{"id": "3d2BWD", "name": "Inferior", "author": "TAKUSAKU", "description": "Inferior's hazy ideas will create a bright future for the world.", "tags": ["flow", "inferior"], "likes": 2, "viewed": 89, "date": "1590075839", "time_retrieved": "2024-06-20T20:06:00.765690", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv =  (2.*fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n      \n    uv *= 30.*abs(1.1 + sin(iTime*0.1));\n    \n    float len;\n    \n    for (int i = 0; i < 10; i++) {\n    len = length(uv);\n        \n        uv.x +=  sin(uv.y + iTime * 0.3)*1.;\n        uv.y +=  cos(uv.x + iTime * 1.0 + cos(len * 1.0))*1.;\n    }\n    \n    len *= cos(len*0.3)+ sin(iTime * 0.3);\n    \n    len -= 3.;\n    \n    vec3 col = vec3(cos(len + 0.2), cos(len + 0.1), cos(len - 0.05));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3d2BWD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3d2fDw", "name": "Planet Shader", "author": "mrange", "description": "License CC0: Planet Shader\nI have been experimenting with space themed shaders", "tags": ["raytracing", "space"], "likes": 16, "viewed": 424, "date": "1590167107", "time_retrieved": "2024-06-20T20:06:01.945363", "image_code": "// License CC0: Planet Shader\n//  I have been experimenting with space themed shaders\n#define PI           3.141592654\n#define TAU          (2.0*PI)\n\n#define TIME         (iTime)\n#define RESOLUTION   iResolution\n#define PERIOD       30.0\n#define PERIODS      4.0\n#define FADETIME     2.0\n#define TPERIOD      (mod(TIME, PERIOD))\n#define NPERIOD      (int(mod(TIME/PERIOD, PERIODS)))\n\nconst vec3  sunDirection = normalize(vec3(0.0, 0.1, -10.0));\nconst vec3  sunColor1    = vec3(1.0, 0.8, 0.8);\nconst vec3  sunColor2    = vec3(1.0, 0.8, 0.9);\nconst vec3  planetPos    = vec3(0.0);\nconst float planetRadii  = 10.0;\n\nvec3 tanh3(vec3 c) {\n  return vec3(tanh(c.x), tanh(c.y), tanh(c.z));\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nvec2 raySphere(vec3 ro, vec3 rd, vec3 center, float radius) {\n  vec3 m = ro - center.xyz;\n  float b = dot(m, rd);\n  float c = dot(m, m) - radius*radius;\n  if(c > 0.0 && b > 0.0) return vec2(-1.0, -1.0);\n  float discr = b * b - c;\n  if(discr < 0.0) return vec2(-1.0);\n  float normalMultiplier = 1.0;\n  float s = sqrt(discr);\n  float t0 = -b - s;\n  float t1 = -b + s;;\n  return vec2(t0, t1);\n}\n\nvec3 scaleCol(vec3 c, float s, float r) {\n  float o = sqrt(s/r);\n  float i = s/o;\n  return tanh3(c*i)*o;\n}\n\nvec3 skyColor(vec3 rd) {\n  float diff = max(dot(rd, sunDirection), 0.0);\n  vec3 col = vec3(0.0);\n  col += scaleCol(pow(diff, 4.0*200.0)*sunColor1, 8.0, 0.25);\n  col += scaleCol(pow(diff, 4.0*50.0)*sunColor2, 1.0, 0.25);\n  return col;\n}\n\nfloat psin(float a) {\n  return 0.5 + 0.5*sin(a);\n}\n\nfloat pcos(float a) {\n  return 0.5 + 0.5*cos(a);\n}\n\nfloat spow(float v, float p) {\n  return sign(v)*pow(abs(v), p);\n}\n\nvec4 rings(vec2 p) {\n  float pl = length(p);\n  float pdf = pl-22.0;\n  pdf = abs(pdf) - 3.0;\n  pdf = abs(pdf) - 2.0;\n  pdf = abs(pdf) - 1.0;\n  vec4 pcol = vec4(1.0);\n  pcol.xyz = mix(vec3(1.0, 0.8, 0.75), vec3(1.0, 1.0, 1.0), 0.5 - 0.5*cos(15.0*pl))*sunColor1;\n  pcol.xyz = pow(pcol.xyz, vec3(0.75));\n  pcol.w = psin(20.0*pl)*psin(14.0*pl)*psin(21.0*pl);\n  pcol.w *= 0.5*step(pdf, 0.0);\n  return pcol;\n}\n\nvec4 planet(vec3 ro, vec3 rd, vec3 skyCol, inout float pd) {\n  vec4 col = vec4(0.0);\n\n  vec2 si = raySphere(ro, rd, planetPos, planetRadii);\n  vec3 sp = ro + rd*si.x;\n  vec3 sn = normalize(sp - planetPos);\n  vec3 sr = reflect(rd, sn);\n  vec3 sref = skyColor(sr);\n  float sfres = pow(1.0-abs(dot(rd, sn)), 15.0);\n  float sdiff = max(dot(sunDirection, sn), 0.0);\n  float sf = (si.y - si.x)/(2.0*planetRadii);\n  float sl = (1.0-smoothstep(0.2, 0.7, sf));\n  vec3 sbeer = exp(-6.0*vec3(0.3, 0.25, 0.15)*sf)*sl;\n  float srayl = pow(1.0 - abs(dot(rd, sn)), 5.0);\n\n  float slo = atan(sp.z, sp.x);\n  float slat = PI*sp.y/planetRadii;\n  vec3 scol = vec3(0.8);\n\n  scol = mix(scol, vec3(0.7, 0.7, 0.8), pow(pcos(20.0*slat), 5.0));\n  scol = mix(scol, vec3(0.75, 0.7, 0.8), pow(pcos(14.0*slat), 20.0));\n  scol = mix(scol, vec3(0.2), pow(pcos(21.0*slat)*pcos(13.0*slat+1.0), 15.0));  \n  scol = tanh3(scol);\n  scol *= pow(sunColor1, vec3(0.66));  \n  scol += vec3(0.0, 0.0, srayl*0.5) ;\n\n  if (si.x < si.y) {\n    col.xyz = sfres*sref + pow(skyCol, vec3(0.85))*sbeer + scol*pow(sdiff, 0.75);\n    col.w = 1.0;\n    pd = si.x;\n  }\n\n  return col;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 skyCol = skyColor(rd);  \n  \n  vec4 col = vec4(skyCol, 1.0);\n  float cold = 10000.0;\n\n  vec4 pcol = planet(ro, rd, skyCol, cold);\n\n  col.xyz = mix(col.xyz, pcol.xyz, pcol.w);\n\n  float rsd = (0.0 - ro.y)/rd.y;\n  vec3 rsp = ro + rd*rsd;\n  vec4 rscol = rings(rsp.xz); \n  vec3 rsn = vec3(0.0, 1.0, 0.0);\n  \n  rscol.w = pow(rscol.w, 1.0*pow(abs(dot(rd, rsn)), 0.4));\n\n  vec2 psi = raySphere(rsp, sunDirection, planetPos, planetRadii);\n  rscol.xyz *= (1.0  - smoothstep(0.0, 1.0, (psi.y - psi.x)/(2.0*planetRadii)));\n  \n  col.xyz = mix(col.xyz, rscol.xyz, rscol.w*step(rsd, cold));\n  \n  return col.xyz;\n}\n\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvec3 fragment(vec3 ro, vec3 uu, vec3 vv, vec3 ww, vec2 p) {\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.5*ww);\n  vec3 col = render(ro, rd);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  float tperiod = TPERIOD;\n  int period = NPERIOD;\n  vec3 ro = vec3(0.0, 0.0, 52.0);\n  vec3 la = vec3(0.0, 0.0,0.0);\n  vec3 up = vec3(-0.0, 1.0, 0.0);\n\n  if (period == 0) {\n    ro = vec3(0.0, 0.0, 52.0);\n    ro.y += tperiod*15.0/PERIOD+2.0;\n    la = vec3(0.0, 0.0, -1000000.0);\n  } else if (period == 1) {\n    ro = vec3(00.0, 15.0, -50.0);\n    ro.y -= 10.0*tperiod/PERIOD;\n    rot(ro.xz,-2.0*tperiod/PERIOD-TAU/10.0);\n  } else if (period == 2) {\n    ro = vec3(0.0, 5.0, 30.0);\n    la = vec3(0.0, 0.0, -1000000.0);\n    ro.x += -10.0*tperiod/PERIOD;\n    ro.y += 17.0*tperiod/PERIOD;\n    ro.z += 90.0*tperiod/PERIOD;\n    up = vec3(-1.0, 1.0, 0.0);\n  } else if (period == 3) {\n    ro = vec3(00.0, 0.0, -25.0);\n    rot(ro.yz, 1.0-0.25*tperiod/PERIOD);\n    la = vec3(0.0, 0.0, 0.0);\n    up = vec3(-0.25, 1.0, 0.0);\n  }\n  \n  \n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww));\n  vec3 vv = normalize(cross(ww,uu));\n\n  float s = 2.0/RESOLUTION.y;\n\n  vec2 o1 = vec2(1.0/8.0, 3.0/8.0)*s;\n  vec2 o2 = vec2(-3.0/8.0, 1.0/8.0)*s;\n\n  vec3 col = vec3(0.0);\n\n  // https://blog.demofox.org/2015/04/23/4-rook-antialiasing-rgss/  \n  col += fragment(ro, uu, vv, ww, p+o1);\n  col += fragment(ro, uu, vv, ww, p-o1);\n  col += fragment(ro, uu, vv, ww, p+o2);\n  col += fragment(ro, uu, vv, ww, p-o2);\n  \n  col*=0.25;\n\n  col = postProcess(col, q);\n \n  float fadeIn = smoothstep(0.0, FADETIME, tperiod);\n  float fadeOut = 1.0 - smoothstep(PERIOD - FADETIME, PERIOD, tperiod);\n  col *= fadeIn;\n  col *= fadeOut;\n\n  fragColor = vec4(col, 1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc0-1.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3d2fDw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3d2fzR", "name": "HearBeat", "author": "Castor", "description": "click to move the heart.", "tags": ["heart"], "likes": 0, "viewed": 47, "date": "1589376598", "time_retrieved": "2024-06-20T20:06:01.945363", "image_code": "#define PI 3.141593\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = fragCoord/iResolution.xy;\n    \n    // Normalise la position du cursor [0;1]\n    vec2 cursorPos = iMouse.xy/iResolution.xy;\n    \n    //\n\tvec2 q = p - cursorPos;\n    \n    // Couleur du coeur\n    vec3 col = vec3(1,0.2,0.2);\n\n\n    \n    //Variables coeur\n    float sizeHeart = 0.2;\n    float pulseSize = 0.08;\n    float pulseFrequency = 2.0;\n\tfloat heightHeart = 1.3;\n    \n    //Elargissement du coeur\n    q.y = ((1.0/heightHeart)*q.y - abs(q.x) * sqrt(50.0- abs(q.x))/10.0);\n    \n    //Pulsation du coeur et taille du coeur\n    float r = sizeHeart +pow(abs(pulseSize*sin(PI*pulseFrequency *iTime)),2.0);\n    \n    //CrÃ©e un flou autour du coeur ( lissage )\n    float heart = smoothstep(r, r+0.005,length( q ));\n    \n    // Inverse la coloration ( car le noir est rouge et inversement)\n    col *= 1.0 - heart;\n    \n    // Output to screen\n    fragColor = vec4(col,0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3d2fzR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dBBWK", "name": "Alien artifact", "author": "jarble", "description": "For some reason, this raymarched object appears to change its shape as the camera angle changes.", "tags": ["raymarching"], "likes": 0, "viewed": 214, "date": "1590781378", "time_retrieved": "2024-06-20T20:06:03.023078", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.0001;\n\nvec3 hash33(vec3 p3)\n{\n    //surface color\n    return fract((p3+.2)/p3.zyx);\n}\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 p) {    \n    return (length(p*sin(p))-.4)/5.0;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(10.0*sin(iTime/10.0), 10.0*sin(iTime/10.0), 10.0*cos(iTime/10.0));\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = hash33((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dBBWK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dBfW3", "name": "Detail Discs", "author": "spalmer", "description": "an even simpler variation of Fabrice's toy [url]https://shadertoy.com/view/wdBfzd[/url], to help work out the kinks of the kerning.  Mouse to zoom and pan.", "tags": ["distance", "hypertexture"], "likes": 1, "viewed": 76, "date": "1590933499", "time_retrieved": "2024-06-20T20:06:03.786185", "image_code": "// fork of \"Detail Spheres\" https://shadertoy.com/view/wsjfWK but even simpler!!! for debugging algo\n// fork of \"3d details distrib on surface\" by FabriceNeyret2 https://shadertoy.com/view/wdBfzd\n// but with discs instead to help debug the marching and sdf\n\nconst float\n    rad = .5   // macro disc radius\n  , grid = 24.  // grid density in each direction\n  , size = .3 / grid //.01   // detail radius (use smaller Eps for hit and normals!) \n  , pi = acos(-1.);\n\nconst vec3 skyColor = vec3(.3,.5,.7)\n, ambient  = vec3(.2)\n, diffuse  = vec3(.5);\nconst vec2 lightDir = normalize(vec2(.2,.9));\n\n// Fabrice's short hue\n#define hue(v)     (.6 + .6 * cos(6.3*(v) + vec3(0,23,21)))\n#define hash12(n)  fract(sin(n+vec2(0.,12.345))*43758.5453)\n#define hash22(n)  hash12(dot(n,vec2(1,13.1)))\n\n// spalmer's discs modifications\n\nfloat dshape(vec2 p)\n{\n    return abs(length(p) - rad*.67) - rad*.33; //length(c) - rad; // torus or sphere or ...\n}\n\nvec2 nshape(vec2 p)\n{\n    const float e = 1e-3;\n    float d = dshape(p)\n    , du = dshape(p + vec2(e,0))\n    , dv = dshape(p + vec2(0,e));\n    return normalize(vec2(du,dv)-d);\n    //return normalize(vec2(dFdx(d),dFdy(d)));\n    //return normalize(p); // old HACK not actually measuring the gradient, hard coded for disc shape\n}\n\n\nfloat distrib(vec2 p, inout vec2 C, inout vec3 id)  // return dist; C=pos, id=detail color id\n{\n    float d = 1e15;\n    vec2 ip = floor(p * grid) - 1.;\n    for (int k=0; k<9; ++k) {               // visit 3x3 neighborhood\n        vec2 p0 = ip + vec2(k%3,k/3)        // cell id\n        , c = (p0 + hash22(p0)) / grid;     // cell sample location back in world space\n    \tfloat l = dshape(c);\n\t\tif (l < 0.) continue;\n        //if (l > size) continue;             // only consider cells close enough to surface!\n        if (l > 4.*size) continue;\n        if (l > size) {\n        \tvec2 grad = nshape(c);\t    \n        \tc -= (l - size) * grad;         // snap to touch surface - if move outside the cell it won't work though!\n            l = size;\n        }\n        //l = max(l, .2*size);                // not *too* small!\n        //l = min(l, 1.*size);                // not too big!\n        //l = size;                           // force all same size\n        float d0 = distance(c,p) - l/1.;    // hardcoded simple disc shape TODO generalize to function\n        if (d0 < d)\n            d=d0, C=c, id = vec3(hue(6.*c.xyx)); // keep closest sample info\n    }\n    return d;\n}\n\nfloat dist2scene(vec2 p, inout vec3 id) \n{\n    vec2 P = vec2(0);\n    float v = dshape(p)                    // distance to macro disc\n        , d = distrib(p, P, id);           // dist to closest valid detail. P=center, id\n    if (d < v) v = d;                      // hit a detail\n    else id = vec3(.5);                    // hit nothing or the big disc (or leave the voronoi id)\n    return v;\n}\n\nfloat shadedNormal(vec2 p, float v) // given point and known closest distance at point,\n{\n    vec3 id; float epsL = 2e-4             // smaller eps for better precision\n    , d = dist2scene(p+epsL*lightDir, id)  // second sample toward light\n    , dx = (d-v)/epsL;                     // cheap directional derivative\n    return clamp(dx * .5 + .5, 0., 1.)     // approximates wrap shading  \n         * exp2(min(0., 4./size*v));       // fade w depth\n}\n\nvoid mainImage(out vec4 O, vec2 u)\n{\n    vec2 R = iResolution.xy,\n         q = (2.*u - R) / R.y,\n         M = (2.*iMouse.xy - R) / R.y;\n    //if (M==vec2(0)) M=vec2(-.5); // no effect?!\n    float scale = .18\n    , l = 1.-rad-4.*size\n    , d = 9e9;\n    // set camera\n    if (iMouse.z <= 0.) { // camera shake \n    \tfloat t=.2*iTime, B=.03;   M += B*vec2(cos(t), sin(t));\n        scale *= 2.1;\n        M *= .7;\n        M += 1.3;\n    }\n    vec2 cameraPos = M - 1.3;\n  \tq -= cameraPos;\n    q *= scale;\n    vec3 \n    , col\n    , id = vec3(0);\n    if (dot(q,q) < pow(rad+size*4., 2.)) // don't bother in corners of the screen where there's no way to see any details!\n        d = dist2scene(q, id); \n\t\n    if (d < 1e-7) {                 // hit?\n        float alpha = clamp(.5-.5*d*R.y, 0., 1.); // antialiasing\n        vec3 c = id * diffuse;      // detail color\n        c *= shadedNormal(q, d);    // shading\n        c += ambient;\n \t    col = mix(skyColor, c, alpha);\n    } else {\n        col = skyColor;\n    }\n      \n    O = vec4(sqrt(col), 1);\n}\n\n    //if (length(q) >= .5 && length(q) <= .51) O = vec4(1); else O = vec4(0); return; // DEBUG\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dBfW3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dBfzK", "name": "Origami Kaleidescope", "author": "jayprich", "description": "Colour depends on final relative angle of a path toward the point taking steps with decreasing size where each turn is a multiples of a time varying angle.", "tags": ["iterate"], "likes": 0, "viewed": 216, "date": "1590333011", "time_retrieved": "2024-06-20T20:06:03.787039", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float a=.6+.1*mod(.03*iTime,1.);\n    float b=sqrt(1.-a*a);\n    float c=a/b;\n    mat2 m=mat2(a,-b,b,a);\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = vec2(-.6,-.2)+.7*uv;\n\tuv.x *= iResolution.x/iResolution.y;\n    for(int i=8;i>0;i--){\n     while(uv.y>0.||uv.x>c*uv.y)uv*=m;\n     uv*=.85;\n     uv+=vec2(.07,-.035);\n    }\n\tfloat d = .4+.2*atan(uv.x,uv.y);\n\tfragColor = vec4(vec3(d,d*d,1.-d),1.);\n    if(uv.x-uv.y<.05)fragColor=vec4(0.,.5,0.,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dBfzK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dByDG", "name": "Hw9 - Subsurface Scattering", "author": "vmoniqb", "description": "hw9", "tags": ["raycasting"], "likes": 0, "viewed": 54, "date": "1588872643", "time_retrieved": "2024-06-20T20:06:05.332896", "image_code": "const float FOVY = 3.14159 * 0.25;\nconst int RAY_STEPS = 256;\n\nconst float AO_DIST = 0.085;\nconst float AO_KVAL = 2.0;\n\nconst float SHADOW_HARDNESS = 6.0;\n\n// The larger the DISTORTION, the smaller the glow\nconst float DISTORTION = 0.2;\n// The higher GLOW is, the smaller the glow of the subsurface scattering\nconst float GLOW = 2.0;\n// The higher the BSSRDF_SCALE, the brighter the scattered light\nconst float BSSRDF_SCALE = 4.0;\n// Boost the shadowed areas in the subsurface glow with this\nconst float AMBIENT = 0.25;\n\n    \nstruct Intersection\n{\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\t// Assign every object in scene a unique ID int\n};\n    \n\n    \nvoid pR(inout vec2 p, float a)\n{\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvec3 rotatePtY(vec3 pt, float a)\n{    \n    pR(pt.yz, 0.);\n    pR(pt.xz, a);\n    pR(pt.xy, 0.);\n    \n    return pt;\n}\n\nvec3 rotatePtX(vec3 pt, float a)\n{    \n    pR(pt.yz, a);\n    pR(pt.xz, 0.);\n    pR(pt.xy, 0.);\n    \n    return pt;\n}\n\n// 2D rotation about the y-axis\nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\n\nvoid rayCast(vec3 eye, vec3 ref, vec2 ndc, out vec3 dir) {    \n    // Compute camera axis\n    vec3 F = ref - eye;\n    vec3 R = normalize(cross(F, vec3(0,1,0)));\n    vec3 U = normalize(cross(R, F));\n    \n    vec3 V = U * length(F) * tan(FOVY * 0.5);\n    vec3 H = R * length(F) * tan(FOVY * 0.5) * float(iResolution.x) / iResolution.y;\n    \n    vec3 p = ref + ndc.x * H + ndc.y * V; \n    \n    dir = normalize(p - eye);\n}\n\n    \n// SHAPE SDFs\nfloat sphere(vec3 p, float r, vec3 c) {\n\treturn distance(p, c) - r;\n}\n\nfloat cube(vec3 p, vec3 c) {\n    return length(max(abs(p) - c, 0.0));\n}\n\nfloat squarePlane(vec3 p, vec4 n)\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat torus(vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q) - t.y;\n}\n\n\n#define SPHERE_SDF\t \tsphere(pos + vec3(-5.0, 0.0, 0.0), 4.0, vec3(0.0, 0.0, 0.0))\n#define SPHERE_ID\t\t1\n#define CUBE_SDF\t\tcube(rotatePtY(pos + vec3(0.0, 1.5, 6.0), 0.5), vec3(1.5, 3., 1.5))\n#define CUBE_ID\t\t\t2\n#define TORUS_SDF\t\ttorus(rotatePtX(rotatePtY(pos + vec3(0.0, 0.2, -6.0), -0.4), -0.7), vec2(2.0, 0.75))\n#define TORUS_ID\t\t3\n#define FLOOR_SDF\t\tsquarePlane(pos + vec3(0.0, 2.0, 0.0), vec4(0.0, 1.0, 0.0, 1.0))\n#define FLOOR_ID\t\t4\n#define LIGHT_SDF\t\tsphere(pos + vec3(-0.5, 0.0, 0.0), 2.5, lightPos)\n#define LIGHT_ID\t\t5\n\nvoid sceneMap3D(vec3 pos, out float t, out int obj, vec3 lightPos) {\n    t = SPHERE_SDF;\n    obj = SPHERE_ID;\n    \n    float t2;\n    if ((t2 = CUBE_SDF) < t) {\n    \tt = t2;\n      \tobj = CUBE_ID;\n    }\n    \n    if ((t2 = TORUS_SDF) < t) {\n    \tt = t2;\n      \tobj = TORUS_ID;\n    }\n    \n    if ((t2 = FLOOR_SDF) < t) {\n    \tt = t2;\n      \tobj = FLOOR_ID;\n    }\n    \n    if ((t2 = LIGHT_SDF) < t) {\n    \tt = t2;\n    \tobj = LIGHT_ID;\n    }\n}\n\n\nfloat sceneMap3D(vec3 pos, vec3 lightPos) {\n    float t = SPHERE_SDF;\n    \n    float t2;\n    if ((t2 = CUBE_SDF) < t) {\n    \tt = t2;\n    }\n    \n    if ((t2 = TORUS_SDF) < t) {\n    \tt = t2;\n    }\n    \n    if ((t2 = FLOOR_SDF) < t) {\n    \tt = t2;\n    }\n    \n    if ((t2 = LIGHT_SDF) < t) {\n    \tt = t2;\n    }\n    \n    return t;\n}\n\n\nfloat shadowMap3D(vec3 pos) {\n    float t = SPHERE_SDF;\n    \n    float t2;\n    if ((t2 = CUBE_SDF) < t) {\n    \tt = t2;\n    }\n    \n    if ((t2 = TORUS_SDF) < t) {\n    \tt = t2;\n    }\n    \n    if ((t2 = FLOOR_SDF) < t) {\n    \tt = t2;\n    }\n    \n    return t;\n}\n\n\nvec3 computeNormal(vec3 pos, vec3 lightPos) {\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( sceneMap3D(pos + epsilon.yxx, lightPos) - sceneMap3D(pos - epsilon.yxx, lightPos),\n                            sceneMap3D(pos + epsilon.xyx, lightPos) - sceneMap3D(pos - epsilon.xyx, lightPos),\n                            sceneMap3D(pos + epsilon.xxy, lightPos) - sceneMap3D(pos - epsilon.xxy, lightPos)));\n}\n\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj, vec3 lightPos) {\n    t = 0.001;\n    \n    for (int i = 0; i < RAY_STEPS; ++i) {\n    \tvec3 pos = origin + t * dir;\n        float m; // Minimum distance from this point to an object in the scene\n        sceneMap3D(pos, m, hitObj, lightPos);\n        if (m < 0.01) {\n        \treturn;\n        }\n        t += m;\n    }\n\t// We hit nothing\n    t = -1.0;\n    hitObj = -1;\n}\n\n\nfloat fiveTapAO(vec3 p, vec3 n, float k) {\n    float aoSum = 0.0;\n    for(float i = 0.0; i < 5.0; ++i) {\n        float coeff = 1.0 / pow(2.0, i);\n        aoSum += coeff * (i * AO_DIST - shadowMap3D(p + n * i * AO_DIST));\n    }\n    return 1.0 - k * aoSum;\n}\n\n\nfloat softShadow(vec3 dir, vec3 origin, float min_t, float k) {\n    float res = 1.0;\n    float t = min_t;\n    for(int i = 0; i < RAY_STEPS; ++i) {\n        float m = shadowMap3D(origin + t * dir);\n        if(m < 0.0001) {\n            return 0.0;\n        }\n        res = min(res, k * m / t);\n        t += m;\n    }\n    return res;\n}\n\n\nfloat subsurfaceColor(vec3 lightDir, vec3 n, vec3 view, float thin) {\n\tvec3 scatterDir = lightDir + n * DISTORTION;\n\tfloat lightReachingEye = pow(clamp(dot(view, -scatterDir), 0.0, 1.0), GLOW) * BSSRDF_SCALE;\n\tfloat attenuation = max(0.0, dot(n, lightDir) + dot(view, -lightDir));\n\tfloat totalLight = attenuation * (lightReachingEye + AMBIENT) * thin;\n    return totalLight;\n}\n\nvoid contrast( inout vec3 color, in float c) {\n    float t = 0.5 - c * 0.5; \n    color.rgb = color.rgb * c + t;\n}\n\nvec3 computeMaterial(int hitObj, vec3 p, vec3 n, vec3 lightVec, vec3 view, float thin) {\n    float lambert = max(0.0, dot(n, lightVec));\n    \n    switch(hitObj) {\n        // Sphere\n        case SPHERE_ID:\n        vec3 color1 = vec3(1.0, 0.5, 1.2) * vec3(1.0, 0.7, 0.4) * max(0.0, dot(n, lightVec)) * softShadow(lightVec, p, 0.1, SHADOW_HARDNESS);\n        color1 = color1 + vec3(0.6, 1.0, 0.75) * subsurfaceColor(lightVec, n, view, thin) * vec3(1.0, 0.88, 0.7);\n        //contrast(color1, 1.5);\n        return color1;\n        break;\n        // Cube\n        case CUBE_ID:\n        vec3 color2 = vec3(1.0, 0.88, 0.7) * vec3(1.0, 0.7, 0.5) * lambert * softShadow(lightVec, p, 0.1, SHADOW_HARDNESS);\n        return color2 + vec3(1.0, 0.5, 0.6) * subsurfaceColor(lightVec, n, view, thin) * vec3(1.0, 0.88, 0.7);\n        break;\n        // Torus\n        case TORUS_ID:\n        vec3 color3 = vec3(1.0, 0.88, 0.7) * vec3(1.0, 0.65, 0.45) * max(0.0, dot(n, lightVec)) * softShadow(lightVec, p, 0.1, SHADOW_HARDNESS);\n        return color3 + vec3(0.4, 0.4, 0.8) * subsurfaceColor(lightVec, n, view, thin) * vec3(1.0, 0.88, 0.7);\n        break;\n        // Box\n        case FLOOR_ID:\n        vec4 color4 = texture(iChannel0, vec2(p.xz / 10.0));\n        return vec3(1.0, 1.0, 1.0) * vec3(color4) * max(0.0, dot(n, lightVec)) * softShadow(lightVec, p, 0.1, SHADOW_HARDNESS);\n        break;\n        // Light\n        case LIGHT_ID:\n        return vec3(1.0, 0.88, 0.7);\n        break;\n        // Background\n        case -1:\n        return vec3(0.0);\n        break;\n    }\n    return vec3(1.0);\n}\n\n\nIntersection sdf3D(vec3 dir, vec3 eye, vec3 lightPos) {\n\tfloat t;\n    int hitObj;\n    march(eye, dir, t, hitObj, lightPos);\n    \n    vec3 isect = eye + t * dir;\n    vec3 nor = computeNormal(isect, lightPos);\n    vec3 lightDir = normalize(lightPos - isect);\n    float thickness = fiveTapAO(isect, -nor, AO_KVAL);\n        \n    vec3 surfaceColor = computeMaterial(hitObj, isect, nor, lightDir, normalize(eye - isect), thickness);\n        \n    return Intersection(t, surfaceColor, isect, hitObj);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec3 lightPos = rotateY(vec3(12.0, 4.0, -6.0), iTime * 0.5);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // Convert to range [-1,1]\n    uv = uv * 2.0 - vec2(1.0, 1.0);\n    \n    vec3 eye = rotateY(vec3(0.0, 0.0, 15.0), sin(30.0) * 3.14159 * 0.5);\n    vec3 ref = vec3(0, 0, 0);\n    vec3 rayDir;\n    \n    rayCast(eye, ref, uv, rayDir);\n    \n    Intersection isect = sdf3D(rayDir, eye, lightPos);\n\n    // Output to screen\n    fragColor = vec4(isect.color, 1.);\n}\n", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dByDG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dfBW7", "name": "Shader9_Dela Vega", "author": "zerotojiro", "description": "Turning windmills on a sunny day", "tags": ["midtems"], "likes": 2, "viewed": 204, "date": "1588323980", "time_retrieved": "2024-06-20T20:06:05.338483", "image_code": "float circle(vec2 uv, float radius, float blur,  vec2 pos)\n{\n     \n    float d = distance(pos,uv);\n    float value = smoothstep(radius, radius + blur, d);\n    \n    return value; \n}\n\nfloat rect (vec2 uv, vec2 pos, vec2 size)\n{\n\tfloat value = step(pos.x - size.x/2.,uv.x) - step(pos.x + size.x/2.,uv.x);\n    return value *= step(pos.y - size.y/2.,uv.y) - step(pos.y + size.y/2.,uv.y);\n}\n\nfloat distLine(vec2 p, vec2 a, vec2 b){\n\tvec2 pa = p-a;\n    vec2 ba = b-a;\n    float t = clamp(dot(pa, ba)/dot(ba, ba),0., 1.);\n    return length(pa-ba*t);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b){\n\tfloat d = distLine(p,a,b);\n    float m = 0.9*smoothstep(.01,.001, d/30.);\n    \n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tfloat ratio = iResolution.x/iResolution.y;\n    uv.x *= ratio;\n    \n    vec2 pos1 = vec2(.7 * ratio, .7);\n    vec2 pos2 = vec2(.4 * ratio, .7);\n    vec2 pos3 = vec2(.2 * ratio, .7);\n    \n    vec2 b1Pos = vec2(.7 *ratio, .4);\n    vec2 b2Pos = vec2(.4 *ratio, .4);\n    vec2 b3Pos = vec2(.2 *ratio, .4);\n    \n    vec2 sunPos = vec2(.1, 3.4);\n    \n    float dist = distance(pos1, uv) * 2.0;\n    float dist2 = distance(pos2, uv) * 2.0;\n    float dist3 = distance(pos3, uv) * 2.0;\n    \n    vec2 uv1 = uv;\n    uv1 -= pos1;\n    \n    vec2 uv2 = uv;\n    uv2 -= pos2;\n    \n    vec2 uv3 = uv;\n    uv3 -= pos3;\n    \n    float angle = atan(uv1.y, uv1.x) + iTime;\n    float angle2 = atan(uv2.y, uv2.x) + iTime;\n    float angle3 = atan(uv3.y, uv3.x) + iTime;\n\n    float radius = sin((angle+iTime*3.)*3.);\n    radius *= .6;\n    \n    float radius2 = sin((angle2+iTime*3.)*3.);\n    radius2 *= .45;\n    \n    float radius3 = sin((angle3+iTime*3.)*3.);\n    radius3 *= .3;\n    \n    float value = 1.-smoothstep(radius, radius +.0, dist);\n    float value2 = 1.-smoothstep(radius2, radius2 +.0, dist2);\n    float value3 = 1.-smoothstep(radius3, radius3 +.0, dist3);\n    \n    float cap1 = circle(uv, .04, 0., pos1);\n    float cap2 = circle(uv, .03, 0., pos2);\n    float cap3 = circle(uv, .02, 0., pos3);\n    \n    float back1 = circle(uv, .07, 0., pos1);\n    float back2 = circle(uv, .05, 0., pos2);\n    float back3 = circle(uv, .03, 0., pos3);\n    \n    float bar1 = rect(uv, b1Pos, vec2(.08, .6));\n    float bar2 = rect(uv, b2Pos, vec2(.06, .6));\n    float bar3 = rect(uv, b3Pos, vec2(.04, .6));\n    \n    float m = line(uv,vec2(-.1, .2), vec2(2., -.15));\n    \n    float sun = circle(uv, .5, 3., sunPos);\n    \n    vec3 color = vec3(.7294, .8980, .9686);\n    color = mix(vec3(1., 1., 0.), color, sun);\n    \n    color = mix(color, vec3(.9), bar1);\n    color = mix(vec3(.9), color, back1);\n    color = mix(color, vec3(.7), value);\n    color = mix(vec3(.9), color, cap1);\n    \n    color = mix(color, vec3(.9), bar2);\n    color = mix(vec3(.9), color, back2);\n    color = mix(color, vec3(.7), value2);\n    color = mix(vec3(.9), color, cap2);\n    \n    color = mix(color, vec3(.9), bar3);\n    color = mix(vec3(.9), color, back3);\n    color = mix(color, vec3(.7), value3);\n    color = mix(vec3(.9), color, cap3);\n  \n    color = mix(color, vec3(0., 1., 0.), m);\n    \n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dfBW7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dffWs", "name": "glow //test", "author": "tr0sle", "description": "testing some stuff", "tags": ["test", "lines", "glow"], "likes": 1, "viewed": 99, "date": "1589249199", "time_retrieved": "2024-06-20T20:06:05.339010", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    \n    float cor = 0.0;\n\n \n\n    \n    for (int i = 0; i < 10; i++)\n    {\n        \n        float radius = 0.5;\n        float rad = radians(360.0 / 5.0) * float(i);\n       \n        \n        cor += 0.005 * (abs(sin(iTime/2.)) + 1.) / length(uv + vec2(radius * cos(rad), radius * sin(rad)));\n     cor += 0.001 * (abs(cos(iTime/5.)) + 1.) / length(uv + vec2(radius * sin(rad), radius * cos(rad)));\n        \n        uv.x += (sin(iTime*5.) / 20.0);\n        uv.y += (cos(iTime*5.) / 20.0);\n\n    }\n    \n       \n    \n    \n    \n\n    // Output to screen\n    fragColor = vec4(vec3(cor - 0.5 + 0.5*cos(iTime+vec3(0,2,4))), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dffWs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dffzs", "name": "I meaan, it's something", "author": "MeHigh_", "description": "Thank's  for the support", "tags": ["circles"], "likes": 5, "viewed": 83, "date": "1588837680", "time_retrieved": "2024-06-20T20:06:05.339010", "image_code": "#define SCALE 10.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = SCALE * (2. * fragCoord - iResolution.xy) / iResolution.y \n              * mat2(1, -1, 1, 1) / sqrt(2.),\n     \t gv = fract(uv) - .5,\n         id = floor(uv);\n    \n    float t = iTime;\n    float m = 0.;\n\n    for(int k = 0; k < 9; ++k) {\n        vec2 off = vec2(k % 3, k / 3) - 1.;\n        float l = length(gv - off) - 1.5 * (sin(t - length(id + off) * .3) * .5 + .5);\n        m += (1. - 2. * m) * smoothstep(.7, -.7, l / min(.05, fwidth(l)));\n    }\n    \n    fragColor = vec4(m);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dffzs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3djBRh", "name": "Imagyx-Julia", "author": "Imagyx", "description": "Julia with Color-Palette ", "tags": ["fractal"], "likes": 1, "viewed": 48, "date": "1589479439", "time_retrieved": "2024-06-20T20:06:05.339010", "image_code": "\n/*\n Formula by IQ, with added translation (qd) and elongation/compression (qc)\n*/\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d, in float qc, in float qd){\n    return a + b * sin(2.0 * 3.14159265359 * (c * t * qc + d  + qd));\n}\n\n/*\n   wrong z^2+c\n*/\nfloat julia(in vec2 ri, in vec2 c, in float time){\n    float zr = (ri.x-0.5)*2.25;\n    float zi = (ri.y-0.5)*2.5;\n    float r = c.x;\n    float i = c.y;\n    float max = time;\n    for(float k=0.0;k<max;k++){\n        float t = 1.35*zr*zr - zi*zi + r;\n        zi = 2.35*zr*zi + i;\n        zr = t;\n        if(zr*zr+zi*zi > 1000.0){\n            return k/max;\n        }\n    }\n    return 1.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float time = iTime;\n//    time = 0.0;\n    \n    // Coloring\n    float t2 = pow(uv.x, 0.5)*0.5 *-0.5*pow(uv.y,0.5);\n    vec3 col = pal(t2, vec3(0.5),vec3(0.25),vec3(0.5),vec3(0.8,0.5,0.2),3.0,time);\n    float u = 0.35+mod(time*0.25,0.75);\n    u = u*u*200.0;\n    float r= 0.4 + cos(time*0.37)*0.3;\n    vec2 c = vec2(sin(time)*r, cos(time)*r);\n    col = col*0.7 + col*vec3(julia(uv,c,u));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3djBRh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3djBzK", "name": "twisty stars", "author": "HaleyHalcyon", "description": "spiral", "tags": ["spiral"], "likes": 4, "viewed": 113, "date": "1590412051", "time_retrieved": "2024-06-20T20:06:05.683936", "image_code": "const float PI = 3.14159265;\nconst float PI_2 = PI / 2.;\n\nfloat fold(float x) {\n    return abs(mod(x, 2.0) - 1.0);\n}\n\nfloat foldPlus(float x) {\n    return log(1.0 + fold(x));\n}\n\nfloat smoothThres(float x, float strength) {\n    return smoothstep(0.5 - strength, 0.5 + strength, x);\n}\n\nfloat smoothFold(float x, float strength) {\n    return smoothThres(fold(x), strength);\n}\n\nvec3 colMap(float x, vec3 a, vec3 b) {\n    return a * (1.0 - x) + b * x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = fract(iTime * 64. / 60.);\n    \n    // Normalized pixel coordinates\n    float scale = min(iResolution.x, iResolution.y);\n    vec2 uv = fragCoord / scale;\n\tuv -= iResolution.xy / scale / 2.;\n    uv *= 2.;\n    float dist = log(uv.x*uv.x+uv.y*uv.y); // not real distance, but useful for log spirals\n    float angle = atan(uv.y, uv.x) / PI;\n    \n    //angle -= t * 1. / 5.;\n    \n    float twistiness = 0.5 * (fold(t * 2.) - 0.5);\n    twistiness += cos(t * 2. * PI) * 0.2;\n    \n    float value = foldPlus(angle * 5. + (dist - 1.) * twistiness);\n    \n    value = smoothFold(value * 1.5 + dist * 1. + t * 02.0, 0.05);\n    \n    vec3 colA0 = vec3(1.0, 0.3, 0.8);\n    vec3 colA1 = vec3(0.2, 0.4, 0.7);\n    vec3 colB0 = vec3(0.6, 0.2, 0.4);\n    vec3 colB1 = vec3(0.4, 0.8, 1.0);\n    vec3 colA = colMap(value, colA0, colA1);\n    vec3 colB = colMap(value, colB0, colB1);\n    \n    vec3 col = colMap(smoothFold((angle * 5. + 0.5) + (dist - 1.) * twistiness, 0.02),\n                     colA, colB);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3djBzK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3djcR3", "name": "Subsurface Scattering - cis461", "author": "sharond106", "description": "Subsurface scattering approximation", "tags": ["subsurface"], "likes": 0, "viewed": 108, "date": "1588872894", "time_retrieved": "2024-06-20T20:06:06.950723", "image_code": "const float FOVY = 0.25 * 3.141569;\nconst int RAY_STEPS = 256;\n\n#define SPHERE_SDF sdfSphere(pos, vec3(0.5, .8, 5), .2)\n#define SPHERE_ID 1\n#define SPHERE2_SDF sdfSphere(pos, vec3(-0.5, .8, 5), .2)\n#define SPHERE2_ID 2\n#define SPHERE3_SDF sdfSphere(pos, vec3(0, .5, 5), .3)\n#define SPHERE3_ID 3\n#define SPHERE4_SDF sdfSphere(pos, vec3(0, -.3, 5), .1)\n#define SPHERE4_ID 4\n#define SPHERE5_SDF sdfSphere(pos, vec3(0, .5, 7), 2.)\n#define SPHERE5_ID 5\n\nstruct Intersection {\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n};\n    \nmat4 inverseTransform(vec3 translate, vec3 rotate, vec3 scale) {\n    mat4 s;\n    // matrices indexed to columns!\n    s[0] = vec4(scale.x, 0., 0., 0.);\n    s[1] = vec4(0., scale.y, 0., 0.);\n    s[2] = vec4(0., 0., scale.z, 0.);\n\ts[3] = vec4(0., 0., 0., 1.);                                     \n                                    \n    rotate.x = radians(rotate.x);\n    rotate.y = radians(rotate.y);\n    rotate.z = radians(rotate.z);\n      \n    mat4 r_x;\n    r_x[0] = vec4(1., 0., 0., 0.);\n    r_x[1] = vec4(0., cos(rotate.x), sin(rotate.x), 0.);\n    r_x[2] = vec4(0., -sin(rotate.x), cos(rotate.x), 0.);\n    r_x[3] = vec4(0., 0., 0., 1.);\n                                    \n                                    \n    mat4 r_y;\n    r_y[0] = vec4(cos(rotate.y), 0., -sin(rotate.y), 0.);\n    r_y[1] = vec4(0., 1, 0., 0.);\n    r_y[2] = vec4(sin(rotate.y), 0., cos(rotate.y), 0.);\n    r_y[3] = vec4(0., 0., 0., 1.);\n\n    mat4 r_z;\n    r_z[0] = vec4(cos(rotate.z), sin(rotate.z), 0., 0.);\n    r_z[1] = vec4(-sin(rotate.z), cos(rotate.z), 0., 0.);\n    r_z[2] = vec4(0., 0., 1., 0.);\n    r_z[3] = vec4(0., 0., 0., 1.);\n\n    mat4 r = r_x * r_y * r_z;\n    \n    mat4 t;\n    t[0] = vec4(1., 0., 0., 0.);\n    t[1] = vec4(0., 1., 0., 0.);\n    t[2] = vec4(0., 0., 1., 0.);\n    t[3] = vec4(translate.x, translate.y, translate.z, 1.); \n    \n    return inverse(t * r * s);      \n}\n    \nfloat sdfPlane(vec3 p, mat4 inverseT) {\n    p = vec3(inverseT * vec4(p, 1.));\n    float dot = dot(p, vec3(0., 0., 1.));\n    if (abs(dot) < 0.0001) {\n        // n must be normalized\n        if (p.x >= -.5 && p.x <= 0.5 && p.y >= -0.5 && p.y <= 0.5) {\n            return 0.;  \n        }\n        return 324234.;\n    }\n    float dist = 0.f;\n    if (abs(p.x) > 0.5) {\n        dist += ((p.x - 0.5) * (p.x - 0.5));\n    }\n    if (abs(p.y) > 0.5) {\n        dist += ((p.y - 0.5) * (p.y - 0.5));\n    }\n    dist += abs(p.z) * abs(p.z);\n    return sqrt(dist);\n} \n\n// Box with side lengths b\nfloat sdfBox(vec3 p, vec3 scale, mat4 inverseT)\n{\n    p = vec3(inverseT * vec4(p, 1.));\n    vec3 q = vec3(abs(p.x), abs(p.y), abs(p.z)) - vec3(.5);\n    float d = q.x;\n    d = max(d,q.y);\n    d = max(d,q.z);\n    return d * min(min(scale.x, scale.y), scale.z);\n}\n\n\nfloat sdfSphere(vec3 p, vec3 c, float r) {\n    return distance(p, c) - r;\n}\n\nvoid sceneMap3D(vec3 pos, out float t, out int objectHit) {\n\tt = SPHERE_SDF;\n    objectHit = SPHERE_ID;\n    float t2;\n\n    if ((t2 = SPHERE2_SDF) < t) {\n        t = t2;\n        objectHit = SPHERE2_ID;\n    }\n    if ((t2 = SPHERE3_SDF) < t) {\n        t = t2;\n        objectHit = SPHERE3_ID;\n    }\n    if ((t2 = SPHERE4_SDF) < t) {\n        t = t2;\n        objectHit = SPHERE4_ID;\n    }\n    if ((t2 = SPHERE5_SDF) < t) {\n        t = t2;\n        objectHit = SPHERE5_ID;\n   }\n}\n\n// called by computeNormal\nfloat sceneMap3D(vec3 pos) {\n    float t;\n    int obj;\n    sceneMap3D(pos, t, obj);\n    return t;\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int objectHit) {\n    t = 0.001;\n    for (int i = 0; i < RAY_STEPS; i++) {\n        vec3 pos = origin + t * dir;\n        float min;\n        sceneMap3D(pos, min, objectHit);\n        if (min < 0.01) {\n            return;\n        }\n        t += min;\n    }\n    t = -1.;\n    objectHit = -1;\n}\n\nvec3 computeNormal(vec3 p, vec3 lightPos) {\n    vec3 epsilon = vec3(0., .001, 0.);\n    return normalize(vec3(sceneMap3D(p + epsilon.yxx) - sceneMap3D(p - epsilon.yxx),\n                          sceneMap3D(p + epsilon.xyx) - sceneMap3D(p - epsilon.xyx),\n                     \t  sceneMap3D(p + epsilon.xxy) - sceneMap3D(p - epsilon.xxy)));\n}\n\n\n// The larger the DISTORTION, the smaller the glow\nconst float DISTORTION = 0.2;\n// The higher GLOW is, the smaller the glow of the subsurface scattering\nconst float GLOW = 3.;\n// The higher the BSSRDF_SCALE, the brighter the scattered light\nconst float SCALE = 3.0;\n// Boost the shadowed areas in the subsurface glow with this\nconst float AMBIENT = 0.;\n\n\nfloat subsurfaceColor(vec3 lightDir, vec3 normal, vec3 viewVec, float thickness) {\n    vec3 scatteredLightDir = lightDir + normal * DISTORTION;\n    float lightReachingEye = pow(clamp(dot(viewVec, -scatteredLightDir), 0.0, 1.0), GLOW) * SCALE;\n    float attenuation = 1.0;\n    //attenuation = max(0.0, dot(normal, lightDir) + dot(viewVec, -lightDir));\n\tfloat totalLight = attenuation * (lightReachingEye + AMBIENT) * thickness;\n    return totalLight;\n}\n\n#define DIST 0.085\n\nfloat fiveTapAO(vec3 p, vec3 n, float k) {\n    float sum = 0.0;\n    for(float i = 0.0; i < 5.0; ++i) {\n        float coeff = 1.0 / pow(2.0, i);\n        sum += coeff * (i * DIST - sceneMap3D(p + n * i * DIST));\n    }\n    return 1.0 - k * sum;\n}\n\nvec3 computeMaterial(int objectHit, vec3 p, vec3 n, vec3 lightPos, vec3 view) {\n    vec3 lightDir = normalize(lightPos - p);\n    float lambert = max(0., dot(n, lightDir));\n    vec3 color;\n    float subsurface = subsurfaceColor(lightDir, n, view, fiveTapAO(p, -n, 2.0));\n    \n    switch (objectHit) {\n        case SPHERE_ID:\n        color = vec3(153., 204., 255.) / vec3(255.);\n        break;\n        case SPHERE2_ID:\n        color = vec3(153., 204., 255.) / vec3(255.);\n        break;\n        case SPHERE3_ID:\n        color =  vec3(255, 255, 0) / vec3(255.);\n        break;\n        case SPHERE4_ID:\n        color =  vec3(255, 102, 153) / vec3(255.);\n        break;\n        case SPHERE5_ID:\n        color = vec3(255, 204, 204) / vec3(255.);\n        break;\n    }\n    return color * lambert + color * subsurface;\n}\n\nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\nIntersection sdf3D(vec3 eye, vec3 dir) {\n    float t;\n    int objectHit;\n    march(eye, dir, t, objectHit);\n    vec3 isect = eye + t * dir;\n    \n    vec3 nor = computeNormal(isect, vec3(0, 0, 0));\n    \n    vec3 lightPos =  rotateY(vec3(0, 2., 20), sin(iTime * 0.5));\n    \n    vec3 color = computeMaterial(objectHit, isect, nor, lightPos, normalize(eye - isect));\n    \n    if (objectHit == -1) {\n        color = vec3(0, 0, 0);\n    }\n    \n    return Intersection(t, color, isect, objectHit);\n}\n\nvec3 rayCast(vec3 eye, vec3 ref, vec2 ndc) {\n    vec3 F = ref - eye;\n    vec3 R = normalize(cross(F, vec3(0., 1., 0.)));\n    vec3 U = normalize(cross(R, F));\n    \n    vec3 V = U * length(F) * tan(FOVY * 0.5);\n    vec3 H = R * length(F) * tan(FOVY * 0.5) * float(iResolution.x) / float(iResolution.y);\n    \n    vec3 p = ref + ndc.x * H + ndc.y * V;\n    \n    return normalize(p - eye);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - vec2(1, 1);\n    \n    vec3 eye = vec3(0, 0, 0);\n    vec3 ref = vec3(0, 1, 11);\n    vec3 rayDir = rayCast(eye, ref, uv); \n    \n    Intersection isect = sdf3D(eye, rayDir);\n\n    fragColor = vec4(isect.color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3djcR3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3djfDD", "name": "Turbulent waves", "author": "jarble", "description": "Based on https://www.shadertoy.com/view/3d2BWD", "tags": ["waves", "turbulence"], "likes": 1, "viewed": 240, "date": "1590082311", "time_retrieved": "2024-06-20T20:06:06.950723", "image_code": "//This is based on https://www.shadertoy.com/view/3d2BWD\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv =  (100.*fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    //uv *= 30.*abs(1.1 + sin(iTime*0.1));\n    float len;\n    uv += sin(uv/20.0)/10.0;\n    for (int i = 0; i < 10; i++) {\n    \tlen = length(uv);\n        uv.x += sin(iTime+sin(uv.y))-len/uv.y;\n        uv.y += cos(iTime+cos(uv.x))-len/uv.x;\n    }\n    float col = cos(len);\n    fragColor = vec4(col,col,col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3djfDD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3djfWG", "name": "Wide-angle lens sphere", "author": "TAKUSAKU", "description": "Wide-angle lens sphere", "tags": ["lens", "sphere", "glass", "metal", "angle", "wide"], "likes": 0, "viewed": 87, "date": "1590727323", "time_retrieved": "2024-06-20T20:06:06.950723", "image_code": "#define time iTime\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy, vec2(0.890,-0.900)))*757.153);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat fbm ( in vec2 _st) {\n    float v = sin(time*0.3)*0.1;\n    float a = 0.1;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(1.0), -sin(0.5), acos(0.5));\n    for (int i = 0; i < 3; ++i) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 2.6;\n    }\n    return v;\n}\n\n// 2D rotate\nmat2 rotate(in float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Wide-angle lens is baced on Menger Sponge Variation\n    // https://www.shadertoy.com/view/ldyGWm\n    vec3 st = (vec3(2.0 * fragCoord.xy - iResolution.xy, iResolution.y));\n    st = normalize(vec3(st.xy, sqrt(max(st.z * st.z - dot(st.xy, st.xy) *4.,0.)))) * 0.3;\n    \n    st.xy *= rotate(time*0.1);\n    st.xz *= rotate(time*0.2);\n    \n    vec2 coord = st.xy;\n    coord.x += 0.1*time;\n    coord.y += 0.2*time;    \n    float len; \n    for (int i = 0; i < 3; i++) {\n        len = length(vec2(coord.x, coord.y));  \n        coord.x +=  sin(coord.y + time * 0.620)*0.1;\n        coord.y +=  cos(coord.x + time * 0.164)*0.1;\n    }\n    len -= 3.;\n     \n    vec3 color = vec3(0.);\n\n    vec2 q = vec2(0.);\n    q.x = fbm( st.xy + 1.0);\n    q.y = fbm( st.xy + vec2(-0.450,0.650));\n\n    vec2 r = vec2(0.);\n    r.x = fbm( st.xy + 1.0*q + vec2(0.570,0.520)+ 0.02*time );\n    r.y = fbm( st.xy + 1.0*q + vec2(0.340,-0.570)+ 0.05*time);\n    \n    for (float i = 0.0; i < 3.0; i++) {\n        r += 1.0 / abs(mod(st.y + st.x,((1.0 + sin(time*0.3))*0.48+0.04) * .5 * i) * 1000.);\n        r += 1.0 / abs(mod(st.y - st.x,((1.0 + sin(time*0.3))*0.48+0.04) * .5 * i) * 1000.);\n    }\n    \n    color = mix(color, cos(len + vec3(0.2, 0.0, -0.5)), 1.0);\n    color = mix(vec3(0.730,0.386,0.372), vec3(0.397,0.576,0.667), color);\n    \n    float f = mix(fbm(st.xy+r),fbm(st.xy+r*0.1),step(0.,abs(st.y)-abs(st.x)));   \n    color = 2.0*(f*f*f+.6*f*f+.5*f)*color;\n    \n    fragColor = vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3djfWG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3djfWm", "name": "Bokeh tree background", "author": "pohlt", "description": "I'm shooting for something like this: https://www.istockphoto.com/de/video/bokeh-abstrakte-baum-hintergrund-gm826252336-134111413\n\nNot there yet, as you can see. Any input is appreciated.", "tags": ["bokeh", "background"], "likes": 1, "viewed": 121, "date": "1590256889", "time_retrieved": "2024-06-20T20:06:06.950723", "image_code": "precision lowp float;\n\n\n#define PI 3.14159265358979\n#define R 0.07\n#define D 0.05\n\n\nconst vec3 base_colors[] = vec3[](\n    vec3(1.0, 5.0, 0.0),\n    vec3(2.0, 2.0, 9.0),\n    vec3(5.0, 4.0, 2.0),\n    vec3(4.0, 4.0, 5.0)\n);\n\n\n// from https://www.shadertoy.com/view/lsf3WH\nfloat hash(vec2 p) {\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0, 0.0) ), \n                     hash( i + vec2(1.0, 0.0) ), u.x),\n                mix( hash( i + vec2(0.0, 1.0) ), \n                     hash( i + vec2(1.0, 1.0) ), u.x), u.y);\n}\n\n\n// from https://www.shadertoy.com/view/MsKGWz\nfloat hash12(vec2 p) {\n    float h = dot(p,vec2(127.1, 311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\n\n// from https://www.shadertoy.com/view/MsKGWz\nfloat hash5(float x) {\n    return fract(sin(x)*43758.5453+0.4);\n}\n\n\nfloat disc(vec2 c, vec2 pos) {\n    pos -= c;\n    float d = length(pos / R);\n    if (d > 1.0+D) {\n        return 0.0;\n    }\n    else {\n        float a = atan(pos.y, pos.x);\n        float dm = d + 0.03*(cos(a*5.0+2.5)+1.0);\n        return (0.02+0.01*(\n            ((dm < 1.0+D) ? smoothstep(0.0, 1.0, dm) : 0.0) -\n            smoothstep(1.0, 1.0+D, dm)))*\n            (0.75+0.25*noise(75.0*pos*mat2( 1.6,  1.2, -1.2,  1.6 )));\n    }\n}\n    \n    \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect = iResolution.y/iResolution.x;\n    uv.y *= aspect;\n\tvec3 col = mix(vec3(0.02, 0.05, 0.00),\n                   vec3(0.10, 0.20, 0.05),\n                   dot(vec2(0.6, 0.6/aspect), uv)+\n                   //0.4*noise(20.0*uv)-0.2+\n                   0.2*hash12(uv)-0.1);\n    \n    for (float i=100.0; i>0.0; i--) {\n        int m = int(i) & 3;\n        float x = 1.1*hash5(2.0*i+3.0)-0.05;\n        float y = 1.1*hash5(5.0*i)-0.05;\n        float dx = 0.05*sin(0.3*iTime+0.01*i) + 0.05*sin(0.4*iTime+0.01*i);\n        float dy = 0.03*sin(0.2*iTime+0.100*i) + 0.03*sin(0.3*iTime+0.100*i);\n        float b = pow((1.0+cos(0.75*iTime+0.1*i)), 0.5) * (0.7+0.3*cos(0.51*iTime+0.03*i));\n        col += (base_colors[m] + 2.0*vec3(hash5(x), hash5(y), hash5(x+y))) *\n            disc(vec2(x+dx, (y+dy)*aspect), uv) * b;\n    }\n\n    // tone mapping and gamma\n    fragColor = vec4(pow(col/(col+1.0), vec3(1.0)/2.2), 1.0);\n}\n", "image_inputs": [{"id": "MlS3zK", "previewfilepath": "https://soundcloud.com/maltempoeffects/25-1-meadow-summer-day", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/maltempoeffects/25-1-meadow-summer-day", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3djfWm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3djfWW", "name": "Big Rubik Pseudosolver", "author": "dr2", "description": "Big (Rubik's Revenge) or small cubes; each shuffle is different (only pretending to solve)", "tags": ["cube", "puzzle"], "likes": 11, "viewed": 293, "date": "1590068902", "time_retrieved": "2024-06-20T20:06:06.965379", "image_code": "// \"Big Rubik Pseudosolver\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define SIZE4  1  // =1 for 4^3 cube; =0 for 3^3\n\n#define AA     0  // optional antialiasing\n\nmat3 VToRMat (vec3 v, float a);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat Hashff (float p);\n\n#define VAR_ZERO min (iFrame, 0)\n\nmat3 vuMat;\nvec2 qBlk;\nfloat tCur, dstFar, bSize, rSeed;\nconst float pi = 3.1415927;\n\nvec4 BlkHit (vec3 ro, vec3 rd, vec3 p, mat3 m)\n{\n  vec3 rdm, v, tm, tp, u, fcBlk;\n  float dMin, dn, df;\n  dMin = dstFar;\n  rdm = m * rd;\n  v = (m * ro - p) / rdm;\n  tp = bSize / abs (rdm) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  if (df > 0. && dn < min (df, dMin)) {\n    dMin = dn;\n    fcBlk = - sign (rdm) * step (tm.zxy, tm) * step (tm.yzx, tm);\n    u = (v + dn) * rdm;\n  }\n  if (dMin < dstFar) {\n    qBlk = vec2 (dot (u.zxy, fcBlk), dot (u.yzx, fcBlk));\n  }\n  return vec4 (dMin, fcBlk);\n}\n\nvec4 SphHit (vec3 ro, vec3 rd, float rad)\n{\n  vec3 vn;\n  float b, d, w;\n  b = dot (rd, ro);\n  w = b * b + rad * rad - dot (ro, ro);\n  d = dstFar;\n  if (w > 0.) {\n    d = - b - sqrt (w);\n    vn = (ro + d * rd) / rad;\n  }\n  return vec4 (d, vn);\n}\n\n#if SIZE4\nconst float nbE = 4.;\nconst float nTwist = 28.;\n#else\nconst float nbE = 3.;\nconst float nTwist = 22.;\n#endif\n\nmat3 RotSeq (vec3 bId, float nt, float aRot)\n{                     // Derived rotation matrix sequence from Kali's \"Rubik\"\n  mat3 rMat, m;\n  vec3 ax[3], vSlice;\n  vec2 e;\n  float s, sa;\n  e = vec2 (1., 0.);\n  ax[0] = e.xyy;\n  ax[1] = e.yxy;\n  ax[2] = e.yyx;\n  rMat = mat3 (e.xyy, e.yxy, e.yyx);\n  for (float n = float (VAR_ZERO); n < nTwist; n ++) {\n    if (n > nt) break;\n    s = mod (n + floor (6. * Hashff (99. + rSeed)), 6.);\n    sa = sign (s - 2.5);\n    s = mod (s, 3.);\n    vSlice = (s == 0.) ? e.xyy : ((s == 1.) ? e.yxy : e.yyx);\n    if (length ((bId + 0.5 * (nbE + 1.)) * vSlice) - 1. == floor (nbE * Hashff (n + rSeed))) {\n      m = VToRMat (sa * ((s == 0.) ? ax[0] : ((s == 1.) ? ax[1] : ax[2])),\n         0.5 * pi * ((n < nt) ? 1. : aRot));\n      for (int k = 0; k < 3; k ++) ax[k] = m * ax[k];\n      rMat = m * rMat;\n      if (n < nt) bId = VToRMat (sa * vSlice, -0.5 * pi) * bId;\n    }\n  }\n  return rMat;\n}\n\nfloat LabSym (vec2 p)\n{\n  vec2 q;\n  float d, r;\n  r = length (p);\n  d = max (min (0.06 - abs (0.1 - abs (r - 0.8)), p.y), min (0.06 - abs (p.y), 1.1 - abs (p.x)));\n  q = Rot2D (p, 2. * pi * floor (16. * ((r > 0.) ? atan (p.y, - p.x) / (2. * pi) : 0.) + 0.5) / 16.);\n  d = max (d, min (min (0.06 - abs (q.y), 0.2 - abs (q.x + 1.1)), p.y + 0.1));\n  q.x += 1.5;\n  d = max (d, min (0.1 - length (q), p.y + 0.1));\n  return d;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  mat3 rMat, rMatH;\n  vec4 col4, bs4;\n  vec3 col, vn, ltDir, fcBlk, bId, bidH, cc[6], de3, ld, bLab;\n  vec2 qBlkH, de;\n  float dstBlk, dstSphr, d, nt, tCyc, shSpd, tWait, aRot, dSum, sSum, bMin;\n  cc[0] = vec3 (1., 0.2, 0.2);\n  cc[1] = vec3 (1., 0.4, 0.2);\n  cc[2] = vec3 (0.2, 0.2, 1.);\n  cc[3] = vec3 (0.2, 1., 0.2);\n  cc[4] = vec3 (1., 1., 0.2);\n  cc[5] = vec3 (1., 1., 1.);\n  bSize = 0.48;\n  shSpd = 10.;\n  tWait = 3.;\n  tCyc = (nTwist + tWait) * (1. + 1. / shSpd) + tWait;\n  nt = nTwist - max (0., mod (tCur, tCyc) - tWait);\n  if (nt + tWait < 0.) nt = - shSpd * (nt + tWait);\n  aRot = smoothstep (0.1, 0.9, max (0., fract (nt) * sign (nt)));\n  nt = max (0., floor (nt));\n  rSeed = 17.77 * floor ((tCur + (nTwist + tWait) / shSpd + tWait) / tCyc + 1.);\n  bMin = 0.5 * (nbE - 1.) - 0.5;\n  bLab = vec3 (0., 0., -1.);\n  if (nbE == 4.) bLab -= 0.5;\n  dstBlk = dstFar;\n  for (float j = float (VAR_ZERO); j < nbE * nbE * nbE; j ++) {\n    bId = vec3 (mod (j, nbE), mod (floor (j / nbE), nbE), floor (j / (nbE * nbE))) - 0.5 * (nbE - 1.);\n    if (Maxv3 (abs (bId)) > bMin) {\n      rMat = RotSeq (bId, nt, aRot);\n      bs4 = BlkHit (ro, rd, bId, rMat);\n      d = bs4.x;\n      if (d < dstBlk) {\n        dstBlk = d;\n        fcBlk = bs4.yzw;\n        rMatH = rMat;\n        qBlkH = qBlk;\n        bidH = bId;\n      }\n    }\n  }\n  bs4 = SphHit (ro, rd, (nbE - 0.2) * bSize);\n  dstSphr = bs4.x;\n  if (min (dstBlk, dstSphr) < dstFar) {\n    if (dstBlk < dstSphr) {\n      ro += dstBlk * rd;\n      de = smoothstep (-0.08, 0., abs (qBlkH.xy) - bSize);\n      de3 = vec3 (0.25 * pi * de * sign (qBlkH.xy), 0.);\n      vn = normalize (fcBlk + ((fcBlk.x != 0.) ? de3.zxy : ((fcBlk.y != 0.) ? de3.xzy : de3))) * rMatH;\n      if (length (max (abs (qBlkH) - bSize + 0.12, 0.)) < 0.07) {\n        if (abs (bidH.x) > bMin && sign (bidH.x) == fcBlk.x ||\n            abs (bidH.y) > bMin && sign (bidH.y) == fcBlk.y ||\n            abs (bidH.z) > bMin && sign (bidH.z) == fcBlk.z) {\n          if      (abs (fcBlk.x) == 1.) col4.rgb = (fcBlk.x > 0.) ? cc[0] : cc[1];\n          else if (abs (fcBlk.y) == 1.) col4.rgb = (fcBlk.y > 0.) ? cc[2] : cc[3];\n          else if (abs (fcBlk.z) == 1.) col4.rgb = (fcBlk.z > 0.) ? cc[4] : cc[5];\n          col4 = vec4 (mix (col4.rgb, vec3 (0.2, 0.2, 0.2), max (de.x, de.y)), 0.2);\n        } else {\n          col4 = vec4 (0.1, 0.1, 0.1, 0.);\n        }\n        if (bidH == bLab && sign (bidH.z) == fcBlk.z)\n           col4 *= 1. - 0.6 * smoothstep (-0.05, 0., LabSym (-16. * (vec2 (0.5, 0.5) * bSize + qBlkH.yx)));\n      } else {\n        col4 = vec4 (0.2, 0.2, 0.2, 0.2);\n      }\n    } else if (dstSphr < dstFar) {\n      ro += dstSphr * rd;\n      vn = bs4.yzw;\n      col4 = vec4 (0.1, 0.1, 0.1, 0.);\n    }\n    dSum = 0.;\n    sSum = 0.;\n    ltDir = normalize (vec3 (1., 1., -0.6));\n    for (int j = 0; j < 4; j ++) {\n      ltDir.xy = Rot2D (ltDir.xy, 0.5 * pi);\n      ld = vuMat * ltDir;\n      dSum += pow (max (dot (vn, ld), 0.), 1.5);\n      sSum += pow (max (dot (normalize (ld - rd), vn), 0.), 32.);\n    }\n    col = col4.rgb * (0.2 + 0.5 * dSum) + col4.a * sSum;\n    col = pow (clamp (col, 0., 1.), vec3 (0.8));\n  } else {\n    col = vec3 (0.6);\n  }\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.15 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az -= 0.04 * pi * tCur;\n    el -= 0.07 * pi * (1. + sin (0.05 * pi * tCur));\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -10. * nbE / 3.);\n  zmFac = 3.7;\n  dstFar = 100.;\n  if (length (uv) < 0.99) {\n#if ! AA\n    const float naa = 1.;\n#else\n    const float naa = 3.;\n#endif  \n    col = vec3 (0.);\n    sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n    for (float a = float (VAR_ZERO); a < naa; a ++) {\n      rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n         sr * (0.667 * a + 0.5) * pi), zmFac));\n      col += (1. / naa) * ShowScene (ro, rd);\n    }\n  } else col = mix (vec3 (0.6), vec3 (0.82), smoothstep (0., 0.1, length (uv) - 0.99));\n  fragColor = vec4 (col, 1.);\n}\n\nmat3 VToRMat (vec3 v, float a)\n{\n  mat3 m;\n  vec3 w, b1, b2;\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  w = (1. - cs.x) * v * v + cs.x;\n  b1 = (1. - cs.x) * v.zyx * v.xzy;\n  b2 = - cs.y * v;\n  m[0][0] = w.x;  m[1][1] = w.y;  m[2][2] = w.z;\n  m[1][2] = b1.x + b2.x;  m[2][1] = b1.x - b2.x;\n  m[2][0] = b1.y + b2.y;  m[0][2] = b1.y - b2.y;\n  m[0][1] = b1.z + b2.z;  m[1][0] = b1.z - b2.z;\n  return m;\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff (float p)\n{\n  return fract (sin (p) * cHashM);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3djfWW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3djfzy", "name": "Ice Reflection", "author": "TAKUSAKU", "description": "ice", "tags": ["reflection", "ice", "block"], "likes": 7, "viewed": 198, "date": "1590302969", "time_retrieved": "2024-06-20T20:06:06.966377", "image_code": "float rand (in vec2 _st) {\n    return fract(sin(dot(_st.xy, vec2(-0.820,-0.840)))*4757.153);\n}\n\nfloat noise (in vec2 _st) {\n\tconst vec2 d = vec2(0., 1.);\n  vec2 b = floor(_st), f = smoothstep(vec2(0.), vec2(0.1,0.3), fract(_st));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nfloat fbm ( in vec2 _st) {\n    float v = sin(iTime*0.5)*0.2;\n    float a = 0.3;\n    vec2 shift = vec2(100.);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(1.0), -sin(0.5), acos(0.5));\n    for (int i = 0; i <3; ++i) {\n        v += a * noise(_st);\n        _st = rot * _st * 2. + shift;\n        a *= 1.5;\n    }\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = (fragCoord * 2. - iResolution.xy) / min(iResolution.x, iResolution.y) * 0.5;\n    \n    vec2 coord = st * 0.2;\n    float len;\n    for (int i = 0; i < 3; i++) {\n        len = length(coord);\n        coord.x +=  sin(coord.y + iTime * 0.1)*2.1;\n        coord.y +=  cos(coord.x + iTime * 0.1 + cos(len * 1.0))*1.;\n    }\n    len -= 3.;\n    \n    vec3 color = vec3(0.);\n\n    vec2 q = vec2(0.);\n    q.x = fbm( st );\n    q.y = fbm( st + vec2(-0.450,0.650));\n\n    vec2 r = vec2(0.);\n    r.x = fbm( st + 1.0*q + vec2(0.570,0.520)+ 0.1*iTime );\n    r.y = fbm( st + 1.0*q + vec2(0.340,-0.570)+ 0.05*iTime);\n    float f = fbm(st+r);\n    \n    color = mix(color, cos(len + vec3(0.5, 0.0, -0.1)), 1.0);\n    color = mix(vec3(0.478,0.738,0.760),vec3(0.563,0.580,0.667),color);\n    \n    fragColor = vec4((f*f*f+.6*f*f+.5*f)*color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3djfzy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3djyDD", "name": "flower_glow", "author": "elle", "description": "strange flower", "tags": ["flower"], "likes": 2, "viewed": 249, "date": "1588410433", "time_retrieved": "2024-06-20T20:06:06.966377", "image_code": "vec3 rotate(vec3 p, float angleX, float angleY)\n{\n    float cosA = cos(angleY);\n\tfloat sinA = sin(angleY);\n\tvec3 r = vec3(p.x, sinA * p.z + cosA * p.y, cosA * p.z - sinA * p.y);\n    cosA = cos(angleX);\n\tsinA = sin(angleX);\n\treturn (-vec3(cosA * r.x - sinA * r.z, r.y, sinA * r.x + cosA * r.z));\n}\n\nfloat flower(vec3 p)\n{\n    float x2 = p.x * p.x;\n    float y2 = p.y * p.y;\n    float z2 = p.z * p.z;\n\treturn (1.44 * x2 + y2 + z2 +\n            1.0 / sqrt(abs(cos((5.0 + cos(0.5 * iTime)) * atan(p.z / p.y)))) +\n    \t\t1.0 / (y2 + z2) + 3.0 / (x2 + y2 + z2) - 7.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n   vec2 aspectRatio = vec2(iResolution.x / iResolution.y, 1.0);\n   vec2 uv =  8.0 * aspectRatio * (fragCoord.xy / iResolution.xy - 0.5);\n    \n   vec2 mouse = 4.0 * (iMouse.xy / iResolution.xy - 0.5);   \n   float d = flower(rotate(vec3(uv.x, uv.y, 2.2), mouse.x+0.5, mouse.y-1.1));\n    \n   vec3 color = vec3(0.5 + 0.5 * cos(0.5 * iTime + 2.0),\n                     0.5 + 0.5 * sin(0.5 * iTime + 4.0),\n                     0.5 + 0.5 * cos(0.5 * iTime + 0.0));\n  \n   fragColor = vec4(color * vec3(d/6.0), 1.0);   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3djyDD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dlBRB", "name": "Circle - Stolen by Visu", "author": "Visual917", "description": "circle...", "tags": ["circle"], "likes": 1, "viewed": 72, "date": "1588527638", "time_retrieved": "2024-06-20T20:06:06.967374", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t    vec2 p = (2.0*gl_FragCoord.xy-iResolution.xy)/iResolution.y;\n\n    float a = atan(p.x,p.y);\n    float r = length(p);\n    vec2 uv = vec2(a/(3.1415926535),r);\n\t\n\t//get the colour\n\tfloat xCol = (uv.x - (iTime / 8.0)) * 3.0;\n\txCol = mod(xCol, 3.0);\n\tvec3 horColour = vec3(0.25, 0.25, 0.25);\n\t\n\tif (xCol < 1.0) {\n\t\t\n\t\thorColour.r += 1.0 - xCol;\n\t\thorColour.g += xCol;\n\t}\n\telse if (xCol < 2.0) {\n\t\t\n\t\txCol -= 1.0;\n\t\thorColour.g += 1.0 - xCol;\n\t\thorColour.b += xCol;\n\t}\n\telse {\n\t\t\n\t\txCol -= 2.0;\n\t\thorColour.b += 1.0 - xCol;\n\t\thorColour.r += xCol;\n\t}\n\t\n\t//background lines\n\tfloat backValue = 1.0;\n\tfloat aspect = iResolution.x / iResolution.y;\n\tif (mod(uv.y * 100.0, 1.0) > 0.75 || mod(uv.x * 100.0 * aspect, 1.0) > 0.75) {\n\t\t\n\t\tbackValue = 1.15;\t\n\t}\n\t\n\tvec3 backLines  = vec3(backValue);\n\t\n\t//main beam\n\tuv = (2.0 * uv) - 1.0;\n\tfloat beamWidth = abs(1.0 / (30.0 * uv.y));\n\tvec3 horBeam = vec3(beamWidth);\n\t\n\tfragColor = vec4(((backLines * horBeam) * horColour), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dlBRB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dlBWS", "name": "voronoi with color scheme", "author": "sidchou", "description": "voronoi with color scheme\n\nreference :\nvoronoi: https://www.shadertoy.com/view/MslGD8\nvoronoi: https://www.shadertoy.com/view/ldl3W8", "tags": ["voronoicolor"], "likes": 1, "viewed": 66, "date": "1588972219", "time_retrieved": "2024-06-20T20:06:06.967374", "image_code": "//color pick\nvec3 color(float t) {\n    vec3 col;\n\tvec3 a = vec3(0.15,0.26,0.91);\n    vec3 b = vec3(0.34,0.78,0.94);\n    vec3 c = vec3(0.89,0.25,0.91);\n    \n    col = step(t,0.333)*a;\n    col +=step(0.333,t)*step(t,0.667)*b;\n    col +=step(0.667,t)*c;\n    \n    return col;\n}\n\n//hash (random) function\nvec2 hash( vec2 p ) {\n    p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); \n    return fract(p);}\n\n// return distance as x, and xy as y\nvec3 voronoi( in vec2 x )\n{\n    vec2 n = floor( x );\n    vec2 f = fract( x );\n\n    vec2 mg, mr;\n    \n\tvec3 m = vec3( 8.0 );\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2  g = vec2( float(i), float(j) );\n        vec2  o = hash( n + g );\n        \n        vec2  r = g - f + o;\n        //o = 0.5 + 0.5*sin( iTime + 6.2831*o );\n \n\t    //vec2  r = g - f; // square\n\t\tfloat d = dot( r, r );\n\n        if( d<m.x ){\n\t\t\tmr = r;\n\t\t\tmg = g;\n            m = vec3( d, o.x,o.y);\n        } \n       \n    }\n    \n    \n    //distance to\n    float md = 8.0 ;\n  for( int j=-2; j<=2; j++ ){\n\tfor( int i=-2; i<=2; i++ ){\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash( n + g );\n        //o = 0.5 + 0.5*sin( iTime + 6.2831*o );\n        //o = 0.2*sin( iTime + 6.2831*o );\n        vec2 r =  g - f + o;\n\n        if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n  }\n\n\n    return vec3( sqrt(m.x), m.y*m.z, md );\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = fragCoord.xy/max(iResolution.x,iResolution.y);\n    p.x-=iTime*.02;\n    p.y-=iTime*.01;\n        \n    // voronoi patterm\n\tvec3 c = voronoi(10.*p);\n    c.y += floor(iTime/5.);\n    \n    //randomize order\n    vec2 hashing = hash(vec2(0.,c.y))*30.;\n\tc.y *= hashing.x*hashing.y;\n    c.y = fract(c.y);\n    \n    // colorize\n    vec3 col;\n    col = vec3(c.y);\n    col = vec3(color(c.y));\n\t\n    //edge\n    vec3 edge = vec3(smoothstep( 0.04, 0.07,c.z));\n\n    col = min(col,edge);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dlBWS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dlBzj", "name": "menger-sponge-va-001", "author": "jorge2017a1", "description": "menger-sponge-va-001", "tags": ["mengerspongeva001"], "likes": 1, "viewed": 80, "date": "1588621722", "time_retrieved": "2024-06-20T20:06:06.970233", "image_code": "//modificado por jorge flores.p --\n//Gracias a ....Created by russ in 2017-03-06\n//https://www.shadertoy.com/view/XsfczB\n    \n\nconst int iter =100;\nconst float eps = 0.001, far = 20.;\nvec3 lDir0 = normalize(vec3(1,2,1)), lDir1 = normalize(vec3(-1,1.0,-2));\nvec3 lCol0 = vec3(1,.8,.5), lCol1 = vec3(.6,0.8,1); \n\n\n#define PI 3.1415926\n\n///-------------------------------------\nconst int MAX_RAY_STEPS = 64;\nconst float RAY_STOP_TRESHOLD = 0.0001;\nconst int MENGER_ITERATIONS = 5;\n///-------------------------------------\n\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3  di = abs(p) - b;\n  float mc = maxcomp(di);\n  return min(mc,length(max(di,0.0)));\n}\n\n\nfloat cylUnion(vec3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(min(xy,min(xz,yz))) - 1.;\n}\n\nfloat cylIntersection(vec3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(max(xy,max(xz,yz))) - 1.;\n}\n\n\n//-------------------------------------------\n\nfloat dsSphere(vec3 center, float r, vec3 point)// basic sphere SDF\n{\n    // point is point pos in space, center is sphere's center, r is its radius\n    return length(point - center) - r;\n}\n\nfloat dsCapsule(vec3 point_a, vec3 point_b, float r, vec3 point_p)//cylinder SDF\n{\n \tvec3 ap = point_p - point_a;\n    vec3 ab = point_b - point_a;\n    float ratio = dot(ap, ab) / dot(ab , ab);\n    ratio = clamp(ratio, 0.0, 1.0);\n    vec3 point_c = point_a + ratio * ab;\n    return length(point_c - point_p) - r;\n}\n\nfloat dsTorus(vec3 center, float r1, float r2, vec3 point)\n{\n \tfloat x = length(point.xz - center.xz) - r1;\n    float y = point.y - center.y;\n    float dist = length(vec2(x,y)) - r2;\n    return dist;\n}\n//--------------------------------------------\n\n//oooooooooooooooooooooooooooooooooooooooooooooooooooo\nfloat sdCross(vec3 p) {\n\tp = abs(p);\n\tvec3 d = vec3(max(p.x, p.y),\n\t\t\t\t  max(p.y, p.z),\n\t\t\t\t  max(p.z, p.x));\n\treturn min(d.x, min(d.y, d.z)) - (1.0 / 3.0);\n}\n\nfloat sdCrossRep(vec3 p) {\n\tvec3 q = mod(p + 1.0, 2.0) - 1.0;\n\treturn sdCross(q);\n}\n\nfloat sdCrossRepScale(vec3 p, float s) {\n\treturn sdCrossRep(p * s) / s;\t\n}\n\n\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\n\n//--------------------------\nfloat DE(vec3 p) {\n\t\n    \n    float scale = 1.435;\n\t\n \n       \n    \n    float dist =sdBox(p- vec3(0.0), vec3(1.0) );\n    \n \n\tfor (int i = 0; i < MENGER_ITERATIONS; i++) {\n\t\tdist = max(dist, -sdCrossRepScale(p, scale));\n\t\tscale *= 3.0;\n\t}\n\n\n    \n    \n\treturn dist;\n}\n\n//oooooooooooooooooooooooooooooooooooooooooooooooooooo\n\n\n\nvec2 march(vec3 ro, vec3 rd){\n\tfloat t=0. , d = far, it = 0.;\n    for (int i=0;i<iter;i++){\n     \tt += (d = DE(ro+t*rd));\n        if(d<eps || t> far) break;\n        it += 1.;\n    }\n    return vec2(t,it/float(iter));\n}\n\nfloat getShadow(vec3 p, vec3 n, vec3 ld){\n    p +=  2. * eps * n;\n    float t=0.,d=far;\n    for(int i=0;i<50;i++){\n        t += (d=DE(p + t*ld));\n        if (d<eps || t>3.) break;\n    }\n    return t<=3. ? 0.1 : 1. ;\n}\n\nvec3 getRay(vec3 ro, vec3 look, vec2 uv){\n    vec3 f = normalize(look - ro);\n    vec3 r = normalize(vec3(f.z,0,-f.x));\n    vec3 u = cross (f,r);\n    return normalize(f + uv.x * r + uv.y * u);\n}\n\nvec3 getNorm(vec3 p){\n    vec2 e = vec2(eps, 0);\n    return normalize(vec3(DE(p+e.xyy)-DE(p-e.xyy),DE(p+e.yxy)-DE(p-e.yxy),DE(p+e.yyx)-DE(p-e.yyx)));\n}\n\nvec3 light(vec3 p, vec3 n){\n    vec3 col = vec3(0.01);\n    for(int i=0;i<2;i++){\n        vec3 ld = (i==0) ? lDir0 : lDir1;\n        float diff = max(dot(n, (ld)),0.);\n        diff *= getShadow(p, n, ld);\n        col += diff * (i==0 ? lCol0 : lCol1);\n    }\n    return col * .7;\n}\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) {\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float time = iTime * 0.5;\n    //float time = iTime * .06;\n    \n    \n\tvec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n  \n    \n    \n    //vec3 ro = vec3(0.5, 0.25, 1.5+ 1.0*cos(time)+time*1.2);\n    vec3 ro = vec3(1.0+sin(iTime), 0.25, 1.0+ 1.0*cos(time));\n     //ro = get_mouse(ro);\n   \n    \n    vec3 rd = getRay(ro, vec3(0.), uv);\n    vec2 hit = march(ro, rd);\n    vec3 p = ro + hit.x*rd;\n    \n    vec3 col = hit.x<far ? light(p, getNorm(p)) : vec3(.1*(1.-length(uv)));\n    \n    \n    col += pow(hit.y,3.);\n\tfragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dlBzj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dlfDs", "name": "Cube + Sphere SDF", "author": "blackle", "description": "generalization of a cube and a sphere, complete with closest-point calculation!", "tags": ["sdf"], "likes": 11, "viewed": 402, "date": "1589378062", "time_retrieved": "2024-06-20T20:06:07.914478", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nvec3 nonzero_sign(vec3 p) {\n    return max(sign(p),vec3(0))*2.-1.;\n}\n\nmat3 sort(vec3 p) {\n    mat3 perm = mat3(1);\n    //there must be a more elegant way to do this...\n    if (p.x > p.y) { p.xy = p.yx; perm *= mat3(0,1,0,1,0,0,0,0,1); }\n    if (p.y > p.z) { p.yz = p.zy; perm *= mat3(1,0,0,0,0,1,0,1,0); }\n    if (p.x > p.y) { p.xy = p.yx; perm *= mat3(0,1,0,1,0,0,0,0,1); }\n    return perm;\n}\n\nvec4 rounded_square(vec3 p, float radius, float sharpness, float offset) {\n    //first we abs and sort the vector so we can work with the cube symmetries\n    vec3 sgn = nonzero_sign(p);\n    p = abs(p);\n    mat3 perm = sort(p);\n    p *= perm;\n    p.z += sharpness;\n\n    //get closest point on defining sphere for this axis\n    float rad = sharpness + radius;\n    vec3 closest = normalize(p)*rad;\n\n    //normalize the closest point so it lies within the axis\n    if (closest.y > closest.z-sharpness) {\n        float a = closest.x;\n        float d = closest.y+closest.z;\n        float k = sharpness;\n        float z = (k + sqrt(d*d*(2.*rad*rad-k*k)/(2.*a*a+d*d)))/2.;\n        float y = z - k;\n        float x = a*(2.*z-k)/d;\n        closest = vec3(x,y,z);\n    \tif (closest.x > closest.z-sharpness) {\n            z = (2.*k + sqrt(3.*rad*rad - 2.*k*k))/3.;\n        \ty = z - k;\n            x = z - k;\n        \tclosest = vec3(x,y,z);\n    \t}\n    }\n    //calculate the distance\n    float side = sign(length(p)-rad);\n    float dist = length(p-closest)*side;\n\n    //map the closest point back to global coordinates\n    closest += normalize(p-closest)*offset*side;\n    if (side == 0.) closest = p;\n    vec3 closest_global = (closest-vec3(0,0,sharpness))*transpose(perm)*sgn;\n\n\treturn vec4(dist-offset, closest_global);\n}\n\nfloat linedist(vec3 p, vec3 a, vec3 b) {\n    float k = dot(p-a,b-a)/dot(b-a,b-a);\n    return distance(p,mix(a,b,clamp(k,0.,1.)));\n}\n\nvec3 srgb(float r, float g, float b) {\n    return vec3(r*r, g*g, b*b);\n}\nvec3 srgb(float k) {\n    return vec3(k*k);\n}\n\nfloat PI = acos(-1.);\nvec3 objcol_glob;\nfloat scene(vec3 p) {\n    float radius = sin(iTime*1.2)*0.2+0.7;\n    float sharpness = pow(asin(sin(iTime*0.7))/PI+1.,8.);\n    float offset = 1.-radius;\n    float dist = rounded_square(p, radius, sharpness, offset).x;\n\tobjcol_glob = srgb(0.5,0.35,0.6);\n    \n    vec3 probe = normalize(vec3(cos(iTime*2.), sin(iTime*2.), cos(iTime*.7)*.3+.3))*2.;\n    vec3 closest = rounded_square(probe, radius, sharpness, offset).yzw;\n    float closestball = length(p-closest)-0.1;\n    float probeball = length(p-probe)-0.1;\n    float probeline = linedist(p, probe, closest) - 0.03;\n    \n    if (closestball < dist) {\n        objcol_glob = srgb(0.2,0.6,0.3);\n        dist = closestball;\n    }\n    if (probeball < dist) {\n        objcol_glob = srgb(0.6,0.2,0.1);\n        dist = probeball;\n    }\n    if (probeline < dist) {\n        objcol_glob = srgb(0.3);\n        dist = probeline;\n    }\n\n    return dist;\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p) - mat3(0.001);\n    return normalize(scene(p)- vec3(scene(k[0]), scene(k[1]), scene(k[2])));\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax,p)*ax, p, cos(ro)) + sin(ro)*cross(ax,p);\n}\n\n\nvec3 shade(vec3 n, vec3 r, vec3 cam, float harmonic, vec3 col, vec3 rot) {\n    float ang = length(rot); vec3 ax = normalize(rot);\n    \n    col = abs(erot(col, vec3(0,0,1), ang*0.1));\n    float fresnel = 1.-abs(dot(cam,n))*0.98;\n    r = erot(r, ax, -ang);\n    float spec = length(sin(r*harmonic)*0.5+0.5)/sqrt(3.);\n    return col*pow(spec+.2,3.) + pow(spec, 12.)*fresnel*1.6;\n}\n\nfloat bayer(vec2 uv) {\n    return (texelFetch(iChannel0, ivec2(uv)%8, 0).x - 0.5)/128.;\n}\n\nfloat antialias(float x) {\n    float pixelsize = 3./iResolution.y;\n    return smoothstep(-pixelsize, pixelsize, x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n    vec3 cam = normalize(vec3(1.6, uv));\n    vec3 init = vec3(-7,0,0);\n\n   \tfloat yrot = 0.5;\n    float zrot = 2.5;\n    if (iMouse.z > 0.) {\n        yrot += -4.*mouse.y;\n        zrot += 4.*mouse.x;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    init = erot(init, vec3(0,0,1), zrot);\n    \n    vec3 p = init;\n    bool hit = false;\n    for (int i = 0; i < 150 && !hit; i++) {\n        float dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p+=dist*cam;\n    }\n    vec3 objcol = objcol_glob;\n    vec3 n = norm(p);\n    vec3 r = reflect(cam, n);\n    \n    vec3 l1 = vec3(0,0,.1);\n    vec3 l2 = vec3(0,1.,0);\n    vec3 l3 = vec3(4.,0,0);\n\n    vec3 col = shade(n, r, cam, 2., objcol, l1);\n    vec3 bg = shade(cam, cam, vec3(0), 2., srgb(0.3), l1);\n    col += shade(n, r, cam, 3.3, objcol, l2)*.6;\n    bg += shade(cam, cam, vec3(0), 3.3, srgb(0.1), l2)*.6;\n    col += shade(n, r, cam, 4., objcol, l3)*.3;\n    bg += shade(cam, cam, vec3(0), 4., srgb(0.3), l3)*.3;\n    fragColor.xyz = sqrt(hit ? col : bg*.4) + bayer(fragCoord);\n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc0-1.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dlfDs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dlfW2", "name": "Wood Grain Texture", "author": "jstrom2002", "description": "Uniform random noise generator adapted from: https://people.sc.fsu.edu/~jburkardt/cpp_src/uniform/uniform.html\nNote: This code is distributed under the GNU LGPL license. See original website for details.\n'cnoise' and helper functions from S.Gustav", "tags": ["noise", "random", "uniform"], "likes": 1, "viewed": 168, "date": "1589114510", "time_retrieved": "2024-06-20T20:06:08.696274", "image_code": "// GLSL textureless classic 2D noise \"cnoise\",\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n//https://github.com/ashima/webgl-noise/blob/master/src/classicnoise2D.glsl\nvec4 mod289(vec4 x)\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n    return mod289(((x * 34.0) + 1.0) * x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec2 fade(vec2 t) {\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec2 P)\n{\n    vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n    Pi = mod289(Pi); // To avoid truncation effects in permutation\n    vec4 ix = Pi.xzxz;\n    vec4 iy = Pi.yyww;\n    vec4 fx = Pf.xzxz;\n    vec4 fy = Pf.yyww;\n\n    vec4 i = permute(permute(ix) + iy);\n\n    vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0;\n    vec4 gy = abs(gx) - 0.5;\n    vec4 tx = floor(gx + 0.5);\n    gx = gx - tx;\n\n    vec2 g00 = vec2(gx.x, gy.x);\n    vec2 g10 = vec2(gx.y, gy.y);\n    vec2 g01 = vec2(gx.z, gy.z);\n    vec2 g11 = vec2(gx.w, gy.w);\n\n    vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n    g00 *= norm.x;\n    g01 *= norm.y;\n    g10 *= norm.z;\n    g11 *= norm.w;\n\n    float n00 = dot(g00, vec2(fx.x, fy.x));\n    float n10 = dot(g10, vec2(fx.y, fy.y));\n    float n01 = dot(g01, vec2(fx.z, fy.z));\n    float n11 = dot(g11, vec2(fx.w, fy.w));\n\n    vec2 fade_xy = fade(Pf.xy);\n    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n    float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n    return 2.3 * n_xy;\n}\n\n\n\n\n//====================================================\n// Uniform sampled noise from John Burkardt's page at\n// https://people.sc.fsu.edu/~jburkardt/cpp_src/uniform/uniform.cpp\nint i4_uniform_0i(inout int seed)\n{\n    const int ia = 16807;\n    const int ib15 = 32768;\n    const int ib16 = 65536;\n    const int ip = 2147483647;\n    int iprhi;\n    int ixhi;\n    int k;\n    int leftlo;\n    int loxa;\n    int value;\n    //\n    //  Don't let SEED be 0.\n    //\n    if (seed == 0)\n    {\n        seed = ip;\n    }\n    //\n    //  Get the 15 high order bits of SEED2.\n    //\n    ixhi = seed / ib16;\n    //\n    //  Get the 16 low bits of SEED and form the low product.\n    //\n    loxa = (seed - ixhi * ib16) * ia;\n    //\n    //  Get the 15 high order bits of the low product.\n    //\n    leftlo = loxa / ib16;\n    //\n    //  Form the 31 highest bits of the full product.\n    //\n    iprhi = ixhi * ia + leftlo;\n    //\n    //  Get overflow past the 31st bit of full product.\n    //\n    k = iprhi / ib15;\n    //\n    //  Assemble all the parts and presubtract IP.  The parentheses are\n    //  essential.\n    //\n    value = (((loxa - leftlo * ib16) - ip)\n        + (iprhi - k * ib15) * ib16) + k;\n    //\n    //  Add IP back in if necessary.\n    //\n    if (value < 0)\n    {\n        value = value + ip;\n    }\n    seed = value;\n\n    return value;\n}\n\n\n//====================================================\n// Uniform wood grain:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    float scale = 100.0;\n    float displacement = float(iFrame)*0.001;\n    \n    // Perlin noise-generated seed w/ displacement factors.\n    int seed = int(cnoise(vec2(fragCoord.x/iResolution.x, fragCoord.y/iResolution.y)+displacement)*scale); \n       \n    float i1 = float(i4_uniform_0i(seed));\n    seed++;\n    float i2 = float(i4_uniform_0i(seed));\n    seed++;\n    float i3 = float(i4_uniform_0i(seed));\n    \n    // convert int -> float\n    i1 = float(i1)/2147483647.0;\n    i2 = float(i2)/2147483647.0;\n    i3 = float(i3)/2147483647.0;\n    \n    // clamp color to range for wood\n    i1 = clamp(i3,0.25,0.32);//R\n    i2 = clamp(i2,0.20,0.22);//G\n    i3 = clamp(i1,0.10,0.11);//B\n    \n    fragColor = vec4(normalize(vec3(i1,i2,i3)) * vec3(1.40,1.50,1.15), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dlfW2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dlfWB", "name": "menger-sponge-va-005", "author": "jorge2017a1", "description": "menger-sponge-va-005", "tags": ["mengerspongeva005"], "likes": 1, "viewed": 69, "date": "1588988067", "time_retrieved": "2024-06-20T20:06:08.696274", "image_code": "//modificado por jorge flores.p --\n//Gracias a ....Created by russ in 2017-03-06\n//https://www.shadertoy.com/view/XsfczB\n    \n\nconst int iter =100;\nconst float eps = 0.001, far = 20.;\nvec3 lDir0 = normalize(vec3(1,2,1)), lDir1 = normalize(vec3(-1,1.0,-2));\nvec3 lCol0 = vec3(1,.8,.5), lCol1 = vec3(.6,0.8,1); \n\n\n#define PI 3.1415926\n\n///-------------------------------------\nconst int MAX_RAY_STEPS = 64;\nconst float RAY_STOP_TRESHOLD = 0.0001;\nconst int MENGER_ITERATIONS = 5;\n///-------------------------------------\n\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3  di = abs(p) - b;\n  float mc = maxcomp(di);\n  return min(mc,length(max(di,0.0)));\n}\n\n\nfloat cylUnion(vec3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(min(xy,min(xz,yz))) - 1.;\n}\n\nfloat cylIntersection(vec3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(max(xy,max(xz,yz))) - 1.;\n}\n\n\n//-------------------------------------------\n\nfloat dsSphere(vec3 center, float r, vec3 point)// basic sphere SDF\n{\n    // point is point pos in space, center is sphere's center, r is its radius\n    return length(point - center) - r;\n}\n\nfloat dsCapsule(vec3 point_a, vec3 point_b, float r, vec3 point_p)//cylinder SDF\n{\n \tvec3 ap = point_p - point_a;\n    vec3 ab = point_b - point_a;\n    float ratio = dot(ap, ab) / dot(ab , ab);\n    ratio = clamp(ratio, 0.0, 1.0);\n    vec3 point_c = point_a + ratio * ab;\n    return length(point_c - point_p) - r;\n}\n\nfloat dsTorus(vec3 center, float r1, float r2, vec3 point)\n{\n \tfloat x = length(point.xz - center.xz) - r1;\n    float y = point.y - center.y;\n    float dist = length(vec2(x,y)) - r2;\n    return dist;\n}\n//--------------------------------------------\n\n//oooooooooooooooooooooooooooooooooooooooooooooooooooo\nfloat sdCross(vec3 p) {\n\tp = abs(p);\n\tvec3 d = vec3(max(p.x, p.y),\n\t\t\t\t  max(p.y, p.z),\n\t\t\t\t  max(p.z, p.x));\n\treturn min(d.x, min(d.y, d.z)) - (1.0 / 3.0);\n}\n\nfloat sdCrossRep(vec3 p) {\n\tvec3 q = mod(p + 1.0, 2.0) - 1.0;\n\treturn sdCross(q);\n}\n\nfloat sdCrossRepScale(vec3 p, float s) {\n\treturn sdCrossRep(p * s) / s;\t\n}\n\n\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\n\n//--------------------------\nfloat DE(vec3 p) {\n\t\n    \n    float scale = 0.55;\n\t\n \n       \n    \n    float dist =sdBox(p- vec3(0.0), vec3(1.0) );\n    float dist2 =sdBox(p- vec3(0.0), vec3(0.35,3.0,0.35) );\n\tdist =dist*2.0-dist2;\n    \n \n\tfor (int i = 0; i < MENGER_ITERATIONS; i++) {\n\t\tdist = max(dist, -sdCrossRepScale(p, scale));\n\t\tscale *= 3.0*sin(scale);\n\t}\n\n\n    \n    \n\treturn dist;\n}\n\n//oooooooooooooooooooooooooooooooooooooooooooooooooooo\n\n\n\nvec2 march(vec3 ro, vec3 rd){\n\tfloat t=0. , d = far, it = 0.;\n    for (int i=0;i<iter;i++){\n     \tt += (d = DE(ro+t*rd));\n        if(d<eps || t> far) break;\n        it += 1.;\n    }\n    return vec2(t,it/float(iter));\n}\n\nfloat getShadow(vec3 p, vec3 n, vec3 ld){\n    p +=  2. * eps * n;\n    float t=0.,d=far;\n    for(int i=0;i<50;i++){\n        t += (d=DE(p + t*ld));\n        if (d<eps || t>3.) break;\n    }\n    return t<=3. ? 0.1 : 1. ;\n}\n\nvec3 getRay(vec3 ro, vec3 look, vec2 uv){\n    vec3 f = normalize(look - ro);\n    vec3 r = normalize(vec3(f.z,0,-f.x));\n    vec3 u = cross (f,r);\n    return normalize(f + uv.x * r + uv.y * u);\n}\n\nvec3 getNorm(vec3 p){\n    vec2 e = vec2(eps, 0);\n    return normalize(vec3(DE(p+e.xyy)-DE(p-e.xyy),DE(p+e.yxy)-DE(p-e.yxy),DE(p+e.yyx)-DE(p-e.yyx)));\n}\n\nvec3 light(vec3 p, vec3 n){\n    vec3 col = vec3(0.01);\n    for(int i=0;i<2;i++){\n        vec3 ld = (i==0) ? lDir0 : lDir1;\n        float diff = max(dot(n, (ld)),0.);\n        diff *= getShadow(p, n, ld);\n        col += diff * (i==0 ? lCol0 : lCol1);\n    }\n    return col * .7;\n}\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) {\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float time = iTime * 0.5;\n    //float time = iTime * .06;\n    \n    \n\tvec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n  \n    \n    \n    //vec3 ro = vec3(0.5, 0.25, 1.5+ 1.0*cos(time)+time*1.2);\n    vec3 ro = vec3(0.5+sin(iTime), 0.25, 1.5+ 2.0*cos(time));\n     //ro = get_mouse(ro);\n   \n    \n    vec3 rd = getRay(ro, vec3(0.), uv);\n    vec2 hit = march(ro, rd);\n    vec3 p = ro + hit.x*rd;\n    \n    vec3 col = hit.x<far ? light(p, getNorm(p)) : vec3(.1*(1.-length(uv)));\n    \n    \n    col += pow(hit.y,3.);\n\tfragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dlfWB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dlfWH", "name": "Gentle Rings", "author": "darknoon", "description": "Just a simple relaxing sine combination", "tags": ["rings"], "likes": 6, "viewed": 319, "date": "1588367654", "time_retrieved": "2024-06-20T20:06:08.696274", "image_code": "#define PI 3.141596\n\n\nvec3 a = vec3(0.5, 0.5, 0.5);\nvec3 b = vec3(0.5, 0.5, 0.5);\nvec3 c = vec3(1.0, 1.0, 1.0);\nvec3 d = vec3(0.00, 0.33, 0.67);\n\n// iq color mapper\nvec3 colorMap(float t) {\n\treturn (a + b * cos(2. * PI * (c * t + d)));\n}\n\nvoid mainImage(out vec4 o, in vec2 i)\n{\n    vec2 uv = i / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float r = length(uv);\n    float a = atan(uv.y, uv.x);\n    \n    float ring = 1.5 + 0.8 * sin(PI * 0.25 * iTime);\n    \n    float kr = 0.5 - 0.5 * cos(7. * PI * r); \n    vec3 kq = 0.5 - 0.5 * sin(ring*vec3(30., 29.3, 28.6) * r - 6.0 * iTime + PI * vec3(-0.05, 0.5, 1.0));\n    vec3 c = kr * (0.1 + kq * (1. - 0.5* colorMap(a / PI))) * (0.5 + 0.5 * sin(11.*a + 22.5*r));\n\n    // Output to screen\n    o.rgb = mix(vec3(0.0, 0.0, 0.2), c, 0.85);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dlfWH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dlfzj", "name": "Journey to Another World V.2", "author": "julianlumia", "description": ":)", "tags": ["tunnelthingy"], "likes": 15, "viewed": 272, "date": "1588625078", "time_retrieved": "2024-06-20T20:06:08.696274", "image_code": "\n#define pi acos(-1.)\n\nconst int Iterations=13;\nconst float detail=.00009;\nconst float Scale=1.9999;\nvec3 lightdir=normalize(vec3(0.,-1,-1.));\n\n  float eyes3;\n\nfloat ot=0.;\nfloat det=0.;\n\nfloat hitfloor;\nfloat hitrock;\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nmat3 rotate( in vec3 v, in float angle)\n{\n float c = cos(radians(angle));\n float s = sin(radians(angle));\t\n return mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n (1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n (1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z\n );\n}\nfloat tt;\n\nfloat dBox(vec3 p, vec3 s)\n{\n return length (max (abs(p)-s,0.));   \n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\n\nfloat g1;\nfloat g2;\nfloat g3;\nfloat g4;\nfloat g5;\n\nfloat de(vec3 pos) {\n vec3 o5 = pos;\n hitfloor=0.;\n hitrock=0.;\n vec3 p10; \n vec3 p2 = pos;\n vec3 p=pos;\n p.z=abs(0.5-mod(pos.z,1.));\n float DEfactor=1.;\n for (int i=0; i<Iterations; i++) {\n  p = abs(p)-vec3(.452,2.,0.);  \n  float r2 = dot(p*vec3(0.,10.,1.), p)*.2;\n  float sc=Scale/clamp(r2,sin(abs(p.y-0.0)*.0)*.00,1.);\n  p*=sc; \n  DEfactor*=sc;\n  p = p - vec3(0.1,13.,0.5);\n }\n //definition\n float d=length(p)/DEfactor-.0003;\n vec3 from=vec3(-0.049,3.059,-iTime*-0.002+0.025);\n float sep = 0.0;  \n p2.x = abs(p2.x-sep);\n from.x = abs(from.x-sep); \n p2 -= vec3(-0.32,0,.0);\n vec3 p3 =  p2;\n p2 -=from;\n float gap = .03; \n from.z = mod(from.z + gap,2. * gap) - gap;\n p2.z = mod(p2.z + gap,2. * gap) - gap;\n gap = .03;   \n from.x = mod(from.x + gap,2. * gap) - gap;\n p2.x = mod(p2.x + gap,2. * gap) - gap;\n float e;\n float   the = sin(pos.z*30.+iTime)*0.1;\n //p2.xy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n the = sin(pos.z*20.+iTime)*.1;\n// p2.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n the = (0.2)*1.;\n //p2.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n from.xz *= -mat2(cos(the), -sin(the), sin(the), cos(the));  \n p2.x=(p2.x)-0.003;\n float eyes2;\n float y2;\n float eyes6;\n for(float i=0.; i<4.; i++)    \n {\n p2 = rotate( ( vec3(0.,1., 0. )),90.)*p2;\n p2.xz += 1.*0.006;\n float e = dBox(p2,vec3(0.006,.03,.000));\n float nose = dBox(p2,vec3(abs(sin(p2.y*100.+2.2)*2.)*0.001,(sin(p2.x*10.+2.2)*2.)*.002,abs(sin(p2.y*100.+2.2))*.003));    \n vec3 p3 =  p2;\n p3 -= vec3(-0.000,0.002,0.0001);\n p3.xz = abs(p3.xz)-.003;\n float eyes = sdRoundBox(p3,vec3(0.0019,.0013,.02),0.0001);  \n p3 -= vec3(-0.002,0.007,-0.002);\n eyes2 = dBox(p3,vec3(0.0004,.002,.0002));  \n p3 -= vec3(-0.0002,-0.045,0.01);\n\n float eyes5 = dBox(p3,vec3(0.04,.0003,.002));  \n\n vec3 p4 =  p2;\n p4.xz = abs(p4.xz)-0.001;\n p4 -= vec3(0.000,-0.006,0.001);\n p4.y = abs(p4.y)-0.0005;\n float mond = dBox(p4,vec3(0.002,(sin(p4.x*-200.+0.4)*4.)*.0002,.0001)); \n vec3 p5 =  p2;\n e =smin(e,mond,0.002);\n e = min(e,nose);\n float y =min(eyes2, max(e,-eyes));\n      y = min(y,eyes5);\n\n y2 = y;\n if( y  < d)\n  {\n   d=min(y ,d);\n   eyes3=eyes2;\n   eyes6 = eyes5;\n  }\n }   \n p10=o5-=from;\n float  gap2 = .1; \n p10.z = mod(p10.z + gap2,2. * gap2) - gap2;\n gap2 = .1; \n p10.x = mod(p10.x + gap2,2. * gap2) - gap2;\n       \n vec3 op = p10;\n  the = iTime;  \n vec3 op1 = op-vec3(-0.01,-0.02,0.);\n  //  op1.y = abs(op1.y)-0.02;\n     //   op1.x = abs(op1.x)-0.04;\n\n vec3 snakesize =vec3(.0000,0,0001.);\n op1 =op1-vec3(cos(o5.z*25.+iTime*.3-pi)*5.,sin(o5.z*30.+iTime*3.-pi)-0.0*4.,0)*0.002;\n vec2 box15 = vec2((dBox(op1-vec3(-0.00,0.000,0.), snakesize)),0.);\n box15.x += cos(o5.z*5.-iTime*1.)*0.002+sin(o5.y*1.-iTime-pi*6.)*.001;\n d=min(d,box15.x);\n g3 +=2./(0.0004+pow(abs(box15.x),1.));\n g2 +=2./(0.0004+pow(abs(eyes3),2.));\n g1 +=2./(0.0004+pow(abs(y2),2.));\n g4 +=1./(0.001+pow(abs(eyes6),1.));\n\n\n return d;\n}\n\n\n\nvec3 normal(vec3 p) {\n vec3 e = vec3(0.0,det,0.0);\n return normalize(vec3(\n  de(p+e.yxx)-de(p-e.yxx),\n  de(p+e.xyx)-de(p-e.xyx),\n  de(p+e.xxy)-de(p-e.xxy)\n  )\n );\n\n}\n\n\n\n\nmat2 rot;\n\nvec3 raymarch(in vec3 from, in vec3 dir) \n{\n\tfloat t=iTime;\n\tfloat cc=cos(t*.03); float ss=sin(t*.03);\n    rot=mat2(cc,ss,-ss,cc);\n    vec2 lig=vec2(sin(t*2.)*.6,cos(t)*.25-.25);\n\tfloat fog,glow,d=1., totdist=glow=fog=0.;\n\tvec3 p, col=vec3(0.);\n\tfloat ref=0.;\n\tfloat steps;\n\tfor (int i=0; i<64; i++) {\n\t\tif (d>det && totdist<1.5) {\n\t\t\tp=from+totdist*dir;\n\t\t\td=de(p);\n\t\t\tdet=detail*(0.+totdist*5.);\n\t\t\ttotdist+=d; \n\t\t\tglow+=max(0.,.015-d)*exp(-totdist);\n\t\t\tsteps++;\n\t\t}\n\t}\n\tcol+=glow*vec3(0.,.9,.8)*.44;\n\treturn col; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\ttt=iTime*.5;\n    vec2 uv = fragCoord.xy / iResolution.xy*2.-1.;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec2 mouse=(iMouse.xy/iResolution.xy-.5);\n\tfloat t=iTime*.15;\n\tfloat y=(cos(iTime*.2+3.)+1.);\n\tif (iMouse.z<1.) mouse=vec2(sin(t*3.)*2.,cos(t)+.5)*.04*(.9+y)*min(1.4,iTime*10.);\n\tuv+=mouse*0.5;\n    vec3 from=vec3(sin(iTime)*0.002,3.06,iTime*1.*0.05);\n    float the = sin(iTime*.2)*0.5+0.04;\n\tvec3 dir=normalize(vec3(uv*.85,.5));\n    //dir.xy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    vec3 color=raymarch(from,dir); \n\tcolor=pow(color,vec3(1.6));\n\tcolor=mix(vec3(length(color)),color,.2)*.95;\n\tcolor*= 3.;\n\t//glow at the end of the tunnel\n\t//color *=g4*vec3(.001)*vec3(0.,.5,.0)*.02+0.0;\n\n    color +=g3*vec3(.002)*vec3(0.,1.,.6)*.004+0.0;\n\tcolor +=g2*vec3(.001)*vec3(.0,.04,.0)*.02+0.0;\n\tcolor +=g1*vec3(.001)*vec3(0.0,.1,.3)*.003+0.0;\ncolor+=vec3(.2,.8,.35)*pow(max(0.,.25-length(uv-vec2(0.,.03)))/.3,1.5)*.65;\n\n\tfragColor = vec4(color,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dlfzj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dlfzn", "name": "561_Rabbitz_2", "author": "mrabbitz", "description": "Simple Penumbra Shadows", "tags": ["shadows"], "likes": 0, "viewed": 23, "date": "1588800999", "time_retrieved": "2024-06-20T20:06:10.005588", "image_code": "////////////////////////////////////////////////////////////////\n\n\nconst int RAY_STEPS = 256;\nvec3 LIGHT_POS = vec3(0.0, 5., -2.0);\n\nstruct Intersection\n{\n    vec3 p;\t\t// point of intersection in world space\n    float t;\t// t-value of ray to p\n    int objHit;\t// assign every object in scene a unique ID integer\n    vec3 color;\t// color of surface\n};\n    \nvec3 rotateX(vec3 p, float a) {\n    return vec3(p.x, cos(a) * p.y - sin(a) * p.z, sin(a) * p.y + cos(a) * p.z);\n}    \n    \n// Takes in direction, rotates it by a radians\n// result of applying a y rotation matrix to the vec3\n// rotates about y-axis\nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n    \n// b consists of width, height, and depth VECTORS (center to edge)\nfloat BoxSDF(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// point, radius, center\nfloat SphereSDF(vec3 p, float r, vec3 c) {\n    return distance(p, c) - r;\n}\n\nfloat PlaneSDF(vec3 p, vec4 n)\n{\n    return dot(p,n.xyz)+n.w;\n}\n\n#define BOX_SDF BoxSDF(pos + vec3(2.5, 0.0, 0.0), vec3(1.0))\n#define SPHERE_SDF SphereSDF(pos, 1., vec3(2.5, 0.0, 0.0))\n#define PLANE_SDF PlaneSDF(pos, vec4(0.0, 1.0, 0.0, 1.0))\n\n#define BOX 0\n#define SPHERE 1\n#define PLANE 2\n\nvec3 ComputeMaterial(int objHit, vec3 pos, vec3 nor, vec3 light, vec3 view)\n{\n    float lambert = dot(nor, light) + 0.2;\n    switch(objHit)\n    {\n        case BOX:\n        return vec3(1.0, 0.0, 0.0) * lambert;\n        break;\n    \tcase SPHERE:\n        return vec3(0.0, 1.0, 0.0) * lambert;\n    \tbreak;\n    \tcase PLANE:\n        return vec3(0.0, 0.0, 1.0) * lambert;\n    \tbreak;\n\t}\n\treturn vec3(1.0);    \n}\n\nfloat SceneSDF(vec3 pos, vec3 lightPos)\n{\n    float t = BOX_SDF;\n    t = min(t,SPHERE_SDF);\n    t = min(t,PLANE_SDF);\n    return t;\n}\n\nvec3 ComputeNormal(vec3 pos, vec3 lightPos) {\n    vec2 offset = vec2(0.0, 0.001);\n    return normalize( vec3( SceneSDF(pos + offset.yxx, lightPos) - SceneSDF(pos - offset.yxx, lightPos),\n                            SceneSDF(pos + offset.xyx, lightPos) - SceneSDF(pos - offset.xyx, lightPos),\n                            SceneSDF(pos + offset.xxy, lightPos) - SceneSDF(pos - offset.xxy, lightPos)\n                          )\n                    );\n}\n    \nvoid SceneSDF(vec3 pos, out float t, out int objHit, vec3 lightPos)\n{\n    t = BOX_SDF;\n    objHit = BOX;\n    \n    float t2;\n    if((t2 = SPHERE_SDF) < t)\n    {\n        t = t2;\n        objHit = SPHERE;\n    }\n    if((t2 = PLANE_SDF) < t)\n    {\n        t = t2;\n        objHit = PLANE;\n    }\n}\n    \nvoid RayMarch(vec3 origin, vec3 dir, out float t, out int objHit, vec3 lightPos)\n{\n    // starts slightly > 0\n    // so that if we march from a different point in the scene that isnt the camera\n    // we dont immediately intersect ourselves\n    t = 0.001;\n    // ray march not to a certain distance but for a certain number of iterations\n    for (int i = 0; i < RAY_STEPS; ++i)\n    {\n        vec3 pos = origin + t * dir;\n        // minimum distance that pos is from all SDFs in the scene\n        float m;\n        SceneSDF(pos, m, objHit, lightPos);\n        if(m < 0.01)\n        {\n            return;\n        }\n        t += m;\n    }\n    // hit nothing\n    t = -1.0;\n    objHit = -1;\n}\n    \nIntersection SceneIntersection(vec3 eye, vec3 dir, vec3 lightPos)\n{\n    float t;\n    int objHit;\n    // Marches along ray to find point of intersection\n    RayMarch(eye, dir, t, objHit, lightPos);\n    \n    vec3 isect = eye + t * dir;\n    vec3 nor = ComputeNormal(isect, lightPos);\n    vec3 lightDir = normalize(lightPos - isect);\n    \n    vec3 surfaceColor = ComputeMaterial(objHit, isect, nor, lightDir, normalize(eye - isect));\n        \n    vec3 normalAsColor = 0.5 * (nor + vec3(1.0));\n        \n    return Intersection(isect, t, objHit, surfaceColor);\n}\n    \nconst vec3 worldUp = vec3(0,1,0);\nvoid RayCast(vec2 ndc, out vec3 eye, out vec3 dir, out vec3 ref)\n{\n    eye = vec3(0.0, 3.0, 15.0);\n    ref = vec3(0.0, 0.0, 0.0);\n    \n    float len = tan(3.14159 * 0.08) * distance(eye, ref);\n   \n    vec3 H = normalize(cross(worldUp, ref - eye));\n    vec3 V = normalize(cross(H, eye - ref));\n    V *= len;\n    H *= len * iResolution.x / iResolution.y;\n    vec3 p = ref + ndc.x * H + ndc.y * V;\n    dir = normalize(p - eye);\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax)\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<100; i++ )\n    {\n\t\tfloat h = SceneSDF( ro + rd*t , LIGHT_POS);\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, 10.0*d/max(0.0,t-y) );\n        ph = h;\n        \n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.001 + 0.15*float(i)/4.0;\n        float d = SceneSDF( pos + h*nor, LIGHT_POS );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 1.5*occ, 0.0, 1.0 );    \n}\n\n// mainImage: present in every single shader program on shadertoy\n// outputs: the fragment color for the fragment it is operating on\n// takes in: the pixel space coordinates of the fragment it is coloring\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime * 3.14159 * 0.1;\n    LIGHT_POS = rotateY(vec3(0.0, 10.0, -10.), t);\n    \n    // iResolution: width and height of screen in pixels (on bottom toolbar of image output)\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Convert to range -1 to 1 for x and y\n    // Normalized Device Coordinates w.r.t. the center of the screen being (0,0)\n    uv = (uv * 2.0) - vec2(1.0);\n    \n    Intersection aaIsects[4];\n    vec3 eye, dir, ref;\n    int idx = 0;\n    for (float i = 0.0; i < 1.0; i += 0.5)\n    {\n        for (float j = 0.0; j < 1.0; j += 0.5)\n        {\n            RayCast(uv + vec2(i, j) / iResolution.xy, eye, dir, ref);\n            aaIsects[idx++] = SceneIntersection(eye, dir, LIGHT_POS);\n        }\n    }\n                                                                          \n    vec3 avgColor = vec3(0.0);\n    for (int i = 0; i < 4; ++i)\n    {\n        avgColor += aaIsects[i].color;\n    }\n    avgColor *= 0.25;\n    \n    \n    vec3 norm = ComputeNormal(aaIsects[0].p, LIGHT_POS);\n    \n            \tvec3 color = vec3(0.0);\n    \tvec3 baseColor = avgColor;\n        \n    //    https://www.shadertoy.com/view/lsKcDD\n    \n    // key light\n        vec3  lig = normalize(LIGHT_POS - aaIsects[0].p);\n        vec3  hal = normalize( lig-dir );\n        float dif = clamp( dot( norm, lig ), 0.0, 1.0 ) * \n                    calcSoftshadow( aaIsects[0].p, lig, 0.01, 15.0);\n\n\t\tfloat spe = pow( clamp( dot( norm, hal ), 0.0, 1.0 ),16.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,dir),0.0,1.0), 5.0 ));\n\n\t\tcolor = baseColor * 4.0*dif*vec3(1.00,0.70,0.5);\n        color +=      12.0*spe*vec3(1.00,0.70,0.5);\n    \n            // ambient light\n        float occ = calcAO( aaIsects[0].p, norm );\n\t\tfloat amb = clamp( 0.5+0.5*norm.y, 0.0, 1.0 );\n        color += baseColor*amb*occ*vec3(0.0,0.08,0.1);\n    color += baseColor * 0.4;\n    \n    fragColor = vec4(color * step(0.0, aaIsects[0].t), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dlfzn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dsBDj", "name": "string theory?", "author": "sense", "description": "strange theory", "tags": ["juliamod"], "likes": 0, "viewed": 34, "date": "1589108291", "time_retrieved": "2024-06-20T20:06:10.005588", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy + iMouse.xy/ iResolution.xy;\n\n    vec2 cc = 10.1*vec2( 0.5*tanh(0.1*iTime) - 0.25*cos(2.02*iTime), \n\t                    0.5+sin(0.1*iTime) - 0.25*tanh(12.002+iTime));\n\n\tvec4 dmin = vec4(100.0);\n    vec2 z = (-1.0 + 1.0/p)*vec2(10.6,1.3);\n    for( int i=0; i<64; i++ )\n    {\n        z = cc + vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y );\n\t\tz += 0.15+sin(float(i));\n\t\tdmin=min(dmin, vec4(abs(0.0+z.y - 2.2*sin(z.x)), \n\t\t\t\t\t\t\tabs(1.0+z.x + 23.25*sin(z.y)), \n\t\t\t\t\t\t\tdot(z,z),\n\t\t\t\t\t\t    length( fract(z)-0.2) ) );\n    }\n    \n    vec3 color = vec3( dmin.w );\n\tcolor = mix( color, vec3(2.80,0.40,0.20),     min(1.0,pow(dmin.x*0.25,0.20)) );\n    color = mix( color, vec3(0.12,0.70,0.60),     min(1.0,pow(dmin.y*0.50,0.50)) );\n\tcolor = mix( color, vec3(0.90,0.40,0.20), 1.0-min(1.0,pow(dmin.z*1.00,0.15) ));\n\n\tcolor = 1.25*color+color+color*color;\n\t\n\tcolor *= 0.5555 + 0.5*pow(9.0*p.x*(1.0-p.y)*p.y*(1.0-p.y),0.15);\n\n\tfragColor = vec4(color,1.0)*0.33333333;\n}\n\n\n// mod of mod from original maker \n// https://www.shadertoy.com/view/MsXGzr", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dsBDj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dSBRc", "name": "Quick Mandelbrot Zoom", "author": "cheasify", "description": "A fuzzy zoom into the asymptotic behavior of the complex recursive function z=z^2+c with initial z=0. Has a lot of jittering/temporal discontinuity/aliasing. ", "tags": ["fractal"], "likes": 2, "viewed": 64, "date": "1590478822", "time_retrieved": "2024-06-20T20:06:10.387313", "image_code": "#define PI 3.14159265358979\n    \n\n\nvec3 color(float x){//x 0 to 1\n\tx=abs(sin(x));\n    //bezier \n    float r=(1.0-x)*(1.0-x);\n    float g=x*x;\n    float b=2.0*(1.0-x)*x;\n    return vec3(r,g,b);\n}\n\n\n\n\nfloat atan2(vec2 n){\n    return mod(atan(n.y, n.x), 2. * PI);\n}\n\n//faster than general equation complex power\nvec2 square(vec2 n){\n\treturn vec2(n.x*n.x-n.y*n.y,2.0*n.x*n.y);\n}\n//we can also ask what happens when we raise z to a different power\n//making the recursive definition z=z^p+c\nvec2 power(vec2 n,float p){\n    //this is eulers identity \n\t//(a+bi)^p=len(a,b)e^(atan2(b,a)i)=len(a,b)(cos(atan2(b,a))+isin(atan2(b,a)))\n    float theta=atan2(n);\n    float len=length(n);\n    return pow(len,p)*vec2(cos(p*theta),sin(p*theta));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //frame\n    //make camera rotate with power\n    float zoom=1.0;//intial zoom\n    float zoomRate=1.0/60.0;\n   \tconst vec2 center=vec2( -0.743643887037158704752191506114774, 0.131825904205311970493132056385139);//where you zoom in\n    vec2 uv = 2.0/(zoom*exp2(zoomRate*float(iFrame)))*((2.*fragCoord-iResolution.xy)/iResolution.y)+center;\n    const int maxiter=300;\n    int count=0;\n    vec2 value=vec2(0);\n\n    float p=2.0;//set p=2.0 to for mandelbrot or use square\n\n    for(int i=0;i<maxiter;i++){\n        count+=1;\n        //value=power(value,p)+uv;\n        value=square(value)+uv;\n    \tif(length(value)>2.0)\n            break;\n    }\n\n    //printing\n    const float cycleRate=3.0;\n    vec3 col=vec3(0);\n    if (length(value)>2.0){\n      \tcol=color(float(count)*cycleRate);\n    }\n    fragColor=vec4(col,1);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dSBRc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dSBRt", "name": "Darkmatter Boze", "author": "kaiware007", "description": "State before the birth of the universe...", "tags": ["raymarching"], "likes": 3, "viewed": 76, "date": "1590568780", "time_retrieved": "2024-06-20T20:06:12.775398", "image_code": "// ------------------------------------------------------------------------------------\n// Original \"thinking...\" created by kaneta : https://www.shadertoy.com/view/wslSRr\n// Original Character By MikkaBouzu : https://twitter.com/mikkabouzu777\n// ------------------------------------------------------------------------------------\n\n#define M_PI 3.1415926\n#define M_PI2 M_PI*2.0\n\n#define M_PI03 1.04719\n#define M_PI06 2.09439\n\n#define MAT_BLACK 1.0\n#define MAT_FACE 2.0\n#define MAT_BROW 3.0\n#define MAT_CHEEP 4.0\n#define MAT_SPHERE 5.0\n#define MAT_BG 6.0\n\n#define AA 1\n    \nvec3 sinebow(float h) {\n    vec3 r = sin((.5-h)*M_PI + vec3(0,M_PI03,M_PI06));\n    return r*r;\n}\n\nfloat rand(vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 10000.0);\n}\n\nfloat rand3d(vec3 st)\n{\n    return fract(sin(dot(st.xyz, vec3(12.9898, 78.233, 56.787))) * 10000.0);\n}\n\nfloat noise(vec3 st)\n{\n\tvec3 ip = floor(st);\n    vec3 fp = smoothstep(vec3(0.), vec3(1.), fract(st));\n    \n\tvec4 a = vec4(rand3d(ip+vec3(0.)),rand3d(ip+vec3(1.,0.,0.)),rand3d(ip+vec3(0.,1.,0.)),rand3d(ip+vec3(1.,1.,0.)));\n    vec4 b = vec4(rand3d(ip+vec3(0.,0.,1.)),rand3d(ip+vec3(1.,0.,1.)),rand3d(ip+vec3(0.,1.,1.)),rand3d(ip+vec3(1.,1.,1.)));\n    \n\ta = mix(a, b, fp.z);\n\ta.xy = mix(a.xy, a.zw, fp.y);\n    \n\treturn mix(a.x, a.y, fp.x);\n}\n\nfloat easeInOutQuad(float t) {\n    if ((t *= 2.0) < 1.0) {\n        return 0.5 * t * t;\n    } else {\n        return -0.5 * ((t - 1.0) * (t - 3.0) - 1.0);\n    }\n}\n\n// Distance functions by iq\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdRoundBox(vec3 p, vec3 size, float r)\n{\n    return length(max(abs(p) - size * 0.5, 0.0)) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - r;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n// Union, Subtraction, SmoothUnion (distance, Material) \nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 opS( vec2 d1, vec2 d2 )\n{ \n    return (-d1.x>d2.x) ? vec2(-d1.x, d1.y): d2;\n}\n\nvec2 opSU( vec2 d1, vec2 d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.x-d1.x)/k, 0.0, 1.0 );\n    return vec2(mix( d2.x, d1.x, h ) - k*h*(1.0-h), h > 0.5 ? d1.y : d2.y); }\n\n// Union, Subtraction, SmoothUnion (distance only)\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\nvec3 rotate(vec3 p, float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nvec3 opTwist(in vec3 p, float k )\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return vec3(q.x, q.y, q.z);\n}\n\nvec3 TwistY(vec3 p, float power)\n{\n    float s = sin(power * p.y);\n    float c = cos(power * p.y);\n    mat3 m = mat3(\n          c, 0.0,  -s,\n        0.0, 1.0, 0.0,\n          s, 0.0,   c\n    );\n    return m*p;\n}\n\nfloat ease_cubic_out(float p)\n{\n\tfloat f = (p - 1.0);\n\treturn f * f * f + 1.0;\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\nvec2 opRep2D( in vec2 p, in vec2 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\n// ç·åã¨ç¡éå¹³é¢ã®è¡çªä½ç½®ç®åº\n// rayPos : ã¬ã¤ã®éå§å°ç¹\n// rayDir : ã¬ã¤ã®åã\n// planePos : å¹³é¢ã®åº§æ¨\n// planeNormal : å¹³é¢ã®æ³ç·\nfloat GetIntersectLength(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal)\n{\n    return dot(planePos - rayPos, planeNormal) / dot(rayDir, planeNormal);\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// Mikka Boze Distance Function\n/////////////////////////////////////////////////////////////////////////////////////////////////\n#define RAD90 (M_PI * 0.5)\n\nfloat sdEar(vec3 p, float flip, float sc)\n{\n    p.x *= flip;\n    p = rotate(p, RAD90+0.25, vec3(0,0,1));    \n    return sdCappedTorus(p + vec3(0.05, 0.175, 0) * sc, vec2(sin(0.7),cos(0.7)), 0.03 * sc, 0.01 * sc);\n}\n\n#define EYE_SPACE 0.04\n\nvec3 opBendXY(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\nfloat sdMouse(vec3 p, float sc)\n{\n    vec3 q = opBendXY(p, 2.0);\n    \n    return sdEllipsoid(q - vec3(0,0,0.2) * sc, vec3(0.05,0.015 + sin(iTime * 1.) * 0.05,0.05) * sc);\n}\n\nfloat sdCheep(vec3 p, float flip, float sc)\n{\n\tp.x *= flip;\n    \n    float x = 0.05;\n    float z = -0.18;\n    p = rotate(p, M_PI * -0.6 * (p.x - x) / sc, vec3(0,1,0));\n\n    float d = sdCapsule(opBendXY(p + vec3(x, -0.01, z) * sc, 100.0/sc), vec3(-0.005,0.0,0) * sc, vec3(0.005, 0., 0) * sc, 0.0025 * sc);\n    float d1 = sdCapsule(opBendXY(p + vec3(x+0.01, -0.01, z) * sc, 200.0/sc), vec3(-0.0026,0.0,0) * sc, vec3(0.0026, 0., 0) * sc, 0.0025 * sc);\n    float d2 = sdCapsule(opBendXY(p + vec3(x+0.019, -0.015, z) * sc, -100.0/sc), vec3(-0.01,0.0,-0.01) * sc, vec3(0.0045, 0., 0.0) * sc, 0.0025 * sc);\n    \n    return opUnion(opUnion(d, d1), d2);\n}\n\nfloat sdEyeBrow(vec3 p, float flip, float sc)\n{\n    p.x *= flip;\n    \n    p = rotate(p, M_PI * -0.0225, vec3(0,0,1));\n    \n    return sdRoundBox(p + vec3(0.03, -0.14,-0.125) * sc, vec3(0.015,0.0025,0.1) * sc, 0.0001);\n}\n\nvec2 sdBoze(vec3 p, float sc)\n{    \n    vec2 result = vec2(0.);\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0) * sc, vec3(0, 0.11, 0) * sc, 0.125 * sc);\n    \n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0) * sc, 0.095 * sc, 0.05 * sc, 0.0);\n    \n    d = opSmoothUnion(d, d1, 0.1 * sc);\n    \n    // ear\n    float d2 = sdEar(p, 1.0, sc);\n    d = opUnion(d, d2);\n    float d3 = sdEar(p, -1.0, sc);\n    d = opUnion(d, d3);\n\n    vec2 head = vec2(d, MAT_FACE);\n\n\t// eye\n    float d4 = sdCapsule(p, vec3(EYE_SPACE, 0.06, 0.125) * sc, vec3( EYE_SPACE, 0.08, 0.125) * sc, 0.0175 * sc);\n    float d5 = sdCapsule(p, vec3(-EYE_SPACE,0.06, 0.125) * sc, vec3(-EYE_SPACE, 0.08, 0.125) * sc, 0.0175 * sc);\n    vec2 eye = vec2(opUnion(d4, d5), MAT_BLACK);\n    \n    // mouse\n    float d6 = sdMouse(p, sc);\n    vec2 mouse = vec2(d6, MAT_BROW);\n    \n    // cheep\n    float d7 = sdCheep(p, 1.0, sc);\n    float d8 = sdCheep(p, -1.0, sc);\n    vec2 cheep = vec2(opUnion(d7, d8), MAT_CHEEP);\n\n    // eyebrows\n    float d9 = sdEyeBrow(p, 1.0, sc);\n    float d10 = sdEyeBrow(p, -1.0, sc);\n    eye.x = opUnion(eye.x, opUnion(d9, d10));\n    \n    mouse = opU(eye, mouse);\n    result = opS(mouse, head);\n    result = opU(cheep, result);\n    \n    \n    return result;\n}\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// End of Mikka Boze\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nvec2 map(vec3 p)\n{\n\tvec2 result = vec2(1.);\n    \n    float timeSpeed = iTime * 0.2;\n    \n    vec3 q = p;\n    //q.x = mod(p.x+1.0,2.0)-1.0;\n    //q.z = mod(p.z+1.0,2.0)-1.0;\n    q.xz = opRep2D(q.xz, vec2(1.0));\n\n    vec3 q2 = q;\n    vec2 index = floor(p.xz + 0.5);\n    float angle = (index.y + index.x + timeSpeed * 2.5) * M_PI2;\n    \n    //q.xy += vec2(cos(angle)*0.075, sin(angle)*0.05);\n\t//q = rotate(q, iTime, vec3(0,1,0));\n    \n    q.y -= mod(rand(index.xy) * 10. + timeSpeed * (0.5 + rand(index.yx) * 2.5), 10.) - 5.;\n\n    q = rotate(q, angle, normalize(vec3(noise(vec3(index.yx, timeSpeed)), noise(vec3(index.x, timeSpeed, index.y)), noise(vec3(timeSpeed, index.xy)))));\n\n    result = sdBoze(q, 1.0);\n\n    //vec2 body = vec2(sdEllipsoid(q2 + vec3(0.,0.2,0.025), vec3(0.2, 0.175, 0.15)), MAT_FACE);\n    //result = opSU(body, result, 0.025);\n    \n    // background\n    vec2 bg1 = vec2(sdPlane(p + vec3(0., 1.0, 0.), vec4(0,1,0,0)), MAT_BG);\n    vec2 bg2 = vec2(sdPlane(p - vec3(0., 1.0, 0.), vec4(0,-1,0,0)), MAT_BG);\n    \n    result = opSU(bg1, result,  0.25);\n    result = opSU(bg2, result,  0.25);\n    \n    return result;\n}\n\nvec3 norm(vec3 p)\n{\n    vec2 e=vec2(.001,.0);\n    return normalize(.000001+map(p).x-vec3(map(p-e.xyy).x,map(p-e.yxy).x,map(p-e.yyx).x));\n}\n\nvec3 fresnelSchlick_roughness(vec3 F0, float cosTheta, float roughness) {\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n// Unreal Engine Ambient BRDF Approx\n// https://www.unrealengine.com/en-US/blog/physically-based-shading-on-mobile?lang=en-US\nvec3 EnvBRDFApprox( vec3 SpecularColor, float Roughness, float NoV )\n{\n\tconst vec4 c0 = vec4( -1, -0.0275, -0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, -0.04 );\n\tvec4 r = Roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn SpecularColor * AB.x + AB.y;\n}\n\nvec3 calcAmbient(vec3 pos, vec3 albedo, float metalness, float roughness, vec3 N, vec3 V, float t)\n{\n\tvec3 F0 = mix(vec3(0.04), albedo, metalness);\n    vec3 F  = fresnelSchlick_roughness(F0, max(0.0, dot(N, V)), roughness);\n    vec3 kd = mix(vec3(1.0) - F, vec3(0.0), metalness);\n    \n\tfloat aoRange = t/20.0;\n\tfloat occlusion = max( 0.0, 1.0 - map( pos + N*aoRange ).x/aoRange );\n\tocclusion = min(exp2( -.8 * pow(occlusion, 2.0) ), 1.0);\n    \n    vec3 ambientColor = vec3(0.5);\n    \n    vec3 diffuseAmbient = kd * albedo * ambientColor * min(1.0, 0.75+0.5*N.y) * 3.0;\n    vec3 R = reflect(-V, N);\n    \n    vec3 col = mix(vec3(0.5) * pow( 1.0-max(-R.y,0.0), 4.0), ambientColor, pow(roughness, 0.5));\n    vec3 ref = EnvBRDFApprox(F0, roughness, max(dot(N, V), 0.0));\n    vec3 specularAmbient = col * ref;\n\n    diffuseAmbient *= occlusion;\n    return vec3(diffuseAmbient + specularAmbient);\n}\n\n///////////////////////////////////////////////////////////////////////\n#define MAX_MARCH 100\n\nvec3 materialize(vec3 p, vec3 ray, float depth, vec2 mat)\n{\n    //vec3 col = vec3(0.12, 0., 0.4);\n    vec3 col = min(vec3(0.12, 0., 0.4) + sinebow(fract(iTime * 1.5)) * vec3(0.1), 1.);\n    vec3 nor = norm(p);\n    vec3 sky = vec3(0.,0.,0.0);\n    //vec3 sky = min(sinebow(fract(iTime * 2.5 + 0.5)) * vec3(0.35) + vec3(0.3) + pow(max(1.29 - p.y, 0.), 5.), 1.);\n    //if(p.y >= 0.29) \n    if(depth > 100.)\n    {\n    \tcol = sky;\n    } else {\n        if(mat.y > 0.0){\n            vec2 index = floor(p.xz + 0.5);\n\n            float roughness, metalness;\n            if(mat.y == MAT_BLACK) {\n                col = vec3(sin(rand(index.xy) * M_PI2 + iTime * 2.) * 0.5 + 0.5, 0.0, 0.0);\n                roughness = 1.0;\n                metalness = 0.0;\n            } else if(mat.y == MAT_FACE) {\n                //col = vec3(1.0, 0.8, 0.6);\n                //col = min(sinebow(fract(rand(vec2(index.x, index.y) * 32.) + iTime * 0.5)) + vec3(0.2), 1.);\n                roughness = 0.0;\n                metalness = 1.0;\n            } else if(mat.y == MAT_BROW) {\n                //col = vec3(1.0, 0, 0);\n                roughness = 0.0;\n                metalness = 1.0;\n            } else if(mat.y == MAT_CHEEP) {\n                //col = vec3(1.0, 0.3, 0.5);\n                roughness = 0.0;\n                metalness = 1.0;\n            } else if(mat.y == MAT_BG) {\n                //col = min(sinebow(fract((index.x + index.y) * 0.175 + iTime * 0.5 + 0.5)) * vec3(0.3), 1.);\n                //float e = smoothstep(abs(mod(p.y + 0.25 + iTime * 0.5, 0.5) - 0.25), 0.0, 0.0125); \n                roughness = 0.0;\n                metalness = 1.0;\n            }\n\n            vec3 result = vec3(0.);\n            result += calcAmbient(p, col, metalness, roughness, nor, -ray, depth);\n            col = result;\n        }\n        float fog = min(1.0, (1.0 / float(MAX_MARCH)) * float(mat.x))*5.0;\n    \tvec3  fog2 = vec3(0.015,0.015,0.01) * depth;\n    \tcol += vec3(0.01, 0.01, 0.05) * fog;\n    \t//col += fog2 + sky * 0.1;\n        col -= fog2;\n    }\n    \n    return col;\n}\n\nvec3 trace(vec3 p, vec3 ray)\n{\n    float t = 0.0;\n    vec3 pos;\n    vec2 mat;\n    \n    //float planeDistance = GetIntersectLength(p, ray, vec3(0.,0.3,0.), vec3(0.,1.,0.));\n    //t = planeDistance;\n    \n    int count = 0;\n    for (int i = 0; i < MAX_MARCH; i++) {\n        pos = p + ray * t;\n        mat = map(pos);\n        if (mat.x <= 0.00001) {\n        \tbreak;\n        }\n        t += mat.x * 0.5;\n        count++;\n    }\n    \n    p = p + t * ray;\n    mat.x = float(count);\n    return materialize(p, ray, t, mat);\n}\n\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n        \n    float rotSpeed = iTime * -0.125;\n    float x = mod(iTime * 0.5, 10000.);\n    //vec3 ro = vec3(cos(rotSpeed)*5.0, 0., sin(rotSpeed)*5.0);\n    //vec3 ta = vec3(0., 0.0, 0.);\n    vec3 ro = vec3(x, 0., 5.5);\n    //vec3 ta = vec3(x, 0., 0.);\n    vec3 ta = ro + vec3(cos(rotSpeed)*5.0, 0., sin(rotSpeed)*5.0);\n    mat3 c = camera(ro, ta, 0.);\n    vec3 ray = c * normalize(vec3(p, 3.5));\n    vec3 col = trace(ro, ray);\n    \n    tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    fragColor = vec4(tot,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dSBRt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dsBzl", "name": "Function Bending", "author": "zktosu", "description": "simple function plot bender. ", "tags": ["function", "plot", "bend"], "likes": 0, "viewed": 198, "date": "1588875007", "time_retrieved": "2024-06-20T20:06:12.775398", "image_code": "float plot (vec2 st, float pct){\n  return  smoothstep( pct-0.1, pct, st.y) - smoothstep( pct, pct+0.1, st.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord / iResolution.y);\n    \n    float fn = 0.5 + 0.5* sin(iTime) * sin(8.0*iTime)* sin(uv.x*55.0);\n    float col = plot(uv, fn );\n    fragColor = vec4( 0.0, 1.0 - col, 0.0 , 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dsBzl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dSBzt", "name": "Animated Textured Truchet", "author": "Shane", "description": "An animated texture-mapped two-tiled Truchet arrangement, rendered in a faux 3D style.", "tags": ["texture", "abstract", "animation", "truchet", "mapping", "art"], "likes": 39, "viewed": 635, "date": "1590761895", "time_retrieved": "2024-06-20T20:06:15.775689", "image_code": "/*\n\n    Animated Textured Truchet\n    -------------------------\n\n\tHere's that animated texture-mapped two-tiled Truchet code that literally\n    no one asked for. :D Yeah, I don't imagine it'd be something many would \n\trequest, but there'd be some things contained within that I believe a few \n    people would find useful, so here it is.\n\n\tI've texture mapped and animated Truchet tiles and Wang tiles before, but \n    have never texture mapped this particular dual tile arrangement. A quick \n    look on the internet would suggest that little to no one else has either.\n\t\n    Actually, animating this wasn't as bad as I thought it'd be, but it did\n\trequire some logic and finesse. For the mapping part, you use the standard \n    texure mapping for the overlapping rectangular tles, and polar coordinates \n    for the arc tiles, then flip and rotate the texture coordinates where \n    necessary -- Rotate a tile, rotate coordinates, etc. For anyone who's \n    comfortable coding up repeat patterns, it shouldn't be too much of a \n    stretch.\n\n\tHowever, a few simple observations should help: Animating square grid \n    Truchet arc tiles on their own requires the flow directions to be reversed \n    on alternate checkered tiles. Furthermore, in order to work straight line \n    tiles in with them, both horizontal and vertical lines must span two grid \n    cells. In addition, adjacent horizontal line rows must flow in opposite \n    directions. The same applies to adjacent vertical line columns.\n\n\tAnyway, I have a raymarched extruded version coming up, so this was just a\n\tpractice run. By the way, I have a much simpler version of this that I'll \n\tput up soon, for anyone who just wants the pattern animation portion.\n\n\n\tOther examples:\n\n\t// Animation without the complication of texture mapping.\n\tAnimated Two-Tiled Truchet - Shane\n    https://www.shadertoy.com/view/tsSfWK\n\n\n*/\n\n\n// A jagged edge option: Aesthetically, it's interesting, but a little too busy\n// for me, but it's here as an option to show that it can be done.\n//#define JAGGED_EDGES\n\n// Displays each separate grid cell, which allows you to more easily discern\n// individual tiles.\n//#define SHOW_GRID\n\n// Serrated beveling.\n//#define SERRATED_EDGES\n\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  \n   \n    return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); \n}\n \n\n// vec2 to vec2 hash.\nvec2 hash22(vec2 p){ \n    \n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(27, 57)));\n    //return fract(vec2(262144, 32768)*n)*2. - 1.; \n    \n    // Animated.\n    p = fract(vec2(262144, 32768)*n);\n    return sin(p*6.2831853 + iTime*2.); \n    \n}\n\n// Based on IQ's gradient noise formula.\nfloat n2D3G( in vec2 p ){\n   \n    vec2 i = floor(p); p -= i;\n    \n    vec4 v;\n    v.x = dot(hash22(i), p);\n    v.y = dot(hash22(i + vec2(1, 0)), p - vec2(1, 0));\n    v.z = dot(hash22(i + vec2(0, 1)), p - vec2(0, 1));\n    v.w = dot(hash22(i + 1.), p - 1.);\n\n#if 0\n    // Quintic interpolation.\n    p = p*p*p*(p*(p*6. - 15.) + 10.);\n#else\n    // Cubic interpolation.\n    p = p*p*(3. - 2.*p);\n#endif\n\n    return mix(mix(v.x, v.y, p.x), mix(v.z, v.w, p.x), p.y);\n}\n\n\n/*\nfloat sBoxS(in vec2 p, in vec2 b, in float rf){\n  \n  vec2 d = abs(p) - b + rf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - rf;\n    \n}\n*/\n\n// IQ's vec2 to float hash.\nfloat hash21M(vec2 p, float scale){  \n    p.y = mod(p.y, scale); // Wrapping around the Truchet.\n    return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); \n}\n\n// A basic dot pattern, which returns the offset dot \n// value and its ID.\nvec3 dfDots(vec2 p, float scale){\n    \n    p *= scale;\n    vec2 oP = p;\n    \n    // Repeating along Y, which runs along the Truchet.\n    // The 2D hash function also needs to wrap with it.\n    vec2 ip = floor(p);\n    p -= ip + .5;\n    \n    // Row offsetting. It's hacky, but it works.\n    if(mod(ip.x, 2.)<.5){\n        \n        p = oP - vec2(0, .5);\n        ip = floor(p);\n        p -= ip + .5;\n    }\n    \n    \n    // Random size.\n    float rnd = hash21M(ip, scale);\n    // Random XY offset.\n    vec2 rndP = (vec2(rnd, hash21M(ip + .37, scale)) - .5)*.2;\n    \n    // Circular distance field.\n    float d = length(p - rndP) - .15 - rnd*.225;\n    \n    // Return the distance and ID.\n    return vec3(d, ip);\n}\n\n\n\n\n\n// Texture coordinates for each Truchet segment. Remember that there are\n// two segments per tile. Either two quarter arcs or overlaying lines.\n// Technically, the arcs overlay also, which I did for style purposes.\nvec2 tuv[2];\n\n// A hacky shadow container, which I threw in as an afterthough, because\n// I decided that I wanted fake shadows at the last minute. :)\nvec2 gShadow;\nconst vec2 gShOff = vec2(.07, -.07);\n\n\n// The Truchet distance field. A lot of this is standard stuff. The additional\n// code here involved texture mapping. That was just a case of \nvec2 df(vec2 p){\n    \n    \n    // Two by two cell random value.\n    vec2 ip2 = floor(p/2.);\n    float rnd2 = hash21(ip2 + .43);  \n    \n    // Cell ID and local coordinates.\n    vec2 ip = floor(p);\n    p -= ip + .5;\n    \n    // Random 1x1 numbers, for flipping and rotating.\n    float rnd = hash21(ip);\n    float rnd3 = hash21(ip + .57);\n    \n    // The distance field container. Each cell contains either two lines\n    // or two arcs, so this will hold each one.\n    vec2 d = vec2(1e5);\n    \n    // Shadow offset coordinate.\n    vec2 pShOff = p - gShOff;\n    \n    \n    // UV radial coordinate for each arc... and just to confuse matters, I'm \n    // using radius and angles to represent the UV straight line tiles also... \n    // Yes, that's bad name coding -- No Google apprentiship for me. :D\n    vec2 rad;\n    \n    // The angle is either the angle of the Truchet arcs, which have been \n    // normalized to the zero to one range, or the value of the straight line \n    // position on the straight edge tile arrangement, which also ranges from \n    // zero to one.\n    vec2 ang;\n  \n    \n    // When animating arc Truchet arrangements only, the trick is to \n    // reverse the animation flow on alternate checkered cells... \n    // I have a basic animated version on here somewhere, if you\n    // require more information.\n    //\n    // Anyway, working in the extra overlapping straight line tiles \n    // complicates things. However, after a while, you'll realise that \n    // either the horizontal or vertical line must span two cells for \n    // the animation to work, so that's what the following two-by-two \n    // checkered \"mod\" decision is all about.\n    //\n    // Every 2 by 2 alternate checker, put in the overlapped straight \n    // tiles. Otherwise, calculate the distance field for the double \n    // arc one.\n    //\n    if(mod(ip2.x + ip2.y, 2.)<.5){ // Alternate checkers.\n    //if(rnd2<.5){ // Random 2x2 coverings.\n    //if((mod(ip2.x, 2.)<.5 || mod(ip2.y, 2.)<.5) && rnd2<.5){ // Mixing.\n        \n        \n        \n        // Overlapping straight tile.\n\n        // Set the UV coordinates prior to folding the center over\n        // to form a vertical or horizontal line.\n        rad = p*vec2(-1, 1);\n\t\tang = p.yx; // I can't remember why I reversed these. :)\n        \n        // Horizontal and vertical line distance fields.\n        d = abs(p);\n        gShadow = abs(pShOff);\n        \n\n        // Reversing just the X-directions on every second column. It's \n        // common sense... but it still took me a while to figure out.. :)\n        if(mod(ip.x + 1., 2.)<.5){\n            ang.x *= -1.;\n            rad.x *= -1.;\n\n        }\n        \n        // Reversing just the Y-directions on every second row.\n        if(mod(ip.y + 1., 2.)>.5){\n            ang.y *= -1.;\n            rad.y *= -1.;\n        }  \n\n\n        // Randomly change the rendering order, which means\n        // switching everything else. I always forget this, then spend\n        // ages trying to figure out why things aren't working. :)\n        if(rnd3<.5) {\n            d = d.yx;\n            ang = ang.yx;\n            gShadow = gShadow.yx;\n            rad = rad.yx;\n        }\n\n        // This makes things line up.\n        ang += .5;\n        //ang *= 3.;\n\n    }\n    else {\n        \n        \n        // Double arc tile.\n        \n        // Randomly rotate.\n        if(rnd<.5) {\n        \tp = p.yx*vec2(1, -1);\n            pShOff = pShOff.yx*vec2(1, -1);\n    \t}\n        \n        // Individual arc distances. One in each corner.\n        d.x = length(p - .5) - .5;\n    \td.y = length(p + .5) - .5;\n        \n        // Shadows: Same as above, but with the offset coordinates.\n        gShadow.x = length(pShOff - .5) - .5;\n        gShadow.y = length(pShOff + .5) - .5;\n        \n        // The angles of the pixels subtended to the circle centers of each \n        // arc. Standard polar coordinate stuff... In a hurry, I threw some\n        // negative signs in and everything lined up, but you could rework \n        // everything to work without them.\n        ang.x = -atan(p.y - .5, p.x - .5);\n        ang.y = -atan(p.y + .5, p.x + .5);\n        \n        // Arcs have the distance field form: arc = abs(circle) - arcWidth/2.\n        // However, this folds things across the center, which you don't want\n        // for your UV coordinates, so set \"uv\" to the unfolded distance.\n        // This is one of the many things I've learned the hard way. :)\n        rad = d;\n        \n        // Turn the quarter circles into arcs. Do the same with the \n        // offset shadow distance field.\n        d = abs(d);\n        gShadow = abs(gShadow);\n        \n        // This comes up all the time when animating square Truchets.\n        // It's necessary to reverse the animation flow on alternate\n        // checker squares.\n        if(mod(ip.x + ip.y, 2.)<.5){\n            ang *= -1.;\n            rad *= -1.;\n        }\n        \n        // Reverse the flow on all randomly rotated tiles.\n        if(rnd<.5){\n            ang *= -1.;\n            rad *= -1.;\n        } \n        \n        // Randomly change the rendering order, which means\n        // switching everything else. I always forget this, then spend\n        // ages trying to figure out why things aren't working. :)\n        if(rnd3<.5) {\n             d = d.yx;\n             ang = ang.yx;\n             \n             gShadow = gShadow.yx;\n             \n             rad = rad.yx;\n         }\n        \n        // Normalizing the angle. Four arcs make up a circle, which\n        // means each needs to run from zero to one four times over\n        // for the texture to wrap... I'm pretty sure that's right...\n        // but I've been wrong before. :)\n        ang *= 4./6.2831853;\n        \n        //ang *= 2.;\n        \n        \n        \n    }\n    \n    // Adding some time-based movement... or animation, if you wish to \n    // call it that. :D By the way, if you take out the time component,\n    // I think the \"fract\" call still needs to be there.\n    ang = fract(ang + iTime/4.);\n\n    // UV coordinates. One set for each cell object.\n    tuv[0] = vec2(rad.x, ang.x);\n    tuv[1] = vec2(rad.y, ang.y);\n    \n    \n    return d;\n    \n}\n\n\n// The square grid boundaries.\nfloat gridField(vec2 p){\n    \n    vec2 ip = floor(p);\n    p -= ip + .5;\n    \n    p = abs(p);\n    \n    return abs(max(p.x, p.y) - .5) - .03;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n\n    // Aspect correct screen coordinates.\n    float iRes = min(iResolution.y, 800.);\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iRes;\n    \n    // Subtle barrel distortion.\n    float r = dot(uv, uv);\n    uv *= 1. + .025*(r*r*.5 + r);\n    \n    // Scaling and translation.\n    const float gSc = 6.;\n    // Depending on perspective; Moving the oject toward the bottom left, \n    // or the camera in the north east (top right) direction. \n    vec2 p = uv*gSc - vec2(-1, -.25)*iTime/4.;\n    \n    // Smoothing factor, based on scale.\n    float sf = 2./iResolution.y*gSc;\n   \n    // Line scale, and line width... This relates back to a simpler example \n    // I made. I wouldn't pay it too much attention.\n    float lSc = 7.; \n    float lw = 1./lSc/gSc;\n    \n    // Calling the Truchet pattern distance field and giving it a bit of width.\n    // The width relates back to another example, but you could hard code figures\n    // in, if you wanted.\n    vec2 d = df(p) - 2.5/lSc;\n    \n    // Giving the shadow the same width.  You could add more to represent more \n    // depth, but it's not that important.\n    gShadow = gShadow - 2.5/lSc;\n    \n    // Setting the background to the texture.\n    vec3 bgTex = texture(iChannel0, p/gSc + .5).xyz; bgTex *= bgTex;\n    bgTex = smoothstep(.05, .5, bgTex); // Ramping up the color a bit.\n\tvec3 col = bgTex;\n    \n    // Applying some horizontal lines to give an industrial look, or something.\n    float pat = abs(fract(p.y*lSc*2. + .5)  - .5) - lw*lSc;\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, pat));\n   \n  \n\n    // Rendering the two Truchet layers. A lot of this was made up as I\n    // went along, so you could ignore the details.\n    //\n    for(int i = 0; i<2; i++){\n         \n        // The distance field value for the layer. I've bumped it up by a\n        // small portion for some reason. It looks untidy, but I'll leave\n        // it there, just in case. :)\n        float di = d[i] - lw/4.;\n\n        \n        // Using the Truchet texture coordinates to apply some texture color to \n        // the Truchet object. I'm using the trusty metallic texture, but the\n        // wood and blue noise textures look all right as well.        \n        vec3 tx = texture(iChannel0, tuv[i]).xyz; tx *= tx;\n        tx = smoothstep(.05, .5, tx);\n        vec3 tx2 = max(1. - tx.zyx, 0.);\n        \n     \n        // Putting a repeat random dot pattern onto the Truchet. I tried some \n        // fancier patterns, but went with something simple in the end.\n        vec3 tr3 = dfDots(tuv[i] + vec2(.0, 0), 4.); // The \"4\" is a wrap scale.\n        float tr = tr3.x;\n        float rnd = hash21M(tr3.yz + .67, 4.);\n        \n        float ns = n2D3G(p/gSc*1.5)*.66 + n2D3G(p/gSc*3.)*.34;\n        rnd = mix(rnd, 1. - rnd, smoothstep(-.125, .125, ns));\n        \n        \n        //rnd = smoothstep(.5, .85, rnd);\n        vec3 dotCol = .5 + .5*cos(rnd*6.2831 + vec3(2, 1, 0));\n        dotCol = mix(tx*3., dotCol, .9);\n        \n        \n        // Applying the dots to the texture object. I'm not sure why I took this\n        // route. You could apply the pattern directly to the Truchet object below,\n        // if you wanted... I'm sure I had my reasons. :)\n        tx = mix(tx, vec3(0), 1. - smoothstep(0., sf, tr - .1));\n        tx = mix(tx, dotCol*1.5, 1. - smoothstep(0., sf, tr + .05));\n         \n    \n        // Applying the shadows. Because there's two layers, you have to apply \n        // them in a different way. Combine the two shadows for the first (ground)\n        // layer, then apply the top shadow to the bottom object layer... Confused?\n        // That makes both of us. :D It's one of the reasons I find it easier to\n        // to render things in 3D.\n        //\n        // By the way, you could arrange for this to be outside the loop, but I \n        // think it's more readable here.\n        float diSh = i == 0? min(gShadow[0], gShadow[1]) : max(gShadow[1], d[0]);\n\n        // Jagged edge option... Not sure what I was thinking with this modification,\n        // but I've left it here as an option, just in case I decide to rework it. :)\n        #ifdef JAGGED_EDGES\n        float diO = max(di, -tr/4.);\n        diSh = max(diSh, -dfDots((tuv[i] - gShOff), 4.).x/4.);\n        #else\n        float diO = di;\n        #endif\n        \n        \n        // Self shadowing. Analogous to ambient occlusion, but not really. :)\n        // You could almost use just this and save yourself the hassle of rendering\n        // fake shadow layers, but the shadows are offset in the direction of the\n        // light which provides more of an air of authenticity.\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*4., diO))*.5);\n         \n        // Render the shadow layer. See the \"diSh\" comments above.  \n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*4., diSh))*.5);\n        \n        // Rendering the stroke layer... The black edge. \n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, diO));\n        \n        float sh = max(.35 - di/lw/6., 0.);\n        tx2 *= sh;\n        \n        \n        \n        \n        // Outer Truchet layer.\n        float gap = 1. + lw;\n        col = mix(col, tx2, 1. - smoothstep(0., sf, diO + lw*2.));\n        \n        #ifdef SERRATED_EDGES\n        // Side decorations.\n        float lnd = (abs(fract(tuv[i].y*12. - .5) - .5) - lw/3.)/12.;\n        lnd = max(lnd, di);\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf, lnd))*.85);\n        #endif\n\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, di + gap/lSc));\n        col = mix(col, tx, 1. - smoothstep(0., sf, di + gap/lSc + lw*1.5));\n\n        // Inner Truchet layer.\n        gap = .9;\n        di = max(di, -tr*4.);\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, di + 2.*gap/lSc));\n        col = mix(col, tx*sh, 1. - smoothstep(0., sf, di + 2.*gap/lSc + lw*1.5));\n        \n        #ifndef SERRATED_EDGES\n        // Another kind of side bevel.\n        col = mix(col, tx, (1. - smoothstep(0., sf, abs(di + gap/lSc*.9/2. + lw*1.5) - lw/3.))*.75);\n        #endif\n\n    }\n  \n    // Displaying the grid cells.\n    #ifdef SHOW_GRID\n    float grid = gridField(p);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*4., grid))*.5);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, grid)));\n    col = mix(col, 1.25 - bgTex.zyx, (1. - smoothstep(0., sf, grid  + .03)));\n\t#endif\n    \n    // Toning things down.\n    //col = 1. - exp(-col*1.5);\n    \n     // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    float vig = pow(16.*(1. - uv.x)*(1. - uv.y)*uv.x*uv.y, 1./6.);\n    col *= min(vig*1.25, 1.);\n    \n    // Output to screen\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dSBzt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dsfDj", "name": "Hip-Flop!", "author": "shau", "description": "Started of as an attempt at s Hip-Hop/Graffiti style tag ", "tags": ["3d"], "likes": 24, "viewed": 179, "date": "1589830536", "time_retrieved": "2024-06-20T20:06:17.964584", "image_code": "// Created by SHAU - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define R iResolution.xy\n#define ZERO (min(iFrame,0))\n#define S(a, b, v) smoothstep(a, b, v)\n#define EPS .003\n#define FAR 20.\n#define T iTime\n#define PI 3.14159\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 / float(0xffffffffU))\n\n//Fabrice - compact rotation\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\n\n//Dave Hoskins - improved hash without sin\n//https://www.shadertoy.com/view/XdGfRR\nvec3 h3(vec3 p) \n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z) * UI3;\n\treturn vec3(q) * UIF;\n}\n\nfloat h1(float p) \n{\n\tvec3 x  = fract(vec3(p) * .1031);\n    x += dot(x, x.yzx + 19.19);\n    return fract((x.x + x.y) * x.z);\n}\n\nvec3 hash31(float p) \n{\n   vec3 p3 = fract(vec3(p) * vec3(443.8975,397.2973, 491.1871));\n   p3 += dot(p3.xyz, p3.yzx + 19.19);\n   return fract(vec3(p3.x * p3.y, p3.x*p3.z, p3.y*p3.z));\n}\n\nvec3 n13(float n) \n{\n    float f = fract(n);\n    n = floor(n);\n    f = f * f * (3.0 - 2.0 * f);\n    return mix(hash31(n), hash31(n + 1.0), f);\n}\n\n//Shane IQ\nfloat n3D(vec3 p) \n{    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); \n    p -= ip; \n    vec4 h = vec4(0.,s.yz,s.y + s.z) + dot(ip, s);\n    p = p * p * (3. - 2. * p);\n    h = mix(fract(sin(h)*43758.5453),fract(sin(h + s.x)*43758.5453),p.x);\n    h.xy = mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z);\n}\n\nfloat noise(vec2 uv, float s1, float s2, float t1, float t2, float c1) \n{\n\treturn clamp(h3(vec3(uv.xy * s1, t1)).x +\n\t\t         h3(vec3(uv.xy * s2, t2)).y, \n                 c1, \n                 1.);\n}\n\n//Shane - Perspex Web Lattice - one of my favourite shaders\n//https://www.shadertoy.com/view/Mld3Rn\n//Standard hue rotation formula... compacted down a bit.\nvec3 rotHue(vec3 p, float a)\n{\n    vec2 cs = sin(vec2(1.570796,0) + a);\n\n    mat3 hr = mat3(0.299,  0.587,  0.114,  0.299,  0.587,  0.114,  0.299,  0.587,  0.114) +\n        \t  mat3(0.701, -0.587, -0.114, -0.299,  0.413, -0.114, -0.300, -0.588,  0.886) * cs.x +\n        \t  mat3(0.168,  0.330, -0.497, -0.328,  0.035,  0.292,  1.250, -1.050, -0.203) * cs.y;\n\t\t\t\t\t\t\t \n    return clamp(p*hr,0.,1.);\n}\n\n//SDFs - IQ\nfloat sdBox(vec3 p, vec3 b)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCappedCylinder(vec3 p, float h, float r)\n{\n  vec2 d = abs(vec2(length(p.xy),p.z)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdSegment(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdArc(vec2 p, vec2 sca, vec2 scb, float ra, float rb)\n{\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p.xy,scb) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat smax(float a, float b, float k) \n{\n\tfloat h = clamp( 0.5 + 0.5 * (b - a) / k, 0.0, 1.0 );\n\treturn mix(a, b, h) + k * h * (1.0 - h);\n}\n\nfloat dfS3DPart(vec3 p)\n{\n    vec3 q = p;\n    q.y *= 2.0;\n\tfloat t = sdCappedCylinder(q,2.0,0.5); \n    q.xy *= rot(0.5);\n    float l = max(0.0,p.y - 0.2)*max(0.0,p.y - 0.2)*-0.2*sign(q.z);\n    t = min(t, sdBox(q - vec3(1.0,1.0,0.0), vec3(1.0,1.8,0.5 + l)));\n    q = p;\n    q.y *= 4.0;\n\tt = max(t, -sdCappedCylinder(q - vec3(0.0,-1.4,0.0),1.2,5.0)); \n    q = p;\n    q.xy *= rot(0.3); \n    t = smax(t, -sdBox(q - vec3(1.7,0.0,0.0), vec3(1.0,4.0,2.0)),0.2);    \n    return max(t, -sdBox(p - vec3(1.0,-1.0,0.0), vec3(1.0,1.0,2.0)));\n}\n\nfloat dfS3D(vec3 p)\n{\n    p.xy *= rot(-0.5);\n    float t = dfS3DPart(p - vec3(0.0,0.825,0.0));\n    p.xy *= rot(PI);\n    return min(t, dfS3DPart(p - vec3(0.0,0.825,0.0)));\n}\n\nfloat dfH3D(vec3 p)\n{\n    float l = max(0.0,p.x*0.5 + 0.6)*max(0.0,p.x*0.5 + 0.6)*0.3;\n    float t = sdCappedCylinder(p - vec3(1.0,6.0,0.0),5.0,0.5 + l);  \n    vec3 q = p;\n    q.xy *= rot(0.1);\n    t = min(t, sdBox(q - vec3(-1.0,0.0,0.0), vec3(0.6,3.0,0.5)));\n    t = smax(t, -sdBox(p - vec3(-1.0,-3.0,0.0), vec3(2.0,1.0,1.0)),0.2);    \n    t = smax(t, -sdCappedCylinder(p - vec3(1.0,6.0,0.0),4.0,4.0),0.2);\n    t = smax(t, -sdBox(q - vec3(-3.4,0.0,0.0), vec3(2.0,10.0,1.0)),0.2);\n    t = smax(t, -sdBox(p - vec3(4.1,0.0,0.0), vec3(4.0,16.0,10.0)),0.2);\n    t = max(t, -sdBox(p - vec3(0.0,9.0,0.0), vec3(10.0,4.0,4.0)));\n    t = min(t, sdBox(p - vec3(1.0,0.0,0.0), vec3(0.5,2.0,0.5)));  \n    q = p;\n    l = max(0.0,p.x*-0.5)*max(0.0,p.x*-0.5)*0.3;\n    return min(t, sdBox(q - vec3(-0.5,-0.4,0.0), vec3(1.4,0.2,0.5 + l)));\n}\n\nfloat dfA3D(vec3 p)\n{\n \tfloat t = sdBox(p - vec3(-0.2,0.0,0.0), vec3(0.5,2.0,0.5));\n    float l = max(0.0,(p.x-2.5)*-1.0)*max(0.0,(p.x-2.5)*-1.0)*0.1;\n    t = min(t, sdBox(p - vec3(1.7,-1.6,0.0), vec3(0.9,0.6,0.5 + l)));\n    vec3 q = p;\n    q.xy *= rot(0.6);\n    t = min(t, sdBox(q - vec3(1.2,0.0,0.0), vec3(0.5,4.0,0.5)));\n    l = max(0.0,p.x+0.2)*max(0.0,p.x+0.2)*0.1;\n    t = min(t, sdBox(p - vec3(1.2,-0.4,0.0),vec3(1.6,0.2,0.5 + l)));\n    t = min(t, sdCappedCylinder(p - vec3(-1.0,6.0,0.0),5.0,0.5 + l));\n    t = smax(t, -sdCappedCylinder(p - vec3(-1.0,6.0,0.0),4.0,5.0),0.2);\n    t = smax(t, -sdBox(p - vec3(-3.5,0.0,0.0), vec3(3.0,16.0,5.0)),0.2); \n    t = smax(t, -sdBox(q - vec3(7.0,0.0,0.0), vec3(4.0,10.0,5.0)),0.2);\n    return smax(t, -sdBox(p - vec3(2.0,-3.0,0.0), vec3(4.0,1.0,2.0)),0.2);\n}\n\nfloat dfU3D(vec3 p)\n{\n    vec3 q = p;\n    q.xy *= rot(-0.3);\n    q.x *= 3.0;\n    float t = sdCappedCylinder(q - vec3(0.0,2.0,0.0),4.0,0.5);\n    t = min(t, sdBox(p - vec3(1.8,0.0,0.0), vec3(0.5,2.2,0.5)));\n    float l = max(0.0,(q.x + 2.0)*-0.5)*max(0.0,(q.x + 2.0)*-0.5)*0.1;\n    l = min(l, 2.0);\n    t = min(t, sdCappedCylinder(p - vec3(-5.0,6.0,0.0),6.5,0.5 + l));\n    t = smax(t, -sdCappedCylinder(p - vec3(-5.0,6.0,0.0),5.5,20.0),0.2);\n    t = smax(t, -sdCappedCylinder(q - vec3(1.0,2.0,0.0),2.0,1.0),0.2);\n    q = p;\n    q.xy *= rot(0.6);\n    t = smax(t, -sdBox(q - vec3(-5.4,6.0,0.0), vec3(4.0,6.0,10.0)),0.2);\n    return smax(t, -sdBox(p - vec3(-5.0,8.0,0.0), vec3(8.0,6.0,20.0)),0.2);\n}\n\nfloat dfS2DPart(vec2 uv)\n{\n    float t = sdSegment(uv, vec2(0.5,1.35), vec2(1.4,1.1));\n    t = min(t, sdSegment(uv, vec2(1.4,1.1), vec2(1.1,-0.0)));\n    uv *= rot(0.9);\n    uv.x *= 2.0;\n    return min(t, sdArc(uv, vec2(1.0,0.0),vec2(1.0,0.0), 1.3, 0.0));\n}\n\nfloat dfS2D(vec2 uv) \n{\n    float t = dfS2DPart(uv - vec2(0.0,0.8));\n    uv *= rot(PI);\n    return min(t, dfS2DPart(uv - vec2(0.0,0.8)));\n}\n\nfloat dfH2D(vec2 uv)\n{\n    float t = sdSegment(uv,vec2(-1.0,1.6),vec2(-1.0,-1.8));\n    t = min(t, sdSegment(uv,vec2(-1.6,-1.8),vec2(-1.0,-1.8)));\n    t = min(t, sdSegment(uv,vec2(-3.3,-1.8),vec2(-2.7,-1.8)));\n    t = min(t, sdSegment(uv,vec2(-3.4,-1.0),vec2(-3.3,-1.8)));\n    t = min(t, sdSegment(uv,vec2(-3.6,1.4),vec2(-3.5,0.3)));\n    t = min(t, sdSegment(uv,vec2(-4.0,-0.4),vec2(-1.4,-0.4)));\n    uv -= vec2(-2.0,4.7);\n    uv *= rot(-0.4);\n    return min(t, sdArc(uv, vec2(1.0,0.0),vec2(-0.45,1.0), 2.8, 0.));\n}\n\nfloat dfA2D(vec2 uv)\n{\n    float t = sdSegment(uv,vec2(0.0,1.8),vec2(0.0,-1.4));\n    t = min(t, sdSegment(uv,vec2(0.4,-0.4),vec2(2.8,-0.4)));\n    t = min(t, sdSegment(uv,vec2(1.4,-1.8),vec2(3.2,-1.8)));\n    t = min(t, sdSegment(uv,vec2(3.2,-1.8),vec2(2.65,-1.0)));\n    t = min(t, sdSegment(uv,vec2(1.25,1.1),vec2(1.8,0.3)));\n    uv.y -= 4.8;\n    uv *= rot(0.36);\n    return min(t, sdArc(uv, vec2(1.0,0.0),vec2(-0.4,1.0), 3.0, 0.));\n}\n\nfloat dfU2D(vec2 uv)\n{\n    vec2 quv = uv - vec2(0.0,1.1);\n    quv *= rot(-0.3);\n    quv.x *= 3.0;\n \tfloat t = sdArc(quv, vec2(1.0,0.0),vec2(-1.0,0.0), 2.8, 0.0);\n    t = min(t, sdSegment(uv, vec2(1.4,1.7), vec2(1.4,-1.8)));\n    t = min(t, sdSegment(uv, vec2(1.4,-1.8), vec2(0.9,-1.8)));\n    t = min(t, sdSegment(uv, vec2(-1.7,1.8), vec2(-0.6,1.8)));\n    quv = uv - vec2(-4.0,4.3);\n    quv *= rot(0.54);\n    return min(t, sdArc(quv, vec2(1.0,0.0),vec2(-0.24,1.0), 3.4, 0.));    \n}\n\nfloat map(vec3 p) \n{\n    float t = dfS3D(p - vec3(-5.2,0.0,0.0));\n    t = min(t, dfH3D(p - vec3(-2.3,0.0,0.0)));\n    t = min(t, dfA3D(p - vec3(0.2,0.0,0.0)));\n    t = min(t, dfU3D(p - vec3(4.4,0.0,0.0)));\n    return t -0.1;\n}\n\nvec3 normal(vec3 p) \n{  \n    vec4 n = vec4(0.0);\n    for (int i=ZERO; i<4; i++) \n    {\n        vec4 s = vec4(p, 0.0);\n        s[i] += EPS;\n        n[i] = map(s.xyz);\n    }\n    return normalize(n.xyz-n.w);\n}\n\n//IQ - http://www.iquilezles.org/www/articles/raymarchingdf/raymarchingdf.htm\nfloat AO(vec3 p, vec3 n) \n{    \n    float ra = 0., w = 1., d = 0.;\n    for (float i = 1.; i < 12.; i += 1.){\n        d = i / 5.;\n        ra += w * (d - map(p + n * d));\n        w *= .5;\n    }\n    return 1. - clamp(ra, 0., 1.);\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat apprSoftShadow(vec3 ro, vec3 rd, float mint, float tmax, float w)\n{\n \tfloat t = mint;\n    float res = 1.0;\n    for( int i=ZERO; i<256; i++ )\n    {\n     \tfloat h = map(ro + t*rd);\n        res = min( res, h/(w*t) );\n    \tt += clamp(h, 0.005, 0.30);\n        if( res<-1.0 || t>tmax ) break;\n    }\n    res = max(res,-1.0); // clamp to [-1,1]\n\n    return 0.25*(1.0+res)*(1.0+res)*(2.0-res); // smoothstep\n}\n\nfloat sparkles(vec2 uv)\n{\n    float t = length(uv - vec2(-3.9,1.9));\n    t = min(t, length(uv - vec2(-6.4,-2.0)));\n    t = min(t, length(uv - vec2(-1.0,1.7)));\n    t = min(t, length(uv - vec2(-4.1,-0.4)));\n    t = min(t, length(uv - vec2(-2.4,1.95)));\n    t = min(t, length(uv - vec2(1.9,2.5)));\n    t = min(t, length(uv - vec2(3.0,-0.4)));\n    t = min(t, length(uv - vec2(4.3,1.8)));\n    return min(t, length(uv - vec2(6.4,1.75)));\n}\n\nvec2 pol(vec3 rd)\n{\n    float a = (atan(rd.x,rd.y)/6.28318) + 0.5;\n\treturn vec2(a,floor(a*24.0)/24.0);  \n}\n\nvec3 bg3(vec3 rd, vec3 hu, float nz)\n{\n\tvec2 pa = pol(rd);\n    float m = mod(abs(rd.y) + h1(pa.y*sign(rd.z))*4. - T*.08, .3); \n    return hu*step(.1, fract(pa.x * 24.))*h1(pa.y)*step(m, .16)*m*50.0*rd.y*rd.y +\n           hu/(1.0 + rd.y*rd.y*1000.0)*nz;\n}\n\nvoid mainImage(out vec4 C, vec2 U)\n{\n    vec2 uv = (U - R*.5) / R.y;\n    float fl = 1.4,\n          AT = mod(T, 40.),\n          nz = noise(uv, 64., 16., float(iFrame), float(iFrame), .96);\n    vec3 la = vec3(0),\n         lp = vec3(4,6,-5),\n         ro = vec3(0,sin(T*0.2),-8. - cos(T*0.4)*0.5),\n         hu = rotHue(vec3(1,0.1,0.2), T*0.1),\n         hu2 = rotHue(vec3(1,0.1,0.2), (T+6.0)*0.1);\n    ro.xz *= rot(sin(T*0.1)*0.2);\n    ro += 0.1*n13(T);\n    //camera\n    vec3 fwd = normalize(la-ro),\n         rgt = normalize(vec3(fwd.z,0.0,-fwd.x)),\n         rd = normalize(fwd + fl*uv.x*rgt + fl*uv.y*cross(fwd, rgt));\n    //background\n    float yy = rd.y*rd.y;\n    vec2 pa = pol(rd); \n    vec3 pc1 = (hu/(1.0 + yy*32.0) +\n                mix(hu,vec3(1),0.7)/(1.0 + yy*256.0)) * nz,\n         pc2 = (hu*yy*8.0 +\n\t            mix(hu,vec3(1),0.7)*yy*2.*clamp(nz,0.96,1.0)) * clamp(nz,0.98,1.0),\n         pc3 = bg3(rd,hu,nz),\n         pc4 = mix(mix(hu*nz,vec3(1),yy*4.0),\n                   hu,\n                   S(0.02, 0.0, length(fract(yy*6.0-T*0.4) - 0.5)) +\n                  (S(0.46, 0.5, fract(pa.x*24.0)) * S(0.54, 0.5, fract(pa.x*24.0))))*yy*8.;\n    //ray march\n    float t = 0.0;   \n    for (int i=ZERO; i<200; i++)\n    {\n        float ns = map(ro + rd*t);\n        if (abs(ns)<EPS) break;\n        t += ns *0.8;\n        if (t>FAR) \n        {\n            t = -1.0;\n            break;\n        }\n        \n    }\n    //render\n    if (t>0.0)\n    {\n        vec3 p = ro + rd*t,\n             n = normal(p),\n             rrd = reflect(rd,n),\n             ld = normalize(lp - p),\n             bgc = mix(hu,hu2,clamp((p.y*-1.)+sin(p.x*2.)*0.3,0.,1.));        \n        float ao = AO(p,n),\n              spec = pow(max(dot(reflect(-ld, n), -rd), 0.0), 8.0),\n              spec2 = max(dot(reflect(-ld, n), -rd), 0.0),\n              frs = pow(clamp(dot(n, rd) + 1.,0.,1.),1.),\n              sh = apprSoftShadow(p, ld, 0.01, FAR, 0.1),\n              spa = sparkles(p.xy);\n\n        float hg = dfS2D(p.xy - vec2(-5.2,0.0));\n        hg = min(hg, dfH2D(p.xy));\n        hg = min(hg, dfA2D(p.xy));\n        hg = min(hg, dfU2D(p.xy - vec2(5.0,0.0)));\n        \n        //neon\n        pc1 = hu*2.0 / (1.0 + hg*hg*100.6);\n        pc1 += hu2*max(0.0,n.y)*0.3;\n        pc1 += vec3(2) * spec;\n        pc1 *= ao;\n        \n        //hip-hop\n        pc2 = vec3(0.4,0.6,0.6) + bgc / (1. + hg*hg*0.6);\n        vec3 hg2 = mix(pc2,bgc,1.0/(1.0 + hg*hg*100.));\n        pc2 = mix(pc2,hg2,S(0.0,1.0,abs(p.y+0.4)));\n        pc2 = mix(pc2,bgc*2.0,1.0/(1.0 + spa*spa*6.0));\n        vec3 hg3 = mix(pc2, vec3(2), 1.0/(1.0 + hg*hg*400.));        \n        pc2 = mix(pc2,hg3,S(0.5,2.0,abs(p.y+0.4)));\n        pc2 *= max(0.05,dot(ld,n));\n        pc2 *= ao * sh;\n        pc2 += vec3(0.3)*(spec + spec2);\n        pc2 += vec3(1)/(1.0 + spa*spa*30.0);        \n\n        //dark reflection\n        pc3 = mix(mix(hu*0.4,vec3(0.2),0.4)*max(0.05,dot(ld,n)),\n                  bg3(rrd,hu,nz)*0.5,\n                  S(0.15,0.12,hg));\n        pc3 += hu2*max(0.0,n.y)*0.3;\n        pc3 += vec3(2)*spec;\n        pc3 *= ao*sh;\n        \n        //silver\n        pc4 = mix(hu,vec3(1),0.7)*max(0.,0.6+dot(ld,n)*0.4);\n        pc4 += hu2*max(0.0,n.y)*0.4;\n        pc4 += vec3(0.7)*spec2 + vec3(1)*spec;\n        pc4 *= ao*(0.6 + sh*0.4);\n        pc4 = mix(pc4,hu,1.0/(1.0 + hg*hg*60.));\n        pc4 += vec3(2) / (1.0 + hg*hg*1000.);\n        \n    }\n    //transitions\n    vec2 axy = fract((uv-0.5)*40.0) - 0.5;\n    vec3 pc = mix(pc1,pc2,step(length(axy),clamp(uv.y - (5. - AT),-0.1,1.4))); \n    pc = mix(pc4,pc,step(length(axy),clamp(length(uv) - (AT - 15.0),-0.1,1.4)));\n    pc = mix(pc3,pc,step(length(axy),clamp(uv.y - (-25. + AT),-0.1,1.4)));\n    pc = mix(pc1,pc,step(length(axy),clamp(length(uv) - (AT - 35.0),-0.1,1.4)));\n    pc *= 1. + sin(uv.y*800. + T)*0.02;\n    pc *= 1. + sin(uv.x*800. + T)*0.02;\n    \n    C = vec4(pc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dsfDj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dsfRj", "name": "ShATI - Bouquet", "author": "Flopine", "description": "My former school named ATI decided to launch an everyday challenge from 4th may to 24th may, here is the first subject: bouquet :) ", "tags": ["raymarching", "flower", "everydaychallenge"], "likes": 11, "viewed": 741, "date": "1588620976", "time_retrieved": "2024-06-20T20:06:18.667451", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n// Shader made for Everyday ATI challenge\n\n#define PI 3.141592\n#define TAU (2.*PI)\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nvoid mo (inout vec2 p , vec2 d)\n{\n    p = abs(p)-d;\n    if (p.y>p.x) p = p.yx;\n}\n\nvoid moda(inout vec2 p, float rep)\n{\n    float per = TAU/rep;\n    float a = atan(p.y,p.x);\n    float l = length(p);\n    a = mod(a,per)-per*0.5;\n    p = vec2(cos(a),sin(a))*l;\n}\n\nfloat cyl (vec3 p, float r, float h)\n{return max(length(p.xy)-r,abs(p.z)-h);}\n\nfloat plane (vec3 p, vec3 n)\n{return dot(p,normalize(n));}\n\nfloat stack (vec3 p)\n{\n    p.y += 4.;\n    p.xz *= rot(sin(p.y+iTime));\n    moda(p.xz,6.);\n    p.x -= 0.15+abs(p.y)*0.5 ;\n    return cyl(p.xzy, 0.1+abs(p.y+5.5)*0.03, 3.);\n}\n\nfloat st, flower;\nvec3 new_p;\nfloat SDF (vec3 p)\n{ \n    mo(p.xz, vec2(1.5));\n    p.xz*=rot(p.y*0.5);\n\n    vec3 pp = p+0.3;\n    st = stack(pp);\n\n    mo(p.xz,vec2(.5));    \n    p.yz *= rot(sin(length(p)-iTime)*2.);    \n    mo(p.yz, vec2(0.9));\n    mo(p.xy, vec2(0.5));\n    new_p = p;\n    flower = plane(p, vec3(.2,.2,0.2));\n\n    return min(st,flower);\n}\n\nvec3 getcam (vec3 ro, vec3 tar, vec2 uv)\n{\n    vec3 f = normalize(tar-ro);\n    vec3 l = normalize(cross(vec3(0.,1.,0.),f));\n    vec3 u = normalize(cross(f,l));\n    return normalize(f + uv.x*l + uv.y*u);\n}\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2(0.001,0.);\n    return normalize(vec3(SDF(p)-vec3(SDF(p-eps.xyy),SDF(p-eps.yxy),SDF(p-eps.yyx))));\n}\n\nvec3 palette (float t, vec3 a, vec3 b, vec3 c, vec3 d)\n{return a+b*cos(TAU*(c*t+d));}\n\nvec3 background (vec2 uv)\n{\n    float mask = smoothstep(0.15,0.1,fract(abs(abs(uv.x-uv.y)-0.2)-0.1));\n    return (mask >= 0.99) ? vec3(0.8,0.6,0.8) : vec3(0.9);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(2.5,3.,-6.),\n        rd = getcam(ro, vec3(0.,-1.5,0.), uv),\n        p = ro,\n        col = background(uv);\n\n    float shad,d = 0.;\n    bool hit = false;\n\n    for (float i=0.; i<64.; i++)\n    {\n        d = SDF(p);\n        if (d<0.01)\n        {\n            hit = true;\n            shad = i/64.;\n            break;\n        }\n        p+=d*rd*0.4;\n    }\n\n    if (hit)\n    {\n        if (d == flower) col = palette(length(p),vec3(0.5), vec3(0.4),vec3(0.3), vec3(0.7,0.5,0.3));\n        if (d == st) col = vec3(0.5,1.,new_p.y);\n        vec3 n = getnorm(p);\n        col *= smoothstep(0.15,0.25,pow(abs(n.z), 0.8));\n    }\n\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dsfRj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dSfRy", "name": "Aliasing Effects", "author": "Helliaca", "description": "CLICK AND DRAG MOUSE (left-to-right) TO INTERACT\n\nAliasing effects from circular patterns.", "tags": ["aliasing"], "likes": 0, "viewed": 47, "date": "1590245978", "time_retrieved": "2024-06-20T20:06:18.812327", "image_code": "// Authors: Benjamin Kahl, Jaroslaw Urbanek\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Set r position in relation to mouse coord\n    float r = 100.0 + abs(800.0*sin(0.3*iTime));\n    \n    // Set origin to center\n    vec2 uv = fragCoord - 0.5*iResolution.xy;\n\n    // Compute color value\n    r*=0.1;\n    float value = mod((uv.x*uv.x + uv.y*uv.y), r*r) / (r*r);\n\n    // Output to screen\n    fragColor = vec4(vec3(value),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dSfRy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dsfWl", "name": "Booze Cruise", "author": "dr2", "description": "Easy sailing with a favorite drink (impossible now)", "tags": ["refraction", "ocean", "glass", "beer", "bottle"], "likes": 21, "viewed": 435, "date": "1589278530", "time_retrieved": "2024-06-20T20:06:18.838978", "image_code": "// \"Booze Cruise\"  by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0    // optional antialiasing (longer compile time)\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Noisefv2 (vec2 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nstruct {\n  vec3 pCont;\n  float rCont, hCont, hSurf, hCap, hLab;\n} cnf;\n\nvec3 sunDir, ltDir;\nfloat dstFar, tCur, rTbl, hTbl;\nint idObj;\nbool inCont, chkLbl, doBott;\nconst int idCap = 1, idBal = 2, idLbl1 = 3, idLbl2 = 4, idLbl3 = 5, idStir = 6, idStirB = 7,\n   idFom = 8, idTbl = 9, idFlr = 10, idRail = 11, idWal = 12;\n\nconst float pi = 3.14159;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat TObjDf (vec3 p)\n{\n  vec3 pp, q;\n  float dMin, d, r, bf, s, rb, hb;\n  dMin = dstFar;\n  pp = p - cnf.pCont;\n  r = length (pp.xz);\n  if (doBott) {\n    bf = 0.95;\n    s = bf * cnf.rCont;\n    q = pp;\n    rb = cnf.rCont * (bf + (1. - bf) * smoothstep (0., 0.2 * cnf.rCont, q.y + cnf.hCont) -\n       0.65 * smoothstep (0., 1.5 * cnf.rCont, q.y - cnf.hCont) +\n       0.05 * smoothstep (0.,  0.1 * cnf.rCont, q.y - 2. * cnf.hCont - 0.7 * cnf.rCont));\n    d = inCont ? rb - r : r - rb;\n    d = max (d, max (q.y - 2. * cnf.hCont - cnf.rCont, - q.y - cnf.hCont));\n    hb = cnf.hCont + 0.3 * (r * r / (s * s) - 1.);\n    d = min (d, max (r - bf * cnf.rCont, abs (q.y + hb - 0.02) - 0.02));\n    dMin = d;\n  } else {\n    bf = 0.95;\n    q = pp;\n    rb = cnf.rCont * (bf + (1. - bf) * smoothstep (0., 0.2 * cnf.rCont, q.y + cnf.hCont) +\n       0.4 * smoothstep (0., 2.8 * cnf.rCont, q.y + 0.75 * cnf.hCont));\n    d = inCont ? rb - r : r - rb;\n    d = max (d, abs (q.y) - cnf.hCont);\n    q.y -= - cnf.hCont + 0.05;\n    d = min (d, PrCylDf (q.xzy, bf * cnf.rCont, 0.05));\n    dMin = d;\n  }\n  return 0.8 * dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 pp, q;\n  float dMin, d, r, rm, a, s, db;\n  dMin = dstFar;\n  pp = p - cnf.pCont;\n  r = length (pp.xz);\n  rm = 1.4 * cnf.rCont;\n  if (doBott) {\n    q = pp;\n    q.y -= cnf.hCap;\n    d = PrCylDf (q.xzy, 0.4 * cnf.rCont + 0.4 - min (0.4 * (q.y + 0.4) * (q.y + 0.4), 1.), 0.4);\n    DMIN (idCap);\n    if (inCont) {\n      q = pp;\n      q.x = abs (q.x) - 0.7;\n      q.y -= - cnf.hCont + 0.9;\n      d = PrSphDf (q, 0.6);\n      DMIN (idBal);\n    }\n    if (! inCont && chkLbl) {\n      q = pp;\n      q.y -= cnf.hLab;\n      db = abs (r - cnf.rCont - 0.02) - 0.01;\n      a = atan (q.z, - q.x);\n      d = max (db, length (vec2 (r * a, q.y)) - 2.);\n      DMIN (idLbl1);\n      d = max (db, max (abs (2. * (mod (a, 2. * pi) - pi)), abs (q.y)) - 2.);\n      DMIN (idLbl2);\n    }\n  } else {\n    if (! inCont && chkLbl) {\n      q = pp;\n      q.y -= cnf.hLab;\n      d = max (abs (r - rm - 0.02) - 0.01, length (vec2 (r * atan (- q.x, - q.z), q.y)) - 1.5);\n      DMIN (idLbl3);\n    }\n    q = pp;\n    q.xz = Rot2D (q.xz, 0.3 * pi);\n    q.xy = Rot2D (q.xy - vec2 (1.2, 1.6), 0.05 * pi);\n    d = PrCylDf (q.xzy, 0.2, cnf.hCont + 1.5);\n    DMIN (idStir);\n    q.y -= cnf.hCont + 1.5;\n    d = PrSphDf (q, 0.3);\n    DMIN (idStirB);\n    q = pp;\n    s = r / rm;\n    s = 0.2 * (1. - s * s);\n    q.y -= cnf.hCont - 0.1 + s;\n    d = PrCylDf (q.xzy, rm - 0.03, 0.2 + s);\n    DMIN (idFom);\n  }\n  if (! inCont) {\n    q = p;\n    q.y -= hTbl - 0.1;\n    d = PrCylDf (q.xzy, rTbl, 0.1);\n    DMIN (idTbl);\n    q = p;\n    q.y -= 0.5 * hTbl;\n    d = PrCylDf (q.xzy, 1., 0.5 * hTbl);\n    q = p;\n    q.z -= 17.;\n    d = min (d, max (q.y, q.z));\n    DMIN (idFlr);\n    q.y = abs (abs (q.y - 8.) - 4.) - 2.;\n    q.z -= -0.5;\n    d = length (q.yz) - 0.3;\n    q = p;\n    q.x = mod (q.x + 5., 10.);\n    q -= vec3 (5., 6.5, 16.5);\n    d = min (d, PrCylDf (q.xzy, 0.3, 7.5));\n    DMIN (idRail);\n    d = max (max (61. - length (p.xz), abs (p.y - 20.) -20.1), p.z - 15.);\n    DMIN (idWal);\n  }\n  return 0.8 * dMin;\n}\n\nfloat TObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = TObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 CObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.005, -0.005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = TObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.005, -0.005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat LabSym (vec2 p)\n{\n  vec2 q;\n  float d, r;\n  r = length (p);\n  d = max (min (0.06 - abs (0.1 - abs (r - 0.8)), p.y), min (0.06 - abs (p.y), 1.1 - abs (p.x)));\n  q = Rot2D (p, 2. * pi * floor (16. * ((r > 0.) ? atan (p.y, - p.x) / (2. * pi) : 0.) + 0.5) / 16.);\n  d = max (d, min (min (0.06 - abs (q.y), 0.2 - abs (q.x + 1.1)), p.y + 0.1));\n  q.x += 1.5;\n  d = max (d, min (0.1 - length (q), p.y + 0.1));\n  return d;\n}\n\nvec4 ObjCol (vec3 p)\n{\n  vec4 c, colLb1, colLb2, colLb3, colLb4;\n  vec3 q;\n  vec2 w;\n  float r, a, s;\n  colLb1 = vec4 (0., 0.7, 0.4, 0.1);\n  colLb2 = vec4 (0., 0., 0.5, 0.1);\n  colLb3 = vec4 (1., 1., 0.2, 0.3);\n  colLb4 = vec4 (0.7, 0.7, 0.7, 0.);\n  q = p - cnf.pCont;\n  r = length (q.xz);\n  if (doBott) {\n    a = atan (q.z, - q.x);\n    if (idObj == idCap) {\n      c = colLb1 + 0.1;\n      if (r < 1.4) {\n        if (q.y > cnf.hCap - 0.1) {\n          s = LabSym (1.3 * q.xz);\n          c = mix (mix (c, colLb2, smoothstep (-0.05, -0.01, s)), colLb3, smoothstep (0.01, 0.05, s));\n        } else c *= 0.5;\n      } else c *= 1. - 0.3 * sin (16. * a);\n    } else if (idObj == idLbl1) {\n      w = vec2 ((cnf.rCont + 0.1) * a, q.y - cnf.hLab);\n      c = mix (colLb1, colLb2, smoothstep (0., 0.05, length (w) - 1.9));\n      s = LabSym (0.9 * w);\n      c = mix (mix (c, colLb2,\n         smoothstep (-0.05, -0.01, s)), colLb3, smoothstep (0.01, 0.05, s));\n      if (r < cnf.rCont + 0.01) c = mix (c, colLb4, 0.8);\n    } else if (idObj == idLbl2) {\n      w = vec2 ((cnf.rCont + 0.1) * (mod (a, 2. * pi) - pi), q.y - cnf.hLab);\n      c = mix (colLb1, colLb2, smoothstep (0., 0.05, max (abs (w.x) - 2.95, abs (w.y) - 1.9)));\n      w = mod (w + vec2 (0., 0.5), vec2 (3., 2.2)) - 0.5 * vec2 (3., 2.2);\n      s = LabSym (1.5 * w);\n      c = mix (mix (c, colLb2,\n         smoothstep (-0.05, -0.01, s)), colLb3, smoothstep (0.01, 0.05, s));\n      if (r < cnf.rCont + 0.01) c = mix (c, colLb4, 0.8);\n    } else if (idObj == idBal) {\n      c = vec4 (0.9, 0.9, 1., 0.2); \n    }\n  } else {\n    if (idObj == idLbl3) {\n      w = vec2 ((1.4 * cnf.rCont + 0.1) * atan (- q.x, - q.z), q.y - cnf.hLab);\n      c = mix (colLb1, colLb2, smoothstep (0., 0.05, length (w) - 1.4));\n      s = LabSym (1.4 * w);\n      c = mix (mix (c, colLb2, smoothstep (-0.05, -0.01, s)), colLb3, smoothstep (0.01, 0.05, s));\n      if (r < 1.4 * cnf.rCont + 0.01) c = mix (c, colLb4, 0.8);\n    } else if (idObj == idFom) {\n      c = vec4 (1., 1., 1., 0.3) * (1. - 0.1 * Fbm2 (8. * q.xz));\n    } else if (idObj == idStir) {\n      q.xz = Rot2D (q.xz, 0.3 * pi);\n      q.xy = Rot2D (q.xy - vec2 (1.2, 1.6), 0.05 * pi);\n      c = mix (vec4 (0.8, 0.9, 0.8, 0.1), vec4 (0.9, 0.7, 0., 0.1), step (0., sin (4. * pi * q.y)));\n    } else if (idObj == idStirB) {\n      c = vec4 (0.9, 0.3, 0.3, 0.1);\n    }\n  }\n  if (idObj == idTbl) {\n    c = vec4 (0.85, 0.95, 0.9, 0.2);\n    if (p.y > hTbl - 0.1) c = (mix (vec4 (0.5, 0.7, 0.4, 0.1), c, \n       smoothstep (0.02, 0.03, abs (Fbm2 (vec2 (0.5, 0.2) * p.xz) - 0.4)))) *\n       (0.7 + 0.3 * smoothstep (0.2, 0.5, r - cnf.rCont));\n  } else if (idObj == idFlr) {\n    c = vec4 (0.5, 0.3, 0.1, 0.1) * (0.7 + 0.3 * SmoothBump (0.1, 3.9, 0.05, mod (p.z + 2., 4.))) *\n       (0.8 + 0.2 * smoothstep (0.1, 0.2, length (p.xz) - rTbl));\n  } else if (idObj == idRail) {\n    c = vec4 (0.8, 0.8, 0.9, 0.1);\n  } else if (idObj == idWal) {\n    c = vec4 (0.9, 0.9, 0.85, 0.1);\n  }\n  return c;\n}\n\nfloat WaveHt (vec2 p)\n{\n  mat2 qRot = mat2 (0.8, -0.6, 0.6, 0.8);\n  vec4 t4, v4;\n  vec2 q, t, tw;\n  float wFreq, wAmp, h;\n  q = 0.5 * p + vec2 (1.5, 0.) * tCur;\n  h = 0.5 * sin (dot (q, vec2 (-0.05, 1.))) + 0.3 * sin (dot (q, vec2 (0.1, 1.2)));\n  wFreq = 1.;\n  wAmp = 1.;\n  tw = 0.1 * tCur * vec2 (1., -1.);\n  for (int j = VAR_ZERO; j < 3; j ++) {\n    q *= qRot;\n    t4 = q.xyxy * wFreq + tw.xxyy;\n    t = vec2 (Noisefv2 (t4.xy), Noisefv2 (t4.zw));\n    t4 += 2. * t.xxyy - 1.;\n    v4 = (1. - abs (sin (t4))) * (abs (sin (t4)) + abs (cos (t4)));\n    t = 1. - sqrt (v4.xz * v4.yw);\n    t *= t;\n    t *= t;\n    h += wAmp * dot (t, t);\n    wFreq *= 2.;\n    wAmp *= 0.5;\n  }\n  return h;\n}\n\nvec3 WaveNf (vec3 p, float d)\n{\n  vec2 e;\n  e = vec2 (max (0.01, 0.005 * d * d), 0.);\n  p *= 0.5;\n  return normalize (vec3 (0.3 * (WaveHt (p.xz) - vec2 (WaveHt (p.xz + e.xy),  WaveHt (p.xz + e.yx))), e.x)).xzy;\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol;\n  vec2 q;\n  float sd, a, f, ff, fd, h;\n  a = atan (rd.z, rd.x) - 0.005 * tCur;\n  h = Fbm1 (32. * a);\n  if (rd.y < 0.02 * h * h + 0.005) {\n    col = mix (vec3 (0.3, 0.32, 0.3), vec3 (0.4, 0.43, 0.43), 0.5 +\n       0.5 * dot (normalize (rd.xz), - normalize (sunDir.xz))) *\n       (1. - 0.3 * Fbm2 (128. * vec2 (a, rd.y)));\n  } else {\n    q = 0.01 * (ro.xz + vec2 (0., 8.) * tCur + ((200. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = 0.7 * (0.7 + 0.5 * ff) * (vec3 (1.) - vec3 (0.2, 0.2, 0.1) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    fd = smoothstep (0.01, 0.1, rd.y);\n    col = mix (mix ((vec3 (0.7, 0.7, 0.75)), vec3 (0.4, 0.5, 0.8), 0.3 + 0.7 * fd), clCol, 0.1 + 0.9 * f * fd);\n    sd = pow (max (dot (rd, sunDir), 0.), 256.);\n    col += (0.1 * sd + 0.3 * pow (sd, 4.)) * vec3 (1., 1., 0.3);\n  }\n  return col;\n}\n\nvoid SetParm (int cnfId)\n{\n  hTbl = 6.;\n  rTbl = 12.;\n  if (cnfId == 0) {\n    cnf.rCont = 3.;\n    cnf.hCont = 2. * cnf.rCont;\n    cnf.pCont = vec3 (2.5 * cnf.rCont, cnf.hCont + hTbl + 0.2, 0.);\n    cnf.hSurf = 2.8 * cnf.hCont + hTbl;\n    cnf.hCap = 2. * cnf.hCont + cnf.rCont + 0.1;\n    cnf.hLab = 0.3 * cnf. hCont;\n  } else {\n    cnf.rCont = 2.5;\n    cnf.hCont = 2.5 * cnf.rCont;\n    cnf.pCont = vec3 (-2.5 * cnf.rCont, cnf.hCont + hTbl + 0.2, 0.);\n    cnf.hSurf = 2. * cnf.hCont + hTbl - 0.1;\n    cnf.hLab = 0.65 * cnf.hCont;\n  }\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 roo, rdo, rdd, vn, vnW, colD, colR, col, row, rdw;\n  vec2 vf;\n  float dstObj, dstCont, dstContW, dstSurf, rdDotN, eta, hMenisc, dw, s, rFac;\n  bool contHit, inLiq, inLiqW;\n  SetParm (doBott ? 0 : 1);\n  eta = 1.33;\n  roo = ro;\n  rdo = rd;\n  inCont = false;\n  chkLbl = true;\n  dstCont = TObjRay (ro, rd);\n  dstObj = ObjRay (ro, rd);\n  dstContW = dstCont;\n  hMenisc = 0.;\n  rdDotN = 0.;\n  inLiq = false;\n  contHit = (dstCont < min (dstObj, dstFar));\n  if (contHit) {\n    ro += dstCont * rd;\n    vn = CObjNf (ro);\n    vnW = vn;\n    rdDotN = - dot (rd, vn);\n    if (ro.y < cnf.hSurf) {\n      rd = refract (rd, vn, 1. / eta);\n      inLiq = true;\n      inLiqW = true;\n    }\n    hMenisc = max (0., ro.y - cnf.hSurf);\n    ro += 0.01 * rd;\n    inCont = true;\n    dstSurf = dstFar;\n    if (inLiq && rd.y > 0. || ! inLiq && rd.y < 0.) dstSurf = - (ro.y - cnf.hSurf) / rd.y;\n    dstCont = TObjRay (ro, rd);\n    dstObj = ObjRay (ro, rd);\n    if (dstSurf < min (min (dstCont, dstObj), dstFar)) {\n      ro += dstSurf * rd;\n      if (inLiq) {\n        vn = vec3 (0., -1., 0.);\n        rdd = refract (rd, vn, eta);\n        if (length (rdd) > 0.) {\n          rd = rdd;\n          inLiq = false;\n        } else {\n          rd = reflect (rd, vn);\n        }\n      } else {\n        vn = vec3 (0., 1., 0.);\n        rd = refract (rd, vn, 1. / eta);\n        inLiq = true;\n        inLiqW = true;\n      }\n      ro += 0.01 * rd;\n      dstCont = TObjRay (ro, rd);\n      dstObj = ObjRay (ro, rd);\n    }\n    if (dstCont < min (dstObj, dstFar)) {\n      ro += dstCont * rd;\n      vn = CObjNf (ro);\n      if (inLiq) {\n        rdd = refract (rd, vn, eta);\n        if (length (rdd) > 0.) {\n          rd = rdd;\n          inCont = false;\n          inLiq = false;\n        } else {\n          rd = reflect (rd, vn);\n        }\n      } else inCont = false;\n      hMenisc = min (hMenisc, max (ro.y - cnf.hSurf, 0.));\n      ro += 0.01 * rd;\n      dstObj = ObjRay (ro, rd);\n    }\n  }\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    col4 = ObjCol (ro);\n    vn = ObjNf (ro);\n    vf = vec2 (0.);\n    if (idObj == idFom) vf = vec2 (16., 1.);\n    else if (idObj == idWal) vf = vec2 (128., 0.2);\n    else if (idObj == idFlr) {\n      s = mod (ro.z + 2., 4.);\n      vn.yz = Rot2D (vn.yz, 0.2 * pi * SmoothBump (0.2, 0.3, 0.05, abs (s)) * sign (s - 2.));\n    }\n    if (vf.x > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n    colD = col4.rgb * (0.2 + 0.2 * max (- dot (ltDir, vn), 0.) + 0.8 * max (dot (ltDir, vn), 0.) +\n       col4.a * pow (max (dot (rd, reflect (sunDir, vn)), 0.), 32.));\n  } else {\n    row = ro;\n    rdw = rd;\n    rFac = 1.;\n    if (rd.y < 0.) {\n      dw = - row.y / rdw.y;\n      row += dw * rdw;\n      rdw = reflect (rdw, WaveNf (row, dw));\n      rFac = 0.9;\n    }\n    colD = rFac * BgCol (row, rdw);\n  }\n  colR = vec3 (0.);\n  if (contHit) {\n    ro = roo;\n    rd = rdo;\n    ro += dstContW * rd;\n    rd = reflect (rd, vnW);\n    ro += 0.01 * rd;\n    inCont = false;\n    chkLbl = false;\n    dstObj = ObjRay (ro, rd);\n    if (dstObj < dstFar) {\n      ro += dstObj * rd;\n      col4 = ObjCol (ro);\n      vn = ObjNf (ro);\n      colR = col4.rgb * (0.2 + 0.2 * max (- dot (ltDir, vn), 0.) + 0.8 * max (dot (ltDir, vn), 0.) +\n         col4.a * pow (max (dot (rd, reflect (sunDir, vn)), 0.), 32.));\n    } else {\n      row = ro;\n      rdw = rd;\n      rFac = 1.;\n      if (rd.y < 0.) {\n        dw = - row.y / rdw.y;\n        row += dw * rdw;\n        rdw = reflect (rdw, WaveNf (row, dw));\n        rFac = 0.9;\n      }\n      colR = rFac * BgCol (row, rdw);\n    }\n  }\n  if (contHit) {\n    if (inLiqW) hMenisc = 0.;\n    col = mix (vec3 (0.8, 0.7, 0.2), vec3 (1.), smoothstep (0., 0.2, hMenisc)) * colD;\n    if (eta != 1.) col = mix (colR, col, 0.2 + 0.8 * smoothstep (0., 0.9, rdDotN));\n  } else col = colD;\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.05 * pi;\n  if (mPtr.z > 0.) {\n    az += pi * mPtr.x;\n    el += 0.5 * pi * mPtr.y;\n  } else {\n    //float t = mod (0.01 * tCur, 2.);\n    //az += 0.2 * pi * SmoothBump (0.3, 0.7, 0.1, mod (t, 1.)) * sign (t - 1.);\n    //el -= 0.03 * pi * sin (0.007 * pi * tCur);\n  }\n  el = clamp (el, -0.25 * pi, 0.03 * pi);\n  az = clamp (az, -0.3 * pi, 0.3 * pi);\n  if (abs (abs (az) - 0.5 * pi) < 0.19 * pi) az = (0.5 + 0.19 * sign (abs (az) - 0.5 * pi)) * pi * sign (az);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 15., -55.);\n  zmFac = 3.5;\n  dstFar = 150.;\n  ltDir = vuMat * normalize (vec3 (0.5, 1., -1.));\n  sunDir = normalize (vec3 (1., 1., -1.));\n  doBott = (sign (abs (mod (az + 2. * pi, 2. * pi) - pi) - 0.5 * pi) == sign (uv.x));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dsfWl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dSfzD", "name": "Ray Marching 1 KPH", "author": "kpharri", "description": "Copy of Art of Code's tutorial code.", "tags": ["raymarching"], "likes": 3, "viewed": 78, "date": "1589757878", "time_retrieved": "2024-06-20T20:06:19.843854", "image_code": "/*\nGeneral comments:\n\nEverything is vectors. Whenever a point is mentioned below, I actually mean a vector drawn \nfrom some location to that point. Distance between points is really just the difference\nbetween the two vectors representing those points, i.e. everything is vector addition or\nsubtraction, and dot and cross products can be used to obtain useful information.\n\n*/\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST 0.01\n\nfloat GetDist(vec3 p) {\n// Returns the shortest distance from point p to any of the shapes in the field.\n// This function also contains definitions of the shapes themselves. This is probably\n// not the best place for these...\n    \n\tvec4 s = vec4(0, 1, 6, 1); // Sphere parameters. First three are coords of center. Last\n                               // is radius. \n    \n    // Distance to sphere's surface is the distance between point p and the sphere's center,\n    // minus the radius of the sphere.\n    float sphereDist = length(p-s.xyz)-s.w; \n    \n    // We assume a horizontal plane in the x-z plane, so the distance from p to the plane\n    // is just the y-coord of p.\n    float planeDist = p.y;\n    \n    return min(sphereDist,planeDist);\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n// Marches along a ray with origin at ro and direction rd. Returns the\n// distance along the ray from ro to the first intersection with any shape in the view.\n    \n\tfloat dO = 0.; // Distance to origin from current point in the marching process.\n    \n    for (int i=0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO; // Point that's a distance dO along the ray.\n        float dS = GetDist(p); // Shortest distance from p to the object.\n        dO += dS; // Add the shortest distance to the ray location.\n        if (dO>MAX_DIST || dS<SURF_DIST) break; // Check for stopping conditions\n    }\n    return dO;\n}\n\n\nvec3 GetNormal(vec3 p) {\n// Finds the normal vector to the surface of the object at point p.\n    \n\tfloat d = GetDist(p); // Find the shortest distance to the object surface from point p.\n                          // This will not be exactly zero because of the error cushion built\n                          // into the ray marching algorithm.\n    vec2 e = vec2(0.01, 0); // Set up a perturbation vector.\n    vec3 n = d - vec3(    // This line of code hides quite a bit of clever geometry. Draw yourself\n        GetDist(p - e.xyy), // some diagrams in 2D, and do the necessary trig to convince yourself \n        GetDist(p - e.yxy), // that it is correct.\n        GetDist(p - e.yyx));\n    \n    return normalize(n);\n}\n\n\nfloat GetLight(vec3 p) {\n// Diffuse lighting and shadow function. \n    \n    vec3 lightPos = vec3(0, 5, 6); // Defines the position of the light source.\n    lightPos.xz += vec2(sin(iTime),cos(iTime))*2.; // Moves the light source in a horizontal circle.\n    vec3 l = normalize(lightPos-p); // Vector pointing from p to the light source.\n    vec3 n = GetNormal(p); // Unit vector normal to the object's surface.\n    \n    float dif = clamp(dot(n,l),0.,1.); // Brightness is set to the dot product between the surface\n                                       // normal and the ray pointing from the object to the light.\n                                       // clamp function ensures no brightnesses less than zero.\n    \n    float d = RayMarch(p+n*SURF_DIST*2., l); // Use ray marching to determine the distance from the\n                                             // the current point on the object to the light source.\n                                             // Use a location slightly offset from the current point\n                                             // else the ray marching algorithm will exit right away,\n                                             // because we're too close to the object.\n                                       \n    if (d < length(lightPos - p)) dif *= .1; // If the distance traveled by the ray marching algorithm\n                                             // from the the current point toward the light source is \n                                             // less than the full distance to the light, then we've\n                                             // encountered an object between us and the light, and we're\n                                             // therefore in shadow, so lower the brightness.    \n        \n    return dif; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    // Black screen:\n    vec3 col = vec3(0);\n    \n    // Camera:\n    vec3 ro = vec3(0, 1, 0);\n    \n    // Rays drawn from camera through each pixel of screen:\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    // Find the distance along each ray at which we bump into the first shape.\n    // Since rd is a vector of rays passing through the screen pixels, d is going\n    // to be a vector of distances.\n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd*d;\n    float dif = GetLight(p);\n    col = vec3(dif);\n    \n    // The distances are all going to be greater than 1, given the location of ro and\n    // the shapes we've defined. This means that the color used to depict d will be\n    // white for all pixels, which is not very interesting. Therefore, divide d by 6\n    // to make d values smaller. We use 6 because that's how far away the sphere is.\n    //d /= 6.;\n    //col = vec3(d);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dSfzD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dSfzt", "name": "Belvedere", "author": "dr2", "description": "Even penguins get confused by Escher's architecture", "tags": ["illusion", "escher", "artwork", "penguin", "building", "paradox"], "likes": 24, "viewed": 346, "date": "1590568808", "time_retrieved": "2024-06-20T20:06:19.875629", "image_code": "// \"Belvedere\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  1  // optional antialiasing\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h);\nfloat PrFlatCyl2Df (vec2 p, float rhi, float rlo);\nfloat PrEllipsDf (vec3 p, vec3 r);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltDir, qHit, vuDir, vuPln;\nfloat dstFar, tCur, fAng;\nint idObj;\nconst int idFlr = 1, idPil = 2, idBal = 3, idFrz = 4, idRf = 5, idLBld = 6, idLad = 7,\n   idGrnd = 8, idStr = 9, idWal = 10, idPen = 20;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat PengDf (vec3 p, float szFac, float rot, int isSit, float dMin)\n{\n  vec3 q;\n  float d, dh;\n  dMin /= szFac;\n  p /= szFac;\n  if (isSit > 0) p.y -= 1.25;\n  else p.y -= 1.55;\n  q = p;\n  q.y -= 0.5;\n  d = PrSphDf (q, 2.5);\n  if (d < dMin) {\n    p.xz = Rot2D (p.xz, rot);\n    q = p;\n    d = PrEllipsDf (q.xzy, vec3 (1.3, 1.2, 1.4));\n    q.y -= 1.5;\n    dh = PrEllipsDf (q.xzy, vec3 (0.8, 0.6, 1.3));\n    q = p;\n    q.x = abs (q.x);\n    q -= vec3 (0.3, 2., -0.4);\n    d = SmoothMin (d, max (dh, - PrCylDf (q, 0.15, 0.3)), 0.2);\n    DMINQ (idPen + 1);\n    q = p;\n    q.yz -= vec2 (1.6, -0.6);\n    d = max (PrEllipsDf (q, vec3 (0.4, 0.2, 0.6)), 0.01 - abs (q.y));\n    DMINQ (idPen + 2);\n    q = p;\n    q.x = abs (q.x);\n    q -= vec3 (0.3, 2., -0.4);\n    d = PrSphDf (q, 0.15);\n    DMINQ (idPen + 3);\n    q = p;\n    q.x = abs (q.x);\n    if (isSit > 0) {\n      q.xy -= vec2 (0.6, -1.05);\n      q.yz = Rot2D (q.yz, -0.5 * pi);\n      q.y -= -0.6;\n    } else {\n      q.xy -= vec2 (0.4, -0.8);\n    }\n    d = PrCylDf (q.xzy, 0.12, 0.7);\n    DMINQ (idPen + 4);\n    q -= vec3 (0.1, -0.67, -0.4);\n    q.xz = Rot2D (q.xz, -0.07 * pi);\n    d = PrEllipsDf (q.xzy, vec3 (0.15, 0.5, 0.05));\n    q.z -= 0.5;\n    q.xz = Rot2D (q.xz, 0.15 * pi);\n    q.z -= -0.5;\n    d = SmoothMin (d, PrEllipsDf (q.xzy, vec3 (0.15, 0.5, 0.05)), 0.05);\n    q.z -= 0.5;\n    q.xz = Rot2D (q.xz, -0.3 * pi);\n    q.z -= -0.5;\n    d = SmoothMin (d, PrEllipsDf (q.xzy, vec3 (0.15, 0.5, 0.05)), 0.05);\n    DMINQ (idPen + 5);\n    q = p;\n    q.x = abs (q.x);\n    q -= vec3 (1.1, 0.3, -0.2);\n    q.yz = Rot2D (q.yz, -0.25 * pi);\n    q.xy = Rot2D (q.xy, fAng) - vec2 (0.1, -0.4);\n    d = PrEllipsDf (q.xzy, vec3 (0.05, 0.25, 0.9));\n    DMINQ (idPen + 6);\n  } else dMin = min (dMin, d);\n  dMin *= szFac;\n  return dMin;\n}\n\nfloat StairDf (vec3 p, float st, float w, float h)\n{\n  return 0.7 * max ((st + p.y - p.z - abs (mod (p.y + p.z, 2. * st) - st) / sqrt(2.)),\n     max (abs (p.x) - w, max (abs (p.y) - h, abs (p.z) - h)));\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, wb, len, wid, b, ds;\n  dMin = dstFar;\n  len = 4.;\n  wid = 1.;\n  b = 0.1;\n  wb = 0.4 * b;\n  q = p;\n  q.y -= (vuDir.y > 0.) ? 1.2 : -3.;\n  q.xz = (vuDir.y > 0.) ? q.xz : q.zx;\n  d = PrBoxDf (q, vec3 (wid + 1.5 * b, 0.1, len + 1.5 * b));\n  DMINQ (idFlr);\n  if (vuDir.y > 0.) {\n    q = p;\n    q.y -= 4.4;\n    d = abs (q.z) - (len + 1.5 * b);\n    q.z = mod (q.z + (1./3.) * len + 0.05, (2./3.) * len + 0.1) - (1./3.) * len - 0.05;\n    d = max (d, min (max (max (length (vec2 (q.yz)) - (1./3.) * len , length (q.xy) - wid - b) - 0.1,\n       0.3 - q.y), min (PrCylDf ((q - vec3 (0., 1.3, 0.)).xzy, 0.07 * (1. - 1.3 * (q.y - 1.3)), 0.35),\n       PrCylDf ((q - vec3 (0., 1.5, 0.)).xzy, 0.15, 0.03))));\n    DMIN (idRf);\n    q = p;\n    q.y = (abs (q.y - 2.4) - 1.8) * sign (q.y - 2.4);\n    d = max (PrBoxDf (q, vec3 (wid + wb, 0.5, len + wb)), - PrBox2Df (q.xz, vec2 (wid, len) - wb));\n    d = max (d, - PrFlatCyl2Df (vec2 (q.x, q.y + 0.4), wid - b - 0.7, 0.8));\n    d = max (d, - PrFlatCyl2Df (vec2 (mod (q.z + (1./3.) * len, (2./3.) * len) -\n       (1./3.) * len, q.y + 0.4), (1./3.) * len - b - 0.7, 0.8));\n    DMIN (idFrz);\n  } else {\n    q = p;\n    q.y -= -4.5;\n    d = PrBoxDf (q, vec3 (len + b, 1.4, wid + b));\n    d = max (d, - max (PrFlatCylDf ((q - vec3 (- len - b, 0.3, 0.)).yzx, 0.2, 0.6, 0.4), 0.2 - q.y));\n    d = max (d, - max (PrFlatCylDf ((q - vec3 (0.5, 0.3, - wid - b)).yxz, 0.2, 0.6, 0.4), 0.2 - q.y));\n    d = max (d, - max (PrFlatCylDf ((q - vec3 (3., -0.3, - wid - b)).yxz, 0.7, 0.5, 0.4), -0.8 - q.y));\n    d = min (d, PrBoxDf (q - vec3 (- len - b, -0.5, - wid - b - 0.5), vec3 (0.35, 0.2, 0.4)));\n    DMINQ (idLBld);\n    q = p - vec3 (-2.7, -4.1, -2.3);\n    d = StairDf (q, 0.25, 1., 1.2);\n    DMINQ (idStr);\n    q = p - vec3 (-9., -5.5, -5.);\n    d = PrBoxDf (q, vec3 (8.1, 0.4, 6.3));\n    DMINQ (idGrnd);\n    q = p - vec3 (-1., -4.7, -6.);\n    d = PrBoxDf (q, vec3 (0.1, 0.4, 5.2));\n    DMINQ (idWal);\n    q = p - vec3 (-7., -4.7, 1.2);\n    d = PrBoxDf (q, vec3 (9., 0.4, 0.1));\n    DMINQ (idWal);\n  }\n  q = p;\n  q.y -= (vuDir.y > 0.) ? 1.7 : -2.5;\n  q.xz = (vuDir.y > 0.) ? q.xz : q.zx;\n  d = max (PrBoxDf (q, vec3 (wid + wb, 0.4, len + wb)), - PrBox2Df (q.xz, vec2 (wid, len) - wb));\n  d = max (d, - PrBoxDf (q - vec3 (- wid, 0., ((vuDir.y > 0.) ? 0. : - (2./3.) * len)),\n     vec3 (0.2, 0.5, (1./3.) * len)));\n  d = max (d, - max (PrFlatCyl2Df (vec2 (q.y, mod (mod (q.z + (1./3.) * len, (2./3.) * len) -\n     (1./3.) * len + 0.2, 0.4) - 0.2), 0.17, 0.13), abs (q.z) - (len - 0.9 * b)));\n  d = max (d, - PrFlatCyl2Df (vec2 (q.y, mod (q.x + 0.2, 0.4) - 0.2), 0.17, 0.13));\n  DMIN (idBal);\n  if (vuDir.y > 0.) {\n    q = p;\n    d = max (abs (q.y - 3.) - 1.8, PrBox2Df (vec2 (abs (q.x) - wid,\n       abs (abs (q.z) - (2./3.) * len) - (1./3.) * len), vec2 (b)));\n    DMIN (idPil);\n  }\n  q = p;\n  q = vec3 (abs (q.x) - wid, q.y + 0.5, abs (abs (q.z) - 2. * len / 3.) - len / 3.);\n  d = max (PrBox2Df (q.xz, vec2 (b)), abs (q.y) - 1.6);\n  if (vuDir.y < 0.) d = max (d, - dot (q, vuPln));\n  DMIN (idPil);\n  q = p;\n  q = vec3 (abs (abs (q.x) - 2. * len / 3.) - len / 3., q.y + 1.1, abs (q.z) - wid);\n  d = max (PrBox2Df (q.xz, vec2 (b)), abs (q.y) - 2.);\n  if (vuDir.y > 0.) d = max (d, dot (q, vuPln));\n  DMIN (idPil);\n  q = p;\n  q.xy -= (vuDir.y > 0.) ? vec2 (-1.3, 1.) : vec2 (-2.39, -2.);\n  d = abs (q.y) - ((vuDir.y > 0.) ? 1.3 : 2.7);\n  q.xy = Rot2D (q.xy, 0.1 * pi);\n  d = max (d, PrBox2Df (vec2 (q.x, abs (q.z) - ((vuDir.y > 0.) ? 0.3 : 0.28)), vec2 (0.05)));\n  ds = (vuDir.y > 0.) ? max (PrCylDf (vec3 (q.x, mod (q.y + 0.1, 0.4) - 0.21, q.z), 0.03, 0.3),\n     abs (q.y + 1.) - 2.2) : max (PrCylDf (vec3 (q.x, Rot2D (vec2 (mod (q.y + 0.15, 0.4) - 0.2, q.z),\n     -0.019 * pi * (q.y + 0.9))), 0.03, 0.3), abs (q.y - 1.) - 2.2);\n  d = min (d, ds);\n  DMIN (idLad);\n  q = p - vec3 (-4.1, -4.8, -1.7);\n  dMin = PengDf (q, 0.3, 0.45 * pi, 1, dMin);\n  q = p - ((vuDir.y > 0.) ? vec3 (-0.6, 1.3, 0.9) : vec3 (-2.5, -2.9, -0.9));\n  dMin = PengDf (q, 0.35, ((vuDir.y > 0.) ? 0.6 * pi : 0.), 0, dMin);\n  q = p - ((vuDir.y > 0.) ? vec3 (0.3, 1.3, -3.3) : vec3 (3.3, -2.9, -0.3));\n  dMin = PengDf (q, 0.35, ((vuDir.y > 0.) ? 0. : -0.3 * pi), 0, dMin);\n  q = p - vec3 (-3., -5.1, -6.8);\n  q.z = (abs (q.z) - 1.33) * sign (q.z);\n  dMin = PengDf (q, 0.4, 0.7 * pi, 0, dMin);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.002, -0.002);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjAO (vec3 ro, vec3 rd)\n{\n  float ao, d;\n  ao = 0.;\n  for (int j = VAR_ZERO; j < 8; j ++) {\n    d = float (j + 1) / 16.;\n    ao += max (0., d - 3. * ObjDf (ro + d * rd));\n  }\n  return 0.6 + 0.4 * clamp (1. - 0.2 * ao, 0., 1.);\n}\n\nvec4 PengCol (vec3 p)\n{\n  vec4 col4;\n  if (idObj == idPen + 1) col4 = (qHit.z < -0.2 || qHit.z < 0. && length (qHit.xy) < 0.2) ?\n     vec4 (0.95, 0.95, 0.95, 0.05) : vec4 (0.15, 0.15, 0.2, 0.1);\n  else if (idObj == idPen + 2) col4 = vec4 (1., 0.8, 0.2, 0.2);\n  else if (idObj == idPen + 3) col4 = vec4 (0.05, 0.15, 0.05, 0.2);\n  else if (idObj == idPen + 4) col4 = vec4 (0.05, 0.1, 0.05, 0.1);\n  else if (idObj == idPen + 5) col4 = vec4 (0.9, 0.9, 0., 0.3);\n  else if (idObj == idPen + 6) col4 = vec4 (0.25, 0.25, 0.3, 0.1);\n  return col4;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd, vec3 bgCol)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstObj, ao;\n  fAng = -0.2 * pi + 0.15 * pi * SmoothBump (0.25, 0.75, 0.1, mod (0.2 * tCur, 1.)) *\n     sin (8. * pi * tCur);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == idFlr) col4 = (vn.y > -0.99) ? vec4 (0.9, 0.85, 0.85, 0.1) :\n       vec4 (1., 0.3, 0., 0.2);\n    else if (idObj == idBal) col4 = vec4 (0.6, 0.3, 0.1, 0.2);\n    else if (idObj == idLBld) col4 = (abs (qHit.x) < 3.8 && abs (qHit.z) < 0.8) ?\n       vec4 (0., 0., 0.4, 0.) : vec4 (0.85, 0.8, 0.8, 0.2);\n    else if (idObj == idLad) col4 = vec4 (0.95, 0.95, 1., 0.2);\n    else if (idObj == idGrnd) col4 = vec4 (0.7, 0.8, 0.7, 0.1) *\n       (1. - 0.2 * abs (dot (floor (mod (0.75 * qHit.xz, 2.)), vec2 (1., -1.))));\n    else if (idObj == idWal) col4 = vec4 (0.7, 0.7, 0.8, 0.1);\n    else if (idObj == idPil) col4 = vec4 (1., 0.8, 0.2, 0.1);\n    else if (idObj == idStr) col4 = (abs (qHit.x) > 0.85) ? vec4 (0.9, 0.85, 0.85, 0.2) :\n       vec4 (0.6, 0.7, 0.6, 0.1);\n    else if (idObj == idRf) col4 = vec4 (1., 0.3, 0., 0.2);\n    else if (idObj == idFrz) col4 = vec4 (0.9, 0.5, 0., 0.2);\n    else if (idObj > idPen) col4 = PengCol (ro);\n    if (idObj == idLBld || idObj == idFlr || idObj == idWal) vn = VaryNf (16. * ro, vn, 0.5);\n    ao = (idObj != idLad) ? ObjAO (ro, vn) : 1.;\n    col = col4.rgb * (0.2 + 0.8 * max (dot (vn, ltDir), 0.)) +\n       col4.a * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n    col *= ao;\n  } else {\n    col = bgCol;\n  }\n  return pow (clamp (col, 0., 1.), vec3 (0.9));\n}\n\nvec3 BgCol (vec2 uv)\n{\n  return (uv.y + 0.05 < 0.05 * Fbm1 (32. * uv.x)) ? mix (mix (vec3 (0.3, 0.5, 0.3),\n     vec3 (0.2, 0.5, 0.2), smoothstep (0.4, 0.6, Fbm2 (256. * uv))),\n     vec3 (0.85, 0.85, 1.) * (1. - 0.05 * Fbm1 (128. * uv.x)),\n     smoothstep (-0.1, -0.01, uv.y + 0.05)) : mix (vec3 (0.7, 0.7, 0.8), vec3 (0.4, 0.4, 1.),\n     uv.y + 0.05);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col, bgCol, vx, vy;\n  vec2 canvas, uv, uvv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.25 * pi;\n  el = 0.;\n  if (false && mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.5 * pi * mPtr.y;\n  }\n  ro = vec3 (0., - 1.5 * sign (uv.y), -10.);\n  ro.yz = Rot2D (ro.yz, - el);\n  ro.xz = Rot2D (ro.xz, - az);\n  rd = normalize (- ro);\n  vuDir = rd;\n  vx = normalize (vec3 (vuDir.z, 0., - vuDir.x));\n  vy = vec3 (0., 1., 0.) - vuDir.y * vuDir;\n  vuPln = vy;\n  zmFac = 0.15;\n  dstFar = 30.;\n  ltDir = normalize (vec3 (-0.5, 0.7, -1.));\n  bgCol = BgCol (uv);\n  if (max (abs (uv.x), abs (uv.y)) < 0.98) {\n#if ! AA\n    const float naa = 1.;\n#else\n    const float naa = 3.;\n#endif  \n    col = vec3 (0.);\n    sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n    for (float a = float (VAR_ZERO); a < naa; a ++) {\n      uvv = uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) * pi);\n      col += (1. / naa) * ShowScene (ro + vec3 (uvv.x * vx + uvv.y * vy) / zmFac, rd, bgCol);\n    }\n  } else if (abs (uv.x) < 1.) {\n    uv = abs (uv) - 0.97;\n    col = vec3 (0.8, 0.7, 0.2) * (0.5 + 0.5 * smoothstep (0., 0.03, max (uv.x, uv.y)));\n  } else col = vec3 (0.75);\n  if (false && mPtr.z > 0. && length (uv) < 0.01) col *= 0.5;\n  fragColor = vec4 (col, 1);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h)\n{\n  return max (length (p.xy - vec2 (clamp (p.x, - rhi, rhi), 0.)) - rlo, abs (p.z) - h);\n}\n\nfloat PrFlatCyl2Df (vec2 p, float rhi, float rlo)\n{\n  return length (p - vec2 (clamp (p.x, - rhi, rhi), 0.)) - rlo;\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dSfzt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dSfzy", "name": "lr94/PressPlay", "author": "lucasrumney94", "description": "My VHS effect that emulates tracking errors and a screendoor effect. It's like if your TV had a bad capacitor. ", "tags": ["vhs", "screendoor", "fuzzing"], "likes": 3, "viewed": 129, "date": "1590252113", "time_retrieved": "2024-06-20T20:06:20.354170", "image_code": "#define STATIC_ON true\n#define STATIC_FADE_PERIOD 0.7\n\n#define BAR_NOISE_ON true\n\n#define STATIC_NOISE_THRESHOLD 0.8\n#define BAR_NOISE_THRESHOLD 0.98\n#define MAX_BAND_WIDTH 50.\n\nfloat randomNoise(float inputValue)\n{\n\treturn ((sin(inputValue*344.3423+434.21222*inputValue)/8.)+.125)\n\t\t\t+ ((cos(inputValue*456.15+5543.53428*inputValue)/8.)+.125)\n        \t+ ((sin(inputValue*54.21111+455.24534*inputValue)/8.)+.125)\n        \t+ ((cos(inputValue*54.21111+951.23984*inputValue)/8.)+.125);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 XYStaticCol = vec3(1.);\n    vec3 YBarStaticCol = vec3(0.7);\n    vec3 vhsBlueCol = vec3(0.,0.,.8);\n\tvec3 finalCol = vec3(0.);\n    \n    // Useful Signals\n    float YBarNoise = randomNoise(fragCoord.y*iTime);\n    float XYStaticNoise = randomNoise(fragCoord.x*fragCoord.y*iTimeDelta);\n    float sinBackAndForth = (sin(iTime)/2.)+.5;\n    vec4 videoSignal = texture(\n        iChannel0,\n        vec2(\n            fract(uv.x+(fract(iTime)/(100.+iTime))),\n        \tfract(uv.y+(0.01*sin(iTime/YBarNoise)*fract(iTime/3.)))\n        )\n    );\n    \n    \n    \n    // Start with Blue\n   \tfinalCol = videoSignal.rgb;\n    \n    // Add basic Static\n    if(STATIC_ON)\n    {\n        if (XYStaticNoise > STATIC_NOISE_THRESHOLD)\n        {\n            finalCol = mix(XYStaticNoise*XYStaticCol*(.5*cos(iTime/STATIC_FADE_PERIOD)+1.), finalCol, 0.7);\n        } \n    }\n\t\n    if (BAR_NOISE_ON)\n    {\n        \n        if (fract(iTime)<.2)\n        {\n            for (float row = fragCoord.y-MAX_BAND_WIDTH; row<fragCoord.y+MAX_BAND_WIDTH; row++)\n            {\n                if (randomNoise(row*iTime)>BAR_NOISE_THRESHOLD)\n                {\n                    finalCol = YBarStaticCol*YBarNoise;\n                }\n            }\n        }\n    }\n    \n\tvec3 screenDoor = vec3(\n        .2*(5.*sin((fract(iTime/6.)+10.)*fragCoord.y)+1.),\n        .2*(5.*cos((fract(iTime/6.)+10.)*fragCoord.x)+1.), \n        1.); \n    \n   \tfinalCol = mix(screenDoor, finalCol, .8\n                  );  \n    \n    // Output Final color to screen\n    fragColor = vec4(finalCol,1.0);\n}", "image_inputs": [{"id": "4df3zn", "previewfilepath": "/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dSfzy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dXBDB", "name": "Jumping ", "author": "MeHigh_", "description": "*boing boing*", "tags": ["raymarch"], "likes": 1, "viewed": 61, "date": "1588943023", "time_retrieved": "2024-06-20T20:06:20.359306", "image_code": "float smin(float a, float b, float k) {\n\tfloat h = max(k - abs(a - b), 0.0);\n    \n    return min(a, b) - h * h /(k * 4.); \n}\n\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n    \n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat sdEllipsoid(vec3 p, vec3 rad) {\n\tfloat k1 = length(p/rad);\n    float k2 = length(p/(rad * rad));\n    \n    return k1 * (k1 - 1.) / k2;\n}\n\nfloat sdMain(vec3 p) {\n\tfloat t = fract(iTime * .75);\n    float y  = 4. * t * (1. - t);\n        \n    vec3 v = vec3(0., y, 0.);\n    \n    float sy = 0.5 + 0.5 * y;\n\tfloat sz = 1./ sy;\n    \n    //box shape\n    vec3 rad = vec3(.1, .2 * sy, .1 * sz);\n    vec3 pos = p - v;\n    float d = sdBox(pos, rad);\n    \n    //sphere shape\n\tvec3 pos1 = pos - vec3(0., -.2, 0.);\n\tvec3 rad1 = vec3(0.2, 0.2 * sy, 0.2 * sz);\n    float d1 = sdEllipsoid(pos1, rad1);\n    \n    d = smin(d, d1, .05);\n    return d;\n}\n\nfloat map (vec3 p) {\n\tfloat d = sdMain(p);\n    \n\tfloat d1 = (p.y) - (-0.25);    \n    \n    return min(d, d1);\n}\n\nvec3 getNormal(in vec3 p) {\n\tvec2 e = vec2(0.001, 0.);   \n    return normalize( vec3( map(p + e.xyy) - map(p - e.xyy),\n                           \tmap(p + e.yxy) - map(p - e.yxy),\n                           \tmap(p + e.yyx) - map(p - e.yyx) ) );\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n\tfloat t = 0.;\n    for(int i = 0; i < 100; ++i) {\n        vec3 p = ro + t * rd;\n        float h = map(p);\n        if(h < .001)\n            break;\n        t += h;\n        if(t > 20.)\n            break;\n    }\n    if(t > 20.) \n        t = -1.0;\n    return t;\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float tmin, float tmax) {\n\tfloat res = 1.;\n    float t = tmin;\n    float ph = 1e20;\n    \n    for(int i = 0; i < 25; ++i) {\n\t\tfloat h = map(ro + t * rd);\n        \n        float y = h * h / (2. * ph);\n        float d = sqrt(h * h - y * y);\n        res = min(res, 10. * d / max(0., t - y));\n        \n        ph = h;\n        t += h;\n    \tif(res < .0001 || t > tmax) \n            break;\n    }\n    return clamp(res, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.);\n\n    vec2 uv = (2. * (fragCoord) - iResolution.xy)/iResolution.y;\n\n    float a = 10.0 * iMouse.x / iResolution.x;\n\n    float howFar = 1.25;\n    vec3 ro = vec3(howFar * sin(a), 0.45, howFar * cos(a));\n\n    vec3 lookAt = vec3(0., 0.45, 0.);\n    vec3 f = normalize(lookAt - ro);\n    vec3 u = normalize(cross(f, vec3(0., 1., 0.)));\n    vec3 r = normalize(cross(u, f));\n    float zoom = 1.5;\n\n    vec3 rd = normalize(uv.x * u + uv.y * r + zoom * f);\n\n    col = vec3(0.4, 0.75, 1.) - rd.y * .7;\n    col = mix(col, vec3(0.7, 0.75, 0.8), exp(-10. * rd.y));\n\n\n    float t = rayMarch(ro, rd);\n\n    if( t > 0.) {\n        vec3 p = ro + t * rd;\n        vec3 norm = getNormal(p);\n\n        vec3 mat = vec3(0.18);\n        vec3 sunDir = normalize(vec3(0.8, 0.5, 0.2));        \n\n        float sunDif \t= clamp(dot(norm, sunDir), 0., 1.) \n            * softShadow(p, sunDir, .001, 4.);\n        float sunShadow = step(rayMarch(p + norm*0.001, sunDir), 0.0); \n        float skyDif \t= clamp(0.5 + 0.5 * dot(norm, vec3(0., 1., 0.)), 0., 1.);   \n        float bounceDif = clamp(0.5 + 0.5 * dot(norm, vec3(0., -1., 0.)), 0., 1.);   \n\n        col  = mat * vec3(7.0, 5.0, 4.0) * sunDif * sunShadow;\n        col += mat * vec3(0.5, 0.8, 0.9) * skyDif;\n        col += mat * vec3(0.7, 0.3, 0.2) * bounceDif;\n\n    }\n    col = pow(col, vec3(0.4545));\n    //col /= float(AA * AA);\n\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dXBDB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dXBRr", "name": "CIS461: Noise and UV Mapping", "author": "raykim1996", "description": "Noise and UV Mapping practice", "tags": ["cis461"], "likes": 2, "viewed": 88, "date": "1588866480", "time_retrieved": "2024-06-20T20:06:22.103504", "image_code": "const float FOVY = 3.14159 * 0.25;\nconst int RAY_STEPS = 256;\nconst float PI = 3.14159;\nconst float TWO_PI = 3.14159 * 2.0;\nconst vec3 matteWhite = vec3(0.85, 0.81, 0.78);\nconst vec3 matteRed = vec3(0.63, 0.065, 0.05);\nconst vec3 matteGreen = vec3(0.14, 0.45, 0.091);\nvec3 center = vec3(-5.0, 2.0, -1.0);\nconst vec3 lightPos = vec3(-1.0, 6.5, -15);\n\n\n//Intersection\nstruct Intersection\n{\n    float t;\n    vec3 color;\n    vec3 p;\n    int object; // unique ID for every object\n};    \n\n// Box with side lengths b\nfloat cube(vec3 p, vec3 b)\n{\n  return length(max(abs(p) - b, 0.0));\n}\n\n// SquarePlane SDF\nfloat plane(vec3 p, vec4 n)\n{\n    n = normalize(n);\n    return dot(p, n.xyz) + n.w;\n}\n\n// Sphere with radius r at center c\nfloat sphere(vec3 p, float r, vec3 c)\n{\n    return distance(p, c) - r;\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d)\n{\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\n//Worley===============================================\n// noise basis function\nvec2 noiseBasis(vec2 p) {\n    return fract(sin(vec2(dot(p,vec2(127.1, 161.979)),\n                          dot(p, vec2(469.73, 837.43))))\n                 *28347.4939);\n}\n\n// worleyNoise function\nfloat worleyNoise(vec2 uv) {\n    uv *= 0.1; //Now the space is 10x10 instead of 1x1. Change this to any number you want.\n    vec2 uvInt = floor(uv);\n    vec2 uvFract = fract(uv);\n    float minDist = 1.0; //Minimum distance initialized to max.\n    for(int y = -1; y <= 1; ++y) {\n        for(int x = -1; x <= 1; ++x) {\n            vec2 neighbor = vec2(float(x), float(y)); //Direction in which neighbor cell lies\n            vec2 point = noiseBasis(uvInt + neighbor); //Get the Voronoi centerpoint for the neighboring cell\n            \n            point = 0.5 + 0.5 * sin(iTime + 6.2831 * point); // 0 to 1 range\n\n            vec2 diff = neighbor + point - uvFract; //Distance between fragment coord and neighborâs Voronoi point\n            float dist = length(diff);\n            minDist = min(minDist, dist);\n        }\n    }\n    return minDist;\n}\n\n//FBM===============================================\n//sphere 2d mapper\nvec2 sphereMapper(vec3 p)\n{\n    float phi = atan(p.z, p.x);\n    if (phi < 0.0) {\n        phi += TWO_PI;\n    }\n    float theta = acos(p.y);\n    \n    float u = 1.0 - (phi / TWO_PI);\n    float v = 1.0 - (theta / PI);\n\n    return (vec2(u, v) + 0.1 * iTime) / 0.1; // 0 to 1 range\n}\n\n//noise basis function\nfloat noiseFBM2D(vec2 n)\n{\n    return (fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453));\n}\n\n//interpNoise2D\nfloat interpNoise2D(float x, float y)\n{\n    float intX = floor(x);\n    float fractX = fract(x);\n    float intY = floor(y);\n    float fractY = fract(y);\n\n    float v1 = noiseFBM2D(vec2(intX, intY));\n    float v2 = noiseFBM2D(vec2(intX + 1.0, intY));\n    float v3 = noiseFBM2D(vec2(intX, intY + 1.0));\n    float v4 = noiseFBM2D(vec2(intX + 1.0, intY + 1.0));\n\n    float i1 = mix(v1, v2, fractX);\n    float i2 = mix(v3, v4, fractX);\n    return mix(i1, i2, fractY);\n}\n\n//fbm function\nfloat fbm(float x, float y)\n{\n    float total = 0.0;\n    float persistence = 0.5;\n    float octaves = 4.0;\n\n    for(float i = 1.0; i <= octaves; i++) {\n        float freq = pow(2.0, i);\n        float amp = pow(persistence, i);\n\n        total += interpNoise2D(x * freq, y * freq) * amp;\n    }\n    return total;\n}\n\n//Perlin===============================================\nvec3 random3(vec3 p) {\n    return fract(sin(vec3(dot(p,vec3(127.1, 315.6, 382.919)),\n                          dot(p,vec3(739.5, 283.3, 732.14)),\n                          dot(p, vec3(838.69, 283.2,109.21))))\n                 *74738.3207);\n}\n\nfloat surflet(vec3 p, vec3 gridPoint) {\n    // Compute the distance between p and the grid point along each axis, and warp it with a\n    // quintic function so we can smooth our cells\n    vec3 t2 = abs(p - gridPoint);\n    vec3 t = vec3(1.0) - 6.0 * pow(t2, vec3(5.0)) + 15.0 * pow(t2, vec3(4.0)) - 10.0 * pow(t2, vec3(3.0));\n    // Get the random vector for the grid point (assume we wrote a function random2\n    // that returns a vec2 in the range [0, 1])\n    vec3 gradient = random3(gridPoint) * 2. - vec3(1., 1., 1.);\n    // Get the vector from the grid point to P\n    vec3 diff = p - gridPoint;\n    // Get the value of our height field by dotting grid->P with our gradient\n    float height = dot(diff, gradient);\n    // Scale our height field (i.e. reduce it) by our polynomial falloff function\n    return height * t.x * t.y * t.z;\n}\n\nfloat perlinNoise3D(vec3 p) {\n    float surfletSum = 0.0;\n    // Iterate over the four integer corners surrounding uv\n    p = (p + (iTime + 721.22913)) * 0.5; // 0 to 1 range\n    for(int dx = 0; dx <= 1; ++dx) {\n        for(int dy = 0; dy <= 1; ++dy) {\n            for(int dz = 0; dz <= 1; ++dz) {\n                surfletSum += surflet(p, floor(p) + vec3(dx, dy, dz));\n            }\n        }\n    }\n    return surfletSum;\n}\n\n\n#define BACK_WALL 0\n#define LEFT_WALL 1\n#define RIGHT_WALL 2\n#define FLOOR 3\n#define SPHERE1 4\n#define SHORT_CUBE 5\n#define BIG_CUBE 6\n#define BACK_WALL_SDF plane(pos, vec4(0.0, 0.0, -1.0, 10.0))\n#define LEFT_WALL_SDF plane(pos, vec4(1.0, 0.0, 0.0, 5.0))\n#define RIGHT_WALL_SDF plane(pos, vec4(-1.0, 0.0, 0.0, 5.0))\n#define CEILING_SDF plane(pos, vec4(0.0, -1.0, 0.0, 7.5))\n#define FLOOR_SDF plane(pos, vec4(0.0, 1.0, 0.0, 4.0))\n#define SPHERE1_SDF sphere(rotateY(pos, 15.0 * 3.14159 / 180.0), 3.5, vec3(-5.0, 2.0, -1.0))\n#define SHORT_CUBE_SDF cube(rotateY(pos + vec3(-2, 1.5, -0.75), -17.5 * 3.14159 / 180.0), vec3(2.2, 3, 2.2))\n\nvec3 rotateY(vec3 p, float a)\n{\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);   \n}\n\n// function to create whole scene\nvoid sceneMap3D(vec3 pos, out float t, out int obj)\n{\n    t = BACK_WALL_SDF;\n    obj = BACK_WALL;\n    \n    float t2;\n    if ((t2 = FLOOR_SDF) < t) {\n        t = t2;\n        obj = FLOOR;\n    }\n    if ((t2 = SPHERE1_SDF) < t) {\n        t = t2;\n        obj = SPHERE1;\n    }\n    if ((t2 = SHORT_CUBE_SDF) < t) {\n        t = t2;\n        obj = SHORT_CUBE;\n    }\n}\n\nfloat sceneMap3D(vec3 pos)\n{\n    float t = BACK_WALL_SDF;\n    \n    float t2;\n    if ((t2 = FLOOR_SDF) < t) {\n        t = t2;\n    }\n    if ((t2 = SPHERE1_SDF) < t) {\n        t = t2;\n    }\n    if ((t2 = SHORT_CUBE_SDF) < t) {\n        t = t2;\n    }\n    return t;\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj)\n{\n    t = 0.001;\n    for (int i = 0; i < RAY_STEPS; ++i) {\n        vec3 pos = origin + t * dir;\n        float m;\n        sceneMap3D(pos, m, hitObj);\n        if (m < 0.001) {\n            return;\n        }\n        t += m;\n    }\n    t = -1.0;\n    hitObj = -1;\n}\n\nvec3 computeMaterial(int hitObj, vec3 p, vec3 n, vec3 lightVec, vec3 view)\n{\n    float lambert = dot(lightVec, n);\n    switch(hitObj) {\n        case BACK_WALL:\n        return lambert * palette(worleyNoise(p.xy), vec3(0.8,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,0.7,0.4),vec3(0.0,0.15,0.20));\n        break;\n        case FLOOR:\n        return lambert * palette(worleyNoise(p.xz), vec3(0.8,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,0.7,0.4),vec3(0.0,0.15,0.20));\n        break;\n        case SPHERE1:\n        return lambert * palette(fbm(sphereMapper(normalize(p-center)).x, sphereMapper(normalize(p-center)).y), vec3(0.1,0.5,0.5), vec3(0.5), vec3(1.0), vec3(0.00, 0.10, 0.20));\n        break;\n        case SHORT_CUBE:\n        return lambert * palette(perlinNoise3D(p), vec3(0.5,0.8,0.8),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.3,0.20,0.20));\n        break;\n        case -1:\n        return vec3(0, 0, 0) * lambert;\n        break;\n    }\n    return vec3(0, 0, 0) * lambert;\n}\n\nvec3 computeNormal(vec3 pos)\n{\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize(vec3(sceneMap3D(pos + epsilon.yxx) - sceneMap3D(pos - epsilon.yxx),\n                         sceneMap3D(pos + epsilon.xyx) - sceneMap3D(pos - epsilon.xyx),\n                         sceneMap3D(pos + epsilon.xxy) - sceneMap3D(pos - epsilon.xxy)));\n}\n\nIntersection sdf3D(vec3 dir, vec3 eye)\n{\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj);\n    \n    vec3 isect = eye + (t * dir);\n    \n    vec3 nor = computeNormal(isect);\n    vec3 lightDir = normalize(lightPos - isect);\n    vec3 surfaceColor = computeMaterial(hitObj, isect, nor, lightDir, normalize(eye - isect));\n    \n    return Intersection(t, surfaceColor, isect, hitObj);\n}\n\n// Returns direction of ray\nvec3 rayCast(vec3 eye, vec3 ref, vec2 ndc)\n{\n    vec3 F = ref - eye;\n    vec3 R = normalize(cross(vec3(0, 1, 0), F));\n    vec3 U = normalize(cross(R, -F));\n    \n    vec3 V = U * length(F) * tan(FOVY * 0.5);\n    vec3 H = R * length(F) * tan(FOVY * 0.5) * float(iResolution.x) / iResolution.y;\n    \n    vec3 p = ref + ndc.x * H + ndc.y * V;\n    \n    return normalize(p - eye);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // Convert range to [-1, 1]\n    uv = uv * 2.0 - vec2(1.0, 1.0);\n    \n    vec3 eye = vec3(7, 5.5, -16);\n    vec3 ref = vec3(-2, 1.5, 0);\n    \n    vec3 rayDir = rayCast(eye, ref, uv);\n    \n    Intersection isect = sdf3D(rayDir, eye);\n    \n    fragColor = vec4(isect.color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dXBRr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dXBWf", "name": "SDF Material ID learning.", "author": "snolot", "description": "Try to understand how to retain material when merging sdf.", "tags": ["sdf", "multimaterial"], "likes": 4, "viewed": 103, "date": "1589148215", "time_retrieved": "2024-06-20T20:06:22.867185", "image_code": "\nvec2 z,v,e=vec2(0.01,0);\nfloat t,tt;vec3 np,bp,no,po,ld,al,g; //global variables\n\n\nmat2 r2(float r){ return mat2(cos(r),sin(r),-sin(r),cos(r)); }\n\n// SDF taken from evvvvil thanx to him learn a lot from his code ;)\nfloat cy(vec3 p,vec3 r){ return max(abs(length(p.xz)-r.x)-r.y,abs(p.y)-r.z/2.); }\nvec2 fb( vec3 p,float s,float m) \n{\n  for(int i=0;i<4;i++){\n    p=abs(p);\n    p.xy*=r2(.48);\n    p.yz*=r2(s*sin(p.z*.5)*.3);\n  }\n\n  vec2 h,t=vec2(cy(p,vec3(2,.3,.4)),m);//Make thin hollow tube \n  h=vec2(cy(p,vec3(2,.1,.6)),2.5); //Make white hollow tube\n  t=t.x<h.x?t:h; //(blend geometry together while retaining material ID)\n  h=vec2(cy(p,vec3(2.,.4,.2)),3.5); //Make black hollow tube\n  t=t.x<h.x?t:h; //(blend geometry together while retaining material ID)\n  return t;\n}\n\nvec2 road( vec3 p, float r){\n  vec2 h,t=vec2(cy(p,vec3(r,.5,1)),5.);\n  h=vec2(cy(p,vec3(r,.5,5)),3);\n  h.x=abs(h.x)-.1;\n  h.x=max(h.x,abs(p.y)-.6);\n  t=t.x<h.x?t:h;\n  t.x=max(t.x,-(abs(p.z)-.8));\n  h=vec2(cy(p,vec3(r,1.2,.5)),2.5); \n  //g+=0.1/(2.01+h.x*h.x*100.);//Glow trick by Balkhan, which I tend to rinse and use as a party trick.\n  t=t.x<h.x?t:h;\n  t.x=max(t.x,-(abs(p.z)-1.8));\n  h=vec2(cy(p,vec3(r,0.5,.125)),1.5);\n  //g+=0.1/(2.01+h.x*h.x*100.);\n  h.x=abs(h.x)-.005;\n  //h.x=max(h.x,abs(p.y)-.2);\n  \n  t=t.x<h.x?t:h;\n  //t.x=max(t.x,-(abs(p.z)-.8));\n    \n  return t;\n}\n\n\nvec2 map( vec3 p ){\n\tvec3 pp = p, pp2 = p;\n\n\tpp.xy *= r2(tt);\n\tpp.xz *= r2(-tt*3.);\n\tpp2.xy *= r2(-tt);\n\tpp2.xz *= r2(tt*2.);\n\n\tvec2 h,t=road(pp2, 5.);\n  \t\n  \th=road(pp, 8.);\n  \tt=t.x<h.x?t:h;\n\n  \th=road(pp2, 11.);\n  \tt=t.x<h.x?t:h;\n\n  \th=road(pp, 14.);\n  \tt=t.x<h.x?t:h;\n\n  \treturn t;\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor ){\n\tfloat ao = 0.0;\n\n\tvec3 v = normalize(vec3(0.7,0.5,0.2));\n\tfor( int i=0; i<12; i++ )\n\t{\n\t\tfloat h = abs(sin(float(i)));\n\t\tvec3 kv = v + 2.0*nor*max(0.0,-dot(nor,v));\n\t\tao += clamp( map(pos+nor*0.01+kv*h*0.2).x*3.0, 0.0, 1.0 );\n\t\tv = v.yzx; if( (i&2)==2) v.yz *= -1.0;\n\t}\n\tao /= 12.0;\n\tao = ao + 2.0*ao*ao;\n\treturn clamp( ao*2.5, 0.0, 1.0 );\n}\n\nvec2 march( in vec3 ro, in vec3 rd, in float _max, in int iter ){ //main trace  / raycast / raymarching loop function \n\tvec2 h,t= vec2(.1); //0.1 is near plane\n  \t\n  \tfor(int i=0;i<iter;i++){ //march for iter amount of iterations\n    \th=map(ro+rd*t.x); \t//get distance to geom\n    \tif(h.x<.00001||t.x>_max) break; //conditional break we hit something or gone too far\n    \tt.x+=h.x;t.y=h.y; //huge step forward and remember material id\n  \t}\n  \n  \tif(t.x>_max) \n  \t\tt.y=0.;//if we hit far plane return material id = 0, we will use it later to check if we hit something\n  \n  \treturn t;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1); //get UVs\n  \ttt=mod(iTime,62.9); //modulo time to avoid glitchy artifact and also nicely reset camera / scene\n  \tvec3 lp=vec3(0., 5. , cos(tt)*2.);//vec3(3.+cos(tt*.2)*10.,6.+sin(tt*.4)*5.,-6); //light position\n  \n  \tvec3 ro= lp*mix(vec3(1),vec3(-1,3.2,1),ceil(cos(tt))), // ray origin = camera position\n  \tcw=normalize(vec3(sin(tt*.4)*2.,cos(tt*.2)*10.,0)-ro), //camera forward vector\n  \tcu=normalize(cross(cw,vec3(0,1,0))), //camera left vector ?\n  \tcv=normalize(cross(cu,cw)), //camera up vector ?\n  \trd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),co,fo; //ray direction */\n  \t\n  \tlp+=vec3(0,5.+sin(tt)*.5,5); // light position offset animation\n  \tco=vec3(.09)-length(uv*.8)*.107, fo=vec3(.1); // background with pseudo clouds made from noise\n  \tz=march(ro,rd,50.,128);\n  \tt=z.x; // let's trace and get result\n  \t\n  \tif(z.y>0.){ // we hit something \n    \tpo=ro+rd*t; // get position where we hit\n    \tld=normalize(lp-po); //get light direction from light pos\n    \tno=normalize(map(po).x-vec3(map(po-e.xyy).x,map(po-e.yxy).x,map(po-e.yyx).x));\n\n        if(z.y==1.5) al=vec3(1.);\n    \tif(z.y==2.5) al=vec3(1., .05, 0.);\n    \tif(z.y==3.5) al=vec3(.6);\n    \tif(z.y==5.) al=vec3(.7, .5, 0);\n    \tif(z.y>5.) al=vec3(.1, .4, .7);\n    \tfloat dif=max(0.,dot(no,ld)), // diffuse lighting\n   \t\tfr=pow(1.-abs(dot(rd,no)),4.);\n    \t//spo=exp2(15.).r, // Gloss specular map made from noise\n\t    float sp=pow(max(dot(reflect(-ld,no),-rd),0.),20.),\n\t    ldd=length(lp-po), attn=1.0-pow(min(1.0,ldd/25.),4.0); \n\t    float ao = calcAO(po, no);\n    \tco = al * (fr+ attn) * dif * vec3(ao) ;\n    \t//co=dif*al*fr*attn;\n    }\n\n    fragColor = vec4( pow(co+g*.2,vec3(.45)),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dXBWf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3dXfRX", "name": "2D FBM example", "author": "Nrx", "description": "Basic 2D FBM example in reply to [url=https://www.facebook.com/groups/IndieGameDevs/permalink/10156876829611573/]this Facebook post[/url].\nUse the mouse to zoom & pan.", "tags": ["fbm"], "likes": 2, "viewed": 291, "date": "1588690590", "time_retrieved": "2024-06-20T20:06:22.867185", "image_code": "// This is a very basic 2D FBM example in reply to this Facebook post:\n// https://www.facebook.com/groups/IndieGameDevs/permalink/10156876829611573/\n// Comment out line 26 to get a triangular look.\n\n#define SPEED\t\t0.2\n#define SCALE\t\t3.0\n#define WIDTH\t\t0.005\n#define DX\t\t\t0.001\n#define STAR_SIZE\t0.005\n\n// PRNG (1D)\nfloat rand (in float seed) {\n\treturn fract (sin (seed * 12.9898) * 137.5453);\n}\n\n// PRNG (2D)\nfloat rand (in vec2 seed) {\n\tseed = fract (seed * vec2 (5.3983, 5.4427));\n\tseed += dot (seed.yx, seed.xy + vec2 (21.5351, 14.3137));\n\treturn fract (seed.x * seed.y * 95.4337);\n}\n\n// Noise\nfloat noise (in float p) {\n\tfloat f = fract (p);\n//\tf = f * f * (3.0 - 2.0 * f); // Comment this to get a triangular look.\n\tp = floor (p);\n\treturn mix (rand (p), rand (p + 1.0), f);\n}\n\n// FBM\nfloat fbm (in float p) {\n\tp *= SCALE;\n\treturn (noise (p) + noise (p * 2.0) / 2.0 + noise (p * 4.0) / 4.0) / (1.0 + 1.0 / 2.0 + 1.0 / 4.0);\n}\n\n// Main\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n\t// Define the local coordinates\n\tvec2 uv = fragCoord / iResolution.y;\n\tuv.x -= iMouse.x / iResolution.y;\n\tuv *= 1.0 + iMouse.y / iResolution.y;\n\tuv.x += iTime * SPEED;\n\n\t// Call the FBM function to define the profile of the mountain\n\tfloat y = fbm (uv.x);\n\n\t// Compute the distance of the fragment to the mountain, to draw a nice line\n#ifdef DX\n\tfloat dy = (fbm (uv.x + DX) - fbm (uv.x - DX)) / (2.0 * DX);\n#else\n\tfloat dy = dFdx (y) / dFdx (uv.x);\n#endif\n\tfloat dist = abs (uv.y - y) / sqrt (1.0 + dy * dy);\n\tfloat mountain = smoothstep (WIDTH * 1.1, WIDTH, dist);\n\n\t// Add some (blocky) stars above the mountain\n\tfloat star = step (0.995, rand (floor (uv / STAR_SIZE)));\n\tstar *= step (y, uv.y) * step (WIDTH, dist);\n\n\t// Final color\n\tfragColor = vec4 (mountain + star, star, star, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3dXfRX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3l23R3", "name": "basket ball by sid", "author": "sidchou", "description": "basket ball by sid\n\nIG: @sid_100_days", "tags": ["basketball"], "likes": 0, "viewed": 50, "date": "1590850037", "time_retrieved": "2024-06-20T20:06:23.546049", "image_code": "float hexDist(vec2 p)\n{\n\tp = abs(p);\n    float c = dot(p,normalize(vec2 (1.,pow(3.,.5))));\n    c = max (c,p.x);\n    return c;\n}\n\nvec4 hexCo(vec2 uv){\n   \n \tvec2 r = vec2(1,pow(3.,.5));\n    vec2 h = r*.5;\n    \n    uv -= r.yx*iTime*2.;\n \n    vec2 a = mod(uv,r)-h;\n\tvec2 b = mod(uv-h,r)-h;\n    \n\tvec2 gv;\n    if(length(a)<length(b))\n    \tgv = a;\n    else\n        gv = b;\n    \n    // distance\n    float cent = hexDist(gv);\n    float edge = .5-hexDist(gv);\n    float th = atan(gv.x,gv.y);\n\n    //return vec4(gv.x,gv.y,uv.x-gv.x,uv.y-gv.y);\n    return vec4(edge,th,uv.x-gv.x,uv.y-gv.y);\n\n}\n\n\nfloat Bend(vec2 uv, float w,float x,float curve){\n    uv.y+=x*.5;\n    uv.x+=uv.y*uv.y*curve;\n    uv.x+=x;\n    //float w = .01;\n    float c=smoothstep(-w,.01-w,uv.x)*smoothstep(w+.01,w,uv.x);\n      \n    return c;\n}\nfloat spinTime(float t,float o){\nreturn t = (step(0.,sin(t+o))*2.-1.)*sin(t+.5*3.14+o); //1 => -1\n    \n}\n\nvec4 Ball(vec2 uv,vec2 p,float r){\n    \n    vec4 c = vec4(1.,.4,.1,1.);\n    \n    vec2 _p = p-uv;\n    float d = length(_p);\n    float cir= 1.- smoothstep(r-.1,r-.05,d);\n    //c = mix(vec4(0.),c,cir);\n    /*\n    vec4 c2 = vec4(1.,.7,.3,1.);\n    float highlight = smoothstep(.4, .1, length(_p+vec2(-.2,.2)));\n    c = mix(c,c2,highlight);\n    c2 = vec4(.6,.1,.01,1.);\n\t float shadow = smoothstep(.3,.7,  length(_p+vec2(-.2,.2)));\n    c = mix(c,c2,shadow);\n\n    c = mix(vec4(0.),c,cir);\n\n    \n\tfloat w = .01;\n    float t = spinTime(iTime*.4,0.)*(r+w);\n    \n    float b = Bend((_p),w,t,-t*.2);\n    t = spinTime((iTime)*.4,-.4)*(r+w);\n    b += Bend((_p),w,t,t+1.);\n\tt = spinTime((iTime)*.4,.4)*(r+w);\n    b += Bend((_p),w,t,t-1.);\n\tt = spinTime((iTime)*.4,-1.57)*(r+w);\n    b += Bend((_p),w,t,t*.2);\n    \n    t = sin(iTime*.4+2.)*.2;\n    vec2 yp = (vec2(_p).yx-vec2((_p).x*.3,0.));\n    b += Bend(yp,w,0.,-.15);\n    \n    b = min(b,1.);\n    c = mix(c,vec4(0.3,.01,.002,1.),b*cir);\n    */\n    //_p.x+=iTime; //cool shit\n    \n    vec4 tex=hexCo((_p+vec2((_p).y*.3,0.))*100.*cos(1.-d));\n    tex+=.3;\n    c*=tex.x;\n    \n    \n     vec4 c2 = vec4(1.,.7,.3,1.);\n     float highlight = smoothstep(.5, .1, length(_p+vec2(-.25,.25)))*.7;\n    c = mix(c,c2,highlight);\n    c2 = vec4(.4,.1,.01,1.);\n\t  float shadow = smoothstep(.4,.7,  length(_p+vec2(-.2,.2)))*.8;\n    c = mix(c,c2,shadow);\n\n    \tfloat w = .01;\n    float t = spinTime(iTime*.4,0.)*(r+w);\n    \n    float b = Bend((_p),w,t,-t*.2);\n    t = spinTime((iTime)*.4,-.4)*(r+w);\n    b += Bend((_p),w,t,t+1.);\n\tt = spinTime((iTime)*.4,.4)*(r+w);\n    b += Bend((_p),w,t,t-1.);\n\tt = spinTime((iTime)*.4,-1.57)*(r+w);\n    b += Bend((_p),w,t,t*.2);\n    \n    t = sin(iTime*.4+2.)*.2;\n    vec2 yp = (vec2(_p).yx-vec2((_p).x*.3,0.));\n    b += Bend(yp,w,0.,-.15);\n    \n    b = min(b,1.);\n    c = mix(c,vec4(0.2,.01,.002,1.),b);\n    \n    \n    c = mix(vec4(0.),c,cir);\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=.5;\n    uv.x /= iResolution.y/iResolution.x;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n   \n    vec4 c = Ball(uv,vec2(0.,0.),.5);\n    vec4 col = c;\n\n\n    // Output to screen\n    fragColor = vec4(col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3l23R3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3lKSD3", "name": "Shader5_Dela Vega", "author": "zerotojiro", "description": "Clock", "tags": ["midterms"], "likes": 0, "viewed": 194, "date": "1588323614", "time_retrieved": "2024-06-20T20:06:23.546049", "image_code": "float circle(vec2 uv,float radius, float blur,  vec2 pos)\n{\n     \n    float d = distance(pos,uv);\n    float value = smoothstep(radius, radius + blur, d);\n    \n    return value; \n}\n\nfloat distLine(vec2 p, vec2 a, vec2 b){\n\tvec2 pa = p-a;\n    vec2 ba = b-a;\n    float t = clamp(dot(pa, ba)/dot(ba, ba),0., 1.);\n    return length(pa-ba*t);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b){\n\tfloat d = distLine(p,a,b);\n    float m = .9*smoothstep(.01, .00001, d);\n    \n    return m;\n}\n\nfloat rect (vec2 uv, vec2 pos, vec2 size)\n{\n\tfloat value = step(pos.x - size.x/2.,uv.x) - step(pos.x + size.x/2.,uv.x);\n    return value *= step(pos.y,uv.y) - step(pos.y + size.y,uv.y);\n}\n\nmat2 rotate2d(float angle)\n{\n    return mat2(cos(angle),-sin(angle), sin(angle), cos(angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tfloat ratio = iResolution.x/iResolution.y;\n    uv.x *= ratio;\n    \n    vec2 center = vec2(.5*ratio, .5);\n    \n    float border = circle(uv,.45, 0., center);\n    border -= circle(uv, .5, 0., center);\n    \n    float blank = circle(uv,.38, 0., center);\n    blank -= circle(uv, .45, 0., center);\n    \n    float middle = circle(uv,.02, 0., center);\n    \n    vec2 uvMin = uv;\n    vec2 uvHour = uv;\n    \n    uvMin -= center;\n    uvMin *= rotate2d((iTime)*1.2);\n    uvMin += center;\n    \n    uvHour -= center;\n    uvHour *= rotate2d((iTime)*.1);\n    uvHour += center;\n    \n    float minHand = rect(uvMin, center,vec2(.02,.4));\n    float hourHand = rect(uvHour, center,vec2(.02,.25));\n    \n    //lines\n    float l = line(uv, vec2(.5*ratio, 0.), vec2(.5*ratio, 1.));\n    l += line(uv, vec2(0.*ratio, .5), vec2(1.*ratio, .5));\n    l += line(uv, vec2(.35*ratio, 0.), vec2(.65*ratio, 1.));\n    l += line(uv, vec2(.05*ratio, 0.), vec2(.95*ratio, 1.));\n    l += line(uv, vec2(.05*ratio, 1.), vec2(.95*ratio, 0.));\n    l += line(uv, vec2(.35*ratio, 1.), vec2(.65*ratio, 0.));\n    \n    vec3 col = mix(vec3(1.), vec3(0.), l);\n    col = mix(vec3(1.), col, blank);\n    col = mix(col, vec3(0.), minHand);\n    col = mix(col, vec3(0.), hourHand);\n    col = mix(vec3(0.), col, middle);\n    col = mix(col, vec3(0.), border);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3lKSD3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3lKSDG", "name": "Cosmic horizon", "author": "z0rg", "description": "A small experiment for dnb visuals.", "tags": ["abstract", "liquid", "dnb"], "likes": 22, "viewed": 422, "date": "1589462531", "time_retrieved": "2024-06-20T20:06:24.315827", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nconst float PI = 3.14159265;\nmat2 r2d(float a){float sa = sin(a);float ca=cos(a);return mat2(ca,sa,-sa,ca);}\n\nfloat lenny(vec2 v)\n{\n  return abs(v.x)+abs(v.y);\n}\nfloat sat(float a)\n{\n  return clamp(a,0.,1.);\n}\nvec3 sat(vec3 v)\n{\n  return vec3(sat(v.x),sat(v.y), sat(v.z));\n}\nfloat _sub(float a, float b)\n{\n  return max(a,-b);\n}\nfloat _cir(vec2 uv, float sz)\n{\n  return length(uv)-sz;\n}\n\nfloat _loz(vec2 uv,float sz)\n{\n  return lenny(uv)-sz;\n}\n\nvec3 tunnel(vec2 uv,float sz)\n{\n  //uv += vec2(sin(length(uv)),cos(length(uv)))*.1;\n  float a = sz*atan(uv.y,uv.x)/PI;\n  float d = .021*iTime+.01/length(uv);\n  vec3 col = texture(iChannel0,vec2(d,a)).xxx;\n  return sat(1.-length(uv*.2))*col*sat(length(uv*20.))*mix(vec3(.28+abs(uv.x),.34,sat(.17+length(uv))),vec3(.8,.5,.7),length(uv)-.9);\n}\n\nvec3 rdrLand(vec2 uv)\n{\n  vec3 back;\n  vec3 col;\n  col += 2.*tunnel(uv,1.);\n // col += 1.5*tunnel(uv*.8*r2d(iTime*.2),.2);\n  col += tunnel(uv*5.2*r2d(iTime*.2),.2);\n\n  for (int i = 0;i<8;++i)\n  {\n    float fi= float(i);\n    float sz = 5./(fi+1.);\n    float szc = 7.*mod(sz+iTime*.1,1./9.);\n    float cut = _cir(uv, szc-szc/10.);\n    float ci = _cir(uv, szc);\n    float cir = 1.-sat(_sub(ci,cut)*20.);\n    col += vec3(.53,.94,.58)*(cir)*(sz-.1)*.1;\n  }\n\n  return back+col*.5;\n}\n\nvec3 rdrSqr(vec2 uv)\n{\n  uv = uv *r2d(PI/4.);\n  vec3 acc;\n  for (int i = 0; i < 16; i++)\n  {\n     vec2 suv = uv;\n     suv = suv*r2d(.8*smoothstep(0.,.9,mod(iTime+float(i)*.5,.9)));\n     vec3 col;\n\n     float an = iTime*.1+.15*float(i)+atan(uv.y, uv.x)/PI;\n     float sz = mod(iTime/(float(i+1)*.7),1.);\n     float sqr = _sub(_loz(suv, sz),_loz(suv,sz*.999));\n     col = vec3(1.,float(i)/10.,uv.y*.5+.2)*((1.-sat(sqr*200.))+.7*(1.-sat(sqr*15.)))*sat(float((mod(an,.05)-.015))*20.);\n     acc += col;\n  }\n    return acc;\n}\n\nvec3 rdrScn(vec2 uv)\n{\n  float maskLand = 1.-sat(_cir(uv,.5)*50.);\n\n  vec3 land = rdrLand(uv).zyx;\n  land += rdrSqr(uv)*sat(lenny(uv*2.))*.7;\n  return land;\n}\n\nvec3 rdr2(vec2 uv)\n{\n    vec2 ouv = uv;\n    ouv.y *= 1.+cos((ouv.x*PI));\n    vec3 col = rdrScn(ouv);\n  \tcol *= vec3(.7, .34, .89)*sat(1.-lenny(uv))*2.;\n    vec3 col2;\n    col2 += 2.*vec3(.7, .54, .89).zyx*sat(1.-lenny(uv*vec2(1., 8.)));\n    col2 += vec3(.7, .54, .89).zyx*sat(1.-lenny(uv*vec2(.5, 90.)));\n    col2 += .9*vec3(.7, .54, .89).zyx*sat(1.-lenny((uv*r2d(PI/4.)*vec2(.5, 10.))));\n    col2 += .5*vec3(.7, .54, .89).zyx*sat(1.-lenny((uv*r2d(PI/4.)*vec2(.5, 2.))));\n    col2 += .5*vec3(.7, .54, .89).zyx*sat(1.-lenny(((uv+vec2(-.2, -.5))*r2d(PI/4.)*vec2(.5, 90.))));\n    col2 += .5*vec3(.7, .54, .89).zyx*sat(1.-lenny(((uv+vec2(-.2, .3))*r2d(PI/4.)*vec2(.5, 5.))));\n    \n    vec3 halo = vec3(.6,.7,.9)*(1.-sat(_sub(_cir(uv, .65), _cir(uv, .6))*15.));\n    return col+col2*.5+halo*.4;\n}\n\nvec3 rdrPost(vec2 uv)\n{\n    vec2 dir = uv*.05;\n    float r = rdr2(uv+dir).x;\n    float g = rdr2(uv).y;\n    float b = rdr2(uv-dir).z;\n    return vec3(r,g,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / iResolution.xx;\n  uv -= vec2(.5)*iResolution.xy/iResolution.xx;\n  uv*= 1.5;\n  vec3 col = rdrPost(uv);\n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3lKSDG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3ltGD7", "name": "Lighting blob in 3d", "author": "yp3y5akh0v", "description": "Lighting blob in 3d", "tags": ["3d", "light"], "likes": 2, "viewed": 100, "date": "1588993295", "time_retrieved": "2024-06-20T20:06:24.315827", "image_code": "#define MAX_RAY_STEPS 100\n#define EPS 0.001\n#define t iTime\n\nstruct Light {\n    vec3 p;\n    float r;\n    vec3 c;\n} light;\n\nstruct RM {\n    float sdf;\n    float atm;\n};\n    \nfloat box(vec3 p, vec3 b)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat cylinder(vec3 p, float r) {\n    return length(p.xz) - r;\n}\n\nfloat plane(vec3 p, float h) {\n    return p.y - h;\n}\n\nfloat SceneSdf(vec3 p) {\n    float plane = plane(p, -5.0);\n    float dcBox1 = max(box(p - vec3(0., 1., 0.), vec3(1., 0.1, 1)), -cylinder(p, 0.5));\n    float dcBox2 = max(box(p - vec3(0., 0., 0.), vec3(1., 0.1, 1)), -cylinder(p, 0.5));\n    float d = min(dcBox1, dcBox2);\n    d = min(d, plane);\n    float dLight = length(light.p - p) - light.r;\n    d = min(d, dLight);\n    return d;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = SceneSdf(p);\n    vec2 e = vec2(0.001, 0.);\n    vec3 n = d - vec3(\n        SceneSdf(p - e.xyy),\n        SceneSdf(p - e.yxy),\n        SceneSdf(p - e.yyx)\n    );\n    \n    return normalize(n);\n}\n\nfloat WeightedLightBlob(Light light, float decay, vec3 pos) {\n    return light.r * decay / pow(length(pos - light.p), 2.);\n}\n\nRM RayMarching(vec3 ro, vec3 rd) {\n    float sdf = 0.;\n    float atm = 0.;\n    float decay = 1.;\n    vec3 pos = ro;\n    for(int i = 0; i < MAX_RAY_STEPS; i++) {        \n        float d = SceneSdf(pos);\n        atm += WeightedLightBlob(light, decay, pos);\n        if (abs(d) < EPS) {\n            break;\n        }\n        sdf += d;\n        pos += d * rd;\n        decay *= 0.98;\n    }\n    return RM(sdf, atm);\n}\n\nvec3 RenderSceneWithLight(Light light, vec3 ro, vec3 rd) {\n    RM rmMap = RayMarching(ro, rd);\n    vec3 p = ro + rmMap.sdf * rd;\n    vec3 n = GetNormal(p); \n    vec3 pToL = light.p - p;\n    vec3 pToLN = normalize(pToL);\n    float diffuse = max(dot(n, pToLN), 0.);\n\n    vec3 col = diffuse * vec3(1.) + rmMap.atm * light.c;\n    \n    RM rmShadow = RayMarching(p + n, pToLN);\n    if (rmShadow.sdf < length(pToL) - light.r) {\n        col *= 0.3;\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float dor = 2.5;\n    vec2 cs = vec2(0.5 + 1.5 * cos(0.5 * t), 0.5 + 1.5 * sin(0.5 * t));\n    vec3 ro = vec3(dor * cs.x - 2., 3. * cs.x, dor * cs.y - 2.);\n    vec3 lookAt = vec3(0.);\n    vec3 col = vec3(0.);\n    \n    vec3 oz = normalize(lookAt - ro);\n    vec3 ox = normalize(cross(vec3(0., 1., 0.), oz));\n    vec3 oy = normalize(cross(oz, ox));\n    \n    vec3 rd = uv.x * ox + uv.y * oy + oz;\n    \n    light = Light(vec3(0., cs.x, 0.), .01, vec3(1, 0.871, 0.231));\n    col = RenderSceneWithLight(light, ro, rd);\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3ltGD7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3lyXWV", "name": "Shader4_DelaVega", "author": "zerotojiro", "description": "Waterwheel in the night", "tags": ["midterms"], "likes": 1, "viewed": 199, "date": "1588323611", "time_retrieved": "2024-06-20T20:06:24.315827", "image_code": "vec3 waves(vec2 uv, vec3 color)\n{\n    // To create the waves\n\tfloat wave_width;\n\tuv  = -.2 + 5.0 * uv;\n\tuv.y += 0.0;\n\tfor(float i = .0; i < 15.; i++) {\n\t\t\n\t\tuv.y += (.07 * sin(uv.x + i/2.0 + iTime ));\n\t\twave_width = abs(1. / (150.0 * uv.y));\n\t\tcolor += vec3(wave_width * 1.9, wave_width, wave_width * 1.5);\n\t}\n    \n    return color;\n}\n\nfloat circle(vec2 uv,float radius, float blur,  vec2 pos)\n{\n     \n    float d = distance(pos,uv);\n    float value = smoothstep(radius, radius + blur, d);\n    \n    return value; \n}\n\nfloat rect (vec2 uv, vec2 pos, vec2 size)\n{\n\tfloat value = step(pos.x - size.x/2.,uv.x) - step(pos.x + size.x/2.,uv.x);\n    return value *= step(pos.y - size.y/2.,uv.y) - step(pos.y + size.y/2.,uv.y);\n}\n\nmat2 rotate2d(float angle)\n{\n    return mat2(cos(angle),-sin(angle), sin(angle), cos(angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n\n    uv.x *= ratio;\n    \n    vec2 moonPos = vec2(.2*ratio, .7);\n    vec2 landPos = vec2(.5*ratio, .1);\n    vec2 wheelPos = vec2(.7*ratio, .35);\n    vec2 supportPos = vec2(.7*ratio, .25);\n        \n    float moon = circle(uv, .15, .05, moonPos);\n   \tfloat land = rect(uv, landPos, vec2(2., .1));\n    float support = rect(uv, supportPos, vec2(.1, .3));\n    \n    vec3 water = waves(uv, vec3(-.05));\n    \n    //wheel\n    uv-=wheelPos;\n    uv*= rotate2d((iTime)*2.);\n    uv+=wheelPos;\n    \n    float wheel = circle(uv,.3, 0., wheelPos);\n    wheel -= circle(uv, .35, 0., wheelPos);\n    \n    //woodenbars\n    float bar1 = rect(uv, wheelPos, vec2(.05, .8));\n    float bar2 = rect(uv, wheelPos, vec2(.8, .05));\n    float bolt = rect(uv, wheelPos, vec2(.05, .05));\n    \n\tvec3 col = mix(vec3(.0627, .0823, .2), vec3(.4), support);\n    col = mix(col, vec3(.4196, .1903, 0.), land);\n    col = mix(col, vec3(.2784, .1882, .1176), wheel);\n    col = mix(col, vec3(.2784, .1882, .1176), bar1);\n    col = mix(col, vec3(.2784, .1882, .1176), bar2);\n    col = mix(col, vec3(.1), bolt);\n    col = mix(col, vec3(0., 0., 1.), water);\n    col = mix(vec3(.9764, 1., .7607), col, moon);\n\t\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3lyXWV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3s2BWG", "name": "Lightning Menger Sponge", "author": "TAKUSAKU", "description": "Lightning Menger Sponge  Fold", "tags": ["lightning", "fold", "mengersponge"], "likes": 8, "viewed": 134, "date": "1590726933", "time_retrieved": "2024-06-20T20:06:24.315827", "image_code": "#define time iTime\n\nconst float PI = 3.14159265;\n\n// noise background is baced on æææ°VIP:\n// https://www.shadertoy.com/view/4sVBDm\n// ---------------------------------------------------------------------\n\nconst float noiseIntensity = 2.8;\nconst float noiseDefinition = 0.6;\nconst vec2 glowPos = vec2(-2., 0.);\n\nfloat random(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(-0.950,-0.910))) * 43758.5453);\n}\n\nfloat noise( in vec2 p ){\n    p*=noiseIntensity;\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\tvec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( random( i + vec2(0.0,0.0) ), \n                     random( i + vec2(1.0,0.0) ), u.x),\n                mix( random( i + vec2(0.0,1.0) ), \n                     random( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat fbm( in vec2 uv ){\t\n\tuv *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    float f  = 0.5*noise( uv ); uv = m*uv;\n    f += 5.*noise( uv ); uv = m*uv;\n    f += 5.*noise( uv ); uv = m*uv;    \n\tf = 0.1 + .5*f;\n    return f;\n}\n\nvec3 bg(vec2 uv ){\n    float velocity = time * 0.5;\n    float intensity = sin(uv.x*noise(uv)*7.+velocity*3.)*noise(uv*10.)*1.0+.3;\n    uv.y -= 2.;\n    vec2 bp = uv+glowPos;\n    uv *= noiseDefinition;\n\n    //ripple\n    float rb = fbm(vec2(uv.x*.5-velocity*.03, uv.y))*.1;\n    uv += rb;\n\n    //coloring\n    float rz = fbm(uv*.9+vec2(velocity*.35, 0.0));\n    rz *= dot(bp*intensity,bp);\n\n    //bazooca line\n    rz *= sin(uv.x*0.1+velocity*0.8);\n    \n    //lightning\n    rz *= 5.*sin(uv.x*0.1+velocity*sin(time));\n    \n    vec3 bgColor = vec3(cos(time),0.45 * sin(time*0.2),sin(time*0.3));\n    vec3 col = bgColor/(.1-rz);\n    return sqrt(abs(col));\n}\n\n// IFS MengerSponge based on gam0022.net\n// https://gam0022.net/blog/2019/06/25/unity-raymarching/\n// ---------------------------------------------------------------------\n#define ITERATIONS 4\n\nvec3 _MengerOffset = vec3(1.000,0.072,0.414);\nfloat _MengerScale = 2.9;\nfloat _MengerFold = 3.;\n\n// IFS MengerSpongeãDistanceFunction\nfloat dMenger(vec3 z0, vec3 offset, float scale) {\n    vec4 z = vec4(z0, 1.0);\n    for (int n = 0; n < ITERATIONS; n++) {\n        z = abs(z);\n\n        if (z.x < z.y) z.xy = z.yx;\n        if (z.x < z.z) z.xz = z.zx;\n        if (z.y < z.z) z.yz = z.zy;\n\n        z *= scale;\n        z.xyz -= offset * (scale - 1.0);\n\n        if (z.z < -0.5 * offset.z * (scale - 1.0))\n            z.z += offset.z * (scale - 1.0);\n    }\n    return (length(max(abs(z.xyz) - vec3(1.0, 1.0, 1.0), 0.0)) - 0.05) / z.w;\n}\n\n// 2D rotate\nmat2 rotate(in float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\n// Deformation used folding\n// https://www.shadertoy.com/view/Mlf3Wj\nvec2 foldRotate(in vec2 p, in float s) {\n    float a = PI / s - atan(p.x, p.y);\n    float n = PI*2. / s;\n    a = floor(a / n) * n;\n    p *= rotate(a);\n    return p;\n}\n\n// Final DistanceFunction\nfloat map(vec3 pos) {\n    pos.xy = foldRotate(pos.xy, _MengerFold);\n    pos.yz = foldRotate(pos.yz, _MengerFold);\n    return dMenger(pos, _MengerOffset, _MengerScale);\n}\n\n// Normal\nvec3 getNormal(vec3 p){\n    const vec2 e = vec2(0.001, 0.0);\n\treturn normalize(vec3(\n\t\tmap(p + e.xyy) - map(p - e.xyy),\n\t\tmap(p + e.yxy) - map(p - e.yxy),\n\t\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n// ---------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;// background\n    \n    // camera\n    float pscale = 1.0 + 0.85*cos(time*0.5);\n    vec3 cPos = vec3(pscale*cos(time*0.5), 0.0, pscale*sin(time*0.5));\n    vec3 cDir = vec3(1.*sin(time*0.5+PI*1.5), 0.0, -1.*cos(time*0.5+PI*1.5));\n    vec3 cUp  = vec3(0.0, 1.0, 0.0);\n    vec3 cSide = cross(cDir, cUp);\n    float targetDepth = 1.0;\n     \n    // ray\n    vec3 rPos = cPos;// cPos = ray origin\n    vec3 rd = normalize(cSide * p.x + cUp * p.y + cDir * targetDepth);// ray direction\n    \n    // marching loop\n    float dist = 0.0;\n    float rLen = 0.0;\n    for(int i = 0; i < 42; i++){\n        dist = map(rPos);\n        rLen += dist;\n        rPos = cPos + rd * rLen;\n    }\n    \n    //color\n    vec3 color = vec3(0.0);\n    vec3 bgCol = bg(p)*(2.-abs(uv.y*2.));// background color\n    \n    // hit check\n    if(abs(dist) < 0.001){\n        vec3 normal = getNormal(rPos);\n        vec3 refDir = reflect(rd, normal);// reflect direction\n        float refInt = max(0.0, dot(refDir, vec3(0.279,0.284,0.315)));// reflect Intensity\n        vec3 refCol = 30.0*pow(refInt, 1.5)*(vec3(0.285,0.230,0.211));// reflect color\n        color = mix(bgCol, refCol, 0.5);\n        color = mix(color, refDir, 0.1);\n    }else{\n        color = bg(p*rotate(PI*0.5))*bgCol*0.1;\n    }\n    \n\tfragColor = vec4(mix(bgCol, color, 0.65-0.5*(sin(cos(time*0.5-150.))-0.2)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3s2BWG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3s2BWW", "name": "Spooky Gyration 2", "author": "workingclasshacker", "description": "Learning more and more every day!", "tags": ["gyroidraymarching"], "likes": 2, "viewed": 250, "date": "1590067991", "time_retrieved": "2024-06-20T20:06:25.006776", "image_code": "// Based on Art_of_code's youtube tutorial on Gyroids.\n// https://www.youtube.com/watch?v=-adHIyjIYgk\nprecision mediump float;\n\n#define MAX_STEPS 100\n#define SURFACE_DIST.001\n#define MAX_DIST 200.\n\nfloat sdSphere(vec3 p, vec4 sphere){\n  return length(p-sphere.xyz)-sphere.w;\n}\n\nfloat sdBox(vec3 p, vec3 box){\n  p = abs(p)-box;\n  return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)),0.);\n}\n\nfloat sdGyroid(vec3 p, float scale, float thickness, float bias, float xamp, float yamp){\n    p *= scale;\n    return abs(dot(sin(p)*xamp, cos(p.zxy)*yamp)-bias)/scale-thickness;\n}\nfloat GetDist(vec3 p){\n  //float box = sdSphere(p, vec4(vec3(0),3.4));\n  // p = abs(p);\n  float box = sdBox(p-vec3(0,0,0), vec3(2.5));\n  //float planed=p.y;\n  float t = iTime/12.;\n  float gyroid = sdGyroid(p, 10., min(.12,.1*sin(iTime)+.11), -1.4,2.*sin(t), cos(t));\n  // float gyroid2 = sdGyroid(p-.1, 21.);\n\n  float d = max(box, gyroid*.7);\n  // d = max(d-.05, gyroid2);\n  return d;\n}\n\nvec3 GetNormal(vec3 p){\n  vec2 e=vec2(.01,0);\n  float d=GetDist(p);\n  vec3 n=d-vec3(GetDist(p-e.xyy),GetDist(p-e.yxy),GetDist(p-e.yyx));\n  return normalize(n);\n}\n\nmat4 RotationX(float angle){\n  return mat4(1.,0,0,0,\n    0,cos(angle),-sin(angle),0,\n    0,sin(angle),cos(angle),0,\n  0,0,0,1);\n}\n\nmat4 RotationY(float angle){\n  return mat4(cos(angle),0,sin(angle),0,\n  0,1.,0,0,\n  -sin(angle),0,cos(angle),0,\n0,0,0,1);\n}\n\nmat4 RotationZ(float angle){\n  return mat4(cos(angle),-sin(angle),0,0,\n    sin(angle),cos(angle),0,0,\n    0,0,1,0,\n    0,0,0,1);\n}\n\nmat2 Rot2d(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat RayMarch(vec3 ro,vec3 rd){\n  float dO=0.;\n  for(int i=0;i<MAX_STEPS;i++){\n    vec3 p=ro+dO*rd;\n    float ds=GetDist(p);\n    dO+=ds;\n    if(dO<SURFACE_DIST||dO>MAX_DIST){\n      break;\n    }\n  }\n  return dO;\n}\n\nfloat GetLight(vec3 p){\n  mat4 r = RotationY(iTime);\n  vec4 lpos=vec4(1,2,3,1)*r;\n  \n  vec3 l=normalize(lpos.xyz-p);\n  vec3 n=GetNormal(p);\n  float diff=dot(n,l)*.5+.5;\n  float d=RayMarch(p+n*.02,l);\n  if(d<length(lpos.xyz-p)){\n    diff*=.4;\n  }\n  return diff;\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n  vec3 color=vec3(0);\n  \n  float t = iTime/10.;\n  // camera\n  vec3 ro = vec3(0, 3, -2);\n  \n    ro.yz *= Rot2d(t*3.14+1.);\n    ro.xz *= Rot2d(t*6.2831);\n  \n\n  vec3 rd=GetRayDir(uv, ro, vec3(0),1.);\n\n  // trace scene\n  float d=RayMarch(ro,rd);\n\n  // material\n  vec3 p=ro+rd*d;\n  vec3 n = GetNormal(p);\n  float diffuse=GetLight(p);\n  float o=0.;\n  color=vec3(diffuse-o);\n  color.rg += n.xy*.2-d*.05;\n  fragColor=vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3s2BWW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3s2fR1", "name": "Truchet experimentations", "author": "ManuManu", "description": "some try with Truchet ", "tags": ["2d", "truchet", "layers"], "likes": 6, "viewed": 278, "date": "1589637601", "time_retrieved": "2024-06-20T20:06:25.812760", "image_code": "\nfloat hash21(vec2 p)\n{\n    float v = fract(sin( p.x*1234.68 + p.y * 98765.543)*753.159);\n    return v;\n}\n\nvec3 palette( float t, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    return a + b * cos( 2.*3.14159 * ( c * t + d) );\n}\n\n// Different tries with palettes :\nvec3 MyPalette1( float t )\n{\n    return palette( t, vec3(.8, .5, .4), vec3(.2,.4,.2), vec3( .5), vec3( 0., .25, .25));\n}\nvec3 MyPalette2( float t )\n{\n    return palette( t, vec3(.5, .5, 5), vec3(.5, .5, .5), vec3( 1., 0.7,0.4), vec3( 0., .15, .2));\n}\nvec3 MyPalette3( float t )\n{\n    return palette( t, vec3(.5), vec3(.5), vec3( 1.), vec3( 0.3, .2, .2));\n}\nvec3 MyPalette4( float t )\n{\n    return palette( t, vec3(.5), vec3(.5), vec3( 1.,1.,0.5), vec3( 0.8, .9, .3));\n}\nvec3 MyPalette5( float t )\n{\n    return palette( t, vec3(.8, .5, .4), vec3(.2), vec3( .5,.5,0.5), vec3( 0., .9, .3));\n}\n\n\nvec3 MyPalette( float t )\n{\n    return MyPalette3(t);\n}\n\nfloat full_width = 0.09;\nfloat fade_width = 0.1;\n\nvec3 insideBoxDraw2( vec2 uv )\n{\n    vec3 col;\n    float d = min( abs(uv.x), abs(uv.y));\n    float val = smoothstep( fade_width, 0.,  d - full_width);\n    col = vec3(val);\n    return col;\n}\nvec3 insideBoxDraw3( vec2 uv )\n{\n    vec3 col;\n    float d = abs(abs(uv.x + uv.y) -.5);\n    float val = smoothstep( fade_width, 0.,  d - full_width);\n    col = vec3(val);\n    return col;\n}\n\nvec3 circle( vec2 uv, vec2 center, float rad, float width, vec3 color )\n{\n    float d = length(uv - center );\n    float val = smoothstep(  fade_width, 0., abs( d-rad) - full_width );\n    return val * color;\n}\n\nvec3 insideBoxDraw( vec2 uv )\n{\n    vec3 col = vec3(0.);\n    \n    vec2 center = vec2(.5,.5);\n    vec2 center2 = vec2(-.5,-.5);\n    \n    col  = circle( uv, center, .5, 0.05, vec3( 1.,1.,1.));\n    col += circle( uv, center2, .5, 0.05, vec3( 1.,1.,1.));\n    return col;\n}\n\nfloat truchet(vec2 p )\n{\n    float returnVal = 0.;\n    \n    vec2 boxCoord = fract(p)-.5;\n    vec2 id = floor(p);\n    \n    \n    //col = vec3( 1.-length(boxCoord) );\n    \n    float rnd = hash21( id );\n    if ( rnd < .5)\n        boxCoord.x = -boxCoord.x;\n    \n    float rnd2 = mod(rnd, .5 ) * 2.; \n    if ( rnd2 < .33)\n\t    returnVal = insideBoxDraw2(boxCoord).x;\n    else\n        if ( rnd2 < .66)\n\t\t\treturnVal = insideBoxDraw(boxCoord).x;\n        else\n            returnVal = insideBoxDraw3(boxCoord).x;\n        \n     \n    return returnVal;    \n    /*\n    if ( boxCoord.x > 0.48 || boxCoord.y > 0.48 )\n        col = vec3(1., 0.,0.);\n    //*/\n}\n\nmat2 rot( float a )\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2( c, s, -s, c);\n}\nvec2 moveUV( vec2 uv, float angle, float zoom, vec2 dep )\n{\n    return rot( angle ) * ( ( uv * zoom) + dep );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy * 2. - 1.;\n\tuv.x *= iResolution.x/iResolution.y;\n\n    vec2 realUv = uv;\n\tvec3 col = length(uv*.3) *vec3(0.3,0.3,0.8);\n\n    // general camera move :\n    uv = moveUV( uv, sin(iTime*.2), 1.1+.2*sin(iTime*.51), vec2(cos(iTime*.1), sin(iTime*.07)));\n    \n    float nbLayers = 10.;\n    for( float i = 0.; i < nbLayers; i+= 1.)\n    {\n        vec2 coord = moveUV( uv, iTime/(.3*i+1.), (nbLayers-i)*2., (nbLayers-i)*vec2(cos(iTime*5./(i+1.)), sin(iTime*3./(i+1.))) );\n        float truchetVal = truchet(coord);\n        \n        \n        float timeFactorPal = .5;\n        vec3 paletteColor1= mix( MyPalette1( length(coord )*2.), MyPalette5( length(coord )*.5), .5+.5*sin(iTime*timeFactorPal)) ;\n        vec3 paletteColor2 = mix( MyPalette1( length(coord )*2.), MyPalette3( length(coord )*3.), .5+.5*sin(iTime*timeFactorPal)) ;\n        \n        //vec3 paletteColor = mix( paletteColor1, paletteColor2, i/nbLayers);\n        vec3 paletteColor = paletteColor1;\n    \n        vec3 layerCol = paletteColor * ( i) / nbLayers;\n        col = mix( col,  layerCol, truchetVal);\n    }\n    \n    // Output to screen\n    //vignetting :\n    col*=smoothstep(2.5,1.,length(realUv));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3s2fR1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3s2fRd", "name": "Ellipsoid - distance, CJ version", "author": "chrisjj", "description": " CJ modification of https://www.shadertoy.com/view/tdS3DG showing unexpected pinching and wayward shadow (?) from thinning (kine 57) the improved version (right side).\n", "tags": ["sdfiq"], "likes": 4, "viewed": 190, "date": "1590620704", "time_retrieved": "2024-06-20T20:06:27.091730", "image_code": "//  CJ modification of https://www.shadertoy.com/view/tdS3DG showing unexpected pinching effect of thinning the improved version on right.\n\n\n// The MIT License\n// Copyright Â© 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Computing the exact distance to a generic (non symmetric) ellipsoid\n// requires solving a sixth degree equation, which can be difficult.\n// Approximating the distance is easier though. This shaders shows one\n// such approximation that produces better results than the naive\n// approach. More info here:\n//\n// http://iquilezles.org/www/articles/ellipsoids/ellipsoids.htm\n//\n// Left, naive ellipsoid distance approximation (single square root)\n// Right, improved approximation (two square roots).\n//\n// Note how the improved approximation produces a more accurate intersection\n// for the same number of raymarching steps (specially noticeable in the first\n// frame of the animation). Note also how the penumbra shadow estimation works\n// best with since since it has a more eucliden distance as input.\n//\n// The technique is based on dividing the bad approximation's distance estimation\n// by the length of its gradient to get a first order approximation to the true\n// distance (see http://iquilezles.org/www/articles/distance/distance.htm)\n\n#define AA 1   // make this 3 is you have a fast computer\n\n//------------------------------------------------------------------\n\n// generic ellipsoid - simple but bad approximated distance\nfloat sdEllipsoid_Bad( in vec3 p, in vec3 r ) \n{\n    return (length(p/r)-1.0)*min(min(r.x,r.y),r.z);\n}\n\n\n// generic ellipsoid - improved approximated distance\nfloat sdEllipsoid( in vec3 p, in vec3 r ) \n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n//------------------------------------------------------------------\n\nvec2 map( in vec3 p, int id )\n{\n    // ellipsoid\n    // CJ: prolate \n    float d1 = (id==0) ? sdEllipsoid_Bad( p, vec3(0.3,0.1,0.1) ) :\n                         sdEllipsoid(     p, vec3(0.3,0.1,0.1) );\n    \n    // CJ\n    d1+=.084; // Distortion: https://i.imgur.com/lm5TKhV.png\n   // d1-=.084; // Distortion: https://i.imgur.com/sHWTXKj.png\n\n    // plane\n    float d2 = p.y+0.3;\n    \n    return (d1<d2) ? vec2(d1,1.0) : vec2(d2,2.0);\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd, int id )\n{\n    float m = 0.0;\n    float t = 0.0;\n    const float tmax = 100.0;\n    for( int i=0; i<100 && t<tmax; i++ )\n    {\n\t    vec2 h = map( ro+rd*t, id );\n        if( h.x<0.001 ) break;\n        m = h.y;\n        t += h.x;\n    }\n\n    return (t<tmax) ? vec2(t,m) : vec2(0.0);\n}\n\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in int id)\n{\n\tfloat res = 1.0;\n    float t = 0.01;\n    for( int i=0; i<256; i++ )\n    {\n\t\tfloat h = map( ro + rd*t, id ).x;\n        res = min( res, smoothstep(0.0,1.0,8.0*h/t ));\n        t += clamp( h, 0.005, 0.02 );\n        if( res<0.001 || t>5.0 ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos, in int id )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy, id ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, id ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, id ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, id ).x );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor, in int id )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos, id).x;\n        occ += (hr-dd)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );    \n}\n \n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p )\n{\n    // filter kernel\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd, int id )\n{ \n    vec3 col = vec3(0.1);\n    \n    vec2  res = castRay(ro,rd, id);\n\n    if( res.y>0.5 )\n    {\n        float t   = res.x;\n        vec3  pos = ro + t*rd;\n        vec3  nor;\n        float occ;\n\n        // material        \n        if( res.y>1.5 )\n        {\n        \tnor = vec3(0.0,1.0,0.0);\n            col = 0.05*vec3(1.0);\n            col *= 0.8+0.2*checkersGradBox( pos.xz*2.0 );\n            occ = 1.0;\n\n        }\n        else\n        {\n            nor = calcNormal( pos, id );\n            occ = 0.5+0.5*nor.y;\n            col = vec3(0.25,0.15,0.05);\n        }\n\n        // lighting\n        occ *= calcAO( pos, nor, id );\n\n        vec3  lig = normalize( vec3(-0.5, 1.9, 0.8) );\n        vec3  hal = normalize( lig-rd );\n        float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n\n        float sha = calcSoftshadow( pos, lig, id );\n        sha = sha*sha;\n\n        float spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),32.0)*\n                    dif * sha *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n        vec3 lin = vec3(0.0);\n        lin += 2.00*dif*vec3(3.30,2.50,2.00)*sha;\n        lin += 0.50*amb*vec3(0.30,0.60,1.50)*occ;\n        lin += 0.30*bac*vec3(0.40,0.30,0.25)*occ;\n        col = col*lin;\n        col += 2.00*spe*vec3(3.30,2.50,2.00);\n        \n        //col = mix( col, vec3(0.1), 1.0-exp(-0.03*t) );\n    }\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera\t\n    vec3 ro = vec3( 1.0*cos(0.2*iTime), 0.12, 1.0*sin(0.2*iTime) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera-to-world transformation\n    vec3 cw = normalize(ta-ro);\n    vec3 cu = normalize( cross(cw,vec3(0.0, 1.0,0.0)) );\n    vec3 cv =          ( cross(cu,cw) );\n\n    // scene selection\n    int id = (fragCoord.x>iResolution.x/2.0) ? 1 : 0;\n\n    // render\n    vec3 tot = vec3(0.0);\n\t#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 fc = o + vec2( mod(fragCoord.x,iResolution.x/2.0), fragCoord.y);\n\t\t#else    \n        vec2 fc = vec2( mod(fragCoord.x,iResolution.x/2.0), fragCoord.y);\n\t\t#endif\n        vec2 p = (-vec2(iResolution.x/2.0,iResolution.y) + 2.0*fc)/iResolution.y;\n\n        // ray direction\n        vec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n\n        // render\t\n        vec3 col = render( ro, rd, id );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n\t#if AA>1\n    }\n    tot /= float(AA*AA);\n\t#endif\n\n    // separator    \n\ttot *= smoothstep( 1.0, 2.5, abs(fragCoord.x-iResolution.x/2.0) );\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/3s2fRd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3s2fWG", "name": "Endless Boze Tunnel", "author": "kaiware007", "description": "End not end.", "tags": ["raymarching"], "likes": 2, "viewed": 74, "date": "1590735742", "time_retrieved": "2024-06-20T20:06:29.516150", "image_code": "// ------------------------------------------------------------------------------------\n// Original \"thinking...\" created by kaneta : https://www.shadertoy.com/view/wslSRr\n// Original Character By MikkaBouzu : https://twitter.com/mikkabouzu777\n// ------------------------------------------------------------------------------------\n\n#define M_PI 3.1415926\n#define M_PI2 M_PI*2.0\n\n#define M_PI03 1.04719\n#define M_PI06 2.09439\n\n#define MAT_BLACK 1.0\n#define MAT_FACE 2.0\n#define MAT_BROW 3.0\n#define MAT_CHEEP 4.0\n#define MAT_SPHERE 5.0\n#define MAT_BG 6.0\n\n#define AA 1\n    \nvec3 sinebow(float h) {\n    vec3 r = sin((.5-h)*M_PI + vec3(0,M_PI03,M_PI06));\n    return r*r;\n}\n\nfloat rand(vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 10000.0);\n}\n\nfloat rand3d(vec3 st)\n{\n    return fract(sin(dot(st.xyz, vec3(12.9898, 78.233, 56.787))) * 10000.0);\n}\n\n\nfloat noise(vec3 st)\n{\n\tvec3 ip = floor(st);\n    vec3 fp = smoothstep(vec3(0.), vec3(1.), fract(st));\n    \n\tvec4 a = vec4(rand3d(ip+vec3(0.)),rand3d(ip+vec3(1.,0.,0.)),rand3d(ip+vec3(0.,1.,0.)),rand3d(ip+vec3(1.,1.,0.)));\n    vec4 b = vec4(rand3d(ip+vec3(0.,0.,1.)),rand3d(ip+vec3(1.,0.,1.)),rand3d(ip+vec3(0.,1.,1.)),rand3d(ip+vec3(1.,1.,1.)));\n    \n\ta = mix(a, b, fp.z);\n\ta.xy = mix(a.xy, a.zw, fp.y);\n    \n\treturn mix(a.x, a.y, fp.x);\n}\n\nfloat easeInOutQuad(float t) {\n    if ((t *= 2.0) < 1.0) {\n        return 0.5 * t * t;\n    } else {\n        return -0.5 * ((t - 1.0) * (t - 3.0) - 1.0);\n    }\n}\n\n// Distance functions by iq\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdRoundBox(vec3 p, vec3 size, float r)\n{\n    return length(max(abs(p) - size * 0.5, 0.0)) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - r;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n// Union, Subtraction, SmoothUnion (distance, Material) \nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 opS( vec2 d1, vec2 d2 )\n{ \n    return (-d1.x>d2.x) ? vec2(-d1.x, d1.y): d2;\n}\n\nvec2 opSU( vec2 d1, vec2 d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.x-d1.x)/k, 0.0, 1.0 );\n    return vec2(mix( d2.x, d1.x, h ) - k*h*(1.0-h), h > 0.5 ? d1.y : d2.y); }\n\n// Union, Subtraction, SmoothUnion (distance only)\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\nvec3 rotate(vec3 p, float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nvec3 opTwist(in vec3 p, float k )\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return vec3(q.x, q.y, q.z);\n}\n\nvec3 TwistY(vec3 p, float power)\n{\n    float s = sin(power * p.y);\n    float c = cos(power * p.y);\n    mat3 m = mat3(\n          c, 0.0,  -s,\n        0.0, 1.0, 0.0,\n          s, 0.0,   c\n    );\n    return m*p;\n}\n\nfloat ease_cubic_out(float p)\n{\n\tfloat f = (p - 1.0);\n\treturn f * f * f + 1.0;\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\nvec2 opRep2D( in vec2 p, in vec2 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\n// ç·åã¨ç¡éå¹³é¢ã®è¡çªä½ç½®ç®åº\n// rayPos : ã¬ã¤ã®éå§å°ç¹\n// rayDir : ã¬ã¤ã®åã\n// planePos : å¹³é¢ã®åº§æ¨\n// planeNormal : å¹³é¢ã®æ³ç·\nfloat GetIntersectLength(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal)\n{\n    return dot(planePos - rayPos, planeNormal) / dot(rayDir, planeNormal);\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// Mikka Boze Distance Function\n/////////////////////////////////////////////////////////////////////////////////////////////////\n#define RAD90 (M_PI * 0.5)\n\nfloat sdEar(vec3 p, float flip, float sc)\n{\n    p.x *= flip;\n    p = rotate(p, RAD90+0.25, vec3(0,0,1));    \n    return sdCappedTorus(p + vec3(0.05, 0.175, 0) * sc, vec2(sin(0.7),cos(0.7)), 0.03 * sc, 0.01 * sc);\n}\n\n#define EYE_SPACE 0.04\n\nvec3 opBendXY(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\nfloat sdMouse(vec3 p, float sc, float ms)\n{\n    vec3 q = opBendXY(p, 2.0);\n    \n    //return sdEllipsoid(q - vec3(0,0,0.2) * sc, vec3(0.05,0.015 + sin(iTime * 1.) * 0.05,0.05) * sc);\n    return sdEllipsoid(q - vec3(0,0,0.2) * sc, vec3(0.05,0.02 * ms,0.2 * ms) * sc);\n}\n\nfloat sdCheep(vec3 p, float flip, float sc)\n{\n\tp.x *= flip;\n    \n    float x = 0.05;\n    float z = -0.18;\n    p = rotate(p, M_PI * -0.6 * (p.x - x) / sc, vec3(0,1,0));\n\n    float d = sdCapsule(opBendXY(p + vec3(x, -0.01, z) * sc, 100.0/sc), vec3(-0.005,0.0,0) * sc, vec3(0.005, 0., 0) * sc, 0.0025 * sc);\n    float d1 = sdCapsule(opBendXY(p + vec3(x+0.01, -0.01, z) * sc, 200.0/sc), vec3(-0.0026,0.0,0) * sc, vec3(0.0026, 0., 0) * sc, 0.0025 * sc);\n    float d2 = sdCapsule(opBendXY(p + vec3(x+0.019, -0.015, z) * sc, -100.0/sc), vec3(-0.01,0.0,-0.01) * sc, vec3(0.0045, 0., 0.0) * sc, 0.0025 * sc);\n    \n    return opUnion(opUnion(d, d1), d2);\n}\n\nfloat sdEyeBrow(vec3 p, float flip, float sc)\n{\n    p.x *= flip;\n    \n    p = rotate(p, M_PI * -0.0225, vec3(0,0,1));\n    \n    return sdRoundBox(p + vec3(0.03, -0.14,-0.125) * sc, vec3(0.015,0.0025,0.1) * sc, 0.0001);\n}\n\nvec2 sdBoze(vec3 p, float sc, float ms)\n{    \n    vec2 result = vec2(0.);\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0) * sc, vec3(0, 0.11, 0) * sc, 0.125 * sc);\n    \n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0) * sc, 0.095 * sc, 0.05 * sc, 0.0);\n    \n    d = opSmoothUnion(d, d1, 0.1 * sc);\n    \n    // ear\n    float d2 = sdEar(p, 1.0, sc);\n    d = opUnion(d, d2);\n    float d3 = sdEar(p, -1.0, sc);\n    d = opUnion(d, d3);\n\n    vec2 head = vec2(d, MAT_FACE);\n\n\t// eye\n    float d4 = sdCapsule(p, vec3(EYE_SPACE, 0.06, 0.125) * sc, vec3( EYE_SPACE, 0.08, 0.125) * sc, 0.0175 * sc);\n    float d5 = sdCapsule(p, vec3(-EYE_SPACE,0.06, 0.125) * sc, vec3(-EYE_SPACE, 0.08, 0.125) * sc, 0.0175 * sc);\n    vec2 eye = vec2(opUnion(d4, d5), MAT_BLACK);\n    \n    // mouse\n    float d6 = sdMouse(p, sc, ms);\n    vec2 mouse = vec2(d6, MAT_BROW);\n    \n    // cheep\n    float d7 = sdCheep(p, 1.0, sc);\n    float d8 = sdCheep(p, -1.0, sc);\n    vec2 cheep = vec2(opUnion(d7, d8), MAT_CHEEP);\n\n    // eyebrows\n    float d9 = sdEyeBrow(p, 1.0, sc);\n    float d10 = sdEyeBrow(p, -1.0, sc);\n    eye.x = opUnion(eye.x, opUnion(d9, d10));\n    \n    mouse = opU(eye, mouse);\n    result = opS(mouse, head);\n    result = opU(cheep, result);\n    \n    \n    return result;\n}\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// End of Mikka Boze\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\n\nvec2 map(vec3 p)\n{\n\tvec2 result = vec2(1.);\n    \n    //vec4 v = voronoi(p * 0.25);\n    \n    //float s = 1.0;\n    //p = deform( p, iTime, s );\n    \n    for(float i = 0.; i < 4.; i++){\n        float time = iTime * 0.25 + i * 0.25;\n        float sc = fract(time);\n\n        vec3 q = p;\n        //vec3 q = p - vec3(0.,0.,-1. + mod(time, 2.0));\n        //q.x = mod(p.x+1.0,2.0)-1.0;\n        //q.z = mod(p.z+1.0,2.0)-1.0;\n        //q.xz = opRep2D(q.xz, vec2(1.0));\n        //q = opRep(q, vec3(1.0));\n        //q.x += cos(iTime + pow(1.0-q.y, 25.))*0.1;\n\n        //q.xyz = v.yzw;\n        //vec3 q2 = q;\n        //vec3 index = floor(p + 0.5);\n        //float angle = (index.y + index.x + time * 2.5) * M_PI2;\n\n        //q.xy += vec2(cos(angle)*0.075, sin(angle)*0.05);\n        //q = rotate(q, time * 15., vec3(0,0,1));\n\t\tq = rotate(q, sc * 8. - iTime * 0.1 * M_PI2, vec3(0,0,1));\n        \n        //q.y -= mod(rand(index.xy) * 10. + timeSpeed * (0.5 + rand(index.yx) * 2.5), 10.) - 5.;\n\n        //q = rotate(q, angle, normalize(vec3(noise(vec3(index.xy, timeSpeed)), noise(vec3(index.y, timeSpeed, index.z)), noise(vec3(timeSpeed, index.zx)))));\n\n        result = opU(sdBoze(q, pow(sc,6.0) * 20., 0.0 + (1. - pow(1. - smoothstep(0.3,0.99, sc),1.5)) * 2.), result);\n    }\n    \n    //vec2 body = vec2(sdEllipsoid(q2 + vec3(0.,0.2,0.025), vec3(0.2, 0.175, 0.15)), MAT_FACE);\n    //result = opSU(body, result, 0.025);\n    \n    // background\n    //vec2 bg1 = vec2(sdPlane(p + vec3(0., 1.0, 0.), vec4(0,1,0,0)), MAT_BG);\n    //vec2 bg2 = vec2(sdPlane(p - vec3(0., 1.0, 0.), vec4(0,-1,0,0)), MAT_BG);\n    \n    //result = opSU(bg1, result,  0.25);\n    //result = opSU(bg2, result,  0.25);\n    \n    //result.x *= s;\n    \n    return result;\n}\n\nvec3 norm(vec3 p)\n{\n    vec2 e=vec2(.001,.0);\n    return normalize(.000001+map(p).x-vec3(map(p-e.xyy).x,map(p-e.yxy).x,map(p-e.yyx).x));\n}\n\nvec3 fresnelSchlick_roughness(vec3 F0, float cosTheta, float roughness) {\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n// Unreal Engine Ambient BRDF Approx\n// https://www.unrealengine.com/en-US/blog/physically-based-shading-on-mobile?lang=en-US\nvec3 EnvBRDFApprox( vec3 SpecularColor, float Roughness, float NoV )\n{\n\tconst vec4 c0 = vec4( -1, -0.0275, -0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, -0.04 );\n\tvec4 r = Roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn SpecularColor * AB.x + AB.y;\n}\n\nvec3 calcAmbient(vec3 pos, vec3 albedo, float metalness, float roughness, vec3 N, vec3 V, float t)\n{\n\tvec3 F0 = mix(vec3(0.04), albedo, metalness);\n    vec3 F  = fresnelSchlick_roughness(F0, max(0.0, dot(N, V)), roughness);\n    vec3 kd = mix(vec3(1.0) - F, vec3(0.0), metalness);\n    \n\tfloat aoRange = t/20.0;\n\tfloat occlusion = max( 0.0, 1.0 - map( pos + N*aoRange ).x/aoRange );\n\tocclusion = min(exp2( -.8 * pow(occlusion, 2.0) ), 1.0);\n    \n    vec3 ambientColor = vec3(0.5);\n    \n    vec3 diffuseAmbient = kd * albedo * ambientColor * min(1.0, 0.75+0.5*N.y) * 3.0;\n    vec3 R = reflect(-V, N);\n    \n    vec3 col = mix(vec3(0.5) * pow( 1.0-max(-R.y,0.0), 4.0), ambientColor, pow(roughness, 0.5));\n    vec3 ref = EnvBRDFApprox(F0, roughness, max(dot(N, V), 0.0));\n    vec3 specularAmbient = col * ref;\n\n    diffuseAmbient *= occlusion;\n    return vec3(diffuseAmbient + specularAmbient);\n}\n\n///////////////////////////////////////////////////////////////////////\n#define MAX_MARCH 100\n\nvec3 materialize(vec3 p, vec3 ray, float depth, vec2 mat)\n{\n    vec3 col = vec3(0.12, 0., 0.4);\n    //vec3 col = min(vec3(0.12, 0., 0.4) + sinebow(fract(iTime * 1.5)) * vec3(0.1), 1.);\n    vec3 nor = norm(p);\n    vec3 sky = vec3(1.0,0.0,0.0);\n    //vec3 sky = min(sinebow(fract(iTime * 2.5 + 0.5)) * vec3(0.35) + vec3(0.3) + pow(max(1.29 - p.y, 0.), 5.), 1.);\n    //if(p.y >= 0.29) \n    if(depth > 100.)\n    {\n    \tcol = sky;\n    } else {\n        if(mat.y > 0.0){\n            vec2 index = floor(p.xz + 0.5);\n\n            float roughness, metalness;\n            if(mat.y == MAT_BLACK) {\n                col = vec3(0.0, 0.0, 0.0);\n                roughness = 0.8;\n                metalness = 0.0;\n            } else if(mat.y == MAT_FACE) {\n                col = vec3(1.0, 0.8, 0.6);\n                roughness = 0.8;\n                metalness = 0.0;\n            } else if(mat.y == MAT_BROW) {\n                col = vec3(1.0, 0, 0);\n                roughness = 0.1;\n                metalness = 0.0;\n            } else if(mat.y == MAT_CHEEP) {\n                col = vec3(1.0, 0.3, 0.5);\n                roughness = 0.1;\n                metalness = 0.0;\n        \t} else if(mat.y == MAT_BG) {\n                //col = min(sinebow(fract((index.x + index.y) * 0.175 + iTime * 0.5 + 0.5)) * vec3(0.3), 1.);\n                //float e = smoothstep(abs(mod(p.y + 0.25 + iTime * 0.5, 0.5) - 0.25), 0.0, 0.0125); \n                roughness = 1.0;\n                metalness = 0.0;\n            }\n\n            vec3 result = vec3(0.);\n            result += calcAmbient(p, col, metalness, roughness, nor, -ray, depth);\n            col = result;\n        }\n        //float fog = min(1.0, (1.0 / float(MAX_MARCH)) * float(mat.x))*5.0;\n    \t//vec3  fog2 = vec3(0.015,0.015,0.01) * depth;\n    \t//col += vec3(0.01, 0.01, 0.05) * fog;\n    \t//col += fog2 + sky * 0.1;\n        //col -= fog2;\n    }\n    \n    return col;\n}\n\nvec3 trace(vec3 p, vec3 ray)\n{\n    float t = 0.0;\n    vec3 pos;\n    vec2 mat;\n    \n    //float planeDistance = GetIntersectLength(p, ray, vec3(0.,0.3,0.), vec3(0.,1.,0.));\n    //t = planeDistance;\n    \n    int count = 0;\n    for (int i = 0; i < MAX_MARCH; i++) {\n        pos = p + ray * t;\n        mat = map(pos);\n        if (mat.x <= 0.0001) {\n        \tbreak;\n        }\n        t += mat.x * 0.5;\n        count++;\n    }\n    \n    p = p + t * ray;\n    mat.x = float(count);\n    return materialize(p, ray, t, mat);\n}\n\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n        float time = iTime * 0.2 * M_PI2;\n        //float x = mod(iTime * 0.5, 10000.);\n        //vec3 ro = vec3(cos(rotSpeed)*5.0, 0., sin(rotSpeed)*5.0);\n        //vec3 ro = vec3(0, 0., 1.0);\n        //vec3 ta = vec3(0., 0.0, 0.);\n        //vec3 ro = vec3(x, 0., 5.5);\n        //vec3 ta = vec3(x, 0., 0.);\n        vec3 ro = vec3(sin(time * 2.0) * 0.1, cos(time * 1.) * 0.1, 1.0);\n        vec3 ta = vec3(-cos(time * 1.0) * 0.05, sin(time * 2.0) * 0.05 , 0.);\n        //vec3 ta = ro + vec3(cos(rotSpeed)*5.0, 0., sin(rotSpeed)*5.0);\n        mat3 c = camera(ro, ta, 0.);\n        vec3 ray = c * normalize(vec3(p, 3.5));\n        vec3 col = trace(ro, ray);\n    \n\t\ttot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    fragColor = vec4(tot,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3s2fWG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3s2fz3", "name": "Circle_Inversion", "author": "lil_chickehh", "description": "my first public shader. Does anyone know how to get rid of the ugly stuff in the middle?", "tags": ["geometry"], "likes": 3, "viewed": 80, "date": "1590522053", "time_retrieved": "2024-06-20T20:06:29.673904", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float density=3.1415926*8.;//controls how small the checkers are\n\n    //normalize stuff\n    vec2 uv = fragCoord/(.5*iResolution.y)-vec2(iResolution.x/iResolution.y,1.);\n    \n    //transform space\n    vec2 t=uv/(dot(uv,uv));\n    t+=vec2(sin(iTime*0.2),cos(iTime*0.2));\n\n    //checkerboard pattern\n    float col=smoothstep(-0.31,0.31,cos(t.x*density)+cos(t.y*density));\n    \n    //white light in the middle (remove to see the original ugliness)\n    col=col+.05/dot(uv,uv);\n\t\n    // Output to screen\n    fragColor = vec4(vec3(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3s2fz3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3s2fzd", "name": "Crazy Cobwebs", "author": "jarble", "description": "This is based on my [url=https://www.shadertoy.com/view/Wd2fzd]\"Iridescent bubble fly-through\"[/url] animation.", "tags": ["raymarching", "hash"], "likes": 0, "viewed": 181, "date": "1590626829", "time_retrieved": "2024-06-20T20:06:30.837468", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n/**\n * Part 6 Challenges:\n * - Make a scene of your own! Try to use the rotation transforms, the CSG primitives,\n *   and the geometric primitives. Remember you can use vector subtraction for translation,\n *   and component-wise vector multiplication for scaling.\n */\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 10.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.00001;\n\nvec3 hash33(vec3 p3)\n{\t\n    //this is from https://www.shadertoy.com/view/4djSRW\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3)+p3.zyx);\n\n}\n\n/**\n * Rotation matrix around the Y axis.\n */\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(hash33(sin(p)/10.0))-sin(length(p))/3.33;\n}\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {    \n    //Slowly spin the whole scene\n    samplePoint = samplePoint+vec3(0.0,0.0,0.0);\n    \n    return sphereSDF(samplePoint,1.0);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(8.0+iTime*10.0, 5.0, 7.0*iTime);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = hash33(p/(500.0));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3s2fzd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3s2fzh", "name": "sherbert hexagon ripple", "author": "emmagamma", "description": "reminiscent of the colors experienced at uhhh, certain times, with certain things >.>", "tags": ["cubes", "glow", "hexagons", "sherbert"], "likes": 1, "viewed": 77, "date": "1589493265", "time_retrieved": "2024-06-20T20:06:30.837468", "image_code": "float hexGrid(vec2 pos) {\n  float diagonalWarp = sin(sin(pos.y - pos.x - iTime)/20.0 + (sin(iTime)/20.0));\n  float otherDiagonalWarp = sin(sin(pos.y + pos.x - iTime)/20.0 + (sin(iTime)/20.0));\n\n  pos.x *= 1.0847;\n  pos.y += mod(floor(pos.x), 2.0) * 0.5;\n  pos.y +=  otherDiagonalWarp - diagonalWarp;\n\n  pos = abs(mod(pos, 1.0) - 0.5);\n\n  return abs(max(pos.x * 1.5 + pos.y, pos.y * 2.0) - 1.0);\n}\n\nvec3 invert(vec3 color) {\n  return vec3(1.0 - color.r, 1.0 - color.g, 1.0 - color.b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 px = fragCoord.xy/iResolution.y;\n\n    vec3 pink = vec3(1.0, 0.7, 0.8);\n    vec3 green = vec3(0.3, 0.96, 0.69);\n    vec3 orange = vec3(1.0, 0.91, 0.75);\n\n    float sine = abs(sin(iTime / 4.0));\n    vec3 pinkToOrange = mix(pink, orange, sine);\n    vec3 orangeToPink = mix(orange, pink, sine);\n    vec3 pinkToGreen = mix(pink, green, sine);\n\n    vec3 hexagons = vec3( smoothstep(0.0, 0.05, hexGrid(px * 4.2)) );\n    vec3 softHexagons = vec3(\n      smoothstep(-0.3, 0.9, hexGrid(px * 4.2) + cos(abs(sin(iTime / 10.0)) / 10.0) - 1.1)\n    );\n    vec3 tinyHexagons = vec3(\n      smoothstep(-0.9, 0.3, hexGrid(px * 4.2) + sin(abs(sin(iTime / 10.0)) / 8.0) - 1.1)\n    );\n\n    fragColor = vec4(\n      (hexagons * pinkToOrange * invert(softHexagons * pinkToGreen)\n        - (tinyHexagons * pink) + (softHexagons*pink/4.0))\n      + (invert(hexagons) * green + (tinyHexagons * orangeToPink * 1.5)\n        + ((softHexagons * orangeToPink * orange) / 1.3))\n      + ((sin(iTime/4.0)/20.0) + 0.1)\n      * (invert(hexagons) * green), 1.0\n    );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3s2fzh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3s2fzV", "name": "Outline 2020 battle MsieurSoleil", "author": "MonsieurSoleil", "description": "25 min shader battle result.\n\nI don't really know if the is a value to publish that shader, but... let's let it here =)", "tags": ["livecoding"], "likes": 4, "viewed": 117, "date": "1590429581", "time_retrieved": "2024-06-20T20:06:30.837468", "image_code": "#define time iTime\n#define mod01 floor(mod(time*2.0, 4.0))\n#define mod02 floor(mod(time*4.0, 8.0))\n#define mod03 floor(mod(time*2.0, 16.0))\n\nfloat gg = 0.0;\n\nfloat sphere(vec3 p, float r)\n{\n  return length(p) -r ;\n}\n\nfloat box(vec3 p, vec3 s)\n{\n  p = abs(p) - s;\n  return max(p.x, max(p.y, p.z));\n  \n}\n\nfloat rnd2(vec2 uv)\n{\n  return fract( dot( sin(uv*4521.562549+uv.yx*562.2354) , vec2(452.12336)));\n}\n\nfloat rnd(float t)\n{\n  return fract( sin(t*4521.562549) * 452.12336);\n}\n\nfloat curve(float t)\n{\n  return mix( rnd(t), rnd(t)+1.0, smoothstep(0.0, 1.0, fract(t)));\n  \n}\n\nfloat smin(float a, float b, float k)\n{\n  float h = clamp(0.5 - 0.5 * (a - b)/k, 0.0, 1.0);\n  return mix(b,a, h) - k*h*(1.0 - h);\n}\n\nfloat map(vec3 p)\n{\n  float mat;\n  \n  float repeat = 2.0;\n  float height = sin(time) + sin(p.x * 0.1 + time);\n  \n  vec2 grid = (floor(abs(p.xz) / repeat - 0.5) - 0.5) * repeat;\n  float rndX = rnd2(grid * 16.2) * 2.0;\n  vec3 p2 = p;\n  p2.xz = (fract(abs(p.xz) / repeat - 0.5) - 0.5) * repeat;\n  \n  vec3 scale = vec3(0.8 * rndX * mod03, 0.1 + 0.2 * mod01 + 0.5 * mod02* rndX  , 2.0);\n  \n  mat = box(p2 + vec3(0.0, height * rndX, 0.0), scale);\n  \n   gg += 0.1/(0.9+mat*mat);\n  \n   mat = smin(mat, p.y, 3.5);\n  \n  \n  return mat;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 o = vec3(0.0, 26.0, curve(mod01) * 75.0 + 5.0), t = vec3(0.0);\n\n  vec3 fr = normalize(t -o);\n  vec3 ri = normalize(cross(vec3(0.0, 1.0, 0.0), fr));\n  vec3 up = normalize(cross(fr, ri));\n  vec3 dir = normalize(fr + uv.x * ri + uv.y * up);\n  vec3 p = o + dir * 0.5;\n  \n  float shad = 0.0, d = 0.0, mat = .0;\n\tvec3 col = vec3(0.0);\n  for(int i = 0; i < 100; ++i)\n  {\n    mat = map(p);\n    if(mat < 0.01)\n    {\n      shad = clamp(1.0 - (float(i) / 200.0) ,0.0, 1.0);\n    }\n    \n    p += dir * mat;\n    d += mat;\n    \n    col += gg * vec3(0.0, 0.2, 0.5) * 0.005 * abs(sin(mod01) + 0.5);\n  }\n  \n  col += vec3(0.4) * shad;\n  \n  float fog = clamp(1.0 - (float(d)/100.0), 0.0, 1.0);\n  vec3 sky = mix(vec3(1.0, 0.5, 0.0), vec3(0.5, 0.5, 1.0), uv.y - 0.5);\n  col += sky * fog;\n  \n  \n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3s2fzV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3s2yRt", "name": "Hw9 - Noise & UV Map", "author": "vmoniqb", "description": "hw9", "tags": ["raycasting"], "likes": 0, "viewed": 56, "date": "1588872610", "time_retrieved": "2024-06-20T20:06:33.462082", "image_code": "const float FOVY = 3.14159 * 0.25;\nconst int RAY_STEPS = 256;\nconst float AO_DIST = 0.085;\nconst float AO_KVAL = 2.0;\n// The larger the DISTORTION, the smaller the glow\nconst float DISTORTION = 0.2;\n// The higher GLOW is, the smaller the glow of the subsurface scattering\nconst float GLOW = 5.0;\n// The higher the BSSRDF_SCALE, the brighter the scattered light\nconst float BSSRDF_SCALE = 2.0;\n// Boost the shadowed areas in the subsurface glow with this\nconst float AMBIENT = 2.0;\n\n    \nstruct Intersection\n{\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\t// Assign every object in scene a unique ID int\n};\n\n    \n\n// Cosine palette VENUS\nconst vec3 av = vec3(0.5, 0.5, 0.5);\nconst vec3 bv = vec3(0.5, 0.5, 0.5);\nconst vec3 cv = vec3(2.0, 1.0, 0.0);\nconst vec3 dv = vec3(0.5, 0.2, 0.25);\n\n// Cosine palette EARTH\nconst vec3 ae = vec3(0.0, 0.58, 0.45 );\nconst vec3 be = vec3(0.5, 0.65, 0.31);\nconst vec3 ce = vec3(0.4, 0.8, 0.7);\nconst vec3 de = vec3(0.4, 0.15, 0.0);\n\t\n// Cosine palette MARS\nconst vec3 am = vec3(1.0, 0.0, 0.0);\nconst vec3 bm = vec3(0.4, 0.8, 0.0);\nconst vec3 cm = vec3(0.5, 0.34, 0.89);\nconst vec3 dm = vec3(0.5, 0.63, 0.9);\n\n// Cosine palette SATURN\nconst vec3 as = vec3(0.5, 0.5, 0.5);\nconst vec3 bs = vec3(0.5, 0.5, 0.5);\nconst vec3 cs = vec3(1.0, 1.0, 1.0);\nconst vec3 ds = vec3(0.0, 0.10, 0.20);\n\n// Cosine palette Background\nconst vec3 ab = vec3(0.8, 0.5, 0.4);\nconst vec3 bb = vec3(0.2, 0.4, 0.2);\nconst vec3 cb = vec3(2.0, 1.0, 1.0);\nconst vec3 db = vec3(0.0, 0.25, 0.25);\n\nvec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n    return a + b * cos(6.28318 * (c * t + d) );\n}\n\n\n\n// RANDOM NOISE FUNCTIONS\nfloat random1(vec3 p) {\n  return fract(sin(dot(p, vec3(127.1, 311.7, 191.999))) * 43758.5453);\n}\n\nvec2 random2(vec2 p) {\n  return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * 43758.5453);\n}\n\nfloat smootherStep(float a, float b, float t) {\n  t = t*t*t*(t*(t*6.0 - 15.0) + 10.0);\n  return mix(a, b, t);\n}\n\nvec3 random3(vec3 p) {\n    return fract(sin(vec3(dot(p,vec3(127.1, 311.7, 191.999)),\n                          dot(p,vec3(269.5, 183.3, 765.54)),\n                          dot(p,vec3(420.6, 631.2, 109.23))\n                    )) * 43758.5453);\n}\n\n\n\n// PERLIN NOISE FUNCTION\nfloat perlin(vec3 p) {\n  vec3 pFract = fract(p);\n  float llb = random1(floor(p));\n  float lrb = random1(floor(p) + vec3(1.0,0.0,0.0));\n  float ulb = random1(floor(p) + vec3(0.0,1.0,0.0));\n  float urb = random1(floor(p) + vec3(1.0,1.0,0.0));\n\n  float llf = random1(floor(p) + vec3(0.0,0.0,1.0));\n  float lrf = random1(floor(p) + vec3(1.0,0.0,1.0));\n  float ulf = random1(floor(p) + vec3(0.0,1.0,1.0));\n  float urf = random1(floor(p) + vec3(1.0,1.0,1.0));\n\n  float lerpXLB = smootherStep(llb, lrb, pFract.x);\n  float lerpXHB = smootherStep(ulb, urb, pFract.x);\n  float lerpXLF = smootherStep(llf, lrf, pFract.x);\n  float lerpXHF = smootherStep(ulf, urf, pFract.x);\n\n  float lerpYB = smootherStep(lerpXLB, lerpXHB, pFract.y);\n  float lerpYF = smootherStep(lerpXLF, lerpXHF, pFract.y);\n\n  return smootherStep(lerpYB, lerpYF, pFract.z);\n}\n\n\n\n// FBM NOISE FUNCTION\nfloat fbm(vec3 p, float octaves) {\n  float amp = 0.5;\n  float freq = 8.0;\n  float sum = 0.0;\n  float maxSum = 0.0;\n  for(float i = 0.0; i < 10.0; ++i) {\n    if(i == octaves)\n    break;\n    maxSum += amp;\n    sum += perlin(p * freq) * amp;\n    amp *= 0.5;\n    freq *= 2.0;\n  }\n  return sum / maxSum;\n}\n\n\n\n// WORLEY NOISE FUNCTION\nfloat worley2D(vec2 p) {\n    vec2 pointInt = floor(p);\n    vec2 pointFract = fract(p);\n    float minDist = 1.0;\n    \n    for (int y = -1; y <= 1; y++) {\n        for (int x = -1; x <= 1; x++) {\n            vec2 neighbor = vec2(float(x), float(y));\n            vec2 point = random2(pointInt + neighbor);\n            point = 0.5 + 0.5 * sin(iTime * 0.01 + 6.2831 * point);  \n            vec2 diff = neighbor + point - pointFract;\n            float dist = length(diff);\n            minDist = min(minDist, dist);\n        }\n    }\n    return minDist;\n}\n\nfloat worley3D(vec3 p) {\n    p *= 0.3;\n    vec3 pointInt = floor(p);\n    vec3 pointFract = fract(p);\n    \n    float minDist = 1.0;\n    \n    for (int z = -1; z <= 1; z++) {\n        for (int y = -1; y <= 1; y++) {\n            for (int x = -1; x <= 1; x++) {\n                vec3 neighbor = vec3(float(x), float(y), float(z));\n                vec3 point = random3(pointInt + neighbor);\n                point = 0.5 + 0.5 * sin(iTime * 1.5 * 0.01 + 6.2831 * point);  \n                vec3 diff = neighbor + point - pointFract;\n                float dist = length(diff);\n                minDist = min(minDist, dist);\n            }\n        }\n    }\n    return minDist;\n}\n\n\n\n// COORDINATE & ROTATION FUNCTIONS\nvoid pR(inout vec2 p, float a)\n{\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvec3 rotatePtY(vec3 pt, float a)\n{    \n    pR(pt.yz, 0.);\n    pR(pt.xz, a);\n    pR(pt.xy, 0.);\n    \n    return pt;\n}\n\nvec3 rotatePtX(vec3 pt, float a)\n{    \n    pR(pt.yz, a);\n    pR(pt.xz, 0.);\n    pR(pt.xy, 0.);\n    \n    return pt;\n}\n\nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\nvoid CoordinateSystem(in vec3 v1, out vec3 v2, out vec3 v3) {\n    if (abs(v1.x) > abs(v1.y)) {\n    \tv2 = vec3(-v1.z, 0.0, v1.x) / sqrt(v1.x * v1.x + v1.z * v1.z);\n    } else {\n    \tv2 = vec3(0.0, v1.z, -v1.y) / sqrt(v1.y * v1.y + v1.z * v1.z);\n    }\n    v3 = cross(v1, v2);\n}\n\nmat3 TangentToWorld(vec3 nor) {\n    vec3 tangent, bitangent;\n    CoordinateSystem(nor, tangent, bitangent);\n    return mat3(tangent, bitangent, nor);\n}\n\n\n\nvoid rayCast(vec3 eye, vec3 ref, vec2 ndc, out vec3 dir) {    \n    float len = tan(3.14159 * 0.125) * distance(eye, ref);\n    vec3 H = normalize(cross(vec3(0.0, 1.0, 0.0), ref - eye));\n    vec3 V = normalize(cross(H, eye - ref));\n    V *= len;\n    H *= len * iResolution.x / iResolution.y;\n    vec3 p = ref + ndc.x * H + ndc.y * V;\n    dir = normalize(p - eye);\n}\n\n\n    \n// SHAPE SDFs\nfloat sphere(vec3 p, float r, vec3 c) {\n\treturn distance(p, c) - r;\n}\n\nfloat cube(vec3 p, vec3 c) {\n    return length(max(abs(p) - c, 0.0));\n}\n\nfloat squarePlane(vec3 p, vec4 n)\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat torus(vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q) - t.y;\n}\n\n\n#define VENUS_SDF\t \tsphere(pos + vec3(0.0, 0., 0.0), 2.0, vec3(-8.0, 0.0, 4.0))\n#define VENUS_ID\t\t1\n#define EARTH_SDF\t\tcube(rotatePtX(rotatePtY(pos + vec3(0.0, 0.3, -0.9), 0.3 * iTime), 0.6), vec3(1.3, 1.3, 1.3))\n#define EARTH_ID\t\t2\n#define MARS_SDF\t\tsphere(pos, 2.5, vec3(12.0, 0.0, -5.5))\n#define MARS_ID\t\t\t3\n#define SATURN_SDF\t\tsphere(pos + vec3(0.0, -1.0, 0.1), 2.0, vec3(16.0, 0.0, -13.0))\n#define SATURN_ID\t\t4\n#define TORUS1_SDF\t\ttorus(rotatePtX(rotatePtY(pos + vec3(-15.9, -1.05, 13.0), -0.8 * iTime), 0.5 * iTime), vec2(2.7, 0.35))\n#define TORUS1_ID\t\t5\n#define TORUS2_SDF\t\ttorus(rotatePtX(rotatePtY(pos + vec3(-16.0, -1.1, 13.0), -0.8), -0.5 * iTime), vec2(3.7, 0.35))\n#define TORUS2_ID\t\t6\n#define NEPTUNE_SDF\t\tsphere(pos + vec3(0.0, -2.5, 0.0), 2.5, vec3(20.0, 0.0, -22.0))\n#define NEPTUNE_ID\t\t7\n#define BACK_SDF \t\tsquarePlane(pos + vec3(-60.0, 0.0, 0.0), vec4(-1., 0., 0., 1.))\n#define BACK_ID \t\t8\n#define LIGHT_SDF\t\tsphere(pos + vec3(0., 0., 0.), 2.0, lightPos)\n#define LIGHT_ID\t\t9\n\n\nvoid sceneMap3D(vec3 pos, out float t, out int obj, vec3 lightPos) {\n    t = VENUS_SDF;\n    obj = VENUS_ID;\n    \n    float t2;\n    if ((t2 = EARTH_SDF) < t) {\n    \tt = t2;\n      \tobj = EARTH_ID;\n    }\n    \n    if ((t2 = MARS_SDF) < t) {\n    \tt = t2;\n      \tobj = MARS_ID;\n    }\n    \n    if ((t2 = SATURN_SDF) < t) {\n    \tt = t2;\n      \tobj = SATURN_ID;\n    }\n    \n    if ((t2 = TORUS1_SDF) < t) {\n    \tt = t2;\n      \tobj = TORUS1_ID;\n    }\n    \n    if ((t2 = TORUS2_SDF) < t) {\n    \tt = t2;\n      \tobj = TORUS2_ID;\n    }\n    \n    if ((t2 = NEPTUNE_SDF) < t) {\n    \tt = t2;\n      \tobj = NEPTUNE_ID;\n    }\n    \n    if ((t2 = BACK_SDF) < t) {\n    \tt = t2;\n      \tobj = BACK_ID;\n    }\n    \n    if ((t2 = LIGHT_SDF) < t) {\n    \tt = t2;\n    \tobj = LIGHT_ID;\n    }\n}\n\n\nfloat sceneMap3D(vec3 pos, vec3 lightPos) {\n    float t = VENUS_SDF;\n    \n    float t2;\n    if ((t2 = EARTH_SDF) < t) {\n    \tt = t2;\n    }\n    \n    if ((t2 = MARS_SDF) < t) {\n    \tt = t2;\n    }\n    \n    if ((t2 = SATURN_SDF) < t) {\n    \tt = t2;\n    }\n    \n    if ((t2 = TORUS1_SDF) < t) {\n    \tt = t2;\n    }\n    \n    if ((t2 = TORUS2_SDF) < t) {\n    \tt = t2;\n    }\n    \n    if ((t2 = NEPTUNE_SDF) < t) {\n    \tt = t2;\n    }\n    \n    if ((t2 = BACK_SDF) < t) {\n    \tt = t2;\n    }\n    \n    if ((t2 = LIGHT_SDF) < t) {\n    \tt = t2;\n    }\n    \n    return t;\n}\n\n\nfloat shadowMap3D(vec3 pos) {\n    float t = VENUS_SDF;\n    \n    float t2;\n    if ((t2 = EARTH_SDF) < t) {\n    \tt = t2;\n    }\n    \n    if ((t2 = MARS_SDF) < t) {\n    \tt = t2;\n    }\n    \n    if ((t2 = SATURN_SDF) < t) {\n    \tt = t2;\n    }\n    \n    if ((t2 = TORUS1_SDF) < t) {\n    \tt = t2;\n    }\n    \n    if ((t2 = TORUS2_SDF) < t) {\n    \tt = t2;\n    }\n    \n    if ((t2 = NEPTUNE_SDF) < t) {\n    \tt = t2;\n    }\n    \n    if ((t2 = BACK_SDF) < t) {\n    \tt = t2;\n    }\n    \n    return t;\n}\n\n\nvec3 computeNormal(vec3 pos, vec3 lightPos) {\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( sceneMap3D(pos + epsilon.yxx, lightPos) - sceneMap3D(pos - epsilon.yxx, lightPos),\n                            sceneMap3D(pos + epsilon.xyx, lightPos) - sceneMap3D(pos - epsilon.xyx, lightPos),\n                            sceneMap3D(pos + epsilon.xxy, lightPos) - sceneMap3D(pos - epsilon.xxy, lightPos)));\n}\n\n\nvec3 WorlyTangentSpaceNormal(vec3 pos) {\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize(vec3(worley3D(pos + epsilon.yxx) - worley3D(pos - epsilon.yxx),\n                          worley3D(pos + epsilon.xyx) - worley3D(pos - epsilon.xyx),\n                          worley3D(pos + epsilon.xxy) - worley3D(pos - epsilon.xxy)));\n}\n\n\nvec3 FbmTangentSpaceNormal(vec3 pos, float a) {\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize(vec3(fbm(pos + epsilon.yxx, a) - fbm(pos - epsilon.yxx, a),\n                          fbm(pos + epsilon.xyx, a) - fbm(pos - epsilon.xyx, a),\n                          fbm(pos + epsilon.xxy, a) - fbm(pos - epsilon.xxy, a)));\n}\n\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj, vec3 lightPos) {\n    t = 0.001;\n    \n    for (int i = 0; i < RAY_STEPS; ++i) {\n    \tvec3 pos = origin + t * dir;\n        float m; // Minimum distance from this point to an object in the scene\n        sceneMap3D(pos, m, hitObj, lightPos);\n        if (m < 0.01) {\n        \treturn;\n        }\n        t += m;\n    }\n\t// We hit nothing\n    t = -1.0;\n    hitObj = -1;\n}\n\n\nfloat fiveTapAO(vec3 p, vec3 n, float k) {\n    float aoSum = 0.0;\n    for(float i = 0.0; i < 5.0; ++i) {\n        float coeff = 1.0 / pow(2.0, i);\n        aoSum += coeff * (i * AO_DIST - shadowMap3D(p + n * i * AO_DIST));\n    }\n    return 1.0 - k * aoSum;\n}\n\n\nfloat softShadow(vec3 dir, vec3 origin, float min_t, float k) {\n    float res = 1.0;\n    float t = min_t;\n    for(int i = 0; i < RAY_STEPS; ++i) {\n        float m = shadowMap3D(origin + t * dir);\n        if(m < 0.0001) {\n            return 0.0;\n        }\n        res = min(res, k * m / t);\n        t += m;\n    }\n    return res;\n}\n\n\nfloat subsurfaceColor(vec3 lightDir, vec3 n, vec3 view, float thin) {\n\tvec3 scatterDir = lightDir + n * DISTORTION;\n\tfloat lightReachingEye = pow(clamp(dot(view, -scatterDir), 0.0, 1.0), GLOW) * BSSRDF_SCALE;\n\tfloat attenuation = max(0.0, dot(n, lightDir) + dot(view, -lightDir));\n    float totalLight = attenuation * (lightReachingEye + AMBIENT) * thin;\n    return totalLight;\n}\n\n\nvec3 computeMaterial(int hitObj, vec3 p, vec3 n, vec3 light, vec3 view, float thin) {\n    vec3 worley_normal = WorlyTangentSpaceNormal(p);\n    worley_normal = TangentToWorld(n) * worley_normal;\n    float worleyLambert = dot(light, worley_normal);\n    \n    vec3 fbm_normal = FbmTangentSpaceNormal(p, 4.0);\n    fbm_normal = TangentToWorld(n) * fbm_normal;\n    float fbmLambert = dot(light, fbm_normal);\n    \n    float lambert = max(0.0, dot(n,light));\n    \n    switch(hitObj) {\n        // Sphere 1\n        case VENUS_ID:\n        vec3 color1 = vec3(1.0,0.88,0.7) * vec3(1.0,0.7,0.4) * palette(fbm(p * sin(iTime * 0.05),4.0),av,bv,cv,dv) * softShadow(light,p,0.1,6.0);\n        return color1 + vec3(0.0,0.2,1.0) * subsurfaceColor(light,n,view,thin) * vec3(1.0,0.88,0.7);\n        break;\n        // Sphere 2\n        case EARTH_ID:\n        return palette(perlin(p),ae,be,ce,de) * softShadow(light,p,0.1,6.0);\n        break;\n        // Sphere 3\n        case MARS_ID:\n        vec3 color2 = vec3(0.6,0.5,0.5) * palette(worley3D(p * sin(iTime * 0.2) * 2.3),am,bm,cm,dm) * softShadow(light,p,0.1,6.0);\n        return color2 + vec3(0.2,0.8,0.5) * subsurfaceColor(light,n,view,thin);\n        break;\n        // Sphere 4\n        case SATURN_ID:\n        return vec3(0.9,0.9,0.9) * palette(fbm(p * sin(iTime * 0.05),4.) * 1.65,as,bs,cs,ds) * softShadow(light,p,0.1,6.0);\n        break;\n        // Torus 1\n        case TORUS1_ID:\n        vec3 color3 = vec3(0.3,0.1,0.8) * vec3(0.7,0.2,0.8) * lambert * softShadow(light,p,0.1,6.0);\n        return color3 + vec3(1.0,0.5,0.3) * subsurfaceColor(light,n,view,thin) * vec3(1.0,0.88,0.7);\n        break;\n        // Torus 2\n        case TORUS2_ID:\n        vec3 color4 = vec3(1.0,0.88,0.8) * vec3(0.9,0.2,0.8) * lambert * softShadow(light,p,0.1,6.0);\n        return color4 + vec3(1.0,0.7,0.3) * subsurfaceColor(light,n,view,thin) * vec3(1.0,0.88,0.7);\n        break;\n        // Sphere 5\n        case NEPTUNE_ID:\n        vec3 color5 = vec3(0.4,0.8,1.6) * vec3(1.0,0.4,0.8) * palette(lambert,av,bv,cv,dv) * softShadow(light,p,0.1,6.0) * worley3D(p);\n        return color5 + vec3(1.0,0.0,0.8) * subsurfaceColor(light,n,view,thin) * vec3(1.0,0.88,0.7) * worley3D(p);\n        break; \n        // BACKGROUND\n        case BACK_ID:\n        return vec3(0.0, 0.3, 0.4) * palette(worleyLambert,as,bs,cs,ds);\n        break;\n        // Light\n        case LIGHT_ID:\n        return vec3(1.0, 0.88, 0.7);\n        break;\n        // Background\n        case -1:\n        return vec3(0.0);\n        break;\n    }\n    return vec3(1.0);\n}\n\n\nIntersection sdf3D(vec3 dir, vec3 eye, vec3 lightPos) {\n\tfloat t;\n    int hitObj;\n    march(eye, dir, t, hitObj, lightPos);\n    \n    vec3 isect = eye + t * dir;\n    vec3 nor = computeNormal(isect, lightPos);\n    vec3 lightDir = normalize(lightPos - isect);\n    float thickness = fiveTapAO(isect, -nor, AO_KVAL);\n        \n    vec3 surfaceColor = computeMaterial(hitObj, isect, nor, lightDir, normalize(eye - isect), thickness);\n        \n    return Intersection(t, surfaceColor, isect, hitObj);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec3 lightPos = rotateY(vec3(30.0, 4.0, -22.0), iTime * 0.5);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // Convert to range [-1,1]\n    uv = uv * 2.0 - vec2(1.0, 1.0);\n    \n    vec3 eye = rotateY(vec3(0.0, 0.0, 15.0), sin(30.0) * 3.14159 * 0.5);\n    vec3 ref = vec3(0, 0, 0);\n    vec3 rayDir;\n    \n    rayCast(eye, ref, uv, rayDir);\n    \n    Intersection isect = sdf3D(rayDir, eye, lightPos);\n\n    // Output to screen\n    fragColor = vec4(isect.color, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3s2yRt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sBBDV", "name": "twinkle starfield", "author": "TheNosiriN", "description": "something simple I managed to do for a game", "tags": ["2d", "random", "space", "stars", "starfield", "twinkle"], "likes": 5, "viewed": 392, "date": "1590801618", "time_retrieved": "2024-06-20T20:06:33.462082", "image_code": "#define RES 0.2\n\n\n// perlin noise from: https://www.shadertoy.com/view/4sc3z2\n#define MOD3 vec3(.1031,.11369,.13787)\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\nfloat perlin_noise(vec3 p)\n{\n    vec3 pi = floor(p);\n    vec3 pf = p - pi;\n    \n    vec3 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    return \tmix(\n        \t\tmix(\n                \tmix(dot(pf - vec3(0, 0, 0), hash33(pi + vec3(0, 0, 0))), \n                        dot(pf - vec3(1, 0, 0), hash33(pi + vec3(1, 0, 0))),\n                       \tw.x),\n                \tmix(dot(pf - vec3(0, 0, 1), hash33(pi + vec3(0, 0, 1))), \n                        dot(pf - vec3(1, 0, 1), hash33(pi + vec3(1, 0, 1))),\n                       \tw.x),\n                \tw.z),\n        \t\tmix(\n                    mix(dot(pf - vec3(0, 1, 0), hash33(pi + vec3(0, 1, 0))), \n                        dot(pf - vec3(1, 1, 0), hash33(pi + vec3(1, 1, 0))),\n                       \tw.x),\n                   \tmix(dot(pf - vec3(0, 1, 1), hash33(pi + vec3(0, 1, 1))), \n                        dot(pf - vec3(1, 1, 1), hash33(pi + vec3(1, 1, 1))),\n                       \tw.x),\n                \tw.z),\n    \t\t\tw.y);\n}\n\n\nfloat hash21(vec2 p)\n{\n \tp = fract( p*vec2(123.34, 456.21) );\n    p += dot(p, p+45.32);\n    return fract(p.x*p.y);\n}\n\n\nfloat star(vec2 p, float time)\n{\n\tfloat d = length(p);\n    float m = (max(0.2, abs(sin(time))) * 0.02) / d;\n    \n    m *= smoothstep(1.0, 0.2, d);\n    \n    return m;\n}\n\n\nvec3 starField(vec2 uv)\n{\n    vec3 col = vec3(0);\n    \n    vec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n    \n    for (int x=-1; x<=1; x++){\n        for (int y=-1; y<=1; y++)\n        {\n            vec2 offset = vec2(x, y);\n            \n            float n = hash21(id + offset);\n            float star = star(gv - offset - (vec2(n, fract(n*100.0)) - 0.5), iTime*fract(n*135.246));\n            float size = min(1.0, fract(n*1234.567) + 0.1);\n            \n            col += star * size;\n        }\n    }\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy/iResolution.y)/RES;\n    vec3 coords = vec3(vec2(uv.x, uv.y + iTime*0.03), iTime*0.3);\n    \n    \n    vec3 stars = starField( vec2(coords.x, coords.y)*5.0 );\n    \n    \n    float warpAmplitude = 10.0;\n   \tfloat warpFrequency = 0.04;\n    \n    vec3 clouds = vec3( perlin_noise(coords) ) * 0.3;\n    \n    vec3 cloudsCol = 0.5 + 0.5*cos((coords*2.0)+vec3(0,3,9)); //color\n    clouds *= cloudsCol;\n    stars *= cloudsCol*2.0;\n    stars *= clouds+0.5;\n    vec3 col = clouds + stars;\n   \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sBBDV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sBBDw", "name": "menger triprism-02", "author": "jorge2017a1", "description": "menger triprism", "tags": ["mengertriprism"], "likes": 1, "viewed": 75, "date": "1590115493", "time_retrieved": "2024-06-20T20:06:33.462082", "image_code": "//modificado por jorge flores.p --\n//Gracias a ....Created by russ in 2017-03-06\n//https://www.shadertoy.com/view/XsfczB\n    \n\nconst int iter =100;\nconst float eps = 0.001, far = 20.;\nvec3 lDir0 = normalize(vec3(1,2,1)), lDir1 = normalize(vec3(-1,1.0,-2));\nvec3 lCol0 = vec3(1,.8,.5), lCol1 = vec3(.6,0.8,1); \n\n\n#define PI 3.1415926\n\n///-------------------------------------\nconst int MAX_RAY_STEPS = 64;\nconst float RAY_STOP_TRESHOLD = 0.0001;\nconst int MENGER_ITERATIONS = 5;\n///-------------------------------------\n\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\n\n\n\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n\nfloat sdCrossHex( in vec3 p )\n{\n    \n    float sdfin=1000.0;\n    \n    float sdt1= sdTriPrism( p- vec3(0.0), vec2(1.0) );\n    float sdt2= sdTriPrism( -p.xyz- vec3(0.0), vec2(0.5,1.2) );\n    float sdt3= sdTriPrism( p.xzy- vec3(0.0), vec2(0.5,1.2) );\n    \n    sdfin =max(sdt1, -sdt2);\n    sdfin =max(sdfin, -sdt3);\n    \n    return sdfin;\n     \n}\n\n\n\nfloat sdCross(vec3 p) {\n\tp = abs(p);\n\tvec3 d = vec3(max(p.x, p.y),\n\t\t\t\t  max(p.y, p.z),\n\t\t\t\t  max(p.z, p.x));\n\treturn min(d.x, min(d.y, d.z)) - (1.0 / 3.0);\n}\n\nfloat sdCrossRep(vec3 p) {\n\tvec3 q = mod(p + 1.0, 2.0) - 1.0;\n\treturn sdCrossHex(q);\n}\n\nfloat sdCrossRepScale(vec3 p, float s) {\n\treturn sdCrossRep(p * s) / s;\t\n}\n\n\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\n\n//--------------------------\nfloat DE(vec3 p) {\n\t\n    \n   \n    float scale = 4.0;\n\t\n    float dist=sdTriPrism( p-vec3(0.0), vec2(1.0,1.0) );\n    \n \n\tfor (int i = 0; i < MENGER_ITERATIONS; i++) {\n\t\tdist = max(dist, -sdCrossRepScale(p, scale));\n\t\tscale *= 3.0;\n\t}\n\n\n    \n    \n\treturn dist;\n}\n\n//oooooooooooooooooooooooooooooooooooooooooooooooooooo\n\n\n\nvec2 march(vec3 ro, vec3 rd){\n\tfloat t=0. , d = far, it = 0.;\n    for (int i=0;i<iter;i++){\n     \tt += (d = DE(ro+t*rd));\n        if(d<eps || t> far) break;\n        it += 1.;\n    }\n    return vec2(t,it/float(iter));\n}\n\nfloat getShadow(vec3 p, vec3 n, vec3 ld){\n    p +=  2. * eps * n;\n    float t=0.,d=far;\n    for(int i=0;i<50;i++){\n        t += (d=DE(p + t*ld));\n        if (d<eps || t>3.) break;\n    }\n    return t<=3. ? 0.1 : 1. ;\n}\n\nvec3 getRay(vec3 ro, vec3 look, vec2 uv){\n    vec3 f = normalize(look - ro);\n    vec3 r = normalize(vec3(f.z,0,-f.x));\n    vec3 u = cross (f,r);\n    return normalize(f + uv.x * r + uv.y * u);\n}\n\nvec3 getNorm(vec3 p){\n    vec2 e = vec2(eps, 0);\n    return normalize(vec3(DE(p+e.xyy)-DE(p-e.xyy),DE(p+e.yxy)-DE(p-e.yxy),DE(p+e.yyx)-DE(p-e.yyx)));\n}\n\nvec3 light(vec3 p, vec3 n){\n    vec3 col = vec3(0.01);\n    for(int i=0;i<2;i++){\n        vec3 ld = (i==0) ? lDir0 : lDir1;\n        float diff = max(dot(n, (ld)),0.);\n        diff *= getShadow(p, n, ld);\n        col += diff * (i==0 ? lCol0 : lCol1);\n    }\n    return col * .7;\n}\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) {\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float time = iTime * 0.5;\n    float t = iTime * 0.5;\n    //float time = iTime * .06;\n    \n    \n\tvec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n  \n    vec3 ro = vec3(1.0+cos(t*1.5), 1.0+0.25*sin(t), 1.0+sin(iTime*0.5) );\n  \n     ro = get_mouse(ro);\n   \n    \n    vec3 rd = getRay(ro, vec3(0.), uv);\n    vec2 hit = march(ro, rd);\n    vec3 p = ro + hit.x*rd;\n    \n    vec3 col = hit.x<far ? light(p, getNorm(p)) : vec3(.1*(1.-length(uv)));\n    \n    \n    col += pow(hit.y,3.);\n\tfragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sBBDw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sBBRc", "name": "accidental effect", "author": "mailko", "description": "processing shadow have some problem.but it is look not bad.keep it to record. can be some special effect?", "tags": ["special"], "likes": 2, "viewed": 52, "date": "1590483830", "time_retrieved": "2024-06-20T20:06:33.468296", "image_code": "#define MAX_MARCHING_STEP 255\n#define MIN_DIST 0.0\n#define MAX_DIST 100.0\n#define EPSILON 0.00001\n\n\n//ç©éµç¸å³\nmat4 rotateY_invert(float theta){\n\tfloat c = cos(-theta);\n    float s = sin(-theta);\n    return mat4(\n    \tvec4(c, 0, s, 0),\n        vec4(0, 1, 0, 0),\n        vec4(-s, 0, c, 0),\n        vec4(0, 0, 0, 0)\n    );\n}\n\nmat4 transform_invert(vec3 movement){\n\treturn mat4(\n    \tvec4(1, 0, 0, 0),\n        vec4(0, 1, 0, 0),\n        vec4(0, 0, 1, 0),\n        vec4(-movement, 0)\n    );\n}\n\nfloat sphereSDF(vec3 p){\n    return length(p) - 1.0;\n}\n\nfloat torusSDF(vec3 p){\n    vec2 t = vec2(1.0, 0.4);\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n  \treturn length(q)-t.y;\n}\n\nfloat planeSDF(vec3 p, vec4 n){\n\treturn dot(p, n.xyz) + n.w;\n}\nfloat boxSDF(vec3 p, vec3 b)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n\nfloat sceneSDF(vec3 p){\n    vec3 torusP = (rotateY_invert(1.0) * transform_invert(vec3(0.5, 0, 0)) * vec4(p, 1.0)).xyz;\n    return unionSDF(\n        differenceSDF(sphereSDF(p), torusSDF(torusP)),\n        planeSDF(p, vec4(0.0, 1.0, 0.0, 1.0))\n    );\n}\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end){\n\tfloat depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEP; i++){\n       \tfloat dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON){\n        \treturn depth;\n        }\n        depth += dist;\n        if(depth >= end){\n        \treturn end;\n        }\n    }\n    return end;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord){\n\tvec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up){\n\tvec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n    \tvec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n}\n    \n\nvec3 estimateNormal(vec3 p){\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye, vec3 lightPos, vec3 lightIntensity)\n{\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    float dotLN = clamp(dot(L, N), 0.0, 1.0);\n    float dotRV = clamp(dot(R, V), 0.0, 1.0);\n\treturn lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));    \n}\n\nfloat shadow(vec3 lightPos, vec3 p)\n{\n    vec3 dir = normalize(p - lightPos);\n    float maxDistance = length(p - lightPos);\n    for(float t = 0.0; t < maxDistance;)\n    {\n        float h = sceneSDF(lightPos + dir * t);\n        if(h < EPSILON)\n            return 0.0;\n        t += h;\n    }\n    return 1.0;\n}\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye){\n\tconst vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    vec3 lightPos = vec3(4.0 * sin(iTime),\n                         2.0,\n                         4.0 * cos(iTime));\n    vec3 lightIntensity = vec3(0.4, 0.4, 0.4);\n    float shadow = shadow(lightPos, p);\n    color += phongContribForLight(k_d, k_s, alpha, p, eye, lightPos, lightIntensity) * shadow;\n    \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0, 5.0, 5.0);\n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    if(dist > MAX_DIST - EPSILON){\n    \tfragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        return;\n    }\n    \n    vec3 K_a = vec3(0.3, 0.3, 0.3);\n    vec3 K_d = vec3(0.7, 0.2, 0.2);\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 p = eye + dist * worldDir;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sBBRc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sBBRh", "name": "Tetration in the Complex plane", "author": "enslow", "description": "This fractal is generated in the complex plane by computing the N-th tetration at each point.\nI would love some advice on how to improve my code, especially the coloring so I can continue to improve :). Thank you for reading", "tags": ["fractal", "tetration", "3b1b"], "likes": 3, "viewed": 122, "date": "1589422966", "time_retrieved": "2024-06-20T20:06:33.868060", "image_code": "//The argument function takes in parameters of a+bi\n//References:\n//\n//http://paulbourke.net/fractals/tetration/\n//3Blue1Brown: https://youtu.be/elQVZLLiod4?t=2558\t\n\n\n#define pi 3.14159\n#define CENTER vec2(0.5,.217708)\n//#define CENTER vec2(-1.296537,.0021708)\n#define LOOP 23.15\n\n//Thank you mla!\nint AA = 16;\n\n//Returns angle of p where p = p.x + p.y*i\nfloat arg(vec2 p)\n{\n    return atan(p.y,p.x);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = exp(10.*pow(sin(pi/2.*iTime/LOOP),2.));\n    \n    \n    //resize window and number of iterations\n    int N = 40+int(log(t/2.0)*log(t/2.0));\n    \n    \n    //background gradient\n    vec3 col;\n    vec3 fcol;\n    for (int k=0;k<AA;k++)\n    {\n        for (int j=0;j<AA;j++)\n        {\n            //temporary variables\n            vec2 uv = 3.0 * (2.0 * fragCoord.xy + vec2(k,j)/float(AA)-iResolution.xy)/iResolution.y / t+CENTER;\n            vec2 p = uv;\n            col = vec3((uv.x+3.)/10.,0.4,0.5);\n            float c;\n            float m;\n            for (int i=0;i<N;i++)\n            {\n                //complex exponentiation\n                c = pow(length(uv),p.x)*exp(-p.y*arg(uv));\n                //m = p.y*log(length(uv))+p.x*arg(uv);\n                m = p.y*0.5*log(dot(uv,uv))+p.x*arg(uv);\n                p.x = cos(m);\n                p.y = sin(m);\n                p *= c;\n\n                //compute color based on magnitude\n                if (length(p) > 500.)\n                {\n                    float f = float(i)/20.;    \n                    fcol += abs(vec3((sin(f+1.57)),sin(f+0.4),sin(1.2*(f+0.5))))*0.85;          \n                    break;\n                }\n            }\n        }\n    }\n    fcol /= float(AA*AA);\n    \n    fragColor = vec4(mix(col,fcol,0.4),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sBBRh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sBBRw", "name": "Abstract galaxy", "author": "mrange", "description": "License CC0: Abstract Galaxy\nBeen working on scifi shaders, while this is not \"realistic\" looking I find it nice to look at\n", "tags": ["2d", "fbm"], "likes": 2, "viewed": 194, "date": "1589660626", "time_retrieved": "2024-06-20T20:06:34.601582", "image_code": "// License CC0: Abstract Galaxy\n//\tBeen working on scifi shaders, while this is not \"realistic\" looking I find it nice to look at\n#define PI           3.141592654\n#define TAU          (2.0*PI)\n\n#define TIME         (iTime*0.2)\n#define RESOLUTION   iResolution\n\n#define LESS(a,b,c) mix(a,b,step(0.,c))\n\n#define SABS(x,k)    LESS((.5/k)*x*x+k*.5,abs(x),abs(x)-k)\n\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return p.x*vec2(cos(p.y), sin(p.y));\n}\n\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\nfloat noise1(vec2 p) {\n  float s = 1.0;\n\n  p *= tanh(0.1*length(p));\n\n  float a = cos(p.x);\n  float b = cos(p.y);\n\n  float c = cos(p.x*sqrt(3.5));\n  float d = cos(p.y*sqrt(1.5));\n\n  return a*b*c*d;\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nfloat galaxy(vec2 p, float a, float z) {\n  vec2 pp = toPolar(p);\n  pp.y += pp.x*3.0 + a;\n  p = toRect(pp);\n  \n  p *= z;\n  \n  return noise1(p);\n}\n\nfloat height(vec2 p) {\n  p *= 0.75;\n  float s = 0.0;\n  float a = 1.0;\n  float f = 15.0;\n  float d = 0.0;\n  for (int i = 0; i < 3; ++i) {\n    float g = a*galaxy(p, -0.5*TIME + TIME*(0.2*pow(float(i), 1.0)), f);\n    s += g;\n    a *= sqrt(0.5);\n    f *= sqrt(2.0);\n    d += a;\n  }\n  \n  float l = length(p);\n  \n  return SABS((-0.25+ s/d), 0.5)*exp(-5.5*l*l);\n}\n\nvec3 normal(vec2 p) {\n  vec2 eps = vec2(0.000125, 0.0);\n  \n  vec3 n;\n  \n  n.x = height(p - eps.xy) - height(p + eps.xy);\n  n.y = 2.0*eps.x;\n  n.z = height(p - eps.yx) - height(p + eps.yx);\n  \n  return normalize(n);\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n \n  vec3 lp1 = vec3(-2.0, 0.5, 2.0);\n  vec3 ld1 = normalize(lp1 - vec3(p.x, 0.0, p.y));\n  vec3 lp2 = vec3(2.0, 0.5, 2.0);\n  vec3 ld2 = normalize(lp2 - vec3(p.x, 0.0, p.y));\n\n  float l = length(p);\n  float tl = tanh(l);\n\n  float h = height(p);\n  float th = tanh(h);\n  vec3 n = normal(p);\n  \n  float diff1 = max(dot(ld1, n), 0.0);\n  float diff2 = max(dot(ld2, n), 0.0);\n\n  vec3 col = vec3(0.0);\n  col += vec3(0.5, 0.5, 0.75)*h;\n  col += 0.5*pow(diff1, 10.0);\n  col += 0.25*pow(diff2, 2.0);\n  col += pow(vec3(0.5)*h, n.y*1.75*(mix(vec3(0.5, 1.0, 1.5), vec3(0.5, 1.0, 1.5).zyx, 1.25*tl)));\n  col += 0.9*vec3(1.0, 0.9, 0.75)*exp(-10.0*l*l);\n\n  col = postProcess(col, q);\n\n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc0-1.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sBBRw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sBBzG", "name": "Hypnosis Trippy", "author": "workingclasshacker", "description": "Just messing around with trig functions. kinda neat :)", "tags": ["trig"], "likes": 1, "viewed": 230, "date": "1590234970", "time_retrieved": "2024-06-20T20:06:34.734751", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ((fragCoord-.5*iResolution.xy)/iResolution.y);\n\tuv *= sin(iTime/5.);\n    // Time varying pixel color\n    float p = 2.;\n    vec3 x = iTime/15.+vec3(sin(iTime)*.002+length((uv)/20.));\n    \n    vec3 f = cos(pow(x,vec3(p)))+sin(x*2000.)-cos(x*5215.);\n    vec3 f2 = cos(pow(x,vec3(p)))+sin(x*200.)-cos(x*5225.);\n    vec3 col = 0.5 + 0.5 * f*.2;\n    vec3 col2 = 0.5 + 0.5 * f2*.5;\n\tcol = mod(col, 2.);\n    col2 = mod(col2, 2.);\n    // Output to screen\n    fragColor = vec4(col.r-col2.r*.31, col.g*.4-col2.g, col2.z,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sBBzG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sBBzw", "name": "Test Camera", "author": "ibragim_aghdabi", "description": "work and progress", "tags": ["zoom"], "likes": 1, "viewed": 41, "date": "1589667676", "time_retrieved": "2024-06-20T20:06:34.734751", "image_code": "float DistLine(vec3 ro, vec3 rd, vec3 p) {\n\treturn length(cross(p-ro, rd))/length(rd);\n}\n\nfloat DrawPoint(vec3 ro, vec3 rd, vec3 p){\n    float d = DistLine(ro, rd, p);\n    d = smoothstep(.06, .05, d);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float t = iTime; \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3 (3.*sin(t), 2.,-3.*cos(t));  // ro - Ray origin, cam up\n    \n    vec3 lookat = vec3(.5);\n    \n    float zoom = 1.;\n    \n    vec3 f = normalize(lookat-ro);   // f - forward vector\n    vec3 r = cross(vec3(0., 1., 0.), f);   // r - right vec\n    vec3 u = cross(f,r);   // u- up vector\n    \n    vec3 c = ro + f*zoom;  // c- center\n    vec3 i = c+ uv.x*r + uv.y*u;   // i - intersection\n    vec3 rd = i-ro;\n    \n  \n    \n    \n    float d = 0.;\n    \n    d += DrawPoint(ro, rd, vec3(0., 0., 0.));\n    d += DrawPoint(ro, rd, vec3(0., 0., 1.));\n    d += DrawPoint(ro, rd, vec3(0., 1., 0.));\n    d += DrawPoint(ro, rd, vec3(0., 1., 1.));\n    d += DrawPoint(ro, rd, vec3(1., 0., 0.));\n    d += DrawPoint(ro, rd, vec3(1., 0., 1.));\n    d += DrawPoint(ro, rd, vec3(1., 1., 0.));\n    d += DrawPoint(ro, rd, vec3(1., 1., 1.));\n   \n \n\n    // Output to screen\n    fragColor = vec4(d);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sBBzw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sBfDR", "name": "Water Falling", "author": "dr2", "description": "Dynamic version of Escher's \"Waterval\" - a source of perpetual energy.", "tags": ["illusion", "escher", "penrose", "paradox"], "likes": 29, "viewed": 472, "date": "1589795161", "time_retrieved": "2024-06-20T20:06:37.631975", "image_code": "// \"Water Falling\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Started from the simplified image in NuSan's \"Waterfall\" and borrowed the main \n  geometrical features; new version includes motion, color and transparency, and\n  other visual changes (cf. original).\n  \n  Use the mouse to see how the scene is built; however, there is only one correct\n  view; note the parallel projection, and the shifting / duplication / truncation\n  of certain elements. Click in corners for alternative images.\n*/\n\n#define AA  0    // optional antialiasing (slow)\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h);\nfloat PrRoundFlatCylAnDf (vec3 p, float rhi, float rlo, float w, float h, float rc);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nvec2 Rot2D (vec2 q, float a);\nfloat Noisefv2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 qHit, sunDir, vuDir, vuPln;\nfloat dstFar, tCur, flDir;\nbool isMono, isPoly;\nint idObj;\nconst int idWChan = 1, idWWhl = 2, idMBldg = 3, idRBldg = 4, idFBldg = 5, idLBldg = 6,\n   idStair = 7, idFenc = 8, idUBldg = 9, idUBldgX = 10, idRoof = 11, idPilr = 12,\n   idPlat = 13, idTop = 14, idArch = 15, idWater = 16;\nfloat pi = 3.14159;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat UBldgDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, rc, rs;\n  rs = sin (4. * pi * p.x);\n  q = p - vec3 (-8., 3., -3.);\n  d = PrBoxDf (q, vec3 (5., 8., 3.));\n  d = max (d, - PrBoxDf (q - vec3 (-5.4, 2.2, -1.8), vec3 (1., 1.5, 0.7)));\n  d = max (d, - PrBoxDf (q - vec3 (-5.5, 2.8, 1.), vec3 (1., 0.8, 1.2)));\n  d = max (d, - PrBoxDf (q - vec3 (-3., 5.3, -3.5), vec3 (1.2, 0.5, 1.)));\n  q.z = - abs (q.z);\n  rc = dot (vec2 (q.y - 8. - 0.02 * rs, q.z), vec2 (-0.4, 0.2));\n  d = max (d, - rc);\n  DMINQ (idUBldg);\n  d = max (abs (rc) - 0.04, PrBox2Df (q.xz, vec2 (5.5, 3.5)));\n  DMINQ (idRoof);\n  q = p - vec3 (-12., 11.7, -4.3);\n  d = 0.7 * PrBoxDf (q, vec3 (vec2 (0.6 - 0.15 * smoothstep (-0.2, 0.2, q.y)), 1.5).xzy);\n  DMINQ (idUBldgX);\n  q.z = - abs (q.z);\n  d = max (abs (dot (vec2 (q.y - 1.95 - 0.02 * rs, q.z), vec2 (-0.7, 0.7))) - 0.04,\n     PrBox2Df (q.xz, vec2 (0.7)));\n  DMINQ (idRoof);\n  return dMin;\n}\n\nfloat SpltBldgDf (vec3 p, float zHi, float dMin)\n{\n  vec3 q;\n  vec2 s1, s2, b1, b2;\n  float d;\n  s1 = vec2 (-9., -6.);\n  s2 = vec2 (-13.5, -4.);\n  b1 = vec2 (5.5, 8.5);\n  b2 = vec2 (3., 6.5);\n  q = p;\n  d = min (PrBoxDf (q - vec3 (s1, -0.5).xzy, vec3 (b1, 4.2).xzy),\n     PrBoxDf (q - vec3 (s2, 2.8).xzy, vec3 (b2, 0.9).xzy));\n  d = max (d, - PrFlatCylDf ((q - vec3 (-6.7, -1.5, -13.3)).yxz, 2., 1.7, 2.));\n  q.x -= -16.5;\n  d = max (d, - min (PrBox2Df (q.xy, vec2 (2., 3.3 - 0.8 * q.x)),\n     max (PrBox2Df (q.xy, vec2 (2., 3.4)), 0.2 - abs (mod (q.z + 1., 2.) - 1.))));\n  d = max (d, zHi);\n  DMINQ (idMBldg);\n  q = p - vec3 (-19.5, -5., -4.);\n  d = min (d, max (PrBoxDf (q, vec3 (5., 4., 5.)),\n     - PrBoxDf (q - vec3 (0., 4.2, 0.), vec3 (4.5, 0.8, 4.5))));\n  q.y -= 3.1;\n  q.xz = abs (q.xz) - 2.1;\n  d = min (d, PrRoundBoxDf (q, vec3 (0.8, 0., 0.8), 1.));\n  d = max (d, zHi);\n  DMIN (idLBldg);\n  q = p;\n  d = min (PrCylDf (vec3 (mod (q.xz + 0.5, 1.) - 0.5, q.y - 4.5), 0.14, 0.8),\n     max (abs (mod (q.y - 0.55, 0.7) - 0.35) - 0.05, abs (q.y - 4.7) - 0.8));\n  d = max (d, abs (min (PrBox2Df (q.xz - s1, b1 - 0.5),\n     PrBox2Df (q.xz - s2, b2 - 0.5))) - 0.15);\n  d = max (d, - PrBox2Df (q.xz - vec2 (-2., -10.), vec2 (4., 1.4)));\n  d = max (d, zHi);\n  DMIN (idFenc);\n  return dMin;\n}\n\nfloat StairDf (vec3 p, float st, float w, float h)\n{\n  return 0.7 * max ((st + p.y - p.z - abs (mod (p.y + p.z, 2. * st) - st) / sqrt(2.)),\n     max (abs (p.x) - w, max (abs (p.y) - h, abs (p.z) - h)));\n}\n\nfloat FBldgDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  q = p - vec3 (3.4, 0.5, -15.);\n  d = max (PrBoxDf (q, vec3 (3.4, 3.2, 4.)),\n     - PrBoxDf (q - vec3 (0., 4.7, 0.), vec3 (2.9, 2., 3.5)));\n  d = min (d, PrRoundBoxDf (q - vec3 (0., 2.4, 0.), vec3 (0.9, 0., 1.5), 1.));\n  d = max (d, - PrBoxDf (q - vec3 (-3.4, 1.3, -1.6), vec3 (0.5, 0.7, 0.5)));\n  d = max (d, - PrFlatCylDf ((q - vec3 (-2., -0.8, 2.2)).yzx, 1.7, 1., 2.));\n  DMIN (idRBldg);\n  q = p - vec3 (3., 0.7, -22.);\n  d = max (PrBoxDf (q, vec3 (3.5, 6.2, 3.5)),\n     - PrBoxDf (q - vec3 (0., 7.2, 0.), vec3 (3, 1.5, 3)));\n  d = max (d, - PrBoxDf (q - vec3 (-3.4, 3.8, 0.5), vec3 (0.5, 1., 1.)));\n  DMIN (idRBldg);\n  q = p - vec3 (-10., -5., -26.);\n  d = max (PrBoxDf (q, vec3 (20., 4., 15.)),\n     - min (PrBoxDf (q - vec3 (-4., 5.5, 10.5), vec3 (10., 2.5, 4.)),\n     PrBoxDf (q - vec3 (1.5, 6., -3.), vec3 (7., 5., 9.))));\n  DMIN (idFBldg);\n  q = p - vec3 (-2.5, -2.6, -22.2);\n  d = min (StairDf (q, 0.35, 0.8, 2.), StairDf (q - vec3 (-2., 1.3, 7.), 0.35, 0.4, 2.));\n  DMIN (idStair);\n  return dMin;\n}\n\nfloat IcoDodDf (vec3 p, float typ)\n{\n  vec3 q, dv, vc;\n  float cp, sp, scl;\n  scl = 1.2;\n  p /= scl;\n  cp = cos (pi / 5.);\n  sp = sqrt (0.75 - cp * cp);\n  vc = vec3 (-0.5, - cp, sp);\n  for (int j = 0; j < 5; j ++) {\n    p.xy = abs (p.xy);\n    p -= 2. * min (0., dot (p, vc)) * vc;\n  }\n  q = p - ((typ < 0.) ? normalize (vec3 (sp, 0., 0.5)) : normalize (vec3 (0., sp, cp)));\n  dv = vec3 (length (q - min (0., q.x) * vec3 (1., 0., 0.)), \n     length (q - min (0., q.y) * vec3 (0., 1., 0.)),\n     length (q - min (0., dot (q, vc)) * vc));\n  return scl * (Minv3 (dv) - 0.15);\n}\n\nfloat WatChanDf (vec3 p, float dMin)\n{\n  vec3 q, qq;\n  vec2 b;\n  float d, dw, s;\n  b = vec2 (-5.);\n  q = p - vec3 (0., 3., -10.);\n  qq = q;\n  for (float j = 0.; j <= 3.; j ++) {\n    if (j > 0.) qq.xz = b + qq.zx ;\n    q = vec3 (abs (vec2 (abs (qq.x) - 5., qq.z)) - 1., qq.y - 1.).xzy;\n    d = max (PrBoxDf (q, vec3 (0.2, 5., 0.2)), dot (qq, vuPln) - 1.);\n    DMINQ (idPilr);\n  }\n  dw = min (PrBoxDf (p - vec3 (-7.5, 4., -9.9), vec3 (2.9, 0.3, 1.1)),\n     PrBoxDf (qq - vec3 (5., 0.23, -2.), vec3 (0.82, 0.3, 1.9)));\n  s = - qq.x;\n  q = vec3 (abs (vec2 (abs (qq.x) - 5., qq.z)) - 1., qq.y).xzy;\n  d = PrBoxDf (q, vec3 (0.2, 5., 0.2));\n  DMINQ (idPilr);\n  qq.x = - qq.x;\n  qq.xz = vec2 (15., 0.) - qq.xz;\n  qq.xz = mix (qq.xz, qq.zx, step (qq.x, qq.z));\n  qq.xy -= vec2 (10., 1.);\n  qq.xz = mix (qq.xz, qq.zx, step (qq.x, qq.z));\n  qq.x = - qq.x;\n  dw = min (dw, PrBoxDf (qq, vec3 (10.8, max (0., 0.95 - 0.03 * s), 0.65)));\n  q = p - vec3 (0., 3., -10.);\n  d = max (PrBoxDf (q - vec3 (-7.4, 0.95, 0.1), vec3 (3.5, 0.25, 1.7)), - dw);\n  DMINQ (idWChan);\n  for (float j = 0.; j <= 3.; j ++) {\n    if (j > 0.) q.xz = b + q.zx;\n    s = 0.1 * step (1., q.x);\n    d = max (PrBoxDf (q - vec3 (0., - s, 0.), vec3 (6., 1.2 - 0.2 * j - s, 1.)), - dw);\n    DMINQ (idWChan);\n  }\n  d = max (PrBoxDf (q - vec3 (5., -0.15, -2.2), vec3 (1., 0.4, 1.2)), - dw);\n  DMINQ (idWChan);\n  s = sign (q.x);\n  q.x = abs (q.x) - 5.;\n  d = isPoly ? IcoDodDf (q - vec3 (0., 6.4, 0.), s) : PrSphDf (q - vec3 (0., 6.2, 0.), 1.);\n  DMIN (idTop);\n  d = PrBoxDf (q - vec3 (0., 5.1, 0.), vec3 (1.5, 0.1, 1.5));\n  DMIN (idPlat);\n  d = 6. - abs (q.y);\n  q.y = mod (q.y - 2.1, 5.6) - 1.7;\n  d = max (max (PrBoxDf (q - vec3 (0., 0.5, 0.), vec3 (1.15, 0.7, 1.15)),\n     0.85 - min (length (q.xy), length (q.zy))), - d);\n  q = p - vec3 (5., 1., 0.);\n  d = min (d, max (PrBoxDf (q - vec3 (0., 0.5, 0.), vec3 (1.15, 0.7, 1.15)),\n     0.85 - min (length (q.xy), length (q.zy))));\n  DMIN (idArch);\n  return dMin;\n}\n\nfloat WWheelDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  q = p - vec3 (-7.8, 5.2, -6.2);\n  d = PrCylDf (q, 1., 0.2);\n  DMIN (idUBldgX);\n  q.z -= -2.3;\n  d = PrCylDf (q, 0.5, 2.2);\n  q.z -= -1.5;\n  d = min (d, PrCylAnDf (q, 1.1, 0.15, 0.7));\n  DMIN (idWWhl);\n  q.xy = Rot2D (q.xy, -0.8 * tCur * flDir);\n  q.xy = Rot2D (q.xy, 2. * pi * floor (14. * atan (q.y, - q.x) / (2. * pi) + 0.5) / 14.);\n  q.x -= -1.3;\n  d = PrBoxDf (q, vec3 (0.7, 0.07, 0.6));\n  DMIN (idWWhl);\n  return dMin;\n}\n\nfloat WatSurfDf (vec3 p, float dMin)\n{\n  vec3 q;\n  vec2 b;\n  float d;\n  b = vec2 (-5.);\n  q = p - vec3 (0., 3., -10.);\n  d = PrBoxDf (q - vec3 (-7.5 , 0.1, 0.1), vec3 (3., 0.8, 1.1));\n  DMINQ (idWater);\n  for (int j = 0; j <= 3; j ++) {\n    if (j > 0) q.xz = b + q.zx;\n    d = PrBoxDf (q, vec3 (6., 0.8 - 0.2 * float (j) - 0.02 * q.x, 0.75));\n    DMINQ (idWater);\n  }\n  q.xz = - q.zx;\n  q -= vec3 (2.1, -0.05, -5.);\n  d = max (PrBoxDf (q, vec3 (1.3, 0.15, 0.75)), q.x + 4. * q.y - 1.5);\n  DMINQ (idWater);\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dMin;\n  dMin = dstFar;\n  dMin = UBldgDf (p - vuDir * 35., dMin);\n  dMin = SpltBldgDf (p - vuDir * 35., p.z - 99., dMin);\n  dMin = SpltBldgDf (p, p.z + 8.7, dMin);  \n  dMin = FBldgDf (p, dMin);\n  dMin = WWheelDf (p, dMin);\n  dMin = WatChanDf (p, dMin);\n  dMin = WatSurfDf (p, dMin);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.002, -0.002);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat TrObjDf (vec3 p)\n{\n  vec3 q;\n  q = p - vec3 (-8., 7.6, -9.8);\n  return max (PrRoundFlatCylAnDf (q.yxz, 5.6, 1.5, 0.1, 0.5, 0.1),  q.x - 0.1);\n}\n\nfloat TrObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 60; j ++) {\n    d = TrObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 TrObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.002, -0.002);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = TrObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nfloat BCylHit (vec3 ro, vec3 rd, float rad)\n{\n  float a, b;\n  a = dot (rd.xz, rd.xz);\n  b = dot (rd.xz, ro.xz);\n  return (- b + sqrt (b * b - a * (dot (ro.xz, ro.xz) - rad * rad))) / a;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, colW, roo, vn, q;\n  vec2 vf, c;\n  float dstObj, dstFWat, sh, a, s, spec;\n  dstObj = ObjRay (ro, rd);\n  roo = ro;\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    spec = 0.1;\n    if (idObj <= idRBldg) {\n      if (idObj == idWChan) col = mix (vec3 (0.9, 0.4, 0.2), vec3 (0.7, 0.3, 0.4),\n         step (qHit.y, -0.4)) * (1. - 0.3 * step (0.95, sin (8. * pi * qHit.y)));\n      else if (idObj == idWWhl) col = vec3 (0.8, 0.5, 0.1);\n      else if (idObj == idMBldg) col = (qHit.y > 3.69) ? vec3 (0.7, 0.7, 0.8) : \n         ((qHit.y < 3.35 && qHit.x < 1.9) ? vec3 (0.8, 0.7, 0.5) : vec3 (0.6, 1., 1.));\n      else /*if (idObj == idRBldg)*/ col = vec3 (0.7, 0.5, 0.3);\n    } else if (idObj <= idFenc) {\n      if (idObj == idFBldg) col = vec3 (0.75, 0.45, 0.3);\n      else if (idObj == idLBldg) col = vec3 (0.7, 0.5, 0.35);\n      else if (idObj == idStair) col = (vn.x > -0.01) ? vec3 (0.8, 0.8, 0.5) :\n         vec3 (0.75, 0.45, 0.3);\n      else /*if (idObj == idFenc)*/ col = vec3 (1., 0.9, 0.4);\n    } else if (idObj <= idPilr) {\n      if (idObj == idUBldg) col = (max (abs (qHit.x) - 4.7, abs (qHit.z) - 2.7) < 0.) ?\n         vec3 (0.2, 0.5, 0.3) : vec3 (0.9, 0.8, 0.5);\n      else if (idObj == idUBldgX) col = vec3 (0.9, 0.8, 0.5);\n      else if (idObj == idRoof) col = vec3 (0.8, 0.1, 0.2) * (1. - 0.2 * step (0.5,\n         sin (16. * pi * qHit.y)));\n      else /*if (idObj == idPilr)*/ col = vec3 (0.9, 0.8, 0.7) * (1. -\n         0.1 * step (0.7, sin (4. * pi * qHit.y)));\n    } else /*if (idObj <= idWater)*/ {\n      if (idObj == idPlat) col = vec3 (0.7, 0.6, 0.5);\n      else if (idObj == idTop) col = vec3 (0.5, 0.6, 1.);\n      else if (idObj == idArch) {\n        c = (1. - 0.2 * step (0.8, cos (4. * pi * qHit.xz)));\n        col = vec3 (0.9, 0.8, 0.7) * c.x * c.y;\n      } else /*if (idObj == idWater)*/ {\n        q = qHit;\n        s = 1. - smoothstep (0., 2., abs (q.x) - 3.);\n        q.x -= tCur * flDir;\n        col = vec3 (0.7, 0.8, 1.) * (0.96 - 0.04 * s * sin (2. * pi * q.x));\n      }\n    }\n    if (idObj != idWWhl && idObj != idFenc) {\n      if (idObj == idWater) {\n        vf = vec2 (0.);\n        if (vn.y > 0.5) {\n          vf = vec2 (4., 2.);\n          spec = 0.2;\n        }\n      } else {\n        vf = vec2 (16., 0.5);\n        q = ro;\n      }\n      if (vf.x > 0.) vn = VaryNf (vf.x * q, vn, vf.y);\n    }\n    sh = (idObj != idPilr && idObj != idWater) ? ObjSShadow (ro, sunDir) : 1.;\n    col = col * (0.2 + 0.8 * sh * max (dot (vn, sunDir), 0.)) +\n       spec * step (0.95, sh) * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n  } else {\n    ro += BCylHit (ro + vec3 (-20., 0., 10.), rd, 100.) * rd;\n    a = (atan (ro.z, - ro.x) + 0.3 * floor (0.5 * ro.y)) / (2. * pi);\n    col = (1. + 0.2 * ro.y / 100.) * mix (vec3 (0.3, 0.5, 0.2) * (1. -\n       0.1 * smoothstep (0.25, 0.3, mod (360. * a + 0.5, 1.) - 0.5)), vec3 (0.4, 0.6, 0.3) *\n       (1. - 0.1 * Noisefv2 (256. * vec2 (4. * a, ro.y))), step (0.65, mod (0.5 * ro.y, 1.)));\n  }\n  ro = roo;\n  dstFWat = TrObjRay (ro, rd);\n  if (dstFWat < min (dstObj, dstFar)) {\n    ro += dstFWat * rd;\n    vn = TrObjNf (ro);\n    q = ro;\n    q.y += 2. * tCur * flDir;\n    vn = VaryNf (8. * q, vn, 4.);\n    colW = mix (vec3 (0.8, 0.9, 1.), 0.9 * vec3 (0.7, 0.8, 1.),\n       smoothstep (0., 1., ro.y - 13.5)) * (0.6 + 0.4 * max (dot (vn, sunDir), 0.)) +\n       0.2 * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n    col = mix (col, colW, sqrt (Maxv3 (colW)) * (1. - 0.3 * step (0., sin (16. * pi * ro.z)) *\n       (1. - 0.4 * step (0., sin (2. * pi * q.y)))));\n  }\n  if (isMono) col = vec3 (1., 0.7, 0.3) * Maxv3 (col);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col, vx, vy;\n  vec2 canvas, uv, ut, uvv;\n  float el, az, zmFac, asp, sr;\n  bool inCorn, flipVu;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  flDir = 1.;\n  isMono = false;\n  flipVu = false;\n  isPoly = false;\n  ut = vec2 (abs (mPtr.x), abs (mPtr.y)) + 0.05 * vec2 (1. / asp, 1.) - 0.5;\n  inCorn = (mPtr.z > 0. && min (ut.x, ut.y) > 0.);\n  if (inCorn) {\n    if (mPtr.x > 0. && mPtr.y > 0.) isPoly = true;\n    if (mPtr.x > 0. && mPtr.y < 0.) flDir = -1.;\n    if (mPtr.x < 0. && mPtr.y > 0.) flipVu = true;\n    if (mPtr.x < 0. && mPtr.y < 0.) isMono = true;\n  }\n  az = 0.2501 * pi;\n  el = -0.143 * pi;\n  if (mPtr.z > 0. && ! inCorn) {\n    az += 2. * pi * smoothstep (0.05, 0.2, abs (mPtr.x)) * mPtr.x;\n    el += 0.5 * pi * smoothstep (0.05, 0.2, abs (mPtr.y)) * mPtr.y;\n  }\n  ro = vec3 (0., 0., -70.);\n  ro.yz = Rot2D (ro.yz, - el);\n  ro.xz = Rot2D (ro.xz, - az);\n  rd = normalize (vec3 (0., 4., 0.) - ro);\n  vuDir = rd;\n  vx = normalize (vec3 (vuDir.z, 0., - vuDir.x));\n  if (flipVu) vx *= -1.;\n  vy = vec3 (0., 1., 0.) - vuDir.y * vuDir;\n  vuPln = vy;\n  zmFac = 0.065;\n  dstFar = 200.;\n  sunDir = normalize (vec3 (-2., 3., -1.));\n  if (max (abs (uv.x), abs (uv.y)) < 0.97) {\n#if ! AA\n    const float naa = 1.;\n#else\n    const float naa = 3.;\n#endif  \n    col = vec3 (0.);\n    sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n    for (float a = float (VAR_ZERO); a < naa; a ++) {\n      uvv = uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) * pi);\n      col += (1. / naa) * ShowScene (ro + vec3 (uvv.x * vx + uvv.y * vy) / zmFac, rd);\n    }\n  } else if (abs (uv.x) < 1.) {\n    col = vec3 (0.2, 0.4, 0.6);\n  } else {\n    col = vec3 (0.75);\n  }\n  if (mPtr.z > 0. && min (abs (uv.x) - asp, abs (uv.y) - 1.) > -0.1)\n     col = mix (col, vec3 (1., 1., 0.), 0.3);\n  fragColor = vec4 (col, 1);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h)\n{\n  return max (length (p.xy - vec2 (clamp (p.x, - rhi, rhi), 0.)) - rlo, abs (p.z) - h);\n}\n\nfloat PrRoundFlatCylAnDf (vec3 p, float rhi, float rlo, float w, float h, float rc)\n{\n  vec2 q;\n  q = abs (vec2 (length (p.xy - vec2 (clamp (p.x, - rhi, rhi), 0.)) - rlo, p.z)) - vec2 (w, h);\n  return length (vec2 (max (q, 0.))) - rc;\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sBfDR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sBfDW", "name": "Psychedelic flower", "author": "codecontemplator", "description": "Psychedelic flower", "tags": ["2d"], "likes": 0, "viewed": 265, "date": "1590008701", "time_retrieved": "2024-06-20T20:06:37.631975", "image_code": "#define PI 3.14159265359\n\nvec2 toSmith(vec2 p)  {\n  // z = (p + 1)/(-p + 1)\n  // (x,y) = ((1+x)*(1-x)-y*y,2y)/((1-x)*(1-x) + y*y)\n  float d = (1.0 - p.x)*(1.0 - p.x) + p.y*p.y;\n  float x = (1.0 + p.x)*(1.0 - p.x) - p.y*p.y;\n  float y = 2.0*p.y;\n  return vec2(x,y)/d;\n}\n\nvec2 fromSmith(vec2 p)  {\n  // z = (p - 1)/(p + 1)\n  // (x,y) = ((x+1)*(x-1)+y*y,2y)/((x+1)*(x+1) + y*y)\n  float d = (p.x + 1.0)*(p.x + 1.0) + p.y*p.y;\n  float x = (p.x + 1.0)*(p.x - 1.0) + p.y*p.y;\n  float y = 2.0*p.y;\n  return vec2(x,y)/d;\n}\n\nvec2 rotate(vec2 v, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat2 m = mat2(c, -s, s, c);\n    return m * v;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdEquilateralTriangle( in vec2 p )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdStar5(in vec2 p, in float r, in float rf)\n{\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n    float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n    return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\nfloat sdHorseshoe( in vec2 p, in vec2 c, in float r, in vec2 w )\n{\n    p.x = abs(p.x);\n    float l = length(p);\n    p = mat2(-c.x, c.y, \n              c.y, c.x)*p;\n    p = vec2((p.y>0.0)?p.x:l*sign(-c.x),\n             (p.x>0.0)?p.y:l );\n    p = vec2(p.x,abs(p.y-r))-w;\n    return length(max(p,0.0)) + min(0.0,max(p.x,p.y));\n}\n\nfloat circle(in vec2 p, in float r ) {\n    return length(p) - r;\n}\n\nfloat map(in vec2 p){    \n    float d1 = sdEquilateralTriangle(p*0.5);\n    float d2 = sdStar5(p*0.1, 1.0, 0.4);\n    float d3 = sdStar5(p*0.2, 1.0, 0.4);\n    //float d4 = sdHorseshoe(p-vec2(2.0,-0.1), vec2(0.4, -1.5), 1.5, vec2(0.750,0.25));\n    float d4 = circle(p, 8.);\n    return min(min(d1, max(d2,-d3)), -d4);\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 modMirror2(inout vec2 p, vec2 size) {\n  vec2 halfsize = size*0.5;\n  vec2 c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  p *= mod(c,vec2(2.0))*2.0 - vec2(1.0);\n  return c;\n}\n\nvec3 postProcess(in vec3 col, in vec2 q) \n{\n  col=pow(clamp(col,0.0,1.0),vec3(0.45)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=vec3(0.15+0.85*pow(29.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7));  // vigneting\n  return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord/iResolution.xy;\n    vec2 uv = -1. + 2. * q;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float sc = 25.0;\n    vec2 p = uv*sc;\n    p = toSmith(p);\n    p = p + 0.7;\n    p = rotate(p, iTime*0.05*PI);\n    p = fromSmith(p);\n    p = toPolar(p);\n    \n    modMirror2(p, vec2(150, 2.*PI/16.));\n    p = toRect(p);\n    modMirror2(p, vec2(15, 15));\n    p = rotate(p, iTime*0.05*PI);\n    float d = map(p + vec2(0.4, 0)) / sc;\n    \n    float r = smoothstep(0.0, 0.001, d);\n    float g = smoothstep(0.0, 0.01, d);\n    float b = smoothstep(0.0, 1.0, d);\n    \n    vec3 color = vec3(r, g ,b);\n    color += mix(vec3(1.0,0.0,0.0),vec3(0.0,1.0,0.0),0.5+0.5*sin(d*200.))*(0.5+0.5*sin(d*2000.));\n    //color = 1.0 - color;\n    color = postProcess(color, q);\n    fragColor = vec4(color, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sBfDW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sBfzV", "name": "Radar Effect", "author": "yp3y5akh0v", "description": "Radar Effect", "tags": ["2d", "radar"], "likes": 1, "viewed": 129, "date": "1590351426", "time_retrieved": "2024-06-20T20:06:37.631975", "image_code": "#define n 10.\n\n#define rand(p) fract(sin(sin(p) * mat2(12.9898, 78.233, 78.233, 12.9898)) * 143758.5453)\n#define Circle(w, p, r) smoothstep( w, 0., abs(length(p) - r ) )\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 R = iResolution.xy;\n    vec2 uv = (fragCoord - 0.5 * R) / R.y;\n    float t = iTime;\n    vec3 col = vec3(0.);\n    vec2 p = uv;\n    vec2 p1 = vec2(sin(t), cos(t));\n    vec2 PtoP0P1 = p - dot(p1, p) * p1;\n    float d = length(PtoP0P1);\n    if (dot(p, p1) < 0.) {\n        d = length(p);\n    }\n    vec2 cl = vec2(0.5, 0.);\n    col = .006 / d * cl.yxy;\n    float r = length(p1);\n    float i = round(n * length(p) / r);\n    float w = 2. * r / R.y;\n    float circle = Circle(w, p, r * i / n);\n    \n    col += circle * cl.yxy;\n    \n    vec2 delay = vec2(1., 20.) * (1. + p1); \n    if (delay.x > 0.99) {\n        float echoR = mix(r, 0., delay.y);\n        float circle = Circle(w, p, echoR);\n        col += circle * cl.yxy;\n    } else {\n        vec2 enemy = vec2(-0.2 + 0.5 * cos(0.01 * floor(t)));\n        col += .005 / length(p - enemy) * cl.xyy;\n    }\n        \n    float dTargets = length(rand(p - 1e-6 * log(t + 100.)));    \n    col += .02 / dTargets * cl.yxy;\n    \n    fragColor = vec4(col, 0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sBfzV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sBfzz", "name": "Volume Rendering Test", "author": "okdalto", "description": "Volume Rendering test", "tags": ["volumerendering"], "likes": 3, "viewed": 109, "date": "1589337822", "time_retrieved": "2024-06-20T20:06:37.631975", "image_code": "\nfloat sdf(vec3 p){\n    return length(p) - 3.0;\n}\n\n\nvec4 sampleDensity(vec3 p){\n    float density = clamp(-sdf(p) * 1000.0, 0.0, 1.0);\n    vec3 color = clamp(abs(p * 0.3), 0.0, 1.0);\n    return vec4(color, density);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy - 0.5) * 2.0;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 col = vec3(0.0);\n    vec3 cameraPos = vec3(cos(iTime), sin(iTime), sin(iTime)) * 5.0;\n    vec3 rayPos = cameraPos;\n    vec3 up = vec3(0,1,0);\n    vec3 front = normalize(-cameraPos);\n    vec3 left = normalize(cross(up, front));\n    up = normalize(cross(front, left));\n    \n    vec3 rayDir = normalize(up * uv.y + left * uv.x + front);\n    \n    float deltaStep = 0.05;\n    vec3 accCol = vec3(0.0);\n    float accDensity = 0.0;\n    \n    for(int i = 0; i < 128; i++){\n        vec4 raw = sampleDensity(rayPos);\n        float density = raw.w;\n        vec3 volumeCol = raw.xyz;\n        \n        accCol += exp(-accDensity) * (1.0 - exp(-density * deltaStep)) * volumeCol;\n        accDensity += density * deltaStep;\n        rayPos = cameraPos + rayDir * float(i) * deltaStep;\n    }\n\n    // Output to screen\n    fragColor = vec4(accCol, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sBfzz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sfBDf", "name": "constant line thickness voronoi", "author": "Veggiebob", "description": "voronoi with (mostly) constant line thickness", "tags": ["voronoi", "noise"], "likes": 1, "viewed": 332, "date": "1589152375", "time_retrieved": "2024-06-20T20:06:38.298689", "image_code": "// Bad code, but came back later to prototype the constant line thickness thing\n// has some bugs because it depends on the two closest points, but works pretty well for thin lines\n\n\n//credit to iq for noise\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\nfloat snoise(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\nvec3 proj (vec3 a, vec3 b) {\n    return dot(a, b) * b / dot(b, b);\n}\nfloat comp (vec3 a, vec3 b) {\n    return dot(a, b) / length(b);\n}\nfloat comp2 (vec2 a, vec2 b) {\n    return comp(vec3(a.xy, 0.), vec3(b.xy, 0.));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float aspect = iResolution.x/iResolution.y;\n    vec2 mouse = vec2(0.5);\n    uv.x*=aspect;\n    const int numPoints = 25;\n    float[numPoints] pointsx = float[numPoints](\n        0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0.);\n    float[numPoints] pointsy = pointsx;\n    float d = 100000.;\n    float ld = d;\n    vec2 last_point = vec2(0.);\n    vec2 point = vec2(0.);\n    for(int i = 0; i<numPoints; i++){\n        float j = float(i);\n        pointsx[i] = snoise(vec2(iTime*0.01+j))+mouse.x*aspect;\n        pointsy[i] = snoise(vec2(iTime*0.01+j+1.))+mouse.y;\n        vec2 r = vec2(pointsx[i], pointsy[i]);\n        float dist = length(r-uv);\n        if(dist<d){\n            ld = d;\n            last_point = point;\n            d = dist;\n            point = r;\n        } else\n        if (dist<ld){\n            ld = dist;\n            last_point = r;\n        }\n    }\n    //one thing to take advantage of is the fact that each line separating points is equal in length\n    float max_dist = length(point - last_point) / 2.;\n    float dist = comp2(uv - point, last_point - point); // project vector from nearest onto height-space vector\n    float h = abs(dist - max_dist);\n    float hp = h / max_dist;\n    float lines = 30.;\n    vec3 mod_color = vec3(abs(mod(h, 1./lines)*lines-0.5));\n    vec3 line_color = smoothstep(0.02, 0.00, h) * vec3(0., 0., 1.);\n    vec3 col = max(mod_color, line_color); // just the line: smoothstep(0.01, 0.02, h)\n    col = mix(vec3(1.), col, smoothstep(0.01, 0.02, length(uv-point)));\n    fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sfBDf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sfBRj", "name": "simple 3d ball", "author": "betseyliu", "description": "simple 3d ball", "tags": ["learn"], "likes": 1, "viewed": 40, "date": "1588567983", "time_retrieved": "2024-06-20T20:06:38.298689", "image_code": "float DistLine(vec3 ro, vec3 rd, vec3 p){\n\treturn length(cross(p-ro, rd))/length(rd); \n}\n\nfloat DrawPoint(vec3 ro, vec3 rd, vec3 p, float pointSize) {\n\n    float d = DistLine(ro, rd, p);\n    d = smoothstep(pointSize, pointSize - .01, d);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)   \n    vec2 uv = fragCoord/iResolution.xy;\n\tuv -= .5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    \n    \n    float t = iTime;\n    \n    vec3 ro = vec3(3. * sin(t), -1., -3.* cos(t));\n    vec3 lookat = vec3(0.);\n    \n    float zoom = 1.;\n    vec3 f = normalize(lookat - ro);\n  \tvec3 r = cross(vec3(0., 1., 0.), f);\n        vec3 u = cross(f, r);\n    \n    vec3 c = ro + f * zoom;\n    vec3 i = c + uv.x *r + uv.y * u;\n    \n    vec3 rd = i - ro;\n    \n   \tfloat d = 0.;\n   \tfloat size = 1.;\n    size /= 2.;\n    \n    d += DrawPoint(ro, rd, vec3(-size, size, -size), .05);\n    d += DrawPoint(ro, rd, vec3(-size, -size, -size), .05);\n    d += DrawPoint(ro, rd, vec3(size, size, -size), .05);\n    d += DrawPoint(ro, rd, vec3(size, -size, -size), .05);\n    d += DrawPoint(ro, rd, vec3(-size, size, size), .05);\n    d += DrawPoint(ro, rd, vec3(-size, -size, size), .05);\n    d += DrawPoint(ro, rd, vec3(size, size, size), .05);\n    d += DrawPoint(ro, rd, vec3(size, -size, size), .05);\n    \n    \n    \n    fragColor = vec4(d);\n    \n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sfBRj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sfBWf", "name": "ShATI - Musical", "author": "Flopine", "description": "My former school named ATI decided to launch an everyday challenge from 4th may to 24th may, here is the 7th subject: musical :)\nAlso made during a twitch session you can re-watch here:  https://www.twitch.tv/flopine", "tags": ["raymarching", "zelda", "toonshading", "twitch", "ocarina"], "likes": 8, "viewed": 217, "date": "1589149702", "time_retrieved": "2024-06-20T20:06:39.244363", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n// Shader made for Everyday ATI challenge\n\n#define PI 3.141592\n#define TAU 6.2831853071\n#define time iTime\n#define dt mod(iTime,TAU)\n#define trir vec2(1.,0.7)\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat smin (float a, float b, float k)\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat caps (vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat cyl (vec3 p, float r, float h)\n{return max(length(p.xy)-r,abs(p.z)-h);}\n\nfloat fradius;\nfloat ocarina (vec3 p)\n{\n    vec3 pp = p;\n    float bradius = sin((-p.x+1.)*1.4)*0.3+0.08;\n    float body = caps(p,vec3(-1.,0.,0.),vec3(1.,0.,0.), bradius);\n\n    p.xy += vec2(0.45,-.6);\n    fradius = sin((-p.y+0.4)*2.)*0.16; \n    float flute = caps(p,vec3(0.,-0.2,0.),vec3(0.,0.25,0.), fradius);\n\n    p = pp;\n    float c1 = cyl(p+vec3(0.64,-0.15,0.3), 0.08, .3);\n    float c2 = cyl(p+vec3(0.8,0., 0.3), 0.08, .3);\n    float c3 = cyl(p+vec3(0.64,0.15, 0.3), 0.08, .3);\n    float c4 = cyl(p+vec3(0.45,0., 0.3), 0.08, .3);\n    float c5 = cyl(p+vec3(-0.1,-0.25, 0.3), 0.08, .3);\n    float c6 = cyl(p+vec3(-0.3,-0.1, 0.3), 0.08, .3);\n    float c7 = cyl(p+vec3(-0.5,-0.18, 0.3), 0.08, .3);\n    float cs = min(c7,min(min(c6,c5),min(min(c1,c3),min(c2,c4))));\n\n    return max(-cs,abs(smin(body,flute,0.1))-0.005);\n}\n\nfloat ring (vec3 p)\n{\n    p.xy += vec2(0.44,-.48);\n    p.xy *= rot(0.1);\n    return cyl(p.xzy,0.04+fradius,0.1);\n}\n\nint mat_id;\nfloat SDF (vec3 p)\n{\n    p.yz *= rot(sin(dt)*0.15);\n    p.xz *= rot(cos(dt)*0.1);\n    p.y -= 0.45+sin(dt)*0.1;\n    p.xy *= rot(PI/5.);\n    float ri = ring(p);\n    float oc = ocarina(p);\n    float d = min(ri,oc);\n    if (d == ri) mat_id = 1;\n    if (d == oc) mat_id = 2;\n    return d;\n}\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2(0.01,0.);\n    return normalize(SDF(p)-vec3(SDF(p-eps.xyy),SDF(p-eps.yxy),SDF(p-eps.yyx)));\n}\n\nfloat spec (vec3 rd, vec3 n, vec3 l)\n{\n    vec3 h = normalize(l-rd);\n    return pow(max(dot(n,h), 0.), 20.);\n}\n\n// courtesy of Alkama\nfloat pales (vec2 uv, float speed, float number)\n{\n    uv *= rot(-time*speed);\n    return floor(smoothstep(0.1, 0.2,cos(atan(uv.y, uv.x)*number)));\n}\n\nvec3 ynotes (vec2 uv, float size, int note)\n{\n    uv *= size;\n    float r = 0.2;\n    float s = 0.08;\n    float triUp = smoothstep(s,s*1.1,max(-uv.y, dot(vec2(abs(uv.x),uv.y), normalize(trir))));\n    float triRight = smoothstep(s,s*1.1,max(-uv.x, dot(vec2(uv.x,abs(uv.y)), normalize(trir.yx))));\n    float triLeft = smoothstep(s,s*1.1,max(uv.x, dot(vec2(-uv.x,abs(uv.y)), normalize(trir.yx))));\n    float direction;\n    if (note == 1) direction = triUp;\n    if (note == 2) direction = triRight;\n    if (note == 3) direction = triLeft;\n    float mask = (1.-smoothstep(r,r*1.1, length(uv)))*direction;\n\n    return vec3(0.9,0.8,0.)*mask;\n}\n\nvec3 bnotes (vec2 uv, float size)\n{\n    uv *= size;\n    float mask = 1.-smoothstep(0.2,0.2*1.1, length(uv));\n    return vec3(0.1,0.4,0.95) * mask;\n}\n\nvec3 background (vec2 uv)\n{\n    vec2 uu = uv;\n    vec3 back = mix(vec3(0.3,0.25, 0.1),\n                    vec3(0.9,0.9,0.45),\n                    pales(uv+vec2(0.,-0.2), 0.3, 5.)*0.5+pales(uv+vec2(0.,-0.2),-0.5, 10.)*0.7\n                   );\n    uv.y += 0.25;\n    back *= smoothstep(0.2,0.21,max(abs(uv.x*.45),abs(uv.y*1.4)));\n    uv.x -= 0.15;\n    back += bnotes(uv+vec2(0.5,0.07), 5.);\n    back += ynotes(uv+vec2(0.4,-0.07), 5., 1);\n    back += ynotes(uv+vec2(0.25,-0.02), 5., 3);\n    back += ynotes(uv+vec2(0.1,0.03), 5., 2);\n    back += ynotes(uv+vec2(-0.05,-0.02), 5., 3);\n    back += ynotes(uv+vec2(-0.2,0.03), 5., 2);\n\n    return clamp(back,0.,1.);\n}\n\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = vec2(fragCoord.x /iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    vec3 ro = vec3(0.0,-0.3,-3.),\n        rd = normalize(vec3(uv,1.)),\n        p = ro,\n        l = normalize(vec3(1.,2., -2.)),\n        specl = normalize(vec3(-1.5,5.,-5.)),\n        col = background(uv);\n\n    float shad,d=0.; \n    bool hit = false;\n\n    for (float i=0.; i<64.; i++)\n    {\n        d = SDF(p);\n        if (d<0.01)\n        {\n            hit = true;\n            shad = i/64.;\n            break;\n        }\n        p += d*rd*0.6;\n    }\n\n    if (hit)\n    {\n        vec3 n = getnorm(p);\n        float lighting = floor(max(dot(n,l),0.)*3.)/3.;\n        if (mat_id == 2) \n        {\n            col = mix(vec3(0.,0.05,0.2),vec3(0.5,0.8,1.),lighting);\n        }\n        if (mat_id == 1)\n        {\n            col = vec3(lighting+0.15);\n        }\n        col += smoothstep(0.4,0.5,spec(rd, n, specl));\n    }\n    fragColor = vec4(sqrt(clamp(col,0.,1.)), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sfBWf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sfBWS", "name": "FXAA to hide discontinuities?", "author": "mosaic", "description": "Left is no FXAA, right is FXAA enabled \nThere's probably a better way to do this", "tags": ["2d"], "likes": 1, "viewed": 66, "date": "1588915283", "time_retrieved": "2024-06-20T20:06:39.244363", "image_code": "// https://www.shadertoy.com/view/4dfGDj\n// FXAA by Dave Hoskins, FXAA algorithm from NVIDIA :)\n// http://developer.download.nvidia.com/assets/gamedev/files/sdk/11/FXAA_WhitePaper.pdf\n\n#define FXAA_SPAN_MAX\t8.0\n#define FXAA_REDUCE_MUL 1.0/8.0\n#define FXAA_REDUCE_MIN 1.0/128.0\n\n//========================================================================================\nfloat Hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\n//========================================================================================\nfloat Noise( in vec2 x )\n{\n\t\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\t\n   \tf = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0;\n    float res = mix(mix( Hash(n+  0.0), Hash(n+  1.0),f.x),\n                    mix( Hash(n+ 57.0), Hash(n+ 58.0),f.x),f.y);\n    return res;\n}\n\n//========================================================================================\nvec3 hsv(in float h) \n{\n\tif (h > .45 && h < .55) return vec3(1.0);\n\tvec3 rgb = clamp((abs(fract(h + vec3(3, 2, 1) / 3.0) * 6.0 - 3.0) - 1.0), 0.0 , 1.0);\n\treturn sqrt(rgb);\n}\n\n//========================================================================================\nvec3 old(vec2 p)\n{\n\tfloat t= sin(iTime*.03)*1.5;\n\tmat2 m = mat2(cos(t), sin(t), -sin(t), cos(t));\n\tp*= m;\n\tvec2 b = vec2(.6, .6);\n\tvec2 d = abs(p) - b;\n  \tfloat f = min(max(d.x, d.y),0.0) + length(max(d,0.0));\n\tfloat pix = Noise(p*20.0)*.29;\n\tif (f < pix && f > -pix) return hsv(Noise(p*33.0));\n\telse return vec3(0.0, 0.0, .0);\n}\n\nvec3 Box(vec2 uv)\n{\nfloat time1 = iTime/2.0;\n    float scale = 5.0;\n    vec2 col = (uv.yx*scale*(1.0+sin(uv.x+time1/10.)/2.0));\n    vec2 col2;\n    for(float i = 1.0; i < 4.0; i++){\n        uv += ceil(col+tan((col.x+col.y))/5.0);\n        col -= sin(uv.x+time1/10.);\n        col2 = (col2+col)/(i*i);\n    }\n    \n    // Output to screen\n    return vec3(col.y,col2.x,0.5);\n\n}\n\n\n\n//========================================================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\n\tif (abs(uv.x) < 3.0/iResolution.x) \n\t{\n\t\t// Centre line...\n\t\tfragColor = vec4(0.2, 0.0, 0.2, 1.0);\n\t\treturn;\n\t}\n\tif (uv.x < 0.0) \n\t{\n\t\t// No FXAA on left...\n\t\tuv.x = -uv.x;\n\t\tfragColor = vec4(Box(uv), 1.0);\n\t\treturn;\n\t}\n\tvec2 add = vec2(1.0) / iResolution.xy;\n\t\t\t\n\tvec3 rgbNW = Box(uv+vec2(-add.x, -add.y));\n\tvec3 rgbNE = Box(uv+vec2( add.x, -add.y));\n\tvec3 rgbSW = Box(uv+vec2(-add.x,  add.y));\n\tvec3 rgbSE = Box(uv+vec2( add.x,  add.y));\n\tvec3 rgbM  = Box(uv);\n\t\n\tvec3 luma\t = vec3(0.299, 0.587, 0.114);\n\tfloat lumaNW = dot(rgbNW, luma);\n\tfloat lumaNE = dot(rgbNE, luma);\n\tfloat lumaSW = dot(rgbSW, luma);\n\tfloat lumaSE = dot(rgbSE, luma);\n\tfloat lumaM  = dot(rgbM,  luma);\n\t\n\tfloat lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n\tfloat lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\t\n\tvec2 dir;\n\tdir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n\tdir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\t\n\t\n\tfloat dirReduce = max(\n\t\t(lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\t  \n\tfloat rcpDirMin = 1.0/(min(abs(dir.x), abs(dir.y)) + dirReduce);\n\t\n\n\tdir = min(vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),\n\t\t  max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n\t\t  dir * rcpDirMin)) * add;\n\n\t\t\n\tvec3 rgbA = (1.0/2.0) * (Box(uv + dir * (1.0/3.0 - 0.5)) +\n\t\t\t\t\t\t\t Box(uv + dir * (2.0/2.0 - 0.5)));\n\t\n\tvec3 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) *\n\t\t(Box(uv.xy + dir * (0.0/3.0 - 0.5)) +\n\t\t Box(uv.xy + dir * (3.0/3.0 - 0.5)));\n\t\n\tfloat lumaB = dot(rgbB, luma);\n\tif((lumaB < lumaMin) || (lumaB > lumaMax))\n\t{\n\t\tfragColor.xyz=rgbA;\n\t}else\n\t{\n\t\tfragColor.xyz=rgbB;\n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sfBWS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sfBzl", "name": "Perlin Noise Derivative", "author": "patgleeson101", "description": "Perlin noise lit according to its analytical derivative.", "tags": ["perlinnoise"], "likes": 0, "viewed": 100, "date": "1588926684", "time_retrieved": "2024-06-20T20:06:39.692754", "image_code": "vec2 gradient(vec2 cell)\n{\n\tvec3 p3  = fract(vec3(cell.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    float theta = 6.2831853072 * fract((p3.x + p3.y) * p3.z);\n    return vec2(cos(theta), sin(theta));\n}\n\nvec3 perlin2(vec2 r) //Returns perlin value + gradient\n{\n    //Useful vector\n    vec2 zo = vec2(0.0, 1.0);\n    \n    //Coordinates & vertices\n    vec2 v00 = floor(r);\n    vec2 v01 = v00 + zo.xy;\n    vec2 v10 = v00 + zo.yx;\n    vec2 v11 = v00 + zo.yy;\n    vec2 xy = r - v00; //Local coordinate\n    \n    //Get gradients\n    vec2 g00 = gradient(v00);\n    vec2 g01 = gradient(v01);\n    vec2 g10 = gradient(v10);\n    vec2 g11 = gradient(v11);\n    \n    //Get influence values\n    float G00 = dot(xy, g00);\n    float G01 = dot(r - v01, g01);\n    float G10 = dot(r - v10, g10);\n    float G11 = dot(r - v11, g11);\n    vec4 G = vec4(G00, G01, G10, G11);\n    \n    //Calculate noise value\n    vec2 W = xy*xy*xy*(10.0+xy*(6.0*xy-15.0)); //Weighted local coordinates\n    vec2 C = G.xy + W.x*(G.zw - G.xy);\n    float P = C.x + W.y*(C.y - C.x);\n    P = P * 0.7071067812 + 0.5;\n    \n    //First derivatives (vectors)\n    vec2 delW = 30.0*xy*xy*(xy*(xy-2.0)+1.0);\n    vec2 delG0 = g00 + W.x*(g10-g00) + vec2(delW.x*(G10-G00), 0.0);\n    vec2 delG1 = g01 + W.x*(g11-g01) + vec2(delW.x*(G11-G01), 0.0);    \n    vec2 delP = delG0 + W.y*(delG1-delG0) + vec2(0.0, delW.y*(C.y-C.x));\n    \n    return vec3(P, delP);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy; //Normalized pixel\n    vec3 noisedata = vec3(0.0);\n    float sTot = 0.0;\n    vec3 rs = vec3(5.0 * uv * vec2(1.0, iResolution.y/iResolution.x), 1.0);\n    for (int i = 0; i < 4; i++) {\n        rs.xy *= 1.5;\n        rs.z *= 0.7;\n        rs.xy += vec2(1.5, 1.8);\n        sTot += rs.z;\n        noisedata += perlin2(rs.xy) * rs.z;\n    }\n    noisedata /= sTot;\n    noisedata.x *= 1.2; //Since statistically the values become increasingly uniform\n    vec2 delP = noisedata.yz;\n    float P = noisedata.x;\n    \n    //Lighting\n    vec3 normal = normalize(vec3(-delP, 1.0)); //Normal \n    vec3 col = vec3(0.8,0.8,0.6); //Colour\n    vec3 light = normalize(vec3(cos(iTime),sin(iTime),0.5)); //Direction to light\n    col *= 0.5*dot(light, normal)+0.5;\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sfBzl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sffDj", "name": "tangents", "author": "gurudevbk", "description": "fullscreen for best results....results vary on diff monitors and diff resolution (restart if pattern converges, considering you actually watched for that long)", "tags": ["tangent"], "likes": 1, "viewed": 238, "date": "1589043518", "time_retrieved": "2024-06-20T20:06:39.953316", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    float thickness = 0.1;\n    float t_usec = (iTime+70.) * .0001;\n    vec2 origin = vec2(.4)+t_usec;\n    const float pi = 3.14159265;\n    \n    // rotation matrix for funzies\n   \t\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y - 0.5;\n    uv.x -= .29;\n    \n    \n    //uv = mat2(sin(t_usec), cos(t_usec), sin(t_usec), -cos(t_usec)) * uv;\n    float radius = .5*atan(uv.x*uv.y,pow(t_usec,3.))/pow(sin(t_usec),2.4);\n    \n    vec3 col = vec3(t_usec+.1, .5*(cos(iTime)*.5+.5),.5); //color \n    vec3 color_scale = length(uv-radius)*col.rgb;\n    \n    col.rgb = 0.5*sin(length(uv*radius)+col.rgb);\n    \n    col *= length(uv*origin)*color_scale;\n    \n    // Time varying pixel color\n  \t//col += 0.4*cos(iTime)+col;\n   \tcol.g += sin(iTime*.02);\n    col.r -= .2*cos(iTime*.02);\n    col.g += pow(sin(iTime*.2),2.);\n\n\n    col.g += atan(sin(iTime),abs(cos(iTime)));\n    \n    col.rgb += mix(col.rbg, col.bgr, length(uv-origin)/2.);\n    \n   // col.g *= 0.05;\n\n    // Output to screen\n    fragColor = vec4(col,1.-length(uv-origin));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sffDj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sffRf", "name": "anillo--torre-v1", "author": "jorge2017a1", "description": "anillo--torre-v1", "tags": ["anillotorrev1"], "likes": 2, "viewed": 74, "date": "1588708743", "time_retrieved": "2024-06-20T20:06:42.899127", "image_code": "//por jorge2017a1-\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define PI 3.14159265358979323846264\n\n\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n\nfloat pi = atan(1.0)*4.0;\nfloat tau = atan(1.0)*8.0;\n\n///------------------------------------\nstruct TObj\n{\n    float tipo;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 path;\n};\n\n\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\n\n//-----------------------------------------\n#define MAXREFLECTIONS 2\n#define MAXITER 64\n//-----------------------------------------\nvec3 ambientColor = vec3(0.05, 0.15, 0.2);\nvec3 diffuseColor = vec3(0.2, 0.6, 0.8);\nvec3 specularColor = vec3(1.0, 1.0, 1.0);\nvec3 lightDir = normalize(vec3(0.0, 4.0, 5.0));\nvec3 spherePos = vec3(0.0, 0.5, 0.0);\n//-----------------------------------\n\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n\n\n\n\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\n\n//---------------------------------------------\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); \n    float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, -sa, +.0,\n\t\t+sa, +ca, +.0,\n\t\t+.0, +.0, +1.0);\n}\n\n\n///---------------------------------------------\n\nfloat opU( float d1, float d2 )\n{\n    return min(d2,d2);\n}\n\n\nvec3 LightShading(vec3 N,vec3 L,vec3 V,vec3 color)\n{\n    vec3 diffuse = max(0.,dot(N,-L))*color;\n    vec3 specular = pow(max(0.,dot(N,normalize(-L-V))),100.)*vec3(1.,1.,1.); \n    return diffuse + specular;\n}\n\n    \n    \nmat2 rotate(float a) \n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\n\nfloat GetDist(vec3 p  ) \n{\t\n\n      float d;\n    float dif1;\n    float dif2;\n    \n    d=999.9;\n \n    \n   vec3 pp, p2;\n    pp=p;\n    p2=p;\n    \n \n    float planeDist1 = p.y-2.0;  //piso inf\n    float planeDist1sup = 20.0-p.y;  //piso sup\n    float planeDist2 = p.x+10.0; //pared izq\n    float planeDist3 = 10.0-p.x;  //pared der\n    float planeDist4 = -p.z+50.0;  //pared atras\n   \n    vec2 res;\n    res = vec2(9999, 0);\n   \n    p.z=p.z-30.0;  ///eje z\n    \n    // float num;\n    #define num 20.0\n    float gr;\n    float sdfintdo;\n    sdfintdo=999.0;\n    float rx, ry;\n    float Incgrados;\n    \n    \n    ///num =20.0;\n     \n    Incgrados=360./num;\n    float angs=360./num*PI/180.0;\n    Incgrados=Incgrados*PI/180.0;\n    float incy;\n    \n\n    vec3 pr =rotate_y(p, angs);\n   \n   for(float jj=0.0; jj<5.0; jj++) \n   {    \n    float it=iTime*0.25 ;  \n    //float it=iTime*0.0 ;     \n    for(float ii=0.0; ii<num; ii++) \n\t{\n       p=rotate_y(p, angs+it);\n       float sdcp2= sdBox( p-vec3(20.0,5.0+incy,1.0), vec3(2.0 ));  \n   \t   sdfintdo = min(sdfintdo,sdcp2);\n       \n     \n    }\n    incy=incy+4.2;\n      \n   } \n    \n    res =opU(res, vec2(sdfintdo,6.0)); \n   res =opU(res, vec2(planeDist4,4));\n    res =opU(res, vec2(planeDist1,4));\n    res =opU(res, vec2(1.0,4));\n  \n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n    \n    return d;\n}\n\n\n\n///----------------------------------------------------------\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n\tfloat dO=0.2;\n    //Determines size of shadow\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = ro + rd*dO;\n        \n        float dS = GetDist(p);\n        \n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) \n        {\n            //mObj.dist=dO; \t\n            mObj.p=p; \t\n            gres2 = vec2(dO,dS); \n            break;\n    \t}    \n        \n    }\n    \n    return dO;\n}\n\n\n//---------------------------------------------------\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n\nfloat GetLightPar(vec3 p, vec3 plig) {\n    vec3 lightPos = plig;\n    //Determine movement of light ex. shadow and light direction and diffusion\n    //lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat saturate(float f)\n{\n\treturn clamp(f,0.0,1.0);\n}\n\n    \n\n#define offset1 4.7\n#define offset2 4.6\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) \n{\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\n\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tif(i==0 )\n    {\n    \n        \n      return vec3(0.0,0.0,0.0);\n    }\n    \n    if(i== 1 )\n    {\n        \n        //return vec3(1, 0.5, 0);\n        \treturn vec3(1.0,0.0,0.0);\n        } \n    if(i== 2 )\n    {\n        //return vec3(1.0, 1.0, 1.0);\n        \treturn vec3(0.0,1.0,0.0);\n        } \n    if(i== 3 )\n    {\n        //return vec3(247./255., 168./255.,  184./255.); \n        \treturn vec3(0.0,0.0,1.0);\n       } \n    if(i== 4 )\n    {\n        \n        //return vec3(0, 1, 1);\n        \treturn vec3(0.0,1.0,1.0);\n        } \n    if(i== 5 )\n    {\n        //return vec3(85./255., 205./255., 252./255.);\n        return vec3(1.0,0.0,1.0);\n        \n        } \n    if(i== 6 )\n    {\n        \n        ///return  vec3(0.5, 0.8, 0.9);\n        return vec3(1.0,0.5,1.0);\n        } \n        \n    if(i== 7 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n       } \n    if(i== 8 )\n    {\n       \n        \n        return vec3(0.425, 0.56, 0.9); \n       } \n    if(i== 9 )\n    {\n        \n        return vec3(0.5, 0.6, 0.6); \n     } \n    if(i== 10 )\n    {\n        return vec3(0.0, 1.0, 0.0);\n    } \n    \n    if(i== 11 )\n    {\n        return vec3(0.25, 0.25, 0.25);\n    } \n    \n     if(i== 15 )\n    {\n    \t\treturn vec3(1.0,0.0,1.);\n       } \n     if(i== 16 )\n    {\n    \t\treturn vec3(1.0,1.0,0.0);\n     } \n    \n     if(i== 17 )\n    {\n    \treturn vec3(0.8,0.8,0.8);\n     } \n    \n    \n    if(i== 21 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*0.12;\n            marbleP.z += sin(p.y*23.0)*0.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.3);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.4,0.4,0.6),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n    \n    \n    \n     if(i== 23)\n    {\n    \n        \n        return  vec3(0.425, 0.16, 0.6);\t\n        \t\n\t} \n    \n    \n    \n    if(i== 24)\n    {\n      float size = (-mObj.uv.y+.1)/2.5;\n     vec3 color = vec3(0.,0.,0.);\n     color += vec3(mod(floor(mObj.uv.x/size+sin(iTime)) + floor(mObj.uv.y*20./size+iTime),2.)-.8-mObj.uv.y);\n\n     // Lightsource falloff on floor\n     color *= vec3(smoothstep(0.,1.,1.-length(vec2(.2-mObj.uv.x/6.,.6+mObj.uv.y/1.5))));\n        return color;\n\t}    \n    \n    \n    if(i== 25)\n    {\n      float size = (-mObj.p.y+.1)/2.5;\n     vec3 color = vec3(0.,0.,0.);\n     color += vec3(mod(floor(mObj.p.x/size) + floor(mObj.p.y*20./size),2.)-.8-mObj.p.y);\n\n     // Lightsource falloff on floor\n     color *= vec3(smoothstep(0.,1.,1.-length(vec2(.2-mObj.p.x/6.,.6+mObj.p.y/1.5))));\n        return color;\n\t} \n    \n    if(i== 26)\n    {\n        // checkerboard hack\n\t\t\tvec2 cb = floor(mObj.p.xz);\n\t\t\tfloat cb2 = mod(cb.x*1.2 + cb.y, 2.);\n        \treturn vec3(1.4 + 0.1*cb2, 0.3 + 0.85*cb2, 0.35 - 0.3*cb2)*0.8;\n            \n    }   \n    \n    \n    \n    if(i== 27)\n    {\n      vec3 outColor = vec3(0.0);\n      float sinus1 = sin(mObj.uv.x*5.1 +iTime*0.5) * 0.1 - 0.2;\n      float land1 = step(sinus1, mObj.uv.y);\n      vec3 landColor1 = vec3(0.2, 0.4, 0.3);\n      outColor = mix(outColor, landColor1, 1.0 - land1);\n        return outColor;\n    }\n    \n    \n    if (i== 28)\n     {   \n    \tvec3 position=mObj.p;\n        vec3 normal=mObj.normal;\n    \t//position *= scale;\n         position *= 0.25;\n    \t\n    \t//vec3 color = vec3(1.0);\n        vec3 color = vec3(0.98,0.86,0.4);\n    \n    \tcolor = color * 0.75 + 0.25;\n    \tcolor *= normal * .25 + .75;\n    \tfloat checker = sin(position.x * pi * 4.0) * sin(position.y * pi * 4.0) * sin(position.z * pi * 4.0);\n    \tcolor *= step(0.0,checker) * 0.25 + 0.75;\n         return color;\n    }\n    \n    \n    \n}\n\n///--------------------------------------------\n\n\n\n\n\n\n// phong shading\nvec3 p_shadingv2( vec3 v, vec3 n, vec3 eye, vec3 plight_pos1,  vec3 plight_color1 )\n{\n\t// ...add lights here...\n\t\n\tfloat shininess = 16.0;\n\t\n\tvec3 final = vec3( 0.0 );\n\t\n\tvec3 ev = normalize( v - eye );\n\tvec3 ref_ev = reflect( ev, n );\n\t\n\t// light 0\n\t{\n\t\n\t\tvec3 vl = normalize( plight_pos1 - v );\n\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n\t\t\n\t\tfinal += plight_color1 * ( diffuse + specular ); \n\t}\n\t\n\t\n\n    return (final);\n}\n\n\n\n\n//-------------------------------------------\nvec3 Shade(vec3 position, vec3 normal, vec3 direction, vec3 camera)\n{\n    //position *= scale;\n    position *= 0.125;\n    vec3 color = vec3(1.0);\n    \n    color = color * 0.75 + 0.25;\n    \n    color *= normal * .25 + .75;\n    float ambient = 0.1;\n    float diffuse = 0.5 * -dot(normal,direction);\n    float specular = 1.0 * max(0.0, -dot(direction, reflect(direction,normal)));\n    \n    color *= vec3(ambient + diffuse + pow(specular,5.0));\n\n    color *= smoothstep(12.0,6.0,length(position));\n    \n    return color;\n}\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    light_pos1   = vec3( 10.0,10., 0.0);\n\tlight_color1 = vec3( 0.3, 0.2, 1.0 );\n\tlight_pos2   = vec3( 0.0,15.0, -10.0  );\n\tlight_color2 = vec3( 1.0, 1.0, 1.0);\n    \n    vec3 ro = vec3(0.0,15.0,-20.0);  //-eje y  //bien\n\t//ro =get_mouse(ro);\n    vec3 rd = normalize( vec3(uv,1.0));\n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    mObj.uv=uv;\n    mObj.rd=rd;\n    mObj.ro=ro;\n\n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n  \n    vec3 p = (ro + rd * d ); \n    glpRoRd=p;\n    mObj.p=p;\n    \n    float dif=0.5;\n    \n   // vec3 colp1 = GetLightPar(p,light_pos1)*light_color1;\n   // vec3 colp2 = GetLightPar(p,light_pos2)*light_color2;\n    \n    mObj.dist =d;\n    vec3 colobj;\n    \n    vec3 nor= GetNormal( p);\n    mObj.normal=nor;\n    colobj=getSphereColor(int( Obj.tipo));\n    \n    \n    \n    \n    \n    vec3 col2=vec3(0.0);\n    col2+= p_shadingv2( p, nor, ro, light_pos1, light_color1 );\n    col2+= p_shadingv2( p, nor, ro, light_pos2, light_color2 );\n    col2=(col2)/2.0;\n    \n    col2= colobj*col2;\n    col= col2*dif;\n    \n    col = pow(col, vec3(1.0/2.2));  \n    \n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sffRf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sjBDh", "name": "color study", "author": "stduhpf", "description": "studying how colorspaces work so i stop being stupid\nleft: XYZ-SRGB spectrum difference\nright : sRGB-XYZ spectrum difference", "tags": ["colorspace", "spectralrendering"], "likes": 0, "viewed": 184, "date": "1589940361", "time_retrieved": "2024-06-20T20:06:42.905135", "image_code": "\nvec3 linearToSRGB(vec3 linear){\n    return mix(\n        linear * 12.92,\n        pow(linear, vec3(1./2.4) ) * 1.055 - .055,\n        step( .0031308, linear )\n    );\n}\nvec3 srgbToLinear(vec3 srgb){\n    return mix(\n        srgb / 12.92,\n        pow(.947867 * srgb + .0521327, vec3(2.4) ),\n        step( .04045, srgb )\n    );\n}\n\n\n\nvec3 xyYtoXYZ(vec3 xyY){\n    return vec3(xyY.x*xyY.z/xyY.y, xyY.z, (1.-xyY.x-xyY.y)*xyY.z/xyY.y);\n}\n\nvec3 XYZtoxyY(vec3 XYZ){\n    float s = dot(XYZ,vec3(1.));\n    return vec3(XYZ.xy/s,XYZ.y);\n}\n\nconst mat3 sRGBmat = mat3(3.2406 ,-0.9689,0.0557 ,\n                          -1.5372,1.8758 ,-0.2040,\n                          -0.4986,0.0415 ,1.0570 );\nconst mat3 sRGBmatInv = mat3(0.4124,0.2126,0.0193,\n                             0.3576,0.7152,0.1192,\n                             0.1805,0.0722,0.9505);\n\nconst mat3 cRGBmat = mat3(0.41847   ,-0.091169,0.00092090,\n                          -0.15866  ,0.25243  ,-0.0025498,\n                          -0.082835 ,0.015708 ,0.17860   );\nconst mat3 cRGBmatInv = mat3(2.7689,1.    ,0.      ,\n                             1.7517,4.5907,0.056508,\n                             1.1302,0.0601,5.5943  );\n\nconst mat3 rec2020mat = mat3( 1.654001072327064,-0.491962367727270,0.012823156180904,\n  \t\t\t\t\t\t\t -0.328582439150225, 1.224807649257926,-0.031926845969885,\n  \t\t\t\t\t\t\t -0.235295745486861, 0.008763367829582, 0.696316140136240);\n\nconst mat3 rec2020matInv = mat3(0.657021262353320,0.263902442109458,0.000000698474365,\n                                0.181988445346400,0.889285361222104,0.037423246412350,\n                                0.219727028026240,0.077984673908997,1.435658536478509);\n\nconst mat3 lowmat = mat3(4.676069275708541,-1.355340336859568,-0.343392231214305,\n                          -2.776565148174218,2.338468515524017,-1.138156950151501,\n                          -0.702417457071294,-0.238453212389776,4.430411203248263);\nconst mat3 lowmatInv = mat3(0.3524,0.2126,0.08193,\n                             0.4576,0.7152,0.2192,\n                             0.0805,0.0722,.2505);\n\nconst mat3 linsRGB2rec2020 = mat3(0.508498879219063,7.149744544518886e-04,-0.014531283587229,\n                           \t   \t  0.296721021771517,0.803820685906905,0.109308963621570,\n                               \t  0.031782878191668,0.006517710499047,0.658351876756886);\n\nconst mat3 rec20202linsRGB = mat3(1.965066666697664 ,-0.002102387643990,0.043722440585856 ,\n                                  -0.713441332134416,1.246498953170958 ,-0.222708755337426,\n                                  -0.087803304716027,-0.012238894834515,1.519038619766569 );\n\nconst mat3 sRGB2cust = mat3(0.459948689438523,0.487503161496537,0.308936806856135,\n                        1.101525882302790,1.326330267248322,0.948972794836465,\n                        1.142282121705257,0.972197437403970,2.386717475045308);\nconst mat3 cust2sRGB = mat3(15.881055316759070,-6.111620993518249,0.374371724126280,\n                             -10.939346494458402,5.273947646023810,-0.680962903808598,\n                             -3.144670876144256,0.776747574210547,0.517192451815031);\n\n\nfloat gaussian(float x,float al, float mu, float s1, float s2){\n    float y = x-mu;\n    y/=y<0.?s1:s2;\n    return al*exp(-y*y*.5);\n}\n\nvec3 lambdatoXYZ(float wl){\n    return vec3( gaussian(wl, 1.056, 599.8, 37.9, 31.0)+gaussian(wl, 0.362, 442.0, 16.0, 26.7)+ gaussian(wl, -0.065, 501.1, 20.4, 26.2)\n                ,gaussian(wl, 0.821, 568.8, 46.9, 40.5)+gaussian(wl, 0.286, 530.9, 16.3, 31.1)\n                ,gaussian(wl, 1.217, 437.0, 11.8, 36.0)+gaussian(wl, 0.681, 459.0, 26.0, 13.8));\n}\n\nfloat red(float wl){\n    float a = 0.;\n    float b1 = wl-435.;\n    a+=exp2(-b1*b1*.004)*.27;\n    float b2 = wl-601.;\n\ta+=exp2(-b2*b2*(1.-sign(b2)*.4)*.001)*2.5;\n    return a;\n}\n\nfloat green(float wl){\n    float a = 0.;\n    float b1 = wl-540.;\n    a+=exp2(-b1*b1*.0008)*1.5;\n    return a;\n}\n\nfloat blue(float wl){\n    float a = 0.;\n    float b1 = wl-450.;\n    a+=exp2(-b1*b1*.0015)*1.9;\n    return a;\n}\n\nvec3 lambdatosRGB(float wl){\n    return vec3(red(wl),green(wl),blue(wl));\n}\n\n\nfloat dfSeg( vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat blackbody(float wl, float T){\n    float h = 6.62607004e-34; // Planck constant\n    float k = 1.38064852e-23; // Boltzmann constant\n    float c = 299792458.;// Speed of light\n   \twl*=1e-9;\n    return  2.*h*(c*c)/(wl*wl*wl*wl*wl*(exp(h*c/(T*wl*k))-1.));\n}\n\nvec3 bbXYZ(float T){\n    int samples = 25;\n    float mi = 300.,ma = 800.;\n    float st = (ma-mi)/float(samples);\n    vec3 ret = vec3(0);\n    vec3 tmp = vec3(0);\n    for(float l = mi ; l < ma ; l += st){\n    \tvec3 XYZ = lambdatoXYZ(l);\n        float bb = blackbody(l,T);\n        XYZ*=bb;\n        ret+=st*(XYZ+tmp)/2.;\n        tmp = XYZ;\n    }\n    return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float mRes = min(iResolution.x,iResolution.y);\n    vec2 off = mRes==iResolution.x?vec2(0,1.-iResolution.y/iResolution.x)*.5:vec2(1.-iResolution.x/iResolution.y,0)*.5;\n\n    vec2 uv = fragCoord/mRes+off;\n\t\n    float luninance = sRGBmatInv[2].y; \n    //lumiance of pure blue pixel on srgb screen\n        \n    vec3 redCorner = vec3(.637,.326,luninance);\n    vec3 greenCorner = vec3(.296,.600,luninance);\n    vec3 blueCorner = vec3(.148,.059,luninance);\n    \n    vec3 xyY = vec3(uv,luninance);\n    vec3 XYZ = xyYtoXYZ(xyY);\n        \n    vec3 lsRGB = sRGBmat*XYZ;\n    \n    vec3 sRGB = linearToSRGB(lsRGB/max(max(lsRGB.r,lsRGB.g),lsRGB.b));\n    \n    vec3 cieRGB = cRGBmat*XYZ;\n    \n\tvec3 rec2020 = rec2020mat*XYZ;\n    \n    vec3 desat = 0.*rec2020==fract(rec2020)?.1+.8*clamp(lsRGB,0.,1.):clamp(lsRGB,0.,1.);\n    \n    vec3 col = lsRGB==fract(lsRGB)?sRGB:linearToSRGB(desat);\n\n    {\n        vec2 p = vec2(1./3.);\n        if(distance(uv,p)<2./mRes)col=vec3(1.);\n    }\n    {\n        vec2 lp = redCorner.xy;\n        for(float T = 0.;T<20000.;T+=500.){\n            vec3  XYZ = bbXYZ(T);\n            vec3 xyY = XYZtoxyY(XYZ);\n            vec2 p = xyY.xy;\n            xyY.z=.95;\n            if(dfSeg(uv,p,lp)<2./mRes)col=linearToSRGB(sRGBmat*xyYtoXYZ(xyY));\n            lp = p;\n        }\n    }\n\t\n    {\n    vec2 pxy = vec2(-1.);\n    vec2 lpxy = vec2(-1.);\n    for(float wl=300.;wl<=800.;wl+=2.5){\n        vec3 XYZ = lambdatoXYZ(wl);\n        vec3 xyY = XYZtoxyY(XYZ);\n        if(pxy.x>0. && dfSeg(uv,xyY.xy,pxy)<2./mRes){\n            col=linearToSRGB(sRGBmat*XYZ);\n            break;\n        }\n        pxy = xyY.xy;\n        \n        vec3 lRGB = lambdatosRGB(wl);\n        vec3 lXYZ = (sRGBmatInv)*lRGB;\n        vec3 lxyY = XYZtoxyY(lXYZ);\n        if(lpxy.x>0. && dfSeg(uv,lxyY.xy,lpxy)<2./mRes){\n            col=linearToSRGB(lRGB);\n            break;\n        }\n        lpxy = lxyY.xy;\n    }\n    }\n\n    \n    {\n    float wl = 200.+fract(iTime*.04)*700.;\n    vec3 XYZ = lambdatoXYZ(wl);\n    vec3 xyY = XYZtoxyY(XYZ);\n    vec3 lRGB = lambdatosRGB(wl);\n    vec3 lXYZ = (sRGBmatInv)*lRGB;\n    vec3 lxyY = XYZtoxyY(lXYZ);\n    if(dfSeg(uv,lxyY.xy,xyY.xy)<1./mRes){\n        col=linearToSRGB(lRGB);\n    }\n    vec3 xyY2 = XYZtoxyY(sRGBmatInv*clamp(sRGBmat*XYZ,0.,1.));\n    if(dfSeg(uv,xyY2.xy,xyY.xy)<1./mRes){\n        col=vec3(1);\n    }\n     \n    if(uv!=fract(uv))\n        col=1.*sign(uv.x)*(clamp(linearToSRGB(lRGB),0.,1.)-clamp(linearToSRGB(sRGBmat*XYZ),0.,1.));\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sjBDh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sjBRG", "name": "Sinewave pattern", "author": "timeisbeautifulhere", "description": "I couldn't replicate this if I tried", "tags": ["procedural", "wave", "sine", "pattern", "accident"], "likes": 0, "viewed": 46, "date": "1590279154", "time_retrieved": "2024-06-20T20:06:43.232459", "image_code": "\n#define PI 3.14159\n\n#define FUNK_SPEED 2.0\n#define SCROLL_SPEED 3.0\n\n//Transform a value that to something between [-1,1].\n//A wrapping function gone horribly wrong.\nfloat weirdWrapFunk(float val){\n    \n    //My mini algo only works for positive numbers.\n    //Multiply by multiples of range (2) to make number\n    //positive without affecting result.\n    if(val < 0.0){\n    \tfloat factor = abs(floor(val));\n        val = val + (2.0 * factor);\n    }\n    \n    //f(x) = x - floor((x-minx)/(max-min)) - 1\n    float res = (val) - floor((val+1.0)/2.0) - 1.0;\n    \n    return res;\n}\n\n//Check if in sine wave.\n//Expects uv to be in [-1,1]\nbool checkInSine(vec2 uv){\n    //Sine wave = Asine(wt + 0)\n    \n    //get x in radians\n    float x = (uv.x + 1.0) * (PI);\n    \n    float expected = sin(x);\n    float actual = uv.y;\n    \n    //Apply weird transform, then wrap to [-1,1]\n    expected = weirdWrapFunk(expected + (iTime * (SCROLL_SPEED)));\n    expected = mod(expected, 2.0) - 1.0;\n    actual = weirdWrapFunk(actual + (iTime * FUNK_SPEED));\n    actual = mod(actual, 2.0) - 1.0;\n    \n    \n    return abs(expected - actual) < 0.1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Default shadertoy junk\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    fragColor = vec4(col,1.0);\n    \n    //normalize [-1,1]\n    uv = ((2.0*fragCoord) / iResolution.xy) - 1.0;\n    \n    if(checkInSine(uv)){\n        fragColor = vec4(vec3(1.0,1.0,1.0),1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sjBRG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sjBzc", "name": "Raymarching glitch sphere", "author": "0xspig", "description": "Followed Art of Codes raymarching tutorial and turned it into this.", "tags": ["raymarching"], "likes": 3, "viewed": 79, "date": "1590531228", "time_retrieved": "2024-06-20T20:06:43.232459", "image_code": "#define MAX_STEPS 300\n#define MAX_DIST 75.\n#define SURF_DIST .001\n\n//abs(sin(tan(p.z)*sin(p.y/p.x)/tan(iTime)))\n\nfloat GetDist(vec3 p)\n{\n\tvec4 s = vec4(cos(iTime), 0., sin(iTime) *2.+ 2.5, abs(sin(tan(p.z)*sin(p.y/p.x)/tan(iTime))));\n    \n    float sphereDist = length(p - s.xyz) - s.w;\n    float planeDist = sin(length(p.xy)) + cos(p.z /p.y + iTime * 3.) +1.;\n    \n    return min(sphereDist, planeDist);\n    \n}\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n\tfloat dO = 0.;\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n    \tvec3 p = ro + rd * dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO > MAX_DIST || abs(dS) < SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n    \tGetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx)    \n    );\n    \n    return normalize(n);\n}\n    \n\nfloat GetLight(vec3 p)\n{\n    vec3 lightPos = vec3(0., 3., .0);\n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    \n    float d = RayMarch(p+n*SURF_DIST*5., l);\n    \n  \tfloat dif = dot(l, n);\n    \n    if(d < length(lightPos - p))\n       dif *= smoothstep(0., .7, d);\n        \n\treturn dif;\t\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n \n    //sound\n    int tx = int((uv.x + 1.)*512.0/2.);\n    float wave = texelFetch( iChannel0, ivec2(tx,1), 0 ).x;\n    \n   \tvec3 col = vec3(uv.x, uv.y, 1.);\n    \n    vec3 ro = vec3(0.,.1, -10);\n    vec3 lp = vec3(0., 0., 2.);\n    vec3 f = normalize(lp - ro);\n    vec3 r = cross(f, vec3(.0, -1., .0));\n    vec3 u = cross(f, r);\n    \n    float zoom = 2.;\n    \n    vec3 i = (ro + f * zoom) + uv.x * r + uv.y*u;\n    \n    vec3 rd = normalize(i - ro);\n    \n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d;\n    \n    float l = GetLight(p);\n    col = l * vec3(.5,.6,.4);\n\tcol *= sin(uv.x/sin(uv.x/sin(iTime)*uv.y*30.)) * tan(sin(uv.y/uv.x*-300.*sin(iTime))) + .2;\n    col.g /= abs(cos(iTime/2.)* uv.x/uv.y/abs(sin(iTime))) + .5;\n    col.r /= abs(sin(iTime/4.)* uv.y/uv.x/abs(cos(iTime)))+ .5;\n    col.b /= ((wave * wave)-.5)*6.+sin(cos(iTime*uv.x*uv.x)/(uv.y*uv.y*tan(iTime)));\n\n\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XljGRV", "previewfilepath": "https://soundcloud.com/tylersmckee/opening", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/tylersmckee/opening", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sjBzc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sjBzW", "name": "Triangle mesh renderer", "author": "TomF", "description": "A basic software renderer for an arbitrary triangle mesh. May be a useful basis for other projects.\n\nThis version generates the entire mesh for every pixel, which is obviously slow!\nNote this rasteriser does not obey the strict fill rules.", "tags": ["triangles", "barycentric", "mesh", "rasteriser"], "likes": 7, "viewed": 561, "date": "1589667376", "time_retrieved": "2024-06-20T20:06:44.250789", "image_code": "\n\n#define BACKFACE_CULL true\n#define TEXTURED true\n\n\nstruct Vertex\n{\n    vec4 Pos;\n    vec2 Uv;\n};\n\n// Test a position against a triangle and return\n// the perspective-correct barycentric coordinates in the triangle\n// Note the z value in the vertex is ignored, it's the w that matters.\n// This is the fast but hard-to-read version.\n// See https://www.shadertoy.com/view/wdjfz1 for the more readable version.\nvec2 BaryTri3D ( vec2 pos, Vertex v1, Vertex v2, Vertex v3 )\n{\n    // 1/w already done by caller\n    vec3 recipw = vec3 ( v1.Pos.w, v2.Pos.w, v3.Pos.w );\n\n    vec2 posv1 = pos - vec2(v1.Pos);\n    \n    vec2 v21 = vec2(v2.Pos) - vec2(v1.Pos);\n    vec2 v31 = vec2(v3.Pos) - vec2(v1.Pos);\n    \n    float scale = v21.x * v31.y - v21.y * v31.x;\n    float baryis = ( posv1.x * v31.y - posv1.y * v31.x );\n    float baryjs = ( posv1.y * v21.x - posv1.x * v21.y );\n    float baryks = ( scale - baryis - baryjs );\n    \n    float newis = recipw.y * baryis;\n    float newjs = recipw.z * baryjs;\n    float newws = recipw.x * baryks + newis + newjs;\n    \n    // ...and project back.\n    float rnewws = 1.0/newws;\n    float perspi = newis * rnewws;\n    float perspj = newjs * rnewws;\n        \n    return vec2 ( perspi, perspj );\n}\n\n\nconst int GridW = 5;\nconst int GridH = 5;\nconst int NumVerts = GridH*GridW*2;\nconst int NumTris = (GridH-1)*(GridW-1)*2*2;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // NDC (-1 to +1)\n    vec2 uv = -1.0 + 2.0f * (fragCoord/iResolution.xy);\n    \n    float wobble = float(iTime);\n    \n    // Create the mesh. This would of course be done offline.\n    Vertex Verts[NumVerts];\n    for ( int w = 0; w < GridW; w++ )\n    {\n        for ( int h = 0; h < GridH; h++ )\n        {\n            Vertex Vert0, Vert1;\n            Vert0.Pos.x = float(w - GridW/2);\n            Vert0.Pos.y = float(h - GridH/2);\n            float wf = -2.0 + float(w);\n            float hf = -3.0 + float(h);\n            float d = sqrt(wf*wf + hf*hf);\n            Vert0.Pos.z = 0.3 * cos (d * 2.0 + wobble);\n            Vert0.Pos.w = 1.0f;\n            Vert0.Uv.x = float(w) / float(GridW-1);\n            Vert0.Uv.y = float(h) / float(GridH-1);\n            \n            Vert1.Pos = Vert0.Pos;\n            Vert1.Pos.z += 1.0f;\n            Vert1.Uv = Vert0.Uv;\n            \n            int Index = (w*GridH+h)*2;\n            Verts[Index+0] = Vert0;\n            Verts[Index+1] = Vert1;\n        }\n    }\n\n    int Indices0[NumTris];\n    int Indices1[NumTris];\n    int Indices2[NumTris];\n    for ( int w = 0; w < GridW-1; w++ )\n    {\n        for ( int h = 0; h < GridH-1; h++ )\n        {\n            int VertIndex = (w*GridH+h)*2;\n            int TriIndex = (w + (GridH-1)*h) * 2 * 2;\n            Indices0[TriIndex+0] = VertIndex  ;\n            Indices1[TriIndex+0] = VertIndex  +GridH*2;\n\t\t\tIndices2[TriIndex+0] = VertIndex  +2;\n            Indices0[TriIndex+1] = VertIndex+1;\n            Indices2[TriIndex+1] = VertIndex+1+GridH*2;\n\t\t\tIndices1[TriIndex+1] = VertIndex+1+2;\n            \n            Indices2[TriIndex+2] = VertIndex  +GridH*2;\n            Indices0[TriIndex+2] = VertIndex  +GridH*2+2;\n\t\t\tIndices1[TriIndex+2] = VertIndex  +2;\n            Indices1[TriIndex+3] = VertIndex+1+GridH*2;\n            Indices0[TriIndex+3] = VertIndex+1+GridH*2+2;\n\t\t\tIndices2[TriIndex+3] = VertIndex+1+2;\n        }\n    }\n    \n    float hfov = 0.6;\n    float vfov = hfov * iResolution.y / iResolution.x;\n    float zfar = 10.0f;\n    float znear = 1.0f;\n    float q = zfar/(zfar-znear);\n    \n    mat4 ProjMat;\n    ProjMat[0] = vec4 ( 1.0/hfov, 0.0f, 0.0f, 0.5f );\n    ProjMat[1] = vec4 ( 0.0f, 1.0/vfov, 0.0f, 0.5f );\n    ProjMat[2] = vec4 ( 0.0f, 0.0f, q, 1.0f );\n    ProjMat[3] = vec4 ( 0.0f, 0.0f, -q*znear, 0.0f );\n    \n    \n    mat4 TotalMat;\n    mat4 ObjMat1;\n    mat4 ObjMat2;\n    \n    float a1 = iMouse.x * 0.01;\n    float a2 = iMouse.y * 0.01;\n    float zdist = 8.0;\n    ObjMat1[0] = vec4 ( cos(a1),  sin(a1), 0.0, 0.0 );\n    ObjMat1[1] = vec4 ( sin(a1), -cos(a1), 0.0, 0.0 );\n    ObjMat1[2] = vec4 ( 0.0,          0.0, 1.0, 0.0 );\n    ObjMat1[3] = vec4 ( 0.0,          0.0, 0.0, 1.0 );\n    ObjMat2[0] = vec4 ( 1.0, 0.0,          0.0, 0.0 );\n    ObjMat2[1] = vec4 ( 0.0, cos(a2),  sin(a2), 0.0 );\n    ObjMat2[2] = vec4 ( 0.0, sin(a2), -cos(a2), zdist );\n    ObjMat2[3] = vec4 ( 0.0, 0.0,          0.0, 1.0 );\n    \n    TotalMat = ObjMat1 * ObjMat2;\n    TotalMat = TotalMat * ProjMat;\n\n    // Background colour\n    vec3 col;\n    col.xy = uv.xy;\n    col.z = 0.0;\n\n    Vertex ScreenVert[NumVerts];\n    for ( int VertNum = 0; VertNum < NumVerts; VertNum++ )\n    {\n        vec4 Pos = Verts[VertNum].Pos;\n        \n        vec4 ScrPos = Pos * TotalMat;\n        float rw = 1.0/ScrPos.w;\n        ScrPos.x *= rw;\n        ScrPos.y *= rw;\n        ScrPos.z *= rw;\n        ScrPos.w = rw;\n        \n        ScreenVert[VertNum].Pos = ScrPos;\n        ScreenVert[VertNum].Uv = Verts[VertNum].Uv;\n    }\n    \n    float NearestZ = 10000.0f;\n    for ( int TriNum = 0; TriNum < NumTris; TriNum++ )\n    {\n        Vertex v1 = ScreenVert[Indices0[TriNum]];\n        Vertex v2 = ScreenVert[Indices1[TriNum]];\n        Vertex v3 = ScreenVert[Indices2[TriNum]];\n        vec3 bary;\n        bary.xy = BaryTri3D ( uv, v1, v2, v3 );\n        bary.z = 1.0 - bary.x - bary.y;\n\n        // You need to do the UV coord generation outside all the conditionals,\n        // otherwise you don't get good gradients at the edges.\n        // HOWEVER - what actually happens is the compiler spots you only *use* the UV\n        // values inside the conditionals and drags the calculation inside,\n        // which then breaks the gradients! So to stop this, I added a totally\n        // spurious test of the UV coords to the barycentric test.\n        vec2 uv = bary.z * v1.Uv + bary.x * v2.Uv + bary.y * v3.Uv;\n        \n        if ( ( bary.x >= 0.0 ) &&\n             ( bary.y >= 0.0 ) &&\n             ( bary.z >= 0.0 ) &&\n             ( uv.x + uv.y > -10.0 ) ) // see above\n        {\n            // Interpolate Z\n            // Note this is linear Z, not the strange Z that most rasteriser use\n            // In this case, that's fine.\n            float Z = bary.z * v1.Pos.z + bary.x * v2.Pos.z + bary.y * v3.Pos.z;\n            if ( NearestZ > Z )\n            {\n                NearestZ = Z;\n            \n                if ( TEXTURED )\n                {\n                    vec4 tex = texture ( iChannel0, uv );\n                    col.xyz = tex.xyz;\n                }\n                else\n                {\n                    col.xy = bary.xy;\n                    col.z = 1.0;\n                    if ( fract ( bary.x * 4.0 ) < 0.05 ) { col.z = 0.0; }\n                    if ( fract ( bary.y * 4.0 ) < 0.05 ) { col.z = 0.0; }\n                }\n            }\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sjBzW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sjfRG", "name": "voxel-traversal-algorithm", "author": "vizaxo", "description": "voxel", "tags": ["voxel"], "likes": 0, "viewed": 22, "date": "1590359145", "time_retrieved": "2024-06-20T20:06:44.250789", "image_code": "const bool[6*6] data = bool[](false, false, true, true, false, false,\n                              false, true, true, true, true, false,\n                              true, true, true, true, true, true,\n                              true, true, true, true, true, true,\n                              false, true, true, true, true, false,\n                              false, false, true, true, false, false);\n\nconst float pi = 3.141592;\nconst float tau = 2.0*pi;\n\n//#define TIME 0.5\n#define TIME iTime/2.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float cells = 50.0;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 p = uv * cells;\n    \n    vec2 offset = fract(p);\n    vec2 cell = floor(p);\n    vec2 ro = vec2(20, 20);\n    vec2 rd = normalize(vec2(sin(TIME), cos(TIME)));\n    \n    vec2 hyp = p - ro; //hypotenuse\n    float theta = acos(dot(hyp, rd) / length(hyp)); //angle between ray and p\n        \n    float d = length(hyp) * sin(theta);\n    \n    bool posT = theta <= tau/4.0 || theta > 3.0*tau/4.0;\n    float ray = posT ? 1.0-smoothstep(d, 0.00, 0.007) : 0.0;\n    \n    \n    \n    float phi = mod(atan(rd.y, rd.x), tau);//angle between ray and horizontal\n        //voxel intersection algorithm\n    float x = floor(ro.x);\n    float y = floor(ro.y);\n    float stepX = rd.x > 0.0 ? 1.0 : -1.0;\n    float stepY = rd.y > 0.0 ? 1.0 : -1.0;\n    \n    float tMaxX, tMaxY;\n    if (phi < tau/4.0 || phi >= 3.0*tau/4.0)\n    \ttMaxX = (1.0 - fract(ro.x)) / cos(phi);\n\telse\n        tMaxX = fract(ro.x) / cos(pi - phi);\n \n    if (phi < tau/2.0)\n    \ttMaxY = (1.0 - fract(ro.y)) / sin(phi);\n    else\n        tMaxY = fract(ro.y) / sin(tau - phi);\n\n    float tDeltaX = stepX * 1.0 / cos(phi);\n    float tDeltaY = stepY * 1.0 / sin(phi);\n        vec4 currentCell = vec4(0,0,0,0);\n\n    int maxTrace = 50;\n    if (cell == vec2(x,y)) currentCell += vec4(1.0 / float(maxTrace), 1.0 / float(maxTrace), 0, 0);\n\n    for (int i = 0; i < maxTrace-1; i++) {\n        if (tMaxX < tMaxY) {\n            tMaxX += tDeltaX;\n            x += stepX;\n        } else {\n            tMaxY += tDeltaY;\n            y += stepY;\n        }\n        if (cell == vec2(x,y)) currentCell += vec4(float(i+2) / float(maxTrace), float(i+2) / float(maxTrace), 0, 0);\n    }\n    \n    float t =tMaxY + 2.0*tDeltaY*stepY;\n    vec2 point = ro + t*rd;\n    \n    float target = smoothstep(0.1, 0.0, length(p-point));\n    \n    int index = int(cell.y*6.0 + cell.x );\n    bool inBounds =  cell.x < 6.0 && cell.y < 6.0;\n    \n    vec4 cellColor = inBounds ? (data[index] ? vec4(1, 0, 0, 0) : vec4(0,0,0,0)) : vec4(0,0,0,0);\n    \n    \n\n    //fragColor = cellColor + vec4(0, target, target, 0) + 0.7*(vec4(ray) + vec4(cell / cells, 0, 0));\n    fragColor = ray + currentCell + vec4(cell / cells, 0, 0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sjfRG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sjfz1", "name": "3DS Homebrew", "author": "lambmeow", "description": "Recreated the background for the 3ds homebrew channel. \nThis one was a lot of fun.", "tags": ["3ds", "homebrew"], "likes": 2, "viewed": 277, "date": "1589505519", "time_retrieved": "2024-06-20T20:06:44.250789", "image_code": "#define time iTime\n\nfloat wave(float x)\n{\n    return sin(x * 10.0 + time)* 0.5 * sin(x * 0.5 + time) * .2 + 0.5;\n}\n\n\n//stolen from iq\n//https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdRoundedBox( vec2 p, vec2 b, vec4 r )\n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\n\nfloat drawBox(vec2 uv, vec2 p, vec2 s)\n{\n    return step(1.0,1.0-sdRoundedBox(uv - p, vec2(.23,.35) * s * 0.7, vec4(0.1) * length(s * 0.7)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(0.2, .5,1);\n    \n    float line = step( .99, 1.0 - (abs(wave(uv.x) - uv.y )));\n    col += line * vec3(0, .4, 0);\n    float grad = step(uv.y, wave(uv.x)) + line/2.0;\n    float b = drawBox(uv, vec2(sin(time * 0.5) * .4 + 0.5, mod(time, 2.0)) , vec2(.23));\n    for(int i = 1; i < 101; i++)\n    {\n        b += drawBox(uv, vec2((sin(float(i))) + sin(time * 5.0 + float(i)) * .09 + 0.5, \n                              mod((time* clamp(((14.0/float(i))),6.0, 20.0) )/float(i), 2.0)) , vec2(.23)) * clamp(1.3-uv.y * 1.25, 0.,1.0);\n    }\n    b*= 0.12;\n    fragColor = vec4( col  +b + grad * vec3(0.1 ,.2, 1),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sjfz1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sjfzV", "name": "Outline 2020/23 may/MsieurSoleil", "author": "MonsieurSoleil", "description": "I lost control over my shader :D, so the result was kinda unexpected.\n\nI wanted to use reflections, and I played, with a \"broken\" shader. (Meaning of broken, Is that it did not what I wanted him to do).\n", "tags": ["livecode"], "likes": 3, "viewed": 83, "date": "1590428912", "time_retrieved": "2024-06-20T20:06:44.250789", "image_code": "#define time iTime * 0.5\n#define mod01 floor(mod(time * 2.0, 4.0))\n#define mod02 floor(mod(time * 4.0, 2.0))\n#define mod03 floor(mod(time * 2.0, 16.0))\n#define mod04 floor(mod(time, 4.0))\n\nfloat gg = 0.0;\n\nstruct matter\n{\n  float mat;\n  int type;\n};\n\nmat2 rot(float a)\n{\n  float ca = cos(a);\n  float sa = sin(a);\n  \n  return mat2(ca, -sa, sa, ca);\n}\n\n//I WONT PANICK I'M FRENCH MUAHHAAHAHAHAAHAHAHH\nvec2 rep(vec2 p, float repeat)\n{\n  return (floor(abs(p)/repeat - 0.5) - 0.5) * repeat;\n}\n// ZBLEH !!!!\n\nfloat sphere(vec3 p, float r)\n{\n  return length(p)-r;\n}\n\n// TRROOOOOPAAAAAASKKAAAYAAAAAAAA\nfloat box(vec3 p, vec3 s)\n{\n  p = abs(p) - s;\n  return max(p.x, max(p.y, p.z));\n}\n\nfloat rnd(float t)\n{\n  return fract( sin(t*423.1256) * 4523.1524);\n}\n\nfloat curve(float t)\n{\n  return mix(\n  rnd(floor(t)),\n  rnd(floor(t) + 1.0),\n  smoothstep(0.0, 1.0, fract(t)));\n}\n\nfloat smin(float a , float b, float k)\n{\n  float h = clamp( 0.5 - 0.5 * (a - b) / k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);  \n}\n\nmatter map(vec3 p)\n{\n  matter mat;\n  \n  float mat01, mat02, mat03, mat04;\n  \n  vec3 p02 = p;\n  vec3 p03 = p;\n  vec3 p04 = p;\n  \n  p04.xz = rep(p.xz, 4.0);\n  p04.xz *= rot(p.y * 0.01 + sin(time * 0.1));\n \n  \n  p02.xy *= rot(sin(p.z * 0.05 + time * 0.2)) * 2.0 * mod03 + 1.0;\n  \n  p03.xy *= rot(sin(p.z * 0.01 + (curve(time * 1.0) * 12.2 * mod04))) * 2.5;\n  \n  \n   p.xy *= rot(sin(p.z * 0.05 + curve(time))) * 1.5;\n  \n  float scale = 0.5 + 0.5 * mod01 + 0.5 * mod03 + 0.2 * mod02 * 0.05;\n  \n  mat.mat = sphere(p, scale);\n  \n  mat01 = box(p + vec3(curve(time * 2.0) * 12.0, curve(time * 4.0) * 8.0, 0.0), vec3(0.1, scale * 1.5, 100000.0));\n  \n  //mat02 = box(p02 + vec3(5.0, 2.0, 0.0), vec3(0.1, scale, 100000.0));\n  //mat02 = min(mat02, box(p02 + vec3(-5.0, 2.0, 0.0), vec3(0.01, scale, 1000000.0)));\n   //mat02 = min(mat02, box(p02 + vec3(5.0, 6.0, 0.0), vec3(0.01, scale, 1000000.0)));\n   //mat02 = min(mat02, box(p02 + vec3(-10.0, 4.0, 0.0), vec3(0.1, scale, 1000000.0)));\n   //mat02 = min(mat02, box(p02 + vec3(10.0, 4.0, 0.0), vec3(0.1, scale, 1000000.0)));\n   \n   //mat02 = min(mat02, box(p03 + vec3(15.0, 8.0, 0.0), vec3(0.2, scale, 1000000.0)));\n   \n   //mat02 = min(mat02, box(p04 + vec3(8.0, 4.0, 0.0), vec3(0.01, scale, 1000000.0)));\n  // mat02 = min(mat02, box(p04 + vec3(6.0, 4.0, 0.0), vec3(0.01, scale, 1000000.0)));\n   \n   \n  mat03 = -box(p03, vec3(55.0 + (mod04 * 15.0),55.0 + (mod04 * 15.0), 1000000.0));\n  \n  \n  \n  //mat04 = box(p04, vec3(sin(mod01) * 2.5, sin(mod01) * 2.5, 1000000.0));\n  //mat03 = smin(mat03, mat04 , pow(10.0 * curve(abs(sin(time * 2.0))), 2.6));\n  \n  //mat.mat = min(mat01, mat02);\n  mat.mat = min(mat01, mat03);\n  \n \n  \n  if(mat.mat < 0.01)\n  {\n    mat.type = 1;\n  }\n  \n  gg += 0.1/(0.9 +mat01*mat01);\n  \n  \n  \n  \n  return mat;\n}\n\nvec3 normals(vec3 p)\n{\n  vec2 uv = vec2(0.01, 0.0);\n  \n  return normalize(map(p).mat - vec3(map(p - uv.xyy).mat, map(p - uv.yxy).mat, map(p - uv.yyx).mat ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n    \n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 o = vec3(curve(time * 2.0) * 6.0, curve(time) * 4.0 + 6.5, 10.0 + curve(time * 4.5) * 325.0), t = vec3(curve(time * 2.0) * 6.0, 8.5, curve(time* 4.5) * 325.0);\n  vec3 fr = normalize( t - o );\n  vec3 ri =  normalize( cross( vec3(0.0, 1.0, 0.0), fr) );\n  vec3 up =  normalize( cross( fr, ri ) );\n  vec3 dir = normalize( fr + uv.x * ri + uv.y * up );\n  vec3 p = o + dir * 0.5;\n  \n  vec3 col = vec3(0.0);\n  \n  matter mat;\n  float shad, d;\n  for(int i = 0; i < 120; ++i)\n  {\n   p.xy *= rot(sin(time * 0.1 * mod01) * 0.001);\n    p.xz *= rot(sin(time * 0.01 * mod01) * 0.0001);\n    \nmat = map(p);\n\nif(mat.mat < 0.001)\n{\n  if(mat.type == 1)\n  {\n    mat.mat = 1.5 * (mod03 / 16.0);\n    \n     vec3 n = normals(p);\n    \n    dir = reflect(dir, n);\n    \n  } else {\n    \n    break;\n  }\n  \n  shad = clamp( 1.0 - (float(i)/200.0), 0.0, 1.0);\n}  \n\np += mat.mat * dir;\nd+= mat.mat;\n\n  col += mix(vec3(0.0, 0.5, 0.0), vec3(0.0, 0.0, 1.0), sin((p.z * 0.01 * mod01) + time )) * gg * (0.0002 * (mod01/6.0));\n  }\n  \n  col += shad * vec3(1.0);\n  \n float fog = clamp(1.0 - (d/100.0), 0.0, 1.0);\n  \n  vec3 sky = mix(vec3(1.0 * mod01, 0.0, 0.0), vec3(0.0, 0.5, 1.2), uv.y - 0.5);\n  col += sky * pow(0.3 * 2.5* (mod03 / 16.0), 1.6);\n  \n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sjfzV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3slBDl", "name": "Square + Circle SDF", "author": "blackle", "description": "an exact SDF that generalizes the circle and the square. it can also give the closest point on the surface!", "tags": ["sdf"], "likes": 6, "viewed": 334, "date": "1589286687", "time_retrieved": "2024-06-20T20:06:44.753777", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nvec2 nonzero_sign(vec2 p) {\n    return max(sign(p),vec2(0))*2.-1.;\n}\n\nmat2 sort(vec2 p) {\n    if (p.x > p.y) return mat2(0,1,1,0);\n    return mat2(1);\n}\n\nconst float PI = acos(-1.);\nvec3 rounded_square(vec2 p, float radius, float sharpness, float offset) {\n    //first we abs and sort the vector so we can work with the symmetries of the square\n    vec2 sgn = nonzero_sign(p);\n    p = abs(p);\n    mat2 perm = sort(p);\n    p *= perm;\n    p.y += sharpness;\n\n    //get closest point on defining sphere for axis\n    float rad = sharpness + radius;\n    vec2 closest = normalize(p)*rad;\n\n    //normalize the closest point so it lies within the axis\n    if (closest.x > closest.y-sharpness) {\n        float k = sharpness;\n        float y = closest.y;\n        closest.y = (k + sqrt(2.*rad*rad-k*k))/2.;\n        closest.x = closest.y - k;\n    }\n\n    //calculate the distance\n    float side = sign(length(p)-rad);\n    float dist = length(p-closest)*side;\n\n    //map the closest point back to global coordinates\n    closest += normalize(p-closest)*offset*side;\n    if (side == 0.) closest = p;\n    vec2 closest_global = (closest-vec2(0,sharpness))*transpose(perm)*sgn;\n    return vec3(dist-offset, closest_global);\n}\n\nvec3 shadeDistance(float d) {\n    float dist = d*150.0;\n    float banding = max(sin(dist), 0.0);\n    float strength = sqrt(1.-exp(-abs(d)*2.));\n    float pattern = mix(strength, banding, (0.6-abs(strength-0.5))*0.3);\n    \n    vec3 color = vec3(pattern);\n    \n    color *= d > 0.0 ? vec3(1.0,0.56,0.4) : vec3(0.4,0.9,1.0);\n\n    return color;\n}\n\nfloat antialias(float x) {\n    float pixelsize = 3./iResolution.y;\n    return smoothstep(-pixelsize, pixelsize, x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n    uv*=3.; mouse*=3.;\n    \n    float radius = sin(iTime)*0.25+0.75;\n    float sharpness = pow(asin(sin(iTime*2.5))/PI+1.,8.);\n    float offset = sin(iTime*0.65)*0.25+0.25;\n    \n    float dist = rounded_square(uv, radius, sharpness, offset).x;\n    fragColor = vec4(shadeDistance(dist), 1.);\n\n    float mousedist = rounded_square(mouse, radius, sharpness, offset).x;\n    vec2 mousepoint = rounded_square(mouse, radius, sharpness, offset).yz;\n    if (iMouse.z > 0.) {\n        float pixelsize = 3./iResolution.y;\n        fragColor *= antialias(distance(mouse, uv) - abs(mousedist))*0.5+0.5;\n        fragColor = mix(vec4(1,0,0,0), fragColor, antialias(distance(mousepoint, uv) - 0.03));\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc0-1.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3slBDl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3slBW7", "name": "lissajous_v002", "author": "darkczar", "description": "hiya", "tags": ["hiya"], "likes": 1, "viewed": 56, "date": "1588433027", "time_retrieved": "2024-06-20T20:06:44.753777", "image_code": "// reference from https://www.shadertoy.com/view/XssSzN\n\n#define A float (5.0/4.0)\n#define B float (4.0/4.0)\n\nvec3 metaballs(vec2 uv)\n{\n    float v = 0.5;\n    float P = 1.5 ; //3. + 3.*(1.+sin(0.008*iTime));\n    for (int i; i<35; i++) {\n        vec2 c = vec2(1.65*sin(A*(.02*iTime-float(i)*P) +3.141592/4.), sin(B*(.02*iTime-float(i)*P)));\n        float tempV = 1.0-smoothstep(0.007, 0.25, length(uv-0.5*c));\n        v += tempV;\n    }\n    \n    vec3 c = mix(vec3(0.2), vec3(.5*(1.+sin(iTime)*uv.y),uv.x+uv.y,1.0-uv.x), smoothstep(.06,.91,v*.5));\n    return c;\n}\n\nfloat circle(vec2 p , vec2 c, float r)\n{\n    vec2 dist = (p-c)*.2;\n    float a = smoothstep(r, r+0.01, length(dist));\n    return a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2. *  fragCoord.xy / iResolution.xy - 1.);\n\tuv.y *= iResolution.y/iResolution.x;\n    vec3 col = vec3(0);\n    vec3 line = vec3(0);\n   for (int i = 0; i<500; i++) {\n       float P =  .03 ; //+ (1.+sin(0.015*iTime));\n       vec2 pos = vec2(1.65*sin(A*(.2*iTime-float(i)*P) +3.141592/4.), sin(B*(.2*iTime-float(i)*P)));\n   \tline += vec3(.08)-vec3(circle(uv, 0.55*pos, 0.008));\n   }\n    line = vec3(.1*(2.+sin(3.*line.x) + sin(-uv.x*2.75)),line.x*.5*(1.+sin(uv.y*3.)),.25*(1.+sin(uv.y*3.5*cos(iTime))));\n   \t\n    col += metaballs(uv) + line;\n\n    fragColor = vec4(clamp(col, 0., 1.), 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3slBW7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3slfW2", "name": "Raymarched Moonscape", "author": "dean_the_coder", "description": "Raymarching a lunar landscape.\nIf anyone has any hints and tips they could suggest, they would be welcome! I'm trying to learn. :)", "tags": ["procedural", "3d", "raymarching", "moon"], "likes": 10, "viewed": 252, "date": "1589126996", "time_retrieved": "2024-06-20T20:06:44.753777", "image_code": "// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n\nfloat hash(vec2 p) { return fract(sin(dot(p, vec2(123.45, 875.43))) * 5432.3); }\n\nfloat noise(vec2 p) {\n\tvec2 i = floor(p),\n\t     f = fract(p);\n\tfloat a = hash(i),\n\t      b = hash(i + vec2(1, 0)),\n\t      c = hash(i + vec2(0, 1)),\n\t      d = hash(i + vec2(1));\n\tf = f * f * (3. - 2. * f);\n\treturn mix(a, b, f.x) + (c - a) * f.y * (1. - f.x) + (d - b) * f.x * f.y;\n}\n\nfloat fbm(vec2 p) {\n\tfloat f = 0.;\n\tf += .5 * noise(p * 1.1);\n\tf += .22 * noise(p * 2.3);\n\tf += .155 * noise(p * 3.9);\n\tf += .0625 * noise(p * 8.4);\n\tf += .03125 * noise(p * 15.);\n\treturn f;\n}\n\nfloat smoothBounds(float a, float b, float v) {\n\tfloat midPoint = a + (b - a) * .5;\n\treturn smoothstep(a, midPoint, v) * smoothstep(b, midPoint, v);\n}\n\nfloat stars(vec2 uv) { return smoothBounds(.195, .2, fbm(uv * 1e2)); }\n\nfloat rfbm(vec2 xz) { return abs(2. * fbm(xz) - 1.); }\n\nfloat sdEarth(vec3 p) { return length(p - vec3(0, -.8, 2)) - .7; }\n\nfloat sdTerrain(vec3 p) {\n\tif (p.y > 0.) return 1e10;\n\tfloat h = rfbm(p.xz * .2);\n\tp.xz += vec2(1);\n\th += .5 * rfbm(p.xz * .8);\n\th += .25 * rfbm(p.xz * 2.);\n\th += .03 * rfbm(p.xz * 16.1);\n\th *= .7 * fbm(p.xz);\n\th -= .7;\n\treturn abs(p.y - h) * .6;\n}\n\nvec2 map(vec3 p) {\n\tfloat d1 = sdTerrain(p),\n\t      d2 = sdEarth(p);\n\treturn d1 < d2 ? vec2(d1, 1) : vec2(d2, 2);\n}\n\nvec3 calcNormal(vec3 p) {\n\tconst vec2 e = vec2(1, -1) * 29e-5;\n\treturn normalize(e.xyy * map(p + e.xyy).x + e.yyx * map(p + e.yyx).x + e.yxy * map(p + e.yxy).x + e.xxx * map(p + e.xxx).x);\n}\n\nfloat calcShadow(vec3 origin, vec3 lightOrigin) {\n\tfloat s = 1.,\n\t      d = .1;\n\tvec3 rayDir = normalize(lightOrigin - origin);\n\twhile (d < 10. && s > 0.) {\n\t\tfloat distToObj = map(origin + rayDir * d).x;\n\t\ts = min(s, distToObj / d);\n\t\td += clamp(distToObj, .2, 1.);\n\t}\n\treturn smoothstep(0., 1., s);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\tvec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\tvec3 p, col,\n\t     rd = normalize(vec3(uv, 1));\n\tfloat d = .01,\n\t      id = 0.;\n\tfor (float steps = 0.; steps < 80.; steps++) {\n\t\tp = vec3(0, 0, -3) + rd * d;\n\t\tvec2 h = map(p);\n\t\tif (abs(h.x) < .004 * d) {\n\t\t\tid = h.y;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (d > 5.) break;\n\t\td += h.x;\n\t}\n\n\tif (id < .5) col = vec3(stars(uv));\n\telse {\n\t\tvec3 sunPos = vec3(8. - 16. * iMouse.x / iResolution.x, 6. - cos(iTime * .2), -1. - iMouse.y / 18.),\n\t\t     n = calcNormal(p),\n\t\t     mainLight = vec3(1.82, 1.8, 1.78) * dot(n, normalize(sunPos - p));\n\t\tif (id > 1.5) {\n\t\t\tcol = mix(mix(mix(vec3(.05, .05, .8), vec3(.05, .25, .05), smoothstep(.4, .52, fbm(n.xy * 3.1 + vec2(iTime * .05, 0)))), vec3(1), smoothstep(.8, .95, n.y) * smoothstep(.1, .8, fbm(n.xz * 10. + vec2(iTime * .1, 0)))), vec3(.3, .5, .95), smoothstep(-.5, 0., n.z));\n\t\t\tcol *= mainLight;\n\t\t}\n\t\telse if (id > .5) col = vec3(.5) * mainLight * pow(calcShadow(p, sunPos), 2.);\n\t}\n\n\tfragColor = vec4(pow(col, vec3(.4545)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3slfW2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3slfzr", "name": "561_Rabbitz_4", "author": "mrabbitz", "description": "used simple penumbra shadows scene and added some colored fog based on https://www.iquilezles.org/www/articles/fog/fog.htm", "tags": ["fog"], "likes": 1, "viewed": 54, "date": "1588801015", "time_retrieved": "2024-06-20T20:06:46.141827", "image_code": "////////////////////////////////////////////////////////////////\n\nvec3 applyFog( in vec3  rgb,      // original color of the pixel\n               in float distance, // camera to point distance\n               in vec3  rayDir,   // camera to point vector\n               in vec3  sunDir )  // sun light direction\n{\n    float fogAmount = 1.0 - exp( -distance*.04 );\n    float sunAmount = max( dot( rayDir, sunDir ), 0.0 );\n    vec3  fogColor  = mix( vec3(0.5,0.6,0.7), // bluish\n                           vec3(1.0,0.9,0.7), // yellowish\n                           pow(sunAmount,8.0) );\n    return mix( rgb, fogColor, fogAmount );\n}\n\n\nconst int RAY_STEPS = 256;\nvec3 LIGHT_POS = vec3(0.0, 5., -2.0);\n\nstruct Intersection\n{\n    vec3 p;\t\t// point of intersection in world space\n    float t;\t// t-value of ray to p\n    int objHit;\t// assign every object in scene a unique ID integer\n    vec3 color;\t// color of surface\n};\n    \nvec3 rotateX(vec3 p, float a) {\n    return vec3(p.x, cos(a) * p.y - sin(a) * p.z, sin(a) * p.y + cos(a) * p.z);\n}    \n    \n// Takes in direction, rotates it by a radians\n// result of applying a y rotation matrix to the vec3\n// rotates about y-axis\nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n    \n// b consists of width, height, and depth VECTORS (center to edge)\nfloat BoxSDF(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// point, radius, center\nfloat SphereSDF(vec3 p, float r, vec3 c) {\n    return distance(p, c) - r;\n}\n\nfloat PlaneSDF(vec3 p, vec4 n)\n{\n    return dot(p,n.xyz)+n.w;\n}\n\n#define BOX_SDF BoxSDF(pos + vec3(2.5, 0.0, 0.0), vec3(1.0))\n#define SPHERE_SDF SphereSDF(pos, 1., vec3(2.5, 0.0, 0.0))\n#define PLANE_SDF PlaneSDF(pos, vec4(0.0, 1.0, 0.0, 1.0))\n\n#define BOX 0\n#define SPHERE 1\n#define PLANE 2\n\nvec3 ComputeMaterial(int objHit, vec3 pos, vec3 nor, vec3 light, vec3 view)\n{\n    float lambert = dot(nor, light) + 0.2;\n    switch(objHit)\n    {\n        case BOX:\n        return vec3(1.0, 0.0, 0.0) * lambert;\n        break;\n    \tcase SPHERE:\n        return vec3(0.0, 1.0, 0.0) * lambert;\n    \tbreak;\n    \tcase PLANE:\n        return vec3(0.0, 0.0, 1.0) * lambert;\n    \tbreak;\n\t}\n\treturn vec3(1.0);    \n}\n\nfloat SceneSDF(vec3 pos, vec3 lightPos)\n{\n    float t = BOX_SDF;\n    t = min(t,SPHERE_SDF);\n    t = min(t,PLANE_SDF);\n    return t;\n}\n\nvec3 ComputeNormal(vec3 pos, vec3 lightPos) {\n    vec2 offset = vec2(0.0, 0.001);\n    return normalize( vec3( SceneSDF(pos + offset.yxx, lightPos) - SceneSDF(pos - offset.yxx, lightPos),\n                            SceneSDF(pos + offset.xyx, lightPos) - SceneSDF(pos - offset.xyx, lightPos),\n                            SceneSDF(pos + offset.xxy, lightPos) - SceneSDF(pos - offset.xxy, lightPos)\n                          )\n                    );\n}\n    \nvoid SceneSDF(vec3 pos, out float t, out int objHit, vec3 lightPos)\n{\n    t = BOX_SDF;\n    objHit = BOX;\n    \n    float t2;\n    if((t2 = SPHERE_SDF) < t)\n    {\n        t = t2;\n        objHit = SPHERE;\n    }\n    if((t2 = PLANE_SDF) < t)\n    {\n        t = t2;\n        objHit = PLANE;\n    }\n}\n    \nvoid RayMarch(vec3 origin, vec3 dir, out float t, out int objHit, vec3 lightPos)\n{\n    // starts slightly > 0\n    // so that if we march from a different point in the scene that isnt the camera\n    // we dont immediately intersect ourselves\n    t = 0.001;\n    // ray march not to a certain distance but for a certain number of iterations\n    for (int i = 0; i < RAY_STEPS; ++i)\n    {\n        vec3 pos = origin + t * dir;\n        // minimum distance that pos is from all SDFs in the scene\n        float m;\n        SceneSDF(pos, m, objHit, lightPos);\n        if(m < 0.01)\n        {\n            return;\n        }\n        t += m;\n    }\n    // hit nothing\n    t = -1.0;\n    objHit = -1;\n}\n    \nIntersection SceneIntersection(vec3 eye, vec3 dir, vec3 lightPos)\n{\n    float t;\n    int objHit;\n    // Marches along ray to find point of intersection\n    RayMarch(eye, dir, t, objHit, lightPos);\n    \n    vec3 isect = eye + t * dir;\n    vec3 nor = ComputeNormal(isect, lightPos);\n    vec3 lightDir = normalize(lightPos - isect);\n    \n    vec3 surfaceColor = ComputeMaterial(objHit, isect, nor, lightDir, normalize(eye - isect));\n        \n    vec3 normalAsColor = 0.5 * (nor + vec3(1.0));\n        \n    return Intersection(isect, t, objHit, surfaceColor);\n}\n    \nconst vec3 worldUp = vec3(0,1,0);\nvoid RayCast(vec2 ndc, out vec3 eye, out vec3 dir, out vec3 ref)\n{\n    eye = vec3(0.0, 4.5, 15.0);\n    ref = vec3(0.0, 0.0, 0.0);\n    \n    float len = tan(3.14159 * 0.08) * distance(eye, ref);\n   \n    vec3 H = normalize(cross(worldUp, ref - eye));\n    vec3 V = normalize(cross(H, eye - ref));\n    V *= len;\n    H *= len * iResolution.x / iResolution.y;\n    vec3 p = ref + ndc.x * H + ndc.y * V;\n    dir = normalize(p - eye);\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax)\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<100; i++ )\n    {\n\t\tfloat h = SceneSDF( ro + rd*t , LIGHT_POS);\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, 10.0*d/max(0.0,t-y) );\n        ph = h;\n        \n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.001 + 0.15*float(i)/4.0;\n        float d = SceneSDF( pos + h*nor, LIGHT_POS );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 1.5*occ, 0.0, 1.0 );    \n}\n\n// mainImage: present in every single shader program on shadertoy\n// outputs: the fragment color for the fragment it is operating on\n// takes in: the pixel space coordinates of the fragment it is coloring\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime * 3.14159 * 0.1;\n    LIGHT_POS = rotateY(vec3(0.0, 10.0, -10.), t);\n    \n    // iResolution: width and height of screen in pixels (on bottom toolbar of image output)\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Convert to range -1 to 1 for x and y\n    // Normalized Device Coordinates w.r.t. the center of the screen being (0,0)\n    uv = (uv * 2.0) - vec2(1.0);\n    \n    Intersection aaIsects[4];\n    vec3 eye, dir, ref;\n    int idx = 0;\n    for (float i = 0.0; i < 1.0; i += 0.5)\n    {\n        for (float j = 0.0; j < 1.0; j += 0.5)\n        {\n            RayCast(uv + vec2(i, j) / iResolution.xy, eye, dir, ref);\n            aaIsects[idx++] = SceneIntersection(eye, dir, LIGHT_POS);\n        }\n    }\n                                                                          \n    vec3 avgColor = vec3(0.0);\n    for (int i = 0; i < 4; ++i)\n    {\n        avgColor += aaIsects[i].color;\n    }\n    avgColor *= 0.25;\n    \n    \n    vec3 norm = ComputeNormal(aaIsects[0].p, LIGHT_POS);\n    \n            \tvec3 color = vec3(0.0);\n    \tvec3 baseColor = avgColor;\n        \n    //    https://www.shadertoy.com/view/lsKcDD\n    \n    // key light\n        vec3  lig = normalize(LIGHT_POS - aaIsects[0].p);\n        vec3  hal = normalize( lig-dir );\n        float dif = clamp( dot( norm, lig ), 0.0, 1.0 ) * \n                    calcSoftshadow( aaIsects[0].p, lig, 0.01, 15.0);\n\n\t\tfloat spe = pow( clamp( dot( norm, hal ), 0.0, 1.0 ),16.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,dir),0.0,1.0), 5.0 ));\n\n\t\tcolor = baseColor * 4.0*dif*vec3(1.00,0.70,0.5);\n        color +=      12.0*spe*vec3(1.00,0.70,0.5);\n    \n            // ambient light\n        float occ = calcAO( aaIsects[0].p, norm );\n\t\tfloat amb = clamp( 0.5+0.5*norm.y, 0.0, 1.0 );\n        color += baseColor*amb*occ*vec3(0.0,0.08,0.1);\n    color += baseColor * 0.4;\n    \n    color = applyFog( color,      // original color of the pixel\n               distance(aaIsects[0].p, eye), // camera to point distance\n               normalize(aaIsects[0].p - eye),   // camera to point vector\n               normalize(LIGHT_POS - aaIsects[0].p));\n    \n    fragColor = vec4(color * step(0.0, aaIsects[0].t), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3slfzr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sSBDV", "name": "Fly On, Buckaroo (Live Version)", "author": "blackle", "description": "live coded in 1 hour on the neuvoids stream for the algorave event on 29/05/2020\nedit: some slight performance improvements\nwatch the replay here: https://www.twitch.tv/videos/635826054", "tags": ["ufo", "livecode"], "likes": 25, "viewed": 595, "date": "1590797606", "time_retrieved": "2024-06-20T20:06:47.014573", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax,p)*ax, p, cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat comp(vec3 p, vec3 ax, float ro) {\n  \n  p = erot(p,ax,ro);\n  p = asin(sin(p));\n  return length(p)-1.;\n}\n\nfloat cloudssdf(vec3 p) {\n  p.y += iTime*.2;\n  float d1 = comp(p, normalize(vec3(1,2,5)), 0.5);\n  p.y += iTime*.2;\n  float d3 = comp(p*2., normalize(vec3(3,1,1)), 2.5)/2.;\n  p.y += iTime*.2;\n  float d4 = comp(p*3., normalize(vec3(4,-2,5)), 3.5)/3.;\n  return (d1+d3+d4)/3.;\n}\n\nfloat linedist (vec3 p, vec3 a, vec3 b) {\n  float k = dot(p-a,b-a)/dot(b-a,b-a);\n  return distance(p,mix(a,b,clamp(k,0.,1.)));\n}\n\nfloat body;\nfloat beamm;\nfloat scene(vec3 p) {\n  p.z += sin(iTime);\n  p = erot(p, vec3(0,1,0), cos(iTime)*.2);\n  beamm = 0.9*(linedist(p, vec3(0), vec3(0,0,-10))-.3-sin(p.z*3.+iTime*4.)*.05 - sin(iTime)*.2);\n  vec3 p2 =p;\n  p2.z = sqrt(p2.z*p2.z+0.02);\n  p2.z+=3.;\n  body = length(p2)-3.8;\n  body += smoothstep(0.8,1.,sin(atan(p2.x,p2.y)*10.))*.02;\n  body += smoothstep(0.8,1.,sin(atan(p2.x,p2.y)*45.))*.003;\n  float hat = length(p-vec3(0,0,0.8))-0.7;\n  return min(min(body,hat), beamm);\n}\nfloat bpm = 125.;\nfloat eye;\nfloat buckaroo(vec3 p) {\n  float bpmt = iTime/60.*bpm;\n  float t = pow(sin(fract(bpmt)*3.14/2.), 20.);\n  p.z += sin(iTime);\n  p = erot(p, vec3(0,1,0), cos(iTime)*.2);\n  p-=vec3(0,0,0.9);\n  p.z += t*.1;\n  p.x = abs(p.x);\n  float b =  length(p)-0.2;\n  b = min(b, linedist(p, vec3(0), vec3(.3,0,.3))-.04);\n  b = min(b, length(p-vec3(.3,0,.3))-.07);\n  b = min(b, linedist(p, vec3(0), vec3(0,0,-.5))-.15);\n  eye = length(p-vec3(.1,.18,.0))-.03;\n  return min(b, eye);\n}\n\nvec3 norm(vec3 p) {\n  mat3 k = mat3(p,p,p)-mat3(0.01);\n  return normalize(scene(p)-vec3(scene(k[0]), scene(k[1]), scene(k[2])));\n}\n\nvec3 norm2(vec3 p) {\n  mat3 k = mat3(p,p,p)-mat3(0.01);\n  return normalize(buckaroo(p)-vec3(buckaroo(k[0]), buckaroo(k[1]), buckaroo(k[2])));\n}\n\nvec3 srgb(float r, float g, float b) {\n  return vec3(r*r,g*g,b*b);\n}\n\nvec3 clouds(inout vec3 p, vec3 cam, vec3 init, int depth) {\n  p = init;\n  for (int i = 0; i < depth; i++) {\n    float dist = min(scene(p),cloudssdf(p));\n    dist = sqrt(dist*dist+0.05);\n    p += dist*cam;\n  }\n  float f1 = length(sin(p)*.5+.5)/sqrt(3.);\n  float f2 = smoothstep(0., 30., distance(p,init));\n  vec3 sun = max(0.,dot(vec3(1./sqrt(3.)), cam))*vec3(1);\n  sun = pow(sun,vec3(9)) + pow(sun,vec3(4))*srgb(0.7,0.5,0.2);\n  return mix(srgb(0.2,0.3,0.7), srgb(0.8,0.3,0.3), f1) + mix(srgb(0.2,0.4,0.7), srgb(0.7,0.7,0.7), f2) + sun;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n  vec3 cam = normalize(vec3(1,uv));\n  \n  float bpmt = iTime/60.*bpm;\n  float t = mix(floor(bpmt) + pow(sin(fract(bpmt)*3.14/2.), 20.), bpmt, 0.8);\n  vec3 init = vec3(-8.+sin(t)*2.,0,0.1);\n  cam = erot(cam, vec3(0,0,1), t*.2);\n  init = erot(init, vec3(0,0,1), t*.2);\n  vec3 clp;\n  vec3 p = init;\n  bool hit = false;\n  float dist;\n  float glow = 0.;\n  for (int i = 0; i < 120 && !hit; i++) {\n    dist = scene(p);\n    if (!isnan(beamm)) glow += .5/(1.+beamm*100.);\n    hit = dist*dist < 1e-6;\n    p+=dist*cam;\n    if(distance(p,init)>20.)break;\n  }\n  glow = min(glow,1.);\n  bool bdy = (dist == body);\n  vec3 n = norm(p);\n  vec3 obj = hit ? sin(n)*.5+.5 : vec3(0);\n  vec3 clds = clouds(clp, cam, init, 20);\n  if (hit) {\n    vec3 p2 = p+n*.1;\n    float ao = smoothstep(-.1,.1,scene(p2));\n    vec3 r = reflect(cam,n);\n    float fres = 1.-abs(dot(cam,n))*.5;\n    obj = clouds(p2, r, p2, 10)*fres*ao;\n    if (!bdy) {\n      p2 = p+cam;\n      r = refract(cam,n,1.1);\n      vec3 p5 = p;\n      bool hhit = false;\n      float bb;\n      for (int i = 0; i < 50 && !hhit; i++) {\n        bb = buckaroo(p5);\n        hhit = bb*bb< 1e-6;\n        p5+=bb*r;\n        if(distance(p5,p)>2.)break;\n      }\n      bool ey = eye==bb;\n      if (hhit) {\n        vec3 n5 = norm2(p5);\n        float fk = length(sin(n5*2.)*.5+.5)/sqrt(3.);\n        obj = fk*(ey ? srgb(0.1,0.1,0.1) : srgb(0.3,0.75,0.3)) + obj*.5;\n      } else {\n      \tobj = obj*.5 + clouds(p2, r, p2, 20)*.9;\n      }\n    }\n  }\n  obj = obj  + srgb(0.2,0.4,0.6)*glow;\n  float fctr = smoothstep(-3.,1., distance(clp,init)-distance(p,init));\n  fragColor.xyz = mix(clds, obj, fctr) + glow*glow*.9*sqrt(fctr*.5+.5);\n  fragColor.xyz = sqrt(fragColor.xyz);\n  fragColor.xyz = abs(erot(fragColor.xyz, normalize(sin(clp*.3+t)), 0.2));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc0-1.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sSBDV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3ssBRB", "name": "Babyâs first shader", "author": "powers", "description": "Learning shaders, playing with inputs", "tags": ["stupid"], "likes": 1, "viewed": 64, "date": "1588530436", "time_retrieved": "2024-06-20T20:06:47.014573", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 st = fragCoord.xy;\n    vec2 size = mod(iTime,2.0)*iResolution.xy;\n\tfragColor = vec4(mod(st.x,size.x)/size.x,0.0,mod(st.y,size.y)/size.y,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3ssBRB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3ssBRS", "name": "radiance01", "author": "paulobarcelos", "description": "radiance01", "tags": ["radiance01"], "likes": 0, "viewed": 206, "date": "1588517663", "time_retrieved": "2024-06-20T20:06:47.020402", "image_code": "float noise(vec2 p) {\n    float a = sin(p.x * 1234.456) * cos(p.y * 5678.1234) * 999.0;\n    float b = cos(p.x * 2355.234) * sin(p.y * 3534.3465) * 456.0;\n    return fract(a + b);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float scale = 0.5;\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    float time = mod(iTime, 6.35);\n    vec2 mouse = (iMouse.xy - 0.5 * iResolution.xy)/iResolution.y;\n    vec2 center = vec2(0);\n    vec2 follow = mix(center, mouse, clamp(iMouse.w, 0., 1.));\n    \n    uv *= scale;\n    follow *= scale;\n    vec3 col = vec3(0);\n\n    float points = mix(noise(uv), noise(uv + time * 0.000001), 0.01);\n    float focus = clamp(length(uv - follow + vec2(sin(time), cos(time)) * 0.01), 0.0, 1.0);\n    float waves = pow((1.0 - focus) * sin(pow(focus, 0.5) * 200.0 - iTime) * 0.5 + 0.5, 1.5);\n    float mask = smoothstep(0.0, 0.0001, smoothstep(0.2, 0.0, pow(focus + waves * 0.05, 0.8) * points + focus * 0.15));\n\n    col = mix(vec3(0.2, 0.0, 0.1), vec3(0.9, 0.9, 0.8), mask);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3ssBRS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sSBRW", "name": "Squashed hexagons (ungolfed)", "author": "schnaader", "description": "Shader to draw the pattern from\nhttps://codegolf.stackexchange.com/questions/204726/tile-the-plane-with-squashed-hexagons\n\nungolfed version, golfed version here: https://www.shadertoy.com/view/tsBfRW", "tags": ["tesselation"], "likes": 3, "viewed": 61, "date": "1589544019", "time_retrieved": "2024-06-20T20:06:47.547989", "image_code": "const int n = 10;\n\nconst float zoom = 0.15;                // higher values => zoom into the pattern\n\nconst float W = (0.03 * zoom) / 2.0;\t// half line width\nconst float L = (0.1 * zoom); \t\t\t// length of a hexagon edge\nconst float M = (L / 2.0) * sqrt(2.0);  // axis parallel length of a diagonal\nconst float InsideHexagon = 1.0;\nconst float OnBoundary = 0.0;\n \n// Returns 1.0 if inside the hexagon, 0.0 else\nfloat hexagon(vec2 uv, vec2 center) {\n    \n    // using absolute of the coordinates uses the symmetry of the hexagon\n    // this way, the hexagon can be reduced to two lines\n    vec2 absUv = abs(uv - center);\n    \n    if ((absUv.x >= 0.0) && (absUv.x <= L / 2.0)) { // straight line\n        if ((absUv.y >= M - W / sqrt(2.0)) && (absUv.y <= M + W / sqrt(2.0))) {\n            return OnBoundary;\n        } else {\n            return InsideHexagon;\n        }\n    } else if (absUv.x <= L / 2.0 + M + W) { // diagonal line\n        if ((absUv.y >= M - (absUv.x - L / 2.0) - W) && (absUv.y <= M - (absUv.x - L / 2.0) + W)) {\n            return OnBoundary;\n        } else {\n            return InsideHexagon;\n        }        \n    }\n    \n    return InsideHexagon;\n}\n\nfloat mirroredHexagons(vec2 uv, vec2 center) {\n    float result;\n    \n    result = hexagon(uv, center);     // draws some of the hexagons\n    result *= hexagon(uv.yx, center); // same, but rotated by 90Â°\n\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = fragCoord/iResolution.xy - vec2(0.5, 0.5);\n    uv.y /= (iResolution.x / iResolution.y);\n \n    // rotated by 45 degree\n    float alpha = radians(-45.0);\n    vec2 uv45 = vec2(uv.x * cos(alpha) - uv.y * sin(alpha), uv.x * sin(alpha) + uv.y * cos(alpha));\n \n    // Time varying pixel color\n    vec3 colInside   = 0.5 + 0.5 * cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 colBoundary = vec3(0,0,0);\n\n    // Output to screen\n    float currentState = InsideHexagon;\n    \n    float xFirst = L / 2.0 + M;\n    \n    for (int i = 0; i < n; i++) {\n        int maxJ = i / 2 + 1;\n        if (i % 2 == 0) {\n            for (int j = 0; j < maxJ; j++) {\n                // by passing abs(uv) to mirroredHexagons, symmetry is used and multiple hexagons are\n                // drawn at once\n            \tcurrentState *= mirroredHexagons(abs(uv), vec2(xFirst + float(i) * (L + M), float(j) * 2.0 * M));\n                if (i < n - 1) {\n                    currentState *= mirroredHexagons(abs(uv45), vec2(xFirst + float(i) * (L + M) + L, float(j) * 2.0 * M));\n                }\n            }\n        } else {\n            for (int j = 0; j < maxJ; j++) {\n            \tcurrentState *= mirroredHexagons(abs(uv), vec2(xFirst + float(i) * (L + M), float(j) * 2.0 * M + M));\n                if (i < n - 1) {\n            \t\tcurrentState *= mirroredHexagons(abs(uv45), vec2(xFirst + float(i) * (L + M) + L, float(j) * 2.0 * M + M));\n                }\n            }\n        }\n    }\n\n    // multiplying gives black for boundaries while preserving the animated background\n    fragColor = vec4(currentState * colInside, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sSBRW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sSBzG", "name": "Infinity cubes scene", "author": "kotfind", "description": "Scene with infinity figures.", "tags": ["3d"], "likes": 1, "viewed": 236, "date": "1590233510", "time_retrieved": "2024-06-20T20:06:48.432822", "image_code": "#define M_PI 3.1415926\n\n// SETTINGS\nconst float zFar = 200.;\nconst float zNear = 1.;\n\nconst vec3 background_color = vec3(0.2);\nconst float collision_distance = 0.00001;\nconst int marching_iterations = 100;\n\nconst float normal_partial_derivative_epsilon = 0.00001;\n\n// COLORS\nconst vec3 red   = vec3(1., 0., 0.);\nconst vec3 green = vec3(0., 1., 0.);\nconst vec3 blue  = vec3(0., 0., 1.);\n\nfloat sq(in float n) {\n    return n * n;\n}\n\n// Transformations\nmat4 worldMatrix = mat4(1., 0., 0., 0.,   0., 1., 0., 0.,   0., 0., 1., 0.,   0., 0., 0., 1.);\n\nvoid identity() {\n    worldMatrix = mat4(1., 0., 0., 0.,   0., 1., 0., 0.,   0., 0., 1., 0.,   0., 0., 0., 1.);\n}\n\nvoid scale(in float a, in float b, in float c) {\n    worldMatrix *= mat4(a , 0., 0., 0.,\n                        0., b , 0., 0.,\n                        0., 0., c , 0.,\n                        0., 0., 0., 1.);\n}\n\nvoid trans(in vec3 v) {\n    worldMatrix *= mat4(1., 0., 0., v.x,\n                        0., 1., 0., v.y,\n                        0., 0., 1., v.z,\n                        0., 0., 0., 1.);\n}\n\nvoid rotx(in float a) {\n    float sina = sin(a);\n    float cosa = cos(a);\n    worldMatrix *= mat4(1.,   0.,    0., 0.,\n                        0., cosa, -sina, 0.,\n                        0., sina,  cosa, 0.,\n                        0.,   0.,    0., 1.);\n}\n\nvoid roty(in float a) {\n    float sina = sin(a);\n    float cosa = cos(a);\n    worldMatrix *= mat4( cosa, 0., sina, 0.,\n                           0., 1.,   0., 0.,\n                        -sina, 0., cosa, 0.,\n                           0., 0.,   0., 1.);\n}\n\nvoid rotz(in float a) {\n    float sina = sin(a);\n    float cosa = cos(a);\n    worldMatrix *= mat4(cosa, -sina, 0., 0.,\n                        sina,  cosa, 0., 0.,\n                          0., 0., 1., 0.,\n                          0., 0., 0., 1.);\n}\n\n// All object functions (like sphere), scene function and functions inter,\n// union and diff returns vec4, where .rgb is color and .a is distance.\n\nvec4 inter(in vec4 a, in vec4 b) {\n    if (a.a > b.a) {\n        return a;\n    } else {\n        return b;\n    }\n}\n\nvec4 union_(in vec4 a, in vec4 b) {\n    if (a.a < b.a) {\n        return a;\n    } else {\n        return b;\n    }\n}\n\nvec4 diff(in vec4 a, in vec4 b) {\n    if (a.a > -b.a) {\n        return a;\n    } else {\n        return vec4(b.rgb, -b.a);\n    }\n}\n\nvec4 sphere(in vec3 pos, in vec3 color, in vec3 center, in float radius) {\n    return vec4(color, distance(pos, center) - radius);\n}\n\nvec4 plane(in vec3 pos, in vec3 color, in float height) {\n    return vec4(color, height - pos.y);\n}\n\nvec4 cube(in vec3 pos, in vec3 color, in vec3 coords, in vec3 size) {\n    return vec4(color, sqrt(sq(max(0., abs(pos.x - coords.x) - size.x)) +\n                            sq(max(0., abs(pos.y - coords.y) - size.y)) +\n                            sq(max(0., abs(pos.z - coords.z) - size.z))));\n}\n\nvec4 xcylinder(in vec3 pos, in vec3 color, in vec3 coords, in float radius) {\n    return vec4(color, distance(pos.yz, coords.yz) - radius);\n}\n\nvec4 ycylinder(in vec3 pos, in vec3 color, in vec3 coords, in float radius) {\n    return vec4(color, distance(pos.xz, coords.xz) - radius);\n}\n\nvec4 zcylinder(in vec3 pos, in vec3 color, in vec3 coords, in float radius) {\n    return vec4(color, distance(pos.xy, coords.xy) - radius);\n}\n\nvec4 scene(vec3 pos) {\n    pos = (vec4(pos, 1.) * worldMatrix).xyz;\n    pos = mod(pos + 5., 10.) - 5.;\n    return diff(inter(cube(pos, red, vec3(0., 0., 0.), vec3(0.9)),\n                      sphere(pos, blue, vec3(0., 0., 0.), 1.25)),\n                union_(union_(xcylinder(pos, green, vec3(0., 0., 0.), 0.8 * abs(sin(iTime / 2.))),\n                              ycylinder(pos, green, vec3(0., 0., 0.), 0.8 * abs(sin(iTime / 2.)))),\n                       zcylinder(pos, green, vec3(0., 0., 0.), 0.8 * abs(sin(iTime / 2.)))));\n}\n\nvec3 getNormal(in vec3 pos) {\n    float x, y, z;\n    float E = normal_partial_derivative_epsilon;\n    x = scene(pos + vec3(E, 0., 0.)).a - scene(pos - vec3(E, 0., 0.)).a;\n    y = scene(pos + vec3(0., E, 0.)).a - scene(pos - vec3(0., E, 0.)).a;\n    z = scene(pos + vec3(0., 0., E)).a - scene(pos - vec3(0., 0., E)).a;\n    return normalize(vec3(x, y, z));\n}\n\nvec3 ray_marching(vec3 pos, vec3 dir) {\n    dir = normalize(dir);\n    float len = 0.;\n    float mindist;\n    vec3 color;\n    vec3 norm;\n\n    for (int i = 0; i < marching_iterations; ++i) {\n        vec4 tmp = scene(pos);\n        color = tmp.rgb;\n        mindist = tmp.a;\n        norm = getNormal(pos);\n\n        if (mindist < collision_distance) return color * max(0.4, dot(normalize(vec3(0.) - pos), norm));\n        if (len > zFar) return background_color;\n\n        len += mindist;\n        pos += dir * mindist;\n    }\n    return background_color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / vec2(min(iResolution.x, iResolution.y));\n    uv -= (iResolution.xy / min(iResolution.x, iResolution.y) - vec2(1.)) / 2.;\n    uv.y = 1. - uv.y;\n\n    identity();\n    trans(vec3(0., 0., abs(sin(iTime / 2. + M_PI / 2.)) * -5.));\n    rotx(iTime + 2.);\n    rotz(iTime + 2.);\n    roty(iTime + 2.);\n    vec3 color = ray_marching(vec3(0.), vec3(uv - vec2(0.5), zNear));\n\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sSBzG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3ssBzj", "name": "menger-sponge-va-002", "author": "jorge2017a1", "description": "menger-sponge-va-002", "tags": ["mengerspongeva002"], "likes": 2, "viewed": 48, "date": "1588622722", "time_retrieved": "2024-06-20T20:06:48.432822", "image_code": "//modificado por jorge flores.p --\n//Gracias a ....Created by russ in 2017-03-06\n//https://www.shadertoy.com/view/XsfczB\n    \n\nconst int iter =100;\nconst float eps = 0.001, far = 20.;\nvec3 lDir0 = normalize(vec3(1,2,1)), lDir1 = normalize(vec3(-1,1.0,-2));\nvec3 lCol0 = vec3(1,.8,.5), lCol1 = vec3(.6,0.8,1); \n\n\n#define PI 3.1415926\n\n///-------------------------------------\nconst int MAX_RAY_STEPS = 64;\nconst float RAY_STOP_TRESHOLD = 0.0001;\nconst int MENGER_ITERATIONS = 5;\n///-------------------------------------\n\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3  di = abs(p) - b;\n  float mc = maxcomp(di);\n  return min(mc,length(max(di,0.0)));\n}\n\n\nfloat cylUnion(vec3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(min(xy,min(xz,yz))) - 1.;\n}\n\nfloat cylIntersection(vec3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(max(xy,max(xz,yz))) - 1.;\n}\n\n\n//-------------------------------------------\n\nfloat dsSphere(vec3 center, float r, vec3 point)// basic sphere SDF\n{\n    // point is point pos in space, center is sphere's center, r is its radius\n    return length(point - center) - r;\n}\n\nfloat dsCapsule(vec3 point_a, vec3 point_b, float r, vec3 point_p)//cylinder SDF\n{\n \tvec3 ap = point_p - point_a;\n    vec3 ab = point_b - point_a;\n    float ratio = dot(ap, ab) / dot(ab , ab);\n    ratio = clamp(ratio, 0.0, 1.0);\n    vec3 point_c = point_a + ratio * ab;\n    return length(point_c - point_p) - r;\n}\n\nfloat dsTorus(vec3 center, float r1, float r2, vec3 point)\n{\n \tfloat x = length(point.xz - center.xz) - r1;\n    float y = point.y - center.y;\n    float dist = length(vec2(x,y)) - r2;\n    return dist;\n}\n//--------------------------------------------\n\n//oooooooooooooooooooooooooooooooooooooooooooooooooooo\nfloat sdCross(vec3 p) {\n\tp = abs(p);\n\tvec3 d = vec3(max(p.x, p.y),\n\t\t\t\t  max(p.y, p.z),\n\t\t\t\t  max(p.z, p.x));\n\treturn min(d.x, min(d.y, d.z)) - (1.0 / 3.0);\n}\n\nfloat sdCrossRep(vec3 p) {\n\tvec3 q = mod(p + 1.0, 2.0) - 1.0;\n\treturn sdCross(q);\n}\n\nfloat sdCrossRepScale(vec3 p, float s)\n{\t\n    \n    return sdCrossRep(p * s) / s;\t\n    \n}\n\n\nfloat sdCrossRepScalev2(vec3 p, float s)\n{\t\n    float d;\n    d= sdCrossRep(p * s) / s;\t\n    \n    vec2 q = abs(p.xy);\n    float mind =  length(q-d)-0.4;\n    return mind;\n\t\n    \n    \n}\n\n\n\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\n\n//--------------------------\nfloat DE(vec3 p) {\n\t\n    \n    float scale = 4.435;\n\t\n \n       \n    \n    float dist =sdBox(p- vec3(0.0), vec3(1.0) );\n    \n \n\tfor (int i = 0; i < MENGER_ITERATIONS; i++) {\n\t\t\n        dist = max(dist, sdCrossRepScale(p, scale)+sdCrossRepScalev2(p, scale+0.0125));\n\t\tscale *= 3.0;\n\t}\n\n\n    \n    \n\treturn dist;\n}\n\n//oooooooooooooooooooooooooooooooooooooooooooooooooooo\n\n\n\nvec2 march(vec3 ro, vec3 rd){\n\tfloat t=0. , d = far, it = 0.;\n    for (int i=0;i<iter;i++){\n     \tt += (d = DE(ro+t*rd));\n        if(d<eps || t> far) break;\n        it += 1.;\n    }\n    return vec2(t,it/float(iter));\n}\n\nfloat getShadow(vec3 p, vec3 n, vec3 ld){\n    p +=  2. * eps * n;\n    float t=0.,d=far;\n    for(int i=0;i<50;i++){\n        t += (d=DE(p + t*ld));\n        if (d<eps || t>3.) break;\n    }\n    return t<=3. ? 0.1 : 1. ;\n}\n\nvec3 getRay(vec3 ro, vec3 look, vec2 uv){\n    vec3 f = normalize(look - ro);\n    vec3 r = normalize(vec3(f.z,0,-f.x));\n    vec3 u = cross (f,r);\n    return normalize(f + uv.x * r + uv.y * u);\n}\n\nvec3 getNorm(vec3 p){\n    vec2 e = vec2(eps, 0);\n    return normalize(vec3(DE(p+e.xyy)-DE(p-e.xyy),DE(p+e.yxy)-DE(p-e.yxy),DE(p+e.yyx)-DE(p-e.yyx)));\n}\n\nvec3 light(vec3 p, vec3 n){\n    vec3 col = vec3(0.01);\n    for(int i=0;i<2;i++){\n        vec3 ld = (i==0) ? lDir0 : lDir1;\n        float diff = max(dot(n, (ld)),0.);\n        diff *= getShadow(p, n, ld);\n        col += diff * (i==0 ? lCol0 : lCol1);\n    }\n    return col * .7;\n}\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) {\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float time = iTime * 0.5;\n    //float time = iTime * .06;\n    \n    \n\tvec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n  \n    \n    \n    //vec3 ro = vec3(0.5, 0.25, 1.5+ 1.0*cos(time)+time*1.2);\n    vec3 ro = vec3(1.0+0.25*sin(iTime), 0.25, 1.0+ 1.0*cos(time));\n     //ro = get_mouse(ro);\n   \n    \n    vec3 rd = getRay(ro, vec3(0.), uv);\n    vec2 hit = march(ro, rd);\n    vec3 p = ro + hit.x*rd;\n    \n    vec3 col = hit.x<far ? light(p, getNorm(p)) : vec3(.1*(1.-length(uv)));\n    \n    \n    col += pow(hit.y,3.);\n\tfragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3ssBzj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3ssfDM", "name": "Anti Menger Sphere Sponge II", "author": "ManuManu", "description": "For some reasons, I played with parameters from this old shader of mine (  here https://www.shadertoy.com/view/MtBGWK ).\n\nAnd find the results satisfying:)", "tags": ["raymarching", "menger", "sponge"], "likes": 4, "viewed": 262, "date": "1588429645", "time_retrieved": "2024-06-20T20:06:49.602783", "image_code": "\n//---------------------------------------------------------\n//\n// source header from IQ, for sure...\n//\n//\n// Modified by ManuManu to create the Monge effect\n//\n//\n\n// Shader:   RayMarchingPrimitivesV2.glsl\n// original: https://www.shadertoy.com/view/Xds3zN   colored\n//           http://glslsandbox.com/e#20839          gray scaled\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// A list of usefull distance function to simple primitives (animated), and an example \n// on how to / do some interesting boolean operations, repetition and displacement.\n// More info here: http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n//---------------------------------------------------------\n\n\n//---------------------------------------------------------\n\n#define ANIMATE true\n#define ROTATE true\n#define flag true\n\nfloat aTime = 0.0;\nfloat sinTime = 0.0;\n//---------------------------------------------------------\n//  primitives\n//---------------------------------------------------------\nfloat sdPlane( vec3 p )\n{\n  return p.y;\n}\n\n\n//----------------------------------------------------------------------\n// distance operations\n//----------------------------------------------------------------------\n\n\n// Union: d1 +d2\nvec2 opU( vec2 d1, vec2 d2 )\n{\n  return (d1.x < d2.x) ? d1 : d2;\n}\n\n//----------------------------------------------------------------------\n// animated fractal Anti sphere sponge\nfloat AntiSphereSponge(vec3 w)\n{\n  const int ITER = 10;\n  float sphereHoles = 8.0 + 5.*sin(0.42*aTime);\n  float sphereScale = 1.5 + 0.9*sin(0.39*aTime);\n  float scale =1.6;\n  //float scale =1.5;\n  float k = scale*.5;\n  float d = 10000.0;\n  float r, d1;\n  //float sph=length(w * vec3(0.8, 0.8, 0.5)) - 0.6 ;\n  float sph=length(w * vec3(0.8, 0.5, 0.5)) - 0.6;\n  \n  if ( sph < .1)\n  for (int i = 0; i < ITER; i++) \n  {\n    vec3 zz = mod(w * k, sphereHoles) - vec3(0.5 * sphereHoles);\n    r = length(zz);\n    d1 = -(sphereScale - r) / k;\n    k *= scale;\n    d = min(d, d1);\n  }\n\telse d = 0.;\n  d = max(d,sph);\n  return d;\n}\n//----------------------------------------------------------------------\nvec2 map( in vec3 pos )\n{\n  vec3 r1, r2;\n  vec2 res = vec2( sdPlane( pos), 1.0 );\n  float color = 46.9 + 40.0 * cos(0.2 * iTime);\n  res = opU(res,vec2(AntiSphereSponge(pos - vec3(0.0, 0.7, 0.0)), color));\n  return res;\n}\n//----------------------------------------------------------------------\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n  float tmin = 1.0;\n  float tmax = 20.0;\n\n  float precis = 0.002;\n  float t = tmin;\n  float m = -1.0;\n  for ( int i=0; i<100; i++ )\n  {\n    vec2 res = map( ro+rd*t );\n    if ( res.x<precis || t>tmax ) break;\n    t += res.x;\n    m = res.y;\n  }\n\n  if ( t>tmax ) m=-1.0;\n  return vec2( t, m );\n}\n\n//----------------------------------------------------------------------\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n  float res = 1.0;\n  float t = mint;\n  for ( int i=0; i<14; i++ )\n  {\n    float h = map( ro + rd*t ).x;\n    res = min( res, 8.0*h/t );\n    t += clamp( h, 0.02, 0.10 );\n    if ( h<0.001 || t>tmax ) break;\n  }\n  return clamp( res, 0.0, 1.0 );\n}\n\n//----------------------------------------------------------------------\nvec3 calcNormal( in vec3 pos )\n{\n  vec3 eps = vec3( 0.001, 0.0, 0.0 );\n  vec3 nor = vec3(\n  map(pos+eps.xyy).x - map(pos-eps.xyy).x, \n  map(pos+eps.yxy).x - map(pos-eps.yxy).x, \n  map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n  return normalize(nor);\n}\n\n//----------------------------------------------------------------------\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n  float occ = 0.0;\n  float sca = 1.0;\n  for ( int i=0; i<5; i++ )\n  {\n    float hr = 0.01 + 0.12*float(i) / 4.0;\n    vec3 aopos =  nor * hr + pos;\n    float dd = map( aopos ).x;\n    occ += -(dd-hr)*sca;\n    sca *= 0.95;\n  }\n  return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n//---------------------------------------------------------\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n  aTime = ANIMATE ? iTime : 0.0;\n  sinTime = sin(aTime);\n  vec3 col = vec3(0.8, 0.9, 1.0);\n  vec2 res = castRay(ro, rd);\n  float t = res.x;\n  float m = res.y;\n  if ( m > -0.5 )\n  {\n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormal( pos );\n    vec3 ref = reflect( rd, nor );\n\n    // material        \n    col = 0.45 + 0.3*sin( vec3(0.05, 0.08, 0.10)*(m-1.0) );\n\n    if ( m<1.5 )\n    {\n      float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n      col = 0.4 + 0.1*f*vec3(1.0);\n    }\n\n    // lighting        \n    float occ = calcAO( pos, nor );\n    vec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n    float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float bac = clamp( dot( nor, normalize(vec3(-lig.x, 0.0, -lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y, 0.0, 1.0);\n    float dom = smoothstep( -0.1, 0.1, ref.y );\n    float fre = pow( clamp(1.0+dot(nor, rd), 0.0, 1.0), 2.0 );\n    float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ), 16.0);\n\n    dif *= softshadow( pos, lig, 0.02, 2.5 );\n    dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n    vec3 brdf = vec3(0.0);\n    brdf += 1.20*dif*vec3(1.00, 0.90, 0.60);\n    brdf += 1.20*spe*vec3(1.00, 0.90, 0.60)*dif;\n    brdf += 0.30*amb*vec3(0.50, 0.70, 1.00)*occ;\n    brdf += 0.40*dom*vec3(0.50, 0.70, 1.00)*occ;\n    brdf += 0.30*bac*vec3(0.25, 0.25, 0.25)*occ;\n    brdf += 0.40*fre*vec3(1.00, 1.00, 1.00)*occ;\n    brdf += 0.02;\n    col = col*brdf;\n    col = mix( col, vec3(0.8, 0.9, 1.0), 1.0-exp( -0.005*t*t ) );\n  }\n  return vec3( clamp(col, 0.0, 1.0) ); \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = 2.0*(fragCoord.xy / iResolution.xy) - 1.0;\n  p.x *= iResolution.x / iResolution.y;\n\n  // camera  \n  float angle = ROTATE ? 0.02*iTime : 0.0;\n  float rx = 0.5 + 3.0*cos(angle + 6.0*iMouse.x);\n  float rz = 0.5 + 3.0*sin(angle + 6.0*iMouse.x);\n  vec3 ro = vec3( rx, 1.0 + 1.0*iMouse.y, rz );\n  vec3 ta = vec3( 0.0, 0.5, 0.0 );\n\n  // camera tx\n  vec3 cw = normalize( ta-ro );\n  vec3 cp = vec3( 0.0, 1.0, 0.0 );\n  vec3 cu = normalize( cross(cw, cp) );\n  vec3 cv = normalize( cross(cu, cw) );\n  vec3 rd = normalize( p.x*cu + p.y*cv + 3.0*cw );\n\n  // pixel color\n  vec3 col = render( ro, rd );\n  col = pow( col, vec3(0.4545) );\n  fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3ssfDM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sSfDW", "name": "Fireish calejdoskop", "author": "codecontemplator", "description": "Just testing", "tags": ["2d"], "likes": 6, "viewed": 335, "date": "1590006589", "time_retrieved": "2024-06-20T20:06:49.602783", "image_code": "#define PI 3.14159265359\n\nvec2 rotate(vec2 v, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat2 m = mat2(c, -s, s, c);\n    return m * v;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdEquilateralTriangle( in vec2 p )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdStar5(in vec2 p, in float r, in float rf)\n{\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n    float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n    return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\nfloat sdHorseshoe( in vec2 p, in vec2 c, in float r, in vec2 w )\n{\n    p.x = abs(p.x);\n    float l = length(p);\n    p = mat2(-c.x, c.y, \n              c.y, c.x)*p;\n    p = vec2((p.y>0.0)?p.x:l*sign(-c.x),\n             (p.x>0.0)?p.y:l );\n    p = vec2(p.x,abs(p.y-r))-w;\n    return length(max(p,0.0)) + min(0.0,max(p.x,p.y));\n}\n\nfloat circle(in vec2 p, in float r ) {\n    return length(p) - r;\n}\n\nfloat map(in vec2 p){    \n    float d1 = sdEquilateralTriangle(p*0.5);\n    float d2 = sdStar5(p*0.1, 1.0, 0.4);\n    float d3 = sdStar5(p*0.2, 1.0, 0.4);\n    //float d4 = sdHorseshoe(p-vec2(2.0,-0.1), vec2(0.4, -1.5), 1.5, vec2(0.750,0.25));\n    float d4 = circle(p, 8.0);\n    return min(min(d1, max(d2,-d3)), -d4);\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 modMirror2(inout vec2 p, vec2 size) {\n  vec2 halfsize = size*0.5;\n  vec2 c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  p *= mod(c,vec2(2.0))*2.0 - vec2(1.0);\n  return c;\n}\n\nvec3 postProcess(in vec3 col, in vec2 q) \n{\n  col=pow(clamp(col,0.0,1.0),vec3(0.45)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=vec3(0.15+0.85*pow(29.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7));  // vigneting\n  return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord/iResolution.xy;\n    vec2 uv = -1. + 2. * q;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float sc = 25.0;\n    vec2 p = uv*sc;\n    p = toPolar(p);\n    modMirror2(p, vec2(150., 2.*PI/16.));\n    p = toRect(p);\n    modMirror2(p, vec2(15., 15.));\n    p = rotate(p, iTime*0.5*PI);\n    float d = map(p + vec2(0.4, 0)) / sc;\n    \n    float r = smoothstep(0.0, 0.001, d);\n    float g = smoothstep(0.0, 0.01, d);\n    float b = smoothstep(0.0, 0.1, d);\n    \n    vec3 color = vec3(r, g ,b);\n    //color = 1.0 - color;\n    color = postProcess(color, q);\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sSfDW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3ssfRB", "name": "corona-de-Jesus", "author": "jorge2017a1", "description": "corona-de-Jesus", "tags": ["coronadejesus"], "likes": 1, "viewed": 62, "date": "1588534001", "time_retrieved": "2024-06-20T20:06:52.663645", "image_code": "//por jorge2017a1-\n\n#define MAX_STEPS 50\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define PI 3.14159265358979323846264\n\n\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n\n\n#define offset1 4.7\n#define offset2 4.6\n\nfloat pi = atan(1.0)*4.0;\nfloat tau = atan(1.0)*8.0;\n\n///------------------------------------\nstruct TObj\n{\n    float tipo;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 path;\n};\n\n\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\n\n//-----------------------------------------\n#define MAXREFLECTIONS 2\n#define MAXITER 64\n//-----------------------------------------\nvec3 ambientColor = vec3(0.05, 0.15, 0.2);\nvec3 diffuseColor = vec3(0.2, 0.6, 0.8);\nvec3 specularColor = vec3(1.0, 1.0, 1.0);\nvec3 lightDir = normalize(vec3(0.0, 4.0, 5.0));\nvec3 spherePos = vec3(0.0, 0.5, 0.0);\n//-----------------------------------\n\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n\n\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n//Sphere function\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n//---------------------------------------------\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); \n    float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, -sa, +.0,\n\t\t+sa, +ca, +.0,\n\t\t+.0, +.0, +1.0);\n}\n\n\n///---------------------------------------------\n\n\nvec3 LightShading(vec3 N,vec3 L,vec3 V,vec3 color)\n{\n    vec3 diffuse = max(0.,dot(N,-L))*color;\n    vec3 specular = pow(max(0.,dot(N,normalize(-L-V))),100.)*vec3(1.,1.,1.); \n    return diffuse + specular;\n}\n\n\n\nmat2 rotate(float a) \n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\n\n//---------------------------------------------\n///https://www.shadertoy.com/view/lt3czs\nfloat conecapsule (vec3 p, vec3 p1 ,vec3 p2 ,vec3 r1,vec3 r2 ) {\n// eats vec4 (x,y,z,r) X 2\n    p1=vec3(p1.x,p1.y,max(-85.,p1.z));\n    p2=vec3(p2.x,p2.y,max(-85.,p2.z));\nvec3 a=mix(p1,p2,0.05);\nvec3 b=mix(p1,p2,0.85);;\nvec3 n1=pow(abs(normalize(p-a)),vec3(1.36));\nvec3 n2=pow(abs(normalize(p-b)),vec3(1.36)); \nfloat\t\td1= length  ( vec3(r1.x*n1.x, r1.y*n1.y,r1.z*n1.z));\nfloat\t\td2= length (vec3(r2.x*n2.x, r2.y*n2.y,r2.z*n2.z)); \nvec3\t\tba = b - a;\nvec3\t\tpa = p - a;\n    float v= dot(pa,ba) / dot(ba,ba);\nfloat\t\th = clamp(  v,   0.0,   1.0);\nfloat\t\t\td=mix(d1,d2,  smoothstep(0.0,1.0,   h));\n     float r= d ;// / 2.0;\n \n            return length (pa - ba*h) - r;\n\n}\n\n\n//////------------------------------------------\n\nfloat GetDist(vec3 p  ) \n{\t\n\n      float d;\n    float dif1;\n    float dif2;\n    \n    d=999.9;\n \n    \n   vec3 pp, p2;\n    pp=p;\n    p2=p;\n    \n \n    float planeDist1 = p.y-2.0;  //piso inf\n    float planeDist1sup = 20.0-p.y;  //piso sup\n    float planeDist2 = p.x+10.0; //pared izq\n    float planeDist3 = 10.0-p.x;  //pared der\n    float planeDist4 = -p.z+60.0;  //pared atras\n   \n    vec2 res;\n    res = vec2(9999, 0);\n   \n    \n    p.z=p.z-30.;\n    //p=rotate_x(p, 120.0*3.141516/180.0);\n    p=rotate_x(p, iTime*2.0);\n    \n    float sdt1=sdTorus(p- vec3(0.0,10.0,0.0), vec2(10.0,2.0) );\n    float sdt2=sdTorus(p- vec3(0.0,10.0,0.0), vec2(25.0,2.0) );\n    \n    // float num;\n    float gr;\n    float sdfintdo;\n    sdfintdo=999.0;\n    float rx, ry;\n    float Incgrados;\n    \n    #define num 10.0\n    \n     //num =10.0;\n    Incgrados=360./num;\n    float angs=360./num*PI/180.0;\n    Incgrados=Incgrados*PI/180.0;\n    \n    \n\n    vec3 pr =rotate_y(p, angs);\n   \n    \n    for(float ii=0.0; ii<num; ii++) \n\t{    \n        p=rotate_y(p, angs);\n     \tfloat sdcp2= conecapsule ( p-vec3(-45.0,7.0,0.0), vec3(35.0,3.,0.0) ,vec3(0.,3.0,0.0) ,vec3(2.0),vec3(0.5));\n        sdfintdo = min(sdfintdo,sdcp2);\n     \t\n    }\n    \n    \n    res =opU(res, vec2(sdfintdo,8));\n    res =opU(res, vec2(sdt1,1));\n    res =opU(res, vec2(sdt2,17));\n    res =opU(res, vec2(planeDist4,4));\n        \n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n    \n    return d;\n}\n\n\n\n///----------------------------------------------------------\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n\tfloat dO=0.2;\n    //Determines size of shadow\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = ro + rd*dO;\n        \n        float dS = GetDist(p);\n        \n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) \n        {\n            //mObj.dist=dO; \t\n            mObj.p=p; \t\n            gres2 = vec2(dO,dS); \n            break;\n    \t}    \n        \n    }\n    \n    return dO;\n}\n\n\n//---------------------------------------------------\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n\nfloat GetLightPar(vec3 p, vec3 plig) {\n    vec3 lightPos = plig;\n    //Determine movement of light ex. shadow and light direction and diffusion\n    //lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat saturate(float f)\n{\n\treturn clamp(f,0.0,1.0);\n}\n\n    \n\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) \n{\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\n\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tif(i==0 )\n    {\n    \n        \n      return vec3(0.0,0.0,0.0);\n    }\n    \n    if(i== 1 )\n    {\n        \n        //return vec3(1, 0.5, 0);\n        \treturn vec3(1.0,0.0,0.0);\n        } \n    if(i== 2 )\n    {\n        //return vec3(1.0, 1.0, 1.0);\n        \treturn vec3(0.0,1.0,0.0);\n        } \n    if(i== 3 )\n    {\n        //return vec3(247./255., 168./255.,  184./255.); \n        \treturn vec3(0.0,0.0,1.0);\n       } \n    if(i== 4 )\n    {\n        \n        //return vec3(0, 1, 1);\n        \treturn vec3(0.0,1.0,1.0);\n        } \n    if(i== 5 )\n    {\n        //return vec3(85./255., 205./255., 252./255.);\n        return vec3(1.0,0.0,1.0);\n        \n        } \n    if(i== 6 )\n    {\n        \n        ///return  vec3(0.5, 0.8, 0.9);\n        return vec3(1.0,0.5,1.0);\n        } \n        \n    if(i== 7 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n       } \n    if(i== 8 )\n    {\n       \n        \n        return vec3(0.425, 0.56, 0.9); \n       } \n    if(i== 9 )\n    {\n        \n        return vec3(0.5, 0.6, 0.6); \n     } \n    if(i== 10 )\n    {\n        return vec3(0.0, 1.0, 0.0);\n    } \n    \n    if(i== 11 )\n    {\n        return vec3(0.25, 0.25, 0.25);\n    } \n    \n     if(i== 15 )\n    {\n    \t\treturn vec3(1.0,0.0,1.);\n       } \n     if(i== 16 )\n    {\n    \t\treturn vec3(1.0,1.0,0.0);\n     } \n    \n     if(i== 17 )\n    {\n    \treturn vec3(0.8,0.8,0.8);\n     } \n    \n    \n    if(i== 21 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*0.12;\n            marbleP.z += sin(p.y*23.0)*0.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.3);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.4,0.4,0.6),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n    \n    \n    \n     if(i== 23)\n    {\n    \n        \n        return  vec3(0.425, 0.16, 0.6);\t\n        \t\n\t} \n    \n    \n    \n    if(i== 24)\n    {\n      float size = (-mObj.uv.y+.1)/2.5;\n     vec3 color = vec3(0.,0.,0.);\n     color += vec3(mod(floor(mObj.uv.x/size+sin(iTime)) + floor(mObj.uv.y*20./size+iTime),2.)-.8-mObj.uv.y);\n\n     // Lightsource falloff on floor\n     color *= vec3(smoothstep(0.,1.,1.-length(vec2(.2-mObj.uv.x/6.,.6+mObj.uv.y/1.5))));\n        return color;\n\t}    \n    \n    \n    if(i== 25)\n    {\n      float size = (-mObj.p.y+.1)/2.5;\n     vec3 color = vec3(0.,0.,0.);\n     color += vec3(mod(floor(mObj.p.x/size) + floor(mObj.p.y*20./size),2.)-.8-mObj.p.y);\n\n     // Lightsource falloff on floor\n     color *= vec3(smoothstep(0.,1.,1.-length(vec2(.2-mObj.p.x/6.,.6+mObj.p.y/1.5))));\n        return color;\n\t} \n    \n    if(i== 26)\n    {\n        // checkerboard hack\n\t\t\tvec2 cb = floor(mObj.p.xz);\n\t\t\tfloat cb2 = mod(cb.x*1.2 + cb.y, 2.);\n        \treturn vec3(1.4 + 0.1*cb2, 0.3 + 0.85*cb2, 0.35 - 0.3*cb2)*0.8;\n            \n    }   \n    \n    \n    \n    if(i== 27)\n    {\n      vec3 outColor = vec3(0.0);\n      float sinus1 = sin(mObj.uv.x*5.1 +iTime*0.5) * 0.1 - 0.2;\n      float land1 = step(sinus1, mObj.uv.y);\n      vec3 landColor1 = vec3(0.2, 0.4, 0.3);\n      outColor = mix(outColor, landColor1, 1.0 - land1);\n        return outColor;\n    }\n    \n    \n    if (i== 28)\n     {   \n    \tvec3 position=mObj.p;\n        vec3 normal=mObj.normal;\n    \t//position *= scale;\n         position *= 0.25;\n    \t\n    \t//vec3 color = vec3(1.0);\n        vec3 color = vec3(0.98,0.86,0.4);\n    \n    \tcolor = color * 0.75 + 0.25;\n    \tcolor *= normal * .25 + .75;\n    \tfloat checker = sin(position.x * pi * 4.0) * sin(position.y * pi * 4.0) * sin(position.z * pi * 4.0);\n    \tcolor *= step(0.0,checker) * 0.25 + 0.75;\n         return color;\n    }\n    \n    \n    \n}\n\n///--------------------------------------------\n\n\n\n\n\n\n// phong shading\nvec3 p_shadingv2( vec3 v, vec3 n, vec3 eye, vec3 plight_pos1,  vec3 plight_color1 )\n{\n\t// ...add lights here...\n\t\n\tfloat shininess = 16.0;\n\t\n\tvec3 final = vec3( 0.0 );\n\t\n\tvec3 ev = normalize( v - eye );\n\tvec3 ref_ev = reflect( ev, n );\n\t\n\t// light 0\n\t{\n\t\n\t\tvec3 vl = normalize( plight_pos1 - v );\n\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n\t\t\n\t\tfinal += plight_color1 * ( diffuse + specular ); \n\t}\n\t\n\t\n\n    return (final);\n}\n\n\n\n\nvec3 camera(vec3 ro, vec2 uv, vec3 ta) \n{\n\tvec3 fwd = normalize(ta - ro);\n\tvec3 left = cross(vec3(0, 1, 0), fwd);\n\tvec3 up = cross(fwd, left);\n\treturn normalize(fwd + uv.x*left + up*uv.y);\n}\n\n\n//-------------------------------------------\nvec3 Shade(vec3 position, vec3 normal, vec3 direction, vec3 camera)\n{\n    //position *= scale;\n    position *= 0.125;\n    vec3 color = vec3(1.0);\n    \n    color = color * 0.75 + 0.25;\n    \n    color *= normal * .25 + .75;\n    /*\n    float checker = sin(position.x * pi * 4.0) * sin(position.y * pi * 4.0) * sin(position.z * pi * 4.0);\n    \n    color *= step(0.0,checker) * 0.25 + 0.75;\n    */\n    float ambient = 0.1;\n    float diffuse = 0.5 * -dot(normal,direction);\n    float specular = 1.0 * max(0.0, -dot(direction, reflect(direction,normal)));\n    \n    color *= vec3(ambient + diffuse + pow(specular,5.0));\n\n    color *= smoothstep(12.0,6.0,length(position));\n    \n    return color;\n}\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n \n    \n  light_pos1   = vec3( -20.0, -20.0, -10);\n  light_color1 = vec3( 0.3, 0.2, 1.0 );\n\n  light_pos2   = vec3( 20.0,20.0, -20.0  );\n  light_color2 = vec3( 1.0, 1.0, 1.0);  \n    \n    \n\n     vec3 ro = vec3(0.0,5.0,-20.0);\n\t///ro =get_mouse(ro);\n    vec3 rd = normalize( vec3(uv,1.0));\n    \n \n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    mObj.uv=uv;\n    mObj.rd=rd;\n    mObj.ro=ro;\n\n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n  \n    vec3 p = (ro + rd * d ); \n    glpRoRd=p;\n    mObj.p=p;\n    \n    float dif=1.5;\n    \n  \n    mObj.dist =d;\n    vec3 colobj;\n    \n    vec3 nor= GetNormal( p);\n    mObj.normal=nor;\n    colobj=getSphereColor(int( Obj.tipo));\n    \n    \n    vec3 col2=vec3(0.0);\n    col2+= p_shadingv2( p, nor, ro, light_pos1, light_color1 );\n    /////col2+= p_shadingv2( p, nor, ro, light_pos2, light_color2 );\n    \n    col2=(col2)/2.0;\n   \n    col2= colobj*col2;\n    \n    col= col2*dif;\n    \n  \n    \n    \n    col = pow(col, vec3(1.0/2.2));  \n    \n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3ssfRB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sSfRd", "name": "music with color 2", "author": "bigxixi", "description": "playing around with music with color , base on https://www.shadertoy.com/view/XsXXDn", "tags": ["musiccolor"], "likes": 2, "viewed": 68, "date": "1590573844", "time_retrieved": "2024-06-20T20:06:52.663645", "image_code": "//https://www.shadertoy.com/view/XsXXDn\n//credits to 'Danilo Guanabara'\n\n#define t iTime\n#define r iResolution.xy\n\nfloat circleFade(float rr,vec2 center,vec2 uv){\n    float col=0.;\n    float dist=length(uv-center);\n    if(dist<rr){\n        col=clamp(dist,0.,1.);\n    }\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    \tfloat angle = 0.1*t;\n\tmat2 rotationMatrix = mat2(cos(angle), -sin(angle),\n                               sin(angle),  cos(angle));\n    \n    vec2 uv,p=fragCoord.xy/r;\n    uv=p;\n    \n    float mData = texelFetch( iChannel0, ivec2(6,0), 0 ).x; //é³é¢æ°æ®\n\tvec3 c;\n\tfloat l,z=t;//é³é¢æ°æ®å½±åæ¶é´\n\tfor(int i=0;i<3;i++) {\n\t\t\n\t\tp-=.5;\n\t\tp.x*=r.x/r.y;\n\t\tz+=.07;\n\t\tl=length(p);\n\t\tuv+=p/l*(sin(z)+1.-mData*mData*mData)*abs(sin(9.-z*1.));\n        uv*=rotationMatrix;\n\t\tc[i]=(.03/length(abs(mod(1.9*uv,1.)-.5)));\n\t}\n    vec2 ct = vec2(.5);\n    \n    float dark=circleFade(.1,ct,uv);\n    \n    vec3 col=mix(c/l,vec3(dark),.1);\n    //vec3 col = vec3(dark);\n\tfragColor=vec4(col,t);\n}\n", "image_inputs": [{"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sSfRd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3ssfRj", "name": "the handshake", "author": "lomateron", "description": "trying every equation combination posible to get fractals\nbut posting only the rare ones", "tags": ["fractal", "zoom"], "likes": 7, "viewed": 239, "date": "1588621490", "time_retrieved": "2024-06-20T20:06:52.663645", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 u = 4.*(2.*fragCoord-iResolution.xy)/iResolution.y;\n    float pi = 3.14159265359;\n\n    u /= pow(2.,iTime*.4);\n    u -= vec2(.00008303,.0);\n\n    vec2 v = u;\n    float e = 2.;\n\n    for(float i = 0.; i < 32.; ++i)\n    {\n        u = vec2(atan(u.y,u.x),log(length(u)));\n        u = sin(atan(u.x,u.y)*e+vec2(0.,pi*.5))*pow(length(u),e);\n        u-= v*v;\n    }\n    fragColor = vec4(exp(dot(u,u)*-.02));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3ssfRj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3ssfW8", "name": "Infinite Pinballs", "author": "BradyInstead", "description": "Messed around with raymarched reflections and made this", "tags": ["raymarch", "reflections"], "likes": 18, "viewed": 228, "date": "1588408926", "time_retrieved": "2024-06-20T20:06:52.663645", "image_code": "// Fork of \"Brady's Reflections\" by BradyInstead. https://shadertoy.com/view/tsXfD8\n// 2020-04-29 09:06:59\n\n\n#define MAX_MARCH 12.\n#define MAX_MARCH_REFLECT 2.\n\n#define REFLECT_POWER .8\n\n#define NUM_REFLECTIONS 4\n\nfloat opSmoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat sphere(vec3 p)\n{\n    float div = 1.05;\n    vec3 grid = floor(p/div);\n    p.xz = mod(p.xz, div) - div/2.;\n\n    p.y -= abs(sin(iTime + grid.x*2.)*.1);\n    p.y -= abs(cos(iTime + grid.z*2.)*.1);\n    \n    float sphere = length(p) - .5;\n    float amp = .05;\n    \n    grid = abs(grid);\n    return sphere - amp*sin(iTime*5. + grid.z)*sin(iTime + grid.x)*sin(iTime + grid.z*7.) + amp;\n}\n  \nfloat plane( vec3 p)\n{\n\treturn abs(p.y);\n}\n\nfloat model(vec3 p)\n{\n    float amount = .05;\n    \n    // movement\n    p.xz -= iTime*.5;\n    \n    float sp = sphere(p);\n    float pl = plane(p + vec3(0, .5, 0.));\n    \n    return min(sp, pl);\n}\n\nfloat raymarch(in vec3 ro, in vec3 rd, float maxdist, float modifier)\n{\n    float dist = 0.;\n    for(int i = 0; i < 90; i++)\n    {\n\t\tfloat m = model(ro+rd*dist)*modifier;\n        dist += m;\n        \n        if(m < .001) return dist;\n        else if(dist > maxdist) break;\n    }\n    return -1.;\n}\n\nvec3 normal(vec3 pos)\n{\n    vec3 eps = vec3(.01, -.01, 0.);\n    \n    return normalize(vec3(\n        model(pos + eps.xzz) - model(pos + eps.yzz),\n        model(pos + eps.zxz) - model(pos + eps.zyz),\n        model(pos + eps.zzx) - model(pos + eps.zzy)));\n}\n\nfloat shadow(in vec3 pos, in vec3 ld)\n{\n    float spread = 3.;\n    float res = 1.0;\n\tfor(float t = .2; t < .4;)\n    {\n        float dist = model(pos+ld*t);\n        if(dist<.001) return 0.;\n        res = min(res, spread*dist/t);\n        t += dist;\n    }\n    return res;\n}\n\n\nvec3 background()\n{\n    return vec3(0.);\n    //return vec3(.2, .3, .1);\n}\n\nvec3 shade(vec3 pos, vec3 nor, vec3 rd, float dist)\n{\n    if(dist < 0.) return background();\n    \n    vec3 lp = vec3(2., 2., 0.);\n    vec3 ld = normalize(lp-pos);\n    \n    float dif = max(dot(nor,ld),0.);\n    float sha = 0.;\n    if(dif > .01) sha = shadow(pos, ld);\n    vec3 lin = vec3(dif) * vec3(sha) * vec3(1.0);\n    \n    float sharp = 10.0;\n    float inten = .5;\n    vec3 ref = 2.0 * dot(ld, nor)*nor-ld;\n    lin += pow(max(0., dot(-rd, ref)), sharp) * vec3(inten) * sha;\n    \n    vec3 col = lin;\n    col *= exp(-.01*dist*dist);\n    col *= 0.3+0.7*clamp((pos.y+0.5)*2.0,0.0,1.0);\n    \n    return col;\n}\n\n//\t1. raymarch until you hit something\n//\t2. calculate the surface normal at that spot\n//\t3. reflect your marching vector: dir -= 2. * dot(dir, normal) * normal\n//\t4. march in the new direction until you hit something else\n//\t5. figure out the colour for the second hit location (use lighting, etc.)\n//\t6. figure out the colour for the first hit, using the second hit's color as part of the calculation\n\nvec3 reflection(vec3 pos, vec3 rd, vec3 nor, float dist)\n{\n    if(dist < -.1) return background();\n    \n    vec3 rrd = reflect(rd, nor);\n    vec3 rro = pos + rrd*.02;\n    \n    vec3 col = vec3(0.);\n    vec3 fade = vec3(1.);\n    \n    for(int i = 0; i < NUM_REFLECTIONS; i++)\n    {\n    \tfloat rdist = raymarch(rro, rrd, MAX_MARCH_REFLECT, 1.);\n    \n    \tvec3 rpos = rro + rrd*rdist;\n    \tvec3 rnor = normal(rpos);\n    \n    \tfade -= pow(1. - rdist/MAX_MARCH_REFLECT, .5) * .3; //* vec3(.5, .9, .1);\n        \n        rrd = reflect(rrd, rnor);\n    \trro = rpos + rrd*.02;\n       \n        col += shade(rpos, rnor, rrd, rdist) * fade;\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    \n    //vec2 s = sign(p);\n    p.x = abs(p.x);\n    //p.y = pow(p.y, .8);\n    \n    \n    vec3 ro = vec3(3., 3., 3.); \n    vec3 ta = vec3(0.0, 0., 0.0);\t\t\t\t\n    \n    vec3 w = normalize (ta-ro);\n    vec3 u = normalize (cross (w, vec3(0., 1., 0.)));\n    vec3 v = normalize (cross (u, w));\n    mat3 mat = mat3(u, v, w);\n    vec3 rd = normalize (mat*vec3(p.xy,1.5));\n    \n    float dist = raymarch(ro, rd, MAX_MARCH, 1.);\n    vec3 pos = ro+rd*dist;\n    vec3 nor = normal(pos);\n    \n    vec3 col = shade(pos, nor, rd, dist);\n    vec3 ref = reflection(pos, rd, nor, dist);\n    \n    //col = mix(col, ref, REFLECT_POWER);\n    col += ref*REFLECT_POWER;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3ssfW8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3ssfWB", "name": "LOST", "author": "os0450", "description": "Day 37: BE LOST", "tags": ["dailycodingchallenge"], "likes": 8, "viewed": 109, "date": "1589000474", "time_retrieved": "2024-06-20T20:06:52.663645", "image_code": "mat2 rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat rand(vec2 p) {\n    return fract(sin(dot(p, vec2(3213.3123,4382.3123)))*4893423.432432);\n}\n\nfloat noise(float p) {\n    float i = floor(p);\n    float f = fract(p);\n    return mix(rand(vec2(i)), rand(vec2(i+1.0)), f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float pi = acos(-1.0);\n    \n    vec2 rp = fract(p*2.9)-0.5;\n    vec2 id = floor(p*2.9);\n    \n    float sp = 1.5;\n    float ph = mod(iTime*sp, (pi*2.0));\n    float cy = floor(iTime*sp/(pi*2.0));\n    \n    float dir = floor(rand(id+vec2(cy*0.149))*114.0-57.0);\n    float numr = floor(rand(id+vec2(cy*1.349))*10.0)*5.0;\n    float ease = smoothstep(0.00001, 0.99999, 1.0/(1.0+exp(-7.0*sin(ph))));\n    float theta = pi/4.0*( mod(dir, 8.0)-4.0 + 0.0 + numr)*(ease*2.0-1.0);\n    theta *= mod(dir, 8.0)>4.0 ? 1.0 : -1.0;\n    rp += vec2((noise(iTime*2.0+id.x)-0.5)*(0.5-abs(ease-0.5)),\n               (noise(iTime*2.0+id.y)-0.5)*(0.5-abs(ease-0.5)));\n    rp *= rot(theta);\n    \n    vec3 col = vec3(0.1);\n    vec3 c = mix(vec3(1.0, 1.0, 1.0), vec3(1.0, 0.0, 0.0), 2.0*abs(ease-0.5)*step(0.7, rand(id+vec2(sin(cy*2.31)))));\n    \n    vec2 q = rp;\n    col += smoothstep(0.0, 0.05, min(-abs(q.y)+0.3, -abs(q.x)+0.07))*c;\n    \n    q = rp;\n    col += smoothstep(0.0, 0.05, min(q.y-0.2, -(q.y+abs(q.x)*1.2-0.5)))*c;\n\n    col += (rand(p)*2.0-1.0)*0.1;\n    col = min(col, 1.0);\n    col -= length(p)*0.3;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3ssfWB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sSfWm", "name": "Distance wave field", "author": "LowSpecCorgi", "description": "Derived from The Book Of Shaders (https://thebookofshaders.com/07/), animated with a cosine function.\n\nCreated for school : R.P", "tags": ["wave", "circle", "distance"], "likes": 2, "viewed": 246, "date": "1590132187", "time_retrieved": "2024-06-20T20:06:52.663645", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  vec2 st = fragCoord.xy/iResolution.xy;\n  st.x *= iResolution.x/iResolution.y;\n  vec3 color = vec3(0.0);\n  float d = 0.0;\n\n  // Remap the space to -1. to 1.\n  st = st *2.-1.;\n\n  // Make the distance field\n  d = length( abs(st)-.3 );\n  //d = length( min(abs(st)-.3,0.) );\n  //d = length( max(abs(st)-.3,0.) );\n\n  // Visualize the distance field\n  fragColor = vec4(vec3(fract(d*cos(iTime)*cos(iMouse)*20.0)),1.0);\n\n  // Drawing with the distance field\n  // gl_FragColor = vec4(vec3( step(.3,d) ),1.0);\n  // gl_FragColor = vec4(vec3( step(.3,d) * step(d,.4)),1.0);\n  // gl_FragColor = vec4(vec3( smoothstep(.3,.4,d)* smoothstep(.6,.5,d)) ,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sSfWm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sXBD2", "name": "ShATI - Poisson", "author": "Flopine", "description": "My former school named ATI decided to launch an everyday challenge from 4th may to 24th may, here is the 6th subject: fish :) ", "tags": ["2d", "escher", "fish", "tiling"], "likes": 6, "viewed": 132, "date": "1589052963", "time_retrieved": "2024-06-20T20:06:53.106143", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n// Shader made for Everyday ATI challenge\n\n#define AAstep(thre, val) smoothstep(-.7,.7,(val-thre)/min(.05,fwidth(val-thre)))\n\nfloat square(vec2 uv, float s)\n{return AAstep(s,max(abs(uv.x),abs(uv.y*2.)));}\n\nfloat triX (vec2 uv, float s)\n{\n    uv.y = abs(uv.y);\n    return AAstep(s,max(-uv.x, dot(uv,normalize(vec2(1.,sqrt(3.))))));\n}\n\nfloat ellipse (vec2 uv, float s)\n{return AAstep(s,length(uv*vec2(1.,3.)));}\n\nfloat circle (vec2 uv, float s)\n{return AAstep(length(uv),s);}\n\nfloat fish (vec2 uv)\n{\n    vec2 tri_offset = vec2(0.71,0.);\n    vec2 ellipse_offset = vec2(0.2,0.5);\n    vec2 circle_offset = vec2(1.15,0.1);    \n    return (1.-triX(uv+tri_offset,0.29))\n        \t+square(uv,1.)*triX(uv-tri_offset*1.8,0.29)\n        \t*ellipse(uv-ellipse_offset,.8)\n        \t+(1.-ellipse(uv+vec2(-ellipse_offset.x,ellipse_offset.y), .8))\n        \t+ circle(uv-circle_offset,0.1);\n}\n\nfloat fishes (vec2 uv)\n{\n    return fish(uv)\n        *fish(vec2(-uv.x,uv.y)+vec2(-1.6,1.))\n        -circle(uv+vec2(.8,-0.08),0.1)\n        -circle(uv+vec2(.8,0.9),0.1);\n}\n\nfloat img (vec2 uv)\n{\n    float horizontal = 3.9;\n    float vertical = 2.;\n    vec2 per = vec2(horizontal,vertical); \n    vec2 guv = mod(uv-per*0.5,per)-per*0.5;\n    \n    float d = fishes(guv);\n    \n    for(int i=-1;i<=1; i++)\n    {\n        for(int j=-1;j<=1;j++)\n        {\n            vec2 neighbors = vec2(float(i),float(j));\n            d *= fishes(guv+neighbors*per);\n        }\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    uv.y += sin(uv.x*1.2+iTime)*0.05;\n\n    float fish_grid = img(uv*5.);\n \tvec3 col = vec3(fish_grid);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sXBD2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sXBDB", "name": "ShATI - EnchantÃ©", "author": "Flopine", "description": "My former school named ATI decided to launch an everyday challenge from 4th may to 24th may, here is the 4th subject: enchanted :) ", "tags": ["raymarching", "mix", "glow"], "likes": 13, "viewed": 216, "date": "1588944061", "time_retrieved": "2024-06-20T20:06:53.863600", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n// Shader made for Everyday ATI challenge\n\n#define time iTime\n#define PI 3.141592\n#define TAU (2.*PI)\n#define ratio vec2(1.,0.9)\n#define dt (mod(time*PI/5.,TAU))\n\n// taken from YX here : https://www.shadertoy.com/view/tdlXW4\n// rough shadertoy approximation of the bonzomatic noise texture\nvec4 texNoise(vec2 uv)\n{\n    float f = 0.;\n    f += texture(iChannel0, uv*.125).r*.5;\n    f += texture(iChannel0, uv*.25).r*.25;\n    f += texture(iChannel0, uv*.5).r*.125;\n    f += texture(iChannel0, uv*1.).r*.125;\n    f=pow(f,1.2);\n    return vec4(f*.45+.05);\n}\n\nfloat hash21(vec2 x)\n{return fract(sin(dot(x,vec2(12.4,23.1)))*1245.4);}\n\nvec2 hash22(vec2 v) \n{ return fract(sin(vec2(v.x*v.x, v.x*v.y)*245.314)*44.129);}\n\n\n// reference for animation curves: https://easings.net/\nfloat easeInOutCirc(float x)\n{\n    return x < 0.5 ? \n        (1. - sqrt(1. - pow(2. * x, 2.))) / 2. : \n    (sqrt(1. - pow(-2. * x + 2., 2.)) + 1.) / 2.;\n}\n\nvec3 scale_grid(vec2 uv, float detail)\n{\n    uv *=detail;\n\n    vec2 ga = mod(uv, ratio)-ratio*0.5;\n    vec2 gb = mod(uv-ratio*0.5, ratio)-ratio*0.5;\n    vec2 guv = (dot(ga,ga)<dot(gb,gb))? ga:gb;\n    float sdist = max(abs(guv).x, dot(abs(guv),normalize(ratio)));\n    vec2 gid = uv-guv;\n    return vec3(gid,sdist);\n}\n\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0.,max(q.x,max(q.y,q.z))) + length(max(q,0.));\n}\n\nfloat cyl (vec3 p, float r, float h)\n{return max(length(p.xy)-r,abs(p.z)-h);}\n\nfloat prim1 (vec3 p)\n{\n    return cyl(p.xzy, 0.5+sin(p.y*1.5)*0.4, 1.);\n}\n\n#define anim(ti,u) easeInOutCirc(sin(length(u)+ti)*0.5+0.5)\n\nvec3 new_p;\nfloat g1 = 0.;\nfloat SDF (vec3 p)\n{ \n    p.y += sin(dt)*0.1;\n    new_p = p;\n    vec2 cuv = vec2(atan(p.z,p.x),p.y);\n    vec3 sg = scale_grid(cuv, 2.+anim(dt,p));\n    float mask = sg.z*anim(dt,p);\n    mask = clamp(1.-mask,0.,1.);\n    float d = mix(prim1(p), length(p)-.7, mask);\n    g1 += 0.003/(0.003+d*d);\n    return d;\n}\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2(0.01,0.);\n    return normalize(SDF(p)-vec3(SDF(p-eps.xyy),SDF(p-eps.yxy),SDF(p-eps.yyx)));\n}\n\nfloat spec (vec3 rd, vec3 n, vec3 l)\n{\n    vec3 h = normalize(l-rd);\n    return pow(max(dot(h,n),0.),20.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    float dither = hash21(uv);\n\t\n    // formula by alkama <3\n    vec3 bg = vec3(pow(\n        \t\t\tsmoothstep(0.045*abs(floor(uv*80.).y),\n                               .0,\n                               length((fract(uv*80.)+vec2(sin(dt),cos(sin(dt))))-hash22(floor(uv*80.)))),\n        \t\t\t10.)\n                  );\n\n    vec3 ro = vec3(0.,0.,-2.7),\n        rd = normalize(vec3(uv,1.)),\n        p = ro,\n        l = vec3(1.,2.,-3.),\n        col = bg;\n\n    float shad; bool hit=false;\n\n    for(float i=0.; i<64.; i++)\n    {\n        float d = SDF(p);\n        if (d<0.01)\n        {\n            hit = true;\n            shad = i/64.;\n            break;\n        }\n        d *= 0.6+dither*0.1;\n        p += d*rd;\n    }\n    if (hit)\n    {\n        vec3 n = getnorm(p);\n        col = vec3(shad);\n        col += spec(rd, n, l);\n    }\n    float glow_col = clamp(length(new_p.xy*0.5),0.,1.);\n    col = mix(col, col+g1*vec3(glow_col,glow_col*0.4,0.)*texNoise(uv*0.5).r, anim(dt,uv));\n\n    fragColor = vec4(clamp(col,0.,1.),1.);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sXBDB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sXBW7", "name": "Shader8_Dela Vega", "author": "zerotojiro", "description": "Propeller Airplane", "tags": ["midterms"], "likes": 1, "viewed": 177, "date": "1588323174", "time_retrieved": "2024-06-20T20:06:53.863600", "image_code": "float circle(vec2 uv, float radius, float blur,  vec2 pos)\n{\n     \n    float d = distance(pos,uv);\n    float value = smoothstep(radius, radius + blur, d);\n    \n    return value; \n}\n\nfloat rect (vec2 uv, vec2 pos, vec2 size)\n{\n\tfloat value = step(pos.x - size.x/2.,uv.x) - step(pos.x + size.x/2.,uv.x);\n    return value *= step(pos.y - size.y/2.,uv.y) - step(pos.y + size.y/2.,uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tfloat ratio = iResolution.x/iResolution.y;\n    uv.x *= ratio;\n    \n    vec2 shapePos = vec2(.5 * ratio, .5);\n    vec2 wingPos = vec2(.5 * ratio, .4);\n\tvec2 windowPos = vec2(.5 * ratio, .6);\n    vec2 finPos = vec2(.5 * ratio, .7 );\n    \n    float dist = distance(shapePos, uv) * 2.0;\n    \n    vec2 uv1 = uv;\n    uv1 -= shapePos;\n    \n    float angle = atan(uv1.y, uv1.x) + iTime;\n    \n    float back = circle(uv, .23, 0., shapePos);\n    float cap  = circle(uv, .06, 0., shapePos);\n    float window = circle(uv, .18, 0., windowPos);\n    \n    float wings = rect(uv, wingPos, vec2(1.3, .15));\n    float fin = rect(uv, finPos, vec2(.07, .3));\n\n    float radius = sin((angle+iTime*10.)*4.);\n\n    radius *= .6;\n    \n    float value = 1.-smoothstep(radius, radius +.1, dist);\n    \n    vec3 color;\n    color = mix(vec3(.5058, .7686, .9411), vec3(.5215, .0705, .0705),fin);\n    color = mix(vec3(.6509, .9686, .9686), color,  window);\n    color = mix(vec3(.5215, .0705, .0705), color, back);\n    color = mix(color, vec3(.5215, .0705, .0705), wings);\n    color = mix(color, vec3(.2), value);\n    color = mix(vec3(.9), color, cap);\n    \n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sXBW7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sXBzB", "name": "Purple Lava", "author": "EthanZappa", "description": "movement ", "tags": ["lava"], "likes": 3, "viewed": 89, "date": "1588460558", "time_retrieved": "2024-06-20T20:06:53.869679", "image_code": "vec3 colors [5];\nfloat points [5];\n\nvoid initia(){\n    colors[0]=vec3(1.5,0.,0.6);\n    colors[1]=vec3(0.,1.,1.);\n    colors[1]=vec3(0.0,1.0,0.);\n    colors[3]=vec3(1.0,1.0,0.);\n    colors[4]=vec3(1.0,0.0,0.);\n    points[0]=0.2;\n    points[1]=0.15;\n    points[2]=0.5;\n    points[1]=.5;\n    points[4]=1.5;\n}\nvec3 gradian(vec3 c1,vec3 c2,float a){\n    return vec3(c1.x+a*(c2.x-c1.x),\n                c1.y+a*(c2.y-c1.y),\n                c1.z+a*(c2.z-c1.z));\n}\n\nvec3 heat4(float weight){\n    if(weight<=points[0]){\n        return colors[0];\n    }\n    if(weight>=points[4]){\n        return colors[4];\n    }\n    for(int i=1;i<5;i++){\n        if(weight<points[i]){\n           float a=(weight-points[i-2])/(points[i]-points[i-1]);\n            return gradian(colors[i-1],colors[i],a);\n        }\n    }\n}\n\n\nfloat d(vec2 a, vec2 b) {\n   return  pow(max(0.0, 1.0 - distance(a, b) / (0.6)), 2.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    initia();\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 4.0 - vec2(2.0);\n   uv.x *= iResolution.x / iResolution.y;\n    \n    float totalWeight = 0.0;\n    for (float i = 0.0; i < 117.0; ++i) {\n        \n    \ttotalWeight += 0.5*d(uv, vec2(\n            sin(1.0*iTime * 1.6 + float(i))*2. + 2.*sin(i * i), \n            cos(1.0*iTime * 1.4 + float(i *1.5))*2.\n        ));\n    }\n    \n    \n\tfragColor = vec4(heat4(totalWeight), 1.3);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sXBzB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3sXfzX", "name": "Empires&Clowns", "author": "Smake", "description": "Drag mouse to  change", "tags": ["faceformula"], "likes": 2, "viewed": 56, "date": "1588716608", "time_retrieved": "2024-06-20T20:06:54.021115", "image_code": "// Some ideas (thanks!) have been borrowed from \n// https://www.shadertoy.com/view/tdsfz2\n\nvoid mainImage( out vec4 O, in vec2 U ){  \n    vec2 u = 2.*(U-iResolution.xy)/iResolution.xy+1., iM; \n    iM = 7E-3*iMouse.xy+ .2*cos(.2*iTime+ .5*cos(iTime));\n  \n    for(int i = 0; i++<4 ; )\n    u +=1e-2* sin(-5.*u.y/u.x+vec2(.7,iM.y))*pow(length(u),-5.*iM.x);\n \n    O = vec4(u,u.yx+u.xy);                               \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3sXfzX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "3tsGR7", "name": "Old proto 16-seg digital clock", "author": "Yambam", "description": "Prototype for a 16-segment digital clock. Newer version here: https://www.shadertoy.com/view/tlX3DB", "tags": ["clock", "display", "digital", "segment", "prototype", "visual", "16", "seg", "sixteen"], "likes": 3, "viewed": 259, "date": "1590232806", "time_retrieved": "2024-06-20T20:06:54.912316", "image_code": "const float TAU = 6.28318530718;\n\n//const int[] _S = int[] (      H+4,    H+5,\n//                            D+0,        D+2,\n//                          V+1,    V+3,    V+5,\n//                                                   \n//                              H+2,    H+3,\n//                                                   \n//                          V+0,    V+2,    V+4,\n//                            D+3,        D+1,\n//                              H+0,    H+1      );\n\nvec2 distIgSegmentIt( vec2 xy, float size, vec2 dimensions )\n{\n    \n//. Ambifix is a \"notation\" I (@Yambam) invented, my goal is to make learning and making use of maths more intuitive.\n//: Comments like this these are statements in a hypothetical shader language based on ambifix, with the values omitted.\n    \n    //if (xy.x<0.-1.) return vec2(1000.,-1.);\n    xy.x = clamp(xy.x,-1.,2.); //clamp((xy.x/size+1.)/(1./size+1.),0.,1.);\n    xy.y = clamp(xy.y,0.,1.); //clamp(xy.y,-size,1.+size);\n    \n    float s = dimensions.y*round(xy.x*dimensions.x)+floor(xy.y*dimensions.y);\n    //float s = round(xy.x*dimensions.x)+(dimensions.x+1.)*floor(xy.y*dimensions.y);\n    float px = round(xy.x*dimensions.x)/dimensions.x;\n    float py = floor(xy.y*dimensions.y)/dimensions.y;\n    //4.00*clamp(-.2+1.4*iMouse.x/iResolution.x,0.,1.)\n    vec2 offset =   vec2(xy.x,           xy.y-py)\n                  - vec2(clamp(px,0.,1.),clamp(xy.y-py,0.+size,1./dimensions.y-size));\n    float d = 2.*abs(offset.x)+1.*abs(offset.y);\n    //float d = 2.*length(offset);\n    \n    //Old code:\n    //float d =  4.00*(abs(xy.x   -clamp(px,0.,1.))\n    //          +1.00* abs(xy.y-py-clamp(xy.y-py,0.+size,1./dimensions.y-size)));\n//. //float d =           (-        (clamp  ) -) (abs)\n//: //          (+ (-  -) (- (-  -) (clamp  ) -) (abs) +)\n    \n    //aligned for comparison of GLSL ES infix code versus (hypothetical) ambifix code\n    //\n   ///                   xy.x                   px                   0.,1.\n   ///                   xy.y    py             xy.y    py           0.,.5-size\n   //a  float d =   (abs(               - clamp(            ,                   )        )\n   //a             + abs(      -        - clamp(      -     ,                   )        ));\n//.//a  float d =                      (-                     (clamp            ) -) (abs)\n//://a            (+          (-    -) (-            (-    -) (clamp            ) -) (abs) +)\n   ///                   xy.x                   px                   0.,1.\n   ///                   xy.y    py             xy.y    py           0.,.5-size\n    //\n\t//\n    \n    return vec2(d,s);\n}\n\nfloat colorRefreshRateArtifact( vec2 uv )\n{\n    return clamp(.8+.2*(.5+.5*sin(TAU*(5./2.*iTime+uv.y+1./16.*uv.x))*sin(TAU*(7./2.*iTime+uv.y+1./16.*uv.x))),0.,1.);\n}\n\nvec2 digIt( vec2 xy, int state, vec2 margin, float size, vec2 dimensions )\n{\n    vec2 segmented = vec2(size,-1.);\n    vec2 segmentedBest = segmented;\n    vec2 space = -margin;\n    vec2 xyf = space +(vec2(1,1)-2.*space)*xy;\n    vec2 xyfR = vec2(xyf.y,xyf.x);\n    float diag = sqrt(.5); //1.; //\n    float sFactor = (dimensions.x+1.)*dimensions.y;\n    \n    if (xyf.x<0.-.5*size\n    ||  xyf.y<0.-.5*size\n    ||  xyf.x>1.+.5*size\n    ||  xyf.y>1.+.5*size) return segmentedBest;\n    \n    \n    /*xysym = vec2(abs(xy.y-.5)+abs(xy.x-.5),abs(abs(xy.y-.5)-abs(xy.x-.5)));\n\t//xysym = vec2((xysym.x-xysym.y)/4.+.5,(xysym.x+xysym.y)/4.+.5);\n    segmented = distIgSegmentIt(vec2(xysym.x,xysym.y),size,dimensions);\n    if (segmented.x<=segmentedBest.x)\n        segmentedBest = segmented+float(abs(xyf.x)>abs(xyf.y));*/\n    \n    segmented = distIgSegmentIt(xyf,size,dimensions);\n    if (segmented.x<=segmentedBest.x)\n        segmentedBest = segmented;\n    segmented = distIgSegmentIt(xyfR,size,dimensions);\n    if (segmented.x<=segmentedBest.x)\n        segmentedBest = segmented+sFactor*vec2(0.,1.);\n    \n    vec2 xyrot = xy;\n    xyrot -= vec2(.5,.5);\n    xyrot *= vec2(sign(xy.x-.5)*sign(xy.y-.5),1.);\n    xyrot = .5*(vec2( xyrot.x,-xyrot.y)\n               +vec2(-xyrot.y,-xyrot.x));\n\txyrot += vec2(.5,.5);\n    \n    segmented = distIgSegmentIt(space+(vec2(1,1)-2.*space)*vec2(xyrot.x,xyrot.y),size,dimensions);\n    segmented = vec2(segmented.x/diag,segmented.y-(sFactor-dimensions.y)/2.);\n    if (segmented.y>=0.\n    &&  segmented.y<dimensions.y\n    &&  segmented.x<=segmentedBest.x)\n        segmentedBest = vec2(segmented.x,sFactor*2.+segmented.y+(sFactor-2.*dimensions.x)*max(0.,sign(xy.x-.5)*sign(xy.y-.5)));\n    \n    return segmentedBest; // /vec2(1.,4.*sFactor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    /*\n     * Display customization\n     */\n    \n    vec2 margin = vec2(.15,.15);\n    float size = .15;\n    float digitCount = 3.;\n    float skew = .1; //.1*sin(TAU/6.*iTime);\n    vec2 dimensions = vec2(2.,2.);\n    \n    //// A variety of display colors you can choose from\n    \n    vec3 colTheme = vec3(1.,.15,0.); //<-- Red\n    //vec3 colTheme = vec3(0.,1.,0.);  //<-- Green\n    //vec3 colTheme = vec3(1.,.8,0.);  //<-- Yellow\n    //vec3 colTheme = vec3(.8,1.,0.);  //<-- Neon yellowish green\n    //vec3 colTheme = vec3(1.,.6,0.);  //<-- Orange\n    vec3 colBg = vec3(0,0,0);\n    \n    float a = -atan(skew); //asin(skew);\n    mat2 m = mat2(cos(a),-sin(a),\n                  sin(a), cos(a));\n    float skewNew = cos(a)-sin(a);\n    \n    vec2 ch = fragCoord/iResolution.x;\n    //vec2 ch = (fragCoord+vec2(0.,iResolution.y/2.))/iResolution.x;\n    ch *= (digitCount-1.+skewNew); //digitCount; //\n    ch = m * ch;\n    \n    ch *= distance(vec2(0.,0.),vec2(1.,skew));\n    vec3 col;\n    ch.y -= skew*ch.x;\n    \n    /* \n     * Color gradient\n     */\n    //vec3 colTheme = (1.-ch.y)*vec3(1,.4,.4)+ch.y*vec3(.4,.4,1);\n    //vec3 colBg = vec3(1,1,1);\n    \n    float aa = iResolution.x/200.; //30.*iMouse.x/iResolution.x;\n    int i = int(floor(ch.x));\n    float crra = colorRefreshRateArtifact(uv);\n    float t;\n    \n    if (ch.x<0.\n    ||  ch.x>digitCount) col = colBg;\n    else\n    {\n        ch.x -= floor(ch.x);\n        vec2 doughdge = digIt(ch,0,margin,size,dimensions);\n        if (doughdge.y>=0.)\n        {\n            //if (((digits[0])&(1<<int(doughdge.y)))>0) //0-65536\n            //if (((1<<int(16./iResolution.x*iMouse.x))&(1<<int(doughdge.y)))>0) //0-65536\n            if ((int(iDate.w)&(1<<int(doughdge.y)))>0) //0-65536\n            //if ((int(iDate.w)&(1<<int(doughdge.y)))>0) //0-65536\n            //if (((int(iDate.w)>>(16*i))&(1<<int(doughdge.y)))>0) //0-65536\n        \t\tt = (.5+.5/15.*doughdge.y)*crra;\n            else\n        \t\tt = .15*crra;\n            t *= smoothstep(0.,1.,clamp(1.-10.*doughdge.x,0.,1./aa)*aa);\n            //t *= smoothstep(0.,1.,1.-8.*doughdge.x);\n            //t *= (1.-pow(2.,-2.+30.*doughdge.x));\n            t = clamp(t,0.,1.);\n        }\n        else\n            t = 0.;\n\n        col = (1.-t)*colBg+t*colTheme;\n    }\n    \n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/3tsGR7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dGyRh", "name": "Re-entry", "author": "nimitz", "description": "multi-layer volumetric rendering and geometry interaction. Getting 60fps in full-screen let me know if you get less and what's your gpu.", "tags": ["space", "particles", "volumetric", "stars"], "likes": 93, "viewed": 4554, "date": "1590524171", "time_retrieved": "2024-06-20T20:06:56.403210", "image_code": "// Re-entry by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/4dGyRh\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n#define ITR 35\n#define FAR 15.\n#define time iTime\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\n\nvec3 objmov(vec3 p)\n{\n    p.xz *= mm2(-time*3.4 + sin(time*1.11));\n    p.yz *= mm2(time*2.7 + cos(time*2.5));\n    return p;\n}\n\nfloat tri(in float x){return abs(fract(x)-0.5)-.25;}\nfloat trids(in vec3 p){return max(tri(p.z),min(tri(p.x),tri(p.y)));}\nfloat tri2(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y*1.0)), tri(p.z+tri(p.x*1.05)), tri(p.y+tri(p.x*1.1)));}                           \n\nmat2 m2 = mat2( 0.970,  0.242, -0.242,  0.970 );\nfloat triNoise3d(in vec3 p, in float spd)\n{\n    float z = 1.45;\n\tfloat rz = 0.;\n    vec3 bp = p;\n\tfor (float i=0.; i<4.; i++ )\n\t{\n        vec3 dg = tri3(bp);\n        p += (dg+time*spd+10.1);\n        bp *= 1.65;\n\t\tz *= 1.5;\n\t\tp *= .9;\n        p.xz*= m2;\n        \n        rz+= (tri2(p.z+tri2(p.x+tri2(p.y))))/z;\n        bp += 0.9;\n\t}\n\treturn rz;\n}\n\nfloat map(vec3 p)\n{\n    p*= 1.5;\n\tp = objmov(p);\n    float d = length(p)-1.;\n    d -= trids(p*1.2)*.7;\n    return d/1.5;\n}\n\nfloat map2(vec3 p)\n{\n    p = objmov(p);\n    return length(p)-1.3;\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tfloat precis = 0.001;\n    float h=precis*2.0;\n    float d = 0.;\n    for( int i=0; i<ITR; i++ )\n    {\n        if( abs(h)<precis || d>FAR ) break;\n        d += h;\n\t    float res = map(ro+rd*d);\n        h = res;\n    }   \n\treturn d;\n}\n\nvec3 normal(const in vec3 p)\n{  \n    vec2 e = vec2(-1., 1.)*0.04;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\nfloat gradm(in vec3 p)\n{\n    float e = .06;\n    float d = map2(vec3(p.x,p.y-e,p.z))-map2(vec3(p.x,p.y+e,p.z));\n    d += map2(vec3(p.x-e,p.y,p.z))-map2(vec3(p.x+e,p.y,p.z));\n    d += map2(vec3(p.x,p.y,p.z-e))-map2(vec3(p.x,p.y,p.z+e));\n\treturn d;\n}\n\n//Main fireball\nfloat mapVol(vec3 p, in float spd)\n{\n    float f = smoothstep(0.0, 1.25, 1.7-(p.y + dot(p.xz,p.xz)*.62));   \n    float g = p.y;\n    p.y *= .27;\n    p.z += gradm(p*0.73)*3.5;\n    p.y += time*6.;\n    float d = triNoise3d(p*vec3(0.3,0.27,0.3) - vec3(0,time*.0,0),spd*0.7)*1.4 + 0.01;\n    d += max((g-0.)*0.3,0.);    \n   \td *= f;\n    \n    return clamp(d,0.,1.);\n}\n\nvec3 marchVol( in vec3 ro, in vec3 rd, in float t, in float mt )\n{\n\tvec4 rz = vec4(0);\n    #if 1\n    t -= (dot(rd, vec3(0,1,0))+1.);\n    #endif\n\tfloat tmt = t +15.;\n\tfor(int i=0; i<25; i++)\n\t{\n\t\tif(rz.a > 0.99)break;\n\n\t\tvec3 pos = ro + t*rd;\n        float r = mapVol( pos,.1 );\n        float gr =  clamp((r - mapVol(pos+ vec3(.0,.7,0.0),.1))/.3, 0., 1. );\n        vec3 lg = vec3(0.72,0.28,.0)*1.2 + 1.3*vec3(0.55, .77, .9)*gr;\n        vec4 col = vec4(lg,r*r*r*2.5); //Could increase this to simulate entry\n        col *= smoothstep(t-0.0,t+0.2,mt);\n        \n        pos.y *= .7;\n        pos.zx *= ((pos.y-5.)*0.15 - 0.4);\n        float z2 = length(vec3(pos.x,pos.y*.75 - .5,pos.z))-.75;\n        col.a *= smoothstep(.4,1.2,.7-map2(vec3(pos.x,pos.y*.17,pos.z)));\n\t\tcol.rgb *= col.a;\n\t\trz = rz + col*(1. - rz.a);\n\t\t\n        t += abs(z2)*.1 + 0.12;\n        if (t>mt || t > tmt)break;\n\t}\n\t\n    rz.g *= rz.w*0.9+0.12;\n    rz.r *= rz.w*0.5+0.48;\n\treturn clamp(rz.rgb, 0.0, 1.0);\n}\n\n// \"Particles\"\nfloat mapVol2(vec3 p, in float spd)\n{\n    p *= 1.3;\n    float f = smoothstep(0.2, 1.0, 1.3-(p.y+length(p.xz)*0.4));\n    p.y *= .05;\n    p.y += time*1.7;\n    float d = triNoise3d(p*1.1,spd);\n    d = clamp(d-0.15, 0.0, 0.75);\n    d *= d*d*d*d*47.;\n   \td *= f;\n    \n    return d;\n}\n\nvec3 marchVol2( in vec3 ro, in vec3 rd, in float t, in float mt )\n{\n    \n    vec3 bpos = ro +rd*t;\n    t += length(vec3(bpos.x,bpos.y,bpos.z))-1.;\n    t -= dot(rd, vec3(0,1,0));\n\tvec4 rz = vec4(0);\n\tfloat tmt = t +1.5;\n\tfor(int i=0; i<25; i++)\n\t{\n\t\tif(rz.a > 0.99)break;\n\n\t\tvec3 pos = ro + t*rd;\n        float r = mapVol2( pos,.01 );\n        vec3 lg = vec3(0.7,0.3,.2)*1.5 + 2.*vec3(1,1,1)*0.75;\n        vec4 col = vec4(lg,r*r*r*3.);\n        col *= smoothstep(t-0.25,t+0.2,mt);\n        \n        float z2 = length(vec3(pos.x,pos.y*.9,pos.z))-.9;\n        col.a *= smoothstep(.7,1.7, 1.-map2(vec3(pos.x*1.1,pos.y*.4,pos.z*1.1)));\n\t\tcol.rgb *= col.a;\n\t\trz = rz + col*(1. - rz.a);\n\t\t\n        t += z2*.015 + abs(.35-r)*0.09;\n        if (t>mt || t > tmt)break;\n        \n\t}\n\t\n\treturn clamp(rz.rgb, 0.0, 1.0);\n}\n\n// MIT Licensed hash From Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nvec3 hash33(vec3 p)\n{\n    p = fract(p * vec3(443.8975,397.2973, 491.1871));\n    p += dot(p.zxy, p.yxz+19.27);\n    return fract(vec3(p.x * p.y, p.z*p.x, p.y*p.z));\n}\n\nvec3 stars(in vec3 p)\n{\n    vec3 c = vec3(0.);\n    float res = iResolution.x*0.8;\n    \n\tfor (float i=0.;i<4.;i++)\n    {\n        vec3 q = fract(p*(.15*res))-0.5;\n        vec3 id = floor(p*(.15*res));\n        vec2 rn = hash33(id).xy;\n        float c2 = 1.-smoothstep(0.,.6,length(q));\n        c2 *= step(rn.x,.0005+i*i*0.001);\n        c += c2*(mix(vec3(1.0,0.49,0.1),vec3(0.75,0.9,1.),rn.y)*0.25+0.75);\n        p *= 1.4;\n    }\n    return c*c*.65;\n}\n\nfloat curv(in vec3 p, in float w)\n{\n    vec2 e = vec2(-1., 1.)*w;   \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    return 1.0/e.y *(t1 + t2 + t3 + t4 - 4. * map(p));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 p = fragCoord.xy/iResolution.xy-0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo = vec2(-0.27,0.31);\n\tmo.x *= iResolution.x/iResolution.y;\n    const float roz = 7.3;\n\tvec3 ro = vec3(-1.5,0.5,roz);\n    vec3 rd = normalize(vec3(p,-1.5));\n    mo.x += sin(time*0.3 + sin(time*0.05))*0.03+0.03;\n    mo.y += sin(time*0.4 + sin(time*0.06))*0.03;\n    mat2 mx = mm2(mo.x*6.);\n    mat2 my = mm2(mo.y*6.); \n    ro.xz *= mx;rd.xz *= mx;\n    ro.xy *= my;rd.xy *= my;\n    \n\tfloat rz = march(ro,rd); //march geometry\n    vec3 col = stars(rd);   \n    float maxT = rz;\n    if (rz > FAR)\n        maxT = 25.;\n    vec3 mv = marchVol(ro,rd, roz-1.5,maxT);\n    \n    if ( rz < FAR )\n    {\n        vec3 pos = ro+rz*rd;\n        vec3 nor= normal( pos );\n        float crv = clamp(curv(pos, 0.3)*0.35,0.,1.3);\n        \n        vec3 col2 = vec3(1,0.1,0.02)*(crv*0.8+0.2)*0.5;\n        float frict = dot(pos, normalize(vec3(0.,1.,0.)));\n        col = col2*(frict*0.3+0.7);\n        \n        col += vec3(1,0.3,0.1)*(crv*0.7+0.3)*max((frict*0.5+0.5),0.)*1.3;\n        col += vec3(.8,0.8,.5)*(crv*0.9+0.1)*pow(max(frict,0.), 1.5)*1.9;\n        pos = objmov(pos);\n        \n        col *= 1.2-mv;\n        col *= triNoise3d(pos*2.8,0.)*0.25+0.45;\n        col = pow(col, vec3(1.5,1.2,1.2))*.9;\n    }\n    col += mv;\n    col += marchVol2(ro,rd, roz-5.5,rz);\n\tcol = pow(col,vec3(1.4))*1.1;\n    \n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dGyRh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lstfDN", "name": "experiment - negative light", "author": "Azorlogh", "description": "click to place the negative and positive light sources", "tags": ["test"], "likes": 1, "viewed": 53, "date": "1588528684", "time_retrieved": "2024-06-20T20:06:56.403210", "image_code": "struct Ray {\n\tvec2 pos;\n\tvec2 dir;\n};\n\nstruct Sphere {\n\tvec2 pos;\n\tfloat rad;\n};\n\nbool hitSphere(Ray R, Sphere S, float m) {\n\tvec2 toSphere = S.pos-R.pos;\n\tfloat d = dot(toSphere, R.dir);\n\tif (d < 0. || length(toSphere) < S.rad) {\n\t\treturn false;\n\t}\n\tfloat dist = sqrt(length(toSphere)*length(toSphere) - d*d);\n\tif (dist < S.rad && d+sqrt(S.rad*S.rad-dist*dist)<m) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nvec2 uvToWorld(vec2 pos) {\n\tpos = ( pos - iResolution.xy/2. ) / (iResolution.y/2.);\n    return pos*0.8;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = uvToWorld(fragCoord);\n    \n    vec3 col;\n    \n    Sphere s = Sphere(vec2(.0), .2);\n\tSphere s2 = Sphere(vec2(.0,.5), .2);\n    \n    float time = iTime+1.0;\n\n    vec2 l;\n    vec2 d;\n    if (iMouse.xy == vec2(0)) {\n        l = vec2(1,0);\n    } else {\n        l = uvToWorld(iMouse.xy);\n    }\n    if (iMouse.z <= 0.0 || iMouse.w > 0.0) {\n        d = vec2(cos(time)+cos(time*1.618033),sin(time)+sin(time*1.618033));\n    } else {\n    \td = uvToWorld(abs(iMouse.zw));\n    }\n\n    Ray ray;\n    \n\tvec2 toLight = l-pos;\n\tray = Ray(pos, normalize(toLight));\n    if (!hitSphere(ray, s, length(toLight)) && !hitSphere(ray, s2, length(toLight))) {\n\t\tcol += vec3(0.2/pow(length(pos-l),0.4));\n    }\n    \n    vec2 toDark = d-pos;\n\tray = Ray(pos, normalize(toDark));\n    if (!hitSphere(ray, s, length(toDark)) && !hitSphere(ray, s2, length(toDark))) {\n\t\tcol -= vec3(0.2/pow(length(pos-d),0.4));\n    }\n\n    if (length(pos-s.pos) < s.rad) {\n\t\tcol *= vec3(1,0,0);\n\t}\n\tif (length(pos-s2.pos) < s2.rad) {\n\t\tcol *= vec3(1,0,0);\n\t}\n\t\n    \n    col = tanh(col)*.5+.5;\n\n\tfragColor = vec4(col, 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lstfDN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsVyzK", "name": "4d voxel raytracing", "author": "Azorlogh", "description": "experimental method of rendering a 4D voxel world by drawing opposing rotated slices as red and green", "tags": ["4d"], "likes": 4, "viewed": 137, "date": "1588529159", "time_retrieved": "2024-06-20T20:06:56.409365", "image_code": "precision highp float;\n\n\n// THIS IS NOT MY CODE\n//////////////////////////////////////////////////////////////\n//\tSimplex 4D Noise \n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nfloat permute(float x){return floor(mod(((x*34.0)+1.0)*x, 289.0));}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nfloat taylorInvSqrt(float r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec4 grad4(float j, vec4 ip){const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);vec4 p,s;p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;p.w = 1.5 - dot(abs(p.xyz), ones.xyz);s = vec4(lessThan(p, vec4(0.0)));p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;return p;}float snoise(vec4 v){const vec2  C = vec2( 0.138196601125010504,0.309016994374947451);vec4 i  = floor(v + dot(v, C.yyyy) );vec4 x0 = v -   i + dot(i, C.xxxx);vec4 i0;vec3 isX = step( x0.yzw, x0.xxx );vec3 isYZ = step( x0.zww, x0.yyz );i0.x = isX.x + isX.y + isX.z;i0.yzw = 1.0 - isX;i0.y += isYZ.x + isYZ.y;i0.zw += 1.0 - isYZ.xy;i0.z += isYZ.z;i0.w += 1.0 - isYZ.z;vec4 i3 = clamp( i0, 0.0, 1.0 );vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );vec4 x1 = x0 - i1 + 1.0 * C.xxxx;vec4 x2 = x0 - i2 + 2.0 * C.xxxx;vec4 x3 = x0 - i3 + 3.0 * C.xxxx;vec4 x4 = x0 - 1.0 + 4.0 * C.xxxx;i = mod(i, 289.0);float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);vec4 j1 = permute( permute( permute( permute (i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))+ i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))+ i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))+ i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;vec4 p0 = grad4(j0,   ip);vec4 p1 = grad4(j1.x, ip);vec4 p2 = grad4(j1.y, ip);vec4 p3 = grad4(j1.z, ip);vec4 p4 = grad4(j1.w, ip);vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));p0 *= norm.x;p1 *= norm.y;p2 *= norm.z;p3 *= norm.w;p4 *= taylorInvSqrt(dot(p4,p4));vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);m0 = m0 * m0;m1 = m1 * m1;return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))+ dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;}\n//\n//////////////////////////////////////////////////////////////\n\n#define normalize(a) normalize(a+1e-5) \n\nvec4 rotateXY(vec4 v, float a) {float c = cos(a), s = sin(a);return mat4(c, s, 0, 0,-s, c, 0, 0,0, 0, 1, 0,0, 0, 0, 1)*v;}\nvec4 rotateXZ(vec4 v, float a) {float c = cos(a), s = sin(a);return mat4(c, 0, s, 0,0, 1, 0, 0,-s, 0, c, 0,0, 0, 0, 1)*v;}\nvec4 rotateXW(vec4 v, float a) {float c = cos(a), s = sin(a);return mat4(c, 0, 0, s,0, 1, 0, 0,0, 0, 1, 0,-s, 0, 0, c)*v;}\nvec4 rotateYZ(vec4 v, float a) {float c = cos(a), s = sin(a);return mat4(1, 0, 0, 0,0, c, s, 0,0, -s, c, 0,0, 0, 0, 1)*v;}\nvec4 rotateYW(vec4 v, float a) {float c = cos(a), s = sin(a);return mat4(1, 0, 0, 0,0, c, 0, s,0, 0, 1, 0,0, -s, 0, c)*v;}\nvec4 rotateZW(vec4 v, float a) {float c = cos(a), s = sin(a);return mat4(1, 0, 0, 0,0, 1, 0, 0,0, 0, c, s,0, 0, -s, c)*v;}\n\n\nfloat sdTorus( vec4 p, vec2 t )\n{\n  vec3 q = vec3(length(p.xw)-t.x, p.y, p.z);\n  return length(q)-t.y;\n}\n\n\nfloat terrain(vec4 pos) {\n    return snoise(pos*2.);\n    //return .5-length(pos-.5);\n    //return -sdTorus(pos-.5, vec2(.4,.2));\n}\n\nfloat intersection(vec4 b0, vec4 b1, vec4 ro, vec4 rid) {\n    float tx1 = (b0.x - ro.x)*rid.x;\n    float tx2 = (b1.x - ro.x)*rid.x;\n    float tmin = min(tx1, tx2);\n    float tmax = max(tx1, tx2);\n    float ty1 = (b0.y - ro.y)*rid.y;\n    float ty2 = (b1.y - ro.y)*rid.y;\n    tmin = max(tmin, min(ty1, ty2));\n    tmax = min(tmax, max(ty1, ty2));\n    float tz1 = (b0.z - ro.z)*rid.z;\n    float tz2 = (b1.z - ro.z)*rid.z;\n    tmin = max(tmin, min(tz1, tz2));\n    tmax = min(tmax, max(tz1, tz2));\n    float tw1 = (b0.w - ro.w)*rid.w;\n    float tw2 = (b1.w - ro.w)*rid.w;\n    tmin = max(tmin, min(tw1, tw2));\n    tmax = min(tmax, max(tw1, tw2));\n    return (tmax >= tmin && tmin > 0.) ? tmin : -1.;\n}\n\nvec4 computeNormal(vec4 inter, vec4 center) {\n  vec4 a = inter - center;\n  a = abs(a);\n  return vec4(greaterThanEqual(a.xyzw, max(a.yzwx, max(a.zwxy, a.wxyz))));\n}\n\n#define GRID_SIZE 16.\n\nvec4 trace(vec4 ro, vec4 rd, inout float t) {\n    vec4 rid = 1./rd;\n    if (ro != clamp(ro, 0., 1.)) {\n        float tmin = intersection(vec4(0), vec4(1), ro, rid);\n        if (tmin == -1.) {return vec4(0.);}\n        ro = ro + rd*(tmin+1e-4);\n        t += tmin;\n    }\n    vec4 grid = floor( ro*GRID_SIZE );\n    vec4 grid_step = sign( rd );\n\tvec4 corner = max( grid_step, vec4(0) );\n\n    vec4 inv = vec4( 1.0 ) / rd;\n\tvec4 ratio = ( grid + corner - ro*GRID_SIZE ) * inv;\n\tvec4 ratio_step = grid_step * inv;\n\n    vec4 mask = computeNormal(ro, vec4(.5));\n\n    for (int i=0; i<32; i++) {\n        if (grid != clamp(grid, 0., GRID_SIZE-1.)) {return vec4(0.);}\n        if (terrain(vec4(grid)/GRID_SIZE) > 0.) {\n            t += dot( ratio - ratio_step, mask )/GRID_SIZE;\n            return mask*grid_step;\n        }\n        \n        mask = vec4(lessThanEqual(ratio.xyzw,min(ratio.yzwx, min(ratio.zwxy, ratio.wxyz))));\n\t\tgrid  += grid_step  * mask;\n\t\tratio += ratio_step * mask;\n    }\n    return vec4(0.);\n}\n\nvec4 sunDir = normalize(vec4(4,8,6,7));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 pos = (fragCoord - iResolution.xy/2.) / (iResolution.y/2.);\n\n   \tfloat time=3.8+cos(iTime)*.5;\n    \n    vec4 ro = vec4(cos(time)*1.5+.5,1.5,sin(time)*1.5+.5,cos(iTime)*.4+.5);\n    vec4 rd = normalize(vec4(pos, 1, 0));\n    rd = rotateYZ(rd, .3);\n    rd = rotateXZ(rd, time+3.14/2.);\n\n    vec3 col = vec3(0);\n    \n    for (int i=-1; i<=1; i++) {\n        float t;\n    \tvec4 normal = trace(ro+vec4(0,0,0,i)*.1, rd, t);\n    \tif (length(normal) != .0) {\n        \tfloat d = clamp(dot(normal, sunDir), 0., 1.);\n        \tcol += vec3(d) * (vec3(i>=0 ? 1./float(i*2+1) : 0., -i>=0 ? 1./float(-i*2+1) : 0., i==0 ? 1 : 0));\n    \t}\n    }\n    \n    fragColor = vec4(col, 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsVyzK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdcyWB", "name": "negative lights 2", "author": "Azorlogh", "description": "If negative light was a thing.\n\nA fixed light source and a rotating negative light source.", "tags": ["negativelights"], "likes": 1, "viewed": 38, "date": "1588528759", "time_retrieved": "2024-06-20T20:06:57.251906", "image_code": "const float PI = 3.14159265358979323846;\n\nvec3 rotateXY(vec3 v, float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat3(\n\t\tc, s, 0,\n\t\t-s, c, 0,\n\t\t0, 0, 1\n\t)*v;\n}\nvec3 rotateXZ(vec3 v, float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat3(\n\t\tc, 0, s,\n\t\t0, 1, 0,\n\t\t-s, 0, c\n\t)*v;\n}\nvec3 rotateYZ(vec3 v, float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat3(\n\t\t1, 0, 0,\n\t\t0, c, s,\n\t\t0, -s, c\n\t)*v;\n}\n\n// Operations\nfloat opU(float a, float b) { return min(a,b); }\nfloat opI(float a, float b) { return max(a,b); }\nfloat opD(float a, float b) { return max(a, -b); }\n\n// Transformations\nvec3 deform( vec3 p )\n{\n    p.xyz += .300*sin(  2.0*p.zxy );\n    p.xyz += 0.450*sin(  4.0*p.zxy );\n    p.xyz += 0.250*sin(  8.0*p.zxy );\n    return p;\n}\n\n// Distance functions\nfloat sphereSDF(vec3 p, float r) { return length(p)-r; }\nfloat boxSDF( vec3 p, vec3 b ) { vec3 d = abs(p) - b; return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0)); }\nfloat planeSDF( vec3 p, vec4 n ) { return dot(p,n.xyz) + n.w; }\nfloat torusSDF( vec3 p, vec2 t ) { vec2 q = vec2(length(p.xz)-t.x,p.y); return length(q)-t.y; }\n\n// Scene\nfloat sceneSDF(vec3 p) {\n    return opU(\n        torusSDF(p+vec3(-.5,-.8,-.5), vec2(1.,.5))*.1,\n        planeSDF(p, normalize(vec4(0,1,0,2)))\n    );\n}\n\n\n\n/////////////////////////////////////////////////\n\n// Marching\n\n#define EPSILON 1e-4\n#define MAX_STEPS 512\n#define tmin 0.\n#define tmax 1e2\n\nvec3 getNormal( in vec3 pos ) {\n    vec2 e = vec2(0.001, -0.001);\n    return normalize(\n        e.xyy * sceneSDF(pos + e.xyy) + \n        e.yyx * sceneSDF(pos + e.yyx) + \n        e.yxy * sceneSDF(pos + e.yxy) + \n        e.xxx * sceneSDF(pos + e.xxx));\n}\n\nfloat shadow(vec3 ro, vec3 rd, float lightDist) {\n    float t = EPSILON;\n    float penumbra = 1e8;\n    for (int i=0; i<MAX_STEPS; i++) {\n        float dist = sceneSDF(ro+rd*t);\n        if (dist < EPSILON) {\n            return 0.;\n        }\n        penumbra = min(penumbra, 64.*dist/t);\n        t += dist;\n        if (t > lightDist) {\n            return smoothstep(penumbra, 0., .1);\n        }\n    }\n    return 0.;\n}\n\nfloat march(vec3 ro, vec3 rd) {\n    float t = tmin;\n    for (int i=0; i<MAX_STEPS; i++) {\n        float dist = sceneSDF(ro+rd*t);\n        if (dist < EPSILON) {\n            return t;\n        }\n        if (dist > tmax) {\n            return -1.;\n        }\n        t += dist;\n    }\n    return -1.;\n}\n\nfloat marchSphere(vec3 ro, vec3 rd, vec3 pos, float rad) {\n    float t = tmin;\n    for (int i=0; i<MAX_STEPS; i++) {\n        float dist = length(ro+rd*t + pos)-rad;\n        if (dist < EPSILON) {\n            return t;\n        }\n        if (dist > tmax) {\n            return -1.;\n        }\n        t += dist;\n    }\n    return -1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime*.3;\n    \n    vec3 lightDir = normalize(vec3(1,1,1));\n\tvec3 darkDir  = normalize(vec3(cos(time),1./sqrt(3.),sin(time)));\n    \n    vec2 pos = (fragCoord - iResolution.xy/2.) / (iResolution.y/2.);\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    vec3 ro = vec3(0.,1,6.);\n    vec3 rd = normalize(vec3(pos, -1));\n    \n    \n    vec3 col;\n    \n    float tl = marchSphere(ro, rd, vec3(1,1,1)*-10., .2);\n    float td = marchSphere(ro, rd, vec3(cos(time),1,sin(time))*-10., .2);\n                           \n    if (tl != -1.) {fragColor = vec4(1,1,1,1); return;}\n    if (td != -1.) {fragColor = vec4(0,0,0,1); return;}\n    \n    float t = march(ro, rd);\n    if (t != -1.) {\n        vec3 p = ro+rd*t;\n        vec3 n = getNormal(p);\n        \n        vec3 sro = p+lightDir*10.;\n        vec3 srd = -normalize(lightDir);\n        float penumbra = shadow(sro, srd, 8.);\n        \n        float diff = max(dot(n, lightDir), 0.);\n        col += vec3(diff*penumbra);\n        \n        sro = p+darkDir*10.;\n        srd = -normalize(darkDir);\n        penumbra = shadow(sro, srd, 8.);\n        \n        diff = max(dot(n, darkDir), 0.);\n        col -= vec3(diff*penumbra);\n    }\n    \n    col = tanh(col)*.5+.5;\n\n    fragColor = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdcyWB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MddXzN", "name": "Math fun.", "author": "WojtaZam", "description": "Animation based on tan function.", "tags": ["2d", "math"], "likes": 6, "viewed": 253, "date": "1589658340", "time_retrieved": "2024-06-20T20:06:57.251906", "image_code": "#define st( fun ) smoothstep( 0.99, 1.0, fun )\n\nconst vec4 red = vec4( 1.0, 0.0, 0.0, 1.0 );\nconst vec4 blue = vec4( 0.0, 0.0, 1.0, 1.0 );\n\n#define fun(x) tan(100.0*x)/20.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord / iResolution.xy;\n    p = 2.0 * p - 1.0;\n    p *=  vec2( iResolution.x / iResolution.y, 1.0 );\n    \n\tvec4 color = vec4( 1.0 );\n    float timeFactor = sin( iTime );\n    vec2 p2 = vec2( fun(p.x), fun(p.y) );\n    float f = st( length( p ) + length(p2) * timeFactor );\n\tcolor = mix( red, color, f );\n    \n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MddXzN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtKcD1", "name": "Cyan plasma", "author": "Alexwing", "description": "A Cyan plasma for web backgroud", "tags": ["plama"], "likes": 1, "viewed": 69, "date": "1588858284", "time_retrieved": "2024-06-20T20:06:57.251906", "image_code": "// digital's first plasma!\n\nvec3 palette(float pos, float time)\n{\n\treturn vec3(cos(6.2*pos),cos(6.2*pos),cos(6.2*pos));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime/2.0;\n\n\tvec2 p = fragCoord.xy / iResolution.xy;\n\t// translate\n\tp.y += 0.0;\n\t// zoom to a good looking spot\n\tp *= 0.25;\n\t\n\t// start the plasma magic!\n\tfloat part1 = sin(p.x*(90.0+21.0*cos(p.y*0.0))+time);\n\tfloat part2 = cos(p.y*(32.0+11.0*sin(p.x*57.0))+time);\n\tfloat part3 = sin(p.x*(55.0 + 21.0*sin(p.y*32.0))+ time);\n\tfloat plas = 0.5 + 0.65*part1*part2 + 1.35*part3*part2;\n\t\n\tfragColor = vec4(palette(plas, time),1.0);\n    \n    fragColor = vec4(fragColor.x +1.9,fragColor.y +3.0,fragColor.z +3.0,1.0);\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtKcD1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "td2BR3", "name": "Day 159 [twitch]", "author": "jeyko", "description": "coded on evvvvil's stream", "tags": ["mdtmjvm"], "likes": 6, "viewed": 232, "date": "1590537246", "time_retrieved": "2024-06-20T20:06:57.258002", "image_code": "vec3 glow = vec3(0);\n\nvec3 glowb = vec3(0);\n\nvec3 att = vec3(1);\n\nfloat sdBox(vec3 p, vec3 s){\n  p = abs(p) - s;\n  return max(p.y,max(p.z,p.x));\n\n}\n\n#define dmin(a,b) a.x < b.x ? a :b\n  \n#define T iTime\n  \n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\n\nvec2 map(vec3 p){\n  vec2 d = vec2(10e6);\n  \n  vec4 q = vec4(p,1);\n  \n  \n  float dpp = dot(q.xyz,q.xyz);\n  q /= dpp;  \n  \n  q.xy += sin(T)/5.;\n  \n  \n  for(int i = 0; i <13; i++){\n    float dpp = dot(q.xyz,q.xyz);\n    q = abs(q)/dpp - vec4(0.22,0.2,0.1,0);\n    \n    q.xy *= rot(0.4+sin(T)/2000.);    \n    \n  }\n  float b = sdBox(q.xyz,vec3(1.4,3.4,1.1)*q.w/4.);\n  float bb = sdBox(q.xyz-vec3(-.2,0.,0.5),vec3(1.9,3.4,1.1)*q.w/2.);\n  \n  float bc = sdBox(q.xyz-vec3(0.04,0.2,0.5),vec3(1.9,1.4,3.1));\n  \n  \n  //glowb += exp(-abs(bc)*20.);\n  \n  \n  d = dmin(d, vec2(b, 2.));\n  d = dmin(d, vec2(bb, 1.));\n  \n  glow += 0.02/(0.2+d.x*d.x*4.);\n  \n  d.x *= 0.2/q.w;\n  \n  return d;\n}\n\nvec3 getNormal(vec3 p){\n  vec2 t = vec2(0.001,0.);\n  return normalize(map(p).x - vec3(\n    map(p-t.xyy).x,\n    map(p-t.yxy).x,\n    map(p-t.yyx).x\n  ));\n}\n\n#define pal(a,b,c,d,e) (a + b*sin(c*d + e))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  vec3 col = vec3(0);\n  \n  vec3 ro = vec3(0,1.5,4.)*4.;\n  \n  vec3 lookAt = vec3(0);\n  \n  vec3 dir = normalize(lookAt - ro);\n  vec3 right = normalize(cross(vec3(0,1,0),dir));\n  vec3 up= normalize(cross(dir, right));\n  \n  vec3 rd = normalize(dir + right*uv.x+ up*uv.y);\n  \n  \n  \n  \n  vec3 p = ro; float t =0.; bool hit = false;\n  vec2 d;\n  for(int j = 0; j <1;j ++){\n  \n    for(int i = 0; i <290;i ++){\n      d = map(p);\n      if(d.x < 0.001){\n        hit = true;\n        break;\n      }\n      t += d.x;\n      p += rd*d.x;\n    }\n  }\n  \n   \n    #define AO(j) smoothstep(0.,1.,map(p+n*j).x/j)\n  vec3 l = normalize(vec3(1,-1,1));\n  if(hit ){\n    vec3 n = getNormal(p);\n    float fres = pow(1.- max(dot(n,-rd),0.),5.);\n    float antifres = smoothstep(0.,1.,(1.-fres)*0.4);\n    float diff = max(dot(n,l),0.);\n    if(d.y == 1.){\n      col +=  AO(0.3)*AO(0.04)*antifres*306.* ( 0.4*(diff+0.4)*fres)*glow*pal(0.5,0.5,vec3(1,0.2,0.1),1., length(p) + T);\n    }\n    if(d.y == 2.){\n      col += 0.1*diff*glow*pal(0.5,0.5,vec3(1,0.2,0.1),1., length(p) + T+4.);\n    }\n  \n  } else {\n  \t//col += glow*1000.2001;\n    col += 0.2*pal(0.5,0.5,vec3(1.,0.4,0.1),1.,length(uv)+T);\n    //col += glow*0.004*att;\n  }\n    //col += glow;\n  \n  col *= 1. - dot(uv,uv)*0.7;\n  //col += glowb;\n  \n  col = max(col,0.);\n  col = pow(col,vec3(0.45454));\n  fragColor = vec4(col,1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/td2BR3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "td2BRR", "name": "Value Noise Example", "author": "peterekepeter", "description": "Useful primitive for texturing.", "tags": ["noise2d"], "likes": 2, "viewed": 228, "date": "1589396395", "time_retrieved": "2024-06-20T20:06:57.839889", "image_code": "// Defines\n\n#define COLOR_SKY vec3(.1,.2,.6)\n#define COLOR_CLOUDS vec3(.98,.96,.92)\n#define COLOR_DARK_SOMETHING vec3(.1,.01,.1)\n#define SCREEN_GAMMA 2.2\n\n// Function prototypes\n\nfloat hash(float value); // Produces random values\nfloat hash(vec2 value); // Produces random values\nfloat noise(vec2 position); // A single layer of noise\nfloat value_noise(vec2 position, int octaves); // Multiple layers of noise\nmat2 rotate2D(float a); // Returns 2D rotation matrix\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates\n    vec2 uv = fragCoord/iResolution.yy;\n    vec2 position = uv;\n    \n\t// Rotate and translate the camera using some random sine waves\n\tposition*=rotate2D(iTime*.1)*pow(2.0,sin(iTime*.1));\n\tposition = position*7.0+sin(vec2(iTime, iTime+2.0));\n    \n    // Add some distorsion, often used for chaging the texture\n\tfloat distort_amount = sin(iTime*.3)*.5+.5; // set to 0 to disable distorsion\n    position = position + distort_amount*vec2(\n        2.0*value_noise(position*.23+iTime*.1, 8),\n        4.0*value_noise(position*.14-iTime*.1, 8));\n    \n    // This is where the texture is sampled.\n\tfloat noise_value = value_noise(position, 16);\n\tnoise_value=mix(noise_value, value_noise(position*.2+4.0, 16),.5);\n\n    // Apply gradient 1 which makes it look like clouds\n    vec3 col = mix(COLOR_CLOUDS, COLOR_SKY, smoothstep(.2,.7,noise_value));\n\n    // Apply another gradient\n    vec3 col2 = mix(COLOR_CLOUDS, COLOR_DARK_SOMETHING, pow(abs(noise_value-(sin(iTime*2.0)*.1+.5))*2.0,.2));\n    \n    // Mix between the two gradients\n\tcol=mix(col,col2, smoothstep(-.2,.2, sin(iTime+uv.x*.2))); // cooment out for clouds only\n    \n    // Gamma correction\n\tcol=pow(col, vec3(1.0/SCREEN_GAMMA));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\nmat2 rotate2D(float a){\n\tfloat c=cos(a), s=sin(a);\n\treturn mat2(c,s,-s,c);\n}\n\n// https://en.wikipedia.org/wiki/Value_noise\nfloat value_noise(vec2 position, int octaves){\n\tfloat value = 0.0;\n    // Sum together various layers of noise\n\tfor (int i=1; i<octaves; i++)\n\t{\n\t\tfloat scale = pow(2.0,float(i)); // At different scales\n\t\tfloat contrib = 1.0/scale; // Weighted accordint to scale\n\t\tvalue += noise(position*scale)*contrib;\n\t}\n\treturn value;\n}\n\nfloat noise(vec2 position){\n    // Fractional part is used for interpolation\n\tvec2 fractional_part = fract(position);\n    // Integral part is used for sampling the hash function\n\tvec2 integral_part = position-fractional_part;\n    \n    // Generate 4 sample points\n\tfloat sample_00=hash(integral_part);\n\tfloat sample_10=hash(integral_part+vec2(1,0));\n\tfloat sample_11=hash(integral_part+vec2(1,1));\n\tfloat sample_01=hash(integral_part+vec2(0,1));\n    \n    // Interpolate them so we have nice and stable continuous texture\n\treturn mix(\n\t\tmix(sample_00, sample_10, fractional_part.x),\n\t\tmix(sample_01, sample_11, fractional_part.x),\n\t\tfractional_part.y\n\t);\n}\n\nfloat hash(vec2 v) \n{ \n    // Random numbers thrown together to produce other random numbers\n    return fract(hash(v.x*.97+v.y*.98)*143.94213); \n}\n\nfloat hash(float v) \n{ \n    // Even more pseudo randomness\n    return fract(fract(v*11.3334)*fract(v*91.73362341)*43.123*429.32234643);  \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/td2BRR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "td2BWG", "name": "Coffee chat", "author": "dean_the_coder", "description": "Webcam projected onto a coffee cup.\nPerfect for those virtual 'Covid' coffee chats (with MemixApp, or similar).", "tags": ["procedural", "3d", "raymarching", "webcam", "covid"], "likes": 9, "viewed": 212, "date": "1590840754", "time_retrieved": "2024-06-20T20:06:57.839889", "image_code": "// Set to zero for a better frame rate.\n#define REFLECTIONS 1\n\nfloat hash(vec2 p) {\n    return fract(sin(dot(p, vec2(123.45, 875.43))) * 5432.3);\n}\n\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n    f = f * f * (3.0 - 2.0 * f); // smoothstep with no clamp.\n    \n    return mix(a, b, f.x) +\n            (c - a) * f.y * (1.0 - f.x) +\n            (d - b) * f.x * f.y;\n}\n\nfloat fbm(vec2 p) {\n\tfloat f = 0.0;\n    f += 0.5 * noise(p * 1.1);\n    f += 0.22 * noise(p * 2.3);\n    f += 0.155 * noise(p * 3.9);\n    f += 0.0625 * noise(p * 8.4);\n    f += 0.03125 * noise(p * 15.0);\n    \n    return f;\n}\n\nvec3 vignette(vec3 col, vec2 fragCoord) {\n    vec2 q = fragCoord.xy / iResolution.xy;\n    col *= 0.5 + 0.5 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.4);\n    return col;\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCylinder(vec3 p, vec2 rh) {\n    return max(length(p.xz) - rh.x, abs(p.y) - rh.y);\n}\n\nvec3 opElongate(vec3 p, vec3 h) {\n    return p - clamp( p, -h, h );\n}\n\nfloat sdCup(vec3 p) {\n    float d = sdTorus(opElongate(p, vec3(0.0, 1.0, 0.0)), vec2(1.0, 0.05));\n    \n    vec3 pp = p;\n    pp.y += 0.4;\n    pp.y -= pp.x * 0.5;\n    pp.xy -= vec2(1.0, 0.0);\n    pp.zy *= rot(3.14159 * 0.5);\n    return smin(d, sdTorus(pp, vec2(0.6, mix(0.08, 0.06, p.y))), 0.15);\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    return normalize(forward + right * uv.x + up * uv.y);\n}\n\nvec2 dmin(vec2 d1, vec2 d2) {\n    return d1.x < d2.x ? d1 : d2;\n}\n\nvec2 map(vec3 p) {\n    vec2 d1 = vec2(sdCup(p), 1.5);\n    \n    vec3 pp = p;\n    pp.xy *= rot(sin(iTime) * 0.05);\n    pp.y -= sin(length(pp.xz) * 10.0 + iTime) * 0.02;\n    vec2 d2 = vec2(sdCylinder(pp, vec2(1.0, 0.85)), 2.5); // Coffee\n    vec2 d3 = vec2(abs(p.y + 1.1), 3.5); // Table\n    \n    return dmin(d1, dmin(d2, d3));\n}\n\nvec3 calcNormal(in vec3 p) {\n    // Thanks iq!\n    vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;\n    return normalize(e.xyy * map(p + e.xyy).x + \n\t\t\t\t\t e.yyx * map(p + e.yyx).x + \n\t\t\t\t\t e.yxy * map(p + e.yxy).x + \n\t\t\t\t\t e.xxx * map(p + e.xxx).x);\n}\n\nfloat calcShadow(vec3 p, vec3 lightPos, float sharpness) {\n    vec3 rd = normalize(lightPos - p);\n    \n    float h;\n    float minH = 1.0 / sharpness;\n    for (float d = 0.1; d < 32.0; d += h) {\n        h = max(0.0, map(p + rd * d).x);\n        minH = min(minH, h / d);\n        if (minH < 0.01)\n            break;\n    }\n    \n    return minH * sharpness;\n}\n\nfloat calcOcc(vec3 p, vec3 n, float strength) {\n    const float dist = 0.3;\n    return 1.0 - (dist - map(p + n * dist).x) * strength;\n}\n\nint march(vec3 ro, vec3 rd, out vec3 p) {\n    float d = 0.01;\n    for (float steps = 0.0; steps < 128.0; steps++) {\n        p = ro + rd * d;\n        vec2 h = map(p);\n        if (h.x < 0.001 * d) {\n            return int(h.y);\n        }\n\n        d += h.x;\n    }\n    \n    return 0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    // Raymarch.\n    float camTime = clamp(iTime - 4.0, 0.0, 4.0) / 4.0;\n    vec2 cyz = mix(vec2(2.0, -2.0), vec2(0.6, -1.2), smoothstep(0.0, 1.0, camTime));\n    vec3 ro = 2.5 * vec3(0.2, cyz);\n    ro.xy += clamp(iTime - 8.0, 0.0, 1.0) * vec2(sin(iTime - 8.0) * 0.05, 0.0);\n    vec3 rd = getRayDir(ro, vec3(0.0), uv);\n\n    vec3 rgb;\n    vec3 p;\n    float ref = 1.0;\n    for (int i = 0; i <= REFLECTIONS; i++) {\n        int hit = march(ro, rd, p);\n\n        if (hit > 0) {\n            vec3 n = calcNormal(p);\n            vec3 lightPos = vec3(20.0, 15.0, -15.0);\n            vec3 lightCol = vec3(1.0, 0.9, 0.8);\n            vec3 lightToPoint = normalize(lightPos - p);\n            vec3 skyCol = vec3(0.15, 0.2, 0.25);\n            float sha = calcShadow(p, lightPos, 5.0);\n            float occ = calcOcc(p, n, 4.0);\n            float spe = pow(max(0.0, dot(rd, reflect(lightToPoint, n))), 15.0);\n            vec3 mainLight = clamp(dot(n, lightToPoint), 0.01, 1.0) * lightCol;\n            vec3 backLight = clamp(dot(n, -rd), 0.01, 1.0) * 0.1 * lightCol;\n            vec3 skyLight = clamp(dot(n, vec3(0.0, 1.0, 0.0)), 0.01, 1.0) * 0.4 * skyCol;\n            float d = length(p - ro);\n            float fog = 1.0 - exp(-max(0.0, d - 8.0) * 0.06);\n            float shiny;\n\n            vec3 mat;\n            if (hit == 1) {\n                // Cup.\n                vec2 wuv = p.xy * 0.7;\n                wuv.x *= iResolution.y / iResolution.x;\n                wuv.xy += vec2(0.45, 0.4);\n                if (abs(wuv.x - 0.5) > 0.35 || abs(wuv.y - 0.5) > 0.5 || p.z > 0.0)\n                    mat = vec3(0.5, 0.51, 0.49);\n                else\n                    mat = texture(iChannel0, wuv).rgb;\n                shiny = 0.3;\n            } else if (hit == 2) {\n                // Coffee.\n                mat = vec3(0.43, 0.3, 0.22);\n                shiny = 0.2;\n            } else if (hit == 3) {\n                // Table.\n                mat = vec3(0.6, 0.3, 0.18);\n                vec3 pp = p;\n                pp.x -= 5.6;\n                pp.xz *= rot(2.2);\n                mat *= 0.4 + 0.6 * abs(sin((3.0 + pp.x) * 0.8 * (5.0 + fbm(pp.xz * 0.8))));\n                shiny = 0.1;\n            }\n\n            vec3 col = mainLight * lightCol * sha;\n            col += backLight * occ;\n            col += skyLight * occ;\n            col += spe * lightCol * occ;\n            col *= mat;\n\t\t\tcol = mix(col, skyCol, fog);\n            \n            rgb += col * ref;\n\n\n            rd = reflect(rd, n);\n            ref *= shiny;\n            ro = p;\n        } else {\n            // Sky.\n            rgb += vec3(0.15, 0.2, 0.25) * ref;\n            break;\n        }\n    }\n\n    // Output to screen\n    rgb = pow(rgb, vec3(0.4545));\n    fragColor = vec4(vignette(rgb, fragCoord), 1.0);\n}", "image_inputs": [{"id": "4sf3zn", "previewfilepath": "/presets/webcam.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/webcam.png", "ctype": "webcam"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/td2BWG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "td2BWm", "name": "Menger squares - sorry bout that", "author": "alvarobyrne", "description": "Eazy peazy. spam", "tags": ["fractal", "menger", "sponge"], "likes": 1, "viewed": 222, "date": "1590202696", "time_retrieved": "2024-06-20T20:06:57.839889", "image_code": "// Fork of \"Menger squares\" by kindpotato. https://shadertoy.com/view/ttsGW8\n// 2020-05-23 02:56:09\n\n#define third 0.3333\n\nbool coloured(vec2 uv){\n    \n    return uv.x < third || uv.x > 2.*third || uv.y < third || uv.y > 2.*third;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.x;\n    float zoom = mod(-30.*iTime,109.);\n    uv*= pow(0.99,zoom);\n    fragColor = vec4(1);\n    float its = log(iResolution.y)/log(3.+0.5*sin(iTime));\n\n    for(float i = 0.; i < its; i+=1.){\n        if (coloured(uv)){\n            uv = fract((3.+0.1*tan(iTime/181.))*uv);\n        }\n        else{\n        \tfragColor = vec4(0,0,0,1);\n            return;\n        }\n    } \n\n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/td2BWm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "td2fDm", "name": "Dragon_Scale", "author": "TAKUSAKU", "description": "Dragon Scale", "tags": ["dragon", "scale", "shine"], "likes": 6, "viewed": 110, "date": "1590224644", "time_retrieved": "2024-06-20T20:06:57.839889", "image_code": "float random (in vec2 _st) {\n    return fract(sin(dot(_st.xy, vec2(0.890,-0.900)))*757.153);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3. - 2. * f);\n\n    return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat fbm ( in vec2 _st) {\n    float v = sin(iTime*0.3)*0.2;\n    float a = 0.9;\n    vec2 shift = vec2(100.);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(1.0), -sin(0.5), acos(0.5));\n    for (int i = 0; i < 3; ++i) {\n        v += a * noise(_st);\n        _st = rot * _st * 2. + shift;\n        a *= 0.1;\n    }\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = (2.*fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y) * 1.7;\n    \n    vec2 co = st;\n    co.x += 0.2*iTime;\n    co.y += 0.2*iTime;\n    \n    float len;  \n    for (int i = 0; i < 3; i++) {\n        len = length(co); \n        co.x +=  sin(co.y + iTime * 0.620)*0.1;\n        co.y +=  cos(co.x + iTime * 0.164)*0.1;\n    }   \n    len -= 3.;\n     \n    vec3 col = vec3(0.);\n\n    vec2 q = vec2(0.);\n    q.x = fbm( st + 1.0);\n    q.y = fbm( st + vec2(-0.450,0.650));\n\n    vec2 r = vec2(0.);\n    r.x = fbm( st + q + vec2(0.570,0.520)+ 0.5*iTime );\n    r.y = fbm( st + q + vec2(0.340,-0.570)+ 0.4*iTime);\n    \n    for (float i = 0.; i < 3.; i++) {\n        r += 1. / abs(mod(st.y, 0.512* i) * 30.) * 1.;//Virtical line\n        r += 1. / abs(mod(st.y - st.x, 0.524 * i) * 10.) * 1.;//Diagonal line\n    }\n    float f = fbm(st+r);\n    \n    col = mix(col, cos(len + vec3(0.2, 0.0, -0.5)), 1.0);   \n    col = mix(vec3(0.730,0.386,0.372), vec3(0.397,0.576,0.667), col);\n    \n    fragColor = vec4(2.0*(f*f*f+.6*f*f+.5*f)*col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/td2fDm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "td2fRD", "name": "Corroding Arbitrary SDF", "author": "blackle", "description": "a technique to add pitting to an SDF in a controlled way. cycles between three different \"modes\". see [url]https://www.shadertoy.com/view/WsBBRw[/url] for the 2d case", "tags": ["sdf"], "likes": 28, "viewed": 630, "date": "1589658757", "time_retrieved": "2024-06-20T20:06:58.597423", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//this shader is an experiment with mapping a 4 dimensional SDF onto a 3 dimensional one, by\n//using the components of 3d space plus the distance to a given SDF. this can be used to\n//map domain-repeated spheres onto the surface of an SDF, and use those spheres to cut holes\n//into it, much like pitted metal. Becase these spheres are restrained to the surface of the\n//SDF, we can control exactly what part of the SDF gets pitted. This shader cycles through 3\n//possibilities. pitting everything, only pitting inside existing pits, or only pitting\n//outside existing pits. There is no visible domain repetition pattern because I am also using\n//a modified version of domain repetition where some of the domains are \"disabled\" such that\n//they report the distance as if the neighbour domains are filled, but it is empty. this means\n//you can make an arbitrary percentage of domains empty, and therefore no holes will appear\n\n//see https://www.shadertoy.com/view/WsBBRw for the 2d case\n\n//return the SDF for a sphere, or the SDF for an empty region surrounded by spheres\nfloat gated_domain(vec4 p, float scale, bool gated) {\n    if (!gated) {\n        p.yzw = abs(p.yzw);\n        if (p.y > p.z) p.yz = p.zy;\n        if (p.z > p.w) p.zw = p.wz;\n        if (p.y > p.z) p.yz = p.zy;\n        p.w -= scale;\n    }\n    return length(p)-scale/2.2;\n}\n\n#define FK(k) floatBitsToInt(k)^floatBitsToInt(cos(k))\nfloat hash(float a, float b) {\n    int x = FK(a); int y = FK(b);\n    return float((x*x-y)*(y*y+x)+x)/2.14e9;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax,p)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = max(0., k-abs(a-b))/k;\n    return min(a,b)-h*h*h*k/6.;\n}\n\nint pittingtype;\nfloat scene(vec3 p) {\n    float sphere = length(p)-1.;\n    float cut = p.z;\n    \n    float top = sphere;\n    float last = sphere;\n    for (int i = 0; i < 5; i++) { //5 octaves of noise\n        //random rotations\n        p = erot(p, normalize(vec3(1,2,3)), .2);\n        p = erot(p, normalize(vec3(1,3,2)), .51);\n\n    \tfloat scale = .5/pow(float(i+1),1.5);\n\n        //create 4d coordinates where the first coordinate is the distance to the SDF\n    \tvec4 p4d = vec4(last,p);\n\n        //domain repetition *only* along the yzw axes\n    \tvec3 id = floor(p4d.yzw/scale);\n    \tp4d.yzw = (fract(p4d.yzw/scale)-0.5)*scale;\n\n        //disable 50% of spheres. see https://www.shadertoy.com/view/WsSBRD for another example of this technique\n    \tbool gated = hash(id.x, hash(id.y, id.z)) > 0.;\n        float holes = gated_domain(p4d, scale, gated);\n        top = -smin(-top, holes, 0.04*sqrt(scale));\n\n        if (pittingtype == 0) last = holes; //add pitting to existing pits\n        if (pittingtype == 1) last = top; //add pitting everywhere\n        if (pittingtype == 2) last = sphere; //add pitting only to original surface\n    }\n    \n    return max(top,-cut);\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(scene(p)-vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n    \n    pittingtype = int(iTime)%3;\n\n    vec3 cam = normalize(vec3(2,uv));\n    vec3 init = vec3(-5,0,0);\n\n   \tfloat yrot = 0.5;\n    float zrot = 4.5;\n    if (iMouse.z > 0.) {\n        yrot += -4.*mouse.y;\n        zrot += 4.*mouse.x;\n    } else {\n        yrot += cos(iTime)*.2;\n        zrot += sin(iTime)*.2;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    init = erot(init, vec3(0,0,1), zrot);\n    \n    vec3 p = init; \n    bool hit = false;\n    //raymarch\n    for (int i = 0; i < 100 && !hit; i++) {\n        float dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p+=cam*dist*.9;\n        if (distance(p,init) > 10.) break;\n    }\n    //shading\n    vec3 n = norm(p);\n    vec3 r = reflect(cam, n);\n    float ao = smoothstep(-.1,.1,scene(p+n*.1));\n    ao *= smoothstep(-.2,.2,scene(p+n*.2));\n    ao*=ao;\n    float diff = length(sin(n*2.)*.5+.5)/sqrt(3.);\n    float spec = length(sin(r*2.)*.5+.5)/sqrt(3.);\n    float fresnel = 1.-abs(dot(cam,n))*.98;\n    vec3 col = abs(erot(vec3(0.1,0.04,0.03),r,0.05))*diff*diff*ao + pow(spec, 10.)*fresnel*ao;\n    fragColor.xyz = sqrt((hit ? col : vec3(0.))*2.) + abs(hash(iTime, hash(uv.x,uv.y)))*.04;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc0-1.0", "thumbnail": "https://www.shadertoy.com/media/shaders/td2fRD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "td2fRt", "name": "Twisted sand", "author": "tono", "description": "sand", "tags": ["raymarching", "sand"], "likes": 3, "viewed": 62, "date": "1590635523", "time_retrieved": "2024-06-20T20:06:58.597423", "image_code": "#define M(x,y) mod(x,y) - y/2.\n#define saturate(x) clamp(x,0.,1.)\n#define hclamp(x) clamp(x,-0.5,0.5)\n\nmat2 rot(float a)\n{\n    float s = sin(a),c = cos(a);\n    return mat2(c,s,-s,c);\n}\n\n//https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdSphere(vec3 p,float size)\n{\n    return length(p) - size;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCone( vec3 p, vec2 c )\n{\n  // c is the sin/cos of the angle\n  float q = length(p.xy);\n  return dot(c,vec2(q,p.z));\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n//----------------------------------------------\n\n//http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nfloat random2(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n//-------------------------------------------------------------\n\n\nfloat Noise(vec2 st) \n{\n    vec2 p = floor(st);\n    vec2 f = fract(st);\n    vec2 u = f*f*(3.0-2.0*f);\n\n    float v00 = random2(p+vec2(0.,0.));\n    float v10 = random2(p+vec2(1.,0.));\n    float v01 = random2(p+vec2(0.,1.));\n    float v11 = random2(p+vec2(1.,1.));\n\n    return mix( mix( dot( vec2(v00), f - vec2(0.,0.) ), dot( vec2(v10), f - vec2(1.,0.) ), u.x ),\n                 mix( dot( vec2(v01), f - vec2(0.,1.) ), dot( vec2(v11), f - vec2(1.,1.) ), u.x ), \n                 u.y)+0.5;\n}\n\nfloat fbm (vec2 st) \n{\n    float f = 0.;\n    vec2 q = st;\n    for(int i = 1 ;i < 4;i++){\n        f += Noise(q)/pow(2.,float(i) );\n        q = q * (2.00+float(i)/100.);\n    }\n\n    return f;\n}\n\nfloat meltIce(vec3 p ,float tdist, float size)\n{\n    vec3 sp = p;\n    float s = sdEllipsoid(sp,vec3(0.5,0.2,0.5) * size);\n    \n    vec3 b=p + vec3(0.,tdist,0.) ; \n    b.xz *= rot(p.y * 20. + iTime * 2.4 );\n    b.yx *= rot(p.x * 15. );\n    b.zy *= rot(p.z * 10.);\n    \n    float box = sdBox(b ,vec3(0.1)*size);\n    s = smin(box,s,1.5);\n    return s;\n}\n\nfloat map(vec3 p)\n{\n    p.y -= 1.;\n    vec4 n = vec4(0.0, 1.0, 0.0, 0.9);\n    vec3 pp = p;\n    pp.y += fbm(pp.xz*2. +vec2(2.,-1.1)*iTime);\n    float plane = sdPlane(pp,n);\n    \n    vec3 mIp = p - vec3(0.,0.5,0.);\n    \n    vec2 areaID = floor(mIp.xz/5.);\n    mIp.xz = mod(mIp.xz,5.) - 0.5 * 5.;\n    float mI = meltIce(mIp + vec3(0.,0.5,0.) , 0.8,1.0);\n    vec3 ppp = p;\n    vec2 pillerSize = vec2(.8,0.2);\n    pillerSize.x -=saturate( sin(iTime) )/2.;\n    ppp.xz = mod(ppp.xz,5.)-5./2.;\n    ppp.yz *= rot(acos(-1.)/2.);\n    float piller = sdCone(ppp,pillerSize);\n    float hashid = random2(areaID);\n    for(int i = 1 ; i<7 ; i+=2)\n    {\n        mIp += vec3(2.,0.,2.) * (random2(vec2(float(i)) ) - 0.5) ;\n        \n        float h =  saturate(sin(iTime/float(i) + float(i)*8. + 6.*hashid ) + 0.5);\n        h = h * h * h + sin(iTime*2.+hashid*11.)/10.;\n        mIp.y += h;\n        mIp.xz *= rot(0.1 + float(i)* 3.);\n        mI = smin(mI,meltIce(mIp,0.8,0.4 + float(i)/15.),0.3);\n    }\n   // mI = smin(mI,piller,0.9);\n    return smin(mI,plane,0.9) + 0.09;\n}\n\nvec2 castRay(vec3 ro,vec3 rd)\n{\n    float c = 0.;\n    float cyc = 0.;\n    for(int i = 0; i < 100; i ++)\n    {\n        vec3 rp = ro + c * rd;\n        float d = map(rp);\n        float dist = length(ro - rp);\n        if(d < 0.00001){\n            break;\n        }\n        c += d;\n        cyc += 1.;\n    }\n    if(c > 20.){c = -1.;}\n\treturn vec2(c,cyc);\n}\n\nvec3 calcNormal(vec3 p)\n{\n    vec2 e=vec2(.001,.0);\n    return normalize(.000001+map(p)-vec3(map(p-e.xyy),map(p-e.yxy),map(p-e.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (fragCoord.xy * 2.0 -iResolution.xy) / min(iResolution.x, iResolution.y);\n    p.y = -p. y;\n\tvec3 co = vec3(-0.8,0.,-12.);\n    co.z *= hclamp(sin(iTime/16.))*2.;\n    co.y += hclamp( cos(iTime/4.) )*hclamp( cos(iTime/4.) )*.5;\n    \n    co.xz *= rot(iTime/35.);\n    vec3 target = vec3(0.,8.5,0.);\n    target.y += 34.*(hclamp(sin(iTime/6.)));\n    vec3 cd = normalize(target - co);\n    vec3 cu = vec3(0.,1.,0.);\n    vec3 cs = normalize(cross(cu , cd));\n    cu = normalize(vec3(cross(cs,cd)));\n    \n    float fov = (1. - dot(p,vec2(1.3,1.9)*p))/2.;\n    \n    vec3 rd = normalize(vec3(p.x * cs + p.y * cu + fov * cd));\n    \n    vec3 skycolor = vec3(0.6,0.3,0.4);\n    vec3 color = skycolor;\n    vec2 cr = castRay(co,rd) ;\n    \n    float crp = cr.y/90.;\n    \n    //http://sayachang-bot.hateblo.jp/entry/2019/11/30/205926\n    if(cr.x > 0.)\n    {\n    \tvec3 N = calcNormal(co + cr.x  * rd);\n        vec3 mate=vec3(.18);\n        \n        vec3 sun_dir=normalize(vec3(.8,.4,.2));\n        sun_dir.xz *= rot(iTime/2.);\n        float sun_dif=clamp(dot(N,sun_dir),.0,1.);\n        float sun_sha=step(castRay(co+cr.x *rd+N*.001,sun_dir).x,.0);\n        float sky_dif=clamp(.5+.5*dot(N,vec3(.0,1.,.0)),.0,1.);\n        float bou_dif=clamp(.5+.5*dot(N,vec3(.0,-1.,.0)),.0,1.);\n        \n        color=mate*vec3(7.,4.5,3.)*sun_dif*sun_sha;\n        color+=mate*vec3(.5,.8,.9)*sky_dif;\n        color+=mate*vec3(.7,.3,.2)*bou_dif;\n        color = mix(color , skycolor, crp * crp * crp);\n    }\n    \n    color=pow(color, vec3(.4545));\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/td2fRt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "td2fzy", "name": "Little sun", "author": "Stenator", "description": "a cute little sun :)", "tags": ["noise"], "likes": 2, "viewed": 51, "date": "1590321752", "time_retrieved": "2024-06-20T20:06:59.348968", "image_code": "\n//Random\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n\n\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0,\n                0.0,_scale.y);\n}\n\n\n\n//fbm anim\nfloat FbmVariation( float value) {\n\nfloat amplitude = 0.04;\nfloat frequence = 3.;\nfloat y = sin(value*frequence);\nfloat t = 0.01*(-iTime * 130.);\ny+= sin(value*frequence*2.1+t)*4.5;\ny+= sin(value*frequence*1.4842+t)*3.;\ny+= sin(value*frequence*4.55858+t)*4.5;\ny*=amplitude*0.07;\n\nreturn y; }\n\n\n\n//donne la distance pour raymarch\nfloat GetDist(vec3 p) {\n\n    vec3 pnoise = p ;\n    //pnoise.y *= 1;\n    \n    float variation = noise((pnoise.xy* pnoise.z));\n    pnoise = pnoise *0.02;\n    pnoise.z += iTime*0.05;\n    float minvar = noise(pnoise.xy * pnoise.z);\n    pnoise *= 6.;\n    float maxvar = noise(pnoise.xy * pnoise.z);\n\n\n    variation = variation*0.15 +  FbmVariation(minvar) ;\n    variation += 0.008 * (maxvar);\n    \n    vec4 s = vec4(0., 1., 6., 1.5 +  variation );\n    \n    float sphereDist = length(p-s.xyz) -s.w;\n    \n    \n    return sphereDist;\n    }\n\n\n\n//on definit des valeur ici afin de les retrouver plus facilement\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\n\n\n//fonction raymarch\nfloat RayMarch(vec3 ro,vec3 rd) {\nfloat dO =0. ;\n\nfor(int i=0; i<MAX_STEPS; i++) {\nvec3 p = ro + rd*dO; //c'est le point qui marque la distance \nfloat dS = GetDist(p);\ndO += dS;\nif(dO>MAX_DIST ||dS<SURF_DIST) break; \n\n}\nreturn dO;\n}\n\n\n\n//recuperation des normal\nvec3 GetNormal(vec3 p) {\nfloat d = GetDist(p);\nvec2 e = vec2(.01, 0.);\n\nvec3 n = d - vec3(\n    GetDist(p- e.xyy),\n    GetDist(p- e.yxy),\n    GetDist(p- e.yyx));\n\n    return normalize(n);\n}\n\n\n// la rimlight\nfloat RimLight (vec3 p, vec3 rd) {\nvec3 normal = GetNormal(p);\n\nfloat rim =  1.- dot(normal, normalize(vec3(0.,0.,-1.)));\nrim = clamp(rim,0.,1.)*6.;\nreturn max(0.2,rim*0.2);\n\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec2 uv = -1. + 2. * v_texcoord;\n    //vec2 uv = gl_FragCoord.xy / resolution;\n    vec2 uv = (gl_FragCoord.xy-.5* iResolution.xy) / iResolution.y;\n    \n    \n    \n    //camera\n    vec3 ro = vec3(0., 1., 0.); //ray origin, c'est la position de la camÃ©ra\n    vec3 rd  = normalize(vec3(uv.x,uv.y,1.)); // direction du rayon/ camera?\n    \n    \n    float d = RayMarch(ro, rd);\n    vec3 p = ro + rd * d; //les coord des point par rapport a la zdepth\n    \n    \n    //on enleve tout la partie du fond du calcul de la rim\n    float gradientlight =0.2;\n    float light = 0.;\n    if (d<50.) {\n    light = RimLight(p, rd); }\n    \n    float varcolor = noise(p.xy * p.z);\n    \n    \n    vec3 seccolor = vec3(0.7,0.2,0.1)*(varcolor*9.);\n    vec3 color = vec3(0.3,0.15,0.05) ;//*seccolor;\n    color = mix(color,seccolor,varcolor)*2.;\n    \n    color *= light*6.;\n    fragColor = vec4(color,\n        1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/td2fzy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "td2SzG", "name": "Flipping Boxes Pattern", "author": "koi", "description": "An old shader inspired by @beesandbombs on Twitter.", "tags": ["pattern", "boxes", "flipping"], "likes": 4, "viewed": 231, "date": "1590437519", "time_retrieved": "2024-06-20T20:06:59.348968", "image_code": "#define TAU 6.28318530718\n\nfloat flipRange(float a, float fac) {\n    return fac + a * (1.0 - 2.0*fac);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = (fragCoord - iResolution.xy / 2.0) / iResolution.x;\n    coord *= 10.0;\n    \n    float t = iTime / 2.0;\n    float flip = step(0.5, fract(t/2.0));\n    float a = fract(t)*TAU/4.0;\n    float r = 0.5;\n    \n    vec2 fc = coord - 0.5*flip;\n    fc -= round(fc);\n    fc *= mat2(cos(a), -sin(a), sin(a), cos(a));\n    \n    float d = abs(fc.x) + abs(fc.y);\n    \n    float fwd = fwidth(coord.x) / 2.0;\n    float val = smoothstep(-fwd, fwd, d - r);\n    val = flipRange(val, flip);\n    \n    fragColor = vec4(val);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/td2SzG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdBBRt", "name": "Simple area light", "author": "kow", "description": "https://www.shadertoy.com/view/tsKXzK", "tags": ["raymarching", "arealight"], "likes": 7, "viewed": 104, "date": "1590849841", "time_retrieved": "2024-06-20T20:06:59.355147", "image_code": "vec3 A = vec3(-5., 2., 0.); \nvec3 B = vec3(5., 2., 0.); \nvec3 C = vec3(5., 1., 0.); \nvec3 D = vec3(-5., 1., 0.);\n\nvec3 AA = vec3(-8., 5., 5.); \nvec3 BB = vec3(8., 5., 5.); \nvec3 CC = vec3(8., 5., -5.); \nvec3 DD = vec3(-8., 5., -5.);\n\nvec3 lightColor = vec3(0.9, 1., .9);\n\nvec3 area_light(in vec3 p, in vec3 a, in vec3 b, in vec3 c, in vec3 d, out vec3 n)\n{\n    vec3 o = (a+b+c+d)/4.;\n    vec3 ba = b-a;\n    vec3 cb = c-b;\n    vec3 dc = d-c;\n    vec3 ad = a-d;\n    n = normalize(cross(ba, ad));\n    p = p-n*dot(p-o, n);\n    vec3 pa = p-a;\n    vec3 pb = p-b;\n    vec3 pc = p-c;\n    vec3 pd = p-d;\n    float s = 4., l = 100000.;\n    vec3 vo, vh, vd;\n    if (sign(dot(cross(ba, n), pa)) <= -1. && length(pa) < l)\n    {\n        s--; l = length(pa); vo = a; vh = b; vd = pa;\n    }\n    if (sign(dot(cross(cb, n), pb)) <= -1. && length(pb) < l)\n    {\n        s--; l = length(pb); vo = b; vh = c; vd = pb;\n    }\n    if (sign(dot(cross(dc, n), pc)) <= -1. && length(pc) < l)\n    {\n        s--; l = length(pc); vo = c; vh = d; vd = pc;\n    }\n    if (sign(dot(cross(ad, n), pd)) <= -1. && length(pd) < l)\n    {\n        s--; l = length(pd); vo = d; vh = a; vd = pd;\n    }\n    if (s < 4.)\n    {\n        float t = clamp(dot(vh-vo, vd)/dot(vh-vo, vh-vo), 0., 1.);\n        return mix(vo, vh, t);\n    }\n    else\n        return p;\n}\n\n// Quad function from IQ\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat dot2( vec3 v ) { return dot(v,v); }\nfloat quad( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 dc = d - c; vec3 pc = p - c;\n  vec3 ad = a - d; vec3 pd = p - d;\n  vec3 nor = cross( ba, ad );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ad,nor),pd))<3.0)\n     ?\n     min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nvec2 opU(in vec2 a, in vec2 b)\n{\n    return a.x<b.x?a:b;\n}\n\nvec2 scene(in vec3 p)\n{\n    vec2 plane1 = vec2(p.y, 1.5);\n    vec2 quad1 = vec2(quad(p, A, B, C, D), 2.5);\n    vec2 quad2 = vec2(quad(p, AA, BB, CC, DD), 2.5);\n    vec4 sphere = vec4(0, -1, 3, 2.5);\n    vec2 sphereDist = vec2(length(p - sphere.xyz) - sphere.w, 1.5);\n\n    vec2 sc1 = opU(sphereDist, quad1);\n    vec2 sc2 = opU(sc1, quad2);\n    return opU(plane1, sc2);\n}\n\nvec3 getNormal(in vec3 p)\n{\n    float d = scene(p).x;\n    vec2 e = vec2(.1, 0.);\n    vec3 n = d - vec3\n        \t\t\t(\n                        scene(p-e.xyy).x,\n                        scene(p-e.yxy).x,\n                        scene(p-e.yyx).x\n    \t\t\t\t);\n    return normalize(n);\n}\n\nvec2 marcher(in vec3 o, in vec3 d)\n{\n    float t = 0.;\n    for (int i = 0; i < 100; i++)\n    {\n        vec2 s = scene(o + d * t);\n        if (s.x < .01)\n            return vec2(t, s.y);\n        t += s.x * .8;\n    }\n    return vec2(-1.5);\n}\n\nvec3 computeAreaLight(vec3 p, vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n    vec3 n = vec3(0.);\n    vec3 pl = area_light(p, p1, p2, p3, p4, n);\n\n    //float df = dot(normalize(p-pl), n);\n\n    float l = length(p-pl);\n    float kc = .9;\n    float kl = .7;\n    float kq = .15;\n    float attenuation = 1. / (kc + kl * l + kq * l * l);\n\n    return lightColor * attenuation; // *df;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy*2.-1.;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 col = vec3(0.);\n    \n    vec3 o = vec3(0., 3., 10.);\n    vec3 d = vec3(uv, -1.);\n    \n    float T = sin(iTime);\n    mat2 rot = mat2(cos(T), sin(T), -sin(T), cos(T));\n    \n    A.xz *= rot;\n    B.xz *= rot;\n    C.xz *= rot;\n    D.xz *= rot;\n    \n    vec2 m = marcher(o, d);\n    int index = int(floor(m.y));\n    if (index != -1)\n    {\n        vec3 p = o + d * m.x;\n        if (index == 1)\n        {\n            col += computeAreaLight(p, A, B, C, D);\n            col += computeAreaLight(p, AA, BB, CC, DD);\n        }\n        if (index == 2)\n        {\n            col += lightColor;\n        }\n    }\n\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdBBRt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdBBRV", "name": "Golden Magma", "author": "TAKUSAKU", "description": "Golden Magma", "tags": ["gold", "magma"], "likes": 5, "viewed": 110, "date": "1590383229", "time_retrieved": "2024-06-20T20:06:59.355147", "image_code": "float random (in vec2 _st) {\n    return fract(sin(dot(_st.xy, vec2(0.9,-0.5)))*757.153);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3. - 2. * f);\n\n    return mix(a, b, u.x) + (c - a)* u.y * (1. - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat fbm ( in vec2 _st) {\n    float v = sin(iTime*0.3)*0.1;\n    float a = 0.1;\n    vec2 shift = vec2(100.);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(1.0), -sin(0.5), acos(0.5));\n    for (int i = 0; i < 3; ++i) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 2.8;\n    }\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y) * 0.8;\n   \n    vec2 coord = st;\n    coord.x += 0.2*iTime;\n    coord.y += 0.2*iTime;\n    \n    float len = length(coord) - 3.;     \n    \n    vec3 color = vec3(0.);\n\n    vec2 q = vec2(0.);\n    q.x = fbm( st + 1.0);\n    q.y = fbm( st + vec2(-0.450,0.650));\n\n    vec2 r = vec2(0.);\n    r.x = fbm( st + 1.0*q + vec2(0.570,0.520)+ 0.1*iTime );\n    r.y = fbm( st + 1.0*q + vec2(0.340,-0.570)+ 0.07*iTime);\n    \n    color = mix(color, cos(len + vec3(0.2, 0.0, 0.5)), 1.0);\n    color = mix(vec3(0.730,0.237,0.003), vec3(0.667,0.295,0.005), color);\n    \n    float f = fbm(st+r);\n    fragColor = vec4(2.0*(f*f*f+.6*f*f+.5*f)*color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdBBRV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdBBWG", "name": "Sea of Colors", "author": "jarble", "description": "It's an infinite sea of randomly-colored bubbles.", "tags": ["raymarching"], "likes": 0, "viewed": 187, "date": "1590689229", "time_retrieved": "2024-06-20T20:07:00.440064", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n/**\n * Part 6 Challenges:\n * - Make a scene of your own! Try to use the rotation transforms, the CSG primitives,\n *   and the geometric primitives. Remember you can use vector subtraction for translation,\n *   and component-wise vector multiplication for scaling.\n */\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.0001;\n\nvec3 hash33(vec3 p3)\n{\t\n    return fract((p3.zyx*sin(p3.x)+2.0)*(p3.zxy*cos(p3.x)+2.0+sin((p3.x+p3.y+p3.z)*2.0)));\n}\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {    \n    return length(hash33(sin(samplePoint)/10.0))-sin(length(samplePoint))/3.33;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(8.0+iTime*10.0, 5.0, 7.0*iTime);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = hash33(p/(500.0));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdBBWG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdBBzc", "name": "Mandelbrot zoom(26.5.20)", "author": "LucasWilson", "description": "Mandelbrot shader, floating precision problems atm", "tags": ["fractal", "mandelbrot", "complex"], "likes": 0, "viewed": 40, "date": "1590507692", "time_retrieved": "2024-06-20T20:07:00.440064", "image_code": "const float bigmag = 3000.;\nfloat scale = 0.;\nconst float maxtimescale = 15.;\n\nvec2 cmpxmul(in vec2 a, in vec2 b) {\n\treturn vec2(a.x * b.x - a.y * b.y, a.y * b.x + a.x * b.y);\n}\n\nvec2 calcm(vec2 num) {\n    float i=0.;\n    vec2 num2 = vec2(0.,0.);\n    \n    while (length(num2) < bigmag && i < 500.) {\n    \tnum2 = cmpxmul(num2,num2) + num/scale;\n        i+=1.;\n    }\n    \n\treturn vec2(1.-length(num2)/bigmag, i);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    scale = 29. + (cos(iTime/20. - 3.142)+1.)*maxtimescale;\n    fragCoord.xy = (fragCoord.xy/iResolution.xy - vec2(.5))*iResolution.xy;\n    \n    vec3 camPos = vec3( vec2(-.000136705,0.00198882)*scale * iResolution.xy , pow(1.5, scale-20.)/10.);\n    vec2 fragOffset = (fragCoord-camPos.xy)/camPos.z;\n    \n\tfragColor = vec4(calcm(camPos.xy + fragOffset) / vec2(1.,200.), 0., 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdBBzc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdBfDK", "name": "MengerSponge Lightning Base", "author": "TAKUSAKU", "description": "MengerSponge Lightning Base", "tags": ["raymarching", "lightning", "fold", "mengersponge"], "likes": 8, "viewed": 113, "date": "1590827018", "time_retrieved": "2024-06-20T20:07:00.446166", "image_code": "#define time iTime\nconst float PI = 3.14159265;\nconst float HARF_PI = 1.57079632;\n\n// Background shader based on : \n// https://www.shadertoy.com/view/4sVBDm\n// ---------------------------------------------------------------------\n\n//noise background\nconst float noiseIntensity = 2.8;\nconst float noiseDefinition = 0.6;\nconst vec2 glowPos = vec2(-2., 0.);\n\nfloat random(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(-0.950,-0.910))) * 43758.5453);\n}\n\nfloat noise( in vec2 p ){\n    p*=noiseIntensity;\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\tvec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( random( i + vec2(0.0,0.0) ), \n                     random( i + vec2(1.0,0.0) ), u.x),\n                mix( random( i + vec2(0.0,1.0) ), \n                     random( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat fbm( in vec2 uv ){\t\n\tuv *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    float f  = 0.5*noise( uv ); uv = m*uv;\n    f += 5.*noise( uv ); uv = m*uv;\n    f += 5.*noise( uv ); uv = m*uv;    \n\tf = 0.1 + .5*f;\n    return f;\n}\n\nvec3 bg(vec2 uv ){\n    float velocity = time * 0.5;\n    float intensity = sin(uv.x*noise(uv)*7.+velocity*3.)*noise(uv*10.)*1.0+.3;\n    uv.y -= 2.;\n    vec2 bp = uv+glowPos;\n    uv *= noiseDefinition;\n\n    //ripple\n    float rb = fbm(vec2(uv.x*.5-velocity*.03, uv.y))*.1;\n    uv += rb;\n\n    //coloring\n    float rz = fbm(uv*.9+vec2(velocity*.35, 0.0));\n    rz *= dot(bp*intensity,bp);\n\n    //bazooca line\n    rz *= sin(uv.x*0.1+velocity*0.8);\n    \n    //lightning\n    rz *= 5.*sin(uv.x*0.1+velocity*sin(time));\n    \n    vec3 bgColor = vec3(cos(time),0.45 * sin(time*0.2),sin(time*0.3));\n    vec3 col = bgColor/(.1-rz);\n    return sqrt(abs(col));\n}\n\n// IFS MengerSponge is based on gam0022.net\n// https://gam0022.net/blog/2019/06/25/unity-raymarching/\n// ---------------------------------------------------------------------\nvec3 trans(vec3 p){\n    return mod(p, 4.0) -2.0;\n}\n\n#define ITERATIONS 4\n\nvec3 _MengerOffset = vec3(1.000,0.072,0.414);\nfloat _MengerFold = 3.;\n\n// IFS MengerSpongeãDistanceFunction\nfloat dMenger(vec3 z0, vec3 offset, float scale) {\n    vec4 z = vec4(z0, 1.0);\n    for (int n = 0; n < ITERATIONS; n++) {\n        z = abs(z);\n\n        if (z.x < z.y) z.xy = z.yx;\n        if (z.x < z.z) z.xz = z.zx;\n        if (z.y < z.z) z.yz = z.zy;\n\n        z *= scale;\n        z.xyz -= offset * (scale - 1.0);\n\n        if (z.z < -0.5 * offset.z * (scale - 1.0))\n            z.z += offset.z * (scale - 1.0);\n    }\n    return (length(max(abs(z.xyz) - vec3(1.0, 1.0, 1.0), 0.0)) - 0.05) / z.w;\n}\n\n// 2D rotate\nmat2 rotate(in float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\n// Deformation used folding\n// https://www.shadertoy.com/view/Mlf3Wj\nvec2 foldRotate(in vec2 p, in float s) {\n    float a = PI / s - atan(p.x, p.y);// PI/s = offset, atan(p.x, p.y) : XY to Polar coordinates\n    float n = PI*2. / s;// Unit angle\n    a = floor(a / n) * n;\n    p *= rotate(a);\n    return p;\n}\n\n// Final DistanceFunction\nfloat map(vec3 pos) {\n    pos.xy = foldRotate(pos.xy, _MengerFold);\n    pos.yz = foldRotate(pos.yz, _MengerFold);\n    vec3 p = trans(pos);\n    float _MengerScale = -(1.1 +0.7*smoothstep(0.0,2.0,1.-cos(time*0.1)));\n    return dMenger(p, _MengerOffset, _MengerScale);\n}\n\n// Normal and Camera\n// baced on Kazuya Hiruma @edo_m18\n// https://qiita.com/edo_m18/items/1532aceb9d470174caaf#%E3%83%90%E3%83%AA%E3%83%A5%E3%83%BC%E3%83%8E%E3%82%A4%E3%82%BA\n// ---------------------------------------------------------------------\n// Normal\nvec3 getNormal(vec3 p){\n    const vec2 e = vec2(0.001, 0.0);\n\treturn normalize(vec3(\n\t\tmap(p + e.xyy) - map(p - e.xyy),\n\t\tmap(p + e.yxy) - map(p - e.yxy),\n\t\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n// Camera\nmat3 camera(vec3 ro, vec3 ta){\n    vec3 cw = normalize(ta - ro);// camera forward, ro = Ray origin, ta = Target\n    vec3 cp = vec3(0.0, 1.0, 0.0);\n    vec3 cu = cross(cw, cp);\n    vec3 cv = cross(cu, cw);\n    return mat3(cu, cv, cw);\n}\n\n// lighting\nvec3 getMetalColor(vec3 n, vec3 rd, vec2 p, vec2 uv){\n\n    vec3 refDir = reflect(rd, n);// reflect direction\n    float specular = max(0.0, dot(refDir, vec3(-0.017,0.473,-0.617)));// light position\n    vec3 SPECULAR_COLOR = 30.0*pow(specular, 1.5)*(vec3(0.195,0.157,0.144));// light color\n    vec3 bgCol = bg(p)*(2.-abs(uv.y*2.));\n    vec3 spCol = mix(bgCol, SPECULAR_COLOR, 0.5);\n    \n    return mix(spCol, refDir, 0.2);\n}\n\n// fog\n// based on Atsushi Asakura @aa_debdeb\n// https://qiita.com/aa_debdeb/items/b78975c5bcb063e28a08\nfloat exp2Fog(float d, float density) {\n\tfloat dd = d * density;\n\treturn exp(-dd * dd);\n}\n\n// ---------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;// background\n    \n    // Wide-angle lens is baced on Menger Sponge Variation\n    // https://www.shadertoy.com/view/ldyGWm\n    // background\n    vec3 st = (vec3(2.0 * fragCoord - iResolution.xy, iResolution.y));\n    st = normalize(vec3(st.xy, sqrt(max(st.z * st.z - dot(st.xy, st.xy) *4.*sin(time*0.4),0.))));\n    \n    // camera  \n    vec3 ta1 = vec3(0.0,0.0,-1.0);// target1\n    vec3 ta2 = vec3(cos(time*0.4+HARF_PI),0.0,time+sin(time*0.4+HARF_PI));// target2\n    \n    float moveSwitch =  step(0.942, smoothstep(0.0,2.0,1.-cos(time*0.1)));\n    vec3 ta = mix(ta1, ta2, moveSwitch);//if(smooth...<=0.942){ta1} else {ta2}\n    \n\tvec3 ro = vec3(0.0, 0.0, time);// ray origin = camera position\n    \n\tmat3 c = camera(ro, ta);\n     \n    // ray\n    float fl = 1.0;// focalLength\n\tvec3 rd = c * normalize(vec3(p, fl));// ray direction = normalize(vec3(cu*p.x + cv*p.y + cw*fl));\n    \n    // marching loop\n    float d;\n    float t = 0.0;\n    vec3  rPos = ro;\n    for(int i = 0; i < 64; i++){\n        d = map(rPos);\n        t += d;\n        rPos = ro + rd * t;\n    }\n    \n    //color\n    vec3 normal = getNormal(rPos);\n    vec3 col1 = getMetalColor(normal, rd, st.xy, uv);\n    vec3 col2 = getMetalColor(normal, rd, p, uv);\n    vec3 color = mix(col1, col2, moveSwitch);//if(smooth...<=0.942){col1} else {col2}\n    \n    //fog\n    vec3 fogColor = vec3(1.000,0.976,0.822);\n    float f = exp2Fog(d, 8.);\n\t\tcolor = mix(fogColor, color, f);\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdBfDK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdBfRw", "name": "Simulating the Colors of the Sky", "author": "jamelouis", "description": "https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/simulating-sky", "tags": ["sky"], "likes": 9, "viewed": 121, "date": "1589692986", "time_retrieved": "2024-06-20T20:07:00.446166", "image_code": "const float INFINITY = 1.0 / 0.0;\nconst float M_PI = 3.1415926f;\nconst float earthRadius = 6360e3;\nconst float atmosphereRadius = 6420e3;\nconst float Hr = 7994.;\nconst float Hm = 1200.;\nconst vec3 betaR = vec3(3.8e-6, 13.5e-6,33.1e-6);\nconst vec3 betaM = vec3(21e-6f);\n// from 'the graphics codex'\n// Ray-Sphere Intersection\nbool raySphereIntersect(vec3 P, vec3 w, vec3 C, float r, out float t0, out float t1) { \n    vec3 v = P - C;\n    \n    float b = 2.0 * dot(w, v);\n    float c = dot(v,v) - r * r;\n    \n    float d = b * b - 4.0 * c;\n    \n    if(d<0.0) return false;\n    \n    float s = sqrt(d);\n    t0 = (-b-s) * 0.5;\n    t1 = (-b+s) * 0.5f;\n    \n    return true;\n}\n\nvec3 computeIncidentLight(vec3 o, vec3 d, float tmin, float tmax, vec3 sunDirection)\n{\n    float t0, t1;\n    if(!raySphereIntersect(o, d, vec3(0.0), atmosphereRadius, t0, t1) || t1 < 0.) return vec3(0.0);\n    if(t0>tmin && t0>0.) tmin = t0;\n    if(t1<tmax) tmax = t1;\n    uint numSamples = 16u;\n    uint numSamplesLight = 8u;\n    float segmentLength = (tmax-tmin)/float(numSamples);\n    float tCurrent = tmin;\n    vec3 sumR = vec3(0.0);\n    vec3 sumM = vec3(0.0);\n    float opticalDepthR = 0.0;\n    float opticalDepthM = 0.0;\n    float mu = dot(d, sunDirection);\n    float phaseR = 3.f / (16.f * M_PI) * ( 1. + mu * mu);\n    float g = 0.76;\n    float phaseM = 3. / (8. * M_PI) * ((1.-g*g)*(1. + mu*mu)) / ((2. + g*g) * pow(1. + g*g - 2. * g * mu, 1.5));\n    \n    for(uint i = 0u; i < numSamples; ++i) {\n        vec3 samplePosition = o + (tCurrent + segmentLength * 0.5) * d;\n        float height = length(samplePosition) - earthRadius;\n        float hr = exp(-height/ Hr) * segmentLength;\n        float hm = exp(-height/Hm) * segmentLength;\n        opticalDepthR += hr;\n        opticalDepthM += hm;\n        float t0Light;\n        float t1Light;\n        raySphereIntersect(samplePosition, sunDirection, vec3(0.0), atmosphereRadius, t0Light, t1Light);\n        float segmentLengthLight = t1Light / float(numSamplesLight);\n        float opticalDepthLightR = 0.;\n        float opticalDepthLightM = 0.;\n        float tCurrentLight = 0.;\n        uint j;\n        for(j=0u;j<numSamplesLight;++j){\n            vec3 samplePositionLight = samplePosition + (tCurrentLight + segmentLengthLight * 0.5) * sunDirection;\n            float heightLight = length(samplePositionLight) - earthRadius;\n            if(heightLight < 0.0) break;\n            opticalDepthLightR += exp(-heightLight / Hr) * segmentLengthLight;\n            opticalDepthLightM += exp(-heightLight / Hm) * segmentLengthLight;\n            tCurrentLight += segmentLengthLight;\n        }\n        if(j==numSamplesLight) {\n            vec3 tau = vec3(betaR * (opticalDepthR + opticalDepthLightR) + betaM * 1.1 * (opticalDepthM + opticalDepthLightM));\n            vec3 attenuation = exp(-tau);\n            sumR += attenuation * hr;\n            sumM += attenuation * hm;\n        }\t\n        tCurrent += segmentLength;\n    }\n    \n    return vec3(sumR * betaR * phaseR + sumM * betaM * phaseM) * 20.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy  * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float angle = M_PI / 2.0 * (fract(float(iFrame)/180.)*2.-1.);\n    vec3  sunDirection = vec3(sin(angle), cos(angle), 0.0);\n    \n    float x = uv.x;\n    float y = uv.y;\n    float z2 = x*x + y*y;\n    \n    vec3 col = vec3(0.0);\n    if(z2 <= 1.){\n        float phi = atan(y,x);\n        float theta = acos(1.-z2);\n        vec3 dir = vec3(sin(theta)*cos(phi), cos(theta), sin(theta)*sin(phi));\n        col = computeIncidentLight(vec3(0.0, earthRadius + 1., 0.0), dir, 0., INFINITY, sunDirection);\n    }\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdBfRw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdBXDz", "name": "datastream", "author": "gsynuh", "description": "Inspired by Ryoji Ikeda's work.", "tags": ["noise"], "likes": 2, "viewed": 96, "date": "1589732891", "time_retrieved": "2024-06-20T20:07:00.446166", "image_code": "#define f fragCoord.xy;\n#define r iResolution.xy\n#define PI 3.1415926538\n#define TWO_PI 6.2831853076\n\nfloat random (in float x) {\n    return fract(sin(x)*1e4);\n}\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\nfloat sstep(float v,float t) {\n\treturn smoothstep(t-0.01,t+0.01,v);\n}\n\nfloat borders(float v,float w) {\n\treturn sstep(v,1.-w);\n}\n\nfloat patt(in vec2 st) {\n    vec2 sti = floor(st);\n    vec2 stf = fract(st);\n    float ra = random(sti) > 0.5 ? 1.0 : 0.0;\n    vec2 st2 = fract(stf);\n\treturn  borders(st2.y,0.8) *ra;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float t = iTime+30942.122342;\n    \n    float lns = 64.0;\n    float cols = 2.0;\n    vec3 c;\n    float speed = 0.2;\n    \n    vec2 st = fragCoord.xy/r.xy;\n    st.x *= cols;\n    st.y *= lns; \n\n    \n    for(int i = 0; i < 3; i++) {\n\n        float fi = float(i+1);\n        fi *= random(fi) * 2.0 - 1.0;\n\n        float line = floor(st.y);\n        float dir = random(line) * 2.0 - 1.0;\n\n        vec2 st2 = st + vec2(t*speed*dir*fi,0.);\n\n        c[i] = patt(st2);\n    \t\n    }\n    \n    fragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdBXDz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdfBWs", "name": "Trippier Menger Journey", "author": "kowbell", "description": "A fork of Snytopia's excellent shadertoy: https://www.shadertoy.com/view/Mdf3z7\n\n", "tags": ["raymarching", "colorful", "fractals", "menger", "trippy", "psychadelic"], "likes": 10, "viewed": 218, "date": "1589257335", "time_retrieved": "2024-06-20T20:07:01.483699", "image_code": "// Original by Snytopia (https://www.shadertoy.com/view/Mdf3z7)\n// I've made very very minimal changes to it. All credit goes to them :)\n// This one is modified to have ~ t r i p p i e r ~ parameters!\n\n\n// /////////////////////////////////////////////////////////////////// //\n// Feel free to mess with the values here,                             //\n// then hit the Play button down in the bottom left of this text area! //\n// /////////////////////////////////////////////////////////////////// //\n\n\n// Try between 8 and 40!\n#define MaxSteps 15\n\n// No time to explain all these, just mess with 'em!\n#define Iterations 7\n#define Scale 3.0\n#define FieldOfView 1.0\n#define Jitter 0.05\n#define FudgeFactor 0.7\n#define NonLinearPerspective 3.0\n\n// Modified time used for color effects\n// Haven't hooked this up to tweak how fast you \"fly through\" everything.\n#define xTime iTime * 0.1\n#define sTime (sin(xTime) + 2.0) / 0.5\n#define cTime (cos(xTime) + 2.0) / 0.5\n\n// Ambient brightness\n#define Ambient 0.3\n// Strength of the two light colors\n#define Diffuse 0.9\n\n// Tweak these!\n#define LightColor hsv2rgb(vec3(cTime, 3.0, 1.5))\n#define LightColor2 hsv2rgb(vec3(sTime, 3.0, 1.5))\n\n\n// \"Melts\" things when you use lower values\n#define Offset vec3(0.92858, 0.92858, 0.32858)\n\n\n// /////////////////////////////////////////////////////////////////// //\n// Messing with these won't do you much good...                        //\n// /////////////////////////////////////////////////////////////////// //\n#define MinimumDistance 0.0009\n#define normalDistance  0.0002\n\n#define LightDir vec3(1.0)\n#define LightDir2 vec3(1.0,-1.0,1.0)\n\n#define PI 3.141592\n\n\n\n\n// from iq, https://www.shadertoy.com/view/lsS3Wc\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec2 rotate(vec2 v, float a) {\n\treturn vec2(cos(a)*v.x + sin(a)*v.y, -sin(a)*v.x + cos(a)*v.y);\n}\n\n// Two light sources. No specular \nvec3 getLight(in vec3 color, in vec3 normal, in vec3 dir) {\n\tvec3 lightDir = normalize(LightDir);\n\tfloat diffuse = max(0.0,dot(-normal, lightDir)); // Lambertian\n\t\n\tvec3 lightDir2 = normalize(LightDir2);\n\tfloat diffuse2 = max(0.0,dot(-normal, lightDir2)); // Lambertian\n\t\n\treturn\n\t(diffuse*Diffuse)*(LightColor*color) +\n\t(diffuse2*Diffuse)*(LightColor2*color);\n}\n\n\n// DE: Infinitely tiled Menger IFS.\n//\n// For more info on KIFS, see:\n// http://www.fractalforums.com/3d-fractal-generation/kaleidoscopic-%28escape-time-ifs%29/\nfloat DE(in vec3 z)\n{\n\t// enable this to debug the non-linear perspective\n    /**\n    z = fract(z);\n    float d=length(z.xy-vec2(0.5));\n    d = min(d, length(z.xz-vec2(0.5)));\n    d = min(d, length(z.yz-vec2(0.5)));\n    return d-0.01;\n\t**/\n    \n\t// Folding 'tiling' of 3D space;\n\tz  = abs(1.0-mod(z,2.0));\n\n\tfloat d = 1000.0;\n\tfor (int n = 0; n < Iterations; n++) {\n\t\tz.xy = rotate(z.xy,4.0+2.0*cos( iTime/8.0));\t\t\n\t\tz = abs(z);\n\t\tif (z.x<z.y){ z.xy = z.yx;}\n\t\tif (z.x< z.z){ z.xz = z.zx;}\n\t\tif (z.y<z.z){ z.yz = z.zy;}\n\t\tz = Scale*z-Offset*(Scale-1.0);\n\t\tif( z.z<-0.5*Offset.z*(Scale-1.0))  z.z+=Offset.z*(Scale-1.0);\n\t\td = min(d, length(z) * pow(Scale, float(-n)-1.0));\n\t}\n\t\n\treturn d-0.001;\n}\n\n// Finite difference normal\nvec3 getNormal(in vec3 pos) {\n\tvec3 e = vec3(0.0,normalDistance,0.0);\n\t\n\treturn normalize(vec3(\n\t\t\tDE(pos+e.yxx)-DE(pos-e.yxx),\n\t\t\tDE(pos+e.xyx)-DE(pos-e.xyx),\n\t\t\tDE(pos+e.xxy)-DE(pos-e.xxy)\n\t\t\t)\n\t\t);\n}\n\n// Solid color \nvec3 getColor(vec3 normal, vec3 pos) {\n\treturn vec3(1.0);\n}\n\n\n// Pseudo-random number\n// From: lumina.sourceforge.net/Tutorials/Noise.html\nfloat rand(vec2 co){\n\treturn fract(cos(dot(co,vec2(4.898,7.23))) * 23421.631);\n}\n\nvec4 rayMarch(in vec3 from, in vec3 dir, in vec2 fragCoord) {\n\t// Add some noise to prevent banding\n\tfloat totalDistance = Jitter*rand(fragCoord.xy+vec2(iTime));\n\tvec3 dir2 = dir;\n\tfloat distance;\n\tint steps = 0;\n\tvec3 pos;\n\tfor (int i=0; i < MaxSteps; i++) {\n\t\t// Non-linear perspective applied here.\n\t\tdir.zy = rotate(dir2.zy,totalDistance*cos( iTime/4.0)*NonLinearPerspective);\n\t\t\n\t\tpos = from + totalDistance * dir;\n\t\tdistance = DE(pos)*FudgeFactor;\n\t\ttotalDistance += distance;\n\t\tif (distance < MinimumDistance) break;\n\t\tsteps = i;\n\t}\n\t\n\t// 'AO' is based on number of steps.\n\t// Try to smooth the count, to combat banding.\n\tfloat smoothStep =   float(steps) + distance/MinimumDistance;\n\tfloat ao = 1.1-smoothStep/float(MaxSteps);\n\t\n\t// Since our distance field is not signed,\n\t// backstep when calc'ing normal\n\tvec3 normal = getNormal(pos-dir*normalDistance*3.0);\n\t\n\tvec3 color = getColor(normal, pos);\n\tvec3 light = getLight(color, normal, dir);\n\tcolor = (color*Ambient+light)*ao;\n\treturn vec4(color,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Camera position (eye), and camera target\n\tvec3 camPos = 0.5*iTime*vec3(1.0,0.0,0.0);\n\tvec3 target = camPos + vec3(1.0,0.0*cos(iTime),0.0*sin(0.4*iTime));\n\tvec3 camUp  = vec3(0.0,1.0,0.0);\n\t\n\t// Calculate orthonormal camera reference system\n\tvec3 camDir   = normalize(target-camPos); // direction for center ray\n\tcamUp = normalize(camUp-dot(camDir,camUp)*camDir); // orthogonalize\n\tvec3 camRight = normalize(cross(camDir,camUp));\n\t\n\tvec2 coord =-1.0+2.0*fragCoord.xy/iResolution.xy;\n\tcoord.x *= iResolution.x/iResolution.y;\n\t\n\t// Get direction for this pixel\n\tvec3 rayDir = normalize(camDir + (coord.x*camRight + coord.y*camUp)*FieldOfView);\n\t\n\tfragColor = rayMarch(camPos, rayDir, fragCoord );\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdfBWs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdfBzf", "name": "CTJuliaMorph", "author": "Chris_M_Thomasson", "description": "A pure experiment!", "tags": ["fractal", "vector", "morph", "bio"], "likes": 1, "viewed": 71, "date": "1588744409", "time_retrieved": "2024-06-20T20:07:02.591686", "image_code": "// Fractal Morph Spin by Chris M. Thomasson\n\n\n#define PI 3.1459\n\n\n// Viewport Axes\nstruct ct_axes\n{\n    float xmin;\n    float xmax;\n    float ymin;\n    float ymax;\n};\n    \n    \nct_axes ct_axes_from_radius(\n    in vec3 vpcircle\n){\n    return ct_axes(\n        vpcircle.x - vpcircle.z,\n        vpcircle.x + vpcircle.z,\n        vpcircle.y - vpcircle.z,\n        vpcircle.y + vpcircle.z\n    );\n}\n\n\n// Simple 2d Plane\nstruct ct_plane2d\n{\n    ct_axes axes;\n    float xstep;\n    float ystep;\n};\n    \n    \nct_plane2d ct_plane2d_create(\n    in ct_axes axes\n){\n    float awidth = axes.xmax - axes.xmin;\n    float aheight = axes.ymax - axes.ymin;\n    \n    float daspect = abs(iResolution.y / iResolution.x);\n    float waspect = abs(aheight / awidth);\n    \n    if (daspect > waspect)\n    {\n        float excess = aheight * (daspect / waspect - 1.0);\n        axes.ymax += excess / 2.0;\n        axes.ymin -= excess / 2.0;\n    }\n    \n    else if (daspect < waspect)\n    {\n        float excess = awidth * (waspect / daspect - 1.0);\n        axes.xmax += excess / 2.0;\n        axes.xmin -= excess / 2.0;\n    }\n    \n    return ct_plane2d(\n        axes,\n        (axes.xmax - axes.xmin) / iResolution.x,\n        (axes.ymax - axes.ymin) / iResolution.y\n    );\n}\n\n\nvec2 ct_plane2d_project(\n\tin ct_plane2d self,\n    in vec2 z\n){\n\treturn vec2(\n        self.axes.xmin + z.x * self.xstep,\n        self.axes.ymin + z.y * self.ystep\n    );\n}\n\n\nmat3 ct_rot_x(float angle) \n{\n    float cos_temp = cos(angle);\n    \n    float sin_temp = sin(angle);\n    \n    return mat3(\n        vec3(1., 0., 0.),\n        vec3(0., cos_temp, -sin_temp),\n        vec3(0, sin_temp, cos_temp)\n    );\n}\n\n\nmat3 ct_rot_y(float angle) \n{\n    float cos_temp = cos(angle);\n    float sin_temp = sin(angle);\n    return mat3(\n        vec3(cos_temp, 0., sin_temp),\n        vec3(0., 1., 0.),\n        vec3(-sin_temp, 0., cos_temp)\n    );\n}\n\n\nvec4 ct_circle(\n    in vec2 c,\n    in vec2 z,\n    in float radius\n){\n    float d = length(c - z);\n    \n    if (d < radius) \n    {\n        d = d / radius;\n        float b = -(.25 + abs(sin(iTime)));\n        return exp(b*dot(d,d) ) * vec4(1,.7,.4,0)*2.;\n    }\n    \n    return vec4(0.0, 0.0, 0.0, 0.0);\n}\n\nvec2 ct_cmul(in vec2 p0, in vec2 p1)\n{\n    return vec2(p0.x * p1.x - p0.y * p1.y, p0.x * p1.y + p0.y * p1.x);\n}\n\n\n\n\nfloat ct_torus(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(vec2(p.x, p.z)) - t.x, p.y);\n    return length(q) - t.y * 0.5;\n}\n\n\nfloat ct_de(vec3 p)\n{\n    p *= ct_rot_x(iTime);\n    p *= ct_rot_y(iTime);\n    float de = ct_torus(p, vec2(.5 + abs(sin(iTime)) * .5, .5 + abs(cos(iTime * .25))) * .5);\n    return de;\n}\n\n\n\nmat3 ct_cam(in vec3 ro, in vec3 ta, float cr)\n{\n    vec3 norm_0 = normalize(ta - ro);\n    vec3 p2d = vec3(sin(cr), cos(cr),0.0);\n    vec3 cnorm_0 = normalize( cross(norm_0, p2d) );\n    vec3 cnorm_1 = normalize( cross(cnorm_0, norm_0) );\n    return mat3( cnorm_0, cnorm_1, norm_0 );\n}\n\n\nfloat ct_march_along(vec3 from, vec3 direction) {\n    float dis_sum = 0.0;\n    int i;\n    for (i = 0; i < 64; i++) {\n        vec3 p = from + dis_sum* direction;\n        \n        vec3 origin = vec3(1, 0, 0);\n        \n        float distance = ct_de(p);\n        \n        distance = min(distance, ct_de(p - origin));\n        distance = min(distance, ct_de(p + origin));\n        distance = min(distance, ct_de(p + origin + vec3(.0, .5, sin(iTime))));\n        \n        dis_sum+= distance;\n        if (distance < .001)\n        {\n            break;\n        }\n    }\n    \n    return 1.0 - float(i) / float(64);\n}\n\n\nvec3 ct_main(vec3 pt, vec3 direction) {\n    float dis = ct_march_along(pt, direction);\n    float color_1 = mod(dis * 5., 1.);\n    return vec3(dis, dis, dis);\n}\n\n\n\n// Raw Entry.\nvoid mainImage(\n  \tout vec4 fragColor, \n\tin vec2 fragCoord\n){\n    vec3 vpcircle = vec3(\n        0., \n        0., \n        abs(sin(iTime * .25)) + .5\n    );\n    \n    ct_plane2d plane = ct_plane2d_create(\n        ct_axes_from_radius(vpcircle)\n    );\n    \n    vec2 c = ct_plane2d_project(plane, fragCoord);\n    \n    \n    \n    vec2 cj = vec2(-.5 + abs(cos(iTime * .5)) * .25, sin(iTime) * .1);\n    vec2 zj = c;\n    \n    zj = ct_cmul(zj, zj) + cj;\n    zj = ct_cmul(zj, zj) + cj;\n    //zj = ct_cmul(zj, zj) + cj;\n    //zj = ct_cmul(zj, zj) + cj;\n    \n    c = zj;\n    \n    \n    \n    vec3 dis = vec3( 0, 0, 5 );\n    vec3 origin = vec3( 0.0, 0.0, 0.0 );\n    mat3 cam_mat = ct_cam( dis, origin, 0.0 );\n    vec3 rai_vec = cam_mat * normalize( vec3(c.xy, 2.0) );\n    \n    // Exec...\n    vec4 color = vec4(ct_main(dis, rai_vec), 1.);\n    \n    fragColor = color;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdfBzf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdffD2", "name": "static emergence ", "author": "gurudevbk", "description": "bzzzzzt", "tags": ["random", "static", "tangent", "emergent"], "likes": 1, "viewed": 59, "date": "1589090324", "time_retrieved": "2024-06-20T20:07:02.864512", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    float thickness = 0.1;\n    float t_usec = (iTime) * .0001;\n    vec2 origin = vec2(.2)+t_usec;\n    const float pi = 3.14159265;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y - 0.4;\n    uv.x -= .29;\n    \n    // rotation matrix for funzies\n    mat2 rot = mat2(sin(t_usec*10.), cos(t_usec*10.),\n                    -cos(t_usec*10.), sin(t_usec*10.));\n    \n    uv = rot * uv;\n    uv *= length(uv-origin);\n   \n    //uv = mat2(sin(t_usec), cos(t_usec), sin(t_usec), -cos(t_usec)) * uv;\n    float radius = .07*atan(uv.x*uv.y,pow(t_usec,3.))/pow(sin(t_usec),2.4);\n    \n    vec3 col = vec3(t_usec+.1, .5*(cos(iTime)*.5+.5),.5); //color \n    vec3 color_scale = length(uv-radius)*col.rgb;\n    \n    col.rgb = 0.5*sin(length(uv*radius)+col.rgb);\n    \n    col *= length(uv*origin)*color_scale;\n    \n    // Time varying pixel color\n  \t//col += 0.4*cos(iTime)+col;\n   \tcol.g += sin(iTime*.02);\n    col.r -= .2*cos(iTime*.02);\n    col.g += pow(sin(iTime*.2),2.);\n\n\n    col.g += atan(sin(iTime),abs(cos(iTime)));\n    \n    col.rgb += mix(col.rbg, col.bgr, length(uv-origin)/2.);\n    \n   // col.g *= 0.05;\n\n    // Output to screen\n    fragColor = vec4(col,1.-length(uv-origin));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdffD2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdffWX", "name": "12 balls", "author": "akent4000", "description": "12 balls", "tags": ["raymarch"], "likes": 1, "viewed": 46, "date": "1589162664", "time_retrieved": "2024-06-20T20:07:02.864512", "image_code": "#define Iterations 100\n#define SafeDist 0.01\n#define MaxDist 50.\n#define NumberOfObj 19\n#define CamPos vec3(0, 2.5, -12)\n//#define LightPos vec3(cos(iTime*2.)*10. ,5, sin(iTime*2.)*10.)\n#define LightPos vec3(0., sin(iTime)*2.+5., -10.)\n//#define CamRotate vec3(1, 2, 1);\n\nfloat DistCube(vec3 p, vec4 s)\n{\n    vec3 q = abs(p - s.xyz) - s.w;\n    return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat DistSphere(vec3 p, vec4 sphere/*x pos, y pos, z pos, r*/)\n{\n    return length(p-sphere.xyz)-sphere.w;\n}\n\nfloat DistPlane(vec3 p, float y)\n{\n \treturn p.y - y;   \n}\n\n\nfloat Soft_min(float a, float b, float r)\n{\n    float e = max(r - abs(a - b), 0.0);\n    return min(a, b) - e*e*0.25 / r;\n}\n\nfloat Dist(vec3 p)\n{\n    float Dists[NumberOfObj];\n    Dists[0] = DistPlane(p, 0.);\n    Dists[1] = DistSphere(p, vec4(sin(iTime)*3., sin(iTime*3.)+1., cos(iTime)*3., 1));\n    Dists[2] = DistSphere(p, vec4(sin(iTime+1.0472)*3., sin(iTime*3.+1.0472) +1., cos(iTime+1.0472)*3.  ,1));\n    Dists[3] = DistSphere(p, vec4(sin(iTime+2.0944)*3., sin(iTime*3.+2.0944)+1., cos(iTime+ 2.0944)*3. ,1));\n    Dists[4] = DistSphere(p, vec4(sin(iTime+3.14159)*3.,sin(iTime*3.+3.14159)+1.,cos(iTime+ 3.14159)*3.,1));\n    Dists[5] = DistSphere(p, vec4(sin(iTime+4.18879)*3.,sin(iTime*3.+4.18879)+1.,cos(iTime+ 4.18879)*3.,1));\n    Dists[6] = DistSphere(p, vec4(sin(iTime+5.23599)*3.,sin(iTime*3.+5.23599)+1.,cos(iTime+ 5.23599)*3.,1));\n    Dists[7] = DistSphere(p, vec4(cos(iTime)*3., cos(iTime*3.) + 2., sin(iTime)*3., 1));\n    Dists[8] = DistSphere(p, vec4(cos(iTime+1.0472)*3., cos(iTime*3.+1.0472)+ 3., sin(iTime+1.0472)*3.  ,1));\n    Dists[9] = DistSphere(p, vec4(cos(iTime+2.0944)*3., cos(iTime*3.+2.0944)+ 3., sin(iTime+ 2.0944)*3. ,1));\n    Dists[10] =DistSphere(p, vec4(cos(iTime+3.14159)*3.,cos(iTime*3.+3.14159)+ 3.,sin(iTime+ 3.14159)*3.,1));\n    Dists[11] =DistSphere(p, vec4(cos(iTime+4.18879)*3.,cos(iTime*3.+4.18879)+ 3.,sin(iTime+ 4.18879)*3.,1));\n    Dists[12] =DistSphere(p, vec4(cos(iTime+5.23599)*3.,cos(iTime*3.+5.23599)+ 3.,sin(iTime+ 5.23599)*3.,1));\n    Dists[13] = DistSphere(p, vec4(sin(iTime)*3., sin(iTime*3.), cos(iTime)*3., 1));\n    Dists[14] = DistSphere(p, vec4(sin(iTime+1.0472)*3., sin(iTime*3.+1.0472) +5., cos(iTime+1.0472)*3.  ,1));\n    Dists[15] = DistSphere(p, vec4(sin(iTime+2.0944)*3., sin(iTime*3.+2.0944)+5., cos(iTime+ 2.0944)*3. ,1));\n    Dists[16] = DistSphere(p, vec4(sin(iTime+3.14159)*3.,sin(iTime*3.+3.14159)+5.,cos(iTime+ 3.14159)*3.,1));\n    Dists[17] = DistSphere(p, vec4(sin(iTime+4.18879)*3.,sin(iTime*3.+4.18879)+5.,cos(iTime+ 4.18879)*3.,1));\n    Dists[18] = DistSphere(p, vec4(sin(iTime+5.23599)*3.,sin(iTime*3.+5.23599)+5.,cos(iTime+ 5.23599)*3.,1));\n    \n    float minD = Dists[0];\n    for(int i = 0; i < NumberOfObj - 1; i++)\n    {\n        minD = Soft_min(minD, Dists[i + 1],1.);\n    }\n    return minD;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n    float dO = 0.;\n    for(int i = 0; i < Iterations; i++)\n    {\n        vec3 p = ro + dO*rd;\n        float ds = Dist(p);\n        dO += ds;\n        if(ds < SafeDist || dO > MaxDist)\n        {\n            break;\n        }\n    }\n    return dO;\n    \n}\nvec3 GetNormal(vec3 p) {\n\tfloat d = Dist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        Dist(p-e.xyy),\n        Dist(p-e.yxy),\n        Dist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = LightPos;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SafeDist*2., l);\n    if(d<length(lightPos-p)) dif *= .5;\n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    vec3 col = vec3(0);\n    vec3 ro = CamPos;\n\tvec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    float d = RayMarch(ro, rd);\n    vec3 p = ro+d*rd;\n    float dif = GetLight(p);\n    col = vec3(dif);\n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdffWX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdffzB", "name": "Failed tiling attempt", "author": "Domenicobrz", "description": "Tiling some octahedrons for my CG uni class ", "tags": ["raymarching", "raymarch", "tiling", "octahedron"], "likes": 5, "viewed": 102, "date": "1588513454", "time_retrieved": "2024-06-20T20:07:02.870616", "image_code": "//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3) {\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat noise(float p){\n\tfloat fl = floor(p);\n  float fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\n\nfloat sdSphere(vec3 center, float rad, vec3 p) {\n    return length(p - center) - rad;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdOctahedron( vec3 p, float s) {\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat sdOctahedronSquash( vec3 p, float s, float ys) {\n  p = abs(p) * vec3(1.0, ys, 1.0);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat scene(vec3 p, float type) {\n    float modul = 4.0;\n    float hmod  = modul * 0.5;\n    \n    vec3 realp = p;\n    \n    p.y += noise(sin(p.x * 0.01 + iTime * 0.4) * 10.0) * 2.0; \n    p.z += noise(sin(p.z * 0.01 + iTime * 0.4) * 10.0) * 2.0; \n    \n    \n    \n    vec3 octahedron_index = (p + hmod) - mod((p+hmod), modul);\n    octahedron_index.y = 0.0;\n    // vec3 octahedron_index = p - mod(p, modul);\n    // octahedron_index.y = 0.0;\n    \n    \n    float pt = (p.z + hmod) - mod((p.z + hmod), modul);\n    float pq = (p.x + 128.0 + hmod) - mod((p.x + 128.0 + hmod), modul);\n    \n    p.x = mod(p.x + hmod, modul) - hmod;\n    p.y = p.y;\n    p.z = mod(p.z + hmod, modul) - hmod;\n        \n    \n    \n    // float mint = sphere(vec3(0.0, 0.0, 8.0), 5.0, p);\n    // float octahedron_index = \n    float octahedron_height = noise(pt * 0.25 + pq * 0.25 + iTime * 0.2);\n    float octahedron  = sdOctahedronSquash(p, 2.0, octahedron_height * 2.0 + 0.4);\n    \n    \n    \n    \n    \n    \n    p = p + vec3(2.0, 0.0, 2.0);\n    p.x = mod(p.x + hmod, modul) - hmod;\n    p.y = p.y;\n    p.z = mod(p.z + hmod, modul) - hmod;\n    pt = (p.z + hmod) - mod((p.z + hmod), modul);\n    pq = (p.x + 128.0 + hmod) - mod((p.x + 128.0 + hmod), modul);\n    octahedron_height = noise(pt * 0.15 + pq * 0.15);\n    \n    float octahedron2 = sdOctahedronSquash(p, 2.0, octahedron_height * 2.0 + 0.4);\n    \n    \n    \n    \n    \n    \n    \n    \n    vec3 tp = realp;\n    tp.y += noise(iTime * 0.5 + octahedron_index.x * 17.0 + octahedron_index.z * 23.0) * 8.0;\n    float hmod2 = hmod * 1.2;\n    float modul2 = modul * 1.2;\n    tp.x = mod(tp.x + hmod2, modul2) - hmod2;\n    tp.y = tp.y - 8.0;\n    tp.z = mod(tp.z + hmod2, modul2) - hmod2;\n    float octahedron3 = sdOctahedronSquash(tp, 0.2, 0.5);\n    // remove octahedron at the center\n    if(length(realp.xz - vec2(0.0, 0.0)) < 0.5) octahedron3 = 999999.0;\n    \n    \n    \n    \n    \n    \n    float plane      = p.y;\n    \n    float mint = opSmoothUnion(octahedron, octahedron2, sin(realp.x * 2.0 + iTime) * 0.5 + 0.5);\n    if(octahedron2 < mint) mint = octahedron2;\n    if(octahedron3 < mint) mint = octahedron3;\n    if(plane < mint) mint = plane;\n    \n    \n    float sphere = sdSphere(vec3(0.0, 2.0 + (sin(iTime) * 0.5 + 0.5) * 3.0, 0.0), 0.75, realp); \n    if(sphere < mint && type > 0.0) mint = sphere;\n    \n\treturn mint;\n}\n\n\nfloat shadowRay(vec3 ro, vec3 lightPos) {\n    float epsilon = 0.01;\n    float dist = length(lightPos - ro);\n    vec3 rd = normalize(lightPos - ro);\n    \n    \n    vec3 p = ro + rd * 0.15;\n    for(float i = 0.0; i < 50.0; i++) {\n        float t = scene(p, 0.0);\n  \n        if(t < 0.0) {\n            p += rd * t;\n            return 0.0;\n        }\n        if(abs(t) < epsilon) {\n            p += rd * t;\n            break;\n        }\n        \n        p += rd * t;\n    }\n    \n    float hitDist = length(p - ro);\n    if(dist - hitDist < 0.4) return 1.0;\n    return 0.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    \n  \n    \n    \n    vec2 ndv = (uv * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);\n    float fov = 1.5;\n    \n    vec3 target = vec3(0.0);\n    // vec3 ro = vec3(-8.0, 6.0, -6.0);\n    vec3 ro = vec3(sin(iTime * 0.2) * 4.0, 3.0, cos(iTime * 0.2) * 4.0);\n    float rot = 0.5;\n\t// vec3 ro = vec3(sin(rot) * 4.0, 3.0, cos(rot) * 4.0);\n\t\n    ro *= 3.0;\n    \n    \n    vec3 w  = normalize(target - ro);\n    vec3 u  = normalize(cross(w, vec3(0.0, 1.0, 0.0)));\n    vec3 v  = normalize(cross(u, w));\n        \n        \n    vec3 rd = normalize(vec3(ndv, 1.0 * fov)); \n    rd = w * rd.z + v * rd.y + u * rd.x;\n                        \n    vec3 col = vec3(0.0);\n    \n    float epsilon = 0.03;\n    vec3 lightPos = vec3(0.0, 2.0 + (sin(iTime) * 0.5 + 0.5) * 3.0, 0.0);\n    float diffuse = 1.0;\n    vec3 n;\n    \n    vec3 p = ro;\n    for(float i = 0.0; i < 50.0; i++) {\n        float t = scene(p, 1.0);\n        \n        if(abs(t) < epsilon) {\n            \n            float px = scene(p + vec3(+epsilon, 0.0, 0.0), 1.0);\n            float py = scene(p + vec3(0.0, +epsilon, 0.0), 1.0);\n            float pz = scene(p + vec3(0.0, 0.0, +epsilon), 1.0);\n            \n            \n            n = normalize(vec3(px - t, py - t, pz - t));\n            // n.z = -n.z;\n            \n            vec3 lightDir = normalize(lightPos - p);\n            \n            float attenuation = 1.0 / (pow(length(lightPos - p), 2.0)); \n            \n            diffuse = max(dot(n, lightDir), 0.0) * attenuation * 10.0;\n          \n            //p = p + rd * t * 0.85;\n            break;\n        } else {\n        \tp = p + rd * t * 0.85;\n        }\n        \n        if(i > 28.0) {\n           diffuse = 0.0;\n        }\n    }\n    \n    \n    // shadow ray\n    float srr = max(shadowRay(p, lightPos), 0.075);\n    col = vec3(diffuse * srr + 0.0025) * vec3(1.0, 0.6, 0.2);\n    col *= texture(iChannel1, p.xz * 0.05 + p.y * 0.01).rgb * 0.75;\n    \n\t\n    if(length(lightPos - p) < 1.2) {\n       col *= vec3(2030.0);\n    }\n    \n    \n    float gamma = 2.2;\n    float exposure = 1.5;\n\tcol *= pow(2.0, exposure);\n    col = max(vec3(0.), col - vec3(0.004));\n\tcol = (col * (6.2 * col + .5)) / (col * (6.2 * col + 1.7) + 0.06);\n\tcol = pow(col, vec3(1. / gamma));\n\t    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdffzB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdjBDh", "name": "mandelb", "author": "workingclasshacker", "description": "simple implmentation", "tags": ["fractal"], "likes": 2, "viewed": 229, "date": "1589978932", "time_retrieved": "2024-06-20T20:07:02.870616", "image_code": "mat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),sin(_angle),cos(_angle));\n}\n\n#define MAXITER 810\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv = uv*2.5-vec2(.5,0.);\n    float t = iTime * .15;\n\tfloat angle = t;    \n    uv *= rotate2d(angle);\n    float scale = 1.5;\n    uv *= 1.-sin(scale);\n    uv.x -= scale * (sin(scale)/2.+.03);\n    uv.y -= scale * (sin(scale)/5.-.30);\n\tvec2 c = uv;\n    vec2 z = c;\n    int escape = 0;\n    for(int i = 0;i<MAXITER;i++){\n\t\tfloat tempx = z.x*z.x - z.y * z.y + c.x;\n        z.y = 2. * z.x * z.y + c.y;\n        z.x = tempx;\n        if(length(z)>2.){\n           escape = i;\n            break;\n        }\n    }\n    \n    float sl = (float(escape) + log2(length(z)))/float(MAXITER);\n    vec3 col = vec3(sin(sl)*2.*cos(iTime), sin(sl)/3.,cos(sl)/4.);\n    col += sl;\n    if(length(z)<2.0){\n      col = vec3(1.);   \n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdjBDh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdjBRd", "name": "Lightning drop gravity", "author": "TAKUSAKU", "description": "Lightning drop gravity", "tags": ["drop", "lightning", "gravity"], "likes": 6, "viewed": 179, "date": "1590641356", "time_retrieved": "2024-06-20T20:07:02.870616", "image_code": "// 2D rotate\nmat2 rotate(in float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\n// noise background is baced on æææ°VIP:\n// https://www.shadertoy.com/view/4sVBDm\n// ----------------------------------------- \n//noise background\nconst float noiseIntensity = 2.8;\nconst float noiseDefinition = 0.6;\nconst vec2 glowPos = vec2(-2., 0.);\n\nfloat random(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(-0.940,-0.880))) * 43758.5453);\n}\n\nfloat noise( in vec2 p ){\n    p*=noiseIntensity;\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\tvec2 u = f*f*(3.-2.*f);\n    return mix( mix( random( i + vec2(0.0,0.0) ), \n                     random( i + vec2(1.0,0.0) ), u.x),\n                mix( random( i + vec2(0.0,1.0) ), \n                     random( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat fbm( in vec2 uv ){\t\n\tuv *= 5.;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    float f  = 0.5*noise( uv ); uv = m*uv;\n    f += 0.2500*noise( uv ); uv = m*uv;\n    f += 0.1250*noise( uv ); uv = m*uv;\n    f += 0.0625*noise( uv ); uv = m*uv;\n    \n\tf = 0.5 + .5*f;\n    return f;\n}\n\nvec3 bg(vec2 uv ){\n    float velocity = iTime * 0.5;\n    float intensity = sin(uv.x*9.*sin(iTime*0.1)+velocity*3.)*noise(uv*2.)*3.0+.3;\n    uv.y -= 4.;\n    vec2 bp = uv+glowPos;\n    uv *= noiseDefinition;\n\n    //ripple\n    float rb = fbm(vec2(uv.x*.5-velocity*.03, uv.y))*.1;\n    uv += rb;\n\n    //coloring\n    float rz = fbm(uv*.9+vec2(velocity*.35, 0.0));\n    rz *= dot(bp*intensity,bp);\n\n    //bazooca line\n    rz *= sin(uv.x*0.1+velocity*0.8);\n    \n    //lightning\n    rz *= 5.*sin(uv.x*0.1+velocity*sin(iTime));\n    \n    vec3 bgColor = vec3(cos(iTime),0.45 * sin(iTime*0.2),sin(iTime*0.3));\n    vec3 col = bgColor/(.1-rz);\n    \n    return sqrt(abs(col));\n}\n// ----------------------------------------- \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Wide-angle lens is baced on Menger Sponge Variation\n    // https://www.shadertoy.com/view/ldyGWm\n    vec3 st = (vec3(2.0 * fragCoord - iResolution.xy, iResolution.y));\n    st = normalize(vec3(st.xy, sqrt(max(st.z * st.z - dot(st.xy, st.xy) *4.*sin(iTime*0.5),0.)))); \n    \n    st.xy *= rotate(iTime*0.5);\n    \n    vec3 bgCol = bg(st.xy)*(1.9-abs(st.y*2.));\n       \n\tfragColor = vec4(bgCol, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdjBRd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdjBRy", "name": "My 2D Clouds", "author": "takahiroando", "description": "Simplified cloud shader with my learning memo in comments\nbased on: https://www.shadertoy.com/view/4tdSWr", "tags": ["fractal", "noise", "clouds", "fbm"], "likes": 9, "viewed": 709, "date": "1590315495", "time_retrieved": "2024-06-20T20:07:03.410034", "image_code": "const float cloudscale = 2.5; // 1.1\nconst float speed = 0.03;\nconst float clouddark = 0.5;\nconst float cloudlight = 0.3;\nconst float cloudcover = 0.2;\nconst float cloudalpha = 8.0;\nconst float skytint = 0.5;\nconst vec3 skycolour1 = vec3(0.2, 0.4, 0.6);\nconst vec3 skycolour2 = vec3(0.4, 0.7, 1.0);\n\nconst mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\n// <personal favorite noise funcs>\nfloat hash(vec2 uv) {\n\treturn fract(sin(dot(uv, vec2(123.45, 678.9))) * 987654.321);\n}\n\nfloat noise(vec2 uv) {\n\tvec2 i = floor(uv);\n\tvec2 f = fract(uv);\n\tvec2 b = smoothstep(0.0, 1.0, f);\n\treturn 2.0 * mix(\n\t\tmix(hash(i), hash(i + vec2(1.0, 0.0)), b.x),\n\t\tmix(hash(i + vec2(0.0, 1.0)), hash(i + vec2(1.0, 1.0)), b.x), b.y) - 1.0;\n}\n// </personal favorite noise funcs>\n\n// common part of FBMs...\nfloat fbm(bool do_abs, vec2 n, float amp_init, float amp_step, float q, float base_octave) {\n    float time = iTime * speed * base_octave;\n    \n    n *= vec2(iResolution.x/iResolution.y,1.0) * cloudscale * base_octave;\n    n -= q - time;\n    \n\tfloat total = 0.0, amplitude = amp_init;\n\tfor (int i = 0; i < 7; i++) {\n        float v = noise(n) * amplitude;\n        v = do_abs ? abs(v) : v;\n        \n\t\ttotal += v;\n        \n\t\tn = m * n + time;\n\t\tamplitude *= amp_step;\n\t}\n\treturn total;\n}\n\nfloat calcF(vec2 p, float q) {\n    //ridged noise shape\n\tfloat r = fbm(true, p, 0.8, 0.7, q, 1.0);\n\n    //noise shape\n\tfloat f = fbm(false, p, 0.7, 0.6, q, 1.0);\n    \n    f *= r + f;\n    f = cloudcover + cloudalpha*f*r;\n    return f;\n}\n\nfloat calcC(vec2 p, float q) {\n    //noise colour\n    float c = fbm(false, p, 0.4, 0.6, q, 2.0);\n    \n    //noise ridge colour\n    float c1 = fbm(true, p, 0.4, 0.6, q, 3.0);\n\t\n    return c + c1;\n}\n\n// -----------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = fragCoord.xy / iResolution.xy;\n    \n    // f, c, q are not sure yet...\n    \n    // q is used to subtract from uv with time in fbm()...???\n    float q = fbm(false, p, 0.1, 0.4, 0.0, 1.0);\n        \n    // f part(?)\n\tfloat f = calcF(p, q);\n    \n    // c part(color?)\n    float c = calcC(p, q);\n    \n    // sky color is just a vertical screen gradietion\n    vec3 skycolour = mix(skycolour2, skycolour1, p.y);\n    vec3 cloudcolour = vec3(1.1, 1.1, 0.9) * clamp((clouddark + cloudlight*c), 0.0, 1.0);\n\n    // The key strategy of shader would be here:\n    // mix sky color and cloud color by (f + c).\n    // The cloud color is calculated from darken sky color (by skytint) + cloud color.\n    // Not sure f + c meaning yet...\n    vec3 result = mix(skycolour, clamp(skytint * skycolour + cloudcolour, 0.0, 1.0), clamp(f + c, 0.0, 1.0));\n    \n\tfragColor = vec4( result, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdjBRy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdjBzw", "name": "ShATI - Flamme", "author": "Flopine", "description": "My former school named ATI decided to launch an everyday challenge from 4th may to 24th may, here is the 14th subject: flame :)\nInspired by Super Mario Odyssey", "tags": ["raymarching", "fire", "modeling", "glow", "mario"], "likes": 12, "viewed": 155, "date": "1589754532", "time_retrieved": "2024-06-20T20:07:04.315121", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n// Shader made for Everyday ATI challenge\n\n\n#define time iTime\n#define PI acos(-1.)\n\n// taken from YX here : https://www.shadertoy.com/view/tdlXW4\n// rough shadertoy approximation of the bonzomatic noise texture\nvec4 texNoise(vec2 uv)\n{\n    float f = 0.;\n    f += texture(iChannel0, uv*.125).r*.5;\n    f += texture(iChannel0, uv*.25).r*.25;\n    f += texture(iChannel0, uv*.5).r*.125;\n    f += texture(iChannel0, uv*1.).r*.125;\n    f=pow(f,1.2);\n    return vec4(f*.45+.05);\n}\n\nfloat hash21(vec2 x)\n{return fract(sin(dot(x,vec2(32.6,13.4)))*1254.4);}\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat linedist(vec3 p, vec3 a, vec3 b) \n{\n    float k = dot(p-a, b-a)/dot(b-a,b-a);\n    return distance(p, mix(a, b, clamp(k, 0., 1.)));\n}\n\nfloat face, body; \nfloat g1=0.;\nfloat SDF (vec3 p)\n{\n    float r = 0.5;\n    float sy = 1.+sin(time*15.)*0.1+0.1;\n    float sxz = 1./sy;\n    vec3 resize = vec3(sxz,sy,sxz);\n    p.y +=r ;\n    p *= resize;\n    p.y -= r;\n    vec3 pp = p;\n\n    // corps\n\n    p.x -= texNoise(p.yz*0.1+time*0.5).r*0.1;\n    p.y += texNoise(p.xz*0.08+time*0.5).r*0.25;\n    float bd = length(p)-r; \n    // nez\n    p.x *= 0.8; \n    bd = min(bd,(length(p+vec3(0.,0.08,r*1.2))-0.12)/length(vec3(0.8,0.,0.)));\n\n\n    // yeux\n    p = pp;\n    p.x = abs(p.x)-0.15;\n    p.x *= 1.3;\n    float fd = length(p+vec3(0.,-0.07,r*.92))-0.1;\n\n    // sourcils\n    p = pp;\n    p.x = abs(p.x)-0.18;\n    p += vec3(0.,-0.28,r*0.9);\n    p.xz *= rot(PI/6.);\n    p.y += p.x*p.x*2.;\n    fd = min(fd,max(length(p.yz)-(0.01-sqrt(p.x*p.x+0.001)*0.15),abs(p.x)-0.2));\n\n    // moustache\n    p = pp;\n    p *= 1.1;\n    p.y += cos(p.x*3.)*0.2;\n    float line = linedist(p,vec3(-r,0.,-r),vec3(r,0.,-r))-(0.06-sqrt(p.x*p.x+0.001)*0.2) / 1.1;\n    p = pp;  \n    p *= 1.1;\n    p.x = abs(p.x);\n    float spheres = length(p+vec3(-0.35, 0.15, r))-0.05;\n    spheres = min(spheres,length(p+vec3(-0.22, 0.25, r))-0.05);\n    spheres = min(spheres,length(p+vec3(-0.08, 0.3, r))-0.05) / 1.1;\n    float mustache = smin(line, spheres, 0.15);\n    fd = min(fd, mustache);\n\n    body = bd/length(resize);\n    g1 += 0.001/(0.001+body*body);\n    face = fd/length(resize);\n\n    return min(body,face);\n}\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2(0.01,0.);\n    return normalize(SDF(p)-vec3(SDF(p-eps.xyy),SDF(p-eps.yxy),SDF(p-eps.yyx)));\n} \n\nfloat spec (vec3 rd, vec3 n, vec3 l)\n{\n    vec3 h = normalize(l-rd);\n    return pow(max(dot(h,n),0.),15.);\n}\n\nfloat bubble (vec2 uv, float r, vec2 offset)\n{\n    return smoothstep(r,r*0.9,length(uv+offset))*length(uv+offset);\n}\n\nvec3 background(vec2 uv)\n{\n    vec3 color = vec3(1.,0.5,0.8);\n    color += bubble(uv, 0.25+sin(time*1.2)*0.01, vec2(-0.2, -0.1));\n    uv.x = abs(uv.x)-.8;\n    color += bubble(uv, 0.2+sin(time)*0.01, vec2(0.5));\n    color += bubble(uv, 0.3+sin(time*1.5)*0.01, vec2(0.1, 0.3));\n    color += bubble(uv, 0.25+sin(time*1.2)*0.01, vec2(0.4, -0.4));\n    return color;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    float dither = hash21(uv);\n\n    vec3 ro = vec3(0.,0.,-2.2),\n        rd = normalize(vec3(uv,1.)),\n        p = ro,\n        l = vec3(1.,2.,-2.),\n        col = background(uv)*0.8;\n\n    float shad, d = 0.;\n    bool hit = false;\n\n    for (float i=0.; i<64.; i++)\n    {\n        d  = SDF(p);\n        if (d<0.01)\n        {\n            hit = true;\n            shad = i/64.;\n            break;\n        }   \n        d *= 0.9+dither*0.1;\n        p += d*rd;\n    }\n\n\n    if (hit)\n    {\n        float bo = body;\n        float fa = face;\n        vec3 n = getnorm(p);\n        float fre = pow(max(1.-dot(-rd,n),0.),1.);\n        if (d == bo) \n        {\n            col = mix(vec3(0.8,0.8, 0.1),vec3(0.8,0.2,0.), smoothstep(0.2,0.9,fre));\n            col += spec(rd, n, l)*(fre*2.);\n        }\n        if (d == fa) col = mix(vec3(0.05,0., 0.),vec3(0.8,0.1,0.),fre);\n    }\n    \n    col += g1*0.1*vec3(1.,0.1,0.01);\n    fragColor = vec4(sqrt(col),1.);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdjBzw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdjfRd", "name": "Circle_Inversion + smoothclamp", "author": "FabriceNeyret2", "description": "variant of lil_chickehh's  \"Circle_Inversion\"  [url]https://shadertoy.com/view/3s2fz3[/url]\nwith AA + golfing , eiffie's clamped inversion U / clamp(dot(U,U),.25,1.), changed into smoothclamp.", "tags": ["geometry", "2tweets", "golf"], "likes": 4, "viewed": 235, "date": "1590644409", "time_retrieved": "2024-06-20T20:07:04.452457", "image_code": "// Smoothclamp variant of \"Circle_Inversion\" by lil_chickehh. https://shadertoy.com/view/3s2fz3\n// There, I AA and golfed (sorry...) it,\n// and eiffie's suggested clamped inversion U / clamp(dot(U,U),.25,1.)\n// That I here turned to #def smoothclamp(v,a,b) ( a+(b-a)*smoothstep(a,b,v) )\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy,\n         U = ( u+u - R) / R.y;\n    U = cos(   21.*U / ( .3+smoothstep(.25,1.,dot(U,U)) )\n             + 16.*sin(iTime*.2+vec2(0,33))  );\n    U += U.y;\n    O += .5 + U.x/fwidth(U.x);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdjfRd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdjfRt", "name": "Over the Moon Pt. 2 :P", "author": "hopeliz", "description": "Followed The Art of Code's \"Over the Moon\" tutorial: https://youtu.be/XaiYKkxvrFM\nCreated for Day 17 of a 100 Days of Shaders and Textures project", "tags": ["trees", "pretty", "randomness"], "likes": 5, "viewed": 174, "date": "1590642400", "time_retrieved": "2024-06-20T20:07:04.452457", "image_code": "#define S(a, b, t) smoothstep(a, b, t)\n\nfloat createTaperBox(vec2 point, float bottomWidth, float topWidth, float yBottom, float yTop, float blur) {\n    // Bottom edge    \n    float m = S(-blur, blur, point.y - yBottom);\n    // Top edge\n    m *= S(blur, -blur, point.y - yTop);\n    // Sides, mirrored\n    point.x = abs(point.x);\n    \n    float w = mix(bottomWidth, topWidth, (point.y - yBottom) / (yTop - yBottom));\n    m *= S(blur, -blur, point.x - w);\n    \n    return m;\n}\n\nvec4 createTree(vec2 uv, vec3 color, float blur) {\n    \n    // --- Trunk ---\n    float m = createTaperBox(uv, 0.03, 0.03, -0.05, 0.25, blur);\n    // --- Canopy 1 ---\n    m += createTaperBox(uv, 0.2, 0.1, 0.25, 0.5, blur);\n    // --- Canopy 2 ---\n    m += createTaperBox(uv, 0.15, 0.05, 0.5, 0.75, blur);\n    // --- Top ---\n    m += createTaperBox(uv, 0.1, 0.0, 0.75, 1.0, blur);\n    \n    float shadow = createTaperBox(uv - vec2(0.2, 0.0), 0.1, 0.5, 0.15, 0.25, blur);\n    shadow += createTaperBox(uv + vec2(0.25, 0.0), 0.1, 0.5, 0.45, 0.5, blur);\n    shadow += createTaperBox(uv - vec2(0.2, 0.0), 0.1, 0.5, 0.7, 0.75, blur);\n    color -= shadow * 0.8;\n    //m = 1.0;\n    \n    return vec4(color, m);\n}\n\nfloat GetHeight(float x) {\n    return sin(x * 0.435) + sin(x) * 0.3;\n}\n\nvec4 createLayer(vec2 uv, float blur) {\n    vec4 color = vec4(0.0);\n    \n    float id = floor(uv.x);\n    float n = fract(sin(id * 256.12) * 6854.3) * 2.0 - 1.0;\n    float x = n * 0.3;\n    float y = GetHeight(uv.x);\n    \n    // Ground\n    float ground = S(blur, -blur, uv.y + y);\n    color += ground;\n    \n    y = GetHeight(id + 0.5 + x);\n    \n    uv.x = fract(uv.x) - 0.5;\n    vec4 tree = createTree((uv - vec2(x, -y)) * vec2(1.0, 1.0 + n * 0.25), vec3(1.0), blur);\n    \n    color = mix(color, tree, tree.a);\n    color.a = max(ground, tree.a);\n    return color;\n}\n\nfloat Hash21(vec2 point) {\n    point = fract(point * vec2(1462.34, 1026.75));\n    point += dot(point, point + 864.23);\n    \n    return fract(point.x * point.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    // Move origin to the center\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 mouse = (iMouse.xy / iResolution.xy) * 2.0 - 1.0;\n    float time = iTime * 0.3;\n    \n    \n    //uv.x += iTime * 0.1;\n\t//uv.y += 0.5;\n    //uv *= 5.0;\n    \n    float blur = 0.005;\n    \n    // Initialize color\n    vec4 color = vec4(0.0);\n    vec4 layer;\n    \n    color *= 0.0;\n    float twinkle = dot(length(sin(uv + time)), length(cos(uv * vec2(22.0, 6.7) - time * 3.0)));\n    twinkle = sin(twinkle * 10.0) * 0.5 + 0.5 * 4.5;\n    \n    float dawn = S(-0.75, 0.4, -uv.y);\n    \n    float stars = pow(Hash21(uv), 60.0 * twinkle);\n    color += stars;\n    color.rgb -= vec3(0.5, 0.9, 0.1);\n    color += dawn;\n    \n    //float moon = S(0.01, -0.01, length(uv + vec2(-0.65, -0.275)) - 0.1);\n    float moon = S(0.0075, -0.0035, length(uv - vec2(0.47, 0.29)) - 0.1);\n    moon *= S(-0.075, 0.005, length(uv - vec2(0.43, 0.325)) - 0.175);\n    color.rgb += vec3(0.6);\n    color += moon;\n    \n    for (float i = 0.0; i < 1.0; i += 1.0 / 7.0) {\n        float scale = mix(10.0, 1.0, i);\n        blur = mix(0.02, 0.005, i);\n    \tlayer = createLayer(uv * scale + vec2(time + i * 50.0, i) - mouse, blur);\n        layer.rgb *= (1.0 - i) * vec3(0.3, 0.5, 1.0) * 1.2;\n        color = mix(color, layer, layer.a);\n    }\n    \n    layer = createLayer(uv + vec2(time , 1.0) - mouse, blur * 3.0);\n    color = mix(color, layer * 0.002, layer.a);\n    \n    float thickness = 1.0 / iResolution.y;\n    \n    \n    \n    // See axes\n    //if (abs(uv.x) < thickness) { color.g = 1.0; }\n    //if (abs(uv.y) < thickness) { color.r = 1.0; }\n\n    // Output to screen\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdjfRt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdjfWK", "name": "Quadratic Bezier Curve", "author": "yp3y5akh0v", "description": "Quadratic Bezier Curve. Time complexity O(n), where n is # of points in curve\n\nPrevious work: https://www.shadertoy.com/view/WdjfWV", "tags": ["2d", "bezier", "curve", "quadratic"], "likes": 2, "viewed": 118, "date": "1590883179", "time_retrieved": "2024-06-20T20:07:04.452457", "image_code": "#define N 40.\n#define R iResolution.xy\n#define M iMouse.xy\n#define t iTime\n#define T (0.5 + 0.5 * sin(t))\n#define D(p) (((p) - 0.5 * R) / R.y)\n#define inf 1e32\n\nfloat distToV(vec2 p, vec2 o, vec2 v) {\n    vec2 op = p - o;\n    vec2 ep = op - v;\n    float d = length(ep - dot(ep, v) / dot(v, v) * v);\n    if (dot(op, v) < 0.) {\n        d = length(op);\n    }    \n    if (dot(ep, -v) < 0.) {\n        d = length(ep);\n    }\n    return d;\n}\n\nvec2 QuadraticBezier(vec2 a, vec2 b, vec2 c, float q) {\n    vec2 qab = a + q * (b - a);\n    vec2 qbc = b + q * (c - b);    \n    return qab + q * (qbc - qab);\n}\n\nvoid mainImage(out vec4 o, in vec2 p)\n{\n    p = D(p);\n    vec2 m = D(M);    \n    vec2 a = vec2(-0.6, -0.3);\n    vec2 b = vec2(m.x, m.y);\n    vec2 c = vec2(0.6, -0.3);\n    float s = inf;\n    \n    for (float i = 1.; i <= N; i++) {\n        vec2 qb0 = QuadraticBezier(a, b, c, (i - 1.) / N);\n        vec2 qb1 = QuadraticBezier(a, b, c, i / N);\n        float d = distToV(p, qb0, qb1 - qb0);\n        s = min(s, d);\n    }\n    \n    vec2 tab = a + T * (b - a);\n    vec2 tbc = b + T * (c - b);\n    vec2 tr = tab + T * (tbc - tab);\n    float dab = distToV(p, a, tab - a);\n    float dbc = distToV(p, b, tbc - b);\n    float dr = distToV(p, tab, tbc - tab);\n    \n    o = vec4(0.002 / s);\n    o += vec4(0.003 / dab, 0.003 / dbc, 0.003 / dr, 0.);\n    o += vec4(0.004 / length(p - tr));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdjfWK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdjfWR", "name": "Displacement on sphere", "author": "kp1197", "description": "This is just me getting my toes wet again after not doing this for several years.", "tags": ["basicbeginner"], "likes": 1, "viewed": 123, "date": "1589859076", "time_retrieved": "2024-06-20T20:07:04.458527", "image_code": "const int MARCHES = 100;\nconst float EPS = 0.00001;\nconst vec2 EPS_VEC = vec2(EPS,0.);\nconst vec3 LIGHT_DIR = vec3(-0.1,0.5,-0.5);\n\n\nfloat dot2(vec2 a, vec2 b) {\n\treturn (a.x * b.x + a.y * b.y);\n}\n\nfloat dot3(vec3 a, vec3 b) {\n\treturn (a.x * b.x) + (a.y * b.y) + (a.z * b.z);\n}\n\nvec3 sphereCenter(float time) {\n    return vec3(0.,cos(0.5*time),5.) + vec3(sin(time),0.,2.*cos(0.5*time));\n}\n\nfloat harmonics(float time) {\n\treturn floor(4.*mod(time,5.));\n}\n\nfloat time2(float p) {\n    return 0.8 * sin(p);\n}\n\nfloat time() {\n    return 0.5 * iTime + time2(iTime + time2(iTime+ time2(iTime)));\n}\n\n\n\nfloat displacement(vec3 pos, float t) {\n    vec3 SPHERE_CENTER = sphereCenter(t);\n    vec3 relPos = pos - SPHERE_CENTER;\n    float theta = atan(relPos.y, relPos.x);\n    float phi = atan(dot2(relPos.xy, relPos.xy), relPos.z);\n    \n    float harmonics_1 = harmonics(floor(t));\n    float harmonics_2 = harmonics(floor(t)+1.);\n    \n    float displacement1 = sin(harmonics_1*theta) * sin(harmonics_1*phi);\n    float displacement2 = sin(harmonics_2*theta) * sin(harmonics_2*phi);\n    \n    \n    float alpha = fract(t);\n    return mix(displacement1, displacement2, alpha);// smoothstep(displacement1, displacement2, fract(iTime));\n}\n\n\n\nfloat _dist(vec3 pos, float t) {\n    vec3 SPHERE_CENTER = sphereCenter(t);\n    vec3 relPos = pos - SPHERE_CENTER;\n    float disp1 = displacement(pos, t);\n\treturn length(relPos) - 0.5 + 0.2* (disp1);\n}\n\nfloat dist(vec3 pos) {\n\t//pos = mod(pos, 50.);\n    float t = time();\n    return _dist(pos, t);\n}\n\n\n\n\nvec3 normal(vec3 pos) {\n    \n    float dx = dist(pos + EPS_VEC.xyy) - dist(pos - EPS_VEC.xyy);\n    float dy = dist(pos + EPS_VEC.yxy) - dist(pos - EPS_VEC.yxy);\n    float dz = dist(pos + EPS_VEC.yyx) - dist(pos - EPS_VEC.yyx);\n    return normalize(vec3(dx,dy,dz));\n}\n\n\nvec3 shade(vec3 pos, vec3 dir, float t) {\n    //return vec3(length(normal(pos)));\n    //return length(normal(pos));\n\t//return vec3(dot3(normal(pos), LIGHT_DIR));\n    vec3 normal_vec = normal(pos);\n    float shade = dot3(normal_vec, LIGHT_DIR);\n    vec3 dir_to_sphere_center = normalize(pos - sphereCenter(t));\n    float mat_blend = dot3(normal_vec, dir_to_sphere_center);\n    return shade * vec3(sin(mat_blend)*cos(mat_blend), sin(mat_blend), cos(mat_blend));\n    //return vec3(shade, shade, 1.-fract(iTime));\n}\n\nvec3 march(vec3 pos, vec3 dir) {\n    float t = time();\n    float d = 0.;\n    float step_frac = .9;\n    int max_marches = MARCHES;\n    for(int i = 0; i < MARCHES; i++) {\n        d = dist(pos);\n        if (d < EPS) {\n            return shade(pos,dir,t);\n        }\n        step_frac = max(0.2,min(1.,d));\n    \tpos.xyz += dir * d * step_frac;\n    }\n    return vec3(0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xx - vec2(0.5, 0.5*iResolution.y/iResolution.x);\n\t\n    vec3 pos = vec3(uv.xy, 1.0);\n    vec3 dir = normalize(pos);\n    \n    vec3 col = march(pos, dir);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdjfWR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdjfzy", "name": "Experiment all. shape ", "author": "Stenator", "description": "some shape", "tags": ["shape"], "likes": 0, "viewed": 20, "date": "1590321297", "time_retrieved": "2024-06-20T20:07:04.858748", "image_code": "\n\n vec3 v_normal;\n vec2 v_texcoord;\n\n\n//fonction rotate\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat croix (vec2 pos) {\n\nfloat epaisseur = 0.008;\nfloat x= step(abs(pos.x),epaisseur);\nfloat y= step(abs(pos.y),epaisseur);\nreturn x + y;\n}\n\n\n\nfloat fleur(vec2 uv,float rayon) {\n\nvec2 pos = vec2(0.5)-uv;\nfloat a = atan(pos.x,pos.y) *4. +7.85;\n\nfloat distan =  distance(vec2 (0.5), uv);\nrayon *= abs(cos(a))*0.15 +0.5;  \n\nfloat fleur = step(rayon , distan);\nfleur += croix(pos* rotate2d(0.785)) +croix(pos); // on soustrait avec les croix\n\nreturn fleur;\n}\n\nvec2 impair (vec2 uv) {  vec2 impair = vec2(1.);\n impair.y = step(1.,mod(uv.y,2.)); \n impair.x= step(1.,mod(uv.x,2.));\n\n\nreturn impair; }\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 uv = gl_FragCoord.xy /iResolution.xy;\n    \n    \n   \n     float a = atan(uv.x,uv.y);\n     a +=  cos(iTime+70.) * (1.-a)  ;\n     \n     \n    uv.x += 0.5;\n    vec2 uvfract = uv* 10.;\n    vec2 impair= impair(uvfract);\n    uv.x = uv.x+ 0.3*iTime * impair.y;\n    \n    uv= fract(uv*10.);\n  \n    \n    \n    \n    vec3 color= vec3(fleur(uv, 0.6 * cos(iTime)*a));\n    fragColor = vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdjfzy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdjyWK", "name": "Study about procedural warping", "author": "D4v1D", "description": "Freely inspired by https://www.shadertoy.com/view/MdSXzz\nWill be a work in progress for long time, as a study about procedural shaders\n// Created by inigo quilez - iq/2014\n// License Creative Commons Attribution-NonComm", "tags": ["procedural", "2d", "warping"], "likes": 3, "viewed": 120, "date": "1589475105", "time_retrieved": "2024-06-20T20:07:05.106977", "image_code": "const mat2 m = mat2(2.1,2.1,3.9,2.7);\nfloat hash( vec2 p ) { float h = dot(p,vec2(1.,1.)); return -1.0+2.0*fract(sin(h)*777.); }\n\nfloat noise( in vec2 p) \n{   vec2 i = floor(p); vec2 f = (fract(p)); vec2 u = f*f*(3.0-2.0*f);\n    return mix(mix( hash(i + vec2(0.0,0.0)), hash( i + vec2(1.0,.0)), u.x),\n                mix( hash( i + vec2(0.0,1.0)), hash( i + vec2(1.0,1.0)), u.x), u.y); }\n\nfloat fbm(vec2 p) \n{   float f = 0.1;\n          f -= 0.31 - noise(p);\n          p /= m*p/0.09; return f*1.4;}\n\nvec2 fbm2( in vec2 p) \n\t{return vec2( fbm(p.xy), fbm(p.xy) );}\n\nvec3 map( vec2 p )\n{   p *= 1.0; \n    float f = dot(fbm2(tan(.9)*(iTime - atanh(noise(sin(p)))-fbm2(0.9-(p - fbm2(3.0*p)))) ), vec2(0.5,0.8));\n    float bl = smoothstep(-.2,-0.9, sin(f));\n    float ti = smoothstep(.0,1.0, fbm((p*f)) ); // highlight color amount;\n    return mix( mix( vec3(0.0,0.1,.3), vec3(0.0,0.75,.6), bl ), vec3(.8,0.5,.40), ti );}     \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   vec2 p = (-iResolution.xy+5.*fragCoord.xy)/iResolution.y;\n    float e = 1.0;\n    vec3 colc = map(e+p);\n    float gc = dot(colc,vec3(30.));\n    vec3 cola = map(sin(p)/asinh(e)*.9 + dot(colc,vec3(.0)) - vec2(e,3.0));\n    float ga = dot(cola,vec3(6.1));\n    vec3 colb = map(p - vec2(4.0,e));\n \t \n    float gb = dot(colb,vec3(0.333)); //vec3 nor = normalize( vec3(ga-gc, e, gb-gc ) );\n    vec3 col = colc; // colc becomes col\n    col += vec3(0.1,0.1,.41)*.1*abs(.20*gc*ga-gb); // defines color for highlight in outlines/borders\n    vec2 q = -fragCoord.xy/iResolution.xy; // this traces screen coordinates;\n    col *= pow(1.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.1);  // canva vignette   \n   \n    fragColor = vec4(col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdjyWK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdlBRj", "name": "stereographic 3d", "author": "matthen", "description": "stereographic 3d", "tags": ["stereographic3d"], "likes": 14, "viewed": 408, "date": "1588662783", "time_retrieved": "2024-06-20T20:07:06.525243", "image_code": "struct Ray\n{\n\tvec3 org;\n\tvec3 dir;\n};\n\n// reference: http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdPlane( vec3 p, vec4 n )\n{\n\t// n must be normalized\n\treturn dot( p, n.xyz ) + n.w;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n\treturn length(p)-s;\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat opU( float d1, float d2 )\n{\n\treturn min(d1,d2);\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nvec3 translate( vec3 v, vec3 t )\n{\n\treturn v - t;\n}\n\nvec3 rotation(vec3 point, vec3 axis, float angle){\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    mat4 rot= mat4(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,0.0,0.0,1.0);\n    return (rot*vec4(point,1.)).xyz;\n}\n\nvec3 reverseProj(in vec3 p) {\n    float r = dot(p.xz, p.xz);\n    \n    return vec3(\n    \tp.x * (1. - (3. + r)/(9. + r)),\n        (3. * (3. + r))/(9. + r),\n        p.z * (1. - (3. + r)/(9. + r))\n    );\n}\n\nvec3 proj(in vec3 p) {\n    float yy = 3. - p.y;\n    return vec3(\n        p.x * (1. - p.y / yy),\n        3. * p.y / yy + p.y * (1. - p.y / yy),\n        p.z * (1. - p.y / yy)\n    );\n}\n\nvec3 sphericalCentre(in vec3 a, in vec3 b) {\n    vec3 centre = .5 * (a +  b);\n    centre -= vec3(0, 2, 0);\n    centre = normalize(centre);\n    centre += vec3(0, 2, 0);\n    return centre;\n}\n\nfloat makeHole(in vec2 p, in vec3 pos, in float d) {\n    vec3 p1 = reverseProj(vec3(p.x, 0., p.y + 0.5));\n    vec3 p2 = reverseProj(vec3(p.x, 0., p.y - 0.5));\n    vec3 centre = sphericalCentre(p1, p2);\n    float r = length(p1 - centre);\n    float hole = sdSphere(translate(pos, centre), 0.9 * r);\n    return opS(hole, d);\n}\n\nfloat makeCut(in vec3 p, in vec3 pos, in float d) {\n    vec3 pp = reverseProj(p);\n    vec3 np = vec3(0., 3., 0.);\n    vec3 centre = sphericalCentre(np, pp);\n    float r = length(pp - centre);\n    float hole = sdSphere(translate(pos, centre), r);\n    return opS(hole, d);\n    \n}\n\nfloat scene( in vec3 pos )\n{\n\tvec4 plane = vec4( 0.0, 1.0, 0.0, 0.0 ); // xyz, d\n\tfloat dPlane = sdPlane( pos, plane );\n    \n    pos -= vec3(0., 2., 0.);\n    float t = mod(iTime, 18.);\n    float theta = 0.9 * sin(2.09 * t);\n    theta *= (smoothstep(6., 7., t) - smoothstep(8., 9., t));\n    pos = rotation(pos, vec3(1., 0., 0.), theta);\n    pos += vec3(0., 2., 0.);\n    \n\n\tfloat sphere = sdSphere( translate( pos, vec3(0., 2., 0.)), 1. );\n\tfloat innerSphere = sdSphere( translate( pos, vec3(0., 2., 0.)), 0.99);\n\t\n    float hole1 = sdSphere( translate( pos, vec3(0., 3., 0.)), 0.6);\n    float hole2 = sdSphere( translate( pos, vec3(0., 1., 0.)), 0.6);\n    \n    float d =  opS(hole1, opS(innerSphere, sphere));\n    float w = 3.;\n    for (float i = -w; i <= w; i++) {\n        for (float j = -w; j <= w; j++) {\n        \td = makeHole(vec2(i, j), pos, d);\n        }\n    }\n    \n    w += 0.7;\n    d = makeCut(vec3(w, 0., 0.), pos, d);\n    d = makeCut(vec3(-w, 0., 0.), pos, d);\n    d = makeCut(vec3(0., 0., w), pos, d);\n    d = makeCut(vec3(0., 0., -w), pos, d);\n    \n   \t\n\treturn opU(dPlane, d);\n}\n\n// calculate scene normal using forward differencing\nvec3 sceneNormal( vec3 pos, float d )\n{\n    float eps = 0.001;\n    vec3 n;\n\t\n    n.x = scene( vec3( pos.x + eps, pos.y, pos.z ) ) - d;\n    n.y = scene( vec3( pos.x, pos.y + eps, pos.z ) ) - d;\n    n.z = scene( vec3( pos.x, pos.y, pos.z + eps ) ) - d;\n\t\n    return normalize(n);\n}\n\nbool raymarch( Ray ray, out vec3 hitPos, out vec3 hitNrm )\n{\n\tconst int maxSteps = 256;\n\tconst float hitThreshold = 0.00001;\n\n\tbool hit = false;\n\thitPos = ray.org;\n\n\tvec3 pos = ray.org;\n\n\tfor ( int i = 0; i < maxSteps; i++ )\n\t{\n\t\tfloat d = scene( pos );\n\n\t\tif ( d < hitThreshold )\n\t\t{\n\t\t\thit = true;\n\t\t\thitPos = pos;\n\t\t\thitNrm = sceneNormal( pos, d );\n\t\t\tbreak;\n\t\t}\n\t\tpos += d * ray.dir;\n\t}\n\treturn hit;\n}\n\n\nfloat shadow( vec3 ro, vec3 rd, float mint, float maxt )\n{\n\tfloat t = mint;\n    for ( int i = 0; i < 64; ++i )\n    {\n        float h = scene( ro + rd * t );\n        if ( h < 0.001 && i > 0) {\n            return 0.2;\n        }\n        t += h;\n\t\t\n\t\tif ( t > maxt )\n\t\t\tbreak;\n    }\n    return 1.0;\n}\n\n\nvec3 shade( vec3 pos, vec3 nrm, vec4 light )\n{\n\tvec3 toLight = light.xyz - pos;\n\t\n\tfloat toLightLen = length( toLight );\n\ttoLight = normalize( toLight );\n\t\n\tfloat comb = 0.0;\n   \tfloat vis = shadow( pos, toLight, 0.01, toLightLen );\n\n\n\tif ( vis > 0.0 )\n\t{\n\t\tfloat diff = 2.0 * max( 0.0, dot( nrm, toLight ) );\n\t\tfloat attn = 1.0 - pow( min( 1.0, toLightLen / light.w ), 2.0 );\n        comb += diff * attn * vis;\n\t}\n\t\n\treturn vec3( comb, comb, comb );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// fragCoord: location (0.5, 0.5) is returned \n\t// for the lower-left-most pixel in a window\n\t\n\t// XY of the normalized device coordinate\n\t// ranged from [-1, 1]\n    float t = iTime;\n    t = mod(t, 18.);\n\tvec2 ndcXY = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\t\n\t// aspect ratio\n\tfloat aspectRatio = iResolution.x / iResolution.y;\n\t\n\t// scaled XY which fits the aspect ratio\n\tvec2 scaledXY = ndcXY * vec2( aspectRatio, 1.0 );\n\t\n\t// camera XYZ in world space\n\tvec3 camWsXYZ = vec3( 0.0, 2.2, 2.0 );\n    \n   camWsXYZ.y -= smoothstep(3., 6., t);\n    \n\tcamWsXYZ.z += 3. * smoothstep(3., 6., t);\n\tcamWsXYZ.y *= (1. - smoothstep(10., 12., t))\n        ;\n    camWsXYZ.y += 2.2 * smoothstep(13., 15., t);\n    camWsXYZ.z *= (1. - smoothstep(13., 15., t));\n    camWsXYZ.z += smoothstep(13., 15., t) * 2.;\n    \n    \n\t// construct the ray in world space\n\tRay ray;\n\tray.org = camWsXYZ;\n\tray.dir =  normalize(vec3( scaledXY, -1 )); // OpenGL is right handed\n    \n    float theta = -0.3 + 0.7 * smoothstep(3., 6., t);\n    \n    theta += (1.57 - 0.4) * smoothstep(10., 12., t);\n    theta *= (1. - smoothstep(13., 15., t));\n    theta += smoothstep(13., 15., t) * (-0.3);\n    \n    ray.dir = rotation(ray.dir, vec3(1., 0., 0.), theta);\n    ray.org = rotation(ray.org, vec3(1., 0., 0.), theta);\n    \n    theta = -0.71 + 2.28 * smoothstep(6., 9., t);\n    theta -= smoothstep(13., 18., t) * 2.28;\n    ray.dir = rotation(ray.dir, vec3(0., 1., 0.), theta);\n    ray.org = rotation(ray.org, vec3(0., 1., 0.), theta);\n\t\n\t// define the point light in world space (XYZ, range)\n\tvec4 light1 = vec4( 0.0, 0., 0.0, 8.0 );\n    light1.y = 7. - 4. * (\n        smoothstep(0., 2.8, t)\n        -  smoothstep(13., 18., t));\n    \n    vec4 light2 = vec4( 1.0, 2.0, 4.2, 9.0 );\n\t\n\tvec3 sceneWsPos;\n\tvec3 sceneWsNrm;\n\t\n\tif ( raymarch( ray, sceneWsPos, sceneWsNrm ) )\n\t{\n\t\t// our ray hit the scene, so shade it with 2 point lights\n\t\tvec3 shade1 = shade( sceneWsPos, sceneWsNrm, light1 );\n        vec3 shade2 = shade( sceneWsPos, sceneWsNrm, light2 );\n        \n\t\tvec3 shadeAll = \n\t\t\t  0.8 * shade1 * vec3( 0.5, 0.5, 0.8 )\n\t\t\t+  0.5 * shade2 * vec3( 0.5, 0.5, 1.0 );\n\t\t\n\t\tfragColor = vec4( shadeAll, 1.0 );\n\t}\n\telse\n\t{\n\t\tfragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t}\n    \n    if (sceneWsPos.y < 0.01) {\n    \tfragColor.rgb += vec3(0.1, 0.3, 0.3);   \n    }\n    \n    // point source of light.\n    float flare = dot(normalize(ray.dir), normalize(light1.xyz - ray.org));\n    fragColor += 0.6 * smoothstep(0.999, 1., pow(flare, 2.));\n    fragColor += 0.4 * smoothstep(0.97, 0.9999, pow(flare, 0.5));\n    \n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdlBRj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdlBRS", "name": "circlegrid01", "author": "paulobarcelos", "description": "circlegrid01", "tags": ["circlegrid01"], "likes": 1, "viewed": 218, "date": "1588541560", "time_retrieved": "2024-06-20T20:07:06.525243", "image_code": "// inspired by https://www.youtube.com/watch?v=cQXAbndD5CQ\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // uv - center and fix aspect ratio\n    vec2 uv = (fragCoord - iResolution.xy * 0.5)/iResolution.y;\n    \n    // uv - rotate 45 deg\n\tfloat a = 0.7853982; // 45 in radians\n    float sa = sin(a);\n    float ca = cos(a);\n    uv *= mat2(ca, -sa, sa, ca);\n    \n    float time = iTime * 2.0;\n    vec3 col = vec3(0);\n    \n    float divisions = 11.0;\n    vec2 gv = fract(uv * divisions) - 0.5;\n    vec2 id = floor(uv * divisions);\n    gv.x *= mod(id.x, 2.0) == 0.0 ? 1.0 : -1.0;\n    gv.y *= mod(id.y, 2.0) == 0.0 ? 1.0 : -1.0;\n    \n    float d = length(gv + vec2(sin(time) * 2.0, cos(time) * 2.0) * 0.25);\n    float radius = 0.5 * (0.1 + sin(time * 0.25 + length(uv) * 3.12) * 0.5 + 0.5);\n    float circle = smoothstep(radius + 0.02, radius - 0.02, d);\n    \n    \n    col.rg = gv;\n    \n    col += d;\n    col = pow(col, vec3(4.0));\n   \n    col = max(col, vec3(circle));\n    \n  \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdlBRS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdlBz2", "name": "Windless Mandelbrot Set", "author": "Windless", "description": "Just a quick test to try displaying mandelbrot set.", "tags": ["fractal", "mandelbrot"], "likes": 0, "viewed": 44, "date": "1588683104", "time_retrieved": "2024-06-20T20:07:06.525243", "image_code": "vec2 fc(vec2 c, vec2 z) {\n\treturn vec2(c.x + z.x * z.x - z.y * z.y, c.y + 2. * z.x * z.y);\n}\n\nvec2 mandelbrot(vec2 c) {\n    int i=0;\n    \n    vec2 z = vec2(0., 0.);\n    vec2 oz = vec2(0., 0.);\n    \n    while( (length(z) < 1.5) ) {\n\n        oz = z;\n        z = fc(c, z);\n        i +=1;\n        \n        if (i > 100) {\n            \n            return vec2(0., 0.);\n        }\n    }\n    \n    return vec2(1.,1.) * float(i) / 100.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy * 3. - 2.) * 100. / (100. + iTime );\n\n    // Output to screen\n    fragColor = vec4(mandelbrot(uv), 0., 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdlBz2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdlBzj", "name": "some effects", "author": "keshav2010", "description": "my 1st shader :/ learning", "tags": ["basic"], "likes": 1, "viewed": 59, "date": "1588662194", "time_retrieved": "2024-06-20T20:07:06.525243", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    \n    float radii=.25+log(iTime*5.)*.05;\n    \n   \t\n    float current_distance = length(uv-vec2((iResolution.x/iResolution.y)/2., 0.5));\n    vec3 col = vec3((radii-current_distance)*sin(iTime*2.)*10.+0.5, 0, (radii-current_distance)*sin(iTime*8.)+0.5);\n    if(current_distance > radii)\n        col=col*vec3(current_distance/radii, current_distance/radii, current_distance/radii);\n    \n    // Output to screen\n    fragColor = vec4(col,0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdlBzj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdlfD7", "name": "loading rounded box w round cap", "author": "bradjamesgrant", "description": "loading assets...", "tags": ["learning"], "likes": 4, "viewed": 166, "date": "1588430783", "time_retrieved": "2024-06-20T20:07:06.525243", "image_code": "#define PI 3.1425\n\nvec3 remap(vec2 p, vec2 s, float d){\n    \n\tvec2 q = abs(p);\n    float n = 0.;\n    //if point closer to left or right side\n    if(q.x-s.x>q.y-s.y){\n        //how far is y coord up edge?\n    \tn = q.y/s.y;//0->1\n        n = sign(p.x)>0.?sign(p.y)*n*.125+.125:sign(p.y)*-n*.125+.625;\n    }\n    else{\n    \tn = q.x/s.x;\n        n= sign(p.y)>0.?sign(p.x)*-n*.125+.375:sign(p.x)*n*.125+.875;\n        \n    }\n    //THIS LINE HERE CREATES THE ROUNDED CAP\n    n+=sqrt(-(sin(d)*.13)+.15);\n    //n-=sqrt(-(d*d)+.25)*10000.; \n    \n    \n    return fract(n*3.-iTime/3.)*3.*fract(\tvec3(.6,.2,.4));\n}\n\n\nfloat sdBox( in vec2 p, float b)\n{\n    vec2 d = abs(p)-b;\n    float c = length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n    return 1.-smoothstep(0.00,0.01,abs(c));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-(0.5*iResolution.xy))/iResolution.x;\n\tvec2 s = vec2(0.1);    \n    float w = 0.01;\n    float d = sdBox(uv,0.1);\n    vec3 mask = d*remap(uv,s,d/20.);\n    \n    vec3 col = mask;\n     fragColor = vec4(col,0.);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdlfD7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdlfDX", "name": "Procedural Fabric Using R_2 LDS", "author": "jstrom2002", "description": "An attempted implementation of the R_2 low discrepancy sequence as described by Martin Roberts in his blog: http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences. Still a work-in-progress.", "tags": ["noise", "sequence", "bluenoise", "r2"], "likes": 1, "viewed": 60, "date": "1589210722", "time_retrieved": "2024-06-20T20:07:06.761752", "image_code": "//==============================================================\n// Functions for 1,2,3 Noise by Patricio Gonzalez Vivo\n// Ref: https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nfloat rand(vec2 n) {\n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\nfloat noise(vec2 n) {\n\tconst vec2 d = vec2(0.0, 1.0);\n\tvec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\n\n//=============================================================\n// R2 low-discrepancy sequence as described by Martin Roberts\n// Ref: http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences\nconst float a1 = 0.61803398874989484820633884919255;\nconst float a2 = 0.56984029099805326591218186327522;\nconst float a3 = 0.54970047790197026694714643076746;\nfloat R_2_1D(float n) {\n\treturn (0.5 + a1 * n);\n}\nvec2 R_2_2D(float n) {\n\treturn vec2(0.5 + a1 * n, 0.5 + a2 * n);\n}\nvec3 R_2_3D(float n) {\n\treturn vec3(0.5 + a1 * n, 0.5 + a2 * n, 0.5 + a3 * n);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) { \n    float uv_scale = 1.0;\n    vec2 uv_displacement = vec2(10000,10000) + vec2(float(iFrame) * 1.75);\n    float coord = noise(fragCoord * uv_scale + uv_displacement);\n    vec3 pattern = R_2_3D(coord);\n    vec3 fabricColor = vec3(0.7, 0.5, 0.41);\n    fragColor = vec4(pattern * fabricColor, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdlfDX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdlfW8", "name": "ytb", "author": "samstinson", "description": "chÃ©po", "tags": ["test"], "likes": 1, "viewed": 35, "date": "1588340004", "time_retrieved": "2024-06-20T20:07:07.082817", "image_code": "float map(vec3 p)\n{\t\n    vec3 q = fract(p) * 2.0 - 1.0;\n    \n    return length(q) -0.25;\n   \n}\nfloat trace (vec3 o, vec3 r)\n{\n    float t = 0.0;\n    for ( int i = 0; i< 32; ++i) {\n        vec3 p = o + r * t ;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    return t;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    //fragColor = vec4(col,1.0);\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv = uv * 2.0 - 1.0;\n    \n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 r = normalize(vec3(uv, 1.0));\n    \n    float the = iTime * 0.25;\n    r.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    \n    vec3 o = vec3(0.0, iTime, iTime);\n    \n    float t = trace (o, r);\n    \n    float fog = 1.0 / (1.0 + t * t * 0.1);\n    \n    vec3 fc = vec3(fog);\n    \n    fragColor = vec4(fc,1.0);\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdlfW8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdlfWM", "name": "Noise Over Time", "author": "Mogster", "description": "it noises", "tags": ["noise"], "likes": 1, "viewed": 55, "date": "1588408149", "time_retrieved": "2024-06-20T20:07:07.088713", "image_code": "#define RES 100.0\n#define SPEED 1.0\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 noiseInput = floor(uv * RES);\n    \n\tvec3 col = vec3(sin(rand(noiseInput) * iTime * 3.14159 * 2.0 * SPEED));\n\n\tvec4 color = vec4(vec3(col), 1.0);\n    color.r *= (uv.y + cos(iTime) * 1.0 + 1.0);\n    //color.b *= ((uv.x + uv.y) / 2.0 * cos(iTime * 1.5) + 1.0);\n\n    // Output to screen\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdlfWM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdlfWS", "name": "Round and Round and Round", "author": "gurudevbk", "description": "just new boot goofin'", "tags": ["colors", "experiment", "experimentation", "circle", "abstract"], "likes": 1, "viewed": 218, "date": "1589008398", "time_retrieved": "2024-06-20T20:07:07.301048", "image_code": "// returns true if a point [uv] is within the circle defined by [origin, radius]\nbool circle(vec2 uv, vec2 origin, float radius) {\n \treturn (length(uv-origin) < radius);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    float radius = sin(iTime)/2.;\n    vec2 zero = vec2(sin(iTime)*0.3+0.5, cos(iTime)*0.3+0.5);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = length(uv-zero)+cos(iTime+vec3(0.,2.,.4));\n    \n    col.r += .5*atan(sin(iTime*0.002)*(uv.x+zero.x), length(uv-zero));\n    col.b += atan(uv.y-zero.y, length(uv-zero));\n    col.g -= .5*atan(cos(iTime*0.2)*(zero.y-uv.x), length(uv-zero))-col.b;\n\n\tcol += length(uv-zero);\n    \n    col.r = (length(uv-zero)*col.b+sin(iTime*.2)*col.g);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdlfWS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdsBDB", "name": "psychedelic fractal", "author": "unnick", "description": "while i was making the [url=https://www.shadertoy.com/view/3dfBWj]laser show[/url] shader, i made this sort-of fractal that uses the same algorithm but i use it with broken inputs.", "tags": ["2d"], "likes": 0, "viewed": 282, "date": "1589126581", "time_retrieved": "2024-06-20T20:07:07.301048", "image_code": "#define res iResolution.xy\n#define tau 6.283\n#define eps .01\n\nfloat sdf(vec2 p) {\n    float dist = length(p) - .5;\n    dist = min(dist, p.y + 1.);\n    dist = min(dist, 1. - p.y);\n    dist = min(dist, p.x + res.x/res.y);\n    dist = min(dist, res.x/res.y - p.x);\n    return dist;\n}\n\nvoid mainImage(out vec4 col, in vec2 coord) {\n    vec2 pos = (coord * 2. - res) / res.y;\n    for(int i = 0; i < 32; i++) {\n        float dist = sdf(pos)*2.;\n        if(abs(dist) < .01) break;\n        pos += dist * vec2(sin((vec2((i+1)*(i+1))*iTime*.001 + vec2(0,.25)) * tau));\n    }\n    col = vec4(normalize(pos) * .5 + .5, 0, 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdsBDB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdSBRR", "name": "Palace", "author": "os0450", "description": "Day 40: Palace", "tags": ["dailycodingchallenge"], "likes": 2, "viewed": 98, "date": "1589344864", "time_retrieved": "2024-06-20T20:07:07.301048", "image_code": "// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat rand(vec2 p) {\n    return fract(sin(dot(p, vec2(3213.213123, 7879.789321)))*321312.890);\n}\n\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 ii = i+1.0;\n    vec2 f = fract(p);\n    \n    f = smoothstep(0.0, 1.0, f);\n    \n    return mix(mix(rand(vec2(i.x+0.0, i.y+0.0)), rand(vec2(i.x+1.0, i.y+0.0)), f.x),\n               mix(rand(vec2(i.x+0.0, i.y+1.0)), rand(vec2(i.x+1.0, i.y+1.0)), f.x),\n               f.y);\n}\n\nfloat map(vec3 p) {\n    float d = 1e10;\n    vec3 q;\n    \n    q = p;\n    q.y -= -5.0;\n    d = min(d, q.y + (noise(q.xz*3.0)*0.05)+noise(q.xz*0.5+vec2(13213.2))*0.5 );\n    \n    q = p;\n    q.y -= 25.0;\n    d = min(d, -q.y + (noise(q.xz*3.0)*0.05)+noise(q.xz*0.5+vec2(13213.2))*0.5 );\n    \n    q = p;\n    q.y -= -2.5;\n    q.xz = mod(q.xz, 6.0) - 3.0;\n    d = min(d,\n            sdRoundBox(q, vec3(0.2, 100.0, 0.2), 0.2) +\n            noise( (p.yz+p.xy) )*0.1 +\n            noise( (p.yz+p.xy)*20.0 )*0.01);\n    \n    return d;\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 eps = vec2(0.001, 0.0);\n    return normalize(vec3(\n        map(p+eps.xyy) - map(p-eps.xyy),\n        map(p+eps.yxy) - map(p-eps.yxy),\n        map(p+eps.yyx) - map(p-eps.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord - iResolution.xy)/iResolution.yy;\n\tvec3 cPos = vec3(0.0, 0.0, -5.0);\n    \n    cPos = vec3(sin(iTime*0.5), 0.3+cos(iTime*0.4)*0.2, cos(iTime*0.5));\n    cPos *= 10.5;\n    \n    vec3 cTar = vec3(0.0, 0.0, 0.0);\n    cTar = vec3(sin(iTime), cos(iTime*0.7)*0.5+0.5, 0.0);\n    cTar *= 10.5;\n    \n    \n    vec3 cDir = normalize(cTar - cPos);\n    vec3 wU = vec3(0.0, 1.0, 0.0);\n    vec3 cR = cross(cDir, wU);\n    vec3 cU = cross(cR, cDir);\n\t\n    vec3 rd = normalize(p.x*cR + p.y*cU + cDir);\n    vec3 ro = cPos;\n    \n    float t = 0.;\n    vec3 rp;\n    for(int i=0; i<99; i++) {\n        rp = ro + rd*t;\n        float d = map(rp);\n        \n        t += d;\n    }\n    \n    float mt = iTime;\n    float ph = fract(mt);\n    \n    vec3 col = vec3(0.0);\n    vec3 lDir = normalize(vec3(0.5, 0.5, -0.5));\n    float diff = max(0.0, dot(lDir, getNormal(rp)));\n\n    col += (diff+0.1)*cDir*exp(-3.0*t*t)*100.0;\n\n    float decay = exp(-0.1*t);\n    col += decay*0.01;\n    col += exp(-100.0*abs(fract(rp*5.0+0.1)-0.5))*decay;\n    col += max(0.0, exp(-500.0*abs( fract(t*0.5)-ph )))*decay*vec3(0.3, 1.0, 0.4)*2.5;\n    col = clamp(col, 0.0, 1.5);\n    \n    col = pow(col, vec3(0.45));\n    col -= ( 1.0-exp(-0.2*length(p)) )*0.2;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdSBRR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdsBWf", "name": "Ford Monument", "author": "spalmer", "description": "a testament to Lester R. Ford, Sr. for the circles which bear his name.  A simple kaleidoscope of a 3d view of a simplified sequence of Ford circles.  Or maybe it's to Lita Ford, who probably has a guitar shaped like this.  Uses experimental WoS lighting.", "tags": ["sphere", "packing", "ford", "appollonian", "rwos"], "likes": 4, "viewed": 135, "date": "1589552890", "time_retrieved": "2024-06-20T20:07:09.810541", "image_code": "// fork of Ford Circles 101:  https://shadertoy.com/view/wdlBWX\n// and Orbit Camera:  https://shadertoy.com/view/WlVGD1\n// TODO at some point should merge in some cool rendering/shading\n// haven't merged any code in yet but might regarding random walk on spheres\n// let's see how far I can get w/o referring back to anything lol!\n\n#define IZERO min(0, iFrame)\n\nconst float pi = acos(-1.)\n\t, tau = 2. * pi\n    , phi = .5 * (sqrt(5.) + 1.);\n\nconst float radius = .5 // of object resting on ground to examine\n, orbit_scale = 3.2; // of radius of object\n\nconst int nbulbs = 6;\n\nconst vec3 op = vec3(-1,0,0); // HACK major kludge, quite problematic\n// due to how I arranged the Ford circles with tail end at the origin\n// TODO re-integrate into C somehow\n\n// Ford circle for given rational number p/q\nvoid C(int p, int q, out vec3 c, out float r)\n{\n    if (q <  1) {\n        c = vec3(0); r = 0.; return;\n    }\n    r = .5 / float(q * q); \n    c.x = float(p) / float(q);\n    c.y = r;\n    c.z = 0.;\n}\n    // radius is in fact an easy sequence to compute\n\n    // must actually skip cases that reduce to simpler fractions!!!\n    // first the special cases to start sequence off:\n    // cannot do it recursively in GLSL anyway!\n\n// quick'n'dirty, not precise palette\nvec3 hue(float h)\n{\n    return max(cos(vec3(0,2,4) + (h-.166) * tau), 0.);\n}\n\nvec3 csky(vec3 rd)\n{\n    return rd * .5 + .5; //vec3(0); //  \n}\n\nfloat dPlaneY(vec3 p, vec3 d) { return p.y; }\nfloat dBall(vec3 p, vec3 d) { return length(p) - 1.; }\n\n// FIXME same as ConsiderObject so far\n// first 3 are inout arguments, last 2 unmodified.\n// sorry about the dtemp var hack, it's still pretty lame.\n// macro is to future-proof check of bounding volume etc.\n#define CheckObject(dtemp, dmin, imin, dobj, iobj) \\\ndtemp = dobj; \\\nif (dtemp < dmin) \\\n{ dmin = dtemp; imin = iobj; }\n///\n\n// must replicate traced scene as sdf\nfloat dscene(vec3 p, out int sid)\n{\n    sid = 0; // nearest object (for material/lighting)\n    float d = 3.4e38, dtemp; // prep trace scene\n    vec3 ro = p, rd = vec3(0);\n    int i = 0;\n    CheckObject(dtemp, d, i, dPlaneY(ro, rd), 1);\n//    CheckObject(dtemp, d, i, dBall(ro.zyx / .5, rd) * .5, 2); // for checking sanity\n//    CheckObject(dtemp, d, i, dBall((ro - op) / .5, rd) * .5, 2);\n    \t// in fact with distance field ray marching, yes, totally,\n    // far easier to do symmetry some other way FIXME\n    // but I'll roll with it for now to get started hehe\n    // truly I'm being silly here, I believe I could do the equivalent\n    // by mirroring the camera vectors with the scene in a loop\n    // HACK kludged to make a nice sequence even without sieving primes\n  #if 1\n    for (int j = nbulbs; j-- >= 1; ) {\n        vec3 c; float r; int id = j;\n        C(1, j+1, c, r);\n        int k = 2 + id;\n    \tCheckObject(dtemp, d, i, dBall((ro.zyx * vec3(-1,1, 1) - op - c) / r, rd.zyx * vec3(-1,1, 1)) * r, k);\n    \tCheckObject(dtemp, d, i, dBall((ro.zyx                 - op - c) / r, rd.zyx                ) * r, k);\n    \tCheckObject(dtemp, d, i, dBall((ro     * vec3(-1,1, 1) - op - c) / r, rd     * vec3(-1,1, 1)) * r, k);\n    //\tCheckObject(dtemp, d, i, dBall((ro                     - op - c) / r, rd                    ) * r, k);\n        if (id > 0)\n        { // getting these horns arranged is harder than it looks lol sign madness!\n    //    CheckObject(dtemp, d, i, dBall((ro.yzx * vec3( 1,1, 1) - vec3( .5,-.5, 0) - op - c) / r, rd.yzx * vec3( 1,1, 1)) * r, k);\n    //\t  CheckObject(dtemp, d, i, dBall((ro.yzx * vec3(1,-1, 1) - vec3(-.5,-.5, 0) - op - c) / r, rd.yzx * vec3(-1,1, 1)) * r, k);\n    //    CheckObject(dtemp, d, i, dBall((ro.yxz * vec3( 1,1, 1) - vec3( .5,-.5, 0) - op - c) / r, rd.yxz * vec3( 1,1, 1)) * r, k);\n    \tCheckObject(dtemp, d, i, dBall((ro.yxz * vec3(-1,1, 1) - vec3(-.5,-.5, 0) - op - c) / r, rd.yxz * vec3(-1,1, 1)) * r, k);\n        }\n    }\n  #endif\n    sid = i;\n    return d; // TODO\n}\n// curry shim, yay dead code elimination phase!\nfloat dscene(vec3 p)\n{\n    int _; // unused id\n    return dscene(p, _);    \n}\n\n// safer than usual; TODO incorporate eye distance lod\nvec3 nscene(vec3 p) //, float h, out float d)\n{\n    float h = .002;\n    vec3 n = vec3( \n          dscene(p + vec3(h,0,0))\n        , dscene(p + vec3(0,h,0))\n        , dscene(p + vec3(0,0,h))\n      ) - dscene(p);\n    if (dot(n,n) < 1e-7) n = vec3(0,1,0);\n    else n = normalize(n);\n    return n;\n}\n\nfloat rseed; // random seed\n\nfloat rnd() // about that alleged randomness, buddy... FIXME need real hash\n{ // this garbage distribution should be embarrassing enough to prevent publishing the toy\n    return sin(7. * tau * (rseed = fract(rseed * 5. * phi + 1e-7)));\n} // but I have no shame lol - use whatever hash works for you!\n\nvec3 randomDir()\n{\n    return normalize(vec3(rnd(), rnd(), rnd()));\n}\n// I tried blackle's tangent trick!  slightly different but did not notice major change.\n// I might not have done it correctly though.\n\n// seriously I'm just not finding the hashing to be the major problem.\n// Random Walk On Spheres is awesome!\n\n// creative use of bias should be able to make it replicate\n// traditional ray marching effects, but with some amount of\n// blurriness dependent inversely upon the magnitude of the bias.\n// with no bias, it's really blurry and liable to randomly\n// walk straight back into the neighboring surface, resulting\n// in maybe some subsurface if handled properly (not done here)\n// so usually you'd want to take the surface normal into account.\n// returns final position o walked to.\nvec3 rwos(vec3 o, vec3 bias, int iter, float tol, out int rwid)\n{\n    vec3 orig = o;\n    rwid = 0; // sky if hit nothing else\n    for (int i = iter; --i > 0; ) {\n        int sid;\n        float d = dscene(o, sid);\n        if (d < tol) { // TODO abs(d)?\n            rwid = sid; break;\n        }\n        vec3 g = randomDir();\n        g += bias;\n        float m = dot(g, g);\n        if (m < 1e-6) continue; // avoid nan\n        o += d * inversesqrt(m) * g; // normalize(g) shares m \n    }\n    //o = mix(orig, o, .9); // HACK - no\n    return o;\n}\n\n// HACK x = some hack for lighting; trying to fix stuff\n// when x == 0, basically returns albedo, \n// when x == 1, returns the pulsing glow emission too\n// TODO desperately wants some texture\nvec3 cscene(vec3 hp, vec3 n, float d, int i, float x)\n{\n    // TODO would be better off with actual reflection mapping somehow;\n    // this sort of averages the sky color out to a gray for bounce light purposes\n    vec3 cenv = vec3(.4); \n    vec3 csk = csky(n); //vec3(0,1,0)); // green tho\n    cenv = mix(cenv, csk, .5); \n    vec3 cfire = .2*vec3(1,.4,.16); // lamest fire palette evar\n    vec3 c = vec3(0);\n    switch (i) {\n        case 0: { // sky\n        \tc.rgb = cenv; d = 1e4;\n        \tbreak;\n        }\n        case 1: { // plane\n        //\tfloat stripe = cos(hp.x) * cos(hp.z); //.5; //1.; // 2d grid texture\n        //\tstripe *= stripe; stripe = 1. - stripe; stripe *= stripe;\n        //\tstripe = 0.*mix(stripe, .3, min(1., .4*length(fwidth(hp.xz)))); // aa\n        //\tc.rgb = vec3(0,0,0); //vec3(.1, .1*stripe, .1); // colorize\n            c.rgb = vec3(.1*x); // ambient on plane bounces up onto spheres and lights them, which bounces back down as tinted shadows\n        \tbreak;\n        }\n        default:\n      //  case 2: { // sphere\n        \tc = hue(phi * float(i));\n\t\t\tif (x > 0.) {\n        \tc = .1 + .1*c;\n        \t\tfloat flux = sin(iTime*2.) * .5 + .5;\n                flux *= x;\n                c += cfire * flux;\n            \t//c = mix(c, c + cfire, flux);\n            } // fluctuate\n\t    \tbreak;\n      //  }\n\t}\n    // most gawdawful HACK ever! somehow I've made diffuseness into an argument\n    // what in the heck am I doing here, returning colorization components based\n    // on scalar argument, just make a real light transfer function!\n    if (x == 0.) // general albedo and emission?\n    \tc = .7 * mix(c, vec3(1), .5);\n    //if (x != 0.) //else // what ambient lighting picks up\n    //\tc *= mix(1., 1./2., x); // FIXME probably missing a pi factor elsewhere\n    return c;\n}\n\nvec3 cglow(vec3 hp, vec3 v, float d, int id)\n{\n  //  return vec3((1.-dscene(hp)) * exp2(-.5*d));\n    vec3 n = nscene(hp);\n    n = normalize(n);\n    hp += .025 * n; // random walk already using it as a bias, no need atm\n   \n    vec3 r = n;\n\tif (id == 1) r *= .99; // plane much blurrier\n    else {\n        // balls pretty shiny\n        r = normalize(reflect(-v, n)); //n, v)); //n + \n        r *= exp2(2.); // how shiny?\n        n += r; //n = r; //\n    }\n    vec3 rnorm = normalize(r);\n  //  return n * .5 + .5;\n    // TODO improve lighting\n    vec3 c = vec3(0);\n    int ni = 12;\n    if (iResolution.y > 500.) ni -= 4;\n    if (iResolution.y > 1000.) ni /= 2;\n    if (iResolution.y > 1400.) ni /= 2;\n    //barrier(); // great place for a barrier, but GLES 3 doesn't have any?!\n    ni = max(ni, 1);\n    for (int i = ni + IZERO; --i >= 0; ) {\n        int rwid;\n        vec3 pwalk = rwos(hp, r, 6, .015, rwid);\n        if (hp.y > 1.5) rwid = 0;\n    \tvec3 amb = cscene(pwalk, rnorm, d, rwid, 1.); // / (1. + dot(pwalk - hp, pwalk - hp)); //i); //\n        amb = clamp(amb, 0., 1.);\n        c += amb;\n    }\n    c *= 1. / float(ni);\n    vec3 emi = cscene(hp, n, d, id, 0.);\n    c *= emi; // or is it albedo?\n    c = clamp(c, 0., 1.);\n    return c;\n}\n\n#if 0\n// marching - too slow\n// so I can reuse sdf and maybe debug it, similar but marched\n// returns (distance, material)\nvec2 March(vec3 ro, vec3 rd, float rate, int iters)\n{\n    vec2 c = vec2(3.4e38, 0);\n    int i = iters;\n    float t = 0.;\n    while (i-- > 0) {\n        int id;\n        float d = dscene(ro + rd * t, id);\n        //float d = h.x;\n        //if (d < c.x) {\n        //    c = h; //vec2(d, m);\n        //}\n        t += d * rate;\n        if (d < .01) {\n            c = vec2(d, float(id));\n            break;\n        }\n    }\n    //barrier(); // FIXME sync threads please - lack of barrier makes marching particularly slow, even if unrolled; don't think the threads ever manage to sync up before the next loop\n    int m = int(c.y);\n    const float dmax = 8.5e4;\n    /*if (false && c.x > .05 && ro.y > 0.) { // rescue? no.\n        if (rd.y < 0.) { // ground plane\n            t = ro.y / -rd.y; m = 1;\n        } else { // sky dome\n            t = dmax * pow(1.-.5*rd.y, 2.); m = 0;\n        }\n        c.y = float(m);\n    }*/\n    c.x = clamp(t, 0., dmax);\n    return c;\n}\n\nvec3 RenderScene(vec3 ro, vec3 rd, float time)\n{\n\tvec2 m = March(ro, rd, .5, 48);\n    float d = m.x;\n    int id = int(m.y);\n    vec3 cenv = csky(rd);\n    vec3 hp = ro + d * rd; // hit pos\n    vec3 c = vec3(0.);\n   \tc = cglow(hp, -rd, d, id);\n    float dfade = exp2(-.02 * d);\n    c.rgb = mix(cenv, c.rgb, dfade);\n    return c;\n}\n\n#else\n// tracing\n\n//hp -= op; //vec3 hp = ro + d * rd - op; \n//hp *= 1.*pi;\n\n// basic root finder special case\nfloat Root(vec3 f) // first zero crossing of polynomial quadric function\n{ // f(t) = dot(f, vec3(1.,vec2(1.,t)*t)) == 0\n    float dsc = .25 * f.y * f.y - f.x * f.z;\n    if (dsc < 0.) return -1.; // guard vs. nan fix for busted camera on android \n\tfloat d = sqrt(dsc);\n\tif (f.y * f.z < 0.) d = -d; // wut?\n\treturn (d - .5 * f.y) / f.z;\n} // see also The Quadratic Equation\n\nfloat tracePlaneY(vec3 ro, vec3 rd)\n{\n    return ro.y <= 0. ? 0. : rd.y >= -5e-3 ? -1. : ro.y / -rd.y;\n}\n\n// many cases not handled properly btw\nfloat traceBall(vec3 ro, vec3 rd)\n{\n\treturn Root(vec3(dot(ro, ro) - 1., 2. * dot(ro, rd), 1.));\n}\n\n// first 3 are inout arguments, last 2 unmodified.\n// sorry about the dtemp var hack, it's pretty lame.\n/// macro is to future-proof check of bounding volume etc.\n#define ConsiderObject(dtemp, dmin, imin, dobj, iobj) \\\ndtemp = dobj; \\\nif (0. <= dtemp && dtemp < dmin) \\\n{ dmin = dtemp; imin = iobj; }\n///\n\nfloat Trace(vec3 ro, vec3 rd, out int i)\n{\n    float d = 3.4e38, dtemp; // prep trace scene\n    ConsiderObject(dtemp, d, i, tracePlaneY(ro, rd), 1);\n    // truly I'm being silly here, I believe I could do the equivalent\n    // by mirroring the camera vectors with the scene in a loop\n    // HACK kludged to make a nice sequence even without sieving primes\n    for (int j = nbulbs; --j >= 0; ) {\n        vec3 c; float r; int id = j;\n        C(1, j+1, c, r);\n        int k = 2 + id;\n    \tConsiderObject(dtemp, d, i, traceBall((ro.zyx * vec3(-1,1, 1) - op - c) / r, rd.zyx * vec3(-1,1, 1)) * r, k);\n    \tConsiderObject(dtemp, d, i, traceBall((ro.zyx                 - op - c) / r, rd.zyx                ) * r, k);\n    \tConsiderObject(dtemp, d, i, traceBall((ro     * vec3(-1,1, 1) - op - c) / r, rd     * vec3(-1,1, 1)) * r, k);\n    //\tConsiderObject(dtemp, d, i, traceBall((ro                     - op - c) / r, rd                    ) * r, k);\n        //if (id > 1)\n        { // getting these horns arranged is harder than it looks lol sign madness!\n    //    ConsiderObject(dtemp, d, i, traceBall((ro.yzx * vec3( 1,1, 1) - vec3( .5,-.5, 0) - op - c) / r, rd.yzx * vec3( 1,1, 1)) * r, k);\n    //\t  ConsiderObject(dtemp, d, i, traceBall((ro.yzx * vec3(1,-1, 1) - vec3(-.5,-.5, 0) - op - c) / r, rd.yzx * vec3(-1,1, 1)) * r, k);\n    //    ConsiderObject(dtemp, d, i, traceBall((ro.yxz * vec3( 1,1, 1) - vec3( .5,-.5, 0) - op - c) / r, rd.yxz * vec3( 1,1, 1)) * r, k);\n    \t  ConsiderObject(dtemp, d, i, traceBall((ro.yxz * vec3(-1,1, 1) - vec3(-.5,-.5, 0) - op - c) / r, rd.yxz * vec3(-1,1, 1)) * r, k);\n        }\n    }\n    if (d < 0.) d = 8e5;\n    return d;\n}\n\nvec3 RenderScene(vec3 ro, vec3 rd, float time)\n{\n    vec3 c = vec3(0);\n    int i = 0; // sky is id 0\n    vec3 cenv = csky(rd);\n    float d = Trace(ro, rd, i);\n    vec3 hp = ro + d * rd; // hit pos\n   \tc = cglow(hp, -rd, d, i);\n    float dfade = exp2(-.04 * d);\n    c.rgb = mix(cenv, c.rgb, dfade); // \"fog\"\n    return c;\n}\n\n#endif\n// ray scan method\n\n// I'm sure compiler will figure it out and\n// rewrite to same thing internally either way,\n// but I've always had a soft spot for the\n// identity x + x = 2*x, since historically\n// x += x has been a cheaper operation than\n// x *= 2 or even x <<= 1 in some cases.\n// Nowadays with mads, probably not, in this case.\n// it'll evaluate as (2.*s-r)/r.y, betcha.\nvec2 StoQ(vec2 s, vec2 r)\n{\n\treturn (s + s - r) / r.y;\n}\n\nmat3 CameraMatrix(vec3 camFwd)\n{\n    vec3 w = normalize(camFwd)\n       , u = normalize(cross(vec3(0, 1, 0), w))\n       , v = normalize(cross(w, u));\n    return mat3(u, v, w);\n}\n// then transform by pw = MC * pv;\n\nvec3 sph2cart(vec3 a) // spherical radians theta, psi, radius -> cartesian\n{\n    float cx = cos(a.x), sx = sin(a.x)\n        , cy = cos(a.y), sy = sin(a.y);\n    return vec3(sx*cy, sy, cx*cy) * a.z;\n}\n\nvec3 OrbitCamera(vec2 angles)\n{ // angles is yaw, pitch in radians\n    angles.x *= 2.;\n    angles.y = clamp(angles.y, -.4, .3);\n    return sph2cart(vec3(angles * pi, 1.));\n} // returns forward vector camera aims along\n\nfloat Dither(vec2 p)\n{\n    return sin(dot(p, vec2(1./23., 1./23./17.)) * 23456.);\n}\n\nvoid mainImage(out vec4 c, vec2 p)\n{\n    rseed = fract(fract(iTime*.1)+dot(vec2(.09,.07),p));\n    c = vec4(0,0,0,1);\n    vec2 R = iResolution.xy\n    , M = iMouse.xy\n    , q = StoQ(   p, R)\n    , m = StoQ(M.xy, R);\n    if (length(M.xy) <= 1.)\n        m = vec2(.2 + .02*iTime,.25); // unattended, mouse in bottom left corner?\n    vec3 object_pos = vec3(0, radius, 0)\n        , camera_dir = OrbitCamera(m)\n        , camera_pos = object_pos - orbit_scale * radius * camera_dir;\n    camera_pos.y = max(camera_pos.y, 1e-2); // do not go beneath ground\n    camera_dir = normalize(object_pos - camera_pos); // redo LookAt\n    mat3 cam = CameraMatrix(camera_dir);\n    const float hfovy = pi/6.;\n    vec3 vd = normalize(vec3(q, 1./sin(hfovy)))\n    , ro = camera_pos\n    , rd = normalize(cam * vd); // view ray\n    c.rgb = RenderScene(ro, rd, iTime);\n    c.rgb = pow(c.rgb, vec3(1./2.2)); // to sRGB gamut (approximately)\n    c.rgb += .5/256. * Dither(p);\n}\n\n            //float stripe = 1.; //cos(hp.x) * cos(hp.y) * cos(hp.z); // 3d grid texture\n        //    stripe = 1. - abs(stripe); stripe *= stripe; stripe *= stripe; \n        //    stripe = mix(stripe, .3, min(1., .4*length(fwidth(hp)))); // aa\n        //    if (d == 0.) stripe = sin(iTime*12.); // beneath? flash\n            //c.rgb = vec3(.5, .25*stripe, 0.); // colorize\n            // TODO antialias silhouette edge!  ;)\n\t\t\t//float pixel = .5/r.y;\n\t\t    //d -= .5 * pixel;\n\t\t\t//float cov = clamp(.5 - .5*d*r.y, 0., 1.);\n\t\t    //float g = cov;\n\t\t   // c = h; //vec3 c = 2. * vec3(g) * h; // super bright!  more will saturate weird\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdsBWf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdsBWs", "name": "Quake strafe jump angle graph", "author": "heartoftheforce", "description": "Graph showing the relationship between speed, angle relative to direction of movement and acceleration.", "tags": ["graph"], "likes": 2, "viewed": 70, "date": "1589349701", "time_retrieved": "2024-06-20T20:07:10.368068", "image_code": "// CONFIGURATION\n#define M_PI 3.1415926535897932384626433832795\n#define MaxVelocity 320.0\n// function sampling range\nvec2 xRange = vec2(-M_PI, M_PI);\n// drawn range of the Y axis\nvec2 yRange = vec2(-MaxVelocity, MaxVelocity) * 2.0;\n\n// colours\nconst vec3 background = vec3(1.0, 1.0, 1.0);\nconst vec3 axes = vec3(0.0, 0.0, 0.0);\n\n// function plot line thickness in pixels\nconst float thickness = 5.0;\n\n// function to sample\n#define Acceleration 10.0\n#define DeltaTime 0.01\n\nvec3 calcPrevVelocity()\n{\n    return vec3(MaxVelocity * 3.0 * (sin((M_PI / -2.0) + iTime * 0.25) + 1.0) * 3.0, 0, 0);\n}\n\nfloat f(float angle)\n{\n    vec3 prevVelocity = calcPrevVelocity();\n    vec3 accelDir = vec3(cos(angle), sin(angle), 0);\n    float projVel = dot(prevVelocity, accelDir);\n    float accelVel = Acceleration * DeltaTime;\n\n    if(projVel + accelVel > MaxVelocity) \n        accelVel = MaxVelocity - projVel;\n  \n    if(accelVel < 0.0)\n        return 0.0;\n    else\n  \t \treturn projVel + accelVel;\n}\n\nfloat o()\n{\n    vec3 prevVelocity = calcPrevVelocity();\n   \tfloat prevLength = length(prevVelocity);\n    float accelVel = Acceleration * DeltaTime;\n    float projMax = MaxVelocity - accelVel;\n\n    float theta;\n    if (prevLength <= projMax)\n        theta = acos(dot(vec3(1,0,0), prevVelocity) / prevLength);\n    else\n        theta = acos(projMax / prevLength);\n\n    return theta;\n}\n\n\n// IMPLEMENTATION\n\n// @return\tGiven relative real Y value converted to pixels.\nfloat realYToPixels(float real)\n{\n\treturn real / (yRange.y - yRange.x) * iResolution.y;\n}\n\n// @return\tGiven relative real X value converted to pixels.\nfloat realXToPixels(float real)\n{\n\treturn real / (xRange.y - xRange.x) * iResolution.x;\n}\n\n// @return\tAlpha for a pixel which is dist away for a given max allowed radius.\nfloat coverage(float dist, float radius)\n{\n\tradius *= 0.5;\n\treturn 1.0 - smoothstep(floor(radius), radius, dist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 actualYRange = yRange;\n\t\n\tfloat x = xRange.x + (xRange.y - xRange.x) * (fragCoord.x / iResolution.x);\n\tfloat y = f(x);\n    float optimalAngle = o();\n    \n    float actualY = actualYRange.x + (actualYRange.y - actualYRange.x) * (fragCoord.y / iResolution.y);\n    vec4 plot;\n    if(abs(x) - optimalAngle < 0.01 && optimalAngle - abs(x) < 0.01)\n    {\n        plot = vec4(1.0, 0.0, 0.0, 1);\n    }\n    else\n    {\n        // plot dot :)\n        float dotX = xRange.x + fract(iTime) * (xRange.y - xRange.x);\n\n        vec3 funcColour = vec3(0.0, 0.0, 1.0);\n        // plot colour\n        float distY = abs(y - actualY);\n        plot = vec4(funcColour, coverage(realYToPixels(distY), thickness));\n    }\n    \n    // axis colour\n    vec4 xAxis = vec4(axes, coverage(realXToPixels(abs(x)), thickness));\n    vec4 yAxis = vec4(axes, coverage(realYToPixels(abs(actualY)), thickness));\n    vec4 axis = xAxis * xAxis.a + yAxis * yAxis.a;\n\t\n\tvec4 foreground = mix(axis, plot, plot.a);\n\tfragColor = mix(vec4(1.0), foreground, foreground.a);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdsBWs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdSBWw", "name": "Reshaping sphere", "author": "kotfind", "description": "My first glsl project.", "tags": ["raymarching3d"], "likes": 1, "viewed": 225, "date": "1590138871", "time_retrieved": "2024-06-20T20:07:10.368068", "image_code": "#define ROTATION\n#define LIGHT_SOURCE_ATTACHED_TO_CAMERA\n#define LIGHTING\n\n#define M_PI 3.1415926\n\n// setting begin\nconst float FOV   = M_PI / 2.;\nconst float zNear = 1.;\nconst float zFar  = 100.;\n\nconst float colissiondist = 0.00001;\nconst int maxIter = 1000;\n// setting end\n\nvec3 viewpoint = vec3(0., 0., 6.);\n\nmat3 rotatey(in float a) {\n    float sina = sin(a);\n    float cosa = cos(a);\n    return mat3(cosa,  0., sina,\n                0.,    1.,   0.,\n                -sina, 0., cosa);\n}\n\nfloat f(in vec3 p) {\n    return distance(p, vec3(0., 0., 0.)) - 2. + sin(p.x * 10.) * sin(iTime * 2.);\n}\n\nvoid dist(in vec3 p, out float mind, out vec3 color, out vec3 norm) {\n    mind = f(p);\n    color = vec3(1., 0., 0.);\n    color = vec3(sin(p.x * 3.)  + sin(p.y * 5.)  * cos(p.z * 100.), \n                 sin(p.x * 30.) * sin(p.y * 1.)  + sin(p.z * 2.),\n                 sin(p.x * 9.)  * cos(p.y * 25.) + sin(p.z * 700.));\n    const float E = 0.000001;\n    norm = normalize(vec3(f(p + vec3(E, 0., 0.)), f(p + vec3(0., E, 0.)), f(p + vec3(0., 0., E))));\n}\n\nvec3 ray_marching(vec3 orig, vec3 dir) {\n    dir = normalize(dir);\n    float len = 0.;\n    vec3 bg = vec3(min(0.937255, max(0.2, sin(dir.x * 5.) + sin(dir.y * 10.) + cos(dir.x * dir.y * 10.))));\n\n    for (int i = 0; i < maxIter; ++i) {\n        float d;\n        vec3 color;\n        vec3 norm;\n        dist(orig, d, color, norm);\n        #ifdef LIGHTING\n            #ifdef LIGHT_SOURCE_ATTACHED_TO_CAMERA\n                if (d < colissiondist) return color * \n                    max(0.4, length(dot(norm, normalize(viewpoint - dir))));\n            #else\n                if (d < colissiondist) return color * \n                    max(0.4, length(dot(norm, normalize(vec3(0., 3., 4.) - dir))));\n            #endif\n        #else\n            if (d < colissiondist) return color;\n        #endif\n        if (len > zFar) return bg;\n\n        len += d;\n        orig += dir * d;\n    }\n    return bg;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / vec2(min(iResolution.x, iResolution.y));\n    uv -= (iResolution.xy / min(iResolution.x, iResolution.y) - vec2(1.)) / 2.;\n    uv.y = 1. - uv.y;\n\n    #ifdef ROTATION\n        float a = iTime * 0.1;\n    #else\n        float a = 0.;\n    #endif\n    viewpoint.x = sin(a) * 7.;\n    viewpoint.z = cos(a) * 7.;\n    vec3 color = ray_marching(viewpoint, rotatey(-a + M_PI) * vec3(uv - vec2(0.5, 0.5) , zNear));\n\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdSBWw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdSBzc", "name": "just21", "author": "elle", "description": "21", "tags": ["number", "box", "gyroid"], "likes": 2, "viewed": 186, "date": "1590893943", "time_retrieved": "2024-06-20T20:07:10.374213", "image_code": "#define BOX_CNT 7\n#define EPS\t0.0001\n#define MAX_STEPS 100\n#define MAX_DIST 200.0\n#define NUMBER1 0\n#define NUMBER2 1\n#define PLANE\t2\n\nstruct Intersect {\n    int\t\tidx;\n    float\tdist;};\n\nstruct Point\t{\n\tvec3\tpos;\n    vec3\tcol;};\n    \nvec3 diffCol[] = vec3[](vec3(0.0, 1.0, 0.7),\n\t\t\t\t\t\tvec3(1.0, 1.0, 0.0),\n\t\t\t\t\t\tvec3(0.8, 0.0, 0.8));\n\nfloat diff[] =  float[](0.4,  0.4,  0.5);\nfloat spec[] =  float[](0.8,  0.9,  0.2);\nfloat specPow[]=float[](64.0, 32.0, 4.0);\n\nvec3 rotate(vec3 p, float angleX, float angleY, float angleZ)\n{\n    float cosA = cos(angleY);\n\tfloat sinA = sin(angleY);\n\tvec3 r = vec3(p.x, sinA * p.z + cosA * p.y, cosA * p.z - sinA * p.y);\n    cosA = cos(angleX);\n\tsinA = sin(angleX);\n\tr = (-vec3(cosA * r.x - sinA * r.z, r.y, sinA * r.x + cosA * r.z));\n    cosA = cos(angleZ);\n\tsinA = sin(angleZ);\n\treturn (vec3(cosA * r.x - sinA * r.y, sinA * r.x + cosA * r.y, r.z));\n}\n\n//https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 repeat(in vec2 p, in float s, in vec2 lim)\n{\n    return p - s * clamp(round(p / s), -lim, lim);\n}\n\n\nfloat gyroidDist(vec3 p, float scale, float thickness, float bias)\n{\n\tp *= scale;\n    return abs(dot(sin(p), cos(p.zxy)) + bias) / (scale) - thickness;\n}\n\n\nfloat planeDist(in vec3 pos, in vec4 normal)\n{\n    return (dot(pos, normal.xyz) + normal.w);\n}\n\n\nfloat box(vec3 p)\n{\n\tfloat b = 1.0;\n\tfloat rounding = 0.6;\n\treturn length(max(abs(p) - b, 0.0)) - rounding;\n}\n\nfloat blob(float dist[BOX_CNT], int i1, int i2)\n{\n    float k = 2.2;\n    float res = 0.0;\n    for (int i = i1; i <= i2; i++)\n        res += exp(-k * dist[i]);\n\treturn -log(res)/k;\n}\n\n\nIntersect sceneDist(vec3 pos)\n{   \n    Intersect res;\n\tfloat SINt = sin(iTime * 0.5);\n    \n    float dist[BOX_CNT];\n    vec3 p1 = pos + vec3( 6.0, -6.0, 0.0);\n    vec3 p2 = pos + vec3( 3.0,  6.0, 0.0);\n    vec3 p3 = pos + vec3( 0.0, -3.0, 0.0);\n    vec3 p4 = pos + vec3( 9.0,  3.0, 0.0);\n    vec3 p5 = pos + vec3( 4.35, 0.0, 0.0);\n    \n    vec3 p6 = pos + vec3(-7.0,  1.5, 0.0);\n    vec3 p7 = pos + vec3(-4.0, -6.0, 0.0);\n\n    p1.xy = repeat(p1.xy, 2.0, vec2(1.5, 0.0));\n\tp2.xy = repeat(p2.xy, 2.0, vec2(1.5, 0.0));\n    p5.xy = repeat(p5.xy, 2.0, vec2(0.9, 0.0));\n    p6.xy = repeat(p6.xy, 2.0, vec2(0.0, 2.2));\n \n    //2\n    dist[0] = box(rotate(p1, 0.0, 8.0 * clamp(SINt - 0.0, 0.0, 0.2), 0.0));\n    dist[1] = box(rotate(p2, 0.0, 8.0 * clamp(SINt - 0.2, 0.0, 0.2), 0.0));\n    dist[2] = box(rotate(p3, 0.0, 8.0 * clamp(SINt - 0.05, 0.0, 0.2), 0.0));\n    dist[3] = box(rotate(p4, 0.0, 8.0 * clamp(SINt - 0.15, 0.0, 0.2), 0.0));\n    dist[4] = box(rotate(p5, 0.0, 8.0 * clamp(SINt - 0.1, 0.0, 0.2), 0.0));\n    //1\n    dist[5] = box(rotate(p6, 8.0 * clamp(SINt - 0.3, 0.0, 0.2), 0.0, 0.0));\n    dist[6] = box(rotate(p7, 0.0, 0.0, 8.0 * clamp(SINt - 0.25, 0.0, 0.2)));\n    \n    float distPlane = planeDist(pos, vec4(0.0, 1.0, 0.0, 100.0));\n    \n    float distBox = min(blob(dist, 0, 4), blob(dist, 4, 6));\n    \n    res.dist = min(distPlane, distBox);\n    if (res.dist == distPlane)\n        res.idx = PLANE;\n    else if (SINt <= 0.4) \n    \tres.idx = NUMBER1;\n    else\n        res.idx = NUMBER2;\n    return (res);\n}\n\nvec3 getNormal(vec3 p)\n{\n    return normalize(vec3(\n    sceneDist(vec3(p.x + EPS, p.y, p.z)).dist - sceneDist(vec3(p.x - EPS, p.y, p.z)).dist,\n    sceneDist(vec3(p.x, p.y + EPS, p.z)).dist - sceneDist(vec3(p.x, p.y - EPS, p.z)).dist,\n    sceneDist(vec3(p.x, p.y, p.z  + EPS)).dist - sceneDist(vec3(p.x, p.y, p.z - EPS)).dist));\n}\n\n\nIntersect rayMarch(vec3 ro, vec3 rd)\n{\n    Intersect d;\n    Intersect intersect;\n    for (int i = 0; i < MAX_STEPS; ++i)\n    {\n        d = sceneDist(ro + intersect.dist * rd);\n        intersect.dist += d.dist;\n        if (intersect.dist < EPS || intersect.dist >= MAX_DIST)\n            break;\n    }\n    intersect.idx = d.idx;\n    return (intersect);\n}\n\nfloat getShadow(in vec3 ro, in vec3 rd, in float min_t, in float max_t, in float k)\n{\n    float res = 1.0;\n    for (float t = min_t; t < max_t;)\n    {\n        float dist = sceneDist(ro + rd * t).dist;\n        if (dist < EPS)\n            return 0.0;\n        res = min(res, k * dist / t);\n        t += dist;\n    }\n    return (res);\n}\n\nvec3 getLight(int idx, vec3 pos, vec3 eye, vec3 lightPos)\n{\n    vec3 diffuseCol = diffCol[idx];\n    vec3 specularCol = vec3(1.0);\n    vec3 Norm = getNormal(pos);\n    vec3 Ldir = normalize(lightPos - pos);\n    vec3 View = normalize(eye - pos);\n    vec3 Refl = normalize(reflect(-Ldir, Norm));\n\n    float dotLN = dot(Ldir, Norm);\n    float dotRV = dot(Refl, View);\n\n    // light not visible\n    if (dotLN < 0.0)\n        return vec3(0.0);\n\n    // light reflection in opposite direction, apply only diffuse lighting\n    if (dotRV < 0.0)\n        return 1.7 * (diffuseCol * dotLN) * diff[idx];\n\n    vec3 half_direction = normalize(normalize(Ldir) + View);\n    float specular = pow(max(dot(half_direction, Norm), 0.0), specPow[idx]);\n    return 1.7 * diffuseCol * dotLN * diff[idx] + specularCol * specular * spec[idx];\n}\n\nPoint getColor(vec3 ro, vec3 rd, vec3 eye, vec3 lightPos, vec2 uv)\n{\n    Point point;\n    Intersect intersect = rayMarch(ro, rd);\n    point.pos = ro + intersect.dist * rd;\n    if (intersect.dist > MAX_DIST - EPS)\n    {\n        float bg = gyroidDist(rotate(vec3(uv.x, uv.y, iTime*0.3), 0.0, cos(iTime*0.01), cos(iTime*0.01)), 28.0, 0.001, 3.0);\n        point.col += abs(bg) * 6.0;\n        point.col *= vec3(rd.y + 0.4, 0.05, rd.y + 0.7); //background\n    }\n    else\n    {    \n\t\t//ambient\n        vec3 ambientCol = vec3(0.5, 0.5, 0.5);    \n    \tvec3 ambientLight = 0.3 * vec3(1.0);\n    \tpoint.col = ambientLight * ambientCol;\n\n    \t//shadow\n    \tvec3 shadowDir = normalize(lightPos - point.pos);\n    \tfloat shadow = getShadow(point.pos + shadowDir, shadowDir, 0.0, MAX_DIST, 8.0);\n\n    \t//diffuse + specular\n    \tvec3 blinn_phong = getLight(intersect.idx, point.pos, eye, lightPos) * shadow;\n    \tpoint.col += blinn_phong;\n    }\n    return point;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 aspectRatio = vec2(iResolution.x / iResolution.y, 1.0);\n    vec2 uv = aspectRatio * (fragCoord.xy / iResolution.xy - 0.5);\n    vec2 mouse = 6.4 * (iMouse.xy / iResolution.xy);\n\tfloat SINt = 0.5 + 0.5 * sin(iTime * 0.6);\n\tvec3 ro = rotate(vec3(0.0, 0.0, 30.0), SINt - 0.4 , 0.0, 0.0);\n    vec3 rd = -rotate(vec3(uv, 1.0), SINt - 0.4, 0.0, 0.0);  \n\tvec3 lightPos = rotate(vec3(5.0, -10.0, 80.0), 0.0, 0.0, 0.0);\t  \n    \n    Point point = getColor(ro, rd, ro, lightPos, uv);\n\tvec3 color = point.col;   \n    \n    vec3 rd1 = rd - (2.0 * dot(rd, getNormal(point.pos)) * getNormal(point.pos));\n    Point point2 = getColor(point.pos + rd1, rd1, ro, lightPos, uv);\n    color = mix(color, point2.col, 0.2);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdSBzc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdsBzf", "name": "Iridescent Waves", "author": "jarble", "description": "Based on [url=https://www.shadertoy.com/view/tdsBRf]this shader[/url]", "tags": ["fractal", "waves"], "likes": 1, "viewed": 244, "date": "1588798884", "time_retrieved": "2024-06-20T20:07:10.501385", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord)/iResolution.xy;\n    // Time varying pixel color\n    vec2 col = (uv*50.0);\n    for(float i = 1.0; i <5.0; i++){\n        uv += col;\n        col = cos(uv.yx*(i+sin((uv.y-uv.x)/10.0+iTime)));\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdsBzf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdSBzK", "name": "Simple Scroll of 2 Lerped Colors", "author": "vincentwing", "description": "Very simple color gradient lerping and scrolling. My first learning script.", "tags": ["gradient", "lerp", "scroll"], "likes": 1, "viewed": 100, "date": "1590360848", "time_retrieved": "2024-06-20T20:07:10.812635", "image_code": "//parameters\nconst float stretch = .1;\nconst float revolutionsPerSecond = 1.;\nconst float topAmount = .98;\n//colors\nconst vec4 red = vec4(1.,0.,0.,1.);\nconst vec4 green = vec4(0.,1.,0.,1.);\nconst vec4 blue = vec4(0.,0.,1.,1.);\nconst vec4 yellow = vec4(1.,1.,0.,1.);\nconst vec4 purple = vec4((red.xyz + blue.xyz)/2.,1.);\n//displayed colors\nconst vec4 topColorA = purple;\nconst vec4 topColorB = green;\nconst vec4 bottomColorA = purple;\nconst vec4 bottomColorB = green;\n\n//I learned a bit late about GLSL's \"mix\" function\nvec3 lerp(in vec3 colorA, in vec3 colorB, float val)\n{\n    return colorA * (1. - val) + colorB * val;\n}\n//scrolls and stretches a pixel along the x coordinate of the screen\nfloat scrollAndStretch(float x, float stretch, float revolutionsPerSecond)\n{\n    float speed = revolutionsPerSecond * iResolution.x;\n    return mod((x + speed * iTime) * stretch, iResolution.x);\n}\n//splits the screen in half (lengthwise) between color A and color B\nvec4 splitScreenColor(vec4 colorA, vec4 colorB, float x)\n{\n    return x < iResolution.x/2. ? colorA : colorB;\n}\n//displays a smooth gradient from color A to color B and back again\nvec4 gradient(vec4 colorA, vec4 colorB, float x)\n{\n    return vec4(lerp(colorA.rgb, colorB.rgb, abs(1. - 2. * x/iResolution.x)), 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(fragCoord.y>iResolution.y * (1. - clamp(topAmount, 0., 1.))){\n        fragCoord.x = scrollAndStretch(fragCoord.x, stretch, revolutionsPerSecond);\n        fragColor = gradient(topColorA, topColorB, fragCoord.x);\n        //fragColor = splitScreenColor(topColorA, topColorB, fragCoord.x);\n    }\n    else \n        fragColor = splitScreenColor(bottomColorA, bottomColorB, fragCoord.x);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdSBzK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdSBzm", "name": "shortest rotation dot (65 chars)", "author": "Smake", "description": "search for clarity )", "tags": ["rotation", "short", "golf"], "likes": 2, "viewed": 82, "date": "1589714696", "time_retrieved": "2024-06-20T20:07:10.812635", "image_code": "// thanks to Fabrice Neyret for  91 char https://www.shadertoy.com/view/XlsyWX\nvoid mainImage(out vec4 O, vec2 U)\n{\n    O += .2 / length( U/1e2 - 1.- sin( iTime  + vec2(8,0) ) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdSBzm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdsBzs", "name": "tetrahedra tunnels", "author": "abje", "description": "stolen a lot from [url]https://www.shadertoy.com/view/MdSBRc[/url].\na voxel grid with 5 tetrahedra in each voxel.", "tags": ["3d", "marchingtetrahedra"], "likes": 3, "viewed": 277, "date": "1588900966", "time_retrieved": "2024-06-20T20:07:13.102055", "image_code": "#define FAR 100.0\n\n#define antialiasing 16\n\n#define rot(A) mat2(cos(A),-sin(A),sin(A),cos(A))\n#define sqr(a) (a*a)\n#define dot2(a) dot(a,a)\n\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smax(float a, float b, float k){\n    \n   float f = max(0., 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n\n// Commutative smooth minimum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\nfloat plane(vec3 ro, vec3 rd, vec3 pln, float d) {\n    \n    float a = dot(ro,pln)-d;\n    float b = dot(rd,pln);\n    \n    if (a*b < 0.0 && b < 0.0) {\n        return -a/b;\n    }\n    \n    return FAR;\n}\n\nvec2 path(float time) {\n    time *= 0.1;\n    //random sine waves that move the camera\n    vec2 a = vec2(sin(time),cos(time*3.0));\n    a += vec2(sin(time*0.1)*5.0,cos(time*1.0)*3.0);\n    a *= sin(time*0.05);\n    a *= 4.0;\n    \n    return a;\n}\n\nfloat isoMap(vec3 p, vec3 ro){\n    \n    p += 0.001;\n    \n    float l;\n    \n    vec2 path1 = p.xy;\n    vec2 path2 = path(p.z)-p.xy;\n    \n    float tunnel = 7.0-smin(length(path1),length(path2), 3.0);\n    \n    l = tunnel;\n    \n    vec3 p2 = p*0.2;\n    \n    p2.x += iTime*0.1;\n    p.z += 2.0;\n    \n\tp2 = cos(p2*0.315*1.25 + sin(p2.zxy)); // 3D sinusoidal mutation.\n    \n    float n = dot(p2,vec3(1)); // Spherize. The result is some mutated, spherical blob-like shapes.\n    \n    l = smax(l,n-1.5, 3.0);\n    \n    return l;\n    \n}\n\n// Interpolating along the edge connecting vertices v1 and v2 with respect to the isovalue.\nvec3 inter(in vec3 p1, in vec3 p2, float v1, float v2){\n    // The interpolated point will fall somewhere between the vertex points p1 and p2.\n    // Obviously if the isovalue is closer to p1, then the interpolated point will be\n    // closer to p1, and vice versa.\n    return mix(p2, p1, v2/(v2 - v1));\n}\n\nfloat ray(vec3 ro, vec3 rd, inout vec3 normal, float maxdist)\n{\n    \n    vec3 fro = floor(ro);\n    vec3 lro = ro-fro;\n    vec3 srd = sign(rd);\n    vec3 ird = srd/rd;\n    float d = 0.0;\n    vec3 dists = abs((srd*0.5+0.5)-lro)*ird;\n    vec3 n = vec3(0);\n    \n    mat4x3 tetraf = mat4x3(\n        vec3( 1, 1, 1),\n        vec3(-1, 1,-1),\n        vec3(-1,-1, 1),\n        vec3( 1,-1,-1));\n    \n    vec3 p = lro-0.5;\n    vec3 flip = 1.0-mod(fro,2.0)*2.0;\n    \n    vec4 tetra1 = vec4(\n        dot(rd,tetraf[0]),\n        dot(rd,tetraf[1]),\n        dot(rd,tetraf[2]),\n        dot(rd,tetraf[3]));\n    \n    vec4 tetra3 = 1.0/max(abs(tetra1),0.001);\n    \n    vec4 tetra2 = vec4(\n        dot(ro,tetraf[0]),\n        dot(ro,tetraf[1]),\n        dot(ro,tetraf[2]),\n        dot(ro,tetraf[3]));\n    \n    vec4 tetra = abs((sign(tetra1)+1.0)-mod(tetra2,2.0))*tetra3;\n    \n    vec4 tetrac = step(0.5,vec4(\n        dot(p,tetraf[0]*flip),\n        dot(p,tetraf[1]*flip),\n        dot(p,tetraf[2]*flip),\n        dot(p,tetraf[3]*flip)));\n    \n    vec4 a = (1.0-2.0*tetrac);\n\n    mat4x3 sp = 0.5-0.5*mat4x3(\n        tetraf[0]*flip*a.x,\n        tetraf[1]*flip*a.y,\n        tetraf[2]*flip*a.z,\n        tetraf[3]*flip*a.w);\n    \n    vec4 ps = vec4(\n        isoMap(fro+sp[0], ro),\n        isoMap(fro+sp[1], ro),\n        isoMap(fro+sp[2], ro),\n        isoMap(fro+sp[3], ro));\n    \n    int i2 = 0;\n    \n    for (int i = 0; i < 400; i++)\n    {\n        \n        int index = int(dot(step(ps,vec4(0.0)),vec4(1,2,4,8)));\n            /*(ps[0] < 0.0 ? 1 : 0)\n             +(ps[1] < 0.0 ? 2 : 0)\n             +(ps[2] < 0.0 ? 4 : 0)\n             +(ps[3] < 0.0 ? 8 : 0);*/\n        \n        vec3 mask;\n        if (dists.x < dists.y)\n        {\n            if (dists.x < dists.z)\n            {\n                mask = vec3(1,0,0);\n            }\n            else\n            {\n                mask = vec3(0,0,1);\n            }\n        }\n        else\n        {\n            if (dists.y < dists.z)\n            {\n                mask = vec3(0,1,0);\n            }\n            else\n            {\n                mask = vec3(0,0,1);\n            }\n        }\n        \n        \n        vec4 maskt;\n        if (tetra.x < tetra.y)\n        {\n            if (tetra.x < tetra.z)\n            {\n                if (tetra.x < tetra.w)\n                {\n                    maskt = vec4(1,0,0,0);\n                }\n                else\n                {\n                    maskt = vec4(0,0,0,1);\n                }\n            }\n            else\n            {\n                if (tetra.z < tetra.w)\n                {\n                    maskt = vec4(0,0,1,0);\n                }\n                else\n                {\n                    maskt = vec4(0,0,0,1);\n                }\n            }\n        }\n        else\n        {\n            if (tetra.y < tetra.z)\n            {\n                if (tetra.y < tetra.w)\n                {\n                    maskt = vec4(0,1,0,0);\n                }\n                else\n                {\n                    maskt = vec4(0,0,0,1);\n                }\n            }\n            else\n            {\n                if (tetra.z < tetra.w)\n                {\n                    maskt = vec4(0,0,1,0);\n                }\n                else\n                {\n                    maskt = vec4(0,0,0,1);\n                }\n            }\n        }\n        \n        float lv = dot(dists,mask);\n        float lt = dot(maskt,tetra);\n        \n        float l = min(lv,lt);\n        \n        if (index != 0)\n        {\n            if (index != 15)\n            {\n                ivec3 v1, v2;\n                float f = -1.0;\n                if (index > 7) {\n                    f = -f;\n                    index = 15-index;\n                }\n                \n                if(index == 1)\n                {\n                    v1 = ivec3(0,0,0);\n                    v2 = ivec3(1,2,3);\n                }    \n                // Vertex 1 only is inside or outside.\n                else if(index == 2)\n                {\n                    v1 = ivec3(1,1,1);\n                    v2 = ivec3(0,3,2);\n                }\n                // Vertex 2 only is inside or outside.\n                else if(index == 4)\n                {\n                    v1 = ivec3(2,2,2);\n                    v2 = ivec3(0,1,3);\n                } \n                // Vertex 3 only is inside or outside.\n                else if(index == 7)\n                {\n                    v1 = ivec3(3,3,3);\n                    v2 = ivec3(0,1,2);\n                }\n                // Vertices 0 and 1 are inside or vertices 2 and 3 are inside.\n                else if(index == 3)\n                {\n                    v1 = ivec3(0,0,1);\n                    v2 = ivec3(2,3,3);\n                }\n                // Vertices 0 and 2 are inside or vertices 1 and 3 are inside.   \n                else if(index == 5)\n                {\n                    v1 = ivec3(0,2,0);\n                    v2 = ivec3(1,3,3);\n                } \n                // Vertices 1 and 2 are inside or vertices 0 and 3 are inside.\n                else if(index == 6)\n                {\n                    v1 = ivec3(0,1,2);\n                    v2 = ivec3(1,3,3);\n                }\n                \n        \t\tmat3 v = mat3(\n                    inter(sp[v1.x], sp[v2.x], ps[v1.x], ps[v2.x]),\n                    inter(sp[v1.y], sp[v2.y], ps[v1.y], ps[v2.y]),\n                    inter(sp[v1.z], sp[v2.z], ps[v1.z], ps[v2.z]));\n                \n                vec3 n = cross(v[1]-v[0],v[2]-v[0])*f*(+dot(tetrac,vec4(1))*2.0-1.0)*flip.x*flip.y*flip.z;\n                \n                float pln = plane(lro-v[0],rd,n,0.0);\n                \n                if (pln < l)\n                {\n                    normal = n;\n                    d += pln;\n                    return d;\n                }\n            }\n        }\n          \n        d += l;\n        lro += rd*l;\n        \n        dists -= l;\n        tetra -= l;\n        \n        int j;\n        \n        if (lv < lt)\n        {\n            normal = -mask*sign(rd);\n            \n            dists = dists+mask*ird;\n            lro -= srd*mask;\n            fro += srd*mask;\n            \n            vec3 p = lro-0.5;\n            \n            flip *= 1.0-mask*2.0;\n            \n            for (int j = 0; j < 4; j++)\n            {\n            \tsp[j] = abs(mask-sp[j]);\n            }\n            \n            j = int(abs(dot(mask,vec3(-7,-5,2))+dot(tetrac,vec4(0,1,2,3))))%4;\n            // mask.x  mask.y  mask.z\n            //  w 3     y 1     z 2   tetrac.x\n            //  z 2     x 0     w 3   tetrac.y\n            //  y 1     w 3     x 0   tetrac.z\n            //  x 0     z 2     y 1   tetrac.w\n        }\n        else\n        {\n            vec4 mask = maskt;\n            \n            if (flip.x > 0.0) {\n                mask = mask.wzyx;\n            }\n            \n            if (flip.y > 0.0) {\n                mask = mask.yxwz;\n            }\n            \n            if (flip.z > 0.0) {\n                mask = mask.zwxy;\n            }\n            \n            tetra += tetra3*maskt*2.0;\n            tetrac = abs(tetrac-mask);\n            \n            \n        \tj = int(dot(mask,vec4(0,1,2,3)));\n            // maskt.x maskt.y maskt.z maskt.w\n            //   0       1       2       3\n            \n            sp[j] = 1.0-sp[j];\n        }\n        ps[j] = isoMap(fro+sp[j], ro);\n        \n        if (d > maxdist) return maxdist;\n    }\n    \n    return d;\n    \n    \n    /*vec4 dists = vec4(\n        plane(ro,rd,vec3( 1, 1, 1),1.0),\n        plane(ro,rd,vec3( 1,-1,-1),1.0),\n        plane(ro,rd,vec3(-1, 1,-1),1.0),\n        plane(ro,rd,vec3(-1,-1, 1),1.0));\n    \n    return vec4(min(min(min(dists.x,dists.y),dists.z),dists.w),0,0,0);*/\n}\n\nvec4 getdata(int index) {\n    ivec2 p;\n    p.x = index%int(iResolution.x);\n    p.y = index/int(iResolution.x);\n    return texelFetch(iChannel0,p,0);\n}\n\n//hash function by Dave_Hoskins https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE3 vec3(.131, .130, .1973)\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * HASHSCALE3);\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n//shading\nvec3 shade(vec3 p, vec3 d, vec3 n, float material, float num, float dist) {\n    vec3 color = vec3(1);\n    \n    //vec3 f = floor(p*0.01+sin(p.yzx)+sin(p.zxy));\n    //color = sin(f+sin(p))*(sin(p)*0.25+0.5)+0.5;\n    \n    vec3 light = vec3(0,sin(iTime)*4.0,iTime*4.0+8.0);\n    \n    vec3 ldir = light-p;\n    float llen = length(ldir);\n    ldir /= llen;\n    \n    float shadow = dot(ldir,n)*0.8;\n    shadow /= llen*llen*0.02+1.0;\n    \n    if (shadow > 0.0) {\n        vec3 nothing;\n        float l = ray(p+ldir*0.001,ldir, nothing, llen);\n        if (l < llen) shadow *= 0.0;\n    }\n    \n    shadow = max(shadow,0.02);\n    \n    color *= shadow;\n    float fog = max(4.0-dist/FAR*4.0,0.0);\n    color *= fog;\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(path(iTime*4.0),iTime*4.0);\n    \n    vec3 rd = normalize(vec3(uv,1)+0.001);\n    \n    if (length(iMouse.xy) < 50.0) {\n        vec3 lookat = vec3(path(iTime*4.0+2.0),iTime*4.0+2.0);\n        vec3 forward = normalize(lookat-ro);\n        vec3 left = normalize(cross(vec3(path(iTime*4.0+1.0),0),forward));\n        vec3 up = cross(forward,left);\n        \n        rd = rd.x*left+rd.y*up+rd.z*forward;\n        \n    } else {\n        rd.zy *= rot(iMouse.y/iResolution.y*3.14-3.14*0.5);\n        rd.zx *= rot(iMouse.x/iResolution.x*3.14*2.0-3.14);\n    }\n    \n    int id = 3;\n    float tetranum;\n    vec3 cell;\n    vec3 nor;\n    float d = ray(ro,rd, nor, FAR);\n    nor = normalize(nor);\n    \n    // Output to screen\n    vec3 sun = normalize(vec3(1));\n    vec3 col = vec3(0);\n    if (d < FAR)\n    {\n        vec3 p = ro+rd*d;\n        \n        col = shade(p, rd, nor, cell.x+cell.y*0.348+cell.z*0.483, tetranum, d);\n    } else {\n        float sunl = max(dot(sun,rd),0.0);\n        sunl = pow(sunl,100.0);\n        \n        col = vec3(0);//mix(vec3(0.2,0.2,0.8),vec3(1.2,1.0,0.2),sunl);\n    }\n    \n    \n    col = clamp(col,0.0,1.0);\n    col = pow(col,vec3(1.0/2.2));\n    fragColor = vec4(sqrt(col),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdsBzs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdsfD8", "name": "Pink beamkiller!", "author": "friol", "description": "Watch your head.", "tags": ["raymarching", "demoscene", "volumetric", "lights"], "likes": 14, "viewed": 393, "date": "1588366564", "time_retrieved": "2024-06-20T20:07:14.932038", "image_code": "\n//\n// friol 2o2o\n// sdf functions by iq\n// music by Twisterium\n// 02.05.2020: slightly enlarged beamrays\n//\n\nconst int iterationAmount=512;\n\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nvec3 rotx(in vec3 p, float a) \n{\n\treturn vec3(p.x,\n                cos(a) * p.y + sin(a) * p.z,\n                cos(a) * p.z - sin(a) * p.y);\n}\n\nvec3 roty(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.z,\n                p.y,\n                cos(a) * p.z - sin(a) * p.x);\n}\n\nvec3 rotz(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.y,\n                cos(a) * p.y - sin(a) * p.x,\n                p.z);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdInvertedBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return -length(max(q,0.0)) - min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// 3D hash function\nfloat hash(vec3 p)\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n// 3D precedural noise\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n\n//\n//\n//\n\nvec2 SDF(vec3 r)\n{\n    float mat=0.0;\n    vec3 origR=r;\n    float rotTime=iTime/1.0;\n    float fft = texture( iChannel0, vec2(0.0,0.0) ).x;\n    float cylRad=0.15+0.1*fft;\n    \n    r=rotz(r,rotTime);\n    r=roty(r,-rotTime);\n    float t = sdCylinder(r,vec3(0.0,0.0,cylRad));\n    r=rotx(r,3.141592/2.0);\n    float t2 = sdCylinder(r,vec3(0.0,0.0,cylRad));\n    r=rotz(r,3.141592/2.0);\n    float t3 = sdCylinder(r,vec3(0.0,0.0,cylRad));\n    \n    t=min(min(t,t2),t3);\n    \n    return vec2(t,1.0);\n}\n\nvec2 SDFsolid(vec3 r)\n{\n    vec3 origR=r;\n    float t=1000.0;\n    float rotTime=iTime/1.0;\n\n    r=rotz(r,rotTime);\n    r=roty(r,-rotTime);\n\n    float fft = texture( iChannel0, vec2(0.0,0.0) ).x;\n    //float rbox = sdRoundBox(r,vec3(.5,.5,.5),.1);\n    float rbox = sdSphere(r,.69+fft*0.33);\n    float amt=10.0;\n    //rbox+=0.2*(0.5+abs(sin(iTime)))*cos(r.x*amt)*sin(r.y*amt)*cos(r.z*amt);\n    rbox+=(.10+0.05*fft)*cos(r.x*amt)*(sin(r.y*amt))*cos(r.z*amt);\n    t=rbox;\n    \n    float cyllen=.55;\n    float cylrad=.19;\n    float tcyl0=sdCappedCylinder(r,cylrad,cyllen);\n    t=min(t,tcyl0);\n    r=rotx(r,3.141592/2.0);\n    float tcyl1=sdCappedCylinder(r,cylrad,cyllen);\n    t=min(t,tcyl1);\n    r=rotz(r,3.141592/2.0);\n    float tcyl2=sdCappedCylinder(r,cylrad,cyllen);\n    t=min(t,tcyl2);\n    \n    /*\n    origR+=vec3(0.0,0.0,iTime);\n    int numq=5;\n    for (int i=0;i<numq;i++)\n    {\n        float c=.9;\n        vec3 q = vec3(origR.x,origR.y,mod(origR.z+0.5*c,c)-0.5*c);\n        vec3 rotatedr=rotz(q,(float(i)*3.141592*2.0)/float(numq));\n    \t//float abox=sdRoundBox(rotatedr-vec3(0.0,-2.3,4.0),vec3(1.82,.01,3.5),.1);\n        float box=sdSphere(rotatedr-vec3(0.0,-1.0,0.0),.2);\n        //float box=sdPlane(rotatedr-vec3(0.0,-1.0,0.0),vec4(0.0,1.0,0.0,1.0));\n        t=min(t,box);\n    }\n\t*/\n    \n    float ibox=sdInvertedBox(origR,vec3(5.5));\n    t=min(t,ibox);\n\n    if ((t==tcyl0)||(t==tcyl1)||(t==tcyl2)) return vec2(t,3.0);\n    if (t==rbox) return vec2(t,2.0);\n    return vec2(t,4.0);\n}\n\nvec3 calcNormal(vec3 pos)\n{\n\tvec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3(( mod(float((i+3)/2),2.0) ),(mod(float(i/2),2.0)),(mod(float(i),2.0)))-1.0);\n        n += e*SDFsolid(pos+0.0005*e)[0];\n    }\n    return normalize(n);\n}\n\nvec4 castRay(vec3 rayOrigin, vec3 rayDir)\n{\n    float mintlc=100000.0;\n    float lightAccum=0.0;\n    float fogAccum=0.0;\n    \n    float fft = texture( iChannel0, vec2(0.0,0.0) ).x;\n    \n    // light cone\n    float tlc = 0.0;\n    for (int i = 0; i < iterationAmount; i++)\n    {\n        vec2 res = SDF(rayOrigin + rayDir * tlc);\n        if (res[0]<0.0)\n        {\n            float fact=distance(vec3(0.),rayOrigin + rayDir * tlc);\n            float k=(abs(noise((rayOrigin+rayDir*tlc))));\n            //k*=0.02;\n            k*=0.08*fft;\n            //float cnst=0.08;\n            lightAccum+=mix(k,0.08,0.4)/fact;\n            //lightAccum+=k/fact;\n            if (tlc<mintlc) mintlc=tlc;\n        }\n        tlc += 0.0155;\n    }\n    \n    //lightAccum/=2.0;\n    //lightAccum=clamp(lightAccum,0.0,1.0);\n    \n    // solid shapes\n    float t=0.0;\n    for (int i = 0; i < iterationAmount; i++)\n    {\n        vec2 res = SDFsolid(rayOrigin + rayDir * t);\n        if (res[0] < (0.0001*t))\n        {\n    \t\tif (lightAccum>0.0)\n            {\n                vec3 vecLight=rayOrigin+rayDir*mintlc;\n                vec3 vecSolid=rayOrigin+rayDir*t;\n                \n                if (distance(rayOrigin,vecSolid)<=distance(rayOrigin,vecLight))\n                {\n                    return vec4(t,res[1],0.0,fogAccum);\n                }\n                else\n                {\n                    return vec4(t,res[1],lightAccum,fogAccum);\n                }\n            }\n            else\n            {\n                return vec4(t,res[1],0.0,fogAccum);\n            }\n        }\n\n        float n=abs(noise((rayOrigin+rayDir*tlc)));\n        //n=cos(n)*n*sin(n);\n        fogAccum+=n*0.04;\n        t += res[0];\n    }\n    \n\tif (lightAccum>0.0) return vec4(0.0,1.0,clamp(0.0,1.0,lightAccum),fogAccum);\n     \n    return vec4(-1.0,-1.0,-1.0,-1.0);\n}\n\nvec4 render(vec3 rayOrigin, vec3 rayDir, vec2 uv)\n{\n    vec3 col=vec3(0.);\n    vec3 L=normalize(vec3(0.0,0.0,-1.0));\n\n    vec4 rayHit = castRay(rayOrigin, rayDir);\n    float mat=rayHit[1];\n    vec3 pHit=rayOrigin+rayDir*rayHit[0];\n    float fft = texture( iChannel0, vec2(0.0,0.0) ).x;\n\n    if (mat==1.0)\n    {\n        col=vec3(1.0,1.0,1.0)*rayHit[2];\n    }\n    else if (((mat==2.0)||(mat==3.0))||(mat==4.0))\n    {\n        vec3 N=calcNormal(rayOrigin + rayDir * rayHit[0]);\n        if (mat==2.0) \n        {\n    \t\tfloat rotTime=iTime/4.0;\n            vec3 N2=N;\n            N2=rotz(N2,rotTime);\n            N2=roty(N2,-rotTime);\n            vec2 matuv = vec2( atan(N2.x,N2.z), acos(N2.y ) );\n\t\t\tfloat intensity=max((dot(N2,L)),0.0);\n            intensity+= pow(intensity, 2.0);            \n            //col=texture(iChannel0,matuv).rrr;\n            //col=mix(col,vec3(intensity),0.9);\n            //col=vec3(intensity*0.817,intensity*0.32,intensity*0.5);\n            vec3 colstart=vec3(0.03,0.045,0.18);\n            vec3 colenddd=vec3(0.817,0.32,0.5);\n            col=mix(colstart,colenddd,intensity/2.0);\n        }\n        else if (mat==3.0) \n        {\n        \tfloat NoL=max(dot(N, L),0.0);\n            col=vec3(1.,1.,1.)*NoL;\n        }\n        else if (mat==4.0) \n        {\n            //vec3 ll=vec3(1.0,0.0,0.0);\n        \t//float NoL=max(dot(N, ll),0.0);\n            //float intens=0.1;\n            //col=vec3(intens)*NoL;\n            //col+=vec3(0.1,0.1,0.4);\n            //col/=pHit.z/3.2;\n        \tvec2 a=vec2(1.0);\n            if ((N.z>0.01)||(N.z<-0.01))\n            {\n                a=vec2(\n                    vec2(1.)*smoothstep(-0.05, 0.05, mod(pHit.x, 1.))*\n                    smoothstep(-0.05, 0.05, mod(pHit.y, 1.)));\n            }\n            else if ((N.x>0.01)||(N.x<-0.01))\n            {\n                a=vec2(\n                    vec2(1.)*smoothstep(-0.05, 0.05, mod(pHit.y, 1.))*\n                    smoothstep(-0.05, 0.05, mod(pHit.z, 1.)));\n            }\n            else if ((N.y>0.01)||(N.y<-0.01))\n            {\n                a=vec2(\n                    vec2(1.)*smoothstep(-0.05, 0.05, mod(pHit.x, 1.))*\n                    smoothstep(-0.05, 0.05, mod(pHit.z, 1.)));\n            }\n            col = vec3(.6-a.x,.7-a.y,0.8-a.x);\n            //col*=NoL;\n        }\n        \n        // add fog\n        col+=vec3(rayHit[3]);\n        \n        // add lightrays\n        col+=vec3(rayHit[2]);\n        \n        // add beat\n        if (iTime>15.0) col+=pow(fft,16.0);\n    }\n    else\n    {\n        col=vec3(0.0,0.0,0.0);\n    }\n\n    //col=fog(col,, vec3 fxcol)\n    col=pow(col,vec3(0.58));\n    return vec4(col,1.0);\n}\n\nvec3 getCameraRayDir(vec2 uv, vec3 camPos, vec3 camTarget)\n{\n    vec3 camForward = normalize(camTarget - camPos);\n    vec3 upz=vec3(0.,1.,0.);\n    vec3 camRight = normalize(cross(upz, camForward));\n    vec3 camUp = normalize(cross(camForward, camRight));\n     \n    float fPersp = 2.0;\n    vec3 vDir = normalize(uv.x * camRight + uv.y * camUp + camForward * fPersp);\n \n    return vDir;\n}\n\nvec2 normalizeScreenCoords(vec2 screenCoord)\n{\n    vec2 result = 2.0 * (screenCoord/iResolution.xy - 0.5);\n    result.x *= iResolution.x/iResolution.y;\n    return result;\n}\n\nfloat onelinerRandom(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float myTime=iTime;\n    float rotTime=iTime*1.5;\n\tvec2 uv = normalizeScreenCoords(fragCoord);\n\n    vec3 camPos,camTarget;\n    \n    float fft = texture( iChannel0, vec2(0.0,0.0) ).x;\n    float radius=2.0+2.0*abs(sin(iTime));\n    //camPos = vec3(radius*sin(myTime),0.0,-radius*cos(myTime));\n    //camTarget = vec3(0.0,cos(myTime)*2.0,0.0);\n    camPos=vec3(radius*sin(rotTime),2.0*sin(rotTime),-radius*cos(rotTime));\n    camTarget=vec3(0.0,0.0,0.0);\n    \n    vec3 rayDir = getCameraRayDir(uv, camPos, camTarget);   \n\n    vec4 finalCol = vec4(render(camPos, rayDir,uv).xyz,1.0);\n\tfinalCol+=0.09;    \n    fragColor=vec4(finalCol.rgb, 1.0);\n}\n", "image_inputs": [{"id": "ltSGDm", "previewfilepath": "https://soundcloud.com/twisterium/trance-2-free-instrumental-background-music-creative-commons", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/twisterium/trance-2-free-instrumental-background-music-creative-commons", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdsfD8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdSfDK", "name": "Drop Boze feat Daruma-otoshi", "author": "kaiware007", "description": "It is based on the motif of a traditional Japanese toy, Daruma-otoshi.", "tags": ["raymarching"], "likes": 2, "viewed": 83, "date": "1590835843", "time_retrieved": "2024-06-20T20:07:17.901999", "image_code": "// ------------------------------------------------------------------------------------\n// Original \"thinking...\" created by kaneta : https://www.shadertoy.com/view/wslSRr\n// Original Character By MikkaBouzu : https://twitter.com/mikkabouzu777\n// ------------------------------------------------------------------------------------\n\n#define M_HALFPI 1.5707963\n#define M_PI 3.1415926\n#define M_PI2 M_PI*2.0\n\n#define M_PI03 1.04719\n#define M_PI06 2.09439\n\n#define MAT_BLACK 1.0\n#define MAT_FACE 2.0\n#define MAT_BROW 3.0\n#define MAT_CHEEP 4.0\n#define MAT_SPHERE 5.0\n#define MAT_BG 6.0\n#define MAT_CS 7.0\n\n#define AA 1\n    \nvec3 sinebow(float h) {\n    vec3 r = sin((.5-h)*M_PI + vec3(0,M_PI03,M_PI06));\n    return r*r;\n}\n\nfloat rand(vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 10000.0);\n}\n\nfloat rand3d(vec3 st)\n{\n    return fract(sin(dot(st.xyz, vec3(12.9898, 78.233, 56.787))) * 10000.0);\n}\n\n\nfloat noise(vec3 st)\n{\n\tvec3 ip = floor(st);\n    vec3 fp = smoothstep(vec3(0.), vec3(1.), fract(st));\n    \n\tvec4 a = vec4(rand3d(ip+vec3(0.)),rand3d(ip+vec3(1.,0.,0.)),rand3d(ip+vec3(0.,1.,0.)),rand3d(ip+vec3(1.,1.,0.)));\n    vec4 b = vec4(rand3d(ip+vec3(0.,0.,1.)),rand3d(ip+vec3(1.,0.,1.)),rand3d(ip+vec3(0.,1.,1.)),rand3d(ip+vec3(1.,1.,1.)));\n    \n\ta = mix(a, b, fp.z);\n\ta.xy = mix(a.xy, a.zw, fp.y);\n    \n\treturn mix(a.x, a.y, fp.x);\n}\n\nfloat easeInOutQuad(float t) {\n    if ((t *= 2.0) < 1.0) {\n        return 0.5 * t * t;\n    } else {\n        return -0.5 * ((t - 1.0) * (t - 3.0) - 1.0);\n    }\n}\n\n// Distance functions by iq\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdRoundBox(vec3 p, vec3 size, float r)\n{\n    return length(max(abs(p) - size * 0.5, 0.0)) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - r;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n// Union, Subtraction, SmoothUnion (distance, Material) \nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 opS( vec2 d1, vec2 d2 )\n{ \n    return (-d1.x>d2.x) ? vec2(-d1.x, d1.y): d2;\n}\n\nvec2 opSU( vec2 d1, vec2 d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.x-d1.x)/k, 0.0, 1.0 );\n    return vec2(mix( d2.x, d1.x, h ) - k*h*(1.0-h), h > 0.5 ? d1.y : d2.y); }\n\nvec2 opI( vec2 d1, vec2 d2 )\n{ \n    //return (d1.x>d2.x) ? d1: vec2(d2.x, d1.y);\n    return (d1.x>d2.x) ? d1: d2;\n}\n\n// Union, Subtraction, SmoothUnion (distance only)\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\nvec3 rotate(vec3 p, float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nvec3 opTwist(in vec3 p, float k )\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return vec3(q.x, q.y, q.z);\n}\n\nvec3 TwistY(vec3 p, float power)\n{\n    float s = sin(power * p.y);\n    float c = cos(power * p.y);\n    mat3 m = mat3(\n          c, 0.0,  -s,\n        0.0, 1.0, 0.0,\n          s, 0.0,   c\n    );\n    return m*p;\n}\n\nfloat ease_cubic_out(float p)\n{\n\tfloat f = (p - 1.0);\n\treturn f * f * f + 1.0;\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\nvec2 opRep2D( in vec2 p, in vec2 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\n// ç·åã¨ç¡éå¹³é¢ã®è¡çªä½ç½®ç®åº\n// rayPos : ã¬ã¤ã®éå§å°ç¹\n// rayDir : ã¬ã¤ã®åã\n// planePos : å¹³é¢ã®åº§æ¨\n// planeNormal : å¹³é¢ã®æ³ç·\nfloat GetIntersectLength(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal)\n{\n    return dot(planePos - rayPos, planeNormal) / dot(rayDir, planeNormal);\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// Mikka Boze Distance Function\n/////////////////////////////////////////////////////////////////////////////////////////////////\n#define RAD90 (M_PI * 0.5)\n\nfloat sdEar(vec3 p, float flip, float sc)\n{\n    p.x *= flip;\n    p = rotate(p, RAD90+0.25, vec3(0,0,1));    \n    return sdCappedTorus(p + vec3(0.05, 0.175, 0) * sc, vec2(sin(0.7),cos(0.7)), 0.03 * sc, 0.01 * sc);\n}\n\n#define EYE_SPACE 0.04\n\nvec3 opBendXY(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\nfloat sdMouse(vec3 p, float sc, float ms)\n{\n    vec3 q = opBendXY(p, 2.0);\n    \n    //return sdEllipsoid(q - vec3(0,0,0.2) * sc, vec3(0.05,0.015 + sin(iTime * 1.) * 0.05,0.05) * sc);\n    return sdEllipsoid(q - vec3(0,0,0.2) * sc, vec3(0.05,0.02 * ms,0.2 * ms) * sc);\n}\n\nfloat sdCheep(vec3 p, float flip, float sc)\n{\n\tp.x *= flip;\n    \n    float x = 0.05;\n    float z = -0.18;\n    p = rotate(p, M_PI * -0.6 * (p.x - x) / sc, vec3(0,1,0));\n\n    float d = sdCapsule(opBendXY(p + vec3(x, -0.01, z) * sc, 100.0/sc), vec3(-0.005,0.0,0) * sc, vec3(0.005, 0., 0) * sc, 0.0025 * sc);\n    float d1 = sdCapsule(opBendXY(p + vec3(x+0.01, -0.01, z) * sc, 200.0/sc), vec3(-0.0026,0.0,0) * sc, vec3(0.0026, 0., 0) * sc, 0.0025 * sc);\n    float d2 = sdCapsule(opBendXY(p + vec3(x+0.019, -0.015, z) * sc, -100.0/sc), vec3(-0.01,0.0,-0.01) * sc, vec3(0.0045, 0., 0.0) * sc, 0.0025 * sc);\n    \n    return opUnion(opUnion(d, d1), d2);\n}\n\nfloat sdEyeBrow(vec3 p, float flip, float sc)\n{\n    p.x *= flip;\n    \n    p = rotate(p, M_PI * -0.0225, vec3(0,0,1));\n    \n    return sdRoundBox(p + vec3(0.03, -0.14,-0.125) * sc, vec3(0.015,0.0025,0.1) * sc, 0.0001);\n}\n\nvec2 sdBoze(vec3 p, float sc, float ms)\n{    \n    vec2 result = vec2(0.);\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0) * sc, vec3(0, 0.11, 0) * sc, 0.125 * sc);\n    \n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0) * sc, 0.095 * sc, 0.05 * sc, 0.0);\n    \n    d = opSmoothUnion(d, d1, 0.1 * sc);\n    \n    // ear\n    float d2 = sdEar(p, 1.0, sc);\n    d = opUnion(d, d2);\n    float d3 = sdEar(p, -1.0, sc);\n    d = opUnion(d, d3);\n\n    vec2 head = vec2(d, MAT_FACE);\n\n\t// eye\n    float d4 = sdCapsule(p, vec3(EYE_SPACE, 0.06, 0.125) * sc, vec3( EYE_SPACE, 0.08, 0.125) * sc, 0.0175 * sc);\n    float d5 = sdCapsule(p, vec3(-EYE_SPACE,0.06, 0.125) * sc, vec3(-EYE_SPACE, 0.08, 0.125) * sc, 0.0175 * sc);\n    vec2 eye = vec2(opUnion(d4, d5), MAT_BLACK);\n    \n    // mouse\n    float d6 = sdMouse(p, sc, ms);\n    vec2 mouse = vec2(d6, MAT_BROW);\n    \n    // cheep\n    float d7 = sdCheep(p, 1.0, sc);\n    float d8 = sdCheep(p, -1.0, sc);\n    vec2 cheep = vec2(opUnion(d7, d8), MAT_CHEEP);\n\n    // eyebrows\n    float d9 = sdEyeBrow(p, 1.0, sc);\n    float d10 = sdEyeBrow(p, -1.0, sc);\n    eye.x = opUnion(eye.x, opUnion(d9, d10));\n    \n    mouse = opU(eye, mouse);\n    result = opS(mouse, head);\n    result = opU(cheep, result);\n    \n    \n    return result;\n}\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// End of Mikka Boze\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\n\nvec2 map(vec3 p)\n{\n\tvec2 result = vec2(10.);\n\n    float time = iTime * 1.0;\n    //float sc = fract(time);\n\n    vec3 q = p;\n\tq.y -= 0.3;\n    //float index = floor((q.y + 0.3) * 5.0);\n    float index2 = mod(floor(time), 5.0);\n    //float x = (sin(iTime * 2.0 * M_PI));\n    float x = fract(time);\n    float y = smoothstep(0.0, 0.25, fract(time));\n    //q.x += (index == index2) ? x * 0.5 : 0.0;\n    //q.x += index * 0.4;\n    \n    for(float i = 0.; i < 5.; i++){\n    \tvec3 q = p;\n\t\tq.y -= 0.3;\n        bool isIndex = (index2 == i);\n        q.x += isIndex ? x * 15. : 0.;\n        q.x += (index2 <= i) ? 0. : 15.;\n        q.y += isIndex ? 0.2*(index2) : (y+index2)*0.2;\n        //q.x += x;\n        //q.x += i * 0.2;\n        float b = sdRoundBox(q + vec3(0.,0.2 - i * 0.2,0.), vec3(1.0, 0.2, 1.0), 0.01);\n    \tvec2 boze = opI(sdBoze(q, 2.5, 1.0), vec2(b, MAT_CS));\n        //vec2 boze = opU(sdBoze(q, 2.5, 1.0), vec2(b, MAT_CS));\n        result = opU(result, boze);\n    }\n    // hammer\n    vec3 q2 = p;\n    float htime = time * M_PI;\n    q2 = rotate(q2, M_PI * 0.5, vec3(0,0,1));\n    //float c = sdCylinder(p, vec3(0.1,0.1,0.1));\n    q2.x += 0.1;\n    q2.yz += vec2(-0.5, 1.5);\n    q2.yz += vec2(abs(sin(htime)), abs(cos(htime))) * -1.5;\n    q2 = rotate(q2, M_HALFPI - (cos(htime*2.) * 0.5 + 0.5) * M_HALFPI, vec3(1,0,0));\n    //q2 = rotate(q2, M_PI - (sin(htime*2.) * 0.5 + 0.5)*M_HALFPI, vec3(1,0,0));\n    float c = sdCappedCylinder(q2, 0.1, 0.2);\n\tresult = opU(result, vec2(c, MAT_CS));\n\n    // next boze\n    vec3 q3 = p;\n\tfloat y2 = index2 == 4. ? y : 0.;\n    q3.y += -2. + y2 * 1.7;\n    result = opU(result, sdBoze(q3, 2.5, 1.0));\n    \n    // background\n    vec2 bg1 = vec2(sdPlane(p + vec3(0., 0., 0.), vec4(0,1,0,0)), MAT_BG);\n    //vec2 bg2 = vec2(sdPlane(p - vec3(0., 1.0, 0.), vec4(0,-1,0,0)), MAT_BG);\n    \n    result = opU(bg1, result);\n    //result = opSU(bg2, result,  0.25);\n    \n    //result.x *= s;\n    \n    return result;\n}\n\nvec3 norm(vec3 p)\n{\n    vec2 e=vec2(.001,.0);\n    return normalize(.000001+map(p).x-vec3(map(p-e.xyy).x,map(p-e.yxy).x,map(p-e.yyx).x));\n}\n\nfloat shadow(in vec3 p, in vec3 l)\n{\n    float t = 0.15;\n    float t_max = 20.0;\n    \n    float res = 1.0;\n    for (int i = 0; i < 16; ++i)\n    {\n        if (t > t_max) break;\n        \n        float d = map(p + t*l).x;\n        if (d < 0.01)\n        {\n            return 0.0;\n        }\n        t += d;\n        res = min(res, 1.0 * d / t);\n    }\n    \n    return res;\n}\n\n\nfloat ndfGGX(float NdotH, float roughness)\n{\n\tfloat alpha   = roughness * roughness;\n\tfloat alphaSq = alpha * alpha;\n\n\tfloat denom = (NdotH * NdotH) * (alphaSq - 1.0) + 1.0;\n\treturn alphaSq / (M_PI * denom * denom);\n}\n\nfloat gaSchlickG1(float theta, float k)\n{\n\treturn theta / (theta * (1.0 - k) + k);\n}\n\nfloat gaSchlickGGX(float NdotL, float NdotV, float roughness)\n{\n\tfloat r = roughness + 1.0;\n\tfloat k = (r * r) / 8.0;\n\treturn gaSchlickG1(NdotL, k) * gaSchlickG1(NdotV, k);\n}\n\nvec3 fresnelSchlick_roughness(vec3 F0, float cosTheta, float roughness) {\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nvec3 shade(vec3 pos, vec3 albedo, float metalness, float roughness, vec3 N, vec3 V, vec3 L, vec3 Lradiance)\n{\n\tvec3 H = normalize(L + V);\n\tfloat NdotV = max(0.0, dot(N, V));\n\tfloat NdotL = max(0.0, dot(N, L));\n\tfloat NdotH = max(0.0, dot(N, H));\n\t\t\n\tvec3 F0 = mix(vec3(0.04), albedo, metalness);\n\n\tvec3 F  = fresnelSchlick_roughness(F0, max(0.0, dot(H, L)), roughness);\n\tfloat D = ndfGGX(NdotH, roughness);\n\tfloat G = gaSchlickGGX(NdotL, NdotV, roughness);\n\n\tvec3 kd = mix(vec3(1.0) - F, vec3(0.0), metalness);\n\n    float shadow = shadow(pos, L);\n\tvec3 diffuseBRDF = kd * albedo / M_PI;\n\tvec3 specularBRDF = (F * D * G) / max(0.0001, 4.0 * NdotL * NdotV);\n\n\treturn (diffuseBRDF + specularBRDF) * Lradiance * NdotL * shadow;\n}\n\n// Unreal Engine Ambient BRDF Approx\n// https://www.unrealengine.com/en-US/blog/physically-based-shading-on-mobile?lang=en-US\nvec3 EnvBRDFApprox( vec3 SpecularColor, float Roughness, float NoV )\n{\n\tconst vec4 c0 = vec4( -1, -0.0275, -0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, -0.04 );\n\tvec4 r = Roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn SpecularColor * AB.x + AB.y;\n}\n\n// Specular Occlusion\n// https://media.contentapi.ea.com/content/dam/eacom/frostbite/files/course-notes-moving-frostbite-to-pbr-v2.pdf\nfloat so(float NoV, float ao, float roughness) {\n    return clamp(pow(NoV + ao, exp2(-16.0 * roughness - 1.0)) - 1.0 + ao, 0.0, 1.0);\n}\n\nvec3 calcAmbient(vec3 pos, vec3 albedo, float metalness, float roughness, vec3 N, vec3 V, float t)\n{\n\tvec3 F0 = mix(vec3(0.04), albedo, metalness);\n    vec3 F  = fresnelSchlick_roughness(F0, max(0.0, dot(N, V)), roughness);\n    vec3 kd = mix(vec3(1.0) - F, vec3(0.0), metalness);\n    \n\tfloat aoRange = t/20.0;\n\tfloat occlusion = max( 0.0, 1.0 - map( pos + N*aoRange ).x/aoRange );\n\tocclusion = min(exp2( -.8 * pow(occlusion, 2.0) ), 1.0);\n    \n    vec3 ambientColor = vec3(0.5);\n\n    vec3 diffuseAmbient = kd * albedo * ambientColor * min(1.0, 0.75+0.5*N.y) * 3.0;\n    vec3 R = reflect(-V, N);\n    \n    vec3 col = mix(vec3(1.0) * pow( 1.0-max(-R.y,0.0), 4.0), ambientColor, pow(roughness, 0.5));\n    vec3 ref = EnvBRDFApprox(F0, roughness, max(dot(N, V), 0.0));\n    vec3 specularAmbient = col * ref;\n\n    diffuseAmbient *= occlusion;\n    specularAmbient *= so(max(0.0, dot(N, V)), occlusion, roughness);\n    \n    return vec3(diffuseAmbient + specularAmbient);\n}\n\n///////////////////////////////////////////////////////////////////////\n#define MAX_MARCH 100\n\nvec3 materialize(vec3 p, vec3 ray, float depth, vec2 mat)\n{\n    vec3 col = vec3(0.12, 0., 0.4);\n    //vec3 col = min(vec3(0.12, 0., 0.4) + sinebow(fract(iTime * 1.5)) * vec3(0.1), 1.);\n    vec3 nor = norm(p);\n    vec3 sky = vec3(0.0,0.0,0.0);\n    //vec3 sky = min(sinebow(fract(iTime * 2.5 + 0.5)) * vec3(0.35) + vec3(0.3) + pow(max(1.29 - p.y, 0.), 5.), 1.);\n    //if(p.y >= 0.29) \n    if(depth > 100.)\n    {\n    \tcol = sky;\n    } else {\n        if(mat.y > 0.0){\n            vec2 index = floor(p.xz + 0.5);\n\n            float roughness, metalness;\n            if(mat.y == MAT_BLACK) {\n                col = vec3(0.0, 0.0, 0.0);\n                roughness = 0.0;\n                metalness = 0.0;\n            } else if(mat.y == MAT_FACE) {\n                col = vec3(1.0, 0.8, 0.6);\n                roughness = 0.2;\n                metalness = 0.3;\n            } else if(mat.y == MAT_BROW) {\n                col = vec3(1.0, 0, 0);\n                roughness = 0.9;\n                metalness = 0.3;\n            } else if(mat.y == MAT_CHEEP) {\n                col = vec3(1.0, 0.3, 0.5);\n                roughness = 0.1;\n                metalness = 0.6;\n        \t} else if(mat.y == MAT_BG) {\n                //col = min(sinebow(fract((index.x + index.y) * 0.175 + iTime * 0.5 + 0.5)) * vec3(0.3), 1.);\n                col = mod(index.x + index.y, 2.0) == 0.0 ? vec3(1.) : vec3(0.);\n                roughness = 0.1;\n                metalness = 0.9;\n            } else if(mat.y == MAT_CS) {\n                col = min(sinebow(iTime * 3.5), 1.);\n                //col = mod(index.x + index.y, 2.0) == 0.0 ? vec3(1.) : vec3(0.);\n                roughness = 0.2;\n                metalness = 0.3;\n            }\n            \n\n            vec3 result = vec3(0.);\n            result += shade(p, col, metalness, roughness, nor, -ray, normalize(vec3(1.)), vec3(1.0, 0.98, 0.95) * 10.)*1.0;\n            result += calcAmbient(p, col, metalness, roughness, nor, -ray, depth);\n            col = result;\n        }\n        \n        \n        //float fog = min(1.0, (1.0 / float(MAX_MARCH)) * float(mat.x))*5.0;\n    \tvec3  fog2 = vec3(0.01) * pow(depth, 2.);\n    \t//col += vec3(0.01, 0.01, 0.05) * fog;\n    \t//col += fog2 + sky * 0.1;\n        col -= fog2;\n        col = max(col, 0.);\n    }\n    \n    return col;\n}\n\nvec3 trace(vec3 p, vec3 ray)\n{\n    float t = 0.0;\n    vec3 pos;\n    vec2 mat;\n    \n    //float planeDistance = GetIntersectLength(p, ray, vec3(0.,0.3,0.), vec3(0.,1.,0.));\n    //t = planeDistance;\n    \n    int count = 0;\n    for (int i = 0; i < MAX_MARCH; i++) {\n        pos = p + ray * t;\n        mat = map(pos);\n        if (mat.x <= 0.000001) {\n        \tbreak;\n        }\n        t += mat.x;\n        count++;\n    }\n    \n    p = p + t * ray;\n    mat.x = float(count);\n    return materialize(p, ray, t, mat);\n}\n\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nfloat luminance(vec3 col)\n{\n    return dot(vec3(0.298912, 0.586611, 0.114478), col);\n}\n\nvec3 reinhard(vec3 col, float exposure, float white) {\n    col *= exposure;\n    white *= exposure;\n    float lum = luminance(col);\n    return (col * (lum / (white * white) + 1.0) / (lum + 1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n        float time = iTime * 0.5;\n        float y = 0.5;\n        //float x = mod(iTime * 0.5, 10000.);\n        //vec3 ro = vec3(cos(time)*3.0, y, sin(time)*3.0);\n        vec3 ro = vec3(2.5 + sin(time) * 0.1, y + cos(time * 2.13 + 3.5354) * 0.05, 3.0);\n        vec3 ta = vec3(-0., y, 0.);\n        //vec3 ro = vec3(sin(time * 2.3) * 0.1, cos(time * 3.23) * 0.1, 1.0);\n        //vec3 ta = vec3(-cos(time * 0.9) * 0.05, sin(time * 0.3) * 0.05 , 0.);\n        //vec3 ta = ro + vec3(cos(rotSpeed)*5.0, 0., sin(rotSpeed)*5.0);\n        mat3 c = camera(ro, ta, 0.);\n        vec3 ray = c * normalize(vec3(p, 3.5));\n        vec3 col = trace(ro, ray);\n        col = reinhard(col, 2.9, 100.0);\n        col = pow(col, vec3(1.0/0.9));\n    \n    \ttot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    fragColor = vec4(tot,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdSfDK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdsfDS", "name": "å¤§é¾ç« - RadioaktivitÃ¤t", "author": "totetmatt", "description": "Rip Florian Schneider \nhttps://www.youtube.com/watch?v=Nzzw94lrytg", "tags": ["kraftwerk"], "likes": 1, "viewed": 230, "date": "1589023148", "time_retrieved": "2024-06-20T20:07:17.901999", "image_code": "\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\nfloat sdCappedCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n  vec3  ba = b - a;\n  vec3  pa = p - a;\n  float baba = dot(ba,ba);\n  float paba = dot(pa,ba);\n  float x = length(pa*baba-ba*paba) - r*baba;\n  float y = abs(paba-baba*0.5)-baba*0.5;\n  float x2 = x*x;\n  float y2 = y*y*baba;\n  float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n  return sign(d)*sqrt(abs(d))/baba;\n}\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat vexel(vec3 p,vec3 b, float r) {\n\n        vec3 q = abs(p) -b;\n        return length(max(q,0.0) + min(max(q.x,max(q.y,q.z)),0.0)) - r;\n}\n#define ITER 64.\n#define PI 3.141592\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\nmat2 r(float a){\n    float c=cos(a),s=sin(a);\n    return mat2(c,s,-s,c);\n}\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\nfloat stripes(vec3 p) {\n     \n    float s = sin(atan(p.x,p.y)*21.) > 0.85 && p.z <-0.15 && sin(8.*iTime+p.z*50.) >-0.5 ? -sdCappedCylinder(p,vec3(0.,0.,1.),vec3(0.,0.,-1.),.89) : 10000.;\n    return s;\n\n}\nfloat radiologo(vec3 p) {\n    \n    float side = 100000.;\n    for(float i=0.;i<3.; i++){\n        \n        vec3 pos = p;\n        pos.xy*=r(i*(2.*PI/3.));\n        pos+=vec3(0,.5,-0.);\n         \n         \n        \n        side = min(side,sdTriPrism(pos,vec2(.51,.1) ));\n    }\n    \n    \n    side = max(-sdCappedCylinder(p,vec3(0,0,-.20),vec3(0,0,.20),.15),side);\n    \n    float border = max( sdCappedCylinder(p,vec3(0,0,-.20),vec3(0,0,.20),.89), -sdCappedCylinder(p,vec3(0,0,-.25),vec3(0,0,.25),.75)) ;\n    side = max(side,-border);\n    float center = sdCappedCylinder(p,vec3(0,0,-.10),vec3(0,0,.10),.1);\n    return min(min(side,center),stripes(p));\n}\n\n\nfloat SDF(vec3 p) {\n \n     return radiologo(p+vec3(0.,0.,-4.0));\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv*=.5;\n    vec3 ro =vec3(0.01,0.01,-3.),\n    p = ro,\n    rd = normalize(vec3(uv,1.)),\n    col = vec3(0);\n  \n    float shad = 0.;\n    bool hit = false;\n    \n    for(float i=0.;i < ITER; i++) {\n      float d = SDF(p);\n        if(d< 0.001) {\n            hit = true;\n            shad = i / ITER;\n            break;\n        }\n        p += d*rd;\n    }\n    \n bool anim = mod(iTime,3.) >1.;\n    bool subanim = mod(iTime,3.) >2.;\n    if(hit) {\n     if(anim) {\n        col = vec3(1.-shad,1.-shad,.1);\n        } else {\n            col = vec3(0);\n        } \n        \n    } else {\n       if(anim) {\n             if(subanim) {\n           col = vec3(0);}\n           else {\n           col = vec3(.9,0.,0.);\n           }\n        } else {\n           \n            col = vec3(1.-shad,1.-shad,.1);\n        } \n    }\n     \n     \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdsfDS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdSfDW", "name": "City city", "author": "TheGreatMurloc", "description": "city", "tags": ["city"], "likes": 2, "viewed": 106, "date": "1590051360", "time_retrieved": "2024-06-20T20:07:17.901999", "image_code": "#define LAYERS 15.\n#define WINDOWS_ROW 4.\n#define WINDOWS_COLL 8.\n\n//I know, performence is horrible and the code is garbage. I might improve it later.\n\nfloat Rect(vec2 uv, float width, float height, float blur, float centreHeight)\t//Scren height = .5\n{\n    uv.y -= height*centreHeight;\n    float col = smoothstep(width+blur,width,abs(uv.x));\n    col *= smoothstep(height+blur,height,abs(uv.y));\n    \n\treturn col;\n}\n\nvec4 glowingRect(vec2 uv, vec4 col, float scale)\n{\n    return vec4(col*(Rect(uv,.05*scale,.05*scale,0.05*scale,0.)+(col*(0.08*scale)/length(uv*.6))));\n}\n\nfloat Hash21(float pos)\n{\n\treturn fract(sin(pos*123.32)*351.102+153.15);\n}\n\nvec3 tiledWindows(vec2 pos, vec3 baseCol, float blur, vec2 scale, float a)\n{\n    float glowScale, glowAmount, windowsMask;\n    vec4 wndGlow;\n    vec2 tiledPos = pos;\n    for (float i = 0.; i < 2.; i++)\n    {\n        for (float j = 0.; j < 2.; j++)\n        {\n            tiledPos = pos+vec2((j*.25)+.125,(i*.25)+.125);\n            tiledPos *= vec2(2.,2.);\n            tiledPos = vec2(fract(tiledPos.x)-.5,fract(tiledPos.y)-.5);\n            tiledPos /= vec2(2.,2.);\n            glowScale = (2.-(scale.x*.1))*.5;\n            windowsMask = (i==1.) ? a : floor(a);\n            wndGlow = glowingRect(tiledPos,vec4(vec3(1.,.8,.5),windowsMask),glowScale);\n            glowAmount = wndGlow.a*(abs(1.-(blur*2.)));\n            baseCol = max(baseCol,mix(baseCol,wndGlow.rgb,glowAmount));\n        }\n    }\n    return baseCol;\n}\n\nvec4 cityLayer(vec2 uv, vec2 scale, vec3 col, float blur)\n{\n    blur += 0.0001;\n    uv *= scale;\n    float a = 0.;\n    float id = floor(uv.x);\n    uv.x = fract(uv.x);\n    vec2 pos = vec2(uv.x-.5,uv.y+.5);\n    float height = ((Hash21(id)+.8)*.3+1.)*.5*.31*scale.x;\n    a += Rect(pos,.5,height,blur,1.);\t//Max height = 3.1\n    \n    uv = ((uv/scale)-.5)*2.+1.;\n    //col += (uv.y*.6)*.2;\n    col -= max(((1.-uv.y*.5))*.05,0.);\n    \n    pos.y -= (height*2.);// - (Hash21(id+126.321)*.5);\n    pos.x += .5;\n    \n    float savedPosX = pos.x;\n    \n    for (float j = 0.; j < WINDOWS_COLL; j++)\n    {\n        pos.y += .2;\n        pos.x = savedPosX;\n        for (float i = 0.; i < WINDOWS_ROW; i++)\n        {\n            pos.x -= .2;\n            float glowScale = (2.-(scale.x*.1))*.5;\n            vec4 wndGlow = glowingRect(pos,vec4(vec3(1.,.8,.5),1.),glowScale);\n            float glowAmount = wndGlow.a*(abs(1.-(blur*2.)));\n            col = mix(col,wndGlow.rgb,glowAmount);\n        }\n    }\n    \n    //col = tiledWindows(pos, col, blur, scale, a);\n    \n    return vec4(col,a);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y = uv.y*9./16.;\n    uv.y -= exp((abs(uv.x-.5)-.8)*7.)*.7;\n    \n    vec4 col = vec4(.4,.3,1.,1.);\n    vec4 tree = vec4(0.);\n    \n    for (float i = 1.; i > 0.; i -= 1./LAYERS)\n    {\n        vec2 pos = vec2(uv.x+iTime*.5*(.9-i)+Hash21(i*123.51),uv.y-(i*.5)+.3);\n    \ttree = cityLayer(pos,vec2((i+.8)*10.),vec3(.15,.06,i),abs(i-.5)),1.;\n        col = mix(col,tree,tree.a);\n    }\n    \n    fragColor = vec4(col);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdSfDW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdSfRG", "name": "Day 155", "author": "jeyko", "description": "potoa", "tags": ["mdtmjvm"], "likes": 7, "viewed": 281, "date": "1590257710", "time_retrieved": "2024-06-20T20:07:17.901999", "image_code": "vec3 glow = vec3(0);\n\nfloat id = 0.;\n\nfloat sdBox(vec3 p, vec3 s){\n\tp = abs(p) - s;\n\treturn max(p.x, max(p.y,p.z));\n}\n\n\n    \n#define rot(j) mat2(cos(j),-sin(j),sin(j),cos(j))\n#define pal(a,b,c,d,e) (a + b*sin(c*d + e))\n#define AO(j) clamp(map(p+n*j).x/j,0.,1.)\n#define SSS(j) smoothstep(0.,1.,map(p+l*j).x/j)\n\n\nfloat r11(float t){return fract(sin(t*414.125)*114.12521);}\n\nfloat valN(float t){return mix(r11(floor(t)),r11(floor(t)+1.),pow(fract(t),2.));}\nvec3 nois(float t){\n    t /= 2.;\n\treturn vec3(valN(t+200.),valN(t+10.),valN(t+50.));\n\n}\n\nvec3 n;\n\nvec2 map(vec3 p){\n\tvec2 d = vec2(10e7);\n    \n    \n    vec3 sz = vec3(1.,0.5,0.5)/2.;\n    \n    //p.y += sz.y;\n    \n    \n    for(int i = 0; i < 8; i++){\n    \t\n        float b = sdBox(p, sz);\n        \n        sz *= vec3(0.74,0.5,0.74);\n        if(b<=d.x){\n        \tid = float(i);\n            d.x = b;\n        }\n        p=abs(p);\n        \n        p.xy *= rot(-0.9+n.x);\n        p.yz *= rot(0.6-n.y*0.3);\n        p.xz *= rot(-0.2+n.y*0.1);\n    \tp.xy -= sz.xy*2.;\n        \n        \n    }\n    \n    //glow += exp(-d.x*20.)*pal(0.5,0.6,vec3(0.6,0.2,0.1),1.,p.x+iTime);\n    return d;\n\n}\n\nvec3 getNormal(vec3 p){\n\tvec2 t = vec2(0.001,0.);\n\treturn normalize(map(p).x - vec3(\n    \tmap(p-t.xyy).x,\n    \tmap(p-t.yxy).x,\n    \tmap(p-t.yyx).x\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    n = nois(iTime);\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n\n    vec3 ro = vec3(0);\n    \n    ro.xz = 2.*vec2(cos(n.x*6.14),sin(n.x*6.));\n    \n    \n    vec3 lookAt = vec3(0);\n    \n    vec3 dir = normalize(lookAt - ro);\n    \n    vec3 right = normalize(cross(vec3(0,1,0), dir));\n    vec3 up = normalize(cross(dir, right));\n    \n    vec3 rd = normalize(dir + right*uv.x + up*uv.y);\n    \n    \n    \n    vec3 p = ro; float t = 0.; bool hit = false;\n    \n    vec2 d;\n    \n    for(int i = 0; i < 250; i++){\n    \td = map(p);\n        \n        \n        if(d.x < 0.001){\n        \thit = true;\n            break;\n        }\n    \n        p += rd*d.x;\n        t += d.x;\n    }\n    \n    vec3 l = normalize(vec3(1));\n    if(hit){\n    \tvec3 n = getNormal(p);\n        \n        float ao = AO(0.6)*AO(0.1)*AO(0.3)*SSS(0.8);\n        \n        vec3 c = pal(0.5, 0.5,vec3(1.,0.4,0.2),1., iTime + length(p) +id );\n        \n        col += c*ao;\n        \n    }\n    \n    col = mix(col, vec3(0.1,0.1,0.1)/7.,smoothstep(0.,1.,t*0.1));\n    \n    if(!hit){\n    \tcol += glow*0.01;\n    \n    }    \n    \n    col *= 4.;\n    \n    \n    //col *= 1. - pow(dot(p,p), 2.);\n    \n    col = pow(max(col,0.),vec3(0.4545454));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdSfRG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdsfWl", "name": "circles, push, pull", "author": "elenzil", "description": "was working on something else and made this instead.", "tags": ["circles", "pushing", "pulling"], "likes": 7, "viewed": 311, "date": "1589297459", "time_retrieved": "2024-06-20T20:07:17.901999", "image_code": "\n\n\nmat2 rot(in float rads) {\n    return mat2(sin(rads), cos(rads), -cos(rads), sin(rads));\n}\n\nfloat trapezoid(in float t) {\n    /*\n            t    f(t)\n            0    0\n            1    1\n            2    1\n            3    0\n    */\n\n    if (t < 1.0) {\n        return t;\n    }\n    if (t < 2.0) {\n        return 1.0;\n    }\n    if (t < 3.0) {\n        return 1.0 - (t - 2.0);\n    }\n    return 0.0;\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY)\n{\n    RGBA.a   = 1.0;\n\n    // float rad = (sin(iTime * 0.1) * 0.5 + 0.5) * 200.0 + 100.0;\n\n    vec2 md = abs(iMouse.xy - iResolution.xy / 2.0) / (iResolution.xy / 2.0);\n    if (length(iMouse.xy) < 50.0) {\n        md = vec2(0.8, 0.8);\n    }\n    float rad = mix(10.0, 80.0, md.x);\n    \n    float cd = length(XY - iResolution.xy / 2.0) / (iResolution.x / 2.0);\n    rad *= mix(1.0, 0.5, cd);\n\n    float lw  = 5.0;\n\n    XY -= iResolution.xy * 0.5;\n    XY *= rot(-iTime * 0.02);\n\n    vec3 cot = vec3(0.7);\n    vec3 cin = vec3(0.8);\n\n    vec2 xy = XY;\n    int it = int(iTime);\n    if (XY.x > -rad / 2.0 && XY.x < rad / 2.0) {\n        cin = vec3(1.0);\n        xy.y += rad * trapezoid(mod(iTime      , 4.0)) - 0.5;\n    }\n    if (XY.y > -rad / 2.0 && XY.y < rad / 2.0) {\n        cin = vec3(1.0);\n        xy.x += rad * trapezoid(mod(iTime + 1.0, 4.0)) - 0.5;\n    }\n\n    /*\n    ivec2 ij = ivec2(xy / rad);\n    if (ij.x == ij.y && ij.x == 0) {\n        cin = vec3(1.0, 0.0, 0.0);\n    }\n    */\n\n\n    // cin *= sin(length(xy) * 0.1) * 0.2 + 0.8;\n\n    // xy.y += sin((XY.x / rad + 0.5) * 3.1415 * 5.0 + iTime) * 2.0;\n    // xy.x += sin((XY.y / rad + 0.5) * 3.1415 * 5.0 + iTime) * 2.0;\n\n    vec2 uv = (mod(xy - rad/2.0, rad) - rad/2.0) * 2.0;\n\n\n    float c = smoothstep(0.0, lw, abs(rad - length(uv) - 2.0 * lw / 2.0));\n    vec3 rgb = vec3(c);\n\n    if (length(uv) > rad - lw) {\n        rgb *= cot;\n    }\n    else if (length(uv) < rad - lw) {\n        rgb *= cin;\n    }\n\n    \n\n    RGBA.rgb = rgb;\n}\n\n#ifdef GRIMOIRE\nout vec4 fragColor; void main() { mainImage(fragColor, gl_FragCoord.xy); }\n#endif\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdsfWl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdSfWy", "name": "Perlin Warp", "author": "alint", "description": "Simple perlin effect with gradient warp", "tags": ["noise", "perlin", "gradient", "warp"], "likes": 2, "viewed": 109, "date": "1590841256", "time_retrieved": "2024-06-20T20:07:17.908107", "image_code": "#define SHOW_GRADIENT 0\n\nvec4 permute(const in vec4 x) \n{ \n    return mod(((x * 34.0) + 1.0) * x * 1.0, 289.0); \n}\nvec2 smootherStep(const in vec2 x) \n{ \n    vec2 x2 = x * x;\n    return x2 * x * (x * (x * 6.0 - 15.0) + 10.0); \n}\n\nfloat noise(const in vec2 pos, vec2 scale)\n{\n    // classic Perlin noise based on Stefan Gustavson\n    vec2 p = pos * scale;\n    vec4 i = mod(floor(p.xyxy) + vec4(0.0, 0.0, 1.0, 1.0), scale.xyxy);\n    vec4 f = fract(p.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n    i = mod(i, 289.0); // avoid truncation effects in permutation\n\n    vec4 ix = i.xzxz;\n    vec4 iy = i.yyww;\n    vec4 fx = f.xzxz;\n    vec4 fy = f.yyww;\n    \n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 gx = 2.0 * fract(ixy * 0.0243902439) - 1.0; // 1/41 = 0.024...\n    vec4 gy = abs(gx) - 0.5;\n    vec4 tx = floor(gx + 0.5);\n    gx = gx - tx;\n    \n    vec2 g00 = vec2(gx.x,gy.x);\n    vec2 g10 = vec2(gx.y,gy.y);\n    vec2 g01 = vec2(gx.z,gy.z);\n    vec2 g11 = vec2(gx.w,gy.w);\n    \n    vec4 norm = 1.79284291400159 - 0.85373472095314 * \n    vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\n    g00 *= norm.x;\n    g01 *= norm.y;\n    g10 *= norm.z;\n    g11 *= norm.w;\n    float n00 = dot(g00, vec2(fx.x, fy.x));\n    float n10 = dot(g10, vec2(fx.y, fy.y));\n    float n01 = dot(g01, vec2(fx.z, fy.z));\n    float n11 = dot(g11, vec2(fx.w, fy.w));\n    \n    vec2 fade_xy = smootherStep(f.xy);\n    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n    float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n    return 2.3 * n_xy * 0.5 + 0.5;\n}\n\nfloat powFactor;\nfloat gradientFactor;\nfloat perlinNoise(const in vec2 pos, vec2 scale)\n{\n    // classic Perlin noise based on Stefan Gustavson\n    vec2 p = pos * scale;\n    vec4 i = mod(floor(p.xyxy) + vec4(0.0, 0.0, 1.0, 1.0), scale.xyxy);\n    vec4 f = fract(p.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n    i = mod(i, 289.0); // avoid truncation effects in permutation\n    \n    vec4 ix = i.xzxz;\n    vec4 iy = i.yyww;\n    vec4 fx = f.xzxz;\n    vec4 fy = f.yyww;\n    \n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 gx = 2.0 * fract(ixy * 0.0243902439) - 1.0; // 1/41 = 0.024...\n    vec4 gy = abs(gx) - 0.5;\n    vec4 tx = floor(gx + 0.5);\n    gx = gx - tx;\n    \n    // rotate gradients\n    gx = cos(gx * gradientFactor);\n    gy = sin(gy * gradientFactor * 2.0);\n    \n    vec2 g00 = vec2(gx.x,gy.x);\n    vec2 g10 = vec2(gx.y,gy.y);\n    vec2 g01 = vec2(gx.z,gy.z);\n    vec2 g11 = vec2(gx.w,gy.w);\n    \n    vec4 norm = 1.79284291400159 - 0.85373472095314 * \n    vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\n    g00 *= norm.x;\n    g01 *= norm.y;\n    g10 *= norm.z;\n    g11 *= norm.w;\n    float n00 = dot(g00, vec2(fx.x, fy.x));\n    float n10 = dot(g10, vec2(fx.y, fy.y));\n    float n01 = dot(g01, vec2(fx.z, fy.z));\n    float n11 = dot(g11, vec2(fx.w, fy.w));\n    \n    vec2 fade_xy = smootherStep(f.xy);\n    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n    float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n    return max(pow(2.3 * n_xy * 0.5 + 0.5, powFactor), 0.001);\n}\n\t\t\nvec2 perlinGradient(vec2 uv, vec2 scale, float spread)\n{\n    vec3 offset = vec3(1.0 / iResolution.xy, 0.0) * spread;\n    vec2 grad = vec2(0.0);\n    grad.x -= perlinNoise(uv - offset.xy, scale) * 1.0;\n    grad.x -= perlinNoise(uv - offset.xz, scale) * 2.0;\n    grad.x -= perlinNoise(uv + offset.xy * vec2(-1.0, 1.0), scale) * 1.0;\n    grad.x += perlinNoise(uv + offset.xy * vec2(1.0, -1.0), scale) * 1.0;\n    grad.x += perlinNoise(uv + offset.xz, scale) * 2.0;\n    grad.x += perlinNoise(uv + offset.xy, scale) * 1.0;\n    grad.y -= perlinNoise(uv - offset.xy, scale) * 1.0;\n    grad.y -= perlinNoise(uv - offset.zy, scale) * 2.0;\n    grad.y -= perlinNoise(uv + offset.xy * vec2(1.0, -1.0), scale) * 1.0;\n    grad.y += perlinNoise(uv + offset.xy * vec2(-1.0, 1.0), scale) * 1.0;\n    grad.y += perlinNoise(uv + offset.zy, scale) * 2.0;\n    grad.y += perlinNoise(uv + offset.xy, scale) * 1.0;\n       \n    return grad;  \n}\t\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.y;\n    \n    vec2 cells = vec2(20.0);\n    float spread = 1.0;\n    float radius = 0.25;\n    float mask = length(uv - iMouse.xy / iResolution.y) - radius;\n    mask = step(mask, 0.0) * abs(mask) / radius;\n    \n    float strength = 0.35 * noise(uv + iTime * 0.175 + mask, vec2(4.0)) - mask * 0.125;\n    float signStrength = sin(iTime * 0.5);\n    float phase = uv.x * sin(iTime * 0.25) + uv.y * cos(iTime * 0.5) + iTime * 1.15 + noise(uv + iTime, vec2(2.0, 3.0));\n\tpowFactor = 3.0 + (1.0 - mask) * 8.0 * abs(sin(phase));  \n    gradientFactor = iTime * 2.0 + 1.0;\n    \n    vec2 grad = perlinGradient(uv, cells, spread);\n\tfloat n = perlinNoise(uv + grad * strength * signStrength, cells);\n    fragColor = vec4(vec3(n), 1.0);\n    \n#if SHOW_GRADIENT == 1    \n    fragColor = vec4(grad * 0.5 + 0.5, 0.0 ,1.0);\n#endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdSfWy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdsfz2", "name": "rare flower", "author": "lomateron", "description": "a rare fractal\nclick to explore it", "tags": ["breathe"], "likes": 9, "viewed": 313, "date": "1588685895", "time_retrieved": "2024-06-20T20:07:17.908107", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 u = 2.*(2.*fragCoord-iResolution.xy)/iResolution.y;\n    float pi = 3.14159265359;\n    float p = 1.+sin(iTime)*.05;\n    u *= p;\n    vec2 v = u;\n    vec2 m = vec2(.25,.6);  if(iMouse.z>0.)m=iMouse.xy/iResolution.xy;\n    float e = 16.*m.x-8.;\n    for(float i = 0.; i < 8.*m.y; ++i)\n    {\n        u = sin(atan(u.y,u.x)*e+vec2(0.,pi*.5))*pow(length(u),e*.6);\n        u+= v/p;\n    }\n    fragColor = vec4(exp(dot(u,u)*-.1));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdsfz2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdXBD7", "name": "frac demo2", "author": "okh0056", "description": "fractal using hyperbolic tangent", "tags": ["fractal"], "likes": 3, "viewed": 284, "date": "1588970960", "time_retrieved": "2024-06-20T20:07:17.908107", "image_code": "#define ANGLE 1.275\n#define DELTA 0.01315\n#define XOFF 0.9699\n\nfloat crd(float ang) {\n    return 2.*sin(ang/2.);\n}\nvec2 crd(vec2 ang) {\n    return 2.*sin(ang/2.);\n}\n\nfloat sec(float ang) {\n    return 1./cos(ang);\n}\nvec2 sec(vec2 ang) {\n    return 1./cos(ang);\n}\n\nfloat csc(float ang) {\n    return 1./sin(ang);\n}\nvec2 csc(vec2 ang) {\n    return 1./sin(ang);\n}\n\nfloat cot(float ang) {\n    return 1./tan(ang);\n}\nvec2 cot(vec2 ang) {\n    return 1./tan(ang);\n}\n\n#define time iTime\nmat2 mm2(in float a){float c = cot(a), s = sin(a);return mat2(c,-s,s,c);}\n\n\nfloat f(vec2 p, float featureSize)\n{\n\tp.x = cos(p.x*1.3+time*0.09)*tanh(time+p.x*0.13)*2.;\t\n    p += csc(p.x*3.5)*0.4;\n    return smoothstep(-0.01,featureSize,abs(p.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x/iResolution.y;\n    float featureSize = 135./((iResolution.x*aspect+iResolution.y));\n\n    vec2 p = fragCoord.xy / iResolution.xy*4.5-1.5;\n\tp.x *= aspect;\n\tp.y = abs(p.y);\n\t\n\tvec3 col = vec3(0);\n\tfor(float i=2.;i<36.;i+=.33)\n\t{\n\t\tvec3 col2 = (cos(vec3(4.5,2.5,3.6)-i*0.45)*0.65+0.24)*(1.-f(p,featureSize));\n\t\tcol = max(col,col2);\n\t\t\n        p.x -= XOFF;\n        p.y -= tanh(time*0.31+1.5)*1.5+1.5;\n\t\tp*= mm2(i*DELTA+ANGLE);\n\t\t\n        vec2 pa = vec2(abs(p.x-0.9),abs(p.y));\n        vec2 pb = vec2(p.x,abs(p.y));\n        \n        p = mix(pa,pb,smoothstep(-.97,.97,log2(time*3.14)-1.1));\n\t}\n\tfragColor = vec4(col,.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdXBD7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdXBRS", "name": "Rainbow Noise Raymarching", "author": "ethann", "description": "Using Raymarching to render 3D noise with a rainbow palette", "tags": ["raymarching"], "likes": 2, "viewed": 123, "date": "1588467046", "time_retrieved": "2024-06-20T20:07:18.689905", "image_code": "// Define some constants\nconst int steps = 100; // This is the maximum amount a ray can march.\nconst float smallNumber = 0.001;\nconst float maxDist = 15.; // This is the maximum distance a ray can travel.\n\n// cosine based palette, 4 vec3 params\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n \nfloat hash(vec3 p)  // replace this by something better\n{\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat scene(vec3 position){\n    // So this is different from the sphere equation above in that I am\n    // splitting the position into its three different positions\n    // and adding a 10th of a cos wave to the x position so it oscillates left \n    // to right and a (positive) sin wave to the z position\n    // so it will go back and forth.\n    float sphere = noise(\n        vec3(\n            position.x + sin(iTime*.1), \n            position.y + cos(iTime*.5), \n            position.z + iTime*.5+1.0)\n        ) - sin(iTime*.3)*.05-.2;\n    \n    // This is different from the ground equation because the UV is only \n    // between -1 and 1 we want more than 1/2pi of a wave per length of the \n    // screen so we multiply the position by a factor of 10 inside the trig \n    // functions. Since sin and cos oscillate between -1 and 1, that would be \n    // the entire height of the screen so we divide by a factor of 10.\n    //float ground = position.y + sin(position.x * 5.) / 10. \n    //                          + cos(position.z * 10.) / 10. + 1.0;\n    \n    // We want to return whichever one is closest to the ray, so we return the \n    // minimum distance.\n    return sphere;\n}\n \n // Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n    float angle = 2.0*3.1415/repetitions;\n    float a = atan(p.y, p.x) + angle/2.;\n    float r = length(p);\n    float c = floor(a/angle);\n    a = mod(a,angle) - angle/2.;\n    p = vec2(cos(a), sin(a))*r;\n    // For an odd number of repetitions, fix cell index of the cell in -x direction\n    // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n    if (abs(c) >= (repetitions/2.0)) c = abs(c);\n    return c;\n}\n\n \nvec4 trace (vec3 origin, vec3 direction){\n    \n    float dist = 0.;\n    float totalDistance = 0.;\n    vec3 positionOnRay = origin;\n    \n    for(int i = 0 ; i < steps; i++){\n        \n        dist = scene(positionOnRay);\n        \n        // Advance along the ray trajectory the amount that we know the ray\n        // can travel without going through an object.\n        positionOnRay += dist * direction;\n        \n        // Total distance is keeping track of how much the ray has traveled\n        // thus far.\n        totalDistance += dist;\n        \n        // If we hit an object or are close enough to an object,\n        if (dist < smallNumber){\n            // return the distance the ray had to travel normalized so be white\n            // at the front and black in the back.\n            return 1.0 - vec4(totalDistance / maxDist);\n \n        }\n        \n        if (totalDistance > maxDist){\n \n            return vec4(0.); // Background color.\n        }\n    }\n    \n    return vec4(0.);// Background color.\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 pos = fragCoord/iResolution.xy-vec2(.5,.5);\n    \n    //pModPolar(pos,4.0);\n    \n    vec3 camOrigin = vec3(0,0,-1);\n\tvec3 rayOrigin = vec3(pos + camOrigin.xy, camOrigin.z + 1.0);\n\tvec3 dir = rayOrigin - camOrigin;\n\t\n\tvec4 dist = trace(rayOrigin,dir);\n    //palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n    vec4 color = vec4(palette(dist.x*2.0, vec3(.5),vec3(.5),vec3(1.0),vec3(0.0,.33,.67)), dist.yzw);\n    \n    fragColor = color;\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdXBRS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdXfW7", "name": "Wormhole effect", "author": "ShawnLG", "description": "This shader is a port from FreeBASIC programming language.", "tags": ["tunnel", "wormhole", "vortex"], "likes": 1, "viewed": 103, "date": "1588352269", "time_retrieved": "2024-06-20T20:07:21.053872", "image_code": "//Wormhole effect by ShawnLG, originally coded in FreeBASIC.\n\nconst vec2 v[50*9] = vec2[](// Random numbers from FreeBASIC's rnd() function.\nvec2(0.3300996,0.3290385),\nvec2(0.5324828,0.759945),\nvec2(0.6424803,0.6527108),\nvec2(0.2956116,0.9701146),\nvec2(0.9696021,0.9504358),\nvec2(0.5354314,0.6804802),\nvec2(0.07139794,0.6646097),\nvec2(0.02476472,0.4909007),\nvec2(0.0394583,0.4660093),\nvec2(0.8267168,0.8180722),\nvec2(0.8964728,0.2704488),\nvec2(0.3204605,0.4773552),\nvec2(0.437302,0.5509636),\nvec2(0.881838,0.250075),\nvec2(0.1796756,0.5502083),\nvec2(0.3810085,0.3155391),\nvec2(0.4162265,0.2768588),\nvec2(0.8479728,0.4717384),\nvec2(0.2878213,0.6768259),\nvec2(0.765179,0.474786),\nvec2(0.3388629,0.6327573),\nvec2(0.967032,0.4150589),\nvec2(0.5326403,0.6693776),\nvec2(0.7210397,0.5884476),\nvec2(0.934157,0.8131022),\nvec2(0.7924528,0.9135315),\nvec2(0.8477999,0.2787921),\nvec2(0.9675062,0.09576599),\nvec2(0.6103168,0.4258673),\nvec2(0.01053051,0.9752595),\nvec2(0.01502077,0.5717952),\nvec2(0.3351754,0.7924569),\nvec2(0.7979138,0.5113571),\nvec2(0.717841,0.2323518),\nvec2(0.743208,0.40011),\nvec2(0.7905434,0.9240817),\nvec2(0.1157196,0.4176795),\nvec2(0.2937634,0.8976976),\nvec2(0.7769904,0.1271566),\nvec2(0.6951949,0.04779153),\nvec2(0.2758411,0.3543816),\nvec2(0.5140281,0.06338978),\nvec2(0.417998,0.319551),\nvec2(0.01457345,0.862041),\nvec2(0.9613547,0.1822213),\nvec2(0.5438171,0.1801847),\nvec2(0.6193774,0.9496793),\nvec2(0.5576718,0.6286837),\nvec2(0.7891371,0.9497626),\nvec2(0.4334949,0.9285403),\nvec2(-0.6699004,-0.6709615),\nvec2(0.3300996,-0.6709615),\nvec2(1.3301,-0.6709615),\nvec2(-0.6699004,0.3290385),\nvec2(1.3301,0.3290385),\nvec2(-0.6699004,1.329039),\nvec2(0.3300996,1.329039),\nvec2(1.3301,1.329039),\nvec2(-0.4675172,-0.240055),\nvec2(0.5324828,-0.240055),\nvec2(1.532483,-0.240055),\nvec2(-0.4675172,0.759945),\nvec2(1.532483,0.759945),\nvec2(-0.4675172,1.759945),\nvec2(0.5324828,1.759945),\nvec2(1.532483,1.759945),\nvec2(-0.3575197,-0.3472892),\nvec2(0.6424803,-0.3472892),\nvec2(1.64248,-0.3472892),\nvec2(-0.3575197,0.6527108),\nvec2(1.64248,0.6527108),\nvec2(-0.3575197,1.652711),\nvec2(0.6424803,1.652711),\nvec2(1.64248,1.652711),\nvec2(-0.7043884,-0.02988541),\nvec2(0.2956116,-0.02988541),\nvec2(1.295612,-0.02988541),\nvec2(-0.7043884,0.9701146),\nvec2(1.295612,0.9701146),\nvec2(-0.7043884,1.970115),\nvec2(0.2956116,1.970115),\nvec2(1.295612,1.970115),\nvec2(-0.03039789,-0.04956424),\nvec2(0.9696021,-0.04956424),\nvec2(1.969602,-0.04956424),\nvec2(-0.03039789,0.9504358),\nvec2(1.969602,0.9504358),\nvec2(-0.03039789,1.950436),\nvec2(0.9696021,1.950436),\nvec2(1.969602,1.950436),\nvec2(-0.4645686,-0.3195198),\nvec2(0.5354314,-0.3195198),\nvec2(1.535431,-0.3195198),\nvec2(-0.4645686,0.6804802),\nvec2(1.535431,0.6804802),\nvec2(-0.4645686,1.68048),\nvec2(0.5354314,1.68048),\nvec2(1.535431,1.68048),\nvec2(-0.928602,-0.3353903),\nvec2(0.07139794,-0.3353903),\nvec2(1.071398,-0.3353903),\nvec2(-0.928602,0.6646097),\nvec2(1.071398,0.6646097),\nvec2(-0.928602,1.66461),\nvec2(0.07139794,1.66461),\nvec2(1.071398,1.66461),\nvec2(-0.9752353,-0.5090993),\nvec2(0.02476472,-0.5090993),\nvec2(1.024765,-0.5090993),\nvec2(-0.9752353,0.4909007),\nvec2(1.024765,0.4909007),\nvec2(-0.9752353,1.490901),\nvec2(0.02476472,1.490901),\nvec2(1.024765,1.490901),\nvec2(-0.9605417,-0.5339906),\nvec2(0.0394583,-0.5339906),\nvec2(1.039458,-0.5339906),\nvec2(-0.9605417,0.4660093),\nvec2(1.039458,0.4660093),\nvec2(-0.9605417,1.466009),\nvec2(0.0394583,1.466009),\nvec2(1.039458,1.466009),\nvec2(-0.1732832,-0.1819278),\nvec2(0.8267168,-0.1819278),\nvec2(1.826717,-0.1819278),\nvec2(-0.1732832,0.8180722),\nvec2(1.826717,0.8180722),\nvec2(-0.1732832,1.818072),\nvec2(0.8267168,1.818072),\nvec2(1.826717,1.818072),\nvec2(-0.1035272,-0.7295512),\nvec2(0.8964728,-0.7295512),\nvec2(1.896473,-0.7295512),\nvec2(-0.1035272,0.2704488),\nvec2(1.896473,0.2704488),\nvec2(-0.1035272,1.270449),\nvec2(0.8964728,1.270449),\nvec2(1.896473,1.270449),\nvec2(-0.6795395,-0.5226448),\nvec2(0.3204605,-0.5226448),\nvec2(1.320461,-0.5226448),\nvec2(-0.6795395,0.4773552),\nvec2(1.320461,0.4773552),\nvec2(-0.6795395,1.477355),\nvec2(0.3204605,1.477355),\nvec2(1.320461,1.477355),\nvec2(-0.562698,-0.4490364),\nvec2(0.437302,-0.4490364),\nvec2(1.437302,-0.4490364),\nvec2(-0.562698,0.5509636),\nvec2(1.437302,0.5509636),\nvec2(-0.562698,1.550964),\nvec2(0.437302,1.550964),\nvec2(1.437302,1.550964),\nvec2(-0.118162,-0.749925),\nvec2(0.881838,-0.749925),\nvec2(1.881838,-0.749925),\nvec2(-0.118162,0.250075),\nvec2(1.881838,0.250075),\nvec2(-0.118162,1.250075),\nvec2(0.881838,1.250075),\nvec2(1.881838,1.250075),\nvec2(-0.8203244,-0.4497917),\nvec2(0.1796756,-0.4497917),\nvec2(1.179676,-0.4497917),\nvec2(-0.8203244,0.5502083),\nvec2(1.179676,0.5502083),\nvec2(-0.8203244,1.550208),\nvec2(0.1796756,1.550208),\nvec2(1.179676,1.550208),\nvec2(-0.6189915,-0.6844609),\nvec2(0.3810085,-0.6844609),\nvec2(1.381009,-0.6844609),\nvec2(-0.6189915,0.3155391),\nvec2(1.381009,0.3155391),\nvec2(-0.6189915,1.315539),\nvec2(0.3810085,1.315539),\nvec2(1.381009,1.315539),\nvec2(-0.5837735,-0.7231412),\nvec2(0.4162265,-0.7231412),\nvec2(1.416227,-0.7231412),\nvec2(-0.5837735,0.2768588),\nvec2(1.416227,0.2768588),\nvec2(-0.5837735,1.276859),\nvec2(0.4162265,1.276859),\nvec2(1.416227,1.276859),\nvec2(-0.1520272,-0.5282616),\nvec2(0.8479728,-0.5282616),\nvec2(1.847973,-0.5282616),\nvec2(-0.1520272,0.4717384),\nvec2(1.847973,0.4717384),\nvec2(-0.1520272,1.471738),\nvec2(0.8479728,1.471738),\nvec2(1.847973,1.471738),\nvec2(-0.7121787,-0.3231741),\nvec2(0.2878213,-0.3231741),\nvec2(1.287821,-0.3231741),\nvec2(-0.7121787,0.6768259),\nvec2(1.287821,0.6768259),\nvec2(-0.7121787,1.676826),\nvec2(0.2878213,1.676826),\nvec2(1.287821,1.676826),\nvec2(-0.234821,-0.525214),\nvec2(0.765179,-0.525214),\nvec2(1.765179,-0.525214),\nvec2(-0.234821,0.474786),\nvec2(1.765179,0.474786),\nvec2(-0.234821,1.474786),\nvec2(0.765179,1.474786),\nvec2(1.765179,1.474786),\nvec2(-0.6611371,-0.3672427),\nvec2(0.3388629,-0.3672427),\nvec2(1.338863,-0.3672427),\nvec2(-0.6611371,0.6327573),\nvec2(1.338863,0.6327573),\nvec2(-0.6611371,1.632757),\nvec2(0.3388629,1.632757),\nvec2(1.338863,1.632757),\nvec2(-0.03296798,-0.584941),\nvec2(0.967032,-0.584941),\nvec2(1.967032,-0.584941),\nvec2(-0.03296798,0.4150589),\nvec2(1.967032,0.4150589),\nvec2(-0.03296798,1.415059),\nvec2(0.967032,1.415059),\nvec2(1.967032,1.415059),\nvec2(-0.4673597,-0.3306224),\nvec2(0.5326403,-0.3306224),\nvec2(1.53264,-0.3306224),\nvec2(-0.4673597,0.6693776),\nvec2(1.53264,0.6693776),\nvec2(-0.4673597,1.669378),\nvec2(0.5326403,1.669378),\nvec2(1.53264,1.669378),\nvec2(-0.2789603,-0.4115524),\nvec2(0.7210397,-0.4115524),\nvec2(1.72104,-0.4115524),\nvec2(-0.2789603,0.5884476),\nvec2(1.72104,0.5884476),\nvec2(-0.2789603,1.588448),\nvec2(0.7210397,1.588448),\nvec2(1.72104,1.588448),\nvec2(-0.06584305,-0.1868978),\nvec2(0.934157,-0.1868978),\nvec2(1.934157,-0.1868978),\nvec2(-0.06584305,0.8131022),\nvec2(1.934157,0.8131022),\nvec2(-0.06584305,1.813102),\nvec2(0.934157,1.813102),\nvec2(1.934157,1.813102),\nvec2(-0.2075472,-0.08646846),\nvec2(0.7924528,-0.08646846),\nvec2(1.792453,-0.08646846),\nvec2(-0.2075472,0.9135315),\nvec2(1.792453,0.9135315),\nvec2(-0.2075472,1.913532),\nvec2(0.7924528,1.913532),\nvec2(1.792453,1.913532),\nvec2(-0.1522001,-0.7212079),\nvec2(0.8477999,-0.7212079),\nvec2(1.8478,-0.7212079),\nvec2(-0.1522001,0.2787921),\nvec2(1.8478,0.2787921),\nvec2(-0.1522001,1.278792),\nvec2(0.8477999,1.278792),\nvec2(1.8478,1.278792),\nvec2(-0.03249383,-0.904234),\nvec2(0.9675062,-0.904234),\nvec2(1.967506,-0.904234),\nvec2(-0.03249383,0.09576599),\nvec2(1.967506,0.09576599),\nvec2(-0.03249383,1.095766),\nvec2(0.9675062,1.095766),\nvec2(1.967506,1.095766),\nvec2(-0.3896832,-0.5741327),\nvec2(0.6103168,-0.5741327),\nvec2(1.610317,-0.5741327),\nvec2(-0.3896832,0.4258673),\nvec2(1.610317,0.4258673),\nvec2(-0.3896832,1.425867),\nvec2(0.6103168,1.425867),\nvec2(1.610317,1.425867),\nvec2(-0.9894695,-0.02474046),\nvec2(0.01053051,-0.02474046),\nvec2(1.01053,-0.02474046),\nvec2(-0.9894695,0.9752595),\nvec2(1.01053,0.9752595),\nvec2(-0.9894695,1.97526),\nvec2(0.01053051,1.97526),\nvec2(1.01053,1.97526),\nvec2(-0.9849792,-0.4282048),\nvec2(0.01502077,-0.4282048),\nvec2(1.015021,-0.4282048),\nvec2(-0.9849792,0.5717952),\nvec2(1.015021,0.5717952),\nvec2(-0.9849792,1.571795),\nvec2(0.01502077,1.571795),\nvec2(1.015021,1.571795),\nvec2(-0.6648246,-0.2075431),\nvec2(0.3351754,-0.2075431),\nvec2(1.335175,-0.2075431),\nvec2(-0.6648246,0.7924569),\nvec2(1.335175,0.7924569),\nvec2(-0.6648246,1.792457),\nvec2(0.3351754,1.792457),\nvec2(1.335175,1.792457),\nvec2(-0.2020862,-0.4886429),\nvec2(0.7979138,-0.4886429),\nvec2(1.797914,-0.4886429),\nvec2(-0.2020862,0.5113571),\nvec2(1.797914,0.5113571),\nvec2(-0.2020862,1.511357),\nvec2(0.7979138,1.511357),\nvec2(1.797914,1.511357),\nvec2(-0.282159,-0.7676482),\nvec2(0.717841,-0.7676482),\nvec2(1.717841,-0.7676482),\nvec2(-0.282159,0.2323518),\nvec2(1.717841,0.2323518),\nvec2(-0.282159,1.232352),\nvec2(0.717841,1.232352),\nvec2(1.717841,1.232352),\nvec2(-0.256792,-0.59989),\nvec2(0.743208,-0.59989),\nvec2(1.743208,-0.59989),\nvec2(-0.256792,0.40011),\nvec2(1.743208,0.40011),\nvec2(-0.256792,1.40011),\nvec2(0.743208,1.40011),\nvec2(1.743208,1.40011),\nvec2(-0.2094566,-0.07591832),\nvec2(0.7905434,-0.07591832),\nvec2(1.790543,-0.07591832),\nvec2(-0.2094566,0.9240817),\nvec2(1.790543,0.9240817),\nvec2(-0.2094566,1.924082),\nvec2(0.7905434,1.924082),\nvec2(1.790543,1.924082),\nvec2(-0.8842804,-0.5823205),\nvec2(0.1157196,-0.5823205),\nvec2(1.11572,-0.5823205),\nvec2(-0.8842804,0.4176795),\nvec2(1.11572,0.4176795),\nvec2(-0.8842804,1.41768),\nvec2(0.1157196,1.41768),\nvec2(1.11572,1.41768),\nvec2(-0.7062366,-0.1023024),\nvec2(0.2937634,-0.1023024),\nvec2(1.293763,-0.1023024),\nvec2(-0.7062366,0.8976976),\nvec2(1.293763,0.8976976),\nvec2(-0.7062366,1.897698),\nvec2(0.2937634,1.897698),\nvec2(1.293763,1.897698),\nvec2(-0.2230096,-0.8728434),\nvec2(0.7769904,-0.8728434),\nvec2(1.77699,-0.8728434),\nvec2(-0.2230096,0.1271566),\nvec2(1.77699,0.1271566),\nvec2(-0.2230096,1.127157),\nvec2(0.7769904,1.127157),\nvec2(1.77699,1.127157),\nvec2(-0.3048051,-0.9522085),\nvec2(0.6951949,-0.9522085),\nvec2(1.695195,-0.9522085),\nvec2(-0.3048051,0.04779153),\nvec2(1.695195,0.04779153),\nvec2(-0.3048051,1.047791),\nvec2(0.6951949,1.047791),\nvec2(1.695195,1.047791),\nvec2(-0.7241589,-0.6456184),\nvec2(0.2758411,-0.6456184),\nvec2(1.275841,-0.6456184),\nvec2(-0.7241589,0.3543816),\nvec2(1.275841,0.3543816),\nvec2(-0.7241589,1.354382),\nvec2(0.2758411,1.354382),\nvec2(1.275841,1.354382),\nvec2(-0.4859719,-0.9366102),\nvec2(0.5140281,-0.9366102),\nvec2(1.514028,-0.9366102),\nvec2(-0.4859719,0.06338978),\nvec2(1.514028,0.06338978),\nvec2(-0.4859719,1.06339),\nvec2(0.5140281,1.06339),\nvec2(1.514028,1.06339),\nvec2(-0.582002,-0.680449),\nvec2(0.417998,-0.680449),\nvec2(1.417998,-0.680449),\nvec2(-0.582002,0.319551),\nvec2(1.417998,0.319551),\nvec2(-0.582002,1.319551),\nvec2(0.417998,1.319551),\nvec2(1.417998,1.319551),\nvec2(-0.9854265,-0.137959),\nvec2(0.01457345,-0.137959),\nvec2(1.014573,-0.137959),\nvec2(-0.9854265,0.862041),\nvec2(1.014573,0.862041),\nvec2(-0.9854265,1.862041),\nvec2(0.01457345,1.862041),\nvec2(1.014573,1.862041),\nvec2(-0.03864533,-0.8177787),\nvec2(0.9613547,-0.8177787),\nvec2(1.961355,-0.8177787),\nvec2(-0.03864533,0.1822213),\nvec2(1.961355,0.1822213),\nvec2(-0.03864533,1.182221),\nvec2(0.9613547,1.182221),\nvec2(1.961355,1.182221),\nvec2(-0.4561829,-0.8198153),\nvec2(0.5438171,-0.8198153),\nvec2(1.543817,-0.8198153),\nvec2(-0.4561829,0.1801847),\nvec2(1.543817,0.1801847),\nvec2(-0.4561829,1.180185),\nvec2(0.5438171,1.180185),\nvec2(1.543817,1.180185),\nvec2(-0.3806226,-0.05032074),\nvec2(0.6193774,-0.05032074),\nvec2(1.619377,-0.05032074),\nvec2(-0.3806226,0.9496793),\nvec2(1.619377,0.9496793),\nvec2(-0.3806226,1.949679),\nvec2(0.6193774,1.949679),\nvec2(1.619377,1.949679),\nvec2(-0.4423282,-0.3713163),\nvec2(0.5576718,-0.3713163),\nvec2(1.557672,-0.3713163),\nvec2(-0.4423282,0.6286837),\nvec2(1.557672,0.6286837),\nvec2(-0.4423282,1.628684),\nvec2(0.5576718,1.628684),\nvec2(1.557672,1.628684),\nvec2(-0.2108629,-0.05023742),\nvec2(0.7891371,-0.05023742),\nvec2(1.789137,-0.05023742),\nvec2(-0.2108629,0.9497626),\nvec2(1.789137,0.9497626),\nvec2(-0.2108629,1.949763),\nvec2(0.7891371,1.949763),\nvec2(1.789137,1.949763),\nvec2(-0.5665051,-0.07145965),\nvec2(0.4334949,-0.07145965),\nvec2(1.433495,-0.07145965),\nvec2(-0.5665051,0.9285403),\nvec2(1.433495,0.9285403),\nvec2(-0.5665051,1.92854),\nvec2(0.4334949,1.92854),\nvec2(1.433495,1.92854));\n\nvec3 cloudtext(in vec2 p){\n    p = mod(p, 1.);\n    float smallest = 10.0;\n    float smaller = 10.0;\n    float dtable[50*9];\n    vec2 s;\n    for(int i = 0; i<50*9-1; i++){\n        vec2 a = p - v[i];\n        float d = distance(p, v[i]);\n        dtable[i] = d + sin(atan(a.x/a.y)*30.0)*d*.1;\n        if(smallest > d){\n            smallest = d;\n            s = v[i];\n        }\n    }\n    for(int i = 0; i<50*9-1; i++){\n    \tfloat d = dtable[i];\n        if(smaller > d){\n            if(s != v[i]){\n                smaller = d;\n            }\n        }\n    }                   \n     float c = smaller + smallest;\n    if (c > 1.){\n        c = 1.;\n    }\n    return vec3(c,c,c);               \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 aspect = vec2(iResolution.x / iResolution.y,1.);\n\tvec2  p = (fragCoord.xy / iResolution.xy - .5) * aspect;\n    p = p + vec2(sin(iTime),cos(iTime))*.1;\n\tvec2  tuv = vec2(atan(p.x, p.y) / 3.141593*.5, .08 / length(p));\n\tvec2  scroll = iTime * vec2(.2, .2);\n    float l = sqrt(p.x*p.x+p.y*p.y);\n    if(l > .2){\n        l = 1.;\n    }\n    else{\n        l = l * 5. - 1.;\n        l = -(l*l) + 1.;\n    }\n\tfragColor = vec4(cloudtext( tuv + scroll).xyz * l*2., 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdXfW7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdXfWs", "name": "loading_circle", "author": "linkwwj", "description": "loading circle", "tags": ["2d"], "likes": 2, "viewed": 52, "date": "1589264050", "time_retrieved": "2024-06-20T20:07:21.053872", "image_code": "#define PI 3.1415926535897932384626433832795\n\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n\t//coord\n    uv = uv*2.0-1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    uv = rotate2d(iTime*3.0)*uv;\n    \n    float r = length(uv - vec2(0.0));\n    float theta = atan(uv.y,uv.x)+PI*1.25;\n    \n   \t\n    vec3 col = vec3(0.0);\n    col = vec3(step(0.15,r)*step(r,0.4)*sin(0.25*theta));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdXfWs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdXfWX", "name": "LEEWAY", "author": "os0450", "description": "Day 38: LEEWAY", "tags": ["dailycodingchallenge"], "likes": 4, "viewed": 68, "date": "1589166371", "time_retrieved": "2024-06-20T20:07:21.053872", "image_code": "#define ss(v) smoothstep(0.01, 0.00, v)\n\nfloat rand(float x) {\n    return fract(sin(x)*233332.32432);\n}\n\nfloat dCircle(vec2 p, float r) {\n    return length(p)-r;\n}\n\nfloat dBox(vec2 p, vec2 s) {\n    p = abs(p);\n    p -= s;\n    return max(p.x, p.y);\n}\n\nfloat dTriangle(vec2 p) {\n    float r3 = sqrt(3.0);\n    p.y -= -r3*0.25;\n    return max(-p.y, p.y+r3*abs(p.x)-r3*0.5);\n}\n\nfloat sigmoid(float x, float a) {\n    return 1.0/(1.0+exp(-a*x));\n}\n\nmat2 rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 ip = fragCoord;\n    \n    float asr = iResolution.x/iResolution.y;\n    float pi = acos(-1.0);\n    float tau = acos(-1.0)*2.0;\n    \n    float t = iTime*0.6;\n    float cy = floor(t);\n    float mcy = mod(cy, 3.0);\n    float dcy = mod(floor(t-0.5), 13.0);\n    float ph = fract(t);\n    float dph = fract(t-0.5)+0.5;\n    float sigPh = sigmoid(cos(ph*pi), -30.0);\n    \n    p *= rot(sigmoid(sin(t*0.9), 15.0)*tau);\n    \n    vec2 q = p;\n    q.x = abs(q.x);\n    q.x -= asr*(smoothstep(0.01, 0.99, sigmoid(pow(cos(ph*pi), 2.0), -4.0))*3.0)+0.015;\n    \n    vec2 d;\n    vec2 dc = vec2(dCircle(p, 0.5), dCircle(q, 0.7));\n    vec2 db = vec2(dBox(p, vec2(0.5)), dBox(q, vec2(0.7)));\n    vec2 qq = vec2(q.x, q.y-0.05);\n    vec2 dt = vec2(dTriangle(p), dTriangle(qq*0.71)/0.71);\n    \n    vec2 dFrom, dTo;\n    \n    if(mcy == 0.0) {\n        dFrom = dc;\n        dTo = db;\n    } else if(mcy == 1.0) {\n        dFrom = db;\n        dTo = dt;\n    } else {\n        dFrom = dt;\n        dTo = dc;\n    }\n    d = vec2(mix(dFrom.x, dTo.x, sigPh),\n             max(-q.x, -mix(dFrom.y, dTo.y, sigPh)));\n    \n    vec3 c = mix(vec3(rand(dcy), rand(dcy+2.0), rand(dcy+13.0)),\n                 vec3(rand(dcy+1.0), rand(dcy+2.0+1.0), rand(dcy+13.0+1.0)),\n                 sigmoid(dph, 20.0));\n    c = normalize(c);\n    \n    vec3 col = vec3(0.0);\n    col += sin(length(p))*0.2*c*ss(-d.y);\n    \n    col += ss(d.x)*c*rand(d.x+iTime)*2.0;\n    \n    int ix = int(q.x*40.0);\n    int iy = int(abs(q.y)*40.0);\n    float v = mod(float(ix^iy), (11.0+dcy))/(10.0+dcy);\n    \n    col += ss(d.y)*clamp(v, 0.2, 1.0)*pow(c, vec3(0.2));\n    col += -exp(length(p))*0.1;\n    col = pow(col, vec3(0.5));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdXfWX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tdXfzr", "name": "561_Rabbitz_1", "author": "mrabbitz", "description": "Practice with Noise and UV Mapping.  2D worley noise is UV mapped to the plane, 2D 4-octave FBM is UV mapped to the sphere, and 3D Perlin noise is applied (not UV mapped) to the box.  All of it is animated using iTime.", "tags": ["noise"], "likes": 1, "viewed": 70, "date": "1588800981", "time_retrieved": "2024-06-20T20:07:22.799323", "image_code": "vec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)),\n                 dot(p, vec2(269.5,183.3))))\n                 * 43758.5453);\n}\n\n////////////////////PERLIN//////////////////////////////////////////////////\n\nvec3 random3o3i(vec3 p) {\n  return fract(sin(vec3(dot(p, vec3(127.1, 311.7, 191.999)),\n                        dot(p, vec3(269.5, 183.3, 765.54)),\n                        dot(p, vec3(420.69, 631.2, 109.21))))\n                        * 43758.5453);\n}\n\nfloat surflet3D(vec3 p, vec3 gridPoint) {\n    // Compute the distance between p and the grid point along each axis, and warp it with a\n    // quintic function so we can smooth our cells\n    vec3 t2 = abs(p - gridPoint);\n    vec3 t = vec3(1.f) - 6.f * pow(t2, vec3(5.f)) + 15.f * pow(t2, vec3(4.f)) - 10.f * pow(t2, vec3(3.f));\n    // Get the random vector for the grid point (assume we wrote a function random2\n    // that returns a vec2 in the range [0, 1])\n    vec3 gradient = random3o3i(gridPoint) * 2. - vec3(1.);\n    // Get the vector from the grid point to P\n    vec3 diff = p - gridPoint;\n    // Get the value of our height field by dotting grid->P with our gradient\n    float height = dot(diff, gradient);\n    // Scale our height field (i.e. reduce it) by our polynomial falloff function\n    return height * t.x * t.y;\n}\n\nfloat perlinNoise3D(vec3 uv) {\n\tfloat surfletSum = 0.f;\n\t// Iterate over the four integer corners surrounding uv\n\tfor(int dx = 0; dx <= 1; ++dx) {\n\t\tfor(int dy = 0; dy <= 1; ++dy) {\n            for(int dz = 0; dz <= 1; ++dz) {\n\t\t\t\tsurfletSum += surflet3D(uv, floor(uv) + vec3(dx, dy, dz));\n            }\n\t\t}\n\t}\n\treturn surfletSum;\n}\n\n////////////////////////////////////////////////////////////////////////////\n\n////////////////////WORLEY//////////////////////////////////////////////////\n\n\nfloat WorleyNoise2D(vec2 uv) {\n    uv *= 10.0; // Now the space is 10x10 instead of 1x1. Change this to any number you want.\n    vec2 uvInt = floor(uv);\n    vec2 uvFract = fract(uv);\n    float minDist = 1.0; // Minimum distance initialized to max.\n    for(int y = -1; y <= 1; ++y) {\n        for(int x = -1; x <= 1; ++x) {\n            vec2 neighbor = vec2(float(x), float(y)); // Direction in which neighbor cell lies\n            vec2 point = random2(uvInt + neighbor); // Get the Voronoi centerpoint for the neighboring cell\n            \n            point = 0.5 + 0.5 * sin(iTime * 0.1 + 6.2831 * point); // 0 to 1 range\n            \n            vec2 diff = neighbor + point - uvFract; // Distance between fragment coord and neighborâs Voronoi point\n            float dist = length(diff);\n            minDist = min(minDist, dist);\n        }\n    }\n    return minDist;\n}\n\n/////////////////////////////////////////////////////////////////////\n\n////////////////FBM//////////////////////////////////////////////////\n\n// random1o2i\nfloat noise2D(vec2 p) {\n    return fract(sin(dot(p,vec2(127.1,311.7))) * 43758.5453);\n}\n\nfloat interpNoise2D(float x, float y) {\n    float intX = floor(x);\n    float fractX = fract(x);\n    float intY = floor(y);\n    float fractY = fract(y);\n\n    float v1 = noise2D(vec2(intX, intY));\n    float v2 = noise2D(vec2(intX + 1.0, intY));\n    float v3 = noise2D(vec2(intX, intY + 1.0));\n    float v4 = noise2D(vec2(intX + 1.0, intY + 1.0));\n\n    float i1 = mix(v1, v2, fractX);\n    float i2 = mix(v3, v4, fractX);\n    \n    return mix(i1, i2, fractY);\n}\nfloat fbm2D(float x, float y) {\n    float total = 0.0;\n    float persistence = 0.5;\n    int octaves = 4;\n\n    for(int i = 1; i <= octaves; i++) {\n        float freq = pow(2.f, float(i));\n        float amp = pow(persistence, float(i));\n\n        total += interpNoise2D(x * freq,\n                               y * freq) * amp;\n    }\n    return total;\n}\n\n////////////////////////////////////////////////////////////////\n\n\nconst int RAY_STEPS = 256;\n#define LIGHT_POS vec3(0.0, 2.45, 2.0)\n\nstruct Intersection\n{\n    vec3 p;\t\t// point of intersection in world space\n    float t;\t// t-value of ray to p\n    int objHit;\t// assign every object in scene a unique ID integer\n    vec3 color;\t// color of surface\n};\n    \nvec3 rotateX(vec3 p, float a) {\n    return vec3(p.x, cos(a) * p.y - sin(a) * p.z, sin(a) * p.y + cos(a) * p.z);\n}    \n    \n// Takes in direction, rotates it by a radians\n// result of applying a y rotation matrix to the vec3\n// rotates about y-axis\nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n    \n// b consists of width, height, and depth VECTORS (center to edge)\nfloat BoxSDF(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// point, radius, center\nfloat SphereSDF(vec3 p, float r, vec3 c) {\n    return distance(p, c) - r;\n}\n\nfloat PlaneSDF(vec3 p, vec4 n)\n{\n    return dot(p,n.xyz)+n.w;\n}\n\n#define BOX_SDF BoxSDF(pos + vec3(2.5, 0.0, 0.0), vec3(1.0))\n#define SPHERE_SDF SphereSDF(pos, 1.5, vec3(2.5, 0.0, 0.0))\n#define PLANE_SDF PlaneSDF(pos, vec4(0.0, 1.0, 0.0, 3.0))\n\n#define BOX 0\n#define SPHERE 1\n#define PLANE 2\n\nconst vec3 a = vec3(0.5, 0.5, 0.5);\nconst vec3 b = vec3(0.5, 0.5, 0.5);\nconst vec3 c = vec3(2.0, 1.0, 1.0);\nconst vec3 d = vec3(0.5, 0.2, 0.25);\n\nvec3 colorPaletteWorley(float t) {\n    return a + b * cos(6.28 * (t * c + d));\n}\n\nconst vec3 a1 = vec3(0.5, 0.5, 0.5);\nconst vec3 b1 = vec3(0.5, 0.5, 0.5);\nconst vec3 c1 = vec3(1.0, 1.0, 1.0);\nconst vec3 d1 = vec3(0.0, 0.33, 0.67);\n\nvec3 colorPalettePerlin(float t) {\n    return a1 + b1 * cos(6.28 * (t * c1 + d1));\n}\n\nconst vec3 a2 = vec3(0.5, 0.5, 0.5);\nconst vec3 b2 = vec3(0.5, 0.5, 0.5);\nconst vec3 c2 = vec3(1.0, 1.0, 1.0);\nconst vec3 d2 = vec3(0.0, 0.1, 0.2);\n\nvec3 colorPaletteFBM(float t) {\n    return a2 + b2 * cos(6.28 * (t * c2 + d2));\n}\n\nvec3 ComputeMaterial(int objHit, vec3 pos, vec3 nor, vec3 light, vec3 view)\n{\n    switch(objHit)\n    {\n        case BOX:\n        pos = pos * 5.;\n        pos = (cos(iTime / 10.) * 10.) + pos;\n        return colorPalettePerlin(perlinNoise3D(pos));\n        break;\n    \tcase SPHERE:\n        \n        // vector from center of sphere to point of intersection\n        pos = normalize(pos - vec3(2.5, 0.0, 0.0));\n        \n        float phi = atan(pos.z, pos.x);\n        if (phi < 0.0)\n        {\n            phi += 2. * 3.14159;\n        }\n        float theta = acos(pos.y);\n        \n        vec2 newUV = vec2(1. - phi / (2. * 3.14159), 1. - theta / 3.14159);\n        \n        newUV *= 7.;\n        newUV = (cos(iTime / 10.) * 10.) + newUV;\n        \n    \treturn colorPaletteFBM(fbm2D(newUV.x, newUV.y));\n    \tbreak;\n    \tcase PLANE:\n        \n        // https://gamedev.stackexchange.com/questions/172352/finding-texture-coordinates-for-plane\n        vec3 e1 = normalize(cross(vec3(0.,1.,0.), vec3(1.,0.,0.)));\n        vec3 e2 = normalize(cross(vec3(0.,1.,0.), e1));\n        float u = dot(e1, pos);\n\t\tfloat v = dot(e2, pos);\n        \n    \treturn colorPaletteWorley(WorleyNoise2D(vec2(u, v) / 20.0));\n    \tbreak;\n    \tcase -1:\n    \t// Background\n    \treturn vec3(0.0);\n    \tbreak;\n\t}\n\treturn vec3(1.0);    \n}\n\nfloat SceneSDF(vec3 pos, vec3 lightPos)\n{\n    float t = BOX_SDF;\n    t = min(t,SPHERE_SDF);\n    t = min(t,PLANE_SDF);\n    return t;\n}\n\nvec3 ComputeNormal(vec3 pos, vec3 lightPos) {\n    vec2 offset = vec2(0.0, 0.001);\n    return normalize( vec3( SceneSDF(pos + offset.yxx, lightPos) - SceneSDF(pos - offset.yxx, lightPos),\n                            SceneSDF(pos + offset.xyx, lightPos) - SceneSDF(pos - offset.xyx, lightPos),\n                            SceneSDF(pos + offset.xxy, lightPos) - SceneSDF(pos - offset.xxy, lightPos)\n                          )\n                    );\n}\n    \nvoid SceneSDF(vec3 pos, out float t, out int objHit, vec3 lightPos)\n{\n    t = BOX_SDF;\n    objHit = BOX;\n    \n    float t2;\n    if((t2 = SPHERE_SDF) < t)\n    {\n        t = t2;\n        objHit = SPHERE;\n    }\n    if((t2 = PLANE_SDF) < t)\n    {\n        t = t2;\n        objHit = PLANE;\n    }\n}\n    \nvoid RayMarch(vec3 origin, vec3 dir, out float t, out int objHit, vec3 lightPos)\n{\n    // starts slightly > 0\n    // so that if we march from a different point in the scene that isnt the camera\n    // we dont immediately intersect ourselves\n    t = 0.001;\n    // ray march not to a certain distance but for a certain number of iterations\n    for (int i = 0; i < RAY_STEPS; ++i)\n    {\n        vec3 pos = origin + t * dir;\n        // minimum distance that pos is from all SDFs in the scene\n        float m;\n        SceneSDF(pos, m, objHit, lightPos);\n        if(m < 0.01)\n        {\n            return;\n        }\n        t += m;\n    }\n    // hit nothing\n    t = -1.0;\n    objHit = -1;\n}\n    \nIntersection SceneIntersection(vec3 eye, vec3 dir, vec3 lightPos)\n{\n    float t;\n    int objHit;\n    // Marches along ray to find point of intersection\n    RayMarch(eye, dir, t, objHit, lightPos);\n    \n    vec3 isect = eye + t * dir;\n    vec3 nor = ComputeNormal(isect, lightPos);\n    vec3 lightDir = normalize(lightPos - isect);\n    \n    vec3 surfaceColor = ComputeMaterial(objHit, isect, nor, lightDir, normalize(eye - isect));\n        \n    vec3 normalAsColor = 0.5 * (nor + vec3(1.0));\n        \n    return Intersection(isect, t, objHit, surfaceColor);\n}\n    \nconst vec3 worldUp = vec3(0,1,0);\nvoid RayCast(vec2 ndc, out vec3 eye, out vec3 dir, out vec3 ref)\n{\n    eye = vec3(0.0, 5.0, 15.0);\n    ref = vec3(0.0, 0.0, 0.0);\n    \n    float len = tan(3.14159 * 0.08) * distance(eye, ref);\n   \n    vec3 H = normalize(cross(worldUp, ref - eye));\n    vec3 V = normalize(cross(H, eye - ref));\n    V *= len;\n    H *= len * iResolution.x / iResolution.y;\n    vec3 p = ref + ndc.x * H + ndc.y * V;\n    dir = normalize(p - eye);\n}\n\n// mainImage: present in every single shader program on shadertoy\n// outputs: the fragment color for the fragment it is operating on\n// takes in: the pixel space coordinates of the fragment it is coloring\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // iResolution: width and height of screen in pixels (on bottom toolbar of image output)\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Convert to range -1 to 1 for x and y\n    // Normalized Device Coordinates w.r.t. the center of the screen being (0,0)\n    uv = (uv * 2.0) - vec2(1.0);\n    \n    Intersection aaIsects[4];\n    vec3 eye, dir, ref;\n    int idx = 0;\n    for (float i = 0.0; i < 1.0; i += 0.5)\n    {\n        for (float j = 0.0; j < 1.0; j += 0.5)\n        {\n            RayCast(uv + vec2(i, j) / iResolution.xy, eye, dir, ref);\n            aaIsects[idx++] = SceneIntersection(eye, dir, LIGHT_POS);\n        }\n    }\n                                                                          \n    vec3 avgColor = vec3(0.0);\n    for (int i = 0; i < 4; ++i)\n    {\n        avgColor += aaIsects[i].color;\n    }\n    avgColor *= 0.25;\n    \n    fragColor = vec4(avgColor * step(0.0, aaIsects[0].t), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tdXfzr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tlGXzV", "name": "Shader1_Dela Vega", "author": "zerotojiro", "description": "rotating Lightsaber", "tags": ["midterms"], "likes": 3, "viewed": 213, "date": "1588323518", "time_retrieved": "2024-06-20T20:07:22.799323", "image_code": "mat2 rotate2d(float angle)\n{\n    return mat2(cos(angle),-sin(angle), sin(angle), cos(angle));\n}\n\nfloat rect (vec2 uv, vec2 pos, float blurVal, vec2 size)\n{\n\tfloat value = smoothstep(pos.x - size.x/2., (pos.x - size.x/2.) + blurVal, uv.x) \n        \t\t- smoothstep(pos.x + size.x/2., (pos.x + size.x/2.) + blurVal,uv.x);\n    \n    return value *= smoothstep(pos.y, pos.y + blurVal, uv.y) \n        \t\t  - smoothstep(pos.y + size.y, (pos.y+size.y) + blurVal, uv.y);\n}\n\nfloat circle(vec2 uv,float radius, vec2 pos)\n{\n     \n    float d = distance(pos,uv);\n    float value = step(radius,d);\n    \n    return value; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tfloat ratio = iResolution.x/iResolution.y;\n    \n   \tvec2 bladePos = vec2(.495*ratio,.48);\n    vec2 handlePos = vec2(.499*ratio,.34);\n    vec2 shinePos = vec2(.494*ratio,.48);\n    vec2 circlePos = vec2(.499*ratio,.44);\n    vec2 hiltPos = vec2(.5*ratio,.48);\n    vec2 bottomPos = vec2(.5*ratio,.34);\n    \n    uv.x *= ratio;\n    \n    uv-=bladePos;\n    uv*= rotate2d(sin(iTime)*5.);\n    uv+=bladePos;\n    \n    vec3 blade = vec3(rect(uv, bladePos, 0.02, vec2(.029, 0.7)));\n    vec3 handle = vec3(rect(uv, handlePos, 0.0, vec2(.029, 0.15)));\n    vec3 shine = vec3(rect(uv, shinePos, 0.02, vec2(.01, 0.7)));\n    float button = circle(uv, 0.01, circlePos);\n    vec3 hilt = vec3(rect(uv, hiltPos, 0.0, vec2(.05, .015)));\n    vec3 bottom = vec3(rect(uv, bottomPos, 0.0, vec2(.05, .015)));\n    \n    vec3 col = mix(vec3(.0), vec3(0., 0., 1.), blade);\n    col = mix(col, vec3(1., 1., 1.), shine);\n    col += mix(col, vec3(.3), handle);\n    col += mix(col, vec3(.0), button);\n    col = mix(col, vec3(.2), hilt);\n    col = mix(col, vec3(.2), bottom);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tlGXzV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ts2BRR", "name": "Animated 2D Perlin Noise", "author": "dust", "description": "An iteration on - https://www.shadertoy.com/view/MldfzB; seeing what I can get with minimal passes and animating by playing with the corner gradients instead of adding another dimension.", "tags": ["procedural", "2d", "noise", "perlin", "animated"], "likes": 2, "viewed": 827, "date": "1589395931", "time_retrieved": "2024-06-20T20:07:23.308589", "image_code": "// Specialty Perlin ease-in/out function\nvec2 soften(vec2 t)\n{\n    vec2 t3 = t * t * t;\n    vec2 t4 = t3 * t;\n    vec2 t5 = t4 * t;\n    return 6.0f * t5 - \n           15.0f * t4 +\n           10.0f * t3;\n}\n\n// Slow, high-quality 2D hash adapted from nimitz's\n// WebGL2 hash collection\n// (https://www.shadertoy.com/view/Xt3cDn)\nvec2 hash22(uvec2 p)\n{\n    const uint PRIME32_2 = 2246822519U, PRIME32_3 = 3266489917U;\n\tconst uint PRIME32_4 = 668265263U, PRIME32_5 = 374761393U;\n    uint h32 = p.y + PRIME32_5 + p.x*PRIME32_3;\n    h32 = PRIME32_4*((h32 << 17) | (h32 >> (32 - 17))); //Initial testing suggests this line could be omitted for extra perf\n    h32 = PRIME32_2*(h32^(h32 >> 15));\n    h32 = PRIME32_3*(h32^(h32 >> 13));\n    h32 = h32^(h32 >> 16);\n    uvec2 rz = uvec2(h32, h32*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU)) / float(0x7fffffff);\n}\n\n// Perlin noise function, taking corner + pixel positions as input\nfloat Perlin(vec2 uv, vec2 fragCoord)\n{\n    // Find corner coordinates\n    vec4 lwrUpr = vec4(floor(uv), ceil(uv)); \n    mat4x2 crnrs = mat4x2(lwrUpr.xw, lwrUpr.zw,\n                          lwrUpr.xy, lwrUpr.zy);\n    \n    // Generate gradients at each corner\n    vec2 mUV = iMouse.zw / iResolution.xy;\n    vec2 scTime = abs(vec2(sin(iTime) + mUV.x, cos(iTime) + mUV.y)) + vec2(0.75);\n    mat4x2 dirs = mat4x2(hash22(uvec2(floatBitsToUint(crnrs[0]))) * scTime,\n                         hash22(uvec2(floatBitsToUint(crnrs[1]))) * scTime,\n                         hash22(uvec2(floatBitsToUint(crnrs[2]))) * scTime,\n                         hash22(uvec2(floatBitsToUint(crnrs[3]))) * scTime);\n    \n    // Shift gradients into [-1...0...1]\n    dirs *= 2.0f;\n    dirs -= mat4x2(vec2(1.0f), vec2(1.0f), \n                   vec2(1.0f), vec2(1.0f));\n    \n    // Normalize\n    dirs[0] = normalize(dirs[0]);\n    dirs[1] = normalize(dirs[1]);\n    dirs[2] = normalize(dirs[2]);\n    dirs[3] = normalize(dirs[3]);\n    \n    // Find per-cell pixel offset\n    vec2 offs = mod(uv, 1.0f);\n    \n    // Compute gradient weights for each corner; take each offset relative\n    // to corners on the square in-line\n    vec4 values = vec4(dot(dirs[0], (offs - vec2(0.0f, 1.0f))),\n                       dot(dirs[1], (offs - vec2(1.0f))),\n                       dot(dirs[2], (offs - vec2(0.0f))),\n                       dot(dirs[3], (offs - vec2(1.0f, 0.0f))));\n    \n    // Return smoothly interpolated values\n    vec2 softXY = soften(offs);\n    return mix(mix(values.z, \n                   values.w, softXY.x),\n               mix(values.x, \n                   values.y, softXY.x),\n               softXY.y);\n}\n\n#define GEOM_NOISE\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to [1.0 / [cellSize]])\n    const float cellSize = 0.0825f;\n    vec2 uv = vec2(fragCoord / iResolution.y);\n    uv = uv / cellSize;\n            \n    // Generate fractional noise\n    float f = 0.0f;\n    float ampl = 1.87f; // Output noise intensity\n    for (int i = 0; i < 2; i += 1)\n    {\n        float p = Perlin(uv/* + texture(iChannel0, uv).rg*/, fragCoord);\n    \tf = ampl * p * (1.0f - abs(p));\n        #ifdef GEOM_NOISE\n        \tuv = uv * p;\n        #endif\n    }\n    \n    // Output to screen\n    fragColor = vec4(vec3(f), 1.0);\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ts2BRR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ts2BRW", "name": "metaboze again", "author": "kaiware007", "description": "metaboze again", "tags": ["raymarching"], "likes": 11, "viewed": 102, "date": "1590040062", "time_retrieved": "2024-06-20T20:07:25.496649", "image_code": "// ------------------------------------------------------------------------------------\n// Original \"thinking...\" created by kaneta : https://www.shadertoy.com/view/wslSRr\n// Original Character By MikkaBouzu : https://twitter.com/mikkabouzu777\n// ------------------------------------------------------------------------------------\n\n#define M_PI 3.1415926\n#define M_PI2 M_PI*2.0\n\n#define MAT_BLACK 1.0\n#define MAT_FACE 2.0\n#define MAT_BROW 3.0\n#define MAT_CHEEP 4.0\n#define MAT_SPHERE 5.0\n#define MAT_BG 6.0\n\n#define AA 1\n\n// Distance functions by iq\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdRoundBox(vec3 p, vec3 size, float r)\n{\n    return length(max(abs(p) - size * 0.5, 0.0)) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - r;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\n// Union, Subtraction, SmoothUnion (distance, Material) \nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 opS( vec2 d1, vec2 d2 )\n{ \n    return (-d1.x>d2.x) ? vec2(-d1.x, d1.y): d2;\n}\n\nvec2 opSU( vec2 d1, vec2 d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.x-d1.x)/k, 0.0, 1.0 );\n    return vec2(mix( d2.x, d1.x, h ) - k*h*(1.0-h), h > 0.5 ? d1.y : d2.y); }\n\n// Union, Subtraction, SmoothUnion (distance only)\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\nvec3 rotate(vec3 p, float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nvec3 opTwist(in vec3 p, float k )\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return vec3(q.x, q.y, q.z);\n}\n\nvec3 TwistY(vec3 p, float power)\n{\n    float s = sin(power * p.y);\n    float c = cos(power * p.y);\n    mat3 m = mat3(\n          c, 0.0,  -s,\n        0.0, 1.0, 0.0,\n          s, 0.0,   c\n    );\n    return m*p;\n}\n\nfloat ease_cubic_out(float p)\n{\n\tfloat f = (p - 1.0);\n\treturn f * f * f + 1.0;\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// Mikka Boze Distance Function\n/////////////////////////////////////////////////////////////////////////////////////////////////\n#define RAD90 (M_PI * 0.5)\n\nfloat sdEar(vec3 p, float flip, float sc)\n{\n    p.x *= flip;\n    p = rotate(p, RAD90+0.25, vec3(0,0,1));    \n    return sdCappedTorus(p + vec3(0.05, 0.175, 0) * sc, vec2(sin(0.7),cos(0.7)), 0.03 * sc, 0.01 * sc);\n}\n\n#define EYE_SPACE 0.04\n\nvec3 opBendXY(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\nfloat sdMouse(vec3 p, float sc)\n{\n    vec3 q = opBendXY(p, 2.0);\n    \n    return sdEllipsoid(q - vec3(0,0,0.2) * sc, vec3(0.05,0.015 + sin(iTime * 0.5 * M_PI2) * 0.05,0.05) * sc);\n    //return sdEllipsoid(q - vec3(0,0,0.2) * sc, vec3(0.05,0.015,0.05) * sc);\n}\n\nfloat sdCheep(vec3 p, float flip, float sc)\n{\n\tp.x *= flip;\n    \n    float x = 0.05;\n    float z = -0.18;\n    p = rotate(p, M_PI * -0.6 * (p.x - x) / sc, vec3(0,1,0));\n\n    float d = sdCapsule(opBendXY(p + vec3(x, -0.01, z) * sc, 100.0/sc), vec3(-0.005,0.0,0) * sc, vec3(0.005, 0., 0) * sc, 0.0025 * sc);\n    float d1 = sdCapsule(opBendXY(p + vec3(x+0.01, -0.01, z) * sc, 200.0/sc), vec3(-0.0026,0.0,0) * sc, vec3(0.0026, 0., 0) * sc, 0.0025 * sc);\n    float d2 = sdCapsule(opBendXY(p + vec3(x+0.019, -0.015, z) * sc, -100.0/sc), vec3(-0.01,0.0,-0.01) * sc, vec3(0.0045, 0., 0.0) * sc, 0.0025 * sc);\n    \n    return opUnion(opUnion(d, d1), d2);\n}\n\nfloat sdEyeBrow(vec3 p, float flip, float sc)\n{\n    p.x *= flip;\n    \n    p = rotate(p, M_PI * -0.0225, vec3(0,0,1));\n    \n    return sdRoundBox(p + vec3(0.03, -0.14,-0.125) * sc, vec3(0.015,0.0025,0.1) * sc, 0.0001);\n}\n\nvec2 sdBoze(vec3 p, float sc)\n{\n    // scale\n\t//p = p / sc;\n    //float s = (sc.x + sc.y + sc.z) / 3.0;\n    //float s2 = 1.0 / s;\n    \n    vec2 result = vec2(0.);\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0) * sc, vec3(0, 0.11, 0) * sc, 0.125 * sc);\n    \n    //vec3 p2 = p / vec3(1.0,1.0,0.9);\n    //float d1 = sdRoundedCylinder(p2 + vec3(0,0.025,0), 0.095, 0.05, 0.0);\n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0) * sc, 0.095 * sc, 0.05 * sc, 0.0);\n    \n    d = opSmoothUnion(d, d1, 0.1 * sc);\n    \n    // ear\n    float d2 = sdEar(p, 1.0, sc);\n    d = opUnion(d, d2);\n    float d3 = sdEar(p, -1.0, sc);\n    d = opUnion(d, d3);\n\n    vec2 head = vec2(d, MAT_FACE);\n\n\t// eye\n    float d4 = sdCapsule(p, vec3(EYE_SPACE, 0.06, 0.125) * sc, vec3( EYE_SPACE, 0.08, 0.125) * sc, 0.0175 * sc);\n    float d5 = sdCapsule(p, vec3(-EYE_SPACE,0.06, 0.125) * sc, vec3(-EYE_SPACE, 0.08, 0.125) * sc, 0.0175 * sc);\n    vec2 eye = vec2(opUnion(d4, d5), MAT_BLACK);\n    \n    // mouse\n    float d6 = sdMouse(p, sc);\n    vec2 mouse = vec2(d6, MAT_BROW);\n    \n    // cheep\n    float d7 = sdCheep(p, 1.0, sc);\n    float d8 = sdCheep(p, -1.0, sc);\n    vec2 cheep = vec2(opUnion(d7, d8), MAT_CHEEP);\n\n    // eyebrows\n    float d9 = sdEyeBrow(p, 1.0, sc);\n    float d10 = sdEyeBrow(p, -1.0, sc);\n    eye.x = opUnion(eye.x, opUnion(d9, d10));\n    \n    mouse = opU(eye, mouse);\n    result = opS(mouse, head);\n    result = opU(cheep, result);\n    \n    \n    return result;\n}\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// End of Mikka Boze\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nvec2 map(vec3 p)\n{\n\tvec2 result = vec2(1.);\n    \n    //p = rotate(p, M_PI, vec3(0,1,0));\n    //float timeSpeed = iTime * 0.5;\n    //float timeSpeed = iTime * 0.10398* M_PI2;\n    float timeSpeed = iTime * 0.1* M_PI2;\n    //float timeSpeed = iTime * 0.1* M_PI2;\n    \n    // Boze Twist\n    for(float i = 0.0; i < 8.0; i++)\n    {\n        vec3 q = p;\n        //q = rotate(q, M_PI + timeSpeed * 15.0 + i * 0.125, vec3(0,1,0));\n        //q = rotate(q, M_PI , vec3(0,1,0));\n        //q = rotate(q, M_PI + timeSpeed * 2.0, vec3(0,1,0));\n        float y = fract(8.0 + timeSpeed - i * 0.125);\n\t\tfloat size = min(y * 5.0, 1.05);\n        //float k = mod(floor(timeSpeed + i), 8.0);\n        //float k = mod(timeSpeed + i - (1.0 - size), 8.0);\n        //float k = mod(timeSpeed + i, 8.0);\n        //float k = mod(i - (1.0 - size), 8.0);\n        float k = mod(timeSpeed *4.0+ i - (1.0 - size), 8.0);\n    \tfloat angle = k * (M_PI2 * 0.125);\n        //float angle = i * (M_PI2 * 0.125);\n\t\t//float size = i * 0.125;\n        //float size = 1.0;\n\n        q = rotate(q, M_PI, vec3(0,1,0));\n        vec2 v = vec2(cos(angle), sin(angle)) * 0.5; \n    \tq.xz += v.xy;\n        //q.z -= 0.5;\n        //q.z += v.x;\n        q.y += y;\n        \n   \t \tq = rotate(q, M_PI * 0.4, vec3(v.x, 0.0, v.y));\n        float tp = min(y*3.0, 1.0);\n        q = TwistY(q, (1.0 - tp) * M_PI * 20.0);\n    \tresult = opSU(sdBoze(q, size), result, max(0.22 * tp, 0.1));\n    }\n    \n    // Background\n    //float y = fract(8.0 + timeSpeed);\n    vec3 q = opRep(p + vec3(0., iTime * 0.1 * M_PI2, 0.), vec3(1,1,1));\n    float l = sdRoundBox(q, vec3(0.75), 0.0);\n    float l2 = sdCylinder(p, vec3(0.,0.,2.25));\n    float l3 = sdCylinder(p, vec3(0.,0.,0.125));\n    //vec2 br = vec2(max(-l,l2), MAT_BG);\n    vec2 br = vec2(min(max(-l2, l), l3), MAT_BG);\n    //vec2 br = vec2(l2, MAT_BG);\n    //vec2 br = vec2(l, MAT_BG);\n    \n    result = opU(br, result);\n    \n    return result;\n}\n\nvec3 norm(vec3 p)\n{\n    vec2 e=vec2(.001,.0);\n    return normalize(.000001+map(p).x-vec3(map(p-e.xyy).x,map(p-e.yxy).x,map(p-e.yyx).x));\n}\n\nvec3 fresnelSchlick_roughness(vec3 F0, float cosTheta, float roughness) {\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n// Unreal Engine Ambient BRDF Approx\n// https://www.unrealengine.com/en-US/blog/physically-based-shading-on-mobile?lang=en-US\nvec3 EnvBRDFApprox( vec3 SpecularColor, float Roughness, float NoV )\n{\n\tconst vec4 c0 = vec4( -1, -0.0275, -0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, -0.04 );\n\tvec4 r = Roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn SpecularColor * AB.x + AB.y;\n}\n\nvec3 calcAmbient(vec3 pos, vec3 albedo, float metalness, float roughness, vec3 N, vec3 V, float t)\n{\n\tvec3 F0 = mix(vec3(0.04), albedo, metalness);\n    vec3 F  = fresnelSchlick_roughness(F0, max(0.0, dot(N, V)), roughness);\n    vec3 kd = mix(vec3(1.0) - F, vec3(0.0), metalness);\n    \n\tfloat aoRange = t/20.0;\n\tfloat occlusion = max( 0.0, 1.0 - map( pos + N*aoRange ).x/aoRange );\n\tocclusion = min(exp2( -.8 * pow(occlusion, 2.0) ), 1.0);\n    \n    vec3 ambientColor = vec3(0.5);\n    \n    vec3 diffuseAmbient = kd * albedo * ambientColor * min(1.0, 0.75+0.5*N.y) * 3.0;\n    vec3 R = reflect(-V, N);\n    \n    vec3 col = mix(vec3(0.5) * pow( 1.0-max(-R.y,0.0), 4.0), ambientColor, pow(roughness, 0.5));\n    vec3 ref = EnvBRDFApprox(F0, roughness, max(dot(N, V), 0.0));\n    vec3 specularAmbient = col * ref;\n\n    diffuseAmbient *= occlusion;\n    return vec3(diffuseAmbient + specularAmbient);\n}\n\n///////////////////////////////////////////////////////////////////////\nvec3 materialize(vec3 p, vec3 ray, float depth, vec2 mat)\n{\n    vec3 col = vec3(0.0);\n    vec3 nor = norm(p);\n    vec3 sky = vec3(0);\n    if (depth > 100.0) {\n        col = sky;\n        //col = vec3(fract(iTime * 0.5), 0.0, 0.0);\n        //vec3 lig = normalize( vec3(1.0,0.2,1.0) );\n        //col = background(ray, lig);\n    } else {\n        float roughness, metalness;\n        float t = iTime * M_PI2 * 0.1;\n        float red = max(0., sin(t * 5.0));\n        //float red = 1.;\n        if(mat.y == MAT_BLACK) {\n            col = vec3(0.0 + red, 0.0, 0.0);\n            roughness = 0.8;\n            metalness = 0.0;\n        } else if(mat.y == MAT_FACE) {\n        \tcol = vec3(1.0 + red, 0.8, 0.6);\n            roughness = 0.8;\n            metalness = 0.0;\n        } else if(mat.y == MAT_BROW) {\n            col = vec3(1.0 + red, 0, 0);\n            roughness = 0.1;\n            metalness = 0.0;\n        } else if(mat.y == MAT_CHEEP) {\n            col = vec3(1.0 + red, 0.3, 0.5);\n            roughness = 0.1;\n            metalness = 0.0;\n        } else if(mat.y == MAT_BG) {\n            //col = vec3(0.4, 0.02, 0.05);\n            float e = smoothstep(abs(mod(p.y + 0.25 + t, 0.5) - 0.25), 0.0, 0.0125); \n            //float e = smoothstep(mod(abs(p.y - 0.5) + iTime * 0.5, 0.5),0.,0.025); \n            //col = e ? vec3(1.4, 0.02, 0.05) * max(0., sin(iTime * 5.0)): vec3(0.01, 0., 0.);\n            col = mix(vec3(1.4, 0.02, 0.05) * red, vec3(0.03, 0., 0.), e);\n            roughness = e > 0.0 ? 0.01 : 0.25;\n            metalness = e > 0.0 ? 0.8 : 0.1;\n        }\n\n        vec3 result = vec3(0.);\n        result += calcAmbient(p, col, metalness, roughness, nor, -ray, depth);\n        //result += calcAmb(p, nor, col, ray);\n        col = result;\n    }\n    return col;\n}\n\n#define MAX_MARCH 100\n\nvec3 trace(vec3 p, vec3 ray)\n{\n    float t = 0.0;\n    vec3 pos;\n    vec2 mat;\n    \n    int count = 0;\n    for (int i = 0; i < MAX_MARCH; i++) {\n        pos = p + ray * t;\n        mat = map(pos);\n        if (mat.x <= 0.000001) {\n        \tbreak;\n        }\n        t += mat.x;\n        count++;\n    }\n    if(count == MAX_MARCH)\n    {\n        mat.y == MAT_BLACK;\n    }\n    p = p + t * ray;\n    return materialize(p, ray, t, mat);\n}\n\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n        \n    float t = iTime * M_PI2 * 0.1047;\n\t//vec3 ro = vec3(cos(iTime)*2.0, 0.25, sin(iTime)*2.0 );\n    //vec3 ro = vec3(0.0, -1.0, -2.1);\n    //vec3 ro = vec3(0.0, -0.75, -2.1);\n    //vec3 ro = vec3(0.0, -0.75 + sin(iTime * 1.5)*0.25, -2.1);\n    vec3 ro = vec3(cos(t)*2.0, -0.75 + sin(t)*0.25, sin(t)*2.0 );\n    vec3 ta = vec3(0., -0.05, 0.);\n    \n    //mat3 c = camera(ro, ta, cos(t * 0.35)*0.25);\n    mat3 c = camera(ro, ta, cos(t*2.0)*0.25);\n    //mat3 c = camera(ro, ta, 0.);\n    vec3 ray = c * normalize(vec3(p, 3.5));\n    vec3 col = trace(ro, ray);\n    \n    tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    fragColor = vec4(tot,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ts2BRW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ts2fzK", "name": "ShATI - LibertÃ©", "author": "Flopine", "description": "My former school named ATI decided to launch an everyday challenge from 4th may to 24th may, here is the last subject: liberty! I did it :D :) ", "tags": ["raymarching", "animation", "isometric", "mograph"], "likes": 4, "viewed": 83, "date": "1590439070", "time_retrieved": "2024-06-20T20:07:26.090641", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n// Shader made for Everyday ATI challenge\n\n#define PI acos(-1.)\n#define time fract(iTime*0.3)\n\nfloat easeInOutExpo(float x)\n{\n    return x == 0.\n        ? 0.\n        : x == 1.\n            ? 1.\n            : x < 0.5 ? pow(2., 20. * x - 10.) / 2.\n                : (2. - pow(2., -20. * x + 10.)) / 2.;\n}\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0.,max(q.x,max(q.y,q.z)))+length(max(q,0.));\n}\n\nfloat sc (vec3 p, float d)\n{\n    p = abs(p);\n    p = max(p.xyz,p.yzx);\n    return min(p.x,min(p.y,p.z))-d;\n}\n\nfloat cage (vec3 p)\n{\n    float per = 15.;\n    p.y -= easeInOutExpo(time*PI/3.)*per;\n    p.y = mod(p.y-per*0.5,per)-per*0.5;\n    vec3 pp = p;\n    float size = 1.8;\n    float cube = max(-sc(p,size*0.8),box(p,vec3(size)));\n\n    p.z = abs(p.z)-size*0.9;\n    p.x = abs(abs(p.x)-0.65)-0.3;\n    float b1 = box(p,vec3(0.12,size,0.1));\n\n    p = pp;\n    p.xz *= rot(PI/2.);\n    p.z = abs(p.z)-size*0.9;\n    p.x = abs(abs(p.x)-0.65)-0.3;\n    float b2 = box(p,vec3(0.12,size,0.1));\n\n    return min(min(b2,b1),cube);\n}\n\nfloat gem (vec3 p)\n{\n    float d = dot(p,normalize(sign(p)))-(.2+sqrt(sin(time*PI)*0.5));\n    return d;\n}\n\nfloat SDF (vec3 p)\n{\n    vec3 pp = p;    \n    pp.yz *= rot(-atan(1./sqrt(2.)));\n    pp .xz *= rot(PI/4.);\n    p = mix(p,pp,easeInOutExpo(clamp(sin(time*PI)*3.-1.,0.,1.)));\n    return min(gem(p),cage(p));\n}\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2(0.001,0.);\n    return normalize(SDF(p)-vec3(SDF(p-eps.xyy),SDF(p-eps.yxy),SDF(p-eps.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(uv*3.5,-30.),\n        rd = vec3(0.,0.,1.),\n        p = ro,\n        l = normalize(vec3(1.,2.,-4.)),\n        col = vec3(0.4,0.55,0.5);\n\n    float d=0.;\n    bool hit = false;\n    for (float i=0.; i<100.;i++)\n    {\n        d = SDF(p);\n        if (d < 0.001)\n        {\n            hit = true;\n            break;\n        }\n        p += d*rd*0.8;\n    }\n\n    if (hit)\n    {\n        vec3 n = getnorm(p);\n        col = vec3(max(dot(n,l),0.));\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ts2fzK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ts2fzt", "name": "Vicsek Snowflake", "author": "blepfo", "description": "Another KIFS loop", "tags": ["kifs"], "likes": 2, "viewed": 77, "date": "1590640709", "time_retrieved": "2024-06-20T20:07:26.466359", "image_code": "#define PI (3.14)\n#define ITERATIONS (5)\n\nfloat cubeSdf(vec2 p, vec2 halves) {\n    vec2 edgeDist = abs(p) - halves;\n    return length(max(edgeDist, 0.)) \n        + min(max(edgeDist.x, edgeDist.y), 0.);\n}\n\nvec2 fold(vec2 uv, float theta) {\n\tvec2 normal = vec2(sin(-theta), cos(-theta));\n    // proj(uv, n) = dot(uv, n) / dot(n, n)\n    // n has norm 1\n    float d = dot(uv, normal);\n    return uv - (2. * max(d, 0.) * normal);\n}\n\nvec2 vicsekSnowflake(vec2 uv, float time) {\n    // Period 0 -- fold angle from (PI / 4) -> (PI / 6)\n    // angle denominator increment ranges 0->2 from 0->1\n    // Period 1 -- Translate 1 from 0.5 to 1.5\n    time = mod(time, 4.);\n    float denominatorIncrement = \n        // Transition from 0 to 1\n        ((1. - step(1., time)) * fract(time) * 2.)\n        // After 1 stay at 2, but stay back down after 3\n        + ((step(1., time) * 2.) * (1. - step(3., time)))\n        // After 2 decrease from 2 back to 0\n        - ((step(2., time) * fract(time) * 2.) * (1. - step(3., time)));\n    \t\n    \n    float translateIncrement = \n        // Transition from 1 to 2\n        ((1. - step(2., time)) * step(1., time) * fract(time))\n    \t// After 2 stay at 1\n        + step(2., time)\n    \t// After 3 decrease to 0\n    \t- (step(3., time) * fract(time));\n    \n    \n    for (int i = 0; i < ITERATIONS; i++) {\n        uv *= 3.;\n        uv = abs(uv);\n    \tuv = fold(uv, PI / (4. + denominatorIncrement));\n    \tuv.x -= 0.5 + translateIncrement;\n    \tuv.x = abs(uv.x);\n    \tuv.x -= 0.5;\n    }\n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n\t\n    uv = vicsekSnowflake(uv, iTime* 0.8);\n    \n    float s = cubeSdf(uv, vec2(0.5));\n    float pixelSize = (1. * pow(3., float(ITERATIONS))) / iResolution.x;\n    float c = smoothstep(-pixelSize, pixelSize, s);\n    \n    vec3 color = vec3(uv.x, uv.y, 0.);\n    color = vec3(0.105,0.154,0.300);\n    color = mix(color, vec3(0.81,0.93,1.), 1.-c);\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ts2fzt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ts2yWt", "name": "CIS461: Penumbra Shadows", "author": "raykim1996", "description": "Penumbra Shadows practice", "tags": ["cis461"], "likes": 0, "viewed": 41, "date": "1588866505", "time_retrieved": "2024-06-20T20:07:27.454241", "image_code": "const float FOVY = 3.14159 * 0.25;\nconst int RAY_STEPS = 256;\nconst float PI = 3.14159;\nconst float TWO_PI = 3.14159 * 2.0;\nconst vec3 matteWhite = vec3(0.85, 0.81, 0.78);\nconst vec3 matteRed = vec3(0.63, 0.065, 0.05);\nconst vec3 matteGreen = vec3(0.14, 0.45, 0.091);\nconst vec3 lightPos = vec3(-4.0, 10.5, -10);\nconst float SHADOW_HARDNESS = 6.0;\n\n\n//Intersection\nstruct Intersection\n{\n    float t;\n    vec3 color;\n    vec3 p;\n    int object; // unique ID for every object\n};    \n\n// Box with side lengths b\nfloat cube(vec3 p, vec3 b)\n{\n  return length(max(abs(p) - b, 0.0));\n}\n\n// SquarePlane SDF\nfloat plane(vec3 p, vec4 n)\n{\n    n = normalize(n);\n    return dot(p, n.xyz) + n.w;\n}\n\n// Sphere with radius r at center c\nfloat sphere(vec3 p, float r, vec3 c)\n{\n    return distance(p, c) - r;\n}\n\n#define BACK_WALL 0\n#define LEFT_WALL 1\n#define RIGHT_WALL 2\n#define FLOOR 3\n#define SPHERE1 4\n#define SHORT_CUBE 5\n#define BIG_CUBE 6\n#define BACK_WALL_SDF plane(pos, vec4(0.0, 0.0, -1.0, 15.0))\n#define LEFT_WALL_SDF plane(pos, vec4(1.0, 0.0, 0.0, 5.0))\n#define RIGHT_WALL_SDF plane(pos, vec4(-1.0, 0.0, 0.0, 5.0))\n#define CEILING_SDF plane(pos, vec4(0.0, -1.0, 0.0, 7.5))\n#define FLOOR_SDF plane(pos, vec4(0.0, 1.0, 0.0, 4.0))\n#define SPHERE1_SDF sphere(rotateY(pos, 15.0 * 3.14159 / 180.0), 3.5, vec3(-7.0, 2.0, -1.0))\n#define SHORT_CUBE_SDF cube(rotateY(pos + vec3(-2, 1.5, -0.75), -17.5 * 3.14159 / 180.0), vec3(2.2, 3, 2.2))\n\nvec3 rotateY(vec3 p, float a)\n{\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);   \n}\n\n// function to create whole scene\nvoid sceneMap3D(vec3 pos, out float t, out int obj)\n{\n    t = FLOOR_SDF;\n    obj = FLOOR;\n    \n    float t2;\n    if ((t2 = SPHERE1_SDF) < t) {\n        t = t2;\n        obj = SPHERE1;\n    }\n    if ((t2 = SHORT_CUBE_SDF) < t) {\n        t = t2;\n        obj = SHORT_CUBE;\n    }\n}\n\nfloat sceneMap3D(vec3 pos)\n{\n    float t = FLOOR_SDF;\n    \n    float t2;\n    if ((t2 = SPHERE1_SDF) < t) {\n        t = t2;\n    }\n    if ((t2 = SHORT_CUBE_SDF) < t) {\n        t = t2;\n    }\n    return t;\n}\n\n\n// Soft Shadow for Penumbra Effect\nfloat softShadow(vec3 dir, vec3 origin, float min_t, float k) {\n    float res = 1.0;\n    float t = min_t;\n    for(int i = 0; i < RAY_STEPS; ++i) {\n        float m = sceneMap3D(origin + t * dir);\n        if(m < 0.0001) {\n            return 0.0;\n        }\n        res = min(res, k * m / t);\n        t += m;\n    }\n    return res;\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj)\n{\n    t = 0.001;\n    for (int i = 0; i < RAY_STEPS; ++i) {\n        vec3 pos = origin + t * dir;\n        float m;\n        sceneMap3D(pos, m, hitObj);\n        if (m < 0.001) {\n            return;\n        }\n        t += m;\n    }\n    t = -1.0;\n    hitObj = -1;\n}\n\nvec3 computeMaterial(int hitObj, vec3 p, vec3 n, vec3 lightVec, vec3 view)\n{\n    switch(hitObj) {\n        case FLOOR:\n        return matteWhite;\n        break;\n        case SPHERE1:\n        return vec3(0.85, 0.41, 0.2);\n        break;\n        case SHORT_CUBE:\n        return vec3(0.1, 0.31, 0.6);\n        break;\n        case -1:\n        return vec3(0, 0, 0);\n        break;\n    }\n    return vec3(0, 0, 0);\n}\n\nvec3 computeNormal(vec3 pos)\n{\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize(vec3(sceneMap3D(pos + epsilon.yxx) - sceneMap3D(pos - epsilon.yxx),\n                         sceneMap3D(pos + epsilon.xyx) - sceneMap3D(pos - epsilon.xyx),\n                         sceneMap3D(pos + epsilon.xxy) - sceneMap3D(pos - epsilon.xxy)));\n}\n\nIntersection sdf3D(vec3 dir, vec3 eye)\n{\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj);\n    \n    vec3 isect = eye + (t * dir);\n    vec3 nor = computeNormal(isect);\n\n    vec3 lightDir = normalize(lightPos - isect);\n    vec3 surfaceColor = computeMaterial(hitObj, isect, nor, lightDir, normalize(eye - isect));\n    vec3 warmDir = rotateY(normalize(lightDir), sin(iTime * 0.25));\n\n    float warmDot = max(0.0, dot(nor, warmDir));\n\n    vec3 overallColor = warmDot * vec3(1.0, 0.88, 0.7) * surfaceColor * softShadow(warmDir, isect, 0.1, SHADOW_HARDNESS);\n    \n    vec3 sdfColor = overallColor;\n\n    return Intersection(t, sdfColor, isect, hitObj);\n}\n\n// Returns direction of ray\nvec3 rayCast(vec3 eye, vec3 ref, vec2 ndc)\n{\n    vec3 F = ref - eye;\n    vec3 R = normalize(cross(vec3(0, 1, 0), F));\n    vec3 U = normalize(cross(R, -F));\n    \n    vec3 V = U * length(F) * tan(FOVY * 0.5);\n    vec3 H = R * length(F) * tan(FOVY * 0.5) * float(iResolution.x) / iResolution.y;\n    \n    vec3 p = ref + ndc.x * H + ndc.y * V;\n    \n    return normalize(p - eye);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // Convert range to [-1, 1]\n    uv = uv * 2.0 - vec2(1.0, 1.0);\n    \n    vec3 eye = vec3(9, 5.5, -24);\n    vec3 ref = vec3(-2, 1.5, 0);\n    \n    vec3 rayDir = rayCast(eye, ref, uv);\n    \n    Intersection isect = sdf3D(rayDir, eye);\n    \n    fragColor = vec4(isect.color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ts2yWt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsBBzG", "name": "Outline 2020 Freestyle Live code", "author": "NuSan", "description": "Shader coded live during Outline Online 2020 in ~2h\nThere is two scenes that you can switch by changing SCENE from 0 to 1", "tags": ["livecode"], "likes": 43, "viewed": 756, "date": "1590261223", "time_retrieved": "2024-06-20T20:07:28.872671", "image_code": "// Shader coded live during Outline Online 2020 in ~2h\n// There is two scenes that you can switch by changing SCENE from 0 to 1\n\n#define SCENE 0\n\nfloat time = 0.;\n\n#define repeat(a,b) (fract((a)/(b)+.5)-.5)*(b)\n#define repid(a,b) floor((a)/(b)+.5)\n\nfloat fft(vec2 t) {\n  return texture(iChannel0, vec2((fract(t.x*10.)+fract(t.y))*.1)).x*50.;\n}\n\n\nvec2 rnd(vec2 p){\n  \n  return fract(sin(p*425.522+p.yx*847.554)*352.742);\n}\n\nfloat rnd(float a) {\n  return fract(sin(a*254.574)*652.512);\n}\n\nfloat curve(float t, float d) {\n  t/=d;\n  return mix(rnd(floor(t)), rnd(floor(t)+1.), pow(smoothstep(0.,1.,fract(t)), 10.));\n}\n\nfloat tick(float t, float d) {\n  t/=d;\n  return (floor(t) + pow(smoothstep(0.,1.,fract(t)), 10.)) * d;\n}\n\n\n\nfloat box(vec3 p, vec3 s) {\n  p=abs(p)-s;\n  return max(p.x, max(p.y,p.z));\n}\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nfloat at=0.;\nfloat at2=0.;\n#if SCENE==0\nfloat map(vec3 p){\n  \n  //p.xy *= rot(sin(-length(p.xy)*.02 + time*2)*1+time);\n  //p.yz *= rot(sin(-length(p.yz)*.03 + time*4)*1);\n  p.xz *= rot(sin(-length(p.xz)*.07 + time*1.)*1.);\n  \n  \n  p.y += pow(smoothstep(0.,1.,sin(-pow(length(p.xz),2.)*.001 + time*4.)),3.)*4.;\n  \n  float d=-p.y;\n  \n  for(float i=0.; i<4.; ++i) {\n    vec3 p2 = p;\n    p2.xz *= rot(i+.7);\n    p2.xz -= 7.;\n    float id=fft(rnd(repid(p2.xz, 10.)));\n    p2.xz = repeat(p2.xz, 10.);\n    \n    d=min(d, box(p2, vec3(1,0.3*id,1)));\n    //d=max(d, -box(p2, vec3(4,id*130,4)));\n    \n  }\n  \n  vec3 p3 = p;\n  float t3 = time*.13;\n  p3.xz *= rot(t3);\n  p3.xy *= rot(t3*1.3);\n  p3=repeat(p3, 5.);\n  float d2 = box(p3, vec3(1.7));\n  //d = max(d, -d2*1.3);\n  d = min(d, d-d2*0.1);//*curve(time, .3));\n  \n  //d = min(d, -p.y);\n  \n  vec3 p4 = p;\n  float t4 = time*1.33;\n  p4.xz=repeat(p4.xz, 200.);\n  p4.yz *= rot(t4);\n  p4.xz *= rot(t4*1.3);\n  \n  at += 0.04/(1.2+abs(length(p4.xz)-17.));\n  \n  vec3 p5 = p;\n  float t5 = time*1.23;\n  p5.xz=repeat(p5.xz, 200.);\n  p5.yz *= rot(t5*.7);\n  p5.xy *= rot(t5);\n  \n  at2 += 0.04/(1.2+abs(box(p5,vec3(37))));\n  \n  //d -= sin(time);\n  \n  return d*.7;\n}\n#endif\n\nfloat grid2(vec3 p) {\n  float v=0.0;\n  p *= 0.004;\n  for(float i=0.; i<3.; ++i) {\n    p *= 1.7;\n    p.xz *= rot(0.3+i);\n    p.xy *= rot(0.4+i*1.3);\n    p += vec3(0.1,0.3,-.13)*(i+1.);\n    vec3 g=abs(fract(p)-.5)*2.0;\n    //v-=g.x*g.y*g.z*.7;\n    v-=min(g.x,min(g.y,g.z))*.7;\n  }\n  return v;\n}\n\n#if SCENE==1\nfloat map(vec3 p){\n  \n  //p.x += smoothstep(0,1,sin(p.y*.01 + time))*100*curve(time, .5);\n  \n  float ppy=p.y;\n  \n  p.y = repeat(p.y,300.);\n  //p.x = repeat(p.x,500);\n  \n  p.xz *= rot(sin(-length(p.xz)*.0007 + time*.5 + ppy*.005)*1.);\n  \n  //p.xz *= rot(sin(-length(p.xz)*.07 + time*1 + p.y*.05)*1);\n  \n  vec3 p4=p;\n  float t4=0.;\n  p4.yz *= rot(t4);\n  p4.xz *= rot(t4*1.3);\n  \n  float d = box(p4, vec3(20));\n  float ss = 10.;\n  d = max(d, -box(p4, vec3(ss,ss,100)));\n  d = max(d, -box(p4, vec3(ss,100,ss)));\n  d = max(d, -box(p4, vec3(100,ss,ss)));\n  \n  vec3 p3 = p;\n  p3.xz *= rot(sin(time*3. + p.y*.01)*.3);\n  p3.xz = abs(p3.xz)-30.;\n  p3.xz = abs(p3.xz)-10.*(sin(time+p.y*.05)*.5+.5);\n  d = min(d, length(p3.xz)-5.);\n  \n  \n  float g = grid2(p);\n  float d2 = d-5.-g*12.7;// * smoothstep(-1,1,sin(tick(time, 1)+p.y*.1));\n  d = min(d+4.3, d2);\n  \n  vec3 p6 = p;\n  float t6 = time*1.33;\n  p6.xz=repeat(p6.xz, 40.);\n  p6.yz *= rot(t6);\n  p6.xz *= rot(t6*1.3);\n  \n  at += 0.04/(1.2+abs(length(p6.xz)-17.));\n  \n  vec3 p5 = p;\n  float t5 = time*1.23;\n  //p5.xz=repeat(p5.xz, 200);\n  p5.yz *= rot(t5*.7);\n  p5.xy *= rot(t5);\n  \n  at2 += 0.04/(0.7+abs(box(p5,vec3(37))));\n  \n  \n  vec3 p7 = p;\n  float t3 = time*.13;\n  p7.xz *= rot(t3);\n  p7.xy *= rot(t3*1.3);\n  p7=repeat(p7, 5.);\n  float d7 = box(p7, vec3(1.7));\n  //d = max(d, -d7*1.3);\n  d = min(d, d*.7-d7*0.7);//*curve(time, .3));\n  \n  return d*.7;\n}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n    \n  time = mod(iTime*1., 300.);\n  \n  float si = 30.;// + 50 * curve(time, .1);\n  vec2 grid=abs(fract(uv*si)-.5)*2.;\n  //uv=floor(uv*si+.5)/si;\n  \n  \n\n  vec3 s=vec3(0,0,-50);\n  s.xz += (curve(time, 1.6)-.5)*30.;\n  vec3 t=vec3(0);\n  \n  // SWITCH NIGHT MOOD\n  float part = smoothstep(-0.1,.1,sin(time));\n  \n  float adv = time*.1;//tick(time, .5)*2;\n  s.yz *= rot(sin(adv*.3)*.3+0.5);\n  s.xz *= rot(adv);\n \n#if SCENE==1  \n  s.y -= 100.;\n  s.x += 100.;\n  \n \n  float push=tick(time, .5) * 100.;\n  s.y += push;\n  t.y += push;\n#endif\n  \n  \n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(vec3(0,1,0), cz));\n  vec3 cy=normalize(cross(cx, cz));\n  float fov = 0.4;// + curve(time, 0.5)*1.3;\n  vec3 r=normalize(uv.x*cx + uv.y*cy + fov*cz);\n  \n  vec3 col=vec3(0);\n  \n  vec3 p=s;\n  for(int i=0; i<100; ++i) {\n    float d=abs(map(p));\n    if(d<0.01) {\n      d=0.1;\n      break;\n    }\n    if(d>300.) break;\n    p+=r*d;\n    //col += 0.001/(0.1+abs(d));\n  }\n  col += at * vec3(.3,.4,1) * (1.+curve(time, .3));\n  col += at2 * vec3(1.0,.4,.6) * (1.+curve(time, .4));\n  \n  col *= part;\n  \n  \n  //*\n  float fog = 1.-clamp(length(p-s)/300.,0.,1.);\n  \n  vec2 off=vec2(0.01,0);\n  vec3 n=normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n  vec3 l=normalize(-vec3(1,1.3,2));\n  vec3 h=normalize(l-r);\n  \n  float sss=0.;\n  for(float i=1.; i<20.; ++i){\n    float dist = i*5.2;\n    sss += smoothstep(0.,1.,map(p+l*dist)/dist);\n    \n  }\n  vec3 col2 = vec3(0);\n  col2 += sss * vec3(1,.3,.8) * .15 * fog ;\n  \n  float ao=smoothstep(0.,1.,map(p+n));\n  \n  vec3 sky = mix(vec3(1,.6,.7)*0.1/(.1+abs(r.y)), vec3(1,.9,.3)*10., pow(max(0.,dot(r,l)), 20.));\n  \n  col2 += max(0., dot(n,l)) * (pow(max(0.,dot(h,n)),10.))*fog*ao;\n  \n  col2 += pow(1.-fog,2.) * sky;\n  col += col2*(1.-part);\n  //*/\n  \n  /*\n  float t3 = time*.1;\n  col.xz *= rot(t3 + r.x*.17);\n  col.yz *= rot(t3*1.2 + r.y*.13);\n  col=abs(col);\n  //*/\n  \n  col *= 1.2-length(uv);\n  \n  float lum = clamp(col.x,0.,1.);\n  float factor = step(+1.-1.+0.7*lum,min(grid.x, grid.y))+.7;\n  \n  //col *= factor;\n  \n  col += max(col.yzx-1.,0.);\n  col += max(col.zxy-1.,0.);\n  \n  col=smoothstep(0.,1.,col);\n  col=pow(col, vec3(0.4545));\n  \n  fragColor = vec4(col, 1);\n}", "image_inputs": [{"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsBBzG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsBfDw", "name": "Fire Glass", "author": "TAKUSAKU", "description": "Fire Glass", "tags": ["fire", "glass"], "likes": 13, "viewed": 195, "date": "1590153126", "time_retrieved": "2024-06-20T20:07:28.878763", "image_code": "float random (in vec2 _st) {\n    return fract(sin(dot(_st.xy, vec2(0.890,-0.900))) * 757.153);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3. - 2. * f);\n\n    return mix(a, b, u.x) + (c - a)* u.y * (1. - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat fbm ( in vec2 _st) {\n    float v = sin(iTime)*0.15;\n    float a = 0.9;\n    vec2 shift = vec2(100.);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(1.0), -sin(0.5), acos(0.5));\n    for (int i = 0; i < 5; ++i) {\n        v += a * noise(_st);\n        _st = rot * _st * 2. + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = (2.*fragCoord-iResolution.xy) / min(iResolution.x, iResolution.y)*0.7;\n    \n    vec2 co = st;    \n    float len;    \n    for (int i = 0; i < 3; i++) {\n        len = length(co);       \n        co.x +=  sin(co.y + iTime * 0.620)*0.3;\n        co.y +=  cos(co.x + iTime * 0.164 + cos(len * 1.))*0.3;\n    }    \n    len *= cos(len * 0.01);    \n    len -= 3.;\n     \n    vec3 color = vec3(0.);\n\n    vec2 q = vec2(0.);\n    q.x = fbm( st );\n    q.y = fbm( st + vec2(-0.450,0.650));\n\n    vec2 r = vec2(0.);\n    r.x = fbm( st + 1.0*q + vec2(0.570,0.520)+ 0.5*iTime );\n    r.y = fbm( st + 1.0*q + vec2(0.340,-0.570)+ 0.4*iTime);\n    \n    //Diagonal line\n    for (float i = 0.; i < 3.; i++) {\n        r += 1. / abs(mod(st.y + st.x, 0.6 * i) * 50.) * 2.;\n        r += 1. / abs(mod(st.y - st.x, 0.6 * i) * 50.) * 1.;\n    }\n\n    color = mix(color, cos(len + vec3(0.620, 0.0, -0.564)), 1.0);\n\n    float f = fbm(st+r);\n\n    color = mix(vec3(0.667,0.340,0.404), vec3(0.101,0.551,0.667), color);\n    \n    fragColor = vec4(2.0*(f*f*f+.6*f*f+.5*f)*color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsBfDw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsBfRD", "name": "Quadratic Bezier - 3D BBox", "author": "iq", "description": "Computing the exact bounding box to a quadratic Bezier curve.   See  [url]http://iquilezles.org/www/articles/bezierbbox/bezierbbox.htm[/url] for the derivation.", "tags": ["3d", "bezier", "bbox"], "likes": 20, "viewed": 624, "date": "1589589118", "time_retrieved": "2024-06-20T20:07:28.888400", "image_code": "// The MIT License\n// Copyright Â© 2017 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n// Analytical computation of the exact bounding box for a cubic bezier segment\n//\n// See http://iquilezles.org/www/articles/bezierbbox/bezierbbox.htm\n\n\n// Other bounding box functions:\n//\n// Disk             - 3D BBox : https://www.shadertoy.com/view/ll3Xzf\n// Cylinder         - 3D BBox : https://www.shadertoy.com/view/MtcXRf\n// Ellipse          - 3D BBox : https://www.shadertoy.com/view/Xtjczw\n// Cone boundong    - 3D BBox : https://www.shadertoy.com/view/WdjSRK\n// Cubic     Bezier - 2D BBox : https://www.shadertoy.com/view/XdVBWd \n// Quadratic Bezier - 3D BBox : https://www.shadertoy.com/view/ldj3Wh\n// Quadratic Bezier - 2D BBox : https://www.shadertoy.com/view/lsyfWc\n\n\n#define AA 3\n\nstruct bound3\n{\n    vec3 mMin;\n    vec3 mMax;\n};\n\n//---------------------------------------------------------------------------------------\n// bounding box for a bezier (http://iquilezles.org/www/articles/bezierbbox/bezierbbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 BezierAABB( in vec3 p0, in vec3 p1, in vec3 p2 )\n{\n    // extremes\n    vec3 mi = min(p0,p2);\n    vec3 ma = max(p0,p2);\n\n    // p = (1-t)^2*p0 + 2(1-t)t*p1 + t^2*p2\n    // dp/dt = 2(t-1)*p0 + 2(1-2t)*p1 + 2t*p2 = t*(2*p0-4*p1+2*p2) + 2*(p1-p0)\n    // dp/dt = 0 -> t*(p0-2*p1+p2) = (p0-p1);\n\n    vec3 t = clamp((p0-p1)/(p0-2.0*p1+p2),0.0,1.0);\n    vec3 s = 1.0 - t;\n    vec3 q = s*s*p0 + 2.0*s*t*p1 + t*t*p2;\n\n    mi = min(mi,q);\n    ma = max(ma,q);\n    \n    return bound3( mi, ma );\n}\n\n\n// ray-ellipse intersection\nfloat iEllipse( in vec3 ro, in vec3 rd,         // ray: origin, direction\n             in vec3 c, in vec3 u, in vec3 v )  // disk: center, 1st axis, 2nd axis\n{\n\tvec3 q = ro - c;\n\tvec3 r = vec3(\n        dot( cross(u,v), q ),\n\t\tdot( cross(q,u), rd ),\n\t\tdot( cross(v,q), rd ) ) / \n        dot( cross(v,u), rd );\n    \n    return (dot(r.yz,r.yz)<1.0) ? r.x : -1.0;\n}\n\n\n// ray-box intersection (simplified)\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 cen, in vec3 rad ) \n{\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rd;\n    vec3 n = m*(ro-cen);\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return vec2(-1.0);\n\n\treturn vec2( tN, tF );\n}\n\nfloat length2( in vec3 v ) { return dot(v,v); }\n\nvec3 iSegment( in vec3 ro, in vec3 rd, in vec3 a, in vec3 b )\n{\n\tvec3 ba = b - a;\n\tvec3 oa = ro - a;\n\t\n\tfloat oad  = dot( oa, rd );\n\tfloat dba  = dot( rd, ba );\n\tfloat baba = dot( ba, ba );\n\tfloat oaba = dot( oa, ba );\n\t\n\tvec2 th = vec2( -oad*baba + dba*oaba, oaba - oad*dba ) / (baba - dba*dba);\n\t\n\tth.x = max(   th.x, 0.0 );\n\tth.y = clamp( th.y, 0.0, 1.0 );\n\t\n\tvec3 p =  a + ba*th.y;\n\tvec3 q = ro + rd*th.x;\n\t\n\treturn vec3( th, length2( p-q ) );\n    \n}\n\n\nfloat iBezier( in vec3 ro, in vec3 rd, in vec3 p0, in vec3 p1, in vec3 p2, in float width)\n{\n    const int kNum = 50;\n    \n    float hit = -1.0;\n    float res = 1e10;\n    vec3 a = p0;\n    for( int i=1; i<kNum; i++ )\n    {\n        float t = float(i)/float(kNum-1);\n        vec3 b = mix(mix(p0,p1,t),mix(p1,p2,t),t);\n        vec3 r = iSegment( ro, rd, a, b );\n        if( r.z<width*width )\n        {\n            res = min( res, r.x );\n            hit = 1.0;\n        }\n        a = b;\n    }\n    \n    return res*hit;\n    \n    \n}\n\nfloat hash1( in vec2 p )\n{\n    return fract(sin(dot(p, vec2(12.9898, 78.233)))*43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n    // camera position\n\tvec3 ro = vec3( -0.5, 0.4, 1.5 );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    // bezier animation\n    float time = iTime*0.5;\n    vec3 p0 = vec3(0.8,0.6,0.8)*sin( time*0.7 + vec3(3.0,1.0,2.0) );\n    vec3 p1 = vec3(0.8,0.6,0.8)*sin( time*1.1 + vec3(0.0,6.0,1.0) );\n    vec3 p2 = vec3(0.8,0.6,0.8)*sin( time*1.3 + vec3(4.0,2.0,3.0) );\n\tfloat thickness = 0.01;\n        \n    // render\n   \tvec3 col = vec3(0.4)*(1.0-0.3*length(p));\n\n    // raytrace bezier\n    float t = iBezier( ro, rd, p0, p1, p2, thickness);\n\tfloat tmin = 1e10;\n    if( t>0.0 )\n\t{\n    \ttmin = t;\n\t\tcol = vec3(1.0,0.75,0.3);\n\t}\n\n    // compute bounding box for bezier\n    bound3 bbox = BezierAABB( p0, p1, p2 );\n    bbox.mMin -= thickness;\n    bbox.mMax += thickness;\n\n    \n    // raytrace bounding box\n    vec3 bcen = 0.5*(bbox.mMin+bbox.mMax);\n    vec3 brad = 0.5*(bbox.mMax-bbox.mMin);\n\tvec2 tbox = iBox( ro, rd, bcen, brad );\n\tif( tbox.x>0.0 )\n\t{\n        // back face\n        if( tbox.y < tmin )\n        {\n            vec3 pos = ro + rd*tbox.y;\n            vec3 e = smoothstep( brad-0.03, brad-0.02, abs(pos-bcen) );\n            float al = 1.0 - (1.0-e.x*e.y)*(1.0-e.y*e.z)*(1.0-e.z*e.x);\n            col = mix( col, vec3(0.0), 0.25 + 0.75*al );\n        }\n        // front face\n        if( tbox.x < tmin )\n        {\n            vec3 pos = ro + rd*tbox.x;\n            vec3 e = smoothstep( brad-0.03, brad-0.02, abs(pos-bcen) );\n            float al = 1.0 - (1.0-e.x*e.y)*(1.0-e.y*e.z)*(1.0-e.z*e.x);\n            col = mix( col, vec3(0.0), 0.15 + 0.85*al );\n        }\n\t}\n\t\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    // dithering\n    tot += ((hash1(fragCoord.xy)+hash1(fragCoord.yx+13.1))/2.0-0.5)/256.0;\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/tsBfRD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsfBRj", "name": "fractals ordered construction", "author": "lomateron", "description": "like https://www.shadertoy.com/view/tt3GW2\nbut instead of wraping the image of a cat\nwrap the image of a point of light\nit applies that space wrap multiple times\nbut in order through time\nmouse Y controls how open the hand fan is", "tags": ["mandelbrot"], "likes": 5, "viewed": 260, "date": "1588591625", "time_retrieved": "2024-06-20T20:07:28.889397", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 u = 1.2*(2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = 8.*iMouse.xy/iResolution.xy;\n    float pi = 3.14159265359;\n\n    vec2 v = u;\n    float t = iTime;\n    float r = 2.;\n    if(iMouse.z>0.) t = m.x;\n    if(iMouse.z>0.) r = m.y*4.-16.;\n\n    for(float i = 0.; i < t; ++i)\n    {\n        float s = clamp(t-i,0.,1.);\n        float e = min(s,.5)*r+1.;\n        u = cos(atan(u.y,u.x)*e-vec2(0.,pi*.5))*pow(length(u),e);\n        u+= v*max(s-.5,.0)*2.;\n    }\n    fragColor = vec4(.05/length(u));\n    //fragColor = vec4(exp(dot(u,u)*-1.));\n    //fragColor = texture( iChannel0, vec2(.125,1.)*.1*u+.4 );\n}", "image_inputs": [{"id": "Xsf3Rn", "previewfilepath": "/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsfBRj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsffDM", "name": "Hypercentric Optics", "author": "blackle", "description": "experimenting with hypercentric optics as described by the applied science video here: https://www.youtube.com/watch?v=iJ4yL6kaV1A\n\nuse the mouse to rotate", "tags": ["hypercentric", "pericentric", "appliedscience", "domino", "dominos"], "likes": 10, "viewed": 320, "date": "1588354880", "time_retrieved": "2024-06-20T20:07:29.599896", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nfloat super(vec3 p) {\n    return sqrt(length(p*p));\n}\n\nfloat box(vec3 p, vec3 d) {\n    vec3 q = abs(p)-d;\n    return super(max(vec3(0), q)) + min(0., max(q.x, max(q.y, q.z)));\n}\n\nfloat linedist(vec3 p, vec3 a, vec3 b) {\n    float k = dot(p-a,b-a)/dot(b-a,b-a);\n    return distance(p, mix(a,b,clamp(k,0.,1.)));\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax,p)*ax, p, cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = max(0., k-abs(b-a))/k;\n    return min(a,b)-h*h*h*k/6.;\n}\n\nint mat;\nfloat domino(vec3 p, mat3 topholes, mat3 bottomholes) {\n    float body = box(p, vec3(0.0,0.4,0.9))-0.2;\n    float holes = linedist(p, vec3(.2,0.45,0), vec3(0.2,-0.45,0))-0.04; //divider\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            vec2 holepos = vec2(float(i-1), float(j-1))*0.3;\n            if (topholes[i][j] == 1.) {\n                holes = min(holes, length(p-vec3(.2,holepos+vec2(0.,0.55)))-0.08);\n            }\n            if (bottomholes[i][j] == 1.) {\n                holes = min(holes, length(p-vec3(.2,holepos+vec2(0.,-0.55)))-0.08);\n            }\n        }\n    }\n    mat = -body < holes ? 1 : 0;\n    return -smin(-body, holes, 0.05);\n}\n\nfloat scene(vec3 p) {\n    float table = box(p-vec3(0,0,-1.2), vec3(3,3,0.05))-0.05;\n    float d1 = domino(erot(p-vec3(-1,0,0),vec3(0,0,1),-0.05), mat3(0,0,1,0,1,0,1,0,0), mat3(1,0,1,0,1,0,1,0,1));\n    int d1mat = mat;\n    float d2 = domino(erot(p-vec3(1,0,0),vec3(0,0,1),0.1), mat3(1,0,1,0,0,0,1,0,1), mat3(0,0,0,0,1,0,0,0,0));\n    int d2mat = mat;\n    float dominos = min(d1,d2);\n    mat = d1 < d2 ? d1mat : d2mat;\n    mat = dominos < table ? mat : 2;\n    return min(dominos,table);\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])) );\n}\n\nvec3 srgb(float r, float g, float b) {\n    return vec3(r*r,g*g,b*b);\n}\n\nvec3 srgb(float k) {\n    return vec3(k*k);\n}\n\nvec3 trilinear_texture(vec3 p, vec3 n) {\n    return mix(mix(texture(iChannel0,p.xz), texture(iChannel0,p.yz), n.x*n.x), texture(iChannel0,p.xy), n.z*n.z).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n\n    //when centricity is negative, instead of camera rays diverging from the\n    //image plane, they instead converge. you can image this as the image plane\n    //being a refractive object that causes the camera rays to switch directions\n    float centricity = cos(iTime)*0.5;\n    vec3 cam = normalize(vec3(1,uv*centricity));\n    vec3 init = vec3(-5,uv*(4.-centricity*2.));\n\n   \tfloat yrot = 0.1;\n    float zrot = 3.14;\n    if (iMouse.z > 0.) {\n        yrot += -4.*mouse.y;\n        zrot += 4.*mouse.x;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    init = erot(init, vec3(0,0,1), zrot);\n\n    vec3 p = init;\n    bool hit = false;\n    for (int i = 0; i < 500 && !hit; i++) {\n        float dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p+=dist*cam;\n        if (distance(p, init) > 100.) break;\n    }\n    int locmat = mat;\n\tvec3 n = norm(p);\n    vec3 r = reflect(cam, n);\n    float ao = smoothstep(-1.,1.,scene(p+n*0.1)/.1);\n    float specao = smoothstep(0.,1.,scene(p+r*0.3)/.3);\n    float diff = ao*length(sin(n*2.5)*0.5+0.5)/sqrt(3.);\n    float spec = length(sin(r*2.5)*0.5+0.5)/sqrt(3.);\n    float diffbright = locmat == 0 ? 0.05 : 1.;\n    float specbright = locmat == 2 ? 0.1 : 1.5;\n  \n    p += trilinear_texture(p*0.5,n)*0.1;\n    vec3 tex = trilinear_texture(p,n)*0.25 + trilinear_texture(p*0.5,n)*0.5 + trilinear_texture(p*0.2,n);\n    vec3 diffcol = locmat == 2 ? (tex.x*0.5+0.1)*srgb(0.9, 0.85, 0.8) : srgb(0.95);\n    specbright += tex.x*tex.x*0.2;\n    vec3 col = mix(diffcol*0.1, diffcol, diff)*diffbright + pow(spec, 10.)*specbright*specao;\n    fragColor.xyz = hit ? col : vec3(pow(length(sin(cam*2.5)*0.5+0.5)/sqrt(3.), 10.)+0.01);\n    fragColor.xyz = sqrt(fragColor.xyz);\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc0-1.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsffDM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsffWs", "name": "Grid of cross demo", "author": "benpigchu", "description": "My first SDF ray marching thing.", "tags": ["procedural", "3d", "raymarching", "distancefields"], "likes": 2, "viewed": 85, "date": "1589363482", "time_retrieved": "2024-06-20T20:07:30.109078", "image_code": "vec4 quaternion(vec3 axis,float angle){\n\tfloat halfang=angle/2.;\n    return vec4(axis*sin(halfang),cos(halfang));\n}\n\nvec4 quaternionMultiply(vec4 q1,vec4 q2){\n\treturn vec4(q1.xyz*q2.w+q1.w*q2.xyz+cross(q1.xyz,q2.xyz),q1.w*q2.w-dot(q1.xyz,q2.xyz));\n}\n\nvec3 rotation(vec4 q,vec3 pos){\n\treturn pos+2.*cross(q.xyz,cross(q.xyz,pos)+q.w*pos);\n}\n\n//Note: we need dimension.x > dimension.y here\nfloat sdfCross(vec2 dimension,vec3 p){\n    vec3 xmaxP=abs(p);\n    xmaxP=xmaxP.x<xmaxP.y?xmaxP.yzx:xmaxP;\n    xmaxP=xmaxP.x<xmaxP.y?xmaxP.yzx:xmaxP;\n    xmaxP=xmaxP.x<xmaxP.z?xmaxP.zxy:xmaxP;\n    vec3 diff=xmaxP-dimension.xyy;\n    float maxdiff=max(max(diff.x,diff.y),diff.z);\n    vec3 connection=maxdiff>0.?diff:vec3(0.,-maxdiff,dimension.y-xmaxP.x);\n\treturn sign(maxdiff)*length(max(connection,0.));\n}\n\nfloat sdfcell(vec3 p,vec2 cell){\n    vec4 qUpDown=quaternion(vec3(1,0,0),radians(-cell.y*30.));\n    vec4 qLeftRight=quaternion(vec3(0,0,1),radians(iTime*10.+cell.x*30.));\n    vec4 q=quaternionMultiply(qLeftRight,qUpDown);\n\treturn sdfCross(vec2(0.9,0.3),rotation(q,p))+.1;\n}\n\nfloat sdf(vec3 p){\n    vec2 cell=floor((p.xz/2.0));\n    vec2 offset=fract((p.xz/2.0))*2.;\n\treturn min(min(sdfcell(vec3(offset.x,p.y,offset.y),cell+vec2(0.,0.)),\n              sdfcell(vec3(offset.x-2.,p.y,offset.y),cell+vec2(1.,0.))),min(\n              sdfcell(vec3(offset.x,p.y,offset.y-2.),cell+vec2(0.,1.)),\n              sdfcell(vec3(offset.x-2.,p.y,offset.y-2.),cell+vec2(1.,1.))));\n    //return length(p)-1.0;\n}\n\nvec3 rayDirection(in vec2 fragCoord){\n    float zoom=0.6;\n    vec2 offset=fragCoord/iResolution.xy-0.5;\n    offset.y/=iResolution.x/iResolution.y;\n    vec3 rawDir=vec3(offset/zoom,-1);\n    vec2 mouseAngles=iMouse.xy/iResolution.xy-0.5;\n    vec4 qUpDown=quaternion(vec3(1,0,0),radians(90.+mouseAngles.y*10.0));\n    vec4 qLeftRight=quaternion(vec3(0,0,1),radians(0.-mouseAngles.x*10.0));\n    vec4 q=quaternionMultiply(qLeftRight,qUpDown);\n    return normalize(rotation(q,rawDir));\n}\n\n#define delta 0.00025\nvec3 normal(vec3 pos){\n    vec2 e=vec2(1.,-1.);\n    vec3 rawNormal=e.xxx*sdf(pos+delta*e.xxx);\n    rawNormal+=e.xyy*sdf(pos+delta*e.xyy);\n    rawNormal+=e.yyx*sdf(pos+delta*e.yyx);\n    rawNormal+=e.xxx*sdf(pos+delta*e.xxx);\n    return normalize(rawNormal);\n}\n\n#define iteration 128\nvec3 rayMarching(vec3 start,vec3 dir){\n    float tmin=(-1.0-start.y)/dir.y;\n    vec3 pos=tmin*dir+start;\n    float t=tmin;\n    if(tmin<0.){\n        return pos;\n    }\n    for(int i=0;i<iteration;i++){\n        float step1=sdf(pos);\n        if(abs(step1)<.000001*t){\n        \treturn pos;\n        }\n        t+=step1;\n        pos=t*dir+start;\n    }\n    return pos;\n}\n\nfloat lighting(vec3 pos){\n    vec3 light=vec3(0.+sin(2.*iTime),-2.0,0.-cos(2.*iTime));\n    float diffuse=clamp(dot(normalize(light-pos),normal(pos)),0.,1.);\n\treturn diffuse*.5+.5;\n}\n\nvec3 color(vec3 pos){\n\treturn pos.y>1.?vec3(0,0,0):vec3(1.,.5,0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cameraPos=vec3(0.+.25*sin(iTime),-8.0,0.-.25*cos(iTime));\n    vec3 dir=rayDirection(fragCoord);\n    vec3 pos=rayMarching(cameraPos,dir);\n    fragColor =vec4(lighting(pos)*color(pos),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsffWs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsGGR3", "name": "2D voxel traversal", "author": "ich", "description": "traversing a 2 dimensional grid of voxels with a line. said line reflects on non-empty cells.\nuse mouse determine the starting position", "tags": ["2dvoxeltraversaltraverse"], "likes": 8, "viewed": 318, "date": "1589482976", "time_retrieved": "2024-06-20T20:07:30.745422", "image_code": "float n21(vec2 n)\n{\n\treturn fract(sin(dot(n, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nmat2 rot(float a)\n{\n\treturn mat2(\n    \tcos(a), -sin(a),\n        sin(a), cos(a)\n    );\n}\n\nfloat grid(vec2 uv)\n{\n\treturn n21(uv) < .1 ? 1. : 0.;\n}\n\nfloat line(vec2 uv, vec2 lo, vec2 ld)\n{\n    uv -= lo;\n\tvec2 p = dot(uv, ld) / dot(ld, ld) * ld;\n    return length(p - uv);\n}\n\nfloat line_segment(vec2 uv, vec2 lo, vec2 ld)\n{\n\tuv -= lo;\n\tvec2 p = dot(uv, ld) / dot(ld, ld) * ld;\n    float l = clamp(length(p), 0., length(ld));\n    p = normalize(ld) * l;\n    return length(p - uv);\n}\n\nvec2 line_intersect_line(vec2 s1, vec2 v1, vec2 s2, vec2 v2)\n{\n    float b = (-s1.y - v1.y * ((s2.x - s1.x) / v1.x) + s2.y) / (v2.x / v1.x * v1.y - v2.y);\n    return s2 + v2 * b;\n}\n\nvoid cube_line(vec2 n, out vec2 o, out vec2 d)\n{\n\td = -n.yx;\n    o = clamp(n, vec2(0, 0), vec2(1, 1));\n}\n\nbool traverse_voxel(vec2 ro, vec2 rd, out vec2 id, out vec2 p, out vec2 n)\n{\n    const int len = 128;\n    //const int size = 16;\n    int x = int(floor(ro.x));\n    int y = int(floor(ro.y));\n    int stepX = int(sign(rd.x));\n    int stepY = int(sign(rd.y));\n    int cstepX = clamp(stepX, 0, 1);\n    int cstepY = clamp(stepY, 0, 1);\n    //int outX = size * stepX;\n    //int outY = size * stepY;\n    float tDeltaX = abs(rd.y);\n    float tDeltaY = abs(rd.x);\n    float tMaxX = tDeltaX - fract(ro.x * sign(rd.x)) * tDeltaX;\n    float tMaxY = tDeltaY - fract(ro.y * sign(rd.y)) * tDeltaY;\n    int status = -1; // unresolved\n    int i = 0;\n    \n    do {\n        if(tMaxX < tMaxY) {\n            tMaxX += tDeltaX;\n            x += stepX;\n            n = vec2(-stepX, 0);\n        } else {\n            tMaxY += tDeltaY;\n            y += stepY;\n            n = vec2(0, -stepY);\n        }\n        \n        if (grid(vec2(x, y)) == 1.) {\n            status = 0; // hit\n            id = vec2(x, y);\n        }\n        \n        //if (x == outX || y == outY) status = 1; // outside\n    } while(status == -1 && i++ < len);\n    \n    if (status == 0) {\n        vec2 lo, ld;\n        cube_line(n, lo, ld);\n        p = line_intersect_line(ro, rd, id + lo, ld);\n        \n        return true;\n    }\n    return false;\n}\n\nvoid bounce(vec2 uv, vec2 ro, vec2 rd, vec2 id, float scale, inout vec3 col)\n{\n    for (int i = 0; i < 8; i++) {\n        vec2 pid, p, n;\n        col.rg += traverse_voxel(ro, rd, pid, p, n) ? (id == pid ? 1. : 0.) : 0.;\n        col.b += smoothstep(scale / iResolution.y * 2., .0, line_segment(uv, ro, rd * length(p - ro)));\n        ro = p + n * .001;\n        rd = reflect(rd, n);\n    }\n}\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord)\n{\n    float scale = 32.;\n    vec2 uv = frag_coord / iResolution.y * scale;\n    vec2 id = floor(uv);\n    vec3 col = vec3(0);\n    \n    vec2 ro = iMouse.xy / iResolution.y * scale + .001;\n    vec2 rd = rot(iTime * .1) * normalize(vec2(5, 1) + .001);\n    \n    /*\n    vec2 pid, p, n;\n    col.rg += traverse_voxel(ro, rd, pid, p, n) ? (id == pid ? 1. : 0.) : 0.;\n    col.r += smoothstep(.23, .2, length(uv - p));\n    vec2 co, cd;\n    cube_line(n, co, cd);\n    col.r += smoothstep(scale / iResolution.y * 2., .0, line(uv, pid + co, cd));\n    col.rg += smoothstep(scale / iResolution.y * 2., .0, line(uv, pid, n));\n    */\n    \n    col.g += grid(id) * .3;\n    col.bg += smoothstep(.23, .2, length(uv - ro));\n    bounce(uv, ro, rd, id, scale, col);\n\n    frag_color = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsGGR3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsjBD1", "name": "Eclipse Thing", "author": "colejd", "description": "Happened upon this randomly trying out other things. I'll build this out into something more cool when I get time.", "tags": ["sdf", "eclipse"], "likes": 1, "viewed": 48, "date": "1589988804", "time_retrieved": "2024-06-20T20:07:30.975792", "image_code": "// Modified from https://www.shadertoy.com/view/tddXW4\n\n// distance of a circle\nfloat circleDist(vec2 p, float radius) {\n    return length(p) - radius;\n}\n\n// clamp the distnace to 0 and 1\nfloat mask(float dist) {\n    return clamp(-dist, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 clear = vec3(0.0);\n    // Draw the colorful background\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n \t// the sample point and the center of the screen\n    vec2 point = fragCoord.xy;\n\tvec2 center = iResolution.xy / 2.0;\n    \n    // radius of our circle\n    float circleRadius = 50.0;\n    \n    // is the point in the circle?\n    float circle = circleDist(point - center, circleRadius);\n    \n    // mask our circle (and negate the colors)\n    col = mix(clear, col, circle);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsjBD1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsjBRw", "name": "RayMarching Coronavirus", "author": "AlancitoBalanza", "description": "Raymarching Test", "tags": ["raymarching"], "likes": 4, "viewed": 102, "date": "1590541319", "time_retrieved": "2024-06-20T20:07:30.975792", "image_code": "#define PI 3.141592\n#define MAXITER 100\n\nfloat sdSphere(vec3 pos, float rad) {\n    \n    //vec2 ang = vec2(atan(pos.y / length(pos.xz)), vec2(pos.z / pos.x));\n    vec3 norm = normalize(pos);\n    //Sphere UV mapping\n    //vec2 uv = vec2(0.5 + atan(norm.z/norm.x)/(2.0*PI), 0.5 - asin(norm.y)/PI);\n    vec2 uv = vec2(0.5 + atan(norm.z/norm.x)/(2.0*PI), 0.5 - asin(norm.y)/PI);\n    uv *= 30.0;\n    \n    float bump = sin(uv.x)*sin(uv.y);\n    //bump = abs(bump);\n    //float bump = sin(pos.x*10.0)*sin(pos.y*10.0)*sin(pos.z*10.0) * 0.5 + 0.5;\n    bump = pow(bump, 5.0);\n    bump *= 5.0;\n    bump = min(1.0, bump);\n    bump /= 5.0;\n\t//bump = 0.0;\n    return length(pos) - rad - bump;\n}\n\nfloat sdPlane(vec3 pos) {\n\treturn pos.y+sin(pos.x)+sin(pos.z);\n}\n\n\nfloat sceneDist(vec3 pos) {\n    \n    vec3 rep = mod(pos+2.0, 4.0)-2.0;\n    //vec3 rep = pos;\n    float sphere1 = sdSphere(rep-vec3(0.0, 0.0, 0.0), 1.0);\n    float d = sphere1;\n    //float sphere2 = sdSphere(pos-vec3(0.0, 0.75, 0.0), 0.1);\n    //d = min(d, sphere2);\n    //float sphere3 = sdSphere(pos-vec3(0.0, 0.0, 0.75), 0.1);\n    //d = min(d, sphere3);\n    float plane = sdPlane(pos-vec3(0, -10.0, 0));\n    d = min(d, plane);\n    d *= 0.6;\n\t//return min(sphere1, sphere2);\n\treturn d;\n}\n\nmat3 rotation(vec2 angles) {\n    mat3 id = mat3(1, 0, 0, 0, 1, 0, 0, 0, 1);\n    {\n        vec3 u = vec3(cos(angles.x), 0, sin(angles.x));\n        vec3 v = vec3(0, 1, 0);\n        vec3 w = vec3(-sin(angles.x), 0, cos(angles.x));\n        id = id * mat3(u, v, w);\n\t}\n    {\n        vec3 u = vec3(1, 0, 0);\n        vec3 v = vec3(0, cos(angles.y), -sin(angles.y));\n        vec3 w = vec3(0, sin(angles.y), cos(angles.y));\n        id = id * mat3(u, v, w);\n\t}\n    return id;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 lookingAngle = vec2(iTime, (sin(iTime)*0.5+0.5)*-PI/2.0*0.5);\n    //vec2 lookingAngle = vec2(iTime, 0);\n    //lookingAngle.x = iMouse.x / 100.0;\n    //lookingAngle.y = -iMouse.y / 100.0;\n    \n    mat3 rot = rotation(lookingAngle);\n    \n    vec3 pos = rot * vec3(0, 0, 1);\n    pos *= -10.0;\n    \n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 dir = rot * normalize(vec3(uv.xy, 2.5));\n    \n    bool collide = false;\n    int i;\n    for (i = 0; i < MAXITER && !collide; i++) {\n    \tfloat dist = sceneDist(pos);\n        if (dist < 0.0001)\n            collide = true;\n       \tif (dist > 1000.0)\n        {\n            i=MAXITER;\n\t        break;\n\t    }\n        pos += dir * dist;\n    }\n    vec3 col = vec3(float(i) / float(MAXITER));\n    bool lost = float(i) > 0.8*float(MAXITER);\n    /*\n    if (collide)\n        col = vec3(1.0);\n    else\n        col = vec3(0.0);\n*/\n    \n    //if (lost) col.x = 0.0;\n    //col = dir.zzz;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsjBRw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsjfRw", "name": "Jungle Gym", "author": "blackle", "description": "domain repetition with a twist: some of the domains are empty!", "tags": ["sdf"], "likes": 47, "viewed": 778, "date": "1589754259", "time_retrieved": "2024-06-20T20:07:31.890979", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//antialising\n#define AA_SAMPLES 1\n//percentage of domains filled\n#define DENSITY 0.35\n\n//returns a vector pointing in the direction of the closest neighbouring cell\nvec3 quadrant(vec3 p) {\n    vec3 ap = abs(p);\n    if (ap.x >= max(ap.y, ap.z)) return vec3(sign(p.x),0.,0.);\n    if (ap.y >= max(ap.x, ap.z)) return vec3(0.,sign(p.y),0.);\n    if (ap.z >= max(ap.x, ap.y)) return vec3(0.,0.,sign(p.z));\n    return vec3(0);\n}\n\nfloat hash(float a, float b) {\n    return fract(sin(a*1.2664745 + b*.9560333 + 3.) * 14958.5453);\n}\n\nbool domain_enabled(vec3 id) {\n    //repeat random number along z axis so every active cell has at least one active neighbour\n    id.z = floor(id.z/2.); \n    return hash(id.x, hash(id.y, id.z)) < DENSITY;\n}\n\nfloat linedist(vec3 p, vec3 a, vec3 b) {\n    float k = dot(p-a,b-a)/dot(b-a,b-a);\n    return distance(p, mix(a,b,clamp(k,0.,1.)));\n}\n\nfloat ball;\nfloat scene(vec3 p) {\n    float scale = 5.;\n    vec3 id = floor(p/scale);\n    p = (fract(p/scale)-.5)*scale;\n    if (!domain_enabled(id)) {\n        //return distance to sphere in adjacent domain\n        p = abs(p);\n        if (p.x > p.y) p.xy = p.yx;\n        if (p.y > p.z) p.yz = p.zy;\n        if (p.x > p.y) p.xy = p.yx;\n        p.z -= scale;\n        return length(p)-1.;\n    }\n    float dist = length(p)-1.;\n    ball = dist;\n    vec3 quad = quadrant(p);\n    if (domain_enabled(id+quad)) {\n        //add pipe\n        dist = min(dist, linedist(p, vec3(0), quad*scale)-.2);\n    }\n    return dist;\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.01);\n    return normalize(scene(p) - vec3( scene(k[0]),scene(k[1]),scene(k[2]) ));\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax,p)*ax, p, cos(ro)) + sin(ro)*cross(ax,p);\n}\n\nvec3 srgb(float r, float g, float b) {\n    return vec3(r*r,g*g,b*b);\n}\n\nfloat smoothstairs(float p, float scale) {\n    p *= scale;\n    p = smoothstep(0.9, 1., fract(p)) + floor(p);\n    return p/scale;\n}\n\nconst float PI = acos(-1.);\nvec3 pixel_color(vec2 uv) {\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n\tvec3 cam = normalize(vec3(1,uv));\n    vec3 init = vec3(iTime,0,0);\n\n    float yrot = 0.;\n    float zrot = 0.;\n    if (iMouse.z > 0.) {\n        yrot += smoothstep(-PI/2., PI/2., -4.*mouse.y)*PI-PI/2.;\n        zrot += 4.*mouse.x;\n    } else {\n        yrot += cos(iTime*.2)*.6;\n        zrot += sin(iTime*.2)*.6;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    \n    vec3 p = init;\n    bool hit = false;\n    bool triggered = false;\n    bool outline = false;\n    bool type = false;\n    float dist;\n    //ray marching\n    for (int i = 0; i < 150 && !hit; i++) {\n        dist = scene(p);\n        float outline_radius = 0.1*sqrt(distance(p,init))/3.;\n        if (dist < outline_radius*.9 && !triggered) {\n            triggered = true;\n            type = dist == ball;\n        }\n        if (triggered) {\n            float line = (outline_radius-dist);\n            outline = line < dist || type != (dist == ball);\n\t\t\tdist = min(line, dist);\n        }\n        hit = dist*dist < 1e-6;\n        p+=dist*cam;\n        if (distance(p,init)>90.) break;\n    }\n    if (!hit) return vec3(0.4);\n    bool is_ball = dist == ball;\n    vec3 n = norm(p);\n    vec3 r = reflect(cam, n);\n \t\n    //add outline to sharp edges\n    outline = outline || scene(p+n*.1) < 0.09;\n    float fog = smoothstep(80.,60., distance(p,init));\n\n    //shading\n    float ao = smoothstep(.0, .5, scene(p+n*.5));\n    float fact = ao*length(sin(r*vec3(3.,-2.,2.))*.5+.5)/sqrt(3.);\n    float lod = smoothstep(90.,50.,distance(p,init))*5.; //make the shading simpler in the distance\n    fact = smoothstairs(fact, lod)+.1;\n    vec3 ballcol = abs(erot(srgb(0.6,0.7,0.8), normalize(cos(p*.5)), .3));\n    vec3 matcol = is_ball ? ballcol : srgb(0.6,0.65,0.7);\n    vec3 col = matcol*fact + mix(vec3(1), matcol, .4)*pow(fact, 10.)*1.5;\n    col *= smoothstep(0.,.25,abs(dot(cam, n)));\n    col = mix(vec3(.6), outline ? vec3(0.) : col, fog);\n    if (isnan(length(col))) return vec3(.6); //i have no idea where this nan is coming from\n    return col;\n}\n\nvec2 weyl_2d(int n) {\n    return fract(vec2(n*12664745, n*9560333)/exp2(24.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    fragColor = vec4(0);\n    for (int i = 0; i < AA_SAMPLES; i++) {\n        vec2 uv2 = uv + weyl_2d(i)/iResolution.y*1.25;\n        fragColor += vec4(pixel_color(uv2), 1.);\n    }\n\tfragColor.xyz = sqrt(fragColor.xyz/fragColor.w);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc0-1.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsjfRw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsKXz3", "name": "LSD Sun", "author": "daslaller", "description": "test, with stolen stuff. sorry", "tags": ["tutorial", "circle", "noob", "stolen"], "likes": 1, "viewed": 48, "date": "1590135689", "time_retrieved": "2024-06-20T20:07:32.181829", "image_code": "vec3 rgb(float r, float g, float b) {\n    if(r > 1.0){\n        r = 1.0;\n    }\n    if(g > 1.0){\n        g = 1.0;\n    }\n    if(b > 1.0){\n        b = 1.0;\n    }\n\treturn vec3(r, g, b);\n}\n\nvec3 intRgb(float r, float g, float b){\n\treturn rgb(r / 255.0, g / 255.0, b / 255.0);\n}\n\n\nvec4 circle(vec2 uv, vec2 pos, float rad, vec3 color) {\n\tfloat d = length(pos - uv) - rad;\n//float t = clamp(d, 0.0, 1.0); //Uncomment for original effect\n\treturn vec4(color, 1.0 -d * 0.01); //-d * 0.01 //-t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n        // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    float radius = 0.5 * iResolution.y; //Size of circle\n //   vec2 center = iResolution.xy * 0.5; //center of screen\n    \n    vec4 myCircle = circle(fragCoord.xy, iMouse.xy , radius, col); //My circle (iMouse.xy * uv) / 0.5\n    \n        // Background layer\n\tvec4 background = vec4(rgb(0.82, 0.87, 0.89), 1.0); //Simple background\n\n    // Output to screen\n    fragColor = mix(background, myCircle, myCircle.a);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsKXz3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tslBRB", "name": "My Spinning Planet", "author": "aberkson1", "description": "For fun", "tags": ["spaceplanet"], "likes": 1, "viewed": 49, "date": "1588650103", "time_retrieved": "2024-06-20T20:07:32.188009", "image_code": "#define scale 10.0\n\n\nfloat random(vec2 st)\n{\n \treturn fract(sin(dot(st, vec2(12.43, 67.88)))*94436.3453);   \n}\n\nfloat noise(vec2 uv)\n{\n\tvec2 i = floor(uv);\n    vec2 f = fract(uv);\n    vec2 u = smoothstep(0.0, 1.0, f);\n    \n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n    \n    return mix( mix(a, b, u.x),\n                mix(c, d, u.x), u.y);\n}\n\n\nmat2 rotate2d(float angle)\n{\n    return mat2(cos(angle), -sin(angle),\n                sin(angle),  cos(angle));\n}\n\nvec2 line(in vec2 uv, float b, float c)\n{\n \tvec2 f = fract(uv);\n    return smoothstep(b - c, b, f) - smoothstep(b, b + c, f);\n}\n\nfloat smoothLine(in vec2 uv)\n{\n    vec2 f = fract(uv);\n    vec2 u = smoothstep(0.0, 1.0, f);\n    float b1 = noise(uv - vec2(0.0, -1.0));\n    float b2 = noise(uv - vec2(0.0, 0.0));\n    float dist = (1.0 - abs(b2 - u.y)) * abs(b2 - u.y);\n    return  1.0 - dist;\n}\n\nvec3 planet( in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= scale;\n    //uv = rotate2d(3.2*(uv.x - 14.2) * (uv.y / 8.0) * 3.1415 / 180.0) * uv;\n    uv = rotate2d(21.0 * 3.1415 / 180.0) * uv;\n    \n    vec2 pos = vec2(uv.x + iTime, uv.y);\n    float pattern = line(pos, noise(pos), 0.07).y;\n    float colorPattern = smoothLine(pos);\n    \n    return vec3(pattern * .2, (1.0 - colorPattern) + pattern * .2, pattern * .2);\n}\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec2 random3( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(103.1,311.7)),dot(p,vec2(183.5,183.3))))*43758.5453);\n}\n\nvec3 star(in vec2 uv, float _scale)   \n{\n    \n    uv *= _scale;\n    \n    vec2 i_st = floor(uv);\n    vec2 f_st = fract(uv);\n    \n    float min_dist = 1.0;\n    float max_dist = 1.0;\n    float min_dist2 = 1.0;\n    \n    for (int y = -1; y <= 1; ++y)\n    {\n    \tfor (int x = -1; x <= 1; ++x)\n        {\n        \tvec2 neighbor = vec2(float(x), float(y));\n            \n            vec2 point = random2(i_st + neighbor);\n            point = 0.5 + 0.5*sin(iTime + 6.2831*point);\n            \n            vec2 point2 = random3(i_st + neighbor);\n            point2 = 0.5 + 0.5*sin(iTime + 8.2831*point2);\n            \n            vec2 point3 = random2(i_st + neighbor);\n            point2 = 0.5 + 0.5*sin(iTime + 1.2831*point3);\n            \n            vec2 diff = neighbor + point - f_st;\n            vec2 diff2 = neighbor + point2 - f_st;\n            vec2 diff3 = neighbor + point3 - f_st;\n            \n            float dist = abs(length(diff));\n            float dist2 = abs(length(diff2));\n            float dist3 = abs(length(diff3));\n            \n            min_dist = min(min_dist, dist);\n            max_dist = min(max_dist, dist2);\n            min_dist2 = min(min_dist2, dist3);\n        }\n    }\n    return vec3(min_dist + max_dist + min_dist2);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    \n    vec3 color;\n    vec3 starCol = vec3(0.6, 0.6, 0.6);\n    vec2 center = vec2(0.85, 0.5);\n    \n    float shadow = distance(center + 0.4, uv);\n    float shadow2 = distance(center + vec2(-0.5, -0.5), uv);\n    \n    vec3 stars = star(0.6*uv, 50.0);\n    vec3 circleForeground = (1.0 - step(0.4, distance(center, uv))) * vec3(1.0);// (planet(fragCoord) * 0.4);\n    vec3 circleBackground = (step(0.4, distance(center, uv))) * vec3(1.0);\n    \n    vec2 ringPos = rotate2d(30.0 * 3.1415 / 180.0) * (uv + 1.25);\n    float ring = line(ringPos, 0.5, 0.07).y * 10.0;\n\t\n    starCol -= stars;\n    circleBackground *= starCol * abs(sin(iTime / 10.0 + uv.x));\n    circleForeground *= shadow2 * shadow * planet(fragCoord);\n    color = circleBackground + circleForeground;\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tslBRB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tslBW7", "name": "Fortress Harkonnen", "author": "mrange", "description": "License CC0: Fortress Harkonnen\nInspired by: http://www.fractalforums.com/new-theories-and-research/very-simple-formula-for-fractal-patterns/\n", "tags": ["2d", "fractal"], "likes": 24, "viewed": 636, "date": "1588421175", "time_retrieved": "2024-06-20T20:07:33.031058", "image_code": "// License CC0: Fortress Harkonnen\n// Inspired by: http://www.fractalforums.com/new-theories-and-research/very-simple-formula-for-fractal-patterns/\n\n// SABS from ollj\n#define LESS(a,b,c) mix(a,b,step(0.,c))\n#define SABS(x,k)   LESS((.5/k)*x*x+k*.5,abs(x),abs(x)-k)\n\n#define PI      3.141592654\n#define TAU     (2.0*3.141592654)\n#define TIME    iTime\n#define PERIOD  55.0\n#define PERIODS 5.0\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nfloat plane(vec2 p, vec2 n, float m) {\n  return dot(p, n) + m;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat holey(float d, float k) {\n  return abs(d) - k;\n}\n\nfloat tanh2(float x) {\n  // Hack around precision problem\n  if (abs(x) > 50.0) {\n    return sign(x);\n  } else {\n    return tanh(x);\n  }\n}\n\nfloat nfield(vec2 p, vec2 c) {\n  vec2 u = p;\n\n  float a = 0.0;\n  float s = 1.0;\n\n  \n  for (int i = 0; i < 25; ++i) {\n    float m = dot(u,u);\n    u = SABS(u, 0.0125)/m + c;\n    u *= pow(s, 0.65);\n    a += pow(s, 1.0)*m;\n    s *= 0.75;\n  }\n  \n  return -tanh2(0.125*a);\n}\n\nvec3 normal(vec2 p, vec2 c) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(2.0/iResolution.y, 0);\n  \n  vec3 n;\n  n.x = nfield(p + e.xy, c) - nfield(p - e.xy, c);\n  n.y = 2.0*e.x;\n  n.z = nfield(p + e.yx, c) - nfield(p - e.yx, c);\n  \n  return normalize(n);\n}\n\nvec3 field(vec2 p, vec2 c) {\n  vec2 u = p;\n\n  float a = 0.0;\n  float s = 1.0;\n\n  vec2 tc = vec2(0.5, 0.3);\n  rot(tc, TAU*TIME/PERIOD);\n  vec2 tpn = normalize(vec2(1.0));\n  float tpm = 0.0 + 1.4*tanh(length(p));\n  \n  float tcd = 1E10;\n  float tcp = 1E10;\n  \n  for (int i = 0; i < 18; ++i) {\n    float m = dot(u,u);\n    u = SABS(u, 0.0125)/m + c;\n    tcd = min(tcd, holey(circle(u-tc, 0.05), -0.1));\n    tcp = min(tcp, holey(plane(u, tpn, tpm), -0.1));\n    u *= pow(s, 0.5);\n    a += pow(s, 1.0)*m;\n    s *= 0.75;\n  }\n  \n  return vec3(tanh(0.125*a), tanh(tcd), tanh(tcp));\n\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col=pow(clamp(col,0.0,1.0),vec3(.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= iResolution.x/iResolution.y;\n    \n  float currentPeriod = mod(floor(TIME/PERIOD), PERIODS);\n  float timeInPeriod = mod(TIME, PERIOD);\n  \n  p *= 0.25 + (0.005*timeInPeriod) + pow(1.35, currentPeriod);\n  vec2 c = vec2(-0.5, -0.35);\n   \n  vec3 gp = vec3(p.x, 1.0*tanh(1.0 - (length(p))), p.y);\n  vec3 lp1 = vec3(-1.0, 1.5, 1.0);\n  vec3 ld1 = normalize(lp1 - gp);\n  vec3 lp2 = vec3(1.0, 1.5, 1.0);\n  vec3 ld2 = normalize(lp2 - gp);\n  vec3 f = field(p, c);\n\n  vec3 n = normal(p, c);\n\n  float diff1 = max(dot(ld1, n), 0.0);\n  float diff2 = max(dot(ld2, n), 0.0);\n  \n  vec3 col = vec3(0.0);\n  \n  const vec3 dcol1 = vec3(0.3, 0.5, 0.7).xyz;\n  const vec3 dcol2 = 0.5*vec3(0.7, 0.5, 0.3).xyz;\n  const vec3 scol1 = 0.5*vec3(1.0);\n  const vec3 scol2 = 0.5*0.5*vec3(1.0);\n  \n  col += diff1*dcol1;\n  col += diff2*dcol2;\n  col += scol1*pow(diff1, 10.0);\n  col += scol2*pow(diff2, 3.0);\n  col -= vec3(tanh(f.y-0.1));\n  col += 0.5*(diff1+diff2)*(1.25*pow(vec3(f.z), 5.0*vec3(1.0, 4.0, 5.0)));\n \n  col = postProcess(col, q);\n \n  const float fade = 2.0;\n  float fadeIn  = smoothstep(0.0, fade, timeInPeriod);\n  float fadeOut = 1.0-smoothstep(PERIOD - fade, PERIOD, timeInPeriod);\n  col *= fadeIn*fadeOut;\n \n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [{"id": "Xl23Dw", "previewfilepath": "https://soundcloud.com/gmm/ugress-win-without-triumph", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/gmm/ugress-win-without-triumph", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc0-1.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tslBW7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tssBD7", "name": "Dancing Sine Wave by Darko", "author": "omegasbk", "description": "This is my simple sine wave implementation. ", "tags": ["sinewave"], "likes": 1, "viewed": 90, "date": "1588430519", "time_retrieved": "2024-06-20T20:07:33.031058", "image_code": "// Feel free to use this code in your projects\n// Reference me if you really want to :) \n\n#define M_PI 3.1415926535897932384626433832795\n#define AMPLITUDE 0.2\n#define PHASE 2. * M_PI\n#define THICKNESS 0.03\n#define FREQUENCY 1.\n#define WAVE_LENGTH 0.1\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y -= 0.5;  \n    \n    float phase = PHASE + uv.x / WAVE_LENGTH;\n\n    int tx = int(uv.x*512.0);\n\tfloat fft  = texelFetch(iChannel0, ivec2(tx,0), 0).x; \n    float wave = texelFetch(iChannel0, ivec2(tx,1), 0).x;\n    \n\tfloat amplitude = AMPLITUDE + wave/50.;\n    float frequency = FREQUENCY + wave/200.;\n    \n    vec3 col = vec3(0., 0., 0.);\n    \n    float waveValue = amplitude * sin(2. * M_PI * frequency * iTime + phase);\n        \n    if (uv.y < waveValue + THICKNESS\n       && uv.y > waveValue - THICKNESS)\n    {\n        col = vec3(1. - (abs(waveValue - uv.y) / THICKNESS));\n        col.g += sin(iTime)*wave;\n        col.r += cos(iTime)*wave;\n        col.b += tan(iTime)*wave;\n    }\n        \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tssBD7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tssBDN", "name": "Cuernos--v2", "author": "jorge2017a1", "description": "Cuernos--v2", "tags": ["cuernosv2"], "likes": 2, "viewed": 63, "date": "1588297893", "time_retrieved": "2024-06-20T20:07:36.400567", "image_code": "//por jorge2017a1-\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define PI 3.14159265358979323846264\n\n\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n\nfloat pi = atan(1.0)*4.0;\nfloat tau = atan(1.0)*8.0;\n\n///------------------------------------\nstruct TObj\n{\n    float tipo;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n   \n};\n\n\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\n\n//-----------------------------------------\n#define MAXREFLECTIONS 2\n#define MAXITER 64\n//-----------------------------------------\nvec3 ambientColor = vec3(0.05, 0.15, 0.2);\nvec3 diffuseColor = vec3(0.2, 0.6, 0.8);\nvec3 specularColor = vec3(1.0, 1.0, 1.0);\nvec3 lightDir = normalize(vec3(0.0, 4.0, 5.0));\nvec3 spherePos = vec3(0.0, 0.5, 0.0);\n//-----------------------------------\n\n\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n\n\n\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n//Sphere function\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\n\n// signed\nfloat box(vec3 p, vec3 b)\n{\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat cyl(vec3 p, float r, float h) {\n\treturn max(length(p.xz) - r, abs(p.y) - h);\n}\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n//---------------------------------------------\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); \n    float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, -sa, +.0,\n\t\t+sa, +ca, +.0,\n\t\t+.0, +.0, +1.0);\n}\n\n\n///---------------------------------------------\n\nfloat opU( float d1, float d2 )\n{\n    return min(d2,d2);\n}\n//-------------------------------------------------\n\n\nmat2 rotate(float a) {\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\n//----------------------------\n// Tunnel pattern studied from shane & shau\n// i.e. https://www.shadertoy.com/view/4tKXzV\nvec2 path(float t) {\n\tfloat a = sin(t*.2 + 1.5), b = sin(t*.2);\n\treturn vec2(a*2., a*b);\n}\n//-------------------------\n\nvec2 pathv2(float t) \n{\n\tfloat a = sin(t*.2 + 1.5), b = sin(t*.2);\n\t//return vec2(a*2., a*b);\n    return vec2(a*2., 1.0);\n}\n\n\n\nfloat GetDist(vec3 p  ) \n{\t\n\n     float d, dif1,dif2; \n     d=999.9;\n \n    \n   vec3 pp, p2;\n    pp=p;\n    p2=p;\n    \n \n    float planeDist1 = p.y-5.0;  //piso inf\n    float planeDist1sup = 20.0-p.y;  //piso sup\n    float planeDist2 = p.x+10.0; //pared izq\n    float planeDist3 = 10.0-p.x;  //pared der\n    float planeDist4 = -p.z+30.0;  //pared atras\n \n    \n   \n    vec2 res;\n    res = vec2(9999, 0);\n    \n    if (iTime<20.0)\n    {\n        float  sdp1= sdSphere(p-vec3(0.0,10.0,20.0+iTime), 1.5 );\n    \tres =opU(res, vec2(sdp1,6)); \n \t}   \n    \n    \n    if (iTime>20.0 &&  iTime<40.0)\n    {\n        float  sdp1= sdSphere(p-vec3(0.0,10.0,40.0+iTime), 1.5 );\n    \tres =opU(res, vec2(sdp1,6)); \n \t}   \n    \n    \n    \n    p.xy -= pathv2(p.z);\n\tvec3 pa= p;\n    \n    \n    \n    // spinal\n\tfloat t = 2.;\n    \n    p.y=p.y-5.0+1.0*cos(iTime);\n    p.y=p.y+ pa.y + 1.0 + 0.3*(sin(pa.x + 3.0*iTime) + sin(pa.z));\n    \n    \n   p.z = mod(p.z - t*.65, t) - t*.75;\n   float dd = max(cyl(p.yzx, 1.2, .1), -cyl(p.yzx - vec3(.12, 0, 0), 1.1, 1.9));\n\n    \n   float plane = p.y + 1.0 + 0.3*(sin(p.x + 3.0*iTime) + sin(p.z));\n   res =opU(res, vec2(plane,29));\n        \n   res =opU(res, vec2(dd,6));\n   res =opU(res, vec2(1.0,6));\n  \n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n    \n    return d;\n}\n\n\n\n///----------------------------------------------------------\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n\tfloat dO=0.2;\n    //Determines size of shadow\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = ro + rd*dO;\n        \n        float dS = GetDist(p);\n        \n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) \n        {\n            //mObj.dist=dO; \t\n            mObj.p=p; \t\n            gres2 = vec2(dO,dS); \n            break;\n    \t}    \n        \n    }\n    \n    return dO;\n}\n\n\n//---------------------------------------------------\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n\nfloat GetLightPar(vec3 p, vec3 plig) {\n    vec3 lightPos = plig;\n    //Determine movement of light ex. shadow and light direction and diffusion\n    //lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat saturate(float f)\n{\n\treturn clamp(f,0.0,1.0);\n}\n\n    \n\n#define offset1 4.7\n#define offset2 4.6\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) \n{\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\n\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tif(i==0 )\n    {\n    \n        \n      return vec3(0.0,0.0,0.0);\n    }\n    \n    if(i== 1 )\n    {\n        \n        //return vec3(1, 0.5, 0);\n        \treturn vec3(1.0,0.0,0.0);\n        } \n    if(i== 2 )\n    {\n        //return vec3(1.0, 1.0, 1.0);\n        \treturn vec3(0.0,1.0,0.0);\n        } \n    if(i== 3 )\n    {\n        //return vec3(247./255., 168./255.,  184./255.); \n        \treturn vec3(0.0,0.0,1.0);\n       } \n    if(i== 4 )\n    {\n        \n        //return vec3(0, 1, 1);\n        \treturn vec3(0.0,1.0,1.0);\n        } \n    if(i== 5 )\n    {\n        //return vec3(85./255., 205./255., 252./255.);\n        return vec3(1.0,0.0,1.0);\n        \n        } \n    if(i== 6 )\n    {\n        \n        ///return  vec3(0.5, 0.8, 0.9);\n        return vec3(1.0,0.5,1.0);\n        } \n        \n    if(i== 7 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n       } \n    if(i== 8 )\n    {\n       \n        \n        return vec3(0.425, 0.56, 0.9); \n       } \n    if(i== 9 )\n    {\n        \n        return vec3(0.5, 0.6, 0.6); \n     } \n    if(i== 10 )\n    {\n        return vec3(0.0, 1.0, 0.0);\n    } \n    \n    if(i== 11 )\n    {\n        return vec3(0.25, 0.25, 0.25);\n    } \n    \n     if(i== 15 )\n    {\n    \t\treturn vec3(1.0,0.0,1.);\n       } \n     if(i== 16 )\n    {\n    \t\treturn vec3(1.0,1.0,0.0);\n     } \n    \n    \n    \n    if(i== 21 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*0.12;\n            marbleP.z += sin(p.y*23.0)*0.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.3);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.4,0.4,0.6),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n    \n    \n    \n     if(i== 23)\n    {\n    \n        \n        return  vec3(0.425, 0.16, 0.6);\t\n        \t\n\t} \n    \n    \n    \n    if(i== 24)\n    {\n      float size = (-mObj.uv.y+.1)/2.5;\n     vec3 color = vec3(0.,0.,0.);\n     color += vec3(mod(floor(mObj.uv.x/size+sin(iTime)) + floor(mObj.uv.y*20./size+iTime),2.)-.8-mObj.uv.y);\n\n     // Lightsource falloff on floor\n     color *= vec3(smoothstep(0.,1.,1.-length(vec2(.2-mObj.uv.x/6.,.6+mObj.uv.y/1.5))));\n        return color;\n\t}    \n    \n    \n    if(i== 25)\n    {\n      float size = (-mObj.p.y+.1)/2.5;\n     vec3 color = vec3(0.,0.,0.);\n     color += vec3(mod(floor(mObj.p.x/size) + floor(mObj.p.y*20./size),2.)-.8-mObj.p.y);\n\n     // Lightsource falloff on floor\n     color *= vec3(smoothstep(0.,1.,1.-length(vec2(.2-mObj.p.x/6.,.6+mObj.p.y/1.5))));\n        return color;\n\t} \n    \n    if(i== 26)\n    {\n        // checkerboard hack\n\t\t\tvec2 cb = floor(mObj.p.xz);\n\t\t\tfloat cb2 = mod(cb.x*1.2 + cb.y, 2.);\n        \treturn vec3(1.4 + 0.1*cb2, 0.3 + 0.85*cb2, 0.35 - 0.3*cb2)*0.8;\n            \n    }   \n    \n    \n    \n    if(i== 27)\n    {\n      vec3 outColor = vec3(0.0);\n      float sinus1 = sin(mObj.uv.x*5.1 +iTime*0.5) * 0.1 - 0.2;\n      float land1 = step(sinus1, mObj.uv.y);\n      vec3 landColor1 = vec3(0.2, 0.4, 0.3);\n      outColor = mix(outColor, landColor1, 1.0 - land1);\n        return outColor;\n    }\n    \n    \n    if (i== 28)\n     {   \n    \tvec3 position=mObj.p;\n        vec3 normal=mObj.normal;\n    \t//position *= scale;\n         position *= 0.25;\n    \t\n    \t//vec3 color = vec3(1.0);\n        vec3 color = vec3(0.98,0.86,0.4);\n    \n    \tcolor = color * 0.75 + 0.25;\n    \tcolor *= normal * .25 + .75;\n    \tfloat checker = sin(position.x * pi * 4.0) * sin(position.y * pi * 4.0) * sin(position.z * pi * 4.0);\n    \tcolor *= step(0.0,checker) * 0.25 + 0.75;\n         return color;\n    }\n    \n    \n    \n    if (i== 29)\n     {  \n        //checkboard\n        //vec3 col = vec3(0.75)*(0.3 + mod(floor(mObj.p.x) + floor(mObj.p.z), 2.0));\n        vec3 col = vec3(1.0)*(0.23 + mod(floor(mObj.p.x*0.25) + floor(mObj.p.z*0.25), 2.0));\n         return col;\n    }\n    \n    \n    \n}\n\n///--------------------------------------------\n\n// phong shading\nvec3 p_shadingv2( vec3 v, vec3 n, vec3 eye, vec3 plight_pos1,  vec3 plight_color1 )\n{\n\t// ...add lights here...\n\t\n\tfloat shininess = 16.0;\n\t\n\tvec3 final = vec3( 0.0 );\n\t\n\tvec3 ev = normalize( v - eye );\n\tvec3 ref_ev = reflect( ev, n );\n\t\n\t// light\n\t{\n\t\n\t\tvec3 vl = normalize( plight_pos1 - v );\n\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n\t\t\n\t\tfinal += plight_color1 * ( diffuse + specular ); \n\t}\n\t\n\t\n\n    return (final);\n}\n\n\n\n\n\n//-------------------------------------------\nvec3 Shade(vec3 position, vec3 normal, vec3 direction, vec3 camera)\n{\n    //position *= scale;\n    position *= 0.125;\n    vec3 color = vec3(1.0);\n    \n    color = color * 0.75 + 0.25;\n    \n    color *= normal * .25 + .75;\n    \n    float ambient = 0.1;\n    float diffuse = 0.5 * -dot(normal,direction);\n    float specular = 1.0 * max(0.0, -dot(direction, reflect(direction,normal)));\n    \n    color *= vec3(ambient + diffuse + pow(specular,5.0));\n\n    color *= smoothstep(12.0,6.0,length(position));\n    \n    return color;\n}\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n    \n\n\tlight_pos1   = vec3( -20.0, -20.0, -iTime*2.0);\n \tlight_color1 = vec3( 0.3, 0.2, 1.0 );\n\n \tlight_pos2   = vec3( 20.0,20.0, 20.0 +iTime*2.0 );\n \tlight_color2 = vec3( 1.0, 0.7, 0.7);\n    \n\n    \n    \n    vec3 ro = vec3(0.0,6.0,iTime*2.0);\n    ro.xz += pathv2(ro.z);\n \t\n    \n\t//ro =get_mouse(ro);\n    vec3 rd = normalize( vec3(uv,1.0));\n    \n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    mObj.uv=uv;\n    mObj.rd=rd;\n    mObj.ro=ro;\n\n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n  \n    vec3 p = (ro + rd * d ); \n    glpRoRd=p;\n    mObj.p=p;\n    \n    float dif=1.5;\n  \n    \n    mObj.dist =d;\n    vec3 colobj;\n    \n    vec3 nor= GetNormal( p);\n    mObj.normal=nor;\n    colobj=getSphereColor(int( Obj.tipo));\n    \n    \n    \n    \n    \n    vec3 col2=vec3(0.0);\n    if (d>0.0)\n    {    \n    col2+= p_shadingv2( p, nor, ro, light_pos1, light_color1 );\n    col2+= p_shadingv2( p, nor, ro, light_pos2, light_color2 );\n    col2=(col2)/2.0;\n \n    col2= colobj*col2;\n    col= col2*dif;\n   }\n\n   \n\n    int f = int(mod(iTime * 60.0, 30.0));\n  \n    \n    \n    \n    if  ( float(f)<iTime )\n    {\n    \tvec3 sh= Shade( p, nor, rd, ro);\n        if (iTime<40.0)\n    \t\tcol =col*sh*8.0;\n \t}   \n    \n    \n    \n    //col = pow(col, vec3(1.0/2.2));  \n    col = pow(col, vec3(0.4545));  \n    \n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tssBDN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsSBR3", "name": "Moving Glass Garden - fork", "author": "alvarobyrne", "description": "Looking at the garden through the glass block", "tags": ["glass", "green", "block", "garden"], "likes": 7, "viewed": 252, "date": "1590493712", "time_retrieved": "2024-06-20T20:07:36.400567", "image_code": "// Fork of \"Glass Garden\" by TAKUSAKU. https://shadertoy.com/view/3s2Bzy\n// 2020-05-26 11:46:54\n\nfloat rand (in vec2 _st) {\n    return fract(sin(dot(_st.xy, vec2(-0.370,0.200+0.0002*sin(iTime*0.1))))*757.161);\n}\n\nfloat noise (in vec2 _st) {\n\tconst vec2 d = vec2(0.0, 1.0);\n    vec2 b = floor(_st);\n    vec2 f = smoothstep(vec2(0.), vec2(0.5), fract(_st));\n    float m1 = mix(rand(b), rand(b + d.yx), f.x);\n    float m2 = mix(rand(b + d.xy), rand(b + d.yy), f.x);\n\treturn mix(m1, m2, f.x);\n}\n\nfloat fbm ( in vec2 _st) {\n    float v = 0.23 + 0.05 * sin(iTime*0.2);\n    float a = .5;\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5)+sin(iTime*0.01), -sin(0.5), acos(0.5));\n    for (int i = 0; i < 5; ++i) {\n        v += a * noise(_st);\n        _st = rot * _st * 8.0;\n        a *= 0.32;\n    }\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = (fragCoord * 2. - iResolution.xy) / min(iResolution.x, iResolution.y) * 1.7;\n   \n    vec2 co = st;\n    co.x += 0.9*sin(iTime);\n    co.y += 4.;\n\n    float len;    \n    for (int i = 0; i < 3; i++) {\n        len = length(co);\n        co.x +=  sin(co.y + iTime * 0.620)*0.;\n        co.y +=  cos(co.x + iTime * 0.164)*0.1;\n    }\n    len -= 3.;\n     \n    vec3 col = vec3(0.);\n\n    vec2 q = vec2(0.);\n    q.x = fbm( st + 1.0);\n    q.y = fbm( st + vec2(-0.450,0.650));\n\n    vec2 r = vec2(0.);\n    r.x = fbm( st + 1.0*q + vec2(0.570,0.520)+ 0.16*iTime );\n    r.y = fbm( st + 1.0*q + vec2(0.340,-0.570)+ 0.1*iTime);\n    \n    for (float i = 0.; i < 3.; i++) {\n        r += 1.0 / abs(mod(st.xy+vec2(0.4*iTime,0.), 0.732* i) * 10.) * 1.;// Glass block grid\n    }\n    float f = fbm(st+r);\n    \n    col = mix(col, cos(len + vec3(0.0, 1.0, 0.3)), 1.0);\n    col = mix(vec3(0.562,0.680,0.482), vec3(0.357,0.518,0.600), col);\n    \n    fragColor = vec4(2.0*(f*f*f*f+.6*f*f+.5*f)*col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsSBR3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsSBRd", "name": "Bispirale Hedges", "author": "spalmer", "description": "someone dared someone to do it, so ...", "tags": ["hedge"], "likes": 6, "viewed": 100, "date": "1590600072", "time_retrieved": "2024-06-20T20:07:37.673325", "image_code": "// fork of https://shadertoy.com/view/tlyGzG\n// and uses a FabriceNeyret2 snippet :)\n// TODO needs more work, some trees, and a lot of cleanup\n\n// simple bispirale by Fabrice :) https://shadertoy.com/view/tsBfRt\nfloat abispirale(vec2 u)\n{\n    u /= 32.; \n    u.x += sign(u.y)*.375;\n    return .5 - cos(58.6* length(u)) * .5;\n}\n// btw there's a busted derivative between the two halves of the bispirale!\n\n//#define Enviro   iChannel2\n \nconst float tau = 2. * acos(-1.);\n\nvoid rot(inout vec2 p, vec2 s) \n{\n\tp = p * s.x + vec2(p.y, -p.x) * s.y;\n}\n\nfloat rand(float x)\n{\n    return fract(sin(x) * 25314.67283);\n}\n\nfloat hash(vec2 x)\n{\n\treturn rand(dot(x, vec2(7,5)));\n}\n\nfloat hash(vec3 x)\n{\n\treturn rand(dot(x, vec3(7,5,11)));\n}\n\nfloat hbispirale(vec2 p)\n{\n    float c = abispirale(p);\n    c = clamp(c*2.-1., 0., 1.);\n    return 1.-pow(max(0., 1.-c), 2.);\n}\n/* // just inlined\nfloat dbispirale(vec3 p)\n{\n    float h = hbispirale(p.xz);\n\t// converts height to fake conservative distance atm\n    return p.y - h;\n//\treturn sqrt(sqrt(c));\n//    if (c >= .99) return .5;\n//    c = c * .5; // HACK thin walls\n     // round the hedges\n//    float s = sqrt(1. - c*c);\n//    return 0.; //.5 - .5 * c;   \n}\n*/\nfloat dleaf(vec2 q)\n{\n    q.x = abs(q.x);\n    q.x = q.x + .5;\n    return length(q) - 1.02;\n}\n\n\nfloat gt(vec3 p, vec3 c, vec3 o, float h, inout float r)\n{\n//    return length(p) - .2; //.001; //1./tSpace;\n    vec3 q = p + o; // o is presently zero; q should be relative to cell origin, local coord, basically\n    if (q.y > h) //2.5) // 0.)  //\n        return r; // cull if center not inside hedge shape\n     // need random orientation\n    float n1 = hash(c) * tau;\n    float n2 = (hash(c+1.) * 2. - 1.) * .25 * tau; //sin(2.5*iTime) * 3.14 * .5; //\n    rot(q.xz, vec2(cos(n1),sin(n1)));\n    rot(q.yz, vec2(cos(n2),sin(n2))); // fine, we'll just do it this way!\n    float d = dleaf(q.xz / .5) * .5;\n    float dy = abs(q.y) - .02;\n    d = max(d, dy); //min(d, dy); //d += dy; // flat\n    return r = min(r, d); //d; //\n}\n\nfloat gd(vec3 p, float h)\n{\n    vec3 c = floor(p);\n    const float ldens = 1.; //.5; //.2; // affects leaf density, not scale\n\t/*c = floor(p / ldens); // tile address\n    p.xyz = (fract(p / ldens) - .5) * ldens; // local coord\n    //return length(p) - .2; //.001; //1./ldens; */\n\tfloat r = 3e38; //dist2frame(p, 4.25);\n    //gt(p, c, vec3(0), h, r); // had 2 fields interleaved before\n    // no, must re-tile again  - beware 0.5 scale factor! still causing problems\n    gt((fract((p + .25) / ldens) - .5) * ldens, c+.5, vec3(0), h, r);\n    // random offsets would be better but this is pretty dense and looks ok-ish for now\n    //r *= ldens;\n    return r;\n  #if 0\n //   return gt(p, c, vec3(0), 3e38); // actual leaf\n    // TODO checking neighbor cells will be necessary once I start perturbing their offsets near the cell boundaries\n\tvec2 z = vec2(0,1);\n\tgt(p, c, z.xxx, h, r);\n\tgt(p, c, z.yxx, h, r);\n\tgt(p, c, z.xyx, h, r);\n\tgt(p, c, z.yyx, h, r);\n\tgt(p, c, z.xxy, h, r);\n\tgt(p, c, z.yxy, h, r);\n\tgt(p, c, z.xyy, h, r);\n\tgt(p, c, z.yyy, h, r);\n//\tr = min(r, abs(p.y - 0.));\n\treturn r; \n  #endif\n}\n\nfloat max3(vec3 a) { return max(a.x,max(a.y,a.z)); }\n\nvec3 campos, camdir;\n\nfloat sdf(vec3 p)\n{\n\tfloat h = hbispirale(p.xz);\n    h = max(h, 0.);\n    // this part's really supposed to be only the low-lod\n   // h -= .01; // in fact, trim it down a bit so march won't stop on it before hitting leaves\n    float pd = p.y - h; // not a true sdf, just a heightfield\n    // tiled randomized leaf texture\n    // but only in areas *beneath* the maze hedge height and above the ground\n    if (true //false //\n        //distance(p,campos) < 5. && // just switch to lod lod with distance\n      &&  h > .03\n      &&  pd < .2 //p.y < h + .2\n     //   && max3(fwidth(p)) < 1e-7 // totally not working how I'd hoped\n       ) {\n        // scale of the hedge leaves\n        float lscale = 1. / 2.; //32.; //4.; //8.; //64.; //\n        float ld = gd(p/lscale, h / lscale)*lscale;\n        ld *= .9; // it's FUBAR HACK\n       // ld = min(ld, pd - h + .33); // fill body of hedge where leaves don't cover enough - borked\n        return min(pd, ld);\n    } else {\n        pd *= .91;\n    }\n    return pd;\n}\n\nvec3 nbispirale(vec3 p, float h)\n{\n    return normalize((vec3(sdf(p + vec3(h,0.,0.)), sdf(p + vec3(0.,h,0.)), sdf(p + vec3(0.,0.,h))) - sdf(p)) / h);\n}\n    \nfloat raymarch(vec3 ro, vec3 rd, int maxsteps)\n{\n    float ret = -1.;\n    float t = 0.0;\n    for (int i = 0; i < maxsteps; ++i) {\n        vec3 p = ro + rd * t;\n        float d = sdf(p);\n        if (d <= 1e-7) {\n          ret = t;\n          break;\n        }\n        t += max(d, .0005);\n    }\n    if (ret < 0. && rd.y < 0.)\n        ret = ro.y / -rd.y; // rescue to plane\n    return ret;\n}\n\nconst vec3 L = normalize(vec3(1.,1.,2.));\n\nfloat shadow(vec3 p)\n{\n    float r = raymarch(p, L, 24);\n    return r > 0.\n        ? .4 : 1.;\n}\n\nvec3 lighting(vec3 d, vec3 n, float r, vec3 p)\n{\n    vec3 cdiff = vec3(.3,.7,.1);\n    if (p.y < .01) cdiff = vec3(.9,.5,.2);\n    float h = p.y; // this color palette is bogus FIXME\n    float nl = dot(L, n);\n    float shadowatten = shadow(p + n * .005 + nl * .03 * L); //1.; //\n    nl = max(0., nl);\n    // TODO ambient occlusion\n    nl *= shadowatten;\n    float diff = mix(nl, 1., .05);  // wtf kind of hax is this\n    vec3 H = normalize(L+d); // blinn-phong hack\n    float spec = nl * pow(max(0., dot(H, n)), 64.); //0.; //\n    vec3 nr = reflect(n, d); //d, n); //\n//    vec3 env = textureLod(Enviro, nr, 0.).rgb;\n    return //env + \n        clamp(cdiff * diff + .6 * spec, 0., 1.); //mix(diff, 2.*spec, .5);\n}\n\nmat3 cameraMatrix(vec3 camFwd)\n{\n    vec3 w = normalize(camFwd);\n    vec3 u = normalize(cross(vec3(0., 1., 0.), w));\n    vec3 v = normalize(cross(w, u));\n    return mat3(u, v, w);\n}\n\nvec3 draw(vec2 q)\n{\n    campos = vec3(sin(vec2(0,.25*tau) + iTime * .01), -5).xzy; // slow fly cam\n    camdir = vec3(cos(vec2(0,.25*tau) + iTime * .01) * .5, -.866).xzy;\n    campos -= camdir * 63.;\n    mat3 m = cameraMatrix(camdir);\n    vec3 rp = campos;\n    vec3 rd = normalize(m * vec3(q, 2.));\n    float r = raymarch(rp, rd, 72);\n    float vl = max(dot(rd, L), 0.);\n    if (!(r >= 0.))\n        return vec3(mix(.5,1.,pow(vl, 4.))) //exp2(-8. * max(0.,1.-vl))))\n       * 1.2*vec3(.85,.9,.95);\n    vec3 phit = rp + rd * r;\n    float nw = .005 * r;\n    vec3 n = nbispirale(phit, nw);\n    return lighting(-rd, n, r, phit);\n}\n\nvoid mainImage(out vec4 c, vec2 p)\n{\n    vec2 r = iResolution.xy;\n    c.rgb = draw((p+p-r)/r.y);\n    c.rgb = pow(c.rgb, vec3(1./2.2)); // to approx srgb gamut\n\tc.a = 1.;\n}\n\n", "image_inputs": [{"id": "4sX3zn", "previewfilepath": "/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsSBRd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsSBzc", "name": "wiggly bar", "author": "ncot_tech", "description": "A wiggly bar", "tags": ["sin"], "likes": 1, "viewed": 65, "date": "1590525018", "time_retrieved": "2024-06-20T20:07:37.673325", "image_code": "vec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat Circle(vec2 uv, vec2 p, float r, float blur)\n{\n    float d = length(uv-p);\n    float c = smoothstep(r, r-blur, d);\n    \n    return c;\n}\n\nfloat Band(vec2 uv, float start, float end, float blur)\n{\n    float wiggle = sin(uv.y*30.+iTime) / 10.;\n    \n    float step1 = smoothstep(start-blur+wiggle, start+blur+wiggle, uv.x);\n    float step2 = smoothstep(end+blur+wiggle, end-blur+wiggle, uv.x);\n    \n    return step1 * step2;\n}\n\nfloat VLine(vec2 uv, float x, float w)\n{\n    float wiggle = sin(uv.y*50.+iTime) / 1.5;\n    if (uv.x >= x+wiggle-w && uv.x <= x+wiggle+w) return 1.;\n    return 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // move origin, fix aspect ratio\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // Set up colour\n    vec3 col = vec3(0.);\n\t// set up mask\n    float mask = 0.;\n    \n    // Create image\n    mask = Band(uv, -.2, .2, .01);\n    //mask = VLine(uv, 0., 0.05);\n    \n    // set colour\n    col = pal( uv.y, vec3(0.7,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.34,0.33,0.67) ) * mask;\n    //col = vec3(1.,1.,1.)* mask;\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsSBzc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsSBzd", "name": "Colorful bubbles", "author": "jarble", "description": "This is similar to my \"Iridescent bubbles\" shader, but the 3D hash function is slightly modified.", "tags": ["raymarching", "hash"], "likes": 0, "viewed": 182, "date": "1590605229", "time_retrieved": "2024-06-20T20:07:38.843133", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n/**\n * Part 6 Challenges:\n * - Make a scene of your own! Try to use the rotation transforms, the CSG primitives,\n *   and the geometric primitives. Remember you can use vector subtraction for translation,\n *   and component-wise vector multiplication for scaling.\n */\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.00001;\n\nvec3 hash33(vec3 p3)\n{\t\n    //this is from https://www.shadertoy.com/view/4djSRW\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += (p3, p3.yxz+10.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n/**\n * Rotation matrix around the Y axis.\n */\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(hash33(sin(p)/10.0))-sin(length(p))/3.33;\n}\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {    \n    //Slowly spin the whole scene\n    samplePoint = samplePoint+vec3(0.0,0.0,iTime);\n    \n    return sphereSDF(samplePoint,1.0);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(8.0, 5.0, 7.0);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = hash33(p/10.0);\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsSBzd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tssBzl", "name": "CMPM163 LAB6", "author": "Amir_Alaj", "description": "Lab 6 is where we learn how to use ShaderToy and display moving cirlces with it.", "tags": ["shaders", "graphics", "lab6"], "likes": 0, "viewed": 40, "date": "1588893052", "time_retrieved": "2024-06-20T20:07:39.079606", "image_code": "float DistLine(vec3 ro, vec3 rd, vec3 p) {\n    // the distance from the point p to the ray line in 3D space\n    return length(cross(p - ro, rd))/length(rd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    //set origin to middle of screen\n    uv -= .5;\n    \n    //sets u axis so that the right aspect ratio is in terms of uv\n\tuv.x *= iResolution.x/iResolution.y;\n    \n    // set the ray origin (camera position) 2 units toward the screen\n    vec3 ro = vec3(0., 0., -2.);\n    \n\t// set the ray direction, subtract ro to get intersection point\n\tvec3 rd = vec3(uv.x, uv.y, 0.) - ro;\n    \n    // per frame static variable\n    float t = iTime;\n    \n    // set point with formula to move in a circle along the xz plane\n    vec3 p = vec3(sin(t), 0, 2. + cos(t));\n    \n    // call the function that calculates distance\n    float d = DistLine(ro, rd, p);\n    \n    //performs smooth Hermite interpolation between 0 and 1\n    d = smoothstep(.1, .09, d);\n    \n    // Output to screen\n    fragColor = vec4(d);\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tssBzl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsSBzV", "name": "lr94/flow", "author": "lucasrumney94", "description": "Simple Geometric pattern generated from a one dimensional signal. ", "tags": ["flow"], "likes": 0, "viewed": 49, "date": "1590391278", "time_retrieved": "2024-06-20T20:07:39.079606", "image_code": "#define PI 3.14159\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy)-.5;\n\tuv.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = vec3(0.);//vec3(1.-fract(iTime/20.)-uv.x*uv.y);\n\n    float signal = max(\n       abs (cos(uv.x*20.*(.5*sin(iTime/2.)+1.)*PI+iTime*4.)+.3),\n       abs (sin(uv.y*20.*(.5*sin(iTime/2.)+1.)*PI-iTime*3.)+.3)\n    );\n    \n    vec3 interestingColor = vec3(\n        0.,\n        signal*.3, \n        signal*.4\n    );\n    \n    col = mix(col, vec3(interestingColor), signal);\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsSBzV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsSfRG", "name": "newton-rhapson Lissajous", "author": "asiermarzo", "description": "A newton-rhapson fractal that solves a Lissajous curves of 3 points. Some color gradients and smoothing are applied.", "tags": ["fractal", "newtonrhapson"], "likes": 4, "viewed": 263, "date": "1590258129", "time_retrieved": "2024-06-20T20:07:39.589433", "image_code": "#define sLenght(a) dot((a),(a))\n\nvec2 cInv(vec2 c){\n\tfloat sl = dot(c,c);\n\treturn vec2(c.x / sl, -c.y / sl);\n}\n\nvec2 cMul(vec2 a, vec2 b){\n\tvec4 t = a.xyxy * b.xyyx;\n\treturn vec2(t.x - t.y, t.z + t.w);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfloat zoom = (sin(iTime/4.0)+1.0) * 8.0 + 1.0;\n    vec2 p = -(zoom/2.0) + zoom * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\t\n\tfloat t = iTime/2.0;\n\t\n\t//setting roots of a third grade poly using a Lissajous curve\n    vec2 root1 = vec2(sin(t + 0.00000000) , sin(2.0 * t + 0.00000000));\n\tvec2 root2 = vec2(sin(t + 2.09439510) , sin(2.0 * t + 2.09439510));\n\tvec2 root3 = vec2(sin(t + 4.18879020) , sin(2.0 * t + 4.18879020));\n\t\n\tconst int maxIters = 16;\n\tfloat tolerance = 1e-8;\n\tvec2 r1,r2,r3;\n\tvec2 prevP = p;\n\tfloat iters = 0.0;\n\t\n\tr1 = p-root1;\n\tr2 = p-root2;\n\tr3 = p-root3;\n\n\tfor(int iterations = 0; iterations < maxIters; iterations++ ){\n\t\tprevP = p;\n\t\t//newton-rhapson method iteration\n\t\tp = p - cInv( cInv(r1) + cInv(r2) + cInv(r3) );\n\t\t\n\t\t//check how near we are from the nearest root\n\t\tr1 = p-root1;\n\t\tr2 = p-root2;\n\t\tr3 = p-root3;\n\t\tif (min(sLenght(r1),min(sLenght(r2),sLenght(r3))) < tolerance ) {break;}\n\t\titers += 1.0;\n\t}\n\tfloat co = iters;\n\t\n\t//the code could be more compact but repeating code makes changing the gradients easier\n\tfloat l1 = length(p-root1);\n\tfloat l2 = length(p-root2);\n\tfloat l3 = length(p-root3);\n\tfloat dist0,dist1;\n\tfloat tol = log(tolerance);\n    if (l1 <= l2 && l1 <= l3){\n\t\tdist0 = log(sLenght(prevP-root1));\n\t\tdist1 = log(sLenght(p-root1));\n\t\tif (dist1 < tol && dist0 > tol) { co += (tol - dist0) / (dist1 - dist0); }\n\t\tco = clamp(co/float(maxIters),0.0,1.0);\n\t\t\n\t\t//gradient for root1\n\t\tfragColor = vec4(\n\t\t\t0.5+0.89*cos(6.2831855*co+0.0),\n\t\t\t0.5+0.48000002*cos(25.132742*co+2.0734513),\n\t\t\t0.5+0.38*cos(50.265484*co+4.1469026),\n\t\t\t1.0);\n\t\t\t\n\t}else if (l2 <= l1 && l2 <= l3){\n\t\tdist0 = log(sLenght(prevP-root2));\n\t\tdist1 = log(sLenght(p-root2));\n\t\tif (dist1 < tol && dist0 > tol) { co += (tol - dist0) / (dist1 - dist0); }\n\t\tco = clamp(co/float(maxIters),0.0,1.0);\n\t\t\n\t\t//gradient for root2 \n\t\tfragColor = vec4(\n\t\t\t0.5+0.6*cos(2.0106194*co+-1.5079645),\n\t\t\t0.5+1.0*cos(4.5867257*co+2.576106),\n\t\t\t0.5+0.82*cos(3.015929*co+2.3247786),\n\t\t\t1.0);\n\t\t\t\n\t}else if (l3 <= l2 && l3 <= l1){\n\t\tdist0 = log(sLenght(prevP-root3));\n\t\tdist1 = log(sLenght(p-root3));\n\t\tif (dist1 < tol && dist0 > tol) { co += (tol - dist0) / (dist1 - dist0); }\n\t\tco = clamp(co/float(maxIters),0.0,1.0);\n\t\t\n\t\t//gradient for root3 \n\t\tfragColor = vec4( .5+.5*cos(6.2831*co+0.0),\n                         .5+.5*cos(6.2831*co+0.4),\n                         .5+.5*cos(6.2831*co+0.7),\n                         1.0 );\n\t\t\t\t\t\t \n\t}else{\n\t\tfragColor = vec4(0.0 , 0.0, 0.0, 1.0 );\n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsSfRG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsSfRK", "name": "WallsToBuild", "author": "z0rg", "description": "walls to build mall grab remix\nA sunday night inspiration, while listening this cool song.", "tags": ["2d", "abstract", "worm", "vidjing"], "likes": 1, "viewed": 153, "date": "1590361932", "time_retrieved": "2024-06-20T20:07:40.213022", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nmat2 r2d(float a) {float cosa = cos(a);float sina = sin(a);return mat2(cosa, sina, -sina, cosa);}\n\nfloat lenny(vec2 p)\n{\n    return abs(p.x)+abs(p.y);\n}\n\nfloat sat(float a)\n{\n    return clamp(a,0.,1.);\n}\n\nfloat sdCir(vec2 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat cir(vec2 p, float r)\n{\n    float sharp = abs(p.y)*400.;\n    \n    return sat(sat(-sdCir(p,r) / r) * sharp);\n}\n\nfloat loz(vec2 p, float r)\n{\n\tfloat sharp = abs(p.y)*400.;\n    \n    return sat(sat(-(lenny(p)-r) / r) * sharp);\n}\n\nvec4 cirRdr(vec2 p, float sz, float borderTh)\n{\n    float mixF = sin(iTime * 0.7+p.y*5.)*.6+.4;\n    float outerCir = mix(cir(p, sz), loz(p, sz), mixF);\n    float innerCir = mix(cir(p, sz - borderTh), loz(p, sz - borderTh), mixF);\n    \n    float mask = outerCir;\n    vec3 col = mix(vec3(abs(sin(p.y+iTime))*3., sz*10.,.5)*.35,vec3(0.), sat(innerCir));\n    return vec4(col*sat(mask), sat(mask));\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 color = abs(sin(iTime*0.1))*2.*vec3(0.05,0.01,0.17)*sat(1.-length(uv))+vec3(1.)*pow(sat(1.-length(uv)),3.);\n    \n    \n    float sharp = 20.;\n    float szFlare = 1.;\n    color += .1*vec3(.5,.4,.2) * sat(sat(-(lenny(uv) - szFlare) / szFlare)*sharp) * (.5+abs(sin(iTime+uv.x+uv.y)));\n    \n    int i = 0;\n    int horizSteps = 5;\n    while (i < horizSteps)\n    {\n        float fi = float(i)-(float(horizSteps)*.5);\n        int j = 0;\n        int vertSteps = 50;\n        while (j < vertSteps)\n        {\n            float fj = float(j)-(float(vertSteps)*.5);\n            vec2 p = uv - vec2(fi*.5+sin(0.1*fj+iTime)*0.05, fj*.05*sin(-iTime*0.2+fi) + 0.03*sin(iTime + fj*.5));\n            float radSnd = .05*texelFetch(iChannel0, ivec2(int(abs(fj)*1.), 0), 0).x;\n            vec4 cirColMask = cirRdr(p, radSnd+0.15+0.005*sin(2.0*fj-iTime), 0.003+0.005*fj/float(vertSteps));\n    \t\tcolor = mix(color, cirColMask.xyz* 2.*sat(pow(sat(5.*(abs(fi)+2.*sin(iTime+fi*10.))/float(vertSteps)), 1.2)+.01), cirColMask.w);\n            ++j;\n        }\n        ++i;\n    }\n    \n\tfloat szFlarePost = 1.5;\n    color += 5.*vec3(.5,.4,.2)*(mod(iTime, 0.5)*.2+0.3)*pow(sat(sat((szFlarePost-lenny(uv*vec2(1.,3.)*.3)) / szFlarePost)),10.);\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xx;\n    uv -= vec2(.5)*iResolution.xy/iResolution.xx;\n    uv *= 2.+2.*(sin(iTime*.25)*.5+.5);\n    //uv = uv*r2d(2.*length(uv)+.2*sin(iTime-length(uv)));\n    vec3 col = rdr(uv);\n    col *= vec3(.0)+1.*pow(sat(iTime*.5), 5.);\n\tcol = pow(col, vec3(1./2.2));\n    col = vec3(sat(col.x), sat(col.y), sat(col.z));\n    fragColor = vec4(col.zyx,1.0);\n}", "image_inputs": [{"id": "llB3zV", "previewfilepath": "https://soundcloud.com/vapenation/kenny-needs-to-sleep", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/vapenation/kenny-needs-to-sleep", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsSfRK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsSfWK", "name": "Animated Two-Tiled Truchet", "author": "Shane", "description": "An animated two-tiled Truchet arrangement.", "tags": ["abstract", "animation", "truchet"], "likes": 31, "viewed": 555, "date": "1590816024", "time_retrieved": "2024-06-20T20:07:41.685712", "image_code": "/*\n\n    Animated Two-Tiled Truchet\n    --------------------------\n\n\n\tAn animated two-tiled Truchet arrangement -- to accompany the texture mapped\n\tone -- for anyone only interested in the animated portion. I tried to give \n\tit a kind of geometric art deco feel.\n\n    For anyone wanting to make one of these, a few simple observations should help: \n    \n    Animating square grid Truchet arc tiles on their own requires the flow directions \n    to be reversed on alternate checkered tiles. Furthermore, in order to work \n    straight line tiles in with them, both horizontal and vertical lines must span \n    two grid cells. In addition, adjacent horizontal line rows must flow in opposite \n    directions. The same applies to adjacent vertical line columns.\n\n\n    Other examples:\n\n\t// The texture mapped version of this.\n\tAnimated Textured Truchet - Shane\n\thttps://www.shadertoy.com/view/3dSBzt\n\n\t// A much, much simpler version containing just the arc tiles.\n\tMinimal Animated Truchet - Shane\n\thttps://www.shadertoy.com/view/XtfyDf\n\n*/\n\n\n// Displays each separate grid cell, which allows you to more easily discern\n// individual tiles.\n//#define SHOW_GRID\n\n// Thinner Truchet rails.\n//#define THINNER\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n\n// Global Truchet constants. The angle is either the angle of the\n// Truchet semi-circles, which have been normalized to the zero to one\n// range, or the value of the straight line position on the straight\n// edge tile arrangement, which also ranges from zero to one.\nvec2 ang;\n\n// The Truchet distance field. A lot of this is standard stuff. The additional\n// code here involved texture mapping. That was just a case of \nvec2 df(vec2 p){\n    \n    // Two by two cell random value.\n    vec2 ip2 = floor(p/2.);\n    float rnd2 = hash21(ip2 + .43);  \n    \n    // Cell ID and local coordinates.\n    vec2 ip = floor(p);\n    p -= ip + .5;\n    \n    // Random 1x1 numbers, for flipping and rotating.\n    float rnd = hash21(ip);\n    float rnd3 = hash21(ip + .57);\n    \n    // The distance field container. Each cell contains either two lines\n    // or two arcs, so this will hold each one.\n    vec2 d = vec2(1e5);\n  \n    \n    // When animating arc Truchet arrangements only, the trick is to \n    // reverse the animation flow on alternate checkered cells... \n    // I have a basic animated version on here somewhere, if you\n    // require more information.\n    //\n    // Anyway, working in the extra overlapping straight line tiles \n    // complicates things. However, after a while, you'll realise that \n    // either the horizontal or vertical line must span two cells for \n    // the animation to work, so that's what the following two-by-two \n    // checkered \"mod\" decision is all about.\n    //\n    // Every 2 by 2 alternate checker, put in the overlapped straight \n    // tiles. Otherwise, calculate the distance field for the double \n    // arc one.\n    //\n    if(mod(ip2.x + ip2.y, 2.)<.5){ // Alternate checkers.\n    //if(rnd2<.5){ // Random 2x2 coverings.\n    //if((mod(ip2.x, 2.)<.5 || mod(ip2.y, 2.)<.5) && rnd2<.5){ // Mixing.\n        \n        \n        \n        // Overlapping straight tile.\n\n        d = abs(p);\n        ang = p.yx;\n\n        // Reversing just the X-directions on every second column. It's \n        // common sense... but it still took me a while to figure out.. :)\n        if(mod(ip.x + 1., 2.)<.5){\n            ang.x *= -1.;\n\n        }\n        // Reversing just the Y-directions on every second row.\n        if(mod(ip.y + 1., 2.)>.5){\n            ang.y *= -1.;\n        }  \n\n\n        // Randomly change the rendering order, which means\n        // switching everything else. I always forget this, then spend\n        // ages trying to figure out why things aren't working. :)\n        if(rnd3<.5) {\n            d = d.yx;\n            ang = ang.yx;\n        }\n\n        // This makes things line up.\n        ang += .5;\n        \n        // The straight lines are about 1.5 times the length of the\n        // quarter arcs, so multiply the straight line pattern \n        // frequency by 3 and the arc frequency by 2.\n        ang *= 3.;\n\n    }\n    else {\n        \n        \n        // Double arc tile.\n        \n        // Randomly rotate.\n        if(rnd<.5) {\n        \tp = p.yx*vec2(1, -1);\n    \t}\n        \n        // Individual arc distances. One in each corner.\n        d.x = length(p - .5) - .5;\n    \td.y = length(p + .5) - .5;\n        d = abs(d);\n        \n        // The angles of the pixels subtended to the circle centers of each \n        // arc. Standard polar coordinate stuff... In a hurry, I threw some\n        // negative signs in and everything lined up, but you could rework \n        // everything to work without them.\n        ang.x = -atan(p.y - .5, p.x - .5);\n        ang.y = -atan(p.y + .5, p.x + .5);\n        \n        \n        // This comes up all the time when animating square Truchets.\n        // It's necessary to reverse the animation flow on alternate\n        // checker squares.\n        if(mod(ip.x + ip.y, 2.)<.5) ang *= -1.;\n\n        \n        // Reverse the flow on all randomly rotated tiles.\n        if(rnd<.5) ang *= -1.;\n        \n        // Randomly change the rendering order, which means\n        // switching everything else. I always forget this, then spend\n        // ages trying to figure out why things aren't working. :)\n        if(rnd3<.5) {\n             d = d.yx;\n             ang = ang.yx;\n         }\n        \n        // Normalizing the angle. Four arcs make up a circle, which\n        // means each needs to run from zero to one four times over\n        // for the texture to wrap... I'm pretty sure that's right...\n        // but I've been wrong before. :)\n        ang *= 4./6.2831853;\n        \n        // The straight lines are about 1.5 times the length of the\n        // quarter arcs, so multiply the straight line pattern \n        // frequency by 3 and the arc frequency by 2.\n        ang *= 2.;\n        \n        \n        \n    }\n    \n    // Adding some time-based movement... or animation, if you wish to \n    // call it that. :D By the way, if you take out the time component,\n    // I think the \"fract\" call still needs to be there.\n    ang = fract(ang + iTime/4.);\n    \n    \n    return d;\n    \n}\n\n// The square grid boundaries.\nfloat gridField(vec2 p){\n    \n    vec2 ip = floor(p);\n    p -= ip + .5;\n    \n    p = abs(p);\n    return abs(max(p.x, p.y) - .5) - .001;\n\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Aspect correct screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // Scaling and translation.\n    const float gSc = 7.;\n    // Depending on perspective; Moving the oject toward the bottom left, \n    // or the camera in the north east (top right) direction. \n    vec2 p = uv*gSc - vec2(-1, -.5)*iTime/4.;\n    \n\n    // Smoothing factor, based on scale.\n    float sf = 2./iResolution.y*gSc;\n   \n    // Thinner rails.\n    float lSc = 6.;\n    #ifdef THINNER\n    lSc = 8.;\n    #endif\n    \n    // Line width.\n    float lw = 1./lSc/gSc;\n    \n    // Calling the Truchet pattern distance field and giving it a bit of width.\n    // Each cell contains two overlapping arcs or line objects. \n    vec2 d = df(p) - 2.5/lSc;\n    \n    // Background color. Keeping things simple.\n    vec3 col = vec3(1., .9, .8);\n    \n    #ifdef THINNER\n    // Line pattern. Used for thinner Truchet widths.\n    float pat = abs(fract(p.x*lSc + .5*0.)  - .5) - lw*lSc/2.;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, pat)));\n    #endif\n   \n    // Rendering the two Truchet layers. A lot of this was made up as I\n    // went along, so you could ignore the details.\n    //\n    for(int i = 0; i<2; i++){\n         \n        // The tile layer distance... offset by a small amount or whatever\n        // reason I had at the time. :)\n        float di = d[i] - lw/4.;\n        \n        // The animated part: This is a standard cheap way to do it, but \n        // you could also plug \"ang[i]\" into a function that renders\n        // shapes, etc.\n        float tracks = clamp(sin(ang[i]*6.2831 + iTime*6.)*4., 0., 1.);\n       \n         \n        \n        // Set to 1 for normal edge thickness.\n        float gap = 1. + lw;// + sf/2.;//.25/lSc;\n        // Set to \"di + lw\" for normal edge thickness.\n        \n        // Fake ambient occlusion and dark edge.\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*6., di))*.35);\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, di));\n        \n        // Outer layers.\n        col = mix(col, vec3(1., .9, .8), 1. - smoothstep(0., sf, di + lw*2.)); \n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, di + gap/lSc));\n        // Middle.\n        col = mix(col, vec3(1), 1. - smoothstep(0., sf, di + gap/lSc + lw));\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, di + 2.*gap/lSc));\n        // The central tracks.\n        col = mix(col, vec3(1)*tracks, 1. - smoothstep(0., sf, di + 2.*gap/lSc + lw));\n         \n\n    }\n    \n    // Displaying the grid cells.\n    #ifdef SHOW_GRID\n    float grid = gridField(p);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, grid)));\n    #endif\n\n    \n    // Output to screen\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsSfWK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsSfWy", "name": "Emerald Spheres", "author": "jarble", "description": "It's a world of iridescent shiny spherical objects.", "tags": ["raymarching"], "likes": 0, "viewed": 195, "date": "1590707367", "time_retrieved": "2024-06-20T20:07:42.758664", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n/**\n * Part 6 Challenges:\n * - Make a scene of your own! Try to use the rotation transforms, the CSG primitives,\n *   and the geometric primitives. Remember you can use vector subtraction for translation,\n *   and component-wise vector multiplication for scaling.\n */\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.0001;\n\nvec3 hash33(vec3 p3)\n{\tp3 *= 100.0;\n    return fract((p3+1.0+sin(p3.x+p3.y+p3.z))/p3);\n}\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {    \n    return length(hash33(sin(samplePoint)/10.0))-sin(length(samplePoint))/3.33;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(8.0+iTime*10.0, 5.0, 7.0*iTime);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = hash33(p/200.0);\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsSfWy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tssfzB", "name": "circle inversion", "author": "matthen", "description": "minimal circle inversion shader", "tags": ["circles", "inversion", "tangent"], "likes": 7, "viewed": 145, "date": "1588560869", "time_retrieved": "2024-06-20T20:07:42.758664", "image_code": "vec3 gradient(in float r) {\t    \n    vec3 rainbow = 0.5 + 0.5 * cos((0.2 * r + vec3(0.2, 0.45, 0.8)*6.));   \n    return rainbow;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    uv *= 2.;\n    \n    \n    float r = length(uv);\n    uv /= (r * r);\n    \n    float t = 0.05 * iTime;\n    uv.x -= 15. * sin(t);\n    uv.y -= 10. * cos(t);\n    \n    float theta = 1.2 * t;\n    uv = vec2(    \n        uv.x * cos(theta) - uv.y * sin(theta),\n        uv.y * cos(theta) + uv.x * sin(theta)\n    );\n    \n        \n    \n    float thickness = 0.02 / r;\n    \n    \n\tuv.y +=  2. * (0.5 + 0.5 * cos(10. * (t - 0.2 * floor(uv.x)))) * mod(floor(uv.x), 2.);\n  \n        \n    vec3 col = vec3(1. - smoothstep(\n        0., thickness,\n        length(fract(uv) - 0.5) - 0.5));\n    col *= gradient(floor(uv.x) + 3.2 * floor(uv.y));\n    \n    fragColor = vec4(vec3(col), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tssfzB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tssfzl", "name": "Dodecahedralis I", "author": "sl2c", "description": "Pattern based on the hyperbolic dodecahedron with rgiht-angled edges.  Treating six of them as mirrors produces a symmetry group isomorphic to one of the hyperbolic plane, preserving the yellow fractal curve.", "tags": ["fractal", "circles", "hyperbolic"], "likes": 21, "viewed": 161, "date": "1588959821", "time_retrieved": "2024-06-20T20:07:43.249516", "image_code": "// Copyright 2020 Google LLC\n// SPDX-License-Identifier: Apache-2.0\n// NOT an official Google project; see Google Open Source guidelines for more info on copyright transfer\n// written by William Cadegan-Schlieper \n\nfloat tau = 6.283185307179586;\n\nbool flip(inout vec2 z, inout float ds, in vec2 c, in float r, inout float t) {\n    z -= c;\n    bool res = (dot(z,z) < r*r) ^^ (r < 0.0);\n    if (res) {\n        ds *= r * r / dot(z,z);\n        z *= r * r / dot(z,z);\n    }\n    t = min(t, (dot(z,z)-r*r)/(2.0 * r * ds));\n    z += c;\n    return res;\n}\n\nbool inside(in vec2 z, in float ds, in vec2 c, in float r, inout float t) {\n    vec2 p = z - c;\n    float res = (dot(p,p)-r*r) / (2.0 * abs(r) * ds);\n    t = min(t, abs(res));\n    return res < 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 z = 2.0 * (fragCoord - iResolution.xy * 0.5)/iResolution.y;\n    float ds = 1.0 / iResolution.y;\n    \n    vec2[12] c; float[12] r;\n    float r1 = pow(1.5 + 0.5 * sqrt(5.0) - sqrt(1.5 * sqrt(5.0) + 2.5), 0.5);\n    r[0] = r1; c[0] = vec2(0.0);\n    float r2 = r1 * sqrt(sqrt(5.0));\n    float x2 = sqrt(r1*r1+r2*r2);\n    float r3 = r2 / ( x2 * x2 - r2 * r2);\n    float x3 = -x2 / ( x2 * x2 - r2 * r2);\n    for (int i=0; i<5; i++) {\n        float theta = tau * 0.2 * float(i);\n        vec2 eit = vec2(cos(theta), sin(theta));\n        r[i+1] = r2;\n        c[i+1] = x2 * eit;\n        r[i+6] = r3;\n        c[i+6] = x3 * eit;\n    }\n    float r4 = -1.0 / r1;\n    r[11] = r4; c[11] = vec2(0.0);\n    \n    float period = -4.0 * log(r1);\n    float d = mod(iTime * 0.2, period) - period * 0.5;\n    z *= exp(-d); ds *= exp(-d);\n    \n    bool fl = false;\n    float yellow = 0.0;\n    float t = 1.0;\n    for (int i=0; i<7; i++) {\n        fl = fl ^^ flip(z, ds, c[0], r[0], t);\n        fl = fl ^^ flip(z, ds, c[2], r[2], t);\n        fl = fl ^^ flip(z, ds, c[5], r[5], t);\n        fl = fl ^^ flip(z, ds, c[7], r[7], t);\n        fl = fl ^^ flip(z, ds, c[10], r[10], t);\n        fl = fl ^^ flip(z, ds, c[11], r[11], t);\n        yellow = max(yellow, 3.0 * ds / (-r4 - r1));\n        if (yellow > 1.0) {\n            fragColor = vec4(1.0,1.0,0.0,0.0);\n            return;\n        }\n    }\n    \n    fl = fl ^^ inside(z, ds, c[1], r[1], t);\n    fl = fl ^^ inside(z, ds, c[3], r[3], t);\n    fl = fl ^^ inside(z, ds, c[4], r[4], t);\n    fl = fl ^^ inside(z, ds, c[6], r[6], t);\n    fl = fl ^^ inside(z, ds, c[8], r[8], t);\n    fl = fl ^^ inside(z, ds, c[9], r[9], t);\n    t = (1.0 - t) * 0.5;\n    if (fl) {\n        t = 1.0 - t;\n    }\n    vec3 col = vec3(t);\n    yellow = yellow * yellow;\n    col = (1.0 - yellow) * col + yellow * vec3(1.0, 1.0, 0.0);\n    fragColor = vec4(col,1.0);\n    fragColor = pow(fragColor, vec4(1.0/2.2));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "apache-2.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tssfzl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsSfzm", "name": "Weird 3d'ish mandel", "author": "Tsarpf", "description": "A weird 3d looking mandelbrot that I stumbled on accidentally.\n\nIncrease speed (a little) to... go faster.", "tags": ["mandelbrot"], "likes": 1, "viewed": 49, "date": "1589723123", "time_retrieved": "2024-06-20T20:07:43.249516", "image_code": "float mandelbro(vec2 coord, float iters, float time) {\n    float maxVal = 1.0f;\n    vec2 currentVals = coord;\n    float i = 0.;\n    for(; i < iters; i++)\n    {\n        float x = currentVals.x * currentVals.x - currentVals.y * currentVals.y + coord.x;\n        float y = 2.f * currentVals.x * currentVals.y + coord.y;\n        currentVals = vec2(x,y);\n            \n        if(x > maxVal || y > maxVal) {\n            break;\n        }\n    }\n    return float(i) - log2(log2(dot(currentVals,currentVals))) * iters;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float speed = 20.1;\n    \n    float zoomLocation = 1.5 + 0.0001*iTime;\n    float timeVary = ((1.f/iTime)*(1.f/iTime)*0.01f);\n    float loopPos = -3.5f;\n    float loopVal = pow(2.5f, loopPos - speed * cos(iTime/1.0f)) / 60.f;\n    vec2 looper = vec2(loopVal, loopVal);\n    vec2 uv = (vec2(1., .5) - vec2(fragCoord.x, fragCoord.y)/iResolution.xy) * looper - vec2(zoomLocation, 0);\n    \n    float iters = 512.0;\n    float iterF = float(iters);\n    float bailOut = float(mandelbro(uv, iters, iTime));\n    \n    float color = bailOut / iterF;\n    vec3 col = vec3(.5) + .5*sin(bailOut / iterF * 0.5 + vec3(0., 0.5, 1.));\n    \n    if(bailOut < iterF/2.f) {\n        col = vec3(col.xy, color);\n    }\n    if(bailOut < iterF*(7.f/8.f)) {\n        col = vec3(col.x, col.y, color);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsSfzm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsSfzw", "name": "yorha_two", "author": "YoRHa", "description": "~~~~~~", "tags": ["trigonometry"], "likes": 1, "viewed": 77, "date": "1589703611", "time_retrieved": "2024-06-20T20:07:43.249516", "image_code": "// 2pi = 6.28318;\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n// background\nvec3 bckg ( in float x, in float y )\n{\n    return pal( x, vec3(0.8,0.5,0.4),vec3(0.2,0.4,0.2),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25) );\n}\n\n// amplitude, period, position, width, x, y, col \nvec3 sine( in float amp, in float prd, in float psn, in float wid, in float x, in float y, in vec3 col )\n{\n    // exact position of the sine wave\n    float spos = sin(x* prd + iTime) * amp + psn;\n    \n    // render the area above the sine wave as white\n    if(abs(spos - y) <= wid)\n        return vec3(1.0);\n    else\n    \treturn col;\n}\n\n// amplitude, period, position, width, x, y, col \nvec3 csine( in float amp, in float prd, in float psn, in float wid, in float x, in float y, in vec3 col )\n{\n    // exact position of the sine wave\n    float spos = cos(x* prd + iTime) * amp + psn;\n    \n    // render the area above the sine wave as white\n    if(abs(spos - y) <= wid)\n        return vec3(0.0);\n    else\n    \treturn col;\n}\n\n// amplitude, period, position, width, x, y, col \nvec3 tang( in float amp, in float prd, in float psn, in float wid, in float x, in float y, in vec3 col )\n{\n    // exact position of the sine wave\n    float spos = tan(x* prd + iTime) * amp + psn;\n    \n    // render the area above the sine wave as white\n    if(abs(spos - y) <= wid)\n        return vec3(0.0);\n    else\n    \treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = fragCoord/iResolution.xy;\n\n    vec3 col = pal( p.x, vec3(0.8,0.5,0.4),vec3(0.2,0.4,0.2),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25) );\n    \n    for(float i = 0.1; i <= 1.0; i += 0.1)\n        col = sine(i*0.5, i*10.0, 0.5, i*0.015, p.x, p.y, col);\n    \n    \n    /*for(float i = 0.1; i <= 1.0; i += 0.1)\n        col = csine(i*0.5, i*10.0, 0.5, i*0.015, p.x, p.y, col);*/\n    \n    for(float i = 0.1; i <= 1.0; i += 0.1)\n        col = tang(i*0.5, i*10.0, 0.5, i*0.015, p.x, p.y, col);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsSfzw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsXBzs", "name": "Cubeworld", "author": "mla", "description": "A World consisting of a single cube. Looking or moving out through the cube walls just comes back to the cube through a different wall. The grey sphere is you.", "tags": ["manifold", "cubeworld"], "likes": 7, "viewed": 278, "date": "1588868175", "time_retrieved": "2024-06-20T20:07:44.201022", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Cubeworld\n// Matthew Arcus, mla, 2020\n//\n// The entire world consists of a single cube, each wall of the cube is just a\n// passage back into the cube, through a different wall.\n//\n// Mouse to look around. Haven't worked out the details of doing lighting yet,\n// so just uses fogging to indicate distance.\n//\n// Came out of thinking about tmst's excellent \"Non-Euclidean World\":\n// https://www.shadertoy.com/view/WsXcWn\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.1415927;\nfloat AA = 2.0;\nfloat maxdist = 15.0;\nint maxiterations = 30;\n\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\nfloat stepsize(vec3 p, vec3 r) {\n  // Want least k such that p + kr has coordinate 1 in some dimension\n  // eg. p.x+kr.x = 1 => k = (1-p.x)/r.x\n  // eg. p.x+kr.x = 0 => k = -p.x/r.x\n  // Want k positive, so assuming p.x is 0 < p.x < 1, depends on r.\n  float k = 1e8;\n  if (r.x > 0.0) k = (1.0-p.x)/r.x;\n  else if (r.x < 0.0) k = min(k,-p.x/r.x);\n  if (r.y > 0.0) k = min(k,(1.0-p.y)/r.y);\n  else if (r.y < 0.0) k = min(k,-p.y/r.y);\n  if (r.z > 0.0) k = min(k,(1.0-p.z)/r.z);\n  else if (r.z < 0.0) k = min(k,-p.z/r.z);\n  return k; // What if we cross 2 boundaries?\n}\n\nint gethitside(vec3 p) {\n  if (p.x > 1.0) return 0;\n  if (p.x < 0.0) return 1;\n  if (p.y > 1.0) return 2;\n  if (p.y < 0.0) return 3;\n  if (p.z > 1.0) return 4;\n  if (p.z < 0.0) return 5;\n  return -1;\n}\n\nvoid nextdir(int hitside, inout vec3 r) {\n  if (hitside == 0) { r.yz = vec2(r.z,-r.y); r.xz = r.zx; } // Reflection in x=y\n  if (hitside == 1) { r.yz = vec2(r.z,-r.y); r.xz = vec2(-r.z,r.x); } // Rotation by 90 deg\n  if (hitside == 4) { r.xz = vec2(r.z,-r.x); r.yz = vec2(-r.z,r.y); } // Opposite rotation by 90 deg\n  if (hitside == 5) { r.xz = r.zx; r.yz = vec2(-r.z,r.y); } // Reflection in x=y\n}\n\nvoid nextpos(int hitside, inout vec3 p) {\n  if (hitside == 0) p.x -= 1.0;\n  if (hitside == 1) p.x += 1.0;\n  if (hitside == 2) p.y -= 1.0;\n  if (hitside == 3) p.y += 1.0;\n  if (hitside == 4) p.z -= 1.0;\n  if (hitside == 5) p.z += 1.0;\n  if (hitside == 0) { p.yz = vec2(p.z,1.0-p.y); p.xz = p.zx; } // Reflection in x=y\n  if (hitside == 1) { p.yz = vec2(p.z,1.0-p.y); p.xz = vec2(1.0-p.z,p.x); } // Rotation by 90 deg\n  if (hitside == 4) { p.xz = vec2(p.z,1.0-p.x); p.yz = vec2(1.0-p.z,p.y); } // Opposite rotation by 90 deg\n  if (hitside == 5) { p.xz = p.zx; p.yz = vec2(1.0-p.z,p.y); } // Reflection in x=y\n}\n\nbool traceray(inout vec3 p, inout vec3 r, out vec3 n, out int type, out float totaldist) {\n  totaldist = 0.0;\n  vec3 p0 = p;\n  for (int i = 0; i < maxiterations; i++) {\n    if (i > 0) {\n      // find intersection with sphere at p0\n      vec3 q = p-p0;\n      //(q+kr).(q+kr) = r2\n      float A = dot(r,r);\n      float B = dot(q,r);\n      float r = 0.05;\n      float r2 = r*r;\n      float C = dot(q,q)-r2;\n      float D = B*B-A*C;\n      if (D >= 0.0) {\n        float t = (-B-sqrt(D))/A;\n        totaldist += t;\n        n = q+t*r;\n        type = 6;\n        return true;\n      }\n    }\n    float eps = 1e-3;\n    float k = stepsize(p,r)+eps;\n    p += k*r;\n    totaldist += k;\n    if (totaldist > maxdist) return false;\n    // determine the hit side\n    int hitside = gethitside(p);\n    type = hitside;\n    vec3 border = min(p,1.0-p);\n    // Have we hit the wall frames?\n    if (hitside/2 == 0 && min(border.y,border.z) < 0.05) { n = vec3(1,0,0); return true; }\n    if (hitside/2 == 1 && min(border.z,border.x) < 0.05) { n = vec3(0,1,0); return true; }\n    if (hitside/2 == 2 && min(border.x,border.y) < 0.05) { n = vec3(0,0,1); return true; }\n    // Advance p and r\n    nextpos(hitside,p);\n    nextdir(hitside,r);\n  }\n  return false;\n}\n\nvoid moveforward(inout vec3 p, inout vec3 r, vec3 dir, float t) {\n  for (int i = 0; i < 50; i++) {\n    float k = stepsize(p,dir) ;\n    float eps = 1e-3;\n    if (t <= k) break;\n    k += eps;\n    p += k*dir;\n    t -= k;\n    int hitside = gethitside(p);\n    nextpos(hitside,p);\n    nextdir(hitside,dir);\n    nextdir(hitside,r);\n  }\n  p += t*dir;\n}\n\nvec3 getcolor(int type) {\n  if (type == 0) return vec3(1,0,0);\n  if (type == 1) return vec3(0,1,0);\n  if (type == 2) return vec3(0,0,1);\n  if (type == 3) return vec3(1,1,0);\n  if (type == 4) return vec3(1,0,1);\n  if (type == 5) return vec3(0,1,1);\n  return vec3(0.2);\n}\n\nvec3 raycolor(vec3 p, vec3 r) {\n    int type; vec3 n; float totaldist;\n    vec3 bgcol = vec3(1,1,0.5);\n    //vec3 bgcol = vec3(1);\n    if (!traceray(p,r,n,type,totaldist)) return bgcol;\n    vec3 basecolor = getcolor(type);\n    vec3 color = basecolor;\n    color *= 0.5;\n    color = mix(color,bgcol,totaldist/maxdist);\n    return color;\n}\n\nvec2 rotate(vec2 p, float t) {\n  return mat2(cos(t),sin(t),-sin(t),cos(t))*p;\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = -(2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = -(2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  if (false) {\n    p.zx = rotate(p.zx,iTime * 0.2);\n    p.xy = rotate(p.xy,iTime * 0.125);\n  }\n  return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec3 col = vec3(0);\n  for (float i = 0.0; i < AA; i++) {\n    for (float j = 0.0; j < AA; j++) {\n      vec2 uv = (2.0*(fragCoord+vec2(i,j)/AA)-iResolution.xy)/iResolution.y;\n      vec3 r = vec3(uv,2);\n      vec3 p = vec3(0.5);\n      r = transform(r);\n      r = normalize(r); // Normalize after transform\n      moveforward(p,r,vec3(0,0,1),mod(0.2*iTime,4.0));\n      vec3 c = raycolor(p,r);\n      col += c;\n    }\n  }\n  col /= float(AA*AA);\n  col = pow(col,vec3(0.4545));\n  if (alert) col = vec3(1,0,0);\n  fragColor = vec4(col,1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsXBzs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "tsXfWS", "name": "Dodecahedralis II", "author": "sl2c", "description": "A hyperbolic 3-manifold sliced along a horosphere, based on [url=http://archive.bridgesmathart.org/2018/bridges2018-531.html]this paper by Vladimir Bulatov[/url].  Four-coloring the right-angled dodecahedron gives a blueprint for joining 16 dodecahedra.", "tags": ["circles", "tiling", "hyperbolic", "horosphere"], "likes": 20, "viewed": 172, "date": "1589213145", "time_retrieved": "2024-06-20T20:07:44.643705", "image_code": "// Copyright 2020 Google LLC\n// SPDX-License-Identifier: Apache-2.0\n// NOT an official Google project; see Google Open Source guidelines for more info on copyright transfer\n// written by William Cadegan-Schlieper \n\nfloat tau = 6.283185307179586;\n\nbool flip(inout vec3 z, inout float ds, in vec2 c, in float r, inout float t) {\n    z -= vec3(c,0.0);\n    bool res = (dot(z,z) < r*r) ^^ (r < 0.0);\n    if (res) {\n        ds *= r * r / dot(z,z);\n        z *= r * r / dot(z,z);\n    }\n    t = min(t, (dot(z,z)-r*r)/(2.0 * r * ds));\n    z += vec3(c,0.0);\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3[4] colorizers = vec3[](\n        vec3(0.25,0.0,0.0),\n        vec3(0.0,0.3,0.0),\n        vec3(-0.05,-0.02,0.4),\n        vec3(-0.15)\n    );\n    int[12] m = int[](2,0,1,3,0,1,2,3,2,3,0,1);\n    \n    vec2 z = 2.0 * (fragCoord - iResolution.xy * 0.5)/iResolution.y;\n    float ds = 1.0 / iResolution.y;\n    z *= 9.0; ds *= 9.0;\n    vec3 zh = vec3(z, 1.0);\n    \n    vec2[12] c; float[12] r;\n    float r1 = pow(1.5 + 0.5 * sqrt(5.0) - sqrt(1.5 * sqrt(5.0) + 2.5), 0.5);\n    r[0] = r1; c[0] = vec2(0.0);\n    float r2 = r1 * sqrt(sqrt(5.0));\n    float x2 = sqrt(r1*r1+r2*r2);\n    float r3 = r2 / ( x2 * x2 - r2 * r2);\n    float x3 = -x2 / ( x2 * x2 - r2 * r2);\n    for (int i=0; i<5; i++) {\n        float theta = tau * 0.2 * float(i);\n        vec2 eit = vec2(cos(theta), sin(theta));\n        r[i+1] = r2;\n        c[i+1] = x2 * eit;\n        r[i+6] = r3;\n        c[i+6] = x3 * eit;\n    }\n    float r4 = -1.0 / r1;\n    r[11] = r4; c[11] = vec2(0.0);\n    \n    \n    float period = -8.0 * log(r1);\n    float d = mod(iTime * 0.2, period) - period * 0.5;\n    zh *= exp(-d); ds *= exp(-d);\n\t\n    bool[4] flips=bool[](false,false,false,false);\n    float[4] ts=float[](1.0,1.0,1.0,1.0);\n    for (int i=0; i<6; i++) {\n        for (int j=0; j<12; j++) {\n            flips[m[j]] = flips[m[j]] ^^ flip(zh, ds, c[j], r[j], ts[m[j]]);\n        }\n    }\n    vec3 col = vec3(0.5);\n    for (int i=0; i<4; i++) {\n        if (flips[i]) {\n            ts[i] = -ts[i];\n        }\n        col += colorizers[i] * ts[i];\n    }\n    fragColor = vec4(col,1.0);\n    fragColor = pow(fragColor, vec4(1.0/2.2));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "apache-2.0", "thumbnail": "https://www.shadertoy.com/media/shaders/tsXfWS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wd2BDw", "name": "Mandelbuld", "author": "kotfind", "description": "Mandelbulb fractal.", "tags": ["3d", "fractal", "mandelbulb"], "likes": 4, "viewed": 271, "date": "1590165518", "time_retrieved": "2024-06-20T20:07:44.643705", "image_code": "#define ROTATION\n\n#define M_PI 3.1415926\n\n// setting begin\nconst float FOV   = M_PI / 2.;\nconst float zNear = 1.;\nconst float zFar  = 10.;\n\nconst float colissiondist = 0.01;\nconst int maxIter = 100;\n// setting end\n\nvec3 viewpoint = vec3(0., 0., 6.);\n\nfloat sq(in float n) {\n    return n * n;\n}\n\nfloat f(in vec3 p) {\n    float power = 8. + sin(iTime * 1.) * 5.;\n    vec3 z = p;\n    float dr = 1.;\n    float r = 0.;\n\n    for (int i = 0; i < 10; ++i) {\n        r = length(z);\n        if (r > 4.)\n            break;\n\n        float theta = acos(z.z / r) * power;\n        float phi   = atan(z.y / z.x) * power;\n        float zr    = pow(r, power);\n        dr = pow(r, power - 1.) * power * dr + 1.;\n\n        z = zr * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));\n        z += p;\n    }\n    return 0.5 * log(r) * r / dr;\n}\n\nfloat map(in vec3 p) {\n    return f(p);\n}\n\nvoid mapColor(in vec3 p, out float mind, out vec3 color, out vec3 norm) {\n    mind = map(p);\n\n    color = vec3(max(0.1, min(0.9, 1. - (1. - sin(p.x * 100.)) *\n                                        (1. - sin(p.y * 100.)) *\n                                        (1. - sin(p.z * 100.)))));\n\n    // get normal\n    const float E = 0.0001;\n    norm = normalize(vec3(f(p + vec3(E, 0., 0.)), f(p + vec3(0., E, 0.)), f(p + vec3(0., 0., E))));\n}\n\nvec3 ray_marching(vec3 orig, vec3 dir) {\n    dir = normalize(dir);\n    float len = 0.;\n    //vec3 bg = vec3(min(0.937255, max(0.2, sin(dir.x * 5.) + sin(dir.y * 10.) + cos(dir.x * dir.y * 10.))));\n    vec3 bg = vec3(0.2);\n\n    for (int i = 0; i < maxIter; ++i) {\n        float d;\n        vec3 color;\n        vec3 norm;\n        mapColor(orig, d, color, norm);\n        if (d < colissiondist) return color;\n        if (len > zFar) return bg;\n\n        len += d;\n        orig += dir * d;\n    }\n    return bg;\n}\n\nmat3 rotatey(in float a) {\n    float sina = sin(a);\n    float cosa = cos(a);\n    return mat3(cosa,  0., sina,\n                0.,    1.,   0.,\n                -sina, 0., cosa);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / vec2(min(iResolution.x, iResolution.y));\n    uv -= (iResolution.xy / min(iResolution.x, iResolution.y) - vec2(1.)) / 2.;\n    uv.y = 1. - uv.y;\n\n    #ifdef ROTATION\n        float a = iTime * 0.2;\n    #else\n        float a = 0.;\n    #endif\n    viewpoint.x = sin(a) * 3.;\n    viewpoint.z = cos(a) * 3.;\n    vec3 color = ray_marching(viewpoint, rotatey(-a + M_PI) * vec3(uv - vec2(0.5, 0.5) , zNear));\n\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wd2BDw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wd2Bzy", "name": "jupiterCloud-cloud-fuzzed", "author": "alvarobyrne", "description": "simple cloud with multiple layer noise", "tags": ["noise", "cloud"], "likes": 7, "viewed": 308, "date": "1590300508", "time_retrieved": "2024-06-20T20:07:44.643705", "image_code": "// Fork of \"jupiterCloud-cloud\" by feefi. https://shadertoy.com/view/wtdXzN\n// 2020-05-24 06:06:35\n\nfloat N21(vec2 p){\n    float v  = dot(p,vec2(123.2,45.1+0.0001*sin(iTime)));\n    return fract(sin(v)*438.545312);\n}\n\nfloat Noise(vec2 p){\n    vec2 f = fract(p);\n    vec2 id = floor(p);\n    float a = N21(id);\n    float b = N21(id + vec2(1.,0.));\n    float c = N21(id + vec2(0.,1.));\n    float d = N21(id + vec2(1.,1.));\n    f = smoothstep(vec2(0.0),vec2(1.0),f);\n    return mix(mix(a,b,f.x),mix(c,d,f.x),f.y);\n}\nfloat fbm(vec2 p){\n    float n = Noise(p*4.-vec2(iTime*0.1,0));\n    n += Noise(p*8.+vec2(iTime*0.3,0))*0.5;\n    n+= Noise(p*16.-vec2(iTime*0.5,0))*0.25;\n\tn+= Noise(p*32.+vec2(iTime*0.8,0))*0.125;\n    n+= Noise(p*62.-vec2(iTime*2.,0))*0.0625;\n    return (n/2.);\n}\n\nmat2 rot(float a)\n{\n    float c = cos(a),s = sin(a);\n    return mat2(c,-s,s,c);\n}\nconst float pi = 3.1415926;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n\n    float l1 = fbm(uv+1.);\n    float l2 = fbm(rot(pi/2.)*uv+l1);\n    \n    float l3 = fbm(uv+vec2(l1,l2));\n    \n    vec3 col = vec3(0.);\n    col = mix(vec3(1.),vec3(0.985,0.800+sin(iTime),0.714),1.-l1);\n    col = mix(col,vec3(1.30,.009,0.047),l2);\n\tcol = mix(col,vec3(0.1,0.1,0.1),l3);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wd2Bzy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wd2fDW", "name": "Oil flow", "author": "TAKUSAKU", "description": "oil", "tags": ["oil", "flow", "liquid"], "likes": 3, "viewed": 205, "date": "1590073346", "time_retrieved": "2024-06-20T20:07:44.643705", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv *= 6.5;\n    \n    float len;\n    for(int i = 0; i < 3; i++) {\n        len = length(uv);\n        uv.x +=  sin(uv.y + iTime * 0.3)*5.;\n        uv.y +=  cos(uv.x + iTime * 0.1 + cos(len * 2.0))*2.;\n    }\n    \n    vec3 col = vec3(cos(len + 0.3), cos(len + 0.1), cos(len - 0.1));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wd2fDW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wd2fRG", "name": "angel 3", "author": "Aman", "description": "angel 3", "tags": ["the", "mirage"], "likes": 3, "viewed": 218, "date": "1590281444", "time_retrieved": "2024-06-20T20:07:45.595198", "image_code": "\n// S/o https://www.shadertoy.com/view/MlcGRf for the dodecahedron SDF\n// & mercury.sexy for these ops\n\nvec2 opU2(vec2 x, vec2 y) {\n    return vec2(min(x.x, y.x), x.x < y.x ? x.y : y.y);\n}\n\nvec3 polar(vec3 cart) {\n    return vec3(length(cart), atan(cart.y, cart.z), atan(cart.z, cart.x));\n}\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat fOpIntersectionRound(float a, float b, float r) {\n    vec2 u = max(vec2(r + a,r + b), vec2(0));\n    return min(-r, max (a, b)) + length(u);\n}\n\nfloat fOpDifferenceRound (float a, float b, float r) {\n    return fOpIntersectionRound(a, -b, r);\n}\n\nfloat fOpIntersectionChamfer(float a, float b, float r) {\n    return max(max(a, b), (a + r + b)*sqrt(0.5));\n}\n\n// Difference can be built from Intersection or Union:\nfloat fOpDifferenceChamfer (float a, float b, float r) {\n    return fOpIntersectionChamfer(a, -b, r);\n}\n\nfloat fOpPipe(float a, float b, float r) {\n    return length(vec2(a, b)) - r;\n}\n\n\n\n#define GDFVector3 normalize(vec3(1, 1, 1 ))\n#define GDFVector4 normalize(vec3(-1, 1, 1))\n#define GDFVector5 normalize(vec3(1, -1, 1))\n#define GDFVector6 normalize(vec3(1, 1, -1))\n\n#define GDFVector7 normalize(vec3(0, 1, PHI+1.))\n#define GDFVector8 normalize(vec3(0, -1, PHI+1.))\n#define GDFVector9 normalize(vec3(PHI+1., 0, 1))\n#define GDFVector10 normalize(vec3(-PHI-1., 0, 1))\n#define GDFVector11 normalize(vec3(1, PHI+1., 0))\n#define GDFVector12 normalize(vec3(-1, PHI+1., 0))\n\n#define GDFVector13 normalize(vec3(0, PHI, 1))\n#define GDFVector14 normalize(vec3(0, -PHI, 1))\n#define GDFVector15 normalize(vec3(1, 0, PHI))\n#define GDFVector16 normalize(vec3(-1, 0, PHI))\n#define GDFVector17 normalize(vec3(PHI, 1, 0))\n#define GDFVector18 normalize(vec3(-PHI, 1, 0))\n\n#define fGDFBegin float d = 0.;\n#define fGDF(v) d = max(d, abs(dot(p, v)));\n#define fGDFEnd return d - r;\n\n#define PI 3.14159265359\n#define PHI (1.618033988749895)\n#define TAU 6.283185307179586\n\nfloat fDodecahedron(vec3 p, float r) {\n    fGDFBegin\n    fGDF(GDFVector13) fGDF(GDFVector14) fGDF(GDFVector15) fGDF(GDFVector16)\n    fGDF(GDFVector17) fGDF(GDFVector18)\n    fGDFEnd\n}\n\nfloat pModPolar(inout vec2 p, float repetitions) {\n    float angle = 2.0*PI/repetitions;\n    float a = atan(p.y, p.x) + angle/2.;\n    float r = length(p);\n    float c = floor(a/angle);\n    a = mod(a,angle) - angle/2.;\n    p = vec2(cos(a), sin(a))*r;\n    // For an odd number of repetitions, fix cell index of the cell in -x direction\n    // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n    if (abs(c) >= (repetitions/2.0)) c = abs(c);\n    return c;\n}\n\nvec2 sdf(vec3 _p) {\n    vec3 p = _p;\n    p.y -= 0.2;\n    pR(p.yz, 0.7);\n    vec3 pol = polar(p);\n    float n = texture(iChannel0, pol.yz * 0.06 + vec2(0., 1.0 * 0.1)).r ;\n    float n2 = texture(iChannel0, pol.zy * (1.0 + n) + vec2(0., 1.0 * 0.2)).r;\n\n    vec3 pol2 = pol;\n    pol2.yz = mod(pol2.yz * 1.0, PI * 4.0);\n    vec3 dp = p;\n    dp.y -= 0.5;\n    pModPolar(dp.yx,2.0);\n    pR(dp.xz, sin(iTime));\n    vec2 sp = vec2(fDodecahedron(dp, 0.44), 1.0);\n    \n    pR(dp.yz, cos(iTime));\n    sp.x = fOpDifferenceRound(fDodecahedron(dp, 0.5), sp.x, 0.1);\n    \n    pR(dp.yz, sin(-iTime));\n    sp.x = fOpDifferenceRound(fDodecahedron(dp, 0.5), sp.x, 0.1);\n    \n    sp.x = fOpDifferenceRound(sp.x, sp.x * 1.34 * pol.r, 0.);\n\n    float n3 = texture(iChannel0, fract(pol.xz * 0.4 + iTime * 0.1)).r;\n    n3 = n3 * n3 * n3;\n    vec2 mirror = vec2(_p.y + 0.1 + n3 * 0.1, 0.0);\n    mirror.x = fOpIntersectionRound(length(p) - 0.8, mirror.x, 0.06);\n    \n    vec2 ring = vec2(length(p - vec3(0.0, -0.3, 0.0)) - 0.79, 1.0);\n    ring.x = fOpPipe(ring.x, mirror.x, 0.1);\n    \n    return opU2(sp, opU2(ring, mirror));\n}\n\n\nbool march(vec3 ro, vec3 rd, out vec3 hitPos, out float mat) {\n    float t = 0.0;\n    for(int i = 0; i < 50; i++) {\n        vec2 d = sdf(ro);\n        t += d.x;\n        ro += rd * d.x;\n        if(d.x < 0.001) {\n            hitPos = ro;\n            mat = d.y;\n            return true;\n        }\n    }\n    return false;\n}\n\nvec3 estimateNormal(vec3 p) {\n    float h = 0.0001;\n    vec2 k = vec2(1.0, -1.0);\n    return normalize(\n        k.xyy * sdf(p + h * k.xyy).x +\n        k.yxy * sdf(p + h * k.yxy).x +\n        k.yyx * sdf(p + h * k.yyx).x +\n        k.xxx * sdf(p + h * k.xxx).x\n    );\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = -1.0 + 2.0 * fragCoord/iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro = vec3(0.0, 0.3, -1.3);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    vec3 hitPos;\n    float mat;\n    \n    vec3 col = vec3(1.0);\n    if(march(ro, rd, hitPos, mat)) {\n        vec3 normal = estimateNormal(hitPos);\n        if(mat < 0.5) {\n          //  col = vec3(1.0, 0.0, 0.0);\n            vec3 refl = reflect(rd, normal);\n            vec3 reflHit;\n            if(march(hitPos + refl * 0.1, refl, reflHit, mat)) {\n                \n                col = estimateNormal(reflHit) * 0.5 + 0.5;\n                col.rb *= 2.0;\n                col.r = sqrt(col.r);\n                col = mix(col, vec3(1.0), 0.1);\n                //col = vec3(1.0);\n            } else {\n                col = vec3(0.0);\n                \n            }\n        } else {\n        \n            col = estimateNormal(hitPos) * 0.5 + 0.5;\n            col.rb *= 2.0;\n            float spec =  pow(clamp(dot(normal, normalize(vec3(1.0, 1.5, -1.0) - hitPos)), 0.0, 1.0), 4.0);\n            col = mix(col, vec3(1.0), spec * 4.0);\n            col.r = sqrt(col.r);\n            col.g *= 0.5;\n        }   \n        \n       \n        \n        \n    \n    }\n    \n    //if(time < 0.01) { col = vec3(1.0); }\n    \n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wd2fRG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wd2fRW", "name": "Bap", "author": "Bjorn", "description": "I'm stuck on oldschool 2D effects.\nI think this is cool in black & white.", "tags": ["chessboard"], "likes": 5, "viewed": 112, "date": "1590242373", "time_retrieved": "2024-06-20T20:07:45.595198", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 col;\n    vec2 zuu;\n    float prof = 20.;\n    \n    for(float i=prof; i>0. ;i--){\n        zuu.x = .5+cos(uv.x*(5.*i)+sin(iTime*1.2)*4.);\n        zuu.y = .5+cos(uv.y*(5.*i)+cos(iTime*1.6)*4.);\n        if (zuu.x >.5 ^^  zuu.y >.5){\n            col = vec3(1./i,1./i,1./i);\n        }\n    }\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wd2fRW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wd2fWD", "name": "Devil's Egg", "author": "workingclasshacker", "description": "A simple raymarcher, with a distance estimation function for the Mandelbulb fractal. I wish I could fix the artifacts though, any tips on that?", "tags": ["raymarching", "mandelbulb"], "likes": 1, "viewed": 267, "date": "1590099409", "time_retrieved": "2024-06-20T20:07:45.595198", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define MAX_STEPS 100\n#define SURFACE_DIST .001\n#define MAX_DIST 30.0\n#define MANDEL_ITERATIONS 5\n#define MANDEL_BAIL_DIST 16.\n#define MANDEL_POWER 8.0\n\nmat2 Rot2d(float a) {\n  float s = sin(a);\n  float c = cos(a);\n  return mat2(c, - s, s, c);\n}\n\nfloat sdMandelBulb(vec3 p){\n  vec3 z = p;\n  float dr = 1.;\n  float r = 0.;\n  for(int i = 0; i<MANDEL_ITERATIONS;i++){\n    r = length(z);\n    if(r>MANDEL_BAIL_DIST) break;\n\n    // spherical coordinates\n    float theta = acos(z.z/r);\n    float phi = atan(z.y, z.x);\n    dr = pow(r, MANDEL_POWER)*MANDEL_POWER*dr +1.0;\n\n    float zr = pow(r, MANDEL_POWER);\n    theta = theta*MANDEL_POWER;\n    phi = phi*MANDEL_POWER;\n\n    z = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta))+p;\n    \n  }\n  return 0.5*log2(r)*r/dr;\n}\n\nfloat sdSphere(vec3 p, vec4 sphere) {\n  return length(p - sphere.xyz) - sphere.w;\n}\n\nfloat sdBox(vec3 p, vec3 box) {\n  p = abs(p) - box;\n  return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\nfloat sdGyroid(vec3 p, float scale, float thickness, float bias) {\n  p *= scale;\n  return abs(dot(sin(p), cos(p.zxy)) + bias) / scale - thickness;\n}\n\nfloat sdAAPlane(vec3 p){\n  return p.y;\n}\n//\nvec3 Transform(vec3 p) {\n  return p;\n}\n\nfloat GetDist(vec3 p){\n  // replace with your scene\n  float d = sdMandelBulb(p);\n    \n  return d;\n}\n\nvec3 GetNormal(vec3 p) {\n  vec2 e = vec2(0.00001, 0.);\n  float d = GetDist(p);\n  vec3 n = d-vec3(GetDist(p - e.xyy), GetDist(p - e.yxy), GetDist(p - e.yyx));\n  return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n  vec3 f = normalize(l - p),\n  r = normalize(cross(vec3(0, 1, 0), f)),\n  u = cross(f, r),\n  c = p+f * z,\n  i = c+uv.x * r+uv.y * u,\n  d = normalize(i - p);\n  return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n  float dO = 0.0;\n  for(int i = 0; i < MAX_STEPS; i ++ ) {\n    vec3 p = ro + dO * rd;\n    float ds = GetDist(p);\n    dO += ds;\n    if (dO < SURFACE_DIST||dO > MAX_DIST) {\n      break;\n    }\n  }\n  return dO;\n}\n\nvec3 render(vec2 uv){\n  float t = iTime / 5.0;\n  vec3 color = vec3(0);\n  \n  // camera\n  vec3 camO = vec3(0, 0, -3);\n  vec3 lookAt = vec3(0, 0, 0);\n\n  camO.xz *= Rot2d(t/1.);\n  camO.yz *= Rot2d(t/1.);\n  vec3 rd = GetRayDir(uv, camO, lookAt, 6.*(sin(t)*.5+.5));\n  \n  // trace scene\n  float d = RayMarch(camO, rd);\n    \n  // material\n  if (d < MAX_DIST) {\n    vec3 p = camO + rd * d;\n    vec3 n = GetNormal(p);\n    float height = p.y;\n    float dif = n.y * 0.5 + 0.5+n.x*.5;    \n    //color.r = n.x;\n    //color += vec3(.0,0,0.);\n    //color += .2*n*dif*dif+dif*.5;\n    color += vec3(d*.2);\n    \n    color *= vec3(n.x*.4,0,n.y/2.);\n    color *= dif;\n  } else {\n   \tcolor = vec3(.2,0,0);\n    color *= 1.-dot(uv, uv);\n  }\n  return color*=1.7;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  vec2 uv = (fragCoord.xy-0.5 * iResolution.xy) / iResolution.y;\n  \n  vec3 color = render(uv);\n  \n  fragColor=vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wd2fWD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wd2fzd", "name": "Iridescent bubble fly-through", "author": "jarble", "description": "Another edit of my [url=https://www.shadertoy.com/view/tsBfRd]\"Iridescent bubbles\"[/url] shader.", "tags": ["raymarching", "hash"], "likes": 0, "viewed": 174, "date": "1590626199", "time_retrieved": "2024-06-20T20:07:46.764850", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n/**\n * Part 6 Challenges:\n * - Make a scene of your own! Try to use the rotation transforms, the CSG primitives,\n *   and the geometric primitives. Remember you can use vector subtraction for translation,\n *   and component-wise vector multiplication for scaling.\n */\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 10.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.00001;\n\nvec3 hash33(vec3 p3)\n{\t\n    //this is from https://www.shadertoy.com/view/4djSRW\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n/**\n * Rotation matrix around the Y axis.\n */\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(hash33(sin(p)/10.0))-sin(length(p))/3.33;\n}\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {\n    return sphereSDF(samplePoint,1.0);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(8.0+iTime*10.0, 5.0, 7.0*iTime);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = hash33(p/(500.0));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wd2fzd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wd2fzV", "name": "Locked In Glass!", "author": "dean_the_coder", "description": "Webcam 'locked in glass' - Inspired by Superman.\nThanks to Evvvvil for his awesome Twitch tutorials!", "tags": ["procedural", "3d", "raymarch", "webcam", "superman", "memix"], "likes": 18, "viewed": 492, "date": "1590431109", "time_retrieved": "2024-06-20T20:07:46.764850", "image_code": "float glow = 0.0;\n\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat sdPlane(vec3 p) {\n    return p.y;\n}\n\nfloat sdCylinder(vec3 p, float r, float h) {\n    float d = length(p.xz) - r;\n    \n    return max(max(-p.y, d), p.y - h);\n}\n\nfloat sdTorus(vec3 p, float t) {\n  vec2 q = vec2(length(p.xz)-t, p.y);\n  return length(q);\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdRings(vec3 p, bool useGlow) {\n    p.xz *= rot(iTime * 3.0);\n    \n    p.y = abs(p.y - 1.85) - 0.8;\n    p.xy *= rot(3.1415 / 8.0);\n    \n    float d = sdTorus(p, 2.0);\n    \n    if (useGlow)\n    \tglow += 0.008 / (d * d);\n    return d;\n}\n\nvec2 glassUV;\n\nfloat sdGlass(vec3 p, bool txMap) {\n    p.y -= 2.0;\n    \n    p.xz *= rot(iTime * 0.3);\n    p.xy *= rot(sin(iTime * 0.9));\n    p.yz *= rot(sin(iTime * 0.7));\n    \n    if (txMap) {\n        ivec2 ts = textureSize(iChannel0, 0);\n        float ratio = float(ts.y) / float(ts.x);\n        glassUV = (p.xy * vec2(ratio, 1.0)  * 0.42 + 0.5);\n    }\n    \n    return sdBox(p, vec3(1.2, 1.2, 0.01));\n}\n\nvec2 map(vec3 p, bool isMapping) {\n    float d1 = sdCylinder(p, 2.0, 0.2);\n    float d2 = sdPlane(p);\n    float d3 = sdRings(p, isMapping);\n    float d4 = sdGlass(p, isMapping);\n    \n    vec2 res = d1 < d2 ? vec2(d1, 1.5) : vec2(d2, 2.5);\n    if (d3 < res.x) res = vec2(d3, 0.0);\n    if (d4 < res.x) res = vec2(d4, 3.5);\n    \n    return res;\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    return normalize(forward + right * uv.x + up * uv.y);\n}\n\nvec3 calcNormal(in vec3 p) {\n    // Thanks iq!\n    vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;\n    return normalize(e.xyy * map(p + e.xyy, false).x + \n\t\t\t\t\t e.yyx * map(p + e.yyx, false).x + \n\t\t\t\t\t e.yxy * map(p + e.yxy, false).x + \n\t\t\t\t\t e.xxx * map(p + e.xxx, false).x);\n}\n\nfloat calcShadow(vec3 p, vec3 lightPos, float sharpness) {\n    vec3 rd = normalize(lightPos - p);\n    \n    float h;\n    float minH = 1.0 / sharpness;\n    for (float d = 0.1; d < 32.0; d += h) {\n        h = max(0.0, map(p + rd * d, false).x);\n        minH = min(minH, h / d);\n        if (minH < 0.01)\n            break;\n    }\n    \n    return minH * sharpness;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Raymarch.\n    vec3 ro = 5.0 * vec3(0.0, 0.4, -1.1 + (4.5 * sin(iTime * 0.5) + sin(iTime * 0.25)) * 0.1);\n    vec3 rd = getRayDir(ro, vec3(0.0, 1.4, 0.0), uv);\n\n    int hit = 0;\n    float d = 0.01;\n    vec3 p;\n    for (float steps = 0.0; steps < 128.0; steps++) {\n        p = ro + rd * d;\n        vec2 h = map(p, true);\n        if (h.x < 0.004 * d) {\n            hit = int(h.y);\n            break;\n        }\n\n        d += h.x;\n    }\n\n    vec3 col;\n    vec3 skyCol = vec3(0.18, 0.2, 0.22) * 0.1;\n    if (hit > 0) {\n        vec3 n = calcNormal(p);\n        vec3 lightPos = vec3(1.0, 1.2, -5.0);\n        vec3 lightCol = vec3(1.0, 0.9, 0.8);\n        vec3 lightToPoint = normalize(lightPos - p);\n        float sha = calcShadow(p, lightPos, 5.0);\n        float spe = 1.5 * pow(max(0.0, dot(rd, reflect(lightToPoint, n))), 30.0);\n        vec3 mainLight = clamp(dot(n, lightToPoint), 0.01, 1.0) * lightCol;\n        vec3 backLight = clamp(dot(n, -rd), 0.01, 1.0) * 0.2 * lightCol;\n        float fog = 1.0 - exp(-d * 0.03);\n\n        vec3 mat;\n        if (hit == 1) {\n            // Podium.\n            mat = vec3(0.001);\n        } else if (hit == 2) {\n            // Plane.\n            mat = vec3(0.001);\n            \n        } else if (hit == 3) {\n            // Glass.\n            mat = texture(iChannel0, glassUV).rgb;\n        }\n\n        col = mainLight * lightCol * sha;\n        col += backLight;\n        col += spe * lightCol;\n        col *= mat;\n        col = mix(col, skyCol, fog);\n    } else {\n        // Sky.\n        col = skyCol;\n    }\n    \n    // Glow\n    col += glow * 0.1;\n\n    // Output to screen\n    col = pow(col, vec3(0.4545));\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "4sf3zn", "previewfilepath": "/presets/webcam.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/webcam.png", "ctype": "webcam"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wd2fzV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wd2yRV", "name": "My Improved Raytracer", "author": "mrmcsoftware", "description": "Here's an improved raytracer I wrote which is a GLSL version of a trimmed down C version of my C raytracer (trimmed down version was the basis for my assembly language versions (my own CPU design and x86)) - now with reflection/refraction by using a loop.", "tags": ["raytracer", "animation"], "likes": 1, "viewed": 233, "date": "1588917739", "time_retrieved": "2024-06-20T20:07:49.134950", "image_code": "//#version 130\n//#extension GL_EXT_gpu_shader4 : enable\n\n//#define GAMMAC 1.0/2.2   // Uncomment this line to apply gamma correction\n#define SPEED 4.0  // speed adjustment - MODIFY AS NEEDED\n#define MAXLEVEL 2  // ray trace depth - MODIFY AS DESIRED\n\n#define SMALL .001\n#define SMALL3 .000001\n\n#define SPHERE 0\n#define PLANE 1\n#define LIGHT 2\n\nstruct Ray\n\t{\n\tvec3 p;\n\tvec3 v;\n\t};\n\nstruct Rgb\n\t{\n\tfloat r,g,b;\n\t};\n\nstruct View\n\t{\n\tvec3 e,a,u;\n\t};\n\nstruct Light\n\t{\n\tvec3 p;\n\tfloat k,dist,r;\n\tRgb i;\n\t};\n\nstruct Info\n\t{\n\tvec3 v1,v2,v3,v4;\n\tfloat f1,f2,f3;\n\t};\n\nstruct Object\n\t{\n\tint type,id;\n\tRgb amb,diff,spec,tran;\n\tfloat ka,ks,kd,kn,kr,kt,n;\n\tInfo info;\n\t};\n\nstruct Hit\n\t{\n\tObject object;\n\tvec3 normal,pt;\n\tfloat t;\n\tRgb col;\n\t};\n\n#define MAXFLOAT\t3.37E+38\n\nView V;\nint xres,yres;\nint CXc,CYc,xc,yc;\nRgb bg=Rgb(0.0,0.0,0.0),ambient;\nint numlights=0;\nLight light[2];\nint numobj=0;\nObject objs[10];\nfloat ka=.15,ks=.10,kd=.415,kn=8.0,kr=0.0,textoff=32.0,gn=1.0,ior,kt=0.0;\nRgb diff,spec,tran;\nHit hit;\nvec3 pol[3];\nfloat flengthx=1150.0,flengthy=1150.0,min_weight=.05;\nvec3 dir,right;\nInfo infoblank;\nRgb gat;\nfloat gt;\nvec3 gpt;\n\nRgb trace(Ray);\nvoid pushobj(int,Info);\n\n/* I'll use GLSL's functions instead, but these do work */\n/*\n\nfloat Dot(vec3 v1,vec3 v2)\n{\nfloat f;\n\nf=v1.x*v2.x+v1.y*v2.y+v1.z*v2.z;\nreturn(f);\n}\n\nfloat Mag(vec3 v1)\n{\nfloat d;\n\nd=sqrt(v1.x*v1.x+v1.y*v1.y+v1.z*v1.z);\nreturn(d);\n}\n\nvec3 Normalize(vec3 v1)\n{\nfloat d;\nvec3 res;\n\nd=sqrt(v1.x*v1.x+v1.y*v1.y+v1.z*v1.z);\nres.x=v1.x/d;\nres.y=v1.y/d;\nres.z=v1.z/d;\nreturn(res);\n}\n\nvec3 CrossProduct(vec3 v2,vec3 v3)\n{\nvec3 res;\n\nres.x=v2.y*v3.z-v2.z*v3.y;\nres.y=v2.z*v3.x-v2.x*v3.z;\nres.z=v2.x*v3.y-v2.y*v3.x;\nreturn(res);\n}\n\n*/\n\nbool sphereinter(Object obj,Ray ray)\n{\nfloat a,b,c,d,spht0,spht1,t;\nvec3 P;\n\nP=ray.p-obj.info.v1;\nc=dot(P,P)-obj.info.f1*obj.info.f1;\nb=2.0*dot(ray.v,P);\na=dot(ray.v,ray.v);\nd=b*b-4.0*a*c;\nif (d<=0.0) { return(false); }\nd=sqrt(d);\nif (a==0.0) { return(false); }\nspht0=(-b+d)/(a+a);\nspht1=(-b-d)/(a+a);\nif ((spht1<spht0)&&(spht1>SMALL)) t=spht1;\nelse t=spht0;\nif (t>SMALL)\n\t{\n\tgpt=P+t*ray.v;\n\tgt=t;\n\treturn(true);\n\t}\nreturn(false);\n}\n\nvec3 spherenorm(Object obj,Ray ray)\n{\nvec3 n,pt;\n\nn=gpt;\ngpt+=obj.info.v1;\nn=normalize(n);\nreturn(n);\n}\n\nbool triinter(Object obj,Ray ray)\n{\nfloat in1,in2,f1,t;\n\nf1=dot(obj.info.v3,ray.v);\nif (abs(f1)<SMALL) return(false);\nin1=obj.info.f3;\nin2=dot(obj.info.v3,ray.p);\nt=(in1-in2)/f1;\nif (t<SMALL) return(false); /* ?? */\ngpt=ray.p+t*ray.v;\nreturn(true);\n}\n\nvec3 trinorm(Object obj,Ray ray)\n{\nvec3 n,pt;\n\nreturn(obj.info.v3);\n}\n\nvoid planarobj(int t)\n{\nInfo info;\n\ninfo=infoblank;\ninfo.v1=pol[1]-pol[0];\ninfo.v2=pol[2]-pol[0];\ninfo.v3=cross(info.v1,info.v2);\ninfo.v3=normalize(info.v3);\ninfo.v4=pol[0];\ninfo.f1=dot(info.v1,info.v1);\ninfo.f2=dot(info.v2,info.v2);\ninfo.f3=dot(info.v3,info.v4);\npushobj(t,info);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\nInfo info;\nfloat r,g,b;\nRay eye_ray;\nfloat xf,yf;\nRgb col;\n\nnumobj=0;\nV.a=vec3(0,0,0);\nV.e=vec3(1,10,20);\nV.u=vec3(0,1,0);\nCXc=(xres/2); CYc=(yres/2);\ndir=V.a-V.e;\ndir=normalize(dir);\nright=cross(V.u,dir);\nright=normalize(right);\nV.u=cross(dir,right);\nV.u=normalize(V.u);\n\n\t/* magenta sphere */\nka=.1; ks=0.0; kd=.6; kn=40.0; ambient=Rgb(.99,.99,.99);\nspec=Rgb(255.0,255.0,255.0);\nks=.5;\ninfo.v1=vec3(1.0,1.0,0.0); info.f1=1.0;\ndiff=Rgb(255.0,0.0,255.0);\nkr=.5;\npushobj(SPHERE,info);\n\t/* green sphere */\nks=0.0;\ninfo.v1=vec3(-1.0,1.0,2.0);\ndiff=Rgb(0.0,255.0,0.0);\nkt=1.0; /*.58;*/ ior=1.75; kd=.07; ks=.4; kr=.26; /*0;*/ /*.1;*/ kn=100.0;\ntran=Rgb(0.0,255.0,0.0);\nka=0.0;\n/* adjust to no refraction possible */\n//kt=0.0; ka=.1; kd=.6;\nkr=0.0;\npushobj(SPHERE,info);\n\t/* yellow sphere */\nkt=0.0; kd=.6; ks=0.0; /*.5;*/ kr=.5; kn=40.0;\nka=.1;\ninfo.v1=vec3(.75,1.0,3.25);\ndiff=Rgb(255.0,255.0,0.0);\npushobj(SPHERE,info);\n\t/* light 1 */\nlight[numlights].p=vec3(-2.0,6.0,8.0);\nlight[numlights].i=Rgb(.2,.2,.2);\nlight[numlights].k=0.0; light[numlights].dist=9.0; light[numlights].r=.25;\n//normalize(light[numlights].p); light[numlights].r=0;\ninfo.v1=light[numlights].p;\ninfo.f1=light[numlights].r;\npushobj(LIGHT,info);\nnumlights++;\n\t/* light 2 */\nlight[numlights].p=vec3(2.0,8.0,7.0);\nlight[numlights].i=Rgb(.99,.99,.99);\nlight[numlights].k=0.0; light[numlights].dist=9.0; light[numlights].r=.25;\n//normalize(light[numlights].p); light[numlights].r=0;\ninfo.v1=light[numlights].p;\ninfo.f1=light[numlights].r;\npushobj(LIGHT,info);\nnumlights++;\n\t/* plane */\ndiff=Rgb(255.0,255.0,255.0); ks=.8; kd=.4;\npol[0]=vec3(0.0,0.0,0.0);\npol[1]=vec3(0.0,0.0,1.0);\npol[2]=vec3(1.0,0.0,0.0);\n//kr=0;\nplanarobj(PLANE);\n\n\t/* adjust movements through time */\nfloat iGlobalTime=iTime-1.0;\nif (iGlobalTime<0.0) { iGlobalTime=0.0; }\niGlobalTime*=SPEED;\n//iGlobalTime=0.0;\nobjs[0].info.v1+=vec3(0,0,(iGlobalTime)*.2);\nobjs[1].info.v1+=vec3((iGlobalTime)*-.1,0,0);\nobjs[2].info.v1+=vec3((iGlobalTime)*.2,0,0);\nlight[1].p+=vec3((iGlobalTime)*-1.0,0,0);\n\nCXc=int(iResolution.x/2.0);\nCYc=int(iResolution.y/2.0);\nvec2 q=fragCoord.xy;\nq.y=iResolution.y-q.y-1.0;\nxc=int(q.x); yc=int(q.y);\nflengthx=flengthy=iResolution.y/1.5*750.0/256.0;\n//flengthx=flengthy=150.0/256.0*5.0;\nxf=float(CXc-xc)/flengthx;\nyf=float(CYc-yc)/flengthy;\neye_ray.v=dir+xf*right+yf*V.u;\neye_ray.p=V.e;\ncol=trace(eye_ray);\nr=clamp(col.r/255.0,0.0,1.0);\ng=clamp(col.g/255.0,0.0,1.0);\nb=clamp(col.b/255.0,0.0,1.0);\n#ifdef GAMMAC\nr=pow(r,GAMMAC);\ng=pow(g,GAMMAC);\nb=pow(b,GAMMAC);\n#endif\nfragColor=vec4(r,g,b,1);\n}\n\nfloat shadow(Object obj,vec3 p,vec3 vv,float vd)\n{\nRay v;\nfloat t;\nint j;\nbool i;\n\nv.p=p;\nv.v=vv;\nfor (j=0;j<numobj;j++)\n\t{\n\tObject ptr=objs[j];\n\tif ((ptr.id!=obj.id)&&(ptr.type!=LIGHT)&&(ptr.type!=PLANE))\n\t\t{\n\t\tif (ptr.type==SPHERE) { i=sphereinter(ptr,v); }\n\t\telse { i=false; }\n\t\tif (i)\n\t\t\t{\n\t\t\tif (t<vd)\n\t\t\t\t{\n\t\t\t\tif (ptr.kt<min_weight) { return(0.0); }\n\t\t\t\tgat.r*=ptr.kt*ptr.tran.r/255.0;\n\t\t\t\tgat.g*=ptr.kt*ptr.tran.g/255.0;\n\t\t\t\tgat.b*=ptr.kt*ptr.tran.b/255.0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nreturn(1.0);\n}\n\nRgb shade(Ray ray,Object obj,vec3 N,vec3 pt)\n{\nRgb color,dcol;\nfloat t2,f;\nfloat t,t3;\nint i;\nvec3 L;\nRay R,T;\nfloat light_dist=0.0; /* ?? */\nRgb at;\n\ndcol=hit.col;\nif (obj.type==LIGHT) { color.r=color.g=color.b=0.0; return(color); }\ncolor.r=obj.ka*obj.amb.r*dcol.r;\ncolor.g=obj.ka*obj.amb.g*dcol.g;\ncolor.b=obj.ka*obj.amb.b*dcol.b;\n\nfor (i=0;i<numlights;i++)\n\t{\n\tL=light[i].p-pt;\n\tlight_dist=length(L);\n\tL=normalize(L);\n\tf=dot(N,L);\n\tgat.r=gat.g=gat.b=1.0;\n\tif (shadow(obj,pt,L,light_dist)>0.0)\n\t\t{\n\t\tt3=light[i].dist/(light_dist+light[i].k);\n\t\tif ((f>0.0)||(obj.kt>min_weight))\n\t\t\t{\n\t\t\tt=t3*f*obj.kd;\n\t\t\tif ((obj.kt>min_weight)&&(f<0.0)) { t=-t; }\n\t\t\tcolor.r+=light[i].i.r*dcol.r*t*gat.r;\n\t\t\tcolor.g+=light[i].i.g*dcol.g*t*gat.g;\n\t\t\tcolor.b+=light[i].i.b*dcol.b*t*gat.b;\n\t\t\tt2=2.0*f;\n\t\t\tR.v=t2*N-L;\n\t\t\tt2= -dot(R.v,ray.v);\n\t\t\tif (t2>0.0)\n\t\t\t\t{\n\t\t\t\tt2=t3*pow(t2,obj.kn)*obj.ks;\n\t\t\t\tcolor.r+=light[i].i.r*obj.spec.r*t2*gat.r;\n\t\t\t\tcolor.g+=light[i].i.g*obj.spec.g*t2*gat.g;\n\t\t\t\tcolor.b+=light[i].i.b*obj.spec.b*t2*gat.b;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nreturn(color);\n}\n\nbool intersect(Ray ray)\n{\nObject ptr,p;\nint j;\nbool inter=false,i=false;\nfloat t;\nvec3 pt,gpts;\nfloat mint=MAXFLOAT;\nRgb col,colm;\n\nfor (j=0;j<numobj;j++)\n\t{\n\tptr=objs[j];\n\tif (ptr.type==SPHERE) { i=sphereinter(ptr,ray); }\n\telse if (ptr.type==PLANE) { i=triinter(ptr,ray); }\n\telse { i=false; }\n\tif (i)\n\t\t{\n\t\tinter=true;\n\t\tif (gt<mint)\n\t\t\t{\n\t\t\tp=ptr; mint=gt; gpts=gpt;\n\t\t\tcolm=ptr.diff;\n\t\t\t}\n\t\t}\n\t}\nif (inter)\n\t{\n\thit.object=p;\n\thit.t=mint;\n\tgpt=gpts;\n\tif (p.type==SPHERE) { hit.normal=spherenorm(p,ray); }\n\telse if (p.type==PLANE) { hit.normal=trinorm(p,ray); }\n\thit.pt=gpt;\n\tif (p.type==PLANE)\n\t\t{\n\t\tint ibx,ibz;\n\n\t\tibx=int(gpt.x+textoff);\n\t\tibz=int(gpt.z+textoff);\n\t\tif (((ibx+ibz)%2)==1) { colm.r=colm.g=colm.b=128.0; }\n\t\telse { colm.r=colm.g=colm.b=255.0; }\n\t\t}\n\thit.col=colm;\n\t}\nreturn(inter);\n}\n\nRgb trace(Ray ray)\n{\nvec3 pt,N;\nObject obj;\nRgb col,dcol,colt;\nint level;\nvec3 k;\nfloat f,t,t2,t3;\n\nray.v=normalize(ray.v);\ncol=Rgb(0.0,0.0,0.0);\nk=vec3(1.0,1.0,1.0);\nfor (level=0;level<=MAXLEVEL;level++)\n\t{\n\tif (intersect(ray))\n\t\t{\n\t\tobj=hit.object;\n\t\tdcol=hit.col;\n\t\tN=hit.normal;\n\t\tpt=hit.pt;\n\t\tcolt=shade(ray,obj,N,pt);\n\t\tcol.r+=colt.r*k.x;\n\t\tcol.g+=colt.g*k.y;\n\t\tcol.b+=colt.b*k.z;\n\t\tk=vec3(1.0,1.0,1.0);\n\t\tif (obj.kr>min_weight)\n\t\t\t{\n\t\t\tf= -2.0*dot(N,ray.v);\n\t\t\tray.v=f*N+ray.v;\n\t\t\tray.p=pt+SMALL3*ray.v;\n\t\t\tk=vec3(obj.kr,obj.kr,obj.kr);\n\t\t\t}\n\t\telse if (obj.kt>min_weight)\n\t\t\t{\n\t\t\tfloat n;\n\t\n\t\t\tf=dot(N,ray.v);\n\t\t\tif (f<0.0) { n=gn/obj.n; f= -f; }\n\t\t\telse { n=obj.n/gn; N=-N; }\n\t\t\tt=n*f;\n\t\t\tt3=1.0-n*n*(1.0-f*f);\n\t\t\tk=vec3(obj.kt*dcol.r/255.0,obj.kt*dcol.g/255.0,obj.kt*dcol.b/255.0);\n\t\t\tif (t3<0.0) // TIR\n\t\t\t\t{\n\t\t\t\tf= -2.0*dot(N,ray.v);\n\t\t\t\tray.v=f*N+ray.v;\n\t\t\t\tray.p=pt+SMALL3*ray.v;\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tt2=t-sqrt(t3);\n\t\t\t\tray.v=t2*N+n*ray.v;\n\t\t\t\tray.p=pt+SMALL3*ray.v;\n\t\t\t\t}\n\t\t\t}\n\t\telse { break; }\n\t\t}\n\telse\n\t\t{\n\t\tcol.r+=bg.r*k.x;\n\t\tcol.g+=bg.g*k.y;\n\t\tcol.b+=bg.b*k.z;\n\t\treturn(col);\n\t\t}\n\t}\nreturn(col);\n}\n\nvoid pushobj(int type,Info info)\n{\nobjs[numobj].id=numobj;\nobjs[numobj].type=type;\nif (type!=LIGHT)\n\t{\n\tobjs[numobj].ka=ka;\n\tobjs[numobj].ks=ks;\n\tobjs[numobj].kd=kd;\n\tobjs[numobj].kn=kn;\n\tobjs[numobj].kr=kr;\n\tobjs[numobj].kt=kt;\n\tobjs[numobj].n=ior;\n\tobjs[numobj].diff=diff;\n\tobjs[numobj].tran=tran;\n\tobjs[numobj].amb.r=ambient.r;\n\tobjs[numobj].amb.g=ambient.g;\n\tobjs[numobj].amb.b=ambient.b;\n\tobjs[numobj].spec=spec;\n\t}\nobjs[numobj].info=info;\nnumobj++;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wd2yRV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdBBDK", "name": "clockEyes2", "author": "HaleyHalcyon", "description": "a", "tags": ["gear"], "likes": 1, "viewed": 101, "date": "1590824307", "time_retrieved": "2024-06-20T20:07:50.086542", "image_code": "const float PI = 3.14159265;\n\nfloat remap(float x, float lowIn, float rangeIn, bool invert)\n{\n    float o = clamp(clamp(x - lowIn, 0., rangeIn) / rangeIn, 0., 1.);\n    if (invert) {\n        return 1. - o;\n    }\n    return o;\n}\n\nvec3 blend(vec3 x1, vec3 x2, float factor)\n{\n    return x2 * factor + x1 * (1. - factor);\n}\n\nfloat zigzag(float x)\n{\n    return abs(1. - mod(x, 2.0));\n}\n  \nfloat eyeAccent(vec2 uv, float x) {\n    float x2 = max(0., 0.8 - x);\n    vec2 uv2 = uv / vec2(0.7, 0.55) + vec2(0., 0.4);\n    float bottom = clamp(1.1 * (1.3 - 1.0 * (uv2.x * uv2.x + uv2.y * uv2.y)), 0., 1.);\n    float center = clamp(2.5 * x2 * x2, 0., 1.0);\n    return (cos(3.0 * (bottom - center)) - 1.) * -0.5;\n}\n\nfloat eyeHighlight(vec2 uv) {\n    vec2 uv2 = (uv + vec2(0.3, -0.4)) * vec2(1.9, 2.6);\n    float dist2 = (uv2.x * uv2.x + uv2.y * uv2.y);\n    float top = smoothstep(0.8, 0.85, 1. - dist2);\n    \n    uv2 = (uv + vec2(0.15, -0.25)) * vec2(3., 4.5);\n    dist2 = (uv2.x * uv2.x + uv2.y * uv2.y);\n    float middle = smoothstep(0.8, 0.9, 1. - dist2);\n    \n    uv2 = (uv + vec2(-0.25, 0.4)) * vec2(1.3, 1.8);\n    dist2 = (uv2.x * uv2.x + uv2.y * uv2.y);\n    float bottom = smoothstep(0.8, 0.9, 1. - dist2);\n    \n    return max(top * 1.0, max(middle * 0.8, bottom * 0.3));\n}\n\nfloat timeBounce(float x)\n{\n    return -3. * sin(PI * x) + x;\n}\n\nfloat gear(float d, float theta)\n{\n    // constants\n    // teeth\n    const float teethCount = 8.0;\n    const float teethWidth = 0.3; // from 0.0 to 1.0\n    const float teethSlant = 0.2; // purely radial sides don't look right\n    const float teethSmoothing = 0.06;\n    // spokes\n    const float spokeCount = 4.0;\n    const float spokeWidth = 0.08; // from 0.0 to 1.0\n    const float spokeSlant = 0.3; // purely radial sides don't look right\n    const float spokeSmoothing = 0.04;\n    // radii\n    const float scale = 0.5; // total size of the gear\n    const float smoothing = 0.02; // radial; teeth and spoke smoothing are defined separately\n    const float center = 0.2; // spokes start here\n    const float inner = 0.5; // spokes end here\n    const float outer = 0.75; // teeth start here\n    \n    d /= scale;\n    \n    if (d < center) {\n        return 1.;\n    } else if (d < inner) {\n        float slant = remap(\n                    d, center, inner + smoothing - center, true\n                );\n        return clamp(\n            remap(d, center, 0.25 * smoothing, true) // center smoothing (quarter)\n            +\n            remap( // spokes\n                1. - zigzag(theta / PI * spokeCount) - slant * slant * spokeSlant,\n                spokeWidth,\n                spokeSmoothing,\n                true\n            )\n            +\n            remap(\n                d,\n                inner - smoothing,\n                smoothing,\n                false\n            )\n        , 0., 1.);\n    } else if (d < outer) {\n        return 1.;\n    } else if (d < 1.) {\n        return clamp(\n            min(\n                remap(d, outer, smoothing, true) // ring smoothing\n                +\n                remap( // teeth\n                    1. - zigzag(theta / PI * teethCount) - remap(\n                        d, outer, 1. + smoothing - outer, true) * teethSlant,\n                    teethWidth,\n                    teethSmoothing,\n                    true\n                )\n            ,\n                remap( // smooth outer rim of gear\n             \t\td,\n                    1. - 2. * smoothing, // smooth double for outside\n                    smoothing,\n                    true\n                )\n            )\n        , 0., 1.);\n    }\n    return 0.;\n}\n\nfloat tick(float t){\n    const float ticksPerRot = 24.0;\n    const float tickLength = 0.125;\n    const float tickPeriod = 1.;\n    t += 0.5 * tickLength + 0.5 * tickPeriod;\n    return (\n        floor(t / tickPeriod) + smoothstep(0., 1., (mod(t / tickPeriod, 1.) - 0.5) / tickLength)\n \t\t) / ticksPerRot\n    ;\n}\n  \nfloat spiral(float x) {\n  return max(0.0, sin(x) * 0.75 + 0.25);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n  // colors\n  const vec3 colorBase = vec3(0.2, 0.3, 0.5);\n  const vec3 colorBaseG = vec3(0.1, 0.1, 0.3);\n  const vec3 colorAccent = vec3(0., 0.4, 0.6);\n  const vec3 colorGear = vec3(0.9, 0.95, 0.95);\n  const vec3 colorSpiral = vec3(0.2);\n  const vec3 colHighlight = vec3(0.7);\n\n  // parameters to tweak\n  // more params for the gear inside the gear() function\n  const float eyesScale = 0.7;\n\n  // more params for the ticking inside the tick() function\n  float time = tick(iTime);\n\n  // Normalized pixel coordinates (from 0 to 1)\n  float scale = min(iResolution.x, iResolution.y);\n  vec2 uv = (gl_FragCoord.xy - 0.50 * iResolution.xy) / scale * 1.41421356;\n    \n  float dist = sqrt(uv.x*uv.x+uv.y*uv.y) / eyesScale;\n  \n  float angle = atan(uv.y, uv.x);\n\n  // Time varying pixel color\n  float cAccent = eyeAccent(uv, dist);\n  float cGear = gear(dist, angle + 2. * PI * time);\n  float cHighlight = eyeHighlight(uv);\n  \n  float logDist = log(dist);\n  float bounceTime = timeBounce(iTime * 2.0 + logDist * 0.4);\n  float ring = spiral(logDist * 8.0 + bounceTime);\n  \n  vec3 colBase = colorBase + uv.y * colorBaseG + cAccent * colorAccent + ring * colorSpiral;\n  vec3 colComp = blend(colBase, colorGear, cGear);\n\n  // Output to screen\n  fragColor =\n    vec4(\n        min(vec3(1.0), colComp + cHighlight * colHighlight)\n        * remap(dist, 1.0, 0.02, true) // remove this line to remove circle crop\n      , 1.\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdBBDK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdBBDy", "name": "Tornado World", "author": "jarble", "description": "It's a mesmerizing sea of technicolor tornadoes.", "tags": ["raymarching", "tornado", "cyclone"], "likes": 0, "viewed": 211, "date": "1590714197", "time_retrieved": "2024-06-20T20:07:51.159288", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n/**\n * Part 6 Challenges:\n * - Make a scene of your own! Try to use the rotation transforms, the CSG primitives,\n *   and the geometric primitives. Remember you can use vector subtraction for translation,\n *   and component-wise vector multiplication for scaling.\n */\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.0001;\n\nvec3 hash33(vec3 p3)\n{\tp3 *= (p3.y+p3.y+p3.z)*(15.0);\n    return fract((p3+1.2+sin((iTime+p3.y+p3.x+p3.z)*5.0)/10.0)/(p3+.5+sin(p3.y+p3.x+p3.z)));\n}\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {    \n    return length(hash33(sin(samplePoint)/10.0))-sin(length(samplePoint))/3.33;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(8.0+iTime, 5.0, 7.0*iTime);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = hash33(p/(500.0));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdBBDy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdBBW3", "name": "multi-scale truchet scaled - 2", "author": "FabriceNeyret2", "description": "\"multi-scale truchet scaled\" by phi16 simplified and commented [url]https://shadertoy.com/view/wdjfDK[/url]\n\nThen golfed (+further simplif) there (unlisted) [url]https://www.shadertoy.com/view/wd2fD3[/url]", "tags": ["2d", "truchet"], "likes": 25, "viewed": 302, "date": "1590927519", "time_retrieved": "2024-06-20T20:07:51.528972", "image_code": "// Fork of \"multi-scale truchet scaled\" by phi16. (1825) https://shadertoy.com/view/wdjfDK\n// Simplified and commented.\n\n// hash(int(p)) with seed varying with parameter i and time\n#define rand(p,i) fract(  sin( dot( ceil(p), vec2(12.9,78.2) ) ) * 4e5  \\\n                         + .2 + 1.4 * (i + floor(iTime/2.) )            \\\n                       )             \nfloat H(vec2 U) {                           // choose truchet LOD\n    float i=0.;\n    for( ; i < 5. ; i++, U*=2. )\n        if( U.y > 1. && ( abs(U.y) > 2. || rand(U,i) < .5 ) ) break;\n \n    return i;\n}\n\nvoid mainImage( out vec4 O, vec2 co )\n{\n    vec2 R = iResolution.xy, F,\n         U = co / R.y - vec2( .5*R.x/R.y, - .075);\n    \n    float z =  1.8 * exp2(-fract(iTime/2.)),// zooming coordinates\n          h = H(U*=z), s = exp2(h), u,v,d;  // truchet LOD h and scale s\n    \n    F = fract(U*s);                         // local coords in truchet tile    \n    v = rand( U*s, h ) -.5;                 // 2 rands per tile: sign,abs\n\n    if( v < 0.) F = vec2( 1.-F.y, F.x );    // < 0 : rotate 90Â°\n    v = abs(v);                             // [0,.5]\n    d =  v > .4                             // 20% luck:\n           ? min(  abs( length(F)    - .5 ),// round parts at one of the 2 ends\n                   abs( length(F-1.) - .5 )\n                ) -1./6. \n       : v > .1                             // 60% luck:\n           ? min(       abs(F.y-.5)  -1./6.,// segment parts\n                  max(  abs(F.x-.5) - 1./6.,// crossing ?\n                      -(abs(F.y-.5) - 1./4.) \n                )    )\n       :     min( abs( F.y = abs(F.y-.5) ), // 20% luck:\n                  length( F-.5 )            // semi-round parts ?\n                ) - 1./6.;\n   \td /= s;        \n    \n    for(float c,i=h; i < 6.; i++, s*=2., d=-d) {  // draw all LOD >= h\n        F = round(U*s)/s;                   // local tile id\n        vec2 e = vec2(-1,1)/64.;            // ( any small value ? )\n        c = max( max( H( F + e.xx),         // seek deepest LOD \"around\"\n                      H( F + e.yx)),\n                 max( H( F + e.xy),\n                      H( F + e.yy)) );\n        if( i < c )                         // if less deep,\n            u = length(U - F) - 1./6./s,    // draw disk (?) \n            d = min( d, u );                // ( not sure why we continue )\n    }\n    int(iTime/2.) % 2 >0 ? d = -d : d;      // for cycling continuity, alternate BW\n    O = vec4( .5+.5* d*R.y/z );             // paint with AA\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdBBW3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdBBzd", "name": "Lightning corrosion gravity", "author": "TAKUSAKU", "description": "Lightning corrosion gravity", "tags": ["sphere", "lightning", "corrosion", "gravity"], "likes": 8, "viewed": 194, "date": "1590577878", "time_retrieved": "2024-06-20T20:07:51.535032", "image_code": "// noise background is baced on æææ°VIP:\n// https://www.shadertoy.com/view/4sVBDm\nconst float noiseIntensity = 2.8;\nconst float noiseDefinition = 0.6;\nconst vec2 glowPos = vec2(-2., 0.);\n\nfloat random(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(-0.950,-0.910))) * 43758.5453);\n}\n\nfloat noise( in vec2 p ){\n    p*=noiseIntensity;\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\tvec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( random( i + vec2(0.0,0.0) ), \n                     random( i + vec2(1.0,0.0) ), u.x),\n                mix( random( i + vec2(0.0,1.0) ), \n                     random( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat fbm( in vec2 uv ){\t\n\tuv *= 5.0;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    float f  = 0.5*noise( uv ); uv = m*uv;\n    f += 5.*noise( uv ); uv = m*uv;\n    f += 5.*noise( uv ); uv = m*uv;    \n\tf = 0.1 + .5*f;\n    return f;\n}\n\nvec3 bg(vec2 uv ){\n    float velocity = iTime * 0.5;\n    float intensity = sin(uv.x*noise(uv)*7.+velocity*3.)*noise(uv*10.)*1.0+.3;\n    uv.y -= 2.;\n    vec2 bp = uv+glowPos;\n    uv *= noiseDefinition;\n\n    //ripple\n    float rb = fbm(vec2(uv.x*.5-velocity*.03, uv.y))*.1;\n    uv += rb;\n\n    //coloring\n    float rz = fbm(uv*.9+vec2(velocity*.35, 0.0));\n    rz *= dot(bp*intensity,bp);\n\n    //bazooca line\n    rz *= sin(uv.x*0.1+velocity*0.8);\n\n    //lightning\n    rz *= 5.*sin(uv.x*0.1+velocity*sin(iTime*100.));\n    \n    vec3 bgColor = vec3(cos(iTime),  sin(iTime*0.2), sin(iTime*0.3));\n    vec3 col = bgColor/(.1-rz);\n    return sqrt(abs(col));\n}\n\n// 2D rotate\nmat2 rotate(in float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Wide-angle lens is baced on Menger Sponge Variation\n    // https://www.shadertoy.com/view/ldyGWm\n    vec3 st = (vec3(2.0 * fragCoord.xy - iResolution.xy, iResolution.y));\n    st = normalize(vec3(st.xy, sqrt(max(st.z * st.z - dot(st.xy, st.xy) *4.*sin(iTime*0.4),0.))));\n    \n    st.xy *= rotate(iTime*0.5);\n  \n    vec3 bgCol = bg(st.xy)*(1.9-abs(st.y*2.));\n       \n\tfragColor = vec4(bgCol, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdBBzd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdBBzh", "name": "Dancelbrot", "author": "ReesHerbert", "description": "Mandelbrot but it dances", "tags": ["generative"], "likes": 1, "viewed": 60, "date": "1589496968", "time_retrieved": "2024-06-20T20:07:51.535032", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat speed = 100.0;\n    float zoom = 0.1 * (1.0 - mod(iTime, speed)/speed);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 originaluv = uv;\n    \n    uv -= 0.56 * mod(iTime, speed);\n    uv /= mod(iTime, speed);\n    \n    float xshifted = (uv.x - 0.5) * 512.0;\n    \n    float colorshift = texelFetch(iChannel0, ivec2(uv.x,0), 0).x;\n    \n    float startx = colorshift * zoom + mod(iTime, 10.0)/100.0;\n    \n    vec2 z = vec2(startx, -startx);\n    \n    float count = 0.0;\n    \n    for(int i = 0; i < 512; i++)\n    {\n        z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + uv;\n        if(dot(z,z) > 1024.0){break;}\n        count += 1.0;\n    }\n    \n    float countF = float(count);\n    \n    float color = countF / 512.0;\n    color = 1.0 - color;\n    \n    vec3 texColor = texelFetch(iChannel1,ivec2(originaluv.x, originaluv.y), 0).rgb;\n    \n    fragColor = vec4(vec3(colorshift* sin(iTime), color/2.0, 1.0 - colorshift/2.0) + texColor, (1.0));\n  \n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdBBzh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdBfDc", "name": "Rainbow Fractal Galaxy", "author": "jarble", "description": "This galaxy is full of fractal-patterned objects.\n\nClick and drag the mouse to look around!", "tags": ["3d", "raymarching", "fractal", "galaxy"], "likes": 0, "viewed": 230, "date": "1590949209", "time_retrieved": "2024-06-20T20:07:52.650351", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.0001;\n\nvec3 surface_color(in vec3 uv)\n{\n   uv /=  3.0;\n    float lar;\n\n    for (float i=0.0; i < 5.0; i++)\n    {\n        lar = length(vec2(uv.x, uv.y));\n        uv.x = uv.y + sin(uv.x-(uv.z+uv.y))+(uv.x);\n        uv.y = uv.x + sin(uv.y-(uv.z+uv.x))-(uv.y);\n    }\n    return cos(vec3(lar * 2.0, lar * 3.0, lar * 1.0));\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 p) {\n    float py1 = p.y;\n    float px1 = p.x;\n    float pz1 = p.z;\n    p.x += (sin(py1/100.0)+cos(pz1/100.0))*100.0;\n    p.y += cos(sin(pz1/100.0)+cos(px1/100.0))*100.0;\n    p.z += sin(sin(px1/100.0)+cos(py1/100.0))*100.0;\n    //p *= (sin((p.x+p.y+p.z)/1000.0))+1.5;\n    //p += (sin(p.x*5.0)*cos(p.y*5.0)+cos(p.z*5.0))/(6.0+sin(length(p*2.0)/2.0));\n    return  3.9 +sin(length(p*10.0)/10.0) + sin(p.x/5.0)+cos(p.y/5.0)+cos(p.z/5.0);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n         if (length(iMouse.xy) > 40.0) {\n            viewDir.yz *= rot(iMouse.y/iResolution.y*3.14-3.14*0.5);\n            viewDir.xz *= rot(iMouse.x/iResolution.x*3.14*2.0-3.14);\n        }\n    \n    vec3 eye = vec3(sin(iTime/5.0), cos(iTime/5.0), -iTime)*50.0;\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * -viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdBfDc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdBfDK", "name": "Mandelbrot with \"smart\" AA", "author": "mrange", "description": "Licence CC0: Nothing special, just a mandelbrot with orbit traps, experimenting with \"smart\" AA", "tags": ["2d", "mandelbrot", "aa"], "likes": 9, "viewed": 328, "date": "1590827507", "time_retrieved": "2024-06-20T20:07:52.656420", "image_code": "\n#define MANDELBROT_ZOOM_START 0.0\n#define MANDELBROT_ITER       240\n\nvoid pR(inout vec2 p, in float a) { \n  p = cos(a)*p + sin(a)*vec2(p.y, -p.x);    \n}\n\nvec2 pMod2(inout vec2 p, in vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n\nvec3 mandelbrot(float time, vec2 p, out float ii) {\n  vec3 col = vec3(0.0);\n\n  float ztime = (time - MANDELBROT_ZOOM_START)*step(MANDELBROT_ZOOM_START, time);\n\n  float zoo = 0.64 + 0.36*cos(.07*ztime);\n  float coa = cos(0.15*(1.0-zoo)*ztime);\n  float sia = sin(0.15*(1.0-zoo)*ztime);\n  zoo = pow(zoo,8.0);\n  vec2 xy = vec2( p.x*coa-p.y*sia, p.x*sia+p.y*coa);\n  vec2 c = vec2(-.745,.186) + xy*zoo;\n\n  const float B = 10.0;\n  float l = 0.0;\n  vec2 z  = vec2(0.0);\n\n  vec2 zc = vec2(1.0);\n  \n  pR(zc, ztime);\n\n  float d = 1e20;\n  \n  int i = 0;\n        \n  for(int j = 0; j < MANDELBROT_ITER; ++j) {\n// \"Furry\" mandelbrot\n//    const float ss = 0.125*1.13125;\n//    const float ss = sqrt(1.99)/10.0;\n//    z = tanh(ss*z)/ss;\n    float re2 = z.x*z.x;\n    float im2 = z.y*z.y;\n    float reim= z.x*z.y;\n        \n    if(re2 + im2 > (B*B)) break;\n\n    z = vec2(re2 - im2, 2.0*reim) + c;\n\n    vec2 zm = z;\n    vec2 n = pMod2(zm, vec2(4));\n    vec2 pp = zm - zc;\n    float dd = dot(pp, pp);\n\n    d = min(d, dd);\n\n    l += 1.0;\n    \n    i = j;\n  }\n\n  ii = float(i)/float(MANDELBROT_ITER);\n  \n  float sl = l - log2(log2(dot(z,z))) + 4.0; \n\n  vec3 dc = vec3(pow(max(1.0 - d, 0.0), 20.0));\n  vec3 gc = 0.5 + 0.5*cos(3.0 + sl*0.15 + vec3(0.1,0.5,0.9));\n  return gc + dc*smoothstep(28.8, 29.0, ztime);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float s = 2.0/iResolution.y;\n\n  vec2 o1 = vec2(1.0/8.0, 3.0/8.0)*s;\n  vec2 o2 = vec2(-3.0/8.0, 1.0/8.0)*s;\n\n  vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n  float ii = 0.0;\n  vec3 col = mandelbrot(iTime, p+o1, ii);\n\n  // \"smart\" AA? Is that a good idea?  \n  vec2 dii2 = vec2(dFdx(ii), dFdy(ii));\n  float dii = length(dii2);\n  \n  if(abs(dii) > 0.01) {\n    col += mandelbrot(iTime, p-o1, ii);\n    col += mandelbrot(iTime, p+o2, ii);\n    col += mandelbrot(iTime, p-o2, ii);\n    col *=0.25;\n//    col = vec3(1.0, 0.0, 0.0);\n  }\n\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdBfDK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdBfRd", "name": "Rings and Lines", "author": "Tezza48", "description": "Made for my website background.", "tags": ["rings", "lines", "voronoise"], "likes": 1, "viewed": 211, "date": "1590601914", "time_retrieved": "2024-06-20T20:07:53.032242", "image_code": "// Remove for just the noise\n#define SWEEP\n\n// Hash without Sine 2 - https://www.shadertoy.com/view/XdGfRR\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 / float(0xffffffffU))\n\nvec2 hash22(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p))*UI2;\n\tq = (q.x ^ q.y) * UI2;\n\treturn vec2(q) * UIF;\n}\n\nvec3 hash33(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn vec3(q) * UIF;\n}\n\n// -\t-\t-\t-\t-\t-\t-\t-\n\nfloat calcVoro31(vec3 p)\n{\n    vec3 cellPos = fract(p);\n    vec3 cellId = floor(p);\n    \n    float len = 2.0;\n    \n    for (int z = -1; z < 2; z++)\n    for (int y = -1; y < 2; y++)\n    for (int x = -1; x < 2; x++)\n    {\n        vec3 offs = vec3(x, y, z);\n        len = min(len, length(cellPos + offs - hash33(cellId - offs)));\n    }\n    \n    return len;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    float timeScale = 20.0f;\n    \n    vec3 p = vec3(uv, iTime / timeScale);\n    \n    float res;\n    float voro = calcVoro31(p * 3.0);\n    \n    res += voro;\n    \n    //res = cla(res, 0.3);\n    res *= 2.0;\n    \n    res = abs(res - 0.4);   \n    \n    res = smoothstep(0.02, 0.025, res);\n    \n    col.rgb = mix(vec3(0.9, 0.9, 0.9), vec3(0.2, 0.4, 0.6),res);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdBfRd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdBfRK", "name": "ShATI - AmitiÃ©", "author": "Flopine", "description": "My former school named ATI decided to launch an everyday challenge from 4th may to 24th may, here is the 19th subject: friendship :)", "tags": ["2d", "animation", "rainbow", "xor"], "likes": 8, "viewed": 135, "date": "1590359083", "time_retrieved": "2024-06-20T20:07:53.480629", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n// Shader made for Everyday ATI challenge\n\n#define PI acos(-1.)\n#define TAU 6.2831853071\n#define time(offset) fract((iTime+offset)*0.1)\n#define AAstep(thre, val) smoothstep(-.7,.7,(val-thre)/min(.05,fwidth(val-thre)))\n#define circle(s,pix) AAstep(s,length(pix))\n#define square(s,pix) AAstep(s,max(abs(pix.x),abs(pix.y)))\n\n\n// taken from YX here : https://www.shadertoy.com/view/tdlXW4\n// rough shadertoy approximation of the bonzomatic noise texture\nvec4 texNoise(vec2 uv)\n{\n    float f = 0.;\n    f += texture(iChannel0, uv*.125).r*.5;\n    f += texture(iChannel0, uv*.25).r*.25;\n    f += texture(iChannel0, uv*.5).r*.125;\n    f += texture(iChannel0, uv*1.).r*.125;\n    f=pow(f,1.2);\n    return vec4(f*.45+.05);\n}\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat xor (float a, float b)\n{return (1.-b)*a + (1.-a)*b;}\n\nvec3 palette (float t, vec3 c)\n{return vec3(.5)+vec3(.5)*cos(TAU*(c*t+vec3(.0,.37,.63)));}\n\nvec3 background (vec2 uv)\n{\n    uv *= rot(sin(length(uv*1.5)+time(0.)*TAU));\n    uv += texNoise(uv+smoothstep(0.1,0.25,abs(sin(length(uv)-iTime)-1.))).r*0.5-0.1;\n    float mask = circle(sqrt(sin((time(5.))*TAU)*2.),length(uv));\n    float spread = atan(uv.y,uv.x);\n    return palette(spread, vec3(TAU/8.))*(1.-mask);\n}\n\nvec3 dancing_shapes (vec2 uv)\n{\n    float size = 0.1;\n    float spread = pow(clamp(sin(time(0.)*TAU)*0.2,0.,1.),0.35);\n    vec2 puv = uv;\n    uv *= rot(time(0.)*TAU*1.2);\n\n    vec2 uc = vec2(uv.x - spread,uv.y);\n    vec2 us = vec2(uv.x + spread, uv.y);\n    us *= rot(time(0.)*PI);\n    \n    float cir = circle(size,uc);\n    float squ = square(size,us);\n    float mask = xor(cir,1.-squ);\n    \n    vec3 color = (spread<=0.0001) ? background(puv)*squ+(1.-mask) : vec3(mask); \n    return color;\n}\n\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n    vec3 col = vec3(dancing_shapes(uv));\n    fragColor = vec4(sqrt(col),1.);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdBfRK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdBfRy", "name": "Raymarching surface coloring", "author": "rodgzilla", "description": "Very glitchy but I kinda like the effect.", "tags": ["coloring"], "likes": 2, "viewed": 312, "date": "1590269676", "time_retrieved": "2024-06-20T20:07:53.486473", "image_code": "#define time iTime\n\n// #define SPEED 15.\n#define SPEED 15.\n#define FLOOR 0\n#define SPH 1\n#define CAP 2\n#define EXTR 3\n#define INF 4\n\nint hit = FLOOR;\n\nmat2 rot2d(float a) {\n    float c = cos(a), s = sin(a);\n    \n    return mat2(c, s, -s, c);\n}\n\nvec3 kifs(vec3 p) {\n    float r = .7;\n    float s = 2.;\n\n    for (float i = 0.; i < 4.; i++) {\n        p.xy *= rot2d(time * .7);\n        p.yz *= rot2d(time * .5 - i);\n        p = abs(p);\n        p -= s;\n        s *= r;\n    }\n    \n    return p;\n}\n\nfloat sph(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat tube(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b - a;\n\tvec3 ap = p - a;\n\tfloat t = dot(ab, ap) / dot(ab, ab);\n\tvec3 c = a + ab * t;\n  \n\treturn length(p - c) - r;\n}\n\nfloat cap(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b - a;\n\tvec3 ap = p - a;\n\tfloat t = dot(ab, ap) / dot(ab, ab);\n\tt = clamp(t, 0., 1.);\n\tvec3 c = a + ab * t;\n  \n\treturn length(p - c) - r;\n}\n\n\nvec3 rep(vec3 p, vec3 r) {\n    return mod(p, r) - .5 * r;\n}\n\nfloat map(vec3 p) {\n    p.xy *= rot2d(p.z / 70.);\n//    p = rep(p, vec3(0., 0, 100.));\n    p = rep(p, vec3(0., 0, 40.));\n    vec3 pkifs = kifs(p);\n    float d = 5000.;\n    \n    hit = FLOOR;\n  \tfloat dsph = sph(pkifs - vec3(2, 0, 0), 1.);\n    d = min(d, dsph);\n    hit = (d == dsph) ? SPH : hit;\n    float dtube = tube(pkifs, vec3(0, 1, 0), vec3(2, 1, 0), .5);\n    d = min(d, dtube);\n    hit = (d == dtube) ? CAP : hit;\n    float dextr = -tube(p, vec3(0, 0, -1), vec3(0, 0, 0), 2.);\n    d = max(d, dextr);\n    hit = (d == dextr) ? EXTR : hit;\n    \n    return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    vec3 col = vec3(0);\n\n    vec3 ro = vec3(0, 0, -30. + time * SPEED);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n\n    vec3 p = ro;\n    float d = 0.;\n    for (int i = 0; i < 100; i++) {\n\t\tfloat ds = map(p);\n        \n        if (ds < .01 || ds > 100.) {\n            break;\n        }\n        if (ds > 100.) {\n            hit = INF;\n        }\n        p += .7 * ds * rd;\n    }\n    \n    col = vec3(length(p - ro) * .1);\n    vec2 e = vec2(0.01, 0);\n    \n    vec3 n = normalize(map(p) - vec3(\n        map(p - e.xyy),\n        map(p - e.yxy),\n        map(p - e.yyx)\n\t));\n    \n    vec3 lp = vec3(0, 0, -30. + time * SPEED);\n    float dif = dot(n, normalize(lp - p));\n    \n//    map(p);\n    col = vec3(0, 0, 1);\n    if (hit == SPH) {\n        col = vec3(0.306, 0.21 + .3 * (.5 * sin(3. * time) + 0.5), .43);\n    }\n    if (hit == CAP) {\n//        col = vec3(201. /255., 122. / 255., 30. / 255.);\n        col = vec3(1);\n    }\n    if (hit == EXTR) {\n//        255, 182, 71\n\t\tcol = vec3(255. / 255., 182. / 255., 71. / 255.);\n//        col = vec3(1., 0., 0.);\n    }\n    if (hit == INF) {\n        col = vec3(1);\n    }\n    col *= dif;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdBfRy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdBfW3", "name": "First Raymarch!", "author": "PhilBurt", "description": "This is the first raymarch I have ever done! Super exited! Learned from the Art of Code.", "tags": ["raymarching"], "likes": 3, "viewed": 59, "date": "1590930538", "time_retrieved": "2024-06-20T20:07:53.486732", "image_code": "\n#define MAXSTEPS 100\n#define MAXDIST 100.\n#define SURFDIST .01\n\nfloat GetDist(vec3 p){\n\n\tvec4 s1 = vec4(0, 4, 19, 4);\n    vec4 s2 = vec4(10, 4.2, 10, 4.2);\n    vec4 s3 = vec4(-8, 5, 6, 5);\n    \n    float sphereDist1 = length(p - s1.xyz) - s1.w;\n    float sphereDist2 = length(p - s2.xyz) - s2.w;\n    float sphereDist3 = length(p - s3.xyz) - s3.w;\n    float planeDist = p.y;\n    \n    float d = min(min(min(sphereDist1, planeDist), sphereDist2), sphereDist3);\n    return d;\n\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd){\n\n\tfloat dO = 0.;\n        \n        for(int i = 0; i < MAXSTEPS; i++){\n        \n        \tvec3 p = ro + rd * dO;\n            float dS = GetDist(p);\n            dO += dS;\n            if(dO > MAXDIST || dS < SURFDIST){\n            \n            \t\n            \n            }\n        \n        }\n        \n\treturn dO;\n\n}\n\n\nvec3 GetNormal(vec3 p){\n\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n    \tGetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n\t\n    return normalize(n);\n    \n}\n\nfloat GetLight(vec3 p){\n\n\tvec3 lightPos = vec3(0, 1, 6);\n    \n    lightPos.xz += vec2(sin(iTime), cos(iTime)) * 2.;\n    \n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n\n    float dif = clamp(dot(n, l), 0., 1.);\n    \n    float d = RayMarch(p+n*SURFDIST * 2., l);\n    if(d<length(lightPos - p )) dif *= .2;\n    \n    return dif;\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy) / iResolution.y;\n\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec3 ro = vec3(0, 1, 0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d;\n    \n    float dif = GetLight(p);\n    \n    col = vec3(dif);\n    \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdBfW3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdBfzc", "name": "Edge (metal and frosted glass)", "author": "TAKUSAKU", "description": "Edge (metal and frosted glass)", "tags": ["glass", "edge", "metal"], "likes": 7, "viewed": 192, "date": "1590490289", "time_retrieved": "2024-06-20T20:07:53.486732", "image_code": "float random (in vec2 _st) {\n    return fract(sin(dot(_st.xy, vec2(0.890,-0.900)))*757.153);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat fbm ( in vec2 _st) {\n    float v = sin(iTime*0.3)*0.1;\n    float a = 0.1;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(1.0), -sin(0.5), acos(0.5));\n    for (int i = 0; i < 3; ++i) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 2.6;\n    }\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = (2.*fragCoord-iResolution.xy)/min(iResolution.x,iResolution.y)*0.1;\n       \n    vec3 color = vec3(0.);\n\n    vec2 q = vec2(0.);\n    q.x = fbm( st + 1.0);\n    q.y = fbm( st + vec2(-0.450,0.650));\n\n    vec2 r = vec2(0.);\n    r.x = fbm( st  + vec2(0.570,0.520)+ 0.02*iTime );\n    r.y = fbm( st  + vec2(0.340,-0.570)+ 0.05*iTime);\n    \n    for (float i = 0.0; i < 3.0; i++) {\n        r += 1.0 / abs(mod(st.xy, 0.035* i) * 10000.) * 1.;//Virtical line\n        r += 1.0 / abs(mod(st.y + st.x, 1.0 * i) * 10000.) * 1.;//Diagonal line\n    }\n    \n    color = mix(vec3(0.730,0.513,0.302), vec3(0.397,0.576,0.667), sin(iTime*0.2));\n    \n    float f = mix(fbm(st+r),fbm(st+r*0.15),step(0.,st.x+st.y));//left metal, right glass\n    \n    color = 2.0*(f*f*f+.6*f*f+.5*f)*color;\n    \n    fragColor = vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdBfzc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdBfzd", "name": "3D details distrib on surface", "author": "FabriceNeyret2", "description": "(camera follow mouse).\n#56: flag for detail free 3D orientation or normal + free surface orientation\nflags SHADED , FOG\nWIP. slow and dirty for now.", "tags": ["procedural", "noise", "hypertexture", "trabeculum", "mm"], "likes": 6, "viewed": 363, "date": "1590614411", "time_retrieved": "2024-06-20T20:07:54.438199", "image_code": "// started from \"hypertexture-trabeculum\" by FabriceNeyret2. https://shadertoy.com/view/ltj3Dc\n\n#define SHADED 1      // 1: fast light-dir shading. 0: stepCount pseudo-shading\n#define FOG 0         // activate fog\nbool geoMode = true;  // details 3D free (true) or 2D constrained (false)\n                      // space to toggle.\nconst float skyTrsp = .1;\nconst vec3 skyColor = vec3(.7,.8,1),\n           sunColor = vec3(1,.7,.1) *10.,   \n           lightDir = vec3(.94,.24,.24), // normalize(vec3(.8,.2,-.2));\n           ambient  = vec3(.2), \n           diffuse  = vec3(.8);\n\n// --- utils\n#define keyToggle(a) ( texelFetch(iChannel3,ivec2(a,2),0).x > 0.)\n#define hue(v)       ( .6 + .6 * cos( 6.3*(v)  + vec3(0,23,21)  ) ) // https://www.shadertoy.com/view/ll2cDc\n#define hash13(n)     fract(sin(n+vec3(0.,12.345,124))*43758.5453)\n#define hash33(n)     hash13(dot(n,vec3(1,13.1,107.7)))\n#define rot(a)        mat2(cos(a),-sin(a),sin(a),cos(a))\n\nmat3 rot3D(vec3 A, float a) {\n    A = normalize(A);\n    float s = sin(a), c = cos(a), C = 1. - c;\n /* return mat3(C* A.x*A.x + c,        C* A.x*A.y - A.z * s,  C* A.z*A.x + A.y * s,\n                C* A.x*A.y + A.z * s,  C* A.y*A.y + c,        C* A.y*A.z - A.x * s,\n                C* A.z*A.x - A.y * s,  C* A.y*A.z + A.x * s,  C* A.z*A.z + c    );\n */ return mat3(c) +  C*outerProduct(A,A) +  mat3(  0  ,-s*A.z, s*A.y,\n                                                  s*A.z,  0   ,-s*A.x,\n                                                 -s*A.y, s*A.x,  0   );\n}                                           // GLSL bug: can't factor s !\n\nfloat distrib( vec3 p, inout vec3 C, inout vec3 id) { // return dist; C=pos, id=detail 3D id\n    float d = 1e15;\n    vec3 ip = floor(p);\n    for (int k=0; k<27; k++) {                    // --- visit 3x3x3 neighborhood\n                vec3  p0 = ip + vec3(k%3,k/3%3,k/9) - 1., // cell id\n                       c = hash33(p0)+p0-p;       // vector-dist to cell sample\n                float d0 = dot(c,c);              // distÂ²\n                if  (d0<d) d=d0, C=c+p, id = p0;  // keep closest sample info\n            }\n    return sqrt(d);\n}\n\nfloat rad = .5,  // macro sphere radius\n     grid = 10., // grid density in each direction\n     size =.03;  // detail radius ( take care of using smaller Eps for hit and normals ) \n\n#if 0 // --- should be the correct one, but gives bad detail scattering\n\nfloat dist2scene(vec3 p, inout vec3 id) {\n    vec3 P=vec3(0); id=vec3(-2);     // for debug\n    float v = length(p) - rad+size,                    // distance to macro sphere\n          d = distrib(grid*p,P,id)/grid ;         // dist to detail center. P=center, id\n          P /= grid;\n // if (dot(p,p)/4. > size*size + rad*rad + size*rad) return v-2.*size;  // bounding sphere: save everything!  \n // if (v > 2.*size) return  v+2.*size;           // bounding sphere: save nothing :-(\n    if  ( abs(length(P)-rad+size)<2.*size ) \n    {\n        P = normalize(P)* rad;\n        vec3 a = p-P, h = hash33(id);                 // detail random rotation\n        if (geoMode)                                  // free 3D rot\n            a.yz *= rot(6.28*h.x), a.xy *= rot(6.28*h.z);\n        else                                          // 2D rot + align along N\n            a *= rot3D(vec3(P.y,-P.x,0),acos(normalize(P).z)),\n            a.xy *= rot(6.28*h.z);\n\n        a = abs(a); d = max(a.x,max(a.y,a.z)) - size; // distance to detail = cube\n\n        if (  d < v ) v = d;                          // we hit a detail\n        else id = vec3(-1);                           // we hit nothing or the surface\n    } //else id=vec3(-1);  \n    float bg = .85-length(p);                     // background sphere\n    if (bg < v ) v = bg, id = vec3(-2);           // we missed the object: id = sky.\n    return v;\n}\n\n#else // --- temporary one with better scattered details... not really on the surface\n\nfloat dist2scene(vec3 p, inout vec3 id) {\n    vec3 P=vec3(0); id=vec3(-2);     // for debug\n    float v = length(p) - rad,                    // distance to macro sphere\n          d = distrib(grid*p,P,id)/grid ;         // dist to detail center. P=center, id\n          P /= grid;\n // if (dot(p,p)/4. > size*size + rad*rad + size*rad) return v-2.*size;  // bounding sphere: save everything!  \n // if (v > 2.*size) return  v+2.*size;           // bounding sphere: save nothing :-(\n                                                  // put detail on surface\n    if  ( abs(length(P)-rad-size)<size ) P = normalize(P)*(rad-size); // [ why -size ? ]\n    vec3 a = p-P, h = hash33(id);                 // detail random rotation\n    if (geoMode)                                  // free 3D rot\n        a.yz *= rot(6.28*h.x), a.xy *= rot(6.28*h.z);\n    else                                          // 2D rot + align along N\n        a *= rot3D(vec3(P.y,-P.x,0),acos(normalize(P).z)),\n        a.xy *= rot(6.28*h.z);\n\n    a = abs(a); d = max(a.x,max(a.y,a.z)) - size; // distance to detail = cube\n    \n    v += 2.*size;           // [ why can't I put all below or around rad ? ]\n    if ( length(P) < rad && d < v ) v = d;        // we hit a detail\n    else id = vec3(-1);                           // we hit nothing or the surface\n    \n    float bg = .85-length(p);                     // background sphere\n    if (bg < v ) v = bg, id = vec3(-2);           // we missed the object: id = sky.\n    return v;\n}\n\n#endif\n\nvec3 calcNormal(vec3 p) { // taken here https://www.shadertoy.com/view/3sBBWy\n  vec3 n = vec3(0), id;\n  for(int i = 0; i < 4; i++){\n      vec3 e = .001*( vec3(9>>i&1, i>>1&1, i&1) *2.-1. );\n      n += e * dist2scene(p+e, id);\n  }\n  return normalize(n);\n}\n\n#define NORM 2    // 0 : full DF normal 1: centered directional 2: even cheaper\nfloat shadedNormal( vec3 p, float v ) {\n    float epsL = .005, dx; vec3 id;               // use smaller eps for contrast\n#if NORM == 0\n    dx =  dot(calcNormal(p),lightDir);            // true Lambert with full DF normal\n#elif NORM == 1                                   // centered directional derivative\n// Cheap computation of normals+Lambert using directional derivative (see https://www.shadertoy.com/view/Xl23Wy )\n// still, we need an estimate of slope amplitude to avoid artifacts (see grad+scale).\n    dx = ( dist2scene(p+epsL*lightDir, id)\n          -dist2scene(p-epsL*lightDir, id)) / (2.*epsL);\n#else                                             // cheap directional derivative\n    dx = (dist2scene(p+epsL*lightDir, id)-v)/epsL;\n#endif\n    return clamp(dx, 0.,1.);                      // approx Lambert shading    \n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         q = ( 2.*u - R ) / R.y,\n         M = iMouse.xy / R;\n    if ( M==vec2(0)) M=vec2(.5);\n    geoMode = !keyToggle(32);\n    \n    // --- set camera\n    float theta = -( M.x - .5 ) *6.28,\n            phi = -( M.y - .5 ) *3.14;\n#if 1 // camera shake \n    float t=10.*iTime,B=.02;   theta += B*cos(t); phi += B*sin(t);\n#endif\n    vec3 cameraPos = vec3(sin(theta)*cos(phi),sin(phi),cos(theta)*cos(phi)),   \n      cameraTarget = vec3(0),\n         W = normalize( cameraPos - cameraTarget ),\n         U = normalize(cross( vec3(0,1,0), W )),\n         V = cross(W,U),\n    rayDir = normalize( q.x*U + q.y*V -1.5*W );\n  \n    // --- ray-trace volume\n    float l = .5, d,\n        transp = 1.;\n    vec3 col = vec3(0),\n           p = cameraPos+l*rayDir, p_=p, \n          id = vec3(-2);                      // default = sky\n    \n    float i=0.;\n    for (; i<200.; i++) {                     // ray-march\n        d = dist2scene(p, id); \n        if (id==vec3(-2)) break;              // early exit if sky\n        if (d < .003)     break;              // \"hit\" on an object\n        p += .3*d*rayDir;\n    }\n // O = i/vec4(200,50,12,1); return;          // test: hitmap of iterations\n    \n    // --- shading\n    if ( d < .01 && id != vec3(-2) ) {        // hit\n#if FOG \n\t    float fog = pow(skyTrsp,length(p_-p)); p_=p;\n        col += transp*skyColor*(1.-fog);\n    \ttransp *= fog; \n#endif            \n        vec3 c = id != vec3(-1) \n                  ? .2*hue( hash33(id).x )    // detail color\n                  : ambient;                  // other surface: ambiant\n#if SHADED          \n        c += diffuse* shadedNormal(p,d);      // shading\n#else\n        c += diffuse* (1.-i/40.);             // pseudo-shading\n#endif\n \t    col += transp*c; transp = 0.;\n      }\n      \n   O = vec4(col+ transp*skyColor, 1.);\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdBfzd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdBfzV", "name": "Ray Tracer Lesson 1", "author": "omegasbk", "description": "Shader made for lesson two of Darko's Gamedev Cookbook series on youtube.\nChannel: https://www.youtube.com/channel/UCEB2BQkJs_9tH6DE0dM5kqA", "tags": ["raytracerlesson1"], "likes": 0, "viewed": 260, "date": "1590596892", "time_retrieved": "2024-06-20T20:07:54.444382", "image_code": "// Created by Darko (omegasbk) \n//\n// Darko's Gamedev Cookbok Youtube serial\n// https://www.youtube.com/channel/UCEB2BQkJs_9tH6DE0dM5kqA\n//\n// Lesson 1 - Rendering a Sphere\n\nstruct Camera \n{\n    vec3 position;\n    vec3 direction;\n    float zoom; \n} camera;\n\nstruct Sphere\n{\n    vec3 position;\n    float radius;     \n} sphere;\n\nvoid setupScene()\n{\n    camera.position = vec3(0., 0., 3.5);\n    camera.direction = vec3(0., 0., -1.);\n    camera.zoom = 1.0;\n    \n    sphere.position = vec3(0., 0., 0.);\n    sphere.radius = 0.3;\n}\n\nbool solveQuadratic(float a, float b, float c, out float t0, out float t1)\n{\n    float disc = b * b - 4. * a * c;\n    \n    if (disc < 0.)\n    {\n        return false;\n    } \n    \n    if (disc == 0.)\n    {\n        t0 = t1 = -b / (2. * a);\n        return true;\n    }\n    \n    t0 = (-b + sqrt(disc)) / (2. * a);\n    t1 = (-b - sqrt(disc)) / (2. * a);\n    return true;    \n}\n\nbool intersect(vec3 direction, out float refl)\n{\n    vec3 L = camera.position - sphere.position;\n    \n    float a = dot(direction, direction);\n    float b = 2. * dot(direction, L);\n    float c = dot(L, L) - pow(sphere.radius, 2.);\n    \n    float t0;\n    float t1;\n    \n    if (solveQuadratic(a, b, c, t0, t1))\n    {\n        float t = t0;\n        if (t1 < t0)\n        {\n            t = t1;\n        }\n        \n        vec3 Phit = camera.position + t * direction;\n        vec3 surfaceNormal = normalize(Phit - sphere.position);\n        \n        refl = -dot(direction, surfaceNormal);\n                \n        return true;\n    }  \n     \n    return false;\n}\n\nvec3 rayTrace(vec3 direction)\n{\n    float refl = 1.;\n    if (intersect(direction, refl))\n    {\n        return refl * vec3(0.9, 0.2, 0.3);\n    }\n    \n    return vec3(0., 0., 0.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{        \n    setupScene();\n    \n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x *= (iResolution.x / iResolution.y); \n    \n    vec3 direction = normalize(vec3(uv, camera.zoom) - camera.position);\n    \n    sphere.position.y = sin(iTime * 6.) / 3.;\n    \n    vec3 col = rayTrace(direction);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdBfzV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdfBD7", "name": "Pencil Sketches", "author": "samhattangady", "description": "Trying to replicate a hand-drawn aesthetic.", "tags": ["handdrawn"], "likes": 7, "viewed": 376, "date": "1588330496", "time_retrieved": "2024-06-20T20:07:54.444382", "image_code": "\n/*\n * 01 May 2020\n * Wanted to try to see if I could replicate some kind of hand drawn aesthetic\n * It looks alright. Definitely doesn't look hand drawn though. Maybe need to\n * make the lines not straight. But it's alright\n */\n\nfloat PI = 3.14159;\n\nvec3 paper_colour = vec3(0.9, 0.9, 0.85);\nvec3 pencil_colour = vec3(0.3, 0.3, 0.40);\nfloat line_thickness = 1.7;\nfloat line_variation = 3.0508;\nfloat line_smoothness = 0.5;\n\nfloat rand(vec2 c) {\n\treturn fract(sin(dot(c.xy ,vec2(12.868,781.233))) * 4378.5453);\n}\n\nfloat noise(vec2 p, float freq ){\n\tfloat unit = iResolution.x/freq;\n\tvec2 ij = floor(p/unit);\n\tvec2 xy = mod(p,unit)/unit;\n\t//xy = 3.*xy*xy-2.*xy*xy*xy;\n\txy = .5*(1.-cos(PI*xy));\n\tfloat a = rand((ij+vec2(0.,0.)));\n\tfloat b = rand((ij+vec2(1.,0.)));\n\tfloat c = rand((ij+vec2(0.,1.)));\n\tfloat d = rand((ij+vec2(1.,1.)));\n\tfloat x1 = mix(a, b, xy.x);\n\tfloat x2 = mix(c, d, xy.x);\n\treturn mix(x1, x2, xy.y);\n}\n\nfloat pNoise(vec2 p, int res){\n\tfloat persistance = .5;\n\tfloat n = 0.;\n\tfloat normK = 0.;\n\tfloat f = 30.3;\n\tfloat amp = 1.;\n\tint iCount = 0;\n\tfor (int i = 0; i<50; i++){\n\t\tn+=amp*noise(p, f);\n\t\tf*=2.;\n\t\tnormK+=amp;\n\t\tamp*=persistance;\n\t\tif (iCount == res) break;\n\t\tiCount++;\n\t}\n\tfloat nf = n/normK;\n\treturn nf*nf*nf*nf;\n}\n\nfloat get_noise(vec2 p) {\n    float noise = pNoise(p, 3);\n    noise *= 2.0;\n    // noise -= 0.5;\n    return noise;\n}\n\nfloat rectangle(vec2 samplePosition, vec2 halfSize){\n    vec2 componentWiseEdgeDistance = abs(samplePosition) - halfSize;\n    float outsideDistance = length(max(componentWiseEdgeDistance, 0.0));\n    float insideDistance = min(max(componentWiseEdgeDistance.x, componentWiseEdgeDistance.y), 0.0);\n    return outsideDistance + insideDistance;\n}\n\nvec3 draw_line(vec2 p, vec2 p1, vec2 p2, vec3 current_colour) {\n    float d;\n    float l_sq = pow(distance(p1, p2), 2.0);\n    if (l_sq == 0.0)\n        d = distance(p, p1);\n    else {\n        float t = max(0.0, min(1.0, dot(p - p1, p2 - p1) / l_sq));\n        vec2 projection = p1 + t * (p2 - p1);  // Projection falls on the segment\n        d = distance(p, projection);\n    }\n    float noise;\n    // TODO (01 May 2020 sam): Figure out how to to better line check\n    if (p1.y<p.y) noise = get_noise(p.yx);\n    else noise = get_noise(p);\n    d += noise*line_variation;\n    float pencil = smoothstep(line_thickness, line_thickness+line_smoothness, d);\n    return mix(pencil_colour, current_colour, pencil);\n}\n\nvec3 draw_box(vec2 p, vec2 p1, vec2 p3, vec3 current_colour) {\n    vec3 colour = current_colour;\n    vec2 p2 = vec2(p1.x, p3.y);\n    vec2 p4 = vec2(p3.x, p1.y);\n    vec2 box_center = (p1 + p3)/2.0;\n    float bd = rectangle(p-box_center, (p3-p1)/2.0);\n    float noise = get_noise(p);\n    noise *= 5.0;\n    if (bd-noise<0.0)\n        colour = paper_colour;\n    colour = draw_line(p, p1, p2, colour);\n    colour = draw_line(p, p2, p3, colour);\n    colour = draw_line(p, p3, p4, colour);\n    colour = draw_line(p, p4, p1, colour);\n    return colour;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 colour;\n    float WIDTH = iResolution.x;\n\tfloat HEIGHT = iResolution.y;\n\n    vec2 pos = fragCoord;\n    vec2 uv = pos/iResolution.xy;\n    pos.x += (tan(iTime)/100.0)*iResolution.x*20.0;\n    colour = paper_colour;\n    // horizon\n    colour = draw_line(pos, vec2(-50000.0, iResolution.y/3.0), vec2(iResolution.x*5000.0, iResolution.y/3.0), colour);\n    // pillars\n    colour = draw_box(pos, vec2(WIDTH*0.22, HEIGHT*0.41), vec2(WIDTH*0.26, HEIGHT*0.59), colour);\n    colour = draw_box(pos, vec2(WIDTH*0.30, HEIGHT*0.41), vec2(WIDTH*0.34, HEIGHT*0.59), colour);\n    colour = draw_box(pos, vec2(WIDTH*0.37, HEIGHT*0.41), vec2(WIDTH*0.41, HEIGHT*0.59), colour);\n    colour = draw_box(pos, vec2(WIDTH*0.44, HEIGHT*0.41), vec2(WIDTH*0.48, HEIGHT*0.59), colour);\n    colour = draw_box(pos, vec2(WIDTH*0.51, HEIGHT*0.41), vec2(WIDTH*0.55, HEIGHT*0.59), colour);\n    colour = draw_box(pos, vec2(WIDTH*0.59, HEIGHT*0.41), vec2(WIDTH*0.63, HEIGHT*0.59), colour);\n    colour = draw_box(pos, vec2(WIDTH*0.66, HEIGHT*0.41), vec2(WIDTH*0.70, HEIGHT*0.59), colour);\n    colour = draw_box(pos, vec2(WIDTH*0.74, HEIGHT*0.41), vec2(WIDTH*0.78, HEIGHT*0.59), colour);\n    // base\n    colour = draw_box(pos, vec2(WIDTH*0.2, HEIGHT*0.3), vec2(WIDTH*0.8, HEIGHT*0.4), colour);\n    colour = draw_box(pos, vec2(WIDTH*0.24, HEIGHT*0.32), vec2(WIDTH*0.76, HEIGHT*0.38), colour);\n    // roof\n    colour = draw_box(pos, vec2(WIDTH*0.2, HEIGHT*0.6), vec2(WIDTH*0.8, HEIGHT*0.66), colour);\n    colour = draw_line(pos, vec2(WIDTH*0.2, HEIGHT*0.68), vec2(WIDTH*0.5, HEIGHT*0.8), colour);\n    colour = draw_line(pos, vec2(WIDTH*0.8, HEIGHT*0.68), vec2(WIDTH*0.5, HEIGHT*0.8), colour);\n    colour = draw_line(pos, vec2(WIDTH*0.2, HEIGHT*0.68), vec2(WIDTH*0.8, HEIGHT*0.68), colour);\n    fragColor = vec4(colour, 1.0);\n    float c = get_noise(pos.yx);\n    // fragColor = vec4(vec3(c), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdfBD7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdfBDH", "name": "Mjolnir", "author": "ez21", "description": "If he be worthy...", "tags": ["raymarching", "noise", "lightning", "hammer", "thor"], "likes": 8, "viewed": 102, "date": "1589052981", "time_retrieved": "2024-06-20T20:07:57.844715", "image_code": "// The larger the DISTORTION, the smaller the glow\nconst float DISTORTION = 0.4;\n// The higher GLOW is, the smaller the glow of the subsurface scattering\nconst float GLOW = 2.0;\n// The higher the BSSRDF_SCALE, the brighter the scattered light\nconst float SCALE = 20.0;\n// Boost the shadowed areas in the subsurface glow with this\nconst float AMBIENT = 2.5;\n\n// ambient occlusion\nconst float KSTEP = 2.;\nconst float OCCDist = 0.085;\n\n// speed at which the ground flashes: higher = faster\nconst float SPEED = 4.;\n\n\n#define FLOOR_SDF plane(pos, vec3(0., 1.0, 0.), vec3(0., -2.5, 0.))\n#define HANDLE_SDF sdCappedCylinder(pos, vec3(-2.1, 5.95, 12.1), vec3(-0.25, -0.3, 8.5), 0.38)\n#define CAP_SDF sdCappedCylinder(pos, vec3(-2.25, 6.55, 12.25), vec3(-2.07, 5.85, 12.1), 0.5)\n#define SUN_SDF sphere(pos, 20.5, vec3(10., 0., 100.))\n\n#define HAMMER_SDF roundedBox(pos, vec3(3., 2., 3.), vec3(15., 0., 15.5), vec3(0., -1.3, 10.), 0.21)\n#define ATTACHLEFT_SDF roundedBox(pos, vec3(0.5, 1.4, 2.5), vec3(15., 0., 15.5), vec3(2.03, -0.77, 10.), 0.18)\n#define ONEATTACH_SDF smoothBlendSDF(pos, HAMMER_SDF, ATTACHLEFT_SDF, 0.35)\n#define ATTACHRIGHT_SDF roundedBox(pos, vec3(0.6, 1.4, 2.5), vec3(15., 0., 15.5), vec3(-2.05, -1.87, 10.), 0.18)\n#define MJOLNIR_SDF smoothBlendSDF(pos, ONEATTACH_SDF, ATTACHRIGHT_SDF, 0.3)\n\n#define RIBBON_SDF sdCappedTorus(pos + vec3(2.8 + cos(iTime * 3.) * 0.05, -6.35, -12.1 + cos(iTime * 3.) * 0.08), vec2(0.8,0.12), 1., 0.1)\n#define RIBBON2_SDF sdCappedTorus(pos + vec3(3. + cos(iTime * 3.) * 0.05, -6.85, -12.0 + cos(iTime * 3.) * 0.08), vec2(-0.8,0.12), 0.8, 0.1)\n#define STRING_SDF smoothBlendSDF(pos, RIBBON_SDF, RIBBON2_SDF, 0.2)\n\n#define FLOOR_ID 3\n#define HANDLE_ID 5\n#define SUN_ID 6\n#define MJOLNIR_ID 8\n#define STRING_ID 9\n#define CAP_ID 10\n\n\n\nconst float FOVY = (3.141569 * 2.) * 19.5 / 360.;\nconst int RAY_STEPS = 256;\n\nstruct Intersection {\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n    vec3 n;\n};\n    \n/********************************/\n/***** NOISE FUNCTIONS BEGIN*****/\n/********************************/\n\nvec3 random3(vec3 p) {\n    return fract(sin(vec3(dot(p, vec3(127.1, 311.7, 191.999)),\n                          dot(p, vec3(269.5, 183.3, 765.54)), \n                          dot(p, vec3(420.69, 631.2, 109.21))))\n                 * 43758.5453);\n}\n\nvec2 random2(vec2 p) {\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)),\n                          dot(p, vec2(269.5, 183.3))))\n                 * 43758.5453);\n}\n\nfloat WorleyNoise2D(vec2 p) {\n    \n    // Tile the space\n    vec2 pointInt = floor(p);\n    vec2 pointFract = fract(p);\n\n    float minDist = 1.0; // Minimum distance initialized to max.\n\n    // Search all neighboring cells and this cell for their point\n    for(int y = -1; y <= 1; y++)\n    {\n        for(int x = -1; x <= 1; x++)\n        {\n            vec2 neighbor = vec2(float(x), float(y));\n\n            // Random point inside current neighboring cell\n            vec2 point = random2(pointInt + neighbor);\n\n            // Animate the point\n            point = 0.5 + 0.5 * sin(iTime * 0.01 + 6.2831 * point); // 0 to 1 range\n\n            // Compute the distance b/t the point and the fragment\n            // Store the min dist thus far\n            vec2 diff = neighbor + point - pointFract;\n            float dist = length(diff);\n            minDist = min(minDist, dist);\n        }\n    }\n    return minDist;\n}\n\nconst vec3 a = vec3(0.05,0.05,0.5);\nconst vec3 b = vec3(0.5,0.5,0.5);\nconst vec3 c = vec3(0.55,0.55,0.55);\nconst vec3 d = vec3(0.55,0.55,0.55);\n\nvec3 colorPalette(float t) {\n    return a + b * cos(6.28 * (t * c + d));\n}\n\nconst vec3 a2 = vec3(0.7, 0.5, 0.5);\nconst vec3 b2 = vec3(0.5, 0.5, 0.5);\nconst vec3 c2 = vec3(0.8, 0.8, 0.2);\nconst vec3 d2 = vec3(0.8,0.8,0.05);\n\n\nvec3 colorPalette2(float t) {\n    return a2 + b2 * cos(6.28 * (t * c2 + d2));\n}\n\nfloat noise2D(vec2 p ) {\n    return fract(sin(dot(p, vec2(127.1, 311.7))) *\n                 43758.5453);\n}\n\nfloat noise3D(vec3 p ) {\n    return fract(sin(dot(p, vec3(127.1, 311.7, 818.2))) *\n                 43758.5453);\n}\n\n\nfloat interpNoise2D(float x, float y) {\n    float intX = floor(x);\n    float fractX = fract(x);\n    float intY = floor(y);\n    float fractY = fract(y);\n\n    float v1 = noise2D(vec2(intX, intY));\n    float v2 = noise2D(vec2(intX + 1., intY));\n    float v3 = noise2D(vec2(intX, intY + 1.));\n    float v4 = noise2D(vec2(intX + 1., intY + 1.));\n\n    float i1 = mix(v1, v2, fractX);\n    float i2 = mix(v3, v4, fractX);\n    return mix(i1, i2, fractY);\n}\n\nfloat fbm(vec2 p) {\n    float total = 0.;\n    float persistence = 0.73f;\n    float octaves = 16.;\n\n    for(float i = 1.; i <= octaves; i++) {\n        float freq = pow(2.f, i);\n        float amp = pow(persistence, i);\n\n        total += interpNoise2D(p.x * freq,\n                               p.y * freq) * amp;\n    }\n    return total;\n}\n\nfloat fbm2(vec2 p) {\n    p *= 1.;\n    float total = 0.;\n    float persistence = 0.6f;\n    float octaves = 16.;\n\n    for(float i = 1.; i <= octaves; i++) {\n        float freq = pow(2.f, i);\n        float amp = pow(persistence, i);\n\n        total += interpNoise2D(p.x * freq,\n                               p.y * freq) * amp;\n    }\n    return total;\n}\n\n/********************************/\n/***** NOISE FUNCTIONS END ******/\n/********************************/\n    \n\n// SDF of a sphere\nfloat sphere(vec3 p , float r, vec3 c) {\n    return distance(p, c) - r;\n}\n\n// SDF of plane\nfloat plane(vec3 p, vec3 n, vec3 c)\n{\n  \t// n must be normalized\n  \tvec3 a = p - c;\n  \tvec3 b = n;\n    \n    if (dot(a, b) < -0.001) {\n        return 10000.;\n    }\n    if (length(p - c) > 82.) {\n        return 1000000.;\n    }\n  \n  \treturn dot(a ,b) / length(b);\n}\n\n// transformation\nmat4 inverseTransform(vec3 s, vec3 rDeg, vec3 t) {\n    \n    // convert from degrees to radians\n    vec3 rotate = vec3(radians(rDeg.x), radians(rDeg.y), radians(rDeg.z));\n    \n    mat4 r_x;\n    r_x[0] = vec4(1., 0., 0., 0.);\n    r_x[1] = vec4(0., cos(rotate.x), sin(rotate.x), 0.);\n    r_x[2] = vec4(0., -sin(rotate.x), cos(rotate.x), 0.);\n    r_x[3] = vec4(0., 0., 0., 1.);\n                                    \n                                    \n    mat4 r_y;\n    r_y[0] = vec4(cos(rotate.y), 0., -sin(rotate.y), 0.);\n    r_y[1] = vec4(0., 1, 0., 0.);\n    r_y[2] = vec4(sin(rotate.y), 0., cos(rotate.y), 0.);\n    r_y[3] = vec4(0., 0., 0., 1.);\n\n    mat4 r_z;\n    r_z[0] = vec4(cos(rotate.z), sin(rotate.z), 0., 0.);\n    r_z[1] = vec4(-sin(rotate.z), cos(rotate.z), 0., 0.);\n    r_z[2] = vec4(0., 0., 1., 0.);\n    r_z[3] = vec4(0., 0., 0., 1.);\n\n    mat4 rMat = r_x * r_y * r_z;\n    \n    // creating worldTransform matrix\n    mat4 translateMat;\n    translateMat[0] = vec4(1., 0., 0., 0.);\n    translateMat[1] = vec4(0., 1., 0., 0.);\n    translateMat[2] = vec4(0., 0., 1., 0.);\n    translateMat[3] = vec4(t.x, t.y, t.z, 1.);\n    \n    mat4 scaleMat;\n    scaleMat[0] = vec4(s.x, 0., 0., 0.);\n    scaleMat[1] = vec4(0., s.y, 0., 0.);\n    scaleMat[2] = vec4(0., 0., s.z, 0.);\n    scaleMat[3] = vec4(0., 0., 0., 1.);\n\n    mat4 worldTrans = translateMat * rMat * scaleMat;\n    \n    return inverse(worldTrans);\n}\n\n// SDF of box\nfloat roundedBox(vec3 p, vec3 s, vec3 r, vec3 t, float radius) {\n    mat4 inverseTrans = inverseTransform(s, r, t);\n    vec4 tempP = inverseTrans * vec4(p, 1.f);\n    p = vec3(tempP.x, tempP.y, tempP.z);\n    \n    vec3 q = abs(p) - vec3(0.5, 0.5, 0.5);\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - radius;\n}\n\n\nfloat sdCappedCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    \n  \tvec3  ba = b - a;\n    vec3  pa = p - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    \n  \tp.x = abs(p.x);\n  \tfloat k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  \treturn sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat smoothBlendSDF(vec3 pos, float a, float b, float k) {\n\n    float h = clamp((0.5f + 0.5f * (b - a) / k), 0.f, 1.f);\n    return mix(b, a, h) - k * h * (1.f - h);\n}\n\nvoid sceneMap3D(vec3 pos, out float t, out int obj, vec3 lightPos) {\n    t = FLOOR_SDF;\n    obj = FLOOR_ID;\n    \n    float t2;\n    if ((t2 = HANDLE_SDF) < t) {\n        t = t2;\n        obj = HANDLE_ID;\n    }\n    if ((t2 = SUN_SDF) <t) {\n        t = t2;\n        obj = SUN_ID;\n    }\n    if ((t2 = MJOLNIR_SDF) < t) {\n        t = t2;\n        obj = MJOLNIR_ID;\n    }\n    if ((t2 = STRING_SDF) < t) {\n        t = t2;\n        obj = STRING_ID;\n    }\n    if ((t2 = CAP_SDF) < t) {\n        t = t2;\n        obj = CAP_ID;\n    }\n}\n\nfloat sceneMap3D(vec3 pos, vec3 lightPos) {\n    float t = FLOOR_SDF;\n    \n    float t2;\n    if ((t2 = HANDLE_SDF) < t) {\n        t = t2;\n    }\n    if ((t2 = SUN_SDF) < t) {\n        t = t2;\n    }\n    if ((t2 = MJOLNIR_SDF) < t) {\n        t = t2;\n    }\n    if ((t2 = CAP_SDF) < t) {\n        t = t2;\n    }\n    return t;\n}\n\nfloat shadowMap3D(vec3 pos, vec3 lightPos) {\n    float t = FLOOR_SDF;\n    \n    float t2;\n    if ((t2 = HANDLE_SDF) < t) {\n        t = t2;\n    }\n    if ((t2 = MJOLNIR_SDF) < t) {\n        t = t2;\n    }\n    return t;\n}\n\nfloat subsurface(vec3 lightDir, vec3 normal, vec3 viewVec, float thin) {\n\tvec3 scatterDir = lightDir + normal * DISTORTION; // Last term is tunable\n\tfloat lightReachingEye = pow(clamp(dot(viewVec, -scatterDir),\n\t\t\t\t\t\t\t     0.0, 1.0), GLOW) * SCALE;\n\tfloat attenuation = max(0.0, dot(normal, lightDir)\n                             + dot(viewVec, -lightDir));\n    //attenutation = 1.f;\n\tfloat totalLight = attenuation * (lightReachingEye + AMBIENT) * thin;\n\treturn totalLight;\n}\n\nfloat softShadow(vec3 dir, vec3 origin, float min_t, float max_t, float k) {\n    float res = 1.0;\n    for(float t = min_t; t < max_t; /*No update in loop header*/) {\n        float m = shadowMap3D(origin + t * dir, vec3(0., 0., 0.));\n        if(m < 0.0001) {\n            return 0.0; // In shadow\n        }\n        res = min(res, k * m / t);\n        t += m;\n    }\n    return res;\n}\n\nvec3 rotateY(vec3 p, float a) {\n    return vec3(sin(a) * p.x + cos(a) * p.z, p.y, -cos(a) * p.x + sin(a) * p.z);\n}\n\nvec2 sphereUVMapSun(vec3 pos, vec3 lightPos) {\n    vec3 n = normalize(pos - lightPos); // sphere point - sphere center: for the sun\n    float phi = atan(n.z, n.x);\n    if (phi < 0.) {\n        phi += 2. * 3.1415926;\n    }\n    float theta = acos(n.y);\n    float u = 1. - phi / (2. * 3.1415926);\n    float v = 1. - theta / 3.1415926;\n    return vec2(u, v);\n}\n\nvec2 planeUVMap(vec3 pos) {\n    vec3 n = vec3(0., 1., 0.);\n    vec3 u = normalize(vec3(1., 0., 0.));\n    vec3 v = cross(n, u);\n    \n    float u_coord = dot(u, pos);\n\tfloat v_coord = dot(v,pos);\n    return vec2(u_coord, v_coord);\n}\n\nvec3 computeMaterial(int hitObj, vec3 pos, vec3 n, vec3 lightVec, vec3 view, float thickness, vec3 lightPos) {\n    float lambert = max(0., dot(lightVec, n)) * softShadow(lightVec, pos, 0.1, 50., 6.0);\n    \n    switch(hitObj) {\n        case FLOOR_ID:\n        \tif (pos.z > 70.) {\n\t\t\t\treturn vec3(0.);\n            }\n        \tvec3 warpedColor = vec3(1., 1., 1.) * lambert * colorPalette(cos(iTime * SPEED)* WorleyNoise2D(planeUVMap(2. * pos / 4.)));\n    \t\tvec3 warpedConstant = vec3(1., 1., 1.) * lambert * colorPalette(cos(2.6)* WorleyNoise2D(planeUVMap(pos)));\n        \t//warpedConstant /= 1.5;\n        \twarpedColor *= 1.3;\n        \tvec3 floorColor = warpedColor + warpedConstant;\n            if (pos.z > 60.) {\n\t\t\t\tfloorColor *= 0.7;\n            }\n        \treturn floorColor;\n        \tbreak;\n        case MJOLNIR_ID:\n        \n        \tvec3 diffuseColor = vec3(0.65, 0.65, 0.65) * fbm2(vec2(pos.x, pos.y));\n        \t// Calculate Bling Phong terms\n            float diffuseTerm = max(0., dot(normalize(n), normalize(lightVec)));\n            vec3 average = normalize((normalize(lightVec) + normalize(view)) / 2.f);\n            float specularIntensity = max(pow(dot(average, normalize(n)), 3.5), 0.);\n            float lightIntensity = diffuseTerm + 0.2f;\n\n            // Compute final shaded color\n        \tvec3 blingColor = vec3(diffuseColor * lightIntensity) + vec3(specularIntensity);\n        \tvec3 mjolnirColor = blingColor + subsurface(lightVec, n, view, thickness) * vec3(0.1, 0.3, 1.);\n        \n        \treturn mjolnirColor;\n            break;\n\t\tcase HANDLE_ID:\n        \n        \t// metal stripes\n            if ((pos.y <= 2. && pos.y > 1.85) || (pos.y <= 3. && pos.y > 2.85) ||\n               (pos.y <= 1. && pos.y > 0.85) || (pos.y <= 4. && pos.y > 3.85) || \n               (pos.y <= 5. && pos.y > 4.85)) {\n                \n                vec3 diffuseHandle = vec3(180., 180., 180.) / 255.;\n                float diffuseTerm2 = max(0., dot(normalize(n), normalize(lightVec)));\n            \tvec3 average2 = normalize((normalize(lightVec) + normalize(view)) / 2.f);\n            \tfloat specularIntensity2 = max(pow(dot(average2, normalize(n)), 50.f), 0.);\n            \tfloat lightIntensity2 = diffuseTerm2 + 0.2f;\n                vec3 shinyColor = vec3(diffuseHandle * lightIntensity2) + vec3(specularIntensity2);\n\t\t\t\treturn shinyColor;\n            }\n        \n        \t// wood\n        \tvec3 color = vec3(0.55, 0.26, 0.04) * lambert * fbm(pos.xy);\n        \treturn color + subsurface(lightVec, n, view, thickness) * vec3(0.2, 0.5, 1.);\n            break;\n        case SUN_ID:\n        \treturn vec3(1.0, 0.88, 0.7) * colorPalette2(fbm(sphereUVMapSun(pos, vec3(10., 0., 100.))) * mix(0.95, 1.15, cos(iTime / 4.)));\n        \tbreak;\n        case STRING_ID:\n        \tvec3 lightning = vec3(0.3, 0.8, 1.) * colorPalette(mix(1.2, 1.5, cos(iTime * 3.))* WorleyNoise2D(pos.xy * 64.));\n\n        \treturn lightning;\n        \tbreak;\n        case CAP_ID:\n        \tvec3 diffuseColor3 = vec3(0.45, 0.45, 0.45) * fbm2(vec2(pos.x * 32., pos.y * 32.));\n        \t// Calculate Bling Phong terms\n            float diffuseTerm3 = max(0., dot(normalize(n), normalize(lightVec)));\n            vec3 average3 = normalize((normalize(lightVec) + normalize(view)) / 2.f);\n            float specularIntensity3 = max(pow(dot(average3, normalize(n)), 20.f), 0.);\n            float lightIntensity3 = diffuseTerm3 + 0.2f;\n\n            // Compute final shaded color\n        \tvec3 blingColor3 = vec3(diffuseColor3 * lightIntensity3) + vec3(specularIntensity3);\n        \tvec3 mjolnirColor3 = blingColor3 + subsurface(lightVec, n, view, thickness) * vec3(0.1, 0.3, 1.);\n        \n        \treturn mjolnirColor3;\n        \tbreak;\n        case -1:\n            return vec3(0., 0., 0.);\n        \tbreak;\n    }\n    return vec3(0., 0., 0.);\n}\n\n\nvec3 computeNormal(vec3 pos, vec3 lightPos) {\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize(vec3(sceneMap3D(pos + epsilon.yxx, lightPos) - sceneMap3D(pos - epsilon.yxx, lightPos), \n                    \t  sceneMap3D(pos + epsilon.xyx, lightPos) - sceneMap3D(pos - epsilon.xyx, lightPos),\n                          sceneMap3D(pos + epsilon.xxy, lightPos) - sceneMap3D(pos - epsilon.xxy, lightPos)));\n}\n    \n\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj, vec3 lightPos) {\n    t = 0.001;\n    for (int i = 0; i < RAY_STEPS; ++i) {\n        vec3 pos = origin + t * dir;\n        float m;\n        sceneMap3D(pos, m, hitObj, lightPos);\n        if (m < 0.01) {\n            return;\n        }\n        t += m;\n    }\n    t = -1.0;\n    hitObj = -1;\n}\n\n\nfloat AO5Step(vec3 p, vec3 n) {\n    float sum = 0.;\n    for (float i = 1.; i <= 5.; i = i + 1.) {\n        float distSDF = sceneMap3D(p + n * i * OCCDist, vec3(0.));\n        sum += (1. / pow(2., i)) * (i * OCCDist - distSDF);\n    }\n    float ao = 1.0 - KSTEP * sum;\n    return ao;\n}\n\n\nIntersection sdf3D(vec3 dir, vec3 eye, vec3 lightPos) {\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj, lightPos);\n    \n    vec3 isect = eye + t * dir;\n    \n    vec3 nor = computeNormal(isect, lightPos);\n    \n    vec3 lightDir = normalize(lightPos - isect);\n    float thickness = AO5Step(isect, -nor);\n    \n    vec3 surfaceColor = computeMaterial(hitObj, isect, nor, lightDir, normalize(eye - isect), thickness, lightPos);\n        \n    return Intersection(t, surfaceColor, isect, hitObj, nor);\n}\n\n// returns direction of ray\nvec3 rayCast(vec3 eye, vec3 ref, vec2 ndc) {\n    vec3 F = ref - eye;\n    vec3 R = normalize(cross(F, vec3(0, 1, 0)));\n    vec3 U = normalize(cross(R, F));\n    \n    vec3 V = U * length(F) * tan(FOVY * 0.5);\n    vec3 H = R * length(F) * tan(FOVY * 0.5) * float(iResolution.x) / iResolution.y;\n    \n    vec3 p = ref + ndc.x * H + ndc.y * V;\n    \n    return normalize(p - eye);\n}\n\n/******** Lightning ****************/\n/***********************************/\n\n// credit: https://www.shadertoy.com/view/XlsGWS\n\nfloat hash(float x)\n{\n\treturn fract(21654.6512 * sin(385.51 * x));\n}\nfloat hash( in vec2 p ) \n{\n    return fract(sin(p.x*15.32+p.y*35.78) * 43758.23);\n}\n\nvec2 hash2(vec2 p)\n{\n\treturn vec2(hash(p*.754),hash(1.5743*p.yx+4.5891))-.5;\n}\n\nvec2 hash2b(vec2 p)\n{\n\treturn vec2(hash(p*.754),hash(1.5743*p+4.5476351));\n}\nvec2 add = vec2(1.0, 0.0);\n\nvec2 noise2(vec2 x)\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    vec2 res = mix(mix( hash2(p),          hash2(p + add.xy),f.x),\n                    mix( hash2(p + add.yx), hash2(p + add.xx),f.x),f.y);\n    return res;\n}\n\nvec2 fbm2Light(vec2 x)\n{\n    vec2 r = vec2(0.0);\n    float a = 1.0;\n    \n    for (int i = 0; i < 8; i++)\n    {\n        r += abs(noise2(x)+.5 )* a;\n        x *= 2.;\n        a *= .5;\n    }\n     \n    return r;\n}\n\n\nfloat dseg( vec2 ba, vec2 pa )\n{\n\t\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), -0.2, 1. );\t\n\treturn length( pa - ba*h );\n}\n\nfloat arc(vec2 x,vec2 p, vec2 dir)\n{\n    vec2 r = p;\n    float d=10.;\n    for (int i = 0; i < 5; i++)\n    {\n        vec2 s= noise2(r+iTime)+dir;\n        d=min(d,dseg(s,x-r));\n        r +=s;      \n    }\n    return d*3.;\n    \n}\n\n\n\nfloat thunderbolt(vec2 x,vec2 tgt)\n{\n    vec2 r = tgt;\n    float d=1000.;\n    float dist=length(tgt-x);\n     \n    for (int i = 0; i < 19; i++)\n    {\n        if(r.y>x.y+.5)break;\n        vec2 s= (noise2(r+iTime)+vec2(0.,.7))*2.;\n        dist = dseg(s,x-r);\n        d=min(d,dist);\n        \n        r +=s;\n        if(i-(i/5)*5==0){\n            if(i-(i/10)*10==0)d=min(d,arc(x,r,vec2(.3,.5)));\n            else d=min(d,arc(x,r,vec2(-.3,.5)));\n        }\n    }\n    return exp(-5.*d)+.2*exp(-1.*dist);\n   \n}\n\n/***********************************/\n/***********************************/\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv = uv * 2.0 - vec2(1.0, 1.0);\n    \n    vec3 eye = vec3(0, 5.5, -35);\n    vec3 ref = vec3(0, 2.5, 0);\n    \n    vec3 rayDir = rayCast(eye, ref, uv);\n    vec3 lightPos = vec3(9., 8.4, 5.);\n    //vec3 lightPos = vec3(9.,8., 7.);\n    //vec3 lightPos = rotateY(vec3(0., 7.4, 10.), sin(iTime * 0.5));\n\n    Intersection isect = sdf3D(rayDir, eye, lightPos);\n    \n    // ambient occlusion\n    float k = 2.5;\n    float occDist = 0.12;\n    float sum = 0.;\n    for (float i = 1.; i <= 5.; i = i + 1.) {\n        float distSDF = sceneMap3D(isect.p + isect.n * i * occDist, lightPos);\n        sum += (1. / pow(2., i)) * (i * occDist - distSDF);\n    }\n    float ao = 1.0 - k * sum;\n    \n\n    // Output to screen\n    fragColor = vec4(isect.color, 1.) * ao;\n    \n    /**** Lightning *****/\n    vec2 p = 2.*fragCoord.xy/iResolution.yy-1.;\n    p.x -= 0.82;\n    p.y += 0.1;\n    vec2 p2 = vec2(p.x + 0.5, p.y);\n    \n    p *= 3.;\n    p2 *= 4.;\n    \n    vec2 tgt = vec2(1., -8.);\n    float c = 0.;\n    vec3 col;\n    \n    vec2 tgt2 = vec2(1., -10.);\n    float c2 = 0.;\n    vec3 col2;\n    \n    float t = hash(floor(2.*iTime));\n    tgt += 8.*hash2b(tgt+t);\n    float t2 = hash(floor(2.*iTime));\n    tgt2 += 8.*hash2b(tgt+t);\n    \n    if(hash(t+2.3)>.8)\n\t{\n\t\tc= thunderbolt(p*10.+2.*fbm2Light(3.*p),tgt);\t\n\t\tcol+=clamp(1.7*vec3(0.3,.6, 1.2)*c,0.,1.);\t\n\t}\n    \n    if(hash(t2+4.3)>.8)\n\t{\n\t\tc2= thunderbolt(p*6.+5.*fbm2Light(3.*p),tgt2);\t\n\t\tcol2+=clamp(1.7*vec3(0.3,.6, 1.2)*c2,0.,1.);\t\n\t}\n    \n    if (length(col) > 0.8) {\n        fragColor = vec4(col, 0.0);\n    }\n    \n    if (length(col2) > 0.8) {\n        if (p.y > -0.05 || p.y < -1.5) {\n            return;\n        }\n        fragColor = vec4(col2, 0.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdfBDH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdfBR2", "name": "waves-54329", "author": "psedge", "description": "working on minimal shaders for use in demos", "tags": ["seawavesminimal"], "likes": 1, "viewed": 66, "date": "1588578993", "time_retrieved": "2024-06-20T20:07:57.844715", "image_code": "vec3 rgbToFragCol(vec3 rgb) {\n    return rgb/255.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tfloat ux = uv[0];\n    float uy = uv[1];\n    \n    vec3 col = rgbToFragCol(vec3(39,60,117));\n    fragColor = vec4(col,1.0)*0.0;\n    \n    for (float i=1.0; i >= 0.0; i-=0.1) {\n        float inv = 1.0-i;\n        vec3 col = vec3(1.0-i)*col;\n        float pos;\n        if (mod(inv, 0.2) > 0.01) {\n            pos = sin(ux*100.0/(7.5+i*5.0)-(iTime*inv*5.0))/80.0;\n        } else {\n            pos = sin(ux*100.0/(7.5+i*5.0)+(iTime*inv*5.0))/80.0;\n        }\n        if (uy-0.05-i+sin(iTime)*0.01 < pos) {\n        \tfragColor = vec4(col, 1.0);\n    \t}\n \n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdfBR2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdfBRX", "name": "ShATI - Arc-en-ciel", "author": "Flopine", "description": "My former school named ATI decided to launch an everyday challenge from 4th may to 24th may, here is the 2nd subject: rainbow :) ", "tags": ["raymarching", "glow", "rainbow", "colours"], "likes": 5, "viewed": 154, "date": "1588712345", "time_retrieved": "2024-06-20T20:07:58.366018", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n// Shader made for Everyday ATI challenge\n\n#define PI 3.141592\n#define TAU (2.*PI)\n\nfloat hash21 (vec2 x)\n{return fract(sin(dot(x,vec2(12.4,23.4)))*145.4);}\n\nmat2 rot(float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat box (vec3 p, vec3 c)\n{return length(max(abs(p)-c,0.));}\n\nvec3 new_p;\nfloat ruban, sphere, g1=0.;\nfloat SDF (vec3 p)\n{\n    p.x = abs(p.x)-2.;\n    p.xz *= rot(PI/4.);\n\n    sphere = length(p-vec3(9.,0.5,0.8))-3.;\n    g1 += 0.1/(0.1+sphere*sphere);\n    p.x -= p.y*p.y*0.11;\n\n    p.z += sin(p.y*2.+iTime*5.)*0.2;\n\n    p.xz *= rot(p.y*0.35);\n    new_p = p;\n    ruban = box(p,vec3(2.,40.,0.1));\n    return min(sphere,ruban);\n}\n\nvec3 palette (float t, vec3 c)\n{return vec3(0.5)+vec3(0.5)*cos(TAU*(c*t+vec3(0.,0.36,0.74)));}\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2(0.1,0.);\n    return normalize(SDF(p)-vec3(SDF(p-eps.xyy),SDF(p-eps.yxy),SDF(p-eps.yyx)));\n}\n\nfloat spec (vec3 rd, vec3 n, vec3 l)\n{\n    vec3 h = normalize(l-rd);\n    return pow(max(dot(n,h),0.), 15.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    float dither = hash21(uv);\n\n    vec3 ro = vec3(3.,0.,-5.8),\n        p = ro,\n        rd = normalize(vec3(uv,1.)),\n        l = vec3(-2.,1., -3.),\n        col = vec3(0.01,0.,0.03);\n\n    float shad, d = 0.;\n    bool hit = false;\n\n    for (float i=0.; i<64.;i++)\n    {\n        d = SDF(p);\n        if (d<0.001)\n        {\n            hit = true;\n            shad = i/64.;\n            break;\n        }\n        d *= 0.7 + dither*0.1;\n        p += d*rd;\n    }\n\n    if(hit)\n    {\n        if (d == ruban) col = palette(texture(iChannel0,new_p.xx*0.02).r, vec3(1.));\n        if (d == sphere) col = vec3(0.5,0.2,0.);\n\n        vec3 n = getnorm(p);        \n        col += spec(rd,n,l);\n    }\n\n    col += g1*length(uv)*0.1;\n    \n    // Output to screen\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdfBRX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdfBWs", "name": "lr94/asteroidProto", "author": "lucasrumney94", "description": "Look-Dev for an asteroids project I am currently working on. ", "tags": ["asteroids"], "likes": 0, "viewed": 66, "date": "1589259581", "time_retrieved": "2024-06-20T20:07:59.390207", "image_code": "const float MAX_RAYMARCH_DISTANCE = 100.;\nconst int MAX_RAYMARCH_STEPS = 100;\nconst float EPSILON = 0.0001;\nconst float VERTICAL_FOV = 45.0;\n\n//Phong Parameters\nconst float ambientReflectionConstant = 1.;\nconst float ambientLightingLevel = 1.3;\nconst float diffuseReflectionConstant = .8;\nconst float diffuseLightingLevel = .9;\nconst float specularReflectionConstant = .5;\nconst float specularLightingLevel = .7;\nconst float shininess = 16.;\n\nvec3 rand3(vec3 st)\n{\n    st = vec3( dot(st, vec3(12.9898,78.233, 37.135)),\n               dot(st, vec3(325.800, 228.540, 561.121)),\n               dot(st, vec3(285.760, 189.060, 126.580)) );\n    return -1.0 + 2.0 * fract(sin(st) * 43758.5453123);\n}\n\n// returns from 0 to 1\nvec3 smootherstep(vec3 x){\n\treturn x*x*x*(x*(x*6.-15.)+10.);\n}\n\nfloat noise(vec3 st)\n{\n    vec3 i = floor(st);\n    vec3 fractional = fract(st);\n    \n    // Eight samples from cube corners\n    float a = dot( rand3(i), fractional );\n    float b = dot( rand3(i + vec3(1.0, 0.0, 0.0)), fractional - vec3(1.0, 0.0, 0.0) );\n    float c = dot( rand3(i + vec3(0.0, 1.0, 0.0)), fractional - vec3(0.0, 1.0, 0.0) );\n    float d = dot( rand3(i + vec3(1.0, 1.0, 0.0)), fractional - vec3(1.0, 1.0, 0.0) );\n    float e = dot( rand3(i + vec3(0.0, 0.0, 1.0)), fractional - vec3(0.0, 0.0, 1.0) );\n    float f = dot( rand3(i + vec3(1.0, 0.0, 1.0)), fractional - vec3(1.0, 0.0, 1.0) );\n    float g = dot( rand3(i + vec3(0.0, 1.0, 1.0)), fractional - vec3(0.0, 1.0, 1.0) );\n    float h = dot( rand3(i + vec3(1.0, 1.0, 1.0)), fractional - vec3(1.0, 1.0, 1.0) );\n    \n    vec3 u = smootherstep(fractional);\n    \n    float ab = mix(a, b, u.x);\n    float cd = mix(c, d, u.x);\n    float ef = mix(e, f, u.x);\n    float gh = mix(g, h, u.x);\n    float c1 = mix(ab, cd, u.y);\n    float c2 = mix(ef, gh, u.y);\n    return mix(c1, c2, u.z);\n}\n\nfloat sphere(vec3 uv, vec3 position, float radius){\n    return (distance(position, uv) - radius);\n}\n\nfloat displacedSphereSDF(vec3 samplePoint){\n\tfloat actualDistance = sphere(samplePoint, vec3(0.,0.,0.), .5);\n    float modifiedDistance = actualDistance;\n    modifiedDistance -= 0.15+0.01*sin(23.98+120.*samplePoint.y*samplePoint.x*samplePoint.z);\n    modifiedDistance -= 0.15+0.03*sin(2.*iTime+33.*samplePoint.y);\n    modifiedDistance -= 0.15+0.01*sin(123.3+14.*samplePoint.x);\n    modifiedDistance -= .2*noise(5.*samplePoint+324.4);\n    \n\treturn modifiedDistance;\n}\n\n// Defines the surfaces \n// returns the nearest distance from the provided position to the scene's surfaces\nfloat sceneSDF(vec3 samplePoint){\n    float largeSphere = sphere(samplePoint, vec3(0.,0.,0.), .5);\n\n    return displacedSphereSDF(samplePoint);\n}\n\n\n\nfloat rayMarch(vec3 cameraPoint, vec3 cameraRay){\n\tvec3 samplePoint = cameraPoint;\n    float depth = 0.;\n\n    for (int i = 0; i < MAX_RAYMARCH_STEPS; i++){\n        float closestDistance = sceneSDF(samplePoint);\n        // If we are close enough\n        if (closestDistance < EPSILON){\n        \tbreak;\n        }\n        depth += closestDistance;\n        // If we have exhausted the raymarching\n        if (depth > MAX_RAYMARCH_DISTANCE) {\n            depth = 0.;\n            break;\n        }\n        // March the Sample Point forward by the closestDistance\n        samplePoint += (closestDistance)*cameraRay;  \n    }\n            \n    // 0. cameraPoint INSIDE the SDF\n    // +f distance to the surface\n    return depth; // pointOnShape\n}\n\nvec3 getNormal(vec3 position){\n\tvec3 normal = vec3(0.);\n    \n    vec3 x1Sample = position+vec3(EPSILON, 0.,0.);\n    vec3 x2Sample = position-vec3(EPSILON, 0.,0.);\n    float x1SampleDistance = sceneSDF(x1Sample);\n    float x2SampleDistance = sceneSDF(x2Sample);\n    normal.x = x1SampleDistance-x2SampleDistance;\n    \n    vec3 y1Sample = position+vec3(0.,EPSILON,0.);\n    vec3 y2Sample = position-vec3(0.,EPSILON,0.);\n    float y1SampleDistance = sceneSDF(y1Sample);\n    float y2SampleDistance = sceneSDF(y2Sample);\n    normal.y = y1SampleDistance-y2SampleDistance;\n    \n    vec3 z1Sample = position+vec3(0.,0.,EPSILON);\n    vec3 z2Sample = position-vec3(0.,0.,EPSILON);\n    float z1SampleDistance = sceneSDF(z1Sample);\n    float z2SampleDistance = sceneSDF(z2Sample);\n    normal.z = z1SampleDistance-z2SampleDistance;\n    \n    return normalize(normal);\n}\n\nvec3 cameraRayFromFrag(float vFoVDegrees, vec2 fragCoord){\n\t\n    // Remap coordinate (0,0) to center of screen\n    fragCoord = fragCoord-iResolution.xy/2.;\n    \n    float z = iResolution.y / tan(radians(vFoVDegrees) / 2.);\n\n    vec3 cameraRay = vec3(fragCoord.x, fragCoord.y, -z);\n    return normalize(cameraRay);\n}\n\nfloat phong(vec3 pointOnSurface, vec3 normal, vec3 cameraPoint, vec3 lightPoint){\n    \n    float ambient = ambientReflectionConstant*ambientLightingLevel;\n    vec3 L = normalize(lightPoint-pointOnSurface);\n    float diffuse = diffuseReflectionConstant*dot(L,normal)*diffuseLightingLevel;\n    \n    vec3 R = normalize(reflect(-L, normal));\n    vec3 view = normalize(cameraPoint-pointOnSurface);\n    float reflectionFactor = dot(R, view);\n    float specular = 0.;\n    if (reflectionFactor > 0.){\n    \tspecular = specularReflectionConstant*pow(dot(R, view), shininess)*specularLightingLevel;\n    }\n    \n    return ambient+diffuse+specular;\n}\n\nvec3 asteroidShader(vec3 pointOnSurface, vec3 normal){\n\t\n    vec3 outputColor = vec3(0.); \n    //float threshold = step(1.1, length(pointOnSurface));\n    \n    float elevation = clamp((length(pointOnSurface)-.87)*3.03, 0., 1.);\n    float slope = length(cross(pointOnSurface, normal));\n    float slopeElevbyElev = pow(mix(elevation, 1.-slope, elevation),2.);\n    outputColor = mix(vec3(0.02,.01,0.),\n                      vec3(.8,.6,.3), \n                      slopeElevbyElev);\n    \n\n    \n    //.87 to 1.1\n    \n    return outputColor;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n\n    // Grey Background\n    vec3 col = vec3(0.2);\n    \n\t\n    vec3 cameraPoint = vec3(0.,0.,5.);\n    vec3 cameraRay = cameraRayFromFrag(VERTICAL_FOV, fragCoord);\n    float rayMarchDistance = rayMarch(cameraPoint, cameraRay);\n    vec3 pointOnSurface = cameraPoint+cameraRay*rayMarchDistance;\n    vec3 normal = getNormal(pointOnSurface);\n    vec3 lightPoint = vec3(cos(1.3*iTime),2.,2.+sin(1.1*iTime));\n    \n    float phongLighting = phong(pointOnSurface,normal,cameraPoint,lightPoint);\n    vec3 asteroidShaderColor = asteroidShader(pointOnSurface, normal);\n    \n    col = mix(col, phongLighting*asteroidShaderColor, clamp(rayMarchDistance, 0., 1.));\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdfBWs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdfBzB", "name": "Isolating Androids", "author": "dr2", "description": "Gotta stay safe", "tags": ["torus", "robot", "moebius"], "likes": 7, "viewed": 258, "date": "1588509080", "time_retrieved": "2024-06-20T20:07:59.403438", "image_code": "// \"Isolating Androids\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  1   // optional antialiasing\n\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrSphDf (vec3 p, float r);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nfloat Maxv3 (vec3 p);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Fbm2 (vec2 p);\n\nvec3 ltDir;\nfloat tCur, dstFar, tRadB, tRadS;\nint idObj;\nconst float pi = 3.14159;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat RobDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float szFac, rAngH, rAngA, d, s;\n  s = sin (pi * tCur);\n  rAngH = -0.7 * s;\n  rAngA = 1.1 * s;\n  szFac = 0.15;\n  dMin /= szFac;\n  p /= szFac;\n  p.y -= 0.25;\n  q = p; \n  q.y -= 2.3;\n  d = max (PrSphDf (q, 0.85), - q.y - 0.2);\n  q = p; \n  q.y -= 1.5;\n  d = min (d, PrRoundCylDf (q.xzy, 0.9, 0.28, 0.75));\n  q = p;  \n  q.x = abs (q.x); \n  q.xy -= vec2 (1.05, 2.);\n  q.yz = Rot2D (q.yz, rAngA * sign (p.x));\n  q.y -= -0.5;\n  d = min (d, PrRoundCylDf (q.xzy, 0.2, 0.15, 0.6));\n  q = p;\n  q.xz = Rot2D (q.xz, rAngH);\n  q.x = abs (q.x);\n  q.xy -= vec2 (0.3, 3.1);\n  q.xy = Rot2D (q.xy, 0.2 * pi);\n  q.y -= 0.25;\n  d = min (d, PrRoundCylDf (q.xzy, 0.06, 0.04, 0.3));\n  q = p;\n  q.xy -= vec2 (0.4, 0.3);\n  d = min (d, PrRoundCylDf (q.xzy, 0.25, 0.15, 0.65));\n  q = p;\n  q.x = - q.x;  \n  q.xy -= vec2 (0.4, 0.3);\n  d = min (d, PrRoundCylDf (q.xzy, 0.25, 0.15, 0.65));\n  DMIN (2);\n  q = p;\n  q.xz = Rot2D (q.xz, rAngH);\n  q.x = abs (q.x); \n  q -= vec3 (0.4, 2.7, 0.7);  \n  d = PrSphDf (q, 0.15);\n  DMIN (3);\n  return szFac * dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  vec2 b;\n  float dMin, d, a, t, ns;\n  dMin = dstFar;\n  p.yz = Rot2D (p.yz, 0.1 * pi);\n  q = p;\n  ns = 16.;\n  t = 0.05 * tCur;\n  d = length (vec2 (Rot2D (vec2 (length (q.xz) - tRadB, q.y),\n     0.5 * atan (q.z, q.x)))) - tRadS;\n  q.xz = Rot2D (q.xz, t);\n  a = 2. * pi * (floor (ns * atan (q.z, - q.x) / (2. * pi)) + 0.5) / ns;\n  q.xz = Rot2D (q.xz, a);\n  q.x += tRadB;\n  q.xy = Rot2D (q.xy, 0.5 * (a + t));\n  b = vec2 (0.95 * tRadS, 0.65 * pi * tRadB / ns);\n  d = max (d, - max (PrBox2Df (vec2 (abs (q.x) - tRadS, q.z), b),\n     PrBox2Df (vec2 (abs (q.y) - tRadS, q.z), b)));\n  DMIN (1);\n  q.xy = Rot2D (q.xy, 2. * pi * (floor (4. * atan (q.y, - q.x) / (2. * pi)) / 4.)) -\n     vec2 (-0.35, 0.06);\n  q.xz = vec2 (q.z, - q.x);\n  dMin = RobDf (q, dMin);\n  return 0.7 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.005, -0.005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat TrObjDf (vec3 p)\n{\n  p.yz = Rot2D (p.yz, 0.1 * pi);\n  return PrTorusDf (p.xzy, tRadS - 0.02, tRadB);\n}\n\nfloat TrObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = TrObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 TrObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.005, -0.005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = TrObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 ErCol (vec3 rd)\n{\n  vec3 erDir, col, vn;\n  float erRad, bs, ts;\n  erDir = normalize (vec3 (0.02, -0.04, 1.));\n  erRad = 0.04;\n  col = vec3 (0.);\n  bs = dot (rd, erDir);\n  ts = bs * bs - 1. + erRad * erRad;\n  if (ts > 0.) {\n    ts = bs - sqrt (ts);\n    if (ts > 0.) {\n      vn = normalize ((ts * rd - erDir) / erRad);\n      col = mix (vec3 (0.3, 0.4, 0.8), vec3 (1., 1., 0.95),\n         smoothstep (0.2, 0.8, Fbm2 (6. * vn.xy + 7.1))) * (0.5 + 0.5 * max (- dot (vn, rd), 0.)) *\n         (0.2 + 0.8 * max (dot (vn, ltDir), 0.));\n    }\n  }\n  return col;\n}\n\nvec3 StarPat (vec3 rd, float scl)\n{\n  vec3 tm, qn, u;\n  vec2 q;\n  float f;\n  tm = -1. / max (abs (rd), 0.0001);\n  qn = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  u = Maxv3 (tm) * rd;\n  q = atan (vec2 (dot (u.zxy, qn), dot (u.yzx, qn)), vec2 (1.)) / pi;\n  f = 0.57 * (Fbm2 (11. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 131.13 * scl * q) +\n      Fbm2 (13. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 171.13 * scl * q.yx));\n  return 8. * vec3 (1., 1., 0.8) * pow (f, 16.);\n}\n\nvec3 BgCol (vec3 rd)\n{\n  vec3 col;\n  col = ErCol (rd);\n  if (length (col) < 0.03) col += StarPat (rd, 16.);\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, colR, vn, roo;\n  float dstObj, dstObjT;\n  tRadB = 3.;\n  tRadS = 0.8;\n  roo = ro;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 1) col4 = vec4 (0.5, 0.5, 0.55, 0.2);\n    else if (idObj == 2) col4 = vec4 (0., 1., 1., 0.2);\n    else if (idObj == 3) col4 = vec4 (1., 0., 0., 0.2);\n    col = col4.rgb * (0.2 + 0.2 * max (- dot (vn, ltDir), 0.) +\n       0.8 * max (dot (vn, ltDir), 0.)) +\n       col4.a * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n  } else {\n    col = BgCol (rd);\n  }\n  ro = roo;\n  dstObjT = TrObjRay (ro, rd);\n  if (dstObjT < min (dstObj, dstFar)) {\n    ro += dstObjT * rd;\n    vn = TrObjNf (ro);\n    col = mix (0.1 + 1.5 * BgCol (reflect (rd, vn)), col, 0.1 +\n       0.9 * smoothstep (0.1, 0.7, - dot (rd, vn)));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = -0.07 * pi;\n  el = -0.05 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -20.);\n  zmFac = 6.;\n  dstFar = 50.;\n  ltDir = normalize (vec3 (1., 0.7, -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (pow (col, vec3 (0.8)), 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  float dxy, dz;\n  dxy = length (p.xy) - r;\n  dz = abs (p.z) - h;\n  return min (min (max (dxy + rt, dz), max (dxy, dz + rt)), length (vec2 (dxy, dz) + rt) - rt);\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdfBzB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdfBzj", "name": "MS-06 ZAKU", "author": "yasuo", "description": "reference images: [url]https://www.google.com/search?q=zaku+head&tbm=isch[/url]", "tags": ["reproduction", "zaku"], "likes": 6, "viewed": 242, "date": "1588598365", "time_retrieved": "2024-06-20T20:08:01.323795", "image_code": "// All the distance functions from:http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 200\n#define MAX_DIST 80.\n#define SURF_DIST .002\n#define EDGE_WIDTH 0.015\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n\nfloat edge;\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec4 combine(vec4 val1, vec4 val2 ){\n    return (val1.w < val2.w)?val1:val2;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec3 emitColor(vec3 p, vec3 emitPos, vec3 emitColor, float radius, float softness, float brightness) {\n    float c = smoothstep(-softness,softness,-(length(p-emitPos)-radius));\n    emitColor = (emitColor*c)*brightness;\n    return emitColor;\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n\n// ventilator pipe based on the sdLink distance function\n// Notice that the following function is not reusable code.\nfloat sdVentilator( vec3 p, float le, float r1, float r2 )\n{\n    p.x*=0.9;\n    vec3 prevP = p;\n    vec3 q = vec3( p.x, p.y, max(abs(p.z)-le,0.0) );\n    vec2 p2 = vec2(length(q.xz)-r1,q.y);\n\n    float d = length(p2) - r2;\n\tfloat d2 = length(p2) - (r2*0.8);\n    \n    float space = 0.05;\n    p.z = mod(p.z,0.38)-0.19;\n    float b = sdBox(p,vec3(1.5,0.3,space));\n    p = prevP;\n\tfloat b2 = sdBox(p,vec3(1.5,0.3,0.9));\n    b = max(b2,b);\n    \n    p*= matRotateY(radians(52.0));\n    float b3 = sdBox(p,vec3(1.5,0.3,space));\n    p = prevP;\n    b = min(b,b3);\n\n    p*= matRotateY(radians(70.0));\n\tfloat b4 = sdBox(p,vec3(1.5,0.3,space));\n    p = prevP;\n    b = min(b,b4);\n    \n    p*= matRotateY(radians(-52.0));\n    float b5 = sdBox(p,vec3(1.5,0.3,space));\n    p = prevP;\n    b = min(b,b5);\n\n    p*= matRotateY(radians(-70.0));\n\tfloat b6 = sdBox(p,vec3(1.5,0.3,space));\n    p = prevP;\n    b = min(b,b6);\n    \n    \n    vec3 p3 = p-vec3(0.0,0.02,1.15);\n    p3*= matRotateZ(radians(90.0));\n    float d3 = sdCappedCylinder(p3,0.2,0.33);\n    \n    return min(min(d2,d3),max(-b,d))*0.6;\n}\n\nfloat headBack(vec3 p) {\n    float size = 1.5;\n    float thickness = 0.35;\n    vec4 a1 = vec4(0.0,size,1.6,0.0); // btm\n    float p1 = dot(p,a1.xyz) + a1.w;\n    \n    vec4 a2 = vec4(0.0,-size,0.0,0.85); // top\n    float p2 = dot(p,a2.xyz) + a2.w;\n        \n    vec4 a3 = vec4(size,0.0,0.0,0.15); // right\n    float p3 = dot(p,a3.xyz) + a3.w;\n            \n    vec4 a4 = vec4(-size,0.0,0.0,0.15); // left\n    float p4 = dot(p,a4.xyz) + a4.w;\n                \n    vec4 a5 = vec4(0.0,0.0,-size,thickness); // foward\n    float p5 = dot(p,a5.xyz) + a5.w;\n                    \n    vec4 a6 = vec4(0.0,0.0,size,thickness); // back\n    float p6 = dot(p,a6.xyz) + a6.w;\n\n    float d = max(-p1,max(-p2,max(-p3,max(-p4,max(-p5,-p6)))));\n    return d;\n}\n\nfloat sdHead(vec3 p) {\n    vec3 prevP = p;\n    p.x*=1.15;\n    float d =  length(p)-1.0;\n    d = max(-(p.y+0.3),d);\n    float d2 = sdBox(p-vec3(0.0,0.3,1.0),vec3(1.5,0.2,0.5));\n    d = max(-d2,d);\n    \n    p = prevP;\n    p*=matRotateX(radians(-110.0));\n    p.y-=1.25;\n    p.z+=1.35;\n    float sc = mix(0.7,3.0,smoothstep(-1.0,1.0,p.y));\n    vec3 p2 = p-vec3(0.0,-0.25,1.2);\n    p2.x*=sc;\n    \n    d2 = sdBox(p2,vec3(0.6,0.46,.15));\n    d = smin(d,d2,0.3);\n    \n    p = prevP;\n    p.x = abs(p.x);\n    p.x-=0.85;\n    d2 = sdBox(p-vec3(0.0,0.34,0.15),vec3(0.15,0.15,0.15));\n    d = max(-d2,d);\n    p = prevP;\n    p*=matRotateX(radians(-18.0));\n    d2 = sdBox(p-vec3(0.0,0.1,1.5),vec3(0.2,0.1,0.1));\n    d = max(-d2,d);\n    p = prevP;\n    \n    p.x = abs(p.x);\n    p.x-=0.15;\n    \n    d2 = headBack(p-vec3(0.0,-0.04,-1.08));\n    d = smin(d,d2,0.1);\n    \n    return d*0.6;\n}\n\nvec4 GetDist(vec3 p) {\n    \n    vec3 prevP = p;\n    float _floor = p.y;\n\n    float y = 0.0;\n    \n    p*=matRotateX(radians(-10.0));\n    float v = sdVentilator(p-vec3(0.0,1.2+y,-0.2),0.3,0.9,0.15);\n    p = prevP;\n\tfloat h = sdHead(p-vec3(0.0,1.1+y,0.0));\n    \n    float d = min(v,h);\n    vec4 res = vec4(vec3(0.4,0.5,0.4),d);\n        \n    vec3 eyeEmitPos = vec3(sin(iTime*2.0)*0.2,1.43+y,0.56);\n    vec3 eyePos = p-eyeEmitPos;\n    eyePos *= matRotateX(radians(90.0));\n    vec3 ecol = emitColor(p,eyeEmitPos, vec3(1.0,0.5,0.8),0.0001,0.9,3.0);\n    d = sdCappedCylinder(eyePos,0.15,0.02);\n    vec4 eye = vec4(vec3(0.7,0.0,0.0)+ecol,d);\n    \n    vec4 model = combine(res,eye);\n    return model;\n}\n\nvec4 RayMarch(vec3 ro, vec3 rd) {\n    vec4 r = vec4(0.0,0.0,0.0,1.0);\n    \n    float lastDistEval = 1e10; \n    float dist;\n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*r.w;\n        vec4 dS = GetDist(p);\n        dist =  dS.w;\n        r.w += dS.w;\n        r.rgb = dS.xyz;\n        \n\t\tif (lastDistEval < EDGE_WIDTH && dist > lastDistEval + 0.001) {\n            edge = 1.0;\n\t\t}\n        if (dist < lastDistEval) lastDistEval = dist;\n        \n        if(r.w>MAX_DIST || dS.w<SURF_DIST) break;\n    }\n    \n    return r;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).w;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).w,\n        GetDist(p-e.yxy).w,\n        GetDist(p-e.yyx).w);\n    \n    return normalize(n);\n}\n\nfloat shadowMap(vec3 ro, vec3 rd){\n    float h = 0.0;\n    float c = 0.001;\n    float r = 1.0;\n    float shadow = 0.5;\n    for(float t = 0.0; t < 30.0; t++){\n        h = GetDist(ro + rd * c).w;\n        if(h < 0.001){\n            return shadow;\n        }\n        r = min(r, h * 16.0 / c);\n        c += h;\n    }\n    return 1.0 - shadow + r * shadow;\n}\n\nvec2 GetLight(vec3 p) {\n    vec3 lightPos = vec3(2,8,3);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l).w;\n    \n    float lambert = max(.0, dot( n, l))*0.1;\n    \n    float shadow = shadowMap(p + n * 0.001, l);\n    \n    return vec2((lambert+dif),max(0.9, shadow)) ;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvec3 zionLogo(vec2 p, vec3 col, vec3 bcol) {\n    vec2 prevP = p;\n    p.y*=0.95;\n    float d = length(p)-0.2;\n    p.x*=1.2;\n    float d2 = length(p)-0.18;\n    d = max(-d2,d);\n    \n    p.x = abs(p.x);\n    p.x -= 0.15;\n    d2 = sdTriangle(p, vec2(0.22,0.05), vec2(0.03,-0.02), vec2(0.0,-0.155));\n    d = min(d,d2);\n    p = prevP;\n    \n    p.x = abs(p.x);\n    d2 = sdTriangle(p-vec2(0.0,0.35), vec2(0.03,-0.2), vec2(0.0,0.0), vec2(0.0,-0.3));\n    d = min(d,d2);\n    p = prevP;\n    \n    d2 = sdBox(p-vec2(0.0,-0.15),vec2(0.012,0.25));\n    d = min(d,d2);\n    \n    p.x = abs(p.x);\n    d2 = sdTriangle(p-vec2(0.0,-0.35), vec2(0.05,0.00), vec2(0.00,-0.03), vec2(0.0,-0.14));\n    d = min(d,d2);\n    p = prevP;\n    \n\tp.x = abs(p.x);\n    p.x -= 0.01;\n    d2 = sdTriangle(p-vec2(0.0,-0.1), vec2(0.1,0.05), vec2(0.0,0.0), vec2(0.0,-0.05));\n    d = min(d,d2);\n    p = prevP;\n    \n    p.x = abs(p.x);\n    d2 = sdTriangle(p-vec2(0.0,-0.27), vec2(0.45,0.2), vec2(0.0,0.0), vec2(0.15,-0.03));\n    d = min(d,d2);\n    p = prevP;\n    \n\tp.x = abs(p.x);\n    p.x -= 0.01;\n    d2 = sdTriangle(p-vec2(0.0,0.02), vec2(0.3,0.2), vec2(0.0,0.0), vec2(0.0,-0.06));\n    d = min(d,d2);\n    p = prevP;\n    \n    col = mix(col,bcol,S(d,-0.002));\n    return col;\n}\n\nvec3 serialNumber(vec2 p, vec3 col, vec3 bcol) {\n    vec2 prevP = p;\n    \n    //ãï¼\n    vec2 p0 = p-vec2(-0.1,0.0);\n    float d = sdBox(p0,vec2(0.1,0.15));\n    float d2 = sdBox(p0,vec2(0.05,0.1));\n    d = max(-d2,d);\n    d2 = sdBox(p0,vec2(0.01,0.2));\n    d = max(-d2,d);\n    \n    // 6\n    vec2 p1 = p-vec2(0.1,0.0);\n    d2 = sdBox(p1-vec2(-0.05,0.0),vec2(0.025,0.15));\n    d = min(d,d2);\n    d2 = sdBox(p1-vec2(0.025,-0.06),vec2(0.075,0.09));\n    d = min(d,d2);\n    d2 = sdBox(p1-vec2(0.015,-0.06),vec2(0.04,0.04));\n    d = max(-d2,d);\n    d2 = sdBox(p1-vec2(0.035,0.125),vec2(0.065,0.025));\n    d = min(d,d2);\n    d2 = sdBox(p1-vec2(-0.02,0.0),vec2(0.01,0.2));\n    d = max(-d2,d);\n    \n    col = mix(col,bcol,S(d,0.0));\n    return col;\n}\n\nvec3 animationLine(vec2 p, vec3 col, float dir) {\n    p.x+=iTime*0.1*dir;\n    p.x = mod(p.x,0.02)-0.01;\n    p*=Rot(radians(45.0*dir));\n    float d = sdBox(p,vec2(0.001,0.05));\n\tcol = mix(col,vec3(1.0),S(d,0.0));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec2 m = iMouse.xy/iResolution.xy;\n    float t = mod(iTime,8000.0);\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 3.5, -1.0);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.yz *= Rot(radians(-45.0));\n    ro.xz *= Rot(radians((sin(t*0.2)*80.0)+180.0));\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,1.1,0), 1.);\n\tvec4 r = RayMarch(ro, rd);\n    \n    if(r.w<MAX_DIST) {\n        vec3 p = ro + rd * r.w;\n    \n        vec2 dif = GetLight(p);\n        col = vec3(dif.x)*r.rgb;\n        col *= dif.y;\n        \n    } else {\n        // background\n        col =.84*max(mix(vec3(1.1)+(.1-length(uv.xy)/3.),vec3(1),.1),0.);\n        \n        uv*=2.0;\n        col = zionLogo(uv-vec2(1.05,0.5),col,vec3(0.7,0.1,0.1));\n        uv = prevUV;\n        uv*=1.5;\n        col = serialNumber(uv-vec2(-0.9,-0.45),col,vec3(0.95));\n    }\n    \n    col = mix(col,vec3(0.1,0.1,0.1),edge);\n    \n    // overlay contents\n    uv = prevUV;\n    col = animationLine(uv-vec2(0.0,-0.49),col,1.0);\n    col = animationLine(uv-vec2(0.0,0.49),col,-1.0);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdfBzj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdffD7", "name": "tunel--otro-v2", "author": "jorge2017a1", "description": "tunel--otro-v2", "tags": ["tunelotrov2"], "likes": 1, "viewed": 56, "date": "1588362995", "time_retrieved": "2024-06-20T20:08:04.742322", "image_code": "//por jorge2017a1-\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define PI 3.14159265358979323846264\n\n\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n\nfloat pi = atan(1.0)*4.0;\nfloat tau = atan(1.0)*8.0;\n\n///------------------------------------\nstruct TObj\n{\n    float tipo;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 path;\n};\n\n\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\n\n//-----------------------------------------\n#define MAXREFLECTIONS 2\n#define MAXITER 64\n//-----------------------------------------\nvec3 ambientColor = vec3(0.05, 0.15, 0.2);\nvec3 diffuseColor = vec3(0.2, 0.6, 0.8);\nvec3 specularColor = vec3(1.0, 1.0, 1.0);\nvec3 lightDir = normalize(vec3(0.0, 4.0, 5.0));\nvec3 spherePos = vec3(0.0, 0.5, 0.0);\n//-----------------------------------\n\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n\n\n\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n//Sphere function\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\n\n// signed\nfloat box(vec3 p, vec3 b)\n{\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat cyl(vec3 p, float r, float h) {\n\treturn max(length(p.xz) - r, abs(p.y) - h);\n}\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n//---------------------------------------------\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\n\n\n\nmat3 rotateX(float rad) {\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, c, s,\n        0.0, -s, c\n    );\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); \n    float sa = sin(angle);\n\treturn v*mat3(\n\t\t1.0, 0.0, 0.0,\n\t\t0.0, ca, -sa,\n\t\t+.0, sa, ca);\n}\n\n\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); \n    float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, -sa, +.0,\n\t\t+sa, +ca, +.0,\n\t\t+.0, +.0, +1.0);\n}\n\nvec2 rotatevec2(vec2 v, float rad) \n{\n    float c = cos(rad);\n    float s = sin(rad);\n    return  v*mat2(\n        c, s,\n        -s, c\n    );\n}\n\n\n\nvec3 rotateQ(vec3 v,  vec3 axis, float rad) \n{\n    float hr = rad / 2.0;\n    float s = sin( hr );\n    vec4 q = vec4(axis * s, cos( hr ));\n    vec3 q2 = q.xyz + q.xyz;\n    vec3 qq2 = q.xyz * q2;\n    vec2 qx = q.xx * q2.yz;\n    float qy = q.y * q2.z;\n    vec3 qw = q.w * q2.xyz;\n\n    return v*mat3(\n        1.0 - (qq2.y + qq2.z),  qx.x - qw.z,            qx.y + qw.y,\n        qx.x + qw.z,            1.0 - (qq2.x + qq2.z),  qy - qw.x,\n        qx.y - qw.y,            qy + qw.x,              1.0 - (qq2.x + qq2.y)\n    );\n}\n\n\n///---------------------------------------------\n\nfloat opU( float d1, float d2 )\n{\n    return min(d2,d2);\n}\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\n\n//----------------------------------------------\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\nvec3 LightShading(vec3 N,vec3 L,vec3 V,vec3 color)\n{\n    vec3 diffuse = max(0.,dot(N,-L))*color;\n    vec3 specular = pow(max(0.,dot(N,normalize(-L-V))),100.)*vec3(1.,1.,1.); \n    return diffuse + specular;\n}\n\n    \n    \n//-------------------------------------------------\n\n\nmat2 rotate(float a) \n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\n//------------------------------------------\n\nfloat GetDist(vec3 p  ) \n{\t\n\n\tfloat d, dif1, dif2;\n    vec3 pp, p2;\n    d=999.9;\n    pp=p;\n\n \n    float planeDist1 = p.y-2.0;  //piso inf\n    float planeDist1sup = 20.0-p.y;  //piso sup\n    float planeDist2 = p.x+10.0; //pared izq\n    float planeDist3 = 10.0-p.x;  //pared der\n    //float planeDist4 = -p.z+30.0;  //pared atras\n    float planeDist4 =iTime*2.0 -p.z+30.0;  //pared atras\n    \n   \n    vec2 res;\n    res = vec2(9999, 0);\n    \n    p.z=mod( p.z, 10.0)-4.0;\n    \n    \n    vec3 pPosB=vec3(1,1,1);\n \n    float tiempoGiro=iTime*0.25;\n\n    \n    p2=p;\n    p2 =rotate_z(p2, iTime);\n    float  sdb01= sdBox(p2-pPosB, vec3(15.0,15.0,2.0) );\n    float  sdb02= sdBox(p2-pPosB, vec3(10.0,10.0,3.0) );\n    \n    \n    vec3 p3=p;\n    pPosB=vec3(1.0,1.,6.);\n     //p3 =rotate_z(p, iTime+45.0*3.141516/180.0);\n     //p3 =rotate_z(p, iTime+1.5);\n     p3 =rotate_z(p, iTime+iTime/2.0);\n    float  sdb11= sdBox(p3-pPosB, vec3(15.0,15.0,2.0) );\n    float  sdb12= sdBox(p3-pPosB, vec3(10.0,10.0,3.0) );\n    \n    \n    float  sdf1 =differenceSDF(sdb01, sdb02);\n    float  sdf2 =differenceSDF(sdb11, sdb12);\n     \n    \n    res =opU(res, vec2(sdf1,2));\n    res =opU(res, vec2(sdf2,21));\n    res =opU(res, vec2(planeDist4,0));\n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n    \n    return d;\n}\n\n\n\n///----------------------------------------------------------\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n\tfloat dO=0.2;\n    //Determines size of shadow\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = ro + rd*dO;\n        \n        float dS = GetDist(p);\n        \n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) \n        {\n            //mObj.dist=dO; \t\n            mObj.p=p; \t\n            gres2 = vec2(dO,dS); \n            break;\n    \t}    \n        \n    }\n    \n    return dO;\n}\n\n\n//---------------------------------------------------\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n\nfloat GetLightPar(vec3 p, vec3 plig) {\n    vec3 lightPos = plig;\n    //Determine movement of light ex. shadow and light direction and diffusion\n    //lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat saturate(float f)\n{\n\treturn clamp(f,0.0,1.0);\n}\n\n    \n\n#define offset1 4.7\n#define offset2 4.6\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) \n{\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\n\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tif(i==0 )\n    {\n    \n        \n      return vec3(0.0,0.0,0.0);\n    }\n    \n    if(i== 1 )\n    {\n        \n        //return vec3(1, 0.5, 0);\n        \treturn vec3(1.0,0.0,0.0);\n        } \n    if(i== 2 )\n    {\n        //return vec3(1.0, 1.0, 1.0);\n        \treturn vec3(0.0,1.0,0.0);\n        } \n    if(i== 3 )\n    {\n        //return vec3(247./255., 168./255.,  184./255.); \n        \treturn vec3(0.0,0.0,1.0);\n       } \n    if(i== 4 )\n    {\n        \n        //return vec3(0, 1, 1);\n        \treturn vec3(0.0,1.0,1.0);\n        } \n    if(i== 5 )\n    {\n        //return vec3(85./255., 205./255., 252./255.);\n        return vec3(1.0,0.0,1.0);\n        \n        } \n    if(i== 6 )\n    {\n        \n        ///return  vec3(0.5, 0.8, 0.9);\n        return vec3(1.0,0.5,1.0);\n        } \n        \n    if(i== 7 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n       } \n    if(i== 8 )\n    {\n       \n        \n        return vec3(0.425, 0.56, 0.9); \n       } \n    if(i== 9 )\n    {\n        \n        return vec3(0.5, 0.6, 0.6); \n     } \n    if(i== 10 )\n    {\n        return vec3(0.0, 1.0, 0.0);\n    } \n    \n    if(i== 11 )\n    {\n        return vec3(0.25, 0.25, 0.25);\n    } \n    \n     if(i== 15 )\n    {\n    \t\treturn vec3(1.0,0.0,1.);\n       } \n     if(i== 16 )\n    {\n    \t\treturn vec3(1.0,1.0,0.0);\n     } \n    \n    \n    \n    if(i== 21 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*0.12;\n            marbleP.z += sin(p.y*23.0)*0.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.3);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.4,0.4,0.6),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n    \n    \n    \n     if(i== 23)\n    {\n    \n        \n        return  vec3(0.425, 0.16, 0.6);\t\n        \t\n\t} \n    \n    \n    \n    if(i== 24)\n    {\n      float size = (-mObj.uv.y+.1)/2.5;\n     vec3 color = vec3(0.,0.,0.);\n     color += vec3(mod(floor(mObj.uv.x/size+sin(iTime)) + floor(mObj.uv.y*20./size+iTime),2.)-.8-mObj.uv.y);\n\n     // Lightsource falloff on floor\n     color *= vec3(smoothstep(0.,1.,1.-length(vec2(.2-mObj.uv.x/6.,.6+mObj.uv.y/1.5))));\n        return color;\n\t}    \n    \n    \n    if(i== 25)\n    {\n      float size = (-mObj.p.y+.1)/2.5;\n     vec3 color = vec3(0.,0.,0.);\n     color += vec3(mod(floor(mObj.p.x/size) + floor(mObj.p.y*20./size),2.)-.8-mObj.p.y);\n\n     // Lightsource falloff on floor\n     color *= vec3(smoothstep(0.,1.,1.-length(vec2(.2-mObj.p.x/6.,.6+mObj.p.y/1.5))));\n        return color;\n\t} \n    \n    if(i== 26)\n    {\n        // checkerboard hack\n\t\t\tvec2 cb = floor(mObj.p.xz);\n\t\t\tfloat cb2 = mod(cb.x*1.2 + cb.y, 2.);\n        \treturn vec3(1.4 + 0.1*cb2, 0.3 + 0.85*cb2, 0.35 - 0.3*cb2)*0.8;\n            \n    }   \n    \n    \n    \n    if(i== 27)\n    {\n      vec3 outColor = vec3(0.0);\n      float sinus1 = sin(mObj.uv.x*5.1 +iTime*0.5) * 0.1 - 0.2;\n      float land1 = step(sinus1, mObj.uv.y);\n      vec3 landColor1 = vec3(0.2, 0.4, 0.3);\n      outColor = mix(outColor, landColor1, 1.0 - land1);\n        return outColor;\n    }\n    \n    \n    if (i== 28)\n     {   \n    \tvec3 position=mObj.p;\n        vec3 normal=mObj.normal;\n    \t//position *= scale;\n         position *= 0.25;\n    \t\n    \t//vec3 color = vec3(1.0);\n        vec3 color = vec3(0.98,0.86,0.4);\n    \n    \tcolor = color * 0.75 + 0.25;\n    \tcolor *= normal * .25 + .75;\n    \tfloat checker = sin(position.x * pi * 4.0) * sin(position.y * pi * 4.0) * sin(position.z * pi * 4.0);\n    \tcolor *= step(0.0,checker) * 0.25 + 0.75;\n         return color;\n    }\n    \n    \n    \n}\n\n///--------------------------------------------\n\n\n\n\n\n\n// phong shading\nvec3 p_shadingv2( vec3 v, vec3 n, vec3 eye, vec3 plight_pos1,  vec3 plight_color1 )\n{\n\t// ...add lights here...\n\t\n\tfloat shininess = 16.0;\n\t\n\tvec3 final = vec3( 0.0 );\n\t\n\tvec3 ev = normalize( v - eye );\n\tvec3 ref_ev = reflect( ev, n );\n\t\n\t// light 0\n\t{\n\t\n\t\tvec3 vl = normalize( plight_pos1 - v );\n\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n\t\t\n\t\tfinal += plight_color1 * ( diffuse + specular ); \n\t}\n\t\n\t\n\n    return (final);\n}\n\n\n\n\nvec3 camera(vec3 ro, vec2 uv, vec3 ta) {\n\tvec3 fwd = normalize(ta - ro);\n\tvec3 left = cross(vec3(0, 1, 0), fwd);\n\tvec3 up = cross(fwd, left);\n\treturn normalize(fwd + uv.x*left + up*uv.y);\n}\n\n\n//-------------------------------------------\nvec3 Shade(vec3 position, vec3 normal, vec3 direction, vec3 camera)\n{\n    //position *= scale;\n    position *= 0.125;\n    vec3 color = vec3(1.0);\n    \n    color = color * 0.75 + 0.25;\n    \n    color *= normal * .25 + .75;\n\n    float ambient = 0.1;\n    float diffuse = 0.5 * -dot(normal,direction);\n    float specular = 1.0 * max(0.0, -dot(direction, reflect(direction,normal)));\n    \n    color *= vec3(ambient + diffuse + pow(specular,5.0));\n\n    color *= smoothstep(12.0,6.0,length(position));\n    \n    return color;\n}\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n    \n\n\tlight_pos1   = vec3( -20.0, -20.0, -iTime*2.0);\n \tlight_color1 = vec3( 0.3, 0.2, 1.0 );\n\n \tlight_pos2   = vec3( 20.0,20.0, 20.0 +iTime*2.0 );\n \tlight_color2 = vec3( 1.0, 0.7, 0.7);\n    \n    vec3 ro = vec3(0.0,0.0,-40.0+iTime*2.0);\n\t//ro =get_mouse(ro);\n    vec3 rd = normalize( vec3(uv,1.0));\n    \n \n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    mObj.uv=uv;\n    mObj.rd=rd;\n    mObj.ro=ro;\n\n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n  \n    vec3 p = (ro + rd * d ); \n    glpRoRd=p;\n    mObj.p=p;\n    \n    float dif=1.5;\n   \n    \n    mObj.dist =d;\n    vec3 colobj;\n    \n    vec3 nor= GetNormal( p);\n    mObj.normal=nor;\n    colobj=getSphereColor(int( Obj.tipo));\n    \n    \n    \n    \n    \n    vec3 col2=vec3(0.0);\n    col2+= p_shadingv2( p, nor, ro, light_pos1, light_color1 );\n    col2+= p_shadingv2( p, nor, ro, light_pos2, light_color2 );\n    col2=(col2)/2.0;\n   \n    col2= colobj*col2;\n    col= col2*dif;\n    \n  \n    \n    \n    col = pow(col, vec3(1.0/2.2));  \n    \n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdffD7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdffDj", "name": "This is a good sin copy", "author": "RubinReality", "description": "This is a copy of \"this is a good sin :0\" by gurudevbk", "tags": ["sin"], "likes": 0, "viewed": 218, "date": "1589071876", "time_retrieved": "2024-06-20T20:08:04.978622", "image_code": "// Copy of \"this is a good sign :0\" by gurudevbk\n// returns true if a point [uv] is within the circle defined by [origin, radius]\nbool circle(vec2 uv, vec2 origin, float radius) {\n \treturn (length(uv-origin) < radius);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float thickness = 0.1;\n    float radius = 0.3;\n    vec2 origin = vec2(0.5);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n\n    vec3 col = vec3(0.5,0.5,0.36);\n    \n    // Time varying pixel color\n    if (abs(length(uv-origin) - radius) < abs(sin(iTime)/3.)) {\n    \tcol = 0.5 + 0.5*cos(iTime+length(uv-radius)+col);\n    \tcol.r += sin(iTime)+cos(iTime);\n    }\n    \n    else {\n    \tcol = 0.5 + 0.5*sin(iTime+length(uv-radius)+col);\n        col.r += sin(iTime)+cos(iTime);\n    }\n    \n    col.g /= col.r;\n    \n    col.g *= 0.05;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdffDj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdffR2", "name": "Individual Project 2", "author": "JonathanAlderson", "description": "Showing some simple examples of plane deformations", "tags": ["2d", "plane", "perspective"], "likes": 2, "viewed": 61, "date": "1588608701", "time_retrieved": "2024-06-20T20:08:05.257442", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - .5*iResolution.xy)/(min(iResolution.x, iResolution.y));\n\t\n    // cycles between the options\n    \n    float opt = floor(mod(iTime*.3, 4.0));\n    float shadow = 0.8; \n    \n    //angle\n    float a = atan(uv.y, uv.x);\n    \n    if(opt == 3.0){ a += 0.3/length(uv); }\n    \n    float r = length(uv);\n        \n    if(opt == 2.0){ r *= sin(a*3.)*.5 + 4.; }\n    if(opt == 3.0){ r *= sin(a*10.)*.5 + 4.; }\n    \n    if(opt == 0.0){ uv.y = r; }\n    else { uv.y = 1./r; }\n    \n    uv.x = a;\n    \n\n    \n    // animate\n    uv.y -= 0.1*iTime;\n    \n    // repeating grid\n    float w = 0.02;\n    uv *= 5.0;\n    uv = mod(uv + .5, 1.0) - .5;\n    vec3 col = vec3(uv.x, uv.y, 0.);\n   \t\n    // draw white lines\n    if(uv.x > -w && uv.x < w){ col += vec3(1.0); }\n    if(uv.y > -w && uv.y < w){ col += vec3(1.0); }\n    \n    // shading in the middle\n    col *= smoothstep(0., shadow, r);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdffR2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdffRf", "name": "anillo-cubos-v02", "author": "jorge2017a1", "description": "anillo-cubos-v02", "tags": ["anillocubosv02"], "likes": 0, "viewed": 75, "date": "1588708741", "time_retrieved": "2024-06-20T20:08:08.324363", "image_code": "//por jorge2017a1-\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define PI 3.14159265358979323846264\n\n\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n\nfloat pi = atan(1.0)*4.0;\nfloat tau = atan(1.0)*8.0;\n\n///------------------------------------\nstruct TObj\n{\n    float tipo;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 path;\n};\n\n\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\n\n//-----------------------------------------\n#define MAXREFLECTIONS 2\n#define MAXITER 64\n//-----------------------------------------\nvec3 ambientColor = vec3(0.05, 0.15, 0.2);\nvec3 diffuseColor = vec3(0.2, 0.6, 0.8);\nvec3 specularColor = vec3(1.0, 1.0, 1.0);\nvec3 lightDir = normalize(vec3(0.0, 4.0, 5.0));\nvec3 spherePos = vec3(0.0, 0.5, 0.0);\n//-----------------------------------\n\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n\n\n\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\n\n\n//---------------------------------------------\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); \n    float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, -sa, +.0,\n\t\t+sa, +ca, +.0,\n\t\t+.0, +.0, +1.0);\n}\n\n\n///---------------------------------------------\n\nfloat opU( float d1, float d2 )\n{\n    return min(d2,d2);\n}\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\n\n//----------------------------------------------\n\nvec3 LightShading(vec3 N,vec3 L,vec3 V,vec3 color)\n{\n    vec3 diffuse = max(0.,dot(N,-L))*color;\n    vec3 specular = pow(max(0.,dot(N,normalize(-L-V))),100.)*vec3(1.,1.,1.); \n    return diffuse + specular;\n}\n\n    \n    \n//-------------------------------------------------\n\n\nmat2 rotate(float a) \n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\n\n\nfloat GetDist(vec3 p  ) \n{\t\n\n      float d;\n    float dif1;\n    float dif2;\n    \n    d=999.9;\n \n    \n   vec3 pp, p2;\n    pp=p;\n    p2=p;\n    \n \n    float planeDist1 = p.y-2.0;  //piso inf\n    float planeDist1sup = 20.0-p.y;  //piso sup\n    float planeDist2 = p.x+10.0; //pared izq\n    float planeDist3 = 10.0-p.x;  //pared der\n    float planeDist4 = -p.z+30.0;  //pared atras\n   \n    vec2 res;\n    res = vec2(9999, 0);\n \n    p.y=mod( p.y,15.0)+6.0;\n \n    \n    // float num;\n    #define num 15.0\n    float gr;\n    float sdfintdo;\n    sdfintdo=999.0;\n    float rx, ry;\n    float Incgrados;\n    \n    \n    ///num =20.0;\n     //num =15.0;\n    \n    Incgrados=360./num;\n    float angs=360./num*PI/180.0;\n    Incgrados=Incgrados*PI/180.0;\n    \n    \n\n    vec3 pr =rotate_y(p, angs);\n   \n    \n    for(float ii=0.0; ii<num; ii++) \n\t{\n       p=rotate_y(p, angs);\n   \n       float sdcp2= sdBox( p-vec3(30.0,15.0,1.0), vec3(5.0,2.5,5.0) ); \n   \t   sdfintdo = min(sdfintdo,sdcp2);\n     \n    }\n    \n    \n    \n   res =opU(res, vec2(sdfintdo,8)); \n  \n    res =opU(res, vec2(1.0,4));\n  \n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n    \n    return d;\n}\n\n\n\n///----------------------------------------------------------\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n\tfloat dO=0.2;\n    //Determines size of shadow\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = ro + rd*dO;\n        \n        float dS = GetDist(p);\n        \n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) \n        {\n            //mObj.dist=dO; \t\n            mObj.p=p; \t\n            gres2 = vec2(dO,dS); \n            break;\n    \t}    \n        \n    }\n    \n    return dO;\n}\n\n\n//---------------------------------------------------\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n\nfloat GetLightPar(vec3 p, vec3 plig) {\n    vec3 lightPos = plig;\n    //Determine movement of light ex. shadow and light direction and diffusion\n    //lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat saturate(float f)\n{\n\treturn clamp(f,0.0,1.0);\n}\n\n    \n\n#define offset1 4.7\n#define offset2 4.6\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) \n{\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\n\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tif(i==0 )\n    {\n    \n        \n      return vec3(0.0,0.0,0.0);\n    }\n    \n    if(i== 1 )\n    {\n        \n        //return vec3(1, 0.5, 0);\n        \treturn vec3(1.0,0.0,0.0);\n        } \n    if(i== 2 )\n    {\n        //return vec3(1.0, 1.0, 1.0);\n        \treturn vec3(0.0,1.0,0.0);\n        } \n    if(i== 3 )\n    {\n        //return vec3(247./255., 168./255.,  184./255.); \n        \treturn vec3(0.0,0.0,1.0);\n       } \n    if(i== 4 )\n    {\n        \n        //return vec3(0, 1, 1);\n        \treturn vec3(0.0,1.0,1.0);\n        } \n    if(i== 5 )\n    {\n        //return vec3(85./255., 205./255., 252./255.);\n        return vec3(1.0,0.0,1.0);\n        \n        } \n    if(i== 6 )\n    {\n        \n        ///return  vec3(0.5, 0.8, 0.9);\n        return vec3(1.0,0.5,1.0);\n        } \n        \n    if(i== 7 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n       } \n    if(i== 8 )\n    {\n       \n        \n        return vec3(0.425, 0.56, 0.9); \n       } \n    if(i== 9 )\n    {\n        \n        return vec3(0.5, 0.6, 0.6); \n     } \n    if(i== 10 )\n    {\n        return vec3(0.0, 1.0, 0.0);\n    } \n    \n    if(i== 11 )\n    {\n        return vec3(0.25, 0.25, 0.25);\n    } \n    \n     if(i== 15 )\n    {\n    \t\treturn vec3(1.0,0.0,1.);\n       } \n     if(i== 16 )\n    {\n    \t\treturn vec3(1.0,1.0,0.0);\n     } \n    \n     if(i== 17 )\n    {\n    \treturn vec3(0.8,0.8,0.8);\n     } \n    \n    \n    if(i== 21 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*0.12;\n            marbleP.z += sin(p.y*23.0)*0.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.3);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.4,0.4,0.6),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n    \n    \n    \n     if(i== 23)\n    {\n    \n        \n        return  vec3(0.425, 0.16, 0.6);\t\n        \t\n\t} \n    \n    \n    \n    if(i== 24)\n    {\n      float size = (-mObj.uv.y+.1)/2.5;\n     vec3 color = vec3(0.,0.,0.);\n     color += vec3(mod(floor(mObj.uv.x/size+sin(iTime)) + floor(mObj.uv.y*20./size+iTime),2.)-.8-mObj.uv.y);\n\n     // Lightsource falloff on floor\n     color *= vec3(smoothstep(0.,1.,1.-length(vec2(.2-mObj.uv.x/6.,.6+mObj.uv.y/1.5))));\n        return color;\n\t}    \n    \n    \n    if(i== 25)\n    {\n      float size = (-mObj.p.y+.1)/2.5;\n     vec3 color = vec3(0.,0.,0.);\n     color += vec3(mod(floor(mObj.p.x/size) + floor(mObj.p.y*20./size),2.)-.8-mObj.p.y);\n\n     // Lightsource falloff on floor\n     color *= vec3(smoothstep(0.,1.,1.-length(vec2(.2-mObj.p.x/6.,.6+mObj.p.y/1.5))));\n        return color;\n\t} \n    \n    if(i== 26)\n    {\n        // checkerboard hack\n\t\t\tvec2 cb = floor(mObj.p.xz);\n\t\t\tfloat cb2 = mod(cb.x*1.2 + cb.y, 2.);\n        \treturn vec3(1.4 + 0.1*cb2, 0.3 + 0.85*cb2, 0.35 - 0.3*cb2)*0.8;\n            \n    }   \n    \n    \n    \n    if(i== 27)\n    {\n      vec3 outColor = vec3(0.0);\n      float sinus1 = sin(mObj.uv.x*5.1 +iTime*0.5) * 0.1 - 0.2;\n      float land1 = step(sinus1, mObj.uv.y);\n      vec3 landColor1 = vec3(0.2, 0.4, 0.3);\n      outColor = mix(outColor, landColor1, 1.0 - land1);\n        return outColor;\n    }\n    \n    \n    if (i== 28)\n     {   \n    \tvec3 position=mObj.p;\n        vec3 normal=mObj.normal;\n    \t//position *= scale;\n         position *= 0.25;\n    \t\n    \t//vec3 color = vec3(1.0);\n        vec3 color = vec3(0.98,0.86,0.4);\n    \n    \tcolor = color * 0.75 + 0.25;\n    \tcolor *= normal * .25 + .75;\n    \tfloat checker = sin(position.x * pi * 4.0) * sin(position.y * pi * 4.0) * sin(position.z * pi * 4.0);\n    \tcolor *= step(0.0,checker) * 0.25 + 0.75;\n         return color;\n    }\n    \n    \n    \n}\n\n///--------------------------------------------\n\n\n\n\n\n\n// phong shading\nvec3 p_shadingv2( vec3 v, vec3 n, vec3 eye, vec3 plight_pos1,  vec3 plight_color1 )\n{\n\t// ...add lights here...\n\t\n\tfloat shininess = 16.0;\n\t\n\tvec3 final = vec3( 0.0 );\n\t\n\tvec3 ev = normalize( v - eye );\n\tvec3 ref_ev = reflect( ev, n );\n\t\n\t// light 0\n\t{\n\t\n\t\tvec3 vl = normalize( plight_pos1 - v );\n\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n\t\t\n\t\tfinal += plight_color1 * ( diffuse + specular ); \n\t}\n\t\n\t\n\n    return (final);\n}\n\n\n\n\nvec3 camera(vec3 ro, vec2 uv, vec3 ta) {\n\tvec3 fwd = normalize(ta - ro);\n\tvec3 left = cross(vec3(0, 1, 0), fwd);\n\tvec3 up = cross(fwd, left);\n\treturn normalize(fwd + uv.x*left + up*uv.y);\n}\n\n\n//-------------------------------------------\nvec3 Shade(vec3 position, vec3 normal, vec3 direction, vec3 camera)\n{\n    //position *= scale;\n    position *= 0.125;\n    vec3 color = vec3(1.0);\n    \n    color = color * 0.75 + 0.25;\n    \n    color *= normal * .25 + .75;\n   \n    float ambient = 0.1;\n    float diffuse = 0.5 * -dot(normal,direction);\n    float specular = 1.0 * max(0.0, -dot(direction, reflect(direction,normal)));\n    \n    color *= vec3(ambient + diffuse + pow(specular,5.0));\n\n    color *= smoothstep(12.0,6.0,length(position));\n    \n    return color;\n}\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n \n//luz eje y\nlight_pos1   = vec3( -10.0,25.0+iTime*6.0, -10);\nlight_color1 = vec3( 0.3, 0.2, 1.0 );\n//light_color1 = vec3(1.0 );\n\n//light_pos2   = vec3( 0.0,-15.0+iTime*6.0, 0.0  );\nlight_pos2   = vec3( 0.0,-15.0+iTime*6.0, -60.0  );\nlight_color2 = vec3( 1.0, 1.0, 1.0);\n    \n\n    vec3 ro = vec3(0.0,15.0+iTime*6.0,-50.0);  //-eje y  //bien\n    //ro =get_mouse(ro);\n    vec3 rd = normalize( vec3(uv,1.0));\n    \n \n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    mObj.uv=uv;\n    mObj.rd=rd;\n    mObj.ro=ro;\n\n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n  \n    vec3 p = (ro + rd * d ); \n    glpRoRd=p;\n    mObj.p=p;\n    \n    float dif=1.5;\n    \n  \n    mObj.dist =d;\n    vec3 colobj;\n    \n    vec3 nor= GetNormal( p);\n    mObj.normal=nor;\n    colobj=getSphereColor(int( Obj.tipo));\n    \n    \n    \n    \n    \n    vec3 col2=vec3(0.0);\n    col2+= p_shadingv2( p, nor, ro, light_pos1, light_color1 );\n    col2+= p_shadingv2( p, nor, ro, light_pos2, light_color2 );\n    col2=(col2)/2.0;\n    \n    col2= colobj*col2;\n    col= col2*dif;\n    \n  \n    \n    \n    col = pow(col, vec3(1.0/2.2));  \n    \n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdffRf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdffW7", "name": "heightmap version mandelbrot", "author": "henry", "description": "attempt to view mandel as a heightmap, can definitely see the babymandels springing up and down. had a go with IQ's smoother code, also a bit aliased: https://www.shadertoy.com/view/3dXBD7", "tags": ["fractspheres"], "likes": 4, "viewed": 137, "date": "1588330503", "time_retrieved": "2024-06-20T20:08:09.445578", "image_code": "// Fork of \"fract_spheres\" by foran. https://shadertoy.com/view/wljSzR\n// 2020-05-01 10:27:11\n\n\n\n\n#ifdef GL_ES\nprecision mediump float;\nconst vec3 df = vec3(0.05, 0.0, 0.0);\n#else\nconst vec3 df = vec3(0.01, 0.0, 0.0);\n#endif\n\n#define AUTO_CAMERA\n\n// input\n\n// Constants\n// Camera\nconst vec3 origin = vec3(0, 0, 0);\nconst int steps = 64;\nconst vec3 sun = vec3(1.0, .5, -1.0);\n\nconst int miterations = 32;\n\n// Ball\nstruct Ball \n{\n\tvec3 pos;\n\tfloat size;\n};\n\nconst Ball ball = Ball(vec3(10, 10, -10.), 0.0002);\n\nstruct Balls\n{\n\tvec3 dir;\n\tvec3 p;\n\tfloat dist;\n};\n\t\nconst Balls balls = Balls(vec3(1, 0, 0), vec3(0, 0, 0), 2.0);\n\n// Floor\n\nstruct Plane \n{\n\tvec3 n;\n\tfloat d;\n};\n\t\nconst Plane plane = Plane(vec3(0, 1, 0), -1.0);\n\n// Distance\nstruct Dist\n{\n\tfloat dist;\n\tint id;\n};\n\n\t\nDist and(Dist a, Dist b)\n{\n\tif (a.dist < b.dist) \n\t{\n\t\treturn a;\n\t}\n\t\n\treturn b;\n}\n\nDist fBall(Ball ball, vec3 p) \n{\n\treturn Dist(length(ball.pos - p) - ball.size, 0);\n}\n\nBall get(Balls balls, float t) \n{\n\tfloat a = abs(mod(t, 3.0) - 1.0);\n\tvec3 p = balls.p + balls.dir * t * balls.dist + a * a * vec3(0, -0.15, 0);\n\treturn Ball(p, ball.size);\n}\n\nDist fBalls(Balls balls, vec3 p) \n{\n\tfloat t = dot(p - balls.p, balls.dir) / balls.dist;\n\tfloat t0 = t - fract(t + fract(iTime) * 1.0);\n\tfloat t1 = t0 + 1.0;\n\n\treturn and(\n\t\tfBall(get(balls, t0), p),\n\t\tfBall(get(balls, t1), p));\n}\n\nfloat mandel(vec2 c)\n{\n\tvec2 z = c;\n\n\tfor(int i = 0; i < miterations; ++i)\n\t{\n\t\tz = vec2(z.x*z.x - z.y*z.y, 1.5*z.x*z.y) + c;\n\t\tif (length(z) > 40.0) return float(i) / float(miterations);\n\t}\n\t\n\treturn 0.0;\n}\n\nDist fPlane(Plane plane, vec3 p)\n{\n\treturn Dist(dot(plane.n, p) - plane.d +sign(sin(iTime)) *mandel(p.xz), 1);\n}\n\nDist f(vec3 p) \n{\n\treturn and(\n\t\tfBalls(balls, p),\n\t\tfPlane(plane, p));\n}\n\nvec3 grad(vec3 p) \n{\n\tfloat f0 = f(p).dist;\n\n\treturn normalize(vec3(\n\t\tf(p + df.xyz).dist,\n\t\tf(p + df.yxz).dist,\n\t\tf(p + df.yzx).dist) - f0);\n}\n\n\n\nvec3 floorTexture(vec3 p) \n{\n\tmat2 rot = mat2(vec2(1, 1), vec2(1, -1));\n\tvec2 c = 1. * (p.xz + vec2(0,0)) * 1.;\n\tfloat i = mandel(c);\n\treturn clamp(vec3(i * 10.0, i * i *10.0, i*i*i*5.0).zyx, vec3(0,0,0), vec3(2,2,2));\n}\n\n\nvec4 shade(vec3 p, vec3 ray, int id) \n{\n\tvec3 n = grad(p);\n\tfloat diffuse = clamp(dot(normalize(sun), n), 0.0, 1.0);\n\n\tvec3 color;\n\tfloat ref;\n\n\tif (id == 0) \n\t{\n\t\tcolor = vec3(0,1,0);\n\t\tref = 0.1;\n\t} \n\telse \n\t{\n\t\tcolor = floorTexture(p);\n\t\tref = 0.5;\n\t}\n\n\treturn vec4(color * diffuse*2.5, 1) * ref;\n}\n\nvec4 combine(vec4 a, vec4 b) \n{\n\treturn a + b * (1.0 - a.w); \n}\n\nvec4 sky(vec3 ray) \n{\n\tfloat sun = dot(ray, normalize(sun));\n\tsun = (sun > 0.0) ? pow(sun, 150.0) * 3.0 : 0.0;\n\tfloat horizon = 1.0 - abs(ray.y);\n\tvec3 blue = vec3(0.1, 0.3, 0.6);\n\tvec3 red = vec3(0.6, 0.3, 0.) * 2.0;\n\treturn vec4(vec3(0.9, 0.8, 0.5) * sun + blue * horizon + red * pow(horizon, 8.0), 1);\n}\n\nvec4 trace(vec3 origin, vec3 ray) \n{\n\tvec3 p = origin;\n\tDist dist = Dist(10.0, 2);\n\tvec4 result = vec4(0, 0, 0, 0);\n\n\tfor(int i = 0; i < steps; ++i) \n\t{\n\t\tdist = f(p);\n\t\tif (dist.dist > 0.01) \n\t\t{ \n\t\t\tp += ray * dist.dist;\n\t\t\tfloat absorb = exp(-dist.dist * 0.05);\n\t\t\tvec4 s = sky(ray) * (1.0 - absorb);\n\t\t\t\n\t\t\tresult = combine(result, s);\n\t\t}\n\t\telse if (result.w < 0.99) \n\t\t{\n\t\t\tvec3 n = grad(p);\n\t\t\tvec4 s = shade(p, ray, dist.id);\n\t\t\tray = reflect(ray, n);\n\t\t\tp += n * 0.01;\n\t\t\t\n\t\t\tresult = combine(result, s);\n\t\t} \n\t\telse \n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn combine(result, sky(ray));\n}\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n\tfloat scale = 1.0 / max(iResolution.x, iResolution.y);\n\tvec3 ray = vec3((fragCoord.xy - iResolution.xy / 2.0) * scale, 1);\n\n//#ifdef AUTO_CAMERA\n\tfloat yaw = cos(iTime*0.001) * -0.25 + 0.5;\n\tfloat angle = iTime * 0.05;\n//#else\n\t//float yaw = iMouse.y - 0.15;\n\t//float angle = iMouse.x * 8.0;\n//#endif\n\t\n\tvec3 from = (vec3(sin(angle), 0, cos(angle)) * cos(yaw) + vec3(0, sin(yaw) * 1.0, 0)) * 5.0; \n\t//vec3 from = origin + vec3((iMouse.xy - vec2(0.5,0.0)) * vec2(15.0, 3.0), -5);\n\tvec3 to = vec3(0, -1, 0);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 dir = normalize(to - from);\n\tvec3 left = normalize(cross(up, dir));\n\tmat3 rot = mat3(left, cross(dir, left), dir);\n\n\tfragColor = trace(from, rot * normalize(ray));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdffW7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdffWM", "name": "Peek-a-boo.", "author": "Logos", "description": "A sort of tunnel made of stack of julias.\n", "tags": ["2d", "2d", "fractal", "julia", "polynomial"], "likes": 4, "viewed": 125, "date": "1588336839", "time_retrieved": "2024-06-20T20:08:09.876052", "image_code": "// Created by Robert Åmietana (Logos) - 01.05.2020\n// Bielsko-BiaÅa, Poland, UE, Earth, Sol, Milky Way, Local Group, Laniakea :)\n\n\n\n//--- program parameters ---//\n\nconst float\tDEPTH\t\t= 48.0;\nconst float\tITERATIONS\t= 64.0;\nconst float SKIN_SIZE   =  6.0;\n\n\n//--- fractal formula (julia 3rd degree polynomial) ---//\n\nfloat julia(vec2 p, vec2 parameter)\n{\n\tfor (float i = 1.0; i <= ITERATIONS; i++)\n    {\n\t\tvec2 o = p;\n        \n\t\tp = vec2(p.x*p.x - p.y*p.y, 2.0*p.x*p.y);\n\t\tp = vec2(p.x*o.x - p.y*o.y + parameter.x, o.x*p.y + p.x*o.y + parameter.y);\n\n        if (dot(p, p) > 4.0) return i;\n\t}\n\t\n\treturn 0.0;\t\n}\n\n\n//--- coloring function ---//\n\nvec4 color(float n, float i)\n{\n    return SKIN_SIZE < n?\n        \n        vec4(vec3(1.0), 1.0)\n        \n\t\t\t:\n    \n\t\tvec4(0.6 + 0.4*sin(0.874*iTime + (1.22 - 0.4*sin(0.88*iTime))*i),\n             0.6 + 0.4*sin(0.675*iTime + 1.26*i), \n             0.6 + 0.4*cos(0.543*iTime + 0.84*i),\n             1.0);\n}\n\n\n//--- main program ---//\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 pixel_coord = 1.0*(fragCoord - 0.5*iResolution.xy) / iResolution.y;\n    \n    pixel_coord *= 0.9 - 0.3*sin(0.21*iTime);\n    \n    \n\tfor (float i = 0.0; i < DEPTH; i++)\n    {\n        float f = 0.12*i;\n        \n\t\tvec2 parameter = vec2(0.35*cos(iTime-f) + 0.1*sin(0.234*iTime+0.68*f),\n                              0.25*sin(iTime+1.4*f) + 0.11*sin(0.431*iTime-f));\n        \n        float n = julia(pixel_coord, parameter);\n        \n        if (0.0 < n)\n        {\n            fragColor = color(n, i);\n            return;\n        }\n        \n        pixel_coord *= 1.05;\n    }\n    \n    \n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdffWM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdffzS", "name": "Day14: Cubic Patch (4x Faster)", "author": "fluxatron", "description": "My attempts to make my Day13 shader run faster. Thanks to all who gave me pointers! \nhttps://www.shadertoy.com/view/wslBDM\n\nSee the benchmarking notes in code for my journey.\n", "tags": ["bezier", "cubic", "patch"], "likes": 3, "viewed": 105, "date": "1588743531", "time_retrieved": "2024-06-20T20:08:12.088377", "image_code": "#define DIMX_VERTS 3\n#define DIMZ_VERTS 7\n\n#define MAX_STEPS 50\n#define MAX_DIST 50.0\n#define SURFACE_DIST 0.005\n\n\n/* Benchmarking notes\n\n    DIM_VERTS  Compile time  Fps     Res       Notes:\n    4          5.0s          ~27-30  1200x675  Baseline performance\n    4          5.6s          ~34-37  1200x675  Removed _vert array. New tri stripping algo.\n\t4          0.7s          ~38-40  1200x675  Removed _tris array. Sampling bezier and building tris at dist calculation time. Less sqrts.\n\t4          0.6s          ~50     1200x675  Removed 7 mat3*vec3 by rotating camera instead of patch.\n\t4          0.6s          ~52     1200x675  Factorized the BezierSample() fn. 2-3fps maybe.\n\t4          0.8s          ~70-103 1200x675  Bounds test of surface controls avoids many triangle mesh tests\n\t3x5        0.8s          ~85-118 1200x675  More tesseltation where detail is required. 3x5=15 verts vs 4x4=16. Greater perceived detail.\n\t3x5        0.5s          ~85-125 1200x675  Using normal computing technique from iq and co. to improve compile times\n\t\n\tRunning 4x faster now but I've a few optimisations to go\n*/\n\n\n// TYPES ///////////////////////////////////////////////////////////////////////////////////////////////////\n\nstruct Tri\n{\n    vec3 a, b, c;\n};\n\nstruct Ray\n{\n    vec3 Origin;\n    vec3 Direction;\n};\n/*struct Material\n{\n    vec3 Color;\n};\n*/\nstruct Light\n{\n    vec3 Pos;\n    vec3 Color;\n    float Intensity;\n};\n    \nstruct Hit\n{\n    float Dist;\n    vec3 Color;\n};\n\nstruct BezierControl\n{\n    vec3 Vertex; // Position of vertex\n    vec3 Handle; // Vector defining handle direction and length\n};\n    \n    \n// DATA ///////////////////////////////////////////////////////////////////////////////////////////////////\n    \nconst int DIMX_SEGS = DIMX_VERTS-1;\nconst int DIMZ_SEGS = DIMZ_VERTS-1;\n\nBezierControl _leftA;\nBezierControl _leftB;\nBezierControl _rightA;\nBezierControl _rightB;\n\n\n// ACES Tonemap: https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl ////////////////////////////////////\nconst mat3 ACESInputMat  = mat3(0.59719, 0.07600, 0.02840,    0.35458, 0.90834, 0.13383,    0.04823, 0.01566, 0.83777);\nconst mat3 ACESOutputMat = mat3(1.60475, -0.10208, -0.00327, -0.53108, 1.10813, -0.07276,  -0.07367, -0.00605,  1.07602);\nvec3 RRTAndODTFit(vec3 v) { return (v * (v + 0.0245786) - 0.000090537) / (v * (0.983729 * v + 0.4329510) + 0.238081); }\nvec3 ACESFitted(vec3 color) { return clamp(ACESOutputMat * RRTAndODTFit(ACESInputMat * color), 0.0, 1.0); }\n\n    \n// SHAPES ////////////////////////////////////////////////////////////////////////////////////////////////\n\n// udTriangle/sdBox/sdCapsule - https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat dot2(vec3 v) { return dot(v,v); }\nfloat udTriangle(vec3 p, vec3 a, vec3 b, vec3 c)\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n\treturn //sqrt(\n       (sign(dot(cross(ba,nor),pa)) +\n\t\tsign(dot(cross(cb,nor),pb)) +\n\t\tsign(dot(cross(ac,nor),pc))<2.0)\n\t\t?\n            min( min(\n            dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n            dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n            dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n\t\t:\n\t\t\tdot(nor,pa)*dot(nor,pa)/dot2(nor);// );\n}\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdSphere(vec3 p, float r)\n{\n\treturn length(p) - r;\n}\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nstruct Bound3\n{\n    vec3 mMin;\n    vec3 mMax;\n};\n\n\n// AABB of controls\nvec3 ComponentMin(in vec3 a, in vec3 b)\n{\n    return vec3(min(a.x, b.x), min(a.y, b.y), min(a.z, b.z));\n}\nvec3 ComponentMax(in vec3 a, in vec3 b)\n{\n    return vec3(max(a.x, b.x), max(a.y, b.y), max(a.z, b.z));\n}\nBound3 BezierControlAABB(in vec3 p0, in vec3 p1, in vec3 p2, in vec3 p3)\n{\n    return Bound3(ComponentMin(p0, ComponentMin(p1, ComponentMin(p2, p3))),\n                  ComponentMax(p0, ComponentMax(p1, ComponentMax(p2, p3)))\n                 );\n}\n\n\nvec3 SampleBezier(in vec3 a, in vec3 b, in vec3 c, in vec3 d, in float t)\n{\n    // Factorized the shit outta it\n\tfloat t2 = t*t;\n\tfloat t3 = t2*t;\n    return t3*(3.0*(b - c) + d - a) + 3.0*(t2*(a + c - 2.0*b) + t*(b - a)) + a;\n   \n    /*\n    // First degree\n    vec3 p11 = mix(a, b, t);\n    vec3 p12 = mix(b, c, t);\n    vec3 p13 = mix(c, d, t);\n\n    // Second degree\n    vec3 p21 = mix(p11, p12, t);\n    vec3 p22 = mix(p12, p13, t);\n\n    // Third degree\n    return mix(p21, p22, t);\n\t*/\n}\n\n\n// SCENE ///////////////////////////////////////////////////////////////////////////////////////////////////\nHit GetDist(vec3 p)\n{\n    Hit closest; // TODO try combining vec4(color, dist) and see if mix speeds up intersections\n    closest.Dist = 999999.;\n    closest.Color = vec3(1);\n    \n    // Plane\n    {\n        float d = p.y+0.6;\n        if (d < closest.Dist)\n        {\n            closest.Dist = d;\n            closest.Color = vec3(.5,.5,.5);\n        }\n    }\n\n    // Verts\n    /*{\n\t\tfloat r = 0.02;\n        float d = 9999999.;\n        d = min(sdSphere(p-_leftA.Vertex, r), d);\n        d = min(sdSphere(p-_leftB.Vertex, r), d);\n        d = min(sdSphere(p-_rightA.Vertex, r), d);\n        d = min(sdSphere(p-_rightB.Vertex, r), d);\n        \n        if (d < closest.Dist)\n        {\n            closest.Dist = d;\n            closest.Color = vec3(0.2,0.2,1);\n        }\n    }*/\n    \n   \n    \n    // Mesh bounding box test\n    {\n        // Dist to AABB\n        Bound3 bL = BezierControlAABB(_leftA.Vertex, _leftA.Handle, _leftB.Vertex, _leftB.Handle);\n        Bound3 bR = BezierControlAABB(_rightA.Vertex, _rightA.Handle, _rightB.Vertex, _rightB.Handle);\n        vec3 bMin = ComponentMin(bL.mMin, bR.mMin);\n        vec3 bMax = ComponentMax(bL.mMax, bR.mMax);\n        vec3 bCen = 0.5*(bMin+bMax);\n    \tvec3 bDim = 0.5*(bMax-bMin);\n        float dBox = sdBox(p-bCen, bDim);\n        \n         \n\t\t// Draw bounds\n\t\t/*\n\t\tif (dBox < closest.Dist)\n        {\n            closest.Dist = dBox;\n            closest.Color = vec3(1,1,0);\n        }        \n\t\tdBox = min(sdSphere(p-bMin, 0.1), dBox);\n        if (dBox < closest.Dist)\n        {\n            closest.Dist = dBox;\n            closest.Color = vec3(1,0,1);\n        }\n\n        dBox = min(sdSphere(p-bMax, 0.1), dBox);\n        if (dBox < closest.Dist)\n        {\n            closest.Dist = dBox;\n            closest.Color = vec3(0,1,1);\n        }\n\t\t*/\n       \n        \n        if (dBox < closest.Dist)\n        {\n            // Handles\n            {\n                float rHandle = 0.03;\n                float rRod = 0.01;\n                float d = 9999999.;\n                d = min(sdSphere(p-_leftA.Handle, rHandle), d);\n                d = min(sdSphere(p-_leftB.Handle, rHandle), d);\n                d = min(sdSphere(p-_rightA.Handle, rHandle), d);\n                d = min(sdSphere(p-_rightB.Handle, rHandle), d);\n\n                d = min(sdCapsule(p, _leftA.Vertex, _leftA.Handle, rRod), d);\n                d = min(sdCapsule(p, _leftB.Vertex, _leftB.Handle, rRod), d);\n                d = min(sdCapsule(p, _rightA.Vertex, _rightA.Handle, rRod), d);\n                d = min(sdCapsule(p, _rightB.Vertex, _rightB.Handle, rRod), d);\n\n                if (d < closest.Dist)\n                {\n                    closest.Dist = d;\n                    closest.Color = vec3(1);\n                }\n            }\n            \n            // Mesh\n            {\n                const vec3 color = vec3(1);\n\n                // Generate Tris\n\n                /* Sample bezier points for quad\n\n                  lt=a  rt=c\n                ^ |   / |\n                | |  /  |\n                | | /   |\n                V lb=b  rb=d\n                  U --->          */             \n\n                int index = 0;\n                float dTri=9999999.;\n\n                vec3 leftBot  = SampleBezier(_leftA.Vertex,  _leftA.Handle,  _leftB.Handle,  _leftB.Vertex,  0.);\n                vec3 rightBot = SampleBezier(_rightA.Vertex, _rightA.Handle, _rightB.Handle, _rightB.Vertex, 0.);\n\n                float rowStep = 1./float(DIMZ_SEGS);\n                float colmStep = 1./float(DIMX_SEGS);\n                for (int row = 1; row <= DIMZ_SEGS; row++)\n                {\n                    // Sample the bezier curve on the far left and right of this entire row. V coord.\n                    float top = float(row)*rowStep;\n                    vec3 leftTop  = SampleBezier(_leftA.Vertex,  _leftA.Handle,  _leftB.Handle,  _leftB.Vertex,  top);\n                    vec3 rightTop = SampleBezier(_rightA.Vertex, _rightA.Handle, _rightB.Handle, _rightB.Vertex, top);\n\n                    for (int colm = 1; colm <= DIMX_SEGS; colm++)\n                    {\n                        // Interpolate the row's bezier samples for the quad we're in. U Coord.\n                        float left = float(colm-1)*colmStep;\n                        float right = float(colm)*colmStep;\n\n                        // TODO EZ-OPTIMISE - Cache the left values outside of the loop to reduce computation\n                        vec3 a = mix(leftTop, rightTop, left);  // top left\n                        vec3 b = mix(leftBot, rightBot, left);  // bot left\n                        vec3 c = mix(leftTop, rightTop, right); // top right\n                        vec3 d = mix(leftBot, rightBot, right); // bot right\n\n                        // Depth test triangles\n                        dTri = min(udTriangle(p, a, b, c), dTri);\n                        dTri = min(udTriangle(p, c, b, d), dTri);\n                    }\n\n                    // Store this top sample for use as bottom in the next row\n                    leftBot = leftTop;\n                    rightBot = rightTop;\n                }\n\n                // I removed teh sqrt from udTriangle, so i must do it here!\n                dTri = sqrt(dTri) - 0.01;\n                if (dTri < closest.Dist)\n                {\n                    closest.Dist = dTri;\n                    closest.Color = color;\n                }\n            }\n        }\n    }\n    \n    return closest;\n}\n\n\n#define ZERO (min(iFrame,0))\nvec3 GetNormal(vec3 p)\n{\n    // Normal technique from iq: https://www.shadertoy.com/view/Xds3zN - I think this speeds up compile time by avoiding inlining of GetDist 4 times.\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*GetDist(p + 0.0005*e).Dist;\n    }\n    return normalize(n);\n    \n    /*float d = GetDist(p).Dist;\n    float offset = 0.01;\n    vec3 n = d - vec3(\n        GetDist(p - vec3(offset,0,0)).Dist,\n        GetDist(p - vec3(0,offset,0)).Dist,\n        GetDist(p - vec3(0,0,offset)).Dist\n        );\n  \n    return normalize(n);*/\n}\n\nHit RayMarch(Ray r)\n{\n    Hit lastHit;\n    float totalDist = 0.0;\n    \n    for (int i=0; i<MAX_STEPS; i++)\n    {\n        vec3 p = r.Origin + totalDist*r.Direction;\n        lastHit = GetDist(p);\n        totalDist += lastHit.Dist;\n        \n        if (totalDist < SURFACE_DIST || totalDist > MAX_DIST) \n            break;\n    }\n    \n    lastHit.Dist = totalDist;\n    \n    return lastHit;\n}\n\nvec3 GetLight(vec3 p, Light light)\n{\n    vec3 PL = light.Pos-p;\n    float PLLen = length(PL);\n    \n    vec3 lightNormal = PL/PLLen;\n    vec3 surfNormal = GetNormal(p);\n    \n    // Light\n    float strength = clamp(dot(surfNormal, lightNormal), 0., 1.);\n    float attenuation = 1. / max(PLLen*PLLen, 0.001);\n\n    // Shadow\n    Ray shadow;\n    shadow.Origin = p + surfNormal*SURFACE_DIST*2.;\n    shadow.Direction = lightNormal;\n    if(RayMarch(shadow).Dist < PLLen) strength = 0.0;\n    \n    return light.Intensity * light.Color * strength * attenuation;\n}\n\nmat3 RotateXZ(float rad)\n{\n    float cosr = cos(rad);\n    float sinr = sin(rad);\n    return mat3(\n        cosr,  0,  sinr,\n        0,     1,  0,\n        -sinr, 0,  cosr);\n}\n\n\n// MAIN ////////////////////////////////////////////////////////////////////////////////////////////////////\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.yy; // map to center:(0, 0), topright:(aspect/2, 0.5)\n    \n    // Define control points\n    {\n        float py = 0.35;\n        float px = -1.;\n        \n        _leftA = BezierControl(vec3(px, py,  1), vec3(px, py+.1, 0.5) + vec3(0, 0.2*cos(iTime*1.3 + 0.5), 0)); \n        _leftB = BezierControl(vec3(px, py, -1), vec3(px, py+.1,-0.5) + vec3(0, 0.2*sin(iTime*1.3 + 0.5), 0));\n        \n        px = 1.;\n        _rightA = BezierControl(vec3(px, py,  1), vec3(px,-.3,-.2) + vec3(0, 0.2*sin(iTime), 0)); \n        _rightB = BezierControl(vec3(px, py, -1), vec3(px, .4,-.2) + vec3(0, 0.2*cos(iTime), 0));\n    }\n   \n      \n    // Camera\n    Ray camera;\n    mat3 R = RotateXZ(iTime*0.2 + 0.7);\n    camera.Origin = R * vec3(0, 1.3, -3.1);\n    camera.Direction = R * normalize(vec3(uv.x, uv.y-0.7, 1.5));\n    \n    \n    // Hit scene\n    Hit hit = RayMarch(camera);\n    vec3 p = camera.Origin + camera.Direction*hit.Dist; // intersection point\n    \n    \n    // Direct Light\n    vec3 directLight = vec3(0);\n    {\n        Light l1;\n        l1.Pos = vec3(0, 2, 0) + 5.0;\n        l1.Color = vec3(1.0,0.6,0.5);\n        l1.Intensity = 50.0;\n        directLight += hit.Color * GetLight(p, l1);\n    }\n    \n    \n    // Ambient Light\n    vec3 ambient = hit.Color * 0.8*vec3(0.02,0.02,0.08);\n    \n    \n    // Compose colour\n    vec3 col = ambient + vec3(directLight);\n    \n    \n    // Post\n    //col *= 1.0; // exposure bias\n  \tcol = ACESFitted(col); // tonemap \n   \tcol = pow(col, vec3(.454)); // gamma\n\n    \n\tfragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdffzS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdjBDz", "name": "Asteroid Belt Data Links", "author": "blackle", "description": "playing with 4d modelling and the \"empty domains\" trick. see [url]https://www.shadertoy.com/view/tsjfRw[/url]", "tags": ["asteroids"], "likes": 7, "viewed": 323, "date": "1589854313", "time_retrieved": "2024-06-20T20:08:12.888313", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//this is mostly a remix of https://www.shadertoy.com/view/tsjfRw but\n//extending to the 4th dimension so we can do 4d rotations and get neat slices\n\n//returns a vector pointing in the direction of the closest neighbouring cell\nvec3 quadrant(vec3 p) {\n    vec3 ap = abs(p);\n    if (ap.x >= max(ap.y, ap.z)) return vec3(sign(p.x),0.,0.);\n    if (ap.y >= max(ap.x, ap.z)) return vec3(0.,sign(p.y),0.);\n    if (ap.z >= max(ap.x, ap.y)) return vec3(0.,0.,sign(p.z));\n    return vec3(0);\n}\n\nfloat hash(float a, float b) {\n    return fract(sin(a*1.2664745 + b*.9560333 + 3.) * 14958.5453);\n}\n\nbool domain_enabled(vec3 id) {\n    //repeat random number along z axis so every active cell has at least one active neighbour\n    id.z = floor(id.z/2.); \n    return hash(id.x, hash(id.y, id.z)) < .5;\n}\n\nfloat linedist(vec3 p, vec3 a, vec3 b) {\n    float k = dot(p-a,b-a)/dot(b-a,b-a);\n    return distance(p, mix(a,b,clamp(k,0.,1.)));\n}\n\nfloat linedist(vec4 p, vec4 a, vec4 b) {\n    float k = dot(p-a,b-a)/dot(b-a,b-a);\n    return distance(p, mix(a,b,clamp(k,0.,1.)));\n}\n\nvec4 wrot(vec4 p) {\n    return vec4(dot(p,vec4(1)), p.yzw + p.wyz - p.zwy - p.xxx)/2.;\n}\n\nfloat box(vec4 p, vec4 d) {\n    vec4 q = abs(p)-d;\n    return length(max(q,0.))+min(0.,max(max(q.x,q.w),max(q.y,q.z)));\n}\n\nvec4 smin(vec4 a, vec4 b, float k) {\n    vec4 h = max(vec4(0),-abs(a-b)+k)/k;\n    return min(a,b)-h*h*h*k/6.;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax, p, cos(ro)) + sin(ro)*cross(ax,p);\n}\n\nfloat weird_obj(vec4 p) {\n    p.xyz = erot(p.xyz, normalize(sin(p.xyz)), iTime/4.);\n    p = wrot(p);\n    p = sqrt(p*p+0.001);\n    p = wrot(p);\n    p.w+=.5;\n    p = sqrt(p*p+0.001);\n    p = wrot(p);\n    //p = smin(p,wrot(p),0.01);\n    return box(p, vec4(1.2))-.2;\n}\n\nfloat ball;\nfloat pipe;\nfloat scene(vec3 p) {\n    p.x+=sin(p.z/5.); p.y+=cos(p.z/5.);\n    p.y+=sin(p.x/7.); p.z+=cos(p.x/7.);\n    float w = sin(p.x/8.+iTime)*sin(p.y/8.+iTime)*sin(p.z/8.+iTime)*3.;\n    vec4 p4 = vec4(p,w);\n    p4 = mix(p4, wrot(p4), .2);\n    float scale = 8.;\n    vec3 id = floor(p.xyz/scale);\n    p4.xyz = (fract(p.xyz/scale)-.5)*scale;\n    if (!domain_enabled(id)) {\n        //return distance to sphere in adjacent domain\n        p4 = abs(p4);\n        if (p4.x > p4.y) p4.xy = p4.yx;\n        if (p4.y > p4.z) p4.yz = p4.zy;\n        if (p4.x > p4.y) p4.xy = p4.yx;\n        p4.z -= scale;\n        pipe = length(p4)-.2;\n        return weird_obj(p4);\n    }\n    float dist = weird_obj(p4);\n    ball = dist;\n    vec3 quad = quadrant(p4.xyz);\n    if (domain_enabled(id+quad)) {\n        //add pipe\n\t\tpipe = linedist(p4, vec4(0), vec4(quad,0.)*scale)-.2;\n        dist = min(dist, pipe);\n    } else {\n        pipe = length(p4)-.2;\n    }\n    return dist;\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p) - mat3(0.01);\n    return normalize(scene(p)-vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nfloat stars(vec3 dir) {\n    dir = erot(dir,normalize(vec3(1)),.2);\n    float str = length(sin(dir*vec3(120,120,210)));\n    dir = erot(dir,normalize(vec3(1,2,3)),.4);\n    str += length(sin(dir*vec3(320,230,140)));\n    dir = erot(dir,normalize(vec3(2,3,1)),.3);\n    str += length(sin(dir*vec3(230,280,138)));\n    return smoothstep(2.,1.5,str);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 cam  = normalize(vec3(1,uv));\n    float time = (floor(iTime/3.)+pow(sin(fract(iTime/3.)*3.14/2.),20.))*5. + iTime*2.; //accelerates every 3 seconds\n    cam = erot(cam, vec3(1,0,0), time/20.);\n    cam = erot(cam, vec3(0,0,1), .4+cos(time/8.)*.1);\n    vec3 init = vec3(time*2.-50.,-time,time)+cam;\n    vec3 p = init;\n    bool hit = false;\n    float dist;\n    float glow = 1000.;\n    float glowdist = 0.;\n    //raymarching\n    for (int i = 0; i < 150; i++) {\n        dist = scene(p);\n        if (pipe < glow) {\n            glow = pipe;\n            glowdist = distance(p,init);\n        }\n        hit = dist*dist < 1e-6;\n        p += cam*dist;\n        if (distance(p,init) > 250.) break;\n    }\n    //shading\n    glow = smoothstep(0.5, 0.,glow);\n    float fog = pow(smoothstep(250.,50.,distance(p,init)),2.);\n    vec3 n = norm(p);\n    vec3 r = reflect(cam, n);\n    float diff = max(0., dot(n, normalize(vec3(1,-1,1))))  + length(sin(n*vec3(3,2,1))*.5+.5)/sqrt(3.)*.1;\n    float spec = max(0., dot(r, normalize(vec3(1,-1,1))))  + length(sin(r*vec3(3,2,1))*.5+.5)/sqrt(3.)*.1;\n    float fresnel = 1.-abs(dot(n,r))*.98;\n    vec3 matcol = vec3(0.3,.2,.2);\n    vec3 col = matcol*matcol*diff*diff + pow(spec,2.)*fresnel + .005;\n    vec3 glowcol = glow*.5 + abs(erot(vec3(.7,.4,.2), vec3(0,0,1), glowdist*.1))*glow;\n    float glowfog = pow(smoothstep(250.,50.,glowdist),2.);\n    vec3 bg = vec3(stars(cam));\n    fragColor.xyz = sqrt(hit ? mix(bg, col, fog) : bg) + glowfog*glowcol;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc0-1.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdjBDz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdjBR1", "name": "ShATI - VitalitÃ©", "author": "Flopine", "description": "My former school named ATI decided to launch an everyday challenge from 4th may to 24th may, here is the 11th subject: vitality :)\nAlso made during a twitch session you can re-watch here:  https://www.twitch.tv/flopine", "tags": ["raymarching", "voronoise", "twitch"], "likes": 8, "viewed": 148, "date": "1589494451", "time_retrieved": "2024-06-20T20:08:13.573159", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n// Shader made for Everyday ATI challenge\n\n#define time iTime\n#define TAU 6.2831853071\n#define dt mod(time,TAU)\n\nvec2 hash22 (vec2 x)\n{return fract(sin(vec2(dot(x,vec2(12.4,16.4)),dot(x,vec2(23.4,28.37))))*12.4);}\n\nvec3 voronoise (vec2 uv)\n{\n    vec2 uv_id = floor(uv);\n    vec2 uv_cell = fract(uv);\n    vec2 bpoint, bneigh, bdiff;\n    float bdist = 10.;\n    for (int i=-1; i<=1; i++)\n    {\n        for (int j=-1; j<=1; j++)\n        {\n            vec2 neigh = vec2(float(i),float(j));\n            vec2 point = hash22(uv_id+neigh);\n            vec2 diff = neigh + point - uv_cell;\n            float dist = length(diff);\n            if (dist < bdist)\n            {\n                bneigh = neigh;\n                bpoint = point;\n                bdiff = diff;\n                bdist = dist;\n            }\n        }\n    }\n\n    bdist = 10.;\n    for (int i=-2; i<=2; i++)\n    {\n        for (int j=-2; j<=2; j++)\n        {\n            if (i==0 && j==0) continue;\n            vec2 neigh = bneigh + vec2(float(i), float (j));\n            vec2 point = hash22(uv_id+neigh);\n            vec2 diff = neigh + point - uv_cell;\n            float dist = dot(0.5*(bdiff+diff),normalize(diff-bdiff));\n            bpoint = point;\n            bdist = min(dist, bdist);\n        }\n    }\n    return vec3(bpoint,bdist);\n}\n\nvec3 voro;\nvec2 ground (vec3 p)\n{\n    voro = voronoise(p.xz);\n    float d = abs(p.y)\n        - smoothstep(0.01,0.05,voro.z)*0.1; \n    return vec2(d, 1.);\n}\n\nvec2 water (vec3 p)\n{\n    p.y += 0.01;\n    float d = abs(p.y)-smoothstep(0.08,0.01-(sin(length(voro.xy*.5)+dt)*0.5+0.5), voro.z)*0.2;\n    return vec2 (d,2.);\n}\n\nvec2 mat_min (vec2 a, vec2 b)\n{\n    if (a.x < b.x) return a;\n    else return b;\n}\n\nvec2 SDF (vec3 p)\n{return mat_min(ground(p),water(p));}\n\nvec3 getnorm(vec3 p)\n{\n    vec2 eps = vec2(0.05,0.);\n    return normalize(SDF(p).x-vec3(SDF(p-eps.xyy).x,SDF(p-eps.yxy).x,SDF(p-eps.yyx).x));\n}\n\nvec3 getcam (vec3 ro, vec3 tar, vec2 uv)\n{\n    vec3 f = normalize(tar-ro);\n    vec3 l = normalize(cross(vec3(0.,1.,0.),f));\n    vec3 u = normalize(cross(f,l));\n    return normalize(f + l*uv.x + u*uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    vec3 ro = vec3(0.,4.,-3.),\n        rd = getcam(ro,vec3(0.),uv),\n        p = ro,\n        l = normalize(vec3(1.,2., -2.)),\n        col = vec3(0.);\n\n    float shad;\n    vec2 d;  \n\n    for (float i=0.; i<20.; i++)\n    {\n        d = SDF(p);\n        if (d.x<0.01) break;\n        p += d.x*rd*0.3;\n    }\n\n    float t = length(ro-p);\n    vec3 n = getnorm(p);\n    float light = max(dot(n,l),0.);\n\n    if (d.y == 1.) col = mix(vec3(0.2,0.02,0.01),vec3(0.7,0.5,0.3),light);\n    else if (d.y == 2.) col = mix(vec3(0.0,0.0,0.08),vec3(0.1,0.7,0.9),light);\n\n        col = mix(col, vec3(0.9,0.8,0.5),1.-exp(-0.008*t*t));\n\n    fragColor = vec4(sqrt(col),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdjBR1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdjBRc", "name": "Boognish", "author": "Plento", "description": "A tribute to my favorite band, Ween. \nreferenc: https://www.etsy.com/hk-en/listing/603115407/ween-boognish-decal-sticker-11\nsum songs\nhttps://www.youtube.com/watch?v=rc9mECebRxc\nhttps://www.youtube.com/watch?v=_F39uC9IlI0&list=PL52E61FD2D160DBCB&index=11\n", "tags": ["2d", "logo", "band", "recreation", "ween", "boognish"], "likes": 9, "viewed": 469, "date": "1590556480", "time_retrieved": "2024-06-20T20:08:13.573159", "image_code": "// A tribute to Ween //\n// By Plento\n\n\n#define R iResolution.xy\n#define ss(a, b, t) smoothstep(a, b, t)\n\nfloat line( in vec2 p, in vec2 a, in vec2 b ){\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\nfloat box( in vec2 p, in vec2 b ){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat dist(vec2 uv){\n    float d = 999.;\n    uv.y += .07;\n    \n    vec2 p0 = vec2(uv.x*.9+sin(uv.y*1.)*.2, .88*uv.y-pow(uv.x, 2.)); // hair\n    vec2 p1 = vec2((uv.x-.004)*.813+cos(uv.y*15.)*.01,uv.y+sin(uv.x*15.)*.01)-vec2(0.,-.15); // head\n    vec2 p3 = vec2(abs(uv.x)-.16, uv.y+cos(uv.x*32. + 2.)*.008); // eyes\n    vec2 p4 = uv-vec2(0., -.48+exp(-uv.x*uv.x)*.3); // mouth\n    \n    float hair = abs(length(p0)- (.45-abs(cos(atan(uv.y, uv.x)*7.))*.16))-.02;\n    hair = max(hair, -(length(vec2(uv.x*.4, uv.y-.04)-vec2(0., -.5))-.51));\n    \n    d = min(abs(length(p1)-.29)-.0086, hair); // head\n    d = min(d, min(abs(length(p3)-.03)-.0002,abs(length(p3)-.001)-.001)); // eyes\n    d = min(d, abs(box(p4, vec2(.26, .12))) - 0.001); // mouth\n    \n    float teeth = 999.;\n    for(float i = 0.; i < 10.;i++){\n     \tteeth = min(teeth, line(uv, vec2(-.25+i*.05+sin(i*2.)*.01, -.5), \n                                vec2(-.25+i*.05+cos(i*5.)*.016, .5)));}\n    teeth = max(teeth, box(p4, vec2(.26, .12)));\n   \n    return min(d, teeth);\n}\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = 1.3*vec2(u.xy - .5*R.xy)/R.y;\n    uv*=1.-pow(cos(length(uv*8.) + iTime)*0.2, 2.);\n    \n    vec3 col = vec3(0);\n    \n    float d = dist(uv);\n    float thk = .008;\n    \n    col += .6+.32*cos(vec3(.5, .2, .4)*d*80.-iTime*2.+vec3(4.7, 0., 2.));\n    col *= ss(thk, thk+.006, d);\n    \n    col *= ss(1.55, .1, length(uv));\n    f = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdjBRc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdjBRz", "name": "Ride thru the city at night", "author": "lovelyH", "description": "City with light.", "tags": ["city"], "likes": 6, "viewed": 85, "date": "1589405371", "time_retrieved": "2024-06-20T20:08:13.573159", "image_code": "#define E 0.001\n#define INF 10000.0\n#define MAX_DIS 430.0\n\n\nvec2 rot( vec2 p, float l ){\n\treturn vec2(\n\t\tp.x*cos(l) - p.y*sin(l),\n\t\tp.x*sin(l) + p.y*cos(l)\n\t);\n}\n\n\nfloat dfCube( vec3 p, vec3 size ){\n\tp= abs(p) - size;\n\t// return max( max( p.x, p.y), p.z );\n\treturn length( vec3(\n\t\tmax( 0.0, p.x),\n\t\tmax( 0.0, p.y),\n\t\tmax( 0.0, p.z)\n\t));\n}\n\n\n\nint matId= 0;\nvec3 lightDis= vec3(INF);\n\n\nfloat map(vec3 p){\n\tfloat rc= p.z;\n\tfloat r= rc;\n\tfloat h;\n\tmatId= 0;\n\tlightDis= vec3(INF);\n\tvec3 ph, ph2;\n\n\t/// lamps\n\tph= p;\n\tph.x= abs(ph.x) - 6.2;\n\tph.y = mod( ph.y, 4.0 ) - 2.0;\n\trc= length(ph.xy)-0.1;\n\tph.z -= 3.0;\n\trc= max( rc, ph.z );\n\trc= min( rc, length(ph)-0.2 );\n\tlightDis= min( lightDis, vec3(length(ph)-0.1));\n\tif( rc < r ){\n\t\tr= rc;\n\t\tmatId= 1;\n\t}\n\n\t/// pavement\n\tph= p;\n\tph.x= abs(ph.x) - 6.0;\n\tph.z -= 0.2;\n\trc= length( vec2(\n\t\tmax( 0.0, -ph.x),\n\t\tmax( 0.0, ph.z)\n\t));\n\tif( rc < r ){\n\t\tr= rc;\n\t\tmatId= 1;\n\t}\n\n\t/// building\n\tph= p;\n\tfloat seed= floor( p.y / 30.0 ) * sign(p.x);\n\tph.x= abs(ph.x) - 20.0;\n\tph.y= mod( ph.y, 30.0 ) - 15.0;\n\trc= dfCube( ph, vec3(12.0) );\n\tfloat buildingHeight= 6.0 + 3.0 * floor( 3.0*( 0.5 + 0.5 * sin(10.*seed) ) );\n\trc= max( rc, p.z - buildingHeight );\n\trc= min( rc,  max( 1.0, max( ph.x-12.0, ph.y-12.0 ) ) );\n\tif( rc < r ){\n\t\tr= rc;\n\t\tmatId= 10 + int( floor( mod( seed, 6.999 ) ) );\n\t}\n\t/// door\n\tph2= ph;\n\tph2.x += 12.0;\n\tph2.y += 11.0*sin( 7.0*seed );\n\trc= dfCube( ph2, vec3(0.1, 0.7, 2.5) );\n\tif( mod(seed,5.0) < 3.0 ){\n\t\tfloat doory= ph2.y;\n\t\t/// window\n\t\tph2= ph;\n\t\tph2.x += 12.0;\n\t\tph2.y += mod( 11.0*sin( 7.0*seed ) + 11.0 + 11.0, 22.0 ) - 11.0;\n\t\tph2.z -= 2.0;\n\t\trc= min( rc, dfCube( ph2, vec3(0.1, 0.7, 0.8) ) );\n\t\tif( mod(17.0*seed,23.0) < 15.0 )\n\t\t{\n\t\t\tph2.z = mod( p.z, 3.0 )-1.5;\n\t\t\tph2.z = max( ph2.z, p.z + 1.5 - buildingHeight );\n\t\t\trc= min( rc, dfCube( ph2, vec3(0.1, 0.7, 0.8) ) );\n\t\t\tph2.y = doory;\n\t\t\trc= min( rc, dfCube( ph2, vec3(0.1, 0.7, 0.8) ) );\n\t\t}\n\t}\n\tif( rc < r ){\n\t\tr= rc;\n\t\tmatId= 3;\n\t}\n\n\t/// extra stone elements\n\trc= INF;\n\t/// corner\n\th= mod(27.0*seed,29.0);\n\tif( h < 10.0 ){\n\t\tph2= ph;\n\t\tph2.x= abs(ph2.x)-12.0;\n\t\tph2.y= abs(ph2.y)-12.0;\n\t\tph2.z = mod( ph2.z, 0.8 ) - 0.4;\n\t\trc= min( rc, dfCube( ph2+vec3(.2,.2,.0), vec3(.3,.3,.25) ) );\n\t}else if( h < 20.0 ){\n\t\t\n\t\tph2= ph;\n\t\tph2.x= abs(ph2.x)-12.0;\n\t\tph2.y= abs(ph2.y)-12.0;\n\t\t\n\t\t// ph2.z -= 4.0;\n\t\tph2.z = mod( ph2.z, 3.0 ) - 1.0;\n\n\t\tph2.x += 0.1;\n\t\tph2.y += 0.1;\n\t\trc= min( rc, dfCube( ph2, vec3(.15,.15,.12) ) - 0.03 );\n\t\t\n\t\tph2.x += 0.05;\n\t\tph2.y += 0.05;\n\t\tph2.z -= 0.5;\n\t\trc= min( rc, dfCube( ph2, vec3(.19,.19,.14) ) - 0.03 );\n\n\t\tph2.x += 0.7;\n\t\tph2.y += 0.15;\n\t\tph2.z += 0.1;\n\t\trc= min( rc, dfCube( ph2-vec3(.15,.15,.0), vec3(.19,.19,.12) ) - 0.03 );\n\n\t\tph2.x -= 0.7;\n\t\tph2.y += 0.5;\n\t\tph2.z += 0.1;\n\t\trc= min( rc, dfCube( ph2, vec3(.19,.19,.17) ) - 0.03 );\n\n\t}\n\t/// roof\n\tif( mod(13.0*seed,17.0) < 12.0 ){\n\t\tph2= ph;\n\t\tph2.z -= buildingHeight;\n\t\tif( mod(13.0*seed,17.0) < 5.0 ){\n\t\t\tph2.z = mod( ph2.z+1.5, 3.0 )-1.5;\n\t\t}\n\t\trc= min( rc, dfCube( ph2, vec3( 12.1, 12.1, 0.1 ) ) );\n\t}\n\t/// cut above building height\n\trc= max( rc, p.z - buildingHeight );\n\tif( rc < r ){\n\t\tr= rc;\n\t\tmatId= 2;\n\t}\n\n\treturn r;\n}\n\n\nvec3 render( vec3 sp, vec3 dir ){\n\tvec3 p= sp;\n\tfloat dis= map(p);\n\tfloat t= 0.0;\n\tbool isHit= false;\n\tvec3 lightDisFromRay= vec3(INF);\n\tfor( int a=0;a<0x200;a++){\n\t\tt += dis;\n\t\tp= sp + t*dir;\n\t\tdis= map(p);\n\t\tlightDisFromRay= min( lightDisFromRay, lightDis );\n\t\tif( dis < E || MAX_DIS < t ){\n\t\t\tisHit= true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tint hitMatId= matId;\n\tvec3 light= lightDis;\n\n\tvec3 r;\n\tif( t < MAX_DIS ){\n\n\t\t//vec3 nor= normalize(vec3(\n\t\t//\tmap(vec3(p.x+E,p.y,p.z))-map(vec3(p.x-E,p.y,p.z)),\n\t\t//\tmap(vec3(p.x,p.y+E,p.z))-map(vec3(p.x,p.y-E,p.z)),\n\t\t//\tmap(vec3(p.x,p.y,p.z+E))-map(vec3(p.x,p.y,p.z-E))\n\t\t//));\n  \t\tvec3 nor= vec3( 0 );\n\t\tfor( int i=min( iFrame, 0 ); i<4; i++){\n\t\t\tvec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n\t\t\tnor += e * map( p + e*E );\n\t\t}\n        nor= normalize( nor );\n\n\n\t\tfloat ao= 1.0;\n\t\tfor( float a=0.1; a>0.01; a*=0.5 ){\n\t\t\tao= min( ao, map(p+nor*a) / a );\n\t\t}\n\t\tao= clamp( ao, 0.0, 1.0 );\n\n\t\tvec3 baseColor;\n\t\tswitch(hitMatId){\n\t\t\t/// street\n\t\t\tcase 0: {\n\t\t\t\tbaseColor= vec3(.5,.5,.7); \n\t\t\t\tif( abs( p.x ) < 0.05 && mod(p.y,4.0) < 2.0 ){\n\t\t\t\t\tbaseColor= vec3(.9); \n\t\t\t\t}\n\t\t\t} break;\n\t\t\t/// pavement\n\t\t\tcase 1: baseColor= vec3(.5); break;\n\t\t\t/// stone (roof etc)\n\t\t\tcase 2: baseColor= vec3(.65); break;\n\t\t\t/// doors\n\t\t\tcase 3: baseColor= vec3(.55,.6,.1); break;\n\t\t\t/// buildings\n\t\t\tcase 10: baseColor= vec3(.9,.9,.6); break;\n\t\t\tcase 11: baseColor= vec3(.6,.6,.6); break;\n\t\t\tcase 12: baseColor= vec3(.7,.9,.6); break;\n\t\t\tcase 13: baseColor= vec3(.8,.7,.6); break;\n\t\t\tcase 14: baseColor= vec3(.2,.3,.4); break;\n\t\t\tcase 15: baseColor= vec3(.6,.6,.1); break;\n\t\t\tcase 16: baseColor= vec3(.3,.3,.1); break;\n\t\t\tcase 17: baseColor= vec3(.1,.1,.8); break;\n\t\t\t/// other\n\t\t\tdefault: baseColor= vec3(1,0,0); break;\n\t\t}\n\n\t\tr= baseColor *\n\t\t\t( \n\t\t\t\t(1.0 / (1.0 + 1.0 * light) )\n\t\t\t\t+ 1.0\n\t\t\t\t* ( 0.5 + 0.5*dot(nor,vec3(0,0,1)) )\n\t\t\t\t* ( 0.5 + 0.5*dot(nor,-dir) )\n\t\t\t\t* ( 0.5 + 0.5*ao )\n\t\t\t\t* ( 1.0 / (1.0 + 0.0001*t*t) )\n\t\t\t)\n\t\t;\n\n\t}else{\n\t\t/// sky\n\t\tr= vec3(0);\n\t}\n\n\t/// add light\n\tr += vec3(1) / (1.0+2.0*lightDisFromRay);\n\treturn r;\n}\n\nconst float iCamRX= 3.14/2.0;\nconst float iCamRZ= 0.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv= 2.0 * fragCoord / iResolution.xy - vec2(1.0,1.0);\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tvec3 dir= normalize( vec3( uv.x, uv.y, -4.0 ) );\n\tdir.yz= rot( dir.yz, iCamRX );\n\tdir.xy= rot( dir.xy, -iCamRZ );\n\t\n\tfragColor.xyz = sqrt( render( vec3(0,40.0*(mod(iTime,120.0)-60.0),2.0), dir ) );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdjBRz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdjBWD", "name": "Ink flow", "author": "TAKUSAKU", "description": "ink", "tags": ["flow", "liquid", "ink"], "likes": 4, "viewed": 131, "date": "1590075245", "time_retrieved": "2024-06-20T20:08:13.573159", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = (fragCoord.xy * 2. - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    st *= 2.5;\n\n    vec2 coord = st;\n    float len;\n    for (int i = 0; i < 3; i++) {\n        len = length(coord);\n        coord.x +=  sin(coord.y + iTime * 0.3)*1.;\n        coord.y +=  cos(coord.x + iTime * 0.1 + cos(len * 1.0))*6.;\n    }\n         \n    vec3 col = vec3(0.);\n\n    col = mix(col, vec3(cos(len)), 1.0);\n    \n    fragColor = vec4(0.7*col,1.);      \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdjBWD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdjBWR", "name": "å¤§é¾ç« - Quicky#036", "author": "totetmatt", "description": "Nothing special just random imbrication of function", "tags": ["quicky"], "likes": 1, "viewed": 249, "date": "1589830287", "time_retrieved": "2024-06-20T20:08:13.573159", "image_code": "mat2 r(float f){\n    float c=cos(f),s=sin(f);\n    return mat2(c,-s,s,c);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy -.5* iResolution.xy) / iResolution.y;\n    vec2 uuv = uv*.5;\n    uv*=r(atan(uv.x,uv.y)*2.5)*r(sign(cos(length(sin(uv*r(iTime)*10.)*3.)))*iTime);\n    for(float i=0.;i<=4.;i++){\n        uv = abs(uv)-.5;\n        uv *=r(sign(sin(length(uv*5.)))*length(uuv));\n    }\n    float d = smoothstep(-1.,1.9-length(uv-uv)*4.,tan(-iTime+cos(iTime)*5.+10.*(uv.y+uv.x))/tan(iTime-sin(-iTime)*5.+10.*(uv.y-uv.x))  );\n    vec3 col = vec3(d);\n    col = mix(vec3(.1/length(uv),.1,.1/length(uv)),vec3(.1,.2+.1/length(uv),length(uuv)+length(uv)),col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdjBWR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdjBzd", "name": "Make rows of moving cells", "author": "chen1180", "description": "Test the noise generator from the shader book!\nreference: https://thebookofshaders.com/10/", "tags": ["random", "thebookofshaders"], "likes": 0, "viewed": 99, "date": "1590647945", "time_retrieved": "2024-06-20T20:08:13.779458", "image_code": "float rand(float i){\n\treturn fract(sin(i)*43758.5453123);\n}\nfloat rand2d(vec2 uv){\n    return fract(sin(dot(uv.xy,vec2(12.123452,78.48254)))*43758.5453123);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    if (uv.y>0.5){\n        uv*=50.0;\n        uv.x+=5.0*iTime;\n   \n    }else{\n        uv*=75.0;\n        uv.x-=7.5*iTime;\n    }\n    vec2 ipos = floor(uv);  // get the integer coords\n    float random=rand(ipos.x);\n    if (random<0.4)\n        random=0.0;\n    else\n        random=1.0;\n    // Time varying pixel color\n    vec3 col = vec3(random);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdjBzd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdjBzK", "name": "Twinbow", "author": "alyd", "description": "The width of the rainbow stripes decreases with the amplitude of the music.\nif the music doesn't play at first, try pausing and playing again in iChannel0", "tags": ["2d", "music", "audio", "animation", "visualizer", "rainbow", "audiovisual"], "likes": 2, "viewed": 109, "date": "1590436808", "time_retrieved": "2024-06-20T20:08:14.052075", "image_code": "//Adapted code from https://thebookofshaders.com/06/\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define TWO_PI 6.28318530718\n\n//  Function from IÃ±igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime*10.;\n    float totalsound = texture(iChannel0,vec2(0.0,0.0)).r;\n    totalsound *=55.;\n    //totalsound =pow(205.*(totalsound+0.1),1.5);\n    //t *=(2.0+pow(3.*totalsound,2.));\n    vec2 res=iResolution.xy;\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st.x*=res.x/res.y; //scales the aspect ratio\n    st.x -=0.4;\n    vec3 color = vec3(0.0);\n\n    // Use polar coordinates instead of cartesian\n    vec2 toCenter = vec2(0.5)-st;\n    float angle = atan(toCenter.y,toCenter.x);\n    float radius = length(toCenter)*2.0;\n\n    // Map the angle (-PI to PI) to the Hue (from 0 to 1)\n    // and the Saturation to the radius\n    color = hsb2rgb(vec3(((angle*50.*(1.0+totalsound)+t)/TWO_PI)+0.5,radius,1.0));\n\n    fragColor = vec4(color,1.0);\n}\n\n\n\n    ", "image_inputs": [{"id": "Xtj3RK", "previewfilepath": "https://soundcloud.com/slushiimusic/twinbow", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/slushiimusic/twinbow", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdjBzK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdjfDD", "name": "HaiYi Jelly", "author": "PolyEDR", "description": "medium 5 haiyi Jelly", "tags": ["cartoon"], "likes": 5, "viewed": 71, "date": "1590083891", "time_retrieved": "2024-06-20T20:08:14.052075", "image_code": "#define maxstep 100\n#define maxl 100.\n#define minsr 0.01\n\nfloat makeface(vec2 uv){\n    vec2 eye = vec2(.15,.02);\n\tfloat deye = smoothstep(.04,.034,length(eye-vec2(abs(uv.x*1.5),uv.y*.8)));\n    float dmt =\tsmoothstep(.01,.01,(abs(7.*uv.x)-.5)*abs(7.*uv.x)-4.*uv.y-.13),\n        dmb = smoothstep(.05,.01,(abs(7.*uv.x)-.5)*abs(7.*uv.x)-4.*uv.y-.15),\n        dmouse = min(dmt,dmb);\n        dmouse = min(dmouse,step(abs(uv.x),.06));\n    \n    \n    return clamp(dmouse+deye,0.,1.);\n}\nfloat sm(float a,float b,float k)\n{\n    float h = clamp(.5+.5*(b-a)/k,0.,1.);\n    return h*a+(1.-h)*b-h*(1.-h)*k;\n}\nfloat GetDist(vec3 p){\n   \n \n vec2 offs= vec2(0);\n float ft =maxl\n     ,s=1.;\n    \n    float angle = 6.29/20.;\n\t  for(int i = 0;i<20;i++){\n        offs = vec2(cos(s*angle+iTime*1.5),sin(s*angle+iTime*1.5))*1.9;\n    ft = min(length(p+vec3(0,.3,0)+vec3(offs.x,0,offs.y))-.35,ft);\n          \n       s+=1.;\n    \n   }\n\tfloat sf = length(vec3(p.x,p.y*2.,p.z)+vec3(0.,-1.,0.))/2.-1.0;\n float d = sm(ft,sf,.2);\n    return d;\n\n}\n\nfloat RayMarch(vec3 ro ,vec3 rd){\n\tfloat ds,d0;\n    vec3 p;\n    for(int i = 0;i<maxstep;i++){\n    \tp = ro+rd*d0;\n        ds = GetDist(p);\n        if(d0>maxl || ds<minsr ) break;\n        d0 += ds;\n    }\n\treturn d0;\n}\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p,vec3 lightPos ) {\n    \n    \n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    \n    float d = RayMarch(p+n*minsr*2., l);\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n\t\n    \n    vec3 col = vec3(0.1 + 0.1*uv.y);\n\t\n    float zoom = 1.0;\n    vec3 ro = vec3(0.,3.,6.)\n        +vec3(20.*(iMouse.x-.5*iResolution.x)/iResolution.x,0,-.5*(iMouse.y-.5*iResolution.y)/iResolution.y*10.),\n        \n        lookat = vec3(0.,0.,0.),\n        f = normalize(lookat - ro),\n        r = cross(vec3(0.,1.,0.),f),\n        u = cross(f,r),\n        c = ro+f*zoom,\n        i = c+uv.x*r+uv.y*u,\n        rd = normalize(i-ro);\n    \n    float d = RayMarch(ro,rd);\n    vec3 p = ro+rd*d;\n    vec3 l = vec3(2., 5., 4.);\n    float dif = GetLight(p,l);\n    float toon = smoothstep(.01,.2,dif);\n\tfloat  tex = smoothstep(.8,.79,p.y+.27);\n    vec3 n = GetNormal(p);\n    float rim = smoothstep(.6,.1,-dot(n,f));\n    float gx = atan(p.x*.4,p.z);\n    float gy = (p.y-.6)*.3;\n    float face = makeface(vec2(gx,gy));\n    \n    col += clamp(\n        \t\t(vec3(.5,.5,.8)*(1.-tex)\n                 +vec3(.5,.1,.3)*tex\n                 +dif*.5\n                 )*vec3(clamp(toon,.7,1.),clamp(toon,.5,1.),clamp(toon,.8,1.))\n                 -step(50.,length(p-ro))*10.\n                 +rim\n                 -face*1.\n                 ,0.,1.);\n    \n    \n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdjfDD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdjfDK", "name": "Overlapping Voronoi", "author": "izutionix", "description": "version with different distance methods: [url]https://www.shadertoy.com/view/3llcWn[/url]\ncomment out the #define AA to disable anti-aliasing (for performance)", "tags": ["voronoi", "worley", "layers", "sorted", "overlapping"], "likes": 6, "viewed": 151, "date": "1590865331", "time_retrieved": "2024-06-20T20:08:14.052075", "image_code": "#define AA\n\n#define t iTime + 5.\n#define screen(a, b) a + b - a*b\n#define s(t, b, g) smoothstep(t+b*t, t-b*t, abs(g-.5) )\n\n//hash functions from https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p)\n{\n    p *= 733.424;\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hash33(vec3 p3)\n{\n    p3 *= 733.424;\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\t\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nvec3 voronoi2d(vec2 p, float s) {\n    vec2 gv = fract(p)-.5;\n\tvec2 iv = floor(p);\n    vec2 id;\n    \n    vec2 o;\n    float res = 8.;\n    \n    for(int y=-1; y<=1; y++)\n\tfor(int x=-1; x<=1; x++)\n    {\n        o = vec2(x, y);\n\n        vec2 n = hash22(iv+o);\n        vec2 p = o+.5*sin(t*n);\n        float d = dot(gv-p, gv-p)/s;\n\n        if(hash12(n)>.5 ? d<1. : 1.<res) {\n            res = d;\n            id = iv+p;\n        }\n    }\n    res = sqrt(res);\n    return vec3(res, id*float(res<1.) );\n}\n\nvec4 voronoi3d(vec3 p, float s) {\n    vec3 gv = fract(p)-.5;\n\tvec3 iv = floor(p);\n    vec3 id;\n    \n    vec3 o;\n    float res = 8.;\n    \n    for(int z=-1; z<=1; z++)\n    for(int y=-1; y<=1; y++)\n\tfor(int x=-1; x<=1; x++)\n    {\n        vec3 o = vec3(x, y, z);\n\n        vec3 n = hash33(iv+o);\n        vec3 p = o+.5*sin(t*n);\n        float d = dot(gv-p, gv-p)/s;\n\n        if(hash13(n)>.5 ? d<1. : 1.<res) {\n            res = d;\n            id = iv+p;\n        }\n    }\n\tres = sqrt(res);\n    return vec4(res, id*float(res<1.) );\n}\n\nfloat getCol(vec2 coord) {\n\tvec2 R = iResolution.xy;\n    vec2 uv = (coord-.5*R.xy)/R.y;\n    float x = coord.x/R.x;\n\tuv *= 8.;\n    \n    float size = 1.;\n    \n    float v = voronoi2d(uv, size).x;\n    \n    if(x<.5)\n    \tv = step(.9, v)*float(v<1.);\n    else\n    \tv = voronoi3d(vec3(uv, 0), size).w*.5+.5;\n    \n    return screen(v, s(.0025, .2, x ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 R = iResolution.xy;\n\n\tfloat v;\n    \n#ifdef AA\n    // AA from https://blog.demofox.org/2015/04/23/4-rook-antialiasing-rgss/\n    const float S = .125;\n    const float L = .375;\n    v  = getCol( fragCoord + vec2( S,-L) );\n    v += getCol( fragCoord + vec2( L, S) );\n    v += getCol( fragCoord + vec2(-S,-L) );\n    v += getCol( fragCoord + vec2(-L,-S) );\n    v *= .25;\n    \n#else\n   v = getCol(fragCoord);\n    \n#endif\n    fragColor = vec4(v);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdjfDK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdjfRD", "name": "yorha_one", "author": "YoRHa", "description": "one", "tags": ["beginner"], "likes": 3, "viewed": 83, "date": "1589628023", "time_retrieved": "2024-06-20T20:08:14.052075", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = fragCoord/iResolution.xy;\n    \n    vec3 col = vec3(0.0, 0.1875, 0.5078125);\n    \n    vec2 q = p - vec2(0.5, 0.5);\n    \n    float r = 0.2 + 0.2*cos(atan(q.x, q.y) * 5.0 + q.x*150.0 + iTime * 4.0);\n    float v = length(q) - r;\n    col += smoothstep(-1.,1., v/fwidth(v));\n    \n    r = 0.1;\n    col +=  smoothstep(r, r + 0.5, abs(q.x));\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdjfRD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdjfRt", "name": "Infinite Debris", "author": "jarble", "description": "The random shapes and colors go on forever!", "tags": ["raymarching", "hash"], "likes": 0, "viewed": 184, "date": "1590634866", "time_retrieved": "2024-06-20T20:08:15.149213", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n/**\n * Part 6 Challenges:\n * - Make a scene of your own! Try to use the rotation transforms, the CSG primitives,\n *   and the geometric primitives. Remember you can use vector subtraction for translation,\n *   and component-wise vector multiplication for scaling.\n */\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.0001;\n\nvec3 hash33(vec3 p3)\n{\t\n    //this is from https://www.shadertoy.com/view/4djSRW\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += (p3, (p3.xyz*cos(p3.x+p3.y)+p3.xyz*sin(p3.x*2.0+p3.y*3.0))+33.33);\n    return fract(p3*(p3*2.0));\n\n}\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {    \n    return length(hash33(sin(samplePoint)/10.0))-sin(length(samplePoint))/3.33;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(8.0+iTime*10.0, 5.0, 7.0*iTime);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = hash33(p/(500.0));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdjfRt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdjfRw", "name": "interference effect", "author": "foxiepaws", "description": "old school demo effect", "tags": ["oldschool"], "likes": 2, "viewed": 62, "date": "1589730854", "time_retrieved": "2024-06-20T20:08:15.149213", "image_code": "#define pi 3.141579\n\nmat2 rot(float deg) {\n    deg /= 180./3.141579; // convert to radians;\n    float s=sin(deg), c=cos(deg);\n    return mat2(c, -s, s, c);\n}\n\nvec3 colormap(vec2 v) {\n    \n    \n   return vec3(v.y,0.0,v.x);\n}\n\n\nvec2 calc (vec2 cv, vec2 uv, float t) {\n \tfloat sv = 0.0;\n    float dv = 0.0;\n    float x = uv.x;\n\tfloat y = uv.y;\n    float cx = cv.x;\n\tfloat cy = cv.y;\n    // create concentric circles from the centre of the screen\n    sv = sin(sqrt(100.0 * ((x * x) + (y * y))) + 1.0 + t);\n    // use dynamic vector to create interference pattern by moving centre\n    dv = sin(sqrt(100.0 * ((cx * cx) + (cy * cy))) + 1.0 + t);\n    return vec2(sv, dv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv *= 10.; // zoom out\n    vec2 ov = uv; // create copy of vector\n    uv.x += 5.*sin((iTime/1.)/5.0);                    // dynamic x movement\n    uv.y += 7. * cos((iTime/1.)/3.0);                    // dynamic y movement\n\tuv *= .5 * (2.+(1.*sin(2.*pi*.04*iTime)/10.));  // dynamic zoom\n    uv *= rot(22.5+(180.*sin(2.*pi*.01*iTime)));    // dynamic rotation\n    float t = iTime;\n    vec2 v = calc(uv,ov,t);\n\tvec3 hole = colormap(v);\n   \n    fragColor = vec4(hole,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdjfRw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdjfz1", "name": "Persp-correct bary tri rast", "author": "TomF", "description": "A simple triangle rasteriser, with perspective-correct barycentric interpolation.\n\nDoes not obey proper fill rules - too lazy :-)", "tags": ["triangle", "barycentric", "rasteriser", "perspectivecorrect"], "likes": 15, "viewed": 1584, "date": "1589535916", "time_retrieved": "2024-06-20T20:08:15.770225", "image_code": "\n\nstruct Vertex\n{\n    vec4 Pos;\n};\n\n\n// Test a position against a triangle and return\n// the non-perspective-correct barycentric coordinates in the triangle\n// Vertex z and w values are ignored.\nvec2 BaryTri2D ( vec2 pos, Vertex v1, Vertex v2, Vertex v3 )\n{\n    vec2 posv1 = pos - vec2(v1.Pos);\n    \n    vec2 v21 = vec2(v2.Pos) - vec2(v1.Pos);\n    vec2 v31 = vec2(v3.Pos) - vec2(v1.Pos);\n    \n    float scale = v21.x * v31.y - v21.y * v31.x;\n    float rscale = 1.0 / scale;\n    float baryi = ( posv1.x * v31.y - posv1.y * v31.x ) * rscale;   \n    float baryj = ( posv1.x * v21.y - posv1.y * v21.x ) * -rscale;\n    \n    return vec2 ( baryi, baryj );\n}\n\n\n#if 0\n// Test a position against a triangle and return\n// the perspective-correct barycentric coordinates in the triangle\n// Note the z value in the vertex is ignored, it's the w that matters.\nvec2 BaryTri3D ( vec2 pos, Vertex v1, Vertex v2, Vertex v3 )\n{\n    // Note some 3D pipelines will already have 1/w for each vertex, so this line may not be needed.\n    vec3 recipw = vec3 ( 1.0/v1.Pos.w, 1.0/v2.Pos.w, 1.0/v3.Pos.w );\n\n    vec2 posv1 = pos - vec2(v1.Pos);\n    \n    vec2 v21 = vec2(v2.Pos) - vec2(v1.Pos);\n    vec2 v31 = vec2(v3.Pos) - vec2(v1.Pos);\n    \n    float scale = v21.x * v31.y - v21.y * v31.x;\n    float rscale = 1.0 / scale;\n    float baryi = ( posv1.x * v31.y - posv1.y * v31.x ) * rscale;\n    float baryj = ( posv1.x * v21.y - posv1.y * v21.x ) * -rscale;\n    \n    // Now interpolate the canonical coordinates (0,0,1,v1.w), (1,0,1,v2.w) and (0,1,1,v3.w)\n    // with perspective correction\n    // So we project all three by their respective w:\n    // (0,0,v1.w) -> (0,     0,     1/v1.w)\n    // (1,0,v2.w) -> (1/v2.w,0,     1/v2.w)\n    // (0,1,v3.w) -> (0,     1/v3.w,1/v3.w)\n    // Then interpolate those values linearly to produce (nx,ny,nw),\n    // then divide by nw again.\n   \n    float baryk = 1.0 - baryi - baryj;\n    float newi = recipw.y * baryi;\n    float newj = recipw.z * baryj;\n    //float neww = recipw.x * baryk + recipw.y * baryi + recipw.z * baryj;\n    float neww = recipw.x * baryk + newi + newj;\n    \n    // ...and project back.\n    float rneww = 1.0/neww;\n    float perspi = newi * rneww;\n    float perspj = newj * rneww;\n        \n    return vec2 ( perspi, perspj );\n}\n\n#else\n// This is the same code as above, but refactored slightly.\n// It should be slightly faster on some cards, but is harder to read.\nvec2 BaryTri3D ( vec2 pos, Vertex v1, Vertex v2, Vertex v3 )\n{\n    // Note some 3D pipelines will already have 1/w for each vertex, so this line may not be needed.\n    vec3 recipw = vec3 ( 1.0/v1.Pos.w, 1.0/v2.Pos.w, 1.0/v3.Pos.w );\n\n    vec2 posv1 = pos - vec2(v1.Pos);\n    \n    vec2 v21 = vec2(v2.Pos) - vec2(v1.Pos);\n    vec2 v31 = vec2(v3.Pos) - vec2(v1.Pos);\n    \n    float scale = v21.x * v31.y - v21.y * v31.x;\n    float baryis = ( posv1.x * v31.y - posv1.y * v31.x );\n    float baryjs = ( posv1.y * v21.x - posv1.x * v21.y );\n    float baryks = ( scale - baryis - baryjs );\n    \n    float newis = recipw.y * baryis;\n    float newjs = recipw.z * baryjs;\n    float newws = recipw.x * baryks + newis + newjs;\n    \n    // ...and project back.\n    float rnewws = 1.0/newws;\n    float perspi = newis * rnewws;\n    float perspj = newjs * rnewws;\n        \n    return vec2 ( perspi, perspj );\n}\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    Vertex v1 = Vertex (vec4(0.5, 0.5, 0.0, 0.5));\n    Vertex v2 = Vertex (vec4(0.9, 0.6, 0.0, 0.8));\n    Vertex v3 = Vertex (vec4(0.4, 0.8, 0.0, 0.9));\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    col.xy = uv.xy;\n    col.z = 0.0;\n\n    int rep = 0;\n    // Uncomment this line for \"benchmarking\"\n    //for ( rep = 0; rep < 5000; rep++ )\n    {\n        float angle = iTime + 0.1 * float(rep);\n        v1.Pos.xy = 0.5 + 0.2 * vec2 ( cos ( angle ), sin ( angle ) );\n        v2.Pos.xy = 0.5 + 0.2 * vec2 ( sin ( angle ), -cos ( angle ) );\n\n        vec2 bary = BaryTri3D ( uv, v1, v2, v3 );\n        if ( ( bary.x >= 0.0 ) &&\n             ( bary.y >= 0.0 ) &&\n             ( bary.x + bary.y < 1.0 ) )\n        {\n            col.xy = bary;\n            col.z = 1.0;\n            if ( fract ( bary.x * 4.0 ) < 0.05 ) { col.z = 0.0; }\n            if ( fract ( bary.y * 4.0 ) < 0.05 ) { col.z = 0.0; }\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdjfz1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wdjfz3", "name": "Simple Egg - distance 2D", "author": "iq", "description": "Distance to an egg shape (a base circle of radius ra, a tip circle of radius rb, and two circles connecting both). It is not general enough since the height could be a parameter as well by just changing the connection points between circles.", "tags": ["2d", "sdf", "distance", "egg"], "likes": 15, "viewed": 1091, "date": "1590521248", "time_retrieved": "2024-06-20T20:08:15.773430", "image_code": "// The MIT License\n// Copyright Â© 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A simple generaliztion of sylvain69780's shader \"Moss's EGG\":\n// https://www.shadertoy.com/view/wsBBR3\n//\n// A more powerful generalization is possible where the height of the egg\n// is also user specified, and the tangent/contact points are computed\n// instead of hardcoded.\n//\n// This is also a special case of the Vesica primitive, in particular\n// this egg is just half a vesica with a circle attached at its end\n// https://www.shadertoy.com/view/XtVfRW\n\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and http://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\n\n\nfloat sdEgg( in vec2 p, in float ra, in float rb )\n{\n    const float k = sqrt(3.0);\n    \n    p.x = abs(p.x);\n    \n    float r = ra - rb;\n\n    return ((p.y<0.0)       ? length(vec2(p.x,  p.y    )) - r :\n            (k*(p.x+r)<p.y) ? length(vec2(p.x,  p.y-k*r)) :\n                              length(vec2(p.x+r,p.y    )) - 2.0*r) - rb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    // animation\n    float ra = 0.6;\n    float rb = ra*(0.55+0.45*cos(2.0*iTime));\n    \n    // distance\n    float d = sdEgg(p+vec2(0.,0.2), ra, rb);\n    \n    // coloring\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-4.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(128.0*abs(d));\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n\n    if( iMouse.z>0.001 )\n    {\n    d = sdEgg(m+vec2(0.,0.2), ra, rb);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/Wdjfz3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdjfzD", "name": "SinWaves", "author": "abeo", "description": "simple wave generator", "tags": ["sincos"], "likes": 2, "viewed": 75, "date": "1589634645", "time_retrieved": "2024-06-20T20:08:15.773430", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - vec2(0.5,0.5);\n\n\tvec4 col = vec4(0);\n    float thickness = 5.0/iResolution.y;\n    \n    for(float k=0.0;k<1.0;k+=0.05){\n    \tif(abs(uv.y - (k-0.5)*sin(uv.x*10.0 + 10.0*(k-0.5)*iTime))<thickness*(k+0.1))\n        \tcol=vec4(1.0,cos(3.14*(1.0-k)/2.0),cos(k*3.14/2.0),1.0);\n    }\n\n    // Output to screen\n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdjfzD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wdjfzh", "name": "Fabric Sphere", "author": "jcrob", "description": "Experiment in raymarching a fabric like material", "tags": ["raymarch"], "likes": 18, "viewed": 135, "date": "1589489126", "time_retrieved": "2024-06-20T20:08:16.652231", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 500.\n#define SURF_DIST 0.05\n\nconst float rep = 0.5; //change to increase the number of threads on the sphere\n\nfloat sdCylinderYZ( vec3 p, vec3 c )\n{\n    return length(p.yz-c.xy)-c.z;\n}\n\nfloat sdCylinderXY( vec3 p, vec3 c)\n{\n    return length(p.xy-c.xy)-c.z;\n}\n\nfloat twistX(vec3 p, float offsetZ, float offsetY) {\n    //twisting coordinates\n    const float k = 1.0; \n    vec3 q = vec3(p.x, p.y-offsetY, p.z-offsetZ);\n    float c = cos(k*q.x);\n    float s = sin(k*q.x);\n    mat2 m = mat2(c,-s,s,c);\n    q = vec3(q.x, m*q.yz);\n\n    //adding ridges\n    float dist = 0.1 * (0.3*sin(16.0*atan( q.z, q.y )));\n    return dist;\n}\n\nfloat twistZ(vec3 p, float offsetX, float offsetY) {\n    //twisting coordinates\n    const float k = 1.0; \n    vec3 q = vec3(p.x-offsetX, p.y-offsetY, p.z);\n    float c = cos(k*q.z);\n    float s = sin(k*q.z);\n    mat2 m = mat2(c,-s,s,c);\n    q = vec3(m*q.xy, q.z);\n\n    //adding ridges\n    float dist = 0.1 * (0.3*sin(16.0*atan( q.x, q.y )));\n    return dist;\n}\n\nvec3 wrapSphere(vec3 p, vec3 s, float r) {\n    vec3 n = normalize(p-s);\n    float nx = r * acos( dot(normalize(vec3(n.x, 0, n.z)), vec3(0,0,1)) )*rep;\n    float nz = r * acos( dot(n, vec3(0,1,0)) )*rep;\n    vec3 newP = vec3(nx, (length(p-s)-r)*rep, nz);\n    return newP;\n}\n\nmat2 rotate(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat getDist(vec3 p) {\n    \n    //Defining objects and distances to them\n\n    //rotation\n    p.z -= 60.;\n    p.xz *= rotate(iTime*0.1);\n    p.z += 60.;\n\n    vec3 sDist = wrapSphere(p, vec3(0, 0, 60), 30.);\n    vec3 repDist = vec3(mod(sDist.x, 3.14), sDist.y, mod(sDist.z, 5.));\n\n    float dst = sin(0.1*(iTime*25.+p.y)) *rep;\n\n    float rad1 = twistX(repDist, 2.0, (0.15 - sin(sDist.x + 1.7) + dst));\n    float rad2 = twistX(repDist, 4.0, (0.15 - sin(sDist.x + 4.84) + dst));\n    float rad3 = twistZ(repDist, 0.0, 0.0 + dst);\n    float rad4 = twistZ(repDist, 3.14, 0.0 + dst);\n\n    float thread1 = sdCylinderYZ(repDist, vec3(0.15 - sin(sDist.x + 1.7)+dst, 2., 0.5 - rad1));\n    float thread2 = sdCylinderYZ(repDist, vec3(0.15 - sin(sDist.x + 4.84)+dst, 4., 0.5 - rad2));\n    float thread3 = sdCylinderXY(repDist, vec3(0, 0.15+dst, 0.5-rad3));\n    float thread4 = sdCylinderXY(repDist, vec3(3.14, 0.15+dst, 0.5-rad4));\n\n    float threads = min(thread1, min(thread2, min(thread3, thread4)));\n    \n    //float plane = p.y+2.;\n\n    float d = threads/rep;\n    return d;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.;\n    \n    for(int i = 0; i < MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = getDist(p);\n        dO += dS;\n        if(dO > MAX_DIST || abs(dS) < SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 getNormal(vec3 p) {\n    float d = getDist(p);\n    vec2 e = vec2(0.1, 0);\n\n    vec3 n = d - vec3(\n        getDist(p-e.xyy),\n        getDist(p-e.yxy),\n        getDist(p-e.yyx)\n    );\n\n    return normalize(n);\n}\n\nvec3 skyColor( in vec3 ro, in vec3 rd ) {\n    vec3 col = vec3(0.3,0.4,0.5)*0.9 - 0.275*rd.y;\n    \n    return col;\n}\n\nfloat ambientOcclusion(vec3 p, vec3 n) {\n    float step = 0.1;\n    float ao = 0.0;\n    int iter = 3;\n    float intensity = 0.3;\n    float dist;\n    for(int i = 1; i <= iter; i++) {\n        dist = step * float(i);\n        ao += max(0.0, (dist - getDist(p + n * dist)) / dist);\n    }\n    return 1.0 - ao * intensity;\n}\n\nfloat getLight(vec3 p, vec3 lightPos) {\n\n    vec3 l = normalize(lightPos - p);\n    vec3 n = getNormal(p);\n\n    float dif = clamp(dot(n, l), 0., 1.);\n\n    //shadow\n    float d = rayMarch(p+n * SURF_DIST * 2. , l);\n    if(d<length(lightPos-p)) dif *= .1;\n\n    //ao\n    dif *= ambientOcclusion(p, n);\n\n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ((gl_FragCoord.xy-.5*iResolution.xy)/iResolution.y) * 2.0;\n    vec3 col = vec3(0);\n    \n    //Camera\n    vec3 rOrigin = vec3(0., 0., 10.);\n    vec3 rDirection = normalize(vec3(uv.x, uv.y, 1));\n    \n    float dist = rayMarch(rOrigin, rDirection);\n    vec3 p = rOrigin + rDirection * dist;\n    float dif = getLight(p, vec3(75, 20, 0));\n    float amb = getLight(p, vec3(-75, 20, 0));\n    \n    col = skyColor(rOrigin, rDirection);\n    if(dist < 100.) {\n        col = vec3(1.,0.95,0.85)*dif + vec3(0.3,0.4,0.5)*0.5*amb;\n    }\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wdjfzh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdjyWt", "name": "CIS461: Subsurface Scattering", "author": "raykim1996", "description": "Subsurface Scattering Approximation practice", "tags": ["cis461"], "likes": 1, "viewed": 71, "date": "1588866555", "time_retrieved": "2024-06-20T20:08:17.882648", "image_code": "const float FOVY = 3.14159 * 0.25;\nconst int RAY_STEPS = 256;\nconst float PI = 3.14159;\nconst float TWO_PI = 3.14159 * 2.0;\nconst vec3 matteWhite = vec3(0.85, 0.81, 0.78);\nconst vec3 matteRed = vec3(0.63, 0.065, 0.05);\nconst vec3 matteGreen = vec3(0.14, 0.45, 0.091);\nconst float SHADOW_HARDNESS = 6.0;\n\n// Adjust these to alter where the subsurface glow shines through and how brightly\nconst float K_VAL = 2.0;\nconst float OCC_DIST = 0.085;\n// The larger the DISTORTION, the smaller the glow\nconst float DISTORTION = 0.2;\n// The higher GLOW is, the smaller the glow of the subsurface scattering\nconst float GLOW = 6.0;\n// The higher the BSSRDF_SCALE, the brighter the scattered light\nconst float BSSRDF_SCALE = 3.0;\n// Boost the shadowed areas in the subsurface glow with this\nconst float AMBIENT = 0.0;\n\n//Intersection\nstruct Intersection\n{\n    float t;\n    vec3 color;\n    vec3 p;\n    int object; // unique ID for every object\n};    \n\n// Box with side lengths b\nfloat cube(vec3 p, vec3 b)\n{\n  return length(max(abs(p) - b, 0.0));\n}\n\n// SquarePlane SDF\nfloat plane(vec3 p, vec4 n)\n{\n    n = normalize(n);\n    return dot(p, n.xyz) + n.w;\n}\n\n// Sphere with radius r at center c\nfloat sphere(vec3 p, float r, vec3 c)\n{\n    return distance(p, c) - r;\n}\n\n#define BACK_WALL 0\n#define LEFT_WALL 1\n#define RIGHT_WALL 2\n#define FLOOR 3\n#define SPHERE1 4\n#define SHORT_CUBE 5\n#define BIG_CUBE 6\n#define LIGHT 7\n#define BACK_WALL_SDF plane(pos, vec4(0.0, 0.0, -1.0, 15.0))\n#define LEFT_WALL_SDF plane(pos, vec4(1.0, 0.0, 0.0, 5.0))\n#define RIGHT_WALL_SDF plane(pos, vec4(-1.0, 0.0, 0.0, 5.0))\n#define CEILING_SDF plane(pos, vec4(0.0, -1.0, 0.0, 7.5))\n#define FLOOR_SDF plane(pos, vec4(0.0, 1.0, 0.0, 4.0))\n#define SPHERE1_SDF sphere(rotateY(pos, 15.0 * 3.14159 / 180.0), 4.5, vec3(-7.0, 3.0, -1.0))\n#define SHORT_CUBE_SDF cube(rotateY(pos + vec3(-2, 1.5, -0.75), -17.5 * 3.14159 / 180.0), vec3(2.5, 8.0, 2.5))\n\nvec3 rotateY(vec3 p, float a)\n{\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);   \n}\n\nfloat shadowMap3D(vec3 pos)\n{\n    float t = FLOOR_SDF;\n    \n    float t2;\n    if ((t2 = SPHERE1_SDF) < t) {\n        t = t2;\n    }\n    if ((t2 = SHORT_CUBE_SDF) < t) {\n        t = t2;\n    }\n    return t;\n}\n\n// function to create whole scene\nvoid sceneMap3D(vec3 pos, out float t, out int obj, vec3 lightPos)\n{\n    t = FLOOR_SDF;\n    obj = FLOOR;\n    \n    float t2;\n    if ((t2 = SPHERE1_SDF) < t) {\n        t = t2;\n        obj = SPHERE1;\n    }\n    if ((t2 = SHORT_CUBE_SDF) < t) {\n        t = t2;\n        obj = SHORT_CUBE;\n    }\n    if((t2 = sphere(pos, 2.0, lightPos)) < t) {\n        t = t2;\n        obj = LIGHT;\n    }\n}\n\nfloat sceneMap3D(vec3 pos, vec3 lightPos)\n{\n    float t = sphere(pos, 2.0, lightPos);\n    \n    float t2;\n    if ((t2 = FLOOR_SDF) < t) {\n        t = t2;\n    }\n    if ((t2 = SPHERE1_SDF) < t) {\n        t = t2;\n    }\n    if ((t2 = SHORT_CUBE_SDF) < t) {\n        t = t2;\n    }\n    return t;\n}\n\nfloat fiveTapAO(vec3 p, vec3 n, float k) {\n    float aoSum = 0.0;\n    for(float i = 0.0; i < 5.0; ++i) {\n        float coeff = 1.0 / pow(2.0, i);\n        aoSum += coeff * (i * OCC_DIST - shadowMap3D(p + n * i * OCC_DIST));\n    }\n    return 1.0 - k * aoSum;\n}\n\nfloat softShadow(vec3 dir, vec3 origin, float min_t, float k) {\n    float res = 1.0;\n    float t = min_t;\n    for(int i = 0; i < RAY_STEPS; ++i) {\n        float m = shadowMap3D(origin + t * dir);\n        if(m < 0.0001) {\n            return 0.0;\n        }\n        res = min(res, k * m / t);\n        t += m;\n    }\n    return res;\n}\n\nfloat subsurface(vec3 lightDir, vec3 normal, vec3 viewVec, float thickness) {\n    vec3 scatteredLightDir = lightDir + normal * DISTORTION;\n    float lightReachingEye = pow(clamp(dot(viewVec, -scatteredLightDir), 0.0, 1.0), GLOW) * BSSRDF_SCALE;\n    float attenuation = 1.0;\n    attenuation = max(0.0, dot(normal, lightDir) + dot(viewVec, -lightDir));\n    float totalLight = attenuation * (lightReachingEye + AMBIENT) * thickness;\n    return totalLight;\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj, vec3 lightPos)\n{\n    t = 0.001;\n    for (int i = 0; i < RAY_STEPS; ++i) {\n        vec3 pos = origin + t * dir;\n        float m;\n        sceneMap3D(pos, m, hitObj, lightPos);\n        if (m < 0.001) {\n            return;\n        }\n        t += m;\n    }\n    t = -1.0;\n    hitObj = -1;\n}\n\nvec3 computeMaterial(int hitObj, vec3 p, vec3 n, vec3 lightVec, vec3 view, float thick)\n{\n    float t;\n    switch(hitObj) {\n        case FLOOR:\n        return matteWhite * max(0.0, dot(n, lightVec)) * softShadow(lightVec, p, 0.1, SHADOW_HARDNESS);\n        break;\n        case SPHERE1:\n        vec3 sColor = vec3(0.85, 0.41, 0.2) * max(0.0, dot(n, lightVec)) * softShadow(lightVec, p, 0.1, SHADOW_HARDNESS);\n        return sColor + vec3(0.85, 0.41, 0.2) * subsurface(lightVec, n, view, thick);\n        break;\n        case SHORT_CUBE:\n        vec3 cColor = vec3(0.1, 0.31, 0.6) * max(0.0, dot(n, lightVec)) * softShadow(lightVec, p, 0.1, SHADOW_HARDNESS);\n        return cColor + vec3(0.1, 0.31, 0.6) * subsurface(lightVec, n, view, thick);\n        break;\n        case LIGHT:\n        return vec3(1.0, 0.88, 0.7);\n        case -1:\n        return vec3(0, 0, 0);\n        break;\n    }\n    return vec3(0, 0, 0);\n}\n\nvec3 computeNormal(vec3 pos, vec3 lightPos)\n{\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize(vec3(sceneMap3D(pos + epsilon.yxx, lightPos) - sceneMap3D(pos - epsilon.yxx, lightPos),\n                         sceneMap3D(pos + epsilon.xyx, lightPos) - sceneMap3D(pos - epsilon.xyx, lightPos),\n                         sceneMap3D(pos + epsilon.xxy, lightPos) - sceneMap3D(pos - epsilon.xxy, lightPos)));\n}\n\nIntersection sdf3D(vec3 dir, vec3 eye, vec3 lightPos)\n{\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj, lightPos);\n    \n    vec3 isect = eye + (t * dir);\n    vec3 nor = computeNormal(isect, lightPos);\n\n    vec3 lightDir = normalize(lightPos - isect);\n    float thickness = fiveTapAO(isect, -nor, K_VAL);\n\n    vec3 surfaceColor = computeMaterial(hitObj, isect, nor, lightDir, normalize(eye - isect), thickness);\n\n    return Intersection(t, surfaceColor, isect, hitObj);\n}\n\n// Returns direction of ray\nvec3 rayCast(vec3 eye, vec3 ref, vec2 ndc)\n{\n    vec3 F = ref - eye;\n    vec3 R = normalize(cross(vec3(0, 1, 0), F));\n    vec3 U = normalize(cross(R, -F));\n    \n    vec3 V = U * length(F) * tan(FOVY * 0.5);\n    vec3 H = R * length(F) * tan(FOVY * 0.5) * float(iResolution.x) / iResolution.y;\n    \n    vec3 p = ref + ndc.x * H + ndc.y * V;\n    \n    return normalize(p - eye);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 lightPos = rotateY(vec3(-8.0, 7.0, -10), iTime * 0.6);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // Convert range to [-1, 1]\n    uv = uv * 2.0 - vec2(1.0, 1.0);\n    \n    vec3 eye = vec3(9, 2.5, -24);\n    vec3 ref = vec3(-2, 2.5, 0);\n    \n    vec3 rayDir = rayCast(eye, ref, uv);\n    \n    Intersection isect = sdf3D(rayDir, eye, lightPos);\n    \n    fragColor = vec4(isect.color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdjyWt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdlBD2", "name": "Taylor Series (cosinus)[Day 143]", "author": "jeyko", "description": "Based on 3blue1brown video https://www.youtube.com/watch?v=3d6DsjIBzJ4&t=691s", "tags": ["tutorial", "taylor", "maths", "series"], "likes": 11, "viewed": 281, "date": "1589119331", "time_retrieved": "2024-06-20T20:08:18.379713", "image_code": "// Thanks to mla for the smooth plotting function! \n\n\n// Taylor Series\n\n// This version is defined for cos()\n// Check the other version for any function as input: https://www.shadertoy.com/view/wdlBWj\n// This one is better for learning how it works\n\n\n// j = 0.\n// f(j) = cos(j)\n// T(x) = f(j) + x*f(j)'/1! + x^2*f(j)''/2! + x^3*f'''/3! +  x^4*f''''/4! ... etc\n\n\n// This is a series, which approximates a given function around a point\n// by matching its value and derivatives at that point.\n\n// The derivatives are measured at the point, then scaled by x^n and divided by n! \n// This is done, so you negate the extra terms you get when deriving the equation.\n\n\n// Thanks to 3blue1brown for his video from which I learned this! \n// https://www.youtube.com/watch?v=3d6DsjIBzJ4&t=691s\n\n\n// You can change the amount of derivatives in the taylor(function)\n// Uncomment around line 78 to plot the derivatives\n\n\nfloat factorial(float x){float res = 1.;for(float i = 1.; i <= x;i++){res*=i;}return res;}\n\n\n#define offs \t\t(iTime)\n\n#define fn(j) \t\tcos(j+offs)\n\n#define deriv(j) \t-sin(j+offs)\n#define deriv2(j) \t-cos(j+offs)\n#define deriv3(j) \tsin(j+offs)\n\n\nfloat taylor(float j){\n\tfloat res = 0.;\n\t\n    res += fn(0.);\n    res += deriv(0.)  *j \t\t/ factorial(1.);\n    res += deriv2(0.) *j*j \t\t/ factorial(2.);\n    res += deriv3(0.) *j*j*j \t/ factorial(3.);\n    res += fn(0.)     *j*j*j*j \t/ factorial(4.); // cos(x) is the 4th derivatine of cos(x)\n    \n    return res;\n}\n\n// Plotting width\nconst float W = 0.03; \n// Plots a fn\nconst float eps = 0.01;\nvec3 graph(float y, float fn0, float fn1, vec3 col, float width){\n  return smoothstep(W*width*1.,dFdy(y)*W*width, \n                    abs(fn0-y)/length(vec2((fn1-fn0)/eps,1.)))*col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y*5.;\n\n    vec3 col = vec3(0);\n    \n    // functions \n\tcol += graph( uv.y, fn(uv.x),\t  fn(uv.x+eps),     vec3(0.,0.2,0.1), 1. );\n    col += graph( uv.y, deriv(uv.x),  deriv(uv.x+eps),  vec3(0.0,0.02,0.0), 1. );\n    col += graph( uv.y, deriv2(uv.x), deriv2(uv.x+eps), vec3(0.02,0.0,0.0), 1. );\n    col += graph( uv.y, deriv3(uv.x), deriv3(uv.x+eps), vec3(0.0,0.0,0.04), 1. );\n    col += graph( uv.y, taylor(uv.x), taylor(uv.x+eps), vec3(0.9,0.1,0.1), 1. );\n\t\n    \n    \t\n    \n    \n    // plotlines\n    \n    float pi = acos(-1.);\n    float uvxmod = abs( (fract((uv.x+offs+pi/3.)*2./3.14) -pi/5.)*pi/2.  );\n    col += graph(uvxmod + eps,0.01,0.02,vec3(1,1,1)/2.,0.75)*smoothstep(W,W*0.003,abs(uv.y)-0.1);\n    col += graph(abs(uv.y),0.,dFdx(uv.x),vec3(1,1,1)/2.,0.5);\n    \n    \n    // gamma correction\n    col = pow(col,vec3(0.454545));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdlBD2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdlBDj", "name": "FireFunction", "author": "PoetLuchnik", "description": "burn?", "tags": ["fire"], "likes": 1, "viewed": 229, "date": "1589124962", "time_retrieved": "2024-06-20T20:08:18.610865", "image_code": "float f(float x)\n{\n    float y = 0.0;\n    float size = 0.6;\n    float speed = 13.0;\n    float i = 0.0;\n    \n    while(size > 0.001)\n    {\n        y += sin(x * speed + iTime * 16.0 + i) * size;\n        speed *= 2.0;\n        size *= 0.7;\n        i += 13.0;\n    }\n    \n    return y + 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Time varying pixel color\n    float p = 3.0 - uv.y * 3.8 + f(uv.x) * 0.3;\n    vec3 col = vec3(0);\n\n    col.r = p;\n    p -= 1.0;\n   \tcol.g = p;\n   \tp -= 1.0;\n    col.b = p;\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdlBDj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdlBDM", "name": "circle fun sdf", "author": "mtx", "description": "circle and segment sdf ", "tags": ["sdf"], "likes": 3, "viewed": 111, "date": "1588369083", "time_retrieved": "2024-06-20T20:08:18.888843", "image_code": "float sdCircle( vec2 p, float r ) {\n  return length(p) - r;\n}\n\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b ) {\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h =clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(pa-h*ba);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n  \n    // fragCoord (0,0)...(width, height)\n\t// p point in NDS(-1...1)\n    vec2 p = ( 2.0 * fragCoord - iResolution.xy )/ (iResolution.y);\n\tfloat d = sdCircle(p, 0.3);\n    \n    vec2 v1 = cos( iTime + vec2(0.25,0.25) + 0.0 );\n\tvec2 v2 = cos( iTime + vec2(0.25,0.25) + 1.0 );\n    \n    float s = udSegment(p, v1, v2) - 0.05;\n   \n    \n    // circle\n    \n\t// shapes body\n    vec3 col = vec3(1.0) - (sign(d)+sign(s)) * 0.5 * vec3(0.1, 0.4, 0.7);\n    \n    // for single body\n    //vec3 col = vec3(1.0) - sign(s) * vec3(0.1, 0.4, 0.7);\n    \n    // 'shading'\n    // col *= 1.0 - exp(-3.0*abs(d));\n    // col *= 1.0 - exp(-3.0*abs(s));\n\t\n    // 'ripples'\n    // col *= (0.9 + 0.1 * cos(250.0 * (d*s)));\n    \n    // 'edge'\n\tcol = mix( col, vec3(1.0), 1.0 - smoothstep(0.0, 0.01, abs(d * s)) );\n\n\t// col = mix( col, vec3(1.0), 1.0 - smoothstep(0.0,0.015,abs(s)) );\n    \n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdlBDM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdlBR2", "name": "Raytracing a Cone", "author": "mla", "description": "Ray-surface intersection for a cone or other quadric requires solving a quadratic equation and numeric errors can occur. One type, noticeable here at the cone apex, is fixable by moving the ray origin closer to the surface.", "tags": ["raytracing", "quadric", "cone", "quadratic", "hyperboloid"], "likes": 4, "viewed": 298, "date": "1588674498", "time_retrieved": "2024-06-20T20:08:19.925218", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Ray tracing a cone, showing effect of rounding errors on quadratic solution.\n// See https://www.shadertoy.com/view/WdXfR2 for similar problems with sphere.\n//\n// Errors are particularly pronounced at cone apex, even at smaller distances,\n// can be significantly reduced by moving the projection point closer to the\n// surface (compare LHS of image with RHS, zoom in with 'z').\n//\n// Despite shader name, it also does hyperboloids and spheres (illustrating\n// another, possibly GPU dependent, source of numeric error).\n//\n// Matthew Arcus, mla, 2020.\n//\n// <mouse>: rotate cone\n// b: background\n// c: clip cone\n// h: hyperboloid\n// q: quality\n// x: sphere\n// z: extra zoom in\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.1415927;\n\nint quality = 0;\n\n// NB: This solves Ax^2 + 2Bx + C = 0 (with factor of 2 on B)\nbool quadratic(float A, float B, float C, out vec2 t) {\n  // Sometimes should also check for A = 0 or C = 0\n  float D = B*B-A*C;\n  if (D < 0.0) return false;\n  float x,y;\n  if (true) {\n    // The wrong way, but doesn't seem to cause problems\n    // with this shader.\n    x = (-B-sqrt(D))/A;\n    y = (-B+sqrt(D))/A;\n  } else {\n    // The right way\n    x = B <= 0.0 ? -B-sqrt(D) : -B+sqrt(D);\n    y = C/x;\n    x /= A;\n  }\n  // Return solutions in order\n  t = x < y ? vec2(x,y) : vec2(y,x);\n  return true;\n}\n\nbool dohyperboloid = false;\nbool doclip = true;\nbool dosphere = true;\n\nint checkcone(vec3 p) {\n  float height = dohyperboloid ? 2.0 : 1.0;//exp(iTime);\n  if (doclip && abs(p.y) > height) return 0;\n  float N = 16.0;\n  float i = floor(N*(atan(p.z,p.x))/PI);\n  float j = floor(N*p.y/height);\n  return int(mod(i+j,2.0));\n}\n\nint intersectcone(vec3 p, vec3 r, out vec3 n) {\n  float k = 0.0;\n  if (quality == 1) {\n    // Move projection point to be orthogonal to cone apex.\n    k = -dot(p,r); p += k*r;\n  }\n  // Quadric equation is: (p*X).p = 0\n  // So solve: ((p+tr)*X).(p+tr) = 0\n  vec3 X = dosphere ? vec3(1) : vec3(1,-1,1);\n  // Since r is normalized, can take a shortcut for a sphere.\n  float A = dosphere ? 1.0 : dot(r*X,r);\n  float B = dot(p*X,r);\n  float C = dot(p*X,p);\n  if (dosphere) C -= 1.0;\n  else if (dohyperboloid) C += sin(0.2*iTime);// Hyperboloid\n  vec2 t;\n  if (!quadratic(A,B,C,t)) return 0;\n  int type;\n  vec3 q;\n#if 0\n  // Do people prefer assignments in conditionals,\n  if (!(t.x+k >= 0.0 && (type = checkcone(q = p+t.x*r)) != 0) &&\n      !(t.y+k >= 0.0 && (type = checkcone(q = p+t.y*r)) != 0)) {\n    return 0;\n  }\n#elif 0\n  // or using a one-iteration loop and break/return?\n  for(;;) {\n    if (t.x+k >= 0.0) {\n      q = p+t.x*r;\n      type = checkcone(q);\n      if (type != 0) break;\n    }\n    if (t.y+k >= 0.0) {\n      q = p+t.y*r;\n      type = checkcone(q);\n      if (type != 0) break;\n    }\n    return 0;\n#else\n  // Or just this?\n  type = 0;\n  if (t.x+k >= 0.0) {\n     q = p+t.x*r;\n     type = checkcone(q);\n  }\n  if (type == 0 && t.y+k >= 0.0) {\n     q = p+t.y*r;\n     type = checkcone(q);\n  }\n  if (type == 0) return 0;\n#endif\n  \n  n = normalize(q*X);\n  if (dot(n,r) > 0.0) n = -n;\n  return type;\n}\n\nint intersectscene(vec3 p, vec3 r, out vec3 n) {\n  return intersectcone(p,r,n);\n}\n\nvec3 getcolor(vec3 p) {\n  return abs(p);\n}\n\nvec3 raycolor(vec3 p, vec3 r, vec3 light) {\n  vec3 n;\n  int type = intersectscene(p,r,n);\n  if (type == 0) {\n    return vec3(0);\n  } else {\n    float ambient = 0.3;\n    float diffuse = 0.3;\n    vec3 basecolor = getcolor(n);\n    if (type == 2) basecolor *= 0.8;\n    vec3 color = basecolor*(ambient+diffuse*max(0.0,dot(light,n)));\n    float specular = pow(max(0.0,dot(reflect(light,n),r)),5.0);\n    //vec3 speccol = vec3(1);\n    vec3 speccol = basecolor;\n    color += 0.5*specular*speccol;\n    return color;\n  }\n}\n\nvec2 rotate(vec2 p, float t) {\n  return mat2(cos(t),sin(t),-sin(t),cos(t))*p;\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = -(2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = -(2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  if (true) {\n    p.zx = rotate(p.zx,iTime * 0.2);\n    p.xy = rotate(p.xy,iTime * 0.125);\n  }\n  return p;\n}\n\nbool key(int code) {\n  return texelFetch(iChannel3, ivec2(code,2),0).x != 0.0;\n}\n\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_H = 72;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_X = 88;\nconst int CHAR_Z = 90;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  dohyperboloid = key(CHAR_H);\n  dosphere = key(CHAR_X);\n  doclip = !key(CHAR_C);\n  vec3 light = vec3(0.5,1.0,-1.0);\n  light = transform(light);\n  light = normalize(light);\n  float camera = 1.0;\n  float t = iTime;\n  t = mod(t,20.0);\n  camera *= exp(t);\n  vec3 p = vec3(0,0,-camera);\n  p = transform(p);\n  vec3 col = vec3(0);\n  float AA = 2.0;\n  for (float i = 0.0; i < AA; i++) {\n    for (float j = 0.0; j < AA; j++) {\n      vec2 uv = (2.0*(fragCoord+vec2(i,j)/AA)-iResolution.xy)/iResolution.y;\n      if (key(CHAR_Z)) uv *= 0.1; \n      vec3 r = vec3(uv,camera);\n      r = normalize(r);\n      r = transform(r);\n      if (uv.y < 0.0) r = normalize(r); // Normalize after transform\n      if (uv.x < 0.0 || key(CHAR_Q)) quality = 1;\n      vec3 c = raycolor(p,r,light);\n      if (c == vec3(0) && key(CHAR_B)) c = pow(texture(iChannel0,uv).xyz,vec3(2.2));\n      col += c;\n    }\n  }\n  col /= float(AA*AA);\n  col = pow(col,vec3(0.4545));\n  fragColor = vec4(col,1);\n}\n", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdlBR2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdlBWB", "name": "menger-sponge-va-003", "author": "jorge2017a1", "description": "menger-sponge-va-003", "tags": ["mengerspongeva003"], "likes": 4, "viewed": 59, "date": "1588987048", "time_retrieved": "2024-06-20T20:08:19.931066", "image_code": "//modificado por jorge flores.p --\n//Gracias a ....Created by russ in 2017-03-06\n//https://www.shadertoy.com/view/XsfczB\n    \n\nconst int iter =100;\nconst float eps = 0.001, far = 20.;\nvec3 lDir0 = normalize(vec3(1,2,1)), lDir1 = normalize(vec3(-1,1.0,-2));\nvec3 lCol0 = vec3(1,.8,.5), lCol1 = vec3(.6,0.8,1); \n\n\n#define PI 3.1415926\n\n///-------------------------------------\nconst int MAX_RAY_STEPS = 64;\nconst float RAY_STOP_TRESHOLD = 0.0001;\nconst int MENGER_ITERATIONS = 5;\n///-------------------------------------\n\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3  di = abs(p) - b;\n  float mc = maxcomp(di);\n  return min(mc,length(max(di,0.0)));\n}\n\n\nfloat cylUnion(vec3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(min(xy,min(xz,yz))) - 1.;\n}\n\nfloat cylIntersection(vec3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(max(xy,max(xz,yz))) - 1.;\n}\n\n\n//-------------------------------------------\n\nfloat dsSphere(vec3 center, float r, vec3 point)// basic sphere SDF\n{\n    // point is point pos in space, center is sphere's center, r is its radius\n    return length(point - center) - r;\n}\n\nfloat dsCapsule(vec3 point_a, vec3 point_b, float r, vec3 point_p)//cylinder SDF\n{\n \tvec3 ap = point_p - point_a;\n    vec3 ab = point_b - point_a;\n    float ratio = dot(ap, ab) / dot(ab , ab);\n    ratio = clamp(ratio, 0.0, 1.0);\n    vec3 point_c = point_a + ratio * ab;\n    return length(point_c - point_p) - r;\n}\n\nfloat dsTorus(vec3 center, float r1, float r2, vec3 point)\n{\n \tfloat x = length(point.xz - center.xz) - r1;\n    float y = point.y - center.y;\n    float dist = length(vec2(x,y)) - r2;\n    return dist;\n}\n//--------------------------------------------\n\n//oooooooooooooooooooooooooooooooooooooooooooooooooooo\nfloat sdCross(vec3 p) {\n\tp = abs(p);\n\tvec3 d = vec3(max(p.x, p.y),\n\t\t\t\t  max(p.y, p.z),\n\t\t\t\t  max(p.z, p.x));\n\treturn min(d.x, min(d.y, d.z)) - (1.0 / 3.0);\n}\n\nfloat sdCrossRep(vec3 p) {\n\tvec3 q = mod(p + 1.0, 2.0) - 1.0;\n\treturn sdCross(q);\n}\n\nfloat sdCrossRepScale(vec3 p, float s) {\n\treturn sdCrossRep(p * s) / s;\t\n}\n\n\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\n\n//--------------------------\nfloat DE(vec3 p) {\n\t\n    \n    float scale = 0.55;\n\t\n \n       \n    \n    float dist =sdBox(p- vec3(0.0), vec3(1.0) );\n    \n \n\tfor (int i = 0; i < MENGER_ITERATIONS; i++) {\n\t\tdist = max(dist, -sdCrossRepScale(p, scale));\n\t\tscale *= 3.0;\n\t}\n\n\n    \n    \n\treturn dist;\n}\n\n//oooooooooooooooooooooooooooooooooooooooooooooooooooo\n\n\n\nvec2 march(vec3 ro, vec3 rd){\n\tfloat t=0. , d = far, it = 0.;\n    for (int i=0;i<iter;i++){\n     \tt += (d = DE(ro+t*rd));\n        if(d<eps || t> far) break;\n        it += 1.;\n    }\n    return vec2(t,it/float(iter));\n}\n\nfloat getShadow(vec3 p, vec3 n, vec3 ld){\n    p +=  2. * eps * n;\n    float t=0.,d=far;\n    for(int i=0;i<50;i++){\n        t += (d=DE(p + t*ld));\n        if (d<eps || t>3.) break;\n    }\n    return t<=3. ? 0.1 : 1. ;\n}\n\nvec3 getRay(vec3 ro, vec3 look, vec2 uv){\n    vec3 f = normalize(look - ro);\n    vec3 r = normalize(vec3(f.z,0,-f.x));\n    vec3 u = cross (f,r);\n    return normalize(f + uv.x * r + uv.y * u);\n}\n\nvec3 getNorm(vec3 p){\n    vec2 e = vec2(eps, 0);\n    return normalize(vec3(DE(p+e.xyy)-DE(p-e.xyy),DE(p+e.yxy)-DE(p-e.yxy),DE(p+e.yyx)-DE(p-e.yyx)));\n}\n\nvec3 light(vec3 p, vec3 n){\n    vec3 col = vec3(0.01);\n    for(int i=0;i<2;i++){\n        vec3 ld = (i==0) ? lDir0 : lDir1;\n        float diff = max(dot(n, (ld)),0.);\n        diff *= getShadow(p, n, ld);\n        col += diff * (i==0 ? lCol0 : lCol1);\n    }\n    return col * .7;\n}\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) {\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float time = iTime * 0.5;\n    //float time = iTime * .06;\n    \n    \n\tvec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n  \n    \n    \n    //vec3 ro = vec3(0.5, 0.25, 1.5+ 1.0*cos(time)+time*1.2);\n    vec3 ro = vec3(0.5+sin(iTime), 0.25, 1.5+ 2.0*cos(time));\n     //ro = get_mouse(ro);\n   \n    \n    vec3 rd = getRay(ro, vec3(0.), uv);\n    vec2 hit = march(ro, rd);\n    vec3 p = ro + hit.x*rd;\n    \n    vec3 col = hit.x<far ? light(p, getNorm(p)) : vec3(.1*(1.-length(uv)));\n    \n    \n    col += pow(hit.y,3.);\n\tfragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdlBWB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdlBWN", "name": "Modeling practice", "author": "julianlumia", "description": "just doodling a bit, killing time;)", "tags": ["tag"], "likes": 3, "viewed": 80, "date": "1588287935", "time_retrieved": "2024-06-20T20:08:19.931290", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 10.\n#define SURF_DIST .001\n#define pi acos(-1.)\n\nvec2 condmin(in vec2 d1, in vec2 d2) {\nreturn vec2(min(d1.x, d2.x), mix(d1.y, d2.y, step(d2.x, d1.x)));\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n p = abs(p);\n return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nmat2 Rot(float a) {\n float s = sin(a);\n float c = cos(a);\n return mat2(c, -s, s, c);\n}\n\nfloat displacement(vec3 p, float scale)\n{\n    return sin(scale*p.x)*sin(scale*p.y)*sin(scale*p.z);\n}\n\nfloat smin( float a, float b, float k ) {\n float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdSphere(vec3 p, float s)\n{\n return length(p) - s;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n p = abs(p)-s;\n return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat g1;\nfloat g2;\nfloat g3;\nfloat g4;\nfloat g5;\n\nmat3 rotate( in vec3 v, in float angle)\n{\n\tfloat c = cos(radians(angle));\n\tfloat s = sin(radians(angle));\n\t\n\treturn mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n\t\t(1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n\t\t(1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z\n\t\t);\n}\n\nconst float PI = 3.14159265;\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdTorus(vec3 p, vec2 r)\n{\n float x = length(p.xz) -r.x;\n return length(vec2(x,p.y))-r.y;       \n}\n\nvec3 spherepos;\nvec2 GetDist(vec3 p) {\n vec2 d;\n vec2 e = vec2(p.y +2.75,3);\n vec3 size3 = vec3(3.3,3.5,3.5);\n vec3 pos = vec3(0,0.,.0);\n vec3 p4 = p;\n float the = iTime *.5;\n the = iTime *.6;\n p4.zx *= -mat2(cos(the), -sin(the), sin(the), cos(the));\n p4.zy *= -mat2(cos(the), -sin(the), sin(the), cos(the));\n the = iTime *.2;\n vec2 box11 = vec2((sdOctahedron(p4, 1.5)),5.);\n p.zy *= -mat2(cos(the), -sin(the), sin(the), cos(the));\n p.xy *= -mat2(cos(the), -sin(the), sin(the), cos(the));\n vec2 box10 = vec2((sdBox(p, vec3(5.,.4,.4))),5.);\n float displacement = sin(2.5*p.x+ iTime*0.4)*sin(2.2*p.y+ iTime)*cos(.5*p.z+ iTime);\n box10.x += displacement;  \n vec3 torp = p;\n the =sin( torp.x*0.3 +iTime *1.);\n torp.zy *= -mat2(cos(the), -sin(the), sin(the), cos(the));\n vec2 tor =vec2(sdTorus(torp,vec2(3.,.6)),5.);\n the = iTime *.6;   \n spherepos = vec3(-0.,5.5,-.0);\n float box9 = (sdSphere(p-spherepos, 0.));\n vec2 box;\n vec3 p2 = p;\n the = (iTime*0.5);\n float two = ((dot(sin(p2.zxy+iTime*0.2)*5., cos(p2.zxy*4.+iTime))));\n e.x = mix(e.x,two,sin(p.x*0.1+iTime)*0.01);\n the =sin( p2.x*.2 +iTime *1.);\n p2.zy *= -mat2(cos(the), -sin(the), sin(the), cos(the));\n the = iTime *.6;\n p2.zy *= -mat2(cos(the), -sin(the), sin(the), cos(the));\n p2.xy *= -mat2(cos(the), -sin(the), sin(the), cos(the));\n box = vec2(sdBox(p2, vec3(1.43)),5);\n vec2 box2 = vec2(sdBox(p2, vec3(1.4,1.4,1.5)),1);\n vec2 box3 = vec2(sdBox(p2, vec3(1.4,2.1,1.4)),1);\n vec2 box4 = vec2(sdBox(p2, vec3(1.5,1.4,1.4)),5);\n box.x = max( box.x,-box2.x);\n box.x = max(box.x,-box3.x);\n box4.x = max(box.x,-box4.x);  \n d.x = mix(d.x,box10.x,-.045);\n two = ((dot(sin(p2.zxy*2.+0.), cos(p2.zxy*8.+iTime))));\n box10.x = mix(box10.x,two,.1);\n box10 = vec2(box10.x,3);\n g5 +=1./(.05+pow(abs(box11.x),4.));\n g2 +=.04/(.05+pow(abs(box.x),6.));\n g3 +=1./(10.+box9*box9);\n box10.x = smin(box10.x,box11.x,0.6);\n d = max(box2,box10);   \n box4 = condmin(box4,box11); \n tor.x = mix(tor.x,box10.x,.15);\n d = condmin(d,tor);\n d = condmin(box4,d);\n  return  d;\n}\n\n\nvec2 RayMarch(vec3 ro, vec3 rd) {\nvec2 h, t=vec2( 0.);   \nfor (int i=0; i<MAX_STEPS; i++) \n{   \nh = GetDist(ro + t.x * rd);\nif(h.x<SURF_DIST||abs(t.x)>MAX_DIST) break;\nt.x+=h.x *1.;\nt.y=h.y;\n}\nif(t.x>MAX_DIST) \nt.x=100.;\nt.x +=h.x*1.;\nreturn t;\n}\nfloat marchCount;\n\n\nfloat traceRef(vec3 o, vec3 r){\n    \n float t = 0.0;\n marchCount = 0.0;\n float dO = 0.;  \n for (int i = 0; i < 60; i++)\n {\n  vec3 p = o + r * t;   \n  float d = GetDist (p).x;\n  if(d<.002 || (t)>100.) break;\n  t += d * .2;\n  marchCount+= 1./d*.5;\n }    \n return t;\n}\n\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n vec3 f = normalize(l-p),\n r = normalize(cross(vec3(0,1,0), f)),\n u = cross(f,r),\n c = p+f*z,\n i = c + uv.x*r + uv.y*u,\n d = normalize(i-p);\n return d;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ){\n vec3 cw = normalize(ta-ro);\n vec3 cp = vec3(sin(cr), cos(cr),0.0);\n vec3 cu = normalize( cross(cw,cp) );\n vec3 cv = cross(cu,cw);\n return mat3( cu, cv, cw );\n}\n\nvec3 GetNormal(vec3 p){\nvec2 e = vec2(.00035, -.00035); \nreturn normalize(\n e.xyy * GetDist(p + e.xyy).x + \n e.yyx * GetDist(p + e.yyx).x + \n e.yxy * GetDist(p + e.yxy).x + \n e.xxx * GetDist(p + e.xxx).x);\n}\n\nconst float PI2 = 3.14159265359;\n#define HASHSCALE1 .1031\nfloat hash(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//AO code from: https://www.shadertoy.com/view/4sdGWN\n//by XT95\nvec3 randomSphereDir(vec2 rnd)\n{\n float s = rnd.x*PI*2.;\n float t = rnd.y*2.-1.;\n return vec3(sin(s), cos(s), t) / sqrt(1.0 + t * t);\n}\nvec3 randomHemisphereDir(vec3 dir, float i)\n{\n vec3 v = randomSphereDir( vec2(hash(i+1.), hash(i+2.)) );\n return v * sign(dot(v, dir));\n}\n\nfloat ambientOcclusion( in vec3 p, in vec3 n, in float maxDist, in float falloff )\n{\n const int nbIte = 32;\n const float nbIteInv = 1./float(nbIte);\n const float rad = 1.-1.*nbIteInv; \n float ao = 0.0;\n for( int i=0; i<nbIte; i++ )\n {\n  float l = hash(float(i))*maxDist;\n vec3 rd = normalize(n+randomHemisphereDir(n, l )*rad)*l;\n  ao += (l - max(GetDist( p + rd ),0.).x) / maxDist * falloff;\n }\t\n return clamp( 1.-ao*nbIteInv, 0., 1.);\n}\n//----------\n\nfloat shadow(vec3 r0, vec3 rd, float maxDist)\n{\n float d = .1;\n float shadow = 1.0;\n while(d < maxDist)\n {\n  float t = GetDist(r0 + d * rd).x;\n  if(t < 0.001) return 0.0;\n  d += t;\n  shadow = min(shadow,5.0 * (t / d));\n }\n return shadow;\n}\n\nfloat GetLight(vec3 p) {\n vec3 lightPos = vec3(spherepos);\n vec3 l = normalize(lightPos-p);\n vec3 n = GetNormal(p);\n float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n float d = RayMarch(p+n*SURF_DIST*1., l).x;\n return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 uv =( 2. * fragCoord.xy - iResolution.xy ) / iResolution.y;\nvec2 m = iMouse.xy/iResolution.xy;\n\nvec3 eye = 1.0*vec3(0.,0.,6.);\nvec3 col;\nvec2 d;\nvec3 hoek = vec3(0,0.,2.);  \nfloat   the = (iTime*1.);\nmat3 camera = setCamera( eye, hoek,iTime*0.2);\nfloat fov = 1.2;\nvec3 dir = camera * normalize(vec3(uv, fov));\nvec3 p;\nvec3 n;\nvec3 focalPoint = eye + (dir * 1.);\nvec3 shiftedRayOrigin = eye;\nvec3 shiftedRay = (focalPoint - shiftedRayOrigin);\n d = RayMarch(shiftedRayOrigin, shiftedRay);\nfloat t =d.x *1.;\nvec3  shiftedRayOrigin2 = shiftedRayOrigin;\nvec3  shiftedRay2= shiftedRay;\nif(t<MAX_DIST) {\n shiftedRayOrigin2 += shiftedRay2 * t;\n vec3 sn = GetNormal(shiftedRayOrigin2);\n shiftedRay2 = reflect(shiftedRay2, sn);\n if(d.y==3.) traceRef(shiftedRayOrigin2 +  shiftedRay2*.1, shiftedRay2);\n if(d.y==5.) traceRef(shiftedRayOrigin2 +  shiftedRay2*.1, shiftedRay2);\n if(d.y==7.) traceRef(shiftedRayOrigin2 +  shiftedRay2*.1, shiftedRay2);\n p = shiftedRayOrigin + shiftedRay * t;\n n= GetNormal(p.xyz);\n float a = ambientOcclusion(p,n, 20.,1.5);\n vec3 lp =    spherepos*.9;\n const int numIter = 25;\n vec3 vD = shiftedRay;\n vD = normalize(vD);\n float stepSize = length(p - shiftedRayOrigin) / float(numIter);\n vec3 vO = shiftedRayOrigin + stepSize * vD;\n float accum = 0.0;\n for(int i = 0; i  < numIter; ++i)\n  {\n\tvec3 ld = normalize(lp - vO);\n\tfloat shad = shadow(vO, ld, 10.5);\n\tfloat d = dot(vO, vO);\n\taccum += (.001 / d ) * shad;\n\tvO += stepSize * vD;\n   }\n  vec3   color= vec3(1.);\n col +=g5*vec3(0.001)*vec3(0.,1.,0.)*1.;    \n col +=g2*vec3(0.02)*vec3(.2,.5,.6)*.4;    \n col +=g4*vec3(0.01)*vec3(1.,.6,0.6)*.1;    \n col*= a*5.5; \n col *= marchCount * vec3(.4, .4,0.4) * 0.001;\n float dif = GetLight(p);\n col *= vec3(dif)+5.;\n vec3 sky = vec3(1., 1., 1.);\n col *= mix(sky, col, 10./(t*t/1./1.*1.+1.5));   \n col += g3 * color;   \n if(d.y==5.) col+= vec3(sin(p.z*1.+iTime)*cos(p.x*.3+iTime*0.2)*1.,0,1);\n col *= accum * color *100.;\n }\n col*=1.;\n col=smoothstep(0.0,5.,col);\n col=pow(col, vec3(0.345));\n fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdlBWN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdlBzf", "name": "Procedural water texture", "author": "jarble", "description": "A simple procedural texture, based on [url=https://www.shadertoy.com/view/tdsBRf]this shader[/url].\nThis one isn't very good: I was trying to do a tileable caustic like [url=https://www.shadertoy.com/view/MdlXz8]this one[/url].", "tags": ["procedural", "texture", "water"], "likes": 1, "viewed": 272, "date": "1588798148", "time_retrieved": "2024-06-20T20:08:20.058671", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord)/iResolution.xy;\n    // Time varying pixel color\n    vec2 col = (uv*20.0);\n    for(float i = 1.0; i <4.0; i++){\n        uv += col;\n        col = cos(uv.yx*i+iTime);\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdlBzf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdlfD2", "name": "Hyperbolic bloom", "author": "sl2c", "description": "A horospherical slice a la Bulatov as in [url=https://www.shadertoy.com/view/tsXfWS#]my earlier shader[/url] but this time with a coloring of the icosahedra in the icosahedral honeycomb.", "tags": ["hyperbolic", "horosphere"], "likes": 12, "viewed": 157, "date": "1589387540", "time_retrieved": "2024-06-20T20:08:20.604118", "image_code": "// Copyright 2020 Google LLC\n// SPDX-License-Identifier: Apache-2.0\n// NOT an official Google project; see Google Open Source guidelines for more info on copyright transfer\n// written by William Cadegan-Schlieper \n#define swap(sigma) {for(int k=0;k<6;k++) {int temp = curr[k]; curr[k]=curr2[sigma[k]]; curr2[sigma[k]]=temp;}}\n#define swap2(i,j) {int temp = curr[i]; curr[i]=curr[j]; curr[j]=temp;}\n\nbool flip(inout vec3 z, inout float ds, in vec2 c, in float r, inout float t) {\n    z -= vec3(c,0.0);\n    bool res = (dot(z,z) < r*r) ^^ (r < 0.0);\n    if (res) {\n        ds *= r * r / dot(z,z);\n        z *= r * r / dot(z,z);\n    }\n    t = min(1.0, (dot(z,z)-r*r)/(2.0 * r * ds));\n    z += vec3(c,0.0);\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float phi = 0.5 + sqrt(1.25);\n    vec2 c3 = vec2(phi, phi*phi);\n    float r3 = 2.0 * phi;\n    float r4 = 2.0 / (sqrt(3.0*phi-1.0)-phi*phi);\n    vec2 c4 = vec2(0.0, 0.5*r4);\n    \n    vec3[6] cols = vec3[](\n    \tvec3(1.0,0.5,0.0),\n    \tvec3(0.5,1.0,0.0),\n    \tvec3(0.0,1.0,0.5),\n    \tvec3(0.0,0.5,1.0),\n    \tvec3(0.5,0.0,1.0),\n    \tvec3(1.0,0.0,0.5));\n    \n    int[6] curr = int[](0,1,2,3,4,5);\n    int[6] curr2 = int[](0,1,2,3,4,5);\n    \n    int[6] sigma1 = int[](0,1,2,3,4,5);\n    int[6] sigma2 = int[](0,3,4,1,2,5);\n    int[6] sigma3 = int[](0,1,2,4,5,3);\n    int[6] sigma4 = int[](1,0,2,3,5,4);\n    \n    vec2 z = 2.0 * (fragCoord - iResolution.xy * 0.5)/iResolution.y;\n    float ds = 2.0 / iResolution.y;\n    z *= 6.0; ds *= 6.0;\n    vec3 zh = vec3(z, 1.0);\n    \n    float period = 0.6149689755422006;\n    float d = iTime * 0.2;\n    while (d > period * 0.1) {\n        float c = -0.8861114478828093; float s = -0.4634722234730269;\n        zh.xy = vec2(zh.x * c - zh.y * s, zh.x * s + zh.y * c);\n        d -= period;\n        swap2(0,1); swap2(3,4); swap2(1,3); swap2(2,4); \n    }\n    curr2 = curr;\n    \n    \n    zh *= exp(-d); ds *= exp(-d);\n    zh += vec3(0.09504814910742845,0.19915381513146063,0.0);\n    zh /= dot(zh, zh); ds *= dot(zh, zh);\n    zh -= vec3(0.9759259749906782,2.0448518254217527,0.0);\n    \n    float t = 1.0;\n    bool fl = false;\n    \n    for (int i=0; i<15; i++) {\n        if (zh.x < 0.0) {\n            zh.x = -zh.x;\n            fl = !fl;\n            swap(sigma1);\n        }\n        if (zh.y < 0.0) {\n            zh.y = -zh.y;\n            fl = !fl;\n            swap(sigma2);\n        }\n        \n        float throwaway;\n        if (flip(zh, ds, c3, r3, throwaway)) {\n            fl = !fl;\n            swap(sigma3);\n        }\n        if (flip(zh, ds, c4, r4, t)) {\n            fl = !fl;\n            swap(sigma4);\n        }\n    }\n\n    t = (1.0 - t) * 0.5;\n    vec3 col1 = cols[fl ? curr[0] : curr2[0]];\n    swap(sigma4);\n    vec3 col2 = cols[fl ? curr2[0] : curr[0]];\n    vec3 col = col1 * (1.0-t) + col2 * t;\n\n    fragColor = vec4(col,1.0);\n    fragColor = pow(fragColor, vec4(1.0/2.2));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "apache-2.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdlfD2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdlfDH", "name": "DigEggs  (179 chars)", "author": "Smake", "description": "The simplest 3d game.\nUse mouse to avoid collisions.\nit's just a demo )\n", "tags": ["3d", "raymarching", "game", "smallest", "fly", "shiortest"], "likes": 2, "viewed": 246, "date": "1588445159", "time_retrieved": "2024-06-20T20:08:20.610168", "image_code": "void mainImage( out vec4 O, in vec2 U )  {                         \n    vec4  c = vec4(U/7e2, 1,0), r;                 \n          r +=.01*iMouse + cos(iTime);            \n    for  (r.z = iTime; O.a++ < 1e2; )             \n          r += .5*c*(length(fract(r.xyz)-.5)-.2); \n          O = fract(r*9.) - .1*(r.z - iTime);\n}", "image_inputs": [{"id": "4ljGDw", "previewfilepath": "https://soundcloud.com/mrswilfongsmusicclass/the-ride-of-the-valkyries-by", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/mrswilfongsmusicclass/the-ride-of-the-valkyries-by", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdlfDH.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdlfDj", "name": "string theory smooth..", "author": "sense", "description": "string theory smooth", "tags": ["julia", "string", "hack"], "likes": 1, "viewed": 48, "date": "1589109274", "time_retrieved": "2024-06-20T20:08:20.610168", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy + iMouse.xy/ iResolution.xy;\n\n    vec2 cc = 10.1*vec2( 0.23*tanh(0.1*iTime) + 0.25*cos(1.02/iTime), \n\t                    0.5+sin(0.1*iTime) - 0.25*tanh(12.002+iTime));\n\n\tvec4 dmin = vec4(100.0);\n    vec2 z = (-1.0 + 1.0*p)*vec2(1.6,1.3);\n    for( int i=0; i<256; i++ )\n    {\n        z = cc + vec2( z.x*z.x - z.y/z.y, 33.0*z.x*z.y );\n\t\tz += 0.15+sin(float(i));\n\t\tdmin=min(dmin, vec4(abs(0.0+z.y - 2.2*sin(z.x)), \n\t\t\t\t\t\t\tabs(1.0+z.x + 23.25*sin(z.y)), \n\t\t\t\t\t\t\tdot(z,z),\n\t\t\t\t\t\t    length( fract(z)-0.2) ) );\n    }\n    \n    vec3 color = vec3( dmin.w );\n\tcolor = mix( color, vec3(2.80,0.40,0.20),     min(10.0,pow(dmin.x*1.25,0.20)) );\n    color = mix( color, vec3(0.12,0.70,0.60),     min(1.0,pow(dmin.y*0.50,0.50)) );\n\tcolor = mix( color, vec3(0.90,0.40,0.20), 1.0-min(1.0,pow(dmin.z*1.00,0.15) ));\n\n\tcolor = 1.25*color+color+color*color;\n\t\n\tcolor *= 0.5555 + 0.5*pow(9.0*p.x*(1.0-p.y)*p.y*(1.0-p.y),0.15);\n\n\tfragColor = vec4(color,3.0)*0.33;\n}\n\n\n// mod of mod from original maker \n// https://www.shadertoy.com/view/MsXGzr", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdlfDj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdlfDX", "name": "infinite stairs - helix 1d2", "author": "FabriceNeyret2", "description": ".", "tags": ["raymarching", "sdf", "spiral", "helix", "short", "helicoid"], "likes": 4, "viewed": 251, "date": "1589211340", "time_retrieved": "2024-06-20T20:08:20.767763", "image_code": "// variant of https://shadertoy.com/view/tdlfWX\n\nvoid mainImage(out vec4 O, vec2 U) {\n    \n    float T = iTime, t=1.,a;\n    vec3  q = iResolution,\n          D = vec3(.3*(U+U-q.xy)/q.y, -1),        // ray direction\n          p = 30./q;                              // marching point along ray \n    O-=O;\n    for ( O++; O.x > 0. && t > .01 ; O-=.015 )\n        q = p.xzy - vec3(0,0,T),\n        t = abs(length(q.xy)-6.)-2.,              // bounding hollow cylinder\n        a = atan(q.y,q.x) - .3*T,\n        t = max(t, abs(fract(a*24./6.283+.6)-.3)*6.283/24. -.05),\n        t = max(t, sin(a-floor(q.z*4.)/4.*1.047 )),  // helix: stairs side\n        t = max(t, sin(a-q.z*1.047+3.) ),            // helix: roof side\n        p += t*D;                                 // step forward = dist to obj\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdlfDX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdlfRB", "name": "robo", "author": "im_paul_hi", "description": "bobo", "tags": ["robo"], "likes": 38, "viewed": 229, "date": "1588551201", "time_retrieved": "2024-06-20T20:08:29.241295", "image_code": "/*\n    -design from: https://dribbble.com/shots/10707556-Another-Dimension\n    -sdf functions from iq   \n    -\n\n*/\n\n// #define AA 0.005\n#define PI 3.14159\n#define TAU 2.0 * PI\n#define gridThickness 0.05\n\nvec3 headColor = vec3(0.45,0.21,0.67);\nvec3 bgColor = vec3(0.55,0.82,0.87);\nvec3 headGooColor = vec3(0.87,0.56,0.40);\nvec3 blackOutlineColor = vec3(0.09,0.08,0.16);\nvec3 gearCol1 = vec3(0.44,0.48,0.80);\nvec3 gearCol2 = vec3(0.36,0.83,0.99);\nvec3 col = vec3(0.55,0.82,0.87);\nfloat blackOutlineWidth = 0.02;\nvec3 mixedCol = vec3(0.0);\nfloat AA = 0.005;\n\n/*********************************************************\n**********************************************************\n**********************************************************\n**********************************************************/\n\nfloat linearStep(float begin, float end, float t) {\n    return clamp((t - begin) / (end - begin), 0.0, 1.0);\n}\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nvec2 within(vec2 uv, vec4 rect) {\n    vec2 val = (uv-rect.xy)/(rect.zw-rect.xy);\n    // val.y = remap(val.y, 0.0, 1.0, 1.0, 0.0);\n    val.y = -val.y + 1.0;\n\treturn val;\n}\n\nfloat inside01(vec2 p) {\n    return step(0.0, p.x) * (1.0 - step(1.0, p.x)) * step(0.0, p.y) * (1.0 - step(1.0, p.y));\n}\n\nfloat insideY(vec2 p) {\n    return step(0.0, p.y) * (1.0 - step(1.0, p.y));\n}\n\nfloat insideX(vec2 p) {\n    return step(0.0, p.x) * (1.0 - step(1.0, p.x));\n}\n\nvoid addGrid(vec2 p, inout vec3 col) {\n    float all = inside01(p);\n    vec3 gridOutlineCol = vec3(1.0, 0.0, 0.0);\n    vec3 gridCol = vec3(0.0);\n\n    // add outline\n    float outline = step(p.x, gridThickness);\n    outline += step(1.0 - gridThickness, p.x);\n    outline += step(p.y, gridThickness);\n    outline += step(1.0 - gridThickness, p.y);\n\n    // p.y = -p.y;\n    // p.y += 1.0;\n\n    // float outline = step(0.0, p.y) * (1.0 - step(0.1, p.y));\n\n    col = mix(col, gridOutlineCol, outline * all);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nvec3 returnDottedCol(vec2 p, vec3 bgCol, vec3 dotCol) {\n    vec3 dottedCol = vec3(0.0);\n\n    p *= 28.0;\n    p.x += 0.48;\n    p.y *= 2.49;\n    float yIndex = floor(p.y);\n    float xIndex = floor(p.x);\n    p = fract(p);\n\n    // float circle = smoothstep(mod1, mod2, length(p - vec2(0.5)));\n    // circle *= smoothstep(mod3, mod4, length(p - vec2(1.0, 0.0)));\n\n    float circleBool = 0.0;\n\n    float circle = smoothstep(0.3, 0.6, length(p - vec2(0.5)));\n\n    if(mod(xIndex, 2.0) == 0.0 && mod(yIndex, 2.0) == 0.0) {\n        circleBool = 0.0;\n    } else if(mod(xIndex, 2.0) != 0.0 && mod(yIndex, 2.0) == 0.0) {\n        circleBool = 1.0;\n    } else if(mod(xIndex, 2.0) == 0.0 && mod(yIndex, 2.0) != 0.0) {\n        circleBool = 1.0;\n    }\n\n    dottedCol = mix(bgCol, dotCol, (1.0 - circle) * circleBool);\n\n    return dottedCol;\n}\n\nfloat gain(float x, float k) \n{\n    float a = 0.5*pow(2.0*((x<0.5)?x:1.0-x), k);\n    return (x<0.5)?a:1.0-a;\n}\n\nfloat expImpulse( float x, float k )\n{\n    float h = k*x;\n    return h*exp(1.0-h);\n}\n\nfloat customEase(float x, float k) {\n    return pow(x, k);\n}\n\nfloat almostIdentity( float x, float m, float n )\n{\n    if( x>m ) return x;\n    float a = 2.0*n - m;\n    float b = 2.0*m - 3.0*n;\n    float t = x/m;\n    return (a*t + b)*t*t + n;\n}\n\nfloat undulateAngle(int index, float angle, float movementScale, float offsetScale, float timeScale) {\n    float offset = float(index) * offsetScale;\n    float m = angle + sin(iTime * timeScale + offset) * movementScale;\n    return m;\n}\n\n\n\n/*********************************************************\n**********************************************************\n**********************************************************\n**********************************************************/\n\nfloat sdCircle( in vec2 p, in float r ) \n{\n    return length(p)-r;\n}\n\nfloat sdCross( in vec2 p, in vec2 b, float r ) \n{\n    p = abs(p); p = (p.y>p.x) ? p.yx : p.xy;\n    vec2  q = p - b;\n    float k = max(q.y,q.x);\n    vec2  w = (k>0.0) ? q : vec2(b.y-p.x,-k);\n    return sign(k)*length(max(w,0.0)) + r;\n}\n\n\n\nfloat returnTween4Dist(vec2 p, float t, float circleRadius) {\n    // t = normalized time\n    vec2 from = vec2(0.5, 0.66);\n    vec2 to = vec2(0.5, 0.3);\n    float radius = (from.y - to.y) / 2.0;\n    float startAngle = (3.0 * PI) / 2.0;\n    float endAngle = PI;\n    float angle = map(t, 0.0, 1.0, startAngle, endAngle);\n    float angleOffset = -PI * 2.0;\n    // cycle through angle based on t\n    vec2 pos = vec2(sin(angle + angleOffset) * radius, cos(angle + angleOffset) * radius);\n    pos += 0.5;\n    float d = sdCircle(p - pos, circleRadius);\n    return d;\n}\n\nfloat returnTween5Dist(vec2 p, float t, float circleRadius) {\n    // t = normalized time\n    vec2 from = vec2(0.5, 0.32);\n    vec2 to = vec2(0.5, -0.3);\n    vec2 pos = mix(from, to, t);\n    float d = sdCircle(p - pos, circleRadius);\n    return d;\n}\n\nfloat returnTween1Dist(vec2 p, float t, float circleRadius) {\n    // t = normalized time\n    vec2 from = vec2(0.5, 1.0);\n    vec2 to = vec2(0.5, 0.66);\n    vec2 pos = mix(from, to, t);\n    float d = sdCircle(p - pos, circleRadius);\n    return d;\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvoid makeSecondSwoop(vec2 p, inout float d, float loopTime, inout vec3 col, float time) {\n    p -= vec2(0.28, 0.02);\n    // p -= vec2(0.58, 0.02);  // debug view\n\n    for(int i = 0; i < 10; i++) {\n        float d1 = 0.0;\n        float margin = sin(float(i) + time) * 1.0;\n        float modTime = fract((time + margin) / loopTime);\n        float circleRadius = map(modTime, 0.0, 1.0, 0.0, 0.15);\n\n        if(modTime < 0.5) {\n            d1 = returnTween4Dist(p, linearStep(0.0, 0.5, modTime), circleRadius);\n        } else {\n            d1 = returnTween5Dist(p, linearStep(0.5, 1.0, modTime), circleRadius);\n        }\n       \n        // d1 = smoothstep(0.0, AA, d1);\n        // col = mix(col, vec3(1.0), 1.0 - d1);\n\n        if(i != 0) {\n            d = opSmoothUnion(d, d1, 0.04);\n        }\n    }\n}\n\nfloat returnTween2Dist(vec2 p, float t, float circleRadius) {\n    // t = normalized time\n    vec2 from = vec2(0.5, 0.66);\n    vec2 to = vec2(0.5, 0.33);\n    float radius = (from.y - to.y) / 2.0;\n    float startAngle = PI / 2.0;\n    float endAngle = (3.0 * PI) / 2.0;\n    float angle = map(t, 0.0, 1.0, startAngle, endAngle);\n    float angleOffset = -PI * 0.5;\n    // cycle through angle based on t\n    vec2 pos = vec2(sin(angle + angleOffset) * radius, cos(angle + angleOffset) * radius);\n    pos += 0.5;\n    float d = sdCircle(p - pos, circleRadius);\n    return d;\n}\n\nfloat returnTween3Dist(vec2 p, float t, float circleRadius) {\n    // t = normalized time\n    vec2 from = vec2(0.5, 0.33);\n    vec2 to = vec2(0.66, -0.1);\n    vec2 pos = mix(from, to, t);\n    float d = sdCircle(p - pos, circleRadius);\n    return d;\n}\n\nfloat sdBox( in vec2 p, in vec2 b, float r)\n{\n    vec2 d = abs(p) - (b - r);\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r;\n}\n\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\n\n\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat sdRoundBox( in vec2 p, in vec2 b, in vec4 r ) \n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    \n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat dot2(in vec2 v ) { return dot(v,v); }\n\n// trapezoid / capped cone, specialized for Y alignment\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n\n\tp.x = abs(p.x);\n    vec2 ca = vec2(max(0.0,p.x-((p.y<0.0)?r1:r2)), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    \n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, float rb )\n{\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p.xy,scb) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d + (c + b*t)*t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    return sqrt( res );\n}\n\n/*********************************************************\n**********************************************************\n**********************************************************\n**********************************************************/\n\n\nvoid eye(in vec2 p, inout vec3 col) { \n    // eye lash black bottom\n    // float r = 0.06;\n  \tfloat d = sdSegment(p, vec2(0.5, 0.5), vec2(0.5, 1.04)) - 0.06;\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n\n    // eye lash color\n    // r = 0.045;\n  \td = sdSegment(p, vec2(0.5, 0.5), vec2(0.5, 1.04)) - 0.045;\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, vec3(0.90,0.76,0.34), 1.0 - d);\n\n    // bottom outline\n    // r = 0.4;\n  \td = sdSegment(p, vec2(0.5, 0.5), vec2(0.5, 0.6)) - 0.4;\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n\n    // bottom gear\n    d = sdCircle(p - vec2(0.5, 0.51), 0.39);\n    d = smoothstep(0.0, AA, d);\n    mixedCol = mix(gearCol1, gearCol2, smoothstep(0.67, 0.83, p.x));\n    col = mix(col, mixedCol, 1.0 - d);\n\n    // add lines\n    // only where bottom gear is showing\n    float lines = smoothstep(0.076, 0.079, mod((p.x + iTime * 0.03) * 2.0, 0.1));\n    col = mix(col, vec3(0.0), lines * (1.0 - d));\n\n\n    // r = 0.4;\n    d = sdSegment(p, vec2(0.5, 0.58), vec2(0.5, 0.62)) - 0.4;\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n\n    // r = 0.39;\n    d = sdSegment(p, vec2(0.5, 0.59), vec2(0.5, 0.61)) - 0.39;\n    d = smoothstep(0.0, AA, d);\n    mixedCol = mix(vec3(0.55,0.23,0.65), vec3(0.92,0.54,0.37), smoothstep(0.18, 0.92, p.y));\n    col = mix(col, mixedCol, 1.0 - d); \n    \n    ///////////////////////////////////////////////////////////\n    // top gear\n    // black bottom of top gear\n    // r = 0.3;\n    d = sdSegment(p, vec2(0.5, 0.59), vec2(0.5, 0.66)) - 0.3;\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d); \n\n    // top gear\n    d = sdCircle(p - vec2(0.5, 0.6), 0.29);\n    d = smoothstep(0.0, AA, d);\n    mixedCol = mix(vec3(0.40,0.70,0.61), vec3(0.87,0.76,0.37), 1.0 - p.x);\n    col = mix(col, mixedCol, 1.0 - d);\n\n    // top gear lines\n    lines = smoothstep(0.076, 0.079, mod((p.x - iTime * 0.03) * 2.0, 0.1));\n    col = mix(col, vec3(0.0), lines * (1.0 - d));\n\n    //black bottom of top colored gear\n    // r = 0.3;\n    d = sdSegment(p, vec2(0.5, 0.67), vec2(0.5, 0.67)) - 0.3;\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d); \n\n    // r = 0.285;\n    d = sdSegment(p, vec2(0.5, 0.67), vec2(0.5, 0.67)) - 0.285;\n    d = smoothstep(0.0, AA, d);\n    mixedCol = mix(vec3(0.99,0.96,0.86), vec3(0.92,0.81,0.48), p.x);\n    col = mix(col, mixedCol, 1.0 - d); \n\n    // pupil\n    // r = 0.2;\n    d = sdSegment(p, vec2(0.5, 0.67), vec2(0.5, 0.67)) - 0.2;\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d); \n\n    // iris\n    // r = 0.05;\n    d = sdSegment(p, vec2(0.5, 0.67), vec2(0.5, 0.67)) - 0.05;\n    d = smoothstep(0.0, AA, d);\n    mixedCol = mix(vec3(0.75,0.76,0.55), vec3(0.48,0.82,0.86), p.x);\n    col = mix(col, mixedCol, 1.0 - d); \n\n    // addGrid(p, col);\n}\n\nvoid head(in vec2 p, inout vec3 col) {\n\n    // black outline\n\tfloat d = sdSegment(p, vec2(0.5, 0.5), vec2(0.5, 0.0)) - 0.5;\n    d = smoothstep(0.0, AA,d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n\n    // head goo\n    d = sdSegment(p, vec2(0.5, 0.5), vec2(0.5, 0.0)) - 0.5 * (1.0 - blackOutlineWidth);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, headGooColor, 1.0 - d);\n\n    ////////////////////////////////////////////////\n    // head black\n    // head bg outline color\n\n    float d1 = sdSegment(p, vec2(0.5, 0.5), vec2(0.5, 0.0)) - 0.44;\n    \n\n    float d2 = sdSegment(p, vec2(0.85, 0.2), vec2(0.8, 0.2)) - 0.03;\n\td = opSmoothUnion(d1, d2, 0.2);\n\t\n    \n \n    d1 = sdSegment(p, vec2(0.8,0.7), vec2(0.8,0.7)) - 0.005;\n    d = opSmoothUnion(d, d1, 0.3);\n    \n\n    d1 = sdSegment(p, vec2(0.72, 0.92), vec2(0.72, 0.92)) - 0.005;\n    d = opSmoothSubtraction(d1, d, 0.15);\n\n    d1 = sdSegment(p, vec2(0.92, 0.62), vec2(0.92, 0.62)) - 0.005;\n    d = opSmoothSubtraction(d1, d, 0.1);\n\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    \n    \n    // ////////////////////////////////////////////////\n    // head main color\n    d = sdSegment(p, vec2(0.5, 0.5), vec2(0.5, 0.0)) - 0.43;\n\n    d1 = sdSegment(p, vec2(0.85, 0.2), vec2(0.8, 0.2)) - 0.02;\n    d = opSmoothUnion(d, d1, 0.2);\n\n    d1 = sdSegment(p, vec2(0.8,0.7), vec2(0.8,0.7)) - 0.004;\n    d = opSmoothUnion(d, d1, 0.3);\n\n    d1 = sdSegment(p, vec2(0.72, 0.92), vec2(0.72, 0.92)) - 0.004;\n    d = opSmoothSubtraction(d1, d, 0.15);\n\n    d1 = sdSegment(p, vec2(0.92, 0.62), vec2(0.92, 0.62)) - 0.004;\n    d = opSmoothSubtraction(d1, d, 0.1);\n\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, headColor, 1.0 - d);\n\n    // addGrid(p, col);\n}\n\nvoid mouth(in vec2 p, inout vec3 col) {\n    float isInside = inside01(p);\n\n    // light bg\n    vec3 mixedCol = mix(vec3(0.94,0.85,0.59), vec3(1.00,0.98,0.91), p.y);\n    col = mix(col, mixedCol, isInside);\n\n    // circle black bottom\n    vec2 pMod = vec2(p.x, p.y * 0.5);\n    float d = sdCircle(pMod - vec2(0.5, -0.2), 0.37);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n\n    // circle color\n    d = sdCircle(pMod - vec2(0.5, -0.21), 0.36);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, vec3(0.91,0.54,0.36), 1.0 - d);\n    \n    /////////////////////////////////////////////////////////////////////\n    // OIL\n    /////////////////////////////////////////////////////////////////\n    // oil pipe\n    d = sdSegment(p, vec2(0.75, 0.9), vec2(0.75, 0.0)) - 0.03;\n\n    // setup oilBulge1 anim\n    float loopTime = 3.0;\n    float modTime = mod(iTime, loopTime);\n    modTime = 1.0 - (modTime / loopTime); \n    float yPos = ((abs(-0.2) + abs(0.5)) * modTime) + -0.2; \n    pMod = vec2(p.x, p.y * 0.4);\n    float d1 = sdSegment(pMod, vec2(0.75, yPos), vec2(0.75, yPos)) - 0.05 * isInside;\n    d = opSmoothUnion(d, d1, 0.11);\n\n   // setup oilBulge2 anim\n    modTime = mod(iTime + 1.0, loopTime);\n    modTime = 1.0 - (modTime / loopTime);\n    yPos = ((abs(-0.2) + abs(0.5)) * modTime) + -0.2; \n    \n    // sd of oilbulge2\n    d1 = sdSegment(pMod, vec2(0.75, yPos), vec2(0.75, yPos)) - 0.03 * isInside;\n    d = opSmoothUnion(d, d1, 0.11);\n\n    // setup oilBulge3 anim\n    modTime = mod(iTime + 2.0, loopTime);\n    modTime = 1.0 - (modTime / loopTime);\n    yPos = ((abs(-0.2) + abs(0.5)) * modTime) + -0.2; \n    \n    // sd of oilbulge3\n    d1 = sdSegment(pMod, vec2(0.75, yPos), vec2(0.75, yPos)) - 0.01 * isInside;\n    d = opSmoothUnion(d, d1, 0.11);\n\n    //////////////////////////////////////////////////////////////\n    // middle oil pipe\n    d1 = sdSegment(p, vec2(0.5, 0.9), vec2(0.5, 0.0)) - 0.01;\n    d = opSmoothUnion(d, d1, 0.11);\n\n    // middle bulge 1\n    loopTime = 3.8;\n    modTime = mod(iTime, loopTime);\n    modTime = 1.0 - (modTime / loopTime);\n    yPos = ((abs(-0.2) + abs(0.5)) * modTime) + -0.2;\n    d1 = sdSegment(pMod, vec2(0.5, yPos), vec2(0.5, yPos)) - 0.01 * isInside;\n    d = opSmoothUnion(d, d1, 0.11);\n\n    // middle bulge 2\n    modTime = mod(iTime + 1.3, loopTime);\n    modTime = 1.0 - (modTime / loopTime);\n    yPos = ((abs(-0.2) + abs(0.5)) * modTime) + -0.2; \n    // bulge2Pos = vec2(0.5, yPos);\n\n    // sd of middle oilbulge2\n    d1 = sdSegment(pMod, vec2(0.5, yPos), vec2(0.5, yPos)) - 0.05 * isInside;\n    d = opSmoothUnion(d, d1, 0.11);\n\n    // setup middle oilBulge3 anim\n    modTime = mod(iTime + 2.6, loopTime);\n    modTime = 1.0 - (modTime / loopTime);\n    yPos = ((abs(-0.2) + abs(0.5)) * modTime) + -0.2; \n    \n    // sd of middle oilbulge3\n    d1 = sdSegment(pMod, vec2(0.5, yPos), vec2(0.5, yPos)) - 0.03 * isInside;\n    d = opSmoothUnion(d, d1, 0.11);\n\n    //////////////////////////////////////////////////////////\n    // TOP OIL LINE\n\n    loopTime = 3.0;\n    modTime = mod(iTime, loopTime);\n    modTime /= loopTime;\n    float m = (abs(sin(modTime * TAU)) + 0.2) * 0.3;\n    d1 = sdSegment(p, vec2(0.0, 0.96), vec2(1.0, 0.96)) - 0.04;\n    d = opSmoothUnion(d, d1, m);\n\n    //////////////////////////////////////////////\n    // SIDE OIL LINE\n    d1 = sdSegment(p, vec2(1.0, 1.0), vec2(1.0, 0.0)) - 0.015;\n    d = opSmoothUnion(d, d1, 0.11);\n\n    // draw oil\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, (1.0 - d) * isInside);\n\n}\n\nvoid nose(in vec2 p, inout vec3 col) {\n    float isInside = inside01(p);\n    float isInsideY = insideY(p);\n    float isInsideX = insideX(p);\n    vec2 modP = vec2(0.0);\n    vec3 mixedCol = vec3(0.0);\n\n    ////////////////////////////////////////////////////////\n    // hourglass black bottom - top triangle\n    float d2 = sdTriangle(p, vec2(0.48, 0.63), vec2(0.48, 0.85), vec2(1.0, 0.85));\n    // hourglass black bottom - bottom triangle\n    float d1 = sdTriangle(p, vec2(0.91, 0.39), vec2(0.52, 0.64), vec2(0.0, 0.41));\n    float d = opSmoothUnion(d1, d2, 0.14);\n    // hourglass black bottom - middle bend\n    modP = vec2(p.x, p.y * 2.0);\n    float d3 = sdCircle(modP - vec2(0.68, 1.26), 0.04);\n    d = opSmoothUnion(d, d3, 0.1);\n    // hourglass black bottom - top bend\n    d1 = sdCircle(modP - vec2(0.85, 1.64), 0.11);\n    d = opSmoothUnion(d, d1, 0.11);\n    // draw hourglass black bottom\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    //////////////////////////////////////////////////////\n    // hourglass colored - top triangle\n    d2 = sdTriangle(p, vec2(0.40, 0.63), vec2(0.47, 0.84), vec2(0.91, 0.84));\n    // hourglass colored - bottom triangle\n    d1 = sdTriangle(p, vec2(0.8645, 0.39), vec2(0.494, 0.64), vec2(0.0, 0.41));\n    d = opSmoothUnion(d1, d2, 0.14);\n    // hourglass colored - middle bend\n    modP = vec2(p.x, p.y * 2.0);\n    d3 = sdCircle(modP - vec2(0.65, 1.26), 0.01);\n    d = opSmoothUnion(d, d3, 0.16);\n    // hourglass colored - top bend\n    d1 = sdCircle(modP - vec2(0.85, 1.64), 0.09);\n    d = opSmoothUnion(d, d1, 0.11);\n    // draw hourglass colored\n    d = smoothstep(0.0, AA, d);\n    vec3 dottedCol = returnDottedCol(p, vec3(0.89,0.76,0.34), vec3(0.81,0.43,0.12));\n    col = mix(col, dottedCol, 1.0 - d);\n\n\n    ////////////////////////////////////////////////////\n    // black bottom\n    modP = vec2(p.x, p.y * 3.0);\n    // float r = 0.5;\n    d1 = sdSegment(modP, vec2(0.5, 0.9), vec2(0.5, 0.4)) - 0.5;\n    // float subtractR = 0.07;\n    d2 = sdSegment(p, vec2(0.67, -0.1), vec2(0.5, -0.1)) - 0.07;\n\n    d3 = opSmoothSubtraction(d2, d1, 0.5);\n\n    // r = 0.05;\n    d = sdSegment(p, vec2(0.93, 0.1), vec2(0.93, 0.02)) - 0.05;\n    d = opSmoothUnion(d, d3, 0.01);\n\n    // r = 0.005;\n    d1 = sdSegment(p, vec2(0.7, -0.01), vec2(1.4, -0.01)) - 0.005;\n    float loopTime = 2.0;\n    float modTime = mod(iTime, loopTime) / loopTime;\n    float smoothVal = (abs(sin(modTime * TAU))) * 0.085;\n    d = opSmoothUnion(d, d1, smoothVal * isInsideY);\n\n    // middle bottom pipe\n    // r = 0.05;\n    d2 = sdSegment(p, vec2(0.5, 0.1), vec2(0.5, -0.01)) - 0.05;\n    d = opSmoothUnion(d, d2, 0.09);\n\n    // middle bottom pipe connector\n    // r = 0.005;\n    d1 = sdSegment(p, vec2(0.4, -0.01), vec2(0.6, -0.01)) - 0.005;\n    loopTime = 2.0;\n    modTime = mod(iTime + 0.5, loopTime) / loopTime;\n    smoothVal = (abs(sin(modTime * TAU)) + 0.07) * 0.1;\n    d = opSmoothUnion(d, d1, smoothVal);\n\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n\n    ///////////////////////////////////////////////////\n    // nose tubes\n\n    // r = 0.13;\n    vec2 pMod = vec2(p.x * 0.9, p.y * 2.5);\n    d = sdSegment(pMod, vec2(0.59, 0.69), vec2(0.59, 0.37)) - 0.13;\n    mixedCol = mix(vec3(0.40,0.36,0.67), vec3(0.35,0.84,0.99), smoothstep(0.54, 0.85, p.x));\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, mixedCol, 1.0 - d);\n\n    // nose tube bottom black\n    d = sdCircle(pMod - vec2(0.59, 0.36), 0.13);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n\n    // nose tube middle black ring\n    loopTime = 2.0;\n    modTime = mod(iTime, loopTime) / loopTime;\n    float m = 0.06 * abs(sin(modTime * TAU)) + 0.54;\n    d = sdCircle(pMod - vec2(0.59, 0.52), 0.14);\n    d2 = sdCircle(pMod - vec2(0.59, m), 0.13);\n    d = opSubtraction(d, d2);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n\n    // nose tube bottom color\n    d = sdCircle(pMod - vec2(0.59, 0.34), 0.12);\n    d = smoothstep(0.0, AA, d);\n    mixedCol = mix(vec3(0.58,0.28,0.56), vec3(0.90,0.53,0.37), smoothstep(0.09, 0.18, p.y));\n    col = mix(col, mixedCol, 1.0 - d);\n\n    // addGrid(p, col);\n\n}\n\nvoid upperThirdEyeOil(vec2 p, inout vec3 col, vec2 origP) {\n    float d = 0.0;\n    float d1 = 0.0;\n    float d2 = 0.0;\n    float d3 = 0.0;\n    float r = 0.0;\n    vec2 modP = vec2(0.0);\n    vec2 p1 = vec2(0.0);\n    vec3 mixedCol = vec3(0.0);\n    float modTime = 0.0;\n    float loopTime = 0.0;\n    vec2 pos1 = vec2(0.0);\n    vec2 pos2 = vec2(0.0);\n    vec2 mixedPos = vec2(0.0);\n    float isWithinTrapezoid = 0.0;\n    float mask = 0.0;\n    float mask1 = 0.0;\n    float mask2 = 0.0;\n    float m = 0.0;\n    float dropOffset = 0.5;\n\n    modP = within(vec2(abs(origP.x), origP.y), vec4(-0.24, 0.61, 0.7, -0.33));\n\n    d = sdBezier(modP, vec2(0.33, 0.59), vec2(0.61, 0.57), vec2(0.7, 0.26)) - 0.02;\n    // draw base oil\n    // d = smoothstep(0.0, AA, d);\n    // col = mix(col, blackOutlineColor, 1.0 - d);\n\n    loopTime = 4.0;\n    // draw drops\n    for(int i = 0; i < 7; i++) {\n        float margin = sin(0.4 * float(i) + iTime);\n        modTime = fract((iTime + margin) / loopTime);\n        modTime = map(modTime, 0.0, 1.0, 0.2, 0.85);\n        float remap = map(modTime, 0.0, 1.0, -1.0, 1.0);\n        float y = 1.0 - pow(abs(sin(PI * remap / 2.0)), 2.0);\n        float circleRadius = map(y, 0.0, 1.0, 0.0, 0.015);\n\n        float m = 1.0 - pow(abs(modTime), 8.5);\n        vec2 pos = vec2(modTime, m);\n        pos += vec2(-0.17, -0.42);\n        d1 = sdCircle(modP - pos, circleRadius);\n\n        // d1 = smoothstep(0.0, AA, d1);\n        // col = mix(col, vec3(1.0), 1.0 - d1);\n\n        d = opSmoothUnion(d, d1, 0.035);\n    }\n\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n\n\n    // addGrid(modP, col);\n}\n\nvoid thirdEye(in vec2 p, inout vec3 col, vec2 origP) {\n    float d = 0.0;\n    float d1 = 0.0;\n    float d2 = 0.0;\n    float d3 = 0.0;\n    float r = 0.0;\n    vec2 modP = vec2(0.0);\n    vec3 mixedCol = vec3(0.0);\n    float modTime = 0.0;\n    float loopTime = 0.0;\n    vec2 pos1 = vec2(0.0);\n    vec2 pos2 = vec2(0.0);\n    vec2 mixedPos = vec2(0.0);\n    float isWithinTrapezoid = 0.0;\n    float mask = 0.0;\n    float mask1 = 0.0;\n    float mask2 = 0.0;\n    float m = 0.0;\n    float dropOffset = 0.5;\n\n    /////////////////////\n    // THIRD EYE CIRCLES\n    ////////////////////\n    // oil line on non circle part of circles\n    d = sdSegment(p, vec2(0.5, 0.61), vec2(0.5, 0.55)) - 0.007;\n    d1 = sdCircle(p - vec2(0.5, 0.52), 0.02);\n    d = opSmoothUnion(d, d1, 0.05);\n\n    //////////////////////////////////////////\n    // circular movement drip 1\n    modP = vec2(abs(origP.x) * 2.2, origP.y * 3.0);\n    modP.x += 0.5;\n    loopTime = 3.0;\n    modTime = fract(iTime / loopTime); \n    // run normalized time through easing function\n    modTime = expImpulse(modTime, 0.5);\n    if(modTime < 0.55) {\n        m = map(modTime, 0.0, 0.55, 1.4, 0.47);\n    } else {\n        m = max(sin( (modTime - -0.72) / 0.69 ) + -0.5, (modTime - 0.582) / -0.096 * 1.098);\n    }\n    mask = step(0.68, modP.y);\n    d2 = sdCircle(modP - vec2(modTime, m), 0.05 * ((1.0 - modTime) + 0.2));\n    // mask it\n    d2 += mask;\n    d = opSmoothUnion(d, d2, 0.1);\n    \n    // drip 2\n    modP = vec2(abs(origP.x) * 2.2, origP.y * 3.0);\n    modP.x += 0.5;\n    loopTime = 3.0;\n    modTime = fract((iTime + 1.5) / loopTime); \n    // run normalized time through easing function\n    modTime = expImpulse(modTime, 0.5);\n    if(modTime < 0.55) {\n        m = map(modTime, 0.0, 0.55, 1.4, 0.47);\n    } else {\n        m = max(sin( (modTime - -0.72) / 0.69 ) + -0.5, (modTime - 0.582) / -0.096 * 1.098);\n    }\n    mask = step(0.68, modP.y);\n    d2 = sdCircle(modP - vec2(modTime, m), 0.05 * ((1.0 - modTime) + 0.2));\n    // mask it\n    d2 += mask;\n    d = opSmoothUnion(d, d2, 0.1);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n\n    //////////////////////////////////////////////////////\n    // outer third eye (the floating one)\n    // black bottom\n    mask1 = step(0.24, p.y);\n    d = sdCircle(p - vec2(0.5, 0.25), 0.35 * mask1);\n    d1 = sdCircle(p - vec2(0.5, 0.25), 0.42 * mask1);\n    d = opSubtraction(d, d1);\n    d = smoothstep(0.0, AA, d);\n    mask = d;\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    upperThirdEyeOil(p, col, origP);\n    // colored part\n    d = sdCircle(p - vec2(0.5, 0.25), 0.36 * mask1);\n    d1 = sdCircle(p - vec2(0.5, 0.25), 0.41 * mask1);\n    d = opSubtraction(d, d1);\n    d = smoothstep(0.0, AA, d);\n    mixedCol = mix(vec3(0.91,0.65,0.36), vec3(0.92,0.54,0.36), smoothstep(0.52, 0.45, 1.0 - p.y));\n    col = mix(col, mixedCol, 1.0 - d);\n    // oil drip middle line and bottom connecting circle\n    d = sdSegment(p, vec2(0.5, 0.66), vec2(0.5, 0.61)) - 0.009;\n    d += mask;\n    d1 = sdCircle(p - vec2(0.51, 0.51), 0.11);\n    d1 += mask;\n    d = opSmoothUnion(d, d1, 0.03);\n    // circular movement drip 1\n    modP = vec2(abs(origP.x) * 3.0, origP.y * 3.0);\n    modP.x += 0.48;\n    modP.y -= 0.15;\n    loopTime = 3.0;\n    float time = iTime - 0.5;\n    modTime = fract(time / loopTime); \n    // run normalized time through easing function\n    modTime = expImpulse(modTime, 0.5);\n    m = 0.5 - pow(abs(modTime), 5.5);\n    d2 = sdCircle(modP - vec2(modTime, m), 0.05 * ((1.0 - modTime) + 0.2));\n    // mask it\n    d2 += mask;\n    d = opSmoothUnion(d, d2, 0.1);\n    // circular movement drip 2\n    modTime = fract((time + (loopTime / 2.0)) / loopTime); \n    // run normalized time through easing function\n    modTime = expImpulse(modTime, 0.5);\n    m = 0.5 - pow(abs(modTime), 5.5);\n    d2 = sdCircle(modP - vec2(modTime, m), 0.05 * ((1.0 - modTime) + 0.2));\n    // mask it\n    d2 += mask;\n    d = opSmoothUnion(d, d2, 0.1);\n    // color outer third eye oil\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n\n\n    // circle tips go woo woo\n    d = sdCircle(p - vec2(0.885, 0.24), 0.035);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    d = sdCircle(p - vec2(0.885, 0.24), 0.025);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, vec3(0.91,0.57,0.36), 1.0 - d);\n    d = sdCircle(p - vec2(0.885, 0.24), 0.015);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    \n\n    ///////////////////////////////////////////////\n    //third eye circle 5 (outer connected one to the trapezoid)\n    // inner third eye circle - black bottom\n    mask1 = step(0.24, p.y);\n    d = sdCircle(p - vec2(0.5, 0.25), 0.302 * mask1);\n    d = smoothstep(0.0, AA, d);\n    mask = d;\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    // inner third eye circle - color\n    d = sdCircle(p - vec2(0.5, 0.252), 0.292 * mask1);\n    d = smoothstep(0.0, AA, d);\n    modP = vec2(p.x * 3.9 + 0.765, p.y * 1.9);\n    col = mix(col, vec3(0.92,0.56,0.37), 1.0 - d);\n    // oil line\n    d = sdSegment(p, vec2(0.5, 0.335), vec2(0.5, 0.59)) - 0.003;\n    loopTime = 2.0;\n    // modTime = mod(iTime - dropOffset * 5.0, loopTime) / loopTime;\n    modTime = fract((iTime - 0.25) / loopTime);\n    //////////\n    modP = vec2(abs(origP.x) * 3.0, origP.y * 3.0);\n    modP.x -= -0.5;\n    modP.y += 0.25;\n    modTime = expImpulse(modTime, 0.5);\n    if(modTime < 0.5) {\n        m = map(modTime, 0.0, 0.5, 1.0, 0.5);\n        modTime = map(modTime, 0.0, 0.5, 0.4, 0.5);\n    } else {\n        m = max(-99.0 * modTime + 50.0, pow(cos(3.14 * (modTime - 0.5) / 2.0), 0.5) - 0.5);\n    }\n    d1 = sdCircle(modP - vec2(modTime, m), 0.05 * ((1.0 - modTime) + 0.2));\n    d = opSmoothUnion(d, d1, 0.1);\n    d2 = sdCircle(p - vec2(0.5, 0.43), 0.03);\n    d = opSmoothUnion(d, d2, 0.08);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, (1.0 - d) * (1.0/* - mask*/));\n    // addGrid(modP, col);\n    ///////////////////////////////////////////////\n    //third eye circle 4 (thick black)\n    // inner third eye circle - black bottom\n    d = sdCircle(p - vec2(0.5, 0.25), 0.23);\n    d = smoothstep(0.0, AA, d);\n    mask = d;\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    // // inner third eye circle - color\n    // d = sdCircle(p - vec2(0.5, 0.252), 0.20);\n    // d = smoothstep(0.0, AA, d);\n    // modP = vec2(p.x * 3.9 + 0.765, p.y * 1.9);\n    // mixedCol = returnDottedCol(modP, vec3(0.33,0.85,0.98), vec3(0.42,0.28,0.72));\n    // col = mix(col, mixedCol, 1.0 - d);\n    // // oil line\n    // d = sdSegment(p, vec2(0.5, 0.335), vec2(0.5, 0.51)) - 0.003;\n    // loopTime = 2.0;\n    // modTime = mod(-iTime - 1.0, loopTime) / loopTime;\n    // m = (0.5 - 0.3) * modTime + 0.3;\n    // d1 = sdCircle(p - vec2(0.5, m), 0.01);\n    // d = opSmoothUnion(d, d1, 0.05);\n    // d2 = sdCircle(p - vec2(0.5, 0.36), 0.03);\n    // d = opSmoothUnion(d, d2, 0.05);\n    // d = smoothstep(0.0, AA, d);\n    // col = mix(col, blackOutlineColor, (1.0 - d) * (1.0 - mask));\n    ///////////////////////////////////////////////\n    //third eye circle 3 (the dotted one)\n    // inner third eye circle - black bottom\n    d = sdCircle(p - vec2(0.5, 0.25), 0.21);\n    d = smoothstep(0.0, AA, d);\n    mask = d;\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    // inner third eye circle - color\n    d = sdCircle(p - vec2(0.5, 0.252), 0.20);\n    d = smoothstep(0.0, AA, d);\n    modP = vec2(p.x * 3.9 + 0.765, p.y * 1.9);\n    mixedCol = returnDottedCol(modP, vec3(0.33,0.85,0.98), vec3(0.42,0.28,0.72));\n    col = mix(col, mixedCol, 1.0 - d);\n    // oil line\n    d = sdSegment(p, vec2(0.5, 0.335), vec2(0.5, 0.51)) - 0.003;\n    loopTime = 2.0;\n    modTime = mod(-iTime - dropOffset * 3.0, loopTime) / loopTime;\n    m = (0.5 - 0.3) * modTime + 0.3;\n    d1 = sdCircle(p - vec2(0.5, m), 0.01);\n    d = opSmoothUnion(d, d1, 0.05);\n    d2 = sdCircle(p - vec2(0.5, 0.36), 0.03);\n    d = opSmoothUnion(d, d2, 0.05);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, (1.0 - d) * (1.0 - mask));\n    ///////////////////////////////////////////////\n    //third eye circle 2\n    // inner third eye circle - black bottom\n    d = sdCircle(p - vec2(0.5, 0.25), 0.14);\n    d = smoothstep(0.0, AA, d);\n    mask = d;\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    // inner third eye circle - color\n    d = sdCircle(p - vec2(0.5, 0.252), 0.13);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, vec3(0.48,0.17,0.69), 1.0 - d);\n    // oil line\n    d = sdSegment(p, vec2(0.5, 0.335), vec2(0.5, 0.51)) - 0.003;\n    loopTime = 2.0;\n    modTime = mod(-iTime - dropOffset * 2.0, loopTime) / loopTime;\n    m = (0.45 - 0.26) * modTime + 0.26;\n    d1 = sdCircle(p - vec2(0.5, m), 0.01);\n    d = opSmoothUnion(d, d1, 0.05);\n    d2 = sdCircle(p - vec2(0.5, 0.3), 0.03);\n    d = opSmoothUnion(d, d2, 0.05);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, (1.0 - d) * (1.0 - mask));\n    /////////////////////////////////////////////////\n    // third eye circle 1\n    // inner third eye circle - black bottom\n    d = sdCircle(p - vec2(0.5, 0.25), 0.09);\n    d = smoothstep(0.0, AA, d);\n    mask = d;\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    // inner third eye circle - color\n    d = sdCircle(p - vec2(0.5, 0.252), 0.08);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, vec3(0.91,0.54,0.36), 1.0 - d);\n    // oil line\n    d = sdSegment(p, vec2(0.5, 0.335), vec2(0.5, 0.29)) - 0.003;\n    loopTime = 2.0;\n    modTime = mod(-iTime - dropOffset * 1.0, loopTime) / loopTime;\n    m = (0.42 - 0.23) * modTime + 0.23;\n    d1 = sdCircle(p - vec2(0.5, m), 0.01);\n    d = opSmoothUnion(d, d1, 0.05);\n    d2 = sdCircle(p - vec2(0.5, 0.245), 0.03);\n    d = opSmoothUnion(d, d2, 0.05);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, (1.0 - d) * (1.0 - mask));\n    \n\n    /////////////////////////////////////////////////////////////// \n    // lower trapezoid black bottom\n    d = sdTrapezoid(p - vec2(0.48, 0.12), 0.12, 0.32, 0.12);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n\n    // light trapezoid background\n    d = sdTrapezoid(p - vec2(0.46, 0.12), 0.14, 0.322, 0.11);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, vec3(0.91,0.54,0.37), 1.0 - d);\n\n    // black of trapezoid\n    d = sdTrapezoid(p - vec2(0.26, 0.12), 0.335, 0.43, 0.12);\n    // bump 1\n    loopTime = 2.0;\n    pos1 = vec2(0.76, 0.29);\n    pos2 = vec2(0.55, 0.0);\n    modTime = mod(iTime, loopTime) / loopTime;\n    mixedPos = mix(pos1, pos2, modTime);\n    d1 = sdCircle(p - mixedPos, 0.02);\n    d = opSmoothUnion(d, d1, 0.04);\n    // bump 2\n    loopTime = 2.0;\n    pos1 = vec2(0.76, 0.29);\n    pos2 = vec2(0.55, 0.0);\n    modTime = mod(iTime + 0.7, loopTime) / loopTime;\n    mixedPos = mix(pos1, pos2, modTime);\n    d1 = sdCircle(p - mixedPos, 0.02);\n    d = opSmoothUnion(d, d1, 0.04);\n    // bump 3\n    loopTime = 2.0;\n    pos1 = vec2(0.76, 0.29);\n    pos2 = vec2(0.55, 0.0);\n    modTime = mod(iTime + 1.4, loopTime) / loopTime;\n    mixedPos = mix(pos1, pos2, modTime);\n    d1 = sdCircle(p - mixedPos, 0.02);\n    d = opSmoothUnion(d, d1, 0.04);\n\n    isWithinTrapezoid = step(0.0, p.y) * (1.0 - step(0.24, p.y));\n\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, (1.0 - d) * isWithinTrapezoid);\n\n    // trapezoid small triangle\n    d = sdTriangle(p, vec2(0.59, 0.03), vec2(0.59, 0.23), vec2(0.64, 0.23));\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, vec3(0.35,0.85,0.98), 1.0 - d);\n\n    //////////////////////////////////////////////////////////////////////////\n    // trapezoid tube - black bottom\n    r = 0.05;\n    d = sdSegment(p, vec2(0.496, 0.24), vec2(0.496, 0.0)) - r;\n    d1 = step(0.008, p.y);\n    d = smoothstep(0.0, AA, d);\n    mask = d;\n    col = mix(col, blackOutlineColor, (1.0 - d) * d1);\n    // trapezoid tube - color\n    r = 0.043;\n    d = sdSegment(p, vec2(0.496, 0.24), vec2(0.496, 0.0)) - r;\n    d1 = step(0.008, p.y);\n    d = smoothstep(0.0, AA, d);\n    mixedCol = mix(vec3(0.41,0.36,0.68), vec3(0.42,0.72,0.90), smoothstep(0.6, 0.47, p.x));\n    col = mix(col, mixedCol, (1.0 - d) * d1);\n    // middle tube divider\n    r = 0.0005;\n    loopTime = 1.0;\n    modTime = mod(iTime, loopTime) / loopTime;\n    m = 0.1 * modTime - 0.05;\n    d3 = sdSegment(origP, vec2(m, -0.285), vec2(m, 0.5)) - r;\n    d3 = smoothstep(0.0, AA, d3);\n    col = mix(col, blackOutlineColor, (1.0 - d3) * (1.0 - mask));\n    // tube divider 1\n    r = 0.05;\n    d = sdCircle(p - vec2(0.5, 0.14), 0.06);\n    d1 = sdCircle(p - vec2(0.5, 0.15), 0.055);\n    d = opSubtraction(d, d1);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    // tube divider 2\n    r = 0.05;\n    d = sdCircle(p - vec2(0.5, 0.04), 0.06);\n    d1 = sdCircle(p - vec2(0.5, 0.05), 0.055);\n    d = opSubtraction(d, d1);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n\n\n\n    \n    // addGrid(modP, col);\n\n    \n}\n\nvoid littleDrop(vec2 p, inout vec3 col, float timeOffset) {\n    float loopTime = 1.0;\n    float modTime = fract((iTime + timeOffset)/loopTime);\n    float smoothFactor = map(modTime, 0.0, 1.0, 0.0, 0.17);\n    float yPos = map(modTime * modTime * modTime, 0.0, 1.0, 0.53, 0.15);\n    vec2 movingDripPos = vec2(0.51, yPos);\n\n\n    float d1 = sdCircle(p - vec2(0.51, 0.53), 0.02);\n    float d2 = sdCircle(p - movingDripPos, 0.02);\n    float d = opSmoothUnion(d1, d2, smoothFactor);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    // addGrid(p, col);\n}\n\nvoid test(vec2 p, inout vec3 col) {\n    vec2 pos = vec2(0.0, 0.0);\n    float loopTime = 3.0;\n    float modTime = fract(iTime / loopTime);\n\n    modTime = map(modTime, 0.0, 1.0, 0.0, TAU);\n    float r = 0.5;\n    pos.x = sin(modTime) * r;\n    pos.y = cos(modTime) * r;\n\n    float d = sdCircle(p - pos, 0.05);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, vec3(1.0), 1.0 - d);\n}\n\nvoid eyeOil(vec2 p, inout vec3 col) {\n    float d = 0.0;\n    float d1 = 0.0;\n    float d2 = 0.0;\n    float d3 = 0.0;\n    float r = 0.0;\n    vec2 modP = vec2(0.0);\n    vec3 mixedCol = vec3(0.0);\n    float modTime = 0.0;\n    float loopTime = 0.0;\n    vec2 pos1 = vec2(0.0);\n    vec2 pos2 = vec2(0.0);\n    vec2 mixedPos = vec2(0.0);\n    float isWithinTrapezoid = 0.0;\n    float mask = 0.0;\n    float mask1 = 0.0;\n    float mask2 = 0.0;\n    float m = 0.0;\n    float dropOffset = 0.5;\n    float time = 0.0;\n    float timeScale = 0.3;\n\n    /////////////////////////////////////\n    // cluster of circles\n    /////////////////////////////////////\n    float startAngle = 0.0;\n    float margin = 0.05;\n    float circleLayoutRadius = 0.5;\n    float circleRadius = 0.02;\n    modP = within(p, vec4(-0.02, -0.02, 0.93, -0.87));\n    // modP = within(p, vec4(-0.13, 0.09, 0.93, -1.0)); \n    // rotate grid just a tad\n    modP = rotate2d(0.05) * modP;\n    // addGrid(modP, col);\n    d = sdCircle(modP - vec2(0.5), 0.02);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, vec3(1.0), 1.0 - d);\n    time = iTime * timeScale;\n\n    // DRAW CIRLCLES THROUGH TWEEN\n    loopTime = 3.0;\n    // position circles\n    for(int i = 0; i < 12; i++) {\n        float margin = sin(float(i) + time) * 1.0;\n        modTime = fract((time + margin) / loopTime);\n        float s = smoothstep(0.1, 0.3, modP.y);\n        float m = modP.y * modP.y * 1.5;\n        circleRadius = map(m, 0.0, 1.0, 0.04, 0.005);\n        circleRadius *= s;\n        // circleRadius = 0.004;\n        if(modTime < 0.333) {\n            // tween 1\n            d1 = returnTween1Dist(modP, linearStep(0.0, 0.333, modTime), circleRadius);\n        } else if(modTime < 0.666) {\n            //tween 2\n            d1 = returnTween2Dist(modP, linearStep(0.33, 0.666, modTime), circleRadius);\n        } else {\n            // tween 3\n            d1 = returnTween3Dist(modP, linearStep(0.666, 1.0, modTime), circleRadius);\n        }\n\n        if(i != 0) {\n            float smoothVal = modP.y * 0.12;\n            d = opSmoothUnion(d, d1, smoothVal);  // 0.12\n        }\n    }\n\n    // base circle\n    d1 = sdCircle(p - vec2(0.37, -0.48), 0.2);\n    d = opSmoothUnion(d, d1, 0.13);\n    // // draw oil\n    // d = smoothstep(0.0, AA, d);\n    // col = mix(col, blackOutlineColor, 1.0 - d);\n    /////////////////////////////////////////////////////////////\n    // bottom left swoop tween\n    modP = within(p, vec4(-0.43, 0.09, 0.76, -1.0));\n    timeScale = 0.3;\n    time = iTime * timeScale;\n    makeSecondSwoop(modP, d, loopTime, col, time);\n    // addGrid(modP, col);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n\n    ///////////////////////////////////////////////////////////////////////////\n    \n    \n}\n\nvoid hat(vec2 p, inout vec3 col, vec2 origP) {\n    float d = 0.0;\n    float d1 = 0.0;\n    float d2 = 0.0;\n    float d3 = 0.0;\n    float r = 0.0;\n    vec2 modP = vec2(0.0);\n    vec2 p1 = vec2(0.0);\n    vec3 mixedCol = vec3(0.0);\n    float modTime = 0.0;\n    float loopTime = 0.0;\n    vec2 pos1 = vec2(0.0);\n    vec2 pos2 = vec2(0.0);\n    vec2 mixedPos = vec2(0.0);\n    float isWithinTrapezoid = 0.0;\n    float mask = 0.0;\n    float mask1 = 0.0;\n    float mask2 = 0.0;\n    float m = 0.0;\n    float dropOffset = 0.5;\n\n    modP = within(origP, vec4(-1.0, 1.0, 1.0, -0.52));\n\n    // black bottom\n    d = sdSegment(p, vec2(0.0, -0.10), vec2(-0.26, -0.93)) - 0.76;\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n\n    // colored part\n    d = sdSegment(p, vec2(0.0, -0.10), vec2(-0.26, -0.93)) - 0.745;\n    d = smoothstep(0.0, AA, d);\n    mixedCol = returnDottedCol(vec2(p.x * 4.0, p.y * 2.0), vec3(0.91,0.75,0.34), vec3(0.82,0.44,0.12));\n    col = mix(col, mixedCol, 1.0 - d);\n\n    // addGrid(modP, col);\n\n\n}\n\nvoid crown(vec2 p, inout vec3 col, vec2 origP) {\n    float d = 0.0;\n    float d1 = 0.0;\n    float d2 = 0.0;\n    float d3 = 0.0;\n    float r = 0.0;\n    vec2 modP = vec2(0.0);\n    vec2 p1 = vec2(0.0);\n    vec3 mixedCol = vec3(0.0);\n    float modTime = 0.0;\n    float loopTime = 0.0;\n    vec2 pos1 = vec2(0.0);\n    vec2 pos2 = vec2(0.0);\n    vec2 mixedPos = vec2(0.0);\n    float isWithinTrapezoid = 0.0;\n    float mask = 0.0;\n    float mask1 = 0.0;\n    float mask2 = 0.0;\n    float m = 0.0;\n    float dropOffset = 0.5;\n\n    modP = within(origP, vec4(-1.0, 1.0, 1.0, -0.52));\n\n\n    // addGrid(modP, col);\n\n    // black bottom\n    d = sdBox(modP - vec2(0.5, 0.91), vec2(0.1, 0.44), 0.0);\n    d = smoothstep(0.0, AA, d);\n    mask1 = 1.0 - d;\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    // color bg\n    d = sdBox(modP - vec2(0.5, 0.91), vec2(0.095, 0.405), 0.04);\n    d = smoothstep(0.0, AA, d);\n    mask = 1.0 - d;\n    mixedCol = mix(vec3(0.61,0.80,0.72), vec3(0.90,0.76,0.34), map(modP.y, 0.60 * abs(sin(iTime * 1.5)), 0.67, 0.0, 1.0));\n    col = mix(col, mixedCol, 1.0 - d);\n\n    // middle pipe\n    loopTime = 2.0;\n    modTime = fract((iTime + 0.05) / loopTime);\n    m = abs(sin(modTime * TAU)) * 0.02;\n    d = sdSegment(p, vec2(0.0 + m, 0.85), vec2(0.0, 0.26)) - 0.05;\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    // bottom color of middle pipe\n    d = sdSegment(p, vec2(0.0, 0.57), vec2(0.0, 0.26)) - 0.04;\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, vec3(0.90,0.63,0.34), 1.0 - d);\n\n\n    \n\n    // top circle\n    float radiusM = abs(sin(modTime * TAU)) * 0.02;\n    d = sdCircle(p - vec2(0.0, 0.85), 0.05 + radiusM);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    d = sdCircle(p - vec2(0.0, 0.85), 0.045 + radiusM);\n    d = smoothstep(0.0, AA, d);\n    mixedCol = returnDottedCol(vec2(p.x * 4.0, p.y * 2.0), vec3(0.91,0.55,0.37), vec3(0.84,0.36,0.18));\n    col = mix(col, mixedCol, 1.0 - d);\n\n    // top dotted color\n    d = sdCircle(p - vec2(0.2, 1.0), 0.15);\n    d = smoothstep(0.0, AA, d);\n    mixedCol = mix(vec3(0.73,0.78,0.61), vec3(0.44,0.80,0.92), map(p.y, 0.9, 1.0, 0.0, 1.0));\n    mixedCol = returnDottedCol(vec2(p.x * 4.0, p.y * 2.0), mixedCol, vec3(0.44,0.21,0.68));\n    col = mix(col, mixedCol, (1.0 - d) * mask);\n\n    // black under diamond\n    d = sdCircle(p - vec2(0.17, 0.67), 0.13);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, (1.0 - d) * mask);\n\n    // diamond black bottom\n    d = sdCross(origP - vec2(0.0, 0.84), vec2(0.52, 0.33), 0.37);\n    d1 = sdCross(origP - vec2(0.0, 0.84), vec2(0.52, 0.33), 0.37 - 0.05);\n    d = opSubtraction(d, d1);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, (1.0 - d) * mask);\n    // diamond white part\n    d = sdCross(origP - vec2(0.0, 0.84), vec2(0.52, 0.33), 0.36);\n    d1 = sdCross(origP - vec2(0.0, 0.84), vec2(0.52, 0.33), 0.38 - 0.05);\n    d = opSubtraction(d, d1);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, vec3(1.00,0.98,0.90), (1.0 - d) * mask);\n\n    // hat cover up part\n    // black bottom\n    d = sdSegment(p, vec2(0.0, -0.10), vec2(-0.26, -0.93)) - 0.76;\n    d1 = sdSegment(p, vec2(0.0, -0.205), vec2(-0.26, -0.93)) - 0.745;\n    d = opSubtraction(d1, d);\n    d = smoothstep(0.0, AA, d); \n    col = mix(col, blackOutlineColor, (1.0 - d) * mask);\n    // dotted color\n    d = sdSegment(p, vec2(0.0, -0.115), vec2(-0.26, -0.93)) - 0.76;\n    d1 = sdSegment(p, vec2(0.0, -0.19), vec2(-0.26, -0.93)) - 0.745;\n    d = opSubtraction(d1, d);\n    d = smoothstep(0.0, AA, d); \n    mixedCol = returnDottedCol(vec2(p.x * 4.0, p.y * 2.0), vec3(0.91,0.75,0.34), vec3(0.82,0.44,0.12));\n    col = mix(col, mixedCol, (1.0 - d) * mask);\n\n    // crown oil\n    vec2 from = vec2(0.2, 1.3);\n    vec2 to = vec2(0.2, 0.17);\n    loopTime = 4.0;\n    for(int i = 0; i < 20; i++) {\n        float time = iTime * 0.5;\n        float margin = cos(0.25 * float(i) + time);\n        modTime = fract((time + margin) / loopTime);\n        float scale = 0.01 * abs(sin(modTime * TAU * 2.0)) + 0.01;\n        pos1 = mix(from, to, modTime);\n        d1 = sdCircle(p - pos1, scale);\n\n        if(i != 0) {\n            d = opSmoothUnion(d, d1, 0.02 * abs(sin(iTime)) + 0.03); \n        } else {\n            d = d1;\n        }\n    }\n\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, (1.0 - d) * mask1);\n\n    // middle oil line circles\n    from = vec2(0.0, 1.3);\n    to = vec2(0.0, 0.17);\n    loopTime = 4.0;\n    for(int i = 0; i < 20; i++) {\n        float time = (iTime + 3.5) * 0.4;\n        float margin = cos(float(i) + time);\n        modTime = fract((time + margin) / loopTime);\n        float scale = 0.005 * abs(sin(modTime * TAU * 2.0)) + 0.005;\n        pos1 = mix(from, to, modTime);\n        d1 = sdCircle(p - pos1, scale);\n\n        if(i != 0) {\n            d = opSmoothUnion(d, d1, 0.02 * abs(sin(iTime)) + 0.01); \n        } else {\n            d = d1;\n        }\n    }\n\n    // line\n    d1 = sdSegment(p, vec2(0.0, 1.0), vec2(0.0, 0.26)) - 0.0005;\n    d = opSmoothUnion(d, d1, 0.02 * abs(sin(iTime)) + 0.01); \n\n    mask2 = mask1 * step(p.y, 0.78);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, (1.0 - d) * mask2);\n\n    // bottom circle\n    modTime = fract((iTime) / loopTime);\n    m = 0.25 + sin(modTime * TAU) * 0.02;\n    d = sdCircle(p - vec2(0.0, m), 0.05);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    d = sdCircle(p - vec2(0.0, m), 0.045);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, vec3(0.89,0.96,0.91), 1.0 - d);\n}\n\nvoid backClouds(vec2 p, inout vec3 col, vec2 origP) {\n    float d = 0.0;\n    float d1 = 0.0;\n    float d2 = 0.0;\n    float d3 = 0.0;\n    float r = 0.0;\n    vec2 modP = vec2(0.0);\n    vec2 p1 = vec2(0.0);\n    vec3 mixedCol = vec3(0.0);\n    float modTime = 0.0;\n    float loopTime = 0.0;\n    vec2 pos1 = vec2(0.0);\n    vec2 pos2 = vec2(0.0);\n    vec2 mixedPos = vec2(0.0);\n    float isWithinTrapezoid = 0.0;\n    float mask = 0.0;\n    float mask1 = 0.0;\n    float mask2 = 0.0;\n    float m = 0.0;\n    float dropOffset = 0.5;\n\n    // top black bottom\n    vec2 pointA = vec2(0.0, 0.0);\n    vec2 pointB = vec2(2.0, 1.8);\n    d = sdSegment(p, pointA, pointB) - 0.09;\n    float h = dot(p - pointA, pointB - pointA);\n    float time = -iTime;\n    m = (0.04 + 0.04 * sin(2.0 * PI * h + (time * 2.0)/2.0));\n    m += (0.1 + 0.05 * sin(1.2 * PI * h + (time * 4.0)/10.0));\n    m += (0.01 + 0.02 * sin(2.0 * PI * h + (time * 4.0)/2.0));\n    // m += (0.01 + 0.01 * sin(6.0 * PI * h + (time * 4.0)/2.0));\n    // keep adding waves till it looks good\n    d = d - m;\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    // more top black bottom\n    pointA = vec2(0.0, -0.3);\n    pointB = vec2(2.0, 1.5);\n    d = sdSegment(p, pointA, pointB) - 0.09;\n    h = dot(p - pointA, pointB - pointA);\n    time = -iTime;\n    m = (0.04 + 0.04 * sin(2.0 * PI * h + (time * 2.0)/2.0));\n    m += (0.1 + 0.05 * sin(1.2 * PI * h + (time * 4.0)/10.0));\n    m += (0.01 + 0.02 * sin(2.0 * PI * h + (time * 4.0)/2.0));\n    // m += (0.01 + 0.01 * sin(6.0 * PI * h + (time * 4.0)/2.0));\n    // keep adding waves till it looks good\n    d = d - m;\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n\n    // top color\n    pointA = vec2(0.0, 0.0);\n    pointB = vec2(2.0, 1.8);\n    d = sdSegment(p, pointA, pointB) - 0.03;\n    h = dot(p - pointA, pointB - pointA);\n    time = -iTime;\n    m = (0.04 + 0.01 * sin(2.0 * PI * h + (time * 2.0)/2.0));\n    m += (0.1 + 0.02 * sin(1.2 * PI * h + (time * 4.0)/10.0));\n    m += (0.01 + 0.03 * sin(2.0 * PI * h + (time * 4.0)/2.0));\n    // m += (0.01 + 0.01 * sin(6.0 * PI * h + (time * 4.0)/2.0));\n    // keep adding waves till it looks good\n    d = d - m;\n    d = smoothstep(0.0, AA, d);\n    mixedCol = mix(vec3(0.52,0.87,0.96), vec3(0.95,0.97,0.91), p.x);\n    col = mix(col, mixedCol, 1.0 - d);\n\n    // dotted back wave\n    pointA = vec2(0.0, -1.5);\n    pointB = vec2(2.0, 0.8);\n    d = sdSegment(p, pointA, pointB) - 0.03;\n    h = dot(p - pointA, pointB - pointA);\n    time = -iTime;\n    m = (0.04 + 0.01 * sin(2.0 * PI * h + (time * 2.0)/2.0));\n    m += (0.1 + 0.02 * sin(1.2 * PI * h + (time * 4.0)/10.0));\n    m += (0.01 + 0.03 * sin(2.0 * PI * h + (time * 4.0)/2.0));\n    m += (0.1 + 0.1 * sin(0.5 * PI * h + (time * 4.0)/2.0));\n    // m += (0.01 + 0.01 * sin(6.0 * PI * h + (time * 4.0)/2.0));\n    // keep adding waves till it looks good\n    d = d - m;\n    d = smoothstep(0.0, AA, d);\n    mixedCol = mix(col, vec3(0.90,0.76,0.34), map(origP.y, -1.0, 1.0, 0.0, 1.0));\n    mixedCol = returnDottedCol(vec2(p.x * 4.0, p.y * 2.0), mixedCol, vec3(0.81,0.58,0.46));\n    col = mix(col, mixedCol, 1.0 - d);\n\n    // black\n    // pointA = vec2(0.0, -2.0);\n    // pointB = vec2(2.0, 0.5);\n    // d = sdSegment(p, pointA, pointB) - 0.03;\n    // h = dot(p - pointA, pointB - pointA);\n    // time = -iTime + 2.0;\n    // m = (0.04 + 0.01 * sin(2.0 * PI * h + (time * 2.0)/4.0));\n    // m += (0.1 + 0.02 * sin(1.2 * PI * h + (time * 4.0)/10.0));\n    // m += (0.01 + 0.03 * sin(2.0 * PI * h + (time * 4.0)/3.0));\n    // // m += (0.01 + 0.01 * sin(6.0 * PI * h + (time * 4.0)/2.0));\n    // // keep adding waves till it looks good\n    // d = d - m;\n    // d = smoothstep(0.0, AA, d);\n    // col = mix(col, blackOutlineColor, 1.0 - d);\n\n    // back block black\n    d = sdBox(origP - vec2(0.0, -1.0), vec2(2.0, 0.5), 0.0);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    // back block color\n    d = sdBox(origP - vec2(0.0, -1.0), vec2(2.0, 0.49), 0.0);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, vec3(0.90,0.76,0.34), 1.0 - d);\n    // back block black\n    d = sdBox(origP - vec2(0.0, -1.05), vec2(2.0, 0.5), 0.0);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    // back block color\n    d = sdBox(origP - vec2(0.0, -1.05), vec2(2.0, 0.49), 0.0);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, vec3(0.90,0.76,0.34), 1.0 - d);\n    // back block black\n    d = sdBox(origP - vec2(0.0, -1.2), vec2(2.0, 0.5), 0.0);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    // back block color\n    d = sdBox(origP - vec2(0.0, -1.2), vec2(2.0, 0.49), 0.0);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, vec3(0.90,0.76,0.34), 1.0 - d);\n    // back block black\n    d = sdBox(origP - vec2(0.0, -1.45), vec2(2.0, 0.5), 0.0);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    // back block color\n    d = sdBox(origP - vec2(0.0, -1.45), vec2(2.0, 0.49), 0.0);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, vec3(0.90,0.76,0.34), 1.0 - d);\n\n    // cloud\n    pointA = vec2(0.0, -2.7);\n    pointB = vec2(2.0, 0.5);\n    d = sdSegment(p, pointA, pointB) - 0.3;\n    h = dot(p - pointA, pointB - pointA);\n    time = -iTime + 2.0;\n    m = (0.04 + 0.01 * sin(1.3 * PI * h + (time * 2.0)/4.0));\n    m += (0.1 + 0.02 * sin(1.2 * PI * h + (time * 4.0)/10.0));\n    m += (0.01 + 0.03 * sin(1.5 * PI * h + (time * 4.0)/3.0));\n    m += (0.1 + 0.05 * sin(1.0 * PI * h + (time * 4.0)/2.0));\n    // keep adding waves till it looks good\n    d = d - m;\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    // cloud\n    pointA = vec2(0.0, -2.7);\n    pointB = vec2(2.0, 0.5);\n    d = sdSegment(p, pointA, pointB) - 0.29;\n    h = dot(p - pointA, pointB - pointA);\n    time = -iTime + 2.0;\n    m = (0.04 + 0.01 * sin(1.3 * PI * h + (time * 2.0)/4.0));\n    m += (0.1 + 0.02 * sin(1.2 * PI * h + (time * 4.0)/10.0));\n    m += (0.01 + 0.03 * sin(1.5 * PI * h + (time * 4.0)/3.0));\n    m += (0.1 + 0.05 * sin(1.0 * PI * h + (time * 4.0)/2.0));\n    // keep adding waves till it looks good\n    d = d - m;\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, vec3(0.45,0.87,0.97), 1.0 - d);\n    // dottted\n    pointA = vec2(0.0, -2.8);\n    pointB = vec2(2.0, -0.24);\n    d = sdSegment(p, pointA, pointB) - 0.29;\n    h = dot(p - pointA, pointB - pointA);\n    time = -iTime + 2.0;\n    m = (0.04 + 0.01 * sin(2.0 * PI * h + (time * 2.0)/4.0));\n    m += (0.1 + 0.02 * sin(1.2 * PI * h + (time * 4.0)/10.0));\n    m += (0.01 + 0.03 * sin(2.0 * PI * h + (time * 4.0)/3.0));\n    // m += (0.01 + 0.01 * sin(6.0 * PI * h + (time * 4.0)/2.0));\n    // keep adding waves till it looks good\n    d = d - m;\n    d = smoothstep(0.0, AA, d);\n    mixedCol = mix(vec3(0.44,0.86,0.98),vec3(0.91,0.96,0.91), p.x);\n    mixedCol = returnDottedCol(vec2(p.x * 4.0, p.y * 2.0), col, vec3(0.23,0.36,0.68));\n    col = mix(col, mixedCol, 1.0 - d);\n\n    // front dark cloud - black bottom\n    pointA = vec2(0.0, -3.0);\n    pointB = vec2(2.0, -0.24);\n    d = sdSegment(p, pointA, pointB) - 0.29;\n    h = dot(p - pointA, pointB - pointA);\n    time = -iTime + 3.0;\n    m = (0.04 + 0.01 * sin(2.0 * PI * h + (time * 2.0)/2.0));\n    m += (0.1 + 0.02 * sin(1.2 * PI * h + (time * 4.0)/10.0));\n    m += (0.01 + 0.03 * sin(2.0 * PI * h + (time * 4.0)/2.0));\n    m += (0.1 + 0.1 * sin(0.5 * PI * h + (time * 4.0)/2.0));\n    // keep adding waves till it looks good\n    d = d - m;\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    // front dark cloud - color\n    pointA = vec2(0.0, -3.0);\n    pointB = vec2(2.0, -0.24);\n    d = sdSegment(p, pointA, pointB) - 0.28;\n    h = dot(p - pointA, pointB - pointA);\n    time = -iTime + 3.0;\n    m = (0.04 + 0.01 * sin(2.0 * PI * h + (time * 2.0)/2.0));\n    m += (0.1 + 0.02 * sin(1.2 * PI * h + (time * 4.0)/10.0));\n    m += (0.01 + 0.03 * sin(2.0 * PI * h + (time * 4.0)/2.0));\n    m += (0.1 + 0.1 * sin(0.5 * PI * h + (time * 4.0)/2.0));\n    // keep adding waves till it looks good\n    d = d - m;\n    d = smoothstep(0.0, AA, d);\n    mixedCol = mix(vec3(0.90,0.54,0.38),vec3(0.63,0.30,0.60), 1.0 - map(p.x, 1.0, 0.48, 0.0, 1.0));\n    col = mix(col, mixedCol, 1.0 - d);\n    \n}\n\nvoid thirdEyeRays(vec2 p, inout vec3 col, vec2 origP) {\n    float d = 0.0;\n    float d1 = 0.0;\n    float d2 = 0.0;\n    float d3 = 0.0;\n    float r = 0.0;\n    vec2 modP = vec2(0.0);\n    vec2 p1 = vec2(0.0);\n    vec3 mixedCol = vec3(0.0);\n    float modTime = 0.0;\n    float loopTime = 0.0;\n    vec2 pos1 = vec2(0.0);\n    vec2 pos2 = vec2(0.0);\n    vec2 mixedPos = vec2(0.0);\n    float isWithinTrapezoid = 0.0;\n    float mask = 0.0;\n    float mask1 = 0.0;\n    float mask2 = 0.0;\n    float m = 0.0;\n    float dropOffset = 0.5;\n\n    // black bottom\n    modP = vec2(p.x, p.y);\n    modP = rotate2d(-0.76) * modP;\n    d = sdBox(modP - vec2(0.1, 1.0), vec2(0.07, 0.75), -0.8);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n\n    // color bottom\n    d = sdBox(modP - vec2(0.1, 1.0), vec2(0.06, 0.75), -0.8);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, vec3(0.91,0.54,0.36), 1.0 - d);\n\n    // middle black bottom\n    d = sdBox(modP - vec2(0.1, 1.0), vec2(0.03, 0.75), -0.8);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n\n    // middle color 0.76 - 1.0\n    d = sdBox(modP - vec2(0.1, 1.0), vec2(0.018, 0.75), -0.8);\n    d = smoothstep(0.0, AA, d);\n    mixedCol = mix(vec3(0.51,0.20,0.67), vec3(0.89,0.51,0.40), map(modP.y, 0.22, 0.25 * abs(sin(iTime * 6.0)) + 0.76, 0.0, 1.0));\n    col = mix(col, mixedCol, 1.0 - d);\n}\n\nvoid backBars(vec2 p, inout vec3 col, vec2 origP) {\n    float d = 0.0;\n    float d1 = 0.0;\n    float d2 = 0.0;\n    float d3 = 0.0;\n    float r = 0.0;\n    vec2 modP = vec2(0.0);\n    vec2 p1 = vec2(0.0);\n    vec3 mixedCol = vec3(0.0);\n    float modTime = 0.0;\n    float loopTime = 0.0;\n    vec2 pos1 = vec2(0.0);\n    vec2 pos2 = vec2(0.0);\n    vec2 mixedPos = vec2(0.0);\n    float isWithinTrapezoid = 0.0;\n    float mask = 0.0;\n    float mask1 = 0.0;\n    float mask2 = 0.0;\n    float m = 0.0;\n    float dropOffset = 0.5;\n\n    // black bottom\n    d = sdBox(p - vec2(0.83, 0.81), vec2(0.91, 0.07), -0.8);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n\n    // dotted color\n    d = sdBox(p - vec2(0.83, 0.81), vec2(0.91, 0.06), -0.8);\n    d = smoothstep(0.0, AA, d);\n    mixedCol = returnDottedCol(vec2(p.x * 3.0, p.y * 3.0), vec3(0.48,0.17,0.69), vec3(0.44,0.08,0.33));\n    col = mix(col, mixedCol, 1.0 - d);\n\n    // while color\n    d = sdBox(p - vec2(0.83, 0.78), vec2(0.91, 0.03), -0.8);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, vec3(1.0), 1.0 - d);\n\n    // middle black bottom\n    d = sdBox(p - vec2(0.83, 0.81), vec2(0.91, 0.03), -0.8);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n\n    // middle color \n    d = sdBox(p - vec2(0.83, 0.81), vec2(0.91, 0.02), -0.8);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, vec3(0.35,0.84,0.98), 1.0 - d);\n}\n\nvoid bg(vec2 p, inout vec3 col, vec2 origP) {\n    col = mix(col, vec3(0.90,0.76,0.34), map(origP.y, 0.39, 0.74, 0.0, 1.0));\n\n    col = mix(col, vec3(0.76,0.78,0.53), map(origP.y, -0.09, -0.59, 0.0, 1.0));\n}\n\n void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    //vec2 p = (2.0 * gl_FragCoord.xy - iResolution.xy) / iResolution.y;\n    \n\n    vec2 origP = vec2(p.x, p.y);\n    // mirror coords\n    p.x = abs(p.x);\n\n    // AA = map(sin(iTime * 3.0), -1.0, 1.0, 0.005, 0.01);\n    float m = length(p) * 0.05 * abs(sin(iTime * 1.0));\n    AA = 0.005 + m;\n    \n    bg(p, col, origP);\n    backBars(p, col, origP);\n    backClouds(p, col, origP);\n    hat(p, col, origP);\n    head(within(p, vec4(-0.75, 0.55, 0.75, -1.0)), col);\n    eyeOil(p, col);\n    mouth(within(p, vec4(-0.3, -0.75, 0.3, -1.0)), col);\n    nose(within(p, vec4(-0.1, -0.2, 0.1, -0.75)), col);   \n    crown(p, col, origP);\n    thirdEyeRays(p, col, origP);\n    thirdEye(within(p, vec4(-0.5, 0.5, 0.5, -0.29)), col, origP);  \n    littleDrop(within(origP, vec4(0.15, 0.13, 0.61, -0.37)), col, 0.3);\n    littleDrop(within(origP, vec4(-0.15, 0.13, -0.61, -0.37)), col, 0.0);\n    eye(within(p, vec4(0.13, -0.25, 0.63, -0.7)), col);\n    // test(origP, col);\n\n    fragColor = vec4(col,1.0);\n    //gl_FragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdlfRB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdlfW4", "name": "Graph Shader", "author": "enslow", "description": "currently, this shader calculates the distance of all the edges which is pretty inefficient. I could theoretically lower the runtime to O(n) if i had some function to detect if any points were in some radius, but I'll do that later.\n\n", "tags": ["dotshader"], "likes": 8, "viewed": 288, "date": "1588365993", "time_retrieved": "2024-06-20T20:08:29.586550", "image_code": "#define num 27\n#define MAX_DIST 1.7\n\n//Segment function credit: https://www.shadertoy.com/view/MlcGDB\n//User: gPlatl\n\nstruct circle\n{\n    float r;\n\tvec2 p;\n};\n    \nfloat segment(vec2 P, vec2 A, vec2 B, float r) \n{\n    vec2 g = B - A;\n    vec2 h = P - A;\n    float d = length(h - g * clamp(dot(g, h) / dot(g,g), 0.0, 1.0));\n\treturn smoothstep(r, 0.5*r, d);\n}\n    \n    \nfloat hash1(int x)\n{\n    return sign(sin(float(x)*432.))*fract(sin(float(x)*15.4321));\n}\nfloat hash2(int x)\n{\n    return sign(sin(float(x)*273.))*fract(sin(float(x)*3.482));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 5.*(fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0.);    \n    float t = iTime/3.;\n    \n    \n    circle[num] v;\n    for (int i=0;i<num;i++)\n    {\n        v[i].r = 0.01;\n        v[i].p = vec2( cos(t+float(i*24)),sin(t+float((i)*32)) ) + vec2(hash1(i),hash2(i));\n        for (int j=0;j<i;j++)\n        {\n            float d = distance(v[i].p,v[j].p);\n            if (d > MAX_DIST)\n            {\n                continue;\n            }\n            float intensity = segment(uv,v[i].p,v[j].p,0.01)*(-exp(d-MAX_DIST)+1.);\n            col = col+vec3(intensity*sin(iTime/3.14),intensity/3.,intensity*3.);\n        }\n        if (length(v[i].p-uv) < v[i].r)\n        {\n            //col = col+vec3(1.0);\n        }\n    }\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdlfW4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdlfWS", "name": "this is a good sin :0", "author": "gurudevbk", "description": "its bloops", "tags": ["periodic"], "likes": 0, "viewed": 216, "date": "1589009020", "time_retrieved": "2024-06-20T20:08:29.829096", "image_code": "// returns true if a point [uv] is within the circle defined by [origin, radius]\nbool circle(vec2 uv, vec2 origin, float radius) {\n \treturn (length(uv-origin) < radius);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float thickness = 0.1;\n    float radius = 0.3;\n    vec2 origin = vec2(0.5);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n\n    vec3 col = vec3(0.5,0.5,0.36);\n    \n    // Time varying pixel color\n    if (abs(length(uv-origin) - radius) < abs(sin(iTime)/3.)) {\n    \tcol = 0.5 + 0.5*cos(iTime+length(uv-radius)+col);\n    \tcol.r += sin(iTime)+cos(iTime);\n    }\n    \n    else {\n    \tcol = 0.5 + 0.5*sin(iTime+length(uv-radius)+col);\n        col.r += sin(iTime)+cos(iTime);\n    }\n    \n    col.g /= col.r;\n    \n    col.g *= 0.05;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdlfWS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdlfzB", "name": "radiance03", "author": "paulobarcelos", "description": "radiance03", "tags": ["radiance03"], "likes": 0, "viewed": 196, "date": "1588537831", "time_retrieved": "2024-06-20T20:08:29.835137", "image_code": "\nfloat noise(vec2 p) {\n    float a = sin(p.x * 1234.456) * cos(p.y * 5678.1234) * 999.0;\n    float b = cos(p.x * 2355.234) * sin(p.y * 3534.3465) * 456.0;\n    return fract(a + b);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float scale = 0.5;\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    float time = mod(iTime, 6.35);\n    vec2 mouse = (iMouse.xy - 0.5 * iResolution.xy)/iResolution.y;\n    vec2 center = vec2(0);\n    vec2 follow = mix(center, vec2(mouse.x, 0.0), clamp(iMouse.w, 0., 1.));\n    \n    uv *= scale;\n    follow *= scale;\n    vec3 col = vec3(0);\n\n    float points = mix(noise(uv), noise(uv + iTime * 0.000001), 0.01);\n    float focus = clamp(length(uv.xx - follow + vec2(sin(time), cos(time)) * 0.01), 0.0, 1.0);\n    float waves = pow((1.0 - focus) * sin(pow(focus, 0.5) * 200.0 - time) * 0.5 + 0.5, 1.5);\n    float mask = smoothstep(0.0, 0.0001, smoothstep(0.2, 0.0, pow(focus + waves * 0.05, 0.8) * points + focus * 0.15));\n\n    col = mix(vec3(0.2, 0.0, 0.1), vec3(0.9, 0.9, 0.8), mask);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdlfzB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdlfzf", "name": "Colorized modified rare flower", "author": "codecontemplator", "description": "Build from https://www.shadertoy.com/view/tdsfz2", "tags": ["fractalcolors"], "likes": 2, "viewed": 54, "date": "1588800431", "time_retrieved": "2024-06-20T20:08:29.835137", "image_code": "vec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 u = 2.*(2.*fragCoord-iResolution.xy)/iResolution.y;\n    float pi = 3.14159265359;\n    float p = 1.+sin(iTime)*.05;\n    u *= p;\n    vec2 v = u;\n    float e = -4.;\n    for(float i = 0.; i < 3.; ++i)\n    {\n        //u = sin(atan(u.y,u.x)*e+vec2(0.,pi*.5))*pow(length(u),-1.+4./(e+1.));\n        float ttt = (1.+0.1*sin(iTime))*pi;\n        vec2 ooo = vec2(pi*.5*sin(ttt),pi*.5*cos(ttt));\n        u = sin(atan(u.y,u.x)*e+ooo)*pow(length(u),-1.+4./(e+1.));\n        //u = sin(atan(u.y,u.x)*e+vec2(pi*.5*sin(iTime),pi*.5*cos(iTime)))*pow(length(u),-1.+4./(e+1.));\n        u+= v/p;\n    }\n    \n//  vec3 hsl = vec3(1.+.5*sin(iTime+length(u)), 1.+.5*cos(iTime+length(u)), exp(dot(u,u)*-.1));\n    vec3 hsl = vec3(.5+.5*sin(iTime+length(u)), .5+.5*cos(iTime+length(u)), exp(dot(u,u)*-.1));\n    vec3 rgb = hsv2rgb(hsl);\n    fragColor = vec4(rgb, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdlfzf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdSBDm", "name": "waterCaustics", "author": "mailko", "description": "water caustics", "tags": ["voronoi", "water", "caustics"], "likes": 3, "viewed": 91, "date": "1590135511", "time_retrieved": "2024-06-20T20:08:29.835137", "image_code": "#define SIZE 8.0\nvec2 hash22(vec2 p)\n{\n    p = vec2 (\n        dot(p, vec2(127.1, 311.7)),\n        dot(p, vec2(269.5, 183.3))\n    );\n    return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);\n}\n\nfloat wnoise(vec2 p, float time)\n{\n    vec2 pi = floor(p);\n    vec2 pf = p - pi;\n    float minDistance = 5.0;\n    \n    //ä¹å®«æ ¼ä¸­åæå°è·ç¦»\n    for(int i = -1; i <= 1; i++)\n    {\n    \tfor(int j = -1; j <=1; j++)\n        {\n            vec2 offset = vec2(i, j);\n            vec2 rand = hash22(pi + offset);\n           \tvec2 move = 0.5 + 0.5 * sin(rand * time);\n            move = pi + offset + move - p;\n            float distance = dot(move, move) * 1.0;\n            if(distance < minDistance)\n            {\n                minDistance = distance;\n            }\n        }\n    }\n    return minDistance;\n}\n\nfloat noise_sum(vec2 p)\n{\n    float f = 0.0;\n    p = p / 2.0;\n    f += 1.0000 * wnoise(p, iTime); p = 2.0 * p;\n    //f += 0.5000 * wnoise(p, iTime); \n    p = 2.0 * p;\n    f += 0.2500 * wnoise(p, iTime); p = 2.0 * p;\n    //f += 0.1250 * wnoise(p, iTime); \n    p = 2.0 * p;\n    f += 0.0625 * wnoise(p, iTime); p = 2.0 * p;\n\n   return f;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv * SIZE;\n    float val = noise_sum(uv);\n    fragColor = vec4(0.2, 0.6, 1, 1) * vec4(val, val, val, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdSBDm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdSBRG", "name": "images as bar charts of RGB", "author": "matthen", "description": "images as bar charts of red, green, and blue.  underlying animation by Flyguy https://www.shadertoy.com/view/XsSfW1", "tags": ["rgb", "pixels"], "likes": 5, "viewed": 542, "date": "1590228885", "time_retrieved": "2024-06-20T20:08:30.241304", "image_code": "vec4 rainbowDisk(vec2 o) {\n    // the underlying image\n    // source: https://www.shadertoy.com/view/XsSfW1 by Flyguy\n    o *= max(iResolution.x, iResolution.y);\n    o += .5 * iResolution.xy;\n    vec4 c;\n    vec2 r = iResolution.xy;\n    o = vec2(length(o -= r/2.) / r.y - .3, atan(o.y,o.x));    \n    vec4 s = c.yzwx = .1*cos(1.6*vec4(0,1,2,3) + iTime + o.y + sin(o.y) * sin(iTime)*2.),\n    f = min(o.x-s, c-o.x);\n    return dot(40.*(s-c), clamp(f*r.y, 0., 1.)) * (s-.1) - f;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    float t = iTime;\n    t = mod(t, 30.);\n    float res = max(iResolution.x, iResolution.y);\n    float maxScale = res / 9.;\n    // zoom in and out\n    float scale = mix(\n        4.,  maxScale,\n    \tsmoothstep(2., 15., t) - smoothstep(20., 30., t)\n    );\n    vec2 off = vec2(-.2, .1);\n    vec2 uv = scale * ((fragCoord - .5 * iResolution.xy) / res - off);\n    float pixel = scale / res;\n\n    vec2 pixeluv = fract(uv);\n    vec2 imguv = (floor(uv)) / maxScale + off;\n    \n    vec3 colImg = rainbowDisk(imguv).rgb;\n    // make the loop seemless\n    colImg = mix(\n        // just something to pseudo random\n        fract(vec3(\n            sin(300.123 * imguv.x + 300.123 * imguv.y),\n            sin(100.521 * imguv.y - 250.2 * imguv.x),\n            0.4)),\n\t\tcolImg, smoothstep(0., .1, t) - smoothstep(29.9, 30., t));\n    colImg = clamp(colImg, .1, .9);\n\n    vec3 col = vec3(0.);\n    col.r = smoothstep(\n        pixel, 0.,\n        max(\n            pixeluv.y - colImg.r,\n            pixeluv.x - 0.3333333 + pixel\n        )\n    );\n    col.g = smoothstep(\n        pixel, 0.,\n        max(\n            pixeluv.y - colImg.g,\n            max(pixeluv.x - 0.666666 + pixel,\n                0.333333 - pixeluv.x + pixel)\n        )\n    );\n    col.b = smoothstep(\n        pixel, 0.,\n        max(\n            pixeluv.y - colImg.b,\n            0.666 - pixeluv.x + pixel\n        )\n    );\n    col *= smoothstep(\n        0., 4. * pixel * smoothstep(10., 1., scale),\n        min(\n            min(pixeluv.y, 1. - pixeluv.y),\n            min(pixeluv.x, 1. - pixeluv.x)\n        )\n    );\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdSBRG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdSBWG", "name": "Simple 2D wave", "author": "remilanza", "description": "Based on https://www.shadertoy.com/view/MtyyR3", "tags": ["2d", "wave"], "likes": 1, "viewed": 104, "date": "1590653388", "time_retrieved": "2024-06-20T20:08:30.241304", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\t// Scale pixel coords to 0..1 range instead\n    //vec2 uv = vec2(fragCoord.x, fragCoord.y/iResolution.y);\n    \n    float pi2 = 3.1415926535 * 2.;\n    float waves = 30.;\n    float speed = 20.;\n    \n    float height= 140.;\n    \n    vec3 c = vec3(0.,0.,0.);\n    float dx = -0.4*iTime;\n    \n    \n    \n    float y = sin((uv.x + dx) * pi2 * waves);// * cos(0.0) + (iTime * speed));\n\t//float y_max = (uv.y-0.5) * height /* * (0.1*sin(iTime))*/;\n   \n    height *= (1.0 + 0.5*sin(20.0*uv.x));\n    float y_max = (uv.y - 0.5) * height * (1.0 + 0.2*sin(iTime * speed)) ;\n    float y_min = y_max - 1.1;\n    \n    if(y < y_max && y > y_min){\n        c = vec3(1.0,0.0,0.2);\n    }\n    \n\tfragColor   = vec4(c,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdSBWG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdsBzB", "name": "Minimalistic fire", "author": "Tetane", "description": "Minimalistic fire", "tags": ["sdf", "fire", "circle", "minimalistic"], "likes": 1, "viewed": 307, "date": "1588714804", "time_retrieved": "2024-06-20T20:08:30.241304", "image_code": "#define pi 3.14159\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy) / iResolution.y+0.5;\n    float a = atan(uv.x - 0.5, -uv.y + 0.5);\n    \n    float d = distance((uv),vec2(0.5));\n    d = d + 0.12 * cos(a*10.0+iTime*1.5) * cos(a*5.0-iTime*1.5) * pow(a/(2.0*pi),2.0);    \n    \n    vec3 col = vec3(smoothstep(d,d+0.005,0.3) - smoothstep(d,d+0.005,0.28));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdsBzB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdSBzG", "name": "Outline 2020 Freestyle Session", "author": "blackle", "description": "coded live in 2 hours at outline online 2020 during the shader freestyle. code quality and performance is no good XD", "tags": ["freestyle"], "likes": 34, "viewed": 476, "date": "1590259909", "time_retrieved": "2024-06-20T20:08:31.483821", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax,p)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat linedist(vec3 p, vec3 a, vec3 b) {\n  float k = dot(p-a,b-a)/dot(b-a,b-a);\n  return distance(p, mix(a,b,clamp(k,0.,1.)));\n}\n\nfloat linedist(vec2 p, vec2 a, vec2 b) {\n  float k = dot(p-a,b-a)/dot(b-a,b-a);\n  return distance(p, mix(a,b,clamp(k,0.,1.)));\n}\n\nfloat smin(float a, float b, float k) {\n  float h = max(0.,k-abs(b-a))/k;\n  return min(a,b)-h*h*h*k/6.;\n}\n\nfloat box(vec4 p, vec4 d) {\n  vec4 q = abs(p)-d;\n  return length(max(q,0.)) + min(0., max(max(q.x,q.y),max(q.z,q.w)));\n}\nfloat box(vec3 p, vec3 d) {\n  vec3 q = abs(p)-d;\n  return length(max(q,0.)) + min(0., max(q.x,max(q.z,q.y)));\n}\n\nvec4 wrot(vec4 p) {\n  return vec4(dot(p,vec4(1.)), p.yzw + p.zwy - p.wyz - p.xxx)/2.;\n}\n\nfloat sep;\nfloat t;\nfloat plane;\nfloat obj;\nfloat hiddenball;\nfloat clouds(vec3 p) {\n  \n  p = erot(p,normalize(vec3(2,3,1)),2.123);\n  float d1 = length(abs(asin(sin(p))*.9))-1.;\n  p = erot(p,normalize(vec3(1,2,3)),2.453);\n  float d2 = length(abs(asin(sin(p))*.9))-1.;\n  p = erot(p,normalize(vec3(3,2,1)),0.7821);\n  float d3 = length(abs(asin(sin(p))*.9))-1.;\n  return (d1+d2+d3)/3.;\n}\n\nfloat airplane(vec3 p) {\n  float pln = linedist(p, vec3(.4,0,0), vec3(-.6,0,0))-.1-cos(p.x*2.)*.1;\n  float wingskel = linedist(p.xy, vec2(0,.6), vec2(0,-.6))-.15;\n  float wing = linedist(vec2(wingskel, p.z), vec2(-.04,0), vec2(-1,0))-.04;\n  float tail = linedist(p, vec3(-.65,0,0), vec3(-.85,0,.2))-.13;\n  float ruddskel = linedist(p.xy, vec2(-.9,.3), vec2(-.9,-.3))-.1;\n  float rudd = linedist(vec2(ruddskel, p.z), vec2(-.04,.28), vec2(-1,.28))-.03;\n  return smin(min(rudd,wing), smin(tail,pln,0.2),.1);\n}\n\nfloat blimp(vec3 p) {\n  float blmp = linedist(p, vec3(.6,0,0), vec3(-.7,0,0))-.4-cos(p.x*2.)*.1;\n  float carriage = linedist(p, vec3(.3,0,-.5), vec3(-.3,0,-.5))-.15;\n  p.yz = abs(p.yz);\n  p.yz = vec2(max(p.y,p.z),min(p.y,p.z));\n  float ruddskel = linedist(p.xy, vec2(-1.,.3), vec2(-.8,-.3))-.2;\n  float rudd = linedist(vec2(ruddskel, p.z), vec2(-.04,.0), vec2(-1,.0))-.03;\n  return min(min(carriage,blmp),rudd);\n}\n\nfloat hotair(vec3 p) {\n  p.z -= .4;\n  float ht = length(p)-.7;\n  float dimpl = linedist(p, vec3(0), vec3(0,0,-.8))-.2;\n  float hollow = linedist(p, vec3(0), vec3(0,0,-1.3))-.18;\n  float carriage = box(p-vec3(0,0,-1.3), vec3(.12))-.05;\n  carriage = -min(-carriage, box(p-vec3(0,0,-1.), vec3(.12, .12, .3)));\n  p.xy = abs(p.xy);\n  float lines = linedist(p, vec3(0.1,0.1,-.5), vec3(.1,.1,-1.3))-.01;\n  return min(-smin(-smin(ht, dimpl, 0.4),hollow,.01), min(lines,carriage));\n}\n\nfloat helicopter(vec3 p) {\n  float body = linedist(p, vec3(.2,0,0), vec3(-.2,0,0))-.35;\n  body = smin(body, linedist(p, vec3(.2,0,-.2), vec3(-1.,0,-.2))-.2, .2);\n  float tail = linedist(p, vec3(-1.1,0,-.2), vec3(-1.3,0,0))-.13;\n  body = smin(body,tail,.1);\n  vec3 p2 = p;\n  p2.x -= -1.3;\n  p2 = erot(p2, vec3(0,1,0), iTime);\n  p2.y -=0.15;\n  p2.y=abs(p2.y);\n  p2.xz = abs(p2.xz);\n  p2.zx = vec2(max(p2.x,p2.z),min(p2.x,p2.z));\n  p = erot(p, vec3(0,0,1), iTime);\n  p.z -=0.44;\n  p.yx = abs(p.yx);\n  p.yx = vec2(max(p.y,p.x),min(p.y,p.x));\n  \n  float wingskel = linedist(p.xy, vec2(0,.6), vec2(0,-.6))-.1;\n  float wing = linedist(vec2(wingskel, p.z), vec2(-.04,0), vec2(-1,0))-.04;\n  float wingskel2 = linedist(p2.xz, vec2(0,.2), vec2(0,-.23))-.06;\n  float wing2 = linedist(vec2(wingskel2, p2.y), vec2(-.04,0), vec2(-1,0))-.02;\n  return min(body,min(wing,wing2));//smin(min(rudd,wing), smin(tail,pln,0.2),.1);\n  \n}\n\nfloat scene(vec3 p) {\n  float fl = p.z + 5.;\n  \n  vec3 pp = p;\n  pp.y = asin(sin(pp.y/sep))*sep;\n  float roll = pow(sin(fract(t*.03)*3.14/2.),50.) + floor(t*.03);\n  pp = erot(pp, vec3(1,0,0),roll*acos(-1.)*2.);\n  pp = erot(pp, vec3(0,1,0),sin(t)*.4);\n  pp = erot(pp, vec3(0,0,1),cos(t*.5)*.2);\n  pp.z += cos(t)*.3;\n  pp.y += -sin(t*.5)*.2;\n  float air = airplane(pp);\n  float blmp = blimp(pp);\n  float hot = hotair(pp);\n  float heli = helicopter(pp);\n  float mixval_a = smoothstep(-.25,.25,sin((iTime+1.)/2.));\n  float mixval_b = smoothstep(-.15,.15,sin((iTime+1.)/4.));\n  plane = mix(mix(hot, heli, mixval_a), mix(blmp, air, mixval_a), mixval_b);\n  //plane = \n  \n  \n  p.x += mod(t,1000.);\n  vec3 p2 = p;\n  p2 = erot(p2, vec3(0,0,1),.31233);\n  p2.xy = asin(sin(p2.xy/3.)*.97)*3.+3.;\n  p2.z += 4.;\n  p2 = erot(p2, vec3(0,0,1),t*.3);\n  p2 = erot(p2, vec3(0,1,0),t*.2);\n  p2 = erot(p2, vec3(1,0,0),t*.1);\n  obj = length(min(1.-abs(p2),0.6))-.7;\n  \n  \n  p = erot(p,normalize(vec3(2,3,1)),2.123);\n  float d1 = dot(abs(asin(sin(p))*.9),vec3(1))/sqrt(3.)-1.;\n  p = erot(p,normalize(vec3(1,2,3)),2.453);\n  float d2 = dot(abs(asin(sin(p))*.9),vec3(1))/sqrt(3.)-1.;\n  p = erot(p,normalize(vec3(3,2,1)),0.7821);\n  float d3 = dot(abs(asin(sin(p))*.9),vec3(1))/sqrt(3.)-1.;\n  \n  \n  \n  float ground = mix((d1+d2+d3)/2.5, fl,0.2);\n  vec4 reproj = vec4(ground, asin(sin(p*5.))/5.);\n  float mx = cos(iTime*.3-fl*.3)*.5+.5;\n  mx = smoothstep(0.4,.6,mx);\n  mx = smoothstep(0.,1.,mx);\n  reproj = mix(wrot(reproj), reproj,mx);\n  ground = box(reproj,vec4(.02,.27,.27,.27))-0.04;\n  hiddenball = length(reproj+vec4(.2,0,0,0))-.2;\n  ground = min(ground, hiddenball);\n  return min(min(obj,ground), plane);\n}\n\nvec3 norm(vec3 p) {\n  mat3 k = mat3(p,p,p)-mat3(0.03);\n  return normalize(scene(p)-vec3(scene(k[0]), scene(k[1]), scene(k[2])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord - iResolution.xy*.5)/iResolution.y;\n\n  float sc = smoothstep(.5,.6,cos(iTime/10.+3.));\n  t = pow(sin(fract(iTime*.4)*3.14/2.),70.)*2. + floor(iTime*.4)*2. + iTime*.9 + 2.;\n  sep = 2.+cos(t*.4);\n  vec3 cam = normalize(vec3(1, uv));\n  vec3 init = vec3(-5.+sin(t), 0, 0) + cam;\n  cam = erot(cam,vec3(0,1,0),.7-sc*.3);\n  init = erot(init,vec3(0,1,0),.7-sc*.3);\n  float zrot = t*.3;\n  cam = erot(cam,vec3(0,0,1),zrot);\n  init = erot(init,vec3(0,0,1),zrot); \n  init.z -= sc*4.;\n  \n\n  vec3 p = init;\n  bool hit = false;\n  float dist;\n  bool triggered = false;\n  bool outline = false;\n  float glow = 0.;\n  for (int i = 0; i < 150 && !hit; i++) { \n    dist = scene(p);\n    glow += 1./(hiddenball*500.+1.);\n    if (!triggered) triggered = dist < 0.03;\n    if (triggered) {\n      float ol = 0.05-dist;\n      outline = ol < dist;\n      dist = min(ol,dist);\n    }\n    hit = dist*dist < 1e-6;\n    p+=cam*dist;\n  }\n  vec3 p2 = init;\n  for (int i = 0; i < 30; i++) {\n    float dd = abs(clouds(p2))+.1;\n    p2+=cam*dd;\n  }\n  float lcoudstr = distance(p2, init);\n  float fog = smoothstep(40.,10.,distance(p,init)+ lcoudstr*.5);\n  bool pl = plane == dist;\n  bool oj = obj == dist;\n  vec3 n = norm(p);\n  vec3 r = reflect(cam,n);\n  float ao = smoothstep(-.1,.1,scene(p+n*.1));\n  float diff = ao*length(sin(n*vec3(3,2,2))*.5+.5)/sqrt(3.);\n  diff = floor(diff*6.)/6.+.1;\n  float spec = length(sin(r*vec3(3,2,2))*.5+.5)/sqrt(3.);\n  float fres = 1.-abs(dot(cam,n))*.9;\n  vec3 matcol = mix(vec3(0.3,0.7,0.2), vec3(0.7,0.5,0.2), smoothstep(-5.5,-4.5,p.z));\n  matcol = mix(matcol, vec3(0.7,0.75,0.9), smoothstep(-4.5,-3.5,p.z));\n  if (pl) {\n    matcol = vec3(0.9,0.8,0.3);\n    float id = floor(p.y/acos(-1.)/sep + 1.5);\n    id += floor(iTime);\n    matcol = abs(erot(matcol, vec3(1,0,0), id))*.6+.4;\n    matcol = abs(erot(matcol, vec3(0,1,0), id*2.3423))*.6+.4;\n  }\n  vec3 col = matcol*diff + pow(spec,10.)*fres*1.5;\n  if (oj) {\n    \n    float spec2 = length(sin(r*vec3(3,1,1))*.5+.5)/sqrt(3.);\n    float spec3 = length(sin(-r*vec3(3,1,1))*.5+.5)/sqrt(3.);\n    col = vec3(0.8,0.3,0.2)*floor(spec2*6.)/6.+pow(spec2,10.);\n    col += (vec3(0.1,0.3,0.8)*floor(spec3*6.)/6.+pow(spec3,10.))*.7;\n    col *=ao;\n  }\n  vec3 bgcol = vec3(0.4,0.7,0.9);\n  if (!pl) {\n    col *= 0.7;\n  } else {\n    col = col*.7+.3;\n  }\n  col = erot(col,normalize(sin(p)),.02);\n  fragColor.xyz = (hit ? mix(bgcol, col,fog) : bgcol) + pow(smoothstep(40.,5.,lcoudstr),10.)*(1.-fog);\n  if (outline) fragColor.xyz = mix(bgcol, fragColor.xyz*.2, fog);\n  fragColor.xyz = smoothstep(vec3(-.2),vec3(1.2),fragColor.xyz);\n  fragColor.xyz += (glow*vec3(0.7,0.3,0.)+glow*.9)*.4;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc0-1.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdSBzG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdSBzK", "name": "voxel-raycasting", "author": "vizaxo", "description": "roxel raycasting", "tags": ["voxelraycasting"], "likes": 0, "viewed": 97, "date": "1590408003", "time_retrieved": "2024-06-20T20:08:32.083857", "image_code": "const float pi = 3.141592;\nconst float tau = 2.0*pi;\n\n//#define TIME (3.0*tau/4.0)\n#define TIME iTime/2.0\n\nconst float sphereRadius = 15.0;\nconst float camRadius = 2.0*sphereRadius;\n\nstruct hit {\n    bool didHit;\n    vec3 col;\n};\n\nhit getVoxel(ivec3 p) {\n    if (length(vec3(p)) < sphereRadius)\n        return hit(true, vec3(p) / (sphereRadius * 2.0) + 0.6);\n    else\n        return hit(false, vec3(0,0,0));\n\n}\n\nvec3 lighting(vec3 norm, vec3 pos, vec3 rd, vec3 col) {\n    vec3 lightDir = normalize(vec3(-1.0, 3.0, -1.0));\n    float diffuseAttn = max(dot(norm, lightDir), 0.0);\n    vec3 light = vec3(1.0,0.9,0.9);\n    \n    vec3 ambient = vec3(0.2, 0.2, 0.3);\n    \n    vec3 reflected = reflect(rd, norm);\n    float specularAttn = max(dot(reflected, lightDir), 0.0);\n    \n    return col*(diffuseAttn*light*1.0 + specularAttn*light*0.6 + ambient);\n}\n\n// Voxel ray casting algorithm from \"A Fast Voxel Traversal Algorithm for Ray Tracing\" \n// by John Amanatides and Andrew Woo\n// http://www.cse.yorku.ca/~amana/research/grid.pdf\nhit intersect(vec3 ro, vec3 rd) {\n    //Todo: find out why this is so slow\n    vec3 pos = floor(ro);\n    \n    vec3 step = sign(rd);\n    vec3 tDelta = step / rd;\n\n    \n    float tMaxX, tMaxY, tMaxZ;\n    \n    vec3 fr = fract(ro);\n    \n    tMaxX = tDelta.x * ((rd.x>0.0) ? (1.0 - fr.x) : fr.x);\n    tMaxY = tDelta.y * ((rd.y>0.0) ? (1.0 - fr.y) : fr.y);\n    tMaxZ = tDelta.z * ((rd.z>0.0) ? (1.0 - fr.z) : fr.z);\n\n    vec3 norm;\n    const int maxTrace = 100;\n    \n    for (int i = 0; i < maxTrace; i++) {\n        hit h = getVoxel(ivec3(pos));\n        if (h.didHit) {\n            return hit(true, lighting(norm, pos, rd, h.col));\n        }\n\n        if (tMaxX < tMaxY) {\n            if (tMaxZ < tMaxX) {\n                tMaxZ += tDelta.z;\n                pos.z += step.z;\n                norm = vec3(0, 0,-step.z);\n            } else {\n                tMaxX += tDelta.x;\n            \tpos.x += step.x;\n                norm = vec3(-step.x, 0, 0);\n            }\n        } else {\n            if (tMaxZ < tMaxY) {\n                tMaxZ += tDelta.z;\n                pos.z += step.z;\n                norm = vec3(0, 0, -step.z);\n            } else {\n            \ttMaxY += tDelta.y;\n            \tpos.y += step.y;\n                norm = vec3(0, -step.y, 0);\n            }\n        }\n    }\n\n \treturn hit(false, vec3(0,0,0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n    vec3 worldUp = vec3(0,1,0);\n    vec3 camPos = vec3(camRadius*sin(TIME), 10, 1.0*camRadius*cos(TIME));\n    vec3 lookAt = vec3(0,0,0);\n    vec3 camDir = normalize(lookAt - camPos);\n    vec3 camRight = normalize(cross(camDir, worldUp));\n    vec3 camUp = cross(camRight, camDir);\n    \n    vec3 filmCentre = camPos + camDir*0.3;\n    vec2 filmSize = vec2(1,iResolution.y / iResolution.x);\n    \n    vec3 filmPos = filmCentre + uv.x*filmSize.x*camRight + uv.y*filmSize.y*camUp;\n    vec3 ro = camPos;\n    vec3 rd = normalize(filmPos - camPos);\n    \n    hit h = intersect(ro, rd);    \n    if(h.didHit) {\n        fragColor = vec4(h.col,0);\n    } else{\n        fragColor = vec4(0,0,0,0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdSBzK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdsBzS", "name": "Loopless Conic Envelope", "author": "mla", "description": "Draw a net of lines tangent to a conic section and passing through a \"baseline\" that follows the mouse (end  points to baseline shown). The lines nearest the pixel point are calculated completely looplessly.", "tags": ["envelope", "conic", "projective", "loopless"], "likes": 6, "viewed": 295, "date": "1588924976", "time_retrieved": "2024-06-20T20:08:33.302142", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Loopless Conic Envelopes\n// Matthew Arcus, mla, 2020\n//\n// A demo of drawing envelopes of conic curves looplessly\n//\n////////////////////////////////////////////////////////////////////////////////\n\n\nconst float PI = 3.1415927;\nint AA = 2;\n\n// With homogeneous coordinates, (x,y,z) corresponds to the Euclidean\n// point (x/z,y/z), so (kx,ky,kz) represents the same point for any\n// k. z can be regarded as a \"scaling\" parameter, so (x,y,0)\n// represents a point infinitely far away (like a vanishing point in a\n// perspective drawing it can be regarded as a pure direction), in\n// fact, a point on the \"line at infinity\", equation z = 0.\n//\n// Lines also are represented as l = vec3(a,b,c) with point p being on line l\n// just when dot(l,p) = 0, again, multiples of (a,b,c) represent the\n// same line, so (a,b,c) represents the Euclidean line ax+by+c = 0.\n//\n// If l1 and l2 are lines, join(l1,l2) is their intersection, and if p1,p2 are\n// points, then join(p1,p2) is the line between them. join is just\n// cross product:\n\nvec3 join(vec3 p, vec3 q) {\n  return cross(p,q);\n}\n\n// Actually drawing a point or a line or a conic involves Euclidean notions of\n// scale and distance, so we need to convert to Euclidean points (or do something\n// equivalent), so to draw a point, we need the distance between the pixel point\n// and the point being drawn (we can look on this as mapping both points to the\n// z=1 plane and measuring distances there):\n\nfloat point(vec3 p, vec3 q) {\n  return distance(p.xy/p.z,q.xy/q.z);\n}\n\n// We can short circuit the calculations a little:\n// If p = (x,y,z) and l = (a,b,c) then (x/z,y/z) is the Euclidean point\n// and if |(a,b)| = 1, then the distance to the line is ax+by+c:\nfloat line(vec3 p, vec3 l) {\n  return abs(dot(p,l)/(p.z*length(l.xy)));\n}\n\n// For a line given by two points, just join the points into a line:\nfloat line(vec3 p, vec3 q, vec3 r) {\n  return line(p,join(q,r));\n}\n\n// A conic curve is represented by a 3x3 symmetric matrix A and p is on the\n// conic just when dot(p,A*p) = dot(p*A,p) = 0. Lines tangent to the conic then\n// satisfy dot(l,inverse(A)*l) = dot(l*inverse(A),l) = 0 (points and lines\n// are dual).\n//\n// For simple conics where the matrix is diagonal, we can just use a\n// a vector to represent the conic, the code is much the same:\n//\n// To turn the conic equation into a distance function, we need to\n// divide by the magnitude of the gradient, and the gradient at p is\n// just 2.0*A*p (analogous to dx^2/dx = 2x):\nfloat conic(vec3 p, mat3 A) {\n  float s = dot(p,A*p);\n  vec3 ds = 2.0*A*p; // Gradient\n  return abs(s/(p.z*length(ds.xy))); // Normalize for Euclidean distance\n}\n\n// Note, this is solving at^2 + 2bt + c = 0, so the discriminant is\n// b^2 - ac, not b^2 - 4ac.\nbool quadratic(float a, float b, float c, out float t1, out float t2) {\n  // Assumes we have checked for a == 0 or c == 0\n  float disc = b*b-a*c;\n  if (disc < 0.0) return false;\n  if (b >= 0.0) {\n    // Try to avoid rounding error.\n    t1 = -b-sqrt(disc);\n    t2 = c/t1; t1 /= a;\n  } else {\n    t2 = -b+sqrt(disc);\n    t1 = c/t2; t2 /= a;\n  }\n  return true;\n}\n\n// Find the intersections of the line through p0,p1 with the conic\n// defined by A by solving a quadratic equation.\n// (or dually, find the tangent lines to A through join of lines p0,p1).\nbool intersection(vec3 p0, vec3 p1, mat3 A, out vec3 q0, out vec3 q1) {\n  // Any line through p0, p1 is expressible as p0+t*p1,\n  // so solve (p0 + t*p1)A((p0 + t*p1) = 0 =>\n  // p0*A*p0 + 2*t*p0*A*p1 + t^2*p1*A*p1 = 0\n  // We have a quadratic equation:\n  float a = dot(p1,A*p1), b = dot(p0,A*p1), c = dot(p0,A*p0);\n  // a==0 or c==0 indicate p1 or p0 are actually on conic\n  if (a == 0.0) { q0 = q1 = p1; return true; }\n  if (c == 0.0) { q0 = q1 = p0; return true; }\n  float t1,t2;\n  if (!quadratic(a,b,c,t1,t2)) return false;\n  q0 = p0 + t1*p1;\n  q1 = p0 + t2*p1;\n  return true;\n  \n}\n\n// Find the tangents to a conic from the point z, since this involves\n// solving a quadratic equation, there may be no (real) solution, so\n// return a boolean to indicate success or otherwise.\nbool tangents(vec3 z, mat3 A, out vec3 tan1, out vec3 tan2) {\n  // Construct two lines through the point - assuming that z is not at\n  // infinity, l1 and l2 will be distinct.\n  vec3 l1 = join(z,vec3(1,0,0));\n  vec3 l2 = join(z,vec3(0,1,0));\n  return intersection(l1,l2,A,tan1,tan2);\n}\n\n// crossratio(infinity,p,q,r) = pr/pq\n// Assumes p,q,r are collinear.\n// -1 if p is midpoint of q and r\n// r = p + k(q-p) or r = (1-k)p + kq where k = ratio(p,q,r)\nfloat ratio(vec3 p, vec3 q, vec3 r) {\n  p /= p.z; q /= q.z; r /= r.z;\n  return dot(r-p,q-p)/dot(q-p,q-p);\n}\n\nvec3 getcolor(vec3 z, vec3 pointer) {\n  // This is just a plain unit circle, which seems very dull,\n  mat3 A = mat3(1,0,0,\n                0,1,0,\n                0,0,-1);\n  // until we rotate it in projective space, when it transitions\n  // to ellipse, parabola, hyperbola, then back to parabola,\n  // ellipse and circle.\n  float t = iTime;\n  mat3 rot = mat3(cos(t),0,sin(t),\n                  0,1,0,\n                  -sin(t),0,cos(t));\n  A = A*rot;\n\n  // We use the inverse of the conic matrix to find lines.\n  mat3 Ainv = inverse(A);\n\n  float dconic = conic(z,A); // The distance to the conic\n\n  // Draw the grid of tangent lines to the conic, with lines\n  // passing through a baseline:\n  vec3 base0 = vec3(-1,0,1);\n  vec3 base1 = pointer;\n  vec3 baseline = join(base0,base1);\n  vec3 tan1, tan2; // Put tangent solutions here\n  float ldist = dconic; // This will be minimum distance to a line,\n  float pdist = 1e8; // and the minimum distance to a point\n  pdist = min(pdist,point(z,2.0*base0-base1)); // Opposite baseline end\n  if (tangents(z,Ainv,tan1,tan2)) {\n    // Find where the tangents hit the baseline\n    vec3 z1 = join(tan1,baseline); \n    vec3 z2 = join(tan2,baseline);\n    float k1 = ratio(base0,base1,z1);\n    float k2 = ratio(base0,base1,z2); \n    float N = 16.0;\n    float t = 0.0;//0.1*iTime;\n    k1 = round(N*(k1+t))/N-t;\n    k2 = round(N*(k2+t))/N-t;\n    // If the rounded baseline point is in the right range (and the\n    // tangent from there is defined) then draw it. Since there will\n    // be two tangents from the baseline point, we need to make sure\n    // we use the right one - if baseline point and the pixel point\n    // are on the same side of the conic, then use the same quadratic\n    // root for both, otherwise use different roots. We find which\n    // side the points are with the ratio function.\n    //\n    // If line l is a tangent to the conic A, then the intersection\n    // point of the tangent is Ainv*l (and the tangent line at point\n    // p is A*p). A is symmetric, so A*p = p*A and Ainv*l = l*Ainv.\n    vec3 tan11,tan12;\n    if (abs(k1) <= 1.0 && tangents(base0+k1*(base1-base0),Ainv,tan11,tan12)) {\n      vec3 t1 = Ainv*tan1; // The point of tan1 on the conic\n      if (ratio(t1,z1,z) > 0.0) ldist = min(ldist,line(z,tan11));\n      else ldist = min(ldist,line(z,tan12));\n    }\n    vec3 tan21,tan22;\n    if (abs(k2) <= 1.0 && tangents(base0+k2*(base1-base0),Ainv,tan21,tan22)) {\n      vec3 t2 = Ainv*tan2; // The point of tan2 on the conic\n      if (ratio(t2,z2,z) > 0.0) ldist = min(ldist,line(z,tan22));\n      else ldist = min(ldist,line(z,tan21));\n    }\n  }\n  ldist = min(ldist,line(z,baseline));\n  pdist = min(pdist,point(z,pointer));\n  vec3 col = vec3(0.75+0.25*cos(20.0*dconic),1,1);\n  col *= smoothstep(0.01,max(fwidth(z.x),0.02),ldist);\n  col *= smoothstep(0.08,0.1,pdist);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec3 col = vec3(0);\n  float scale = 5.0;\n  vec2 pointer;\n  if (iMouse.x > 0.0) pointer = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n  else pointer = cos(0.5*iTime-vec2(0,0.4*PI));\n  for (int i = 0; i < AA; i++) {\n    for (int j = 0; j < AA; j++) {\n      vec2 z = (2.0*(fragCoord+vec2(i,j)/float(AA))-iResolution.xy)/iResolution.y;\n      col += getcolor(vec3(scale*z,1),vec3(scale*pointer,1));\n    }\n  }\n  col /= float(AA*AA);\n  col = pow(col,vec3(0.4545));\n  fragColor = vec4(col,1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdsBzS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdsfD7", "name": "Watercolour Sketches", "author": "samhattangady", "description": "Tried to make a watercolour painting. Quite happy with how it turned out.\nThoughts and criticism appreciated.", "tags": ["watercolour", "handdraw"], "likes": 8, "viewed": 403, "date": "1588397199", "time_retrieved": "2024-06-20T20:08:34.569330", "image_code": "/*\n * 02 May 2020\n * I liked yesterday's sketch a lot. Wanted to make it a little less thick.\n * Fiddled with the values till I had a nice thin line that looked nice.\n * Wanted to go with a quick and dirty watercolour style sketch. Really happy\n * with the result.\n * The biggest problem I'm facing is the uniformity of the noise. Specifically\n * while filling in the colours (painting). So if I draw\n * multiple shapes that occupy the same space, their behaviour is identical which\n * doesn't look so great. So I need to figure out what infrastructure is required\n * so that the scale of noise is dependent on the size of the area being filled,\n * as well as use a different noise pattern for every individual shape (or something\n * along those lines) like passing a \"seed\" that is shared for the single fill.\n */\nfloat PI = 3.14159;\n\nvec3 paper_colour = vec3(0.9, 0.9, 0.85);\nvec3 pencil_colour = vec3(0.3, 0.3, 0.40);\n\nfloat line_thickness = 0.0;\nfloat line_variation = 5.2508;\nfloat line_smoothness = 1.5;\nfloat fill_noise = 35.04;\n\nfloat rand(vec2 c) {\n    //return pow((sin(iTime/1.0)),2.0)*0.1 + 0.9*fract(sin(dot(c.xy ,vec2(15.868,781.233))) * 4378.5453);\n\n\treturn fract(sin(dot(c.xy ,vec2(15.868,781.233))) * 4378.5453);\n}\n\nfloat noise(vec2 p, float freq ){\n\tfloat unit = iResolution.x/freq;\n\tvec2 ij = floor(p/unit);\n\tvec2 xy = mod(p,unit)/unit;\n\t//xy = 3.*xy*xy-2.*xy*xy*xy;\n\txy = .5*(1.-cos(PI*xy));\n\tfloat a = rand((ij+vec2(0.,0.)));\n\tfloat b = rand((ij+vec2(1.,0.)));\n\tfloat c = rand((ij+vec2(0.,1.)));\n\tfloat d = rand((ij+vec2(1.,1.)));\n\tfloat x1 = mix(a, b, xy.x);\n\tfloat x2 = mix(c, d, xy.x);\n\treturn mix(x1, x2, xy.y);\n}\n\nfloat pNoise(vec2 p, int res){\n    p += vec2(iTime*14.50, 0.0);\n\tfloat persistance = .5;\n\tfloat n = 0.;\n\tfloat normK = 0.;\n\tfloat f = 30.3;\n\tfloat amp = 1.;\n\tint iCount = 0;\n\tfor (int i = 0; i<50; i++){\n\t\tn+=amp*noise(p, f);\n\t\tf*=2.;\n\t\tnormK+=amp;\n\t\tamp*=persistance;\n\t\tif (iCount == res) break;\n\t\tiCount++;\n\t}\n\tfloat nf = n/normK;\n\treturn nf*nf*nf*nf;\n}\n\nfloat pNoise2(vec2 p, int res){\n    p += vec2(iTime*12.0, iTime*52.0);\n\tfloat persistance = .5;\n\tfloat n = 0.;\n\tfloat normK = 0.;\n\tfloat f = 3.3;\n\tfloat amp = 1.;\n\tint iCount = 0;\n\tfor (int i = 0; i<50; i++){\n\t\tn+=amp*noise(p, f);\n\t\tf*=2.;\n\t\tnormK+=amp;\n\t\tamp*=persistance;\n\t\tif (iCount == res) break;\n\t\tiCount++;\n\t}\n\tfloat nf = n/normK;\n\treturn nf*nf*nf*nf;\n}\n\nfloat get_noise(vec2 p) {\n    float noise = pNoise(p, 3);\n    noise *= 2.0;\n    // noise -= 0.5;\n    return noise;\n}\nfloat get_noise2(vec2 p) {\n    float noise = pNoise2(p, 3);\n    noise *= 2.0;\n    // noise -= 0.5;\n    return noise;\n}\n\nfloat triangle_sign (vec2 p1, vec2 p2, vec2 p3) {\n    return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);\n}\n\nbool point_in_triangle (vec2 pt, vec2 v1, vec2 v2, vec2 v3) {\n    float d1, d2, d3;\n    bool has_neg, has_pos;\n    d1 = triangle_sign(pt, v1, v2);\n    d2 = triangle_sign(pt, v2, v3);\n    d3 = triangle_sign(pt, v3, v1);\n    has_neg = (d1 < 0.0) || (d2 < 0.0) || (d3 < 0.0);\n    has_pos = (d1 > 0.0) || (d2 > 0.0) || (d3 > 0.0);\n    return !(has_neg && has_pos);\n}\n\nfloat rectangle(vec2 samplePosition, vec2 halfSize){\n    vec2 componentWiseEdgeDistance = abs(samplePosition) - halfSize;\n    float outsideDistance = length(max(componentWiseEdgeDistance, 0.0));\n    float insideDistance = min(max(componentWiseEdgeDistance.x, componentWiseEdgeDistance.y), 0.0);\n    return outsideDistance + insideDistance;\n}\n\nfloat distance_to_line(vec2 p, vec2 p1, vec2 p2) {\n    float d;\n    float l_sq = pow(distance(p1, p2), 2.0);\n    if (l_sq == 0.0)\n        d = distance(p, p1);\n    else {\n        float t = max(0.0, min(1.0, dot(p - p1, p2 - p1) / l_sq));\n        vec2 projection = p1 + t * (p2 - p1);  // Projection falls on the segment\n        d = distance(p, projection);\n    }\n    return d;\n}\n\nfloat triangle (vec2 p, vec2 p1, vec2 p2, vec2 p3) {\n    float d, d2, d3;\n    d = distance_to_line(p, p1, p2);\n    d = min(d, distance_to_line(p, p2, p3));\n    d = min(d, distance_to_line(p, p3, p1));\n    if (point_in_triangle(p, p1, p2, p3))\n        return -d;\n    return d;\n}\n\nvec3 draw_line(vec2 p, vec2 p1, vec2 p2, vec3 current_colour) {\n    // return current_colour;\n    p += sin(iTime/1.2)*4.0*vec2(get_noise(p.xy), get_noise(p.yx));\n    p1 += 5.0*vec2(get_noise(p.xy), get_noise(p.yx));\n    p2 -= 5.0*vec2(get_noise(p.xy), get_noise(p.yx));\n    float d = distance_to_line(p, p1, p2);\n    float noise;\n    // TODO (01 May 2020 sam): Figure out how to to better line check\n    if (p1.y<p.y) noise = get_noise(p.yx);\n    else noise = get_noise(p);\n    d += noise*line_variation;\n    float pencil = smoothstep(line_thickness, line_thickness+line_smoothness, d);\n    return mix(pencil_colour, current_colour, pencil);\n}\n\nvec3 fill_box(vec2 p, vec2 p1, vec2 p3, vec3 current_colour, vec3 fill_colour) {\n    vec3 colour = current_colour;\n    vec2 p2 = vec2(p1.x, p3.y);\n    vec2 p4 = vec2(p3.x, p1.y);\n    vec2 box_center = (p1 + p3)/2.0;\n    float bd = rectangle(p-box_center, (p3-p1)/2.0);\n    float noise = get_noise2(p);\n    noise *= fill_noise;\n    if (bd+noise<0.0)\n        colour = fill_colour;\n    return colour;\n}\n\nvec3 draw_box(vec2 p, vec2 p1, vec2 p3, vec3 current_colour, bool fill_paper) {\n    vec3 colour = current_colour;\n    vec2 p2 = vec2(p1.x, p3.y);\n    vec2 p4 = vec2(p3.x, p1.y);\n    vec2 box_center = (p1 + p3)/2.0;\n    float bd = rectangle(p-box_center, (p3-p1)/2.0);\n    float noise = get_noise(p);\n    noise *= 5.0;\n    if (bd-noise<0.0 && fill_paper)\n        colour = paper_colour;\n    colour = draw_line(p, p1, p2, colour);\n    colour = draw_line(p, p2, p3, colour);\n    colour = draw_line(p, p3, p4, colour);\n    colour = draw_line(p, p4, p1, colour);\n    return colour;\n}\n\nvec3 fill_triangle(vec2 p, vec2 p1, vec2 p2, vec2 p3, vec3 current_colour, vec3 fill_colour) {\n    vec3 colour = current_colour;\n    float d = triangle(p, p1, p2, p3);\n    float noise = get_noise2(p);\n    noise *= fill_noise;\n    if (d+noise<0.0)\n        colour = fill_colour;\n    return colour;\n}\n\nvec3 draw_pillar(vec2 pos, vec2 p1, vec2 p3, vec3 current) {\n    float WIDTH = iResolution.x;\n\tfloat HEIGHT = iResolution.y;\n    vec3 building_colour = paper_colour*0.95;\n    vec3 shadow_colour = building_colour*0.9;\n    vec3 sky_colour = vec3(0.83, 0.83, 0.85);\n    vec3 ground_colour = vec3(0.8, 0.8, 0.65);\n    \n    vec3 colour = current;\n    colour = draw_box(pos, p1, p3, colour, true);\n    colour = fill_box(pos, p1, p3, colour, building_colour);\n    colour = fill_box(pos, vec2(p1.x+WIDTH*0.015, p1.y), p3, colour, shadow_colour);\n    return colour;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 colour;\n    float WIDTH = iResolution.x;\n\tfloat HEIGHT = iResolution.y;\n    vec3 building_colour = paper_colour*0.95;\n    vec3 shadow_colour = building_colour*0.9;\n    vec3 sky_colour = vec3(0.83, 0.83, 0.85);\n    vec3 ground_colour = vec3(0.8, 0.8, 0.65);\n\n    vec2 pos = fragCoord;\n    vec2 uv = pos/iResolution.xy;\n    colour = paper_colour;\n    // background\n    colour = fill_box(pos, vec2(WIDTH*0.01, HEIGHT*0.35), vec2(WIDTH*0.99, HEIGHT*0.99), colour, sky_colour*0.93);\n    colour = fill_box(pos, vec2(WIDTH*0.01, HEIGHT*0.35), vec2(WIDTH*0.99, HEIGHT*0.75), colour, sky_colour*0.96);\n    colour = fill_box(pos, vec2(WIDTH*0.01, HEIGHT*0.35), vec2(WIDTH*0.99, HEIGHT*0.5), colour, sky_colour);\n    colour = fill_box(pos, vec2(WIDTH*0.01, HEIGHT*0.01), vec2(WIDTH*0.99, HEIGHT*0.31), colour, ground_colour);\n    colour = fill_triangle(pos, vec2(WIDTH*0.2, HEIGHT*0.3), vec2(WIDTH*0.8, HEIGHT*0.3),  vec2(WIDTH*0.95, HEIGHT*0.1), colour, ground_colour*0.9);\n    float fade = rectangle(pos-vec2(WIDTH*0.5,HEIGHT*0.5), vec2(WIDTH*0.05, 0.0001));\n    fade += get_noise2(pos.yx) * 500.0;\n    fade = smoothstep(WIDTH*0.25, WIDTH*0.452, fade);\n    colour = mix(colour, paper_colour, fade);\n    // horizon\n    colour = draw_line(pos, vec2(-50000.0, iResolution.y/3.0), vec2(iResolution.x*5000.0, iResolution.y/3.0), colour);\n    colour = fill_triangle(pos, vec2(WIDTH*0.18, HEIGHT*0.66), vec2(WIDTH*0.5, HEIGHT*0.82), vec2(WIDTH*0.82, HEIGHT*0.66), colour, paper_colour);\n    // pillars\n    colour = draw_pillar(pos, vec2(WIDTH*0.22, HEIGHT*0.405), vec2(WIDTH*0.26, HEIGHT*0.585), colour);\n    colour = draw_pillar(pos, vec2(WIDTH*0.30, HEIGHT*0.405), vec2(WIDTH*0.34, HEIGHT*0.588), colour);\n    //colour = draw_pillar(pos, vec2(WIDTH*0.22, HEIGHT*0.41), vec2(WIDTH*0.26, HEIGHT*0.59), colour);\n    colour = draw_pillar(pos, vec2(WIDTH*0.37, HEIGHT*0.407), vec2(WIDTH*0.41, HEIGHT*0.586), colour);\n    colour = draw_pillar(pos, vec2(WIDTH*0.44, HEIGHT*0.404), vec2(WIDTH*0.48, HEIGHT*0.583), colour);\n    colour = draw_pillar(pos, vec2(WIDTH*0.51, HEIGHT*0.406), vec2(WIDTH*0.55, HEIGHT*0.588), colour);\n    colour = draw_pillar(pos, vec2(WIDTH*0.59, HEIGHT*0.404), vec2(WIDTH*0.63, HEIGHT*0.589), colour);\n    colour = draw_pillar(pos, vec2(WIDTH*0.66, HEIGHT*0.408), vec2(WIDTH*0.70, HEIGHT*0.586), colour);\n    colour = draw_pillar(pos, vec2(WIDTH*0.74, HEIGHT*0.409), vec2(WIDTH*0.78, HEIGHT*0.583), colour);\n    // base\n    colour = draw_box(pos, vec2(WIDTH*0.2, HEIGHT*0.3), vec2(WIDTH*0.8, HEIGHT*0.4), colour, true);\n    colour = fill_box(pos, vec2(WIDTH*0.2, HEIGHT*0.3), vec2(WIDTH*0.8, HEIGHT*0.4), colour, building_colour);\n    colour = fill_box(pos, vec2(WIDTH*0.2, HEIGHT*0.3), vec2(WIDTH*0.8, HEIGHT*0.36), colour, shadow_colour);\n    colour = draw_box(pos, vec2(WIDTH*0.24, HEIGHT*0.32), vec2(WIDTH*0.76, HEIGHT*0.38), colour, false);\n    // roof\n    colour = draw_box(pos, vec2(WIDTH*0.2, HEIGHT*0.6), vec2(WIDTH*0.8, HEIGHT*0.66), colour, true);\n    colour = fill_box(pos, vec2(WIDTH*0.2, HEIGHT*0.6), vec2(WIDTH*0.8, HEIGHT*0.66), colour, building_colour);\n    colour = fill_box(pos, vec2(WIDTH*0.26, HEIGHT*0.6), vec2(WIDTH*0.8, HEIGHT*0.64), colour, shadow_colour);\n    colour = fill_triangle(pos, vec2(WIDTH*0.2, HEIGHT*0.68), vec2(WIDTH*0.5, HEIGHT*0.8), vec2(WIDTH*0.8, HEIGHT*0.68), colour, building_colour);\n    colour = fill_triangle(pos, vec2(WIDTH*0.6, HEIGHT*0.68), vec2(WIDTH*0.5, HEIGHT*0.8), vec2(WIDTH*0.8, HEIGHT*0.68), colour, shadow_colour);\n    colour = draw_line(pos, vec2(WIDTH*0.2, HEIGHT*0.68), vec2(WIDTH*0.5, HEIGHT*0.8), colour);\n    colour = draw_line(pos, vec2(WIDTH*0.8, HEIGHT*0.68), vec2(WIDTH*0.5, HEIGHT*0.8), colour);\n    colour = draw_line(pos, vec2(WIDTH*0.2, HEIGHT*0.68), vec2(WIDTH*0.8, HEIGHT*0.68), colour);\n    fragColor = vec4(colour, 1.0);\n    float c = get_noise(pos.yx);\n    // fragColor = vec4(vec3(c), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdsfD7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdSfDK", "name": "Zoom vs Scale", "author": "eiffie", "description": "Left side is typical zoom by scaling space. Right side scales Z each iteration. I wish I could think of some use for this to end my description... um, no.", "tags": ["mandelbrot"], "likes": 1, "viewed": 222, "date": "1590826859", "time_retrieved": "2024-06-20T20:08:34.569330", "image_code": "#define rez iResolution.xy\nfloat DE(vec2 z){\n  const int iters=200;\n  float scl=1.0+(0.5+0.5*cos(iTime*0.1))*500000.;\n  if(z.x<0.){z/=scl;scl=1.;}\n  z+=vec2(-.74820292,-.18466048)*scl;\n  vec2 c=z,mc=fract(c)-0.5;\n  float d=step(mc.x*mc.y,0.)*.2+.7;\n  float m=dot(z,z);\n  int n=0; \n  for (n = 0; n < iters && m<4.*scl*scl; n++) {  \n   z=vec2(z.x*z.x-z.y*z.y,2.0*z.x*z.y)/scl+c;\n   m = dot(z,z);\n  }\n  z/=scl;\n  m = dot(z,z);\n  return (float(iters-n)+1.33*log(log(m)))/float(iters);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv=(2.0*fragCoord.xy-rez)/rez.x;\n  float d=DE(2.*uv);\n  fragColor=vec4(d,d,d,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdSfDK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdSfDy", "name": "WorleyNoise3D", "author": "im_sky", "description": "Worley Noise 3D", "tags": ["noise"], "likes": 2, "viewed": 284, "date": "1590684342", "time_retrieved": "2024-06-20T20:08:35.174970", "image_code": "#define PI 3.14159265359\n\nfloat GetIntegerNoise(vec2 p)  // replace this by something better, p is essentially ivec2\n{\n    p  = 53.7 * fract( (p*0.3183099) + vec2(0.71,0.113));\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat Hash(float f)\n{\n    return fract(sin(f)*43758.5453);\n}\n\nfloat Hash21(vec2 v)\n{\n    return Hash(dot(v, vec2(253.14, 453.74)));\n}\n\nfloat Hash31(vec3 v)\n{\n    return Hash(dot(v, vec3(253.14, 453.74, 183.3)));\n}\n\nvec3 Random3D( vec3 p ) {\n    return fract(sin(vec3(dot(p,vec3(127.1,311.7,217.3)),dot(p,vec3(269.5,183.3,431.1)), dot(p,vec3(365.6,749.9,323.7))))*437158.5453);\n}\n\nvec2 Rotate2D(vec2 v, float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    \n    mat2 rotMat = mat2(c,s,-s,c);\n    return rotMat * v;\n}\n\nvec4 GetWorleyNoise3D(vec3 uvw)\n{\n    float noise = 0.0;\n    \n    vec3 p = floor(uvw);\n    vec3 f = fract(uvw);\n    \n    vec4 res = vec4(1.0);\n    for(int x = -1; x <=1; ++x)\n    {\n        for(int y = -1; y <=1; ++y)\n        {\n            for(int z = -1; z <=1; ++z)\n            {\n                vec3 gp = p + vec3(x, y, z);\t//grid point\n\n                vec3 v = Random3D(gp);\n\n\t\t\t\tvec3 diff = gp + v - uvw;\n                \n                float d = length(diff);\n                \n                if(d < res.x)\n                {\n                    res.xyz = vec3(d, res.x, res.y);\n                }\n                else if(d < res.y)\n                {\n                    res.xyz = vec3(res.x, d, res.y);\n                }\n                else if(d < res.z)\n                {\n                    res.z = d;\n                }\n                \n                res.w = Hash31(gp);\n            }\n        }\n    }\n\n    return res;\n}\n\nfloat fBMWorley(vec3 x, float lacunarity, float gain, int numOctaves)\n{\n    float total = 0.0;\n    float frequency = 1.0;\n    float amplitude = 1.0;\n\tfloat totalAmplitude = 0.0;\n    for(int i = 0; i < numOctaves; ++i)\n    {\n        totalAmplitude += amplitude;\n        \n        vec4 n = GetWorleyNoise3D(x * frequency);\n        total += amplitude * n.x;\n        \n        frequency *= lacunarity;\n        amplitude *= gain;\n    }\n    \n    return total/totalAmplitude;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    uv *= 3.0;\n    vec3 uvw = vec3(uv, iTime * 0.1);\n    \n    //uv *= 0.5*(sin(iTime * 2.0) + 5.0) * 2.40;\n\n\tfloat noise = fBMWorley(uvw, 2.0, 0.5, 4);\n    //noise += GetWorleyNoise3D(uvw * 2.0) * 0.5;\n\n    vec3 color = noise * vec3(1.0);\n    fragColor = vec4(1.0 - color, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdSfDy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdSfRc", "name": "Ray Marching - Luke", "author": "ljuektes", "description": "sup its raymarching -- smothmin func", "tags": ["raymarching"], "likes": 2, "viewed": 86, "date": "1590505977", "time_retrieved": "2024-06-20T20:08:35.174970", "image_code": "struct Ray{\n\tvec3 origin;\n    vec3 direction;\n};\n\nstruct Sphere{\n\tvec3 position;\n    float radius;\n    vec3 color;\n    \n};\n    \nstruct RayHit{\n\tfloat dist;\n    vec3 color;\n};\n    \nRay getRay(vec2 uv, vec3 cameraPosition, vec3 lookAt, float zoom){\n\tRay ray;\n    ray.origin = cameraPosition;\n    \n    vec3 front = normalize(lookAt - ray.origin);\n    vec3 right = cross(vec3(0., 1., 0.), front);\n    vec3 up = cross(front, right);\n    vec3 center = ray.origin + front * zoom;\n    vec3 intersectionPointOfScreen = center + uv.x * right + uv.y * up;\n    ray.direction = normalize(intersectionPointOfScreen - ray.origin);\n    return ray;\n}\n\n#define MAX_MARCH_STEPS 128\n#define SURFACE_HIT_DISTANCE 0.004\n#define MAX_DISTANCE_MARCHABLE 1024.\n\n\n\nfloat sdInter(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat sdUnion(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat sdDiff(float distA, float distB) {\n    return max(distA, -distB);\n}\nfloat smoothMin(float da, float db, float k){\n\tfloat h = max(k - abs(da - db), 0.) / k;\n    return min(da, db) - h*h*h*k*1./6.;\n\n}\nfloat sdBox( vec3 p, vec3 pos, vec3 b ){\n    p -= pos;\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nfloat sdHexPrism( vec3 p, vec3 pos, vec2 h ){\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p -= pos;\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r){\n\tvec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot(ap, ab) / dot(ab,ab);\n    t = clamp(t, 0., 1.);\n    vec3 c = a + (t * ab);\n    return length(p -c) - r;\n    \n    \n}\nfloat sdSphere( vec3 point, Sphere sphere ){\n\treturn length(point - sphere.position) - sphere.radius;\n}\n\nfloat sdTorus( vec3 p, vec3 pos, vec2 r ){\n    p -= pos;\n\tfloat x = length(p.xz) - r.x;\n\treturn length(vec2(x, p.y)) - r.y;\n}\nRayHit getMarchDistance(vec3 point){\n    Sphere spheres[4];\n    int i = 0;\n    spheres[i].position = vec3(0., 3., 11.); spheres[i++].radius = 2.;\n    spheres[i].position = vec3(2. * cos(iTime), 3., 11.); spheres[i++].radius = 1.;\n    spheres[i].position = vec3(2. * -cos(iTime), 3., 11.); spheres[i++].radius = 1.;\n    spheres[i].position = vec3(7., 1.25 + 2.*(sin(iTime*1.5f)), 10.); spheres[i++].radius = 1.;\n    \n    const int modelCount = 11;\n    RayHit rayHits[modelCount];\n    rayHits[10].dist = sdHexPrism(point, vec3(-2., 2., 2.), vec2(.5, .25));rayHits[10].color = vec3(1., 1., 0.);\n    rayHits[0].dist = sdSphere(point, spheres[0]);rayHits[0].color = vec3(0., 0., 1.);\n    rayHits[1].dist = sdSphere(point, spheres[1]);rayHits[1].color =  vec3(0., 0., 1.);\n    rayHits[2].dist = sdSphere(point, spheres[2]);rayHits[2].color =  vec3(0., 0., 1.);\n    rayHits[3].dist = sdSphere(point, spheres[3]);rayHits[3].color =  vec3(1., 0., 0.);\n    rayHits[4].dist = sdCapsule(point, vec3(-20., 5. * abs(sin(iTime * 3.)) + 1., 30.), vec3(-15., 5. * abs(cos(iTime * 3.)) + 1., 35.), 1.);\n    rayHits[4].color =  vec3(1., 0., 1.);\n    vec3 moving = vec3(0., 0.5, 3.);\n    vec3 moving2 = vec3(0., 0.5, 3.);\n    moving.xz += vec2(sin(iTime), cos(iTime));\n    moving2.xz -= vec2(sin(iTime), cos(iTime));\n    rayHits[5].dist = sdCapsule(point,vec3(0., 1.5, 3.),moving, .12);rayHits[5].color =  vec3(0., 1., 0.);\n    rayHits[6].dist = sdCapsule(point,vec3(0., 1.5, 3.),moving2, .12);rayHits[6].color =  vec3(0., 1., 0.);\n    rayHits[7].dist = sdTorus(point,  vec3(0., .5, 3.), vec2(1., .5));rayHits[7].color =  vec3(0., 1., 0.);\n    rayHits[8].dist = sdBox(point,  vec3(7., 1., 10.), vec3(1., 1., 1.));rayHits[8].color =  vec3(1., 0., 0.);\n    rayHits[9].dist = point.y;rayHits[9].color =  vec3(1., 1., 1.);\n    float distanceFromPlane = point.y;\n    float capDist = sdCapsule(point, vec3(-10., 1., 10.), vec3(-9.75, 1., 15.), 1.);\n   \n    int minValueIndex = 0;\n    float minValue = rayHits[minValueIndex].dist;\n    RayHit rayHit; rayHit.dist = minValue; rayHit.color = rayHits[minValueIndex].color;\n    for(int k = 0; k < modelCount; k++){\n        float compareValue = rayHits[k].dist;\n        if(compareValue < rayHits[minValueIndex].dist){\n            minValueIndex = k;\n\n        }\n    \t\tminValue = smoothMin(minValue, compareValue, 0.64);\n        \n    }\n\trayHit.color = rayHits[minValueIndex].color;\n    rayHit.dist = minValue;\n    \n    return rayHit;\n}\n\n\n\n\nvec3 getNormal(vec3 point){\n\tvec2 change = vec2(0.01, 0.);\n    RayHit rayHit = getMarchDistance(point);\n    vec3 normal = vec3(rayHit.dist - getMarchDistance(point - change.xyy).dist,rayHit.dist - getMarchDistance(point - change.yxy).dist,\n                       rayHit.dist - getMarchDistance(point - change.yyx).dist);\n    return normalize(normal);\n\n}\n\n\n\nRayHit rayMarch(Ray ray){\n \tRayHit rayHit;rayHit.dist = 0.;\n    for(int i = 0; i < MAX_MARCH_STEPS; i++){\n    \tvec3 pointMarchingFrom = ray.origin + rayHit.dist * ray.direction;\n        RayHit distanceToNextMarch = getMarchDistance(pointMarchingFrom);\n        rayHit.dist += distanceToNextMarch.dist;\n        rayHit.color = distanceToNextMarch.color;\n\n        if(distanceToNextMarch.dist < SURFACE_HIT_DISTANCE || rayHit.dist > MAX_DISTANCE_MARCHABLE) break;\n    \n    }\n    return rayHit;\n    \n}\n    \n\n\nfloat getLight(vec3 point){\n    vec3 lightPosition = vec3(0, 4, -3);lightPosition.xz += vec2(sin(iTime), cos(iTime));\n    vec3 lightVector = normalize(lightPosition - point);\n    vec3 normal = getNormal(point);\n    float dif = clamp(dot(normal, lightVector), 0., 1.);\n    \n    Ray pointToLightRay; pointToLightRay.origin = point + normal * SURFACE_HIT_DISTANCE * 2.; pointToLightRay.direction = normalize(lightPosition - point);\n    float distToLight = rayMarch(pointToLightRay).dist;\n    if(distToLight < length(lightPosition - point)) dif *= 0.05;\n\treturn dif ;\n}\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = getNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = clamp(dot(L, N),0.,1.); \n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) return vec3(0.0, 0.0, 0.0);\n    if (dotRV < 0.0)  return lightIntensity * (k_d * dotLN);\n\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          9.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n\tvec3 resultingColor = vec3(0);\n    \n    Ray cameraRay;\n    vec3 cameraPos = vec3(0., 2.97, -2.);vec3 lookAt = vec3(0., 2.5, 0.); float zoom = 1.;\n    cameraRay = getRay(uv, cameraPos, lookAt, zoom);\n    \n    \n    RayHit rayMarch = rayMarch(cameraRay);\n    \n    vec3 point = cameraRay.origin + (cameraRay.direction * rayMarch.dist);\n    vec3 K_a = vec3(0.05);\n    vec3 K_s = vec3(1., .3, .1);\n    float shininess = 3.;\n    \n    vec3 color = phongIllumination(K_a, rayMarch.color, K_s, shininess, point, cameraRay.origin);\n    float diffuse = getLight(point);\n    \n    resultingColor = vec3(diffuse);\n   //resultingColor = getNormal(point); //for visualizing normals\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdSfRc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdSfRd", "name": "RayMarching Test #1", "author": "ncot_tech", "description": "Raymarching tests following Art of Code YouTube videos.", "tags": ["raymarching"], "likes": 0, "viewed": 138, "date": "1590574655", "time_retrieved": "2024-06-20T20:08:35.987150", "image_code": "// Follows these YouTube Videos\n// https://www.youtube.com/watch?v=PGtv-dBi2wE\n// https://www.youtube.com/watch?v=Ff0jJyyiVyw\n\n// https://sausage-factory.games\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(.5+.5*(b-a)/k, 0., 1.);\n    return mix(b,a,h) - k*h*(1.0-h);\n}\n\nfloat remap(float a, float min1, float max1, float min2, float max2) {\n    return min2 + (max2-min2) * ((a-min1) / (max1-min1));\n}\n\n// angle\nmat2 Rot(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\n// a and b and the end positions, r is radius\nfloat Capsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab,ap) / dot(ab,ab);\n    t = clamp(t,0.,1.);\n    \n    vec3 c = a + t*ab;\n    return length(p-c)-r;\n}\n\n// a is position, r is outer,inner radii\nfloat Torus(vec3 p, vec3 a, vec2 r)\n{\n    p -= a;\n    float x = length(p.xz)-r.x;\n    return length(vec2(x,p.y))-r.y;\n}\n\n// a is pos, s is size\nfloat Box(vec3 p, vec3 a, vec3 s)\n{\n    p -= a;\n    return length(max(abs(p)-s, 0.));\n}\n\n// This is really the scene itself\nfloat GetDist(vec3 p)\n{\n    vec4 s = vec4(0,1,6,1);\t// This is a sphere (x,y,z,radius)\n    \n    float sphereDist = length(p-s.xyz)-s.w;\n    //float planeDist = p.y;\t// Ground plane at 0;\n    \n    float cd = Capsule(p, vec3(0,.5,4), vec3(1,2,6), .2);\n    float td = Torus(p, vec3(0,.5,6), vec2(1.5, .3));\n    float bd = Box(p,vec3(-2,.5, 6),vec3(.5));\n    \n    // This is how you combine them\n    float d = smin(cd, td, .2);\n   // d = min(d, td);\n    d = smin(d, bd, .2);\n    \n    return d;\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd)\n{\n    // Distance from origin\n    float dO = 0.;\n    int steps = 0;\n    float dS = 0.;\n    \n    //for (int i = 0; i < MAX_STEPS; i++) {\n    do {\n        vec3 p = ro + rd * dO;\n        // Distance to scene\n       \tdS = GetDist(p);\n        dO += dS;\n        steps++;\n        //if (dO > MAX_DIST || dS < SURF_DIST) break;\t// Hit\n    } while (steps < MAX_STEPS && dO < MAX_DIST && dS > SURF_DIST);\n    //}\n    float s = remap(float(steps), 0., float(MAX_STEPS), 1.0, 0.);\n    return vec2(dO,s);\n}\n\n// Calculate normal vector for a point\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDist(p);\n    vec2 e = vec2(.01,0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p, vec3 lightPos)\n{\n    lightPos.xz += vec2(sin(iTime), cos(iTime));\t// Rotate around Y\n    \n    vec3 lv = normalize(lightPos-p);\n    vec3 ln = GetNormal(p);\n    \n    float dif = clamp(dot(ln, lv), 0., 1.);\n    \n    // Shadows\n    float d = RayMarch(p+ln*SURF_DIST*2., lv).x;\n    if (d < length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = vec3(0);\n    \n    // \"camera\"\n    vec3 ro = vec3(0,3,0);\t// Ray origin (camera position)\n    vec3 rd = normalize(vec3(uv.x,uv.y-.4,1.1));\t// Ray direction (looking at)\n    \n    // Raymarch the scene\n    vec2 march = RayMarch(ro, rd);\n    vec3 p = ro + rd * march.x;\n    \n    // Calculate the diffuse lighting\n    vec3 lightPos1 = vec3(0, 5, 3);\t// Where light is\n    vec3 lightPos2 = vec3(-.5, -5, 7);\t// Where light is\n    float difLight = GetLight(p, lightPos2) + GetLight(p, lightPos1);\n    difLight = clamp(difLight, 0., 1.);\n    \n    // Shade the scene\n    //col = pal( difLight, vec3(0.7,0.1,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.34,0.33,0.67) ) * march.y;\n    col = vec3(difLight);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdSfRd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdsfRj", "name": "menger-sponge--inverso", "author": "jorge2017a1", "description": "menger-sponge--inverso", "tags": ["mengerspongeinverso"], "likes": 5, "viewed": 88, "date": "1588621434", "time_retrieved": "2024-06-20T20:08:35.987150", "image_code": "//modificado por jorge flores.p --\n//Gracias a ....Created by russ in 2017-03-06\n//https://www.shadertoy.com/view/XsfczB\n    \n\nconst int iter =100;\nconst float eps = 0.001, far = 20.;\nvec3 lDir0 = normalize(vec3(1,2,1)), lDir1 = normalize(vec3(-1,1.0,-2));\nvec3 lCol0 = vec3(1,.8,.5), lCol1 = vec3(.6,0.8,1); \n\n\n#define PI 3.1415926\n\n///-------------------------------------\nconst int MAX_RAY_STEPS = 64;\nconst float RAY_STOP_TRESHOLD = 0.0001;\nconst int MENGER_ITERATIONS = 5;\n///-------------------------------------\n\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3  di = abs(p) - b;\n  float mc = maxcomp(di);\n  return min(mc,length(max(di,0.0)));\n}\n\n\nfloat cylUnion(vec3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(min(xy,min(xz,yz))) - 1.;\n}\n\nfloat cylIntersection(vec3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(max(xy,max(xz,yz))) - 1.;\n}\n\n\n//-------------------------------------------\n\nfloat dsSphere(vec3 center, float r, vec3 point)// basic sphere SDF\n{\n    // point is point pos in space, center is sphere's center, r is its radius\n    return length(point - center) - r;\n}\n\nfloat dsCapsule(vec3 point_a, vec3 point_b, float r, vec3 point_p)//cylinder SDF\n{\n \tvec3 ap = point_p - point_a;\n    vec3 ab = point_b - point_a;\n    float ratio = dot(ap, ab) / dot(ab , ab);\n    ratio = clamp(ratio, 0.0, 1.0);\n    vec3 point_c = point_a + ratio * ab;\n    return length(point_c - point_p) - r;\n}\n\nfloat dsTorus(vec3 center, float r1, float r2, vec3 point)\n{\n \tfloat x = length(point.xz - center.xz) - r1;\n    float y = point.y - center.y;\n    float dist = length(vec2(x,y)) - r2;\n    return dist;\n}\n//--------------------------------------------\n\n//oooooooooooooooooooooooooooooooooooooooooooooooooooo\nfloat sdCross(vec3 p) {\n\tp = abs(p);\n\tvec3 d = vec3(max(p.x, p.y),\n\t\t\t\t  max(p.y, p.z),\n\t\t\t\t  max(p.z, p.x));\n\treturn min(d.x, min(d.y, d.z)) - (1.0 / 3.0);\n}\n\nfloat sdCrossRep(vec3 p) {\n\tvec3 q = mod(p + 1.0, 2.0) - 1.0;\n\treturn sdCross(q);\n}\n\nfloat sdCrossRepScale(vec3 p, float s) {\n\treturn sdCrossRep(p * s) / s;\t\n}\n\n\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\n\n//--------------------------\nfloat DE(vec3 p) {\n\t\n    \n    float scale = 0.35;\n\t\n \n       \n    \n    float dist =sdBox(p- vec3(0.0), vec3(1.0) );\n    \n \n\tfor (int i = 0; i < MENGER_ITERATIONS; i++) {\n\t\tdist = max(dist, sdCrossRepScale(p, scale));\n\t\tscale *= 3.0;\n\t}\n\n\n    \n    \n\treturn dist;\n}\n\n//oooooooooooooooooooooooooooooooooooooooooooooooooooo\n\n\n\nvec2 march(vec3 ro, vec3 rd){\n\tfloat t=0. , d = far, it = 0.;\n    for (int i=0;i<iter;i++){\n     \tt += (d = DE(ro+t*rd));\n        if(d<eps || t> far) break;\n        it += 1.;\n    }\n    return vec2(t,it/float(iter));\n}\n\nfloat getShadow(vec3 p, vec3 n, vec3 ld){\n    p +=  2. * eps * n;\n    float t=0.,d=far;\n    for(int i=0;i<50;i++){\n        t += (d=DE(p + t*ld));\n        if (d<eps || t>3.) break;\n    }\n    return t<=3. ? 0.1 : 1. ;\n}\n\nvec3 getRay(vec3 ro, vec3 look, vec2 uv){\n    vec3 f = normalize(look - ro);\n    vec3 r = normalize(vec3(f.z,0,-f.x));\n    vec3 u = cross (f,r);\n    return normalize(f + uv.x * r + uv.y * u);\n}\n\nvec3 getNorm(vec3 p){\n    vec2 e = vec2(eps, 0);\n    return normalize(vec3(DE(p+e.xyy)-DE(p-e.xyy),DE(p+e.yxy)-DE(p-e.yxy),DE(p+e.yyx)-DE(p-e.yyx)));\n}\n\nvec3 light(vec3 p, vec3 n){\n    vec3 col = vec3(0.01);\n    for(int i=0;i<2;i++){\n        vec3 ld = (i==0) ? lDir0 : lDir1;\n        float diff = max(dot(n, (ld)),0.);\n        diff *= getShadow(p, n, ld);\n        col += diff * (i==0 ? lCol0 : lCol1);\n    }\n    return col * .7;\n}\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) {\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float time = iTime * 0.5;\n    //float time = iTime * .06;\n    \n    \n\tvec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n  \n    \n    \n    //vec3 ro = vec3(0.5, 0.25, 1.5+ 1.0*cos(time)+time*1.2);\n    vec3 ro = vec3(0.5+sin(iTime), 0.25,  1.5*cos(time));\n     //ro = get_mouse(ro);\n   \n    \n    vec3 rd = getRay(ro, vec3(0.), uv);\n    vec2 hit = march(ro, rd);\n    vec3 p = ro + hit.x*rd;\n    \n    vec3 col = hit.x<far ? light(p, getNorm(p)) : vec3(.1*(1.-length(uv)));\n    \n    \n    col += pow(hit.y,3.);\n\tfragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdsfRj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdsfRl", "name": "fading triangles", "author": "eimink", "description": "Fork of https://www.shadertoy.com/view/wtcXWr\nIntentionally dark, work in progress.", "tags": ["darktriangles"], "likes": 10, "viewed": 190, "date": "1588890608", "time_retrieved": "2024-06-20T20:08:36.641748", "image_code": "#define S(a, b, t) smoothstep(a, b, t)\n\nfloat distLine(vec2 p, vec2 a, vec2 b){\n\tvec2 pa = p - a;\n    vec2 ba = b - a;\n    float t = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba*t);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b){\n\tfloat d = distLine(p, a, b);\n    float m = S(0.03, 0.01, d);\n    float d2 =  length(a - b);\n    m *= S(1.4, 0.8, d2) * 0.5 + S(0.05, 0.03, abs(d2 - 0.75));\n    return m;\n}\n\nfloat distTriangle(in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\nfloat triangle(vec2 p, vec2 a, vec2 b, vec2 c){\n\tfloat d = distTriangle(p, a, b, c);\n    float m = S(0.13, 0.01, d);\n    float d2 =  length(a - b);\n    m *= S(1.2, 0.8, d2) * 0.25 + S(0.05, 0.03, abs(d2 - 0.75));\n    return m;\n}\n\nfloat N21(vec2 p){\n\tp = fract(p * vec2(233.34, 851.73));\n    p += dot(p, p + 23.45);\n    return fract(p.x * p.y);\n}\n\nvec2 N22(vec2 p){\n\tfloat n = N21(p);\n    return vec2(n, N21(p + n));\n}\n\nvec2 getPos(vec2 id, vec2 offset){\n    vec2 n = N22(id + offset) * iTime;\n    return offset + sin(n) * 0.4;\n}\n\nfloat layer(vec2 uv){\n\tvec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n\n    vec2 p[9];\n    int i = 0;\n    for(float y = -1.0; y <= 1.0; y++){\n    \tfor(float x = -1.0; x <= 1.0; x++){\n        \tp[i++] = getPos(id, vec2(x, y));\n    \t}    \n    }\n    \n    \n    float t = iTime * 10.0;\n    float m = 0.0;\n    for(int i = 0; i < 9; i++){\n    \tm += line(gv, p[4], p[i]);\n        \n        vec2 j = (p[i] - gv) * 20.0;\n        \n        for(int yi= i + 1; yi < 9; yi++){\n    \t\tfor(int zi= yi + 1; zi < 9; zi++){\n                \n                float len1 = abs(length(p[i] - p[yi]));\n                float len2 = abs(length(p[yi] - p[zi]));\n                float len3 = abs(length(p[i] - p[zi]));\n                \n                if((len1 + len2 + len3) < 2.8){\n                \tm += triangle(gv, p[i], p[yi], p[zi]) * 0.8;\n                }\n    \t\t}\n    \t}\n    }\n    m += line(gv, p[1], p[3]);\n    m += line(gv, p[1], p[5]);\n    m += line(gv, p[7], p[3]);\n    m += line(gv, p[7], p[5]);\n\n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    float m = 0.0;\n    float t = iTime * 0.02;\n    \n    float gradient = min(-uv.y,uv.y) * 0.25;\n    \n    float s = sin(t);\n    float c = cos(t);\n    mat2 rot = mat2(c, -s, s, c);\n    uv *= rot;\n    \n    for(float i = 0.0; i < 1.0; i += 1.0 / 4.0){\n        float z = fract(i + t);\n        float size = mix(10.0, 0.5, z);\n        float fade = S(0.0, 0.5, z) * S(1.0, 0.8, z);\n        \n        m += layer(uv * size + i * 10.0) * fade* 0.35;\n    }\n    \n    \n    vec3 base = vec3(0.845, 0.156, 0.167) * 0.8 + 0.6;\n    vec3 gradc = vec3(0.045, 0.056, 0.967) * 0.8 + 0.6;\n    vec3 col = m * base;\n    \n    col -= gradient * gradc;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdsfRl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdsfRr", "name": "561_Rabbitz_3", "author": "mrabbitz", "description": "Subsurface scattering approximation along with penumbra shadows.", "tags": ["shadows"], "likes": 2, "viewed": 72, "date": "1588801007", "time_retrieved": "2024-06-20T20:08:38.363245", "image_code": "////////////////////////////////////////////////////////////////\n// The larger the DISTORTION, the smaller the glow\nconst float DISTORTION = 0.2;\n// The higher GLOW is, the smaller the glow of the subsurface scattering\nconst float GLOW = 6.0;\n// The higher the BSSRDF_SCALE, the brighter the scattered light\nconst float BSSRDF_SCALE = 3.0;\n// Boost the shadowed areas in the subsurface glow with this\nconst float AMBIENT = 0.0;\n// Toggle this to affect how easily the subsurface glow propagates through an object\n#define ATTENUATION 0\n\n\n// Adjust these to alter where the subsurface glow shines through and how brightly\nconst float AO_DIST = 0.085;\nconst float FIVETAP_K = 2.0;\n\n\nconst int RAY_STEPS = 256;\nvec3 LIGHT_POS = vec3(0.0, 5., -2.0);\n\nstruct Intersection\n{\n    vec3 p;\t\t// point of intersection in world space\n    float t;\t// t-value of ray to p\n    int objHit;\t// assign every object in scene a unique ID integer\n    vec3 color;\t// color of surface\n};\n    \nvec3 rotateX(vec3 p, float a) {\n    return vec3(p.x, cos(a) * p.y - sin(a) * p.z, sin(a) * p.y + cos(a) * p.z);\n}    \n    \n// Takes in direction, rotates it by a radians\n// result of applying a y rotation matrix to the vec3\n// rotates about y-axis\nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n    \n// b consists of width, height, and depth VECTORS (center to edge)\nfloat BoxSDF(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// point, radius, center\nfloat SphereSDF(vec3 p, float r, vec3 c) {\n    return distance(p, c) - r;\n}\n\nfloat PlaneSDF(vec3 p, vec4 n)\n{\n    return dot(p,n.xyz)+n.w;\n}\n\n#define BOX_SDF BoxSDF(pos + vec3(2.5, 0.0, 0.0), vec3(1.0))\n#define SPHERE_SDF SphereSDF(pos, 1., vec3(2.5, 0.0, 0.0))\n#define PLANE_SDF PlaneSDF(pos, vec4(0.0, 1.0, 0.0, 1.0))\n\n#define SUN_SDF SphereSDF(pos, 1., LIGHT_POS - vec3(0.0,1.5,0.0))\n\n#define BOX 0\n#define SPHERE 1\n#define PLANE 2\n\n#define SUN 3\n\nfloat SceneSDF(vec3 pos, vec3 lightPos)\n{\n    float t = BOX_SDF;\n    t = min(t,SPHERE_SDF);\n    t = min(t,PLANE_SDF);\n    //t = min(t,SUN_SDF);\n    return t;\n}\n\nfloat shadowMap3D(vec3 pos)\n{\n    return SceneSDF(pos, vec3(0.0, 0.0, 0.0));\n}\n\nfloat softShadow(vec3 dir, vec3 origin, float min_t, float k)\n{\n    float res = 1.0;\n    float t = min_t;\n    for (int i = 0; i < RAY_STEPS; ++i)\n    {\n        float m = shadowMap3D(origin + t * dir);\n        if(m < 0.0001)\n        {\n            return 0.0;\n        }\n        res = min(res, k * m / t);\n        t += m;\n    }\n    return res;\n}\n\nfloat shadow(vec3 dir, vec3 origin, float min_t)\n{\n    return softShadow(dir, origin, min_t, 6.0);\n}\n\nfloat fiveTapAO(vec3 p, vec3 n, float k)\n{\n    float aoSum = 0.0;\n    for (float i = 0.0; i < 5.0; ++i)\n    {\n        float coeff = 1.0 / pow(2.0, i);\n        aoSum += coeff * (i * AO_DIST - SceneSDF(p + n * i * AO_DIST, vec3(0.)));\n    }\n    return 1.0 - k * aoSum;\n}\n\nfloat subsurface(vec3 lightDir, vec3 normal, vec3 viewVec, float thickness) {\n    vec3 scatteredLightDir = lightDir + normal * DISTORTION;\n    float lightReachingEye = pow(clamp(dot(viewVec, -scatteredLightDir), 0.0, 1.0), GLOW) * BSSRDF_SCALE;\n    float attenuation = 1.0;\n    #if ATTENUATION\n    attenuation = max(0.0, dot(normal, lightDir) + dot(viewVec, -lightDir));\n    #endif\n\tfloat totalLight = attenuation * (lightReachingEye + AMBIENT) * thickness;\n    return totalLight;\n}\n\nvec3 ComputeMaterial(int objHit, vec3 p, vec3 n, vec3 light, vec3 view, float thick)\n{\n    float lambert = dot(n, light) + 0.2;\n    switch(objHit)\n    {\n        case BOX:\n        vec3 color = vec3(1.0, 0.88, 0.7) * vec3(1.0, 0.67, 0.67) * max(0.0, dot(n, light)) * shadow(light, p, 0.1);\n        return color + vec3(1.0, 0.67, 0.67) * subsurface(light, n, view, thick) * vec3(1.0, 0.88, 0.7);\n        break;\n    \tcase SPHERE:\n        vec3 color1 = vec3(1.0, 0.88, 0.7) * vec3(1.0, 0.67, 0.67) * max(0.0, dot(n, light)) * shadow(light, p, 0.1);\n        return color1 + vec3(1.0, 0.67, 0.67) * subsurface(light, n, view, thick) * vec3(1.0, 0.88, 0.7);\n    \tbreak;\n    \tcase PLANE:\n        return vec3(0.0, 0.0, 1.0) * lambert;\n    \tbreak;\n        case SUN:\n        return vec3(10.0);\n    \tbreak;\n\t}\n\treturn vec3(1.0);    \n}\n\nvec3 ComputeNormal(vec3 pos, vec3 lightPos) {\n    vec2 offset = vec2(0.0, 0.001);\n    return normalize( vec3( SceneSDF(pos + offset.yxx, lightPos) - SceneSDF(pos - offset.yxx, lightPos),\n                            SceneSDF(pos + offset.xyx, lightPos) - SceneSDF(pos - offset.xyx, lightPos),\n                            SceneSDF(pos + offset.xxy, lightPos) - SceneSDF(pos - offset.xxy, lightPos)\n                          )\n                    );\n}\n    \nvoid SceneSDF(vec3 pos, out float t, out int objHit, vec3 lightPos)\n{\n    t = BOX_SDF;\n    objHit = BOX;\n    \n    float t2;\n    if((t2 = SPHERE_SDF) < t)\n    {\n        t = t2;\n        objHit = SPHERE;\n    }\n    if((t2 = PLANE_SDF) < t)\n    {\n        t = t2;\n        objHit = PLANE;\n    }\n    if((t2 = SUN_SDF) < t)\n    {\n        t = t2;\n        objHit = SUN;\n    }\n}\n    \nvoid RayMarch(vec3 origin, vec3 dir, out float t, out int objHit, vec3 lightPos)\n{\n    // starts slightly > 0\n    // so that if we march from a different point in the scene that isnt the camera\n    // we dont immediately intersect ourselves\n    t = 0.001;\n    // ray march not to a certain distance but for a certain number of iterations\n    for (int i = 0; i < RAY_STEPS; ++i)\n    {\n        vec3 pos = origin + t * dir;\n        // minimum distance that pos is from all SDFs in the scene\n        float m;\n        SceneSDF(pos, m, objHit, lightPos);\n        if(m < 0.01)\n        {\n            return;\n        }\n        t += m;\n    }\n    // hit nothing\n    t = -1.0;\n    objHit = -1;\n}\n    \nIntersection SceneIntersection(vec3 eye, vec3 dir, vec3 lightPos)\n{\n    float t;\n    int objHit;\n    // Marches along ray to find point of intersection\n    RayMarch(eye, dir, t, objHit, lightPos);\n    \n    vec3 isect = eye + t * dir;\n    vec3 nor = ComputeNormal(isect, lightPos);\n    vec3 lightDir = normalize(lightPos - isect);\n    float thickness = fiveTapAO(isect, -nor, FIVETAP_K);\n    \n    vec3 surfaceColor = ComputeMaterial(objHit, isect, nor, lightDir, normalize(eye - isect), thickness);\n        \n    return Intersection(isect, t, objHit, surfaceColor);\n}\n    \nconst vec3 worldUp = vec3(0,1,0);\nvoid RayCast(vec2 ndc, out vec3 eye, out vec3 dir, out vec3 ref)\n{\n    eye = vec3(0.0, 0.0, 10.0);\n    ref = vec3(0.0, 0.0, 0.0);\n    \n    float len = tan(3.14159 * 0.08) * distance(eye, ref);\n   \n    vec3 H = normalize(cross(worldUp, ref - eye));\n    vec3 V = normalize(cross(H, eye - ref));\n    V *= len;\n    H *= len * iResolution.x / iResolution.y;\n    vec3 p = ref + ndc.x * H + ndc.y * V;\n    dir = normalize(p - eye);\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax)\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<100; i++ )\n    {\n\t\tfloat h = SceneSDF( ro + rd*t , LIGHT_POS);\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, 10.0*d/max(0.0,t-y) );\n        ph = h;\n        \n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.001 + 0.15*float(i)/4.0;\n        float d = SceneSDF( pos + h*nor, LIGHT_POS );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 1.5*occ, 0.0, 1.0 );    \n}\n\n// mainImage: present in every single shader program on shadertoy\n// outputs: the fragment color for the fragment it is operating on\n// takes in: the pixel space coordinates of the fragment it is coloring\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime * 3.14159 * 0.1;\n    LIGHT_POS = rotateY(vec3(0.0, 1.5, 12.), t);\n    \n    // iResolution: width and height of screen in pixels (on bottom toolbar of image output)\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Convert to range -1 to 1 for x and y\n    // Normalized Device Coordinates w.r.t. the center of the screen being (0,0)\n    uv = (uv * 2.0) - vec2(1.0);\n    \n    Intersection aaIsects[4];\n    vec3 eye, dir, ref;\n    int idx = 0;\n    for (float i = 0.0; i < 1.0; i += 0.5)\n    {\n        for (float j = 0.0; j < 1.0; j += 0.5)\n        {\n            RayCast(uv + vec2(i, j) / iResolution.xy, eye, dir, ref);\n            aaIsects[idx++] = SceneIntersection(eye, dir, LIGHT_POS);\n        }\n    }\n                                                                          \n    vec3 avgColor = vec3(0.0);\n    for (int i = 0; i < 4; ++i)\n    {\n        avgColor += aaIsects[i].color;\n    }\n    avgColor *= 0.25;\n    \n    \n    vec3 norm = ComputeNormal(aaIsects[0].p, LIGHT_POS);\n    \n            \tvec3 color = vec3(0.0);\n    \tvec3 baseColor = avgColor;\n        \n    //    https://www.shadertoy.com/view/lsKcDD\n    \n    // key light\n        vec3  lig = normalize(LIGHT_POS - aaIsects[0].p);\n        vec3  hal = normalize( lig-dir );\n        float dif = clamp( dot( norm, lig ), 0.0, 1.0 ) * \n                    calcSoftshadow( aaIsects[0].p, lig, 0.01, 15.0);\n\n\t\tfloat spe = pow( clamp( dot( norm, hal ), 0.0, 1.0 ),16.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,dir),0.0,1.0), 5.0 ));\n\n\t\tcolor = baseColor * 4.0*dif*vec3(1.00,0.70,0.5);\n        color +=      12.0*spe*vec3(1.00,0.70,0.5);\n    \n            // ambient light\n        float occ = calcAO( aaIsects[0].p, norm );\n\t\tfloat amb = clamp( 0.5+0.5*norm.y, 0.0, 1.0 );\n        color += baseColor*amb*occ*vec3(0.0,0.08,0.1);\n    color += baseColor * 0.4;\n    \n    fragColor = vec4(color * step(0.0, aaIsects[0].t), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdsfRr.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdsfRS", "name": "circlegrid02", "author": "paulobarcelos", "description": "circlegrid02", "tags": ["circlegrid02"], "likes": 3, "viewed": 219, "date": "1588542048", "time_retrieved": "2024-06-20T20:08:38.363245", "image_code": "// inspired by https://www.youtube.com/watch?v=cQXAbndD5CQ\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // uv - center and fix aspect ratio\n    vec2 uv = (fragCoord - iResolution.xy * 0.5)/iResolution.y;\n    \n    // uv - rotate 45 deg\n\tfloat a = 0.7853982; // 45 in radians\n    float sa = sin(a);\n    float ca = cos(a);\n    uv *= mat2(ca, -sa, sa, ca);\n    \n    float time = iTime * 2.0;\n    vec3 col = vec3(0);\n    \n    float divisions = 11.0;\n    vec2 gv = fract(uv * divisions) - 0.5;\n    vec2 id = floor(uv * divisions);\n    gv.x *= mod(id.x, 2.0) == 0.0 ? 1.0 : -1.0;\n    gv.y *= mod(id.y, 2.0) == 0.0 ? 1.0 : -1.0;\n    \n    float d = length(gv + vec2(sin(time) * 2.0, cos(time) * 2.0) * 0.25);\n    float radius = 0.5 * (0.1 + sin(time * 0.25 + length(uv) * 3.12) * 0.5 + 0.5);\n    float circle = smoothstep(radius + 0.01, radius - 0.02, d);\n    \n   \n    col = mix(vec3(0.125, 0.874, 0.733), vec3(0.874, 0.125, 0.266), circle);\n    \n  \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdsfRS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdSfRw", "name": "Harmonic dance (142 chars)", "author": "Smake", "description": "effects with  recurrent harmonic functions\n", "tags": ["short", "golf", "meditation", "dynamicpainting"], "likes": 1, "viewed": 74, "date": "1590515057", "time_retrieved": "2024-06-20T20:08:38.363245", "image_code": "void mainImage(out vec4 O, vec2 U)\n{\n   vec4  d; int  a;\n   d.xy = 4.*U/iResolution.xy-2.;\n   for (d.z=5.; a++ < 9;\n    O +=-4.*d*(atan(cos(O.x),cos(O.y))+sin(.03*iTime+18.)));\n   O /=5e1;\n}", "image_inputs": [{"id": "4l2GRK", "previewfilepath": "https://soundcloud.com/naruto_official_page/naruto-shippuden-ost-despair", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/naruto_official_page/naruto-shippuden-ost-despair", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdSfRw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdSfWh", "name": "circuits all the way down", "author": "unnick", "description": "a recreation of [url]https://youtu.be/V4oRHv-Svwc?t=90[/url]", "tags": ["2d"], "likes": 3, "viewed": 205, "date": "1590933917", "time_retrieved": "2024-06-20T20:08:38.363245", "image_code": "#define res iResolution.xy\n#define ires ivec2(res)\n\n#define decaysp vec2(3, 30)\n#define colormat (mat2x3(.5,.6,.2, .9,.95,1) * mat2x2(1,0,-1,1))\n#define op(x,y) x^y\n#define speed 0x625b\n\nint modinv(int a, int m) {\n    int r = 1; int q = 0;\n    for(int i = 0; i < m; i++) {\n        q |= r & (1 << i);\n        r += (-((r >> i) & 1)) & (a << i);\n    }\n    return q;\n}\n\nvoid mainImage(out vec4 color, in vec2 _pos) {\n    int m = int(floor(log2(max(res.x, res.y)))); int s = 1 << m;\n    ivec2 pos = ivec2(_pos) - (ivec2(ires.xy) >> 1);\n    float t = fract(float(((op((pos.x), (pos.y))) * modinv(speed, m) + iFrame) & (s-1)) / float(s));\n    color.rgb = colormat * exp(-t * decaysp);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdSfWh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdSfWV", "name": "Targets on a map", "author": "mightee_cactus", "description": "Practice of using smoothstep and trigonometry.", "tags": ["grid", "dots"], "likes": 0, "viewed": 58, "date": "1590834689", "time_retrieved": "2024-06-20T20:08:38.363245", "image_code": "#define S(a, b, t) smoothstep(a, b, t)\n\nvec2 getGrid(vec2 uv)\n{\n    float freq = 50.;\n    float shiftDown = - 0.9;\n    \n    // module by cos, then shift cos down to narrow the resulting \"line\"\n    vec2 tmp = (cos(uv * freq) + shiftDown);\n    // we'd need to clamp values if we are going to myltiply tmp by itself,\n    // but I just use some random constant to remove the blur\n    //tmp = clamp(tmp, vec2(0.), vec2(1.));\n    tmp *= 10.;\n\treturn S(0., 1., tmp);\n}\n\nvec3 getTargetDot(vec2 uv, float radius)\n{\n    vec2 tmp = sin(uv);\n    float d = clamp(length(tmp), 0., radius);\n    d /= radius;\n    d = S(1., 0., d);\n    \n    return mix(vec3(0.), vec3(0., 6., 0.), d);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    // then move (0,0) to a center\n    // then account for window ratio\n    vec2 uv = fragCoord/iResolution.xy;\n    uv     -= .5;\n    uv.x   *= iResolution.x / iResolution.y;\n\n    vec2 mapSpeed = vec2(iTime * 0.15, iTime) * 0.15;\n    \n    // bg color\n    vec3 col  = vec3(0.066, 0.066, 0.094);\n    \n    // grid\n    vec3 gridColor = vec3(0.176, 0.176, 0.243);\n    vec2 grid = getGrid(uv + mapSpeed);\n    col = mix(col, gridColor, grid.x);\n    col = mix(col, gridColor, grid.y);\n    \n    // dots\n    col += getTargetDot(uv + vec2(0.4, 0.37)+ mapSpeed, 0.05);\n    col += getTargetDot(uv + vec2(0.2, -0.5) + mapSpeed, 0.05);\n    col += getTargetDot(uv + vec2(1.5, 1.) + mapSpeed, 0.05);\n    col += getTargetDot(uv + vec2(-0.5, 0.7) + mapSpeed, 0.05);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdSfWV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdSfzh", "name": "[TWITCH] Monster Things", "author": "evvvvil", "description": "Monster Things - Result of improvised live code session on Twitch\nLIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 21:00 Uk time:\nhttps://www.twitch.tv/evvvvil_", "tags": ["tunnel", "demoscene", "glow", "alien", "organic", "life", "monster", "creature", "disgusting", "spine", "twitch", "horn", "improv"], "likes": 73, "viewed": 3604, "date": "1589474229", "time_retrieved": "2024-06-20T20:08:39.005608", "image_code": "// Monster Things - Result of an improvised live code session on Twitch\n// LIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 21:00 Uk time: https://www.twitch.tv/evvvvil_\n// Thankx to Haptix and canadianCornDog for the suggestions!\n// Music by OddJohn / HANDSOME HOOLIGANS - https://soundcloud.com/oddjohnofficial\n\n// \"Motherfuckers stole my 80s style!\" - Steven Spielberg\n\nvec2 z,v,e=vec2(.01,-.01);float t,tt,g,gg;vec3 sp,tp,ep,op,hp,po,no,ld,al;//Global vars. About as boring as conspiracy theorists conspiring to make conspriacy theories\nfloat smin(float a,float b,float h){float k=clamp((a-b)/h*.5+.5,0.,1.); return mix(a,b,k)-k*(1.-k)*h;} //Add geometries with smooth blend. Yeah this is what Sade talks about in the song \"Smoothhhhhhh Operatooooor\"\nfloat smax(float d1,float d2,float k){float h=clamp(0.5-0.5*(d2+d1)/k,0.,1.);return mix(d2,-d1,h)+k*h*(1.0-h);}//Remove geometries with smooth blend. yeah sorry couldn't make a lamer joke than the one above...\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));}//Rotate function. Short and sweet, just like how Kim Jung Un could be, if he had been given enough attention as a child.\nvec4 texNoise(vec2 uv){ float f = 0.; f+=texture(iChannel0, uv*.125).r*.5; //Rough shadertoy approximation of the bonzomatic noise texture by yx - https://www.shadertoy.com/view/tdlXW4\n    f+=texture(iChannel0,uv*.25).r*.25;f+=texture(iChannel0,uv*.5).r*.125;f+=texture(iChannel0,uv*1.).r*.125;f=pow(f,1.2);return vec4(f*.45+.05);\n}\nvec2 mp( vec3 p )\n{ \n  op=p;//Remember original position in op\n  p.z=mod(p.z+tt*6.,78.)-39.;//Modulo and animate everything else along the z axis\n  tp=p;//Tunnel position is moduloed and animated (line above) but NOT twisted along z axis (next line)    \n  p.xy*=r2(sin(op.z*.2+tt*2.)*.5);//Twist everything else along the z axis and animnate\n  sp=p;//Sp is spine position used everywhere for monster\n  float dis=sin(op.z*.2+tt*1.2)*1.+sin(op.z*.1+tt*.6)*.5; //dis is deformer / displacement along z axis with sin\n  float zf=sin(p.z*15.)*0.03; //zf is z axis frill adding nice details like rib cage and crest\n  float xf=sin(p.x*15.)*0.03; //xf is x axis frill adding nice details on edges etc\n  float tnoi=texNoise(p.yz*.1).r*.8; //tnoi is texture noise displacement by sampling texture and making perlin, adds great curnchy organic details\n  float fft=texture( iChannel1, vec2(min(abs(op.z*.002)*.15,5.),0)).x; //Audio sync along z limited to first 5 fft samples (bass)\n  sp.xy+=dis;//add deformer to spine position\n  vec2 h,t=vec2(length(sp.xy+xf)-(2.-dis+tnoi),5); //make main spline with deformer also influencing the radius not just position + texture displacement\n  t.x=smin(t.x,length(abs(sp.xy+xf)-(1.5-dis))-(.5+tnoi),.5); //Add 4 cylinder to create edges again with deformer and texture displacement\n  t.x=smin(t.x,length(abs(sp.xy+zf)-vec2(0,2.1-dis))-(.5+tnoi),.5);  //CREST made of two cylinder above and bellow with deformer and texture displacement\n  t.x=smax((length(abs(sp.xy+zf)-vec2(2.-dis,0))-(1.-dis+tnoi)),t.x,.3);//RIBS made by carving out 2 cylinders on side and adding x axis frill\n  hp=ep=sp; //horn positions and electricitings position\n  hp.z=mod(hp.z,3.)-1.5; //modulo horn position along z to have loads of them on the crest\n  t.x=smax(length(abs(hp-vec3(0,0,.2))-vec3(0,2.1-dis,0))-(.6+tnoi-dis*.4),t.x,.5); //HOLES FOR HORNS by reusing hp and shifting a bit\n  hp.z-=min(pow(hp.y*.1,2.)*5.,5.);//HORN DEFORMER. Bend them forward menacingly. This could also be said in a BDSM scenario, involving people, also wearing horns.\n  h=vec2(length(hp.xz+xf)-(.5+tnoi-dis*.4-abs(pow(hp.y*.09,2.)*4.)),6);  //HORNS made using hp postion and horn deformer\n  h.x*=0.7; //We gotta increase the definition of horn geometry as they are deformed a lot, this avoids artifact\n  t=t.x<h.x?t:h; //Add horns geometry to the scene while retinaing material id\n  sp.y*=0.5;//EGGS position is reusing spine position but scaled along y to make spheres a taller egg shape\n  sp.z=mod(sp.z,3.)-1.5; //Modulo along z to create many eggs along z axis, it's the same modulo frequency as for the horn position to align holes, horns and eggs. \"Align holes, horns and eggs\" sounds like a very good Peter Greenaway film!\n  h=vec2(length(sp)-(max(.8,1.-dis*.5)),6);  //Make the actual eggs geometry and use displacement variable to change radius\n  g+=0.1/(0.1+h.x*h.x*40.);//Add eggs distance field to red glow variable (added at the end)\n  t=t.x<h.x?t:h;  //Add eggs to the scene\n  for(int i=0;i<2;i++){//ELECTRICITINGS KIFS\n   ep=abs(ep)-2.;//Each iter pull apart by 2 on xyz \n   ep.xy*=r2(-.3); //Rotate bit on XY\n   ep.yz*=r2(.5);  //Rotate more on YZ\n  }\n  h=vec2(length(ep.xz+tnoi*5.),3);  //Make electricitings, please note the lack of radius, -0 in fact so ignored, that is how you get pure LASER. let's be pedantic about these things, this isn't Stepney Green Bingo Hall\n  gg+=0.4/(0.1+h.x*h.x*1.+1.*abs(sin(ep.y*.4-tt*2.)));//Add electricitings distance field to blue glow variable (added at the end)\n  t=t.x<h.x?t:h;  //Add electricitings to scene  \n  h=vec2(length(tp.xy)-27.,6);  //OUTTER CYLINDER FOR TUNNEL\n  tnoi=texNoise(vec2(abs(atan(tp.x,tp.y)),tp.z*.1-76.)*(.07)).r*14.;//REDEFINE texture noise with polar uvs\n  h.x=max(h.x,-(length(tp.xy)-14.+tnoi+fft*3.)); //CUT HOLE IN TUNNEL\n  h.x=smax((length(abs(tp)-vec3(0,15.-fft*2.,0))-(4.+tnoi)),h.x,1.);//HOLES FOR BLUE SPHERES\n  h.x*=0.8; t=t.x<h.x?t:h; //Tweak disitance field to remove artifact and add to the scene\n  h=vec2((length(abs(tp)-vec3(0,15.-fft*2.,0))-(3.+tnoi)),7);//BLUE SPHERES \n  gg+=0.4/(0.1+h.x*h.x*1.+1.*abs(sin(ep.y*.4-tt*2.-.7))); //Add blue spheres distance field to blue glow variable (added right at end)\n  t=t.x<h.x?t:h; //Add blue spheres to scene \n  t.x*=0.6; return t;\n}\nvec2 tr( vec3 ro, vec3 rd) // main trace / raycast / raymarching loop function \n{\n  vec2 h,t= vec2(.1); //Near plane because when it all started the hipsters still lived in Norwich and they only wore tweed.\n  for(int i=0;i<128;i++){ //Main loop de loop \n    h=mp(ro+rd*t.x); //Marching forward like any good fascist army: without any care for culture theft. (get distance to geom)\n    if(h.x<.00001||t.x>120.) break;//Conditional break we hit something or gone too far. Don't let the bastards break you down!\n    t.x+=h.x;t.y=h.y; //Huge step forward and remember material id. Let me hold the bottle of gin while you count the colours.\n  }\n  if(t.x>120.) t.y=0.;//If we've gone too far then we stop, you know, like Alexander The Great did when he realised his wife was sexting some Turkish bloke. (10 points whoever gets the reference)\n  return t;\n}\n#define a(d) clamp(mp(po+no*d).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d).x/d)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )//2 lines above are a = ambient occlusion and s = sub surface scattering\n{\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1); //get UVs, nothing fancy, \n  tt=mod(iTime,62.82);  //Time variable, modulo'ed to avoid ugly artifact. Imagine moduloing your timeline, you would become a cry baby straight after dying a bitter old man. Christ, that's some fucking life you've lived, Steve.\n  v=mix(vec2(3.,8.8),vec2(12.,16.),ceil(cos(tt*.4)));//Reuse the v variable as holder of camera variables\n  vec3 ro=vec3(cos(tt*.4)*7.,sin(tt*.4)*7.,-10.),//Ro=ray origin=camera position We build camera right here broski. Gotta be able to see, to peep through the keyhole.\n  cw=normalize(vec3(0,0,cos(tt*.6)*8.)-ro),cu=normalize(cross(cw,vec3(sin(tt*.3)*.5,1,0))),cv=normalize(cross(cu,cw)), //camera forward, left and up vector.\n  rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),co,fo;//rd=ray direction (where the camera is pointing), co=final color, fo=fog color\n  ld=normalize(vec3(.2,.5,-.3));//ld=light direction\n  co=fo=vec3(.1)-length(uv)*.1;//background is dark with vignette\n  z=tr(ro,rd);t=z.x; //Trace the trace in the loop de loop. Sow those fucking ray seeds and reap them fucking pixels.\n  if(z.y>0.){ //Yeah we hit something, unlike you trying to throw a spear at a pig. We wouldnt have survive the ice age with you and your nerdy mates.\n    po=ro+rd*t; //Get ray pos, know where you at, be where you is.\n    no=normalize(e.xyy*mp(po+e.xyy).x+e.yyx*mp(po+e.yyx).x+e.yxy*mp(po+e.yxy).x+e.xxx*mp(po+e.xxx).x); //Make some fucking normals. You do the maths while I count how many brain cells I lost during my mid 2000s raving haydays.\n    al=mix(vec3(.4,.5,.6),vec3(.6,.3,.2),.5+.5*sin(tp.z*.3-1.5));//albedo is base colour by default it's greyish to redish gradient\n    if(z.y<5.) al=vec3(0); //material system if less than 5 make it black\n    if(z.y>5.) al=vec3(1); //material system if more than 5 make it white\n    if(z.y>6.)al=vec3(.1,.2,.4);//Material Id more than 6 makes it blue\n    float dif=max(0.,dot(no,ld)), //Dumb as fuck diffuse lighting\n    fr=pow(1.+dot(no,rd),4.), //Fr=fresnel which adds background reflections on edges to composite geometry better\n    sp=pow(max(dot(reflect(-ld,no),-rd),0.),50.);//Sp=specular, stolen from shane\n    co=mix(sp+al*(a(.1)*a(.3)+.2)*(vec3(.5,.2,.1)*dif+s(.5)*1.5),fo,min(fr,.5));//Building the final lighting result, compressing the fuck outta everything above into an RGB shit sandwich\n    co=mix(fo,co,exp(-.00007*t*t*t)); //Fog soften things, but it won't stop your annoying uncle from thinking \"Bloody fiddling with bloody numbers, ain't gonna get you a job, son. Real graft is what ye need, wee man.\"(last sentence read with Scottish accent if you can)\n  }\n  fragColor = vec4(pow(co+g*.2*vec3(.5,.2,.1)+gg*.1*vec3(.1,.2,.4),vec3(.55)),1); //Add glow at the end. g & gg are red and blue glow global variables containg distance fields see lines 42,50,58\n}", "image_inputs": [{"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}, {"id": "Xlj3zy", "previewfilepath": "https://soundcloud.com/jonathan-colonieu/monster-things", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/jonathan-colonieu/monster-things", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdSfzh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdXBD2", "name": "4 Dimensional Modelling", "author": "blackle", "description": "various objects that can be made by applying a handful of operations to a 4 dimensional vector before passing it into a 4 dimensional cube.", "tags": ["4d"], "likes": 11, "viewed": 326, "date": "1589098187", "time_retrieved": "2024-06-20T20:08:39.690628", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nint INSTRUCTIONS;\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\n//this is a multiplication by the quaternion (.5, .5, .5, .5)\n//somehow this results in a good rotation\nvec4 rot4d(vec4 b) {\n    return vec4(dot(b,vec4(1)), b.yzw + b.zwy - b.wyz - b.xxx)*0.5;\n}\n\nfloat super(vec4 p) {\n    return sqrt(length(p*p));\n}\n\nfloat box(vec4 p, vec4 d) {\n    vec4 q = abs(p)-d;\n    return super(max(q,0.))+min(0.,max(max(q.x,q.w),max(q.y,q.z)));\n}\n\nvec4 smin(vec4 a, vec4 b, float k) {\n    vec4 h = max(vec4(0),-abs(a-b)+k)/k;\n    return min(a,b)-h*h*h*k/6.;\n}\n\nfloat scene(vec3 p) {\n    int inst = INSTRUCTIONS;\n    int off = inst % 3; inst /= 3;\n    vec4 pp = vec4(p,vec3(1.,0.5,0.)[off]);\n    for (int i = 0; i < 6; i++) {\n    \tint op = inst % 3; inst /= 2;\n        if (op == 0) pp = sqrt(pp*pp+0.001); //smooth abs\n        if (op == 1) pp = rot4d(pp); //fixed 4d rotation\n        if (op == 2) pp.x -= 0.25; //offset\n    }\n    pp = smin(pp,rot4d(pp),0.1);\n    float b1 = box(pp,vec4(1.))-0.1;\n    return b1;\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvec3 srgb(float r, float g, float b) {\n    return vec3(r*r,g*g,b*b);\n}\n\nfloat bayer(vec2 uv) {\n    return texelFetch(iChannel0,ivec2(uv)%8,0).x/128.;\n}\n\nint hash(int x) {\n    x += 45758;\n    for (int i = 0; i < 16; i++) {\n    \tx ^= x << 13;\n\t\tx ^= x >> 7;\n\t\tx ^= x << 17;\n    }\n    return x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    INSTRUCTIONS = hash(int(iTime));\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 cam = normalize(vec3(1.2,uv));\n    vec3 samplepos = erot(vec3(-10,0,0), vec3(0,0,1), iTime*.2);\n    float radius = 10.-scene(samplepos);\n    vec3 init = vec3(-radius-4.,0,0);\n    \n    float yrot = 0.5;\n    float zrot = iTime*.2;\n    if (iMouse.z > 0.) {\n        yrot += -4.*mouse.y;\n        zrot = 4.*mouse.x;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    init = erot(init, vec3(0,0,1), zrot);\n    \n    vec3 p = init;\n    bool hit = false;\n    for (int i = 0; i < 250 && !hit; i++) {\n        float dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p+=dist*cam;\n        if (distance(p,init)>50.) break;\n    }\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n    float ss = smoothstep(-.1,.1,scene(p+vec3(.1)));\n    float ao = smoothstep(-.1,.1,scene(p+n*.1));\n    float diff = mix(length(sin(n*3.5)*0.5+0.5)/sqrt(3.),ss,.3)*ao*1.5;\n    float spec = length(sin(r*3.)*0.5+0.5)/sqrt(3.);\n    float frens = 1.-pow(dot(cam,n),2.)*0.98;\n    vec3 col = mix(srgb(0.05,0.01,0.),srgb(0.45,0.6,0.8), diff) + pow(spec,5.)*frens;\n    vec3 bg = vec3(smoothstep(1.5,0.,length(uv))*.1);\n    fragColor.xyz = (hit ? col : bg) + bayer(fragCoord);\n    fragColor.xyz = sqrt(fragColor.xyz);\n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc0-1.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdXBD2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdXBWj", "name": "coincoin", "author": "zener", "description": "My first raymarcher (thx to Iq)", "tags": ["raymarcher"], "likes": 5, "viewed": 77, "date": "1589061468", "time_retrieved": "2024-06-20T20:08:39.696724", "image_code": "\n// sorry, it's a little quick & dirty, just a wink for a friend ;-)\n\n// originaly made using bonzomatic, so define fGlobalTime\n#define fGlobalTime\tiTime\n\n\nfloat smin(float a,float b,float k)\n{\n  // found on internet from Iq I presume\n  float h=max(k-abs(a-b),0.);\n  return min(a,b)-h*h/(k*4.);\n}\n\nfloat sdSphere(vec3 p,float r)\n{\n    return length(p)-r;\n}\n\nfloat sdEllipse(vec3 p,vec3 r)\n{\n  float h=length(p/r);\n  float n=length(p/r/r);\n  return h*(h-1.)/n;  \n}\n\nvec2 scene(vec3 p)\n{\n    float matNum=0.;\n\n    float d,h;\n   \n    p.x+=sin(fGlobalTime*3.1415926/4.);\n    p.z+=fract(fGlobalTime/100.)*100.;\n  \n    float rng1=4.;\n    float idx=floor((p.x+rng1/2.)/rng1)*rng1;\n    float idz=floor((p.z+rng1/2.)/rng1)*rng1;\n    p.xz=fract((p.xz+rng1/2.)/rng1)*rng1-rng1/2.;\n\n    // coincoin\n\n    vec3 pBeforeRot=p;\n    float a=fGlobalTime*3.+idx*12.+idz*42.; // this will cut\n    float sina=sin(a);\n    float cosa=cos(a);\n\n  \n    // rotate coin\n    p.xz*=mat2(cosa,-sina,sina,cosa);\n\n  \n    // head\n    h=sdSphere(p-vec3(0.,0.,0.),0.15);\n    matNum=3.;\n\n     //body\n    d=sdEllipse(p-vec3(-.2,-.3,0.),vec3(.4,.2,.3));\n    h=smin(h,d,0.1);\n    \n    d=sdEllipse(p-vec3(-.5,-.15,0.),vec3(.05,.1,.08));\n    h=smin(h,d,0.1);\n \n    // bec\n    vec3 p2=p-vec3(.15,.05,0.);\n    d=sdEllipse(p2-vec3(.0,p2.x/4.,0.),vec3(.1,.03,.08));\n    if(d<h)\n    {\n      matNum=4.;\n    }\n    h=smin(h,d,.01);\n    \n    p2=p-vec3(.15,0.,0.);\n    d=sdEllipse(p2-vec3(.0,-p2.x/4.,0.),vec3(.1,.03,.08));\n    if(d<h)\n    {\n      matNum=4.;\n    }\n\n    h=smin(h,d,.01);\n  \n    // eyes : just color\n    // white\n    p2=vec3(p.x,p.y,abs(p.z))-vec3(.16-p.y/1.5,.1,.05);\n    d=sdEllipse(p2,vec3(.02,.04,.03));\n    if(d<h)\n    {\n      matNum=5.;\n    }\n    // black\n    p2=vec3(p.x,p.y,abs(p.z))-vec3(.16-p.y/1.5,.1,.05);\n    d=sdEllipse(p2,vec3(.02,.04,.03)*0.7);\n    if(d<h)\n    {\n      matNum=6.;\n    }\n\n    p=pBeforeRot;\n    \n    // floor\n    float dfl=p.y+0.4;\n    float hole=sdEllipse(p-vec3(0.,0.2,0.),vec3(2.,1.,2.));\n    dfl=max(dfl,-hole);\n    dfl=min(dfl,p.y+0.47+0.01*sin(length(p.xz)*20.0-(fract(fGlobalTime/100.0)*100.)*10.));\n    \n    if(dfl<h)\n    {\n        h=dfl;\n        matNum=1.; // floor\n        if(length(vec2(p.x,p.z))<(1.5+0.*sin(p.z*10.)/8.))\n        {\n          matNum=2.;\n        }\n    }\n    \n    \n    return vec2(h,matNum);\n}\n\n\nvec2 raym(vec3 ro,vec3 rd)\n{\n  float t=0.0;\n  float matNum=-1.;\n  for(int i=0;i<100;i++)\n  {\n    vec3 p=ro+t*rd;\n    \n    vec2 hm=scene(p);\n    matNum=hm.y;\n    if(hm.x<0.0001)  break;\n    t+=hm.x;\n    if(t>20.)\n    {\n      matNum=-1.;\n      break;    \n    }\n  }\n    return vec2(t,matNum);\n}\n\n\nvec3 norm(vec3 p)\n{\n    vec2 e=vec2(0.0001,0.);\n    return normalize(vec3(scene(p+e.xyy).x-scene(p-e.xyy).x,\n                          scene(p+e.yxy).x-scene(p-e.yxy).x,\n                          scene(p+e.yyx).x-scene(p-e.yyx).x));\n}\n\nfloat shadow(vec3 ro,vec3 rd)\n{\n  float res=1.;\n  \n  float t=0.01;\n  for(int i=0;i<100;i++)\n  {\n    vec3 p=ro+t*rd;\n    \n    float h=scene(p).x;\n\n    res=min(res,8.*h/t);\n    \n    if(h<0.00001) break;\n    t+=h;\n    if(t>20.) break;\n    \n  }\n    return res;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  uv*=2.;\n  \n  \n  vec3 col=vec3(0.1,0.2,0.5);\n\n  col=mix(col,vec3(0.2),1.-uv.y);\n  \n  \n  vec3 ro=vec3(0.,0.,-1);\n  vec3 rd=normalize(vec3(uv.x,uv.y,0.)-ro);\n    \n  \n  vec3 sunDir=normalize(vec3(1.,1.,0.));\n  vec3 sunCol=vec3(4.,4.,1.);\n  vec3 bounceDir=normalize(vec3(0.,-1.,0.));\n  \n  vec3 mate1=vec3(.01,.2,.01); // ground\n  vec3 mate2=vec3(.01,.05,.5); // ground2\n  vec3 mate3=vec3(.4,.4,.01); // body\n  vec3 mate4=vec3(.4,.1,.01); // bec\n  vec3 mate5=vec3(1.); // eye white\n  vec3 mate6=vec3(.01); // eye black\n\n  \n  vec2 tm=raym(ro,rd);\n  float t=tm.x;\n  float matNum=tm.y;\n  if(matNum>0.)\n  {\n      vec3 p=ro+t*rd;    \n      vec3 nor=norm(p);\n\n      vec3 newCol=col;\n    \n      float sunDif=clamp(dot(nor,sunDir),0.,1.);\n      float sunSha=clamp(shadow(p+nor*0.002,sunDir),0.,1.);\n\n      float bounceDif=clamp(dot(nor,bounceDir),0.,1.);\n    \n      vec3 curMate=vec3(0.);\n    \n      if(matNum<1.5) // floor 1\n        curMate=mate1;\n      else if(matNum<2.5) // floor 2\n        curMate=mate2;\n      else if(matNum<3.5) // body\n        curMate=mate3;\n      else if(matNum<4.5) // bec\n        curMate=mate4;\n      else if(matNum<5.5) // eye wh\n        curMate=mate5;\n      else if(matNum<6.5) // eye bl\n        curMate=mate6;\n      \n\n      newCol=curMate*sunCol*sunDif*sunSha;\n      newCol+=curMate*bounceDif*0.2;\n      \n      \n      col=mix(newCol,col,clamp(t/20.,0.,1.));\n  }\n  \n  \n  \n    col=pow(col,vec3(.4));\n \n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdXBWj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdXBzl", "name": "value noise - 234 chars", "author": "FabriceNeyret2", "description": "re-golfing 277 chars [url]https://shadertoy.com/view/MlsXDr[/url]", "tags": ["2d", "noise", "perlin", "2tweets", "short"], "likes": 5, "viewed": 310, "date": "1588853375", "time_retrieved": "2024-06-20T20:08:39.696724", "image_code": "// re-golfing 277 chars https://shadertoy.com/view/MlsXDr\n// ( quadrilin version of Perlin noise with marble modifier. See more there. )\n\n\n// -14 by xor \n\nvoid mainImage(out vec4 O, vec2 I)   \n{\n    for(float s = 1.;s<9.;s+=s)\n    {\n        vec4 m = (I/iResolution.y*8.-vec2(7,4)).xyxy*s, c;\n        m -= c = floor(m);  m.xy = 1.-m.xy; m *= m*(3.-m-m);\n        O += dot(m*m.yzwx,fract(sin(vec4(0,1,158,157) + c.x+157.*c.y)*57.))/s;\n    }\n\tO = sin(O/.1+iTime);\n} /*\n\n\n\n\n// +18 now that the #define mainimage is no longer allowed\n\n\n\n\n// -11 by coyote\n\n#define h fract( 57.*sin( vec2(0,157) + dot( u*s-r, vec2(1,157) )//\nvoid mainImage(out vec4 O, vec2 U) {\n    for(vec2 m,r, u = 8.*U/iResolution.y-vec2(7,4), s=vec2(1);\n        s.x<16.; s+=s )\n          r = m = fract(u*s),\n          m *= m*(3.-m-m),\n          r  = mix( h)), h+1.)), m.x )/s,\n          O += mix(r.xx,r,m).y ;\n    O = sin(O/.1+iTime);\n} /*\n\n\n\n\n\n\n// --- 244 chars\n\n#define h(n) fract( sin( n+vec2(0,157) ) *57. )   //\n#define mainImage(O,U)                             \\\n    vec2 m,r, u = 8.*U/iResolution.y-vec2(7,4);    \\\n    for(float l,s=1.; s<16.; s+=s )                \\\n          m = fract(u*s),                          \\\n          l = dot( u*s-m, vec2(1,157) ),           \\\n          m *= m*(3.-m-m),                         \\\n          r  = mix( h(l), h(++l), m.x ),           \\\n          O += mix(r.xx,r,m).y /s ;                \\\n    O = sin(O/.1+iTime)                           /*\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdXBzl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdXBzs", "name": "[TWITCH] Friday Giro Fever", "author": "evvvvil", "description": "Friday Giro Fever - Result of improvised live code session on Twitch\nLIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 21:00 Uk time:\nhttps://www.twitch.tv/evvvvil_", "tags": ["demoscene", "abstract", "glow", "reflections", "rotation", "gyroscope", "circular", "spaceship", "gyro", "structure", "industrial", "twitch", "improv"], "likes": 28, "viewed": 705, "date": "1588873891", "time_retrieved": "2024-06-20T20:08:40.411897", "image_code": "// Friday Giro Fever - Result of an improvised live code session on Twitch\n// LIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 21:00 Uk time:\n// https://www.twitch.tv/evvvvil_\n\n// \"Being on the dole doesn't have to be dull.\" - William Shakespeare\n\nvec2 z,v,e=vec2(.05,-.05);float t,tt,spo,g,gg;vec3 np,bp,pp,cp,po,no,al,ld;//global vars. About as boring as being stuck in lockdown with your wife and kids.\nfloat cy(vec3 p,vec3 r){return max(abs(length(p.xz)-r.x)-r.y,abs(p.y)-r.z/2.);} //my own primitive function which I didn't steal from IQ. Not bad for an ageing bitter skateboarder. It makes a hollow tube\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));}//rotate function. Short and sweet, just like Napoleon before his megalomaniac fit.\nvec2 fb( vec3 p,float s,float m) // fb \"fucking bit\" function make a base geometry which we use to make gyro and flying objects\n{\n  for(int i=0;i<4;i++){//bullshit kifs rotation cloner. \"Friday Giro Fever\" is a reference to the UK umemployment benefits, the \"giro\". It usually lands on friday, meaning there is always a party for everyone, every friday, in England.\n    p=abs(p);//People against unemployment benefit are heartless like people annoyed at my humourous comments are boring\n    p.xy*=r2(.48);//clone along xy axis with rotation\n    p.yz*=r2(s*sin(p.z*.5)*.3);//this tweaks the gyro into much different shape for flying objects\n  }\n  vec2 h,t=vec2(cy(p,vec3(2,.3,.4)),m);//Make thin hollow tube either yellow or blue \n  h=vec2(cy(p,vec3(2,.1,.6)),6); //Make white hollow tube\n  t=t.x<h.x?t:h; //Make toobs touch boobs! (blend geometry together while retaining nipple colour, I mean material ID)\n  h=vec2(cy(p,vec3(2.,.4,.2)),3); //Make black hollow tube\n  t=t.x<h.x?t:h; //Make toobs touch boobs! (blend geometry together while retaining nipple colour, I mean material ID)\n  return t;\n}\nvec2 road( vec3 p) //Road is yellow circular bit in middle. Nah it doesn't lead to Rome, it leads to an industrial estate in Birmingham. What? You got something against burnt cars and the smell of petrol?\n{ \n  vec2 h,t=vec2(cy(p,vec3(6,.5,1)),8);//Use my fancy fucking hollow tube primitive function, I know some clever bastard probably thought about it before but this is me we're talking about: I once got into an argument with the neighbour's dog and lost.\n  h=vec2(cy(p,vec3(6,.5,5)),3);//Make another hollow toob, this time black and...\n  h.x=abs(h.x)-.1;//...whip that fucker into shape, push it against the edges, and other sexual innuendos...\n  h.x=max(h.x,abs(p.y)-.6); //croperoo the fuckeroo and whatch it groove\n  t=t.x<h.x?t:h; //Make toobs touch boobs! (blend geometry together while retaining nipple colour, I mean material ID)\n  t.x=max(t.x,-(abs(p.z)-.3)); //remove middle bit, otherwise it's full circle and so this way you can see it rotate more. Simple and easy like daddy in mommy\n  h=vec2(cy(p,vec3(6.9,0,.1)),6); //One more hollow tube this time around the whole shit, make it glow, so it's nice a central focal point to the composition (look at me talking like I actually know what I'm doing... fucking hipster)\n  g+=0.1/(0.1+h.x*h.x*100.);//Glow trick by Balkhan, which I tend to rinse and use as a party trick.\n  t=t.x<h.x?t:h; //Make toobs touch boobs! (blend geometry together while retaining nipple colour, I mean material ID)\n  return t;\n}\nvec2 mp( vec3 p )\n{ \n  bp=np=cp=pp=p; //GYROBULLSHIT starts here\n  bp.xy*=r2(tt); //We make two positions bp and np, one rotate clockwise the other anti-clockwise\n  np.xy*=r2(-tt); //None of those positions are either right or wrong in terms of movements direction, get out of your hemisphere-centric bubble, Steve.\n  vec2 h,t=fb(bp*.6,0.,5.); //Make first gyro bit and spin the fucker\n  t.x/=0.6; //Since we scale the pos we must tweak domain into shape to avoid artifact\n  t.x=max(t.x,-(abs(p.z)-.3)); //remove middle bit of outter gyro\n  h=fb(np,0.,5.); //Make another fucking gyro and make it spin\n  t=t.x<h.x?t:h;  //Mege both spinning gyros, bit like \"Mr Speaker\" trying to order the parliament with both parties spinning out of control around their own lame centre of political gravity\n  h=fb(bp*1.7,0.,5.);h.x/=1.7;t=t.x<h.x?t:h; //Yeah yeah one more gyro, blah blah blah, something about distance fucking fields, man I'm so borded when is football restarting, being a geek is cool, but hooliganism is more rewarding.\n  h=vec2(length(p)-.4);//Dumb fucking sphere in middle, make it glow, call the Tate Modern, tell them about my struggle as a child in our anonymous post-post-modern society and give me the Turner Prize.\n  g+=0.1/(0.1+h.x*h.x*40.);t=t.x<h.x?t:h;//Make said dumb sphere glow, call Tate Modern again, explain I wasn't myself when I sent \"that\" email and and it's all due to Donald Trump's rage at China. Collect Turner Prize.\n  h=vec2(length(p.xz+sin(p.y*20.)*.03)-(2.-cos(p.y*.15)*2.3));//Middle pointy erections. What? Yeah broh they are errected, so they are erections... You need to get laid more ma broski.\n  h.x*=0.7; t=t.x<h.x?t:h; //Add those middle pointy erections... Mind where you sit.\n  h=road(p);t=t.x<h.x?t:h; //Whole road thingy is added here.  \n  pp.xz*=r2(tt);//Objects flying around, there is actually a sick position trick in there\n  pp.xy=abs(pp.xy);//Rotate first, then abs symetry on xy axis\n  pp+=vec3(cos(-3.+sin(tt))*6.,-2.,sin(-3.+sin(tt))*6.); //push position along circle\n  pp.xz*=r2(sin(tt));//Rotate the fucking whole thing back and forth\n  h=fb(pp*3.5,3.,7.);//And that's how we get satisfying pandular action. Please note \"satisfying pandular action\" is also what wives want.\n  h.x*=0.15;  t=t.x<h.x?t:h;//since we scaled position, tweak back domain\n  h=vec2(length(pp)-.2);//Blue glow sphere inside flying objects\n  gg+=0.2/(0.1+h.x*h.x*(50.-sin(pp.z*.5+tt*2.)*48.)); //Make it glow and collect some Italia'90 football cards for your meak effort\n  t=t.x<h.x?t:h; //Merge geom together, retain material ID \n  h=fb(p*.165,3.,7.); //Big outter shell is made of flying object body\n  h.x*=3.0; t=t.x<h.x?t:h; //Scaled position means tweak domain. Should have gone to Stockton to become a tweaker when i had the opportunity back in 2010.\n  h=vec2(length(p.xy)-.2+abs(p.z*.02)); //Long white line, usually taken on fridays, through a straw, while talking about how great a drummer Zach Hill really is.\n  g+=0.2/(0.1+h.x*h.x*(50.-sin(pp.z*.2+tt*2.)*45.)); //Glow the fat white line along z axis, I know, I know, it is inviting. Who doesn't like to buy a gram of fun and chat shit to their friends?\n  t=t.x<h.x?t:h;//Merge it all, get into rehab and become a \"hero\" for saving your own skin.\n  return t; //I'm done commenting this and can go back to pointing menacingly at the neighbour's dog\n}\nvec2 tr( vec3 ro, vec3 rd,float _max,int iter) // main trace / raycast / raymarching loop function \n{\n  vec2 h,t= vec2(.1); //Near plane because when it all started the hipsters still lived in Norwich and they only wore tweed.\n  for(int i=0;i<iter;i++){ //Main loop de loop \n    h=mp(ro+rd*t.x); //Marching forward like any good fascist army: without any care for culture theft. (get distance to geom)\n    if(h.x<.00001||t.x>_max) break;//Conditional break we hit something or gone too far. Don't let the bastards break you down!\n    t.x+=h.x;t.y=h.y; //Huge step forward and remember material id. Let me hold the bottle of gin while you count the colours.\n  }\n  if(t.x>_max) t.y=0.;//If we've gone too far then we stop, you know, like Alexander The Great did when he realised his wife was sexting some Turkish bloke. (10 points whoever gets the reference)\n  return t;\n}\n// Rough shadertoy approximation of the bonzomatic noise texture by yx - https://www.shadertoy.com/view/tdlXW4\nvec4 texNoise(vec2 uv){ float f = 0.; f+=texture(iChannel0, uv*.125).r*.5;\n    f+=texture(iChannel0,uv*.25).r*.25;f+=texture(iChannel0,uv*.5).r*.125;\n    f+=texture(iChannel0,uv*1.).r*.125;f=pow(f,1.2);return vec4(f*.45+.05);\n}\n#define a(d) clamp(mp(po+no*d).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d).x/d)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )//2 lines above are a = ambient occlusion and s = sub surface scattering\n{\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1); //get UVs, nothing fancy, \n  tt=mod(iTime,62.82);  //Time variable, modulo'ed to avoid ugly artifact. Imagine moduloing your timeline, you would become a cry baby straight after dying a bitter old man. Christ, that's some fucking life you've lived, Steve.\n  v=mix(vec2(3.,8.8),vec2(12.,16.),ceil(cos(tt*.4)));//Reuse the v variable as holder of camera variables\n  vec3 ro=mix(vec3(1),vec3(-1,-.8,-1),ceil(sin(tt*.4)))*vec3(cos(tt*.2)*v.y,v.x+sin(tt*.4)*2.,sin(tt*.2)*v.y),//Ro=ray origin=camera position We build camera right here broski. Gotta be able to see, to peep through the keyhole.\n  cw=normalize(vec3(0)-ro),cu=normalize(cross(cw,vec3(0,1,0))),cv=normalize(cross(cu,cw)), //camera forward, left and up vector.\n  rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),co,fo;//rd=ray direction (where the camera is pointing), co=final color, fo=fog color\n  ld=normalize(vec3(.2,.5,-.1)); //ld=light direction\n  co=fo=vec3(.09)-length(uv*.8)*.107;//background is dark with vignette\n  z=tr(ro,rd,50.,128);t=z.x; //Trace the trace in the loop de loop. Sow those fucking ray seeds and reap them fucking pixels.\n  if(z.y>0.){ //Yeah we hit something, unlike you trying to throw a spear at a pig. We wouldnt have survive the ice age with you and your nerdy mates.\n    po=ro+rd*t; //Get ray pos, know where you at, be where you is.\n    no=normalize(e.xyy*mp(po+e.xyy).x+e.yyx*mp(po+e.yyx).x+e.yxy*mp(po+e.yxy).x+e.xxx*mp(po+e.xxx).x); //Make some fucking normals. You do the maths while I count how many instances of Holly Willoughby there really is.\n    spo=20.+20.*exp2(10.*texNoise(vec2(bp.z,dot(bp.xy,vec2(.7)))*.3).r);//spo is specular power and refraction index\n    al=vec3(1.,.5,0);//albedo is base colour by default it's yellow \n    if(z.y<5.) spo=40.,al=vec3(0); //material system if less than 5 make it black, with specular power 40 and no reflections\n    if(z.y>5.) spo=40.,al=vec3(1); //material system if more than 5 make it white, with specular power 40 and no reflections\n    if(z.y>6.) al=mix(vec3(.1,.2,.4),vec3(.1,.35,.6),sin(cp*.5)*.5+.5); //Material Id more than 6 makes it blue / green gradient\n    if(z.y>7.) al=vec3(1.,.5,0),spo=20.+20.*exp2(10.*texNoise(vec2(cp.z,dot(cp.xy,vec2(.7)))*.3).r); //Material ID more than 7 makes it yellow and we re adapt the specular power and refraction index\n    float dif=max(0.,dot(no,ld)), //Dumb as fuck diffuse lighting\n    fr=pow(1.+dot(no,rd),4.), //Fr=fresnel which adds background reflections on edges to composite geometry better\n    sp=pow(max(dot(reflect(-ld,no),-rd),0.),spo);//Sp=specular, stolen from shane\n    co=mix(sp+mix(vec3(.8),vec3(1.),abs(rd))*al*(a(.1)*a(.2)+.2)*(dif+s(13.)),fo,min(fr,0.2));//Building the final lighting result, compressing the fuck outta everything above into an RGB shit sandwich\n    if(z.y>7.||z.y==5.){ //If material id is 5 or more than 7 then we do reflections\n      rd=refract(rd,-no,1.-(spo*.0005));//reflect rd with refraction\n      z=tr(po+rd*0.01,rd,50.,80); //Throw another ray from surface, shift ray start position a bit and shoot\n      if(z.y>0.){ //If we hit something in reflection ray... (optimization and cleanup this)\n        po=po+rd*z.x; //Get where we at\n        no=no=normalize(e.xyy*mp(po+e.xyy).x+e.yyx*mp(po+e.yyx).x+e.yxy*mp(po+e.yxy).x+e.xxx*mp(po+e.xxx).x);//More broing normals calculations\n        al=vec3(1.,.5,0);//Gotta give it the material id thing so we know how to colour what\n        if(z.y<5.) al=vec3(0);//ya ya give it back the colours\n        if(z.y>5.) al=vec3(1);//Still pretty boring shit\n        if(z.y>6.) al=vec3(.1,.2,.4);//Did you know Louis Theroux had interviewed Tiger King before he went to prison?\n        if(z.y>7.) al=vec3(1.,.5,0); \n        float dif=max(0.,dot(no,ld));\n        co=co+(dif*al*fr);\n      }\n    }\n    co=mix(fo,co,exp(-.0001*t*t*t)); //Fog soften things, but it won't stop your mother from being unimpressed by your current girlfriend\n  } \n  fragColor = vec4(pow(co+g*.2+gg*.3*vec3(.0,.1,.7),vec3(.45)),1);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdXBzs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdXfDj", "name": "circles and waves", "author": "szczuro", "description": "3 circles on a grid make nice wave pattern,\nI added some colours and rotation animation to make it look better.", "tags": ["circles", "grid", "wave", "pattern"], "likes": 3, "viewed": 53, "date": "1589231081", "time_retrieved": "2024-06-20T20:08:40.787549", "image_code": "// simple helper to smoothstep\nfloat vsmooth(float c, float s, float val ) {\n    float v = s/2.;\n    return smoothstep(c-v,c+v,val);\n}\n\n// draw circle\nfloat circle(vec2 uv, float r, float thick, float fuz) {\n    float len = length(uv);\n    float b = thick/2.;\n   \treturn vsmooth(r-b,-fuz,len) + vsmooth(r+b,fuz,len);\n}\n\n// rotate uv in time \nvec2 uv_rotator(vec2 uv, float time) {\n    float a = sin(time*.02);\n    float s = 1.*sin(a);\n    float c = 2.*cos(a+.3);\n    // rotation\n    uv*= mat2(c, -s,s,c);\n    // offset\n    uv +=vec2(s,s)-vec2(c,c);\n    return uv;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime*2.;\n\n    vec2 uv_g = 4.*(fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv_g += length(uv_g-vec2(.5))/20.; // little disortion\n    uv_g =uv_rotator(uv_g,t); // uv rotation\n   \n    vec2 uv1 = fract(uv_g); // cell uv\n    vec2 uv2 = 1. - uv1;\n    vec2 uvc = fract(uv_g + .5);\n        \n    // prepare parameters\n    float fuz = .03;\n    float thick = sin(t * .2 / 1.) / 15. + .15;\n        \n    // waves patterns\n    float r = .5;\n    float wave1 = circle(uv1, r, thick, fuz);\n    float wave2 = circle(uv2, r, thick, fuz);\n    \n    // circle pattern\n    r /= 2.;\n    float c = circle(uvc - .5, r, thick, fuz);\n    \n    // whole pattern    \n    float p = (1. - wave1) + (1. - wave2) + (1. - c);\n    \n    // preapre color\n    float contrast = cos(t * .1) * .07 + uv_g.x*.02;\n    //contrast = clamp(contrast,-.1,.1);\n    p *= contrast;\n    float G = sin(t * .21) * .05 + .1;\n    float R = cos(t * .3) * .03 + .1;\n    \n    // mix\n    vec3 rgb = vec3(R - p * .2-.1, G, .5) + p ;\n    //vec3 col = vec3(rgb + p);\n\n    fragColor = vec4(rgb, 1.0); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdXfDj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdXfDM", "name": "Boner Style Skinning 2D", "author": "spalmer", "description": "a frag-shader-only 2D version of the skinning/boning technique I used long LONG ago.\nWill it cooperate with distance fields?  I think it will!\n", "tags": ["animation", "skinning"], "likes": 12, "viewed": 201, "date": "1588515154", "time_retrieved": "2024-06-20T20:08:42.587765", "image_code": "// Similar to my OLD method for skinned skeletal mesh animation.\n// Was used on Demise (Wizardry/Bard'sTale clone you never heard of)\n// I called it \"Boner\" for laughs.\n// Was helpful for the artists to rig their models really easily in 3DS MAX.\n// \"Boner II\" got used on a few Tony Hawk ports back in the Dreamcast era.\n// This is the same general idea, but only 2D and not using meshes at all,\n// but rather simple pill SDFs, noise, and textures.\n// As an example of skinned animation, it's truly simple,\n// and has quite a few limitations when used in production.\n// But it certainly can do the trick!\n\nconst int njoints = 4;\n\n// parent joint of joint - can try alternative hierarchies\nint[njoints] poseConnect = int[njoints] (\n    -1, 0, 1, 2 //1, -1, 1, 2 //1, 2, -1, 2 //1, 2, 3, -1 //\n    );\n\nvec2[njoints] poseRest = vec2[njoints] (\n    vec2(-1,0), vec2(-.33,0), vec2(.33,0), vec2(1,0)\n    );\nvec2[njoints] poseCurr;\n// the scheme results in having to index by the *child* joint index everywhere.\n// parent/child is a rather arbitrary distinction, could simply call \"other\".\n// in any case, the directionality should be consistent, either way.\n\nvoid InitPoseCurr()\n{\n  #if 0\n\tvec2[njoints] poseAnim = vec2[njoints] (\n    \tvec2(-.6,.3), vec2(-.4,-.3), vec2(.4,-.3), vec2(.6,.3)\n    );\n    for (int i = njoints; i-- > 0; ) {\n        poseCurr[i].x = mix(poseRest[i], poseAnim[i], abs(sin(iTime*.2))).x;\n        poseCurr[i].y = mix(poseRest[i], poseAnim[i],     sin(iTime*.2) ).y;\n    }\n  #else\n    float animangle = .7*sin(iTime*.2);\n    if (iMouse.z > 1.) animangle = ((iMouse.y * 2.) / iResolution.y - 1.) * 1.25;\n    vec2 cs = sin(vec2(1.57,0) + animangle);\n    mat2 R = mat2(cs.x, -cs.y, cs.y, cs.x), r = mat2(1);\n    poseCurr[0] = poseRest[0] + vec2(0, 1.4*cs.y);\n    for (int i = 1; i < njoints; ++i)\n        poseCurr[i] = poseCurr[i-1] + (r = r * R) * (poseRest[i] - poseRest[i-1]);\n  #endif\n}\n\n// distance to line segment ab from p\nfloat dseg(vec2 p, vec2 a, vec2 b)\n{\n    p -= a; b -= a;\n    return length(p - b*clamp(dot(p,b) / max(1e-3,dot(b,b)), 0., 1.));\n}\n\nfloat tnoise(vec2 p)\n{\n    return texture(iChannel1, p).x * 2. - 1.;\n}\n\nfloat dshape(vec2 p)\n{\n    float dcap = dseg(p, vec2(-1,0), vec2(1,0));\n    dcap -= .25;\n    dcap += tnoise(p*32./iChannelResolution[1].y) * .03;\n    return dcap;\n}\n\nmat2 bone(int j, vec2[njoints] pose)\n{\n    return mat2(pose[max(0, poseConnect[j])], pose[j]);\n}\n\nmat2 inv(mat2 m)\n{\n  #if 1\n    // scaling m rows then transposing seems identical to inverse, as expected\n    m[0] /= dot(m[0],m[0]);\n    m[1] /= dot(m[1],m[1]);\n    mat2 i = transpose(m);\n  #else\n    // in other words, I'm pretty sure it's *not* the inverse implementation, after all.\n    mat2 i = inverse(m);\n  #endif\n    return i;\n}\n\nmat2 joint2world(mat2 bon)\n{\n   vec2 a = bon[0]\n      , b = bon[1]\n    , r = b - a;\n    if (dot(r,r) < 1e-7) r = vec2(1,0); // bugfix: avoid divide by zero!\n    vec2 d = normalize(r);\n    return mat2(r, vec2(-d.y, d.x));\n}\n\nvec2 worldToJoint(vec2 p, int j, vec2[njoints] pose)\n{\n\tmat2 b = bone(j, pose); // the two relevant segment points of the joint\n    mat2 j2w = joint2world(b);\n    return inv(j2w) * (p - b[0]);\n}\n\nvec2 jointToWorld(vec2 p, int j, vec2[njoints] pose)\n{\n\tmat2 b = bone(j, pose); // the two relevant segment points of the joint\n    mat2 j2w = joint2world(b);\n    return j2w * p + b[0];\n}\n\nconst float jointpoof = .01;\n\n// I was using custom meshes for the bones\n// but iq's sdRoundCone would be quite appropriate here\nfloat djoint(vec2 q, int i, vec2[njoints] pose)\n{\n    return dseg(q, pose[i], pose[max(0, poseConnect[i])]) - jointpoof;\n}\n\nfloat dAllJoints(vec2 q)\n{\n    float d = 3.4e38;\n    for (int i = njoints; i-- > 0; )\n        d = min(d, djoint(q, i, poseCurr));\n    return d;\n}\n\nvoid drawArrow(inout vec3 c, vec2 q, vec2 d, vec3 tint, float w)\n{\n    float s = dseg(q, vec2(0), d) - w;\n    float cov = clamp(.5 - .5*iResolution.y * s, 0., 1.);\n    c = mix(c, tint, cov);\n}\n\nvoid drawTripod(inout vec3 c, vec2 q, mat3x2 m)\n{\n    q -= m[2]; float w = 1.5/iResolution.y;\n    drawArrow(c, q, m[0], vec3(1,0,0), w);\n    drawArrow(c, q, m[1], vec3(0,1,0), w);\n//    drawArrow(c, q-m[0], m[1], vec3(0,0,1), w);\n}\n\n// how many bone weights to consider per pixel\nconst int nclosest = 2;\n\n// can adjust weighting falloff; helps isolate the bone influences.\nfloat hackw(float d, float d0)\n{\n     return pow(max(0., d), 2.); //max(0., d); //\n}\n    //d - d0; //d; // // HACK bring closest in to zero distance for weighting calcs\n\n// refactored merely to simplify closestJoints logic\nvoid insertCloser(int i, float d0, inout int[nclosest] n, inout float[nclosest] d)\n{\n\tfor (int j = 0; j < nclosest; ++j) {\n\t   \tif (d0 < d[j]\n\t\t || (d0 == d[j] && n[j] > i) // ties go to the smaller index\n\t\t//|| (d0 == 0. && d[j] == 0. && poseConnect[i] <= j)\n\t\t) {\n\t\t\tfor (int k = nclosest-1; --k >= j; ) { // insert, shift down\n\t\t\t\td[k+1] = d[k];\n\t\t\t\tn[k+1] = n[k];\n\t\t\t}\n\t\t\tn[j] = i; // insert\n\t\t\td[j] = d0;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n// track closest joints for weighting\nvoid closestJoints(vec2 q\n     , out   int[nclosest] n\n     , out float[nclosest] d\n     , out float[nclosest] w)\n{    \n    for (int j = nclosest; j-- > 0; ) {\n        n[j] = 0;\n        d[j] = 3.4e38;\n    }\n\t// for each animated joint,\n    for (int i = njoints; i-- > 0; ) {\n\t    // compute distance to pixel\n    \tfloat d0 =\n            poseConnect[i] < 0 \n            ? 3.4e38\n            : djoint(q, i, poseCurr);\n        d0 = max(d0, 0.);\n        insertCloser(i, d0, n, d);\n    }\n    for (int j = nclosest; j-- > 0; )\n        d[j] = max(0., d[j]); // seg poofed, can be negative\n    float t = 0.; // total distances for weighting\n    for (int j = nclosest; j-- > 0; )\n        t += hackw(d[j], d[0]);\n    t = max(t, 1e-3);\n    for (int j = nclosest; j-- > 0; ) {\n        w[j] = clamp((t - hackw(d[j], d[0])) / t, 0., 1.);\n    }\n    // TODO I may need to take bone relative angle vs. rest pose angle\n    // into account for the weighting to handle the scaling issues.\n // simply normalize the weights wrt one again, and handle special case of failure\n    float wtotal = 0.;\n    for (int j = nclosest; j-- > 0; )\n        wtotal += w[j];\n    if (wtotal == 0.)\n        w[0] = 1.;\n    else\n    for (int j = nclosest; j-- > 0; )\n        w[j] /= wtotal;\n}\n\nvec2 mapToRestPose(vec2 q\n     ,   int[nclosest] n\n     , float[nclosest] w)\n{\n    // trying to sum weighted position in rest pose from nearest joints\n    vec2 c = vec2(0);\n    for (int ci = nclosest; ci-- > 0; ) {\n        int i = n[ci];\n    \tvec2 l = worldToJoint(q, i, poseCurr);\n        c += jointToWorld(l, i, poseRest) * w[ci];\n    }\n    return c;\n}\n\n\nvec3 jointColor(int j)\n{\n    return max(vec3(0), cos(10.2*float(j) + vec3(0,2,4)));\n}\n\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    vec2 r = iResolution.xy\n    , q = (p + p - r) / r.y;\n    q *= 1.25; // zoom so animation doesn't move offscreen HACK\n    vec3 c = .5 + .5*cos(iTime+q.xyx+vec3(0,2,4));\n    InitPoseCurr();\n\tfloat da = dAllJoints(q);\n\n      int[nclosest] n;\n    float[nclosest] d;\n    float[nclosest] w;\n    closestJoints(q, n, d, w);\n    vec2 qrest = mapToRestPose(q, n, w);\n    float cov = .5 - .5/32.*iResolution.y*dshape(qrest);\n    cov = clamp(cov, 0., 1.);\n  //  cov = pow(cov, 16.); // reshape curve of alpha falloff?\n        \n    vec3 tex = texture(iChannel0, qrest * 2.).rgb;\n    tex = pow(tex, vec3(2.2)); // from sRGB gamma\n   #if 0 // DEBUG visualize the weights, falloff\n    tex = vec3(0); for (int i = 0; i < nclosest; ++i) tex += cov*w[i]/float(nclosest) * jointColor(n[i]);\n   #endif\n    c = mix(c, tex, cov); //c *= cov; //\n   #if 1 // debug - draw all joints, and/or their coordinate frames\n    float danim = fract((sin(iTime*.2)*.5 + .5) * 3.);\n    if (iMouse.z <= 0.)\n    for (int i = 0; i < njoints; ++i) {\n        if (poseConnect[i] < 0) continue;\n\t\tmat2 b = bone(i, poseCurr); // the two relevant segment points of the joint\n   \t\tmat2 j2w = joint2world(b);\n        if (false || danim > .5 && danim < .7)\n        drawTripod(c, q, mat3x2(j2w[0], j2w[1], b[0]));\n    \t// outline the bone shape capsules\n        if (false || danim > .1 && danim < .4)\n        c += exp2(-iResolution.y*2.*abs(da - 0.*jointpoof)); // in white\n    //    c *= 1.-exp2(-iResolution.y*1.*abs(da - 0.*jointpoof)); // in black\n    }\n   #endif\n    c = pow(c, vec3(.4545)); // to sRGBish gamma\n    o = vec4(c, 1);\n}\n\n\n#if 0 // a lot of debugging crap when I was working on the weighting\n   #if 0 // HACK only keep closest bone, so I can debug that\n    for (int j = 1; j < nclosest; ++j) d[j] = 9e9;\n   #endif\n    // FIXME weighting borked; if only use closest bone,\n    // full weighting, it looks as expected.\n    // they should all add up to 1.0\n  #if 0 // HACK force nearest two both to .5, rest to 0.\n    // actually seems very similar to what I've been seeing,\n    // so I expect this is what's happening, that \n    // it's being averaged out so they all incorrectly get influence always\n    for (int j = 2; j < nclosest; ++j)\n        w[j] = 0.;\n    w[0] = w[1] = .5;\n  #elif 0 // HACK force nearest to 1., rest to 0.\n    for (int j = 1; j < nclosest; ++j)\n        w[j] = 0.;\n    w[0] = 1.;\n  #elif 0 // even MOAR HACK - either 100,100,0 or 100,0,0\n    // at least it doesn't appear discontiguous!\n    // or at least it didn't!  but now is.  :(\n    for (int j = 1; j < nclosest; ++j)\n        w[j] = 0.;\n\tif (d[0] - d[1] > -.001)    \n\t    w[0] = w[1] = 1.;\n    else\n        w[0] = 1.;\n  #elif 0 // MOAR HACK - either 80,80,0, or 100,0,0\n    for (int j = 1; j < nclosest; ++j)\n        w[j] = 0.;\n\tif (d[0] - d[1] > -.001)    \n\t    w[0] = w[1] = .6;\n    else\n        w[0] = 1.;\n  #elif 0 // HACK either 50/50 or 100% - does not work as expected, for sure.  :(\n    for (int j = 1; j < nclosest; ++j)\n        w[j] = 0.;\n\tif (d[0] - d[1] > -.001)    \n\t    w[0] = w[1] = .5;\n    else\n        w[0] = 1.;\n  #elif 0 // HACK any nonzero weight is set to 100%,\n    // because 100% is the only mapping that works.\n    // However, this approach does not work.  :(\n    for (int j = 0; j < nclosest; ++j)\n  \t\tif (w[j] > 0.) w[j] = 1.;  \n  #endif\n#endif\n\n", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdXfDM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdXfR2", "name": "Journey to ?", "author": "Maxice", "description": "gyroid test based on art of code youtube video", "tags": ["gyroid"], "likes": 1, "viewed": 60, "date": "1588620903", "time_retrieved": "2024-06-20T20:08:42.587765", "image_code": "///////////Gyroid based on art of code tut\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\nfloat t,g=0.;\n\nmat2 rot (float a)\n\t{return mat2(cos(a),sin(a),-sin(a),cos(a));} \n\nfloat\tgyroid (vec3 p,float s){\n    \tp *=s;\n    \tfloat d = abs(dot (sin(p*0.9),cos(p.zxy*1.02))+1.7+(sin(t*.3)*.2))/(s*2.)-.03;\n    \treturn d;\n    }\n\n\nfloat sdf(vec3 p) {\n    p.xy *= rot (p.z*.35);\n\tp.z +=t*.5;\t\t\t\t\t\t//move forward\n   \tfloat d1 = gyroid(p,8.);\t\n \tg += 0.1/(0.1+d1*d1*114.);\t\t//add glow \n \treturn d1;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = sdf(p);\n        dO += dS*0.8;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tt = mod(iTime,400.);\t\t\t//stop time getting to big\n    vec3 col = vec3(0.);\n  \n    vec3 ro = vec3(.2, 0.1, -3.);\n    vec3 rd = normalize(vec3(uv.x, uv.y, (sin(t*.66)+1.)*.4)+.2);\n\n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d;\n    float fog = length (ro-p);\n  \n    col =clamp (vec3(1.-p.z,p.y*.6,p.z+2.),0.,1.);\n    col = mix(col,vec3(.1,.12,.3),1.-exp(-0.06*fog*fog));  //fog col\n    col += g*.008*(p.z+2.);\t\t//add glow more glow in dist\t\t\n    col = pow( col, vec3(0.4545) );\t\t//gamma\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdXfR2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdXfRs", "name": "Day 107 ( 666 chars )", "author": "FabriceNeyret2", "description": "simplifying bufA of \"Day 107\"  by jeyko ( 1480 chars ). [url]https://shadertoy.com/view/3dByR1[/url]", "tags": ["mograph", "motiongraphics"], "likes": 8, "viewed": 258, "date": "1588851872", "time_retrieved": "2024-06-20T20:08:42.587765", "image_code": "// simplifying bufA:\"Day 107\" ( 1480 chars )  by jeyko. https://shadertoy.com/view/3dByR1\n\n// Ease from https://necessarydisorder.wordpress.com/\nfloat E(float p) {\n    return   p < 0.  ? 0.\n           : p > .5  ? 1.\n           : p > .25 ? p = 1.-p-p , 1. - 2.*p*p\n           :           8.*p*p; \n}\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, p,\n         U = ( u - .5*R ) / R.y;\n\n    float t = mod(iTime*.8, 3.5), r=1.57, x = U.x, z,m, i = 0.,\n          A = E(t), B = E(t-1.), C = E(t-2.),\n          b = r + .1*(A-C);\n    \n    U *= mat2( cos( r*( A+C + vec4(0,-1,1,0) ) ))\n      * ( 1. - dot(U,U)*.05 );   \n    U.x += .2* (A -B-B + C);\n    \n  //vec3 p = vec3(U,1) / dot(U,U);   \n    z = dot(U,U); p = U/z;\n    p.x -= sin( r* (A -B-B -C) ) *5.9;\n    \n    for(; i < 20.; i++) {\n        p *= m = (2. - i/20. ) / clamp( dot(p,p), .1, 20. );\n        z /= m;\n        p = abs( mod(p.yx - b, b+b)  - b );\n        if(i == 2.) p.x -= 1.1 + ( B+C - pow(A,.6)*2. ) /4.; \n    }\n    \n    t *= 1.8;\n#define S(v) smoothstep(0.,.5/R.y, .0015 - length(v*z) )\n    O =   S( p.x ) * vec4(1.9,.9,.6,0)   \n        + S( min(p.y, p.x) )\n          * pow( abs( sin( ( U.x + sin( (U.y-U.x)/.1 - t) ) /1.8) ), 6.)\n          * max( 2.* sin( vec4(8,8,5,0) + sin(x + t) ) , 0. );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdXfRs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WdXfW7", "name": "[TWITCH] Isometric Cages", "author": "Flopine", "description": "My first isometric doodle with raymarching! It's so much fun :D \nDid it during a live session on twitch you can re-watch here: https://www.twitch.tv/flopine", "tags": ["raymarching", "isometric", "twitch", "orthographicprojection"], "likes": 11, "viewed": 238, "date": "1588327945", "time_retrieved": "2024-06-20T20:08:43.260468", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n\n// References used for this isometric shader:\n// https://en.wikipedia.org/wiki/Isometric_projection\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/orthographic-projection-matrix\n\n#define PI 3.141592\n#define TAU (2.*PI)\n#define time iTime\n\nfloat stmin (float a, float b, float k, float n)\n{\n    float st = k/n;\n    float u = b-k;\n    return min(min(a,b), 0.5*(u+a+abs(mod(u-a+st,2.*st)-st)));\n}\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nvoid mo (inout vec2 p, vec2 d)\n{\n    p= abs(p)-d;\n    if (p.y>p.x) p = p.yx;\n}\n\nfloat sc(vec3 p, float s) \n{\n    vec3 pp = p;\n    p = abs(p);\n    p = max(p, p.yzx);\n    float d = min(p.x, min(p.y, p.z)) - s;\n    return d;\n    return max(d,-(abs(pp.x)-0.2));\n}\n\nfloat od (vec3 p, float d)\n{return dot(p,normalize(sign(p)))-d;}\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0.,max(q.x,max(q.y,q.z))) + length(max(q,0.));\n}\n\nfloat g1=0.;\nfloat SDF (vec3 p)\n{\n    float dt = ((2.*PI)/4.)*(floor(time) + (pow(fract(time)+1., 6.)-1.)*exp(-15.*fract(time)));\n    p.yz *= rot(-atan(1./sqrt(2.)));\n    p.xz *= rot(TAU/8.);\n\n    float per = 10.;\n    p.xz = mod(p.xz, per)-per*.5;\n    mo(p.xz, vec2(1.5, 2.));\n    p.x -= 1.;\n    mo(p.yz, vec2(1.));\n    p.z += 1.;\n    mo(p.xy, vec2(0.8));\n    p.x -= 0.5;\n    p.xz += vec2(cos(dt),sin(dt));\n    float d = od(p,0.5);\n    g1 += 0.01/(0.01+d*d);\n    return stmin(od(p, 0.5),max(-sc(p,0.85),box (p, vec3(1.))), 0.5, 4.);\n}\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2 (0.001,0.);\n    return normalize(SDF(p)-vec3(SDF(p-eps.xyy),SDF(p-eps.yxy),SDF(p-eps.yyx)));\n}\n\nvec3 rm (inout bool hit, inout vec3 p, vec3 ro, vec3 rd)\n{\n    vec3 col = vec3(0.); \n    float shad=0., d=0.;\n\n    for (float i=0.; i<64.; i++)\n    {\n        d = SDF(p);\n        if (d<0.001)\n        {\n            hit = true;\n            shad = i/64.;\n            break;\n        }\n        p += d*rd;\n    }\n    if (hit)\n    {\n        col = vec3(0.4,0.5,0.6);\n        col *= (1.-shad);\n    }\n    return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    bool hit =  false;\n    \n\t// Isometric definition of camera, thanks to moringox! <3\n    vec3 ro = vec3(uv*10.,-50.),\n        rd = normalize(vec3(0.,0.,1.)),\n        p = ro;\n    vec3 col = rm(hit,p,ro,rd);\n    vec3 n = getnorm(p);\n    \n    if (hit)\n    {\n        p += 0.01*n;\n        float fre = pow(clamp(dot(-rd,n),0.,1.),2.);\n        col += rm(hit,p,ro,reflect(rd,n))*fre;\n    }\n    col += g1*vec3(0.8,0.1,0.01)*0.05;\n\n    fragColor = vec4(clamp(sqrt(col),0.,1.),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WdXfW7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wdXfWS", "name": "Adam Bomb", "author": "yasuo", "description": "reference images:https://thehundreds.com/products/adam-bomb-puzzle?variant=31914407297098", "tags": ["reproduction"], "likes": 9, "viewed": 280, "date": "1588952867", "time_retrieved": "2024-06-20T20:08:44.339354", "image_code": "#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n\n// https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nvec3 lineTex(vec2 uv)\n{\n    float stripeSize = 50.0;\n    float t = iTime*10.0;\n    return vec3(tan((uv.x+uv.y+(-t/stripeSize))*stripeSize)*stripeSize,tan((uv.x+uv.y+(-t/stripeSize))*stripeSize)*stripeSize,tan((uv.x+uv.y+(-t/stripeSize))*stripeSize)*stripeSize);\n}\n\nvec3 bom(vec2 p, vec3 col){\n    vec2 prevP = p;\n    col = mix(col,vec3(0.0),S( length(p)-0.25,0.0)); // bg\n    \n    p.x*=0.95;\n    col = mix(col,vec3(0.0),S( length(p-vec2(0.0,0.27))-0.07,0.0));\n    \n\tp = prevP;\n    float d = abs(length(p)-0.25)-0.005;\n    \n    vec2 p2 = p-vec2(0.0,0.3);\n    p2.y*=1.7;\n    \n    d = max(-sdBox(p-vec2(0.0,0.25),vec2(0.07,0.05)),d);\n    \n    float d2 = abs(length(p2)-0.07)-0.006;\n    d = min(d,d2);\n    \n    vec2 p3 = p-vec2(0.0,0.25);\n    float d3 = abs(sdBox(p3,vec2(0.07,0.05)))-0.006;\n    d3 = max(-(length(p2)-0.07),d3);\n    d = min(d,d3);\n    \n    vec2 p4 = p-vec2(0.0,0.2);\n    p4.y*=1.7;\n    float d4 = abs(length(p4)-0.07)-0.006;\n    d4 = max((p4.y),d4);\n    d = min(d,d4);\n    d = max(-(length(p4)-0.065),d);\n    \n    vec2 p5 = p-vec2(0.02,0.03);\n    p5*=Rot(radians(-20.0));\n    p5.x*=2.0;\n    \n    float d5 = length(p5)-0.07;\n    d = min(d,d5);\n    \n    vec2 p6 = p-vec2(0.013,0.05);\n    p6*=Rot(radians(-20.0));\n    p6.x*=3.0;\n    p6.y*=1.8;\n    \n    float d6 = length(p6)-0.07;\n    d = max(-d6,d);\n    \n    vec2 p7 = p-vec2(0.12,0.09);\n    p7*=Rot(radians(-20.0));\n    p7.x*=2.0;\n    p7.y*=1.1;\n    \n    float d7 = length(p7)-0.07;\n    d = min(d,d7);\n    \n    vec2 p8 = p-vec2(0.115,0.105);\n    p8*=Rot(radians(-20.0));\n    p8.x*=3.2;\n    p8.y*=2.0;\n    \n    float d8 = length(p8)-0.07;\n    d = max(-d8,d);\n    \n    float d9 = length(p)-0.22;\n    p.y*=0.8;\n    float d10 = length(p)-0.2;\n    d9 = max(-d10,d9);\n    d9 = max(p.x,d9);\n    p = prevP;\n    \n    float d11 = sdBox((p-vec2(0.0,0.15))*Rot(radians(-20.0)),vec2(0.3,0.015));\n    d9 = max(-d11,d9);\n    \n    d = min(d,d9);\n\n    vec2 p9 = p-vec2(0.1,-0.14);\n    p9*=Rot(radians(-40.0));\n    p9.y*=2.0;\n    float d12 = length(p9)-0.08;\n    \n    vec2 p10 = p-vec2(0.16,-0.17);\n    p10*=Rot(radians(0.0));\n    p10.x*=2.0;\n    float d13 = length(p10)-0.08;\n    d12 = max(-d13,d12);\n    \n    d = min(d,d12);\n    \n    vec2 p11 = p-vec2(-0.04,0.2);\n    float d14 = sdBox(p11,vec2(0.007,0.028));\n    d = min(d,d14);\n        \n    vec2 p12 = p-vec2(-0.04,0.255);\n    float d15 = sdBox(p12,vec2(0.007,0.011));\n    d = min(d,d15);\n    \n    \n    col = mix(col,vec3(1.0),S(d,0.0));\n    \n    \n    vec2 p13 = p-vec2(0.0,0.37);\n    const float k = 3.0;\n    float c = cos(k*p13.y);\n    float s = sin(k*p13.y);\n    mat2  m = mat2(c,-s,s,c);\n    \n    \n    d = sdBox((p13*m)*Rot(radians(10.0)),vec2(0.022,0.07));\n    col = mix(col,lineTex(p),S(d,0.0));\n    \n    return col;\n}\n\nvec3 fire(vec2 p, vec3 col) {\n    vec2 prevP = p;\n    float d = sdTriangle(p,vec2(0.0,0.2),vec2(0.1,-0.2),vec2(-0.1,-0.2));\n    \n    p.x = abs(p.x);\n    vec2 p2 = (p-vec2(0.15,-0.1));\n    p2*=Rot(radians(45.0));\n    \n    float d2 = sdTriangle(p2,vec2(0.0,0.15),vec2(0.1,-0.1),vec2(-0.1,-0.1));\n    d = min(d,d2);\n    \n    p2 = (p-vec2(0.15,-0.2));\n    p2*=Rot(radians(100.0));\n    d2 = sdTriangle(p2,vec2(0.0,0.3),vec2(0.06,-0.1),vec2(-0.06,-0.1));\n    d = min(d,d2);\n    \n    p2 = (p-vec2(0.15,-0.25));\n    p2*=Rot(radians(110.0));\n    d2 = sdTriangle(p2,vec2(0.0,0.1),vec2(0.03,-0.1),vec2(-0.03,-0.1));\n    d = min(d,d2);\n    \n    p2 = (p-vec2(0.15,-0.3));\n    p2*=Rot(radians(130.0));\n    d2 = sdTriangle(p2,vec2(0.0,0.23),vec2(0.06,-0.1),vec2(-0.06,-0.1));\n    d = min(d,d2);\n    \n    col = mix(col,vec3(0.8,0.7,0.0),S(d,0.0));\n    \n    col = mix(col,vec3(0.7,0.3,0.0),S(abs(d)-0.01,0.0));\n    return col;\n}\n\nvec3 chara(vec2 p, vec3 col) {\n    vec2 prevP = p;\n    \n    p*=1.0+sin(iTime*6.0)*0.05;\n    col = fire(p-vec2(0.0,0.43),col);\n    \n    p = prevP;\n    col = bom(p,col);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 prevUV = uv;\n    vec3 col = vec3(0.0);\n\tfloat t = iTime*0.1;\n    \n    uv-=t;\n    uv*=1.5;\n    uv.x = mod(uv.x,0.52)-0.26;\n    uv.y = mod(uv.y,1.1)-0.55;\n    col = bom(uv,col);\n    uv = prevUV;\n    \n    uv-=t;\n    uv*=1.5;\n    uv.x += 0.26;\n    uv.x = mod(uv.x,0.52)-0.26;\n    \n    uv.y -= 0.55;\n    uv.y = mod(uv.y,1.1)-0.55;\n    \n    col = bom(uv,col);\n    \n    uv = prevUV;\n    uv*=1.5;\n    col = chara((uv-vec2(0.7,0.35))*Rot(radians(120.0)),col);\n    \n    uv = prevUV;\n    uv*=1.2;\n    col = chara((uv-vec2(-0.6,0.2))*Rot(radians(200.0)),col);\n        \n    uv = prevUV;\n    uv*=1.3;\n    col = chara((uv-vec2(0.85,-0.35))*Rot(radians(260.0)),col);\n    \n    uv = prevUV;\n    col = chara(uv-vec2(0.0,-0.2),col);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wdXfWS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wl3XR8", "name": "Jumper Wires", "author": "Plento", "description": "This shader is running on a breadboard.", "tags": ["3d", "mouse", "raymarch", "breadboard"], "likes": 15, "viewed": 304, "date": "1589856720", "time_retrieved": "2024-06-20T20:08:45.133498", "image_code": "// Plento\n// \"Jumper Wires\"\n\n// Raymarched breadboard model with some literal jumping wires\n\n\n#define ShowWires\n\nvec2 R;\nconst float pi = 3.14159;\n#define m vec2(R.x/R.y*(iMouse.x/R.x-.5),iMouse.y/R.y-.5)\n#define FAR 100.\n#define ss(a, b, t) smoothstep(a, b, t)\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\nmat2 rot(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat box( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat torus( vec3 p, vec2 t ){\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat smoothsub( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat map(vec3 rp){\n    float d = 999.;\n    \n    rp.xz*=rot(iTime*.5 -1.);\n    \n    vec3 rp2 = rp;\n    \n    rp.x = -abs(rp.x);\n    \n    float board = box(rp-vec3(0., -.98, 0.), vec3(1., .05, 2.5)) - .05;\n    \n    d = min(d, board);\n    d = smoothsub(box(rp-vec3(0., -.84, 0.), vec3(.03, .05, 3.)),d, .06);\n    \n    vec3 b = vec3(.07, .2, .07);\n    vec3 rrp = rp - vec3(.09, 0., .07);\n    rrp = mod(rrp, b)-b*.5;\n    \n    float rep = max(box(rrp, vec3(.013, .4, .013)),\n        box(rp-vec3(-.36, -1., 0.), vec3(.22, .15, 2.5))\n    );    \n    \n    d = smoothsub(rep, d, .03);\n    \n    float rep2 = max(box(rrp, vec3(.013, .04, .013)),\n        box(rp-vec3(-.89, -1., 0.), vec3(.05, .15, 2.36))\n    );  \n    \n    d = smoothsub(rep2, d, .03);\n    \n    vec3 p = rp2-vec3(0., -1.0, 1.);\n    p = mod(p, vec3(0., 0., 0.4))-vec3(0., 0., 0.4)*0.5;\n    \n    p.yz *= rot(pi/2.);\n    \n    vec3 irp = rp2-vec3(iTime+1.2,-0.5,0.);\n    irp = mod(irp, vec3(4.5,0.,0.))-vec3(4.5,0.,0.)*0.5;\n    irp.xz*=rot(pi/4.);\n    \n    #ifdef ShowWires\n    d = min(d, max(torus(p, vec2(0.5, 0.02)), box(irp, vec3(0.8, 0.5, 2.4))));\n    #endif\n    \n    return d;\n}\n\n\n\nvec3 normal( in vec3 pos ){\n    vec2 e = vec2(0.002, -0.002);\n    return normalize(\n        e.xyy * map(pos + e.xyy) + \n        e.yyx * map(pos + e.yyx) + \n        e.yxy * map(pos + e.yxy) + \n        e.xxx * map(pos + e.xxx));\n}\n\nfloat march(vec3 rd, vec3 ro){\n \tfloat t = 0., d = 0.;   \n    \n    for(int i = 0; i < 80; i++){\n    \td = map(ro + rd*t); \t   \n        if(abs(d) < .0015 || t > 60.) break;\n        \n        t += d * .75;\n    }\n    return t;\n}\n\n\nvec3 color(vec3 p, vec3 rd, vec3 n, float t){\n    vec3 lp = vec3(6., 9.0, -5.0);\n    vec3 ld = normalize(lp-p);\n   \tvec3 ref = reflect( rd, n );\n    \n    float faloff = 1.-exp(-(4. / length(lp - p)));\n    \n    float spec = pow(max(dot(normalize(reflect(ld, n)), rd), 0.), 12.);\n    float dif = max(dot(n, ld), .05);\n    \n    p.xz*=rot(iTime*.5-1.);\n    p.x = abs(p.x);\n    \n    vec3 col = vec3(0);\n    float mat = step(0.865, abs(p.y));\n    \n    float id = floor(p.z/ 0.4 - 0.5);\n    vec3 wire = hash31(id*346.24);\n    \n    vec3 board = vec3(.95, .7, .4);\n    float bnd = ss(2.382, 2.383, abs(p.z));\n    board = mix(vec3(.6, 0., 0.), board, ss(0.01, 0.015, abs(p.x-.99)+bnd));\n    board = mix(vec3(0., .1, .6), board, ss(0.01, 0.015, abs(p.x-.78)+bnd));\n    \n    col = mix(wire, board, mat);\n    \n    col *= 2.*dif*vec3(1., 1., 1.) * faloff;\n    col += vec3(0.8, 0.8, 0.8) * spec * .25;\n    \n    col = mix(vec3(0), col, 1.-step(50., t));\n     \n\treturn col;   \n}\n\n\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    R = iResolution.xy;\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    \n    float zm = max(5.- (iTime * 7.), 0.8);\n    vec3 rd = normalize(vec3(uv, zm));\n    //vec3 ro = vec3(0., m.y*10., m.x*10. - 3.);\n    vec3 ro = vec3(0., 0.5, -2.9);\n    \n    if(iMouse.z>0.) ro.zy += m*3.; \n    \n    rd.yz*=rot(0.65);\n    \n    float t = march(rd, ro);\n    \n    vec3 n = normal(ro + rd*t);\n    vec3 col = color(ro + rd*t, rd, n, t);\n    \n    f = vec4(sqrt(clamp(col, .0, 1.)), 1.);\n    \n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wl3XR8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wlKXzd", "name": "Shader2_DelaVega", "author": "zerotojiro", "description": "Waving swedish flag", "tags": ["midterms"], "likes": 0, "viewed": 189, "date": "1588323531", "time_retrieved": "2024-06-20T20:08:45.139560", "image_code": "float rect (vec2 uv, vec2 pos, vec2 size)\n{\n\tfloat value = step(pos.x - size.x/2.,uv.x) - step(pos.x + size.x/2.,uv.x);\n    return value *= step(pos.y - size.y/2.,uv.y) - step(pos.y + size.y/2.,uv.y);\n}\n\nvec2 hash( vec2 p ) {                       \n    p = vec2( dot(p,vec2(127.1,311.7)),\n              dot(p,vec2(269.5,183.3)) );\n    return -1. + 2.*fract(sin(p+20.)*53758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor((p)), f = fract((p));\n    vec2 u = f*f*(3.-2.*f);\n    return mix( mix( dot( hash( i + vec2(0.,0.) ), f - vec2(0.,0.) ), \n                     dot( hash( i + vec2(1.,0.) ), f - vec2(1.,0.) ), u.x),\n                mix( dot( hash( i + vec2(0.,1.) ), f - vec2(0.,1.) ), \n                     dot( hash( i + vec2(1.,1.) ), f - vec2(1.,1.) ), u.x), u.y);\n}\n\n\nfloat distLine(vec2 p, vec2 a, vec2 b){\n\tvec2 pa = p-a;\n    vec2 ba = b-a;\n    float t = clamp(dot(pa, ba)/dot(ba, ba),0., 1.);\n    return length(pa-ba*t);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b){\n\tfloat d = distLine(p,a,b);\n    float m = 0.9*smoothstep(.02,.01, d);\n    \n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    \n    uv.x *= ratio;\n    \n    uv.y+=noise((uv*.5) + iTime)*.1;\n    uv.x+=noise((uv*.3) + iTime)*.3;\n    \n    vec2 basePos = vec2(.5*ratio, .5);\n    vec2 rect1Pos = vec2(.38*ratio, .5);\n    vec2 rect2Pos = vec2(.5*ratio, .5);\n    \n    vec3 base = vec3(rect(uv, basePos, vec2(1.4, .8)));\n    vec3 rect1 = vec3(rect(uv, rect1Pos, vec2(.15, .8)));\n    vec3 rect2 = vec3(rect(uv, rect2Pos, vec2(1.4, .15 )));\n    float m = line(uv,vec2(-.1,-.1),vec2(.25,.15));\n    m += line(uv,vec2(-.1,1.1),vec2(.25,.85));\n\n    vec3 col = vec3(.0941, .1725, .3215);\n    col = mix(col, vec3(1.0), m);\n    col = mix(col, vec3(0., .2941, .5294), base);\n    col = mix(col, vec3(1.0, 0.8196, 0.), rect1);\n    col = mix(col, vec3(1.0, 0.8196, 0.), rect2);\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wlKXzd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wlt3zs", "name": "Raytracing in a weekend", "author": "mawasi", "description": "Reference\nhttps://raytracing.github.io/\nhttps://raytracing.github.io/books/RayTracingInOneWeekend.html\n", "tags": ["raytracing"], "likes": 1, "viewed": 126, "date": "1588325285", "time_retrieved": "2024-06-20T20:08:47.394142", "image_code": "// Ray Tracing in a Weekend\n\nstruct Ray{\n    vec3 origin;\n    vec3 dir;\n};\n\nstruct Material{\n    int type;\n    vec3 albedo;\n    float fuzz;\n    float refIdx;\n};\n\nstruct Sphere{\n    vec3 center;\n    float radius;\n    Material material;\n};\n\nstruct HitRecord{\n    bool front_face;\n    float t;\n    vec3 point;\n    vec3 normal;\n    Material material;\n};\n\nstruct Camera{\n    vec3 origin;\n    vec3 lower_left_corner;\n    vec3 horizontal;\n    vec3 vertical;\n    vec3 u;\n    vec3 v;\n    vec3 w;\n    float lens_radius;\n};\n\n\n// floatæå¤§å¤\nconst float FLT_MAX = 3.402823466e+38f;\nconst float PI = 3.1515926f;\n\n// ãã¯ã»ã«ãµã³ããªã³ã°åæ°\nconst float samples_per_pixel = 10.0;\n// Rayã®åå°åæ°\nconst float ray_depth = 5.0;\n\nconst float mr = 0.2;\nconst Material GLASS = Material(2, vec3(1.0, 1.0, 1.0), 0.0, 1.5);\n\nconst int OBJ_MAX = 100 + 4;\nSphere[OBJ_MAX] Spheres = Sphere[](\n\tSphere(vec3(-3.645230, 0.200000, 3.147237), 0.200000, Material(2, vec3(0.601982, 0.119547, 0.165649), 0.000000, 1.500000)),\n\tSphere(vec3(3.350085, 0.200000, 4.057920), 0.200000, Material(2, vec3(0.340220, 0.262971, 0.471957), 0.000000, 1.500000)),\n\tSphere(vec3(4.688678, 0.200000, -3.730132), 0.200000, Material(1, vec3(0.716101, 0.689215, 0.529842), 0.654079, 1.500000)),\n\tSphere(vec3(-2.789660, 0.200000, 4.133759), 0.200000, Material(1, vec3(0.720493, 0.450542, 0.988379), 0.748152, 1.500000)),\n\tSphere(vec3(-1.918330, 0.200000, 1.323593), 0.200000, Material(2, vec3(0.228977, 0.912578, 0.083821), 0.000000, 1.500000)),\n\tSphere(vec3(0.472206, 0.200000, -4.024596), 0.200000, Material(1, vec3(0.152378, 0.558269, 0.913337), 0.505499, 1.500000)),\n\tSphere(vec3(-3.116180, 0.200000, -2.215018), 0.200000, Material(0, vec3(0.462474, 0.825817, 0.503190), 0.000000, 1.500000)),\n\tSphere(vec3(4.928813, 0.200000, 0.468815), 0.200000, Material(0, vec3(0.996135, 0.546592, 0.538342), 0.000000, 1.500000)),\n\tSphere(vec3(4.964613, 0.200000, 4.575068), 0.200000, Material(1, vec3(0.442678, 0.854451, 0.078176), 0.447584, 1.500000)),\n\tSphere(vec3(4.676950, 0.200000, 4.648885), 0.200000, Material(2, vec3(0.498544, 0.106653, 0.604231), 0.000000, 1.500000)),\n\tSphere(vec3(2.258389, 0.200000, -3.423869), 0.200000, Material(2, vec3(0.004634, 0.979926, 0.961898), 0.000000, 1.500000)),\n\tSphere(vec3(4.811097, 0.200000, 4.705928), 0.200000, Material(2, vec3(0.977002, 0.774910, 0.034317), 0.000000, 1.500000)),\n\tSphere(vec3(-3.901382, 0.200000, 4.571670), 0.200000, Material(1, vec3(0.679520, 0.868695, 0.363186), 0.817303, 1.500000)),\n\tSphere(vec3(2.981058, 0.200000, -0.146244), 0.200000, Material(0, vec3(0.399783, 0.346233, 0.084436), 0.000000, 1.500000)),\n\tSphere(vec3(-2.029706, 0.200000, 3.002805), 0.200000, Material(1, vec3(0.800068, 0.045060, 0.259870), 0.855875, 1.500000)),\n\tSphere(vec3(-4.952165, 0.200000, -3.581137), 0.200000, Material(2, vec3(0.749941, 0.431414, 0.660119), 0.000000, 1.500000)),\n\tSphere(vec3(-3.875355, 0.200000, -0.782387), 0.200000, Material(1, vec3(0.982361, 0.181847, 0.132996), 0.910648, 1.500000)),\n\tSphere(vec3(1.397634, 0.200000, 4.157355), 0.200000, Material(2, vec3(0.145539, 0.095355, 0.263803), 0.000000, 1.500000)),\n\tSphere(vec3(3.784307, 0.200000, 2.922073), 0.200000, Material(0, vec3(0.802111, 0.136069, 0.282673), 0.000000, 1.500000)),\n\tSphere(vec3(0.036627, 0.200000, 4.594925), 0.200000, Material(0, vec3(0.579705, 0.077557, 0.869292), 0.000000, 1.500000)),\n\tSphere(vec3(2.979286, 0.200000, 1.557407), 0.200000, Material(0, vec3(0.008094, 0.549860, 0.627384), 0.000000, 1.500000)),\n\tSphere(vec3(-1.387060, 0.200000, -4.642883), 0.200000, Material(0, vec3(0.853031, 0.680287, 0.144955), 0.000000, 1.500000)),\n\tSphere(vec3(-2.880757, 0.200000, 3.491293), 0.200000, Material(2, vec3(0.438667, 0.622055, 0.533933), 0.000000, 1.500000)),\n\tSphere(vec3(1.813595, 0.200000, 4.339932), 0.200000, Material(0, vec3(0.513250, 0.199551, 0.350952), 0.000000, 1.500000)),\n\tSphere(vec3(-1.012615, 0.200000, 1.787352), 0.200000, Material(1, vec3(0.075967, 0.382333, 0.401808), 0.138001, 1.500000)),\n\tSphere(vec3(2.406473, 0.200000, 2.577401), 0.200000, Material(1, vec3(0.123319, 0.040471, 0.239916), 0.762421, 1.500000)),\n\tSphere(vec3(-0.252413, 0.200000, 2.431325), 0.200000, Material(0, vec3(0.504771, 0.183908, 0.252956), 0.000000, 1.500000)),\n\tSphere(vec3(-0.779123, 0.200000, -1.077730), 0.200000, Material(2, vec3(0.417267, 0.822605, 0.239953), 0.000000, 1.500000)),\n\tSphere(vec3(-3.261348, 0.200000, 1.554779), 0.200000, Material(2, vec3(0.823455, 0.049654, 0.981723), 0.000000, 1.500000)),\n\tSphere(vec3(-1.980869, 0.200000, -3.288133), 0.200000, Material(2, vec3(0.944787, 0.301827, 0.902716), 0.000000, 1.500000)),\n\tSphere(vec3(2.972799, 0.200000, 2.060461), 0.200000, Material(2, vec3(0.247848, 0.490864, 0.047944), 0.000000, 1.500000)),\n\tSphere(vec3(-1.834496, 0.200000, -4.681672), 0.200000, Material(0, vec3(0.337719, 0.544056, 0.489253), 0.000000, 1.500000)),\n\tSphere(vec3(3.724288, 0.200000, -2.230770), 0.200000, Material(2, vec3(0.343840, 0.900054, 0.887726), 0.000000, 1.500000)),\n\tSphere(vec3(-3.508860, 0.200000, -4.538286), 0.200000, Material(0, vec3(0.111203, 0.033269, 0.369247), 0.000000, 1.500000)),\n\tSphere(vec3(4.940685, 0.200000, -4.028682), 0.200000, Material(0, vec3(0.877364, 0.780252, 0.162872), 0.000000, 1.500000)),\n\tSphere(vec3(3.219033, 0.200000, 3.234578), 0.200000, Material(1, vec3(0.272753, 0.241691, 0.210302), 0.389739, 1.500000)),\n\tSphere(vec3(-3.748172, 0.200000, 1.948286), 0.200000, Material(2, vec3(0.096455, 0.492442, 0.403912), 0.000000, 1.500000)),\n\tSphere(vec3(2.637500, 0.200000, -1.829005), 0.200000, Material(1, vec3(0.942051, 0.490301, 0.131973), 0.223420, 1.500000)),\n\tSphere(vec3(-0.094110, 0.200000, 4.502221), 0.200000, Material(1, vec3(0.575209, 0.651969, 0.956135), 0.954943, 1.500000)),\n\tSphere(vec3(1.636055, 0.200000, -4.655539), 0.200000, Material(0, vec3(0.435246, 0.059780, 0.757504), 0.000000, 1.500000)),\n\tSphere(vec3(-3.741034, 0.200000, -0.612556), 0.200000, Material(2, vec3(0.353159, 0.552881, 0.234780), 0.000000, 1.500000)),\n\tSphere(vec3(-2.897909, 0.200000, -1.184416), 0.200000, Material(0, vec3(0.322511, 0.821194, 0.053153), 0.000000, 1.500000)),\n\tSphere(vec3(-4.487836, 0.200000, 2.655168), 0.200000, Material(2, vec3(0.043024, 0.404981, 0.015403), 0.000000, 1.500000)),\n\tSphere(vec3(-4.635588, 0.200000, 2.951999), 0.200000, Material(0, vec3(0.809137, 0.168990, 0.908434), 0.000000, 1.500000)),\n\tSphere(vec3(-0.912688, 0.200000, -3.131274), 0.200000, Material(0, vec3(0.731722, 0.258296, 0.649116), 0.000000, 1.500000)),\n\tSphere(vec3(2.939750, 0.200000, 1.463130), 0.200000, Material(2, vec3(0.493327, 0.647746, 0.129847), 0.000000, 1.500000)),\n\tSphere(vec3(4.208748, 0.200000, 2.093648), 0.200000, Material(0, vec3(0.547009, 0.378500, 0.450924), 0.000000, 1.500000)),\n\tSphere(vec3(3.075310, 0.200000, 2.546866), 0.200000, Material(1, vec3(0.744693, 0.287805, 0.296321), 0.718470, 1.500000)),\n\tSphere(vec3(2.057743, 0.200000, -2.239749), 0.200000, Material(2, vec3(0.811874, 0.188955, 0.623436), 0.000000, 1.500000)),\n\tSphere(vec3(-4.971816, 0.200000, 1.797027), 0.200000, Material(1, vec3(0.385711, 0.183511, 0.312508), 0.686775, 1.500000)),\n\tSphere(vec3(2.107038, 0.200000, 1.550980), 0.200000, Material(2, vec3(0.625619, 0.343930, 0.368485), 0.000000, 1.500000)),\n\tSphere(vec3(1.439610, 0.200000, -3.373883), 0.200000, Material(2, vec3(0.669285, 0.780227, 0.815769), 0.000000, 1.500000)),\n\tSphere(vec3(-0.439672, 0.200000, -3.810023), 0.200000, Material(1, vec3(0.458497, 0.929386, 0.379419), 0.081126, 1.500000)),\n\tSphere(vec3(2.739172, 0.200000, -0.016359), 0.200000, Material(0, vec3(0.486792, 0.303614, 0.775713), 0.000000, 1.500000)),\n\tSphere(vec3(0.737547, 0.200000, 4.597440), 0.200000, Material(0, vec3(0.488618, 0.435859, 0.910565), 0.000000, 1.500000)),\n\tSphere(vec3(3.767574, 0.200000, -1.596143), 0.200000, Material(1, vec3(0.108062, 0.306349, 0.755790), 0.446784, 1.500000)),\n\tSphere(vec3(3.081755, 0.200000, 0.852677), 0.200000, Material(2, vec3(0.510772, 0.393590, 0.508509), 0.000000, 1.500000)),\n\tSphere(vec3(-4.822261, 0.200000, -2.761881), 0.200000, Material(0, vec3(0.360861, 0.817628, 0.870187), 0.000000, 1.500000)),\n\tSphere(vec3(3.212460, 0.200000, 2.512671), 0.200000, Material(1, vec3(0.543805, 0.644318, 0.917118), 0.794831, 1.500000)),\n\tSphere(vec3(3.208407, 0.200000, -2.449049), 0.200000, Material(1, vec3(0.199873, 0.811580, 0.140144), 0.378609, 1.500000)),\n\tSphere(vec3(4.400741, 0.200000, 0.059571), 0.200000, Material(1, vec3(0.990110, 0.350727, 0.948925), 0.532826, 1.500000)),\n\tSphere(vec3(-0.873335, 0.200000, 1.990767), 0.200000, Material(2, vec3(0.875943, 0.240076, 0.939002), 0.000000, 1.500000)),\n\tSphere(vec3(-0.768349, 0.200000, 3.909033), 0.200000, Material(2, vec3(0.388615, 0.550156, 0.016521), 0.000000, 1.500000)),\n\tSphere(vec3(0.809567, 0.200000, 4.592914), 0.200000, Material(0, vec3(0.587045, 0.779689, 0.622475), 0.000000, 1.500000)),\n\tSphere(vec3(-3.419424, 0.200000, 0.472155), 0.200000, Material(0, vec3(0.540138, 0.207742, 0.476638), 0.000000, 1.500000)),\n\tSphere(vec3(2.617312, 0.200000, -3.613756), 0.200000, Material(1, vec3(0.900183, 0.470923, 0.018451), 0.301246, 1.500000)),\n\tSphere(vec3(-2.698439, 0.200000, -3.507060), 0.200000, Material(1, vec3(0.885998, 0.844309, 0.194495), 0.230488, 1.500000)),\n\tSphere(vec3(3.097345, 0.200000, -2.424917), 0.200000, Material(2, vec3(0.225922, 0.441223, 0.194764), 0.000000, 1.500000)),\n\tSphere(vec3(4.885216, 0.200000, 3.407172), 0.200000, Material(1, vec3(0.227664, 0.239502, 0.170708), 0.147829, 1.500000)),\n\tSphere(vec3(-1.675517, 0.200000, -2.457178), 0.200000, Material(1, vec3(0.311102, 0.473015, 0.435699), 0.799653, 1.500000)),\n\tSphere(vec3(-2.001683, 0.200000, 3.142848), 0.200000, Material(2, vec3(0.644551, 0.923380, 0.089823), 0.000000, 1.500000)),\n\tSphere(vec3(-4.864609, 0.200000, -2.564750), 0.200000, Material(0, vec3(0.184816, 0.633064, 0.430207), 0.000000, 1.500000)),\n\tSphere(vec3(-2.827621, 0.200000, 4.292637), 0.200000, Material(2, vec3(0.726654, 0.904881, 0.584382), 0.000000, 1.500000)),\n\tSphere(vec3(4.073647, 0.200000, -1.500163), 0.200000, Material(0, vec3(0.438870, 0.354638, 0.979748), 0.000000, 1.500000)),\n\tSphere(vec3(3.484677, 0.200000, -3.034048), 0.200000, Material(1, vec3(0.258065, 0.707322, 0.111119), 0.680407, 1.500000)),\n\tSphere(vec3(4.550176, 0.200000, -2.489161), 0.200000, Material(2, vec3(0.133736, 0.408720, 0.162329), 0.000000, 1.500000)),\n\tSphere(vec3(2.788977, 0.200000, 1.160447), 0.200000, Material(0, vec3(0.262212, 0.449556, 0.594896), 0.000000, 1.500000)),\n\tSphere(vec3(4.874596, 0.200000, -0.267112), 0.200000, Material(0, vec3(0.797364, 0.602843, 0.042054), 0.000000, 1.500000)),\n\tSphere(vec3(-4.324046, 0.200000, -1.483405), 0.200000, Material(0, vec3(0.221747, 0.167556, 0.711216), 0.000000, 1.500000)),\n\tSphere(vec3(2.935976, 0.200000, 3.308286), 0.200000, Material(2, vec3(0.324964, 0.117418, 0.831214), 0.000000, 1.500000)),\n\tSphere(vec3(0.945036, 0.200000, 0.852641), 0.200000, Material(0, vec3(0.318778, 0.655780, 0.296676), 0.000000, 1.500000)),\n\tSphere(vec3(2.327987, 0.200000, 0.497236), 0.200000, Material(2, vec3(0.781909, 0.424167, 0.420190), 0.000000, 1.500000)),\n\tSphere(vec3(1.952329, 0.200000, 4.171936), 0.200000, Material(0, vec3(0.085516, 0.113193, 0.507858), 0.000000, 1.500000)),\n\tSphere(vec3(1.798198, 0.200000, -2.141610), 0.200000, Material(1, vec3(0.801015, 0.181573, 0.262482), 0.993535, 1.500000)),\n\tSphere(vec3(-1.076796, 0.200000, 2.572002), 0.200000, Material(0, vec3(0.265921, 0.029220, 0.762931), 0.000000, 1.500000)),\n\tSphere(vec3(0.615575, 0.200000, 2.537291), 0.200000, Material(2, vec3(0.730331, 0.244138, 0.928854), 0.000000, 1.500000)),\n\tSphere(vec3(-2.919319, 0.200000, -1.195542), 0.200000, Material(1, vec3(0.578525, 0.344328, 0.488609), 0.100738, 1.500000)),\n\tSphere(vec3(-0.957915, 0.200000, -4.241457), 0.200000, Material(2, vec3(0.968640, 0.237284, 0.281627), 0.000000, 1.500000)),\n\tSphere(vec3(-1.472376, 0.200000, -4.460499), 0.200000, Material(2, vec3(0.963089, 0.213773, 0.458849), 0.000000, 1.500000)),\n\tSphere(vec3(-1.436548, 0.200000, 2.791672), 0.200000, Material(1, vec3(0.521136, 0.226551, 0.546806), 0.605928, 1.500000)),\n\tSphere(vec3(4.649664, 0.200000, 4.340107), 0.200000, Material(0, vec3(0.401571, 0.231594, 0.189905), 0.000000, 1.500000)),\n\tSphere(vec3(-3.455616, 0.200000, -3.700938), 0.200000, Material(0, vec3(0.624060, 0.413291, 0.488898), 0.000000, 1.500000)),\n\tSphere(vec3(-1.050918, 0.200000, 0.688236), 0.200000, Material(2, vec3(0.299052, 0.679136, 0.170152), 0.000000, 1.500000)),\n\tSphere(vec3(-1.127041, 0.200000, -0.306094), 0.200000, Material(1, vec3(0.151574, 0.367437, 0.636469), 0.395515, 1.500000)),\n\tSphere(vec3(2.269547, 0.200000, -4.880980), 0.200000, Material(2, vec3(0.037739, 0.769243, 0.987982), 0.000000, 1.500000)),\n\tSphere(vec3(-1.114302, 0.200000, -1.628773), 0.200000, Material(1, vec3(0.913287, 0.959222, 0.885168), 0.883969, 1.500000)),\n\tSphere(vec3(4.274929, 0.200000, -3.378177), 0.200000, Material(2, vec3(0.582846, 0.796184, 0.018066), 0.000000, 1.500000)),\n\tSphere(vec3(-0.638824, 0.200000, 2.942845), 0.200000, Material(0, vec3(0.261871, 0.766854, 0.098712), 0.000000, 1.500000)),\n\tSphere(vec3(3.626781, 0.200000, -1.887850), 0.200000, Material(0, vec3(0.129066, 0.335357, 0.327798), 0.000000, 1.500000)),\n\tSphere(vec3(1.203600, 0.200000, 0.285332), 0.200000, Material(2, vec3(0.136553, 0.291961, 0.679728), 0.000000, 1.500000)),\n\n    Sphere(vec3(0.0, -1000.0, 0.0), 1000.0, Material(0, vec3(0.5, 0.5, 0.5), 0.0, 0.0)),\n    Sphere(vec3(0.0, 1.0, 0.0), 1.0, Material(2, vec3(1.0, 1.0, 1.0), 0.0, 1.5)),\n    Sphere(vec3(-3.0, 1.0, 0.0), 1.0, Material(0, vec3(0.4, 0.2, 0.1), 0.0, 1.5)),\n    Sphere(vec3(3.0, 1.0, 0.0), 1.0, Material(1, vec3(0.7, 0.6, 0.5), 0.0, 1.5))\n);\n\n\n\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand(vec2 co, float min, float max)\n{\n    return min + (max - min) * rand(co);\n}\n\nvec3 randVec(vec2 co, float min, float max)\n{\n    float i = 0.0;\n    vec3 result;\n    result.x = rand(co+i, min, max); i += 0.1;\n    result.y = rand(co+i, min, max); i += 0.1;\n    result.z = rand(co+i, min, max); i += 0.1;\n    return result;\n}\n\nvec3 randomUnitVector(vec2 oc)\n{\n    float bias = 1.0;\n    float a = rand(oc+bias, 0.0, 2.0*PI);\n    bias += 1.0;\n    float z = rand(oc+bias, -1.0, 1.0);\n    float r = sqrt(1.0 - z*z);\n    return vec3(r*cos(a), r*sin(a), z);\n}\n\nvec3 randomInUnitSphere(vec2 oc)\n{\n    float i = 0.0;\n    while(true){\n        vec3 p;\n        p.x = rand(oc+i, -1.0, 1.0); i += 0.1;\n        p.y = rand(oc+i, -1.0, 1.0); i += 0.1;\n        p.z = rand(oc+i, -1.0, 1.0); i += 0.1;\n        if(length(p) >= 1.0) continue;\n        return p;\n    }\n}\n\nvec3 randomInHemisphere(vec2 oc, vec3 normal)\n{\n    vec3 inUnitSphere = randomInUnitSphere(oc);\n    if(dot(inUnitSphere, normal) > 0.0){\n        return inUnitSphere;\n    }\n    else{\n        return -inUnitSphere;\n    }\n}\n\nvec3 randomInUnitDisk(vec2 oc)\n{\n    float i = 0.0;\n    while(true){\n        vec3 p;\n        p.x = rand(oc+i, -1.0, 1.0); i += 0.1;\n        p.y = rand(oc+i, -1.0, 1.0); i += 0.1;\n        p.z = 0.0;\n        if(length(p) >= 1.0) continue;\n        return p;\n    }    \n}\n\nfloat deg2Rad(float degree)\n{\n    return degree * PI / 180.0f;\n}\n\n\nvoid setFaceNormal(Ray r, vec3 outwardNormal, inout HitRecord hitrecord)\n{\n    hitrecord.front_face = dot(r.dir, outwardNormal) < 0.0;\n    hitrecord.normal = hitrecord.front_face ? outwardNormal : -outwardNormal;\n}\n\nvec3 pointAtParameter(Ray r, float t)\n{\n    return r.origin + t * r.dir;\n}\n\n// Schlick approximation\nfloat schlick(float cosine, float refIdx)\n{\n    float r0 = (1.0 - refIdx) / (1.0 + refIdx);\n    r0 = r0 * r0;\n    return r0 + (1.0 - r0) * pow((1.0 - cosine), 5.0);\n}\n\nbool lambertianScatter(Ray ray, HitRecord hitrecord, inout vec3 attenuation, inout Ray scatterd, vec2 oc)\n{\n    vec3 scatterDicrection = hitrecord.normal + randomUnitVector(oc);\n    scatterd = Ray(hitrecord.point, scatterDicrection);\n    attenuation = hitrecord.material.albedo;\n    return true;\n}\n\nbool metalScatter(Ray ray, HitRecord hitrecord, inout vec3 attenuation, inout Ray scatterd, vec2 oc)\n{\n    vec3 reflected = reflect(normalize(ray.dir), hitrecord.normal);\n    scatterd = Ray(hitrecord.point, reflected + hitrecord.material.fuzz*randomInUnitSphere(oc));\n    attenuation = hitrecord.material.albedo;\n    return (dot(scatterd.dir, hitrecord.normal) > 0.0);\n}\n\nbool dielectricScatter(Ray ray, HitRecord hitrecord, inout vec3 attenuation, inout Ray scatterd, vec2 oc)\n{\n    attenuation = vec3(1.0, 1.0, 1.0);//hitrecord.material.albedo;\n    float etai_over_etat;\n    if(hitrecord.front_face){\n        etai_over_etat = 1.0 / hitrecord.material.refIdx;\n    }\n    else{\n        etai_over_etat = hitrecord.material.refIdx;\n    }\n\n    vec3 dir = normalize(ray.dir);\n    float cosTheta = min(dot(-dir, hitrecord.normal), 1.0);\n    float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n    if(etai_over_etat * sinTheta > 1.0){\n        vec3 reflected = reflect(dir, hitrecord.normal);\n        scatterd = Ray(hitrecord.point, reflected);\n        return true;\n    }\n    float reflectProb = schlick(cosTheta, etai_over_etat);\n    if(rand(oc) < reflectProb){\n        vec3 reflected = reflect(dir, hitrecord.normal);\n        scatterd = Ray(hitrecord.point, reflected);\n        return true;\n    }\n    vec3 refracted = refract(dir, hitrecord.normal, etai_over_etat);\n    scatterd = Ray(hitrecord.point, refracted);\n    return true;\n}\n\nbool scatter(Ray ray, HitRecord hitrecord, inout vec3 attenuation, inout Ray scatterd, vec2 oc)\n{\n    bool result;\n\n    if(hitrecord.material.type == 0){\n        result = lambertianScatter(ray, hitrecord, attenuation, scatterd, oc);\n    }\n    else if(hitrecord.material.type == 1){\n        result = metalScatter(ray, hitrecord, attenuation, scatterd, oc);\n    }\n    else if(hitrecord.material.type == 2){\n        result = dielectricScatter(ray, hitrecord, attenuation, scatterd, oc);\n    }\n    else{\n        result = lambertianScatter(ray, hitrecord, attenuation, scatterd, oc);\n    }\n\n    return result;\n}\n\nbool contactSphere(Sphere sphere, Ray r, float t_min, float t_max, inout HitRecord hitrecord)\n{\n    // ray vs sphere ã®å¤å®\n    vec3 oc = r.origin - sphere.center;\n    float a = dot(r.dir, r.dir);\n    float half_b = dot(oc, r.dir);\n    float c = dot(oc, oc) - sphere.radius*sphere.radius;\n    float discriminant = half_b * half_b - a * c;\n\n    if(discriminant > 0.0){\n\n        float root = sqrt(discriminant);\n        float temp = (-half_b - root) / a;\n        if(temp < t_max && temp > t_min){\n            hitrecord.t = temp;\n            hitrecord.point = pointAtParameter(r, hitrecord.t);\n            vec3 outwardNormal = (hitrecord.point - sphere.center) / sphere.radius;\n            setFaceNormal(r, outwardNormal, hitrecord);\n            hitrecord.material = sphere.material;\n            return true;\n        }\n        temp = (-half_b + root) / a;\n        if(temp < t_max && temp > t_min){\n            hitrecord.t = temp;\n            hitrecord.point = pointAtParameter(r, hitrecord.t);\n            vec3 outwardNormal = (hitrecord.point - sphere.center) / sphere.radius;\n            setFaceNormal(r, outwardNormal, hitrecord);\n            hitrecord.material = sphere.material;\n            return true;\n        }\n    }\n    return false;\n}\n\n\nbool contactObjects(Ray r, float t_min, float t_max, inout HitRecord rec)\n{\n    HitRecord temp_rec;\n    bool hit_anything = false;\n    float closest_so_far = t_max;\n\n    for(int i = 0; i < OBJ_MAX; i++){\n        if(contactSphere(Spheres[i], r, t_min, closest_so_far, temp_rec)){\n            hit_anything = true;\n            closest_so_far = temp_rec.t;\n            rec = temp_rec;\n        }\n    }\n\n    return hit_anything;\n}\n\n\nvec3 rayColor(Ray r, float depth)\n{\n    HitRecord rec;\n\n    vec3 target;\n    Ray ray = r;\n\n    if(contactObjects(ray, 0.001, FLT_MAX, rec)){\n        vec3 attenuation;\n        bool result = scatter(ray, rec, attenuation, ray, r.dir.xy);\n\n        if(result){\n            for(float i = 0.0; i < depth; i++){\n                if(contactObjects(ray, 0.001, FLT_MAX, rec)){\n                    vec3 attenuation2;\n                    result = scatter(ray, rec, attenuation2, ray, r.dir.xy+i);\n                    if(result){\n                        attenuation *= attenuation2;\n                        continue;\n                    }\n                    return vec3(0.0, 0.0, 0.0);\n                }\n                vec3 unit_dir = normalize(ray.dir);\n                float t = 0.5f * (unit_dir.y + 1.0f);\n                return attenuation * mix(vec3(1.0f, 1.0f, 1.0f), vec3(0.5f, 0.7f, 1.0f), t);\n            }\n        }\n        return vec3(0.0, 0.0, 0.0);\n    }\n\n    vec3 unit_dir = normalize(ray.dir);\n    float t = 0.5f * (unit_dir.y + 1.0f);\n    return mix(vec3(1.0f, 1.0f, 1.0f), vec3(0.5f, 0.7f, 1.0f), t);\n\n}\n\n\nCamera createCamera(vec3 origin, vec3 lookat, vec3 vup, float fov, float aspect, float aperture, float focusDist)\n{\n    Camera cam;\n    cam.origin = origin;\n    cam.lens_radius = aperture / 2.0;\n\n    float rfov = deg2Rad(fov);\n    float halfHeight = tan(rfov/2.0);\n    float halfWidth = halfHeight * aspect;\n\n    cam.w = normalize(origin - lookat);\n    cam.u = normalize(cross(vup, cam.w));\n    cam.v = normalize(cross(cam.w, cam.u));\n\n    cam.lower_left_corner = origin\n                            - halfWidth * focusDist * cam.u\n                            - halfHeight * focusDist * cam.v\n                            - focusDist * cam.w;\n\n    cam.horizontal = 2.0 * halfWidth * focusDist * cam.u;\n\n    cam.vertical = 2.0 * halfHeight * focusDist * cam.v;\n\n    return cam;\n}\n\nRay createRay(in Camera cam, float u, float v, vec2 oc)\n{\n    vec3 rd = cam.lens_radius * randomInUnitDisk(oc);\n    vec3 offset = cam.u * rd.x + cam.v * rd.y;\n\n    return Ray(cam.origin + offset, cam.lower_left_corner + u * cam.horizontal + v * cam.vertical - cam.origin - offset);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    float aspect = iResolution.x / iResolution.y;\n\n\n\n    float rot = 30.0*iTime;\n    rot = rot > 360.0 ? rot - 360.0 : rot;\n    rot = deg2Rad(rot);\n    float len = 5.0;\n\n    vec3 origin = vec3(len * cos(rot), 2.0f, len * sin(rot));\n    vec3 lookat = vec3(0.0, 0.0, 0.0);\n    vec3 vup = vec3(0.0, 1.0, 0.0);\n\n    float aperture = 0.0;\n    float focusDist = length(origin - lookat);\n\n    Camera cam = createCamera(origin, lookat, vup, 90.0, aspect, aperture, focusDist);\n\n\n    vec3 col = vec3(0.0, 0.0, 0.0);\n\n    for(float s = 0.0; s < samples_per_pixel; s++){\n        float u = (fragCoord.x + rand(uv+s)) / iResolution.x;\n        float v = (fragCoord.y + rand(uv+s)) / iResolution.y;\n        Ray r = createRay(cam, u, v, uv);\n        col += rayColor(r, ray_depth);\n    }\n    float scale = 1.0 / samples_per_pixel;\n\n    col.x = sqrt(col.x * scale);\n    col.y = sqrt(col.y * scale);\n    col.z = sqrt(col.z * scale);\n\n\tfragColor = vec4(col, 1.0f);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wlt3zs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wlVXWz", "name": "Lunar Planet", "author": "propagant", "description": "Random lunar planet atmosphere. My regular practice shader.", "tags": ["space", "lunarplanet"], "likes": 2, "viewed": 295, "date": "1590891118", "time_retrieved": "2024-06-20T20:08:47.394142", "image_code": "\nfloat sph(vec3 c, vec4 p) { return length(c - p.xyz) - p.w; }\n\nfloat generic(vec3 p) { return sph(p, vec4(-0.1,0.,1.8,0.25)); }\n\nfloat march(vec3 ro, vec3 rd)\n{\n    float pr = 0.;\n    \n    for(int i = 0; i < 6; i++)\n    {\n     \tvec3 p = ro + rd * pr;\n        pr += generic(p);\n        if(pr >= 8.)\n            break;\n    }\n    return pr;\n}\n\nvec3 normal(vec3 p)\n{\n \tvec2 off = vec2(0.001, 0.0);\n    float copy = generic(p);\n    vec3 n = copy - vec3(generic(p- off.xyy), generic(p- off.yxy), generic(p- off.yyx));\n    return normalize(n);\n}\n\nfloat lighting(vec3 p, vec3 lpos)\n{\n    vec3 n = normal(p);\n    vec3 l = normalize(lpos - n);\n    vec3 ll = normalize(lpos - p);\n    float diff = dot(l, n) + 1.;\n    diff+=pow(max(dot(l,n),0.),2.0)*2.0;\n    return diff;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 ro = vec3(0.0);\n    vec3 rd = normalize(vec3(uv.xy,1.0));\n    float m = march(ro,rd);\n    vec3 p = ro + rd * m;\n    vec3 lp = vec3(sin(iTime*0.15)*3.,2.0,0.5);\n    vec3 col = vec3(lighting(p,lp)) \n        * vec3(lighting(p,vec3(lp.x,-lp.y/2.,lp.z)));\n\tcol += vec3(0.25,0.35,0.3)/1.;\n    col *= exp(-1. * pow(m,1.1));\n    if(m > 3.)\n    col+=vec3(smoothstep(0.998, 1., fract(cos(dot(uv, vec2(0.2, 7.13)))*5894.5458)))/4.;\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [{"id": "MtjGzK", "previewfilepath": "https://soundcloud.com/astropilot/space-ambient-demo-00", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/astropilot/space-ambient-demo-00", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wlVXWz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ws2BRm", "name": "Isoparty", "author": "jahnertz", "description": "The result of some live-programming on https://shawnlawson.github.io/The_Force/ during our end-of-isolation party", "tags": ["noise", "perlin", "smooth", "stripe"], "likes": 1, "viewed": 66, "date": "1589765178", "time_retrieved": "2024-06-20T20:08:47.394142", "image_code": "// Noise implementation\nvec2 hash( vec2 p )\n{\n    p = vec2( dot( p, vec2( 127.1, 311.7 )), dot( p, vec2( 269.5, 183 )) );\n    return -1.0 + 2.0 * fract( sin( p ) * 43758.5453123 );\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n    \n    vec2 i = floor( p + (p.x + p.y) * K1 );\n    vec2 a = p - i + ( i.x + i.y) * K2;\n    float m = step( a.y, a.x );\n    vec2 o = vec2( m, 1.0 - m );\n    vec2 b = a - o + K2;\n    vec2 c = a - 1.0 + 2.0 * K2;\n    vec3 h = max( 0.5 - vec3( dot( a, a ), dot( b, b ), dot( c, c ) ), 0.0 );\n    vec3 n = h*h*h*h*vec3( dot( a, hash( i + 0.0 )), dot( b, hash( i + o )), dot( c, hash( i + 1.0)));\n    return dot( n, vec3( 70.0 ) );\n}\n\n// Draw a diagonal division\nfloat tri(vec2 st, float pct){\n    return 1.0 - smoothstep( pct, pct+0.05, st.y );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (fraom 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    // Center coordinates a\n    uv -= vec2( 0.5 );\n    // coordinates circular oscilation\n    uv.x += sin( iTime / 5.0 );\n    uv.y -= cos( iTime / 5.0 );\n    // Set scale/zoom\n    float s = 2.0 + sin(iTime / 10.0) * 15.0;\n    // TODO: noise displacement\n    uv += noise(uv);\n    // spherical distortion\n    uv *= vec2( cos( length( uv ) * cos( iTime / 10.0 ) * 10.0 ));\n    // apply scale\n    uv *= s;\n    \n    // set colors\n    vec3 color_a = vec3( 0.2, 0.2, cos( iTime / 20.0 ));\n    vec3 color_b = vec3( 1.0, sin( iTime / 10.0 ), 0.2 + cos( iTime / 2.0 ) * 0.2);\n    \n    float y1 = mod( uv.x, 1.0 ) + ( sin( uv.x / s + iTime * 1.0 )) + cos( uv.y / s + iTime );\n    \n    vec3 color = color_a;\n    color -= vec3( tri( uv, y1 ));\n    color += vec3( tri( uv + 0.5, y1));\n    color += vec3( 1.0 );\n    color *= color_b;\n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ws2BRm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ws2BRW", "name": "Square + Circle Construction", "author": "blackle", "description": "how the square + circle shape is built", "tags": ["construction"], "likes": 6, "viewed": 249, "date": "1589640104", "time_retrieved": "2024-06-20T20:08:47.709429", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nfloat antialias(float x) {\n    float pixelsize = 4./iResolution.y;\n    return smoothstep(pixelsize, 0., x);\n}\n\nconst float PI = acos(-1.);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n    uv*=3.; mouse*=3.;\n    \n    \n    float col = 0.;\n    float animlen = 27.;\n    float timeline = abs(asin(sin(iTime*PI/animlen/2.))*animlen/PI*2.);\n    \n    float radius = 1.;\n    float sharpness = pow(asin(sin(max(4.7, timeline*1.2)))/PI+1.,8.);\n    float offset = sin(iTime*0.65)*0.25+0.25;\n    \n    float axis_fade = smoothstep(0., 1., timeline);\n    float sphere_fade = smoothstep(2., 3., timeline);\n    float point_fade = smoothstep(17., 16., timeline);\n    float mirror_fade = smoothstep(9., 10., timeline)*smoothstep(20., 19., timeline);\n    float cut_fade = abs(uv.x) > uv.y ? smoothstep(14., 13., timeline) : 1.;\n    float rep_fade = smoothstep(16., 17., timeline+uv.y*.1);\n    float sector_pulse = smoothstep(.5,0.,abs(timeline-13.5));\n    \n    col += antialias(min(abs(uv.x), abs(uv.y)))*.33*axis_fade; //axes\n    col += antialias(abs(abs(uv.x)-abs(uv.y))/sqrt(2.))*.66*mirror_fade; //mirror axes\n    col += antialias(abs(uv.x)-uv.y)*.2*sector_pulse; //sector to be mirrored\n    col += antialias(length(uv+vec2(0, sharpness))-.01)*sphere_fade*point_fade; //circle center\n\tcol += antialias(abs(length(uv+vec2(0, sharpness))-radius-sharpness))*sphere_fade*cut_fade*(1.-rep_fade); //circle\n    vec2 uv_mapped = abs(uv); if (uv_mapped.x > uv_mapped.y) uv_mapped = uv_mapped.yx;\n    col += antialias(abs(length(uv_mapped+vec2(0, sharpness))-radius-sharpness))*rep_fade; //mirrored circle\n\n\tfragColor = vec4(col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc0-1.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ws2BRW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ws2BRy", "name": "Experiment all 01", "author": "Stenator", "description": "some experiment :)", "tags": ["noise"], "likes": 2, "viewed": 35, "date": "1590317477", "time_retrieved": "2024-06-20T20:08:47.709429", "image_code": "\nvec3 v_normal;\nvec2 v_texcoord;\n\n\n\nfloat random (in vec2 x){\nfloat rand = fract(sin(dot(x,vec2(12.558585,50.2525)))* 42478.555745) ;\nreturn rand;\n}\n\n\nfloat noise2d (in vec2 pos) {\n\n    vec2 ipos = floor(pos);\n    vec2 fpos = fract(pos);\n\nfloat a = random(ipos);\nfloat b = random(ipos+vec2(1.,0.));\nfloat c = random(ipos+vec2(0.,1.));\nfloat d = random(ipos+vec2(1.,1.));\n\nvec2 u= smoothstep(0.,1.,fpos); \nreturn mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n\n\n\nfloat Rectangle ( vec2 position, vec2 uv, vec2 taille,float blur) {\n\nuv *=   1. + position;\nvec2 rectanglehaut = smoothstep(taille * blur, taille,uv);\nvec2 rectanglebas = smoothstep(taille * blur, taille, 1.-uv);\n\nfloat rectangle= rectanglebas.y *rectanglebas.x * rectanglehaut.y * rectanglehaut.x;\nreturn rectangle;\n}\n\n\nfloat sharpRectangle (vec2 position, vec2 uv, vec2 taille) {\n\n\nfloat noise = noise2d((vec2(uv.x,uv.y+iTime))*50.);\nfloat noisemoins = noise2d(uv*(9.* (0.8*iTime)));\nfloat noiseplus = noise2d(uv*500.);\nfloat rectangle = Rectangle(position, uv, taille, float (1.0001));\nfloat blurRectangle = 1.- Rectangle(position, uv  , taille*0.86, float (1.4));\nrectangle = pow(noise*noiseplus,blurRectangle*(4.*noisemoins));\n\nreturn rectangle;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 uv = gl_FragCoord.xy / iResolution.xy;\n    \n    vec2 pos = uv *100.;\n    \n    float noise= noise2d(pos);\n    \n    \n    vec3 color = vec3 (sharpRectangle(vec2 (0.), uv, vec2(0.65,0.89)));\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ws2BRy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ws2BWD", "name": "Fractal pocho", "author": "makaronsito", "description": "No saber, no reÃ­r T-T", "tags": ["3d", "fractal"], "likes": 2, "viewed": 260, "date": "1590098847", "time_retrieved": "2024-06-20T20:08:48.091182", "image_code": "//constantes para el march tracing\nconst float MIN_DIST = 0.01;\nconst float MAX_DIST = 1000.;\nconst int MAX_MARCH = 500;\n//altura a la que se encuentra un plano que hace de suelo\nconst float groundHeight = 0.;\n//definimos una esfera con una posiciÃ³n y radio, debe caber en nuestra celda unidad\nconst vec3 bola = vec3(0, 1, .7);\nconst float radio = 0.5;\n//distancia entre bolas duplicadas eternamente, la arista de la celda unidad\nconst float cellS = 5.;\n\n//devuelve el resto de la divisiÃ³n con el signo de x\nvec3 rep(vec3 pos, float spa){\n\treturn mod(pos+spa/2.,spa)-spa/2.;\n}\n\n//se encarga de hallar el punto mÃ¡s cercano perteneciente a cualquier objeto que se encuentre en escena\n//en este momento solo hay un plano y una esfera, la menor de las distancias es la devuelta por la funciÃ³n\n//tambiÃ©n devuelte una tonalidad de rojo para distinguir un objeto de otro\nvec2 getDistance(vec3 pos){\n\tfloat diff = 0.;\n\tfloat col = 0.;\n\tfloat diffG = abs(pos.y-groundHeight);\n\t\n\tfloat diffC = length(rep(pos,cellS)-bola) - radio;\n\t\n\tif (diffC > diffG){\n        col = 1.;\n\t\tdiff = diffG;\n\t}\n\telse{\n\t\tdiff = diffC;\n\t}\n\t\t\n\treturn vec2(abs(diffC), col);\n}\n\n//calcula la distancia y con ella determina lo vivo que es el color, si se pasa de la \"rayo\" devuelve color blanco\n//si da contra algo devuelve un color que estÃ¡ objetivamente mal y no proporciona informaciÃ³n asÃ­ que mola\nvec3 rayMarch(vec3 dir, vec3 pos){\n\tfloat dist = 0.;\n\tfor (int i = 0; i < MAX_MARCH; i++){\n\t\tvec2 res = getDistance(pos);\n\t\tfloat surfDist = res.x;\n\t\tpos += dir * surfDist;\n\t\tdist += surfDist;\n\t\t\n\t\t//if it's\t BUT \tit's not\n\t\tif (surfDist < MIN_DIST){\n\t\t\tfloat coef = dist/MAX_DIST;\n\t\t\treturn vec3(res.y, coef, coef);\n\t\t}\n        else{\n            if (i == MAX_MARCH-1 || dist > MAX_DIST)\n\t\t\treturn vec3(1);\n        }\n\t}\n}\n\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 relUV = vec2(uv.x-0.5,uv.y-0.5);\t// \"centramos\" las coordenadas UV en el centro de la textura en vez de la esquina\n    vec3 rotPixel = normalize(vec3(relUV.x*iResolution.x/iResolution.y, relUV.y, 1));\t// vector direcciÃ³n para cada rayo\n    vec3 camPos = vec3(cos(iTime)*4.,sin(iTime)*4.,(iTime)*20.2);//owo y paz\t// posiciÃ³n cÃ¡mara, mov armÃ³nico simple en relaciÃ³n al tiempo no tiene pÃ©rdida\n\tfragColor = vec4(rayMarch(rotPixel,camPos),1.0);\t// ahÃ­ va el colorsito\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ws2BWD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ws2Bzc", "name": "Raymarching with random colors", "author": "jarble", "description": "I used a hash function to color the surface of this raymarched 3D object.", "tags": ["raymarching", "hash"], "likes": 3, "viewed": 196, "date": "1590532569", "time_retrieved": "2024-06-20T20:08:49.770258", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n/**\n * Part 6 Challenges:\n * - Make a scene of your own! Try to use the rotation transforms, the CSG primitives,\n *   and the geometric primitives. Remember you can use vector subtraction for translation,\n *   and component-wise vector multiplication for scaling.\n */\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\nvec3 hash33(vec3 p3)\n{\t\n    //this is from https://www.shadertoy.com/view/4djSRW\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n/**\n * Rotation matrix around the X axis.\n */\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n/**\n * Rotation matrix around the Y axis.\n */\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n/**\n * Rotation matrix around the Z axis.\n */\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n/**\n * Constructive solid geometry intersection operation on SDF-calculated distances.\n */\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\n/**\n * Constructive solid geometry union operation on SDF-calculated distances.\n */\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\n/**\n * Constructive solid geometry difference operation on SDF-calculated distances.\n */\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n/**\n * Signed distance function for a cube centered at the origin\n * with dimensions specified by size.\n */\nfloat boxSDF(vec3 p, vec3 size) {\n    vec3 d = abs(p) - (size / 2.0);\n    \n    // Assuming p is inside the cube, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    \n    // Assuming p is outside the cube, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\n/**\n * Signed distance function for a sphere centered at the origin with radius r.\n */\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\n/**\n * Signed distance function for an XY aligned cylinder centered at the origin with\n * height h and radius r.\n */\nfloat cylinderSDF(vec3 p, float h, float r) {\n    // How far inside or outside the cylinder the point is, radially\n    float inOutRadius = length(p.xy) - r;\n    \n    // How far inside or outside the cylinder is, axially aligned with the cylinder\n    float inOutHeight = abs(p.z) - h/2.0;\n    \n    // Assuming p is inside the cylinder, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(inOutRadius, inOutHeight), 0.0);\n\n    // Assuming p is outside the cylinder, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(vec2(inOutRadius, inOutHeight), 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {    \n    // Slowly spin the whole scene\n    samplePoint = rotateY(iTime / 2.0) * samplePoint;\n    \n    float cylinderRadius = 0.4 + (1.0 - 0.4) * (1.0 + sin(1.7 * iTime)) / 2.0;\n    float cylinder1 = cylinderSDF(samplePoint, 2.0, cylinderRadius);\n    float cylinder2 = cylinderSDF(rotateX(radians(90.0)) * samplePoint, 2.0, cylinderRadius);\n    float cylinder3 = cylinderSDF(rotateY(radians(90.0)) * samplePoint, 2.0, cylinderRadius);\n    \n    float cube = boxSDF(samplePoint, vec3(1.8, 1.8, 1.8));\n    \n    float sphere = sphereSDF(samplePoint, 1.2);\n    \n    float ballOffset = 0.4 + 1.0 + sin(1.7 * iTime);\n    float ballRadius = 0.3;\n    float balls = sphereSDF(samplePoint - vec3(ballOffset, 0.0, 0.0), ballRadius);\n    balls = unionSDF(balls, sphereSDF(samplePoint + vec3(ballOffset, 0.0, 0.0), ballRadius));\n    balls = unionSDF(balls, sphereSDF(samplePoint - vec3(0.0, ballOffset, 0.0), ballRadius));\n    balls = unionSDF(balls, sphereSDF(samplePoint + vec3(0.0, ballOffset, 0.0), ballRadius));\n    balls = unionSDF(balls, sphereSDF(samplePoint - vec3(0.0, 0.0, ballOffset), ballRadius));\n    balls = unionSDF(balls, sphereSDF(samplePoint + vec3(0.0, 0.0, ballOffset), ballRadius));\n    \n    \n    \n    float csgNut = differenceSDF(intersectSDF(cube, sphere),\n                         unionSDF(cylinder1, unionSDF(cylinder2, cylinder3)));\n    \n    return unionSDF(balls, csgNut);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(8.0, 5.0 * sin(0.2 * iTime), 7.0);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = hash33(p/500.0);\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ws2Bzc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ws2Bzw", "name": ".-=its a skurr=-.", "author": "im_paul_hi", "description": ".-=CANADIAN REGGAE AUDIO VISUALIZER=-.\n\nYou have to hit pause, then back, then play to make it play it seems?  Or am i doing it wrong?\n\nsounds:  Venetian Snares - Sugarbush", "tags": ["audio"], "likes": 11, "viewed": 291, "date": "1589739265", "time_retrieved": "2024-06-20T20:08:54.709989", "image_code": "/*\nprecision highp float;\nuniform vec2 iResolution;\nuniform float iTime;\nuniform float mod1;\nuniform float mod2;\nuniform float mod3;\nuniform float mod4;\nuniform float mod5;\nuniform float mod6;\nuniform float mod7;\nuniform float mod8;\nuniform float mod9;\n*/\n\n/*\n    -sdf functions from iq   \n    \n\n*/\n\n// https://www.shadertoy.com/view/MsjXRt\nvec4 HueShift (in vec3 Color, in float Shift)\n{\n    vec3 P = vec3(0.55735)*dot(vec3(0.55735),Color);\n    \n    vec3 U = Color-P;\n    \n    vec3 V = cross(vec3(0.55735),U);    \n\n    Color = U*cos(Shift*6.2832) + V*sin(Shift*6.2832) + P;\n    \n    return vec4(Color,1.0);\n}\n\n//\n// GLSL textureless classic 2D noise \"cnoise\",\n// with an RSL-style periodic variant \"pnoise\".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec2 fade(vec2 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec2 P)\n{\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod289(Pi); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute(permute(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n  vec4 gy = abs(gx) - 0.5 ;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\n// https://www.shadertoy.com/view/4dsSzr\nvec3 ansiGradient(float t) {\n\treturn mod(floor(t * vec3(8.0, 4.0, 2.0)), 2.0);\n}\n\n// #define AA 0.005\n#define PI 3.14159\n#define TAU 2.0 * PI\n#define gridThickness 0.05\n\nvec3 headColor = vec3(0.45,0.21,0.67);\nvec3 bgColor = vec3(0.95,0.92,0.99);\nvec3 headGooColor = vec3(0.87,0.56,0.40);\nvec3 blackOutlineColor = vec3(0.23,0.24,0.21);\nvec3 gearCol1 = vec3(0.44,0.48,0.80);\nvec3 gearCol2 = vec3(0.36,0.83,0.99);\nvec3 col = vec3(0.95,0.92,0.99);\nfloat blackOutlineWidth = 0.02;\nvec3 mixedCol = vec3(0.0);\nfloat AA = 0.005;\n\n/*********************************************************\n**********************************************************\n**********************************************************\n**********************************************************/\n\nfloat linearStep(float begin, float end, float t) {\n    return clamp((t - begin) / (end - begin), 0.0, 1.0);\n}\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nvec2 within(vec2 uv, vec4 rect) {\n    vec2 val = (uv-rect.xy)/(rect.zw-rect.xy);\n    // val.y = remap(val.y, 0.0, 1.0, 1.0, 0.0);\n    val.y = -val.y + 1.0;\n\treturn val;\n}\n\nfloat inside01(vec2 p) {\n    return step(0.0, p.x) * (1.0 - step(1.0, p.x)) * step(0.0, p.y) * (1.0 - step(1.0, p.y));\n}\n\nfloat insideY(vec2 p) {\n    return step(0.0, p.y) * (1.0 - step(1.0, p.y));\n}\n\nfloat insideX(vec2 p) {\n    return step(0.0, p.x) * (1.0 - step(1.0, p.x));\n}\n\nvoid addGrid(vec2 p, inout vec3 col) {\n    float all = inside01(p);\n    vec3 gridOutlineCol = vec3(1.0, 0.0, 0.0);\n    vec3 gridCol = vec3(0.0);\n\n    // add outline\n    float outline = step(p.x, gridThickness);\n    outline += step(1.0 - gridThickness, p.x);\n    outline += step(p.y, gridThickness);\n    outline += step(1.0 - gridThickness, p.y);\n\n    // p.y = -p.y;\n    // p.y += 1.0;\n\n    // float outline = step(0.0, p.y) * (1.0 - step(0.1, p.y));\n\n    col = mix(col, gridOutlineCol, outline * all);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nvec3 returnDottedCol(vec2 p, vec3 bgCol, vec3 dotCol) {\n    vec3 dottedCol = vec3(0.0);\n\n    p *= 28.0;\n    p.x += 0.48;\n    p.y *= 2.49;\n    float yIndex = floor(p.y);\n    float xIndex = floor(p.x);\n    p = fract(p);\n\n    // float circle = smoothstep(mod1, mod2, length(p - vec2(0.5)));\n    // circle *= smoothstep(mod3, mod4, length(p - vec2(1.0, 0.0)));\n\n    float circleBool = 0.0;\n\n    float circle = smoothstep(0.3, 0.6, length(p - vec2(0.5)));\n\n    if(mod(xIndex, 2.0) == 0.0 && mod(yIndex, 2.0) == 0.0) {\n        circleBool = 0.0;\n    } else if(mod(xIndex, 2.0) != 0.0 && mod(yIndex, 2.0) == 0.0) {\n        circleBool = 1.0;\n    } else if(mod(xIndex, 2.0) == 0.0 && mod(yIndex, 2.0) != 0.0) {\n        circleBool = 1.0;\n    }\n\n    dottedCol = mix(bgCol, dotCol, (1.0 - circle) * circleBool);\n\n    return dottedCol;\n}\n\nfloat gain(float x, float k) \n{\n    float a = 0.5*pow(2.0*((x<0.5)?x:1.0-x), k);\n    return (x<0.5)?a:1.0-a;\n}\n\nfloat expImpulse( float x, float k )\n{\n    float h = k*x;\n    return h*exp(1.0-h);\n}\n\nfloat customEase(float x, float k) {\n    return pow(x, k);\n}\n\nfloat almostIdentity( float x, float m, float n )\n{\n    if( x>m ) return x;\n    float a = 2.0*n - m;\n    float b = 2.0*m - 3.0*n;\n    float t = x/m;\n    return (a*t + b)*t*t + n;\n}\n\nfloat undulateAngle(int index, float angle, float movementScale, float offsetScale, float timeScale) {\n    float offset = float(index) * offsetScale;\n    float m = angle + sin(iTime * timeScale + offset) * movementScale;\n    return m;\n}\n\n\n\n/*********************************************************\n**********************************************************\n**********************************************************\n**********************************************************/\n\nfloat sdCircle( in vec2 p, in float r ) \n{\n    return length(p)-r;\n}\n\nfloat sdCross( in vec2 p, in vec2 b, float r ) \n{\n    p = abs(p); p = (p.y>p.x) ? p.yx : p.xy;\n    vec2  q = p - b;\n    float k = max(q.y,q.x);\n    vec2  w = (k>0.0) ? q : vec2(b.y-p.x,-k);\n    return sign(k)*length(max(w,0.0)) + r;\n}\n\n\n\nfloat returnTween4Dist(vec2 p, float t, float circleRadius) {\n    // t = normalized time\n    vec2 from = vec2(0.5, 0.66);\n    vec2 to = vec2(0.5, 0.3);\n    float radius = (from.y - to.y) / 2.0;\n    float startAngle = (3.0 * PI) / 2.0;\n    float endAngle = PI;\n    float angle = map(t, 0.0, 1.0, startAngle, endAngle);\n    float angleOffset = -PI * 2.0;\n    // cycle through angle based on t\n    vec2 pos = vec2(sin(angle + angleOffset) * radius, cos(angle + angleOffset) * radius);\n    pos += 0.5;\n    float d = sdCircle(p - pos, circleRadius);\n    return d;\n}\n\nfloat returnTween5Dist(vec2 p, float t, float circleRadius) {\n    // t = normalized time\n    vec2 from = vec2(0.5, 0.32);\n    vec2 to = vec2(0.5, -0.3);\n    vec2 pos = mix(from, to, t);\n    float d = sdCircle(p - pos, circleRadius);\n    return d;\n}\n\nfloat returnTween1Dist(vec2 p, float t, float circleRadius) {\n    // t = normalized time\n    vec2 from = vec2(0.5, 1.0);\n    vec2 to = vec2(0.5, 0.66);\n    vec2 pos = mix(from, to, t);\n    float d = sdCircle(p - pos, circleRadius);\n    return d;\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvoid makeSecondSwoop(vec2 p, inout float d, float loopTime, inout vec3 col, float time) {\n    p -= vec2(0.28, 0.02);\n    // p -= vec2(0.58, 0.02);  // debug view\n\n    for(int i = 0; i < 5; i++) {\n        float d1 = 0.0;\n        float margin = sin(float(i) + time) * 1.0;\n        float modTime = fract((time + margin) / loopTime);\n        float circleRadius = map(modTime, 0.0, 1.0, 0.0, 0.15);\n\n        if(modTime < 0.5) {\n            d1 = returnTween4Dist(p, linearStep(0.0, 0.5, modTime), circleRadius);\n        } else {\n            d1 = returnTween5Dist(p, linearStep(0.5, 1.0, modTime), circleRadius);\n        }\n       \n        // d1 = smoothstep(0.0, AA, d1);\n        // col = mix(col, vec3(1.0), 1.0 - d1);\n\n        if(i != 0) {\n            d = opSmoothUnion(d, d1, 0.04);\n        }\n    }\n}\n\nfloat returnTween2Dist(vec2 p, float t, float circleRadius) {\n    // t = normalized time\n    vec2 from = vec2(0.5, 0.66);\n    vec2 to = vec2(0.5, 0.33);\n    float radius = (from.y - to.y) / 2.0;\n    float startAngle = PI / 2.0;\n    float endAngle = (3.0 * PI) / 2.0;\n    float angle = map(t, 0.0, 1.0, startAngle, endAngle);\n    float angleOffset = -PI * 0.5;\n    // cycle through angle based on t\n    vec2 pos = vec2(sin(angle + angleOffset) * radius, cos(angle + angleOffset) * radius);\n    pos += 0.5;\n    float d = sdCircle(p - pos, circleRadius);\n    return d;\n}\n\nfloat returnTween3Dist(vec2 p, float t, float circleRadius) {\n    // t = normalized time\n    vec2 from = vec2(0.5, 0.33);\n    vec2 to = vec2(0.66, -0.1);\n    vec2 pos = mix(from, to, t);\n    float d = sdCircle(p - pos, circleRadius);\n    return d;\n}\n\nfloat sdBox( in vec2 p, in vec2 b, float r)\n{\n    vec2 d = abs(p) - (b - r);\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r;\n}\n\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdUnevenCapsule( vec2 p, float r1, float r2, float h )\n{\n    p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}\n\n\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat sdRoundBox( in vec2 p, in vec2 b, in vec4 r ) \n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    \n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat dot2(in vec2 v ) { return dot(v,v); }\n\n// trapezoid / capped cone, specialized for Y alignment\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n\n\tp.x = abs(p.x);\n    vec2 ca = vec2(max(0.0,p.x-((p.y<0.0)?r1:r2)), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    \n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, float rb )\n{\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p.xy,scb) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0/dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx-3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h,-h)-q)/2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );\n        res = dot2(d + (c + b*t)*t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);\n        res = min( dot2(d+(c+b*t.x)*t.x),\n                   dot2(d+(c+b*t.y)*t.y) );\n        // the third root cannot be the closest\n        // res = min(res,dot2(d+(c+b*t.z)*t.z));\n    }\n    return sqrt( res );\n}\n\n/*********************************************************\n**********************************************************\n**********************************************************\n**********************************************************/\n\n\n\n\nvoid bg(vec2 p, inout vec3 col, vec2 origP) {\n    // col = mix(col, vec3(0.90,0.76,0.34), map(origP.y, 0.39, 0.74, 0.0, 1.0));\n\n    // col = mix(col, vec3(0.76,0.78,0.53), map(origP.y, -0.09, -0.59, 0.0, 1.0));\n}\n\nvoid cranium(vec2 p, inout vec3 col, vec2 origP) {\n    float d = 0.0;\n    float d1 = 0.0;\n    float d2 = 0.0;\n    float d3 = 0.0;\n    float r = 0.0;\n    vec2 modP = vec2(0.0);\n    vec3 mixedCol = vec3(0.0);\n    float modTime = 0.0;\n    float loopTime = 0.0;\n    float n = 0.0;\n    float m = 0.0;\n\n    // testing noise - looks great!\n    // modP = vec2(origP.x, origP.y) * 0.6;\n    // p = vec2(p.x, p.y);\n    // n = cnoise(modP * 10.0) * 0.02;\n    // modP.x += n;\n    // modP.y -= n;\n    // p.x += n;\n    // p.y -= n;\n\n    \n    //////////////////\n    // lower layers LEWWWWWWWP\n    //////////////////\n    for(int i = 0; i < 10; i++) {\n        float loopTime = 2.0;\n        float iVal = float(i);\n        float totalI = 10.0;\n        float maxScale = 4.0 + (sin(iTime + iVal) * 0.05);\n        float minScale = 0.1 - (sin(iTime + iVal) * 0.05);\n        //////////////////\n        // outline\n        //////////////////\n        // cranium circle\n        modP = vec2(origP.x, origP.y);\n        modP = rotate2d(sin(iTime + iVal) * 0.05) * modP;\n        float borderSize = (0.05 * (iVal / totalI)) * sin(iTime * 2.0 + iVal) + 0.05;\n        modP /= map(iVal, 0.0, totalI, maxScale, minScale) + borderSize;\n        d = sdCircle(modP - vec2(0.0, 0.1), 0.59);\n        d1 = sdBox(modP - vec2(0.07, 0.96), vec2(0.41, 0.13), -0.07);\n        d = opSmoothSubtraction(d1, d, 0.26);\n        // mandible box\n        d1 = sdBox(modP - vec2(0.0, -0.37), vec2(0.33, 0.33), 0.11);\n        d = opSmoothUnion(d, d1, 0.22);\n        // zygomatic indents\n        modP = vec2(p.x, p.y);\n        modP /= map(iVal, 0.0, totalI, maxScale, minScale) + borderSize;\n        d1 = sdCircle(modP - vec2(0.74, -0.5), 0.39);\n        d = opSmoothSubtraction(d1, d, 0.15);\n        // eye socket protrusions\n        d1 = sdRoundBox(modP - vec2(0.34, -0.22), vec2(0.22, 0.2), vec4(0.07, 0.11, 0.22, 0.22));\n        d = opSmoothUnion(d, d1, 0.04);\n        // zygomatic indents\n        d1 = sdCircle(modP - vec2(0.41, -0.46), 0.04);\n        d = opSmoothSubtraction(d1, d, 0.04);\n        // temple indents\n        d1 = sdCircle(modP - vec2(0.7, -0.17), 0.15);\n        d = opSmoothSubtraction(d1, d, 0.02);\n        d = smoothstep(0.0, AA, d);\n        col = mix(col, blackOutlineColor, 1.0 - d);\n        //////////////////\n        // color\n        //////////////////\n        // cranium circle\n        modP = vec2(origP.x, origP.y);\n        modP /= map(iVal, 0.0, totalI, maxScale, minScale);\n        d = sdCircle(modP - vec2(0.0, 0.1), 0.59);\n        d1 = sdBox(modP - vec2(0.07, 0.96), vec2(0.41, 0.13), -0.07);\n        d = opSmoothSubtraction(d1, d, 0.26);\n        // mandible box\n        d1 = sdBox(modP - vec2(0.0, -0.37), vec2(0.33, 0.33), 0.11);\n        d = opSmoothUnion(d, d1, 0.22);\n        // zygomatic indents\n        modP = vec2(p.x, p.y);\n        modP /= map(iVal, 0.0, totalI, maxScale, minScale);\n        d1 = sdCircle(modP - vec2(0.74, -0.5), 0.39);\n        d = opSmoothSubtraction(d1, d, 0.15);\n        // eye socket protrusions\n        d1 = sdRoundBox(modP - vec2(0.34, -0.22), vec2(0.22, 0.2), vec4(0.07, 0.11, 0.22, 0.22));\n        d = opSmoothUnion(d, d1, 0.04);\n        // zygomatic indents\n        d1 = sdCircle(modP - vec2(0.41, -0.46), 0.04);\n        d = opSmoothSubtraction(d1, d, 0.04);\n        // temple indents\n        d1 = sdCircle(modP - vec2(0.7, -0.17), 0.15);\n        d = opSmoothSubtraction(d1, d, 0.02);\n        d = smoothstep(0.0, AA, d);\n        col = mix(col, ansiGradient(iVal / totalI), 1.0 - d);\n    }\n    \n\n    \n\n//////////////////////////////////////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////////////\n    \n    /////////////////\n    // blackbottom\n    ////////////////\n    // cranium circle\n    d = sdCircle(origP - vec2(0.0, 0.1), 0.59);\n    d1 = sdBox(origP - vec2(0.07, 0.96), vec2(0.41, 0.13), -0.07);\n    d = opSmoothSubtraction(d1, d, 0.26);\n    // mandible box\n    d1 = sdBox(origP - vec2(0.0, -0.37), vec2(0.33, 0.33), 0.11);\n    d = opSmoothUnion(d, d1, 0.22);\n    // zygomatic indents\n    d1 = sdCircle(p - vec2(0.74, -0.5), 0.39);\n    d = opSmoothSubtraction(d1, d, 0.15);\n    // eye socket protrusions\n    d1 = sdRoundBox(p - vec2(0.34, -0.22), vec2(0.22, 0.2), vec4(0.07, 0.11, 0.22, 0.22));\n    d = opSmoothUnion(d, d1, 0.04);\n    // zygomatic indents\n    d1 = sdCircle(p - vec2(0.41, -0.46), 0.04);\n    d = opSmoothSubtraction(d1, d, 0.04);\n    // temple indents\n    d1 = sdCircle(p - vec2(0.7, -0.17), 0.15);\n    d = opSmoothSubtraction(d1, d, 0.02);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n\n    \n\n    ////////////////\n    // color\n    ///////////////\n    // cranium circle\n    d = sdCircle(origP - vec2(0.0, 0.1), 0.57);\n    d1 = sdBox(origP - vec2(0.07, 0.96), vec2(0.41, 0.13), -0.07);\n    d = opSmoothSubtraction(d1, d, 0.26);\n    // mandible box\n    d1 = sdBox(origP - vec2(0.0, -0.37), vec2(0.3, 0.3), 0.11);\n    d = opSmoothUnion(d, d1, 0.22);\n    // zygomatic indents\n    d1 = sdCircle(p - vec2(0.74, -0.5), 0.41);\n    d = opSmoothSubtraction(d1, d, 0.15);\n    // eye socket protrusions\n    d1 = sdRoundBox(p - vec2(0.34, -0.22), vec2(0.20, 0.18), vec4(0.07, 0.11, 0.22, 0.22));\n    d = opSmoothUnion(d, d1, 0.04);\n    // zygomatic indents\n    d1 = sdCircle(p - vec2(0.41, -0.46), 0.06);\n    d = opSmoothSubtraction(d1, d, 0.04);\n    // temple indents\n    d1 = sdCircle(p - vec2(0.7, -0.17), 0.17);\n    d = opSmoothSubtraction(d1, d, 0.02);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, vec3(0.82,0.87,0.85), 1.0 - d);\n\n    // eye socket black bottom\n    d = sdCircle(p - vec2(0.26, -0.11), 0.2);\n    // eye socket subtraction\n    d1 = sdCircle(p - vec2(0.46, 0.26), 0.28);\n    d = opSmoothSubtraction(d1, d, 0.10);\n    d1 = sdCircle(p - vec2(0.26, -0.46), 0.17);\n    d = opSmoothSubtraction(d1, d, 0.02);\n    modP = vec2(p.x, p.y);\n    modP = rotate2d(0.61 * TAU) * modP;\n    d1 = sdBox(modP - vec2(0.28, 0.3), vec2(0.24, 0.26), 0.04);\n    d = opSmoothSubtraction(d1, d, 0.02);\n    modP = vec2(p.x, p.y);\n    modP = rotate2d(0.5 * TAU) * modP;\n    d1 = sdBox(modP - vec2(0.04, 0.8), vec2(0.09, 1.0), 0.26);\n    d = opSmoothSubtraction(d1, d, 0.15);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n\n    // eye socket color\n    d = sdCircle(p - vec2(0.26, -0.11), 0.18);\n    // eye socket subtraction\n    d1 = sdCircle(p - vec2(0.46, 0.26), 0.28);\n    d = opSmoothSubtraction(d1, d, 0.10);\n    d1 = sdCircle(p - vec2(0.26, -0.46), 0.17);\n    d = opSmoothSubtraction(d1, d, 0.02);\n    modP = vec2(p.x, p.y);\n    modP = rotate2d(0.61 * TAU) * modP;\n    d1 = sdBox(modP - vec2(0.28, 0.3), vec2(0.24, 0.26), 0.04);\n    d = opSmoothSubtraction(d1, d, 0.04);\n    modP = vec2(p.x, p.y);\n    modP = rotate2d(0.5 * TAU) * modP;\n    d1 = sdBox(modP - vec2(0.04, 0.8), vec2(0.09, 1.0), 0.26);\n    d = opSmoothSubtraction(d1, d, 0.15);\n    d1 = sdCircle(origP - vec2(0.13, -0.22), 0.07);\n    d = opSmoothSubtraction(d1, d, 0.04);\n    d1 = sdCircle(vec2(origP.x * -1.0, origP.y) - vec2(0.105, -0.22), 0.07);\n    d = opSmoothSubtraction(d1, d, 0.04);\n    d = smoothstep(0.0, AA, d);\n    mixedCol = mix(blackOutlineColor, vec3(0.85,0.65,0.68), smoothstep(-0.17, 0.43, length(vec2(p.x, p.y + 0.3))));\n    col = mix(col, mixedCol, 1.0 - d);\n\n\n\n    // nose socket black\n    d = sdSegment(p, vec2(0.0, -0.26), vec2(0.05, -0.39)) - 0.05;\n    d1 = sdSegment(p, vec2(-0.02, -0.37 - 0.11), vec2(0.0, -0.7 - 0.11)) - 0.02;\n    d = opSmoothSubtraction(d1, d, 0.13);\n    // d1 = sdCircle(p - vec2(mod1, mod2), mod3);\n    // d = opSmoothUnion(d1, d, mod4);\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n\n\n\n\n    // teeth\n    modP = vec2(origP.x, origP.y) * 0.8;\n    n = cnoise(modP * 10.0) * 0.02; \n    modP.x += n;\n    modP.y -= n;\n    modP *= 1.7;\n    d = sdSegment(modP, vec2(-0.09+0.0, -1.2 + 0.22), vec2(-0.09+0.0, -1.14 + 0.22)) - 0.04;\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    modP = vec2(origP.x, origP.y) * 0.8;\n    n = cnoise(modP * 10.0) * 0.02; \n    modP.x += n;\n    modP.y -= n;\n    modP *= 1.7;\n    d = sdSegment(modP, vec2(-0.09+0.0, -1.2 + 0.22), vec2(-0.09+0.0, -1.14 + 0.22)) - 0.03;\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, vec3(0.99,0.94,0.81), 1.0 - d);\n    modP = vec2(origP.x, origP.y) * 0.8;\n    n = cnoise(modP * 10.0) * 0.02; \n    modP.x += n;\n    modP.y -= n;\n    modP *= 1.7;\n    d = sdSegment(modP, vec2(-0.09 + 0.065, -1.2 + 0.22), vec2(-0.09 + 0.065, -1.14 + 0.22)) - 0.04;\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    modP = vec2(origP.x, origP.y) * 0.8;\n    n = cnoise(modP * 10.0) * 0.02; \n    modP.x += n;\n    modP.y -= n;\n    modP *= 1.7;\n    d = sdSegment(modP, vec2(-0.09 + 0.065, -1.2 + 0.22), vec2(-0.09 + 0.065, -1.14 + 0.22)) - 0.03;\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, vec3(0.99,0.94,0.81), 1.0 - d);\n    //\n    modP = vec2(origP.x, origP.y) * 0.8;\n    n = cnoise(modP * 10.0) * 0.02; \n    modP.x += n;\n    modP.y -= n;\n    modP *= 1.7;\n    d = sdSegment(modP, vec2(-0.09+0.15, -1.2 + 0.22), vec2(-0.09+0.15, -1.14 + 0.22)) - 0.04;\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    modP = vec2(origP.x, origP.y) * 0.8;\n    n = cnoise(modP * 10.0) * 0.02; \n    modP.x += n;\n    modP.y -= n;\n    modP *= 1.7;\n    d = sdSegment(modP, vec2(-0.09+0.15, -1.2 + 0.22), vec2(-0.09+0.15, -1.14 + 0.22)) - 0.03;\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, vec3(0.99,0.94,0.81), 1.0 - d);\n    //\n    modP = vec2(origP.x, origP.y) * 0.8;\n    n = cnoise(modP * 10.0) * 0.02; \n    modP.x += n;\n    modP.y -= n;\n    modP *= 1.7;\n    d = sdSegment(modP, vec2(-0.09+0.22, -1.2 + 0.22), vec2(-0.09+0.22, -1.14 + 0.22)) - 0.04;\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    modP = vec2(origP.x, origP.y) * 0.8;\n    n = cnoise(modP * 10.0) * 0.02; \n    modP.x += n;\n    modP.y -= n;\n    modP *= 1.7;\n    d = sdSegment(modP, vec2(-0.09+0.22, -1.2 + 0.22), vec2(-0.09+0.22, -1.14 + 0.22)) - 0.03;\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, vec3(0.99,0.94,0.81), 1.0 - d);\n    //\n    modP = vec2(origP.x, origP.y) * 0.8;\n    n = cnoise(modP * 10.0) * 0.02; \n    modP.x += n;\n    modP.y -= n;\n    modP *= 1.7;\n    d = sdSegment(modP, vec2(-0.09+0.28, -1.2 + 0.22), vec2(-0.09+0.28, -1.14 + 0.22)) - 0.04;\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    modP = vec2(origP.x, origP.y) * 0.8;\n    n = cnoise(modP * 10.0) * 0.02; \n    modP.x += n;\n    modP.y -= n;\n    modP *= 1.7;\n    d = sdSegment(modP, vec2(-0.09+0.28, -1.2 + 0.22), vec2(-0.09+0.28, -1.14 + 0.22)) - 0.03;\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, vec3(0.99,0.94,0.81), 1.0 - d);\n    //\n    modP = vec2(origP.x, origP.y) * 0.8;\n    n = cnoise(modP * 10.0) * 0.02; \n    modP.x += n;\n    modP.y -= n;\n    modP *= 1.7;\n    d = sdSegment(modP, vec2(-0.09+0.41, -1.2+0.24), vec2(-0.09+0.41, -1.14+0.24)) - 0.04;\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    modP = vec2(origP.x, origP.y) * 0.8;\n    n = cnoise(modP * 10.0) * 0.02; \n    modP.x += n;\n    modP.y -= n;\n    modP *= 1.7;\n    d = sdSegment(modP, vec2(-0.09+0.41, -1.2+0.24), vec2(-0.09+0.41, -1.14+0.24)) - 0.03;\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, vec3(0.99,0.94,0.81), 1.0 - d);\n    //\n    modP = vec2(origP.x, origP.y) * 0.8;\n    n = cnoise(modP * 10.0) * 0.02; \n    modP.x += n;\n    modP.y -= n;\n    modP *= 1.7;\n    d = sdSegment(modP, vec2(-0.09+0.48, -1.2 + 0.22 + 0.04), vec2(-0.09+0.48, -1.14 + 0.22 + 0.04)) - 0.04;\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    modP = vec2(origP.x, origP.y) * 0.8;\n    n = cnoise(modP * 10.0) * 0.02; \n    modP.x += n;\n    modP.y -= n;\n    modP *= 1.7;\n    d = sdSegment(modP, vec2(-0.09+0.48, -1.2 + 0.22 + 0.04), vec2(-0.09+0.48, -1.14 + 0.22 + 0.04)) - 0.03;\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, vec3(0.99,0.94,0.81), 1.0 - d);\n    //\n    modP = vec2(origP.x, origP.y) * 0.8;\n    n = cnoise(modP * 10.0) * 0.02; \n    modP.x += n;\n    modP.y -= n;\n    modP *= 1.7;\n    d = sdSegment(modP, vec2(-0.09+0.35, -1.2 + 0.22), vec2(-0.09+0.35, -1.14 + 0.22)) - 0.04;\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    modP = vec2(origP.x, origP.y) * 0.8;\n    n = cnoise(modP * 10.0) * 0.02; \n    modP.x += n;\n    modP.y -= n;\n    modP *= 1.7;\n    d = sdSegment(modP, vec2(-0.09+0.35, -1.2 + 0.22), vec2(-0.09+0.35, -1.14 + 0.22)) - 0.03;\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, vec3(0.99,0.94,0.81), 1.0 - d);\n    //\n    modP = vec2(origP.x, origP.y) * 0.8;\n    n = cnoise(modP * 10.0) * 0.02; \n    modP.x += n;\n    modP.y -= n;\n    modP *= 1.7;\n    d = sdSegment(modP, vec2(-0.09-0.28, -1.2 + 0.29), vec2(-0.09-0.28, -1.14 + 0.29)) - 0.04;\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    modP = vec2(origP.x, origP.y) * 0.8;\n    n = cnoise(modP * 10.0) * 0.02; \n    modP.x += n;\n    modP.y -= n;\n    modP *= 1.7;\n    d = sdSegment(modP, vec2(-0.09-0.28, -1.2 + 0.29), vec2(-0.09-0.28, -1.14 + 0.29)) - 0.03;\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, vec3(0.99,0.94,0.81), 1.0 - d);\n    //\n    modP = vec2(origP.x, origP.y) * 0.8;\n    n = cnoise(modP * 10.0) * 0.02; \n    modP.x += n;\n    modP.y -= n;\n    modP *= 1.7;\n    d = sdSegment(modP, vec2(-0.09+-0.07, -1.2 + 0.22), vec2(-0.09+-0.07, -1.14 + 0.22)) - 0.04;\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    modP = vec2(origP.x, origP.y) * 0.8;\n    n = cnoise(modP * 10.0) * 0.02; \n    modP.x += n;\n    modP.y -= n;\n    modP *= 1.7;\n    d = sdSegment(modP, vec2(-0.09+-0.07, -1.2 + 0.22), vec2(-0.09+-0.07, -1.14 + 0.22)) - 0.03;\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, vec3(0.99,0.94,0.81), 1.0 - d);\n    //\n    modP = vec2(origP.x, origP.y) * 0.8;\n    n = cnoise(modP * 10.0) * 0.02; \n    modP.x += n;\n    modP.y -= n;\n    modP *= 1.7;\n    d = sdSegment(modP, vec2(-0.09-0.22, -1.2 + 0.25), vec2(-0.09-0.22, -1.14 + 0.25)) - 0.04;\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    modP = vec2(origP.x, origP.y) * 0.8;\n    n = cnoise(modP * 10.0) * 0.02; \n    modP.x += n;\n    modP.y -= n;\n    modP *= 1.7;\n    d = sdSegment(modP, vec2(-0.09-0.22, -1.2 + 0.25), vec2(-0.09-0.22, -1.14 + 0.25)) - 0.03;\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, vec3(0.99,0.94,0.81), 1.0 - d);\n    //\n    modP = vec2(origP.x, origP.y) * 0.8;\n    n = cnoise(modP * 10.0) * 0.02; \n    modP.x += n;\n    modP.y -= n;\n    modP *= 1.7;\n    d = sdSegment(modP, vec2(-0.09+-0.15, -1.2 + 0.22), vec2(-0.09+-0.15, -1.14 + 0.22)) - 0.04;\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    modP = vec2(origP.x, origP.y) * 0.8;\n    n = cnoise(modP * 10.0) * 0.02; \n    modP.x += n;\n    modP.y -= n;\n    modP *= 1.7;\n    d = sdSegment(modP, vec2(-0.09+-0.15, -1.2 + 0.22), vec2(-0.09+-0.15, -1.14 + 0.22)) - 0.03;\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, vec3(0.99,0.94,0.81), 1.0 - d);\n\n\n\n    // d = sdSegment(modP, vec2(-0.09, -0.65), vec2(-0.09, -0.74)) - 0.03;\n    // d = smoothstep(0.0, AA, d);\n    // col = mix(col, vec3(0.96,0.89,0.74), 1.0 - d);\n\n}\n\nvoid darkLines(vec2 p, inout vec3 col, vec2 origP) {\n    float d = 0.0;\n    float d1 = 0.0;\n    float d2 = 0.0;\n    float d3 = 0.0;\n    float r = 0.0;\n    vec2 modP = vec2(0.0);\n    vec3 mixedCol = vec3(0.0);\n    float modTime = 0.0;\n    float loopTime = 0.0;\n    float n = 0.0;\n    float m = 0.0;\n    float mask = 0.0;\n\n    // testing noise - looks great!\n    // modP = vec2(origP.x, origP.y) * 0.6;\n    // p = vec2(p.x, p.y);\n    // n = cnoise(modP * 10.0) * 0.02;\n    // modP.x += n;\n    // modP.y -= n;\n    // p.x += n;\n    // p.y -= n;\n\n    // zygomatic (bottom)\n    modP = vec2(p.x, p.y);\n    m = sin(p.x + 4.4);\n    modP.y += m;\n    modP.y -= -0.262 * 4.0;\n    modP.x += 0.05;\n    modP = rotate2d(0.02 * TAU) * modP;\n    d = sdSegment(modP, vec2(0.24, -0.41), vec2(0.35, -0.41)) - 0.01;\n    d = smoothstep(0.0, AA, d);\n    col = mix(col, blackOutlineColor, 1.0 - d);\n    // zygomatic (side)\n    modP = within(p - vec2(0.46, -0.04), vec4(0.29, 0.17, 0.74, -0.26));\n    modP = rotate2d(PI * 0.5) * modP;\n    m = sin((modP.x + 5.0) * 6.0) * 0.06;\n    m += 0.5;\n    d = length(modP - vec2(modP.x, m));\n    mask = step(0.0, modP.x) * step(modP.x, 0.65);\n    d = smoothstep(0.018, 0.028, d);\n    col = mix(col, blackOutlineColor, (1.0 - d) * mask);\n\n    // frontal (corner)\n    modP = within(p - vec2(0.57, 0.09), vec4(0.13, 0.22, 0.39, -0.04));\n    modP = rotate2d(0.39 * TAU) * modP;\n    m = sin(modP.x * 6.0) * 0.08;\n    m += 0.6;\n    d = length(modP - vec2(modP.x, m));\n    mask = step(0.55, modP.x) * step(modP.x, 0.75);\n    d = smoothstep(0.005, 0.02, d);\n    col = mix(col, blackOutlineColor, (1.0 - d) * mask);\n    // addGrid(modP, col);\n    // frontal right\n    modP = within(origP, vec4(0.13, 0.22, 0.39, -0.04));\n    modP = rotate2d(-0.01 * TAU) * modP;\n    m = sin(modP.x * 6.0) * 0.03;\n    m += 0.6;\n    d = length(modP - vec2(modP.x, m));\n    mask = step(0.25, modP.x) * step(modP.x, 0.75);\n    d = smoothstep(0.005, 0.02, d);\n    col = mix(col, blackOutlineColor, (1.0 - d) * mask);\n    // front left\n    modP = within(vec2(origP.x * -1.0, origP.y), vec4(0.13, 0.22, 0.48, -0.04));\n    modP = rotate2d(0.000 * TAU) * modP;\n    m = sin(modP.x * 6.0) * 0.03;\n    m += 0.6;\n    d = length(modP - vec2(modP.x, m));\n    mask = step(0.25, modP.x) * step(modP.x, 0.75);\n    d = smoothstep(0.005, 0.02, d);\n    col = mix(col, blackOutlineColor, (1.0 - d) * mask);\n\n    // upper maxilla\n    modP = within(p - vec2(0.0, -0.22), vec4(0.13, 0.22, 0.39, -0.04));\n    modP = rotate2d(-0.275 * TAU) * modP;\n    m = sin(modP.x * 6.0) * 0.08;\n    m += 0.6;\n    d = length(modP - vec2(modP.x, m));\n    mask = step(0.55, modP.x) * step(modP.x, 0.85);\n    d = smoothstep(0.005, 0.02, d);\n    col = mix(col, blackOutlineColor, (1.0 - d) * mask);\n    // upper maxilla\n    modP = within(p - vec2(0.035, -0.22), vec4(0.13, 0.22, 0.39, -0.04));\n    modP = rotate2d(-0.275 * TAU) * modP;\n    m = sin(modP.x * 6.0) * 0.08;\n    m += 0.6;\n    d = length(modP - vec2(modP.x, m));\n    mask = step(0.55, modP.x) * step(modP.x, 0.65);\n    d = smoothstep(0.005, 0.02, d);\n    col = mix(col, blackOutlineColor, (1.0 - d) * mask);\n    // maxilla\n    modP = within(origP - vec2(-0.4, -0.25), vec4(0.13, 0.22, 0.39, -0.04));\n    modP = rotate2d(0.76 * TAU) * modP;\n    m = sin(modP.x * 6.0) * 0.08;\n    m += 0.6;\n    d = length(modP - vec2(modP.x, m));\n    mask = step(0.55, modP.x) * step(modP.x, 0.85);\n    d = smoothstep(0.005, 0.02, d);\n    col = mix(col, blackOutlineColor, (1.0 - d) * mask);\n    // addGrid(modP, col);\n\n    // eye socket\n    // d = sdBezier(p, vec2(0.1, -0.11), vec2(0.11, 0.03), vec2(0.26, 0.0)) - 0.0;\n    // d = smoothstep(0.0, AA, d);\n    // col = mix(col, blackOutlineColor, 1.0 - d);\n    // d = sdBezier(p, vec2(mod1, mod2), vec2(mod3, mod4), vec2(mod5, mod6)) - mod7;\n    // d = smoothstep(0.0, AA, d);\n    // col = mix(col, blackOutlineColor, 1.0 - d);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n//void main()\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    //vec2 p = (2.0 * gl_FragCoord.xy - iResolution.xy) / iResolution.y;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\t\n    // https://www.shadertoy.com/view/MsdGzn\n    // first texture row is frequency data\n\tfloat fft  = texture( iChannel0, vec2(uv.x,0.25) ).x; \n\t// convert frequency to colors\n\tvec3 freqCol = vec3( fft, 4.0*fft*(1.0-fft), 1.0-fft ) * fft;\n    \n    // perturb coords - highs\n    float highsMod = 2.0 * freqCol.r;\n    float m = sin(iTime + (p.y * 20.0)) * highsMod;\n    m *= smoothstep(-0.35, 0.0, p.y) - (smoothstep(0.0, 0.2, p.y));\n    // m *= p.y * 4.0;\n    p.x += m;\n\n    // perturb coords - lows\n    float lowsMod = 0.1 * freqCol.b;\n    float noiseScale = 10.0;\n    float n = cnoise(vec2(p.x, p.y + (iTime * 0.5)) * noiseScale) * lowsMod;\n    p.x += n;\n    p.y -= n;\n\n    vec2 origP = vec2(p.x, p.y);\n\n\n    // mirror coords\n    p.x = abs(p.x);\n\n    \n    bg(p, col, origP);\n    cranium(p, col, origP);\n    darkLines(p, col, origP);\n\n\tfragColor = vec4(col,1.0);\n    //gl_FragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": "ltj3zG", "previewfilepath": "https://soundcloud.com/venetian-snares/sugarbush", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/venetian-snares/sugarbush", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ws2Bzw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ws2fD1", "name": "Me Learning Marching 6", "author": "ShadingAlpaca", "description": "Let's rotate the camera", "tags": ["raymarching"], "likes": 0, "viewed": 37, "date": "1589971137", "time_retrieved": "2024-06-20T20:08:55.388925", "image_code": "#define MAX_STEPS 100\n#define MAX_DISTANCE 10.\n#define MIN_SURF .001\n#define PI 3.14159\n\n//Rotates the given Vector around the X-Axis\nvec3 rotateX(vec3 put,float angle)\n{\n    return vec3(\n        put.x,\n        put.y*cos(angle) - put.z*sin(angle),\n        put.y*sin(angle) + put.z*cos(angle)\n    );\n}\n\n//Rotates the given Vector around the Y-Axis\nvec3 rotateY(vec3 put,float angle)\n{\n    return vec3(\n        put.x*cos(angle) + put.z*sin(angle),\n        put.y,\n       -put.x*sin(angle) + put.z*cos(angle)\n    );\n}\n\n//Rotates the given Vector around the Z-Axis\nvec3 rotateZ(vec3 put,float angle)\n{\n    return vec3(\n        put.x*cos(angle) - put.y*sin(angle),\n        put.x*sin(angle) + put.y*cos(angle),\n        put.z\n    );\n}\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nfloat sphereDist(vec3 point, vec4 sphere)\n{\n    return length(point-sphere.xyz)-sphere.w;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sceneDist(vec3 point)\n{\n    float box1 = sdBox(mod(point,2.)-vec3(1.,1.,1.),vec3(0.3));\n    float scene = box1;\n        \n    return scene;\n}\n\nfloat rayMarch(vec3 position, vec3 direction)\n{\n    float cD = 0.;\n    \n    for(int i=0;i<MAX_STEPS;i++)\n    {\n        vec3 p = position+direction*cD;\n        float dS = sceneDist(p);\n        cD += dS;\n        if(cD>MAX_DISTANCE||dS<MIN_SURF)\n            break;\n    }\n    \n    return cD;\n}\n\nvec3 getNormal(vec3 point)\n{\n    float d = sceneDist(point);\n    vec2 e = vec2(0.01,0);\n    \n    vec3 n = d-vec3(\n        sceneDist(point-e.xyy),\n        sceneDist(point-e.yxy),\n        sceneDist(point-e.yyx)\n    );\n    return normalize(n);\n}\n\nfloat getLight(vec3 point, vec3 light)\n{\n    vec3 l = normalize(light-point);\n    vec3 n = getNormal(point);\n    \n    float dif = clamp(dot(n,l),0.,1.);\n    float d = rayMarch(point+MIN_SURF*n*2.,l);\n    \n    if(d<length(light.xyz-point))\n        dif *= 0.1;\n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = 1.;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ( fragCoord - .5*iResolution.xy) /iResolution.y;\n\n    vec3 camera = vec3(0.,0.,iTime*0.5);\n    vec3 direction = normalize(rotateX(rotateY(vec3(uv.x*zoom,uv.y*zoom,1.),sin(iTime)*0.1),cos(iTime*0.2)*0.3));\n    \n    float d = rayMarch(camera,direction);\n    \n    \n    vec3 p = camera+direction*d;\n    \n    vec3 light1 = camera;\n    float brightness1 = getLight(p,light1);\n    // Time varying pixel color\n    vec3 col1 = vec3(0.2,0.18,0.1);\n\n    // Output to screen\n    fragColor = vec4(col1*brightness1+1./d,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ws2fD1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ws2fDy", "name": "Rasterizing a Blob to a grid", "author": "Schrompf", "description": "Analytically (*) calculates the common area between a rectangle and the blob. The result is a perfectly anti-aliased rasterization of said blob.\n(*) First tried circloid functions (like y = (1 - x^a) ^ (1/a)) which are nearly impossible to integrate", "tags": ["experiment"], "likes": 2, "viewed": 134, "date": "1590747126", "time_retrieved": "2024-06-20T20:08:55.825300", "image_code": "const float GridSize = 32.0f;\nconst float Exp = 4.0f;\nconst float InvExp = 1.0f / Exp;\n\n\n// Hull curve is \"y = 1 - x^5\"\n// Inverse is \"x = (1 - y) ^ (1/5)\"\n// Integral is \"y = x - 1/6 x^6\"\nfloat hullIntegral(float x) \n{\n    return x - (1.0f / (Exp + 1.0f)) * pow( x, (Exp + 1.0f));\n}\n\n// Area integral of Blob shape (0, 0) to (x, y). Sign is Positive (TopRight/BottomLeft) or Negative (other)\nfloat areaIntegral(vec2 pos) \n{\n    vec2 p = abs( pos);\n    float plus = sign( pos.x) * sign( pos.y);\n    \n    // only top-right quadrant: calculate xpos of intersection between hull and upper area border\n    float intersectPos = pow( clamp( 1.0f - p.y, 0.0f, 1.0f), InvExp);\n    // area of the part completely inside the hull, 0 .. intersectPos\n    float insideArea = min( p.x, intersectPos) * min( p.y, 1.0f);\n    // area under hull function beyond intersect position, intersectPos .. right border\n    float remainPos = clamp( p.x, intersectPos, 1.0f);\n    float remainArea = hullIntegral( remainPos) - hullIntegral( intersectPos);\n    \n    return plus * (insideArea + remainArea);\n}\n\nfloat integral( vec2 blobCenter, float blobRadius, vec2 rectMin, vec2 rectMax)\n{\n    float invBlobRadius = 1.0f / blobRadius;\n    vec2 minpos = invBlobRadius * (rectMin - blobCenter);\n    vec2 maxpos = invBlobRadius * (rectMax - blobCenter);\n    \n    float totalArea = (maxpos.x - minpos.x) * (maxpos.y - minpos.y);\n    float area\n        = areaIntegral( maxpos)\n        - areaIntegral( vec2( minpos.x, maxpos.y))\n        - areaIntegral( vec2( maxpos.x, minpos.y))\n        + areaIntegral( minpos);\n    return area / totalArea;\n}\n\nfloat doBlob( vec2 center, float radius, vec2 pos)\n{\n    vec2 off = abs( pos - center) / radius;\n    float y = 1.0f - pow( off.x, Exp);\n    float i = off.y < y ? 1.0f : 0.0f;\n    return i;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Blob controllable by mouse\n    vec2 blobPos = iMouse.xy;\n    float blobRadius = 150.0f + 50.0f * sin(0.5f * iTime);\n\tfloat blobPresence = doBlob( blobPos, blobRadius, fragCoord.xy);\n        \n    // a grid of rectangles\n    ivec2 gridpos = ivec2(fragCoord.xy / GridSize);\n    vec2 rectMin = vec2( gridpos) * GridSize;\n    vec2 rectMax = rectMin + vec2( GridSize, GridSize);   \n    \n    // calculate the percentage of the area the blob occupies \n    float factor = integral( blobPos, blobRadius, rectMin, rectMax);\n    // quick gamma correction\n    factor *= factor;\n    \n    // base colour is rasterized blob\n    vec3 res = vec3( factor, factor, factor);\n    // paint real blob shape on top\n    res = mix( res, vec3( 1, 0, 0), 0.3f * blobPresence);\n    \n    fragColor = vec4( res, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ws2fDy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ws2fzh", "name": "Smiley_the_art_of_code_from_YT", "author": "Birat_Kafle", "description": "Followed the tutorial form the art of code on YOUTUBE\n\nUse your mouse !!", "tags": ["eye", "animation", "smiley", "art", "emoji"], "likes": 3, "viewed": 78, "date": "1590143762", "time_retrieved": "2024-06-20T20:08:56.946746", "image_code": "\n#define S(a,b,t) smoothstep (a,b,t)\n#define sat(x)  clamp(x,0.,1.)\n\nfloat remap01 (float a, float b, float t)\n{\n\nreturn sat((t-a)/(b-a));\n\n}\n\n\nfloat remap (float a, float b, float c, float d, float t)\n{\n\nreturn sat(((t-a)/(b-a))*(d-c)+c);\n}\n\nvec2 within (vec2 uv, vec4 rect)\n{\n \nreturn (uv.xy-rect.xy)/(rect.zw-rect.xy);\n}\n\nvec4 Brow(vec2 uv,float smile)\n{\n   \n uv = within(uv,vec4(.03, .2, .4, .45));\n    \n     float offs = mix(.2,0.,smile);\n    uv.y += offs;\n    \n    \n float y = uv.y;\n    uv.y+= uv.x*mix(.5,.8,smile)-mix(.1,.3,smile);\n    uv.x -=mix(0.,.1,smile);\n    uv-=.5;\n    \n    vec4 col = vec4(0.);\n             \nfloat blur = .1;\n    \n    float d1 = length(uv);\n    float s1 = S(.45,.45-blur,d1);\n    float d2 = length(uv-vec2(.1,-.2)*.7);\n    float s2 = S(.5,.5-blur,d2);\n\n    float browmask = sat(s1-s2);\n    \n    float colMask = remap01(.7,.8,y)*.75;\n    colMask *= S(.6,.9,browmask);\n    colMask *=smile;\n    vec4 browcol = mix(vec4(.5, .2, .2, 1.), vec4(1., .75, .5, 1.), colMask);\n    \n    \n    \n    uv.y += .15 - offs*.5;\n   \n    blur += .1*smile;\n    d1 = length(uv);\n    s1 = S(.45, .45-blur, d1);\n    d2 = length(uv-vec2(.1, -.2)*.7);\n    s2 = S(.5, .5-blur, d2);\n    float shadowMask = sat(s1-s2);\n    \n    col = mix(col, vec4(0.,0.,0.,1.), S(.0, 1., shadowMask)*.5);\n    \n   col = mix(col,browcol,S(.2,.4,browmask));\nreturn col;\n}\n\n\nvec4 Eye(vec2 uv,float side,vec2 m,float smile)\n{\n\n    uv = within(uv,vec4(.03,-0.1,.37,.25));\n    uv-=.5;\n    uv.x *=side;\n    float d = length(uv);\n\n   \n     \n    vec4 irisColor = vec4(.3,.5,1.,1.);\n    \n    \n    \n    vec4 col = mix(vec4(1.),irisColor,S(.1,.7,d)*0.5);\n    col.a = S(.5,.48,d);\n    \n    col.rgb *= 1.-S(.4,.5,d)*0.5*sat(-uv.y-uv.x*side)*0.5;\n    \n    \n    \n    //uv.x += sin(iTime*10.)*0.2;\n    //uv.y += cos(iTime*10.)*0.2;\n    \n    d = length(uv-m*0.5);\n    col.rgb = mix(col.rgb,vec3(0.),S(.3,.28,d));\n    \n    irisColor.rgb *= 1.+S(0.3,.05,d);\n    float irisMask = S(.27,.26,d);\n    col.rgb = mix(col.rgb,irisColor.rgb,irisMask);\n    \n    d = length(uv-m*0.6);\n    float pupilsize = mix(0.4,.16,smile);\n    float pupilMask = S(pupilsize,pupilsize*0.8,d);\n    pupilMask *= irisMask;\n    col.rgb = mix(col.rgb,vec3(0.),pupilMask);\n    \n    float t = iTime*3.0;\n    vec2 offs = vec2(sin(t+uv.y*25.),sin(t+uv.x*25.));\n    offs *= 0.01*(1.-smile); \n    uv+= offs;\n    \n    float highlight = S(0.1,0.09,length(uv-vec2(-0.15,0.15)));\n    highlight += S(0.07,0.05,length(uv+vec2(-0.08,0.08)));\n    col.rgb = mix(col.rgb,vec3(1.0),highlight);\n    \n    \n \n    return col;\n}\n\n\nvec4 Mouth(vec2 uv,float smile)\n{\n    uv = within(uv,vec4(-.3,-0.4,.3,-.1));\n    uv-=.5;\n    uv.y*=1.5;\n    vec4 col = vec4(.5,.18,.05,1.);\n    uv.y-=uv.x*uv.x*2.0*smile;\n    uv.x *= mix(2.,1.,smile);\n    \n    vec2 tuv = uv;\n    float d = length(uv);\n    col.a = S(0.5,0.48,d);\n    \n    uv.y += abs(uv.x)*(1.-smile)*.7;\n    float td = length(uv-vec2(0.,.6));\n    \n   \n    \n    \n     vec3 toothcol = vec3(1.)*S(.6,.35,d);\n    col.rgb= mix(col.rgb,toothcol,S(.4,.37,td));\n    \n    td = length(tuv+vec2(0.,.5));\n    col.rgb = mix(col.rgb,vec3(1.,.5,.5),S(.5,.2,td));\n    \n    return col;\n}\n\nvec4 Head(vec2 uv)\n{\n    \n    vec4 col = vec4(0.9,.65,.1,1.0);\n    float d = length(uv);\n    \n    col.a = S(.5,0.49,d);\n    \n    \n    float edgeshade = remap01(0.35,0.5,d);\n    edgeshade = pow(edgeshade,2.);\n    \n    col.rgb *= 1.-edgeshade*0.5;\n    float DO = S(.47,.48,d);\n    col.rgb = mix(col.rgb, vec3(.6,.3,.1),DO);\n    \n    float highlight = S(.41,.405,d);\n    highlight *= remap(.41,-0.1,.75,0.,uv.y);\n    highlight *= S(.18,.19,length(uv-vec2(.21,.08)));\n    col.rgb = mix(col.rgb,vec3(1),highlight);\n    \n    d = length(uv-vec2(.25,-.2));\n    float cheek = S(.2,.1,d)*.4;\n               \n    col.rgb = mix(col.rgb,vec3(1.,.1,.1),cheek);\n   \n\n    return col;\n}\n\n\nvec4 Smiley(vec2 uv,vec2 m,float smile)\n{\n    float side = sign(uv.x);\n    \n    uv.x = abs(uv.x);\n    \n\n    vec4 col = vec4(0.);\n    vec4 head = Head(uv);\n    vec4 eye = Eye(uv,side,m,smile);\n    vec4 mouth = Mouth(uv,smile);\n    vec4 brow = Brow(uv,smile);\n    \n    col = mix(col, head,head.a);\n    col = mix(col, eye,eye.a);\n    col = mix(col, mouth,mouth.a);\n    col = mix(col, brow,brow.a);\n    \n    \n    \n    return col;\n}\n\n\nvoid mainImage(out vec4 FragColor,in vec2 FragCoord)\n{\n    vec2 uv = FragCoord/iResolution.xy;\n    uv -= vec2(0.5,0.5);\n\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec2 m = iMouse.xy/iResolution.xy;\n    m-=.5;\n    \n    float smile = cos(iTime)*.5+.5;\n    //uv -=m*(.25-dot(uv,uv));\n    uv -=m*(.25-length(uv)*length(uv));\n    uv.y*=(sin(iTime*3.)*0.03)+1.;\n    uv.x*=(cos(iTime*3.)*0.03)+1.;\n \n    \n    \n    \n    FragColor = Smiley(uv,m,smile);\n   \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ws2fzh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ws2fzV", "name": "polyhedron morphing", "author": "darkfox", "description": "various change.", "tags": ["polyhedron"], "likes": 8, "viewed": 129, "date": "1590460122", "time_retrieved": "2024-06-20T20:08:58.255877", "image_code": "// polyhedron morphing.\n// octahedron, icosahedron, cuboctahedron, medium polyhedron, \n// hexahedron, dodecahedron, Stella octangula, tetrahedron.\n// reference: raymarching:https://www.shadertoy.com/view/XtXGRS\n// thanks!\n\nconst float pi = 3.14159;\n// color palette.\nconst vec3 black = vec3(0.2);\nconst vec3 red = vec3(0.95, 0.3, 0.35);\nconst vec3 orange = vec3(0.98, 0.49, 0.13);\nconst vec3 yellow = vec3(0.95, 0.98, 0.2);\nconst vec3 green = vec3(0.3, 0.9, 0.4);\nconst vec3 lightgreen = vec3(0.7, 0.9, 0.1);\nconst vec3 purple = vec3(0.6, 0.3, 0.98);\nconst vec3 blue = vec3(0.2, 0.25, 0.98);\nconst vec3 skyblue = vec3(0.1, 0.65, 0.9);\nconst vec3 white = vec3(1.0);\nconst vec3 aquamarine = vec3(0.47, 0.98, 0.78);\nconst vec3 turquoise = vec3(0.25, 0.88, 0.81);\nconst vec3 coral = vec3(1.0, 0.5, 0.31);\nconst vec3 limegreen = vec3(0.19, 0.87, 0.19);\nconst vec3 khaki = vec3(0.94, 0.90, 0.55);\nconst vec3 navy = vec3(0.0, 0.0, 0.5);\nconst vec3 silver = vec3(0.5);\n// points on axis.\nconst vec3 e1 = vec3(1.0, 0.0, 0.0);\nconst vec3 e2 = vec3(0.0, 1.0, 0.0);\nconst vec3 e3 = vec3(0.0, 0.0, 1.0);\nconst vec3 e123 = vec3(1.0, 1.0, 1.0);\n// global points and faces.\nvec3 V1, V2, V3, G;\nvec3 P12, P23, P31, P123, Q12, Q23, Q31, R12, R23, R31;\nvec3 corner0, corner1;\n// drawing flags.\nint version;\nbool verticeFlag; // true: draw V1, V2, V3.\nbool cornerFlag; // true: draw e123.\nbool subCornerFlag; // true: draw corner0 while expanding.\n// for bodyColor.\nvec3 bodyColor;\n// get parameter and set flags and bodyColor.\nvec4 getParam(){\n  float time = mod(iTime, 48.0);\n  float f = fract(time / 3.0);\n  verticeFlag = true;\n  cornerFlag = false;\n  subCornerFlag = false;\n// in ver1 and ver2, draw e123.\n  if(time > 24.0 && time < 39.0){ cornerFlag = true; }\n// golden ratio - 1.0\n  float k = (sqrt(5.0) - 1.0) / 2.0;\n// è²ãæ±ºãããRGBã§é©å½ã«ã»ã»\n  bodyColor = turquoise;\n  if(time < 3.0){\n    return vec4(0.0, 0.0, 0.0, 0.0); // octahedron.\n  }else if(time < 6.0){\n    bodyColor = mix(turquoise, skyblue, f);\n    return vec4(k * f, 0.0, 0.0, 0.0);\n  }else if(time < 9.0){\n    bodyColor = skyblue;\n    return vec4(k, 0.0, 0.0, 0.0); // icosahedron.\n  }else if(time < 12.0){\n    bodyColor = mix(skyblue, blue, f);\n    return vec4(k + f * (1.0 - k), 0.0, 0.0, 0.0);\n  }else if(time < 15.0){\n    bodyColor = blue;\n    return vec4(1.0, 0.0, 0.0, 0.0); // cuboctahedron.\n  }else if(time < 18.0){\n    bodyColor = mix(blue, purple, f);\n    return vec4(1.0, 0.0, 0.0, f);\n  }else if(time < 21.0){\n    bodyColor = purple;\n    return vec4(1.0, 0.0, 0.0, 1.0); // medium polyhedron.\n  }else if(time < 24.0){\n    subCornerFlag = true; // preparate for hexahedron, need more vertices.\n    bodyColor = mix(purple, red, f);\n    return vec4(1.0, 0.0, f, 1.0);\n  }else if(time < 27.0){\n    bodyColor = red;\n    verticeFlag = false; return vec4(1.0, 0.0, 1.0, 1.0); } // hexahedron.\n  else if(time < 30.0){\n    bodyColor = mix(red, orange, f);\n    return vec4(1.0 + f * (k - 1.0), k * f, 1.0, 1.0);\n  }else if(time < 33.0){\n    bodyColor = orange;\n    return vec4(k, k, 1.0, 1.0); // dodecahedron.\n  }else if(time < 36.0){\n    bodyColor = mix(orange, yellow, f);\n    return vec4(k * (1.0 - f), k * (1.0 - f), 1.0, 1.0);\n  }else if(time < 39.0){\n    bodyColor = yellow;\n    return vec4(0.0, 0.0, 1.0, 1.0); } // Stella octangula.\n  else if(time < 42.0){\n    subCornerFlag = true; // preparate for tetrahedron, need more vertices.\n    bodyColor = mix(yellow, green, f);\n    return vec4(0.0, 0.0, 1.0 - f, 1.0);\n  }else if(time < 45.0){\n    bodyColor = green;\n    verticeFlag = false; return vec4(0.0, 0.0, 0.0, 1.0); } // tetrahedron.\n  bodyColor = mix(green, turquoise, f);\n  return vec4(0.0, 0.0, 0.0, 1.0 - f);\n}\n// set global properties.\nvoid prepareGlobal(){\n  vec4 t = getParam();\n  // set version.\n  version = 2;\n  if(max(t.z, t.w) == 0.0){ version = 0; }\n  else if(min(t.z, t.w) == 1.0){ version = 1; }\n  // set vertices.\n  V1 = vec3(0.0, t.y + 1.0, t.x);\n  V2 = vec3(t.x, 0.0, t.y + 1.0);\n  V3 = vec3(t.y + 1.0, t.x, 0.0);\n  G = (V1 + V2 + V3) / 3.0;\n  // prepare faces.\n  P12 = normalize(cross(V2 - e3, V1 - e3));\n  P23 = normalize(cross(V3 - e1, V2 - e1));\n  P31 = normalize(cross(V1 - e2, V3 - e2));\n  P123 = normalize(cross(V2 - V1, V3 - V1));\n  corner0 = (1.0 - t.z) * G + t.z * e123;\n  corner1 = (1.0 - t.w) * G + t.w * e123;\n  Q12 = normalize(cross(V1 - corner0, V2 - corner0));\n  Q23 = normalize(cross(V2 - corner0, V3 - corner0));\n  Q31 = normalize(cross(V3 - corner0, V1 - corner0));\n  R12 = normalize(cross(V1 - corner1, V2 - corner1));\n  R23 = normalize(cross(V2 - corner1, V3 - corner1));\n  R31 = normalize(cross(V3 - corner1, V1 - corner1));\n}\n// rotation function for camera work.\nvec2 rotate(vec2 p, float t){\n  return p * cos(t) + vec2(-p.y, p.x) * sin(t);\n}\nvec3 rotateX(vec3 p, float t){\n  p.yz = rotate(p.yz, t);\n  return p;\n}\nvec3 rotateY(vec3 p, float t){\n  p.zx = rotate(p.zx, t);\n  return p;\n}\nvec3 rotateZ(vec3 p, float t){\n  p.xy = rotate(p.xy, t);\n  return p;\n}\n// sphere. (for vertices)\nfloat sphere(vec3 p, float r){\n  return length(p) - r;\n}\n// bar. (not use)\nfloat bar(vec3 p, vec3 n, float r){\n  return length(p - dot(p, n) * n) - r;\n}\n// halfBar. (not use)\nfloat halfBar(vec3 p, vec3 n, float r){\n  return length(p - min(0.0, dot(p, n)) * n) - r;\n}\n// drawing utility.\n// 0: min(union)\n// 1: max(intersection)\n// 2: minus max(difference)\nvoid updateDist(inout vec3 color, inout float dist, vec3 c, float d, int modeId){\n  if(d < dist && modeId == 0){ color = c; dist = d; }\n  if(d > dist && modeId == 1){ color = c; dist = d; }\n  if(-d > dist && modeId == 2){ color = c; dist = -d; }\n}\n// map function.\nvec4 map(in vec3 p){\n  vec3 color;\n  float parity = sign(p.x) * sign(p.y) * sign(p.z);\n  p = abs(p);\n  float t = -1.0;\n  float face, vertice; // for calculate.\n  if(version == 0 || version == 2){\n    face = max(dot(p - e3, P12), max(dot(p - e1, P23), dot(p - e2, P31)));\n    updateDist(color, t, bodyColor, face, 1);\n  }\n  if(version == 0){\n    updateDist(color, t, bodyColor, dot(p - G, P123), 1);\n  }\n  if(version == 1 || (version == 2 && parity > 0.001)){\n    face = max(dot(p - corner0, Q12), max(dot(p - corner0, Q23), dot(p - corner0, Q31)));\n    updateDist(color, t, bodyColor, face, 1);\n    if(subCornerFlag){\n      updateDist(color, t, silver, sphere(p - corner0, 0.1), 0);\n    }\n  }\n  if(version == 2 && parity < 0.001){\n    face = max(dot(p - corner1, R12), max(dot(p - corner1, R23), dot(p - corner1, R31)));\n    updateDist(color, t, bodyColor, face, 1);\n    updateDist(color, t, silver, sphere(p - corner1, 0.1), 0);\n  }\n  if(verticeFlag){\n    vertice = min(sphere(p - V1, 0.1), min(sphere(p - V2, 0.1), sphere(p - V3, 0.1)));\n    updateDist(color, t, silver, vertice, 0);\n  }\n  if(cornerFlag){\n    updateDist(color, t, silver, sphere(p - e123, 0.1), 0);\n  }\n  return vec4(color, t);\n}\n// get normal vector. (mathematical method)\nvec3 calcNormal(vec3 p){\n  const vec2 eps = vec2(0.0001, 0.0);\n  vec3 n;\n  n.x = map(p + eps.xyy).w - map(p - eps.xyy).w;\n  n.y = map(p + eps.yxy).w - map(p - eps.yxy).w;\n  n.z = map(p + eps.yyx).w - map(p - eps.yyx).w;\n  return normalize(n);\n}\n// ray marching.\nfloat march(vec3 ray, vec3 camera){\n  const float maxd = 20.0; // searching limit.\n  const float precis = 0.001; // precision.\n  const int ITERATION = 64; // iteration limit.\n  float h = precis * 2.0; // heuristics.\n\n  float t = 0.0; // current distance.\n\n  float result = -1.0;\n  for(int i = 0; i < ITERATION; i++){\n    if(h < precis || t > maxd){ break; }\n    // adding heuristics value.\n    h = map(camera + t * ray).w;\n    t += h;\n  }\n  // if t < maxd, it means success(h < precis).\n  if(t < maxd){ result = t; }\n  return result;\n}\n// camera move.\nvoid transform(inout vec3 p){\n  float angleX = pi * iTime * 0.3;\n  float angleY = pi * iTime * 0.15;\n  p = rotateX(p, angleX);\n  p = rotateY(p, angleY);\n}\n// èæ¯è²ãã¨ããããããã©ã§ãããã\nvec3 getBackground(vec2 p){\n// ã¾ãããã ã¨ç©ºéããããããã¦ãæãããªããããªã¼ã»ã»\n// ä½ã®è²ã«åããã¦å¤ãã¦ã¿ããã¤ãã£ã¦ã¿ã¾ããã\n  vec3 color = mix(bodyColor, white, 0.5);\n  return color * (0.3 + p.y * 0.4);\n}\n// main.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n  vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n  vec3 color;\n  // ray vector.\n  vec3 ray = normalize(vec3(p, -1.8));\n  // camera position.\n  vec3 camera = vec3(0.0, 0.0, 4.5);\n  // light vector.\n  vec3 light = normalize(vec3(0.5, 0.8, 3.0));\n  // camera rotation.\n  transform(ray);\n  transform(camera);\n  transform(light);\n  // preparation.\n  prepareGlobal();\n  color = getBackground(p);\n  // get ray marching result.\n  float t = march(ray, camera);\n  // if t > -0.001, it means success. if not, background color.\n  if(t > -0.001){\n    vec3 pos = camera + t * ray;\n    vec3 n = calcNormal(pos);\n    // lighting.\n    float diff = clamp((dot(n, light) + 0.5) * 0.7, 0.3, 1.0);\n    vec3 baseColor = map(pos).xyz;\n    baseColor *= diff;\n    // fadeout effect.\n    color = mix(baseColor, color, tanh(t * 0.02));\n  }\n  fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ws2fzV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Ws2yRt", "name": "Hw9 - Penumbra Shadows", "author": "vmoniqb", "description": "hw9", "tags": ["raycasting"], "likes": 0, "viewed": 93, "date": "1588872623", "time_retrieved": "2024-06-20T20:08:59.668019", "image_code": "const float FOVY = 3.14159 * 0.25;\nconst int RAY_STEPS = 256;\nconst float SHADOW_HARDNESS = 6.0;\n\n    \nstruct Intersection\n{\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\t// Assign every object in scene a unique ID int\n};\n    \n\n    \nvoid pR(inout vec2 p, float a)\n{\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvec3 rotatePtY(vec3 pt, float a)\n{    \n    pR(pt.yz, 0.);\n    pR(pt.xz, a);\n    pR(pt.xy, 0.);\n    \n    return pt;\n}\n\nvec3 rotatePtX(vec3 pt, float a)\n{    \n    pR(pt.yz, a);\n    pR(pt.xz, 0.);\n    pR(pt.xy, 0.);\n    \n    return pt;\n}\n\n// 2D rotation about the y-axis\nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\n\nvoid rayCast(vec3 eye, vec3 ref, vec2 ndc, out vec3 dir) {\n    // Compute camera axis\n    vec3 F = ref - eye;\n    vec3 R = normalize(cross(F, vec3(0,1,0)));\n    vec3 U = normalize(cross(R, F));\n    \n    vec3 V = U * length(F) * tan(FOVY * 0.5);\n    vec3 H = R * length(F) * tan(FOVY * 0.5) * float(iResolution.x) / iResolution.y;\n    \n    vec3 p = ref + ndc.x * H + ndc.y * V; \n    \n    dir = normalize(p - eye);\n}\n\n    \n// SHAPE SDFs\nfloat sphere(vec3 p, float r, vec3 c) {\n\treturn distance(p, c) - r;\n}\n\nfloat cube(vec3 p, vec3 c) {\n    return length(max(abs(p) - c, 0.0));\n}\n\nfloat squarePlane(vec3 p, vec4 n)\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat torus(vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q) - t.y;\n}\n\n\n#define FLOOR_SDF\t \tsquarePlane(pos + vec3(0.0, 0.2, 0.0), vec4(0., 1., 0., 1.))\n#define FLOOR_ID\t\t1\n#define SPHERE1_SDF\t\tsphere(pos + vec3(3.0, -0.5, -6.0), 1.5, vec3(0.0, 0.0, 0.0))\n#define SPHERE1_ID\t\t2\n#define SPHERE2_SDF\t\tsphere(pos + vec3(-1.0, -4.0, -3.0), 1.5, vec3(0.0, 0.0, 0.0))\n#define SPHERE2_ID\t\t3\n#define CUBE_SDF\t\tcube(rotatePtX(rotatePtY(pos + vec3(1.5, -1.5, 6.0), 0.3), 0.8), vec3(1.2, 1.2, 1.2))\n#define CUBE_ID\t\t\t4\n#define TORUS1_SDF\t\ttorus(rotatePtX(rotatePtY(pos + vec3(4.0, -3.5, 1.0), 0.5), 0.9), vec2(1.7, 0.5))\n#define TORUS1_ID\t\t5\n#define TORUS2_SDF\t\ttorus(rotatePtX(rotatePtY(pos + vec3(6.0, 0.5, 3.0), -0.4), -0.5), vec2(1.0, 0.4))\n#define TORUS2_ID\t\t6\n#define LIGHT_SDF\t\tsphere(pos + vec3(-0.5, 0., 0.), 2.0, lightPos)\n#define LIGHT_ID\t\t7\n\nvoid sceneMap3D(vec3 pos, out float t, out int obj, vec3 lightPos) {\n    t = FLOOR_SDF;\n    obj = FLOOR_ID;\n    \n    float t2;\n    if ((t2 = SPHERE1_SDF) < t) {\n    \tt = t2;\n      \tobj = SPHERE1_ID;\n    }\n    \n    if ((t2 = SPHERE2_SDF) < t) {\n    \tt = t2;\n      \tobj = SPHERE2_ID;\n    }\n    \n    if ((t2 = CUBE_SDF) < t) {\n    \tt = t2;\n      \tobj = CUBE_ID;\n    }\n    \n    if ((t2 = TORUS1_SDF) < t) {\n    \tt = t2;\n      \tobj = TORUS1_ID;\n    }\n    \n    if ((t2 = TORUS2_SDF) < t) {\n    \tt = t2;\n      \tobj = TORUS2_ID;\n    }\n}\n\n\nfloat sceneMap3D(vec3 pos, vec3 lightPos) {\n    float t = FLOOR_SDF;\n    \n    float t2;\n    if ((t2 = SPHERE1_SDF) < t) {\n    \tt = t2;\n    }\n    \n    if ((t2 = SPHERE2_SDF) < t) {\n    \tt = t2;\n    }\n    \n    if ((t2 = CUBE_SDF) < t) {\n    \tt = t2;\n    }\n    \n    if ((t2 = TORUS1_SDF) < t) {\n    \tt = t2;\n    }\n    \n    if ((t2 = TORUS2_SDF) < t) {\n    \tt = t2;\n    }\n    \n    return t;\n}\n\n\nfloat shadowMap3D(vec3 pos) {\n    float t = SPHERE1_SDF;\n\n    float t2;\n    if ((t2 = SPHERE2_SDF) < t) {\n    \tt = t2;\n    }\n    \n    if ((t2 = CUBE_SDF) < t) {\n    \tt = t2;\n    }\n\n    if ((t2 = TORUS1_SDF) < t) {\n    \tt = t2;\n    }\n    \n    if ((t2 = TORUS2_SDF) < t) {\n    \tt = t2;\n    }\n    \n    if ((t2 = FLOOR_SDF) < t) {\n    \tt = t2;\n    }\n    \n    return t;\n}\n\n\nvec3 computeNormal(vec3 pos, vec3 lightPos) {\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( sceneMap3D(pos + epsilon.yxx, lightPos) - sceneMap3D(pos - epsilon.yxx, lightPos),\n                            sceneMap3D(pos + epsilon.xyx, lightPos) - sceneMap3D(pos - epsilon.xyx, lightPos),\n                            sceneMap3D(pos + epsilon.xxy, lightPos) - sceneMap3D(pos - epsilon.xxy, lightPos)));\n}\n\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj, vec3 lightPos) {\n    t = 0.001;\n    \n    for (int i = 0; i < RAY_STEPS; ++i) {\n    \tvec3 pos = origin + t * dir;\n        float m; // Minimum distance from this point to an object in the scene\n        sceneMap3D(pos, m, hitObj, lightPos);\n        if (m < 0.01) {\n        \treturn;\n        }\n        t += m;\n    }\n\t// We hit nothing\n    t = -1.0;\n    hitObj = -1;\n}\n\n\nfloat softShadow(vec3 dir, vec3 origin, float min_t, float k) {\n    float res = 1.0;\n    float t = min_t;\n    for(int i = 0; i < RAY_STEPS; ++i) {\n        float m = shadowMap3D(origin + t * dir);\n        if(m < 0.0001) {\n            return 0.0;\n        }\n        res = min(res, k * m / t);\n        t += m;\n    }\n    return res;\n}\n\n\nvec3 computeMaterial(int hitObj, vec3 p, vec3 n, vec3 lightVec, vec3 view) {\n    float lambert = dot(lightVec, n);\n    switch(hitObj) {\n        // Sphere 1\n        case SPHERE1_ID:\n        return vec3(1., 0.7, 0.2) * lambert * softShadow(lightVec, p, 0.1, SHADOW_HARDNESS);\n        break;\n        // Sphere 2\n        case SPHERE2_ID:\n        return vec3(0.4, 0.7, 0.3) * lambert * softShadow(lightVec, p, 0.1, SHADOW_HARDNESS);\n        break;\n        // Cube\n        case CUBE_ID:\n        return vec3(0.8, 0.4, 0.6) * lambert * softShadow(lightVec, p, 0.1, SHADOW_HARDNESS);\n        break;\n        // Torus 1\n        case TORUS1_ID:\n        return vec3(0.6, 0.4, 0.8) * lambert * softShadow(lightVec, p, 0.1, SHADOW_HARDNESS);\n        break;\n        // Torus 2\n        case TORUS2_ID:\n        return vec3(0.2, 0.5, 0.8) * lambert * softShadow(lightVec, p, 0.1, SHADOW_HARDNESS);\n        break;\n        // Light\n        case LIGHT_ID:\n        return vec3(1.0, 0.88, 0.7);\n        break;\n        // Floor\n        case FLOOR_ID:\n        return vec3(1., 1., 1.) * lambert * softShadow(lightVec, p, 0.1, SHADOW_HARDNESS);\n        break;\n        // Background\n        case -1:\n        return vec3(0.0);\n        break;\n    }\n    return vec3(1.0);\n}\n\n\nIntersection sdf3D(vec3 dir, vec3 eye, vec3 lightPos) {\n\tfloat t;\n    int hitObj;\n    march(eye, dir, t, hitObj, lightPos);\n    \n    vec3 isect = eye + t * dir;\n    vec3 nor = computeNormal(isect, lightPos);\n    vec3 lightDir = normalize(lightPos - isect);\n        \n    vec3 surfaceColor = computeMaterial(hitObj, isect, nor, lightDir, normalize(eye - isect));\n        \n    return Intersection(t, surfaceColor, isect, hitObj);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec3 lightPos = rotateY(vec3(0.0, 15.0, -7.0), iTime * 0.75);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // Convert to range [-1,1]\n    uv = uv * 2.0 - vec2(1.0, 1.0);\n    \n    vec3 eye = rotateY(vec3(0.0, 5.0, 15.0), 3.14159 * 1.5);\n    vec3 ref = vec3(0, 0, 0);\n    vec3 rayDir;\n    \n    rayCast(eye, ref, uv, rayDir);\n    \n    Intersection isect = sdf3D(rayDir, eye, lightPos);\n\n    // Output to screen\n    fragColor = vec4(isect.color, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Ws2yRt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsBBDD", "name": "Weird sin wave thing", "author": "LowSpecCorgi", "description": "A weird sin wave thing, derived from https://thebookofshaders.com", "tags": ["wave", "sin", "weird"], "likes": 1, "viewed": 44, "date": "1590063735", "time_retrieved": "2024-06-20T20:08:59.668019", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n\n// Plot a line on Y using a value between 0.0-1.0\nfloat plot(vec2 st, float pct){\n  return  smoothstep( pct/0.1, pct, sin(st.y) * 2.0) -\n          smoothstep( pct, pct+0.9, cos(st.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 st = gl_FragCoord.xy/iResolution.xy;\n\n    float y = sin(st.x)*35.0;\n\n    vec3 color = vec3(y);\n\n    // Plot a line\n    float pct = plot(st,cos(y) * sin(iTime));\n    color = (0.1-pct)*color+pct*vec3(1.0, 0.5, 0.0);\n\n\tfragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsBBDD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsBBDz", "name": "Wooma trophy", "author": "sukupaper", "description": "Based on Wooma, a character from this animated short film : https://www.youtube.com/watch?v=5onyUu9v2ss ", "tags": ["raymarching", "cartoon", "character", "wooma", "trophy", "ssb"], "likes": 9, "viewed": 119, "date": "1589827946", "time_retrieved": "2024-06-20T20:08:59.668019", "image_code": "#define P 3.14159265359\nfloat t;\nfloat aa;\nvec2 mouse = vec2(0.);\n\nmat2 rot(float a) { float c = cos(a), s = sin(a); return mat2(c,s,-s,c);}\nfloat rand(vec2 st){ return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.585); }\n\nfloat smoothunion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat sph(vec3 p, float s) { return length(p) - s; }\nfloat cyl( vec3 p, float h, float r ) {\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n    return max(length(max(abs(p.y) - h,0.)) - .01, length(p.xz) - r) - .01;\n}\n\nfloat ear(vec3 p) {\n    p.x *= 1.8;\n    p.z *= 1.2;\n    float s1 = sph(p + vec3(0.,0.,0.),.2);\n    float s2 = sph(p + vec3(0.,0.3,0.),.1);\n    float s3 = sph(p + vec3(0.,.6,0.),.3);\n    float d = smoothunion(smoothunion(s1,s2,0.45),s3,0.4);\n    return d*.5;\n}\nfloat headShape(vec3 p) {\n    vec3 pp;\n    float s1 = sph(p*vec3(.95,1.3,1.25),.45)/1.5;\n    \n    pp = p;\n    pp.z += pp.y*.2;\n    float s2 = sph(pp*vec3(2.1,1.8,2.5) - vec3(0.,.6,0.),.45)/2.5;\n    \n    pp.x = abs(pp.x);\n    pp.xy *= rot(-.21);\n    float s3 = sph(pp*vec3(2.6,2.5,2.9) - vec3(0.8,.7,0.),.45)/2.5;\n    float s4 = min(s2,s3);\n    \n    pp = p;\n    pp.x = abs(pp.x);\n    pp.x -= .33;\n    pp.xy *= rot(-pp.y*.2);\n    pp.xz *= rot(.21);\n    float e1 = ear(pp);\n    \n    return smoothunion(smoothunion(e1,s1,.05),s4,.15);\n}\nfloat body(vec3 p) {\n    float bd = cyl(p + vec3(0.,.7,0.),.55,.1 + pow(abs(-p.y)*.2,.89) + .02*(sin(p.y*12.)*.5+.5));\n    return max(bd, -(p.y + 1.1 + (sin(p.z*15.)+sin(p.x*15.))*.01))*.99;\n}\nfloat smash2d(vec2 p) {\n    vec2 pp = p + vec2(.2,.1);\n    return max((length(p) - .45),-(min(abs(pp.x),abs(pp.y) + .055) - .1));\n}\nfloat smash(vec3 p) {\n    return cyl(p + vec3(0.,1.21,0.),.02 + smoothstep(0.,0.001,smash2d(p.xz*.8))*.03,.7);\n}\n\nfloat anim1(float x, float sm) {\n  return smoothstep(-sm,sm,fract(x) - .5) + floor(x);\n}\n\nint matid = 0;\nvec3 eyMap;\nfloat df(vec3 p) {\n    p.yz *= rot(-.05);\n    p.y += .75;\n    p.yz *= rot((mouse.y - .5)*.3);\n    p.xz *= rot((mouse.x - .5)*.5);\n    p.y -= .75;\n    float t1 = cos(t*2.)*.5+.5;\n    \n    float smash = smash(p);\n    \n    vec3 pp;\n    \n    float hs = headShape(p);\n    float bd = body(p);\n    \n    pp = p;\n    pp.x = abs(pp.x);\n    eyMap = pp*vec3(1.,1.2,2.) + vec3(-0.13,-0.05,.72);\n    float ey = sph(eyMap,.14)/1.2;\n    \n    pp = p;\n    pp.y -= pow(abs(pp.x),2.8);\n    float mo = sph(pp*vec3(1.2 + t1*.05,4.8,1.) + vec3(0.,0.5,0.5),.5)/4.8;\n    \n    pp = p;\n    pp.x = abs(pp.x) - .25;\n    float th = sph(pp*vec3(1,.6,1.) + vec3(0.,0.08,.2),.035);\n    \n    float d;\n    d = min(bd,hs);\n    d = max(d,-mo);\n    d = min(d,ey);\n    d = min(d,th);\n    d = min(d,smash);\n    \n    if(d >= ey) matid = 3;\n    else if(d >= th) matid = 5;\n    else if(d >= mo) matid = 4;\n    else if(d >= bd) matid = 1;\n    else if(d >= hs) matid = 2;\n    else if(d >= smash) matid = 6;\n    \n    return d;\n}\n\n#define E .0001\nvec3 normal(vec3 p) {\n    vec2 u = vec2(0.,E); float d = df(p);\n    return normalize(vec3(df(p + u.yxx),df(p + u.xyx),df(p + u.xxy)) - d);\n}\n\nvec3 reflection(vec3 v){\n    vec3 n = normal(v);\n    return normalize(v - 2.*dot(v,n)*n);\n}\n\n#define MAX_D 5.\n#define MIN_D 3.\n#define MAX_STEP 70\n#define EDP aa*15.\n#define LIM .001\nvec3 rm(vec3 cam, vec3 rayDir) {\n    vec3 c = vec3(0.301, 0.388, 0.635)*1.9 - rayDir.y;\n    vec3 pInit = cam + rayDir*MIN_D;\n    vec3 p = pInit;\n    float prevD = 10e9;\n    float nbReflections = 0.;\n    for(int i = 0; i < MAX_STEP; i++) {\n        float d = df(p);\n        if(prevD < EDP && d > prevD) return vec3(0.136,0.069,0.465);\n        if(d < LIM) {\n            vec3 n = normal(p);\n            vec3 light = normalize(vec3(0.244,0.909,-1.080));\n\n            float cl = clamp(dot(n,light),0.3,1.);\n            float cv = clamp(dot(n,rayDir) + 1.,0.,1.);\n\n            vec3 col = vec3(1.,0.,0.);\n            if(matid == 1) {\n                col = vec3(0.301, 0.388, 0.635) + cv*.2;\n            } else if(matid == 2) {\n                col = vec3(0.854, 0.549, 0.266) + cv*.3;\n            } else if(matid == 3) {\n                float rs = .05;\n                float a = -1.;\n                vec2 animShift = vec2(cos(t*30.),cos(t*305.));\n                vec2 shift = vec2(cos(a)*rs,sin(a)*rs) + animShift*.002;\n                return mix(vec3(0.136,0.069,0.465),vec3(1.), step(0.,(length(eyMap.xy + shift) - .04 - animShift.y*.001)));\n            } else if(matid == 4) {\n                return vec3(0.603, 0.227, 0.223)*1.5 - cv*.1;\n            } else if(matid == 5) {\n                col = vec3(1.);\n            } else if(matid == 6) {\n                col = vec3(1.000,0.762,0.130);\n            }\n            \n            return col + smoothstep(0.4,0.5,cl)*.2 * (1.+float(i)*.105);//smoothstep(0.4,0.5,cl)\n        }\n        if(distance(pInit,p) > MAX_D) return c*vec3(0.141,0.292,0.465) + float(i)/100.;\n        p += d*rayDir;\n        prevD = min(prevD,d);\n    }\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy/iResolution.xy - .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    t = iTime;\n\taa = 1./iResolution.x;\n\tmouse = iMouse.xy/iResolution.xy;\n    \n    vec3 c = vec3(0.,-.25,(-5.));\n    vec3 r = normalize(vec3(uv,1.6));\n    vec3 col = rm(c,r);\n    \n    fragColor = vec4(col*1.1 - pow(length(uv)*.5, 2.),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsBBDz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsBBRw", "name": "Corroding Arbitrary SDF (2D)", "author": "blackle", "description": "this is the technique in [url]https://www.shadertoy.com/view/td2fRD[/url] but a 3d SDF mapping to a 2d sdf, instead of a 4d to a 3d. should be easier to understand.", "tags": ["sdf"], "likes": 10, "viewed": 408, "date": "1589661702", "time_retrieved": "2024-06-20T20:09:00.383162", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//this is the technique in https://www.shadertoy.com/view/td2fRD\n//but a 3d SDF mapping to a 2d sdf, instead of a 4d to a 3d.\n//should be easier to understand.\n\n#define FK(k) floatBitsToInt(k)^floatBitsToInt(cos(k))\nfloat hash(float a, float b) {\n    int x = FK(a); int y = FK(b);\n    return float((x*x-y)*(y*y+x)+x)/2.14e9;\n}\n\n//return the SDF for a sphere, or the SDF for an empty region surrounded by spheres\nfloat gated_domain(vec3 p, float scale, bool gated) {\n    if (!gated) {\n        p.xy = abs(p.xy);\n        if (p.x > p.y) p.xy = p.yx;\n        p.y -= 1./scale;\n    }\n    return length(p)-.2;\n}\n\nfloat scene3d(vec3 p) {\n    float scale = 2.;\n    vec2 id = floor(p.xy*scale);\n    p.xy = (fract(p.xy*scale)-0.5)/scale;\n    bool gated = hash(id.x, id.y) > 0.;\n    return gated_domain(p, scale, gated);\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax,p)*ax,p,cos(ro)) + sin(ro)*cross(ax,p);\n}\n\nint pittingtype;\nfloat scene2d(vec2 p) {\n    float circle = length(p)-1.;\n\n    float top = circle;\n    float last = circle;\n    for (int i = 0; i < 5; i++) {\n        float scale = 1./float(i+1);\n        //map 3d coordinates to 4d using the distance to the SDF\n    \tvec3 p3d = vec3(p, last)/scale;\n\t\t//cut out mapped spheres from SDF\n        float holes = scene3d(p3d)*scale;\n    \ttop = max(top, -holes);\n\n        if (pittingtype == 0) last = holes; //add pitting to existing pits\n        if (pittingtype == 1) last = top; //add pitting everywhere\n        if (pittingtype == 2) last = circle; //add pitting only to original surface\n    }\n    return top;\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(scene3d(p)-vec3(scene3d(k[0]),scene3d(k[1]),scene3d(k[2])));\n}\n\nvec3 render3d(vec2 uv) {\n    \n    vec3 cam = normalize(vec3(2,uv));\n    vec3 init = vec3(-5,0,2);\n    \n    cam = erot(cam,vec3(0,1,0), .3);\n    cam = erot(cam,vec3(0,0,1), iTime*.1);\n    \n    vec3 p = init; \n    bool hit = false;\n    //raymarch\n    for (int i = 0; i < 100 && !hit; i++) {\n        float dist = scene3d(p);\n        hit = dist*dist < 1e-6;\n        p+=cam*dist*.9;\n        if (distance(p,init) > 100.) break;\n    }\n    //shading\n    vec3 n = norm(p);\n    return hit ? sin(n)*.5+.5 : vec3(0.1);\n}\n\nvec3 shadeDistance(float d) {\n    float dist = d*150.0;\n    float banding = max(sin(dist), 0.0);\n    float strength = sqrt(1.-exp(-abs(d)*2.));\n    float pattern = mix(strength, banding, (0.6-abs(strength-0.5))*0.3);\n    \n    vec3 color = vec3(pattern);\n    color *= d > 0.0 ? vec3(1.0,0.56,0.4) : vec3(0.4,0.9,1.0);\n\n    return color;\n}\n\nfloat antialias(float x) {\n    float pixelsize = 3./iResolution.y;\n    return smoothstep(-pixelsize, pixelsize, x);\n}\n\nvec3 render2d(vec2 uv, vec2 mouse) {\n    uv *= 3.; mouse *= 3.;\n    vec3 col = shadeDistance(scene2d(uv));\n    \n    float mousedist = scene2d(mouse);\n    if (iMouse.z > 0.) {\n        col *= antialias(distance(mouse, uv) - abs(mousedist))*0.5+0.5;\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-.5*iResolution.xy)/iResolution.y;\n    pittingtype = int(iTime)%3;\n    \n    if (uv.x > .0) {\n        fragColor.xyz = render3d(uv-vec2(0.45,0.));\n    } else {\n        fragColor.xyz = render2d(uv+vec2(0.45,0.), mouse+vec2(0.45,0.));\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc0-1.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsBBRw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsBBWD", "name": "Spiral galaxy", "author": "mrange", "description": "Spiral galaxy\nWould benefit from anti-aliasing but looks okish when I run it in fullscreen in FF\nLots of random coding and little thought so the code is kind of messy", "tags": ["raytracing"], "likes": 35, "viewed": 897, "date": "1590057425", "time_retrieved": "2024-06-20T20:09:01.771126", "image_code": "// License CC0: Spiral galaxy\n//  Would benefit from anti-aliasing but looks okish when I run it in fullscreen in FF\n//  Lots of random coding and little thought so the code is kind of messy\n#define PI  3.141592654\n#define TAU (2.0*PI)\n\n#define TIME (iTime*0.1)\n\n#define LESS(a,b,c) mix(a,b,step(0.,c))\n\n#define SABS(x,k)    LESS((.5/k)*x*x+k*.5,abs(x),abs(x)-k)\n\n#define RESOLUTION   iResolution\n\nconst float twirly =2.5;\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return p.x*vec2(cos(p.y), sin(p.y));\n}\n\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\nfloat noise1(vec2 p) {\n  float s = 1.0;\n\n  p *= tanh(0.1*length(p));\n  float tm = TIME;\n\n  float a = cos(p.x);\n  float b = cos(p.y);\n\n  float c = cos(p.x*sqrt(3.5)+tm);\n  float d = cos(p.y*sqrt(1.5)+tm);\n\n  return a*b*c*d;\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nvec2 twirl(vec2 p, float a, float z) {\n  vec2 pp = toPolar(p);\n  pp.y += pp.x*twirly + a;\n  p = toRect(pp);\n  \n  p *= z;\n  \n  return p;\n}\n\nfloat galaxy(vec2 p, float a, float z) {\n  p = twirl(p, a, z);\n  \n  return noise1(p);\n}\n\nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nvec2 raySphere(vec3 ro, vec3 rd, vec3 center, float radius)\n{\n    //get the vector from the center of this circle to where the ray begins.\n    vec3 m = ro - center.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n    float b = dot(m, rd);\n\n    float c = dot(m, m) - radius*radius;\n\n    //exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n    if(c > 0.0 && b > 0.0) return vec2(-1.0, -1.0);\n\n    //calculate discriminant\n    float discr = b * b - c;\n\n    //a negative discriminant corresponds to ray missing sphere\n    if(discr < 0.0) return vec2(-1.0);\n\n    //ray now found to intersect sphere, compute smallest t value of intersection\n    float normalMultiplier = 1.0;\n    float s = sqrt(discr);\n    float t0 = -b - s;\n    float t1 = -b + s;;\n    \n    // return the time t that the collision happened, as well as the surface normal\n    return vec2(t0, t1);\n}\n\n\nvec3 stars(vec2 p) {\n  float l = length(p);\n\n  vec2 pp = toPolar(p);\n  pp.x /= (1.0+length(pp.x))*0.5;\n  p = toRect(pp);\n\n  float sz = 0.0075;\n  \n  vec3 s = vec3(10000.0);\n    \n  for (int i = 0; i < 3; ++i) {  \n    rot(p, 0.5);\n    vec2 ip = p;\n    vec2 n = mod2(ip, vec2(sz));\n    float r = rand(n);\n    vec2 o = -1.0 + 2.0*vec2(r, fract(r*1000.0));\n    s.x = min(s.x, length(ip-0.25*sz*o));\n    s.yz = n*0.1;\n  }\n  \n  return s;\n}\n\nfloat height(vec2 p) {\n  float ang = atan(p.y, p.x);\n  float l = length(p);\n  float sp = mix(1.0, pow(0.75 + 0.25*sin(2.0*(ang + l*twirly)), 3.0), tanh(6.0*l));\n  float s = 0.0;\n  float a = 1.0;\n  float f = 15.0;\n  float d = 0.0;\n  for (int i = 0; i < 11; ++i) {\n    float g = a*galaxy(p, TIME*(0.025*float(i)), f);\n    s += g;\n    a *= sqrt(0.45);\n    f *= sqrt(2.0);\n    d += a;\n  }\n  \n  s *= sp;\n  \n  return SABS((-0.25+ s/d), 0.5)*exp(-5.5*l*l);\n}\n\nvec3 normal(vec2 p) {\n  vec2 eps = vec2(0.000125, 0.0);\n  \n  vec3 n;\n  \n  n.x = height(p - eps.xy) - height(p + eps.xy);\n  n.y = 2.0*eps.x;\n  n.z = height(p - eps.yx) - height(p + eps.yx);\n  \n  return normalize(n);\n}\n\nconst vec3 colDust = vec3(1.0, 0.9, 0.75);\n\nvec3 galaxy(vec2 p, vec3 ro, vec3 rd, float d) {\n  rot(p, 0.5*TIME);\n\n  float h = height(p);\n  vec3 s = stars(p);\n  float th = tanh(h);\n  vec3 n = normal(p);\n  \n  vec3 p3 = vec3(p.x, th, p.y);\n  float lh = 0.5;\n  vec3 lp1 = vec3(-0.0, lh, 0.0);\n  vec3 ld1 = normalize(lp1 - p3);\n  vec3 lp2 = vec3(0.0, lh, 0.0);\n  vec3 ld2 = normalize(lp2 - p3);\n\n  float l = length(p);\n  float tl = tanh(l);\n\n  float diff1 = max(dot(ld1, n), 0.0);\n  float diff2 = max(dot(ld2, n), 0.0);\n\n  vec3 col = vec3(0.0);\n  col += vec3(0.5, 0.5, 0.75)*h;\n//  col += vec3(0.5)*pow(diff1, 20.0);\n  col += 0.25*pow(diff2, 4.0);\n  col += pow(vec3(0.5)*h, n.y*1.75*(mix(vec3(0.5, 1.0, 1.5), vec3(0.5, 1.0, 1.5).zyx, 1.25*tl)));\n//  col += 0.9*vec3(1.0, 0.9, 0.75)*exp(-10*l*l);\n\n\n  float sr = rand(s.yz);\n  float si = pow(th*sr, 0.25)*0.001;\n  vec3 scol = sr*5.0*exp(-2.5*l*l)*tanh(pow(si/(s.x), 2.5))*mix(vec3(0.5, 0.75, 1.0), vec3(1.0, 0.75, 0.5), sr*0.6);\n  scol = clamp(scol, 0.0, 1.0);\n  col += scol*smoothstep(0.0, 0.35, 1.0-n.y);\n  \n  float ddust = (h - ro.y)/rd.y;\n  if (ddust < d) {\n    float t = d - ddust;\n    col += 0.7*colDust*(1.0-exp(-2.0*t));\n  }\n\n  return col;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  float dgalaxy = (0.0 - ro.y)/rd.y;\n  \n  vec3 col = vec3(0);\n  \n  if (dgalaxy > 0.0) {\n    col = vec3(0.5);\n    vec3 p = ro + dgalaxy*rd;\n    \n    col = galaxy(p.xz, ro, rd, dgalaxy);\n  }\n  \n  vec2 cgalaxy = raySphere(ro, rd, vec3(0.0), 0.125);\n\n  float t;\n  \n  if (dgalaxy > 0.0 && cgalaxy.x > 0.0) {\n    float t0 = max(dgalaxy - cgalaxy.x, 0.0);\n    float t1 = cgalaxy.y - cgalaxy.x;\n    t = min(t0, t1);\n  } else if (cgalaxy.x < cgalaxy.y){\n    t = cgalaxy.y - cgalaxy.x;\n  }\n  \n  col += 1.7*colDust*(1.0-exp(-1.0*t));\n  \n  \n  return col;\n}\n\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 ro = vec3(0.0, 0.7, 2.0)*0.75;\n  vec3 la = vec3(0.0, 0.0, 0.0);\n  vec3 up = vec3(-0.5, 1.0, 0.0);\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.5*ww);\n  \n  \n  vec3 col = render(ro, rd);\n\n  col = postProcess(col, q);\n\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc0-1.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsBBWD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsBBWR", "name": "TRUMP CARD", "author": "yasuo", "description": "nothing special about this.", "tags": ["trump"], "likes": 5, "viewed": 277, "date": "1589812957", "time_retrieved": "2024-06-20T20:09:03.450012", "image_code": "// All the distance functions from:http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 100\n#define MAX_DIST 16.\n#define SURF_DIST .002\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n\nvec4 combine(vec4 val1, vec4 val2 ){\n    return (val1.w < val2.w)?val1:val2;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n// https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdBox(vec2 p, vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdVesica(vec2 p, float r, float d)\n{\n    p = abs(p);\n    float b = sqrt(r*r-d*d);\n    return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))\n                             : length(p-vec2(-d,0.0))-r;\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    vec2 q = abs(p);\n    float h = clamp((-2.0*ndot(q,b)+ndot(b,b))/dot(b,b),-1.0,1.0);\n    float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( q.x*b.y + q.y*b.x - b.x*b.y );\n}\n\nfloat heart(vec2 p, vec3 col) {\n    vec2 prevP = p;\n    p.y-=0.05;\n    float d = sdVesica(p,0.15,0.05);\n    d = max(p.y,d);\n    p.x = abs(p.x);\n    p.x -=0.05;\n    float d2 = length(p)-0.05;\n    d = min(d,d2);\n    return d;\n}\n\nfloat spades(vec2 p, vec3 col) {\n    vec2 prevP = p;\n\n    float sc = mix(1.5,0.1,smoothstep(-0.2,0.6,p.y));\n    p.x*=sc;\n    p.y*=1.3;\n    float d = sdTriangle(p,vec2(0.1,0.0),vec2(0.0,0.15),vec2(-0.1,0.0));\n  \tp = prevP;\n    p.x = abs(p.x);\n    p.x -=0.05;\n    p.y +=0.02;\n    float d2 = length(p)-0.05;\n    d = opSmoothUnion(d,d2,0.06);\n    \n    p = prevP;\n    float d3 = sdTriangle(p,vec2(0.03,-0.1),vec2(0.0,-0.04),vec2(-0.03,-0.1));\n    d = min(d,d3);\n    \n    return d;\n}\n\nfloat clover(vec2 p, vec3 col) {\n    vec2 prevP = p;\n    \n    float d = length(p-vec2(0.0,0.05))-0.05;\n    p.x = abs(p.x);\n    p.x -=0.047;\n    p.y +=0.02;\n    float d2 = length(p)-0.05;\n    d = min(d,d2);\n    \n    p = prevP;\n    float d3 = sdTriangle(p,vec2(0.03,-0.1),vec2(0.0,-0.04),vec2(-0.03,-0.1));\n    d = min(d,d3);\n    return d;\n}\n\nfloat diamond(vec2 p, vec3 col) {\n    vec2 prevP = p;\n    float d = sdRhombus(p,vec2(0.05,0.1));\n    return d;\n}\n\nfloat trumpIcon(vec2 p, vec3 col, int type) {\n    float d = heart(p,col);\n  if(type == 2){\n        d = spades(p,col);\n    } else if(type == 3){\n        d = clover(p,col);\n    } else if(type == 4){\n        d = diamond(p,col);\n    }\n    return d;\n}\n\nvec3 trumpTex(vec2 p, vec3 col, int num, int type) {\n    vec2 prevP = p;\n    float d = 0.0;\n    if(num == 1) {\n        d = trumpIcon(p,col,type);\n    } else if(num == 2) {\n        p.y = mod(p.y,0.8)-0.4;\n        d = trumpIcon(p,col,type);\n        p = prevP;\n        d = max(p.y-0.8,d);\n        d = max(-p.y-0.8,d);\n    } else if(num == 3) {\n        p.y+=-0.2;\n    p.y = mod(p.y,0.4)-0.2;\n        d = trumpIcon(p,col,type);\n    p = prevP;\n        d = max(p.y-0.6,d);\n        d = max(-p.y-0.6,d);\n    } else if(num == 4) {\n        p.x = abs(p.x);\n        p.x-=0.2;\n    p.y = mod(p.y,0.8)-0.4;\n        d = trumpIcon(p,col,type);\n        p = prevP;\n        d = max(p.y-0.8,d);\n        d = max(-p.y-0.8,d);\n    } else if(num == 5) {\n        float d2 = trumpIcon(p,col,type);\n    p.x = abs(p.x);\n        p.x-=0.2;\n    p.y = mod(p.y,0.8)-0.4;\n        d = trumpIcon(p,col,type);\n        d = min(d,d2);\n        p = prevP;\n        d = max(p.y-0.8,d);\n        d = max(-p.y-0.8,d);\n    } else if(num == 6) {\n        p.x = abs(p.x);\n        p.x-=0.2;\n        p.y+=-0.2;\n    p.y = mod(p.y,0.4)-0.2;\n        d = trumpIcon(p,col,type);\n    p = prevP;\n        d = max(p.y-0.6,d);\n        d = max(-p.y-0.6,d);\n    } else if(num == 7) {\n        float d2 = trumpIcon(p-vec2(0.0,0.2),col,type);\n        p.x = abs(p.x);\n        p.x-=0.2;\n        p.y+=-0.2;\n    p.y = mod(p.y,0.4)-0.2;\n        d = trumpIcon(p,col,type);\n        d = min(d,d2);\n    p = prevP;\n        d = max(p.y-0.6,d);\n        d = max(-p.y-0.6,d);\n    } else if(num == 8) {\n    float d2 = trumpIcon(p-vec2(0.0,0.2),col,type);\n        float d3 = trumpIcon(p-vec2(0.0,-0.2),col,type);\n        p.x = abs(p.x);\n        p.x-=0.2;\n        p.y+=-0.2;\n    p.y = mod(p.y,0.4)-0.2;\n        d = trumpIcon(p,col,type);\n        d = min(d,min(d2,d3));\n    p = prevP;\n        d = max(p.y-0.6,d);\n        d = max(-p.y-0.6,d);\n    } else if(num == 9) {\n        float d2 = trumpIcon(p,col,type);\n    p.x = abs(p.x);\n        p.x-=0.2;\n    p.y = mod(p.y,0.27)-0.135;\n        d = trumpIcon(p,col,type);\n        d = min(d,d2);\n    p = prevP;\n        d = max(p.y-0.55,d);\n        d = max(-p.y-0.55,d);\n    } else if(num == 10) {\n        float d2 = trumpIcon(p-vec2(0.0,0.25),col,type);\n        float d3 = trumpIcon(p-vec2(0.0,-0.25),col,type);\n    p.x = abs(p.x);\n        p.x-=0.2;\n    p.y = mod(p.y,0.27)-0.135;\n        d = trumpIcon(p,col,type);\n        d = min(d,min(d2,d3));\n    p = prevP;\n        d = max(p.y-0.55,d);\n        d = max(-p.y-0.55,d);\n    }\n    p = prevP;\n    p*=1.5;\n    float d2 = trumpIcon(p-vec2(0.6,0.95),col,type);\n    p.y*=-1.0;\n    float d3 = trumpIcon(p-vec2(-0.6,0.95),col,type);\n    d = min(d,min(d2,d3));\n    col = mix(col,vec3(0.7,0.0,0.0),S(d,0.0));\n    return col;\n}\n\n\nvec4 GetDist(vec3 p) {\n    \n    vec3 prevP = p;\n    vec2 uv = p.xy;\n    uv.y-=1.25;\n    uv*=0.5;\n    \n    p.z+=iTime*10.0;\n    p.z = mod(p.z,4.0)-0.2;\n\n    float y = 0.25;\n\n    // card\n    vec3 size = vec3(1.0,1.5,0.001);\n    float edge = 0.02;\n    float card = sdBox(p-vec3(0.0,1.0+y,0.0),size)-edge;\n    vec3 col = trumpTex(uv,vec3(1.0),1,1);\n    vec4 resA = vec4(col,card);\n\t\n    float card2 = sdBox(p-vec3(0.0,1.0+y,1.0),size)-edge;\n    vec3 col2 = trumpTex(uv,vec3(1.0),3,2);\n    vec4 resB = vec4(col2,card2);\n\t\n    float card3 = sdBox(p-vec3(0.0,1.0+y,2.0),size)-edge;\n    vec3 col3 = trumpTex(uv,vec3(1.0),5,3);\n    vec4 resC = vec4(col3,card3);\n\t\n    float card4 = sdBox(p-vec3(0.0,1.0+y,3.0),size)-edge;\n    vec3 col4 = trumpTex(uv,vec3(1.0),7,4);\n    vec4 resD = vec4(col4,card4);\n\t\t\n    float card5 = sdBox(p-vec3(0.0,1.0+y,4.0),size)-edge;\n    vec3 col5 = trumpTex(uv,vec3(1.0),9,2);\n    vec4 resE = vec4(col5,card5);\n    \n    vec4 model = combine(resA,combine(resB,combine(resC,combine(resD,resE))));\n    return model;\n}\n\nvec4 RayMarch(vec3 ro, vec3 rd) {\n    vec4 dO= vec4(0.0);\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO.w;\n        vec4 dS = GetDist(p);\n        dO.w += dS.w;\n        dO.xyz = dS.xyz;\n        if(dO.w>MAX_DIST || dS.w<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).w;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).w,\n        GetDist(p-e.yxy).w,\n        GetDist(p-e.yyx).w);\n    \n    return normalize(n);\n}\n\nvec2 GetLight(vec3 p) {\n    vec3 lightPos = vec3(2,8,3);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l).w;\n    \n    float lambert = max(.0, dot( n, l))*0.5;\n    \n    return vec2((lambert+dif),max(0.9, 1.0)) ;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    float t = mod(iTime,8000.0);\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 8, -4.5);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.yz *= Rot(radians(-30.0));\n    ro.xz *= Rot(t*.3+1.0);\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,1,0), 1.);\n\n    vec4 d = RayMarch(ro, rd);\n    \n    if(d.w<MAX_DIST) {\n        vec3 p = ro + rd * d.w;\n    \n        vec2 dif = GetLight(p);\n        col = vec3(dif.x)*d.xyz;\n        col *= dif.y;\n        \n    } else {\n        // background\n        col = vec3(0.0,0.6,0.3);\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsBBWR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsBBz3", "name": "twisty star rose", "author": "HaleyHalcyon", "description": "a", "tags": ["spiral"], "likes": 6, "viewed": 143, "date": "1590500895", "time_retrieved": "2024-06-20T20:09:03.880443", "image_code": "const float PI = 3.14159265;\nconst float PI_2 = PI / 2.;\n\nfloat fold(float x) {\n    return abs(mod(x, 2.0) - 1.0);\n}\n\nfloat foldPlus(float x) {\n    return log(0.5 + fold(x));\n}\n\nfloat smoothThres(float x, float strength) {\n    return smoothstep(0.5 - strength, 0.5 + strength, x);\n}\n\nfloat smoothFold(float x, float strength) {\n    return smoothThres(fold(x), strength);\n}\n\nvec3 colMap(float x, vec3 a, vec3 b) {\n    return a * (1.0 - x) + b * x;\n}\n\nvec3 hue(float x) {\n    return (vec3(\n    \tsin(x),\n        sin(x + 2. * PI / 3.),\n        sin(x + 4. * PI / 3.)\n    ) + 1.0) * 0.6;\n}\n\nfloat star(float angle, float d, float roundness) {\n    return foldPlus(angle * 10.) + d * roundness;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = fract(iTime / 8.);\n    \n    // Normalized pixel coordinates\n    float scale = min(iResolution.x, iResolution.y);\n    vec2 uv = fragCoord / scale;\n\tuv -= iResolution.xy / scale / 2.;\n    uv *= 2.;\n    float dist = log(uv.x*uv.x+uv.y*uv.y); // not real distance, but useful for log spirals\n    float angle = atan(uv.x, uv.y) / PI / 2.;\n    float angleLayer = t / 5.;\n    float offsetLayer = t * 3.;\n    float spaceLayer = 0.5;\n    vec3 colA = vec3(1.0, 0.3, 0.8);\n    vec3 colB = vec3(0.3, 0.7, 1.0);\n    vec3 colC = hue(t * 2. * PI);\n    vec3 col = vec3(fold(t * 16.));\n    \n    if (dist >= -8.) {\n        for (float iRing = 0.; iRing < 25.; iRing += 1.) {\n            if (star(angle - (iRing * angleLayer), dist, 1.1) < spaceLayer * (iRing - offsetLayer) - 7.){\n                switch (int(iRing) % 3) {\n                    case 0:\n                        col = colA;\n                        break;\n                    case 1:\n                        col = colB;\n                        break;\n                    case 2:\n                        col = colC;\n                }\n                break;\n            }\n        }\n    }\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsBBz3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsBBzw", "name": "Space Ship Warp  (127 to 91 ch)", "author": "Smake", "description": "Min demo with some gist. Inside the space ship into warp  jump.", "tags": ["texture", "space", "effect", "warp", "short", "golf", "fly"], "likes": 1, "viewed": 103, "date": "1589670620", "time_retrieved": "2024-06-20T20:09:03.880443", "image_code": "//FabriceNeyret2, 2020-05-18\n// 91 ch  - incredible for one-way, non-cyclic hyper-space jump ) !!!\n/**/\nvoid mainImage(out vec4 O, vec2 U)\n{\n    for (; O.a++ < 15.; ) O.xy += U/5e3* (.3 -sin(O.x*50.)-sin(O.y*50.)-iTime/20. );\n}\n\n\n//FabriceNeyret2, 2020-05-18\n// more simplif, + sin(p.z) very close to p.z:\n//-> 94 chars\n/*        \n#define mainImage(O,U)                                      \\\n    for (O-=O; O.a++ < 15.; )                               \\\n        O.xy += U/1e2* (.33 -sin(O.x)-sin(O.y)-iTime/20. ); \\\n     O /= 5e1\n*/\n\n\n//coyote, 2020-05-18\n//119 chars:\n/*\n#define mainImage(O,U)\\\n   vec4  d = vec4(3.*U/8e2, 0,0), e;\\\n        for (O.z = 5e-2*iTime; d.a++ < 14.; O += d -3.*d*(e.x+e.y+e.z) )\\\n            e=sin(O);\\\n        O /= 5e1\n*/\n\n\n\n\n//iapafoto, 2020-05-17.  Only  123 chars!!!\n//\n/* \n#define mainImage(O,U)\\\n   vec4  d = vec4(3.*U/8e2, 0,0), p,e;\\\n        for (p.z = 5e-2*iTime; O.a++ < 15.; )\\\n            e=sin(p),\\\n        \tp += d -3.*d*(e.x+e.y+e.z) ;\\\n        O = p/5e1\n/**/\n    \n//Created by Smake in 2020-05-16,127 chars\n\n/*\n#define mainImage(O,U)\\\n   vec4  d = vec4(3.*U/8e2, 0,0), p;\\\n        for (p.z = 5e-2*iTime; O.a++ < 15.; )\\\n        p += d -3.*d*(sin(p.x)+sin(p.y)+sin(p.z)) ;\\\n        O = p/5e1\n*/", "image_inputs": [{"id": "XdfGzn", "previewfilepath": "/media/ap/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsBBzw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsBfDG", "name": "Pulse_effect", "author": "C1TYZen", "description": "training", "tags": ["trash"], "likes": 0, "viewed": 39, "date": "1590698749", "time_retrieved": "2024-06-20T20:09:03.880443", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 st = fragCoord/iResolution.xy;\n    \n    vec3 color = vec3(0.0);\n\n    vec2 pos = vec2(0.5)-st;\n\n    float r = length(pos)*2.0;\n    float a = atan(pos.y,pos.x)+iTime;\n\n    float f = abs(cos(a*(sin(iTime*.0001)+1.))*cos(a*3.))*1.360;\n\n    color = vec3( 1.-smoothstep(f,f+0.932,r) ) - vec3( 1.-smoothstep(f,0.268,r-cos(iTime*2.)*0.2-0.2) );\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsBfDG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsBfDw", "name": "Stainless", "author": "TAKUSAKU", "description": "stainless", "tags": ["metal", "stainless"], "likes": 9, "viewed": 169, "date": "1590154868", "time_retrieved": "2024-06-20T20:09:03.880443", "image_code": "float random (in vec2 _st) {\n    return fract(sin(dot(_st.xy, vec2(0.89,-0.90)))*757.153);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3. - 2. * f);\n\n    return mix(a, b, u.x) + (c - a)* u.y * (1. - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat fbm ( in vec2 _st) {\n    float v = sin(iTime*0.5)*0.2;\n    float a = 0.8;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(1.0), -sin(0.5), acos(0.5));\n    for (int i = 0; i < 5; ++i) {\n        v += a * noise(_st);\n        _st = rot * _st * 2. + shift;\n        a *= 0.01;\n    }\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = (2.*fragCoord.xy-iResolution.xy) / min(iResolution.x, iResolution.y) * 0.3;\n    \n    vec2 co = st;    \n    float len;    \n    for (int i = 0; i < 3; i++) {\n        len = length(co);  \n        co.x +=  sin(co.y + iTime * 0.620)*0.3;\n        co.y +=  cos(co.x + iTime * 0.164 + cos(len))*0.3;\n    }    \n    len -= 3.;\n     \n    vec3 col = vec3(0.);\n\n    vec2 q = vec2(0.);\n    q.x = fbm( st + 1.);\n    q.y = fbm( st + vec2(-0.450,0.650));\n\n    vec2 r = vec2(0.);\n    r.x = fbm( st + q + vec2(0.570,0.520)+ 0.5*iTime );\n    r.y = fbm( st + q + vec2(0.340,-0.570)+ 0.4*iTime);\n    \n    for (float i = 0.; i < 3.; i++) {\n        r += 1.0 / abs(mod(st.y + st.x, 0.1 * i) * 1000.) * 1.;\n        r += 1.0 / abs(mod(st.y - st.x, 0.5 * i) * 10.) * 1.;\n    }\n    float f = fbm(st+r);\n    \n    col = mix(col, cos(len + vec3(0.8, 0.0, 0.5)), 1.);\n    col = mix(vec3(0.667,0.527,0.586), vec3(0.101,0.551,0.667), col);\n\n    fragColor = vec4(1.8*(f*f*f+.6*f*f+.5*f)*col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsBfDw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsBfDz", "name": "Solar Grains - Suns Set to Music", "author": "Yambam", "description": "Music visualization fork of https://www.shadertoy.com/view/wdSfzm (Simulating the Sunrise/Sunset) by myself\nWhich is a fork of https://www.shadertoy.com/view/tdBfRw (Simulating the Colors of the Sky) by jamelouis", "tags": ["sunset", "sun", "colors", "sky", "fork", "sunrise", "sunrise", "granular", "simulating"], "likes": 4, "viewed": 338, "date": "1589829952", "time_retrieved": "2024-06-20T20:09:03.880443", "image_code": "const float INFINITY = 3.402823466e+38;\n//const float INFINITY = 1.0 / 0.0;\nconst float M_PI = 3.1415926;\nconst float DURATION = 2.;\n\nconst float earthRadius = 6360e3;\nconst float atmosphereRadius = 6420e3;\nconst float Hr = 7994.;\nconst float Hm = 1200.;\nconst vec3 betaR = vec3(3.8e-6, 13.5e-6,33.1e-6);\nconst vec3 betaM = vec3(21e-6);\n// from 'the graphics codex'\n// Ray-Sphere Intersection\nbool raySphereIntersect(vec3 P, vec3 w, vec3 C, float r, out float t0, out float t1) { \n    vec3 v = P - C;\n    \n    float b = 2.0 * dot(w, v);\n    float c = dot(v,v) - r * r;\n    \n    float d = b * b - 4.0 * c;\n    \n    if(d<0.0) return false;\n    \n    float s = sqrt(d);\n    t0 = (-b-s) * 0.5;\n    t1 = (-b+s) * 0.5;\n    \n    return true;\n}\n\nvec3 computeIncidentLight(vec3 o, vec3 d, float tmin, float tmax, vec3 sunDirection)\n{\n    float t0, t1;\n    if(!raySphereIntersect(o, d, vec3(0.0), atmosphereRadius, t0, t1) || t1 < 0.) return vec3(0.0);\n    if(t0>tmin && t0>0.) tmin = t0;\n    if(t1<tmax) tmax = t1;\n    uint numSamples = 3u;\n    uint numSamplesLight = 3u;\n    float segmentLength = (tmax-tmin)/float(numSamples);\n    float tCurrent = tmin;\n    vec3 sumR = vec3(0.0);\n    vec3 sumM = vec3(0.0);\n    float opticalDepthR = 0.0;\n    float opticalDepthM = 0.0;\n    float mu = dot(d, sunDirection);\n    float phaseR = 3. / (16. * M_PI) * ( 1. + mu * mu);\n    float g = 0.76;\n    float phaseM = 3. / (8. * M_PI) * ((1.-g*g)*(1. + mu*mu)) / ((2. + g*g) * pow(1. + g*g - 2. * g * mu, 1.5));\n    vec3 betaRt = betaR*(1.-(iMouse.y/iResolution.y) + vec3(0.,2.,3.)*(iMouse.x/iResolution.x-.2));\n    vec3 betaMt = betaM*(1. + 16.*0.); //iMouse.y/iResolution.y);\n    \n    for(uint i = 0u; i < numSamples; ++i) {\n        vec3 samplePosition = o + (tCurrent + segmentLength * 0.5) * d;\n        float height = length(samplePosition) - earthRadius;\n        float hr = exp(-height/ Hr) * segmentLength;\n        float hm = exp(-height/Hm) * segmentLength;\n        opticalDepthR += hr;\n        opticalDepthM += hm;\n        float t0Light;\n        float t1Light;\n        raySphereIntersect(samplePosition, sunDirection, vec3(0.0), atmosphereRadius, t0Light, t1Light);\n        float segmentLengthLight = t1Light / float(numSamplesLight);\n        float opticalDepthLightR = 0.;\n        float opticalDepthLightM = 0.;\n        float tCurrentLight = 0.;\n        uint j;\n        for(j=0u;j<numSamplesLight;++j){\n            vec3 samplePositionLight = samplePosition + (tCurrentLight + segmentLengthLight * 0.5) * sunDirection;\n            float heightLight = length(samplePositionLight) - earthRadius;\n            if(heightLight < 0.0) break;\n            opticalDepthLightR += exp(-heightLight / Hr) * segmentLengthLight;\n            opticalDepthLightM += exp(-heightLight / Hm) * segmentLengthLight;\n            tCurrentLight += segmentLengthLight;\n        }\n        if(j==numSamplesLight) {\n            vec3 tau = vec3(betaRt * (opticalDepthR + opticalDepthLightR) + betaMt * 1.1 * (opticalDepthM + opticalDepthLightM));\n            vec3 attenuation = exp(-tau);\n            sumR += attenuation * hr;\n            sumM += attenuation * hm;\n        }\t\n        tCurrent += segmentLength;\n    }\n    \n    return vec3(sumR * betaRt * phaseR + sumM * betaMt * phaseM) * 20.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float x_spectro_free = (fragCoord.x/iResolution.x*20.);\n    /*float x_spectro = .2+.6*x_spectro_free/16.;\n    float fft  = (texture( iChannel0, vec2(x_spectro,0.0) - .2 ).x)*.5-.3;*/\n    \n    float x_spectro_floor = floor(x_spectro_free);\n    float x_spectro_ceil = ceil(x_spectro_free);\n    vec2 x_spectro = .2+.6*vec2(x_spectro_floor,x_spectro_ceil)/20.;\n    float fft  = mix(\n        (texture( iChannel0, vec2(x_spectro.x,0.0) - .2 ).x)\n        ,\n        (texture( iChannel0, vec2(x_spectro.y,0.0) - .2 ).x)\n        ,\n        min((x_spectro_free-x_spectro_floor)*3.,1.) // /(x_spectro_ceil-x_spectro_floor)\n    );\n    //fft = .4-.8*iMouse.x/iResolution.x;\n    //fft = 0.;\n    \n    float daylightCycleSpeed = 1./60.; //0.; //\n    \n    float angle = M_PI * (.0 + 2.*M_PI*(-.0185+.02*sin(2.*M_PI*(iTime*daylightCycleSpeed-.775))+pow(.2835-.1*fft, 2.))); //fract((float(iFrame)/DURATION+40.)/180.)*2.-1.);\n    vec3  sunDirection = vec3(sin(angle), cos(angle), 0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy  * 2.0 - 1.0;\n    bool reflection;\n    if (uv.y<0.) {\n        uv.y = -uv.y;\n        reflection = true;\n    } else {\n        uv.y = .65*uv.y;\n        reflection = false;\n    }\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float scale = .3;\n    float y_scale = 1.;\n    \n    float x = 0.+.5/y_scale*uv.x + .15*iTime + .7*sin(.2*iTime);//float(iFrame)/60.;\n    \n    float y = -.5 * (1. - (.0115*2.4*(-.25 //+ 4.*iMouse.y/iResolution.y\n  + pow(4.+\n        1.000*sin(x*M_PI*1.)\n      + 1.000*sin(x*M_PI*3.)\n      + 0.512*sin(x*M_PI*5.)\n      + 0.512*sin(x*M_PI*7.)\n      + 0.640*sin(x*M_PI*9.)\n      + 0.640*sin(x*M_PI*11.)\n        ,\n        .35\n    )) + .5/y_scale*mod(uv.y, y_scale)));\n    \n    /*y = -.4885 - .0115*2.4*(-1.5 //+ 4.*iMouse.y/iResolution.y\n  + pow(4.+\n        1.000*sin(x*M_PI*1.)\n      + 1.000*sin(x*M_PI*3.)\n      + 0.512*sin(x*M_PI*5.)\n      + 0.512*sin(x*M_PI*7.)\n      + 0.640*sin(x*M_PI*9.)\n      + 0.640*sin(x*M_PI*11.)\n        ,\n        .5\n    )) + .5/y_scale*mod(uv.y, y_scale);*/\n    \n    if (y < -.47) {\n    \ty = mix(y, -.5, min((-.47 - y)/.03*3., 1.));\n    }\n    \n    float z2 = x*x + y*y;\n    \n    vec3 col = vec3(0.0);\n    //if(z2 <= 1.){\n        float phi = x*M_PI*scale;\n        float theta;\n        if (fract(x)*scale > .5) { //<-- Makes the sun rise and set on the same position\n        //if (fract((float(iFrame)/DURATION+40.)/180.) < .5) {\n            theta = y*M_PI*scale-1.125;\n        } else {\n            theta = -(y*M_PI*scale-1.125);\n        }\n        vec3 dir = vec3(sin(theta)*cos(phi), cos(theta), sin(theta)*sin(phi));\n        col = computeIncidentLight(vec3(0.0, earthRadius + 1., 0.0), dir, 0., INFINITY, sunDirection);\n    //}\n    \n\n    // Output to screen\n    //fft  = texture( iChannel0, vec2(x_spectro,0.0) ).x*9.+0.2;\n    //col = pow(col, vec3(1./.6/2.6));\n    col = pow(col, vec3(1./.6/y_scale/(1.5/y_scale+.85/y_scale*(reflection?1.:0.))));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4t2GRV", "previewfilepath": "https://soundcloud.com/wojtek-szczepanik/the-day-after", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/wojtek-szczepanik/the-day-after", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsBfDz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsBfRW", "name": "when you squares", "author": "ReeceGames", "description": "when you SQUARES", "tags": ["trippy", "squares"], "likes": 1, "viewed": 221, "date": "1589546883", "time_retrieved": "2024-06-20T20:09:04.062314", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy-0.5;\n    \n    vec2 sq = vec2(uv.x/(iResolution.y/iResolution.x),uv.y);\n    \n    float dist = distance(sq,vec2(cos(iTime),sin(iTime))/3.0);\n    \n    // Time varying pixel color\n    vec3 col = vec3(sin((sq.x+sq.y*max(sin(iTime),cos(iTime*1.2)))*32.0),cos((sin(iTime*1.2)+sq.y+sin(iTime+sq.x*2.0))*8.0),sin(dist*31.0-iTime*2.0));\n\t\n    if (col.r>0.8&&col.g>0.8)\n    {\n    vec3 col2 = vec3(col.r*0.,col.g*0.2,1.0);\n    col = mix(col,col2 - col.b,mix((col.g-0.8)*3.0,(col.r-0.8)*3.0,0.5));\n    }\n    col = mix(-col,col,sin(iTime)/2.0+0.5)+vec3(0.2,0.2,0.5);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsBfRW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsBfWw", "name": "ShATI - Danger", "author": "Flopine", "description": "My former school named ATI decided to launch an everyday challenge from 4th may to 24th may, here is the 17th subject: danger :)\nInspired by some famous movie you'll recognize ;) ", "tags": ["raymarching", "logo", "ghostbuster"], "likes": 5, "viewed": 85, "date": "1590147387", "time_retrieved": "2024-06-20T20:09:04.844096", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n// Shader made for Everyday ATI challenge\n\n\n#define TAU 6.2831853071\n\nmat2 rot(float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat caps (vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat cyl (vec3 p, float r, float h)\n{return max(length(p.xy)-r,abs(p.z)-h);}\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0.,max(q.x,max(q.y,q.z)))+length(max(q,0.));\n}\n\nvec2 panneau (vec3 p)\n{\n    float r = 2.;\n    float d = max(-cyl(p, r*0.76, 0.5),cyl(p, r, 0.1));\n    p.xy *= rot(-TAU/8.);\n    d = min(d, box(p,vec3(0.2,r*0.9,0.1)));\n    return vec2(d,1.);\n}\n\nvec2 fantome (vec3 p)\n{\n    float r = 1.2;\n    vec3 pp = p;\n    p.xy *= rot(TAU/12.);\n    p.z -= 0.95+sin((p.y+TAU/4.)*TAU/4.)*0.5;   \n    float d = caps(p,vec3(0.,-.9,0.),vec3(0.,.6,0.),r);\n    \n    p = pp;\n    p -= vec3(-0.5,1.7, -0.2);\n    float r2 = 0.5-sin(p.y*TAU)*0.13;\n    d = smin(d, caps(p,vec3(0.,-0.05,0.),vec3(0.,.05,0.),r2), 0.2);\n    \n    return vec2(d,2.);\n}\n\nvec2 face (vec3 p)\n{\n    p += vec3(0.5,-1.65,0.75);\n    vec3 pp = p;\n    p.x = abs(p.x)-0.15;\n    float d = length(p)-0.05;\n    \n    p = pp;\n    p.y += 0.3;\n    d = min(d, length(p*vec3(1.3,1.,1.))-0.1);\n    return vec2(d,3.);\n}\n\nvec2 mat_min (vec2 a, vec2 b)\n{\n    if (a.x<b.x) return a;\n    else return b;\n}\n\nvec2 SDF (vec3 p)\n{\n    p.xz *= rot(sin(iTime*0.5)*0.1);\n    p.yz *= rot(sin(iTime)*0.05);\n    \n    return mat_min(face(p),mat_min(fantome(p),panneau(p)));\n}\n\nvec3 getnorm(vec3 p)\n{\n    vec2 eps = vec2(0.0001,0.);\n    return normalize(SDF(p).x-vec3(SDF(p-eps.xyy).x,SDF(p-eps.yxy).x,SDF(p-eps.yyx).x));\n}\n\nfloat spec (vec3 n, vec3 l, vec3 rd)\n{\n    vec3 h = normalize(l-rd);\n    return pow(max(dot(n,h),0.),30.);\n}\n\nvec3 background (vec2 uv)\n{\n    uv.x = fract(uv.x*5.)-0.5;\n    float mask = smoothstep(0.15,0.25,abs(uv.x));\n    return mix(vec3(0.1,0.2,0.1),vec3(0.,0.8,0.2),mask);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(0.,0.2,-3.),\n        rd= normalize(vec3(uv,1.)),\n        p = ro,\n        l = normalize(vec3(0.,2.,-5.)),\n        col = background(uv);\n    \n    float shad; \n    vec2 d = vec2(0.);\n    bool hit = false;\n    \n   \tfor (float i=0.; i<64.;i++)\n    {\n    \td = SDF(p);\n        if (d.x<0.001)\n        {\n            hit = true;\n            shad = i/64.;\n            break;\n        }\n        p += d.x*rd;\n    }\n    \n    if(hit)\n    {\n        vec3 n =getnorm(p);\n        float light = max(dot(n,l),0.);\n        if (d.y == 1.)\n        {\n            col = mix(vec3(0.1,0.,0.),vec3(0.8,0.,0.),light);\n        \tcol += spec(n,l,rd);\n        }\n        if (d.y == 2.)\n        {\n            col = mix(vec3(0.1),vec3(1.),light);\n        }\n        if (d.y == 3.)\n        {\n            col = vec3(0.);\n        }      \n    }\n   \n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsBfWw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsBfzd", "name": "Psychedelic Spaceships", "author": "jarble", "description": "Another edit of my [url=https://www.shadertoy.com/view/wdBBzd]\"Space Debris\"[/url] shader.", "tags": ["raymarching"], "likes": 2, "viewed": 217, "date": "1590609917", "time_retrieved": "2024-06-20T20:09:05.971380", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n/**\n * Part 6 Challenges:\n * - Make a scene of your own! Try to use the rotation transforms, the CSG primitives,\n *   and the geometric primitives. Remember you can use vector subtraction for translation,\n *   and component-wise vector multiplication for scaling.\n */\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.00001;\n\nvec3 hash33(vec3 p3)\n{\t\n    //this is from https://www.shadertoy.com/view/4djSRW\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += (p3, p3.yxz+3.1+sin(p3.x+p3.y+p3.z)/60.0);\n    return fract((p3.xxy*sin(p3.x*10.0) + p3.yxx*cos(p3.x*10.0))*p3.zyx);\n\n}\n\n\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(hash33(sin(p)/10.0))-sin(length(p))/15.0;\n}\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {    \n    //Slowly spin the whole scene\n    samplePoint = samplePoint-vec3(0.0,0.0,iTime)*5.0;\n    \n    return sphereSDF(samplePoint,1.0);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(8.0, 5.0, 7.0);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = hash33(p/10.0);\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsBfzd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsBfzm", "name": "RM study", "author": "ibragim_aghdabi", "description": "work and progress", "tags": ["raymarching"], "likes": 0, "viewed": 27, "date": "1589689834", "time_retrieved": "2024-06-20T20:09:05.977655", "image_code": "\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nfloat GetDist(vec3 p) {\n\tvec4 s = vec4(0, 1, 6, 1);\n    \n    float sphereDist =  length(p-s.xyz)-s.w;\n    float planeDist = p.y;\n    \n    float d = min(sphereDist, planeDist);\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    \n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p){\n    float d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d-vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p){\n    vec3 lightPos = vec3(0, 5, 6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n,l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2.,l);\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3 (0);\n    vec3 ro = vec3(0, 1, 0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd *  d;\n    \n    float dif = GetLight(p);\n    col = vec3(dif);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsBfzm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsByzK", "name": "Raymarching plane height map", "author": "ciphered", "description": "A great shader if you are used to manipulate 2d textures and want to add depth to your renders.\nhttps://instagram.com/ciphrd", "tags": ["raymarchingheightmapplanedepth"], "likes": 10, "viewed": 477, "date": "1589122849", "time_retrieved": "2024-06-20T20:09:07.056494", "image_code": "// @author ciphered <https://ciphrd.com>\n// @license MIT\n//\n// -----------\n//\n// This shader was made to be working with a vertical plane, parallel to the view screen,\n// passing by (0;0;0). This constraint allows for great optimizations, because this shader \n// is intended to be working along texture manipulations to play with the surface.\n//\n// 2 parallel planes are defined in the space, in front of the camera, with a gap between\n// them corresponding to the DEPTH parameter. For each ray casted from the camera, we first\n// find the intersection between the ray and the first plane. From there, we start marching\n// along the ray and sample the height map at each step to find if whether we're in the\n// volume or not. Once we reach a point within the volume, we can find the point that belongs\n// to the surface and light it accordingly by computing the height map gradient.\n//\n// This is basically a fancy 3d texture renderer\n//\n// If you change the input texture, adjust the DEPTH accordingly\n//\n// Keep in mind that the textures do not represent to height of the elements within, only\n// the default one works correctly for this example\n//\n//\n// LIMITATIONS\n//\n// I coudln't find a way to get soft shadows, if you do feel free to make me know in the comments\n// This version does not provide a COLOR MAP, however it's pretty easy to color the surface using a\n// color map, just copy the getHeightMapValue function to sample from a color map instead of a depthmap\n//\n\n#define PI 3.14159265359\n#define MAX_ITERATIONS 200\n\n// needs to be adujested to match the input texture\n#define DEPTH 0.6\n\n// the step size for the ray marching\n#define PRECISION 0.006\n\n// the lower this is, the more precise the normals get (too much precision results in the\n// apparition of normal artifacts\n#define EPSILON 0.002\n\n\n\n// returns the intersection point between the ray and the hightest point on the plane\nvec3 boundsSDF (vec3 ro, vec3 rd, float h) {\n    // the z length of the target vector\n    float dz = ro.z - h;\n    float t = dz / rd.z;\n    return vec3(\n    \tro.x - rd.x * t,\n        ro.y - rd.y * t,\n        ro.z - rd.z * t\n    );\n}\n\n// returns the height map value of any point in space\n// this is done by projecting the point on the vertical plane\nfloat getHeightMapValue (vec3 p) {\n    // yes this is a projection\n    vec2 tuv = p.xy;\n    tuv.x+= iTime * .1;\n    tuv = fract(tuv - .5);\n    \n    vec3 hm = texture(iChannel0, tuv).rgb;\n    \n    return .9 * (hm.r+hm.g+hm.b)/3. + 0.1;\n}\n\nvec3 calcNormal (vec3 p) {\n\tfloat hx1 = getHeightMapValue(vec3(p.x - EPSILON, p.y, 0.0)) * DEPTH;   \n    float hx2 = getHeightMapValue(vec3(p.x + EPSILON, p.y, 0.0)) * DEPTH;\n    vec3 pu = normalize(vec3(2.0 * EPSILON, 0.0, hx2 - hx1));\n    \n    float hy1 = getHeightMapValue(vec3(p.x, p.y, 0.0)) * DEPTH;\n    float hy2 = getHeightMapValue(vec3(p.x, p.y + EPSILON, 0.0)) * DEPTH;\n    vec3 pv = normalize(vec3(0.0, EPSILON, hy2 - hy1));\n    \n    return cross(pu, pv);\n}\n\nvec3 calcLight( in vec3 pos , in vec3 lightp, in vec3 lightc, in vec3 camdir, float spec)\n{    \n\tvec3 normal = calcNormal(pos);\n    vec3 lightdir = normalize(pos - lightp);\n    float cosa = pow(0.5+0.5*dot(normal, -lightdir), 3.0);\n    float cosr = max(dot(-camdir, reflect(lightdir, normal)), 0.0);\n    \n    vec3 ambiant = vec3(0.1);\n    vec3 diffuse = vec3(0.5 * cosa);\n    vec3 phong = vec3(0.1 * pow(cosr, spec)) * .4;\n    \n    return lightc * (ambiant + diffuse + phong);\n}\n\nvec4 raymarching (vec3 p, vec3 dir) {\n    vec3 prev = p;\n    vec3 curr = p;\n    float lastD = p.z;\n    float hmap = 0.;\n    float df = 0.;\n    \n    for (int i = 0; i < MAX_ITERATIONS; i++) {\n    \tprev = curr;\n        curr = prev + dir * PRECISION;\n        \n        if (curr.z < 0.0) {\n        \treturn vec4(0, 0, 1, 0);    \n        }\n        \n        hmap = getHeightMapValue(curr);\n        // distance to the displaced surface\n        float df = curr.z - hmap * DEPTH;\n        \n        // if we have an intersection\n        if (df < 0.0) {\n        \t// linear interpolation to find more precise df\n            float t = lastD / (abs(df)+lastD);\n            vec3 pi = prev + t * (curr - prev);\n            float h = getHeightMapValue(pi);\n            return vec4(pi, h);\n        } else {\n         \tlastD = df;\n        }\n    }\n    \n    return vec4(0, 0, 1, 0);\n}\n\n// computes a sharp shadow for a given point p of the surface\nfloat shadow (vec3 p, vec3 lpos) {\n    vec3 dir = normalize(lpos - p);\n    vec3 curr = p;\n    float hmap;\n    \n    for (int i = 0; i < MAX_ITERATIONS; i++) {\n    \tcurr+= dir * PRECISION;\n        \n        if (curr.z < 0.0) {\n            return 0.0;\n        }\n        \n        hmap = getHeightMapValue(curr);\n        \n        // distance to the displaced surface\n        float df = curr.z - hmap * DEPTH;\n        \n        if (df < 0.0) {\n            return 1.0;\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - .5;\n    uv.x*= iResolution.x/iResolution.y;\n    \n    float camZ = 1.2;// + cos(iTime*.1) * .1;\n    \n    vec3 ro = vec3(0.0, 0.0, camZ);\n    vec3 cw = normalize(vec3(0.0, 0.0, 0.0) - ro);\n    vec3 cu = normalize(cross(cw, vec3(0.0, 1.0, 0.0)));\n    vec3 cv = normalize(cross(cu, cw));\n    vec3 rd = mat3(cu, cv, cw) * normalize(vec3(uv, 1.0));\n    \n    vec4 col = vec4(0, 0, 0, 1);\n    \n    // the intersection to the highest plane\n    vec3 inter = boundsSDF(ro, rd, DEPTH);\n    \n    // the raymarching\n    vec4 rm = raymarching(inter.xyz, rd);\n    \n    if (rm.w > 999.0) {\n        fragColor = vec4(0);\n        return;\n    }\n    \n    vec3 normal = calcNormal(rm.xyz);\n    \n    vec3 lpos = vec3(cos(iTime)*20., sin(iTime)*20., 7.0);\n    //vec3 lpos = vec3(4.0, 4.0, 2.0);\n    \n    col.rgb = calcLight(rm.xyz , lpos, vec3(1.0, 1.0, 1.0), rd, 0.5);\n    \n    // we get the shadow\n    float shad = shadow(rm.xyz, lpos);\n    col.rgb*= 0.5 + .5 * (1. - shad);\n    \n    //col.rgb = normal;\n   \n    fragColor = vec4(col.rgb, 1.0);\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/WsByzK.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsfBDB", "name": "Blurring Over SDF Surface", "author": "blackle", "description": "using the fancy PDE solving technique to blur across the surface of an SDF, could be useful to simulate subsurface scattering...\n\nVERY slow with ANGLE on chrome for some reason, sorry!", "tags": ["sdf"], "likes": 3, "viewed": 429, "date": "1588970111", "time_retrieved": "2024-06-20T20:09:07.923260", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n#define NO_UNROLL(k) (k+min(0,iFrame))\nconst float blur_strength = 0.1;\n\n#define FK(k) floatBitsToInt(cos(k))^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a);int y = FK(b);\n    return float((x*x-y)*(y*y+x)-x)/2.14e9;\n}\n\nfloat super(vec3 p) {\n    return sqrt(length(p*p));\n}\n\nfloat box(vec3 p, vec3 d) {\n    vec3 q = abs(p)-d;\n    return super(max(vec3(0), q)) + min(0., max(q.x, max(q.y, q.z)));\n}\n\nfloat linedist(vec3 p, vec3 a, vec3 b) {\n    float k = dot(p-a,b-a)/dot(b-a,b-a);\n    return distance(p, mix(a,b,clamp(k,0.,1.)));\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax,p)*ax, p, cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = max(0., k-abs(b-a))/k;\n    return min(a,b)-h*h*h*k/6.;\n}\n\nfloat domino(vec3 p, mat3 topholes, mat3 bottomholes) {\n    float body = box(p, vec3(0.0,0.4,0.9))-0.2;\n    float holes = linedist(p, vec3(.2,0.45,0), vec3(0.2,-0.45,0))-0.04; //divider\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            vec2 holepos = vec2(float(i-1), float(j-1))*0.3;\n            if (topholes[i][j] == 1.) {\n                holes = min(holes, length(p-vec3(.2,holepos+vec2(0.,0.55)))-0.08);\n            }\n            if (bottomholes[i][j] == 1.) {\n                holes = min(holes, length(p-vec3(.2,holepos+vec2(0.,-0.55)))-0.08);\n            }\n        }\n    }\n    return -smin(-body, holes, 0.05);\n}\n\nfloat scene(vec3 p) {\n    float table = box(p-vec3(0,0,-1.2), vec3(3,3,0.05))-0.05;\n    float d1 = domino(erot(p-vec3(-1,0,0),vec3(0,0,1),3.1415-0.05), mat3(1,1,1,0,0,0,1,1,1), mat3(1,0,1,0,1,0,1,0,1));\n    float d2 = domino(erot(p-vec3(1,0,0),vec3(0,0,1),3.1415+0.1), mat3(1,0,1,0,0,0,1,0,1), mat3(0,0,1,0,0,0,1,0,0));\n    float dominos = min(d1,d2);\n    return min(dominos,table);\n}\n\n// suggested from tdhooper. Thanks!\n// improve compilation time & overall fps.\nconst int NORMAL_STEPS = 6;\nvec3 norm(vec3 pos) {\n    vec3 eps = vec3(.01, 0, 0);\n    vec3 nor = vec3(0);\n    float invert = 1.;\n    for (int i = 0; i < NORMAL_STEPS; i++) {\n        nor += scene(pos + eps * invert) * eps * invert;\n        eps = eps.zxy;\n        invert *= -1.;\n    }\n    return normalize(nor);\n}\n\nvec3 srgb(float r, float g, float b) {\n    return vec3(r*r,g*g,b*b);\n}\n\nvec3 srgb(float k) {\n    return vec3(k*k);\n}\n\nvec3 trilinear_texture(vec3 p, vec3 n) {\n    return mix(mix(texture(iChannel0,p.xz), texture(iChannel0,p.yz), n.x*n.x), texture(iChannel0,p.xy), n.z*n.z).xyz;\n}\n\nvec3 shade(vec3 p, vec3 cam) {\n\tvec3 n = norm(p);\n    vec3 r = reflect(cam, n);\n    float ao = smoothstep(-1.,1.,scene(p+n*0.1)/.1);\n    float specao = smoothstep(0.,1.,scene(p+r*0.3)/.3)*0.5;\n\n    vec3 tex = trilinear_texture(p*.2,n);\n    float specmix = smoothstep(0.4,0.6,tex.y);\n    float specex = mix(50.,20.,specmix);\n\n    float diff = ao*length(sin(n*2.5)*0.5+0.5)/sqrt(3.)*0.9+0.1;\n    float spec = length(sin(r*2.5)*0.5+0.5)/sqrt(3.);\n    return tex*diff + pow(spec, specex)*specao;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n    float blur_level = pow(0.5-cos(iTime)*0.5,2.);\n    if (fragCoord.y < 10.) {\n        float grad = sin(fragCoord.y/10.*3.14);\n        float bright = pow(clamp(sin(fragCoord.y/15.*3.14),0.,1.),20.);\n        float barpos = smoothstep(-1., 1., blur_level*iResolution.x - fragCoord.x);\n        fragColor.xyz = grad*mix(vec3(.1), vec3(.9,0.1,0), barpos) + bright*0.3;\n        return;\n    }\n\n    vec3 cam = normalize(vec3(2.,uv));\n    vec3 init = vec3(-10,0,0);\n\n   \tfloat yrot = 0.6;\n    float zrot = 0.9;\n    if (iMouse.z > 0.) {\n        yrot += -4.*mouse.y;\n        zrot += 4.*mouse.x;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    init = erot(init, vec3(0,0,1), zrot);\n\n    vec3 p = init;\n    bool hit = false;\n    for (int i = 0; i < 500 && !hit; i++) {\n        float dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p+=dist*cam;\n        if (distance(p, init) > 100.) break;\n    }\n\n    vec4 col = vec4(0);\n    vec3 n = norm(p);\n    float maxdist = max(scene(p+n*blur_strength),0.);\n    float seed = hash(hash(uv.x,uv.y), float(iFrame));\n    for (int i = 0; i < NO_UNROLL(10); i++) {\n        float blurfactor = mix(0.0,maxdist,blur_level);\n        vec3 p2 = p + n*blurfactor;\n        for (int v = 0; v < NO_UNROLL(5); v++) {\n            float h1 = hash(seed, hash(float(i),float(v)));\n            float h2 = hash(h1,h1);\n            float h3 = hash(h2,h2);\n            vec3 dir = normalize(tan(vec3(h1,h2,h3))-n);\n            float dist = scene(p2);\n            p2 += dir*dist;\n        }\n        col += vec4(shade(p2,cam), 1.);\n    }\n    fragColor.xyz = hit ? col.xyz/col.w : vec3(0.);\n    fragColor.xyz = sqrt(fragColor.xyz);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc0-1.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsfBDB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsfBDj", "name": "Princess Ida", "author": "adelwu", "description": "Spring 2020\nInspired by Monument Valley \nAmbient Occlusion, Global Illumination, Penumbra, and SDF 'algebra'", "tags": ["game", "monumentvalley", "graphics"], "likes": 10, "viewed": 149, "date": "1589169292", "time_retrieved": "2024-06-20T20:09:10.238469", "image_code": "const int RAY_STEPS = 256;\nconst float HALF_PI = 3.14159 * 0.5;\n\nconst vec3 shortBoxPos = vec3(7.0, -2.0, 0.0);\nconst vec3 shortBoxPos2 = vec3(7.0, 2.9, 0.0);\nconst vec3 coneBody = vec3(7.0, -25.8, 1.0);\nconst vec3 coneHat = vec3(5.4, -28.9, -3.7);\nconst vec3 headSphere = vec3(7.0, -26.0, 1.0);\nconst vec3 scarfSphere = vec3(6.8, -26.0, 0.8);\nconst vec3 leftLeg = vec3(6.4, -18.8, 0.8);\nconst vec3 rightLeg = vec3(7.6, -18.8, -0.5);\n\nconst vec3 M1 = vec3(33.0, -20.0, 14.0);\nconst vec3 M2 = vec3(30.0, -20.0, 15.0);\nconst vec3 M3 = vec3(26.0, -20.0, 15.0);\n\nconst vec3 N1 = vec3(33.0, -20.0, -12.0);\nconst vec3 N2 = vec3(30.0, -20.0, -13.0);\nconst vec3 N3 = vec3(27.0, -20.0, -14.0);\n\nconst vec3 L1 = vec3(0.0, -9.8, 14.0);\nconst vec3 L2 = vec3(2.0, 2.8, -14.0);\n\nconst vec3 S0 = vec3(12., -13., 4.5);\nconst vec3 S4 = vec3(14., -10., 6.5);\nconst vec3 S5 = vec3(16., -7., 8.5);\nconst vec3 S6 = vec3(18., -4., 10.5);\n\nconst vec3 LIGHT_POS = vec3(0.0, 30.0, 0.0);\n\nconst vec3 s1Pos = vec3(-14.0, -22.0, -21.0);\nconst vec3 s2Pos = vec3(-12.0, -24.0, -19.0);\n\n// The higher the value, the smaller the penumbra\nconst float SHADOW_HARDNESS = 7.0;\n\n// 0 for penumbra shadows, 1 for hard shadows\n#define HARD_SHADOW 0\n#define R 0.015\n#define M_PI 3.1415926535897932384626433832795\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nstruct Intersection\n{\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n};\n\nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\nvec3 rotateX(vec3 p, float amt) {\n    return vec3(p.x, cos(amt) * p.y - sin(amt) * p.z, sin(amt) * p.y + cos(amt) * p.z);\n}\n\nvec3 rotateZ(vec3 p, float amt) {\n    return vec3(cos(amt) * p.x - sin(amt) * p.y, cos(amt) * p.y + sin(amt) * p.x, p.z);\n}\n\nvoid raycast(vec2 uv, out vec3 dir, out vec3 eye, out vec3 ref) {\n    eye = rotateY(vec3(0.0, 5.0, 15.0), 3.14159 * 1.5);\n    ref = vec3(0.0, 0.0, 0.0);\n    \n    float len = tan(3.14159 * 0.125) * distance(eye, ref);\n    vec3 H = normalize(cross(vec3(0.0, 1.0, 0.0), ref - eye));\n    vec3 V = normalize(cross(H, eye - ref));\n    V *= len;\n    H *= len * iResolution.x / iResolution.y;\n    vec3 p = ref + uv.x * H + uv.y * V;\n    dir = normalize(p - eye);\n}\n// random2 function by Patricio Gonzalez\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// Value Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/lsf3WH\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nvec3 waterFunc(vec3 color, vec2 uv, float detail, float power,\n              float colorMul, float glowRate, bool animate, float noiseAmount)\n{\n    vec3 rockColor = vec3(abs(sin(iTime * .75)) * .03, 0.12, 0.02);\n    float minDistance = 1.;\n    uv *= detail;\n    \n    vec2 cell = floor(uv);\n    vec2 frac = fract(uv);\n    \n    for (int i = -1; i <= 1; i++) {\n        for (int j = -1; j <= 1; j++) {\n        \tvec2 cellDir = vec2(float(i), float(j));\n            vec2 randPoint = random2(cell + cellDir);\n            randPoint += noise(uv) * noiseAmount;\n            randPoint = animate ? 0.5 + 0.5 * sin(iTime * .35 + 6.2831 * randPoint) : randPoint;\n            minDistance = min(minDistance, length(cellDir + randPoint - frac));\n        }\n    }\n    \t\n    float powAdd = sin(uv.x * 2. + iTime * glowRate) + sin(uv.y * 2. + iTime * glowRate);\n\tvec3 outColor = vec3(color * pow(minDistance, power + powAdd * .95) * colorMul);\n    outColor.rgb = mix(rockColor, outColor.rgb, minDistance);\n    return outColor;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdCone( vec3 p, vec2 c, float h )\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\n\n// Box with side lengths b\nfloat box(vec3 p, vec3 b)\n{\n  return length(max(abs(p) - b, 0.0));\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sceneMap3D(vec3 pos, vec3 lightPos)\n{\n    // platform box\n    float b0 = box(rotateY(pos + shortBoxPos, 0.7), vec3(6.0, 15.0, 6.0));\n    float b7 = box(rotateY(pos + shortBoxPos2, 0.7), vec3(4.0, 20.0, 4.0));\n\n    // body cone\n    float b1 = sdCone(rotateX(rotateY(pos + coneBody, -0.5),0.3), vec2(sin(145.), cos(145.)), 6.);\n    // party hat\n    float b2 = sdCone(rotateX(rotateY(pos + coneHat, -0.3), -1.0), vec2(sin(0.33), cos(0.33)), 5.);\n    // head\n    float b3 = sdSphere(pos + headSphere, 1.5);\n    float b4 = sdSphere(pos + scarfSphere, 1.6);\n    \n    // legs\n    float b5 = box(pos + leftLeg, vec3(0.3, 2.0, 0.3));\n    float b6 = box(pos + rightLeg, vec3(0.3, 2.0, 0.3));\n    \n    //mountains\n    float m1 = box(rotateY(rotateZ(pos + M1, 1.5),0.70), vec3(10.0, 0.0, 5.0));\n    float m2 = box(rotateY(rotateZ(pos + M2, 1.5),0.50), vec3(5.0, 0.0, 5.0));\n\tfloat m3 = box(rotateY(rotateZ(pos + M3, 1.5),0.50), vec3(5.0, 0.0, 5.0));\n    float n1 = box(rotateY(rotateZ(pos + N1, 1.5),-0.70), vec3(10.0, 0.0, 5.0));\n    float n2 = box(rotateY(rotateZ(pos + N2, 1.5),-0.50), vec3(5.0, 0.0, 5.0));\n\tfloat n3 = box(rotateY(rotateZ(pos + N3, 1.5),-0.50), vec3(5.0, 0.0, 5.0));   \n    \n    // floor\n    float t2 = box(pos + vec3(0.0, 5.0, 0.0), vec3(45.0, 0.0, 45.0));\n     \n    // moon\n    float s1 = sdSphere(pos + s1Pos + vec3(0., sin(iTime), 0.), 5.0);\n    float s2 = sdSphere(pos + s2Pos + vec3(0., sin(iTime), 0.), 4.8);\n    float s3 = opSubtraction(s2, s1);\n    \n    //lilypads\n    float l0 = sdCappedCylinder(pos + L1 + vec3(0., sin(iTime), 0.), 2.3, 0.1);\n    float l1 = sdCappedCylinder(pos + L2 + vec3(0., sin(iTime),0.), 2.7, 0.1);\n    \n    //stairs\n    float s0 = box(rotateY(pos + S0, -0.9), vec3(6., 1.5, 1.5));\n    float s4 = box(rotateY(pos + S4, -0.9), vec3(6., 1.5, 1.5));\n    float s5 = box(rotateY(pos + S5, -0.9), vec3(6., 1.5, 1.5));\n    float s6 = box(rotateY(pos + S6, -0.9), vec3(6., 1.5, 1.5));\n    \n    float min = min(s3, min(t2, min(b1, min(b0, \n                min(b2, min(b3, min(b4, min(b5, \n                min(b6, min(m1, min(m2, min(m3, \n                min(n1, min(n2, min(n3, min(b7, \n                min(l0, min(l1, min(s0, min(s4, \n                min(s5, s6)))))))))))))))))))));\n    \n    return min;\n}\n\nvoid sceneMap3D(vec3 pos, out float t, out int obj, vec3 lightPos)\n{   \n    // platform\n    float b0 = box(rotateY(pos + shortBoxPos, 0.7), vec3(6.0, 15.0, 6.0));\n    float b7 = box(rotateY(pos + shortBoxPos2, 0.7), vec3(4.0, 20.0, 4.0));\n    \n    // body cone\n    float b1 = sdCone(rotateX(rotateY(pos + coneBody,-0.5),0.3), vec2(sin(145.), cos(145.)), 6.);\n    // party hat\n    float b2 = sdCone(rotateX(rotateY(pos + coneHat, -0.3), -1.0), vec2(sin(0.33), cos(0.33)), 5.);\n    // head\n    float b3 = sdSphere(pos + headSphere, 1.5);\n    float b4 = sdSphere(pos + scarfSphere, 1.6);\n    // legs\n    float b5 = box(pos + leftLeg, vec3(0.3, 2.0, 0.3));\n    float b6 = box(pos + rightLeg, vec3(0.3, 2.0, 0.3));\n    \n    // floor    \n    float t2 = box(pos + vec3(0.0, 5.0, 0.0), vec3(45.0, 0.0, 45.0));\n    \n    //mountains\n    float m1 = box(rotateY(rotateZ(pos + M1, 1.5),0.70), vec3(10.0, 0.0, 5.0));\n    float m2 = box(rotateY(rotateZ(pos + M2, 1.5),0.50), vec3(5.0, 0.0, 5.0));\n\tfloat m3 = box(rotateY(rotateZ(pos + M3, 1.5),0.50), vec3(5.0, 0.0, 5.0));\n    float n1 = box(rotateY(rotateZ(pos + N1, 1.5),-0.70), vec3(10.0, 0.0, 5.0));\n    float n2 = box(rotateY(rotateZ(pos + N2, 1.5),-0.50), vec3(5.0, 0.0, 5.0));\n\tfloat n3 = box(rotateY(rotateZ(pos + N3, 1.5),-0.50), vec3(5.0, 0.0, 5.0));\n    \n    // moon \n    float s1 = sdSphere(pos + s1Pos + vec3(0., sin(iTime), 0.), 5.0);\n    float s2 = sdSphere(pos + s2Pos + vec3(0., sin(iTime), 0.), 4.8);\n    float s3 = opSubtraction(s2, s1);\n    \n    //lilypads\n    float l0 = sdCappedCylinder(pos + L1 + vec3(0., sin(iTime),0.), 2.3, .1);\n    float l1 = sdCappedCylinder(pos + L2 + vec3(0., sin(iTime),0.), 2.7, 0.1); \n    \n    //stairs\n    float s0 = box(rotateY(pos + S0, -0.9), vec3(6., 1.5, 1.5));\n    float s4 = box(rotateY(pos + S4, -0.9), vec3(6., 1.5, 1.5));\n    float s5 = box(rotateY(pos + S5, -0.9), vec3(6., 1.5, 1.5));\n    float s6 = box(rotateY(pos + S6, -0.9), vec3(6., 1.5, 1.5));\n    \n    obj = 0; \n\tfloat min = min(s3, min(t2, min(b1, min(b0, \n               \tmin(b2, min(b3, min(b4, min(b5,\n                min(b6, min(m1, min(m2, min(m3, \n                min(n1, min(n2, min(n3, min(b7, \n                min(l0, min(l1, min(s0, min(s4, \n                min(s5, s6)))))))))))))))))))));    \n    t = min;\n    if (min == t2) {obj = 3;}\n    else if (min == b0 || min == s0 || min == s4\n            || min == s5 || min == s6) {obj = 0;}\n    else if (min == b4) {obj = 1;}\n    else if (min == m1 || min == n1) {obj = 4;}\n    else if (min == m2 || min == n2) {obj = 6;}\n    else if (min == m3 || min == n3) {obj = 5;}\n    else if (min == b7) {obj = 7;}\n    else if (min == l0 || min == l1) {obj = 8;}\n    else {obj = 2;}\n   \t\n}\nfloat ambientOcclusion(vec3 p, vec3 nor, float k) \n{\n    float sum = 0.0;\n    for (float i = 0.0; i < 5.0; i++) \n    {\n        sum += 1.0 / pow(2.0, i) * (i * 0.15 - sceneMap3D(p + nor * i * 0.15, LIGHT_POS));\n    }\n\n    return 1.0 - k * sum;\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj)\n{\n    t = 0.001;\n    for(int i = 0; i < RAY_STEPS; ++i)\n    {\n        vec3 pos = origin + t * dir;\n    \tfloat m;\n        sceneMap3D(pos, m, hitObj, LIGHT_POS);\n        if(m < 0.01)\n        {\n            return;\n        }\n        t += m;\n    }\n    t = -1.0;\n    hitObj = -1;\n}\n\nvec3 computeNormal(vec3 pos, vec3 lightPos) {\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( sceneMap3D(pos + epsilon.yxx, lightPos) - sceneMap3D(pos - epsilon.yxx, lightPos),\n                            sceneMap3D(pos + epsilon.xyx, lightPos) - sceneMap3D(pos - epsilon.xyx, lightPos),\n                            sceneMap3D(pos + epsilon.xxy, lightPos) - sceneMap3D(pos - epsilon.xxy, lightPos)));\n}\n\nvec3 computeMaterial(int hitObj, vec3 p, vec3 n, vec2 uv) {\n    float t;\n    switch(hitObj) {\n        case 0:\n        // platform\n        return vec3(249., 136., 104.)/255.;\n        break;\n        \n        case 1:\n        // blue mountains\n        return vec3(0., 84., 105.)/255.;\n        break;\n        \n        case 2:\n        // white\n        return vec3(1.0, 1.0, 1.0);\n        break;\n        \n        case 3:\n        // Floor\n        vec3 color = vec3(0.0);\n        color += waterFunc(vec3(0, 85., 106.)/255., uv, 3.,  2.5, 1.15, 1.5, false, 1.5);\n        color += waterFunc(vec3(24., 181., 177.)/255., uv, 6., 3., .4, 1., true, 0.);\n        color += waterFunc(vec3(6., 126., 135.)/255., uv, 8., 4., .2, 1.9, true, 4.5);\n        return color;\n        \n        case 4:\n        // mountains front\n        return vec3(0., 104., 106.)/255.;\n        break;\n        \n        case 5:\n        // mountains back\n        float y = smoothstep(0.1,0.9, sin(iTime) * 0.3);\n        return mix(vec3(85., 196., 179.)/255., vec3(24., 220., 189.)/255., y);\n        //return vec3(24., 220., 189.)/255.;\n        break;\n        \n        case 6:\n        // mountains middle\n        return vec3(2., 143., 131.)/255.;\n        break;\n        \n        case 7:\n        // platform accent\n        return vec3(243., 116., 114.)/255.;\n        break;\n        \n        case 8:\n        // lilypads\n        return vec3(125., 178., 53.)/255.;\n        break;\n        \n        case -1:\n        // Background\n        return vec3(0.0);\n        break;\n    }\n    return vec3(1.0);\n}\n\nfloat hardShadow(vec3 dir, vec3 origin, float min_t) {\n    float t = min_t;\n    for(int i = 0; i < RAY_STEPS; ++i) {\n        float m = sceneMap3D(origin + t * dir, LIGHT_POS);\n        if(m < 0.0001) {\n            return 0.0;\n        }\n        t += m;\n    }\n    return 1.0;\n}\n\nfloat softShadow(vec3 dir, vec3 origin, float min_t, float k) {\n    float res = 1.0;\n    float t = min_t;\n    for(int i = 0; i < RAY_STEPS; ++i) {\n        float m = sceneMap3D(origin + t * dir, LIGHT_POS);\n        if(m < 0.0001) {\n            return 0.0;\n        }\n        res = min(res, k * m / t);\n        t += m;\n    }\n    return res;\n}\n\nfloat shadow(vec3 dir, vec3 origin, float min_t) {\n    #if HARD_SHADOW\n    return hardShadow(dir, origin, min_t);\n    #else\n    return softShadow(dir, origin, min_t, SHADOW_HARDNESS);\n    #endif\n}\n\nIntersection sdf3D(vec3 dir, vec3 eye, vec2 uv)\n{\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj);\n\n    vec3 isect = eye + t * dir;\n    vec3 nor = computeNormal(isect, LIGHT_POS);\n    \n    vec3 material = computeMaterial(hitObj, isect, nor, uv);\n    \n    vec3 warmDir = rotateY(normalize(vec3(0.5, 0.75, 1.0)), sin(iTime * 0.5));\n    vec3 coolDir = rotateY(normalize(vec3(-1.0, 0.0, -1.0)), sin(iTime * 0.5));\n\n    float warmDot = max(0.0, dot(nor, warmDir));\n    float coolDot = max(0.0, dot(nor, coolDir));\n\n    vec3 overallColor = warmDot * vec3(1.0, 0.88, 0.7) * shadow(warmDir, isect, 0.1);\n    overallColor += coolDot * vec3(0.05, 0.15, 0.4);\n    overallColor *= material;\n    overallColor = clamp(overallColor + vec3(0.05, 0.1, 0.15), 0.0, 1.0);\n    if (overallColor.x < 0.1 && overallColor.x > 0.045) {overallColor += vec3(0.07, 0.0, 0.07);}\n    \n    vec3 sdfColor = overallColor + vec3(0.03);\n    \n    return Intersection(t, sdfColor, isect, hitObj);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // [-1, 1]\n    vec2 uv2 = 2.0 * uv - vec2(1.0);\n    \n    Intersection aaIsects[4];\n    vec3 dir, eye, ref;\n    int idx = 0;\n    for(float i = 0.0; i < 1.0; i += 0.5) {\n        for(float j = 0.0; j < 1.0; j += 0.5) {\n            raycast(uv2 + vec2(i, j) / iResolution.xy, dir, eye, ref);\n            aaIsects[idx++] = sdf3D(dir, eye + vec3(-30.0, 25.0, 0.0), uv);\n        }\n    }\n    vec3 avgColor = vec3(0.0);\n    for(int i = 0; i < 4; ++i) {\n        avgColor += aaIsects[i].color;\n    }\n    \n    float ao = ambientOcclusion(aaIsects[0].p, computeNormal(aaIsects[0].p, LIGHT_POS), 2.0);\n    \n    avgColor *= 0.45;\n    avgColor *= ao;\n    fragColor = vec4(avgColor * step(0.0, aaIsects[0].t), 1.0);\n    float fogT = smoothstep(30.0, 50.0, distance(aaIsects[0].p, eye));\n    fragColor.rgb = mix(fragColor.rgb, vec3(0.0), fogT);\n    \n    if (fragColor.rgb == vec3(0.0)) {\t\n\t\n\t\tvec3 color = vec3(85., 196., 179.)/255.;\n\t\tif (rand(fragCoord.xy / iResolution.xy) > 0.996)\n\t\t{\n\t\t\tfloat r = rand(fragCoord.xy);\n            //fragColor.rgb = mix(color, vec3(1.0), sin(iTime) * r);\n            fragColor.rgb = vec3(1.0);\n        } \n        else \n        {\n            vec2 st = fragCoord/iResolution.xy;\n\n            // Smooth interpolation between 0.1 and 0.9\n            float y = smoothstep(0.5,0.9,st.y);\n\n            fragColor.rgb = mix(vec3(85., 196., 179.)/255., vec3(224., 135., 126.)/255., y);\n        }\n    } else {\n    \n    fragColor.rgb = mix(fragColor.rgb, vec3(85., 196., 179.)/255., fogT);\n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsfBDj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsfBDS", "name": "projective spherical raymarching", "author": "sasha_sortai", "description": "similar to https://www.shadertoy.com/view/WsfBzs but on a different representation of the sphere", "tags": ["2d", "sdf", "spherical"], "likes": 3, "viewed": 60, "date": "1588931652", "time_retrieved": "2024-06-20T20:09:10.238469", "image_code": "\nvec3 onsph(vec2);\nvec2 onpln(vec3);\nfloat dist(vec3, vec3);\nfloat dist(vec2, vec2);\nfloat DE(vec2);\n\nconst float PI = (asin(1.)*2.);\n\n#define NITER 100\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord - .5*iResolution.xy);\n    float mult = 15./min(iResolution.x, iResolution.y);\n    p *= mult;\n    //vec4 mouse = (texture(iChannel0, vec2(0.))-vec4(.5*iResolution.xy,.5*iResolution.xy))*mult;\n    vec3 col = vec3(DE(p));\n    \n    //if (min(distance(p,mouse.xy),distance(p,mouse.zw))<.02) col = mix(vec3(.1),vec3(0,1,0)*.7,col);\n    \n    //vec3 cam = onsph(mouse.zw); vec3 tar = onsph(mouse.xy);\n    vec2 camp = vec2(-1,1)*cos(iTime/6.6);\n    vec3 cam = onsph(camp); vec3 tar = onsph(camp+.01*vec2(cos(iTime*.2),sin(iTime*.2)));\n    vec3 cen = normalize(cross(cam, tar)); vec3 ort = normalize(cross(cen, cam));\n    float l = 0.;\n    for (int i = 0; i<NITER; i++)\n    {\n        float d = DE(onpln(cos(l)*cam+sin(l)*ort));\n        if (d<.001 || l>2.*PI) break;\n        if (abs(dist(p,onpln(cos(l)*cam+sin(l)*ort))-d)<.02) col = mix(vec3(.1),vec3(1,0,1)*.7,col);\n        l += d;\n    }\n    \n    //if (length(p)>PI) col *= 0.;\n    //col = vec3(sin(distance(mouse.zw,p)));\n    \n    // Output to screen\n    fragColor = vec4(col,1.);\n}\n\nvec3 onsph(vec2 xy)\n{\n    vec3 res;\n    float l = length(xy);\n    res.xy = xy*sin(2.*atan(l))/l;\n    res.z = cos(2.*atan(l));\n    return res;\n}\n\nvec2 onpln(vec3 xyz)\n{\n    xyz = normalize(xyz)+vec3(0,0,1);\n    return xyz.xy/xyz.z;\n}\n\nfloat dist(vec3 a, vec3 b)\n{\n    return acos(dot(normalize(a),normalize(b)));\n}\nfloat dist(vec2 a, vec2 b)\n{\n    return dist(onsph(a), onsph(b));\n}\n\nfloat DE(vec2 p)\n{\n    //return .1*PI;\n    \n    return min(dist(p,vec2(1)),dist(p,vec2(-1)))-PI/4.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsfBDS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsfBzs", "name": "spherical space sdf", "author": "sasha_sortai", "description": "raymarching on a sphere, unwrapped onto a disk\nthe fun part of this is that you don't have to worry about a ray going to infinity without hitting anything, because it's trivial to check if you've looped back on  yourself", "tags": ["sdf", "spherical"], "likes": 1, "viewed": 60, "date": "1588842382", "time_retrieved": "2024-06-20T20:09:10.244536", "image_code": "\nvec3 onsph(vec2);\nvec2 onpln(vec3);\nfloat dist(vec3, vec3);\nfloat dist(vec2, vec2);\nfloat DE(vec2);\n\nconst float PI = (asin(1.)*2.);\n\n#define NITER 100\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord - .5*iResolution.xy);\n    float mult = 2.*PI/min(iResolution.x, iResolution.y);\n    p *= mult;\n    //vec4 mouse = (texture(iChannel0, vec2(0.))-vec4(.5*iResolution.xy,.5*iResolution.xy))*mult;\n    vec3 col = vec3(DE(p));\n    \n    //if (min(distance(p,mouse.xy),distance(p,mouse.zw))<.02) col = mix(vec3(.1),vec3(0,1,0)*.7,col);\n    \n    //vec3 cam = onsph(mouse.zw); vec3 tar = onsph(mouse.xy);\n    vec2 camp = vec2(-1,1)*cos(iTime/6.6);\n    vec3 cam = onsph(camp); vec3 tar = onsph(camp+.01*vec2(cos(iTime*.2),sin(iTime*.2)));\n    vec3 cen = normalize(cross(cam, tar)); vec3 ort = normalize(cross(cen, cam));\n    float l = 0.;\n    for (int i = 0; i<NITER; i++)\n    {\n        float d = DE(onpln(cos(l)*cam+sin(l)*ort));\n        if (d<.001 || l>2.*PI) break;\n        if (abs(dist(p,onpln(cos(l)*cam+sin(l)*ort))-d)<.01) col = mix(vec3(.1),vec3(1,0,1)*.7,col);\n        l += d;\n    }\n    \n    if (length(p)>PI) col *= 0.;\n    //col = vec3(sin(distance(mouse.zw,p)));\n    \n    // Output to screen\n    fragColor = vec4(col,1.);\n}\n\nvec3 onsph(vec2 xy)\n{\n    vec3 res;\n    float l = length(xy);\n    res.xy = xy*sin(l)/l;\n    res.z = cos(l);\n    return res;\n}\n\nvec2 onpln(vec3 xyz)\n{\n    xyz = normalize(xyz);\n    float l = acos(xyz.z);\n    return normalize(xyz.xy)*l;\n}\n\nfloat dist(vec3 a, vec3 b)\n{\n    return acos(dot(normalize(a),normalize(b)));\n}\nfloat dist(vec2 a, vec2 b)\n{\n    return dist(onsph(a), onsph(b));\n}\n\nfloat DE(vec2 p)\n{\n    //return .1*PI;\n    return min(dist(p,vec2(1)),dist(p,vec2(-1)))-PI/4.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsfBzs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsffRf", "name": "lattice R", "author": "haptix", "description": "lattice R", "tags": ["latticer"], "likes": 8, "viewed": 345, "date": "1588740300", "time_retrieved": "2024-06-20T20:09:10.244536", "image_code": "vec2 smoothU(vec2 a, vec2 b, float r)\n{\n\tvec2 u = max(vec2(r - a.x, r - b.x), vec2(0.));\n\treturn vec2(max(r, min (a.x, b.x)) - length(u), (a.y+b.y) / 2.);\n}\n\nvec3 rep(vec3 pos, float sp)\n{\n\treturn mod(pos, sp) - .5*sp;\n}\n\nvec2 cylX(vec3 p, vec3 c, float matId)\n{\n\tfloat sdf = length(p.yx - c.zx) - c.x;\n    return vec2(sdf, matId);\n}\n\nvec2 cylY(vec3 p, vec3 c, float matId)\n{\n\tfloat sdf = length(p.xz - c.xy) - c.z;\n    return vec2(sdf, matId);\n}\n\nvec2 cylZ(vec3 p, vec3 c, float matId)\n{\n\tfloat sdf = length(p.yz - c.yx) - c.y;\n    return vec2(sdf, matId);\n}\n\nmat2 rot(float rad)\n{\n    return mat2(cos(rad), sin(rad), -sin(rad), cos(rad));\n}\n\nvec3 kif(vec3 p)\n{    \n    float t = iTime*.05 + 42.;\n    \n    for(int i = 0; i < 6; i++)\n    {\n        p.xy *= rot(.021*t);\n        \n        p = abs(p) + vec3(.02*cos(t*.21) + .31,\n                          .03*sin(t*.27) + 8.35,\n                          .04*sin(t*.37) + 120.37);\n        \n        p.yz *= rot(.013*t);\n    }\n    \n    return p;\n}\n\nvec2 crs(vec3 p, vec3 c, float matId)\n{\n    vec2 cylx = cylX(p, c, matId);\n    vec2 cyly = cylY(p, c, matId + 1.);\n    vec2 cylz = cylZ(p, c, matId + 2.);\n \n    float soft = .015;\n    vec2 sdf = smoothU(cylx, cyly, soft);\n    return smoothU(sdf, cylz, soft);\n}\n\nvec2 map(vec3 p)\n{   \n    p = 250. * sin(p/dot(p,p));\n    p = kif(p);\n    \n    float t = -iTime*.2 - 42.;\n    p = rep(p + t, 1.3);\n    \n    vec2 m = crs(p, vec3(.05), 1.);\n    return m;\n}\n\nvec2 tr(vec3 ro, vec3 rd)\n{\n    float far = 50.;\n\tvec2 h,t= vec2(.75);\n\tfor(int i = 0; i < 256; i++)\n\t{\n\t\th = map(ro + rd*t.x);\n\t\tif(h.x < .01 || t.x > far)\n\t\t\tbreak;\n\t\tt.x += h.x;\n        t.y = h.y;\n  \t}\n    if(t.x > far)\n        t.y = 0.;\n\treturn t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec3 ro = vec3(3.*sin(iTime*.25), -5.*cos(iTime*.25), 32.);\n    \n\tvec3 camTarget = vec3(0.);\n\tvec3 up = vec3(0., 1., 0.);\n\tvec3 camDir = normalize(camTarget - ro);\n\tvec3 camRight = normalize(cross(up, ro));\n\tvec3 camUp = normalize(cross(camDir, camRight));\n    vec3 lightPos1 = ro;\n    vec3 lightPos2 = ro + 10.;\n  \n\tvec2 screenPos = -1. + 2. * gl_FragCoord.xy / iResolution.xy;\n\tscreenPos.x *= iResolution.x / iResolution.y;\n\n\tvec3 rd = normalize(camRight*screenPos.x + camUp*screenPos.y + camDir);\n  \n\tvec2 t = tr(ro, rd);\n\n    if (t.y > 0.)\n    {\n        vec3 hit = ro + rd*t.x;\n        vec3 lightDir = normalize(lightPos1 - hit);\n\n        vec2 eps = vec2(0., .05);\n        vec3 norm = normalize(map(hit).x - vec3(map(hit - eps.yxx).x,\n                              \t\t\t\t\tmap(hit - eps.xyx).x,\n                              \t\t\t\t\tmap(hit - eps.xxy).x));\n        \n        float diff = max(0., dot(lightDir, norm));\n        float spec = pow(max(dot(rd, reflect(norm, lightDir)), 0.), 45.);\n\n        vec3 col = vec3(0.);\n        col += .2 * diff;\n        col += vec3(1.) * spec;\n        \n        fragColor = vec4(col, 1.);\n    }\n    else\n    {\n        vec3 wh = vec3(1.);\n        fragColor = vec4(.85); \n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsffRf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsffRS", "name": "Artifact at Sea", "author": "samlo", "description": "Wrote this piece on and off over the past two weeks to get back into raymarching :) Water inspired by the sum of sines method in Very fast procedural ocean by afl_ex. It has some continuity bugs, but I'm quite pleased with the result ð\n", "tags": ["raymarch", "sdf", "water", "ocean", "glow", "night"], "likes": 68, "viewed": 1278, "date": "1588441792", "time_retrieved": "2024-06-20T20:09:11.669014", "image_code": "#define time iTime\n\nconst float CAM_FAR = 20.0;\nconst vec3 BACKGROUND = vec3(0.1, 0.1, 0.13);\nconst int WATER_MARCH_ITERATIONS = 12;\nconst int WATER_NORMAL_ITERATIONS = 39;\nconst float PI = 3.14159265359;\n\nconst int NUM_PARTICLES = 20;\nvec4 ppos[NUM_PARTICLES];\n\n// calculated per fragment\nvec3 artifactOffset;\nmat3 artifactRotation;\nvec3 artifactAxis;\nfloat flicker;\nvec3 camFwd;\nvec3 camUp;\n\nfloat rand(float n) {\n    return fract(sin(n) * 43758.5453123);\n}\nfloat hash(float n) { return fract(sin(n) * 1e4); }\nfloat noise(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(hash(i), hash(i + 1.0), u);\n}\nmat4 viewMatrix (vec3 dir, vec3 up) { \n    vec3 f = normalize(dir);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4( s,   0.0),\n        vec4( u,   0.0),\n        vec4(-f,   0.0),\n        vec4( 0.0, 0.0, 0.0, 1)\n    );\n}\nmat3 rotationAlign(vec3 d, vec3 z) {\n    vec3  v = cross(z, d);\n    float c = dot(z, d);\n    float k = 1.0/(1.0+c);\n    return mat3(v.x*v.x*k + c,     v.y*v.x*k - v.z,    v.z*v.x*k + v.y,\n                v.x*v.y*k + v.z,   v.y*v.y*k + c,      v.z*v.y*k - v.x,\n                v.x*v.z*k - v.y,   v.y*v.z*k + v.x,    v.z*v.z*k + c    );\n}\nfloat intersectPlane(vec3 origin, vec3 direction, vec3 point, vec3 normal) { \n    return clamp(dot(point - origin, normal) / dot(direction, normal), -1.0, 9991999.0); \n}\nvec3 calcRay(vec2 uv, float fov, float aspect) {\n    uv = uv * 2.0 - 1.0;\n    float d = 1.0 / tan(radians(fov) * 0.5);\n    return normalize(vec3(aspect * uv.x, uv.y, d));\n}\nvec2 getWave(vec2 position, vec2 dir, float speed, float frequency, float timeshift) {\n    float x = dot(dir, position) * frequency + timeshift * speed;\n    float wave = exp(sin(x) - 1.0);\n    float dist = wave * cos(x);\n    return vec2(wave, -dist);\n}\nfloat heightmap(vec2 worldPos, int iterations) {\n    const float scale = 0.13;\n    vec2 p = worldPos * scale;\n    vec2 p2 = (artifactOffset.xz - vec2(0.0, 1.0)) * scale;\n    float d = clamp(length(p2 - p) / 0.8, 0.0, 1.0);\n    d = (1.0 - smoothstep(0.0, 1.0, d)) * 0.8;\n    float angle     = 0.0;\n    float freq      = 5.0;\n    float speed     = 2.0;\n    float weight    = 1.9;\n    float wave      = 0.0;\n    float waveScale = 0.0;\n    vec2 dir;\n    vec2 res;\n    for (int i = 0; i < iterations; i++) {\n        dir = vec2(cos(angle), sin(angle));\n        res = getWave(p, dir, speed, freq, time);\n        p += dir * res.y * weight * 0.05;\n        wave += res.x * weight - d;\n        angle += 12.0;\n        waveScale += weight;\n        weight = mix(weight, 0.0, 0.2);\n        freq *= 1.18;\n        speed *= 1.06;\n    }\n    return wave / waveScale;\n}\nvec3 waterNormal(vec2 p, float eps) {\n    vec2 h = vec2(eps, 0.0);\n    #define i WATER_NORMAL_ITERATIONS\n    return normalize(vec3(heightmap(p - h.xy, i) - heightmap(p + h.xy, i),\n                          2.0 * eps,\n                          heightmap(p - h.yx, i) - heightmap(p + h.yx, i)));\n}\nfloat octahedron(vec3 p, float s) {\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\nvoid artifact(vec3 p, inout float curDist, inout vec3 glowColor, inout int id) {\n    p -= artifactOffset;\n    p = artifactRotation * p;\n    float dist = octahedron(p, 1.2);\n    const float glowDist = 4.8;\n    if (dist < glowDist) {\n        float d = dist + rand(dist) * 1.7;\n        glowColor += vec3(0.75, 0.55, 0.45) * clamp(1.0 - pow((d / glowDist), 5.0), 0.0, 1.0) * 0.035 * flicker; // glow\n    }\n    if (dist < curDist) {\n        curDist = dist;\n        id = 1;\n    }\n}\nvoid particles(vec3 p, inout float curDist, inout vec3 glowColor, inout int id) {\n    float t;\n    float angle;\n    float radius;\n    float dist = CAM_FAR;\n    const float glowDist = 0.2;\n    for (int i = 0; i < NUM_PARTICLES; i++) {\n        dist = length(p - ppos[i].xyz) - 0.005;\n        if (dist < glowDist && false) {\n            float d = dist + rand(dist) * 0.5;\n            glowColor += clamp(1.0 - d / glowDist, 0.0, 1.0) * 0.005;\n        }\n        if (dist < curDist) {\n            curDist = dist;\n            id = 2;\n        }\n    }\n}\nfloat objects(vec3 p, inout vec3 glowColor, inout int objId) {\n    float dist = CAM_FAR;\n    artifact(p, dist, glowColor, objId);\n    particles(p, dist, glowColor, objId);\n    return dist;\n}\nfloat artifactDist(vec3 p) {\n    p -= artifactOffset;\n    p = artifactRotation * p;\n    return octahedron(p, 1.2);\n}\nfloat objectsDist(vec3 p) {\n    return artifactDist(p);\n}\nvec3 objectsNormal(vec3 p, float eps) {\n    vec2 h = vec2(eps, 0);\n    #define f artifactDist\n    return normalize(vec3(f(p + h.xyy) - f(p - h.xyy),\n                          f(p + h.yxy) - f(p - h.yxy),\n                          f(p + h.yyx) - f(p - h.yyx)));\n}\nvec3 objectsColor(int id, vec3 normal, vec3 ray) {\n    if (id == 1) { // artifact\n        float l = dot(normal, normalize(vec3(0.0, 1.0, 0.5)));\n        float hl = mix(0.8, 1.5, l * 0.5 + 0.5);\n        return vec3(0.85, 0.65, 0.55) * hl * flicker;\n    }\n    if (id == 2) {\n        return vec3(0.85, 0.65, 0.55) * 1.5;\n    }\n    return vec3(1.0, 1.0, 0.0); // shouldn't happen\n}\nvoid marchObjects(vec3 eye, vec3 ray, float wDepth, inout vec4 color) {\n    float dist = 0.0;\n    int id;\n    vec3 rayPos = eye + ray * dist;\n    vec3 c;\n    float depth = CAM_FAR;\n    vec3 glowColor = vec3(0.0);\n    for (int i = 0; i < 100; i++) {\n        dist = objects(rayPos, color.rgb, id);\n        depth = distance(rayPos, eye);\n        if (depth > wDepth) {\n            break;\n        }\n        if (dist < 0.01) {\n            vec3 normal = objectsNormal(rayPos, 0.01);\n            color = vec4(objectsColor(id, normal, ray), depth);\n            return;\n        }\n        rayPos += ray * dist;\n    }\n}\nvec3 waterColor(vec3 ray, vec3 normal, vec3 p) {\n    vec3 color = vec3(0.0);\n    float fogDist = length(p - vec3(0.0, 0.0, -6.));\n    float dist = 0.0;\n    int objId = 0;\n    vec3 refl = reflect(ray, normal);\n    vec3 rayPos = p + refl * dist;\n    vec3 dir = normalize(artifactOffset - p);\n    if (length(p.xz - artifactOffset.xz) < 8.5 && dot(refl, dir) > -0.25) { // hacky but this way we aren't reflecting on every single fragment\n        for (int i = 0; i < 40; i++) {\n            dist = objects(rayPos, color, objId);\n            if (dist < 0.01) {\n                vec3 objNormal = objectsNormal(rayPos, 0.001);\n                color = objectsColor(objId, objNormal, rayPos);\n                break;\n            }\n            rayPos += refl * dist;    \n        }\n    }\n    float fresnel = (0.04 + 0.9 * (pow(1.0 - max(0.0, dot(-normal, ray)), 7.0)));\n    vec3 lightOffset = artifactOffset - p;\n    float d = length(lightOffset);\n    const float r = 14.0;\n    float atten = clamp(1.0 - (d*d) / (r*r), 0.0, 1.0);\n    atten *= atten;\n    vec3 point = vec3(0.75, 0.55, 0.45) * atten * (1.0 + fresnel) * 0.07;\n    vec3 ambient = vec3(dot(normal, normalize(vec3(0.0, 1.0, 0.5)))) * max(fresnel, 0.06) * vec3(0.1, 0.5, 1.0) * 0.85;\n    float fog = smoothstep(25.0, 6.0, fogDist) / (fogDist * 0.1);\n   \n    return color + (point + ambient) * fog;\n}\nvoid marchWater(vec3 eye, vec3 ray, inout vec4 color) {\n    const vec3 planeNorm = vec3(0.0, 1.0, 0.0);\n    const float depth = 3.0;\n    float ceilDist = intersectPlane(eye, ray, vec3(0.0, 0.0, 0.0), planeNorm);\n    vec3 normal = vec3(0.0);\n    if (dot(planeNorm, ray) > -0.05) {\n        normal = vec3(0.0);\n        color = vec4(vec3(0.0), CAM_FAR);\n        return;\n    }\n    float height = 0.0;\n    vec3 rayPos = eye + ray * ceilDist;\n    for (int i = 0; i < 80; i++) {\n        height = heightmap(rayPos.xz, WATER_MARCH_ITERATIONS) * depth - depth;\n        if (rayPos.y - height < 0.1) {\n            color.w = distance(rayPos, eye);\n            vec3 normPos = (eye + ray * color.w);\n            normal = waterNormal(normPos.xz, 0.005);\n            color.rgb = waterColor(ray, normal, normPos);\n            return;\n        }\n        rayPos += ray * (rayPos.y - height);\n    }\n}\nvec3 march(vec2 uv, vec3 camPos) {\n    mat4 vm = viewMatrix(camFwd, camUp);\n    vec3 ray = (vm * vec4(calcRay(uv, 80.0, iResolution.x / iResolution.y), 1.0)).xyz;\n    vec4 color = vec4(BACKGROUND, CAM_FAR);\n    vec3 waterColor;\n    marchWater(camPos, ray, color);\n    marchObjects(camPos, ray, color.w, color);\n    return color.rgb;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // simulate  particles\n    float pR;\n    float pA;\n    float gen;\n    float t;\n    float loop;\n    float height;\n    vec4 p;\n    const float emitR = 1.7;\n    for (int i = 0; i < NUM_PARTICLES; i++) {\n        t = time * 0.035 + float(i) * 0.07;\n        gen = floor(t);\n        loop = fract(t);\n        pR = rand(gen + float(i)) * emitR;\n        pA = rand(float(i)) * PI * 2.0;\n        p.xz = vec2(cos(pA), sin(pA)) * pR + vec2(0.0, -5.2);\n        height = mix(3.0, 2.3, (abs(pR) / emitR));\n        p.y = mix(-3.5, height, sqrt(loop));\n        //p.w = cos(loop * PI * 2.0) * min(1.0, 1.0 - (loop / 0.9)); // not currently used :(\n        ppos[i] = p;\n    }\n    \n    // artifact animation\n    t = time;\n    float s = sin(t);\n    float c = cos(t);\n    artifactRotation = mat3x3(c,0,s,\n                              0,1,0,\n                             -s,0,c);\n    artifactRotation *= rotationAlign(vec3(0.0, 1.0, 0.0), vec3(sin(t) * 0.2, 1.0, cos(t) * 0.2 + 0.3));\n    artifactOffset = vec3(sin(time) * 0.4, cos(time * 0.5) * 0.3 - 1.7, -6.);\n    flicker = mix(1.0, 1.1, sin(time * 2.0) * 0.5 + 0.5) + noise(time * 4.0) * -0.1 + 0.05;\n\n    // camera animation\n    camFwd = vec3(0.0, 0.7 + noise(time * 0.8 + 4.0) * 0.08 - 0.04, 1.0);\n    camUp = vec3(noise(time * 1.2) * 0.02 - 0.01, 1.0, 0.0);\n\n    // scene\n    vec3 color = march(uv, vec3(0.0, 1.9, 1.0));\n\n    // vignette\n    color -= (length(uv - 0.5) - 0.3) * 0.05;\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsffRS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsffWM", "name": "Prairie des vaches", "author": "HyiKing", "description": "Prairie des vaches - the cow meadow", "tags": ["prairievachescowmeadow"], "likes": 0, "viewed": 30, "date": "1588423911", "time_retrieved": "2024-06-20T20:09:12.505439", "image_code": "#define SCALE 15.0\n#define TILESIZE 30.0\n#define PI 3.14159265359\n\n// COLORS\nvec3 yellow = vec3(241./255.,242./255.,208./255.);\nvec3 green = vec3(127./255., 173./255., 110.0/255.);\nvec3 laurel = vec3(146./255., 173./255., 148.0/255.);\nvec3 bg = vec3(226./255., 214./255., 134.0/255.);\nvec3 middlegreen = vec3(88./255.,129./255.,87./255.);\nvec3 huntergreen = vec3(68./255.,100./255.,74./255.);\nvec3 blackolive = vec3(53./255.,56./255.,49./255.);\n\nfloat hash21(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rect(vec2 uv, vec2 bottomLeft, vec2 topRight) {\n    vec2 step1 = step(bottomLeft, uv);\n    vec2 step2 = step(1.0-topRight, 1.0-uv);\n    return step1.x*step1.y*step2.x*step2.y;\n}\n\nvec4 tile1(vec2 uvT) {\n    // Draw First Tile flowers\n    vec3 col = vec3(0.0);\n    float mask = rect(uvT, vec2(2.0, 10.0), vec2(6.0, 14.0));\n    mask += rect(uvT, vec2(10.0, 10.0), vec2(14.0, 14.0));\n    mask += rect(uvT, vec2(6.0, 6.0), vec2(10.0, 10.0));\n    mask += rect(uvT, vec2(6.0, 14.0), vec2(10.0, 16.0));\n\n    mask += rect(uvT, vec2(18.0, 20.0), vec2(22.0, 24.0));\n    mask += rect(uvT, vec2(22.0, 24.0), vec2(26.0, 26.0));\n    mask += rect(uvT, vec2(22.0, 16.0), vec2(26.0, 20.0));\n    mask += rect(uvT, vec2(26.0, 20.0), vec2(30.0, 24.0));\n    col = mix(col, yellow, mask);\n    float mask2 = rect(uvT, vec2(2.0, 8.0), vec2(6.0, 10.0));\n    mask2 += rect(uvT, vec2(6.0, 10.0), vec2(10.0, 14.0));\n    mask2 += rect(uvT, vec2(10.0, 8.0), vec2(14.0, 10.0));\n    mask2 += rect(uvT, vec2(6.0, 4.0), vec2(10.0, 6.0));\n\n    mask2 += rect(uvT, vec2(18.0, 18.0), vec2(22.0, 20.0));\n    mask2 += rect(uvT, vec2(22.0, 20.0), vec2(26.0, 24.0));\n    mask2 += rect(uvT, vec2(26.0, 18.0), vec2(30.0, 20.0));\n    mask2 += rect(uvT, vec2(22.0, 14.0), vec2(26.0, 16.0));\n    col = mix(col, green, mask2);\n    return vec4(col,clamp(mask+mask2, 0.0, 1.0));\n}\n\nvec4 tile2(vec2 uvT) {\n    // Draw Second Tile flowers\n    vec3 col = vec3(0.0);\n    float mask = rect(uvT, vec2(0.0, 22.0), vec2(12.0, 26.0));\n    mask += rect(uvT, vec2(4.0, 18.0), vec2(8.0, 28.0));\n\n    mask += rect(uvT, vec2(16.0, 12.0), vec2(28.0, 16.0));\n    mask += rect(uvT, vec2(20.0, 8.0), vec2(24.0, 18.0));\n    col = mix(col, yellow, mask);\n    float mask2 = rect(uvT, vec2(0.0, 20.0), vec2(4.0, 22.0));\n    mask2 += rect(uvT, vec2(4.0, 22.0), vec2(8.0, 26.0));\n    mask2 += rect(uvT, vec2(4.0, 16.0), vec2(8.0, 18.0));\n    mask2 += rect(uvT, vec2(8.0, 20.0), vec2(12.0, 22.0));\n\n    mask2 += rect(uvT, vec2(16.0, 10.0), vec2(20.0, 12.0));\n    mask2 += rect(uvT, vec2(20.0, 12.0), vec2(24.0, 16.0));\n    mask2 += rect(uvT, vec2(20.0, 6.0), vec2(24.0, 8.0));\n    mask2 += rect(uvT, vec2(24.0, 10.0), vec2(28.0, 12.0));\n    col = mix(col, green, mask2);\n    return vec4(col, clamp(mask+mask2, 0.0, 1.0));\n}\n\nvec4 tile3(vec2 uvT) {\n    // Draw Third Tile flowers\n    vec3 col = vec3(0.0);\n    float mask = rect(uvT, vec2(0.0, 18.0), vec2(12.0, 22.0));\n    mask += rect(uvT, vec2(4.0, 14.0), vec2(8.0, 24.0));\n    mask += rect(uvT, vec2(18.0, 24.0), vec2(30.0, 28.0));\n    mask += rect(uvT, vec2(22.0, 20.0), vec2(26.0, 30.0));\n    mask += rect(uvT, vec2(10.0, 6.0), vec2(22.0, 10.0));\n    mask += rect(uvT, vec2(14.0, 2.0), vec2(18.0, 12.0));\n    col = mix(col, yellow, mask);\n    float mask2 = rect(uvT, vec2(0.0, 16.0), vec2(4.0, 18.0));\n    mask2 += rect(uvT, vec2(4.0, 18.0), vec2(8.0, 22.0));\n    mask2 += rect(uvT, vec2(8.0, 16.0), vec2(12.0, 18.0));\n    mask2 += rect(uvT, vec2(4.0, 12.0), vec2(8.0, 14.0));\n    mask2 += rect(uvT, vec2(18.0, 22.0), vec2(22.0, 24.0));\n    mask2 += rect(uvT, vec2(22.0, 24.0), vec2(26.0, 28.0));\n    mask2 += rect(uvT, vec2(26.0, 22.0), vec2(30.0, 24.0));\n    mask2 += rect(uvT, vec2(22.0, 18.0), vec2(26.0, 20.0));\n    mask2 += rect(uvT, vec2(10.0, 4.0), vec2(14.0, 6.0));\n    mask2 += rect(uvT, vec2(14.0, 6.0), vec2(18.0, 10.0));\n    mask2 += rect(uvT, vec2(18.0, 4.0), vec2(22.0, 6.0));\n    mask2 += rect(uvT, vec2(14.0, 0.0), vec2(18.0, 2.0));\n    col = mix(col, green, mask2);\n    return vec4(col, clamp(mask+mask2, 0.0, 1.0));\n}\n\nfloat weed(vec2 uvT, vec2 pos, float speed) {\n\t// Grass movement\n    // let stop and move again periodically\n    float ct1 = iTime*2.0*speed;\n    float ct2 = iTime*1.0*speed;\n    float stopEveryAngle1 = PI/2.;\n    float stopEveryAngle2 = PI;\n    float stopRatio1 = 0.9;\n    float stopRatio2 = 0.9;\n    float tm1 = (floor(ct1) + smoothstep(0.0, 1.0-stopRatio1, fract(ct1)) )*stopEveryAngle1;\n    float tm2 = (floor(ct2) + smoothstep(0.0, 1.0-stopRatio2, fract(ct2)) )*stopEveryAngle2;\n\n    float x1 = -4.0*cos(tm1);\n    float x2 = -2.0*cos(tm2);\n    float mask = rect(uvT, vec2(pos.x+x1, pos.y+6.0), vec2(pos.x+2.0+x1, pos.y+10.0));\n    mask += rect(uvT, vec2(pos.x+x2, pos.y+3.0), vec2(pos.x+2.0+x2, pos.y+6.0));\n    mask += rect(uvT, vec2(pos.x, pos.y), vec2(pos.x+3.0, pos.y+3.0));\n\treturn mask;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 uvStatic = uv;\n\n    // TIME\n    uv.x += iTime/8.0;\n    uv.y += iTime/32.0;\n    uv *= SCALE;\n    vec2 guv = fract(uv);\n    vec2 id = floor(uv);\n    \n    // Background\n    vec2 uvBack = uv*SCALE/1.0;\n    vec2 guvBack = fract(uvBack);\n    vec2 idB = floor(uvBack);\n    vec2 uvTBack = guvBack*TILESIZE;\n    vec3 col = huntergreen;\n    float noiseGreen = hash21(idB);\n    if (noiseGreen < 0.6) col = middlegreen;\n    else if (noiseGreen < 0.8) col = huntergreen;\n    else if (noiseGreen < 0.9) col = blackolive;\n    \n    float noise = hash21(id);\n    if (noise < 0.5) col.r -= noise*0.1;\n    noise = hash21(id+0.4);\n    if (noise < 0.4) col.b -= noise*0.1;\n    \n    vec2 uvT = guv*TILESIZE;\n    \n    // Flowers\n    vec4 flower;\n    float isTile = hash21(id+0.1);\n    if (isTile < 0.1) {\n        flower = tile3(uvT);\n    \tcol = mix(col, flower.rgb, flower.a);\n    } else if (isTile < 0.22) {\n        flower = tile2(uvT);\n    \tcol = mix(col, flower.rgb, flower.a);\n    } else if (isTile < 0.35) {\n        flower = tile1(uvT);\n    \tcol = mix(col, flower.rgb, flower.a);\n    }\n    \n    // Weed\n    float r1 = hash21(id+0.34);\n    float r2 = hash21(id+0.71);\n    vec2 pos = vec2(4.8+19.0*r1, 18.0*r2);\n    //float speed = 1.5*sin(id.x+iTime*PI/2.)+2.0;\n    float maskWeed = weed(uvT, pos, 1.0);\n    r1 = hash21(id+0.64);\n    r2 = hash21(id+0.55);\n    maskWeed += weed(uvT, vec2(4.8+19.0*r1, 18.0*r2), 1.0);\n   \tmaskWeed = clamp(maskWeed, 0.0, 1.0);\n    col = mix(col, bg, maskWeed);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsffWM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsffWs", "name": "moving dots", "author": "linkwwj", "description": "moving dots", "tags": ["2d"], "likes": 2, "viewed": 46, "date": "1589268284", "time_retrieved": "2024-06-20T20:09:12.505439", "image_code": "\nfloat odd(in float number){\n\n\treturn step(1.0,mod(number,2.0));\n}\n\nvec2 zoomAndMove(in vec2 st,in float scale){\n\n    st *= scale; \n    st.x += max(0.0,odd(st.y)*sin(iTime));\n    st.y += min(0.0, odd(st.x)*sin(iTime));\n\treturn fract(st);\n}\n\n\nfloat circle(in vec2 st, in vec2 origin, in float radius){\n\n\tfloat dist = length(st-origin);\n    return step(radius, dist);\n}\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv =uv*2.0-1.0;\n    uv.x *= iResolution.x/iResolution.y;\n   \t\n    vec2 st = zoomAndMove(uv,4.0);\n  \n    vec3 col = vec3(0.0);\n    col = vec3(circle(st, vec2(0.5), 0.15));\n    \n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsffWs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsGSRG", "name": "Rainbow Tunnel of Fun", "author": "koi", "description": "A fun shader I made a while back", "tags": ["tunnel", "animation", "rainbow"], "likes": 3, "viewed": 242, "date": "1590437094", "time_retrieved": "2024-06-20T20:09:12.505439", "image_code": "#define TAU 6.283185\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    float theta = iTime + fract(iTime/TAU) * TAU/2.0;\n    coord *= mat2(cos(theta), sin(theta), -sin(theta), cos(theta));\n    \n    float a = atan(coord.y, coord.x);\n    \n    float n = exp((-cos(iTime)*0.5+0.5)*3.5)+1.0;\n    \n    float d = length(coord) * cos(mod(a+TAU/n/2.0, TAU/n)-TAU/n/2.0);\n    d = 1.0 / d;\n    float val = step(d, 0.5);\n    \n    fragColor = vec4(hsv2rgb(vec3(round(fract(d-iTime)*6.0)/6.0, 0.8, 1.0))*(fract(fract(d-iTime)*6.0+0.5)*0.2+0.8)/d, 1.0);    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsGSRG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsjBRG", "name": "Fireworm", "author": "Reva", "description": "Ex10", "tags": ["2d", "noise", "particle"], "likes": 12, "viewed": 215, "date": "1590310814", "time_retrieved": "2024-06-20T20:09:12.881231", "image_code": "// Author: Reva 2020-05-23\n// Title: Fireworm\n\nfloat rand( vec2 c )\n{\n\treturn fract( sin( dot( c.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );\n}\n\nvec2 rand2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( rand2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( rand2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( rand2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( rand2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat circle(vec2 pos, float radius, float glow){\n    float sdf = length(pos);\n    sdf = smoothstep(radius-0.700,radius,sdf);\n    float circles = 1.0 - smoothstep(0.0,1.0,sdf*10.280);\n    float glows = exp(-sdf*4.496) * glow * (1.0 - circles);\n    return circles+glows;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 st = (fragCoord - 0.5*iResolution.xy )/iResolution.y;\n    st *= 20.0;\n    vec2 uv = st;\n    float noisest = noise(vec2(uv.x - iTime,uv.y - iTime));\n    uv += noisest*0.13;\n    uv += vec2( noise(vec2(iTime)*0.2)*6.0,-iTime*2.0);\n    \n    vec3 color = vec3(0.);\n    \n    \n    vec2 pos = fract(uv)-0.5;\n    vec2 id = floor(uv);\n\n    \n    for(int y = -1; y <= 1; y++){\n        for(int x = -1; x <= 1; x++){\n            vec2 neighbour = vec2(x,y);\n            vec2 rand2 = rand2(id+neighbour);\n            float a = noise(rand2+iTime*2.8);\n            vec2 offset = 0.5*(sin(iTime + rand2*6.28))*2.2;\n            float size = rand(id+neighbour)*0.75 + a*0.15;\n            color += circle(pos-neighbour+offset,size,size*1.400)/9.0 * vec3(rand2.x*7.884,7.2,rand2.y*6.832);\n        }\n    }\n    \n    float xRange = 1.0 - abs(2.0 * st.x)*0.02;\n    vec3 ambient = smoothstep(1.0,0.0,st.y*0.05+0.9) * vec3(0.401,0.570,0.443);\n    color = max(ambient, color) * xRange;\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsjBRG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsjBRW", "name": "Turbulence noise test", "author": "exandro", "description": "Turbulence noise test for cineshader", "tags": ["test", "cineshader"], "likes": 7, "viewed": 11889, "date": "1589609621", "time_retrieved": "2024-06-20T20:09:13.463005", "image_code": "\n//\tSimplex 3D Noise \n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){ \n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    //  x0 = x0 - 0. + 0.0 * C \n    vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n    vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n    vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n    i = mod(i, 289.0 ); \n    vec4 p = permute( permute( permute( \n                         i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n                     + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n                     + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n    float n_ = 1.0/7.0; // N=7\n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n// Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat fbm( vec3 p ) {\n        float f = 0.0;\n        f += 0.5000*snoise( p ); p = p*2.02;\n        f += 0.2500*snoise( p ); p = p*2.03;\n        f += 0.1250*snoise( p ); p = p*2.01;\n        f += 0.0625*snoise( p );\n        return f/0.9375;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    float mouseRatio = smoothstep(100.0, 0.0, length(iMouse.xy - fragCoord.xy));\n    float noise = 0.25 + fbm(vec3(uv * 12.0 + (iMouse.xy - fragCoord.xy) * mouseRatio * 0.05, iTime * 0.18 + 0.5 * mouseRatio));\n    noise *= 0.25 + snoise(vec3(uv * 4.0 + 1.5, iTime * 0.15));\n    //fragColor = vec4(1.0, 1.0, 1.0, noise);\n    \n    for(float i = 1.0; i < 8.0; i++){\n    uv.y += i * 0.1 / i * \n      sin(uv.x * i * i + iTime * 0.5) * sin(uv.y * i * i + iTime * 0.5);\n  \t}\n    \n   vec3 col;\n   col.r = uv.y + noise - 0.1;\n   col.g = uv.y + noise + 0.3;\n   col.b = uv.y + noise + 0.95;\n    \n    fragColor = vec4(col,noise);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Turbulence noise\",\n\t\"description\": \"probando shadertoy a cineshader\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsjBRW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsjBW1", "name": "Gradient Noise 3D", "author": "im_sky", "description": "Gradient Noise 3d first implementation.", "tags": ["noise3d"], "likes": 4, "viewed": 293, "date": "1590169322", "time_retrieved": "2024-06-20T20:09:14.832948", "image_code": "#define PI 3.14159265359\n\n#define CosineCurve 0\n#define PerlinSmoothCurve 1\n\nconst vec3 dirs[] = vec3[26]\n(\n    vec3(0.57735, 0.57735, -0.57735),                                                                                                                                                                                                                 \n    vec3(0.57735, 0.57735, 0.57735),                                                                                                                                                                                                                  \n    vec3(0.70711, 0.70711, 0),                                                                                                                                                                                                                        \n    vec3(0.70711, 0, -0.70711),                                                                                                                                                                                                                       \n    vec3(0.70711, 0, 0.70711),                                                                                                                                                                                                                        \n    vec3(1, 0, 0),                                                                                                                                                                                                                                    \n    vec3(0.57735, -0.57735, -0.57735),                                                                                                                                                                                                                \n    vec3(0.57735, -0.57735, 0.57735),                                                                                                                                                                                                                 \n    vec3(0.70711, -0.70711, 0),                                                                                                                                                                                                                       \n    vec3(0, 0.70711, -0.70711),                                                                                                                                                                                                                       \n    vec3(0, 0.70711, 0.70711),                                                                                                                                                                                                                        \n    vec3(0, 1, 0),                                                                                                                                                                                                                                    \n    vec3(0, 0, -1),                                                                                                                                                                                                                                   \n    vec3(0, 0, 1),                                                                                                                                                                                                                                    \n    //vec3(0,0,0),                                                                                                                                                                                                                           \n    vec3(0, -0.70711, -0.70711),                                                                                                                                                                                                                      \n    vec3(0, -0.70711, 0.70711),                                                                                                                                                                                                                       \n    vec3(0, -1, 0),                                                                                                                                                                                                                                   \n    vec3(-0.57735, 0.57735, -0.57735),                                                                                                                                                                                                                \n    vec3(-0.57735, 0.57735, 0.57735),                                                                                                                                                                                                                 \n    vec3(-0.70711, 0.70711, 0),                                                                                                                                                                                                                       \n    vec3(-0.70711, 0, -0.70711),                                                                                                                                                                                                                      \n    vec3(-0.70711, 0, 0.70711),                                                                                                                                                                                                                       \n    vec3(-1, 0, 0),                                                                                                                                                                                                                                   \n    vec3(-0.57735, -0.57735, -0.57735),                                                                                                                                                                                                               \n    vec3(-0.57735, -0.57735, 0.57735),                                                                                                                                                                                                                \n    vec3(-0.70711, -0.70711, 0)         \n);\n\nconst int tableSize = 512;\nconst int permutationMask = 512/2 - 1;\nconst int permutationTable[512] = int[]\n(                                                                                                                                                                                                                                          \n    180, 3, 121, 17, 22, 7, 69, 202, 72, 172,                                                                                                                                                                                                         \n    56, 94, 92, 254, 122, 139, 118, 127, 76, 2,                                                                                                                                                                                                       \n    46, 74, 169, 147, 228, 196, 47, 110, 138, 217,                                                                                                                                                                                                    \n    155, 39, 91, 61, 45, 238, 242, 229, 251, 207,                                                                                                                                                                                                     \n    192, 198, 175, 222, 176, 75, 234, 10, 25, 63,                                                                                                                                                                                                     \n    250, 135, 159, 183, 253, 96, 68, 153, 87, 50,                                                                                                                                                                                                     \n    226, 241, 114, 188, 13, 112, 21, 66, 249, 144,                                                                                                                                                                                                    \n    126, 1, 233, 124, 148, 43, 199, 156, 208, 223,                                                                                                                                                                                                    \n    164, 213, 18, 219, 59, 209, 108, 134, 27, 100,                                                                                                                                                                                                    \n    197, 90, 53, 140, 168, 29, 165, 19, 65, 161,                                                                                                                                                                                                      \n    141, 52, 195, 128, 151, 37, 117, 150, 36, 105,                                                                                                                                                                                                    \n    49, 6, 187, 116, 235, 216, 201, 119, 182, 204,                                                                                                                                                                                                    \n    221, 136, 0, 113, 24, 111, 158, 131, 212, 58,                                                                                                                                                                                                     \n    41, 85, 102, 166, 77, 157, 64, 103, 184, 83,                                                                                                                                                                                                      \n    237, 220, 23, 149, 84, 171, 99, 230, 152, 178,                                                                                                                                                                                                    \n    190, 215, 38, 34, 163, 93, 14, 244, 79, 31,                                                                                                                                                                                                       \n    9, 142, 240, 132, 145, 231, 95, 236, 8, 167,                                                                                                                                                                                                      \n    82, 80, 133, 137, 252, 211, 57, 248, 89, 20,                                                                                                                                                                                                      \n    30, 154, 32, 174, 205, 42, 98, 11, 15, 243,                                                                                                                                                                                                       \n    78, 203, 146, 185, 107, 51, 224, 54, 70, 106,                                                                                                                                                                                                     \n    194, 35, 177, 160, 255, 16, 104, 189, 12, 67,                                                                                                                                                                                                     \n    125, 33, 123, 55, 120, 186, 40, 143, 181, 239,                                                                                                                                                                                                    \n    193, 214, 115, 81, 4, 44, 200, 101, 206, 71,                                                                                                                                                                                                      \n    73, 28, 86, 130, 48, 225, 210, 227, 245, 109,                                                                                                                                                                                                     \n    232, 162, 129, 179, 218, 88, 247, 173, 191, 97,                                                                                                                                                                                                   \n    62, 60, 246, 5, 26, 170,\n    180, 3, 121, 17, 22, 7, 69, 202, 72, 172,                                                                                                                                                                                                         \n    56, 94, 92, 254, 122, 139, 118, 127, 76, 2,                                                                                                                                                                                                       \n    46, 74, 169, 147, 228, 196, 47, 110, 138, 217,                                                                                                                                                                                                    \n    155, 39, 91, 61, 45, 238, 242, 229, 251, 207,                                                                                                                                                                                                     \n    192, 198, 175, 222, 176, 75, 234, 10, 25, 63,                                                                                                                                                                                                     \n    250, 135, 159, 183, 253, 96, 68, 153, 87, 50,                                                                                                                                                                                                     \n    226, 241, 114, 188, 13, 112, 21, 66, 249, 144,                                                                                                                                                                                                    \n    126, 1, 233, 124, 148, 43, 199, 156, 208, 223,                                                                                                                                                                                                    \n    164, 213, 18, 219, 59, 209, 108, 134, 27, 100,                                                                                                                                                                                                    \n    197, 90, 53, 140, 168, 29, 165, 19, 65, 161,                                                                                                                                                                                                      \n    141, 52, 195, 128, 151, 37, 117, 150, 36, 105,                                                                                                                                                                                                    \n    49, 6, 187, 116, 235, 216, 201, 119, 182, 204,                                                                                                                                                                                                    \n    221, 136, 0, 113, 24, 111, 158, 131, 212, 58,                                                                                                                                                                                                     \n    41, 85, 102, 166, 77, 157, 64, 103, 184, 83,                                                                                                                                                                                                      \n    237, 220, 23, 149, 84, 171, 99, 230, 152, 178,                                                                                                                                                                                                    \n    190, 215, 38, 34, 163, 93, 14, 244, 79, 31,                                                                                                                                                                                                       \n    9, 142, 240, 132, 145, 231, 95, 236, 8, 167,                                                                                                                                                                                                      \n    82, 80, 133, 137, 252, 211, 57, 248, 89, 20,                                                                                                                                                                                                      \n    30, 154, 32, 174, 205, 42, 98, 11, 15, 243,                                                                                                                                                                                                       \n    78, 203, 146, 185, 107, 51, 224, 54, 70, 106,                                                                                                                                                                                                     \n    194, 35, 177, 160, 255, 16, 104, 189, 12, 67,                                                                                                                                                                                                     \n    125, 33, 123, 55, 120, 186, 40, 143, 181, 239,                                                                                                                                                                                                    \n    193, 214, 115, 81, 4, 44, 200, 101, 206, 71,                                                                                                                                                                                                      \n    73, 28, 86, 130, 48, 225, 210, 227, 245, 109,                                                                                                                                                                                                     \n    232, 162, 129, 179, 218, 88, 247, 173, 191, 97,                                                                                                                                                                                                   \n    62, 60, 246, 5, 26, 170\n);\n\nint Hash(vec3 x)\n{\n    // using ampersand to calculate modulus because-\n    // mod() for negative integers gives \"wrong\" results, for instance mod(-3, 4) = 1 and not 3\n    // the ampersand trick works only if the divisor is a power of two minus 1\n    // less operatons compared to x - y * floor(x/y)\n    return permutationTable[permutationTable[permutationTable[int(x.x) & permutationMask] + int(x.z) & permutationMask] + int(x.y) & permutationMask];\n}\n\nfloat SmoothCurve(float t)\n{\n#if CosineCurve\n    return (1.0 - cos(t * PI)) * 0.5;\n#elif PerlinSmoothCurve\n    return t * t * (3.0 - 2.0 * t);\n#else\n    return t;\n#endif\n}\n\nfloat GetIntegerNoise(vec2 p)  // replace this by something better, p is essentially ivec2\n{\n    p  = 53.7 * fract( (p*0.3183099) + vec2(0.71,0.113));\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nvec3 GetGradient(vec3 x)\n{\n    // using % instead of & operator, below, because the divisor is not a power of two minus 1, and the divisor will never be negative here.\n    int i = Hash(x) % 26;\n    return dirs[i];\n}\n\nfloat Get3DNoise(vec3 uvw)\n{\n    float noise = 0.0;\n    \n    vec3 p = floor(uvw);\n    vec3 f = fract(uvw);\n    \n    vec3 p1 = p + vec3(0.0, 0.0, 0.0);\n    vec3 p2 = p + vec3(1.0, 0.0, 0.0);\n    vec3 p3 = p + vec3(0.0, 1.0, 0.0);\n    vec3 p4 = p + vec3(1.0, 1.0, 0.0);\n    vec3 p5 = p + vec3(0.0, 0.0, 1.0);\n    vec3 p6 = p + vec3(1.0, 0.0, 1.0);\n    vec3 p7 = p + vec3(0.0, 1.0, 1.0);\n    vec3 p8 = p + vec3(1.0, 1.0, 1.0);\n    \n    vec3 g1 = GetGradient(p1);\n    vec3 g2 = GetGradient(p2);\n    vec3 g3 = GetGradient(p3);\n    vec3 g4 = GetGradient(p4);\n    vec3 g5 = GetGradient(p5);\n    vec3 g6 = GetGradient(p6);\n    vec3 g7 = GetGradient(p7);\n    vec3 g8 = GetGradient(p8);\n    \n    float dot1 = dot(g1, uvw - p1);\n    float dot2 = dot(g2, uvw - p2);\n    float dot3 = dot(g3, uvw - p3);\n    float dot4 = dot(g4, uvw - p4);\n    float dot5 = dot(g5, uvw - p5);\n    float dot6 = dot(g6, uvw - p6);\n    float dot7 = dot(g7, uvw - p7);\n    float dot8 = dot(g8, uvw - p8);\n    \n    float wX = SmoothCurve(f.x);\n    float noiseY1 = mix(dot1, dot2, wX);\n    float noiseY2 = mix(dot3, dot4, wX);\n    float noiseY3 = mix(dot5, dot6, wX);\n    float noiseY4 = mix(dot7, dot8, wX);\n    \n    float wY = SmoothCurve(f.y);\n    float noiseZ1 = mix(noiseY1, noiseY2, wY);\n    float noiseZ2 = mix(noiseY3, noiseY4, wY);\n    \n    float wZ = SmoothCurve(f.z);\n    noise = mix(noiseZ1, noiseZ2, wZ);\n    \n    return noise;\n}\n\n//https://www.iquilezles.org/www/articles/fbm/fbm.htm\n// H: Hurst Exponent, affects the integration of noise partially\nfloat fBM(vec3 x, float H, int numOctaves)\n{\n    float total = 0.0;\n    for(int i = 0; i < numOctaves; ++i)\n    {\n        float frequency = pow(2.0, float(i));\n        float amplitude = pow(frequency, -H);\n        total += amplitude * Get3DNoise(x * frequency);\n    }\n\t\n    return total;\n}\n\n// https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/procedural-patterns-noise-part-1/simple-pattern-examples\n// output range -1.0 to 1.0\nfloat fBM(vec3 x, float lacunarity, float gain, int numOctaves)\n{\n    float total = 0.0;\n    float frequency = 1.0;\n    float amplitude = 1.0;\n    for(int i = 0; i < numOctaves; ++i)\n    {\n        total += amplitude * Get3DNoise(x * frequency);\n        frequency *= lacunarity;\n        amplitude *= gain;\n    }\n    \n    return total;\n}\n\nfloat Turbulence(vec3 x, float lacunarity, float gain, int numOctaves)\n{\n    float total = 0.0;\n    float frequency = 1.0;\n    float amplitude = 1.0;\n    for(int i = 0; i < numOctaves; ++i)\n    {\n        total += amplitude * abs(Get3DNoise(x * frequency));\n        frequency *= lacunarity;\n        amplitude *= gain;\n    }\n\t\n    return total;\n}\n\nfloat HighPassFilter(float x, float threshold)\n{\n    x = max(x, threshold);\n    x -= threshold;\n    x /= (1.0 - threshold);\n    return x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    uv *= 2.0;\n    vec3 uvw = vec3(uv, iTime * 0.1);\n\n    \n\t//float noise = fBM(uvw, 2.0, 0.4, 4);\n    //noise = 0.5 * noise + 0.5;\n    \n    float noise = 0.0;\n    {\n        float windowWidth = iResolution.x / 4.0; \n\n        if(fragCoord.x < windowWidth)\t\n        {\n            // pink noise\n            noise = fBM(uvw, 3.0, 1.0/3.0, 7);\n            noise = 0.5 * noise + 0.5;  \n        }\n        else if(fragCoord.x < 2.0 * windowWidth)\t\n        {\n            // brown noise\n            noise = fBM(uvw, 2.0, 0.5, 7);\n            noise = 0.5 * noise + 0.5;  \n        }\n        else if(fragCoord.x < 3.0 * windowWidth)\t\n        {\n            // turbulence\n            noise = Turbulence(uvw, 2.0, 0.5, 7);\n        }\n        else\n        {\n            uvw *= 2.0;\n            uvw.y *= 0.4; \n            // wood grain\n            noise = fBM(uvw, 0.02, 0.35, 2) * 10.0;\n            //noise = (sin((5.0 * noise * 100.0) * 2.0 * PI / 200.0) + 1.0) / 2.0;\n            noise = noise - floor(noise);\n        }\n    }\n    \n    noise = pow(noise, 2.2);\n    fragColor = vec4(noise, noise, noise, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsjBW1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsjBWm", "name": "Jelly Bean manufacture", "author": "dpiponi", "description": "Attempt to recreate a RenderMan example I wrote many years ago. The original used a photon mapping pass to simulate subsurface scattering but I found a hack.\n\nStill buggy. Work in progress.", "tags": ["confectionery"], "likes": 7, "viewed": 309, "date": "1590365385", "time_retrieved": "2024-06-20T20:09:15.990353", "image_code": "float theTime = 0.0;\n\nmat4 translate(vec3 p) {\n    return mat4(1.0,  0.0,  0.0,  -p.x,\n              0.0,  1.0,  0.0,  -p.y,\n              0.0,  0.0,  1.0,  -p.z,\n              0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 scale(vec3 s) {\n    return mat4(s.x,  0.0,  0.0,  0.0,\n              0.0,  s.y,  0.0,  0.0,\n              0.0,  0.0,  s.z,  0.0,\n              0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat4(c,  -s,  0.0,  0.0,\n              s,  c,  0.0,  0.0,\n              0.0,  0.0,  1.0,  0.0,\n              0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat4(c,  0.0, s,  0.0,\n              0.0,  1.0, 0.0, 0.0,\n              -s,  0.0, c,  0.0,\n              0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat4(1.0, 0.0, 0.0, 0.0,\n                0.0, c,  -s,  0.0, \n                0.0, s,  c,  0.0,\n                0.0,  0.0,  0.0,  1.0);\n}\n\nvec2 xy;\n\n// From https://iquilezles.org/www/articles/smin/smin.htm\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h *(1.0 - h);\n}\n\nfloat softmin(float x, float y) {\n    return smin(x, y, 0.55);\n}\n\nfloat hash(ivec3 xyz0) {\n    return -0.5 + fract(dot(vec3(1132.312, -19.121311, -12.2312), vec3(xyz0)));\n}\n\n// Thanks iq!\nvec3 center(ivec3 i)\n{\n    float ph = hash(i);\n    return vec3(i) + 0.5*cos( 0.5*theTime + ph*3.14159 + vec3(0,7,4) );\n}\n\n// From https://github.com/hughsk/glsl-hsv2rgb/blob/master/index.glsl\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 colour(ivec3 i) {\n    float cx = 0.5 + hash(i.zxy);\n    float cy = 1.8;\n    float cz = 0.5 + 0.5 * hash(i + ivec3(12, 111, -3));\n\treturn hsv2rgb(vec3(cx, cy, cz));\n}\n\nfloat cube(vec3 x, float top) {\n    float s = 3.0;\n    return max(x.x - s,\n               max(-s - x.x,\n                   max(x.y - top,\n                       max(-s - x.y,\n                           max(x.z - s, -s - x.z)))));\n}\n\n\n// This is the function we're marching into.\nvec4 f(vec3 x) {\n    \n    float a = cube(x, 2.*cos(0.2 * theTime));\n    ivec3 b = ivec3(floor(x + 0.5));\n   \n    float dist;\n    float weight = 35.0;\n    vec3 col = weight * vec3(0.95, 0.85, 0.8);\n\n\n    // Main cause of GPU time.\n    for (int ix = -2; ix <= 2; ++ix) {\n        for (int iy = -2; iy <= 2; ++iy) {\n            for (int iz = -2; iz <= 2; ++iz) {\n                ivec3 ii = b + ivec3(ix, iy, iz); \n\n                // Hole in middle saves some render time.\n                if (ii.x > -2 && ii.x < 2 && ii.y > -2 &&\n                    ii.y < 2 && ii.z > -2 && ii.z < 2) continue;\n                if (ii.x < -2) continue;\n                if (ii.x > 2) continue;\n                if (ii.y < -2) continue;\n                if (ii.y > 2) continue;\n                if (ii.z < -2) continue;\n                if (ii.z > 2) continue;\n                \n                // Note: maybe cache computed centres?\n                vec3 c = center(ii);\n                vec3 cc = colour(ii);\n\n                float s = length(x - c) - 0.5;\n                \n                dist = max(0.0001, s + 0.4);\n                float w = 1. / (dist * dist * dist * dist);\n                col += w * cc;\n                weight += w;\n                a = softmin(a, s);\n            }\n        }\n    }\n\n    return vec4(col / weight, a);\n}\n\n\n\n// Doesn't compute colour.\nfloat fastf(vec3 x) {\n    return f(x).a;\n}\n\nfloat eps = 0.0001;\n//float lambda = 2.0;\n\nfloat lighting(vec3 x, vec3 n, vec3 d, vec3 l) {\n    // Crudely measures curvature.\n    float t = min(1., exp(1.5 * fastf(x + 0.25 * d)));\n    \n    // Sort of transports light under surface.\n    t += min(1., exp(1.5 * fastf(x - 0.15 * l)));\n    \n    return t;\n}\n\nmat4 view() {\n    return rotateY(0.25 * theTime) * rotateX(0.);\n}\n\n\nfloat phong(vec3 n, vec3 light, vec3 d) {\n    vec3 r = reflect(light, n);\n    float e = dot(r, -d);\n    return e > 0. ? pow(e, 16.0) : 0.;\n}\n\nvec3 march(vec3 p, vec3 d) {\n    float c;\n    c = fastf(p);\n    if (c < 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    vec3 col;\n    vec3 bestcol;\n    float bestc = 100.0;\n    // Other cause of GPU time.\n    for (int i = 0; i < 50; ++i) {\n        float step = max(0.005, c);\n        p = p + step * d;\n        vec4 result = f(p);\n        c = result.a;\n        col = result.xyz;\n        if (c < bestc) {\n            bestc = c;\n            bestcol = col;\n        }\n        if (c < 0.01) break;\n    }\n    if (c < 0.01) {\n        // Arrived!\n\n        // Gradient of sdf\n        float ex, ey, ez;\n        ex = fastf(p + vec3(eps, 0.0, 0.0));\n        ey = fastf(p + vec3(0.0, eps, 0.0));\n        ez = fastf(p + vec3(0.0, 0.0, eps));\n        vec3 n = vec3(ex - c, ey - c, ez - c) / eps;\n        n = normalize(n);\n\n        mat4 m = view();\n        vec3 light = normalize((vec4(1.0, 1.0, -1.0, 1.0) * m).xyz);\n        float l = 0.0;\n        l += 0.5 * (0.1 + 0.65 * max(dot(n, light)/sqrt(3.0), 0.0));\n        l += 1.0 * (0.4 * (phong(n, -light, d)));\n        l += 1.2 * (0.5 * lighting(p, n, d, light));\n\n        return vec3(l) * col;\n    }\n    if (c < 0.5) {\n        // Gross hack to fill holes due to grazing rays.\n        // Probably a better way.\n    \treturn 1.5 * bestcol;\n    } else {\n        return vec3(0.1, 0.1, 0.1);\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    theTime = iTime;\n    \n    vec2 uv = fragCoord.xy-0.5*iResolution.xy;\n    uv = 2.0*uv/iResolution.y;\n    xy = iMouse.xy/iResolution.xy;\n\n    vec3 p = vec3(0.0, 2.0, -8.0);\n    // Initial ray direction\n    vec3 d = normalize(vec3(0.5*uv, 1.0));\n    d = (rotateX(-0.25) * vec4(d, 1.0)).xyz;\n    mat4 m = view();\n    p = (vec4(p, 1.0)*m).xyz;\n    d = (vec4(d, 1.0)*m).xyz;\n    d = normalize(d);\n    vec3 color = march(p, d);\n    fragColor = vec4(color, 1.0);\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsjBWm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsjBz3", "name": "Doodling with Lynn", "author": "Flopine", "description": "This shader was made during an online DJ Set at Outline 2020 by LynnDrumm. You can listen to her awesome Drum&Bass sets here: https://www.twitch.tv/lynndrumm/\nTo tone things down and see the scene a bit better, comment the define CRAZYNESS at line 18", "tags": ["raymarching", "animation", "glow", "outline", "vjing"], "likes": 3, "viewed": 191, "date": "1590519376", "time_retrieved": "2024-06-20T20:09:16.972328", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n#define ITER 64.\n#define time iTime\n#define width 5.\n#define height 2.\n#define PI acos(-1.)\n#define BPM 165./60.\n\n#define CRAZYNESS\n\n// taken from YX here : https://www.shadertoy.com/view/tdlXW4\n// rough shadertoy approximation of the bonzomatic noise texture\nvec4 texNoise(vec2 uv)\n{\n    float f = 0.;\n    f += texture(iChannel0, uv*.125).r*.5;\n    f += texture(iChannel0, uv*.25).r*.25;\n    f += texture(iChannel0, uv*.5).r*.125;\n    f += texture(iChannel0, uv*1.).r*.125;\n    f=pow(f,1.2);\n    return vec4(f*.45+.05);\n}\n\nfloat hash21 (vec2 x)\n{return fract(sin(dot(x,vec2(18.4,16.4)))*1524.4);}\n\nmat2 rot( float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nvoid mo(inout vec2 p, vec2 d)\n{\n    p = abs(p)-d;\n    if(p.y>p.x) p = p.yx;\n}\n\nfloat stmin(float a, float b, float k, float n)\n{\n    float st = k/n;\n    float u = b-k;\n    return min(min(a,b), 0.5*(u+a+abs(mod(u-a+st,2.*st)-st)));\n}\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0.,max(q.x,max(q.y,q.z)))+length(max(q,0.));\n}\n\nfloat cyl (vec3 p, float r, float h)\n{return max(length(p.xy)-r,abs(p.z)-h);}\n\n\nfloat tore (vec3 p, vec2 t)\n{return length(vec2(length(p.xz)-t.x,p.y))-t.y;}\n\nfloat sid,g1=0.;\nfloat spot (vec3 p)\n{\n    float per = 10.;\n    sid = floor(p.z/per);\n    p.z = mod(p.z,per)-per*0.5;\n    p.y = abs(p.y)-height*0.9;\n    p.x = abs(p.x)-width*0.98;\n    p.z = abs(p.z)-1.;\n    float d = length(p)-0.2;\n    g1 += 0.07/(0.07+d*d);\n    return d;\n}\n\nfloat g2=0.;\nfloat pipes (vec3 p)\n{\n    float per = 10.;\n    p.z = mod(p.z,per)-per*0.5;\n    vec3 pp = p;\n    p.x = abs(p.x)-width;\n    float d = tore(p,vec2(2.,0.2));\n\n    p = pp;\n    mo(p.xy, vec2(2.5));\n    p.xz*=rot(PI/2.);\n    d = min(d, tore(p.xzy, vec2(1., 0.2)));\n\n    p = pp;\n    mo(p.xy, vec2(1.5));\n    d = min(d, cyl(p,0.1,1e10));\n\n    g2 += 0.001/(0.001+d*d);\n    return d;\n}\n\nfloat g3 = 0.;\nfloat prim1 (vec3 p)\n{\n    float per = 10.;\n    float id = floor((p.z-per*0.5)/per);\n    p.xy *= (mod(id,2.)==0.) ? rot(p.z*0.1+time) : rot(p.z*0.1-time);\n    p.z = mod(p.z-per*0.5,per)-per*0.5;\n    mo(p.xy, vec2(width*(0.1+exp(-fract(time*BPM))*0.4)));\n    p.xy *= rot(PI/4.);\n    float d = cyl(p.xzy, 0.1, height*2.);\n    g3 += 0.01/(0.01+d*d);\n    return d;\n}\n\nfloat g4 = 0.;\nfloat gem (vec3 p)\n{\n    p.z -= 5.-time*3.;\n    p.xy *= rot(time);\n    mo(p.xz, vec2(0.1));\n    mo(p.xy,vec2(0.2));\n    p.x -= exp(-fract(time*BPM));\n    p.xz *= rot(time);\n\n    float d =  dot(p,normalize(sign(p)))-0.1;\n    d = stmin(d,tore(p,vec2(0.3,0.1)),0.2,5.);\n    g4 += 0.1/(0.1+d*d);\n    return d;\n}\n\nfloat room (vec3 p)\n{\n    float per = 10.;\n    float d = -box(p,vec3(width,height,1e10));\n    vec3 pp = p;\n    p.z = mod(p.z-per*0.5,per)-per*0.5;\n    p.x = abs(p.x)-width*0.98;\n    d = min(d, box(p,vec3(1.,height, 0.5)));\n\n    p = pp;\n    p.x = abs(p.x)-width*0.98;\n    d = stmin(d, box(p,vec3(0.5,0.5,1e10)),0.5,5.);\n\n    p = pp;\n    p.y = abs(p.y)-height*0.98;\n    d = stmin(d, box(p,vec3(0.5,0.5,1e10)),0.5,3.);\n\n    return d;\n}\n\nfloat SDF (vec3 p)\n{\n    p.x+= sin(p.z*0.5)*0.5;\n    float d = min(gem(p),min(prim1(p),stmin(pipes(p),min(room(p), spot(p)),0.2,4.)));\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    float dither = hash21(uv);\n    \n    #ifdef CRAZYNESS\n    uv = mix(abs(uv)-vec2(0.2,0.3), uv, floor(sin(time*(PI/4.)*BPM)+1.));\n    uv = mix(uv*rot(PI/4.),uv*rot(-PI/4.),floor(sin(time*2.*PI*BPM)+1.));\n    #endif\n    \n    vec3 ro = vec3(0.001,0.001,-time*3.),\n        rd = normalize(vec3(uv,1.)),\n        col = vec3(0.),\n        p = ro;\n\n    float shad,d = 0.;\n    for (float i=0.; i<ITER; i++)\n    {\n        d = SDF(p);\n        if (d<0.01)\n        {\n            shad = i/ITER;\n            break;\n        }\n        d *= 0.7+dither*0.05;\n        p += d*rd;\n    }\n    \n    float t = length(ro-p);\n\n    col = vec3(shad);\n    col += (mod(sid,2.) == 0.) ? g1*vec3(0.1,0.6,0.7) : g1*vec3(0.7,0.2,0.75);\n    col += g2*0.5;\n    col += g3*0.5;\n    vec3 gemcol = mix(vec3(0.1,0.6,0.7), vec3(0.7,0.2,0.75), floor(sin(time*PI*BPM)+1.));\n    col += g4*texNoise(p.xy*0.2).r*gemcol;\n    \n    col = mix(col,vec3(0.1),1.-exp(-0.01*t*t));\n\n    fragColor = vec4(clamp(col,0.,1.), 1.);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsjBz3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsjBzR", "name": "Oozing Rainbow", "author": "Poobslag", "description": "A rainbow which oozes and moves across the screen. Will be masked over opaque painted bits in a game to create a rainbow paint look.", "tags": ["perlinnoise", "perlin", "animated", "rainbow", "goop", "ooze"], "likes": 5, "viewed": 337, "date": "1589398873", "time_retrieved": "2024-06-20T20:09:17.329974", "image_code": "vec2 hash22(vec2 p)\n{\n    p = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)));\n  \n    return -1.0 + 2.0 * fract(sin(p)*43758.5453123);\n}\n\n\nfloat perlin_noise(vec2 p)\n{\n\tvec2 pi = floor(p);\n    vec2 pf = p-pi;\n    \n    vec2 w = pf*pf*(3.-2.*pf);\n    \n    float f00 = dot(hash22(pi+vec2(.0,.0)),pf-vec2(.0,.0));\n    float f01 = dot(hash22(pi+vec2(.0,1.)),pf-vec2(.0,1.));\n    float f10 = dot(hash22(pi+vec2(1.0,0.)),pf-vec2(1.0,0.));\n    float f11 = dot(hash22(pi+vec2(1.0,1.)),pf-vec2(1.0,1.));\n    \n    float xm1 = mix(f00,f10,w.x);\n    float xm2 = mix(f01,f11,w.x);\n    \n    return mix(xm1,xm2,w.y);\n}\n\n// Official HSV to RGB conversion \nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv2 = uv + perlin_noise(1.2 * vec2(uv.x + 38.913 + iTime * 0.04, uv.y + 81.975 + iTime * 0.04));\n    uv2 = uv2 + vec2(iTime * 0.01, 0.0);\n\n    // Time varying pixel color\n    float f = perlin_noise(2.0 * uv2);\n\n    // Output to screen\n    f = (f + iTime * .01) * 8.0;\n    f = f - floor(f);\n    float f2 = 0.02;\n    f2 = f2 + 0.08 * smoothstep(0.08, 0.12,f);\n    f2 = f2 + 0.08 * smoothstep(0.21, 0.25, f);\n    f2 = f2 + 0.06 * smoothstep(0.33, 0.37, f);\n    f2 = f2 + 0.23 * smoothstep(0.46, 0.50, f);\n    f2 = f2 + 0.08 * smoothstep(0.58, 0.62, f);\n    f2 = f2 + 0.12 * smoothstep(0.71, 0.75, f);\n    f2 = f2 + 0.12 * smoothstep(0.83, 0.87, f);\n    f2 = f2 + 0.23 * smoothstep(0.96, 1.00, f);\n    vec3 col2 = hsv2rgb(vec3(f2, 1.0, 1.0));\n    \n    fragColor = vec4(col2.rgb, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsjBzR.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsjBzw", "name": "Chase", "author": "nordaj", "description": "just got bored", "tags": ["simple"], "likes": 6, "viewed": 150, "date": "1589756670", "time_retrieved": "2024-06-20T20:09:17.329974", "image_code": "#define PI 3.14159265359\n\nconst float rad = .6;\nconst float bRad = .07;\nconst float speed = 5.;\n\nconst float lRad = 3.;\nconst float lInt = .4;\nconst float lAtten = 5.;\n\nconst vec4 c1 = vec4(27., 231., 255., 255.) / 255.;\nconst vec4 c2 = vec4(227., 108., 201., 255.) / 255.;\nconst vec4 bg = vec4(48., 13., 68., 255.) / 255.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //Ball point and angle\n    float t = iTime * speed;\n    vec2 p = vec2(cos(t), sin(t)) * rad;\n    \n    //Trail\n    float rAngle = dot(normalize(uv), normalize(p)) * 0.5 + 0.5;\n    rAngle *= ceil(cross(vec3(uv, 0.), vec3(p, 0.)).z);\n    \n    float gAngle = dot(normalize(uv), normalize(-p)) * 0.5 + 0.5;\n    gAngle *= ceil(cross(vec3(uv, 0.), vec3(-p, 0.)).z);\n    \n    //Use trail in path\n    float rTRad = mix(0., bRad, rAngle);\n    rAngle *= clamp(ceil(1. - abs(length(uv) - rad) / rTRad), 0., 1.);\n    \n    float gTRad = mix(0., bRad, gAngle);\n    gAngle *= clamp(ceil(1. - abs(length(uv) - rad) / gTRad), 0., 1.);\n    \n    //Ball colors\n    float rb = ceil(bRad - length(uv - p));\n    rb = clamp(rb + rAngle, 0., 1.);\n    \n    float gb = ceil(bRad - length(uv + p));\n    gb = clamp(gb + gAngle, 0., 1.);\n    \n    //Lighting\n    float rDist = clamp(lRad - length(uv - p), 0., lRad) / lRad;\n    rb += pow(rDist, lAtten) * lInt;\n    \n    float gDist = clamp(lRad - length(uv + p), 0., lRad) / lRad;\n    gb += pow(gDist, lAtten) * lInt;\n    \n    //Color output\n    vec4 c = c1 * rb + c2 * gb;\n    c += bg * (1. - c.a);\n    fragColor = c;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsjBzw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsjfRD", "name": "Simple LoDless Volumetric Clouds", "author": "42yeah", "description": "Dissecting iq's clouds - https://www.shadertoy.com/view/XslGRr and here's what I get by far. No fancy lods or textures. There aren't even lighting! But I am kinda satisfied with this, and will post a lighted up one next morning :P", "tags": ["raymarching", "simple", "clouds", "volumetric", "iq", "lodless"], "likes": 15, "viewed": 1006, "date": "1589650755", "time_retrieved": "2024-06-20T20:09:17.954321", "image_code": "// Created by 42yeah - 42yeah/2020\n// Ripped off from inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Simple LoDless Volumetric clouds. It does NOT perform level of detail (LOD) for faster rendering\n\n// A white noise function.\nfloat rand(vec3 p) {\n    return fract(sin(dot(p, vec3(12.345, 67.89, 412.12))) * 42123.45) * 2.0 - 1.0;\n}\n\n// A perlin noise function. Since we are not using textures, we am gonna sample 8 corners of a cube.\nfloat perlin(vec3 p) {\n    vec3 u = floor(p);\n    vec3 v = fract(p);\n    vec3 s = smoothstep(0.0, 1.0, v);\n    \n    float a = rand(u);\n    float b = rand(u + vec3(1.0, 0.0, 0.0));\n    float c = rand(u + vec3(0.0, 1.0, 0.0));\n    float d = rand(u + vec3(1.0, 1.0, 0.0));\n    float e = rand(u + vec3(0.0, 0.0, 1.0));\n    float f = rand(u + vec3(1.0, 0.0, 1.0));\n    float g = rand(u + vec3(0.0, 1.0, 1.0));\n    float h = rand(u + vec3(1.0, 1.0, 1.0));\n    \n    return mix(mix(mix(a, b, s.x), mix(c, d, s.x), s.y),\n               mix(mix(e, f, s.x), mix(g, h, s.x), s.y),\n               s.z);\n}\n\n// The fbm function. iq unrolled the loop, so I am doing it too.\n// If you wonder what fbm is, check this out: https://thebookofshaders.com/13/\nfloat fbm(vec3 p) {\n    vec3 off = vec3(0.0, 0.1, 1.0) * iTime;\n    vec3 q = p - off;\n    \n    // fbm\n    float f = 0.5 * perlin(q); q *= 2.0;\n    f += 0.25 * perlin(q); q *= 2.0;\n    f += 0.125 * perlin(q); q *= 2.0;\n    f += 0.06250 * perlin(q); q *= 2.0;\n    f += 0.03125 * perlin(q);\n    return clamp(f - p.y, 0.0, 1.0);\n}\n\n// volmetric raymarching, which is kinda like the core algorithm.\n// I ripped lighting calculations and other stuffs off, so this is bare bones raymarching\nvec3 volumetricTrace(vec3 ro, vec3 rd) {\n    // at first there's no depth\n    float depth = 0.0;\n    \n    // and the color's black\n    vec4 sumColor = vec4(0.0);\n    \n    // then we begin to march\n    for (int i = 0; i < 100; i++) {\n        vec3 p = ro + depth * rd;\n        \n        // and we get the cloud density at said position\n        float density = fbm(p);\n        // if there is an unignorable amount of density (the cloud is thick enough) then\n        if (density > 1e-3) {\n            // we estimate the color with density (the thicker, the whiter)\n            vec4 color = vec4(mix(vec3(0.0), vec3(1.0), density), density);\n            // and we multiply it by a factor so it makes the clouds softer\n            color.w *= 0.4;\n            color.rgb *= color.w;\n            // sumColor.w will rise steadily, which stands for when the ray hits thick enough cloud,\n            // its color won't change anymore\n            sumColor += color * (1.0 - sumColor.a);\n        }\n        // we march forward\n        depth += max(0.05, 0.02 * depth);\n    }\n    return clamp(sumColor.rgb, 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // standard raymarching routine\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    float aspect = iResolution.x / iResolution.y;\n    uv.x *= aspect;\n\n    vec3 ro = vec3(0.0, 1.0, 5.0);\n    vec3 center = vec3(0.0);\n    \n    vec3 front = normalize(center - ro);\n    vec3 right = normalize(cross(front, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(right, front));\n    \n    mat4 lookAt = mat4(\n        vec4(right, 0.0),\n        vec4(up, 0.0),\n        vec4(front, 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n    vec3 rd = normalize(vec3(lookAt * vec4(uv, 2.0, 1.0)));\n\n    vec3 objColor = volumetricTrace(ro, rd);\n    \n    // gamma correction (yeah, that's definitely not needed here)\n    objColor = pow(objColor, vec3(0.4545));\n\n    fragColor = vec4(objColor, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsjfRD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsjfzd", "name": "Simple Menger KIFS", "author": "blepfo", "description": "Menger KIFS ", "tags": ["raymarch", "kifs"], "likes": 2, "viewed": 93, "date": "1590649572", "time_retrieved": "2024-06-20T20:09:19.863258", "image_code": "#ifdef GL_ES\nprecision highp float;\n#endif\n\n#define PI (3.141)\n#define TWOPI (2.*PI)\n#define RAND_SEED (87629.3453)\n\n#define MARCH_MAX_STEPS (512)\n#define MARCH_MAX_DIST (1000.)\n#define MARCH_HIT_DIST (0.001)\n\n#define AO_ITERATIONS (5)\n#define GLOBAL_AO (0.327)\n\n#define SHADE_AO_ONLY (false)\n\n\nstruct Ray {\n    vec3 o;\t\t\t// origin\n    vec3 d;\t\t\t// direction\n};\n\nstruct PointLight { \n    vec3 o;\t\t\t// origin\n    vec3 d;\t\t\t// diffuse intensity\n    vec3 s; \t\t// specular intensity\n    vec3 a;\t\t\t// ambient intensity\n};\n\nstruct DirectionLight {\n    vec3 dir;\t\t// direction\n    vec3 d;\t\t\t// diffuse intensity\n    vec3 s; \t\t// specular intensity\n    vec3 a;\t\t\t// ambient intensity\n};\n\nstruct Material {\n    vec3 d;\t\t\t// diffuse\n    vec3 s;\t\t\t// specular\n    vec3 a;\t\t\t// ambient\n    float shiny;\t// shininess\n};\n\nstruct SceneObj {\n    float sdf;\n\tint matId;\n};\n\nstruct Hit {\n    vec3 p;\n    vec3 n;\n    SceneObj obj;\n};\n\n/********* Transformations\n**********/\n\nvec3 translate(vec3 p, vec3 t) {\n    return p - t;\n}\n\nmat2 rotate2d(float theta) {\n    return mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n}\n\n\n/********* Signed Distance Functions (SDFs)\n\nReferences for SDFs:\nSphere, Cube, Torus, Capsule, Cylinder - https://youtu.be/Ff0jJyyiVyw (ArtOfCode)\nRotate, Scale, Union, Intersection, Difference - https://youtu.be/AfKGMUDWfuE (ArtOfCode)\nOnioning, Displacement Mapping, Twisting - https://youtu.be/Vmb7VGBVZJA (ArtOfCode)\n\nhttps://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm (Inigo Quilez)\n**********/\n\nfloat sdfCube(vec3 p, vec3 halfSize) {\n    vec3 edgeDist = abs(p) - halfSize;\n    return length(max(edgeDist, 0.))\n        + min(max(edgeDist.x, max(edgeDist.y, edgeDist.z)), 0.);\n}\n\nSceneObj objUnion(SceneObj s1, SceneObj s2) {\n    if (s1.sdf < s2.sdf) {\n        return s1;\n    } else {\n        return s2;\n    }\n}\n\nvec3 fold(vec3 p, vec3 n) {\n    n = normalize(n);\n    float d = dot(p, n);\n    return p - (2. * max(d, 0.) * n);\n}\n\nvec3 fold(vec3 p, float pitch, float yaw) {\n\tfloat cp = cos(pitch);\n    vec3 n = vec3(cp*sin(yaw), sin(pitch), cp*cos(yaw));\n    return fold(p, n);\n}\n\n// Define all objects in the scene\n// Use material Ids so we can wait until later to calculate Material colors\n// Materials using textures need scene normal, which we can't get until after\n// scene SDF is defined\nSceneObj mapScene(vec3 p) {\n\n    vec3 sphereP = p;\n\tfloat hPi = PI / 2.;\n    hPi = iTime;\n    \n\tsphereP.y *= -1.;\n    sphereP /= 2.;\n    #define iterations (4)\n    sphereP = translate(sphereP, vec3(0., -0.25, 0.));\n    for (int i = 0; i < iterations; i++) {\n        sphereP *= 3.;\n    \tsphereP = fold(sphereP, vec3(0., 1., 0.));\n    \tsphereP = translate(sphereP, vec3(0., -2., 0.));\n    \tsphereP = fold(sphereP, vec3(-1., 0., 0.));\n    \tsphereP = translate(sphereP, vec3(2., 0., 0.));\n\t\tsphereP = fold(sphereP, 0., 0.);\n    \tsphereP = translate(sphereP, vec3(0., 0., -2.));\n    \tsphereP = fold(sphereP, -hPi/2., 0.);\n    \tsphereP = fold(sphereP, vec3(1., 1., 0.));\n    \tsphereP = translate(sphereP, vec3(-2., 0., 0.));\n    \tsphereP = fold(sphereP, vec3(1.,0.,0.));\n    \tsphereP = translate(sphereP, vec3(-1., 0., 0.));\n    \tsphereP = fold(sphereP, vec3(1.,0.,0.));\n\t\tsphereP = translate(sphereP, vec3(-1.,0.,0.));\n    \tsphereP = fold(sphereP, vec3(1., 1.,0.));\n    }\n    \n\n    float sphere1Sdf = sdfCube(sphereP, vec3(1.));\n    sphere1Sdf /= pow(3., float(iterations));\n    SceneObj sphere1 = SceneObj(sphere1Sdf, 0);\n    \n    SceneObj s = sphere1;\n    return s ;\n}\n\nfloat sdfScene(vec3 p) {\n\tSceneObj objAtP = mapScene(p);\n    return objAtP.sdf;\n}\n\n\n// Scene normals using SDF gradient\n// References for normal calculation: \n// http://www.michaelwalczyk.com/blog/2017/5/25/ray-marching (Michael Walczyk)\n// https://www.iquilezles.org/www/articles/normalsSDF/normalsSDF.htm (Inigo Quilez)\nvec3 sceneNormal(vec3 p) {\n    vec2 epsilon = vec2(0.01, 0.);\n    return normalize(vec3(\n        sdfScene(p + epsilon.xyy) - sdfScene(p - epsilon.xyy),\n        sdfScene(p + epsilon.yxy) - sdfScene(p - epsilon.yxy),\n        sdfScene(p + epsilon.yyx) - sdfScene(p - epsilon.yyx)\n    ));\n}\n\n\n/********** MATERIALS **********/\n\nMaterial materialLookup(Hit hit) {\n    int matId = hit.obj.matId;\n    if (matId == 0) {\n        // Plane material\n        return Material(\n        \tvec3(0.535,0.535,0.535),\n        \tvec3(0.245,0.245,0.245), \n        \tvec3(0.245,0.239,0.245),\n        \t256.\n        );\n    }\n}\n\n\n// References for raymarching:\n// http://www.michaelwalczyk.com/blog/2017/5/25/ray-marching (Michael Walczyk)\n// https://youtu.be/PGtv-dBi2wE (ArtofCode)\nbool rayMarch(Ray r, out Hit hit) {\n    // Accumulated distance to ray origin\n    float dO = 0.;\n    for (int i = 0; i < MARCH_MAX_STEPS; i++) {\n        vec3 p = r.o + (dO * r.d);\n        // Current distance to scene\n        float dS = sdfScene(p);\n        dO += dS;\n        if (abs(dS) < MARCH_HIT_DIST) {\n            hit = Hit(\n                p,\n                sceneNormal(p),\n                mapScene(p)\n            );\n            return true;\n        }\n        if (dO >= MARCH_MAX_DIST) {\n            return false;\n        }\n    }\n    return false;\n}\n\n\n/********** LIGHTING **********/\n\n// Reference for shadows: \n// https://youtu.be/2YZClgDWCaM (3dGraphicsFromScratch)\n// http://www.polygonpi.com/?p=318 (Polygon Pi)\n// https://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm (Inigo Quilez)\nfloat calcShadow(Ray shadowRay, float maxMarch, float k) {\n    // Shadow increases when ray from surface to light gets closer to scene (dS gets smaller)\n    // More distant objects cast darker shadows (dO gets larger)\n    float shadowMultiplier = 1.;\n    float dO = 0.;\n    for (int i = 0; i < MARCH_MAX_STEPS; i++) {\n        if (dO > maxMarch) { break; }\n        vec3 p = shadowRay.o + (dO * shadowRay.d);\n        float dS = sdfScene(p);\n        if (abs(dS) < MARCH_HIT_DIST) {\n            // Hit surface -- we are in a shadow\n            return 0.;\n        }\n        dO += dS;\n        shadowMultiplier = min(shadowMultiplier, k * dS / dO);\n    }\n\treturn clamp(shadowMultiplier, 0., 1.);\n}\n\n// Reference for ambient occlusion:\n// https://youtu.be/6zYTrFRVGiU (3dGraphicsFromScratch)\nfloat calcAO(vec3 p, vec3 normal, float epsilon) {\n    float aoMultiplier = 0.;\n    float weight = 0.5;\n    for (int i = 1; i <= AO_ITERATIONS ; i++) {\n        float t = epsilon * float(i);\n        aoMultiplier += (weight * (1. - (t - sdfScene(p + t*normal))));\n        weight /= 2.;\n    }\n    return aoMultiplier;\n}\n\n\n// Reference for lighting:\n// Basics - http://www.michaelwalczyk.com/blog/2017/5/25/ray-marching (Michael Walczyk)\n// Diffuse - https://youtu.be/9VJReTr7YXY (3dGraphicsFromScratch)\n// Diffuse - shadows - https://youtu.be/PGtv-dBi2wE (ArtOfCode)\nvec3 illuminateSingleLight(\n    Hit hit, \n    vec3 lDir, \n    vec3 lDiffuse, \n    vec3 lSpec, \n    vec3 lAmbient, \n    vec3 eye,\n    float maxMarch\n) {\n    Material mat = materialLookup(hit);\n    // DIRECT LIGHTING\n    // Diffuse illumination\n    float diffuse = dot(hit.n, lDir);\n    vec3 diffuseIllum = diffuse * lDiffuse * mat.d;\n    // Specular illumination\n    vec3 r = reflect(lDir, hit.n);\n    vec3 viewDir = normalize(eye - hit.p);\n    float specular = dot(r, viewDir);\n    vec3 specularIllum = pow(specular, mat.shiny) * mat.s * lSpec;\n    vec3 directLight = diffuseIllum + specularIllum;\n    // Estimate shadow\n    vec3 pNearSurface = hit.p + (hit.n * MARCH_HIT_DIST * 2.);\n    float shadow = calcShadow(Ray(pNearSurface, lDir), maxMarch, 3.);\n    directLight *= shadow;\n    // INDIRECT LIGHTING\n    vec3 ambientIllum = lAmbient * mat.a;\n    float ambientOcclusion = calcAO(hit.p, hit.n, GLOBAL_AO);\n    vec3 indirectLight = ambientIllum * ambientOcclusion;\n    \n    vec3 illum = directLight + indirectLight;\n    \n    if (SHADE_AO_ONLY) {\n        return vec3(ambientOcclusion);\n    }\n\n    return clamp(illum, 0., 1.);\n}\n\n\n// DirectionalLight\nvec3 illuminateSingleLight(Hit hit, DirectionLight l, vec3 eye, float maxMarch) {\n    vec3 illum = illuminateSingleLight(hit, l.dir, l.d, l.s, l.a, eye, maxMarch);\n    return illum;\n}\n\n\n// Point light\nvec3 illuminateSingleLight(Hit hit, PointLight l, vec3 eye) {\n    vec3 lDir = normalize(l.o - hit.p);\n    // Light intensity decayed by 1/(dist^2)\n    vec3 lDiff = (hit.p - l.o);\n    float falloff = 1. / dot(lDiff, lDiff);\n    vec3 illum = illuminateSingleLight(hit, DirectionLight(lDir, l.d*falloff, l.s*falloff, l.a), eye, distance(hit.p, l.o));\n\n    return illum;\n}\n\n\n// Define all lights in the scene\nvec3 illuminateScene(Hit hit, vec3 eye) {\n\tDirectionLight l1 = DirectionLight(\n        -vec3(0.800,0.000,0.535), \n        vec3(1.),\n        vec3(1.),\n        vec3(0.1)\n    );\n  \n    vec3 l2Pos = vec3(4., 2., 0.);\n    vec3 l2Intensity = vec3(15.);\n    PointLight l2 = PointLight(\n        l2Pos, \t\t\t\n        l2Intensity, \n        l2Intensity, \n        vec3(0.075,0.075,0.075)\n    );\n    \n    DirectionLight l3 = DirectionLight(\n        vec3(-0.200,0.000,0.835), \n        vec3(1.),\n        vec3(1.),\n        vec3(0.1)\n    );\n\n    vec3 i1 = illuminateSingleLight(hit, l1, eye, 100.);\n    vec3 i2 = illuminateSingleLight(hit, l2, eye);\n    vec3 i3 = illuminateSingleLight(hit, l3, eye, 100.);\n    return i1 + i2 + i3;\n}\n\n\n/********* RENDER SCENE *********/\n\n// References for camera:\n// https://youtu.be/PBxuVlp7nuM (ArtofCode)\n// https://youtu.be/2SaGgTlkhSs (3dGraphicsFromScratch)\nRay cameraViewRay(vec2 uv, vec3 eye, vec3 lookat, float fovDegrees, float roll) {\n    // Axes\n    vec3 f = normalize(lookat - eye);\n    vec3 r = cross(vec3(0., 1., 0.), f);\n    vec3 u = cross(f, r);\n    // Image plane\n    float zoom = 1. / tan(radians(fovDegrees) / 2.);\n    vec3 c = eye + f*zoom;\n    uv *= rotate2d(roll);\n    vec3 i = c + (uv.x*r) + (uv.y*u);\n    // Ray from camera origin to intersection with image plane\n    return Ray(eye, normalize(i - eye));\n}\n\n\nvec3 renderScene(Ray viewRay) {\n    Hit sceneHit;\n    // rayMarch returns false if no scene intersection\n    if(!rayMarch(viewRay, sceneHit)) return vec3(0.012,0.025,0.006);\n    else return illuminateScene(sceneHit, viewRay.o);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    // Move origin to center of viewing plane\n    uv -= 0.5;\n    // Normalize aspect ratio\n    uv.x *= iResolution.x/iResolution.y;\n    // Remap to [-1, -1] x [1, 1]\n    uv *= 2.;\n    \n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse -= 0.5;\n    \n    // CAMERA SETUP\n    vec2 cameraXZ = 7. * vec2(cos(mouse.x*TWOPI*2.), sin(mouse.x*TWOPI*2.));\n    vec3 eye = vec3(cameraXZ[0], 6. + sin(mouse.y)*10., cameraXZ[1]);\n    vec3 lookat = vec3(0., 0., 0.);\n    Ray viewRay = cameraViewRay(uv, eye, lookat,  65., 0.);\n\n    // CALCULATE PIXEL COLOR\n    vec3 color = vec3(0.);\n    color = renderScene(viewRay);\n    // Gamma correction\n    color = pow(color, vec3(0.6));\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsjfzd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsjfzh", "name": "RayMarching - BasicExample", "author": "SimonParschat", "description": "Shader test: Implemented n_reflections based on object normal. Also, have Lightsource and shadows which are based on the distance to the object. A camera with basic functionality has also been implemented. Very inefficient..", "tags": ["raymarching"], "likes": 1, "viewed": 218, "date": "1589582677", "time_retrieved": "2024-06-20T20:09:19.863483", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST  1000.\n#define SURF_DIST .01\n#define N_SPHERES 2\n#define N_PLANES 1\n#define N_BOXES 0\n#define N_REFLECTIONS 0\n#define SOURCE_TO_CAM_DISTANCE 10.\n#define M_PI 3.1415926535897932384626433832795\n\nstruct Sphere  {    \n    vec3  spherePosition;\n    vec3  sphereColor;\n    float sphereRadius;\n};\n    \nstruct Plane {\n    vec3  planeColor;\n    float planeY;\n};\n\nstruct Box {\n    vec3 boxPosition;\n    vec3 boxSize;\n    vec3 boxColor;\n};\n\nfloat GetSphereDistance(in Sphere spheres[N_SPHERES], in vec3 p, out int sphereID) {\n    float minLen = 10000.;\n    sphereID = 0;\n    for (int i = 0; i < N_SPHERES; i++) {\n        float sLen = length(p - spheres[i].spherePosition) - spheres[i].sphereRadius;\n        minLen = min(minLen, sLen);\n        sphereID = (minLen == sLen) ? i : sphereID;\n    }\n    return minLen;\n}\n\nfloat GetPlaneDistance(in Plane planes[N_PLANES], in vec3 p, out int planeID) {\n    float minLen = 10000.;\n    planeID = 0;\n    for (int i = 0; i < N_PLANES; i++) {\n        float pLen = abs(p.y - planes[i].planeY);\n        minLen     = min(minLen, pLen);\n        planeID    = (minLen == pLen) ? i : planeID;\n    }\n    return minLen;\n}\n\nfloat GetBoxDistance(in Box box, in vec3 p) {\n    return length(max(abs(p) - box.boxSize, 0.));\n}\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n   \n    return mat2(c, -s, s, c);\n}\n\nvec3 RotateAboutNormal(in vec3 rayNorm, in vec3 objNorm) {\n    float angle     =  M_PI;\n    rayNorm         = -rayNorm;\n    vec3   paraComp = (dot(rayNorm,objNorm) / dot(objNorm,objNorm))*objNorm;\n    vec3   perpComp =  rayNorm - paraComp;\n    vec3   w        =  cross(objNorm, perpComp);\n    float  x1       =  cos(angle) / length(perpComp);\n    float  x2       =  sin(angle) / length(w);\n    \n    vec3 perpObjAng =  length(perpComp) * (x1 * perpComp + x2 * w);\n    vec3 rotVec     =  perpObjAng + paraComp;\n    return rotVec;\n}\n\nfloat GetDist(in vec3 p, out vec3 objColor) {\n    int sphereID = 0;\n    int planeID = 0;\n    \n    Sphere sphere[N_SPHERES] = Sphere[N_SPHERES](\n        \tSphere(vec3( -.5,  1.,  0.),  vec3(0.5,0.8,0.5),  .4),\n    \t\tSphere(vec3(  .5,  1.,  0.),  vec3(0.5,0.5,0.8),    .4) );\n        \n    Plane  plane[N_PLANES] = Plane[N_PLANES](\n        \tPlane(vec3(1.,1.,1.), \t\t\t 0.  ));\n    //Box    box \t = Box(   vec3(-5., 2., 5.), vec3(.5, .5, .5), vec3(1.,.8,.8) );\n    \n    float SphereDist  = GetSphereDistance(sphere, p, sphereID);\n    float PlaneDist   = GetPlaneDistance(plane, p, planeID); \n    float d = min(SphereDist, PlaneDist);\n    \n    if (d == SphereDist)     { objColor = sphere[sphereID].sphereColor; }\n    else if (d == PlaneDist) { objColor = plane[planeID].planeColor; }\n    //else if (d == BoxDistance) { objColor = box.boxColor; }\n        \n    return d;\n}\n\nfloat RayMarch(in vec3 ro, in vec3 rd, out vec3 objCol) {\n\tfloat pointPos = 0.;\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n    \tvec3 p = ro + rd * pointPos;\n        float dS = GetDist(p, objCol);\n        pointPos += dS;\n        \n        if ( pointPos > MAX_DIST || dS < SURF_DIST) break;\n    }\n    \n    return pointPos;\n}\n\nvec3 GetNormal(in vec3 p) {\n    vec3 cOlDummy = vec3(0);\n    float d = GetDist(p, cOlDummy);\n    vec2  e = vec2(.01,0);\n    \n    vec3 n = d - vec3(\n        GetDist(p - e.xyy, cOlDummy),\n        GetDist(p - e.yxy, cOlDummy),\n        GetDist(p - e.yyx, cOlDummy));\n    return normalize(n);\n}\n\nfloat GetLight(in vec3 p) {\n    vec3 cOlDummy = vec3(0.);\n    vec3 lightPosition = vec3(0,5,0);\n    lightPosition.xz += vec2(sin(iTime * .5) * 10.,cos(iTime * .5) * 10.);\n    \n    vec3 l = normalize(lightPosition - p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p + n*SURF_DIST*1.5, l, cOlDummy);\n    \n    if (d < length(lightPosition - p)) dif *= 0.3* clamp(d, 0.,1.);\n\treturn dif;\n}\n\nvec3 RayDirection(in vec3 pixelPos, in vec3 intermediatePlane) {    \n    vec3 rDir = normalize(pixelPos - intermediatePlane);\n    return rDir;\n}\n\nfloat RayReflection(in vec3 p, in vec3 rayNorm, out vec3 refCol, in int N){\n    float d = 0.;\n    for (int i = 0; i < N; i++) {\n        vec3 objNormal = GetNormal(p);\n        vec3 refNormal = RotateAboutNormal(rayNorm, objNormal);\n       \tvec3 coL = vec3(0.);    \n       \t\n        d = RayMarch(p + objNormal*SURF_DIST*1.6, refNormal, coL);\n        refCol += (coL * 1./ float(N))*.9;\n        p += refNormal*d;\n    }\n        \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec3 colorOfPixel = vec3(0.);\n    \n    vec3 cameraPosition = vec3(0.,5.,-20.);\n    vec3 viewNorm = normalize(vec3(0.,1.,0.) - cameraPosition);\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    vec3 camRightNorm = normalize(cross(vec3(0.,-1.,0.), viewNorm));\n    vec3 camUpNorm = normalize(cross(camRightNorm, viewNorm));\n\n    vec3 ro = (-camRightNorm*uv.x)+(camUpNorm*uv.y) + cameraPosition;\n    vec3 ri = (-camRightNorm*uv.x * 0.5) + (camUpNorm*uv.y * 0.5) + cameraPosition + viewNorm * (-SOURCE_TO_CAM_DISTANCE*.5);\n    vec3 rd = RayDirection(ro, ri);\n    \n    float d = RayMarch(ro, rd, colorOfPixel);\n    vec3 p = ro + rd*d;\n    vec3 dumCol = colorOfPixel;\n    if (N_REFLECTIONS != 0) {\n    \tfloat dRef = RayReflection(p, rd, dumCol, N_REFLECTIONS);\n    \tcolorOfPixel = (colorOfPixel + dumCol) * (1./float(N_REFLECTIONS)) ;\n    }\n        \n\tfloat dif = GetLight(p);\n    \n    fragColor = vec4(colorOfPixel,1.0) * dif;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsjfzh.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wsjfzm", "name": "I dont understand shaders", "author": "Anderkent", "description": "Performing the `(bary.z * v1.Uv  + bary.x * v2.Uv + bary.y * v3.Uv)` calculation outside the conditionals somehow changes the output, even though nothing is mutated (?). How?\n\nremove the && false comment in line 217 to verify (it'll optimize out the calc)", "tags": ["rasterizer", "mesh"], "likes": 0, "viewed": 72, "date": "1589814042", "time_retrieved": "2024-06-20T20:09:21.027223", "image_code": "\n\n#define BACKFACE_CULL true\n#define TEXTURED true\n\n\nstruct Vertex\n{\n    vec4 Pos;\n    vec2 Uv;\n};\n\n\n// Test a position against a triangle and return\n// the non-perspective-correct barycentric coordinates in the triangle\n// Vertex z and w values are ignored.\nvec2 BaryTri2D ( vec2 pos, Vertex v1, Vertex v2, Vertex v3 )\n{\n    vec2 posv1 = pos - vec2(v1.Pos);\n    \n    vec2 v21 = vec2(v2.Pos) - vec2(v1.Pos);\n    vec2 v31 = vec2(v3.Pos) - vec2(v1.Pos);\n    \n    float scale = v21.x * v31.y - v21.y * v31.x;\n    if ( BACKFACE_CULL && ( scale < 0.0 ) )\n    {\n        return vec2 ( -1.0, -1.0 );\n    }\n    \n    float rscale = 1.0 / scale;\n    float baryi = ( posv1.x * v31.y - posv1.y * v31.x ) * rscale;   \n    float baryj = ( posv1.x * v21.y - posv1.y * v21.x ) * -rscale;\n    \n    return vec2 ( baryi, baryj );\n}\n\n\n// Test a position against a triangle and return\n// the perspective-correct barycentric coordinates in the triangle\n// Note the z value in the vertex is ignored, it's the w that matters.\nvec2 BaryTri3D ( vec2 pos, Vertex v1, Vertex v2, Vertex v3 )\n{\n    vec2 posv1 = pos - vec2(v1.Pos);\n    \n    vec2 v21 = vec2(v2.Pos) - vec2(v1.Pos);\n    vec2 v31 = vec2(v3.Pos) - vec2(v1.Pos);\n    \n    float scale = v21.x * v31.y - v21.y * v31.x;\n    if ( BACKFACE_CULL && ( scale < 0.0 ) )\n    {\n        return vec2 ( -1.0, -1.0 );\n    }\n\n    float rscale = 1.0 / scale;\n    float baryi = ( posv1.x * v31.y - posv1.y * v31.x ) * rscale;\n    float baryj = ( posv1.x * v21.y - posv1.y * v21.x ) * -rscale;\n    \n    // Now interpolate the canonical coordinates (0,0,1,v1.w), (1,0,1,v2.w) and (0,1,1,v3.w)\n    // with perspective correction\n    // So we project all three by their respective w:\n    // (0,0,v1.w) -> (0,     0,     1/v1.w)\n    // (1,0,v2.w) -> (1/v2.w,0,     1/v2.w)\n    // (0,1,v3.w) -> (0,     1/v3.w,1/v3.w)\n    // Then interpolate those values linearly to produce (nx,ny,nw),\n    // then divide by nw again.\n    vec3 recipw = vec3 ( 1.0/v1.Pos.w, 1.0/v2.Pos.w, 1.0/v3.Pos.w );\n    \n    float baryk = 1.0 - baryi - baryj;\n    float newi = recipw.y * baryi;\n    float newj = recipw.z * baryj;\n    //float neww = recipw.x * baryk + recipw.y * baryi + recipw.z * baryj;\n    float neww = recipw.x * baryk + newi + newj;\n    \n    // ...and project back.\n    float rneww = 1.0/neww;\n    float perspi = newi * rneww;\n    float perspj = newj * rneww;\n        \n    return vec2 ( perspi, perspj );\n}\n\nconst int GridW = 5;\nconst int GridH = 5;\nconst int NumVerts = GridH*GridW*2;\nconst int NumTris = (GridH-1)*(GridW-1)*2*2;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // NDC (-1 to +1)\n    vec2 uv = -1.0 + 2.0f * (fragCoord/iResolution.xy);\n    \n    float wobble = float(iTime);\n    \n    // Create the mesh. This would of course be done offline.\n    Vertex Verts[NumVerts];\n    for ( int w = 0; w < GridW; w++ )\n    {\n        for ( int h = 0; h < GridH; h++ )\n        {\n            Vertex Vert0, Vert1;\n            Vert0.Pos.x = float(w - GridW/2);\n            Vert0.Pos.y = float(h - GridH/2);\n            float wf = -2.0 + float(w);\n            float hf = -3.0 + float(h);\n            float d = sqrt(wf*wf + hf*hf);\n            Vert0.Pos.z = 0.3 * cos (d * 2.0 + wobble);\n            Vert0.Pos.w = 1.0f;\n            Vert0.Uv.x = float(w) / float(GridW-1);\n            Vert0.Uv.y = float(h) / float(GridH-1);\n            \n            Vert1.Pos = Vert0.Pos;\n            Vert1.Pos.z += 1.0f;\n            Vert1.Uv = Vert0.Uv;\n            \n            int Index = (w*GridH+h)*2;\n            Verts[Index+0] = Vert0;\n            Verts[Index+1] = Vert1;\n        }\n    }\n\n    int Indices0[NumTris];\n    int Indices1[NumTris];\n    int Indices2[NumTris];\n    for ( int w = 0; w < GridW-1; w++ )\n    {\n        for ( int h = 0; h < GridH-1; h++ )\n        {\n            int VertIndex = (w*GridH+h)*2;\n            int TriIndex = (w + (GridH-1)*h) * 2 * 2;\n            Indices0[TriIndex+0] = VertIndex  ;\n            Indices1[TriIndex+0] = VertIndex  +GridH*2;\n\t\t\tIndices2[TriIndex+0] = VertIndex  +2;\n            Indices0[TriIndex+1] = VertIndex+1;\n            Indices2[TriIndex+1] = VertIndex+1+GridH*2;\n\t\t\tIndices1[TriIndex+1] = VertIndex+1+2;\n            \n            Indices2[TriIndex+2] = VertIndex  +GridH*2;\n            Indices0[TriIndex+2] = VertIndex  +GridH*2+2;\n\t\t\tIndices1[TriIndex+2] = VertIndex  +2;\n            Indices1[TriIndex+3] = VertIndex+1+GridH*2;\n            Indices0[TriIndex+3] = VertIndex+1+GridH*2+2;\n\t\t\tIndices2[TriIndex+3] = VertIndex+1+2;\n        }\n    }\n    \n    float hfov = 0.6;\n    float vfov = hfov * iResolution.y / iResolution.x;\n    float zfar = 10.0f;\n    float znear = 1.0f;\n    float q = zfar/(zfar-znear);\n    \n    mat4 ProjMat;\n    ProjMat[0] = vec4 ( 1.0/hfov, 0.0f, 0.0f, 0.5f );\n    ProjMat[1] = vec4 ( 0.0f, 1.0/vfov, 0.0f, 0.5f );\n    ProjMat[2] = vec4 ( 0.0f, 0.0f, q, 1.0f );\n    ProjMat[3] = vec4 ( 0.0f, 0.0f, -q*znear, 0.0f );\n    \n    \n    mat4 TotalMat;\n    mat4 ObjMat1;\n    mat4 ObjMat2;\n    \n    float a1 = iMouse.x * 0.01;\n    float a2 = iMouse.y * 0.01;\n    float zdist = 8.0;\n    ObjMat1[0] = vec4 ( cos(a1),  sin(a1), 0.0, 0.0 );\n    ObjMat1[1] = vec4 ( sin(a1), -cos(a1), 0.0, 0.0 );\n    ObjMat1[2] = vec4 ( 0.0,          0.0, 1.0, 0.0 );\n    ObjMat1[3] = vec4 ( 0.0,          0.0, 0.0, 1.0 );\n    ObjMat2[0] = vec4 ( 1.0, 0.0,          0.0, 0.0 );\n    ObjMat2[1] = vec4 ( 0.0, cos(a2),  sin(a2), 0.0 );\n    ObjMat2[2] = vec4 ( 0.0, sin(a2), -cos(a2), zdist );\n    ObjMat2[3] = vec4 ( 0.0, 0.0,          0.0, 1.0 );\n    \n    TotalMat = ObjMat1 * ObjMat2;\n    TotalMat = TotalMat * ProjMat;\n\n    // Background colour\n    vec3 col;\n    col.xy = uv.xy;\n    col.z = 0.0;\n\n    Vertex ScreenVert[NumVerts];\n    for ( int VertNum = 0; VertNum < NumVerts; VertNum++ )\n    {\n        vec4 Pos = Verts[VertNum].Pos;\n        \n        vec4 ScrPos = Pos * TotalMat;\n        float rw = 1.0/ScrPos.w;\n        ScrPos.x *= rw;\n        ScrPos.y *= rw;\n        ScrPos.z *= rw;\n        \n        ScreenVert[VertNum].Pos = ScrPos;\n        ScreenVert[VertNum].Uv = Verts[VertNum].Uv;\n    }\n    \n    float NearestZ = 10000.0f;\n    for ( int TriNum = 0; TriNum < NumTris; TriNum++ )\n    {\n        Vertex v1 = ScreenVert[Indices0[TriNum]];\n        Vertex v2 = ScreenVert[Indices1[TriNum]];\n        Vertex v3 = ScreenVert[Indices2[TriNum]];\n        vec3 bary;\n        bary.xy = BaryTri3D ( uv, v1, v2, v3 );\n        bary.z = 1.0 - bary.x - bary.y;\n\n        // You need to do the UV coord generation outside all the conditionals,\n        // otherwise you don't get good gradients at the edges.\n        // HOWEVER - what actually happens is the compiler spots you only *use* the UV\n        // values inside the conditionals and drags the calculation inside,\n        // which then breaks the gradients! So to stop this, I added a totally\n        // spurious test of the UV coords to the barycentric test.\n\n        if ((bary.z * v1.Uv  + bary.x * v2.Uv + bary.y * v3.Uv).x + \n             (bary.z * v1.Uv  + bary.x * v2.Uv + bary.y * v3.Uv).y < -10.0\n            // && false\n           ) {\n            col.xy = bary.xy;\n            col.z = sqrt(-1.0);\n        }\n\n        \n        if ( ( bary.x >= 0.0 ) &&\n             ( bary.y >= 0.0 ) &&\n             ( bary.z >= 0.0 ) )\n        {\n            vec2 uv = bary.z * v1.Uv + bary.x * v2.Uv + bary.y * v3.Uv;\n            // Interpolate Z\n            // Note this is linear Z, not the strange Z that most rasteriser use\n            // In this case, that's fine.\n            float Z = bary.z * v1.Pos.z + bary.x * v2.Pos.z + bary.y * v3.Pos.z;\n            if ( NearestZ > Z )\n            {\n                NearestZ = Z;\n            \n                if ( TEXTURED )\n                {\n                    vec4 tex = texture ( iChannel0, uv );\n                    col.xyz = tex.xyz;\n                }\n                else\n                {\n                    col.xy = bary.xy;\n                    col.z = 1.0;\n                    if ( fract ( bary.x * 4.0 ) < 0.05 ) { col.z = 0.0; }\n                    if ( fract ( bary.y * 4.0 ) < 0.05 ) { col.z = 0.0; }\n                }\n            }\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wsjfzm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsjfzV", "name": "Prep for Outline 2020/23 may MS.", "author": "MonsieurSoleil", "description": "That was the expecxted Result !!!!!!!", "tags": ["livecoding", "preparation"], "likes": 5, "viewed": 146, "date": "1590429258", "time_retrieved": "2024-06-20T20:09:21.027223", "image_code": "#define time iTime\n#define mod01 floor(mod(time, 4.0))\n#define mod02 floor(mod(time * 2.0, 2.0))\n#define mod03 floor(mod(time  * 8.0, 16.0))\n\n\nfloat gg = 0.0;\n\nstruct matter\n{\n  float mat;\n  int type;\n};\nmat2 rot(float a)\n{\n  float ca = cos(a);\n  float sa = sin(a);\n  \n  return mat2(ca, -sa, sa, ca);\n}\n\nfloat sphere(vec3 p, float r)\n{\n  return length(p) - r;\n}\n\nfloat box(vec3 p, vec3 r)\n{\n  p = abs(p) - r;\n  return max(p.x, max(p.y, p.z));\n}\n\nfloat Infbox(vec3 p, vec2 r)\n{\n  p.xz = abs(p.xy) - r;\n  return max(p.x, p.y);\n}\n\nfloat terrain(vec3 p)\n{\n    return p.y + 0.8;\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5 - 0.5 * ( a - b )/k, 0.0, 1.0);\n    return mix(b , a, h) - k*h*(1.0*h);\n}\n\nvec3 opRepLimit(vec3 p, float c, vec3 l)\n{\n \treturn p - c * clamp(round(p/c), -l, l);   \n}\n\nvec2 opRepID(vec2 p, float repeat)\n{\n  return (floor(abs(p) / repeat - 0.5) - 0.5) * repeat;\n}\n\nvec2 opRep(vec2 p, float repeat)\n{\n  return (fract(abs(p) / repeat - 0.5) - 0.5) * repeat; \n}\n\nfloat opRep(float p, float repeat)\n{\n  return (fract(abs(p) / repeat - 0.5) - 0.5) * repeat;\n}\n\nmatter map(vec3 p)\n{\n  matter m;\n  \n  float mat01, mat02;\n  vec3 p02 = p;\n  vec3 p03 = p;\n  vec3 p04 = p;\n  \n  p02.z = opRep(p.z, 1.0);\n  vec2 gID = opRepID(p.xz, 2.0);\n  \n  vec3 scale = vec3(0.5, 0.05 + mod01 * 0.05 + mod02 * 0.1 + mod03 * 0.1, 100000000000.0);\n  \n  p.xy *= rot(sin(p.z * 0.1 + time) * ((mod01 * 0.5) + 2.0));  \n  p02.xy *= rot(sin(p.z * 0.02 + time) * ((mod01 * 0.1) + 2.0));  \n  p02.xz *= rot(sin(p.z * 0.01 + time) * 0.5);  \n  \n  p03.xy *= rot(sin(p.z * 0.02 + time) * ((mod01 * 0.1) + 5.0));  \n  //p02.xz *= rot(sin(p.z * 0.01 + time) * 0.5);  \n  p04.xy *= rot(sin(p.z * 0.01 + time) * ((mod03 * 0.5) + .0));  \n  mat01 = box(p + vec3(1.0, 4.0, 0.0), scale * 0.5);\n  \n  //mat01 = Infbox(p, vec2(1.5));\n  mat02 = box(p02 + vec3(0.2, 6.0, 0.0), scale * 0.5);\n  mat02 = min(mat02, box(p02 + vec3(10, 6.0, 0.0), scale * 0.2));\n  mat02 = min(mat02, box(p02 + vec3(2.0, 1.0, 0.0), scale * 0.2));\n  mat02 = min(mat02, box(p02 + vec3(2.0, 1.0, 0.0), scale * 0.2));\n  mat02 = min(mat02, box(p03 + vec3(10.0, 5.0, 0.0), scale * 0.2));\n  \n  gg += 0.1/(0.9+mat01*mat01);\n  \n  m.mat = min(mat01, mat02);\n  m.mat = min(m.mat, -box(p04, vec3(7.0 + abs(sin(time * 0.1)) * 5.0, 7.0 + abs(sin(time * 0.1)) * 5.0, 100000000000.0)));\n  \n  if(m.mat < 0.001)\n  {\n    m.type = 1;\n  }\n\n  return m;\n}\n\nvec3 normals(vec3 p)\n{\n  vec2 uv = vec2(0.01, 0.0);\n  \n  return vec3(map(p).mat - vec3(map(p - uv.xyy).mat, map(p - uv.yxy).mat, map(p - uv.yyx).mat));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n vec3 l = normalize(vec3(0.0, 10.0, -5.0));\n  \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 o = vec3(0.0, -1.0, 1.0 + (time * 0.3)), t = vec3(0.0, -1.0, (time * 0.3));\n  vec3 fr = normalize( t - o );\n  vec3 ri = normalize( cross(vec3(0.0, 1.0, 0.0), fr) );\n  vec3 up = normalize( cross(fr, ri) );\n  vec3 dir = normalize( fr + uv.x * ri + uv.y * up );\n  vec3 p = o + dir * 0.5;\n  \n  vec3 col = vec3(0.0);\n  matter m;\n  float shad = 0.0;\n  float d = 0.0;\n  \n  for(int i = 0; i < 100; ++i)\n  {\n    /*\n    p.xy *= rot(sin(time * 0.0001) * 0.1);\n    p.xz *= rot(sin(time * 0.0001) * 0.05);\n    p.yz *= rot(sin(time * 0.0001) * 0.01);\n    */\n    \n    m = map(p);\n    \n    if(m.mat < 0.001)\n    {\n      if(m.type == 1)\n      {\n        m.mat = 0.5;\n        \n        vec3 n = normals(p);\n        dir = reflect(dir, n);\n      } else {\n        \n         break;\n      }\n      \n      shad = clamp(1.0 - pow((float(i)/500.0), 2.0),0.0,1.0);\n    }\n    \n    p += dir * m.mat;\n    d += m.mat;\n    \n    col += mix(vec3(1.0, 0.5, 1.0), vec3( 1.0, 0.5, 0.0), sin(time + (p.z * 0.01))) * gg * 0.004;\n  }\n  \n  vec3 n = normals(p);\n\n  float fog = clamp(1.0 - (d/100.0), 0.0, 1.0);\n  vec3 sky = mix(vec3(0.5, 0.3, 0.3), vec3(0.8, 0.4, 0.1), uv.y - 0.5); \n  \n  col += shad * vec3(1.0)  * clamp(dot(n, l), 0.0, 1.0);\n  col += sky * 1.0;\n  \n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsjfzV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wsjfzy", "name": "party boze", "author": "kaiware007", "description": "party parrot parody", "tags": ["raymarching"], "likes": 3, "viewed": 76, "date": "1590334135", "time_retrieved": "2024-06-20T20:09:23.282107", "image_code": "// ------------------------------------------------------------------------------------\n// Original \"thinking...\" created by kaneta : https://www.shadertoy.com/view/wslSRr\n// Original Character By MikkaBouzu : https://twitter.com/mikkabouzu777\n// ------------------------------------------------------------------------------------\n\n#define M_PI 3.1415926\n#define M_PI2 M_PI*2.0\n\n#define M_PI03 1.04719\n#define M_PI06 2.09439\n\n#define MAT_BLACK 1.0\n#define MAT_FACE 2.0\n#define MAT_BROW 3.0\n#define MAT_CHEEP 4.0\n#define MAT_SPHERE 5.0\n#define MAT_BG 6.0\n\n#define AA 1\n    \nvec3 sinebow(float h) {\n    vec3 r = sin((.5-h)*M_PI + vec3(0,M_PI03,M_PI06));\n    return r*r;\n}\n\nfloat rand(vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 10000.0);\n}\n\nfloat easeInOutQuad(float t) {\n    if ((t *= 2.0) < 1.0) {\n        return 0.5 * t * t;\n    } else {\n        return -0.5 * ((t - 1.0) * (t - 3.0) - 1.0);\n    }\n}\n\n// Distance functions by iq\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdRoundBox(vec3 p, vec3 size, float r)\n{\n    return length(max(abs(p) - size * 0.5, 0.0)) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - r;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n// Union, Subtraction, SmoothUnion (distance, Material) \nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 opS( vec2 d1, vec2 d2 )\n{ \n    return (-d1.x>d2.x) ? vec2(-d1.x, d1.y): d2;\n}\n\nvec2 opSU( vec2 d1, vec2 d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.x-d1.x)/k, 0.0, 1.0 );\n    return vec2(mix( d2.x, d1.x, h ) - k*h*(1.0-h), h > 0.5 ? d1.y : d2.y); }\n\n// Union, Subtraction, SmoothUnion (distance only)\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\nvec3 rotate(vec3 p, float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nvec3 opTwist(in vec3 p, float k )\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return vec3(q.x, q.y, q.z);\n}\n\nvec3 TwistY(vec3 p, float power)\n{\n    float s = sin(power * p.y);\n    float c = cos(power * p.y);\n    mat3 m = mat3(\n          c, 0.0,  -s,\n        0.0, 1.0, 0.0,\n          s, 0.0,   c\n    );\n    return m*p;\n}\n\nfloat ease_cubic_out(float p)\n{\n\tfloat f = (p - 1.0);\n\treturn f * f * f + 1.0;\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\nvec2 opRep2D( in vec2 p, in vec2 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\n// ç·åã¨ç¡éå¹³é¢ã®è¡çªä½ç½®ç®åº\n// rayPos : ã¬ã¤ã®éå§å°ç¹\n// rayDir : ã¬ã¤ã®åã\n// planePos : å¹³é¢ã®åº§æ¨\n// planeNormal : å¹³é¢ã®æ³ç·\nfloat GetIntersectLength(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal)\n{\n    return dot(planePos - rayPos, planeNormal) / dot(rayDir, planeNormal);\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// Mikka Boze Distance Function\n/////////////////////////////////////////////////////////////////////////////////////////////////\n#define RAD90 (M_PI * 0.5)\n\nfloat sdEar(vec3 p, float flip, float sc)\n{\n    p.x *= flip;\n    p = rotate(p, RAD90+0.25, vec3(0,0,1));    \n    return sdCappedTorus(p + vec3(0.05, 0.175, 0) * sc, vec2(sin(0.7),cos(0.7)), 0.03 * sc, 0.01 * sc);\n}\n\n#define EYE_SPACE 0.04\n\nvec3 opBendXY(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\nfloat sdMouse(vec3 p, float sc)\n{\n    vec3 q = opBendXY(p, 2.0);\n    \n    return sdEllipsoid(q - vec3(0,0,0.2) * sc, vec3(0.05,0.015 + sin(iTime * 0.5*M_PI2) * 0.05,0.05) * sc);\n}\n\nfloat sdCheep(vec3 p, float flip, float sc)\n{\n\tp.x *= flip;\n    \n    float x = 0.05;\n    float z = -0.18;\n    p = rotate(p, M_PI * -0.6 * (p.x - x) / sc, vec3(0,1,0));\n\n    float d = sdCapsule(opBendXY(p + vec3(x, -0.01, z) * sc, 100.0/sc), vec3(-0.005,0.0,0) * sc, vec3(0.005, 0., 0) * sc, 0.0025 * sc);\n    float d1 = sdCapsule(opBendXY(p + vec3(x+0.01, -0.01, z) * sc, 200.0/sc), vec3(-0.0026,0.0,0) * sc, vec3(0.0026, 0., 0) * sc, 0.0025 * sc);\n    float d2 = sdCapsule(opBendXY(p + vec3(x+0.019, -0.015, z) * sc, -100.0/sc), vec3(-0.01,0.0,-0.01) * sc, vec3(0.0045, 0., 0.0) * sc, 0.0025 * sc);\n    \n    return opUnion(opUnion(d, d1), d2);\n}\n\nfloat sdEyeBrow(vec3 p, float flip, float sc)\n{\n    p.x *= flip;\n    \n    p = rotate(p, M_PI * -0.0225, vec3(0,0,1));\n    \n    return sdRoundBox(p + vec3(0.03, -0.14,-0.125) * sc, vec3(0.015,0.0025,0.1) * sc, 0.0001);\n}\n\nvec2 sdBoze(vec3 p, float sc)\n{    \n    vec2 result = vec2(0.);\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0) * sc, vec3(0, 0.11, 0) * sc, 0.125 * sc);\n    \n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0) * sc, 0.095 * sc, 0.05 * sc, 0.0);\n    \n    d = opSmoothUnion(d, d1, 0.1 * sc);\n    \n    // ear\n    float d2 = sdEar(p, 1.0, sc);\n    d = opUnion(d, d2);\n    float d3 = sdEar(p, -1.0, sc);\n    d = opUnion(d, d3);\n\n    vec2 head = vec2(d, MAT_FACE);\n\n\t// eye\n    float d4 = sdCapsule(p, vec3(EYE_SPACE, 0.06, 0.125) * sc, vec3( EYE_SPACE, 0.08, 0.125) * sc, 0.0175 * sc);\n    float d5 = sdCapsule(p, vec3(-EYE_SPACE,0.06, 0.125) * sc, vec3(-EYE_SPACE, 0.08, 0.125) * sc, 0.0175 * sc);\n    vec2 eye = vec2(opUnion(d4, d5), MAT_BLACK);\n    \n    // mouse\n    float d6 = sdMouse(p, sc);\n    vec2 mouse = vec2(d6, MAT_BROW);\n    \n    // cheep\n    float d7 = sdCheep(p, 1.0, sc);\n    float d8 = sdCheep(p, -1.0, sc);\n    vec2 cheep = vec2(opUnion(d7, d8), MAT_CHEEP);\n\n    // eyebrows\n    float d9 = sdEyeBrow(p, 1.0, sc);\n    float d10 = sdEyeBrow(p, -1.0, sc);\n    eye.x = opUnion(eye.x, opUnion(d9, d10));\n    \n    mouse = opU(eye, mouse);\n    result = opS(mouse, head);\n    result = opU(cheep, result);\n    \n    \n    return result;\n}\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// End of Mikka Boze\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nvec2 map(vec3 p)\n{\n\tvec2 result = vec2(1.);\n    \n    p = rotate(p, M_PI, vec3(0,1,0));\n    float timeSpeed = iTime * 1.0 * M_PI2;\n    \n    vec3 q = p;\n    //q.x = mod(p.x+1.0,2.0)-1.0;\n    //q.z = mod(p.z+1.0,2.0)-1.0;\n    q.xz = opRep2D(q.xz, vec2(1.0));\n\n    vec3 q2 = q;\n    vec2 index = floor(p.xz + 0.5);\n    float angle = mod(index.y + index.x + timeSpeed, 7.0) *  (M_PI2 / 7.0);\n    q.xy += vec2(cos(angle)*0.075, sin(angle)*0.05);\n    result = sdBoze(q, 1.0);\n\n    vec2 body = vec2(sdEllipsoid(q2 + vec3(0.,0.2,0.025), vec3(0.2, 0.175, 0.15)), MAT_FACE);\n    \n    result = opSU(body, result, 0.025);\n    \n    // background\n    vec2 bg = vec2(sdPlane(p + vec3(0., 0.2, 0.), vec4(0,1,0,0)), MAT_BG);\n    result = opU(bg, result);\n    \n    //// Background\n    //float y = fract(8.0 + timeSpeed);\n    //vec3 q = opRep(p + vec3(0., timeSpeed, 0.), vec3(1,1,1));\n    //float l = sdRoundBox(q, vec3(0.75), 0.0);\n    //float l2 = sdCylinder(p, vec3(0.,0.,2.25));\n    //float l3 = sdCylinder(p, vec3(0.,0.,0.125));\n    //vec2 br = vec2(max(-l,l2), MAT_BG);\n    //vec2 br = vec2(min(max(-l2, l), l3), MAT_BG);\n    //vec2 br = vec2(l2, MAT_BG);\n    //vec2 br = vec2(l, MAT_BG);\n    \n    //result = opU(br, result);\n    \n    return result;\n}\n\nvec3 norm(vec3 p)\n{\n    vec2 e=vec2(.001,.0);\n    return normalize(.000001+map(p).x-vec3(map(p-e.xyy).x,map(p-e.yxy).x,map(p-e.yyx).x));\n}\n\nvec3 fresnelSchlick_roughness(vec3 F0, float cosTheta, float roughness) {\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n// Unreal Engine Ambient BRDF Approx\n// https://www.unrealengine.com/en-US/blog/physically-based-shading-on-mobile?lang=en-US\nvec3 EnvBRDFApprox( vec3 SpecularColor, float Roughness, float NoV )\n{\n\tconst vec4 c0 = vec4( -1, -0.0275, -0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, -0.04 );\n\tvec4 r = Roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn SpecularColor * AB.x + AB.y;\n}\n\nvec3 calcAmbient(vec3 pos, vec3 albedo, float metalness, float roughness, vec3 N, vec3 V, float t)\n{\n\tvec3 F0 = mix(vec3(0.04), albedo, metalness);\n    vec3 F  = fresnelSchlick_roughness(F0, max(0.0, dot(N, V)), roughness);\n    vec3 kd = mix(vec3(1.0) - F, vec3(0.0), metalness);\n    \n\tfloat aoRange = t/20.0;\n\tfloat occlusion = max( 0.0, 1.0 - map( pos + N*aoRange ).x/aoRange );\n\tocclusion = min(exp2( -.8 * pow(occlusion, 2.0) ), 1.0);\n    \n    vec3 ambientColor = vec3(0.5);\n    \n    vec3 diffuseAmbient = kd * albedo * ambientColor * min(1.0, 0.75+0.5*N.y) * 3.0;\n    vec3 R = reflect(-V, N);\n    \n    vec3 col = mix(vec3(0.5) * pow( 1.0-max(-R.y,0.0), 4.0), ambientColor, pow(roughness, 0.5));\n    vec3 ref = EnvBRDFApprox(F0, roughness, max(dot(N, V), 0.0));\n    vec3 specularAmbient = col * ref;\n\n    diffuseAmbient *= occlusion;\n    return vec3(diffuseAmbient + specularAmbient);\n}\n\n///////////////////////////////////////////////////////////////////////\n#define MAX_MARCH 100\n\nvec3 materialize(vec3 p, vec3 ray, float depth, vec2 mat)\n{\n    vec3 col = vec3(0.0);\n    vec3 nor = norm(p);\n    float t = iTime;\n    vec3 sky = min(sinebow(fract(t * 2.5 + 0.5)) * vec3(0.35) + vec3(0.3) + pow(max(1.29 - p.y, 0.), 5.), 1.);\n    if(p.y >= 0.29) {\n    \tcol = sky;\n    } else {\n        if(mat.y > 0.0){\n            vec2 index = floor(p.xz + 0.5);\n\n            float roughness, metalness;\n            if(mat.y == MAT_BLACK) {\n                col = vec3(0.0, 0.0, 0.0);\n                roughness = 0.8;\n                metalness = 0.0;\n            } else if(mat.y == MAT_FACE) {\n                //col = vec3(1.0, 0.8, 0.6);\n                col = min(sinebow(fract(rand(vec2(index.x, index.y) * 32.) + t * 0.5)) + vec3(0.2), 1.);\n                roughness = 0.8;\n                metalness = 0.0;\n            } else if(mat.y == MAT_BROW) {\n                col = vec3(1.0, 0, 0);\n                roughness = 0.1;\n                metalness = 0.0;\n            } else if(mat.y == MAT_CHEEP) {\n                col = vec3(1.0, 0.3, 0.5);\n                roughness = 0.1;\n                metalness = 0.0;\n            } else if(mat.y == MAT_BG) {\n                col = min(sinebow(fract((index.x + index.y) * 0.175 + t * 0.5 + 0.5)) * vec3(0.3), 1.);\n                float e = smoothstep(abs(mod(p.y + 0.25 + t * 0.5, 0.5) - 0.25), 0.0, 0.0125); \n                roughness = 0.0;\n                metalness = 0.8;\n            }\n\n            vec3 result = vec3(0.);\n            result += calcAmbient(p, col, metalness, roughness, nor, -ray, depth);\n            col = result;\n        }\n        float fog = min(1.0, (1.0 / float(MAX_MARCH)) * float(mat.x))*1.0;\n    \tvec3  fog2 = 0.0025 * vec3(1) * depth;\n    \tcol += vec3(0.1)* fog;\n    \tcol += fog2 + sky * 0.1;\n    }\n    \n    return col;\n}\n\nvec3 trace(vec3 p, vec3 ray)\n{\n    float t = 0.0;\n    vec3 pos;\n    vec2 mat;\n    \n    float planeDistance = GetIntersectLength(p, ray, vec3(0.,0.3,0.), vec3(0.,1.,0.));\n    t = planeDistance;\n    \n    int count = 0;\n    for (int i = 0; i < MAX_MARCH; i++) {\n        pos = p + ray * t;\n        mat = map(pos);\n        if (mat.x <= 0.000001) {\n        \tbreak;\n        }\n        t += mat.x * 0.5;\n        count++;\n    }\n    p = p + t * ray;\n    mat.x = float(count);\n    return materialize(p, ray, t, mat);\n}\n\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n        \n        float rotSpeed = iTime * M_PI2 * 0.1;\n        vec3 ro = vec3(cos(rotSpeed)*5.0, sin(iTime * M_PI2 * 0.4) * 0.3 + 1.0, -5.0);\n        vec3 ta = vec3(0., 0.0, 0.);\n\n        mat3 c = camera(ro, ta, 0.);\n        vec3 ray = c * normalize(vec3(p, 3.5));\n        vec3 col = trace(ro, ray);\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    fragColor = vec4(tot,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wsjfzy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wsjfzz", "name": "ShATI - Contraste", "author": "Flopine", "description": "My former school named ATI decided to launch an everyday challenge from 4th may to 24th may, here is the 9th subject: contrast :) ", "tags": ["2d", "color", "puzzle", "eschertiling"], "likes": 6, "viewed": 103, "date": "1589389382", "time_retrieved": "2024-06-20T20:09:23.645713", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n// Shader made for Everyday ATI challenge\n\n#define TAU 6.2831853071\n#define dt mod(iTime-TAU/8.,TAU)\n#define scale 0.08\n\n#define AAstep(thre, val) smoothstep(-.7,.7,(val-thre)/min(.001,fwidth(val-thre)))\n#define square(u,s) AAstep(s, max(abs(u.x),abs(u.y)))\n#define circle(u,s) AAstep(s, length(u))\n\n\nfloat piece (vec2 uv)\n{\n   \tvec2 offsetX = vec2 (scale,0.);\n    vec2 offsetXY = vec2 (scale*0.2, scale);\n    return square(uv, scale)\n        * circle(uv-offsetX,scale*0.4)\n        * circle(uv-offsetXY, scale*0.4)\n        +(1.-circle(uv+offsetX,scale*0.4))\n        +(1.-circle(uv+offsetXY,scale*0.4));\n}\n\nfloat pattern (vec2 uv)\n{return piece(uv)*piece(vec2(-uv.x,-uv.y)+vec2(-scale*2.,scale*2.));}\n\nfloat grid (vec2 uv)\n{\n    uv = mod(uv,scale*4.)-scale*2.;\n    float d = 1.;\n    for (int i=-1; i<=1; i++)\n    {\n        for(int j=-1; j<=1;j++)\n        {\n            vec2 offset = vec2(float(i),float(j));\n            d *= pattern(uv+offset*(scale*4.));\n        }\n    }  \n    return clamp(d,0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy);\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 centered_uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n \tvec3 col = mix(vec3(1.,0.,.5),vec3(.95),grid(uv));\n    \n    float mask = piece(centered_uv*sin(length(centered_uv*0.7)-dt)*0.2);\n    col = mix(col, 1.-col, clamp(mask,0.,1.));\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wsjfzz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsjyRV", "name": "Noise - cis461", "author": "sharond106", "description": "Noise and uv mapping", "tags": ["noise"], "likes": 1, "viewed": 63, "date": "1588872867", "time_retrieved": "2024-06-20T20:09:25.288238", "image_code": "const float FOVY = 0.25 * 3.141569;\nconst int RAY_STEPS = 256;\n#define BACK_WALL_SDF sdfPlane(pos, BACK_WALL_INVERSE_T)\n#define BACK_WALL_ID 1\n#define BACK_WALL_INVERSE_T inverseTransform(vec3(0., 5., 15.), vec3(0.), vec3(40., 40., 1.))\n#define FLOOR_SDF sdfPlane(pos, FLOOR_INVERSE_T)\n#define FLOOR_ID 2\n#define FLOOR_INVERSE_T inverseTransform(vec3(0., -4.95, 0.), vec3(90., 0., 0.), vec3(40., 40., 1.))\n\n#define TALL_CUBE_SDF sdfBox(pos, vec3(5., 7, 3), TALL_CUBE_INVERSE_T)\n#define TALL_CUBE_ID 3\n#define TALL_CUBE_INVERSE_T inverseTransform(vec3(4, -1.5, 8), vec3(0, 35, 0), vec3(5., 7, 3))\n\n#define SPHERE_SDF sdfSphere(pos, vec3(-5, -1, 5), 3.)\n#define SPHERE_ID 5\n#define SPHERE_INVERSE_T inverseTransform(vec3(-5, -1, 5), vec3(0, 90., 0), vec3(3.))\n\nstruct Intersection {\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n};\n    \nmat4 inverseTransform(vec3 translate, vec3 rotate, vec3 scale) {\n    mat4 s;\n    // matrices indexed to columns!\n    s[0] = vec4(scale.x, 0., 0., 0.);\n    s[1] = vec4(0., scale.y, 0., 0.);\n    s[2] = vec4(0., 0., scale.z, 0.);\n\ts[3] = vec4(0., 0., 0., 1.);                                     \n                                    \n    rotate.x = radians(rotate.x);\n    rotate.y = radians(rotate.y);\n    rotate.z = radians(rotate.z);\n      \n    mat4 r_x;\n    r_x[0] = vec4(1., 0., 0., 0.);\n    r_x[1] = vec4(0., cos(rotate.x), sin(rotate.x), 0.);\n    r_x[2] = vec4(0., -sin(rotate.x), cos(rotate.x), 0.);\n    r_x[3] = vec4(0., 0., 0., 1.);\n                                    \n                                    \n    mat4 r_y;\n    r_y[0] = vec4(cos(rotate.y), 0., -sin(rotate.y), 0.);\n    r_y[1] = vec4(0., 1, 0., 0.);\n    r_y[2] = vec4(sin(rotate.y), 0., cos(rotate.y), 0.);\n    r_y[3] = vec4(0., 0., 0., 1.);\n\n    mat4 r_z;\n    r_z[0] = vec4(cos(rotate.z), sin(rotate.z), 0., 0.);\n    r_z[1] = vec4(-sin(rotate.z), cos(rotate.z), 0., 0.);\n    r_z[2] = vec4(0., 0., 1., 0.);\n    r_z[3] = vec4(0., 0., 0., 1.);\n\n    mat4 r = r_x * r_y * r_z;\n    \n    mat4 t;\n    t[0] = vec4(1., 0., 0., 0.);\n    t[1] = vec4(0., 1., 0., 0.);\n    t[2] = vec4(0., 0., 1., 0.);\n    t[3] = vec4(translate.x, translate.y, translate.z, 1.); \n    \n    return inverse(t * r * s);      \n}\n    \nfloat sdfPlane(vec3 p, mat4 inverseT) {\n    p = vec3(inverseT * vec4(p, 1.));\n    float dot = dot(p, vec3(0., 0., 1.));\n    if (abs(dot) < 0.0001) {\n        // n must be normalized\n        if (p.x >= -.5 && p.x <= 0.5 && p.y >= -0.5 && p.y <= 0.5) {\n            return 0.;  \n        }\n        return 324234.;\n    }\n    float dist = 0.f;\n    if (abs(p.x) > 0.5) {\n        dist += ((p.x - 0.5) * (p.x - 0.5));\n    }\n    if (abs(p.y) > 0.5) {\n        dist += ((p.y - 0.5) * (p.y - 0.5));\n    }\n    dist += abs(p.z) * abs(p.z);\n    return sqrt(dist);\n} \n\n// Box with side lengths b\nfloat sdfBox(vec3 p, vec3 scale, mat4 inverseT)\n{\n    p = vec3(inverseT * vec4(p, 1.));\n    vec3 q = vec3(abs(p.x), abs(p.y), abs(p.z)) - vec3(.5);\n    float d = q.x;\n    d = max(d,q.y);\n    d = max(d,q.z);\n    return d * min(min(scale.x, scale.y), scale.z);\n}\n\n\nfloat sdfSphere(vec3 p, vec3 c, float r) {\n    return distance(p, c) - r;\n}\n\nvoid sceneMap3D(vec3 pos, out float t, out int objectHit) {\n\tt = BACK_WALL_SDF;\n    objectHit = BACK_WALL_ID;\n    float t2;\n\n\tif ((t2 = FLOOR_SDF) < t) {\n        t = t2;\n        objectHit = FLOOR_ID;\n    }\n    if ((t2 = TALL_CUBE_SDF) < t) {\n        t = t2;\n        objectHit = TALL_CUBE_ID;\n    }\n     if ((t2 = SPHERE_SDF) < t) {\n        t = t2;\n        objectHit = SPHERE_ID;\n    }\n}\n\n// called by computeNormal\nfloat sceneMap3D(vec3 pos) {\n    float t;\n    int obj;\n    sceneMap3D(pos, t, obj);\n    return t;\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int objectHit) {\n    t = 0.001;\n    for (int i = 0; i < RAY_STEPS; i++) {\n        vec3 pos = origin + t * dir;\n        float min;\n        sceneMap3D(pos, min, objectHit);\n        if (min < 0.01) {\n            return;\n        }\n        t += min;\n    }\n    t = -1.;\n    objectHit = -1;\n}\n\nvec3 computeNormal(vec3 p) {\n    vec3 epsilon = vec3(0., .001, 0.);\n    return normalize(vec3(sceneMap3D(p + epsilon.yxx) - sceneMap3D(p - epsilon.yxx),\n                          sceneMap3D(p + epsilon.xyx) - sceneMap3D(p - epsilon.xyx),\n                     \t  sceneMap3D(p + epsilon.xxy) - sceneMap3D(p - epsilon.xxy)));\n}\n\nfloat noise2D( vec2 p ) {\n    return fract(sin(dot(p, vec2(127.1, 311.7))) *\n                  45964.03 / (4372. * (cos(.5 * iTime) + 3.) / 2.));\n}\n\nfloat interpNoise2D(float x, float y) {\n    int intX = int(floor(x));\n    float fractX = fract(x);\n    int intY = int(floor(y));\n    float fractY = fract(y);\n\n    float v1 = noise2D(vec2(intX, intY));\n    float v2 = noise2D(vec2(intX + 1, intY));\n    float v3 = noise2D(vec2(intX, intY + 1));\n    float v4 = noise2D(vec2(intX + 1, intY + 1));\n\n    float i1 = mix(v1, v2, fractX);\n    float i2 = mix(v3, v4, fractX);\n    return mix(i1, i2, fractY);\n}\n\n\nfloat fbm(float x, float y) {\n    float total = 0.;\n    float persistence = 0.5f;\n    float octaves = 4.;\n\n    for(float i = 1.; i <= octaves; i++) {\n        float freq = pow(2.f, i);\n        float amp = pow(persistence, i);\n\n        total += interpNoise2D(x * freq,\n                               y * freq) * amp;\n    }\n    return total;\n}\n\n\nvec2 random2 (vec2 p) {\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)),\n                          dot(p, vec2(269.5, 183.3))))\n                 * 43758.5433);\n}\n\nfloat WorleyNoise(vec2 uv) {\n    uv /= 5.;\n    vec2 uvInt = floor(uv);\n    vec2 uvFract = fract(uv);\n    float minDist = 1.0; // Minimum distance initialized to max.\n    for(int y = -1; y <= 1; ++y) {\n        for(int x = -1; x <= 1; ++x) {\n            vec2 neighbor = vec2(float(x), float(y)); // Direction in which neighbor cell lies\n            vec2 point = random2(uvInt + neighbor); // Get the Voronoi centerpoint for the neighboring cell\n            point = 0.5 + 0.5 * sin(iTime + 13.2831 * point);\n            vec2 diff = neighbor + point - uvFract; // Distance between fragment coord and neighborâs Voronoi point\n            float dist = length(diff);\n            minDist = min(minDist, dist);\n        }\n    }\n    return minDist;\n}\n\nvec3 random3( vec3 p ) {\n    return fract(sin(vec3(dot(p,vec3(127.1, 311.7, 191.999)),\n                          dot(p,vec3(269.5, 183.3, 765.54)),\n                          dot(p, vec3(420.69, 631.2,109.21))))\n                 *43758.5453);\n}\n\nfloat surflet(vec3 p, vec3 gridPoint) {\n    vec3 t2 = abs(p - gridPoint);\n    vec3 t = vec3(1.f) - 6.f * vec3(pow(t2.x, 5.),pow(t2.y, 5.), pow(t2.z, 5.)) + 15.f * vec3(pow(t2.x, 4.), pow(t2.y, 4.),pow(t2.z, 4.)) - 10.f * vec3(pow(t2.x, 3.),pow(t2.y, 3.),pow(t2.z, 3.));\n    vec3 gradient = random3(gridPoint) * 2. - vec3(1) * (sin(2. * iTime) + 1.);\n    vec3 diff = p - gridPoint;\n    float height = dot(diff, gradient);\n    return height * t.x * t.y * t.z;\n}\n\nfloat perlinNoise(vec3 p) {\n\tfloat surfletSum = 0.f;\n\t// Iterate over the four integer corners surrounding uv\n\tfor(int dx = 0; dx <= 1; ++dx) {\n\t\tfor(int dy = 0; dy <= 1; ++dy) {\n            for(int dz = 0; dz <= 1; ++dz) {\n\t\t\t\tsurfletSum += surflet(p, floor(p) + vec3(dx, dy, dz));\n            }\n\t\t}\n\t}\n\treturn surfletSum + 0.2;\n}\n\nvec3 computeMaterial(int objectHit, vec3 p, vec3 n, vec3 lightDir, vec3 view) {\n    lightDir = normalize(lightDir - p);\n    float lambert = dot(n, lightDir);\n    vec3 color = vec3(1);\n    \n    switch (objectHit) {\n        case SPHERE_ID:\n        p = vec3(SPHERE_INVERSE_T * vec4(p, 1.));        \n\n        vec3 n = p;\n\t\tfloat u = atan(n.x, n.z) / (2.*3.1415926535897932384626433832795) + 0.5;\n\t\tfloat v = 0.5 - asin(n.y)/3.1415926535897932384626433832795;\n               \n        float f = fbm(u * 20., v * 20.);\n        \n        color = vec3(1) * f;\n        vec3 a = vec3(-0.642, 0.608, 0.608);\n   \t\tvec3 b = vec3(0.588, -0.342, 0.048);\n        vec3 c = vec3(f, f, f);\n    \tvec3 d = vec3(f*f, f*f, f*f);\n        vec3 color1 = a + b * cos(2. * 3.1415926535897932384626433832795 *\n                                 (c  + d));\n        vec3 color2 = c + d * cos(2. * 3.1415926535897932384626433832795 *\n                                 (a  + b));\n        color = mix(color2, color1, (cos(.5 * iTime) + 1.) / 2.) * 1.5;                \n        break;\n        \n        case FLOOR_ID:\n        \n        color = vec3(.8, 1, .7);\n        \n        break;\n        \n        case TALL_CUBE_ID:\n        float perlin = perlinNoise(p);\n        \n        a = vec3(1.000, 0.500, 0.500);\n\t\tb = vec3(0.5);\n\t\td = vec3(0.750, 1.000, 0.667);\n\t\tc = vec3(0.800, 1.000, 0.333);\n        \n        vec3 perlinColor = a + b * cos(6.28 * (perlin * 2. * c + d));\n        color = vec3(1) * perlinColor;\n        \n        break;\n        \n        case BACK_WALL_ID:\n        vec3 uvec = vec3(1, 0, 0);\n        vec3 vvec = vec3(0, 1, 0);\n        u = dot(uvec, p);\n        v = dot(vvec, p);\n        \n        float t = WorleyNoise(vec2(u, v));\n        a = vec3(0.5, 0.5, 0.5);\n\t\tb = vec3(0.5, 0.5, 0.5);\n\t\td = vec3(1.);\n\t\tc = vec3(0.3, 0.2, 0.2);\n        vec3 worleyColor = a + b * cos(6.28 * (t * c + d));\n        \n        color = vec3(1) * worleyColor;\n        break;\n    }\n    return color * lambert;\n}\n\nIntersection sdf3D(vec3 eye, vec3 dir) {\n    float t;\n    int objectHit;\n    march(eye, dir, t, objectHit);\n    vec3 isect = eye + t * dir;\n    \n    vec3 nor = computeNormal(isect);\n    \n    vec3 lightDir = vec3(3, 7, -4);\n    \n    vec3 color = computeMaterial(objectHit, isect, nor, lightDir, normalize(eye - isect));\n    \n    if (objectHit == -1) {\n        color = vec3(0, 0, 0);\n    }\n    \n    return Intersection(t, color, isect, objectHit);\n}\n\nvec3 rayCast(vec3 eye, vec3 ref, vec2 ndc) {\n    vec3 F = ref - eye;\n    vec3 R = normalize(cross(F, vec3(0., 1., 0.)));\n    vec3 U = normalize(cross(R, F));\n    \n    vec3 V = U * length(F) * tan(FOVY * 0.5);\n    vec3 H = R * length(F) * tan(FOVY * 0.5) * float(iResolution.x) / float(iResolution.y);\n    \n    vec3 p = ref + ndc.x * H + ndc.y * V;\n    \n    return normalize(p - eye);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - vec2(1, 1);\n    \n    vec3 eye = vec3(0, 3, -11);\n    vec3 ref = vec3(0, 0, 2);\n    vec3 rayDir = rayCast(eye, ref, uv); \n    \n    Intersection isect = sdf3D(eye, rayDir);\n\n    fragColor = vec4(isect.color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsjyRV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wslBDM", "name": "Day13: Cubic Bezier Patches", "author": "fluxatron", "description": "Why does it run so bad? :'(\n\nIncreasing NUM_VERTS exponentially increases compile and frame time. And it's worse on even numbers of verts...\n\nImproved perf here: https://www.shadertoy.com/view/wslBDM\n", "tags": ["bezier", "cubic"], "likes": 4, "viewed": 146, "date": "1588482039", "time_retrieved": "2024-06-20T20:09:26.767070", "image_code": "#define DIM_VERTS 3\n\n#define MAX_STEPS 50\n#define MAX_DIST 50.0\n#define SURFACE_DIST 0.005\n\n// TYPES ///////////////////////////////////////////////////////////////////////////////////////////////////\n\nstruct Tri\n{\n    vec3 a, b, c;\n};\n\nstruct Ray\n{\n    vec3 Origin;\n    vec3 Direction;\n};\n/*struct Material\n{\n    vec3 Color;\n};\n*/\nstruct Light\n{\n    vec3 Pos;\n    vec3 Color;\n    float Intensity;\n};\n    \nstruct Hit\n{\n    float Dist;\n    vec3 Color;\n};\n\nstruct BezierControl\n{\n    vec2 Vertex; // Position of vertex\n    vec2 Handle; // Vector defining handle direction and length\n};\n    \n    \n// DATA ///////////////////////////////////////////////////////////////////////////////////////////////////\n    \nconst int DIM_SEGS = DIM_VERTS-1;\n\nconst int NUM_SEGS = DIM_SEGS*DIM_SEGS;\nconst int NUM_TRIS = DIM_SEGS*DIM_SEGS*2;\nconst int NUM_VERTS = DIM_VERTS*DIM_VERTS;\n\nTri[NUM_TRIS] _tris;\nvec3[NUM_VERTS] _vertices;\n\n\n// ACES Tonemap: https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl ////////////////////////////////////\nconst mat3 ACESInputMat  = mat3(0.59719, 0.07600, 0.02840,    0.35458, 0.90834, 0.13383,    0.04823, 0.01566, 0.83777);\nconst mat3 ACESOutputMat = mat3(1.60475, -0.10208, -0.00327, -0.53108, 1.10813, -0.07276,  -0.07367, -0.00605,  1.07602);\nvec3 RRTAndODTFit(vec3 v) { return (v * (v + 0.0245786) - 0.000090537) / (v * (0.983729 * v + 0.4329510) + 0.238081); }\nvec3 ACESFitted(vec3 color) { return clamp(ACESOutputMat * RRTAndODTFit(ACESInputMat * color), 0.0, 1.0); }\n\n    \n// SHAPES ////////////////////////////////////////////////////////////////////////////////////////////////\n\n// udTriangle - https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat dot2( vec3 v ) { return dot(v,v); }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nvec2 SampleBezier(vec2 a, vec2 b, vec2 c, vec2 d, float t)\n{\n    // First degree\n    vec2 p11 = mix(a, b, t);\n    vec2 p12 = mix(b, c, t);\n    vec2 p13 = mix(c, d, t);\n\n    // Second degree\n    vec2 p21 = mix(p11, p12, t);\n    vec2 p22 = mix(p12, p13, t);\n\n    // Third degree\n    return mix(p21, p22, t);\n}\n\n\n// SCENE ///////////////////////////////////////////////////////////////////////////////////////////////////\nHit GetDist(vec3 p)\n{\n    Hit closest; // TODO try combining vec4(color, dist) and see if mix speeds up intersections\n    closest.Dist = 999999.;\n    closest.Color = vec3(1);\n    \n    float dist = 999999.;\n    \n    // Tri surface\n    {\n        const vec3 col = vec3(1);\n        for (int i = 0; i < NUM_TRIS; i++)\n        {\n            dist = udTriangle(p, _tris[i].a, _tris[i].b, _tris[i].c) - 0.01;\n            if (dist < closest.Dist)\n            {\n                closest.Dist = dist;\n                closest.Color = col;\n            }\n        }\n    }\n    \n    \n    // Vertices\n    {\n        const vec3 col = vec3(1);\n        for (int i = 0; i < NUM_VERTS; i++)\n        {\n            dist = length(p-_vertices[i]) - 0.03;\n            if (dist < closest.Dist)\n            {\n                closest.Dist = dist;\n                closest.Color = col;\n            }\n        }\n    }\n   \n    \n    // Plane\n    {\n        vec3 col = vec3(.5,.5,.5);\n        dist = p.y+0.5; // ground at y=0\n\t\tif (dist < closest.Dist)\n        {\n            closest.Dist = dist;\n            closest.Color = col;\n        }\n    }\n    \n    return closest;\n}\n\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDist(p).Dist;\n    float offset = 0.01;\n    vec3 n = d - vec3(\n        GetDist(p - vec3(offset,0,0)).Dist,\n        GetDist(p - vec3(0,offset,0)).Dist,\n        GetDist(p - vec3(0,0,offset)).Dist\n        );\n    \n    return normalize(n);\n}\n\nHit RayMarch(Ray r)\n{\n    Hit lastHit;\n    float totalDist = 0.0;\n    \n    for (int i=0; i<MAX_STEPS; i++)\n    {\n        vec3 p = r.Origin + totalDist*r.Direction;\n        lastHit = GetDist(p);\n        totalDist += lastHit.Dist;\n        \n        if (totalDist < SURFACE_DIST || totalDist > MAX_DIST) \n            break;\n    }\n    \n    lastHit.Dist = totalDist;\n    \n    return lastHit;\n}\n\nvec3 GetLight(vec3 p, Light light)\n{\n    vec3 PL = light.Pos-p;\n    float PLLen = length(PL);\n    \n    vec3 lightNormal = PL/PLLen;\n    vec3 surfNormal = GetNormal(p);\n    \n    // Light\n    float strength = clamp(dot(surfNormal, lightNormal), 0., 1.);\n    float attenuation = 1. / max(PLLen*PLLen, 0.001);\n\n    // Shadow\n    Ray shadow;\n    shadow.Origin = p + surfNormal*SURFACE_DIST*2.;\n    shadow.Direction = lightNormal;\n    if(RayMarch(shadow).Dist < PLLen) strength = 0.0;\n    \n    return light.Intensity * light.Color * strength * attenuation;\n}\n\nmat3 RotateXZ(float rad)\n{\n    float cosr = cos(rad);\n    float sinr = sin(rad);\n    return mat3(\n        cosr,  0,  sinr,\n        0,     1,  0,\n        -sinr, 0,  cosr);\n}\n\n\n// MAIN ////////////////////////////////////////////////////////////////////////////////////////////////////\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.yy; // map to center:(0, 0), topright:(aspect/2, 0.5)\n    \n    // Camera\n    Ray r;\n    r.Origin = vec3(0, 1.3, -3.1);\n    r.Direction = normalize(vec3(uv.x, uv.y-0.7, 1.5));\n    \n    \n    // Build scene\n    {\n        mat3 R = RotateXZ(iTime*0.2);\n        \n\t\tBezierControl seg1a = BezierControl(vec2(-1, 0), vec2(-.3,-0.7) + vec2(0, 0.2*sin(iTime+1.))); \n        BezierControl seg1b = BezierControl(vec2(1,  0), vec2(.3, -.3) + vec2(0, 0.2*cos(iTime+1.)));\n        \n        BezierControl seg2a = BezierControl(vec2(-1, 0), vec2(-.5,-.2) + vec2(0, 0.2*sin(iTime))); \n        BezierControl seg2b = BezierControl(vec2(1,  0), vec2(.5, -.2) + vec2(0, 0.2*cos(iTime)));\n        \n        // Verts\n        int index = 0;\n        for (int z = 0; z < DIM_VERTS; z++)\n        {\n            float v = float(z)/float(DIM_VERTS-1);\n\t\t\tv = v*2. - 1.; // transform to [-1,1]\n            \n            for (int x = 0; x < DIM_VERTS; x++)\n            {\n                float u = float(x)/float(DIM_VERTS-1);\n                vec2 u0 = SampleBezier(seg1a.Vertex, seg1a.Handle, seg1b.Handle, seg1b.Vertex, u);\n                vec2 u1 = SampleBezier(seg2a.Vertex, seg2a.Handle, seg2b.Handle, seg2b.Vertex, u);\n\n                vec2 xy = mix(u0, u1, v) + vec2(0,.35);\n \t\t\t\t_vertices[index++] = R*vec3(xy, v);\n            }\n        }\n        \n        // Tris\n        {\n\t\t\tfor (int i = 0; i < NUM_TRIS; i+=2)\n            {\n                //int i = 1;\n                int baseIndex = i/2;\n                int base = (baseIndex/DIM_SEGS)*DIM_VERTS + baseIndex%DIM_SEGS;\n                vec3 a = _vertices[base];\n                vec3 b = _vertices[base + 1];\n                vec3 c = _vertices[base + DIM_VERTS + 1];\n                vec3 d = _vertices[base + DIM_VERTS];\n\n                _tris[i] = Tri(a,b,c);\n                _tris[i+1] = Tri(c,d,a);\n            }\n        }\n    }\n   \n    \n    // Hit scene\n    Hit hit = RayMarch(r);\n    vec3 p = r.Origin + r.Direction*hit.Dist; // intersection point\n    \n    \n    // Direct Light\n    vec3 directLight = vec3(0);\n    {\n        Light l1;\n        l1.Pos = vec3(0, 2, 0) + 5.0;// * vec3(0.5*sin(iTime), 1.0, 0.5*cos(iTime));\n        l1.Color = vec3(1.0,0.5,0.4);\n        l1.Intensity = 50.0;\n\n        /*Light l2;\n        l2.Pos = vec3(5, 5, -5);\n        l2.Color = vec3(1.0,0.7,0.5);\n        l2.Intensity = 0.5;*/\n\n        directLight += hit.Color * GetLight(p, l1);\n    \t//directLight += GetLight(p, l2);\n    }\n    \n    \n    // Ambient Light\n    vec3 ambient = hit.Color * 0.8*vec3(0.02,0.02,0.08);\n    \n    \n    // Compose colour\n    vec3 col = ambient + vec3(directLight);\n    \n    \n    // Post\n    col *= 1.0; // exposure bias\n  \tcol = ACESFitted(col); // tonemap \n   \tcol = pow(col, vec3(1.0/2.2)); // gamma\n\n    \n\tfragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wslBDM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wslBRf", "name": "Flickering plaid", "author": "jarble", "description": "I modifed one of my fractals to make this \"plaid\" animation.", "tags": ["plaid"], "likes": 0, "viewed": 177, "date": "1588794958", "time_retrieved": "2024-06-20T20:09:26.894357", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord)/iResolution.xy;\n    // Time varying pixel color\n    vec2 col = (uv.yx*10.0);\n    for(float i = 1.0; i <5.0; i++){\n        uv += col.yx;\n        col.xy = cos(uv.yx*i+iTime);\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wslBRf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WslBRS", "name": "Polarised Blip", "author": "chernomord", "description": "A figure drawn with polar coordinates got twisted and transformed differently for each color channel", "tags": ["sdf", "polarcoordinates", "chromaticshift"], "likes": 2, "viewed": 107, "date": "1588515357", "time_retrieved": "2024-06-20T20:09:26.894357", "image_code": "void remap(inout vec2 st) {\n  st = st/.5 - 1.;\n}\n\nvoid proportion(inout vec2 st) {\n  st.x *= iResolution.x/iResolution.y;\n}\n\n\nvec2 polar(in vec2 pos, in vec2 uv) {\n    vec2 dist = pos - uv;\n    return vec2(atan(dist.y,dist.x)+iTime/4., dot(dist,dist)*4.);\n}\n\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0,\n                0.0,_scale.y);\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    // uv = fract((uv)*3.);\n    remap(uv);\n    proportion(uv);\n\n    uv *= rotate2d(sin(iTime*2.));\n    uv *= scale(vec2((sin(iTime)+3.5)/3.));\n\n    vec2 pos = vec2(0.0);\n\n    vec2 uv_r = uv * scale(vec2(.5,(sin(iTime)+2.)*3.));\n    vec2 uv_b = uv + vec2(cos(iTime*4.)*2.,.0) /4.;\n    \n    vec2 p_ar = polar(pos, uv);\n    \n    vec2 p_ar_r = polar(pos, uv_r);\n    vec2 p_ar_b = polar(pos, uv_b);\n    float f = cos(p_ar[1]*8.0)/6. +.5;\n    float f_r = cos(p_ar_r[0]*8.0)/6. +.5;\n    float f_b = cos(p_ar_b[0]*8.0)/6. +.5;\n    vec3 color = vec3( \n        smoothstep(f,f+0.2,p_ar_r[1]),\n        smoothstep(f,f+0.024,p_ar[1]*(sin(iTime*5.)+2.)/4.+(sin(iTime*5.)+2.)/4.),\n        smoothstep(f,f+0.1,p_ar_b[1]) \n        );\n\n    fragColor = vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WslBRS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WslBWB", "name": "menger-sponge-va-004", "author": "jorge2017a1", "description": "menger-sponge-va-004", "tags": ["mengerspongeva004"], "likes": 4, "viewed": 73, "date": "1588987330", "time_retrieved": "2024-06-20T20:09:26.894357", "image_code": "//modificado por jorge flores.p --\n//Gracias a ....Created by russ in 2017-03-06\n//https://www.shadertoy.com/view/XsfczB\n    \n\nconst int iter =100;\nconst float eps = 0.001, far = 20.;\nvec3 lDir0 = normalize(vec3(1,2,1)), lDir1 = normalize(vec3(-1,1.0,-2));\nvec3 lCol0 = vec3(1,.8,.5), lCol1 = vec3(.6,0.8,1); \n\n\n#define PI 3.1415926\n\n///-------------------------------------\nconst int MAX_RAY_STEPS = 64;\nconst float RAY_STOP_TRESHOLD = 0.0001;\nconst int MENGER_ITERATIONS = 5;\n///-------------------------------------\n\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3  di = abs(p) - b;\n  float mc = maxcomp(di);\n  return min(mc,length(max(di,0.0)));\n}\n\n\nfloat cylUnion(vec3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(min(xy,min(xz,yz))) - 1.;\n}\n\nfloat cylIntersection(vec3 p){\n    float xy = dot(p.xy,p.xy);\n    float xz = dot(p.xz,p.xz);\n    float yz = dot(p.yz,p.yz);\n    return sqrt(max(xy,max(xz,yz))) - 1.;\n}\n\n\n//-------------------------------------------\n\nfloat dsSphere(vec3 center, float r, vec3 point)// basic sphere SDF\n{\n    // point is point pos in space, center is sphere's center, r is its radius\n    return length(point - center) - r;\n}\n\nfloat dsCapsule(vec3 point_a, vec3 point_b, float r, vec3 point_p)//cylinder SDF\n{\n \tvec3 ap = point_p - point_a;\n    vec3 ab = point_b - point_a;\n    float ratio = dot(ap, ab) / dot(ab , ab);\n    ratio = clamp(ratio, 0.0, 1.0);\n    vec3 point_c = point_a + ratio * ab;\n    return length(point_c - point_p) - r;\n}\n\nfloat dsTorus(vec3 center, float r1, float r2, vec3 point)\n{\n \tfloat x = length(point.xz - center.xz) - r1;\n    float y = point.y - center.y;\n    float dist = length(vec2(x,y)) - r2;\n    return dist;\n}\n//--------------------------------------------\n\n//oooooooooooooooooooooooooooooooooooooooooooooooooooo\nfloat sdCross(vec3 p) {\n\tp = abs(p);\n\tvec3 d = vec3(max(p.x, p.y),\n\t\t\t\t  max(p.y, p.z),\n\t\t\t\t  max(p.z, p.x));\n\treturn min(d.x, min(d.y, d.z)) - (1.0 / 3.0);\n}\n\nfloat sdCrossRep(vec3 p) {\n\tvec3 q = mod(p + 1.0, 2.0) - 1.0;\n\treturn sdCross(q);\n}\n\nfloat sdCrossRepScale(vec3 p, float s) {\n\treturn sdCrossRep(p * s) / s;\t\n}\n\n\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\n\n//--------------------------\nfloat DE(vec3 p) {\n\t\n    \n    float scale = 1.55;\n\t\n \n       \n    \n    float dist =sdBox(p- vec3(0.0), vec3(1.0) );\n    \n \n\tfor (int i = 0; i < MENGER_ITERATIONS; i++) {\n\t\tdist = max(dist, -sdCrossRepScale(p, scale));\n\t\tscale *= 3.0*sin(scale);\n\t}\n\n\n    \n    \n\treturn dist;\n}\n\n//oooooooooooooooooooooooooooooooooooooooooooooooooooo\n\n\n\nvec2 march(vec3 ro, vec3 rd){\n\tfloat t=0. , d = far, it = 0.;\n    for (int i=0;i<iter;i++){\n     \tt += (d = DE(ro+t*rd));\n        if(d<eps || t> far) break;\n        it += 1.;\n    }\n    return vec2(t,it/float(iter));\n}\n\nfloat getShadow(vec3 p, vec3 n, vec3 ld){\n    p +=  2. * eps * n;\n    float t=0.,d=far;\n    for(int i=0;i<50;i++){\n        t += (d=DE(p + t*ld));\n        if (d<eps || t>3.) break;\n    }\n    return t<=3. ? 0.1 : 1. ;\n}\n\nvec3 getRay(vec3 ro, vec3 look, vec2 uv){\n    vec3 f = normalize(look - ro);\n    vec3 r = normalize(vec3(f.z,0,-f.x));\n    vec3 u = cross (f,r);\n    return normalize(f + uv.x * r + uv.y * u);\n}\n\nvec3 getNorm(vec3 p){\n    vec2 e = vec2(eps, 0);\n    return normalize(vec3(DE(p+e.xyy)-DE(p-e.xyy),DE(p+e.yxy)-DE(p-e.yxy),DE(p+e.yyx)-DE(p-e.yyx)));\n}\n\nvec3 light(vec3 p, vec3 n){\n    vec3 col = vec3(0.01);\n    for(int i=0;i<2;i++){\n        vec3 ld = (i==0) ? lDir0 : lDir1;\n        float diff = max(dot(n, (ld)),0.);\n        diff *= getShadow(p, n, ld);\n        col += diff * (i==0 ? lCol0 : lCol1);\n    }\n    return col * .7;\n}\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) {\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float time = iTime * 0.5;\n    //float time = iTime * .06;\n    \n    \n\tvec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n  \n    \n    \n    //vec3 ro = vec3(0.5, 0.25, 1.5+ 1.0*cos(time)+time*1.2);\n    vec3 ro = vec3(0.5+sin(iTime), 0.25, 1.5+ 2.0*cos(time));\n     //ro = get_mouse(ro);\n   \n    \n    vec3 rd = getRay(ro, vec3(0.), uv);\n    vec2 hit = march(ro, rd);\n    vec3 p = ro + hit.x*rd;\n    \n    vec3 col = hit.x<far ? light(p, getNorm(p)) : vec3(.1*(1.-length(uv)));\n    \n    \n    col += pow(hit.y,3.);\n\tfragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WslBWB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wslBWX", "name": "gradation map effect", "author": "yasuo", "description": "effect experiment", "tags": ["gradationmap"], "likes": 2, "viewed": 213, "date": "1589206350", "time_retrieved": "2024-06-20T20:09:26.900459", "image_code": "const float Epsilon = 1e-10;\n\n// noise function from https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nvec2 fade(vec2 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\n\nfloat cnoise(vec2 P){\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod(Pi, 289.0); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n  vec4 i = permute(permute(ix) + iy);\n  vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0; // 1/41 = 0.024...\n  vec4 gy = abs(gx) - 0.5;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n  vec4 norm = 1.79284291400159 - 0.85373472095314 * \n    vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\nvec3 RGBtoHCV(vec3 RGB)\n{\n    vec4 P = (RGB.g < RGB.b) ? vec4(RGB.bg, -1.0, 2.0/3.0) : vec4(RGB.gb, 0.0, -1.0/3.0);\n    vec4 Q = (RGB.r < P.x) ? vec4(P.xyw, RGB.r) : vec4(RGB.r, P.yzx);\n    float C = Q.x - min(Q.w, Q.y);\n    float H = abs((Q.w - Q.y) / (6. * C + Epsilon) + Q.z);\n    return vec3(H, C, Q.x);\n}\n\nvec3 RGBtoHSL(vec3 RGB)\n{\n    vec3 HCV = RGBtoHCV(RGB);\n    float L = HCV.z - HCV.y * 0.5;\n    float S = HCV.y / (1. - abs(L * 2. - 1.) + Epsilon);\n    return vec3(HCV.x, S, L);\n}\n\nvec3 HUEtoRGB(float H)\n{\n    float R = abs(H * 6. - 3.) - 1.;\n    float G = 2. - abs(H * 6. - 2.);\n    float B = 2. - abs(H * 6. - 4.);\n    return clamp(vec3(R,G,B),0.,1.);\n}\n\nvec3 HSLtoRGB(vec3 HSL)\n{\n    vec3 RGB = HUEtoRGB(HSL.x);\n    float C = (1. - abs(2. * HSL.z - 1.)) * HSL.y;\n    return (RGB - 0.5) * C + HSL.z;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy*2.0-iResolution.xy)/min(iResolution.x, iResolution.y);\n\tp*=1.6;\n    vec2 prevP = p;\n\n    float t = iTime*0.1;\n    float dist = 1.0;\n    p.x+=cos(t)*dist;\n    p.y+=sin(t)*dist;\n    p*= cnoise(p*0.5);\n    float d = length(p)-0.6;\n    \n    dist = 1.3;\n    p.x-=cos(-t*1.2)*dist;\n    p.y-=sin(-t*1.2)*dist;\n    p*= cnoise(p*0.9);\n    float d2 = length(p)-0.7;\n    \n    p = prevP;\n    p.y+=iTime*0.1;\n    float n = cnoise(p*2.5)+min(d,d2);\n\t//n = min(d,d2);\n    \n    // tone curve\n    float toneval = 0.5;\n    vec3 originalCol = vec3(pow(n,toneval));\n    \n    // gradient map\n    vec3 gradientCol1 = vec3(0.7,0.3,0.6);\n    vec3 gradientCol2 = vec3(0.7,0.7, .3);\n    \n    vec3 hsl = RGBtoHSL(originalCol);\n    \n    float r = gradientCol1.r+(gradientCol2.r-gradientCol1.r)*hsl.z;\n    float g = gradientCol1.g+(gradientCol2.g-gradientCol1.g)*hsl.z;\n    float b = gradientCol1.b+(gradientCol2.b-gradientCol1.b)*hsl.z;\n    \n    vec3 gradientMapResult = RGBtoHSL(vec3(r,g,b));\n    \n    // hue\n    float hueVal = 0.02;\n    gradientMapResult.x+=hueVal;\n    \n    // brightness\n    float brightness = 0.5;\n    \n    vec3 resRGB = HSLtoRGB(gradientMapResult)*brightness;\n    \n    float threthold =  0.21;\n    fragColor = vec4(vec3(step(resRGB.r,threthold),step(resRGB.g,threthold),step(resRGB.b,threthold)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wslBWX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wslBz2", "name": "MerciJC", "author": "arthursw", "description": "Merci Jean-Come !", "tags": ["merci"], "likes": 1, "viewed": 76, "date": "1588684357", "time_retrieved": "2024-06-20T20:09:26.900459", "image_code": "#define PI 3.1415926535897932384626433\n\n\nbool line(ivec2 n, int x1, int x2, int x3, int y) {\n\treturn ((n.x==0 && x1==1)||\n            (n.x==1 && x2==1)||\n            (n.x==2 && x3==1)) && n.y==y;\n}\n\nbool G(ivec2 np, int x, int y)\n{\n    ivec2 n = np + ivec2(x, y);\n\treturn  line(n, 1, 1, 1, 4)   ||\n\t\t\tline(n, 1, 0, 0, 3) ||\n\t\t\tline(n, 1, 0, 1, 2)  ||\n\t\t\tline(n, 1, 0, 1, 1)  ||\n\t\t\tline(n, 1, 1, 1, 0);\n}\n\nbool O(ivec2 np, int x, int y)\n{\n    ivec2 n = np + ivec2(x, y);\n\treturn  line(n, 1, 1, 1, 4)   ||\n\t\t\tline(n, 1, 0, 1, 3) ||\n\t\t\tline(n, 1, 0, 1, 2)  ||\n\t\t\tline(n, 1, 0, 1, 1)  ||\n\t\t\tline(n, 1, 1, 1, 0);\n}\n\nbool D(ivec2 np, int x, int y)\n{\n    ivec2 n = np + ivec2(x, y);\n\treturn  line(n, 1, 1, 0, 4)   ||\n\t\t\tline(n, 1, 0, 1, 3) ||\n\t\t\tline(n, 1, 0, 1, 2)  ||\n\t\t\tline(n, 1, 0, 1, 1)  ||\n\t\t\tline(n, 1, 1, 0, 0);\n}\n\nbool M(ivec2 np, int x, int y)\n{\n    ivec2 n = np + ivec2(x, y);\n\treturn  line(n, 1, 0, 1, 4)   ||\n\t\t\tline(n, 1, 1, 1, 3) ||\n\t\t\tline(n, 1, 0, 1, 2)  ||\n\t\t\tline(n, 1, 0, 1, 1)  ||\n\t\t\tline(n, 1, 0, 1, 0);\n}\n\nbool R(ivec2 np, int x, int y)\n{\n    ivec2 n = np + ivec2(x, y);\n\treturn  line(n, 1, 1, 0, 4)   ||\n\t\t\tline(n, 1, 0, 1, 3) ||\n\t\t\tline(n, 1, 1, 0, 2)  ||\n\t\t\tline(n, 1, 0, 1, 1)  ||\n\t\t\tline(n, 1, 0, 1, 0);\n}\n\nbool N(ivec2 np, int x, int y)\n{\n    ivec2 n = np + ivec2(x, y);\n\treturn  line(n, 1, 1, 1, 4)   ||\n\t\t\tline(n, 1, 0, 1, 3) ||\n\t\t\tline(n, 1, 0, 1, 2)  ||\n\t\t\tline(n, 1, 0, 1, 1)  ||\n\t\t\tline(n, 1, 0, 1, 0);\n}\n\nbool I(ivec2 np, int x, int y)\n{\n    ivec2 n = np + ivec2(x, y);\n\treturn  line(n, 1, 1, 1, 4)   ||\n\t\t\tline(n, 0, 1, 0, 3) ||\n\t\t\tline(n, 0, 1, 0, 2)  ||\n\t\t\tline(n, 0, 1, 0, 1)  ||\n\t\t\tline(n, 1, 1, 1, 0);\n}\n\nbool E(ivec2 np, int x, int y)\n{\n    ivec2 n = np + ivec2(x, y);\n\treturn  line(n, 1, 1, 1, 4)   ||\n\t\t\tline(n, 1, 0, 0, 3) ||\n\t\t\tline(n, 1, 1, 1, 2)  ||\n\t\t\tline(n, 1, 0, 0, 1)  ||\n\t\t\tline(n, 1, 1, 1, 0);\n}\n\nbool P(ivec2 np, int x, int y)\n{\n    ivec2 n = np + ivec2(x, y);\n\treturn  line(n, 1, 1, 1, 4)   ||\n\t\t\tline(n, 1, 0, 1, 3) ||\n\t\t\tline(n, 1, 1, 1, 2)  ||\n\t\t\tline(n, 1, 0, 0, 1)  ||\n\t\t\tline(n, 1, 0, 0, 0);\n}\n\nbool C(ivec2 np, int x, int y)\n{\n    ivec2 n = np + ivec2(x, y);\n\treturn  line(n, 1, 1, 1, 4)   ||\n\t\t\tline(n, 1, 0, 0, 3) ||\n\t\t\tline(n, 1, 0, 0, 2)  ||\n\t\t\tline(n, 1, 0, 0, 1)  ||\n\t\t\tline(n, 1, 1, 1, 0);\n}\n\nbool J(ivec2 np, int x, int y)\n{\n    ivec2 n = np + ivec2(x, y);\n\treturn  line(n, 1, 1, 1, 4)   ||\n\t\t\tline(n, 0, 1, 0, 3) ||\n\t\t\tline(n, 0, 1, 0, 2)  ||\n\t\t\tline(n, 0, 1, 0, 1)  ||\n\t\t\tline(n, 1, 1, 0, 0);\n}\n\nbool A(ivec2 np, int x, int y)\n{\n    ivec2 n = np + ivec2(x, y);\n\treturn  line(n, 1, 1, 1, 4)   ||\n\t\t\tline(n, 1, 0, 1, 3) ||\n\t\t\tline(n, 1, 1, 1, 2)  ||\n\t\t\tline(n, 1, 0, 1, 1)  ||\n\t\t\tline(n, 1, 0, 1, 0);\n}\n\nbool ii(ivec2 np, int x, int y)\n{\n    ivec2 n = np + ivec2(x, y);\n\treturn  line(n, 1, 0, 1, 4)   ||\n\t\t\tline(n, 1, 0, 1, 3) ||\n\t\t\tline(n, 1, 0, 1, 2)  ||\n\t\t\tline(n, 0, 0, 0, 1)  ||\n\t\t\tline(n, 1, 0, 1, 0);\n}\n\nfloat exponentialOut(float t) {\n  return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n\nfloat easeInOutCubic(float t){\n    return t<0.5 ? 4.*t*t*t : (t - 1.)*(2.*t - 2.)*(2.*t - 2.) + 1.;\n}\n\nfloat appearDelayInOutCubic(float delay, float speed){\n\treturn iTime < delay ? 0.0 : easeInOutCubic(speed * (iTime - delay));\n}\n\nfloat appearDelayExpo(float delay, float speed) {\n\treturn iTime < delay ? 0.0 : exponentialOut(speed * (iTime - delay));\n}\n\nfloat appearDelay(float delay, float speed, float duration) {\n\treturn iTime < delay ? 0.0 : mod(speed * (iTime - delay), speed * duration);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xx;\n\n\n    p -= vec2(0.5,0.5*iResolution.y/iResolution.x);\n    \n    float t = iTime;\n    \n    float angle = appearDelayExpo(4., 0.5) * PI;\n\t\n    mat2 rotationMatrix = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n\tp *= rotationMatrix;\n    \n    p *= - 40.0 + 80.*appearDelayExpo(0., 0.25) + -80.*appearDelayExpo(2.5, 0.25);// * p.y;\n\n\t//p *= sin(7.0*t)*0.001+40.0;\n//\tp.x -= 10.5;\n\tvec2 n = floor(p);\n\tvec2 f = fract(p);\n\t\n\tfloat dist = 0.0;\n\t\n\t\n\tdist = sqrt(1.0/dot(p-(n+0.5), p-(n+0.5)));\n\t\n\tn.x += 8.00;\n\tn.y += 2.00;\n    \n\tivec2 ni = ivec2(n.x, n.y-6.0);\n\t\n\tfloat scale = 0.35;\n\t\n\tif(sin(t*4.0)>0.0)\n\t{\n\t\tdist *= scale;\n\t\tscale = 1.0/scale;\n\t}\n\tfloat delay = 0.75;\n\tfloat speed = 1.0;\n\tfloat offset = 52.0;\n\tfloat dist2 = 50.0;\n\tivec2 ni1 = ni + ivec2(offset - dist2 * appearDelayExpo(delay + 0.5, speed), 0);\n\t// if( G(ni1, 0, 0) || O(ni1, -4, 0) || O(ni1, -8, 0) || D(ni1, -12, 0) )\n\tif( M(ni1, 0, 0) || E(ni1, -4, 0) || R(ni1, -8, 0) || C(ni1, -12, 0) || I(ni1, -16, 0) )\n\t\tdist *= scale;\n\tni += ivec2(2, 6);\n\tivec2 ni2 = ni + ivec2(-offset + dist2 * appearDelayExpo(delay + 0.75, speed), 0);\n\tif( J(ni2, 0, 0) || E(ni2, -4, 0) || A(ni2, -8, 0) || N(ni2, -12, 0) )\n\t\tdist *= scale;\n\tni += ivec2(4, 6);\n\tivec2 ni3 = ni + ivec2(offset - dist2 * appearDelayExpo(delay + 1.0, speed), 0);\n\tif( C(ni3, 0, 0) || O(ni3, -4, 0) || M(ni3, -8, 0) || E(ni3, -12, 0) || ii(ni3, -16, 0) || ii(ni3, -20, 0) || ii(ni3, -24, 0) || ii(ni3, -28, 0) )\n\t\tdist *= scale;\n\t\n\tvec3 c1 = vec3(0.25,0.33,0.4);\n\tvec3 c2 = vec3(0.525,0.2633,0.24);\n\tvec3 c=c1;\n\tif(mod(t,1.0)>0.5)\n\t\tc = c2;\n\tfragColor = vec4(c*dist,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wslBz2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WslBzX", "name": "test for fun", "author": "linkwwj", "description": "test for fun", "tags": ["2d"], "likes": 0, "viewed": 43, "date": "1589015852", "time_retrieved": "2024-06-20T20:09:26.900459", "image_code": "//sdf\nfloat distance_from_sphere(in vec3 curPos, in vec3 sphereOri, in float r){\n\treturn length(curPos-sphereOri)-r;\n} \n\nfloat map_the_world(in vec3 p){\n    float displacement = sin(sin(iTime)*5.0 * p.x) * sin(sin(iTime)*5.0 * p.y) * sin(sin(iTime)*5.0 * p.z) * 0.25;\n\tfloat sphere_0 = distance_from_sphere(p,vec3(0.0), 1.0);\n    return sphere_0+displacement;\n}\n\nvec3 calc_normal(vec3 p){\n\n\tconst vec3 SMALL_STEP = vec3(0.001, 0.0, 0.0);\n        \n    float gradient_x = map_the_world(p+SMALL_STEP.xyy)-map_the_world(p-SMALL_STEP.xyy);\n    float gradient_y = map_the_world(p+SMALL_STEP.yxy)-map_the_world(p-SMALL_STEP.yxy);\n    float gradient_z = map_the_world(p+SMALL_STEP.yyx)-map_the_world(p-SMALL_STEP.yyx);\n    \n    vec3 normal = vec3(gradient_x,gradient_y,gradient_z);\n    \n    return normalize(normal);\n        \n\t\n}\n\n//ray march\nvec3 ray_march(in vec3 ro, in vec3 rd ){\n\t\n    float total_distance_marched = .0;\n    const int MAX_STEP = 32;\n    const float MIN_HIT_DISTANCE = 0.001;\n    const float MAX_MARCH_Distance = 1000.0;\n    \n    \n    for(int i=0;i<MAX_STEP;i++){\n    \t\n        vec3 currentPos = ro+rd*total_distance_marched;\n        float dist = map_the_world(currentPos);\n        //hit\n        if(dist < MIN_HIT_DISTANCE){\n            //shader\n        \tvec3 normal = calc_normal(currentPos);\n            vec3 lightPos = vec3(3.0,-5.0,3.0);\n            vec3 dir_to_light = normalize(-lightPos +currentPos);\n            \n            float diffuse = max(0.0, dot(normal, dir_to_light));\n            \n            return vec3(1.0,0.0,0.0)*diffuse;\n        }\n        total_distance_marched += dist;\n        //not hit\n        if(total_distance_marched > MAX_MARCH_Distance){\n        \tbreak;\n            \n        }\n        \n        \n    }\n    //return black\n    return vec3(.0);\n   \n    \n}\n\n\n\nfloat circle(in vec2 uv, in vec2 pos, in float r)\n{\n\tfloat d= length(uv-pos);\n    if(d<r)d = 1.0;\n    else d= 0.0;\n    return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //set uv to [-0.5, 0.5] origin as (0, 0)\n    uv-=0.5;\n    //ratio\n    uv.x *= iResolution.x/iResolution.y;\n   \n    \n    //set camera\n    vec3 cameraPos = vec3(.0,.0,-5.0);\n    vec3 rd = vec3(uv,1.0);\n        \n    //shader\n    vec3 shadedColor = ray_march(cameraPos, rd);\n    \n    // Output to screen\n    fragColor = vec4(shadedColor,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WslBzX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WslcRl", "name": "sdf-modelling", "author": "vizaxo", "description": "sdf-modelling", "tags": ["sdf"], "likes": 0, "viewed": 26, "date": "1590508986", "time_retrieved": "2024-06-20T20:09:26.900459", "image_code": "const int maxIters = 25;\nfloat epsilon = 0.005;\nconst int subdivisions = 2;\n\nstruct ray {\n    vec3 o;\n    vec3 d;\n};\n    \nfloat square(float x) { return x*x; }\n    \nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdBox(vec2 p, vec2 r) {\n    return length(max(abs(p) - r, 0.0));\n}\n\nfloat sdCross(vec3 p) {\n    p = abs(p) - vec3(0.0, 0.48, 0.0);\n    p.y = abs(p.y);\n    p.xz = p.x>p.z ? p.xz : p.zx;\n\treturn length(max(p - vec3(0.17, 0.015, 0.015), 0.0));\n}\n\n\nfloat delta(float k, float diff) {\n    if (diff > k) {\n        return 0.0;\n    } else {\n        return (square(diff-k))*1.0/(4.0*k);\n    }\n}\n\nfloat smax(float a, float b, float k) {\n        return max(a, b) + delta(k, abs(a-b));\n}\n\nfloat sdStick(vec3 p) {\n    float r = 0.5;\n    float line = length(vec3(p.x, max(abs(p.y)-r, 0.0), p.z));\n    return line - 0.01;\n}\n\nfloat gear(vec3 p, float angle) {\n    if (p.y > 0.0) {\n        angle += 0.5*6.28/12.0;\n    }\n    p.xz *= mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    vec2 q = p.xz;\n    \n\n    float segAngle = 6.28/12.0;\n    float segment = round(atan(p.z, p.x) / segAngle);\n    float theta = segment*segAngle;\n    mat2 rot = mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n    q = rot* q;\n    float teeth = sdBox(q - vec2(0.212, 0.0), vec2(0.04, 0.02));\n    \n    float ring = abs(length(p.xz) - 0.18) - 0.03;\n    float gear2d = min(teeth, ring);\n    float boundingSphere = abs(length(p) - 0.5) - 0.02;\n    float gear = smax(gear2d, boundingSphere, 0.005) - 0.005;\n    \n    return min(sdCross(p), min(sdStick(p), gear));\n}\n\nfloat gears(vec3 p) {\n    \n    float segAngle = 6.28/6.0;\n    float d = 1000.0;\n    for (int j = 0; j < 2; j++) {\n        vec3 p1 = p;\n        float theta = float(j)*6.28/4.0;\n        mat2 rot = mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n\t\tp1.xz *= rot;\n\n    for (int i = -1; i < 2; i++) {\n\t\tvec3 p2 = p1;\n        float theta = float(i)*segAngle;\n\n        mat2 rot = mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n\n        p2.xy *= rot;\n        float offset;\n        float segment = 6.28/12.0;\n        switch(i) {\n            case -1: offset = 0.0; break;\n            case 0: offset = segment/2.0; break;\n            case 1: offset = 0.0; break;\n            default: offset = 0.0;\n        }\n        d = min(d, gear(p2, offset + 2.0*iTime*(i % 2 == 0 ? 1.0 : -1.0)));\n    }\n    }\n    return d;\n}\n    \nfloat scene(vec3 p) {\n    float sphere = length(p) - 0.1;\n    return min(sphere, gears(p));\n}\n\nvec3 getNorm(vec3 p) {\n    return normalize(vec3(\n        scene(vec3(p + vec3(epsilon, 0, 0))) - scene(vec3(p - vec3(epsilon, 0, 0))),\n        scene(vec3(p + vec3(0, epsilon, 0))) - scene(vec3(p - vec3(0, epsilon, 0))),\n        scene(vec3(p + vec3(0, 0, epsilon))) - scene(vec3(p - vec3(0, 0, epsilon)))\n        ));\n}\n\nvec3 march(ray r) { \n    for (int i = 0; i < maxIters; i++) {\n    \tfloat d = scene(r.o);\n        if (d < epsilon) {\n            return (getNorm(r.o) + 1.0)/2.0;\n        } else {\n            r.o += r.d*d;\n        }\n    }\n    return vec3(0);\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 camPos = vec3((iMouse.x/iResolution.x-1.0)*sin(iTime), 2.0*(-iMouse.y/iResolution.y + 0.5), (iMouse.x/iResolution.x-1.0)*cos(iTime));\n    vec3 lookAt = vec3(0);\n    vec3 worldUp = vec3(0.0, 1.0, 0.0);\n    vec3 camForward = normalize(lookAt - camPos);\n    vec3 camRight = cross(camForward, worldUp);\n    vec3 camUp = cross(camRight, camForward);\n    \n    vec2 filmSize = vec2(1.0, iResolution.y/iResolution.x);\n    vec3 filmCentre = camPos + camForward*0.3;\n    \n    vec3 col = vec3(0);\n    for (int i = 0; i < subdivisions; i++) {\n        for (int j = 0; j < subdivisions; j++) {\n        \tvec2 uv;\n            uv.x = (fragCoord.x + float(i)/float(subdivisions) - 0.5)/iResolution.x - 0.5;\n            uv.y = (fragCoord.y + float(j)/float(subdivisions) - 0.5)/iResolution.y - 0.5;\n        \t\n            vec3 filmPos = filmCentre + filmSize.x*uv.x*camRight + filmSize.y*uv.y*camUp;\n    \t\tray r = ray(camPos, normalize(filmPos - camPos));    \n    \t\tcol += march(r);\n    \t}\n    }\n    fragColor = vec4(col/float(subdivisions*subdivisions), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WslcRl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WslfD7", "name": "Weird Machine That Does Nothing", "author": "blackle", "description": "made in like an hour a half on discord live with some friends. it has some texture swimming problems but I didn't want to deal with it >.<", "tags": ["sdf", "machine", "relfection"], "likes": 16, "viewed": 372, "date": "1588395626", "time_retrieved": "2024-06-20T20:09:27.652028", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//set FOCALBLUR to 1 and SAMPS to 3 for a prettier shader, but beware, it's slow!\n#define FOCALBLUR 0\n#define SAMPS 1\n\nfloat super(vec3 p) {\n    return sqrt(length(p*p));\n}\nfloat super(vec2 p) {\n    return sqrt(length(p*p));\n}\n\nfloat box(vec3 p, vec3 d) {\n    vec3 q = abs(p)-d;\n    return super(max(vec3(0),q)) + min(0., max(q.x,max(q.y,q.z)));\n}\n\nfloat fancyrings(vec3 p) {\n    p=abs(p);\n    p.xy = vec2(max(p.x,p.y),min(p.y,p.x));\n    float ring = length(vec2(super(p.xy)-1.8,p.z))-0.2;\n    float metaring = super(vec2(length(p.xz-vec2(1.8,0.))-0.5, p.y-(0.5+0.25*cos(iTime*8.))))-0.2;\n    return min(ring,metaring);\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax, p, cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat scene(vec3 p) {\n    float b = box(erot(p,vec3(0,0,1),p.z*0.5+iTime),vec3(0.25,0.25,4))-0.5;\n    float scale = 0.65;\n    p.z = (asin(sin(p.z*scale*3.14)*0.99)/3.14)/scale;\n    float ring1 = fancyrings(p+vec3(0,0,.75));\n    float ring2 = fancyrings(erot(p,vec3(0,0,1),radians(45.))-vec3(0,0,0.75));\n    return min(min(ring1,ring2),b);\n}\n\n#define FK(k) floatBitsToInt(cos(k))^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a);int y = FK(b);\n    return float((x*x-y)*(y*y+x)-x)/2.14e9;\n}\n\nfloat noise(vec2 p) {\n    vec2 id = floor(p);\n    vec2 crds = fract(p);\n    float h1 = hash(id.x,id.y);\n    float h2 = hash(id.x+1.,id.y);\n    float h3 = hash(id.x,id.y+1.);\n    float h4 = hash(id.x+1.,id.y+1.);\n    return mix(mix(h1,h2,crds.x),mix(h3,h4,crds.x),crds.y);\n}\n\nfloat triplanar(vec3 p, vec3 n) {\n    return mix(noise(p.xy), mix(noise(p.xz), noise(p.yz), n.x*n.x), 1.-n.z*n.z);\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p) - mat3(0.01);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvec3 srgb(float r, float g, float b) {\n    return vec3(r*r,g*g,b*b);\n}\nvec3 srgb(float r) {\n    return vec3(r*r);\n}\n\nfloat speed(float x) {\n    return pow(sin(fract(x)*3.14/2.),200.)+floor(x)+x*2.;\n}\n\nvec3 pixel(vec2 uv) {\n    vec3 cam = normalize(vec3(1,uv));\n    vec3 init = vec3(-6,0,0);\n    \n    float h1 = hash(hash(uv.x,uv.y),iTime*8.);\n    float h2 = hash(h1,iTime);\n    float h3 = hash(h2,iTime);\n    vec3 blur = normalize(tan(vec3(h1,h2,h3)))*float(FOCALBLUR);\n    cam+=blur*0.025;\n    init-=blur*0.1;\n    \n    float ramptime = speed(iTime*0.25);\n    float yrot = 0.2;\n    float zrot = ramptime;\n    init.x += sin(ramptime*0.5);\n    cam = erot(cam,vec3(0,1,0),yrot);\n    init = erot(init,vec3(0,1,0),yrot);\n    cam = erot(cam,vec3(0,0,1),zrot);\n    init = erot(init,vec3(0,0,1),zrot);\n    init.z += cos(ramptime);\n    \n    \n    vec3 p = init;\n    bool hit = false;\n    for (int i = 0; i < 100 && !hit; i++) {\n        float dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p+=dist*cam;\n        if (distance(p,init) > 10.) break;\n    }\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n    float marble = smoothstep(-0.5,0.4,triplanar(p*4., n));\n    float tex = max(triplanar(p*80., n),0.)*marble;\n    float spexex = mix(8., 6., tex);\n    float ao = smoothstep(-1.,1.,scene(p+r*0.3)/0.3/dot(r,n))*0.5+0.5;\n    float diff1 = ao*pow(length(sin(r*2.)*0.5+0.5)/sqrt(3.),2.);\n    float diff2 = ao*pow(length(sin(r*2.+3.5)*0.5+0.5)/sqrt(3.),2.);\n    float diff3 = ao*pow(length(sin(r*2.5+1.)*0.5+0.5)/sqrt(3.),2.);\n    vec3 col1 = mix(srgb(0.,.05,.1), srgb(0.4,.3,1.), diff1) + pow(diff1, spexex)*1.5;\n    vec3 col2 = mix(srgb(0.1,.0,0.5), srgb(1.,.2,0.5), diff2) + pow(diff2, spexex)*1.5;\n    vec3 col3 = mix(srgb(0.1), srgb(0.9,0.9,1.), diff3) + pow(diff3, spexex)*1.5;\n    vec3 col = mat3(col2,col1,col3)*transpose(mat3(col2,col1,col3))*vec3(mix(0.3,0.1,marble));\n    return hit ? col : mix(srgb(0.25), srgb(0.1), length(uv));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    vec4 col;\n    for (int i = 0; i<SAMPS;i++) {\n        for (int j = 0; j<SAMPS;j++) {\n            vec2 off= vec2(i,j)/iResolution.y/float(SAMPS);\n            col += vec4(pixel(uv+off), 1);\n        }\n    }\n    fragColor.xyz = col.xyz/col.w;\n    fragColor.xyz = sqrt(fragColor.xyz) + hash(hash(uv.x,uv.y),iTime)*0.02;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc0-1.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WslfD7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WslfDS", "name": "cuarto-escalera-v1", "author": "jorge2017a1", "description": "cuarto-escalera-v1", "tags": ["cuartoescalerav1"], "likes": 0, "viewed": 48, "date": "1588984188", "time_retrieved": "2024-06-20T20:09:30.882647", "image_code": "//por jorge2017a1-\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define PI 3.14159265358979323846264\n\n\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\nfloat tiempoA, tiempoB=0.5;\n\n///------------------------------------\nstruct TObj\n{\n    float tipo;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n};\n\n\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\n\n\n\n\nvec3 ambientColor = vec3(0.05, 0.15, 0.2);\nvec3 diffuseColor = vec3(0.2, 0.6, 0.8);\nvec3 specularColor = vec3(1.0, 1.0, 1.0);\nvec3 lightDir = normalize(vec3(0.0, 4.0, 5.0));\nvec3 spherePos = vec3(0.0, 0.5, 0.0);\n//-----------------------------------\n\n\n//vec3 light_pos   = vec3( -20.0, -20.0, -20.0 );\n//vec3 light_color = vec3( 0.3, 0.2, 1.0 );\n//vec3 light_pos   = vec3( 20.0, 20.0, 20.0 );\n//vec3 light_color = vec3( 1.0, 0.7, 0.7 );\n\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n\n\n\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); \n    float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, -sa, +.0,\n\t\t+sa, +ca, +.0,\n\t\t+.0, +.0, +1.0);\n}\n\n\n\n///-----------------------------------------\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\nvec3 LightShading(vec3 N,vec3 L,vec3 V,vec3 color)\n{\n    vec3 diffuse = max(0.,dot(N,-L))*color;\n    vec3 specular = pow(max(0.,dot(N,normalize(-L-V))),100.)*vec3(1.,1.,1.); \n    return diffuse + specular;\n}\n\n    \n    \n//-------------------------------------------------\n\n\n\n\n//0000000000000000000000000000000000000000000000000000000\n\nfloat hash( in vec2 p ) \n{\n    return fract(sin(p.x*15.32+p.y*35.78) * 43758.23);\n}\n\nvec2 hash2(vec2 p)\n{\n\treturn vec2(hash(p*.754),hash(1.5743*p.yx+4.5891))-.5;\n}\n\n\nvec2 noise2(vec2 x)\n{\n    vec2 add = vec2(1.0, 0.0);\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    return mix(mix( hash2(p),          hash2(p + add.xy),f.x),\n                    mix( hash2(p + add.yx), hash2(p + add.xx),f.x),f.y);\n    \n}\n\nmat2 rotate(float a) {\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\n//------------------------------------------\n///https://www.shadertoy.com/view/3dScRc\nfloat softmin(float f1, float f2, float val)\n{\n      float e = max(val - abs(f1 - f2), 0.0);\n      return min(f1, f2) - e*e*0.25 / val;     \n}\n///---------------------------\n\nfloat sol(vec3 p , vec3 pos )\n{\t\n    vec3 p2;\n    p2 =p;\n    //p2.yxz =p.xyz;\n    p2.xzy=p.xyz;\n    float sdc1 =sdCylinder( p2- pos, vec2(2.0,0.5) );\n    return  sdc1;\n}\n\n//----------------------------------------------------\nbool TiempoMinMax( float t, float pmin, float pmax )\n{\t\n    bool resp=false;\n    if (t>pmin && t<pmax)\n    { resp=true;\t}\n    else\n    { resp=false;\t}\n        \n    return resp;\n}\n//---------------------------------------------------\nbool espar(float valor )\n{\n   bool resp=false; \n    float vp = mod(floor(valor), 2.0) * 2. - 1.;\n    //will be -1 or 1\n    if( vp==1.0)\n    { resp=true;\t}\n    else\n    { resp=false;\t}\n      \n    return resp;\t\n}   \n\n///------------------------------------------\n\n//https://www.shadertoy.com/view/ts2cWD\n\nfloat rep(float a, float d) {\n\treturn (fract(a/d+.5)-.5)*d;\n}\n//https://www.shadertoy.com/view/ts2cWD\nvec2 rep2(vec2 a, vec2 d) {\n\treturn (fract(a/d+.5)-.5)*d;\n}\n\n//https://www.shadertoy.com/view/ts2cWD\nfloat stair(vec3 p, float size, float w, float h) \n{\n  vec3 bp=p;\n  p.xy *= rotate(PI*0.25);\n  p.x=rep(p.x,size*2.0);\n  p.xy *= rotate(PI*0.25);\n  float d=sdBox(p, vec3(size,size,w));\n  d=max(d, abs(bp.y)-h);\n  return d;\n}\n\n\n\n\n\n//-----------------------------------------------------\n\nfloat GetDist(vec3 p  ) \n{\t\n\n      float d;\n    float dif1;\n    float dif2;\n    \n    d=999.9;\n \n    \n   vec3 pp, p2;\n    pp=p;\n    p2=p;\n    \n \n    float planeDist1 = p.y+1.0;  //piso inf\n    float planeDist2 = 30.0-p.y;  //piso sup\n    float planeDist3 = p.x+30.0; //pared izq\n    float planeDist4 = 30.0-p.x;  //pared der\n    float planeDist5 = -p.z+40.0;  //pared atras\n   \n    vec2 res;\n    res = vec2(9999, 0);\n    \n    \n    bool  resp= espar(iTime);\n    if (resp)\n    { \n        float sdc1 =sdCylinder( p- vec3(-30.0,10.0,40.0), vec2(5.0,20.0) );\t\n        float sdc2 =sdCylinder( p- vec3(30.0,10.0,40.0), vec2(5.0,20.0) );\t\n        res =opU(res, vec2(sdc1,23));\n        res =opU(res, vec2(sdc2,23));\n       \n    }\n    else\n    {\n        float sdc1 =sdCylinder( p- vec3(-30.0,10.0,40.0), vec2(5.0,20.0) );\t\n        float sdc2 =sdCylinder( p- vec3(30.0,10.0,40.0), vec2(5.0,20.0) );\t\n        res =opU(res, vec2(sdc1,22));\n        res =opU(res, vec2(sdc2,22));\n       \n    }\n    \n    \n    float ssol;\n\n    resp=espar(iTime*1.5);\n    if (resp)\n     { ssol= sol(p , vec3(10.0,35.,20.0+2.0*sin(2.0*iTime)) );\t}\n    else\n    { ssol= sol(p , vec3(10.0,35.,20.0+5.0*cos(10.0*iTime)) );\t}\n    \n    \n    \n    res =opU(res, vec2(ssol,28));\n\n    float sdbInf =sdBox( p-vec3(0.0,-10.0,0.0), vec3(8.0,15.0,19.0) );\n    float  sdif3= differenceSDF( planeDist1,sdbInf);\n    \n    \n    //res =opU(res, vec2(planeDist1,2)); //inf\n    res =opU(res, vec2(sdif3,30)); //inf\n    \n    res =opU(res, vec2(planeDist2,21)); //sup\n    res =opU(res, vec2(planeDist3,21));\n    res =opU(res, vec2(planeDist4,21));\n    res =opU(res, vec2(planeDist5,21));\n   \n    \n    float st1 =stair(p.zyx-vec3(0.0,0.0,-20.0), 1.5, 5.0, 30.0) ;\n\n    \n    float st2 =stair(p.zyx-vec3(0.0,-15.0,0.0), 1.5, 6.0, 12.0);\n    res =opU(res, vec2(st1,3));\n    res =opU(res, vec2(st2,5));\n    \n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n    \n    return d;\n}\n\n\n\n///----------------------------------------------------------\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n\tfloat dO=0.2;\n    //Determines size of shadow\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = ro + rd*dO;\n        \n        float dS = GetDist(p);\n        \n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) \n        {\n            //mObj.dist=dO; \t\n            mObj.p=p; \t\n            gres2 = vec2(dO,dS); \n            break;\n    \t}    \n        \n    }\n    \n    return dO;\n}\n\n\n//---------------------------------------------------\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\nfloat GetLightPar(vec3 p, vec3 plig) {\n    vec3 lightPos = plig;\n    //Determine movement of light ex. shadow and light direction and diffusion\n    //lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat saturate(float f)\n{\n\treturn clamp(f,0.0,1.0);\n}\n\n    \n\n#define offset1 4.7\n#define offset2 4.6\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) \n{\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\n\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tif(i==0 )\n    { return vec3(0.0);    }\n    \n    if(i== 1 )\n    {  return vec3(1, 0.5, 0);    } \n    if(i== 2 )\n    { return vec3(1.0, 1.0, 1.0); } \n    if(i== 3 )\n    {  return vec3(247./255., 168./255.,  184./255.);  } \n    if(i== 4 )\n    { return vec3(0, 1, 1);} \n    if(i== 5 )\n    { return vec3(85./255., 205./255., 252./255.); } \n    if(i== 6 )\n    { return  vec3(0.5, 0.8, 0.9);} \n    if(i== 7 )\n     {return vec3(1.0, 1.0, 1.0);} \n    if(i== 8 )\n    { return vec3(0.425, 0.56, 0.9); } \n    if(i== 9 )\n    { return vec3(0.5, 0.6, 0.6);} \n    if(i== 10 )\n    { return vec3(0.0, 1.0, 0.0);} \n    if(i== 11 )\n    { return vec3(0.25, 0.25, 0.25); } \n     if(i== 15 )\n    { return vec3(1.0,0.0,1.);} \n     if(i== 16 )\n     { return vec3(1.0,1.0,0.0);} \n    \n    if(i== 21 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*0.12;\n            marbleP.z += sin(p.y*23.0)*0.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.3);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.4,0.4,0.6),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n    \n     if(i== 23)\n    { return  vec3(0.425, 0.16, 0.6);} \n    \n    if(i== 24)\n    {\n      float size = (-mObj.uv.y+.1)/2.5;\n     vec3 color = vec3(0.,0.,0.);\n     color += vec3(mod(floor(mObj.uv.x/size+sin(iTime)) + floor(mObj.uv.y*20./size+iTime),2.)-.8-mObj.uv.y);\n\n     // Lightsource falloff on floor\n     color *= vec3(smoothstep(0.,1.,1.-length(vec2(.2-mObj.uv.x/6.,.6+mObj.uv.y/1.5))));\n        return color;\n\t}    \n    \n    \n    if(i== 25)\n    {\n      float size = (-mObj.p.y+.1)/2.5;\n     vec3 color = vec3(0.,0.,0.);\n     color += vec3(mod(floor(mObj.p.x/size) + floor(mObj.p.y*20./size),2.)-.8-mObj.p.y);\n\n     // Lightsource falloff on floor\n     color *= vec3(smoothstep(0.,1.,1.-length(vec2(.2-mObj.p.x/6.,.6+mObj.p.y/1.5))));\n        return color;\n\t} \n    \n    if(i== 26)\n    {\n        // checkerboard hack\n\t\t\tvec2 cb = floor(mObj.p.xz);\n\t\t\tfloat cb2 = mod(cb.x*1.2 + cb.y, 2.);\n        \treturn vec3(1.4 + 0.1*cb2, 0.3 + 0.85*cb2, 0.35 - 0.3*cb2)*0.8;\n            \n    }   \n    \n    if(i== 27)\n    {\n      vec3 outColor = vec3(0.0);\n      float sinus1 = sin(mObj.uv.x*5.1 +iTime*0.5) * 0.1 - 0.2;\n      float land1 = step(sinus1, mObj.uv.y);\n      vec3 landColor1 = vec3(0.2, 0.4, 0.3);\n      outColor = mix(outColor, landColor1, 1.0 - land1);\n        return outColor;\n    }\n    \n    \n    if(i== 28)\n    { return vec3(0.9,0.9,0.2);  }\n    \n    if(i== 29)\n    { return vec3(1.0,1.0,1.0); }\n    \n     \n    if (i== 30)\n     {  \n        //checkboard\n        //vec3 col = vec3(0.75)*(0.3 + mod(floor(mObj.p.x) + floor(mObj.p.z), 2.0));\n        vec3 col = vec3(1.0)*(0.23 + mod(floor(mObj.p.x*0.25) + floor(mObj.p.z*0.25), 2.0));\n         return col;\n     }\n    \n}\n\n///--------------------------------------------\n\n// phong shading\nvec3 p_shadingv2( vec3 v, vec3 n, vec3 eye, vec3 plight_pos1,  vec3 plight_color1 )\n{\n\t// ...add lights here...\n\t\n\t//float shininess = 16.0;\n    float shininess = 30.0;\n\t\n\tvec3 final = vec3( 0.0 );\n\t\n\tvec3 ev = normalize( v - eye );\n\tvec3 ref_ev = reflect( ev, n );\n\t\n\t// light 0\n\t{\n\t\n\t\tvec3 vl = normalize( plight_pos1 - v );\n\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n\t\t\n\t\tfinal += plight_color1 * ( diffuse + specular ); \n\t}\n\t\n\t\n\n    return (final);\n}\n\n\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n    \n \n light_pos1   = vec3( 0.0, 10.0, 0.0 ); \n light_color1 = vec3( 1.0 );\n\n light_pos2   = vec3( 5.0, 5.0, 0.0 );\n light_color2 = vec3( 1.0, 1.0, 1.0 );\n //light_color2 = vec3( 0.65, 0.5, 1.0 );\n\n    \n\n    vec3 ro = vec3(0.0,3.0+12.0*sin(iTime*0.8),-10.0);\n\t//ro = get_mouse(ro);\n    vec3 rd = normalize( vec3(uv,1.0));\n    \n    \n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    mObj.uv=uv;\n    mObj.rd=rd;\n    mObj.ro=ro;\n\n\t \n    \n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n  \n    vec3 p = (ro + rd * d ); \n    glpRoRd=p;\n    mObj.p=p;\n    \n    float dif=0.5;\n  \n    \n    mObj.dist =d;\n    vec3 colobj;\n    colobj=getSphereColor(int( Obj.tipo));\n    \n    \n    \n \n    vec3 nor= GetNormal( p);\n    \n    \n    vec3 col2;\n    \n    if (d>0.0)\n    col2= p_shadingv2( p, nor, ro, light_pos1, light_color1 )*colobj;\n    \n    //col2+= p_shadingv2( p, nor, ro, light_pos2, light_color2 *colobj);\n    //col2=col2/2.0;\n    \n    col= col2*dif;\n    col= col2;\n    \n    col = pow(col, vec3(1.0/2.2));  \n    \n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WslfDS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wslfRB", "name": "Radial Optical Illusion", "author": "kstyler", "description": "If you stare at the image for long enough the next time you look at a wall, it (the wall) will appear to move.", "tags": ["illusion"], "likes": 4, "viewed": 243, "date": "1588551901", "time_retrieved": "2024-06-20T20:09:30.888719", "image_code": "\nmat2 rotate(float a){\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    vec2 uv = (fragCoord.xy -0.5* iResolution.xy)/iResolution.x;\n    vec2 p = uv;\n    //rotate ring\n    p*=rotate(iTime/1.);\n    \n    //create ring\n    float ang = 6.283185/90.0;\n    float sector = round(atan(p.x,p.y)/ang);\n    float an = sector*ang;\n    vec2 q = p;\n    q = rotate(an)*q;\n    \n    //duplicate ring radialy \n    float c = 0.006;\n    q.y-=iTime/10.;\n    q.y = mod(q.y+0.5*c,c)-0.5*c;\n   \n    //make circles\n    vec3 r = vec3(length(q));\n    vec3 color = smoothstep(0.0019,0.002,r);\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wslfRB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WslfRl", "name": "monoflame", "author": "ukeyshima", "description": "monoflame", "tags": ["mono"], "likes": 2, "viewed": 94, "date": "1588872141", "time_retrieved": "2024-06-20T20:09:30.888719", "image_code": "#define PI 3.141592\n\nfloat random(float p) { return fract(sin(p * 452.21) * 223.32); }\n\nvec2 random2(vec2 p) {\n  return vec2(fract(sin(dot(p, vec2(12.43, 24.12) * 452.21)) * 223.32),\n              fract(sin(dot(p, vec2(46.26, 57.84) * 681.37)) * 412.49));\n}\n\nfloat perlinNoise1d(float p) {\n  float i1 = floor(p), i2 = i1 + 1.;\n  float p1 = p - i1, p2 = p - i2;\n  float r1 = random(i1), r2 = random(i2);\n  float d1 = dot(r1, p1), d2 = dot(r2, p2);\n  float j = fract(p);\n  j = j * j * (3. - 2. * j);\n  return mix(d1, d2, j) * .5 + .5;\n}\n\nfloat perlinNoise2d(vec2 p) {\n  vec2 i1 = floor(p), i2 = i1 + vec2(1., 0.), i3 = i1 + vec2(1., 1.),\n       i4 = i1 + vec2(0., 1.);\n  vec2 p1 = p - i1, p2 = p - i2, p3 = p - i3, p4 = p - i4;\n  vec2 r1 = random2(i1), r2 = random2(i2), r3 = random2(i3), r4 = random2(i4);\n  float d1 = dot(r1, p1), d2 = dot(r2, p2), d3 = dot(r3, p3), d4 = dot(r4, p4);\n  vec2 j = fract(p);\n  j = j * j * (3. - 2. * j);\n  return mix(mix(d1, d2, j.x), mix(d4, d3, j.x), j.y);\n}\n\nfloat cellularNoise(vec2 p) {\n  vec2 ci = floor(p);\n  vec2 cf = fract(p);\n  float minDist = 1000.0;\n\n  for (int y = -1; y <= 1; y++) {\n    for (int x = -1; x <= 1; x++) {\n      vec2 neighbor = vec2(float(x), float(y));\n      vec2 neighborPoint = random2(ci + neighbor);\n      neighborPoint = 0.5 + 0.5 * sin(iTime * 3.5 + PI * 2.0 * neighborPoint);\n      vec2 diff = neighborPoint + neighbor - cf;\n      float dist = length(diff);\n      minDist = min(minDist, dist);\n    }\n  }\n  return minDist;\n}\n\nfloat moreNoise(vec2 p) { return 1.0 - 1.0 * cellularNoise(p); }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 p = fragCoord.xy / iResolution.xy;\n\n  p.x +=iTime/90.;\n\n  p.x += perlinNoise2d(p * vec2(12.2, 8.9) + vec2(iTime*0.8, 0.)) / 9.;\n  p.y += perlinNoise2d(p * vec2(9.2, 6.9) + vec2(iTime*1.1, 0.)) / 9.;\n\n  float color = smoothstep(1., 0., p.y) * 2. - 1.;\n  color += cellularNoise(p * vec2(22.,7.) - vec2(0., iTime * 2.)); \n\n  float hei = perlinNoise1d(p.x * 12.) * 4. - 1.9;\n  float color2 = smoothstep(hei, hei + 0.8, p.y) * 2. - 1.;\n  color2 += moreNoise(p * vec2(25.,16.) - vec2(0., iTime * 2.));\n\n  color = color - color2;\n  color = step(0.5, color);\n  color = 1. - color;\n\n  fragColor = vec4(vec3(color), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WslfRl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wslfzl", "name": "tube_yurka", "author": "yurka", "description": "Travel through a pipe", "tags": ["tube"], "likes": 4, "viewed": 154, "date": "1588924356", "time_retrieved": "2024-06-20T20:09:31.846324", "image_code": "#define DELTA_DISTANCE  1e-10\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat random (in float _st) {\n    return fract(sin(dot(vec2(_st, 0.0),\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat timescale = 0.5;\n\nvec3 ProjectPointOnLine(vec3 a, vec3 v, vec3 pos)\n{\n \tvec3 p = pos-a;\n\n\tfloat l_l = length(v);\n\tfloat l_p = length(p);\n\n\tif (l_l<DELTA_DISTANCE)\n\t\treturn a;\n\tif (l_p<DELTA_DISTANCE)\n\t\treturn a;\n\n\tvec3 l_u = normalize(v);\n\n\treturn a + l_u*dot(v,p)/l_l;\n}\n\nbool intersectPlaneAndLine(vec3 planePoint, vec3 planeVector, vec3 linePoint, vec3 lineVector, out vec3 p)\n{\n    float planeD = -(planeVector.x*planePoint.x + planeVector.y*planePoint.y + planeVector.z*planePoint.z);\n    p = vec3(0);\n    float temp = planeVector.x * lineVector.x + planeVector.y * lineVector.y + planeVector.z * lineVector.z;\n    if (abs(temp) < 1E-40)\n        return false;\n    float t = (-planeD - planeVector.x * linePoint.x - planeVector.y * linePoint.y - planeVector.z * linePoint.z) / temp;\n    p.x = lineVector.x * t + linePoint.x;\n    p.y = lineVector.y * t + linePoint.y;\n    p.z = lineVector.z * t + linePoint.z;\n    return true;\n}\n\nvec2 GetTotal(float atime)\n{\n    \n    vec2 dprev = vec2(random(floor(atime * timescale) - 1.0) - 0.5, random(floor(atime * timescale) - 1.0 + 0.4) - 0.5);\n    vec2 d     = vec2(random(floor(atime * timescale)) - 0.5, random(floor(atime * timescale) + 0.4) - 0.5);\n    vec2 dnext = vec2(random(floor(atime * timescale) + 1.0) - 0.5, random(floor(atime * timescale) + 1.0 + 0.4) - 0.5);\n    float prg = fract(atime * timescale);\n    //float pd = 1.0 - abs(prg - 0.5);\n    //float pdprev = max(0.0, 0.5 - prg);\n    //float pdnext = max(0.0, prg - 0.5);\n    \n    float ddd = pow(2.0*(prg - 0.5), 2.0) * 0.5;\n    float pd = 1.0 - ddd;\n    float pdprev = ddd;\n    float pdnext = ddd;\n    if (prg < 0.5)\n        pdnext = 0.0;\n    else\n        pdprev = 0.0;\n    \n    vec2 dtotal = dprev * pdprev + d * pd + dnext * pdnext;\n    return dtotal * 1.5;\n}\n\nfloat length2(vec3 v){\n        return v.x*v.x+v.y*v.y+v.z*v.z;               \n}\n\nfloat GetAngle(vec3 v1, vec3 v2)\n{\n    float cosval = dot(v1, v2) / (length(v1) * length(v2));\n    if (cosval < -1.0)\n        cosval = -1.0;\n    if (cosval > 1.0)\n        cosval = 1.0;\n    return acos(cosval);\n}\n\nvec3 RotateVectorAroundVector(vec3 axe, vec3 v, float angle)\n{\n    vec3 res;\n    float a [3 * 3];\n\n    float c = cos(angle);\n    float s = sin(angle);\n    axe = normalize(axe);\n    a[0*3+0] = c + (1.0 - c) * axe.x * axe.x;\n    a[0*3+1] = (1.0 - c) * axe.y * axe.x - s * axe.z;\n    a[0*3+2] = (1.0 - c) * axe.z * axe.x + s * axe.y;\n    a[1*3+0] = (1.0 - c) * axe.x * axe.y + s * axe.z;\n    a[1*3+1] = c + (1.0 - c) * axe.y * axe.y;\n    a[1*3+2] = (1.0 - c) * axe.z * axe.y - s * axe.x;\n    a[2*3+0] = (1.0 - c) * axe.x * axe.z - s * axe.y;\n    a[2*3+1] = (1.0 - c) * axe.y * axe.z + s * axe.x;\n    a[2*3+2] = c + (1.0 - c) * axe.z * axe.z;\n    res.x = v.x * a[0*3+0] + v.y * a[0*3+1] + v.z * a[0*3+2];\n    res.y = v.x * a[1*3+0] + v.y * a[1*3+1] + v.z * a[1*3+2];\n    res.z = v.x * a[2*3+0] + v.y * a[2*3+1] + v.z * a[2*3+2];\n    return res;\n}\n\nvec4 raymarch(vec3 ro, vec3 rd) {\n    \n    vec3 path = vec3(0, 0, 0);\n    path.y += 0.0;\n    float stp = 0.004;\n    float radius = 0.2;\n    float crT = iTime;\n    float maxdist = 0.0;\n    float maxdistT = crT;\n    vec3 maxdistProj = vec3(0);\n    vec3 maxdistProjV = vec3(0);\n    vec3 pathzd = vec3(GetTotal(iTime), 1.0);\n    vec3 forward = vec3(0, 0, 1);\n    vec3 axis = cross(pathzd, forward);\n    float angle = GetAngle(pathzd, forward);\n    for (int i = 0; i < 1000; i++) {\n        float crstp = stp * pow(2.0, (crT - iTime)*0.5);\n        crT += crstp;\n        vec3 pathd = vec3(GetTotal(crT), 1.0);\n        pathd = RotateVectorAroundVector(axis, pathd, angle);\n        //pathd.x -= pathzd.x;\n        //pathd.y -= pathzd.y;\n        path += pathd * crstp * timescale;\n        \n        //vec3 prj = ProjectPointOnLine(ro, rd, path);\n        vec3 prj;\n        \n        if (intersectPlaneAndLine(path, pathd, ro, rd, prj) && length2(path - prj) > maxdist)\n        {\n            maxdist = length2(path - prj);\n            maxdistT = crT;\n            maxdistProj = prj;\n            maxdistProjV = path - prj;\n            vec3 axis_ = cross(pathd, forward);\n            float angle_ = GetAngle(pathd, forward);\n            maxdistProjV = RotateVectorAroundVector(axis_, maxdistProjV, angle_);\n        }\n        if (maxdist > radius*radius)\n        {\n            break;\n        }\n    }\n    float freq = 5.0;\n    vec3 c = vec3(0.0, 0.0, 0.0);\n    if (maxdist > radius*radius)\n    {\n\n        float an = GetAngle(maxdistProjV, vec3(1, 0, 0));\n        vec3 c3 = vec3(\n        cos(an * 5.0) * sin(fract(maxdistT) * 3.14 * 3.0),\n        -cos(an * 5.0) * sin(fract(maxdistT) * 3.14 * 3.0),\n        abs(cos(an * 5.0) * sin(fract(maxdistT) * 3.14 * 3.0))\n    \t);\n        \n        c = (c3 ) / 1.0;\n\t\t\n    }\n    return vec4(c, 1.0);\n}\n\nvec4 raymarch_test(vec3 ro, vec3 rd) {\n    \n\n vec3 path = vec3(0, 0, 0);\n\n    vec3 c = vec3(0.0, 0.0, 0.0);\n\n    return vec4(c, 1.0);\n}\n\nmat2 rotate(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord - iResolution.xy/2.0) / iResolution.y * 2.0;\n\n    //vec4 col = vec4(vec3(dot(uv, GetTotal(iTime))), 1.0);\n    \n    vec3 ro = vec3(0, 0, 0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    //rd.yz *= rotate(3.14*0.5);\n    //ro.y += -2.8;\n    //ro.z += 1.5;\n    vec4 col = raymarch(ro, rd);\n    \n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wslfzl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsSBR1", "name": "diagonal lines //", "author": "tr0sle", "description": "diagonal lines", "tags": ["lines", "diagonal"], "likes": 0, "viewed": 101, "date": "1589470852", "time_retrieved": "2024-06-20T20:09:32.016023", "image_code": "uniform vec3 spectrum;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = .005 * fragCoord * iResolution.y/10.0;\n    vec2 uv2 = uv;\n    \n    uv.y += -uv.x + iTime*10.;\n    uv.x = mod(uv.x, 0.01);\n    \n    \n    \n    \n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsSBR1.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WssBR2", "name": "ShATI 02 : Arc-en-ciel", "author": "Melokey", "description": "ShATI 02 : Arc-en-ciel (Rainbow)", "tags": ["rainbow"], "likes": 0, "viewed": 75, "date": "1588635360", "time_retrieved": "2024-06-20T20:09:32.016023", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // - Normalize Coordinate -\n    vec2 uv = -(2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n    // - Deform Space - \n    uv.y *= 3. + cos(uv.x * 5.);\n    \n    float offset = 0.25 + (sin(iTime * 2.) + 1.) * 0.5;\n    float size = 2.;\n    \n    vec3 col = vec3(sin((offset - uv.y) * size), cos(uv.y * size), sin((uv.y + offset) * size));\n\t\n    // - Output -\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WssBR2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsSBRV", "name": "Spiral2d effect", "author": "yp3y5akh0v", "description": "Spiral effect in 2d", "tags": ["2d", "spiral", "effect"], "likes": 5, "viewed": 101, "date": "1590335971", "time_retrieved": "2024-06-20T20:09:32.016023", "image_code": "#define n 90.\n#define pi radians(180.)\n\nvec2 rot(vec2 p, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c) * p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0.);\n    float t = iTime;\n    vec2 p = uv;\n    float s = 0.;\n\n    for (float i = 0.; i < mix(0., n, 0.5 + 0.5 * sin(t)); i++) {\n        float itr = i / n;\n        vec2 q = abs(p) - mix(1.5, -0.02, itr) * itr;\n        float d = length(q);\n        s += mix(0.0001, 0.002, itr) / d;\n        p = rot(p, 0.05 * t);\n    }\n\n    col = vec3(s);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsSBRV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WssBW4", "name": "Shader7_Dela Vega", "author": "zerotojiro", "description": "Electric fan", "tags": ["midterms"], "likes": 1, "viewed": 176, "date": "1588323182", "time_retrieved": "2024-06-20T20:09:32.016023", "image_code": "float circle(vec2 uv,float radius, float blur,  vec2 pos)\n{\n    float d = distance(pos,uv);\n    float value = smoothstep(radius, radius + blur, d);\n    \n    return value; \n}\n\nfloat rect (vec2 uv, vec2 pos, vec2 size)\n{\n\tfloat value = step(pos.x - size.x/2.,uv.x) - step(pos.x + size.x/2.,uv.x);\n    return value *= step(pos.y - size.y/2.,uv.y) - step(pos.y + size.y/2.,uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tfloat ratio = iResolution.x/iResolution.y;\n    uv.x *= ratio;\n    \n    vec2 shapePos = vec2(.5 * ratio, .7);\n    vec2 barPos = vec2(.5 * ratio, .3);\n    vec2 b1Pos = vec2(.5 * ratio, .15);\n    vec2 b2Pos = vec2(.5 * ratio, .21);\n    vec2 b3Pos = vec2(.5 * ratio, .27);\n\n    float dist = distance(shapePos, uv) * 2.0;\n    \n    vec2 uv1 = uv;\n    uv1 -= shapePos;\n    \n    float angle = atan(uv1.y, uv1.x) + iTime;\n    \n    float ring = circle(uv,.33, 0., shapePos);\n    ring -= circle(uv, .35, 0., shapePos);\n    \n    float back = circle(uv, .1, 0., shapePos);\n    float plug = circle(uv, .05, 0., shapePos);\n    float bar = rect(uv, barPos, vec2(.13, .7));\n    float b1 = rect(uv, b1Pos, vec2(.04, .04));\n    float b2 = rect(uv, b2Pos, vec2(.04, .04));\n    float b3 = rect(uv, b3Pos, vec2(.04, .04));\n\n    float radius = sin((angle + iTime * 12.)*3.);\n    radius *= .6;\n    \n    float value = 1.-smoothstep(radius, radius +.1, dist);\n    \n    vec3 color = mix(vec3(.1), vec3(1.), back);\n    color = mix(color, vec3(.1), bar);\n    color = mix(color, vec3(1.), b1);\n    color = mix(color, vec3(1.), b2);\n    color = mix(color, vec3(1.), b3);\n    color = mix(color, vec3(.2), value);\n    color = mix( vec3(.1), color, plug);\n    color = mix(color, vec3(.2), ring);\n    \n    // Output to screen\n    fragColor = vec4(color*2.5,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WssBW4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wssBW7", "name": "Soundfields", "author": "_pwd_", "description": "Sound-raymarching-thingy", "tags": ["raymarching", "noise", "sound"], "likes": 2, "viewed": 79, "date": "1588423462", "time_retrieved": "2024-06-20T20:09:32.016023", "image_code": "\n#define pi 3.14159265\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n#define hsv(h,s,v) mix(vec3(1.), clamp((abs(fract(h+vec3(1., 1., 3.)/3.)*6.-3.)-1.), 0., 1.), s)*v\n\nfloat smallBeat, mediumBeat, bigBeat;\n\nfloat pn(vec3 p) { //noise @Las^Mercury\n\tvec3 i = floor(p);\n\tvec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\n\tvec3 f = cos((p-i)*pi)*(-.5) + .5;\n\ta = mix(sin(cos(a)*a), sin(cos(1.+a)*(1.+a)), f.x);\n\ta.xy = mix(a.xz, a.yw, f.y);\n\treturn mix(a.x, a.y, f.z);\n}\n\nfloat fpn(vec3 p) {\n\treturn pn(p*.06125)*.5 + pn(p*.125)*.25 + pn(p*.25)*.125;\n}\n\nfloat field(vec3 hitpoint,float r,float R) {\n\n\tif ( sin(iChannelTime[0]) > .5 ) {\n\t\t \n\t\t return (cos( hitpoint.x ) + cos( hitpoint.y ) + cos( hitpoint.z )) + r*1.2;\n\t\n\t} else {\n\t\t \n\t\t return length(vec2(length(sin(hitpoint.yz + sin(hitpoint.xy))*cos(hitpoint.yz + cos(hitpoint.yx))+sin(hitpoint.xy)) - r, sin(hitpoint.x) - r)) - R;\t\t//} else if(mediumBeat>0.1) {\n\n\t}\n\t\n}\n\t\nfloat distfunc(vec3 pos) {\n\tfloat t = iTime * 0.01;\n\tvec3 rotpos=mat3(vec3(cos(t*1.63),0.0,-sin(t*1.63)),vec3(0.0,1.0,0.0),vec3(sin(t*1.63),0.0,cos(t*1.63)))*mat3(vec3(cos(t*1.2),-sin(t*1.2),0.0),vec3(sin(t*1.2),cos(t*1.2),0.0),vec3(0.0,0.0,1.0))*(pos-vec3(1.0,1.0,-4.0));\n\treturn field(rotpos,(0.6 * smallBeat)+0.4 + (0.6 * bigBeat),(0.5 * mediumBeat)+0.45 + (0.5 * bigBeat)) + fpn(rotpos*30.+ t*25.) * 0.15;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // create pixel coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\t\n\tfloat x = uv.x;\n\tfloat y = uv.y;\n\t\n\tvec3 ray_dir  = normalize( vec3( x, y, -1.0 ) );\n\tvec3 ray_orig = vec3( 5.0, 1.0, 2.0 );\n\t\n\tfloat j, w, ld, td= 0.,offs = 0.0;\n\tvec3 tc = vec3(0.);\n\t\t\t\t\n\t\n\tfloat fft = texture( iChannel0, vec2(uv.x,1.75) ).x;\n\tvec3 sync = vec3( fft, 4.0*fft*(1.0-fft), 1.0-fft ) * fft;\n\n\tsmallBeat  = sync.r * 0.1;\n\tmediumBeat = sync.g * 0.1;\n\tbigBeat    = sync.b * 0.1;\t\n    \n\tfor( float i = 0.0; i < 50.0;i += 1.0 ) {\n\t\t\n\t\tfloat dist = distfunc(ray_orig+ray_dir*offs);\n\t\toffs+=dist;\n\t\t\t\n\t\tif ( abs(dist) < .05 ) {\n\t\t\t \n\t\t\t ld = 0.05 - dist;\n\t\t\t w = (1. - td) * ld;   \n\t\t\t\n\t\t\t tc = tc + w * hsv(w*3.-0.5, 1.-w*20., 1.) * hsv(w*3.-0.5, 1.-w*20., 1.); \n\t\t\t td = td + w ;\t\n\t\t}\t\n\t\t\n\t\ttd += 1./200.;\t\t\t\n\t\t\n\t\tif(abs(dist)<0.0001) break;\n\t\telse if(offs>50.0) break;\n\t\t\t\n\t}\n\t\n\tfragColor = vec4( tc + mediumBeat * 0.001, 1.0);\n\t\n}", "image_inputs": [{"id": "4t2GWw", "previewfilepath": "https://soundcloud.com/mark-r-3/vanishing-point", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/mark-r-3/vanishing-point", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wssBW7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsSBWG", "name": "sdFunc - Glowing Objects", "author": "NightJolt", "description": "signed distance function", "tags": ["sdfunc"], "likes": 3, "viewed": 288, "date": "1590689162", "time_retrieved": "2024-06-20T20:09:32.016023", "image_code": "float map(float value, float fmin, float fmax, float tmin, float tmax) {\n    return tmin + (value - fmin) * (tmax - tmin) / (tmax - tmin);\n}\n\nfloat modAxis(float p, float size) {\n\tfloat halfsize = size * 0.5;\n\tfloat c = floor((p + halfsize) / size);\n\tp = mod(p + halfsize, size) - halfsize;\n\tp = mod(-p + halfsize, size) - halfsize;\n\treturn p;\n}\n\nfloat sdCircle(vec2 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdBox(vec2 p, vec2 s, float r) {\n    vec2 d = abs(p) - s;\n    float sd = length(max(d, vec2(0))) + min(max(d.x, d.y), 0.0);\n    \n    return sd - r;\n}\n\nfloat su(float d1, float d2, float k) {\n    float h = clamp(.5 + .5 * (d2 - d1) / k, 0., 1.);\n    \n    return mix(d2, d1, h) - k * h * (1. - h);\n}\n\nfloat ss(float d1, float d2, float k) {\n    float h = clamp(.5 -.5 * (d2 + d1) / k, 0.0, 1.0);\n    return mix(d2, -d1, h) + k * h * (1. - h);\n}\n\nfloat si(float d1, float d2, float k) {\n    float h = clamp(.5 - .5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) + k * h * (1.0 - h);\n}\n\nfloat un(float d1, float d2) {\n    return min(d1, d2);\n}\n\nvec2 rotate(vec2 p, float angle) {\n    mat2 rot_mat = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    \n    return rot_mat * p;\n}\n\nvec2 magic(vec2 p) {\n    mat2 mat = mat2(cos(p.x), cos(p.y), cos(p.y), cos(p.x));\n    \n    return mat * p;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 res = iResolution.xy;\n    vec2 coord = fragCoord;\n    vec2 uv = coord / res;\n    vec2 p = coord - res * .5;\n    \n    //p.x = modAxis(p.x, 400.);\n    //p.y = modAxis(p.y, 400.);\n    \n    float rect = sdBox(rotate(p, -iTime), vec2(30.), 50.);\n    float rect_2 = sdBox(rotate(p, -iTime), vec2(20.), 100.);\n    float circle_ring =\n        un (\n            un (\n                sdCircle(p + vec2(100. * cos(iTime), 100. * sin(iTime)), 30.),\n    \t\t\tsdCircle(p + vec2(-100. * cos(iTime), -100. * sin(iTime)), 30.)\n            ),\n            un (\n                sdCircle(p + vec2(-100. * sin(-iTime), -100. * cos(-iTime)), 30.),\n    \t\t\tsdCircle(p + vec2(100. * sin(-iTime), 100. * cos(-iTime)), 30.)\n            )\n        );\n    float d = ss(su(rect, circle_ring, 20.), rect_2, 10.);\n    \n    vec3 c = vec3(5. / length(abs(mod(uv / d, 1.) - .5)));\n   \n\tvec3 col = vec3(.5 + sin(uv.x * 10. + iTime * 2.) * .3, .25, .7 + sin(uv.y * 20. + iTime * .5) * .3);\n    col *= 0.1;\n    \n    vec3 f_col = c / d * col * sqrt(length(p));\n    \n    fragColor = vec4(f_col - mod(f_col, .1), iTime);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsSBWG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsSBWm", "name": "Glasswall", "author": "TAKUSAKU", "description": "Glasswall", "tags": ["wall", "glass", "architecture"], "likes": 19, "viewed": 313, "date": "1590154773", "time_retrieved": "2024-06-20T20:09:32.016023", "image_code": "float random (in vec2 _st) {\n    return fract(sin(dot(_st.xy, vec2(0.89,-0.90)))*757.153);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3. - 2. * f);\n\n    return mix(a, b, u.x) + (c - a)* u.y * (1. - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat fbm ( in vec2 _st) {\n    float v = sin(iTime*0.2)*0.15;\n    float a = 0.8;\n    vec2 shift = vec2(100.);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(1.0),\n                    -sin(0.5), acos(0.5));\n    for (int i = 0; i < 5; ++i) {\n        v += a * noise(_st);\n        _st = rot * _st * 2. + shift;\n        a *= 0.01;\n    }\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = (2.*fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y) * 1.7;\n    \n    vec2 co = st;    \n    float len;    \n    for (int i = 0; i < 3; i++) {\n        len = length(co);        \n        co.x +=  sin(co.y + iTime * 0.620)*0.1;\n        co.y +=  cos(co.x + iTime * 0.164)*0.1;\n    }    \n    len -= 3.;\n     \n    vec3 col = vec3(0.);\n\n    vec2 q = vec2(0.);\n    q.x = fbm( st + 1.0);\n    q.y = fbm( st + vec2(-0.45,0.65));\n\n    vec2 r = vec2(0.);\n    r.x = fbm( st + q + vec2(0.57,0.52)+ 0.5*iTime );\n    r.y = fbm( st + q + vec2(0.34,-0.57)+ 0.4*iTime);\n    \n    for (float i = 0.; i < 3.; i++) {\n        r += 1. / abs(mod(st.y, 1.2* i) * 500.) * 1.;//Virtical line\n        r += 1. / abs(mod(st.x, 0.3 * i) * 500.) * 1.;//Horizontal line\n        r += 1. / abs(mod(st.y + st.x, 0.6 * i) * 500.) * 1.;//Diagonal line\n        r += 1. / abs(mod(st.y - st.x, 0.6 * i) * 500.) * 1.;//Diagonal line\n    }\n    float f = fbm(st+r);\n    \n    col = mix(col, cos(len + vec3(0.2, 0.0, -0.5)), 1.0);\n    col = mix(vec3(0.730,0.386,0.372), vec3(0.397,0.576,0.667), col);    \n    \n    fragColor = vec4(2.0*(f*f*f+.6*f*f+.5*f)*col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsSBWm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsSBzc", "name": "Multi Color", "author": "ylan_go", "description": "Multi Color", "tags": ["multicolor"], "likes": 1, "viewed": 171, "date": "1590488527", "time_retrieved": "2024-06-20T20:09:32.131204", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsSBzc.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsSBzd", "name": "Sun Light", "author": "TAKUSAKU", "description": "Sun Light", "tags": ["sun", "light"], "likes": 2, "viewed": 62, "date": "1590576453", "time_retrieved": "2024-06-20T20:09:32.131204", "image_code": "float va ( in vec2 _st) {\n    float v = sin(iTime*0.1)*0.2;\n    float a = 0.2;    \n    for (int i = 0; i <3; ++i) {\n        v += a;\n        _st = _st * 2.0;\n        a *= 2.0;\n    }\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Wide-angle lens is baced on Menger Sponge Variation\n    // https://www.shadertoy.com/view/ldyGWm\n    vec3 st = (vec3(2.0 * fragCoord - iResolution.xy, iResolution.y));\n    st = normalize(vec3(st.xy, sqrt(max(st.z * st.z - dot(st.xy, st.xy) *2.,0.)))); \n    //st *= 4.0*sin(u_time*0.1);\n\n    vec2 coord = st.xy * 0.2;\n    float len; \n    for (int i = 0; i < 3; i++) {\n        len = length(vec2(coord.x, coord.y));  \n        coord.x +=  sin(coord.y + iTime * 0.1)*2.1;\n        coord.y +=  cos(coord.x + iTime * 0.05 + cos(len * 50.0))*1.;\n    }\n    len -= 3.;\n    \n    vec3 color = vec3(0.);\n    \n    color = mix(color, cos(len + vec3( 0.5, 0.0, 0.1)), 1.0);\n    color = mix(vec3(0.595,0.490,0.241),vec3(0.420,0.042,0.038),color);\n    \n    float f = va(st.xy);\n    fragColor = vec4((f*f*f+.6*f*f+.5*f)*color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsSBzd.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsSBzw", "name": "Displacement map on rast mesh", "author": "TomF", "description": "Most of this is simulating a conventional rasterised mesh, but then it steps through a displacement map.", "tags": ["animated", "displacementmap", "rasterize", "mesh"], "likes": 2, "viewed": 542, "date": "1589694711", "time_retrieved": "2024-06-20T20:09:33.604145", "image_code": "\n\n#define BACKFACE_CULL false\n#define TEXTURED true\n#define PHASES false\n\n\nstruct Vertex\n{\n    vec4 Pos;\n    vec3 Uvh;\n};\n    \n\n// Test a position against a triangle and return\n// the perspective-correct barycentric coordinates in the triangle\n// Note the z value in the vertex is ignored, it's the w that matters.\nvec2 BaryTri3D ( vec2 pos, Vertex v1, Vertex v2, Vertex v3 )\n{\n    vec2 posv1 = pos - vec2(v1.Pos);\n    \n    vec2 v21 = vec2(v2.Pos) - vec2(v1.Pos);\n    vec2 v31 = vec2(v3.Pos) - vec2(v1.Pos);\n    \n    float scale = v21.x * v31.y - v21.y * v31.x;\n    if ( BACKFACE_CULL && ( scale < 0.0 ) )\n    {\n        return vec2 ( -1.0, -1.0 );\n    }\n\n    float rscale = 1.0 / scale;\n    float baryi = ( posv1.x * v31.y - posv1.y * v31.x ) * rscale;\n    float baryj = ( posv1.x * v21.y - posv1.y * v21.x ) * -rscale;\n    \n    // Now interpolate the canonical coordinates (0,0,1,v1.w), (1,0,1,v2.w) and (0,1,1,v3.w)\n    // with perspective correction\n    // So we project all three by their respective w:\n    // (0,0,v1.w) -> (0,     0,     1/v1.w)\n    // (1,0,v2.w) -> (1/v2.w,0,     1/v2.w)\n    // (0,1,v3.w) -> (0,     1/v3.w,1/v3.w)\n    // Then interpolate those values linearly to produce (nx,ny,nw),\n    // then divide by nw again.\n    vec3 recipw = vec3 ( 1.0/v1.Pos.w, 1.0/v2.Pos.w, 1.0/v3.Pos.w );\n    \n    float baryk = 1.0 - baryi - baryj;\n    float newi = recipw.y * baryi;\n    float newj = recipw.z * baryj;\n    //float neww = recipw.x * baryk + recipw.y * baryi + recipw.z * baryj;\n    float neww = recipw.x * baryk + newi + newj;\n    \n    // ...and project back.\n    float rneww = 1.0/neww;\n    float perspi = newi * rneww;\n    float perspj = newj * rneww;\n        \n    return vec2 ( perspi, perspj );\n}\n\nconst int GridW = 5;\nconst int GridH = 5;\nconst int NumVerts = GridH*GridW*2;\nconst int NumTris = (GridH-1)*(GridW-1)*2*2 + ((GridH-1)*2+(GridW-1)*2)*2;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // NDC (-1 to +1)\n    vec2 uv = -1.0 + 2.0f * (fragCoord/iResolution.xy);\n    \n    int Phase = 0;\n    if(PHASES)\n    {\n    \tPhase = (int(floor(0.2*(iTime-1.0*fragCoord.x/iResolution.x))))%3;\n    }\n    \n    \n    float wobble = float(iTime);\n    \n    // Create the mesh. This would of course be done offline.\n    Vertex Verts[NumVerts];\n    for ( int w = 0; w < GridW; w++ )\n    {\n        for ( int h = 0; h < GridH; h++ )\n        {\n            Vertex Vert0, Vert1;\n            Vert0.Pos.x = float(w - GridW/2);\n            Vert0.Pos.y = float(h - GridH/2);\n            float wf = -2.0 + float(w);\n            float hf = -3.0 + float(h);\n            float d = sqrt(wf*wf + hf*hf);\n            Vert0.Pos.z = 0.3 * cos (d * 0.8 + wobble) - 1.0;\n            Vert0.Pos.w = 1.0f;\n            Vert0.Uvh.x = float(w) / float(GridW-1);\n            Vert0.Uvh.y = float(h) / float(GridH-1);\n            Vert0.Uvh.z = 0.0;\n            \n            Vert1.Pos = Vert0.Pos;\n            Vert1.Pos.z += 1.0;\n            Vert1.Uvh = Vert0.Uvh;\n            Vert1.Uvh.z = 1.0;\n            \n            int Index = (w*GridH+h)*2;\n            Verts[Index+0] = Vert0;\n            Verts[Index+1] = Vert1;\n        }\n    }\n\n    int Indices0[NumTris];\n    int Indices1[NumTris];\n    int Indices2[NumTris];\n    for ( int w = 0; w < GridW-1; w++ )\n    {\n        for ( int h = 0; h < GridH-1; h++ )\n        {\n            int VertIndex = (w*GridH+h)*2;\n            int TriIndex = (w + (GridH-1)*h) * 2 * 2;\n            Indices0[TriIndex+0] = VertIndex  ;\n            Indices1[TriIndex+0] = VertIndex  +GridH*2;\n\t\t\tIndices2[TriIndex+0] = VertIndex  +2;\n            Indices0[TriIndex+1] = VertIndex+1;\n            Indices2[TriIndex+1] = VertIndex+1+GridH*2;\n\t\t\tIndices1[TriIndex+1] = VertIndex+1+2;\n            \n            Indices2[TriIndex+2] = VertIndex  +GridH*2;\n            Indices0[TriIndex+2] = VertIndex  +GridH*2+2;\n\t\t\tIndices1[TriIndex+2] = VertIndex  +2;\n            Indices1[TriIndex+3] = VertIndex+1+GridH*2;\n            Indices0[TriIndex+3] = VertIndex+1+GridH*2+2;\n\t\t\tIndices2[TriIndex+3] = VertIndex+1+2;\n        }\n    }\n    // Now do the edges.\n    int CurTri  = (GridH-1)*(GridW-1)*2*2;\n    for ( int w = 0; w < GridW-1; w++ )\n    {\n        int VertIndex = (w*GridH)*2;\n        Indices0[CurTri+0] = VertIndex;\n        Indices1[CurTri+0] = VertIndex+1;\n\t\tIndices2[CurTri+0] = VertIndex+GridH*2;\n        Indices0[CurTri+1] = VertIndex+1;\n        Indices1[CurTri+1] = VertIndex+GridH*2;\n\t\tIndices2[CurTri+1] = VertIndex+GridH*2+1;\n\n        VertIndex = (w*GridH+GridH-1)*2;\n        Indices0[CurTri+2] = VertIndex;\n        Indices1[CurTri+2] = VertIndex+1;\n\t\tIndices2[CurTri+2] = VertIndex+GridH*2;\n        Indices0[CurTri+3] = VertIndex+1;\n        Indices1[CurTri+3] = VertIndex+GridH*2;\n\t\tIndices2[CurTri+3] = VertIndex+GridH*2+1;\n        \n        CurTri += 4;\n    }\n    for ( int h = 0; h < GridH-1; h++ )\n    {\n        int VertIndex = (h)*2;\n        Indices0[CurTri+0] = VertIndex;\n        Indices1[CurTri+0] = VertIndex+1;\n\t\tIndices2[CurTri+0] = VertIndex+2;\n        Indices0[CurTri+1] = VertIndex+1;\n        Indices1[CurTri+1] = VertIndex+2;\n\t\tIndices2[CurTri+1] = VertIndex+2+1;\n\n        VertIndex = (h+GridH*(GridW-1))*2;\n        Indices0[CurTri+2] = VertIndex;\n        Indices1[CurTri+2] = VertIndex+1;\n\t\tIndices2[CurTri+2] = VertIndex+2;\n        Indices0[CurTri+3] = VertIndex+1;\n        Indices1[CurTri+3] = VertIndex+2;\n\t\tIndices2[CurTri+3] = VertIndex+2+1;\n        \n        CurTri += 4;\n    }\n   \n    \n    float hfov = 0.6;\n    float vfov = hfov * iResolution.y / iResolution.x;\n    float zfar = 10.0f;\n    float znear = 1.0f;\n    float q = zfar/(zfar-znear);\n    \n    mat4 ProjMat;\n    ProjMat[0] = vec4 ( 1.0/hfov, 0.0f, 0.0f, 0.5f );\n    ProjMat[1] = vec4 ( 0.0f, 1.0/vfov, 0.0f, 0.5f );\n    ProjMat[2] = vec4 ( 0.0f, 0.0f, q, 1.0f );\n    ProjMat[3] = vec4 ( 0.0f, 0.0f, -q*znear, 0.0f );\n    \n    \n    mat4 TotalMat;\n    mat4 ObjMat1;\n    mat4 ObjMat2;\n    \n    float a1 = iMouse.x * 0.01 + 0.5;\n    float a2 = iMouse.y * 0.01 + 2.0;\n    float zdist = 4.0;\n    ObjMat1[0] = vec4 ( cos(a1),  sin(a1), 0.0, 0.0 );\n    ObjMat1[1] = vec4 ( sin(a1), -cos(a1), 0.0, 0.0 );\n    ObjMat1[2] = vec4 ( 0.0,          0.0, 1.0, 0.0 );\n    ObjMat1[3] = vec4 ( 0.0,          0.0, 0.0, 1.0 );\n    ObjMat2[0] = vec4 ( 1.0, 0.0,          0.0, 0.0 );\n    ObjMat2[1] = vec4 ( 0.0, cos(a2),  sin(a2), 0.0 );\n    ObjMat2[2] = vec4 ( 0.0, sin(a2), -cos(a2), zdist );\n    ObjMat2[3] = vec4 ( 0.0, 0.0,          0.0, 1.0 );\n    \n    TotalMat = ObjMat1 * ObjMat2;\n    TotalMat = TotalMat * ProjMat;\n\n    // Background colour\n    vec3 col;\n    col.xy = uv.xy;\n    col.z = 0.0;\n\n    Vertex ScreenVert[NumVerts];\n    for ( int VertNum = 0; VertNum < NumVerts; VertNum++ )\n    {\n        vec4 Pos = Verts[VertNum].Pos;\n        \n        vec4 ScrPos = Pos * TotalMat;\n        float rw = 1.0/ScrPos.w;\n        ScrPos.x *= rw;\n        ScrPos.y *= rw;\n        ScrPos.z *= rw;\n        \n        ScreenVert[VertNum].Pos = ScrPos;\n        ScreenVert[VertNum].Uvh = Verts[VertNum].Uvh;\n    }\n    \n    float NearestZ = 10000000.0f;\n    float FarthestZ = -10000000.0f;\n    vec3 NearUvh;\n    vec3 FarUvh;\n    \n    for ( int TriNum = 0; TriNum < NumTris; TriNum++ )\n    {\n        Vertex v1 = ScreenVert[Indices0[TriNum]];\n        Vertex v2 = ScreenVert[Indices1[TriNum]];\n        Vertex v3 = ScreenVert[Indices2[TriNum]];\n        vec3 bary;\n        bary.xy = BaryTri3D ( uv, v1, v2, v3 );\n        bary.z = 1.0 - bary.x - bary.y;\n\n        vec3 uvh = bary.z * v1.Uvh + bary.x * v2.Uvh + bary.y * v3.Uvh;\n        \n        if ( ( bary.x >= 0.0 ) &&\n             ( bary.y >= 0.0 ) &&\n             ( bary.z >= 0.0 ) &&\n             ( uvh.x + uvh.y + uvh.z > -1000.0 ) ) // see above\n        {\n            // Interpolate Z\n            // Note this is linear Z, not the strange Z that most rasteriser use\n            // In this case, that's fine.\n            float Z = bary.z * v1.Pos.z + bary.x * v2.Pos.z + bary.y * v3.Pos.z;\n            if ( NearestZ >= Z )\n            {\n                NearestZ = Z;\n                NearUvh = uvh;\n                \n                if ( Phase == 1 )\n                {\n                    // Wireframe!\n                    float maxbary = min ( bary.x, min ( bary.y, bary.z ) );\n                    maxbary = maxbary * 100.0;\n                    if ( maxbary < 1.0 )\n                    {\n                        col.x = 1.0 - maxbary;\n                    }\n                }  \n            }\n            \n            if ( FarthestZ <= Z )\n            {\n                FarthestZ = Z;\n                FarUvh = uvh;\n            }\n            \n        }        \n    }\n    \n    if ( NearestZ < FarthestZ )\n    {\n        if ( Phase == 0 )\n        {\n            // Now \"trace\" from NearUV to FarUV and\n            // see where it intersects the heightfield.\n            // Ideally the heightfield would store an SDF rather than a simple height,\n            // so you could step through it quickly, but I don't have that, so this is\n            // just a brute-force step, although it is at least proportional to the\n            // number of texels to traverse.\n            float Dist = length(NearUvh.xy - FarUvh.xy);\n            int NumSteps = int(Dist*64.0+5.0); // texture size?\n            vec3 LastUvh = NearUvh;\n            float LastTexH = NearUvh.z;\n            for ( int StepNum = 0; StepNum <= NumSteps; StepNum++ )\n            {\n                float Lerp = float(StepNum)/float(NumSteps);\n                vec3 uvh = NearUvh + (FarUvh-NearUvh)*Lerp;\n                float height = 1.0 - texture ( iChannel0, uvh.xy ).x;\n                if ( uvh.z >= height )\n                {\n                    // We crossed from one side to the other,\n                    // so interpolate to the intersection.\n                    float h0 = LastUvh.z - LastTexH;\n                    float h1 = uvh.z - height;\n                    float ThisLerp = h0 / (h0-h1);\n                    vec3 uvh2 = LastUvh + (uvh-LastUvh)*ThisLerp;\n                    vec4 tex2 = texture ( iChannel0, uvh2.xy ).xxxx * texture ( iChannel1, uvh2.xy );\n                    col.xyz = tex2.xyz;\n                    break;\n                }\n                else\n                {\n                    LastUvh = uvh;\n                    LastTexH = height;\n                }\n            }\n        }\n        else if ( Phase == 1 )\n        {\n            //col.xyz = NearUvh.xyz;\n        }\n        else if ( Phase == 2 )\n        {\n            col.xyz = texture ( iChannel0, NearUvh.xy ).xxx;\n        }\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsSBzw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsSfD3", "name": "Phong Spheres", "author": "Helliaca", "description": "phong spheres", "tags": ["phong"], "likes": 0, "viewed": 34, "date": "1590934732", "time_retrieved": "2024-06-20T20:09:34.767882", "image_code": "\n// Constants #######################################################################\n\nconst vec3 cameraPos = vec3(0.0, 1.3, 0.0);\t// Position of the camera in world space\nconst vec3 viewPlane = cameraPos + vec3(0.0, 0.0, 1.0);\t// Position of the view-plane in world space (point that camera is looking at)\n#define noMat Material(0.0, 0.0, 0.0, 0.0, vec3(0.0, 0.0, 0.0))\n\n\n\n// Structs #########################################################################\n\nstruct Light {\n    vec3 pos;\n    vec3 color;\n    vec3 att; //constant, linear, quadratic attenuation factors\n};\n\nstruct Material {\n    float ambient_str;\n    float diffuse_str;\n    float specular_str;\n    float shininess;\n    vec3 color;\n};\n\nstruct Plane {\n    vec3 pos;\n    vec3 nrm;\n    Material mat;\n};\n    \nstruct Sphere {\n    vec3 pos;\n    float r;\n    Material mat;\n};\n    \nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n    \nstruct Hit {\n    bool hit;\n    vec3 pos;\n    vec3 nrm;\n    Material mat;\n};\n    \n    \n    \n// Scene Objects ####################################################################\n    \n//Lights\nLight lights[] = Light[](\n    //    position             //color              //attenuation\n    Light(vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0), vec3(1.0, 0.5, 0.5)),\t// Moving white Light\n    Light(vec3(-1.5, 0.0, -1.5), vec3(1.0, 0.0, 0.0), vec3(0.0, 0.2, 0.2)),\t// Red light bottom left\n    Light(vec3(1.5, 0.0, -1.5), vec3(0.0, 0.8, 0.0), vec3(0.0, 0.2, 0.2)),\t// Green light bottom right\n    Light(vec3(0.0, 2.5, 0.0), vec3(0.0, 0.0, 1.0), vec3(0.0, 1.0, 0.5))\t// Blue light top blinking\n);\n    \n// Planes\nPlane planes[] = Plane[](\n    //    position             // surface-normal    //mat    //a  //d  //s  //sh  //color\n    Plane(vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), Material(0.1, 1.0, 1.0, 32.0, vec3(1.0, 1.0, 1.0)) ),\n    Plane(vec3(-2.0, 0.0, 0.0), vec3(1.0, 0.0, 0.0), Material(0.1, 1.0, 1.0, 32.0, vec3(1.0, 1.0, 1.0)) ),\n    Plane(vec3(2.0, 0.0, 0.0), vec3(-1.0, 0.0, 0.0), Material(0.1, 1.0, 1.0, 32.0, vec3(1.0, 1.0, 1.0)) )\n);\n\nSphere spheres[] = Sphere[](\n    //     position                //r   //mat    //a  //d  //s  //sh  //color\n    Sphere(vec3(-1.50, 0.3, -3.0), 0.3f, Material(0.08, 0.0, 3.0, 512.0, vec3(1.0, 1.0, 1.0)) ),\n    Sphere(vec3(-1.50, 1.0, -3.0), 0.3f, Material(0.08, 1.0, 0.5, 016.0, vec3(1.0, 0.3, 3.3)) ),\n    Sphere(vec3(-1.50, 1.7, -3.0), 0.3f, Material(0.08, 1.0, 5.0, 016.0, vec3(1.0, 1.0, 1.0)) ),\n    Sphere(vec3(-1.50, 2.4, -3.0), 0.3f, Material(0.08, 1.0, 0.0, 002.0, vec3(1.0, 1.0, 1.0)) ),\n    Sphere(vec3(-0.75, 0.3, -3.0), 0.3f, Material(0.08, 1.0, 0.2, 064.0, vec3(0.0, 1.0, 0.0)) ),\n    Sphere(vec3(-0.75, 1.0, -3.0), 0.3f, Material(0.08, 1.0, 1.0, 032.0, vec3(0.5, 0.5, 0.5)) ),\n    Sphere(vec3(-0.75, 1.7, -3.0), 0.3f, Material(0.50, 1.0, 5.0, 128.0, vec3(1.0, 1.0, 1.0)) ),\n    Sphere(vec3(-0.75, 2.4, -3.0), 0.3f, Material(0.08, 0.1, 8.0, 001.0, vec3(0.0, 1.0, 1.0)) ),\n    Sphere(vec3(00.00, 0.3, -3.0), 0.3f, Material(0.50, 0.1, 0.5, 032.0, vec3(1.0, 1.0, 0.0)) ),\n    Sphere(vec3(00.00, 1.0, -3.0), 0.3f, Material(0.08, 1.0, 1.0, 032.0, vec3(1.0, 1.0, 1.0)) ),\n    Sphere(vec3(00.00, 1.7, -3.0), 0.3f, Material(0.08, 1.0, 0.0, 016.0, vec3(0.2, 0.2, 0.2)) ),\n    Sphere(vec3(00.00, 2.4, -3.0), 0.3f, Material(0.08, 2.5, 0.1, 001.0, vec3(1.0, 1.0, 1.0)) ),\n    Sphere(vec3(00.75, 0.3, -3.0), 0.3f, Material(0.08, 0.6, 0.1, 128.0, vec3(0.9, 0.2, 0.2)) ),\n    Sphere(vec3(00.75, 1.0, -3.0), 0.3f, Material(0.25, 1.0, 0.1, 001.0, vec3(0.24, 0.14, 0.0)) ),\n    Sphere(vec3(00.75, 1.7, -3.0), 0.3f, Material(0.08, 1.0, 1.0, 016.0, vec3(1.0, 0.0, 0.0)) ),\n    Sphere(vec3(00.75, 2.4, -3.0), 0.3f, Material(0.15, 1.5, 1.0, 128.0, vec3(0.0, 1.0, 0.35)) ),\n    Sphere(vec3(01.50, 0.3, -3.0), 0.3f, Material(0.08, 1.0, 9.0, 001.0, vec3(0.01, 0.01, 0.01)) ),\n    Sphere(vec3(01.50, 1.0, -3.0), 0.3f, Material(0.00, 0.7, 0.0, 032.0, vec3(1.0, 1.0, 1.0)) ),\n    Sphere(vec3(01.50, 1.7, -3.0), 0.3f, Material(0.20, 0.8, 1.0, 128.0, vec3(1.0, 0.7, 0.2)) ),\n    Sphere(vec3(01.50, 2.4, -3.0), 0.3f, Material(0.08, 1.0, 1.0, 002.0, vec3(0.0, 0.0, 1.0)) ) \n);\n\n\n\n// Math ######################################################################\n\n// Returns point where a ray intersects a given plane p\nHit ray_plane(Ray r, Plane p) {    \n    // Check if ray is parallel to plane\n    if(dot(p.nrm, r.dir)==0.0) return Hit(false, vec3(0.0), vec3(0.0), noMat);\n    \n    // See: https://en.wikipedia.org/wiki/Line%E2%80%93plane_intersection\n    float d = dot((p.pos-r.origin), p.nrm) / dot(r.dir, p.nrm);\n    if(d<=0.0) return Hit(false, vec3(0.0), vec3(0.0), noMat); //collision *behind* origin -> no collision\n    return Hit(true, r.origin + d*r.dir, p.nrm, p.mat);\n}\n\n// Returns points where a ray intersects a given sphere sph\nHit ray_sphere(Ray r, Sphere sph) {\n    // A sphere is characterized by dot(P-s_origin, P-s_origin) - r^2 = 0\n    // A ray is characterized by p(t) = r_origin + t*dir\n    // Inserting p(t) into P of the sphere equation yields: dot(p(t)-s_origin, p(t)-s_origin) - r^2 = 0\n    // When expanded and solved for t we get following: http://viclw17.github.io/2018/07/16/raytracing-ray-sphere-intersection/\n    float a = dot(r.dir, r.dir);\n    vec3 so_ro = r.origin - sph.pos;\n    float b = 2.0 * dot(r.dir, so_ro);\n    float c = dot(so_ro, so_ro) - (sph.r * sph.r);\n    \n    float disr = b*b - 4.0*a*c; //discriminant\n    \n    // Doesn't hit\n    if (disr < 0.0) {\n        return Hit(false, vec3(0.0), vec3(0.0), noMat);\n    }\n    // hits\n    vec3 hitpos = r.origin + r.dir*(-b - sqrt(disr))/(2.0*a);\n    vec3 normal = normalize(hitpos-sph.pos);\n    return Hit(true, hitpos, normal, sph.mat);\n}\n\n\n\n// Shading ######################################################################\n\nvec3 phong(vec3 pos, vec3 nrm, Material mat, Light light, vec3 viewPos) {\n    // Ambient\n    vec3 ambient = mat.ambient_str * light.color;\t\t\t// ambient color\n  \t\n    // Diffuse\n    vec3 lightDir = normalize(light.pos - pos);\t\t\t\t// Direction of lightsource\n    float diff = max(dot(nrm, lightDir), 0.0);\t\t\t\t// diffuse factor\n    vec3 diffuse = mat.diffuse_str * diff * light.color;\t// diffuse color\n\n    // Glossy\n    vec3 viewDir = normalize(viewPos - pos);\t\t\t\t// View direction\n    vec3 reflectDir = reflect(-lightDir, nrm); \t\t\t\t// Perfect reflectance direction \n    float spec = pow(max(dot(reflectDir, viewDir), 0.0), 8.0); // specular factor\n    vec3 specular = mat.specular_str * spec * light.color;  // Specular color\n\n    // Attenuation (Const. Lin. Quadratic)\n    float dist = length(light.pos - pos);\n    float attenuation = 1.0f / (light.att.x + light.att.y * dist + light.att.z * (dist * dist));\n    \n    // Final result\n    return (ambient + diffuse + specular) * mat.color * attenuation;\n}\n\n// Returns a ray through any given fragment coordinate of a virtual camera\nRay cameraRay(vec2 fragCoord) {\n    // Viewplane x-Axis is cross product of global up-Vector and camera forward vector\n    vec3 xvec = normalize(cross(vec3(0.0, 1.0, 0.0), cameraPos-viewPlane));\n    // Viewplane y-Axis is cross product of viewplane x-Axis and camera forward vector\n    vec3 yvec = normalize(cross(xvec, cameraPos-viewPlane));\n    \n    vec2 uv = fragCoord/iResolution.xy; \t// Normalized screen coordiantes [0, 1]\n    uv -= 0.5;\t\t\t\t\t\t\t\t// Screen coordiantes centered [0,1] -> [-0.5, 0.5]\t\n    uv.x *= iResolution.x / iResolution.y; \t// Apply aspect ration of resolution\n    \n    // Get virtual pixel position on virtual screen at viewPlane in world space\n    vec3 vpp = viewPlane + xvec*uv.x + yvec*uv.y;\n    // This gives us the desired ray direction\n    vec3 rayDir = cameraPos - vpp;\n    \n    return Ray(cameraPos, rayDir);\n}\n\n// Returns closest collision point of any given ray on all objects\nHit rayTrace(Ray ray) {\n    // Set some non-collision point very far away as the closest\n    Hit closest = Hit(false, vec3(9999.0, 9999.0, 9999.0), vec3(0), noMat);\n    \n    // Trace to each sphere, if collision -> keep closest point  to ray-origin\n    for(int i=0; i<spheres.length(); i++) {\n        Hit h = ray_sphere(ray, spheres[i]);\n        if(h.hit && length(h.pos - ray.origin) < length(closest.pos - ray.origin)) {\n            closest = h;\n        }\n    }\n    \n    // Trace to each plane, if collision -> keep closest point  to ray-origin\n    for(int i=0; i<planes.length(); i++) {\n        Hit h = ray_plane(ray, planes[i]);\n        if(h.hit && length(h.pos - ray.origin) < length(closest.pos - ray.origin)) {\n            closest = h;\n        }\n    }\n    \n    return closest;\n}\n\n// Move lights over time\nvoid updateLights() {\n    lights[0].pos = vec3(1.9*sin(iTime), 1.5, -3.0+1.3*cos(iTime));\n    lights[3].color.b = sin(iTime*0.8f);    \n}\n\n\n// Main shader\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    updateLights();\n    \n    // Trace a ray through the respective pixel\n    Hit h = rayTrace(cameraRay(fragCoord));\n    \n    // If we hit something, calculate respective phong color\n    //if(h.hit) fragColor = vec4(phong(h.pos, h.nrm, vec3(0.0, 1.0, 0.0)) ,1.0);    \n    //else fragColor = vec4(0.0);\n    \n    vec3 col = vec3(0.0);\n    if(h.hit) {\n    \tfor(int i=0; i<lights.length(); i++) {\n        \tcol += phong(h.pos, h.nrm, h.mat, lights[i], cameraPos);\n    \t}\n    }\n    \n    fragColor = vec4(col, 1.0);\n}\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsSfD3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsSfDD", "name": "color with music", "author": "bigxixi", "description": "//https://www.shadertoy.com/view/XsXXDn\n//credits to 'Danilo Guanabara'\n", "tags": ["color"], "likes": 3, "viewed": 101, "date": "1590064111", "time_retrieved": "2024-06-20T20:09:34.767882", "image_code": "//https://www.shadertoy.com/view/XsXXDn\n//credits to 'Danilo Guanabara'\n\n#define t iTime\n#define r iResolution.xy\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    \tfloat angle = t;\n\tmat2 rotationMatrix = mat2(cos(angle), -sin(angle),\n                               sin(angle),  cos(angle));\n    \n    \n    \n    float mData = texelFetch( iChannel0, ivec2(6,0), 0 ).x; //é³é¢æ°æ®\n\tvec3 c;\n\tfloat l,z=t;//é³é¢æ°æ®å½±åæ¶é´\n\tfor(int i=0;i<3;i++) {\n\t\tvec2 uv,p=fragCoord.xy/r;\n\t\tuv=p;\n\t\tp-=.5;\n\t\tp.x*=r.x/r.y;\n\t\tz+=.07;\n\t\tl=length(p);\n\t\tuv+=p/l*(sin(z)+1.-mData*mData*mData)*abs(sin(l*9.-z*1.));\n        uv*=rotationMatrix;\n\t\tc[i]=(.01/length(abs(mod(0.9*uv,1.)-.5)));\n\t}\n\tfragColor=vec4(c/l,t);\n}\n", "image_inputs": [{"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsSfDD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsSfDW", "name": "pixel perlin noise", "author": "TheNosiriN", "description": "something random", "tags": ["procedural", "noise", "grid", "perlinnoise", "grayscale"], "likes": 4, "viewed": 137, "date": "1590006988", "time_retrieved": "2024-06-20T20:09:34.767882", "image_code": "#define _PerlinPrecision 0.2\n#define _PerlinOctaves 2.0\n#define _PerlinSeed 1.0\n#define RES 20.0\n\n\nfloat rnd(vec2 xy)\n{\n    return fract(sin(dot(xy, vec2(12.9898-_PerlinSeed, 78.233+_PerlinSeed)))* (43758.5453+_PerlinSeed));\n}\nfloat inter(float a, float b, float x)\n{\n    //return a*(1.0-x) + b*x; // Linear interpolation\n\n    float f = (1.0 - cos(x * 3.1415927)) * 0.5; // Cosine interpolation\n    return a*(1.0-f) + b*f;\n}\nfloat perlin(vec2 uv)\n{\n    float a,b,c,d, coef1,coef2, t, p;\n\n    t = _PerlinPrecision;\t\t\t\t\t// Precision\n    p = 0.0;\t\t\t\n\n    for(float i=0.0; i<_PerlinOctaves; i++)\n    {\n        a = rnd(vec2(floor(t*uv.x)/t, floor(t*uv.y)/t));\t//\ta---b\n        b = rnd(vec2(ceil(t*uv.x)/t, floor(t*uv.y)/t));\t\t//\t|   |\n        c = rnd(vec2(floor(t*uv.x)/t, ceil(t*uv.y)/t));\t\t//\tc---d\n        d = rnd(vec2(ceil(t*uv.x)/t, ceil(t*uv.y)/t));\n\n        if((ceil(t*uv.x)/t) == 1.0)\n        {\n            b = rnd(vec2(0.0, floor(t*uv.y)/t));\n            d = rnd(vec2(0.0, ceil(t*uv.y)/t));\n        }\n\n        coef1 = fract(t*uv.x);\n        coef2 = fract(t*uv.y);\n        p += inter(inter(a,b,coef1), inter(c,d,coef1), coef2) * (1.0/pow(2.0,(i+0.6)));\n        t *= 2.0;\n    }\n    return p;\n}\n\n\nfloat grid(vec2 fragCoord, float space, float gridWidth)\n{\n    vec2 p  = fragCoord - vec2(.5);\n    vec2 size = vec2(gridWidth - .5);\n    \n    vec2 a1 = mod(p - size, space);\n    vec2 a2 = mod(p + size, space);\n    vec2 a = a2 - a1;\n       \n    float g = min(a.x, a.y);\n    return clamp(g, 0., 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/RES;\n\t\n    uv = floor(uv) + iTime;\n    \n    float col = perlin(uv);\n    \n    col *= clamp(grid(fragCoord, 20.0, 2.0), 0.0, 1.0);\n    \n    fragColor = vec4(vec3(col), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsSfDW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsSfRG", "name": "ShATI - Oriental", "author": "Flopine", "description": "My former school named ATI decided to launch an everyday challenge from 4th may to 24th may, here is the 18th subject: oriental :)", "tags": ["2d", "grid", "xor", "pattern"], "likes": 15, "viewed": 168, "date": "1590229468", "time_retrieved": "2024-06-20T20:09:35.040624", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n// Shader made for Everyday ATI challenge\n\n#define PI acos(-1.)\n#define AAstep(thre, val) smoothstep(-.7,.7,(val-thre)/min(.05,fwidth(val-thre)))\n\nfloat xor (float a, float b)\n{return (1.-a)*b + (1.-b)*a;}\n\nfloat circle(vec2 uv, float r)\n{return AAstep(r,length(uv));}\n\nfloat pattern(vec2 uv)\n{\n    float per = 1.5;\n    int ip = int(per);\n    vec2 id = floor((uv)/per);\n    uv = mod(uv,per)-per*0.5;\n    float r = sin(length(id+0.5)-iTime*PI/6.)*0.5+0.5;\n    float d = circle(uv,0.5);\n    for(int i=-ip; i<=ip;i+=ip)\n    {\n        for (int j=-ip; j<=ip;j+=ip)\n        {\n          d = xor(d,circle(uv+vec2(float(i),float(j))/2.,r));\n        }\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 col = mix(vec3(0.8,0.7,0.5),vec3(0.1,0.4,0.6),pattern(uv*5.));\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsSfRG.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsSfWm", "name": "Two part color", "author": "codaaaaa", "description": "Each dimension representing Blue-Yellow opponent, or Red-Green opponent", "tags": ["color"], "likes": 0, "viewed": 31, "date": "1590156229", "time_retrieved": "2024-06-20T20:09:35.040624", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y; //Vertically -1 to +1\n    uv /= vec2(0.95); //Scale\n    \n    \n    \n    vec3 col = mix(\n        vec3(mix(vec3(1.,1.,0.), vec3(0.,0.,1.), uv.x+.5)),\n        vec3(mix(vec3(0.,1.,0.), vec3(1.,0.,0.), uv.y+.5)),\n        cos(iTime*0.5)/2.+.5\n    );\n  \n    \n    \n    // Output to screen\n    if (abs(uv.x) > 1.0 || abs(uv.y) > 1.0) {\n        col = vec3(0);\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsSfWm.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsSfWW", "name": "ShATI - Joie", "author": "Flopine", "description": "My former school named ATI decided to launch an everyday challenge from 4th may to 24th may, here is the 16th subject: joy :)\nBecause swimming otter brings me joy <3", "tags": ["raymarching", "modeling", "otter"], "likes": 5, "viewed": 126, "date": "1589996550", "time_retrieved": "2024-06-20T20:09:35.846725", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n// Shader made for Everyday ATI challenge\n\n\n// taken from YX here : https://www.shadertoy.com/view/tdlXW4\n// rough shadertoy approximation of the bonzomatic noise texture\nvec4 texNoise(vec2 uv)\n{\n    float f = 0.;\n    f += texture(iChannel0, uv*.125).r*.5;\n    f += texture(iChannel0, uv*.25).r*.25;\n    f += texture(iChannel0, uv*.5).r*.125;\n    f += texture(iChannel0, uv*1.).r*.125;\n    f=pow(f,1.2);\n    return vec4(f*.45+.05);\n}\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat vcaps( vec3 p, float h, float r )\n{\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\n\nfloat water (vec3 p)\n{\n    p.y += texNoise(p.xz*0.1).r*0.2;\n    p.y += sin(length((p.xz-vec2(0.,0.5))*3.)-iTime*3.)*0.05;\n    return p.y;\n}\n\nfloat otter_body (vec3 p)   \n{\n    vec3 pp = p;\n    p.yz *= rot(0.2);\n    float r = 0.15+p.z*0.1;\n    p.y += 0.2+sin((p.z)*5.)*0.15;\n    float d = max(length(p.xy)-r, abs(p.z)-2.);\n\n    p = pp;\n    p.z -= 1.5;\n    d = min(d, length(p*vec3(0.7,1.2,1.))-0.3);\n\n    p = pp;\n    p.yz += vec2(0.25,-1.);\n    p.x = abs(p.x)-.5;\n    p.z += p.y * p.y;\n    d = min(d,vcaps(p,0.5, 0.08));\n    return d;\n}\n\nfloat otter_face (vec3 p)\n{\n    vec3 pp = p;\n    p.yz -= vec2(0.25,1.3);\n    float d = length(p*vec3(0.6,1.,1.))-0.05;\n\n    p = pp;\n    p.yz -= vec2(0.28,1.4);\n    p.x = abs(p.x)-0.15;\n    d = min(d,length(p)-0.05);\n    return d;\n}\n\nfloat ob,of;\nfloat otter_all (vec3 p)\n{\n    p.x += sin(p.z*1.2+iTime*2.)*0.2;\n    ob = otter_body(p)-texture(iChannel0, p.xz*0.3).r*0.05;\n    of = otter_face(p);\n    return min(ob,of);\n}\n\nfloat w;\nfloat SDF (vec3 p)\n{\n    w = water(p);\n    return min(otter_all(p),w);\n}\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2(0.1,0.);\n    return normalize(SDF(p)-vec3(SDF(p-eps.xyy),SDF(p-eps.yxy),SDF(p-eps.yyx)));\n}\n\nvec3 getcam (vec3 ro, vec3 tar, vec2 uv)\n{\n    vec3 f = normalize(tar-ro);\n    vec3 l = normalize(cross(vec3(0.,1.,0.),f));\n    vec3 u = normalize(cross(f,l));\n    return normalize(f + uv.x * l + uv.y * u);\n}\n\nfloat spec (vec3 rd, vec3 l, vec3 n, float spec_pow)\n{\n    vec3 h = normalize(l-rd);\n    return pow(max(dot(n,h),0.), spec_pow);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(0.,2.5,-.1),\n        p = ro,\n        rd = getcam(ro,vec3(0.),uv),\n        l = normalize(vec3(.8, 1., -.5)),\n        col = vec3(0.);\n\n\n    float d = 0.;\n    for (float i=0.;i<32.;i++)\n    {\n        d = SDF(p);\n        if (d<0.001) break;\n        p += d*rd*0.5;\n    }\n\n    float temp_ob = ob;\n    float temp_of = of;\n    float temp_w = w;\n    vec3 n = getnorm(p);\n    float light = max(dot(n,l),0.);\n\n    if (d == temp_ob) \n    {\n        col = mix(vec3(0.,0.1,0.2),vec3(0.8,0.8,0.6),light);\n        col += spec(rd,l,n, 1.)*0.4;\n    }\n    if (d == temp_of)\n    {\n        col = vec3(0.);\n        col += spec(rd,l,n,15.);\n    }\n    if (d == temp_w)\n    {\n        col = mix(vec3(0.05,0.2,0.05),vec3(0.7,0.85,.95),light);\n        col += spec(rd,l,n,25.)*0.2;\n    }\n\n    \n\t// vignetting (from iq)\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tcol *= .5 + 0.5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), 0.15);\n    \n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsSfWW.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wssfWX", "name": "infinite stairs - helix 1e", "author": "FabriceNeyret2", "description": ".", "tags": ["raymarching", "sdf", "spiral", "helix", "short", "helicoid"], "likes": 4, "viewed": 240, "date": "1589209539", "time_retrieved": "2024-06-20T20:09:36.016456", "image_code": "// variant of https://shadertoy.com/view/tdlfWX\n// variant of https://shadertoy.com/view/XsdBW8\n\nvoid mainImage(out vec4 O, vec2 U) {\n    \n    float T = iTime, t=1.,a;\n    mat2  R = mat2( cos(-.3*T +vec4(0,33,11,0)) );\n    vec3  q = iResolution, A,\n          D = vec3(.3*(U+U-q.xy)/q.y, -1),        // ray direction\n          p = 30./q;                              // marching point along ray \n    O-=O;\n    for ( O++; O.x > 0. && t > .01 ; O-=.015 )\n        q = p.xzy - vec3(0,0,T),\n        q.xy *= R,\n        A = abs(q), t = abs(max(A.x,A.y)-6.)-2.,  // bounding hollow box\n        a = atan(q.y,q.x),\n        t = max(t, sin(a-floor(q.z*4.)/4.*1.047)),// helix: stairs side\n        t = max(t, sin(a-q.z*1.047+2.3) ),        // helix: roof side\n        p += .7*t*D;                              // step forward = dist to obj\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wssfWX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WssfzS", "name": "rayMarch_sphere+heart", "author": "elle", "description": "SDF   -> https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nheart -> https://www.youtube.com/watch?v=aNR4n0i2ZlM", "tags": ["raymarch", "sphere", "heart"], "likes": 4, "viewed": 298, "date": "1589069117", "time_retrieved": "2024-06-20T20:09:36.016456", "image_code": "#define PI\t\t3.14159265\n#define EPS\t0.001\n#define MAX_STEPS 200\n#define MAX_DIST 100.0\n#define BOARD_SQUARE 1.0\n#define SPHERE1 0\n#define SPHERE2 1\n#define SPHERE3 2\n#define HEART\t3\n#define PLANE\t4\n\n\nstruct Intersect {\n    int\t\tidx;\n    float\tdist;};\n\nstruct Point\t{\n\tvec3\tpos;\n    vec3\tcol;};\n    \nvec3 diffCol[] = vec3[](vec3(0.0, 0.0, 1.0),\n\t\t\t\t\t\tvec3(1.0, 0.0, 1.0),\n\t\t\t\t\t\tvec3(0.0, 1.0, 0.3),\n\t\t\t\t\t\tvec3(1.0, 0.1, 0.1));\n\nfloat diff[] =  float[](0.4, 0.5,  0.4,  0.8,  0.7);\nfloat spec[] =  float[](0.9, 1.2,  1.1,  1.9,  0.3);\nfloat specPow[]=float[](8.0, 16.0, 16.0, 32.0, 4.0);\n\nvec3 lightPos = vec3(-3.0, 3.0, 5.0);\n\nfloat sphereDist(in vec3 pos, in float radius, in vec3 center)\n{\n    return (length(pos + center) - radius);\n}\n\nfloat planeDist(in vec3 pos, in vec4 normal)\n{\n    return (dot(pos, normal.xyz) + normal.w);\n}\n\nfloat heartDist(vec3 q, float r)\n{\n    float ani = pow(0.5 + 0.5 * sin(7.0 * iTime + q.y / 20.0), 4.0);\n    q *= 1.0 - 0.2 * vec3(1.0,0.5,1.0)*ani;\n    q.y -= 0.2 * ani;\n    float x = abs(q.x);\n        \n    float y = q.y;\n    float z = q.z;\n    y = -0.5 + y * 1.2 - x * sqrt(max((5.0 - x) / 10.0, 0.0));\n    float res = sqrt(x*x + y*y + z*z) - r;\n    return res;\n}\n\n\nIntersect sceneDist(vec3 pos)\n{\n\tfloat SINt = sin(iTime);\n    float SINt03 = sin(iTime * 0.3);\n    float COSt03 = cos(iTime * 0.3);\n    float sphereD1_1 = sphereDist(pos, 1.8, vec3(0, 0.1, 0));\n\tfloat sphereD1_2 = sphereDist(pos, 1.8, vec3(0, 0.1 - 2.0*(0.5 + 0.5 * SINt), 0));\n    float sphereD2 = sphereDist(pos, 0.7, vec3(2.8 * COSt03, SINt, 2.8 * SINt03));\n    float sphereD3 = sphereDist(pos, 0.5, vec3(3.8 * SINt03, cos(iTime), 3.8 * COSt03));\n    float planeD = planeDist(pos, vec4(0.0, 1.0, 0.0, 2.2));\n    float heartD = heartDist(pos, 0.5);\n    Intersect res;\n    \n    // hollow sphere\n\tsphereD1_1 = abs(sphereD1_1) - 0.03;\n\tsphereD1_1 = max(sphereD1_1, pos.y);\n\tsphereD1_2 = abs(sphereD1_2) - 0.03;\n\tsphereD1_2 = max(sphereD1_2, - (pos.y - 2.0 * (0.5 + 0.5 * SINt)));\n\n    res.dist = min(min(min(min(min(sphereD1_1, sphereD1_2), sphereD2), sphereD3), planeD), heartD);\n    if (res.dist == sphereD1_1 || res.dist == sphereD1_2)\n        res.idx = SPHERE1;\n    else if (res.dist == sphereD2)\n\t\tres.idx = SPHERE2;\n    else if (res.dist == sphereD3)\n\t\tres.idx = SPHERE3;\n    else if (res.dist == heartD)\n        res.idx = HEART;     \n    else\n        res.idx = PLANE;\n    return (res);\n}\n\nvec3 getNormal(vec3 p)\n{\n    return normalize(vec3(\n    sceneDist(vec3(p.x + EPS, p.y, p.z)).dist - sceneDist(vec3(p.x - EPS, p.y, p.z)).dist,\n    sceneDist(vec3(p.x, p.y + EPS, p.z)).dist - sceneDist(vec3(p.x, p.y - EPS, p.z)).dist,\n    sceneDist(vec3(p.x, p.y, p.z  + EPS)).dist - sceneDist(vec3(p.x, p.y, p.z - EPS)).dist));\n}\n\nIntersect rayMarch(vec3 ro, vec3 rd)\n{\n    Intersect d;\n    Intersect intersect;\n    for (int i = 0; i < MAX_STEPS; ++i)\n    {\n        d = sceneDist(ro + intersect.dist * rd);\n        intersect.dist += d.dist;\n        if (intersect.dist < EPS || intersect.dist >= MAX_DIST)\n            break;\n    }\n    intersect.idx = d.idx;\n    return (intersect);\n}\n\nfloat getShadow(in vec3 ro, in vec3 rd, in float min_t, in float max_t, in float k)\n{\n    float res = 1.0;\n    for (float t = min_t; t < max_t;)\n    {\n        float dist = sceneDist(ro + rd * t).dist;\n        if (dist < EPS)\n            return 0.0;\n        res = min(res, k * dist / t);\n        t += dist;\n    }\n    return (res);\n}\n\nvec3 boardColor(vec3 p)\n{\n    vec3 pos = vec3(p.x, p.y, p.z - (0.7 * iTime));\n    \n    if ((mod(pos.x,(BOARD_SQUARE * 2.0)) < BOARD_SQUARE && mod(pos.z,(BOARD_SQUARE * 2.0)) > BOARD_SQUARE) ||\n        (mod(pos.x,(BOARD_SQUARE * 2.0)) > BOARD_SQUARE && mod(pos.z,(BOARD_SQUARE * 2.0)) < BOARD_SQUARE))\n\t\treturn vec3(1.0);\n    else\n\t\treturn vec3(0.0);\n}\n\nvec3 getLight(int idx, vec3 pos, vec3 eye)\n{\n    vec3 diffuseCol;\n    if (idx == PLANE)\n        diffuseCol = boardColor(pos);\n    else\n        diffuseCol = diffCol[idx];\n    vec3 specularCol = vec3(1.0);\n    vec3 Norm = getNormal(pos);\n    vec3 Ldir = normalize(lightPos - pos);\n    vec3 View = normalize(eye - pos);\n    vec3 Refl = normalize(reflect(-Ldir, Norm));\n\n    float dotLN = dot(Ldir, Norm);\n    float dotRV = dot(Refl, View);\n\n    // light not visible\n    if (dotLN < 0.0)\n        return vec3(0.0);\n\n    // light reflection in opposite direction, apply only diffuse lighting\n    if (dotRV < 0.0)\n        return 1.7 * (diffuseCol * dotLN) * diff[idx];\n\n    vec3 half_direction = normalize(normalize(Ldir) + View);\n    float specular = pow(max(dot(half_direction, Norm), 0.0), specPow[idx]);\n    return 1.7 * diffuseCol * dotLN * diff[idx] + specularCol * specular * spec[idx];\n}\n\nPoint getColor(vec3 ro, vec3 rd, vec3 eye)\n{\n    Point point;\n    Intersect intersect = rayMarch(ro, rd);\n    point.pos = ro + intersect.dist * rd;\n    if (intersect.dist > MAX_DIST - EPS)\n        point.col = vec3(0.0, 0.0, 1.0 - 2.0 * rd.y); //background\n    else\n    {    \n\t\t//ambient\n        vec3 ambientCol = vec3(0.2, 0.4, 0.7);    \n    \tvec3 ambientLight = 0.25 * vec3(1.0);\n    \tpoint.col = ambientLight * ambientCol;\n\n    \t//shadow\n    \tvec3 shadowDir = normalize(lightPos - point.pos);\n    \tfloat shadow = getShadow(point.pos + shadowDir, shadowDir, 0.0, MAX_DIST, 8.0);\n\n    \t//diffuse + specular\n    \tvec3 blinn_phong = getLight(intersect.idx, point.pos, eye) * shadow;\n    \tpoint.col += blinn_phong;\n    }\n    return point;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 aspectRatio = vec2(iResolution.x / iResolution.y, 1.0);\n    vec2 uv = aspectRatio * (fragCoord.xy / iResolution.xy - 0.5);\n    vec2 mouse = 4.0 * (iMouse.xy / iResolution.xy);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    vec3 ro = vec3(mouse.x, mouse.y, 8.0);\n\n    Point point = getColor(ro, rd, ro);\n\tvec3 color = point.col;   \n    \n    vec3 rd1 = rd - (2.0 * dot(rd, getNormal(point.pos)) * getNormal(point.pos));\n    Point point2 = getColor(point.pos + rd1, rd1, ro);\n    color = mix(color, point2.col, 0.22);\n    \n    vec3 rd2 = rd1 - (2.0 * dot(rd1, getNormal(point2.pos)) * getNormal(point2.pos));\n    Point point3 = getColor(point2.pos + rd2, rd2, ro);\n    color = mix(color, point3.col, 0.12);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WssfzS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsSfzz", "name": " Various Spider Silk Shapes", "author": "kass", "description": "hey", "tags": ["glsl"], "likes": 4, "viewed": 203, "date": "1589337020", "time_retrieved": "2024-06-20T20:09:36.016456", "image_code": "float uvrand(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = gl_FragCoord.xy;\n\n    const float pi = 3.1415926;\n    float t = floor(iTime * 1.1) * 7.3962;\n\n    vec2 sc = (coord.xy - iResolution.xy / 2.0) / iResolution.y;\n    float phi = atan(sc.y, sc.x + 1e-6);\n    vec2 pc = vec2(fract(phi / (pi * 2.f)), length(sc));  //æ¥µåº§æ¨\n    \n    // æ¾å°\n    float h_divnum = 5. + 10.*abs(sin(float(int(iTime))));\n    float s_divnum = 5. + 10.*abs(sin(float(int(iTime))));\n    \n    float ddth = fract(pc.x * h_divnum);\n    \n    // æ¾å°åºåããã¨ã®ã©ã³ãã å¤\n    float h_id = (pc.x * h_divnum) - fract(pc.x * h_divnum); \n    float h_rand = uvrand(vec2(h_id,int(iTime)));\n    \n    // åå¿ååºåããã¨ã®ã©ã³ãã å¤\n    float s_id  = (pc.y * s_divnum) - fract(pc.y * s_divnum); \n    int   is_id = int(s_id);   \n    \n    float s_rand = uvrand(vec2(float(s_id),int(iTime)));\n    \n\n    \n    // æ¨ªç·ããã¾ã\n    float l = pc.y+ ddth * (h_rand - 0.5) + ddth*(s_rand - 0.5)*0.2 ;\n    \n    // æ¾å°ã»åå¿å\n    \n    float thickness = 0.5- pc.y + (s_rand*0.1 + h_rand*0.1) + (0.02*sin((h_rand)*iTime*10.f)); // å¾®å¦\n    \n    float a = step(abs(sin( ( pc.x*pi*2.f  )  * s_divnum )),thickness * 0.5);\n    float b = step(abs(sin( ( pc.y*pi*2.f + h_rand + l)  * h_divnum )),thickness*0.5 );\n    \n    fragColor = vec4(a+b,a+b,a+b,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsSfzz.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wst3zl", "name": "gears by sid", "author": "sidchou", "description": "gears", "tags": ["gears"], "likes": 4, "viewed": 53, "date": "1590327314", "time_retrieved": "2024-06-20T20:09:36.016456", "image_code": "//https://thebookofshaders.com/07/\n\n\nfloat gear (vec2 uv, float r, float a)\n{\n     float rr = length(uv)*2./r;\n\t a = atan(uv.y,uv.x)+a/r;\n\tfloat f = smoothstep(-.5,1., cos(a*r*10.))*0.2/r+0.5;\n    return 1.-smoothstep(f,f+0.02,rr)-step(length(uv),.02);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n\tvec2 pos = vec2(0.5)-uv;\n\n    pos.x *=iResolution.x/iResolution.y;\n    pos.y -= .2;\n    \n    vec3 color = vec3(0.0);\n\n    //float r = length(pos)*2.0;\n    //float a = atan(pos.y,pos.x);\n    //a+=iTime;\n\n     //f = cos(a*3.);\n     //f = abs(cos(a*3.));\n     //f = abs(cos(a*2.5))*.5+.3;\n     //f = abs(cos(a*12.)*sin(a*3.))*.8+.1; \n     //f = smoothstep(-.5,1., cos(a*10.))*0.2+0.5;\n    \n\tfloat f = gear(pos,.8,iTime)\n        \t+ gear(pos+vec2(-.7,.1),1.5,-iTime-.3)\n        \t+ gear(pos+vec2(.45,.45),1.2,-iTime);\n\n\n    color = vec3( f );\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wst3zl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsXBRl", "name": "Colored snowflake", "author": "codecontemplator", "description": "Build from https://www.shadertoy.com/view/tdsfz2", "tags": ["snowflake"], "likes": 2, "viewed": 88, "date": "1588803585", "time_retrieved": "2024-06-20T20:09:36.016456", "image_code": "vec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 u = 2.*(2.*fragCoord-iResolution.xy)/iResolution.y;\n    float pi = 3.14159265359;\n    float p = 1.+sin(iTime)*.15;\n    u *= p;\n    vec2 v = u;\n    float e = -4.;\n    for(float i = 0.; i < 3.; ++i)\n    {\n        //u = sin(atan(u.y,u.x)*e+vec2(0.,pi*.5))*pow(length(u),-1.+4./(e+1.));\n        float ttt = (1.0+0.1*sin(iTime))*pi;\n        vec2 ooo = vec2(pi*0.5*sin(ttt),pi*.5*cos(ttt));\n        float div = 1.1; // + .6* sin(iTime);\n        u = sin(atan(u.y,u.x)*e+ooo)*pow(length(u),-1.+4./div);//(e+1.+xxx));\n        //u = sin(atan(u.y,u.x)*e+vec2(pi*.5*sin(iTime),pi*.5*cos(iTime)))*pow(length(u),-1.+4./(e+1.));\n\n\n        u+= v/p;\n    }\n    \n    float iTime2 = 0.5 + 0.25*sin(iTime);// 0.2*pi;\n    u = vec2(u.x*cos(iTime2),u.y*sin(iTime2));\n    vec3 hsl = vec3(\n        .5+.4*sin(2.*iTime+length(u*2.)), \n        .7+.2*cos(3.*iTime+length(u*2.)), \n        exp(dot(u,u)*-.1));\n    vec3 rgb = hsv2rgb(hsl);\n    fragColor = vec4(rgb, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsXBRl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsXBRS", "name": "Look mum, I drew a circle!", "author": "matthewspear", "description": "First time trying out shader toys, so I drew a circle :)", "tags": ["circle"], "likes": 0, "viewed": 59, "date": "1588436793", "time_retrieved": "2024-06-20T20:09:36.240578", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // background colour\n    vec3 col = vec3(0.94,0.94,0.94);\n\n    vec2 midPoint = iResolution.xy / 2.0;\n    \n    // Move position with time\n    //midPoint.x += 100.0 * cos(iTime);\n    //midPoint.y += 50.0 * cos(iTime);\n    \n    float distance = distance(fragCoord, midPoint);\n    \n    if (distance < 100.0) {\n        // Just red\n    \t//col = vec3(1.0, 0.0, 0.0);\n        \n        // Time varying pixel color\n        col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    }\n\t    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}\n\n//float distance(vec2 a, vec2 b) {\n//    float dX = a.x - b.x;\n//    float dY = a.y - b.y;\n//\treturn sqrt(dX*dX + dY*dY);\n//}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsXBRS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsXBWS", "name": "Comic Blobs", "author": "blackle", "description": "fiddling with different sampling methods to get cool effects", "tags": ["blobs", "npr", "comic"], "likes": 60, "viewed": 2432, "date": "1588966557", "time_retrieved": "2024-06-20T20:09:36.864902", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nfloat bayer(ivec2 uv) {\n    return texelFetch(iChannel0,uv % 8,0).x;\n}\n\n#define FK(k) floatBitsToInt(cos(k))^floatBitsToInt(k)\nfloat hash(vec2 k) {\n  int x = FK(k.x);int y = FK(k.y);\n  return float((x*x-y)*(y*y+x)-x)/2.14e9;\n}\n\nfloat hash3(vec3 k) {\n  float h1 = hash(k.xy);\n  return hash(vec2(h1, k.z));\n}\n\nvec3 hash33(vec3 k) {\n  float h1 = hash3(k);\n  float h2 = hash3(k*h1);\n  float h3 = hash3(k*h2);\n  return vec3(h1, h2, h3);\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nvec3 sphercoord(vec2 p) {\n  float l1 = acos(p.x);\n  float l2 = acos(-1.)*p.y;\n  return vec3(cos(l1), sin(l1)*sin(l2), sin(l1)*cos(l2));\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(p,ax)*ax, p, cos(ro)) + sin(ro)*cross(p,ax);\n}\n\nfloat comp(vec3 p, vec3 ro, float t) {\n  vec3 ax = sphercoord(ro.xy);\n  p.z -= t;\n  p = erot(p, ax, ro.z*acos(-1.));\n  float scale = 4. + hash(ro.xz)*0.5+0.5;\n  p = (fract(p/scale)-0.5)*scale;\n  return length(p) - 0.8;\n}\n\nfloat scene(vec3 p) {\n  float rad = 3.+p.z+sin(p.y/2.+iTime)+cos(p.x/3.+iTime*0.9);\n  float dist = 10000.;\n  for (int i = 0; i < 4; i++) {\n    vec3 rot = hash33(vec3(float(i+1), cos(float(i)), sin(float(i))));\n    float d = comp(p, rot, iTime/2.*(float(i+1)));\n    dist = smin(dist, d, 1.);\n  }\n  return mix(dist, rad, mix(0.3,0.8+sin(iTime)*0.2, 0.1));\n}\n\nvec3 norm(vec3 p) {\n  mat3 k = mat3(p,p,p)-mat3(0.1);\n  return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nfloat march(vec3 p, vec3 bias, float seed) {\n    for (int i = 0; i < 10; i++) {\n        p += normalize(bias+tan(hash33(vec3(float(i),seed,2.))))*scene(p);\n    }\n    return sqrt(smoothstep(0.0,2.0,scene(p)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  \n  vec3 cam = normalize(vec3(4.,uv));\n  vec3 init = vec3(-50,0,sin(iTime*0.37)*1.4);\n  cam = erot(cam, vec3(0,1,0), -0.5);\n  init = erot(init, vec3(0,1,0), -0.5);\n\n  vec3 p = init;\n  bool hit = false;\n  bool trig = false;\n  bool outline = false;\n  for (int i = 0; i < 500 && !hit; i++) {\n    float dist = scene(p);\n    if (dist<0.08) trig = true;\n    if (trig) {\n      float odist = 0.09-dist;\n      outline = odist<dist;\n      dist = min(dist,odist);\n    }\n    hit = dist*dist < 1e-6;\n    p += dist*cam;\n  }\n  vec3 n = norm(p);\n  vec3 r = reflect(cam,n);\n  vec2 ao = vec2(0);\n  for (int i = 0; i < 8; i++) {\n    ivec2 id = (ivec2(fragCoord/16.+vec2(iTime*10.,iTime*20.)) % 2)*2-1;\n    ao += vec2(march(p+n*0.1, r, bayer(ivec2(fragCoord)+i+ivec2(i/4,0))) , 1.);\n  }\n  ao.x/=ao.y;\n\n  fragColor.xyz = hit&&!outline ? vec3(ao.x) : vec3(0.);\n  fragColor.xyz = pow(smoothstep(vec3(0),vec3(1),sqrt(fragColor.xyz)),vec3(1.7,1.6,1.5));\n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc0-1.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsXBWS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsXBzS", "name": "Demoscene museum", "author": "friol", "description": "A strange museum with strange objects. Ticket is 50$.", "tags": ["metaballs", "refraction", "plasma", "demoscene"], "likes": 17, "viewed": 485, "date": "1588718200", "time_retrieved": "2024-06-20T20:09:40.592474", "image_code": "\n//\n// friol 2o2o\n// Now that the demoscene is cultural heritage of humanity (at least in Finland)\n// I imagined how a demoscene museum would look like and what would would you find in there\n// sdf functions&ao by iq\n// plasma cube inspiration from patu https://www.shadertoy.com/view/4d3SRN\n// some materials taken from https://www.shadertoy.com/view/WslfD7\n// music by Salidad -> https://soundcloud.com/salidad\n//\n\nconst int iterationAmount=1024*3;\n\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nvec3 rotx(in vec3 p, float a) \n{\n\treturn vec3(p.x,\n                cos(a) * p.y + sin(a) * p.z,\n                cos(a) * p.z - sin(a) * p.y);\n}\n\nvec3 roty(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.z,\n                p.y,\n                cos(a) * p.z - sin(a) * p.x);\n}\n\nvec3 rotz(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.y,\n                cos(a) * p.y - sin(a) * p.x,\n                p.z);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdAmigahSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdInvertedBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return -length(max(q,0.0)) - min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTwistingBox( vec3 p, vec3 b, float r )\n{\n\tp=rotx(p,2.0*sin(iTime)*sin(.92*p.x+iTime/2.0));\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdPlasmaCube( vec3 p, vec3 b, vec3 shift )\n{\n  p=rotx(p,iTime);\n  p=roty(p,iTime);\n  p+=shift;\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  p=roty(p,iTime+3.141592/2.0);\n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\n\n//#define FK(k) floatBitsToInt(cos(k))^floatBitsToInt(k)\n#define FK(k) int(cos(k))*int(k)\nfloat hash(float a, float b) {\n    int x = FK(a);int y = FK(b);\n    return float((x*x-y)*(y*y+x)-x)/2.14e9;\n}\n\nfloat noise(vec2 p) \n{\n    vec2 id = floor(p);\n    vec2 crds = fract(p);\n    float h1 = hash(id.x,id.y);\n    float h2 = hash(id.x+1.,id.y);\n    float h3 = hash(id.x,id.y+1.);\n    float h4 = hash(id.x+1.,id.y+1.);\n    return mix(mix(h1,h2,crds.x),mix(h3,h4,crds.x),crds.y);\n}\n\nfloat triplanar(vec3 p, vec3 n) \n{\n    return mix(noise(p.xy), mix(noise(p.xz), noise(p.yz), n.x*n.x), 1.-n.z*n.z);\n}\n\nfloat dot2( vec2 v ) { return dot(v,v); }\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\n//\n//\n//\n\nfloat mapBin(vec3 r)\n{\n    //r*=1.55;\n\tfloat mainCone=sdCappedCone(r-vec3(0.0,-0.4,0.0),.6,  0.5,0.7);\n    float innerCone=sdCappedCone(r-vec3(0.0,-0.25,0.0),.55,0.45,0.65);\n    float t=opSubtraction(innerCone,mainCone);\n    //float t=100.0;\n    \n    vec3 capsr=r;\n    \n    const float PI=3.141592;\n    const float TWOPI=PI*2.0;\n    for (float i=0.0;i<TWOPI;i+=PI/18.0)\n    {\n        vec3 realcapsr=roty(capsr,i);\n    \trealcapsr=rotz(realcapsr,-0.15);\n        float caps=sdVerticalCapsule(realcapsr-vec3(0.60,-0.63,0.0),0.9,0.06);\n        t=opSubtraction(caps,t);\n        //t=min(t,caps);\n    }\n\n    return t;\n}\n\nfloat mapDemosceneLogo(vec3 r)\n{\n    //r*=1.55;\n    float t=10000.0;\n    \n    r=rotx(r,0.25);\n    r=rotz(r,-0.5);\n    \n    float spessore=0.05;\n    \n    float horz1=sdBox(r-vec3(0.0,0.85,0.0),vec3(0.3,spessore,spessore));\n    t=min(t,horz1);\n    float horz2=sdBox(r-vec3(0.0,0.6,0.0),vec3(0.3,spessore,spessore));\n    t=min(t,horz2);\n    float horz3=sdBox(r-vec3(0.0,0.35,0.0),vec3(0.3,spessore,spessore));\n    t=min(t,horz3);\n    \n    float vertleft=sdBox(r-vec3(-0.25,0.80,0.0),vec3(spessore,0.25,spessore));\n    t=min(t,vertleft);\n    float vertright=sdBox(r-vec3(0.25,0.80,0.0),vec3(spessore,0.25,spessore));\n    t=min(t,vertright);\n    float vertcenter=sdBox(r-vec3(0.0,0.25,0.0),vec3(spessore,0.3,spessore));\n    t=min(t,vertcenter);\n    \n    return t;\n}\n\n// returns: t, material, hit type (0.0 solid, 1.0 transparent)\n\nvec3 SDF(vec3 r)\n{\n    float amt=9.0; // bump amount on glass panels\n    float t=0.0;\n    float mat=0.0;\n    vec3 origR=r;\n\n    vec3 boxR=r-vec3(0.0,0.0,0.0);\n    t=sdInvertedBox(boxR,vec3(4.0,2.5,35.0));\n    \n    //float domainRep=3.7;\n    //vec3 c=vec3(domainRep);\n    //r = mod(r+0.5*c,c)-0.5*c;\n    \n    // little boxes+balls at the entrance\n    float pyrh=1.1;\n    float pyr1=sdBox(r-vec3(3.0,-2.5,-5.0),vec3(.55,0.25,0.55));\n    t=min(t,pyr1);\n    \n    float pyr2=sdBox(r-vec3(-3.0,-2.5,-5.0),vec3(.55,0.25,0.55));\n    t=min(t,pyr2);\n\n    float container1=sdRoundBox(r-vec3(3.0,-1.7,-5.0),vec3(.5,.5,.5),0.1);\n    float innerBox1=sdBox(r-vec3(3.0,-1.7,-5.0),vec3(.49));\n    container1=opSubtraction(innerBox1,container1);\n    t=min(t,container1);\n\n    float container2=sdRoundBox(r-vec3(-3.0,-1.7,-5.0),vec3(.5,.5,.5),0.1);\n    float innerBox2=sdBox(r-vec3(-3.0,-1.7,-5.0),vec3(.49));\n    container2=opSubtraction(innerBox2,container2);\n    t=min(t,container2);\n    \n    float amigaball1=sdAmigahSphere(r-vec3(3.0,-1.7+0.05*sin(iTime*2.0),-5.0),0.45);\n    t=min(t,amigaball1);\n\n    float amigaball2=sdAmigahSphere(r-vec3(-3.0,-1.7+0.05*sin(iTime*2.0),-5.0),0.45);\n    t=min(t,amigaball2);\n    \n    // metaballs\n    \n    float mbz=11.0;\n    float mbally=0.0;\n    if (iTime>32.0) mbally=(iTime-32.0)/2.5;\n    \n    float backS=sdSphere(r-vec3(1.7*sin(iTime),-.7*sin(iTime)+mbally,mbz),.76);\n    backS+=(.04)*sin(r.x*9.0)*(sin(r.y*9.0))*cos(r.z*9.0);\n\n    float backS2=sdSphere(r-vec3(-1.0*cos(iTime),-.1+mbally,mbz),.86);\n    backS2+=(.04)*sin(r.x*9.0)*(sin(r.y*9.0))*cos(r.z*9.0);\n\n    float backS3=sdSphere(r-vec3(-1.0*sin(iTime),-.7*cos(iTime)+mbally,mbz),.76);\n    backS3+=(.04)*sin(r.x*9.0)*(sin(r.y*9.0))*cos(r.z*9.0);\n    \n    float metaballs=opSmoothUnion(opSmoothUnion(backS,backS2,0.5),backS3,0.5);\n    t=min(t,metaballs);\n    \n    // twisting block\n    vec3 tbr=r;\n    float tblockpos=.5;\n\n    float spikeAmt=6.0;\n    float tblocky=0.0;\n    if (iTime>25.0) tblocky=1.5*sin((iTime-25.0)/2.3);\n    float tblock=sdTwistingBox(tbr-vec3(iTime/4.0,tblocky,2.0+tblockpos),vec3(17.0,.87,.87),0.1);\n    tblock+=(.12)*sin(r.x*spikeAmt)*(.52*sin(r.y*spikeAmt))*(.52*cos(r.z*spikeAmt));\n    t=min(t,tblock);\n\n    float trashbin=10000.0;\n    float merlogo=10000.0;\n    \n    if (iTime>24.0)\n    {        \n        // biiin\n        float binx=3.2;\n        float binz=14.5;\n        trashbin=mapBin(r-vec3(binx,-1.5,binz));\n        t=min(t,trashbin);\n        // random demoscene logo\n        merlogo=mapDemosceneLogo(r-vec3(binx-0.21,-1.7,binz-0.1));\n        t=min(t,merlogo);\n    }\n    \n    // cyboman's torus (not really)\n    vec3 rottor=r;\n    float cybotorus=sdTorus(rottor-vec3(0.0,-.5,21.0),vec2(1.5,.5));\n    cybotorus+=(.04)*sin(r.x*amt)*(sin(r.y*amt))*cos(r.z*amt);\n    t=min(t,cybotorus);\n    \n    // plasmacube from 2nd reality\n    float cubeZ=27.0;\n    float cubeBase=sdBox(r-vec3(0.0,-1.96,cubeZ),vec3(1.35,1.07,1.35));\n    t=min(t,cubeBase);\n    \n    vec3 rcubed=r;\n    float cubeSide=0.52;\n    \n    //float innerCube=sdBox(rcubed-vec3(0.0,0.0,cubeZ-cubeSide/2.0),vec3(cubeSide-0.1,cubeSide-0.1,cubeSide-0.1));\n    \n    float sideProf=0.32;\n    float pcube0=sdPlasmaCube(rcubed-vec3(0.0,0.0,cubeZ-cubeSide/2.0),\n                              vec3(cubeSide,cubeSide,sideProf),\n                              vec3(0.0,0.0,-cubeSide/2.5));\n    float pcube1=sdPlasmaCube(rcubed-vec3(0.0,0.0,cubeZ-cubeSide/2.0),\n                              vec3(cubeSide,cubeSide,sideProf),\n                              vec3(0.0,0.0,cubeSide/2.5));\n    float pcube2=sdPlasmaCube(rcubed-vec3(0.0,0.0,cubeZ-cubeSide/2.0),\n                              vec3(cubeSide,sideProf,cubeSide),\n                              vec3(0.0,cubeSide/2.5,0.0));\n    float pcube3=sdPlasmaCube(rcubed-vec3(0.0,0.0,cubeZ-cubeSide/2.0),\n                              vec3(cubeSide,sideProf,cubeSide),\n                              vec3(0.0,-cubeSide/2.5,0.0));\n    float pcube4=sdPlasmaCube(rcubed-vec3(0.0,0.0,cubeZ-cubeSide/2.0),\n                              vec3(sideProf,cubeSide,cubeSide),\n                              vec3(-cubeSide/2.5,0.0,0.0));\n    float pcube5=sdPlasmaCube(rcubed-vec3(0.0,0.0,cubeZ-cubeSide/2.0),\n                              vec3(sideProf,cubeSide,cubeSide),\n                              vec3(cubeSide/2.5,0.0,0.0));\n    t=min(t,pcube0);\n    t=min(t,pcube1);\n    t=min(t,pcube2);\n    t=min(t,pcube3);\n    t=min(t,pcube4);\n    t=min(t,pcube5);\n\n    float container3=sdRoundBox(r-vec3(0.0,-0.1,cubeZ),vec3(1.25,1.25,1.25),0.1);\n    float innerBox3=sdBox(r-vec3(0.0,-0.1,cubeZ),vec3(1.15,1.15,1.15));\n    container3=opSubtraction(innerBox3,container3);\n    t=min(t,container3);\n    //float container3=1000.0;\n    \n    //\n    // glass panels\n    //\n\n    float boxxpos=3.0;\n    float glass0z=0.0;\n    if (iTime>11.0) boxxpos+=iTime-11.0;\n    float rbox=sdRoundBox(r-vec3(boxxpos,-0.1,glass0z),vec3(3.0,4.6,0.1),0.1);\n    rbox+=(.04)*sin(r.x*amt)*(sin(r.y*amt))*cos(r.z*amt);\n    t=min(t,rbox);\n\n    float rbox2=sdRoundBox(r-vec3(-boxxpos,-0.1,glass0z),vec3(3.0,4.6,0.1),0.1);\n    rbox2+=(.04)*sin(r.x*amt)*(sin(r.y*amt))*cos(r.z*amt);\n    t=min(t,rbox2);\n\n    float boxxpos2=3.0;\n    float glass1z=8.0;\n    if (iTime>26.5) boxxpos2+=iTime-26.5;\n    float rbox3=sdRoundBox(r-vec3(boxxpos2,-0.1,glass1z),vec3(3.0,4.6,0.1),0.1);\n    rbox3+=(.04)*sin(r.x*amt)*(sin(r.y*amt))*cos(r.z*amt);\n    t=min(t,rbox3);\n\n    float rbox4=sdRoundBox(r-vec3(-boxxpos2,-0.1,glass1z),vec3(3.0,4.6,0.1),0.1);\n    rbox4+=(.04)*sin(r.x*amt)*(sin(r.y*amt))*cos(r.z*amt);\n    t=min(t,rbox4);\n\n    float boxxpos3=3.0;\n    float glass2z=16.0;\n    if (iTime>36.0) boxxpos3+=iTime-36.0;\n    float rbox5=sdRoundBox(r-vec3(boxxpos3,-0.1,glass2z),vec3(3.0,4.6,0.1),0.1);\n    rbox5+=(.04)*sin(r.x*amt)*(sin(r.y*amt))*cos(r.z*amt);\n    t=min(t,rbox5);\n\n    float rbox6=sdRoundBox(r-vec3(-boxxpos3,-0.1,glass2z),vec3(3.0,4.6,0.1),0.1);\n    rbox6+=(.04)*sin(r.x*amt)*(sin(r.y*amt))*cos(r.z*amt);\n    t=min(t,rbox6);\n\n    float boxxpos4=3.0;\n    float glass3z=25.0;\n    if (iTime>44.0) boxxpos4+=iTime-44.0;\n    float rbox7=sdRoundBox(r-vec3(boxxpos4,-0.1,glass3z),vec3(3.0,4.6,0.1),0.1);\n    rbox7+=(.04)*sin(r.x*amt)*(sin(r.y*amt))*cos(r.z*amt);\n    t=min(t,rbox7);\n\n    float rbox8=sdRoundBox(r-vec3(-boxxpos4,-0.1,glass3z),vec3(3.0,4.6,0.1),0.1);\n    rbox8+=(.04)*sin(r.x*amt)*(sin(r.y*amt))*cos(r.z*amt);\n    t=min(t,rbox8);\n    \n    // calc materials\n    \n    if (t==metaballs) return vec3(t,2.0,0.0);\n    if (t==tblock) return vec3(t,3.0,0.0);\n    if ((t==container1)||(t==container2)||(t==container3)) return vec3(t,7.0,1.0);\n    if ((t==rbox)||(t==rbox2)||(t==rbox3)||(t==rbox4)||(t==rbox5)||(t==rbox6)||(t==rbox7)||(t==rbox8)) return vec3(t,0.0,1.0);\n    if ((t==pyr1)||(t==pyr2)||(t==cubeBase)) return vec3(t,5.0,0.0);\n    if ((t==amigaball1)||(t==amigaball2)) return vec3(t,6.0,0.0);\n    if (t==cybotorus) return vec3(t,4.0,0.0);\n    if ((t==pcube0)||(t==pcube1)) return vec3(t,8.0,0.0);\n    if ((t==pcube2)||(t==pcube3)) return vec3(t,8.1,0.0);\n    if ((t==pcube4)||(t==pcube5)) return vec3(t,8.2,0.0);\n    if (t==trashbin) return vec3(t,9.0,0.0);\n    if (t==merlogo) return vec3(t,10.0,0.0);\n    \n    return vec3(t,1.0,0.0);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor, float h )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    pos.y+=h;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = SDF( aopos )[0];\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\nvec3 calcNormal(vec3 pos)\n{\n\tvec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3(( mod(float((i+3)/2),2.0) ),(mod(float(i/2),2.0)),(mod(float(i),2.0)))-1.0);\n        n += e*SDF(pos+0.0005*e)[0];\n    }\n    return normalize(n);\n}\n\nvec4 castRay(vec3 rayOrigin, vec3 rayDir)\n{\n    float t=0.0;\n    float trasp=0.0;\n    bool refrakkted=false;\n    vec3 rd=rayDir;\n    for (int i=0;i<iterationAmount;i++)\n    {\n        vec3 res = SDF(rayOrigin + rd * t);\n        if (res[0] < (0.0001*t))\n        {\n            if (res[2]==0.0)\n            {\n            \treturn vec4(t,res[1],trasp,0.0);\n            }\n            else\n            {\n                if (!refrakkted)\n                {\n                    vec3 hitNorm=calcNormal(rayOrigin+rd*t);\n                    vec3 newdir;\n                    if (res[1]==7.0) newdir=rd; // don't refract the thecas\n                    else newdir=refract(rd,hitNorm,0.90);\n                    rd=newdir;\n                    trasp=t;\n                    refrakkted=true;\n                }\n            }\n        }\n\n        if (!refrakkted) t+=res[0];\n        else t += 0.02;\n    }\n    \n    return vec4(-1.0,-1.0,-1.0,-1.0);\n}\n\nvec3 fog(vec3 c, float dist, vec3 fxcol)\n{\n    const float FOG_DENSITY = 0.06;\n    vec3 FOG_COLOR = fxcol.xyz;\n    \n    float fogAmount = 1.0 - exp(-dist * FOG_DENSITY);\n        \n    return mix(c, FOG_COLOR, fogAmount);\n}\n\nvec3 srgb(float r, float g, float b) {\n    return vec3(r*r,g*g,b*b);\n}\nvec3 srgb(float r) {\n    return vec3(r*r);\n}\n\nvec4 cubePlasma (vec2 coord, vec3 p, int ptype) \n{\n    float \n        k = iTime * 3.0,\n        as = 4.78207464329,\n    \tfd = 12.18910931609,\n    \tas1 = 2.839499561581 / 24.0 + sin(k) * 0.02,\n    \tfd2 = 2.188989119604,\n    \tps = -5.624243766069,\n    \tps2 = 9.393007904291,\n    \tp1 = sin(k / ps) * 4.0,\n    \tp2 = sin(k / fd) * 3.0,\n    \tt3 = sin(k / fd2) + cos(as1),\n        t4 = sin(k / ps);    \n    \n    float coordDivider=32.0;\n    coord.x = floor(coord.x * coordDivider) / coordDivider;\n    coord.y = floor(coord.y * coordDivider) / coordDivider;\n    \n    float x = sin(p1 + coord.x) * sin(p2 + coord.y) + sin(t3 + coord.x) * sin(t4 + coord.y) * -p.x;\n    \n    float r,g,b;\n    \n    if (ptype==0)\n    {\n        r = (0.01 );\n        g = (0.12 + sin(x / as1)) / 2.0; \n        b = (0.97 + sin(x / as1 )) + sin(coord.y / as1) / 4.0;\n    }\n    else if (ptype==1)\n    {\n        r = (0.81 + sin(x / as1)) / 2.0;\n        g = (0.51 + sin(x / as1)) / 2.0; \n        b = (0.37 + sin(x / as1 )) + sin(coord.y / as1) / 14.0;\n    \t//r=pow(r,2.9);\n        r+=0.5;\n        g+=0.5;\n    \tg=pow(g,2.0);\n    \tb=pow(b,2.0);\n    }\n    else if (ptype==2)\n    {\n        r = (0.31 + sin(x / as1)) / 2.0;\n        g = (0.97 + sin(x / as1)) / 2.0; \n        b = (0.17 + sin(x / as1 )) + sin(coord.y / as1) / 14.0;\n    \tr=pow(r,2.9);\n    \tg=pow(g,2.0);\n    \t//b=pow(b,2.0);\n    }\n\n    r=clamp(r,0.0,1.0);\n    g=clamp(g,0.0,1.0);\n    b=clamp(b,0.0,1.0);\n    vec4 color = vec4(vec3(r,g,b), 1.0);\n    return color;\n}\n\nvec4 boxmap( in vec3 p, in float k, int ptype ) {\n    vec3 m = pow( abs(p), vec3(k) );\n\tvec4 x = cubePlasma(p.yz, p,ptype);\n\tvec4 y = cubePlasma(p.zx, p,ptype);\n\tvec4 z = cubePlasma(p.xy, p,ptype);\n\treturn (x * m.x + y * m.y + z * m.z) / (m.x + m.y + m.z);\n}\n\nvec4 render(vec3 rayOrigin, vec3 rayDir, vec2 uv, vec2 fragCoord)\n{\n    vec3 col=vec3(0.);\n    vec3 L=normalize(vec3(1.33,1.0,-1.0));\n\n    vec4 rayHit = castRay(rayOrigin, rayDir);\n    \n    float mat=rayHit[1];\n    vec3 pHit=rayOrigin+rayDir*rayHit[0];\n    vec3 N=calcNormal(pHit);\n    float dotprod=abs(dot(N,L));\n\n    if (mat==1.0)\n    {\n        float occlHeight=1.6;\n        if (pHit.z<0.0) occlHeight=0.52; // amigahballs\n        if ((pHit.z>13.5)&&(pHit.z<15.0)) occlHeight=0.5; // bin\n        if (pHit.z>16.0) occlHeight=0.2; // cybomantorus\n        float occ = calcAO( pHit, vec3(0.0,1.0,0.0),occlHeight );\n\n        vec2 a=vec2(1.0);\n        if ((N.z>0.01)||(N.z<-0.01))\n        {\n            a=vec2(\n                vec2(1.)*smoothstep(-0.05, 0.05, mod(pHit.x, 1.))*\n                smoothstep(-0.05, 0.05, mod(pHit.y, 1.)));\n        }\n        else if ((N.x>0.01)||(N.x<-0.01))\n        {\n            a=vec2(\n                vec2(1.)*smoothstep(-0.05, 0.05, mod(pHit.y, 1.))*\n                smoothstep(-0.05, 0.05, mod(pHit.z, 1.)));\n        }\n        else if ((N.y>0.01)||(N.y<-0.01))\n        {\n            a=vec2(\n                vec2(1.)*smoothstep(-0.05, 0.05, mod(pHit.x, 1.))*\n                smoothstep(-0.05, 0.05, mod(pHit.z, 1.)));\n        }\n        \n        float cenDist=distance(vec3(pHit.x,pHit.y,mod(pHit.z,6.0)),vec3(0.0,0.0,3.0));\n\n        if (pHit.z<0.0)\n        {\n            //if (iTime>4.80) col = vec3(.82-a.y,.73-a.x,0.62-a.y);\n            //else col = vec3(.4-a.x,.5-a.y,.6-a.x);\n            col = vec3(.82-a.y,.73-a.x,0.62-a.y);\n        }\n        else if ((pHit.z>=0.0)&&(pHit.z<8.0))\n        {\n            if (iTime>5.80) col = vec3(.7-a.x,.8-a.y,0.9-a.x);\n            else col = vec3(.4-a.x,.5-a.y,.6-a.x);\n        }\n        else if ((pHit.z>=8.0)&&(pHit.z<16.0))\n        {\n            if (iTime>6.80) col = vec3(.82-a.y,.73-a.x,0.62-a.y);\n            else col = vec3(.4-a.x,.5-a.y,.6-a.x);\n        }\n        else if ((pHit.z>=16.0)&&(pHit.z<25.0))\n        {\n        \tcol = vec3(.4-a.x,.5-a.y,.6-a.x);\n        }\n        else\n        {\n            if (iTime>8.80) col = vec3(.82-a.y,.73-a.x,0.62-a.y);\n        \telse col =vec3(.4-a.x,.5-a.y,.6-a.x);\n        }\n\n        col+=vec3(1.0)/cenDist*1.25;\n        if (N.y>0.01) col=mix(col,vec3(occ),0.06);\n        //col=fog(col,distance(rayOrigin,pHit)/4.0,vec3(1.,1.,1.));\n    }\n    else if (mat==2.0) // metaballs\n    {\n        dotprod+=pow(dotprod,16.0);\n        col=vec3(.85,.5,.7)*dotprod;\n\n        vec3 oldcolor = col + (col * texture(iChannel1, (mod(fragCoord, 8.0) / 8.0)).rrr);\n        col = floor(oldcolor);    \n    }\n    else if (mat==3.0) // twisting block\n    {\n        vec3 r = reflect(rayDir,N);\n        float marble = smoothstep(-0.5,0.4,triplanar(pHit*2., N));\n        float tex = max(triplanar(pHit*20., N),0.)*marble;\n        float spexex = mix(5., 6., tex);\n        float diff1 = pow(length(sin(r*2.)*0.5+0.5)/sqrt(3.),2.);\n        float diff2 = pow(length(sin(r*2.+3.5)*0.5+0.5)/sqrt(3.),2.);\n        float diff3 = pow(length(sin(r*2.5+1.)*0.5+0.5)/sqrt(3.),2.);\n        vec3 col1 = mix(srgb(0.,.05,.1), srgb(0.4,.3,1.), diff1) + pow(diff1, spexex)*1.5;\n        vec3 col2 = mix(srgb(0.1,.0,0.3), srgb(1.,.2,0.5), diff2) + pow(diff2, spexex)*1.5;\n        vec3 col3 = mix(srgb(0.33), srgb(0.2,0.9,1.), diff3) + pow(diff3, spexex)*2.5;\n        col = mat3(col2,col1,col3)*transpose(mat3(col2,col1,col3))*vec3(mix(0.3,0.1,marble));  \n        \n        if (iTime<5.80) col*=vec3(0.25);\n    }\n    else if (mat==4.0) // rolling torus\n    {\n        vec3 r = reflect(rayDir,N);\n        float marble = smoothstep(-0.5,0.4,triplanar(pHit*2., N));\n        float tex = max(triplanar(pHit*20., N),0.)*marble;\n        float spexex = mix(5., 6., tex);\n        float diff1 = pow(length(sin(r*2.)*0.5+0.5)/sqrt(3.),2.);\n        float diff2 = pow(length(sin(r*2.+3.5)*0.5+0.5)/sqrt(3.),2.);\n        float diff3 = pow(length(sin(r*2.5+1.)*0.5+0.5)/sqrt(3.),2.);\n        vec3 col1 = mix(srgb(0.2,.05,.1), srgb(0.24,.3,1.), diff1) + pow(diff1, spexex)*2.5;\n        vec3 col2 = mix(srgb(0.41,.0,0.3), srgb(0.5,.2,0.5), diff2) + pow(diff2, spexex)*2.5;\n        vec3 col3 = mix(srgb(0.33), srgb(0.02,0.3,1.), diff3) + pow(diff3, spexex)*3.5;\n        col = mat3(col2,col1,col3)*transpose(mat3(col2,col1,col3))*vec3(mix(0.3,0.1,marble));        \n    }\n    else if (mat==5.0) // ball's base\n    {\n        float occ = calcAO( pHit, vec3(0.0,1.0,0.0),0.3);\n        col=vec3(.05,.05,.05)*dotprod;\n\t\tif (N.y>0.01) col=mix(col,vec3(occ),0.06);\n    }\n    else if (mat==6.0) // amigahballs\n    {\n    \tvec3 amigaLight=normalize(vec3(1.03,1.0,-1.0));;\n        if (pHit.x>0.0) amigaLight=normalize(vec3(-1.03,1.0,-1.0));;\n        \n        vec3 N2=roty(N,iTime);\n        vec2 matuv = vec2( atan(N2.x,N2.z), acos(N2.y ) );\n        vec2 qp = floor(matuv*2.51);\n        float intensity=mod(qp.x+qp.y,2.0);\n        if (intensity==1.0) col=vec3(1.0,0.0,0.0);\n        else col=vec3(1.0);\n        float NoL = max(dot(N, amigaLight), 0.1);\n        col*=NoL;\n        col+=pow(NoL,32.0);\n\n        vec3 oldcolor = col + (col * texture(iChannel1, (mod(fragCoord, 8.0) / 8.0)).rrr);\n        col = floor(oldcolor);    \n    }\n    else if ((mat==8.0)||(mat==8.1)||(mat==8.2)) // plasmacube\n    {\n        // 2nd reality cube faces are \n        // red-yellow-black\n        // blue-white-black\n        // green-brown-black\n        \n        float cubeZ=28.0;\n        if (mat==8.0) col=boxmap(vec3(pHit.x,pHit.y,pHit.z-cubeZ),34.0,0).xyz;\n        else if (mat==8.1) col=boxmap(vec3(pHit.x,pHit.y,pHit.z-cubeZ),34.0,1).xyz;\n        else col=boxmap(vec3(pHit.x,pHit.y,pHit.z-cubeZ),34.0,2).xyz;\n        \n        //col=vec3(1.0,0.0,0.0);\n        col*=dotprod;\n    }\n    else if (mat==9.0) // trashbin\n    {\n        vec3 r = reflect(rayDir,N);\n        float marble = smoothstep(-0.5,0.4,triplanar(pHit*2., N));\n        float tex = max(triplanar(pHit*20., N),0.)*marble;\n        float spexex = mix(5., 6., tex);\n        float diff1 = pow(length(sin(r*2.)*0.5+0.5)/sqrt(3.),2.);\n        float diff2 = pow(length(sin(r*2.+3.5)*0.5+0.5)/sqrt(3.),2.);\n        float diff3 = pow(length(sin(r*2.5+1.)*0.5+0.5)/sqrt(3.),2.);\n        vec3 col1 = mix(srgb(0.05,.05,.05), srgb(0.3,.3,.3), diff1) + pow(diff1, spexex)*1.5;\n        vec3 col2 = mix(srgb(0.1,.1,0.1), srgb(.2,.2,0.2), diff2) + pow(diff2, spexex)*1.5;\n        vec3 col3 = mix(srgb(0.43,0.43,0.43), srgb(0.82,0.82,0.82), diff3) + pow(diff3, spexex)*2.5;\n        col = mat3(col2,col1,col3)*transpose(mat3(col2,col1,col3))*vec3(mix(0.3,0.1,marble));\n        col*=0.8;\n    }\n    else if (mat==10.0) // random demoscene logo\n    {\n        col=vec3(1.0,85.0/255.0,0.0)*dotprod;\n        col*=0.8;\n    }\n    else\n    {\n        col=vec3(0.0,1.0,0.0);\n    }\n    \n    if (rayHit[2]!=0.0)\n    {\n        vec3 tN=calcNormal(rayOrigin+rayDir*rayHit[2]);\n        float dotprod=max(dot(tN,L),0.0);\n        dotprod+=pow(dotprod,2.0);\n        col=mix(col,vec3(0.8,0.8,0.8)*dotprod,0.15);\n    }\n\n    col=pow(col,vec3(0.58));\n    return vec4(col,1.0);\n}\n\nvec3 getCameraRayDir(vec2 uv, vec3 camPos, vec3 camTarget)\n{\n    vec3 camForward = normalize(camTarget - camPos);\n    vec3 upz=vec3(0.,1.,0.);\n    vec3 camRight = normalize(cross(upz, camForward));\n    vec3 camUp = normalize(cross(camForward, camRight));\n     \n    float fPersp = 2.0;\n    vec3 vDir = normalize(uv.x * camRight + uv.y * camUp + camForward * fPersp);\n \n    return vDir;\n}\n\nvec2 normalizeScreenCoords(vec2 screenCoord)\n{\n    vec2 result = 2.0 * (screenCoord/iResolution.xy - 0.5);\n    result.x *= iResolution.x/iResolution.y;\n    return result;\n}\n\nfloat onelinerRandom(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = normalizeScreenCoords(fragCoord);\n\n    vec3 camPos,camTarget;\n    \n    //float fft = texture( iChannel0, vec2(0.0,0.0) ).x;\n\n    // opening fade in\n    if (iTime<10.4)\n    {\n        camPos=vec3(0.0,-1.8,-11.0+(iTime/11.0));\n        camTarget=vec3(0.0,0.0,-4.0+(iTime/11.0));\n    }\n    // panning right-left\n    else if ((iTime>=10.4)&&(iTime<20.0))\n    {\n        camPos=vec3(10.4-iTime/1.5,-1.6,-8.0);\n        camTarget=vec3(10.4-iTime/1.5,-1.6,-7.0);\n    }\n    // walkthrough\n    else if ((iTime>=20.0)&&(iTime<49.0))\n    {    \n        camPos=vec3(0.0,-0.1,-26.0+iTime);\n        camTarget=vec3(0.0,0.0,0.0+iTime);\n    }\n    else\n    {\n        camPos=vec3(0.0,-0.1,(-18.0+42.0)-(abs(.7*sin(iTime-49.0))));\n        camTarget=vec3(0.0,0.0,-18.0+42.0+2.0);\n    }\n    \n    //camPos=vec3(sin(iTime)*0.2,0.6,7.5);\n    //camTarget=vec3(0.0,0.0,9.0);\n    vec3 rayDir = getCameraRayDir(uv, camPos, camTarget);   \n    vec4 finalCol=vec4(render(camPos, rayDir,uv,fragCoord).xyz,1.0);\n    \n    // fadein\n    if (iTime<2.001)\n    {\n        finalCol=vec4(mix(finalCol.xyz,vec3(0.0),(2.0-iTime)/2.0),1.0);\n    }\n    \n    // fadeout\n    if (iTime>55.0)\n    {\n        finalCol=vec4(mix(vec3(0.0),finalCol.xyz,clamp((59.0-iTime)/4.0,0.0,1.0)),1.0);\n    }\n\n    fragColor=vec4(finalCol.rgb, 1.0);\n}\n", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}, {"id": "lt23Ww", "previewfilepath": "https://soundcloud.com/salidad/salidad-white-day", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/salidad/salidad-white-day", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsXBzS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "WsXfD7", "name": "tv display", "author": "gorgh", "description": "experiments with traditional tv display", "tags": ["2d", "lines"], "likes": 1, "viewed": 80, "date": "1588346875", "time_retrieved": "2024-06-20T20:09:40.592474", "image_code": "float Hash11(float a){\n a=sin(a*564.331)*cos(a*126.542);\n    return fract(a);\n}\nfloat disortion(vec2 uv, float h, float thickness,float sinus){\n    float res=0.;\n\tif(uv.y>h && uv.y <h+thickness)\n    res= sin(sinus*(uv.y-h));\n    if(res>.99)res=Hash11(iTime*346.221);\n    return res;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0.);\n    float line1=fract(iTime*.38)*12.-4.;\n    float line2=fract(iTime*.21)*12.-4.;  \n    float line3=fract(iTime*.11)*12.-4.;      \n\n    float scale=8.;\n   \tvec2 uvv=uv*smoothstep(-1.5,2.,length(uv))*scale;\n   \n    uvv.x-=disortion(uvv,line1,.3,14.);\n    uvv.x-=disortion(uvv,line2,.4,8.);\n    uvv.x-=disortion(uvv,line3,.2,18.);    \n\tvec2 fv=fract(uvv);\n    vec2 gv=floor(uvv);\n\n    float color=Hash11(gv.x);\n    color+=uv.x*uv.y;\n \tif(mod(uvv.y*iResolution.y/16.,2.)<=0.3)color-=.05; \n    else color+=sin(iTime)*.08+.1;\n\n    col+=vec3(color*.3,color*.9,color*.4);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/WsXfD7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "wsXfWS", "name": "Euler Spoiler", "author": "qwert33", "description": "Inspired by:\nhttps://www.youtube.com/watch?v=qu04xLNrk94\nhttps://youtu.be/ovaZ-YlAjHY?list=PLIwiAebpd5CIEPbQua9XO3iodtZ4bjWa-&t=1373\n", "tags": ["euler", "numberphile", "spoiler"], "likes": 4, "viewed": 290, "date": "1588957160", "time_retrieved": "2024-06-20T20:09:41.065269", "image_code": "const vec4 background = vec4(.2, .2, .2, 1.);\n\n// generated with https://medialab.github.io/iwanthue/\n// ordered to minimize travelling salesman distance.\nconst vec3[11] colors = vec3[11](\n    vec3(115./255., 124./255., 208./255.),\n    vec3(89./255., 51./255., 151./255.),\n    vec3(74./255., 154./255., 93./255.),\n    vec3(104./255., 180./255., 61./255.),\n    vec3(155./255., 149./255., 52./255.),\n    vec3(208./255., 133./255., 59./255.),\n    vec3(221./255., 78./255., 67./255.),\n    vec3(147./255., 56./255., 41./255.),\n    vec3(189./255., 74./255., 124./255.),\n    vec3(200./255., 90./255., 197./255.),\n    \n    vec3(115./255., 124./255., 208./255.) // first one repeated\n);\n\nint[100] outer = int[100](\n    6,7,8,0,1,2,3,4,5,9,\n    1,4,7,5,2,0,9,6,8,3,\n    3,6,4,1,8,9,5,7,0,2,\n    5,3,0,7,9,4,6,8,2,1,\n    2,8,6,9,3,5,7,1,4,0,\n    7,5,9,2,4,6,0,3,1,8,\n    4,9,1,3,5,8,2,0,6,7,\n    9,0,2,4,7,1,8,5,3,6,\n    8,1,3,6,0,7,4,2,9,5,\n    0,2,5,8,6,3,1,9,7,4 );\n\nint[100] inner = int[100](\n    4,5,6,7,8,0,1,2,3,9,\n    7,9,3,6,1,4,2,0,8,5,\n    9,2,5,0,3,1,8,7,6,4,\n    1,4,8,2,0,7,6,5,9,3,\n    3,7,1,8,6,5,4,9,0,2,\n    6,0,7,5,4,3,9,8,2,1,\n    8,6,4,3,2,9,7,1,5,0,\n    5,3,2,1,9,6,0,4,7,8,\n    2,1,0,9,5,8,3,6,4,7,\n    0,8,9,4,7,2,5,3,1,6 );\n\nvec3 color_cycled(int i) {\n    i = (i + int(iTime)) % 10;\n\t// Here we assume colors has the first one repeated rather than doing the usual mod 10;\n    float t = fract(iTime);\n    t = mix(t, smoothstep(0., 1., t), .2);\n    return mix(colors[i], colors[i+1], t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // put things into a square\n    uv.x -= .5;\n    uv.x /= iResolution.y / iResolution.x;\n    uv.x += .5;\n    \n    if (uv.x < .0 || uv.x > 1.) {\n        fragColor = background;\n        return;\n    }\n    \n    // 10x10 grid.\n    vec2 grid = uv * 10.;\n    uv = fract(grid); \n    \n    // center-based coordinates\n    uv -= .5;\n    uv = abs(uv*2.);\n    \n    vec3 col = background.rgb;\n    \n    \n    if (max(uv.x, uv.y) < 0.50) col.rgb = color_cycled(outer[int(grid.x) + 10*int(grid.y)]);\n    if (max(uv.x, uv.y) < 0.25) col.rgb = color_cycled(inner[int(grid.x) + 10*int(grid.y)]);\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/wsXfWS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Wty3zV", "name": "Vortex Dust", "author": "irwatts", "description": "Inspired by David Bruce's work on the '80s HBO intro. (https://youtu.be/agS6ZXBrcng?t=329)", "tags": ["procedural", "mask", "vortex", "sinusoidal", "dust"], "likes": 11, "viewed": 458, "date": "1590954151", "time_retrieved": "2024-06-20T20:09:41.065269", "image_code": "const int ITERATIONS = 64;\nconst float SPEED = 0.25;\nconst float PAN = 2.8;\nconst float MASK_VIS = 0.0; // Set between 0-1 to visualize masks\n\nfloat vortex(vec2 uv, float dist, float seed, float bias, float offset)\n{\n    float ang = atan(uv.y, uv.x)+sin(dist+0.1*seed)*(1.2-offset)*2.0;\n    ang += 3.14159*(0.01*seed);\n    return clamp((sin((ang)*(3.0+offset*float(ITERATIONS)))+bias)/(1.0+bias), 0.0, 1.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-vec2(iResolution.xy*0.5))/iResolution.y;\n    float texel = 1.0/iResolution.y;\n    float dist = length(uv);\n    vec3 col = vec3(0.0);\n    for (int i=0; i<ITERATIONS; i++) \n    {\n        float offset = float(i)/float(ITERATIONS);\n        float seed = 1000.0*fract(3.1379136*floor(iTime*SPEED+offset));\n        float time = fract(iTime*SPEED+offset);\n        vec2 pan = vec2(0.0, time*PAN);\n        float maskA = vortex(uv, dist, seed+100.0*float(i), -0.998+texel, offset);\n        float dist2 = length(uv+pan);\n        float maskB = vortex(uv+pan, dist2, seed+42.0*float(i), -0.99+texel, offset);\n        float radius = pow(((maskA*maskA)+(maskB*maskB)), 2.0);\n        float fade = time*(1.0-time);\n        float mask = maskA*maskB*fade*radius;\n        col = mix(col, vec3(0.42+1.0*dist-0.2*offset-0.1*radius, 0.75-0.5*offset-0.5*dist, 1.0-0.8*dist), mask);\n        col = max(vec3(maskA*MASK_VIS, maskB*MASK_VIS+0.1, max(maskA*MASK_VIS*2.0, maskB*MASK_VIS)+0.12)*fade, col);\n    }\n    fragColor = vec4(col*4.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Wty3zV.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XlyBWt", "name": "Nibble Extraction 2", "author": "BigotedSJW", "description": "a not as impressive but nevertheless more elaborate followup to https://www.shadertoy.com/view/MtfBzB\nthe fruit of ruminating over how I can hopefully squeeze down https://www.shadertoy.com/view/MtdBRS to an average of 2 bits/pixel", "tags": ["2d", "simple", "integer", "bitoperations"], "likes": 0, "viewed": 39, "date": "1588980256", "time_retrieved": "2024-06-20T20:09:41.065269", "image_code": "ivec2 dataSet = ivec2(0x01234567, 0x89ABCDEF);\n\nfloat selectFromMat(ivec2 coord, mat4x4 matrix){\n\tcoord &= 3;\n\tfloat value;\n\tswitch(coord.x){\n\t\tcase 0: value = matrix[coord.y].x; break;\n\t\tcase 1: value = matrix[coord.y].y; break;\n\t\tcase 2: value = matrix[coord.y].z; break;\n\t\tcase 3: value = matrix[coord.y].w; break;\n\t\tdefault: value = 0.0f;} \n\treturn value;\n}\n\nfloat duff(int step, mat4x4 block){\n\tfloat value = 0.;\n\tmat4x4 diffblock = block - mat4x4(8.);\n\t\n\tswitch(step & 15){\n\t\tcase 15: value += diffblock[3].w;\n\t\tcase 14: value += diffblock[3].z;\n\t\tcase 13: value += diffblock[3].y;\n\t\tcase 12: value += diffblock[3].x;\n\t\tcase 11: value += diffblock[2].w;\n\t\tcase 10: value += diffblock[2].z;\n\t\tcase  9: value += diffblock[2].y;\n\t\tcase  8: value += diffblock[2].x;\n\t\tcase  7: value += diffblock[1].w;\n\t\tcase  6: value += diffblock[1].z;\n\t\tcase  5: value += diffblock[1].y;\n\t\tcase  4: value += diffblock[1].x;\n\t\tcase  3: value += diffblock[0].w;\n\t\tcase  2: value += diffblock[0].z;\n\t\tcase  1: value += diffblock[0].y;\n\t\tcase  0: value += diffblock[0].x;\n\t}\n\treturn value;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 normUV = fragCoord.xy /iResolution.xy;\n\tivec4 shifted0 = (ivec4(dataSet.x) >> ivec4(28, 24, 20, 16)) & ivec4(15);\n\tivec4 shifted1 = (ivec4(dataSet.x) >> ivec4(12,  8,  4,  0)) & ivec4(15);\n\tivec4 shifted2 = (ivec4(dataSet.y) >> ivec4(28, 24, 20, 16)) & ivec4(15);\n\tivec4 shifted3 = (ivec4(dataSet.y) >> ivec4(12,  8,  4,  0)) & ivec4(15);\n\t\n\tmat4x4 matthew = mat4x4(shifted0, shifted1, shifted2,  shifted3);\n\t\n\tvec2 timeOffset = vec2(cos(iTime), sin(iTime))/4.;\n\n\tivec2 bigGrid = ivec2((4.* (normUV - timeOffset)) );\n\tivec2 smallGrid = ivec2((16.* (normUV + timeOffset) ));\n\tfloat value = selectFromMat(bigGrid, matthew);\n\tfloat value2 = selectFromMat(smallGrid, matthew);\n\tfloat value3 = duff(int(normUV.y * 16.) , matthew);\n\tfloat arbitraryCombination = ((value3+12.)/64.) * (value2 + value)/31.;\n    float unGamma = pow(arbitraryCombination, 0.45);\n    \n\tfragColor = vec4( unGamma );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XlyBWt.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsBGWw", "name": "barrel distortion test", "author": "Impossible", "description": "testing ovr barrel distortion", "tags": ["oculus"], "likes": 0, "viewed": 210, "date": "1590696557", "time_retrieved": "2024-06-20T20:09:41.065269", "image_code": "vec4 HmdWarpParam = vec4( 1, 0.22, 0.24, 0 );\nvec2 Scale = vec2(0.1469278, 0.2350845);\nvec2 ScaleIn = vec2(4, 2.5);\n\nvec2 HmdWarp(vec2 texIn, vec2 LensCenter)\n{\n   vec2 theta = (texIn - LensCenter) * ScaleIn;\n   float rSq = theta.x * theta.x + theta.y * theta.y;\n   vec2 theta1 = theta * (HmdWarpParam.x + HmdWarpParam.y * rSq + HmdWarpParam.z * rSq * rSq + HmdWarpParam.w * rSq * rSq * rSq);\n   return LensCenter + Scale * theta1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uvo = fragCoord.xy / iResolution.xy;\n\tvec2 uv;\n\tvec2 ScreenCenter = vec2( 0.25, 0.5 );\n\tvec2 LensCenter = vec2( 0.2863248, 0.5 );\t\n\t\n\tuv = HmdWarp(uvo,LensCenter); //gl_TexCoord[0].xy);\n   if (any(notEqual(clamp(uv, ScreenCenter-vec2(0.25,0.5), ScreenCenter+vec2(0.25, 0.5)) - uv, vec2(0.0, 0.0))))\n   {\n\t   ScreenCenter = vec2( 0.75, 0.5 );\n\t   LensCenter = vec2( 0.7136753, 0.5 );\n\t   \n\t   uv = HmdWarp(uvo,LensCenter);\n\t   \n\t    if (any(notEqual(clamp(uv, ScreenCenter-vec2(0.25,0.5), ScreenCenter+vec2(0.25, 0.5)) - uv, vec2(0.0, 0.0))))\n\t\t   fragColor = vec4(0.0, 0.0, 0.0, 1.0);\t\t\t\n\t\telse\n\t\t\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n   }\n   else\t\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsBGWw.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
