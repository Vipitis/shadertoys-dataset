{"id": "3ddyz2", "name": "Bare Skull", "author": "Yusef28", "description": "For some reason I only make shaders in the summer. This is from last summer/fall. I always become too much of a perfectionist in fall and winter to upload and then in the summer I say \"wait why ddin't I upload this?\". So here is something imperfect.", "tags": ["3d", "scary", "spooky", "minimalism", "dark", "skull", "bones", "teeth", "schadel"], "likes": 24, "viewed": 305, "published": "Public", "date": "1622078714", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define FAR 4.\n\n\n//just wanted to add that a lot of the lighting stuff is Shane's\n//and his comments are still there.\n\n\nfloat sdCappedCylinder( vec3 p, float h, float r ){\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat smin( float a, float b, float k ){\n    float h = clamp( 0.5 + 0.5 * (b - a) / k, 0.0, 1.0 );\n    return mix( b, a, h ) - k * h * (1.0 - h);\n}\nfloat smax( float a, float b, float k ){\n    float h = clamp( 0.5 + 0.5 * (a - b) / k, 0.0, 1.0 );\n    return mix( b, a, h ) + k * h * (1.0 - h);\n}\nfloat knochen(vec3 p, vec3 xyz, vec3 dim, float th, float phi, float ga, \n                float spiegel, float r){\n    \n    vec3 sp = p - xyz;\n    sp.x = abs(sp.x) - spiegel;\n    \n    float cs = cos(th), si = sin(th);\n    sp.yz*=mat2(cs, si, -si, cs);\n    \n    cs = cos(phi), si = sin(phi);\n    sp.xz*= mat2(cs, si, -si, cs);\n    \n    cs = cos(ga), si = sin(ga);\n    sp.xy*= mat2(cs, si, -si, cs);\n        \n    sp = abs(sp) - dim;\n    return min(max(sp.x, max(sp.y, sp.z)), 0.0) + length(max(sp, 0.0)) - r;    \n}\nfloat sdCircleCircle( in vec3 p, in int n, float zeichen){\nfloat a0 = float(n) / radians(360.); \nfloat a = round(atan(p.z, p.x) * a0) / a0;\nvec3 sp = p - vec3(cos(a), 0.0, sin(a));\n  \nfloat cs = cos(a), si = sin(a);//erste versuch!!!!\nsp.xz*=mat2(cs, si, -si, cs);\n  \ncs = cos(0.3*zeichen), si = sin(0.3*zeichen);//erste versuch!!!!\nsp.xy*=mat2(cs, si, -si, cs);\n    \nsp = abs(sp) - vec3(0.1 + cos(sp.y*8.)*0.03, 0.19, 0.07 + cos(sp.y*6.+ 1.4)*0.05*zeichen);\nreturn min(max(sp.x, max(sp.y, sp.z)), 0.0) + length(max(sp, 0.0)) - 0.03;  \n\n    \n    //return sdCappedCylinder(sp, 0.05, 0.06) - 0.05; \n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\nvec4 objID, oSvObjID;\nfloat svObjID; // Global ID to keep a copy of the above from pass to pass.\nfloat map(vec3 p){\n    vec3 altp = p;\n    p.x+=1.;\n    p.x = mod(p.x, 2.) - 1.;\n    \n    float PosX, PosY;\n    PosX = 0. + sin(iTime*20.)/4.;// - (iMouse.x)/iResolution.x;//0.2*2.*(rechts - links);\n    PosY = -0.1 + sin(iTime*2.)/4.;;//(iMouse.y)/iResolution.y*4.;\n    \n    //zufall \n    float cs = cos(PosX), si = sin(PosX);\n    //p.xy = mat2(cs, si, -si, cs)*p.xy;\n    if (altp.x > 0.75 || altp.x < -0.75){\n    p.xz = mat2(cs, si, -si, cs)*p.xz;}\n    else{\n    cs = cos(PosY), si = sin(PosY);\n    p.yz = mat2(cs, si, -si, cs)*p.yz;}\n    \n    //guckmal\n    float gu = clamp(sin(iTime*0.3), -0.4, 0.4);\n    cs = cos(gu), si = sin(gu);\n    //p.xz = mat2(cs, si, -si, cs)*p.xz;\n    \n    \n\tp*=0.6;\n    p.y-=0.2;// + sin(iTime)*0.1;\n    \n\n    \n    vec3 sp = p - vec3(0., 0., 0.03);\n    float k = length(sp*vec3(1.-sin(sp.z*6.-0.4)*0.05, \n                             0.95+sin(sp.z*6.+1.6)*0.05, \n                             0.87)) - 0.5;\n    float alle = k;\n    \n    //schadel unten schneiden\n    sp = p;\n    k = length(sp - vec3(0., -0.9, -0.5)) - 0.7;\n    alle = smax(alle, -k, 0.09);\n    \n    ///return alle;\n    \n    //schadel seite\n    sp = p  - vec3(0., -0.05, -0.28);\n    sp.x = abs(sp.x) - 0.65;\n    //length(sp*vec3(1., 0.95+sin(sp.z*4.+0.8)*0.07, 0.87))\n    k = length(sp) - 0.3;\n    //k = length(sp*vec3(1., 0.95+sin(sp.z*4.+0.8)*0.07, 0.6)) - 0.3;\n    //alle = smax(alle, -k, 0.09);\n\n    //schadel seite knochen schneiden versuch\n    sp = p;\n    k = knochen(p, vec3(0., -0.15 , -0.18 ), \n                vec3(0.005, \n                     0.17 + sin(sp.z*4.+2.4)*0.1, \n                     0.2+ sin(sp.y*4.+2.)*0.18), \n                -0.2, -0.4, 0.1, 0.42+ sin(sp.z*4.+2.4)*0.05, 0.03);\n    alle = smax(alle, -k, 0.09);\n    \n    //return alle;\n    \n    //oben augen knochen\n    sp = p;\n    k = knochen(p, vec3(0., \n                        0. + cos(abs(sp.x)*8. + 5.)*0.03*1. - 0.04*1. , \n                        -0.45 - cos(abs(sp.x)*8. + 5.8)*0.05), \n                vec3(0.12, 0.005, 0.005), \n                0., 0., -0., 0.14, 0.04);\n    alle = smin(alle, k, 0.07);\n    \n    //return alle;\n\n    \n    //oberest knochen\n    sp = p;\n    k = knochen(p, vec3(0., 0.055 , -0.37 ), vec3(0.005, 0.005, 0.12), \n                -1., -0.25, 0., 0.28, 0.02);\n    alle = smin(alle, k, 0.06);\n    \n    //augen seit knochen\n    sp = p;\n    k = knochen(p, vec3(0., -0.14 , -0.46+ cos(sp.y*8.+1.5)*0.07), \n                vec3(0.01, 0.08, 0.02), \n                0.0, 0.0, 0.35, 0.26+ cos(sp.y*12.+1.2)*0.06, 0.015);\n    alle = smin(alle, k, 0.06);\n    \n\n    \n    \n    //wangen knochen vor\n    sp = p;\n    k = knochen(p, vec3(0., -0.28, -0.42+cos(abs(sp.x)*8.+2.)*0.02), \n                vec3(0.13, 0.055+sin(abs(sp.x)*8.+2.)*0.02, 0.05), \n                -0.5, 0.2, -0.1, 0.12, 0.05);\n    alle = smin(alle, k, 0.09);\n    \n    //return alle;\n    \n    //wangen knochen seit sollte dasselb (gesamt)breit haben wie die augen seit!\n    //wangen knochen seit\n    sp = p;\n    k = knochen(p, vec3(0., -0.3, -0.28), \n                vec3(0.007, 0.02-cos(sp.z*8. + 1.7-cos(sp.z*20. + 1.7))*0.01, 0.16), \n                0., 0.1, 0., 0.27 + cos(sp.z*8. + 2.)*0.09, \n                0.03 + cos(sp.z*8. + 4.7)*0.015);\n    alle = smin(alle, k, 0.02);\n    \n    float keiferHohe = 0.01;\n    //wangen knochen zu keifer\n    sp = p;\n    k = knochen(p, vec3(0., -0.51+keiferHohe, -0.25 - cos(abs(sp.y)*12. + 3.)*0.04), \n                vec3(0.005-cos(sp.z*12.+4.5)*0.004 - cos(sp.y*6.+1.2)*0.017, \n                     0.125, \n                     0.1), \n                0.2+(-sp.y-0.5)*0.2, -0.35, -0.25, \n                0.29 , 0.01); //keifer ein bisschen mehr eng war hilfreich\n    float keifer = k;\n    \n    \n    \n    \n    //keifer\n    sp = p;\n    k = knochen(p, vec3(0., -0.67+keiferHohe, -0.35), vec3(0.005, 0.02, 0.16), \n                -0.3, -0.5, 0., 0.18+cos(sp.z*8.+3.14)*0.02, 0.045);\n    keifer = smin(keifer, k, 0.04);\n    \n    //wkk schneid\n    sp = p;\n    k = knochen(p, vec3(0., -0.58+keiferHohe, -0.28 - cos(abs(sp.y)*12. + 3.)*0.06), \n                vec3(0.001, 0.15, 0.055), \n                0.2+(-sp.y-0.5)*0.2, -0.45, -0.3, 0.34, 0.01);\n    keifer = smax(keifer, -k, 0.04);\n    \n    //wkk loch\n    sp = p;\n    sp.x = abs(sp.x) - 0.31;\n    k = length(sp - vec3(0., -0.38+keiferHohe, -0.23)) - 0.06;\n    keifer = smax(keifer, -k, 0.04);\n    \n    \n    //kinn\n    sp = p;\n    k = knochen(p, vec3(0., -0.73+keiferHohe, -0.45-cos(sp.x*8.)*0.1), vec3(0.09, 0.02, 0.015), \n                0., 0., 0., 0., 0.03);\n    keifer = smin(keifer, k, 0.09);\n    \n\n    //sollte siemlich schaf sein\n    //augen loche\n    sp = p;\n    sp.x = abs(sp.x) - 0.172;\n    k = length(sp - vec3(0., -0.14, -0.48)) - 0.084;\n    alle = smax(alle, -k, 0.075);\n    \n    //nase\n    sp = p;\n    k = knochen(p, vec3(0., -0.23, -0.51), vec3(0.03, 0.09, 0.08), \n                -0.3, 0., 0.3, 0., 0.039);\n    alle = smin(alle, k, 0.06);\n    \n    //nase scheiden\n    sp = p;\n    k = knochen(p, vec3(0., -0.25, -0.54), vec3(0.022, 0.08, 0.07), \n                -0.35, 0., 0.3, 0., 0.03);\n    alle = smax(alle, -k, 0.04);\n    \n    //nase linie\n    sp = p;\n    k = knochen(p, vec3(0., -0.25, -0.5), vec3(0.001, 0.12, 0.07), \n                -0.35, 0., 0., 0., 0.005);\n    alle = smin(alle, k, 0.03);\n    \n    \n    float zahnNum = 12.;\n    float th = 0.15;\n    sp = p;\n    cs = cos(th), si = sin(th);\n    \n    sp = sp - vec3(0., -0.43, -0.4);\n    sp.yz*=mat2(cs, si, -si, cs);\n    \n    //cyl oben\n    \n    k = sdCappedCylinder(sp, 0.17 //nicht so breit\n                         + cos(sp.y*12. -5.)*0.015\n                         + abs(cos(atan(sp.z,sp.x)*zahnNum - 0.8))*0.005\n                         , 0.045 - abs(cos(atan(sp.z,sp.x)*zahnNum - 0.8))*0.02\n                        - cos(sp.z*6.-1.75)*0.05\n                        );\n    alle = smin(alle, k, 0.06); //weniger smooth weil die echte schadel\n    \n    \n    //return alle;\n    \n    //cyl unten\n    sp = p - vec3(0., -0.65+keiferHohe, -0.42);\n    k = sdCappedCylinder(sp, 0.15\n                         + cos(sp.y*12. - 1.5)*0.03\n                         + abs(cos(atan(sp.z,sp.x)*zahnNum - 0.8))*0.01\n                         , 0.05 - abs(cos(atan(sp.z,sp.x)*zahnNum - 0.8))*0.01);\n    keifer = smin(keifer, k, 0.06);\n    \n    \n    \n    \n  \n    //oben zhan\n    sp = p - vec3(0.0, -0.51, -0.41);\n    cs = cos(0.33), si = sin(0.33);//erste versuch!!!!\n\tsp.xz*=mat2(cs, si, -si, cs);\n    k = sdCircleCircle(sp*6.6, 24, 1.); //nicht so breit\n    float zahn = k;\n    \n    //unten zahn\n    sp = p - vec3(0.0, -0.58+keiferHohe, -0.39);\n    cs = cos(0.33), si = sin(0.33);//erste versuch!!!!\n\tsp.xz*=mat2(cs, si, -si, cs);\n    \n    k = sdCircleCircle(sp*6.6, 24, -1.);//nicht so breit\n    zahn = min(zahn, k);\n    \n    objID = vec4(zahn-0.05, alle, keifer, 0);\n    alle = smin(zahn,alle, 0.09);\n    alle = smin(alle, keifer, 0.09);\n    \n    //cyl schneiden\n    sp = p - vec3(0., -0.58, -0.15);\n    k = sdCappedCylinder(sp, 0.17, 0.24);\n    alle = smax(alle, -k, 0.06);\n    \n    //schonheit\n    sp = p;\n    sp.x = abs(sp.x) - 0.18;\n    k = length(sp - vec3(0., -0.32, -0.522)) - 0.012;\n    alle = smax(alle, -k, 0.01);\n    \n    return alle;\n}\nfloat trace(vec3 ro, vec3 rd){\n   \n    float t = 0., d;\n    \n    for (int i = 0; i < 96; i++){\n\n        d = map(ro + rd*t);\n        \n        // Using the hacky \"abs,\" trick, for more accuracy. \n        if(abs(d)<.001 || t>FAR) break;        \n        \n        t += d*.75;  // Using more accuracy, in the first pass.\n    }\n    \n    return t;\n}\n\n\n//thanks to Shane\nfloat softShadow(vec3 ro, vec3 lp, float k){\n\n    const int maxIterationsShad = 24; \n    \n    vec3 rd = lp - ro; \n\n    float shade = 1.;\n    float dist = .002;    \n    float end = max(length(rd), .001);\n    float stepDist = end/float(maxIterationsShad);\n    \n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = 0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, .2), \n        // clamp(h, .02, stepDist*2.), etc.\n        dist += clamp(h, .02, .25);\n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0. || dist>end) break; \n        //if (h<.001 || dist > end) break; // If you're prepared to put up with more artifacts.\n    }\n\n    // I've added 0.5 to the final shade value, which lightens the shadow a bit. It's a preference thing. \n    // Really dark shadows look too brutal to me.\n    return min(max(shade, 0.) + .25, 1.); \n}\n\n//Rudimentary getNormal function thanks to Shane\n//vec3 getNormal(in vec3 p) {\n//\tconst vec2 e = vec2(.001, 0);\n//\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n//}\n\n//I think this is the tetrehedral normal or something like that\n//to reduce compile time, thanks to iq\n//vec3 getNormal(in vec3 p) \n//{\n//    vec2 e = vec2(1.0,-1.0)*0.5773*0.001;\n//    return normalize( e.xyy*map( p + e.xyy ) + \n//\t\t\t\t\t  e.yyx*map( p + e.yyx ) + \n//\t\t\t\t\t  e.yxy*map( p + e.yxy ) + \n//\t\t\t\t\t  e.xxx*map( p + e.xxx ) );\n//}\n\n//Another normal function to further reduce compile time to\n//one second thanks to iq!\nvec3 getNormal(in vec3 p)\n{\n    vec3 n = vec3(0.0);\n    for( int i=min(iFrame,0); i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+0.001*e);\n    }\n    return normalize(n);\n}\nvec3 getObjectColor(vec3 p){\n\n\tp*=0.6;\n    p.y-=0.2;\n    \n    // \"floor(p)\" is analogous to a unique ID - based on position.\n    vec3 ip = floor(p);\n    \n\n    vec3 knochenFarber = vec3(237./255., 218./255., 201./255.)*1.5;\n    vec3 schwarze = vec3(0.);\n    vec3 rot = vec3(0.4, 0., 0.);\n    // Color up the objects in a cubic checkered arrangement using a subtle version\n    // of IQ's palette formula.\n\n    vec3 col =  vec3(1.4, 0., 0.);//vec3(.9, .45, 1.5);\n    \n    col = vec3(2.);\n    col = vec3(237./255., 218./255., 201./255.)*1.5;\n    //col = vec3(0.03);///schwarz\n    // Reverse the RGB channels on some of the objects, for a bit of variance.\n    //if(fract(rnd*1183.5437 + .42)>.65) col = col.zyx;\n    vec3 gold = vec3(205./255.,120./255.,15./255.)*1.5;\n    vec3 silber = vec3(0.2,0.3, 0.4);\n    //zahn\n    //if(stripe > 0.){col = vec3(1.0-stripe*0.7)*1.5;}\n    //keifer\n    if(svObjID == 0.){col = vec3(2.);}//vec3(237./255., 218./255., 201./255.)*1.5;}\n    return col;\n    \n}\n\n//thanks to Shane\nvec3 doColor(in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, float t){\n    \n    vec3 ld = lp-sp; // Light direction vector.\n    float lDist = max(length(ld), .001); // Light to surface distance.\n    ld /= lDist; // Normalizing the light vector.\n    \n    // Attenuating the light, based on distance.\n    float atten = 1. / (1. + lDist*.2 + lDist*lDist*.1);\n    \n    // Standard diffuse term.\n    float diff = max(dot(sn, ld), 0.);\n    // Standard specualr term.\n    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.), 5.);\n    if(svObjID == 0.){spec = pow(spec*6.,3.);}\n    // Coloring the object. You could set it to a single color, to\n    // make things simpler, if you wanted.\n    vec3 objCol = getObjectColor(sp);\n    \n    // Combining the above terms to produce the final scene color.\n    vec3 sceneCol = (objCol*(diff + 0.15) + vec3(0.8, 0.8, 1.)*spec*(1.2-svObjID/3.)) * atten;\n    \n    \n    // Fog factor -- based on the distance from the camera.\n    float fogF = smoothstep(0., .95, t/FAR);\n    //\n    // Applying the background fog. Just black, in this case, but you could\n    // render sky, etc, as well.\n    \n    sceneCol = mix(sceneCol, vec3(0.01), fogF); \n\t//sceneCol = mix(sceneCol, vec3(1.), 1.0-length(sp.xy)-0.5);\n    \n    // Return the color. Performed once every pass... of which there are\n    // only two, in this particular instance.\n    return sceneCol;\n    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinates.\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.y;\n    \n    // Unit direction ray.\n    vec3 rd = normalize(vec3(uv, 1.));\n    \n\n    float cs = cos(iTime * .25), si = sin(iTime * .25);\n    //rd.xy = mat2(cs, si, -si, cs)*rd.xy;\n    //rd.xz = mat2(cs, si, -si, cs)*rd.xz;\n    \n    // Ray origin. Doubling as the surface position, in this particular example.\n    // I hope that doesn't confuse anyone.\n    vec3 ro = vec3(0., 0., -3.);\n    \n    // Light position. Set in the vicinity the ray origin.\n    vec3 lp = ro + vec3(0., 2., -0.5);\n    \n    \n    // FIRST PASS.\n    \n    float t = trace(ro, rd);\n    \n    //Speichern Save the object IDs after the first pass.\n    \n    svObjID = objID.x<objID.y? 0. : 1.;\n    if(objID.z < objID.x && objID.z < objID.y) svObjID = 2.;\n    \n    oSvObjID = objID;\n   \n    //thanks to Shane\n    // Advancing the ray origin, \"ro,\" to the new hit point.\n    ro += rd*t;\n    \n    //thanks to Shane\n    // Retrieving the normal at the hit point.\n    vec3 sn = getNormal(ro);\n    \n    //thanks to Shane\n    vec3 sceneColor = doColor(ro, rd, sn, lp, t);\n    float sh = softShadow(ro +  sn*.0015, lp, 16.);\n\n    sceneColor *= sh;\n\n\tfragColor = vec4(sqrt(clamp(sceneColor, 0., 1.)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ddyz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[120, 120, 171, 171, 278], [279, 279, 319, 319, 426], [427, 427, 467, 467, 574], [575, 575, 689, 689, 1087], [1088, 1088, 1146, 1146, 1686], [1850, 1910, 1928, 1928, 9058], [9059, 9059, 9089, 9089, 9400], [9403, 9421, 9465, 9465, 10733], [11318, 11405, 11432, 11432, 11640], [11641, 11641, 11669, 11669, 12627], [12629, 12647, 12717, 12717, 14034], [14035, 14035, 14091, 14119, 15341]], "test": "valid"}
{"id": "3dSBRz", "name": "DumbColorCube", "author": "webbgamers", "description": "dumb cube thing that i made to start learning graphical programming", "tags": ["dumb"], "likes": 1, "viewed": 32, "published": "Public", "date": "1621956500", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float DistLine(vec3 ro, vec3 rd, vec3 p) {\n    return length(cross(p-ro, rd)) / length(rd);\n}\n\nvec3 DrawPoint(vec3 ro, vec3 rd, vec3 p, vec3 col) {\n    float d = DistLine(ro, rd, p);\n    d = smoothstep(.08, .07, d);\n    return d * col;\n}    \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float t = iTime;\n    \n    vec3 ro = vec3(3.*sin(t)+.5, 2., -3.*cos(t)+.5);\n    \n    vec3 lookat = vec3(.5);\n    \n    float zoom = 1.;\n    vec3 f = normalize(lookat - ro);\n    vec3 r = normalize(cross(vec3(0, 1, 0), f));\n    vec3 u = cross(f, r);\n    \n    vec3 c = ro + f * zoom;\n    vec3 i = c + uv.x*r + uv.y*u;\n    vec3 rd = i - ro;\n    \n    vec3 d = vec3(.0);\n    d += DrawPoint(ro, rd, vec3(0., 0., 0.), vec3(0.2, 0.2, 0.2));\n    d += DrawPoint(ro, rd, vec3(0., 0., 1.), vec3(0., 0., 1.));\n    d += DrawPoint(ro, rd, vec3(0., 1., 0.), vec3(0., 1., 0.));\n    d += DrawPoint(ro, rd, vec3(0., 1., 1.), vec3(0., 1., 1.));\n    d += DrawPoint(ro, rd, vec3(1., 0., 0.), vec3(1., 0., 0.));\n    d += DrawPoint(ro, rd, vec3(1., 0., 1.), vec3(1., 0., 1.));\n    d += DrawPoint(ro, rd, vec3(1., 1., 0.), vec3(1., 1., 0.));\n    d += DrawPoint(ro, rd, vec3(1., 1., 1.), vec3(1., 1., 1.));\n    \n    fragColor = vec4(d, 0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dSBRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 42, 42, 93], [95, 95, 147, 147, 237], [244, 244, 301, 301, 1318]], "test": "valid"}
{"id": "3ljfRK", "name": "Ulysses 31", "author": "xjorma", "description": "A tribute to my favorite TV-Show of all the time!\nIniatially I wanted to a more ambitious shader. But I lost the motivation to finish it, since it's sleeping on my private shader since a while I decide to release it as is.", "tags": ["31", "cineshader", "ulysses"], "likes": 7, "viewed": 1338, "published": "Public API", "date": "1621569620", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Ulysses 31 by David \"Xjorma\" Gallardo 2021\n\n\n// Exported from Houdini\n\nconst int numVertices = 765;\n\nconst uint vertices[765] = uint[](\n  80367615U,    667647U,  40807423U, 294277119U, 373968895U, 373857279U, 406474751U, 388537343U, 388648959U, 598252543U, 518560767U, 573270015U,\n 707304447U, 642292735U, 692807679U, 859538431U, 931699711U, 856202239U,1018731519U, 946379775U, 996894719U, 420479999U, 370298879U, 431116287U,\n 627136511U, 605029375U, 605116415U,  95419392U,  95420415U,   4194303U,  80366592U,  80367615U,  95420415U, 138038272U, 138039295U,  80367615U,\n 124779520U, 124780543U, 138039295U, 210762752U, 210763775U, 124780543U, 210675712U, 210676735U, 210763775U, 175024128U, 175025151U, 210676735U,\n 210381824U, 210382847U, 175025151U, 177772544U, 177773567U, 210382847U,  40409088U,  40410111U, 177773567U,    666624U,    667647U,  40410111U,\n  40806400U,  40807423U,    667647U,   4106240U,   4107263U,  40807423U,   4193280U,   4194303U,   4107263U, 294648832U, 294649855U, 236978175U,\n 294276096U, 294277119U, 294649855U, 373967872U, 373968895U, 294277119U, 373856256U, 373857279U, 373968895U, 236492800U, 236493823U, 373857279U,\n 236977152U, 236978175U, 236493823U, 403700736U, 403701759U, 334495743U, 439241728U, 439242751U, 403701759U, 479198208U, 479199231U, 439242751U,\n 551549952U, 551550975U, 479199231U, 475822080U, 475823103U, 551550975U, 475679744U, 475680767U, 475823103U, 493505536U, 493506559U, 475680767U,\n 493393920U, 493394943U, 493506559U, 388536320U, 388537343U, 493394943U, 388647936U, 388648959U, 388537343U, 406473728U, 406474751U, 388648959U,\n 406616064U, 406617087U, 406474751U, 334494720U, 334495743U, 406617087U, 653261824U, 653262847U, 573571071U, 598568960U, 598569983U, 653262847U,\n 652960768U, 652961791U, 598569983U, 598251520U, 598252543U, 652961791U, 518559744U, 518560767U, 598252543U, 573268992U, 573270015U, 518560767U,\n 523071488U, 523072511U, 573270015U, 573570048U, 573571071U, 523072511U, 765459456U, 765460479U, 689963007U, 714960896U, 714961919U, 765460479U,\n 769352704U, 769353727U, 714961919U, 707303424U, 707304447U, 769353727U, 642291712U, 642292735U, 707304447U, 692806656U, 692807679U, 642292735U,\n 638414848U, 638415871U, 692807679U, 689961984U, 689963007U, 638415871U, 921697280U, 921698303U, 856686591U, 859632640U, 859633663U, 921698303U,\n 924644352U, 924645375U, 859633663U, 924549120U, 924550143U, 924645375U, 859537408U, 859538431U, 924550143U, 931698688U, 931699711U, 859538431U,\n 856201216U, 856202239U, 931699711U, 769391616U, 769392639U, 856202239U, 856685568U, 856686591U, 769392639U,1070595072U,1070596095U, 994050047U,\n1015902208U,1015903231U,1070596095U,1073439744U,1073440767U,1015903231U,1018730496U,1018731519U,1073440767U, 946378752U, 946379775U,1018731519U,\n 996893696U, 996894719U, 946379775U, 939356160U, 939357183U, 996894719U, 994049024U, 994050047U, 939357183U, 587686912U, 587687935U, 420964351U,\n 515104768U, 515105791U, 587687935U, 587202560U, 587203583U, 515105791U, 420478976U, 420479999U, 587203583U, 370297856U, 370298879U, 420479999U,\n 431115264U, 431116287U, 370298879U, 449926144U, 449927167U, 431116287U, 485577728U, 485578751U, 449927167U, 445898752U, 445899775U, 485578751U,\n 485871616U, 485872639U, 445899775U, 450220032U, 450221055U, 485872639U, 431290368U, 431291391U, 450221055U, 370472960U, 370473983U, 431291391U,\n 420963328U, 420964351U, 370473983U, 685204480U, 685205503U, 617048063U, 684807168U, 684808191U, 685205503U, 706827264U, 706828287U, 684808191U,\n 706740224U, 706741247U, 706828287U, 605028352U, 605029375U, 706741247U, 605115392U, 605116415U, 605029375U, 627135488U, 627136511U, 605116415U,\n 627421184U, 627422207U, 627136511U, 612694016U, 612695039U, 627422207U, 569702400U, 569703423U, 612695039U, 617047040U, 617048063U, 569703423U,\n 569702400U, 617047040U, 569703423U, 612694016U, 569702400U, 612695039U, 627421184U, 612694016U, 627422207U, 627135488U, 627421184U, 627136511U,\n 605115392U, 627135488U, 605116415U, 605028352U, 605115392U, 605029375U, 706740224U, 605028352U, 706741247U, 706827264U, 706740224U, 706828287U,\n 684807168U, 706827264U, 684808191U, 685204480U, 684807168U, 685205503U, 617047040U, 685204480U, 617048063U, 370472960U, 420963328U, 370473983U,\n 431290368U, 370472960U, 431291391U, 450220032U, 431290368U, 450221055U, 485871616U, 450220032U, 485872639U, 445898752U, 485871616U, 445899775U,\n 485577728U, 445898752U, 485578751U, 449926144U, 485577728U, 449927167U, 431115264U, 449926144U, 431116287U, 370297856U, 431115264U, 370298879U,\n 420478976U, 370297856U, 420479999U, 587202560U, 420478976U, 587203583U, 515104768U, 587202560U, 515105791U, 587686912U, 515104768U, 587687935U,\n 420963328U, 587686912U, 420964351U, 939356160U, 994049024U, 939357183U, 996893696U, 939356160U, 996894719U, 946378752U, 996893696U, 946379775U,\n1018730496U, 946378752U,1018731519U,1073439744U,1018730496U,1073440767U,1015902208U,1073439744U,1015903231U,1070595072U,1015902208U,1070596095U,\n 994049024U,1070595072U, 994050047U, 769391616U, 856685568U, 769392639U, 856201216U, 769391616U, 856202239U, 931698688U, 856201216U, 931699711U,\n 859537408U, 931698688U, 859538431U, 924549120U, 859537408U, 924550143U, 924644352U, 924549120U, 924645375U, 859632640U, 924644352U, 859633663U,\n 921697280U, 859632640U, 921698303U, 856685568U, 921697280U, 856686591U, 638414848U, 689961984U, 638415871U, 692806656U, 638414848U, 692807679U,\n 642291712U, 692806656U, 642292735U, 707303424U, 642291712U, 707304447U, 769352704U, 707303424U, 769353727U, 714960896U, 769352704U, 714961919U,\n 765459456U, 714960896U, 765460479U, 689961984U, 765459456U, 689963007U, 523071488U, 573570048U, 523072511U, 573268992U, 523071488U, 573270015U,\n 518559744U, 573268992U, 518560767U, 598251520U, 518559744U, 598252543U, 652960768U, 598251520U, 652961791U, 598568960U, 652960768U, 598569983U,\n 653261824U, 598568960U, 653262847U, 573570048U, 653261824U, 573571071U, 406616064U, 334494720U, 406617087U, 406473728U, 406616064U, 406474751U,\n 388647936U, 406473728U, 388648959U, 388536320U, 388647936U, 388537343U, 493393920U, 388536320U, 493394943U, 493505536U, 493393920U, 493506559U,\n 475679744U, 493505536U, 475680767U, 475822080U, 475679744U, 475823103U, 551549952U, 475822080U, 551550975U, 479198208U, 551549952U, 479199231U,\n 439241728U, 479198208U, 439242751U, 403700736U, 439241728U, 403701759U, 334494720U, 403700736U, 334495743U, 236492800U, 236977152U, 236493823U,\n 373856256U, 236492800U, 373857279U, 373967872U, 373856256U, 373968895U, 294276096U, 373967872U, 294277119U, 294648832U, 294276096U, 294649855U,\n 236977152U, 294648832U, 236978175U,   4106240U,   4193280U,   4107263U,  40806400U,   4106240U,  40807423U,    666624U,  40806400U,    667647U,\n  40409088U,    666624U,  40410111U, 177772544U,  40409088U, 177773567U, 210381824U, 177772544U, 210382847U, 175024128U, 210381824U, 175025151U,\n 210675712U, 175024128U, 210676735U, 210762752U, 210675712U, 210763775U, 124779520U, 210762752U, 124780543U, 138038272U, 124779520U, 138039295U,\n  80366592U, 138038272U,  80367615U,  95419392U,  80366592U,  95420415U,   4193280U,  95419392U,   4194303U, 617048063U, 627422207U, 569703423U,\n 569703423U, 627422207U, 612695039U, 617048063U, 685205503U, 627422207U, 685205503U, 684808191U, 627422207U, 684808191U, 627136511U, 627422207U,\n 684808191U, 706741247U, 605029375U, 684808191U, 706828287U, 706741247U, 684808191U, 605029375U, 627136511U, 420964351U, 431291391U, 370473983U,\n 420964351U, 450221055U, 431291391U, 420964351U, 587687935U, 485872639U, 420964351U, 485872639U, 450221055U, 587687935U, 515105791U, 485872639U,\n 515105791U, 485578751U, 445899775U, 515105791U, 587203583U, 485578751U, 587203583U, 420479999U, 485578751U, 515105791U, 445899775U, 485872639U,\n 485578751U, 420479999U, 449927167U, 420479999U, 431116287U, 449927167U, 994050047U,1015903231U, 939357183U, 939357183U,1015903231U, 996894719U,\n1015903231U,1073440767U, 996894719U, 996894719U,1073440767U,1018731519U, 994050047U,1070596095U,1015903231U, 856686591U, 859633663U, 769392639U,\n 769392639U, 859538431U, 856202239U, 769392639U, 859633663U, 859538431U, 859633663U, 924550143U, 859538431U, 859633663U, 924645375U, 924550143U,\n 856686591U, 921698303U, 859633663U, 689963007U, 714961919U, 638415871U, 638415871U, 714961919U, 692807679U, 714961919U, 769353727U, 692807679U,\n 692807679U, 769353727U, 707304447U, 689963007U, 765460479U, 714961919U, 573571071U, 598569983U, 523072511U, 523072511U, 598569983U, 573270015U,\n 573270015U, 598569983U, 652961791U, 573270015U, 652961791U, 598252543U, 573571071U, 653262847U, 598569983U, 334495743U, 403701759U, 406617087U,\n 403701759U, 439242751U, 406617087U, 439242751U, 475823103U, 406617087U, 406617087U, 475823103U, 475680767U, 439242751U, 479199231U, 475823103U,\n 479199231U, 551550975U, 475823103U, 475680767U, 493394943U, 406474751U, 475680767U, 493506559U, 493394943U, 475680767U, 406474751U, 406617087U,\n 493394943U, 388537343U, 406474751U, 236978175U, 294277119U, 236493823U, 236978175U, 294649855U, 294277119U, 294277119U, 373857279U, 236493823U,\n   4194303U,  40807423U,   4107263U,   4194303U,  95420415U,  40807423U,  95420415U,  80367615U,  40807423U,  80367615U,  40410111U,    667647U,\n  80367615U, 177773567U,  40410111U,  80367615U, 138039295U, 177773567U, 138039295U, 175025151U, 210382847U, 138039295U, 210382847U, 177773567U,\n 138039295U, 124780543U, 175025151U, 124780543U, 210763775U, 175025151U, 210763775U, 210676735U, 175025151U );\n\nvec3 getVertex( uint id )\n{\n\tuint d = vertices[id];\n\tvec3 v = vec3(ivec3(d >> 20, d >> 10, d)&1023) / 1023.0;\n    v.z *= -1.;\n\treturn v * vec3(4.4848484993, 2.0, 1.00000011921) + vec3(-2.24242424965, -1.0, -0.500000059605);\n}\n\nconst vec3 bboxSiz = vec3(2.24242424965, 1.0, 0.500000059605);\nconst vec3 bboxCtr = vec3(0.0, 0.0, 0.0);\n\nconst float pi = radians(180.);\nconst vec3 logoColor0 = vec3(255., 223., 0.) / 255.;\nconst vec3 logoColor1 = vec3(255., 102., 0.) / 255.;\n\n// http://iquilezles.org/www/articles/intersectors/intersectors.htm\nvec3 triIntersect( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 v1v0 = v1 - v0;\n    vec3 v2v0 = v2 - v0;\n    vec3 rov0 = ro - v0;\n\n    vec3  n = cross( v1v0, v2v0 );\n    vec3  q = cross( rov0, rd );\n    float d = 1.0/dot( rd, n );\n    float u = d*dot( -q, v2v0 );\n    float v = d*dot(  q, v1v0 );\n    float t = d*dot( -n, rov0 );\n\n    if( u<0.0 || v<0.0 || (u+v)>1.0 ) t = -1.0;\n    \n    return vec3( t, u, v );\n}\n\n#define ZERO_NOLOOP min(0,iFrame)\n\nbool intersectMesh( in vec3 ro, in vec3 rd, in float tmax, out float oDis, out vec3 oNor)\n{\n    bool\tres = false;\n    float\ttmin = tmax;\n    for( int i = ZERO_NOLOOP; i < numVertices / 3; i++ )\n    {\n        // get the triangle        \n        vec3 v0 = getVertex(uint(i*3));\n        vec3 v1 = getVertex(uint(i*3 + 2));\n        vec3 v2 = getVertex(uint(i*3 + 1));\n\n        vec3 h = triIntersect( ro, rd, v0, v1, v2 );\n        if( h.x > 0. && h.x < tmin)\n        {\n            tmin = h.x;\n            oNor = normalize(cross(v1 - v0, v2 - v0));;\n            oDis = tmin;\n            res = true;\n        }\n    }\n    \n    return res;\n}\n\n// Star field by Del https://www.shadertoy.com/view/wsKXRK\nfloat vDrop(vec2 uv,float t)\n{\n    uv.x = uv.x*128.0;\t\t\t\t\t\t// H-Count\n    float dx = fract(uv.x);\n    uv.x = floor(uv.x);\n    uv.y *= 0.05;\t\t\t\t\t\t\t// stretch\n    float o=sin(uv.x*215.4);\t\t\t\t// offset\n    float s=cos(uv.x*33.1)*.2 +.7;\t\t\t// speed\n    float trail = mix(55.0,35.0,s);\t\t\t// trail length\n    float yv = fract(uv.y + t*s + o) * trail;\n    yv = 1.0/yv;\n    yv = smoothstep(0.0,1.0,yv*yv);\n    yv = sin(yv*pi)*(s*5.0);\n    float d2 = sin(dx*pi);\n    return yv*(d2*d2);\n}\n\nvec3 drawStarField(in vec2 uv)\n{\n    vec2 p = uv;\n    float d = length(p);\n\tp = vec2(atan(p.x, p.y) / pi, 2.5 / d);\n    float t =  iTime*0.4;\n    vec3 col = vec3(vDrop(p, t));\n\treturn col*(pow(d,1.5));\n}\n\n\nvec4 renderLogo(in vec3 ro, in vec3 rd)\n{\n    float d;\n    vec3  n;\n    if(intersectMesh( ro, rd, 20., d, n))\n    {\n        if(n.z > 0.5)\n            return vec4(logoColor0, 1);\n        return vec4(logoColor1, 1);;\n    }\n    return vec4(0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2\tp = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    float\ta = atan(p.y, p.x);\n    float\tl = length(p);\n    \n\tfloat\tv = smoothstep(0.1, 0.25, l) * smoothstep(2., 0.8, l) * pow(abs(sin(a)), 1.3);\n    vec3 col = vec3(v);\n    \n    vec3 rd = normalize(vec3(p ,1.5));\n    vec3 ro = vec3(0, 0, -4);\n    \n    col = drawStarField(p);\n    vec4 logo = renderLogo(ro, rd);    \n    col = mix(col, logo.rgb, logo.a);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "ltSGWK", "previewfilepath": "https://soundcloud.com/david-gallardo-492062428/ulysses-31-full-intro-restored", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/david-gallardo-492062428/ulysses-31-full-intro-restored", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ljfRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[9386, 9386, 9413, 9413, 9611], [9858, 9926, 10007, 10007, 10366], [10403, 10403, 10494, 10494, 11034], [11036, 11095, 11125, 11125, 11573], [11575, 11575, 11607, 11607, 11778], [11781, 11781, 11822, 11822, 12023], [12026, 12026, 12083, 12083, 12557]], "test": "error"}
{"id": "3lyBWz", "name": "Circuit board fractal 11", "author": "jarble", "description": "I found a fractal pattern that looks like a circuit board.", "tags": ["fractal", "circuit"], "likes": 10, "viewed": 164, "published": "Public API", "date": "1620080577", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//vec3 c1 = vec3(7.0,5.0,1.4); //change this constant to get different patterns!\n//vec3 c1 = vec3(7.0,9.0,1.4);\nvec3 c1 = vec3(2.0,2.5,1.4); //looks like a maze\n//vec3 c1 = vec3(1.7,1.9,1.4);\n\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;  \n    float t1 = 4.0;\n    float offset = .16;\n    float scale2 = 1.05;\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        for(int i=0;i<9;i++)\n        {\n          \n            uv = triangle_wave(uv+offset,scale)+triangle_wave(uv.yx,scale);\n            uv = triangle_wave(uv+col.xy,scale);\n            scale /= scale2+col.x;\n            offset *= scale2;\n            uv.y /= -1.0;\n            //uv = uv.yx;\n\n        }\n     col[c] = fract((uv.x)-(uv.y));\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lyBWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[194, 194, 233, 233, 278], [280, 280, 337, 337, 1001]], "test": "valid"}
{"id": "3sSBDz", "name": "ray tracing in one weekend-05", "author": "shicz86", "description": "implement ray tracing in one weekend,thanks for this wonderful digital book-_-", "tags": ["raytracing"], "likes": 0, "viewed": 21, "published": "Public", "date": "1622273755", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MIN_FLOAT 1e-3\n#define MAX_FLOAT 1e5\n#define SAMPLES 8\n\nfloat seed = 0.0;\nvec2 UV = vec2(0.);\n\n// Helper functions.\nfloat random() {\n\treturn fract(sin(dot(UV, vec2(12.9898, 78.233)) + seed++) * 43758.5453);\n}\n\nstruct ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n    \nvec3 point_at_parameter(const ray r,float t)\n{\n\treturn r.origin+t*r.direction;\n}\n\nstruct hit_record\n{\n\tfloat t;\n    vec3 p;\n    vec3 normal;\n};\n\nstruct hitable\n{\n\tvec3 center;\n    float radius;\n};\n    \nbool hitable_hit(const in hitable hb,const in ray r,const in float t_min,const in float t_max,inout hit_record rec)\n{\n\tvec3 oc = r.origin-hb.center;\n    float a = dot(r.direction,r.direction);\n    float b = dot(oc,r.direction);\n    float c = dot(oc,oc)-hb.radius*hb.radius;\n    float discriminant = b*b-(a*c);\n    if(discriminant>0.0)\n    {\n        float s = sqrt(discriminant);\n        float t1 = (-b-s)/a;\n        float t2 = (-b+s)/a;\n        if(t1 < t_max && t1 > t_min)\n        {\n        \trec.t = t1;\n            rec.p = point_at_parameter(r,rec.t);\n            rec.normal = normalize((rec.p-hb.center));\n            return true;\n        }\n        if(t2 < t_max && t2 > t_min)\n        {\n        \trec.t = t2;\n            rec.p = point_at_parameter(r,rec.t);\n            rec.normal = normalize((rec.p-hb.center));\n            return true;\n        }\n    }\n    return false;\n}\n\nbool world_hit(const in ray r,const in float t_min,const in float t_max,inout hit_record rec)\n{\n    rec.t = t_max;\n    bool hit = false;\n    hitable h0 = hitable(vec3(0.,0.,-1.),0.5);\n    hitable h1 = hitable(vec3(0.,-100.5,-1.),100.);\n  \tif (hitable_hit(h0,r,t_min,rec.t,rec)) hit=true;\n    if (hitable_hit(h1,r,t_min,rec.t,rec)) hit=true;\n\treturn hit;\n}\n    \nvec3 color(const ray r)\n{\n    hit_record rec;\n    if(world_hit(r,MIN_FLOAT,MAX_FLOAT,rec))\n    {\n    \treturn 0.5*vec3(rec.normal.x+1.,rec.normal.y+1.,rec.normal.z+1.);\n    }\n    else\n    {\n        vec3 unit_direction = normalize(r.direction);\n        float t = 0.5*(unit_direction.y+1.0);\n        return (1.0-t)*vec3(1.0,1.0,1.0)+t*vec3(0.5,0.7,1.0);\n    }\n}\n\nray camera_getray(const in float u,const in float v)\n{\n\tvec3 lower_left_corner = vec3(0.,0.0,-2.);\n    vec3 horizontal = vec3(2.0,0.0,0.0);\n    vec3 vertical = vec3(0.0,2.0,0.0);\n    vec3 origin = vec3(0.0,0.0,.0);\n    return ray(origin,lower_left_corner+u*horizontal+v*vertical);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    UV = fragCoord / iResolution.xy;\n    seed = iTime;\n    vec3 col = vec3(0.);\n    for (int s = 0; s < SAMPLES; s++)\n    {   \n        vec2 uv = (2.*(fragCoord+vec2(random(),random()))/iResolution.xy-1.)*vec2(iResolution.x/iResolution.y,1.);\n        ray r = camera_getray(uv.x,uv.y);\n        col += color(r);\n    }\n\tcol /= float(SAMPLES);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sSBDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[103, 124, 140, 140, 216], [276, 276, 322, 322, 356], [1717, 1717, 1742, 1742, 2075], [2361, 2361, 2418, 2418, 2791]], "test": "error"}
{"id": "7d2SD3", "name": "The Flashlight", "author": "Hexdigest", "description": "Just a shader with a combination of things I've learnt and experimented with lately.", "tags": ["random", "flashlight", "tiles", "randomness"], "likes": 1, "viewed": 56, "published": "Public", "date": "1621207698", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Hash21(vec2 p) {\n    float t = iTime/100.;\n    p = fract(p*vec2(234.35, 935.775));\n    p += dot(p, p+24.23+t);\n    return fract(p.x * p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - iResolution.xy*.5)/iResolution.y;\n    vec3 col = vec3(0);\n    \n    uv *= 30.;\n    \n    uv *= acos(uv.x * .05);\n    \n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    \n    float n = Hash21(id + 5.364);\n    \n    col += -n + dot(uv.x/5. + uv.y/5. * .5, n) *.2;\n    \n    col += n;\n    col.r += smoothstep(10.8-cos(iTime)*2., 4.6-cos(iTime), length(vec2(uv.x + sin(iTime)*18., uv.y + cos(iTime)*22.))) *.5;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d2SD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 147], [149, 149, 206, 206, 679]], "test": "error"}
{"id": "7d2SDG", "name": "rehiletes 2d-", "author": "jorge2017a1", "description": "rehiletes 2d-", "tags": ["2d", "draw", "polygons", "poly", "rehiletes2d"], "likes": 4, "viewed": 155, "published": "Public API", "date": "1620960327", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//por jorge2017a1 ----jorgeFloresP---13/may/2021\n//rehiletes 2d-\n// referencia \n////-------------------\n/// IQ funciones....librerias\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n    \nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r; }\n\nvec3 ponerBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S(abs( distObj),0.0));\n  return colOut;\n}\n\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\nvec2 RotarPuntoPivote(vec2 p,vec2 pXrYr, float theta)\n{\n     vec2 pp=p;\n     vec2 pos=pXrYr;\n     pp=pp-pos;\n     pp.xy = rotatev2(pp.xy, theta);\n     pp=pp+pos;   \n     return pp;\n}   \n\n\nfloat opU(float d1, float d2) {return min(d1, d2); }\nconst vec3 col1=vec3(0.54,0.49,0.39);\nconst vec3 col2=vec3(0.06,0.07,1.0);\nconst vec3 col3=vec3(0.06,0.07,0.8);\nconst vec3 col4=vec3(0.60,0.17,0.17); \nconst vec3 col5=vec3(0.73,0.60,0.55);\nconst vec3 colDorado=vec3(0.925,0.67,0.0);\n\n#define POLY(N) (in vec2 p, in vec2[N] v) {const int n=v.length();float d=dot(p-v[0],p-v[0]);float s=1.;for(int i=0,j=n-1;i<n;j=i,i++){vec2 e=v[j]-v[i];vec2 w=p-v[i];vec2 b=w-e*clamp(dot(w,e)/dot(e,e),0.,1.);d=min(d,dot(b,b));bvec3 cond=bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);if(all(cond)||all(not(cond))) s=-s;}return s*sqrt(d);}\n\nfloat sdPoly5 POLY(5)\nvec2 pt5[ 5]=vec2[](  \nvec2(.28,.72),vec2(.71,.72),vec2(.71,.28),vec2(.28,.28),vec2(.28,.72) );\n\n\nfloat sdPoly4 POLY(4)\nvec2 pt4[ 4]=vec2[](  \nvec2(.29,.72),vec2(.07,.50),vec2(.50,.51),vec2(.29,.72) );\n\nfloat sdPoly4b POLY(4)\nvec2 pt4b[ 4]=vec2[](  \nvec2(.50,.93),vec2(.72,.71),vec2(.50,.51),vec2(.50,.93) );\n\nfloat sdPoly4c POLY(4)\nvec2 pt4c[ 4]=vec2[](  \nvec2(.50,.50),vec2(.93,.50),vec2(.71,.28),vec2(.50,.50) );\n\nfloat sdPoly4d POLY(4)\nvec2 pt4d[ 4]=vec2[](  \nvec2(.50,.50),vec2(.50,.07),vec2(.28,.28),vec2(.50,.50) );\n\n\n///------------*******-------------------\nvec3 Rehilete(in vec2 pp, vec3 col) \n{\n    vec2 p=pp;  \n    float sd5 = sdPoly5(p, pt5);\n    float sd4 = sdPoly4(p, pt4);\n    float sd4b = sdPoly4b(p, pt4b);\n    float sd4c = sdPoly4(p, pt4c);\n    float sd4d = sdPoly4(p, pt4d);\n    col=ponerBorde(col1,col,sd5 );\n    col=ponerBorde(col2,col,sd4 );\n    col=ponerBorde(col3,col,sd4b );\n    col=ponerBorde(col4,col,sd4c );\n    col=ponerBorde(col5,col,sd4d );\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    float t=5.0*sin(iTime*0.5+cos(iTime*0.5))+sin(iTime+0.5);\n    vec2 p=uv*0.5-vec2(-0.5,-0.5);\n    vec2 p2=uv*0.25-vec2(-0.5,-0.5);\n    vec2 p3=uv*0.125-vec2(-0.5,-0.5);\n    \n    vec3 col=vec3(0.15,0.6,0.3); //vec3(0.25);\n    vec2 pXrYr1=vec2(0.5,0.5);\n    vec2 pr1=RotarPuntoPivote( p, pXrYr1, t);\n    vec2 pr2=RotarPuntoPivote( p, pXrYr1, 10.0+t);\n    vec2 pr3=RotarPuntoPivote( p, pXrYr1, 20.0+t);\n    col=Rehilete(pr3, col);\n    col=Rehilete(pr2, col);\n    col=Rehilete(pr1, col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d2SDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[243, 281, 317, 317, 362], [368, 368, 403, 403, 427], [429, 429, 489, 489, 613], [615, 615, 649, 649, 746], [747, 747, 802, 802, 929], [935, 935, 966, 966, 987], [2107, 2149, 2187, 2187, 2572], [2574, 2574, 2631, 2631, 3248]], "test": "valid"}
{"id": "7d2SDR", "name": "Lunar Arcans", "author": "jhabaa", "description": "Nice illusion", "tags": ["lunar"], "likes": 2, "viewed": 160, "published": "Public API", "date": "1620071901", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n    ///Voici les arcanes lunaires inspirées du manga Naruto\n    \n    Le code est basé sur celui de  FabriceNeyret2-- shortest rotation dot (91 chars) -- \n    pour les effets lumineux et rotationnel des élements. \n    \n    La sphère centrale qui représente la lune est la même utilisée par Deefunct --Light circles--\n    \n    Le disque central rouge est acquis grace au code disponible en cours\n    \n    les effets de lumières, couleurs, et animations resultent d'une modification des codes acquis.\n    \n*/\n\n\n//Fonction de création d'un disque. Prise en cours\nvec4 disk(vec2 uv, vec2 center, float radius, vec4 color) {\nfloat inDisk = step(length(center - uv), radius);\nif (inDisk==0.0) return vec4(0.0, 0.0, 0.0, 1.0);\nelse return vec4(inDisk, inDisk, inDisk, 1.0)*color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //disque central rouge\n    vec2 xy = fragCoord.xy;\n    xy = iResolution.xy;\n    vec2 center = iResolution.xy * 0.5;\n    float radius = 0.12 * iResolution.y;\n    vec4 layer3 = disk(fragCoord.xy, center, radius, vec4(1.0, 0.0, 0.0, 1.0));\n    layer3 -= 0.1 / length( (fragCoord+fragCoord-xy)/xy.y*2.0 + tan( iTime  + vec2(33,0) )  ) ; //ajout d'un halo noir tangent à la lune\n    \n    //cercle luminlumineux blanc lunaire\n    vec2 uv1 = 7.2*(2.0*fragCoord.xy - iResolution.xy) / iResolution.y;\n    vec3 light_color1 = vec3(1.0,1.0,1.0);\n    float light1 = 2.0 / distance(normalize(uv1), uv1);\n    vec4 layer2 = vec4(light1*light_color1,1.0) + layer3;\n    layer2 += .1 / length( (fragCoord+fragCoord-xy)/xy.y*1.8 + sin( iTime  + vec2(33,0) )  ) ;\n\n   // cercle central\n\tvec2 uv = 1.8*(2.0*fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 light_color = vec3(0.9, 0.1, 0.1);\n\tvec2 offset = vec2(tan(iTime),sin(iTime));;\n\tfloat light = 0.1 / distance(normalize(uv), uv); // Point de chute du ryon à la surface de la lune\n    float light2 = 0.5 / distance(normalize(uv), uv); // satellite\n    float light3 = 0.3 / distance(normalize(uv), uv*2.5); // rayon envoyé par le satellite\n    if(length(uv) > 1.0  ){\n\t\tlight *= 0.7 /  length( (fragCoord+fragCoord-xy)/xy.y + sin( iTime  + vec2(33,0) ) + light2 * light3);\n\n\t}\n    vec4 layer1 = vec4(light*light_color,0.0);\n\tfragColor = mix(layer1,mix(layer2,layer3,0.5),0.5); // affichage de tous les calques\n\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d2SDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[519, 571, 630, 630, 785], [788, 788, 845, 872, 2303]], "test": "valid"}
{"id": "7dBSDD", "name": "CLIP-to-cppn-to-glsl", "author": "vsewall", "description": "this glsl code was generated by google colab", "tags": ["clip", "neural", "cppn"], "likes": 5, "viewed": 196, "published": "Public", "date": "1620235847", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#ifdef GL_ES\nprecision lowp float;\n#endif\n\n#define N_HIDDEN 20\nvec4 bufA[N_HIDDEN/4];\nvec4 bufB[N_HIDDEN/2];\nvec4 cppn_fn(vec2 coordinate, float in0, float in1, float in2, float in3) {\n    vec4 tmp;\n    bufB[0] = vec4(coordinate.x, coordinate.y, 0., 0.);\n\n // layer 0 \nbufA[0] = vec4(-0.438, 0.054, -0.363, -0.006) + mat4(vec4(-0.710, 1.217, 0.011, -0.733), vec4(-0.082, 0.490, -0.409, 1.856), vec4(0.000, 0.000, 0.000, 0.000), vec4(0.000, 0.000, 0.000, 0.000)) * bufB[0];\nbufA[1] = vec4(-0.057, 0.111, -0.400, -0.045) + mat4(vec4(0.258, -0.912, -1.028, 0.743), vec4(-0.675, 0.193, 0.139, 0.705), vec4(0.000, 0.000, 0.000, 0.000), vec4(0.000, 0.000, 0.000, 0.000)) * bufB[0];\nbufA[2] = vec4(-0.117, -0.332, 0.397, -0.305) + mat4(vec4(1.362, -0.308, -1.502, -0.518), vec4(0.611, 1.164, 0.419, -0.247), vec4(0.000, 0.000, 0.000, 0.000), vec4(0.000, 0.000, 0.000, 0.000)) * bufB[0];\nbufA[3] = vec4(-0.305, 0.234, -0.233, 0.483) + mat4(vec4(-0.676, 0.794, 1.700, -0.016), vec4(0.417, -0.315, -0.683, -0.978), vec4(0.000, 0.000, 0.000, 0.000), vec4(0.000, 0.000, 0.000, 0.000)) * bufB[0];\nbufA[4] = vec4(0.170, -0.049, -0.391, -0.345) + mat4(vec4(-1.192, 0.070, 1.500, 1.881), vec4(0.112, -0.217, -1.199, 0.442), vec4(0.000, 0.000, 0.000, 0.000), vec4(0.000, 0.000, 0.000, 0.000)) * bufB[0];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 1 \nbufA[0] = vec4(0.194, 0.236, -0.370, -0.504) + mat4(vec4(-0.011, -0.090, -0.166, 0.098), vec4(0.052, -0.069, -0.364, 0.308), vec4(-0.142, 0.002, -0.146, 0.042), vec4(0.079, 0.150, -0.034, 0.154)) * bufB[0] + mat4(vec4(-0.135, -0.348, -0.076, 0.399), vec4(-0.298, -0.381, -0.015, -0.228), vec4(-0.099, -0.269, 0.050, -0.348), vec4(-0.231, 0.213, 0.248, 0.124)) * bufB[1] + mat4(vec4(0.127, 0.076, 0.171, -0.090), vec4(-0.042, 0.015, -0.210, -0.077), vec4(0.024, -0.119, 0.010, -0.244), vec4(0.158, -0.185, 0.002, 0.231)) * bufB[2] + mat4(vec4(-0.147, 0.124, -0.030, 0.086), vec4(0.023, 0.059, -0.024, -0.056), vec4(0.074, -0.248, 0.052, -0.165), vec4(0.084, -0.233, -0.114, -0.293)) * bufB[3] + mat4(vec4(-0.426, -0.064, 0.061, -0.127), vec4(-0.122, 0.091, -0.245, 0.089), vec4(0.027, 0.152, -0.291, 0.273), vec4(-0.069, -0.208, 0.036, 0.170)) * bufB[4] + mat4(vec4(0.171, -0.068, -0.057, 0.147), vec4(0.347, -0.208, 0.129, 0.159), vec4(0.063, 0.088, -0.163, 0.054), vec4(0.027, 0.051, -0.017, -0.347)) * bufB[5] + mat4(vec4(-0.057, -0.029, -0.098, 0.115), vec4(0.038, -0.101, 0.122, -0.051), vec4(-0.099, -0.188, -0.075, 0.030), vec4(0.223, 0.149, -0.401, 0.006)) * bufB[6] + mat4(vec4(0.142, -0.171, 0.037, -0.190), vec4(-0.153, -0.011, -0.012, -0.110), vec4(-0.082, 0.282, 0.291, -0.149), vec4(-0.250, -0.495, -0.296, -0.119)) * bufB[7] + mat4(vec4(-0.173, -0.047, -0.127, 0.027), vec4(-0.155, -0.114, 0.341, 0.082), vec4(-0.069, 0.245, 0.105, -0.014), vec4(0.340, -0.047, 0.056, 0.080)) * bufB[8] + mat4(vec4(0.145, 0.050, 0.108, -0.004), vec4(0.011, -0.088, -0.100, -0.086), vec4(0.266, 0.323, -0.115, -0.299), vec4(0.262, -0.091, 0.363, -0.192)) * bufB[9];\nbufA[1] = vec4(0.466, 0.076, -0.209, 0.096) + mat4(vec4(0.041, 0.083, 0.014, 0.187), vec4(0.083, -0.122, 0.245, -0.185), vec4(0.279, 0.006, -0.011, 0.077), vec4(-0.229, -0.152, -0.043, -0.037)) * bufB[0] + mat4(vec4(0.238, 0.098, -0.044, 0.096), vec4(0.031, 0.034, 0.011, 0.112), vec4(-0.132, 0.141, -0.110, -0.099), vec4(-0.234, -0.204, -0.349, 0.108)) * bufB[1] + mat4(vec4(-0.113, -0.261, 0.108, -0.173), vec4(0.006, -0.218, 0.292, 0.003), vec4(-0.038, -0.051, -0.003, 0.020), vec4(0.029, -0.301, 0.001, 0.479)) * bufB[2] + mat4(vec4(-0.198, -0.003, -0.300, 0.076), vec4(0.269, 0.146, -0.102, 0.064), vec4(-0.035, -0.116, -0.164, -0.254), vec4(0.468, -0.034, -0.008, 0.330)) * bufB[3] + mat4(vec4(0.060, -0.105, 0.122, 0.050), vec4(0.059, -0.131, -0.137, -0.006), vec4(-0.325, -0.227, 0.020, -0.047), vec4(-0.224, -0.057, -0.091, 0.209)) * bufB[4] + mat4(vec4(-0.200, 0.025, -0.098, 0.241), vec4(0.034, 0.205, 0.294, 0.057), vec4(0.028, -0.058, -0.118, 0.222), vec4(0.016, 0.049, -0.007, 0.093)) * bufB[5] + mat4(vec4(-0.004, 0.167, 0.125, -0.232), vec4(-0.107, 0.006, 0.126, 0.195), vec4(-0.413, -0.076, -0.030, -0.125), vec4(0.158, -0.008, -0.001, -0.040)) * bufB[6] + mat4(vec4(0.517, 0.236, 0.350, -0.123), vec4(0.199, 0.021, 0.130, -0.015), vec4(0.058, -0.099, 0.170, 0.165), vec4(-0.157, -0.023, 0.066, 0.193)) * bufB[7] + mat4(vec4(0.015, 0.088, -0.064, 0.061), vec4(0.106, -0.338, 0.071, 0.051), vec4(0.002, -0.104, 0.010, -0.031), vec4(-0.305, -0.134, 0.082, -0.086)) * bufB[8] + mat4(vec4(0.158, 0.144, 0.092, -0.010), vec4(-0.014, -0.016, 0.014, 0.109), vec4(0.022, 0.007, -0.138, -0.013), vec4(-0.071, 0.502, -0.026, 0.076)) * bufB[9];\nbufA[2] = vec4(-0.558, 0.246, 0.456, 0.177) + mat4(vec4(0.117, 0.122, 0.073, -0.241), vec4(0.072, 0.296, 0.270, 0.043), vec4(0.103, -0.036, 0.266, 0.285), vec4(0.151, 0.037, -0.029, -0.054)) * bufB[0] + mat4(vec4(0.081, 0.081, 0.232, -0.030), vec4(0.092, 0.031, -0.192, 0.032), vec4(-0.044, 0.089, -0.207, -0.313), vec4(0.080, 0.067, -0.016, 0.108)) * bufB[1] + mat4(vec4(-0.211, -0.131, 0.135, -0.213), vec4(-0.278, 0.161, 0.330, 0.048), vec4(-0.162, -0.036, 0.109, -0.071), vec4(0.129, -0.070, -0.320, -0.204)) * bufB[2] + mat4(vec4(-0.046, -0.062, -0.139, -0.271), vec4(0.440, 0.120, 0.074, -0.139), vec4(0.100, -0.090, -0.162, -0.022), vec4(-0.207, 0.238, 0.093, 0.187)) * bufB[3] + mat4(vec4(-0.089, -0.037, 0.184, 0.063), vec4(0.026, 0.039, -0.199, -0.014), vec4(0.106, -0.126, -0.026, -0.389), vec4(-0.277, -0.081, -0.081, -0.153)) * bufB[4] + mat4(vec4(-0.082, 0.006, 0.007, 0.215), vec4(-0.390, 0.346, -0.102, -0.041), vec4(-0.435, -0.073, 0.111, -0.303), vec4(-0.302, 0.091, -0.101, 0.227)) * bufB[5] + mat4(vec4(0.095, 0.096, 0.176, 0.146), vec4(-0.205, -0.103, -0.078, -0.186), vec4(-0.064, 0.080, -0.152, -0.099), vec4(-0.296, -0.049, 0.311, -0.164)) * bufB[6] + mat4(vec4(-0.059, -0.033, 0.048, 0.046), vec4(-0.136, -0.061, 0.049, -0.097), vec4(0.025, 0.170, -0.209, 0.159), vec4(0.005, -0.210, -0.292, -0.095)) * bufB[7] + mat4(vec4(0.116, -0.238, -0.015, -0.044), vec4(0.228, -0.247, 0.178, 0.191), vec4(0.050, 0.205, -0.255, 0.001), vec4(0.035, 0.081, -0.065, -0.027)) * bufB[8] + mat4(vec4(-0.146, 0.041, -0.017, 0.146), vec4(0.460, -0.108, -0.128, -0.215), vec4(-0.286, 0.039, -0.123, -0.320), vec4(-0.062, 0.057, 0.188, 0.272)) * bufB[9];\nbufA[3] = vec4(0.084, -0.265, -0.140, -0.135) + mat4(vec4(0.194, -0.187, 0.131, -0.150), vec4(-0.236, -0.000, -0.185, 0.094), vec4(0.279, 0.053, -0.010, -0.340), vec4(-0.311, -0.036, 0.104, 0.182)) * bufB[0] + mat4(vec4(0.171, 0.174, 0.121, -0.132), vec4(0.020, -0.079, -0.086, 0.001), vec4(-0.033, -0.030, -0.170, 0.187), vec4(-0.035, 0.424, -0.127, 0.002)) * bufB[1] + mat4(vec4(-0.006, -0.125, 0.000, 0.085), vec4(-0.181, 0.054, 0.099, -0.028), vec4(-0.032, -0.099, -0.079, 0.278), vec4(-0.062, -0.006, 0.068, 0.022)) * bufB[2] + mat4(vec4(-0.224, 0.107, -0.331, -0.054), vec4(0.074, 0.092, 0.030, -0.221), vec4(-0.130, -0.021, 0.131, 0.109), vec4(0.079, -0.150, -0.286, 0.013)) * bufB[3] + mat4(vec4(-0.200, -0.007, 0.178, 0.116), vec4(-0.092, 0.125, 0.053, 0.262), vec4(0.142, 0.204, 0.014, -0.253), vec4(-0.102, 0.136, 0.218, -0.108)) * bufB[4] + mat4(vec4(0.171, 0.326, 0.007, 0.063), vec4(0.130, -0.043, 0.012, 0.202), vec4(-0.138, 0.122, 0.000, 0.084), vec4(0.427, -0.081, 0.372, 0.102)) * bufB[5] + mat4(vec4(-0.023, -0.021, 0.191, -0.103), vec4(-0.360, -0.129, 0.053, 0.098), vec4(-0.089, 0.307, -0.000, -0.080), vec4(0.101, 0.095, -0.227, -0.035)) * bufB[6] + mat4(vec4(0.405, 0.149, -0.009, 0.199), vec4(-0.046, -0.095, 0.099, 0.131), vec4(0.117, 0.016, 0.091, 0.044), vec4(-0.052, 0.028, -0.163, 0.099)) * bufB[7] + mat4(vec4(-0.080, -0.371, -0.053, -0.153), vec4(0.010, 0.057, 0.107, 0.035), vec4(0.297, -0.059, -0.008, -0.060), vec4(0.223, 0.077, -0.344, -0.124)) * bufB[8] + mat4(vec4(0.327, -0.157, -0.115, 0.028), vec4(-0.366, 0.166, 0.126, 0.240), vec4(-0.026, -0.188, 0.144, 0.044), vec4(-0.035, -0.078, 0.141, -0.380)) * bufB[9];\nbufA[4] = vec4(0.120, -0.443, 0.019, -0.354) + mat4(vec4(0.192, 0.249, -0.013, 0.109), vec4(0.052, -0.140, 0.137, 0.197), vec4(-0.011, -0.080, 0.347, 0.062), vec4(0.080, 0.083, -0.082, 0.187)) * bufB[0] + mat4(vec4(-0.076, -0.009, -0.143, -0.282), vec4(-0.015, -0.148, -0.121, 0.074), vec4(-0.193, -0.116, -0.084, -0.244), vec4(0.023, -0.157, -0.018, 0.318)) * bufB[1] + mat4(vec4(0.222, 0.337, -0.166, -0.073), vec4(0.085, 0.098, -0.044, 0.299), vec4(-0.105, 0.193, 0.031, 0.059), vec4(-0.041, -0.006, 0.137, -0.174)) * bufB[2] + mat4(vec4(0.013, 0.303, -0.211, 0.341), vec4(0.207, -0.120, -0.047, 0.272), vec4(0.219, 0.078, 0.211, -0.028), vec4(0.119, -0.090, 0.394, -0.279)) * bufB[3] + mat4(vec4(0.080, -0.270, 0.038, 0.225), vec4(0.140, 0.098, 0.107, 0.124), vec4(0.305, 0.079, 0.078, -0.091), vec4(0.183, 0.205, -0.003, 0.338)) * bufB[4] + mat4(vec4(0.151, 0.163, 0.135, -0.263), vec4(0.015, 0.071, -0.035, -0.046), vec4(0.195, -0.288, 0.152, 0.045), vec4(0.015, 0.312, -0.254, 0.142)) * bufB[5] + mat4(vec4(0.164, 0.052, -0.064, -0.055), vec4(-0.249, 0.049, -0.124, -0.158), vec4(-0.304, 0.121, -0.052, -0.377), vec4(0.040, 0.335, 0.003, -0.206)) * bufB[6] + mat4(vec4(0.051, -0.026, 0.318, -0.130), vec4(-0.172, 0.007, 0.099, -0.106), vec4(-0.038, -0.078, -0.023, -0.174), vec4(-0.155, 0.204, 0.058, -0.108)) * bufB[7] + mat4(vec4(-0.107, -0.272, 0.017, 0.033), vec4(-0.073, 0.045, 0.113, -0.063), vec4(-0.024, -0.138, -0.322, 0.089), vec4(0.089, -0.060, 0.092, -0.318)) * bufB[8] + mat4(vec4(-0.190, -0.038, -0.177, -0.068), vec4(-0.031, -0.087, 0.314, -0.151), vec4(-0.084, -0.252, -0.302, -0.063), vec4(0.119, 0.253, -0.260, -0.246)) * bufB[9];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 2 \nbufA[0] = vec4(0.392, 0.421, -0.111, 0.303) + mat4(vec4(-0.017, 0.169, 0.225, -0.251), vec4(0.034, 0.301, -0.000, 0.153), vec4(-0.218, 0.387, -0.135, -0.014), vec4(-0.283, -0.013, -0.370, 0.034)) * bufB[0] + mat4(vec4(0.063, -0.128, 0.202, -0.036), vec4(0.083, 0.008, 0.165, 0.031), vec4(0.042, 0.036, 0.024, -0.101), vec4(-0.005, 0.013, -0.247, -0.168)) * bufB[1] + mat4(vec4(-0.265, 0.522, -0.623, 0.452), vec4(0.038, -0.058, 0.192, 0.142), vec4(-0.082, 0.058, 0.060, -0.038), vec4(-0.075, 0.063, 0.271, -0.193)) * bufB[2] + mat4(vec4(-0.207, 0.379, 0.436, -0.094), vec4(-0.125, 0.027, 0.069, 0.282), vec4(-0.232, 0.011, 0.138, -0.065), vec4(0.088, -0.241, 0.267, -0.020)) * bufB[3] + mat4(vec4(-0.062, -0.203, 0.091, -0.038), vec4(0.030, -0.223, 0.111, 0.079), vec4(-0.009, -0.098, 0.124, -0.089), vec4(0.177, 0.010, -0.225, -0.244)) * bufB[4] + mat4(vec4(0.112, -0.052, -0.007, 0.055), vec4(-0.068, -0.205, 0.256, -0.080), vec4(0.203, -0.034, 0.093, -0.092), vec4(0.043, -0.079, 0.106, 0.043)) * bufB[5] + mat4(vec4(-0.205, 0.087, -0.191, 0.116), vec4(-0.246, -0.236, 0.023, -0.204), vec4(-0.087, 0.029, -0.119, 0.024), vec4(-0.150, 0.215, -0.087, 0.271)) * bufB[6] + mat4(vec4(0.073, 0.039, -0.178, 0.023), vec4(0.143, 0.110, 0.187, -0.249), vec4(0.130, 0.165, -0.155, 0.237), vec4(0.025, 0.053, -0.005, 0.147)) * bufB[7] + mat4(vec4(0.181, -0.012, 0.077, 0.021), vec4(0.376, 0.084, 0.158, -0.103), vec4(-0.215, 0.336, 0.020, -0.011), vec4(-0.035, 0.189, -0.022, -0.248)) * bufB[8] + mat4(vec4(-0.030, -0.083, -0.183, 0.234), vec4(0.007, -0.003, -0.036, -0.020), vec4(0.158, -0.129, -0.123, 0.211), vec4(0.253, -0.146, -0.061, 0.058)) * bufB[9];\nbufA[1] = vec4(0.311, 0.075, -0.417, -0.385) + mat4(vec4(-0.232, -0.070, 0.090, -0.007), vec4(-0.008, 0.229, -0.061, 0.105), vec4(0.143, -0.049, 0.210, 0.197), vec4(-0.002, 0.076, -0.185, -0.132)) * bufB[0] + mat4(vec4(-0.168, -0.403, 0.540, 0.102), vec4(-0.057, -0.149, 0.258, -0.023), vec4(0.269, 0.110, 0.131, 0.084), vec4(0.095, 0.114, -0.004, 0.052)) * bufB[1] + mat4(vec4(-0.227, -0.203, -0.110, -0.283), vec4(-0.218, 0.044, 0.355, 0.162), vec4(0.011, -0.060, -0.147, -0.262), vec4(0.197, -0.203, -0.223, 0.063)) * bufB[2] + mat4(vec4(-0.355, 0.143, 0.076, -0.171), vec4(0.144, 0.376, -0.042, -0.169), vec4(0.103, -0.003, 0.067, 0.065), vec4(-0.042, 0.012, -0.015, -0.216)) * bufB[3] + mat4(vec4(-0.026, -0.026, -0.061, -0.115), vec4(0.061, -0.060, 0.230, -0.212), vec4(0.077, 0.004, -0.334, -0.144), vec4(-0.003, -0.106, 0.143, 0.077)) * bufB[4] + mat4(vec4(0.052, -0.112, 0.035, 0.168), vec4(0.231, -0.025, 0.097, 0.071), vec4(0.060, 0.207, -0.268, -0.130), vec4(0.067, 0.189, -0.187, -0.169)) * bufB[5] + mat4(vec4(-0.343, -0.208, 0.093, 0.079), vec4(0.502, 0.376, 0.119, -0.294), vec4(0.201, -0.051, -0.451, -0.315), vec4(0.017, 0.209, 0.066, -0.119)) * bufB[6] + mat4(vec4(-0.072, 0.213, 0.122, 0.111), vec4(0.108, -0.050, -0.056, -0.090), vec4(0.048, 0.213, -0.040, 0.045), vec4(-0.061, -0.126, 0.228, 0.149)) * bufB[7] + mat4(vec4(-0.180, -0.074, -0.171, 0.011), vec4(-0.075, -0.152, 0.202, 0.136), vec4(0.090, 0.324, -0.242, 0.016), vec4(0.158, -0.202, 0.107, -0.140)) * bufB[8] + mat4(vec4(0.044, -0.088, 0.178, -0.077), vec4(-0.451, 0.357, 0.028, -0.268), vec4(0.229, 0.370, -0.031, 0.229), vec4(0.047, -0.214, -0.034, -0.014)) * bufB[9];\nbufA[2] = vec4(-0.469, -0.276, 0.234, 0.355) + mat4(vec4(0.044, 0.041, -0.105, 0.159), vec4(0.248, -0.051, 0.132, -0.109), vec4(-0.065, 0.139, -0.438, 0.250), vec4(0.049, 0.237, 0.003, -0.050)) * bufB[0] + mat4(vec4(0.038, -0.058, -0.314, 0.032), vec4(0.086, 0.004, -0.137, 0.068), vec4(-0.321, -0.090, 0.140, 0.090), vec4(0.166, 0.125, -0.125, -0.209)) * bufB[1] + mat4(vec4(-0.355, 0.154, -0.105, -0.308), vec4(-0.183, 0.086, -0.191, -0.134), vec4(0.155, -0.198, 0.011, 0.224), vec4(-0.003, -0.239, -0.135, -0.011)) * bufB[2] + mat4(vec4(-0.060, -0.160, -0.266, -0.154), vec4(-0.063, 0.157, -0.069, -0.172), vec4(0.290, -0.162, 0.141, -0.160), vec4(0.047, -0.236, 0.138, 0.058)) * bufB[3] + mat4(vec4(0.039, -0.293, 0.284, -0.050), vec4(0.093, -0.165, 0.018, 0.142), vec4(-0.030, -0.033, -0.075, -0.009), vec4(-0.037, -0.119, 0.157, 0.019)) * bufB[4] + mat4(vec4(-0.132, -0.060, 0.004, -0.011), vec4(0.143, 0.096, 0.079, 0.145), vec4(-0.208, 0.085, -0.082, 0.264), vec4(0.110, 0.417, -0.519, 0.043)) * bufB[5] + mat4(vec4(-0.167, 0.152, -0.299, 0.402), vec4(-0.079, -0.083, -0.017, 0.171), vec4(-0.162, -0.302, 0.176, 0.061), vec4(-0.150, -0.075, 0.128, -0.136)) * bufB[6] + mat4(vec4(-0.069, -0.146, 0.177, -0.032), vec4(0.217, 0.044, -0.003, 0.248), vec4(0.155, 0.005, 0.063, -0.183), vec4(-0.046, -0.040, -0.086, 0.009)) * bufB[7] + mat4(vec4(0.305, 0.004, 0.199, -0.086), vec4(0.103, -0.036, -0.289, -0.013), vec4(-0.023, 0.171, -0.010, -0.116), vec4(0.062, 0.092, 0.008, -0.303)) * bufB[8] + mat4(vec4(-0.116, -0.135, -0.122, -0.112), vec4(-0.026, 0.125, 0.032, -0.076), vec4(0.020, -0.443, 0.177, 0.297), vec4(0.158, -0.085, 0.223, 0.106)) * bufB[9];\nbufA[3] = vec4(0.374, 0.188, -0.495, -0.234) + mat4(vec4(0.330, 0.088, -0.280, 0.062), vec4(0.213, 0.066, 0.187, 0.018), vec4(-0.005, -0.204, 0.271, -0.093), vec4(-0.024, -0.003, 0.134, -0.162)) * bufB[0] + mat4(vec4(0.246, 0.113, 0.047, 0.154), vec4(0.118, 0.006, 0.276, 0.062), vec4(0.057, 0.011, -0.260, -0.014), vec4(0.196, -0.107, -0.187, 0.013)) * bufB[1] + mat4(vec4(-0.376, -0.203, 0.152, 0.150), vec4(0.040, 0.102, 0.232, 0.124), vec4(0.049, 0.068, -0.026, -0.021), vec4(-0.060, 0.144, 0.439, -0.303)) * bufB[2] + mat4(vec4(0.053, 0.122, 0.072, 0.083), vec4(-0.013, -0.133, -0.313, -0.124), vec4(-0.018, 0.303, 0.006, 0.120), vec4(-0.158, 0.278, 0.189, -0.039)) * bufB[3] + mat4(vec4(0.024, -0.007, -0.072, 0.068), vec4(-0.122, 0.135, -0.186, -0.019), vec4(0.083, -0.283, -0.048, 0.148), vec4(-0.270, -0.137, -0.056, -0.088)) * bufB[4] + mat4(vec4(-0.128, -0.000, 0.260, 0.045), vec4(0.188, 0.351, -0.070, -0.185), vec4(-0.173, 0.335, 0.081, 0.121), vec4(-0.290, 0.014, -0.291, -0.002)) * bufB[5] + mat4(vec4(0.030, -0.143, 0.008, 0.058), vec4(0.010, 0.196, 0.221, 0.119), vec4(-0.014, -0.066, -0.119, -0.159), vec4(-0.049, -0.048, 0.019, 0.068)) * bufB[6] + mat4(vec4(-0.105, -0.274, -0.120, 0.108), vec4(0.068, 0.119, -0.049, 0.140), vec4(0.169, 0.031, 0.004, 0.181), vec4(0.088, -0.087, -0.049, 0.109)) * bufB[7] + mat4(vec4(-0.001, -0.034, 0.086, -0.257), vec4(-0.006, -0.379, -0.154, -0.012), vec4(-0.218, -0.368, -0.165, -0.118), vec4(0.204, 0.229, -0.093, 0.304)) * bufB[8] + mat4(vec4(0.042, 0.146, 0.089, 0.215), vec4(-0.096, 0.188, -0.168, -0.214), vec4(-0.085, 0.006, -0.209, -0.223), vec4(-0.006, 0.145, -0.121, 0.030)) * bufB[9];\nbufA[4] = vec4(-0.126, -0.275, 0.371, 0.398) + mat4(vec4(0.118, -0.046, -0.012, 0.140), vec4(0.080, 0.108, 0.160, -0.025), vec4(-0.154, 0.081, -0.123, -0.054), vec4(-0.172, 0.371, -0.132, -0.012)) * bufB[0] + mat4(vec4(0.023, -0.086, 0.079, 0.030), vec4(-0.078, 0.011, -0.245, 0.090), vec4(-0.038, -0.088, 0.146, 0.083), vec4(-0.121, 0.075, -0.174, 0.109)) * bufB[1] + mat4(vec4(0.251, -0.046, 0.123, 0.188), vec4(0.076, 0.242, -0.012, -0.118), vec4(0.200, -0.080, -0.035, 0.012), vec4(-0.142, -0.064, 0.283, 0.070)) * bufB[2] + mat4(vec4(0.110, 0.155, -0.069, 0.146), vec4(0.092, 0.240, -0.057, -0.063), vec4(0.176, 0.112, -0.111, -0.163), vec4(-0.212, -0.025, -0.266, 0.004)) * bufB[3] + mat4(vec4(-0.249, 0.043, 0.053, -0.061), vec4(0.420, 0.080, -0.030, 0.023), vec4(0.201, -0.085, -0.099, -0.051), vec4(0.080, 0.053, 0.255, 0.105)) * bufB[4] + mat4(vec4(0.117, 0.022, -0.304, 0.324), vec4(-0.297, -0.257, 0.071, 0.099), vec4(-0.213, 0.179, -0.268, -0.067), vec4(-0.009, -0.037, 0.005, 0.124)) * bufB[5] + mat4(vec4(-0.194, -0.040, 0.105, 0.107), vec4(0.079, 0.114, 0.176, -0.227), vec4(-0.314, 0.215, 0.019, 0.351), vec4(0.233, 0.057, 0.041, 0.073)) * bufB[6] + mat4(vec4(0.176, 0.114, 0.029, 0.067), vec4(0.228, -0.230, -0.323, 0.106), vec4(0.274, -0.108, 0.038, 0.076), vec4(0.121, -0.014, -0.043, 0.056)) * bufB[7] + mat4(vec4(0.128, -0.459, -0.006, 0.024), vec4(-0.160, 0.234, -0.112, -0.040), vec4(0.051, 0.012, -0.085, -0.082), vec4(0.200, 0.052, -0.001, 0.022)) * bufB[8] + mat4(vec4(0.391, 0.029, -0.150, 0.174), vec4(-0.061, 0.133, -0.075, 0.338), vec4(0.002, -0.153, -0.140, 0.201), vec4(-0.091, -0.296, 0.055, -0.125)) * bufB[9];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 3 \nbufA[0] = vec4(-0.249, 0.123, -0.313, -0.249) + mat4(vec4(0.215, -0.066, -0.030, 0.117), vec4(-0.103, -0.219, -0.079, 0.007), vec4(-0.217, -0.213, -0.176, 0.214), vec4(-0.215, -0.007, 0.169, -0.125)) * bufB[0] + mat4(vec4(-0.149, -0.207, 0.181, 0.091), vec4(-0.001, 0.265, -0.015, 0.028), vec4(-0.133, 0.057, 0.065, 0.001), vec4(-0.001, 0.067, -0.043, -0.161)) * bufB[1] + mat4(vec4(0.111, 0.006, -0.065, 0.158), vec4(-0.232, 0.129, -0.090, 0.130), vec4(0.078, -0.054, 0.108, -0.146), vec4(-0.268, -0.038, 0.006, 0.077)) * bufB[2] + mat4(vec4(-0.134, -0.267, 0.223, 0.182), vec4(0.165, 0.109, -0.324, 0.294), vec4(0.066, 0.025, 0.006, 0.186), vec4(-0.036, -0.217, 0.163, -0.033)) * bufB[3] + mat4(vec4(0.030, -0.070, -0.048, -0.032), vec4(-0.245, 0.272, 0.285, -0.176), vec4(-0.172, -0.074, 0.062, -0.063), vec4(-0.035, 0.319, -0.116, 0.009)) * bufB[4] + mat4(vec4(-0.125, 0.179, -0.176, -0.015), vec4(0.304, -0.209, 0.005, -0.310), vec4(0.205, -0.228, -0.306, -0.306), vec4(0.168, 0.087, -0.020, 0.222)) * bufB[5] + mat4(vec4(0.066, 0.124, -0.038, 0.074), vec4(-0.062, 0.049, 0.012, -0.061), vec4(0.215, -0.146, 0.147, 0.047), vec4(-0.110, -0.069, 0.181, 0.069)) * bufB[6] + mat4(vec4(-0.232, 0.031, 0.157, -0.035), vec4(-0.040, 0.046, 0.191, 0.391), vec4(-0.119, -0.034, -0.002, 0.195), vec4(-0.125, -0.076, -0.265, 0.017)) * bufB[7] + mat4(vec4(0.007, -0.021, -0.347, 0.065), vec4(-0.266, -0.128, 0.027, 0.072), vec4(0.206, -0.177, -0.161, -0.139), vec4(-0.052, -0.140, -0.019, -0.190)) * bufB[8] + mat4(vec4(0.201, 0.296, 0.140, -0.043), vec4(0.154, -0.078, -0.087, 0.143), vec4(-0.077, -0.185, -0.071, -0.407), vec4(-0.112, -0.236, -0.090, 0.005)) * bufB[9] + in0;\nbufA[1] = vec4(0.033, -0.176, 0.043, 0.092) + mat4(vec4(-0.023, -0.293, -0.129, -0.239), vec4(-0.144, -0.152, 0.328, -0.074), vec4(0.039, -0.038, -0.148, -0.078), vec4(0.020, 0.058, 0.094, -0.000)) * bufB[0] + mat4(vec4(0.119, 0.022, -0.142, -0.200), vec4(0.128, -0.035, -0.050, -0.190), vec4(-0.273, 0.049, -0.157, -0.038), vec4(-0.133, 0.059, 0.079, 0.156)) * bufB[1] + mat4(vec4(-0.181, -0.038, -0.244, 0.155), vec4(0.161, 0.192, 0.331, -0.169), vec4(0.053, -0.052, -0.082, -0.025), vec4(-0.280, -0.054, 0.001, -0.094)) * bufB[2] + mat4(vec4(0.296, -0.140, 0.090, 0.167), vec4(-0.219, -0.044, -0.032, 0.184), vec4(-0.256, -0.038, 0.160, 0.186), vec4(0.001, -0.121, -0.174, 0.015)) * bufB[3] + mat4(vec4(0.140, 0.093, 0.188, 0.027), vec4(0.192, -0.098, 0.341, 0.079), vec4(-0.016, -0.442, 0.273, 0.114), vec4(-0.143, -0.017, 0.077, -0.212)) * bufB[4] + mat4(vec4(-0.060, 0.118, -0.159, 0.338), vec4(-0.185, 0.026, -0.088, -0.036), vec4(-0.186, 0.043, -0.092, -0.044), vec4(0.101, -0.037, 0.024, -0.033)) * bufB[5] + mat4(vec4(0.169, 0.234, 0.162, 0.078), vec4(0.163, -0.315, 0.247, 0.110), vec4(-0.065, -0.119, 0.065, 0.047), vec4(-0.015, 0.170, 0.004, 0.014)) * bufB[6] + mat4(vec4(0.075, 0.095, 0.170, -0.248), vec4(-0.023, -0.072, 0.238, -0.161), vec4(0.206, 0.271, -0.146, 0.118), vec4(-0.231, -0.161, -0.063, -0.058)) * bufB[7] + mat4(vec4(0.195, -0.110, 0.037, -0.099), vec4(0.096, 0.029, -0.044, 0.058), vec4(0.171, -0.024, 0.090, -0.168), vec4(0.102, 0.007, -0.227, 0.259)) * bufB[8] + mat4(vec4(-0.116, 0.183, 0.040, -0.165), vec4(0.044, 0.097, -0.066, 0.010), vec4(-0.055, -0.064, 0.087, 0.102), vec4(0.038, 0.018, 0.148, 0.011)) * bufB[9] + in1;\nbufA[2] = vec4(-0.118, 0.223, 0.356, -0.385) + mat4(vec4(0.189, -0.037, -0.041, -0.199), vec4(-0.166, -0.082, 0.050, 0.298), vec4(0.087, -0.174, 0.264, -0.114), vec4(-0.252, -0.170, 0.108, 0.061)) * bufB[0] + mat4(vec4(0.088, 0.046, 0.104, -0.175), vec4(0.110, 0.047, -0.150, -0.131), vec4(-0.112, -0.126, 0.082, -0.012), vec4(0.006, -0.103, -0.289, 0.090)) * bufB[1] + mat4(vec4(-0.029, 0.253, 0.020, -0.114), vec4(0.413, -0.047, 0.113, 0.099), vec4(0.138, -0.069, -0.208, -0.097), vec4(0.192, 0.058, 0.007, -0.160)) * bufB[2] + mat4(vec4(-0.082, 0.134, -0.171, 0.411), vec4(0.356, 0.156, -0.142, -0.024), vec4(-0.192, -0.037, -0.125, 0.033), vec4(0.065, 0.165, -0.187, -0.056)) * bufB[3] + mat4(vec4(-0.238, -0.021, -0.021, -0.057), vec4(-0.198, -0.223, 0.069, 0.103), vec4(0.189, 0.078, 0.115, 0.169), vec4(-0.336, -0.100, -0.307, 0.275)) * bufB[4] + mat4(vec4(-0.043, 0.236, -0.143, -0.080), vec4(0.168, -0.011, 0.262, 0.117), vec4(0.044, 0.003, -0.027, -0.191), vec4(-0.127, -0.443, -0.193, -0.172)) * bufB[5] + mat4(vec4(0.188, -0.052, 0.262, 0.455), vec4(0.124, -0.009, -0.159, 0.259), vec4(0.016, -0.080, -0.210, -0.130), vec4(0.032, 0.092, 0.162, -0.234)) * bufB[6] + mat4(vec4(-0.229, 0.004, 0.116, -0.093), vec4(0.237, -0.224, 0.026, -0.126), vec4(0.722, 0.133, 0.423, -0.194), vec4(0.178, -0.020, -0.112, -0.035)) * bufB[7] + mat4(vec4(0.042, -0.004, 0.040, 0.062), vec4(-0.003, -0.001, 0.042, -0.020), vec4(0.340, 0.051, 0.187, -0.017), vec4(0.002, 0.443, 0.167, -0.046)) * bufB[8] + mat4(vec4(-0.063, 0.141, 0.105, 0.334), vec4(0.045, 0.294, -0.028, 0.221), vec4(-0.245, -0.059, -0.087, -0.028), vec4(0.014, -0.066, -0.074, -0.061)) * bufB[9] + in2;\nbufA[3] = vec4(0.345, -0.043, -0.206, -0.395) + mat4(vec4(0.019, -0.099, -0.261, -0.096), vec4(0.277, 0.078, 0.005, -0.005), vec4(0.020, -0.072, 0.218, -0.248), vec4(-0.160, -0.038, -0.049, 0.227)) * bufB[0] + mat4(vec4(-0.007, 0.091, -0.125, 0.169), vec4(-0.241, 0.168, 0.405, -0.044), vec4(-0.072, 0.132, 0.213, 0.037), vec4(0.262, -0.163, 0.024, 0.025)) * bufB[1] + mat4(vec4(0.093, -0.297, 0.242, 0.212), vec4(0.200, -0.142, -0.034, 0.122), vec4(-0.066, 0.221, -0.186, 0.178), vec4(-0.129, 0.100, -0.065, 0.132)) * bufB[2] + mat4(vec4(-0.194, -0.002, -0.159, -0.087), vec4(-0.167, 0.289, 0.009, -0.250), vec4(-0.065, 0.003, -0.232, -0.156), vec4(0.085, -0.105, 0.075, -0.177)) * bufB[3] + mat4(vec4(-0.040, -0.039, -0.396, 0.072), vec4(0.140, 0.198, -0.304, -0.001), vec4(0.076, 0.028, 0.078, -0.203), vec4(0.071, 0.104, 0.015, -0.173)) * bufB[4] + mat4(vec4(0.028, -0.132, 0.072, -0.046), vec4(0.039, 0.002, -0.008, -0.224), vec4(-0.037, 0.115, 0.060, -0.259), vec4(0.126, -0.047, 0.031, -0.077)) * bufB[5] + mat4(vec4(0.170, -0.087, -0.155, 0.274), vec4(0.095, -0.291, -0.124, 0.115), vec4(-0.005, -0.000, 0.166, -0.061), vec4(0.125, 0.091, 0.028, 0.016)) * bufB[6] + mat4(vec4(0.350, 0.268, -0.104, -0.246), vec4(0.122, 0.184, -0.105, -0.141), vec4(-0.192, 0.157, -0.210, -0.278), vec4(-0.195, -0.172, 0.393, 0.020)) * bufB[7] + mat4(vec4(0.175, 0.179, 0.069, 0.025), vec4(-0.165, 0.133, 0.198, -0.237), vec4(-0.315, 0.086, -0.126, -0.041), vec4(-0.049, -0.094, -0.037, -0.008)) * bufB[8] + mat4(vec4(0.242, -0.384, 0.132, 0.213), vec4(-0.492, -0.134, 0.066, 0.160), vec4(-0.134, 0.370, -0.209, -0.065), vec4(0.215, -0.195, -0.035, 0.027)) * bufB[9] + in3;\nbufA[4] = vec4(0.144, 0.129, 0.482, 0.044) + mat4(vec4(-0.014, 0.008, 0.015, 0.253), vec4(-0.270, -0.019, 0.091, -0.037), vec4(-0.229, -0.319, -0.022, 0.223), vec4(0.101, 0.104, 0.087, 0.116)) * bufB[0] + mat4(vec4(-0.095, 0.143, -0.116, 0.209), vec4(0.003, 0.223, -0.217, 0.029), vec4(-0.116, -0.263, -0.001, -0.026), vec4(-0.134, -0.005, 0.120, 0.128)) * bufB[1] + mat4(vec4(-0.354, 0.208, -0.155, 0.048), vec4(-0.030, -0.177, -0.251, 0.095), vec4(0.120, 0.314, -0.107, 0.071), vec4(-0.217, 0.017, 0.299, -0.249)) * bufB[2] + mat4(vec4(-0.084, -0.132, 0.094, -0.054), vec4(-0.018, 0.038, 0.257, 0.009), vec4(0.178, 0.251, 0.085, 0.149), vec4(-0.329, -0.210, -0.110, 0.002)) * bufB[3] + mat4(vec4(-0.068, 0.013, 0.089, 0.006), vec4(-0.074, 0.086, 0.228, -0.221), vec4(0.176, -0.286, -0.049, -0.045), vec4(0.121, -0.336, 0.015, -0.098)) * bufB[4] + mat4(vec4(0.106, -0.304, -0.066, -0.305), vec4(0.172, -0.001, -0.208, 0.108), vec4(0.042, -0.000, -0.033, 0.125), vec4(-0.241, -0.199, -0.097, -0.059)) * bufB[5] + mat4(vec4(0.044, -0.399, 0.078, 0.062), vec4(-0.096, 0.018, -0.118, 0.183), vec4(0.238, 0.005, -0.012, -0.103), vec4(0.060, 0.034, 0.463, -0.169)) * bufB[6] + mat4(vec4(-0.367, -0.088, -0.052, 0.122), vec4(0.035, -0.031, -0.215, 0.020), vec4(0.117, -0.129, -0.050, 0.218), vec4(0.251, -0.155, 0.160, 0.016)) * bufB[7] + mat4(vec4(-0.332, -0.223, -0.062, -0.170), vec4(-0.047, -0.193, 0.006, 0.064), vec4(0.264, 0.032, 0.011, -0.115), vec4(-0.034, 0.170, 0.079, 0.221)) * bufB[8] + mat4(vec4(0.246, 0.261, 0.139, -0.255), vec4(-0.100, 0.122, -0.069, 0.101), vec4(-0.194, 0.056, 0.064, -0.106), vec4(-0.038, 0.052, -0.172, 0.165)) * bufB[9] + in0;\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 4 \nbufA[0] = vec4(0.285, 0.106, -0.327, 0.159) + mat4(vec4(0.201, -0.127, -0.037, -0.240), vec4(-0.157, -0.174, -0.007, 0.208), vec4(-0.095, 0.053, 0.077, -0.299), vec4(-0.103, -0.248, 0.333, 0.046)) * bufB[0] + mat4(vec4(0.087, -0.130, 0.137, -0.067), vec4(0.080, 0.025, -0.362, 0.040), vec4(0.140, 0.304, -0.095, 0.237), vec4(0.104, -0.287, 0.142, 0.033)) * bufB[1] + mat4(vec4(-0.093, 0.203, -0.123, -0.032), vec4(-0.019, 0.022, -0.051, 0.079), vec4(0.054, 0.058, -0.050, 0.041), vec4(-0.028, 0.068, 0.385, 0.313)) * bufB[2] + mat4(vec4(-0.129, 0.019, -0.148, 0.298), vec4(-0.072, 0.407, 0.255, 0.026), vec4(0.186, -0.062, -0.087, -0.012), vec4(-0.149, -0.153, -0.260, 0.031)) * bufB[3] + mat4(vec4(0.167, -0.037, 0.222, 0.254), vec4(-0.240, -0.195, -0.012, -0.221), vec4(0.009, -0.057, -0.061, -0.106), vec4(0.160, 0.128, -0.139, 0.044)) * bufB[4] + mat4(vec4(0.284, 0.144, -0.037, 0.208), vec4(0.116, 0.095, -0.107, 0.066), vec4(-0.065, -0.289, -0.114, -0.001), vec4(0.109, 0.073, 0.010, 0.034)) * bufB[5] + mat4(vec4(-0.161, -0.167, -0.023, -0.028), vec4(0.027, -0.016, -0.243, 0.043), vec4(-0.213, 0.158, 0.285, -0.087), vec4(-0.167, -0.018, 0.170, 0.364)) * bufB[6] + mat4(vec4(-0.193, -0.162, -0.050, -0.481), vec4(-0.047, -0.196, -0.250, 0.093), vec4(-0.118, 0.198, 0.207, 0.035), vec4(0.304, -0.023, 0.174, -0.499)) * bufB[7] + mat4(vec4(0.068, -0.018, -0.046, -0.106), vec4(0.212, 0.141, -0.311, 0.098), vec4(-0.101, 0.137, -0.054, 0.101), vec4(-0.219, 0.097, 0.027, -0.034)) * bufB[8] + mat4(vec4(-0.258, 0.155, -0.143, 0.163), vec4(0.164, 0.114, 0.038, 0.131), vec4(0.058, 0.072, -0.035, -0.100), vec4(-0.169, 0.022, -0.039, -0.037)) * bufB[9];\nbufA[1] = vec4(-0.213, -0.029, -0.161, -0.363) + mat4(vec4(-0.175, 0.157, 0.066, -0.119), vec4(0.192, 0.016, -0.249, -0.022), vec4(-0.362, 0.067, -0.076, 0.194), vec4(0.212, -0.206, -0.113, -0.027)) * bufB[0] + mat4(vec4(-0.002, 0.277, 0.018, -0.266), vec4(0.163, -0.003, -0.138, -0.088), vec4(0.006, 0.321, -0.136, 0.403), vec4(0.045, 0.066, 0.040, -0.135)) * bufB[1] + mat4(vec4(0.002, 0.069, -0.193, 0.177), vec4(0.116, -0.004, 0.103, 0.107), vec4(0.079, -0.044, 0.287, 0.258), vec4(0.077, -0.137, 0.032, -0.053)) * bufB[2] + mat4(vec4(-0.072, -0.034, 0.078, -0.038), vec4(-0.187, 0.011, -0.072, 0.161), vec4(-0.152, -0.236, -0.213, -0.019), vec4(0.166, 0.003, -0.090, 0.133)) * bufB[3] + mat4(vec4(-0.074, 0.125, 0.085, -0.065), vec4(-0.079, 0.066, 0.045, 0.045), vec4(0.038, 0.014, -0.107, -0.054), vec4(0.288, 0.119, -0.077, -0.110)) * bufB[4] + mat4(vec4(0.016, -0.019, -0.101, 0.085), vec4(0.045, 0.012, -0.017, -0.293), vec4(0.178, -0.214, 0.101, -0.292), vec4(-0.089, -0.101, 0.148, -0.015)) * bufB[5] + mat4(vec4(-0.154, 0.021, 0.160, -0.045), vec4(-0.107, -0.067, 0.107, 0.219), vec4(-0.162, -0.044, 0.364, -0.031), vec4(0.231, -0.165, 0.016, 0.145)) * bufB[6] + mat4(vec4(-0.082, -0.292, 0.174, 0.203), vec4(0.015, -0.016, -0.219, 0.081), vec4(-0.108, -0.103, -0.182, -0.005), vec4(-0.007, 0.012, -0.039, 0.113)) * bufB[7] + mat4(vec4(-0.299, -0.122, -0.039, -0.319), vec4(-0.268, 0.107, 0.006, -0.210), vec4(0.237, 0.039, 0.092, 0.067), vec4(-0.149, -0.155, 0.090, 0.115)) * bufB[8] + mat4(vec4(-0.001, -0.213, -0.207, -0.060), vec4(0.337, -0.027, -0.087, -0.129), vec4(0.072, 0.002, -0.047, 0.165), vec4(-0.236, -0.078, 0.082, 0.232)) * bufB[9];\nbufA[2] = vec4(0.329, 0.137, -0.260, -0.213) + mat4(vec4(-0.410, -0.224, 0.301, -0.036), vec4(0.292, 0.114, -0.100, 0.127), vec4(0.143, -0.017, -0.275, -0.038), vec4(-0.215, -0.025, -0.005, -0.127)) * bufB[0] + mat4(vec4(-0.038, -0.052, 0.149, 0.090), vec4(0.131, 0.347, -0.022, 0.126), vec4(0.021, -0.105, -0.025, 0.045), vec4(-0.215, -0.046, 0.075, -0.229)) * bufB[1] + mat4(vec4(0.004, -0.360, -0.233, -0.208), vec4(0.326, 0.074, -0.099, -0.269), vec4(-0.130, 0.006, 0.206, 0.218), vec4(0.081, -0.082, 0.079, 0.041)) * bufB[2] + mat4(vec4(-0.298, -0.089, -0.101, 0.141), vec4(-0.058, -0.417, -0.350, 0.037), vec4(-0.205, 0.300, -0.031, 0.504), vec4(0.216, -0.062, -0.093, -0.086)) * bufB[3] + mat4(vec4(0.218, -0.013, 0.022, -0.318), vec4(-0.038, 0.012, -0.119, 0.211), vec4(-0.038, 0.045, -0.115, 0.111), vec4(-0.159, -0.065, -0.086, -0.122)) * bufB[4] + mat4(vec4(0.077, -0.170, -0.071, -0.122), vec4(-0.265, -0.149, 0.026, 0.229), vec4(-0.123, 0.020, 0.211, 0.209), vec4(0.067, 0.179, 0.080, -0.131)) * bufB[5] + mat4(vec4(-0.002, -0.051, -0.092, 0.042), vec4(-0.267, 0.276, 0.163, 0.250), vec4(-0.025, 0.053, -0.140, 0.000), vec4(-0.059, -0.019, 0.191, -0.021)) * bufB[6] + mat4(vec4(-0.314, -0.270, -0.003, 0.048), vec4(0.188, 0.040, -0.259, 0.055), vec4(0.102, -0.093, 0.129, 0.112), vec4(0.008, -0.123, 0.132, -0.023)) * bufB[7] + mat4(vec4(0.122, -0.179, -0.200, -0.115), vec4(0.100, 0.090, 0.435, -0.206), vec4(-0.008, -0.021, -0.168, -0.157), vec4(0.043, -0.068, -0.295, 0.163)) * bufB[8] + mat4(vec4(-0.003, -0.090, -0.000, -0.273), vec4(0.023, -0.110, -0.173, -0.080), vec4(0.032, 0.315, 0.277, -0.196), vec4(0.049, -0.097, 0.298, 0.066)) * bufB[9];\nbufA[3] = vec4(0.165, 0.147, -0.378, 0.205) + mat4(vec4(-0.091, -0.252, -0.252, 0.073), vec4(0.399, 0.072, -0.170, -0.171), vec4(0.125, -0.029, -0.096, -0.208), vec4(0.096, 0.331, 0.052, 0.219)) * bufB[0] + mat4(vec4(-0.115, 0.025, 0.068, 0.031), vec4(-0.394, -0.047, 0.097, 0.120), vec4(0.101, -0.115, -0.111, 0.023), vec4(0.026, 0.065, -0.110, 0.030)) * bufB[1] + mat4(vec4(-0.147, 0.111, -0.146, 0.215), vec4(-0.103, -0.103, -0.055, -0.196), vec4(0.013, 0.070, -0.051, 0.031), vec4(-0.077, -0.278, -0.010, -0.245)) * bufB[2] + mat4(vec4(0.344, 0.102, -0.427, 0.123), vec4(-0.220, -0.385, -0.020, 0.173), vec4(0.010, 0.105, -0.087, 0.021), vec4(0.281, 0.035, -0.049, -0.057)) * bufB[3] + mat4(vec4(-0.178, -0.121, -0.013, -0.041), vec4(0.038, -0.161, 0.242, 0.130), vec4(-0.161, -0.171, -0.113, 0.192), vec4(-0.208, -0.112, 0.237, 0.114)) * bufB[4] + mat4(vec4(-0.279, -0.045, 0.202, -0.084), vec4(-0.121, 0.059, -0.020, 0.070), vec4(-0.009, 0.326, -0.013, 0.243), vec4(0.089, -0.173, -0.021, -0.188)) * bufB[5] + mat4(vec4(-0.057, 0.231, -0.317, -0.036), vec4(0.138, 0.050, -0.145, -0.123), vec4(-0.194, 0.009, 0.308, -0.202), vec4(-0.174, -0.123, 0.101, 0.172)) * bufB[6] + mat4(vec4(0.144, -0.012, -0.332, 0.082), vec4(0.510, -0.117, 0.036, -0.098), vec4(0.081, 0.355, -0.040, -0.004), vec4(-0.333, 0.083, -0.182, -0.200)) * bufB[7] + mat4(vec4(-0.054, -0.247, 0.169, 0.113), vec4(0.311, 0.150, -0.008, 0.013), vec4(0.030, -0.035, -0.062, 0.159), vec4(0.025, -0.123, 0.083, 0.440)) * bufB[8] + mat4(vec4(0.090, 0.063, 0.107, 0.177), vec4(0.166, 0.148, -0.190, 0.184), vec4(0.082, 0.129, -0.126, -0.034), vec4(-0.115, -0.030, -0.024, 0.018)) * bufB[9];\nbufA[4] = vec4(-0.442, 0.419, -0.084, 0.013) + mat4(vec4(-0.334, -0.073, -0.248, 0.007), vec4(-0.057, -0.056, 0.132, 0.167), vec4(-0.092, -0.257, -0.084, -0.014), vec4(0.196, 0.083, -0.072, 0.317)) * bufB[0] + mat4(vec4(0.162, -0.168, -0.115, -0.037), vec4(0.156, 0.155, 0.048, 0.476), vec4(0.274, 0.013, -0.107, -0.352), vec4(-0.135, 0.041, 0.107, -0.179)) * bufB[1] + mat4(vec4(0.348, 0.431, 0.200, 0.146), vec4(0.010, 0.204, 0.137, -0.198), vec4(0.119, -0.102, 0.227, -0.127), vec4(-0.137, -0.121, 0.052, -0.010)) * bufB[2] + mat4(vec4(0.007, -0.027, -0.116, -0.080), vec4(0.140, 0.019, 0.021, -0.171), vec4(0.261, -0.103, 0.221, 0.413), vec4(0.068, -0.370, -0.205, 0.132)) * bufB[3] + mat4(vec4(-0.510, -0.004, 0.088, -0.201), vec4(-0.257, 0.130, -0.140, -0.038), vec4(-0.252, -0.096, -0.056, -0.005), vec4(0.192, 0.119, -0.108, 0.143)) * bufB[4] + mat4(vec4(-0.149, -0.142, -0.393, -0.069), vec4(0.092, -0.368, 0.055, 0.055), vec4(-0.000, -0.146, -0.093, 0.054), vec4(-0.247, 0.078, -0.032, 0.018)) * bufB[5] + mat4(vec4(0.483, 0.054, -0.048, 0.242), vec4(-0.034, 0.155, 0.069, -0.029), vec4(-0.090, 0.150, -0.071, 0.052), vec4(0.045, 0.315, -0.050, -0.076)) * bufB[6] + mat4(vec4(0.035, -0.321, 0.420, 0.202), vec4(0.433, -0.212, 0.174, 0.133), vec4(0.032, 0.178, 0.241, 0.084), vec4(0.030, 0.007, -0.028, 0.229)) * bufB[7] + mat4(vec4(0.272, -0.003, 0.091, -0.012), vec4(-0.100, 0.247, 0.276, 0.210), vec4(-0.052, -0.076, -0.227, 0.011), vec4(-0.131, 0.027, 0.249, 0.004)) * bufB[8] + mat4(vec4(0.038, 0.231, 0.130, -0.222), vec4(0.122, -0.021, 0.110, 0.102), vec4(-0.103, 0.059, 0.193, 0.176), vec4(-0.008, 0.063, 0.157, -0.019)) * bufB[9];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 5 \nbufA[0] = vec4(-0.509, -0.103, -0.270, -0.490) + mat4(vec4(-0.123, -0.022, -0.147, -0.342), vec4(-0.098, 0.053, -0.244, -0.143), vec4(0.305, 0.072, -0.069, 0.069), vec4(0.104, -0.101, 0.175, 0.001)) * bufB[0] + mat4(vec4(0.120, -0.374, -0.194, -0.277), vec4(-0.015, -0.269, -0.084, 0.146), vec4(0.134, -0.049, 0.046, 0.113), vec4(0.263, 0.127, 0.007, -0.154)) * bufB[1] + mat4(vec4(-0.156, 0.001, 0.015, -0.292), vec4(0.109, 0.095, -0.225, 0.108), vec4(0.148, -0.217, -0.055, -0.128), vec4(0.149, -0.010, -0.089, -0.025)) * bufB[2] + mat4(vec4(-0.031, 0.121, 0.371, -0.170), vec4(-0.164, 0.076, 0.038, -0.147), vec4(0.053, 0.261, 0.235, 0.111), vec4(0.009, -0.109, -0.090, -0.039)) * bufB[3] + mat4(vec4(0.198, -0.082, -0.278, 0.035), vec4(-0.293, -0.073, 0.169, -0.029), vec4(-0.224, -0.007, 0.282, -0.033), vec4(0.103, 0.099, -0.086, -0.140)) * bufB[4] + mat4(vec4(0.190, -0.133, 0.062, 0.070), vec4(-0.080, -0.152, 0.172, -0.052), vec4(0.104, 0.103, 0.067, 0.046), vec4(0.083, 0.075, -0.284, -0.195)) * bufB[5] + mat4(vec4(-0.131, -0.036, -0.150, 0.053), vec4(0.316, -0.139, -0.243, 0.342), vec4(0.114, -0.134, 0.107, 0.214), vec4(0.133, 0.076, -0.043, -0.044)) * bufB[6] + mat4(vec4(0.167, 0.041, -0.329, -0.064), vec4(-0.045, 0.069, 0.107, -0.033), vec4(-0.388, 0.075, -0.163, -0.013), vec4(0.055, -0.127, 0.476, 0.164)) * bufB[7] + mat4(vec4(0.221, -0.176, -0.047, -0.048), vec4(-0.043, -0.090, -0.159, 0.433), vec4(-0.141, 0.197, -0.252, -0.124), vec4(0.096, -0.013, -0.062, -0.108)) * bufB[8] + mat4(vec4(-0.026, -0.178, 0.189, -0.056), vec4(0.126, 0.173, 0.175, -0.098), vec4(0.179, -0.010, 0.048, -0.049), vec4(-0.088, 0.011, 0.280, -0.114)) * bufB[9];\nbufA[1] = vec4(-0.186, 0.079, -0.263, -0.220) + mat4(vec4(0.005, 0.133, -0.075, 0.194), vec4(0.355, 0.050, -0.076, -0.454), vec4(-0.047, 0.024, 0.066, 0.124), vec4(-0.219, 0.023, -0.027, -0.107)) * bufB[0] + mat4(vec4(0.043, 0.170, -0.005, -0.133), vec4(-0.053, -0.503, -0.048, -0.048), vec4(-0.049, -0.002, 0.073, 0.209), vec4(-0.199, 0.045, 0.063, 0.083)) * bufB[1] + mat4(vec4(-0.070, -0.078, -0.112, 0.251), vec4(-0.002, 0.113, -0.003, 0.165), vec4(-0.184, -0.079, -0.110, 0.224), vec4(-0.021, -0.235, -0.230, -0.023)) * bufB[2] + mat4(vec4(-0.023, 0.277, 0.173, 0.156), vec4(0.201, -0.035, 0.024, 0.190), vec4(0.102, -0.347, 0.047, 0.009), vec4(0.243, 0.023, 0.432, -0.205)) * bufB[3] + mat4(vec4(0.104, -0.187, 0.048, -0.058), vec4(-0.145, -0.113, -0.168, -0.128), vec4(-0.333, 0.077, 0.185, 0.076), vec4(-0.023, -0.087, 0.094, 0.220)) * bufB[4] + mat4(vec4(-0.109, -0.166, -0.299, 0.021), vec4(0.161, 0.050, -0.055, 0.215), vec4(0.274, -0.080, -0.231, 0.308), vec4(0.065, -0.206, 0.193, 0.050)) * bufB[5] + mat4(vec4(0.019, 0.030, 0.204, 0.033), vec4(0.259, 0.003, -0.072, -0.300), vec4(-0.194, 0.067, 0.172, 0.289), vec4(-0.020, 0.277, -0.029, 0.108)) * bufB[6] + mat4(vec4(-0.222, -0.129, -0.055, -0.142), vec4(0.159, 0.021, 0.103, 0.037), vec4(0.199, -0.201, 0.055, 0.078), vec4(-0.199, 0.033, -0.094, -0.083)) * bufB[7] + mat4(vec4(0.349, 0.241, -0.353, -0.285), vec4(0.117, -0.010, 0.413, 0.158), vec4(0.106, 0.173, 0.009, 0.309), vec4(-0.111, -0.103, 0.243, -0.142)) * bufB[8] + mat4(vec4(-0.073, -0.062, -0.169, -0.180), vec4(0.182, 0.194, -0.289, -0.143), vec4(0.008, 0.018, -0.025, -0.122), vec4(0.045, 0.024, 0.087, -0.298)) * bufB[9];\nbufA[2] = vec4(-0.031, -0.211, -0.203, 0.460) + mat4(vec4(0.042, 0.208, 0.026, 0.123), vec4(-0.110, 0.161, 0.232, -0.182), vec4(0.150, -0.107, -0.086, -0.350), vec4(-0.228, 0.270, -0.191, 0.147)) * bufB[0] + mat4(vec4(0.053, 0.065, -0.399, -0.087), vec4(-0.095, -0.055, -0.054, 0.110), vec4(0.034, 0.179, -0.010, 0.139), vec4(-0.021, 0.040, 0.020, -0.189)) * bufB[1] + mat4(vec4(0.014, -0.045, -0.144, -0.079), vec4(0.044, -0.240, 0.009, 0.182), vec4(0.133, -0.046, 0.206, 0.240), vec4(0.168, 0.208, 0.101, 0.095)) * bufB[2] + mat4(vec4(0.066, -0.171, -0.202, -0.063), vec4(0.319, 0.056, -0.042, -0.145), vec4(-0.135, 0.104, 0.061, -0.259), vec4(0.011, 0.158, -0.128, 0.032)) * bufB[3] + mat4(vec4(0.126, 0.001, -0.030, -0.291), vec4(-0.158, 0.073, -0.218, 0.076), vec4(-0.128, 0.014, 0.207, -0.047), vec4(0.110, -0.086, -0.091, 0.023)) * bufB[4] + mat4(vec4(-0.148, -0.100, 0.081, 0.220), vec4(-0.069, 0.283, 0.151, -0.121), vec4(-0.299, 0.080, -0.008, -0.338), vec4(0.039, 0.195, 0.160, 0.105)) * bufB[5] + mat4(vec4(0.114, -0.076, 0.043, -0.067), vec4(0.321, 0.047, -0.037, 0.150), vec4(0.072, -0.106, 0.107, -0.122), vec4(-0.018, 0.190, 0.160, 0.015)) * bufB[6] + mat4(vec4(0.052, 0.100, -0.059, 0.126), vec4(0.078, -0.267, 0.241, 0.203), vec4(-0.034, -0.076, -0.003, 0.157), vec4(-0.013, 0.048, 0.127, 0.067)) * bufB[7] + mat4(vec4(-0.064, -0.021, -0.180, 0.005), vec4(0.014, -0.093, 0.024, -0.117), vec4(0.049, -0.170, -0.232, -0.116), vec4(0.027, -0.190, -0.202, 0.030)) * bufB[8] + mat4(vec4(-0.319, 0.577, -0.276, 0.298), vec4(0.043, -0.222, -0.172, -0.033), vec4(0.136, 0.165, -0.071, -0.096), vec4(-0.011, -0.068, -0.296, 0.148)) * bufB[9];\nbufA[3] = vec4(0.411, 0.072, 0.152, 0.306) + mat4(vec4(-0.019, 0.048, -0.077, -0.096), vec4(-0.203, -0.270, -0.012, -0.214), vec4(-0.020, -0.086, 0.044, 0.151), vec4(0.247, 0.140, -0.000, 0.227)) * bufB[0] + mat4(vec4(0.160, 0.072, 0.032, 0.106), vec4(-0.068, 0.121, -0.171, -0.040), vec4(0.226, 0.053, 0.106, -0.090), vec4(0.188, -0.319, 0.024, -0.050)) * bufB[1] + mat4(vec4(0.044, -0.230, 0.178, 0.089), vec4(-0.012, 0.119, 0.391, -0.006), vec4(0.086, -0.172, -0.253, 0.067), vec4(-0.114, 0.036, -0.186, 0.113)) * bufB[2] + mat4(vec4(0.172, 0.101, 0.028, 0.151), vec4(0.320, -0.098, -0.041, -0.027), vec4(-0.179, 0.041, -0.074, 0.201), vec4(-0.017, -0.017, -0.198, -0.193)) * bufB[3] + mat4(vec4(0.237, -0.223, -0.005, 0.291), vec4(-0.158, -0.143, 0.182, 0.241), vec4(0.465, -0.413, -0.042, 0.169), vec4(0.026, 0.125, 0.246, -0.013)) * bufB[4] + mat4(vec4(-0.089, 0.056, 0.078, 0.122), vec4(-0.049, -0.094, 0.004, -0.208), vec4(-0.005, -0.041, 0.180, 0.191), vec4(-0.276, 0.129, 0.051, -0.209)) * bufB[5] + mat4(vec4(0.204, 0.061, -0.141, -0.078), vec4(-0.003, 0.245, -0.141, 0.119), vec4(0.196, -0.066, 0.078, -0.175), vec4(-0.261, -0.016, -0.026, 0.023)) * bufB[6] + mat4(vec4(-0.046, -0.025, 0.222, 0.188), vec4(0.060, 0.110, -0.177, 0.165), vec4(-0.003, 0.039, 0.003, 0.185), vec4(0.142, 0.256, 0.114, 0.140)) * bufB[7] + mat4(vec4(0.148, 0.049, 0.027, -0.090), vec4(-0.114, 0.455, -0.347, -0.247), vec4(0.092, -0.068, 0.062, -0.079), vec4(0.091, 0.117, 0.121, 0.231)) * bufB[8] + mat4(vec4(-0.199, 0.131, -0.267, -0.067), vec4(-0.081, 0.217, 0.074, -0.114), vec4(-0.011, 0.007, -0.178, 0.167), vec4(0.066, -0.030, -0.051, -0.265)) * bufB[9];\nbufA[4] = vec4(-0.217, -0.225, 0.239, 0.287) + mat4(vec4(0.018, -0.133, -0.223, 0.064), vec4(0.110, 0.182, -0.099, -0.028), vec4(-0.187, 0.317, -0.122, -0.007), vec4(0.146, -0.080, -0.119, 0.283)) * bufB[0] + mat4(vec4(-0.060, 0.042, -0.142, -0.050), vec4(-0.055, -0.046, -0.214, -0.062), vec4(0.097, -0.057, -0.131, 0.017), vec4(0.130, -0.183, 0.019, -0.106)) * bufB[1] + mat4(vec4(-0.101, -0.100, -0.169, 0.217), vec4(0.222, -0.115, -0.151, 0.262), vec4(0.024, -0.080, 0.062, 0.188), vec4(0.101, 0.075, 0.155, 0.055)) * bufB[2] + mat4(vec4(-0.045, 0.001, 0.105, 0.225), vec4(-0.017, 0.002, 0.252, -0.451), vec4(-0.212, -0.108, 0.077, -0.221), vec4(0.156, 0.044, 0.157, -0.017)) * bufB[3] + mat4(vec4(-0.295, -0.000, -0.188, -0.232), vec4(-0.051, 0.181, -0.055, -0.315), vec4(-0.315, -0.029, -0.085, -0.226), vec4(-0.087, -0.032, -0.122, -0.336)) * bufB[4] + mat4(vec4(-0.321, 0.093, -0.065, 0.178), vec4(0.052, 0.272, 0.033, -0.258), vec4(0.044, 0.382, -0.498, -0.017), vec4(-0.313, -0.483, -0.041, -0.098)) * bufB[5] + mat4(vec4(-0.112, -0.114, 0.158, 0.181), vec4(-0.134, -0.078, 0.051, 0.219), vec4(0.104, -0.049, -0.154, 0.089), vec4(-0.025, 0.453, 0.276, -0.035)) * bufB[6] + mat4(vec4(-0.301, 0.290, -0.124, -0.094), vec4(-0.041, 0.154, -0.020, 0.064), vec4(0.179, 0.186, -0.163, 0.139), vec4(-0.144, 0.044, 0.001, 0.258)) * bufB[7] + mat4(vec4(0.325, 0.153, -0.019, 0.029), vec4(-0.189, 0.013, 0.204, -0.273), vec4(0.060, -0.113, 0.093, 0.055), vec4(0.034, 0.085, 0.182, 0.080)) * bufB[8] + mat4(vec4(0.459, -0.339, 0.114, 0.158), vec4(-0.056, -0.072, -0.106, -0.050), vec4(-0.242, -0.092, 0.196, -0.239), vec4(-0.225, 0.154, 0.108, 0.289)) * bufB[9];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 6 \nbufA[0] = vec4(-0.504, 0.193, -0.248, 0.438) + mat4(vec4(-0.259, -0.337, 0.213, 0.058), vec4(0.152, -0.022, -0.079, 0.147), vec4(0.107, 0.122, -0.139, 0.268), vec4(-0.019, 0.014, -0.217, -0.216)) * bufB[0] + mat4(vec4(0.072, 0.009, 0.246, -0.123), vec4(0.155, 0.044, 0.133, -0.044), vec4(-0.067, 0.067, -0.171, -0.055), vec4(-0.214, 0.030, 0.401, 0.042)) * bufB[1] + mat4(vec4(0.146, -0.003, -0.253, 0.040), vec4(0.072, 0.058, 0.100, 0.021), vec4(-0.164, -0.088, 0.478, 0.381), vec4(0.012, 0.228, -0.301, -0.100)) * bufB[2] + mat4(vec4(0.057, 0.140, -0.153, -0.169), vec4(0.119, 0.066, -0.136, 0.277), vec4(-0.115, -0.098, -0.028, -0.194), vec4(-0.042, 0.110, -0.336, -0.063)) * bufB[3] + mat4(vec4(0.142, 0.216, -0.269, -0.056), vec4(-0.385, 0.161, 0.245, -0.147), vec4(0.033, 0.084, -0.462, -0.305), vec4(0.213, 0.372, 0.093, 0.208)) * bufB[4] + mat4(vec4(0.128, 0.009, 0.043, 0.114), vec4(-0.012, -0.222, -0.126, 0.018), vec4(0.119, -0.088, -0.466, -0.076), vec4(-0.024, 0.007, -0.118, 0.268)) * bufB[5] + mat4(vec4(-0.131, -0.175, 0.221, 0.024), vec4(-0.196, -0.229, 0.171, 0.384), vec4(-0.055, 0.007, -0.214, 0.131), vec4(0.026, 0.332, -0.169, -0.264)) * bufB[6] + mat4(vec4(-0.060, 0.061, -0.313, 0.020), vec4(-0.260, 0.000, -0.007, -0.143), vec4(0.298, -0.042, -0.115, 0.008), vec4(0.109, 0.257, -0.011, 0.107)) * bufB[7] + mat4(vec4(-0.007, 0.038, 0.121, 0.053), vec4(-0.067, -0.015, -0.018, -0.027), vec4(-0.069, -0.199, -0.318, 0.057), vec4(0.147, -0.073, 0.115, -0.118)) * bufB[8] + mat4(vec4(0.170, 0.041, -0.207, 0.050), vec4(0.011, -0.004, 0.070, 0.203), vec4(-0.015, 0.013, -0.276, 0.221), vec4(0.054, 0.203, 0.138, -0.024)) * bufB[9];\nbufA[1] = vec4(-0.086, 0.456, -0.289, -0.478) + mat4(vec4(-0.199, -0.200, -0.153, 0.093), vec4(0.006, 0.080, 0.051, 0.271), vec4(0.121, -0.219, 0.034, 0.329), vec4(-0.172, -0.162, 0.170, 0.003)) * bufB[0] + mat4(vec4(0.419, -0.170, -0.176, 0.183), vec4(0.103, 0.261, 0.002, 0.155), vec4(0.385, -0.197, 0.217, 0.165), vec4(0.175, 0.129, -0.030, 0.374)) * bufB[1] + mat4(vec4(0.133, 0.068, 0.102, 0.023), vec4(-0.083, -0.180, -0.161, 0.243), vec4(-0.024, 0.052, -0.257, 0.251), vec4(-0.031, 0.114, 0.023, -0.004)) * bufB[2] + mat4(vec4(0.190, -0.003, 0.117, 0.053), vec4(0.345, 0.246, 0.421, -0.330), vec4(-0.208, 0.126, 0.080, -0.158), vec4(0.140, -0.091, 0.049, 0.044)) * bufB[3] + mat4(vec4(-0.108, 0.137, -0.233, 0.174), vec4(-0.069, -0.047, -0.205, -0.263), vec4(0.035, -0.059, -0.039, 0.068), vec4(-0.120, 0.267, -0.177, -0.235)) * bufB[4] + mat4(vec4(0.176, -0.090, -0.077, 0.226), vec4(-0.473, -0.121, -0.091, 0.004), vec4(-0.036, -0.086, -0.509, 0.098), vec4(-0.026, 0.059, -0.166, 0.133)) * bufB[5] + mat4(vec4(-0.238, -0.007, 0.143, -0.168), vec4(0.108, 0.288, -0.365, 0.095), vec4(0.020, 0.191, -0.186, -0.269), vec4(0.076, -0.307, -0.052, 0.143)) * bufB[6] + mat4(vec4(-0.186, 0.090, -0.343, 0.011), vec4(-0.155, 0.139, -0.177, -0.094), vec4(0.083, -0.019, 0.120, -0.332), vec4(-0.409, -0.001, 0.279, 0.087)) * bufB[7] + mat4(vec4(-0.241, -0.093, -0.035, 0.061), vec4(-0.066, 0.273, -0.067, -0.011), vec4(-0.283, 0.467, 0.040, 0.195), vec4(-0.189, 0.048, 0.070, 0.122)) * bufB[8] + mat4(vec4(0.362, -0.075, -0.037, 0.112), vec4(0.081, 0.189, 0.205, -0.188), vec4(0.033, -0.112, -0.142, -0.268), vec4(0.036, 0.052, 0.361, -0.222)) * bufB[9];\nbufA[2] = vec4(-0.079, 0.179, -0.173, -0.097) + mat4(vec4(-0.090, -0.163, -0.174, 0.143), vec4(-0.156, 0.097, -0.148, 0.162), vec4(-0.026, -0.106, 0.171, -0.203), vec4(0.033, -0.295, -0.017, 0.110)) * bufB[0] + mat4(vec4(-0.121, -0.324, 0.309, -0.118), vec4(-0.006, 0.093, -0.070, -0.013), vec4(0.267, 0.291, 0.327, 0.183), vec4(0.051, -0.008, 0.191, 0.038)) * bufB[1] + mat4(vec4(0.157, 0.237, 0.104, -0.034), vec4(0.004, 0.403, -0.026, -0.443), vec4(-0.190, -0.074, 0.019, 0.233), vec4(-0.016, -0.051, -0.130, 0.132)) * bufB[2] + mat4(vec4(-0.016, -0.134, -0.181, -0.005), vec4(-0.025, -0.022, 0.670, -0.067), vec4(-0.008, -0.070, 0.027, 0.078), vec4(0.023, 0.260, -0.020, -0.010)) * bufB[3] + mat4(vec4(0.145, -0.079, -0.370, -0.130), vec4(0.085, -0.089, -0.170, 0.079), vec4(-0.097, 0.013, 0.291, 0.197), vec4(-0.109, -0.039, 0.019, 0.134)) * bufB[4] + mat4(vec4(-0.047, -0.151, -0.199, 0.140), vec4(-0.080, -0.171, -0.019, -0.012), vec4(-0.025, -0.115, -0.049, -0.253), vec4(0.031, 0.112, -0.039, 0.060)) * bufB[5] + mat4(vec4(0.199, 0.188, 0.237, -0.129), vec4(-0.248, 0.079, 0.134, 0.109), vec4(0.289, 0.312, 0.045, -0.036), vec4(0.031, 0.027, 0.096, -0.001)) * bufB[6] + mat4(vec4(0.115, 0.040, -0.125, -0.079), vec4(-0.180, 0.056, 0.170, 0.209), vec4(0.070, 0.318, 0.183, -0.296), vec4(0.151, 0.227, 0.124, -0.096)) * bufB[7] + mat4(vec4(-0.110, -0.050, -0.009, -0.211), vec4(-0.135, -0.026, 0.018, 0.165), vec4(0.155, -0.027, -0.028, -0.203), vec4(-0.171, -0.331, 0.059, 0.339)) * bufB[8] + mat4(vec4(-0.267, 0.236, -0.277, 0.148), vec4(-0.094, 0.115, -0.079, -0.082), vec4(-0.220, 0.065, -0.256, -0.311), vec4(0.312, 0.237, -0.200, -0.158)) * bufB[9];\nbufA[3] = vec4(0.181, 0.087, 0.486, 0.149) + mat4(vec4(0.286, -0.114, -0.244, 0.181), vec4(-0.260, -0.036, -0.142, 0.079), vec4(-0.519, 0.105, 0.239, -0.075), vec4(-0.310, -0.253, -0.058, -0.023)) * bufB[0] + mat4(vec4(0.527, 0.456, 0.003, -0.156), vec4(-0.211, 0.086, 0.285, 0.062), vec4(0.217, 0.011, -0.011, -0.058), vec4(0.023, 0.210, 0.271, 0.205)) * bufB[1] + mat4(vec4(0.166, -0.390, -0.058, 0.197), vec4(0.232, -0.135, -0.375, 0.053), vec4(-0.154, -0.101, -0.088, -0.407), vec4(-0.129, 0.185, -0.090, 0.284)) * bufB[2] + mat4(vec4(0.013, -0.185, 0.073, -0.090), vec4(-0.016, 0.160, 0.071, 0.270), vec4(0.013, 0.240, 0.317, 0.127), vec4(-0.014, -0.389, -0.126, 0.126)) * bufB[3] + mat4(vec4(0.116, 0.219, 0.051, 0.022), vec4(-0.152, 0.170, 0.207, -0.022), vec4(-0.040, -0.269, -0.274, -0.228), vec4(-0.040, 0.348, -0.320, -0.100)) * bufB[4] + mat4(vec4(0.053, 0.083, 0.257, -0.266), vec4(0.008, -0.157, -0.002, 0.118), vec4(0.144, -0.188, -0.033, -0.087), vec4(0.150, -0.126, 0.236, 0.126)) * bufB[5] + mat4(vec4(-0.009, -0.184, 0.236, -0.074), vec4(-0.004, -0.098, -0.071, -0.167), vec4(0.164, 0.191, 0.029, -0.220), vec4(0.053, 0.005, -0.130, -0.020)) * bufB[6] + mat4(vec4(-0.033, 0.531, 0.059, -0.106), vec4(0.118, 0.072, -0.426, 0.053), vec4(0.184, 0.082, 0.034, -0.036), vec4(0.078, 0.381, -0.145, -0.066)) * bufB[7] + mat4(vec4(-0.116, -0.058, 0.150, -0.031), vec4(-0.162, 0.383, 0.184, -0.128), vec4(-0.128, 0.099, -0.118, 0.032), vec4(0.189, 0.244, 0.012, 0.208)) * bufB[8] + mat4(vec4(-0.078, -0.084, -0.101, 0.003), vec4(-0.048, -0.147, -0.201, -0.050), vec4(0.448, 0.255, -0.046, 0.002), vec4(-0.136, 0.069, 0.024, -0.209)) * bufB[9];\nbufA[4] = vec4(0.352, -0.064, 0.322, -0.068) + mat4(vec4(-0.012, 0.107, -0.023, 0.057), vec4(-0.108, -0.129, -0.121, -0.101), vec4(0.174, 0.291, 0.081, 0.121), vec4(-0.120, 0.114, 0.018, 0.243)) * bufB[0] + mat4(vec4(0.060, 0.184, -0.276, 0.094), vec4(0.024, -0.207, 0.017, 0.290), vec4(-0.028, 0.068, 0.141, 0.168), vec4(-0.410, -0.444, 0.013, -0.006)) * bufB[1] + mat4(vec4(0.076, 0.150, -0.010, 0.155), vec4(0.194, -0.039, -0.117, -0.234), vec4(-0.166, -0.122, 0.544, 0.203), vec4(0.163, -0.059, -0.012, -0.018)) * bufB[2] + mat4(vec4(-0.171, -0.177, -0.152, -0.193), vec4(0.156, 0.147, 0.243, -0.030), vec4(0.009, -0.019, 0.233, -0.022), vec4(0.253, -0.097, 0.061, 0.061)) * bufB[3] + mat4(vec4(0.008, 0.067, 0.158, 0.157), vec4(0.092, -0.262, -0.288, -0.016), vec4(0.072, 0.178, 0.048, 0.213), vec4(0.409, 0.061, 0.120, -0.137)) * bufB[4] + mat4(vec4(-0.324, 0.044, 0.121, -0.166), vec4(-0.053, -0.203, 0.118, -0.067), vec4(-0.111, 0.009, -0.291, 0.156), vec4(0.289, 0.069, 0.141, 0.079)) * bufB[5] + mat4(vec4(-0.004, -0.211, 0.005, 0.227), vec4(-0.170, -0.079, 0.171, -0.003), vec4(0.127, 0.205, -0.137, -0.496), vec4(0.139, 0.329, -0.142, -0.049)) * bufB[6] + mat4(vec4(0.095, 0.061, 0.059, -0.151), vec4(0.217, -0.089, -0.174, -0.073), vec4(0.183, 0.252, -0.147, -0.239), vec4(0.252, -0.200, -0.243, -0.078)) * bufB[7] + mat4(vec4(0.099, -0.005, 0.075, -0.087), vec4(0.133, 0.181, -0.291, 0.168), vec4(0.226, 0.023, 0.144, -0.019), vec4(-0.221, 0.022, 0.038, 0.276)) * bufB[8] + mat4(vec4(-0.081, 0.149, 0.114, 0.081), vec4(-0.060, 0.202, -0.097, -0.135), vec4(0.247, 0.040, -0.218, -0.024), vec4(0.007, -0.011, 0.088, 0.087)) * bufB[9];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 7 \nbufA[0] = vec4(0.000, 0.273, -0.539, -0.332) + mat4(vec4(0.296, -0.207, -0.034, -0.095), vec4(0.220, -0.127, 0.071, 0.020), vec4(-0.148, 0.011, -0.119, -0.082), vec4(0.093, -0.410, -0.287, -0.068)) * bufB[0] + mat4(vec4(-0.560, -0.083, -0.142, 0.215), vec4(0.246, -0.462, -0.118, -0.289), vec4(0.030, -0.193, 0.167, -0.372), vec4(0.188, 0.009, -0.196, -0.041)) * bufB[1] + mat4(vec4(0.184, 0.031, 0.298, 0.030), vec4(0.051, 0.069, 0.041, -0.284), vec4(0.304, 0.016, 0.179, 0.080), vec4(0.052, 0.122, -0.215, 0.020)) * bufB[2] + mat4(vec4(0.136, 0.234, -0.033, -0.326), vec4(0.117, -0.147, -0.050, -0.225), vec4(-0.030, -0.242, -0.032, 0.392), vec4(-0.150, -0.302, -0.177, -0.086)) * bufB[3] + mat4(vec4(-0.225, -0.036, -0.319, -0.193), vec4(0.121, 0.009, -0.160, -0.028), vec4(0.194, -0.310, -0.185, -0.090), vec4(0.217, 0.076, -0.065, 0.051)) * bufB[4] + mat4(vec4(0.407, 0.153, 0.258, -0.270), vec4(0.113, -0.180, -0.072, -0.348), vec4(0.128, -0.082, -0.002, 0.415), vec4(-0.057, -0.181, 0.077, -0.182)) * bufB[5] + mat4(vec4(0.083, 0.226, -0.151, -0.039), vec4(-0.015, -0.126, -0.004, -0.314), vec4(0.042, 0.006, 0.161, -0.568), vec4(0.109, 0.056, -0.011, 0.276)) * bufB[6] + mat4(vec4(-0.002, -0.073, 0.191, -0.185), vec4(0.035, 0.199, -0.012, -0.165), vec4(-0.139, 0.100, -0.138, -0.156), vec4(0.153, 0.059, 0.148, -0.271)) * bufB[7] + mat4(vec4(-0.328, 0.131, 0.030, 0.299), vec4(-0.237, -0.145, -0.037, -0.022), vec4(-0.075, -0.056, 0.049, 0.086), vec4(-0.104, -0.401, -0.155, -0.136)) * bufB[8] + mat4(vec4(0.406, 0.230, -0.139, 0.265), vec4(-0.088, 0.066, -0.139, -0.018), vec4(-0.007, 0.368, 0.060, 0.072), vec4(-0.098, 0.320, 0.191, -0.115)) * bufB[9];\nbufA[1] = vec4(-0.135, 0.333, 0.138, 0.294) + mat4(vec4(0.088, 0.400, -0.127, 0.045), vec4(0.151, -0.103, -0.264, -0.153), vec4(0.099, -0.118, -0.160, -0.110), vec4(0.099, 0.053, 0.140, 0.029)) * bufB[0] + mat4(vec4(-0.152, -0.162, -0.381, -0.035), vec4(-0.080, -0.154, 0.029, -0.286), vec4(0.262, -0.028, -0.015, 0.164), vec4(-0.030, 0.172, 0.150, -0.103)) * bufB[1] + mat4(vec4(0.058, -0.049, -0.335, -0.039), vec4(-0.239, 0.089, -0.126, 0.106), vec4(0.091, 0.509, 0.049, -0.052), vec4(0.019, 0.007, 0.223, 0.008)) * bufB[2] + mat4(vec4(-0.126, -0.075, -0.199, 0.005), vec4(-0.032, -0.178, -0.408, 0.002), vec4(0.005, -0.036, 0.023, -0.106), vec4(0.015, 0.013, 0.088, -0.112)) * bufB[3] + mat4(vec4(0.123, -0.031, 0.217, 0.079), vec4(0.331, 0.151, -0.066, -0.104), vec4(0.000, 0.136, -0.030, -0.078), vec4(0.242, -0.022, -0.058, -0.099)) * bufB[4] + mat4(vec4(-0.155, 0.052, 0.213, -0.441), vec4(-0.153, 0.155, -0.144, 0.047), vec4(0.013, -0.071, -0.268, -0.156), vec4(-0.032, -0.028, 0.290, -0.266)) * bufB[5] + mat4(vec4(0.250, -0.047, 0.099, 0.296), vec4(0.355, 0.170, -0.003, 0.299), vec4(0.034, -0.164, -0.119, 0.053), vec4(-0.007, -0.297, -0.193, 0.135)) * bufB[6] + mat4(vec4(0.038, -0.033, -0.199, -0.181), vec4(0.063, 0.288, -0.229, -0.290), vec4(-0.010, -0.032, 0.212, 0.100), vec4(0.237, 0.185, -0.083, -0.375)) * bufB[7] + mat4(vec4(-0.153, 0.008, -0.203, 0.014), vec4(-0.131, 0.020, 0.334, -0.088), vec4(0.069, 0.337, 0.330, -0.025), vec4(-0.280, -0.044, 0.138, -0.163)) * bufB[8] + mat4(vec4(0.318, 0.072, -0.064, 0.188), vec4(-0.102, 0.310, 0.015, -0.124), vec4(-0.037, 0.093, -0.083, -0.071), vec4(0.095, -0.192, -0.403, 0.062)) * bufB[9];\nbufA[2] = vec4(0.048, 0.004, -0.150, -0.516) + mat4(vec4(-0.364, 0.015, -0.022, -0.108), vec4(0.031, 0.096, 0.083, -0.169), vec4(0.323, -0.120, -0.471, -0.294), vec4(0.273, 0.022, 0.215, -0.195)) * bufB[0] + mat4(vec4(-0.036, 0.134, -0.033, 0.315), vec4(0.478, -0.271, 0.188, -0.125), vec4(0.138, -0.084, -0.058, 0.270), vec4(-0.202, 0.207, -0.122, 0.026)) * bufB[1] + mat4(vec4(-0.057, -0.294, 0.104, -0.114), vec4(0.160, -0.045, -0.063, 0.233), vec4(-0.070, -0.182, 0.176, 0.340), vec4(0.042, -0.209, 0.186, 0.216)) * bufB[2] + mat4(vec4(0.351, -0.139, -0.215, 0.125), vec4(0.102, -0.199, 0.205, 0.132), vec4(-0.106, 0.049, 0.170, 0.101), vec4(-0.064, -0.060, 0.264, 0.146)) * bufB[3] + mat4(vec4(-0.081, 0.083, -0.045, -0.100), vec4(-0.093, -0.361, 0.296, 0.167), vec4(0.204, -0.123, 0.218, -0.160), vec4(0.020, -0.142, -0.498, -0.060)) * bufB[4] + mat4(vec4(0.182, 0.057, -0.071, 0.169), vec4(-0.065, 0.163, 0.035, -0.338), vec4(-0.194, -0.073, -0.167, -0.224), vec4(0.223, 0.141, -0.027, -0.057)) * bufB[5] + mat4(vec4(0.023, -0.267, -0.021, -0.228), vec4(-0.178, 0.148, 0.118, 0.194), vec4(0.068, -0.104, -0.322, -0.112), vec4(0.052, -0.319, 0.054, 0.051)) * bufB[6] + mat4(vec4(0.065, -0.097, 0.266, -0.171), vec4(0.051, -0.347, -0.152, 0.072), vec4(0.206, 0.133, -0.005, -0.091), vec4(-0.052, 0.288, -0.050, 0.110)) * bufB[7] + mat4(vec4(0.016, -0.125, -0.134, 0.056), vec4(0.225, 0.222, 0.060, -0.030), vec4(0.164, 0.436, 0.055, 0.321), vec4(-0.095, 0.084, -0.169, -0.028)) * bufB[8] + mat4(vec4(-0.157, 0.087, 0.287, 0.004), vec4(-0.207, -0.003, 0.201, 0.070), vec4(0.114, -0.017, 0.142, -0.128), vec4(0.243, -0.009, -0.181, -0.030)) * bufB[9];\nbufA[3] = vec4(-0.300, -0.361, -0.274, -0.142) + mat4(vec4(0.093, -0.046, -0.010, -0.281), vec4(-0.501, -0.233, -0.196, -0.072), vec4(0.245, 0.225, -0.032, -0.034), vec4(-0.070, -0.006, -0.079, 0.079)) * bufB[0] + mat4(vec4(0.158, 0.123, 0.075, -0.206), vec4(-0.039, 0.057, 0.051, 0.084), vec4(-0.274, -0.218, -0.053, 0.257), vec4(-0.078, -0.029, -0.157, -0.039)) * bufB[1] + mat4(vec4(0.052, 0.177, -0.104, 0.216), vec4(-0.075, 0.153, -0.092, 0.126), vec4(0.063, 0.017, -0.064, -0.190), vec4(-0.054, 0.205, 0.002, -0.154)) * bufB[2] + mat4(vec4(0.382, 0.034, -0.183, 0.046), vec4(0.033, -0.088, 0.086, -0.307), vec4(-0.142, -0.177, -0.336, -0.061), vec4(-0.068, -0.576, -0.255, 0.050)) * bufB[3] + mat4(vec4(0.342, -0.067, -0.107, 0.158), vec4(0.240, 0.155, -0.359, -0.156), vec4(-0.256, -0.104, 0.371, 0.326), vec4(-0.228, -0.014, -0.004, -0.165)) * bufB[4] + mat4(vec4(0.331, -0.030, -0.583, 0.016), vec4(0.214, 0.203, -0.039, -0.371), vec4(0.174, 0.065, -0.546, -0.085), vec4(0.441, -0.199, -0.185, -0.128)) * bufB[5] + mat4(vec4(-0.392, 0.348, -0.179, -0.148), vec4(-0.225, 0.120, -0.220, 0.168), vec4(-0.169, -0.241, -0.046, 0.039), vec4(0.357, -0.048, -0.315, 0.155)) * bufB[6] + mat4(vec4(0.073, -0.210, -0.213, -0.154), vec4(0.402, 0.233, -0.125, 0.000), vec4(-0.012, 0.010, 0.311, -0.172), vec4(0.150, -0.173, 0.322, 0.319)) * bufB[7] + mat4(vec4(0.333, -0.239, 0.330, 0.096), vec4(-0.101, 0.161, 0.198, 0.084), vec4(0.010, 0.061, 0.182, 0.088), vec4(0.162, 0.126, 0.180, -0.116)) * bufB[8] + mat4(vec4(0.085, 0.275, 0.040, -0.191), vec4(0.152, 0.360, -0.314, -0.054), vec4(0.600, 0.035, 0.200, -0.571), vec4(0.397, 0.038, -0.114, 0.307)) * bufB[9];\nbufA[4] = vec4(0.042, 0.516, -0.399, -0.001) + mat4(vec4(-0.119, -0.101, -0.213, 0.104), vec4(0.224, 0.086, -0.197, -0.032), vec4(0.295, 0.235, -0.362, 0.159), vec4(0.173, 0.164, 0.113, 0.062)) * bufB[0] + mat4(vec4(0.070, -0.283, 0.144, 0.104), vec4(-0.177, 0.299, -0.049, 0.134), vec4(0.113, -0.159, -0.122, 0.231), vec4(0.108, 0.072, -0.173, -0.040)) * bufB[1] + mat4(vec4(-0.060, 0.113, -0.031, -0.058), vec4(-0.231, -0.220, -0.012, -0.056), vec4(0.219, -0.200, 0.057, -0.072), vec4(-0.113, 0.183, -0.009, -0.229)) * bufB[2] + mat4(vec4(-0.183, 0.040, 0.098, -0.135), vec4(0.206, -0.067, -0.007, -0.389), vec4(-0.132, 0.009, -0.118, 0.213), vec4(0.066, 0.147, 0.180, -0.252)) * bufB[3] + mat4(vec4(-0.189, 0.046, -0.103, 0.015), vec4(-0.301, -0.005, -0.008, -0.213), vec4(0.067, -0.124, -0.043, -0.251), vec4(0.432, 0.293, 0.168, 0.045)) * bufB[4] + mat4(vec4(-0.056, -0.081, -0.107, -0.171), vec4(-0.398, -0.036, -0.190, -0.114), vec4(-0.267, 0.159, -0.180, 0.106), vec4(0.052, -0.248, 0.085, 0.020)) * bufB[5] + mat4(vec4(0.173, -0.252, -0.101, -0.029), vec4(0.106, -0.031, -0.145, -0.267), vec4(0.131, 0.061, 0.342, 0.042), vec4(-0.254, -0.029, -0.198, -0.066)) * bufB[6] + mat4(vec4(-0.284, 0.061, -0.001, 0.191), vec4(-0.091, 0.237, 0.095, -0.011), vec4(-0.025, -0.230, -0.185, -0.002), vec4(-0.591, 0.043, 0.079, 0.133)) * bufB[7] + mat4(vec4(0.111, 0.109, 0.383, 0.074), vec4(0.217, 0.199, -0.136, 0.093), vec4(0.230, -0.003, 0.035, 0.219), vec4(0.102, -0.090, -0.241, -0.026)) * bufB[8] + mat4(vec4(-0.028, -0.068, 0.089, -0.242), vec4(-0.290, -0.185, 0.125, -0.086), vec4(0.019, -0.193, -0.231, 0.183), vec4(0.247, 0.133, 0.126, 0.124)) * bufB[9];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 8 \nbufA[0] = vec4(0.279, 0.238, -0.027, -0.508) + mat4(vec4(0.199, -0.060, 0.161, 0.362), vec4(-0.027, 0.152, 0.173, 0.010), vec4(-0.478, -0.295, -0.432, -0.013), vec4(0.009, 0.054, -0.164, 0.056)) * bufB[0] + mat4(vec4(-0.134, -0.040, -0.174, 0.065), vec4(-0.121, -0.224, -0.020, -0.011), vec4(0.426, 0.004, 0.195, 0.156), vec4(-0.082, 0.274, 0.024, 0.384)) * bufB[1] + mat4(vec4(-0.209, -0.247, -0.022, -0.014), vec4(-0.216, -0.022, -0.369, -0.032), vec4(-0.059, -0.160, 0.099, -0.078), vec4(-0.087, -0.418, -0.235, 0.244)) * bufB[2] + mat4(vec4(0.021, -0.114, 0.045, 0.072), vec4(0.191, 0.413, -0.188, 0.017), vec4(0.106, 0.002, -0.341, 0.087), vec4(-0.253, -0.086, -0.137, -0.237)) * bufB[3] + mat4(vec4(0.042, 0.141, 0.305, -0.007), vec4(0.073, 0.128, -0.520, 0.007), vec4(0.130, 0.187, -0.042, 0.060), vec4(-0.122, 0.251, -0.196, -0.303)) * bufB[4] + mat4(vec4(-0.199, -0.102, 0.078, -0.323), vec4(0.441, -0.037, -0.100, -0.076), vec4(-0.093, -0.176, 0.133, 0.271), vec4(0.096, -0.680, -0.143, -0.112)) * bufB[5] + mat4(vec4(0.263, 0.312, 0.148, 0.107), vec4(0.364, -0.021, -0.012, -0.065), vec4(-0.119, -0.066, -0.206, 0.278), vec4(-0.209, -0.269, 0.087, 0.119)) * bufB[6] + mat4(vec4(0.098, 0.371, -0.263, -0.049), vec4(0.143, 0.020, 0.303, -0.288), vec4(-0.499, -0.252, -0.108, 0.170), vec4(0.173, 0.183, -0.048, 0.221)) * bufB[7] + mat4(vec4(0.163, 0.315, 0.348, -0.137), vec4(0.341, 0.082, -0.200, 0.214), vec4(-0.173, -0.029, -0.161, -0.024), vec4(-0.013, 0.136, -0.239, 0.044)) * bufB[8] + mat4(vec4(-0.247, -0.027, -0.021, 0.051), vec4(-0.039, -0.086, 0.349, 0.213), vec4(0.120, -0.022, -0.221, -0.240), vec4(-0.005, -0.185, 0.051, -0.002)) * bufB[9];\nbufA[1] = vec4(-0.266, 0.203, -0.213, -0.049) + mat4(vec4(-0.171, -0.024, 0.261, -0.123), vec4(-0.210, -0.085, -0.108, -0.133), vec4(0.112, -0.049, -0.304, -0.077), vec4(0.381, 0.026, -0.078, 0.139)) * bufB[0] + mat4(vec4(-0.087, -0.195, -0.214, -0.162), vec4(0.399, -0.256, -0.334, 0.008), vec4(0.187, 0.167, 0.075, -0.009), vec4(0.306, 0.173, 0.040, 0.215)) * bufB[1] + mat4(vec4(-0.128, -0.036, 0.218, 0.174), vec4(-0.066, -0.109, -0.038, 0.075), vec4(0.100, 0.059, -0.039, 0.277), vec4(0.144, -0.139, -0.137, 0.161)) * bufB[2] + mat4(vec4(-0.009, -0.060, 0.296, 0.040), vec4(0.036, 0.126, -0.042, -0.229), vec4(0.501, 0.429, 0.011, 0.118), vec4(0.083, 0.120, 0.325, 0.375)) * bufB[3] + mat4(vec4(0.143, 0.151, -0.266, 0.085), vec4(-0.362, 0.143, -0.055, -0.169), vec4(0.320, -0.001, 0.028, 0.061), vec4(0.076, -0.051, -0.183, 0.005)) * bufB[4] + mat4(vec4(0.159, 0.211, 0.338, -0.301), vec4(-0.142, 0.238, -0.093, -0.021), vec4(0.091, 0.006, -0.148, -0.154), vec4(0.292, -0.218, -0.010, 0.147)) * bufB[5] + mat4(vec4(0.275, 0.044, 0.255, -0.167), vec4(0.136, 0.042, -0.190, 0.195), vec4(-0.003, 0.154, -0.026, 0.029), vec4(-0.114, -0.184, -0.283, 0.056)) * bufB[6] + mat4(vec4(-0.229, -0.069, -0.079, 0.049), vec4(0.208, -0.040, 0.006, -0.169), vec4(-0.337, 0.218, 0.211, 0.009), vec4(-0.125, 0.249, 0.258, 0.126)) * bufB[7] + mat4(vec4(0.086, -0.169, 0.077, 0.006), vec4(0.183, 0.170, -0.073, -0.034), vec4(0.333, -0.149, 0.129, -0.139), vec4(-0.173, 0.162, 0.173, -0.148)) * bufB[8] + mat4(vec4(0.025, -0.252, 0.265, -0.094), vec4(0.247, 0.215, 0.131, 0.045), vec4(-0.012, 0.157, -0.131, 0.239), vec4(-0.174, 0.170, 0.267, -0.393)) * bufB[9];\nbufA[2] = vec4(0.168, -0.260, -0.360, 0.405) + mat4(vec4(-0.113, -0.124, 0.046, 0.051), vec4(0.383, 0.118, -0.235, 0.041), vec4(-0.124, -0.154, -0.389, 0.048), vec4(0.117, -0.225, -0.007, 0.246)) * bufB[0] + mat4(vec4(-0.184, -0.032, 0.389, -0.236), vec4(-0.167, -0.057, -0.126, -0.346), vec4(-0.199, -0.120, 0.131, -0.125), vec4(0.435, -0.017, -0.029, 0.075)) * bufB[1] + mat4(vec4(0.071, 0.219, 0.152, 0.406), vec4(0.155, -0.169, 0.016, 0.048), vec4(-0.329, -0.173, 0.043, 0.112), vec4(-0.272, 0.458, 0.097, 0.047)) * bufB[2] + mat4(vec4(0.120, -0.063, -0.318, 0.082), vec4(0.039, 0.076, -0.085, -0.310), vec4(-0.119, 0.309, 0.032, 0.321), vec4(-0.190, -0.034, -0.081, 0.119)) * bufB[3] + mat4(vec4(0.058, 0.057, 0.141, 0.169), vec4(-0.338, -0.012, 0.045, -0.142), vec4(0.154, 0.009, -0.155, -0.461), vec4(0.288, -0.328, -0.290, -0.123)) * bufB[4] + mat4(vec4(-0.199, -0.062, 0.002, -0.183), vec4(-0.359, 0.459, 0.201, 0.381), vec4(-0.226, -0.241, 0.036, 0.199), vec4(0.195, 0.000, -0.282, 0.432)) * bufB[5] + mat4(vec4(0.034, -0.234, -0.514, -0.138), vec4(-0.121, 0.414, -0.102, 0.306), vec4(0.148, 0.110, 0.411, 0.655), vec4(-0.128, 0.106, 0.267, 0.353)) * bufB[6] + mat4(vec4(0.144, 0.126, -0.179, -0.135), vec4(0.194, 0.128, 0.054, -0.033), vec4(0.088, -0.345, -0.001, 0.057), vec4(-0.091, -0.068, 0.150, 0.134)) * bufB[7] + mat4(vec4(0.080, 0.058, -0.125, 0.071), vec4(0.305, 0.000, -0.063, -0.037), vec4(0.194, 0.157, -0.076, -0.048), vec4(-0.106, 0.225, -0.234, 0.140)) * bufB[8] + mat4(vec4(0.041, -0.045, 0.108, -0.022), vec4(-0.170, 0.215, 0.059, -0.164), vec4(0.103, -0.176, 0.108, 0.260), vec4(-0.142, 0.167, -0.099, -0.145)) * bufB[9];\nbufA[3] = vec4(0.319, 0.045, 0.299, -0.138) + mat4(vec4(0.117, -0.142, 0.079, 0.271), vec4(-0.022, -0.157, 0.011, -0.222), vec4(0.034, -0.281, 0.124, 0.189), vec4(0.177, -0.082, 0.247, -0.093)) * bufB[0] + mat4(vec4(-0.180, -0.014, 0.076, -0.044), vec4(-0.022, 0.172, -0.223, -0.102), vec4(-0.106, -0.058, 0.221, 0.144), vec4(0.068, -0.028, -0.051, 0.042)) * bufB[1] + mat4(vec4(-0.214, -0.146, -0.498, 0.108), vec4(-0.171, 0.287, -0.119, -0.106), vec4(-0.190, -0.066, 0.111, 0.133), vec4(-0.016, 0.195, -0.078, 0.491)) * bufB[2] + mat4(vec4(0.047, -0.058, -0.059, -0.085), vec4(-0.218, 0.013, -0.446, 0.001), vec4(-0.183, -0.083, 0.020, 0.164), vec4(-0.000, -0.221, 0.051, -0.098)) * bufB[3] + mat4(vec4(0.407, 0.088, -0.243, 0.292), vec4(0.218, 0.072, -0.201, -0.133), vec4(0.135, 0.191, 0.466, 0.176), vec4(0.236, 0.043, -0.082, 0.074)) * bufB[4] + mat4(vec4(-0.148, 0.055, 0.321, -0.136), vec4(0.470, 0.397, -0.048, 0.035), vec4(-0.022, -0.271, -0.026, 0.098), vec4(-0.173, -0.216, -0.002, -0.009)) * bufB[5] + mat4(vec4(0.258, -0.152, 0.230, 0.019), vec4(0.047, 0.240, -0.377, 0.018), vec4(0.091, -0.087, 0.222, 0.146), vec4(-0.121, -0.228, -0.050, 0.021)) * bufB[6] + mat4(vec4(-0.047, -0.052, -0.368, -0.261), vec4(0.296, 0.273, 0.146, -0.007), vec4(-0.178, 0.030, -0.224, -0.192), vec4(-0.192, 0.103, -0.352, 0.046)) * bufB[7] + mat4(vec4(0.514, -0.061, 0.190, -0.121), vec4(-0.135, 0.106, -0.171, -0.095), vec4(0.177, 0.011, 0.115, -0.256), vec4(-0.097, 0.046, 0.189, 0.124)) * bufB[8] + mat4(vec4(-0.388, -0.009, 0.184, 0.035), vec4(0.225, -0.037, 0.005, 0.029), vec4(-0.236, -0.186, -0.119, 0.005), vec4(0.107, 0.108, 0.240, 0.407)) * bufB[9];\nbufA[4] = vec4(-0.147, -0.207, 0.521, 0.154) + mat4(vec4(-0.016, 0.062, -0.012, 0.152), vec4(-0.373, -0.186, 0.201, -0.016), vec4(-0.339, -0.179, -0.119, -0.132), vec4(0.079, -0.131, 0.070, 0.175)) * bufB[0] + mat4(vec4(-0.121, -0.340, 0.250, 0.269), vec4(0.175, 0.171, -0.097, -0.105), vec4(0.264, 0.133, -0.165, -0.037), vec4(-0.197, -0.115, 0.218, 0.398)) * bufB[1] + mat4(vec4(0.065, -0.120, -0.036, 0.031), vec4(-0.106, 0.002, 0.198, 0.044), vec4(0.181, -0.132, 0.044, -0.177), vec4(-0.123, 0.020, 0.210, 0.022)) * bufB[2] + mat4(vec4(-0.097, 0.188, -0.050, -0.044), vec4(-0.181, 0.276, -0.053, 0.112), vec4(0.124, -0.194, -0.017, 0.012), vec4(0.055, -0.309, -0.204, -0.191)) * bufB[3] + mat4(vec4(0.063, 0.118, 0.019, 0.001), vec4(-0.291, 0.649, -0.030, 0.047), vec4(-0.056, -0.251, 0.043, 0.095), vec4(0.093, -0.184, -0.044, -0.163)) * bufB[4] + mat4(vec4(-0.241, 0.169, -0.178, -0.054), vec4(-0.027, 0.060, 0.021, 0.014), vec4(0.146, 0.225, -0.094, 0.421), vec4(-0.174, -0.123, -0.239, 0.509)) * bufB[5] + mat4(vec4(-0.293, -0.291, 0.060, -0.075), vec4(0.168, -0.125, -0.330, -0.209), vec4(-0.240, 0.009, 0.182, 0.075), vec4(-0.055, 0.342, 0.108, -0.065)) * bufB[6] + mat4(vec4(0.130, -0.180, 0.051, -0.148), vec4(0.381, 0.263, 0.162, 0.112), vec4(0.065, 0.246, -0.280, -0.316), vec4(0.048, 0.084, 0.138, 0.045)) * bufB[7] + mat4(vec4(-0.287, 0.301, 0.048, -0.235), vec4(0.375, 0.316, 0.214, 0.010), vec4(0.002, -0.043, -0.074, -0.210), vec4(0.359, -0.058, -0.051, -0.287)) * bufB[8] + mat4(vec4(0.122, 0.255, -0.206, -0.006), vec4(-0.048, -0.344, 0.030, -0.070), vec4(0.198, 0.025, -0.156, -0.035), vec4(-0.267, 0.086, -0.110, -0.251)) * bufB[9];\ntmp = atan(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[5] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[6] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[7] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[8] = (tmp*tmp - 0.45) / 0.396;\ntmp = atan(bufA[4]);\nbufB[4] = tmp/0.67;\nbufB[9] = (tmp*tmp - 0.45) / 0.396;\n\n // layer 9 \nbufA[0] = vec4(0.248, 0.011, -0.110, 0.000) + mat4(vec4(-0.027, -0.211, -0.312, 0.000), vec4(-0.239, -0.310, 0.061, 0.000), vec4(-0.058, -0.071, -0.183, 0.000), vec4(-0.030, 0.000, -0.242, 0.000)) * bufB[0] + mat4(vec4(0.140, 0.030, 0.294, 0.000), vec4(0.001, -0.305, 0.015, 0.000), vec4(-0.104, -0.014, 0.056, 0.000), vec4(0.227, -0.020, -0.029, 0.000)) * bufB[1] + mat4(vec4(-0.238, -0.234, -0.111, 0.000), vec4(-0.095, -0.005, 0.019, 0.000), vec4(0.113, -0.290, -0.323, 0.000), vec4(0.169, 0.094, 0.021, 0.000)) * bufB[2] + mat4(vec4(-0.104, 0.149, 0.099, 0.000), vec4(-0.115, 0.074, -0.153, 0.000), vec4(0.290, 0.230, 0.141, 0.000), vec4(-0.185, 0.099, -0.340, 0.000)) * bufB[3] + mat4(vec4(0.392, 0.021, -0.131, 0.000), vec4(0.317, -0.130, -0.320, 0.000), vec4(-0.139, -0.249, -0.370, 0.000), vec4(0.336, -0.220, -0.425, 0.000)) * bufB[4] + mat4(vec4(0.350, 0.170, -0.050, 0.000), vec4(0.049, -0.014, -0.302, 0.000), vec4(-0.220, 0.150, 0.445, 0.000), vec4(-0.130, -0.025, 0.243, 0.000)) * bufB[5] + mat4(vec4(-0.264, -0.174, -0.262, 0.000), vec4(0.050, 0.141, 0.158, 0.000), vec4(-0.368, 0.107, 0.421, 0.000), vec4(0.154, 0.114, -0.217, 0.000)) * bufB[6] + mat4(vec4(0.035, -0.129, -0.170, 0.000), vec4(-0.116, -0.186, -0.164, 0.000), vec4(0.226, 0.212, 0.038, 0.000), vec4(0.101, -0.182, -0.330, 0.000)) * bufB[7] + mat4(vec4(-0.103, -0.146, -0.254, 0.000), vec4(0.173, 0.069, 0.256, 0.000), vec4(0.059, 0.083, -0.111, 0.000), vec4(0.055, -0.175, 0.188, 0.000)) * bufB[8] + mat4(vec4(0.413, 0.118, -0.247, 0.000), vec4(0.157, -0.080, -0.136, 0.000), vec4(0.303, 0.067, 0.206, 0.000), vec4(-0.002, -0.038, -0.014, 0.000)) * bufB[9];\n\n return vec4((1. / (1. + exp(-bufA[0]))).xyz, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouseNorm = (iMouse.xy / iResolution.xy) - vec2(0.5, 0.5);\n\n    uv.x *= iResolution.x / iResolution.y;\n    uv.x -= ((iResolution.x / iResolution.y) - 1.) /2.;\n\n    // Shifted to the form expected by the CPPN\n    uv = vec2(1., -1.) * 1.8 * (uv - vec2(0.5, 0.5));\n    // Output to screen\n    fragColor = cppn_fn(uv, 0.23*sin(iTime), 0.32*sin(0.69*iTime), 0.32*sin(0.44*iTime), 0.23*sin(1.23*iTime));\n}\n        ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dBSDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[110, 110, 185, 185, 72837], [72839, 72839, 72896, 72946, 73395]], "test": "valid"}
{"id": "7dBSR3", "name": " Phantom Star NikolaErceg fork", "author": "NikolaErceg", "description": "fork", "tags": ["raymarching", "ifs", "phantommode"], "likes": 2, "viewed": 198, "published": "Public API", "date": "1620668846", "time_retrieved": "2021-10-01T00:00:00", "image_code": " float;\n\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\nconst float pi = acos(-1.0);\nconst float pi2 = pi*2.0;\n\nvec2 pmod(vec2 p, float r) {\n    float a = atan(p.x, p.y) + pi/r;\n    float n = pi2 / r;\n    a = floor(a/n)*n;\n    return p*rot(-a);\n}\n\nfloat box( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat ifsBox(vec3 p) {\n    for (int i=0; i<5; i++) {\n        p = abs(p) - 1.0;\n        p.xy *= rot(iTime*0.3);\n        p.xz *= rot(iTime*0.1);\n    }\n    p.xz *= rot(iTime);\n    return box(p, vec3(0.4,0.8,0.3));\n}\n\nfloat map(vec3 p, vec3 cPos) {\n    vec3 p1 = p;\n    p1.x = mod(p1.x-5., 10.) - 5.;\n    p1.y = mod(p1.y-5., 10.) - 5.;\n    p1.z = mod(p1.z, 16.)-8.;\n    p1.xy = pmod(p1.xy,7.0);\n    return ifsBox(p1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    vec3 cPos = vec3(0.0,0.0, -3.0 * iTime);\n    // vec3 cPos = vec3(0.3*sin(iTime*0.8), 0.4*cos(iTime*0.3), -6.0 * iTime);\n    vec3 cDir = normalize(vec3(0.0, 0.0, -1.0));\n    vec3 cUp  = vec3(sin(iTime), 1.0, 0.0);\n    vec3 cSide = cross(cDir, cUp);\n\n    vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir);\n\n    // Phantom Mode https://www.shadertoy.com/view/MtScWW by aiekick\n    float acc = 0.0;\n    float acc2 = 0.0;\n    float t = 0.0;\n    for (int i = 0; i < 99; i++) {\n        vec3 pos = cPos + ray * t;\n        float dist = map(pos, cPos);\n        dist = max(abs(dist), 0.02);\n        float a = exp(-dist*3.0);\n        if (mod(length(pos)+30.0*iTime, 60.0) < 1.0) {\n            a *= 2.0;\n            acc2 += a;\n        }\n        acc += a;\n        t += dist * 0.5;\n    }\n\n    vec3 col = vec3(acc * 0.01, acc * 0.00066 + acc2*0.02, acc * 0.00066+ acc2*0.5);\n    fragColor = vec4(col, 1.0 - t * 0.03);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dBSR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[10, 10, 29, 29, 92], [150, 150, 178, 178, 284], [286, 286, 315, 315, 406], [408, 408, 430, 430, 620], [622, 622, 652, 652, 823], [825, 825, 882, 882, 1882]], "test": "error"}
{"id": "7dBSWG", "name": "symmetry tiling practise", "author": "caogtaa", "description": "It's implemented by 2 overlapped layers, but how to handle layer 2 by kind of \"symmetry\"?", "tags": ["tiling", "symmetry"], "likes": 8, "viewed": 84, "published": "Public", "date": "1620896787", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265\n#define R 2.\n#define MARGIN 2.\n#define GRIDS 4.\n\n\nfloat Circle(vec2 st, vec2 o, float r, float blur) {\n\t return smoothstep(r+blur, r, distance(st, o));\n}\n\nmat2 Rotate2d(float angle){\n    return mat2(cos(angle),-sin(angle),\n            sin(angle),cos(angle));\n}\n\nfloat Shape(vec2 st, float angle, float blur) {\n    // 对单个格子缩放画布\n    // scale canvas for single grid\n    float width = PI+R+MARGIN;\n    st *= width;\n    \n    // 对角镜像\n    // diagonal mirror\n    st = st.x + st.y > width ? width - st : st;\n\n    st = Rotate2d(angle) * st;\n    st = abs(st);    \n    \n    // 绘制\"头部\"。Y从R向0移动时，圆心逐渐向远处移动，使圆变形\n    // draw \"head\", shift circle origin as Y decrease to 0, deform it heart-like\n    float deform = 0.6;\n    float circle = Circle(st, vec2(PI+(st.y-R) * deform, 0.), R, blur);\n    \n    // 绘制\"颈部\"，对cos函数做缩放偏移, \"shift\"控制粗细\n    // draw \"neck\" with cosine wave, \"shift\" controls thickness\n    float shift = 0.35;\n    float cosine = -cos(st.x) * (1.-shift) + 1.+shift;\n    float cosineDist = smoothstep(blur, 0., st.y - cosine);\n    \n    float mask = st.x < PI ? cosineDist : circle;\n    return mask;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv *= GRIDS;\n\n    vec2 st = fract(uv);\n    vec2 id = floor(uv);\n    \n    float t = iTime;\n    float angle = 0.;\n    angle = sin(t*0.5) * PI;\n    float everyOther = mod(id.x + id.y, 2.);\n    \n    // 每隔一个格子初始角度偏移PI/2，为了画面衔接\n    // every other grid shift init angle by PI/2\n    angle += everyOther * PI * 0.5;\n    \n    // 每隔一个格子初始角度偏移PI/2，为了画面衔接\n    // every other grid rotate reversly\n    angle *= everyOther * 2. - 1.;\n    \n    float blur = 1./iResolution.y * GRIDS;\n    float mask = 0.;\n    mask += Shape(st, angle, blur);\n    \n    // 叠加第二层，目前没学会如何用对称的方法处理第二层。如果有请教教我\n    // overlap layer 2. how to handle layer 2 by kind of \"symmetry\"?\n\tmask += Shape(vec2(1.-st.y, st.x), -angle, blur);\n    vec3 color = vec3(mask);\n\n    // Output to screen\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dBSWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 124, 124, 175], [177, 177, 204, 204, 282], [284, 284, 331, 402, 1225], [1227, 1227, 1284, 1284, 2264]], "test": "valid"}
{"id": "7dBSWR", "name": "cppn2glsl_test2", "author": "vsewall", "description": "this code was generated by lucid neural network in google colab", "tags": ["neural", "colab", "cppn"], "likes": 3, "viewed": 61, "published": "Public", "date": "1619986815", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define N_HIDDEN 16\n \nvec4 bufA[N_HIDDEN/4];\nvec4 bufB[N_HIDDEN/2];\n \n \nvec4 cppn_fn(vec2 coordinate, float in0, float in1, float in2, float in3) {\n    vec4 tmp;\n    bufB[0] = vec4(coordinate.x, coordinate.y, 0., 0.);\nbufA[0] = vec4(0.1392157,-0.14403622,-0.10987018,0.088629395) + mat4(vec4(0.5527324080467224,0.7989373803138733,0.8469162583351135,-0.4809730350971222),vec4(0.02086402103304863,-0.7741007804870605,0.08225523680448532,-0.6063721776008606),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\nbufA[1] = vec4(0.22139116,0.46250686,0.47169903,0.2716057) + mat4(vec4(-0.34766313433647156,0.07682348787784576,-0.3346748948097229,-0.6201396584510803),vec4(0.019231440499424934,-1.826249122619629,0.724222719669342,0.07378915697336197),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\nbufA[2] = vec4(-0.21973355,0.08887826,-0.2843799,-0.3404704) + mat4(vec4(-0.25068917870521545,0.3535909354686737,-0.6616144776344299,0.6285610795021057),vec4(0.856115996837616,0.7632209658622742,0.05364528298377991,-0.3126447796821594),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\nbufA[3] = vec4(-0.30295828,0.26827592,-0.07280064,0.5746382) + mat4(vec4(-0.8132221102714539,-0.12490193545818329,0.6580310463905334,1.1463209390640259),vec4(0.0959293395280838,0.4924165904521942,-1.2564489841461182,-0.7626469135284424),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\ntmp = sin(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(-0.29099172,0.053163238,0.33655,-0.44018662) + mat4(vec4(0.1488758,-0.13007033,-0.12612073,-0.036037873),vec4(0.03960949,-0.014362597,0.33148044,0.16588044),vec4(0.16212001,-0.19103622,-0.0677809,0.031183003),vec4(-0.051917557,-0.12049083,-0.32648787,-0.2033548)) * bufB[0] + mat4(vec4(-0.14938232,0.4440312,-0.4179407,-0.06715003),vec4(-0.16362296,0.06070456,-0.1242206,0.20667146),vec4(-0.059568487,-0.13040295,-0.08550807,-0.012654861),vec4(-0.13037446,0.00030371142,0.14328898,0.05768267)) * bufB[1] + mat4(vec4(-0.04780508,0.15955468,-0.13329466,-0.31489387),vec4(-0.26004887,0.5244744,0.045032687,-0.1802943),vec4(-0.14015667,-0.267675,-0.035999272,-0.1752947),vec4(0.10329164,0.10043791,0.17175077,-0.260937)) * bufB[2] + mat4(vec4(-0.4537429,0.27386698,-0.15144984,0.02024186),vec4(-0.15538639,0.21396668,0.025437992,0.2656227),vec4(0.1936712,-0.13960783,-0.17575692,-0.25811082),vec4(0.028781246,0.0911344,-0.18983151,0.05253229)) * bufB[3] + mat4(vec4(-0.08293231,0.06868567,-0.022794917,-0.02395075),vec4(-0.024213118,-0.22359733,0.42282668,0.001109852),vec4(-0.06889077,0.11945153,0.42088354,-0.055431847),vec4(-0.28987953,-0.19718204,0.16046244,-0.12231544)) * bufB[4] + mat4(vec4(0.047418974,-0.18389301,-0.08816122,0.19270442),vec4(0.38551316,0.2980147,-0.30117923,-0.013725798),vec4(-0.039796352,-0.082422756,0.2391206,-0.012220968),vec4(0.17030501,-0.19140936,0.085609354,0.1641735)) * bufB[5] + mat4(vec4(-0.21387827,-0.27800795,-0.1037876,-0.07727278),vec4(-0.17854458,-0.46085793,0.042386014,-0.078590564),vec4(-0.1749416,-0.044531573,-0.2253041,-0.16668102),vec4(0.30727983,0.16109681,0.032084696,0.17205977)) * bufB[6] + mat4(vec4(-0.04392544,0.04620644,-0.099748015,-0.35749027),vec4(-0.045716472,0.16244918,0.25105783,-0.043241307),vec4(0.58723307,-0.11942209,-0.110083275,-0.17061919),vec4(-0.100056686,-0.19621271,-0.27439958,-0.020583557)) * bufB[7];\nbufA[1] = vec4(0.3830168,0.2874283,0.14254777,0.42079642) + mat4(vec4(-0.21236464,0.055113092,0.12764215,0.21360692),vec4(0.046499714,0.15253353,0.103622235,-0.033114005),vec4(0.41094106,-0.1809898,0.0052033872,0.17236902),vec4(-0.026378231,-0.2867365,-0.00802052,0.011740454)) * bufB[0] + mat4(vec4(0.12206383,-0.18698648,0.116284564,-0.07349405),vec4(-0.05186169,-0.28004634,0.25088128,0.14829881),vec4(0.17162809,0.056021478,0.045127384,-0.23950022),vec4(-0.17422828,-0.04335135,-0.17165561,0.09718971)) * bufB[1] + mat4(vec4(-0.053994935,-0.028770551,-0.3246327,0.0031834503),vec4(-0.04128619,0.18585624,0.33212894,0.279761),vec4(-0.013036767,0.08397355,-0.086608864,-0.28791192),vec4(0.03548049,0.10911093,0.31858805,0.13294305)) * bufB[2] + mat4(vec4(-0.25094414,0.23058459,-0.09613707,0.00034706155),vec4(-0.19537666,-0.09685629,0.030484783,0.06754539),vec4(0.30228484,0.02408613,-0.13061455,0.00036060112),vec4(0.2914868,0.10293909,0.012473264,0.0076613924)) * bufB[3] + mat4(vec4(0.31394285,0.30644014,0.029825948,0.19991136),vec4(0.10754622,0.089245304,-0.20936476,0.18153508),vec4(0.1315374,0.22907963,-0.20751034,0.11499764),vec4(0.30139616,0.33424008,-0.21035446,-0.13899507)) * bufB[4] + mat4(vec4(-0.1943886,0.11355618,0.20307432,-0.07389561),vec4(-0.04867342,0.34333962,0.115580976,-0.09749835),vec4(-0.13576066,-0.09389041,0.23772424,0.056525506),vec4(-0.44207153,0.075010836,-0.10123406,-0.27951798)) * bufB[5] + mat4(vec4(0.16840778,0.20292947,-0.1650962,0.18211474),vec4(0.20777595,0.3161431,-0.066138044,-0.012093568),vec4(-0.057748593,0.24185073,-0.061927587,0.09538677),vec4(-0.1825104,0.103294976,0.20056523,0.038109712)) * bufB[6] + mat4(vec4(0.023510307,0.16611512,-0.053307906,0.2887182),vec4(0.062454037,-0.10624931,-0.07611613,-0.01301078),vec4(-0.005081722,0.19987212,-0.17287713,-0.043693144),vec4(-0.059820876,-0.22353047,-0.20382859,-0.121855825)) * bufB[7];\nbufA[2] = vec4(-0.33257222,0.14988104,-0.20734628,0.017082373) + mat4(vec4(0.018002484,-0.025729239,-0.053308696,-0.036156498),vec4(-0.046571136,0.20754321,0.055922598,0.074227564),vec4(0.08758112,0.12437972,0.036959488,-0.089939594),vec4(-0.102925844,-0.20014992,-0.30133504,-0.03703004)) * bufB[0] + mat4(vec4(-0.029336631,-0.29781926,0.012046123,0.21460238),vec4(-0.23119316,0.0180176,0.18100971,0.24652176),vec4(0.121431984,-0.02553179,-0.08404241,0.087732896),vec4(-0.26654887,-0.06574553,-0.09177668,0.2934775)) * bufB[1] + mat4(vec4(-0.3380493,0.10213437,-0.023803582,-0.19724478),vec4(-0.14164269,0.10570151,-0.07955972,-0.11092779),vec4(-0.01442183,-0.14666343,-0.15033148,0.29843006),vec4(-0.0059082177,0.24761464,0.18102859,-0.13663957)) * bufB[2] + mat4(vec4(-0.00015309431,0.003621174,0.119538955,0.012908104),vec4(0.3012528,-0.30036443,0.04650813,-0.10629595),vec4(-0.12878606,0.120935336,-0.071355246,0.028908722),vec4(-0.014884945,-0.22306581,-0.08994216,-0.14647196)) * bufB[3] + mat4(vec4(0.51238346,0.106096976,-0.080477364,-0.20291492),vec4(0.09534993,0.21976463,-0.38841623,0.22007291),vec4(0.010133497,0.15211082,-0.22895138,-0.13117568),vec4(0.21484356,0.20384751,0.1464498,0.18264726)) * bufB[4] + mat4(vec4(-0.0025207803,0.19650064,0.0660299,-0.0950627),vec4(-0.18468265,-0.14092077,0.003937874,0.34481218),vec4(-0.099528335,0.09127804,-0.30761942,0.030934725),vec4(0.0072783804,-0.03352637,-0.039574414,0.11646549)) * bufB[5] + mat4(vec4(-0.014395519,0.33819655,0.5104979,-0.09439558),vec4(0.054681595,0.07643831,-0.07377777,-0.22536713),vec4(-0.15934262,0.17364424,-0.3622582,0.30945557),vec4(0.10624293,-0.01687353,0.11298123,-0.35386735)) * bufB[6] + mat4(vec4(-0.08627277,0.11781017,-0.29761466,-0.07257579),vec4(0.18872143,-0.04208001,0.056462422,-0.09167415),vec4(0.1031181,0.2900268,0.03819227,-0.14227961),vec4(-0.087914035,-0.14897329,0.27856418,0.07815257)) * bufB[7];\nbufA[3] = vec4(0.031553824,0.39816517,-0.045499228,-0.047925998) + mat4(vec4(0.119545385,0.13947287,-0.1775018,-0.044049975),vec4(0.110787295,3.9746898e-05,0.12257363,0.17837238),vec4(0.16276114,0.13452178,-0.093208306,0.16482885),vec4(-0.027288456,0.26056433,0.11305098,0.31704023)) * bufB[0] + mat4(vec4(-0.19819869,0.10713835,0.22512873,-0.10058218),vec4(0.08925121,-0.24502417,0.043990593,0.29849496),vec4(0.0393491,-0.26194087,0.38913506,-0.082799494),vec4(0.034323655,0.1098205,-0.3639223,0.3727796)) * bufB[1] + mat4(vec4(-0.058997072,-0.07517357,-0.17998676,0.048017416),vec4(-0.062455993,-0.068899594,0.049032975,0.0029638985),vec4(0.063415155,0.039331365,-0.052538905,0.085308656),vec4(0.030126348,0.043955375,-0.06828437,0.19519801)) * bufB[2] + mat4(vec4(0.11377189,0.053102735,-0.051833738,0.097258665),vec4(-0.24086688,-0.012162751,0.073384576,-0.020149829),vec4(0.19955786,0.2748417,0.13125722,-0.10643477),vec4(-0.1999988,0.33493704,0.08031487,0.08627437)) * bufB[3] + mat4(vec4(0.0727559,0.05477634,0.24897467,-0.2360891),vec4(0.1362621,0.13639864,-0.11223423,-0.06028089),vec4(0.05120704,0.04572134,0.16006531,-0.15114132),vec4(0.2926742,0.005409149,-0.0017128392,-0.17208184)) * bufB[4] + mat4(vec4(-0.257713,-0.1023777,0.47416928,-0.19229682),vec4(0.18909448,-0.020073581,0.05950728,-0.37421757),vec4(-0.29963857,-0.05977319,-0.034520853,0.21766494),vec4(-0.0074312086,-0.25735876,0.037522033,-0.04152509)) * bufB[5] + mat4(vec4(0.12823027,-0.10016599,-0.27751455,-0.23307312),vec4(0.15043892,-0.3198715,-0.26499885,0.38671976),vec4(0.27708578,0.06470566,0.26222667,0.016652426),vec4(0.1167519,0.21690883,0.14107256,0.3024904)) * bufB[6] + mat4(vec4(0.5748376,-0.2067332,0.0019674036,-0.009830031),vec4(0.09975654,-0.046163194,-0.30930355,0.05050305),vec4(0.12666781,0.3320562,-0.014986834,-0.12078481),vec4(0.34969512,-0.061464805,0.12422402,0.02304014)) * bufB[7];\ntmp = sin(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(0.07026067,-0.28475302,0.19975053,0.008220652) + mat4(vec4(0.28323296,-0.11721426,-0.05171784,-0.0017327542),vec4(-0.2794855,-0.39076558,-0.037575778,-0.11581995),vec4(-0.38667324,0.09559459,0.15305953,0.14265388),vec4(0.11914782,-0.03208786,0.18255986,0.01593591)) * bufB[0] + mat4(vec4(-0.1447506,-0.057754703,0.038142305,0.19140506),vec4(0.11616808,0.10482558,-0.0766989,0.12158459),vec4(-0.15488379,0.026700165,0.24235046,0.015165365),vec4(0.07903673,0.014365538,0.15472464,-0.026155101)) * bufB[1] + mat4(vec4(0.13527432,-0.13865438,0.0603871,0.21896966),vec4(0.02988954,0.040405866,0.0072492035,-0.13441753),vec4(0.11751483,0.13430262,-0.13691507,-0.19328399),vec4(-0.063247725,-0.12640779,0.03526889,-0.14674626)) * bufB[2] + mat4(vec4(-0.14311846,-0.29450753,-0.35964316,0.036067262),vec4(0.29169863,-0.25261787,-0.2264393,-0.14941555),vec4(-0.222173,-0.017529339,0.05975793,0.005813618),vec4(-0.023074351,-0.14792277,-0.07707333,-0.16289228)) * bufB[3] + mat4(vec4(-0.005554198,-0.1569268,-0.2741734,0.18407974),vec4(0.3259605,0.3850653,-0.3738984,-0.03390298),vec4(0.2712018,0.20444997,0.20646164,-0.16969544),vec4(0.1730133,0.0058632432,-0.1013848,0.068175375)) * bufB[4] + mat4(vec4(0.3393086,0.06152616,-0.1932077,-0.44440567),vec4(0.36382,0.114826955,-0.010308186,0.124467574),vec4(-0.2529273,-0.42494228,-0.35168502,0.21838877),vec4(0.12686025,0.033848934,0.4334406,-0.044598863)) * bufB[5] + mat4(vec4(0.2684147,0.04903154,0.04536046,0.065565705),vec4(0.013622524,-0.00965762,-0.1986015,0.25184336),vec4(-0.092109986,0.12225229,0.03713821,-0.082348906),vec4(0.14550918,0.12599643,-0.039978962,0.12341258)) * bufB[6] + mat4(vec4(-0.2098002,-0.21317673,0.06686484,0.0926595),vec4(-0.098458536,-0.10224815,-0.27846846,0.4123117),vec4(-0.113066286,0.2461739,0.05413401,0.16409239),vec4(0.13695334,0.14283891,0.18547294,0.0990722)) * bufB[7];\nbufA[1] = vec4(-0.2169151,-0.27405533,0.4528337,-0.16798486) + mat4(vec4(0.2410014,-0.07289833,0.0054998756,0.19908457),vec4(0.11972071,0.14286968,0.004071854,0.23675081),vec4(0.26880166,0.21980351,-0.014510637,-0.2008869),vec4(-0.23944841,0.008141002,-0.030891882,0.29192582)) * bufB[0] + mat4(vec4(0.019086756,-0.26291576,-0.2938033,0.068492115),vec4(0.25782144,-0.101124525,-0.022910072,-0.062329277),vec4(0.1603163,-0.07200535,-0.019506445,-0.069814235),vec4(-0.26546982,0.11391649,-0.2862,-0.052650746)) * bufB[1] + mat4(vec4(-0.26759627,0.23718852,-0.07534837,0.15964015),vec4(0.055056214,-0.14687353,0.54119265,0.057934873),vec4(-0.2506047,0.06405475,-0.31886953,-0.117034905),vec4(0.055799928,0.12974449,-0.36719298,-0.04442039)) * bufB[2] + mat4(vec4(0.14919941,-0.05291809,-0.0090219835,0.10473175),vec4(-0.20774683,-0.037425794,-0.08900274,-0.40456656),vec4(-0.013263511,0.26879665,-0.022000434,0.18481907),vec4(-0.1519519,0.048101474,-0.26611632,-0.16885222)) * bufB[3] + mat4(vec4(-0.2662977,0.043059677,0.17466322,0.17513587),vec4(-0.007190073,-0.33040848,-0.13655533,-0.022140773),vec4(-0.011445126,-0.25085613,-0.30990684,0.0725193),vec4(-0.013972558,0.20818245,0.1314769,-0.024429256)) * bufB[4] + mat4(vec4(0.076524295,0.11543374,0.13191462,-0.17157745),vec4(0.0063651497,-0.32345405,0.3846464,-0.20392881),vec4(0.052232362,-0.109371856,0.27560133,-0.21400593),vec4(-0.19090304,0.06454186,0.3117382,0.029785598)) * bufB[5] + mat4(vec4(-0.031970344,0.120114125,0.057141744,0.4799803),vec4(-0.49921435,0.115802996,0.33408174,0.32836387),vec4(0.07185959,-0.04346671,0.06779942,0.14801589),vec4(-0.19857304,0.24441543,0.25355828,0.19730733)) * bufB[6] + mat4(vec4(0.28694266,-0.11313078,0.060673513,0.3866265),vec4(0.023287531,0.021452889,-0.06837004,0.35828432),vec4(0.20716,-0.090563335,0.0045539388,0.24541388),vec4(0.2206457,0.23753248,0.1617662,0.27400574)) * bufB[7];\nbufA[2] = vec4(-0.48632097,0.42735985,0.13495025,0.41233432) + mat4(vec4(-0.056638516,-0.23889056,0.065016165,-0.12650426),vec4(0.29338217,0.120183446,-0.09080427,-0.12543026),vec4(0.086220704,0.058890853,0.08335499,-0.028937122),vec4(-0.1977701,0.040824898,0.18705599,0.009668142)) * bufB[0] + mat4(vec4(-0.09053417,0.11157064,-0.03767312,-0.23694202),vec4(-0.08232982,0.038719047,-0.22916421,-0.11664392),vec4(-0.0116827525,0.070577495,-0.28066897,-0.036636148),vec4(-0.11092683,-0.106201544,-0.23515804,-0.039173882)) * bufB[1] + mat4(vec4(0.16355877,0.068867065,-0.12703659,0.031039817),vec4(0.100974165,-0.28965318,0.100968644,-0.026785975),vec4(-0.3152567,-0.017620131,-0.08503992,-0.07995962),vec4(-0.33813268,0.0075830864,-0.014125364,0.21054293)) * bufB[2] + mat4(vec4(-0.036467317,0.16301271,0.075165495,0.41946757),vec4(-0.19886091,0.38656887,-0.001485542,0.1609911),vec4(-0.26669437,0.038821656,-0.09910452,0.20075867),vec4(0.07781926,0.25760186,0.08946548,-0.014803039)) * bufB[3] + mat4(vec4(0.07387956,-0.14217155,0.22553985,-0.020332528),vec4(0.031779997,0.11470913,0.07330069,-0.13615416),vec4(0.39001822,-0.026855486,0.5041183,0.27046305),vec4(-0.0059023355,-0.2559332,-0.045959823,0.14389908)) * bufB[4] + mat4(vec4(-0.115368165,0.1192326,-0.062214546,0.44219312),vec4(0.018142572,0.111348175,-0.36957318,0.37798816),vec4(0.21230806,-0.20400435,0.15302743,0.09675912),vec4(-0.062460072,-0.11181669,-0.041267052,0.055688452)) * bufB[5] + mat4(vec4(0.057589978,0.18427914,-0.12147788,0.16079082),vec4(-0.33312514,-0.121070385,-0.036401834,0.2519306),vec4(-0.28604963,-0.1302422,0.07988389,-0.33346048),vec4(-0.07452799,-0.039177176,-0.18486886,0.2546526)) * bufB[6] + mat4(vec4(0.39253646,0.1135851,0.11709697,-0.066304676),vec4(0.08158854,-0.2777424,-0.06173236,-0.034104552),vec4(-0.09709988,-0.11654039,0.21637231,0.25906515),vec4(-0.16651286,-0.22413836,0.0019595549,0.0055473372)) * bufB[7];\nbufA[3] = vec4(-0.34073567,-0.23316467,-0.37243804,0.08815071) + mat4(vec4(0.29783842,-0.28211877,0.102274336,-0.16565384),vec4(0.1487874,-0.20830616,-0.06594981,0.06867693),vec4(0.25700253,0.03978215,0.29537553,-0.17080794),vec4(-0.03572289,-0.22822127,0.0553393,-0.06952722)) * bufB[0] + mat4(vec4(0.035407215,0.45956796,-0.35327682,-0.004816728),vec4(0.18521525,-0.26784578,0.11694204,0.08061862),vec4(0.33804867,0.13013037,0.40385258,-0.104105696),vec4(0.097789474,0.1702123,-0.18785176,-0.21690832)) * bufB[1] + mat4(vec4(0.114784524,-0.2379462,0.03574868,-0.022544827),vec4(0.019557308,0.3224116,-0.039117683,-0.1406759),vec4(0.019634863,0.08296022,-0.30648085,0.090149656),vec4(-0.01718743,0.12083001,-0.3250836,0.03621228)) * bufB[2] + mat4(vec4(-0.2555743,0.07523948,0.056138497,-0.15802424),vec4(0.18416226,-0.27530596,0.09338188,-0.14788282),vec4(0.08861074,0.1905854,0.14115857,-0.09168397),vec4(-0.30594698,-0.058958504,0.032283187,-0.08174954)) * bufB[3] + mat4(vec4(0.2676054,0.18088895,0.2727381,-0.0381952),vec4(-0.22587234,0.16850282,-0.09627096,-0.16751358),vec4(0.18332905,0.15021971,0.20710823,0.028754933),vec4(0.015230716,-0.20200343,0.048711207,0.037462268)) * bufB[4] + mat4(vec4(-0.03148053,0.14298324,0.13760436,0.049381465),vec4(-0.31517613,0.2865385,-0.077284425,0.09293456),vec4(-0.21197681,-0.07715427,-0.090636246,-0.37306732),vec4(0.06487781,-0.03816916,0.06317043,-0.22513905)) * bufB[5] + mat4(vec4(0.08605206,0.06343561,-0.3570338,0.03948085),vec4(-0.395295,0.016339933,0.06556869,-0.004888446),vec4(0.13294965,-0.18411951,0.12770155,0.15344916),vec4(0.02272643,0.05880395,-0.22445638,0.31620818)) * bufB[6] + mat4(vec4(-0.08419831,0.36015323,-0.14405045,-0.51344347),vec4(0.07871742,0.20061815,0.043324586,0.10487949),vec4(-0.0015208034,0.28788882,0.010897458,-0.14657374),vec4(0.123172164,0.0057411715,-0.03773692,-0.024481295)) * bufB[7];\ntmp = sin(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(-0.056190673,-0.151903,0.26603028,0.32061917) + mat4(vec4(-0.090338625,0.19551967,-0.0026935833,-0.1344586),vec4(0.15372087,-0.17074388,0.31744125,-0.14004427),vec4(0.3190426,0.048416544,0.36685228,0.03234101),vec4(-0.15203255,0.0037291348,-0.06193811,0.00868387)) * bufB[0] + mat4(vec4(-0.04289281,0.123315506,0.065859415,0.19362925),vec4(0.28082162,-0.42100677,-0.31539735,0.006362496),vec4(0.0694591,0.067797065,0.21535645,-0.063008524),vec4(-0.0123834405,0.19327357,0.10847205,0.05553079)) * bufB[1] + mat4(vec4(-0.030956393,-0.10150562,0.35021853,-0.20193619),vec4(0.00839681,0.0113006765,0.05925874,0.15568063),vec4(-0.019005392,-0.41580695,-0.338799,-0.009658654),vec4(0.25196907,-0.13465975,0.031377994,-0.18699014)) * bufB[2] + mat4(vec4(0.01491023,0.2779025,-0.29170707,-0.0932146),vec4(0.0070731584,-0.0834466,0.2708835,-0.030703938),vec4(0.076503016,0.05384517,-0.1928276,0.07843442),vec4(0.018434623,0.2559253,0.23961397,0.33928737)) * bufB[3] + mat4(vec4(0.05244597,-0.01400917,-0.021195693,0.32111505),vec4(-0.1363324,-0.3159319,-0.021638129,-0.15391111),vec4(-0.20480531,-0.14014183,-0.13415535,0.09364145),vec4(-0.36413944,0.054655906,0.35207453,-0.6353254)) * bufB[4] + mat4(vec4(0.39111075,0.30307534,0.17384185,-0.007021733),vec4(-0.053130414,-0.24425831,-0.4348399,-0.24981987),vec4(-8.034373e-05,-0.0686213,0.115844175,-0.2550942),vec4(-0.07325936,0.0992743,-0.13377947,-0.07306128)) * bufB[5] + mat4(vec4(0.21712156,-0.17449734,-0.17752261,0.31076673),vec4(-0.006861354,0.043887928,0.6845058,-0.34503374),vec4(0.2373621,-0.1208544,0.04972148,-0.078038976),vec4(0.2392906,-0.21479204,-0.0073165544,0.013140603)) * bufB[6] + mat4(vec4(-0.10683105,-0.061527427,0.09646515,-0.23556115),vec4(0.20511223,-0.2170068,0.19642186,-0.099868216),vec4(-0.15104923,0.14609961,-0.20707627,-0.24561702),vec4(-0.022717636,0.0340867,-0.0902962,-0.1945725)) * bufB[7] + in0;\nbufA[1] = vec4(-0.37049767,0.13793397,-0.06914139,-0.40380785) + mat4(vec4(-0.014947828,-0.29856086,-0.19013572,-0.27604565),vec4(-0.037702166,0.016960502,0.0074070515,-0.22087593),vec4(-0.030642223,0.45934892,0.1690999,0.108382925),vec4(-0.09153397,-0.012165209,0.15740044,0.2676968)) * bufB[0] + mat4(vec4(-0.05005729,0.14628255,-0.034278285,0.057550643),vec4(0.03581999,-0.2558372,-0.022652678,0.20810835),vec4(-0.12690696,0.23218729,-0.15665545,-0.04077706),vec4(0.23283271,-0.01964636,0.16035043,0.30793473)) * bufB[1] + mat4(vec4(0.0787723,-0.14929292,0.23368497,-0.00017378727),vec4(0.22070009,-0.22049151,0.2313732,-0.10166982),vec4(-0.18682957,-0.23889357,-0.05988486,0.004131919),vec4(-0.0612348,-0.20637181,-0.13968618,0.03117762)) * bufB[2] + mat4(vec4(-0.06914841,-0.0026746648,0.05450483,0.04978197),vec4(0.032187533,-0.27178246,-0.031398457,-0.50812),vec4(-0.048542716,0.047462948,-0.09991617,0.16619323),vec4(-0.013955242,-0.19694605,0.1961116,-0.021485873)) * bufB[3] + mat4(vec4(0.3772003,0.040601213,0.049902033,-0.25217497),vec4(-0.22214733,0.23728494,0.061974995,-0.20349729),vec4(0.19462764,-0.056380976,-0.19205217,0.08834565),vec4(0.13797253,-0.40012458,-0.18439813,-0.40165523)) * bufB[4] + mat4(vec4(-0.39523223,-0.027208978,0.052147362,0.19727707),vec4(0.034434315,-0.09495034,-0.3834777,-0.012870662),vec4(-0.23460442,-0.0909122,0.23177996,-0.09238611),vec4(0.100870945,-0.48637438,0.109640725,0.16956098)) * bufB[5] + mat4(vec4(-0.27367127,-0.08038491,0.044765268,-0.11595867),vec4(0.07509178,-0.08458637,-0.057069216,-0.17043045),vec4(0.09338572,0.16596486,0.036788896,0.11902055),vec4(-0.15264522,-0.17184515,-0.2750417,0.17268701)) * bufB[6] + mat4(vec4(0.17917947,0.3150526,-0.43385148,-0.023020875),vec4(0.2040048,-0.28558657,-0.25405505,-0.05309683),vec4(-0.06416596,-0.04102182,-0.21180922,0.0316741),vec4(0.054491207,-0.2549085,-0.054022606,-0.1905541)) * bufB[7] + in1;\nbufA[2] = vec4(-0.36045724,0.27553675,-0.33512855,-0.27646765) + mat4(vec4(-0.1491884,0.075915605,0.21141602,-0.26765585),vec4(0.013141694,-0.12950508,0.46254325,0.05669679),vec4(0.029381873,0.0964782,0.03392676,0.0041837706),vec4(-0.06959483,0.095713764,-0.0366601,-0.09983573)) * bufB[0] + mat4(vec4(-0.12284696,-0.057539344,0.3153475,-0.11108534),vec4(0.12673852,0.12797819,0.06926326,0.28046414),vec4(-0.08458179,0.27975503,-0.06439267,0.1884096),vec4(0.17104788,-0.057306617,-0.2763153,-0.1815695)) * bufB[1] + mat4(vec4(-0.047873594,0.07680224,0.2254385,0.18793164),vec4(0.250389,0.011116334,-0.25819734,0.030259732),vec4(-0.16479687,-0.0908302,-0.005817768,0.36652157),vec4(-0.0034767145,0.026338167,-0.010362191,-0.2237439)) * bufB[2] + mat4(vec4(0.0139940325,-0.17374793,-0.18657206,0.08149236),vec4(0.2895929,-0.06505049,-0.105148666,-0.3064957),vec4(-0.10941903,-0.13181402,0.11524921,0.08346536),vec4(0.1501511,-0.01067808,-0.38633218,0.0038995754)) * bufB[3] + mat4(vec4(0.07871506,-0.34524357,-0.18644759,-0.28668058),vec4(-0.23249243,-0.24546008,-0.14810821,-0.15871869),vec4(0.13647863,-0.1478381,0.12694232,0.062704764),vec4(-0.20250897,0.15469986,-0.12826644,0.33838335)) * bufB[4] + mat4(vec4(0.0012674471,0.15674111,-0.016319312,-0.060425825),vec4(0.14155109,-0.030837331,-0.3286765,0.011969997),vec4(-0.1132449,-0.35261992,-0.26409575,0.048664786),vec4(0.17125106,0.11951407,0.32479396,-0.13262689)) * bufB[5] + mat4(vec4(0.43340176,0.025138346,0.0718438,-0.35193977),vec4(0.20019992,0.16407843,-0.035360586,-0.14571905),vec4(-0.5993629,-0.0033651858,-0.24715838,-0.28286335),vec4(0.0037891292,0.12414463,-0.3577858,-0.29063758)) * bufB[6] + mat4(vec4(0.30136025,-0.23532681,0.22155,0.03449386),vec4(-0.03222295,-0.3118358,0.17515074,-0.09086117),vec4(0.07075385,-0.029393071,-0.0022357341,0.23654737),vec4(-0.15663305,-0.18304221,-0.1512077,0.14854172)) * bufB[7] + in2;\nbufA[3] = vec4(-0.45879593,0.5757243,0.2590131,-0.43001178) + mat4(vec4(0.065348454,-0.3048781,-0.30996615,0.20323972),vec4(-0.11817524,0.32451543,0.062229976,0.06638065),vec4(0.19459748,-0.023908246,0.15523271,-0.14826433),vec4(0.006457455,0.30943623,-0.37523592,-0.17586888)) * bufB[0] + mat4(vec4(-0.004300191,0.34210423,0.17611669,0.18847969),vec4(-0.21057098,-0.2697467,0.15187944,0.040153265),vec4(0.26101714,-0.3197459,-0.03975131,-0.32902193),vec4(-0.14655155,-0.16153206,0.21168639,0.09359015)) * bufB[1] + mat4(vec4(-0.11580113,0.17410432,0.2305712,0.22008377),vec4(-0.05972646,0.18052173,0.1493112,0.058349457),vec4(-0.1079141,-0.14004122,-0.14504667,-0.30149934),vec4(-0.093388654,0.1605077,-0.16666707,0.037400708)) * bufB[2] + mat4(vec4(-0.11525211,0.15535055,0.2980361,0.06573787),vec4(-0.23643199,0.18724711,-0.15701184,-0.18871853),vec4(-0.024913453,-0.026429188,0.28393394,-0.08427071),vec4(0.16499089,-0.4563467,-0.016409906,-0.3276288)) * bufB[3] + mat4(vec4(-0.29812878,-0.14847209,0.116578616,0.20120789),vec4(-0.06685113,0.14249384,-0.0006473885,-0.013957498),vec4(0.31324565,-0.14893682,-0.058915555,-0.062620044),vec4(0.16820794,-0.004156469,0.13098828,-0.16067553)) * bufB[4] + mat4(vec4(-0.46033633,0.010462021,0.16013962,0.12234817),vec4(0.28699797,-0.025263995,-0.0476415,-0.10321965),vec4(0.17702928,-0.21607259,-0.13626122,-0.025755202),vec4(-0.061743382,0.01636224,0.025903562,-0.28291246)) * bufB[5] + mat4(vec4(0.049256932,-0.03229615,-0.66932803,-0.15725268),vec4(-0.38471234,0.0652649,0.12133856,-0.056309927),vec4(0.031219665,-0.038457982,-0.08800397,0.24167033),vec4(0.05349993,0.115516834,0.11383837,0.2192903)) * bufB[6] + mat4(vec4(-0.10832865,-0.2575902,0.08735689,-0.5736016),vec4(0.14321336,-0.14286086,-0.07782766,-0.16196324),vec4(-0.014528414,0.18128921,-0.060514823,-0.33645082),vec4(-0.040731218,0.14206247,-0.3075154,0.22642675)) * bufB[7] + in3;\ntmp = sin(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(-0.38081846,0.2183214,-0.34133837,0.23267806) + mat4(vec4(-0.19600496,0.4313666,-0.17679761,0.45834473),vec4(0.18859473,-0.11160662,0.08216282,0.08393926),vec4(0.14565076,-0.086054236,0.12896103,0.13598292),vec4(0.29456764,-0.21624629,-0.28346345,0.39809975)) * bufB[0] + mat4(vec4(0.15624724,-0.24299644,0.30855358,-0.44981343),vec4(-0.11392182,0.08126363,-0.00061214383,0.14149453),vec4(0.09100183,0.020862821,0.19051298,-0.31313047),vec4(0.16146058,-0.018194743,-0.1824013,-0.27464992)) * bufB[1] + mat4(vec4(0.030704578,-0.5326489,-0.039243408,-0.08919561),vec4(0.14742287,0.3926456,-0.3524132,0.31623328),vec4(-0.0014678342,-0.068849266,-0.11351669,-0.22950932),vec4(0.45503554,0.21786067,0.024527451,0.05183447)) * bufB[2] + mat4(vec4(-0.26809284,-0.031525753,0.22221734,-0.10053458),vec4(-0.11079534,-0.025065796,0.034752652,-0.14844312),vec4(0.1156745,0.27789184,-0.0049339114,0.016490823),vec4(-0.080426514,-0.026639242,0.017584112,0.06268479)) * bufB[3] + mat4(vec4(0.40502155,0.13683574,-0.16966225,-0.2661726),vec4(0.2319957,-0.18829422,0.014782045,-0.02323454),vec4(-0.0856483,0.16115026,0.12620614,0.14409658),vec4(0.20837848,-0.0074264994,-0.23824488,-0.004799486)) * bufB[4] + mat4(vec4(-0.4483405,0.03223559,0.058931526,0.014533215),vec4(0.01488269,0.055459715,0.22397156,0.034416914),vec4(0.05783947,0.29771256,0.25361517,-0.077271596),vec4(-0.10524739,0.008208927,-0.017526623,0.019162204)) * bufB[5] + mat4(vec4(-0.074331835,-0.38528016,0.34011424,-0.31238547),vec4(0.34831792,-0.13951953,-0.3952036,0.20933835),vec4(-0.22843674,-0.10769131,-0.075718366,0.4233496),vec4(-0.02235043,0.25567082,0.1775001,-0.1942927)) * bufB[6] + mat4(vec4(0.09040011,0.15023258,0.049750425,0.21679704),vec4(-0.07407568,0.23849685,0.17391992,0.0004325285),vec4(0.020129414,0.008658444,0.0010370912,0.2347109),vec4(-0.03672814,-0.29083097,-0.3164271,0.049955826)) * bufB[7];\nbufA[1] = vec4(-0.37149513,0.4096643,-0.2033876,-0.3367047) + mat4(vec4(0.10625876,-0.27754802,-0.23502931,0.08176142),vec4(-0.18000293,0.05698881,-0.0001380312,0.11386033),vec4(-0.1825749,-0.22458813,0.41704234,-0.19797646),vec4(0.18372653,0.13359167,0.21274062,0.18065457)) * bufB[0] + mat4(vec4(-0.07112814,-0.1325057,-0.2562195,-0.07575879),vec4(-0.15973277,0.11211806,0.047266066,-0.07863455),vec4(-0.2329912,-0.11840279,0.07731244,-0.30113444),vec4(-0.031479727,0.38860577,-0.0043628225,-0.2228106)) * bufB[1] + mat4(vec4(-0.03454646,0.14487164,-0.15545617,-0.04303009),vec4(-0.027372327,0.136287,0.36413515,0.1708979),vec4(-0.0045760493,0.02990085,0.26791358,0.17007583),vec4(0.35974434,0.28314146,0.116446,0.08991401)) * bufB[2] + mat4(vec4(-0.13121708,0.038817696,0.2519521,-0.20787337),vec4(-0.015855497,-0.13897897,-0.14749451,0.17199393),vec4(0.0073983087,0.10406206,-0.18019107,0.020508017),vec4(-0.14160785,-0.1140975,0.017638804,-0.35517544)) * bufB[3] + mat4(vec4(-0.13389334,-0.121479005,0.025350643,-0.3209256),vec4(0.050612908,0.13938071,-0.10912737,-0.068358794),vec4(-0.2938216,-0.4526065,-0.25561208,0.016631275),vec4(0.10979971,0.2616958,-0.13152649,-0.09042576)) * bufB[4] + mat4(vec4(-0.3054222,-0.05056329,-0.072303,0.077443235),vec4(-0.3457475,0.038166706,-0.26532084,0.019548357),vec4(0.005056434,-0.094227694,-0.23465568,-0.009134615),vec4(0.041727606,-0.19201845,-0.21226108,0.43278193)) * bufB[5] + mat4(vec4(0.015599218,0.27548334,0.4722531,0.1911654),vec4(0.17331153,-0.3277455,-0.11138864,0.029232856),vec4(0.2815654,0.25716347,-0.078103006,-0.20683248),vec4(-0.49200112,0.015559826,0.23654668,-0.15234213)) * bufB[6] + mat4(vec4(0.03341157,-0.2543377,0.3390703,0.102751546),vec4(-0.15122679,-0.10364765,-0.13464342,-0.09426038),vec4(0.44678196,0.04774713,-0.13607313,0.08965183),vec4(-0.1997112,-0.016094849,-0.28132635,0.044274315)) * bufB[7];\nbufA[2] = vec4(-0.046036813,-0.5140887,-0.49532586,0.14662854) + mat4(vec4(0.36289588,0.08416974,-0.14762978,-0.027805518),vec4(0.06132501,-0.019080088,0.18715319,-0.2551409),vec4(0.07549313,-0.1773216,-0.1782901,-0.062095366),vec4(-0.33515286,0.21363021,0.045033235,-0.21064955)) * bufB[0] + mat4(vec4(-0.082663745,-0.042251907,0.09075651,-0.060224257),vec4(0.05742778,0.19959979,0.24807866,-0.29134527),vec4(0.08127847,0.5014297,-0.16638829,-0.28751895),vec4(0.03723433,-0.20266184,0.18675195,-0.06745641)) * bufB[1] + mat4(vec4(-0.17982945,-0.19851094,-0.19258386,0.17378289),vec4(-0.2651454,0.07841331,-0.119849645,0.08093566),vec4(0.19955519,-0.19985025,0.2306688,-0.41504595),vec4(0.022144157,-0.06100806,-0.1355326,0.17584437)) * bufB[2] + mat4(vec4(0.19529416,0.416257,-0.10140175,0.09054505),vec4(0.12703101,0.19134845,0.20762393,0.08924366),vec4(-0.17815083,0.4144099,0.1789292,-0.17357317),vec4(0.27123633,-0.03440217,0.17047723,-0.21848671)) * bufB[3] + mat4(vec4(-0.079303645,0.16813438,0.10467451,-0.03545988),vec4(0.18172204,-0.03134302,-0.2140977,-0.28658733),vec4(0.096901245,0.035871487,0.105800666,0.2698579),vec4(0.165487,-0.26617157,0.24429776,0.086742446)) * bufB[4] + mat4(vec4(0.08634848,0.31037718,0.2106445,-0.1765215),vec4(-0.17451178,-0.20470905,-0.15248859,0.10030964),vec4(0.013802637,0.0026287793,0.06163079,0.061263554),vec4(-0.12882507,-0.015139121,-0.087584384,-0.28160778)) * bufB[5] + mat4(vec4(0.044646334,0.029754823,-0.08981211,0.07867578),vec4(0.17439923,0.025774872,0.18416135,0.08375258),vec4(-0.25828674,0.14503463,0.19845311,0.3524178),vec4(0.025474535,-0.13705386,0.008233319,-0.12564899)) * bufB[6] + mat4(vec4(-0.04533381,-0.1453424,-0.09462583,0.24651268),vec4(0.0007772917,-0.09873579,-0.33899355,-0.17873341),vec4(-0.12915897,-0.30693507,-0.42450994,-0.09144934),vec4(0.15836623,0.1935036,-0.17343017,0.2111684)) * bufB[7];\nbufA[3] = vec4(-0.5433677,0.2888001,-0.18754487,-0.07497233) + mat4(vec4(0.18591456,0.08893624,0.01367504,-0.0065072915),vec4(0.11336165,-0.06512368,0.15902704,-0.113809384),vec4(-0.03440084,-0.13209513,-0.2085671,-0.19203033),vec4(0.25920558,0.035616536,-0.15570058,0.049573917)) * bufB[0] + mat4(vec4(0.057759177,0.039165344,-0.2007959,-0.05697996),vec4(-0.10637988,-0.15471892,-0.04750641,-0.077158146),vec4(-0.12619917,0.04911898,-0.009076366,0.0874342),vec4(0.31157875,0.41346344,0.13095379,0.014882013)) * bufB[1] + mat4(vec4(0.10701829,-0.47782436,0.24262385,0.10222844),vec4(-0.6118332,0.15508163,0.34571484,-0.10528425),vec4(0.18782182,0.13713425,0.2246131,0.20188348),vec4(-0.1570271,-0.04226532,-0.04537864,0.121777885)) * bufB[2] + mat4(vec4(0.13295452,0.29358396,0.15095305,0.2563214),vec4(-0.31986067,0.09611299,0.038478643,0.10064209),vec4(-0.252236,0.029781973,0.21000972,-0.065132335),vec4(0.053157035,-0.20087963,0.10936373,-0.13412216)) * bufB[3] + mat4(vec4(0.32420638,0.1841265,-0.6578957,-0.004009926),vec4(-0.09930639,-0.16021429,-0.08348348,0.50157976),vec4(-0.031440467,-0.259578,-0.4512844,-0.0062876185),vec4(0.11296801,0.3006522,0.2145621,-0.33936018)) * bufB[4] + mat4(vec4(-0.10993227,-0.042348,0.036841676,-0.0841943),vec4(-0.096309006,-0.06030447,-0.025419999,0.23780034),vec4(-0.092431575,-0.070188,0.11267175,-0.052082516),vec4(0.12488856,-0.12270761,0.28229326,0.2407662)) * bufB[5] + mat4(vec4(0.171511,0.005913254,0.02781091,-0.1522124),vec4(-0.29619977,0.114166595,0.012925977,0.03234268),vec4(0.21686062,-0.11127649,0.05589901,-0.2012004),vec4(-0.42745593,0.071374886,0.10443497,0.3092421)) * bufB[6] + mat4(vec4(-0.09387692,0.15890835,-0.4728912,0.4311988),vec4(0.21123004,0.02750716,0.4149872,-0.063729405),vec4(-0.08611875,-0.27098665,-0.10805473,0.24066842),vec4(0.10648562,-0.573742,0.13570964,-0.0757202)) * bufB[7];\ntmp = sin(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(0.19305597,0.1981928,-0.36741707,0.03680618) + mat4(vec4(-0.023494843,0.13759331,-0.119660795,0.029634936),vec4(0.1496659,0.20180172,-0.49300605,0.16803804),vec4(-0.23827313,0.33217648,-0.12979499,0.028760498),vec4(0.06457751,0.06127245,0.28580812,0.3099377)) * bufB[0] + mat4(vec4(0.02734414,0.3649372,0.25843102,0.0054327487),vec4(-0.05296549,0.12052816,0.31944215,0.028561257),vec4(0.18818419,-0.019328332,0.094943516,0.10619204),vec4(0.23564236,0.2835446,0.099334255,0.17381059)) * bufB[1] + mat4(vec4(-0.09091516,0.39664996,0.3385452,0.1306695),vec4(-0.25540048,0.13326468,0.2518169,0.20992236),vec4(-0.0010746109,-0.3530087,0.4021309,0.1614933),vec4(-0.38812065,-0.47752833,0.123794585,0.12691987)) * bufB[2] + mat4(vec4(-0.2617192,0.21551229,-0.18357946,-0.41850787),vec4(0.33403933,-0.03613223,-0.14922741,0.17543091),vec4(-0.15017593,-0.24780554,-0.07707581,-0.15441751),vec4(0.34578148,-0.09023933,0.0531755,-0.13741922)) * bufB[3] + mat4(vec4(-0.11931497,0.10940248,0.31978524,-0.15687938),vec4(0.03724951,0.2589528,-0.042450335,0.23017758),vec4(0.069140784,0.027997147,-0.35419574,0.22654803),vec4(0.092479005,0.16225183,-0.26244965,-0.09168056)) * bufB[4] + mat4(vec4(0.2552419,0.14970739,-0.41309938,0.058510717),vec4(-0.11122991,0.1155832,-0.32161358,0.42660385),vec4(0.07779818,0.15869612,-0.029021636,0.048025347),vec4(-0.21852145,0.0309483,-0.17486952,-0.18354529)) * bufB[5] + mat4(vec4(0.30689466,0.06412919,0.045046996,-0.14928138),vec4(0.121090405,0.12155069,-0.34046537,-0.09805691),vec4(0.18028319,0.24285996,-0.12010258,0.22157721),vec4(0.21999143,-0.012772296,0.105562165,-0.13970882)) * bufB[6] + mat4(vec4(0.13533859,0.2377328,-0.1915382,-0.11387265),vec4(-0.12514405,-0.12300956,-0.06310729,-0.19389777),vec4(0.27627593,0.08160675,-0.13358065,0.18016118),vec4(-0.32816646,0.006308156,0.20952143,-0.026278136)) * bufB[7];\nbufA[1] = vec4(-0.14277044,0.46946988,0.3309917,-0.40446147) + mat4(vec4(-0.1933882,-0.1401149,-0.11865698,-0.1186879),vec4(-0.3077636,-0.043562245,-0.113469474,-0.0435215),vec4(0.17046832,-0.5973443,-0.086739115,-0.07585898),vec4(-0.3433758,0.222751,0.27066982,0.33215472)) * bufB[0] + mat4(vec4(-0.3613592,0.12953626,-0.13573349,-0.0052294154),vec4(0.21454437,-0.07791268,-0.28531548,0.41352284),vec4(-0.25613418,0.17119259,-0.06636439,-0.07313676),vec4(0.09058721,-0.33875197,0.3291173,-0.28414148)) * bufB[1] + mat4(vec4(0.078241475,-0.03590333,-0.12907644,-0.06306557),vec4(-0.21658924,0.15557267,0.12302585,-0.03299988),vec4(0.0076697995,-0.035275772,-0.22146803,-0.28178436),vec4(0.30237436,-0.023877518,-0.09127971,-0.21894579)) * bufB[2] + mat4(vec4(-0.5427002,-0.15213786,-0.2511362,-0.38753977),vec4(-0.04800801,0.15559383,-0.014260967,-0.014535078),vec4(0.33096433,-0.27271327,0.19156069,0.4293024),vec4(0.072928615,-0.1824679,0.045854665,0.077791914)) * bufB[3] + mat4(vec4(-0.11766656,0.27886304,0.08089733,0.22367492),vec4(0.09527507,-0.11206951,-0.26827475,0.37705833),vec4(-0.42039755,-0.2759436,-0.20066497,-0.28740662),vec4(-0.075981356,0.10916903,0.22446342,-0.1502132)) * bufB[4] + mat4(vec4(-0.120417014,-0.0126633365,-0.15970789,-0.07410321),vec4(0.2408586,-0.16043824,0.2775983,0.10415205),vec4(-0.100970194,0.042013504,0.38035733,-0.49344096),vec4(-0.102056794,-0.3524373,0.30443382,-0.128266)) * bufB[5] + mat4(vec4(0.16392659,0.122652054,-0.054613367,-0.13287604),vec4(0.44686946,0.012675939,-0.09954027,-0.11930252),vec4(-0.070662044,0.30723223,-0.36741203,-0.017264867),vec4(-0.15048932,-0.04497192,0.0771745,0.07792491)) * bufB[6] + mat4(vec4(-0.058989987,0.1406719,0.1798704,-0.07253346),vec4(0.5559099,0.11798656,-0.30920506,0.22327562),vec4(-0.04644552,-0.28174868,-0.16463405,0.22992088),vec4(-0.49005795,-0.24194673,-0.09442841,0.23276074)) * bufB[7];\nbufA[2] = vec4(-0.19544841,0.054830372,0.0536334,0.4893942) + mat4(vec4(-0.011527728,-0.036467995,0.051762294,0.03415779),vec4(0.4524748,0.1631346,0.06567555,-0.058515254),vec4(0.35134253,0.58749765,-0.17904565,0.1491113),vec4(-0.18529156,0.12952055,-0.057734903,0.1268071)) * bufB[0] + mat4(vec4(0.05404315,0.030686812,0.14498186,0.32580125),vec4(0.10680942,0.09358978,-0.050673418,-0.1664148),vec4(-0.18008503,-0.106670626,-0.25729963,-0.09711735),vec4(0.22844571,-0.039390154,-0.024170738,-0.16356225)) * bufB[1] + mat4(vec4(-0.23476559,0.026518751,-0.1096105,-0.2619247),vec4(-0.07894228,0.26923597,-0.22156468,-0.2260029),vec4(-0.04258758,-0.09462228,-0.22099604,0.28443676),vec4(0.11853888,-0.37809962,0.09435605,-0.14301501)) * bufB[2] + mat4(vec4(0.19716588,0.072839744,-0.083679445,-0.07693924),vec4(-0.09686386,-0.18235993,0.0493035,0.052920476),vec4(-0.13698938,0.041312832,0.063114986,-0.12382064),vec4(-0.29740283,0.2600394,0.44551373,0.1544393)) * bufB[3] + mat4(vec4(-0.21658915,-0.27604032,-0.19073644,0.1002327),vec4(0.19418643,0.15043269,0.20358677,0.018403705),vec4(-0.22550218,0.20118433,-0.026731137,-0.23986632),vec4(0.11139452,-0.10877628,0.008374165,0.05128041)) * bufB[4] + mat4(vec4(-0.049271144,0.20126572,-0.35818797,-0.22256346),vec4(0.24908617,0.13843411,0.033210192,-0.14456232),vec4(-0.384487,0.06510741,0.3580327,-0.26753098),vec4(-0.37262723,-0.26667115,0.092651755,-0.15717748)) * bufB[5] + mat4(vec4(-0.020343622,0.04283412,0.13147971,-0.24561277),vec4(0.10619388,0.39454103,-0.089067176,0.13428016),vec4(-0.2741719,-0.1742875,-0.10690084,0.0023212023),vec4(0.022357112,-0.08749306,-0.019352144,-0.22952506)) * bufB[6] + mat4(vec4(-0.05517667,-0.19265968,-0.37834832,0.000855524),vec4(-0.10054307,-0.17697708,0.3546657,0.07508453),vec4(-0.06879938,0.104402736,0.08495242,0.06442901),vec4(-0.14704272,0.13387461,0.4265879,-0.37288103)) * bufB[7];\nbufA[3] = vec4(0.48068824,0.18850276,0.10936783,0.28303772) + mat4(vec4(0.10550686,0.033758614,0.5238994,-0.14709556),vec4(0.044947397,0.18390144,0.13128996,-0.009832646),vec4(0.0006981536,-0.18598102,-0.17807479,0.16895252),vec4(0.104577966,0.15198086,-0.05957637,0.5043912)) * bufB[0] + mat4(vec4(0.06573468,0.038032923,-0.08240462,0.06691987),vec4(-0.15850614,0.21268456,0.060507793,0.26950976),vec4(-0.30388913,-0.0066752858,0.10868339,0.093820274),vec4(-0.10708619,-0.05076916,-0.41929686,0.09210807)) * bufB[1] + mat4(vec4(-0.29629928,-0.18995588,0.35168326,-0.08374444),vec4(-0.2822827,0.2868211,0.08771271,-0.12869152),vec4(-0.17152154,0.15979774,-0.007822112,0.0700234),vec4(-0.114546426,0.036917023,-0.0072315363,0.12475065)) * bufB[2] + mat4(vec4(0.052582532,-0.40898195,-0.08305207,0.13305046),vec4(-0.37675357,-0.17802747,0.2701079,0.37585813),vec4(-0.10644656,0.29978547,-0.42653406,-0.06720433),vec4(0.44781262,0.03920983,0.1026578,-0.045785688)) * bufB[3] + mat4(vec4(-0.24961558,0.22646587,-0.19997266,-0.0433816),vec4(-0.41298535,-0.22189699,0.20542175,-0.43335822),vec4(0.0023429156,0.09459726,0.005152505,0.11321402),vec4(0.29866046,0.0331686,0.08175798,0.12170476)) * bufB[4] + mat4(vec4(0.13929461,-0.16151974,-0.18437769,0.06688911),vec4(0.02941975,0.49308178,0.023893833,0.19207494),vec4(-0.10821265,-0.1848323,0.10714102,0.18240494),vec4(-0.14646253,-0.20711936,-0.04517351,-0.12898564)) * bufB[5] + mat4(vec4(-0.22237709,-0.09227907,-0.41008687,-0.41122374),vec4(0.10735323,-0.34922376,0.33093622,0.12068339),vec4(-0.37216684,0.18177736,0.043227296,0.27600196),vec4(0.34013498,0.031627808,0.2966296,0.2896172)) * bufB[6] + mat4(vec4(0.047011815,0.039597068,-0.02154183,-0.055614352),vec4(-0.055261742,-0.1425749,-0.28503832,-0.032640286),vec4(-0.16620916,-0.22287174,0.43580297,0.113014735),vec4(0.15134647,0.08926022,0.10957531,-0.22378343)) * bufB[7];\ntmp = sin(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(0.3005483,0.22730806,0.37373677,-0.028790768) + mat4(vec4(0.07637481,0.2474065,0.001766563,0.1981522),vec4(-0.17362694,0.11698616,0.4116418,-0.0074186763),vec4(0.29171634,-0.24311857,0.11453935,0.14199778),vec4(0.30272347,-0.0014435921,-0.3308559,0.32161787)) * bufB[0] + mat4(vec4(-0.16054013,0.44922966,-0.089746915,0.023558233),vec4(-0.00068621,-0.0402824,0.12741198,-0.24550065),vec4(-0.103563584,-0.39398426,-0.1059483,-0.09382109),vec4(-0.17283428,-0.32217044,0.07674769,0.21630208)) * bufB[1] + mat4(vec4(0.09333174,0.02783648,-0.21730319,0.0067781126),vec4(0.12519315,0.009202246,0.08693947,-0.09719183),vec4(0.015626973,-0.096330404,0.1218933,-0.1242377),vec4(-0.11735048,-0.13570373,0.016110837,0.06449554)) * bufB[2] + mat4(vec4(-0.56777316,0.030592002,-0.5335025,0.12155377),vec4(0.15684249,0.0710859,0.37495387,0.2613919),vec4(-0.10250056,0.36171502,0.31603757,-0.025886185),vec4(-0.22810712,0.3092338,-0.11896072,-0.034147955)) * bufB[3] + mat4(vec4(0.104738586,0.14161953,0.12829144,0.3837818),vec4(0.24808384,0.060485434,-0.15120876,-0.42960328),vec4(-0.016353752,-0.10103084,-0.04082065,0.040121056),vec4(0.22831605,-0.10188162,-0.37979364,-0.13839665)) * bufB[4] + mat4(vec4(0.0956077,-0.12045048,-0.21538834,0.27853712),vec4(0.31379503,0.2409887,0.11169868,-0.10333276),vec4(-0.06135409,0.31139386,0.0200564,-0.13560563),vec4(-0.0029517529,0.24734437,0.11175469,0.08274818)) * bufB[5] + mat4(vec4(-0.19457369,-0.21311192,0.17299794,0.3703988),vec4(0.1331214,-0.062872216,0.1503831,-0.30313364),vec4(-0.11057325,-0.3365,0.14795068,0.009742349),vec4(-0.00558396,0.022928985,-0.07630218,0.18289286)) * bufB[6] + mat4(vec4(-0.14623825,0.26719078,0.17224452,-0.22249874),vec4(0.282581,0.39300945,-0.07747278,0.20931275),vec4(-0.11299343,0.09557491,-0.36055902,-0.057432905),vec4(0.24927156,0.4931018,-0.16277373,-0.409711)) * bufB[7];\nbufA[1] = vec4(0.20147236,0.13537517,-0.40073204,0.08165233) + mat4(vec4(-0.23017624,0.25204727,-0.24871466,-0.10796842),vec4(0.019249719,0.058533665,0.24203038,0.25056055),vec4(0.009047171,0.3303889,0.24855739,0.084970854),vec4(-0.030230692,-0.25033617,-0.054342903,0.42342988)) * bufB[0] + mat4(vec4(0.18124233,-0.15376645,-0.20583114,0.044826716),vec4(-0.33402824,0.15474291,-0.07262248,0.12688188),vec4(-0.41741624,-0.087735556,-0.11510642,-0.46492344),vec4(0.15633462,-0.37194413,0.1742366,0.27128106)) * bufB[1] + mat4(vec4(-0.009611647,-0.4239054,0.052757077,0.037257057),vec4(0.28591755,-0.10588631,-0.33020714,0.12461611),vec4(-0.35703662,-0.26347795,-0.024356214,-0.25433838),vec4(0.19401595,0.047193997,-0.10307138,0.04004458)) * bufB[2] + mat4(vec4(-0.1735377,-0.05645041,-0.4315517,-0.0041489224),vec4(0.3723944,0.07548275,0.05614173,0.060104616),vec4(-0.16058362,0.3189757,-0.034084637,0.14684503),vec4(-0.46457896,-0.18421796,-0.17420585,-0.0665099)) * bufB[3] + mat4(vec4(-0.045941453,-0.16278774,-0.072561525,0.045939136),vec4(0.26144066,0.09167969,0.27483362,0.5416211),vec4(0.09773464,0.015363794,-0.01461095,0.13108492),vec4(0.12682621,-0.005021885,0.25687775,-0.33432353)) * bufB[4] + mat4(vec4(-0.25730592,0.26876524,0.109549105,0.14363275),vec4(-0.59288406,0.3323069,0.24151008,-0.11792455),vec4(0.30297253,0.21441457,-0.33347154,-0.09935896),vec4(0.59018326,-0.42753693,-0.24006903,0.2079669)) * bufB[5] + mat4(vec4(0.31142068,0.07285852,0.07497171,-0.042831887),vec4(-0.19109099,0.21473172,-0.0085123,-0.04119333),vec4(0.051714636,0.24623853,-0.03483202,-0.10744446),vec4(-0.15155497,0.050336715,0.09751137,-0.25577775)) * bufB[6] + mat4(vec4(-0.52653795,-0.11972856,0.41000894,-0.1773759),vec4(0.2499243,0.29273713,-0.5730445,-0.13036154),vec4(-0.1955454,-0.1291185,-0.48323613,-0.014565698),vec4(0.17975555,-0.24496062,0.4178024,-0.0070473766)) * bufB[7];\nbufA[2] = vec4(0.57344985,-0.39377713,0.31196302,0.079411924) + mat4(vec4(-0.14360172,-0.16701978,0.17079124,-0.14533435),vec4(0.3633582,0.092572376,-0.10543258,0.3625298),vec4(-0.5022048,-0.022099184,0.069226116,0.07280215),vec4(-0.115163386,0.2673803,-0.09523827,0.21844143)) * bufB[0] + mat4(vec4(-0.05527164,-0.26699224,-0.15876922,0.53646874),vec4(0.0042358357,-0.13101666,-0.15778157,-0.06554707),vec4(-0.07538847,-0.03097159,0.0060405834,0.29369855),vec4(0.15330613,-0.1473752,0.19402991,0.15586372)) * bufB[1] + mat4(vec4(-0.14435178,-0.3000623,-0.054803815,0.4294613),vec4(-0.25225085,0.005878942,0.052677866,-0.007808624),vec4(0.12013279,-0.17909361,-0.11839573,0.15461658),vec4(0.13291468,-0.09099811,-0.115633644,-0.09845809)) * bufB[2] + mat4(vec4(0.31675854,0.09657601,-0.18657455,-0.101434164),vec4(-0.18602926,0.14882512,-0.15169798,0.3955067),vec4(0.03414773,0.18847372,0.18243693,0.1782647),vec4(0.0972051,0.033581726,0.051068146,0.093203045)) * bufB[3] + mat4(vec4(0.11105682,-0.18357123,0.4122119,-0.13912602),vec4(0.29994616,-0.33127716,-0.15501301,-0.39707297),vec4(0.37188736,0.06489483,0.15076272,0.17644782),vec4(0.088199876,0.14233056,-0.1657916,0.5161423)) * bufB[4] + mat4(vec4(-0.23500964,-0.10392769,-0.014069649,0.0019663526),vec4(0.15423167,-0.27170354,-0.43291807,0.3322014),vec4(-0.15170835,-0.1284036,0.20869783,0.103102684),vec4(0.41871238,0.31502125,0.09058273,-0.16287906)) * bufB[5] + mat4(vec4(-0.0577252,0.041695636,0.56819636,0.04122632),vec4(0.3654559,-0.072089456,-0.21003598,0.18579121),vec4(0.2281446,0.10463017,-0.06737424,0.09800811),vec4(0.28442207,0.23944527,0.16367644,0.32493976)) * bufB[6] + mat4(vec4(0.05137348,0.21656069,0.24413949,0.049702134),vec4(-0.05390131,0.30973196,-0.29414842,0.08287184),vec4(-0.14779834,-0.31470248,-0.17838162,0.09560618),vec4(-0.52754605,-0.07631061,-0.6420692,0.18066718)) * bufB[7];\nbufA[3] = vec4(0.13527668,-0.54038113,0.16969979,0.04742247) + mat4(vec4(0.032431524,-0.08851935,0.33923805,-0.1107826),vec4(0.18050194,-0.22996913,-0.10182703,-0.21506383),vec4(0.1894815,0.13482817,-0.19618194,-0.20510702),vec4(-0.45373717,0.07125434,0.13468249,-0.24933411)) * bufB[0] + mat4(vec4(0.059501883,-0.039403684,-0.07553571,0.17059657),vec4(0.23034701,-0.30018643,-0.09299418,0.19685136),vec4(-0.1600069,-0.031404905,-0.5546884,-0.25189134),vec4(-0.22132598,0.10083452,0.052533768,-0.3805219)) * bufB[1] + mat4(vec4(0.27311203,0.27196556,-0.13556705,-0.2625895),vec4(0.09934776,0.17530285,-0.024982482,0.05326034),vec4(0.30271628,-0.28246543,0.1251152,0.31437352),vec4(-0.28402844,0.02891023,-0.27573445,0.06465835)) * bufB[2] + mat4(vec4(0.40686548,-0.08074752,0.1915534,0.254657),vec4(-0.073338486,0.13140287,-0.018509272,-0.0819604),vec4(-0.5610531,0.14130005,0.06362042,0.04373869),vec4(-0.09166932,-0.3006563,0.083176315,0.107478075)) * bufB[3] + mat4(vec4(0.4343081,-0.39611012,0.3443499,0.43704826),vec4(0.1283109,-0.30272016,-0.19269103,-0.18017973),vec4(0.2998235,0.38330722,-0.088212684,-0.28187186),vec4(0.26976687,0.19130583,0.021659212,-0.15670346)) * bufB[4] + mat4(vec4(-0.24243973,-0.047533013,0.17368785,-0.29313985),vec4(0.35482907,0.015992196,0.08820963,0.20703377),vec4(0.23366843,0.010752485,0.039015,0.3125269),vec4(0.100258596,0.7287612,0.045624252,0.41547316)) * bufB[5] + mat4(vec4(-0.2300326,0.082746655,0.35887054,0.011836654),vec4(0.041131508,-0.47534725,0.17783552,-0.2555724),vec4(-0.18991077,0.27074072,0.43793592,0.11944979),vec4(-0.22043732,-0.035040364,0.0014585389,0.31529567)) * bufB[6] + mat4(vec4(0.5509521,0.29018906,-0.09310328,-0.15891635),vec4(-0.30780342,0.07278711,-0.39212573,0.10502166),vec4(0.08431141,-0.0908062,0.0895147,0.0132568665),vec4(0.16834566,-0.40186784,0.5323631,0.4291608)) * bufB[7];\ntmp = sin(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(0.1284747,-0.07425099,0.14319064,-0.46221754) + mat4(vec4(0.31963244,-0.25496247,0.39298633,-0.2518046),vec4(-0.06451494,-0.08156927,0.11965649,0.16271442),vec4(0.054220017,-0.06589187,0.08404039,0.091598816),vec4(-0.21281312,0.0420309,-0.22409716,0.28205055)) * bufB[0] + mat4(vec4(0.06176257,-0.019257579,0.087875456,-0.029720822),vec4(-0.17080624,-0.2778926,-0.47781837,0.03794348),vec4(-0.19890645,0.113807835,-0.072816126,0.19528633),vec4(-0.45512447,-0.07671148,0.5866069,0.09835561)) * bufB[1] + mat4(vec4(0.041264605,0.10920648,-0.14660177,-0.19133131),vec4(-0.20389721,0.03713731,-0.26970387,0.030687846),vec4(0.089388855,-0.018984105,-0.41216207,0.050490897),vec4(-0.13760479,0.058788896,-0.3393315,-0.116910726)) * bufB[2] + mat4(vec4(-0.005054134,0.27371514,0.03188783,0.42789137),vec4(-0.06318693,0.036208704,0.08660636,-0.0065670013),vec4(0.11429812,0.107783966,0.037378624,0.053963665),vec4(0.08591909,0.7142032,0.5827904,0.23135659)) * bufB[3] + mat4(vec4(0.44833013,-0.4215723,0.38232213,-0.40653104),vec4(-0.03138245,-0.1309984,-0.13199128,0.116646536),vec4(-0.055748444,0.40481538,-0.44580427,0.0049999338),vec4(-0.08632433,0.36432886,0.09437811,0.4867539)) * bufB[4] + mat4(vec4(0.09935423,0.2660223,-0.025581434,-0.3608382),vec4(0.073658794,0.3026663,0.046337206,0.2152205),vec4(0.085787006,0.1846464,0.08946607,-0.3365932),vec4(0.2167564,-0.07031445,0.50460637,-0.056110308)) * bufB[5] + mat4(vec4(0.10606708,-0.2829845,0.17638922,-0.41708192),vec4(-0.29914472,-0.12906298,-0.09755901,-0.46103737),vec4(-0.25866246,-0.30805615,-0.25852314,-0.700597),vec4(0.37943974,0.1508854,0.040130235,-0.16912916)) * bufB[6] + mat4(vec4(-0.101469785,0.011064242,-0.05917352,0.5530443),vec4(-0.02099597,-0.19276874,0.18165389,-0.59415907),vec4(0.03530995,0.17266828,0.26050076,-0.41339564),vec4(0.16222289,0.026515378,-0.19258972,0.11414048)) * bufB[7];\nbufA[1] = vec4(-0.32443923,-0.13123843,-0.58793765,0.05389503) + mat4(vec4(-0.075128324,-0.17783873,0.6696595,0.31408262),vec4(0.21526368,-0.12165676,-0.47978738,0.14819212),vec4(0.02929538,0.101617984,-0.027762018,0.10709231),vec4(0.3165465,-0.13988745,-0.047402494,0.009008729)) * bufB[0] + mat4(vec4(0.22928277,-0.02292142,0.14556554,0.1149629),vec4(0.08655362,0.03706663,-0.3929,-0.31112894),vec4(0.09457974,-0.045427263,0.21634686,0.124516934),vec4(0.09804496,-0.293048,-0.0332866,0.10454471)) * bufB[1] + mat4(vec4(-0.22575603,-0.09947681,-0.2444781,0.14448707),vec4(0.04254366,0.0027922725,-0.14147893,-0.48598915),vec4(0.33996534,-0.08574676,0.49371013,-0.051926225),vec4(0.02156508,0.4506221,-0.26156342,0.17730364)) * bufB[2] + mat4(vec4(-0.07080716,-0.030414484,0.24489367,0.29189536),vec4(0.19116943,0.14678667,-0.414205,-0.037188422),vec4(-0.20192462,0.065218486,-0.12914039,-0.13357705),vec4(-0.34883484,0.06440758,0.0032243468,0.54349643)) * bufB[3] + mat4(vec4(-0.2864121,-0.08226169,0.23555629,0.32793805),vec4(0.117169656,0.1514617,0.12466709,0.17888658),vec4(-0.35952276,-0.23692964,-0.35123643,0.28991285),vec4(-0.2473499,0.25336578,-0.19187984,-0.2370245)) * bufB[4] + mat4(vec4(-0.28255504,0.13151528,-0.31186697,0.18460044),vec4(0.47608453,-0.1305852,0.8804311,0.44134507),vec4(-0.22241805,-0.07686886,0.14861356,-0.18739274),vec4(0.26572424,-0.19767174,0.49941698,0.6865851)) * bufB[5] + mat4(vec4(0.034371093,-0.038272038,0.23285891,0.31552127),vec4(-0.34670994,-0.0854236,0.08899133,0.2985327),vec4(-0.27376586,0.011002565,0.36596495,-0.4210204),vec4(-0.16389357,-0.24284089,0.5269012,0.60240686)) * bufB[6] + mat4(vec4(0.3352801,-0.10932681,-0.23016068,0.17510392),vec4(-0.17718928,0.23966594,0.051717296,0.3467113),vec4(-0.23481427,0.08653306,0.09858025,-0.006186518),vec4(-0.1273717,-0.078085735,-0.04451442,0.056986123)) * bufB[7];\nbufA[2] = vec4(0.34435618,0.79900753,-0.4204183,0.109095715) + mat4(vec4(-0.08448297,0.2544396,0.43628526,-0.10800574),vec4(-0.12920518,-0.1024706,-0.005767234,0.29120758),vec4(0.06663104,-0.17172372,-0.2141915,-0.1520259),vec4(-0.11752708,-0.02374889,-0.24645689,-0.14122827)) * bufB[0] + mat4(vec4(0.1340532,0.031555563,-0.06333737,0.037598524),vec4(-0.33517882,0.069621205,-0.08369222,-0.060202874),vec4(0.046337474,0.07325367,0.08284064,-0.06338969),vec4(0.18544148,-0.0316665,-0.082511,0.03485779)) * bufB[1] + mat4(vec4(0.22912832,-0.19102414,0.15132435,-0.21004951),vec4(-0.20606148,0.1469524,-0.047455933,-0.013188553),vec4(-0.03975891,0.2122404,0.0618115,0.286076),vec4(0.03250629,-0.02837663,-0.110219695,0.2435202)) * bufB[2] + mat4(vec4(0.08137493,0.105172515,0.19287415,0.07531645),vec4(-0.03127938,-0.06043481,0.13666426,0.0900889),vec4(0.3730857,0.060172424,-0.11294878,-0.050595146),vec4(0.030701192,-0.24198724,0.48812205,-0.0696112)) * bufB[3] + mat4(vec4(-0.28302646,0.26369813,-0.09603985,0.016769957),vec4(-0.31160623,-0.11289007,-0.15603907,0.2765857),vec4(0.42398986,0.0599532,0.29417276,-0.21390946),vec4(-0.023400651,0.20652299,-0.3132537,0.2132883)) * bufB[4] + mat4(vec4(0.43837428,0.04515575,0.12161213,-0.06661587),vec4(-0.28699306,0.10383364,0.18300143,0.2553727),vec4(0.5664262,0.13776201,0.25996178,-0.29382908),vec4(0.073727466,0.11667496,-0.2544262,0.04720535)) * bufB[5] + mat4(vec4(0.28211117,0.24801025,0.28934884,-0.449095),vec4(0.3740123,0.20142426,0.15968014,-0.6389145),vec4(0.5581864,0.024383197,0.4865902,-0.45779955),vec4(-0.012012635,0.236716,0.11059637,-0.042015053)) * bufB[6] + mat4(vec4(-0.33389035,-0.006476446,-0.124767035,0.098512575),vec4(0.30414033,0.074917205,0.24541377,-0.19917315),vec4(0.45237592,-0.045806594,0.2880922,-0.24038315),vec4(-0.064961866,0.19363213,0.07348396,-0.04290109)) * bufB[7];\nbufA[3] = vec4(0.53476596,0.05781715,-0.6312971,0.24083741) + mat4(vec4(-0.07169471,0.24904469,0.24648227,0.18303329),vec4(0.16486399,-0.23259597,0.0986845,0.24422455),vec4(-0.39525142,-0.32825562,0.26998663,-0.015140476),vec4(-0.07502707,0.48459905,0.42571062,0.48319885)) * bufB[0] + mat4(vec4(-0.16721393,-0.09457369,0.29733637,-0.09276704),vec4(-0.16755266,0.113861986,-0.07252577,0.008766206),vec4(-0.07476861,-0.20951527,-0.23589773,0.0999046),vec4(-0.013383475,0.2700398,0.63058126,0.025529793)) * bufB[1] + mat4(vec4(-0.17023507,0.094997324,0.13824952,0.042110626),vec4(0.05015401,0.24183713,0.20660494,0.37795952),vec4(0.2436043,0.1399131,-0.18057394,-0.010116287),vec4(0.08910395,0.2761365,-0.12999593,0.39813626)) * bufB[2] + mat4(vec4(0.3641802,0.036388285,-0.13167524,0.11030409),vec4(0.1929286,0.15808202,-0.17842107,0.08604211),vec4(-0.10167459,0.098637246,-0.13459674,-0.3130225),vec4(-0.22962081,0.36402065,-0.038307324,-0.07169636)) * bufB[3] + mat4(vec4(0.06961641,-0.07272473,-0.1141292,-0.19324079),vec4(0.10538665,-0.28878474,0.16111599,0.27239996),vec4(-0.09127386,0.585815,-0.03368466,-0.41144216),vec4(-0.21008584,0.05837291,-0.071578205,-0.027010754)) * bufB[4] + mat4(vec4(-0.4605389,0.45390028,0.33015674,-0.07570023),vec4(0.30787256,0.016507506,-0.3401612,0.44607455),vec4(-0.19184075,-0.11750444,-0.42157444,-0.43569216),vec4(0.12544627,-0.018529603,-0.023289185,-0.13427696)) * bufB[5] + mat4(vec4(-0.038767,-0.071736276,0.032650456,-0.43112892),vec4(-0.2505264,-0.021962566,0.43036777,-0.24452083),vec4(0.0027165418,-0.13474871,0.282706,-0.29554424),vec4(-0.11459194,0.12839119,-0.010963453,-0.43853536)) * bufB[6] + mat4(vec4(0.08426638,0.068636514,-0.28182256,0.24740946),vec4(0.133034,-0.24831362,0.19083223,-0.079554185),vec4(-0.26127288,0.005503148,0.0959664,-0.30088466),vec4(0.007718132,-0.24279514,-0.23172861,0.031032037)) * bufB[7];\ntmp = sin(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(0.4651624858379364,-0.03446674719452858,-0.1546243280172348,0.0) + mat4(vec4(0.5270249247550964,-0.06327534466981888,0.04157496616244316,0.0),vec4(0.028029408305883408,-0.2471971958875656,0.14207668602466583,0.0),vec4(0.08405202627182007,-0.28460484743118286,-0.5165594816207886,0.0),vec4(0.07071161270141602,-0.2513914406299591,-0.02352302335202694,0.0)) * bufB[0] + mat4(vec4(-0.032778434455394745,-0.22442428767681122,0.06436000764369965,0.0),vec4(-0.15739203989505768,-0.389175683259964,-0.08837797492742538,0.0),vec4(-0.05392952635884285,-0.43179574608802795,-0.43695876002311707,0.0),vec4(-0.03145592287182808,0.024954210966825485,0.0388413667678833,0.0)) * bufB[1] + mat4(vec4(-0.09664515405893326,0.21283982694149017,0.37044546008110046,0.0),vec4(0.5581735372543335,0.11289581656455994,-0.10092741250991821,0.0),vec4(0.20696885883808136,0.013342171907424927,0.09564661234617233,0.0),vec4(0.096464604139328,0.18252015113830566,-0.0009363936260342598,0.0)) * bufB[2] + mat4(vec4(-0.12333245575428009,-0.18646453320980072,-0.48247191309928894,0.0),vec4(-0.08498343080282211,-0.04655557498335838,-0.5465033054351807,0.0),vec4(0.03789900988340378,-0.35359612107276917,-0.3304058909416199,0.0),vec4(-0.011676106601953506,-0.3611185848712921,-0.12898142635822296,0.0)) * bufB[3] + mat4(vec4(-0.20115433633327484,-0.22019223868846893,0.3556138575077057,0.0),vec4(-0.023419970646500587,-0.37119296193122864,-0.04584057629108429,0.0),vec4(0.026532122865319252,-0.34593844413757324,-0.37637200951576233,0.0),vec4(0.06583676487207413,0.5461525917053223,0.32952722907066345,0.0)) * bufB[4] + mat4(vec4(0.0032471243757754564,0.5270434021949768,0.4434675872325897,0.0),vec4(0.16711875796318054,0.44630423188209534,-0.7992166876792908,0.0),vec4(0.05538782477378845,0.37769031524658203,0.1727602630853653,0.0),vec4(-0.0182468444108963,-0.6279658675193787,-0.46679770946502686,0.0)) * bufB[5] + mat4(vec4(-0.04361604154109955,0.2955961525440216,0.40316659212112427,0.0),vec4(0.12609295547008514,0.02200995199382305,0.08314581215381622,0.0),vec4(-0.10006635636091232,0.16703982651233673,-0.34196946024894714,0.0),vec4(0.035000815987586975,-0.3124885857105255,0.14507247507572174,0.0)) * bufB[6] + mat4(vec4(0.05710887536406517,-0.21021944284439087,0.31646570563316345,0.0),vec4(-0.020431043580174446,-0.17631873488426208,0.0956408828496933,0.0),vec4(0.02985757775604725,0.2768854796886444,0.31666144728660583,0.0),vec4(-0.01970868930220604,0.46494171023368835,0.478678822517395,0.0)) * bufB[7];\nreturn vec4((1. / (1. + exp(-bufA[0]))).xyz, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouseNorm = (iMouse.xy / iResolution.xy) - vec2(0.5, 0.5);\n\n\n        uv.x *= iResolution.x / iResolution.y;\n        uv.x -= ((iResolution.x / iResolution.y) - 1.) /2.;\n\n\n    // Shifted to the form expected by the CPPN\n    uv = vec2(1., -1.) * 3. * (uv - vec2(0.5, 0.5));\n    // Output to screen\n    float t = iTime * .25;\n    float a = .8;\n    fragColor = cppn_fn(uv, a * sin(t), a * sin(2.*t), a * sin(3.*t), a* sin(4.*t));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dBSWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[73, 73, 148, 148, 58768], [58770, 58770, 58827, 58877, 59353]], "test": "valid"}
{"id": "7dBXDW", "name": "Topgunner222-SoundEclip", "author": "topgunner222", "description": "fork of SoundEclip", "tags": ["cineshader"], "likes": 10, "viewed": 1461, "published": "Public API", "date": "1620225192", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// credit: https://www.shadertoy.com/view/4tGXzt\n\n#define BEATMOVE 1\n\nconst float FREQ_RANGE = 64.0;\nconst float PI = 3.1415;\nconst float RADIUS = 0.6;\nconst float BRIGHTNESS = 0.2;\nconst float SPEED = 0.5;\n\n//convert HSV to RGB\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nfloat getfrequency(float x) {\n\treturn texture(iChannel0, vec2(floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE, 0.25)).x + 0.06;\n}\n\nfloat getfrequency_smooth(float x) {\n\tfloat index = floor(x * FREQ_RANGE) / FREQ_RANGE;\n    float next = floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE;\n\treturn mix(getfrequency(index), getfrequency(next), smoothstep(0.0, 1.0, fract(x * FREQ_RANGE)));\n}\n\nfloat getfrequency_blend(float x) {\n    return mix(getfrequency(x), getfrequency_smooth(x), 0.5);\n}\n\nvec3 doHalo(vec2 fragment, float radius) {\n\tfloat dist = length(fragment);\n\tfloat ring = 1.0 / abs(dist - radius);\n\t\n\tfloat b = dist < radius ? BRIGHTNESS * 0.3 : BRIGHTNESS;\n\t\n\tvec3 col = vec3(0.0);\n\t\n\tfloat angle = atan(fragment.x, fragment.y);\n\tcol += hsv2rgb( vec3( ( angle + iTime * 0.25 ) / (PI * 2.0), 1.0, 1.0 ) ) * ring * b;\n\t\n\tfloat frequency = max(getfrequency_blend(abs(angle / PI)) - 0.02, 0.0);\n\tcol *= frequency;\n\t\n\t// Black halo\n\tcol *= smoothstep(radius * 0.5, radius, dist);\n\t\n\treturn col;\n}\n\nvec3 doLine(vec2 fragment, float radius, float x) {\n\tvec3 col = hsv2rgb(vec3(x * 0.23 + iTime * 0.12, 1.0, 1.0));\n\t\n\tfloat freq = abs(fragment.x * 0.5);\n\t\n\tcol *= (1.0 / abs(fragment.y)) * BRIGHTNESS * getfrequency(freq);\t\n\tcol = col * smoothstep(radius, radius * 1.8, abs(fragment.x));\n\t\n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 fragPos = fragCoord / iResolution.xy;\n\tfragPos = (fragPos - 0.5) * 2.0;\n    fragPos.x *= iResolution.x / iResolution.y;\n\t\n\tvec3 color = vec3(0.0134, 0.052, 0.1);\n\tcolor += doHalo(fragPos, RADIUS);\n\n    float c = cos(iTime * SPEED);\n    float s = sin(iTime * SPEED);\n    vec2 rot = mat2(c,s,-s,c) * fragPos;\n\tcolor += doLine(rot, RADIUS, rot.x);\n\t\n\tcolor += max(luma(color) - 1.0, 0.0);\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "XdXGRr", "previewfilepath": "/presets/mic.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/mic.png", "ctype": "mic"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dBXDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[208, 229, 250, 250, 419], [421, 421, 445, 445, 495], [497, 497, 526, 526, 619], [621, 621, 657, 657, 868], [870, 870, 905, 905, 969], [971, 971, 1013, 1013, 1480], [1482, 1482, 1533, 1533, 1785], [1788, 1788, 1845, 1845, 2278]], "test": "error"}
{"id": "7dBXWW", "name": "SDF Mandelbulb rows", "author": "Dude", "description": "SDF Mandelbulb rows", "tags": ["sdfmandelbulbrows"], "likes": 0, "viewed": 38, "published": "Public", "date": "1620219427", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAXIMUM_STEPS 260\n#define DISTANCE_THRESHOLD 0.01\n#define FAR_CLIP 90.0\n\n#define BASE_COLOR vec4(.5, .0, .5, 1)\n#define SPEC_COLOR vec4(0, 1., 0, 1)\n\n\n#define bailout 4.0\n#define iterations 6\n\n// Constants\n#define pi 3.14159265\n\nvoid rX(inout vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    p.y = c * q.y - s * q.z;\n    p.z = s * q.y + c * q.z;\n}\n\nvoid rY(inout vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    p.x = c * q.x + s * q.z;\n    p.z = -s * q.x + c * q.z;\n}\n\nvoid rZ(inout vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    p.x = c * q.x - s * q.y;\n    p.y = s * q.x + c * q.y;\n}\n\nfloat mandelbulb(vec3 pos){\n\tfloat power = float(4.0);\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < iterations; i++){\n\t\tr = length(z);\n\t\tif (r>bailout) break;\n\t\t// Convert to Polar Coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow(r, power-1.0)*power*dr+1.0;\n\t\t// Scale and Rotate the Point\n\t\tfloat zr = pow(r, power);\n\t\ttheta = theta*power + iTime;\n\t\tphi = phi*power + iTime;\n\t\t// Convert Back to Cartesian Coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sphereCopies(vec3 z)\n{\n  vec3 id = fract(z * 1.);\n  z = mod(z,6.);\n  \n  z -= vec3(3.);\n  \n  \n  return mandelbulb(z); // sphere DE\n}\n\nfloat scene(vec3 p){\n    return sphereCopies(p);\n}\n\nfloat nearestSurface(vec3 rp) {\n    rp += vec3(0, 0, 10.);\n    float msd = 9999999.;\n    msd = min(msd, scene(rp)); \n    return msd;\n}\n\nvec4 screenBlend(vec4 a, vec4 b){\n    return 1.-(1.-a)*(1.-b);\n}\n\nvec3 normal(vec3 rp){\n    vec2 e = vec2(0.1,0.);\n    float d = nearestSurface(rp);\n    vec3 n = vec3(\n        d-nearestSurface(rp-e.xyy),\n        d-nearestSurface(rp-e.yxy),\n        d-nearestSurface(rp-e.yyx)\n    );\n    return normalize(n);\n}\n\nvec4 marchRay(vec3 ro, vec3 rd) {\n\n    float d = 10.0; //distance marched\n    vec4 pc = vec4(0.); //pixel colour\n\n    for (int i = 0; i < MAXIMUM_STEPS; ++i) {\n        vec3 rp = ro + rd * d;\n        \n        \n        float ns = nearestSurface(rp);\n        d += ns;\n        \n        if (ns < DISTANCE_THRESHOLD) {\n            vec3 sunPos = vec3(sin(iTime)*-32., 12., cos(iTime)*-32.);\n            vec3 norm = normal(rp);\n            \n            float diffuse = dot(normalize(sunPos), norm);\n            \n            vec3 reflection = reflect(normalize(sunPos), normalize(norm));\n            float specularAngle = max(0.0, dot(reflection, vec3(0,0,1.)));\n            vec4 illuminationSpecular = clamp(pow(specularAngle, 0.01), 0., 0.01) * vec4(1.);\n            \n            vec4 clr = vec4(diffuse) * 0.2;\n            pc = BASE_COLOR + clr + illuminationSpecular;\n            break;\n        }\n        \n        if (d > FAR_CLIP) {\n            break;\n        }\n    }\n\n    return pc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord- .5 * iResolution.xy)/iResolution.y;\n    vec3 rd = normalize(vec3(uv, 2.));\n    rY(rd, iTime* 0.1);\n    vec3 ro = vec3(0, 0, iTime * 10.);\n    \n\tfragColor = marchRay(ro, rd);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dBXWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[237, 237, 269, 269, 389], [391, 391, 423, 423, 544], [546, 546, 578, 578, 698], [700, 700, 727, 727, 1284], [1287, 1287, 1320, 1320, 1348], [1350, 1350, 1378, 1378, 1487], [1489, 1489, 1509, 1509, 1539], [1541, 1541, 1572, 1572, 1675], [1677, 1677, 1710, 1710, 1741], [1743, 1743, 1764, 1764, 1985], [1987, 1987, 2020, 2020, 2968], [2970, 2970, 3027, 3027, 3229]], "test": "valid"}
{"id": "7djSDR", "name": "very expensive smooth min/max", "author": "mds2", "description": "Trying out the very expensive, but very smooth, analogs to the classic blend functions", "tags": ["sdf", "testing", "experiment", "blend", "expensive"], "likes": 5, "viewed": 174, "published": "Public API", "date": "1620051679", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define USE_SQUIRCLES_INSTEAD_OF_BOXES 0\n\n\nfloat wiggle = 0.0; // overwritten in main.  global variable\n\n\nfloat box_sdf(in vec2 pt) {\n  vec2 rel = abs(pt) - vec2(0.5);\n  float out_dist = length(max(rel, vec2(0.0)));\n  float in_dist = max(rel.x, rel.y);\n  return mix(in_dist, out_dist, step(-in_dist, out_dist));\n}\n\nfloat squircle_sdf(in vec2 pt) {\n  vec2 squares = pt * pt;\n  float l = sqrt(sqrt(dot(squares, squares)));\n  return l - 0.5;\n}\n\n/**\n * standard blend func, courtesy IQ\n */\nfloat conventional_smin(in highp float a, in highp float b, in highp float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat super_smooth_max(in highp float a, in highp float b, in highp float k) {\n  // return 0.25 * k * log(exp(4.0 * a / k) + exp(4.0 * b / k));\n  return 0.1732802*k*log2(exp2(5.771*a/k) + exp2(5.771*b/k));\n}\n\nfloat super_smooth_min(in float a, in float b, in float k) {\n  return -super_smooth_max(-a, -b, k);\n}\n\nfloat checked_smooth_min(in highp float a, in highp float b, in highp float k) {\n  float val = conventional_smin(a, b, k);\n  if (abs(val) < 4.0 * k) {\n    return super_smooth_min(a, b, k);\n  }\n  return val;\n}\n\nfloat sdf(in vec2 pt_in) {\n  vec2 pt = pt_in / 200.0;\n  vec2 vals;\n#if USE_SQUIRCLES_INSTEAD_OF_BOXES\n  vals = vec2(squircle_sdf(pt - vec2(0.2, 0.1)), \n              squircle_sdf(pt + vec2(0.75 + wiggle, 0.7))); \n#else\n  vals = vec2(box_sdf(pt - vec2(0.2, 0.1)), \n              box_sdf(pt + vec2(0.75 + wiggle, 0.7))); \n#endif\n\n  if (pt_in.x + 0.5 * iResolution.x > iMouse.x) {\n    return checked_smooth_min(vals.x, vals.y, 0.5);\n  }\n  return conventional_smin(vals.x, vals.y, 0.25);\n}\n\n/** first component is a repeating wave function of distance, for contour lines,\n  * second component determines whether we are inside or outside the shape\n  */\nvec2 contour(in vec2 pt) {\n  float val = sdf(pt);\n  return vec2(cos(20.0 * val) - 1.0, val);\n}\n\n/** first and third component are the gradient of the first component of \"contour\"\n  * second and fourth component are the gradient of the second component of \"countour\"\n  */\nvec4 contour_grad(in vec2 pt) {\n  vec2 f = contour(pt);\n  return 1000.0 * vec4(contour(pt + vec2(0.001, 0.0)) - f,\n                       contour(pt + vec2(0.0, 0.001)) - f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy - 0.5 * iResolution.xy;\n    \n    wiggle = 0.5 * sin(0.5 * iTime);\n    \n    // uv = 5.0 * uv;\n    \n    vec2 val = contour(uv);\n    vec4 grad = contour_grad(uv);\n    \n    val = 0.5 * val / vec2(length(grad.xz), length(grad.yw));\n    val = vec2(1.0) + max(vec2(-1.0), min(vec2(0.0), val));\n\n    // val.y = 1.0 - val.y;\n    \n    vec3 col = val.yxx;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7djSDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 133, 133, 313], [315, 315, 347, 347, 440], [865, 865, 925, 925, 966], [1178, 1178, 1204, 1204, 1663], [1665, 1826, 1852, 1852, 1920], [1922, 2097, 2128, 2128, 2273], [2275, 2275, 2332, 2382, 2812]], "test": "error"}
{"id": "7djSDz", "name": "Cornell Cake", "author": "space928", "description": "Cornell cake.\nFor Thomas' Birthday\n\nForked from: https://www.shadertoy.com/view/4ssGzS", "tags": ["raymarching", "fake", "lighting", "shadows", "antialias", "box", "ao", "cornell"], "likes": 2, "viewed": 109, "published": "Public", "date": "1620064757", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The Cornell Box - @h3r3\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Reproducing the famous Cornell Box through Raymarching, fake soft-shadows,\n// fake indirect lighting, ambient occlusion and antialiasing.\n// Reference data: http://www.graphics.cornell.edu/online/box/\n// Reference image: http://www.graphics.cornell.edu/online/box/box.jpg\n//Modified by Thomas M.\n\n// --- Adapt from GLSL Sandbox\n#define time iTime\n\n// Set ANTIALIAS_ALWAYS to false if the animation is too slow\n#define ANTIALIAS_ALWAYS true\n#define ANTIALIAS_SAMPLES 4\n#define ANIMATE_CAMERA\n\n#define PI 3.14159265359\n#define EXPOSURE 34.\n#define GAMMA 2.1\n#define SOFT_SHADOWS_FACTOR 4.\n#define MAX_RAYMARCH_ITER 128\n#define MAX_RAYMARCH_ITER_SHADOWS 16\n#define MIN_RAYMARCH_DELTA 0.0015\n#define GRADIENT_DELTA 0.0002\n#define OBJ_FLOOR\t\t1.\n#define OBJ_CEILING\t\t2.\n#define OBJ_BACKWALL\t3.\n#define OBJ_LEFTWALL\t4.\n#define OBJ_RIGHTWALL\t5.\n#define OBJ_LIGHT\t\t6.\n#define OBJ_SHORTBLOCK\t7.\n#define OBJ_TALLBLOCK\t8.\n#define OBJ_CAKE_BASE   9.\n#define OBJ_CAKE_ICING  10.\n#define OBJ_CAKE_CANDLE 11.\n#define OBJ_CAKE_FLAME  12.\n\n// RGB wavelengths: 650nm, 510nm, 475nm\nconst vec3 lightColor = vec3(16.86, 8.76 +2., 3.2 + .5);\nconst vec3 lightDiffuseColor = vec3(.78);\nconst vec3 leftWallColor = vec3(.611, .0555, .062);\nconst vec3 rightWallColor = vec3(.117, .4125, .115);\nconst vec3 whiteWallColor = vec3(.7295, .7355, .729);\nconst vec3 cakeBaseColor = vec3(.05, .04, .02);\nconst vec3 cakeIcingColor = vec3(1.5, 1.5, 1.9);\nconst vec3 cakeCandleColor = vec3(0.1, 0.2, 1.3);\nconst vec3 cakeCandleFlameColor = vec3(0.3, .15, 0.05)*0.1;\nconst vec3 cameraTarget = vec3(556, 548.8, 559.2) * .5;\n\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.) + length(max(d, 0.));\n}\n\n//https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdSphere(vec3 p, float r, vec3 scale)\n{\n    return length(p*scale)-r;\n}\n\nfloat distort(float sdf, vec3 p, vec3 x, float period)\n{\n    vec3 dist = sin(p*period)*x;\n    float d = dist.x+dist.y+dist.z;\n    return sdf+d;\n}\n\nvec3 distortV(vec3 p, vec3 x, vec3 period, float phase)\n{\n    vec3 dist = sin(p*period+phase);\n    float d = dist.x+dist.y+dist.z;\n    return p+d*x;\n}\n\nvec3 rotateX(in vec3 p, float a) {\n\tfloat c = cos(a); float s = sin(a);\n\treturn vec3(p.x, c * p.y - s * p.z, s * p.y + c * p.z);\n}\n\nvec3 rotateY(vec3 p, float a) {\n\tfloat c = cos(a); float s = sin(a);\n\treturn vec3(c * p.x + s * p.z, p.y, -s * p.x + c * p.z);\n}\n\nvec3 rotateZ(vec3 p, float a) {\n\tfloat c = cos(a); float s = sin(a);\n\treturn vec3(c * p.x - s * p.y, s * p.x + c * p.y, p.z);\n}\n\nvec2 mapBlocks(vec3 p, vec3 ray_dir) { //  ray_dir may be used for some optimizations\n\tvec2 res = vec2(OBJ_SHORTBLOCK, sdBox(rotateY(p + vec3(-250, -82.5, -169.5), 0.29718), vec3(83.66749, 83.522452, 82.5)));\n\t//vec2 obj1 = vec2(OBJ_TALLBLOCK, sdBox(rotateY(p + vec3(-368.5, -165, -351.5), -0.30072115), vec3(87.02012, 165, 83.6675)));\n\t//if (obj1.y < res.y) res = obj1;\n\treturn res;\n}\n\nvec2 map(vec3 p, vec3 ray_dir) { //  ray_dir may be used for some optimizations\n\tvec2 res = vec2(OBJ_FLOOR, p.y);\n\tvec2 obj1 = vec2(OBJ_CEILING, 548.8 - p.y);\n\tif (obj1.y < res.y) res = obj1;\n\tvec2 obj2 = vec2(OBJ_BACKWALL, 559.2 - p.z);\n\tif (obj2.y < res.y) res = obj2;\n\tvec2 obj3 = vec2(OBJ_LEFTWALL, 556. - p.x);\n\tif (obj3.y < res.y) res = obj3;\n\tvec2 obj4 = vec2(OBJ_RIGHTWALL, p.x);\n\tif (obj4.y < res.y) res = obj4;\n\tvec2 obj5 = vec2(OBJ_LIGHT, sdBox(p + vec3(-278, -548.8, -292+150), vec3(65, 0.05, 65)));\n\tif (obj5.y < res.y) res = obj5;\n\tvec2 obj6 = mapBlocks(p, ray_dir);\n\tif (obj6.y < res.y) res = obj6;\n    \n    vec2 cakeBase = vec2(OBJ_CAKE_BASE, sdRoundedCylinder(p + vec3(-250, -180., -169.5), 30., 10., 20.));\n    if(cakeBase.y < res.y) res = cakeBase;\n    \n    vec2 cakeIcing = vec2(OBJ_CAKE_ICING, \n            sdRoundedCylinder(distortV(p, vec3(0.0,p.y<190.?2.:0.,0.0), vec3(0.3,0.0,0.3), 0.) + vec3(-250, -195., -169.5), 31., 10., 11.));\n            //distort(sdRoundedCylinder(p + vec3(-250, -180., -169.5), 32., 10., 22.),\n            //   p, vec3(.2,0.2,0.2), 0.3));\n    if(cakeIcing.y < res.y) res = cakeIcing;\n  \n    vec2 cakeCandle = vec2(OBJ_CAKE_CANDLE, \n            sdRoundedCylinder(distortV(p, vec3(0.1, 0., 0.1), vec3(1.5,1.5,1.5), 0.) + vec3(-250, -225., -169.5), 1.5, 2., 15.));\n    if(cakeCandle.y < res.y) res = cakeCandle;\n    \n    vec2 cakeCandleFlame = vec2(OBJ_CAKE_FLAME, \n            sdSphere(distortV(p, vec3(0.1, 0.3, 0.1), vec3(1.8,1.0,1.8), iTime*20.) + vec3(-250, -250., -169.5), 2., vec3(1.,.3,1.)));\n    if(cakeCandleFlame.y < res.y) res = cakeCandleFlame;\n    \n\treturn res;\n}\n\nvec2 map(vec3 p) {\n    return map(p, vec3(0,0,0));\n}\n\nvec3 gradientNormal(vec3 p) {\n    return normalize(vec3(\n        map(p + vec3(GRADIENT_DELTA, 0, 0)).y - map(p - vec3(GRADIENT_DELTA, 0, 0)).y,\n        map(p + vec3(0, GRADIENT_DELTA, 0)).y - map(p - vec3(0, GRADIENT_DELTA, 0)).y,\n        map(p + vec3(0, 0, GRADIENT_DELTA)).y - map(p - vec3(0, 0, GRADIENT_DELTA)).y));\n}\n\nfloat raymarch(vec3 ray_start, vec3 ray_dir, out float dist, out vec3 p, out int iterations) {\n    dist = 0.0;\n    float minStep = 0.1;\n\tvec2 mapRes;\n    for (int i = 1; i <= MAX_RAYMARCH_ITER; i++) {\n        p = ray_start + ray_dir * dist;\n        mapRes = map(p, ray_dir);\n        if (mapRes.y < MIN_RAYMARCH_DELTA) {\n           iterations = i;\n           return mapRes.x;\n        }\n        dist += max(mapRes.y, minStep);\n    }\n    return -1.;\n}\n\nbool raymarch_to_light(vec3 ray_start, vec3 ray_dir, float maxDist, float maxY, out float dist, out vec3 p, out int iterations, out float light_intensity) {\n    dist = 0.; \n    float minStep = 1.0;\n    light_intensity = 1.0;\n\tfloat mapDist;\n    for (int i = 1; i <= MAX_RAYMARCH_ITER_SHADOWS; i++) {\n        p = ray_start + ray_dir * dist;\n        mapDist = mapBlocks(p, ray_dir).y;\n        if (mapDist < MIN_RAYMARCH_DELTA) {\n            iterations = i;\n            return true;\n        }\n\t\tlight_intensity = min(light_intensity, SOFT_SHADOWS_FACTOR * mapDist / dist);\n\t\tdist += max(mapDist, minStep);\n        if (dist >= maxDist || p.y > maxY) { break; }\n    }\n    return false;\n}\n\nvec3 interpolateNormals(vec3 v0, vec3 v1, float x) {\n\tx = smoothstep(0., 1., x);\n\treturn normalize(vec3(mix(v0.x, v1.x, x),\n\t\tmix(v0.y, v1.y, x),\n\t\tmix(v0.z, v1.z, x)));\n}\n\nfloat ambientOcclusion(vec3 p, vec3 n) {\n    float step = 20.;\n    float ao = 0.;\n    float dist;\n    for (int i = 1; i <= 3; i++) {\n        dist = step * float(i);\n\t\tao += max(0., (dist - map(p + n * dist).y) / dist);  \n    }\n    return 1. - ao * 0.12;\n}\n\nvec3 render(vec3 ray_start, vec3 ray_dir) {\n\tfloat dist; vec3 p; int iterations;\n\tfloat objectID = raymarch(ray_start, ray_dir, dist, p, iterations);\n\t\n\tvec3 color = vec3(0);\n\tif (p.z >= 0.) {\n\t\tif (objectID == OBJ_FLOOR) color = whiteWallColor;\n\t\telse if (objectID == OBJ_CEILING) color = whiteWallColor;\n\t\telse if (objectID == OBJ_BACKWALL) color = whiteWallColor;\n\t\telse if (objectID == OBJ_LEFTWALL) color = leftWallColor;\n\t\telse if (objectID == OBJ_RIGHTWALL) color = rightWallColor;\n\t\telse if (objectID == OBJ_LIGHT) color = lightDiffuseColor;\n\t\telse if (objectID == OBJ_SHORTBLOCK) color = whiteWallColor;\n\t\telse if (objectID == OBJ_TALLBLOCK) color = whiteWallColor;\n        else if (objectID == OBJ_CAKE_BASE) color = cakeBaseColor;\n        else if (objectID == OBJ_CAKE_ICING) color = cakeIcingColor;\n        else if (objectID == OBJ_CAKE_CANDLE) color = cakeCandleColor;\n\t\telse if (objectID == OBJ_CAKE_FLAME) color = cakeCandleFlameColor;\n        \n\t\tif (objectID == OBJ_LIGHT || objectID == OBJ_CAKE_FLAME) {\n\t\t\tcolor *= lightColor;\n\t\t} else {\n\t\t\tfloat lightSize = 25.;\n\t\t\tvec3 lightPos = vec3(278, 548.8 -50., 292 - 250);\n\t\t\tif (objectID == OBJ_CEILING) { lightPos.y -= 550.; }\n\t\t\t\n\t\t\tlightPos.x = max(lightPos.x - lightSize, min(lightPos.x + lightSize, p.x));\n\t\t\tlightPos.y = max(lightPos.y - lightSize, min(lightPos.y + lightSize, p.y));\n\t\t\tvec3 n = gradientNormal(p);\n\t\t\t\n\t\t\tvec3 l = normalize(lightPos - p);\n\t\t\tfloat lightDistance = length(lightPos - p);\n\t\t\tfloat atten = ((1. / lightDistance) * .5) + ((1. / (lightDistance * lightDistance)) * .5);\n\t\t\t\n\t\t\tvec3 lightPos_shadows = lightPos + vec3(0, 140, -50);\n\t\t\tvec3 l_shadows = normalize(lightPos_shadows - p);\n\t\t\tfloat dist; vec3 op; int iterations; float l_intensity;\n\t\t\tbool res = raymarch_to_light(p + n * .11, l_shadows, lightDistance, 400., dist, op, iterations, l_intensity);\n\t\t\t\n\t\t\tif (res && objectID != OBJ_CEILING) l_intensity = 0.;\n\t\t\tl_intensity = max(l_intensity,.25);\n\t\t\tvec3 c1 = color * max(0., dot(n, l)) * lightColor * l_intensity * atten;\n\t\t\t\n\t\t\t// Indirect lighting\n\t\t\tvec3 c2_lightColor = lightColor * rightWallColor * .08;\n\t\t\tfloat c2_lightDistance = p.x + 0.00001;\n\t\t\tfloat c2_atten = 1. / c2_lightDistance;\n\t\t\tvec3 c2_lightDir0 = vec3(-1,0,0);\n\t\t\tvec3 c2_lightDir1 = normalize(vec3(-300., 548.8/2.,559.2/2.) - p);\n\t\t\tfloat c2_perc = min(p.x * .01, 1.);\n\t\t\tvec3 c2_lightDirection = interpolateNormals(c2_lightDir0, c2_lightDir1, c2_perc);\n\t\t\tvec3 c2 = color * max(0., dot(n, c2_lightDirection)) * c2_lightColor * c2_atten;\n\t\t\t\n\t\t\tvec3 c3_lightColor = lightColor * leftWallColor * .08;\n\t\t\tfloat c3_lightDistance = 556. - p.x + 0.1;\n\t\t\tfloat c3_atten = 1. / c3_lightDistance;\n\t\t\tvec3 c3_lightDir0 = vec3(1,0,0);\n\t\t\tvec3 c3_lightDir1 = normalize(vec3(556. + 300., 548.8/2.,559.2/2.) - p);\n\t\t\tfloat c3_perc = min((556. - p.x) * .01, 1.);\n\t\t\tvec3 c3_lightDirection = interpolateNormals(c3_lightDir0, c3_lightDir1, c3_perc);\n\t\t\tvec3 c3 = color * max(0., dot(n, c3_lightDirection)) * c3_lightColor * c3_atten;\n\t\t\t\n\t\t\tcolor = color * .0006 + c1;\n\t\t\tcolor += c2 + c3; // Fake indirect lighting\n\t\t\t\n\t\t\t// Ambient occlusion\n\t\t\tfloat ao = ambientOcclusion(p, n);\n\t\t\tcolor *= ao;\n\t\t}\n\t}\n\treturn color;\n}\n\nvec3 rotateCamera(vec3 ray_start, vec3 ray_dir) {\n\tray_dir.x = -ray_dir.x; // Flip the x coordinate to match the scene data\n\tvec3 target = normalize(cameraTarget - ray_start);\n\tfloat angY = atan(target.z, target.x);\n\tray_dir = rotateY(ray_dir, PI/2. - angY);\n\tfloat angX = atan(target.y, target.z);\n\tray_dir = rotateX(ray_dir, - angX);\n\t#ifdef ANIMATE_CAMERA\n\t\tfloat angZ = smoothstep(0., 1., (time - 5.) * .1) * sin(time * 1.1 + .77) * .05;\n\t\tray_dir = rotateZ(ray_dir, angZ);\n\t#endif\n\treturn ray_dir;\n}\n\nvec3 moveCamera(vec3 ray_start) {\n\tray_start += vec3(278, 273, -400);\n\t#ifdef ANIMATE_CAMERA\n\t\tvec3 ray_start_a = ray_start\n\t\t\t+ vec3(cos(time * 0.8) * 140., cos(time * 0.9) * 140., (cos(time * .3) + 1.) * 190.);\n\t\treturn mix(ray_start, ray_start_a, smoothstep(0., 1., (time - 5.) * .1));\n\t#else\n\t\treturn ray_start;\n\t#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 resolution = iResolution.xy;\n    vec2 mouse = min(iMouse.xy / iResolution.xy, vec2(1));\n\n    \n\tvec3 ray_start = vec3(0, 0, -1.4);\n\tvec3 color = vec3(0);\n\tif (ANTIALIAS_ALWAYS || time < 5.) {\n\t\t// ANTIALIAS\n\t\tfloat d_ang = 2.*PI / float(ANTIALIAS_SAMPLES);\n\t\tfloat ang = d_ang * .333;\n\t\tfloat r = .4;\n\t\tfor (int i = 0; i < ANTIALIAS_SAMPLES; i++) {\n\t\t\tvec2 position = vec2((fragCoord.x + cos(ang)*r - resolution.x *.5) / resolution.y, (fragCoord.y + sin(ang)*r - resolution.y *.5) / resolution.y);\n\t\t\tvec3 ray_s = moveCamera(ray_start);\n\t\t\tvec3 ray_dir = rotateCamera(ray_s,normalize(vec3(position, 0) - ray_start));\n\t\t\tcolor += render(ray_s, ray_dir);\n\t\t\tang += d_ang;\n\t\t}\n\t\tcolor /= float(ANTIALIAS_SAMPLES);\n\t} else {\n\t\t// NO ANTIALIAS\n\t\tvec2 position = vec2((fragCoord.x - resolution.x *.5) / resolution.y, (fragCoord.y - resolution.y *.5) / resolution.y);\n\t\tvec3 ray_s = moveCamera(ray_start);\n\t\tvec3 ray_dir = rotateCamera(ray_s, normalize(vec3(position, 0) - ray_start));\n\t\tcolor += render(ray_s, ray_dir);\n\t}\n\t\n\tcolor *= EXPOSURE;\n\tcolor = pow(color, vec3(1. / GAMMA));\n    fragColor = vec4(color, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7djSDz.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1704, 1704, 1733, 1733, 1820], [1822, 1896, 1960, 1960, 2077], [2079, 2079, 2124, 2124, 2156], [2158, 2158, 2214, 2214, 2303], [2305, 2305, 2362, 2362, 2455], [2457, 2457, 2491, 2491, 2587], [2589, 2589, 2620, 2620, 2717], [2719, 2719, 2750, 2750, 2846], [2848, 2848, 2886, 2933, 3233], [3235, 3235, 3267, 3314, 4859], [4861, 4861, 4879, 4879, 4913], [4915, 4915, 4944, 4944, 5236], [5238, 5238, 5332, 5332, 5686], [5688, 5688, 5844, 5844, 6370], [6372, 6372, 6424, 6424, 6543], [6545, 6545, 6585, 6585, 6800], [6802, 6802, 6845, 6845, 9985], [9987, 9987, 10036, 10036, 10491], [10493, 10493, 10526, 10526, 10818], [10820, 10820, 10877, 10877, 11997]], "test": "valid"}
{"id": "7djSWz", "name": "Triangle_rgb", "author": "fantasour", "description": "triangle", "tags": ["triangle"], "likes": 3, "viewed": 62, "published": "Public", "date": "1620057473", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 barycenter(in vec3 v0, in vec3 v1, in vec3 v2, in vec3 p, in vec3 normal)\n{\n  float area = dot(cross(v1 - v0, v2 - v0), normal);\n\n  if(abs(area) < 0.0001)\n  {\n    return vec3(0.0, 0.0, 0.0);\n  }\n\n  vec3 pv0 = v0 - p;\n  vec3 pv1 = v1 - p;\n  vec3 pv2 = v2 - p;\n\n  vec3 asub = vec3\n  (  dot(cross(pv1, pv2), normal),\n    dot(cross(pv2, pv0), normal),\n    dot(cross(pv0, pv1), normal)\n  );\n  return abs(asub) / vec3(abs(area)).xxx;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 aspect = vec2(iResolution.x / iResolution.y, 1.333);\n  float t = iTime;\n\n    vec3 v0 = vec3(0.0, 0.333, 0.0);\n  vec3 v1 = vec3(0.333, -0.333, 0.0);\n  vec3 v2 = vec3(-0.333, -0.333, 0.0);\n  const vec3 normal = vec3(0.0, 0.0, 1.0);\n\n  vec2 uv = (2.0 * fragCoord.xy / iResolution.xy - 1.0) * aspect;\n\n  vec3 bc = barycenter(v0, v1, v2, vec3(uv, 0.0), normal);\n\n  vec3 color = bc;\n\n  if(bc.x + bc.y + bc.z > 1.00001) // outside of triangle\n  {\n    color = vec3(0.08, 0.1, 0.1);\n  }\n  else                  // inside of triangle\n  {\n    color.r+=color.g*(sin(t)+1.0)/2.0;\n      color.g+=color.b*(sin(t+0.9424778)+1.0)/2.0;\n      color.b+=color.r*(sin(t+1.8849556)+1.0)/2.0;\n  }\n\n  fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7djSWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 80, 80, 434], [436, 436, 493, 493, 1208]], "test": "valid"}
{"id": "7djSzK", "name": "Distance to Sine (three iters!)", "author": "oneshade", "description": "How good does it get?", "tags": ["2d", "sdf", "fast", "sine", "distance"], "likes": 8, "viewed": 153, "published": "Public", "date": "1620623136", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// See: https://www.desmos.com/calculator/hvqys18zux\n// f: frequency\n// a: amplitude\nfloat sdSine(in vec2 p, in float f, in float a) {\n    f *= 3.14159265359 * a, p /= a; // Modify to handle varying amplitude\n    float r = 3.14159265359 / f, h = 0.5 * r, ff = f * f;\n    p = vec2(mod(p.x + h, r) - h, p.y * sign(r - mod(p.x + h, 2.0 * r))); // Remap\n\n    // Get closest on linear approximation\n    float t = clamp((0.818309886184 * f * p.y + p.x) / (0.669631069826 * ff + 1.0), -h, h);\n\n    // Three iterations of Newton-Raphson\n    for (int n=0; n < 3; n++) {\n        float k = t * f, c = cos(k), s = sin(k);\n        t -= ((s - p.y) * c * f + t - p.x) / ((c * c - s * s + s * p.y) * ff + 1.0);\n    }\n\n    return length(p - vec2(t, sin(t * f))) * a;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float unit = 2.0 / iResolution.y;\n\n    float f = mix(0.125, 8.0, 0.5 + 0.5 * sin(iTime));\n    float a = 0.25 + 0.125 * cos(iTime);\n    float d = sdSine(uv, f, a) * 2.0; // Shrink isolines\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(d) * vec3(0.1, 0.4, 0.7);\n\tcolor *= 1.0 - exp(-4.0 * abs(d));\n\tcolor *= 0.8 + 0.2 * cos(140.0 * d);\n\tcolor = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, abs(d) * 0.8));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7djSzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 85, 134, 134, 751], [753, 753, 808, 808, 1335]], "test": "valid"}
{"id": "7djXRm", "name": "Cuboid Artifact", "author": "Drakyen", "description": "Collab with @Tater - he likes doing geometry, I like doing lighting, so we combined our skills and made this :>", "tags": ["3d", "raymarching", "fractal", "collab"], "likes": 12, "viewed": 137, "published": "Public", "date": "1619951204", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"Cuboid Artifact\" by Tater. https://shadertoy.com/view/Nd2SRw\n// 2021-05-02 10:25:29\n\n#define STEPS 256.0\n#define MDIST 250.0\n#define pi 3.1415926535\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define pmod(p, x) (mod(p,x)-0.5*(x))\nfloat glow = 0.0;\n\n//Geometry by Tater\n//----------------------------------------------------------------\n\nfloat box(vec3 p, vec3 s){\n    vec3 d = abs(p)-s;\n    return max(d.x,max(d.y,d.z));\n}\n\nfloat frame(vec3 p, vec3 s, float e){\n    vec2 h = vec2(e,0);\n    float a = box(p,s);\n    float b = box(p,s*1.01-h.xxy);\n    a = max(-b,a);\n    b = box(p,s*1.01-h.xyx);\n    a = max(-b,a);\n    b = box(p,s*1.01-h.yxx);\n    a = max(-b,a);\nreturn a;\n}\n\nfloat timeRemap (float t,float s1, float s2, float c){\n    return 0.5*(s2-s1)*(t-asin(cos(t*pi)/sqrt(c*c+1.0))/pi)+s1*t;  \n}\n\nvoid mo(inout vec2 p){\n  if(p.y>p.x) p = p.yx;\n}\n\nvec2 map(vec3 p){\n    vec3 po2 = p;\n    \n    p.xz*=rot(iTime*0.8);\n    p.xy*=rot(iTime*0.4);\n    vec3 po = p;\n    float t = iTime*0.7;\n    \n    t = timeRemap(t*1.3, 0., 2.3, 0.1);\n    \n    \n    for(float i = 0.0; i< 9.0; i++){\n        p = abs(p)-2.0*i*(vec3(0.35*asin(sin(t*0.15)),0.2*asin(sin(t*0.22)),0.3*asin(sin(t*0.38))));\n        p.xz*=rot(pi/2.0);\n        mo(p.xy);//credit to FMS_CAT for this technique, I still have no idea how he makes it look so good\n        mo(p.zy);\n    }\n    \n    //Inner Cubes\n    p = pmod(p,2.2);\n    vec2 a = vec2(box(p,vec3(0.5)),1.0);\n    a.x = abs(a.x)-0.2;\n    a.x = abs(a.x)-0.1;\n    //Inner Inner glowy Cubes\n    vec2 b = vec2(box(p,vec3(0.45)),2.0);\n    glow+=0.01/(0.01+b.x*b.x);\n    a = (a.x<b.x)?a:b;\n    \n    p = po;\n    p.xy*=rot(pi/4.0);\n    \n    //Boundry Cut Cube\n    vec3 cube = vec3(4,4,4)*vec3(1.2+0.5*sin(t),1.2+0.5*cos(t),1.2+0.5*sin(t));\n    a.x = max(box(p,cube),a.x);\n    //Outer Frame\n    b= vec2(frame(p,cube+0.15,0.45),3.0);\n    a = (a.x<b.x)?a:b;\n    \n    //Repeating Poles\n    po2.y-=iTime*20.0;\n    po2=mod(po2,80.0)-40.0;\n    b.x = length(po2.xz)-2.0;\n    b.x = min(b.x,length(po2.zy)-2.0);\n    b.x = min(b.x,length(po2.xy)-2.0);\n    b.y=4.0;\n    a = (a.x<b.x)?a:b;\n    \n    return a;\n}\n\n\n//----------------------------------------------------------\n\n\n#define ZERO (min(iFrame,0))\nvec3 norm(vec3 p){\n    \n#if 0    \n    vec2 e= vec2(0.01,0);\n\n    vec2 h = vec2(1.0,-1.0)*0.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n                      h.yyx*map( p + h.yyx*e ).x + \n                      h.yxy*map( p + h.yxy*e ).x + \n                      h.xxx*map( p + h.xxx*e ).x );\n#else    \n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*0.001).x;\n    }\n    return normalize(n);\n#endif  \n}\n\n\n//Lighting & modified tracing by Drake (me)\n//----------------------------------------------------------------------------\nvec3 tr(vec3 ro, vec3 rd)\n{\n    vec3 p = ro;\n    float shad = 0.0;\n    vec2 d = vec2(0);\n    \n    for(float i = 0.0; i < STEPS; i++){\n        vec2 s = map(p);\n        d.x += s.x*0.8;d.y=s.y;\n        p = ro+rd*d.x;\n        if(abs(s.x)<0.001||i==STEPS-1.0 ){\n            shad = i/STEPS;\n            break;\n        }\n        if(d.x>MDIST){ break;d.x=MDIST;d.y=0.;};\n    }\n    return vec3(d.x,d.y,shad);\n}\n\nvec3 lit(vec3 p, vec3 h, vec3 rd, vec3 al, vec3 n)\n{\n    vec3 fo = vec3(sin(iTime/10.)*0.5+0.5,cos(iTime/5.)*0.5+0.5,sin(iTime/5.)*0.5+0.5) * 0.1;\n    vec3 col = fo;\n    vec3 sss = vec3(0.5)*smoothstep(0.,1.,map(p+-rd*0.2).x/0.2);\n    float fom = clamp(h.x/MDIST,0.0,1.0);\n    float ffom =fom;\n    \n    //sneaky way to simplify lighting - i use -rd as the light direction, which\n    //makes it as if there's a point light at the camera position, and also makes\n    //fresnel a very simple calculation (essentially just the inverse of the diffuse)\n    float diffs = dot(n, -rd);\n    float diff = max(diffs,0.);\n    float fres = pow(1. - abs(diffs),4.);\n    float spec = pow(max(dot(reflect(-rd,n),rd),0.2),20.)*2.;\n\n    //this is a little bit wacky but works\n    if(h.y==4.){spec = 0.;fres=0.;ffom=0.;diff=0.;}\n    \n    //Definitely not using SSS as intended, but hey, it looks good!\n    col = mix(al * (fres + spec + diff/14.), diff * sss - h.z, ffom);\n    col = mix(col,fo,pow(fom,3.));\n    return col*3.;\n}\n\n//-------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    vec3 al = vec3(0);\n    //maybe a bit overkill to have a full camera \n    vec3 ro = vec3(0,2,-20);\n    ro.xz*=rot(iTime*0.2);\n    vec3 lk = vec3(0,0,0);\n    vec3 f = normalize(lk-ro);\n    vec3 r = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = f+uv.x*r+uv.y*cross(f,r);\n    \n    vec3 d = tr(ro,rd);\n    vec3 p = ro+rd*d.x;\n\n    if(d.y==1.0) al = vec3(0.945,0.027,0.027);\n    if(d.y==2.0) al = vec3(0.741,0.059,1.000);\n    if(d.y==3.0) al = vec3(0.000,0.000,0.000);\n    if(d.y==4.0) al = vec3(0.839,0.812,0.780);\n    \n    //More lighting bits\n    vec2 e = vec2(0.01,0);\n    vec3 n = norm(p);\n    vec3 od = d;\n    vec3 op = p;\n    col = lit(p,d,rd,al,n);    \n    vec3 refld = reflect(rd,n);\n    d = tr(p + n*0.01,refld);\n    p = p+refld*d.x;\n    n = norm(p);\n    vec3 refl = lit(p,d,rd,al,n);\n    if(d.y<4.&&d.y>0.&&od.y>0.&&od.y<4.) col = mix(col,refl,0.5);\n    if(d.y>0.&&od.y<3.&&d.y<3.)col+=glow*0.03*vec3(0.741,0.059,1.000);    \n    //----------------\n\n       \n    col = pow(col,vec3(0.75));//Gamma correction\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7djXRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[356, 356, 382, 382, 441], [443, 443, 480, 480, 690], [692, 692, 746, 746, 816], [818, 818, 840, 840, 866], [868, 868, 885, 885, 2118], [2213, 2213, 2231, 2231, 2835], [2838, 2961, 2988, 2988, 3362], [3364, 3364, 3416, 3416, 4372], [4445, 4445, 4502, 4502, 5635]], "test": "valid"}
{"id": "7djXWw", "name": "Draw an arbitrary line", "author": "kass", "description": "draw line\nrotate : click", "tags": ["3d"], "likes": 1, "viewed": 104, "published": "Public", "date": "1620407472", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float DistLine(vec3 ro, vec3 rd, vec3 p) {\n\treturn length(cross(p-ro, rd))/length(rd);\n}\n\nfloat DrawPoint(vec3 ro, vec3 rd, vec3 p) {\n\tfloat d = DistLine(ro, rd, p);\n    d = smoothstep(.06, .05, d);\n    return d;\n}\n\nfloat DistLines(vec3 ro, vec3 rd, vec3 a1, vec3 a2){\n    vec3 m1 = rd;\n    vec3 m2 = a2-a1;\n    \n    float A = length(cross(m1, m2));\n    float B = dot(ro - a1, cross(m1 ,m2));\n    float d = B/A;\n    \n    return abs(d);\n}\n\nfloat DrawLine(vec3 ro, vec3 rd, vec3 p1, vec3 p2) {\n    float d = DistLines(ro,rd,p1,p2); \n    return d = smoothstep(.01, .0, length(d));\n}\n\nfloat DistPlane(vec3 ro, vec3 rd, vec3 n, float h){\n    vec3 c = ro + (h - dot(n,ro))/dot(rd,n) * rd; \n    return length(ro-c);\n}\n\nfloat DistPlaneXZ(vec3 ro, vec3 rd, vec3 n, float h){\n    vec3 c = ro + (h - dot(n,ro))/dot(rd,n) * rd; \n    return length(ro.xz-c.xz);\n}\n\nvec3 Intersection(vec3 ro, vec3 rd, vec3 n, float h){\n    vec3 c = ro + (h - dot(n,ro))/dot(rd,n) * rd; \n    return c;\n}\n\nfloat DrawPlane(vec3 ro, vec3 rd, vec3 n, float h){\n    float d = DistPlane(ro ,rd, n, h);\n    return pow((1.0-max(1.,d)*0.14),2.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t = iTime;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy; // 0 <> 1\n    uv -= .5;\n    \n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(0.5 + 3.*sin(-iMouse.x*0.03), (6.0-iMouse.y*0.03), 0.5 + -3.*cos(-iMouse.x*0.03));\n    vec3 lookat = vec3(.5);\n    float zoom = 1.0;\n    \n    vec3 f = normalize(lookat-ro);\n    vec3 r = cross(vec3(0., 1., 0.), f);\n    vec3 u = cross(f, r);\n    \n    vec3 c = ro + f*zoom;\n    vec3 i = c + uv.x*r + uv.y*u;\n    vec3 rd = i-ro;\n    \n    float d = 0.;\n    float red = 0.;\n    float green = 0.;\n    float blue = 0.;\n    \n    float light = DistPlaneXZ(ro, rd, vec3(0., 1., 0.), 0.);\n    vec3 inte = Intersection(ro, rd, vec3(0., 1., 0.), 0. );\n    vec4 pic = texture(iChannel0,inte.xz);\n    \n    d += DrawPoint(ro, rd, vec3(0., 0., 0.));\n    d += DrawPoint(ro, rd, vec3(0., 0., 1.));\n    d += DrawPoint(ro, rd, vec3(0., 1., 0.));\n    d += DrawPoint(ro, rd, vec3(0., 1., 1.));\n    d += DrawPoint(ro, rd, vec3(1., 0., 0.));\n    d += DrawPoint(ro, rd, vec3(1., 0., 1.));\n    d += DrawPoint(ro, rd, vec3(1., 1., 0.));\n    d += DrawPoint(ro, rd, vec3(1., 1., 1.));\n    \n    red += DrawLine(ro, rd, vec3(0., 0., 0.), vec3(1.,0.,0.));\n    green += DrawLine(ro, rd, vec3(0., 0., 0.), vec3(0.,0.,1.));\n    blue += DrawLine(ro, rd, vec3(0., 0., 0.), vec3(0.,1.,0.));\n    \n    red += DrawLine(ro, rd, vec3(0.5, 1.0, 0.5), vec3(0.5 + 0.74*cos(t),0.0,0.5 + 0.74*sin(t)));\n    red += DrawPoint(ro, rd, vec3(0.5 + 0.74*cos(t),0.0,0.5 + 0.74*sin(t)));\n\n\n\tfragColor = vec4(red,green,blue,0.) + d  + vec4(pic.xyz,1.0)*1./light;\n}", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7djXWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 42, 42, 88], [90, 90, 133, 133, 214], [216, 216, 268, 268, 437], [439, 439, 491, 491, 579], [581, 581, 632, 632, 710], [712, 712, 765, 765, 849], [851, 851, 904, 904, 971], [973, 973, 1024, 1024, 1107], [1110, 1110, 1167, 1167, 2735]], "test": "error"}
{"id": "7dlSD2", "name": "koch fractal", "author": "noodlechop", "description": "learning to draw koch fractals", "tags": ["fractal", "koch"], "likes": 5, "viewed": 42, "published": "Public", "date": "1621895896", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define M_PI 3.14159265359\n\nfloat segment(vec2 p, vec2 a, vec2 b){\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp(dot(pa, ba)/dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba*h);\n}\n\n\nvec3 mirror(vec2 p, vec2 n, vec2 o){\n    float d = dot(p + o, n);\n    return vec3(p-2.0*n*min(0.0, d), d);\n}\n\nvec3 mirror(vec2 p, vec2 n){\n    return mirror(p, n, vec2(0.0));\n}\n\nvec2 N(float ang){\n    return vec2(sin(ang), cos(ang));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec2 uv_orig = uv;\n    vec2 mouse = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n    \n    // Time varying pixel color\n    float t = 2.0/iResolution.y;\n    float scale = 0.25*cos(iTime*1.23456789) + 1.0;\n    scale *= 0.75;\n\n    vec2 n1 = N(sin(-iTime/51.0)*2.0*M_PI);\n    float ang = sin(0.05337*iTime+mouse.x)*2.0*M_PI/3.0;\n    vec2 n2 = N(ang);\n    \n    vec2 n3 = N(0.01234*iTime);\n    uv -= 2.0*n3*dot(n3, uv);\n    \n    uv *= 1.25*scale;\n    uv += 0.25*N(0.1759*iTime);\n    uv.y -= 0.5*tan(M_PI/6.0);\n    uv = mirror(uv, -n1).xy;\n    vec3 uvd = mirror(uv, N(M_PI/6.0), vec2(0.5, 0.0));\n    uv = uvd.xy;\n    float l = smoothstep(2.0*t, 0.0, abs(uvd.z));\n    \n    \n    \n    uv.x += 0.5;\n    float s0 = scale;\n    for (int i=0; i<8; i++){ \n        uv *= 3.0;\n        uv.x -= 1.5;\n        uv = mirror(uv, n1).xy;\n        uv.x -= 0.5;\n        uv = mirror(uv, n2).xy;\n        \n        scale *= 3.0;\n    }    \n    \n    \n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx*16.0/(0.5*scale+ scale*pow(cos(0.14142*iTime),2.0))+vec3(0,2,4));\n    //col += smoothstep(t, 0.0, segment(uv_orig, vec2(0.0,0.0), n));\n    //col += smoothstep(2.0*t, 0.0, segment(uv, vec2(210.0,21.0), vec2(-210.0,-21.0)));\n    //col += smoothstep(t, 0.0, segment(uv, vec2(1.0,0.0), vec2(1.0,1.0)));\n    //col += smoothstep(t, 0.0, segment(uv, vec2(-1.0,0.0), vec2(1.0,0.0))/scale);\n    for (float j=-10.0; j<10.0; j+= 0.05){\n        col += smoothstep(t, 0.0, segment(uv, vec2(-100.0,j), vec2(100.0,j))/scale);\n    }\n    col+=l;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dlSD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 67, 67, 197], [200, 200, 236, 236, 308], [310, 310, 338, 338, 376], [378, 378, 396, 396, 435], [438, 438, 495, 545, 2157]], "test": "valid"}
{"id": "7dSSDw", "name": "Random TV", "author": "Dutracgi", "description": "Uint32 Pseudorandom generator example!", "tags": ["noise", "tv", "tv", "random", "static", "pseudorandom"], "likes": 1, "viewed": 136, "published": "Public API", "date": "1620334543", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Generator from:\n// https://www.cs.ubc.ca/labs/imager/tr/2008/SchechterTurbulenceSCA08/schechter_turbulence_sca08.pdf\nuint hash(uint s){\n\ts = s ^2747636419u;\n    s *= 2654435769u;\n\ts = s ^ 65536u;\n    s *= 2654435769u;\n\ts = s ^ 65536u;\n    s *= 2654435769u;\n\treturn s;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    uint sx = uint(int(uv.x*iResolution.x+iTime*3600.0));\n    uint sy = uint(int(uv.y*iResolution.y+iTime*6400.0));\n    \n    float c = float(hash(sy*sx)/32u);\n    \n    vec3 col = vec3(c*16.0/2147483647.0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dSSDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 120, 138, 138, 272], [273, 273, 330, 380, 717]], "test": "valid"}
{"id": "7dSXDm", "name": "Fractal maze", "author": "jarble", "description": "A never-ending maze of zig-zagging walls.", "tags": ["fractal", "maze"], "likes": 2, "viewed": 144, "published": "Public API", "date": "1620353358", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//change this constant to get different patterns\n#define c1 vec4(2.0,2.5,1.4,0)\n\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+c1.xy)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col;  \n    float t1 = 4.0;\n    float offset = .18;\n    float scale2 = 1.05;\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    for(int c=0;c<3;c++){\n        float scale = c1.z;\n        for(int i=0;i<9;i++)\n        {\n          \n            uv = triangle_wave(uv+offset,scale)+triangle_wave(uv.yx,scale);\n            uv.x /= -1.0;\n            uv = triangle_wave(uv+c1.w+col.xy,scale);\n            scale /= scale2+col.x;\n            offset *= scale2;\n            //uv.y /= -1.0;\n            uv = uv.yx;\n            //uv = uv.yx;\n\n        }\n     col[c] = fract((uv.x)-(uv.y));\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dSXDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[82, 82, 121, 121, 166], [168, 168, 225, 225, 946]], "test": "valid"}
{"id": "7dSXRK", "name": "Blob-Circles v2", "author": "SteenLund", "description": "Improved version of Blob-Circles", "tags": ["sdf"], "likes": 4, "viewed": 62, "published": "Public", "date": "1620588124", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circle(vec2 samplePosition, vec2 offset, float radius)\n{\n    return length(samplePosition - offset) - radius;\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = max(k -abs(a-b), 0.0) / k;\n    return min(a, b) - h*h*k*0.25;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord - .5 * iResolution.xy ) / iResolution.y;\n\n    float radius = 0.1;\n    float c1  = circle(uv, vec2(0.2*sin(iTime), 0.2*cos(iTime)), radius);     \n    float c2 = circle(uv, vec2(-0.2 + 0.1*cos(iTime*1.5), 0.2 + 0.1*sin(iTime)), radius);     \n    float c3 = circle(uv, vec2(0.25*sin(iTime*1.55 + 2.), 0.25*cos(iTime + 5.)), radius);     \n    float c4 = circle(uv, vec2(0.4*sin(iTime*1.2 + 10.), 0.2*cos(iTime*0.5)), radius);     \n    \n    float k = .0675;\n    float dist = smin(c1, c2, k);\n    dist = smin(dist, c3, k);\n    dist = smin(dist, c4, k);\n\n\n    //my original math\n    //float edgeSize = 0.0015;\n    //vec3 col = vec3(1.) - (vec3(smoothstep(0., edgeSize, dist)) + vec3(smoothstep(0., edgeSize, -dist)));\n\n    //Rules of smooth from @FabriceNeyret2\n    //1-smooth(a,b) = smooth(b,a)\n    //smooth-smooth = smooth(abs)\n \n    //fragColor = vec4(smoothstep( 1.0, 0., abs(dist) ) );\n\n    //@FabriceNeyret2\n    //Antialiasing: magick small number can't work for all scales.\n    //use true pixel width 1.5/ires.y\n    //more accurate auto-adaptable pixel width:\n    //smoothstep( 1.5, 0., abs(dist)/fwidth(dist)\n\n    // Time varying pixel color\n    vec3 lineCol = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 col = vec3(smoothstep( 1.5, 0., abs(dist)/fwidth(dist))) * lineCol;\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dSXRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 62, 62, 117], [119, 119, 158, 158, 236], [238, 238, 295, 295, 1660]], "test": "valid"}
{"id": "7dsXRX", "name": "Triangle pattern", "author": "Eyemm", "description": "Testing an idea I've had on paper. Funny how the empty spaces become hexagons during the transition.", "tags": ["trianglepattern"], "likes": 8, "viewed": 69, "published": "Public", "date": "1620471733", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float s32 = sqrt(3.)/2.;\n\nfloat lineDistance(in vec2 p, in vec2 a, in vec2 b)\n{\n    vec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.);\t\n\treturn length(pa - ba * h);\n}\n\nbool rightSide(in vec2 p, in vec2 a, in vec2 b)\n{\n    return (p.x-a.x)*(b.y-a.y)-(p.y-a.y)*(b.x-a.x) > 0.;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float t = ( (1.-cos(2.*iTime)) )/2.;\n    \n    // 4. factor so we see more triangles in the viewport.\n    // 0.2*iTime for the diagonal drift\n    vec2 uv = 4.*(fragCoord-iResolution.xy/2.)/iResolution.y + 0.2*iTime;\n    \n    // Tile vertically~diagonally along a triangle edge:\n    // uv.y/s32 is the V coordinate in a UV frame shaped like /_\n    uv -= floor(uv.y/s32)*vec2(0.5, s32);\n    // And tile by 1 horizontally\n    uv.x = uv.x - floor(uv.x);\n    \n    // Look at the three triangle edges individually.\n    // Here's the horizontal _ one that becomes / when t==1\n    vec2 orig = vec2(0., 0.);\n    vec2 end = t*vec2(0.5, s32) + vec2(1.-t, 0.);\n    \n    // Distance to the line, and are we on its right side\n    float dist1 = lineDistance(uv, orig, end);\n    bool right1 = rightSide(uv, orig, end);\n \n    // Transform uv into the second edge's local frame\n    vec2 uv2 = uv - vec2(1.0, 0.0);\n    uv2 = vec2(-0.5*uv2.x + s32*uv2.y, -s32*uv2.x - 0.5*uv2.y);\n    // Then same computation\n    float dist2 = lineDistance(uv2, orig, end);\n    bool right2 = rightSide(uv2, orig, end);\n\n    // Transform into the third edge's frame\n    vec2 uv3 = uv - vec2(0.5, s32);\n    uv3 = vec2(-0.5*uv3.x - s32*uv3.y, s32*uv3.x - 0.5*uv3.y);\n    // And again\n    float dist3 = lineDistance(uv3, orig, end);\n    bool right3 = rightSide(uv3, orig, end);\n \n    // Background\n    fragColor = vec4(1.0);\n\n    // Inside triangles\n    if (right1 && right2 && right3)\n        fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    if (!right1 && !right2 && !right3)\n        fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n  \n    // Triangle edges\n    // Truncated\n    dist1 = (!right3 && right2) ? 10.0 : dist1;\n    dist2 = (!right1 && right3) ? 10.0 : dist2;\n    dist3 = (!right2 && right1) ? 10.0 : dist3;\n\n    float distToTriangle = min(min(dist1, dist2), dist3);\n    // Anti-aliasing\n    fragColor = mix( fragColor, vec4(0.), smoothstep(6./iResolution.y, 0., distToTriangle) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dsXRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 79, 79, 195], [197, 197, 246, 246, 305], [307, 307, 362, 362, 2303]], "test": "valid"}
{"id": "7dSXW1", "name": "Oiseau", "author": "azouagh", "description": "Oiseau", "tags": ["azouagh"], "likes": 1, "viewed": 39, "published": "Public", "date": "1620117515", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define AAstep(thre, val) smoothstep(-.7,.7,(val-thre)/min(.05,fwidth(val-thre)))\n#define circle(d, s) AAstep(s, length(d))\n#define anim Animation(abs(-1.+2.*dt))\n#define TAU 6.2831853071\n#define dt fract(iTime*0.5)\n\nfloat cos01(float v){ return 0.5 + 0.5 * cos(v); }\nfloat Animation(float x)\n{\n    float c1 = 8.70158;\n    float c2 = c1 * 1.525; // rotation des ailes\n\n    return x < 0.5\n      ? (pow(2. * x, 2.) * ((c2 + 1.) * 2. * x - c2)) / 2.\n      : (pow(2. * x - 2., 2.) * ((c2 + 1.) * (x * 2. - 2.) + c2) + 2.) / 2.;\n}\n\nmat2 rot (float a) \n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\n\n\nvoid moda (inout vec2 p, float rep)\n{\n    float per = TAU/rep;\n    float a = mod(atan(p.y,p.x),per)-per*0.5; // forme du cercle rouge  \n    p = vec2(cos(a),sin(a))*length(p); // diamètre du  cercle rouge\n}\n\nfloat tri (vec2 uv, float size, vec2 ratio)\n{return AAstep(size, max(-uv.x,dot(vec2(uv.x,abs(uv.y)),normalize(ratio))));}\n\nvec4 head (vec2 uv)\n{\n    uv.y -= anim*0.1;\n    float size = 0.3; //la taile du tête\n    float center = clamp(1.-circle(uv,size),0.,1.);\n    float outer = clamp(1.-(circle(uv, size*1.35)+(center)),0.,1.);\n    vec2 uu = uv;\n    moda(uu,40.); // forme du cercle rouge \n    uu.x -= size;\n    uu.y += sin(uu.x*1.)*0.0001;\n    float pales = clamp(1.-(tri(uu,0.2, vec2(9.25,1.))+outer+center),0.,1.);\n    vec3 col = vec3(1.,8.,0.)*outer + vec3(0.7,0.4,0.3)*pales + vec3(0.95,0.75,0.2)*center;\n\treturn vec4(col, clamp(pales+center+outer,0.,1.));\n}\n//création des ailes\nvec4 ailes (vec2 uv)\n{\n    uv.y -= 0.3;\n    uv.x = abs(uv.x)-0.7;\n    uv *= rot(-anim*0.5);\n    vec2 uu = uv;\n    uu *= rot(TAU/8.);\n    uu.y += sin(uu.x*1.5)*1.3;\n    float w1 = tri(uu, 0.14,vec2(0.12,1.));\n    uu.y += sin(uu.x*5.)*0.2;\n    uu.y += 0.1;\n    float w2 = tri(uu, 0.12,vec2(0.15,1.));\n    uu *= rot(-TAU/15.);\n    uu.y += 0.1;\n    float w3 = tri(uu, 0.1,vec2(0.2,1.));\n    float win = clamp(1.-w1*w2*w3*circle(uv+vec2(0.2,0.1), 0.2),0.,1.);\n    return vec4(vec3(1.)*win, win);\n}\n\n//l'arrière plan \nvec3 background (vec2 uv)\n{\n    uv.y += sin(uv.x*5.+iTime)*4.1;\n    vec3 col;\n    float mask = floor((abs(uv.x + uv.y)*0.7-0.2)*3.)/3.;\n    if (mask<0.2) col = vec3(0.4,1.7,1.7);\n    else if (mask>=0.2 && mask<0.5) col = vec3(0.6,0.9,0.5);\n    else if (mask>=0.5 && mask<0.7) col = vec3(0.5,0.6,0.7);\n    else if (mask>=2.7) col = vec3(0.9,0.3,0.9);\n    return col;\n \n}\n\nvec3 image (vec2 uv) \n{\n    vec3 back = background(uv);\n    uv *= 2.3; // 4.3\n    vec4 su = head(uv);\n    vec4 wi = ailes(uv);\n    float wmask = clamp(wi.w-su.w,0.,1.);\n    float allmask = clamp(1.-(wi.w+su.w),0.,1.);\n    return (ailes(uv).xyz*wmask) + su.xyz + back*allmask;\n}\n\n//création du soleil\nvec4 Soleil(vec2 uv, vec2 center, float radius, vec4 color) {\n    float dist = step(length(center - uv), (radius));\n    //return vec4(dist, dist, dist, 1.0) * cos01(1.2 * iTime );\n    return vec4(dist, 2, 4, 7.0)*color * cos01(1.2 * iTime );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 col = image(uv);\n    vec2 center = iResolution.xy * 0.5; // position du soleil (je l'ai mis au centre )\n    float radius = 0.11 * iResolution.x; // Rayon du soleil \n    float reactBase =texture(iChannel0, vec2(0.4, 1.0) ).x;\n\n   \n    fragColor = vec4( col, 1.0) +  Soleil(fragCoord.xy, center, radius, vec4(1.0, 0.0, 0.0, 1.0));\n\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dSXW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[217, 217, 238, 238, 267], [268, 268, 294, 294, 525], [527, 527, 548, 548, 591], [595, 595, 632, 632, 801], [803, 803, 848, 848, 924], [926, 926, 947, 947, 1467], [1468, 1490, 1512, 1512, 1982], [1984, 2003, 2030, 2030, 2372], [2374, 2374, 2397, 2397, 2651], [2653, 2675, 2736, 2736, 2918], [2921, 2921, 2978, 2978, 3379]], "test": "error"}
{"id": "7lf3D4", "name": "Your Grandmother's Other Quilt", "author": "stseagle", "description": "A happy accident while trying to achieve another effect", "tags": ["2d", "grid", "geometry"], "likes": 3, "viewed": 157, "published": "Public API", "date": "1622084695", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 diamonds (vec2 st) {\n    vec2 r = vec2(0.0);\n    r.x = st.x;\n    r.y = abs(0.5-fract(st.x))+st.y*sign(fract(st.y)-0.5);\n    \n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/min(iResolution.x, iResolution.y);\n    \n    uv *= 5.;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.);\n    \n    uv = diamonds(uv);\n    vec2 pos = floor(uv);\n\n\n    // honeycomb the 2D grid\n    col.r = 0.8*mod(pos.x+pos.y,1.6+0.5*sin(0.2432*iTime));\n    col.g = 0.2*mod(pos.y,2.5+0.7*sin(0.1124*iTime));\n    col.b = 0.3333*mod(pos.x+pos.y,3.2+0.8*sin(0.0845*iTime));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lf3D4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 145], [147, 147, 204, 254, 710]], "test": "valid"}
{"id": "7lf3RH", "name": "raymarched particle system", "author": "maeln", "description": "this is a very simple implementation of a particle system using raymarching.\nThe whole idea is to make the position of each particle fully deterministic so that at each point of time, we know exactly where the particle should be.", "tags": ["raymarching", "particles", "particle"], "likes": 3, "viewed": 206, "published": "Public API", "date": "1621518030", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415\n#define MAXSTEPS 128\n#define MINDIST  0.0005\n#define MAXDIST  20.0\n#define saturate(x) (clamp(0.0, 1.0, x))\n\nstruct pLight {\n    vec3 position;\n    vec3 ambiant;\n    vec3 diffuse;\n    vec3 specular;\n};\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat sphere(vec3 p, float s)\n{\n    return length(p) - s;\n}\n\n// Compute the position of particle {i} at the time {iTime}.\nvec3 calcPos(int i) {\n    float g = 8.91;\n    float period = 5.0;\n    float mTime = iTime+(float(i)*0.2);\n    \n    // we change the direction of the particle every {period} seconds.\n    float dv = floor(mTime/period+1.0);\n    \n    // Our \"random\" is deterministic so it will give us the same output\n    // if we give the same input, this how we can generate the same direction verctor\n    // for particle {i}\n    float dx = 0.5-random(vec2(i,i)*dv);\n    float dy = 0.5-random(vec2(i-1,i+1)*dv);\n    float dz = 0.5-random(vec2(i+1,i-1)*dv);\n    \n    vec3 dir = vec3(dx, dy, dz);\n    \n    // We skew the direction upward\n    dir += vec3(0.0, 1.0, 0.0);\n    \n    // We compute its position at time {iTime%period}\n    // We multiply direction {dir} by the {iTime} modulo {period} so that we reset the particle position every {period} seconds \n    vec3 p = (dir*3.0 + vec3(0.0,-g/10.0,0.0)*(mod(mTime,period))) * mod(mTime,period);\n    \n    return p;\n}\n\n// Draw all the particles\nvec2 scene(vec3 ray)\n{\n    float de = MAXDIST;\n    float m = 0.0;\n    for(int i=0; i<100; ++i) {\n        // if we just want the distance \n        // de = min(sphere(ray-calcPos(i), 0.1), de);\n        \n        // So that we can return the \"material id\"\n        // probably slower, but we can color each particle differently !\n        float di = sphere(ray-calcPos(i), 0.1);\n        if(di < de) {\n            de = di;\n            m = float(i);\n        }\n    }\n    \n    return vec2(de, m);\n}\n\nvec3 normal(vec3 pos) {\n    vec2 eps = vec2(0.0, MINDIST);\n\treturn normalize(vec3(\n    scene(pos + eps.yxx).x - scene(pos - eps.yxx).x,\n    scene(pos + eps.xyx).x - scene(pos - eps.xyx).x,\n    scene(pos + eps.xxy).x - scene(pos - eps.xxy).x));\n}\n\nvec2 raymarch(vec3 from, vec3 direction)\n{\n    float t = 1.0*MINDIST;\n    int i = 0;\n    float obj = -1.0;\n    for(int steps=0; steps<MAXSTEPS; ++steps)\n    {\n        ++i;\n        vec2 dist = scene(from + t * direction);\n        if(dist.x < MINDIST || t >= MAXDIST) break;\n        t += dist.x;\n        obj = dist.y;\n    }\n    \n    return vec2(t, t > MAXDIST ? -1.0 : obj);\n}\n\nvec3 material(vec2 c, vec3 hit, vec3 sky) {\n    vec3 color = sky;\n    float r = random(vec2(c.y,c.y));\n    float g = random(vec2(c.y-1.0,c.y+1.0));\n    float b = random(vec2(c.y+1.0,c.y-1.0));\n    return vec3(r,g,b);\n}\n\nvec3 phong(vec3 hit, vec3 eye, vec3 N, pLight light, float ks) {\n    vec3 L = normalize(light.position - hit);\n    vec3 V = normalize(eye - hit);\n    vec3 R = reflect(L, N);\n    vec3 ambiant = light.ambiant;\n    vec3 diffuse = max(dot(L,N), 0.0)*light.diffuse;\n    vec3 specular = pow(max(dot(R,V), 0.0), ks)*light.specular;\n    return ambiant + 0.5*(diffuse+specular);\n}\n\nfloat sdCircle(vec2 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, in float rb )\n{\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p.xy,scb) : length(p);\n    return sqrt(max(0.0, dot(p,p) + ra*ra - 2.0*ra*k)) - rb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    pLight l1 = pLight(vec3(iTime-3.0, 2.0*sin(iTime), cos(iTime)*3.0),\n                       vec3(0.8), vec3(1.0, 0.0, 0.0), vec3(0.8, 0.0, 0.0));\n    \n   \tpLight l2 = pLight(vec3(iTime-3.0, -2.0, -3.0),\n                       vec3(0.3), vec3(0.0, 0.0, 1.0), vec3(0.0, 0.0, 0.8));\n    \n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    vec3 target  = vec3(0.0, 0.0, 0.0);\n\tvec3 eye     = vec3(2.0, 2.0, 2.0);\n    vec3 up      = vec3(0.0, 1.0, 0.0);\n    \n    vec3 eyeDir   = normalize(target - eye);\n    vec3 eyeRight = normalize(cross(up, eye));\n    vec3 eyeUp    = normalize(cross(eye, eyeRight));\n    \n    vec3 rayDir = normalize(eyeRight * uv.x + eyeUp * uv.y + eyeDir);\n    \n    vec3 hi = vec3(255.0, 122.0, 122.0)/255.0;\n    vec3 lo = vec3(134.0, 22.0, 87.0)/255.0;\n    vec3 color = mix(lo, hi, fragCoord.y/iResolution.y);\n    vec3 sky = color;\n    vec2 c = raymarch(eye, rayDir);\n    vec3 hit = eye+c.x*rayDir;\n    vec3 norm = normal(hit);\n    \n    if(c.y>0.0) {\n        color = material(c, hit, color);\n        color = color * phong(hit, eye, norm, l1, 2.0);\n    }\n    \n    \n    // LOGO\n    // left-down circle\n    float d = sdCircle(uv + vec2(1.25, 0.5), 0.1);\n    color = mix(color, vec3(1.0), smoothstep(3.0/iResolution.y, 0.0, d));\n    \n    // left down arc\n    float ta = PI/2.0 * iTime*2.0;// 3.14*(0.5+0.5*cos(iTime*0.52+2.0));\n    float tb = PI/4.0 * (1.0-sin(iTime)/2.0); //3.14*(0.5+0.5*cos(iTime*0.31+2.0));\n    d = sdArc(uv + vec2(1.25, 0.5),vec2(sin(ta),cos(ta)),vec2(sin(tb),cos(tb)), 0.2, 0.02);\n    color = mix(color, vec3(1.0), smoothstep(4.0/iResolution.y, 0.0, d));\n\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lf3RH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[221, 221, 248, 248, 355], [357, 357, 388, 388, 416], [1428, 1454, 1476, 1476, 1942], [1944, 1944, 1967, 1967, 2189], [2191, 2191, 2233, 2233, 2565], [2567, 2567, 2610, 2610, 2785], [2787, 2787, 2851, 2851, 3158], [3160, 3160, 3193, 3193, 3221], [3223, 3223, 3301, 3301, 3490], [3492, 3492, 3549, 3549, 5196]], "test": "valid"}
{"id": "7lf3Rn", "name": "Distance to Polyspline", "author": "oneshade", "description": "Distance to a polyspline constructed of many quadratic bezier curves.", "tags": ["2d", "sdf", "bezier", "spline", "distance"], "likes": 16, "viewed": 163, "published": "Public", "date": "1621393844", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Number of vertices in the polyspline\n#define N 10\n\n// Helper functions\nfloat dot2(in vec2 v) { return dot(v, v); }\nfloat sdPolyspline(in vec2 p, in vec2[N] cp) {\n    // Complete the first segment of the polyspline\n    vec2 v1 = cp[0], v2 = vec2(0.0), v3 = 0.5 * (cp[1] + v1);\n    vec2 pa = p - v1, ba = v3 - v1;\n    float d = dot2(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n\n    // Combine distances to quadratic beziers spanning each corner (vertex)\n    for (int n=1; n < N - 1; n++) {\n        v1 = 0.5 * (cp[n - 1] + cp[n]), v2 = cp[n], v3 = 0.5 * (cp[n] + cp[n + 1]);\n\n        vec2 c1 = p - v1;\n        vec2 c2 = 2.0 * v2 - v3 - v1;\n        vec2 c3 = v1 - v2;\n\n        // Solve a cubic to minimize the distance for the parameter\n        float t3 = dot(c2, c2);\n        float t2 = dot(c3, c2) * 3.0 / t3;\n        float t1 = (dot(c1, c2) + 2.0 * dot(c3, c3)) / t3;\n        float t0 = dot(c1, c3) / t3;\n\n        float t22 = t2 * t2;\n        vec2 pq = vec2(t1 - t22 / 3.0, t22 * t2 / 13.5 - t2 * t1 / 3.0 + t0);\n        float ppp = pq.x * pq.x * pq.x, qq = pq.y * pq.y;\n\n        float p2 = abs(pq.x);\n        float r1 = 1.5 / pq.x * pq.y;\n\n        if (qq * 0.25 + ppp / 27.0 > 0.0) {\n            float r2 = r1 * sqrt(3.0 / p2), root;\n            if (pq.x < 0.0) root = sign(pq.y) * cosh(acosh(r2 * -sign(pq.y)) / 3.0);\n            else root = sinh(asinh(r2) / 3.0);\n            root = clamp(-2.0 * sqrt(p2 / 3.0) * root - t2 / 3.0, 0.0, 1.0);\n            d = min(d, dot2(p - mix(mix(v1, v2, root), mix(v2, v3, root), root)));\n        }\n\n        else {\n            float ac = acos(r1 * sqrt(-3.0 / pq.x)) / 3.0;\n            vec2 roots = clamp(2.0 * sqrt(-pq.x / 3.0) * cos(vec2(ac, ac - 4.18879020479)) - t2 / 3.0, 0.0, 1.0);\n            d = min(d, dot2(p - mix(mix(v1, v2, roots.x), mix(v2, v3, roots.x), roots.x)));\n            d = min(d, dot2(p - mix(mix(v1, v2, roots.y), mix(v2, v3, roots.y), roots.y)));\n        }\n    }\n\n    // Complete the last segment of the polyspline\n    v1 = cp[N - 1], v2 = vec2(0.0), v3 = 0.5 * (cp[N - 2] + v1);\n    pa = p - v1, ba = v3 - v1;\n    d = min(d, dot2(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0)));\n\n    return sqrt(d);\n}\n\n// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nvec2 Hash22(in vec2 p) {\n\tvec3 p3 = fract(p.xyx * vec3(0.1031, 0.103, 0.0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n    float time = iTime * 2.0;\n\n    // Generate control points\n    vec2[N] controlPoints;\n    for (int id=0; id < N; id++) {\n        controlPoints[id] = mix(Hash22(vec2(id, floor(iTime))), Hash22(vec2(id, ceil(iTime))), smoothstep(0.0, 1.0, fract(iTime))) * 3.0 - 1.5;\n    }\n\n    float d = sdPolyspline(uv, controlPoints) * 0.5;\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(d) * vec3(0.1, 0.4, 0.7);\n\tcolor *= 1.0 - exp(-4.0 * abs(d));\n\tcolor *= 0.8 + 0.2 * cos(140.0 * d);\n\n    // Draw lines and control points\n    for (int n=0; n < N - 1; n++) {\n        vec2 pa = uv - controlPoints[n], ba = controlPoints[n + 1] - controlPoints[n];\n        color = mix(color, vec3(1.0, 0.0, 0.0), smoothstep(unit, 0.0, length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0)) - 0.001));\n        color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, length(uv - controlPoints[n]) - 0.03));\n    }\n\n    // Draw last control point\n    color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, length(uv - controlPoints[N - 1]) - 0.03));\n\n    // Draw the polyspline\n\tcolor = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, d));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lf3Rn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 74, 97, 97, 117], [2187, 2276, 2300, 2300, 2435]], "test": "valid"}
{"id": "7lf3zj", "name": "Electric Whiskey 2", "author": "jayfero", "description": "12 variations. I like these 6.\n\nsq_IDEA_2\nsq_IDEA_123\nsq_IDEA_CRAZY_1\nsq_IDEA_CRAZY_12_WEIRD\nsq_IDEA_CRAZY_12_WEIRD_ALT\nsq_IDEA_FINAL_2", "tags": ["2d", "distortion", "plasma", "sphere", "blending", "glow", "electric", "electricity"], "likes": 0, "viewed": 32, "published": "Public", "date": "1622410605", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\nForked from \"Electric Whiskers\"\nby Dean Alex 2016, dean[at]neuroid co uk\n\nMessing around with (unclamped) sphere normal vectors.\n\n---------------\n\nElectric Whiskey\"\nby Jay Fero\n\nedit. changed the sqrt. just playing around. great job Dean.\n\n*/\n\n// change MACRO_SQ [FUNC]\n\n// sq_IDEA_1\n// sq_IDEA_2\n// sq_IDEA_3\n// sq_IDEA_123\n// sq_IDEA_CRAZY_1\n// sq_IDEA_CRAZY_2\n// sq_IDEA_CRAZY_12\n// sq_IDEA_CRAZY_12_WEIRD\n// sq_IDEA_CRAZY_12_WEIRD_ALT\n// sq_IDEA_FINAL_1\n// sq_IDEA_FINAL_2\n// sq_IDEA_FINAL_3\n\n#define MACRO_SQ sq_IDEA_123\n\n\n\nfloat cool_sq(in vec3 param){\n    return param.x * param.y / abs(param.x) * param.z;\n}\n\nfloat compound_sq(in float f)\n{\nreturn cool_sq(vec3(f, .61, 0.9))\n+ cool_sq(vec3(f, 1.43, .17))\n* cool_sq(vec3(f,.37, 1.61))\n+ cool_sq(vec3(f, 1.43, .17))\n/ cool_sq(vec3(f,.37, 1.61));\n}\nfloat sq_IDEA_1( in float f ){\n    return f * 0.9;\n}\nfloat sq_IDEA_2( in float f ){\n    return f * 1.1 / abs(f);\n}\nfloat sq_IDEA_3( in float f ){\n    return compound_sq(f);\n}\nfloat sq_IDEA_123( in float f ){\n    return sq_IDEA_1(f) * sq_IDEA_2(f)- sq_IDEA_3(f) + sq_IDEA_1(f);\n}\n\nfloat sq_IDEA_CRAZY_1( in float f ){\n    return sq_IDEA_123(f) * sq_IDEA_123(f)- sq_IDEA_123(f) + sq_IDEA_123(f);\n}\nfloat sq_IDEA_CRAZY_2( in float f ){\n    return sq_IDEA_123(f) - sq_IDEA_123(f)+ sq_IDEA_123(f) * sq_IDEA_123(f);\n}\n\nfloat sq_IDEA_CRAZY_12( in float f ){\n    return sq_IDEA_CRAZY_1(f) * sq_IDEA_CRAZY_2(f);\n}\nfloat sq_IDEA_CRAZY_12_WEIRD( in float f ){\n    return sq_IDEA_CRAZY_1(-f) * sq_IDEA_CRAZY_2(-f);\n}\nfloat sq_IDEA_CRAZY_12_WEIRD_ALT( in float f ){\n    return sq_IDEA_CRAZY_1(-f*1.2) * sq_IDEA_CRAZY_2(f*11.);\n}\nfloat sq_IDEA_FINAL_1( in float f ){\n    return sq_IDEA_CRAZY_2(f)  * sq_IDEA_CRAZY_12_WEIRD_ALT(f);\n}\nfloat sq_IDEA_FINAL_2( in float f ){\n    return sq_IDEA_CRAZY_2(f) - sq_IDEA_CRAZY_1(f) * sq_IDEA_CRAZY_12_WEIRD_ALT(f);\n}\nfloat sq_IDEA_FINAL_3( in float f ){\n    return sq_IDEA_FINAL_1(f) + sq_IDEA_FINAL_2(f - 0.3);\n}\n\nfloat sq( in float f ){\n   return MACRO_SQ(f);   \n}\n\nvec3 sq3( in vec3 v ){\n    return vec3(\n        sq(v.x),\n        sq(v.y),\n        sq(v.z)\n    );\n}\n         \nvec3 sh( in vec3 pos, in vec2 uv )\n{\n    vec2 xy = (uv.xy - pos.xy) / pos.z;\n    float len = dot(xy,xy);\n    return vec3( xy, sq( 1.0 - len ));\n}\nfloat tsin( in float mf ){\n    return sin( iTime * mf);\n}\nfloat tcos( in float mf ){\n    return cos( iTime * mf);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 norm;\n    float w = iResolution.x;\n    float h = iResolution.y;\n    float m = min(w,h);\n    \n    vec3 s1 = sh(\n        vec3( w * 0.5, h * 0.5, m * 0.5 ),\n        vec2( fragCoord.x, fragCoord.y )\n    );\n    vec3 s2 = sh(\n        vec3( (tsin(1.7)*0.4 + 0.5)*w, (tcos(1.3)*0.4 + 0.5)*h, m * 0.1 ),\n        vec2( fragCoord.x, fragCoord.y )\n    );\n    vec3 s3 = sh(\n        vec3( (tsin(0.5)*0.3 + 0.5)*w, (tcos(-2.0)*0.4 + 0.5)*h, m * 0.5 ),\n        vec2( fragCoord.x, fragCoord.y )\n    );\n    vec3 s4 = sh(\n        vec3( (tcos(-0.31)*0.6 + 0.5)*w, (tsin(-0.4)*0.2 + 0.5)*h, m * 3.3 ),\n        vec2( fragCoord.x, fragCoord.y )\n    );\n    \n    //\n    norm = sq3( cross( s2.yzx, s1.zxy ));\n    norm = sq3( cross( norm, s3.zxy ));\n    norm = sq3( cross( -norm, s4.xyz ));\n    \n    \n    //\n    \n    float mag = length( norm );\n    float a = pow( smoothstep( 1.0, 1.0, mag ), 10.5 );\n    float s = atan( norm.z, norm.x ) / 6.283185307179586;\n    float t = asin( norm.y ) / 3.14159265358979;\n    fragColor = texture( iChannel0, vec2( s*5.1 + iTime*-0.2, t * s ));\n    fragColor.b = min( fragColor.g, fragColor.b );\n    vec3 lightDir = normalize( vec3( tcos(.5) * -1.1, 0.3, tsin(.5) *1.7 ));\n    float mflight = max(dot( norm, lightDir), 0.0);\n    float dis1 = 1.0 - length( norm - lightDir ) / 2.0;\n    mflight += pow( dis1, 10.0) * 1.5;\n    fragColor.rgb *= mflight;\n    vec3 l1p = vec3( tsin(1.7) * 0.6, tcos(3.5) * 0.5, -tsin(1.5) * 0.3 );\n    vec3 l1c = vec3( 3.0, 2.0, 1.0 );\n    float dis = 1.0 - length( norm - l1p ) / 2.0;\n    fragColor.rgb += l1c * pow( dis, 0.8 );\n    fragColor = mix( fragColor, vec4(1.0,0.0,0.0,1.0), a );\n}\n", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lf3zj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[533, 533, 562, 562, 619], [621, 621, 652, 652, 807], [808, 808, 838, 838, 860], [861, 861, 891, 891, 922], [923, 923, 953, 953, 982], [983, 983, 1015, 1015, 1086], [1088, 1088, 1124, 1124, 1203], [1204, 1204, 1240, 1240, 1319], [1321, 1321, 1358, 1358, 1412], [1413, 1413, 1456, 1456, 1512], [1513, 1513, 1560, 1560, 1623], [1624, 1624, 1660, 1660, 1726], [1727, 1727, 1763, 1763, 1849], [1850, 1850, 1886, 1886, 1946], [1948, 1948, 1971, 1971, 1999], [2001, 2001, 2023, 2023, 2099], [2110, 2110, 2146, 2146, 2255], [2256, 2256, 2282, 2282, 2313], [2314, 2314, 2340, 2340, 2371], [2374, 2374, 2431, 2431, 4072]], "test": "error"}
{"id": "7ll3D4", "name": "31052021", "author": "Pixdigit", "description": "Some shader practice", "tags": ["circle", "stars"], "likes": 3, "viewed": 152, "published": "Public API", "date": "1622485329", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float TAU = 2. * 3.141569;\n\n\nvec3 pal(vec3 val) {\n    return 0.5 + 0.5*cos(val+vec3(0,2,4));\n}\n\nmat2 rot(float deg) {\n    float c = cos(deg);\n    float s = sin(deg);\n    return mat2(-c, s, s, c);\n}\n\nfloat rsin(float minVal, float maxVal, float val) {\n    float r = (maxVal - minVal) * 0.5;\n    return r * sin(val) + r + minVal;\n}\n\n\nfloat rand(float seed) {\n    return fract(sin(dot(vec2(seed),vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// 2D SDF for a segment by IQ\n// https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\nvec2 starTrail(float deg, float time) {\n    vec2 dir = vec2(sin(deg), cos(deg));\n    float phase = mod(time, 10.);\n    float d = pow(100., phase-1.3);\n    return dir*d;\n}\n\nvec3 star(vec2 uv, float seed) {\n\n    float deg = rand(seed+1.) * TAU;\n    float time = iTime*.1+rand(seed+2.)*10.;\n\n    vec3 col;\n    for (int i = 0; i<3; i++) {\n        vec2 trailStart = starTrail(deg, time + float(i) * 0.005);\n        vec2 trailEnd = starTrail(deg, time+0.1+ float(i) * 0.005);\n\n        if (length(trailStart) > length(trailEnd)) {\n            return vec3(0.);\n        }\n        \n        if (i == 0 && (abs(trailStart.y) > 1. || abs(trailStart.x) > iResolution.x / iResolution.y)) {\n            return vec3(0.);\n        }\n\n        float d = sdSegment(uv, trailStart, trailEnd);\n        \n        col[i] = smoothstep(.01, 0., d);\n    }\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col;\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 2.;\n\n    vec3 waves = vec3(rsin(0.07, .13, length(uv) * 2. - iTime * 1.2));\n\n    vec2 uv2 = rot(iTime) * (uv + vec2(0.5, 0.5));\n    float scale = rsin(.5, 1., iTime);\n    vec3 ring = pal(vec3(uv2 * scale, 1.) * 4.);\n    float ringMask = smoothstep(0.03, 0.0, abs(1.-length(uv)));\n    \n    vec3 stars;\n    for (int i = 0; i < 1000; i++) {\n        stars = stars + star(uv, float(i));\n    }\n    float starMask = clamp(length(stars), 0., 1.);\n\n    col = mix(mix(waves, stars, starMask), ring, ringMask);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ll3D4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 55, 55, 100], [102, 102, 123, 123, 203], [205, 205, 256, 256, 335], [338, 338, 362, 362, 438], [440, 545, 597, 597, 716], [719, 719, 758, 758, 889], [891, 891, 923, 923, 1567], [1570, 1570, 1627, 1627, 2283]], "test": "valid"}
{"id": "7ll3RN", "name": "Mono-Eye", "author": "kithy", "description": "mapping2D  eye texture to 3D sphere.\neye based on this shader↓\nhttps://www.shadertoy.com/view/XsjXz1", "tags": ["raymarching", "fbm", "polarcoordinate"], "likes": 1, "viewed": 39, "published": "Public", "date": "1621695448", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ITR 32\n#define EPS 0.001\n#define SCALE 5.0\n#define PI 3.141592\n#define TWO_PI 6.2831\n#define GREEN vec3(0.2,0.9,0.7)\n\nmat2 rot(float a){\n\tfloat s=sin(a);\n\tfloat c=cos(a);\n\treturn mat2(c,-s,s,c);\n}\n\nvec3 hash3(vec2 p){\n\tvec3 q=vec3(dot(p,vec2(127.1,311.7)),\n\t\t\t\tdot(p,vec2(269.5,183.3)),\n\t\t\t\tdot(p,vec2(419.2,371.9)));\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat iqnoise(in vec2 x,float u,float v){\n\tvec2 p=floor(x);\n\tvec2 f=fract(x);\n\n\tfloat k=1.0+63.0*pow(1.0-v,4.0);\n\n\tfloat va=0.0;\n\tfloat wt=0.0;\n\n\tfor(int j=-2;j<=2;j++)\n\t\tfor(int i=-2;i<=2;i++)\n\t\t{\n\t\t\tvec2 g=vec2(float(i),float(j));\n\t\t\tvec3 o=hash3(p+g)*vec3(u,u,1.0);\n\t\t\tvec2 r=g-f+o.xy;\n\t\t\tfloat d=dot(r,r);\n\t\t\tfloat ww=pow(1.0-smoothstep(0.0,1.414,sqrt(d)),k);\n\t\t\tva+=o.z*ww;\n\t\t\twt+=ww;\n\t\t}\n\t\treturn va/wt;\n}\n\nfloat noise(vec2 x){\n\treturn iqnoise(x,0.0,1.0);\n}\n\nmat2 m=mat2(0.8,0.6,-0.6,0.8);\n\nfloat fbm(vec2 p){\n\tfloat f=0.0;\n\tf+=0.5000*noise(p);\n\tp*=m*2.02;\n\tf+=0.2500*noise(p);\n\tp*=m*2.03;\n\tf+=0.1250*noise(p);\n\tp*=m*2.01;\n\tf+=0.0625;\n\tp*=m*2.04;\n\tf/=0.9375;\n\treturn f;\n}\n\n\n\nfloat sdSphere(vec3 p){\n\treturn length(p)-1.2;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n\tvec2 uv=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\n\tvec3 ro=vec3(0.0,0.0,-10.0);\n\tvec3 lookat=vec3(0.0,0.0,0.0);\n\tfloat zoom=5.0;\n\n\tvec3 f=normalize(lookat-ro);\n\tvec3 r=normalize(cross(vec3(0.0,1.0,0.0),f));\n\tvec3 u=cross(f,r);\n\tvec3 c=ro+f*zoom;\n\tvec3 i=c+uv.x*r+uv.y*u;\n\tvec3 rd=normalize(i-ro);\n\n\tfloat dS,dO;\n\tvec3 p;\n\n\t//raymarching\n\tfor(int i=0;i<ITR;i++){\n\t\tp=ro+rd*dO;\n\t\tdS=sdSphere(p);\n\t\tif(dS<EPS)break;\n\t\tdO+=dS;\n\t}\n\n\n    //animate\n\tp.xy*=rot(cos(iTime*5.0));\n\tp.xz*=rot(sin(iTime*3.0)*0.5);\n\tp.yz*=rot(sin(iTime*2.0)*0.3);\n\n\tvec3 col=vec3(0.5);\n\n\tfloat x=atan(p.x+TWO_PI,p.y);\n\tfloat y=length(p.xy);\n\n\n\t//polar coordinate\n\tif(dS<EPS){\n\t\t\n\t\t//2D texture\n\t\tcol=vec3(0.8,0.1,0.1);\n\t\tfloat f=fbm(5.0*p.xy);\n\t\tcol=mix(col,vec3(1.0,0.0,0.0),f);//red\n\n\t\tf=1.0-smoothstep(0.2,0.4,y);\n\t\tcol=mix(col,vec3(0.70,0.44,0.12),f);//yellow\n\n\t\tx+=0.05*fbm(20.0*p.xy);\n\n\t\tf=smoothstep(0.2,1.0,fbm(vec2(5.0*y,20.0*x)));//yellow highlight\n\t\tcol=mix(col,vec3(1.0),f);\n\n\t\tf=smoothstep(0.9,0.9,fbm(vec2(5.0*y,10.0*x)));//dark highlight\n\t\tcol*=1.0-f;\n\n\t\tf=smoothstep(0.55,0.7,y);//dark at edges\n\t\tcol*=1.0-f*0.5;\n\n\t\tf=1.0-smoothstep(0.0,0.5,length(p.xy-vec2(0.1,0.1)));//light\n        col+=vec3(1.0,0.9,0.8)*f*0.75;       \n\n\t\tf=smoothstep(0.75,0.8,y);\n\t\tcol=mix(col,vec3(1.0),f);\n\n\t}\n\t\n\tfragColor=vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ll3RN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[126, 126, 144, 144, 204], [206, 206, 225, 225, 361], [363, 363, 404, 404, 774], [776, 776, 796, 796, 826], [860, 860, 878, 878, 1040], [1044, 1044, 1067, 1067, 1092], [1094, 1094, 1147, 1147, 2456]], "test": "valid"}
{"id": "7ll3WM", "name": "[KiFS] GldChains", "author": "ad_lucem", "description": "Snapshot of a new fft reacting shader wip", "tags": ["raymarch", "kifs", "neon"], "likes": 5, "viewed": 74, "published": "Public", "date": "1622227749", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 ep=vec2(0.003,-0.003);\nfloat ti,b,f;\nfloat em;\nfloat bo(vec3 p, vec3 b){p=abs(p)-b;return max(p.x,max(p.y,p.z));}\nmat2 rt(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\nvec2 sdf(vec3 p)\n{\n    vec3 yp,xp,zp;\n    vec2 h,r=vec2(bo(abs(p),vec3(1)),1);\n    yp=xp=zp=p;\n  f=1.0;\n    float a=.1, of=.25, w=6.*f;\n    vec2 we= vec2(w,.1);\n    xp.yz*=rt(abs(xp.x));\n    h=vec2(bo(abs(xp)-vec3(of+a*abs(p.x)),we.xyy),3);    \n    yp.xz*=rt(abs(yp.y));     \n    h.x=min(bo(abs(yp)-vec3(of+a*abs(p.y)),we.yxy),h.x);\n    zp.xy*=rt(abs(zp.z));  \n    h.x=min(bo(abs(zp)-vec3(of+a*abs(p.z)),we.yyx),h.x);\n    r=r.x<h.x?r:h;\n  b=1.0;\n    float bi = 1.+b;\n    h=vec2(bo(abs(p)-vec3(0,bi,bi),vec3(.5,.0,.0)),2);\n    p.xy*=rt(1.59);\n    h.x=min(bo(abs(p)-vec3(0,bi,bi),vec3(.5,.0,.0)),h.x);\n    p.xz*=rt(1.59);\n    h.x=min(bo(abs(p)-vec3(0,bi,bi),vec3(.5,.0,.0)),h.x);  \n    em+=0.002/(0.1+h.x*h.x);\n    r=r.x<h.x?r:h;\n    r.x*=.5;\n    return r;\n}\n\nvec2 mp(vec3 p)\n{\n  p.xz*=rt(.5*ti);\n  p.xy*=rt(.89*ti);\n  vec3 np=p;\n  //f = texture(texFFTSmoothed,1).r*400;\n  //b = clamp(texture(texFFTSmoothed,0).r*800,0,3);\n  for(int i=0; i<3; i++){\n    np=abs(np)-vec3(pow(1.8,2.));\n    //float t = clamp(100000/fGlobalTime,0,1);\n    //np.zx*=r2(-ti*.1*t);\n    //np.yz*=r2(sin(-ti*.1*t));\n    //np.xy*=r2(sin(-ti)*.1*t);\n  }\n  return sdf(np);\n}\n\nvec2 rm(vec3 ro, vec3 rd)\n{\n  float tn=.001,tx=75.;\n  vec2 h,d=vec2(tn,0);\n  for(;d.x<tx;d.x+=h.x)\n  {\n      h=mp(ro+rd*d.x);\n      if(h.x<.0001)break;\n      d.y=h.y;\n  }\n  if(d.x>tx)d.x=0.;\n  return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    ti=mod(iTime,100.);\n    vec3 co=vec3(0,0,-15),\n    cd=normalize(vec3(uv,1.5)),fo,cl=fo=vec3(.2,.5,1)+cd.y*vec3(0,.5,0);\n    vec2 r=rm(co, cd);\n    float d=r.x;\n    if(d>0.)\n    {\n        vec3 p=co+cd*d, no=normalize(ep.xyy*mp(p+ep.xyy).x+\n        ep.xyx*mp(p+ep.xyx).x+\n        ep.xxy*mp(p+ep.xxy).x+\n        ep.xxx*mp(p+ep.xxx).x),\n        l=normalize(vec3(-1,-.5,1)),\n        al=vec3(1.);\n        if(r.y>0.)al=vec3(.1,.2,1.);\n        if(r.y>1.)\n        {\n            float at = clamp(1.-(length(p)-7.),0.,1.);\n            al=vec3(1.-at,1.-at,.4*at);\n        }\n        float dif=max(dot(no,-l),0.),r=40./d, ao = exp2(pow(max(0.,1.-mp(p+no*r).x)/r,2.));\n        float spec=pow(max(0., dot(no, normalize(-l-cd))), 100.),\n        sss=smoothstep(0., 1., mp(p+l*.4).x/.4);\n        cl=spec+al*(.3*ao)*(dif+sss);\n    }\n    cl=mix(cl+em*vec3(.5,b,(.4*b)), fo, 1.-exp(-.0001*d*d*d));\n    fragColor=vec4(pow(cl,vec3(.45)),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ll3WM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 52, 77, 77, 118], [119, 119, 136, 136, 179], [180, 180, 198, 198, 936], [938, 938, 955, 955, 1322], [1324, 1324, 1351, 1351, 1528], [1530, 1530, 1585, 1585, 2567]], "test": "valid"}
{"id": "7llGRr", "name": "Psychedelic Neon drifts", "author": "sandyblair", "description": "Coloured blobs floating about.", "tags": ["motionsickness"], "likes": 7, "viewed": 80, "published": "Public", "date": "1621455787", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float c (float oldCos) {\n     float newCos = 0.5 + 0.5*cos(oldCos*3.141592);\n\t return newCos;\n\t }\n\nfloat s (float oldSin) {\n    float newSin = 0.5 + 0.5*sin(oldSin*3.141592);\n    return newSin;    }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 uv = fragCoord/iResolution.xy;  // Normalized pixel coordinates (from 0 to 1)\n//   uv -= 0.5;                           // remap so 0,0 is in the middle of the screen.\n\nfloat x = uv.x;\nfloat y = uv.y;\nfloat o = iTime * 0.25;     \n\n// Time varying pixel color\nfloat r = s(s((s(y)-c(x))+c((o*0.28081)))*2.0 + s(s(o+3.0*(y+x)) + s(4.0*x+s(o))));\nfloat g = s(c(c(r)-(x*1.8713) + c(y-x))*2.1);\nfloat b = c(s( c(r)-(g*0.4712))*2.2);\nvec3 col = vec3(r, g, b);\n\n// Output to screen\nfragColor = vec4(col,1.0);\n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7llGRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 97], [99, 99, 123, 123, 198], [200, 200, 257, 257, 767]], "test": "valid"}
{"id": "7llGz2", "name": "Sea Adventure", "author": "IamWiki", "description": "I applied my own skills, combined with a sea shader I found, to make a sail through a sea with some fire elements around it. The shader is essentially lots of different elements combined into one (water, lights, moon, stars, cubes?, fire).", "tags": ["reflection", "waves", "sea", "fire", "water", "ocean", "fog", "stars", "moon", "lights", "liquid", "seascape", "sail"], "likes": 5, "viewed": 225, "published": "Public", "date": "1622472115", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Credits to TDM https://www.shadertoy.com/view/Ms2SD1\n\nfloat smin(float a, float b, float h)\n{\n    float k = clamp((a-b)/ h * .5 + .5, 0., 1.);\n    return mix(a,b,k) - k * (1.-k) * h;\n}\n\nmat2 rot(float a)\n{\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat sph(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat box(vec3 p, vec3 s)\n{\n    p = abs(p) - s;\n    return max(p.x, max(p.y,p.z));\n}\n\nfloat repeat(float p, float s)\n{\n    return (fract(p/s-.5)-.5)*s;\n}\n\nvec2 repeat(vec2 p, vec2 s)\n{\n    return (fract(p/s-.5)-.5)*s;\n}\n\nvec3 repeat(vec3 p, vec3 s)\n{\n    return (fract(p/s-.5)-.5)*s;\n}\n\nvec3 kifs(vec3 p, float t)\n{\n    p.xz = repeat(p.xz, vec2(10.));\n    p.xz = abs(p.xz);\n\n    vec2 s = vec2(10,7) * 0.7;\n    for(float i = 0.; i < 5. ; ++i)\n    {\n        p.xz *= rot(t);\n        p.xz = abs(p.xz) - s;\n        p.y -= 0.1*abs(p.z);\n        s *= vec2(0.68, 0.55);\n    }\n\n    return p;\n}\n\nvec3 kifs3d(vec3 p, float t)\n{\n    p.xz = repeat(p.xz, vec2(32.));\n    p = abs(p);\n\n    vec2 s = vec2(10,7) * 0.6;\n    for(float i = 0.; i < 5. ; ++i)\n    {\n        p.yz *= rot(t * .7);\n        p.xz *= rot(t);\n        p.xz = abs(p.xz) - s;\n        p.y -= 0.1*abs(p.z);\n        s *= vec2(0.68, 0.55);\n    }\n\n    return p;\n}\n\nvec3 tunnel(vec3 p)\n{\n    vec3 off = vec3(0);\n    float dd = p.z * 0.02;\n    dd = floor(dd) + smoothstep(0., 1., smoothstep(0., 1., fract(dd)));\n    dd *= 1.7;\n    off.x += sin(dd) * 10.;\n    //off.y += sin(dd * 0.7) * 10.;\n\n    return off;\n}\n\nfloat fire = 0.;\nfloat solid(vec3 p)\n{\n    float t = iTime * .2;\n    vec3 pp = p;\n    vec3 p5 = p;\n    pp += tunnel(p);\n\n    float path = abs(pp.x) - 1.;\n\n    vec3 p2 = kifs(p, 0.5);\n    vec3 p3 = kifs(p + vec3(1,0,0), 1.9);\n\n    float d5 = -1.;\n    p5.xy *= rot(2.8);\n    p5.xz *= rot(0.5);\n\n\n    float trk = 1.;\n    float z = 1.;\n    int iterations = 10;\n    for(int i = 0; i < iterations; ++i)\n    {\n        p5 += sin(p5.zxy*0.75*trk + t*trk*.8);\n        d5 -= abs(dot(cos(p5), sin(p5.yzx)) * z);\n        trk *= 1.6;\n        z *= 0.4;\n        \n        p5.y += t * 3.;\n    }\n    \n    float d;\n\n    float b1 = box(p2, vec3(1,1,0.5));\n    float b2 = box(p3, vec3(0.5,1.3,1));\n\n    float m1 = max(abs(b1), abs(b2)) - 0.2;\n    d = m1;\n    d = max(d, -path);\n    d5 = abs(d5);\n    d += + sin(iTime * 0.1)*.3+.5;\n    if(p5.y - t * 3. * float(iterations) > -10.)\n    {\n        d = smin(d, d5, 3.);\n    }\n\n    fire += 0.2 / (0.1 + abs(d));\n\n    return d;\n}\n\nvec3 lpos = vec3(0,200,200);\nfloat moonlight = 0.;\nfloat ghost(vec3 p)\n{\n    vec3 p2 = kifs3d(p - vec3(0,2,3), 0.8 + iTime * 0.1);\n    vec3 p3 = kifs3d(p - vec3(3,0,0), 1.2 + iTime * 0.07);\n\n    float b1 = box(p2, vec3(5));\n    float b2 = box(p3, vec3(3));\n\n    float m1 = max(abs(b1), abs(b2)) - .2;\n\n    float d = abs(m1) - 0.02;\n    return d;\n}\n\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat noise(vec3 p) {\n  vec3 ip=floor(p);\n  p=fract(p);\n  p=smoothstep(0.0,1.0,p);\n  vec3 st=vec3(7,137,235);\n  vec4 val=dot(ip,st) + vec4(0,st.y,st.z,st.y+st.z);\n  vec4 v = mix(fract(sin(val)*5672.655), fract(sin(val+st.x)*5672.655), p.x);\n  vec2 v2 = mix(v.xz,v.yw, p.y);\n  return mix(v2.x,v2.y,p.z);\n}\n\nfloat sea_octave(vec2 uv, float choppy) {\n    uv += noise(uv);\n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\nfloat water(vec3 p)\n{\n    float freq = 0.16;//SEA_FREQ;\n    float amp = 0.6;//SEA_HEIGHT;\n    float choppy = 4.;//SEA_CHOPPY;\n    float sea_time = 1. + iTime * 0.8;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    const mat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\n\n    float d, h = 0.0;    \n    for(int i = 0; i < 5/*ITER_GEOMETRY*/; i++) {        \n    \td = sea_octave((uv+sea_time)*freq,choppy);\n    \td += sea_octave((uv-sea_time)*freq,choppy);\n        h += d * amp;\n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h + 1.;\n}\n\nbool isGhost = true;\nbool isWater = true;\nfloat at = 0.;\nfloat at1 = 0.;\nfloat map(vec3 p)\n{\n    float sol = solid(p);\n    float wat = water(p);\n    float gho = ghost(p);\n    float d = smin(sol, wat, 0.1);\n    isWater = wat < sol;\n    isGhost = gho < d;\n    at += 0.1/(0.1+abs(gho));\n    at1 += 0.01/(0.1+abs(gho));\n    at -= at1;\n    at = (at + abs(at))/2.;\n\n    // moon\n    float d1 = length(p - lpos) - 30.;\n    moonlight += 0.5/(0.5+(d1 + abs(d1)));\n    d = min(d,d1);\n\n    d *= 0.7;\n    return d;\n}\n\nvec3 stars(vec2 uv)\n{\n    float iterations = 17.;\n    float formuparam = 0.53;\n\n    float volsteps = 20.;\n    float stepsize = 0.1;\n\n    float zoom = 0.200;\n    float tile = 0.850;\n    //float speed = 0.010;\n\n    float brightness = 0.0015;\n    float darkmatter = 0.300;\n    float distfading = 0.730;\n    float saturation = 0.850;\n\n    uv *= rot(iTime * 0.001);\n\tvec3 dir=vec3(uv*zoom,1.);\n\tfloat time=1.;\n\n\t//volumetric rendering\n\tfloat s=0.1,fade=0.2;\n\tvec3 v=vec3(0.);\n\tfor (float r=0.; r<volsteps; r++) {\n\t\tvec3 p=s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (float i=0.; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam; // the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6.) fade*=1.-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\treturn vec3(v*.01);\t\n\t\n}\n\nvec3 lin2srgb( vec3 cl )\n{\n\t//cl = clamp( cl, 0.0, 1.0 );\n\tvec3 c_lo = 12.92 * cl;\n\tvec3 c_hi = 1.055 * pow(cl,vec3(0.41666)) - 0.055;\n\tvec3 s = step( vec3(0.0031308), cl);\n\treturn mix( c_lo, c_hi, s );\n}\n\nvec3 srgb2lin( vec3 cs )\n{\n\tvec3 c_lo = cs / 12.92;\n\tvec3 c_hi = pow( (cs + 0.055) / 1.055, vec3(2.4) );\n\tvec3 s = step(vec3(0.04045), cs);\n\treturn mix( c_lo, c_hi, s );\n}\n\nvec3 getPixel(vec2 coord)\n{\n    vec2 uv = coord / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;   \n\n    float adv = (sin(iTime * 0.01)+1.) * 100.;\n\n    vec3 s = vec3(0,.6,0);\n    vec3 t = vec3(0,.6,1);\n\n    s.z += adv;\n    t.z += adv;\n\n    s -= tunnel(s);\n    t -= tunnel(t);\n\n    //vec3 r = normalize(vec3(uv, 1.));\n    vec3 cz = normalize(t - s);\n    vec3 cx = normalize(cross(vec3(0,1,0), cz));\n    vec3 cy = normalize(cross(cz,cx));\n\n    float fov = 1.;\n    vec3 r = normalize(uv.x * cx + uv.y * cy + cz * fov);\n\n    vec3 sky = vec3(0);\n\n    vec3 p = s;\n    vec2 off = vec2(0.01, 0.);\n    vec3 n;\n    float dd = 0.;\n    float i = 0.;\n    for(i = 0.; i < 100.; ++i)\n    {\n        float d = map(p);\n        dd += d;\n        if(dd > 1000.) \n        {\n            sky = stars(vec2(r.x,r.y));\n\n            break;\n        }\n        if(d < 0.001)\n        {\n            if(!isGhost)\n            {\n                if(!isWater) break;\n\n                n = normalize(map(p) - vec3(map(p - off.xyy), map(p - off.yxy), map(p - off.yyx)));\n\n                r = reflect(r, n);\n            }\n\n            d = 0.01;\n        }\n        \n        p += r*d;\n    }\n    \n    vec3 l = normalize(p - lpos);\n\n    float falloff = 3.;\n\n    vec3 col = vec3(0);\n    \n    //col += pow(1.-i/101., 8.);\n    col = vec3((dot(l, -n)*.5+.5) * (1. / (0.01 + dd * falloff)));\n    col += pow(at * .2, 0.5) * vec3(1,0,0);\n    col += pow(at1 * .2, 1.) * vec3(0,153./255.,153./255.);\n    col += pow(moonlight * 2., 2.);\n    col += pow(fire * 0.01, 2.) * vec3(1,0,0);\n    col += sky;\n\n    return col;\n}\n\nfloat hash( vec3 p ) {\n\tfloat h = dot(p,vec3(127.1,311.7, 527.53));\t\n    return fract(sin(h)*43758.5453123);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 col = getPixel(fragCoord);\n\n\n    col = pow(col,vec3(2.2));\n    col = lin2srgb(col);\n    //col = pow(col, vec3(3.));\n    //col = col + (vec3(col.r + col.g + col.b) / 3.) * hash(vec3(fragCoord, 1.0)) * 50.;\n\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7llGz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 97, 97, 188], [190, 190, 209, 209, 261], [263, 263, 291, 291, 319], [321, 321, 348, 348, 405], [407, 407, 439, 439, 474], [476, 476, 505, 505, 540], [542, 542, 571, 571, 606], [608, 608, 636, 636, 905], [907, 907, 937, 937, 1229], [1231, 1231, 1252, 1252, 1473], [1492, 1492, 1513, 1513, 2425], [2478, 2478, 2499, 2499, 2774], [2776, 2776, 2798, 2798, 2878], [2880, 2880, 2906, 2906, 3207], [3209, 3209, 3230, 3230, 3513], [3515, 3515, 3556, 3556, 3719], [3721, 3721, 3742, 3742, 4291], [4366, 4366, 4385, 4385, 4796], [4798, 4798, 4819, 4819, 5964], [5966, 5966, 5992, 6023, 6170], [6172, 6172, 6198, 6198, 6343], [6345, 6345, 6372, 6372, 7944], [7946, 7946, 7968, 7968, 8056], [8058, 8058, 8113, 8113, 8361]], "test": "valid"}
{"id": "7llGzj", "name": "Concert Lights With Noise", "author": "veroro", "description": ".", "tags": ["concertligthsnoise"], "likes": 0, "viewed": 137, "published": "Public API", "date": "1622458281", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nconst float Speed = 8.0;\n\n//Reference: https://thebookofshaders.com/10/\nfloat random(vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 uv = (fragCoord.xy * 40. - iResolution.xy * 0.5) / min(iResolution.x, iResolution.y);\n  vec3 col;\n  vec3 color = vec3(1., 1., random(uv));\n  for(float j = 0.0; j < 5.; j++)\n      for(float i = 1.; i < Speed; i++)\n      {\n          uv.x += uv.y * sin(iTime) / cos(iResolution.x);\n          col[int(j)] = clamp((abs(uv.x+uv.y)), 0.1, 1.0);\n      }\n  \n  vec3 bg = vec3(random(uv), random(uv), random(uv));\n  color = mix(col, bg, abs(sin(iTime)));\n  fragColor = vec4(vec3(color), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7llGzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 118, 141, 141, 216], [218, 218, 273, 273, 763]], "test": "valid"}
{"id": "7ls3R4", "name": "Complex Plane", "author": "NivBehar", "description": "mobius(sin(cos(z)))", "tags": ["complex"], "likes": 5, "viewed": 167, "published": "Public", "date": "1621681442", "time_retrieved": "2021-10-01T00:00:00", "image_code": "# define PI 3.141592654\n# define time iTime\n\n// ** different visualisations - use one at a time **\n# define use_boxes false\n# define use_texture false\n# define use_camera false\n# define use_colors true\n\n# define use_axis true\n# define AXIS_WIDTH 0.02\n// transparent axis range 0..1\n# define TRANSPARENT_AXIS 0.1\n\n\n// complex division\nvec2 c_dev(vec2 a, vec2 b){return vec2(a.x*b.x+a.y*b.y,-a.x*b.y+a.y*b.x)/(b.x*b.x+b.y*b.y);}\n\n// complex multiplication\nvec2 c_mul(vec2 a,vec2 b){return vec2(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);}\n\n// complex sin\nvec2 c_sin(vec2 a){return vec2(sin(a.x)*cosh(a.y),cos(a.x)*sinh(a.y));}\n\n// complex cos\nvec2 c_cos(vec2 a){return vec2(cos(a.x)*cosh(a.y),-sin(a.x)*sinh(a.y));}\n\n// mobius transformation\nvec2 mobius(vec2 z, vec2 a, vec2 b, vec2 c, vec2 d)\n{\n    vec2 z_new;\n    z_new = c_dev(c_mul(a,z) + b, c_mul(c,z) + d);\n    return z_new;\n}\n\nvec2 Log(vec2 p) // not sure about this\n{\n    vec2 q;\n    q.x = log(sqrt(p.x*p.x + p.y*p.y)); // natural log\n    q.y = atan(p.y,p.x);\n    return q;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv*=8.;\n    \n    vec3 col;\n\n    vec2 uv_old = uv; // temp for real plain\n    \n    // **apply changes to the uv plain here**\n    uv = c_cos(uv);\n    uv = c_sin(uv);\n    uv = mobius(uv,vec2(1.,0.),vec2(-1.,0.),vec2(1.,0.),vec2(1.,0.));\n    //uv = Log(uv);\n    \n    float timing = 0.475 + 0.525*sin(0.3*time);\n    uv = mix(uv_old, uv, timing <= 0.? 0.:timing); // linear interpolation between the real plain and the complex plain\n\n    // use texture instead of a plain\n    if(use_texture)\n    {\n        uv.x *= 0.1;\n        uv.x -= time*0.3;\n        col = texture(iChannel0, uv).xyz;\n    }\n    else if(use_camera)\n    {\n        uv *= .5;\n        col = texture(iChannel1, uv).xyz;\n    }\n    else if(use_colors)\n    {\n        //uv *= 3.;\n        col.x = sin(uv.x*2.);\n        col.y = cos(uv.y*2.);\n        col.z = sin(uv.x*7.)*cos(uv.y*7.);\n    }\n    else if(use_boxes)\n    {\n        //if(uv.y > 0.) // uncomment to use borders\n        //if(uv.x > 0.4 && uv.x < 1.)\n        {\n            // add lines\n            col = vec3(1,1,1);\n            col *= vec3(1,0,0) * smoothstep(0.,0.1,(0.5 + 0.5*sin(uv.y*10.))); // horizontal\n            col *= vec3(1,0,0) * smoothstep(0.,0.1,(0.5 + 0.5*sin(uv.x*10.))); // vertical\n        }\n    }\n    \n\n    // add white axis lines\n    if(use_axis)\n    {\n        float width = AXIS_WIDTH;\n        if(uv_old.y > -width && uv_old.y < width || uv_old.x > -width && uv_old.x < width )\n        {\n            col = mix(col, vec3(1), 1.-TRANSPARENT_AXIS);\n        }\n    }\n    \n    \n    fragColor = vec4(col,0.1);\n}", "image_inputs": [{"id": "Xsf3Rn", "previewfilepath": "/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture"}, {"id": "4sf3zn", "previewfilepath": "/presets/webcam.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/webcam.png", "ctype": "webcam"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ls3R4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[314, 334, 361, 361, 426], [428, 454, 480, 480, 526], [528, 543, 562, 562, 614], [616, 631, 650, 650, 703], [705, 730, 783, 783, 870], [872, 872, 913, 913, 1021], [1023, 1023, 1080, 1080, 2680]], "test": "error"}
{"id": "7ls3z2", "name": "Nicer Underwater Julia", "author": "seven_dc", "description": "Testing raymarcher to render julia fractal", "tags": ["juliaraymarcher"], "likes": 7, "viewed": 153, "published": "Public", "date": "1622476117", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 10\n#define MAX_DIST 10.\n#define SURF_DIST .1\n\nfloat julia( vec2 p, float time )\n{\n\tfloat ltime = 0.5-0.5*cos(time*0.36);\n    float zoom = pow( 0.9, 30.0*ltime );\n\tvec2 cen = vec2( 0.2055,0.01) + zoom*1.8;//*cos(4.0+2.0*ltime); \n\tvec2 c = vec2( -0.745, 0.186 ) - 0.245*zoom*(1.0-ltime*0.5);\n\tvec2 z = cen + (p-cen)*zoom;\n   \n\tvec2 dz = vec2( 1.0, 0.0 );\n\tfor( int i=0; i<60; i++ )\n\t{\n\t\tdz = 2.0*vec2(z.x*dz.x-z.y*dz.y, z.x*dz.y + z.y*dz.x );\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n\t\tif( dot(z,z)>200.0 ) break;\n\t}\n\tfloat d = sqrt( dot(z,z)/dot(dz,dz) )*log(dot(z,z));\n    \n\treturn sqrt( clamp( (1.0/zoom)*d, 0.0, 1.0 ) );\n}\n\nfloat GetDistance(vec3 point) {\n    return julia(vec2(point.x,point.y), point.z+iTime);\n}\n\nfloat RayMarch(vec3 rayOrgin, vec3 rayDirection) {\n\tfloat distance=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 point = rayOrgin + rayDirection * distance;\n        float surfaceDistance = GetDistance(point);\n        distance += surfaceDistance;\n        // Stop marching if we go too far or we are close enough of surface\n        if(distance>MAX_DIST || surfaceDistance<SURF_DIST) break;\n    }\n    \n    return distance;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // put 0,0 in the center\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n       \n    // camera   \n    vec3 rayOrgin = vec3(0, 1, 0);\n    vec3 rayDirection = normalize(vec3(uv.x, uv.y, 1));\n\n    float d = RayMarch(rayOrgin, rayDirection);\n    \n    vec3 col = vec3(d/100.,d/15.+uv.y,d/5.);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ls3z2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[64, 64, 99, 99, 657], [659, 659, 690, 690, 748], [750, 750, 800, 800, 1181], [1183, 1183, 1240, 1269, 1581]], "test": "valid"}
{"id": "7lsGz4", "name": "Circle Fractal (Ford Circles)", "author": "smjty", "description": "For each pixel the code performs a tree search to find the circle which contains that pixel.", "tags": ["2d", "fractal"], "likes": 11, "viewed": 118, "published": "Public", "date": "1621837475", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Source code for interactive piece: \"Touching Circles 1\" Twitter: @smjtyazdi\n//https://www.hicetnunc.xyz/objkt/95449\n\n#define PI 3.14159265\n#define DEL 0.002\n\n#define R vec3(255,171,225)/255.\n#define G vec3(255,230,230)/255.\n#define B vec3(166,133,226)/255.\n#define L vec3(250,245,245)/255.\n#define Z vec3(0,0,0)/955.\n\nfloat fx(vec2 r1 , vec2 r2,float r3){\n    float d1 = 2.*sqrt(r1.x*r3);\n    float d2 = 2.*sqrt(r2.x*r3);\n    float sol1 = r1.y + d1;\n    float sol2 = r1.y - d1;\n    if(abs(abs(sol1-r2.y)-d2)<abs(r1.y-r2.y)/1000. )return sol1;\n    return sol2;\n}\n\nfloat l(vec2 p,float r,float x){\n    return length(p-vec2(x,r))/r-1.;\n}\n\nvec3 l2(vec2 p,float r,float x){\n    return vec3(length(p-vec2(x,r))-r , atan(p.y-r,p.x-x),r);\n}\n\nbool check_in(vec2 p,float x1, float r1,float x2,float r2){\n    if(p.x < min(x1,x2) || p.x>max(x1,x2))return false;\n    if(p.y > (p.x-x1)*(r1-r2)/(x1-x2) + r1) return false;\n    return true;\n}\n\nvec3 col(float i){\n    if(i==1.)return R;\n    if(i==2.)return B;\n    if(i==3.)return G;\n}\n\nfloat trip(float x1,float x2){\n    if(3.!=x1 && 3.!=x2)return 3.;\n    if(1.!=x1 && 1.!=x2)return 1.;\n    return 2.;\n}\n\nfloat big(float r1,float r2){\n    return 1./pow(1./sqrt(min(r1,r2)) - 1./sqrt(max(r1,r2)),2.);\n}\n\nfloat smol(float r1,float r2){\n    return 1./pow(1./sqrt(r2) + 1./sqrt(r1),2.);\n}\n\nvec4  render(vec2 p,float t){\n\n    float sgn = sign(p.y);\n    p.y = abs(p.y);\n    \n    float r1 = 100.;\n    float ro = r1;\n    float r2 = 1./(0.1+0.3*abs(0.5+0.5*cos(t/24. *2.*PI) ));//iMouse.x/iResolution.x));\n    float kappa = sqrt(r1/r2);\n    if(abs(kappa*2.-round(kappa*2.))/2.<DEL) r2 = r1 / pow(round(kappa*2.)/2. + DEL ,2.);\n\n    float x1 = 0.;\n    float x2 = x1 + 2.*sqrt(r1*r2);\n\n\n    if(l(p,r1,x1)<0.0)return vec4(1.,sgn*l2(p,r1,x1)) ;\n    if(l(p,r2,x2)<0.0)return vec4(2.,sgn*l2(p,r2,x2));\n    \n    float c1 = 1.;\n    float c2 = 2.;\n    float c3 = 3.;\n    \n    float r3,x3;\n    \n    if(check_in(p,x1,r1,x2,r2))\n        r3 = smol(r1,r2);\n    else\n        r3 = big(r1,r2);\n\n    x3 = fx(vec2(r1,x1),vec2(r2,x2),r3);\n\n    if(l(p,r3,x3)<0.0)return vec4(3.,sgn*l2(p,r3,x3));\n    \n   \n    for(int i=0;i<80;i++){\n \n       if(r3>r1||r3>r2){\n            float rmax,xmax,cmax;\n            float rmin,xmin,cmin;\n            if(r1>r2){rmax=r1;xmax=x1;cmax=c1;rmin=r2;xmin=x2;cmin=c2;}\n                else{ rmax=r2;xmax=x2;cmax=c2;rmin=r1;xmin=x1;cmin=c1;}\n            if(check_in(p,x3,r3,xmin,rmin)){\n                float r3_old=r3;\n                x1 = x3; r1=r3; c1=c3;\n                x2 = xmin; r2=rmin; c2=cmin;\n                \n                r3 = smol(rmin,r3);\n                x3 = fx(vec2(r3_old,x3),vec2(rmin,xmin),r3);\n                c3 = trip(cmin,c3);\n                if(l(p,r3,x3)<0.0)return vec4(c3,sgn*l2(p,r3,x3));\n            }\n   \n            else{\n                if(!check_in(p,x3,r3,xmax,rmax)){\n                    float r3_old=r3;\n                    x1 = x3; r1=r3; c1=c3;\n                    x2 = xmax; r2=rmax; c2=cmax;\n\n                    r3 =big(r3,rmax);\n                    x3 = fx(vec2(r3_old,x3),vec2(rmax,xmax),r3);\n                    \n                    \n                    c3 = trip(cmax,c3);\n                    if(l(p,r3,x3)<0.0)return vec4(c3,sgn*l2(p,r3,x3));\n                }\n                else break;\n\n            }\n                \n       }\n       \n       else{\n           if(check_in(p,x1,r1,x3,r3)){\n           x2 = x3; r2 = r3;\n           c2 = c3;\n           }\n           else{\n               if(check_in(p,x2,r2,x3,r3)){\n               x1 = x3; r1 = r3;\n               c1 = c3;\n               }\n               else break;\n           }\n\n            r3 = 1./pow(1./sqrt(r1) + 1./sqrt(r2),2.);\n            x3 = fx(vec2(r1,x1),vec2(r2,x2),r3);\n            c3 = trip(c1,c2);\n\n            if(l(p,r3,x3)<0.0)return vec4(c3,sgn*l2(p,r3,x3));\n       }\n    }\n    \n    return vec4(0.);\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 p = (fragCoord.xy  - iResolution.xy/2.0)/iResolution.y*1000.;\n   float scale = 1.5*(0.5 + 1.* iMouse.y/iResolution.y);\n   p *= scale;\n\n   vec3 colr;\n   vec3 result = vec3(0.);\n   for(float k=0.;k<3.;k+=1.){\n       vec4 get = render(p,iTime - k/180.);\n       if(get.x==0.)colr = Z;\n       else {\n           colr = col(get.x);\n           vec2 pos = abs(1.-abs(get.y/get.w))*vec2(cos(get.z),sin(get.z));\n           colr*=  3./(3. + pow(length(pos-vec2(-0.5,0.5) ),2.) );\n           colr +=  0.02/(0.1 + length(pos-vec2(-0.5,0.5) ) )*L;\n           colr*=min(abs(get.y/scale*1.5),1.);\n        }\n        result+=colr/(1.+k);\n   }\n   fragColor = vec4(result/1.7,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lsGz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[320, 320, 357, 357, 563], [565, 565, 597, 597, 636], [638, 638, 670, 670, 734], [736, 736, 795, 795, 928], [930, 930, 948, 948, 1019], [1021, 1021, 1051, 1051, 1138], [1140, 1140, 1169, 1169, 1236], [1238, 1238, 1268, 1268, 1319], [1321, 1321, 1350, 1350, 3854], [3857, 3857, 3914, 3914, 4585]], "test": "error"}
{"id": "7lX3Rj", "name": "Electric Whiskey", "author": "jayfero", "description": "12 variations. I like these 6.\n\nsq_IDEA_2\nsq_IDEA_123\nsq_IDEA_CRAZY_1\nsq_IDEA_CRAZY_12_WEIRD\nsq_IDEA_CRAZY_12_WEIRD_ALT\nsq_IDEA_FINAL_2", "tags": ["2d", "distortion", "plasma", "sphere", "blending", "glow", "electric", "electricity"], "likes": 2, "viewed": 71, "published": "Public", "date": "1622407794", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\nForked from \"Electric Whiskers\"\nby Dean Alex 2016, dean[at]neuroid co uk\n\nMessing around with (unclamped) sphere normal vectors.\n\n---------------\n\nElectric Whiskey\"\nby Jay Fero\n\nedit. changed the sqrt. just playing around. great job Dean.\n\n*/\n\n// change MACRO_SQ [FUNC]\n\n// sq_IDEA_1\n// sq_IDEA_2\n// sq_IDEA_3\n// sq_IDEA_123\n// sq_IDEA_CRAZY_1\n// sq_IDEA_CRAZY_2\n// sq_IDEA_CRAZY_12\n// sq_IDEA_CRAZY_12_WEIRD\n// sq_IDEA_CRAZY_12_WEIRD_ALT\n// sq_IDEA_FINAL_1\n// sq_IDEA_FINAL_2\n// sq_IDEA_FINAL_3\n\n#define MACRO_SQ sq_IDEA_123\n\n\n\nfloat cool_sq(in vec3 param){\n    return param.x * param.y / abs(param.x) * param.z;\n}\n\nfloat compound_sq(in float f)\n{\nreturn cool_sq(vec3(f, .61, 0.9))\n+ cool_sq(vec3(f, 1.43, .17))\n* cool_sq(vec3(f,.37, 1.61))\n+ cool_sq(vec3(f, 1.43, .17))\n/ cool_sq(vec3(f,.37, 1.61));\n}\nfloat sq_IDEA_1( in float f ){\n    return f * 0.9;\n}\nfloat sq_IDEA_2( in float f ){\n    return f * 1.1 / abs(f);\n}\nfloat sq_IDEA_3( in float f ){\n    return compound_sq(f);\n}\nfloat sq_IDEA_123( in float f ){\n    return sq_IDEA_1(f) * sq_IDEA_2(f)- sq_IDEA_3(f) + sq_IDEA_1(f);\n}\n\nfloat sq_IDEA_CRAZY_1( in float f ){\n    return sq_IDEA_123(f) * sq_IDEA_123(f)- sq_IDEA_123(f) + sq_IDEA_123(f);\n}\nfloat sq_IDEA_CRAZY_2( in float f ){\n    return sq_IDEA_123(f) - sq_IDEA_123(f)+ sq_IDEA_123(f) * sq_IDEA_123(f);\n}\n\nfloat sq_IDEA_CRAZY_12( in float f ){\n    return sq_IDEA_CRAZY_1(f) * sq_IDEA_CRAZY_2(f);\n}\nfloat sq_IDEA_CRAZY_12_WEIRD( in float f ){\n    return sq_IDEA_CRAZY_1(-f) * sq_IDEA_CRAZY_2(-f);\n}\nfloat sq_IDEA_CRAZY_12_WEIRD_ALT( in float f ){\n    return sq_IDEA_CRAZY_1(-f*1.2) * sq_IDEA_CRAZY_2(f*11.);\n}\nfloat sq_IDEA_FINAL_1( in float f ){\n    return sq_IDEA_CRAZY_2(f)  * sq_IDEA_CRAZY_12_WEIRD_ALT(f);\n}\nfloat sq_IDEA_FINAL_2( in float f ){\n    return sq_IDEA_CRAZY_2(f) - sq_IDEA_CRAZY_1(f) * sq_IDEA_CRAZY_12_WEIRD_ALT(f);\n}\nfloat sq_IDEA_FINAL_3( in float f ){\n    return sq_IDEA_FINAL_1(f) + sq_IDEA_FINAL_2(f - 0.3);\n}\n\nfloat sq( in float f ){\n   return MACRO_SQ(f);   \n}\n\nvec3 sq3( in vec3 v ){\n    return vec3(\n        sq(v.x),\n        sq(v.y),\n        sq(v.z)\n    );\n}\n         \nvec3 sh( in vec3 pos, in vec2 uv )\n{\n    vec2 xy = (uv.xy - pos.xy) / pos.z;\n    float len = dot(xy,xy);\n    return vec3( xy, sq( 1.0 - len ));\n}\nfloat tsin( in float mf ){\n    return sin( iTime * mf);\n}\nfloat tcos( in float mf ){\n    return cos( iTime * mf);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 norm;\n    float w = iResolution.x;\n    float h = iResolution.y;\n    float m = min(w,h);\n    \n    vec3 s1 = sh(\n        vec3( w * 0.5, h * 0.5, m * 0.5 ),\n        vec2( fragCoord.x, fragCoord.y )\n    );\n    vec3 s2 = sh(\n        vec3( (tsin(1.7)*0.4 + 0.5)*w, (tcos(1.3)*0.4 + 0.5)*h, m * 0.1 ),\n        vec2( fragCoord.x, fragCoord.y )\n    );\n    vec3 s3 = sh(\n        vec3( (tsin(0.5)*0.3 + 0.5)*w, (tcos(-2.0)*0.4 + 0.5)*h, m * 0.5 ),\n        vec2( fragCoord.x, fragCoord.y )\n    );\n    vec3 s4 = sh(\n        vec3( (tcos(-0.31)*0.6 + 0.5)*w, (tsin(-0.4)*0.2 + 0.5)*h, m * 3.3 ),\n        vec2( fragCoord.x, fragCoord.y )\n    );\n    \n    //\n    norm = sq3( cross( s2.yzx, s1.zxy ));\n    norm = sq3( cross( norm, s3.zxy ));\n    norm = sq3( cross( -norm, s4.xyz ));\n    \n    \n    //\n    \n    float mag = length( norm );\n    float a = pow( smoothstep( 1.0, 5.0, mag ), 0.5 );\n    float s = atan( norm.z, norm.x ) / 6.283185307179586;\n    float t = asin( norm.y ) / 3.14159265358979;\n    fragColor = texture( iChannel0, vec2( s*5.1 + iTime*0.2, t * s ));\n    fragColor.g = min( fragColor.g, fragColor.b );\n    vec3 lightDir = normalize( vec3( tcos(1.5) * -1.6, -0.3, tsin(1.5) * 5.0 ));\n    float mflight = max(dot( norm, lightDir), 0.0);\n    float dis1 = 1.0 - length( norm - lightDir ) / 2.0;\n    mflight += pow( dis1, 10.0) * 2.5;\n    fragColor.rgb *= mflight;\n    vec3 l1p = vec3( tsin(1.7) * 0.6, tcos(2.5) * 0.5, -tsin(0.5) * 0.6 );\n    vec3 l1c = vec3( 1.0, 2.0, 3.0 );\n    float dis = 1.0 - length( norm - l1p ) / 2.0;\n    fragColor.rgb += l1c * pow( dis, 0.8 );\n    fragColor = mix( fragColor, vec4(1.0,0.0,0.0,1.0), a );\n}\n", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lX3Rj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[533, 533, 562, 562, 619], [621, 621, 652, 652, 807], [808, 808, 838, 838, 860], [861, 861, 891, 891, 922], [923, 923, 953, 953, 982], [983, 983, 1015, 1015, 1086], [1088, 1088, 1124, 1124, 1203], [1204, 1204, 1240, 1240, 1319], [1321, 1321, 1358, 1358, 1412], [1413, 1413, 1456, 1456, 1512], [1513, 1513, 1560, 1560, 1623], [1624, 1624, 1660, 1660, 1726], [1727, 1727, 1763, 1763, 1849], [1850, 1850, 1886, 1886, 1946], [1948, 1948, 1971, 1971, 1999], [2001, 2001, 2023, 2023, 2099], [2110, 2110, 2146, 2146, 2255], [2256, 2256, 2282, 2282, 2313], [2314, 2314, 2340, 2340, 2371], [2374, 2374, 2431, 2431, 4074]], "test": "error"}
{"id": "7lX3RM", "name": "Thing 2", "author": "ebenupton", "description": "Another variation on the theme of rotating coloured squares.", "tags": ["lavalamp"], "likes": 1, "viewed": 79, "published": "Public", "date": "1621755191", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float squares (float x, float y, float rep)\n{\n    if ((int(floor(x/rep))&1) == (int(floor(y/rep))&1))\n        return 1.0;\n    else\n        return 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float f = fragCoord.x/1000.0+fragCoord.y/2000.0+1.0+iTime/10.0;\n    \n    mat2 m = mat2 (cos(f), sin(f), -sin(f), cos(f));\n    \n    vec2 k = (fragCoord.xy-iResolution.xy/2.0)*m;\n\n\tvec3 pixel;\n\n    pixel.r = squares(k.x, k.y+iTime*200.0, 96.0);\n    pixel.g = squares(k.x+iTime*100.0, k.y, 112.0);\n    pixel.b = squares(k.x+iTime*50.0, k.y+iTime*50.0, 200.0);\n\n\tfragColor = vec4(pixel, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lX3RM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[154, 154, 211, 211, 606]], "test": "valid"}
{"id": "7lXGDr", "name": "Diffuse Lighting Model", "author": "trigophers", "description": "Basic ray tracer featuring diffuse lighting. Does not take into account distance from light source, shaded only by normal vector and light occlusion.", "tags": ["raytracer", "diffuse"], "likes": 2, "viewed": 47, "published": "Public", "date": "1621889052", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define maxDist 10000.\nvec3 center;\nvec3 ray;\nfloat rdist;\nvec3 color;\nvec3 normal;\n\nvoid sphere(vec4 posRad, vec3 sColor) {\n    vec3 obj = posRad.xyz - center;\n    vec3 temp = vec3(dot(obj, ray), dot(obj, obj), 0.);\n    if ((temp.x>0.0) && (posRad.w*posRad.w > (temp.y - temp.x*temp.x))) {\n        temp.z = sqrt(posRad.w*posRad.w - (temp.y - temp.x*temp.x));\n        if ((temp.y > posRad.w*posRad.w) && rdist > temp.x - temp.z) {\n            rdist = temp.x - temp.z;\n            normal = normalize(center+ray*rdist-posRad.xyz);\n            color = sColor;\n        }\n    }\n}\n\nvoid scene() {\n    sphere(vec4(0, 5, 30, 5), vec3(1, 0, 0));\n    sphere(vec4(5, 4, 30, 4), vec3(0, 1, 0));\n    sphere(vec4(0, -1000000, 30, 1000000), vec3(0.2, 0.5, 0.5));\n}\n\nvec3 raytrace(vec2 uv) {\n    center = vec3(0, 5, 0);\n    ray = normalize(vec3(uv, 1));\n    rdist = maxDist;\n    scene();\n    if (rdist<maxDist) {\n        vec3 light = vec3(cos(iTime)*10., 30., sin(iTime)*10.+30.);\n        vec3 lightVec = normalize(light-(center+rdist*ray));\n        vec3 saveC = vec3(clamp(dot(lightVec, normal), 0., 1.));\n        vec3 saveOC = color;\n        center = center+rdist*ray+normal/100000.;\n        ray = lightVec;\n        rdist = maxDist;\n        scene();\n        if (rdist<maxDist) {\n            return saveOC*0.02;\n        }\n        return vec3((saveC+0.02)*saveOC);\n    } else {\n        return vec3(0);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-iResolution.xy/2.)/iResolution.yy;\n    vec3 superSample = vec3(0.);\n    superSample += raytrace(uv+vec2(1./iResolution.x/2., -1./iResolution.x/2.));\n    superSample += raytrace(uv+vec2(-1./iResolution.x/2., -1./iResolution.x/2.));\n    superSample += raytrace(uv+vec2(1./iResolution.x/2., 1./iResolution.x/2.));\n    superSample += raytrace(uv+vec2(-1./iResolution.x/2., 1./iResolution.x/2.));\n    superSample /= 4.;\n    fragColor = vec4(pow(superSample, vec3(0.4545)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lXGDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[85, 85, 124, 124, 574], [576, 576, 590, 590, 749], [751, 751, 775, 775, 1393], [1395, 1395, 1452, 1452, 1956]], "test": "valid"}
{"id": "7s2SRd", "name": "Cigar at night", "author": "Daizuukee", "description": "A man smoking a cigar in the nightsky.\nA lot of things here are quite hacky this is more of a test to recreate a drawing as ashader.", "tags": ["sky", "night", "smoke", "human", "cigar", "sillouhette"], "likes": 6, "viewed": 242, "published": "Public API", "date": "1620849702", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define Cig1 vec3(0.4, 0.2902, 0.2196)\n#define Cig2 vec3(0.8588, 0.7882, 0.7686)\n#define Light1 vec3(0.902, 0.4941, 0.3843)\n#define Light2 vec3(0.7686, 0.5843, 0.0863)\n#define PIXELSIZE 100.\n\n//#define LSD\n\n#define CRT\n\n\n#define CLCOL ((Light1 - Light2) * abs(max(cos(iTime * 2. * PI),sin(iTime * 2. * PI))) + Light2)\n#define PI_TWO\t\t\t1.570796326794897\n#define PI\t\t\t\t3.141592653589793\n#define TWO_PI\t\t\t6.283185307179586\n\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smax( float a, float b, float k )\n{\n    k *= 1.4;\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*h/(6.0*k*k);\n}\n\nvec2 hash( vec2 p ) {  \t\t\t\t\t\t// rand in [-1,1]\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\treturn -1. + 2.*fract(sin(p+20.)*53758.5453123);\n}\n\n//https://www.shadertoy.com/view/MtcGRl\nvec2 GetGradient(vec2 intPos, float t) {\n    \n    // Uncomment for calculated rand\n    //float rand = fract(sin(dot(intPos, vec2(12.9898, 78.233))) * 43758.5453);;\n    \n    // Texture-based rand (a bit faster on my GPU)\n    float rand = hash(intPos / 64.0).r;\n    \n    // Rotate gradient: random starting rotation, random rotation rate\n    float angle = 6.283185 * rand + 4.0 * t * rand;\n    return vec2(cos(angle), sin(angle));\n}\n\n\nfloat Pseudo3dNoise(vec3 pos) {\n    vec2 i = floor(pos.xy);\n    vec2 f = pos.xy - i;\n    vec2 blend = f * f * (3.0 - 2.0 * f);\n    float noiseVal = \n        mix(\n            mix(\n                dot(GetGradient(i + vec2(0, 0), pos.z), f - vec2(0, 0)),\n                dot(GetGradient(i + vec2(1, 0), pos.z), f - vec2(1, 0)),\n                blend.x),\n            mix(\n                dot(GetGradient(i + vec2(0, 1), pos.z), f - vec2(0, 1)),\n                dot(GetGradient(i + vec2(1, 1), pos.z), f - vec2(1, 1)),\n                blend.x),\n        blend.y\n    );\n    return noiseVal / 0.7; // normalize to about [-1..1]\n}\n\n\n\nvec2 uv;\n\n\nbool Smoke( in vec2 p) {\n    p -= vec2(0.2,0.1);\n    p.x += sin(p.y * 20. - iTime * PI) * p.y / 2. * pow(abs(sin(iTime * 0.25 * PI)),0.5);\n    if(p.x - 0.005 < p.y && p.x + 0.0025 >= p.y * 0.75 && p.x > 0.)\n        return true;\n    return false;\n}\n\nvec3 Cigar( in vec2 p) {\n    vec3 shade = vec3(0.4,0.3,0.2) * (1. - (p.y - 0.08) * (1./0.08) * 2.);\n    if(p.y > 0.08 && p.y < 0.1 && p.x > 0. && p.x < 0.2) {\n        if(p.x < 0.05)\n            return Cig1 - shade;\n        if(p.x < 0.18)\n            return Cig2 - shade;\n        return CLCOL;\n    }\n    return vec3(0);\n}\n\nfloat FaceDist(in vec2 p) {\n    float f = -0.3;\n    //HEAD\n    float po = abs(p.y - 0.225) * 2.;\n    f += (0.1 - po*po*po*po*po) * 3.;\n    //HAT\n    if(p.y > 0.3) {\n        po = (0.4-p.y)*3.25;\n        f = smax(f,po*po*po - 0.075,-0.2) + 0.05;\n    }\n    //EYE HOLE\n    f = smin(f,abs(p.y - 0.25),0.15);\n    //NOSE\n    f = smax(f, 0.02-abs(p.y - 0.175),-0.2);\n    //MOUTH\n    f = smax(f, 0.01-abs(p.y - 0.11),-0.2);\n    f = smax(f, 0.01-abs(p.y - 0.09),-0.2);\n    //SHOULDERS\n    f = smax(f, 0.02-abs(p.y + 0.2),0.1);\n    return f - p.x;\n}\n\nfloat star( in vec2 p) {\n    float x = Pseudo3dNoise(vec3(p * PIXELSIZE / 2.,iTime));\n    if(x > 0.75)\n        return (x-0.75) * (1./0.75); \n    return 0.;\n}\n\nvec3 getColor( in vec2 p) {\n    float smok = 0.;\n    if(Smoke(p))\n        smok = max(0.,0.6 - length(p));\n    vec3 c;\n    if((c = Cigar(p)) != vec3(0)) \n        return vec3(c);\n    float face = FaceDist(p);\n    if(face > 0.)\n        return CLCOL * (0.1 - face);\n\n    float star = star(p);\n    return CLCOL * max(0.2 - distance(p,vec2(0.2,0.09)),0.) + smok + star;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord) {\n    uv = fragCoord.xy / iResolution.yy;\n    uv.x -= 0.25;\n    uv.y -= 0.1;\n#ifdef CRT\n    if(uv.y > (0.75-fract(iTime * 0.1)) * 1.5 && uv.y < (0.75-fract(iTime * 0.1)) * 1.5 + 0.05) {\n        uv.y = (0.75-fract(iTime * 0.1)) * 1.5 + 0.05;\n    }\n#endif\n#ifdef LSD\n    fragColor = vec4(getColor(floor(uv * PIXELSIZE) / PIXELSIZE).r,\n                     getColor(floor((uv + vec2(0.01) * sin(iTime * PI)) * PIXELSIZE) / PIXELSIZE).g,\n                     getColor(floor((uv + vec2(-0.01,sin(iTime * PI) * 0.01) * sin(iTime * PI * 1.5432)) * PIXELSIZE) / PIXELSIZE).b,\n                     1);\n#else\n#ifdef CRT\n    fragColor = vec4(getColor(floor((uv + vec2(0.0,0.116) / PIXELSIZE) * PIXELSIZE) / PIXELSIZE).r,\n                     getColor(floor((uv + vec2(0.116,-0.116) / PIXELSIZE) * PIXELSIZE) / PIXELSIZE).g,\n                     getColor(floor((uv + vec2(-0.116,-0.116) / PIXELSIZE) * PIXELSIZE) / PIXELSIZE).b,\n                     1);\n#else\n    fragColor = vec4(getColor(floor(uv * PIXELSIZE) / PIXELSIZE),1);\n#endif\n#endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s2SRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[422, 474, 515, 515, 587], [589, 641, 682, 682, 773], [775, 775, 796, 821, 943], [945, 985, 1025, 1204, 1415], [1418, 1418, 1449, 1449, 2039], [2054, 2054, 2078, 2078, 2301], [2303, 2303, 2327, 2327, 2623], [2625, 2625, 2652, 2652, 3163], [3165, 3165, 3189, 3189, 3322], [3324, 3324, 3351, 3351, 3689], [3691, 3691, 3745, 3745, 4776]], "test": "valid"}
{"id": "7s2SRm", "name": "Superposition314", "author": "Domain314", "description": "My personal interpretation of a \"Superposition\": Vibration between two states.\n\nOnly watchable @50+fps\n\nIf no music => check for iChannel0 (audio must be loaded) => pause => set back time => start again\n\nYou can disable the colour, at the top of the code.", "tags": ["raymarching", "dark", "superposition", "audioresponsive", "meditaion"], "likes": 4, "viewed": 86, "published": "Public", "date": "1619959811", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n// Colour switch:\n//  0 = !Colour, 1 = Colour\n#define COLOUR_CON 1\n\n// Smooth HSV: https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb);\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nmat2 Rot (float i) {\n    float s = sin(i), c = cos(i);\n    return mat2(c, -s, s, c);\n}\n\nfloat Box(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat Sphere(vec3 p, vec4 s) {\n    return length(p-s.xyz)-s.w;\n}\n\nfloat MainBox(vec3 p, vec2 fft) {\n    vec3 bp = p;\n    bp.xz *= Rot(iTime*fft.x);\n    vec3 sp = p;\n      \n    float boxDist = Box(bp, vec3(1.5));\n    float sphereDist = Sphere(sp, vec4(0, 0, 0, 2.));\n    \n    return mix(sphereDist, boxDist, sin(fft.y*5.)*1.5);\n}\n\nfloat SphereGroup(vec3 p, float _fft2) {\n    float fft2 = _fft2*0.4;\n    vec3 sp = p + vec3(0, 0.5, 0);\n    sp.xz *= Rot(iTime*0.2);\n    //sp.yz *= Rot(fft2);\n    \n    float sphereDist2 = Sphere(sp, vec4(3.+fft2, 0, 3.+fft2, 0.8));    \n    float sphereDist = Sphere(sp, vec4(-3.-fft2, 0, 3.+fft2, 0.8));    \n    float d = min(sphereDist2, sphereDist);     \n    sphereDist = Sphere(sp, vec4(3.+fft2, 0, -3.-fft2, 0.8));    \n    d = min(d, sphereDist); \n    sphereDist = Sphere(sp, vec4(-3.-fft2, 0, -3.-fft2, 0.8));    \n    d = min(d, sphereDist); \n    return d;\n}\n\nfloat Cross(vec3 p, float fft) {\n    vec3 bp = p-vec3(0, 1.9, 0);\n    bp.xz *= Rot(-iTime*fft);\n    \n    float box = Box(bp, vec3(1.*fft, 0.1, 1.*fft));    \n    float boxE = Box(bp-vec3(1, 0, 1), vec3(0.9*fft, 0.25, 0.8*fft));\n    box = max(-boxE, box);\n    boxE = Box(bp-vec3(-1, 0, -1), vec3(0.9*fft, 0.25, 0.8*fft));\n    box = max(-boxE, box);\n    boxE = Box(bp-vec3(-1, 0, 1), vec3(0.9*fft, 0.25, 0.8*fft));\n    box = max(-boxE, box);\n    boxE = Box(bp-vec3(1, 0, -1), vec3(0.9*fft, 0.25, 0.8*fft));\n    return max(-boxE, box);\n}\n\nfloat GetDist(vec3 p) {   \n    //float planeDist= p.y+2.;\n    \n    float fft = texelFetch(iChannel0, ivec2(1., 0), 0).x;\n    float fft2 = texelFetch(iChannel0, ivec2(1., 1), 0).x;\n        \n    //float d = min(planeDist, );\n    float d = min(MainBox(p, vec2(fft, fft2)), SphereGroup(p, fft2));   \n    d = min(d, Cross(p, fft));\n    \n    return d;\n}\n\nfloat GetDistP(vec3 p) {   \n    float planeDist= p.y+2.;\n       \n    float d = planeDist;\n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.;\n    for(int i = 0; i < MAX_STEPS; i++){\n        vec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if (dO > MAX_DIST || dS < SURF_DIST) break;\n    }    \n    return dO;\n}\n\nfloat RayMarchP(vec3 ro, vec3 rd) {\n    float dO = 0.;\n    for(int i = 0; i < MAX_STEPS; i++){\n        vec3 p = ro + rd*dO;\n        float dS = GetDistP(p);\n        dO += dS;\n        if (dO > MAX_DIST || dS < SURF_DIST) break;\n    }    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p);\n    vec2 e = vec2(.01, 0.);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy), \n        GetDist(p-e.yxy), \n        GetDist(p-e.yyx));\n    return normalize(n);\n}\n\nfloat GetLightP(vec3 p) {\n    vec3 lightPos = vec3(-4., 6., -4.);\n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = RayMarchP(p+n*SURF_DIST*2., l);\n    if (d < length(lightPos-p)) dif *=.5;\n    return dif;\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(-4., 6., -4.);\n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    if (d < length(lightPos-p)) dif *=.5;\n    return dif;\n}\n\nvec3 cam(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p);\n    vec3 r = normalize(cross(vec3(0, 1., 0), f));\n    vec3 u = cross(f,r);\n    vec3 c = p+f*z;\n    vec3 i = c + uv.x*r + uv.y*u;\n    return normalize(i-p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy + vec2(0.92, -0.1);\n    \n    vec3 col = vec3(0.);\n    \n    vec3 ro = vec3(1., 4., -5.);\n    \n    // For cam-movement with the mouse, delete following 2 lines and uncomment the 2 lines after. \n    //ro.yz *= Rot(0.1);\n    //ro.xz *= Rot(-0.9*6.2831);    \n    ro.yz *= Rot(-m.y);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = cam(uv, ro, vec3(0,0,0), .7);    \n    \n    float d = RayMarch(ro, rd);    \n    vec3 p = vec3(0.);\n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \n    \tfloat dif = GetLight(p);\n    \tcol = vec3(dif);\n    }\n    \n    float fft = texelFetch(iChannel0, ivec2(1., 0), 0).x;\n    float fft2 = texelFetch(iChannel0, ivec2(1., 1), 0).x;\n    vec3 hsl = vec3(fft2*0.5+.4, 1., 1.);\n    vec3 rgb = hsv2rgb_smooth(hsl);\n    \n    if (COLOUR_CON == 1) col*=rgb;\n    //col = col*rgb;    \n    col = pow(col, vec3(.6));\n    \n    d = RayMarchP(ro, rd);    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \n    \tfloat dif = GetLightP(p);\n    \tcol += vec3(dif);\n    }\n    \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4lfXz2", "previewfilepath": "https://soundcloud.com/ultimae/aes-dana-alep-offset", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/ultimae/aes-dana-alep-offset", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s2SRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[136, 189, 223, 223, 381], [383, 383, 403, 403, 469], [471, 471, 498, 498, 579], [581, 581, 611, 611, 645], [647, 647, 680, 680, 909], [911, 911, 951, 951, 1474], [1476, 1476, 1508, 1508, 2009], [2011, 2011, 2034, 2068, 2358], [2360, 2360, 2384, 2384, 2470], [2472, 2472, 2506, 2506, 2722], [2724, 2724, 2759, 2759, 2976], [2978, 2978, 3002, 3002, 3192], [3194, 3194, 3219, 3219, 3483], [3485, 3485, 3509, 3509, 3772], [3774, 3774, 3818, 3818, 4005], [4007, 4007, 4064, 4064, 5181]], "test": "error"}
{"id": "7s2XRd", "name": "Fork  fractal  NikolaErceg", "author": "NikolaErceg", "description": "Creating multiple shapes with one SDF evaluation by repeatedly rotating and folding space", "tags": ["fractalcineshader"], "likes": 0, "viewed": 1255, "published": "Public API", "date": "1620851580", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 palette(float d){\n\treturn mix(vec3(2.3,2.42,2.24),vec3(.0,0.31,1.2),d);\n}\n\nvec2 rotate(vec2 p,float a){\n\tfloat c = cos(a);\n    float s = sin(a);\n    return p*mat2(c,s,-s,c);\n}\n\nfloat map(vec3 p){\n    for( int i = 0; i<5; ++i){\n        float t = iTime*1.0;\n        p.xz =rotate(p.xz,t);\n        p.xy =rotate(p.xy,t*0.001);\n        p.xz = abs(p.xz);\n        p.xz-=0.24;\n\t}\n\treturn dot(sign(p),p)/13.;\n}\n\nvec4 rm (vec3 ro, vec3 rd){\n    float t = 3.;\n    vec3 col = vec3(0.01);\n    float d;\n    for(float i =0.; i<86.; i++){\n\t\tvec3 p = ro + rd*t;\n        d = map(p)*.86;\n        if(d<0.18){\n            break;\n        }\n        if(d>55.){\n        \tbreak;\n        }\n        //col+=vec3(1.6,3.8,3.8)/(100.*(d));\n        col+=palette(length(p)*.1)/(222.*(d));\n        t+=d;\n    }\n    return vec4(col,0./(d*10.));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-(iResolution.xy/2.))/iResolution.x;\n\tvec3 ro = vec3(41.,41.,-0.);\n    ro.xz = rotate(ro.xz,iTime);\n    vec3 cf = normalize(-ro);\n    vec3 cs = normalize(cross(cf,vec3(55,3.,57.)));\n    vec3 cu = normalize(cross(cf,cs));\n    \n    vec3 uuv = ro+cf*3. + uv.x*cs + uv.y*cu;\n    \n    vec3 rd = normalize(uuv-ro);\n    \n    vec4 col = rm(ro,rd);\n    \n    \n    fragColor = col;\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"fractal pyramid\",\n\t\"description\": \"\",\n\t\"model\": \"car\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s2XRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 78], [80, 80, 108, 108, 180], [182, 182, 200, 200, 405], [407, 407, 434, 434, 813], [814, 814, 871, 871, 1268]], "test": "valid"}
{"id": "7s2XRm", "name": "Cute jelly fish", "author": "long_march", "description": "This is a cute cute jelly fish", "tags": ["cute", "fun", "underwater", "jellyfish"], "likes": 12, "viewed": 141, "published": "Public", "date": "1620044292", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define xsquish 4.0 // (sin(iTime * 0.5)  * 2.0 + 2.0)\n#define ysquish 2.0 // (sin(iTime * 0.75) * 2.0 + 2.0)\n\nfloat time;\n#define time_scale float(1.5);\n\nstruct wave {\n    float f;\n    float a;\n    float s;\n};\n\nwave waves[] = wave[](\n    wave(5.0, 500.0, 3.0),\n    wave(7.0, 1200.0, 6.0),\n    wave(18.0, 1200.0, -6.0)\n);\n\nfloat get_waves(float value, wave waves[3]) {\n    float sum = 0.0;\n    for (int n = 0; n < waves.length(); n += 1) {\n        wave h = waves[n];\n        sum += sin(value * h.f + time * h.s) / h.a;\n    }\n    return sum;\n}\n\nfloat move(float speed, float amount) {\n    float value = sin(time * speed) * 0.5 + 0.5;\n    return 1.0 + value * amount;\n}\n\n#define sqr(x) (x*x)\n\nfloat rand(vec3 value) {\n    value = sin(value);\n    float random = dot(value, vec3(12.9898, 78.233, 37.719));\n    random = fract(sin(random) * 143758.5453);\n    return random;\n}\n\nvoid mainImage(out vec4 fragment_colour, in vec2 fragment_coordinate) {\n    vec2 pure_uv = fragment_coordinate / iResolution.xy - 0.5;\n    pure_uv.x *= iResolution.x / iResolution.y;\n\n    pure_uv *= 1.4;\n\n    #define pixels float(96)\n    pure_uv = floor(pure_uv * pixels) / pixels;\n    time = iTime * time_scale;\n\n    vec2 uv = pure_uv;\n    uv.y *= 0.9;\n    uv.x =  tanh(uv.x * xsquish) / xsquish;\n    uv.y = atanh(uv.y * ysquish) / ysquish;\n\n    fragment_colour = vec4(0.0, 0.15, 0.2, 1.0) * (1.0 - length(pure_uv) / 2.0);\n\n    float tendrils[5] = float[](\n        0.000, 0.768, 0.983, 0.491, -0.353\n    );\n\n    for (int n = 0; n < tendrils.length(); n += 1) {\n        float r = tendrils[n];\n        float position = uv.x + 0.05 * float(n) - 0.095;\n        float a = get_waves(uv.y * 10.0 + r * 4.0, waves) * 250.0;\n        float value = 1.0 - max(0.0, smoothstep(a, a+0.9, position * 50.0)\n                                   + smoothstep(a, a-0.9, position * 50.0));\n\n        if (value > 0.5) value = 1.0;\n        else value = 0.0;\n\n        fragment_colour += value * max(0.05 - uv.y + r / 24.0, 0.0)\n                                 * max(sqr(uv.y + r / 9.0 + 0.8), 0.0)\n                                 * 5.0;\n    }\n    uv = pure_uv;\n\n    float theta = atan(uv.x, uv.y);\n    float radius = length(uv);\n\n    radius += get_waves(theta, waves) * 1.5;\n\n    float mirrored_x = uv.x;\n    if (mirrored_x < 0.5) {\n        mirrored_x += 0.5 - mirrored_x;\n    }\n    float mirrored_theta = atan(mirrored_x, uv.y);\n    radius += sin(mirrored_theta * 10.0 - time * 4.0) / 50.0;\n\n    float threshold = 0.2;\n    float outer = sqr(sqr(sqr(radius * 4.5)));\n    float inner = (1.0 - radius) / 2.0;\n    if (radius < threshold && uv.y > 0.0 + get_waves(uv.x, waves) * 8.0) {\n        float r = inner * 0.2 + outer * move(0.2723, 1.0);\n        float g = inner * 0.3 + outer * move(0.224, 1.0);\n        float b = inner * 0.4 + outer * move(0.3151, 1.0);\n\n        fragment_colour *= sqr(inner);\n        fragment_colour += vec4(r, g, b, 1);\n    }\n\n    uv = pure_uv;\n    float noise = rand(vec3(uv, mod(time, 10.0))) * 0.01;\n    fragment_colour += noise;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s2XRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[324, 324, 369, 369, 543], [545, 545, 584, 584, 668], [692, 692, 716, 716, 870]], "test": "error"}
{"id": "7s2XRz", "name": "Distance to Circle Inverted Box", "author": "oneshade", "description": "Distance to a circle inverted box by converting its edges to circle segments. Has artifacts due to very extreme cases, WIP.", "tags": ["2d", "sdf", "circle", "box", "inverted", "arc"], "likes": 7, "viewed": 92, "published": "Public", "date": "1620865855", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Utilities\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\n\n// SDFs\nfloat sdBox(in vec2 p, in vec2 b) {\n    p = abs(p) - b;\n    return length(max(p, 0.0)) + min(0.0, max(p.x, p.y));\n}\n\n// ax: vec2(cos(axis), sin(axis))\n// ap: vec2(cos(aperture), sin(aperture))\nfloat sdArc(in vec2 p, in vec2 ax, in vec2 ap, in float r) {\n    p = vec2(dot(p, ax), abs(p.y * ax.x - p.x * ax.y));\n    return p.y * ap.x < p.x * ap.y ? abs(length(p) - r) : length(p - ap * r);\n}\n\nfloat cInvSegment(in vec2 p, in vec2 a, in vec2 aInv, in vec2 b, in vec2 bInv) {\n    vec2 ba = b - a;\n\n    // The closest point on the line segment to the origin will invert the farthest away.\n    // Since the line stretches to infinity, its inversion will wrap around to the origin.\n    // The center is then halfway between the farthest point on the line's inversion and the origin.\n    // The radius is then the distance from a point on the line's inversion to the center.\n    vec2 cen = a - ba * dot(a, ba) / dot(ba, ba);\n    cen = 0.5 * cen / dot(cen, cen);\n    float rad = length(cen);\n\n    // The arc lies on one side of the line passing through the end points.\n    // Taking a point on the line's inversion (within the segment only) and projecting\n    // it onto the line passing through endpoints allows the direction in which the\n    // arc lies to be calculated.\n    vec2 far = 0.5 * (a + b), baInv = bInv - aInv;\n    far = far / dot(far, far);\n    vec2 faInv = far - aInv;\n    far = normalize(faInv - baInv * dot(faInv, baInv) / dot(baInv, baInv));\n\n    // Return distance to circle segment\n    aInv -= cen;\n    float ap = dot(aInv, far) / length(aInv);\n    return sdArc(p - cen, far, vec2(ap, sqrt(1.0 - ap * ap)), rad);\n}\n\n// Precomputes values and then combines the distance to each edge and the sign\nfloat sdCircleInvBox(in vec2 p, in mat3 t, in vec2 b, in float r) {\n    float rr = r * r;\n    p /= rr;\n\n    // Transform and invert through a circle\n    vec2 v1 = (vec3(-b,         1.0) * t).xy, v1Inv = v1 / dot(v1, v1);\n    vec2 v2 = (vec3( b.x, -b.y, 1.0) * t).xy, v2Inv = v2 / dot(v2, v2);\n    vec2 v3 = (vec3( b,         1.0) * t).xy, v3Inv = v3 / dot(v3, v3);\n    vec2 v4 = (vec3(-b.x,  b.y, 1.0) * t).xy, v4Inv = v4 / dot(v4, v4);\n\n    // Combine edges\n    float d =  cInvSegment(p, v1, v1Inv, v2, v2Inv);\n    d = min(d, cInvSegment(p, v2, v2Inv, v3, v3Inv));\n    d = min(d, cInvSegment(p, v3, v3Inv, v4, v4Inv));\n    d = min(d, cInvSegment(p, v4, v4Inv, v1, v1Inv));\n\n    // Get sign and return signed distance\n    p = abs((vec3(p / dot(p, p), 1.0) * inverse(t)).xy) - b;\n    return d * rr * sign(max(p.x, p.y));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Boilerplate\n    vec2 center = 0.5 * iResolution.xy;\n    vec4 mouse = (vec4(iMouse.xy, abs(iMouse.zw)) - center.xyxy) / iResolution.y * 4.0;\n    vec2 uv = (fragCoord - center) / iResolution.y * 4.0;\n\n    // Default before interaction\n    if (ivec2(iMouse.xy) == ivec2(0)) mouse.xy = vec2(cos(iTime), sin(iTime)) * 0.75;\n\n    vec2 a = mouse.xy;\n    vec2 b = mouse.zw;\n    float r = 1.0;\n\n    float cInvBox = sdCircleInvBox(uv, mat3(1.0, 0.0, mouse.x, 0.0, 1.0, mouse.y, 0.0, 0.0, 1.0), vec2(0.25), r) * 0.5;\n    if (mod(iTime * 0.5, 2.0) < 1.0) cInvBox = sdBox(uv * r * r / dot(uv, uv) - mouse.xy, vec2(0.25));\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(cInvBox) * vec3(0.1, 0.4, 0.7);\n\tcolor *= 1.0 - exp(-4.0 * abs(cInvBox));\n\tcolor *= 0.8 + 0.2 * cos(140.0 * cInvBox);\n    color = mix(color, vec3(0.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.015, abs(cInvBox)));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s2XRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[94, 102, 137, 137, 217], [219, 295, 355, 355, 491], [493, 493, 573, 573, 1728], [1730, 1809, 1876, 1876, 2630], [2632, 2632, 2687, 2706, 3603]], "test": "error"}
{"id": "7sBSDy", "name": "Fake 3D \"Simplest 3D\"", "author": "Hexdigest", "description": "This is the same effect Art of Code made with a proper camera and rays, but I decided to fake how it works. There's a saying: \"If you don't fake it, you won't make it. - xreg \" ;-)  ", "tags": ["3d", "fake", "simplest", "hexdigest"], "likes": 0, "viewed": 43, "published": "Public", "date": "1620914682", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - iResolution.xy*.5)/iResolution.y;\n    float u = smoothstep(.2-cos(iTime)/10., .21-cos(iTime)/10., length(vec2(uv.x + sin(iTime)/1.5, uv.y)));\n    fragColor = vec4(u, u, u, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sBSDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 267]], "test": "valid"}
{"id": "7sBSWG", "name": "大龙猫 - Quicky#052", "author": "totetmatt", "description": "Quicky done in the ICE, slight difference from Bonzo (mainly texFFT)", "tags": ["quicky"], "likes": 5, "viewed": 162, "published": "Public API", "date": "1620900139", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define fGlobalTime iTime\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\n#define flikflok(t) (floor(t)+pow(fract(t),.25))\nvec2 sdf(vec3 p) {\n  float bt = iTime*.5;\n  float bt3 = iTime*.33;\n   p.z +=floor(bt3*10.);\n   p.xy *=rot(p.z*.785*.1);\n  vec3 op = p;    \n  float tt = texture(iChannel1,p.xz*.1).r*.1;\n\n    vec2 h;\n    vec3 pp = p;\n    p = abs(p)-1.5;\n    h.x = length(p)-1.;\n  p.xy = abs(p.x) < abs(p.y)  ?p.yx:p.xy;\n  \n  \n    p.xz/=3.;\n    p.xz = asin(sin(p.zx));\n    p.xz*=3.;\n    h.x = min(h.x,length(p.xz)-.5-clamp(cos(abs(p.y)*4.+fGlobalTime*180./60.*4.),-.25+sin(p.y*10.)*.1,.25)*.4);   \n     h.y = 1.;\n      h.x*=.7;\n   return h;\n}\nvec2 nv=vec2(-.001,.001);\n#define q(s) s*sdf(p+s).x\nvec3 norm(vec3 p){return normalize(q(nv.xyy)+q(nv.yxy)+q(nv.yyx)+q(nv.xxx));}\nvec3 pal(float t){return .5+.5*cos(6.28*(1.*t+vec3(0.,.3,.7)));}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    float tt = fract(iTime);\n  vec3 bcol = log(1.+tt*100.11)*pal(.5+uv.x);\n  \n  float ttt =texture(iChannel1,uv*10.).r;\n  float pp = fract(iTime);\n\t\n  \n  vec3 ro=vec3(0.,0.,-5.),rd=normalize(vec3(uv,1.-pp*ttt)),rp=ro;\n  vec3 light = vec3(1.,2.,-3.);\n  vec3 acc = vec3(0.);\n  vec3 col =vec3(0.);\n  for(float i=0.;i<=69.;i++){\n      vec2 d = sdf(rp);\n    \n        \n          acc+=mix(vec3(1.,.7,.2),vec3(.1,.5,.7),step(.5,i/69.))*exp(20.*-abs(d.x))/(10.);\n            \n       if(d.x<=0.005){\n         vec3 n = norm(rp);\n        col *= vec3(1.)*max(0.,dot(n,normalize(light-rp)));\n      \n        break;\n        }\n        rp+=rd*d.x;\n   }\n  col +=acc;\n \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sBSWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 44, 44, 91], [141, 141, 159, 159, 663], [716, 716, 734, 734, 793], [794, 794, 812, 812, 858], [859, 859, 916, 966, 1734]], "test": "error"}
{"id": "7sBXWW", "name": "girl bunny -dragon", "author": "jorge2017a1", "description": "girl bunny -dragon", "tags": ["points", "poly", "girlbunnydragon", "2ddraw"], "likes": 8, "viewed": 173, "published": "Public API", "date": "1620220716", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//por jorge2017a1 ----jorgeFloresP---5/may/2021\n// referencia \n////-------------------\n/// IQ funciones....librerias\n//https://www.shadertoy.com/view/tlGBW3\n//Created by manu210404 in 2021-03-13\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r; }\n\nvec3 ponerBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S(abs( distObj),0.0));\n  return colOut;\n}\n\n#define POLY(N) (in vec2 p, in vec2[N] v) {const int n=v.length();float d=dot(p-v[0],p-v[0]);float s=1.;for(int i=0,j=n-1;i<n;j=i,i++){vec2 e=v[j]-v[i];vec2 w=p-v[i];vec2 b=w-e*clamp(dot(w,e)/dot(e,e),0.,1.);d=min(d,dot(b,b));bvec3 cond=bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);if(all(cond)||all(not(cond))) s=-s;}return s*sqrt(d);}\n\nfloat sdPoly32 POLY(32)\nvec2 pt32[ 32]=vec2[](  \nvec2(.54,.79),vec2(.29,.65),vec2(.29,.60),vec2(.29,.60),vec2(.29,.59),\nvec2(.27,.60),vec2(.25,.60),vec2(.24,.59),vec2(.24,.57),vec2(.24,.54),\nvec2(.25,.53),vec2(.28,.52),vec2(.29,.51),vec2(.31,.50),vec2(.32,.51),\nvec2(.34,.51),vec2(.36,.51),vec2(.36,.49),vec2(.37,.48),vec2(.45,.45),\nvec2(.48,.44),vec2(.51,.44),vec2(.54,.45),vec2(.61,.48),vec2(.63,.50),\nvec2(.65,.51),vec2(.65,.53),vec2(.67,.61),vec2(.67,.62),vec2(.68,.65),\nvec2(.69,.68),vec2(.54,.79) );\n\nfloat sdPoly11 POLY(11)\nvec2 pt11[ 11]=vec2[](  \nvec2(.26,.52),vec2(.28,.47),vec2(.29,.42),vec2(.30,.38),vec2(.34,.33),\nvec2(.38,.27),vec2(.39,.28),vec2(.39,.38),vec2(.37,.45),vec2(.36,.49),\nvec2(.26,.52) );\n\n\nfloat sdPoly18 POLY(18)\nvec2 pt18[ 18]=vec2[](  \nvec2(.67,.61),vec2(.70,.62),vec2(.70,.52),vec2(.70,.45),vec2(.69,.40),\nvec2(.66,.34),vec2(.63,.29),vec2(.60,.27),vec2(.61,.30),vec2(.62,.33),\nvec2(.62,.36),vec2(.60,.34),vec2(.57,.33),vec2(.59,.36),vec2(.62,.41),\nvec2(.62,.45),vec2(.62,.59),vec2(.67,.61) );\n\nfloat sdPoly24 POLY(24)\nvec2 pt24[ 24]=vec2[](  \nvec2(.11,.45),vec2(.16,.46),vec2(.26,.47),vec2(.66,.61),vec2(.70,.62),\nvec2(.73,.63),vec2(.76,.65),vec2(.78,.67),vec2(.77,.71),vec2(.75,.75),\nvec2(.71,.79),vec2(.65,.82),vec2(.51,.86),vec2(.44,.87),vec2(.36,.86),\nvec2(.27,.83),vec2(.22,.79),vec2(.18,.74),vec2(.17,.66),vec2(.17,.59),\nvec2(.18,.57),vec2(.17,.54),vec2(.15,.49),vec2(.11,.45) );\n\nfloat sdPoly11b POLY(11)\nvec2 pt11b[ 11]=vec2[](  \nvec2(.33,.76),vec2(.25,.92),vec2(.24,.96),vec2(.25,1.00),vec2(.45,1.00),\nvec2(.40,.96),vec2(.40,.95),vec2(.39,.94),vec2(.40,.93),vec2(.41,.80),\nvec2(.33,.76) );\n\nfloat sdPoly11c POLY(11)\nvec2 pt11c[ 11]=vec2[](  \nvec2(.54,.82),vec2(.61,.99),vec2(.62,1.00),vec2(.83,1.00),vec2(.76,.96),\nvec2(.74,.94),vec2(.72,.93),vec2(.69,.88),vec2(.69,.86),vec2(.63,.80),\nvec2(.54,.82) );\n\nfloat sdPoly13 POLY(13)\nvec2 pt13[ 13]=vec2[](  \nvec2(.32,.75),vec2(.36,.78),vec2(.40,.80),vec2(.53,.82),vec2(.63,.80),\nvec2(.65,.78),vec2(.64,.77),vec2(.58,.79),vec2(.51,.79),vec2(.43,.78),\nvec2(.37,.76),vec2(.33,.74),vec2(.32,.75) );\n\nfloat sdPoly9 POLY(9)\nvec2 pt9[ 9]=vec2[](  \nvec2(.58,.68),vec2(.59,.69),vec2(.61,.69),vec2(.63,.68),vec2(.63,.68),\nvec2(.61,.69),vec2(.59,.69),vec2(.58,.68),vec2(.58,.68) );\n\nfloat sdPoly9b POLY(9)\nvec2 pt9b[ 9]=vec2[](  \nvec2(.39,.67),vec2(.42,.68),vec2(.43,.68),vec2(.47,.67),vec2(.47,.67),\nvec2(.43,.68),vec2(.42,.68),vec2(.39,.68),vec2(.39,.67) );\n\nfloat sdPoly7 POLY(7)\nvec2 pt7[ 7]=vec2[](  \nvec2(.37,.59),vec2(.46,.57),vec2(.45,.61),vec2(.44,.63),vec2(.42,.64),\nvec2(.39,.63),vec2(.37,.59) );\n\nfloat sdPoly10 POLY(10)\nvec2 pt10[ 10]=vec2[](  \nvec2(.58,.58),vec2(.62,.58),vec2(.63,.59),vec2(.63,.61),vec2(.63,.63),\nvec2(.62,.63),vec2(.60,.63),vec2(.59,.63),vec2(.58,.61),vec2(.58,.58) );\n\nfloat sdPoly8 POLY(8)\nvec2 pt8[ 8]=vec2[](  \nvec2(.43,.58),vec2(.43,.60),vec2(.43,.61),vec2(.42,.63),vec2(.39,.63),\nvec2(.38,.62),vec2(.38,.59),vec2(.43,.58) );\n\nfloat sdPoly9c POLY(9)\nvec2 pt9c[ 9]=vec2[](  \nvec2(.57,.58),vec2(.61,.58),vec2(.62,.61),vec2(.61,.62),vec2(.60,.63),\nvec2(.59,.63),vec2(.58,.61),vec2(.58,.60),vec2(.57,.58) );\n\nfloat sdPoly11d POLY(11)\nvec2 pt11d[ 11]=vec2[](  \nvec2(.54,.57),vec2(.55,.56),vec2(.55,.55),vec2(.55,.55),vec2(.54,.54),\nvec2(.54,.54),vec2(.55,.55),vec2(.56,.55),vec2(.55,.56),vec2(.55,.57),\nvec2(.54,.57) );\n\nfloat sdPoly8b POLY(8)\nvec2 pt8b[ 8]=vec2[](  \nvec2(.49,.51),vec2(.51,.51),vec2(.52,.52),vec2(.53,.52),vec2(.54,.51),\nvec2(.53,.51),vec2(.51,.52),vec2(.49,.51) );\n\nfloat sdPoly9d POLY(9)\nvec2 pt9d[ 9]=vec2[](  \nvec2(.49,.51),vec2(.51,.51),vec2(.52,.51),vec2(.54,.51),vec2(.54,.51),\nvec2(.53,.50),vec2(.51,.50),vec2(.50,.51),vec2(.49,.51) );\n\nfloat sdPoly10b POLY(10)\nvec2 pt10b[ 10]=vec2[](  \nvec2(.31,.51),vec2(.33,.51),vec2(.34,.52),vec2(.35,.51),vec2(.36,.50),\nvec2(.36,.49),vec2(.34,.48),vec2(.33,.48),vec2(.31,.50),vec2(.31,.51) );\n\nfloat sdPoly9e POLY(9)\nvec2 pt9e[ 9]=vec2[](  \nvec2(.66,.54),vec2(.66,.54),vec2(.68,.54),vec2(.69,.53),vec2(.68,.52),\nvec2(.67,.51),vec2(.66,.51),vec2(.65,.51),vec2(.66,.54) );\n\nfloat sdPoly12 POLY(12)\nvec2 pt12[ 12]=vec2[](  \nvec2(.25,.57),vec2(.25,.59),vec2(.26,.59),vec2(.27,.59),vec2(.29,.57),\nvec2(.29,.55),vec2(.30,.54),vec2(.31,.53),vec2(.29,.53),vec2(.28,.53),\nvec2(.25,.54),vec2(.25,.57) );\n\nfloat sdPoly29 POLY(29)\nvec2 pt29[ 29]=vec2[](  \nvec2(.00,.35),vec2(.07,.40),vec2(.12,.45),vec2(.14,.46),vec2(.36,.47),\nvec2(.36,.48),vec2(.59,.47),vec2(.59,.47),vec2(.65,.45),vec2(.71,.44),\nvec2(.74,.40),vec2(.75,.36),vec2(.79,.25),vec2(.80,.16),vec2(.89,.07),\nvec2(.72,.07),vec2(.70,.10),vec2(.68,.14),vec2(.65,.13),vec2(.61,.10),\nvec2(.57,.07),vec2(.01,.07),vec2(.11,.10),vec2(.14,.12),vec2(.16,.16),\nvec2(.16,.23),vec2(.14,.29),vec2(.00,.21),vec2(.00,.35) );\n\nfloat sdPoly7b POLY(7)\nvec2 pt7b[ 7]=vec2[](  \nvec2(.50,.30),vec2(.52,.26),vec2(.53,.23),vec2(.53,.23),vec2(.52,.26),\nvec2(.50,.30),vec2(.50,.30) );\n\nfloat sdPoly7c POLY(7)\nvec2 pt7c[ 7]=vec2[](  \nvec2(.19,.32),vec2(.22,.30),vec2(.21,.27),vec2(.21,.27),vec2(.22,.30),\nvec2(.20,.32),vec2(.19,.32) );\n\nfloat sdPoly7d POLY(7)\nvec2 pt7d[ 7]=vec2[](  \nvec2(.69,.37),vec2(.68,.35),vec2(.72,.28),vec2(.73,.28),vec2(.69,.35),\nvec2(.70,.37),vec2(.69,.37) );\n\nfloat sdPoly5 POLY(5)\nvec2 pt5[ 5]=vec2[](  \nvec2(.13,.29),vec2(.21,.34),vec2(.21,.34),vec2(.13,.29),vec2(.13,.29) );\n\nfloat sdPoly7e POLY(7)\nvec2 pt7e[ 7]=vec2[](  \nvec2(.38,.63),vec2(.38,.63),vec2(.37,.63),vec2(.37,.63),vec2(.38,.63),\nvec2(.38,.62),vec2(.38,.63) );\n\nfloat sdPoly7f POLY(7)\nvec2 pt7f[ 7]=vec2[](  \nvec2(.38,.62),vec2(.37,.62),vec2(.36,.62),vec2(.36,.62),vec2(.37,.62),\nvec2(.38,.61),vec2(.38,.62) );\n\nfloat sdPoly7g POLY(7)\nvec2 pt7g[ 7]=vec2[](  \nvec2(.38,.60),vec2(.36,.60),vec2(.35,.60),vec2(.35,.60),vec2(.36,.60),\nvec2(.38,.60),vec2(.38,.60) );\n\nfloat sdPoly7h POLY(7)\nvec2 pt7h[ 7]=vec2[](  \nvec2(.63,.63),vec2(.64,.62),vec2(.65,.63),vec2(.65,.63),vec2(.64,.62),\nvec2(.63,.62),vec2(.63,.63) );\n\nfloat sdPoly7i POLY(7)\nvec2 pt7i[ 7]=vec2[](  \nvec2(.63,.61),vec2(.64,.61),vec2(.66,.61),vec2(.66,.61),vec2(.64,.61),\nvec2(.63,.61),vec2(.63,.61) );\n\n\nfloat sdPoly20 POLY(20)\nvec2 pt20[ 20]=vec2[](  \nvec2(.16,.23),vec2(.17,.22),vec2(.26,.25),vec2(.36,.27),vec2(.40,.27),\nvec2(.52,.22),vec2(.66,.28),vec2(.69,.29),vec2(.72,.27),vec2(.74,.23),\nvec2(.73,.18),vec2(.68,.14),vec2(.65,.14),vec2(.55,.06),vec2(.00,.06),\nvec2(.09,.10),vec2(.13,.11),vec2(.16,.15),vec2(.16,.23),vec2(.16,.23) );\n\n\nfloat sdPoly16 POLY(16)\nvec2 pt16[ 16]=vec2[](  \nvec2(.36,.47),vec2(.40,.45),vec2(.46,.42),vec2(.50,.42),vec2(.51,.42),\nvec2(.57,.45),vec2(.57,.46),vec2(.59,.47),vec2(.60,.42),vec2(.59,.35),\nvec2(.57,.30),vec2(.56,.30),vec2(.51,.41),vec2(.44,.29),vec2(.38,.41),\nvec2(.36,.47) );\n\nconst vec3 colPelo=vec3(0.79,0.51,0.37);\nconst vec3 colPiel=vec3(0.98,0.92,0.82);\nconst vec3 colPiel2=vec3(0.88,0.82,0.72);\nconst vec3 colNegro=vec3(0.0);\nconst vec3 colGris=vec3(0.55);\nconst vec3 colBlanco=vec3(1.0);\nconst vec3 colRojo=vec3(1.0,0.0,0.0);\n\nvec3 RostroChica(in vec2 pp, vec3 col) \n{\n  vec2 p=pp;\n  \n   \n   float sd1 = sdPoly32(p, pt32); \n   float sd2 = sdPoly11(p, pt11);\n   float sd3 = sdPoly18(p, pt18);\n   float sd4 = sdPoly24(p, pt24);\n   float sd5 = sdPoly11b(p,pt11b);\n   float sd6 = sdPoly11c(p,pt11c);\n   float sd7 = sdPoly13(p,pt13);\n   float sd8 = sdPoly9(p,pt9);\n   float sd9 = sdPoly9b(p,pt9b);\n   float sd10 = sdPoly7(p,pt7);\n   float sd11 = sdPoly10(p,pt10);\n   float sd12 = sdPoly8(p,pt8);\n   float sd13 = sdPoly9c(p,pt9c);\n   float sd14 = sdPoly11d(p,pt11d);\n   float sd15 = sdPoly8b(p,pt8b);\n   float sd16 = sdPoly9d(p,pt9d);\n   float sd17 = sdPoly10b(p,pt10b);\n   float sd18 = sdPoly9e(p,pt9e);\n   float sd19 = sdPoly12(p,pt12);\n   float sd20 = sdPoly29(p,pt29);\n   float sd21 = sdPoly7b(p,pt7b);\n   float sd22 = sdPoly7c(p,pt7c);\n   float sd23 = sdPoly7d(p,pt7d);\n   float sd24 = sdPoly5(p,pt5);\n   float sd25 = sdPoly7e(p,pt7e);\n   float sd26 = sdPoly7f(p,pt7f);\n   float sd27 = sdPoly7g(p,pt7g);\n   float sd28 = sdPoly7h(p,pt7h);\n   float sd29 = sdPoly7i(p,pt7i);\n   float sd30 = sdPoly20(p,pt20);\n   float sd31 = sdPoly16(p,pt16);\n   float sd32= sdCircle( p-vec2(0.4,0.60), 0.01 );\n   float sd33= sdCircle( p-vec2(0.59,0.59), 0.01 );\n   \n   col= ponerBorde(colPiel,col,sd20); // cuerpo\n   col= ponerBorde(colPelo,col,sd2); //pelo1\n   col= ponerBorde(colPelo,col,sd3); //pelo2\n   col= ponerBorde(colPelo,col,sd4); //pelo3\n   col= ponerBorde(colPiel,col,sd1); //rostro\n   col= ponerBorde(colGris,col,sd5); //colita 1\n   col= ponerBorde(colGris,col,sd6); //colita 2\n   col= ponerBorde(colGris,col,sd7); //centro colita \n   col= ponerBorde(colNegro,col,sd8); // ceja izq\n   col= ponerBorde(colNegro,col,sd9); // ceja der\n   col= ponerBorde(colBlanco,col,sd10); // ojo izq\n   col= ponerBorde(colBlanco,col,sd11); // ojo der\n   col= ponerBorde(colGris,col,sd12); //  pupila izq\n   col= ponerBorde(colGris,col,sd13); // pupila der\n   col= ponerBorde(colGris,col,sd14); // nariz\n   col= ponerBorde(colRojo,col,sd15); // labio sup\n   col= ponerBorde(colRojo,col,sd16); // labio inf\n   col= ponerBorde(colRojo,col,sd17); // bola\n   col= ponerBorde(colRojo,col,sd18); // bola 2\n   col= ponerBorde(colPiel2,col,sd19); // oreja\n   col= ponerBorde(colPiel2,col,sd21); // linea busto\n   col= ponerBorde(colPiel2,col,sd22); // linea axila\n   col= ponerBorde(colNegro,col,sd23); // \n   col= ponerBorde(colNegro,col,sd24); // linea 2 axila\n   col= ponerBorde(colNegro,col,sd25); //\n   col= ponerBorde(colNegro,col,sd26); //\n   col= ponerBorde(colNegro,col,sd27); //\n   col= ponerBorde(colNegro,col,sd28); //\n   col= ponerBorde(colNegro,col,sd29); //\n   col= ponerBorde(colNegro,col,sd30); // ropa\n   col= ponerBorde(colNegro,col,sd31); // ropa\n   \n   col = mix(col,colNegro ,S( sd32,0.0));\n   col = mix(col,colNegro ,S( sd33,0.0));\n   \n  return col;\n}\nconst vec4 red = vec4( 0.8, 0.1 ,0.2, 1.0 ) ;\nconst vec4 blue = vec4(0.0, 0.0 ,1.0,1 );\n\nvec4 fondo( vec2 pp)\n{\n    vec2 p=pp;\n    vec4 color = vec4( 1.0 );\n\tfloat xOffset = 0.5*sin(iTime);\n    //rays\n    float r = cos( atan( p.y, p.x + xOffset ) * 16.0 );\n    float f = smoothstep( r, r + 0.1, length( p )*0.25 );\n\tcolor = mix( blue, color, f );\n    //circle\n    r = 0.6;\n    f = smoothstep( r, r + 0.01, length( p + vec2( xOffset, 0.0 ) ) );\n    color = mix( red, color, f );\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   vec2 uv = (fragCoord-iResolution.xy)/iResolution.y;\n    //posicion\n    vec2 p=uv+vec2(1.5,0.9);\n    p*=1.7;\n    p.x*=0.7;\n    p.y*=0.5; p.y+=0.15;\n    vec4 colf=fondo(p*1.0);\n    vec3 col=colf.xyz;\n     col= RostroChica( p,col*2.0);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sBXWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[304, 304, 339, 339, 363], [365, 365, 425, 425, 549], [7815, 7815, 7856, 7856, 10629], [10719, 10719, 10741, 10741, 11127], [11129, 11129, 11186, 11186, 11454]], "test": "valid"}
{"id": "7sjSRt", "name": "round bang", "author": "spectrum", "description": "more bang", "tags": ["circular", "bang"], "likes": 2, "viewed": 248, "published": "Public API", "date": "1620836665", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 hash12(float t) {\n    float x = fract(sin(t*674.31)*432.1)*6.2384;\n    float y = fract(sin(t*472.1)*201.9);\n    return vec2(sin(x), cos(x))*y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 color = vec3(0);\n\n    float t = iTime * 4.;\n    \n    float dt = 0.;\n    \n\n    for (float i=600.; i>0.; i--) {\n        float brightness = .0001*(sin((i*3.)+t)+3.);\n        vec2 dir = hash12(i+1.)*2.;\n        float tt = fract(iTime*.2)*10.;\n        dt = length(uv-dir*tt);\n        color += brightness/dt;\n    }\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sjSRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 149], [151, 151, 208, 208, 622]], "test": "valid"}
{"id": "7sjSWm", "name": "Fork Trippy Vis NikolaErce 162", "author": "NikolaErceg", "description": "My first attempt at making an audio visualizer.", "tags": ["audio", "trippy"], "likes": 0, "viewed": 373, "published": "Public API", "date": "1620402187", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//const float pi = 3.14159265358979323846264338327950288419716939937510; //just pi\nconst float ni = 3.0778979877877658472;\n\n/*vec2 rot(vec2 a, float c){\nfloat g = c*pi/33.0;\nvec2 b = vec2(cos(g),sin(g));        \nreturn vec2(a.x*b.x - a.x*b.x, a.x*a.y + a.y*a.b);\n}*/\n\nvec2 rot(vec2 a, float c){ //mine\nfloat p = length(a);\na = normalize(a);\nfloat ang_x = atan(a.y,a.x);\nang_x +=  c*ni/17.9;\nreturn vec2(p*cos(ang_x), p*sin(ang_x));    \n}\n\n\nfloat box(vec3 p, vec3 s){//mine\nvec3 a = abs(p)-s;\nreturn max(max(a.b, a.b),a.b);\n}\n\n/*\nvec3 r(vec3 p, vec3 c){//not originally thought by me\nreturn mod(p,c)-0.009*c; \n}\n*/\n\nvec3 r(vec3 p, vec3 c){ \nreturn ((p/c - floor(p/c))*c)-7.95*c;\n}\n\n\nfloat dis(vec3 p){ \nreturn min(length(mod(p,9.6)-6.60)-4.7,\n          box(r(vec3(5.0, -5.0, 5.0)-p, vec3(66.0,160.0,6.0)), vec3(150.01,50.5,5.5))\n          );\n}\n\nbool trac(out vec3 p, vec3 d, out float dd){\n    for(int i = 0; i < 81; i++){\n        dd = dis(p);\n        if(dd < 0.01){return true;}\n        p+=d*dd;\n    }\n    return false;\n}\n\n/*\nvec3 norm(vec3 p){//not originally by me\nvec2 k = vec2(3.0,3.0);\nreturn normalize(\nvec3(\ndis(p+k.xyy)-dis(p-k.xyy),\ndis(p+k.yxy)-dis(p-k.yxy),\ndis(p+k.yyx)-dis(p-k.yyx)\n));\n}\n*/\n\nvec3 norm(vec3 p, float dist){ \n    return normalize(vec3(dist-dis(vec3(p.x-0.11,p.yz)),dist-dis(vec3(p.x,p.y-0.11,p.z)),\n                          dist-dis(vec3(p.xy,p.z-0.0001))));\n}\n\n\n\nvec3 shadow(vec3 p, vec3 lig){\n    vec3 d = normalize(lig - p);\n    float dist,lgg;\n    for(int i = 1; i < 78; i++){\n     lgg = length(lig-p)-1.3;\n     dist = min(lgg, dis(p));\n     if(dist < 0.2)break;  \n     p+=d*dist;    \n    } \n    if(dist < 9.5052 && dist == lgg){\n    return vec3(0.8);\n    }\n    \n    vec3 n = norm(p,dist);\n    float ang =0.9-dot(-d,n);\n    vec3 c = vec3((cos(iTime-ang*0.0)+0.0)*0.12, (sin(iTime+ang*01.0)+1.0)*0.5, 1.0);\n    return c*ang;\n}\n\nvec3 volumetrics(vec3 prevp, vec3 p, vec3 lig){\n    const int iter = 6;\n    vec3 dp = (p-prevp)/float(iter);\n    \n    vec3 vcol;\n    \n    for(int i = 0; i < iter; i++){\n    vcol += shadow(prevp+dp*float(i+1), lig);\n    }\n    \n    return vcol/float(iter);\n}\n\nfloat rough(float a, float c){\nreturn exp(-pow(1.0*(1.0-a)*(c-11.0) - a ,17.0))/(ni*a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float sp = texture(iChannel0, vec2(0.0 / 512.0, 0.0)).x;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(0.5);\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= vec2(2.0+sp*0.9);\n    \n    vec3 d = normalize(vec3(uv.x, 0.5, uv.y));\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = mouse * 2.0 - 1.0;\n    \n    d = abs(-vec3(rot(d.xz, iTime*0.0),d.y));\n    d.yz = rot(d.yz, cos(iTime*0.1 - sp*0.0000)*90.0);\n    d.xy = rot(d.xy, sin(iTime*0.0000001 + sp*0.00000)*360.0);\n    vec3 p = vec3(1.0);\n    vec3 prevp = p;\n    vec3 col = vec3(0.55);\n    vec3 lig = vec3(sin(iTime)*1.0,6.0,2.0+cos(iTime)*5.0);\n    float dd;\n    if(trac(p,d,dd)){\n        vec3 n = norm(p,dd);\n        vec3 light = normalize(lig-p);\n        \n        col = vec3(0.6)*max(dot(n,light),0.1);\n        col+= rough(0.4, dot(reflect(d,n),light));\n        col*=shadow(p-d*0.1, lig);\n    }\n    \n    col += volumetrics(prevp,p, lig)*0.391;\n    //col = mix(volumetrics(prevp,p, lig), col, 0.5);\n    \n    float dist = abs(length(vec2(0.5) - fragCoord/iResolution.xy));\n    col-= dist*dist*0.6;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sf3zn", "previewfilepath": "/presets/webcam.png", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/webcam.png", "ctype": "webcam"}, {"id": "XdXGRr", "previewfilepath": "/presets/mic.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/mic.png", "ctype": "mic"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sjSWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[268, 268, 294, 301, 437], [440, 440, 466, 472, 524], [615, 615, 638, 638, 679], [682, 682, 700, 700, 842], [844, 844, 888, 888, 1021], [1205, 1205, 1235, 1235, 1389], [1393, 1393, 1423, 1423, 1858], [1860, 1860, 1907, 1907, 2116], [2118, 2118, 2148, 2148, 2207], [2209, 2209, 2266, 2266, 3381]], "test": "error"}
{"id": "7sjSzy", "name": "Blob-Circles", "author": "SteenLund", "description": "Simple circles turns into a blob", "tags": ["sdf"], "likes": 2, "viewed": 44, "published": "Public", "date": "1620517058", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circle(vec2 samplePosition, vec2 offset, float radius)\n{\n    float d =  length(samplePosition - offset) - radius;\n    return d;\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = max(k -abs(a-b), 0.0) / k;\n    return min(a, b) - h*h*k*0.25;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float radius = 0.1;\n    float c1  = circle(uv, vec2(0.2*sin(iTime), 0.2*cos(iTime)), radius);     \n    float c2 = circle(uv, vec2(-0.2 + 0.1*cos(iTime*1.5), 0.2 + 0.1*sin(iTime)), radius);     \n    float c3 = circle(uv, vec2(0.25*sin(iTime*1.55 + 2.), 0.25*cos(iTime + 5.)), radius);     \n    float c4 = circle(uv, vec2(0.4*sin(iTime*1.2 + 10.), 0.2*cos(iTime*0.5)), radius);     \n    \n    float k = .25;\n    float dist = smin(c1, c2, k);\n    dist = smin(dist, c3, k);\n    dist = smin(dist, c4, k);\n\n    float edgeSize = 0.0015;\n    vec3 col = vec3(1.) - (vec3(smoothstep(0., edgeSize, dist)) + vec3(smoothstep(0., edgeSize, -dist)));\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sjSzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 62, 62, 135], [137, 137, 176, 176, 254], [256, 256, 313, 313, 1114]], "test": "valid"}
{"id": "7sjXDR", "name": "Loop Spiral", "author": "aokeili", "description": "based on infinite Yin Yangs 2", "tags": ["spiral"], "likes": 0, "viewed": 68, "published": "Public", "date": "1620055226", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//////////////////////////////////////////////////////////////////////////////////\n// Infinite Yin Yang Zoom - Copyright 2017 Frank Force\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//////////////////////////////////////////////////////////////////////////////////\n\nconst float zoomSpeed\t\t\t= -0.4;\t// how fast to zoom (negative to zoom out)\nconst float zoomScale\t\t\t= 0.08;\t// how much to multiply overall zoom (closer to zero zooms in)\nconst float saturation\t\t\t= 0.4;\t// how much to scale saturation (0 == black and white)\nconst float turnSpeed\t\t\t= 0.7;\t// how fast to rotate (0 = no rotation)\nconst int   recursionCount\t\t= 7;\t// how deep to recurse\nconst float dotSize \t\t\t= 0.6;\t// how much to scale recursion at each step\nconst float blur\t\t\t\t= 5.0;\t// how much blur\nconst float outline\t\t\t\t= 0.12;\t// how thick is the outline\nconst float timeWarp\t\t\t= 2.0;\t// time warp to add curvature\n\n//////////////////////////////////////////////////////////////////////////////////\n    \nconst float pi = 3.14159265359;\nconst float e = 2.718281828459;\n\n\nvec3 colorA = vec3(0.0,0.0,0.5);  \nvec3 colorB = vec3(0.6,1.0,1.0); \n\nfloat RandFloat(int i) { return (fract(sin(float(i)) * 30442.5453)); }\nvec2 Rotate(vec2 p, float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return vec2((p.x*c - p.y*s), (p.x*s * p.y*c));\n}\n\nvec4 HsvToRgb(vec4 c) \n{\n    float s = 0.30;\n    float s_n = c.z;\n    return vec4(s_n) + vec4(s) * cos(5.0 * pi * (c.x + vec4(1.0, 1.0, 1.0, 1.0)));\n}\n\nfloat GetFocusRotation(int i) \n{ \n    float theta = 2.0*pi*RandFloat(i);\n    float s = mix(-1.0, 1.0, RandFloat(30+i));\n    return theta + turnSpeed*s*iTime; \n}\n\nvec2 GetFocusPos(int i) \n{ \n    bool side = (RandFloat(50+i) < 0.5);\n    vec2 p = vec2(0.0, side? -0.5 : 0.5); \n    return Rotate(p, GetFocusRotation(i));\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n\nfloat SpiralDraw( vec2 p, out float dotDistance, float co, float scale)\n{\n   \tfloat b = blur*scale/min(iResolution.y, iResolution.x);\n    float d = dotSize;\n    \n    float c = 1.0;\n    float r;\n    \n    // bottom\n    r = length(2.0*p + vec2(0, 1));\n    if (p.x < 0.0)\n\t   c = mix(c, 0.0, smoothstep(1.0-b, 1.0+b, r));\n    dotDistance = r;\n\nreturn c;\n}\n\nvec4 RecursiveSpiral(vec2 p, int iterations, float scale)\n{\n    // recursive iteration\n    float co = 0.0;\n    for (int r = 0; r < recursionCount; ++r)\n    {\n        // apply rotation\n  \t\tfloat theta = -GetFocusRotation(iterations + r);\n        p = Rotate(p, theta);\n        \n        float dotDistance = 0.0;\n        co = SpiralDraw(p, dotDistance, co, scale);\n        \n        if (dotDistance > dotSize || r == recursionCount)\n        {\n            float co2 = (p.y < 0.0)? 0.0 : 1.0;\n   \t\t\tfloat b = blur*scale/min(iResolution.y,iResolution.x);\n            \n            co = mix(co2, co, smoothstep(dotSize+outline,dotSize+outline+b,dotDistance));\n            int i2 = (dotDistance < dotSize+outline+b && p.y > 0.0)? 1 : 0;\n            float hue = 0.233*float(iterations + r + i2);\n            return vec4(hue, saturation*co, co, 1.0); // stop if outside or reached limit\n        }\n     \t\n    }\n    return vec4(0);\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 color, in vec2 uv )\n{\n    // fixed aspect ratio\n\tvec2 p = (25.0*uv-iResolution.xy)/min(iResolution.y,iResolution.x);\n    vec2 p2 = p;\n    \n    // time warp\n    float time = iTime + timeWarp*length(p);\n    \n\t// get time \n\tfloat timePercent = time;\n\tint iterations = int(floor(timePercent*0.998989));\n\ttimePercent -= float(iterations);\n    \n\t// update zoom, apply pow to make rate constant\n    const float recursionSize = 3.0 / dotSize;\n\tfloat zoom = pow(e, -log(recursionSize)*timePercent);\n\tzoom *= zoomScale;\n    \n    // apply zoom and offset\n\tp = p*(zoom/0.7);\n    \n    // make the spiral\n    color = RecursiveSpiral(p, iterations, zoom);\n    \n    // map to rgp space\n    color = HsvToRgb(color); \n    colorA.y =  p.y * 0.9;\n    colorA.z =  0.9;\n    \n    color.xyz = mix(colorA, colorB,abs(sin(color.x)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sjXDR.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1155, 1155, 1179, 1179, 1225], [1226, 1226, 1260, 1260, 1365], [1367, 1367, 1391, 1391, 1517], [1519, 1519, 1551, 1551, 1679], [1681, 1681, 1707, 1707, 1837], [1923, 1923, 1996, 1996, 2274], [2276, 2276, 2335, 2362, 3194], [3280, 3280, 3326, 3352, 4114]], "test": "valid"}
{"id": "7sjXRm", "name": "SineWobble", "author": "trigophers", "description": "Sine stuff", "tags": ["sine", "trig", "synthesis"], "likes": 2, "viewed": 41, "published": "Public", "date": "1620082011", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 uv;\nfloat pi = 3.1415926536;\n\nfloat sine(float seed, float freq, float amp, vec2 pos) {\n    return sin(seed*freq+pos.x)*amp+pos.y;\n}\n\nvoid aspectNorm(vec2 fragCoord, vec2 scale) {\n    if (iResolution.x<iResolution.y) {\n        uv = scale*(fragCoord/iResolution.xx-vec2(0.5, iResolution.y/iResolution.x/2.0));\n    } else {\n        uv = scale*(fragCoord/iResolution.yy-vec2(iResolution.x/iResolution.y/2.0, 0.5));\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    aspectNorm(fragCoord, vec2(1.0, 1.0));\n\n    vec3 col;\n    float saveSine = sine(uv.x, 5.0, 0.25, vec2(iTime, 0.0));\n    saveSine += sine(uv.x, 16.0, 0.125, vec2(iTime/3.0*2.0, 0.0));\n    saveSine += sine(uv.x, 21.0, 0.0625, vec2(iTime/3.0, 0.0));\n    if (saveSine>uv.y) {\n        col = vec3(uv.y+1.0-saveSine);\n    } else {\n        col = vec3((saveSine)*2.0+1.0-uv.y*2.0);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sjXRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 92, 92, 137], [139, 139, 184, 184, 424], [426, 426, 483, 483, 924]], "test": "valid"}
{"id": "7sjXRy", "name": "Circular Animated Julia Set", "author": "wetzecam", "description": "Julia Set defined by: Z_n+1 = Z_n^2 + C;   where C is allowed to be any complex number... The animation sweeps C around the circle of radius 1.1 in the complex plane.\n\nEscape time is used to determine the coloring scheme... ", "tags": ["fractal"], "likes": 2, "viewed": 37, "published": "Public", "date": "1620513922", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float SerpinskiEscapeTime(vec2 u){\n    float numits=65.0;\n    float R = 200.0;\n    float n;\n    \n    for(n=0.0;n<numits;n++){\n        if (u.y>0.5){\n            u.x = 2.0*u.x;\n            u.y = 2.0*u.y-1.0;\n        }\n        else if (u.x>0.5 && u.y <= 0.5){\n            u.x = 2.0*u.x-1.0;\n            u.y = u.y;\n        }\n        else{\n            u.y = 2.0*u.y;\n            u.x = 2.0*u.x;\n        }\n        \n        if(length(u)>R){ return n; }\n    }\n    \n    return n;\n}\n\nfloat JuliaEscapeTime(vec2 u, vec2 seed){\n    float numits=1005.0;\n    float R = 2.0;\n    float n;\n \n     for(n=0.0;n<numits;n++){\n        float tmpx = u.x;\n        float tmpy = u.y;\n        \n        u.x = tmpx*tmpx - tmpy*tmpy + seed.x;\n        u.y = 2.0*tmpx*tmpy + seed.y;\n        \n        if(length(u)>R){ return n; }\n    }\n    \n    return n;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.0*(fragCoord/iResolution.xy) - vec2(1.0,1.0);\n    \n    vec2 Cval = 1.1*vec2(cos(iTime),sin(iTime));\n    \n    float escapeTime = JuliaEscapeTime(uv,Cval);\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*vec3(cos(escapeTime*2.0),0.0,0.0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sjXRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 471], [473, 473, 514, 514, 822], [824, 824, 881, 931, 1252]], "test": "valid"}
{"id": "7sjXWt", "name": "1st Toy", "author": "numinet", "description": "Toy Shader", "tags": ["toy"], "likes": 1, "viewed": 25, "published": "Public", "date": "1621326436", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 a = fragCoord*vec2(.15,.2)*sin(iTime)*.09*cos(iTime);\n   fragColor = vec4(.9+cos(iTime)*.5,.3,.1,1.0)+vec4(a,.53,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sjXWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 185]], "test": "valid"}
{"id": "7sSSDd", "name": "Call of the Siren", "author": "Quasimondo", "description": "This shader runs a SIREN neural network that was trained on a series of faces generated with StyleGAN2. The code is based on the work of Blackle Mori / https://www.shadertoy.com/view/wtVyWK", "tags": ["portrait", "neuralnetwork", "siren", "gan", "stylegan2"], "likes": 43, "viewed": 1095, "published": "Public", "date": "1621274773", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Parts of this shader code are based on the work of Blackle Mori / https://www.shadertoy.com/view/wtVyWK\n//Siren model trained and customized by Mario Klingemann / @Quasimondo\n\nvec4 r(vec2 pp,float t,vec2 q) {\n    vec4 p = vec4(pp,q.yx*1.5);\n    vec4 f0_0=sin(p.x*vec4(-1.21,-.03,1.20,-1.17)+p.y*vec4(-.28,1.35,1.36,-1.23)+p.z*vec4(-.12,-.05,-.04,-.06)+p.w*vec4(-.18,-.12,-.13,-.48)+vec4(-.46,1.24,.40,-.30));\nvec4 f0_1=sin(p.x*vec4(-1.56,1.50,.48,1.36)+p.y*vec4(.10,-.75,.31,1.04)+p.z*vec4(-.27,-.03,-.03,-.05)+p.w*vec4(.01,-.16,-.41,.29)+vec4(.22,.21,.81,-1.16));\nvec4 f0_2=sin(p.x*vec4(-.94,-.22,1.00,1.10)+p.y*vec4(.38,-.74,.05,-1.54)+p.z*vec4(.04,-.05,-.06,-.06)+p.w*vec4(-.46,-.18,.20,.27)+vec4(.12,.97,.20,-.44));\nvec4 f0_3=sin(p.x*vec4(-1.13,-.72,.47,-1.66)+p.y*vec4(.24,.01,1.57,.56)+p.z*vec4(-.07,.04,-.10,-.00)+p.w*vec4(.32,.30,.08,-.04)+vec4(-.85,.37,-1.02,-1.29));\nvec4 f1_0=sin(mat4(.10,.41,-.34,-.20,.07,-.10,.07,-.20,.24,-.24,-.21,-.11,-.17,.23,-.06,-.16)*f0_0+\n    mat4(.05,.25,-.19,-.24,-.24,.01,-.27,.28,-.03,.03,-.08,.06,.07,.01,-.01,.25)*f0_1+\n    mat4(.07,.08,.01,.02,-.18,-.10,-.04,-.24,-.12,-.39,.10,.14,-.15,.35,-.29,.19)*f0_2+\n    mat4(.15,.02,-.32,.04,-.08,.22,.24,.21,.02,.23,-.07,-.07,.36,.24,-.15,.03)*f0_3+\n    vec4(-.18,-.33,.29,-.03))/1.00+f0_0;\nvec4 f1_1=sin(mat4(-.31,.19,.11,-.31,.35,-.03,-.24,-.17,.20,.07,-.38,.08,.09,-.04,.16,.21)*f0_0+\n    mat4(-.53,-.09,-.17,.22,-.31,-.08,.23,-.33,-.11,-.17,-.40,.23,.12,.27,-.04,-.72)*f0_1+\n    mat4(-.47,-.17,-.36,-.02,-.09,-.14,-.17,.37,.29,-.11,-.09,-.02,-.28,.15,.30,.13)*f0_2+\n    mat4(-.30,.25,.06,-.26,-.10,.12,.18,.26,-.26,-.02,-.46,-.03,.44,.09,.08,-.19)*f0_3+\n    vec4(.06,.12,-.26,.19))/1.00+f0_1;\nvec4 f1_2=sin(mat4(-.42,-.18,.15,-.15,-.22,-.34,.12,-.10,-.04,-.21,-.38,.15,-.32,.04,.25,.40)*f0_0+\n    mat4(-.25,-.37,-.44,-.09,-.04,.12,-.07,-.17,-.05,-.25,.16,.72,.13,.10,.28,-.07)*f0_1+\n    mat4(-.73,.12,.23,-.17,.08,-.28,-.02,.32,.25,-.47,-.23,.42,.24,.29,.07,.02)*f0_2+\n    mat4(-.03,.38,.04,-.19,.04,.02,.14,.32,.22,.33,-.02,-.14,.16,.33,.06,-.27)*f0_3+\n    vec4(.19,.03,.17,.31))/1.00+f0_2;\nvec4 f1_3=sin(mat4(-.17,.11,.22,.05,-.07,-.14,-.01,-.15,-.11,-.22,-.46,.37,.18,.02,.23,-.09)*f0_0+\n    mat4(.14,-.17,.31,-.31,.22,-.16,-.32,.44,.39,-.27,-.13,.02,.19,-.17,-.03,.24)*f0_1+\n    mat4(-.13,.47,.27,-.30,-.05,-.25,-.08,-.09,.15,-.27,-.65,.02,.13,-.02,.05,-.10)*f0_2+\n    mat4(-.54,.12,-.03,-.23,.21,-.14,.26,-.21,-.07,-.27,.20,-.19,.20,.17,-.01,.22)*f0_3+\n    vec4(.12,-.20,-.05,.07))/1.00+f0_3;\nvec4 f2_0=sin(mat4(-.23,-.03,.42,-.06,.55,-.30,.10,.25,.07,-.36,.13,.40,.23,.64,.17,-.47)*f1_0+\n    mat4(.55,-.44,-1.00,-.09,.27,.02,.14,-.16,1.11,.25,-1.03,.20,.52,-.25,.44,.69)*f1_1+\n    mat4(-.12,.20,.16,.19,.01,.68,.21,.30,-.33,-.37,.03,-.01,.10,.39,-.21,.28)*f1_2+\n    mat4(-.45,.09,.37,.68,-.54,-.04,-.21,.61,-.11,-.14,.38,-.05,-.10,-.10,.07,-.31)*f1_3+\n    vec4(-.23,.35,-.30,.31))/1.41+f1_0;\nvec4 f2_1=sin(mat4(-.25,-.09,.15,.54,.50,-.07,.08,.25,.17,.16,.38,-.18,.14,.60,-.60,.23)*f1_0+\n    mat4(-.32,-.37,.13,-.10,.03,-.65,-.63,-.11,-.20,.01,-.39,-.09,.13,.59,.19,-.42)*f1_1+\n    mat4(-.46,.85,-.13,.39,-.14,-.38,-.60,-.18,.14,.12,-.02,-.57,-.42,.43,-.26,-.47)*f1_2+\n    mat4(.32,-.67,-.86,.28,-.74,.33,-.26,-.26,-.16,-.14,-.27,-.18,.68,-.75,-.61,.07)*f1_3+\n    vec4(-.09,.17,.13,-.46))/1.41+f1_1;\nvec4 f2_2=sin(mat4(.35,-.01,-.44,.07,.25,.21,.21,-.14,-.20,.19,-.18,-.12,-.20,.06,-.40,-.27)*f1_0+\n    mat4(.20,-.03,-.62,-.10,-.68,.20,-.58,-.50,.46,-.29,.14,.58,.45,-.03,.83,.25)*f1_1+\n    mat4(.13,-.21,-.90,.01,.31,-.72,.29,.43,.22,.11,.37,-.46,-.23,-.20,.20,-.47)*f1_2+\n    mat4(.15,-.16,.10,-.63,.54,.12,.17,.33,.27,-.04,-.66,-.03,.14,.09,-.29,.20)*f1_3+\n    vec4(.09,.24,.31,-.04))/1.41+f1_2;\nvec4 f2_3=sin(mat4(-.52,-.23,.03,-.28,.71,.06,.06,.13,.26,.30,.41,-.34,-.27,.04,-.29,.42)*f1_0+\n    mat4(-.26,.57,.33,-.07,-.19,-.15,-.03,.35,-.78,-.15,.64,-.18,-.17,-.66,-.12,-.03)*f1_1+\n    mat4(.21,-.35,.68,-.47,-.03,-.04,.30,.14,.10,.06,-.11,.20,-.18,.27,.00,.06)*f1_2+\n    mat4(-.37,.12,.31,.15,.07,-.70,.15,.58,-.54,-.28,-.20,.07,-.35,-.08,.28,-.04)*f1_3+\n    vec4(.62,-.20,.31,.31))/1.41+f1_3;\nvec4 f3_0=sin(mat4(-1.07,-.19,.11,.55,.27,-.99,-.29,-.99,-.58,.32,-1.13,-.17,.44,-.74,.16,-.87)*f2_0+\n    mat4(-.35,-.11,.54,-.81,-.64,.64,.67,-.18,.03,.17,-.69,-.31,-.47,.95,.69,-.51)*f2_1+\n    mat4(.04,-1.12,.15,.62,-.32,.42,.58,-1.14,.00,.39,.29,-.17,.16,.69,.77,-.48)*f2_2+\n    mat4(-.33,.07,.46,.74,.33,.71,-.29,.01,.04,.02,.50,-.18,-.07,.43,.65,-.07)*f2_3+\n    vec4(-.24,.23,.16,.09))/1.73+f2_0;\nvec4 f3_1=sin(mat4(.06,.17,-.07,.85,-.09,.08,-.54,.20,.24,-.39,.35,-.20,.25,-.39,.10,1.06)*f2_0+\n    mat4(-1.34,.53,-.28,-.63,.44,-1.03,-.70,-.14,.41,-.28,-1.04,-.61,-.49,-.80,-.81,1.13)*f2_1+\n    mat4(.36,.30,.23,.24,.26,-.36,.03,.12,.35,-.00,.16,-.74,.13,.26,-.65,-.65)*f2_2+\n    mat4(-.43,-.10,-.07,.08,-.62,.21,-.48,.66,-.23,-.09,.30,.17,-.16,.11,.48,.86)*f2_3+\n    vec4(-.36,-.42,.12,-.84))/1.73+f2_1;\nvec4 f3_2=sin(mat4(-.03,.66,-.20,.15,-.04,-.06,.79,.27,-.31,-.27,.61,.22,.16,.34,.01,.33)*f2_0+\n    mat4(-.07,-.06,-.39,-.08,-.60,-.78,-.27,.28,-.45,.05,.78,.51,.25,.18,.25,.42)*f2_1+\n    mat4(-.56,.73,.42,-.40,-.22,1.17,.07,-.62,.20,-1.11,1.24,.11,.24,.17,.83,-1.48)*f2_2+\n    mat4(.13,-.30,1.73,-.18,-.90,.19,-.07,.03,-.27,.28,-.71,.29,-.53,.32,-.54,-.04)*f2_3+\n    vec4(-.11,-.66,.55,-.09))/1.73+f2_2;\nvec4 f3_3=sin(mat4(-.12,.15,-.88,.08,.01,.31,.28,-.20,.06,.12,-.83,.77,-.73,.01,-.29,-.08)*f2_0+\n    mat4(-.25,.10,.15,.69,.24,-.04,-.04,-.48,.46,-.07,-.23,-.23,.04,-.13,-.57,-.37)*f2_1+\n    mat4(-.23,.39,.00,-.14,-.28,-.06,.10,-1.09,.05,-.16,1.07,.12,.09,-.19,-.21,-1.00)*f2_2+\n    mat4(-1.57,-.71,-.55,-.67,.14,-1.05,1.18,-.58,-.57,-.35,-.20,.31,.21,-.45,-.48,.21)*f2_3+\n    vec4(.27,-.28,.73,-.58))/1.73+f2_3;\nvec4 f4_0=sin(mat4(.89,.39,.15,-.04,-.61,.37,.19,-1.22,-.40,1.05,-1.77,1.20,.03,-1.20,.66,-.00)*f3_0+\n    mat4(.10,.02,.36,.15,.40,.18,.54,.03,.18,.64,.53,-.79,-.51,-.29,-.59,.02)*f3_1+\n    mat4(.17,.24,-.51,-.07,.27,-.66,1.35,-.63,-.45,.06,.05,-.45,-.51,.49,-.02,-.81)*f3_2+\n    mat4(.05,.46,.01,-.69,.75,1.11,.02,-.03,.07,-.82,.18,.76,.79,.23,.50,.63)*f3_3+\n    vec4(-.95,1.41,.15,-.06))/2.00+f3_0;\nvec4 f4_1=sin(mat4(.53,.44,-.07,.38,.06,-.15,-.21,.94,-.38,-1.59,.38,.45,1.30,.41,-.51,.20)*f3_0+\n    mat4(-.32,-.23,-.40,-.47,-.41,-1.94,-1.16,.14,1.06,-.43,-1.74,.22,-.02,.47,-.46,1.03)*f3_1+\n    mat4(.63,-.43,1.55,.69,1.32,.20,-.99,-.28,-.42,-.19,-.47,.04,-.32,-.14,-.52,.07)*f3_2+\n    mat4(.62,-1.52,1.13,1.26,.26,.64,-.03,-.29,.52,-.16,-.79,-.37,.35,-.72,.48,-.66)*f3_3+\n    vec4(.09,-.14,.15,1.24))/2.00+f3_1;\nvec4 f4_2=sin(mat4(-.13,.59,.07,.23,.60,.16,.39,1.96,-.95,-.08,-.35,-1.23,-.01,-.87,.92,.93)*f3_0+\n    mat4(-.92,-.59,-.41,.45,-1.20,-.72,1.19,-.92,-.15,-.07,-.49,-.37,-.89,-.15,-.20,.40)*f3_1+\n    mat4(.52,.09,.38,.02,.41,-1.80,.44,.40,-.38,-.08,-.71,-.85,-1.23,-.24,1.08,-.43)*f3_2+\n    mat4(-.29,.67,-.03,-.49,.39,.19,-.92,.95,.20,.09,-.29,-.08,.20,-.27,.29,-.23)*f3_3+\n    vec4(.22,-.38,.13,-.11))/2.00+f3_2;\nvec4 f4_3=sin(mat4(1.14,-.64,.36,.55,-.65,-.37,-.53,-1.25,-.16,-1.09,.62,-.84,.65,-.41,-.35,.92)*f3_0+\n    mat4(-1.88,.86,-.67,1.14,-.14,1.28,.17,.35,-.06,.11,-.30,.29,.49,-.51,.09,.39)*f3_1+\n    mat4(1.58,-.46,.17,-1.17,1.19,-1.12,-.01,-.13,-.19,.14,-.60,-.39,-1.15,.56,-.53,-.64)*f3_2+\n    mat4(.03,.42,.25,-.93,.52,-.25,.04,.27,.32,-.76,-1.36,-.36,.25,.00,.37,-.63)*f3_3+\n    vec4(-.60,.01,-.10,-.19))/2.00+f3_3;\nvec4 f5_0=sin(mat4(-1.42,-.24,-.06,-.37,.10,-.92,-.25,.58,-.31,.52,-1.59,.20,.37,.03,.05,-1.34)*f4_0+\n    mat4(-.80,.02,.79,-.05,.34,.45,-.31,-.54,-.39,-.05,-.44,.39,.25,.11,1.05,.81)*f4_1+\n    mat4(.27,-.06,.87,.04,.24,.18,-.11,-.03,-.32,-.38,-.81,-.46,-.51,-.09,.05,.28)*f4_2+\n    mat4(.51,.36,.62,.34,-.25,-.47,-.41,-.07,-.07,.07,-.18,.16,.05,.05,.42,.13)*f4_3+\n    vec4(-.06,.19,-.33,-.29))/2.24+f4_0;\nvec4 f5_1=sin(mat4(.12,.28,-.42,.49,-.06,.43,.37,.20,-.48,.85,.10,.17,-.31,-.10,-.10,.70)*f4_0+\n    mat4(-1.28,.24,-.06,-.70,-.08,-.76,.09,-.39,-.34,.88,-2.23,-.71,-.90,-.79,-.10,.62)*f4_1+\n    mat4(-.12,.16,-.07,-.93,.26,1.79,.13,.98,.30,-.26,-.49,-.12,-.52,.04,-.03,-.63)*f4_2+\n    mat4(.18,-.50,.12,-.31,-.36,-.36,-.10,1.07,.56,-.30,-.04,.49,.08,.21,-.24,.54)*f4_3+\n    vec4(-.07,-.02,-.33,-.66))/2.24+f4_1;\nvec4 f5_2=sin(mat4(-.20,.60,.08,-.17,-.35,.07,-.62,-.09,-.63,-.42,.61,-.37,.27,.41,-.74,.65)*f4_0+\n    mat4(.30,.39,-.80,.23,-.85,.51,-.46,-.16,.63,.47,.47,-.25,.33,-.48,.23,.41)*f4_1+\n    mat4(-.07,.39,.38,-.03,.76,1.01,.02,-.22,-.24,-.18,-.32,.45,-.41,.40,-.19,-.99)*f4_2+\n    mat4(-1.57,-.82,-.82,.09,-.64,.10,-.29,-.20,1.22,.26,.32,-.23,.23,.11,-.39,.12)*f4_3+\n    vec4(-.74,-.17,.34,.27))/2.24+f4_2;\nvec4 f5_3=sin(mat4(.01,.59,-.10,.42,.22,.75,-.08,.21,.43,-.26,.50,-.45,-.03,.45,.28,.20)*f4_0+\n    mat4(-.27,-.76,-.14,1.34,-.48,.24,-1.08,-1.32,-.37,.22,.08,-.31,-.25,-.81,.38,-.27)*f4_1+\n    mat4(.12,.40,.57,-.75,.12,.00,-.52,1.38,.83,.03,.62,-.97,-.14,-.81,-.36,-.50)*f4_2+\n    mat4(-.85,-.09,-.01,.46,.08,-.07,.64,-.06,-.30,-.99,-.34,1.28,.26,.00,-.47,.27)*f4_3+\n    vec4(-.32,.29,-.09,-.25))/2.24+f4_3;\nvec4 f6_0=sin(mat4(.47,.26,-.79,.58,1.38,1.96,.86,.10,-.19,.68,-.72,-.26,-.22,.05,-.03,.79)*f5_0+\n    mat4(-.08,-.23,1.80,-.37,1.24,.30,-1.46,-.30,.15,-.77,1.57,.17,-.27,.73,.69,-1.22)*f5_1+\n    mat4(-.70,-.16,-1.67,1.02,-.95,.55,-.42,.20,1.26,.47,.36,-.69,-1.09,.40,.38,.21)*f5_2+\n    mat4(-1.11,-.35,-.33,-1.35,1.16,.22,1.32,.71,.78,-.30,-.29,-.47,-.34,-.57,-.67,.15)*f5_3+\n    vec4(.61,1.28,.07,-.23))/2.45+f5_0;\nvec4 f6_1=sin(mat4(-.28,-.09,-1.03,-.13,.53,.20,1.28,-2.11,-.62,.05,-.75,1.13,.54,.31,-.78,.77)*f5_0+\n    mat4(.46,-.93,-.34,-.80,-.95,-1.56,.42,.61,1.61,-.90,.03,2.71,-.05,.51,-.98,.39)*f5_1+\n    mat4(-.94,.10,-.55,.10,-.64,.30,-1.17,.19,.35,-.31,.40,.93,-.64,.78,1.04,-.31)*f5_2+\n    mat4(-.50,-.88,.40,-1.08,.88,.28,1.20,-.96,-.88,-.21,-1.03,1.79,-1.25,-.22,-1.39,.13)*f5_3+\n    vec4(-.01,.55,1.31,-.13))/2.45+f5_1;\nvec4 f6_2=sin(mat4(-.57,1.18,.05,-.17,.21,-.07,.05,-.32,.07,-.56,1.33,.39,-.25,-.14,.66,.92)*f5_0+\n    mat4(-.13,1.29,-1.58,.34,-1.17,-.65,.93,-.29,.86,-.01,-.62,-.54,-.74,-.67,-.87,-.69)*f5_1+\n    mat4(2.07,-.69,-.14,.86,-.31,-.20,-.63,.36,.39,-.65,-.25,-.22,.34,-.52,-.22,-.70)*f5_2+\n    mat4(.76,-.30,-1.15,-.28,.26,1.37,.62,-.45,.11,-.05,.13,.81,-.28,-.45,.26,.49)*f5_3+\n    vec4(.99,-.66,.59,.53))/2.45+f5_2;\nvec4 f6_3=sin(mat4(.05,.62,.48,.38,.66,-.06,-1.24,-.07,-.15,-.99,-.01,-.04,-.68,-.17,-.34,.23)*f5_0+\n    mat4(-.50,1.36,-1.00,.36,-.06,-.39,.69,-.67,-1.26,-1.10,-1.47,-1.67,-.37,.40,.50,-.01)*f5_1+\n    mat4(.44,-.87,.29,-.86,-1.44,-.01,.40,.55,-.11,.03,-.23,-.56,1.02,-.29,-.58,-.75)*f5_2+\n    mat4(1.90,.42,-.09,-.32,.46,-1.36,-.08,.46,-.37,.32,-.21,-.53,-.80,-.47,-.17,1.47)*f5_3+\n    vec4(1.61,-.19,-.39,-.26))/2.45+f5_3;\nvec4 f7_0=sin(mat4(.98,.63,-.71,.61,.34,1.16,.67,-.31,.19,.13,-1.37,.51,.94,1.12,-.90,.20)*f6_0+\n    mat4(-.00,-.11,.63,-.43,.43,-.95,-.97,-2.06,.50,-.29,-.26,-.52,-.36,-.34,.42,1.71)*f6_1+\n    mat4(-.09,1.18,.00,1.83,-.07,1.16,.85,.12,.70,-.33,.51,-.54,.74,.69,-.29,.38)*f6_2+\n    mat4(.21,-.22,-.13,.63,-.84,-.29,.63,-.24,-.37,-.29,-.41,1.17,-1.40,-.71,.04,.27)*f6_3+\n    vec4(.49,.46,.28,-.53))/2.65+f6_0;\nvec4 f7_1=sin(mat4(-.02,-.93,1.10,-.01,-.35,.66,-.31,.94,-1.05,-.12,1.13,-.10,-.35,-.22,.24,-.23)*f6_0+\n    mat4(1.81,-.21,.89,-.05,.78,1.69,-.36,-.62,.04,-.58,-1.72,.37,1.02,-1.38,.24,2.23)*f6_1+\n    mat4(.32,1.14,1.18,.12,-.78,-1.30,.83,-.42,.80,.53,.14,.15,-.14,.13,.02,.17)*f6_2+\n    mat4(.64,.13,-.13,.05,.09,.23,-.78,-.11,.07,-.16,.86,-.72,-.89,-.82,1.14,-.66)*f6_3+\n    vec4(1.38,.45,-.57,1.55))/2.65+f6_1;\nvec4 f7_2=sin(mat4(.61,.38,-1.20,-.89,-.02,-.92,.88,-.01,.47,.20,-.56,.04,.46,.43,-.12,-.17)*f6_0+\n    mat4(-.81,-.55,-.99,-1.25,-.53,-.69,-1.15,.58,-1.35,-.04,-.95,-.85,.12,.77,.34,-.74)*f6_1+\n    mat4(1.85,-.95,-.14,.58,.83,2.59,.09,-.98,-.31,-.74,1.11,-.46,-.22,-.59,-.35,-1.05)*f6_2+\n    mat4(.31,.52,.16,-.11,1.30,-.23,.62,-.92,.28,.46,-.60,1.32,1.45,.33,-1.21,.69)*f6_3+\n    vec4(-.79,-1.16,.36,-1.08))/2.65+f6_2;\nvec4 f7_3=sin(mat4(-.20,.54,-.39,.09,-.43,.53,-.43,.06,-1.08,1.04,-.45,.66,-.22,-.25,-.54,.10)*f6_0+\n    mat4(-1.01,.07,1.36,.01,.11,.61,-.96,.10,-.92,-.30,.52,.63,-.59,-.07,.23,.80)*f6_1+\n    mat4(-.93,-.06,-1.50,-1.34,-.74,-.47,-.33,-.44,-.93,.71,-.26,-.27,-2.55,-.30,-.12,.44)*f6_2+\n    mat4(-.67,-.44,.61,.14,.48,-.46,.81,-.73,-.62,-.15,-.37,.90,.57,.73,-.21,-.20)*f6_3+\n    vec4(-1.03,-.10,-.18,.13))/2.65+f6_3;\nvec4 f8_0=sin(mat4(.21,-.53,.73,-1.15,.41,-.59,-1.01,.59,-2.03,.76,1.25,-1.22,-.26,.43,.53,-.85)*f7_0+\n    mat4(.44,-.46,-.08,-1.49,-.82,.21,.38,.08,.40,.52,.04,-.67,.89,-.20,-1.96,-.47)*f7_1+\n    mat4(-.69,-.67,-.05,-.10,1.01,1.01,.62,-.81,.52,-.44,-.82,.12,.47,-.04,-.47,-1.19)*f7_2+\n    mat4(.12,-.72,-.85,-.86,-.48,.58,.08,1.24,.01,-.93,.28,-.03,-1.01,.52,.48,-.95)*f7_3+\n    vec4(.50,.40,-.29,.12))/2.83+f7_0;\nvec4 f8_1=sin(mat4(-.23,-.33,-.85,-.06,-.03,.89,-.70,-.07,-.15,-.20,.49,.71,.82,.94,-.71,-.67)*f7_0+\n    mat4(.06,.17,.70,-.55,.83,1.72,-.59,-1.42,.09,-.06,-.60,.75,.76,-.28,.76,-2.43)*f7_1+\n    mat4(-1.92,.47,-.38,.22,.42,.33,-.10,-.76,-.56,.35,-.11,-.26,1.11,.41,-.36,.60)*f7_2+\n    mat4(.69,-.27,-.32,.35,.28,-.41,-.48,-.99,.24,-.04,.60,-.57,.74,-.15,.17,.19)*f7_3+\n    vec4(-.11,.41,-.20,-.06))/2.83+f7_1;\nvec4 f8_2=sin(mat4(.07,.51,.15,-1.41,.63,.14,-.03,.17,-.13,.17,.15,.02,-.01,-.08,-.01,-.15)*f7_0+\n    mat4(-.34,.12,.22,.69,-.09,.97,.13,-.70,-.05,-.17,.10,.14,-.78,-.79,1.21,.51)*f7_1+\n    mat4(-2.09,.11,.56,-.11,-.22,-1.67,.25,-.53,.03,-.84,-1.17,-.28,-.58,.80,.79,-1.09)*f7_2+\n    mat4(-.18,1.02,-.40,-.38,.18,-.58,-.91,-1.22,.16,-.12,-.29,.22,.39,.30,-.15,-.57)*f7_3+\n    vec4(.35,-.53,.52,.98))/2.83+f7_2;\nvec4 f8_3=sin(mat4(.16,.25,-1.50,.10,.78,-.47,.37,-.71,.25,-.67,-1.07,.47,.62,-.06,-.28,-.45)*f7_0+\n    mat4(-1.32,-.20,-1.02,-1.23,.91,.30,1.63,-1.34,.74,1.51,-.23,-1.03,-.27,-.45,.40,.91)*f7_1+\n    mat4(1.58,.64,-.39,-.02,.90,-1.37,-.62,.98,-.12,.31,-.69,.27,.74,-.15,-.35,-.27)*f7_2+\n    mat4(-1.86,.51,-.30,.11,.30,-.16,.49,-.19,-.03,.23,-.59,.46,.11,-.54,-.93,-.51)*f7_3+\n    vec4(-.18,.08,-.25,-.12))/2.83+f7_3;\nvec4 f9_0=sin(mat4(-2.50,-.16,-.17,-.09,.17,1.60,1.59,1.37,1.08,-.74,.55,-.91,.35,-.31,.44,-.86)*f8_0+\n    mat4(-.50,-.61,.20,-.35,.81,.19,.54,1.08,.16,-.05,-1.89,-1.83,-1.06,-.24,1.56,.34)*f8_1+\n    mat4(-.25,.50,.71,1.79,.16,-2.20,-.28,-1.52,.18,2.27,.65,1.39,-1.66,-.10,.46,-.19)*f8_2+\n    mat4(-.35,.62,-.83,.10,-.16,.28,-.55,.68,.33,-.18,.76,.27,-.30,-.35,-.64,-.12)*f8_3+\n    vec4(-1.00,.77,1.20,.90))/3.00+f8_0;\nvec4 f9_1=sin(mat4(.05,-.45,.68,.59,1.11,-.56,.07,-.37,1.70,-1.19,.08,.56,.68,.28,-.29,.73)*f8_0+\n    mat4(1.36,.17,-.24,.36,.11,.03,-1.18,-1.23,-1.46,-1.32,-1.42,-.35,.74,.80,-.10,.99)*f8_1+\n    mat4(2.95,1.78,-.93,-2.56,-.56,-.53,-.82,.78,-.95,-.91,-.73,-1.79,.33,-.81,.47,-.42)*f8_2+\n    mat4(.06,-.56,.30,.75,.11,.33,.33,-2.02,1.23,.41,-.67,-.22,-.31,.48,-.33,.95)*f8_3+\n    vec4(.44,.38,.16,-.97))/3.00+f8_1;\nvec4 f9_2=sin(mat4(.97,.70,1.16,.60,-.11,.83,-.10,.49,-.31,.87,.47,.05,-.66,.01,-.59,-1.43)*f8_0+\n    mat4(.15,-.57,-.06,-.43,.72,.77,-1.36,.04,-.53,-.67,-.26,-.17,-.58,.15,1.53,-.50)*f8_1+\n    mat4(1.04,1.20,1.43,.48,.38,-1.15,.92,-1.87,-.10,.41,1.33,.45,-.71,.32,-.37,.54)*f8_2+\n    mat4(-1.12,.47,-.25,-.59,-.02,-.57,.73,.10,-.27,-.28,1.19,.58,.83,.30,.35,.26)*f8_3+\n    vec4(-.22,.79,-.26,.54))/3.00+f8_2;\nvec4 f9_3=sin(mat4(.88,-.54,.41,-.75,1.39,.63,.52,-.01,.54,-.72,-.02,1.61,.10,-.23,-.02,-2.57)*f8_0+\n    mat4(.40,-.88,.38,.18,.70,-1.88,-.73,-.43,-1.30,.69,.05,-.15,.95,.01,-.95,-1.43)*f8_1+\n    mat4(.45,1.92,-.83,1.68,.46,.10,-.62,.45,-.33,.57,.59,.14,.74,-.36,-.38,-.46)*f8_2+\n    mat4(-.69,-.10,.19,-.14,1.10,-2.51,-.36,1.14,-.28,.15,.86,-1.48,.63,.16,-.81,-.41)*f8_3+\n    vec4(-.71,.73,1.69,1.16))/3.00+f8_3;\nvec4 f10_0=sin(mat4(1.25,-1.01,-.85,-.17,-.33,1.44,1.01,.23,-1.49,-1.32,1.06,.77,-1.50,-.70,.17,-.88)*f9_0+\n    mat4(.12,.24,-.74,.05,-1.33,1.14,-.09,-1.39,-.85,-.74,.54,-.47,1.35,-1.31,-.11,2.10)*f9_1+\n    mat4(2.13,1.36,1.86,.57,-.05,-1.06,.40,.52,-.02,.82,.07,.44,.46,-.28,.64,.22)*f9_2+\n    mat4(.19,-.29,-1.01,-.32,-1.07,1.38,.76,.16,-.07,-.76,.41,1.09,-.42,-.56,-.47,-.52)*f9_3+\n    vec4(-.12,.75,.49,-.74))/3.16+f9_0;\nvec4 f10_1=sin(mat4(.65,.78,-.27,-3.16,.17,.59,1.12,.68,-.32,.00,-1.02,.82,.63,1.71,.05,-1.20)*f9_0+\n    mat4(.02,-.32,-.71,-1.18,-1.86,1.02,.67,1.56,.35,-1.73,.13,-.30,1.64,.81,-.03,1.66)*f9_1+\n    mat4(.15,.16,-.02,-1.23,.32,1.29,.67,-1.24,-1.16,.38,.71,.52,-1.55,-.20,1.31,.59)*f9_2+\n    mat4(-.50,.11,-.22,.24,-.90,.46,1.42,3.61,-.86,.50,-1.23,.63,1.68,.00,-1.81,-1.86)*f9_3+\n    vec4(-2.45,1.20,1.60,2.32))/3.16+f9_1;\nvec4 f10_2=sin(mat4(.69,-.46,.59,-2.72,-.16,-1.25,-1.94,1.52,-.48,.32,.47,-.32,.21,-.74,.46,-.23)*f9_0+\n    mat4(.38,1.18,.53,-1.76,.06,-1.70,-.50,.99,.29,.31,1.01,.28,1.14,.84,1.00,-2.45)*f9_1+\n    mat4(-2.77,-.39,-.30,-.97,.97,-.48,.52,1.31,-1.11,-.24,-2.46,1.59,-.12,-.71,-.28,-.86)*f9_2+\n    mat4(.61,1.11,.11,.23,-.92,.60,.32,.39,-.25,2.56,-.21,1.82,-.10,.39,1.31,-.24)*f9_3+\n    vec4(.29,-.25,-2.16,-.24))/3.16+f9_2;\nvec4 f10_3=sin(mat4(-1.76,-.44,-2.00,-.07,1.50,-.64,-.04,.09,.13,-.75,1.15,.06,-.65,-.79,-.45,.21)*f9_0+\n    mat4(-.02,-.77,-1.35,-.33,-.16,-.07,-.10,.24,-.27,-.44,-.54,-.66,1.05,-1.48,-1.03,.20)*f9_1+\n    mat4(2.31,-.41,-.26,-1.98,.90,-.71,-.09,-.79,-.38,.21,-.20,.72,-.47,-.97,.54,.33)*f9_2+\n    mat4(2.18,-.65,.40,-.35,-.39,-1.35,.45,.41,.34,.35,-.40,.62,-1.35,.27,-.43,-1.35)*f9_3+\n    vec4(2.38,-1.01,1.29,-2.38))/3.16+f9_3;\nvec4 f11_0=sin(mat4(-1.07,-.19,-.30,1.17,-.02,-.22,-.57,.61,.07,.04,-.80,-.69,1.07,-.76,-.95,2.01)*f10_0+\n    mat4(-.42,1.57,.11,-.34,-1.79,.66,.24,-1.03,-.44,-1.27,1.16,.19,-.12,-1.25,.36,.24)*f10_1+\n    mat4(.66,-2.15,-1.47,-1.90,.17,-.52,.07,-.25,-.77,-.71,-.36,2.27,.16,-1.06,.41,-.74)*f10_2+\n    mat4(.71,.56,-.81,1.42,-.59,-.51,1.64,-2.11,-1.33,-.55,-1.81,-.32,.85,.51,-1.13,-.94)*f10_3+\n    vec4(-.30,.12,.59,.67))/3.32+f10_0;\nvec4 f11_1=sin(mat4(.52,-.19,.38,-1.94,-.58,.87,-1.60,-1.50,1.42,.25,.46,.31,.25,.38,-.26,-1.33)*f10_0+\n    mat4(-.72,-.04,-.90,.37,-1.33,2.25,-2.24,.19,-.25,.54,1.83,1.68,1.23,-.43,-.70,-1.70)*f10_1+\n    mat4(.72,-.61,-1.64,-3.01,2.08,-.15,1.16,-1.33,.01,1.42,.58,-.99,-.28,-.24,-.87,-1.06)*f10_2+\n    mat4(.90,-.68,-1.01,-.00,1.36,-.28,.16,.07,.38,.59,-.57,-.96,.26,-.89,.68,-.05)*f10_3+\n    vec4(-.82,.44,.11,.10))/3.32+f10_1;\nvec4 f11_2=sin(mat4(.28,.37,-.41,-.13,.62,.55,.85,.05,-1.46,.00,-.41,-.68,1.58,.27,.15,-.20)*f10_0+\n    mat4(1.08,-.44,-.56,-.14,.23,-1.04,-.32,.72,-1.59,.66,.23,.68,.22,.37,.31,-.26)*f10_1+\n    mat4(.03,-1.39,1.07,1.22,1.02,1.89,1.14,.32,-1.11,-.54,-.97,.61,.67,.60,.17,1.40)*f10_2+\n    mat4(.99,-.48,-.37,-.90,-1.45,-.93,-.35,.19,-1.07,.84,.79,-.74,-.16,1.11,.00,-.19)*f10_3+\n    vec4(.72,-.96,-.29,.16))/3.32+f10_2;\nvec4 f11_3=sin(mat4(.45,-.47,-.39,-.16,-.38,-.36,.07,1.29,-.35,-.89,-.74,1.34,-.31,1.22,.21,-.11)*f10_0+\n    mat4(-.31,-.00,.22,-.07,.20,.34,-1.31,-.22,-.41,-.71,1.00,-.11,-.05,-.26,.54,1.36)*f10_1+\n    mat4(1.17,.57,.18,.97,.37,-.02,1.51,-.09,-.22,-.50,-1.14,-.80,.97,.00,.21,.60)*f10_2+\n    mat4(-1.44,.27,1.16,-.92,-.35,1.31,-.41,-.24,-.14,-.64,1.31,.25,.23,-.28,.65,-.83)*f10_3+\n    vec4(-.14,-.67,-.91,.05))/3.32+f10_3;\nvec4 f12_0=sin(mat4(.65,.57,-.36,-.97,-.19,-2.12,-.69,.32,-.52,-.94,-2.31,-.43,.37,-.56,-1.43,-1.20)*f11_0+\n    mat4(-.59,-.57,-.47,.07,.21,-.57,.63,1.43,.20,-.93,.91,.57,.37,1.14,.09,-.20)*f11_1+\n    mat4(.05,.85,-2.40,.13,-.44,-.06,-.33,.59,-1.09,.72,-.02,.84,-.64,-.24,-1.20,-.42)*f11_2+\n    mat4(1.13,1.31,.10,-1.85,.28,1.85,.46,-.69,1.14,.59,-1.42,-1.08,.13,.37,-1.06,.64)*f11_3+\n    vec4(-.63,-.44,.32,.55))/3.46+f11_0;\nvec4 f12_1=sin(mat4(-.04,.16,-1.08,.14,.51,.01,2.03,-.39,-.18,.13,.65,-.57,-.36,-.29,-1.40,-.62)*f11_0+\n    mat4(.83,.39,.28,.38,.76,-1.27,.96,-.93,.79,-.48,.92,-.04,-1.09,-.49,-.85,-2.06)*f11_1+\n    mat4(.20,-.00,.55,-.93,1.22,.12,-.73,1.04,.67,-.93,.63,.31,-.83,-.76,.56,-.30)*f11_2+\n    mat4(-1.50,.13,-.32,1.48,-.76,.02,-1.85,-.80,1.18,-.32,.96,.72,.36,.34,-.91,.22)*f11_3+\n    vec4(.62,1.14,1.70,1.16))/3.46+f11_1;\nvec4 f12_2=sin(mat4(.67,-.07,-.22,.60,.59,-1.62,.95,-.18,.12,.79,.91,.38,-.81,.38,-.67,.70)*f11_0+\n    mat4(-.25,-.33,-.41,-.32,-.76,-1.11,-.13,-.79,-1.58,.86,.27,.90,-1.07,-.45,.12,-.00)*f11_1+\n    mat4(.04,-.46,.78,-1.02,-.21,1.14,-.19,-.10,1.22,-.17,-1.00,-1.53,-.43,-1.84,-1.38,-1.03)*f11_2+\n    mat4(.85,-.90,.97,-1.27,-.25,-.41,-.41,.27,.84,1.27,.47,.72,-.49,.68,.49,1.51)*f11_3+\n    vec4(-.20,-1.22,.45,-.20))/3.46+f11_2;\nvec4 f12_3=sin(mat4(.36,.97,.44,-.48,-.22,-.70,.43,.61,-.29,.02,.23,-.09,-1.35,-.23,-.28,-.48)*f11_0+\n    mat4(.31,1.03,.11,.03,-.05,.43,.59,-.98,-.96,.02,-.40,.69,.51,.43,.71,-.24)*f11_1+\n    mat4(.49,-.23,.93,-.36,.18,-.05,-.63,.54,1.12,1.24,-.02,-1.65,-.06,-.20,.34,-1.02)*f11_2+\n    mat4(.42,1.62,-.75,-.55,-.83,-.22,.34,.84,-.32,.56,-1.70,.38,-.31,-.14,-.03,.04)*f11_3+\n    vec4(.66,1.11,-.74,-.86))/3.46+f11_3;\nvec4 f13_0=sin(mat4(-.87,-.06,-.36,.65,.03,-1.49,-1.23,.55,1.00,.22,1.73,2.04,-.49,.74,.59,1.84)*f12_0+\n    mat4(-.13,.39,-.99,.17,.87,1.06,1.71,1.71,.50,.78,.58,-1.36,-.29,-.12,.17,.07)*f12_1+\n    mat4(-1.14,-.14,-.19,.27,.93,-1.16,.11,.55,-.59,-.36,.62,.80,-.62,-.78,-1.10,.85)*f12_2+\n    mat4(-1.23,.57,.46,.47,-.25,-.05,.32,-.26,2.69,1.09,-.60,1.49,.23,-.01,.10,-.07)*f12_3+\n    vec4(-1.69,.92,.73,.89))/3.61+f12_0;\nvec4 f13_1=sin(mat4(-.62,.37,-.34,.45,-.81,-.66,-.08,-.43,-.14,.91,-.25,.36,.17,-.55,-.45,.74)*f12_0+\n    mat4(-1.65,.79,.74,1.19,-.35,-2.25,.86,-1.03,-.83,-2.19,2.55,-.97,1.27,.35,-.22,-2.03)*f12_1+\n    mat4(-.60,1.17,1.09,1.95,.15,-.60,-.20,-1.08,-.63,-1.34,.25,.51,-.46,-1.43,.10,.77)*f12_2+\n    mat4(-.68,.63,1.06,1.21,2.24,-.45,-1.35,-.40,-.74,-.10,.38,1.39,-.72,.99,.22,.51)*f12_3+\n    vec4(-1.49,.97,-2.02,-1.49))/3.61+f12_1;\nvec4 f13_2=sin(mat4(-.09,.05,-.01,.68,.22,1.09,.83,-.44,.17,1.37,-.62,.20,-.57,.31,-1.13,-.65)*f12_0+\n    mat4(-.79,.39,-.59,-.71,.36,-2.12,-.28,-.64,.79,.58,-.94,1.56,1.12,-.60,1.04,.54)*f12_1+\n    mat4(4.10,-.21,.99,-.87,-2.04,.34,-1.10,-1.31,.25,.07,2.21,-.37,1.19,.25,.88,.04)*f12_2+\n    mat4(-.91,-.02,-.70,-1.22,1.01,-1.12,.12,-.33,-.21,.38,-1.09,-.22,-.12,-.45,.66,.84)*f12_3+\n    vec4(1.10,-1.22,.90,-1.90))/3.61+f12_2;\nvec4 f13_3=sin(mat4(-.06,1.03,.11,-.37,.11,-.38,-.21,.74,.31,.12,-.61,-.64,-.78,.48,-.80,-1.34)*f12_0+\n    mat4(.13,.28,-.92,-.56,-.73,-1.21,1.08,-.78,.07,.05,-.66,.78,.52,-.48,-.06,-.97)*f12_1+\n    mat4(.80,-.44,.50,.83,.62,.05,-.83,-.29,-1.14,-.68,.60,.98,-.06,.52,-.18,-.20)*f12_2+\n    mat4(1.65,.33,-1.90,.63,.65,1.62,.67,-.53,1.07,1.32,-2.49,.55,-.07,.43,-.91,-.70)*f12_3+\n    vec4(-1.85,-1.23,1.27,-.69))/3.61+f12_3;\nvec4 f14_0=sin(mat4(1.29,-1.49,.86,-1.25,-1.34,1.78,-.60,-1.12,1.04,-1.25,-3.14,-1.56,-1.12,-.75,-1.75,-1.54)*f13_0+\n    mat4(-.61,-.14,-.03,.13,-.60,-.46,.27,.89,.21,-.97,-.15,.78,.18,.37,.72,.90)*f13_1+\n    mat4(1.34,.07,.51,-1.21,-1.15,.80,-1.41,.25,.73,-.68,.42,-.04,.48,1.50,-.79,.08)*f13_2+\n    mat4(-1.06,-.75,1.04,-1.78,2.46,1.12,-.10,1.23,.91,-.35,-.42,-1.51,.50,-.64,-.63,-.90)*f13_3+\n    vec4(-.76,-1.14,.65,1.02))/3.74+f13_0;\nvec4 f14_1=sin(mat4(-1.63,.29,1.55,-.84,1.70,-.81,-1.79,-.42,.37,.15,.91,-.74,-.55,-.00,-.37,1.27)*f13_0+\n    mat4(.00,.51,.51,.27,1.29,2.16,-.22,-.35,-.42,1.60,1.00,-.73,-1.24,.75,1.13,-.18)*f13_1+\n    mat4(.69,.40,1.65,-1.47,.61,.85,-.37,1.24,1.40,-.08,-1.10,-1.27,.34,.01,.20,.66)*f13_2+\n    mat4(-1.39,.75,.50,1.25,.88,.48,-1.44,-1.04,.78,.04,2.27,-.61,-1.38,.94,.80,.47)*f13_3+\n    vec4(2.14,-1.22,-2.07,.02))/3.74+f13_1;\nvec4 f14_2=sin(mat4(.22,.24,1.22,.47,1.30,.01,-1.18,.51,1.96,.43,-.91,.16,1.07,.45,1.51,-.65)*f13_0+\n    mat4(-.57,-.15,-.69,.38,.09,1.03,.44,1.22,-1.15,.07,1.82,.17,2.16,.12,.88,1.31)*f13_1+\n    mat4(-1.37,-2.16,-2.09,1.48,1.65,1.60,.73,.01,-.08,-.80,-1.47,-.32,.21,-.75,.08,1.61)*f13_2+\n    mat4(.03,.17,-.26,.16,.57,-.23,1.68,-1.51,.89,1.84,-.88,-.81,-.22,.47,1.69,1.74)*f13_3+\n    vec4(2.29,-1.20,-3.67,.61))/3.74+f13_2;\nvec4 f14_3=sin(mat4(.48,.15,.20,-.13,.53,-.91,-.53,-.31,-.48,.66,-.18,.35,-1.50,1.31,-.15,.27)*f13_0+\n    mat4(-.97,-.13,-.16,-.11,-.03,2.59,-.49,-.16,.31,1.29,1.00,1.56,-.27,.38,-.36,-.53)*f13_1+\n    mat4(1.22,-.24,.35,.51,.04,1.95,.24,.27,.25,.24,-.26,1.08,1.23,.73,.33,-.30)*f13_2+\n    mat4(-2.77,.19,-.11,.18,-1.07,-.49,.83,-1.64,-1.05,1.07,1.95,2.07,-.18,1.30,-.73,-.26)*f13_3+\n    vec4(-2.23,.38,2.54,.25))/3.74+f13_3;\nvec4 f15_0=sin(mat4(-1.54,-.71,-1.35,.29,.54,.75,1.07,-.92,-.11,-.71,4.73,.02,-1.70,.84,1.68,.34)*f14_0+\n    mat4(.77,.04,-.45,-.18,1.56,5.57,1.33,.27,.26,3.60,-.73,-1.24,.60,.10,.39,-.16)*f14_1+\n    mat4(-2.52,.46,3.16,-1.27,2.41,1.15,.29,-.50,-.47,.95,.53,-1.71,1.00,.54,-.31,-.17)*f14_2+\n    mat4(-1.07,.33,-.95,.99,-1.06,.57,-2.50,1.59,-1.14,-1.93,1.45,-.37,.49,-.23,.85,1.79)*f14_3+\n    vec4(-.60,-.80,.15,1.57))/3.87+f14_0;\nvec4 f15_1=sin(mat4(.71,-.08,.64,2.09,-.70,.07,1.00,-.88,1.22,-.30,.59,.36,.94,-.59,-.01,1.10)*f14_0+\n    mat4(-.40,.52,.01,-.22,1.23,-2.65,-2.56,.31,-.23,-1.01,-2.42,-.13,-.95,-1.10,.56,3.05)*f14_1+\n    mat4(-.65,-2.13,.09,-1.12,.16,.23,-1.06,-1.67,.92,-.50,-.36,-.87,-.49,-.56,-.40,-.95)*f14_2+\n    mat4(-1.59,.33,-.20,1.19,-.44,.81,1.68,.70,1.33,.62,-.82,-2.43,-1.86,-.32,.06,1.29)*f14_3+\n    vec4(2.71,.58,-.12,-.61))/3.87+f14_1;\nvec4 f15_2=sin(mat4(-1.28,.46,.51,2.41,.70,2.56,-1.05,1.00,-.90,.55,.05,-1.54,-.59,-.66,.63,2.07)*f14_0+\n    mat4(.39,-.46,.60,-.43,3.05,-.75,2.54,-1.79,.63,-.23,-1.39,-1.32,-1.16,.91,-.50,2.37)*f14_1+\n    mat4(-1.15,1.24,-1.07,-7.74,2.07,-.79,2.53,5.22,-.51,-.05,.88,-2.27,.45,.61,-.68,.87)*f14_2+\n    mat4(-.81,.09,-1.74,-1.28,-.33,-.79,-1.27,1.84,-.83,-2.11,-1.07,-.22,-.39,-.03,1.09,-.21)*f14_3+\n    vec4(1.61,-.69,.85,.44))/3.87+f14_2;\nvec4 f15_3=sin(mat4(-.43,.28,.11,2.05,2.92,-.14,.22,-1.33,-.33,-1.06,-.09,-.78,-.28,.55,.16,-.06)*f14_0+\n    mat4(-.69,-.40,.15,-.52,-1.83,-.75,-1.01,-1.23,-.88,.62,-.08,-.10,-.01,.38,-.13,2.20)*f14_1+\n    mat4(-1.86,.16,.61,-3.00,1.08,-1.02,.50,1.45,.62,-.93,-.44,-2.99,.50,.10,-.35,.12)*f14_2+\n    mat4(-2.29,-.62,.09,-1.04,-.69,-.73,-.11,2.85,-.92,-.10,2.25,-2.49,-1.39,.17,-.61,1.64)*f14_3+\n    vec4(.48,.19,-3.00,-.68))/3.87+f14_3;\nvec4 f16_0=sin(mat4(-1.61,-.78,2.06,-.75,-.63,-.09,-2.66,.38,.22,-.17,-13.77,-1.09,-.53,.33,-5.48,-.27)*f15_0+\n    mat4(-1.02,-1.68,1.38,-.77,.01,2.00,7.48,-2.17,-1.43,1.02,.60,-1.65,-.30,-.83,-4.41,3.58)*f15_1+\n    mat4(-2.62,-1.50,-7.05,-1.90,.99,.87,4.03,-.37,1.71,4.17,2.01,-.15,-.05,.95,5.35,-1.98)*f15_2+\n    mat4(-1.59,-1.20,-.43,-2.08,.68,1.09,9.15,-.48,-1.69,-1.21,-2.80,-3.66,-.29,-.85,-.03,.83)*f15_3+\n    vec4(-1.71,-1.42,-.66,1.08))/4.00+f15_0;\nvec4 f16_1=sin(mat4(-.09,.64,-.82,-.42,-1.23,-.04,.96,.74,-.91,-.71,-1.37,-.57,-1.24,-.61,-1.24,-2.03)*f15_0+\n    mat4(1.85,1.00,-.94,-.42,-7.01,-.52,-.50,-1.80,-2.97,.45,.22,-.67,-1.56,.07,1.04,-.51)*f15_1+\n    mat4(-2.11,.59,.61,-.50,-2.09,-1.31,2.47,.87,-1.04,-1.00,.46,.37,-2.93,-.58,.69,.36)*f15_2+\n    mat4(1.82,.64,-1.27,-3.65,1.46,-.32,-1.55,-1.16,2.58,-.48,3.32,-1.00,-1.06,-.27,-1.61,.51)*f15_3+\n    vec4(1.08,-1.12,.40,.11))/4.00+f15_1;\nvec4 f16_2=sin(mat4(.32,1.60,-.38,1.19,-1.98,-.25,-.65,-1.14,.95,-.17,.17,.23,.46,.85,-.06,.86)*f15_0+\n    mat4(1.26,1.22,-.54,.44,-5.70,1.42,1.62,-2.76,-3.14,2.32,.22,-3.90,-2.81,-.33,.39,.05)*f15_1+\n    mat4(-2.04,2.00,-.78,-.47,-3.22,-1.12,-.18,-1.67,-.55,-1.16,-.08,-1.25,-3.48,-.40,-.04,-2.09)*f15_2+\n    mat4(2.96,2.04,-.91,1.97,.83,-.07,.67,3.54,-1.89,1.46,-3.28,-1.07,1.95,-.19,.32,1.06)*f15_3+\n    vec4(1.66,-1.28,1.46,-1.12))/4.00+f15_2;\nvec4 f16_3=sin(mat4(-.22,1.02,.09,-.14,.26,.02,-.03,-.36,-.18,.08,.03,.34,-2.24,1.07,.18,.70)*f15_0+\n    mat4(-.27,.10,.25,.32,1.39,-.63,-2.15,3.63,.92,-.96,-.25,2.26,.80,.64,-.70,-.74)*f15_1+\n    mat4(-.08,-.37,-.10,.53,.33,-.46,.54,.89,-.11,-2.32,-.08,.29,1.65,-.43,-.12,-.13)*f15_2+\n    mat4(-2.15,1.31,.95,.69,-1.38,1.92,.35,-1.19,-2.68,2.27,4.30,-1.01,.31,1.42,-1.68,-.06)*f15_3+\n    vec4(-1.50,1.85,2.09,2.78))/4.00+f15_3;\nreturn vec4(dot(f16_0,vec4(-.26,-.04,.04,-.04)) + dot(f16_1,vec4(-.20,-.01,-.00,-.06)) + dot(f16_2,vec4(-.10,.36,.32,.17)) + dot(f16_3,vec4(-.23,-.30,.42,-.20)) + -0.04,\ndot(f16_0,vec4(-.21,-.06,.06,-.06)) + dot(f16_1,vec4(-.26,.14,-.14,.06)) + dot(f16_2,vec4(-.13,.24,.12,.16)) + dot(f16_3,vec4(-.21,.01,.01,.08)) + -0.04,\ndot(f16_0,vec4(-.21,-.04,.05,-.06)) + dot(f16_1,vec4(-.23,.24,-.11,.07)) + dot(f16_2,vec4(-.12,.21,.20,.16)) + dot(f16_3,vec4(-.25,-.10,-.19,.12)) + 0.04,\n1.0);\n}\n\nconst float pi = 3.14159265359;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n     vec2 pn = (iMouse.xy/iResolution.xy)*vec2(2.0,-2.0)+vec2(-1.,1.0)+vec2(cos(iTime),sin(iTime))*0.2;\n     pn.y -= 0.2;\n     fragColor = r(( (uv)*vec2(2.0,-2.0)+vec2(-1.,1.0))*vec2(iResolution.x/iResolution.y,1.0),iTime,pn); \n    \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sSSDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[178, 178, 210, 210, 28177], [28213, 28213, 28270, 28270, 28550]], "test": "valid"}
{"id": "7sSXDW", "name": "Fork Simplicity topgunner2 875", "author": "topgunner222", "description": "Parallax scrolling fractal galaxy.\nInspired by JoshP's Simplicity shader: https://www.shadertoy.com/view/lslGWr", "tags": ["fractal", "cineshader"], "likes": 14, "viewed": 1897, "published": "Public API", "date": "1620225391", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CBS\n//Parallax scrolling fractal galaxy.\n//Inspired by JoshP's Simplicity shader: https://www.shadertoy.com/view/lslGWr\n\n// http://www.fractalforums.com/new-theories-and-research/very-simple-formula-for-fractal-patterns/\nfloat field(in vec3 p,float s) {\n\tfloat strength = 7. + .03 * log(1.e-6 + fract(sin(iTime) * 4373.11));\n\tfloat accum = s/4.;\n\tfloat prev = 0.;\n\tfloat tw = 0.;\n\tfor (int i = 0; i < 26; ++i) {\n\t\tfloat mag = dot(p, p);\n\t\tp = abs(p) / mag + vec3(-.5, -.4, -1.5);\n\t\tfloat w = exp(-float(i) / 7.);\n\t\taccum += w * exp(-strength * pow(abs(mag - prev), 2.2));\n\t\ttw += w;\n\t\tprev = mag;\n\t}\n\treturn max(0., 5. * accum / tw - .7);\n}\n\n// Less iterations for second layer\nfloat field2(in vec3 p, float s) {\n\tfloat strength = 7. + .03 * log(1.e-6 + fract(sin(iTime) * 4373.11));\n\tfloat accum = s/4.;\n\tfloat prev = 0.;\n\tfloat tw = 0.;\n\tfor (int i = 0; i < 18; ++i) {\n\t\tfloat mag = dot(p, p);\n\t\tp = abs(p) / mag + vec3(-.5, -.4, -1.5);\n\t\tfloat w = exp(-float(i) / 7.);\n\t\taccum += w * exp(-strength * pow(abs(mag - prev), 2.2)); \n\t\ttw += w;\n\t\tprev = mag;\n\t}\n\treturn max(0., 5. * accum / tw - .7);\n}\n\nvec3 nrand3( vec2 co )\n{\n\tvec3 a = fract( cos( co.x*8.3e-3 + co.y )*vec3(1.3e5, 4.7e5, 2.9e5) );\n\tvec3 b = fract( sin( co.x*0.3e-3 + co.y )*vec3(8.1e5, 1.0e5, 0.1e5) );\n\tvec3 c = mix(a, b, 0.5);\n\treturn c;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n\tvec2 uvs = uv * iResolution.xy / max(iResolution.x, iResolution.y);\n\tvec3 p = vec3(uvs / 4., 0) + vec3(1., -1.3, 0.);\n\tp += .2 * vec3(sin(iTime / 16.), sin(iTime / 12.),  sin(iTime / 128.));\n\t\n\tfloat freqs[4];\n\t//Sound\n\tfreqs[0] = texture( iChannel0, vec2( 0.01, 0.25 ) ).x;\n\tfreqs[1] = texture( iChannel0, vec2( 0.07, 0.25 ) ).x;\n\tfreqs[2] = texture( iChannel0, vec2( 0.15, 0.25 ) ).x;\n\tfreqs[3] = texture( iChannel0, vec2( 0.30, 0.25 ) ).x;\n\n\tfloat t = field(p,freqs[2]);\n\tfloat v = (1. - exp((abs(uv.x) - 1.) * 6.)) * (1. - exp((abs(uv.y) - 1.) * 6.));\n\t\n    //Second Layer\n\tvec3 p2 = vec3(uvs / (4.+sin(iTime*0.11)*0.2+0.2+sin(iTime*0.15)*0.3+0.4), 1.5) + vec3(2., -1.3, -1.);\n\tp2 += 0.25 * vec3(sin(iTime / 16.), sin(iTime / 12.),  sin(iTime / 128.));\n\tfloat t2 = field2(p2,freqs[3]);\n\tvec4 c2 = mix(.4, 1., v) * vec4(1.3 * t2 * t2 * t2 ,1.8  * t2 * t2 , t2* freqs[0], t2);\n\t\n\t\n\t//Let's add some stars\n\t//Thanks to http://glsl.heroku.com/e#6904.0\n\tvec2 seed = p.xy * 2.0;\t\n\tseed = floor(seed * iResolution.x);\n\tvec3 rnd = nrand3( seed );\n\tvec4 starcolor = vec4(pow(rnd.y,40.0));\n\t\n\t//Second Layer\n\tvec2 seed2 = p2.xy * 2.0;\n\tseed2 = floor(seed2 * iResolution.x);\n\tvec3 rnd2 = nrand3( seed2 );\n\tstarcolor += vec4(pow(rnd2.y,40.0));\n\t\n\tfragColor = mix(freqs[3]-.3, 1., v) * vec4(1.5*freqs[2] * t * t* t , 1.2*freqs[1] * t * t, freqs[3]*t, 1.0)+c2+starcolor;\n}", "image_inputs": [{"id": "XdXGRr", "previewfilepath": "/presets/mic.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/mic.png", "ctype": "mic"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sSXDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 223, 255, 255, 642], [644, 680, 714, 714, 1102], [1104, 1104, 1128, 1128, 1311], [1314, 1314, 1371, 1371, 2790]], "test": "error"}
{"id": "7sSXWc", "name": "Simpler Cubic Solver", "author": "oneshade", "description": "Implementing the general formula for all real and complex roots. Its a LOT simpler.", "tags": ["simple", "complex", "solver", "cubic", "roots"], "likes": 7, "viewed": 119, "published": "Public", "date": "1621150343", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Implementing general formula from https://en.wikipedia.org/wiki/Cubic_equation\nconst vec2 eta = vec2(-0.5, sqrt(0.75)); // = (-1 + sqrt(-3))/2 = -cos(π/3) + sin(π/3)i\nvoid solveCubic(in float a, in float b, in float c, in float d, inout vec2[3] roots) {\n    b /= a, c /= a, d /= a;\n    float d0 = b * b - 3.0 * c;\n    float d1 = (2.0 * b * b - 9.0 * c) * b + 27.0 * d;\n    float q = d1 * d1 - 4.0 * d0 * d0 * d0, j = sqrt(abs(q));\n\n    vec2 C = q < 0.0 ? vec2(d1, j) : vec2(d1 + j, 0.0);\n    if (abs(C.x) + abs(C.y) < 1e-3) C = vec2(d1 - j, 0.0);\n    float t = atan(C.y, C.x) / 3.0, r = pow(0.25 * dot(C, C), 1.0 / 6.0);\n    C = vec2(cos(t), sin(t));\n\n    vec4 k = C.xyxy * eta.xxyy;\n    float h = d0 / r, w = -h - r, wi = h - r;\n    roots[0] = vec2(       C.x  * w - b,        C.y  * wi) / 3.0;\n    roots[1] = vec2((k.x - k.w) * w - b, (k.y + k.z) * wi) / 3.0;\n    roots[2] = vec2((k.x + k.w) * w - b, (k.y - k.z) * wi) / 3.0;\n}\n\n// Coloring code from @mla (https://www.shadertoy.com/view/tlVcD3)\n// I've fixed a minor mistake in the evaluation\nvec2 cmul(in vec2 z, in vec2 w) { return z * mat2(w.x, -w.y, w.yx); }\nvec2 cpoly3(in vec2 x, in float a, in float b, in float c, in float d) {\n    return a * cmul(x, cmul(x, x)) + b * cmul(x, x) + c * x + vec2(d, 0.0);\n}\n\nvec3 hsv2rgb(in float h, in float s, in float v) {\n    vec3 rgb = clamp(abs(mod(h * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n    rgb = rgb * rgb * (3.0 - 2.0 * rgb); // cubic smoothing       \n    return v * mix(vec3(1.0), rgb, s);\n}\n\nvec3 polycolor(in vec2 z) {\n    vec2 z0 = z;\n    float h = 0.5 + 0.5 * atan(z.y, z.x) / 3.14159265;\n    vec3 col = hsv2rgb(h, 1.0, sqrt(1.0 / (1.0 + length(z))));\n    z -= floor(z);\n    z = min(z, 1.0 - z);\n    col *= mix(0.5 + 0.5 * smoothstep(0.0, 0.1, min(z.x, z.y)), 1.0, min(1.0, length(z0) / 20.0));\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = 8.0 / iResolution.y;\n\n    // Coefficients\n    float a = sin(iTime * 0.25) * 2.0;\n    float b = sin(iTime * 0.5);\n    float c = cos(iTime * 0.75) * 2.0;\n    float d = sin(iTime);\n\n    vec3 color = polycolor(cpoly3(uv, a, b, c, d));\n\n    // Draw function\n    float f = a * uv.x * uv.x * uv.x + b * uv.x * uv.x + c * uv.x + d;\n    float g = 3.0 * a * uv.x * uv.x + 2.0 * b * uv.x + c; // Derivative for DE\n    color = mix(color, vec3(1.0, 0.0, 0.0), smoothstep(unit, 0.0, abs(uv.y - f) / sqrt(1.0 + g * g)));\n    color = mix(color, vec3(0.0, 0.0, 1.0), smoothstep(unit, 0.0, abs(uv.y)));\n\n    // Draw roots\n    vec2[3] roots;\n    solveCubic(a, b, c, d, roots);\n    for (int n=0; n < 3; n++) {\n        color = mix(color, vec3(1.0), smoothstep(unit, 0.0, length(uv - roots[n]) - 0.05));\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sSXWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[936, 1051, 1084, 1084, 1120], [1121, 1121, 1193, 1193, 1271], [1273, 1273, 1323, 1323, 1521], [1523, 1523, 1550, 1550, 1846]], "test": "error"}
{"id": "7sSXWR", "name": "Circle Gradience", "author": "Chidebe", "description": "I tried making a circle with gradience.", "tags": ["length", "gradience"], "likes": 3, "viewed": 157, "published": "Public API", "date": "1619988977", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy - iResolution.xy / 2.0f) / iResolution.y;\n    vec3 Col = vec3(0, 0, 0);\n    vec3 AfterCol = vec3(0, 0, 0);\n    \n    if( iTime <= 10.0f)\n    {\n        Col = vec3(sin(iTime), sin(iTime + length(uv)), cos(iTime * 0.4f));\n        vec2 Position = vec2(0, 0);\n        Col += distance(uv, Position);\n        vec2 GradienceDir = vec2(0, 0.3f);\n        float Intensity = 0.6f;\n        Col *= sin(iTime);\n    }\n    if( iTime > 11.0f)\n    {\n        /*AfterCol = vec3(sin(iTime) - 0.4f, sin(iTime + length(uv)), cos(iTime * 0.4f) - 0.4f);\n        vec2 Position = vec2(sin(iTime * uv.x), sin(iTime - 0.4f));\n        AfterCol += distance(uv, Position);\n        vec2 GradienceDir = vec2(0, 0.3f);\n        float Intensity = 0.6f;\n        AfterCol *= sin(iTime);*/\n        /*Col.x = mix(Col.x, AfterCol.x, 0.001f);\n        Col.y = mix(Col.y, AfterCol.y, 0.001f);\n        Col.z = mix(Col.z, AfterCol.z, 0.006f);*/\n    }\n    if( iTime > 9.0f)\n    {\n        Col = vec3(sin(iTime) - 0.4f, sin(iTime + length(uv)), cos(iTime * 0.4f) - 0.4f);\n        vec2 Position = vec2(sin(iTime * uv.x), sin(iTime - 0.4f));\n        Col += distance(uv, Position);\n        vec2 GradienceDir = vec2(0, 0.3f);\n        float Intensity = 0.6f;\n        Col *= sin(iTime);\n    }\n    \n    fragColor = vec4(Col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sSXWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1409]], "test": "valid"}
{"id": "7sSXWy", "name": "Rainbow Heart Tunnel", "author": "Bleuje", "description": "Simple 0.5 seconds loop.\nReproducing a gif animation from dvdp/davidope from memory (haven't got link, his tumblr posts are deleted). Using heart 2d sdf by iq.", "tags": ["raymarching", "heart", "rainbow"], "likes": 14, "viewed": 99, "published": "Public", "date": "1620910591", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// by @etiennejcb\n\n#define duration 0.5\n#define AA true\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\n// from iq https://www.shadertoy.com/view/3tyBzV\nfloat sdHeart( in vec2 p )\n{\n    p.x = abs(p.x);\n\n    if( p.y+p.x>1.0 )\n        return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n                    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n\nfloat de(vec3 p) {\n    p.y += 0.5+6.0*pow(0.1*abs(p.z),2.7);\n    float d = -sdHeart(p.xy);\n    \n    return d;\n}\n\nvec3 palette[8];\n\nvec3 colorOfPalette(float q)\n{\n    q = mod(q,1.0);\n    int ind = int(floor(q*7.999999999999));\n    return palette[ind];\n}\n\n\nvoid mainImage0(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = (fragCoord - .5*iResolution.xy) / iResolution.y;\n    \n    float time = mod(iTime/duration,1.0);\n    \n    // rainbow palette from https://loading.io/color/feature/Rainbow/\n    palette[0] = vec3(230.0,38.0,31.0)/256.0;\n    palette[1] = vec3(235.0,117.0,50.0)/256.0;\n    palette[2] = vec3(247.0,208.0,56.0)/256.0;\n    palette[3] = vec3(163.0,224.0,72.0)/256.0;\n    palette[4] = vec3(73.0,218.0,54.0)/256.0;\n    palette[5] = vec3(52.0,187.0,230.0)/256.0;\n    palette[6] = vec3(67.0,85.0,219.0)/256.0;\n    palette[7] = vec3(210.0,59.0,231.0)/256.0;\n\n\tvec3 ro = vec3(0, 0, -2);\n\tvec3 ta = vec3(0, 0, 0);\n\t\n\tvec3 fwd = normalize(ta - ro);\n\tvec3 left = cross(vec3(0, 1, 0), fwd);\n\tvec3 up = cross(fwd, left);\n\tvec3 rd = normalize(fwd + uv.x*left + uv.y*up);\n\n\tvec3 p;\n\tfloat t = 0., ri;\n\tfor (float i = 0.; i < 1.; i += .01) {\n\t\tri = i;\n\t\tp = ro + rd*t;\n\t\tfloat d = de(p);\n\t\tif (d < .001) break;\n\t\tt += d*.9;\n\t}\n    \n\tvec3 col = colorOfPalette(time+0.7*p.z);\n    \n\tfragColor = vec4(col, 1.);\n}\n\n// smart AA, from FabriceNeyret2\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    if(AA)\n    if ( fwidth(length(O)) > .01 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n     // O.r++;                        // uncomment to see where the oversampling occurs\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sSXWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[57, 57, 82, 82, 101], [103, 152, 180, 180, 400], [402, 402, 420, 420, 513], [533, 533, 563, 563, 654], [657, 657, 713, 713, 1710], [1712, 1745, 1781, 1781, 2132]], "test": "valid"}
{"id": "7sSXzG", "name": "Some Pink Planet", "author": "ReavenTehDerg", "description": "Some quick easy shader done for a friend of mine :)", "tags": ["space"], "likes": 2, "viewed": 32, "published": "Public", "date": "1620464217", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float N21(vec2 p)\n{\n    p = fract(p * vec2(6574.5414, 8961.8778));\n    p += dot(p, p + 23.45);\n    return fract(p.x * p.y);\n}\nvec2 N22(vec2 p)\n{\n    float x = N21(p);\n    float y = N21(p + x);\n    return vec2(x, y);\n}\nvec2 GetPos(vec2 id)\n{\n    vec2 n = N22(id) * 24.;\n    return sin(n) * .4;\n}\nfloat sn(vec2 uv)\n{\n    vec2 lv = fract(uv * 10.0);\n    vec2 id = floor(uv * 10.0);\n\n    lv = lv * lv * (3. - 2. * lv);\n\n    float bl = N21(id);\n    float br = N21(id +vec2(1, 0));\n    float b = mix(bl, br, lv.x);\n\n    float tl = N21(id + vec2(0,1));\n    float tr = N21(id +vec2(1, 1));\n    float t = mix(tl, tr, lv.x);\n\n    return mix(b, t, lv.y);\n}\nfloat stars(vec2 uv)\n{\n    vec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n    vec2 pos = GetPos(id);\n    float distance = length(gv - pos);\n    float shineRate = abs(sin(iTime * 0.8 * N21(id)));\n\n    float star = smoothstep(0.06, 0.059, distance) * shineRate;\n    return star - 0.15;\n}\nfloat circleMask(vec2 uv, float radius)\n{\n    float vL = length(uv);\n    float circle = smoothstep(radius, radius - 0.04, vL);\n    return circle;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n    float sunCircle = circleMask(uv + vec2(0.5, -0.3), 0.07) * 3.0;\n    vec3 sunColor = sunCircle * vec3(0.9, 0.7, 0.2);\n\n    float band = dot(uv, vec2(3.0, -8.0)) / 2.0;\n    float stars = stars(uv * 60.0);\n    float mixed = mix(band, stars, 1.0 - clamp(band, 0.0, 1.0));\n    vec3 bandColor = vec3(1.0, 0.2, 0.7) * mixed;\n\n\n    fragColor = vec4(bandColor + sunColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sSXzG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 125], [126, 126, 144, 144, 217], [218, 218, 240, 240, 294], [295, 295, 314, 314, 645], [646, 646, 668, 668, 936], [937, 937, 978, 978, 1084], [1086, 1086, 1143, 1143, 1588]], "test": "valid"}
{"id": "7tf3Dr", "name": "Twisting Skies", "author": "Tater", "description": "Made with creative direction from my sister. ", "tags": ["3d", "raymarch", "sun", "ocean", "twist", "reflective", "pillar", "chains"], "likes": 9, "viewed": 225, "published": "Public API", "date": "1621908672", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define pi 3.141596\n#define STEPS 200.0\n#define MDIST 250.0\n#define pmod(p,x) (mod(p, x) - (x)*0.5)\n\nvec3 g1 = vec3(0);\nfloat donut( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvec2 map2(vec3 p){\n    vec3 po = p;\n    float t = iTime*0.2;\n\n    vec2 a = vec2(1);\n    a.x = donut(p,vec2(2,0.5));\n    vec2 b = vec2(2);\n    p.yz*=rot(pi/2.0);\n    b.x = donut(p+vec3(2.5,0,0),vec2(2,0.5));\n    \n    //Colors\n    a.y = mix(1.0,2.0,clamp(30.0*sin(p.y*7.0+t*3.0),0.0,1.0));\n    vec3 p2 = p;\n    p2+=t*4.0;\n    b.y = mix(1.0,2.0,step(sin((p2.x)*10.0)*sin((p2.y)*10.0)*sin((p2.z)*10.0),-0.5));\n\n    b = (b.x < a.x) ? b:a;\n    \n    a = vec2(donut(p+vec3(-2.5,0,0),vec2(2,0.5)),3.0);\n    g1 += 0.05/(0.5+abs(a.x))*vec3(1.000,0.588,0.122);\n    b = (b.x < a.x) ? b:a;\n    \n    return b;\n}\nvec2 map3(vec3 p){\n    vec3 po = p;\n    float sep = 15.0;\n    p.x = pmod(p.x,sep);\n    vec2 a = map2(p);\n    p = po;\n    p.x+=sep*0.5;\n    p.x = pmod(p.x,sep);\n    p.zy*=rot(pi/2.0);\n    vec2 b = map2(p);\n    b = (b.x < a.x) ? b:a;\n    return b;\n}\nvec2 map(vec3 p){\n    vec3 po2 = p;\n    p.zy*=rot(pi/2.0);\n    \n    \n    vec3 po = p;\n    float t = iTime;\n    p.y+=6.0;\n    float th = atan(po.y,po.x)/(2.0*pi)+0.5;\n    float r = length(po.yx)-10.;\n    th*=60.0;\n    p.y = r;\n    p.x = th;\n    p.x+=t*9.0;\n    vec2 a = map3(p);\n    \n    po.xy*=rot(p.z*0.05);\n    //Big rings\n    float size = 15.0;\n    vec3 p2 = po; \n    \n    p2.xy = abs(p2.xy)-vec2(1,1)*4.5;\n    p2.xy*=rot(-0.9);\n    p2.y-=size*10.0;\n    p2.xz*=rot(pi/2.0);\n    p2.xy*=rot(t*0.2);\n    p = p2;\n    \n    th = atan(p2.y,p2.x)/(2.0*pi)+0.5;\n    \n    r = length(p2.yx)-10.0*size;\n    th*=60.0*size;\n    p.y = r;\n    p.x = th;\n\n    \n    vec2 b = map3(p);\n    b.x*=0.7;\n    b = (b.x < a.x) ? b:a;\n    \n    //Cut Cynlinder\n    p = po;\n    a.x = length(p.xy)-50.0;\n    a.y = 2.0;\n    b.x = max(a.x,b.x);\n\n    p.z+=sin(p.x+t*6.0)*0.025;\n    p.z+=sin(p.y+t*6.0)*0.02;\n    a = vec2(length(p.z),4.0);\n    b = (b.x < a.x) ? b:a;\n\n    //Pillars\n    p = po2;\n    p.xz = abs(p.xz)-vec2(70);\n    a = vec2(length(p.xz)-6.5,5.0);\n    a.x*=0.7;\n    b = (b.x < a.x) ? b:a;\n    \n    return b;\n}\n\n\nvec3 norm(vec3 p){\n    vec2 e= vec2(0.0005,0);\n    return normalize(map(p).x-vec3(\n    map(p-e.xyy).x,\n    map(p-e.yxy).x,\n    map(p-e.yyx).x));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    float t = iTime;\n    float t2 = t*0.05;\n    float outside = 80.0;\n    \n    vec2 off = vec2(outside*sin(t2),outside*cos(t2));\n    \n    vec3 ro = vec3(off.x,8.0,off.y);\n    vec3 lk = vec3(0,14,0);\n    vec3 f = normalize(lk-ro);\n    vec3 ra = normalize(cross(vec3(0,1,0),f));\n    vec3 rd = f*1.0+uv.x*ra+uv.y*cross(f,ra);\n    vec3 p = ro;\n    float shad = 0.0;\n    float dO = 0.0;\n    float dO2;\n    vec2 d;\n    float bnc = 0.0;\n    float dist = 0.0;\n    for(float i = 0.0; i < STEPS; i++){\n        p = ro+rd*dO;\n        d = map(p);\n        d.x = abs(d.x);\n        if(abs(d.x) < 0.001) {\n            if(d.y==3.0) {\n               d.x=0.1;\n            }\n            else{\n            shad = (i)/(STEPS);\n            if(bnc == 0.0)dist=dO;\n            if(bnc== 1.0||d.y!=4.0) {shad=i/STEPS; break; d.y = 0.0;}\n            ro += rd*dO;\n            vec3 n = norm(ro);\n            rd = reflect(rd,n);\n            ro += 0.1;\n            dO = 0.0;\n            i=0.0;\n            bnc++;\n            }\n            \n        }\n        if(dO2>MDIST){\n        if(bnc==0.0)p = ro+rd*MDIST;\n        d.y = 0.0;\n        break;\n        }\n        dO += d.x;\n        dO2 += d.x;\n    }\n    vec3 po = p;\n    p.y-=5.0;\n    vec3 sky = mix(vec3(0.012,0.490,0.647),vec3(0.145,0.118,0.522),clamp(p.y*0.01,0.0,1.0));\n    sky = mix(sky,vec3(1.000,0.773,0.141) * clamp(pow(abs(1.0 / (100.0 * length(p.xy*0.0004))),3.0),0.0,0.9),\n    pow(abs(1.0 / (100.0 * length(p.xy*0.0004))),3.9));\n    p=po;\n    vec3 al = vec3(0);\n    if(d.y!=0.0)shad = 1.0-shad;\n    if(d.y==1.0){\n    al = vec3(0.310,0.122,1.000);\n    }\n    if(d.y==2.0) {\n    al = vec3(1.000,0.588,0.122);\n    }\n    if(d.y==5.0) {\n    al = vec3(0.8);\n    }\n    if(d.y==4.0) {\n    al = sky;\n    }\n    vec3 n = norm(p);\n    vec3 ld = vec3(1,1,-1);\n    float spec = pow(max(dot(n,normalize(-rd)),0.0),30.0);\n    col = vec3(shad)*al;\n    if(d.y!=0.0&&d.y!=5.0){\n    col+=spec;\n    }\n    if(d.y==5.0){\n    col+=spec*0.2;\n    }\n    if(d.y==0.0)col = mix(col,sky,clamp(dO2/200.0,0.0,1.0));\n    col += min(g1*0.25,1.0);\n    \n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tf3Dr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[170, 170, 201, 201, 266], [268, 268, 286, 286, 864], [865, 865, 883, 883, 1112], [1113, 1113, 1130, 1130, 2203], [2206, 2206, 2224, 2224, 2352], [2353, 2353, 2410, 2410, 4572]], "test": "valid"}
{"id": "7tf3RM", "name": "Spherical Delinquency", "author": "Fahrenheitrequited", "description": "q", "tags": ["q"], "likes": 3, "viewed": 175, "published": "Public API", "date": "1621757546", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\nYou can lower the MARCH_STEPS and PART_COUNT if too slow\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/CorrodedBeasts.glsl\n*/\n\n#define MARCH_STEPS 100\n#define PART_COUNT 20\n\n#define time iTime\nfloat PI = acos(-1.0);\n\nfloat tor(vec3 p, vec2 r) {\n\tfloat x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat cyl(vec2 p, float r) {\n  return length(p)-r;\n}\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat cylcap( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sph(vec3 p, float r) {\n  return length(p) - r;\n}\n\nvec3 rep( vec3 p, vec3 c )\n{\n    return mod(p,c) - 0.5 * c;\n}\n\n\nvec3 replim( in vec3 p, in float c, in vec3 l){\n    return p-c*clamp(round(p/c),-l,l);\n    \n}\n\n\n\nvec3 moda(vec3 p, float rep, float off) {\n  vec2 rp = vec2(atan(p.z,p.x)/(2.0*PI), length(p.xz));\n  rp.x=(fract(rp.x*rep-0.5+off)-0.5)/rep;\n  rp.x *= 2.0*PI;\n  return vec3(cos(rp.x)*rp.y,p.y,sin(rp.x)*rp.y);\n}\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);\n}\n\nfloat noise(vec3 p) {\n  vec3 ip=floor(p);\n  p=fract(p);\n  p=smoothstep(0.0,1.0,p);\n  vec3 st=vec3(7,37,289);\n  vec4 pos=dot(ip,st) + vec4(0,st.y,st.z,st.y+st.z);\n  vec4 val=mix(fract(sin(pos)*7894.552), fract(sin(pos+st.x)*7894.552), p.x);\n  vec2 val2=mix(val.xz,val.yw, p.y);\n  return mix(val2.x,val2.y, p.z);\n}\n\nfloat fbm(vec3 p) {\n\n  float d=0.5;\n  float f=0.0;\n  for(int i=0; i<5; ++i) {\n    f+=noise(p/d)*d;\n    d*=.5;\n  }\n  return f;\n}\n\nfloat smin(float a, float b, float h) {\n  float k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k)-k*(1.0-k)*h;\n}\n\nvec3 smin(vec3 a, vec3 b, float h) {\n  vec3 k=clamp((a-b)/h*0.5+0.5,0.0,1.0);\n  return mix(a,b,k) - k*(1.0-k)*h;\n}\n\nvec3 tunnel(vec3 p){\n  vec3 off=vec3(0);\n  off.x += sin(p.z*0.2)*1.5;\n  off.y += sin(p.z*0.3)*1.3;\n  return off;\n}\n\nfloat pi = 3.141592;\nfloat surge (float tt) {\n\n   return (1. - cos(mod(tt*pi,pi))/2.)+floor(tt);\n \n}\n\nvec3 kifs(vec3 p) \n{\n  \n  float t = surge(time);\n  float s = 1.;\n  for ( float i = 0.; i <5.; i++ ) {\n  \n    p.xy *= rot((t-i));\n    p.yz *= rot((t+i) * .7);\n    p = abs(p);\n    p -= s;\n    s *= 0.65;\n  }\n  return p;\n}\n\nfloat map(vec3 p) {\n\n /*\n  float r = sph(p, 4.);\n\n  float t1 = time;\n  vec3 q = vec3(0);\n  q += kifs(p + kifs(p)/4.);\n  q += kifs(p + kifs(p)/5.);\n  \n  \n  p = rep(p, vec3(0,15,15) * sin(surge(t1 * .17)));\n  float s = sph(p + vec3(8,0,0) , 2.);\n  \n  \n  float f1= cylcap(q,3.,.1);\n  float f2 = min(f1,s);\n  \n return f2;\n */\n  float t1 = time;\n  float t = tor(p + vec3(0,0,5), vec2(3.,1.));\n  \n  vec3 q = rep(p, vec3(20,20,0) * sin(surge(t1 * .17)));\n  float s = sph(q , 1.);\n  return min(s,t);\n \n}\n\nvec3 norm(vec3 p) {\n  vec2 off=vec2(0.01,0.0);\n  return normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx))+0.000001);\n}\n\nfloat getao(vec3 p, vec3 n, float dist) {\n  return clamp(map(p+n*dist)/dist,0.0,1.0);\n}\n\nfloat getsss(vec3 p, vec3 r, float dist) {\n  return clamp(map(p+r*dist)*3.0,0.0,1.0);\n}\n\nfloat rnd(float t) {\n  return fract(sin(t*789.451)*7541.223);\n}\n\nfloat rnd(vec2 t) {\n  return fract(dot(sin(t*vec2(789.451)+t.yx*vec2(842.544)),vec2(7541.223)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float time = surge(iTime/1.);\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 s=vec3(0.0,0.0,-20.);\n  s.xz *= rot(time);\n  s.yz *= rot(time * .83);\n  \n  \n  vec3 t=vec3(0,0,0);\n  s.xy *= rot(surge(time*1.));\n  s.xz *= rot(surge(time*1.) * .61);\n  s *= sin(surge(iTime)) * .5 + 0.9;\n  float t2 = time*0.5;\n\n  vec3 cz=normalize(t-s);\n  vec3 cx=normalize(cross(cz,vec3(0,1,0)));\n  vec3 cy=normalize(cross(cz,cx));\n  vec3 r=normalize(cx*uv.x+cy*uv.y+cz*0.7);\n  //vec3 r=normalize(vec3(-uv, 0.7));\n\n  vec3 p=s;\n  float i=0.;\n  float mask=1.0;\n  float d = 10000.0;\n  float dd = 0.;\n  float rand=rnd(uv);\n  float dither=0.5+0.1*rand;\n  \n  for(float z=0.; z<100.; ++z) {\n    i = z;\n    d=map(p) *.5;\n    if(d<0.01) {\n      vec3 n = norm(p);\n      r = reflect(n,r);\n      d = 2.;\n      //break;\n    }\n    if ( dd > 100.) break;\n    dd += d;\n    p+=r*d;\n  }\n\n  vec3 col=vec3(0);\n  vec3 n = norm(p);\n  vec3 l =normalize(vec3(-0.2,0.2,0.5));\n  float t1=sin(time*0.2);\n  l.xz *= rot(t1);\n  l.xy *= rot(t1*3.2);\n  vec3 h = normalize(l-r);\n  float f = pow(1.0-abs(dot(n,r)), 3.0);\n  float fog = pow(1.0-float(i)/100.0,2.0);\n  \n  \n  col = 1. - pow(vec3(i/300.),vec3(.8));\n  col *= fog ;\n  fragColor = vec4(col, 1);\n\n  //float aodist=0.7;\n  //float ao = getao(p,n,aodist*0.2) * (getao(p,n,aodist*0.35)*0.5+0.5) * (getao(p,n,aodist*0.6)*0.25+0.75);\n  //float sss = (getsss(p,r,0.2)+getsss(p,r,0.5)*0.5)*0.9;\n\n  //vec3 back = mix(vec3(0.7,0.2,0.1), vec3(1,0.7,0.2), pow(max(0.0,dot(r,l)),5.0));\n\n  //float diff = fbm(p*15.0);\n  //diff=abs(diff-0.3)*2;\n  //diff=pow(smoothstep(0.1,0.9,diff),5.0)*2.7+0.9;\n  \n  //col += max(0.0,dot(n,l)*0.5+0.5) * fog * ao * (vec3(1,0.7,0.3) + pow(max(0.0,dot(n,h)),20.0));\n  //col += vec3(0.7,0.2,0.1)*0.5*pow(n.y*0.5+0.5,3.0);\n  //col += sss * fog * back * vec3(1,0.2,0.2) * 1.5 * diff;\n  //col += 3.0*f*(-n.y*0.5+0.5)*fog;\n  \n  //float len = length(p-s);\n  //col += back * max(clamp(d,0.0,1.0), clamp(dot(p-s,p-s)/200.0,0.0,1.0));\n\n  //vec3 col2 = vec3(0);\n  //for(int j=1; j<PART_COUNT; ++j) {\n  //  float dist = float(j) * 0.2/r.z;\n  //  if(dist>len) break;\n  //  vec3 vp = vec3(s.x,s.y,0) + r*dist;\n  //  vp.xy *=rot(sin(vp.z*10.0+time*0.2));\n  //  \n  //  col2 += dots(vp, float(j)) * clamp(1.0-dist/float(PART_COUNT), 0.0,1.0);\n  //}\n  //col += col2 * back;\n\n  //col *= pow(clamp(1.2-length(uv),0.0,1.0)*1.3,1.7);\n  //col = vec3(rnd(uv));\n  \n  \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tf3RM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[338, 338, 365, 365, 433], [435, 435, 463, 463, 487], [488, 488, 517, 517, 604], [605, 605, 647, 647, 754], [756, 756, 784, 784, 810], [812, 812, 840, 840, 873], [876, 876, 923, 923, 969], [973, 973, 1014, 1014, 1182], [1184, 1184, 1203, 1203, 1272], [1274, 1274, 1295, 1295, 1586], [1588, 1588, 1607, 1607, 1715], [1717, 1717, 1756, 1756, 1833], [1835, 1835, 1871, 1871, 1949], [1951, 1951, 1971, 1971, 2065], [2088, 2088, 2112, 2112, 2167], [2169, 2169, 2189, 2189, 2387], [2389, 2389, 2408, 2710, 2884], [2886, 2886, 2905, 2905, 3024], [3026, 3026, 3067, 3067, 3113], [3115, 3115, 3157, 3157, 3202], [3204, 3204, 3224, 3224, 3267], [3269, 3269, 3288, 3288, 3367], [3370, 3370, 3427, 3427, 5892]], "test": "valid"}
{"id": "7tf3WM", "name": "Distance to Voronoi", "author": "oneshade", "description": "Figured it out!", "tags": ["2d", "voronoi", "sdf", "borders", "exact"], "likes": 7, "viewed": 92, "published": "Public", "date": "1622186238", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\n// Random cycling points\nvec2 getPoint(in vec2 cell) {\n    float freq = Hash11(dot(cell, vec2(393.84, 673.48))) * 3.0 + 1.0;\n    float phase = Hash11(dot(cell, vec2(348.46, 183.37)));\n    float amp = Hash11(dot(cell, vec2(275.35, 741.69)));\n\n    float t = iTime * freq + phase;\n    return cell + 0.5 + 0.5 * vec2(cos(t), sin(t)) * amp;\n}\n\nvec3 sdVoronoi(in vec2 p) {\n    // Get closest point\n    vec2 cell = floor(p), closest = getPoint(cell);\n    float minDist = length(p - closest);\n    for (int i=-1; i < 2; i++) {\n        for (int j=-1; j < 2; j++) {\n            if (i == 0 && j == 0) continue;\n            vec2 curCell = cell + vec2(i, j), curPoint = getPoint(curCell);\n            float dist = length(p - curPoint);\n            if (dist < minDist) {\n                closest = curPoint;\n                minDist = dist;\n            }\n        }\n    }\n\n    // Get closest border\n    cell = floor(closest);\n    vec2 p1 = getPoint(cell + 1.0);\n    float dist = dot(p - 0.5 * (closest + p1), normalize(closest - p1));\n    for (int i=-2; i < 3; i++) {\n        for (int j=-2; j < 3; j++) {\n            if ((i == 0 && j == 0) || (i == 1 && j == 1)) continue;\n            vec2 curPoint = getPoint(cell + vec2(i, j));\n            dist = min(dist, dot(p - 0.5 * (closest + curPoint), normalize(closest - curPoint)));\n        }\n    }\n\n    return vec3(closest, dist);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 8.0;\n    vec3 voro = sdVoronoi(uv);\n\n    fragColor = vec4(smoothstep(0.05, 0.0, voro.z) + 0.25 + 0.25 * sin(voro.z * 50.0));\n    fragColor.rgb = mix(fragColor.rgb, vec3(1.0, 0.8, 0.0), smoothstep(0.05, 0.0, length(uv - voro.xy) - 0.05));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tf3WM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 89, 115, 115, 201], [203, 228, 257, 257, 540], [542, 542, 569, 594, 1563], [1565, 1565, 1620, 1620, 1927]], "test": "valid"}
{"id": "7tfGRn", "name": "SamRPG frog", "author": "alpar", "description": "gotta make that frog", "tags": ["frog"], "likes": 2, "viewed": 35, "published": "Public", "date": "1621391554", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circle (vec2 uv, vec2 p, float r, float blur) {\n    float d = length(uv - p);\n    float c = smoothstep(r, r-blur, d);\n    return c;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    float bodymask = 0.;\n    float eyemask = 0.;\n    float pupilmask = 0.;\n    float mouthmask = 0.;\n    bodymask = circle(uv, vec2(-0.25,0), 0.25, 0.1);\n    bodymask += circle(uv, vec2(0.25,0), 0.25, 0.1);\n    bodymask += circle(uv, vec2(0,-0.5), 0.75, 0.1);\n    eyemask = circle(uv, vec2(-0.25,0), 0.25, 0.1);\n    eyemask += circle(uv, vec2(0.25,0), 0.25, 0.1);\n    pupilmask = circle(uv, vec2(-0.25,0), 0.24, 0.1);\n    pupilmask += circle(uv, vec2(0.25,0), 0.24, 0.1);\n    \n    mouthmask = bodymask* circle(uv, vec2(0,-.9), 0.8, 0.1);\n    //col = vec3(0,0,1);\n    if (bodymask >= 0.85) {\n        col = vec3(0,.9,0);\n    }\n    if (bodymask >= 0.9) {\n        col = vec3(0,1,0);\n    }\n    if (eyemask >= 1.0) {\n        col = vec3(1,1,1);\n    }\n    if (pupilmask >= 1.0) {\n        col = vec3(0,0,0);\n    }\n    if (mouthmask >= 1.0) {\n        col = vec3(0.6,1,0);\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tfGRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 53, 53, 142], [144, 144, 201, 251, 1370]], "test": "valid"}
{"id": "7tfGzn", "name": "Frog Chill", "author": "alpar", "description": "chill vibes", "tags": ["frogvibes"], "likes": 0, "viewed": 69, "published": "Public", "date": "1621395192", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circle (vec2 uv, vec2 p, float r, float blur) {\n    float d = length(uv - p);\n    float c = smoothstep(r, r-blur, d);\n    return c;   \n}\n\nvec3 drawFrog(vec2 uv) {\n    vec3 col = vec3(0,0,0);\n    float bodymask = 0.;\n    float eyemask = 0.;\n    float pupilmask = 0.;\n    float mouthmask = 0.;\n    bodymask = circle(uv, vec2(-0.25,0), 0.25, 0.2);\n    bodymask += circle(uv, vec2(0.25,0), 0.25, 0.2);\n    bodymask += circle(uv, vec2(0,-0.5), 0.75, 0.2);\n    eyemask = circle(uv, vec2(-0.25,0), 0.25, 0.1);\n    eyemask += circle(uv, vec2(0.25,0), 0.25, 0.1);\n    pupilmask = circle(uv, vec2(-0.25,0), 0.24, 0.1);\n    pupilmask += circle(uv, vec2(0.25,0), 0.24, 0.1);\n    \n    mouthmask = bodymask* circle(uv, vec2(0,-.9), 0.8, 0.1);\n    //col = vec3(0,0,1);\n    if (bodymask >= 0.9) {\n        col = vec3(0,1,0);\n    }\n    if (eyemask >= 1.0) {\n        col = vec3(1,1,1);\n    }\n    if (pupilmask >= 1.0) {\n        col = vec3(0,0,0);\n    }\n    if (mouthmask >= 1.0) {\n        col = vec3(0.6,1,0);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    // Time varying pixel color\n    vec3 ogcol = 0.5 + cos(iTime*.5+uv.xyx+vec3(0,2,4))*vec3(1,0.2,1);\n    vec3 col = vec3(0,0,0);\n    for (float j=1.; j <= 10.; j++) {\n        for (float i = 1.; i <= 10.; i ++) {\n            vec2 smoluv = uv*5.0;\n            smoluv.x += uv.x - 10. + i*2.+mod(iTime,2.);\n            smoluv.y += uv.y + j*2. - 10.;\n            vec2 smoluv2 = uv*5.0;\n            smoluv2.y += uv.y - 10. + i*2.+mod(iTime,2.);\n            smoluv2.x += uv.x + j*2. - 11.;\n            //smoluv.x = smoluv.x*i;\n            col += drawFrog(smoluv);\n            col += drawFrog(smoluv2);\n        }\n    }\n\n    col *= ogcol;\n    col += ogcol*.2;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tfGzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 53, 53, 142], [144, 144, 168, 168, 1020], [1022, 1022, 1079, 1129, 1939]], "test": "valid"}
{"id": "7tlGDM", "name": "Pon Pon Pon [Skull and Eyes]", "author": "Yusef28", "description": "Thanks to iq for the beautypi example, thanks to shane for lighting examples and and great comments, thanks to kyary Pamyu Pamyu for \"Pon Pon Pon\", thanks to blackle for it's inspiring eye shader.\n\nSchadel und Augen ohne \"bounding sphere\"", "tags": ["3d", "cute", "eyes", "fast", "eye", "modeling", "fun", "skull", "eyeball", "teeth", "schadel", "augen"], "likes": 10, "viewed": 103, "published": "Public", "date": "1622340768", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define FAR 10.\n//grupp\nfloat augenGrossOffset = 0.;\nfloat augenGross = 0.3-0.2;\nvec3 augenDir = vec3(1., 0., 0.);\nvec3 augenPos = vec3(0.1,0.2,.2);\nvec3 augenSD = vec3(0.,0., 0.);\nfloat augenAbsOffset = 0.155;\n\n//einzel\nfloat augenGrossOffset2 = 0.;\nfloat augenGross2 = 0.3-0.2;\nvec3 augenDir2 = vec3(1., 0., 0.);\nvec3 augenPos2 = vec3(-0.165,0.125,.4);\nvec3 augenSD2 = vec3(0.,0., 0.);\nfloat augenAbsOffset2 = 0.155;\n\n//just wanted to add that a lot of the lighting stuff is Shane's\n//and his comments are still there.\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0;\n\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n}\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.50000*noise( p ); p = m*p*2.02;\n    f += 0.25000*noise( p ); p = m*p*2.03;\n    f += 0.12500*noise( p ); p = m*p*2.01;\n    f += 0.06250*noise( p ); p = m*p*2.04;\n    f += 0.03125*noise( p );\n\n    return f/0.984375;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r ){\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat smin( float a, float b, float k ){\n    float h = clamp( 0.5 + 0.5 * (b - a) / k, 0.0, 1.0 );\n    return mix( b, a, h ) - k * h * (1.0 - h);\n}\nfloat smax( float a, float b, float k ){\n    float h = clamp( 0.5 + 0.5 * (a - b) / k, 0.0, 1.0 );\n    return mix( b, a, h ) + k * h * (1.0 - h);\n}\nfloat knochen(vec3 p, vec3 xyz, vec3 dim, float th, float phi, float ga, \n                float spiegel, float r){\n    \n    vec3 sp = p - xyz;\n    sp.x = abs(sp.x) - spiegel;\n    \n    float cs = cos(th), si = sin(th);\n    sp.yz*=mat2(cs, si, -si, cs);\n    \n    cs = cos(phi), si = sin(phi);\n    sp.xz*= mat2(cs, si, -si, cs);\n    \n    cs = cos(ga), si = sin(ga);\n    sp.xy*= mat2(cs, si, -si, cs);\n        \n    sp = abs(sp) - dim;\n    return min(max(sp.x, max(sp.y, sp.z)), 0.0) + length(max(sp, 0.0)) - r;    \n}\nfloat sdCircleCircle( in vec3 p, in int n, float zeichen){\nfloat a0 = float(n) / radians(360.); \nfloat a = round(atan(p.z, p.x) * a0) / a0;\nvec3 sp = p - vec3(cos(a), 0.0, sin(a));\n  \nfloat cs = cos(a), si = sin(a);//erste versuch!!!!\nsp.xz*=mat2(cs, si, -si, cs);\n  \ncs = cos(0.3*zeichen), si = sin(0.3*zeichen);//erste versuch!!!!\nsp.xy*=mat2(cs, si, -si, cs);\n    \nsp = abs(sp) - vec3(0.1 + cos(sp.y*8.)*0.03, 0.19, 0.07 + cos(sp.y*6.+ 1.4)*0.05*zeichen);\nreturn min(max(sp.x, max(sp.y, sp.z)), 0.0) + length(max(sp, 0.0)) - 0.03;  \n\n    \n    //return sdCappedCylinder(sp, 0.05, 0.06) - 0.05; \n}\nvec4 objID, oSvObjID;\nfloat svObjID; // Global ID to keep a copy of the above from pass to pass.\nfloat map(vec3 p){\n    \n    //p.x+=1.;\n    //p.x = mod(p.x, 2.) - 1.;\n    \n    float PosX, PosY;\n    PosX;// = 0.;// - (iMouse.x)/iResolution.x;//0.2*2.*(rechts - links);\n    PosY;// = -0.1;// - (iMouse.y)/iResolution.y*4.;\n    \n\n    \n    \n\tp*=0.6;\n    p.y-=0.2 + sin(iTime)*0.1;\n    vec3 altp = p;\n    \n    float cs = cos(0.5), si = sin(0.5);\n    p.xz = mat2(cs, si, -si, cs)*p.xz;\n    cs = cos(-0.4), si = sin(-0.4);\n    p.yz = mat2(cs, si, -si, cs)*p.yz;\n    \n    vec3 sp = p - vec3(0., 0., 0.03);\n    float k = length(sp*vec3(1.-sin(sp.z*6.-0.4)*0.05, \n                             0.95+sin(sp.z*6.+1.6)*0.05, \n                             0.87)) - 0.5;\n    float alle = k;\n    \n    //schadel unten schneiden\n    sp = p;\n    k = length(sp - vec3(0., -0.9, -0.5)) - 0.7;\n    alle = smax(alle, -k, 0.09);\n    \n    ///return alle;\n    \n    //schadel seite\n    sp = p  - vec3(0., -0.05, -0.28);\n    sp.x = abs(sp.x) - 0.65;\n    //length(sp*vec3(1., 0.95+sin(sp.z*4.+0.8)*0.07, 0.87))\n    k = length(sp) - 0.3;\n    //k = length(sp*vec3(1., 0.95+sin(sp.z*4.+0.8)*0.07, 0.6)) - 0.3;\n    //alle = smax(alle, -k, 0.09);\n\n    //schadel seite knochen schneiden versuch\n    sp = p;\n    k = knochen(p, vec3(0., -0.15 , -0.18 ), \n                vec3(0.005, \n                     0.17 + sin(sp.z*4.+2.4)*0.1, \n                     0.2+ sin(sp.y*4.+2.)*0.18), \n                -0.2, -0.4, 0.1, 0.42+ sin(sp.z*4.+2.4)*0.05, 0.03);\n    alle = smax(alle, -k, 0.09);\n    \n    //return alle;\n    \n    //oben augen knochen\n    sp = p;\n    k = knochen(p, vec3(0., \n                        0. + cos(abs(sp.x)*8. + 5.)*0.03*1. - 0.04*1. , \n                        -0.45 - cos(abs(sp.x)*8. + 5.8)*0.05), \n                vec3(0.12, 0.005, 0.005), \n                0., 0., -0., 0.14, 0.04);\n    alle = smin(alle, k, 0.07);\n    \n    //return alle;\n\n    \n    //oberest knochen\n    sp = p;\n    k = knochen(p, vec3(0., 0.055 , -0.37 ), vec3(0.005, 0.005, 0.12), \n                -1., -0.25, 0., 0.28, 0.02);\n    alle = smin(alle, k, 0.06);\n    \n    //augen seit knochen\n    sp = p;\n    k = knochen(p, vec3(0., -0.14 , -0.46+ cos(sp.y*8.+1.5)*0.07), \n                vec3(0.01, 0.08, 0.02), \n                0.0, 0.0, 0.35, 0.26+ cos(sp.y*12.+1.2)*0.06, 0.015);\n    alle = smin(alle, k, 0.06);\n    \n    //wangen knochen vor\n    sp = p;\n    k = knochen(p, vec3(0., -0.28, -0.42+cos(abs(sp.x)*8.+2.)*0.02), \n                vec3(0.13, 0.055+sin(abs(sp.x)*8.+2.)*0.02, 0.05), \n                -0.5, 0.2, -0.1, 0.12, 0.05);\n    alle = smin(alle, k, 0.09);\n    \n    //return alle;\n    \n    //wangen knochen seit sollte dasselb (gesamt)breit haben wie die augen seit!\n    //wangen knochen seit\n    sp = p;\n    k = knochen(p, vec3(0., -0.3, -0.28), \n                vec3(0.007, 0.02-cos(sp.z*8. + 1.7-cos(sp.z*20. + 1.7))*0.01, 0.16), \n                0., 0.1, 0., 0.27 + cos(sp.z*8. + 2.)*0.09, \n                0.03 + cos(sp.z*8. + 4.7)*0.015);\n    alle = smin(alle, k, 0.02);\n    \n    float keiferHohe = 0.01;\n    //wangen knochen zu keifer\n    sp = p;\n    k = knochen(p, vec3(0., -0.51+keiferHohe, -0.25 - cos(abs(sp.y)*12. + 3.)*0.04), \n                vec3(0.005-cos(sp.z*12.+4.5)*0.004 - cos(sp.y*6.+1.2)*0.017, \n                     0.125, \n                     0.1), \n                0.2+(-sp.y-0.5)*0.2, -0.35, -0.25, \n                0.29 , 0.01); //keifer ein bisschen mehr eng war hilfreich\n    float keifer = k;\n    \n    \n    \n    \n    //keifer\n    sp = p;\n    k = knochen(p, vec3(0., -0.67+keiferHohe, -0.35), vec3(0.005, 0.02, 0.16), \n                -0.3, -0.5, 0., 0.18+cos(sp.z*8.+3.14)*0.02, 0.045);\n    keifer = smin(keifer, k, 0.04);\n    \n    //wkk schneid\n    sp = p;\n    k = knochen(p, vec3(0., -0.58+keiferHohe, -0.28 - cos(abs(sp.y)*12. + 3.)*0.06), \n                vec3(0.001, 0.15, 0.055), \n                0.2+(-sp.y-0.5)*0.2, -0.45, -0.3, 0.34, 0.01);\n    keifer = smax(keifer, -k, 0.04);\n    \n    //wkk loch\n    sp = p;\n    sp.x = abs(sp.x) - 0.31;\n    k = length(sp - vec3(0., -0.38+keiferHohe, -0.23)) - 0.06;\n    keifer = smax(keifer, -k, 0.04);\n    \n    \n    //kinn\n    sp = p;\n    k = knochen(p, vec3(0., -0.73+keiferHohe, -0.45-cos(sp.x*8.)*0.1), vec3(0.09, 0.02, 0.015), \n                0., 0., 0., 0., 0.03);\n    keifer = smin(keifer, k, 0.09);\n    \n\n    //sollte siemlich schaf sein\n    //augen loche\n    sp = p;\n    sp.x = abs(sp.x) - 0.172;\n    k = length(sp - vec3(0., -0.14, -0.48)) - 0.084;\n    alle = smax(alle, -k, 0.075);\n    \n    //nase\n    sp = p;\n    k = knochen(p, vec3(0., -0.23, -0.51), vec3(0.03, 0.09, 0.08), \n                -0.3, 0., 0.3, 0., 0.039);\n    alle = smin(alle, k, 0.06);\n    \n    //nase scheiden\n    sp = p;\n    k = knochen(p, vec3(0., -0.25, -0.54), vec3(0.022, 0.08, 0.07), \n                -0.35, 0., 0.3, 0., 0.03);\n    alle = smax(alle, -k, 0.04);\n    \n    //nase linie\n    sp = p;\n    k = knochen(p, vec3(0., -0.25, -0.5), vec3(0.001, 0.12, 0.07), \n                -0.35, 0., 0., 0., 0.005);\n    alle = smin(alle, k, 0.03);\n    \n    \n    float zahnNum = 12.;\n    float th = 0.15;\n    sp = p;\n    cs = cos(th), si = sin(th);\n    \n    sp = sp - vec3(0., -0.43, -0.4);\n    sp.yz*=mat2(cs, si, -si, cs);\n    \n    //cyl oben\n    \n    k = sdCappedCylinder(sp, 0.17 //nicht so breit\n                         + cos(sp.y*12. -5.)*0.015\n                         + abs(cos(atan(sp.z,sp.x)*zahnNum - 0.8))*0.005\n                         , 0.045 - abs(cos(atan(sp.z,sp.x)*zahnNum - 0.8))*0.02\n                        - cos(sp.z*6.-1.75)*0.05\n                        );\n    alle = smin(alle, k, 0.06); //weniger smooth weil die echte schadel\n    \n    \n    //return alle;\n    \n    //cyl unten\n    sp = p - vec3(0., -0.65+keiferHohe, -0.42);\n    k = sdCappedCylinder(sp, 0.15\n                         + cos(sp.y*12. - 1.5)*0.03\n                         + abs(cos(atan(sp.z,sp.x)*zahnNum - 0.8))*0.01\n                         , 0.05 - abs(cos(atan(sp.z,sp.x)*zahnNum - 0.8))*0.01);\n    keifer = smin(keifer, k, 0.06);\n\n    //oben zhan\n    sp = p - vec3(0.0, -0.51, -0.41);\n    cs = cos(0.33), si = sin(0.33);//erste versuch!!!!\n\tsp.xz*=mat2(cs, si, -si, cs);\n    k = sdCircleCircle(sp*6.6, 24, 1.); //nicht so breit\n    float zahn = k;\n    \n    //unten zahn\n    sp = p - vec3(0.0, -0.58+keiferHohe, -0.39);\n    cs = cos(0.33), si = sin(0.33);//erste versuch!!!!\n\tsp.xz*=mat2(cs, si, -si, cs);\n    \n    k = sdCircleCircle(sp*6.6, 24, -1.);//nicht so breit\n    zahn = min(zahn, k);\n    \n    \n    alle = smin(zahn,alle, 0.09);\n    alle = smin(alle, keifer, 0.09);\n    \n    //cyl schneiden\n    sp = p - vec3(0., -0.58, -0.15);\n    k = sdCappedCylinder(sp, 0.17, 0.24);\n    alle = smax(alle, -k, 0.06);\n    \n    //schonheit\n    sp = p;\n    sp.x = abs(sp.x) - 0.18;\n    k = length(sp - vec3(0., -0.32, -0.522)) - 0.012;\n    alle = smax(alle, -k, 0.01);\n    objID = vec4(zahn-0.05, alle, 0, 0);\n    \n    //schadel augen\n    sp = p;\n    sp*=0.9;\n    sp += augenPos2;\n\n    \n    float augen = length(sp)-augenGross;    \n    alle = min(alle, augen);\n    objID[2] = augen;\n    \n    \n    //augen grupp\n    p = altp;\n    //p*=0.9;\n    sp = p;\n    sp*=0.9;\n    sp += augenPos;\n    //Spin\n    cs = cos(iTime), si = sin(iTime);\n    sp.xz*=mat2(cs, si, -si, cs);\n    \n    //Tilt z\n    cs = cos(-0.2), si = sin(-0.2);\n    sp.xy*=mat2(cs, si, -si, cs);\n    \n    //Tilt x\n    cs = cos(-0.2), si = sin(-0.2);\n    sp.yz*=mat2(cs, si, -si, cs);\n    \n    float a0 = float(12.) / radians(360.); \n    float a = round(atan(sp.z, sp.x) * a0) / a0;\n    sp = sp - vec3(cos(a)*.75, 0.0, sin(a)*.75);\n    //drehen\n    \n\n    augen = length(sp)-augenGross;    \n    alle = min(alle, augen);\n    \n    objID[3] = augen;\n    \n    \n    return alle;\n}\nfloat trace(vec3 ro, vec3 rd){\n   \n    float t = 0., d;\n    \n    for (int i = 0; i < 96; i++){\n\n        d = map(ro + rd*t);\n        \n        // Using the hacky \"abs,\" trick, for more accuracy. \n        if(abs(d)<.0001 || t>FAR) break;        \n        \n        t += d*.85;  // Using more accuracy, in the first pass.\n    }\n    \n    return t;\n}\n//thanks to Shane\nfloat softShadow(vec3 ro, vec3 lp, float k){\n\n    const int maxIterationsShad = 24; \n    \n    vec3 rd = lp - ro; \n\n    float shade = 1.;\n    float dist = .002;    \n    float end = max(length(rd), .001);\n    float stepDist = end/float(maxIterationsShad);\n    \n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = 0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, .2), \n        // clamp(h, .02, stepDist*2.), etc.\n        dist += clamp(h, .02, .25);\n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0. || dist>end) break; \n        //if (h<.001 || dist > end) break; // If you're prepared to put up with more artifacts.\n    }\n\n    // I've added 0.5 to the final shade value, which lightens the shadow a bit. It's a preference thing. \n    // Really dark shadows look too brutal to me.\n    return min(max(shade, 0.) + .25, 1.); \n}\nvec3 getNormal(in vec3 p)\n{\n    vec3 n = vec3(0.0);\n    for( int i=min(iFrame,0); i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+0.001*e);\n    }\n    return normalize(n);\n}\nvec3 getObjectColor(vec3 p){\n\n    float PosX;// - (iMouse.x)/iResolution.x;//0.2*2.*(rechts - links);\n    float PosY;// - (iMouse.y)/iResolution.y*4.;\n    p*=0.6;\n    p.y-=0.2+ sin(iTime)*0.1;\n    // \"floor(p)\" is analogous to a unique ID - based on position.\n    vec3 ip = floor(p);\n    \n    vec3 knochenFarber = vec3(237./255., 218./255., 201./255.)*1.5;\n    vec3 schwarze = vec3(0.);\n    vec3 rot = vec3(0.4, 0., 0.);\n    // Color up the objects in a cubic checkered arrangement using a subtle version\n    // of IQ's palette formula.\n\n    vec3 col =  vec3(0.2, 1.9, 1.8)*1.;//vec3(.9, .45, 1.5);\n    \n    \n    float x = sin(atan(p.x, p.y)*20.);\n    vec3 azure = vec3(255., 20., 90. )/255.;\n    col = mix(col, azure, smoothstep(-0.01, 0.01,x)*0.5);\n    \n    //col = vec3(2.);\n    //col = vec3(237./255., 218./255., 201./255.)*1.5;\n    //col = vec3(0.03);///schwarz\n    // Reverse the RGB channels on some of the objects, for a bit of variance.\n    //if(fract(rnd*1183.5437 + .42)>.65) col = col.zyx;\n    vec3 gold = vec3(205./255.,120./255.,15./255.)*1.5;\n    vec3 silber = vec3(0.2,0.3, 0.4);\n    //zahn\n    //if(stripe > 0.){col = vec3(1.0-stripe*0.7)*1.5;}\n    //keifer\n    if(svObjID == 0.){col = vec3(2.);}\n    if(svObjID == 2.){\n    \n    //drehung von schadel\n    float cs = cos(0.5), si = sin(0.5);\n    p.xz = mat2(cs, si, -si, cs)*p.xz;\n    \n    cs = cos(-0.4), si = sin(-0.4);\n    p.yz = mat2(cs, si, -si, cs)*p.yz;\n  \n    \n    \n    \n    vec3 sp = p; \n    sp*=.9;\n    sp += augenPos2;\n    \n    //drehung fur augen\n    cs = cos(-2.2), si = sin(-2.2);\n    sp.xz = mat2(cs, si, -si, cs)*sp.xz;\n    cs = cos(-0.4), si = sin(-0.4);\n    sp.xy = mat2(cs, si, -si, cs)*sp.xy;\n    cs = cos(iTime), si = sin(iTime);\n    sp.yz = mat2(cs, si, -si, cs)*sp.yz;\n    \n    float winkle = atan(sp.y*2., sp.z*2.);\n    float lange = length(sp.yz*2.);\n    float f;\n    \n    \n    col = vec3(0.9, 0.2, 0.1)*(0.5+0.5*sin(winkle*40.+cos(length(sp.yz)*100.)));\n    \n    float a = 7.;\n    vec3 iris = vec3(abs(sin(a*3.)), abs(cos(a+1.)), abs(cos(a*2.)));\n    //iris = pow(iris,vec3(2.));\n    col = iris;//pow(iris,vec3(2.));\n    //sp.x*=2.;\n    //grundlich rauche\n    f = fbm( 20.0*sp.yz*2. );\n    col = mix( col, vec3(0.2,0.5,0.4), f );\n\n    \n    //gelb fur iris\n    col = mix( col, vec3(0.9, 0.8,0.7), 1.0-smoothstep(0.06,0.12,lange*1.2) );\n    \n    //wolken\n    winkle += 0.05*fbm( 20.0*p.yz*2. );\n    f = smoothstep( 0.3, 1.0, fbm( vec2(15.0*winkle,20.0*lange) ) );\n    col = mix( col, iris*1.2, f );//vec3(1.0,1.0,1.0)\n    \n    //schwarze\n    f = smoothstep( 0.4, 0.9, fbm( vec2(15.0*winkle,10.0*lange) ) );\n    col = mix( col, iris*0.5, f );//vec3(0.)\n    \n    //pupille\n    f = 1.0-smoothstep( 0.05, 0.06, lange*1.2 );\n    col = mix( col, vec3(0.0), f );\n   \n    //besser farber\n    col = pow(col,vec3(2.));\n    \n    //dunkle ringe\n    f = smoothstep( -0.27, -0.25, sp.x*3.45);\n    col = mix( col, pow(col,vec3(2.)), f );\n    \n    //schneiden\n    col = mix(col, vec3(2.), \n    smoothstep(-0.25, -0.24, sp.x*3.6));\n    \n    //veins\n    f = smoothstep( 0.3, 1.0, fbm( vec2(25.0*winkle,15.0*lange) ) );\n    f *= smoothstep(0.1, 0.3, sp.x*3.5);\n    col = mix( col, vec3(1.0,0.,0.), f );\n    \n    //rot fur hinten\n    col = mix(col, vec3(2.,0.,0.), \n    smoothstep(0.1, 0.4, sp.x*2.));\n\n    return col;\n    \n}\n\n    if(svObjID == 3.){\n\n    vec3 sp = p; \n    sp*=0.9;\n    sp += augenPos;\n    //Spin\n    float cs = cos(iTime), si = sin(iTime);\n    sp.xz*=mat2(cs, si, -si, cs);\n    \n    //Tilt z\n    cs = cos(-0.2), si = sin(-0.2);\n    sp.xy*=mat2(cs, si, -si, cs);\n    \n    //Tilt x\n    cs = cos(-0.2), si = sin(-0.2);\n    sp.yz*=mat2(cs, si, -si, cs);\n    \n    float a0 = float(12.) / radians(360.); \n    float a = round(atan(sp.z, sp.x) * a0) / a0;\n    sp = sp - vec3(cos(a)*.75, 0.0, sin(a)*.75);\n    cs = cos(a), si = sin(a);\n    sp.xz*=mat2(cs, si, -si, cs);\n    \n\n    //sp.xy = mod(sp.xy, 0.75)-0.3725;\n    \n    //vec2 polyz = vec2(atan(sp.x, sp.y), length(sp.xy));\n    //vec2 polxy = vec2(atan(sp.x, sp.y), length(sp.xy));\n    //vec3 tx = mix(vec3(0.2, 1.9, 1.8), vec3(2.),\n    //smoothstep(-0.2, 0.2, sin(polyz.x*50.) ));\n    \n    //col = mix(vec3(0.2, 1.9, 1.8)*0.1, vec3(2.), \n    //smoothstep(-0.2, 0.2, sin(dot(augenDir,sp)*50.) )) ;\n    \n    \n\n    float winkle = atan(sp.y*2., sp.z*2.);\n    float lange = length(sp.yz*2.);\n    float f;\n    \n    \n    col = vec3(0.2, 1.9, 1.8)*0.6*sin(winkle*40.+cos(length(sp.yz)*100.));\n    \n    col = vec3( 0.0, 0.3, 0.4 )+a/5.;\n    \n    vec3 iris = vec3(abs(sin(a*3.)), abs(cos(a+1.)), abs(cos(a*2.)));\n    iris = pow(iris,vec3(2.));\n    col = iris;//pow(iris,vec3(2.));\n    //sp.x*=2.;\n    //grundlich rauche\n    f = fbm( 20.0*sp.yz*2. );\n    col = mix( col, vec3(0.2,0.5,0.4), f );\n    \n    //gelb fur iris\n    col = mix( col, vec3(0.9, 0.8,0.7), 1.0-smoothstep(0.06,0.12,lange*1.2) );\n    \n    //wolken\n    winkle += 0.05*fbm( 20.0*p.yz*2. );\n    f = smoothstep( 0.3, 1.0, fbm( vec2(15.0*winkle,20.0*lange) ) );\n    col = mix( col, iris*1.1, f );//vec3(1.0,1.0,1.0)\n    \n    //schwarze\n    f = smoothstep( 0.4, 0.9, fbm( vec2(15.0*winkle,10.0*lange) ) );\n    col = mix( col, iris*0.5, f );//vec3(0.)\n    \n    //pupille\n    f = 1.0-smoothstep( 0.05, 0.06, lange*1.2 );\n    col = mix( col, vec3(0.0), f );\n   \n    //besser farber\n    col = pow(col,vec3(2.));\n    \n    //dunkle ringe\n    f = smoothstep( -0.27, -0.25, sp.x*3.45);\n    col = mix( col, pow(col,vec3(2.)), f );\n    \n    //schneiden\n    col = mix(col, vec3(2.), \n    smoothstep(-0.25, -0.24, sp.x*3.6));\n    \n    //veins\n    f = smoothstep( 0.3, 1.0, fbm( vec2(25.0*winkle,20.0*lange) ) );\n    f *= smoothstep(0.1, 0.3, sp.x*3.5);\n    col = mix( col, vec3(1.0,0.,0.), f );\n    \n    //rot fur hinten\n    col = mix(col, vec3(2.,0.,0.), \n    smoothstep(-0.1, 0.4, sp.x*3.));\n    \n    \n    }\n\n    return col;\n    \n}\n\n//thanks to Shane\nvec3 doColor(in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, float t){\n    \n    vec3 ld = lp-sp; // Light direction vector.\n    float lDist = max(length(ld), .001); // Light to surface distance.\n    ld /= lDist; // Normalizing the light vector.\n    \n    // Attenuating the light, based on distance.\n    float atten = 1. / (1. + lDist*.2 + lDist*lDist*.1);\n    \n    // Standard diffuse term.\n    float diff = max(dot(sn, ld), 0.);\n    // Standard specualr term.\n    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.), 5.);\n    if(svObjID == 0.){spec = pow(spec*6.,3.);}\n    if(svObjID == 3.){spec = pow(spec*3.,3.);}\n    // Coloring the object. You could set it to a single color, to\n    // make things simpler, if you wanted.\n    vec3 objCol = getObjectColor(sp);\n    \n    // Combining the above terms to produce the final scene color.\n    vec3 sceneCol = (objCol*(diff + 0.15) + vec3(0.8, 0.8, 1.)*spec*(1.2-svObjID/3.)) * atten;\n    \n    \n    // Fog factor -- based on the distance from the camera.\n    float fogF = smoothstep(0., .95, t/FAR);\n    //\n    // Applying the background fog. Just black, in this case, but you could\n    // render sky, etc, as well.\n    \n   \n    \n    //sceneCol = mix(sceneCol, vec3(1.,1., 0.), fogF); \n\t//sceneCol = mix(sceneCol, vec3(1.), 1.0-length(sp.xy)-0.5);\n    \n    // Return the color. Performed once every pass... of which there are\n    // only two, in this particular instance.\n    return sceneCol;\n    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinates.\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.y;\n    \n    // Unit direction ray.\n    vec3 rd = normalize(vec3(uv, 1.));\n    \n\n    //rd.xy = mat2(cs, si, -si, cs)*rd.xy;\n    //rd.xz = mat2(cs, si, -si, cs)*rd.xz;\n    \n    // Ray origin. Doubling as the surface position, in this particular example.\n    // I hope that doesn't confuse anyone.\n    vec3 ro = vec3(-0.18, .0, -3.2);\n    \n    // Light position. Set in the vicinity the ray origin.\n    vec3 lp = ro + vec3(0., 2., -0.5);\n    \n    \n    // FIRST PASS.\n    \n    float shauen = sin(-iTime+2.)/4.;\n    float cs = cos(shauen), si = sin(shauen);\n    \n    //augenPos.y += sin(iTime)/9.;\n    augenDir.xz = mat2(cs, si, -si, cs)*augenDir.xz;\n    \n    float t = trace(ro, rd);\n    \n    //Speichern Save the object IDs after the first pass.\n    \n    svObjID = objID.x<objID.y? 0. : 1.;\n    if(objID.z < objID.x && objID.z < objID.y) svObjID = 2.;\n    if(objID[3] < objID[0] && objID[3] < objID[1]){ svObjID = 3.;}\n    oSvObjID = objID;\n   \n    //thanks to Shane\n    // Advancing the ray origin, \"ro,\" to the new hit point.\n    ro += rd*t;\n    \n    //thanks to Shane\n    // Retrieving the normal at the hit point.\n    vec3 sn = getNormal(ro);\n    \n    //thanks to Shane\n    vec3 sceneColor = doColor(ro, rd, sn, lp, t);\n    if(t +0.001 > FAR){\n    float x = fract(uv.x*8.);\n    vec3 azure = vec3(20., 90., 255.)/255.;\n    vec3 hintergrund = mix(azure*0.25, azure, smoothstep(0.48, 0.52,x))*2.;\n    sceneColor = hintergrund;\n    }\n    float sh = softShadow(ro +  sn*.0015, lp, 16.);\n\n    sceneColor *= sh;\n    \n\tfragColor = vec4(sqrt(clamp(sceneColor, 0., 1.)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tlGDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[573, 573, 596, 596, 635], [637, 637, 663, 663, 884], [886, 886, 907, 907, 1154], [1156, 1156, 1207, 1207, 1314], [1315, 1315, 1355, 1355, 1462], [1463, 1463, 1503, 1503, 1610], [1611, 1611, 1725, 1725, 2123], [2124, 2124, 2182, 2182, 2722], [2760, 2820, 2838, 2889, 10457], [10458, 10458, 10488, 10488, 10800], [10801, 10819, 10863, 10863, 12131], [12132, 12132, 12159, 12159, 12367], [12368, 12368, 12396, 12396, 18174], [18176, 18194, 18264, 18264, 19644], [19645, 19645, 19701, 19729, 21357]], "test": "valid"}
{"id": "7tlGRB", "name": "sphere basic /w SDF", "author": "spectrum", "description": "이제 조금 뭔가 알 것 같기도 하고.\nsphere 에 pow 할때 .3 곱하니까 쨍하다.", "tags": ["sdf"], "likes": 1, "viewed": 135, "published": "Public API", "date": "1622362339", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sphereSDF(vec2 pos, float r, vec2 center)\n{\n    // center\n    return pow(max(r - length(pos - center), 0.), r*.3)*2.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // 중앙을 (.5,.5)으로 잡는다. 비율은 y기준으로 유지.\n\tvec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 val = vec3(0,0,0);\n    \n    val += vec3(sphereSDF(uv, .05*abs(sin(200.+iTime*6.))+.25, vec2(0.,0.)) ,0.,0.);\n    val += vec3(0.,0.,sphereSDF(uv, .05*abs(sin(0.+iTime*6.))+.25, vec2(.4,.0)));\n    val += vec3(0.,sphereSDF(uv, .05*abs(sin(400.+iTime*6.))+.25, vec2(-.4,.0)), 0.);\n\n    fragColor = vec4(vec3(val), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tlGRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 49, 63, 125], [127, 127, 184, 258, 641]], "test": "valid"}
{"id": "7tlGRM", "name": ":) by notargs ", "author": "jorge2017a1", "description": ":) by notargs ", "tags": ["bynotargs"], "likes": 11, "viewed": 121, "published": "Public", "date": "1621800359", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//:) by notargs \n\n#define PI 3.1415926535\n\nfloat rand(float a, float b)\n{\n    return fract(sin(dot(vec2(a, b) ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\t//vec2 pos = ( fragCoord.xy - iResolution.xy / 2.) / iResolution.y + iMouse.xy - 0.5;\n    vec2 pos = ( fragCoord.xy - iResolution.xy / 2.) / iResolution.y- 0.5;\n    pos-=vec2(-0.5,-0.5);\n\t\n\tvec3 color = vec3(0, 0, 0);\n\t\n\tfor(int i = 0; i < 200; i++)\n\t{\n\t\tfloat fi = float(i);\n\t\tfloat t  = pow(fract(iTime * 2.), 0.5);\n\t\tfloat t2 =     floor(iTime * 2.);\n\t\tfloat a = float(i) / PI;\n\t\tfloat len = 0.3 + (1. - t) * 0.2 * rand(fi, t2);\n\t\tvec2 p = pos + vec2(cos(a), sin(a)) * len;\n\t\tfloat intencity = pow(0.003 / length(p), 1.5);\n\t\tcolor += intencity * vec3(rand(fi, 1.), rand(fi, 2.), rand(fi, 3.));\n\t}\n\tfor(int i = 0; i < 20; i++)\n\t{\n\t\tfloat fi = float(i);\n\t\tfloat t  = pow(fract(iTime * 2.), 0.1);\n\t\tfloat t2 =     floor(iTime * 2.);\n\t\tfloat a = float(i - 10) / PI / 5.;\n\t\tfloat len = 0.3 + (1. - t) * 0.2 * rand(fi, t2);\n\t\tvec2 p = pos + vec2(sin(a), cos(a)) * len;\n\t\tp += vec2(0, -0.1);\n\t\tfloat intencity = pow(0.003 / length(p), 1.5);\n\t\tcolor += intencity * vec3(rand(fi, 1.), rand(fi, 2.), rand(fi, 3.));\n\t}\n\tfor(int i = 0; i < 20; i++)\n\t{\n\t\tfloat fi = float(i);\n\t\tfloat t  = pow(fract(iTime * 2.), 0.1);\n\t\tfloat t2 =     floor(iTime * 2.);\n\t\tfloat a = float(i - 10) / PI;\n\t\tfloat len = 0.04 + (1. - t) * 0.2 * rand(fi, t2);\n\t\tvec2 p = pos + vec2(sin(a), cos(a)) * len;\n\t\tp += vec2(-0.13, -0.05);\n\t\tfloat intencity = pow(0.003 / length(p), 1.5);\n\t\tcolor += intencity * vec3(rand(fi, 1.), rand(fi, 2.), rand(fi, 3.));\n\t}\n\tfor(int i = 0; i < 20; i++)\n\t{\n\t\tfloat fi = float(i);\n\t\tfloat t  = pow(fract(iTime * 2.), 0.1);\n\t\tfloat t2 =     floor(iTime * 2.);\n\t\tfloat a = float(i - 10) / PI;\n\t\tfloat len = 0.04 + (1. - t) * 0.2 * rand(fi, t2);\n\t\tvec2 p = pos + vec2(sin(a), cos(a)) * len;\n\t\tp += vec2(0.13, -0.05);\n\t\tfloat intencity = pow(0.003 / length(p), 1.5);\n\t\tcolor += intencity * vec3(rand(fi, 1.), rand(fi, 2.), rand(fi, 3.));\n\t}\n\tcolor += vec3(fract(pos.y * 20. + iTime) < 0.5) * 0.05;\n\tcolor += vec3(fract(pos.y * 20. - iTime) < 0.5) * 0.05;\n\tfragColor = vec4(color, 1.0);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tlGRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 73, 73, 150], [152, 152, 209, 297, 2193]], "test": "valid"}
{"id": "7tlGz4", "name": "colorful Voronoi cell", "author": "yunhai", "description": "Voronoi pattern irregular cell generating", "tags": ["learn"], "likes": 1, "viewed": 53, "published": "Public", "date": "1621681783", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 random22(vec2 p)\n{\n    return vec2(fract(sin(27.*p.x+137.*p.y)*9492.),fract(sin(21.*p.x+131.*p.y)*8466.));\n}\nvoid mainImage( out vec4 O, in vec2 C )\n{\n    vec2 uv = (2.*C-iResolution.xy)/iResolution.y;\n    float t=iTime;\n    \n    vec2 cuv=uv*5.;\n    vec2 id=floor(cuv);\n    cuv=fract(cuv)-.5;\n    \n    float minDis=1e20;\n    vec2 minDisId;\n    //search for nearest pos in neighbor cell\n    for(float i=-1.0;i<1.1;i+=1.0)\n        for(float j=-1.0;j<1.1;j+=1.0)\n        {\n            vec2 nei=vec2(i,j);\n            vec2 speed=random22(nei+id);//global with id\n            vec2 p=nei+sin(speed*t)*.5;//relative pos\n            float len=length(p-cuv);\n            if(minDis>len)\n            {\n                minDis=len;\n                minDisId=nei+id;\n            }\n        }\n    O.b=minDis;\n                //O.b*=9.;//check move trail\n    O.rg=(minDisId+vec2(10.,10.))*.05;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tlGz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 113], [114, 114, 155, 155, 882]], "test": "valid"}
{"id": "7ts3Dr", "name": "line with animation", "author": "yuehongliang", "description": "I want to implement the ant-path line, but failed. I don't know how to split segment and flow it......\nwith oneshade's help, finally got it. ", "tags": ["lineantpath"], "likes": 4, "viewed": 81, "published": "Public", "date": "1621947195", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float ELIPSE=.005;\nconst float LINEWIDTH=0.01;\n\nfloat sdLine_t(in vec2 p,in vec2 a, in vec2 b){\n    vec2 pa=p-a,ba=b-a;\n    float t=dot(pa,ba)/dot(ba,ba);\n    float t_lxs=dot(pa,ba)/length(ba);\n\n    float c=length(pa-ba*clamp(t,0.0,1.0));\n    c=1.-smoothstep(LINEWIDTH,LINEWIDTH+ELIPSE,c);\n\n    return c*mod(t_lxs-iTime/10.,.1);\n}\n\nconst vec2 p0 = vec2( 0.6, 0.1);\nconst vec2 p1 = vec2( 0.4, 0.3);\nconst vec2 p2 = vec2(-0.2, 0.5);\nconst vec2 p3 = vec2(-0.6, 0.4);\nconst vec2 p4 = vec2(-0.8, 0.1);\nconst vec2 p5 = vec2(-0.7,-0.1);\nconst vec2 p6 = vec2( 0.0,-0.2);\nconst vec2 p7 = vec2( 0.7,-0.2);\n\nfloat cDistance_t( in vec2 v )\n{\n    float d0 = sdLine_t( v, p0, p1 );\n    float d1 = sdLine_t( v, p1, p2 );\n    float d2 = sdLine_t( v, p2, p3 );\n    float d3 = sdLine_t( v, p3, p4 );\n    float d4 = sdLine_t( v, p4, p5 );\n    float d5 = sdLine_t( v, p5, p6 );\n    float d6 = sdLine_t( v, p6, p7 );\n    float d7 = sdLine_t( v, p7, p0 );\n\n    float t=max(d0,max(d1,max(d2,max(d3,max(d4,max(d5,d6))))));\n    return t*8.;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    float m=min(iResolution.x,iResolution.y);\n    vec2 p=(-iResolution.xy+2.*fragCoord.xy)/m;\n\n    float c_lxs=cDistance_t(p);\n    fragColor=vec4(vec3(c_lxs),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ts3Dr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 54, 101, 101, 336], [603, 603, 635, 635, 1023], [1025, 1025, 1078, 1078, 1244]], "test": "valid"}
{"id": "7tX3R8", "name": "running circles", "author": "xxxbbbooo", "description": "shader学习记录", "tags": ["circle", "fluent"], "likes": 3, "viewed": 50, "published": "Public", "date": "1621502245", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 st = uv*10.;\n    \n    st.x *= iResolution.x/iResolution.y;\n\n    float pct = 0.0;\n    float x = step(mod(st.y, 2.), 1.);\n    float y = step(mod(st.x, 2.), 1.);\n    if (x == 1.) {\n       st.x = clamp(mod(iTime, 2.), 1., 2.) +st.x;  \n    } else {\n       st.x = clamp(mod(iTime, 2.), 1., 2.) -st.x;\n    }\n    \n    if (y == 1.) {\n       st.y = clamp(mod(iTime, 2.), 0., 1.) +st.y; \n    } else {\n       st.y = clamp(mod(iTime, 2.), 0., 1.) -st.y;\n    }\n    \n\tst = fract(st);\n    \n    pct = length(st-0.5);\n    pct = smoothstep(0.25, 0.3, pct);\n\n    vec3 color = vec3(pct);\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tX3R8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 788]], "test": "valid"}
{"id": "7tX3WN", "name": "colorful hexagonal tile wave", "author": "yunhai", "description": "my first try to generate hexagonal coordinate", "tags": ["learn"], "likes": 5, "viewed": 87, "published": "Public", "date": "1622093767", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SS(a,b,t) smoothstep(a,b,t)\nfloat hexDist(vec2 p)\n{\n    p=abs(p);\n    float d=dot(p,normalize(vec2(1.,1.732)));\n    d=max(d,p.x);//p.x=dot(p,normalize(vec2(1.,0.)));\n    return d;\n}\nvec4 hexCoord(vec2 uv)\n{\n    vec2 r=vec2(1.,1.732)*2.;\n    vec2 auv=mod(uv,r)-.5*r;\n    vec2 buv=mod(uv-.5*r,r)-.5*r;\n    vec2 guv=length(auv)<length(buv)?auv:buv;\n    \n    vec2 id=round(uv-guv);\n    vec2 polar=vec2(hexDist(guv),atan(-guv.y,-guv.x)/6.2832+.5);\n    vec4 coord=vec4(polar.x,polar.y,id.x,id.y);\n    return coord;    \n}\n#define DREMAP(type)\\\ntype remap(float a,float b,float x,float y,type t)\\\n{return (t-a)/(b-a)*(y-x)+x;}\\\ntype remapS(float x,float y,type t)\\\n{return remap(-1.,1.,x,y,t);}\n\nDREMAP(float)\nDREMAP(vec3)\n\nvoid mainImage( out vec4 O, in vec2 C )\n{\n    vec2 uv = (C-.5*iResolution.xy)/iResolution.y;\n    float t=iTime;\n    \n    vec4 guv=hexCoord((uv)*50.);\n    float mode=remapS(1.,9.,sin(t*.2));\n    float minSize=remapS(.3,.8,sin(t*.3));\n    O.rgb+=vec3(step(guv.x,remapS(minSize,.98,sin(t*2.+length(guv.zw)*mode))));\n    O.rgb*=(guv.zwz+36.*remapS(1.5,2.,sin(vec3(15.,14.,27.)*t*.1)))/90.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tX3WN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 36, 59, 59, 189], [190, 190, 214, 214, 522]], "test": "valid"}
{"id": "7tXGDH", "name": "stamina bar zelda", "author": "riperjack", "description": "pasek stamina typu zajebane z zelda", "tags": ["zelda", "piechart", "stamina"], "likes": 4, "viewed": 85, "published": "Public", "date": "1621978449", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// https://youtu.be/YU3DVDMUWTs?t=48\nfloat modulo(float a, float b) {\n    return (a)-(floor((a)/(b))*(b));\n}\nfloat random (float seed){\n    return fract(sin(dot(vec2(seed),vec2(12.9898,78.233)))*43758.5453123);\n}\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 bg = vec3(.8);\n    vec3 fg1 = vec3(.2);\n    vec3 fg2 = vec3(0.,.9,0.);\n    vec3 col = bg;\n    float PI = 3.1415;\n    float r1 = .17;\n    float r2 = .4;\n    float a1 = map(fract(iTime / 5.), 0., 1., -PI, PI);\n    float a2 = a1+.1;//a1 + sin(fract(iTime * 1.)) / 5.;\n    float a2col_transition = smoothstep(0., 1., fract(iTime * 2.));\n    vec3 a2col = vec3(1.,a2col_transition,a2col_transition);\n    float spin_dir = 1.;\n    if (modulo(iTime, 10.) >= 5.){\n        spin_dir = -1.;\n    }\n\n    if (atan(-uv.x, -uv.y) <= a1 * spin_dir && length(uv) < r2)\n        col = fg1;\n    else if ((atan(-uv.x, -uv.y) <= a2 * spin_dir && length(uv) < r2))\n        col = a2col;\n    else\n        col = fg2;\n\n    if (length(uv) < r1 || length(uv) >= r2)\n        col = bg;\n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tXGDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 37, 69, 69, 108], [109, 109, 135, 135, 212], [213, 213, 285, 285, 351], [353, 353, 410, 410, 1265]], "test": "valid"}
{"id": "7tXGRr", "name": "bank card encrypt", "author": "4eckme", "description": "encrypt bank card by circles (num, month/year, cvc)", "tags": ["2d", "buffer"], "likes": 2, "viewed": 170, "published": "Public", "date": "1621408093", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CARD SETTINGS AFTER 230 STRINGS\nvec4 jDate; const float M_PI = 3.14159265358979323846264338327950288;\nvec3 cardNum; vec3 cardInfo; float bank1; float bank2; float code;\n\n// day of week fuction\nfloat day() {\n    float jDatex=jDate.x;\n    float y366 = floor((jDatex-0.0)/400.0)+floor((jDatex-0.0)/4.0)-floor((jDatex-0.0)/100.0);\n    float y365 = jDatex-y366;\n    y366*=366.0; y365*=365.0;\n    float d=y366+y365;\n    if (jDate.y >= 0.0) d+=0.0;\n    if (jDate.y >= 1.0) d+=31.0;\n    if (jDate.y >= 2.0 && (int(mod(jDatex, 4.0))==0&&(int(mod(jDatex, 100.0))!=0||int(mod(jDatex, 400.0))==0))) d+=29.0;\n    if (jDate.y >= 2.0 && (int(mod(jDatex, 4.0))!=0||int(mod(jDatex, 100.0))==0&&int(mod(jDatex, 400.0))!=0)) d+=28.0;\n    if (jDate.y >= 3.0) d+=31.0;\n    if (jDate.y >= 4.0) d+=30.0;\n    if (jDate.y >= 5.0) d+=31.0;\n    if (jDate.y >= 6.0) d+=30.0;\n    if (jDate.y >= 7.0) d+=31.0;\n    if (jDate.y >= 8.0) d+=31.0;\n    if (jDate.y >= 9.0) d+=30.0;\n    if (jDate.y >= 10.0) d+=31.0;\n    if (jDate.y >= 11.0) d+=30.0;\n    return mod(d+jDate.z-2.0, 7.0)+1.0;\n}\n\n//scene function\nvec4 bg(vec2 fragCoord) {\n    vec2 coord = (fragCoord)*4.0;\n   \tfloat t = (iTime);\n    float x = float(coord.x)+64.0*sin((coord.x+coord.y)/60.0);\n    float y = float(coord.y)+64.0*cos((coord.x-coord.y)/60.0);\n    float r = float(x*x*t + y*y*t);\n    vec4 fragColor = vec4(\n        cos(sqrt(r)/x),\n        cos(sqrt(r)/sqrt(t)),\n        cos(sqrt(r)/y),\n        sin(y/x)\n    );\n    fragColor.x+=(tan((degrees(atan(x, y))*1.0-t*2.0)))/4.0;\n    fragColor.y+=(tan((degrees(atan(x, y))*1.0-t*2.0)))/4.0;\n    fragColor.z+=(tan((degrees(atan(x, y))*1.0-t*2.0)))/4.0;\n    return fragColor;\n}\n\n//clock function\nvec4 f(float x, float y, float t) {float N=iResolution.y/360.0;//clock zoom \n    //float jDatem = floor((13800000000.0-2021.0+jDate.x)/230000000.0);\n    jDate.x = bank2; jDate.y=cardInfo.x;//do a barrel roll after 1 million years of work \n    float jDatex = mod(jDate.x,10000.0);//4 last digits of year\n    float jDate1 = 0.0; float jDate2 = 0.0;// 4 digits year\n    if (jDate.x>99999.0) {//if year is 6 digits\n        jDate2 = floor(jDate.x/100000.0);\n        jDate1 = mod(jDate.x,100000.0)/10000.0;\n    }\n    else if (jDate.x>9999.0) {//if year is 5 digits\n        jDate2 = floor(jDate.x/100000.0);\n        jDate1 = floor(jDate.x/10000.0);\n    }\n    //jDate.x=123456.0;// 12422311\n    float angle=atan(-x, -y);\n    \n    \n    \n    /*\n    //galactic years controller\n    vec4 galacticTime = vec4(0.9, 0.2, 0.2, 1.0);\n    float a12=mod(jDatem, 5.0);float b12=floor(jDatem/5.0);\n    float a11=mod(b12, 5.0);float b11=floor(b12/5.0);\n    float a10=mod(b11, 5.0);float b10=floor(b11/5.0);\n    float a9=mod(b10, 5.0);float b9=floor(b10/5.0);\n    float a8=mod(b9, 5.0);float b8=floor(b9/5.0);\n    float a7=mod(b8, 5.0);float b7=floor(b8/5.0);\n    float a6=mod(b7, 5.0);float b6=floor(b7/5.0);\n    float a5=mod(b6, 5.0);float b5=floor(b6/5.0);\n    float a4=mod(b5, 5.0);float b4=floor(b5/5.0);\n    float a3=mod(b4, 5.0);float b3=floor(b4/5.0);\n    float a2=mod(b3, 5.0);float b2=floor(b3/5.0);\n    float a1=mod(b2, 5.0);float b1=floor(b2/5.0);\n    //if (int(a1)==0) return galacticTime;\n    \n    //12 red arcs to 12 digits of fivefold galactic years (max value 244140624 yaers)\n    if ((x*x+y*y)<=146.0*146.0*N&&(x*x+y*y)>143.0*143.0*N) {//140-146 radius\n      //if (degrees(angle)>-180.0&&degrees(angle)<=-180.0+6.0*(floor(jDate2)))\n       //   return galacticTime;\n       if (degrees(angle)>-180.0&&degrees(angle)<=-180.0+6.0*(a1))\n          return galacticTime;\n       if (degrees(angle)>-150.0&&degrees(angle)<=-150.0+6.0*(a2))\n          return galacticTime;\n       if (degrees(angle)>-120.0&&degrees(angle)<=-120.0+6.0*(a3))\n          return galacticTime;\n       if (degrees(angle)>-90.0&&degrees(angle)<=-90.0+6.0*(a4))\n          return galacticTime;\n      if (degrees(angle)>-60.0&&degrees(angle)<=-60.0+6.0*(a5))\n          return galacticTime;\n      if (degrees(angle)>-30.0&&degrees(angle)<=-30.0+6.0*(a6))\n          return galacticTime;\n      if (degrees(angle)>0.0&&degrees(angle)<=6.0*(a7))\n          return galacticTime;\n      if (degrees(angle)>30.0&&degrees(angle)<=30.0+6.0*(a8))\n          return galacticTime;\n      if (degrees(angle)>60.0&&degrees(angle)<=60.0+6.0*(a9))\n          return galacticTime;\n      if (degrees(angle)>90.0&&degrees(angle)<=90.0+6.0*(a10))\n         return galacticTime;\n      if (degrees(angle)>120.0&&degrees(angle)<=(120.0+6.0*(a11)))\n          return galacticTime;\n      if (degrees(angle)>150.0&&degrees(angle)<=(150.0+6.0*(a12)))\n          return galacticTime;\n    } */   \n    //float dangle = degrees()\n    \n    /* Operator \"||\" to set cureent date and day of week when angle arrive +/-180deg. bug fixed by 18.05.2021 */\n    \n    \n    vec4 res = vec4(1.0, 1.0, 1.0, 1.0);//clock color\n    \n    \n    \n                \n                \n                \n    vec4 years = vec4(0.2, 0.2, 0.2, 1.0);//years controller\n    if ((x*x+y*y)<=146.0*146.0*N&&(x*x+y*y)>140.0*140.0*N) {//140-146 radius\n      if (degrees(angle)>-180.0&&degrees(angle)<=-180.0+6.0*(floor(jDate2)))\n          return years;//100000\n      if (degrees(angle)>-120.0&&degrees(angle)<=-120.0+6.0*(floor(jDate1)))\n          return years;//10000\n      if (degrees(angle)>-60.0&&degrees(angle)<=-60.0+6.0*(floor(jDatex/1000.0)))\n          return years;//millenium of year\n      if (degrees(angle)>0.0&&(degrees((angle)))<=6.0*(floor(mod(jDatex, 1000.0)/100.0)))\n          return years;//century of year\n      if (degrees(angle)>60.0&&degrees(angle)<=60.0+6.0*(floor(mod(jDatex,100.0)/10.0)))\n         return years;//dacade of year\n      if (degrees(angle)>120.0&&degrees(angle)<=(120.0+6.0*(floor(mod(jDatex,10.0)))))\n          return years;//last num of year\n    }\n    \n    float c1; float c2; float c3;\n    if (code>=100.0) {\n     c1=floor(code/100.0);\n     c2=floor(mod(code,100.0)/11.0);\n     c3=mod(code,10.0);\n    } else if (code>=10.0) {\n     c1=0.0;\n     c2=floor(code/10.0);\n     c3=mod(code,10.0);\n    }\n    else if (code>=0.0) {\n     c1=0.0;\n     c2=0.0;\n     c3=code;\n    }\n    \n    float d1; float d2;\n    if (cardInfo.y>=10.0) {\n        d1=floor(cardInfo.y/10.0);\n        d2=mod(cardInfo.y,10.0);\n    } else {\n        d2=0.0;\n        d1=cardInfo.y;\n    }\n    \n    float d1mod=mod(d1,5.0)*6.0;\n    float d2mod=mod(d2,5.0)*6.0;\n    float c1mod=mod(c1,5.0)*6.0;\n    float c2mod=mod(c2,5.0)*6.0;\n    float c3mod=mod(c3,5.0)*6.0;\n    d1mod = d1>5.0?d1mod:0.0;\n    d2mod = d2>5.0?d2mod:0.0;\n    float dangle; // month/date + cvc\n    if (cardInfo.x<=5.0)dangle=degrees(atan(x,y))-cardInfo.x*30.0-30.0;\n    else dangle=degrees(atan(x,y))+30.0*(11.0-cardInfo.x);\n    if ((x*x+y*y)<146.0*146.0*N&&(x*x+y*y)>=135.0*135.0*N) {//135-146 radius\n        if (cardInfo.x>=6.0) {\n          if(dangle>330.0-c1mod&&dangle>300.0||dangle>300.0-c2*6.0&&dangle<300.0||dangle>240.0-c3*6.0&&dangle<240.0) return vec4(1.0,0.7,0.1,1.0);\n        }\n        if (dangle<0.0&&dangle>-c1*6.0) return vec4(1.0,0.7,0.1,1.0);\n        if (dangle<-60.0&&dangle>-60.0-c2*6.0) return vec4(1.0,0.7,0.1,1.0);\n        if (dangle<-120.0&&dangle>-120.0-c3*6.0) return vec4(1.0,0.7,0.1,1.0);\n        if (cardInfo.x<=2.0&&(dangle<d1*6.0&&dangle>0.0||dangle<60.0+d2*6.0&&dangle>60.0||dangle<-270.0+d2mod))return vec4(0.25,0.75,0.25,1.0);\n        else if (cardInfo.x>2.0&&cardInfo.x<4.0&&(dangle>0.0||dangle>-360.0&&dangle<-330.0+d1mod)&&dangle<d1*6.0)return vec4(0.25,0.75,0.25,1.0);\n        else if (cardInfo.x>2.0&&cardInfo.x<4.0&&(dangle<60.0+d1*6.0&&dangle>60.0||cardInfo.x>=2.0&&dangle<-270.0+d2mod)&&cardInfo.x<4.0) return vec4(0.25,0.75,0.25,1.0);\n        else if (cardInfo.x>=4.0&&cardInfo.x<6.0&&(dangle<-300.0+d2*6.0&&dangle>-300.0||(dangle<-330.0+d1mod)||(d1>5.0?(dangle>30.0-d1*6.0):false))) return vec4(0.25,0.75,0.25,1.0);\n        else if (cardInfo.x>=4.0&&cardInfo.x<6.0&&(dangle>0.0&&dangle<d1*6.0||dangle>60.0&&dangle<60.0+d2*6.0)) return vec4(0.25,0.75,0.25,1.0);\n        else if (cardInfo.x>=6.0&&(dangle>60.0-d1*6.0-6.0&&dangle<60.0-6.0||dangle>120.0-d1*6.0-6.0&&dangle<120.0-6.0)) return vec4(0.25,0.75,0.25,1.0);\n        \n    }\n    \n    /*fix if (dangle>(jDate.y+1.0)*30.0-180.0-c1*6.0&&dangle<-180.0+(jDate.y+1.0)*30.0||(jDate.y+1.0)==1.0&&dangle>180.0-(jDate.y+1.0)*30.0&&dangle>180.0+(c1-9.0)*6.0)\n                return vec4(1.0,0.7,0.1,1.0);\n            else if (dangle>(jDate.y+1.0)*30.0-240.0-c2*6.0&&dangle<-240.0+(jDate.y+1.0)*30.0||(jDate.y+1.0)==3.0&&dangle>60.0-(jDate.y+1.0)*30.0&&dangle>210.0||(jDate.y+1.0)==2.0&&dangle>180.0-(c2)*6.0||dangle<150.0&&(jDate.y+1.0)==1.0&&dangle>150.0-(c2)*6.0)\n                return vec4(1.0,0.7,0.1,1.0);\n            else if (int(jDate.y+1.0)==6||(jDate.y+1.0)==5.0||jDate+1.0==4.0||dangle>30.0-(jDate.y+1.0)*30.0+(c3+1.0)*6.0&&dangle<(jDate.y+1.0)*30.0-240.0&&(jDate.y+1.0)*30.0-300.0>dangle||(jDate.y+1.0)==4.0&&dangle>-(jDate.y+1.0)*30.0-c3*6.0+300.0||dangle<90.0&&(jDate.y+1.0)==1.0&&dangle>90.0-(c3)*6.0||dangle<150.0&&(jDate.y+1.0)==3.0&&dangle>90.0+(10.0-c3)*6.0||dangle<120.0&&(jDate.y+1.0)==2.0&&dangle>60.0+(10.0-c3)*6.0)\n            {\n            if (jDate.y+1.0==2.0&&dangle>-300.0-(jDate.y+1.0)*30.0-c3*6.0) return vec4(1.0,0.7,0.1,1.0);\n              \n            if (jDate.y+1.0==2.0&&dangle>-240.0-(jDate.y+1.0)*30.0-c3*6.0) return vec4(1.0,0.7,0.1,1.0);\n                \n            if (jDate.y+1.0==3.0&&dangle<150.0&&dangle>150.0-c3*6.0) return vec4(1.0,0.7,0.1,1.0);\n                \n            if (jDate.y+1.0==4.0&&gangle>180.0-6.0*c3) return vec4(1.0,0.7,0.1,1.0);\n                \n            if (jDate.y+1.0==5.0&&dangle<0.0+18.0-(jDate.y+1.0)*30.0-5.0*6.0&&dangle>-150.0-5.0*6.0) return vec4(1.0,0.7,0.1,1.0);\n                \n            if (jDate.y+1.0==6.0&&dangle>60.0-(jDate.y+1.0)*30.0-c3*6.0&&dangle<-120.0) return vec4(1.0,0.7,0.1,1.0);\n                \n            if (jDate.y+1.0==7.0&&dangle>120.0-(jDate.y+1.0)*30.0-c3*6.0) return vec4(1.0,0.7,0.1,1.0);\n                \n            if (jDate.y+1.0==8.0&&dangle>180.0-(jDate.y+1.0)*30.0-c3*6.0) return vec4(1.0,0.7,0.1,1.0);\n                \n                    if (jDate.y+1.0==9.0&&dangle>240.0-(jDate.y+1.0)*30.0-c3*6.0) return vec4(1.0,0.7,0.1,1.0);\n                if (jDate.y+1.0==10.0&&dangle>300.0-(jDate.y+1.0)*30.0-c3*6.0) return vec4(1.0,0.7,0.1,1.0);\n                if (jDate.y+1.0==11.0&&dangle>360.0-(jDate.y+1.0)*30.0-c3*6.0) return vec4(1.0,0.7,0.1,1.0);\n               if (jDate.y+1.0==12.0&&dangle>420.0-(jDate.y+1.0)*30.0-c3*6.0) return vec4(1.0,0.7,0.1,1.0);\n              \n                 }*/\n                /*\n                //else return vec4(1.0,1.0,1.0,1.0);\n            //else if (dangle>390.0-60.0+(jDate.y+1.0)*30.0-c1*6.0&&dangle<390.0-60.0+(jDate.y+1.0)*30.0||dangle>750.0-180.0-60.0+(jDate.y+1.0)*60.0&&dangle>750.0-60.0+(jDate.y+1.0)*30.0-c1*6.0)\n              //  return vec4(1.0,0.7,0.1,1.0);\n           //else if (dangle>390.0-120.0+(jDate.y+1.0)*30.0-c1*6.0&&dangle<390.0-120.0+(jDate.y+1.0)*60.0||dangle>750.0-180.0-120.0+(jDate.y+1.0)*30.0&&dangle>750.0-120.0+(jDate.y+1.0)*30.0-c1*6.0)\n            //    return vec4(1.0,0.7,0.1,1.0);\n            //else if(dangle>((iDate.y+1.0)*30.0)+(10.0-c3)*6.0||dangle<-60.0-240.0+((iDate.y+1.0)*30.0)&&dangle>-60.0-240.0+((iDate.y+1.0)*30.0)-c3*6.0)\n            //    return vec4(1.0,0.7,0.1,1.0);\n    float d1=floor(cardInfo.y/10.0);\n    float d2=mod(cardInfo.y,10.0);\n    if ((x*x+y*y)<146.0*146.0*N&&(x*x+y*y)>=135.0*135.0*N) {//135-146 radius\n    /*fix*/ \n            /*\n            if (180.0+degrees(angle)>30.0*(jDate.y+1.0)&&180.0+degrees(angle)<30.0*(jDate.y+1.0)+6.0*d1||30.0*(jDate.y+1.0)+6.0*d1>360.0+180.0+degrees(angle))\n                return vec4(0.25,0.75,0.25,1.0);//date green color (month, day)\n            \n            if (jDate.y+1.0==11.0&&degrees(angle)>-180.0+6.0*d2&&degrees(angle)<-90.0-6.0*(10.0-d2)||degrees(angle)+30.0*(jDate.y+1.0)-360.0>-120.0&&(120.0+degrees(angle)>30.0*(jDate.y+1.0)&&120.0+degrees(angle)<30.0*(jDate.y+1.0)+6.0*d2||30.0*(jDate.y+1.0)+6.0*d2>360.0+120.0+degrees(angle)))\n                return vec4(0.25,0.75,0.25,1.0);//date green color (month, day)\n            if (jDate.y+1.0==10.0&&degrees(angle)<6.0*d2-180.0)\n                return vec4(0.25,0.75,0.25,1.0);//date green color (month, day)\n            \n     }       \n    */\n    //float jDatem = floor((13800000000.0-2021.0+jDate.x)/1000000.0);\n    jDate.x = bank1;//do a barrel roll after 1 million years of work \n    jDatex = mod(jDate.x,10000.0);//4 last digits of year\n    jDate1 = 0.0; jDate2 = 0.0;// 4 digits year\n    if (jDate.x>99999.0) {//if year is 6 digits\n        jDate2 = floor(jDate.x/100000.0);\n        jDate1 = mod(jDate.x,100000.0)/10000.0;\n    }\n    else if (jDate.x>9999.0) {//if year is 5 digits\n        jDate2 = floor(jDate.x/100000.0);\n        jDate1 = floor(jDate.x/10000.0);\n    }\n    vec4 galacticTime = vec4(0.9, 0.2, 0.2, 1.0);\n    if ((x*x+y*y)>=147.0*147.0*N&&(x*x+y*y)<=149.0*149.0*N) {//140-146 radius\n      if (degrees(angle)>-180.0&&degrees(angle)<=-180.0+6.0*(floor(jDate2)))\n          return galacticTime;//100000\n      if (degrees(angle)>-120.0&&degrees(angle)<=-120.0+6.0*(floor(jDate1)))\n          return galacticTime;//10000\n      if (degrees(angle)>-60.0&&degrees(angle)<=-60.0+6.0*(floor(jDatex/1000.0)))\n          return galacticTime;//millenium of year\n      if (degrees(angle)>0.0&&(degrees((angle)))<=6.0*(floor(mod(jDatex, 1000.0)/100.0)))\n          return galacticTime;//century of year\n      if (degrees(angle)>60.0&&degrees(angle)<=60.0+6.0*(floor(mod(jDatex,100.0)/10.0)))\n         return galacticTime;//dacade of year\n      if (degrees(angle)>120.0&&degrees(angle)<=(120.0+6.0*(floor(mod(jDatex,10.0)))))\n          return galacticTime;//last num of year\n    }\n    if ((x*x+y*y)<=150.0*150.0*N&&(x*x+y*y)>=146.0*146.0*N)//light shadow\n        return vec4(0.92,0.92,0.92,1.0);//shadow\n    \n    \n    \n    if (x*x+y*y<=20.0*20.0*N)//10 radius\n        return vec4(1.0,1.0,1.0, 1.0);\n    if ((x*x+y*y)<=90.0*90.0*N)//90 radius\n      if (int(ceil(60.0*angle/2.0/M_PI))==-int(floor(30.0-mod(((t+0.001)/60.0/12.0),60.0))))\n        return vec4(0.0,0.0,0.0,1.0); //hours arrow color\n    if ((x*x+y*y)<=110.0*110.0*N)//115 radius\n      if (int(ceil(60.0*angle/2.0/M_PI))==-int(floor(30.0-mod(((t+0.001)/60.0), 60.0))))\n        return vec4(0.0,0.8,0.8,1.0);//minutes arrow color\n    if ((x*x+y*y)<=130.0*130.0*N)//140 radius\n      if (int((ceil(60.0*angle/2.0/M_PI)))==-int(floor(30.0-mod(((t+0.001)),60.0))))\n        return vec4(1.0,0.0,0.6,1.0);//seconds arrow color\n    if ((x*x+y*y)<=150.0*150.0*N)//150 radius\n        return res;//clock color\n    if ((x*x+y*y)<=170.0*170.0*N) {//170 radius\n        float dt = 0.0; float jDatew = iTime;\n        if(mod(floor(jDatew/3600.0), 24.0)>=12.0) dt=1.0;// dt sets PM/AM\n        res.x=float(int(mod(floor(60.0*radians((degrees(angle))-mod(floor(jDatew/3600.0)+dt, 24.0)*30.0)/2.0/M_PI),2.0)));\n        res.y=float(int(mod(floor(60.0*radians((degrees(angle))-mod(floor(jDatew/3600.0)+dt, 24.0)*30.0)/2.0/M_PI/5.0),2.0)));\n        res.z=(res.x+res.y)/abs(2.0-mod(jDatew, 4.0));//clock segmentation animate by t(time)\n        return abs(res);//color for clock segmentation\n    }\n    else {\n        res = (vec4(0.0,0.2,0.2,1.0)*sin((y-535.0)/340.0)*sin((x-1070.0)/680.0));//old background\n        if(abs(y)<10000.0)res = bg(vec2(x,y))/1.0;//new scene\n        return res;\n    }\n}\n\n\n// START\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {float N=iResolution.y/360.0;\n    \n    // set card\n    cardNum = vec3(123456.0, 789012.0, 3456.0);\n    cardInfo = vec3(2.0,27.0,123.0);\n    \n    bank1=cardNum.x;\n    bank2=cardNum.y;\n    jDate.y=cardInfo.x;\n    jDate.z=cardInfo.y;\n    jDate.w=cardNum.z;\n    code=cardInfo.z;\n    \n    vec2 coord = fragCoord - (iResolution.xy / vec2(2.0));//simmetric\n    float dx = iMouse.x-iResolution.x/2.0;//mouse move x\n    float dy = iMouse.y-iResolution.y/2.0;//mouse move y\n    if(dx!=-iResolution.x/2.0||dy!=-iResolution.y/2.0)\n    { coord.x+=dx; coord.y+=dy; }//move graphics x, y\n    fragColor= f(coord.x,coord.y,jDate.w); //go\n    if (coord.x*coord.x+coord.y*coord.y>170.0*170.0*N){//shadow\n        if (coord.x*coord.x+coord.y*coord.y<180.0*180.0*N)//shadow\n            fragColor/=8.0;//shadow\n     }\n    if (coord.x*coord.x+coord.y*coord.y<=146.0*146.0*N&&fragColor.w!=0.5)//arrows texture animate\n        fragColor+=abs(tan(abs(degrees(atan(coord.x, coord.y))*4.0-jDate.w*2.0)))/16.0;\n}", "image_inputs": [{"id": "4dXGR8", "previewfilepath": "/media/previz/buffer00.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/previz/buffer00.png", "ctype": "buffer"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tXGRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1059, 1076, 1101, 1101, 1656], [1658, 1675, 1710, 1710, 15344], [15347, 15356, 15413, 15413, 16394]], "test": "valid"}
{"id": "fd2SDd", "name": "BW Fractal", "author": "Shellderr", "description": "simple kaleidoscopic fractal", "tags": ["fractal"], "likes": 2, "viewed": 52, "published": "Public", "date": "1621313131", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    float a = 1.;\n    vec2 m = iMouse.y <1. ? vec2(.44) : iMouse.xy/iResolution.xy;\n    float s = abs(fract(iTime*.1)-.5)*16.;\n    for(float i; i < 8.; i++){\n        uv -= m*.2*i;\n        uv = abs(uv/a);\n        a *= dot(uv-m*s,uv);\n    }\n\n    fragColor = vec4(cos(.25*(3.+iTime+vec3(1./a)+vec3(1.,4.,7.)*1.5))*.5+.5,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd2SDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 441]], "test": "valid"}
{"id": "fd2SDt", "name": "Blaaargghhh", "author": "BrandonV", "description": "The more you look at it the worse it gets.", "tags": ["oo"], "likes": 1, "viewed": 38, "published": "Public", "date": "1621292061", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define BALLS 20.\n#define CONTRAST 1\n#define GLOW .1\n#define ORB_SIZE 0.492519\n#define PI 3.14159265359\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 xy = 2. * fragCoord / iResolution.xy - 1.0; \n    xy.x *= iResolution.x / iResolution.y;\n    vec3 color = vec3(0.0);\n    float d = 0.0;\n    \n    xy *= 0.9; \n    d = length(abs(xy)-.3 ); //Distance field that creates the four circles\n\n\n//Modified Color Warp Section by yozic: https://www.shadertoy.com/view/wl2yRD\n  for (float i = 0.; i < BALLS; i++) {\n    float t = iTime/20.5- i * PI / BALLS * cos(iTime / i);\n    vec2 p = vec2(cos(t), sin(t)) / sin(i / BALLS + PI / d * iTime);\n    vec3 c = cos(vec3(9, -3, 20) * PI * 2. / PI + PI * (iTime / (i+1.) / 5.)) * (GLOW) + (GLOW);\n    fragColor += (vec4(vec3(fract(d * .3 / length(xy - p * ORB_SIZE)) * c), 1.0) ); \n    \n  }\n   fragColor.xyz = pow(fragColor.xyz, vec3(CONTRAST));\n\n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd2SDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 163, 163, 905]], "test": "valid"}
{"id": "fd2XDG", "name": "Fake 3D Planets", "author": "Hexdigest", "description": "I don't know how to retain the original colors and do proper layering yet.", "tags": ["3d", "fake", "planets"], "likes": 1, "viewed": 33, "published": "Public", "date": "1620927502", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - iResolution.xy*.5)/iResolution.y;\n    \n    float u = smoothstep(.2-cos(iTime)/10., .21-cos(iTime)/10., length(vec2(uv.x + sin(iTime)/1.5, uv.y)));\n    float u2 = smoothstep(.15-cos(iTime)/10., .16-cos(iTime)/10., length(vec2(uv.x + sin(iTime)/3.5, uv.y + sin(iTime)/ 5.)));\n       \n    vec3 order_flip = vec3(0);\n    \n    if (cos(iTime)/10. >= .0) {\n        u2 *= u += .5;\n    }\n    else {\n        u *= u2 += .5;\n    }\n    order_flip += u * u2;\n    fragColor = vec4(order_flip, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd2XDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 573]], "test": "valid"}
{"id": "fd2XDz", "name": "Waves of ball sea", "author": "seven_dc", "description": "Raymarching rolling wave with metabalzz", "tags": ["waves", "raymarch"], "likes": 0, "viewed": 57, "published": "Public", "date": "1620044805", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 40\n#define MAX_DIST 50.\n#define SURF_DIST .01\n#define CLOSE_SURF_DIST .1\n\nfloat smin( float a, float b, float k ) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat GetDistance(vec3 point) {\n\t\n    float texture = sin((iTime + point.x)*.2)*2.4+\n        sin((iTime + point.x)*.25)*1.1+\n        sin(point.z*2.5+sin(iTime)*.1)*.15+\n        sin(point.x*5.+point.z*.015)*.41;\n    \n    float planeDist = point.y + texture*.5;\n    \n    vec4 sphere = vec4(1., 1., 1.5, 0.5);\n    vec3 spoint = vec3(mod(point.x, 2.), point.y, mod(point.z, 3.));\n    float sphereDist =  length(spoint-sphere.xyz)-sphere.w-sin(point.x+point.z+iTime)*.1;\n    \n    return smin(planeDist, sphereDist, .9);\n}\n\n\nvec3 GetNormal(vec3 point) {\n  float distance = GetDistance(point);\n  vec2 e = vec2(.01,0);\n  \n  vec3 normal = distance - vec3(\n      GetDistance(point-e.xyy),\n      GetDistance(point-e.yxy),\n      GetDistance(point-e.yyx));\n  \n  return normalize(normal);\n}\n\nvec2 RayMarch(vec3 rayOrgin, vec3 rayDirection) {\n\tfloat distance=0.;\n    \n    int steps = MAX_STEPS; \n    int c = 0; // close of surface\n    \n    for(int i=0; i<steps; i++) {\n    \tvec3 point = rayOrgin + rayDirection * distance;\n        float surfaceDistance = GetDistance(point);\n        distance += surfaceDistance;\n        \n        if (distance<CLOSE_SURF_DIST) c++;\n        // Stop marching if we go too far or we are close enough of surface\n        if(distance>MAX_DIST || surfaceDistance<SURF_DIST) break;\n    }\n    \n    return vec2(distance,c);\n}\n\nfloat GetLight(vec3 point, vec3 normal, vec3 lightPos) {    \n  \n  vec3 direction = normalize(lightPos-point);\n  \n  float dif = clamp(dot(normal, direction), 0., 1.);\n  \n  vec2 d = RayMarch(point+normal*.1, direction);\n  if ( d.x < length(lightPos-point)) {\n      dif *= .5;\n  } else {\n      dif -= d.y*.01;\n  }\n  \n  return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // put 0,0 in the center\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n       \n    // camera   \n    vec3 rayOrgin = vec3(0.-sin(iTime*.1), 3.5, 0);\n    vec3 rayDirection = normalize(vec3(uv.x-sin(iTime*.1), uv.y-0.45, 1));\n\n    vec2 d = RayMarch(rayOrgin, rayDirection);\n    \n    vec3 col = vec3(0.);\n    \n    vec3 lightPos = vec3(1.-sin(iTime*.1), 5.5, 1);\n    \n    if (d.x < 120.) {\n        vec3 p = rayOrgin + rayDirection * d.x;\n        vec3 n = GetNormal(p);\n        float light = GetLight(p, n, lightPos);\n        // color\n        float dist = d.x/36.;\n        col = vec3(\n            light*0.9-dist,\n            light*0.9-dist/1.5+(d.y*20.04),\n            light-dist/2.5+(d.y*20.8)\n        );\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd2XDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[92, 92, 133, 133, 220], [222, 222, 253, 253, 738], [741, 741, 769, 769, 998], [1000, 1000, 1049, 1049, 1554], [1556, 1556, 1612, 1612, 1885], [1887, 1887, 1944, 1973, 2700]], "test": "valid"}
{"id": "fd2XR1", "name": "Try1", "author": "Chidebe", "description": "This is my first try on ShaderToy with an account.", "tags": ["firsttrywithanaccount"], "likes": 0, "viewed": 116, "published": "Public API", "date": "1619981595", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = vec3(0, 0, 0);\n    //col.x = 0.5 + 0.5*sin(iTime+uv.xyx+vec3(0,2,4));\n    col.x = mix(0.0f, cos(iTime * 1.0f), 1.0f);\n    col.y = mix(0.0f, sin(iTime * 1.0f), 0.5f);\n    col.y = mix(0.0f, sin(iTime * 1.0f), 0.7f);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0f);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd2XR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 437]], "test": "valid"}
{"id": "fd2XRK", "name": "duality2 for twitch.tv/sableraph", "author": "morisil", "description": "duality for:\n\nhttps://www.twitch.tv/sableraph", "tags": ["spiral", "signeddistance", "ornament"], "likes": 16, "viewed": 261, "published": "Public API", "date": "1620580788", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"duality for twitch.tv/sableraph\" by morisil. https://shadertoy.com/view/7dBXzV\n// 2021-05-09 17:16:25\n\n// the same shader, just at bit different parameters for more color spread\n\n// check out https://www.twitch.tv/sableraph\n// sableraph is posting creative coding chanllange every week and then review\n// sketches on the stream every Sunday. This time the topic was \"duality\"\n\n// Some comments:\n\n// I like that using trigonometric shapes is reducing the need of antialiasing whatsover\n\n// I started with grayscale, but then decided to apply distance based and angular\n// based chromatic abberration, which gives more video synthesis-like aesthetics\n// Maybe my childhood CRT experience makes me love vaporwave aesthetics so much :)\n\n\n#define SCALE                  140.0\n#define ROTATION_SPEED         -1.\n#define DISTANCE_SPREAD        -.01\n#define ANGLE_SPREAD           .5\n#define SHAPE_RANGE            1.6\n#define OSCILLATION_SPEED      .15\n#define OSCILLATION_AMPLITUDE  .2\n#define MIRROR_TRUE            1.\n#define MIRROR_FALSE           -1.\n\n\nfloat getColorComponent(float dist, float angle, float mirror) {\n    return clamp(\n        sin(\n            (dist * SCALE)\n                + angle * mirror\n                + (cos(dist * SCALE))\n                - (iTime * ROTATION_SPEED) * mirror\n        )\n        - dist * SHAPE_RANGE\n        ,-0.05 // try putting small negative value here, like -.2 :)\n        ,1.\n    );\n}\n\nvec3 getSwirl(vec2 center, float dist, float mirror) {\n    float angle = atan(center.x, center.y);\n    return vec3(\n        getColorComponent(dist * (1. - DISTANCE_SPREAD), angle - ANGLE_SPREAD, mirror),\n        getColorComponent(dist * (1. + 0.)             , angle - 0.          , mirror),\n        getColorComponent(dist * (1. + DISTANCE_SPREAD), angle + ANGLE_SPREAD, mirror)\n    );    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord -.5 * iResolution.xy) / iResolution.y;\n    vec2 oscillation = vec2(\n        sin(iTime * OSCILLATION_SPEED),\n        0.\n    ) * OSCILLATION_AMPLITUDE;\n    vec2 uv1 = uv + oscillation;\n    vec2 uv2 = uv - oscillation;\n    float dist1 = length(uv1);\n    float dist2 = length(uv2);\n    vec3 color =\n        getSwirl(uv1, dist1, MIRROR_TRUE)\n        + getSwirl(uv2, dist2, MIRROR_FALSE);\n    fragColor = vec4(color, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd2XRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1063, 1063, 1127, 1127, 1437], [1439, 1439, 1493, 1493, 1830], [1832, 1832, 1887, 1887, 2330]], "test": "valid"}
{"id": "fd2XRW", "name": "learn(11)", "author": "saltlemon", "description": "learn from https://www.youtube.com/channel/UCcAlTqd9zID6aNX3TzwxJXg The Art of Code", "tags": ["2d"], "likes": 4, "viewed": 60, "published": "Public", "date": "1620298047", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//float n21(vec2 p){\n//    return fract(sin(p.x*100.+p.y*168.)*2368.);\n//}\nfloat xor(float a,float b){\n    return a*(1.-b)+b*(1.-a);\n}\nmat2 rot(float a){\n    float s=sin(a);\n    float c=cos(a);\n    return mat2(c,-s,s,c);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    //uv-=.5;\n    //uv.x*=iResolution.x/iResolution.y;\n    \n    uv*=rot(fract(iTime/20.)*3.14159*2.);\n    uv*=15.;\n    vec2 duv=fract(uv)-.5;\n    vec2 id=floor(uv);\n    float t=iTime*2.;\n    \n    float m=0.;\n    for(int x=-1;x<=1;x++)\n        for(int y=-1;y<=1;y++)\n        {\n            vec2 offset=vec2(x,y);\n            float d=length(duv-offset);\n            float randnum=length(id+offset)*.3;\n            float r=mix(.3,1.5,.5*sin(randnum-t)+.5);\n            m=xor(smoothstep(r,r*.9,d),m);\n        }\n    // Time varying pixel color\n    vec3 col =vec3(0.);\n    \n    //col.rg=duv;\n    col+=m;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd2XRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 75, 102, 102, 134], [135, 135, 153, 153, 222], [223, 223, 280, 330, 1043]], "test": "valid"}
{"id": "fd2XW1", "name": "getErraticWave", "author": "TestCoder", "description": "https://www.desmos.com/calculator/u5zfwind97?lang=es", "tags": ["wave", "time", "pattern"], "likes": 3, "viewed": 137, "published": "Public API", "date": "1620401405", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float cbrt(float number) {\n    return pow(abs(number), 1. / 3.);\n}\n\nfloat getErraticWave(float number) {\n    float scale = 1.;\n\n    return (\n        cbrt(sin(number))\n      + pow(\n          sin(\n              number + iTime / 3.\n          ),\n          3.\n        )\n    ) / scale;\n}\n\nvec3 getErraticPattern(float x, float y, vec2 uv) {\n    float stretch = 2.;\n    float mainDance = getErraticWave(\n        getErraticWave(uv.y + uv.x)\n      + getErraticWave(uv.y + -uv.x)\n      + getErraticWave(-uv.y + uv.x)\n      + getErraticWave(-uv.y + -uv.x)\n    );\n\n    return (\n        getErraticWave(\n            x\n        ) + getErraticWave(\n            y\n        )\n    ) * stretch * (1. - vec3(\n        mainDance * (\n            sin(\n                iTime / 20. + .5\n            ) + 1.\n        )\n    ,\n        mainDance * (\n            sin(\n                iTime / 4. + .25\n            ) + .5\n        )\n    ,\n        mainDance * (\n            sin(\n                iTime / 4. + 1.\n            ) + .25\n        ) + mainDance\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from -.5 to .5)\n    vec2 uv = fragCoord/iResolution.xy-.5;\n\n    uv.x *= iResolution.x/iResolution.y;\n\n    float zoomOut = 10.;\n\n    vec3 rgb = getErraticPattern(\n                uv.x, uv.y, uv * zoomOut\n            ) + getErraticPattern(\n                -uv.x, uv.y, uv * zoomOut\n            ) + getErraticPattern(\n                uv.x, -uv.y, uv * zoomOut\n            ) + getErraticPattern(\n                -uv.x, -uv.y, uv * zoomOut\n            );\n\n    // Output to screen\n    fragColor = vec4(1. - rgb, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd2XW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 66], [68, 68, 104, 104, 281], [283, 283, 334, 334, 1022], [1024, 1024, 1081, 1134, 1631]], "test": "valid"}
{"id": "fdBXRK", "name": "Rey sentado", "author": "jorge2017a1", "description": "Rey sentado", "tags": ["2d", "draw", "reysentado", "pintura", "dibujo"], "likes": 4, "viewed": 131, "published": "Public API", "date": "1620527184", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//por jorge2017a1 ----jorgeFloresP---8/may/2021\n// referencia \n////-------------------\n/// IQ funciones....librerias\n//https://www.shadertoy.com/view/tlGBW3\n//Created by manu210404 in 2021-03-13\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r; }\n\nvec3 ponerBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S(abs( distObj),0.0));\n  return colOut;\n}\n\nfloat opU(float d1, float d2) {return min(d1, d2); }\nconst vec3 colNegro=vec3(0.0);\nconst vec3 colGris=vec3(0.49,0.49,0.49);\nconst vec3 colGris2=vec3(0.6);\nconst vec3 colBlanco=vec3(1.0);\nconst vec3 colRojo=vec3(1.0,0.0,0.0);\nconst vec3 colAzul=vec3(0.0,0.0,1.0);\nconst vec3 colVerde=vec3(0.0,1.0,0.0);\n\nconst vec3 col1=vec3(0.54,0.49,0.39);\nconst vec3 col2=vec3(0.06,0.07,1.0);\nconst vec3 col3=vec3(0.06,0.07,0.8);\n//const vec3 col4=vec3(0.45,0.13,0.15); //rojo obscuro\nconst vec3 col4=vec3(0.60,0.17,0.17); //vestido\nconst vec3 col5=vec3(0.73,0.60,0.55);\nconst vec3 colDorado=vec3(0.925,0.67,0.0);\n\n#define POLY(N) (in vec2 p, in vec2[N] v) {const int n=v.length();float d=dot(p-v[0],p-v[0]);float s=1.;for(int i=0,j=n-1;i<n;j=i,i++){vec2 e=v[j]-v[i];vec2 w=p-v[i];vec2 b=w-e*clamp(dot(w,e)/dot(e,e),0.,1.);d=min(d,dot(b,b));bvec3 cond=bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);if(all(cond)||all(not(cond))) s=-s;}return s*sqrt(d);}\n\nfloat sdPoly25 POLY(25)\nvec2 pt25[ 25]=vec2[](  \nvec2(.08,.01),vec2(.07,.50),vec2(.08,.58),vec2(.09,.65),vec2(.10,.67),\nvec2(.12,.67),vec2(.14,.65),vec2(.16,.57),vec2(.17,.55),vec2(.18,.51),\nvec2(.19,.47),vec2(.17,.45),vec2(.17,.44),vec2(.18,.37),vec2(.21,.28),\nvec2(.26,.21),vec2(.33,.17),vec2(.39,.15),vec2(.40,.11),vec2(.40,.05),\nvec2(.37,.02),vec2(.33,.03),vec2(.31,.05),vec2(.31,.01),vec2(.08,.01) );\n\nfloat sdPoly41 POLY(41)\nvec2 pt41[ 41]=vec2[](  \nvec2(.09,.65),vec2(.11,.57),vec2(.13,.56),vec2(.14,.53),vec2(.14,.48),\nvec2(.13,.46),vec2(.11,.45),vec2(.13,.36),vec2(.13,.31),vec2(.16,.23),\nvec2(.20,.18),vec2(.26,.14),vec2(.31,.13),vec2(.34,.12),vec2(.35,.08),\nvec2(.34,.06),vec2(.32,.05),vec2(.31,.05),vec2(.33,.04),vec2(.37,.03),\nvec2(.39,.05),vec2(.40,.08),vec2(.40,.11),vec2(.39,.14),vec2(.34,.17),\nvec2(.28,.20),vec2(.24,.23),vec2(.18,.34),vec2(.17,.41),vec2(.17,.45),\nvec2(.18,.47),vec2(.19,.50),vec2(.18,.54),vec2(.16,.56),vec2(.16,.57),\nvec2(.15,.62),vec2(.14,.65),vec2(.13,.66),vec2(.11,.67),vec2(.10,.66),\nvec2(.09,.65) );\n\n\nfloat sdPoly5 POLY(5)\nvec2 pt5[ 5]=vec2[](  \nvec2(.07,.57),vec2(.79,.60),vec2(.80,.01),vec2(.08,.01),vec2(.07,.57) );\n\n\nfloat sdPoly25c POLY(25)\nvec2 pt25c[ 25]=vec2[](  \nvec2(.26,.22),vec2(.26,.30),vec2(.30,.40),vec2(.34,.52),vec2(.36,.57),\nvec2(.40,.58),vec2(.43,.59),vec2(.46,.63),vec2(.50,.68),vec2(.53,.78),\nvec2(.57,.83),vec2(.62,.85),vec2(.66,.84),vec2(.70,.80),vec2(.74,.72),\nvec2(.73,.67),vec2(.71,.61),vec2(.69,.56),vec2(.68,.55),vec2(.73,.46),\nvec2(.81,.32),vec2(.84,.28),vec2(.93,.02),vec2(.26,.01),vec2(.26,.22) );\n\n\nfloat sdPoly31 POLY(31)\nvec2 pt31[ 31]=vec2[](  \nvec2(.26,.01),vec2(.26,.29),vec2(.36,.57),vec2(.42,.59),vec2(.45,.62),\nvec2(.49,.67),vec2(.51,.71),vec2(.53,.77),vec2(.55,.80),vec2(.59,.84),\nvec2(.63,.85),vec2(.66,.84),vec2(.70,.81),vec2(.73,.75),vec2(.66,.73),\nvec2(.63,.72),vec2(.62,.68),vec2(.60,.67),vec2(.59,.65),vec2(.57,.62),\nvec2(.55,.62),vec2(.55,.59),vec2(.54,.57),vec2(.53,.56),vec2(.57,.50),\nvec2(.55,.47),vec2(.53,.30),vec2(.52,.22),vec2(.51,.13),vec2(.50,.02),\nvec2(.26,.01) );\n\n\nfloat sdPoly14 POLY(14)\nvec2 pt14[ 14]=vec2[](  \nvec2(.52,.55),vec2(.55,.54),vec2(.57,.54),vec2(.59,.54),vec2(.60,.56),\nvec2(.61,.54),vec2(.60,.53),vec2(.59,.53),vec2(.58,.52),vec2(.58,.52),\nvec2(.58,.53),vec2(.55,.53),vec2(.53,.54),vec2(.52,.55) );\n\n\nfloat sdPoly30 POLY(30)\nvec2 pt30[ 30]=vec2[](  \nvec2(.53,.56),vec2(.58,.64),vec2(.65,.78),vec2(.70,.74),vec2(.70,.71),\nvec2(.70,.70),vec2(.69,.68),vec2(.68,.64),vec2(.68,.63),vec2(.67,.63),\nvec2(.66,.63),vec2(.66,.63),vec2(.67,.62),vec2(.67,.62),vec2(.65,.62),\nvec2(.64,.62),vec2(.66,.61),vec2(.66,.60),vec2(.65,.60),vec2(.65,.58),\nvec2(.64,.58),vec2(.61,.59),vec2(.59,.61),vec2(.60,.59),vec2(.60,.57),\nvec2(.60,.56),vec2(.59,.55),vec2(.56,.55),vec2(.54,.55),vec2(.53,.56) );\n\nfloat sdPoly7 POLY(7)\nvec2 pt7[ 7]=vec2[](  \nvec2(.69,.69),vec2(.68,.70),vec2(.67,.70),vec2(.64,.71),vec2(.67,.69),\nvec2(.68,.69),vec2(.69,.69) );\n\n\nfloat sdPoly9 POLY(9)\nvec2 pt9[ 9]=vec2[](  \nvec2(.64,.69),vec2(.65,.69),vec2(.66,.68),vec2(.67,.68),vec2(.66,.67),\nvec2(.65,.67),vec2(.64,.68),vec2(.64,.68),vec2(.64,.69) );\n\nfloat sdPoly5b POLY(5)\nvec2 pt5b[ 5]=vec2[](  \nvec2(.51,.68),vec2(.19,.72),vec2(.23,.68),vec2(.49,.65),vec2(.51,.68) );\n\nfloat sdPoly9b POLY(9)\nvec2 pt9b[ 9]=vec2[](  \nvec2(.51,.68),vec2(.19,.72),vec2(.23,.68),vec2(.49,.65),vec2(.51,.70),\nvec2(.22,.82),vec2(.19,.87),vec2(.53,.74),vec2(.51,.68) );\n\nfloat sdPoly13 POLY(13)\nvec2 pt13[ 13]=vec2[](  \nvec2(.51,.68),vec2(.19,.72),vec2(.23,.68),vec2(.49,.65),vec2(.51,.70),\nvec2(.22,.82),vec2(.19,.87),vec2(.53,.74),vec2(.54,.79),vec2(.33,.95),\nvec2(.33,1.00),vec2(.57,.82),vec2(.51,.68) );\n\nfloat sdPoly5c POLY(5)\nvec2 pt5c[ 5]=vec2[](  \nvec2(.67,.82),vec2(.85,.98),vec2(.89,.97),vec2(.70,.79),vec2(.67,.82) );\n\nfloat sdPoly20 POLY(20)\nvec2 pt20[ 20]=vec2[](  \nvec2(.51,.10),vec2(.53,.07),vec2(.55,.03),vec2(.56,.02),vec2(.57,.02),\nvec2(.57,.04),vec2(.57,.03),vec2(.58,.03),vec2(.59,.04),vec2(.59,.03),\nvec2(.61,.03),vec2(.61,.05),vec2(.62,.03),vec2(.63,.03),vec2(.63,.06),\nvec2(.60,.10),vec2(.55,.13),vec2(.53,.14),vec2(.52,.13),vec2(.51,.10) );\n\n\n\nfloat sdPoly7b POLY(7)\nvec2 pt7b[ 7]=vec2[](  \nvec2(.66,.62),vec2(.65,.62),vec2(.64,.62),vec2(.64,.62),vec2(.65,.62),\nvec2(.66,.61),vec2(.66,.62) );\n\nfloat sdPoly12 POLY(12)\nvec2 pt12[ 12]=vec2[](  \nvec2(.52,.56),vec2(.60,.55),vec2(.68,.36),vec2(.70,.28),vec2(.72,.24),\nvec2(.73,.04),vec2(.73,.08),vec2(.73,.07),vec2(.80,.03),vec2(.82,.01),\nvec2(.50,.01),vec2(.52,.56) );\n\nfloat sdPoly5d POLY(5)\nvec2 pt5d[ 5]=vec2[](  \nvec2(.66,.71),vec2(.92,.85),vec2(.97,.84),vec2(.70,.68),vec2(.66,.71) );\n\n\nfloat sdPoly5e POLY(5)\nvec2 pt5e[ 5]=vec2[](  \nvec2(.70,.67),vec2(.94,.76),vec2(.98,.74),vec2(.70,.63),vec2(.70,.67) );\n\nfloat sdPoly7c POLY(7)\nvec2 pt7c[ 7]=vec2[](  \nvec2(.00,.93),vec2(.05,.92),vec2(.15,.92),vec2(.17,.02),vec2(.06,.01),\nvec2(.00,.05),vec2(.00,.93) );\n\n//***------------****-----------****------------******-------\nvec3 RostroChica(in vec2 pp, vec3 col) \n{\n  vec2 p=pp;\n  \n   float sd25 = sdPoly25(p, pt25);\n   float sd41 = sdPoly41(p, pt41);\n   float sd5 = sdPoly5(p, pt5);\n   \n   float sd25b = sdPoly25(p-vec2(0.7,0.0), pt25);\n   float sd41b = sdPoly41(p-vec2(0.7,0.0), pt41);\n   float sd25c = sdPoly25c(p, pt25c);\n   float sd31 = sdPoly31(p, pt31);    \n   float sd14 = sdPoly14(p, pt14);\n   float sd30 = sdPoly30(p, pt30);\n   float sd7 = sdPoly7(p, pt7);\n   float sd9 = sdPoly9(p, pt9);\n   float sd5b = sdPoly5b(p, pt5b);\n   float sd9b = sdPoly9b(p, pt9b);\n   float sd13 = sdPoly13(p, pt13);\n   float sd5c = sdPoly5c(p, pt5c);\n   float sd20 = sdPoly20(p-vec2(-0.01,0.05*sin(iTime)), pt20);\n   float sd12 = sdPoly12(p, pt12);\n   float sd5d = sdPoly5d(p, pt5d);    \n   float sd5e = sdPoly5e(p, pt5e);\n   float sd7c = sdPoly7c(p, pt7c);\n   float sd7d = sdPoly7c(p-vec2(0.8,0.0), pt7c);\n   \n   col= ponerBorde(col1,col,sd5); //respaldo silla\n   col= ponerBorde(col1,col,sd7c); //columna\n   col= ponerBorde(col1,col,sd7d); //columna\n   col= ponerBorde(col1,col,sd25b);//silla figura 2\n   col= ponerBorde(col1,col,sd41b); //figura silla 2\n   col= ponerBorde(colDorado,col,sd5b); // rayo1\n   col= ponerBorde(colDorado,col,sd9b); // rayo1\n   col= ponerBorde(colDorado,col,sd13); // rayo1\n   col= ponerBorde(colDorado,col,sd5c); // rayo1\n   col= ponerBorde(colDorado,col,sd5d); // rayo1\n   col= ponerBorde(colDorado,col,sd5e); // rayo1\n   col= ponerBorde(col3,col,sd25c); //vestido izq\n   col= ponerBorde(col2,col,sd31); //vestido der\n   col= ponerBorde(col4,col,sd12); //vestido\n   col= ponerBorde(col1,col,sd25);//silla izq\n   col= ponerBorde(col1,col,sd41); //figura silla izq\n   col= ponerBorde(colVerde,col,sd14); //anillo cuello\n   col= ponerBorde(col5,col,sd30); //rostro\n   col= ponerBorde(colNegro,col,sd7); //pestaña\n   col= ponerBorde(colBlanco,col,sd9); //ojo\n   col= ponerBorde(col5,col,sd20); //mano\n   \n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    float t=iTime*1.0;\n    vec2 p=uv*0.5-vec2(-0.5,-0.5);\n    vec3 col=vec3(0.0); //vec3(0.25);\n    \n    //col=RostroChica(p*0.5-vec2(-0.25,0.0), col);\n    col=RostroChica(p, col);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdBXRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[304, 304, 339, 339, 363], [365, 365, 425, 425, 549], [551, 551, 582, 582, 603], [6375, 6437, 6478, 6478, 8350], [8352, 8352, 8409, 8409, 8725]], "test": "valid"}
{"id": "fdBXRR", "name": "Raymarching blobby sphere", "author": "disambiguator", "description": "adapted from https://www.shadertoy.com/view/Xtd3z7", "tags": ["raymarching"], "likes": 2, "viewed": 178, "published": "Public API", "date": "1619847270", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n * Part 3 Challenges\n * - Make the camera move up and down while still pointing at the cube\n * - Make the camera roll (stay looking at the cube, and don't change the eye point)\n * - Make the camera zoom in and out\n */\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\nconst float PI = 3.14159;\n\n/**\n * Signed distance function for a cube centered at the origin\n * with width = height = length = 2.0\n */\nfloat cubeSDF(vec3 p, vec3 eye) { \n    float v = sin(iTime) > 0. ? p.x : p.y;\n    \n    float jitter = sin(10.*sin(iTime)*v*PI/2.)/15.;\n\n    return length(p) +\n        jitter -\n       (1. + sin(20.*sin(iTime + PI/2.)*p.x*PI/2.))/20.-\n        1.5;\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint, vec3 eye) {\n    return cubeSDF(samplePoint, eye);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection, eye);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p, vec3 eye) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z), eye) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z), eye),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z), eye) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z), eye),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON), eye) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON), eye)\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p, eye);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(5.0 * sin(iTime/3.), 8.0 * sin(iTime/3.), 7.0);\n    \n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = vec3(p.x, 0.2, 0.2);\n    vec3 K_d = vec3(0.7, p.y, 0.2);\n    vec3 K_s = vec3(1.0, 1.0, p.z);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdBXRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[374, 482, 515, 515, 729], [731, 971, 1015, 1015, 1055], [1057, 1478, 1569, 1569, 1880], [1895, 2149, 2214, 2214, 2346], [2348, 2437, 2476, 2476, 2816], [2818, 3310, 3450, 3450, 4045], [4047, 4417, 4502, 4502, 5302], [5304, 5631, 5680, 5715, 5941], [5943, 5943, 6000, 6000, 6875]], "test": "valid"}
{"id": "fdBXz3", "name": "super goku -v3", "author": "jorge2017a1", "description": "super goku -v3", "tags": ["2d", "draw", "anime", "poly", "supergokuv3"], "likes": 3, "viewed": 168, "published": "Public API", "date": "1620651082", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//por jorge2017a1 ----jorgeFloresP---10/may/2021\n// referencia \n////-------------------\n/// IQ funciones....librerias\n//https://www.shadertoy.com/view/tlGBW3\n//Created by manu210404 in 2021-03-13\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(antialiasing(0.75),b,d)\n\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n    \nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r; }\n\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\nvec3 ponerBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj),0.0));\n  return colOut;\n}\n\nfloat opU(float d1, float d2) {return min(d1, d2); }\nconst vec3 colNegro=vec3(0.0);\nconst vec3 colGris=vec3(0.49,0.49,0.49);\nconst vec3 colGris2=vec3(0.6);\nconst vec3 colBlanco=vec3(1.0);\nconst vec3 colRojo=vec3(1.0,0.0,0.0);\nconst vec3 colAzul=vec3(0.0,0.0,1.0);\nconst vec3 colVerde=vec3(0.0,1.0,0.0);\nconst vec3 colVerde2=vec3(0.1,0.8,0.1);\nconst vec3 colrojoObs=vec3(0.45,0.13,0.15); //rojo obscuro\n\n\nconst vec3 colDorado=vec3(0.925,0.67,0.0);\n\n#define POLY(N) (in vec2 p, in vec2[N] v) {const int n=v.length();float d=dot(p-v[0],p-v[0]);float s=1.;for(int i=0,j=n-1;i<n;j=i,i++){vec2 e=v[j]-v[i];vec2 w=p-v[i];vec2 b=w-e*clamp(dot(w,e)/dot(e,e),0.,1.);d=min(d,dot(b,b));bvec3 cond=bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);if(all(cond)||all(not(cond))) s=-s;}return s*sqrt(d);}\n\n\nfloat sdPoly26 POLY(26)\nvec2 pt26[ 26]=vec2[](  \nvec2(.48,1.00),vec2(.73,1.00),vec2(.70,.83),vec2(.73,.86),vec2(.74,.87),\nvec2(.75,.87),vec2(.78,.84),vec2(.78,.79),vec2(.78,.74),vec2(.76,.68),\nvec2(.74,.66),vec2(.71,.65),vec2(.71,.57),vec2(.71,.54),vec2(.68,.50),\nvec2(.62,.44),vec2(.58,.41),vec2(.55,.41),vec2(.52,.46),vec2(.49,.52),\nvec2(.48,.53),vec2(.45,.71),vec2(.45,.73),vec2(.45,.78),vec2(.46,.83),\nvec2(.48,1.00) );\n\n\nfloat sdPoly8 POLY(8)\nvec2 pt8[ 8]=vec2[](  \nvec2(.50,.58),vec2(.55,.62),vec2(.56,.60),vec2(.52,.57),vec2(.53,.57),\nvec2(.53,.56),vec2(.51,.56),vec2(.50,.58) );\n\nfloat sdPoly15 POLY(15)\nvec2 pt15[ 15]=vec2[](  \nvec2(.50,.58),vec2(.55,.62),vec2(.56,.60),vec2(.52,.57),vec2(.53,.57),\nvec2(.53,.56),vec2(.51,.56),vec2(.50,.58),vec2(.55,.63),vec2(.57,.54),\nvec2(.57,.52),vec2(.57,.51),vec2(.54,.49),vec2(.53,.50),vec2(.50,.58) );\n\nfloat sdPoly8b POLY(8)\nvec2 pt8b[ 8]=vec2[](  \nvec2(.53,.50),vec2(.53,.52),vec2(.54,.54),vec2(.55,.55),vec2(.56,.55),\nvec2(.57,.52),vec2(.54,.50),vec2(.53,.50) );\n\nfloat sdPoly6 POLY(6)\nvec2 pt6[ 6]=vec2[](  \nvec2(.49,.68),vec2(.47,.62),vec2(.47,.61),vec2(.49,.59),vec2(.50,.63),\nvec2(.49,.68) );\n\nfloat sdPoly4 POLY(4)\nvec2 pt4[ 4]=vec2[](  \nvec2(.47,.61),vec2(.50,.63),vec2(.50,.60),vec2(.47,.61) );\n\nfloat sdPoly3 POLY(3)\nvec2 pt3[ 3]=vec2[](  \nvec2(.53,.69),vec2(.61,.73),vec2(.53,.69) );\n\nfloat sdPoly5 POLY(5)\nvec2 pt5[ 5]=vec2[](  \nvec2(.55,.69),vec2(.61,.72),vec2(.59,.70),vec2(.62,.71),vec2(.55,.69) );\n\nfloat sdPoly12 POLY(12)\nvec2 pt12[ 12]=vec2[](  \nvec2(.50,.76),vec2(.54,.85),vec2(.56,.90),vec2(.57,.91),vec2(.59,.91),\nvec2(.60,.91),vec2(.60,.88),vec2(.57,.86),vec2(.54,.84),vec2(.53,.81),\nvec2(.51,.78),vec2(.50,.76) );\n\nfloat sdPoly8c POLY(8)\nvec2 pt8c[ 8]=vec2[](  \nvec2(.45,.77),vec2(.46,.78),vec2(.47,.77),vec2(.48,.73),vec2(.48,.73),\nvec2(.46,.75),vec2(.45,.74),vec2(.45,.77) );\n\nfloat sdPoly23 POLY(23)\nvec2 pt23[ 23]=vec2[](  \nvec2(.46,.64),vec2(.40,.65),vec2(.35,.64),vec2(.31,.63),vec2(.38,.76),\nvec2(.26,.79),vec2(.16,.82),vec2(.30,1.00),vec2(.80,1.00),vec2(.80,.98),\nvec2(.92,1.00),vec2(.86,.91),vec2(.99,.90),vec2(.99,.84),vec2(.92,.76),\nvec2(1.00,.74),vec2(.99,.71),vec2(.88,.64),vec2(.93,.62),vec2(.81,.59),\nvec2(.80,.61),vec2(.73,.65),vec2(.46,.64) );\n\nfloat sdPoly35 POLY(35)\nvec2 pt35[ 35]=vec2[](  \nvec2(.58,.41),vec2(.62,.44),vec2(.67,.48),vec2(.70,.53),vec2(.71,.65),\nvec2(.80,.61),vec2(.83,.48),vec2(.92,.40),vec2(.95,.41),vec2(1.00,.38),\nvec2(1.00,.01),vec2(.00,.01),vec2(.00,.21),vec2(.05,.21),vec2(.08,.19),\nvec2(.13,.22),vec2(.18,.22),vec2(.23,.21),vec2(.26,.23),vec2(.26,.26),\nvec2(.30,.28),vec2(.32,.30),vec2(.36,.30),vec2(.37,.31),vec2(.42,.30),\nvec2(.45,.29),vec2(.45,.29),vec2(.46,.31),vec2(.49,.29),vec2(.53,.31),\nvec2(.54,.30),vec2(.55,.31),vec2(.59,.34),vec2(.59,.36),vec2(.58,.41) );\n\n\nfloat sdPoly14 POLY(14)\nvec2 pt14[ 14]=vec2[](  \nvec2(.36,.30),vec2(.35,.19),vec2(.35,.02),vec2(.45,.02),vec2(.45,.06),\nvec2(.47,.14),vec2(.50,.25),vec2(.54,.31),vec2(.51,.30),vec2(.49,.29),\nvec2(.46,.31),vec2(.45,.29),vec2(.42,.31),vec2(.36,.30) );\n\nfloat sdPoly18 POLY(18)\nvec2 pt18[ 18]=vec2[](  \nvec2(.25,.23),vec2(.26,.26),vec2(.27,.27),vec2(.29,.28),vec2(.29,.27),\nvec2(.31,.29),vec2(.33,.30),vec2(.34,.30),vec2(.36,.29),vec2(.37,.30),\nvec2(.36,.24),vec2(.35,.14),vec2(.35,.01),vec2(.33,.01),vec2(.32,.09),\nvec2(.30,.16),vec2(.27,.23),vec2(.25,.23) );\n\n\nfloat sdPoly10 POLY(10)\nvec2 pt10[ 10]=vec2[](  \nvec2(.95,.41),vec2(1.00,.39),vec2(1.00,.22),vec2(.94,.01),vec2(.71,.00),\nvec2(.79,.19),vec2(.83,.28),vec2(.86,.35),vec2(.91,.38),vec2(.95,.41) );\n\nfloat sdPoly20 POLY(20)\nvec2 pt20[ 20]=vec2[](  \nvec2(.54,.31),vec2(.56,.32),vec2(.51,.25),vec2(.48,.13),vec2(.54,.10),\nvec2(.62,.12),vec2(.70,.16),vec2(.75,.19),vec2(.79,.29),vec2(.85,.38),\nvec2(.88,.39),vec2(.95,.41),vec2(.95,.40),vec2(.90,.38),vec2(.86,.35),\nvec2(.73,.01),vec2(.45,.01),vec2(.46,.18),vec2(.53,.31),vec2(.54,.31) );\n\nfloat sdPoly3b POLY(3)\nvec2 pt3b[ 3]=vec2[](  \nvec2(.50,.83),vec2(.55,1.00),vec2(.50,.83) );\n\nfloat sdPoly7 POLY(7)\nvec2 pt7[ 7]=vec2[](  \nvec2(.47,.66),vec2(.49,.67),vec2(.48,.72),vec2(.47,.73),vec2(.46,.73),\nvec2(.46,.71),vec2(.47,.66) );\n\nfloat sdPoly9 POLY(9)\nvec2 pt9[ 9]=vec2[](  \nvec2(.54,.71),vec2(.58,.73),vec2(.58,.78),vec2(.58,.81),vec2(.56,.83),\nvec2(.55,.83),vec2(.53,.80),vec2(.53,.77),vec2(.54,.71) );\n\nfloat sdPoly9b POLY(9)\nvec2 pt9b[ 9]=vec2[](  \nvec2(.57,1.00),vec2(.58,.96),vec2(.58,.93),vec2(.57,.86),vec2(.59,.89),\nvec2(.63,.95),vec2(.63,.99),vec2(.63,1.00),vec2(.57,1.00) );\n\n\nfloat sdPoly10b POLY(10)\nvec2 pt10b[ 10]=vec2[](  \nvec2(.49,1.00),vec2(.54,1.00),vec2(.52,.95),vec2(.49,.90),vec2(.48,.86),\nvec2(.48,.77),vec2(.46,.82),vec2(.45,.91),vec2(.45,.93),vec2(.49,1.00) );\n\nfloat sdPoly17 POLY(17)\nvec2 pt17[ 17]=vec2[](  \nvec2(.72,.70),vec2(.73,.70),vec2(.75,.71),vec2(.76,.76),vec2(.76,.82),\nvec2(.76,.83),vec2(.77,.79),vec2(.77,.79),vec2(.77,.83),vec2(.75,.84),\nvec2(.74,.84),vec2(.73,.79),vec2(.72,.76),vec2(.73,.76),vec2(.73,.74),\nvec2(.73,.73),vec2(.72,.70) );\n\nfloat sdPoly9c POLY(9)\nvec2 pt9c[9]=vec2[](  \nvec2(.52,.24),vec2(.54,.24),vec2(.59,.23),vec2(.60,.23),vec2(.64,.25),\nvec2(.70,.29),vec2(.76,.32),vec2(.81,.33),vec2(.52,.24) );\n\n\nconst vec3 col1=vec3(0.83,0.34,0.69); //rosa\nconst vec3 col2=vec3(0.18,0.28,0.76); //azul\nconst vec3 col3=vec3(1.00,0.84,0.77); //piel\nconst vec3 col4=vec3(0.88,0.60,0.37); //piel obscuro\nconst vec3 col5=vec3(0.98,0.96,0.95); //blanco\nconst vec3 col6=vec3(0.97,0.42,0.14);\n\nfloat sdPoly4b POLY(4)\nvec2 pt4b[4]=vec2[](  \nvec2(.59,.19),vec2(.58,.14),vec2(.58,.11),vec2(.59,.19) );\n\nfloat sdPoly16 POLY(16)\nvec2 pt16[16]=vec2[](  \nvec2(.64,1.),vec2(.66,.91),vec2(.65,.87),vec2(.65,.83),vec2(.66,.84),\nvec2(.68,.86),vec2(.69,.87),vec2(.69,.82),vec2(.68,.81),vec2(.70,.82),\nvec2(.72,.84),vec2(.73,.86),vec2(.74,.87),vec2(.75,.87),vec2(.75,1.),\nvec2(.64,1.) );\n\n\nfloat sdPoly7b POLY(7)\nvec2 pt7b[7]=vec2[](  \nvec2(.10,.17),vec2(.15,.18),vec2(.18,.18),vec2(.22,.17),vec2(.25,.17),\nvec2(.27,.15),vec2(.10,.17) );\n\nfloat sdPoly7c POLY(7)\nvec2 pt7c[7]=vec2[](  \nvec2(.59,.38),vec2(.61,.36),vec2(.62,.32),vec2(.62,.31),vec2(.61,.35),\nvec2(.59,.37),vec2(.59,.38) );\n\nfloat sdPoly7d POLY(7)\nvec2 pt7d[7]=vec2[](  \nvec2(.70,.53),vec2(.70,.48),vec2(.64,.26),vec2(.64,.26),vec2(.70,.48),\nvec2(.70,.53),vec2(.70,.53) );\n\nfloat sdPoly3c POLY(3)\nvec2 pt3c[3]=vec2[](  \nvec2(.82,.45),vec2(.78,.35),vec2(.82,.45) );\n\n\n//***------------****-----------****------------******-------\nvec3 RostroGoku(in vec2 pp, vec3 col, vec2 uv) \n{\n  vec2 p=pp;\n   float sd26 = sdPoly26(p, pt26);\n   float sd8 = sdPoly8(p, pt8);\n   float sd15 = sdPoly15(p, pt15);\n   float sd8b = sdPoly8b(p, pt8b);\n   float sd6 = sdPoly6(p, pt6);\n   float sd4 = sdPoly4(p, pt4);\n   float sd3 = sdPoly3(p, pt3);\n   float sd5 = sdPoly5(p, pt5);\n   float sd12 = sdPoly12(p, pt12);\n   float sd8c = sdPoly8c(p, pt8c);\n   float sd23 = sdPoly23(p, pt23);\n   float sd35 = sdPoly35(p, pt35);\n   float sd14 = sdPoly14(p, pt14);\n   float sd18 = sdPoly18(p, pt18);\n   float sd10 = sdPoly10(p, pt10);\n   float sd20 = sdPoly20(p, pt20);\n   float sd3b = sdPoly3b(p, pt3b);    \n   float sd7 = sdPoly7(p, pt7);\n   float sd9 = sdPoly9(p, pt9);\n   float sd9b = sdPoly9b(p, pt9b);\n   float sd10b = sdPoly10b(p, pt10b);\n   float sd17 = sdPoly17(p, pt17);\n   float sd9c = sdPoly9c(p, pt9c);\n   float sd4b = sdPoly4(p, pt4b);\n   float sd16 = sdPoly16(p, pt16);\n    float sd7b = sdPoly7b(p, pt7b);\n    float sd7c = sdPoly7c(p, pt7c);\n   float sd7d = sdPoly7d(p, pt7d);\n    float sd3c = sdPoly3c(p, pt3c);\n   \n   float sdojo1= sdCircle(uv-vec2(-0.03,0.28), 0.02 );\n   float sdojo2= sdCircle(uv-vec2(-0.22,0.19), 0.02 ); //izq pupila\n   \n   float t1=mod(iTime,1.);\n   float t2=mod(iTime,2.);\n   vec3 colpelo;\n   if (t1<t2)\n    colpelo=mix(colNegro, colDorado, p.y);\n   else\n       colpelo=colNegro;\n   //col=mix(col,colpelo ,S( sd23,0.0)); // pelo\n   col=ponerBorde(colpelo,col,sd23); //pelo\n   col= ponerBorde(col3,col,sd26); //rostro\n   col=mix(col,colBlanco ,S( sd8,0.0));// dientes\n   col= ponerBorde(colNegro,col,sd15); // boca\n   col= ponerBorde(colRojo,col,sd8b); //lengua\n   col= ponerBorde(col3,col,sd6); // nariz\n   col= ponerBorde(col4,col,sd4); // \n   col=mix(col,colNegro ,S( sd3,0.0)); //linea rostro1\n   col=mix(col,colNegro ,S( sd5,0.0)); //linea rostro 2\n   col=mix(col,colNegro ,S( sd12,0.0)); //ceja der\n   col=mix(col,colNegro ,S( sd8c,0.0)); //ceja izq\n   col= ponerBorde(col3,col,sd35); // cuerpo\n   col= ponerBorde(col6,col,sd14); // camisa 0 roja\n   col= ponerBorde(col2,col,sd18); //camisa 1 azul\n   col= ponerBorde(col6,col,sd10); //camisa 2 azul\n   col= ponerBorde(col2,col,sd20); // camisa roja 2\n   col= ponerBorde(col1,col,sd3b); // linea 2 arruga\n   col= ponerBorde(colBlanco,col,sd7); // ojo izq\n   col= ponerBorde(colBlanco,col,sd9); // ojo der\n   col= ponerBorde(colpelo,col,sd9b); // pelo negro\n   col= ponerBorde(colpelo,col,sd10b); // pelo negro\n   col= ponerBorde(col4,col,sd17); // oreja\n   col= ponerBorde(colNegro,col,sd9c); // linea pecho\n   col= ponerBorde(colNegro,col,sdojo1); // pupila-ojo \n   col= ponerBorde(colNegro,col,sdojo2); // pupila-ojo \n   col=mix(col,colNegro ,S( sd4b ,0.0));// linea\n   col=mix(col,colpelo ,S( sd16 ,0.0));\n   col=mix(col,colNegro ,S( sd7b ,0.0));\n   col=mix(col,colNegro ,S( sd7c ,0.0));\n   col=mix(col,colNegro ,S( sd7d ,0.0));\n   col=mix(col,colNegro ,S( sd3c ,0.0));\n  return col;\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    \n    float t=1.0-0.5*fract(sin(iTime*0.5));\n    uv*=t;\n    //uv.x+=1.4;uv.y+=0.8;\n    vec2 p=uv;\n    p.x+=1.4;p.y+=0.8;\n    p.x*=0.4; p.y*=0.7;\n    vec3 col=mix(col1, vec3(0.0),uv.y*0.5);\n    col=RostroGoku(p, col, uv);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdBXz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[356, 394, 430, 430, 475], [481, 481, 516, 516, 540], [542, 542, 576, 576, 673], [674, 674, 734, 734, 859], [861, 861, 892, 892, 913], [7997, 8059, 8108, 8108, 10979], [10982, 10982, 11039, 11039, 11393]], "test": "valid"}
{"id": "fdjSD3", "name": "Fork Girls Only ", "author": "NikolaErceg", "description": "A representation of how women have changed over time.", "tags": ["girlpower"], "likes": 1, "viewed": 152, "published": "Public API", "date": "1621164526", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rgbOffset = 0.0;\n\n   float vertScroll = -0.0;\n\n   float horzFuzziness = 0.0;\n\n   float bottomStatic = -1.0;\n   \n   float Static = -1.0;\n\n   float vertMove =0.0;\n\n   float scalines = 1.0;\n\nvec3 HayburnEdit (vec3 y) {\n  return y - round(y * (3.0 / 180.0)) * 180.0;\n}\n\nvec2 HayburnEdit (vec2 y) {\n  return y - round(y * (1.0 / 90.0)) * 90.0;\n}\n\nvec3 changes(vec3 x) {\n  return HayburnEdit (((x*12.0)+1.0)*x);\n}\n\nfloat statickyEffect (vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,\n                      0.366025403784439,\n                     -0.577350269189626,\n                      0.024390243902439);\n                      \n  vec2 i  = round(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = HayburnEdit(i);\n  vec3 p = changes( changes( i.y + vec3(3.0, i1.y, -6.0 ))\n\t\t+ i.x + vec3(9.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.x,x12.y), dot(x12.zw,x12.zw)), -1.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = round(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nfloat staticV(vec2 uv) {\n    float staticHeight = statickyEffect(vec2(9.0,iTime*1.2+1.0))*0.3+5.0;\n    float staticAmount = statickyEffect(vec2(30.0,iTime*1.2-12.0))*0.1+0.5;\n    float staticStrength = statickyEffect(vec2(-5.75,iTime*0.6-7.0))*2.0+4.0;\n\treturn (1.0-step(statickyEffect(vec2(5.0*pow(iTime,2.0)+pow(uv.x*7.0,1.2),pow((mod(iTime,100.0)+100.0)*uv.y*0.3+3.0,staticHeight))),staticAmount))*staticStrength;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uvA = fragCoord / iChannelResolution[1].xy;\n    vec2 uvB = fragCoord / iChannelResolution[0].xy;\n    fragColor = texture(iChannel0, uvA) + texture(iChannel1, uvB);\n\n\tvec2 uv =  fragCoord.xy/iResolution.xy;\n\t\n\tfloat jerkOffset = (1.0-step(statickyEffect(vec2(iTime*1.3,2.0)),0.8))*0.05;\n\t\n\tfloat fuzzOffset = statickyEffect(vec2(iTime*15.0,uv.y*80.0))*0.003;\n\tfloat largeFuzzOffset = statickyEffect(vec2(iTime*1.0,uv.y*3.0))*0.004;\n    \n    float vertMovementOn = (1.0-step(statickyEffect(vec2(iTime*0.2,1.0)),0.4))*vertMove;\n    float vertJerk = (1.0-step(statickyEffect(vec2(iTime*1.5,5.0)),0.6))*vertScroll;\n    float vertJerk2 = (1.0-step(statickyEffect(vec2(iTime*5.5,5.0)),0.2))*vertScroll;\n    float yOffset = abs(sin(iTime)*1.0)*vertMovementOn+vertJerk*vertJerk2*0.3;\n    float y = mod(uv.y+yOffset,1.0);\n    \n\t\n\tfloat xOffset = (fuzzOffset + largeFuzzOffset) * horzFuzziness;\n    \n    float staticVal = 0.0;\n   \n    for (float y = -1.0; y <= -1.0; y += 3.0) {\n        float maxDist = 5.0/200.0;\n        float dist = y/200.0;\n    \tstaticVal += staticV(vec2(uv.x,uv.y+dist))*(maxDist-abs(dist))*1.5;\n    }\n        \n    staticVal *= bottomStatic;\n\t\n\tfloat red \t=   texture(\tiChannel0, \tvec2(uv.x + xOffset -3.01*rgbOffset,y)).r+staticVal;\n\tfloat green = \ttexture(\tiChannel1, \tvec2(uv.x + xOffset,\t  y)).g+staticVal;\n\tfloat blue \t=\ttexture(\tiChannel3, \tvec2(uv.x + xOffset +1.01*rgbOffset,y)).b+staticVal;\n\t\n\tvec3 color = vec3(red,green,blue);\n\tfloat scanline = sin(uv.y*700.0)*-0.12*scalines;\n\tcolor -= scanline;\n\t\n\tfragColor = vec4(color,0.0);\n    }", "image_inputs": [{"id": "Xdf3Rn", "previewfilepath": "/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video"}, {"id": "Xdf3Rn", "previewfilepath": "/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video"}, {"id": "4df3zn", "previewfilepath": "/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdjSD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[194, 194, 221, 221, 270], [272, 272, 299, 299, 346], [348, 348, 370, 370, 413], [415, 415, 448, 448, 1342], [1344, 1344, 1368, 1368, 1762], [1765, 1765, 1822, 1822, 3387]], "test": "error"}
{"id": "fdjSDy", "name": "Fork  fractal  NikolaErce 522", "author": "NikolaErceg", "description": "Creating multiple shapes with one SDF evaluation by repeatedly rotating and folding space", "tags": ["fractalcineshader"], "likes": 7, "viewed": 1421, "published": "Public API", "date": "1620936564", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 palette(float d){\n\treturn mix(vec3(0.0,3.02,1.24),vec3(1.,0.01,1.2),d);\n}\n\nvec2 rotate(vec2 p,float a){\n\tfloat c = cos(a);\n    float s = sin(a);\n    return p*mat2(c,s,-s,c);\n}\n\nfloat map(vec3 p){\n    for( int i = 0; i<66; ++i){\n        float t = iTime*0.006;\n        p.xz =rotate(p.xz,t);\n        p.xy =rotate(p.xy,t*1.0);\n        p.xz = abs(p.xz);\n        p.xz-=.16;\n\t}\n\treturn dot(sign(p),p)/6.;\n}\n\nvec4 rm (vec3 ro, vec3 rd){\n    float t = 1.;\n    vec3 col = vec3(0.006);\n    float d;\n    for(float i =0.; i<36.; i++){\n\t\tvec3 p = ro + rd*t;\n        d = map(p)*.98;\n        if(d<0.07){\n            break;\n        }\n        if(d>22.){\n        \tbreak;\n        }\n        //col+=vec3(3.6,3.8,3.8)/(400.*(d));\n        col+=palette(length(p)*.1)/(222.*(d));\n        t+=d;\n    }\n    return vec4(col,1./(d*20.));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-(iResolution.xy/2.))/iResolution.x;\n\tvec3 ro = vec3(55.,55.,-13.);\n    ro.xz = rotate(ro.xz,iTime);\n    vec3 cf = normalize(-ro);\n    vec3 cs = normalize(cross(cf,vec3(7,3.,17.)));\n    vec3 cu = normalize(cross(cf,cs));\n    \n    vec3 uuv = ro+cf*3. + uv.x*cs + uv.y*cu;\n    \n    vec3 rd = normalize(uuv-ro);\n    \n    vec4 col = rm(ro,rd);\n    \n    \n    fragColor = col;\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"fractal pyramid\",\n\t\"description\": \"\",\n\t\"model\": \"car\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdjSDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 78], [80, 80, 108, 108, 180], [182, 182, 200, 200, 404], [406, 406, 433, 433, 813], [814, 814, 871, 871, 1268]], "test": "valid"}
{"id": "fdjSWD", "name": "MandleBulb", "author": "UberAtlas", "description": "Learning shaders by rendering a mandlebulb.", "tags": ["fractal", "fractals", "mandlebulb", "trippy", "replication"], "likes": 3, "viewed": 65, "published": "Public", "date": "1620258163", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//////////////////////\n// Raymarch Config\n//////////////////////\nconst int MAX_STEPS = 100;\nconst float MINIMUM_HIT_DISTANCE = 0.001;\nconst float MAXIMUM_TRACE_DISTANCE = 500.0;\nconst float DARKNESS = 35.0;\n\n//////////////////////\n// MandleBulb Config\n//////////////////////\nconst int ITERATIONS = 15;\nconst float BULB_SCALE = 0.5;\n\n\n// Adapted from: http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\nfloat mandleBulbDistance(vec3 pos) {\n\tvec3 z = pos;\n\tfloat dr = 1.;\n\tfloat r = 0.0;\n    float power = 1. + iTime / 15.;\n\n\tfor (int i = 0; i < ITERATIONS ; i++) {\n\t\tr = length(z);\n\t\tif (r > 2.) break;\n\n\t\t// convert to polar coordinates\n        float theta = asin( z.z/r );\n        float phi = atan( z.y,z.x );\n\t\tdr =  pow(r, power - 1.0) * power * dr + 1.0;\n\n\t\t// scale and rotate the point\n\t\tfloat zr = pow(r, power);\n\t\ttheta = theta * power;\n\t\tphi = phi * power;\n\n\t\t// convert back to cartesian coordinates\n\t\tz = zr * vec3(cos(theta) * cos(phi), cos(theta) * sin(phi), sin(theta));\n\t\tz += pos;\n\t}\n\n\treturn BULB_SCALE * log(r) * r / dr;\n}\n\nfloat world(in vec3 pos) {\n    return mandleBulbDistance(pos);\n}\n\nvec3 normalOfPos(in vec3 pos) {\n    const vec3 step = vec3(0.001, 0.0, 0.0);\n\n    float gradX = world(pos + step.xyy) - world(pos - step.xyy);\n    float gradY = world(pos + step.yxy) - world(pos - step.yxy);\n    float gradZ = world(pos + step.yyx) - world(pos - step.yyx);\n\n    vec3 normal = vec3(gradX, gradY, gradZ);\n\n    return normalize(normal);\n}\n\n// Adapted from https://michaelwalczyk.com/blog-ray-marching.html\nvec3 rayMarch(in vec3 ro, in vec3 rd, in vec2 uv) {\n    float totalDistanceTraveled = 0.0;\n    \n    vec3 color = mix(sin(iTime / 7. + vec3(1.4,0.7,10.1)), vec3(uv.x), vec3(uv.y)) * 0.3;\n    \n    int steps = 0;\n    while (steps < MAX_STEPS) {\n        // Calculate our current position along the ray\n        vec3 curPos = ro + totalDistanceTraveled * rd;\n\n        float distToClosest = mandleBulbDistance(curPos);\n        \n        // Hit\n        if (distToClosest < MINIMUM_HIT_DISTANCE) {\n            vec3 normal = normalOfPos(curPos);\n            vec3 lightPos = vec3(1., 2., 3.);\n            vec3 lightDir = normalize(curPos - lightPos);\n            float diffuseIntensity = max(0.0, dot(normal, lightDir));\n            color = sin(iTime / 7. + curPos.zyx + vec3(1.4,0.7,10.1)) * diffuseIntensity;\n            break;\n        }\n        \n        // Miss\n        if (totalDistanceTraveled > MAXIMUM_TRACE_DISTANCE) break;\n\n        // accumulate the distance traveled thus far\n        totalDistanceTraveled += distToClosest;\n        \n        steps += 1;\n    }\n\n    // Inspired by https://github.com/SebLague/Ray-Marching/blob/f7e44c15a212dec53b244b1f53cdaf318f6ec700/Assets/Scripts/Fractal/Fractal.compute\n    float rim = float(steps) / DARKNESS;\n    return color * rim;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    vec3 cameraPos = vec3(-.7, -.5, -2.);\n    vec3 ro = cameraPos;\n    vec3 rd = vec3(uv, 0.75);\n\n    // Time varying pixel color\n    vec3 col = rayMarch(ro, rd, uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdjSWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[335, 475, 511, 511, 1113], [1115, 1115, 1141, 1141, 1179], [1181, 1181, 1212, 1212, 1532], [1534, 1600, 1651, 1651, 2869], [2871, 2871, 2928, 2978, 3246]], "test": "valid"}
{"id": "fdjXWc", "name": "Iridescent Bokeh", "author": "Jaromir", "description": "Moving fake bokeh with fake iridescence. ", "tags": ["2d", "bokeh", "bubbles", "moving", "iridescent"], "likes": 19, "viewed": 595, "published": "Public API", "date": "1621188762", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define C_PI 3.14159265359\n\n\nvec3 hash13(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\nvec3 flower(vec2 p, float t, float id){\n\n    vec3 r = hash13(id+floor(t)*13.);    \n\n    float lT = fract(-t);\n    float ilT = 1.-lT;\n    \n    lT*=lT;\n    \n    float fade = sin(lT*C_PI);\n    fade = smoothstep(0.0,0.1,fade);\n    fade*=fract(t);\n\n    p+=vec2(r.xy-0.5)*pow(lT,.25);\n\n\n    p*=lT*5.;\n\n\n    float l = length(p);\n    float m = smoothstep(.4,0.,l);\n\n    float a = atan(p.y,p.x);\n\n      \n    a = sin(a*r.x*1.23  + iTime*0.123) * \n        sin(a*r.y*2.321 + iTime*0.456) *\n        sin(a*r.z*1.123 + iTime*0.589) *\n        sin(a);\n\n    l = mix(l,a*(r.x-0.5)*3.*ilT,r.z*0.5+0.2);\n    \n    float s1  = smoothstep(.5,0.,l);\n    float s2  = smoothstep(0.01,0.,l);\n    float s = (s1-s2)*m;\n\n\n    vec3 c1 =  vec3(sin(s *vec3(0.987,0.765,0.543)*C_PI*1.4));\n    vec3 c2 =  vec3(sin(s2*vec3(0.13*r.x,0.865*r.y,0.943*r.z)*6.664));\n\n    vec3 sOut = (c1*mix(c2,vec3(1.),r.y*0.5+0.5)*c1)*fade;\n    \n\n    return  sOut*l;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\n    vec3 s = vec3(0.);\n\n    const float amount = 20.;\n    float del = 1./amount;\n\n    for(float i = 1.; i <= amount; i++){\n\n     s+=flower(uv,iTime*0.05 + del*i,i);\n    \n    }\n\n    fragColor = vec4(pow(s*3.,vec3(0.4545)),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdjXWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 51, 51, 184], [187, 187, 226, 226, 1099], [1102, 1102, 1159, 1159, 1447]], "test": "valid"}
{"id": "fdSSDt", "name": "Metagouts", "author": "Kali", "description": "2D metaball thingy with 3D lighting based on heightmap.", "tags": ["2d", "3d", "fake"], "likes": 13, "viewed": 186, "published": "Public", "date": "1621226768", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat ds;\n\nvec2 hash(vec2 p)\n{\n    vec3 p3 = fract(p.xyx * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx).xy;\n}\n\nvec2 noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n    \n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nmat2 rot(float a){\n    float s=sin(a),c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nfloat map(vec2 p)\n{\n    float d=1000.;\n    for (int i=0; i<50; i++)\n    {\n        vec2 pr=noise(vec2(float(i)*.7+iTime*.05)).xy-.5;\n        pr.x*=1.7;\n        d=smin(d,pow(length(p+pr),2.)-.001,.01);\n    }\n    ds=d;\n    return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p=(fragCoord-iResolution.xy*.5)/iResolution.y;\n    vec3 col1=vec3(1.,.6,.3);\n    vec3 col2=vec3(.4,.7,1.);\n//    float d=map(p);\n    vec3 ldir=normalize(vec3(1.,2.,.7));\n    vec3 amb=col1*.8;\n    vec2 eps=vec2(0.,.01);\n    vec3 n=normalize(vec3(map(p+eps.yx),map(p+eps.xy),eps.y*.3)-map(p));\n    float dif=smoothstep(.0,1.,max(0.,dot(ldir,n)));\n    float dr=smoothstep(.001,0.,ds);\n    col1-=smoothstep(.5,.6,fract(p.y*20.))*.2;\n    fragColor=vec4(mix(mix(col1,col2,smoothstep(-.5,.3,p.y))*.7,amb+dif,dr),1.);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdSSDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[12, 12, 31, 31, 167], [169, 169, 194, 194, 494], [496, 496, 514, 514, 572], [575, 575, 616, 616, 709], [712, 712, 731, 731, 943], [945, 945, 1001, 1001, 1522]], "test": "valid"}
{"id": "fdSSWm", "name": "Coder Husk's Ray-Marcher", "author": "CoderHusk", "description": "learning", "tags": ["raymarching"], "likes": 2, "viewed": 54, "published": "Public", "date": "1620331848", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct Sphere {\n    vec3 position;\n    vec3 color;\n    float radius;\n    float dist;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n    float t;\n};\n\nconst int MAX_SPHERES = 2;\nconst float EPSILON = 0.01;\nconst int MAX_STEPS = 10000;\nconst float RENDER_DISTANCE = 1000.0;\nconst vec3 light = vec3(-2.0, 5.0, -3.0);\n\nSphere SPHERES[MAX_SPHERES];\n\nfloat SDF_Sphere(Sphere sphere, vec3 p) {\n    return length(sphere.position - p) - sphere.radius;\n}\n\nfloat mapWorld(vec3 p) {\n  float modifier = (cos(iTime)*0.5+1.5)*3.0;\n  float displacement = sin(p.x * modifier) * sin(p.y * modifier) * sin(p.z * modifier) * 0.25;\n    \n  SPHERES[0].position = vec3(0.0, 0.0, 0.0);\n  SPHERES[0].color = vec3(1.0, 0.0, 0.0);\n  SPHERES[0].radius = 1.0;\n  SPHERES[0].dist = SDF_Sphere(SPHERES[0], p);\n  \n  return SPHERES[0].dist + displacement;\n}\n\nvec3 calcNormal(vec3 p) {\n  const vec3 epsilonStep = vec3(EPSILON, 0.0, 0.0);\n  \n  float gX = mapWorld(p+epsilonStep.xyy) - mapWorld(p - epsilonStep.xyy);\n  float gY = mapWorld(p+epsilonStep.yxy) - mapWorld(p - epsilonStep.yxy);\n  float gZ = mapWorld(p+epsilonStep.yyx) - mapWorld(p - epsilonStep.yyx);\n  \n  return normalize(vec3(gX,gY,gZ));\n}\n\nvec3 raymarch(inout Ray ray) {\n      for (int i=0; i<MAX_STEPS; i++) {\n          vec3 cp = ray.origin+(ray.direction*ray.t);\n          float dist = mapWorld(cp);\n          \n          \n          if (dist < EPSILON) {\n              vec3 normal = calcNormal(cp);\n              float diffuseMix = max(dot(normalize(light - cp), normal),0.0);\n              float specularAngle = pow(max(dot(normalize(reflect(ray.direction, normal)), normalize(light - cp)),0.0), 10.0);\n              return (vec3(1.0, 0.0, 0.0)*diffuseMix*(1.0 - specularAngle) + specularAngle) + (vec3(1.0, 1.0, 0.0) * 0.2);\n          } else if (dist > RENDER_DISTANCE) {\n              break;\n          }\n          ray.t += dist;\n  }\n  return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    Ray primaryRay;\n    primaryRay.origin = vec3(0.0, 0.0, -4.0);\n    primaryRay.direction = normalize(vec3(uv.x, uv.y, 1.0));\n    primaryRay.t = 0.0;\n    \n    vec3 col = raymarch(primaryRay);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdSSWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[351, 351, 392, 392, 450], [452, 452, 476, 476, 828], [830, 830, 855, 855, 1173], [1175, 1175, 1205, 1205, 1893], [1895, 1895, 1952, 1952, 2279]], "test": "valid"}
{"id": "fdSXDz", "name": "cppn2glsl_test", "author": "vsewall", "description": "this code was generated by lucid neural network in google colab", "tags": ["neural", "colab", "cppn"], "likes": 1, "viewed": 61, "published": "Public", "date": "1619984514", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define N_HIDDEN 16\n \nvec4 bufA[N_HIDDEN/4];\nvec4 bufB[N_HIDDEN/2];\n \n \nvec4 cppn_fn(vec2 coordinate, float in0, float in1, float in2, float in3) {\n    vec4 tmp;\n    bufB[0] = vec4(coordinate.x, coordinate.y, 0., 0.);\nbufA[0] = vec4(0.1392157,-0.14403622,-0.10987018,0.088629395) + mat4(vec4(0.5527324080467224,0.7989373803138733,0.8469162583351135,-0.4809730350971222),vec4(0.02086402103304863,-0.7741007804870605,0.08225523680448532,-0.6063721776008606),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\nbufA[1] = vec4(0.22139116,0.46250686,0.47169903,0.2716057) + mat4(vec4(-0.34766313433647156,0.07682348787784576,-0.3346748948097229,-0.6201396584510803),vec4(0.019231440499424934,-1.826249122619629,0.724222719669342,0.07378915697336197),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\nbufA[2] = vec4(-0.21973355,0.08887826,-0.2843799,-0.3404704) + mat4(vec4(-0.25068917870521545,0.3535909354686737,-0.6616144776344299,0.6285610795021057),vec4(0.856115996837616,0.7632209658622742,0.05364528298377991,-0.3126447796821594),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\nbufA[3] = vec4(-0.30295828,0.26827592,-0.07280064,0.5746382) + mat4(vec4(-0.8132221102714539,-0.12490193545818329,0.6580310463905334,1.1463209390640259),vec4(0.0959293395280838,0.4924165904521942,-1.2564489841461182,-0.7626469135284424),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\ntmp = sin(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(-0.29099172,0.053163238,0.33655,-0.44018662) + mat4(vec4(0.1488758,-0.13007033,-0.12612073,-0.036037873),vec4(0.03960949,-0.014362597,0.33148044,0.16588044),vec4(0.16212001,-0.19103622,-0.0677809,0.031183003),vec4(-0.051917557,-0.12049083,-0.32648787,-0.2033548)) * bufB[0] + mat4(vec4(-0.14938232,0.4440312,-0.4179407,-0.06715003),vec4(-0.16362296,0.06070456,-0.1242206,0.20667146),vec4(-0.059568487,-0.13040295,-0.08550807,-0.012654861),vec4(-0.13037446,0.00030371142,0.14328898,0.05768267)) * bufB[1] + mat4(vec4(-0.04780508,0.15955468,-0.13329466,-0.31489387),vec4(-0.26004887,0.5244744,0.045032687,-0.1802943),vec4(-0.14015667,-0.267675,-0.035999272,-0.1752947),vec4(0.10329164,0.10043791,0.17175077,-0.260937)) * bufB[2] + mat4(vec4(-0.4537429,0.27386698,-0.15144984,0.02024186),vec4(-0.15538639,0.21396668,0.025437992,0.2656227),vec4(0.1936712,-0.13960783,-0.17575692,-0.25811082),vec4(0.028781246,0.0911344,-0.18983151,0.05253229)) * bufB[3] + mat4(vec4(-0.08293231,0.06868567,-0.022794917,-0.02395075),vec4(-0.024213118,-0.22359733,0.42282668,0.001109852),vec4(-0.06889077,0.11945153,0.42088354,-0.055431847),vec4(-0.28987953,-0.19718204,0.16046244,-0.12231544)) * bufB[4] + mat4(vec4(0.047418974,-0.18389301,-0.08816122,0.19270442),vec4(0.38551316,0.2980147,-0.30117923,-0.013725798),vec4(-0.039796352,-0.082422756,0.2391206,-0.012220968),vec4(0.17030501,-0.19140936,0.085609354,0.1641735)) * bufB[5] + mat4(vec4(-0.21387827,-0.27800795,-0.1037876,-0.07727278),vec4(-0.17854458,-0.46085793,0.042386014,-0.078590564),vec4(-0.1749416,-0.044531573,-0.2253041,-0.16668102),vec4(0.30727983,0.16109681,0.032084696,0.17205977)) * bufB[6] + mat4(vec4(-0.04392544,0.04620644,-0.099748015,-0.35749027),vec4(-0.045716472,0.16244918,0.25105783,-0.043241307),vec4(0.58723307,-0.11942209,-0.110083275,-0.17061919),vec4(-0.100056686,-0.19621271,-0.27439958,-0.020583557)) * bufB[7];\nbufA[1] = vec4(0.3830168,0.2874283,0.14254777,0.42079642) + mat4(vec4(-0.21236464,0.055113092,0.12764215,0.21360692),vec4(0.046499714,0.15253353,0.103622235,-0.033114005),vec4(0.41094106,-0.1809898,0.0052033872,0.17236902),vec4(-0.026378231,-0.2867365,-0.00802052,0.011740454)) * bufB[0] + mat4(vec4(0.12206383,-0.18698648,0.116284564,-0.07349405),vec4(-0.05186169,-0.28004634,0.25088128,0.14829881),vec4(0.17162809,0.056021478,0.045127384,-0.23950022),vec4(-0.17422828,-0.04335135,-0.17165561,0.09718971)) * bufB[1] + mat4(vec4(-0.053994935,-0.028770551,-0.3246327,0.0031834503),vec4(-0.04128619,0.18585624,0.33212894,0.279761),vec4(-0.013036767,0.08397355,-0.086608864,-0.28791192),vec4(0.03548049,0.10911093,0.31858805,0.13294305)) * bufB[2] + mat4(vec4(-0.25094414,0.23058459,-0.09613707,0.00034706155),vec4(-0.19537666,-0.09685629,0.030484783,0.06754539),vec4(0.30228484,0.02408613,-0.13061455,0.00036060112),vec4(0.2914868,0.10293909,0.012473264,0.0076613924)) * bufB[3] + mat4(vec4(0.31394285,0.30644014,0.029825948,0.19991136),vec4(0.10754622,0.089245304,-0.20936476,0.18153508),vec4(0.1315374,0.22907963,-0.20751034,0.11499764),vec4(0.30139616,0.33424008,-0.21035446,-0.13899507)) * bufB[4] + mat4(vec4(-0.1943886,0.11355618,0.20307432,-0.07389561),vec4(-0.04867342,0.34333962,0.115580976,-0.09749835),vec4(-0.13576066,-0.09389041,0.23772424,0.056525506),vec4(-0.44207153,0.075010836,-0.10123406,-0.27951798)) * bufB[5] + mat4(vec4(0.16840778,0.20292947,-0.1650962,0.18211474),vec4(0.20777595,0.3161431,-0.066138044,-0.012093568),vec4(-0.057748593,0.24185073,-0.061927587,0.09538677),vec4(-0.1825104,0.103294976,0.20056523,0.038109712)) * bufB[6] + mat4(vec4(0.023510307,0.16611512,-0.053307906,0.2887182),vec4(0.062454037,-0.10624931,-0.07611613,-0.01301078),vec4(-0.005081722,0.19987212,-0.17287713,-0.043693144),vec4(-0.059820876,-0.22353047,-0.20382859,-0.121855825)) * bufB[7];\nbufA[2] = vec4(-0.33257222,0.14988104,-0.20734628,0.017082373) + mat4(vec4(0.018002484,-0.025729239,-0.053308696,-0.036156498),vec4(-0.046571136,0.20754321,0.055922598,0.074227564),vec4(0.08758112,0.12437972,0.036959488,-0.089939594),vec4(-0.102925844,-0.20014992,-0.30133504,-0.03703004)) * bufB[0] + mat4(vec4(-0.029336631,-0.29781926,0.012046123,0.21460238),vec4(-0.23119316,0.0180176,0.18100971,0.24652176),vec4(0.121431984,-0.02553179,-0.08404241,0.087732896),vec4(-0.26654887,-0.06574553,-0.09177668,0.2934775)) * bufB[1] + mat4(vec4(-0.3380493,0.10213437,-0.023803582,-0.19724478),vec4(-0.14164269,0.10570151,-0.07955972,-0.11092779),vec4(-0.01442183,-0.14666343,-0.15033148,0.29843006),vec4(-0.0059082177,0.24761464,0.18102859,-0.13663957)) * bufB[2] + mat4(vec4(-0.00015309431,0.003621174,0.119538955,0.012908104),vec4(0.3012528,-0.30036443,0.04650813,-0.10629595),vec4(-0.12878606,0.120935336,-0.071355246,0.028908722),vec4(-0.014884945,-0.22306581,-0.08994216,-0.14647196)) * bufB[3] + mat4(vec4(0.51238346,0.106096976,-0.080477364,-0.20291492),vec4(0.09534993,0.21976463,-0.38841623,0.22007291),vec4(0.010133497,0.15211082,-0.22895138,-0.13117568),vec4(0.21484356,0.20384751,0.1464498,0.18264726)) * bufB[4] + mat4(vec4(-0.0025207803,0.19650064,0.0660299,-0.0950627),vec4(-0.18468265,-0.14092077,0.003937874,0.34481218),vec4(-0.099528335,0.09127804,-0.30761942,0.030934725),vec4(0.0072783804,-0.03352637,-0.039574414,0.11646549)) * bufB[5] + mat4(vec4(-0.014395519,0.33819655,0.5104979,-0.09439558),vec4(0.054681595,0.07643831,-0.07377777,-0.22536713),vec4(-0.15934262,0.17364424,-0.3622582,0.30945557),vec4(0.10624293,-0.01687353,0.11298123,-0.35386735)) * bufB[6] + mat4(vec4(-0.08627277,0.11781017,-0.29761466,-0.07257579),vec4(0.18872143,-0.04208001,0.056462422,-0.09167415),vec4(0.1031181,0.2900268,0.03819227,-0.14227961),vec4(-0.087914035,-0.14897329,0.27856418,0.07815257)) * bufB[7];\nbufA[3] = vec4(0.031553824,0.39816517,-0.045499228,-0.047925998) + mat4(vec4(0.119545385,0.13947287,-0.1775018,-0.044049975),vec4(0.110787295,3.9746898e-05,0.12257363,0.17837238),vec4(0.16276114,0.13452178,-0.093208306,0.16482885),vec4(-0.027288456,0.26056433,0.11305098,0.31704023)) * bufB[0] + mat4(vec4(-0.19819869,0.10713835,0.22512873,-0.10058218),vec4(0.08925121,-0.24502417,0.043990593,0.29849496),vec4(0.0393491,-0.26194087,0.38913506,-0.082799494),vec4(0.034323655,0.1098205,-0.3639223,0.3727796)) * bufB[1] + mat4(vec4(-0.058997072,-0.07517357,-0.17998676,0.048017416),vec4(-0.062455993,-0.068899594,0.049032975,0.0029638985),vec4(0.063415155,0.039331365,-0.052538905,0.085308656),vec4(0.030126348,0.043955375,-0.06828437,0.19519801)) * bufB[2] + mat4(vec4(0.11377189,0.053102735,-0.051833738,0.097258665),vec4(-0.24086688,-0.012162751,0.073384576,-0.020149829),vec4(0.19955786,0.2748417,0.13125722,-0.10643477),vec4(-0.1999988,0.33493704,0.08031487,0.08627437)) * bufB[3] + mat4(vec4(0.0727559,0.05477634,0.24897467,-0.2360891),vec4(0.1362621,0.13639864,-0.11223423,-0.06028089),vec4(0.05120704,0.04572134,0.16006531,-0.15114132),vec4(0.2926742,0.005409149,-0.0017128392,-0.17208184)) * bufB[4] + mat4(vec4(-0.257713,-0.1023777,0.47416928,-0.19229682),vec4(0.18909448,-0.020073581,0.05950728,-0.37421757),vec4(-0.29963857,-0.05977319,-0.034520853,0.21766494),vec4(-0.0074312086,-0.25735876,0.037522033,-0.04152509)) * bufB[5] + mat4(vec4(0.12823027,-0.10016599,-0.27751455,-0.23307312),vec4(0.15043892,-0.3198715,-0.26499885,0.38671976),vec4(0.27708578,0.06470566,0.26222667,0.016652426),vec4(0.1167519,0.21690883,0.14107256,0.3024904)) * bufB[6] + mat4(vec4(0.5748376,-0.2067332,0.0019674036,-0.009830031),vec4(0.09975654,-0.046163194,-0.30930355,0.05050305),vec4(0.12666781,0.3320562,-0.014986834,-0.12078481),vec4(0.34969512,-0.061464805,0.12422402,0.02304014)) * bufB[7];\ntmp = sin(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(0.07026067,-0.28475302,0.19975053,0.008220652) + mat4(vec4(0.28323296,-0.11721426,-0.05171784,-0.0017327542),vec4(-0.2794855,-0.39076558,-0.037575778,-0.11581995),vec4(-0.38667324,0.09559459,0.15305953,0.14265388),vec4(0.11914782,-0.03208786,0.18255986,0.01593591)) * bufB[0] + mat4(vec4(-0.1447506,-0.057754703,0.038142305,0.19140506),vec4(0.11616808,0.10482558,-0.0766989,0.12158459),vec4(-0.15488379,0.026700165,0.24235046,0.015165365),vec4(0.07903673,0.014365538,0.15472464,-0.026155101)) * bufB[1] + mat4(vec4(0.13527432,-0.13865438,0.0603871,0.21896966),vec4(0.02988954,0.040405866,0.0072492035,-0.13441753),vec4(0.11751483,0.13430262,-0.13691507,-0.19328399),vec4(-0.063247725,-0.12640779,0.03526889,-0.14674626)) * bufB[2] + mat4(vec4(-0.14311846,-0.29450753,-0.35964316,0.036067262),vec4(0.29169863,-0.25261787,-0.2264393,-0.14941555),vec4(-0.222173,-0.017529339,0.05975793,0.005813618),vec4(-0.023074351,-0.14792277,-0.07707333,-0.16289228)) * bufB[3] + mat4(vec4(-0.005554198,-0.1569268,-0.2741734,0.18407974),vec4(0.3259605,0.3850653,-0.3738984,-0.03390298),vec4(0.2712018,0.20444997,0.20646164,-0.16969544),vec4(0.1730133,0.0058632432,-0.1013848,0.068175375)) * bufB[4] + mat4(vec4(0.3393086,0.06152616,-0.1932077,-0.44440567),vec4(0.36382,0.114826955,-0.010308186,0.124467574),vec4(-0.2529273,-0.42494228,-0.35168502,0.21838877),vec4(0.12686025,0.033848934,0.4334406,-0.044598863)) * bufB[5] + mat4(vec4(0.2684147,0.04903154,0.04536046,0.065565705),vec4(0.013622524,-0.00965762,-0.1986015,0.25184336),vec4(-0.092109986,0.12225229,0.03713821,-0.082348906),vec4(0.14550918,0.12599643,-0.039978962,0.12341258)) * bufB[6] + mat4(vec4(-0.2098002,-0.21317673,0.06686484,0.0926595),vec4(-0.098458536,-0.10224815,-0.27846846,0.4123117),vec4(-0.113066286,0.2461739,0.05413401,0.16409239),vec4(0.13695334,0.14283891,0.18547294,0.0990722)) * bufB[7];\nbufA[1] = vec4(-0.2169151,-0.27405533,0.4528337,-0.16798486) + mat4(vec4(0.2410014,-0.07289833,0.0054998756,0.19908457),vec4(0.11972071,0.14286968,0.004071854,0.23675081),vec4(0.26880166,0.21980351,-0.014510637,-0.2008869),vec4(-0.23944841,0.008141002,-0.030891882,0.29192582)) * bufB[0] + mat4(vec4(0.019086756,-0.26291576,-0.2938033,0.068492115),vec4(0.25782144,-0.101124525,-0.022910072,-0.062329277),vec4(0.1603163,-0.07200535,-0.019506445,-0.069814235),vec4(-0.26546982,0.11391649,-0.2862,-0.052650746)) * bufB[1] + mat4(vec4(-0.26759627,0.23718852,-0.07534837,0.15964015),vec4(0.055056214,-0.14687353,0.54119265,0.057934873),vec4(-0.2506047,0.06405475,-0.31886953,-0.117034905),vec4(0.055799928,0.12974449,-0.36719298,-0.04442039)) * bufB[2] + mat4(vec4(0.14919941,-0.05291809,-0.0090219835,0.10473175),vec4(-0.20774683,-0.037425794,-0.08900274,-0.40456656),vec4(-0.013263511,0.26879665,-0.022000434,0.18481907),vec4(-0.1519519,0.048101474,-0.26611632,-0.16885222)) * bufB[3] + mat4(vec4(-0.2662977,0.043059677,0.17466322,0.17513587),vec4(-0.007190073,-0.33040848,-0.13655533,-0.022140773),vec4(-0.011445126,-0.25085613,-0.30990684,0.0725193),vec4(-0.013972558,0.20818245,0.1314769,-0.024429256)) * bufB[4] + mat4(vec4(0.076524295,0.11543374,0.13191462,-0.17157745),vec4(0.0063651497,-0.32345405,0.3846464,-0.20392881),vec4(0.052232362,-0.109371856,0.27560133,-0.21400593),vec4(-0.19090304,0.06454186,0.3117382,0.029785598)) * bufB[5] + mat4(vec4(-0.031970344,0.120114125,0.057141744,0.4799803),vec4(-0.49921435,0.115802996,0.33408174,0.32836387),vec4(0.07185959,-0.04346671,0.06779942,0.14801589),vec4(-0.19857304,0.24441543,0.25355828,0.19730733)) * bufB[6] + mat4(vec4(0.28694266,-0.11313078,0.060673513,0.3866265),vec4(0.023287531,0.021452889,-0.06837004,0.35828432),vec4(0.20716,-0.090563335,0.0045539388,0.24541388),vec4(0.2206457,0.23753248,0.1617662,0.27400574)) * bufB[7];\nbufA[2] = vec4(-0.48632097,0.42735985,0.13495025,0.41233432) + mat4(vec4(-0.056638516,-0.23889056,0.065016165,-0.12650426),vec4(0.29338217,0.120183446,-0.09080427,-0.12543026),vec4(0.086220704,0.058890853,0.08335499,-0.028937122),vec4(-0.1977701,0.040824898,0.18705599,0.009668142)) * bufB[0] + mat4(vec4(-0.09053417,0.11157064,-0.03767312,-0.23694202),vec4(-0.08232982,0.038719047,-0.22916421,-0.11664392),vec4(-0.0116827525,0.070577495,-0.28066897,-0.036636148),vec4(-0.11092683,-0.106201544,-0.23515804,-0.039173882)) * bufB[1] + mat4(vec4(0.16355877,0.068867065,-0.12703659,0.031039817),vec4(0.100974165,-0.28965318,0.100968644,-0.026785975),vec4(-0.3152567,-0.017620131,-0.08503992,-0.07995962),vec4(-0.33813268,0.0075830864,-0.014125364,0.21054293)) * bufB[2] + mat4(vec4(-0.036467317,0.16301271,0.075165495,0.41946757),vec4(-0.19886091,0.38656887,-0.001485542,0.1609911),vec4(-0.26669437,0.038821656,-0.09910452,0.20075867),vec4(0.07781926,0.25760186,0.08946548,-0.014803039)) * bufB[3] + mat4(vec4(0.07387956,-0.14217155,0.22553985,-0.020332528),vec4(0.031779997,0.11470913,0.07330069,-0.13615416),vec4(0.39001822,-0.026855486,0.5041183,0.27046305),vec4(-0.0059023355,-0.2559332,-0.045959823,0.14389908)) * bufB[4] + mat4(vec4(-0.115368165,0.1192326,-0.062214546,0.44219312),vec4(0.018142572,0.111348175,-0.36957318,0.37798816),vec4(0.21230806,-0.20400435,0.15302743,0.09675912),vec4(-0.062460072,-0.11181669,-0.041267052,0.055688452)) * bufB[5] + mat4(vec4(0.057589978,0.18427914,-0.12147788,0.16079082),vec4(-0.33312514,-0.121070385,-0.036401834,0.2519306),vec4(-0.28604963,-0.1302422,0.07988389,-0.33346048),vec4(-0.07452799,-0.039177176,-0.18486886,0.2546526)) * bufB[6] + mat4(vec4(0.39253646,0.1135851,0.11709697,-0.066304676),vec4(0.08158854,-0.2777424,-0.06173236,-0.034104552),vec4(-0.09709988,-0.11654039,0.21637231,0.25906515),vec4(-0.16651286,-0.22413836,0.0019595549,0.0055473372)) * bufB[7];\nbufA[3] = vec4(-0.34073567,-0.23316467,-0.37243804,0.08815071) + mat4(vec4(0.29783842,-0.28211877,0.102274336,-0.16565384),vec4(0.1487874,-0.20830616,-0.06594981,0.06867693),vec4(0.25700253,0.03978215,0.29537553,-0.17080794),vec4(-0.03572289,-0.22822127,0.0553393,-0.06952722)) * bufB[0] + mat4(vec4(0.035407215,0.45956796,-0.35327682,-0.004816728),vec4(0.18521525,-0.26784578,0.11694204,0.08061862),vec4(0.33804867,0.13013037,0.40385258,-0.104105696),vec4(0.097789474,0.1702123,-0.18785176,-0.21690832)) * bufB[1] + mat4(vec4(0.114784524,-0.2379462,0.03574868,-0.022544827),vec4(0.019557308,0.3224116,-0.039117683,-0.1406759),vec4(0.019634863,0.08296022,-0.30648085,0.090149656),vec4(-0.01718743,0.12083001,-0.3250836,0.03621228)) * bufB[2] + mat4(vec4(-0.2555743,0.07523948,0.056138497,-0.15802424),vec4(0.18416226,-0.27530596,0.09338188,-0.14788282),vec4(0.08861074,0.1905854,0.14115857,-0.09168397),vec4(-0.30594698,-0.058958504,0.032283187,-0.08174954)) * bufB[3] + mat4(vec4(0.2676054,0.18088895,0.2727381,-0.0381952),vec4(-0.22587234,0.16850282,-0.09627096,-0.16751358),vec4(0.18332905,0.15021971,0.20710823,0.028754933),vec4(0.015230716,-0.20200343,0.048711207,0.037462268)) * bufB[4] + mat4(vec4(-0.03148053,0.14298324,0.13760436,0.049381465),vec4(-0.31517613,0.2865385,-0.077284425,0.09293456),vec4(-0.21197681,-0.07715427,-0.090636246,-0.37306732),vec4(0.06487781,-0.03816916,0.06317043,-0.22513905)) * bufB[5] + mat4(vec4(0.08605206,0.06343561,-0.3570338,0.03948085),vec4(-0.395295,0.016339933,0.06556869,-0.004888446),vec4(0.13294965,-0.18411951,0.12770155,0.15344916),vec4(0.02272643,0.05880395,-0.22445638,0.31620818)) * bufB[6] + mat4(vec4(-0.08419831,0.36015323,-0.14405045,-0.51344347),vec4(0.07871742,0.20061815,0.043324586,0.10487949),vec4(-0.0015208034,0.28788882,0.010897458,-0.14657374),vec4(0.123172164,0.0057411715,-0.03773692,-0.024481295)) * bufB[7];\ntmp = sin(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(-0.056190673,-0.151903,0.26603028,0.32061917) + mat4(vec4(-0.090338625,0.19551967,-0.0026935833,-0.1344586),vec4(0.15372087,-0.17074388,0.31744125,-0.14004427),vec4(0.3190426,0.048416544,0.36685228,0.03234101),vec4(-0.15203255,0.0037291348,-0.06193811,0.00868387)) * bufB[0] + mat4(vec4(-0.04289281,0.123315506,0.065859415,0.19362925),vec4(0.28082162,-0.42100677,-0.31539735,0.006362496),vec4(0.0694591,0.067797065,0.21535645,-0.063008524),vec4(-0.0123834405,0.19327357,0.10847205,0.05553079)) * bufB[1] + mat4(vec4(-0.030956393,-0.10150562,0.35021853,-0.20193619),vec4(0.00839681,0.0113006765,0.05925874,0.15568063),vec4(-0.019005392,-0.41580695,-0.338799,-0.009658654),vec4(0.25196907,-0.13465975,0.031377994,-0.18699014)) * bufB[2] + mat4(vec4(0.01491023,0.2779025,-0.29170707,-0.0932146),vec4(0.0070731584,-0.0834466,0.2708835,-0.030703938),vec4(0.076503016,0.05384517,-0.1928276,0.07843442),vec4(0.018434623,0.2559253,0.23961397,0.33928737)) * bufB[3] + mat4(vec4(0.05244597,-0.01400917,-0.021195693,0.32111505),vec4(-0.1363324,-0.3159319,-0.021638129,-0.15391111),vec4(-0.20480531,-0.14014183,-0.13415535,0.09364145),vec4(-0.36413944,0.054655906,0.35207453,-0.6353254)) * bufB[4] + mat4(vec4(0.39111075,0.30307534,0.17384185,-0.007021733),vec4(-0.053130414,-0.24425831,-0.4348399,-0.24981987),vec4(-8.034373e-05,-0.0686213,0.115844175,-0.2550942),vec4(-0.07325936,0.0992743,-0.13377947,-0.07306128)) * bufB[5] + mat4(vec4(0.21712156,-0.17449734,-0.17752261,0.31076673),vec4(-0.006861354,0.043887928,0.6845058,-0.34503374),vec4(0.2373621,-0.1208544,0.04972148,-0.078038976),vec4(0.2392906,-0.21479204,-0.0073165544,0.013140603)) * bufB[6] + mat4(vec4(-0.10683105,-0.061527427,0.09646515,-0.23556115),vec4(0.20511223,-0.2170068,0.19642186,-0.099868216),vec4(-0.15104923,0.14609961,-0.20707627,-0.24561702),vec4(-0.022717636,0.0340867,-0.0902962,-0.1945725)) * bufB[7] + in0;\nbufA[1] = vec4(-0.37049767,0.13793397,-0.06914139,-0.40380785) + mat4(vec4(-0.014947828,-0.29856086,-0.19013572,-0.27604565),vec4(-0.037702166,0.016960502,0.0074070515,-0.22087593),vec4(-0.030642223,0.45934892,0.1690999,0.108382925),vec4(-0.09153397,-0.012165209,0.15740044,0.2676968)) * bufB[0] + mat4(vec4(-0.05005729,0.14628255,-0.034278285,0.057550643),vec4(0.03581999,-0.2558372,-0.022652678,0.20810835),vec4(-0.12690696,0.23218729,-0.15665545,-0.04077706),vec4(0.23283271,-0.01964636,0.16035043,0.30793473)) * bufB[1] + mat4(vec4(0.0787723,-0.14929292,0.23368497,-0.00017378727),vec4(0.22070009,-0.22049151,0.2313732,-0.10166982),vec4(-0.18682957,-0.23889357,-0.05988486,0.004131919),vec4(-0.0612348,-0.20637181,-0.13968618,0.03117762)) * bufB[2] + mat4(vec4(-0.06914841,-0.0026746648,0.05450483,0.04978197),vec4(0.032187533,-0.27178246,-0.031398457,-0.50812),vec4(-0.048542716,0.047462948,-0.09991617,0.16619323),vec4(-0.013955242,-0.19694605,0.1961116,-0.021485873)) * bufB[3] + mat4(vec4(0.3772003,0.040601213,0.049902033,-0.25217497),vec4(-0.22214733,0.23728494,0.061974995,-0.20349729),vec4(0.19462764,-0.056380976,-0.19205217,0.08834565),vec4(0.13797253,-0.40012458,-0.18439813,-0.40165523)) * bufB[4] + mat4(vec4(-0.39523223,-0.027208978,0.052147362,0.19727707),vec4(0.034434315,-0.09495034,-0.3834777,-0.012870662),vec4(-0.23460442,-0.0909122,0.23177996,-0.09238611),vec4(0.100870945,-0.48637438,0.109640725,0.16956098)) * bufB[5] + mat4(vec4(-0.27367127,-0.08038491,0.044765268,-0.11595867),vec4(0.07509178,-0.08458637,-0.057069216,-0.17043045),vec4(0.09338572,0.16596486,0.036788896,0.11902055),vec4(-0.15264522,-0.17184515,-0.2750417,0.17268701)) * bufB[6] + mat4(vec4(0.17917947,0.3150526,-0.43385148,-0.023020875),vec4(0.2040048,-0.28558657,-0.25405505,-0.05309683),vec4(-0.06416596,-0.04102182,-0.21180922,0.0316741),vec4(0.054491207,-0.2549085,-0.054022606,-0.1905541)) * bufB[7] + in1;\nbufA[2] = vec4(-0.36045724,0.27553675,-0.33512855,-0.27646765) + mat4(vec4(-0.1491884,0.075915605,0.21141602,-0.26765585),vec4(0.013141694,-0.12950508,0.46254325,0.05669679),vec4(0.029381873,0.0964782,0.03392676,0.0041837706),vec4(-0.06959483,0.095713764,-0.0366601,-0.09983573)) * bufB[0] + mat4(vec4(-0.12284696,-0.057539344,0.3153475,-0.11108534),vec4(0.12673852,0.12797819,0.06926326,0.28046414),vec4(-0.08458179,0.27975503,-0.06439267,0.1884096),vec4(0.17104788,-0.057306617,-0.2763153,-0.1815695)) * bufB[1] + mat4(vec4(-0.047873594,0.07680224,0.2254385,0.18793164),vec4(0.250389,0.011116334,-0.25819734,0.030259732),vec4(-0.16479687,-0.0908302,-0.005817768,0.36652157),vec4(-0.0034767145,0.026338167,-0.010362191,-0.2237439)) * bufB[2] + mat4(vec4(0.0139940325,-0.17374793,-0.18657206,0.08149236),vec4(0.2895929,-0.06505049,-0.105148666,-0.3064957),vec4(-0.10941903,-0.13181402,0.11524921,0.08346536),vec4(0.1501511,-0.01067808,-0.38633218,0.0038995754)) * bufB[3] + mat4(vec4(0.07871506,-0.34524357,-0.18644759,-0.28668058),vec4(-0.23249243,-0.24546008,-0.14810821,-0.15871869),vec4(0.13647863,-0.1478381,0.12694232,0.062704764),vec4(-0.20250897,0.15469986,-0.12826644,0.33838335)) * bufB[4] + mat4(vec4(0.0012674471,0.15674111,-0.016319312,-0.060425825),vec4(0.14155109,-0.030837331,-0.3286765,0.011969997),vec4(-0.1132449,-0.35261992,-0.26409575,0.048664786),vec4(0.17125106,0.11951407,0.32479396,-0.13262689)) * bufB[5] + mat4(vec4(0.43340176,0.025138346,0.0718438,-0.35193977),vec4(0.20019992,0.16407843,-0.035360586,-0.14571905),vec4(-0.5993629,-0.0033651858,-0.24715838,-0.28286335),vec4(0.0037891292,0.12414463,-0.3577858,-0.29063758)) * bufB[6] + mat4(vec4(0.30136025,-0.23532681,0.22155,0.03449386),vec4(-0.03222295,-0.3118358,0.17515074,-0.09086117),vec4(0.07075385,-0.029393071,-0.0022357341,0.23654737),vec4(-0.15663305,-0.18304221,-0.1512077,0.14854172)) * bufB[7] + in2;\nbufA[3] = vec4(-0.45879593,0.5757243,0.2590131,-0.43001178) + mat4(vec4(0.065348454,-0.3048781,-0.30996615,0.20323972),vec4(-0.11817524,0.32451543,0.062229976,0.06638065),vec4(0.19459748,-0.023908246,0.15523271,-0.14826433),vec4(0.006457455,0.30943623,-0.37523592,-0.17586888)) * bufB[0] + mat4(vec4(-0.004300191,0.34210423,0.17611669,0.18847969),vec4(-0.21057098,-0.2697467,0.15187944,0.040153265),vec4(0.26101714,-0.3197459,-0.03975131,-0.32902193),vec4(-0.14655155,-0.16153206,0.21168639,0.09359015)) * bufB[1] + mat4(vec4(-0.11580113,0.17410432,0.2305712,0.22008377),vec4(-0.05972646,0.18052173,0.1493112,0.058349457),vec4(-0.1079141,-0.14004122,-0.14504667,-0.30149934),vec4(-0.093388654,0.1605077,-0.16666707,0.037400708)) * bufB[2] + mat4(vec4(-0.11525211,0.15535055,0.2980361,0.06573787),vec4(-0.23643199,0.18724711,-0.15701184,-0.18871853),vec4(-0.024913453,-0.026429188,0.28393394,-0.08427071),vec4(0.16499089,-0.4563467,-0.016409906,-0.3276288)) * bufB[3] + mat4(vec4(-0.29812878,-0.14847209,0.116578616,0.20120789),vec4(-0.06685113,0.14249384,-0.0006473885,-0.013957498),vec4(0.31324565,-0.14893682,-0.058915555,-0.062620044),vec4(0.16820794,-0.004156469,0.13098828,-0.16067553)) * bufB[4] + mat4(vec4(-0.46033633,0.010462021,0.16013962,0.12234817),vec4(0.28699797,-0.025263995,-0.0476415,-0.10321965),vec4(0.17702928,-0.21607259,-0.13626122,-0.025755202),vec4(-0.061743382,0.01636224,0.025903562,-0.28291246)) * bufB[5] + mat4(vec4(0.049256932,-0.03229615,-0.66932803,-0.15725268),vec4(-0.38471234,0.0652649,0.12133856,-0.056309927),vec4(0.031219665,-0.038457982,-0.08800397,0.24167033),vec4(0.05349993,0.115516834,0.11383837,0.2192903)) * bufB[6] + mat4(vec4(-0.10832865,-0.2575902,0.08735689,-0.5736016),vec4(0.14321336,-0.14286086,-0.07782766,-0.16196324),vec4(-0.014528414,0.18128921,-0.060514823,-0.33645082),vec4(-0.040731218,0.14206247,-0.3075154,0.22642675)) * bufB[7] + in3;\ntmp = sin(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(-0.38081846,0.2183214,-0.34133837,0.23267806) + mat4(vec4(-0.19600496,0.4313666,-0.17679761,0.45834473),vec4(0.18859473,-0.11160662,0.08216282,0.08393926),vec4(0.14565076,-0.086054236,0.12896103,0.13598292),vec4(0.29456764,-0.21624629,-0.28346345,0.39809975)) * bufB[0] + mat4(vec4(0.15624724,-0.24299644,0.30855358,-0.44981343),vec4(-0.11392182,0.08126363,-0.00061214383,0.14149453),vec4(0.09100183,0.020862821,0.19051298,-0.31313047),vec4(0.16146058,-0.018194743,-0.1824013,-0.27464992)) * bufB[1] + mat4(vec4(0.030704578,-0.5326489,-0.039243408,-0.08919561),vec4(0.14742287,0.3926456,-0.3524132,0.31623328),vec4(-0.0014678342,-0.068849266,-0.11351669,-0.22950932),vec4(0.45503554,0.21786067,0.024527451,0.05183447)) * bufB[2] + mat4(vec4(-0.26809284,-0.031525753,0.22221734,-0.10053458),vec4(-0.11079534,-0.025065796,0.034752652,-0.14844312),vec4(0.1156745,0.27789184,-0.0049339114,0.016490823),vec4(-0.080426514,-0.026639242,0.017584112,0.06268479)) * bufB[3] + mat4(vec4(0.40502155,0.13683574,-0.16966225,-0.2661726),vec4(0.2319957,-0.18829422,0.014782045,-0.02323454),vec4(-0.0856483,0.16115026,0.12620614,0.14409658),vec4(0.20837848,-0.0074264994,-0.23824488,-0.004799486)) * bufB[4] + mat4(vec4(-0.4483405,0.03223559,0.058931526,0.014533215),vec4(0.01488269,0.055459715,0.22397156,0.034416914),vec4(0.05783947,0.29771256,0.25361517,-0.077271596),vec4(-0.10524739,0.008208927,-0.017526623,0.019162204)) * bufB[5] + mat4(vec4(-0.074331835,-0.38528016,0.34011424,-0.31238547),vec4(0.34831792,-0.13951953,-0.3952036,0.20933835),vec4(-0.22843674,-0.10769131,-0.075718366,0.4233496),vec4(-0.02235043,0.25567082,0.1775001,-0.1942927)) * bufB[6] + mat4(vec4(0.09040011,0.15023258,0.049750425,0.21679704),vec4(-0.07407568,0.23849685,0.17391992,0.0004325285),vec4(0.020129414,0.008658444,0.0010370912,0.2347109),vec4(-0.03672814,-0.29083097,-0.3164271,0.049955826)) * bufB[7];\nbufA[1] = vec4(-0.37149513,0.4096643,-0.2033876,-0.3367047) + mat4(vec4(0.10625876,-0.27754802,-0.23502931,0.08176142),vec4(-0.18000293,0.05698881,-0.0001380312,0.11386033),vec4(-0.1825749,-0.22458813,0.41704234,-0.19797646),vec4(0.18372653,0.13359167,0.21274062,0.18065457)) * bufB[0] + mat4(vec4(-0.07112814,-0.1325057,-0.2562195,-0.07575879),vec4(-0.15973277,0.11211806,0.047266066,-0.07863455),vec4(-0.2329912,-0.11840279,0.07731244,-0.30113444),vec4(-0.031479727,0.38860577,-0.0043628225,-0.2228106)) * bufB[1] + mat4(vec4(-0.03454646,0.14487164,-0.15545617,-0.04303009),vec4(-0.027372327,0.136287,0.36413515,0.1708979),vec4(-0.0045760493,0.02990085,0.26791358,0.17007583),vec4(0.35974434,0.28314146,0.116446,0.08991401)) * bufB[2] + mat4(vec4(-0.13121708,0.038817696,0.2519521,-0.20787337),vec4(-0.015855497,-0.13897897,-0.14749451,0.17199393),vec4(0.0073983087,0.10406206,-0.18019107,0.020508017),vec4(-0.14160785,-0.1140975,0.017638804,-0.35517544)) * bufB[3] + mat4(vec4(-0.13389334,-0.121479005,0.025350643,-0.3209256),vec4(0.050612908,0.13938071,-0.10912737,-0.068358794),vec4(-0.2938216,-0.4526065,-0.25561208,0.016631275),vec4(0.10979971,0.2616958,-0.13152649,-0.09042576)) * bufB[4] + mat4(vec4(-0.3054222,-0.05056329,-0.072303,0.077443235),vec4(-0.3457475,0.038166706,-0.26532084,0.019548357),vec4(0.005056434,-0.094227694,-0.23465568,-0.009134615),vec4(0.041727606,-0.19201845,-0.21226108,0.43278193)) * bufB[5] + mat4(vec4(0.015599218,0.27548334,0.4722531,0.1911654),vec4(0.17331153,-0.3277455,-0.11138864,0.029232856),vec4(0.2815654,0.25716347,-0.078103006,-0.20683248),vec4(-0.49200112,0.015559826,0.23654668,-0.15234213)) * bufB[6] + mat4(vec4(0.03341157,-0.2543377,0.3390703,0.102751546),vec4(-0.15122679,-0.10364765,-0.13464342,-0.09426038),vec4(0.44678196,0.04774713,-0.13607313,0.08965183),vec4(-0.1997112,-0.016094849,-0.28132635,0.044274315)) * bufB[7];\nbufA[2] = vec4(-0.046036813,-0.5140887,-0.49532586,0.14662854) + mat4(vec4(0.36289588,0.08416974,-0.14762978,-0.027805518),vec4(0.06132501,-0.019080088,0.18715319,-0.2551409),vec4(0.07549313,-0.1773216,-0.1782901,-0.062095366),vec4(-0.33515286,0.21363021,0.045033235,-0.21064955)) * bufB[0] + mat4(vec4(-0.082663745,-0.042251907,0.09075651,-0.060224257),vec4(0.05742778,0.19959979,0.24807866,-0.29134527),vec4(0.08127847,0.5014297,-0.16638829,-0.28751895),vec4(0.03723433,-0.20266184,0.18675195,-0.06745641)) * bufB[1] + mat4(vec4(-0.17982945,-0.19851094,-0.19258386,0.17378289),vec4(-0.2651454,0.07841331,-0.119849645,0.08093566),vec4(0.19955519,-0.19985025,0.2306688,-0.41504595),vec4(0.022144157,-0.06100806,-0.1355326,0.17584437)) * bufB[2] + mat4(vec4(0.19529416,0.416257,-0.10140175,0.09054505),vec4(0.12703101,0.19134845,0.20762393,0.08924366),vec4(-0.17815083,0.4144099,0.1789292,-0.17357317),vec4(0.27123633,-0.03440217,0.17047723,-0.21848671)) * bufB[3] + mat4(vec4(-0.079303645,0.16813438,0.10467451,-0.03545988),vec4(0.18172204,-0.03134302,-0.2140977,-0.28658733),vec4(0.096901245,0.035871487,0.105800666,0.2698579),vec4(0.165487,-0.26617157,0.24429776,0.086742446)) * bufB[4] + mat4(vec4(0.08634848,0.31037718,0.2106445,-0.1765215),vec4(-0.17451178,-0.20470905,-0.15248859,0.10030964),vec4(0.013802637,0.0026287793,0.06163079,0.061263554),vec4(-0.12882507,-0.015139121,-0.087584384,-0.28160778)) * bufB[5] + mat4(vec4(0.044646334,0.029754823,-0.08981211,0.07867578),vec4(0.17439923,0.025774872,0.18416135,0.08375258),vec4(-0.25828674,0.14503463,0.19845311,0.3524178),vec4(0.025474535,-0.13705386,0.008233319,-0.12564899)) * bufB[6] + mat4(vec4(-0.04533381,-0.1453424,-0.09462583,0.24651268),vec4(0.0007772917,-0.09873579,-0.33899355,-0.17873341),vec4(-0.12915897,-0.30693507,-0.42450994,-0.09144934),vec4(0.15836623,0.1935036,-0.17343017,0.2111684)) * bufB[7];\nbufA[3] = vec4(-0.5433677,0.2888001,-0.18754487,-0.07497233) + mat4(vec4(0.18591456,0.08893624,0.01367504,-0.0065072915),vec4(0.11336165,-0.06512368,0.15902704,-0.113809384),vec4(-0.03440084,-0.13209513,-0.2085671,-0.19203033),vec4(0.25920558,0.035616536,-0.15570058,0.049573917)) * bufB[0] + mat4(vec4(0.057759177,0.039165344,-0.2007959,-0.05697996),vec4(-0.10637988,-0.15471892,-0.04750641,-0.077158146),vec4(-0.12619917,0.04911898,-0.009076366,0.0874342),vec4(0.31157875,0.41346344,0.13095379,0.014882013)) * bufB[1] + mat4(vec4(0.10701829,-0.47782436,0.24262385,0.10222844),vec4(-0.6118332,0.15508163,0.34571484,-0.10528425),vec4(0.18782182,0.13713425,0.2246131,0.20188348),vec4(-0.1570271,-0.04226532,-0.04537864,0.121777885)) * bufB[2] + mat4(vec4(0.13295452,0.29358396,0.15095305,0.2563214),vec4(-0.31986067,0.09611299,0.038478643,0.10064209),vec4(-0.252236,0.029781973,0.21000972,-0.065132335),vec4(0.053157035,-0.20087963,0.10936373,-0.13412216)) * bufB[3] + mat4(vec4(0.32420638,0.1841265,-0.6578957,-0.004009926),vec4(-0.09930639,-0.16021429,-0.08348348,0.50157976),vec4(-0.031440467,-0.259578,-0.4512844,-0.0062876185),vec4(0.11296801,0.3006522,0.2145621,-0.33936018)) * bufB[4] + mat4(vec4(-0.10993227,-0.042348,0.036841676,-0.0841943),vec4(-0.096309006,-0.06030447,-0.025419999,0.23780034),vec4(-0.092431575,-0.070188,0.11267175,-0.052082516),vec4(0.12488856,-0.12270761,0.28229326,0.2407662)) * bufB[5] + mat4(vec4(0.171511,0.005913254,0.02781091,-0.1522124),vec4(-0.29619977,0.114166595,0.012925977,0.03234268),vec4(0.21686062,-0.11127649,0.05589901,-0.2012004),vec4(-0.42745593,0.071374886,0.10443497,0.3092421)) * bufB[6] + mat4(vec4(-0.09387692,0.15890835,-0.4728912,0.4311988),vec4(0.21123004,0.02750716,0.4149872,-0.063729405),vec4(-0.08611875,-0.27098665,-0.10805473,0.24066842),vec4(0.10648562,-0.573742,0.13570964,-0.0757202)) * bufB[7];\ntmp = sin(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(0.19305597,0.1981928,-0.36741707,0.03680618) + mat4(vec4(-0.023494843,0.13759331,-0.119660795,0.029634936),vec4(0.1496659,0.20180172,-0.49300605,0.16803804),vec4(-0.23827313,0.33217648,-0.12979499,0.028760498),vec4(0.06457751,0.06127245,0.28580812,0.3099377)) * bufB[0] + mat4(vec4(0.02734414,0.3649372,0.25843102,0.0054327487),vec4(-0.05296549,0.12052816,0.31944215,0.028561257),vec4(0.18818419,-0.019328332,0.094943516,0.10619204),vec4(0.23564236,0.2835446,0.099334255,0.17381059)) * bufB[1] + mat4(vec4(-0.09091516,0.39664996,0.3385452,0.1306695),vec4(-0.25540048,0.13326468,0.2518169,0.20992236),vec4(-0.0010746109,-0.3530087,0.4021309,0.1614933),vec4(-0.38812065,-0.47752833,0.123794585,0.12691987)) * bufB[2] + mat4(vec4(-0.2617192,0.21551229,-0.18357946,-0.41850787),vec4(0.33403933,-0.03613223,-0.14922741,0.17543091),vec4(-0.15017593,-0.24780554,-0.07707581,-0.15441751),vec4(0.34578148,-0.09023933,0.0531755,-0.13741922)) * bufB[3] + mat4(vec4(-0.11931497,0.10940248,0.31978524,-0.15687938),vec4(0.03724951,0.2589528,-0.042450335,0.23017758),vec4(0.069140784,0.027997147,-0.35419574,0.22654803),vec4(0.092479005,0.16225183,-0.26244965,-0.09168056)) * bufB[4] + mat4(vec4(0.2552419,0.14970739,-0.41309938,0.058510717),vec4(-0.11122991,0.1155832,-0.32161358,0.42660385),vec4(0.07779818,0.15869612,-0.029021636,0.048025347),vec4(-0.21852145,0.0309483,-0.17486952,-0.18354529)) * bufB[5] + mat4(vec4(0.30689466,0.06412919,0.045046996,-0.14928138),vec4(0.121090405,0.12155069,-0.34046537,-0.09805691),vec4(0.18028319,0.24285996,-0.12010258,0.22157721),vec4(0.21999143,-0.012772296,0.105562165,-0.13970882)) * bufB[6] + mat4(vec4(0.13533859,0.2377328,-0.1915382,-0.11387265),vec4(-0.12514405,-0.12300956,-0.06310729,-0.19389777),vec4(0.27627593,0.08160675,-0.13358065,0.18016118),vec4(-0.32816646,0.006308156,0.20952143,-0.026278136)) * bufB[7];\nbufA[1] = vec4(-0.14277044,0.46946988,0.3309917,-0.40446147) + mat4(vec4(-0.1933882,-0.1401149,-0.11865698,-0.1186879),vec4(-0.3077636,-0.043562245,-0.113469474,-0.0435215),vec4(0.17046832,-0.5973443,-0.086739115,-0.07585898),vec4(-0.3433758,0.222751,0.27066982,0.33215472)) * bufB[0] + mat4(vec4(-0.3613592,0.12953626,-0.13573349,-0.0052294154),vec4(0.21454437,-0.07791268,-0.28531548,0.41352284),vec4(-0.25613418,0.17119259,-0.06636439,-0.07313676),vec4(0.09058721,-0.33875197,0.3291173,-0.28414148)) * bufB[1] + mat4(vec4(0.078241475,-0.03590333,-0.12907644,-0.06306557),vec4(-0.21658924,0.15557267,0.12302585,-0.03299988),vec4(0.0076697995,-0.035275772,-0.22146803,-0.28178436),vec4(0.30237436,-0.023877518,-0.09127971,-0.21894579)) * bufB[2] + mat4(vec4(-0.5427002,-0.15213786,-0.2511362,-0.38753977),vec4(-0.04800801,0.15559383,-0.014260967,-0.014535078),vec4(0.33096433,-0.27271327,0.19156069,0.4293024),vec4(0.072928615,-0.1824679,0.045854665,0.077791914)) * bufB[3] + mat4(vec4(-0.11766656,0.27886304,0.08089733,0.22367492),vec4(0.09527507,-0.11206951,-0.26827475,0.37705833),vec4(-0.42039755,-0.2759436,-0.20066497,-0.28740662),vec4(-0.075981356,0.10916903,0.22446342,-0.1502132)) * bufB[4] + mat4(vec4(-0.120417014,-0.0126633365,-0.15970789,-0.07410321),vec4(0.2408586,-0.16043824,0.2775983,0.10415205),vec4(-0.100970194,0.042013504,0.38035733,-0.49344096),vec4(-0.102056794,-0.3524373,0.30443382,-0.128266)) * bufB[5] + mat4(vec4(0.16392659,0.122652054,-0.054613367,-0.13287604),vec4(0.44686946,0.012675939,-0.09954027,-0.11930252),vec4(-0.070662044,0.30723223,-0.36741203,-0.017264867),vec4(-0.15048932,-0.04497192,0.0771745,0.07792491)) * bufB[6] + mat4(vec4(-0.058989987,0.1406719,0.1798704,-0.07253346),vec4(0.5559099,0.11798656,-0.30920506,0.22327562),vec4(-0.04644552,-0.28174868,-0.16463405,0.22992088),vec4(-0.49005795,-0.24194673,-0.09442841,0.23276074)) * bufB[7];\nbufA[2] = vec4(-0.19544841,0.054830372,0.0536334,0.4893942) + mat4(vec4(-0.011527728,-0.036467995,0.051762294,0.03415779),vec4(0.4524748,0.1631346,0.06567555,-0.058515254),vec4(0.35134253,0.58749765,-0.17904565,0.1491113),vec4(-0.18529156,0.12952055,-0.057734903,0.1268071)) * bufB[0] + mat4(vec4(0.05404315,0.030686812,0.14498186,0.32580125),vec4(0.10680942,0.09358978,-0.050673418,-0.1664148),vec4(-0.18008503,-0.106670626,-0.25729963,-0.09711735),vec4(0.22844571,-0.039390154,-0.024170738,-0.16356225)) * bufB[1] + mat4(vec4(-0.23476559,0.026518751,-0.1096105,-0.2619247),vec4(-0.07894228,0.26923597,-0.22156468,-0.2260029),vec4(-0.04258758,-0.09462228,-0.22099604,0.28443676),vec4(0.11853888,-0.37809962,0.09435605,-0.14301501)) * bufB[2] + mat4(vec4(0.19716588,0.072839744,-0.083679445,-0.07693924),vec4(-0.09686386,-0.18235993,0.0493035,0.052920476),vec4(-0.13698938,0.041312832,0.063114986,-0.12382064),vec4(-0.29740283,0.2600394,0.44551373,0.1544393)) * bufB[3] + mat4(vec4(-0.21658915,-0.27604032,-0.19073644,0.1002327),vec4(0.19418643,0.15043269,0.20358677,0.018403705),vec4(-0.22550218,0.20118433,-0.026731137,-0.23986632),vec4(0.11139452,-0.10877628,0.008374165,0.05128041)) * bufB[4] + mat4(vec4(-0.049271144,0.20126572,-0.35818797,-0.22256346),vec4(0.24908617,0.13843411,0.033210192,-0.14456232),vec4(-0.384487,0.06510741,0.3580327,-0.26753098),vec4(-0.37262723,-0.26667115,0.092651755,-0.15717748)) * bufB[5] + mat4(vec4(-0.020343622,0.04283412,0.13147971,-0.24561277),vec4(0.10619388,0.39454103,-0.089067176,0.13428016),vec4(-0.2741719,-0.1742875,-0.10690084,0.0023212023),vec4(0.022357112,-0.08749306,-0.019352144,-0.22952506)) * bufB[6] + mat4(vec4(-0.05517667,-0.19265968,-0.37834832,0.000855524),vec4(-0.10054307,-0.17697708,0.3546657,0.07508453),vec4(-0.06879938,0.104402736,0.08495242,0.06442901),vec4(-0.14704272,0.13387461,0.4265879,-0.37288103)) * bufB[7];\nbufA[3] = vec4(0.48068824,0.18850276,0.10936783,0.28303772) + mat4(vec4(0.10550686,0.033758614,0.5238994,-0.14709556),vec4(0.044947397,0.18390144,0.13128996,-0.009832646),vec4(0.0006981536,-0.18598102,-0.17807479,0.16895252),vec4(0.104577966,0.15198086,-0.05957637,0.5043912)) * bufB[0] + mat4(vec4(0.06573468,0.038032923,-0.08240462,0.06691987),vec4(-0.15850614,0.21268456,0.060507793,0.26950976),vec4(-0.30388913,-0.0066752858,0.10868339,0.093820274),vec4(-0.10708619,-0.05076916,-0.41929686,0.09210807)) * bufB[1] + mat4(vec4(-0.29629928,-0.18995588,0.35168326,-0.08374444),vec4(-0.2822827,0.2868211,0.08771271,-0.12869152),vec4(-0.17152154,0.15979774,-0.007822112,0.0700234),vec4(-0.114546426,0.036917023,-0.0072315363,0.12475065)) * bufB[2] + mat4(vec4(0.052582532,-0.40898195,-0.08305207,0.13305046),vec4(-0.37675357,-0.17802747,0.2701079,0.37585813),vec4(-0.10644656,0.29978547,-0.42653406,-0.06720433),vec4(0.44781262,0.03920983,0.1026578,-0.045785688)) * bufB[3] + mat4(vec4(-0.24961558,0.22646587,-0.19997266,-0.0433816),vec4(-0.41298535,-0.22189699,0.20542175,-0.43335822),vec4(0.0023429156,0.09459726,0.005152505,0.11321402),vec4(0.29866046,0.0331686,0.08175798,0.12170476)) * bufB[4] + mat4(vec4(0.13929461,-0.16151974,-0.18437769,0.06688911),vec4(0.02941975,0.49308178,0.023893833,0.19207494),vec4(-0.10821265,-0.1848323,0.10714102,0.18240494),vec4(-0.14646253,-0.20711936,-0.04517351,-0.12898564)) * bufB[5] + mat4(vec4(-0.22237709,-0.09227907,-0.41008687,-0.41122374),vec4(0.10735323,-0.34922376,0.33093622,0.12068339),vec4(-0.37216684,0.18177736,0.043227296,0.27600196),vec4(0.34013498,0.031627808,0.2966296,0.2896172)) * bufB[6] + mat4(vec4(0.047011815,0.039597068,-0.02154183,-0.055614352),vec4(-0.055261742,-0.1425749,-0.28503832,-0.032640286),vec4(-0.16620916,-0.22287174,0.43580297,0.113014735),vec4(0.15134647,0.08926022,0.10957531,-0.22378343)) * bufB[7];\ntmp = sin(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(0.3005483,0.22730806,0.37373677,-0.028790768) + mat4(vec4(0.07637481,0.2474065,0.001766563,0.1981522),vec4(-0.17362694,0.11698616,0.4116418,-0.0074186763),vec4(0.29171634,-0.24311857,0.11453935,0.14199778),vec4(0.30272347,-0.0014435921,-0.3308559,0.32161787)) * bufB[0] + mat4(vec4(-0.16054013,0.44922966,-0.089746915,0.023558233),vec4(-0.00068621,-0.0402824,0.12741198,-0.24550065),vec4(-0.103563584,-0.39398426,-0.1059483,-0.09382109),vec4(-0.17283428,-0.32217044,0.07674769,0.21630208)) * bufB[1] + mat4(vec4(0.09333174,0.02783648,-0.21730319,0.0067781126),vec4(0.12519315,0.009202246,0.08693947,-0.09719183),vec4(0.015626973,-0.096330404,0.1218933,-0.1242377),vec4(-0.11735048,-0.13570373,0.016110837,0.06449554)) * bufB[2] + mat4(vec4(-0.56777316,0.030592002,-0.5335025,0.12155377),vec4(0.15684249,0.0710859,0.37495387,0.2613919),vec4(-0.10250056,0.36171502,0.31603757,-0.025886185),vec4(-0.22810712,0.3092338,-0.11896072,-0.034147955)) * bufB[3] + mat4(vec4(0.104738586,0.14161953,0.12829144,0.3837818),vec4(0.24808384,0.060485434,-0.15120876,-0.42960328),vec4(-0.016353752,-0.10103084,-0.04082065,0.040121056),vec4(0.22831605,-0.10188162,-0.37979364,-0.13839665)) * bufB[4] + mat4(vec4(0.0956077,-0.12045048,-0.21538834,0.27853712),vec4(0.31379503,0.2409887,0.11169868,-0.10333276),vec4(-0.06135409,0.31139386,0.0200564,-0.13560563),vec4(-0.0029517529,0.24734437,0.11175469,0.08274818)) * bufB[5] + mat4(vec4(-0.19457369,-0.21311192,0.17299794,0.3703988),vec4(0.1331214,-0.062872216,0.1503831,-0.30313364),vec4(-0.11057325,-0.3365,0.14795068,0.009742349),vec4(-0.00558396,0.022928985,-0.07630218,0.18289286)) * bufB[6] + mat4(vec4(-0.14623825,0.26719078,0.17224452,-0.22249874),vec4(0.282581,0.39300945,-0.07747278,0.20931275),vec4(-0.11299343,0.09557491,-0.36055902,-0.057432905),vec4(0.24927156,0.4931018,-0.16277373,-0.409711)) * bufB[7];\nbufA[1] = vec4(0.20147236,0.13537517,-0.40073204,0.08165233) + mat4(vec4(-0.23017624,0.25204727,-0.24871466,-0.10796842),vec4(0.019249719,0.058533665,0.24203038,0.25056055),vec4(0.009047171,0.3303889,0.24855739,0.084970854),vec4(-0.030230692,-0.25033617,-0.054342903,0.42342988)) * bufB[0] + mat4(vec4(0.18124233,-0.15376645,-0.20583114,0.044826716),vec4(-0.33402824,0.15474291,-0.07262248,0.12688188),vec4(-0.41741624,-0.087735556,-0.11510642,-0.46492344),vec4(0.15633462,-0.37194413,0.1742366,0.27128106)) * bufB[1] + mat4(vec4(-0.009611647,-0.4239054,0.052757077,0.037257057),vec4(0.28591755,-0.10588631,-0.33020714,0.12461611),vec4(-0.35703662,-0.26347795,-0.024356214,-0.25433838),vec4(0.19401595,0.047193997,-0.10307138,0.04004458)) * bufB[2] + mat4(vec4(-0.1735377,-0.05645041,-0.4315517,-0.0041489224),vec4(0.3723944,0.07548275,0.05614173,0.060104616),vec4(-0.16058362,0.3189757,-0.034084637,0.14684503),vec4(-0.46457896,-0.18421796,-0.17420585,-0.0665099)) * bufB[3] + mat4(vec4(-0.045941453,-0.16278774,-0.072561525,0.045939136),vec4(0.26144066,0.09167969,0.27483362,0.5416211),vec4(0.09773464,0.015363794,-0.01461095,0.13108492),vec4(0.12682621,-0.005021885,0.25687775,-0.33432353)) * bufB[4] + mat4(vec4(-0.25730592,0.26876524,0.109549105,0.14363275),vec4(-0.59288406,0.3323069,0.24151008,-0.11792455),vec4(0.30297253,0.21441457,-0.33347154,-0.09935896),vec4(0.59018326,-0.42753693,-0.24006903,0.2079669)) * bufB[5] + mat4(vec4(0.31142068,0.07285852,0.07497171,-0.042831887),vec4(-0.19109099,0.21473172,-0.0085123,-0.04119333),vec4(0.051714636,0.24623853,-0.03483202,-0.10744446),vec4(-0.15155497,0.050336715,0.09751137,-0.25577775)) * bufB[6] + mat4(vec4(-0.52653795,-0.11972856,0.41000894,-0.1773759),vec4(0.2499243,0.29273713,-0.5730445,-0.13036154),vec4(-0.1955454,-0.1291185,-0.48323613,-0.014565698),vec4(0.17975555,-0.24496062,0.4178024,-0.0070473766)) * bufB[7];\nbufA[2] = vec4(0.57344985,-0.39377713,0.31196302,0.079411924) + mat4(vec4(-0.14360172,-0.16701978,0.17079124,-0.14533435),vec4(0.3633582,0.092572376,-0.10543258,0.3625298),vec4(-0.5022048,-0.022099184,0.069226116,0.07280215),vec4(-0.115163386,0.2673803,-0.09523827,0.21844143)) * bufB[0] + mat4(vec4(-0.05527164,-0.26699224,-0.15876922,0.53646874),vec4(0.0042358357,-0.13101666,-0.15778157,-0.06554707),vec4(-0.07538847,-0.03097159,0.0060405834,0.29369855),vec4(0.15330613,-0.1473752,0.19402991,0.15586372)) * bufB[1] + mat4(vec4(-0.14435178,-0.3000623,-0.054803815,0.4294613),vec4(-0.25225085,0.005878942,0.052677866,-0.007808624),vec4(0.12013279,-0.17909361,-0.11839573,0.15461658),vec4(0.13291468,-0.09099811,-0.115633644,-0.09845809)) * bufB[2] + mat4(vec4(0.31675854,0.09657601,-0.18657455,-0.101434164),vec4(-0.18602926,0.14882512,-0.15169798,0.3955067),vec4(0.03414773,0.18847372,0.18243693,0.1782647),vec4(0.0972051,0.033581726,0.051068146,0.093203045)) * bufB[3] + mat4(vec4(0.11105682,-0.18357123,0.4122119,-0.13912602),vec4(0.29994616,-0.33127716,-0.15501301,-0.39707297),vec4(0.37188736,0.06489483,0.15076272,0.17644782),vec4(0.088199876,0.14233056,-0.1657916,0.5161423)) * bufB[4] + mat4(vec4(-0.23500964,-0.10392769,-0.014069649,0.0019663526),vec4(0.15423167,-0.27170354,-0.43291807,0.3322014),vec4(-0.15170835,-0.1284036,0.20869783,0.103102684),vec4(0.41871238,0.31502125,0.09058273,-0.16287906)) * bufB[5] + mat4(vec4(-0.0577252,0.041695636,0.56819636,0.04122632),vec4(0.3654559,-0.072089456,-0.21003598,0.18579121),vec4(0.2281446,0.10463017,-0.06737424,0.09800811),vec4(0.28442207,0.23944527,0.16367644,0.32493976)) * bufB[6] + mat4(vec4(0.05137348,0.21656069,0.24413949,0.049702134),vec4(-0.05390131,0.30973196,-0.29414842,0.08287184),vec4(-0.14779834,-0.31470248,-0.17838162,0.09560618),vec4(-0.52754605,-0.07631061,-0.6420692,0.18066718)) * bufB[7];\nbufA[3] = vec4(0.13527668,-0.54038113,0.16969979,0.04742247) + mat4(vec4(0.032431524,-0.08851935,0.33923805,-0.1107826),vec4(0.18050194,-0.22996913,-0.10182703,-0.21506383),vec4(0.1894815,0.13482817,-0.19618194,-0.20510702),vec4(-0.45373717,0.07125434,0.13468249,-0.24933411)) * bufB[0] + mat4(vec4(0.059501883,-0.039403684,-0.07553571,0.17059657),vec4(0.23034701,-0.30018643,-0.09299418,0.19685136),vec4(-0.1600069,-0.031404905,-0.5546884,-0.25189134),vec4(-0.22132598,0.10083452,0.052533768,-0.3805219)) * bufB[1] + mat4(vec4(0.27311203,0.27196556,-0.13556705,-0.2625895),vec4(0.09934776,0.17530285,-0.024982482,0.05326034),vec4(0.30271628,-0.28246543,0.1251152,0.31437352),vec4(-0.28402844,0.02891023,-0.27573445,0.06465835)) * bufB[2] + mat4(vec4(0.40686548,-0.08074752,0.1915534,0.254657),vec4(-0.073338486,0.13140287,-0.018509272,-0.0819604),vec4(-0.5610531,0.14130005,0.06362042,0.04373869),vec4(-0.09166932,-0.3006563,0.083176315,0.107478075)) * bufB[3] + mat4(vec4(0.4343081,-0.39611012,0.3443499,0.43704826),vec4(0.1283109,-0.30272016,-0.19269103,-0.18017973),vec4(0.2998235,0.38330722,-0.088212684,-0.28187186),vec4(0.26976687,0.19130583,0.021659212,-0.15670346)) * bufB[4] + mat4(vec4(-0.24243973,-0.047533013,0.17368785,-0.29313985),vec4(0.35482907,0.015992196,0.08820963,0.20703377),vec4(0.23366843,0.010752485,0.039015,0.3125269),vec4(0.100258596,0.7287612,0.045624252,0.41547316)) * bufB[5] + mat4(vec4(-0.2300326,0.082746655,0.35887054,0.011836654),vec4(0.041131508,-0.47534725,0.17783552,-0.2555724),vec4(-0.18991077,0.27074072,0.43793592,0.11944979),vec4(-0.22043732,-0.035040364,0.0014585389,0.31529567)) * bufB[6] + mat4(vec4(0.5509521,0.29018906,-0.09310328,-0.15891635),vec4(-0.30780342,0.07278711,-0.39212573,0.10502166),vec4(0.08431141,-0.0908062,0.0895147,0.0132568665),vec4(0.16834566,-0.40186784,0.5323631,0.4291608)) * bufB[7];\ntmp = sin(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(0.1284747,-0.07425099,0.14319064,-0.46221754) + mat4(vec4(0.31963244,-0.25496247,0.39298633,-0.2518046),vec4(-0.06451494,-0.08156927,0.11965649,0.16271442),vec4(0.054220017,-0.06589187,0.08404039,0.091598816),vec4(-0.21281312,0.0420309,-0.22409716,0.28205055)) * bufB[0] + mat4(vec4(0.06176257,-0.019257579,0.087875456,-0.029720822),vec4(-0.17080624,-0.2778926,-0.47781837,0.03794348),vec4(-0.19890645,0.113807835,-0.072816126,0.19528633),vec4(-0.45512447,-0.07671148,0.5866069,0.09835561)) * bufB[1] + mat4(vec4(0.041264605,0.10920648,-0.14660177,-0.19133131),vec4(-0.20389721,0.03713731,-0.26970387,0.030687846),vec4(0.089388855,-0.018984105,-0.41216207,0.050490897),vec4(-0.13760479,0.058788896,-0.3393315,-0.116910726)) * bufB[2] + mat4(vec4(-0.005054134,0.27371514,0.03188783,0.42789137),vec4(-0.06318693,0.036208704,0.08660636,-0.0065670013),vec4(0.11429812,0.107783966,0.037378624,0.053963665),vec4(0.08591909,0.7142032,0.5827904,0.23135659)) * bufB[3] + mat4(vec4(0.44833013,-0.4215723,0.38232213,-0.40653104),vec4(-0.03138245,-0.1309984,-0.13199128,0.116646536),vec4(-0.055748444,0.40481538,-0.44580427,0.0049999338),vec4(-0.08632433,0.36432886,0.09437811,0.4867539)) * bufB[4] + mat4(vec4(0.09935423,0.2660223,-0.025581434,-0.3608382),vec4(0.073658794,0.3026663,0.046337206,0.2152205),vec4(0.085787006,0.1846464,0.08946607,-0.3365932),vec4(0.2167564,-0.07031445,0.50460637,-0.056110308)) * bufB[5] + mat4(vec4(0.10606708,-0.2829845,0.17638922,-0.41708192),vec4(-0.29914472,-0.12906298,-0.09755901,-0.46103737),vec4(-0.25866246,-0.30805615,-0.25852314,-0.700597),vec4(0.37943974,0.1508854,0.040130235,-0.16912916)) * bufB[6] + mat4(vec4(-0.101469785,0.011064242,-0.05917352,0.5530443),vec4(-0.02099597,-0.19276874,0.18165389,-0.59415907),vec4(0.03530995,0.17266828,0.26050076,-0.41339564),vec4(0.16222289,0.026515378,-0.19258972,0.11414048)) * bufB[7];\nbufA[1] = vec4(-0.32443923,-0.13123843,-0.58793765,0.05389503) + mat4(vec4(-0.075128324,-0.17783873,0.6696595,0.31408262),vec4(0.21526368,-0.12165676,-0.47978738,0.14819212),vec4(0.02929538,0.101617984,-0.027762018,0.10709231),vec4(0.3165465,-0.13988745,-0.047402494,0.009008729)) * bufB[0] + mat4(vec4(0.22928277,-0.02292142,0.14556554,0.1149629),vec4(0.08655362,0.03706663,-0.3929,-0.31112894),vec4(0.09457974,-0.045427263,0.21634686,0.124516934),vec4(0.09804496,-0.293048,-0.0332866,0.10454471)) * bufB[1] + mat4(vec4(-0.22575603,-0.09947681,-0.2444781,0.14448707),vec4(0.04254366,0.0027922725,-0.14147893,-0.48598915),vec4(0.33996534,-0.08574676,0.49371013,-0.051926225),vec4(0.02156508,0.4506221,-0.26156342,0.17730364)) * bufB[2] + mat4(vec4(-0.07080716,-0.030414484,0.24489367,0.29189536),vec4(0.19116943,0.14678667,-0.414205,-0.037188422),vec4(-0.20192462,0.065218486,-0.12914039,-0.13357705),vec4(-0.34883484,0.06440758,0.0032243468,0.54349643)) * bufB[3] + mat4(vec4(-0.2864121,-0.08226169,0.23555629,0.32793805),vec4(0.117169656,0.1514617,0.12466709,0.17888658),vec4(-0.35952276,-0.23692964,-0.35123643,0.28991285),vec4(-0.2473499,0.25336578,-0.19187984,-0.2370245)) * bufB[4] + mat4(vec4(-0.28255504,0.13151528,-0.31186697,0.18460044),vec4(0.47608453,-0.1305852,0.8804311,0.44134507),vec4(-0.22241805,-0.07686886,0.14861356,-0.18739274),vec4(0.26572424,-0.19767174,0.49941698,0.6865851)) * bufB[5] + mat4(vec4(0.034371093,-0.038272038,0.23285891,0.31552127),vec4(-0.34670994,-0.0854236,0.08899133,0.2985327),vec4(-0.27376586,0.011002565,0.36596495,-0.4210204),vec4(-0.16389357,-0.24284089,0.5269012,0.60240686)) * bufB[6] + mat4(vec4(0.3352801,-0.10932681,-0.23016068,0.17510392),vec4(-0.17718928,0.23966594,0.051717296,0.3467113),vec4(-0.23481427,0.08653306,0.09858025,-0.006186518),vec4(-0.1273717,-0.078085735,-0.04451442,0.056986123)) * bufB[7];\nbufA[2] = vec4(0.34435618,0.79900753,-0.4204183,0.109095715) + mat4(vec4(-0.08448297,0.2544396,0.43628526,-0.10800574),vec4(-0.12920518,-0.1024706,-0.005767234,0.29120758),vec4(0.06663104,-0.17172372,-0.2141915,-0.1520259),vec4(-0.11752708,-0.02374889,-0.24645689,-0.14122827)) * bufB[0] + mat4(vec4(0.1340532,0.031555563,-0.06333737,0.037598524),vec4(-0.33517882,0.069621205,-0.08369222,-0.060202874),vec4(0.046337474,0.07325367,0.08284064,-0.06338969),vec4(0.18544148,-0.0316665,-0.082511,0.03485779)) * bufB[1] + mat4(vec4(0.22912832,-0.19102414,0.15132435,-0.21004951),vec4(-0.20606148,0.1469524,-0.047455933,-0.013188553),vec4(-0.03975891,0.2122404,0.0618115,0.286076),vec4(0.03250629,-0.02837663,-0.110219695,0.2435202)) * bufB[2] + mat4(vec4(0.08137493,0.105172515,0.19287415,0.07531645),vec4(-0.03127938,-0.06043481,0.13666426,0.0900889),vec4(0.3730857,0.060172424,-0.11294878,-0.050595146),vec4(0.030701192,-0.24198724,0.48812205,-0.0696112)) * bufB[3] + mat4(vec4(-0.28302646,0.26369813,-0.09603985,0.016769957),vec4(-0.31160623,-0.11289007,-0.15603907,0.2765857),vec4(0.42398986,0.0599532,0.29417276,-0.21390946),vec4(-0.023400651,0.20652299,-0.3132537,0.2132883)) * bufB[4] + mat4(vec4(0.43837428,0.04515575,0.12161213,-0.06661587),vec4(-0.28699306,0.10383364,0.18300143,0.2553727),vec4(0.5664262,0.13776201,0.25996178,-0.29382908),vec4(0.073727466,0.11667496,-0.2544262,0.04720535)) * bufB[5] + mat4(vec4(0.28211117,0.24801025,0.28934884,-0.449095),vec4(0.3740123,0.20142426,0.15968014,-0.6389145),vec4(0.5581864,0.024383197,0.4865902,-0.45779955),vec4(-0.012012635,0.236716,0.11059637,-0.042015053)) * bufB[6] + mat4(vec4(-0.33389035,-0.006476446,-0.124767035,0.098512575),vec4(0.30414033,0.074917205,0.24541377,-0.19917315),vec4(0.45237592,-0.045806594,0.2880922,-0.24038315),vec4(-0.064961866,0.19363213,0.07348396,-0.04290109)) * bufB[7];\nbufA[3] = vec4(0.53476596,0.05781715,-0.6312971,0.24083741) + mat4(vec4(-0.07169471,0.24904469,0.24648227,0.18303329),vec4(0.16486399,-0.23259597,0.0986845,0.24422455),vec4(-0.39525142,-0.32825562,0.26998663,-0.015140476),vec4(-0.07502707,0.48459905,0.42571062,0.48319885)) * bufB[0] + mat4(vec4(-0.16721393,-0.09457369,0.29733637,-0.09276704),vec4(-0.16755266,0.113861986,-0.07252577,0.008766206),vec4(-0.07476861,-0.20951527,-0.23589773,0.0999046),vec4(-0.013383475,0.2700398,0.63058126,0.025529793)) * bufB[1] + mat4(vec4(-0.17023507,0.094997324,0.13824952,0.042110626),vec4(0.05015401,0.24183713,0.20660494,0.37795952),vec4(0.2436043,0.1399131,-0.18057394,-0.010116287),vec4(0.08910395,0.2761365,-0.12999593,0.39813626)) * bufB[2] + mat4(vec4(0.3641802,0.036388285,-0.13167524,0.11030409),vec4(0.1929286,0.15808202,-0.17842107,0.08604211),vec4(-0.10167459,0.098637246,-0.13459674,-0.3130225),vec4(-0.22962081,0.36402065,-0.038307324,-0.07169636)) * bufB[3] + mat4(vec4(0.06961641,-0.07272473,-0.1141292,-0.19324079),vec4(0.10538665,-0.28878474,0.16111599,0.27239996),vec4(-0.09127386,0.585815,-0.03368466,-0.41144216),vec4(-0.21008584,0.05837291,-0.071578205,-0.027010754)) * bufB[4] + mat4(vec4(-0.4605389,0.45390028,0.33015674,-0.07570023),vec4(0.30787256,0.016507506,-0.3401612,0.44607455),vec4(-0.19184075,-0.11750444,-0.42157444,-0.43569216),vec4(0.12544627,-0.018529603,-0.023289185,-0.13427696)) * bufB[5] + mat4(vec4(-0.038767,-0.071736276,0.032650456,-0.43112892),vec4(-0.2505264,-0.021962566,0.43036777,-0.24452083),vec4(0.0027165418,-0.13474871,0.282706,-0.29554424),vec4(-0.11459194,0.12839119,-0.010963453,-0.43853536)) * bufB[6] + mat4(vec4(0.08426638,0.068636514,-0.28182256,0.24740946),vec4(0.133034,-0.24831362,0.19083223,-0.079554185),vec4(-0.26127288,0.005503148,0.0959664,-0.30088466),vec4(0.007718132,-0.24279514,-0.23172861,0.031032037)) * bufB[7];\ntmp = sin(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(0.4651624858379364,-0.03446674719452858,-0.1546243280172348,0.0) + mat4(vec4(0.5270249247550964,-0.06327534466981888,0.04157496616244316,0.0),vec4(0.028029408305883408,-0.2471971958875656,0.14207668602466583,0.0),vec4(0.08405202627182007,-0.28460484743118286,-0.5165594816207886,0.0),vec4(0.07071161270141602,-0.2513914406299591,-0.02352302335202694,0.0)) * bufB[0] + mat4(vec4(-0.032778434455394745,-0.22442428767681122,0.06436000764369965,0.0),vec4(-0.15739203989505768,-0.389175683259964,-0.08837797492742538,0.0),vec4(-0.05392952635884285,-0.43179574608802795,-0.43695876002311707,0.0),vec4(-0.03145592287182808,0.024954210966825485,0.0388413667678833,0.0)) * bufB[1] + mat4(vec4(-0.09664515405893326,0.21283982694149017,0.37044546008110046,0.0),vec4(0.5581735372543335,0.11289581656455994,-0.10092741250991821,0.0),vec4(0.20696885883808136,0.013342171907424927,0.09564661234617233,0.0),vec4(0.096464604139328,0.18252015113830566,-0.0009363936260342598,0.0)) * bufB[2] + mat4(vec4(-0.12333245575428009,-0.18646453320980072,-0.48247191309928894,0.0),vec4(-0.08498343080282211,-0.04655557498335838,-0.5465033054351807,0.0),vec4(0.03789900988340378,-0.35359612107276917,-0.3304058909416199,0.0),vec4(-0.011676106601953506,-0.3611185848712921,-0.12898142635822296,0.0)) * bufB[3] + mat4(vec4(-0.20115433633327484,-0.22019223868846893,0.3556138575077057,0.0),vec4(-0.023419970646500587,-0.37119296193122864,-0.04584057629108429,0.0),vec4(0.026532122865319252,-0.34593844413757324,-0.37637200951576233,0.0),vec4(0.06583676487207413,0.5461525917053223,0.32952722907066345,0.0)) * bufB[4] + mat4(vec4(0.0032471243757754564,0.5270434021949768,0.4434675872325897,0.0),vec4(0.16711875796318054,0.44630423188209534,-0.7992166876792908,0.0),vec4(0.05538782477378845,0.37769031524658203,0.1727602630853653,0.0),vec4(-0.0182468444108963,-0.6279658675193787,-0.46679770946502686,0.0)) * bufB[5] + mat4(vec4(-0.04361604154109955,0.2955961525440216,0.40316659212112427,0.0),vec4(0.12609295547008514,0.02200995199382305,0.08314581215381622,0.0),vec4(-0.10006635636091232,0.16703982651233673,-0.34196946024894714,0.0),vec4(0.035000815987586975,-0.3124885857105255,0.14507247507572174,0.0)) * bufB[6] + mat4(vec4(0.05710887536406517,-0.21021944284439087,0.31646570563316345,0.0),vec4(-0.020431043580174446,-0.17631873488426208,0.0956408828496933,0.0),vec4(0.02985757775604725,0.2768854796886444,0.31666144728660583,0.0),vec4(-0.01970868930220604,0.46494171023368835,0.478678822517395,0.0)) * bufB[7];\nreturn vec4((1. / (1. + exp(-bufA[0]))).xyz, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouseNorm = (iMouse.xy / iResolution.xy) - vec2(0.5, 0.5);\n\n\n        uv.x *= iResolution.x / iResolution.y;\n        uv.x -= ((iResolution.x / iResolution.y) - 1.) /2.;\n\n\n    // Shifted to the form expected by the CPPN\n    uv = vec2(1., -1.) * 2. * (uv - vec2(0.5, 0.5));\n    // Output to screen\n    fragColor = cppn_fn(uv, sin(iTime*.4), sin(iTime), sin(1.2*iTime), sin(1.6*iTime));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdSXDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[73, 73, 148, 148, 58768], [58770, 58770, 58827, 58877, 59311]], "test": "valid"}
{"id": "fdSXW1", "name": "Lars-Erik's Julia set explorer", "author": "larserik", "description": "Simple toy to look at different Julia sets of z=z^2+c. Walks around -2,-1i and 1,1i in an oscillating spiral.\nHold mouse to temporarily modify c manually.", "tags": ["juliaset"], "likes": 0, "viewed": 46, "published": "Public", "date": "1620078847", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M_PI 3.1415926535897932384626433832795\n\nconst int maxIter = 100;\n\n\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nint iterate(vec2 a, vec2 c) {\n    vec2 prev = a;\n    vec2 square;\n    for(int i = 0; i<maxIter; i++) {\n        square = vec2(\n            pow(prev.x, 2.0) - pow(prev.y, 2.0),\n            2.0 * prev.x * prev.y\n        ) + c;\n        if (length(square) > 1e10) {\n            return i;\n        }\n        prev = square;\n    }\n    return maxIter;\n}\n\nconst float speed = 6.;\nconst float spiralSpeed = 20.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 c = vec2(0, 0);\n    if (iMouse.z > 0.) {\n        c = iMouse.xy/iResolution.xy*4.0-2.0;\n    } else {\n        float rad = .2 + 1.2 * (cos(float(iTime/spiralSpeed))+1.)/2.;\n        c = vec2(cos(float(iTime/speed))*rad*1.5-1., sin(float(iTime/speed))*rad);\n    }\n\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 suv = uv * 4.0 - 2.0;\n    suv = suv / vec2(1.0, 1.8); \n    \n    int iterations = iterate(suv, c);\n\n    float intensity = float(iterations) / float(maxIter);\n    fragColor = vec4(hsl2rgb(vec3(intensity, 1, intensity)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdSXW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 75, 102, 102, 245], [247, 247, 276, 276, 590], [647, 647, 704, 704, 1246]], "test": "valid"}
{"id": "fdSXWt", "name": "game map -challenger -v2", "author": "jorge2017a1", "description": "game map -challenger -v2", "tags": ["2d", "map", "polygon"], "likes": 3, "viewed": 152, "published": "Public API", "date": "1621218974", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//por jorge2017a1 ----jorgeFloresP---16/may/2021\n// referencia \n////-------------------\n/// IQ funciones....librerias\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(antialiasing(0.5),b,d)\n\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n    \nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r; }\n\nvec3 ponerBorde2(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S(abs( distObj),0.0));\n  return colOut;\n}\n\n\nvec3 ponerBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj),0.0));\n  return colOut;\n}\n\nconst vec3 colNegro= vec3(0.0);\nconst vec3 col0= vec3(0.03,0.35,0.70);\nconst vec3 col1= vec3(0.38,0.69,1.00);\nconst vec3 col2= vec3(0.50,0.50,0.50);\nconst vec3 col3= vec3(0.75,0.75,0.75);\nconst vec3 col4= vec3(0.50,0.50,0.50);\nconst vec3 col5= vec3(0.1,1.0,0.1);\nconst vec3 col6= vec3(0.1,0.8,0.1);\n\nfloat opU(float d1, float d2) {return min(d1, d2); }\n\n#define POLY(N) (in vec2 p, in vec2[N] v) {const int n=v.length();float d=dot(p-v[0],p-v[0]);float s=1.;for(int i=0,j=n-1;i<n;j=i,i++){vec2 e=v[j]-v[i];vec2 w=p-v[i];vec2 b=w-e*clamp(dot(w,e)/dot(e,e),0.,1.);d=min(d,dot(b,b));bvec3 cond=bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);if(all(cond)||all(not(cond))) s=-s;}return s*sqrt(d);}\n\nfloat sdPolyc000 POLY(23)\nvec2 ptc000[ 23]=vec2[](  \nvec2(.478,.064),vec2(.476,.107),vec2(.336,.106),vec2(.265,.188),vec2(.266,.260),\nvec2(.192,.340),vec2(.193,.581),vec2(.157,.581),vec2(.156,.661),vec2(.192,.661),\nvec2(.262,.738),vec2(.262,.819),vec2(.367,.936),vec2(.581,.934),vec2(.687,.816),\nvec2(.686,.741),vec2(.758,.658),vec2(.757,.421),vec2(.613,.260),vec2(.614,.179),\nvec2(.546,.105),vec2(.547,.066),vec2(.478,.064) );\n\nfloat sdPolyc001 POLY(5)\nvec2 ptc001[ 5]=vec2[](  \nvec2(.367,.182),vec2(.401,.261),vec2(.473,.259),vec2(.508,.181),vec2(.367,.182) );\n\nfloat sdPolyc002 POLY(5)\nvec2 ptc002[ 5]=vec2[](  \nvec2(.473,.261),vec2(.492,.280),vec2(.544,.221),vec2(.509,.181),vec2(.473,.261) );\n\nfloat sdPolyc003 POLY(5)\nvec2 ptc003[ 5]=vec2[](  \nvec2(.402,.261),vec2(.418,.280),vec2(.491,.280),vec2(.473,.261),vec2(.402,.261) );\n\nfloat sdPolyc004 POLY(5)\nvec2 ptc004[ 5]=vec2[](  \nvec2(.421,.276),vec2(.480,.276),vec2(.472,.266),vec2(.412,.265),vec2(.421,.276) );\n\nfloat sdPolyc005 POLY(5)\nvec2 ptc005[ 5]=vec2[](  \nvec2(.421,.272),vec2(.474,.271),vec2(.471,.266),vec2(.414,.267),vec2(.421,.272) );\n\nfloat sdPolyc006 POLY(5)\nvec2 ptc006[ 5]=vec2[](  \nvec2(.413,.241),vec2(.429,.241),vec2(.426,.231),vec2(.411,.232),vec2(.413,.241) );\n\nfloat sdPolyc007 POLY(5)\nvec2 ptc007[ 5]=vec2[](  \nvec2(.415,.232),vec2(.415,.240),vec2(.428,.239),vec2(.426,.233),vec2(.415,.232) );\n\nfloat sdPolyc008 POLY(5)\nvec2 ptc008[ 5]=vec2[](  \nvec2(.299,.421),vec2(.316,.441),vec2(.348,.441),vec2(.331,.420),vec2(.299,.421) );\n\nfloat sdPolyc010 POLY(5)\nvec2 ptc010[ 5]=vec2[](  \nvec2(.312,.426),vec2(.317,.431),vec2(.333,.431),vec2(.330,.426),vec2(.312,.426) );\n\nfloat sdPolyc011 POLY(5)\nvec2 ptc011[ 5]=vec2[](  \nvec2(.299,.419),vec2(.331,.421),vec2(.367,.342),vec2(.265,.341),vec2(.299,.419) );\n\nfloat sdPolyc012 POLY(9)\nvec2 ptc012[ 9]=vec2[](  \nvec2(.332,.739),vec2(.368,.815),vec2(.510,.815),vec2(.547,.739),vec2(.459,.739),\nvec2(.458,.767),vec2(.422,.768),vec2(.413,.740),vec2(.332,.739) );\n\nfloat sdPolyc013 POLY(4)\nvec2 ptc013[ 4]=vec2[](  \nvec2(.412,.740),vec2(.422,.748),vec2(.422,.768),vec2(.412,.740) );\n\nfloat sdPolyc014 POLY(5)\nvec2 ptc014[ 5]=vec2[](  \nvec2(.422,.750),vec2(.431,.749),vec2(.431,.765),vec2(.421,.766),vec2(.422,.750) );\n\nfloat sdPolyc015 POLY(5)\nvec2 ptc015[ 5]=vec2[](  \nvec2(.449,.765),vec2(.448,.749),vec2(.457,.749),vec2(.457,.766),vec2(.449,.765) );\n\nfloat sdPolyc016 POLY(5)\nvec2 ptc016[ 5]=vec2[](  \nvec2(.422,.768),vec2(.458,.767),vec2(.458,.748),vec2(.421,.749),vec2(.422,.768) );\n\nfloat sdPolyc017 POLY(5)\nvec2 ptc017[ 5]=vec2[](  \nvec2(.369,.816),vec2(.402,.856),vec2(.545,.856),vec2(.509,.816),vec2(.369,.816) );\n\nfloat sdPolyc018 POLY(5)\nvec2 ptc018[ 5]=vec2[](  \nvec2(.377,.822),vec2(.403,.851),vec2(.533,.851),vec2(.508,.823),vec2(.377,.822) );\n\nfloat sdPolyc019 POLY(5)\nvec2 ptc019[ 5]=vec2[](  \nvec2(.381,.821),vec2(.404,.846),vec2(.527,.848),vec2(.508,.822),vec2(.381,.821) );\n\nfloat sdPolyc020 POLY(5)\nvec2 ptc020[ 5]=vec2[](  \nvec2(.509,.816),vec2(.545,.856),vec2(.599,.796),vec2(.548,.739),vec2(.509,.816) );\n\nfloat sdPolyc021 POLY(5)\nvec2 ptc021[ 5]=vec2[](  \nvec2(.332,.421),vec2(.350,.441),vec2(.403,.381),vec2(.368,.341),vec2(.332,.421) );\n\nfloat sdPolyc022 POLY(18)\nvec2 ptc022[ 18]=vec2[](  \nvec2(.272,.700),vec2(.273,.704),vec2(.269,.706),vec2(.264,.709),vec2(.263,.709),\nvec2(.263,.714),vec2(.261,.719),vec2(.268,.726),vec2(.273,.728),vec2(.278,.726),\nvec2(.287,.722),vec2(.288,.716),vec2(.288,.709),vec2(.284,.706),vec2(.279,.705),\nvec2(.277,.705),vec2(.277,.700),vec2(.272,.700) );\n\nvec3 HacerVentana(vec2 p, vec3 col)\n{\n//ventana\n    float sdc006 = sdPolyc006(p, ptc006);\n    col=ponerBorde(colNegro,col,sdc006 );\n    \n    float sdc007 = sdPolyc007(p, ptc007);\n    col=ponerBorde(col1,col,sdc007 );\n return col;\n}\n\n\nvec3 HacerCuartoN1(vec2 p, vec3 col)\n{\n//hacer cuarto 1\n    float sdc001 = sdPolyc001(p, ptc001);\n    col=ponerBorde(col2,col,sdc001 );\n    \n    float sdc002 = sdPolyc002(p, ptc002);\n    col=ponerBorde(colNegro,col,sdc002 );\n\n    float sdc003 = sdPolyc003(p, ptc003);\n    col=ponerBorde(col3,col,sdc003 );\n        \n    float sdc004 = sdPolyc004(p, ptc004);\n    col=ponerBorde(colNegro,col,sdc004 );\n    \n    float sdc005 = sdPolyc005(p, ptc005);\n    col=ponerBorde(col2,col,sdc005 );\n    \n    col= HacerVentana( p,  col);\n    col= HacerVentana( p-vec2(0.04,0.0),  col);\n     return col;\n} \n\nvec3 HacerCuartoN2(vec2 p, vec3 col)\n{\n//hacer cuarto n2\n    float sdc008 = sdPolyc008(p, ptc008);\n    col=ponerBorde(col3,col,sdc008 );\n\n    float sdc010 = sdPolyc010(p, ptc010);\n    col=ponerBorde(col1,col,sdc010 );\n    \n    float sdc011 = sdPolyc011(p, ptc011);\n    col=ponerBorde(col2,col,sdc011 );\n    \n    col= HacerVentana( p-vec2(-0.1,0.15),  col);\n    \n     float sdc021 = sdPolyc021(p, ptc021);\n    col=ponerBorde(colNegro,col,sdc021 );\n  return col;\n}\n\nvec3 HacerCuartoN3Grande(vec2 p, vec3 col)\n{\n//hacer cuarto n3 grande\n    float sdc012 = sdPolyc012(p, ptc012);\n    col=ponerBorde(col2,col,sdc012 );\n    \n    float sdc013 = sdPolyc013(p, ptc013);\n    col=ponerBorde(colNegro,col,sdc013 );\n    \n    float sdc016 = sdPolyc016(p, ptc016);\n    col=ponerBorde(colNegro,col,sdc016 );\n    \n    float sdc014 = sdPolyc014(p, ptc014);\n    col=ponerBorde(col2,col,sdc014 );\n    \n    float sdc015 = sdPolyc015(p, ptc015);\n    col=ponerBorde(col2,col,sdc015 );\n\n    float sdc017 = sdPolyc017(p, ptc017);\n    col=ponerBorde(col3,col,sdc017 );\n    \n    float sdc018 = sdPolyc018(p, ptc018);\n    col=ponerBorde(col2,col,sdc018 );\n    \n    float sdc019 = sdPolyc019(p, ptc019);\n    col=ponerBorde(col2,col,sdc019 );\n\n    float sdc020 = sdPolyc020(p, ptc020);\n    col=ponerBorde(colNegro,col,sdc020 );\n     return col;\n}\n\n\nvec3 HacerArbol(vec2 p, vec3 col)\n{\n    float sdc022 = sdPolyc022(p, ptc022);\n    col=ponerBorde(col6,col,sdc022 );\n    return col;\n}\n    \n\n//***------------****-----------****------------******-------\nvec3 ChallengerNes(in vec2 pp, vec3 col) \n{\n  vec2 p=pp,pr1=pp, pr2=pp;\n  \n    float sdc000 = sdPolyc000(p, ptc000);\n    //col=mix(col,col1 ,S( sdc000 ,0.0));\n    col=ponerBorde(col2,col,sdc000 );\n    col= HacerCuartoN1(p,col);\n    col= HacerCuartoN2(p,col);\n    col= HacerCuartoN2(p-vec2(0.22,0.0),col);\n    col= HacerCuartoN1(p-vec2(-0.1,0.32),col);\n    col= HacerCuartoN1(p-vec2(0.12,0.32),col);\n    col= HacerCuartoN3Grande(p,col);\n    col= HacerArbol(p,col);\n    col= HacerArbol(p-vec2(0.05,0.0),col);\n    col= HacerArbol(p-vec2(0.3,0.0),col);\n    col= HacerArbol(p-vec2(0.35,0.0),col);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    float t=iTime*0.25;\n    vec2 p=uv*0.325-vec2(-0.45,-0.7+0.5*sin(fract(t)));\n     vec3 col=vec3(0.0,0.0,1.0);\n    //vec3 col=col2;\n    col=ChallengerNes(p, col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdSXWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 315, 351, 351, 396], [402, 402, 437, 437, 461], [463, 463, 524, 524, 648], [651, 651, 711, 711, 837], [1139, 1139, 1170, 1170, 1191], [5058, 5058, 5095, 5105, 5289], [5292, 5292, 5330, 5347, 5880], [5883, 5883, 5921, 5939, 6345], [6347, 6347, 6391, 6416, 7199], [7202, 7202, 7237, 7237, 7335], [7342, 7404, 7447, 7447, 8011], [8013, 8013, 8070, 8070, 8365]], "test": "valid"}
{"id": "fdXSzs", "name": "CircularShader", "author": "Felipe_Rodrigues", "description": "testing 2", "tags": ["noise", "uv", "circular"], "likes": 1, "viewed": 41, "published": "Public", "date": "1622125592", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float STEP_VALUE = 0.2;\nfloat WAVE_FREQUENCY = 8.0;\nfloat SPEED = 4.0;\n\n#define Pi 3.141516\n\nfloat rand1(float x){\n    return fract(sin(x)*1000.0);\n}\n\nfloat rand2(float x){\n    return fract(sin(x)*10000.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // Time varying pixel color\n    vec2 newUv = uv*2.0 - 1.0;\n    float dist = length(newUv);\n    float cossinedDist = cos(dist*Pi*WAVE_FREQUENCY+iTime*SPEED);\n    float steppedDist = step(STEP_VALUE,dist);\n    float randomNoise = rand1(rand2(fragCoord.x) + rand1(fragCoord.y)+iTime);\n    vec3 col = vec3(cossinedDist*randomNoise );//+ (1.0-cossinedDist)*texture(iChannel2,uv).xyz;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XdXGzr", "previewfilepath": "/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture"}, {"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdXSzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[93, 93, 114, 114, 149], [151, 151, 172, 172, 208], [210, 210, 267, 317, 798]], "test": "valid"}
{"id": "flf3Rj", "name": "Simple bubbles raymarch VR", "author": "z0rg", "description": "Testing VR ", "tags": ["vrtest"], "likes": 3, "viewed": 157, "published": "Public API", "date": "1622382061", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\n\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\n\nvec2 map(vec3 p)\n{\n    vec2 acc = vec2(1000.,-1.);\n    for (int i = 0; i < 10; ++i)\n    {\n        float fi = float(i)+iTime*0.0025;\n        vec3 pos = p - vec3(sin(fi), cos(fi*5.), cos(fi))*sin(fi*3.)*7.;\n        float sz = .5+.2*sin(fi);\n        acc = _min(acc, vec2(length(pos)-sz,0.));\n    }\n    for (int i = 0; i < 10; ++i)\n    {\n        float fi = float(i)+10.+iTime*.01;\n        vec3 pos = p - vec3(sin(fi), cos(fi*5.), cos(fi))*sin(fi*3.)*7.;\n        float sz = .05+.025*sin(fi);\n        acc = _min(acc, vec2(length(pos)-sz,1.));\n    }\n    return acc;\n}\n\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n    vec3 p = ro;\n    for (int i = 0; i < steps; ++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.01)\n            return vec3(res.x, distance(p, ro), res.y);\n        p += rd * res.x;\n    }\n    return vec3(-1.);\n}\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize(rd+r*uv.x+u*uv.y);\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n    vec2 e = vec2(0.01,0.);\n    return normalize(vec3(d)-vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\n\nvec3 dordr(vec3 ro, vec3 rd)\n{\n    vec3 col = mix(vec3(1.000,0.000,0.349),vec3(.1), pow(sat(2.*abs(dot(rd, vec3(0.,1.,0.)))),.5));\n    vec3 res = trace(ro, rd, 32);\n    if (res.y > 0.)\n    {\n        vec3 p = ro+rd*res.y;\n        vec3 n = getNorm(p, res.x);\n        col = (n *.5+.5);\n        if (res.z == 0.)\n            col = mix(vec3(1.000,0.000,0.349),vec3(.1,.1,.15), 1.-pow(sat(abs(dot(vec3(0.,1.,0.), n))),2.));\n        else\n            col = mix(vec3(0.094,0.969,0.471),vec3(.1,.1,.15), clamp(sin(n.y*10.),-1.,1.));\n        col = mix(vec3(0.05,0.1,0.2), col, 1.-sat(exp(-res.y*0.1)));\n    }\n    return col;\n}\n\nvec3 rdr2d(vec2 uv)\n{\n    vec3 ro = vec3(0.,0.,-15.);\n    vec3 ta = vec3(0.,0.,0.);\n    vec3 rd = normalize(ta-ro);\n    rd = getCam(rd, uv);\n    vec3 col = dordr(ro, rd);\n    return col;\n}\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    vec3 col =dordr(fragRayOri,fragRayDir);\n    \n    fragColor = vec4(col,1.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n\n    vec3 col =rdr2d(uv);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flf3Rj.jpg", "access": "shaders20k", "license": "cc-by-nc-4.0", "functions": [[430, 430, 457, 457, 510], [512, 512, 530, 530, 1072], [1074, 1074, 1115, 1115, 1338], [1340, 1340, 1371, 1371, 1502], [1504, 1504, 1535, 1535, 1649], [1651, 1651, 1681, 1681, 2265], [2267, 2267, 2288, 2288, 2455], [2456, 2456, 2550, 2550, 2632], [2633, 2633, 2690, 2690, 2820]], "test": "valid"}
{"id": "flf3W7", "name": "BlackHole By Sam K", "author": "samk9632", "description": "black hole test shader", "tags": ["blackhole"], "likes": 10, "viewed": 192, "published": "Public", "date": "1622169416", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 rotate(vec3 pos, vec2 rotation) {\n    vec2 m4 = vec2(length(pos.xz), length(pos.xyz));\n\n    vec2 angle = vec2(acos(pos.x/m4.x), asin(pos.z/m4.y));\n    float xx = pos.x*cos(rotation.y)+pos.z*sin(rotation.y);\n    float yy = pos.y;\n    float zz = -pos.x*sin(rotation.y)+pos.z*cos(rotation.y);\n    return vec3(xx, yy, zz);\n}\nfloat intersectionTest(vec3 o, vec3 n, float rIn, float rOut) {\n    float m1 = length(o);\n    float m2 = length(n);\n    float m3 = o.z/(o.z-n.z)*m2+(1.0-o.z/(o.z-n.z))*m1;\n    float m5 = 1.0;\n    if (o.z <= 0.0 && n.z > 0.0) {\n        if (m3 <= rOut && m3 >= rIn) {\n            m5 = 1.0;\n        } else {\n            m5 = 0.0;\n        }\n    } else if (o.z >= 0.0 && n.z < 0.0) {\n        if (m3 <= rOut && m3 >= rIn) {\n            m5 = 1.0;\n        } else {\n            m5 = 0.0;\n        }\n    } else {\n        m5 = 0.0;\n    }\n    return m5;\n}\nfloat hash(vec2 p)  // replace this by something better\n{\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\tvec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\nfloat fractalNoise(vec2 UV, float iterations, float dimension, float scale, float scaleRel) {\nfloat val = 0.0;\n    for (float j = 1.0; j < pow(scaleRel, iterations); j*=scaleRel) {\n        val+=-0.0+noise(scale*j*UV.xy)/(1.0 + dimension);\n    }\n    return val;\n}\nfloat lt(float a1, float a2) {\n    float output1 = (-abs(a1-a2)/(a1-a2)+1.0)/2.0;\n    return output1;\n}\nfloat gt(float a1, float a2) {\n    float output1 = (abs(a1-a2)/(a1-a2)+1.0)/2.0;\n    return output1;\n}\nvec4 rayMarch(float stepSize, vec3 pos, vec3 dir, float maxSteps, float warp, float horizon, float xx, float SRV, vec4 color) {\n    vec3 p = pos;\n    vec3 d = dir;\n    float ll = length(d);\n    vec3 pStorage = p;\n    float absorb = 0.0;\n    vec4 outs = vec4(0.0, 0.0, 0.0, 1.0);\n    float alpha = 0.0;\n    float di = 1.0;\n    for (float i = 0.0; i < maxSteps; i+=di) {\n        if (abs(p.z) > 0.2+stepSize*length(p) || length(p.xy) > 7.0) {\n        d -= warp*p/(length(p)-horizon)*stepSize*2.0;\n        d /= length(d)*ll/stepSize/length(p);\n            p += d*stepSize;\n            di = 1.0;\n        } else {\n        d -= warp*p/(length(p)-horizon)*stepSize*pow(SRV, 1.0)*2.0;\n        d /= length(d)*ll/stepSize/length(p);\n            p += d*stepSize*SRV;\n            di = SRV;\n        }\n        float rI = 1.0;\n        float rO = 3.0;\n        if (abs(p.z) < 0.5) {\n        vec2 UV = vec2(p.xy);\n        UV = vec2(UV.x*sin(xx)+UV.y*cos(xx), -UV.y*sin(xx)+UV.x*cos(xx));\n        UV = vec2(1.0*length(UV), abs(UV.y)/UV.y*acos(UV.x/length(UV)));\n        float localAbsorb = pow(0.5, 2.0/(rO-rI)*(length(p.xy)-rI))*10.0*length(p-pStorage)*gt(length(p.xy), rI)*lt(abs(p.z), 0.05*max(1.0+0.2*fractalNoise(UV, 16.0, 1.0, 1.0, 2.0), 0.0));\n        localAbsorb *= pow(2.0, min(length(p.xy-rI-0.5), 0.0));\n        absorb += localAbsorb*100.0;\n        vec4 emit = color*100.0*pow(0.5, 2.0/(rO-rI)*(length(p.xy)-rI))*length(p-pStorage)*gt(length(p.xy), rI)*lt(abs(p.z), 0.05*max(1.0+0.2*fractalNoise(UV, 16.0, 1.0, 1.0, 2.0), 0.0));\n        emit *= min(1.0-length(p.xy)+rI, 1.0)+fractalNoise(UV, 8.0, 0.0, 1.0, 2.0);\n        float fog = 10.0*pow(0.5, 2.0/(rO-rI)*(length(p.xy)-rI))*length(p-pStorage)*gt(length(p.xy), rI)*pow(max(0.0, 1.0-5.0*abs(p.z)), 3.0);\n        emit.x += pow(color.x, 0.7)*0.5*(fog)*max(0.5+1.0*fractalNoise(UV, 8.0, 1.0, 1.0, 2.0), 0.0)+0.2*fog;\n        emit.y += pow(color.y, 0.7)*0.5*(fog)*max(0.5+1.0*fractalNoise(UV, 8.0, 1.0, 1.0, 2.0), 0.0)+0.2*fog;\n        emit.z += pow(color.z, 0.7)*0.5*(fog)*max(0.5+1.0*fractalNoise(UV, 8.0, 1.0, 1.0, 2.0), 0.0)+0.2*fog;\n        absorb += 1.0*fog;\n        emit *= lt(length(p.xy), 7.0);\n        emit = max(emit, 0.0);\n        outs += pow(0.8, absorb)*emit;\n        pStorage = p;\n        }\n    }\n    return outs;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = fragCoord.xy / iResolution.xy;\n    //camera distance\n    float r = 25.0;\n    //camera rotation sensitivity\n    float s = 10.0;\n    //depth of field\n    float dof = 1.0;\n    float mouseX = iMouse.x/iResolution.x-0.5;\n    float mouseY = (iMouse.y-0.5*iResolution.y)/iResolution.x;\n    float x = fragCoord.x/iResolution.x-0.5;\n    float y = (fragCoord.y-0.5*iResolution.y)/iResolution.x;\n    vec3 camPos = rotate(vec3(r, 0.0, 0.0), -vec2(0.0*mouseX, -s*mouseY));\n    \n    vec3 camDir = rotate(vec3(-1.0, dof*x, dof*y), vec2(0.0, s*mouseY));\n    fragColor = 2.0*rayMarch(0.25, camPos, camDir, 150.0, 0.01, 0.0, iTime*1.0-s*mouseX, 0.1, vec4(255.0, 0.75*207.0, 0.6*159.0, 255.0)/255.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flf3W7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 325], [326, 326, 389, 389, 868], [869, 869, 926, 926, 1030], [1031, 1031, 1057, 1057, 1348], [1349, 1349, 1442, 1442, 1611], [1612, 1612, 1642, 1642, 1715], [1716, 1716, 1746, 1746, 1818], [1819, 1819, 1946, 1946, 4088], [4089, 4089, 4146, 4146, 4847]], "test": "valid"}
{"id": "flfGW8", "name": "LED wall", "author": "R3N", "description": "I wanted to try simulating the look of an LED wall where each pixel is a bit separate from it's neighbors.", "tags": ["abstract"], "likes": 13, "viewed": 347, "published": "Public API", "date": "1622202632", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 p) {\n\treturn fract(sin(dot(p, vec2(12.543,514.123)))*4732.12);\n}\n\nfloat noise(vec2 p) {\n\tvec2 f = smoothstep(0.0, 1.0, fract(p));\n\tvec2 i = floor(p);\n\t\n\tfloat a = rand(i);\n\tfloat b = rand(i+vec2(1.0,0.0));\n\tfloat c = rand(i+vec2(0.0,1.0));\n\tfloat d = rand(i+vec2(1.0,1.0));\n\t\n\treturn mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float n = 2.0;\n    vec2 uv = fragCoord/iResolution.y;\n    vec2 uvp = fragCoord/iResolution.xy;\n\tuv += 0.75*noise(uv*3.0+iTime/2.0+noise(uv*7.0-iTime/3.0)/2.0)/2.0;\n    float grid = (mod(floor((uvp.x)*iResolution.x/n),2.0)==0.0?1.0:0.0)*(mod(floor((uvp.y)*iResolution.y/n),2.0)==0.0?1.0:0.0);\n    //float grid = (mod(mod(floor((uvp.y)*iResolution.y/n),2.0)+floor((uvp.x)*iResolution.x/n),2.0)==0.0?1.0:0.0);\n    vec3 col = mix(vec3(0), vec3(0.2, 0.4, 1), 5.0*vec3(pow(1.0-noise(uv*4.0-vec2(0.0, iTime/2.0)),5.0)));\n    col *= grid;\n    col = pow(col, vec3(1.0/2.2));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flfGW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 80], [82, 82, 103, 103, 345], [347, 347, 404, 404, 1007]], "test": "valid"}
{"id": "flfGz4", "name": "RGB Balls", "author": "ashishkingdom", "description": "Hey guys! This is my 3rd shader.. it consists of some 2d balls rotating around with some fancy effect of smoothstep(). Any feedbacks are welcome. :)", "tags": ["blur", "colors", "beginner", "balls", "learning"], "likes": 0, "viewed": 98, "published": "Public", "date": "1621581853", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n    @Title: RGB Balls\n    @Author: AshishKingdom\n*/\n#define PI 3.1415926535\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 R = fragCoord/iResolution.y;\n    vec3 clr = vec3(0.0);\n    float i=0.0;\n    for(int j=0;j<3;j++)\n    {\n        vec2 pos = vec2(0.8+0.20*cos(i+iTime*5.0),0.5+0.20*sin(i+iTime*5.0));\n        clr[j] = 1.0-smoothstep(0.0,abs(sin(iTime*2.0)),length(pos-R));\n        i+=0.66*PI;\n    }\n    fragColor = vec4(clr,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flfGz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[79, 79, 136, 136, 457]], "test": "valid"}
{"id": "fll3D8", "name": "Raymarched mandelbulb", "author": "Dumb_Psycho", "description": "A raymarched mandelbulb with soft shadows.", "tags": ["raymarching", "fractal", "fractal", "raymarched", "mandelbulb", "shadows", "fractals", "softshadows"], "likes": 4, "viewed": 63, "published": "Public", "date": "1621997973", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define HITDIST 0.01\n#define SURFDIST 0.03\n#define MAXDIST 100.0\n#define MAXTRACES 32\n\n#define MANDELPOWER 8.0\n#define ITERATIONS 15\n\nfloat power = 0.0;\n\nvec3 bgcol(vec3 point) {\n    float t = point.y*0.5 + 0.5;\n    return (1.0-t)*vec3(1.0) + t*vec3(0.1, 0.0, 0.8);\n}\n\nfloat map(float x, float i1, float i2, float o1, float o2){\n    float slope = (o2 - o1)/(i2 - i1);\n    return (x - i1) * slope + o1;\n}\n\nfloat sphere(vec3 center, float radius, vec3 point) {\n    return length(center-point) - radius;\n}\n\nfloat mandelbulb(vec3 point) {\n    \n    power = clamp(1.0 + (sin(iTime/3.0) + 1.0) * 4.0, 1.0, 8.0);\n    \n   \n    vec3 z = point;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < ITERATIONS ; i++)\n\t{\n\t\tr = length(z);\n\t\tif (r>3.) break;\n\t\n\t\tfloat theta = acos(z.z / r);\n\t\tfloat phi = atan(z.y, z.x);\n\n\t\tdr =  pow( r, power-1.0)*power*dr + 1.0;\n\t\t\n\t\tfloat zr = pow( r,power);\n\t\ttheta = theta*power;\n\t\tphi = phi*power;\n\t\t\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=point;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\nfloat scene(vec3 point){\n    //float f = sphere(vec3(0.0, 0.55, 3.0), 0.5, point);\n    //f = min(f, point.y);\n    float f = mandelbulb(point);\n    return f;\n}\n\nvec3 calcNormal(vec3 p){\n    vec2 e = vec2(0.01, 0.0);\n    float d = scene(p);\n    vec3 normal = d - vec3(scene(p-e.xyy), scene(p-e.yxy), scene(p-e.yyx));\n    return normalize(normal);\n}\n\n\nfloat raymarch(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    for (int i = 0; i < MAXTRACES; i++) {\n        vec3 currentPos = ro + rd * t;\n        float tClosest = scene(currentPos);\n        \n        if (tClosest < HITDIST || t > MAXDIST) break;\n\n        t += tClosest;\n    }\n    return t;\n}\n\nfloat shadow(vec3 ro, vec3 rd, float mint, float maxt, float k){\n    float res = 1.0;\n    for (float t = mint; t < maxt;){\n        float h = scene(ro + rd*t);\n        if (h < 0.01) return 0.0;\n        res = min(res, k*h/t);\n        t += h;\n    }\n    return res;\n}\n\nfloat calcLighting(vec3 point) {\n    vec3 normal = calcNormal(point);\n    float dif = 0.0;\n\n    vec3 light1 = vec3(21.0, .0, -5.0);\n    light1.xz = vec2(sin(iTime), cos(iTime))*10.0;\n    \n    vec3 toLight1 = normalize(light1 - point);\n    \n    dif = clamp(dot(normal, toLight1), 0.0, 1.0);\n    \n    dif *= shadow(point+normal*SURFDIST, toLight1, 0.0, 100.0, 1.1);\n    float amb = 0.1;\n    return clamp(dif+amb, 0.0, 1.0);\n}\n\nvoid camera(in vec2 fragCoord, out vec3 ro, out vec3 rd) {\n    vec3 worldUp = vec3(0.0, 1.0, 0.0);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - 0.5*iResolution.xy)/iResolution.x;\n    vec3 camPos = vec3(0.0, 0., -4.0);\n    \n    \n    \n    vec3 ro = camPos;\n    vec3 rd = normalize(vec3(uv, 1.0));\n    \n    \n    float hitDist = raymarch(ro, rd);\n    \n    vec3 col = vec3(0.0);\n    \n    if (hitDist > MAXDIST) col = bgcol(rd);\n    else {\n        vec3 point = ro + rd * hitDist;\n        float dif = calcLighting(point);\n    \n        vec3 normalCol = calcNormal(point)*0.5 + vec3(0.5);\n    \n        col = normalCol * dif;\n        col = col.yzx;\n        col = sqrt(col);\n    }\n    \n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fll3D8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[154, 154, 178, 178, 267], [269, 269, 328, 328, 403], [405, 405, 458, 458, 502], [504, 504, 534, 534, 1038], [1040, 1040, 1064, 1149, 1198], [1200, 1200, 1224, 1224, 1386], [1389, 1389, 1423, 1423, 1676], [1678, 1678, 1742, 1742, 1941], [1943, 1943, 1975, 1975, 2366], [2368, 2368, 2426, 2426, 2473], [2475, 2475, 2532, 2532, 3132]], "test": "valid"}
{"id": "fll3R7", "name": "The Dip", "author": "lennyjpg", "description": "a", "tags": ["asdfa"], "likes": 3, "viewed": 118, "published": "Public API", "date": "1621825238", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 n) { \nreturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\nvec2 ip = floor(p);\nvec2 u = fract(p);\nu = u*u*(3.0-2.0*u);\nfloat res = mix(\n    mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n    mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\nreturn res*res;\n}\n\nvec3 red = vec3(234,77,83)/255.0;\nvec3 dark = vec3(.1);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 uv = fragCoord/iResolution.y;\nuv.x*=0.5;\nvec2 u = uv * 5.0 ;\nfloat index = ceil(u.x) * ceil(u.y);\nfloat t = iTime * 0.5 + index;\nu = fract(u);\n\n\nfloat width = noise(floor(u) + index) * .1 + .05;\nfloat labelY = step(abs(1.0 - u.y - 0.1),0.05);\nfloat labelX = step(abs(1.0 - u.x-width - 0.02), width);\nfloat label = labelX * labelY;\n\n\n\nfloat j = noise(floor(u)+index+t*20.0)*0.7+0.3;\nfloat w = step(0.5-abs(u.y),0.2);\n//w -= step(abs(u.x-0.1),j);\n//k = max(k,w);\n\n\nfloat lines = clamp(floor(mod(fragCoord.x,10.0)), 0.0, 1.0);\n\nfloat q = u.x;\nvec2 dir = vec2(1,0);\nu += dir * t;\n\nfloat medium = noise((u + index * 133.77 ) * vec2(7.0 , 0.1)),\n small = noise((u + index * 848.33) * vec2(37.57 , 0.1)),\n large = noise((u + index * 1723.456) * vec2(0.572 , 0.1)),\n offset = large - medium*0.78 - small*0.06;\n \n float medium2 = noise((u + index * 1033.77 ) * vec2(7.0 , 0.1)),\n small2 = noise((u + index * 48.33) * vec2(37.7 , 0.1)),\n large2 = noise((u + index * 723.456) * vec2(0.72 , 0.1)),\n offset2 = large2 - medium2*0.78 - small2*0.06;\n \n\nfloat e = step(u.y + offset, 1.0 - q);  \nfloat e2 = step(u.y + offset2, 1.0 - q);  \n\nvec3 col = mix(red, dark, max(e, label));\nvec3 foo = vec3(1.0);\ncol = mix(col, foo, e2*0.8);\n\nfragColor = vec4(col , 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fll3R7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 86], [88, 88, 108, 108, 314], [374, 374, 431, 431, 1684]], "test": "valid"}
{"id": "fll3RN", "name": "Milk Ocean", "author": "ssartell", "description": "raymarch, milk, sunset", "tags": ["raymarch", "sunset", "milk"], "likes": 24, "viewed": 213, "published": "Public", "date": "1621657305", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nLots of stuff from IQ's blog, nothing special. Mostly trying to get something \nthat feels semi-translucent. Mouse drag for camera\n*/\n\nfloat farClip = 30.0;\nfloat pi = 3.14159;\n\nfloat rand(vec2 co){\n  return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat sphere(vec3 p, vec3 c, float r) {\n  return length(p - c) - r;\n}\n\nfloat plane( vec3 p, vec3 n, float h )\n{\n  return dot(p,n) + h;\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat map(vec3 p) {\n  float d1 = sphere(p, vec3(.1, sin(iTime*.9)*.2, 0.), .13);\n  float d2 = sphere(p, vec3(-.1, cos(iTime)*.15, 0.), .1);\n  float d3 = sphere(p, vec3(0., sin(iTime*.7)*.12, .1), .08);\n  float d4 = plane(p, vec3(0., 1., 0.), .2);\n  float r = length(p.xz);\n  float c = exp(-1.5 * r * r);\n  d4 += .03 * cos((r - iTime * .35) * 20.) * c * (1. - c*c*c*c*c);\n  float s1 = smin(smin(d1, d2, .07), d3, .07);\n  return smin(s1, d4, .2);\n}\n\nfloat map2(vec3 p) {\n  float d4 = plane(p, vec3(0., 1., 0.), .2);\n  return d4;\n}\n\nvec3 calcNormal(vec3 p) {\n  vec2 e = vec2(0.0001, 0.0);\n  return normalize(vec3(\n    map(p + e.xyy) - map(p - e.xyy),\n    map(p + e.yxy) - map(p - e.yxy),\n    map(p + e.yyx) - map(p - e.yyx)));\n}\n\nfloat marchRay(vec3 ro, vec3 rd) {\n  float t = 0.0;\n  for(int i = 0; i < 300; i++) {\n    vec3 p = ro + t * rd;\n    float h = map(p);\n    if (h < 0.0001) return t;\n    t += h;\n    if (t > farClip) return 0.0;\n  }\n  return t;\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float k) {\n  float res = 1.0;\n    float ph = 1e20;\n    for( float t = 0.; t<100.;)\n    {\n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.x;\n\n  float tx = iTime / 2.0;\n  float ty = 0.2;\n  if (iMouse.z > 0.0) {\n    tx = iMouse.x / iResolution.x * 3.1416 * 3.0 + 3.14;\n    ty = iMouse.y / iResolution.y - .1;\n  }\n\n  vec3 ro = vec3(cos(tx * .7), ty, sin(tx * .7));\n  vec3 ta = vec3(0.0, 0.0, 0.0);\n\n  // camera axes\n  vec3 ww = normalize(ta - ro);\n  vec3 uu = normalize(cross(ww, vec3(0,1,0)));\n  vec3 vv = normalize(cross(uu, ww));\n\n  vec3 rd = normalize(uv.x*uu + uv.y*vv + .6*ww);\n\n  float t = marchRay(ro, rd);\n\n  vec3 l = normalize(vec3(1., cos(iTime * .3) + 1.1, 0.));\n  float vdotl = max(dot(rd, l), 0.0);\n  vec3 horizon = vec3(l.x, 0., l.y);\n  float atHorizon = pow(max(dot(l, horizon), 0.), 4.);\n\n  //vec3 fog = vec3(.55, .7, .9);\n  vec3 fog = mix(vec3(.55, .7, .9), vec3(0., .1, .2), max(rd.y, 0.));\n  vec3 sun = vec3(1.6, 1.2, 1.);\n  \n  float sunAmount = pow(vdotl, 64.);\n  fog = mix(fog, vec3(.25, .4, .6), atHorizon);\n  fog = mix(fog, vec3(1., .75, .6), (vdotl + .4) * atHorizon);\n  fog = mix(fog, sun, sunAmount);\n  vec3 col = fog;\n\n  if (t > 0.0) {\n    col = vec3(0.0);\n    vec3 p = ro + t * rd;\n\n    vec3 n = calcNormal(p);\n    vec3 r = reflect(-l, n);\n\n    float ndotl = clamp(dot(n, l), 0., 1.);\n    float rdotv = clamp(dot(-rd, r), 0., 1.);\n\n\n    vec3 albedo = vec3(0., .2, .5);\n    albedo = vec3(.75);\n    //albedo = n * .5 + .5;\n    //albedo = vec3(.2, .9, .2);\n\n    float fr = pow(1. + dot(n, rd), 4.) * .7;\n    float ao = clamp(map(p + n * .01) / .01, 0., 1.);\n    float sss = smoothstep(0., 1., map(p + l * .5) / .5);\n    float sha = softShadow(p + .01 * n, l, 6.);\n\n    float diff = ndotl;\n    float sp = pow(rdotv, 100.);\n    float sky = clamp(.5 + .5 * n.y, 0., 1.);\n    float ind = clamp(dot(n, normalize(l * vec3(-1., 0., -1.))), 0., 1.);\n\n    vec3 lin = (sss + diff * sha) * .5 * mix(sun, vec3(1.6, 1.1, .9), atHorizon);\n    lin += sky * vec3(.15, .2, .3) * ao;\n    lin += ind * vec3(.4, .3, .2) * ao;\n\n    col = albedo * lin + sp * sha;\n\n    col = mix(col, fog, fr + sunAmount);\n    col = mix(fog, col, exp(-.001*t*t*t));\n  }\n\n  //col = col / (col + vec3(1.0));\n  col = pow(col, vec3(1.0 / 2.2));\n\n  fragColor = vec4(col, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fll3RN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[180, 180, 200, 200, 268], [270, 270, 309, 309, 339], [341, 341, 381, 381, 406], [408, 408, 447, 447, 531], [533, 533, 552, 552, 979], [981, 981, 1001, 1001, 1061], [1063, 1063, 1088, 1088, 1258], [1260, 1260, 1294, 1294, 1485], [1487, 1487, 1532, 1532, 1855], [1858, 1858, 1915, 1915, 4106]], "test": "valid"}
{"id": "fll3Rr", "name": "raindrop simulation", "author": "yunhai", "description": "raindrop on the window", "tags": ["simulation"], "likes": 2, "viewed": 123, "published": "Public", "date": "1621481580", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SS(a,b,t) smoothstep(a,b,t)\nfloat rand(float x)\n{\n    return fract(sin(sin(126.*x)*564.)*.837);\n}\nfloat wave12(float x)\n{\n    return sin(x+sin(x+sin(x)*.5));\n}\nvec3 paintRaincol(vec2 uv,vec2 pos)\n{\n    vec3 raincol;\n    raincol.xy=uv-pos+.06;\n    raincol.z=.1;\n    return raincol*10.*vec3(.5,.7,1.);\n}\nfloat remap(float a, float b,float c, float d,float x)\n{\n    return ((x-a)/(b-a))*(d-c)+c;\n}\nvoid mainImage( out vec4 O, in vec2 C )\n{\n    float loopTime=600.;\n    float t=fract(iTime/loopTime)*loopTime;//when time is very large, t will be similar in each cell\n\n    vec2 uv = (C-.5*iResolution.xy)/iResolution.y;\n    \n    \n    //cell\n    vec2 ratio=vec2(1.,4.);\n    vec2 cuv=uv/ratio*10.;\n    cuv.y+=rand(floor(cuv.x)+9.)*4.;\n    cuv.y+=t*0.3;\n    vec2 id=floor(cuv);\n    float hashid=id.x*2.+id.y*4.;\n    t+=rand(hashid)*10.;//diff time\n    cuv=fract(cuv)-.5;\n    cuv+=vec2(sin(cuv.y*10.+t*2.),sin(cuv.x*13.+t*2.))*.005;//distort\n    cuv.y*=ratio.y;\n    \n    //cell line\n    //if(cuv.x>.48||cuv.y>.49*ratio.y)\n        //O.rgb+=vec3(1.);\n        \n        \n    //rain\n    vec2 pos=vec2(0.,ratio.y*wave12(-t*2.)*.3);  \n    float d=length(cuv-pos);\n    float size=rand(hashid)*.4+.6;\n    O.rgb+=vec3(SS(.2*size,.099,d))*paintRaincol(cuv,pos);\n    \n    \n    //trail\n    float density=2.;\n    float tLengthRate=remap(0.,1.,.2,.4,rand(hashid));\n    vec2 tuv=fract(uv*vec2(1.,density)*10.)-.5;\n    tuv.y/=density;\n    float trd=cuv.y-pos.y;//trail rain dis\n    float topPos=ratio.y*tLengthRate;\n    float trailr=SS(0.,2.5,topPos-cuv.y)*0.2*size;//nearer the dead line, smaller\n    O.rgb+=vec3(SS(trailr,trailr*.1-.01,length(tuv))*SS(.13,.14,trd))*paintRaincol(tuv,vec2(0.));//size,pos*dir*col\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fll3Rr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 36, 57, 57, 105], [106, 106, 129, 129, 167], [168, 168, 205, 205, 309], [310, 310, 366, 366, 402], [403, 403, 444, 444, 1697]], "test": "valid"}
{"id": "fll3W7", "name": "Rainbow Line", "author": "ReEngine", "description": "Moving line of a flowing rainbow colors\n", "tags": ["abstract"], "likes": 10, "viewed": 149, "published": "Public", "date": "1622216831", "time_retrieved": "2021-10-01T00:00:00", "image_code": "               // shader playback time (in seconds)\n\n\n\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tfloat widthHeightRatio = iResolution.x/iResolution.y;\n\tuv.y/=widthHeightRatio;\n\t\n\t\n\t//Wave/////////////////////\n\tfloat slowing = 3.0;\n\tfloat frequency = 1.;\n\tfloat amplitudeLim = 2.;\n\t\n\t//Colors///\n\tfloat RGBTime = 2.;\n\tfloat colorWidth = 6.;\n\t\n\t\n\n\t\n\t\n\t\n\tfloat curvature = -pow(uv.x-0.5,2.)/0.5+0.5;\n\tfloat wave = cos((uv.x+iTime/slowing)*frequency)/amplitudeLim;\n\tfloat line = wave  *curvature+0.25;\n\t// line = curvature;\n\tvec2 centre = vec2(uv.x,line);\n\tvec2 pos = centre - uv;\n\t// Equation 1/x gives a hyperbola which is a nice shape to use for drawing glow as \n    // it is intense near 0 followed by a rapid fall off and an eventual slow fade\n    float dist = 1./length(pos);\n\t// Dampen the glow to control the radius\n    dist *= 0.1;\n\t\n\t// Raising the result to a power allows us to change the glow fade behaviour\n    // See https://www.desmos.com/calculator/eecd6kmwy9 for an illustration\n    // (Move the slider of m to see different fade rates)\n    dist = pow(dist, 0.8);\n\tRGBTime *= iTime;\n\tvec3 col = dist * vec3(sin(RGBTime+uv.x*colorWidth)/2.+0.5, -sin(RGBTime+uv.x*colorWidth)/2.+0.5, cos(RGBTime+uv.x*colorWidth)/2.+0.5);\n\tcol = 1.0 - exp( -col );\n\t\n\t\n\t\t\n\tfragColor = vec4(col,1.);\n\t\n    \n    //fragColor = vec4(uv.yyx,1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fll3W7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 118, 118, 1399]], "test": "valid"}
{"id": "fll3z7", "name": "Sunset Blobbies", "author": "pajunen", "description": "Blobs.", "tags": ["metaballs", "shadow", "volumetric", "preetham"], "likes": 8, "viewed": 79, "published": "Public", "date": "1621860166", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Implementation of 1999 preetham skylight model\n\n#define T 4.5\n#define M_PI 3.1415926535897932384626433832795\n\n// Radiance distribution parameters\nfloat A_x = -0.0193 * T - 0.2592;\nfloat B_x = -0.0665 * T + 0.0008;\nfloat C_x = -0.0004 * T + 0.2125;\nfloat D_x = -0.0641 * T - 0.8989;\nfloat E_x = -0.0033 * T + 0.0452;\n\nfloat A_y = -0.0167 * T - 0.2608;\nfloat B_y = -0.0950 * T + 0.0092;\nfloat C_y = -0.0079 * T + 0.2102;\nfloat D_y = -0.0441 * T - 1.6537;\nfloat E_y = -0.0109 * T + 0.0529;\n\nfloat A_Y =  0.1787 * T - 1.4630;\nfloat B_Y = -0.3554 * T + 0.4275;\nfloat C_Y = -0.0227 * T + 5.3251;\nfloat D_Y =  0.1206 * T - 2.5771;\nfloat E_Y = -0.0670 * T + 0.3703;\n\n// Matrices for chromaticity calculations\nmat4x3 x_chromaticity = mat4x3(\n    0.0017, -0.0290, 0.1169,\n   -0.0037,  0.0638,-0.2120,\n    0.0021, -0.0320, 0.0605,\n    0.0000,  0.0039, 0.2589\n);\n\nmat4x3 y_chromaticity = mat4x3(\n    0.0028, -0.0421,  0.1535,\n   -0.0061,  0.0897, -0.2676,\n    0.0032, -0.0415,  0.0667,\n    0.0000,  0.0052,  0.2669\n);\n\nfloat angle(float z1, float a1, float z2, float a2) {\n\treturn acos(\n        sin(z1) * cos(a1) * sin(z2) * cos(a2) +\n        sin(z1) * sin(a1) * sin(z2) * sin(a2) +\n        cos(z1) * cos(z2));\n}\n\nfloat zenith_chromaticity(float sun_z, mat4x3 coefficients) {\n    vec3 T_vec = vec3(T * T, T, 1);\n    vec4 Z_vec = vec4(sun_z*sun_z*sun_z, sun_z*sun_z, sun_z, 1.0);\n    return dot(T_vec, coefficients * Z_vec);\n}\n\nfloat zenith_luminance(float sun_z) {\n \tfloat chi = (4.0 / 9.0 - T / 120.0) * (M_PI - 2.0 * sun_z);\n    return (4.0453 * T - 4.9710) * tan(chi) - 0.2155 * T + 2.4192;\n}\n\nfloat F(float theta, float gamma, float A, float B, float C, float D, float E) {\n\treturn (1.0 + A * exp(B / cos(theta))) * (1.0 + C * exp(D * gamma) + E * pow(cos(gamma), 2.0));\n}\n\n// CIE-xyY to CIE-XYZ\nvec3 xyY_to_XYZ(float x, float y, float Y) {\n\treturn vec3(x * Y / y, Y, (1.0 - x - y) * Y / y);\n}\n\n// CIE-XYZ to linear RGB\nvec3 XYZ_to_RGB(vec3 XYZ) {\n    mat3 XYZ_to_linear = mat3(\n  \t\t 3.24096994, -0.96924364, 0.55630080,\n        -1.53738318,  1.8759675, -0.20397696,\n        -0.49861076,  0.04155506, 1.05697151\n    );\n    return XYZ_to_linear * XYZ;\n}\n\n// CIE-xyY to RGB\nvec3 xyY_to_RGB(float x, float y, float Y) {\n \tvec3 XYZ = xyY_to_XYZ(x, y, Y);\n   \tvec3 sRGB = XYZ_to_RGB(XYZ);\n    return sRGB;\n}\n\n// Clamps color between 0 and 1 smoothly\nvec3 expose(vec3 color, float exposure) {\n    return vec3(2.0) / (vec3(1.0) + exp(-exposure * color)) - vec3(1.0);\n}\n\nvec2 to_zenith_azimuth(vec3 v) {\n \tfloat zenith = acos(v.y);\n    float azimuth = atan(v.x, v.z);\n    return vec2(zenith, azimuth);\n}\n\nvec3 sun_d;\n\nvec3 sample_sky(vec3 v) {\n    vec3 V = v;\n    \n    if (v.y < 0.) V.y = -V.y;\n        \n    vec2 sun_zenith_azimuth = to_zenith_azimuth(sun_d);  \n    \n    vec2 zenith_azimuth = to_zenith_azimuth(V);\n    \n    float gamma = angle(zenith_azimuth.x, zenith_azimuth.y, sun_zenith_azimuth.x, sun_zenith_azimuth.y);\n    float theta = zenith_azimuth.x;\n    \n    float sun_angular_radius = M_PI / 360.0; // About 0.5 deg\n    \n    \n    float x_z = zenith_chromaticity(sun_zenith_azimuth.x, x_chromaticity);\n    float y_z = zenith_chromaticity(sun_zenith_azimuth.x, y_chromaticity);\n    float Y_z = zenith_luminance(sun_zenith_azimuth.x);\n    \n    float x = x_z * F(theta, gamma, A_x, B_x, C_x, D_x, E_x) / F(0.0, sun_zenith_azimuth.x, A_x, B_x, C_x, D_x, E_x);\n    float y = y_z * F(theta, gamma, A_y, B_y, C_y, D_y, E_y) / F(0.0, sun_zenith_azimuth.x, A_y, B_y, C_y, D_y, E_y);\n  \tfloat Y = Y_z * F(theta, gamma, A_Y, B_Y, C_Y, D_Y, E_Y) / F(0.0, sun_zenith_azimuth.x, A_Y, B_Y, C_Y, D_Y, E_Y);\n    \n    vec3 col = xyY_to_RGB(x, y, Y);\n\n    if (gamma < sun_angular_radius && v.y > 0.) {\n         col = vec3(100000.);\n    }\n    \n    if (v.y < 0.) col = mix(15. * vec3(0.05,0.09,0.15), col, pow(zenith_azimuth.x / (M_PI / 2.), 20.));\n    \n    return col;\n}\n\nfloat smin( float a, float b, float k )\n{\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sphere_dist(vec3 x, vec3 s_pos, float r) {\n    return length(s_pos - x) - r;\n}\n\nfloat shadow_volume(vec3 x, vec3 pos, vec3 d,  float r) {\n    float proj = dot(x - pos,d);\n    if (proj < 0.) return sphere_dist(x, pos, r);\n    return length(x - pos - proj * d) - r;\n}\n\nfloat scene(vec3 x) {\n    float balls = 100000.0;\n    balls = smin(balls, sphere_dist(x, vec3(sin(iTime), cos(iTime), sin(iTime)), .8), 0.7);\n    balls = smin(balls, sphere_dist(x, vec3(-sin(2. * iTime), -cos(0.1 * iTime), sin(iTime)), 0.5), 0.7);\n    balls = smin(balls, sphere_dist(x, vec3(sin(.5 * iTime), -sin(0.8 * iTime + 0.4), 2. * sin(0.3 * iTime)), 0.5), 0.7);\n    return balls;//sphere_dist(x, vec3(0),1.2);\n}\n\n#define EPSILON .00001\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat shadow(vec3 x) {\n    float balls = 100000.0;\n    balls = smin(balls, shadow_volume(x, vec3(sin(iTime), cos(iTime), sin(iTime)), -sun_d, .8), 0.7);\n    balls = smin(balls, shadow_volume(x, vec3(-sin(2. * iTime), -cos(0.1 * iTime), sin(iTime)), -sun_d, 0.5), 0.7);\n    balls = smin(balls, shadow_volume(x, vec3(sin(.5 * iTime), -sin(0.8 * iTime + 0.4), 2. * sin(0.3 * iTime)), -sun_d, 0.5), 0.7);\n    return opS(scene(x - sun_d * 0.01), balls);\n}\n\n\nvec3 normal(vec3 x) {\n    float x_pos = scene(x + vec3(EPSILON, 0, 0));\n    float x_neg = scene(x - vec3(EPSILON, 0, 0));\n    float y_pos = scene(x + vec3(0, EPSILON, 0));\n    float y_neg = scene(x - vec3(0, EPSILON, 0));\n    float z_pos = scene(x + vec3(0, 0, EPSILON));\n    float z_neg = scene(x - vec3(0, 0, EPSILON));\n    \n    float dx = x_pos - x_neg;\n    float dy = y_pos - y_neg;\n    float dz = z_pos - z_neg;\n    \n    return normalize(vec3(dx, dy, dz));\n}\n\nmat3 rotationX( in float angle ) {\n\treturn mat3(\t1.0,\t\t     0,\t\t\t  0,\n\t\t\t \t\t  0, \tcos(angle),\t-sin(angle),\n\t\t\t\t\t  0, \tsin(angle),\t cos(angle));\n}\n\nmat3 rotationY( in float angle ) {\n\treturn mat3(\tcos(angle),\t\t0,\t\tsin(angle),\n\t\t\t \t\t\t\t0,\t\t1.0,\t\t\t 0,\n\t\t\t\t\t-sin(angle),\t0,\t\tcos(angle));\n}\n\nmat3 rotationZ( in float angle ) {\n\treturn mat3(\tcos(angle),\t\t-sin(angle),\t0,\n\t\t\t \t\tsin(angle),\t\tcos(angle),\t\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t1);\n}\n\nvec3 fresnel_schlick(float cosTheta, vec3 F0)\n{\n    return F0 + (max(vec3(1.0), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}   \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x - vec2(0.5, .5 * iResolution.y / iResolution.x);\n    \n    float ROT = 0.5 * iTime + 3.9;\n    \n    sun_d = vec3(0,0,1) * rotationX(-(M_PI / 5.) * (sin(ROT) + 1.) / 2.) * rotationY(sin(ROT + M_PI/2.));\n\n        \n    vec3 cam_pos = vec3(-4.,-1.5, -3); \n    vec3 v = normalize(vec3(uv, 0.2)) * rotationX(-.4) * rotationY(.2);\n        \n    vec3 col = sample_sky(v);\n    \n    float shadow_thickness = 0.0;\n   \n    vec3 ray = cam_pos;\n    for (int i = 0; i < 70; ++i) {\n        float d = scene(ray);\n        float distance_to_shadow = shadow(ray);\n        bool in_shadow = distance_to_shadow < 0.001;\n        \n        if (d < 0.01) {\n            vec3 n = normal(ray);\n            float cos_theta = max(dot(n, -v), 0.0);  \n            vec3 f = fresnel_schlick(cos_theta, vec3(0.1));      \n            vec3 ambient = 13. * vec3(0.05,0.09,0.15);\n            vec3 albedo = vec3(1,1,1);\n            float NdotL = max(dot(n, sun_d), 0.0);                \n            col = ambient + ((1.0 - f) * albedo / M_PI + sample_sky(n) * f) * 1.0 * NdotL; \n            break;\n        }\n                \n        float march = (in_shadow ? min(max(d, 0.01), max(-distance_to_shadow, 0.1)) : min(max(d, 0.01), max(distance_to_shadow, 0.1)));\n        ray += v * march;\n        if (in_shadow) {\n            shadow_thickness += march;\n        }\n    }\n    \n    \n    col = expose(col, 0.3);\n\n    // Output to screen\n    fragColor = exp(- 0.1 * shadow_thickness) * vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fll3z7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1010, 1010, 1063, 1063, 1203], [1205, 1205, 1266, 1266, 1416], [1418, 1418, 1455, 1455, 1586], [1588, 1588, 1668, 1668, 1767], [1769, 1791, 1835, 1835, 1888], [1890, 1915, 1942, 1942, 2147], [2149, 2167, 2211, 2211, 2297], [2299, 2340, 2381, 2381, 2456], [2458, 2458, 2490, 2490, 2590], [2605, 2605, 2630, 2630, 3848], [3850, 3850, 3891, 3891, 3980], [3982, 3982, 4030, 4030, 4066], [4068, 4068, 4125, 4125, 4253], [4255, 4255, 4276, 4276, 4674], [4700, 4700, 4733, 4733, 4759], [4761, 4761, 4783, 4783, 5211], [5214, 5214, 5235, 5235, 5677], [5679, 5679, 5713, 5713, 5824], [5826, 5826, 5860, 5860, 5963], [5965, 5965, 5999, 5999, 6100], [6102, 6102, 6149, 6149, 6221], [6227, 6227, 6284, 6284, 7771]], "test": "valid"}
{"id": "fllGRr", "name": "animated tiling  2", "author": "FabriceNeyret2", "description": ".", "tags": ["2d", "tiling", "short"], "likes": 12, "viewed": 218, "published": "Public API", "date": "1621434684", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of https://shadertoy.com/view/flsGzn\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,S,\n         U = 6.*u/R.y;\n\n    ivec2 I = ivec2(U); bool b = (I.x+I.y)%2 < 1;\n    U = 2.* fract( U ) - 1.;\n    \n    float h = 1.41*fract(iTime/2.+ .2*u.x/R.x),\n          c = 1., p = 9./R.y; \n    if (h>.707) U=U.yx, h=1.41-h;                          // 2nd half of the animation\n    \n    U *= mat2(cos( asin(h) + 1.57*vec4(0,1,-1,0) ));       // rotation\n    U = abs( U.x*U.y > 0. ? c=.5, U : vec2(-U.y,U.x) );    // 4-fold symmetry + c = checker coloring\n    if (b) c = 1.5-c;\n    \n    if (u.y < R.y/2.)                                      // draw contours\n        S =  smoothstep( 2.*p, 0., abs(U-h ) ),\n        O = vec4(   S.y\n                 +( U.y<h ? S.x : 0. )\n                );\n    else                                                   // draw regions\n        S =  smoothstep( p, -p, h-U ),\n        O =  vec4(       S.y * c\n                   + (1.-S.y)*S.x * (1.5-c)\n               //  + (1.-S.x)*(1.-S.y)* ( b ? .5 : 1. )*(h)\n                 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fllGRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 87, 87, 1076]], "test": "error"}
{"id": "fllGzN", "name": "Modified PotatoOS shader", "author": "WaffleWaifu", "description": "vhs  rewind tunnel", "tags": ["wow"], "likes": 0, "viewed": 68, "published": "Public", "date": "1621666062", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 p = (-iResolution.xy + 3.0*fragCoord)/iResolution.y;\n\n    \n    float a = atan(p.y,p.x);\n    \n    vec2 uv = vec2( 1.0/a + 5.4*iTime, a );\n\n    \n    float f = sin(70.0*uv.x)*cos(6.0*uv.y);\n\n    \n    vec3 col = 0.5 + 0.4*sin( 23.0*f + vec3(0.0,2.5,4.0) );\n    \n      \n    col = col+f;\n    \n    \n    fragColor = vec4( col,1 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fllGzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 396]], "test": "valid"}
{"id": "fls3R8", "name": "blood spiral", "author": "yunhai", "description": "just try polar system", "tags": ["learn"], "likes": 3, "viewed": 57, "published": "Public", "date": "1621526619", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SS(a,b,t) smoothstep(a,b,t)\n#define PAI 3.14159265\nvoid mainImage( out vec4 O, in vec2 C )\n{\n    float t=iTime;\n    vec2 uv = (C-.5*iResolution.xy)/iResolution.y;\n    vec2 polar=vec2(atan(-uv.y,-uv.x)/6.2832+.5,length(uv));\n    \n    //glow\n    O.rgb+=SS(.4,.3,polar.y)*vec3(.1,.1,.1)*1.3;\n    \n    //spiral\n    float petalNum=5.;\n    float st=sin(t);\n    float cx=(polar.x+st)*petalNum;\n    float dx=cx+polar.y*st*19.;//distort\n    float y=min(fract(dx),fract(1.-dx));\n    float len=.3;\n    float musk=SS(0.,.02/polar.y,y*len-polar.y+.2);\n    O.rgb*=1.-musk;\n    O.rgb+=musk*vec3(.7,.1,.1);\n    \n    //O.rgb=vec3(atan(-uv.y,-uv.x)/6.2832+.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fls3R8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 100, 100, 652]], "test": "valid"}
{"id": "fls3RB", "name": "runners", "author": "lennyjpg", "description": "dfghhfgdfgh", "tags": ["fghdghgh"], "likes": 6, "viewed": 152, "published": "Public API", "date": "1622337528", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random (vec2 st) {\nreturn fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\nvec2 u = 10. * fragCoord / iResolution.y - .05;\nu.y += iTime*0.3;\nfloat rnd = random(floor(u));\nu = fract(u);\nfloat angle = -sin(iTime * 1.5 * rnd*5.5)*1.8;\nvec2 r = u + vec2(sin(angle),cos(angle)) * .3;\nfloat c = length(r - .5) * 3.;\nfragColor = vec4(smoothstep(c, c *1.2 ,0.6));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fls3RB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 92], [93, 93, 149, 149, 432]], "test": "valid"}
{"id": "fls3Rj", "name": "HelloWorldCine", "author": "adamgoodapp", "description": "Testing cineshader", "tags": ["cineshader"], "likes": 1, "viewed": 1010, "published": "Public API", "date": "1622432580", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(abs(sin(iTime)),0.0,0.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fls3Rj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 314]], "test": "valid"}
{"id": "fls3RS", "name": "Styx", "author": "R3N", "description": "A ray marching scene made by combining different types of noise.\nIt'd probably look better with anti-aliasing but I think the shader is already resource-intensive as is.", "tags": ["procedural", "3d", "raymarching", "noise", "water"], "likes": 16, "viewed": 349, "published": "Public API", "date": "1622323612", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 500.0\n#define MIN_DIST 0.01\n#define pi acos(-1.0)\n#define sat(t) clamp(t, 0.0, 1.0)\n\n// 2D rotation\nvec2 rot(vec2 p, float a) {\n\treturn p*mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\n// Random number between 0 and 1\nfloat rand(vec2 p) {\n\treturn fract(sin(dot(p, vec2(12.543,514.123)))*4732.12);\n}\n\n// Value noise\nfloat noise(vec2 p) {\n\tvec2 f = smoothstep(0.0, 1.0, fract(p));\n\tvec2 i = floor(p);\n\t\n\tfloat a = rand(i);\n\tfloat b = rand(i+vec2(1.0,0.0));\n\tfloat c = rand(i+vec2(0.0,1.0));\n\tfloat d = rand(i+vec2(1.0,1.0));\n\t\n\treturn mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n\t\n}\n\n// Fractal brownian motion\nfloat fbm(vec2 p) {\n    float a = 0.5;\n    float r = 0.0;\n    for (int i = 0; i < 8; i++) {\n        r += a*noise(p);\n        a *= 0.5;\n        p *= 2.0;\n    }\n    return r;\n}\n\n// Sky SDF\nfloat sky(vec3 p) {\n    vec2 puv = p.xz;\n    // Move clouds\n    puv += vec2(-2, 4)*iTime;\n    // Plane with distortion\n\treturn 0.4*(-p.y+25.0+noise(puv/20.0)*1.5*fbm(puv/7.0));\n}\n\n// Mountains SDF\nfloat mountains(vec3 p) {\n    // Add slope so it forms a valley\n    float addSlope = -clamp(abs(p.x/20.0), 0.0, 7.0);\n    // Increase intensity of distortion as it moves away from the river\n    float rockDist = clamp(2.0*abs(p.x/3.0), 0.0, 30.0);\n    // Rock formations\n    float rocks = fbm(vec2(0, iTime/5.0)+p.xz/15.0);\n    // Plane with distortion\n    return p.y-rockDist*rocks+addSlope+10.0;\n}\n\n// River SDF\nfloat river(vec3 p) {\n    // Underwater rocks that disturb the flow of the river\n    // with a modification by pyBlob that adds a pressure hole after each rock\n    float rocks = pow(noise(p.xz/6.0+vec2(0, iTime/1.5)),4.0)\n                  - pow(noise((p.xz-vec2(0,1.5))/6.0+vec2(0, iTime/1.5)),4.0);\n    // Surface waves\n    float waves = 0.75*fbm(noise(p.xz/4.0)+p.xz/2.0-vec2(0,iTime/1.75-pow(p.x/7.0,2.0)))\n                  + 0.75*fbm(noise(p.xz/2.0)+p.xz/2.0-vec2(0, iTime*1.5));\n    // Plane with distortion\n    return p.y+4.0-rocks+waves;\n}\n\n// Scene\nfloat Dist(vec3 p) {\n\treturn min(river(p), min(mountains(p), sky(p)));\n}\n\n// Classic ray marcher that returns both the distance and the number of steps\nvec2 RayMarch(vec3 cameraOrigin, vec3 rayDir) {\n\tfloat minDist = 0.0;\n\tint steps = 0;\n\twhile (steps < MAX_STEPS) {\n\t\tvec3 point = cameraOrigin + rayDir * minDist;\n\t\tfloat d = Dist(point);\n\t\tminDist += d;\n\t\tif(d < MIN_DIST || minDist > MAX_DIST) {\n\t\t\tbreak;\n\t\t}\n\t\tsteps++;\n\t}\n\treturn vec2(minDist, steps);\n}\n\n// Main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy/(iResolution.y);\n\tuv -= iResolution.xy/iResolution.y/2.0;\n    // Camera setup\n\tvec3 cameraOrigin = vec3(0, noise(vec2(0, iTime/4.0))-1.5, 0);\n\tvec3 ray = normalize(vec3(uv.x, uv.y, 0.4));\n    // Camera sway\n    ray.yz = rot(ray.yz, mix(-0.5 , 0.5, 0.25*noise(vec2(0, 0.5+iTime/4.0))+noise(vec2(3.0-iTime/9.0))));\n    ray.xz = rot(ray.xz, mix(-1.0 , 1.0, noise(vec2(5.0+iTime/10.0))));\n    // Ray March\n    vec2 rm = RayMarch(cameraOrigin, ray);\n    // Color is based on the number of steps and distance\n\tvec4 col = pow(vec4(rm.y/100.0),vec4(3.0))+pow(rm.x/MAX_DIST,2.5);\n    // Gamma correction\n\tfragColor = pow(col, vec4(1.0/2.2));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fls3RS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[124, 139, 166, 166, 217], [219, 252, 272, 272, 332], [334, 349, 370, 370, 612], [614, 641, 660, 660, 815], [817, 828, 847, 847, 1006], [1008, 1025, 1050, 1088, 1423], [1425, 1438, 1459, 1597, 1986], [1988, 1997, 2017, 2017, 2069], [2071, 2149, 2196, 2196, 2455], [2457, 2465, 2522, 2522, 3181]], "test": "valid"}
{"id": "fls3z4", "name": "Lit RetroMarching", "author": "wildniklin", "description": "gaem boi but \"realistic\"?", "tags": ["marching"], "likes": 2, "viewed": 151, "published": "Public API", "date": "1621646817", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_STEPS = 100;\nconst float MAX_DIST = 20.0;\nconst float MIN_DIST = 0.001;\n\nconst float PI = 3.1415;\n\nmat2 rot(float r) {\n    float s = sin(r), c = cos(r);\n    return mat2(c, -s, s, c);\n}\n\nfloat rand1(vec3 p) {\n    return fract(sin(dot(p, vec3(12.9898, 78.233, 195.1533))) * 43758.5453123);\n}\n\nfloat sphere(vec3 p, float r) { return length(p) - r; }\n\nfloat map(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = p - i;\n    return sphere(f - 0.5, mix(0.05, 0.25, rand1(i)));\n}\n\nfloat march(vec3 ro, vec3 rd) {\n    float d = 0.0;\n    for(int i = 0; i < MAX_STEPS; i++) {\n        float sd = map(ro + (rd * d));\n        d += sd;\n        if((abs(sd) < MIN_DIST) || (d > MAX_DIST)) break;\n    }\n    return d;\n}\n\nvec3 normal(vec3 p) {\n    vec2 k = vec2(MIN_DIST, 0.0);\n    return normalize(vec3(\n        map(p + k.xyy) - map(p - k.xyy),\n        map(p + k.yxy) - map(p - k.yxy),\n        map(p + k.yyx) - map(p - k.yyx)\n    ));\n}\n\nfloat dither(float c, vec2 i, float depth) {\n    return (step(texture(iChannel3, i * 0.125).x + 0.00001, fract(c * depth)) + floor(c * depth)) / depth;\n}\n\nvoid mainImage(out vec4 o, in vec2 i) {\n    vec2 uv = (i - (0.5 * iResolution.xy)) / min(iResolution.x, iResolution.y);\n\n    vec3 ro = vec3(0.0, 0.0, iTime);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    rd.xy *= rot(iTime * 0.02 * PI);\n\n    float d = march(ro, rd);\n    vec3 p = ro + (rd * d);\n    vec3 n = normal(p);\n\n    float a = smoothstep(MAX_DIST, 0.0, d);\n    a *= max(0.0, dot(n, normalize(vec3(-0.5, 0.5, -0.5))));\n    a *= a * a;\n\n    a = dither(a, i, 1.0);\n    \n    vec3 col = mix(vec3(0.04, 0.1, 0.03), vec3(0.3, 0.7, 0.15), a);\n\n    o = vec4(col, 1.0);\n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 3, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fls3z4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[113, 113, 132, 132, 198], [200, 200, 221, 221, 303], [305, 305, 336, 336, 360], [362, 362, 381, 381, 481], [483, 483, 514, 514, 710], [712, 712, 733, 733, 926], [928, 928, 972, 972, 1081], [1083, 1083, 1122, 1122, 1649]], "test": "error"}
{"id": "fls3zH", "name": "SDFSphere", "author": "nialred", "description": "Basic sphere using signed distance function. Added a box and a lot of distortion.", "tags": ["sdf", "sphere"], "likes": 2, "viewed": 205, "published": "Public API", "date": "1622048385", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\nI DID NOT DO THIS ALONE:\n========================\n\nReferences:\nhttp://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\nhttps://michaelwalczyk.com/blog-ray-marching.html\nhttps://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-generating-camera-rays/generating-camera-rays\nhttps://www.shadertoy.com/view/4sdSDN\n\n*/\n\nconst int MAX_MARCHING_STEPS = 500; // Max steps you are willing to search for a \"hit\"\nconst float MAX_DIST = 1000.0; // Max distance to search for a \"hit\"\nconst float MIN_DIST = 0.0; // Where to start the march \nconst float EPSILON = 0.001; // How close you need to be to be considered a hit\n\nfloat wave = 0.0;\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Sphere\n{\n    vec3 center;\n    float radius;\n};\n\nstruct Box\n{\n    vec3 center;\n    vec3 size;\n    float radius; // fillet\n};\n\n// I don't know where I should define this cause I don't know how this scales\n// once you introduce multiple shapes and whatnot, so I just made it global\nSphere sphere = Sphere(vec3(0.0, 0.0, 0.0), 25.0);\nBox box = Box(vec3(0.0, 0.0, 200.0), vec3(50.0, 100.0, 50.0), 60.0);\n\nvoid rotate_2d(float freq, inout vec2 p)\n{\n    float c = cos(freq);\n    float s = sin(freq);\n    p = vec2((p.x*c) - (p.y*s), (p.x*s) + (p.y*c));\n}\n\nfloat distort_surface(float freq, vec3 point)\n{\n    return sin(freq * point.x) * sin(freq * point.x) * sin(freq * point.y) * sin(freq * point.y)* sin(freq * point.y)* sin(freq * point.z)/ sin(freq * point.z)/ sin(freq * point.z);\n    //return sin(freq * point.x) * tan(freq * point.x) * cos(freq * point.x) * sin(freq * point.y) * sin(freq * point.y)* sin(freq * point.y)/ sin(freq * point.z)/ sin(freq * point.z)/ tan(2.0*freq * point.z);\n    //return sin(freq * point.x) / cos(freq * point.y) / sin(0.025*point.z);\n    //return sin(freq * point.x) * sin(freq * point.x);\n    //return 2.75*sin(freq * point.x) * sin(freq * point.y) * sin(freq * point.z);\n    //return point.x/point.z*point.y/point.x;\n    //return sin(freq*point.x/2.0) * sin(point.y/2.0) * sin(point.z/2.0);\n}\n\nvec3 ray_direction(float fieldOfView, vec2 uv) \n{ \n    float z = 1.0 / tan(radians(fieldOfView) / 2.0); // Distance to image plane\n    return normalize(vec3(uv, z));\n}\n\nfloat sphere_sdf(vec3 point)\n{\n    return length(point - sphere.center) - sphere.radius; // Return distance from sphere\n}\n\nfloat sd_box(vec3 point, Box box_obj, float is_rounded) // box and rounded box\n{\n    vec3 diff = abs(point-box_obj.center) - box_obj.size;\n    return length(max(diff, 0.0)) + \n           min(max(diff.x,max(diff.y,diff.z)),0.0) - // not sure\n           (box_obj.radius * is_rounded);\n}\n\nfloat map_world(vec3 point)\n{   \n    rotate_2d(iTime/15.0, point.xz);\n    float displacement = distort_surface(0.5, point);\n    float dist = sphere_sdf(point); // Distance from sphere \n    float box_dist = sd_box(point, box, 1.0);\n    return min(dist, box_dist) + displacement;\n}\n\nfloat shortest_distance_to_surface(vec3 eye_pos, vec3 march_dir, float start, float end)\n{\n    float depth = start; // Starting point for ray march (0.0)\n    float dist = 0.0;    // Initalize distance from sphere variable\n    int i = 0;           \n    \n    while (i < MAX_MARCHING_STEPS)\n    {\n        dist = map_world(eye_pos + (depth * march_dir)); // Distance to sphere (distorted)\n        \n        if (dist < EPSILON) // If at the surface, return the depth from image plane\n        {\n            return depth;\n        }\n        \n        depth += dist;\n        \n        if (depth >= end) // If at the max marching distance, return the max value\n        {\n            return end;\n        }\n        \n        i += 1;\n     }\n     \n     return end;\n}\n\nvec3 estimate_normal(vec3 point)\n{   \n    vec3 step = vec3(EPSILON, 0.0, 0.0);\n    \n    float gradient_x = map_world(point + step) - map_world(point - step);\n    float gradient_y = map_world(point + step.yxz) - map_world(point - step.yxz);\n    float gradient_z = map_world(point + step.yzx) - map_world(point - step.yzx);\n    \n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n    \n    return normalize(normal);\n}\n\nfloat diffuse(vec3 current_pos, vec3 light_pos, vec3 normal)\n{\n    vec3 light_dir = normalize(light_pos - current_pos);\n    float intensity = max(0.0, dot(normal, light_dir));\n    return intensity;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord/iResolution.xy) * 2.0 - 1.0;\n    wave = 2.0*texture(iChannel0, uv).x;\n    float aspect_ratio = iResolution.x/iResolution.y;\n    uv.x = uv.x * aspect_ratio; // Account for image aspect ratio\n\n    // Define camera position\n    vec3 cam_pos = vec3(0.0, 0.0, -75.0);\n     \n    // Define ray as vector from camera position to pixel position\n    Ray ray = Ray(cam_pos, ray_direction(45.0, uv));\n      \n    // Define light position as a 3D vector\n    vec3 light_pos = vec3(20.0, 50.0, -40.0);\n    \n    // Find distance to surface\n    float dist = shortest_distance_to_surface(ray.origin, ray.direction, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) // If sphere doesn't exist at this pixel draw bg\n    { \n        // Eventually want to have the background be a cubic room \n        fragColor = vec4(0.2, 0.2, 0.2, 0.0);\n    }\n    \n    else // If sphere does exist at this pixel, draw color accordingly using basic lighting\n    {\n        vec3 point = ray.origin + dist*ray.direction;\n        vec3 normal = estimate_normal(point);\n        float intensity = diffuse(point, light_pos, normal);\n        normal = vec3(0.85, 0.95, 0.95) * (intensity);\n        normal = normal + 0.25;\n        fragColor = vec4(normal, 1.0);\n    }\n}", "image_inputs": [{"id": "XdXGRr", "previewfilepath": "/presets/mic.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/mic.png", "ctype": "mic"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fls3zH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1122, 1122, 1164, 1164, 1268], [1270, 1270, 1317, 1317, 2047], [2049, 2049, 2098, 2098, 2216], [2218, 2218, 2248, 2248, 2339], [2341, 2341, 2421, 2421, 2625], [2627, 2627, 2656, 2656, 2906], [2908, 2908, 2998, 2998, 3656], [3658, 3658, 3692, 3692, 4081], [4083, 4083, 4145, 4145, 4282], [4284, 4284, 4341, 4395, 5650]], "test": "error"}
{"id": "flsGD7", "name": "a Spiral of my mishap", "author": "MrNissenDK", "description": "It's from my mishap of a Hue wheel, with a spiral.", "tags": ["spiral", "hue"], "likes": 3, "viewed": 166, "published": "Public API", "date": "1622219066", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float PI = 3.1415926;\nfloat THI = 6.2831853;\n\nvec3 HSV2RGB(vec3 color){//Based on https://www.rapidtables.com/convert/color/hsv-to-rgb.html\n    color.x = fract(color.x);\n    color = clamp(color,0.,1.);\n    \n    float C = color.z * color.y;\n    float X = C * (1. - abs(mod(color.x*360./60.,2.) - 1.));\n    float m = color.z - C;\n    \n    vec3 RGB_1;\n    switch(int(color.x*6.)){\n        case 0:\n            RGB_1 = vec3(C,X,0);\n            break;\n        case 1:\n            RGB_1 = vec3(X,C,0);\n            break;\n        case 2:\n            RGB_1 = vec3(0,C,X);\n            break;\n        case 3:\n            RGB_1 = vec3(0,X,C);\n            break;\n        case 4:\n            RGB_1 = vec3(X,0,C);\n            break;\n        case 5:\n            RGB_1 = vec3(C,0,X);\n            break;\n            \n    }\n    return vec3((RGB_1.x+m),(RGB_1.y+m),(RGB_1.z+m));\n}\nvec3 hsv2rgb(vec3 c){ //one I found bieng used with in this example\n\tvec4 K=vec4(1.,2./3.,1./3.,3.);\n\treturn c.z*mix(K.xxx,clamp(abs(fract(c.x+K.xyz)*6.-K.w)-K.x,0.,1.),c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ((fragCoord - .5 * iResolution.xy) / iResolution.y) * 3.;\n    \n    vec3 col = vec3(0);\n    \n    col += hsv2rgb(vec3(atan(uv.y,uv.x)/THI + iTime / 5. + pow(length(uv),1.5),length(uv)*4.,4.-length(uv)*4.));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flsGD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 71, 139, 860], [861, 861, 882, 928, 1037], [1039, 1039, 1096, 1096, 1348]], "test": "valid"}
{"id": "flsGDH", "name": "\"Closest Neighbour\" Boundaries", "author": "blackle", "description": "exploring domain repetition", "tags": ["domainrepetition", "closest", "neighbour", "domainrep"], "likes": 24, "viewed": 366, "published": "Public API", "date": "1622014331", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//this is further explorations in how domain repetition works\n//and under what scenarios a naively domain repeated object might fail to be an SDF\n\n//this is a visualization of how the closest neighbour SDF inside a domain changes as those SDFs change\n//if we imagine a point within a domain, we can ask \"what is the closest neighbouring SDF?\"\n//in this case, we have 6 boxes in the immediate neighbouring domains.\n//as we move a point within the central domain around, the closest box to that point will change\n//we can visualze the boundaries at which a point stops being closest to one box, and starts being closest to a different box\n//inside the middle box of this shader is such a visualization\n//as the dimensions of the neighbouring boxes change, the shape of the boundaries change.\n\n//when the boxes are perfect cubes, we can model the boundaries with\n//the \"face\" function in this shader: https://www.shadertoy.com/view/Wl3fD2\n//see also the youtube video: https://youtu.be/I8fmkLK1OKg\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax,p)*ax,p,cos(ro)) + sin(ro)*cross(ax,p);\n}\n\nfloat box(vec3 p, vec3 d) {\n    p = abs(p)-d;\n    return length(max(p,0.)) + min(0.,max(max(p.x,p.y),p.z));\n}\n\nfloat obj(vec3 p) {\n    return box(p, vec3(.25,.25,.25+sin(iTime)*.24)) - .01;\n}\n\nbool sort(inout float a, inout float b) {\n    if (b < a) {\n        float tmp = a;\n        a = b; b = tmp;\n        return true;\n    }\n    return false;\n}\n\nint gid;\nfloat scene(vec3 p) {\n    float u = obj(p - vec3(0,0,1));\n    float d = obj(p - vec3(0,0,-1));\n    float e = obj(p - vec3(0,1,0));\n    float w = obj(p - vec3(0,-1,0));\n    float n = obj(p - vec3(1,0,0));\n    float s = obj(p - vec3(-1,0,0));\n    \n    gid = 0;\n    if (sort(u,d)) gid = 1;\n    sort(d,e);\n    sort(e,w);\n    sort(w,n);\n    sort(n,s);\n    \n    if (sort(u,d)) gid = 2;\n    sort(d,e);\n    sort(e,w);\n    sort(w,n);\n    \n    if (sort(u,d)) gid = 3;\n    sort(d,e);\n    sort(e,w);\n    \n    if (sort(u,d)) gid = 4;\n    sort(d,e);\n    \n    if (sort(u,d)) gid = 5;\n    \n    float closest = u;\n    float secondclosest = d;\n    float boundary = (abs(closest-secondclosest)-.01)/2.;\n    boundary = max(boundary, box(p, vec3(.5)));\n    \n    return min(closest,boundary);\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p) - mat3(0.0001);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\n// https://iquilezles.org/www/articles/palettes/palettes.htm\nvec3 palette( float t )\n{\n    return cos(t+vec3(0,1.8,3.2))*.4+.6;\n}\n\nvec3 shade(vec3 p, vec3 cam) {\n    float fid = float(gid);\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n    float fres = 1.-abs(dot(cam,n))*.98;\n    float fact = length(sin(r*3.5)*.5+.5)/sqrt(3.0);\n    return palette(fid)*(fact*.5 + pow(fact,5.)*4.*fres);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n\n    vec3 cam = normalize(vec3(.8,uv));\n    vec3 init = vec3(-2.5,0,0);\n    float yrot = .2;\n    float zrot = iTime/2.;\n    cam = erot(cam,vec3(0,1,0),yrot);\n    init = erot(init,vec3(0,1,0),yrot);\n    cam = erot(cam,vec3(0,0,1),zrot);\n    init = erot(init,vec3(0,0,1),zrot);\n    \n    vec3 p = init;\n    bool hit = false;\n    \n    \n    vec3 col = vec3(0);\n    float atten = .7;\n    float k = 1.;\n    for (int i = 0; i < 200; i++ ) {\n        float dist = scene(p);\n        p += cam*dist*k;\n        if (dist*dist < 1e-7) {\n            col += shade(p, cam)*atten;\n            atten *= .7;\n            p += cam*.005;\n            k = sign(scene(p));\n        }\n        if(distance(p,init)>100.)break;\n    }\n    vec3 spec = shade(p, cam);\n    fragColor = vec4(sqrt(smoothstep(0.,1.,col)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flsGDH.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[1190, 1190, 1228, 1228, 1292], [1294, 1294, 1321, 1321, 1403], [1405, 1405, 1424, 1424, 1485], [1487, 1487, 1528, 1528, 1639], [1650, 1650, 1671, 1671, 2422], [2424, 2424, 2443, 2443, 2562], [2564, 2625, 2650, 2650, 2693], [2695, 2695, 2725, 2725, 2958], [2960, 2960, 3017, 3017, 3865]], "test": "valid"}
{"id": "flsGz7", "name": "Sliding sine rainbow", "author": "sodazot", "description": "Playing around to try to fully understand how the image is constructed overall. Mostly just a modification of the default set up when starting a new shader on here.", "tags": ["2d", "gradient"], "likes": 6, "viewed": 107, "published": "Public", "date": "1621931252", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.141592653589793238462643383279\nfloat speed = -100.0;\nfloat speed2 = 5.5;\nfloat scale = 1.0;\nfloat scale2 = 0.008;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    \n    vec3 color = 0.5 + 0.5 * sin(fragCoord.y*scale2 + sin((fragCoord.x*scale + iTime*speed + vec3(0.0, iResolution.x / 3.0, iResolution / 2.0)) * (pi / (iResolution.x / 2.0))));\n\n    fragColor = vec4(color, 1.0);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flsGz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[128, 128, 183, 183, 404]], "test": "valid"}
{"id": "flsGzH", "name": "Cubic Bezier Spline Distance", "author": "nr4", "description": "Technique:\n* Determine a solution by interval approximation\n* Polynomial division\n* Solve resulting quartic\n* Determine solution with minimum distance\n* Profit", "tags": ["sdf", "bezier", "distance", "curve", "cubic"], "likes": 9, "viewed": 231, "published": "Public", "date": "1621556123", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n * Cubic Bezier Spline Distance\n * \n * Copyright (C) 2021  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n * Update 1: Fixed a glitch related to the initial conditions of the\n *     interval approximation\n * Update 2: Used relative coordinates to simplify the equations\n * Update 3: Combined the dot products to save on computation time\n * \n */\n \nconst vec3 c = vec3(1.,0.,-1.);\nconst float pi = acos(-1.);\n\n// Cubic bezier curve\nvec2 B3(float t, vec2 P0, vec2 P1, vec2 P2, vec2 P3)\n{\n    float m1 = 1.-t;\n    return m1*m1*m1*P0 + 3.*m1*t*(m1*P1+t*P2) + t*t*t*P3;\n}\n\n// Cubic bezier partial derivative with respect to t\nvec2 B3Prime(float t, vec2 P0, vec2 P1, vec2 P2, vec2 P3)\n{\n    float m1 = 1.-t;\n    return 3.*(m1*m1*(P1-P0)+2.*m1*t*(P2-P1)+t*t*(P3-P2));\n}\n\n// Cubic bezier second partial derivative with respect to t\nvec2 B3Second(float t, vec2 P0, vec2 P1, vec2 P2, vec2 P3)\n{\n    float m1 = 1.-t;\n    return 6.*m1*(P2-2.*P1+P0)+6.*t*(P3-2.*P2+P1);\n}\n\n// This is the \"easy\" representation of the quintic that has to be solved\n// for the sdf.\nfloat D3Prime(vec2 x, float  t, vec2 P0, vec2 P1, vec2 P2, vec2 P3)\n{\n    return dot(x-B3(t,P0,P1,P2,P3), B3Prime(t,P0,P1,P2,P3));\n}\n\n// Determine zeros of a*x^2+b*x+c\nvec2 quadratic_zeros(float a, float b, float cc) {\n    if(a == 0.) return -cc/b*c.xx;\n    float d = b*b-4.*a*cc;\n    if(d<0.) return vec2(1.e4);\n    return (c.xz*sqrt(d)-b)/(2.*a);\n}\n\n// Determine zeros of a*x^3+b*x^2+c*x+d\nvec3 cubic_zeros(float a, float b, float cc, float d) {\n    if(a == 0.) return quadratic_zeros(b,cc,d).xyy;\n    \n    // Depress\n    vec3 ai = vec3(b,cc,d)/a;\n    \n    //discriminant and helpers\n    float tau = ai.x/3., \n        p = ai.y-tau*ai.x, \n        q = -tau*(tau*tau+p)+ai.z, \n        dis = q*q/4.+p*p*p/27.;\n        \n    //triple real root\n    if(dis > 0.) {\n        vec2 ki = -.5*q*c.xx+sqrt(dis)*c.xz, \n            ui = sign(ki)*pow(abs(ki), c.xx/3.);\n        return vec3(ui.x+ui.y-tau);\n    }\n    \n    //three distinct real roots\n    float fac = sqrt(-4./3.*p), \n        arg = acos(-.5*q*sqrt(-27./p/p/p))/3.;\n    return c.zxz*fac*cos(arg*c.xxx+c*pi/3.)-tau;\n}\n\n// Determine zeros of a*x^4+b*x^3+c*x^2+d*x+e\nvec4 quartic_zeros(float a, float b, float cc, float d, float e) {\n    if(a == 0.) return cubic_zeros(b, cc, d, e).xyzz;\n    \n    // Depress\n    float _b = b/a,\n        _c = cc/a,\n        _d = d/a,\n        _e = e/a;\n        \n    // Helpers\n    float p = (8.*_c-3.*_b*_b)/8.,\n        q = (_b*_b*_b-4.*_b*_c+8.*_d)/8.,\n        r = (-3.*_b*_b*_b*_b+256.*_e-64.*_b*_d+16.*_b*_b*_c)/256.;\n        \n    // Determine available resolvent zeros\n    vec3 res = cubic_zeros(8.,8.*p,2.*p*p-8.*r,-q*q);\n    \n    // Find nonzero resolvent zero\n    float m = res.x;\n    if(m == 0.) m = res.y;\n    if(m == 0.) m = res.z;\n    \n    // Apply Ferrari method\n    return vec4(\n        quadratic_zeros(1.,sqrt(2.*m),p/2.+m-q/(2.*sqrt(2.*m))),\n        quadratic_zeros(1.,-sqrt(2.*m),p/2.+m+q/(2.*sqrt(2.*m)))\n    )-_b/4.;\n}\n\n// minimum distance to a cubic spline with the following strategy:\nfloat dcubic_spline(in vec2 x, in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3)\n{\n    // Use relative coordinates to eliminate all terms containing p0.\n    x -= p0;\n    p1 -= p0;\n    p2 -= p0;\n    p3 -= p0;\n    p0 = c.yy;\n    \n    // Use interval approximation to determine a numerical solution for the quintic.\n    // TODO: find something better, I really would like an analytical approach\n    float tmin = -0.5, tmax = 1.5, tnew, \n        dmin = D3Prime(x,tmin,p0,p1,p2,p3),\n        dmax = D3Prime(x,tmax,p0,p1,p2,p3),\n        dnew;\n    \n    for(int i=0; i<20; ++i)\n    {\n        tnew = mix(tmin, tmax, .5);\n        dnew = D3Prime(x,tnew,p0,p1,p2,p3);\n        \n        if(dnew>0.)\n        {\n            tmin = tnew;\n            dmin = dnew;\n        }\n        else \n        {\n            tmax = tnew;\n            dmax = dnew;\n        }\n    }\n    \n    // Determine coefficients of quintic equation.\n    vec2 pa = p2-p1;\n    float a5 = -dot(p3,p3)+3.*dot(pa,2.*p3-3.*pa),\n        a4 = 5.*dot(p1-pa,p3)+15.*dot(pa,pa-p1),\n        a3 = -6.*dot(p2,p2)+4.*dot(p1,9.*pa-p3),\n        a2 = dot(p3-3.*pa,x)+9.*dot(p1,p1-pa),\n        a1 = 2.*dot(pa-p1,x)-3.*dot(p1,p1),\n        a0 = dot(p1,x);\n    \n    // Polynomial division of numerical solution.\n    float _a = a5,\n        _b = a4+_a*tmin,\n        _c = a3+_b*tmin,\n        _d = a2+_c*tmin,\n        _e = a1+_d*tmin;\n        \n    vec4 t = clamp(quartic_zeros(_a,_b,_c,_d,_e),0.,1.);\n    tmin = clamp(tmin, 0.,1.);\n    \n    return min(\n        length(x-B3(tmin,p0,p1,p2,p3)),\n        min(\n            min(\n                length(x-B3(t.x,p0,p1,p2,p3)),\n                length(x-B3(t.y,p0,p1,p2,p3))\n            ),\n            min(\n                length(x-B3(t.z,p0,p1,p2,p3)),\n                length(x-B3(t.w,p0,p1,p2,p3))\n            )\n        )\n    );\n}\n\nfloat dlinesegment(in vec2 x, in vec2 p1, in vec2 p2)\n{\n    vec2 da = p2-p1;\n    return length(x-mix(p1, p2, clamp(dot(x-p1, da)/dot(da,da),0.,1.)));\n}\n\n// paint with antialiasing\nfloat sm(in float d)\n{\n    return smoothstep(1.5/iResolution.y, -1.5/iResolution.y, d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Ignore the drawing code, it's messy, I know :)\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    \n    // Control points.\n    vec2 p_0 = .5*vec2(sin(1.1*iTime), .5*cos(3.*iTime)), \n        p_1 = .5*vec2(1.-sin(1.3*iTime), .5-.5*sin(1.3*iTime)),\n        p_2 = .5*vec2(cos(1.5*iTime), .5*sin(1.1*iTime)),\n    \tp_3 = .5*vec2(-sin(1.15*iTime), .5-.5*cos(.2-iTime));\n    \n    float d, \n        da;\n    vec2 xn, n;\n    d = abs(dcubic_spline(uv,p_0,p_1,p_2,p_3))-.01;\n\n    // Draw distance isolines\n    float interval = clamp(.03 * (d-mod(d,.025))/.025, 0., 1.);\n    vec3 col = mix(vec3(1.00,0.90,0.68), vec3(0.98,0.64,0.67), 2.*interval);\n    if(interval > .5) col = mix(col, vec3(0.54,0.80,0.80), 2.*(interval-.5));\n    \n    // Draw handle lines\n    col = mix(col, c.yyx, sm(abs(dlinesegment(uv,p_0,p_1))-.002));\n    col = mix(col, c.yyx, sm(abs(dlinesegment(uv,p_2,p_3))-.002));\n    \n    // Draw bezier curve\n    col = mix(col, c.yyy, sm(d));\n    \n    // Draw control points\n    col = mix(col, .4*c.xxx, sm(abs(mod(d+.0125,.025)-.0125)-.001));\n    col = mix(col, c.xxx, sm(length(uv-p_0)-.015));\n    col = mix(col, c.yyy, sm(abs(length(uv-p_0)-.015)-.002));\n    col = mix(col, c.xxx, sm(length(uv-p_1)-.015));\n    col = mix(col, c.yyy, sm(abs(length(uv-p_1)-.015)-.002));\n    col = mix(col, c.xxx, sm(length(uv-p_2)-.015));\n    col = mix(col, c.yyy, sm(abs(length(uv-p_2)-.015)-.002));\n    col = mix(col, c.xxx, sm(length(uv-p_3)-.015));\n    col = mix(col, c.yyy, sm(abs(length(uv-p_3)-.015)-.002));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flsGzH.jpg", "access": "shaders20k", "license": "gpl-3.0-plus", "functions": [[1050, 1072, 1126, 1126, 1207], [1209, 1262, 1321, 1321, 1403], [1405, 1465, 1525, 1525, 1599], [1601, 1691, 1760, 1760, 1823], [1825, 1859, 1909, 1909, 2041], [2043, 2083, 2138, 2138, 2754], [2756, 2802, 2868, 2868, 3601], [3603, 3670, 3750, 3820, 5465], [5467, 5467, 5522, 5522, 5618], [5620, 5647, 5669, 5669, 5736], [5738, 5738, 5795, 5849, 7351]], "test": "error"}
{"id": "flX3R2", "name": "Hugo Elias's hash.", "author": "Envy24", "description": "noise, random, hash\n\nHugo Elias's hash.", "tags": ["noise", "random", "hash"], "likes": 2, "viewed": 82, "published": "Public", "date": "1622398726", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* \n    Hugo Elias's hash.\n    \n    Returns hash in range [-1.0f; 1.0f]. \n*/\nfloat noise1D(uint x)\n{\n     x = (x << 13) ^ x;\n     \n     float t = float((x * (x * x * 15731u + 789221u) + 1376312589u) & 0x7fffffffu);\n     \n     return 1.0f - (t / 1073741824.0f);\n}\n\nfloat noise2D(vec2 p, float enthropy)\n{\n     uint offset = uint((floor(p.y) * enthropy) + floor(p.x));\n\n     return noise1D(offset);\n}\n\n#define GOOD_ENTHROPY_VALUE 800.0\n#define BAD_ENTHROPY_VALUE 40.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float u = fragCoord.x / iResolution.x;\n    float gray = 0.0f;\n\n    if (u < 0.33)\n    {\n       gray = (noise2D(fragCoord, GOOD_ENTHROPY_VALUE) + 1.0f) * 0.5f;\n    }\n    else if (u >= 0.33 && u < 0.66)\n    {\n       gray = (noise2D(fragCoord, iTime * 1.0) + 1.0f) * 0.5f; \n    }\n    else\n    {\n       gray = (noise2D(fragCoord, BAD_ENTHROPY_VALUE) + 1.0f) * 0.5f;\n    }\n\n    // Output to screen\n    fragColor = vec4(gray, gray, gray, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flX3R2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 77, 100, 100, 262], [264, 264, 303, 303, 398], [467, 467, 524, 524, 967]], "test": "valid"}
{"id": "flX3W4", "name": "box dance", "author": "geoffp", "description": "playing around with patterns", "tags": ["patternboxes"], "likes": 3, "viewed": 56, "published": "Public", "date": "1622044613", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float inBox ( vec2 uv, vec2 pmin, vec2 pmax ){\n    return step( pmin.x, uv.x ) * ( 1.0 - step( pmax.x, uv.x ) ) *  step( pmin.y, uv.y ) * ( 1.0 - step( pmax.y, uv.y ) ) ;\n}\n\nfloat widthBox ( vec2 uv, float xc, float yc, float xw, float yw ){\n    float minx = xc - xw / 2.0;\n    float maxx = xc + xw / 2.0;\n    float miny = yc - yw / 2.0;\n    float maxy = yc + yw / 2.0;\n    return inBox ( uv, vec2(minx,miny), vec2(maxx,maxy) );\n}\n\nvec3 boxes( vec2 uv)\n{\n   \n    float columns[6] = float[6]( .142, .285, .428, .571, .714, .857 );\n    float rows[4] = float[4]( .865, .625, .385, .145 );\n    vec3 result = vec3(0.0);\n    float mask = 0.0;\n    \n    for ( int i = 0; i < 24; i++ ){\n        mask = widthBox( uv, columns[i%6], rows[int(i/6)], mix(0.1,.2,abs(sin(iTime+float(i)*uv.x*.1))),mix(0.1,0.5,abs(sin(iTime+float(i)+.25*uv.x*.1))) );\n        result = mix ( result, vec3( (sin(iTime+float(i))+1.)/2.,(sin(iTime+float(i+3)+.855)+1.)/2.,(sin(iTime*3.+float(i+1)+.657)+1.)/2. ), mask );\n    }\n    \n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;   \n    vec3 col = boxes( uv );\n    fragColor = vec4(col,1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flX3W4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 46, 46, 172], [174, 174, 241, 241, 430], [432, 432, 454, 454, 1015], [1017, 1017, 1074, 1074, 1183]], "test": "valid"}
{"id": "flX3z8", "name": "2D Random xxx", "author": "xxxbbbooo", "description": "Shader学习记录", "tags": ["random"], "likes": 0, "viewed": 30, "published": "Public", "date": "1621480283", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float factor = 43758.5453123;\nconst float v1 = 12.9898;\nconst float v2 = 78.233;\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy, vec2(v1,v2)))*iTime*10.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float rnd = random(uv);\n\n    // Output to screen\n    fragColor = vec4(vec3(rnd),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flX3z8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[88, 88, 112, 112, 172], [174, 174, 231, 281, 414]], "test": "valid"}
{"id": "flXGRH", "name": "LineVHS", "author": "antoinefortin", "description": "I dont really know what I am doing tbh", "tags": ["rsandom"], "likes": 2, "viewed": 53, "published": "Public", "date": "1621486244", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 N22(vec2 p)\n{\n    vec3 a = fract(p.xyx * vec3(234.34, 323.5, 948.33));\n    a += dot(a, a+34.55);\n    return fract(vec2(a.x * a.y, a.y * a.z));\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (2.0 * fragCoord-iResolution.xy) / iResolution.y;\n    uv *= .5;\n    float m = 0.0;\n    float t = iTime;\n    float minDist = 100.;\n    \n    \n    \n    for(float i = 0.; i < 50.; i++)\n    {\n        vec2 n = N22(vec2(i));\n        vec2 p = sin((n * t));\n        \n        float d = length(uv - p);\n        \n        m += smoothstep(.05, .03, d);\n        \n        if(d < minDist)\n        {\n            minDist = d;\n        }\n        \n    }\n    \n\n    vec2 n = N22(vec2(12. + (uv.x + abs(cos(uv.y * .056)) * .15)));\n    vec2 p = sin(n + (iTime));\n    float d = length(uv + p);\n    vec3 point1 = vec3(smoothstep(.03, .05, d));\n    \n    vec2 random2 = N22(vec2(25. + (uv.y * 0.005), 12. + (uv.y * .005)));\n    vec2 p2 = sin(random2 * (iTime));\n    float d2 = length(uv + p2);\n    vec3 point2 = vec3(smoothstep(.7, .5, d2));\n    \n    vec3 one = vec3(1.);\n    \n    //vec3 col = (point2 * point1);\n    vec3 col = one - point1;\n    col += one - point2;\n    \n    col = one - (point1 * point2);\n    col = point1 * point2;\n    \n    \n    vec3 debugShit = vec3(0.);\n    debugShit= vec3(1.) - vec3(clamp(distance(d * sin(iTime),d2 * 3. + uv.y), 0., 1.));\n    debugShit = abs(sin(debugShit) * cos(debugShit));\n    \n    // Output to screen\n    fragColor = vec4(debugShit ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flXGRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 154], [156, 156, 213, 213, 1488]], "test": "valid"}
{"id": "flXGW7", "name": "Noisy Dithering", "author": "lambmeow", "description": "Created a dithering effect by offsetting the pixel screen coordinates.\n\nLooks better in fullscreen", "tags": ["2d", "noise", "fbm", "gradient", "dithering"], "likes": 0, "viewed": 172, "published": "Public API", "date": "1622166461", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Noisy Dither\n//Lopea\n//2021\n\n#define time iTime\n\n//IQ's Gradient noise algorithm\n/////////////////////////////////////////////////////////////////////////////\nvec2 random(vec2 st)\n{\n    st = vec2( dot(st,vec2(127.1,331.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\nfloat noise(vec2 uv)\n{\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    \n    vec2 a  = random(i);\n    vec2 b = random(i + vec2(1,0));\n    vec2 c = random(i + vec2(0, 1));\n    vec2 d = random(i + vec2(1, 1));\n    \n    vec2 u = f * f * f *(f *(f*6. - 15.)+10.);\n    \n    return mix(mix ( dot( a, f), dot(b, f - vec2(1, 0)), u.x),\n        mix ( dot( c, f-vec2(0,1)), dot(d, f - vec2(1, 1)), u.x), u.y);\n\n}\n/////////////////////////////////////////////////////////////////////////////\n\n//fractal brownian motion\nfloat fbm(vec2 uv)\n{\n    //store the result of the noise texture\n    float result = 0.;\n    \n    //store the current amplitude value\n    float amplitude = 1.;\n    \n    //iterate a few times to give noise a more detailed look\n    for(int i = 0; i < 8; i++)\n    {\n        //add to the result ( with a few modifications\n        result += noise(uv + vec2( time - float(i)  +10., -time/25.- float(i)/2.)) * amplitude;\n        \n        //shrink the noise texture for the next iteration\n        uv *= 2.;\n        \n        //make next noise iteration less potent \n        amplitude *= 0.5;\n    }\n    \n   \n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    //set the threshold for color value, will be compared to screen space.\n    float threshold = fbm(vec2(fbm(uv * 10.), fbm(uv * 10. + 3.)));\n    \n    //create the dithering effect by warping the screen coordinates\n    float coord = sin(uv.x * 1000.) * sin(uv.y * 1000.) * .25;\n    \n    //compare warped screen coords to the threshold and create the color value\n    vec3 color = mix(vec3(0, .04, .1), vec3(0,1,1) , vec3(step(coord, threshold)));\n    \n    //create an outline effect by subracting same algorithm but with a smaller threshold\n    color -= step(clamp(coord, 0., 1.), threshold - .1) * vec3(1);\n    \n    //set the color to the pixel\n    fragColor = vec4(color , 1);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flXGW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 161, 183, 183, 322], [324, 324, 346, 346, 729], [809, 835, 855, 899, 1452], [1454, 1454, 1511, 1561, 2288]], "test": "valid"}
{"id": "fs2SWD", "name": "Neon Color Falloff", "author": "sdfgeoff", "description": "The neon function provides a nice color ramp falloff for lighting glowing things.", "tags": ["color", "neon"], "likes": 4, "viewed": 289, "published": "Public", "date": "1620261520", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 neon(float val, vec3 color) {\n\tfloat r = clamp(val, 0.0, 1.0);\n    float r2 = r * r;\n    float r4 = r2 * r2;\n    float r16 = r4 * r4;\n    vec3 c = color;\n    vec3 c2 = pow(color, vec3(4.0)); // A darker, more saturated version of color\n    \n\tvec3 outp = vec3(0.0);\n\toutp += c2 * r2; // Darker color falloff\n\toutp += c * r4; // Specified Color main part\n\toutp += vec3(1.0) * r16; // White core\n\treturn outp;\n}\n\nfloat ncos(float val) {\n    return cos(val) * 0.5 + 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // A gradient from white in the center to black at the edges\n    float center_bar = (1.0 - abs(uv.x - 0.5)) * 2.0 - 1.0;\n    \n    // Color for the bar\n    vec3 color = vec3(ncos(iTime), ncos(iTime + 2.0), ncos(iTime + 4.0));\n    \n    vec3 col = neon(center_bar, color);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs2SWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 413], [415, 415, 438, 438, 473], [475, 475, 532, 582, 955]], "test": "valid"}
{"id": "fs2XDd", "name": "Wave Room 2", "author": "dr2", "description": "Immersive art using dynamic wraparound texture (mouseable)", "tags": ["wave", "texture"], "likes": 14, "viewed": 226, "published": "Public API", "date": "1621321763", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Wave Room 2\" by dr2 - 2021\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nvec2 Rot2D (vec2 q, float a);\nmat3 StdVuMat (float el, float az);\nfloat Noisefv2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nfloat dstFar, tCur, bSize, tWav;\nint idObj;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p)\n{\n  vec4 sLen;\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  q = p;\n  q.y -= - bSize + 0.25 * bSize;\n  d = PrSphDf (q, 0.35 * bSize);\n  DMIN (1);\n  sLen = vec4 (vec3 (bSize) - 0.03, 0.03);\n  q = abs (p);\n  d = min (min (\n     PrRoundBoxDf (q - sLen.wyz, sLen.xww, 0.02),\n     PrRoundBoxDf (q - sLen.xwz, sLen.wyw, 0.02)),\n     PrRoundBoxDf (q - sLen.xyw, sLen.wwz, 0.02));\n  DMIN (2);\n  q = p;\n  q.y = abs (q.y) - bSize;\n  d = PrRoundCylDf (q.xzy, 0.4 * bSize, 0.02, 0.01);\n  DMIN (2);\n  q = p;\n  d = - PrBoxDf (q, vec3 (bSize + sLen.w));\n  DMIN (3);\n  q = p;\n  q.y -= bSize - 0.22 * bSize;\n  d = PrSphDf (q, 0.22 * bSize);\n  DMIN (4);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat WaveHt (vec2 p)\n{\n  mat2 qRot;\n  vec4 t4, v4;\n  vec2 t2;\n  float wFreq, wAmp, ht;\n  qRot = mat2 (0.8, -0.6, 0.6, 0.8);\n  wFreq = 1.;\n  wAmp = 1.;\n  ht = 0.;\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    p *= qRot;\n    t4 = (p.xyxy + tWav * vec2 (1., -1.).xxyy) * wFreq;\n    t4 += 2. * vec2 (Noisefv2 (t4.xy), Noisefv2 (t4.zw)).xxyy - 1.;\n    t4 = abs (sin (t4));\n    v4 = (1. - t4) * (t4 + sqrt (1. - t4 * t4));\n    t2 = 1. - sqrt (v4.xz * v4.yw);\n    t2 *= t2;\n    t2 *= t2;\n    ht += wAmp * dot (t2, t2);\n    wFreq *= 2.;\n    wAmp *= 0.5;\n  }\n  return ht;\n}\n\nvec4 WaveNfH (vec2 p)\n{\n  vec3 v;\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  p *= 16.;\n  for (int j = VAR_ZERO; j < 3; j ++) v[j] = WaveHt (p + ((j == 0) ? e.yy : ((j == 1) ? e.xy : e.yx)));\n  return vec4 (- normalize (vec3 (0.4 * (v.x - v.yz), e.x)), v.x);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, hn4;\n  vec3 vn, col, ltDir;\n  vec2 u;\n  float dstObj, rAz, rEl;\n  bool isRefl;\n  tWav = 0.2 * tCur;\n  dstObj = ObjRay (ro, rd);\n  isRefl = false;\n  if (dstObj < dstFar && idObj == 1) {\n    ro += rd * dstObj;\n    vn = ObjNf (ro);\n    rd = reflect (rd, vn);\n    ro += 0.01 * rd;\n    dstObj = ObjRay (ro, rd);\n    isRefl = true;\n  }\n  if (dstObj < dstFar) {\n    ro += rd * dstObj;\n    vn = ObjNf (ro);\n    if (idObj == 2) {\n      col4 = vec4 (0.7, 0.7, 0.8, 0.1);\n      vn = VaryNf (32. * ro, vn, 1.);\n    } else if (idObj == 3) {\n      rAz = atan (ro.x, ro.z);\n      rEl = asin (ro.y / length (ro));\n      u = vec2 (rAz + pi, tan (2. * atan (0.5 * rEl))) / (2. * pi);\n      hn4 = mix (WaveNfH (u), WaveNfH (u - vec2 (1., 0.)), u.x);\n      vn = StdVuMat (rEl, rAz) * normalize (hn4.xyz);\n      col4 = vec4 (mix (vec3 (0.4, 1., 0.8), vec3 (0.3, 0.7, 1.), smoothstep (0.3, 1., hn4.w)), 0.2);\n    } else if (idObj == 4) {\n      col4 = vec4 (1., 1., 0.9, -1.);\n    }\n    if (col4.a >= 0.) {\n      ltDir = normalize (- ro);\n      col = col4.rgb * (0.1 + 0.9 * max (dot (vn, ltDir), 0.)) +\n         col4.a * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.);\n    } else col = col4.rgb * (0.6 - 0.4 * dot (rd, vn));\n    if (isRefl) col *= 0.9;\n  } else col = vec3 (0.);\n  return clamp (col, 0., 1.);  \n}\n\n#define AA  0   // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, uvv;\n  float el, az, asp, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  el = clamp (el, -0.35 * pi, 0.35 * pi);\n  dstFar = 20.;\n  bSize = 2.;\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -0.95 * bSize);\n  zmFac = 1.5;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = vec2 (2. * tan (0.5 * atan (uv.x / (asp * zmFac))) * asp * zmFac, uv.y);\n    rd = vuMat * normalize (vec3 (uvv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (Maxv3 (d), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  }\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs2XDd.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[584, 584, 606, 606, 1257], [1259, 1259, 1292, 1292, 1475], [1477, 1477, 1498, 1498, 1753], [1755, 1755, 1778, 1778, 2318], [2320, 2320, 2343, 2343, 2571], [2573, 2573, 2608, 2608, 3916], [3960, 3960, 4016, 4016, 5106], [5108, 5108, 5130, 5130, 5168], [5170, 5170, 5202, 5202, 5286], [5288, 5288, 5334, 5334, 5381], [5383, 5383, 5416, 5416, 5443], [5445, 5445, 5502, 5502, 5578], [5580, 5580, 5610, 5610, 5723], [5725, 5725, 5761, 5761, 5967], [6001, 6001, 6025, 6025, 6085], [6087, 6087, 6111, 6111, 6223], [6225, 6225, 6250, 6250, 6436], [6438, 6438, 6467, 6467, 6679], [6681, 6681, 6720, 6720, 6977]], "test": "error"}
{"id": "fs2XW3", "name": "[Dwarven Stonework]", "author": "Langwedocjusz", "description": "And they call it a mine. A mine!", "tags": ["raymarching"], "likes": 0, "viewed": 42, "published": "Public", "date": "1621174152", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 96\n#define MAX_DIST 100.0\n#define MIN_DIST 0.01\n\n//---Primitive SDFs:\n\nfloat BoxSDF(vec3 point, vec3 box_dims ){\n  vec3 q = abs(point) - box_dims;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - 0.005;\n}\n\nfloat PrismSDF(vec3 point, vec2 h){\n  vec3 q = abs(point);\n  return max(q.z-h.y, max(q.x*0.866025+point.y*0.5,-point.y)-h.x*0.5) - 0.005;\n}\n\n//Rotated by 90 degrees\nfloat Prism2SDF(vec3 point, vec2 h){\n  vec3 q = abs(point);\n  return max(q.x-h.y, max(q.z*0.866025+point.y*0.5,-point.y)-h.x*0.5) - 0.005;\n}\n\n//Union of both prisms\nfloat Prisms(vec3 point, vec2 h){\n    return min(PrismSDF(point, h), Prism2SDF(point, h));\n}\n\n//Prisms on top of a box\nfloat Base(vec3 point, vec2 h){\n    vec3 box_dims = vec3(h.x, 1.0, h.y);\n    return min(Prisms(point, h), max(BoxSDF(point, box_dims), point.y + 0.06));\n}\n\n//Three bases with different sizes and translations unioned with a tall box\nfloat Column(vec3 point){\n    vec3 box_dims = vec3(0.1, 1.0, 0.1);\n    vec2 h = vec2(0.12,0.12);\n    vec3 translation = vec3(0.0, 0.1, 0.0);\n    return min(BoxSDF(point, box_dims),\n               min(Base(point, h), \n                   min(Base(point + translation, 1.12*h),\n                       Base(point + 5.0*translation, 1.12*1.12*h))));\n}\n\n//Using \"mod\" to make space periodic (infinite columns)\nfloat Columns(vec3 point, vec3 period)\n{\n    vec3 q = mod(point+0.5*period,period)-0.5*period;\n    return Column(q);\n}\n\n//---Final scene SDF:\nfloat Map(vec3 point){\n    vec3 period = vec3(1.5, 0.0, 1.5);\n    vec3 translation = vec3(0.75, 0.0, 0.75);\n    \n    //Mirroring the columns vertically\n    vec3 point2 = point;\n    point2.y = -abs(point2.y - 0.4) + 0.4;\n    \n    //Columns + floor plane\n    return min(Columns(point2 - translation, period), point.y + 0.6);\n}\n\n//---Distance Marching:\nfloat March(vec3 origin, vec3 ray){\n    float total_distance = 0.0, current_distance = 0.0;\n    vec3 position;\n    \n    //Number of iterations affects accuracy (self explanatory)\n    for (int i = 0; i < MAX_STEPS; ++i){\n        position = origin + ray * total_distance;\n        \n        current_distance = Map(position);\n        \n        //Numeric value below affects accuracy (rate of convergence near the surface)\n        total_distance += 1.0 * current_distance;\n        \n        //Kill the loop if it gets too far away, or too close to the surface\n        if (total_distance > MAX_DIST || total_distance < MIN_DIST) break;\n    }\n    return total_distance;\n}\n\n//---Rendering functions:\n\n//Normal to the surface as normalized gradient of SDF\nvec3 getNormal(vec3 point){\n    vec2 h = vec2(0.0001,0); \n    //Central differences, normalization makes 2h in the denominator obsolete\n    return normalize( vec3(Map(point+h.xyy) - Map(point-h.xyy),\n                           Map(point+h.yxy) - Map(point-h.yxy),\n                           Map(point+h.yyx) - Map(point-h.yyx) ) );\n}\n\n//Nice algorithm for soft shadows:\n//https://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat SoftShadow(vec3 origin, vec3 ray){\n    float dmin = 0.01, dmax = 100.0, factor = 1.0, ph = 1e20, final = 0.0;\n    for (float dist = dmin; dist<dmax;) {\n        float h = Map(origin + dist* ray);\n        if (h<0.001)\n            return 0.05;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        factor = min(factor, 64.0*d/max(0.0,dist-y));\n        ph = h;\n        dist += h;\n    }\n    return factor;\n}\n\n//Direct illumination:\nfloat getDiff(vec3 point, vec3 normal, vec3 light_direction, bool shadow){\n    float diffuse = dot(light_direction, normal);\n    diffuse = clamp(diffuse, 0.0, 1.0);\n    \n    if(shadow){\n        return diffuse * SoftShadow(point + 0.1*normal, light_direction);\n    }\n    \n    else {\n        return diffuse;    \n    }\n    \n}\n\nfloat hash(float x){\n    return fract(sin(x) * 43758.5453123);\n}\n\n//Naive classical AO, lifted from here:\n//http://www.aduprat.com/portfolio/?page=articles/hemisphericalSDFAO\nfloat AmbientOcclusion(vec3 point, vec3 normal)\n{\n    float AO = 0.0, maxDist = 0.025, falloff=0.66;\n    const int nbIte = 24;\n    for( int i=0; i<nbIte; i++ )\n    {\n        float l = hash(float(i))*maxDist;\n        vec3 rd = normal*l;\n\n        AO += (l - max(Map( point + rd ),0.)) / maxDist * falloff;\n    }\n\n    return clamp( 1.0 - AO/float(nbIte), 0.0, 1.0);\n}\n\n//Ugly placeholder nonsense, mod creates \"tiles\", q is responsible for domain warping\nvec3 mTexture(vec2 coords){\n    vec2 q = coords;\n    q.x += sin(2.0 * q.y);\n    q.y -= sin(2.0 * q.x);\n    return 64.0 * (mod(q.x, 0.05) * mod(q.y, 0.05) + 0.007) * vec3(1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalize pixel coordinates to (0;1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //Convert to (-1;1)\n    uv = 2.0 * uv - 1.0;\n    //Correct for aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //Generate field of ray vectors by taking pixel coordinates and assigning constant value as the 3rd component\n    //Magnitude of the 3rd component controls the field of view\n    vec3 ray = normalize(vec3(uv, 1.0));\n    \n    //Specify the origin (camera position)\n    vec3 origin = vec3(0.0, 0.0, -3.0 + 0.1*iTime);\n    \n    float dist = March(origin, ray);\n    vec3 point = origin + dist * ray;\n    vec3 normal = getNormal(point), color;\n    \n    vec3 sun = normalize(vec3(1.0, 1.2, -0.5));\n    vec3 sky = normalize(vec3(-1.0, 1.2, 0.5));\n    \n    //Projecting the texture\n    //vec3 colXZ = mTexture( (point.xz) * 0.5 + 0.5);\n    //vec3 colYZ = mTexture( (point.yz) * 0.5 + 0.5);\n    //vec3 colXY = mTexture( (point.xy) * 0.5 + 0.5);\n    //vec3 object_color = abs(normal.x) * colYZ + abs(normal.y) * colXZ + abs(normal.z) * colXY ;\n    vec3 object_color = vec3(1.0);\n    \n    //Background gradient\n    if (dist >= MAX_DIST / 5.0) {\n        color = vec3(0.2, 0.3*(1.0 - uv.y), 0.6);\n    }\n    //Actual rendering\n    else {\n        color = object_color * (1.0 * getDiff(point, normal, sun, true) * vec3(1.0, 1.0, 0.9)\n              + AmbientOcclusion(point, normal) * (\n                0.33 * getDiff(point, normal, sky, false) * vec3(0.4, 0.4, 1.0)\n              + 0.35 ) );\n    }\n\n    // Output to screen (4th component is alpha)\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs2XW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 89, 130, 130, 236], [238, 238, 273, 273, 377], [379, 403, 439, 439, 543], [545, 568, 601, 601, 660], [662, 687, 718, 718, 841], [843, 919, 944, 944, 1265], [1267, 1323, 1363, 1363, 1441], [1443, 1465, 1487, 1487, 1789], [1791, 1815, 1850, 1850, 2476], [2505, 2559, 2586, 2586, 2892], [2894, 2995, 3035, 3035, 3422], [3424, 3447, 3521, 3521, 3769], [3771, 3771, 3791, 3791, 3835], [3837, 3946, 3995, 3995, 4310], [4312, 4398, 4425, 4425, 4575], [4577, 4577, 4634, 4678, 6216]], "test": "valid"}
{"id": "fs2XWK", "name": "Flight 2001", "author": "ilyaev", "description": "Space flight ", "tags": ["tunnel", "raymarch", "flight"], "likes": 8, "viewed": 204, "published": "Public", "date": "1621637501", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 200\n#define MAX_DIST 15.\n#define SURF_DIST .001\n#define MAT_BALL  1.\n#define MAT_WALLS  2.\n#define SINGLE_SCENE false\n#define TUNNEL_SPEED .4\n\n\nfloat smin( float a, float b)\n{\n    float k = .4;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat n21(vec2 n) {\n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n    //  return fract(sin(n.x*123.231 + n.y*4432.342)*33344.22);\n}\n\nvec3 renderDebris(vec3 p) {\n    float Width = 1.;\n    float Height = 1.;\n\n    float Thick = .1;\n\n    float Step = 3.5;\n\n    vec3 c = vec3(0., 0., Step);\n    vec3 q = p;\n    if (SINGLE_SCENE != true) {\n        q = mod(p + 0.5 * c, c) - 0.5 * c;\n    }\n\n    q.yz *= Rot(3.14/2.);\n\n    float id = round(p.z / Step) + 4.;\n\n    float n = n21(vec2(id, 1.));\n\n    // if (n > .9) {\n    if (mod(id, 4.) == 0.) {\n        q.xz *= Rot(id * 1. + sin(iTime) * .5 + iTime*clamp((n - .5)*3., 0., 1.));\n    }\n\n    float left = sdBox(abs(q) - vec3(Width*.9, Width / 2., 0.), vec3(Thick, Width/2., Width));\n    float right = sdBox(abs(q) - vec3(0., Width / 2., Width), vec3(Width, Width/2., Thick));\n\n\n    float rad = .05 + 0.05 * n;\n\n    float circ = length(q + vec3(sin(iTime*n + id) * .9 * n, sin(iTime*n)*.2, cos(iTime*n*1.2 + id * 2.)*.9*n)) - rad;\n    float d = circ;\n\n    d = smin(d, min(left, right));\n\n    \n\n    float mat = MAT_WALLS;\n\n    return vec3(d, id, mat);\n}\n\n\nvec3 GetDist(vec3 p) {\n    return renderDebris(p);\n}\n\nvec4 RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    vec3 res = vec3(0.);\n    float k = 0.;\n\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        res = GetDist(p);\n        float dS = res.x;\n        dO += dS*.7;\n        k += 1.;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n\n    return vec4(dO, res.y, res.z, k);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n\n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 Transform(vec3 p) {\n    if (SINGLE_SCENE == true) {\n        return p;\n    }\n     return p + vec3(0. + cos(iTime)*.2,0. + sin(iTime)*.3,-iTime*2.);\n}\n\nvec3 renderPlasma(vec2 uv) {\n    for(float i = 1.0; i < 3.0; i++){\n        uv.x += .6 / i * cos(i * 2.5* uv.y + iTime);\n        uv.y += 0.6 / i * cos(i * 3.5 * uv.y + iTime);\n    }\n    vec3 col = .5 + 0.5*sin(iTime*5. + uv.yyy + vec3(iTime,2. + iTime,4. + iTime));\n    //return col/(2.1*abs(cos(iTime-uv.x)));\n    float nums = 0. + floor(n21(vec2(floor(iTime), 43))*5.);\n\n    return col/(2.1*abs(cos(uv.x * nums)));\n    // return col/(2.1*abs(cos(uv.x * 2.)));\n}\n\nvec3 renderField(vec2 uv, float index) {\n    vec3 col = vec3(.02);\n\n    vec2 ouv = uv;\n    float l = pow(TUNNEL_SPEED/length(uv), .30);\n    float a = atan(uv.x, uv.y);\n\n    float warp = iTime / 3.;\n\n    // uv = vec2(a - sin(abs(uv.x*uv.y)/58.), l + warp);\n    // uv = vec2(a - abs(uv.y/30.)*sin(iTime*5.)*cos(iTime*3. + uv.x/2.), l + warp);\n    // uv = vec2(a, l + warp + uv.x*uv.y/10.);\n    uv = vec2(a, l + warp);\n\n    ouv = uv;\n\n    vec2 cells = vec2(10., 10.);\n\n    uv *= cells;\n\n    vec2 id = floor(uv);\n    uv = fract(uv);\n\n    float n = n21(id + index * 100.);\n    float n1 = fract(n*123.543 + index * 2.);\n    float n2 = fract(n*4435.332 + index * 4.);\n\n    if (index == 2.) {\n        col.rgb = renderPlasma(ouv/2.)*l/15.; //*smoothstep(0.3, .9, ouv.x);\n    }\n\n    float star = step(uv.x, n) - step(uv.x, n-.05);\n    star *= step(uv.y, n1) - step(uv.y, n1-(.3*n2));\n\n    col.rgb += vec3(star) * (1. - l/2.);\n    // col.rgb = vec3(step(length(uv - vec2(n1,n2)), .1*n2)) * .4;\n\n    return col;\n}\n\nvec3 renderTunnelTexture(vec2 uv) {\n\n    // uv.y += sin(iTime)*.02;\n    // uv.x += cos(iTime/2.)*.05;\n\n    vec3 col = vec3(0.);\n    col.rgb =\n        renderField(uv, 0.)\n        + renderField(uv*13., 1.)\n        + renderField(uv/3., 2.);\n\n    return col;\n}\n\nvec3 getBackground(vec2 uv) {\n    return renderTunnelTexture(uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 3, -3);\n    // ro.yz *= Rot(-m.y*3.14+1.);\n    // ro.xz *= Rot(-m.x*6.2831);\n\n    ro.yz *= Rot(-3.14/3.9);\n    ro.xz *= Rot(3.14);\n\n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    vec3 col = vec3(0);\n\n    vec4 rm = RayMarch(Transform(ro), rd);\n    float d = rm.x;\n    float k = rm.a;\n    float mat = rm.z;\n    float id = abs(rm.y);\n\n    if(d<MAX_DIST) {\n        vec3 p = Transform(ro) + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n        vec3 ref = getBackground(Transform(r).xy*2.);// /  texture(iChannel0, Transform(r).xy).rgb;\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        vec3 sc = clamp(vec3(sin(id*10.) + .2, cos(id*20.), cos(id)/sin(id)), vec3(0.0, .3, 0.), vec3(1., .1, 0.3));\n        // vec3 sc = vec3(1., 0. ,0.);\n        if (mat == MAT_WALLS) {\n            col = vec3(dif) * (1. - k/10.);\n            col *= sc;\n            col *= ref * 5.;\n        } else {\n            col = vec3(dif) * ref * sc;\n        }\n        col = pow(col, vec3(.4545));\t// gamma correction\n    } else {\n            // uv.xy *= Rot(iTime/3.);\n            col = getBackground(uv);\n        }\n\n    \n    // col *= p;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs2XWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[162, 162, 193, 193, 304], [306, 306, 325, 325, 387], [389, 389, 418, 418, 499], [501, 501, 520, 520, 653], [655, 655, 682, 682, 1610], [1613, 1613, 1635, 1635, 1665], [1667, 1667, 1700, 1700, 2010], [2012, 2012, 2036, 2036, 2226], [2228, 2228, 2278, 2278, 2469], [2471, 2471, 2495, 2495, 2624], [2626, 2626, 2654, 2654, 3088], [3090, 3090, 3130, 3130, 4091], [4093, 4093, 4128, 4194, 4349], [4351, 4351, 4380, 4380, 4418], [4420, 4420, 4477, 4477, 5784]], "test": "valid"}
{"id": "fsBSDD", "name": "load_spinner_with_chromatic_aber", "author": "skaplun", "description": "Based on https://twitter.com/loackme_/status/1389690617857548294?s=20", "tags": ["2d", "grayscale", "animation"], "likes": 5, "viewed": 67, "published": "Public", "date": "1620222268", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define AA (10./max(iResolution.x, iResolution.y))\n#define rot2d(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define POINT_SIZE .3\n\nconst float PI = acos(-1.);\nconst float HPI = PI*.25;\nconst float TAU = PI*2.;\n\nfloat point(vec2 uv, float pos, float size)\n{\n    float ang = atan(uv.x, uv.y)/TAU + .5;\n    float mang = mod(ang, .25);\n    \n    float res = 0.;\n    for(float i = 0.; i < 3.; i++)\n    {\n        mang -= .25 * i;\n        vec2 muv = vec2(cos(mang * PI * 2.) * length(uv), sin(mang * PI * 2.) * length(uv));\n        vec2 p = mix(vec2(0., 2.), vec2(2., 0.), pos);\n        float c = smoothstep(size + AA, size, distance(p, muv));\n        res = max(res, c);\n    }\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy)/iResolution.y;\n    uv *= rot2d(iTime * .25);\n    uv *= 2.5 + sin(iTime) * .25;\n    vec2 uv2 = uv * mat2(cos(HPI), -sin(HPI), sin(HPI), cos(HPI));\n    \n    vec3 val = vec3(0.);\n    for (float i = 0.; i < 5.; i ++){\n        float time = smoothstep(.75 - .25 * i/5., .25 - .25 * i/5., fract(iTime * .5));\n        time = pow(time, 16./(i + 1.));\n        float aber_offset = AA * 5. * smoothstep(.45, .05, distance(time, .5));\n        float size = POINT_SIZE - smoothstep(.45, .05, distance(time, .5)) * (POINT_SIZE * .5);\n        val.r += point(uv, time - aber_offset, size);\n        val.g += point(uv, time, size);\n        val.b += point(uv, time + aber_offset, size);\n        \n        val.r += point(uv2, time - aber_offset, size);\n        val.g += point(uv2, time, size);\n        val.b += point(uv2, time + aber_offset, size);\n    }\n    \n    fragColor = vec4(val, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsBSDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[209, 209, 254, 254, 684], [686, 686, 743, 743, 1661]], "test": "error"}
{"id": "fsBSRV", "name": "Cam's Mandala", "author": "Jordan", "description": "Made for my brother's gym shirts", "tags": ["spiral", "geometric", "print"], "likes": 1, "viewed": 62, "published": "Public", "date": "1620537377", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(r,c) max( 0., ( abs( fract((c)*r/2.) - .5 ) -.5 + width/sharpness ) / fwidth((c)*r/2.)  )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n\tvec2 R = iResolution.xy,\n         U = ( u - vec2(.5,0) * R) / R.y;               \n    U = 4.* vec2( atan(U.x, U.y)- iTime*.07, length(U) );    \n    U.x = U.x*.955;\n    \n    float sharpness = 100.,\n          y = U.y-1.5,\n          width = -2.9 + U.y*6. / (1. + (y+sin(iTime*5.)) * y ),\n          c1 = U.x + U.y/sqrt(2.),\n          c2 = U.x - U.y/sqrt(2.),\n          \n          m1 = S(1.,c1) + S(2.,c1) + S(4.,c1),\n          m2 = S(1.,c2) + S(2.,c2) + S(4.,c2);\n    \n    O = vec4(m1+m2);\n    O = sqrt(O);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsBSRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[101, 101, 139, 139, 645]], "test": "valid"}
{"id": "fsBSRy", "name": "Square tiling (Material Maker)", "author": "demicuz", "description": "I've decided to replicate one of Dave's creations in Material Maker ([url]https://materialmaker.org/[/url]) and export it to Shadertoy. It turned out to be not as easy as I expected, but it was fun anyway.", "tags": ["animation", "generated", "dave", "materialmaker", "beesandbombs"], "likes": 7, "viewed": 199, "published": "Public API", "date": "1620429911", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The code is not meant to be read by humans :)\n// Original: https://twitter.com/beesandbombs/status/1387181859264737282\n// The colors are slightly off, and the shader itself is quite wasteful\n\nfloat rand(vec2 x) {\n    return fract(cos(mod(dot(x, vec2(13.9898, 8.141)), 3.14)) * 43758.5453);\n}\n\nvec2 rand2(vec2 x) {\n    return fract(cos(mod(vec2(dot(x, vec2(13.9898, 8.141)),\n\t\t\t\t\t\t      dot(x, vec2(3.4562, 17.398))), vec2(3.14))) * 43758.5453);\n}\n\nvec3 rand3(vec2 x) {\n    return fract(cos(mod(vec3(dot(x, vec2(13.9898, 8.141)),\n\t\t\t\t\t\t\t  dot(x, vec2(3.4562, 17.398)),\n                              dot(x, vec2(13.254, 5.867))), vec3(3.14))) * 43758.5453);\n}\n\nvec3 rgb2hsv(vec3 c) {\n\tvec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n\tvec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);\n\tvec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n\n\tfloat d = q.x - min(q.w, q.y);\n\tfloat e = 1.0e-10;\n\treturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c) {\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 rgb_to_hsv(vec3 c) {\n\tvec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n\tvec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);\n\tvec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n\n\tfloat d = q.x - min(q.w, q.y);\n\tfloat e = 1.0e-10;\n\treturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv_to_rgb(vec3 c) {\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nfloat easeInOutCubic(float x) {\n\treturn x < 0.5 ? 4.0 * x * x * x : 1.0 - pow(-2.0 * x + 2.0, 3.0) / 2.0;\n}vec2 scale(vec2 uv, vec2 center, vec2 scale) {\n\tuv -= center;\n\tuv /= scale;\n\tuv += center;\n    return uv;\n}vec3 blend_normal(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*c1 + (1.0-opacity)*c2;\n}\n\nvec3 blend_dissolve(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\tif (rand(uv) < opacity) {\n\t\treturn c1;\n\t} else {\n\t\treturn c2;\n\t}\n}\n\nvec3 blend_multiply(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*c1*c2 + (1.0-opacity)*c2;\n}\n\nvec3 blend_screen(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*(1.0-(1.0-c1)*(1.0-c2)) + (1.0-opacity)*c2;\n}\n\nfloat blend_overlay_f(float c1, float c2) {\n\treturn (c1 < 0.5) ? (2.0*c1*c2) : (1.0-2.0*(1.0-c1)*(1.0-c2));\n}\n\nvec3 blend_overlay(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*vec3(blend_overlay_f(c1.x, c2.x), blend_overlay_f(c1.y, c2.y), blend_overlay_f(c1.z, c2.z)) + (1.0-opacity)*c2;\n}\n\nvec3 blend_hard_light(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*0.5*(c1*c2+blend_overlay(uv, c1, c2, 1.0)) + (1.0-opacity)*c2;\n}\n\nfloat blend_soft_light_f(float c1, float c2) {\n\treturn (c2 < 0.5) ? (2.0*c1*c2+c1*c1*(1.0-2.0*c2)) : 2.0*c1*(1.0-c2)+sqrt(c1)*(2.0*c2-1.0);\n}\n\nvec3 blend_soft_light(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*vec3(blend_soft_light_f(c1.x, c2.x), blend_soft_light_f(c1.y, c2.y), blend_soft_light_f(c1.z, c2.z)) + (1.0-opacity)*c2;\n}\n\nfloat blend_burn_f(float c1, float c2) {\n\treturn (c1==0.0)?c1:max((1.0-((1.0-c2)/c1)),0.0);\n}\n\nvec3 blend_burn(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*vec3(blend_burn_f(c1.x, c2.x), blend_burn_f(c1.y, c2.y), blend_burn_f(c1.z, c2.z)) + (1.0-opacity)*c2;\n}\n\nfloat blend_dodge_f(float c1, float c2) {\n\treturn (c1==1.0)?c1:min(c2/(1.0-c1),1.0);\n}\n\nvec3 blend_dodge(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*vec3(blend_dodge_f(c1.x, c2.x), blend_dodge_f(c1.y, c2.y), blend_dodge_f(c1.z, c2.z)) + (1.0-opacity)*c2;\n}\n\nvec3 blend_lighten(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*max(c1, c2) + (1.0-opacity)*c2;\n}\n\nvec3 blend_darken(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*min(c1, c2) + (1.0-opacity)*c2;\n}\n\nvec3 blend_difference(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*clamp(c2-c1, vec3(0.0), vec3(1.0)) + (1.0-opacity)*c2;\n}\nconst float p_o5267_cx = 0.000000000;\nconst float p_o5267_cy = 0.000000000;\nconst float p_o5267_scale_x = 0.800000000;\nconst float p_o5267_scale_y = 0.800000000;\nconst float p_o5266_amount = 1.000000000;\nvec3 blend_darken_o5265 (vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*min(c1, c2) + (1.0-opacity)*c2;\n}\n\nvec4 master_blend_o5265 (vec4 c1, vec4 c2, float amount){\n\treturn vec4(blend_darken_o5265(c1.rgb, c2.rgb, amount*c1.a),\n\t            min(1.0, c2.a+amount*c1.a));\n}\n\nvec4 blend_o5265 (vec4 c1, vec4 c2, float amount) {\n\tif (c1.a > 0.0 && c2.a > 0.0) return master_blend_o5265 (c1, c2, amount);\n\telse if (c1.a > 0.0) return c1;\n\telse return c2;\n}const float p_o5229_tx = 9.000000000;\nconst float p_o5229_ty = 9.000000000;\nconst float p_o5229_overlap = 1.000000000;\n#define p_o5229_bevel 5.5/iResolution.y\nconst float p_o5217_cx = -1.000000000;\nconst float p_o5217_cy = 0.000000000;\nconst float p_o5222_cx = 1.000000000;\nconst float p_o5222_cy = 0.000000000;\nconst float p_o5221_cx = 0.000000000;\nconst float p_o5221_cy = -1.000000000;\nconst float p_o5220_cx = 0.000000000;\nconst float p_o5220_cy = 1.000000000;\nconst float p_o5214_w = 0.500000000;\nconst float p_o5214_h = 0.500000000;\nconst float p_o5214_cx = 0.000000000;\nconst float p_o5214_cy = 0.000000000;\nconst float p_o5224_cx = 0.000000000;\nconst float p_o5224_cy = 0.000000000;\nfloat o5229_input_in(vec3 p) {\nfloat o5217_0_1_sdf2d = length((((p).xyz).xy)-vec2(p_o5217_cx+0.5, p_o5217_cy+0.5))-(sqrt(2.0)/2.0);\nfloat o5222_0_1_sdf2d = length((((p).xyz).xy)-vec2(p_o5222_cx+0.5, p_o5222_cy+0.5))-(sqrt(2.0)/2.0);\nfloat o5218_0_1_sdf2d = min( o5217_0_1_sdf2d, o5222_0_1_sdf2d);\nfloat o5221_0_1_sdf2d = length((((p).xyz).xy)-vec2(p_o5221_cx+0.5, p_o5221_cy+0.5))-(sqrt(2.0)/2.0);\nfloat o5220_0_1_sdf2d = length((((p).xyz).xy)-vec2(p_o5220_cx+0.5, p_o5220_cy+0.5))-(sqrt(2.0)/2.0);\nfloat o5219_0_1_sdf2d = min( o5221_0_1_sdf2d, o5220_0_1_sdf2d);\nfloat o5216_0_1_sdf2d = min( o5218_0_1_sdf2d, o5219_0_1_sdf2d);\nvec2 o5214_0_d = abs((((p).xyz).xy)-vec2(p_o5214_cx+0.5, p_o5214_cy+0.5))-vec2(p_o5214_w, p_o5214_h);\nfloat o5214_0_1_sdf2d = length(max(o5214_0_d,vec2(0)))+min(max(o5214_0_d.x,o5214_0_d.y),0.0);\nfloat o5215_0_1_sdf2d = max(- o5216_0_1_sdf2d, o5214_0_1_sdf2d);\nvec2 o5214_2_d = abs((((p).xyz).xy)-vec2(p_o5214_cx+0.5, p_o5214_cy+0.5))-vec2(p_o5214_w, p_o5214_h);\nfloat o5214_0_3_sdf2d = length(max(o5214_2_d,vec2(0)))+min(max(o5214_2_d.x,o5214_2_d.y),0.0);\nfloat o5223_0_1_sdf3d = mix(o5215_0_1_sdf2d, o5214_0_3_sdf2d, clamp(((p).xyz).z, 0.0, 1.0));\nfloat o5224_0_1_sdf2d = length((((p).xyz).xy)-vec2(p_o5224_cx+0.5, p_o5224_cy+0.5))-(sqrt(2.0)/2.0);\nfloat o5225_0_1_sdf3d = mix(o5214_0_3_sdf2d, o5224_0_1_sdf2d, clamp(((p).xyz).z, 0.0, 1.0));\nfloat o5226_0_1_sdf3d = max(- o5223_0_1_sdf3d, o5225_0_1_sdf3d);\n\nreturn o5226_0_1_sdf3d;\n}\nconst float p_o5263_hue = 0.000000000;\nconst float p_o5263_saturation = 2.000000000;\nconst float p_o5263_value = 1.000000000;\nvec4 o5263_f(vec4 c) {\n\tvec3 hsv = rgb_to_hsv(c.rgb);\n\treturn vec4(hsv_to_rgb(vec3(fract(hsv.x+p_o5263_hue), clamp(hsv.y*p_o5263_saturation, 0.0, 1.0), clamp(hsv.z*p_o5263_value, 0.0, 1.0))), c.a);\n}const float p_o5242_gradient_0_pos = 0.166113000;\nconst float p_o5242_gradient_0_r = 1.000000000;\nconst float p_o5242_gradient_0_g = 0.878431022;\nconst float p_o5242_gradient_0_b = 0.250979990;\nconst float p_o5242_gradient_0_a = 0.486274987;\nconst float p_o5242_gradient_1_pos = 0.500000000;\nconst float p_o5242_gradient_1_r = 1.000000000;\nconst float p_o5242_gradient_1_g = 0.411765009;\nconst float p_o5242_gradient_1_b = 0.717647016;\nconst float p_o5242_gradient_1_a = 0.486274987;\nconst float p_o5242_gradient_2_pos = 0.832226000;\nconst float p_o5242_gradient_2_r = 0.109803997;\nconst float p_o5242_gradient_2_g = 0.760783970;\nconst float p_o5242_gradient_2_b = 0.756862998;\nconst float p_o5242_gradient_2_a = 0.486274987;\nvec4 o5242_gradient_gradient_fct(float x) {\n  if (x < 0.5*(p_o5242_gradient_0_pos+p_o5242_gradient_1_pos)) {\n    return vec4(p_o5242_gradient_0_r,p_o5242_gradient_0_g,p_o5242_gradient_0_b,p_o5242_gradient_0_a);\n  } else if (x < 0.5*(p_o5242_gradient_1_pos+p_o5242_gradient_2_pos)) {\n    return vec4(p_o5242_gradient_1_r,p_o5242_gradient_1_g,p_o5242_gradient_1_b,p_o5242_gradient_1_a);\n  }\n  return vec4(p_o5242_gradient_2_r,p_o5242_gradient_2_g,p_o5242_gradient_2_b,p_o5242_gradient_2_a);\n}\nvec4 o5229_input_color_map(vec2 uv) {\nvec2 o5242_0_wat = abs((uv) - 0.5);\nfloat o5242_0_d = o5242_0_wat.x+o5242_0_wat.y;vec4 o5242_0_1_rgba = o5242_gradient_gradient_fct(fract(2.0*(5.0/3.0)*o5242_0_d));\nvec4 o5263_0_1_rgba = o5263_f(o5242_0_1_rgba);\n\nreturn o5263_0_1_rgba;\n}\nconst float p_o5271_repeat = 0.500000000;\nconst float p_o5271_gradient_0_pos = 0.000000000;\nconst float p_o5271_gradient_0_r = 0.000000000;\nconst float p_o5271_gradient_0_g = 0.000000000;\nconst float p_o5271_gradient_0_b = 0.000000000;\nconst float p_o5271_gradient_0_a = 1.000000000;\nconst float p_o5271_gradient_1_pos = 0.252491694;\nconst float p_o5271_gradient_1_r = 0.000000000;\nconst float p_o5271_gradient_1_g = 0.000000000;\nconst float p_o5271_gradient_1_b = 0.000000000;\nconst float p_o5271_gradient_1_a = 1.000000000;\nconst float p_o5271_gradient_2_pos = 0.750830565;\nconst float p_o5271_gradient_2_r = 1.000000000;\nconst float p_o5271_gradient_2_g = 1.000000000;\nconst float p_o5271_gradient_2_b = 1.000000000;\nconst float p_o5271_gradient_2_a = 1.000000000;\nconst float p_o5271_gradient_3_pos = 1.000000000;\nconst float p_o5271_gradient_3_r = 1.000000000;\nconst float p_o5271_gradient_3_g = 1.000000000;\nconst float p_o5271_gradient_3_b = 1.000000000;\nconst float p_o5271_gradient_3_a = 1.000000000;\nvec4 o5271_gradient_gradient_fct(float x) {\n  if (x < p_o5271_gradient_0_pos) {\n    return vec4(p_o5271_gradient_0_r,p_o5271_gradient_0_g,p_o5271_gradient_0_b,p_o5271_gradient_0_a);\n  } else if (x < p_o5271_gradient_1_pos) {\n    return mix(vec4(p_o5271_gradient_0_r,p_o5271_gradient_0_g,p_o5271_gradient_0_b,p_o5271_gradient_0_a), vec4(p_o5271_gradient_1_r,p_o5271_gradient_1_g,p_o5271_gradient_1_b,p_o5271_gradient_1_a), ((x-p_o5271_gradient_0_pos)/(p_o5271_gradient_1_pos-p_o5271_gradient_0_pos)));\n  } else if (x < p_o5271_gradient_2_pos) {\n    return mix(vec4(p_o5271_gradient_1_r,p_o5271_gradient_1_g,p_o5271_gradient_1_b,p_o5271_gradient_1_a), vec4(p_o5271_gradient_2_r,p_o5271_gradient_2_g,p_o5271_gradient_2_b,p_o5271_gradient_2_a), ((x-p_o5271_gradient_1_pos)/(p_o5271_gradient_2_pos-p_o5271_gradient_1_pos)));\n  } else if (x < p_o5271_gradient_3_pos) {\n    return mix(vec4(p_o5271_gradient_2_r,p_o5271_gradient_2_g,p_o5271_gradient_2_b,p_o5271_gradient_2_a), vec4(p_o5271_gradient_3_r,p_o5271_gradient_3_g,p_o5271_gradient_3_b,p_o5271_gradient_3_a), ((x-p_o5271_gradient_2_pos)/(p_o5271_gradient_3_pos-p_o5271_gradient_2_pos)));\n  }\n  return vec4(p_o5271_gradient_3_r,p_o5271_gradient_3_g,p_o5271_gradient_3_b,p_o5271_gradient_3_a);\n}\nfloat o5229_input_t_map(vec2 uv) {\nvec2 o5271_0_wat = abs((uv) - 0.5);\nfloat o5271_0_d = max(o5271_0_wat.x,o5271_0_wat.y);vec4 o5271_0_1_rgba = o5271_gradient_gradient_fct(2.0*abs(fract(-0.2*iTime + p_o5271_repeat*o5271_0_d)-0.5));\nfloat o118692_0_1_f = easeInOutCubic((dot((o5271_0_1_rgba).rgb, vec3(1.0))/3.0));\n\nreturn o118692_0_1_f;\n}\nvec3 blend_darken_o5229 (vec3 c1, vec3 c2, float opacity) {\n\t//return min(c1, c2);\n\treturn opacity*min(c1, c2) + (1.0-opacity)*c2;\n}\n\nvec4 master_blend_o5229 (vec4 c1, vec4 c2, float amount){\n\treturn vec4(blend_darken_o5229(c1.rgb, c2.rgb, c1.a*amount),\n\t            min(1.0, c2.a+amount*c1.a));\n}\n\nvec4 tiler_o5229(vec2 uv, vec2 tile, float overlap, float bevel) {\n\tvec2 if_calculated = abs(uv-0.5)-overlap*(1.0/tile);\n\tif (if_calculated.x > 0.5 || if_calculated.y > 0.5) {\n\t\treturn vec4(0.0);\n\t}\n\t\n\tvec2 p = uv*tile;\n\t\n\tvec2 cell_id = floor(p);\n\tvec2 local_uv = fract(p);\n\tvec2 fetching_uv = (cell_id + 0.5)/tile;\n\t\n\tvec4 color = vec4(1.0, 1.0, 1.0, 0.0);\n\t\n\tfor (float dx = -overlap; dx <= overlap; ++dx) {\n\t\tfor (float dy = -overlap; dy <= overlap; ++dy) {\n\t\t\tvec2 local_uv_offset = vec2(dx, dy);\n\t\t\tvec2 local_fetching_uv = fetching_uv - local_uv_offset/tile;\n\t\t\t\n\t\t\tif (local_fetching_uv.x < 0.0 || local_fetching_uv.x > 1.0 || local_fetching_uv.y < 0.0 || local_fetching_uv.y > 1.0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tvec2 localler_uv = local_uv + local_uv_offset;\n\t\t\t\n\t\t\tfloat sdf = o5229_input_in(vec3(localler_uv, o5229_input_t_map(local_fetching_uv)));\n\t\t\t//float sdf_color = step(sdf, 0.0);\n\t\t\tfloat sdf_color = smoothstep(bevel, -bevel, sdf);\n\t\t\t\n\t\t\tvec4 fetched_color = o5229_input_color_map(local_fetching_uv);\n\t\t\t//if (color == vec4(0.0)) {\n\t\t\t//\tfetched_color.a *= sdf_color;\n\t\t\t//\tcolor = vec4(1.0);\n\t\t\t//}\n\t\t\tif (sdf_color > 0.0) {\n\t\t\t\tfetched_color.a *= sdf_color;\n\t\t\t\tcolor = master_blend_o5229(color,fetched_color,1.0);\n\t\t\t}\n\t\t\t\n\t\t\t//color = max(color, o5229_input_color_map(local_fetching_uv)*sdf);\n\t\t\t//color = blend_darken_o5229(o5229_input_color_map(local_fetching_uv)*sdf,color,1.0);\n\t\t}\n\t}\n\treturn color;\n\t//if (color.a < 0.000001) return vec4(0.0);\n\t//else return color;\n}const float p_o5252_cx = 0.000000000;\nconst float p_o5252_cy = 0.000000000;\nconst float p_o5268_tx = 8.000000000;\nconst float p_o5268_ty = 8.000000000;\nconst float p_o5268_overlap = 1.000000000;\n#define p_o5268_bevel 5.5/iResolution.y\nfloat o5268_input_in(vec3 p) {\nfloat o5217_0_1_sdf2d = length((((p).xyz).xy)-vec2(p_o5217_cx+0.5, p_o5217_cy+0.5))-(sqrt(2.0)/2.0);\nfloat o5222_0_1_sdf2d = length((((p).xyz).xy)-vec2(p_o5222_cx+0.5, p_o5222_cy+0.5))-(sqrt(2.0)/2.0);\nfloat o5218_0_1_sdf2d = min( o5217_0_1_sdf2d, o5222_0_1_sdf2d);\nfloat o5221_0_1_sdf2d = length((((p).xyz).xy)-vec2(p_o5221_cx+0.5, p_o5221_cy+0.5))-(sqrt(2.0)/2.0);\nfloat o5220_0_1_sdf2d = length((((p).xyz).xy)-vec2(p_o5220_cx+0.5, p_o5220_cy+0.5))-(sqrt(2.0)/2.0);\nfloat o5219_0_1_sdf2d = min( o5221_0_1_sdf2d, o5220_0_1_sdf2d);\nfloat o5216_0_1_sdf2d = min( o5218_0_1_sdf2d, o5219_0_1_sdf2d);\nvec2 o5214_0_d = abs((((p).xyz).xy)-vec2(p_o5214_cx+0.5, p_o5214_cy+0.5))-vec2(p_o5214_w, p_o5214_h);\nfloat o5214_0_1_sdf2d = length(max(o5214_0_d,vec2(0)))+min(max(o5214_0_d.x,o5214_0_d.y),0.0);\nfloat o5215_0_1_sdf2d = max(- o5216_0_1_sdf2d, o5214_0_1_sdf2d);\nvec2 o5214_2_d = abs((((p).xyz).xy)-vec2(p_o5214_cx+0.5, p_o5214_cy+0.5))-vec2(p_o5214_w, p_o5214_h);\nfloat o5214_0_3_sdf2d = length(max(o5214_2_d,vec2(0)))+min(max(o5214_2_d.x,o5214_2_d.y),0.0);\nfloat o5223_0_1_sdf3d = mix(o5215_0_1_sdf2d, o5214_0_3_sdf2d, clamp(((p).xyz).z, 0.0, 1.0));\nfloat o5224_0_1_sdf2d = length((((p).xyz).xy)-vec2(p_o5224_cx+0.5, p_o5224_cy+0.5))-(sqrt(2.0)/2.0);\nfloat o5225_0_1_sdf3d = mix(o5214_0_3_sdf2d, o5224_0_1_sdf2d, clamp(((p).xyz).z, 0.0, 1.0));\nfloat o5226_0_1_sdf3d = max(- o5223_0_1_sdf3d, o5225_0_1_sdf3d);\n\nreturn o5226_0_1_sdf3d;\n}\nconst float p_o5264_hue = 0.000000000;\nconst float p_o5264_saturation = 2.000000000;\nconst float p_o5264_value = 1.000000000;\nvec4 o5264_f(vec4 c) {\n\tvec3 hsv = rgb_to_hsv(c.rgb);\n\treturn vec4(hsv_to_rgb(vec3(fract(hsv.x+p_o5264_hue), clamp(hsv.y*p_o5264_saturation, 0.0, 1.0), clamp(hsv.z*p_o5264_value, 0.0, 1.0))), c.a);\n}const float p_o183339_cx = 0.000000000;\nconst float p_o183339_cy = 0.000000000;\nvec4 o5268_input_color_map(vec2 uv) {\nvec2 o5242_0_wat = abs((scale((uv), vec2(0.5+p_o183339_cx, 0.5+p_o183339_cy), vec2((9.0/8.0), (9.0/8.0)))) - 0.5);\nfloat o5242_0_d = o5242_0_wat.x+o5242_0_wat.y;vec4 o5242_0_1_rgba = o5242_gradient_gradient_fct(fract(2.0*(5.0/3.0)*o5242_0_d));\nvec4 o183339_0_1_rgba = o5242_0_1_rgba;\nvec4 o5264_0_1_rgba = o5264_f(o183339_0_1_rgba);\n\nreturn o5264_0_1_rgba;\n}\nfloat o5268_input_t_map(vec2 uv) {\nvec2 o5271_0_wat = abs((uv) - 0.5);\nfloat o5271_0_d = max(o5271_0_wat.x,o5271_0_wat.y);vec4 o5271_0_1_rgba = o5271_gradient_gradient_fct(2.0*abs(fract(-0.2*iTime + p_o5271_repeat*o5271_0_d)-0.5));\nfloat o118692_0_1_f = easeInOutCubic((dot((o5271_0_1_rgba).rgb, vec3(1.0))/3.0));\n\nreturn o118692_0_1_f;\n}\nvec3 blend_darken_o5268 (vec3 c1, vec3 c2, float opacity) {\n\t//return min(c1, c2);\n\treturn opacity*min(c1, c2) + (1.0-opacity)*c2;\n}\n\nvec4 master_blend_o5268 (vec4 c1, vec4 c2, float amount){\n\treturn vec4(blend_darken_o5268(c1.rgb, c2.rgb, c1.a*amount),\n\t            min(1.0, c2.a+amount*c1.a));\n}\n\nvec4 tiler_o5268(vec2 uv, vec2 tile, float overlap, float bevel) {\n\tvec2 if_calculated = abs(uv-0.5)-overlap*(1.0/tile);\n\tif (if_calculated.x > 0.5 || if_calculated.y > 0.5) {\n\t\treturn vec4(0.0);\n\t}\n\t\n\tvec2 p = uv*tile;\n\t\n\tvec2 cell_id = floor(p);\n\tvec2 local_uv = fract(p);\n\tvec2 fetching_uv = (cell_id + 0.5)/tile;\n\t\n\tvec4 color = vec4(1.0, 1.0, 1.0, 0.0);\n\t\n\tfor (float dx = -overlap; dx <= overlap; ++dx) {\n\t\tfor (float dy = -overlap; dy <= overlap; ++dy) {\n\t\t\tvec2 local_uv_offset = vec2(dx, dy);\n\t\t\tvec2 local_fetching_uv = fetching_uv - local_uv_offset/tile;\n\t\t\t\n\t\t\tif (local_fetching_uv.x < 0.0 || local_fetching_uv.x > 1.0 || local_fetching_uv.y < 0.0 || local_fetching_uv.y > 1.0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tvec2 localler_uv = local_uv + local_uv_offset;\n\t\t\t\n\t\t\tfloat sdf = o5268_input_in(vec3(localler_uv, o5268_input_t_map(local_fetching_uv)));\n\t\t\t//float sdf_color = step(sdf, 0.0);\n\t\t\tfloat sdf_color = smoothstep(bevel, -bevel, sdf);\n\t\t\t\n\t\t\tvec4 fetched_color = o5268_input_color_map(local_fetching_uv);\n\t\t\t//if (color == vec4(0.0)) {\n\t\t\t//\tfetched_color.a *= sdf_color;\n\t\t\t//\tcolor = vec4(1.0);\n\t\t\t//}\n\t\t\tif (sdf_color > 0.0) {\n\t\t\t\tfetched_color.a *= sdf_color;\n\t\t\t\tcolor = master_blend_o5268(color,fetched_color,1.0);\n\t\t\t}\n\t\t\t\n\t\t\t//color = max(color, o5268_input_color_map(local_fetching_uv)*sdf);\n\t\t\t//color = blend_darken_o5268(o5268_input_color_map(local_fetching_uv)*sdf,color,1.0);\n\t\t}\n\t}\n\treturn color;\n\t//if (color.a < 0.000001) return vec4(0.0);\n\t//else return color;\n}const float p_o5270_color_r = 1.000000000;\nconst float p_o5270_color_g = 1.000000000;\nconst float p_o5270_color_b = 1.000000000;\nconst float p_o5270_color_a = 1.000000000;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\nfloat minSize = min(iResolution.x, iResolution.y);\nvec2 UV = vec2(0.0, 1.0) + vec2(1.0, -1.0) * (fragCoord-0.5*(iResolution.xy-vec2(minSize)))/minSize;\nvec4 o5229_0_1_rgba = tiler_o5229((scale((UV), vec2(0.5+p_o5267_cx, 0.5+p_o5267_cy), vec2(p_o5267_scale_x, p_o5267_scale_y))), vec2(p_o5229_tx, p_o5229_ty), p_o5229_overlap, p_o5229_bevel);\nvec4 o5268_0_1_rgba = tiler_o5268((scale((scale((UV), vec2(0.5+p_o5267_cx, 0.5+p_o5267_cy), vec2(p_o5267_scale_x, p_o5267_scale_y))), vec2(0.5+p_o5252_cx, 0.5+p_o5252_cy), vec2((8.0/9.0), (8.0/9.0)))), vec2(p_o5268_tx, p_o5268_ty), p_o5268_overlap, p_o5268_bevel);\nvec4 o5252_0_1_rgba = o5268_0_1_rgba;\nvec4 o5265_0_1_rgba = blend_o5265(o5229_0_1_rgba, o5252_0_1_rgba, 1.0);\nvec4 o5270_0_1_rgba = vec4(p_o5270_color_r, p_o5270_color_g, p_o5270_color_b, p_o5270_color_a);\nvec4 o5266_0_s1 = o5265_0_1_rgba;\nvec4 o5266_0_s2 = o5270_0_1_rgba;\nfloat o5266_0_a = p_o5266_amount*1.0;\nvec4 o5266_0_2_rgba = vec4(blend_normal((scale((UV), vec2(0.5+p_o5267_cx, 0.5+p_o5267_cy), vec2(p_o5267_scale_x, p_o5267_scale_y))), o5266_0_s1.rgb, o5266_0_s2.rgb, o5266_0_a*o5266_0_s1.a), min(1.0, o5266_0_s2.a+o5266_0_a*o5266_0_s1.a));\nvec4 o5267_0_1_rgba = o5266_0_2_rgba;\nfragColor = o5267_0_1_rgba;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsBSRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[195, 195, 215, 215, 294], [296, 296, 316, 316, 449], [451, 451, 471, 471, 660], [662, 662, 684, 684, 981], [983, 983, 1005, 1005, 1165], [1167, 1167, 1192, 1192, 1489], [1491, 1491, 1516, 1516, 1676], [1677, 1677, 1708, 1708, 1784], [1784, 1784, 1830, 1830, 1891], [1891, 1891, 1952, 1952, 1993], [1995, 1995, 2058, 2058, 2126], [2128, 2128, 2191, 2191, 2235], [2237, 2237, 2298, 2298, 2360], [2362, 2362, 2405, 2405, 2471], [2473, 2473, 2535, 2535, 2665], [2667, 2667, 2732, 2732, 2813], [2815, 2815, 2861, 2861, 2956], [2958, 2958, 3023, 3023, 3162], [3164, 3164, 3204, 3204, 3257], [3259, 3259, 3318, 3318, 3439], [3441, 3441, 3482, 3482, 3527], [3529, 3529, 3589, 3589, 3713], [3715, 3715, 3777, 3777, 3827], [3829, 3829, 3890, 3890, 3940], [3942, 3942, 4007, 4007, 4080], [4285, 4285, 4344, 4344, 4394], [4396, 4396, 4453, 4453, 4559], [4561, 4561, 4612, 4612, 4739], [5430, 5430, 5460, 5460, 6892], [7019, 7019, 7041, 7041, 7218], [7944, 7944, 7987, 7987, 8434], [8435, 8435, 8472, 8472, 8710], [9721, 9721, 9764, 9764, 10965], [10966, 10966, 11000, 11000, 11304], [11305, 11305, 11364, 11387, 11437], [11439, 11439, 11496, 11496, 11602], [11604, 11604, 11670, 11670, 13099], [13334, 13334, 13364, 13364, 14796], [14923, 14923, 14945, 14945, 15122], [15202, 15202, 15239, 15239, 15598], [15599, 15599, 15633, 15633, 15937], [15938, 15938, 15997, 16020, 16070], [16072, 16072, 16129, 16129, 16235], [16237, 16237, 16303, 16303, 17732], [17905, 17905, 17960, 17960, 19185]], "test": "valid"}
{"id": "fsBXDD", "name": "Parallelogram", "author": "Pentan", "description": "2D parallelogram distance field", "tags": ["2d", "distancefield", "sdf", "distance"], "likes": 4, "viewed": 142, "published": "Public API", "date": "1620582715", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float parallelogram2d(vec2 p, float w, float h, float s)\n{\n    vec2 v = vec2(s, h);\n    vec2 n = normalize(v.yx * vec2(1.0, -1.0));\n\n    float th = clamp(p.y / h, -1.0, 1.0);\n    vec2 o = vec2(clamp((p.x - s * th), -w, w), 0.0);\n    float t = clamp(dot(p - o, v) / dot(v, v), -1.0, 1.0);\n    float d0 = length(p - v * t - o);\n\n    float d1 = min(0.0, max(abs(p.y) - h, abs(dot(n, p)) - n.x * w));\n\n    return d0 + d1;\n}\n\nfloat grid(vec2 p) {\n    vec2 s = abs(vec2(dFdx(p).x, dFdy(p).y));\n    p = fract(p);\n    return (p.x < s.x || p.y < s.y) ? 1.0 : 0.0;\n}\n\nvec4 sdf_preview(float d, float lw) {\n    float ad = abs(d);\n    float l = 1.0 - smoothstep(lw - 1.0, lw, abs(d * min(iResolution.x, iResolution.y)));\n    float f = fract(ad * 10.0) * 0.2 + pow(fract(ad), 4.0) * 1.0;\n    vec4 c = (d > 0.0) ? vec4(0.0, f, d, 1.0) : vec4(-d, f, 0.0, 1.0);\n    return mix(c, vec4(0.0, 1.0, 0.0, 1.0), l);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    p *= 4.0;\n\n    float g = grid(p);\n\n    float w = (1.1 + sin(iTime * 0.8)) * 1.5;\n    float h = (1.1 + sin(iTime * 0.5)) * 1.0;\n    float s = 0.0 + sin(iTime * 1.3) * 2.0;\n    float d = parallelogram2d(p, w, h, s);\n\n    vec4 col;\n    col = mix(sdf_preview(d, 8.0), vec4(1.0, 1.0, 1.0, 1.0), g * 0.5);\n    \n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsBXDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 58, 58, 419], [421, 421, 441, 441, 556], [558, 558, 595, 595, 895], [897, 897, 954, 954, 1374]], "test": "valid"}
{"id": "fsjSRK", "name": "Playing with the sin function.", "author": "wildniklin", "description": "It may be slow, but I really don't care about that, since it's just about having fun.", "tags": ["fractal", "sin"], "likes": 5, "viewed": 153, "published": "Public API", "date": "1620575638", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.1415;\n\nfloat sine(float x) { return (sin((x + ((sin(PI * iTime * 0.5) * 0.5))) * PI) * 0.5) + 0.5; }\n\nvoid mainImage(out vec4 o, vec2 i)\n{\n    vec2 uv = (i - (0.5 * iResolution.xy)) / min(iResolution.x, iResolution.y);\n\n    float r = 0.0;\n\n    int OCTAVES = int(fract(iTime / 7.0) * 7.0) + 1;\n\n    if(uv.x > 0.0)\n    {\n        if(uv.y > 0.0)\n        {\n            uv *= 8.0;\n            float a = 0.5;\n            for(int i = 0; i < OCTAVES; i++)\n            {\n                r += (sine(uv.x) + sine(uv.y)) * 0.5 * a;\n                uv *= 2.0;\n                a *= 0.5;\n            }\n        }\n        else\n        {\n            uv *= 8.0;\n            float a = 0.5;\n            for(int i = 0; i < OCTAVES; i++)\n            {\n                r += (sine(uv.x) * sine(uv.y)) * a;\n                uv *= 2.0;\n                a *= 0.5;\n            }\n        }\n    }\n    else\n    {\n        if(uv.y > 0.0)\n        {\n            uv *= 8.0;\n            float a = 0.5;\n            for(int i = 0; i < OCTAVES; i++)\n            {\n                r += (((sine(uv.x) - sine(uv.y)) * 0.5) + 0.5) * a;\n                uv *= 2.0;\n                a *= 0.5;\n            }\n        }\n        else\n        {\n            uv *= 8.0;\n            float a = 0.5;\n            for(int i = 0; i < OCTAVES; i++)\n            {\n                r += (sine(uv.x) / sine(uv.y)) * a;\n                uv *= 2.0;\n                a *= 0.5;\n            }\n        }\n    }\n    o = vec4(r, r, r, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsjSRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 47, 47, 119], [121, 121, 157, 157, 1480]], "test": "valid"}
{"id": "fsjSzV", "name": "breathing-checkerboard-3", "author": "ykcwa", "description": "Just starting to learn shadertoy...", "tags": ["blackandwhite"], "likes": 3, "viewed": 52, "published": "Public", "date": "1620715490", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// from https://www.shadertoy.com/view/Mls3R7\nvoid rotate(inout vec2 p,float angle,vec2 rotationOrigin)\n{\n    p -= rotationOrigin;\n    p *= mat2(cos(angle),-sin(angle),sin(angle),cos(angle));\n    p += rotationOrigin;\n}\n\n\nfloat stripe(float x, float stripeWidth) {\n  float s = mod(x + 0.5 * stripeWidth, 2.0 * stripeWidth);\n  if (s > stripeWidth) {\n    s = 2.0 * stripeWidth - s;\n  }\n  float smoothness =  4./iResolution.y;\n  return smoothstep(stripeWidth * 0.5, stripeWidth * 0.5 - smoothness, s);\n}\n\nfloat xorBW(float color1, float color2) { \n  return abs(color1 - color2);\n}\n\nfloat checkerboardColor(vec2 uv, float squareSize) {\n  return xorBW(stripe(uv.x, squareSize), stripe(uv.y, squareSize));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (y from -0.5 to 0.5, x scaled appropriately)\n    vec2 uv = ( fragCoord - .5* iResolution.xy) / iResolution.y;\n\n    float squareSize = 0.2;\n    \n    float squareSize1 = squareSize * (1.0 + 0.3 * cos(1.0 * iTime));\n    vec2 uv1 = uv + squareSize1 * vec2(-0.125);\n    rotate(uv1, -0.5 * iTime, vec2(0.5 * squareSize1));\n\n    float squareSize2 = squareSize * (1.0 + 0.2 * cos(2.0 * iTime));\n    vec2 uv2 = uv + squareSize2 * vec2(0.625);\n    rotate(uv2, 0.25 * iTime, vec2(0.5 * squareSize2));\n\n    float c1 = checkerboardColor(uv1, squareSize1);\n    float c2 = checkerboardColor(uv2, squareSize2);\n\n    fragColor = vec4(vec3(xorBW(c1, c2)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsjSzV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 46, 105, 105, 218], [221, 221, 263, 263, 499], [501, 501, 542, 542, 576], [578, 578, 630, 630, 700], [702, 702, 759, 840, 1441]], "test": "valid"}
{"id": "fsjXDh", "name": "pixel art night sky", "author": "Sko", "description": "My first shader here!", "tags": ["pixel", "stars", "night", "pixelart", "nightsky"], "likes": 8, "viewed": 138, "published": "Public", "date": "1620138938", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash21(vec2 p)\n{\n    p=fract(p*vec2(123.456,789.01));\n    p+=dot(p,p+45.67);\n    return fract(p.x*p.y);\n}\nfloat star(vec2 uv,float brightness)\n{\n    float color=0.0;\n    float star=length(uv);\n    float diffraction=abs(uv.x*uv.y);\n    //diffraction *= abs((uv.x + 0.001953125) * (uv.y + 0.001953125));\n    star=brightness/star;\n    diffraction=pow(brightness,2.0)/diffraction;\n    diffraction=min(star,diffraction);\n    diffraction*=sqrt(star);\n    color+=star*sqrt(brightness)*8.0;\n    color+=diffraction*8.0;\n    return color;\n}\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 UV=fragCoord.xy/iResolution.yy;\n    vec3 color=vec3(0.0);\n    float dist=1.0;\n    float brightness=.01;\n    vec2 uv=(floor(UV*256.)/256.)-.51019;\n    uv*=128.;\n    uv+=floor((iTime)*64.)/3072.0;\n    vec2 gv=fract(uv)-.5;\n    vec2 id;\n    float displacement;\n    for(float y=-dist;y<=dist;y++)\n    {\n        for(float x=-dist;x<=dist;x++)\n        {\n            id=floor(uv);\n            displacement=hash21(id+vec2(x,y));\n            //color+=vec3(star(gv-vec2(x,y)-vec2(displacement,fract(displacement*16.))+.5,(hash21(id+vec2(x,y))/128.)));\n            //color=min(color,.4);\n        }\n    }\n    uv/=2.;\n    gv=fract(uv)-.5;\n    for(float y=-dist;y<=dist;y++)\n    {\n        for(float x=-dist;x<=dist;x++)\n        {\n            id=floor(uv);\n            displacement=hash21(id+vec2(x,y));\n            color+=vec3(star(gv-vec2(x,y)-vec2(displacement,fract(displacement*16.))+.5,(hash21(id+vec2(x,y))/128.)));\n        }\n    }\n    uv/=8.;\n    gv=fract(uv)-.5;\n    for(float y=-dist;y<=dist;y++)\n    {\n        for(float x=-dist;x<=dist;x++)\n        {\n            id=floor(uv);\n            displacement=hash21(id+vec2(x,y));\n            color+=vec3(star(gv-vec2(x,y)-vec2(displacement,fract(displacement*16.))+.5,(hash21(id+vec2(x,y))/256.)));\n        }\n    }\n    uv/=6.;\n    gv=fract(uv)-.5;\n    for(float y=-dist;y<=dist;y++)\n    {\n        for(float x=-dist;x<=dist;x++)\n        {\n            id=floor(uv);\n            displacement=hash21(id+vec2(x,y));\n            color+=vec3(star(gv-vec2(x,y)-vec2(displacement,fract(displacement*16.))+.5,(hash21(id+vec2(x,y))/256.)));\n        }\n    }\n    color*=vec3(.5,.7,1.);\n    //color = floor(0.01 + color * 16.0) / 16.0;\n    fragColor=vec4(color,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsjXDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 111], [112, 112, 150, 150, 536], [537, 537, 591, 591, 2294]], "test": "valid"}
{"id": "fsjXDR", "name": "cppn2glsl_test3", "author": "vsewall", "description": "this code was generated by lucid neural network in google colab", "tags": ["neural", "colab", "cppn"], "likes": 1, "viewed": 82, "published": "Public", "date": "1620029643", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define N_HIDDEN 16\n \nvec4 bufA[N_HIDDEN/4];\nvec4 bufB[N_HIDDEN/2];\n \n \nvec4 cppn_fn(vec2 coordinate, float in0, float in1, float in2, float in3) {\n    vec4 tmp;\n    bufB[0] = vec4(coordinate.x, coordinate.y, 0., 0.);\nbufA[0] = vec4(-0.17378594,-0.33053422,-0.36180705,0.46339378) + mat4(vec4(-0.4630560576915741,-0.1406053602695465,-1.4045069217681885,-0.6113854050636292),vec4(0.5664404630661011,-0.4835628271102905,0.7804951667785645,-0.6434755325317383),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\nbufA[1] = vec4(-0.10697374,-0.0612698,-0.47419977,-0.03617435) + mat4(vec4(0.7075297236442566,-0.5542700290679932,-0.2063709944486618,0.7497187256813049),vec4(-1.2660986185073853,-0.14948499202728271,-0.7836310863494873,1.169403076171875),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\nbufA[2] = vec4(0.19554143,0.2890092,0.1348906,-0.4888711) + mat4(vec4(0.08058620244264603,0.18168112635612488,1.7374930381774902,-0.16807301342487335),vec4(-0.22306324541568756,-0.49461469054222107,-2.1584603786468506,-1.5888121128082275),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\nbufA[3] = vec4(-0.19986203,0.19739842,0.031648707,-0.18387271) + mat4(vec4(0.2852761149406433,0.05213146656751633,1.4960402250289917,0.04980992525815964),vec4(-1.5774060487747192,0.6713035106658936,0.38498759269714355,0.5980242490768433),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\ntmp = sin(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(-0.23711596,0.42432317,-0.09344965,-0.39688757) + mat4(vec4(0.29784656,0.00018533482,-0.017557189,0.19570819),vec4(0.03799465,-0.055786297,-0.13084623,0.0052995663),vec4(0.11029955,-0.05403679,0.13239671,0.0018682976),vec4(-0.14913186,0.0908783,0.2876094,0.20004582)) * bufB[0] + mat4(vec4(0.09243081,-0.0051000346,0.038379848,-0.10864256),vec4(0.18237673,0.022116197,0.36696988,0.35716972),vec4(-0.033539925,0.07560058,-0.095868446,-0.3171695),vec4(0.15690331,-0.3547471,-0.27152503,-0.015743874)) * bufB[1] + mat4(vec4(-0.108457394,-0.13442542,-0.13557056,0.076305225),vec4(-0.16562903,0.07692469,-0.054051965,0.23289187),vec4(-0.07298815,0.14095557,-0.20537554,-0.23100805),vec4(0.057828642,0.07237708,-0.11801052,-0.12852171)) * bufB[2] + mat4(vec4(0.0744699,0.13127775,-0.24471296,-0.32725382),vec4(-0.35701364,-0.04296046,-0.07992607,-0.30038422),vec4(0.0039207907,0.29204634,-0.24004795,0.085469685),vec4(-0.26904094,-0.361859,-0.24083443,-0.20418486)) * bufB[3] + mat4(vec4(-0.17601478,-0.22819418,-0.076646596,-0.057756253),vec4(-0.12253244,-0.13912615,0.22804214,-0.33031407),vec4(0.18972738,0.123702765,-0.14236563,0.27851224),vec4(-0.32182944,0.15917192,0.106989615,0.24037243)) * bufB[4] + mat4(vec4(0.16761951,0.3393368,-0.056558765,-0.088764325),vec4(-0.06083204,-0.27845198,-0.19162817,-0.4313189),vec4(0.2500589,-0.38723475,0.18217644,-0.037159987),vec4(0.13613579,0.17310295,0.02013001,0.15715373)) * bufB[5] + mat4(vec4(-0.032083005,0.012128489,-0.1922314,-0.20471928),vec4(-0.0402207,-0.25481603,-0.036338873,-0.37182686),vec4(0.40620875,-0.12574263,-0.03948514,0.24590406),vec4(-0.00032020936,0.37159088,0.20010161,-0.006947675)) * bufB[6] + mat4(vec4(0.281306,0.18635319,0.1374897,-0.117242225),vec4(0.043626565,0.054990083,0.17889717,-0.32427552),vec4(0.0518423,-0.14314991,-0.085243836,-0.17838845),vec4(-0.5630495,-0.08853,-0.11867184,-0.41105747)) * bufB[7];\nbufA[1] = vec4(0.26200894,-0.31265026,0.33529425,0.2901435) + mat4(vec4(0.07142526,-0.0695661,-0.07203989,0.17566432),vec4(0.16744785,0.2966786,0.007160837,-0.31388178),vec4(-0.15432091,0.008324179,0.102352776,-0.26235053),vec4(-0.10588587,0.022596525,0.01970592,-0.2637005)) * bufB[0] + mat4(vec4(0.05993743,0.023435468,0.07122165,0.001565433),vec4(-0.047819387,-0.023491234,0.10337793,-0.34226575),vec4(-0.21747877,0.13785294,0.0319544,-0.32468653),vec4(0.22968301,-0.09479061,0.0999417,0.4353951)) * bufB[1] + mat4(vec4(0.029943952,0.31878915,-0.16593295,-0.016561069),vec4(-0.14472863,-0.03911228,-0.01910884,0.07089366),vec4(-0.1376534,0.03977708,0.012146834,0.035935868),vec4(-0.024747653,-0.13907784,0.04563045,0.018632596)) * bufB[2] + mat4(vec4(-0.1094923,-0.2028636,0.15639222,0.0713878),vec4(0.040411342,0.06301841,-0.029396445,-0.19840728),vec4(0.12818307,-0.15605159,-0.027058419,0.32953447),vec4(0.016128628,-0.06938622,-0.17840727,0.044384368)) * bufB[3] + mat4(vec4(-0.14548108,0.25201106,-0.19146505,0.019194713),vec4(-0.055204235,-0.031949557,-0.06755051,0.12932387),vec4(0.020860055,0.21425429,-0.096650995,-0.15560994),vec4(0.008083671,-0.0724474,-0.005672091,-0.1322552)) * bufB[4] + mat4(vec4(0.1543192,0.013404204,0.22433676,0.089155674),vec4(0.23780553,0.104742,-0.17620687,-0.06400651),vec4(0.04248659,0.0943532,-0.34906206,0.02273687),vec4(0.33589527,-0.14365393,-0.008189496,-0.1268628)) * bufB[5] + mat4(vec4(0.192486,-0.028524509,0.015517046,-0.10474593),vec4(-0.30805615,-0.06325286,-0.093326434,-0.26196155),vec4(-0.24274437,0.17053626,-0.3461374,0.035057794),vec4(0.0141108185,0.63463354,-0.116329364,0.09479396)) * bufB[6] + mat4(vec4(-0.09503691,-0.29076377,0.0092730485,-0.08690388),vec4(-0.12799911,0.25087413,0.08405792,-0.21696936),vec4(-0.07100653,-0.09539886,0.32432166,0.16011302),vec4(-0.25215334,-0.0049169683,0.060079634,-0.090367205)) * bufB[7];\nbufA[2] = vec4(0.028746044,0.17146076,-0.10473038,0.51480174) + mat4(vec4(-0.08843271,-0.47178903,-0.14164549,-0.09111566),vec4(-0.20610751,-0.013175843,-0.15081394,0.03975659),vec4(-0.123930715,-0.12961756,0.33314905,0.4203054),vec4(-0.25223678,0.15632227,-0.2711018,0.13357516)) * bufB[0] + mat4(vec4(0.21262217,-0.10706233,0.027212827,-0.12952001),vec4(-0.19022363,0.025947448,-0.22849138,-0.04406395),vec4(0.1562604,0.267026,0.028577449,-0.0012421554),vec4(0.16061911,0.0075982474,-0.09315764,0.007217589)) * bufB[1] + mat4(vec4(0.189975,-0.096541904,0.20872714,0.21575779),vec4(-0.028437905,0.5194053,0.2860259,0.16273855),vec4(-0.23596773,-0.17676459,-0.13450298,0.31600967),vec4(0.0635321,-0.11895465,0.06445332,-0.049861435)) * bufB[2] + mat4(vec4(0.36271578,-0.15052226,-0.34917638,0.110389665),vec4(0.20142268,-0.03421101,-0.08564189,-0.44116163),vec4(-0.17218621,0.055910297,0.17487438,-0.06809778),vec4(0.07458064,-0.36697227,0.17002343,0.17781769)) * bufB[3] + mat4(vec4(0.18840434,-0.26509944,-0.23710383,-0.16903003),vec4(0.30154628,0.044351548,0.17911907,0.10654474),vec4(0.1973299,0.1325085,0.1657429,0.071309805),vec4(-0.18114531,0.19318576,0.21116431,0.12412757)) * bufB[4] + mat4(vec4(-0.19067118,-0.25928563,-0.12834054,-0.62627685),vec4(0.0020580895,-0.08170072,0.115148805,0.035192568),vec4(-0.5218734,-0.16501805,0.14687426,-0.26290244),vec4(-0.11142398,0.080626845,0.10253352,-0.27726653)) * bufB[5] + mat4(vec4(-0.014450669,-0.09555511,-0.35921738,0.09969432),vec4(-0.012299911,-0.07721853,-0.0035463246,0.004906926),vec4(0.18783633,-0.098819025,-0.15474027,0.1937823),vec4(-0.008419537,0.21156722,-0.16931547,-0.01571325)) * bufB[6] + mat4(vec4(0.015508455,0.009897516,-0.087975144,0.10966389),vec4(0.124796174,0.043626577,0.29580066,0.06240527),vec4(0.050259337,0.23528792,-0.21674736,-0.009637339),vec4(0.1518264,-0.15551746,-0.15768577,0.07291677)) * bufB[7];\nbufA[3] = vec4(-0.12898026,-0.1790121,0.20043649,0.25497785) + mat4(vec4(0.4307262,0.07714075,0.0059149326,0.18245274),vec4(0.06021667,0.11922544,-0.0964087,0.033551395),vec4(-0.0384914,-0.09504101,0.06500772,0.17169565),vec4(-0.31146997,0.24954918,-0.2990976,0.05855876)) * bufB[0] + mat4(vec4(0.023153933,0.18498151,-0.032899827,0.116058916),vec4(0.24718757,0.27500698,-0.39123484,0.08001977),vec4(-0.08967905,0.11908575,-0.026811464,0.2808574),vec4(0.15934667,-0.019224605,-0.03597778,0.5255587)) * bufB[1] + mat4(vec4(-0.06997698,-0.24484593,-0.3155955,0.23383406),vec4(-0.1384901,-0.07598179,0.28004906,-0.19683816),vec4(0.3700422,0.23898275,-0.08711241,-0.16696443),vec4(-0.022421543,0.30003217,-0.14806543,-0.16010217)) * bufB[2] + mat4(vec4(-0.12956896,-0.14577703,-0.06548163,-0.09931665),vec4(-0.050230954,-0.15167229,0.079956256,-0.25508156),vec4(-0.009746297,0.1906664,-0.10553579,0.22805063),vec4(-0.119919494,0.008726356,-0.34571397,0.042227745)) * bufB[3] + mat4(vec4(0.29873633,0.24443346,0.1348652,-0.0005229186),vec4(-0.0071702967,0.20728005,-0.072160766,-0.14775097),vec4(0.17966054,-0.29104096,-0.23803408,0.16934423),vec4(0.19881994,0.25488907,0.028672947,-0.45591158)) * bufB[4] + mat4(vec4(0.30856833,0.0362047,-0.05239545,-0.08026196),vec4(0.2587587,0.18571414,0.015132018,0.091983035),vec4(0.21298279,0.3857059,-0.07692736,-0.21744981),vec4(-0.21410772,-0.061579105,-0.28920797,0.0042287232)) * bufB[5] + mat4(vec4(-0.1028291,0.69172364,0.22993422,0.045745164),vec4(-0.063901626,0.13055228,0.21207583,0.14491902),vec4(0.045198604,0.10366708,0.059028257,-0.20587595),vec4(-0.24381754,-0.019612053,0.45828125,-0.13179815)) * bufB[6] + mat4(vec4(0.39478287,0.1314168,-0.097578265,0.1403159),vec4(0.5103637,0.13146633,-0.314296,0.18186025),vec4(0.38234052,0.046336073,-0.010027228,0.5042722),vec4(0.16509892,0.02214179,0.12584606,0.0629027)) * bufB[7];\ntmp = sin(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(0.104241244,-0.15002999,0.32271346,0.29255736) + mat4(vec4(-0.06661802,0.114791416,-0.050502278,0.073508516),vec4(-0.10940022,-0.1803567,-0.08849068,-0.07200608),vec4(0.3508654,-0.053653922,-0.34686986,0.026490323),vec4(0.0015397263,-0.11624775,-0.1725478,0.007675705)) * bufB[0] + mat4(vec4(0.2625549,-0.5051978,0.118428126,0.11770489),vec4(0.24034935,-0.13114624,-0.118594855,0.14340131),vec4(-0.19289318,-0.01694821,0.3798529,-0.17517509),vec4(-0.1671261,0.2217429,0.0060225055,-0.085887894)) * bufB[1] + mat4(vec4(-0.08029078,-0.03200009,-0.22806975,-0.30965382),vec4(-0.010830268,0.0876625,-0.4834955,-0.17457798),vec4(0.17691454,-0.24991192,0.16512784,-0.06675202),vec4(0.075288,0.3930835,0.21911761,-0.12176125)) * bufB[2] + mat4(vec4(-0.024859015,-0.20528102,-0.1723803,0.12694155),vec4(-0.0032197642,0.022225562,-0.22651172,-0.0034156726),vec4(0.36033195,0.16865215,-0.010760951,0.13402611),vec4(0.013930607,-0.046229873,-0.06304444,0.2729994)) * bufB[3] + mat4(vec4(-0.24390672,0.008085924,0.1744352,-0.10507927),vec4(-0.11135021,0.24166247,0.2407738,-0.331831),vec4(0.39515975,0.12081949,0.17030743,-0.17028795),vec4(-0.033248577,-0.103238195,-0.16599497,-0.14884497)) * bufB[4] + mat4(vec4(-0.057387594,0.0014505567,0.015846089,0.13375634),vec4(0.010014693,0.028183416,-0.14385688,0.16714177),vec4(-0.4100174,-0.031236617,0.066837825,0.17367661),vec4(0.22409207,0.30766448,0.02442524,-0.2635978)) * bufB[5] + mat4(vec4(0.002130681,-0.27925956,0.14591283,-0.20278762),vec4(0.048882212,0.19018756,0.1286877,-0.359794),vec4(-0.28574678,0.30843943,-0.012492074,0.209106),vec4(0.018696861,0.22343403,-0.0016453338,0.055470694)) * bufB[6] + mat4(vec4(0.0066107926,-0.021617666,0.2154729,-0.07438639),vec4(-0.2973972,0.19656709,-0.48105603,0.27116498),vec4(-0.09988034,0.1700174,-0.2903337,0.04388444),vec4(-0.08923678,-0.43917435,0.16745299,0.23438023)) * bufB[7];\nbufA[1] = vec4(-0.16377512,-0.36509153,0.0055776467,-0.13404639) + mat4(vec4(-0.19322647,-0.037148383,-0.013727602,0.06021854),vec4(-0.14035052,-0.28066888,-0.039658558,0.094696894),vec4(0.083079785,0.063244976,0.056662336,0.1277245),vec4(-0.04611574,0.037483744,-0.12848085,-0.03788561)) * bufB[0] + mat4(vec4(0.07455067,-0.1806346,-0.28908163,-0.20818453),vec4(0.17329818,0.2000353,-0.10863288,0.06453177),vec4(0.041255344,-0.098181635,0.21675509,0.054619905),vec4(-0.042185023,0.27624482,0.06792231,0.0777548)) * bufB[1] + mat4(vec4(0.33574578,-0.09044749,-0.10802027,0.28938568),vec4(0.13276792,-0.010944816,-0.17255385,-0.23682585),vec4(-0.011880203,-0.24598417,0.04209651,-0.04146016),vec4(-0.10481718,0.16036624,-0.0799164,-0.11860304)) * bufB[2] + mat4(vec4(-0.04296834,-0.09653563,0.07890335,-0.10386397),vec4(0.02544269,0.22115499,-0.20544913,0.01752653),vec4(0.05628556,-0.152801,-0.39954874,0.15504232),vec4(0.28548244,-0.26562876,0.01879732,0.01738124)) * bufB[3] + mat4(vec4(-0.53970313,0.18346754,0.11358681,0.04663727),vec4(-0.029450122,-0.15069741,-0.17435604,-0.032926533),vec4(-0.20174454,-0.07448103,0.07759147,-0.18246453),vec4(0.12616557,0.05006203,0.04763043,0.55801547)) * bufB[4] + mat4(vec4(0.07162028,-0.12540579,-0.27616468,-0.017354475),vec4(0.18619981,-0.052859273,-0.21472853,0.20748821),vec4(0.09452557,-0.043054417,0.07701328,-0.06561767),vec4(0.13515681,0.001738657,-0.2827002,0.17984362)) * bufB[5] + mat4(vec4(-0.2989813,-0.2320694,0.10248132,-0.38952854),vec4(-0.085608356,0.24762869,-0.11006471,0.19804072),vec4(0.30333474,-0.16721496,-0.093439355,0.15301172),vec4(-0.010799506,-0.07813437,0.23839825,-0.40786102)) * bufB[6] + mat4(vec4(-0.16817144,-0.01387742,0.23453797,0.015165226),vec4(0.08413685,0.08943112,0.034840398,-0.16785859),vec4(0.16073245,0.059927076,-0.25156063,-0.2039184),vec4(-0.010360983,0.16144751,-0.41371563,0.34586444)) * bufB[7];\nbufA[2] = vec4(-0.2714947,-0.056463376,0.07782307,-0.411815) + mat4(vec4(0.15200163,0.21123272,-0.13066022,0.21887608),vec4(0.13861361,0.07026502,-0.0951047,0.06714838),vec4(0.14448461,0.13020933,-0.06477003,0.04609644),vec4(-0.24584873,0.35183626,0.28017256,0.26658338)) * bufB[0] + mat4(vec4(-0.23638172,0.16742472,0.14568372,0.207248),vec4(-0.0100160865,0.12540941,-0.15178645,-0.001663805),vec4(-0.07708243,-0.116249375,-0.2055844,-0.27016616),vec4(0.26199663,0.24601942,-0.13159543,-0.11674713)) * bufB[1] + mat4(vec4(0.08300112,-0.19355337,0.19393702,0.23741403),vec4(-0.14385934,0.10972383,-0.009883532,-0.09443482),vec4(0.11887304,0.23673813,0.2379594,-0.19379804),vec4(-0.1820436,-0.01464537,0.047007456,0.08292628)) * bufB[2] + mat4(vec4(-0.033112522,0.08620467,0.07073698,-0.03129439),vec4(-0.08372871,0.13585691,0.13474296,-0.07761418),vec4(0.0029698869,0.25744143,0.11384673,-0.10996305),vec4(0.37740636,0.019166943,-0.019858247,-0.020195914)) * bufB[3] + mat4(vec4(0.10249909,0.1369303,0.3979217,0.12897567),vec4(0.032222696,0.13196559,-0.16192263,-0.13167307),vec4(0.09644636,0.32187694,-0.121412545,-0.10035698),vec4(-0.24612437,0.18613946,0.2811596,-0.091884874)) * bufB[4] + mat4(vec4(-0.045718495,-0.31657463,0.175735,-0.029926702),vec4(-0.12546024,0.36884364,0.15244521,0.112144865),vec4(-0.22561888,-0.08891055,0.16575435,-0.28064668),vec4(-0.14620122,-0.12083687,0.112499945,-0.06648178)) * bufB[5] + mat4(vec4(0.18208566,-0.26204568,0.109804615,-0.3610197),vec4(0.30465943,0.21773209,-0.32546324,-0.02458141),vec4(0.12253581,0.06591868,-0.32960397,-0.17137472),vec4(-0.2654603,0.019929804,0.11040481,0.45874035)) * bufB[6] + mat4(vec4(0.24135561,-0.048627656,0.002526335,0.3878266),vec4(0.03197838,-0.013991297,-0.24775675,-0.031455047),vec4(0.187439,-0.04411331,0.16827762,-0.04593981),vec4(-0.083044015,-0.051227033,-0.07415953,-0.15605134)) * bufB[7];\nbufA[3] = vec4(0.33715162,-0.028193602,-0.13634785,0.41098428) + mat4(vec4(0.43617773,-0.12715581,-0.35383624,-0.21767074),vec4(0.028580127,0.14892606,-0.31512848,-0.019635135),vec4(-0.13391213,-0.2652795,0.20025504,0.1103034),vec4(0.08832512,0.08439371,-0.061231736,0.31258312)) * bufB[0] + mat4(vec4(0.13456595,0.008994816,-0.32453182,0.12190908),vec4(-0.046839017,-0.12022505,-0.016069595,0.075350784),vec4(0.05701537,0.6147755,-0.15605186,0.44857618),vec4(-0.1988637,-0.2101095,0.047412854,0.010586704)) * bufB[1] + mat4(vec4(-0.07745239,-0.051778316,-0.01740465,-9.0428715e-05),vec4(-0.10055167,0.29572186,-0.016777322,0.0350474),vec4(0.004563898,0.3589525,-0.33976677,-0.2172826),vec4(0.26195592,-0.012591633,0.13726915,-0.033199713)) * bufB[2] + mat4(vec4(-0.08647018,-0.5471934,0.012366649,0.052269995),vec4(0.09069844,-0.17819704,-0.03528704,0.17563233),vec4(-0.1762855,-0.10354954,0.15002607,0.05755097),vec4(0.19273758,-0.29396507,-0.07795022,0.20613366)) * bufB[3] + mat4(vec4(-0.088259935,-0.115231976,0.20269985,-0.059038207),vec4(0.30321434,-0.03028352,0.19317994,-0.007060973),vec4(-0.18762691,0.059122466,0.37090147,-0.15071529),vec4(0.089071326,-0.031437486,-0.37471,-0.103321396)) * bufB[4] + mat4(vec4(0.032576617,0.18383676,-0.36520123,-0.02866198),vec4(0.013392811,0.017488612,-0.11153475,-0.0045211283),vec4(0.09348213,-0.08844665,-0.14158317,-0.18930884),vec4(-0.11843933,-0.18390232,-0.21989357,-0.18419474)) * bufB[5] + mat4(vec4(-0.066360265,-0.030462997,-0.02929621,0.33316788),vec4(-0.29807636,0.16412868,-0.12657285,0.003492352),vec4(0.06533296,0.3527267,0.08038555,-0.32534847),vec4(0.24019471,-0.22511733,-0.14120606,-0.32456225)) * bufB[6] + mat4(vec4(0.09139222,-0.08863442,-0.21545398,-0.17863892),vec4(0.32023028,0.009192255,0.17218582,0.46483928),vec4(-0.32048535,-0.2603834,-0.010633039,0.06959446),vec4(-0.08479701,-0.23341851,-0.2611191,0.17444646)) * bufB[7];\ntmp = sin(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(0.08668692,0.20173755,0.33978668,-0.3992742) + mat4(vec4(-0.14953563,-0.16091408,0.18218216,-0.26882064),vec4(-0.20182101,0.20948125,-0.17361441,0.07324646),vec4(-0.11315109,0.13295159,-0.20366983,-0.080336355),vec4(-0.24650319,0.032262232,0.20050164,0.10729461)) * bufB[0] + mat4(vec4(0.1604232,-0.30735332,-0.1708133,-0.10396476),vec4(0.016809106,-0.042733677,0.02614076,0.22356403),vec4(0.22769704,-0.06610347,0.05637743,0.03486411),vec4(-0.16082841,0.10037083,0.07998157,0.18024588)) * bufB[1] + mat4(vec4(-0.04644219,0.22601907,0.33751285,-0.1496604),vec4(-0.29725528,-0.04523528,-0.007715155,-0.0012750549),vec4(0.28525728,0.010340082,0.096002564,0.039216727),vec4(-0.30153364,0.16096732,-0.27573854,-0.009824071)) * bufB[2] + mat4(vec4(0.45390576,0.09156221,-0.092045024,-0.050101258),vec4(-0.2105099,-0.17866147,-0.11359153,0.12277501),vec4(-0.11073111,0.23506463,-0.21296768,-0.24236467),vec4(0.32279366,-0.123668134,-0.01371257,-0.40119332)) * bufB[3] + mat4(vec4(0.106461674,-0.065369725,0.516892,0.14097251),vec4(0.18317783,0.16733962,-0.043314595,-0.06942767),vec4(0.33926612,0.18816997,-0.0912855,0.0067882217),vec4(-0.33597323,-0.41038683,-0.11607338,0.13874026)) * bufB[4] + mat4(vec4(0.022419725,-0.25508103,-0.20879798,0.13943861),vec4(0.35760337,0.044448085,-0.071325,-0.106590725),vec4(0.17203976,-0.060611695,0.39681,-0.3112837),vec4(-0.075788446,-0.40342638,-0.030350981,-0.5340898)) * bufB[5] + mat4(vec4(-0.24667946,0.11109491,-0.030137368,0.06882486),vec4(0.11516688,0.14804976,-0.01191681,0.15123777),vec4(0.054322544,-0.2138364,-0.32319498,0.1063594),vec4(0.12474338,0.14657632,-0.17336151,0.27769738)) * bufB[6] + mat4(vec4(-0.20066322,0.002558847,-0.2368439,0.13350758),vec4(0.040380985,0.13769661,-0.19347236,-0.06718632),vec4(0.07920611,-0.27416283,-0.24545085,0.1561946),vec4(0.042640284,0.043664727,-0.2798313,0.051272765)) * bufB[7] + in0;\nbufA[1] = vec4(-0.38935193,0.23690376,-0.0073320027,0.16997273) + mat4(vec4(-0.04965485,-0.07073161,-0.047066677,-0.27835476),vec4(-0.24377312,-0.1337633,0.13575594,0.37399575),vec4(-0.050121453,0.0973685,0.3665161,0.041197352),vec4(0.17709965,0.024673358,-0.16040623,-0.22652557)) * bufB[0] + mat4(vec4(0.26066586,0.07232818,-0.10228999,-0.019934623),vec4(0.5007158,0.013694456,0.22423644,0.12297291),vec4(-0.0332615,-0.24382015,-0.2259823,0.09350242),vec4(-0.16185646,0.2108412,0.3855168,-0.088593155)) * bufB[1] + mat4(vec4(0.15818341,0.08785109,-0.0011745706,-0.07466916),vec4(-0.35335526,0.20403564,-0.091450796,0.22851166),vec4(-0.21646437,-0.3086267,-0.07525509,0.23176531),vec4(0.02274331,-0.09963238,0.099195264,0.15617844)) * bufB[2] + mat4(vec4(-0.020084552,-0.19402617,-0.23486808,0.18219197),vec4(0.19979815,-0.08987569,-0.17827354,0.16478245),vec4(-0.1429545,-0.114327244,0.043954294,0.029745787),vec4(-0.03153012,0.33051005,0.1709118,-0.093784265)) * bufB[3] + mat4(vec4(-0.16749354,-0.29518405,0.14564459,-0.20410721),vec4(-0.3786217,-0.19872116,-0.36935645,0.20266242),vec4(0.19632259,0.027543008,0.25260478,0.25952682),vec4(0.44595453,-0.115121305,0.09684867,0.21342614)) * bufB[4] + mat4(vec4(-0.008221832,0.044090305,-0.33164993,0.051068556),vec4(0.4857533,0.051125474,-0.06796321,0.021224728),vec4(-0.40487742,0.006765455,0.11696745,0.14613427),vec4(0.411973,-0.18318316,0.116760954,-0.19561754)) * bufB[5] + mat4(vec4(0.15992382,-0.030735776,0.22749534,-0.036974803),vec4(-0.085383914,0.019127177,-0.2410003,-0.43788013),vec4(0.07094108,0.13743949,-0.12676072,-0.2074925),vec4(-0.48286185,0.10720475,0.3075348,-0.07991837)) * bufB[6] + mat4(vec4(-0.4950316,0.098303996,-0.095244884,0.033963032),vec4(-0.0793778,-0.2546853,0.082989864,0.054636925),vec4(-0.027396595,0.26075116,-0.10918459,-0.08600679),vec4(0.08308994,-0.1330271,-0.2410533,0.111577265)) * bufB[7] + in1;\nbufA[2] = vec4(0.0344931,-0.2311486,0.013775398,-0.44406587) + mat4(vec4(0.013030293,0.14745459,0.03256006,-0.06259347),vec4(-0.20635603,0.32404628,-0.039277412,0.25476748),vec4(0.35679182,-0.11899397,0.110442154,-0.16436665),vec4(0.106649935,0.007124768,-0.22185318,-0.19367805)) * bufB[0] + mat4(vec4(-0.28879207,-0.17904872,-0.27090207,0.009517955),vec4(-0.016534103,0.36730212,0.24058063,-0.1808351),vec4(0.17948508,-0.13573354,0.072450526,-0.23965696),vec4(0.15183374,0.13477916,-0.1268623,-0.21027122)) * bufB[1] + mat4(vec4(0.34311235,-0.13263205,-0.03183443,-0.19067952),vec4(0.062944844,-0.047795206,-0.11244204,-0.085750364),vec4(-0.14860637,0.16587587,-0.14964984,0.0001309929),vec4(0.18347588,0.035951193,-0.05260156,0.1404023)) * bufB[2] + mat4(vec4(0.19671997,-0.0005904671,-0.062453914,-0.19520223),vec4(-0.22028519,0.3956486,-0.19112508,-0.117752746),vec4(0.08464705,-0.14529829,-0.07619567,0.054384667),vec4(-0.0004535991,0.24323624,-0.18501435,-0.06803234)) * bufB[3] + mat4(vec4(-0.069994465,0.048310146,-0.2469803,-0.2365416),vec4(-0.04402546,-0.15261708,0.5071783,-0.22716407),vec4(0.19701529,-0.12851754,0.013054806,0.12972544),vec4(0.018667672,-0.14565738,0.015846625,0.0714882)) * bufB[4] + mat4(vec4(0.10788073,0.39918953,-0.11809575,0.053050052),vec4(0.0032177751,-0.27112967,-0.11318418,0.25555888),vec4(-0.045891356,-0.12735596,-0.19825171,-0.094837286),vec4(-0.22026592,0.56813514,-0.1490655,0.15700622)) * bufB[5] + mat4(vec4(0.09793594,0.27438948,0.09128696,-0.0483445),vec4(0.12404266,-0.16885543,0.13496986,-0.16198455),vec4(-0.098646715,-0.068197206,0.1965069,0.14962424),vec4(-0.10546266,-0.049534924,-0.15570314,0.018851511)) * bufB[6] + mat4(vec4(0.3670922,-0.38289073,-0.20400707,0.25444615),vec4(-0.14697513,0.16122784,0.30626273,0.47858825),vec4(0.38570774,0.05266037,-0.044608835,0.068098046),vec4(0.011413359,-0.33220735,-0.061782513,-0.40135133)) * bufB[7] + in2;\nbufA[3] = vec4(-0.3304839,-0.4117872,0.33692193,0.033195022) + mat4(vec4(-0.0050703604,-0.060020257,-0.17930935,-0.13196102),vec4(-0.20861255,-0.078476235,-0.20826676,-0.1875433),vec4(0.08521312,0.07043255,-0.027404228,0.38937953),vec4(0.18811594,0.112835854,-0.3982686,0.15888055)) * bufB[0] + mat4(vec4(-0.020847091,-0.17344119,0.1432418,0.021000555),vec4(-0.076157846,4.9826493e-05,-0.011398872,0.2692721),vec4(-0.12227223,-0.0497891,0.1229765,0.21788587),vec4(-0.04254806,0.11745938,0.23229982,0.2460931)) * bufB[1] + mat4(vec4(-0.43239716,-0.0036893415,-0.12566602,-0.18113102),vec4(-0.18100922,0.0743636,-0.2697902,0.35984063),vec4(-0.09149749,0.18091859,-0.4142307,0.11304354),vec4(-0.09712362,0.49949187,-0.0767137,-0.07148686)) * bufB[2] + mat4(vec4(-0.11355437,-0.27963775,-0.21429469,-0.18362609),vec4(0.05060169,-0.19603834,-0.043639395,-0.00091541006),vec4(0.06777871,-0.1292164,-0.058822792,0.11044048),vec4(-0.1639627,-0.12005531,-0.087174445,-0.30196828)) * bufB[3] + mat4(vec4(-0.014755415,-0.35662392,-0.07175542,-0.16727956),vec4(-0.07257352,0.19692627,0.058117505,0.17368422),vec4(-0.11393893,-0.20340899,-0.0034507667,-0.04690565),vec4(-0.17929582,-0.08374171,-0.09658052,0.12641996)) * bufB[4] + mat4(vec4(-0.15534864,-0.095814995,0.040069785,0.27101186),vec4(-0.152164,0.36137533,0.023494666,0.14842182),vec4(-0.24279925,-0.17582528,0.2394743,0.18872239),vec4(0.066810936,-0.341457,0.038152054,-0.0055244295)) * bufB[5] + mat4(vec4(-0.17787206,0.029906329,-0.2739796,0.014109061),vec4(-0.21428531,-0.023662833,-0.1151668,0.171542),vec4(0.1675191,0.033963393,0.013772501,-0.14586401),vec4(0.18239497,0.010177341,0.19694456,0.3577295)) * bufB[6] + mat4(vec4(0.14024931,0.11085744,0.03657954,-0.044212516),vec4(-0.102330945,-0.25308844,-0.16814335,-0.17960188),vec4(-0.26555604,0.26545492,-0.11542164,0.072735935),vec4(-0.029603813,0.17312622,0.29569072,0.21893197)) * bufB[7] + in3;\ntmp = sin(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(-0.1574457,-0.1407215,0.39763653,0.27358425) + mat4(vec4(-0.14621514,-0.042519417,-0.08131285,0.06663918),vec4(0.262993,-0.18019608,0.10185308,-0.03344825),vec4(-0.123635784,0.14194001,0.18744084,0.10707368),vec4(-0.017080778,0.2719207,-0.010730912,0.115483746)) * bufB[0] + mat4(vec4(0.03395917,0.33446696,-0.25485563,0.02294264),vec4(0.029079039,0.21733241,0.18093191,-0.1445942),vec4(-0.0435237,-0.036950193,-0.03439951,0.031487636),vec4(0.12372955,-0.095051296,0.39954418,0.08391839)) * bufB[1] + mat4(vec4(-0.0768911,0.007012952,0.23065504,0.012374076),vec4(-0.08296473,0.36888185,0.06000969,0.27855307),vec4(-0.2801436,0.28898588,-0.2341081,0.031556442),vec4(-0.025015179,0.001058989,-0.1894531,-0.2079568)) * bufB[2] + mat4(vec4(0.20717368,-0.13860795,-0.11646019,-0.0049930913),vec4(-0.24320605,-0.375298,0.15427893,-0.31176087),vec4(-0.10989622,0.14410637,0.14642937,-0.06451465),vec4(-0.11350388,0.107036166,0.16822283,0.14770654)) * bufB[3] + mat4(vec4(0.08729878,-0.059874788,0.033542365,-0.13305172),vec4(-0.38870037,-0.17138971,0.08931395,-0.3036096),vec4(0.22704242,0.15322532,-0.3508097,-0.13709287),vec4(0.17131718,0.04236534,0.23707448,-0.0065927724)) * bufB[4] + mat4(vec4(0.046739936,0.016199121,-0.2503412,0.052993897),vec4(0.20376018,-0.19643338,0.07659088,-0.28251877),vec4(0.043008585,0.14959377,0.17402987,0.22602884),vec4(0.2278197,0.044637054,-0.07839303,0.085699424)) * bufB[5] + mat4(vec4(-0.09299294,-0.42303964,0.16770731,-0.33230934),vec4(-0.07151157,-0.057365783,0.20605871,-0.19443116),vec4(0.16185993,0.25808975,-0.11425536,0.25665143),vec4(0.08180577,0.19019023,-0.19244847,0.12651475)) * bufB[6] + mat4(vec4(0.16182862,0.074445486,0.19593555,0.17765194),vec4(0.1765954,0.42085776,0.20766257,-0.21350908),vec4(-0.18966757,0.10403979,0.20349272,0.12082432),vec4(-0.063069195,-0.07815465,0.15024985,-0.27833676)) * bufB[7];\nbufA[1] = vec4(0.113131724,0.051117063,-0.28733644,-0.16000183) + mat4(vec4(-0.49886683,-0.12410287,-0.38236704,0.1835449),vec4(-0.096874975,0.003483653,0.01411685,-0.23588182),vec4(-0.05225482,-0.03840161,0.26059338,-0.017658401),vec4(-0.2333203,-0.24450484,0.06345995,0.28058335)) * bufB[0] + mat4(vec4(0.13494207,0.08844836,-0.40833446,0.059895236),vec4(-0.48724523,-0.1001479,0.04246714,0.04224346),vec4(0.04238901,0.007701227,-0.015761742,0.2691061),vec4(-0.31557944,0.03222982,0.13698508,0.012299907)) * bufB[1] + mat4(vec4(-0.089284785,0.30447233,-0.1576518,-0.07488339),vec4(0.029489107,0.3493359,0.26847336,0.028592866),vec4(0.11183853,0.2630818,-0.14045553,0.10161658),vec4(-0.09161176,0.09453041,-0.453771,0.12708126)) * bufB[2] + mat4(vec4(-0.01750205,0.14435597,0.04670053,0.15716983),vec4(-0.05667547,0.20413536,0.038088676,-0.14760761),vec4(0.12702574,0.10299957,0.03997046,0.029896995),vec4(0.32269096,-0.11870147,0.037157554,-0.1750353)) * bufB[3] + mat4(vec4(-0.05016083,0.20567675,-0.085946046,-0.15207101),vec4(-0.001565708,-0.08211358,-0.2687366,0.0375415),vec4(0.079514295,0.25222102,0.25695986,0.035563592),vec4(0.08839153,0.24145147,-0.1209788,0.22456655)) * bufB[4] + mat4(vec4(0.19478053,0.3516787,-0.3604202,0.098727375),vec4(0.120274365,-0.04834557,0.124497846,0.277495),vec4(-0.07472436,-0.06252204,-0.095957264,-0.13526522),vec4(-0.19881524,-0.13599694,0.0012329731,0.2507101)) * bufB[5] + mat4(vec4(0.31085873,-0.047147546,0.28970343,0.19564284),vec4(-0.03587659,0.098362066,0.14306188,0.25992534),vec4(0.45695385,-0.039768,0.21299756,-0.10244706),vec4(0.09868965,-0.036508802,-0.06721909,-0.4473875)) * bufB[6] + mat4(vec4(0.06505594,-0.4429624,-0.049169216,-0.09240787),vec4(-0.3151095,0.12062326,-0.14799486,0.094628304),vec4(0.032870345,0.20610781,0.17840266,0.06907777),vec4(0.16967963,-0.25835693,-0.039344404,0.009849705)) * bufB[7];\nbufA[2] = vec4(0.14199196,0.26332152,0.42373985,-0.48015794) + mat4(vec4(0.08869301,-0.018610729,-0.078511916,-0.075749286),vec4(0.09630663,-0.2717524,0.017621646,-0.101726845),vec4(0.039628237,-0.04599638,0.09628487,0.48749992),vec4(-0.08624445,0.08469682,0.0002877514,0.071443915)) * bufB[0] + mat4(vec4(-0.03371789,0.11535962,-0.2212208,-0.073093966),vec4(0.0126845855,0.34424797,-0.20210116,0.031598732),vec4(0.086472765,-0.47726133,0.039055366,0.0536365),vec4(-0.13963172,-0.16480474,-0.010336658,0.15249506)) * bufB[1] + mat4(vec4(0.16428936,-0.2305075,0.020642536,-0.25921953),vec4(0.07332153,0.32136375,0.21558091,0.031351395),vec4(0.21803428,-0.08920994,-0.09338292,-0.3446599),vec4(0.22094506,-0.13743414,0.044642203,-0.002748596)) * bufB[2] + mat4(vec4(0.19813988,-0.049277954,-0.39941004,-0.12996767),vec4(0.09583304,-0.10071346,0.38654706,-0.047631845),vec4(-0.017084664,0.06351794,-0.2511669,0.3619706),vec4(0.3221873,-0.059014525,0.17708553,0.14198504)) * bufB[3] + mat4(vec4(-0.23913883,0.088829055,0.031898044,0.20933518),vec4(0.23857442,0.06805803,0.07135931,0.044975568),vec4(-0.22620983,-0.13377756,-0.30578482,-0.044184007),vec4(0.20110008,0.11912737,0.18584497,0.1284832)) * bufB[4] + mat4(vec4(0.032648083,0.3469904,-0.10541932,-0.014142806),vec4(0.35710818,-0.13572007,0.1069668,-0.12318482),vec4(-0.28167754,-0.35322657,0.19682208,-0.23416996),vec4(0.24756202,-0.111276895,-0.16189697,-0.111408904)) * bufB[5] + mat4(vec4(-0.43934625,0.16602717,-0.18610942,-0.14403671),vec4(-0.13507861,0.02224525,-0.13593155,-0.24256732),vec4(0.11076023,-0.047745373,-0.4187117,-0.027991623),vec4(-0.23266503,0.15351565,0.0018119847,-0.21296075)) * bufB[6] + mat4(vec4(0.5100226,-0.22400168,0.05998884,0.03765348),vec4(0.029751696,0.10517415,-0.14505626,-0.19710487),vec4(-0.17723025,-0.26934543,0.1761357,0.34779322),vec4(0.30972075,0.017677737,0.20007776,0.11469318)) * bufB[7];\nbufA[3] = vec4(-0.19395252,0.27670807,-0.097107895,-0.27948532) + mat4(vec4(0.11882188,0.04442391,0.039649397,-0.0117237065),vec4(-0.24152525,0.18380122,0.19079462,0.041907217),vec4(-0.009592627,0.0035411976,-0.22241354,-0.045008224),vec4(-0.03059441,-0.38512146,0.13405442,-0.029147746)) * bufB[0] + mat4(vec4(0.13894837,0.1562348,-0.1210894,0.20042804),vec4(0.2578225,-0.20107181,-0.047009405,0.22697335),vec4(0.14522271,0.15528353,0.30605796,-0.06551036),vec4(0.09177627,0.10261897,-0.12745844,-0.4502035)) * bufB[1] + mat4(vec4(-0.11600401,-0.022440467,-0.10895245,-0.01175877),vec4(0.010211963,0.3068374,0.047803115,0.13396783),vec4(-0.037255347,-0.114540614,0.16205736,0.20857598),vec4(0.2822134,0.2833279,0.29104236,-0.09713708)) * bufB[2] + mat4(vec4(-0.25530168,-0.08949236,0.20392129,-0.06276272),vec4(0.1120791,-0.14099759,0.030606827,0.44142047),vec4(-0.43596354,0.09721461,-0.062550426,-0.18072319),vec4(0.15388466,-0.27047503,-0.23228577,0.1274572)) * bufB[3] + mat4(vec4(0.30940828,0.11648289,0.16986248,0.044975527),vec4(-0.044971973,0.0056645176,-0.38878426,0.074381374),vec4(-0.055878695,-0.4392278,-0.42984712,0.19098817),vec4(-0.27300626,-0.07945296,-0.272592,0.20521244)) * bufB[4] + mat4(vec4(0.46187958,0.008996141,0.118659206,-0.0528622),vec4(0.14076747,0.03939278,-0.25950468,0.060779907),vec4(-0.14466988,0.1053594,0.0268155,0.042941313),vec4(-0.3427955,0.51275116,0.15581954,-0.34161982)) * bufB[5] + mat4(vec4(0.17437685,-0.015457904,-0.16119958,0.00661621),vec4(-0.094904035,0.09067362,-0.36283872,-0.14778359),vec4(0.21466023,0.19555968,-0.052959494,-0.06768111),vec4(-0.16599211,-0.078529015,-0.024722459,0.07383542)) * bufB[6] + mat4(vec4(0.21108015,0.23728792,-0.12509352,0.15194221),vec4(-0.04147643,-0.14682782,-0.06408775,-0.027660351),vec4(0.20107283,0.0956774,0.17591849,0.38266098),vec4(0.040539816,-0.043066565,0.071928486,0.30405122)) * bufB[7];\ntmp = sin(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(0.39491123,-0.2317018,0.04749958,0.28140262) + mat4(vec4(-0.034619533,-0.19410956,0.06253238,0.12502271),vec4(0.1585721,0.051026724,0.16619706,-0.07066971),vec4(-0.03877852,-0.007162624,0.011919597,0.07358043),vec4(0.29432943,-0.07330443,0.1542398,0.17597535)) * bufB[0] + mat4(vec4(-0.022906963,-0.008296975,0.048529916,0.008807753),vec4(0.25268617,0.45196807,0.09955092,-0.118925236),vec4(-0.14551869,0.033837292,-0.14672217,-0.101409584),vec4(0.39329267,0.112048395,-0.15304072,0.087676115)) * bufB[1] + mat4(vec4(-0.24436757,0.14146625,0.3069398,0.42021564),vec4(-0.18238409,-0.034733012,0.40545827,-0.13413666),vec4(-0.047786012,0.10496479,-0.025595848,0.22381511),vec4(-0.050818104,-0.13213614,0.14811492,-0.37926477)) * bufB[2] + mat4(vec4(0.39836133,0.23936372,-0.18672904,0.1228167),vec4(0.25510344,0.50222385,0.05429839,0.10050322),vec4(0.059109364,-0.17980185,0.28247395,-0.05491541),vec4(0.12170096,0.049915113,0.33595434,0.11312693)) * bufB[3] + mat4(vec4(-0.030162092,-0.044570882,-0.110533506,0.52070487),vec4(0.01934753,0.14863221,-0.42124927,-0.25482285),vec4(-0.013464151,-0.25049338,-0.043372408,-0.021403452),vec4(-0.45938563,0.0518097,0.097797886,-0.0625627)) * bufB[4] + mat4(vec4(0.14642419,0.042751163,0.049543545,-0.32920384),vec4(-0.017603755,0.2774385,0.20202833,0.049700003),vec4(0.050617725,0.23290537,0.073071286,0.1905834),vec4(0.272042,0.07464707,-0.30378073,-0.091951266)) * bufB[5] + mat4(vec4(-0.26268497,0.1344796,0.015489468,-0.048779372),vec4(0.027289614,-0.39970762,-0.031081187,-0.29385984),vec4(-0.034051962,-0.023986643,0.1075012,0.20537242),vec4(0.038631327,-0.15702105,-0.090520725,0.2804726)) * bufB[6] + mat4(vec4(0.31436253,-0.08862122,0.43962327,-0.25722188),vec4(0.26663223,0.05308075,-0.51866955,0.28715235),vec4(0.4215889,-0.029164758,-0.09765248,-0.09937273),vec4(0.30339113,0.06398209,-0.024763487,-0.017836496)) * bufB[7];\nbufA[1] = vec4(-0.050978485,0.3760832,0.34009936,0.030308107) + mat4(vec4(-0.107827686,-0.13931304,0.02353387,0.2516376),vec4(-0.18799649,-0.10046195,0.022681842,0.049260266),vec4(0.09494933,0.42849782,-0.034258913,0.02779038),vec4(-0.2982634,-0.12599528,0.009716077,-0.13616636)) * bufB[0] + mat4(vec4(-0.022547346,0.028132778,-0.019201608,0.042471927),vec4(0.14374964,-0.08372797,-0.2820361,0.09788078),vec4(0.12032453,-0.40733725,0.5384481,-0.16637965),vec4(0.18787786,0.022400657,-0.060399003,0.23453341)) * bufB[1] + mat4(vec4(-0.06435522,0.003217937,0.25644624,0.1779577),vec4(-0.04751259,0.3020468,0.118175246,0.05475494),vec4(0.27098894,-0.21694237,-0.08700668,-0.27252987),vec4(0.09758576,0.06341542,-0.14804615,-0.32847807)) * bufB[2] + mat4(vec4(-0.018379526,-0.13380839,-0.21669258,0.16368808),vec4(0.0020201746,0.06794339,0.3886824,-0.05027457),vec4(0.0158717,0.011854901,0.028099807,-0.076353036),vec4(0.3127806,0.29702184,0.19386761,-0.46586967)) * bufB[3] + mat4(vec4(0.33571365,0.09581493,0.013893084,0.099606134),vec4(-0.0729439,-0.14998668,0.006810537,0.055669013),vec4(-0.07406122,-0.10705439,-0.011358494,-0.032665372),vec4(0.013679689,-0.25982505,-0.36521152,0.6042962)) * bufB[4] + mat4(vec4(0.0021550194,0.2950519,0.41558987,-0.1203662),vec4(0.07848548,-0.38834605,-0.14064935,-0.09955795),vec4(0.02693778,-0.054182164,0.26384652,-0.27696157),vec4(0.43964168,0.15913005,0.35420337,0.13106982)) * bufB[5] + mat4(vec4(-0.08342092,-0.47731483,-0.20847169,-0.0724977),vec4(0.088274516,0.041809425,0.2996059,-0.048415564),vec4(-0.20981403,0.22083254,0.033332326,-0.13023736),vec4(-0.5067604,0.26548457,0.5611813,-0.2348385)) * bufB[6] + mat4(vec4(-0.016887505,0.10273023,0.27965087,0.083036505),vec4(0.34376937,0.004419182,-0.120767504,0.0622205),vec4(0.20302278,0.1471733,0.028612316,-0.4577389),vec4(-0.033218447,0.21417348,0.31312764,0.07541332)) * bufB[7];\nbufA[2] = vec4(-0.41900232,-0.430785,0.08272184,0.040871788) + mat4(vec4(-0.053571932,0.32452476,0.0060938704,0.11525163),vec4(-0.0881415,0.08291078,0.23831688,0.20927685),vec4(-0.08093251,-0.057346012,-0.1819127,0.28518322),vec4(0.24459162,-0.3248638,0.25936785,-0.113419525)) * bufB[0] + mat4(vec4(0.10057491,-0.08586404,0.12867811,-0.40478486),vec4(0.12480605,0.14800292,-0.014875234,-0.09860808),vec4(0.08311935,0.09160319,0.50927836,-0.18045782),vec4(0.08890828,-0.034021296,0.06872074,0.36688712)) * bufB[1] + mat4(vec4(0.17859809,-0.16811995,-0.039704766,0.2513931),vec4(0.37110263,0.16703233,-0.10665025,-0.23058352),vec4(0.20800138,-0.09097072,0.055002637,0.102072656),vec4(0.21922065,0.17522666,-0.02134278,-0.043394517)) * bufB[2] + mat4(vec4(0.26005322,0.074994035,0.18829979,0.22338164),vec4(0.14624749,0.17932062,0.12051354,-0.14086814),vec4(0.2150964,0.114182554,-0.46312103,-0.4326353),vec4(-0.3338251,0.11260562,0.040990528,-0.12936871)) * bufB[3] + mat4(vec4(0.09324332,0.23040408,0.22020318,0.18787229),vec4(-0.7480972,0.051464964,0.2755829,-0.3159502),vec4(0.10627569,-0.29327953,-0.11886804,-0.23932588),vec4(-0.1954175,-0.28126642,-0.073980525,-0.043368272)) * bufB[4] + mat4(vec4(-0.3652483,-0.059610475,0.029130433,0.18209536),vec4(0.12969734,0.06821311,0.12728724,0.08633351),vec4(-0.069684744,-0.3733621,0.08927465,0.1803361),vec4(0.10389765,0.5333732,-0.1532256,-0.026063088)) * bufB[5] + mat4(vec4(0.06784348,-0.14126422,0.351084,0.19255327),vec4(0.30548853,-0.13629393,0.21657082,-0.21338767),vec4(0.536654,-0.2997819,-0.3088477,-0.016330052),vec4(0.1517045,-0.11312401,-0.34435797,0.15408456)) * bufB[6] + mat4(vec4(0.21023783,0.28775448,0.044572294,0.02140548),vec4(-0.060143873,0.07794016,0.02379405,-0.32873935),vec4(-0.07930481,-0.12682635,-0.15941033,-0.27650094),vec4(0.02926378,0.35945475,-0.11034766,-0.40334937)) * bufB[7];\nbufA[3] = vec4(0.15694848,-0.5078177,-0.0698434,-0.22054417) + mat4(vec4(0.5080282,0.17728575,0.016230768,0.1270502),vec4(0.21683703,0.08815561,-0.07919155,0.16873504),vec4(0.14799778,-0.022694116,-0.044155553,0.19590575),vec4(0.35054845,0.103300564,-0.19983657,-0.36108613)) * bufB[0] + mat4(vec4(0.103831105,0.30472985,0.09224011,0.33281752),vec4(-0.0976304,-0.15097839,-0.30386066,-0.28555298),vec4(0.12866463,-0.118059464,0.145126,-0.111240804),vec4(-0.29510373,0.076698266,0.2672489,-0.014552625)) * bufB[1] + mat4(vec4(-0.26072684,-0.42390275,0.049369868,-0.15295105),vec4(-0.085232474,0.32934484,-0.13750443,0.47072843),vec4(0.35253128,0.19671667,-0.031062428,0.043877523),vec4(-0.32932228,-0.061850194,0.06083887,0.21300982)) * bufB[2] + mat4(vec4(0.14151046,-0.0099804485,0.078435704,-0.1534058),vec4(0.027060252,-0.0031539768,-0.18627013,0.21839404),vec4(-0.030303864,-0.4119556,-0.2098375,0.20087673),vec4(-0.033494048,0.049016513,0.04594378,0.0073439456)) * bufB[3] + mat4(vec4(0.37008607,0.20649393,-0.3688166,-0.40358928),vec4(-0.1293342,0.012148352,-0.018419884,-0.2559438),vec4(0.18831599,-0.06925411,-0.3856291,-0.0012990618),vec4(-0.15026477,0.4301389,0.20284311,-0.14458157)) * bufB[4] + mat4(vec4(-0.07473835,0.109486304,0.05591279,-0.098994024),vec4(-0.27643022,-0.20180966,0.1613275,-0.25664437),vec4(0.041500118,-0.18423691,-0.2967526,0.43820038),vec4(-0.58912206,0.09852606,-0.23350495,0.016775435)) * bufB[5] + mat4(vec4(0.23005247,0.0108532915,0.3083805,0.016467229),vec4(-0.05202126,0.28361595,0.17235248,-0.13732113),vec4(-0.10583337,-0.30155438,0.0857305,-0.15767705),vec4(-0.13083473,0.3004976,-0.086078994,0.22325625)) * bufB[6] + mat4(vec4(0.007154786,-0.062517196,-0.017326772,-0.082408324),vec4(0.0049786624,0.27987865,0.07196608,-0.0538819),vec4(0.27135164,-0.2591038,-0.08498631,0.107737355),vec4(-0.25257346,-0.10807085,-0.040958785,-0.13529009)) * bufB[7];\ntmp = sin(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(0.41058564,0.064643644,-0.15822749,0.2170244) + mat4(vec4(-0.18700525,-0.16910695,0.2988444,0.20156753),vec4(0.0771305,-0.112052284,0.16890559,-0.31283975),vec4(0.24639498,0.10485342,-0.120225236,0.06383739),vec4(-0.07842917,-0.38173088,0.53330106,0.28641656)) * bufB[0] + mat4(vec4(0.14557403,-0.09332241,0.011370377,-0.32169494),vec4(-0.0955753,-0.023933284,-0.017583909,0.034748986),vec4(0.1349177,-0.15221776,0.19010012,-0.42519477),vec4(0.06737422,0.30403665,0.1877549,-0.1489272)) * bufB[1] + mat4(vec4(-0.2619957,-0.2085869,0.06505454,-0.27613187),vec4(0.5392312,0.26228714,-0.18716894,0.20252919),vec4(0.17709735,-0.07662912,-0.06858717,-0.25392517),vec4(-0.15525731,-0.011899927,0.32793453,0.05505246)) * bufB[2] + mat4(vec4(-0.3338446,-0.27227685,0.15576097,0.072081596),vec4(-0.14129895,0.36450973,-0.04248954,0.17197533),vec4(0.16797215,-0.29476228,-0.03520058,-0.0018099636),vec4(0.40727437,-0.18554851,0.07219926,-0.17385884)) * bufB[3] + mat4(vec4(-0.19102833,0.203544,-0.56285274,0.3001769),vec4(-0.7580593,-0.12855251,0.11474961,0.20651947),vec4(-0.13340805,0.26051515,0.5285911,-0.14557116),vec4(-0.13358697,-0.018299026,-0.238024,0.16907059)) * bufB[4] + mat4(vec4(-0.060758326,0.05308886,0.039729174,0.16524684),vec4(0.32098895,-0.32545048,-0.2217476,0.21249472),vec4(0.014002536,0.26172704,-0.30560654,-0.10760665),vec4(0.055186283,-0.17630643,-0.060477536,-0.508138)) * bufB[5] + mat4(vec4(-0.08103348,0.107692175,-0.32025692,0.04974257),vec4(-0.22546054,0.0004236673,-0.21697545,-0.0931659),vec4(0.13401528,-0.1346902,0.14568287,-0.048698895),vec4(-0.38374323,0.049287707,0.11418837,0.2661865)) * bufB[6] + mat4(vec4(-0.15379585,-0.04794955,-0.024905382,-0.6540317),vec4(0.3559184,0.34628558,-0.26805708,0.048282143),vec4(0.10541019,-0.22286548,0.20705067,-0.19231525),vec4(-0.2173642,0.1538304,0.18289582,-0.121082045)) * bufB[7];\nbufA[1] = vec4(0.23781553,-0.14383982,0.47872522,-0.1451952) + mat4(vec4(-0.027903365,-0.10079011,0.423167,0.0041578477),vec4(-0.09326443,0.2916924,-0.06387694,0.13864717),vec4(-0.010352416,0.41718093,0.09373057,0.6035112),vec4(-0.3985842,-0.08897017,-0.024865046,-0.35883602)) * bufB[0] + mat4(vec4(0.009542283,0.48771256,-0.0050805705,-0.12870717),vec4(-0.16275227,0.019308385,-0.23698509,0.16713977),vec4(0.19774084,0.12212886,-0.23931645,0.23558034),vec4(0.37593678,0.2510279,-0.31060728,-0.19018947)) * bufB[1] + mat4(vec4(-0.19097602,0.24400614,0.09616479,0.007755766),vec4(0.09610495,0.17308979,0.004471356,0.0064092367),vec4(0.08764328,0.0011622381,0.11542379,-0.33715317),vec4(-0.036428723,-0.11006172,0.19401434,-0.15191013)) * bufB[2] + mat4(vec4(0.06303415,0.3124889,0.41226256,0.10547304),vec4(-0.10203473,-0.05524978,0.12160131,-0.008557606),vec4(0.08355324,0.2834325,0.4092714,-0.19220054),vec4(0.37992272,-0.07418925,0.26683694,-0.032425217)) * bufB[3] + mat4(vec4(-0.09776129,0.085763685,-0.45323488,-0.05879688),vec4(-0.028370079,0.1604577,-0.5335547,0.3825858),vec4(0.237868,-0.03484486,-0.06551293,0.17500806),vec4(0.020325268,0.15452035,-0.18756783,-0.060321793)) * bufB[4] + mat4(vec4(0.3105477,-0.33810163,-0.33789846,0.010041251),vec4(-0.18936984,-0.08676943,0.15940355,0.13278148),vec4(-0.14122744,0.1934571,0.39057595,0.29995254),vec4(-0.10684604,-0.037655693,-0.0878498,-0.5753429)) * bufB[5] + mat4(vec4(-0.31677705,-0.13481598,0.012935558,-0.24283329),vec4(0.12246203,0.15460856,-0.34993017,-0.1734684),vec4(0.49273223,0.21816593,0.16174933,0.015878875),vec4(-0.08604914,0.041722074,-0.04346362,-0.11545592)) * bufB[6] + mat4(vec4(-0.25375092,-0.12297583,0.18281008,-0.07898542),vec4(-0.09090569,-0.0074983113,0.24996841,-0.6273965),vec4(0.048504755,-0.0329251,-0.24606818,0.13774987),vec4(-0.015320295,0.040456954,-0.39167383,-0.14055768)) * bufB[7];\nbufA[2] = vec4(0.032163765,0.021270305,0.25951904,0.007055809) + mat4(vec4(0.22382835,-0.021619016,0.06829026,0.22646542),vec4(-0.04187658,0.24654056,0.046781868,-0.07976851),vec4(0.10746051,-0.11374241,0.07798015,-0.19807784),vec4(0.12756556,0.01816865,0.1882007,-0.30311674)) * bufB[0] + mat4(vec4(-0.54878986,0.15464465,-0.104754195,-0.07808949),vec4(0.3505593,0.025964258,0.059788086,-0.015866734),vec4(0.0993093,0.090219885,-0.20230196,-0.02983536),vec4(0.342443,-0.38187966,-0.20658746,-0.20738877)) * bufB[1] + mat4(vec4(0.31205016,-0.06530899,0.040335666,0.011455084),vec4(-0.30703974,0.17933711,0.11136399,0.14845587),vec4(-0.4790322,0.019242408,-0.45779955,-0.16027263),vec4(0.05950086,-0.12859856,-0.16045657,-0.009161978)) * bufB[2] + mat4(vec4(0.009158417,0.2637287,0.092580505,-0.005458683),vec4(-0.04410513,0.22551571,-0.2593443,0.05739978),vec4(-0.20292577,-0.16497952,-0.044224013,-0.052490447),vec4(0.0962889,-0.04956368,0.19327337,0.18866466)) * bufB[3] + mat4(vec4(0.16127974,0.033472203,0.07410594,0.12402455),vec4(-0.1773482,0.25030786,0.15009327,0.52167577),vec4(0.048629425,-0.35424587,-0.32763478,0.04829966),vec4(-0.03434595,-0.1190793,-0.09635671,0.11248948)) * bufB[4] + mat4(vec4(-0.3355388,-0.07658784,-0.030438961,0.22820964),vec4(0.19454266,0.23168086,0.13454491,-0.1739402),vec4(-0.31744066,-0.38507074,-0.10388774,0.0996625),vec4(-0.4441828,0.5389134,-0.123599306,0.024136629)) * bufB[5] + mat4(vec4(0.065585256,-0.18166249,0.14307246,-0.042614274),vec4(-0.15080619,-0.17090592,-0.013732248,-0.1523059),vec4(0.11574554,-0.21846619,-0.029175062,0.2716702),vec4(0.029739512,-0.09695879,0.338853,-0.019027345)) * bufB[6] + mat4(vec4(0.19650672,-0.058670968,-0.21842031,0.131448),vec4(0.50687635,0.43859366,-0.12850134,0.19662595),vec4(-0.092762776,0.044781666,-0.17048928,-0.68296474),vec4(0.33426142,-0.13456175,0.12672237,0.2380257)) * bufB[7];\nbufA[3] = vec4(0.25474325,-0.31222183,0.16352767,0.39400595) + mat4(vec4(-0.026944488,-0.41625124,-0.48900867,0.011999754),vec4(-0.10073728,-0.5117083,-0.09071102,0.06894117),vec4(-0.07307071,-0.12975107,-0.19039358,-0.01638825),vec4(0.38245672,0.11189089,0.22177422,0.16873595)) * bufB[0] + mat4(vec4(-0.11224706,0.28863502,0.15333857,-0.28977954),vec4(0.16013251,0.039201476,-0.0802299,0.2288571),vec4(0.16565427,0.49510795,0.28182566,-0.055298403),vec4(0.08809145,-0.5103864,-0.02077656,-0.1751976)) * bufB[1] + mat4(vec4(-0.48603204,0.2576923,0.30429012,0.08524322),vec4(-0.38641992,-0.27093536,0.029487882,0.058934126),vec4(0.29984453,0.33464485,0.11440555,0.32391515),vec4(-0.07721814,-0.12075013,0.1844466,0.089683525)) * bufB[2] + mat4(vec4(-0.27966627,-0.16332515,-0.38274145,-0.15301992),vec4(-0.18509497,-0.24954632,0.24979138,-0.005837138),vec4(0.0083870785,-0.23482223,0.035039052,0.043307055),vec4(0.30561715,0.25662398,-0.114876054,-0.0892956)) * bufB[3] + mat4(vec4(0.1771293,0.15581793,0.22130367,0.21559033),vec4(0.010912611,0.16474669,0.27464962,-0.24137017),vec4(0.18189088,-0.32309663,-0.011761061,-0.046749048),vec4(-0.2450929,-0.05879509,-0.17295958,-0.19430138)) * bufB[4] + mat4(vec4(0.20554864,0.11726335,0.012404967,0.43123248),vec4(0.1971802,-0.20520112,-0.31665716,0.119273275),vec4(0.07885068,0.054547332,-0.28232017,-0.22368528),vec4(0.24766664,-0.061157294,0.3781532,0.12373949)) * bufB[5] + mat4(vec4(0.08509648,-0.16342342,-0.20749122,0.034020375),vec4(0.19531216,0.3550228,0.15746637,-0.17909029),vec4(-0.098595805,-0.07980739,-0.055360544,0.13188377),vec4(-0.06360334,0.08643262,-0.30927214,0.20147584)) * bufB[6] + mat4(vec4(-0.09360386,0.20554666,-0.17268917,-0.39484343),vec4(-0.044414837,-0.20561963,0.24295738,0.13238649),vec4(0.340848,0.54230237,-0.38246432,0.24272695),vec4(-0.084959306,-0.39143303,0.274361,-0.056290988)) * bufB[7];\ntmp = sin(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(0.3387523,0.3129564,-0.1514011,0.20532952) + mat4(vec4(-0.26730356,-0.053499542,-0.53140426,-0.04180316),vec4(0.581809,-0.024942439,0.1475397,0.3214593),vec4(0.05138256,0.12392175,-0.16133437,0.05160326),vec4(-0.43691492,0.6413603,0.6055176,0.07193967)) * bufB[0] + mat4(vec4(0.2786821,0.014848554,0.25879908,-0.14176594),vec4(0.1898684,-0.007989775,0.46640727,-0.27183685),vec4(0.034968674,0.1815524,-0.06456613,-0.13821453),vec4(0.15167777,0.17179954,0.07124912,0.04260359)) * bufB[1] + mat4(vec4(0.3194787,0.19740401,0.07114227,-0.10212059),vec4(0.10813665,-0.21931592,0.0038894983,0.103068635),vec4(0.1005487,-0.09461911,0.54441774,0.17722787),vec4(0.32550246,-0.28575128,-0.26758826,-0.22531022)) * bufB[2] + mat4(vec4(-0.24562575,-0.32645068,-0.07934324,0.11164956),vec4(-0.094929785,-0.15700164,0.06391748,0.020483095),vec4(-0.17272688,-0.2171832,-0.014723391,-0.491574),vec4(-0.32334152,-0.08009769,0.2670623,0.02029354)) * bufB[3] + mat4(vec4(0.08861521,0.060214166,0.03135315,-0.033927206),vec4(0.34455317,0.034150947,0.18971144,0.08967791),vec4(0.061049465,0.07256376,-0.17379461,0.11531577),vec4(0.35449848,0.29584038,-0.40550002,-0.20526125)) * bufB[4] + mat4(vec4(-0.7718277,-0.059679653,-0.16035838,0.1819681),vec4(0.091633946,-0.26473576,-0.30094966,-0.71984565),vec4(-0.008716242,0.099627875,0.6203014,-0.17657487),vec4(-0.1914161,-0.31884983,-0.11791066,-0.16039367)) * bufB[5] + mat4(vec4(0.031296473,-0.32156026,-0.3596415,-0.12808244),vec4(0.0055030556,0.14105153,-0.719726,0.13741414),vec4(0.18631513,0.07469018,0.08594803,-0.04813485),vec4(0.0479407,-0.4891373,0.059011903,0.11993976)) * bufB[6] + mat4(vec4(0.32269284,0.0946369,0.0015307297,-0.0060203495),vec4(0.052004106,-0.2291218,-0.14701124,-0.16455664),vec4(-0.19164717,-0.16394658,-0.13036273,0.31918696),vec4(0.309784,0.09876751,-0.018726919,0.0068984297)) * bufB[7];\nbufA[1] = vec4(-0.46140376,-0.6111263,0.05347925,-0.6683437) + mat4(vec4(-0.15538642,-0.01564163,-0.05364401,-0.0027840415),vec4(0.36371878,-0.21787214,-0.38863635,0.6445093),vec4(0.01425232,0.05047613,-0.16333818,-0.338408),vec4(-0.07833172,-0.13869183,-0.1834103,-0.18701945)) * bufB[0] + mat4(vec4(-0.16618991,0.01676436,-0.40778393,-0.011127398),vec4(-0.4459052,-0.6252961,0.44656566,-0.43369403),vec4(0.39033422,0.39439842,0.046305943,0.17521639),vec4(-0.2559992,0.4725827,-0.18601687,-0.14732291)) * bufB[1] + mat4(vec4(-0.26945594,0.2364369,-0.030211916,-0.061255645),vec4(0.1388209,0.029585032,-0.13970123,-0.3494327),vec4(0.21720988,-0.05215706,0.2941419,-0.038401283),vec4(-0.22420079,0.48547864,-0.08507326,-0.047076616)) * bufB[2] + mat4(vec4(-0.40159723,-0.048726693,0.5483388,0.2022441),vec4(0.05591697,0.5317904,0.08929801,0.36713117),vec4(-0.033560462,0.000246542,0.15632336,0.50284725),vec4(-0.21576434,0.48821774,0.14305955,-0.19893171)) * bufB[3] + mat4(vec4(0.0073016887,0.44467276,-0.031826127,0.041470062),vec4(-0.28552485,-0.0043951026,-0.33116928,-0.082549706),vec4(0.6617786,-0.18909831,-0.38903317,-0.24738267),vec4(-0.053867284,-0.4767186,-0.15999131,-0.20324382)) * bufB[4] + mat4(vec4(0.43607014,0.19510452,-0.15364572,0.47454724),vec4(-0.76081854,0.19045332,0.07087065,0.020134442),vec4(-0.20048718,-0.07040832,0.08805042,0.49966013),vec4(0.41742578,0.124077015,0.05894877,-0.065682195)) * bufB[5] + mat4(vec4(0.33573696,-0.18813455,-0.18180627,-0.47802752),vec4(-0.5457999,-0.02189038,-0.19308864,-0.33529583),vec4(0.53366673,-0.08238294,0.05495704,0.23411275),vec4(-0.18042338,-0.15406233,-0.16330272,0.16449782)) * bufB[6] + mat4(vec4(0.027371999,-0.42307878,-0.30368924,-0.114970416),vec4(-0.0058569703,-0.18338141,0.0640011,-0.0022925849),vec4(-0.081938565,0.56424147,-0.11636444,0.16683681),vec4(-0.25107256,0.11263714,0.21892513,0.13501258)) * bufB[7];\nbufA[2] = vec4(0.3143313,-0.054062244,0.1456196,0.0441189) + mat4(vec4(-0.20157489,0.08509602,0.06899201,-0.2378188),vec4(0.045518376,-0.20645024,0.15915601,-0.26310396),vec4(-0.48546016,-0.271021,0.28777155,0.3416604),vec4(0.066432394,-0.4853446,0.13917793,0.087511525)) * bufB[0] + mat4(vec4(0.0918215,-0.2782772,0.24214399,0.056944408),vec4(-0.33386257,-0.5180132,-0.2704823,0.29389435),vec4(0.081648014,-0.32733354,-0.01983155,-0.22960176),vec4(-0.04409905,-0.071689956,-0.295411,-0.026332865)) * bufB[1] + mat4(vec4(0.10533912,0.025612133,0.32788104,0.49952337),vec4(-0.2063928,0.24266693,0.6554176,0.24488182),vec4(0.16066068,-0.02226643,-0.18499677,-0.045020513),vec4(-0.2795122,-0.6580561,-0.045823295,0.23835543)) * bufB[2] + mat4(vec4(0.3160315,-0.72529763,0.016064588,-0.41474888),vec4(-0.120838545,0.07788702,-0.1613198,-0.06282884),vec4(-0.20397271,0.41274714,0.21437903,0.05005222),vec4(0.20801665,0.027022272,-0.5022032,0.15975928)) * bufB[3] + mat4(vec4(-0.20626152,0.5192127,-0.030798677,0.24293542),vec4(0.48519698,0.0878233,-0.11777495,-0.15578444),vec4(-0.1892471,0.22725932,0.42667907,-0.22246818),vec4(-0.1816712,0.04264374,0.053351995,-0.00866591)) * bufB[4] + mat4(vec4(0.061711334,0.015159936,0.29256272,-0.54648876),vec4(-0.02480918,0.18769242,0.3608373,-0.2850481),vec4(0.6399621,0.19594069,-0.49667925,0.12936836),vec4(-0.121314466,0.06948719,0.17712449,-0.44126248)) * bufB[5] + mat4(vec4(-0.16984798,-0.5474872,0.28873858,-0.11710331),vec4(0.5112683,0.75687367,0.005893462,-0.019789683),vec4(0.043752123,0.3749253,0.13471793,0.019574802),vec4(-0.0039118887,-0.6553978,0.035426237,0.5214775)) * bufB[6] + mat4(vec4(0.011968907,0.4022459,0.08590977,-0.25353515),vec4(-0.06402639,0.15356378,0.37909988,0.118154876),vec4(-0.31075785,0.21683596,0.04374316,0.15698314),vec4(-0.58836627,-0.51331437,-0.6720286,0.12663642)) * bufB[7];\nbufA[3] = vec4(0.18507631,0.04880424,-0.38996568,-0.23245507) + mat4(vec4(-0.10212325,0.28278634,-0.12079879,-0.04422669),vec4(0.5080636,0.14441529,0.4556538,0.14662805),vec4(0.043150347,-0.13754344,-0.13821986,0.025630733),vec4(-0.1258548,0.44598204,0.14203559,-0.02193556)) * bufB[0] + mat4(vec4(-0.6184462,0.24664696,-0.1493141,0.13380155),vec4(0.30972868,0.20928705,-0.07258461,0.37375534),vec4(0.36173669,0.20938227,-0.034512084,0.012595901),vec4(-0.00043054938,0.26528108,-0.49944684,-0.23523705)) * bufB[1] + mat4(vec4(0.59759754,-0.08054483,-0.14544073,-0.17619136),vec4(-0.52622163,0.102911964,-0.024365144,0.052167065),vec4(0.26554477,-0.12081824,-0.49905986,-0.32441816),vec4(-0.1147949,-0.011516156,0.0056853523,0.40132114)) * bufB[2] + mat4(vec4(0.20699584,0.016919727,0.10287985,0.44089067),vec4(-0.20152855,0.043831617,0.0002564221,-0.025928859),vec4(-0.4602745,0.14316362,0.11088733,0.09196835),vec4(0.31272864,0.29643402,-0.33276084,-0.30157334)) * bufB[3] + mat4(vec4(0.17085211,-0.5070318,0.015925582,-0.11725401),vec4(0.03351216,0.088891216,0.10514516,0.07212035),vec4(0.07545845,-0.5434224,0.25495997,0.27722648),vec4(-0.0959527,-0.4036101,0.19961186,-0.05733796)) * bufB[4] + mat4(vec4(-0.037116032,-0.037525833,0.048015997,-0.28110507),vec4(-0.4055889,0.14853777,-0.1049312,0.4869972),vec4(0.09881083,0.3528127,0.27829167,-0.1402767),vec4(-0.53717583,-0.075375,0.03591069,-0.053314287)) * bufB[5] + mat4(vec4(-0.08522312,0.16672279,-0.08307059,0.1093727),vec4(-0.2303964,0.16524975,-0.03302108,0.00588302),vec4(0.5892468,-0.61502546,0.19112429,-0.3474428),vec4(-0.5167694,-0.3156922,0.54053295,0.5912021)) * bufB[6] + mat4(vec4(-0.033610567,-0.22196342,0.36314046,-0.17578198),vec4(-0.3666776,0.35429922,0.0090507865,0.012554062),vec4(-0.0009014595,0.44897628,-0.45125318,-0.5526969),vec4(0.17657125,0.5912847,-0.4953417,0.08046779)) * bufB[7];\ntmp = sin(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(-0.3350553810596466,0.7974206805229187,0.757785439491272,0.0) + mat4(vec4(0.45152151584625244,0.23352639377117157,0.005535314325243235,0.0),vec4(-0.054222360253334045,-0.19313748180866241,-0.1304718405008316,0.0),vec4(-0.18205223977565765,0.06450795382261276,0.1117505356669426,0.0),vec4(-0.3861912190914154,-0.07495030015707016,-0.08346804976463318,0.0)) * bufB[0] + mat4(vec4(0.26481273770332336,-0.13496685028076172,-0.20285192131996155,0.0),vec4(-0.41903024911880493,-0.07635799795389175,0.1288049817085266,0.0),vec4(-0.13258476555347443,-0.09309063851833344,-0.14250551164150238,0.0),vec4(0.3523872494697571,0.2376096546649933,-0.14364568889141083,0.0)) * bufB[1] + mat4(vec4(-0.25289759039878845,0.22976484894752502,0.19683343172073364,0.0),vec4(0.13034667074680328,-0.06851724535226822,-0.0936722680926323,0.0),vec4(0.3772241175174713,-0.1606963872909546,-0.1812610775232315,0.0),vec4(-0.0204013679176569,-0.09300859272480011,-0.21886594593524933,0.0)) * bufB[2] + mat4(vec4(-0.38685253262519836,0.14163830876350403,0.16106514632701874,0.0),vec4(-0.3312928378582001,0.16555534303188324,0.1539432853460312,0.0),vec4(-0.25008031725883484,-0.18729954957962036,0.17849953472614288,0.0),vec4(0.7585878372192383,0.07443078607320786,-0.2021932750940323,0.0)) * bufB[3] + mat4(vec4(0.06200237199664116,0.5700640678405762,0.2996661961078644,0.0),vec4(0.33624622225761414,-0.5082175135612488,-0.42783576250076294,0.0),vec4(0.37491488456726074,-0.1898941844701767,-0.2258996218442917,0.0),vec4(0.509745180606842,0.166483074426651,0.21481853723526,0.0)) * bufB[4] + mat4(vec4(-0.6383064389228821,0.22136609256267548,0.3728906810283661,0.0),vec4(0.5622020959854126,-0.020807532593607903,-0.2131616175174713,0.0),vec4(0.10178627073764801,0.21493622660636902,0.41214048862457275,0.0),vec4(-0.037107981741428375,-0.3232134282588959,-0.16663308441638947,0.0)) * bufB[5] + mat4(vec4(0.7050971984863281,0.1747182458639145,-0.17695322632789612,0.0),vec4(-0.5713052153587341,-0.2109212875366211,-0.006578493397682905,0.0),vec4(0.2126910239458084,-0.2681540250778198,-0.21623504161834717,0.0),vec4(0.8226300477981567,-0.1752673089504242,-0.06447060406208038,0.0)) * bufB[6] + mat4(vec4(-0.21912288665771484,-0.12303164601325989,-0.047226183116436005,0.0),vec4(0.46012645959854126,-0.19637881219387054,-0.24011503159999847,0.0),vec4(-0.2128649652004242,-0.19027309119701385,0.08315350115299225,0.0),vec4(-0.2926671504974365,-0.1932104527950287,-0.07096398621797562,0.0)) * bufB[7];\nreturn vec4((1. / (1. + exp(-bufA[0]))).xyz, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouseNorm = (iMouse.xy / iResolution.xy) - vec2(0.5, 0.5);\n\n\n        uv.x *= iResolution.x / iResolution.y;\n        uv.x -= ((iResolution.x / iResolution.y) - 1.) /2.;\n\n\n    // Shifted to the form expected by the CPPN\n    uv = vec2(1., -1.) * 3. * (uv - vec2(0.5, 0.5));\n    // Output to screen\n    float t = iTime * .01;\n    uv += vec2(t*-10.0, 0);\n    float a = 10.0;\n    fragColor = cppn_fn(uv, a * sin(t), a * sin(2.*t), a * sin(3.*t), a* sin(4.*t));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsjXDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 147, 147, 58818], [58820, 58820, 58877, 58927, 59433]], "test": "valid"}
{"id": "fsjXRK", "name": "Spirale logarithmique tournante", "author": "19elamraou", "description": "Spirale logarithmique telle que r = a*b^theta \nAnti-aliasing :\n- smoothstep sur les deux bords \n- Moyennage sur tous les pixels", "tags": ["spiralelogarithmique"], "likes": 7, "viewed": 56, "published": "Public", "date": "1620579860", "time_retrieved": "2021-10-01T00:00:00", "image_code": "# define PI 3.14159265359\n\nfloat theta(vec2 map){ //angle entre 0 et 2PI\n    float angle = mod(atan(map.y, map.x), 2.*PI);\n    return angle;\n} \n\nvec2 spiral_lower_upper(float a, float b, float angle, float r){ //On calcule la spirale initiale entre 0 et 2PI puis on fait des homotéthies de b^2PI à chaque tour, on renvoie les deux bouts de spirale entre lesquels se trouve r pour le plot final\n    float r0=a*pow(b,2.*PI); \n    float N = floor(1.+log(r/r0)/(2.*PI*log(b))); //nb tours\n    //N = 0;\n    return vec2(r0*pow(b,angle+2.*PI*(N-1.)),r0*pow(b,angle+2.*PI*(N)));\n}\n\nvec3 spiral(vec2 fragCoord){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y; //reshape with aspect ratio\n    uv *=5.;\n    \n    // Defining the spiral parameters, r = a*b^angle\n    float a=.4;\n    float b=1.2;\n    float r = length(uv);\n    float angle = mod(theta(uv)+3.*iTime, 2.*PI); //modulo 2PI\n    \n    vec2 spiral = spiral_lower_upper(a, b, angle, r);\n    \n    //Plot parameters\n    float width = .1*r;\n    vec3 lineColor = vec3(1); //0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)); //color of the spiral\n    vec3 col = (fract(smoothstep(spiral[0]-width, spiral[0], r))+smoothstep(spiral[1]-width,spiral[1],r))*lineColor;\n    col *= 4.*(1. - (fract(smoothstep(spiral[0]-width, spiral[0], r))+smoothstep(spiral[1]-width,spiral[1],r)));\n    //vec3 col = (smoothstep(spiral[0]-width, spiral[0], r))*lineColor; //Il manque un bout de la spirale à chaque tour à cause du smoothstep qui recouvre tout jusqu'au bout de spirale suivant, d'où la nécessité de garder en mémoire les deux bouts de spirale pour récupérer le bout manquant au début de chaque tour\n    return col;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#if 0 //test avec ou sans anti-aliasing\n    vec3 col = spiral(fragCoord);\n#else\n    float m = .25;\n    vec3 col = vec3(0);\n    col += spiral(fragCoord + vec2(m, m));\n    col += spiral(fragCoord + vec2(-m, m));\n    col += spiral(fragCoord + vec2(m, -m));\n    col += spiral(fragCoord + vec2(-m, -m));\n    col /= 4.;\n#endif\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsjXRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 49, 72, 142], [145, 145, 209, 395, 574], [576, 576, 604, 654, 1748], [1751, 1751, 1808, 1808, 2187]], "test": "valid"}
{"id": "fsjXWz", "name": "libyan flag pre-2011", "author": "rockstep", "description": "it's so beautiful", "tags": ["3d", "raymarching"], "likes": 0, "viewed": 51, "published": "Public", "date": "1620126137", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_RAY_MARCH_STEPS 100\n#define MAX_DIST 100.\n#define EPSILON 0.01\n#define LIGHT_FACTOR 10.\n#define PI 3.14159\n\nstruct Camera {\n    vec3 pos;\n    vec3 lookat;\n    float zoom;\n};\n\nstruct Light {\n    vec3 pos;\n};\n\nfloat dBox(vec3 p, vec3 s) {\n    return length(max(abs(p)-s, 0.));\n}\n\nfloat dCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = clamp(dot(ap, ab) / dot(ab, ab), 0., 1.);\n    vec3 c = a + t * ab;\n    return length(p - c) - r;\n}\n\nfloat dSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat distToPlane(vec3 p) {\n    return p.y; // axis-aligned\n}\n\nfloat distToPoleTop(vec3 p) {\n    return dSphere(p - vec3(0., 3., 0.), .1);\n}\n\nfloat distToFlag(vec2 uv, vec3 p) {\n    float wave = sin(uv.x * 10. + iTime) * smoothstep(0., .3, uv.x);\n    return dBox(p - vec3(.5, 2.5, wave), vec3(.6, .4, .01));\n}\n\nfloat distToPole(vec3 p) {\n    return dCapsule(p, vec3(0., -1., 0.), vec3(0., 3., 0.), .05);\n}\n\nfloat distToScene(vec2 uv, vec3 p) {\n    float dist = min(distToPlane(p), distToPoleTop(p));\n    dist = min(dist, distToFlag(uv, p));\n    dist = min(dist, distToPole(p));\n    return dist;\n}\n\nbool approx(float a, float b) {\n    return abs(a - b) < EPSILON;\n}\n\nvec3 color(vec2 uv, vec3 p) {\n    float d = distToScene(uv, p);\n    if (approx(distToPlane(p), d)) {\n        return vec3(0,1,0);\n    }\n    if (approx(distToPoleTop(p), d)) {\n        return vec3(1,1,0);\n    }\n    if (approx(distToFlag(uv, p), d)) {\n        return vec3(0,1,0);\n    }\n    if (approx(distToPole(p), d)) {\n        return vec3(1,1,1);\n    }\n    return vec3(0,0,1);\n}\n\nfloat distToSceneAlong(vec2 uv, vec3 ro, vec3 rd) {\n    float distSoFar = 0.;\n    for (int i = 0; i < MAX_RAY_MARCH_STEPS; i++) {\n        vec3 pointAlongRay = ro + distSoFar*rd;\n        float increment = distToScene(uv, pointAlongRay);\n        distSoFar += increment;\n        if (increment <= EPSILON || distSoFar > MAX_DIST) {\n            break;\n        }\n    }\n    return distSoFar;\n}\n\nvec3 normal(vec2 uv, vec3 p) {\n    vec2 delta = vec2(EPSILON, 0);\n    float dist = distToScene(uv, p);\n    return normalize(vec3(\n        dist - distToScene(uv, p - delta.xyy),\n        dist - distToScene(uv, p - delta.yxy),\n        dist - distToScene(uv, p - delta.yyx)\n    ));\n}\n\nfloat lighting(vec2 uv, Light lamp, vec3 p) {\n    vec3 lightVector = normalize(lamp.pos - p);\n    vec3 n = normal(uv, p);\n\n    float dif = clamp(dot(lightVector, n), 0., 1.) ;\n    float d = distToSceneAlong(uv, p + n * LIGHT_FACTOR * EPSILON , lightVector);\n    if (d < length(lamp.pos - p)) {\n        dif *= 0.1; // in shadow\n    }\n    return dif;\n}\n\nvec3 rayDirection(Camera cam, vec2 uv) {\n    vec3 f = normalize(cam.lookat - cam.pos);\n    vec3 r = normalize(cross(vec3(0., 1., 0.), f));\n    vec3 u = cross(f, r);\n    vec3 screenCenter = cam.pos + f * cam.zoom;\n    vec3 i = screenCenter + uv.x * r + uv.y * u;\n    return i - cam.pos;\n}\n\nmat2 rot(float t) {\n    float s = sin(t);\n    float c = cos(t);\n    return mat2(c, -s, s, c);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n\n    float t = iTime;\n    t = 0.;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    Camera cam;\n    cam.pos = vec3(6.*sin(t), .5, -6.*cos(t));\n    cam.lookat = vec3(0, 1, 0);\n    cam.zoom = 1.;\n    Light lamp;\n    lamp.pos = vec3(-2, 6, -2);\n    \n    //cam.pos.yz *= rot(-m.y*PI + 1.);\n    //cam.pos.xz *= rot(-m.x*2.*PI);\n\n    vec3 rd = rayDirection(cam, uv);\n    float dist = distToSceneAlong(uv, cam.pos, rd);\n    vec3 p = cam.pos + dist * rd;\n    float dif = lighting(uv, lamp, p);\n    \n    //vec3 col = mix(vec3(0,0,1), vec3(dif) * color(uv, p), dif*10.);\n    vec3 col = vec3(dif) * color(uv, p);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsjXWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[220, 220, 248, 248, 288], [290, 290, 339, 339, 494], [496, 496, 528, 528, 556], [558, 558, 585, 585, 619], [621, 621, 650, 650, 698], [700, 700, 735, 735, 867], [869, 869, 895, 895, 963], [965, 965, 1001, 1001, 1154], [1156, 1156, 1187, 1187, 1222], [1224, 1224, 1253, 1253, 1601], [1603, 1603, 1654, 1654, 1989], [1991, 1991, 2021, 2021, 2270], [2272, 2272, 2317, 2317, 2622], [2624, 2624, 2664, 2664, 2911], [2913, 2913, 2932, 2932, 3008], [3010, 3010, 3065, 3065, 3760]], "test": "valid"}
{"id": "fslSRs", "name": "Tennis Ball Sections", "author": "oneshade", "description": "Tennis ball sections.", "tags": ["sphere", "intersection", "sections", "tennisball"], "likes": 10, "viewed": 56, "published": "Public", "date": "1621561863", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Settings\n#define AA 3.0 // Subsamples for antialiasing\n#define hc 0.5 // Curve slope\n#define rb 2.0 // Ball radius\n\n// Intersection info\nstruct Intersect {\n    float dist;\n    vec3 pos;\n    vec3 nor;\n};\n\n// Hyperbolic-parabola intersection\nvec3 iHyperParab(in vec3 ro, in vec3 rd, in float h) {\n    float a = rd.y * rd.y - rd.z * rd.z;\n    float b = h * rd.x + ro.y * rd.y - ro.z * rd.z;\n    float c = 2.0 * h * ro.x + ro.y * ro.y - ro.z * ro.z;\n    float discr = b * b - a * c;\n    if (discr < 0.0) return vec3(-1.0, -1.0, 0.0);\n    return vec3((vec2(-1.0, 1.0) * sqrt(discr) - b) / a, 2.0);\n}\n\n// Hyperbolic-parabola normal\nvec3 nHyperParab(in vec3 p, in float h) {\n    return normalize(vec3(h, p.y, -p.z));\n}\n\n// Hyperbolic-parabola implicit equation\nfloat hyperParabImplicit(in vec3 p, in float h) {\n    return 2.0 * h * p.x + p.y * p.y - p.z * p.z;\n}\n\n// Sphere intersection (rd must be normalized)\nvec3 iSphere(in vec3 ro, in vec3 rd, in float r) {\n    float b = dot(ro, rd), c = dot(ro, ro) - r * r;\n    float discr = b * b - c;\n    if (discr < 0.0) return vec3(-1.0, -1.0, 0.0);\n    return vec3(vec2(-1.0, 1.0) * sqrt(discr) - b, 2.0);\n}\n\n// Sphere normal\nvec3 nSphere(in vec3 p, in float r) {\n    return p / r;\n}\n\n// Sphere implicit equation\nfloat sphereImplicit(in vec3 p, in float r) {\n    return dot(p, p) - r * r;\n}\n\n// Map of half of the shape\nIntersect mapHalf(in vec3 ro, in vec3 rd) {\n    float t = -1.0;\n    vec3 tSphere = iSphere(ro, rd, rb), hitPos, n;\n    for (int i=0; i < int(tSphere[2]); i++) {\n        vec3 hitCandid = ro + rd * tSphere[i];\n        if (tSphere[i] > 0.0 && hyperParabImplicit(hitCandid, hc) > 0.0 && (t < 0.0 ? true : (tSphere[i] < t))) {\n            t = tSphere[i];\n            hitPos = hitCandid;\n            n = nSphere(hitPos, rb);\n        }\n    }\n\n    vec3 tCurve = iHyperParab(ro, rd, hc);\n    for (int i=0; i < int(tCurve[2]); i++) {\n        vec3 hitCandid = ro + rd * tCurve[i];\n        if (tCurve[i] > 0.0 && sphereImplicit(hitCandid, rb) < 0.0 && (t < 0.0 ? true : (tCurve[i] < t))) {\n            t = tCurve[i];\n            hitPos = hitCandid;\n            n = nHyperParab(hitPos, hc);\n        }\n    }\n\n    return Intersect(t, hitPos, n);\n}\n\n// Combined\nIntersect mapScene(in vec3 ro, in vec3 rd) {\n    float offs = 0.5 + 0.5 * sin(iTime);\n\n    Intersect h1 = mapHalf(vec3(ro.x - offs, ro.y, ro.z), rd);\n    Intersect h2 = mapHalf(vec3(-ro.x - offs, ro.z, ro.y), vec3(-rd.x, rd.z, rd.y));\n    h2.nor.yz = -h2.nor.zy;\n\n    Intersect whole = h1;\n    if (whole.dist < 0.0 && h2.dist > 0.0 ? true : (h2.dist < 0.0 ? false : (h2.dist < whole.dist))) whole = h2;\n    return whole;\n}\n\n// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW):\nfloat noise(in vec3 p3) {\n\tp3  = fract(p3 * 0.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Tricubic noise interpolation\nfloat snoise(in vec3 p) {\n    vec3 cell = floor(p), local = fract(p);\n    local *= local * (3.0 - 2.0 * local);\n\n    float ldb = noise(cell);                       // Left, Down, Back\n    float rdb = noise(cell + vec3(1.0, 0.0, 0.0)); // Right, Down, Back\n    float ldf = noise(cell + vec3(0.0, 0.0, 1.0)); // Left, Down, Front\n    float rdf = noise(cell + vec3(1.0, 0.0, 1.0)); // Right, Down, Front\n    float lub = noise(cell + vec3(0.0, 1.0, 0.0)); // Left, Up, Back\n    float rub = noise(cell + vec3(1.0, 1.0, 0.0)); // Right, Up, Back\n    float luf = noise(cell + vec3(0.0, 1.0, 1.0)); // Left, Up, Front\n    float ruf = noise(cell + 1.0);                 // Right, Up, Front\n\n    return mix(mix(mix(ldb, rdb, local.x), mix(ldf, rdf, local.x), local.z),\n               mix(mix(lub, rub, local.x), mix(luf, ruf, local.x), local.z),\n               local.y);\n}\n\n// FBM\nfloat fnoise(in vec3 p, in float scale, in int octaves) {\n    p *= scale;\n\n    float value = 0.0;\n    float nscale = 1.0;\n    float tscale = 0.0;\n\n    for (int octave=0; octave < octaves; octave++) {\n        value += snoise(p) * nscale;\n        tscale += nscale;\n        nscale *= 0.5;\n        p *= 2.0;\n    }\n\n    return value / tscale;\n}\n\nvec4 render(in vec2 pixel) {\n    vec2 mouse = ivec2(iMouse) == ivec2(0) ? vec2(0.0) : (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y * 3.14;\n    vec2 uv = (pixel - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 color = vec3(0.0, 0.25, 0.0);\n\n    vec3 ro = vec3(0.0, 0.0, 6.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    // Render the shape if hitting\n    Intersect scene = mapScene(ro, rd);\n    if (scene.dist > 0.0) {\n        float diff = abs(dot(scene.nor, -rd));\n        color = vec3(0.5, 1.0, 0.0) * (0.75 + 0.5 * fnoise(scene.pos, 5.0, 5));\n        color += 10.0 * max(0.0, 1.0 - max(max(hyperParabImplicit(scene.pos, hc), sphereImplicit(scene.pos, rb)) + 0.75, -sphereImplicit(scene.pos, rb + 0.15)));\n        color *= diff;\n    }\n\n    color = pow(color, vec3(0.75));\n    return vec4(color, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0);\n    float aaStep = 1.0 / AA;\n    for (float xOffs=0.0; xOffs < 1.0; xOffs += aaStep) {\n        for (float yOffs=0.0; yOffs < 1.0; yOffs += aaStep) {\n            fragColor += render(fragCoord + vec2(xOffs, yOffs));\n        }\n    }\n\n    fragColor /= AA * AA;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fslSRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[207, 243, 297, 297, 597], [599, 629, 670, 670, 714], [716, 757, 806, 806, 858], [860, 907, 957, 957, 1148], [1150, 1167, 1204, 1204, 1224], [1226, 1254, 1299, 1299, 1331], [1333, 1361, 1404, 1404, 2193], [2195, 2207, 2251, 2251, 2629], [2631, 2721, 2746, 2746, 2850], [2852, 2884, 2909, 2909, 3746], [3748, 3755, 3812, 3812, 4094], [4096, 4096, 4124, 4124, 5175], [5177, 5177, 5232, 5232, 5518]], "test": "valid"}
{"id": "fsSSD1", "name": "pavo", "author": "4eckme", "description": "tail", "tags": ["2d", "rgb"], "likes": 2, "viewed": 69, "published": "Public", "date": "1620084163", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = (fragCoord)*4.0;\n    coord.x-=iResolution.x*2.0;\n   \tfloat t = iTime;\n    float x = float(coord.x)+64.0*sin((coord.x+coord.y)/60.0);\n    float y = float(coord.y)+64.0*cos((coord.x-coord.y)/60.0);\n    float r = float(x*x*t + y*y*t);\n    float f = abs(r);\n    int a = int(floor(f*pow(16.0, 6.0-ceil(log2(r)/4.0))));\n    int A = a;\n    fragColor = vec4(\n        cos(sqrt(r)/x),\n        cos(sqrt(r)/sqrt(t)),\n        cos(sqrt(r)/y),\n        sin(y/x)\n    );\n    fragColor.x+=(tan((degrees(atan(x, y))*1.0-t*2.0)))/4.0;\n    fragColor.y+=(tan((degrees(atan(x, y))*1.0-t*2.0)))/4.0;\n    fragColor.z+=(tan((degrees(atan(x, y))*1.0-t*2.0)))/4.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsSSD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 712]], "test": "valid"}
{"id": "fsSSWt", "name": "Outlandish Fractal", "author": "oneshade", "description": "Interesting.", "tags": ["fractal"], "likes": 7, "viewed": 87, "published": "Public", "date": "1621214047", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 f(in vec2 z, in vec2 w) { return z * mat2(w.x, -w.y, w.yx); }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 x = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 2.0;\n    float time = iTime * 0.25;\n    fragColor = vec4(0.0);\n\n    float w1 = sin(time * 0.25);\n    float w2 = sin(time) * 3.0;\n    float w3 = sin(time) * 2.0;\n    float w4 = cos(time * 0.75);\n    float w5 = sin(time * 0.5);\n    float w6 = 0.125 * sin(iTime);\n\n    for (int n=0; n < 50; n++) {\n        vec2 p = w1 * f(x, f(x, f(x, f(x, x)))) + w2 * f(x, f(x, f(x, x))) + w3 * f(x, f(x, x)) + w4 * f(x, x) + w5 * x + vec2(w6, 0.0);\n        vec2 q = 5.0 * w1 * f(x, f(x, f(x, x))) + 4.0 * w2 * f(x, f(x, x)) + 3.0 * w3 * f(x, x) + 2.0 * w4 * x + vec2(w5, 0.0);\n        x -= f(0.1 * p, 1.0 - q);\n        fragColor.rb += abs(x);\n    }\n\n    fragColor /= 25.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsSSWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 66], [68, 68, 123, 123, 847]], "test": "valid"}
{"id": "fsSSzw", "name": "GalaxyRipple", "author": "Del", "description": "ripple nebula FBM voronoi", "tags": ["voronoi", "fbm", "nebula", "ripple"], "likes": 4, "viewed": 223, "published": "Public API", "date": "1619823562", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// galaxy ripple nebula effect\n//#define PROCEDURAL_HASH\n\n#ifdef PROCEDURAL_HASH\nvec3 hash33(vec3 p)\n{\n    const float UIF = (1.0/ float(0xffffffffU));\n    const uvec3 UI3 = uvec3(1597334673U, 3812015801U, 2798796415U);\n    uvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn vec3(q) * UIF;\n}\n#else\nvec3 hash33( vec3 x )\n{\n\treturn texture( iChannel0, (x.xy+vec2(3.0,1.0)*x.z+0.5)/256.0, -100.0 ).xyz;\n}\n#endif\n\n\n// 3D Voronoi- (IQ)\nfloat voronoi(vec3 p){\n\n\tvec3 b, r, g = floor(p);\n\tp = fract(p);\n\tfloat d = 1.; \n\tfor(int j = -1; j <= 1; j++)\n    {\n\t    for(int i = -1; i <= 1; i++)\n        {\n\t\t    b = vec3(i, j, -1);\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t\t    b.z = 0.0;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t\t    b.z = 1.;\n\t\t    r = b - p + hash33(g+b);\n\t\t    d = min(d, dot(r,r));\n\t    }\n\t}\n\treturn d;\n}\n\n// fbm layer\nfloat noiseLayers(in vec3 p) {\n\n    vec3 pp = vec3(0., 0., p.z + iTime*.05);\n    float t = 0.;\n    float s = 0.;\n    float amp = 1.;\n    for (int i = 0; i < 5; i++)\n    {\n        t += voronoi(p + pp) * amp;\n        p *= 2.;\n        pp *= 1.5;\n        s += amp;\n        amp *= .5;\n    }\n    return t/s;\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n#define TWO_PI 6.2831853\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n        float dd = length(uv*uv)*.025;\n    \n\tvec3 rd = vec3(uv.x, uv.y, 1.0);\n    \n    float rip = 0.5+sin(length(uv)*20.0+iTime)*0.5;\n    rip = pow(rip*.38,4.15);\n    rd.z=1.0+rip*1.15;// apply a subtle ripple\n    rd = normalize(rd);\n    rd.xy *= rot(dd-iTime*.025);\n    rd*=2.0;\n\t\n\tfloat c = noiseLayers(rd*1.85);\n    float oc = c;\n    c = max(c + dot(hash33(rd)*2. - 1., vec3(.006)), 0.);\n    c = pow(c*1.55,2.5);    \n    vec3 col =  vec3(.55,0.5,1.25);\n    vec3 col2 =  vec3(1.95,0.95,1.4)*5.0;\n    float pulse2 = voronoi(vec3((rd.xy*1.5),iTime*.255));\n    float pulse = pow(oc*1.35,4.0);\n    col = mix(col,col2,pulse*pulse2)*c;\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsSSzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[429, 449, 471, 471, 868], [870, 883, 913, 913, 1186], [1188, 1188, 1209, 1209, 1277], [1305, 1305, 1362, 1362, 2100]], "test": "error"}
{"id": "fsSXRm", "name": "VolumeRaymarching Basic", "author": "kithy", "description": "Basic Volume Raymarching", "tags": ["cloud", "volumetric"], "likes": 1, "viewed": 78, "published": "Public", "date": "1619843151", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 m(float a){\n\tfloat s=sin(a);\n\tfloat c=cos(a);\n\treturn mat2(c,s,-s,c);\n}\n\nfloat hash(float n){\n\treturn fract(sin(n)*43758.5453);\n}\n\nfloat noise(in vec3 x){\n\tvec3 p=floor(x);\n\tvec3 f=fract(x);\n\n\tf=f*f*(3.0-2.0*f);\n\n\tfloat n=p.x+p.y*57.0+113.0*p.z;\n\n\tfloat res=mix(mix(mix(hash(n+0.0),hash(n+1.0),f.x),\n\t\t\tmix(hash(n+57.0),hash(n+58.0),f.x),f.y),\n\t\t\tmix(mix(hash(n+113.0),hash(n+114.0),f.x),\n\t\t\tmix(hash(n+170.0),hash(n+171.0),f.x),f.y),f.z);\n\n\treturn res;\n}\n\nfloat fbm(vec3 p){\n\tfloat f;\n\tf=0.500000*noise(p);\n\tp.xy*=m(iTime)*2.02;\n\tf+=0.25000*noise(p);\n\tp.yz*=m(iTime)*2.03;\n\tf+=0.1250*noise(p);\n\treturn f;\n}\n\nfloat scene(vec3 p){\n\treturn 0.1-length(p)*0.05+fbm(p*0.3);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n\tvec2 uv=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\n\tvec3 ro=vec3(0.0,0.0,-30.0);\n\tvec3 ta=vec3(0.0);\n\tvec3 ww=normalize(ta-ro);\n\tvec3 uu=normalize(cross(vec3(0.0,1.0,0.0),ww));\n\tvec3 vv=normalize(cross(ww,uu));\n\tvec3 dir=normalize(uv.x*uu+uv.y*vv+1.5*ww);\n\tvec4 color=vec4(0.0);\n\n\tconst int nbSample=64;\n\tconst int nbSampleLight=6;\n\n\tfloat zMax=40.0;\n\tfloat step=zMax/float(nbSample);\n\tfloat zMaxl=20.0;\n\tfloat stepl=zMaxl/float(nbSampleLight);\n\tvec3 p=ro;\n\tfloat t=1.0;\n\tfloat absorption=100.0;\n\tvec3 sun_direction=normalize(vec3(0.0,1.0,0.0));\n\n\tfor(int i=0;i<nbSample;i++)\n\t{\n\t\tfloat density=scene(p);\n\t\tif(density>0.0)\n\t\t{\n\t\t\tfloat tmp=density/float(nbSample);\n\t\t\tt*=1.0-tmp*absorption;\n\t\t\tif(t<=0.01)\n\t\t\t\tbreak;\n\n\t\t\t\tfloat tl=1.0;\n\t\t\t\tfor(int j=0;j<nbSampleLight;j++){\n\t\t\t\t\tfloat densityLight=scene(p+normalize(sun_direction)*float(j)*stepl);\n\t\t\t\t\tif(densityLight>0.0)\n\t\t\t\t\t\ttl*=1.0-densityLight*absorption/float(nbSample);\n\t\t\t\t\tif(tl<=0.01)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcolor+=vec4(0.1)*tmp+vec4(0.7,0.0,1.0,1.0)*80.0*tmp*t;\n\t\t\t}\n\t\t\tp+=dir*step;\n\t\t}\n\t\tfragColor=color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsSXRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 16, 16, 76], [78, 78, 98, 98, 134], [136, 136, 159, 159, 460], [462, 462, 480, 480, 612], [614, 614, 634, 634, 675], [677, 677, 730, 730, 1810]], "test": "valid"}
{"id": "fsSXz1", "name": "Joran's Maze", "author": "j0ran", "description": "Maze", "tags": ["maze"], "likes": 7, "viewed": 146, "published": "Public API", "date": "1620122384", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash21(vec2 v) \n{\n    return fract(sin(dot(v, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nmat2 Rot(float a)\n{\n    return mat2(sin(a), cos(a), -sin(a), cos(a));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5)/iResolution.y;  \n    uv = uv * Rot(radians(-45.0));\n    \n    uv *= (sin(iTime*1.0) + 1.0) * 20. + 5.;\n    uv.x += iTime * 7.;\n\n    vec2 gv = fract(uv) - 0.5;\n    vec2 id = floor(uv);\n                \n    float d = 0.;\n    float dir = hash21(id) < 0.5 ? -1. : 1.;\n\n    d += smoothstep(0.25, 0.15, abs(gv.x  + gv.y * dir));\n    \n    vec3 col = vec3(d);    \n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsSXz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 95], [97, 97, 116, 116, 168], [170, 170, 227, 227, 665]], "test": "valid"}
{"id": "fsSXzm", "name": "feature Z", "author": "yasuo", "description": "feature Z", "tags": ["puma"], "likes": 8, "viewed": 181, "published": "Public API", "date": "1619857256", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// All the distance functions from:http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .005\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat threeDF(vec3 p) {\n    vec3 prevP = p;\n    \n    float d = sdBox(p,vec3(1.0,1.0,0.3));\n    p*=matRotateZ(radians(-45.0));\n    d = max(-p.x,d);\n    p = prevP;\n    float mask = sdBox(p-vec3(-0.7,0.35,0.0),vec3(1.0,0.15,0.5));\n    d = max(-mask,d);\n    return d;\n}\n\nvec4 GetDist(vec3 p) {\n    vec3 prevP = p;\n    \n    float animate = sin(iTime*2.0)*0.1;\n    float d = threeDF((p-vec3(0.1+animate,0.3+animate*0.5,0.0)));\n    p*=-1.0;\n    float d2 = threeDF((p-vec3(0.1+animate,0.3+animate*0.5,0.0)));\n    d = min(d,d2);\n    vec4 res = vec4(vec3(1.0),d);\n\n    vec4 model = res;\n    return model;\n}\n\nvec4 RayMarch(vec3 ro, vec3 rd) {\n    vec4 dO= vec4(0.0);\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO.w;\n        vec4 dS = GetDist(p);\n        dO.w += dS.w;\n        dO.xyz = dS.xyz;\n        if(dO.w>MAX_DIST || dS.w<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).w;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).w,\n        GetDist(p-e.yxy).w,\n        GetDist(p-e.yyx).w);\n    \n    return normalize(n);\n}\n\nvec2 GetLight(vec3 p) {\n    vec3 lightPos = vec3(2,5,-3);\n    \n    lightPos.yz *= Rot(radians(-30.0));\n    lightPos.xz *= Rot(iTime*1.5+1.0);\n    \n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l).w;\n    \n    float lambert = max(.0, dot( n, l))*0.6;\n    \n    return vec2((lambert+dif),max(0.9, 1.0)) ;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nfloat noise(float x) {\n    return fract(sin(dot(vec2(x), vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(234.56,789.34));\n    p+=dot(p,p+34.56);\n    return fract(p.x+p.y);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdPie( in vec2 p, in vec2 c, in float r )\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n    float m = length(p-c*clamp(dot(p,c),0.0,r)); // c=sin/cos of aperture\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\nfloat animationMask(vec2 p, float speed){\n    float t = mod(iTime*speed,360.0);\n    float rad = radians(t);\n    float d = sdPie(p,vec2(sin(rad),cos(rad)),0.15);\n    return d;\n}\n\nfloat charF(vec2 p, int animate, float speed) {\n    vec2 prevP = p;\n    float size = 0.1;\n    float d = sdBox(p,vec2(size));\n    p*=Rot(radians(45.0));\n    d = max(p.x,d);\n    p = prevP;\n    float mask = sdBox(p-vec2(0.06,0.025),vec2(0.1,0.015));\n    d = max(-mask,d);\n    \n    if(animate == 1){\n        mask = animationMask(p,speed);\n        d = max(-mask,d);\n    }\n    return d;\n}\n\nfloat charU(vec2 p, int animate, float speed) {\n    vec2 prevP = p;\n    float w = 0.03;\n    float size = 0.1;\n    float d = abs(length(p)-(size-w))-w;\n    d = max(p.y,d);\n    float d2 = sdBox(p,vec2(size));\n    d2 = max(-p.y,d2);\n    float mask = sdBox(p,vec2(w*1.34,size+0.1));\n    d2 = max(-mask,d2);\n    d = min(d,d2);\n    p*=Rot(radians(45.0));\n    p.x+=0.075;\n    d = max(-p.x,d);\n    \n    p = prevP;\n    if(animate == 1){\n        mask = animationMask(p,speed);\n        d = max(-mask,d);\n    }\n    return d;\n}\n\nfloat charT(vec2 p, int animate, float speed) {\n    vec2 prevP = p;\n    float w = 0.03;\n    float size = 0.1;\n    float d = sdBox(p,vec2(size));\n    \n    float mask = sdBox(p-vec2(0.031,-0.031),vec2(0.071));\n    d = max(-mask,d);\n    \n    p*=Rot(radians(45.0));\n    p.x+=0.075;\n    d = max(-p.x,d);\n    \n    p = prevP;\n    p*=Rot(radians(45.0));\n    d = max(p.x,d);\n    \n    p = prevP;\n    if(animate == 1){\n        mask = animationMask(p,speed);\n        d = max(-mask,d);\n    }\n    return d;\n}\n\nfloat charR(vec2 p, int animate, float speed) {\n    vec2 prevP = p;\n    float w = 0.025;\n    float size = 0.11;\n    float d = abs(length(p-vec2(0.032,0.032))-((size-w)*0.5))-w;\n    d = max(-p.x+0.04,d);\n    float d2 = sdBox(p-vec2(-0.0302,0.032),vec2(0.07,0.067));\n    d = min(d,d2);\n    float mask = sdBox(p-vec2(-0.032,0.032),vec2(0.074,0.0155));\n    d = max(-mask,d);\n    d2 = sdBox((p-vec2(0.042,-0.07))*Rot(radians(-40.0)),vec2(0.025,0.08));\n    d = min(d,d2);\n    mask = sdBox(p,vec2(0.1));\n    d = max(mask,d);\n    p*=Rot(radians(45.0));\n    p.x+=0.082;\n    d = max(-p.x,d);\n    \n    p = prevP;\n    if(animate == 1){\n        mask = animationMask(p,speed);\n        d = max(-mask,d);\n    }\n    return d;\n}\n\nfloat charE(vec2 p, int animate, float speed) {\n    vec2 prevP = p;\n    float w = 0.025;\n    float size = 0.1;\n    float d = sdBox(p,vec2(size));\n    p.y = abs(p.y);\n    p.y-=0.032;\n    float mask = sdBox(p-vec2(0.03,0.0),vec2(0.072,0.012));\n    d = max(-mask,d);\n    p = prevP;\n    mask = sdBox(p-vec2(0.07,0.0),vec2(0.05,0.03));\n    d = max(-mask,d);\n    d = max(p.x-0.06,d);\n    p*=Rot(radians(45.0));\n    p.x+=0.082;\n    d = max(-p.x,d);\n    p = prevP;\n    p.x-=0.1;\n    p*=Rot(radians(45.0));\n    d = max(p.x,d);\n    \n    p = prevP;\n    if(animate == 1){\n        mask = animationMask(p,speed);\n        d = max(-mask,d);\n    }\n    return d;\n}\n\nfloat future(vec2 p, int animate){\n    float d = charF(p-vec2(-0.5,0.0),animate,90.0);\n    float d2 = charU(p-vec2(-0.36,0.0),animate,80.0);\n    d = min(d,d2);\n    d2 = charT(p-vec2(-0.14,0.0),animate,70.0);\n    d = min(d,d2);\n    d2 = charU(p-vec2(0.,0.0),animate,60.0);\n    d = min(d,d2);\n    d2 = charR(p-vec2(0.22,0.0),animate,50.0);\n    d = min(d,d2);\n    d2 = charE(p-vec2(0.44,0.0),animate,40.0);\n    d = min(d,d2);\n    return d;\n}\n\nfloat background(vec2 p, int animate){\n    p*=6.0;\n    \n    vec2 gv = fract(p)-0.5;\n    vec2 id = floor(p);\n    \n    float n = Hash21(id);\n    \n    float width = 0.15;\n    \n    if(n<.5)gv*=-1.0;\n    if(n>=.5 && n<0.7)gv*=Rot(radians(90.0));\n    if(n>=.7)gv*=Rot(radians(-90.0));\n    \n    gv*=0.2;\n    float d = charF(gv,animate,70.0);\n    if(n>.2 && n<.4) {\n        d = charU(gv,animate,50.0);\n    }\n    if(n>=.4 && n<.6) {\n        d = charR(gv,0,30.0);\n    }\n    if(n>=.8 && n<.9) {\n        d = charT(gv,animate,60.0);\n    }\n    if(n>=.9) {\n        d = charE(gv,0,30.0);\n    }\n    return d;\n}\n\nvec3 twoDRender(vec2 uv) {\n    vec2 prevUV = uv;\n    vec3 col = vec3(0.1,0.2,0.3);\n    uv.y-=iTime*.1;\n    float bg = background(uv,0);\n    col = mix(col,vec3(0.5),S(bg,0.0));\n    bg = background(uv,1);\n    col = mix(col,vec3(0.8),S(bg,0.0));\n    \n    uv = prevUV;\n    \n    float y = 0.2;\n    float d = future(uv-vec2(0.06,y-0.01),0);\n    \n    col = mix(col,vec3(0.2),S(d,0.0));\n    d = future(uv-vec2(0.055,y),0);\n    col = mix(col,vec3(1,1,0.1),S(d,0.0));\n    uv = prevUV;\n    d = future(uv-vec2(0.055,y),1);\n    col = mix(col,vec3(0.8,0.9,0.2),S(d,0.0));\n    return col;\n}\n\nvec3 Bg(vec3 rd, vec3 bcol) {\n    float k = rd.y*0.7+1.5;\n    vec3 col = mix(bcol,vec3(1.0,0.8,.0),k);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    //uv.x+=sin(floor(uv.y*500.0)*iTime*20.)*0.002;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 3, -10);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.yz *= Rot(radians(-20.0));\n    ro.xz *= Rot(iTime*1.2);\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,1.5,0), 1.);\n\n    vec4 d = RayMarch(ro, rd);\n    \n    vec3 bgCol = twoDRender(uv);\n    if(d.w<MAX_DIST) {\n        vec3 p = ro + rd * d.w;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd,n);\n        float spec = pow(max(0.0,r.y),30.);\n        float dif = dot(n,normalize(vec3(1,2,3)))*0.5+0.5;\n        col = mix(Bg(r,bgCol),vec3(dif),0.5)+spec;\n        //col += d.rgb;\n    } else {\n        // background\n        col += bgCol;\n    }\n    \n    fragColor = vec4(col*0.8,1.0)+(noise(uv.x*uv.y*iTime*0.1))*0.12;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsSXzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[644, 644, 675, 675, 762], [764, 764, 787, 787, 1029], [1031, 1031, 1053, 1053, 1360], [1362, 1362, 1395, 1395, 1648], [1650, 1650, 1674, 1674, 1875], [1877, 1877, 1900, 1900, 2290], [2292, 2292, 2334, 2334, 2529], [2531, 2531, 2553, 2553, 2627], [2629, 2629, 2651, 2651, 2741], [2743, 2743, 2780, 2780, 2860], [2862, 2862, 2911, 2911, 3079], [3081, 3081, 3122, 3122, 3257], [3259, 3259, 3306, 3306, 3641], [3643, 3643, 3690, 3690, 4157], [4159, 4159, 4206, 4206, 4653], [4655, 4655, 4702, 4702, 5365], [5367, 5367, 5414, 5414, 6013], [6015, 6015, 6049, 6049, 6453], [6455, 6455, 6493, 6493, 7048], [7050, 7050, 7076, 7076, 7625], [7627, 7627, 7656, 7656, 7747], [7749, 7749, 7806, 7806, 8745]], "test": "valid"}
{"id": "ftfGRr", "name": "Bigfan Sine wave", "author": "bigfanjs", "description": "sine wave", "tags": ["wave", "sine"], "likes": 1, "viewed": 45, "published": "Public", "date": "1621371059", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float blur = 0.002;\n\nfloat Rect(vec2 uv, float x, float y, float w, float h) {\n    uv.x += w / 2.;\n    uv.y += h / 2.;\n\n    float x1 = smoothstep(x - blur, x + blur, uv.x);\n    float x2 = smoothstep(x + w + blur, x + w - blur, uv.x);\n    \n    float y1 = smoothstep(y - blur, y + blur, uv.y);\n    float y2 = smoothstep(y + h + blur, y + h - blur, uv.y);\n    \n    return (x1 * x2) * (y1 * y2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    float time = iTime;\n\n    uv -= 0.5;\n\n    float x = uv.x;\n    float m = sin(x * 8. + time) * .2;\n    m = m*m*5.;\n    float y = uv.y - m;\n\n    float mask = Rect(vec2(x ,y), 0., 0., 1., 0.01);\n    vec3 col = vec3(1., 1., 0.) * mask;\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftfGRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 78, 78, 393], [395, 395, 452, 502, 837]], "test": "valid"}
{"id": "ftfGW7", "name": "Bicubic Interpolation Surface", "author": "oneshade", "description": "2D cubic interpolation.", "tags": ["2d", "3d", "raymarching", "bicubic", "cubic", "surface", "interpolation"], "likes": 10, "viewed": 128, "published": "Public", "date": "1622167402", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float bicubic4x4(in vec2 p, in mat4 v) {\n    ivec2 id = ivec2(floor(p));                                         // Cell index\n    vec2 uv = smoothstep(0.0, 1.0, fract(p));                           // Smoothed local cell coordinates\n    return mix(mix(v[id.x    ][id.y    ], v[id.x + 1][id.y    ], uv.x), // Lower horizontal pass\n               mix(v[id.x    ][id.y + 1], v[id.x + 1][id.y + 1], uv.x), // Upper horizontal pass\n               uv.y);                                                   // Vertical pass\n}\n\n// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\nfloat anim(in float seed) {\n    float a = Hash11(seed * 393.84 + 673.48);\n    float b = Hash11(seed * 348.46 + 183.37);\n    float c = Hash11(seed * 275.35 + 741.69);\n    return 0.5 + 0.5 * sin(iTime * a + b) * c;\n}\n\nfloat mapScene(in vec3 p) {\n    float height = bicubic4x4(p.xz + 1.5, mat4(anim( 1.0), anim( 2.0), anim( 3.0), anim( 4.0),\n                                               anim( 5.0), anim( 6.0), anim( 7.0), anim( 8.0),\n                                               anim( 9.0), anim(10.0), anim(11.0), anim(12.0),\n                                               anim(13.0), anim(14.0), anim(15.0), anim(16.0)));\n\n    return max(p.y - height, max(max(abs(p.x), abs(p.z)) - 1.5, -p.y));\n}\n\nvec3 getNormal(in vec3 p) {\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy) - mapScene(p - e.xyy),\n                          mapScene(p + e.yxy) - mapScene(p - e.yxy),\n                          mapScene(p + e.yyx) - mapScene(p - e.yyx)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Boilerplate\n    vec2 center = 0.5 * iResolution.xy;\n    vec2 mouse = (iMouse.xy - center) / iResolution.y * 3.14;\n    vec2 uv = (fragCoord - center) / iResolution.y;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 4.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    float t = 0.0;\n    for (int i=0; i < 100; i++) {\n        vec3 p = ro + rd * t;\n        float d = mapScene(p) * 0.75;\n        if (d < 0.001) {\n            vec3 n = getNormal(p);\n\n            fragColor.rgb += smoothstep(0.0, 0.05, abs(fract(p.x + 2.0) - 0.5));\n            fragColor.rgb += smoothstep(0.0, 0.05, abs(fract(p.z + 2.0) - 0.5));\n            fragColor.rgb *= 0.5 * max(0.0, dot(n, -rd));\n\n            break;\n        }\n\n        if (t > 100.0) {\n            break;\n        }\n\n        t += d;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftfGW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 518], [520, 609, 635, 635, 721], [723, 723, 750, 750, 937], [939, 939, 966, 966, 1423], [1425, 1425, 1452, 1452, 1694], [1696, 1696, 1751, 1770, 2823]], "test": "valid"}
{"id": "ftfGWH", "name": "[OUTLINE 2021] - Le tunnel", "author": "totetmatt", "description": "2nd Showdown from Outline 2021 :\n\nAs usual, not fully identical to bonzomatic, found it here :\n https://psenough.github.io/shader_summary/shader_file_sources/outline_shader_showdown_2021/outline_2021_totetmatt_2.glsl", "tags": ["outline", "showdown"], "likes": 7, "viewed": 193, "published": "Public API", "date": "1622020697", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 texNoise(vec2 uv,sampler2D tex ){ float f = 0.; f+=texture(tex, uv*.125).r*.5; f+=texture(tex,uv*.25).r*.25; //Funciton simulating the perlin noise texture we have in Bonzomatic shader editor, written by yx\n                       f+=texture(tex,uv*.5).r*.125; f+=texture(tex,uv*1.).r*.125; f=pow(f,1.2);return vec4(f*.45+.05);}\n\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nvec3 pal(float t){return .5+.5*cos(6.28*(1.*t+vec3(0.,.4,.6)));}\n#define texFFTIntegrated (floor(iTime)+pow(fract(iTime),.25))*.2\nvec3 grid(vec2 uv,float off){\n    vec2 uuv=uv;\n    float tt = texFFTIntegrated;\n    float ttt =texNoise(uv*.01,iChannel1).r;\n    float tttt=texture(iChannel0,vec2(.6)).r*50.;\n    uv*=rot(floor(tt*50.)*.785*.5);\n    uv = abs(fract(uv+ttt*tttt)-.5);\n\n    if(uv.x <=.002) return pal(.1+off)*length(uv)*2.*clamp((length(uuv)-.5),.0,1.);\n     return vec3(.0);\n}\n\nvec3 layer(vec2 uv,float off){\n uv.x +=off*.2;\n   uv.y +=off*.2;\n  float tuv = abs(atan(uv.x,abs(uv.y)))*.05;\n  float tt =texFFTIntegrated;\n  float ttt =texture(iChannel0,fract(vec2(floor(100.*tuv)/100.))).r*.2;\n  \n  float d = length(uv)-.2-ttt ;\n  d = abs(d)-.01+cos(tt)*.02;\n  d = abs(d)-.0020-ttt*.1;\n  d = smoothstep(fwidth(d),0.,d);\n  return vec3(d)*pal(off+ttt*10.)+grid(uv+ttt,off*3.33);;\n  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n\tvec3 col = vec3(.01);\n   float d = 0.;\n  float tttt=texFFTIntegrated;\n  const float lim = 20.;;\n  for(float i=0.;i<=lim;i++){\n    float it=i/lim;\n    float itt = fract(it+iTime*.01+tttt*.005);\n    \n   float z = mix(.001,20.,itt);\n    vec3 d = layer((uv*z)*rot(.785*i), it);\n    col +=vec3(d)*(1.-itt);\n  }\n  \n   /*vec3 pcol = texture(texPreviousFrame,puv).rgb;\n   col = mix(col,pcol,.7);*/\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}, {"id": "MlfSRf", "previewfilepath": "https://soundcloud.com/virgill/amiga-facebook-malefiz", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/virgill/amiga-facebook-malefiz", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftfGWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 332], [334, 334, 352, 352, 399], [400, 400, 418, 418, 464], [530, 530, 559, 559, 886], [888, 888, 918, 918, 1288], [1290, 1290, 1347, 1397, 1911]], "test": "error"}
{"id": "ftfGzB", "name": "Hex Variation (Kolmyjec - 1978)", "author": "lsdlive", "description": "William Kolmyjec's \"Hex Variation\".\nLoop on 4 seconds.\n\nOriginal artwork (1978): http://recodeproject.com/artwork/v3n4hex-variation", "tags": ["truchet", "hex", "kolmyjec"], "likes": 6, "viewed": 75, "published": "Public", "date": "1622285199", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n@lsdlive\nCC-BY-NC-SA\n\nWilliam Kolmyjec's \"Hex Variation\".\nLoop on 4 seconds.\n\nOriginal artwork (1978): http://recodeproject.com/artwork/v3n4hex-variation\n\n*/\n\n#define AA 5.\n#define pi 3.141592\n#define time (mod(iTime, 4.))\n\n// https://lospec.com/palette-list/1bit-monitor-glow\nvec3 col1 = vec3(.133, .137, .137);\nvec3 col2 = vec3(.941, .965, .941);\n\n\nmat2 r2d(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat rand(vec2 uv) {\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// inspired by Pixel Spirit Deck: https://patriciogonzalezvivo.github.io/PixelSpiritDeck/\n// + https://www.shadertoy.com/view/tsSXRz\nfloat stroke(float d, float width) {\n\treturn 1. - smoothstep(0., AA / iResolution.x, abs(d) - width * .5);\n}\n\nfloat circle(vec2 p, float radius) {\n  return length(p) - radius;\n}\n\n// Hex Grid helper from: https://www.shadertoy.com/view/7dX3Dj\nvec4 hexGrid(vec2 uv, out vec2 id)\n{\n    uv *= mat2(1.1547, 0., -.5773503, 1.);\n    vec2 f = fract(uv);\n    float triid = 1.;\n\tif((f.x + f.y) > 1.) {\n        f = 1. - f;\n     \ttriid = -1.;\n    }\n    vec2 co = step(f.yx, f) * step(1. - f.x - f.y, max(f.x, f.y));\n    id = floor(uv) + (triid < 0. ? 1. - co : co);\n    co = (f - co) * triid * mat2(.866026, 0., .5, 1.);\n    uv = abs(co);\n    //id*=inverse(mat2(1.1547,0.0,-0.5773503,1.0)); // optional unskew IDs\n    return vec4(.5 - max(uv.y, abs(dot(vec2(.866026, .5),uv))), length(co),co);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    \n    float t1 = fract(time * .125);\n    \n    const vec2 s = vec2(1.732, 1);\n    \n    uv += t1 * s;\n    \n    float scale = 8.;\n    vec2 id = vec2(0);\n    vec4 p = hexGrid(uv * scale, id);\n    uv = p.zw;\n    id = fract(id * 1. / scale);\n    \n    float r = rand(id);\n    if(r > 0. && r <= .33)\n        uv *= r2d(pi / 3. * 0.);\n    else if( r > .33 && r <= .66)\n        uv *= r2d(pi / 3. * 1.);\n    else\n        uv *= r2d(pi / 3. * 2.);\n    \n    uv.x = abs(uv.x);\n    float sdf = circle(uv-vec2(s.x * 1. / 3., 0), s.x * 1. / 6.);\n    \n    float size = .05;\n    float mask = stroke(sdf, size);\n    mask += stroke(uv.x, size);\n    \n    mask = clamp(mask, 0., 1.);\n    vec3 col = mix(col1, col2, mask);\n    \n    // hex grid outlines\n    //col.r += p.x < .01 || p.y < .01 ? 1. : 0.;\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftfGzB.jpg", "access": "shaders20k", "license": "cc-by-nc-4.0", "functions": [[354, 354, 373, 373, 439], [441, 441, 462, 462, 532], [534, 667, 703, 703, 775], [777, 777, 813, 813, 844], [846, 909, 945, 945, 1450], [1452, 1452, 1509, 1509, 2391]], "test": "valid"}
{"id": "ftl3z2", "name": "myco-fractal", "author": "Shellderr", "description": "myco-net", "tags": ["fractal", "spore"], "likes": 0, "viewed": 42, "published": "Public", "date": "1622447415", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define res iResolution\n#define ft float\n\nft hm(vec2 uv, vec2 m){\n    ft a = dot(uv,uv);\n    ft b = sin(.9*iTime+uv.x/a/m.x)*acos(uv.y/a/m.y);\nreturn abs(b*1.4);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord.xy-res.xy)/res.y;\n    vec2 m = vec2(3.3);\n    vec2 mouse = iMouse.y < 1.? vec2(.5): iMouse.xy/res.xy;\n    ft a = hm(uv, m);\n    for(ft i; i < 6.; i++){\n    uv = abs(uv/hm(uv,m+i*.2)-.4*mouse);\n    }\n    fragColor = vec4(1.-uv.xyy,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftl3z2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 42, 65, 65, 163], [165, 165, 221, 221, 487]], "test": "valid"}
{"id": "ftl3zN", "name": "Smoke ball", "author": "atyuwen", "description": "Shows how to use Bitangent Noise (a fast divergence-free noise generator) to mimic fluid motion.\nDetails: https://atyuwen.github.io/posts/bitangent-noise/\nSource: https://github.com/atyuwen/bitangent_noise/\n\n\n\n", "tags": ["noise", "fluid", "smoke", "bitangentnoise"], "likes": 19, "viewed": 564, "published": "Public", "date": "1621692475", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Shows how to use Bitangent Noise (a fast divergence-free noise generator) to mimic fluid motion.\n// Details: https://atyuwen.github.io/posts/bitangent-noise/\n// Source: https://github.com/atyuwen/bitangent_noise/\n// The checkerboard ground is stolen from iq's work: https://www.shadertoy.com/view/Xds3zN\n\n// Set to 1 to make the ball moves.\n// Set to 0 to disable movement and get higher framerate.\n#define ENABLE_MOVEMENT 1 \n\n//\t--------------------------------------------------------------------\n//\tOptimized implementation of 3D/4D bitangent noise.\n//\tBased on stegu's simplex noise: https://github.com/stegu/webgl-noise.\n//\tContact : atyuwen@gmail.com\n//\tAuthor : Yuwen Wu (https://atyuwen.github.io/)\n//\tLicense : Distributed under the MIT License.\n//\t--------------------------------------------------------------------\n\n// Permuted congruential generator (only top 16 bits are well shuffled).\n// References: 1. Mark Jarzynski and Marc Olano, \"Hash Functions for GPU Rendering\".\n//             2. UnrealEngine/Random.ush. https://github.com/EpicGames/UnrealEngine\nuvec2 _pcg3d16(uvec3 p)\n{\n\tuvec3 v = p * 1664525u + 1013904223u;\n\tv.x += v.y*v.z; v.y += v.z*v.x; v.z += v.x*v.y;\n\tv.x += v.y*v.z; v.y += v.z*v.x;\n\treturn v.xy;\n}\nuvec2 _pcg4d16(uvec4 p)\n{\n\tuvec4 v = p * 1664525u + 1013904223u;\n\tv.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n\tv.x += v.y*v.w; v.y += v.z*v.x;\n\treturn v.xy;\n}\n\n// Get random gradient from hash value.\nvec3 _gradient3d(uint hash)\n{\n\tvec3 g = vec3(uvec3(hash) & uvec3(0x80000, 0x40000, 0x20000));\n\treturn g * (1.0 / vec3(0x40000, 0x20000, 0x10000)) - 1.0;\n}\nvec4 _gradient4d(uint hash)\n{\n\tvec4 g = vec4(uvec4(hash) & uvec4(0x80000, 0x40000, 0x20000, 0x10000));\n\treturn g * (1.0 / vec4(0x40000, 0x20000, 0x10000, 0x8000)) - 1.0;\n}\n\n// Optimized 3D Bitangent Noise. Approximately 113 instruction slots used.\n// Assume p is in the range [-32768, 32767].\nvec3 BitangentNoise3D(vec3 p)\n{\n\tconst vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);\n\tconst vec4 D = vec4(0.0, 0.5, 1.0, 2.0);\n\n\t// First corner\n\tvec3 i = floor(p + dot(p, C.yyy));\n\tvec3 x0 = p - i + dot(i, C.xxx);\n\n\t// Other corners\n\tvec3 g = step(x0.yzx, x0.xyz);\n\tvec3 l = 1.0 - g;\n\tvec3 i1 = min(g.xyz, l.zxy);\n\tvec3 i2 = max(g.xyz, l.zxy);\n\n\t// x0 = x0 - 0.0 + 0.0 * C.xxx;\n\t// x1 = x0 - i1  + 1.0 * C.xxx;\n\t// x2 = x0 - i2  + 2.0 * C.xxx;\n\t// x3 = x0 - 1.0 + 3.0 * C.xxx;\n\tvec3 x1 = x0 - i1 + C.xxx;\n\tvec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n\tvec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n\ti = i + 32768.5;\n\tuvec2 hash0 = _pcg3d16(uvec3(i));\n\tuvec2 hash1 = _pcg3d16(uvec3(i + i1));\n\tuvec2 hash2 = _pcg3d16(uvec3(i + i2));\n\tuvec2 hash3 = _pcg3d16(uvec3(i + 1.0 ));\n\n\tvec3 p00 = _gradient3d(hash0.x); vec3 p01 = _gradient3d(hash0.y);\n\tvec3 p10 = _gradient3d(hash1.x); vec3 p11 = _gradient3d(hash1.y);\n\tvec3 p20 = _gradient3d(hash2.x); vec3 p21 = _gradient3d(hash2.y);\n\tvec3 p30 = _gradient3d(hash3.x); vec3 p31 = _gradient3d(hash3.y);\n\n\t// Calculate noise gradients.\n\tvec4 m = clamp(0.5 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0, 1.0);\n\tvec4 mt = m * m;\n\tvec4 m4 = mt * mt;\n\n\tmt = mt * m;\n\tvec4 pdotx = vec4(dot(p00, x0), dot(p10, x1), dot(p20, x2), dot(p30, x3));\n\tvec4 temp = mt * pdotx;\n\tvec3 gradient0 = -8.0 * (temp.x * x0 + temp.y * x1 + temp.z * x2 + temp.w * x3);\n\tgradient0 += m4.x * p00 + m4.y * p10 + m4.z * p20 + m4.w * p30;\n\n\tpdotx = vec4(dot(p01, x0), dot(p11, x1), dot(p21, x2), dot(p31, x3));\n\ttemp = mt * pdotx;\n\tvec3 gradient1 = -8.0 * (temp.x * x0 + temp.y * x1 + temp.z * x2 + temp.w * x3);\n\tgradient1 += m4.x * p01 + m4.y * p11 + m4.z * p21 + m4.w * p31;\n\n\t// The cross products of two gradients is divergence free.\n\treturn cross(gradient0, gradient1) * 3918.76;\n}\n\n// 4D Bitangent noise. Approximately 163 instruction slots used.\n// Assume p is in the range [-32768, 32767].\nvec3 BitangentNoise4D(vec4 p)\n{\n\tconst vec4 F4 = vec4( 0.309016994374947451 );\n\tconst vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n\t                      0.276393202250021,  // 2 * G4\n\t                      0.414589803375032,  // 3 * G4\n\t                     -0.447213595499958 ); // -1 + 4 * G4\n\n\t// First corner\n\tvec4 i  = floor(p + dot(p, F4) );\n\tvec4 x0 = p -   i + dot(i, C.xxxx);\n\n\t// Other corners\n\n\t// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n\tvec4 i0;\n\tvec3 isX = step( x0.yzw, x0.xxx );\n\tvec3 isYZ = step( x0.zww, x0.yyz );\n\t// i0.x = dot( isX, vec3( 1.0 ) );\n\ti0.x = isX.x + isX.y + isX.z;\n\ti0.yzw = 1.0 - isX;\n\t// i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n\ti0.y += isYZ.x + isYZ.y;\n\ti0.zw += 1.0 - isYZ.xy;\n\ti0.z += isYZ.z;\n\ti0.w += 1.0 - isYZ.z;\n\n\t// i0 now contains the unique values 0,1,2,3 in each channel\n\tvec4 i3 = clamp( i0, 0.0, 1.0 );\n\tvec4 i2 = clamp( i0 - 1.0, 0.0, 1.0 );\n\tvec4 i1 = clamp( i0 - 2.0, 0.0, 1.0 );\n\n\t// x0 = x0 - 0.0 + 0.0 * C.xxxx\n\t// x1 = x0 - i1  + 1.0 * C.xxxx\n\t// x2 = x0 - i2  + 2.0 * C.xxxx\n\t// x3 = x0 - i3  + 3.0 * C.xxxx\n\t// x4 = x0 - 1.0 + 4.0 * C.xxxx\n\tvec4 x1 = x0 - i1 + C.xxxx;\n\tvec4 x2 = x0 - i2 + C.yyyy;\n\tvec4 x3 = x0 - i3 + C.zzzz;\n\tvec4 x4 = x0 + C.wwww;\n\n\ti = i + 32768.5;\n\tuvec2 hash0 = _pcg4d16(uvec4(i));\n\tuvec2 hash1 = _pcg4d16(uvec4(i + i1));\n\tuvec2 hash2 = _pcg4d16(uvec4(i + i2));\n\tuvec2 hash3 = _pcg4d16(uvec4(i + i3));\n\tuvec2 hash4 = _pcg4d16(uvec4(i + 1.0 ));\n\n\tvec4 p00 = _gradient4d(hash0.x); vec4 p01 = _gradient4d(hash0.y);\n\tvec4 p10 = _gradient4d(hash1.x); vec4 p11 = _gradient4d(hash1.y);\n\tvec4 p20 = _gradient4d(hash2.x); vec4 p21 = _gradient4d(hash2.y);\n\tvec4 p30 = _gradient4d(hash3.x); vec4 p31 = _gradient4d(hash3.y);\n\tvec4 p40 = _gradient4d(hash4.x); vec4 p41 = _gradient4d(hash4.y);\n\n\t// Calculate noise gradients.\n\tvec3 m0 = clamp(0.6 - vec3(dot(x0, x0), dot(x1, x1), dot(x2, x2)), 0.0, 1.0);\n\tvec2 m1 = clamp(0.6 - vec2(dot(x3, x3), dot(x4, x4)             ), 0.0, 1.0);\n\tvec3 m02 = m0 * m0; vec3 m03 = m02 * m0;\n\tvec2 m12 = m1 * m1; vec2 m13 = m12 * m1;\n\n\tvec3 temp0 = m02 * vec3(dot(p00, x0), dot(p10, x1), dot(p20, x2));\n\tvec2 temp1 = m12 * vec2(dot(p30, x3), dot(p40, x4));\n\tvec4 grad0 = -6.0 * (temp0.x * x0 + temp0.y * x1 + temp0.z * x2 + temp1.x * x3 + temp1.y * x4);\n\tgrad0 += m03.x * p00 + m03.y * p10 + m03.z * p20 + m13.x * p30 + m13.y * p40;\n\n\ttemp0 = m02 * vec3(dot(p01, x0), dot(p11, x1), dot(p21, x2));\n\ttemp1 = m12 * vec2(dot(p31, x3), dot(p41, x4));\n\tvec4 grad1 = -6.0 * (temp0.x * x0 + temp0.y * x1 + temp0.z * x2 + temp1.x * x3 + temp1.y * x4);\n\tgrad1 += m03.x * p01 + m03.y * p11 + m03.z * p21 + m13.x * p31 + m13.y * p41;\n\n\t// The cross products of two gradients is divergence free.\n\treturn cross(grad0.xyz, grad1.xyz) * 81.0;\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    // filter kernel\n    vec2 w = abs(dpdx)+abs(dpdy) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n#if ENABLE_MOVEMENT\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\nfloat map(in vec3 p)\n{\n    const float r = 1.0;\n    float x = r * sin(iTime);\n    float z = r * cos(iTime);\n    \n    vec3 c = vec3(x, 1, z);\n    vec3 v = vec3(z, 0,-x) * 2.;\n    float d = length(p - c) - 0.5;\n    float d2 = sdCapsule(p, c, c - v * 0.2, 0.5);\n    if (d < -0.2 || d2 > 0.3) return min(d, d2);\n   \n    p = p + (normalize(BitangentNoise4D(vec4(3. * p, iTime))) + v) * 0.05;\n    d = length(p - c);\n    if (d < 0.5) return d - 0.5;\n\n    p = p + (normalize(BitangentNoise4D(vec4(3. * p, iTime))) + v) * 0.05;\n    d = length(p - c);\n    if (d < 0.5) return d - 0.5;\n    \n    p = p + (normalize(BitangentNoise4D(vec4(3. * p, iTime))) + v) * 0.05;\n    d = length(p - c);\n    if (d < 0.5) return d - 0.5;\n    \n    p = p + (normalize(BitangentNoise4D(vec4(3. * p, iTime))) + v) * 0.05;\n    d = length(p - c);\n    return d - 0.5;\n}\n#else\nfloat map(in vec3 p)\n{\n    float d = length(p - vec3(0, 1, 0));\n    if (abs(d - 0.5) > 0.2)\n    {\n        // early quit for optimization.\n        return d - 0.5;\n    }\n\n    p = p + normalize(BitangentNoise4D(vec4(3. * p, iTime))) * 0.05;\n    p = p + normalize(BitangentNoise4D(vec4(3. * p, iTime))) * 0.05;\n    p = p + normalize(BitangentNoise4D(vec4(3. * p, iTime))) * 0.05;\n    p = p + normalize(BitangentNoise4D(vec4(3. * p, iTime))) * 0.05;\n    d = length(p - vec3(0, 1, 0)) - 0.5;\n    return d;\n}\n#endif\n\nconst vec3 sundir = vec3(-1, 1, 0);\nconst vec3 fog = vec3(0.242, 0.334, 0.42) * 2.;\n\nvec4 raymarch(in vec3 ro, in vec3 rd)\n{\n    vec4 acc = vec4(0.);\n    float t = 0.0;\n    for (int i = 0; i < 32 && acc.a < 0.95; ++i)\n    {\n        vec3 pos = ro + t * rd;\n        float d = map(pos);\n        float a = clamp(d * -30., 0.0, 0.2);\n        float s = map(pos + 0.3 * sundir);\n        float diff = clamp((s - d) * 0.4, 0.0, 1.0);\n        vec3 brdf = vec3(0.65,0.68,0.7)* 0.2 + 3.*vec3(0.7, 0.5, 0.3)*diff;\n        acc.w += (1. - acc.w) * a;\n        acc.xyz += a * brdf;\n        t += max(d * 0.5, 0.02);\n    }\n    \n    acc.xyz /= (0.001 + acc.w);\n    return acc;\n}\n\nvec3 shade(vec3 diff, float m, vec3 N, vec3 L, vec3 V)\n{\n  vec3 H = normalize(V + L);\n  float F = 0.05 + 0.95 * pow(1. - dot(V, H), 5.);\n  float R = F * pow(max(dot(N, H), 0.), m);\n  return diff + R * (m + 8.) / 8.;\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    for( float t=mint; t<tmax; )\n    {\n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, 4.*h/t );\n        t += h;\n    }\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 32.0 + iTime * 1.2;\n\n    // camera\n#if ENABLE_MOVEMENT    \n    const float dist = 4.5;\n#else\n    const float dist = 3.0;\n#endif\n    vec3 ta = vec3( 0, 1, 0 );\n    vec3 ro = ta + vec3( dist*cos(0.1*time + 7.0*mo.x), 0.6 + 2.0*mo.y, dist*sin(0.1*time + 7.0*mo.x) );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    // focal length\n    const float fl = 2.5;\n        \n    // ray direction\n    vec3 rd = ca * normalize( vec3(p,fl) );\n\n    // ray differentials\n    vec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\n    vec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\n    vec3 rdx = ca * normalize( vec3(px,fl) );\n    vec3 rdy = ca * normalize( vec3(py,fl) );\n    \n    // raymarch the smoke ball\n    vec4 col = raymarch(ro, rd);\n    \n    // raytrace floor plane\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1 > 0.0 )\n    {\n        vec3 pos = ro + rd * tp1;\n        vec3 dpdx = ro.y*(rd/rd.y-rdx/rdx.y);\n        vec3 dpdy = ro.y*(rd/rd.y-rdy/rdy.y);\n        float f = checkersGradBox( 3.0*pos.xz, 3.0*dpdx.xz, 3.0*dpdy.xz );\n        vec3 ground = shade(0.15 + f * vec3(0.5), 5., vec3(0,1,0), sundir, -rd) * vec3(1.3, 1.2, 1.1);\n        \n        float shadow = calcSoftshadow(pos, normalize(sundir), 0.1, 4.0);\n        ground = ground * mix(0.3, 1.0, shadow);\n        ground = mix(ground, fog, clamp(tp1 * 0.06, 0., 1.));\n        \n        col.xyz = mix(ground, col.xyz, col.w);\n    }\n    else\n    {\n        col.xyz = mix(fog, col.xyz, col.w);\n    }\n    \n    float sun = clamp(dot(sundir,rd), 0.0, 1.0);\n    col.xyz += vec3(1.0,.6,0.1) * 0.6 * (pow(sun, 6.) * 0.5 + max(rd.y * 3., 0.05));\n     \n    // Output to screen\n    fragColor = vec4(pow(col.xyz, vec3(0.4545)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftl3zN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[831, 1074, 1099, 1099, 1236], [1237, 1237, 1262, 1262, 1415], [1417, 1457, 1486, 1486, 1611], [1612, 1612, 1641, 1641, 1783], [1785, 1905, 1936, 1936, 3728], [3730, 3840, 3871, 3871, 6617], [6619, 6695, 6759, 6780, 7013], [7015, 7015, 7067, 7067, 7244], [8877, 8877, 8916, 8916, 9450], [9452, 9452, 9508, 9508, 9669], [9671, 9733, 9811, 9811, 10025], [10027, 10027, 10084, 10084, 11944]], "test": "valid"}
{"id": "ftl3zS", "name": "Hash for float 2d vectors", "author": "Envy24", "description": "random, hash, noise", "tags": ["noise", "random", "hash"], "likes": 1, "viewed": 41, "published": "Public", "date": "1622319171", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* \n    Hash for float vectors.\n    \n    Returns value in range [0.0; 1.0].\n*/\nfloat fhash2D(vec2 p, float enthropy /* [-1.0; -3000.0] */)\n{\n    p.x = p.x < 1.0 ? p.x + enthropy : p.x;\n    p.y = p.y < 1.0 ? p.y - enthropy : p.y;\n    \n    return fract(\n        mod((p.x*p.x*p.y)*6.004323764, p.x*45.2875349852) + \n        mod((p.y*p.y)*0.093004323764, p.y*(enthropy * 0.2340234912))\n    );\n}\n\nfloat enthropy = -1054.0; /* [-1.0; -3000.0] */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float gray;\n\n    if (uv.x < 0.20)\n    {\n       gray = fhash2D(fragCoord, enthropy);\n    }\n    else if (uv.x >= 0.2 && uv.x < 0.4)\n    {\n       gray = fhash2D(fragCoord + iTime, enthropy);\n    }\n    else if (uv.x >= 0.4 && uv.x < 0.6)\n    {\n       gray = fhash2D(fragCoord, -iTime);\n    }\n    else if (uv.x >= 0.6 && uv.x < 0.8)\n    {\n       gray = fhash2D(fragCoord, -iTime * 100.0);\n    }\n    else\n    {\n       gray = fhash2D(fragCoord, -iTime * 1000.0);\n    }\n\n    // Output to screen\n    fragColor = vec4(gray, gray, gray, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftl3zS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 79, 140, 140, 390], [441, 441, 498, 548, 1127]], "test": "valid"}
{"id": "fts3R4", "name": "Uncanny Thingy", "author": "rimina", "description": "I did this shader at my live stream on 22th of May 2021. I wanted to explore how to model with SDFs something more complex than a field of cubes.", "tags": ["sdfmodelling"], "likes": 5, "viewed": 71, "published": "Public", "date": "1621631716", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PIXELR = (0.5/1280.0);\nconst float E = 0.001;\nconst float FAR = 60.0;\nconst int STEPS = 64;\n\nconst vec3 FOG_COLOR = vec3(0.08, 0.08, 0.085);\nconst vec3 LIGHT_COLOR = vec3(0.8, 0.5, 0.8);\n\nconst float PI  = 3.14159265;\nconst float PHI = (sqrt(5.0)*0.5 + 0.5);\n\nvec3 glow = vec3(0.0);\n\nstruct Material{\n  vec3 l_col;\n  vec3 s_col;\n  float l_i;\n  float s_i;\n  float shiny;\n};\n\nMaterial getMaterial(){\n  Material m;\n  m.l_col = vec3(0.3, 0.5, 0.9);\n  m.s_col = vec3(0.5, 0.8, 1.0);\n  m.l_i = 0.6;\n  m.s_i = 0.4;\n  m.shiny = 8.0;\n  \n  return m;\n}\n\nMaterial getSkin(){\n  Material m;\n  m.l_col = vec3(0.8, 0.7, 0.4);\n  m.s_col = vec3(0.8, 0.7, 0.4);\n  m.l_i = 0.9;\n  m.s_i = 0.1;\n  m.shiny = 1.0;\n  \n  return m;\n}\n\nMaterial getHair(){\n  Material m;\n  m.l_col = vec3(0.2, 0.7, 0.8);\n  m.s_col = vec3(0.4, 0.8, 0.9);\n  m.l_i = 0.3;\n  m.s_i = 0.7;\n  m.shiny = 30.0;\n  \n  return m;\n}\n\nMaterial getEye(){\n  Material m;\n  m.l_col = vec3(0.1, 0.2, 0.1);\n  m.s_col = vec3(0.2, 0.5, 0.3);\n  m.l_i = 0.2;\n  m.s_i = 0.8;\n  m.shiny = 10.0;\n  \n  return m;\n}\n\nMaterial getLips(){\n  Material m;\n  m.l_col = vec3(3.0, 0.1, 0.6);\n  m.s_col = vec3(8.0, 0.2, 0.8);\n  m.l_i = 0.2;\n  m.s_i = 0.7;\n  m.shiny = 20.0;\n  \n  return m;\n}\n\nMaterial MATERIAL;\n\n//SOME FUNCTIONS FROM HG_SDF\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n\treturn (x<0.0)?-1.0:1.0;\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\n// Capsule: A Cylinder with round caps on both sides\nfloat fCapsule(vec3 p, float r, float c) {\n\treturn mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n}\n\n// Cone with correct distances to tip and base circle. Y is up, 0 is in the middle of the base.\nfloat fCone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tvec2 tip = q - vec2(0.0, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\t\n\t// distance to tip\n\tif ((q.y > height) && (projected < 0.0)) {\n\t\td = max(d, length(tip));\n\t}\n\t\n\t// distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 0)));\n\t}\n\treturn d;\n}\n\n//https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n//https://www.shadertoy.com/view/tdS3DG\nfloat fEllipsoid( vec3 p, vec3 r ){\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a){\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n//https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat opSmoothUnion( float d1, float d2, float k ){\n  float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n  return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k ){\n  float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n  return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\n// 3D noise function (IQ)\nfloat noise(vec3 p){\n\tvec3 ip = floor(p);\n    p -= ip;\n    vec3 s = vec3(7.0,157.0,113.0);\n    vec4 h = vec4(0.0, s.yz, s.y+s.z)+dot(ip, s);\n    p = p*p*(3.0-2.0*p);\n    h = mix(fract(sin(h)*43758.5), fract(sin(h+s.x)*43758.5), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\n//SCENE STARTS\n\n\nfloat scene(vec3 p){\n  MATERIAL = getMaterial();\n  \n  vec3 pp = p;\n  \n  float n = noise(p*(sqrt(5.0)*0.5 + 0.5)*2.5+iTime*0.25)*0.15;\n  \n  //HEAD & HAIR\n  vec3 head_offset = vec3(0.0, 1.0, 0.0);\n  float head = fSphere(pp-head_offset, 0.45);\n  \n  pp -= vec3(0.0, 1.1, -0.3);\n  pR(pp.yz, PI*0.25);\n  float hair = fEllipsoid(pp, vec3(0.63, 0.74, 0.4));\n  pp -= vec3(0.0, 0.5, 0.1);\n  pR(pp.yz, -PI*0.1);\n  hair = opSmoothUnion(hair, fEllipsoid(pp-vec3(0.0, 0.0, 0.1), vec3(0.53, 0.2, 0.2)), 0.25);\n  hair -= n;\n  pp = p;\n  \n  //FACE\n  //EYES\n  pp -= vec3(0.0, 0.95, 0.45);\n  pp.x = abs(pp.x)-0.15;\n  float socket = fEllipsoid(pp, vec3(0.05, 0.03, 0.05));\n  float eye = fEllipsoid(pp-vec3(0.0, 0.0, -0.08), vec3(0.05, 0.015, 0.05));\n  head = opSmoothSubtraction(socket, head, 0.09);\n  pp = p;\n  \n  //NOSE\n  pp -= head_offset;\n  float nose = fEllipsoid(pp-vec3(0.0, -0.18, 0.4), vec3(0.03, 0.035, 0.02));\n  head = opSmoothUnion(nose, head, 0.1);\n  pp = p;\n  \n  //LIPS\n  pp -= head_offset;\n  pp.x = abs(pp.x)-0.02;\n  float lips = fEllipsoid(pp-vec3(0.0, -0.27, 0.33), vec3(0.08, 0.06, 0.02));\n  pp = p;\n  \n  //NECK\n  float neck = fCapsule(pp, 0.15, 1.0);\n  head = opSmoothUnion(neck, head, 0.05);\n  \n  \n  //TORSO\n  vec3 torso_offset = vec3(0.0, -0.2, 0.0);\n  float torso = fEllipsoid(pp-torso_offset, vec3(0.65, 0.7, 0.5));\n  torso_offset = vec3(0.0, -1.4, 0.0);\n  torso = opSmoothUnion(torso, fEllipsoid(pp-torso_offset, vec3(0.75, 1.25, 0.66)), 0.05);\n  \n  //SKIRT\n  n = noise(p*3.0 + iTime*0.5)*0.1;\n  vec3 skirt_offset = vec3(0.0, -2.5, 0.0);\n  float skirt = fCone(pp-skirt_offset, 1.2, 2.9);\n  skirt -=n;\n  \n  //SHOULDERS\n  pR(pp.xy, PI*0.5);\n  vec3 shoulder_offset = vec3(0.2, 0.0, 0.0);\n  float shoulders = fCapsule(pp-shoulder_offset, 0.25, 0.54);\n  \n  pp.y = abs(pp.y)-1.0;\n  pR(pp.xy, PI*0.2);\n  \n  //ARMS\n  float arms = fCapsule(pp-vec3(0.01, 0.0, 0.0), 0.19, 0.3);\n  pR(pp.xy, -PI*0.5);\n  pR(pp.yz, -PI*0.2);\n  float hands = fCapsule(pp-vec3(-0.4, -0.5, 0.0), 0.16, 0.4);\n  arms = opSmoothUnion(arms, hands, 0.12);\n  \n  \n  //MATERIALS\n  if((head < torso && head < skirt && head < shoulders && head < arms && head < hair && head < eye && head < lips) ||\n    (arms < head && arms < skirt && arms < shoulders && arms < torso && arms < hair && arms < eye && arms < lips)){\n    MATERIAL = getSkin();\n  }\n  else if(hair < head && hair < torso && hair < skirt && hair < shoulders && hair < arms && hair < eye && hair < lips){\n    MATERIAL = getHair();\n  }\n  else if(eye < head && eye < hair && eye < torso && eye < skirt && eye < shoulders && eye < arms && eye < lips){\n    MATERIAL = getEye();\n  }\n  else if(lips < head && lips < hair && lips < eye && lips < torso && lips < skirt && lips < shoulders && lips < arms){\n    MATERIAL = getLips();\n  }\n  \n  glow += vec3(0.2, 0.8, 0.8) * 0.02 / (0.05 + abs(hair));\n  \n  head = min(head, hair);\n  head = opSmoothUnion(head, eye, 0.02);\n  head = opSmoothUnion(lips, head, 0.01);\n  \n  torso = opSmoothUnion(torso, head, 0.01);\n  torso = opSmoothUnion(torso, skirt, 0.25);\n  torso = opSmoothUnion(torso, shoulders, 0.2);\n  torso = opSmoothUnion(torso, arms, 0.14);\n  \n  return torso;\n}\n\n//SCENE ENDS\n\n//Enhanced sphere tracing algorithm introduced by Mercury\nfloat march(vec3 ro, vec3 rd){\n  float t = E;\n  float d = 0.0;\n\n  float omega = 1.0;//muista testata eri arvoilla! [1,2]\n  float prev_radius = 0.0;\n\n  float candidate_t = t;\n  float candidate_error = 1000.0;\n  float sg = sgn(scene(ro));\n\n  vec3 p = ro;\n\n\tfor(int i = 0; i < STEPS; ++i){\n\t\tfloat sg_radius = sg*scene(p);\n\t\tfloat radius = abs(sg_radius);\n\t\td = sg_radius;\n\t\tbool fail = omega > 1. && (radius+prev_radius) < d;\n\t\tif(fail){\n\t\t\td -= omega * d;\n\t\t\tomega = 1.;\n\t\t}\n\t\telse{\n\t\t\td = sg_radius*omega;\n\t\t}\n\t\tprev_radius = radius;\n\t\tfloat error = radius/t;\n\n\t\tif(!fail && error < candidate_error){\n\t\t\tcandidate_t = t;\n\t\t\tcandidate_error = error;\n\t\t}\n\n\t\tif(!fail && error < PIXELR || t > FAR){\n\t\t\tbreak;\n\t\t}\n\t\tt += d;\n    p = rd*t+ro;\n\t}\n  //discontinuity reduction\n  float er = candidate_error;\n  for(int j = 0; j < 6; ++j){\n    float radius = abs(sg*scene(p));\n    p += rd*(radius-er);\n    t = length(p-ro);\n    er = radius/t;\n\n    if(er < candidate_error){\n      candidate_t = t;\n      candidate_error = er;\n    }\n  }\n\tif(t <= FAR || candidate_error <= PIXELR){\n\t\tt = candidate_t;\n\t}\n\treturn t;\n}\n\nvec3 normals(vec3 p){\n  vec3 eps = vec3(E, 0.0, 0.0);\n  return normalize(vec3(\n    scene(p+eps.xyy) - scene(p-eps.xyy),\n    scene(p+eps.yxy) - scene(p-eps.yxy),\n    scene(p+eps.yyx) - scene(p-eps.yyx)\n  ));\n}\n\n//http://www.iquilezles.org/www/articles/fog/fog.htm\nvec3 fog(vec3 col, vec3 p, vec3 ro, vec3 rd, vec3 ld){\n  float dist = length(p-ro);\n\tfloat sunAmount = max( dot(rd, -ld), 0.0 );\n\tfloat fogAmount = 1.0 - exp( -dist*0.07);\n\tvec3  fogColor = mix(FOG_COLOR, LIGHT_COLOR, pow(sunAmount, 8.0));\n  return mix(col, fogColor, fogAmount);\n}\n\nvec3 shade(vec3 p, vec3 rd, vec3 ld){\n  vec3 n = normals(p);\n  \n  float l = max(dot(n, ld), 0.0);\n  float a = max(dot(reflect(ld, n), rd), 0.0);\n  float s = pow(a, MATERIAL.shiny);\n  \n  return l*MATERIAL.l_col*MATERIAL.l_i+s*MATERIAL.s_col*MATERIAL.s_i;\n  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 q = -1.0+2.0*uv;\n    q.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(0.0, 0.0, 5.0);\n    vec3 rt = vec3(0.0, -1.0, 0.0);\n\n    vec3 z = normalize(rt-ro);\n    vec3 x = normalize(cross(z, vec3(0.0, 1.0, 0.0)));\n    vec3 y = normalize(cross(x, z));\n\n    vec3 rd = normalize(mat3(x,y,z)*vec3(q, radians(60.0)));\n\n    vec3 col = FOG_COLOR;\n    float t = march(ro, rd);\n    vec3 p = rd*t+ro;\n\n    if(t <= FAR){\n    col += shade(p, rd, -z);\n    }\n\n    col += glow*0.2;\n\n    col = fog(col, p, ro, rd, -z);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fts3R4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[386, 386, 409, 409, 553], [555, 555, 574, 574, 718], [720, 720, 739, 739, 884], [886, 886, 904, 904, 1049], [1051, 1051, 1070, 1070, 1215], [1267, 1306, 1326, 1326, 1354], [1356, 1356, 1376, 1376, 1411], [1413, 1413, 1445, 1445, 1470], [1472, 1546, 1602, 1602, 1644], [1646, 1682, 1710, 1710, 1791], [1793, 1838, 1886, 1886, 1960], [1962, 2015, 2057, 2057, 2151], [2153, 2249, 2298, 2298, 2800], [2802, 2916, 2951, 2951, 3034], [3036, 3274, 3305, 3305, 3347], [3349, 3423, 3474, 3474, 3569], [3571, 3571, 3628, 3628, 3724], [3726, 3752, 3772, 3772, 4051], [4070, 4070, 4090, 4090, 7196], [7212, 7270, 7300, 7300, 8371], [8373, 8373, 8394, 8394, 8581], [8583, 8636, 8690, 8690, 8917], [8919, 8919, 8956, 8956, 9177], [9179, 9179, 9236, 9286, 9902]], "test": "error"}
{"id": "fts3RM", "name": "RayMarching Practice by EricZhan", "author": "doremi31618", "description": "a raymarching demo", "tags": ["raymarching"], "likes": 1, "viewed": 35, "published": "Public", "date": "1621779503", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\n\n\n\n\nfloat GetDist(vec3 pos){\n    vec4 s = vec4(0, 1, 5, 1);\n    \n    float sphereDist = length(pos - s.xyz) - s.w;\n    float planeDist = pos.y;\n    \n    float d = min(sphereDist, planeDist);\n    return d;\n\n}\n\nvec3 GetNormal(vec3 p){\n    float d = GetDist(p);\n    vec2 e = vec2(0.01f, 0.0);\n    \n    \n    vec3 normal = d - vec3(\n        GetDist(p - e.xyy),\n        GetDist(p - e.yxy),\n        GetDist(p - e.yyx));\n        \n    return normalize(normal);\n}\n\n\n\nfloat RayMarching (vec3 ro, vec3 rd){\n    \n    float d0 = 0.;\n    for (int i=0; i<MAX_STEPS; i++){\n        vec3 p = ro + rd * d0;\n        float ds = GetDist(p);\n        d0 += ds;\n        if (d0 > MAX_DIST || ds < SURF_DIST)break;\n    }\n    return d0;\n\n}\nfloat GetLight(vec3 p){\n    vec3 lightPos = vec3(0, 5, 6);\n    \n    lightPos += vec3(sin(iTime), 0,cos(iTime)) * 5.0;\n    vec3 normal = GetNormal(p);\n    vec3 light = normalize(lightPos - p);\n    //float d = RayMarch\n    float dif = clamp(dot(normal, light), 0.0, 1.0);\n    \n    float d = RayMarching(p+normal * SURF_DIST, normalize(lightPos - p));\n    if (d < length(lightPos - p)) dif *= 0.1;\n    return dif;\n}\n\n//ray marching / shpere tracing \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 1, 1);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    \n    float d = RayMarching(ro, rd);\n    //the hitted point \n    vec3 p = ro + rd * d;\n    float dif = GetLight(p);\n    col = vec3(dif);\n    //col = GetNormal(p);\n    fragColor = vec4 (col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fts3RM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 96, 96, 275], [277, 277, 300, 300, 521], [525, 525, 562, 562, 778], [779, 779, 802, 802, 1191], [1227, 1227, 1284, 1284, 1659]], "test": "valid"}
{"id": "fts3Wr", "name": "IDRK", "author": "Spookyboi241", "description": "lol", "tags": ["funny"], "likes": 1, "viewed": 45, "published": "Public", "date": "1621914813", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n   \n    // Time varying pixel color\n    vec3 col = -69.0 * -69.0 *tan(iTime*uv.xyx*vec3(69,420,666))+-0.5;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n    // channel resolution (6969)\n    vec3 iChannelResolution[45];\n    \n    //(2021, May, 27th, 10;47am)\n    vec4 idate;\n    \n    //input channel. XX= 2D/cube)\n    \n    }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fts3Wr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 106, 484]], "test": "valid"}
{"id": "ftsGRS", "name": "Fabric skirt", "author": "avin", "description": "visual experiment", "tags": ["noise", "lines", "cloth"], "likes": 13, "viewed": 233, "published": "Public API", "date": "1622313046", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926 \n#define PI2 6.2831852 \n \n#define SF 1./min(iResolution.x,iResolution.y)\n#define SS(l,s) smoothstep(SF,-SF,l-s)\n\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\n#define MOD3 vec3(.1031, .11369, .13787)\n\nfloat hash11(float p)\n{\n    p = fract(p * 0.1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec3 hash33(vec3 p3)\n{\n    p3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz + 19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y, (p3.y + p3.z) * p3.x));\n}\n\nfloat snoise(vec3 p)\n{\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n\n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n\n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n    vec3 i1 = e * (1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy * (1.0 - e);\n\n    vec3 d1 = d0 - (i1 - 1.0 * K2);\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\n\n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\n\n    return dot(vec4(31.316), n);\n}\n \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{     \n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n          \n    float l = length(uv);\n    \n    vec3 result = vec3(0.);     \n    \n    for(float i=40.; i>0.; i-=1.){\n    \n        float a = sin(atan(uv.y, uv.x) + i*.1);\n        float am = abs(a-.5)/4.;\n    \n        float zn = .0125 + snoise(vec3(a,a, 10.*i*.005 + iTime*1.25-i*.11))*i*.0025 + i*.01;\n        float d = SS(l, zn);\n        \n        float rn = hash11(i);\n        vec3 col = hue(rn).rgb;\n        \n        result = mix(result, col, d);\n        \n        float dd =  SS(l, zn) * SS(zn-SF, l);\n        \n        result = mix(result, vec3(0.), dd);\n    }\n    \n\n    fragColor = vec4(vec3(result), 1.0);\n} \n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftsGRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[242, 242, 265, 265, 351], [353, 353, 375, 375, 542], [544, 544, 566, 566, 1212], [1215, 1215, 1270, 1270, 1950]], "test": "valid"}
{"id": "ftsGz2", "name": "Raytracing Strange Jellyfish", "author": "bloxard", "description": "The first species of antigravity jellyfish discovered on the coast of Vanuatu. \nLocal fisherman Frank Wilson told reporters at the Vanuatu Daily: \"That shit is floatin' and whatnot.\" end quote.", "tags": ["raytracing", "reflection", "transparency", "grid", "sun", "spectrum", "antialias", "animation", "jellyfish", "quadratic", "quartic", "atmosphere"], "likes": 11, "viewed": 448, "published": "Public", "date": "1622446962", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Per Bloksgaard/2021 \n// Raytracing a strange antigravity jellyfish.\nconst float PI = 3.14159;\n\nvec4 QuatFromAxisAngle(vec3 axis, float angle)\n{\n\tfloat hA = angle * 0.5;\n\tfloat s = sin(hA);\n\tfloat c = cos(hA);\n\treturn vec4(axis*s, c);\n}\n\nvec4 QuatMul(vec4 q, vec4 r)\n{\n\tvec4 nq;\n\tnq.x = q.w * r.x + q.x * r.w + q.y * r.z - q.z * r.y;\n\tnq.y = q.w * r.y - q.x * r.z + q.y * r.w + q.z * r.x;\n\tnq.z = q.w * r.z + q.z * r.w - q.y * r.x + q.x * r.y;\n\tnq.w = q.w * r.w - q.x * r.x - q.y * r.y - q.z * r.z;\n\treturn nq;\n}\n\nmat4 QuatToMat(vec4 q)\n{\n\tfloat xx = q.x * q.x, yy = q.y * q.y, zz = q.z * q.z;\n\tfloat xy = q.x * q.y, yz = q.y * q.z, xz = q.x * q.z;\n\tfloat xw = q.x * q.w, yw = q.y * q.w, zw = q.z * q.w;\n\treturn mat4(1.-2.*(yy+zz),2.*(xy-zw),2.*(xz+yw),0.,2.*(xy+zw),1.-2.*(xx+zz),2.*(yz-xw),0.,2.*(xz-yw),2.*(yz+xw),1.-2.*(xx+yy),0.,0.,0.,0.,1.);\n}\n\nmat3 QuatToMat3(vec4 q)\n{\n\tfloat xx = q.x * q.x, yy = q.y * q.y, zz = q.z * q.z;\n\tfloat xy = q.x * q.y, yz = q.y * q.z, xz = q.x * q.z;\n\tfloat xw = q.x * q.w, yw = q.y * q.w, zw = q.z * q.w;\n\treturn mat3(1.-2.*(yy+zz),2.*(xy-zw),2.*(xz+yw),2.*(xy+zw),1.-2.*(xx+zz),2.*(yz-xw),2.*(xz-yw),2.*(yz+xw),1.-2.*(xx+yy));\n}\n\nmat4 createObjectRotationMatrix(float fAzimuth, float fZenith, float fRoll)\n{\n\tvec4 u = QuatFromAxisAngle(vec3(0., 1., 0.), -fAzimuth);\n\tvec4 v = QuatFromAxisAngle(QuatToMat3(u) * vec3(1., 0., 0.), fZenith);\n\tv = QuatMul(v,u);\n\tvec4 w = QuatFromAxisAngle(QuatToMat3(v) * vec3(0., 0., 1.), -fRoll);\n\treturn QuatToMat(QuatMul(w,v));\n}\n\nmat3 createCameraRotationMatrix(float fU, float fV)\n{\n\tvec4 u = QuatFromAxisAngle(vec3(0., 1., 0.), -fU);\n\tvec4 v = QuatFromAxisAngle(QuatToMat3(u) * vec3(1., 0., 0.), fV);\n\treturn QuatToMat3(QuatMul(u,v));\n}\n\nmat4 translate(vec3 v)\n{\n\treturn mat4(1., 0., 0., 0., 0., 1., 0., 0., 0., 0., 1., 0., v.x, v.y, v.z, 1.);\n}\n\nfloat derivative(vec2 p)\n{\n\tvec2 dx = dFdx(p);\n\tvec2 dy = dFdy(p);\n\tvec2 d = p - floor(p);\n\treturn exp2(-0.31 * min((1. - d.x) * d.x, (1. - d.y) * d.y) / (dot(dx, dy) + dot(dy, dy) + 8e-4));\n}\n\nfloat floorGrid(vec2 p, float od)\n{\n\tvec2 d = p - floor(p);\n\treturn exp2(-0.23 * min((1. - d.x) * d.x, (1. - d.y) * d.y) / clamp(od * -1e-3 + od * od *25e-5,3e-3,1e4));\n}\n\nfloat waveSin(float x, float t)\n{\n\tfloat scalar = sin(x * PI / 8.);\n\tfloat y = sin((x + t * 0.25) * -1.3) * 2.38;\n\ty += sin((x + t * -0.075) * -23.89) * 1.41;\n\ty *= scalar * 0.34;\n\ty += scalar * 3.3;\n\treturn y;\n}\n\nvec3 skyColor(vec3 p)\n{\n\tfloat u = atan(p.z, p.x) + 0.68;\n\tp.x = cos(u);\n\tp.z = abs(sin(u));\n\tvec3 sunPos = vec3(0., 0.0998, 0.995);\n\tfloat h = 0.75 - 0.75 * dot(p, sunPos) * clamp(1. - 3.2*p.y, 0., 1.) * 0.89384734;\n\tfloat w = length(sunPos - p) * 20.;\n\tfloat fSkylar = clamp(1. - w * w * 73e-5, 0., 1.);\n\tvec3 vA = mix(vec3(0.894111, 0.517647, 0.109803), vec3(0.658823, 0.545098, 0.325490) * fSkylar, 4. * (h * 2. - 0.25)) * 0.75;\n\tvec3 vB = vec3(0.25 + 0.278285 * (dot(p, sunPos) + 1.));\n\tvec3 vC = (vA + vB) * 0.5;\n\tfloat l = w * 0.048402;\n\tvec3 z = vec3(1.,2.,3.) * 0.0446 - 0.8;\n\tvec3 sunColor = vec3(0.0028) / ((pow(vec3(0.5) + l + 1.8611 * (cos(0.5 - z)) * abs(sin(l * 8.9583 - z * 2.)), vec3(1.2)) - vec3(0.5)) * l);\n\treturn max(mix(vC, vC * 0.4 + sunColor, length(sunColor) * 1.5) + sunColor, vec3(0.2,0.25,0.4));\n}\n\nvec3 calcSceneColorNonDerivative(in vec3 vCamPos, in vec3 vRayDir)\n{\n\tfloat d = min(-vCamPos.y / min(vRayDir.y, -1e-6), 1e6);\n\tif (vRayDir.y > 0.)\n\t{\n\t\treturn skyColor(vRayDir);\n\t}\n\telse\n\t{\n\t\tvec3 vHitPos = vCamPos + vRayDir * d;\n\t\tfloat vDer = floorGrid(vHitPos.xz, d - acos(vRayDir.y)*d*0.4);\n\t\treturn clamp(mix(skyColor(vec3(vRayDir.x, -vRayDir.y, vRayDir.z)), vec3(1. - vDer), smoothstep(0., -0.2, vRayDir.y)), 0., 1.);\n\t}\n}\n\nvec3 calcSceneColorDerivative(in vec3 vCamPos, in vec3 vRayDir)\n{\n\tfloat d = min(-vCamPos.y / min(vRayDir.y, -1e-6), 1e6);\n\tif (vRayDir.y > 0.)\n\t{\n\t\treturn skyColor(vRayDir);\n\t}\n\telse\n\t{\n\t\tvec3 vHitPos = vCamPos + vRayDir * d;\n\t\tfloat fD = derivative(vHitPos.xz);\n\t\treturn clamp(mix(skyColor(vec3(vRayDir.x, -vRayDir.y, vRayDir.z)), vec3(1. - fD), smoothstep(0., -0.2, vRayDir.y)), 0., 1.);\n\t}\n}\n\nfloat addv(vec2 a)\n{\n\treturn a.x + a.y;\n}\n\nvec2 findQuadricRoots(vec2 coeffs, float a)\n{\n\tfloat p = coeffs.y * 0.5;\n\tfloat D = p * p - coeffs.x;\n\tif (D <= 0.)\n\t{\n\t\treturn vec2(-1.);\n\t}\n\telse\n\t{\n\t\treturn vec2(-1, 1) * sqrt(D) - (p + a * 0.25);\n\t}\n}\n\nfloat findCubicRoot(vec3 a)\n{\n\tfloat p = a.y - a.x*a.x / 3.;\n\tfloat p3 = p*p*p;\n\tfloat q = a.x*(2.*a.x*a.x - 9.*a.y) / 27. + a.z;\n\tfloat d = q*q + 4.*p3 / 27.;\n\tfloat e = -a.x / 3.;\n\tif (d>.0)\n\t{\n\t\tfloat z = sqrt(d);\n\t\tvec2 x = (vec2(z, -z) - q) * 0.5;\n\t\tvec2 uv = sign(x)*pow(abs(x), vec2(1./3.));\n\t\treturn e + uv.x + uv.y;\n\t}\n\tfloat v = acos(-sqrt(-27. / p3)*q*.5) / 3.;\n\treturn (cos(v)*2.) * sqrt(-p/3.) + e;\n}\n\nvec4 findQuarticRoots(vec4 qc)\n{\n\tfloat aa = qc.x*qc.x;\n\tfloat p = -0.375*aa+qc.y;\n\tfloat q = 0.125*aa*qc.x-0.5*qc.x*qc.y+qc.z;\n\tfloat r = -3./256.*aa*aa+1./16.*aa*qc.y-0.25*qc.x*qc.z+qc.w;\n\tfloat z = findCubicRoot(vec3(-0.5*p,-r,0.5*r*p-0.125*q*q));\n\tfloat u = z*z-r;\n\tfloat v = 2.*z-p;\n\tif (u > 0.)\n\t{\n\t\tu = sqrt(u);\n\t}\n\telse\n\t{\n\t\treturn vec4(-1.);\n\t}\n\tif (v > 0.)\n\t{\n\t\tv = sqrt(v);\n\t}\n\telse\n\t{\n\t\treturn vec4(-1.);\n\t}\n\tfloat sQ = sign(q);\n\treturn vec4(findQuadricRoots(vec2(z-u,v*sQ),qc.x),findQuadricRoots(vec2(z+u,v*-sQ),qc.x));\n}\n\nfloat evalQuad(float x, vec3 C)\n{\n\treturn C.z + x * (C.y + x * C.x);\n}\n\nvoid findCylinderNearFar(vec3 ro, vec3 rd, float r, vec2 cy, out float fNear, out float fFar)\n{\n\t// x^2 + z^2 = r^2 => (ro.x + t*rd.x)^2 + (ro.z + t*rd.z)^2 = r^2\n\tfloat fA = dot(rd.xz, rd.xz);\n\tfloat fB = 2. * dot(rd.xz, ro.xz);\n\tfloat fC = dot(ro.xz, ro.xz) - r * r;\n\tfloat fDet = fB * fB - 4. * fA * fC;\n\tif (fDet < 0.)\n\t{\n\t\tfNear = 0.;\n\t\tfFar = -1.;\n\t\treturn;\n\t}\n\tfloat sqrtD = sqrt(fDet);\n\tfloat inv2A = 1. / (2. * fA);\n\tvec2 p = (cy - ro.y) / rd.y;\n\tp += step(rd.y,0.) * (p.yx - p);\n\tfNear = max((-fB - sqrtD) * inv2A, p.x);\n\tfFar = min((-fB + sqrtD) * inv2A, p.y);\n}\n\nvec4 findQuarticMinDistance(vec3 Q, float offset, float fYDirectionDevisor, float cylinderRadius, vec3 rd, vec3 ro)\n{\n\trd.y /= fYDirectionDevisor;\n\tro.y += fYDirectionDevisor * 0.5;\n\tro.y -= offset;\n\tro.y /= fYDirectionDevisor;\n\tfloat near;\n\tfloat far;\n\tfindCylinderNearFar(ro, rd, cylinderRadius + 1e-3, vec2(-1e-3, 1. + 1e-3), near, far);\n\tif (far < 1e-3 || near > far)\n\t{\n\t\treturn vec4(0.,0.,0.,1e5);\n\t}\n\tnear = max(0., near);\n\tro += rd * near;\n\t// Equation solution here: perbloksgaard.dk/research/RayDistanceToBezierCylinder.jpg\n\tfloat A = Q.x * Q.x * rd.y * rd.y * rd.y * rd.y;\n\tfloat B = 2. * Q.x * rd.y * rd.y * rd.y * (2. * Q.x * ro.y + Q.y);\n\tfloat C = rd.y * rd.y * (6. * Q.x * ro.y * (Q.x * ro.y + Q.y) + 2. * Q.x * Q.z + Q.y * Q.y) - rd.x * rd.x - rd.z * rd.z;\n\tfloat D = rd.y * (ro.y * (Q.x * (4. * Q.x * ro.y * ro.y + 6. * Q.y * ro.y + 4. * Q.z) + 2. * Q.y * Q.y) + 2. * Q.y * Q.z) - 2. * (rd.x * ro.x + rd.z * ro.z);\n\tfloat E = ro.y * (Q.x * ro.y * (Q.x * ro.y * ro.y + 2. * Q.y * ro.y + 2. * Q.z) + Q.y * (Q.y * ro.y + 2. * Q.z)) + Q.z * Q.z - ro.x * ro.x - ro.z * ro.z;\n\tvec4 roots = findQuarticRoots(vec4(D, C, B, A) / E);\n\tfloat l = 1. / max(roots.x, max(roots.y, max(roots.z, roots.w)));\n\tif ((l > 1e-3) && l < (far - near))\n\t{\n\t\tvec3 w = ro + rd * l;\n\t\tvec3 q = vec3(normalize(w.xz) * (Q.y + Q.x * w.y * 2.), 1.);\n\t\treturn vec4(vec3(w.x*q.z,-w.x*q.x-w.z*q.y, w.z*q.z), near + l);\n\t}\n\treturn vec4(0.,0.,0.,1e5);\n}\n\nvec3 render(in vec2 uv, float aW[12], float aL[9], float aR[9], float maxGlobalRadius, vec3 vCamPosition, mat3 vCamMat, mat4 txx, mat4 txi)\n{\n\tconst int iC = 9;\n\tconst float fFocalLength = 3.732051;\n\tvec3 totalColorSum = vec3(0.);\n\tvec2 vScreenPixel = vec2(0.5) / vec2(iResolution);\n\tvec3 backGroundColor = calcSceneColorDerivative(vCamPosition, normalize(uv.x * vCamMat[0] + uv.y * vCamMat[1] + fFocalLength * vCamMat[2]));\n\tfor (int iR = 0; iR < 4; iR++)\n\t{\n\t\tint iX = iR / 2;\n\t\tint iY = iR % 2;\n\t\tvec3 rd = normalize((uv.x -vScreenPixel.x + vScreenPixel.x * 2. * float(iX)) * vCamMat[0] + (uv.y -vScreenPixel.y + vScreenPixel.y * 2. * float(iY)) * vCamMat[1] + fFocalLength * vCamMat[2]);\n\t\tvec3 ro = vCamPosition;\n\t\tvec3 lRD = (txi * vec4(rd, 0.)).xyz;\n\t\tvec3 lRO = (txi * vec4(ro, 1.)).xyz;\n\t\tvec3 colorSum = vec3(0.);\n\t\tfloat near, far;\n\t\tfindCylinderNearFar(lRO, lRD, maxGlobalRadius + 1e-3, vec2(-1e-3, float(iC) + 1e-3), near, far);\n\t\tif (far < 1e-3 || near > far)\n\t\t{\n\t\t\treturn backGroundColor;\n\t\t}\n\t\tfloat nearY = lRO.y + lRD.y * near;\n\t\tfloat farY = lRO.y + lRD.y * far;\n\t\tint iVEnd = iC;\n\t\tint iA = 0;\n\t\tint iANear = 0;\n\t\tint iAFar = 0;\n\t\tfloat fOffsetNear = 0.;\n\t\tfloat fOffsetFar = 0.;\n\t\tif (nearY > fOffsetNear)\n\t\t{\n\t\t\tfor (; iANear < 8; iANear++)\n\t\t\t{\n\t\t\t\tif ((fOffsetNear < nearY) && ((fOffsetNear + aL[iANear]) > nearY))\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfOffsetNear += aL[iANear];\n\t\t\t}\n\t\t}\n\t\tif (farY > fOffsetFar)\n\t\t{\n\t\t\tfor (; iAFar < 8; iAFar++)\n\t\t\t{\n\t\t\t\tif ((fOffsetFar < farY) && ((fOffsetFar + aL[iAFar]) > farY))\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfOffsetFar += aL[iAFar];\n\t\t\t}\n\t\t}\n\t\tfloat fInt = 1.;\n\t\tfloat localReflection = 1.0526315;\n\t\tfor (int h = 0; h < 4; h++)\n\t\t{\n\t\t\tvec4 i = vec4(0., 0., 0., 1e3);\n\t\t\tfloat fD = sign(float(iAFar - iANear));\n\t\t\tint dL = int(fD);\n\t\t\tint iAIdx = (fD > 0.) ? 0 : iC - 1;\n\t\t\tfloat fYOffset = (fD > 0.) ? 2e-2 : 2e-2 + float(iC);\n\t\t\tiVEnd = abs(iAFar - iANear) + 1;\n\t\t\tiAIdx = iANear;\n\t\t\tfYOffset = fOffsetNear;\n\t\t\tint iBIdx = iAIdx + 1;\n\t\t\tint iCIdx = iBIdx + 1;\n\t\t\tfor (int iV = 0; iV < iVEnd; iV++)\n\t\t\t{\n\t\t\t\tfloat a = aW[iAIdx];\n\t\t\t\tfloat b = aW[iBIdx];\n\t\t\t\tfloat c = aW[iCIdx];\n\t\t\t\tfYOffset += aL[iAIdx] * 0.5;\n\t\t\t\tvec4 di = findQuarticMinDistance(vec3(a-2.*b+c,-2.*a+2.*b,a+b), fYOffset, aL[iAIdx], aR[iAIdx], lRD, lRO);\n\t\t\t\tif (di.w > 1e-4 && di.w < 1e3)\n\t\t\t\t{\n\t\t\t\t\ti = di;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfYOffset += aL[iAIdx] * 0.5;\n\t\t\t\tif (dL < 0)\n\t\t\t\t{\n\t\t\t\t\tfYOffset -= aL[iAIdx];\n\t\t\t\t}\n\t\t\t\tiAIdx += dL;\n\t\t\t\tiBIdx += dL;\n\t\t\t\tiCIdx += dL;\n\t\t\t\tif (dL < 0)\n\t\t\t\t{\n\t\t\t\t\tfYOffset -= aL[iAIdx];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i.w > 1e2)\n\t\t\t{\n\t\t\t\tif (h == 0)\n\t\t\t\t{\n\t\t\t\t\treturn backGroundColor;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcolorSum += calcSceneColorNonDerivative(ro, rd) * fInt;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvec3 n = (txx * vec4(normalize(i.xyz), 0.)).xyz;\n\t\t\tvec3 posZNormal = faceforward(n, rd, n);\n\t\t\tfloat refac = mix(0.027, 0.77, clamp(pow(1. - dot(rd, -posZNormal), 2.8), 0., 1.));\n\t\t\tro += rd * (i.w + 2e-2) - posZNormal * abs(dot(rd, n) * 2e-2);\n\t\t\tvec3 color = clamp(calcSceneColorNonDerivative(ro, reflect(rd, posZNormal)) * refac * fInt, 0., 1.);\n\t\t\tif (h > 0)\n\t\t\t{\n\t\t\t\tcolor *= (1. + i.w * 9e-2);\n\t\t\t}\n\t\t\tcolorSum += color;\n\t\t\tfInt *= pow(0.36, refac);\n\t\t\trd = refract(rd, posZNormal, localReflection);           \n\t\t\tlRD = (txi * vec4(rd, 0.)).xyz;\n\t\t\tlRO = (txi * vec4(ro, 1.)).xyz;\n\t\t\tlocalReflection = 1.;\n\t\t}\n\t\ttotalColorSum += colorSum;\n\t}\n\treturn totalColorSum * 0.25;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfloat t = iTime + 126.5;\n\tfloat aW[12];\n\tfloat aL[9];\n\tfloat aR[9];\n\taW[1] = (waveSin(0.5, t) + waveSin(1., t))*0.35;\n\taW[0] = -aW[1];\n\tfor (int iWIdx = 2; iWIdx < 10; iWIdx++)\n\t{\n\t\taW[iWIdx] = waveSin(float(iWIdx - 1), t) - aW[iWIdx - 1];\n\t}\n\taW[9] = -aW[8] + aW[7] * 0.5;\n\taW[10] = -aW[9];\n\taW[11] = 0.0;\n\tfloat fSin;\n\taL[4] = 1.;\n\tfSin = sin(t*-1.5 + pow(0.4, 0.3)) * pow(0.4, 0.25);\n\taL[3] = 1. + fSin;\n\taL[5] = 1. - fSin;\n\tfSin = sin(t*-1.5 + pow(0.4, 0.3*2.)) * pow(0.4, 0.25*2.);\n\taL[2] = 1. + fSin;\n\taL[6] = 1. - fSin;\n\tfSin = sin(t*-1.5 + pow(0.4, 0.3*3.)) * pow(0.4, 0.25*3.);\n\taL[1] = 1. + fSin;\n\taL[7] = 1. - fSin;\n\tfSin = sin(t*-1.5 + pow(0.4, 0.3*4.)) * pow(0.4, 0.25*4.);\n\taL[0] = 1. + fSin;\n\taL[8] = 1. - fSin;\n\tfloat maxGlobalRadius = 0.;\n\tfor (int iR = 0; iR < 9; iR++)\n\t{\n\t\tfloat a = aW[iR];\n\t\tfloat b = aW[iR + 1];\n\t\tfloat c = aW[iR + 2];\n\t\tvec3 Q = vec3(a - 2.*b + c, -2.*a + 2.*b, a + b);\n\t\tfloat maxRadius = max(evalQuad(clamp(-Q.y / (2.*Q.x), 0., 1.), Q), max(evalQuad(0., Q), evalQuad(1., Q)));\n\t\tmaxGlobalRadius = max(maxGlobalRadius, maxRadius);\n\t\taR[iR] = maxRadius;\n\t}\n\tmat4 qM = createObjectRotationMatrix(sin(t*1e-2)*1e-2,sin(t*0.37)*0.45-4.67,sin(t*0.25)*0.9+1.1);\n\tvec3 vObjPos = vec3(cos(0.8)*t*-2.1, 5.63, sin(0.8)*t*-2.1);\n\tvec3 vObjCenter = vec3(0., 4.5, 0.);\n\tmat4 txi = translate(vObjCenter) * qM * translate(-vObjPos);\n\tmat4 txx = inverse(txi);\n\tmat3 vCamMat = createCameraRotationMatrix(-cos(t*0.11)*0.25+9.87, sin(-t*0.31)*0.16-0.007158);\n\tmat3 iQM = inverse(mat3(qM));\n\tvec3 vCamPosition = vObjPos - vCamMat[2] * (17. - cos(t * 0.4) * 7.);\n\tvCamPosition.xz += iQM[1].xz * (dot(vObjPos - vCamPosition, iQM[1]) / dot(iQM[1], iQM[1])) * 0.6;\n    vec2 s = (-iResolution.xy+2.*gl_FragCoord.xy)/iResolution.y;\n\tfragColor = vec4(render(s, aW, aL, aR, maxGlobalRadius, vCamPosition, vCamMat, txx, txi),1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftsGz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[109, 109, 157, 157, 249], [251, 251, 281, 281, 525], [527, 527, 551, 551, 862], [864, 864, 889, 889, 1179], [1181, 1181, 1258, 1258, 1513], [1515, 1515, 1568, 1568, 1723], [1725, 1725, 1749, 1749, 1832], [1834, 1834, 1860, 1860, 2026], [2028, 2028, 2063, 2063, 2198], [2200, 2200, 2233, 2233, 2412], [2414, 2414, 2437, 2437, 3239], [3241, 3241, 3309, 3309, 3669], [3671, 3671, 3736, 3736, 4066], [4068, 4068, 4088, 4088, 4109], [4111, 4111, 4156, 4156, 4315], [4317, 4317, 4346, 4346, 4730], [4732, 4732, 4764, 4764, 5266], [5268, 5268, 5301, 5301, 5338], [5340, 5340, 5435, 5502, 5913], [5915, 5915, 6032, 6032, 7349], [7351, 7351, 7492, 7492, 10762], [10764, 10764, 10819, 10819, 12664]], "test": "error"}
{"id": "ftsGzH", "name": "More efficient snow example", "author": "onlinerocker", "description": "A more efficient screen-space snow effect.\nFrom: https://onlinerocker.github.io/snow_effect/", "tags": ["snow"], "likes": 0, "viewed": 119, "published": "Public", "date": "1621545087", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//change this to modify the number of particles\n#define TILES 10.0\n\n//2D random from https://www.shadertoy.com/view/WstGDj\nfloat random (vec2 uv) {\n    return fract(sin(dot(uv, vec2(135., 263.))) * 103.214532);\n}\n\nvec4 drawSnow(vec2 curid, vec2 uv, vec4 fragColor, float r, float c)\n{\n    float maxoff = 2.0 / TILES; //calculate the max offset a particle can have (two tiles)\n\n    //loop through neighboring tiles\n    for(int x=-2; x<=1; x++)\n    {\n        for(int y=-2; y<=0; y++)\n        {\n            float rad = (1.0 / (TILES * 5.0)) * r; //set default radius\n            vec2 id = curid + vec2(x, y); //get the id of the tile we're visiting\n            vec2 pos = id / TILES; //calculate position\n            float xmod = mod(random(pos), maxoff);\n            pos.x += xmod; //add a random x-offset\n            pos.y += mod(random(pos+vec2(4,3)), maxoff); //add a random y-offset\n            rad *= mod(random(pos), 1.0); //vary the radius by multiplying by a random val\n            pos.x += 0.5*(maxoff-xmod)*sin(iTime*r + random(pos)*100.0); //dynamic sin wave x-offset\n            \n            float len = length(uv - pos); //calculate distance from tile's particle\n\n            //if we're inside the particle, draw it\n            float v = smoothstep(0.0, 1.0, (rad - len) / rad*0.75);\n            fragColor = mix(fragColor, vec4(c), v);      \n        }\n    }\n    \n    return fragColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 bg = vec4(.529, .808, .922, 1) * 0.25;\n    vec2 uvNorm = fragCoord.xy / iResolution.xy; //normalized UV coordinate [0, 1]\n    vec2 uvog = fragCoord.xy / iResolution.y; //UV coordinate (will remain static)\n    vec2 uv = fragCoord.xy / iResolution.y; //UV coordinate (we'll modify this one)\n    \n    //draw the closest snow layer\n    uv += 0.2*vec2(-iTime, iTime); //move the UV coords based on time\n    vec2 curid = floor(uv * TILES); //calculate the ID associated with the current UV\n    curid += vec2(0.5); //center the ID\n    \n    //agColor = bg; //set background color\n    fragColor = drawSnow(curid, uv, fragColor, 1.0, 0.9); //draw closest snow layer\n    \n    //draw the middle snow layer, calculate new UV and ID\n    uv = uvog + 0.1*vec2(-iTime - 100.0, iTime + 100.0);\n    curid = floor(uv * TILES);\n    curid += vec2(0.5);\n    fragColor += drawSnow(curid, uv, vec4(0), 0.75, 0.45); \n    \n    //draw the far snow layer, calculate new UV and ID\n    uv = uvog + 0.05*vec2(-iTime - 150.0, iTime + 150.0);\n    curid = floor(uv * TILES);\n    curid += vec2(0.5);\n    fragColor += drawSnow(curid, uv, vec4(0), 0.5, 0.225);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftsGzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 123, 147, 147, 212], [214, 214, 284, 284, 1397], [1399, 1399, 1456, 1456, 2590]], "test": "valid"}
{"id": "ftX3DN", "name": "Green Screen and Color Matching", "author": "milesWaugh", "description": "Just an attempt at green-screening this guy, haha", "tags": ["greenscreen"], "likes": 4, "viewed": 179, "published": "Public API", "date": "1622063117", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.xy;\n    float sl = uv.y*.25-uv.x + iTime*.1;\n    float slc = 1./6.;\n    float sl2 = fract(sl*5.);\n    sl = fract(sl);\n    vec3 g = vec3(0.15,0.63,0.2);\n    vec3 col = textureLod(iChannel0,uv,0.).rgb;\n    float a = 1.-dot(col-g,col-g)*5.;\n    a = smoothstep(0.,1.,clamp(a,0.,1.));\n    if(sl>slc){\n        col = mix(col,vec3(0.),a);\n    }\n    if(sl>slc&&sl<1.75*slc){\n        col = vec3(a);\n    }\n    if(abs(sl-slc)<0.02){\n        col = g;\n    }\n    float a2 = (((col.r+col.b)*.5-col.g)+0.15)*5.;\n    vec3 gr = vec3(col.r+col.g+col.b)/3.;\n    a2 = smoothstep(0.,1.,a2);\n    gr *= vec3(1.,0.85,0.55);\n    if(sl>3.75*slc){\n        col = mix(gr,col,a2)*pow(clamp(a2+.05,0.,1.),0.1);\n    }\n    if(sl>3.*slc&&sl<3.75*slc){\n        col = vec3((((col.r+col.b)*.5-col.g)+0.15)*5.);\n    }\n    col*=smoothstep(0.,1.,abs(fract(sl-0.5)-slc*0.05-0.5)*150.-1.);\n    float xt = fract(uv.x-iTime*.1);\n    if(abs(xt-0.14)<0.008 && abs(uv.y-0.88)<0.08){\n        col = vec3(1.,.6,.8);\n    }\n    if((abs(fract(xt+0.008))-0.008<0.008||abs(xt-0.97)<0.008) && abs(uv.y-0.88)<0.08){\n        col = vec3(0.1,0.2,0.5);\n    }\n    if((abs(xt-0.86)<0.008||abs(xt-0.82)<0.008||abs(xt-0.78)<0.008) && abs(uv.y-0.88)<0.08){\n        col = vec3(1.,.75,.4);\n    }\n    if(abs((-abs(xt-0.685)+(uv.y+0.01)*.2)-0.17)<0.008&&uv.y<.96||abs(xt-0.64)<0.008 && abs(uv.y-0.88)<0.08){\n        col = vec3(.1,.5,.5);\n    }\n    if(abs((-abs(xt-0.4)+(uv.y+0.01)*.2)-0.17)<0.008&&uv.y<.96){\n        col = vec3(0.7,1.,.7);\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XdfGRr", "previewfilepath": "/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftX3DN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 1599]], "test": "error"}
{"id": "ftX3R8", "name": "neon circuit by it7c", "author": "jorge2017a1", "description": "neon circuit by it7c", "tags": ["neoncircuitbyit7c"], "likes": 7, "viewed": 107, "published": "Public", "date": "1621474058", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// neon circuit by it7c \n\nconst float PI  = 3.141592653589793;\nconst float PI2 = PI* 2.;\n\n#define saturate(x) clamp(x,0.,1.)\n\nfloat tri(float x){return abs(2.*fract(x*.5-.25)-1.)*2.-1.;}\nfloat sqr(float x){return -2.*(step(.5,fract(x*.5))-.5);}\nfloat circuit(float x){return clamp(tri(x*4.)*.25,(sqr(x)-1.)*.5,(sqr(x+.5)+1.)*.5);}\nfloat circuit2(float x){return clamp(tri(x*.5)*.5,0.,.25);}\nfloat flow(float x,float d){return (1.+sin(x+d*iTime*5.+3.))*.3+.3;}\nvec2 pp(vec2 p){float r=.5/p.y;return vec2(p.x*r, r);}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n float t=floor(iTime*30.)/15.;\n vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n float l=0.,d=sign(p.y);\n vec2 r = p;\n vec2 q = p;\n q=pp(q);\n float n = floor(q.x/.5);\n q.x=mod(q.x,.5)-.25;\n p=pp(p);\n l+=step(abs(q.x+circuit(q.y+sign(p.y)*t+n)),.005);\n l+=pow(.001/abs(p.x+circuit(p.y+d*t)),flow(p.y,d));\n l+=pow(.001/abs(p.x+.75+circuit2(p.y+d*t)),(1.+sin(p.y+d*iTime*5.))*.3+.3);\n l+=pow(.001/abs(p.x-.75+circuit2(p.y+d*t)),(1.+sin(p.y+d*iTime*5.))*.3+.3);\n l=saturate(l);\n l*=abs(r.y*2.);\n l*=abs(sin(r.y*200.+sign(p.y)*iTime*5.))*.5+.5;\n l+=pow(.001/abs(p.x+circuit(p.x+d*iTime)),(1.+sin(p.x+d*iTime*5.+3.))*.3+.3);\n fragColor = vec4(vec3(l)-vec3(.3,.1,0.), 1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftX3R8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[126, 126, 145, 145, 186], [187, 187, 206, 206, 244], [245, 245, 268, 268, 330], [331, 331, 355, 355, 390], [391, 391, 419, 419, 459], [460, 460, 476, 476, 514], [517, 517, 574, 574, 1279]], "test": "valid"}
{"id": "ftX3zH", "name": "3D Raymarcher", "author": "Bababoi", "description": "its A Technique Where You March A Ray", "tags": ["raymarch", "render"], "likes": 1, "viewed": 45, "published": "Public", "date": "1621496610", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n\nfloat GetDist(vec3 p) {\n    float d = sdBox(p - vec3(0,1,0), vec3(1));\n    float d1 = sdOctahedron(p - vec3(0,1,0), 1.);\n    float d2 = sdPlane(p, vec3(0,1,0), 0.);\n    \n    float c1 = mix(d, d1, sin(iTime)*.5+.5);\n    return min(c1, d2);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 4, -3);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = vec3(dif);\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftX3zH.jpg", "access": "shaders20k", "license": "mit", "functions": [[1475, 1475, 1494, 1494, 1556], [1558, 1558, 1600, 1626, 1651], [1653, 1653, 1691, 1691, 1971], [1973, 1973, 2002, 2002, 2083], [2086, 2086, 2109, 2109, 2326], [2328, 2328, 2362, 2362, 2573], [2575, 2575, 2599, 2599, 2789], [2791, 2791, 2841, 2841, 3032], [3034, 3034, 3091, 3091, 3698]], "test": "valid"}
{"id": "ftXGRn", "name": "Shifting Mandelbrot Julia Grid", "author": "Symbroson", "description": "Random \"pattern\" I've found while writing a julia grid shader.\n", "tags": ["grid", "juliaset", "mandelbrotset"], "likes": 3, "viewed": 46, "published": "Public", "date": "1621358239", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define PI 3.1415926\n#define R (iResolution.xy)\n#define A fragCoord\n#define WALL 40.\n\n#define GRID_RDENS 1.5  // .3 1.5 ...\n#define GRIDW (R.x/GRID_RDENS)\n#define GRIDH (GRIDW*R.y/R.x)\n\n#define ZOOMF 2.\n#define ZOOMT 1.\n#define ZOOMO 1.2\n\n#define RTIMEF 5.\n#define ROTT 20.\n#define ROTD 10.\n\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1, 2.0/3.0, 1.0/3.0, 3);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0., 1.), c.y);\n}\n\nvec2 powC2(vec2 z) {\n    return vec2(z.x*z.x - z.y*z.y, 2.*z.x*z.y);\n}\n\n// 2d point rotation\nvec2 rotate(vec2 pos, vec2 center, float angle)\n{\n    pos -= center;\n    float x = pos.x * cos(angle) - pos.y * sin(angle);\n    float y = pos.y * cos(angle) + pos.x * sin(angle);\n    return vec2(x, y) + center;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // constants\n    float t = iTime / RTIMEF;\n    vec2 f = vec2(GRIDW, GRIDH);\n    vec2 k = vec2(-.17, 0); // move set grid\n \n    float scale = (1. + sin(t/ZOOMT)) * ZOOMF + ZOOMO;\n    vec2 v = .8 * vec2(cos(20. * t/41.), sin(20. * t/23.));\n\n    /*/ // set\n    vec2 z = (A/R - 0.5) * scale;\n    vec2 p = .7 * vec2(cos(SHIFTF * t/SHIFTX), sin(SHIFTF * t/SHIFTY));\n    /*/ // grid\n    vec2 z = (mod(f*A, R)/R - 0.5) * scale;\n    vec2 p = f*(A/R - 0.5)+ vec2(-0.5);\n    p = (floor(p)/f + k + v/ROTD) * scale;\n    //*/\n\n    z.y *= f.x*R.y / (f.y*R.x);\n    z = rotate(z, vec2(0), PI*iTime/ROTT);\n\n    // p marker\n    vec2 d = (A - (1. - v) * R / 2.);\n    if(d.x*d.x + d.y*d.y < 9.) {\n        fragColor= vec4(1.,0.,0.,1.);\n        return;\n    }\n    \n    float i;\n    for(i = 0.; i < WALL; i++)\n    {\n        z = powC2(z) + p;\n        if(z.x*z.x + z.y*z.y >= 10.) break;\n    }\n    \n    // rotate hue without converting to hsb first has some mystical effect\n    vec3 c = vec3(iTime / 50., float(i) / WALL, sin(4. * float(i) / WALL));\n    fragColor= vec4(hsv2rgb(c),1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftXGRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[294, 294, 316, 316, 475], [477, 477, 497, 497, 547], [549, 570, 619, 619, 782], [785, 785, 842, 859, 1907]], "test": "valid"}
{"id": "ftXGWH", "name": "pattern 02", "author": "gunzes", "description": "a pattern", "tags": ["pattern"], "likes": 0, "viewed": 29, "published": "Public", "date": "1621973914", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float square (float size,float feather,vec2 uv)\n{\n    float axis1 = smoothstep(-feather,-size,uv.x)*smoothstep(feather,size,uv.x);\n    float axis2 = smoothstep(-feather,-size,uv.y)*smoothstep(feather,size,uv.y);\n    return axis1*axis2;\n}\nfloat rTime(float rTmin,float rTmax,float speed,float phase)\n{\n    float rsTime = (sin(iTime*speed+phase)+1.)/2.;\n    return mix(rTmin,rTmax,rsTime);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.x-.5;\n    uv.y+=0.225;\n    vec2 zv = uv*1000.;\n    uv*=50.;\n//uv = vec2(pow(uv.x,1.2),pow(uv.y,1.2));\n\n    vec2 gv = uv;\n    vec2 vv = uv;\n    zv.x = clamp(abs(sin(zv.y))*1.2,0.,1.);\n    //zv.x = pow(zv.x,0.98);\nzv.x *= -.1;\n\n    vv.x *= -1.;\n    \n    float phase = 0.0;\n    vec3 col = vec3(zv.x,0.,0.);\n\n    //small square number\n    int nSquare = 8;\n    float xOffset = 5.;\n    for(int y=-3;y<=3;y++)\n    {\n\n    phase += 0.35;\n\n    col *= vec3(1.,rTime(.7,1.,.5,phase*.1),rTime(.7,1.,.5,phase*.1));\n    \n        //draw the small pattern\n        for (int i=-nSquare;i<=nSquare;i++)\n        {\n        phase += .95;\n        vec2 offset = (vec2(float(i)+float(y)*xOffset,float(i)+0.));\n        //draw the square \n        //col += (1.-square(.6,.8,gv+offset))*square(.5,rTime(.9,2.,3.,phase),gv+offset);\n        //col += (1.-square(.6,.8,vv+offset))*square(.5,rTime(.9,2.,3.,phase),vv+offset);\n        \n\n        col += square(.85,rTime(.9,1.9,.5,phase+.6),gv+offset);\n        col += square(.85,rTime(.9,1.9,.5,phase+.2),vv+offset);\n        col -= square(.8,rTime(.85,1.,2.,phase+0.1),gv+offset);\n        col -= square(.8,rTime(.85,1.,1.,phase+.45),vv+offset);\n        \n        col *= 1.;\n\n        \n        }\n\n    }   col *= vec3(1.,rTime(.2,1.,.5,phase*5.),rTime(0.,1.,1.,phase*5.5));\n    \n   \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftXGWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 49, 49, 237], [238, 238, 300, 300, 389], [390, 390, 447, 497, 1881]], "test": "valid"}
{"id": "ftXGzH", "name": "rotate fanshaped", "author": "vanky", "description": "中心旋转", "tags": ["2d", "rotate", "sector"], "likes": 0, "viewed": 129, "published": "Public API", "date": "1621495874", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI=3.141592653589793;\n\n\nconst vec2 center = vec2(0.5,0.5);\nconst vec4 lineColor = vec4(0.900,0.799,0.746,1.000);\nconst vec4 backgroundColor = vec4(0.568,0.665,0.265,1.000);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // 定时旋转\n    mat2 rotate=mat2(cos(iTime),sin(iTime),-sin(iTime),cos(iTime));\n    \n    float delat=PI/20.;\n    \n    // 构建纹理中心点为原点的UV坐标\n    vec2 dist = center-uv;\n    // 二维旋转\n    dist=rotate * dist;\n    if (fract(atan(dist.y,dist.x)/ delat) < 0.180) {\n        fragColor = lineColor;\n    } else {\n       fragColor = backgroundColor;\n       // discard;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftXGzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[186, 186, 243, 293, 736]], "test": "valid"}
{"id": "MtfGzn", "name": "SphereMiner", "author": "bloodnok", "description": "An experiment in negative spaces.", "tags": ["raymarched"], "likes": 8, "viewed": 200, "published": "Public API", "date": "1622109209", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\tPinching noise and basic raymarching setup from Octavio Good: https://www.shadertoy.com/view/4dSXDd\n*/\n\n// noise functions\nfloat Hash1d(float u)\n{\n    return fract(sin(u)*143.9);\t// scale this down to kill the jitters\n}\nfloat Hash2d(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\nfloat Hash3d(vec3 uv)\n{\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\n    return fract(sin(f)*110003.9);\n}\nfloat mixP(float f0, float f1, float a)\n{\n    return mix(f0, f1, a*a*(3.0-2.0*a));\n}\nconst vec2 zeroOne = vec2(0.0, 1.0);\nfloat noise2d(vec2 uv)\n{\n    vec2 fr = fract(uv.xy);\n    vec2 fl = floor(uv.xy);\n    float h00 = Hash2d(fl);\n    float h10 = Hash2d(fl + zeroOne.yx);\n    float h01 = Hash2d(fl + zeroOne);\n    float h11 = Hash2d(fl + zeroOne.yy);\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\n}\nfloat noise(vec3 uv)\n{\n    vec3 fr = fract(uv.xyz);\n    vec3 fl = floor(uv.xyz);\n    float h000 = Hash3d(fl);\n    float h100 = Hash3d(fl + zeroOne.yxx);\n    float h010 = Hash3d(fl + zeroOne.xyx);\n    float h110 = Hash3d(fl + zeroOne.yyx);\n    float h001 = Hash3d(fl + zeroOne.xxy);\n    float h101 = Hash3d(fl + zeroOne.yxy);\n    float h011 = Hash3d(fl + zeroOne.xyy);\n    float h111 = Hash3d(fl + zeroOne.yyy);\n    return mixP(\n        mixP(mixP(h000, h100, fr.x),\n             mixP(h010, h110, fr.x), fr.y),\n        mixP(mixP(h001, h101, fr.x),\n             mixP(h011, h111, fr.x), fr.y)\n        , fr.z);\n}\n\nvec3 noise3(vec3 uv)\n{\n    return vec3(\n        noise(uv),\n        noise(uv.yzx + vec3(35.654,135.7,17.2)),\n        noise(uv.zxy + vec3(19.7,39.7,117.7))\n        );\n}\n\nfloat PI=3.14159265;\n\n\nfloat sdSphere( vec3 p, float s )\n{\n\treturn length(p)-s;\n}\nfloat sdInvSphere( vec3 p, float s )\n{\n\treturn -sdSphere(p,s);\n}\nfloat sdqSphere( vec3 p, float ss )\n{\n\treturn dot(p,p)-ss;\n}\n\nvec2 opS( vec2 d1, vec2 d2 )\n{\n    //vec2 d3 = vec2(-d2.x,d2.y);\n    //return max(-d2,d1);\n    return (-d1.x > d2.x) ? vec2(-d1.x,d1.y) : d2;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n\nvec2 distanceToScene(vec3 p)\n{\n    /*\n\tfloat t = sdSphere(p - vec3(0.0), 0.1);\n    t = min(t,sdSphere(p - vec3(0.3), 0.5));\n    t = min(t,sdSphere(p - vec3(-0.1), 0.2));\n    t = min(t,sdSphere(p - vec3(0.0,0.2,-0.2), 0.3));\n    t = min(t,sdSphere(p - vec3(0.1,0.0,-0.5), 0.5));\n    t = t - noise(p*50.0) * 0.01;\n*/\n  \n    vec2 res = vec2(10000.0,0.0);\n    \n//    float t = 10000.0;//sdSphere(p - vec3(0.0), 0.1);\n    \n    \n    for(float i=-0.5;i<5.0;i+=0.9)\n    {\n        res = opU(res,vec2(sdSphere(p - vec3(0.0,-0.05,i), 0.5),1.0));\n        \n        res = opU(res,vec2(sdSphere(p - vec3(-0.5,-0.05,i), 0.1),0.9));\n        res = opU(res,vec2(sdSphere(p - vec3(0.5,-0.05,i), 0.1),0.9));\n    }\n    \n    //t = sqrt(t);\n    //if (camDist<5.0){\n    \n    float ns = 10.0, na = 0.02;\n    float n = 0.0;\n    n += noise(p*ns) * na; ns *= 2.0; na *= 0.5;\n    n += noise(p*ns) * na; ns *= 2.0; na *= 0.5;\n    n += noise(p*ns) * na; ns *= 2.0; na *= 0.5;\n    n += noise(p*ns) * na; ns *= 2.0; na *= 0.5;\n    \n    res.x-=n;\n    \n        //t = t - noise(p*20.0) * 0.02;\n        //t = t - noise(p*40.0) * 0.01;\n        //t = t - noise(p*80.0) * 0.005;\n    \t//t = t - noise(p*200.0) * 0.001;\n    //}\n    \n    //return t;\n    return opS(res,vec2(sdSphere(p - vec3(0.0,0.0,-0.5), 50.0),0.0));\n}\n\n//float distanceToScene(vec3 p)\n//{\n//    return distanceToScene(p,0.0).x;\n//}\n    \nvec3 getNormal(vec3 p, float dist)\n{\n    vec3 e = vec3(0.0025, 0, 0);\n    return normalize(vec3(dist - distanceToScene(p - e.xyy).x,\n                        dist - distanceToScene(p - e.yxy).x,\n                        dist - distanceToScene(p - e.yyx).x));\n}\n\nfloat shadowMarch(vec3 p0, vec3 d)\n{\n    vec3 p;\n    float s = 1.0;\n    float t = 0.0;\n    \n    for(int i=0;i<16;i++)\n    {\n        p = p0 + d * t;\n        float dist = distanceToScene(p).x;\n        \n        //s *= (1.0 - smoothstep(0.001,0.002,dist)*0.8);\n       \n        t += max(dist,0.1);\n        //s *= 1.0 - clamp(abs(dist),0.0,1.0);\n        \n        //if (s<0.01) break;\n        //if (abs(dist)<0.001) break;\n            \n        \n        //t+=0.1;\n        //if (s<0.001) break;\n        //p = p0 + d * t * 0.05;\n        //float dist= distanceToScene(p);\n        //s *= (1.0 - smoothstep(0.0,0.001,dist)*0.5);\n\t\t\n    }\n    \n    return s;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = distanceToScene( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.025, 0.20 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 tempToColour(float t)\n{\n    return vec3(\n        smoothstep(500.0,2000.0,t) * 0.95,\n        smoothstep(900.0,5000.0,t),\n        smoothstep(2000.0,10000.0,t)\n       )*4.0;\n}\n\nfloat OrenNayar(float roughness, float albedo, vec3 rd, vec3 nor, vec3 light)\n{\n    // oren-nayar\n    //float roughness = 0.5;\n    //float albedo = 1.0;\n    float roughness2 = roughness*roughness;\n    float onA = 1.0 - 0.5 * (roughness / (roughness+0.57));\n    float onB = 0.45 * (roughness / (roughness+0.09));\n\n    float ndotl = dot(nor,light);\n    float ndotv = dot(nor,-rd);\n\n    float ai = acos(ndotl);\n    float ar = acos(ndotv);\n\n    float onAlpha = max(ai,ar);\n    float onBeta = min(ai,ar);\n    float onGamma = dot(-rd - nor * dot(-rd,nor),light - nor * dot(light,nor)); // ?\n\n    return (albedo / 3.1415927) * max(0.0,dot(nor,light)) * (onA + (onB * max(0.0,onGamma) * sin(onAlpha) * tan(onBeta)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 lightV = normalize(vec3(-1.0,0.8,0.0));\n    vec3 lightC = vec3(0.85,0.9,1.0) * 0.05;\n    vec3 camLightC = vec3(0.95,0.92,0.8) * 0.5;\n    \n    vec2 muv = iMouse.xy / iResolution.xy * 2.0 - 1.0;\n    \n\tvec3 camPos = vec3(0.0,0.0,1.5+sin(iTime * 0.1) * 2.0);\n    //vec3 camFacing;\n\tvec3 camUp=vec3(0.0,1.0,0.0);\n\tvec3 camLookat=vec3(muv.x*4.0,muv.y*4.0,camPos.z + 1.0);\n    \n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\n\n\t// Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\n\tvec3 upNorm=cross(camVec, sideNorm);\n\tvec3 worldFacing=(camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * 0.8 * sideNorm * (iResolution.x/iResolution.y) + uv.y * 0.8 * upNorm;\n\tvec3 relVec = normalize(worldPix - camPos);\n    \n    \n    // material parameters\n    vec3 emmissive = vec3(0.0);\n    vec3 albedo = vec3(0.0);\n    float specexp = 30.0;\n    float spec = 0.0;\n    float roughness = 0.0;\n    \n    \n    // Raymarch\n    float t = 0.0;\n    vec2 dist = vec2(0.1,0.0);\n    float distMax = 20.0;\n    vec3 p = vec3(0.0);\n    \n    for(int i=0;i<64;i++)\n    {\n        if ((dist.x > distMax) || (abs(dist.x) < 0.001)) break;\n        \n        p = camPos + relVec * t*0.95;\n        dist = distanceToScene(p);\n        t += dist.x;//*0.9999;\n    }\n    \n    vec3 nor = getNormal(p,dist.x);\n\n    // material\n    if (dist.y>0.95)\n    {\n        vec3 n3 = noise3(p * 400.0);\n        \n        albedo = vec3(0.3) + n3 * vec3(0.05,0.07,0.1);\n        roughness = 0.9;\n        \n        nor = normalize(nor + (n3 - 0.5) * 0.2);\n        \n        float sn = noise(p*vec3(0.5,9.0,9.0)) + noise(p*30.0) * 0.05;\n        //spec = (smoothstep(0.9,0.92,sn) * (1.0-smoothstep(0.95,0.97,sn))) * smoothstep(0.5,0.7,noise(p*3.0));\n        spec = smoothstep(0.99,0.992,sn);\n        \n        spec += smoothstep(0.7,0.95,noise(p * 15.0)) * 0.05;\n        \n        albedo *= (1.0-spec*0.5); \n        roughness *= (1.0-spec);\n    }\n    else if (dist.y > 0.85)\n    {\n        float temperature = \n            500.0 + \n            smoothstep(0.0,1.0,noise(p*3.0)) * 300.0 + \n            //smoothstep(0.6,1.0,noise(p*40.0)) * 950.0 + \n            smoothstep(0.7,1.0,noise(p*40.0)) * 3000.0;\n        temperature *= abs(sin(iTime * 0.05));\n        emmissive = tempToColour(temperature);\n        albedo = vec3(0.3);\n    }\n    \n    vec3 col = vec3(0.0);\n    //vec3 diffuse = vec3(0.2);\n    \n    // hit\n    if (abs(dist.x) < 0.1)\n    {\n        \n        // diffuse\n        col = albedo * clamp(dot(nor,lightV),0.0,1.0) * lightC;\n        \n        // camera light\n        vec3 camLightV = (camPos-p + vec3(0.1,-0.22,-0.1));\n        float camLightPower = 1.0 / dot(camLightV,camLightV);\n        camLightV = normalize(camLightV);\n        //camLightPower *= shadowMarch(p,-camLightV);\n        //camLightPower *= (softshadow(p,camLightV,0.02, 0.5));\n        \n        float diffuse = OrenNayar(1.0, 1.0, relVec, nor, camLightV);\n        \n        col += albedo * clamp(diffuse,0.0,1.0) * camLightC * camLightPower;\n        \n        // specular\n        vec3 refl = reflect(relVec,nor);\n        col += spec * pow(clamp(dot(refl,camLightV),0.0,1.0),specexp) * camLightC * camLightPower;\n        \n        // emmissive\n        col += emmissive;\n        \n        //col = nor * 0.5 + 0.5;\n    }\n\n    float fog = 1.0 - 1.0 / exp(  t * 0.9);\n    \n    \n    col = mix(col,vec3(0.0),fog);\n    fog = max(0.0,fog-0.2);\n    col = mix(col,vec3(0.6,0.8,1.0)*0.1,fog*fog);\n\n    \n    // gamma\n    col = pow(col,vec3(0.4545));\n\n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtfGzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[108, 127, 150, 150, 223], [224, 224, 247, 247, 318], [319, 319, 342, 342, 428], [429, 429, 470, 470, 513], [551, 551, 575, 575, 848], [849, 849, 871, 871, 1456], [1458, 1458, 1480, 1480, 1624], [1649, 1649, 1684, 1684, 1707], [1708, 1708, 1746, 1746, 1772], [1773, 1773, 1810, 1810, 1833], [1835, 1835, 1865, 1925, 1978], [1980, 1980, 2010, 2010, 2043], [2046, 2046, 2076, 2360, 3323], [3409, 3409, 3445, 3445, 3667], [3669, 3669, 3705, 3705, 4314], [4316, 4316, 4390, 4390, 4664], [4666, 4666, 4694, 4694, 4843], [4845, 4845, 4924, 4997, 5555], [5557, 5557, 5614, 5614, 9156]], "test": "valid"}
{"id": "Nd2GRc", "name": "New York City VI (torso)", "author": "shau", "description": "trying to emulate H.R. Giger (kind of)\n[url]https://wikioo.org/paintings.php?refarticle=A25TAE&titlepainting=hr%20giger%20newyorkcity%20VI%20torso&artistname=H.R.%20Giger[/url]", "tags": ["3d", "reproduction", "giger"], "likes": 17, "viewed": 190, "published": "Public", "date": "1619878101", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by SHAU - 2021\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define R iResolution.xy\n#define ZERO (min(iFrame,0))\n#define EPS 0.001\n#define FAR 100.0\n#define T iTime\n\n#define BODY 1.0\n#define HELMET 2.0\n#define METAL 3.0\n#define WALL 4.0\n#define WIRE 5.0\n\n//Fabrice - compact rotation\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\n\n//Dave Hoskins - hash without sin\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//Shane IQ\nfloat n3D(vec3 p) {    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); \n    p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p * p * (3. - 2. * p);\n    h = mix(fract(sin(h) * 43758.5453), fract(sin(h + s.x) * 43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\n//Distance functions IQ\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat smax(float a, float b, float k) {\n\tfloat h = clamp( 0.5 + 0.5 * (b - a) / k, 0.0, 1.0 );\n\treturn mix(a, b, h) + k * h * (1.0 - h);\n}\n\nvec3 opRepLim(vec3 p, float c, vec3 l)\n{\n    return p-c*clamp(round(p/c),-l,l);\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCapsule(vec3 p, float h, float r)\n{\n    p.x -= clamp(p.x,0.0,h);\n    return length(p) - r;\n}\n\nfloat sdTorus(vec3 p, vec2 t) \n{\n    vec2 q = vec2(length(p.yz) - t.x, p.x);\n    return length(q) - t.y;\n}\n\nfloat sdEllipsoid(vec3 p, vec3 r)\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat dot2(vec3 v) { return dot(v,v); }\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\n//A useful little function from IQ\n//http://www.iquilezles.org/www/articles/functions/functions.htm\nfloat almostIdentity(float x, float m, float n) {\n    if (x > m) return x;\n    float a = 2.0 * n - m;\n    float b = 2.0 * m - 3.0 * n;\n    float t = x / m;\n    return (a * t + b) * t * t + n;\n}\n\nfloat boxIntersection(vec3 ro, vec3 rd, vec3 boxSize) \n{\n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return -1.0; // no intersection\n    return tN;\n}\n\nvec2 near(vec2 a, vec2 b)\n{\n    return mix(a,b,step(b.x,a.x));\n}\n\nfloat SXY(float p, float a)\n{\n    return smoothstep(-16.0,-5.0,p)*smoothstep(a,-5.0,p);\n}\n\nvec2 map(vec3 p) \n{\n    //wires\n    //1\n    vec3 q = p - vec3(-2.2,-12.0,-3.9);\n    q.yz *= rot(0.4);\n    float wire = max(sdTorus(q.zyx,vec2(2.6,0.1)),-q.x);\n    q.y += cos(q.x*0.6)*0.8;\n    q.z -= smoothstep(0.0,-6.0,q.x)*2.0;\n    wire = min(wire, sdCapsule(q - vec3(-10.0,-1.8,0.0),10.0,0.1));\n    //2\n    q = p - vec3(-3.8,-12.0,-3.9);\n    q.yz *= rot(0.6);\n    wire = min(wire,max(max(sdTorus(q.zyx,vec2(3.4,0.1)),-q.x),q.y));\n    q.y += cos(q.x*0.6)*0.6;\n    q.z -= smoothstep(0.0,-4.0,q.x)*3.0;\n    wire = min(wire, sdCapsule(q - vec3(-10.0,-2.8,0.0),10.0,0.1));\n    //wall\n    float sxy = SXY(p.y,-2.0),\n          h1 = hash11(floor(p.x*1.7)),\n          wx = fract(p.x*1.7),\n          wall = smin(sdBox(p, vec3(1100.0,100.0,1.8 + sin((p.y + h1)*(12.0+h1*3.0))*0.04)),\n                      sdBox(vec3(wx,p.yz), vec3(h1*0.2,100.0,2.0))-0.04,0.3);\n    //bullets\n    q = p - vec3(2.4,0.0,-5.2);\n    q.z += sxy*1.6 - smoothstep(-16.0,-10.0,p.y)*2.0;\n    q.x -= sxy*0.4;\n    q.xz *= rot(sxy*0.4 + smoothstep(-5.0,5.0,p.y));\n    q.y = mod(q.y,0.4) - 0.2;\n    float bullets = min(sdBox(q,vec3(0.6,0.1,0.1)) - 0.06, \n                        sdBox(q - vec3(1.0 + sxy*0.2,0.0,-0.3),vec3(0.6,0.1,0.1)) - 0.06);\n    bullets = min(bullets, sdBox(q - vec3(2.0 + sxy*0.4,0.0,-0.6),vec3(0.6,0.1,0.1)) - 0.06);\n    bullets = min(bullets, sdBox(q - vec3(3.0 + sxy*0.6,0.0,-0.8),vec3(0.6,0.1,0.1)) - 0.06);\n    //helmet\n    float helmet =    min(sdEllipsoid(p - vec3(-2.4,-2.0,-3.8),vec3(0.8,2.2,1.8)),  \n                          sdEllipsoid(p - vec3(-3.0,-2.0,-3.8),vec3(0.8,1.0,1.0)));\n    helmet = smin(helmet, sdTorus(p - vec3(-3.1,-2.0,-3.8), vec2(1.1,0.2)),0.2);\n    helmet = smin(helmet, sdEllipsoid(p - vec3( 0.0,-5.5,-2.6),vec3(4.8,2.2,1.9)),0.6);\n    //helmet = max(helmet, -sdEllipsoid(p - vec3(-2.4,-2.0,-3.8),vec3(0.6,1.8,1.4)));\n    p.x = abs(p.x);\n    helmet = max(helmet, -(length(p - vec3(4.6,-7.4,-2.6)) - 2.9));\n    helmet = max(helmet, -sdBox(p, vec3(2.0,10.0,10.0)));\n    helmet = smax(helmet,-(sdBox(p - vec3(0.0,-2.2,0.0),vec3(2.3,1.8,8.0))), 0.3);\n    //body\n    float torso = smin(min(sdEllipsoid(p - vec3(0.0,-5.3, -2.6),vec3(3.5,2.0,1.9)),\n                       max(sdEllipsoid(p - vec3(0.0,-5.3, -2.6),vec3(3.5,7.4,1.9)),p.y + 5.3)),\n                       min(sdEllipsoid(p - vec3(0.0,-16.0,-2.6),vec3(3.5,1.8,2.0)),\n                       max(sdEllipsoid(p - vec3(0.0,-16.0,-2.6),vec3(3.5,4.8,2.0)) , -(p.y + 16.0))),\n                  1.6);\n    //shoulders\n    torso = smin(torso, sdEllipsoid(p - vec3(2.8,-5.5, -2.4),vec3(1.2,1.76,1.1)),0.8);\n    //pipes\n    q = p - vec3(10.0,-9.8,-4.9-p.y*0.1);\n    q.y += smoothstep(1.0+sxy*1.0,6.0,p.x)*2.0;\n    q.z -= smoothstep(1.0+sxy*1.0,6.0,p.x)*2.0;\n    q = opRepLim(q,0.6,vec3(0.0,4.0,0.0));\n    float metal = sdCapsule(q,-8.9+sxy,0.2),\n          socket = smax(length(q - vec3(-9.2+sxy,0.0,0.0)) - 0.3, -metal, 0.2);\n    torso = smin(torso,socket,0.3);\n    //neck\n    torso = smin(torso,sdRoundCone(p,vec3(0.0,-5.0,-2.4),vec3(0.0,0.0,-1.64),1.4,1.1),0.4);\n    //backbone\n    sxy = SXY(p.y,-2.0);\n    q = p;\n    q.y -= 0.2 / (1.0 + abs(q.x)*abs(q.x));\n    torso -= (sin(q.y*10.0) + 1.0)\n            * sxy\n            * (smoothstep(0.8+sxy,0.0+sxy,q.x) * smoothstep(sxy-0.2,0.1+sxy,q.x)*0.04 +\n               smoothstep(0.4,0.0,q.x)*0.04 + smoothstep(1.4,0.0,q.x)*0.02 +\n               /*- n3D(p*vec3(1.3,6.1,5.9))*0.04 + */\n               smoothstep(sxy*3.8,0.0,q.x)*0.04) * step(q.x,0.5 + sxy);\n\n    //skin peel\n    torso -= smoothstep(0.5+sxy,0.6+sxy,p.x)*0.08;    \n    //bum\n    p.x = almostIdentity(p.x,0.2,0.04);\n    \n    q = p - vec3(1.9,-16.0,-2.8);\n    q.xy *= rot(0.6);\n    torso = smin(torso, sdEllipsoid(q,vec3(2.2,2.8,2.4)),0.5);\n    q.xz *= rot(1.0);\n    \n    helmet = smin(helmet,sdTorus(q + vec3(-3.0,-8.6,4.7),vec2(1.5,0.54+sin(p.y*24.0)*0.01)),0.2);\n    \n    //v\n    torso += smoothstep(0.4,0.0,p.x+p.y+15.4)*0.04;\n    //box\n    torso = smax(torso,-sdBox(p - vec3(0.0,-18.21,-2.8),vec3(0.1,2.0,4.0)),0.6);\n    //head\n    torso = smin(torso,\n                 smin(sdEllipsoid(p - vec3(0.0,0.0,-0.8),vec3(0.8,2.8,2.4)),\n                      sdEllipsoid(p - vec3(0.8,0.0,-0.4),vec3(1.1,2.6,2.6)),0.4),\n                 0.4);\n    \n    vec2 nr = near(vec2(torso,BODY),vec2(helmet,HELMET));\n    nr = near(nr,vec2(min(metal,bullets),METAL));\n    nr = near(nr,vec2(wire,WIRE));\n    return near(nr,vec2(wall,WALL));\n}\n\nfloat mapD(vec3 p, float sid) \n{\n    float h = map(p).x;\n    if (sid==WALL)\n    {\n        h += (n3D(p*vec3(11.1,1.7,9.3)) + n3D(p*vec3(1.9,12.3,9.1)))*0.02;\n    }\n    if (sid==BODY)\n    {\n        //head\n        vec3 q = p - vec3(0.0,0.0,-0.4);\n        float a = atan(q.z,q.y)/6.283185;\n        float ia = floor(a*16.0)/16.0*6.283185;\n        q.yz *= rot(ia);\n        h += smoothstep(0.1,0.0,abs(q.z))*0.06*\n             smoothstep(0.0,2.0,abs(q.x))* \n             smoothstep(2.8,2.6,length(q.yz));//*\n             //smoothstep(0.5,1.2,length(q.yz));\n             \n        \n        //back\n        float sxy = SXY(p.y,-2.0);\n        p.x = abs(p.x);\n        \n        //vertical\n        h += (smoothstep(0.0,0.1,abs(p.x-1.0-sxy)) +\n              smoothstep(0.0,0.1,abs(p.x-1.2-sxy*2.0)))*0.04*\n              smoothstep(2.0,-6.0,p.y)*\n              smoothstep(-15.0,-10.0,p.y);\n        //horizontal\n        h += sin(p.y*20.0)*0.04 * smoothstep(0.0,-0.1,p.x-1.2-sxy*2.0)*\n                                  smoothstep(-0.1,0.0,p.x-1.1-sxy*1.0)*\n                                  smoothstep(-6.0,-10.0,p.y)*\n                                  smoothstep(-15.0,-10.0,p.y);                         \n        h += sin(p.y*20.0)*0.04 * smoothstep(-0.1,0.0,p.x-1.3-sxy*2.0)*\n                                  smoothstep(0.0,-1.4,p.x-2.6) *\n                                  smoothstep(-10.0,-12.0,p.y)*\n                                  smoothstep(-15.0,-12.0,p.y);\n        //spine \n        h -= pow(n3D(p*vec3(7.7,15.1,14.3)),2.0)*0.02*step(p.x-0.5-sxy,0.0)*smoothstep(6.0,0.0,abs(p.y + 8.0));\n        h -= n3D(p*vec3(1.9,4.1,6.3))*0.064*step(p.x-0.5-sxy,0.0)*smoothstep(5.0,0.0,abs(p.y + 6.0));\n    }\n    if (sid==HELMET)\n    {\n        vec3 q = p - vec3(-2.4,-2.0,-3.8);\n        float a = atan(q.z,q.y)/6.283185;\n        float ia = floor(a*16.0)/16.0*6.283185;\n        q.yz *= rot(ia);\n        h += smoothstep(0.0,0.1,abs(q.z))*0.06*\n             smoothstep(0.8,1.2,length(q.yz))*\n             smoothstep(-2.4,-2.8,p.x)*\n             smoothstep(-5.0,-4.0,p.y);\n    }\n    return h;\n}\n\nvec3 normal(vec3 p, float sid) \n{  \n    vec4 n = vec4(0.0);\n    for (int i=ZERO; i<4; i++) \n    {\n        vec4 s = vec4(p, 0.0);\n        s[i] += EPS;\n        n[i] = mapD(s.xyz,sid);\n    }\n    return normalize(n.xyz-n.w);\n}\n\n//IQ - http://www.iquilezles.org/www/articles/raymarchingdf/raymarchingdf.htm\nfloat AO(vec3 p, vec3 n) \n{\n    float ra = 0., w = 1., d = 0.;\n    for (int i=ZERO; i<5; i++){\n        d = float(i) / 5.;\n        ra += w * (d - map(p + n*d).x);\n        if (ra>1.) break;\n        w *= .5;\n    }\n    return 1. - clamp(ra,0.,1.);\n}\n\n//IQ soft shadows\n//https://www.shadertoy.com/view/lsKcDD\nfloat calcSoftshadow(vec3 ro, vec3 rd, float mint, float tmax, int technique )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<60; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n\n        // traditional technique\n        if( technique==0 )\n        {\n        \tres = min( res, 10.0*h/t );\n        }\n        // improved technique\n        else\n        {\n            // use this if you are getting artifact on the first iteration, or unroll the\n            // first iteration out of the loop\n            //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n\n            float y = h*h/(2.0*ph);\n            float d = sqrt(h*h-y*y);\n            res = min( res, 10.0*d/max(0.0,t-y) );\n            ph = h;\n        }\n        \n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    res = clamp( res, 0.0, 1.0 );\n    return 0.001 + res*res*(3.0-2.0*res);\n}\n\nvec2 march(vec3 ro, vec3 rd) \n{\n    float t = 0.0, id = 0.0;   \n    for (int i=ZERO; i<120; i++)\n    {\n        vec2 ns = map(ro + rd*t);\n        if (ns.x<EPS)\n        {\n            id = ns.y;\n            break;\n        }\n        t += ns.x*0.8;\n        if (t>FAR) \n        {\n            t = -1.0;\n            break;\n        }\n        \n    }\n    return vec2(t,id);\n}\n\nvec3 camera(vec2 uv, vec3 ro, vec3 la, float fl) \n{\n    vec3 fwd = normalize(la-ro),\n         rgt = normalize(vec3(fwd.z,0.0,-fwd.x));\n    return normalize(fwd + fl*uv.x*rgt + fl*uv.y*cross(fwd, rgt));\n}\n\nfloat BXY(float py, float a, float b, float c, float d, float e)\n{\n    return smoothstep(b,a,py) +\n           smoothstep(b,c,py) - \n           smoothstep(c,d,py) +\n           smoothstep(d,e,py);\n}\n\nvoid mainImage(out vec4 C, vec2 U)\n{\n    vec3 pc = vec3(0),\n         la = vec3(0,-8.0,0),\n         lp = vec3(-8,20.0,-10.0),\n         ro = vec3(0,-8.0,-20);\n    vec2 uv = (U - R*.5) / R.y;\n    \n    ro.xz *= rot(sin(T*0.07)*0.18);\n    ro.yz *= rot(sin((T-0.7)*0.04)*0.14);\n    vec3 rd = camera(uv,ro,la,1.0);\n    \n    float bounds = boxIntersection(ro,rd,vec3(8.0,20.0,6.0));\n    if (bounds>0.0)\n    {\n        ro += rd*bounds;\n        vec2 s = march(ro,rd);\n        if (s.x>0.0)\n        {\n            vec3 p = ro + rd*s.x;\n            vec3 n = normal(p, s.y);\n            vec3 ld = normalize(lp - p);\n            float diff = max(0.0,dot(ld,n));\n            float ao = AO(p,n);\n            float spec = pow(max(dot(reflect(-ld,n),-rd),0.0),4.0);\n            float nz = n3D(p*vec3(1.7,5.7,7.9));\n            float nzy = n3D(p*vec3(13.9,1.1,15.8));\n            float sh = calcSoftshadow(p + n*0.003,ld,EPS,FAR,1);\n            if (s.y==BODY)\n            {\n                float sxy = SXY(p.y,-2.0);\n                //back\n                vec3 bc = mix(vec3(0.01),vec3(0.4),smoothstep(-1.0,2.0,p.y));\n                bc = mix(bc,vec3(0.3),nzy*smoothstep(-3.0,1.0,p.y));\n                bc = mix(bc,vec3(0.4),smoothstep(-12.0,-14.0,p.y));\n                bc *= diff;\n                bc += vec3(0.04)*pow(spec,4.0)*smoothstep(2.0,0.0,abs(p.y + 5.0));\n                //skin\n                float sclpb = BXY(p.y,-16.0,-10.0,-5.0,-2.0,1.0);\n                vec3 sc = mix(vec3(0.2),vec3(0.01),nzy*2.0*(1.0 - sclpb));\n                sc += vec3(0.3)*smoothstep(-13.6,-15.0,p.y); //bum highlight\n                sc += vec3(0.4)*smoothstep(1.2,0.0,abs(p.y + 5.0)); //shoulder highlight                \n                sc *= diff;\n                sc += vec3(0.2)*spec;\n                \n                pc = mix(bc,sc,smoothstep(0.1,0.2,abs(p.x)-0.5-sxy*1.0));\n                pc *= smoothstep(-12.0,-16.0,p.y) + smoothstep(-12.0,-4.0,p.y);\n                pc += vec3(0.3)*smoothstep(0.0,2.0,p.y); //head highlight\n            }\n            if (s.y==WALL)\n            {\n                pc = vec3(0.01)*diff + vec3(0.1)*pow(spec,4.0);\n            }\n            if (s.y==METAL)\n            {\n                pc = mix(vec3(0.0),vec3(0.04)+smoothstep(2.0,0.0,abs(p.y+4.0))*0.4,pow(nz,4.0))*diff; \n                pc += vec3(0.2)*pow(spec,4.0);\n                pc += vec3(1.0)*pow(spec,16.0);\n                pc *= smoothstep(6.0,1.0,p.x);\n            }\n            if (s.y==HELMET)\n            {\n                vec3 q = p - vec3(-2.4,-2.0,-3.8);\n                vec3 bc = mix(vec3(0.8),vec3(0.1),n3D(p*3.0));\n                vec3 cc = mix(vec3(0.0),vec3(0.1),pow(nz,2.0));\n                pc = mix(cc,bc,smoothstep(0.9,1.0,length(q.yz)));\n                pc *= diff;\n                pc += vec3(0.2)*pow(spec,4.0);\n            }\n            if (s.y==WIRE)\n            {\n                float lt = length(p - vec3(0.0,-12.0,-3.2));\n                pc = mix(vec3(0.001),vec3(0.4),smoothstep(1.6,2.4,lt))*diff;\n                pc += vec3(0.2)*pow(spec,4.0)*smoothstep(-1.0,-2.0,p.x);\n            }\n            pc *= ao*sh;\n            pc *= smoothstep(8.0,2.0,abs(p.x));\n        }\n        \n    }\n    pc = pow(pc, vec3(0.3545));\n    pc *= 1. + sin(uv.y*800. + T)*0.02;\n    pc *= 1. + sin(uv.x*800. + T)*0.02; \n    \n    C = vec4(pc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nd2GRc.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[366, 395, 414, 414, 460], [462, 496, 519, 519, 604], [606, 617, 636, 636, 941], [943, 967, 1006, 1006, 1100], [1102, 1102, 1141, 1141, 1240], [1242, 1242, 1282, 1282, 1323], [1325, 1325, 1354, 1354, 1445], [1447, 1447, 1490, 1490, 1547], [1549, 1549, 1581, 1581, 1655], [1657, 1657, 1692, 1692, 1781], [1783, 1783, 1803, 1803, 1822], [1823, 1823, 1886, 1950, 2537], [2539, 2639, 2688, 2688, 2832], [2834, 2834, 2890, 2890, 3283], [3285, 3285, 3312, 3312, 3349], [3351, 3351, 3380, 3380, 3440], [3442, 3442, 3461, 3481, 7833], [7835, 7835, 7867, 7867, 9904], [9906, 9906, 9939, 9939, 10128], [10130, 10208, 10235, 10235, 10453], [10455, 10513, 10593, 10593, 11458], [11460, 11460, 11491, 11491, 11824], [11826, 11826, 11877, 11877, 12029], [12031, 12031, 12097, 12097, 12227], [12229, 12229, 12265, 12265, 15545]], "test": "valid"}
{"id": "Nd2SWD", "name": "Animated Lightning Demo", "author": "sdfgeoff", "description": "Shows how lightning can be made from scrolling noise.", "tags": ["noise", "lightning"], "likes": 1, "viewed": 229, "published": "Public", "date": "1620261066", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This uses the noise from https://www.shadertoy.com/view/4lB3zz and I just\n// added some filters to the end of it to do the scrolling lightning.\n//\n// Basically this is to demo that you can subtract two noises and create cool\n// scrolling lighthing.\n\nconst int firstOctave = 4;\nconst int octaves = 2;\nconst float persistence = 0.6;\n\n//Not able to use bit operator like <<, so use alternative noise function from YoYo\n//\n//https://www.shadertoy.com/view/Mls3RS\n//\n//And it is a better realization I think\nfloat noise(int x,int y)\n{   \n    float fx = float(x);\n    float fy = float(y);\n    \n    return 2.0 * fract(sin(dot(vec2(fx, fy) ,vec2(12.9898,78.233))) * 43758.5453) - 1.0;\n}\n\nfloat smoothNoise(int x,int y)\n{\n    return noise(x,y)/4.0+(noise(x+1,y)+noise(x-1,y)+noise(x,y+1)+noise(x,y-1))/8.0+(noise(x+1,y+1)+noise(x+1,y-1)+noise(x-1,y+1)+noise(x-1,y-1))/16.0;\n}\n\nfloat COSInterpolation(float x,float y,float n)\n{\n    float r = n*3.1415926;\n    float f = (1.0-cos(r))*0.5;\n    return x*(1.0-f)+y*f;\n    \n}\n\nfloat InterpolationNoise(float x, float y)\n{\n    int ix = int(x);\n    int iy = int(y);\n    float fracx = x-float(int(x));\n    float fracy = y-float(int(y));\n    \n    float v1 = smoothNoise(ix,iy);\n    float v2 = smoothNoise(ix+1,iy);\n    float v3 = smoothNoise(ix,iy+1);\n    float v4 = smoothNoise(ix+1,iy+1);\n    \n   \tfloat i1 = COSInterpolation(v1,v2,fracx);\n    float i2 = COSInterpolation(v3,v4,fracx);\n    \n    return COSInterpolation(i1,i2,fracy);\n    \n}\n\nfloat PerlinNoise2D(float x,float y)\n{\n    float sum = 0.0;\n    float frequency =0.0;\n    float amplitude = 0.0;\n    for(int i=firstOctave;i<octaves + firstOctave;i++)\n    {\n        frequency = pow(2.0,float(i));\n        amplitude = pow(persistence,float(i));\n        sum = sum + InterpolationNoise(x*frequency,y*frequency)*amplitude;\n    }\n    \n    return sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    float time = iTime * 0.1;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float x = uv.x;\n    float y = uv.y;\n\t//fragColor = vec4(noise(x,y),noise(x,y),noise(x,y),1);\n    float noise1 = PerlinNoise2D(x + time,y) * 5.0 + 0.0;\n    float noise2 = PerlinNoise2D(x,y + time) * 5.0 + 0.0;\n    \n    float outp = 1.0;\n    \n    if (x < 0.32) {\n        outp = noise1;\n    } else if (x > 0.34 && x < 0.64) {\n        outp = noise2;\n    } else if (x > 0.66) {\n        outp = (noise1 - noise2);\n    }\n    \n    if (y < 0.45) {\n        outp =  ((0.5 - abs(outp)) - 0.5) * 10.0;\n    }\n    \n    fragColor = vec4(outp + 0.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nd2SWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[335, 506, 532, 532, 681], [683, 683, 715, 715, 869], [871, 871, 920, 920, 1012], [1014, 1014, 1058, 1058, 1474], [1476, 1476, 1514, 1514, 1839], [1841, 1841, 1898, 1898, 2513]], "test": "valid"}
{"id": "Nd2Szd", "name": "2D Julia set", "author": "takeshi", "description": "ジュリア集合", "tags": ["julia"], "likes": 1, "viewed": 129, "published": "Public API", "date": "1620886388", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define cos01(x) ((cos(x)+1.)/2.)\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nvec3 hsv2rgb( in vec3 c ){\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z * mix( vec3(1.0), rgb*rgb*(3.0-2.0*rgb), c.y);\n}\n\n#define MAX_ITERS 400\nfloat julia( vec2 z, vec2 c ){\n  for( int i=0; i<MAX_ITERS; i++ ){\n      z = vec2( z.x*z.x-z.y*z.y, 2.*z.x*z.y ) + c;\n      if( length(z) > 2. ){\n        return (float(i) - log2(log2(dot(z,z))) + 4.0) / float(MAX_ITERS);\n      }\n  }\n  return 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  float time = iTime * 0.4;\n  float ratio = iResolution.y/iResolution.x;\n  vec2 mo = iMouse.xy / iResolution.xy - 0.5;\n  //mo = vec2(cos(time),-sin(time))*.2;\n  vec2 uv = fragCoord / iResolution.xx - 0.5*vec2(1.,ratio);\n  uv *= rot(-.8);\n  float d = julia(uv*2.4,vec2(-0.1,-0.65)+mo*vec2(.4,.1));\n  float h = cos01(pow(d,1.)/.1);\n  float s = pow(d,1./2.0);\n  float v = 1.-pow(d,1.1) - pow(length(uv),2.2);\n  vec3 hsv = vec3(cos01(h+time/1.),s,v);\n  fragColor = vec4(hsv2rgb(hsv),1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nd2Szd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[85, 85, 111, 111, 258], [531, 531, 587, 587, 1072]], "test": "valid"}
{"id": "Nd2XD3", "name": "Bubbles Rising 3", "author": "cultureulterior", "description": "Fullscreen, can move the mouse", "tags": ["3d", "raymarching", "raycasting", "voxel"], "likes": 6, "viewed": 67, "published": "Public", "date": "1621193845", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst int MAX_RAY_STEPS = 64;\n\n// sph intersect, credits iq\nvec2 sphIntersect2( in vec3 ro, in vec3 rd, in vec4 sph)\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0,-1.0);\n    h = sqrt( h );\n    return vec2(-b - h, -b + h);\n}\n\n// credits anastadunbar\nfloat rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\nfloat rand(vec3 co){ return rand(co.xy+rand(co.z)); }\nfloat randrise(ivec3 co,float time){ return rand(vec3(co.x,co.y+int(time),co.z));}\n\n//mine\nfloat bubblesRising( vec3  rayDir, vec3  rayPos, \n                     float iTime)  \n{\n     \n    float bubble = -iTime*2.0;\n    float fbubble = fract(bubble);\n    float ibubble = floor(bubble);\n    // instead of offsetting the snow rise inside the voxel trace, we offset the ray\n    vec3 offset = vec3(0,fract(bubble),0); \n    rayPos+=offset;\n    vec3 orp = rayPos;\n    // branchless voxel tracing initialization, credits fb39ca4 dda\n\tivec3 mapPos = ivec3(floor(rayPos + 0.0));\n\tvec3 deltaDist = abs(vec3(length(rayDir)) / rayDir);\n\tivec3 rayStep = ivec3(sign(rayDir));\n\tvec3 sideDist = (sign(rayDir) * (vec3(mapPos) - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist; \n\tbvec3 mask;\n    float mist = 0.0;\n\tfor (int i = 0; i < MAX_RAY_STEPS; i++) {            \n            // branchless voxel tracing, credits fb39ca4 dda\n            mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));\t\n\t\t\tsideDist += vec3(mask) * deltaDist;\n\t\t\tmapPos += ivec3(vec3(mask)) * rayStep;\n            vec2 randomness = vec2(randrise(mapPos,floor(bubble)),ibubble);\n            if(randomness.x>0.9)\n                 {\n                    // found a bubble in our voxel- where is it?\n                    vec3 position=vec3(rand(vec2(mapPos.xz)),rand(vec2(mapPos.xz)+vec2(10203,2021)),rand(vec2(mapPos.xz)+vec2(121,-221)))*0.8 - 0.4;\n                    // disable popping at max_ray_steps\n                    float fade = smoothstep(0.0,10.0,float(MAX_RAY_STEPS-i))*0.1;\n                    // offset snowflake to center, and randomize\n                    vec3 msp = vec3(mapPos)+vec3(0.5,0.5,0.5)+position;\n                    // intersect with sphere to get simple bubble- want to make this better\n                    vec2 t = sphIntersect2(orp,rayDir,vec4(msp,(randomness.x-0.85)*1.5));\n                    mist += abs(t.x-t.y) * fade;\n                 }\n\t}             \n    return mist;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //camera setup, credits iq\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m =                iMouse.xy      /iResolution.xy;\n    vec3 ro = 4.0*normalize(vec3(sin(3.0*m.x), 0.8*m.y, cos(3.0*m.x))) - vec3(0.0,0.1,0.0);\n\tvec3 ta = vec3(0.0, -1.0, 0.0);\n    mat3 ca = setCamera( ro, ta, 0.07*cos(0.25*iTime) );\n    vec3 rd = ca * normalize( vec3(p.xy,1.5));\n\n    vec3 col = vec3(0.0);\n    float h=bubblesRising(rd, ro, iTime);\n    if( h>0.0 )\n    {\n            col = mix( col, vec3(0.2,0.5,1.0), h );\n            col = mix( col, 1.15*vec3(1.0,0.9,0.6), h*h*h );\n    }\n    col = sqrt( col )*1.3;\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nd2XD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 61, 119, 119, 321], [323, 347, 369, 369, 417], [418, 418, 438, 438, 506], [507, 507, 527, 527, 560], [561, 561, 597, 597, 643], [645, 652, 739, 739, 2539], [2541, 2541, 2593, 2593, 2770], [2772, 2772, 2829, 2860, 3481]], "test": "valid"}
{"id": "Nd2XWm", "name": "A Simple Squircle (superellipse)", "author": "bct23", "description": "A squircle is the set of points within some norm (\"distance\") of the origin, using:\n   ||d|| ^ e = (d.x) ^ e + (d.y) ^ e\n\nWhen e=2 this gives is Pythagoras's equation, resulting in a normal circle. Scaling x/y produces a superellipse.", "tags": ["2d", "geometry"], "likes": 5, "viewed": 47, "published": "Public", "date": "1620382586", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n * Numerically-stable squircle (superellipse) renderer.\n * (See https://en.wikipedia.org/wiki/Superellipse)\n *\n * Derived from https://www.shadertoy.com/view/XsjGDt\n * by jonobr1 / http://jonobr1.com/\n */\n\n/**\n * Convert r, g, b to normalized vec3\n */\nvec3 rgb(float r, float g, float b) {\n\treturn vec3(r / 255.0, g / 255.0, b / 255.0);\n}\n\n/**\n * Compute a norm (distance) using exponent `e`:\n *    norm^e = x^e + y^e\n *  e=2 gives normal Pythagorean / Euclidean distance.\n */\nfloat norm(float e, vec2 v) {\n    v = abs(v);\n    if (v.y > v.x) { v = vec2(v.y, v.x); }\n    if (v.y == 0.0) { return v.x; }\n    // For large `e`, computing a^e might overflow, so compute log(a^e) = e.log(a)\n    v = vec2(e * log(v));\n    // Calculate log(d^e) log(x^e+y^e). - see https://en.wikipedia.org/wiki/LogSumExp.\n    float logSumExp = v.x + log(1.0 + exp(v.y - v.x));\n    \n    return exp(logSumExp / e);\n}\n\n/**\n * Draw a superellipse at vec2 `pos` with radius `rad`,\n * color `color` and exponent `e`\n */\nvec4 circle(vec2 uv, vec2 pos, float rad, vec3 color, float e) {\n   \n\tfloat d = norm(e, pos - uv) - rad;\n    // Attempt to \"anti-alias\" pixels on the border. Not accurate for e<1.\n\tfloat t = clamp(d, 0.0, 1.0);\n\treturn vec4(color, 1.0 - t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 uv = fragCoord.xy;\n\tvec2 center = iResolution.xy * 0.5;\n\tfloat radius = 0.25 * iResolution.y;\n\n    // Background layer\n\tvec4 layer1 = vec4(rgb(210.0, 222.0, 228.0), 1.0);\n\t\n\t// Super-ellipse\n\tvec3 red = rgb(225.0, 95.0, 60.0);\n    float exponent = pow(8.0, 0.3 + sin(iTime));\n\tvec4 layer2 = circle(uv, center, radius, red, exponent);\n\t\n\t// Blend the two\n\tfragColor = mix(layer1, layer2, layer2.a);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nd2XWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[210, 256, 293, 293, 342], [344, 481, 510, 510, 894], [896, 994, 1058, 1058, 1236], [1238, 1238, 1295, 1295, 1703]], "test": "valid"}
{"id": "Nd2Xzd", "name": "Void Sun", "author": "R3N", "description": "Now with no aliasing artifacts", "tags": ["abstract"], "likes": 2, "viewed": 148, "published": "Public API", "date": "1620859978", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sun(vec2 p, float t){\n    float a = atan(p.x, p.y)-t/50.0;\n    return 0.03/length(p*sin(a*11.0));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 tc = fragCoord/iResolution.xy;\n    vec2 uv = fragCoord/iResolution.y;\n    vec2 uvc = uv - vec2(iResolution.x/iResolution.y, 1.0)/2.0;\n    vec2 nuv = vec2(iResolution.x/iResolution.y, 1.0) - uv;\n    float t = iTime/3.0;\n    vec2 gn = iResolution.xy/4.0;\n    vec2 guv = fract(tc*gn);\n    vec2 gid = floor(tc*gn);\n    vec2 p1 = uvc + vec2(sin(t/3.0), cos(t/3.0+sin(t)))/3.0;\n    vec2 p2 = uvc + vec2(cos(t/3.0), sin(-t/3.0+cos(t)))/3.0;\n    float d = sin(uv.y*10.0+t)*sin(t)*0.1;\n    nuv.x += d;\n    float c = (2.0*mix(0.0, sun(p2, t)*mix(100.0, 300.0, smoothstep(-1.0, 1.0, sin(iTime))), fract(smoothstep(0.0, sun(p1, t), .5*sun(nuv, 0.0)))*(1.0/length(guv-0.5)/100.0)));\n    fragColor = vec4(c);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nd2Xzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 105], [108, 108, 165, 165, 871]], "test": "valid"}
{"id": "Nd2XzG", "name": "8x8 No Texture Dither effect", "author": "Shorakie", "description": "Testing 8x8 dithering effect using internal array instead of using a texture.", "tags": ["effect", "dither"], "likes": 4, "viewed": 92, "published": "Public", "date": "1620491333", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rotateUV(vec2 uv, float rotation)\n{\n    float mid = 0.5;\n    return vec2(\n        cos(rotation) * (uv.x - mid) + sin(rotation) * (uv.y - mid) + mid,\n        cos(rotation) * (uv.y - mid) - sin(rotation) * (uv.x - mid) + mid\n    );\n}\n\n// Cant initialize 2d array\nint dither0[8] = int[](0, 32, 8, 40, 2, 34, 10, 42);\nint dither1[8] = int[](48, 16, 56, 24, 50, 18, 58, 26); /* pattern. Each input pixel */\nint dither2[8] = int[](12, 44, 4, 36, 14, 46, 6, 38); /* is scaled to the 0..63 range */\nint dither3[8] =int[](60, 28, 52, 20, 62, 30, 54, 22); /* before looking in this table */\nint dither4[8] =int[]( 3, 35, 11, 43, 1, 33, 9, 41); /* to determine the action. */\nint dither5[8] =int[](51, 19, 59, 27, 49, 17, 57, 25);\nint dither6[8] =int[](15, 47, 7, 39, 13, 45, 5, 37);\nint dither7[8] =int[](63, 31, 55, 23, 61, 29, 53, 21);\n\nfloat find_closest(int x, int y, float c0)\n{\n    float limit = 0.0;\n    if(x == 0) limit = float(dither0[y]+1)/64.0;\n    else if(x == 1) limit = float(dither1[y]+1)/64.0;\n    else if(x == 2) limit = float(dither2[y]+1)/64.0;\n    else if(x == 3) limit = float(dither3[y]+1)/64.0;\n    else if(x == 4) limit = float(dither4[y]+1)/64.0;\n    else if(x == 5) limit = float(dither5[y]+1)/64.0;\n    else if(x == 6) limit = float(dither6[y]+1)/64.0;\n    else if(x == 7) limit = float(dither7[y]+1)/64.0;\n    \n    if (c0<limit) return 0.0;\n    return 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Rotation test\n    uv = rotateUV(uv, mod(iTime*1.0,2.0*3.14));\n\n    vec3 col = vec3(mix( -0.02, 1.02, uv.x));\n    \n    int x = int(mod(fragCoord.x,8.0));\n    int y = int(mod(fragCoord.y,8.0));\n    float bit = find_closest(x,y, col.r);\n    //col = vec3(x,y,0.0);\n    \n    \n    //col -= step(mod(uv.x+1.0/16.0, 1.0/8.0), 0.0025);\n    // Output to screen\n    fragColor = vec4(vec3(bit),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nd2XzG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 236], [834, 834, 878, 878, 1381], [1383, 1383, 1440, 1490, 1932]], "test": "valid"}
{"id": "NdBSDc", "name": "Eye of the Infinite", "author": "pugbyte", "description": "Just a beginner messing around with radial coordinates. It started to look like an eye at some point so I just ran with it.", "tags": ["beginner"], "likes": 8, "viewed": 238, "published": "Public API", "date": "1621116558", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M_PI 3.14159\n\nvec2 getRadialUv(vec2 uv) {\n    float angle = atan(uv.x, uv.y);\n\n    vec2 radialUv = vec2(0.0);\n    radialUv.x = angle / (M_PI * 2.0) + 0.5;\n    radialUv.y = length(uv);\n\n    return radialUv;\n}\n\nfloat lid(float x, float openess) {\n    //return cos(x) * abs(sin(iTime*2.0));\n    return cos(x) * openess;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Start at an interesting time where the eyelids are moving frequently\n    float time = iTime + 48.0;\n    \n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.yy * 2.0;\n    \n    // Move the whole eye around sporadically\n    float eye_move = sin(texture(iChannel0, vec2(time*0.004)).x-0.5);\n    float eye_move_y = sin(texture(iChannel0, vec2((time+20.0)*0.004)).x-0.5);\n    //uv += vec2(eye_move,0.0);\n    \n    \n    // displace the coordinates using interesting texture\n    float displacement = texture(iChannel0, uv).x*0.1;\n    \n    vec2 uv_anim = uv + vec2(eye_move*1.9+displacement, eye_move_y);\n\n    vec2 radialUv = getRadialUv(uv_anim);\n    \n    float warpedX = fract(radialUv.x - (time*2.0 - radialUv.y*5.0));\n    float warpedY = radialUv.y;\n\n    vec3 color = vec3(warpedX, warpedY, 1.0);\n    \n    float pupil_size = texture(iChannel1, vec2((time-0.3)*0.01)).x*0.5;\n    //pupil_size = 0.1;\n    float pupil = 1.0 - smoothstep(pupil_size, pupil_size + 0.02, radialUv.y);\n    color = mix(color, vec3(.1,.1,.2), pupil);\n    \n    color = mix(color, vec3(.4,.1,.1), min(1.,pow(warpedY*0.6, 8.0)));\n\n    // form the eye lids\n    float lidedge = displacement*0.5;\n    float openess = texture(iChannel1, vec2(time*0.011)).x-0.5;\n    openess *= 2.0;\n    openess = 0.7-clamp(openess, 0.0, 0.7);\n    \n    float lid_move = eye_move*0.5;\n    //lid_move = 0.0;\n    \n    float ulidy = lid(uv.x+lid_move, openess);\n    float upperLid = smoothstep(ulidy-lidedge, ulidy, uv.y);\n    \n    float llidy = -lid(uv.x+lid_move, openess);\n    float lowerLid = 1.0-smoothstep(llidy, llidy+lidedge, uv.y);\n    \n    vec3 lidColor = vec3(.1,.1,.2);\n    vec3 lidHighlight = vec3(0.);\n   \n    \n    float dist = uv.y+0.5 - ulidy;\n    float wrinkles = 30.*(0.5-dist);\n    vec3 upperLidColor = mix(lidColor, lidHighlight, sin(uv.y*wrinkles-lidedge*20.0));\n    \n    dist = abs(uv.y-0.39 - llidy);\n    wrinkles = 30.*(0.5-dist);\n    vec3 lowerLidColor = mix(lidColor, lidHighlight, sin(uv.y*wrinkles-lidedge*20.0));\n    \n    color = mix(color, lowerLidColor, lowerLid);\n    color = mix(color, upperLidColor, upperLid);\n    \n\n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdBSDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 49, 49, 215], [217, 217, 252, 295, 326], [328, 328, 385, 461, 2531]], "test": "error"}
{"id": "NdBSRV", "name": "breathing-checkerboard-2", "author": "ykcwa", "description": "test", "tags": ["blackandwhite"], "likes": 2, "viewed": 36, "published": "Public", "date": "1620715205", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat stripe(float x, float stripeWidth) {\n  float s = mod(x + 0.5 * stripeWidth, 2.0 * stripeWidth);\n  if (s > stripeWidth) {\n    s = 2.0 * stripeWidth - s;\n  }\n  float smoothness =  1./iResolution.y;\n  return smoothstep(stripeWidth * 0.5, stripeWidth * 0.5 - smoothness, s);\n}\n\nfloat xorBW(float color1, float color2) { \n  return abs(color1 - color2);\n}\n\nfloat checkerboardColor(vec2 uv, float squareSize) {\n  return xorBW(stripe(uv.x, squareSize), stripe(uv.y, squareSize));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (y from -0.5 to 0.5, x scaled appropriately)\n    vec2 uv = ( fragCoord - .5* iResolution.xy) / iResolution.y;\n\n    float squareSize = 0.2;\n\n    vec2 uv1 = uv + squareSize * vec2(\n      - 0.125 * cos(2.0 * iTime),\n      - 0.125 * cos(2.0 * iTime)\n    );\n\n    vec2 uv2 = uv + squareSize * vec2(\n      0.5 + 0.125 * cos(2.0 * iTime),\n      0.5 + 0.125 * cos(2.0 * iTime)\n    );\n    float c1 = checkerboardColor(uv1, squareSize);\n    float c2 = checkerboardColor(uv2, squareSize);\n\n    fragColor = vec4(vec3(xorBW(c1, c2)), 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdBSRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 43, 43, 279], [281, 281, 322, 322, 356], [358, 358, 410, 410, 480], [482, 482, 539, 620, 1104]], "test": "valid"}
{"id": "NdBSzy", "name": "Bills Dios de la Destruccion", "author": "jorge2017a1", "description": "Bills Dios de la Destruccion", "tags": ["2d", "anime", "billsdiosdeladestruccion"], "likes": 1, "viewed": 177, "published": "Public API", "date": "1620439732", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//por jorge2017a1 ----jorgeFloresP---7/may/2021\n// referencia \n////-------------------\n/// IQ funciones....librerias\n//https://www.shadertoy.com/view/tlGBW3\n//Created by manu210404 in 2021-03-13\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r; }\n\nvec3 ponerBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S(abs( distObj),0.0));\n  return colOut;\n}\n\nfloat opU(float d1, float d2) {return min(d1, d2); }\nconst vec3 colNegro=vec3(0.0);\nconst vec3 colGris=vec3(0.49,0.49,0.49);\nconst vec3 colGris2=vec3(0.6);\nconst vec3 colBlanco=vec3(1.0);\nconst vec3 colRojo=vec3(1.0,0.0,0.0);\nconst vec3 colAzul=vec3(0.0,0.0,1.0);\nconst vec3 colAzul2=vec3(0.0,0.0,0.2);\nconst vec3 colVerde=vec3(0.0,1.0,0.0);\n\n#define POLY(N) (in vec2 p, in vec2[N] v) {const int n=v.length();float d=dot(p-v[0],p-v[0]);float s=1.;for(int i=0,j=n-1;i<n;j=i,i++){vec2 e=v[j]-v[i];vec2 w=p-v[i];vec2 b=w-e*clamp(dot(w,e)/dot(e,e),0.,1.);d=min(d,dot(b,b));bvec3 cond=bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);if(all(cond)||all(not(cond))) s=-s;}return s*sqrt(d);}\n//***------------****-----------****------------******-------\nfloat sdPoly33 POLY(33)\nvec2 pt33[ 33]=vec2[](  \nvec2(.34,.59),vec2(.31,.61),vec2(.30,.62),vec2(.30,.63),vec2(.30,.66),\nvec2(.27,.70),vec2(.26,.73),vec2(.27,.84),vec2(.28,.92),vec2(.29,.94),\nvec2(.28,.97),vec2(.30,.98),vec2(.31,.99),vec2(.33,.97),vec2(.38,.91),\nvec2(.43,.80),vec2(.45,.70),vec2(.47,.70),vec2(.52,.70),vec2(.53,.71),\nvec2(.55,.78),vec2(.58,.84),vec2(.61,.91),vec2(.65,.96),vec2(.66,.98),\nvec2(.69,.99),vec2(.69,.96),vec2(.71,.85),vec2(.71,.72),vec2(.69,.67),\nvec2(.69,.63),vec2(.64,.59),vec2(.34,.59) );\n\nfloat sdPoly26 POLY(26)\nvec2 pt26[ 26]=vec2[](  \nvec2(.33,.59),vec2(.45,.70),vec2(.46,.70),vec2(.52,.70),vec2(.53,.71),\nvec2(.64,.60),vec2(.64,.57),vec2(.63,.55),vec2(.62,.53),vec2(.62,.52),\nvec2(.59,.50),vec2(.57,.50),vec2(.56,.48),vec2(.56,.47),vec2(.54,.46),\nvec2(.51,.45),vec2(.46,.45),vec2(.45,.46),vec2(.43,.47),vec2(.43,.49),\nvec2(.39,.51),vec2(.38,.51),vec2(.38,.53),vec2(.36,.54),vec2(.35,.56),\nvec2(.33,.59) );\n\nfloat sdPoly7 POLY(7)\nvec2 pt7[ 7]=vec2[](  \nvec2(.37,.58),vec2(.40,.57),vec2(.44,.57),vec2(.45,.55),vec2(.44,.55),\nvec2(.40,.56),vec2(.37,.58) );\n\nfloat sdPoly5 POLY(5)\nvec2 pt5[ 5]=vec2[](  \nvec2(.52,.55),vec2(.54,.57),vec2(.61,.58),vec2(.59,.56),vec2(.52,.55) );\n\nfloat sdPoly7b POLY(7)\nvec2 pt7b[ 7]=vec2[](  \nvec2(.43,.61),vec2(.45,.59),vec2(.46,.58),vec2(.46,.58),vec2(.45,.59),\nvec2(.43,.61),vec2(.43,.61) );\n\nfloat sdPoly7c POLY(7)\nvec2 pt7c[ 7]=vec2[](  \nvec2(.52,.58),vec2(.53,.60),vec2(.55,.61),vec2(.55,.61),vec2(.53,.60),\nvec2(.52,.58),vec2(.52,.58) );\n\nfloat sdPoly7d POLY(7)\nvec2 pt7d[ 7]=vec2[](  \nvec2(.44,.54),vec2(.45,.54),vec2(.46,.55),vec2(.47,.55),vec2(.45,.54),\nvec2(.44,.54),vec2(.44,.54) );\n\nfloat sdPoly7e POLY(7)\nvec2 pt7e[ 7]=vec2[](  \nvec2(.52,.55),vec2(.53,.54),vec2(.54,.53),vec2(.54,.53),vec2(.53,.54),\nvec2(.52,.55),vec2(.52,.55) );\n\nfloat sdPoly10 POLY(10)\nvec2 pt10[ 10]=vec2[](  \nvec2(.48,.50),vec2(.47,.51),vec2(.46,.51),vec2(.47,.52),vec2(.49,.52),\nvec2(.52,.51),vec2(.52,.51),vec2(.51,.50),vec2(.50,.50),vec2(.48,.50) );\n\nfloat sdPoly3 POLY(3)\nvec2 pt3[ 3]=vec2[](  \nvec2(.49,.51),vec2(.49,.50),vec2(.49,.51) );\n\nfloat sdPoly17 POLY(17)\nvec2 pt17[ 17]=vec2[](  \nvec2(.43,.47),vec2(.45,.47),vec2(.46,.47),vec2(.48,.47),vec2(.50,.47),\nvec2(.52,.47),vec2(.54,.47),vec2(.56,.47),vec2(.56,.47),vec2(.54,.47),\nvec2(.52,.47),vec2(.50,.47),vec2(.48,.47),vec2(.46,.47),vec2(.45,.47),\nvec2(.43,.47),vec2(.43,.47) );\n\nfloat sdPoly13 POLY(13)\nvec2 pt13[ 13]=vec2[](  \nvec2(.43,.47),vec2(.43,.47),vec2(.43,.45),vec2(.44,.44),vec2(.49,.44),\nvec2(.53,.44),vec2(.56,.45),vec2(.56,.46),vec2(.56,.47),vec2(.54,.46),\nvec2(.47,.45),vec2(.44,.46),vec2(.43,.47) );\n\nfloat sdPoly25 POLY(25)\nvec2 pt25[ 25]=vec2[](  \nvec2(.43,.46),vec2(.55,.46),vec2(.56,.42),vec2(.78,.36),vec2(.81,.33),\nvec2(.82,.29),vec2(.85,.26),vec2(.88,.19),vec2(.89,.17),vec2(.90,.12),\nvec2(.89,.10),vec2(.10,.10),vec2(.09,.12),vec2(.08,.15),vec2(.10,.18),\nvec2(.10,.21),vec2(.13,.23),vec2(.15,.27),vec2(.17,.29),vec2(.17,.31),\nvec2(.20,.35),vec2(.23,.38),vec2(.42,.42),vec2(.43,.43),vec2(.43,.46) );\n\nfloat sdPoly18 POLY(18)\nvec2 pt18[ 18]=vec2[](  \nvec2(.19,.40),vec2(.35,.42),vec2(.36,.40),vec2(.39,.39),vec2(.47,.38),\nvec2(.56,.38),vec2(.60,.40),vec2(.63,.42),vec2(.79,.40),vec2(.78,.37),\nvec2(.73,.31),vec2(.64,.26),vec2(.51,.23),vec2(.37,.25),vec2(.27,.29),\nvec2(.21,.34),vec2(.19,.38),vec2(.19,.40) );\n\nfloat sdPoly5b POLY(5)\nvec2 pt5b[ 5]=vec2[](  \nvec2(.49,.35),vec2(.44,.31),vec2(.49,.27),vec2(.54,.32),vec2(.49,.35) );\n\nfloat sdPoly5c POLY(5)\nvec2 pt5c[ 5]=vec2[](  \nvec2(.21,.36),vec2(.34,.40),vec2(.36,.39),vec2(.24,.33),vec2(.21,.36) );\n\nfloat sdPoly5d POLY(5)\nvec2 pt5d[ 5]=vec2[](  \nvec2(.39,.37),vec2(.42,.37),vec2(.36,.27),vec2(.30,.28),vec2(.39,.37) );\n\nfloat sdPoly5e POLY(5)\nvec2 pt5e[ 5]=vec2[](  \nvec2(.56,.37),vec2(.59,.38),vec2(.68,.30),vec2(.62,.27),vec2(.56,.37) );\n\nfloat sdPoly5f POLY(5)\nvec2 pt5f[ 5]=vec2[](  \nvec2(.61,.39),vec2(.63,.40),vec2(.76,.37),vec2(.73,.34),vec2(.61,.39) );\n\nfloat sdPoly7f POLY(7)\nvec2 pt7f[ 7]=vec2[](  \nvec2(.37,.53),vec2(.39,.52),vec2(.40,.51),vec2(.40,.51),vec2(.39,.52),\nvec2(.37,.53),vec2(.37,.53) );\n\nfloat sdPoly7g POLY(7)\nvec2 pt7g[ 7]=vec2[](  \nvec2(.62,.54),vec2(.60,.53),vec2(.59,.52),vec2(.59,.51),vec2(.60,.53),\nvec2(.62,.53),vec2(.62,.54) );\n\nfloat sdPoly5g POLY(5)\nvec2 pt5g[ 5]=vec2[](  \nvec2(.47,.70),vec2(.43,.68),vec2(.44,.68),vec2(.48,.70),vec2(.47,.70) );\n\nfloat sdPoly5h POLY(5)\nvec2 pt5h[ 5]=vec2[](  \nvec2(.52,.70),vec2(.55,.67),vec2(.56,.67),vec2(.52,.70),vec2(.52,.70) );\n\nfloat sdPoly6 POLY(6)\nvec2 pt6[ 6]=vec2[](  \nvec2(.71,.83),vec2(.66,.82),vec2(.65,.80),vec2(.66,.79),vec2(.71,.79),\nvec2(.71,.83) );\n\nfloat sdPoly5i POLY(5)\nvec2 pt5i[ 5]=vec2[](  \nvec2(.17,.29),vec2(.17,.25),vec2(.18,.25),vec2(.17,.29),vec2(.17,.29) );\n\nfloat sdPoly9 POLY(9)\nvec2 pt9[ 9]=vec2[](  \nvec2(.28,.28),vec2(.26,.26),vec2(.23,.25),vec2(.19,.24),vec2(.19,.24),\nvec2(.23,.25),vec2(.26,.26),vec2(.28,.27),vec2(.28,.28) );\n\nfloat sdPoly7h POLY(7)\nvec2 pt7h[ 7]=vec2[](  \nvec2(.70,.28),vec2(.73,.26),vec2(.78,.24),vec2(.78,.24),vec2(.74,.26),\nvec2(.71,.28),vec2(.70,.28) );\n\nfloat sdPoly5j POLY(5)\nvec2 pt5j[ 5]=vec2[](  \nvec2(.82,.29),vec2(.81,.25),vec2(.81,.25),vec2(.82,.29),vec2(.82,.29) );\n//***------------****-----------****------------******-------\nvec3 RostroBills(in vec2 pp, vec3 col) \n{\n  vec2 p=pp;\n  \n   float sd1 = sdPoly33(p, pt33);\n   float sd2 = sdPoly26(p, pt26);\n   float sd3 = sdPoly7(p, pt7);\n   float sd4 = sdPoly5(p, pt5);\n   float sd5 = sdPoly7b(p, pt7b);\n   float sd6 = sdPoly7c(p, pt7c);\n   float sd7 = sdPoly7d(p, pt7d);\n   float sd8 = sdPoly7e(p, pt7e);\n   float sd9 = sdPoly10(p, pt10);\n   float sd10 = sdPoly3(p, pt3);\n   float sd11 = sdPoly17(p, pt17);\n   float sd12 = sdPoly13(p, pt13);\n   float sd13 = sdPoly25(p, pt25);\n   float sd14 = sdPoly18(p, pt18);\n   float sd15 = sdPoly5b(p, pt5b);\n   float sd16 = sdPoly5c(p, pt5c);\n   float sd17 = sdPoly5d(p, pt5d);\n   float sd18 = sdPoly5e(p, pt5e);\n   float sd19 = sdPoly5f(p, pt5f);\n   float sd20 = sdPoly7f(p, pt7f);\n   float sd21 = sdPoly7g(p, pt7g);\n   float sd22 = sdPoly5g(p, pt5g);\n   float sd23 = sdPoly5h(p, pt5h);\n   float sd24 = sdPoly6(p, pt6);\n   float sd25 = sdPoly5i(p, pt5i);\n   float sd26 = sdPoly9(p, pt9);\n   float sd27 = sdPoly7h(p, pt7h);\n   float sd28 = sdPoly5j(p, pt5j);\n   float sd29= sdCircle(p-vec2(0.55,0.56), 0.01 );\n   float sd30= sdCircle(p-vec2(0.43,0.56), 0.01 );\n   \n   sd1= opU(sd1, sd2) ;\n   col= ponerBorde(colGris,col,sd1);// 2 orejas\n   //col= ponerBorde(colGris,col,sd2);// rostro\n   col= ponerBorde(colBlanco,col,sd3);// ojo izq\n   col= ponerBorde(colBlanco,col,sd4);// ojo der\n   col= ponerBorde(colNegro,col,sd5); //linea ceja\n   col= ponerBorde(colNegro,col,sd6); //linea ceja\n   col= ponerBorde(colNegro,col,sd7);\n   col= ponerBorde(colNegro,col,sd8);\n   col= ponerBorde(colGris2,col,sd9); ///nariz\n   col= mix(col,colNegro,S( sd10,0.0));\n   col= ponerBorde(colRojo,col,sd11); \n   col= ponerBorde(vec3(0.4,0.4,0.6),col,sd13);  //cuerpo\n   col= ponerBorde(colVerde,col,sd12); //anillo \n   col= ponerBorde(colAzul2,col,sd14); //adorno\n   col= ponerBorde(colRojo,col,sd15);  //figura 1\n   col= ponerBorde(colAzul,col,sd16);  //figura 2\n   col= ponerBorde(colAzul,col,sd17);  //figura 2\n   col= ponerBorde(colAzul,col,sd18);  //figura 2\n   col= ponerBorde(colAzul,col,sd19);  //figura 2\n   col= ponerBorde(colNegro,col,sd20);  //linea 1\n   col= ponerBorde(colNegro,col,sd21);  //linea 2\n   col= ponerBorde(colNegro,col,sd22);  //linea 2\n   col= ponerBorde(colNegro,col,sd23);  //linea 2\n   col= ponerBorde(colAzul,col,sd24);  //cuadro\n   col= ponerBorde(colNegro,col,sd25);  //linea 2\n   col= ponerBorde(colNegro,col,sd26);  //linea 2\n   col= ponerBorde(colNegro,col,sd27);  //linea 2\n   col= ponerBorde(colNegro,col,sd28);  //linea 2\n   col= ponerBorde(colNegro,col,sd29);  //pupila\n   col= ponerBorde(colNegro,col,sd30);  //pupila\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    float t=iTime*1.0;\n    vec2 p=uv*0.5-vec2(-0.5,-0.6);\n    vec3 col=vec3(1.0); //vec3(0.25);\n    //col=RostroBills(p*0.5-vec2(0.0,0.0), col);\n    //col=RostroBills(p*0.5-vec2(-0.5,-0.25), col);\n    col=RostroBills(p+ vec2(0.5*sin(iTime),0.0), col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdBSzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[304, 304, 339, 339, 363], [365, 365, 425, 425, 549], [551, 551, 582, 582, 603], [6483, 6545, 6586, 6586, 9158], [9160, 9160, 9217, 9217, 9599]], "test": "valid"}
{"id": "NdBXDD", "name": "dvd", "author": "rockstep", "description": "if you see it hit the corner directly you get to make a wish", "tags": ["2d"], "likes": 0, "viewed": 40, "published": "Public", "date": "1620297141", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SPEED 5.\n#define EPSILON 0.01\n\n// Stolen from FabriceNeyret2\n#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): textureGrad(iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.), dFdx(U/16.),dFdy(U/16.) )\n#define initMsg vec4 T = vec4(0)\n#define endMsg  return length(T.yz)==0. ? 0. : T.x\nfloat message(vec2 U) {\n    initMsg;\n    C(68);C(86);C(68);\n    endMsg;\n}\n\nfloat pi = radians(180.);\n\nfloat triWave(float theta) {\n    return (1. / pi) * asin(sin(theta * pi));\n}\n\nfloat near(float a, float b) {\n    float diff = abs(a - b);\n    return smoothstep(2.*EPSILON, EPSILON, diff);\n}\n\nfloat annulus(vec2 uv) {\n    //return smoothstep(0.1, 0., length(uv)) - smoothstep(0.05, 0., length(uv));\n    return near(length(uv), 0.05);\n}\n\nvec3 colors[6] = vec3[6](\n    vec3(1.0, 0.1, 0.1),\n    vec3(0.1, 1.0, 0.1),\n    vec3(0.1, 0.1, 1.0),\n    vec3(1.0, 1.0, 0.1),\n    vec3(1.0, 0.1, 1.0),\n    vec3(0.1, 1.0, 1.0)\n);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    float rand = fract(sin(iDate.x + iDate.y + iDate.z));\n    vec2 startPos = vec2(0.5);\n    vec2 startDir = vec2(.1, .1) * vec2(cos(rand), -sin(rand));\n    \n    vec2 dirIn = SPEED * iTime * startDir;\n    vec2 pos = startPos + vec2(\n        triWave(dirIn.x),\n        triWave(dirIn.y)\n    );\n    float ellipse = smoothstep(0.2, 0., length(uv.xy - pos));\n    \n    int colorIdx = int(floor(dirIn.x + .5) - floor(dirIn.y + .5)) % 6;\n    //int colorIdx = int(iTime) % 6;\n    vec3 color = colors[colorIdx];\n    vec3 col = color * vec3(ellipse);\n    col += message((uv - pos) * 8. + vec2(1.5, 0.));\n    col += annulus(uv - pos + vec2(0., 0.05));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdBXDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[309, 309, 332, 332, 382], [411, 411, 439, 439, 487], [489, 489, 519, 519, 600], [602, 602, 626, 707, 744], [925, 925, 980, 980, 1692]], "test": "error"}
{"id": "NdBXWd", "name": "Streamer02 line width fixed", "author": "intrometa", "description": "streamer with lines which supports positive and negative slope, line width fixed. https://en.wikipedia.org/wiki/Distance_between_two_parallel_lines", "tags": ["streamer"], "likes": 0, "viewed": 37, "published": "Public", "date": "1621247561", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define DEBUG 0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    uv.x *= ratio;\n    vec2 clickUV = iMouse.xy / iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n    \n    float k = 5.0;\n    float b = 0.0;\n    float b1 = b;\n    float kSign = 1.0;\n    float width = 0.02;\n    if (k < 0.0) kSign = -1.0;\n    float b2 = b1 - width * sqrt(k * k + 1.0) * kSign;\n    \n    float leftBound = abs((1.0 - b2) / k);\n    float totalLength = 1.0 * ratio + leftBound;; // 这个域映射时，考虑 ratio.\n    if (k < 0.0) totalLength = 1.0 * ratio + leftBound + width * 2.0;\n\n    float speed = 1.0;\n    float driver = fract(iTime / speed);\n#if DEBUG == 1\n    driver += clickUV.x; \n#endif\n    float x = uv.x + leftBound - driver * totalLength;\n    if (k < 0.0) x = uv.x - driver * totalLength + width;\n    float y = uv.y;\n    float y1 = k * x + b1;\n    float y2 = k * x + b2;\n    if (kSign > 0.0 && y < y1 && y > y2 || kSign < 0.0 && y < y2 && y > y1) col = vec3(1.0);\n    else col = vec3(0.0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdBXWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[16, 16, 73, 123, 1214]], "test": "valid"}
{"id": "NdfSRr", "name": "Inverse Reflection - Disk", "author": "oneshade", "description": "Finally learned how to transform it into a quartic polynomial with t-formulae and solved it: [url=https://www.qc.edu.hk/math/Certificate%20Level/t%20method.htm]https://www.qc.edu.hk/math/Certificate%20Level/t%20method.htm[/url]", "tags": ["reflection", "math", "light", "physics", "quartic", "optics", "inverse", "disk", "tformulae"], "likes": 12, "viewed": 74, "published": "Public", "date": "1620178940", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Formulating and simplifying the problem as an equation: https://www.desmos.com/calculator/tnxdrshgt3\n// Attempting to solve the equation: https://www.desmos.com/calculator/ybqpz6ypwy\n// Not sure how to deal with incorrect side reflections due to bad quadrant information in atan().\n// Works fine for near and far incidence points though aside from precision issues.\n\n// Drawing utilities\n#define drawSDF(dist, transp, col) color = mix(color, col, smoothstep(unit, 0.0, dist) * transp)\n\n// SDFs\nfloat sdDisc(in vec2 p, in vec2 o, in float r) {\n    return length(p - o) - r;\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nfloat sdVerticalLine(in vec2 p, in float h) {\n    return length(vec2(p.x, p.y - h * clamp(p.y / h, 0.0, 1.0)));\n}\n\nfloat sdIsosceles(in vec2 p, in float b, in float h) {\n    p.x = abs(p.x);\n    float q = clamp((b - p.x + p.y) / (b + h), 0.0, 1.0);\n    vec2 re = vec2(p.x - b + b * q, p.y - h * q);\n    vec2 be = vec2(p.x - b * min(p.x / b, 1.0), p.y);\n    return sqrt(min(dot(re, re), dot(be, be))) * sign(p.x + (p.y - h) * b / h * sign(p.y));\n}\n\nfloat sdVectorArrow(in vec2 p, in vec2 v) {\n    float m = length(v); vec2 n = v / m;\n    p = vec2(dot(p, n.yx * vec2(1.0, -1.0)), dot(p, n));\n    return min(sdVerticalLine(p, m) - 0.025, sdIsosceles(p - vec2(0.0, m), 0.1, 0.15));\n}\n\n//////////////////////////////////////////////////////////////////////////////////////\n\n// tx: transmitter\n// rx: receiver\n// pos: disk position\n// rad: disk radius\nint getIncidences(in vec2 tx, in vec2 rx, in vec2 pos, in float rad, out vec2[4] incidences) {\n    rx -= pos, tx -= pos;\n\n    vec2 tr1 = tx + rx;\n    vec2 tr2 = rx * mat2(tx.yx, tx.x, -tx.y);\n\n    float k = rad * sqrt(dot(tr1, tr1) / dot(tr2, tr2));\n    float a1 = atan(tr2.x / tr2.y), a2 = atan(tr1.y / tr1.x);\n\n    float shift = 0.5 * a1;\n    float sa = shift - a2;\n\n    vec2 bd = vec2(4.0, -4.0) / sin(sa) / k - 2.0 / tan(sa); // Coefficients (a=1, c=0, e=-1)\n    vec4 t;\n\n    // Solve a quartic equation in tan(x/2)\n    float bb = bd.x * bd.x;\n    float p = -0.375 * bb;\n    float q = bd.y + 0.125 * bb * bd.x;\n    float r = -1.0 - 0.25 * bd.x * bd.y - 0.01171875 * bb * bb;\n    int n = 0; // Root counter\n\n    // Solve for an arbitary root to x^3 + 2px^2 + (p^2 - 4r)x - q^2\n    float ra = 2.0 * p;\n    float rb = p * p - 4.0 * r;\n    float rc = -q * q;\n\n    float raa = ra * ra;\n    float inflect = ra / 3.0;\n\n    float rp = rb - raa / 3.0;\n    float rq = raa * ra / 13.5 - ra * rb / 3.0 + rc;\n    float rppp = rp * rp * rp, rqq = rq * rq;\n\n    float p2 = abs(rp);\n    float v1 = 1.5 / rp * rq;\n\n    float lambda;\n    if (rqq * 0.25 + rppp / 27.0 > 0.0) {\n        float v2 = v1 * sqrt(3.0 / p2);\n        if (rp < 0.0) lambda = sign(rq) * cosh(acosh(v2 * -sign(rq)) / 3.0);\n        else lambda = sinh(asinh(v2) / 3.0);\n        lambda = -sqrt(p2 / 3.0) * lambda;\n    }\n\n    else lambda = sqrt(-rp / 3.0) * cos(acos(v1 * sqrt(-3.0 / rp)) / 3.0);\n    lambda = 2.0 * lambda - inflect;\n\n    // Solve two quadratic equations (checking for negative sqrts which should be complex)\n    if (lambda < 0.0) return n;\n    float sqrtLambda = sqrt(lambda);\n\n    float pLambda = p + lambda, qLambda = q / sqrtLambda;\n    float offs = 0.25 * bd.x;\n\n    float foo = lambda - 2.0 * (pLambda + qLambda);\n    float bar = lambda - 2.0 * (pLambda - qLambda);\n\n    if (foo >= 0.0) {\n        vec2 qRoots = atan((vec2(1.0, -1.0) * sqrt(foo) + sqrtLambda) * 0.5 - offs) * 2.0 + shift;\n\n        incidences[0] = vec2(cos(qRoots.x), sin(qRoots.x)) * rad + pos;\n        incidences[1] = vec2(cos(qRoots.y), sin(qRoots.y)) * rad + pos;\n\n        n += 2;\n    }\n\n    if (bar >= 0.0) {\n        vec2 qRoots = atan((vec2(1.0, -1.0) * sqrt(bar) - sqrtLambda) * 0.5 - offs) * 2.0 + shift;\n\n        incidences[n    ] = vec2(cos(qRoots.x), sin(qRoots.x)) * rad + pos;\n        incidences[n + 1] = vec2(cos(qRoots.y), sin(qRoots.y)) * rad + pos;\n\n        n += 2;\n    }\n\n    return n;\n}\n\n//////////////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n\n    vec4 mouse = (vec4(iMouse.xy, abs(iMouse.zw)) - center.xyxy) / iResolution.y * 4.0;\n    vec2 uv = (fragCoord - center) / iResolution.y * 4.0;\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    float unit = 8.0 / iResolution.y;\n\n    // Default if mouse is not set\n    if (ivec2(iMouse.xy) == ivec2(0)) {\n        mouse = vec4(2.541, 0.722, 0.402, 1.638);\n    }\n\n    vec2 light = mouse.zw;\n    vec2 point = mouse.xy;\n\n    vec2 reflectorPos = vec2(0.0, 0.0);\n    float reflectorRadius = 1.0 + 0.25 * sin(iTime);\n\n    // Draw the reflector\n    drawSDF(sdDisc(uv, reflectorPos, reflectorRadius) - 0.01, 1.0, vec3(0.0, 0.0, 1.0));\n\n    // Draw light path\n    vec2[4] i;\n    int n = getIncidences(light, point, reflectorPos, reflectorRadius, i);\n    for (int k=0; k < n; k++) {\n        vec2 fromLight = i[k] - light;\n        vec2 toPoint = point - i[k];\n        drawSDF(sdVectorArrow(uv - light, fromLight - normalize(fromLight) * 0.2) + 0.01, 1.0, vec3(1.0));\n        drawSDF(sdVectorArrow(uv - i[k], toPoint - normalize(toPoint) * 0.2) + 0.01, 1.0, vec3(1.0));\n    }\n\n    // Draw light, point, and incident point\n    drawSDF(sdDisc(uv, light, 0.05), 1.0, vec3(0.0, 1.0, 0.0));\n    drawSDF(sdDisc(uv, point, 0.05), 1.0, vec3(1.0, 0.0, 0.0));\n    for (int k=0; k < n; k++) {\n        drawSDF(sdDisc(uv, i[k], 0.05), 1.0, vec3(1.0, 0.8, 0.0));\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdfSRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[489, 497, 545, 545, 577], [579, 579, 626, 626, 734], [736, 736, 781, 781, 849], [851, 851, 905, 905, 1181], [1183, 1183, 1226, 1226, 1414]], "test": "valid"}
{"id": "NdjSWW", "name": "surprised face (my first creati)", "author": "Roboticol", "description": "this is my first creation, hoped you liked it!", "tags": ["2d", "blackandwhite", "face", "emoji", "surprised"], "likes": 1, "viewed": 42, "published": "Public", "date": "1620241697", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Circle(vec2 uv, vec2 p, float r, float blur)\n{\n    \n    float d = length(uv - p);\n      \n    float c = smoothstep(r, r-blur, d);\n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 col = vec3(1,1,1); \n\n    float c = Circle(uv, vec2(0.0,0), .5, .0001);\n    c -= Circle(uv, vec2(-0.2, 0.3), .1, .0001);\n    c -= Circle(uv, vec2(0.2, 0.3), .1, .0001);\n    c -= Circle(uv, vec2(0.01 * sin(iTime), 0), .2, .0001);\n\n\n    col = vec3(1,1,0) * c;\n\n    // Output to screen\n    fragColor = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdjSWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 52, 155], [157, 157, 214, 264, 688]], "test": "valid"}
{"id": "NdjXWm", "name": "Rotating Meander", "author": "nowhales", "description": "A circular rotating Greek meander pattern.\n\nVersion1: Veeery slow, my first time writing glsl, best not use this as a reference :). I'm following thebookofshaders.com.\nVersion2: Went from 32 to 60fps on my laptop.", "tags": ["circular", "greek", "meander"], "likes": 10, "viewed": 80, "published": "Public", "date": "1620379933", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define VERSION (2)\n\n#if VERSION == 2\n#define PI (3.14159)\n\nfloat circle(in vec2 uv, in float radius)\n{\n    return smoothstep(radius+(radius*0.001),\n                      radius-(radius*0.001),\n                      dot(uv, uv) * 4.0);\n}\n\nmat2 rotate2d(in float angle)\n{\n    return mat2(cos(angle), -sin(angle),\n                sin(angle), cos(angle));\n}\n\nfloat circleOutline(in vec2 uv, in float outerRadius, in float innerRadius)\n{\n    return min(circle(uv, outerRadius), (1.0-circle(uv, innerRadius)));\n}\n\n#define LAYERS (5)\n#define STEPS (16)\n#define REPS (8)\n\nfloat pattern(int y, int x)\n{\n    if(x < 0 || x >= STEPS) return 0.;\n    if(y < 0 || y >= LAYERS) return 0.;\n#if 0\n    float p[STEPS*LAYERS] = float[STEPS*LAYERS](\n        1., 1., 1., 1., 1., 0., 1., 1., 1., 0., 1., 0., 1., 1., 1., 0.,\n        1., 0., 0., 0., 1., 0., 1., 0., 1., 0., 1., 0., 1., 0., 1., 0.,\n        1., 0., 1., 0., 1., 0., 1., 0., 1., 0., 1., 0., 1., 0., 1., 0.,\n        1., 0., 1., 0., 1., 0., 1., 0., 1., 0., 1., 0., 1., 0., 0., 0.,\n        1., 0., 1., 1., 1., 0., 1., 0., 1., 1., 1., 0., 1., 1., 1., 1.\n    );\n    return p[y * STEPS + x];\n#else\n    if(x == 5 || x == 11) return 0.;\n    if(x == 0 || x == 4 || x == 6 || x == 8 || x == 10 || x == 12) return 1.;\n    if(x == 1 && y != 0) return 0.;\n    if(x == 2 && y == 1) return 0.;\n    if(x == 3 && (y != 0 && y != 4)) return 0.;\n    if(x == 7 && y != 0) return 0.;\n    if(x == 9 && y != 4) return 0.;\n    if(x == 13 && (y != 0 && y != 4)) return 0.;\n    if(x == 14 && y == 3) return 0.;\n    if(x == 15 && y != 4) return 0.;\n    \n    return 1.0;\n#endif\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.x;\n    vec2 origuv = uv;\n    uv = rotate2d(iTime/8.) * uv;\n    \n    float pat = atan(uv.x, uv.y) / (2.0*PI) + 0.5;\n    int idx = int(floor(fract(pat * float(REPS)) * float(STEPS)));\n\n    // First pattern\n    float outer = 0.3;\n    float inner = 0.15;\n    float y = (dot(uv, uv) * 4.0 - inner) / (outer - inner);\n    int idy = int(floor(y * float(LAYERS)));\n    \n    float on = pattern(idy, idx) * circleOutline(uv, outer, inner);\n    vec3 col1 = on * vec3(1.0, 0.4, 0.2);\n    \n    // Second pattern\n    outer = 0.14;\n    inner = 0.085;\n    uv = rotate2d(-iTime/16.0) * origuv;\n    pat = atan(uv.x, uv.y) / (2.0*PI) + 0.5;\n    idx = int(floor(fract(pat * float(REPS)) * float(STEPS)));\n    y = (dot(uv, uv) * 4.0 - inner) / (outer - inner);\n    idy = int(floor(y * float(LAYERS - 1)) + 1.);\n    \n    on = pattern(idy, idx) * circleOutline(uv, outer, inner);\n    vec3 col2 = vec3(on);\n    \n    vec3 color = col1 + col2;\n    fragColor = vec4(color, 1.0);\n}\n#endif\n\n\n\n#if VERSION == 1\n\n#define PI (3.14159)\n\nfloat circle(in vec2 st, in float radius)\n{\n\treturn smoothstep(radius+(radius*0.001),\n                      radius-(radius*0.001),\n                      dot(st,st)*4.0);\n}\n\nmat2 rotate2d(float angle)\n{\n    return mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle));\n}\n\nfloat circleOutline(in vec2 st, in float radius, in float width)\n{\n    return min(circle(st, radius), (1.0-circle(st, radius - width)));\n}\n\nfloat mask(in vec2 uv, in float angle, in float width)\n{\n    uv = rotate2d(angle) * uv;\n    float slice = smoothstep(0.0, 0.001, uv.x);\n    uv = rotate2d(width) * uv;\n    slice -= smoothstep(0.0, 0.001, uv.x);\n    slice = abs(slice);\n    return slice;\n}\n\nfloat layer(in vec2 uv, in float[34] arr, in int start, in int arrlen, in float lw,\n            in int ln, in int repeat, in float patlen, in float unit, in float circSize)\n{\n    float pat = circleOutline(uv, circSize * (1.0 - lw*float(ln)), circSize*lw);\n    for(int i = start; i < start + arrlen; ++i)\n    {\n        vec2 uv2 = uv;\n        for(int j = 0; j < repeat; ++j)\n        {\n            pat -= mask(uv2, arr[i]*unit, unit);\n            uv2 = rotate2d(patlen) * uv2;\n        }\n    }\n    return clamp(pat, 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.x;\n    vec2 origuv = uv;\n\n    uv = rotate2d(iTime/8.) * uv;\n\n    // half circle repeats\n    int repeat = 4;\n    int steps = 16;\n    float lw = 0.1;\n\n    float patlen = PI / float(repeat);\n    float unit = patlen / float(steps);\n\n    float pattern[34] = float[34](\n        5., 9., 11., 15.,\n        1., 2., 3., 5., 7., 9., 11., 13., 15.,\n        1., 3., 5., 7., 9., 11., 13., 15.,\n        1., 3., 5., 7., 9., 11., 13., 14., 15.,\n        1., 5., 7., 11.\n    );\n\n    int layers[5] = int[5](4, 9, 8, 9, 4);\n    float pat = 0.0;\n    int off = 0;\n    for(int i = 0; i < 5; ++i)\n    {\n        pat += layer(uv, pattern, off, layers[i], lw, i, repeat, patlen, unit, 0.3);\n        off += layers[i];\n    }\n    \n    uv = rotate2d(-iTime/16.) * origuv;\n    \n    float pat2 = 0.0;\n    off = 0;\n    for(int i = 0; i < 4; ++i)\n    {\n        pat2 += layer(uv, pattern, off, layers[i], lw, i, repeat, patlen, unit, 0.14);\n        off += layers[i];\n    }\n\n    vec3 color = vec3(pat) * vec3(1.0, 0.4, 0.2);\n    color += vec3(pat2);\n\n    fragColor = vec4(color,1.0);\n}\n#endif\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdjXWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "valid"}
{"id": "NdSSRG", "name": "Beat  spiral", "author": "NikolaErceg", "description": "variation of \"twisting rose\"", "tags": ["procedural", "spiral", "illusion", "glitch", "hypnotic", "polar", "colordistortion"], "likes": 1, "viewed": 168, "published": "Public API", "date": "1620411368", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SPEED 12.0\n\n#define RAYS 12.0\n\n#define RING_PERIOD 129.0\n\n#define TWIST_FACTOR 0.72\n\nfloat getColorComponent(float dist, float angle) {\n    return\n        pow((\n            (\n            \tcos(\n                    (angle * RAYS)\n            \t\t+ pow(\n                        dist * 0.79,\n                \t\t(sin(iTime * SPEED) * TWIST_FACTOR)\n            \t\t) * 3.0\n        \t\t) + sin(\n            \t\tdist * RING_PERIOD\n        \t\t)\n        \t) + 1.6\n        ) / 2.0, 3.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 delta = (fragCoord -.5 * iResolution.xy) / iResolution.y;\n    float dist = length(delta),\n    angle = atan(delta.x, delta.y);\n    fragColor = vec4(\n        getColorComponent(dist, angle),\n        getColorComponent(dist * 0.0005, angle),        \n        getColorComponent(dist * 0.07, angle),\n        5.0\n    );\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdSSRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[93, 93, 143, 143, 475], [477, 477, 532, 532, 854]], "test": "valid"}
{"id": "NdSSRy", "name": "Material Maker Experiment 003", "author": "PauloFalcao", "description": "Generated using the node based material maker using my raymarching lib (see code comments)\nYoutube video making this https://youtu.be/VzV9zOzzUVA", "tags": ["generated", "materialmaker", "nodes"], "likes": 12, "viewed": 312, "published": "Public API", "date": "1620425599", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Material Maker Experiment 003\n// By PauloFalcao\n//\n// Made in the node base material maker\n//\n// Youtube video making this https://youtu.be/VzV9zOzzUVA\n//\n// MaterialMaker is a nodebased shader maker to make procedural textures\n// With custom nodes GLSL nodes created directly in the tool,\n// it's possible to make complex stuff like raymarching :)\n//\n// It's also possible to export the generated code to Shadertoy!\n//\n// I made a library with Ray Marching nodes\n// 1st version 0.01 have 44 new nodes\n// Some nodes are based in code from other authors from shadertoy\n// I always refer the shader author and the shadertoy original code\n// The idea is to reuse the code to quicky create something without coding experience\n// Or just focus on the code of a single node\n//\n// You need Material Maker - https://rodzilla.itch.io/material-maker\n// And my library - https://github.com/paulofalcao/MaterialMakerRayMarching\n// \n// The Material Maker source is here\n//    https://github.com/paulofalcao/MaterialMakerRayMarching/blob/main/Examples/pxf003.mms\n// Just copy-paste into Material Maker\n\nfloat sdSmoothXYUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nvec3 rotate3d(vec3 p, vec3 a) {\n\tvec3 rv;\n\tfloat c;\n\tfloat s;\n\tc = cos(a.x);\n\ts = sin(a.x);\n\trv.x = p.x;\n\trv.y = p.y*c+p.z*s;\n\trv.z = -p.y*s+p.z*c;\n\tc = cos(a.y);\n\ts = sin(a.y);\n\tp.x = rv.x*c+rv.z*s;\n\tp.y = rv.y;\n\tp.z = -rv.x*s+rv.z*c;\n\tc = cos(a.z);\n\ts = sin(a.z);\n\trv.x = p.x*c+p.y*s;\n\trv.y = -p.x*s+p.y*c;\n\trv.z = p.z;\n\treturn rv;\n}\n\nconst float PI=3.14159265359;\n\nvec2 equirectangularMap(vec3 dir) {\n\tvec2 longlat = vec2(atan(dir.y,dir.x),acos(dir.z));\n \treturn longlat/vec2(2.0*PI,PI);\n}\n\n\n//Simple HDRI START\n\n//Hash without Sine Dave_Hoskins\n//https://www.shadertoy.com/view/4djSRW \nfloat Simple360HDR_hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat Simple360HDR_noise(vec2 v){\n  vec2 v1=floor(v);\n  vec2 v2=smoothstep(0.0,1.0,fract(v));\n  float n00=Simple360HDR_hash12(v1);\n  float n01=Simple360HDR_hash12(v1+vec2(0,1));\n  float n10=Simple360HDR_hash12(v1+vec2(1,0));\n  float n11=Simple360HDR_hash12(v1+vec2(1,1));\n  return mix(mix(n00,n01,v2.y),mix(n10,n11,v2.y),v2.x);\n}\n\nfloat Simple360HDR_noiseOct(vec2 p){\n  return\n    Simple360HDR_noise(p)*0.5+\n    Simple360HDR_noise(p*2.0+13.0)*0.25+\n    Simple360HDR_noise(p*4.0+23.0)*0.15+\n    Simple360HDR_noise(p*8.0+33.0)*0.10+\n    Simple360HDR_noise(p*16.0+43.0)*0.05;\n}\n\nvec3 Simple360HDR_skyColor(vec3 p){\n\tvec3 s1=vec3(0.2,0.5,1.0);\n\tvec3 s2=vec3(0.1,0.2,0.4)*1.5;\n    vec3 v=(Simple360HDR_noiseOct(p.xz*0.1)-0.5)*vec3(1.0);\n\tfloat d=length(p);\n    return mix(s2+v,s1+v*(12.0/max(d,20.0)),clamp(d*0.1,0.0,1.0));\n}\n\nvec3 Simple360HDR_floorColor(vec3 p){\n    vec3 v=(Simple360HDR_noiseOct(p.xz*0.1)*0.5+0.25)*vec3(0.7,0.5,0.4);\n    return v;\n}\n\nvec3 Simple360HDR_renderHDR360(vec3 rd, vec3 sun){\n    vec3 col;\n\tvec3 p;\n\tvec3 c;\n\tif (rd.y>0.0) {\n        p=rd*(5.0/rd.y);\n        c=Simple360HDR_skyColor(p);\n    } else {\n        p=rd*(-10.0/rd.y);\n        c=Simple360HDR_floorColor(p);\n\t\tc=mix(c,vec3(0.5,0.7,1.0),clamp(1.0-sqrt(-rd.y)*3.0,0.0,1.0));\n\t}\n\tvec3 skycolor=vec3(0.1,0.45,0.68);\n\tfloat d=length(p);\n\t\n\tfloat ds=clamp(dot(sun,rd),0.0,1.0);\n\tvec3 sunc=(ds>0.9997?vec3(2.0):vec3(0.0))+pow(ds,512.0)*4.0+pow(ds,128.0)*vec3(0.5)+pow(ds,4.0)*vec3(0.5);\n    if (rd.y>0.0){\n\t\tc+=vec3(0.3)*pow(1.0-abs(rd.y),3.0)*0.7;\n\t} \n    return c+sunc;\n}\n\nvec3 Simple360HDR_make360hdri(vec2 p, vec3 sun){\n    float xPI=3.14159265359;\n    vec2 thetaphi = ((p * 2.0) - vec2(1.0)) * vec2(xPI,xPI/2.0); \n    vec3 rayDirection = vec3(cos(thetaphi.y) * cos(thetaphi.x), sin(thetaphi.y), cos(thetaphi.y) * sin(thetaphi.x));\n    return Simple360HDR_renderHDR360(rayDirection,sun);\n}\n//Simple HDRI END\n\nconst float p_o349467_CamY = 0.997000000;\nconst float p_o349467_LookAtX = 0.000000000;\nconst float p_o349467_LookAtY = -0.266000000;\nconst float p_o349467_LookAtZ = 0.000000000;\nconst float p_o349467_CamD = 1.825000000;\nconst float p_o349467_CamZoom = 0.977000000;\nconst float p_o349467_Reflection = 0.200000000;\nconst float p_o349467_Specular = 0.000000000;\nconst float p_o349467_Pow = 64.000000000;\nconst float p_o349467_SunX = 2.500000000;\nconst float p_o349467_SunY = 2.500000000;\nconst float p_o349467_SunZ = 1.000000000;\nconst float p_o349467_AmbLight = 0.250000000;\nconst float p_o349467_AmbOcclusion = 0.502000000;\nconst float p_o349467_Shadow = 1.000000000;\nconst float p_o538946_s = 0.330000000;\nconst float p_o528578_x = 0.000000000;\nconst float p_o528578_y = -1.000000000;\nconst float p_o528578_z = 0.000000000;\nconst float p_o663512_r = 1.270000000;\n\nfloat o360551_input_obj3d(vec3 p) {\n    float o663512_0_1_sdf3d = length((p))-p_o663512_r;\n    return o663512_0_1_sdf3d;\n}\n\nconst float p_o373061_x = 1.000000000;\nconst float p_o373061_y = 1.000000000;\nconst float p_o373061_z = 1.000000000;\nconst float p_o382957_xyz = 0.452000000;\nconst float p_o382957_x = 1.000000000;\nconst float p_o382957_y = 1.000000000;\nconst float p_o382957_z = 1.000000000;\n\nvec4 o360551_input_trans3d(vec4 p) {\n    vec4 o370386_0_1_v4v4 = (vec4(rotate3d((vec4((vec4((vec4(vec3(sqrt((p).xyz*(p).xyz+(sin(iTime*0.2)*0.2+0.2))),(p).w)).xyz-vec3(p_o373061_x, p_o373061_y, p_o373061_z),(vec4(vec3(sqrt((p).xyz*(p).xyz+(sin(iTime*0.2)*0.2+0.2))),(p).w)).w)).xyz/vec3(p_o382957_x, p_o382957_y, p_o382957_z)/p_o382957_xyz,(vec4((vec4(vec3(sqrt((p).xyz*(p).xyz+(sin(iTime*0.2)*0.2+0.2))),(p).w)).xyz-vec3(p_o373061_x, p_o373061_y, p_o373061_z),(vec4(vec3(sqrt((p).xyz*(p).xyz+(sin(iTime*0.2)*0.2+0.2))),(p).w)).w)).w)).xyz, -vec3((sin(iTime*0.05)*360.0), (sin(iTime*0.07)*360.0), (sin(iTime*0.03)*360.0))*0.01745329251), (vec4((vec4((vec4(vec3(sqrt((p).xyz*(p).xyz+(sin(iTime*0.2)*0.2+0.2))),(p).w)).xyz-vec3(p_o373061_x, p_o373061_y, p_o373061_z),(vec4(vec3(sqrt((p).xyz*(p).xyz+(sin(iTime*0.2)*0.2+0.2))),(p).w)).w)).xyz/vec3(p_o382957_x, p_o382957_y, p_o382957_z)/p_o382957_xyz,(vec4((vec4(vec3(sqrt((p).xyz*(p).xyz+(sin(iTime*0.2)*0.2+0.2))),(p).w)).xyz-vec3(p_o373061_x, p_o373061_y, p_o373061_z),(vec4(vec3(sqrt((p).xyz*(p).xyz+(sin(iTime*0.2)*0.2+0.2))),(p).w)).w)).w)).w));\n    vec4 o371615_0_1_v4v4 = o370386_0_1_v4v4;\n    vec4 o_o382957_0=o371615_0_1_v4v4;vec4 o382957_0_1_v4v4 = vec4(o_o382957_0.xyz,(vec4((vec4(vec3(sqrt((p).xyz*(p).xyz+(sin(iTime*0.2)*0.2+0.2))),(p).w)).xyz-vec3(p_o373061_x, p_o373061_y, p_o373061_z),(vec4(vec3(sqrt((p).xyz*(p).xyz+(sin(iTime*0.2)*0.2+0.2))),(p).w)).w)).w/min(min(p_o382957_x, p_o382957_y), p_o382957_z)/p_o382957_xyz);\n    vec4 o373061_0_1_v4v4 = o382957_0_1_v4v4;\n    vec4 o391263_0_1_v4v4 = o373061_0_1_v4v4;\n    return o391263_0_1_v4v4;\n}\n\nconst float p_o694452_k = 0.010000000;\n\nfloat o360551_input_custombool(vec2 uv) {\n    float o694452_0_1_sdf2d = sdSmoothXYUnion((uv).x, (uv).y, p_o694452_k);\n    return o694452_0_1_sdf2d;\n}\n\nfloat for_custom_o360551(vec4 p) {\n  float d=o360551_input_obj3d(p.xyz);\n  float m=o360551_input_custombool(vec2(999999.0,d));\n  for(int i=0;i<6;i++){\n    p=o360551_input_trans3d(p);\n\td=o360551_input_obj3d(p.xyz);\n\tm=o360551_input_custombool(vec2(m,d/p.w));\n  }\n  return m;\n}\n\nfloat o349467_input_sdf_a(vec3 p) {\n    float o360551_0_1_sdf3d = for_custom_o360551(vec4((rotate3d(((((p))/p_o538946_s)-vec3(p_o528578_x, p_o528578_y, p_o528578_z)), -vec3((iTime*21.0), (iTime*27.0), (iTime*23.0))*0.01745329251)),1.0));\n    vec2 o512498_0_1_sdf3dc = vec2(o360551_0_1_sdf3d, 0.0);\n    vec2 o528578_0_1_sdf3dc = o512498_0_1_sdf3dc;\n    vec2 o538946_0_in = o528578_0_1_sdf3dc;vec2 o538946_0_1_sdf3dc = vec2(o538946_0_in.x*p_o538946_s, o538946_0_in.y);\n    return (o538946_0_1_sdf3dc).x;\n}\n\nvec3 o349467_input_tex3d_a(vec4 p) {\n    return vec3(1.0,0.1,0.1);\n}\n\nfloat o349467_input_sdf_b(vec3 p) {\n    return max((p).y+1.0,length(vec3((p).x,(p).y+1.0,(p).z))-10.0);\n}\n\nvec3 o349467_input_tex3d_b(vec4 p) {\n    return vec3(mod(floor((p).x*2.0)+floor((p).z*2.0),2.0))*0.9+0.1;\n}\n\nvec3 o349467_input_hdri(vec2 uv) {\n    return Simple360HDR_make360hdri(vec2((uv).x,-(uv).y+1.0),normalize(vec3(-p_o349467_SunX,p_o349467_SunY,-p_o349467_SunZ)));\n}\n\nvec2 input_o349467(vec3 p) {\n    float sdfa=o349467_input_sdf_a(p);\n\tfloat sdfb=o349467_input_sdf_b(p);\n\tif (sdfa<sdfb) {\n\t  return vec2(sdfa,0.0);\n\t} else {\n\t  return vec2(sdfb,1.0);\n\t}\n}\n\n//tetrahedron normal by PauloFalcao\n//https://www.shadertoy.com/view/XstGDS\nvec3 normal_o349467(vec3 p){  \n  const vec3 e=vec3(0.001,-0.001,0.0);\n  float v1=input_o349467(p+e.xyy).x;\n  float v2=input_o349467(p+e.yyx).x;\n  float v3=input_o349467(p+e.yxy).x;\n  float v4=input_o349467(p+e.xxx).x;\n  return normalize(vec3(v4+v1-v3-v2,v3+v4-v1-v2,v2+v4-v3-v1));\n}\n\nvoid march_o349467(inout float d,inout vec3 p,inout vec2 dS, vec3 ro, vec3 rd){\n    for (int i=0; i < 500; i++) {\n    \tp = ro + rd*d;\n        dS = input_o349467(p);\n        d += dS.x;\n        if (d > 50.0 || abs(dS.x) < 0.0001) break;\n    }\n}\n\n//from https://www.shadertoy.com/view/lsKcDD\nfloat calcAO_o349467( in vec3 pos, in vec3 nor ){\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ ){\n        float h = 0.001 + 0.25*float(i)/4.0;\n        float d = input_o349467( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.98;\n    }\n    return clamp( 1.0 - 1.6*occ, 0.0, 1.0 );    \n}\n\n//from https://www.shadertoy.com/view/lsKcDD\nfloat calcSoftshadow_o349467( in vec3 ro, in vec3 rd, in float mint, in float tmax){\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    for( int i=0; i<32; i++ ){\n\t\tfloat h = input_o349467( ro + rd*t ).x;\n        res = min( res, 10.0*h/t );\n        t += h;\n        if( res<0.0001 || t>tmax ) break;  \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 raymarch_o349467(vec2 uv) {\n    uv-=0.5;\n\tvec3 cam=vec3((sin(sin(iTime*0.2)*0.5+0.5)*4.0),p_o349467_CamY,(sin(sin(iTime*0.3)*0.5+0.5)*4.0))*p_o349467_CamZoom;\n\tvec3 lookat=vec3(p_o349467_LookAtX,p_o349467_LookAtY,p_o349467_LookAtZ);\n\tvec3 ray=normalize(lookat-cam);\n\tvec3 cX=normalize(cross(vec3(0.0,1.0,0.0),ray));\n\tvec3 cY=normalize(cross(cX,ray));\n\tvec3 rd = normalize(ray*p_o349467_CamD+cX*uv.x+cY*uv.y);\n\tvec3 ro = cam;\n\t\n\tfloat d=0.;\n\tvec3 p=vec3(0);\n\tvec2 dS=vec2(0);\n\tmarch_o349467(d,p,dS,ro,rd);\n\t\n    vec3 color=vec3(0.0);\n\tvec3 objColor=(dS.y<0.5)?o349467_input_tex3d_a(vec4(p,1.0)):o349467_input_tex3d_b(vec4(p,1.0));\n\tvec3 light=normalize(vec3(p_o349467_SunX,p_o349467_SunY,p_o349467_SunZ));\n\tif (d<50.0) {\n\t    vec3 n=normal_o349467(p);\n\t\tfloat l=clamp(dot(-light,-n),0.0,1.0);\n\t\tvec3 ref=normalize(reflect(rd,-n));\n\t\tfloat r=clamp(dot(ref,light),0.0,1.0);\n\t\tfloat cAO=mix(1.0,calcAO_o349467(p,n),p_o349467_AmbOcclusion);\n\t\tfloat shadow=mix(1.0,calcSoftshadow_o349467(p,light,0.05,5.0),p_o349467_Shadow);\n\t\tcolor=min(vec3(max(shadow,p_o349467_AmbLight)),max(l,p_o349467_AmbLight))*max(cAO,p_o349467_AmbLight)*objColor+pow(r,p_o349467_Pow)*p_o349467_Specular;\n\t\t//reflection\n\t\td=0.01;\n\t\tmarch_o349467(d,p,dS,p,ref);\n\t\tvec3 objColorRef=vec3(0);\n\t\tif (d<50.0) {\n\t\t\tobjColorRef=(dS.y<0.5)?o349467_input_tex3d_a(vec4(p,1.0)):o349467_input_tex3d_b(vec4(p,1.0));\n\t\t\tn=normal_o349467(p);\n\t\t\tl=clamp(dot(-light,-n),0.0,1.0);\n\t\t\tobjColorRef=max(l,p_o349467_AmbLight)*objColorRef;\n\t\t} else {\n\t\t\tobjColorRef=o349467_input_hdri(equirectangularMap(ref.xzy)).xyz;\n\t\t}\n\t\tcolor=mix(color,objColorRef,p_o349467_Reflection);\n\t} else {\n\t\tcolor=o349467_input_hdri(equirectangularMap(rd.xzy)).xyz;\n\t}\n\treturn color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float minSize = min(iResolution.x, iResolution.y);\n    vec2 UV = vec2(0.0, 1.0) + vec2(1.0, -1.0) * (fragCoord-0.5*(iResolution.xy-vec2(minSize)))/minSize;\n    vec3 o349467_0_1_rgb = raymarch_o349467((UV));\n    fragColor = vec4(o349467_0_1_rgb, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdSSRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1092, 1092, 1146, 1146, 1245], [1247, 1247, 1278, 1278, 1582], [1615, 1615, 1650, 1650, 1739], [1763, 1837, 1872, 1872, 1989], [1991, 1991, 2024, 2024, 2320], [2322, 2322, 2358, 2358, 2565], [2567, 2567, 2602, 2602, 2811], [2813, 2813, 2850, 2850, 2939], [2941, 2941, 2991, 2991, 3538], [3540, 3540, 3588, 3588, 3858], [4742, 4742, 4777, 4777, 4864], [5142, 5142, 5178, 5178, 6750], [6792, 6792, 6833, 6833, 6941], [6943, 6943, 6977, 6977, 7218], [7220, 7220, 7255, 7255, 7723], [7725, 7725, 7761, 7761, 7793], [7795, 7795, 7830, 7830, 7900], [7902, 7902, 7938, 7938, 8009], [8011, 8011, 8045, 8045, 8174], [8176, 8176, 8204, 8204, 8364], [8366, 8442, 8470, 8470, 8724], [8726, 8726, 8805, 8805, 8968], [8970, 9015, 9064, 9064, 9332], [9334, 9379, 9463, 9463, 9781], [9783, 9783, 9815, 9815, 11497], [11499, 11499, 11554, 11554, 11811]], "test": "valid"}
{"id": "NdSSWz", "name": "Multi-material blending V2", "author": "RogerB", "description": "Blending of an arbitrary number of materials in a way that's compatible with textures, reflections, and material properties.", "tags": ["raymarching", "sdf", "blending"], "likes": 2, "viewed": 132, "published": "Public API", "date": "1620875162", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// SHARED CONSTANTS\n\nconst float VERTICAL_FOV = 60.f;\n\n// How far away from the surface counts as 0.\nconst float MARCH_EPS = 0.00001;\n\n// How far to move away from the surface of the shape before marching reflections and shadows so the march doesn't get stuck near the surface.\nconst float T_EPS = MARCH_EPS * 2.;\nconst float NORMAL_EPS = MARCH_EPS * 2.;\n\n// How large of a step to use when computing the gradient.\nconst float GRADIENT_EPS = 0.001;\n\n// How low of a transmittance to use as a cutoff for reflections.\nconst float REFLECTION_EPS = 0.001;\n\nconst float FAR_CLIP = 100.;\nconst int MAX_MARCH_STEPS = 256;\n\n// Maximum number of reflections. Total number of casts = 1+MAX_REFLECTIONS.\nconst int MAX_REFLECTIONS = 5;\n\nconst float PI = 3.1416;\n\n// CAMERA MATH\n\nvec3 computeCameraRay (vec3 eye, vec3 target, vec2 uv) {\n    vec3 look = target - eye;\n    float lookLen = length(look);\n    vec3 xDir = normalize(cross(look, vec3(0, 1, 0)));\n    vec3 yDir = normalize(cross(xDir, look));\n    \n    // Distance to move in world-space to move one unit in screen-space.\n    float unitDist = tan(VERTICAL_FOV/2. * PI/180.) * lookLen;\n    \n    vec3 rayTarget = target + unitDist*(xDir*uv.x + yDir*uv.y);\n    return normalize(rayTarget - eye);\n}\n\n// MATERIALS\n\n// An earlier version represented materials in SdResult as a vector of material weights, with one component for each material in the scene.\n// Storing/blending material properties directly scales better for scenes with many textures.\nstruct Mat {\n    vec3 diffuseCol;\n    vec3 specularCol;\n    float shininess;\n    float reflectivity;\n};\n\nconst Mat red = Mat(vec3(0.2, 0.02, 0.02), vec3(0.04, 0.02, 0.02), 32.0, 0.0);\nconst Mat green = Mat(vec3(0.02, 0.2, 0.02), vec3(0.02, 0.04, 0.02), 32.0, 0.0);\nconst Mat blue = Mat(vec3(0.02, 0.02, 0.2), vec3(0.02, 0.02, 0.04), 32.0, 0.0);\nconst Mat mirror = Mat(vec3(0.01), vec3(0.09), 64., 0.9);\n\nMat floorMat(vec3 pos) {\n    vec3 white = vec3(0.3);\n    vec3 black = vec3(0.025);\n    \n    // Smoothstep for antialising; smooth more strongly further out.\n    // TODO: Antialias better. (Idea: Compute screen-space distance (in pixels?) to the other color and blend using that.)\n    float smoothstepSize = 0.005;\n    float scale = max(10., pow(length(pos), 1.3));\n    vec2 tile2D = smoothstep(-smoothstepSize, smoothstepSize, sin(pos.xz * PI) / scale);\n    float tile = min(max(tile2D.x, tile2D.y), max(1.-tile2D.x,1.-tile2D.y)); // Fuzzy xor.\n    vec3 color = mix(white, black, tile);\n    \n    return Mat(color,vec3(0.03), 128.0, 0.0);\n}\n\n// SCENE DEFINITION\n\nstruct SdResult {\n    float dist;\n    Mat mat;\n};\n\nfloat sdSphere(float r, vec3 p) {\n    return length(p) - r;\n}\n\nfloat sdPlane(float height, vec3 p) {\n    return p.y - height;\n}\n\nfloat largest(vec3 a) {\n    return max(a.x, max(a.y, a.z));\n}\n\nfloat sdBox(vec2 r, vec2 p) {\n    vec2 d = abs(p) - r;\n    float exterior = length(max(d, 0.));\n    float interior = min(max(d.x,d.y), 0.);\n    return exterior + interior;\n}\n\nfloat sdBox(vec3 r, vec3 p) {\n    vec3 d = abs(p) - r;\n    float exterior = length(max(d, 0.));\n    float interior = min(largest(d), 0.);\n    return exterior + interior;\n}\n\nfloat sdCylinder(vec2 r, vec3 p) {\n    return sdBox(r, vec2(length(p.xz), p.y));\n}\n\nSdResult sdUnion(SdResult a, SdResult b) {\n    if (a.dist < b.dist) return a; else return b;\n}\n\nMat blend(Mat a, Mat b, float k) {\n    return Mat(\n        mix(a.diffuseCol, b.diffuseCol, k),\n        mix(a.specularCol, b.specularCol, k),\n        mix(a.shininess, b.shininess, k),\n        mix(a.reflectivity, b.reflectivity, k)\n    );\n}\n\n// TODO: Generalize exponential smoothmin to work with multiple terms, each with their own smoothing coefficient.\n// (Start by deriving an asymmetrical smoothmin for two terms, then generalize it to n terms.)\n\n// k.x is the factor used for blending shape; ky is the factor for blending material.\nSdResult sminCubic(SdResult a, SdResult b, vec2 k) {\n    k = max(k, 0.0001);\n    vec2 h = max(k - abs(a.dist - b.dist), 0.0)/k;\n    vec2 m = h * h * h * 0.5;\n    vec2 s = m * k * (1.0 / 3.0);\n    \n    SdResult res;\n    bool aCloser = a.dist < b.dist;\n    res.dist = (aCloser ? a.dist : b.dist) - s.x;\n    float blendCoeff = aCloser ? m.y : 1.0-m.y;\n    \n    res.mat = blend(a.mat, b.mat, blendCoeff);\n    return res;\n}\n\nSdResult sminCubic(SdResult a, SdResult b, float k) {\n    return sminCubic (a, b, vec2(k));\n}\n\nvec3 rot45(vec3 p) {\n    const float ROOT_2_OVER_2 = 0.70710678118;\n    return vec3(ROOT_2_OVER_2 * (p.x - p.z), p.y, ROOT_2_OVER_2 * (p.x + p.z));\n}\n\n// I'm reasonably certain that the material calculations get optimized away by the compiler in cases where only the distance is used.\n// If this isn't the case, the optimization could be done manually by making a version of this function that only computes the distance.\nSdResult sdScene(vec3 p) {\n    float time = iTime - 2.8; // Add an offset to the current time so the thumbnail at time 0 looks good.\n    vec3 sphere1Pos = vec3(0, 0.5, 0);\n    SdResult sphere1 = SdResult(sdSphere(1.0, p - sphere1Pos), red);\n    SdResult result = sphere1;\n    \n    vec3 sphere2Pos = vec3(2.5*cos(time), 1, 2.5*sin(time));\n    SdResult sphere2 = SdResult(sdSphere (1.5, p - sphere2Pos), green);\n    result = sminCubic(result, sphere2, vec2(2, 1));\n    \n    vec3 sphere3Pos = vec3(-2.*cos(time/2.), 1, 2.*sin(time/2.));\n    SdResult sphere3 = SdResult(sdSphere (1.25, p - sphere3Pos), blue);\n    result = sminCubic(result, sphere3, 1.);\n    \n    SdResult floor = SdResult(sdPlane(0.0, p), floorMat(p));\n    result = sminCubic(result, floor, 1.5);\n    \n    vec3 smallMirrorPos = vec3(1.2, 1.4, 0.);\n    SdResult smallMirror = SdResult(sdBox(vec3(0.5), p - smallMirrorPos) - 0.05, mirror);\n    result = sminCubic(result, smallMirror, vec2(1., 0.5));\n    \n    vec3 cylinderPos = vec3(-5., 1., -3.);\n    SdResult cylinder = SdResult(sdCylinder(vec2(1., 1.5), p - cylinderPos) - 0.5, mirror);\n    \n    vec3 boxPos = vec3(5., 0., -4.);\n    SdResult box = SdResult(sdBox(vec3(1., 3., 3.), rot45(p - boxPos)) - 0.1, mirror);\n    \n    SdResult mirrors = sdUnion(cylinder, box);\n    result = sminCubic(result, mirrors, 0.1);\n    \n    return result;\n}\n\n// RAY MARCHING\n\n// Returns the distance to the intersection with the scene, or -1 if no intersection is found.\nfloat march(vec3 ro, vec3 rd) {\n    float t = T_EPS;\n    for (int i = 0; i < MAX_MARCH_STEPS; i++) {\n        vec3 pos = ro + rd*t;\n        float d = sdScene(pos).dist;\n        t += d;\n        if (d/t < MARCH_EPS) break;\n        if (t > FAR_CLIP) return -1.;\n    }\n    return t;\n}\n\n// Returns a coefficient for how much light makes it to a point from a light source.\n// lightApparentSize controls soft shadows. A bigger number means the light takes up a larger viewing area, making softer shadows.\n// (If you want to specify an exact apparent radius, pass in tan(radius), or tan(diameter/2.) for an apparent diameter.)\n// lightDist is the distance to the light source. Used to prevent marching past a point light.\nfloat shadowMarch(vec3 ro, vec3 norm, vec3 rd, float lightApparentSize, float lightDist) {\n    ro += norm * NORMAL_EPS;\n    float t = T_EPS;\n    \n    float minDist = lightApparentSize;\n    for (int i = 0; i < MAX_MARCH_STEPS; i++) {\n        vec3 pos = ro + rd*t;\n        float d = sdScene(pos).dist;\n        minDist = min(minDist, d/t);\n        t += d;\n        if (d < MARCH_EPS) break; // Good for efficiency and shouldn't impact the final result.\n        if (minDist/lightApparentSize < MARCH_EPS || t > FAR_CLIP) return max(minDist, 0.) / lightApparentSize;\n    }\n    // Assume we're in shadow if we didn't complete the march. This is usually a sign that we couldn't get off the original\n    // surface because the light vector was close to perpendicular.\n    return 0.;\n}\n\n// Overload for light sources infinitely far away.\nfloat shadowMarch(vec3 ro, vec3 norm, vec3 rd, float lightApparentSize) {\n    return shadowMarch(ro, norm, rd, lightApparentSize, FAR_CLIP);\n}\n\nvec3 grad(vec3 pos) {\n    const float eps = GRADIENT_EPS;\n    // Tetrahedron approach from https://www.iquilezles.org/www/articles/normalsSDF/normalsSDF.htm.\n    vec3 n = vec3(0.0);\n    for(int i=min(iFrame,0); i<4; i++) {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sdScene(pos+eps*e).dist;\n    }\n    return n;\n}\n\nvec3 norm(vec3 pos) {\n    return normalize(grad(pos));\n}\n\n// LIGHTING\n\nvec3 distantPointLight(vec3 lightDir, vec3 lightCol, float lightApparentSize, Mat mat, vec3 pos, vec3 rd, vec3 norm) {\n    vec3 halfVec = normalize(lightDir - rd);\n    \n    vec3 diffuse = mat.diffuseCol * clamp(dot(norm, lightDir), 0., 1.);\n    vec3 specular = mat.specularCol * pow(clamp(dot(norm, halfVec), 0., 1.), mat.shininess);\n    // Normalization from http://www.thetenthplanet.de/archives/255.\n    float specNormalization = (mat.shininess  + 2.) / (4. * (2. - pow(2., -mat.shininess/2.)));\n    \n    return lightCol * shadowMarch(pos, norm, lightDir, lightApparentSize) * (diffuse + specular*specNormalization);\n}\n\nvec3 light(Mat mat, vec3 pos, vec3 rd, vec3 norm) {\n    float occlusion = 1.; // TODO: Some kind of occlusion.\n    \n    vec3 res = vec3(0);\n    \n    vec3 sunDir = normalize(vec3(1,0.75,0.5));\n    vec3 sunCol = vec3(2);\n    float sunApparentSize = 0.047; // The physically correct number is 0.0047, but softer shadows are fun.\n    res += distantPointLight(sunDir, sunCol, sunApparentSize, mat, pos, rd, norm);\n    \n    vec3 ambient =  vec3(0.05) * occlusion;\n    res += ambient * mat.diffuseCol;\n    \n    return res;\n}\n\n\n// RENDERING\n\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 color = vec3(0);\n    float transmittance = 1.;\n    \n    for (int i = min(iFrame,0); i <= MAX_REFLECTIONS; i++) {\n        float dist = march(ro, rd);\n        if (dist > 0.) {\n            vec3 pos = ro + dist*rd;\n            SdResult sd = sdScene(pos);\n            vec3 norm = norm(pos);\n\n            color += transmittance * light(sd.mat, pos, rd, norm);\n            transmittance *= sd.mat.reflectivity;\n            ro = pos + norm * NORMAL_EPS;\n            rd = reflect(rd, norm);\n            \n            if (transmittance < REFLECTION_EPS) break;\n\n            // TODO: Render light sources as a specular reflection directly on the camera.\n        } else {\n            vec3 skyLight = vec3(0.4, 0.4, 0.8);\n            vec3 skyDark = vec3(0.1, 0.1, 0.4);\n            vec3 skyColor = mix(skyDark, skyLight, rd.y);\n            color += transmittance * skyColor;\n            break;\n        }\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates. (y goes from -1 to 1, x has the same scale per pixel and is centered at 0.)\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.yy;\n    \n    // Fixed viewpoint.\n    // vec3 ro = vec3(0, 4, 4);\n    // vec3 target = vec3(0, 0, -2);\n    \n    // Rotating viewpoint.\n    float viewAngle = iTime/10.;\n    vec3 ro = 4. * vec3(sin(viewAngle), 1, cos(viewAngle));\n    vec3 target = -2. * vec3(sin(viewAngle), 0, cos(viewAngle));\n    \n    vec3 rd = computeCameraRay(ro, target, uv);\n    \n    vec3 color = render(ro, rd);\n    \n    color = pow(color, vec3(0.4545)); // Gamma correction.\n    fragColor = vec4(color, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdSSWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[767, 767, 823, 823, 1239], [1893, 1893, 1917, 1917, 2532], [2606, 2606, 2639, 2639, 2667], [2669, 2669, 2706, 2706, 2733], [2735, 2735, 2758, 2758, 2796], [2798, 2798, 2827, 2827, 2971], [2973, 2973, 3002, 3002, 3144], [3146, 3146, 3180, 3180, 3228], [3230, 3230, 3272, 3272, 3324], [3326, 3326, 3360, 3360, 3564], [3776, 3862, 3914, 3914, 4280], [4282, 4282, 4335, 4335, 4375], [4377, 4377, 4397, 4397, 4526], [4528, 4799, 4825, 4825, 6153], [6172, 6267, 6298, 6298, 6546], [6548, 6980, 7070, 7070, 7755], [7757, 7808, 7881, 7881, 7950], [7952, 7952, 7973, 7973, 8309], [8311, 8311, 8332, 8332, 8367], [8382, 8382, 8500, 8500, 9003], [9005, 9005, 9056, 9056, 9522], [9539, 9539, 9570, 9570, 10500], [10502, 10502, 10559, 10672, 11211]], "test": "valid"}
{"id": "NdSXWW", "name": "Paint Brush Shader - broken", "author": "Neblig", "description": "Paint brush shader for a game.\nFork from : https://www.shadertoy.com/view/fdfSDB", "tags": ["game", "paint", "drawing", "aesthetic", "brush"], "likes": 4, "viewed": 77, "published": "Public", "date": "1620181173", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAGIC_BOX_ITERS = 11; //Adjust this: higher = more detail, 11\nconst float MAGIC_BOX_MAGIC = .6; //This number is scary, dont mess with it, .55\n\n\nfloat centerThreshold = 1.0; //Closer they are, further it goes?\nfloat edgeThreshold = 80.0;\n\nfloat splatFalloffSize = .9; //.9\nfloat splatCutoffSize = .1; //different dimesion\n\nvec4 defaultColor = vec4(0,0,0,0);\n \n//float temp = glutGet(GLUT_SCREEN_WIDTH/HEIGHT);\n\n\n//Fractal from https://www.shadertoy.com/view/4ljGDd\nfloat magicBox(vec3 p) {\n    // The fractal lives in a 1x1x1 box with mirrors on all sides.\n    // Take p anywhere in space and calculate the corresponding position\n    // inside the box, 0<(x,y,z)<1\n    p = 1.0 - abs(1.0 - mod(p, 2.0));\n    \n    float lastLength = length(p);\n    float tot = 0.0;\n    // This is the fractal.  More iterations gives a more detailed\n    // fractal at the expense of more computation.\n    for (int i=0; i < MAGIC_BOX_ITERS; i++) {\n      // The number subtracted here is a \"magic\" paremeter that\n      // produces rather different fractals for different values.\n      p = abs(p)/(lastLength*lastLength) - MAGIC_BOX_MAGIC;\n      float newLength = length(p);\n      tot += abs(newLength-lastLength);\n      lastLength = newLength;\n    }\n\n    return tot;\n}\n\n\n// A random 3x3 unitary matrix, used to avoid artifacts from slicing the\n// volume along the same axes as the fractal's bounding box.\nconst mat3 M = mat3(0.28862355854826727, 0.6997227302779844, 0.6535170557707412,\n                    0.06997493955670424, 0.6653237235314099, -0.7432683571499161,\n                    -0.9548821651308448, 0.26025457467376617, 0.14306504491456504);\n\n\nfloat euclideanDistance(vec2 a, vec2 b){\n    return sqrt(pow((a.x - b.x), 2.0) + pow((a.y - b.y), 2.0));\n}\n\nfloat lerp(float a, float b, float w)\n{\n  return a + w*(b-a);\n}\n\nbool inRange(vec2 a, vec2 b, float maxDist){\n    return (euclideanDistance(a, b)/iResolution.y) < maxDist;\n}\n\nvec4 overlayColors(vec4 first, vec4 second){\n    return first * first.w + second * (1.0 - first.w);\n}\n\nvec4 splatColor(vec2 splatCenter, vec4 paintColor, vec2 fragCoord, vec2 uv, float falloffMod)\n{\n\n    //FRACTAL FUN:\n    // Rotate uv onto the random axes given by M, and scale\n    // it down a bit so we aren't looking at the entire\n    // 1x1x1 fractal volume.  Making the coefficient smaller\n    // \"zooms in\", which may reduce large-scale repetition\n    // but requires more fractal iterations to get the same\n    // level of detail.\n    vec3 p = 0.3*M*vec3(uv, 0.0);\n    \n    float result = magicBox(p);\n    // Scale to taste.  Also consider non-linear mappings.\n    //result *= 0.025; \n       //TODO: Scale to dist\n        //Removed this since can just scale threshold by distance\n        \n        \n    //Setup Colors (fun)\n    //vec3 paintColor = vec3(255.0, 0.0, 0.0);\n    //vec3 paintColor = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    vec4 retColor;\n    \n    //Now clamp them values\n    //Set threshold to inverse distance\n    float dist = euclideanDistance(fragCoord, splatCenter); //Pixels\n    float screenDist = dist/iResolution.y; //0 to 1 scale, percent of screen\n    \n    //float threshold = centerThreshold + slope * adjDist; //.25\n    float threshold = lerp(centerThreshold, edgeThreshold, screenDist/(splatFalloffSize*falloffMod + .1)); \n    \n    //circle\n    //if(screenDist/splatCutoffSize > splatCutoffSize){retColor = black;}\n    \n    if (result > threshold){\n        retColor = paintColor;\n    }else{\n        retColor = defaultColor;\n    }\n \n    \n\treturn retColor;\n}\n\n\n\nfloat closestTOnLine(vec2 p, vec2 a, vec2 b){\n    vec2 ap = p - a;\n    vec2 ab = b - a;\n    //Squared magnitude of ab\n    float atb2 = ab.x*ab.x + ab.y*ab.y;\n    \n    float ap_dot_ab = ap.x*ab.x + ap.y*ab.y;\n    \n    //Normalized distance from a to closest point\n    float t = ap_dot_ab / atb2;\n\n    t = min(max(t,0.0), 1.0);\n    \n    return t;    \n}\n\nvec2 closestPointToLine(vec2 p, vec2 a, vec2 b, float t){\n    vec2 ap = p - a;\n    vec2 ab = b - a;\n    \n    return a + ab * t;\n}\n\n\n\n//Get color based on distance from two splat centers\n//1 - get distance to the line\nvec4 getOneStreak(vec2 center1, vec2 center2, vec4 paintColor1, vec4 paintColor2, vec2 fragCoord, vec2 uv){\n     \n    //T is distance from A to B  (1 to 2) from 0 to 1\n    float t = closestTOnLine(fragCoord, center1, center2);\n    \n    vec2 closestPoint = closestPointToLine(fragCoord, center1, center2, t);\n     \n    float alphaLerp = mix(paintColor1.w, paintColor2.w, t);\n    float adjFalloff = t * alphaLerp;\n\n    if(inRange(closestPoint,fragCoord, splatCutoffSize)){\n        //return vec4(255.0, 0.0, 255.0, 1.0);\n        return splatColor(closestPoint, paintColor1, fragCoord, uv, adjFalloff);\n    }\n    \n    return defaultColor;\n    \n   \n}\n\n\n\n\n//Return the color at a point, (0,0,0) alpha 0 by default\n\nvec4 getSplatColorAtPixel(vec2 fragCoord, vec2 uv){\n    vec4 c1 = vec4(255.0, 0.0, 0.0, 1.0);\n    vec4 c2 = vec4(0.0, 255.0, 0.0, 1.0);\n    \n    vec4 c3 = vec4(0.0, 0.0, 255.0, 1.0);\n    vec4 c4 = vec4(255.0, 0.0, 255.0, 1.0);\n    \n    vec2 s1 = vec2(100.0,100.0);\n    vec2 s2 = vec2(400.0,300.0);\n    \n    vec2 s3 = vec2(100.0,300.0);\n    vec2 s4 = vec2(500.0,100.0);\n    \n    vec4 retColor = defaultColor;\n    \n    retColor = overlayColors(retColor, getOneStreak(s1, s2, c1, c2, fragCoord, uv));\n    retColor = overlayColors(retColor, getOneStreak(s3, s4, c3, c4, fragCoord, uv));\n    \n    \n    \n    \n    return retColor;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n\n    // uv are screen coordinates, uniformly scaled to go from 0..1 vertically\n\tvec2 uv = fragCoord.xy / iResolution.yy;\n    \n    // scroll a certain number of screenfuls/second\n    uv.x += iTime * 0.2;\n    \n    //splatColor(s1, fragCoord, uv, c1);\n    vec4 dotColor = getSplatColorAtPixel(fragCoord,uv);\n    \n    //Alpha blending - replace black w Result from textures\n    vec4 result = overlayColors(dotColor, defaultColor);\n    \n    //vec2 temp = glGet(\"GL_VIEWPORT\");\n    \n    fragColor = result;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdSXWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[422, 475, 499, 674, 1256], [1642, 1642, 1682, 1682, 1748], [1750, 1750, 1789, 1789, 1813], [1815, 1815, 1859, 1859, 1923], [1925, 1925, 1969, 1969, 2026], [2028, 2028, 2123, 2463, 3518], [3522, 3522, 3567, 3567, 3872], [3874, 3874, 3931, 3931, 4003], [4007, 4091, 4198, 4258, 4736], [4800, 4800, 4851, 4851, 5425], [5429, 5429, 5484, 5563, 5987]], "test": "valid"}
{"id": "Nlf3R8", "name": "圆，半圆，圆", "author": "xxxbbbooo", "description": "shader学习记录", "tags": ["circlehalfcircle"], "likes": 1, "viewed": 31, "published": "Public", "date": "1621475700", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv = uv*2.-1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    \n    uv.x += step(0.1, mod(uv.y, 0.2)) * min(0.,sin(iTime))*0.2;\n    uv.y += step(0.1, mod(uv.x, 0.2)) * max(0.,sin(iTime))*0.2;\n    uv = fract(uv*5.);\n    \n    float a = smoothstep(0.25, 0.3, length(uv-vec2(0.5)));    \n    \n\n    // Output to screen\n    fragColor = vec4(0.3, 0.6, sin(iTime), 1.)+vec4(a);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nlf3R8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 525]], "test": "valid"}
{"id": "Nlf3zn", "name": "Fire Whip", "author": "pauloamorimbr", "description": "An attempt of using fire colors and test with noise functions.\nClick and drag around the X axis...", "tags": ["fire", "sin", "whip"], "likes": 3, "viewed": 69, "published": "Public", "date": "1621368612", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\nfloat rand(vec3 co){ return rand(co.xy+rand(co.z)); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float vCenter = iResolution.y/2.0;\n    \n    float distFromMouse = ( iMouse.x - fragCoord.x );\n    \n    float distFromCenterX = (iResolution.x/2.0 - iMouse.x);\n    \n    float sinCenter = vCenter + sin( (iTime * distFromCenterX) / -55.0 + fragCoord.x / clamp( 2.0, abs(distFromCenterX)/2.0, 100.0) ) * distFromMouse /4.0;\n    \n    float lenFromCenter = abs(sinCenter - fragCoord.y);\n\n    //vec3 color = vec3( clamp(0.0, abs(lenFromCenter / 20.0), 1.0) );\n    vec3 color = vec3( 1.0 - lenFromCenter );\n    //color.r = distFromMouse/iResolution.y * 2.0;\n    //color.g = distFromMouse/iResolution.y * .4;\n    color.g = (1.0 - lenFromCenter / 35.0);\n        color.r = (1.0 - lenFromCenter / 80.0) + (rand(iTime) * .2);   \n\n    // Output to screen\n    fragColor = vec4( color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nlf3zn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 70], [71, 71, 91, 91, 159], [160, 160, 180, 180, 213], [215, 215, 272, 272, 1055]], "test": "valid"}
{"id": "NlfGzB", "name": "voronoi 3D", "author": "pixel", "description": "voronoi example", "tags": ["2d", "3d", "voronoi"], "likes": 2, "viewed": 47, "published": "Public", "date": "1622292758", "time_retrieved": "2021-10-01T00:00:00", "image_code": "  \nconst mat2 myt = mat2(.12121212, .13131313, -.13131313, .12121212);\nconst vec2 mys = vec2(1e4, 1e6);\n\nvec2 rhash(vec2 uv) {\n  uv *= myt;\n  uv *= mys;\n  return fract(fract(uv / mys) * uv);\n}\n\nvec3 hash(vec3 p) {\n  return fract(\n      sin(vec3(dot(p, vec3(1.0, 57.0, 113.0)), dot(p, vec3(57.0, 113.0, 1.0)),\n               dot(p, vec3(113.0, 1.0, 57.0)))) *\n      43758.5453);\n}\n\nvec3 voronoi3d(const in vec3 x) {\n  vec3 p = floor(x);\n  vec3 f = fract(x);\n\n  float id = 0.0;\n  vec2 res = vec2(100.0);\n  for (int k = -1; k <= 1; k++) {\n    for (int j = -1; j <= 1; j++) {\n      for (int i = -1; i <= 1; i++) {\n        vec3 b = vec3(float(i), float(j), float(k));\n        vec3 r = vec3(b) - f + hash(p + b);\n        float d = dot(r, r);\n\n        float cond = max(sign(res.x - d), 0.0);\n        float nCond = 1.0 - cond;\n\n        float cond2 = nCond * max(sign(res.y - d), 0.0);\n        float nCond2 = 1.0 - cond2;\n\n        id = (dot(p + b, vec3(1.0, 57.0, 113.0)) * cond) + (id * nCond);\n        res = vec2(d, res.x) * cond + res * nCond;\n\n        res.y = cond2 * d + nCond2 * res.y;\n      }\n    }\n  }\n\n  return vec3(sqrt(res), abs(id));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Aspect Correction\n    float aspect = iResolution.x / iResolution.y;\n    uv.x *= aspect;\n    \n    \n    // Voronoi Use Example <---\n    vec3 color = voronoi3d(vec3(uv * 10.0, iTime));\n\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlfGzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 105, 126, 126, 192], [194, 194, 213, 213, 379], [1140, 1140, 1197, 1247, 1542]], "test": "error"}
{"id": "Nll3RN", "name": "spiral scope", "author": "4eckme", "description": "spiral", "tags": ["spiral"], "likes": 0, "viewed": 36, "published": "Public", "date": "1621660020", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = fragCoord - (iResolution.xy / vec2(2.0));\n    float x = float(coord.x);\n    float y = float(coord.y);\n    float t = iTime;\n    float O = sqrt(x*x+y*y);\n    float Z = abs(x*cos((O)/t)-y*sin((O)/t));\n    float r2 = (x*x+y*y)*Z;\n    int a = int(floor(r2*pow(16.0, 6.0-ceil(log2(r2)/4.0))));   \n    fragColor = vec4(\n        float((a >> 16) & 255) / 255.0,\n        float((a >> 8) & 255) / 255.0,\n        float((a >> 0) & 255) / 255.0,\n        1.0\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nll3RN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 526]], "test": "valid"}
{"id": "Nll3WH", "name": "swarm pillars", "author": "kylegrover", "description": "played around with stephaneginier's editSDF, very pleased with what came out", "tags": ["editsdf"], "likes": 2, "viewed": 126, "published": "Public API", "date": "1622005199", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SHADERTOY\n#define SHADERTOY_ZOOM 2.0\n#define BLEND_COLOR\nprecision mediump float;\nuniform vec3 uOrigin;\nuniform mat3 uView;\nuniform vec2 uInvSize;\n\n\n#define PI 3.141592653589793\n#define PI_2 1.5707963267948966\n#define SQRT1_2 0.7071067811865476\n#define SQRT2 1.4142135623730951\n\n// raymarching code from https://www.shadertoy.com/view/Xds3zN\n\n// blend color for chamfer and round operators (sd is simple operator distance)\nvec3 colorBlending(const in float sd, const in vec4 a, const in vec4 b) {\n  float ra = clamp(sd / a.x, 0.0, 1.0);\n  float rb = clamp(sd / b.x, 0.0, 1.0);\n  return (a.yzw * ra + b.yzw * rb) / (ra + rb);\n}\n\nvec3 colorUnion(const in vec4 a, const in vec4 b){\n#ifdef BLEND_COLOR\n  return colorBlending(min(a.x, b.x), a, b);\n#else\n  return (a.x < b.x) ? a.yzw : b.yzw;\n#endif\n}\n\nvec3 colorInter(const in vec4 a, const in vec4 b){\n#ifdef BLEND_COLOR\n  return colorBlending(max(a.x, b.x), a, b);\n#else\n  return (a.x < b.x) ? a.yzw : b.yzw;\n#endif\n}\n\nvec2 pR45(const in vec2 p) {\n  return (p + vec2(p.y, -p.x)) * SQRT1_2;\n}\n\n/////////////\n// PRIMITIVES\n/////////////\n\nfloat cullPlane(const in vec3 p) {\n  return p.y >= -0.502 ? p.y + 0.5 : 20.0;\n}\n\nfloat sdSphere(const in vec3 p, const in float s) {\n  return length(p) - s;\n}\n\nfloat sdBox(const in vec3 p, const in vec4 b) {\n  vec3 d = abs(p) - b.xyz;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0)) - b.w;\n}\n\nfloat sdTorus(const in vec3 p, const in vec2 t) {\n  return length(vec2(length(p.xz) - t.x, p.y)) - t.y;\n}\n\nfloat sdCapsule(const in vec3 p, const in vec2 rh) {\n  return mix(length(p.xz) - rh.x, length(vec3(p.x, abs(p.y) - rh.y, p.z)) - rh.x, step(rh.y, abs(p.y)));\n}\n\nfloat sdEllipsoid(const in  vec3 p, const in vec3 r) {\n  return (length(p / r) - 1.0) * min(min(r.x, r.y), r.z);\n}\n\n///////////////\n// COMBINATIONS\n///////////////\n\n// UNION\nfloat opUnion(const in float a, const in float b) {\n  return min(a, b);\n}\nvec4 opUnion(const in vec4 a, const in vec4 b) {\n  return (a.x < b.x) ? a : b;\n}\n\n// INTER\nfloat opInter(const in float a, const in float b) {\n  return max(a, b);\n}\nvec4 opInter(const in vec4 a, const in vec4 b) {\n  return (a.x > b.x) ? a : b;\n}\n\n// SUB\nfloat opSub(const in float a, const in float b) {\n  return max(-b, a);\n}\nvec4 opSub(const in vec4 a, const in vec4 b) {\n  // to keep b material on diff intersection instead of a mat\n  // return (-b.x > a.x) ? vec4(-b.x, b.yzw) : a);\n  return vec4(max(-b.x, a.x), a.yzw);\n}\n\n// see hg_sdf.glsl\n/////////////////////\n// COMBINATIONS ROUND\n/////////////////////\n\n// UNION ROUND (soft media mol version)\nfloat opUnionRound(const in float a, const in float b, const in float r) {\n  float e = max(r - abs(a - b), 0.0);\n  return min(a, b) - e * e * 0.25 / r;\n}\nvec4 opUnionRound(const in vec4 a, const in vec4 b, const in float r) {\n  return vec4(opUnionRound(a.x, b.x, r), colorUnion(a, b));\n}\n\n// INTER ROUND\nfloat opInterRound(const in float a, const in float b, const in float r) {\n  vec2 u = max(vec2(r + a, r + b), vec2(0.0));\n  return min(-r, max(a, b)) + length(u);\n}\nvec4 opInterRound(const in vec4 a, const in vec4 b, const in float r) {\n  return vec4(opInterRound(a.x, b.x, r), colorInter(a, b));\n}\n\n// SUB ROUND\nfloat opSubRound(const in float a, const in float b, const in float r) {\n  return opInterRound(a, -b, r);\n}\nvec4 opSubRound(const in vec4 a, const in vec4 b, const in float r) {\n  return vec4(opInterRound(a.x, -b.x, r), a.yzw);\n}\n\n///////////////////////\n// COMBINATIONS CHAMFER\n///////////////////////\n\n// UNION CHAMFER\nfloat opUnionChamfer(const in float a, const in float b, const in float r) {\n  return min(min(a, b), (a - r + b) * SQRT1_2);\n}\nvec4 opUnionChamfer(const in vec4 a, const in vec4 b, const in float r) {\n  return vec4(opUnionChamfer(a.x, b.x, r), colorUnion(a, b));\n}\n\n// INTER CHAMFER\nfloat opInterChamfer(const in float a, const in float b, const in float r) {\n  return max(max(a, b), (a + r + b) * SQRT1_2);\n}\nvec4 opInterChamfer(const in vec4 a, const in vec4 b, const in float r) {\n  return vec4(opInterChamfer(a.x, b.x, r), colorInter(a, b));\n}\n\n// SUB CHAMFER\nfloat opSubChamfer(const in float a, const in float b, const in float r) {\n  return opInterChamfer(a, -b, r);\n}\nvec4 opSubChamfer(const in vec4 a, const in vec4 b, const in float r) {\n  return vec4(opInterChamfer(a.x, -b.x, r), a.yzw);\n}\n\n//////////////////////\n// COMBINATION COLUMNS\n//////////////////////\n\n// UNION COLUMNS\nfloat opUnionColumns(const in float a, const in  float b, const in vec2 rn) {\n  float r = rn.x;\n  float n = rn.y;\n  if((a < r) && (b < r)) {\n    vec2 p = vec2(a, b);\n    float columnradius = r * SQRT2 / ((n - 1.0) * 2.0 + SQRT2);\n    p = pR45(p);\n    p.x -= SQRT1_2 * r;\n    p.x += columnradius * SQRT2;\n    if(mod(n, 2.0) == 1.0) {\n      p.y += columnradius;\n    }\n    // At this point, we have turned 45 degrees and moved at a point on the\n    // diagonal that we want to place the columns on.\n    // Now, repeat the domain along this direction and place a circle.\n    p.y = mod(p.y + columnradius, columnradius * 2.0) - columnradius;\n    float result = length(p) - columnradius;\n    result = min(result, p.x);\n    result = min(result, a);\n    return min(result, b);\n  } \n\n  return min(a, b);\n}\nvec4 opUnionColumns(const in vec4 a, const in vec4 b, const in vec2 rn) {\n  return vec4(opUnionColumns(a.x, b.x, rn), colorUnion(a, b));\n}\n\n// SUB COLUMNS\nfloat opSubColumns(const in float ain, const float b, const vec2 rn) {\n  float a = -ain;\n  float r = rn.x;\n  float n = rn.y;\n  float m = min(a, b);\n  //avoid the expensive computation where not needed (produces discontinuity though)\n  if((a < r) && (b < r)) {\n    vec2 p = vec2(a, b);\n    float columnradius = r * SQRT2 / n / 2.0;\n    columnradius = r * SQRT2 / ((n - 1.0) * 2.0 + SQRT2);\n\n    p = pR45(p);\n    p.y += columnradius;\n    p.x -= SQRT1_2 * (r + columnradius);\n\n    if(mod(n, 2.0) == 1.0) {\n      p.y += columnradius;\n    }\n    p.y = mod(p.y + columnradius, columnradius * 2.0) - columnradius;\n\n    float result = -length(p) + columnradius;\n    result = max(result, p.x);\n    result = min(result, a);\n    return -min(result, b);\n  }\n\n  return -m;\n}\nvec4 opSubColumns(const in vec4 a, const in vec4 b, const in vec2 rn) {\n  return vec4(opSubColumns(a.x, b.x, rn), a.yzw);\n}\n\n// INTER COLUMNS\nfloat opInterColumns(const in float a, const in float b, const in vec2 rn) {\n  return opSubColumns(a, -b, rn);\n}\nvec4 opInterColumns(const in vec4 a, const in vec4 b, const in vec2 rn) {\n  return vec4(opSubColumns(a.x, -b.x, rn), colorInter(a, b));\n}\n\n/////////////////////\n// COMBINATION STAIRS\n/////////////////////\n// UNION STAIRS\nfloat opUnionStairs(const in float a, const in float b, const in vec2 rn) {\n  float s = rn.x / rn.y;\n  float u = b - rn.x;\n  return min(min(a, b), 0.5 * (u + a + abs((mod(u - a + s, 2.0 * s)) - s)));\n}\nvec4 opUnionStairs(const in vec4 a, const in vec4 b, const in vec2 rn) {\n  return vec4(opUnionStairs(a.x, b.x, rn), colorUnion(a, b));\n}\n\n// INTER STAIRS\nfloat opInterStairs(const in float a, const in float b, const in vec2 rn) {\n  return -opUnionStairs(-a, -b, rn);\n}\nvec4 opInterStairs(const in vec4 a, const in vec4 b, const in vec2 rn) {\n  return vec4(-opUnionStairs(-a.x, -b.x, rn), colorInter(a, b));\n}\n\n// SUB STAIRS\nfloat opSubStairs(const in float a, const in float b, const in vec2 rn) {\n  return -opUnionStairs(-a, b, rn);\n}\nvec4 opSubStairs(const in vec4 a, const in vec4 b, const in vec2 rn) {\n  return vec4(-opUnionStairs(-a.x, b.x, rn), a.yzw);\n}\n\n/////////////\n// REPETITION\n/////////////\n\nvec3 pMod(const in vec3 p, const in vec3 size) {\n  vec3 pmod = p;\n  if(size.x > 0.0) pmod.x = mod(p.x + size.x * 0.5, size.x) - size.x * 0.5;\n  if(size.y > 0.0) pmod.y = mod(p.y + size.y * 0.5, size.y) - size.y * 0.5;\n  if(size.z > 0.0) pmod.z = mod(p.z + size.z * 0.5, size.z) - size.z * 0.5;\n  return pmod;\n}\n\n////////////\n// HELPERS\n////////////\nvec4 mapDistanceColor(const in vec3 point) {\n  vec4 tmpPrim_117 = vec4(cullPlane(pMod((mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.30000001192092896,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(-5.0,-5.0,-5.0))) * 1.0, vec3(0.1) * (mod(floor(5.0 * point.z) + floor(5.0 * point.x), 2.0)) + 0.4);\nvec4 tmpPrim_118 = vec4(sdBox(pMod((mat4(1.4540570974349976,0.0,0.0,0.0,0.0,1.4540570974349976,0.0,0.0,0.0,0.0,1.4540570974349976,0.0,0.0,-0.673682451248169,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(4.8500000000000005,1.71,5.0)), vec4(0.1,0.78,0.1,0.09)) * 0.6877309083938599, vec3(0.30639375,0.35338712499999997,0.52));\nvec4 tmpComb_267 = opUnionColumns(tmpPrim_117, tmpPrim_118, vec2(0.3,5.96));\nvec4 tmpPrim_119 = vec4(sdSphere(pMod((mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(1.6400000000000001,2.09,6.7700000000000005)), 0.28) * 1.0, vec3(0.5215065625,0.49989843749999996,0.77));\nvec4 tmpComb_268 = tmpComb_267;\nvec4 tmpComb_269 = opUnionColumns(tmpComb_268, tmpPrim_119, vec2(0.3,10.0));\nvec4 tmpPrim_120 = vec4(sdBox(pMod((mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(-5.0,-5.0,3.44)), vec4(0.33,0.01,0.53,0.0)) * 1.0, vec3(0.5215065625,0.49989843749999996,0.77));\nvec4 tmpComb_270 = tmpComb_269;\nvec4 tmpComb_271 = opSubColumns(tmpComb_270, tmpPrim_120, vec2(0.17,10.0));\nvec4 tmpPrim_121 = vec4(sdSphere(pMod((mat4(3.274618148803711,0.0,0.0,0.0,0.0,3.274618148803711,0.0,0.0,0.0,0.0,3.274618148803711,0.0,5.372418403625488,-0.0015462442534044385,0.008526071906089783,1.0) * vec4(point, 1.0)).xyz, vec3(0.1,0.1,0.1)), 0.01) * 0.30537912249565125, vec3(0.11024278124999998,0.04005781250000002,0.31000000000000005));\nvec4 tmpComb_272 = tmpComb_271;\nvec4 tmpComb_273 = opInterColumns(tmpComb_272, tmpPrim_121, vec2(0.01,7.0));\nreturn tmpComb_273;\n}\n\nfloat mapDistance(const in vec3 point) {\n  float tmpComb_274 = opUnionColumns(cullPlane(pMod((mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.30000001192092896,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(-5.0,-5.0,-5.0))) * 1.0, sdBox(pMod((mat4(1.4540570974349976,0.0,0.0,0.0,0.0,1.4540570974349976,0.0,0.0,0.0,0.0,1.4540570974349976,0.0,0.0,-0.673682451248169,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(4.8500000000000005,1.71,5.0)), vec4(0.1,0.78,0.1,0.09)) * 0.6877309083938599, vec2(0.3,5.96));\nfloat tmpComb_275 = tmpComb_274;\nfloat tmpComb_276 = opUnionColumns(tmpComb_275, sdSphere(pMod((mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(1.6400000000000001,2.09,6.7700000000000005)), 0.28) * 1.0, vec2(0.3,10.0));\nfloat tmpComb_277 = tmpComb_276;\nfloat tmpComb_278 = opSubColumns(tmpComb_277, sdBox(pMod((mat4(1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0) * vec4(point, 1.0)).xyz, vec3(-5.0,-5.0,3.44)), vec4(0.33,0.01,0.53,0.0)) * 1.0, vec2(0.17,10.0));\nfloat tmpComb_279 = tmpComb_278;\nfloat tmpComb_280 = opInterColumns(tmpComb_279, sdSphere(pMod((mat4(3.274618148803711,0.0,0.0,0.0,0.0,3.274618148803711,0.0,0.0,0.0,0.0,3.274618148803711,0.0,5.372418403625488,-0.0015462442534044385,0.008526071906089783,1.0) * vec4(point, 1.0)).xyz, vec3(0.1,0.1,0.1)), 0.01) * 0.30537912249565125, vec2(0.01,7.0));\nreturn tmpComb_280;\n}\n    \nvec4 castRay(const in vec3 ro, const in vec3 rd) {\n  float t = 1.0;\n  float tmax = 50.0;\n\n  float precis = 0.002;\n  for(int i = 0; i < 50; i++) {\n    float dist = mapDistance(ro + rd * t);\n    if(dist < precis || t > tmax)\n      break;\n    t += dist;\n  }\n\n  vec3 m = t > tmax ? vec3(-1.0) : mapDistanceColor(ro + rd * t).yzw;\n  return vec4(t, m);\n}\n\nfloat softshadow(const in vec3 ro, const in vec3 rd) {\n  float t = 0.02;\n  float tmax = 2.5;\n  float precis = 0.001;\n  float res = 1.0;\n  for(int i = 0; i < 16; i++) {\n    float h = mapDistance(ro + rd * t);\n    res = min(res, 20.0 * h / t);\n    t += clamp( h, 0.02, 0.10 );\n    if(h < 0.001 || t > tmax) break;\n  }\n  return clamp(res, 0.0, 1.0);\n}\n\nvec3 calcNormal(const in vec3 pos) {\n  vec3 eps = vec3(0.001, 0.0, 0.0);\n  vec3 nor = vec3(\n      mapDistance(pos + eps.xyy) - mapDistance(pos - eps.xyy),\n      mapDistance(pos + eps.yxy) - mapDistance(pos - eps.yxy),\n      mapDistance(pos + eps.yyx) - mapDistance(pos - eps.yyx));\n  return normalize(nor);\n}\n\nfloat calcAO(const in vec3 pos, const in vec3 nor) {\n  float occ = 0.0;\n  float sca = 1.0;\n  for(int i = 0; i < 5; i++) {\n      float hr = 0.01 + 0.03 * float(i);\n      vec3 aopos = nor * hr + pos;\n      occ += (hr - mapDistance(aopos)) * sca;\n      sca *= 0.95;\n  }\n  return clamp( 1.0 - 3.0 * occ, 0.0, 1.0 );    \n}\n\nvec3 render(const in vec3 ro, const in vec3 rd) {\n  vec3 col = vec3(0.5, 0.5, 0.5);\n  vec4 res = castRay(ro, rd);\n\n  if(res.y >= 0.0) {\n    vec3 pos = ro + res.x * rd;\n    vec3 nor = calcNormal(pos);\n\n    vec3 ref = reflect( rd, nor );\n    float occ = calcAO( pos, nor );\n    vec3  lig = normalize(vec3(-0.6, 0.7, -0.5));\n    float amb = clamp(0.5 + 0.5 * nor.y, 0.0, 1.0);\n    float dif = clamp(dot(nor, lig), 0.0, 1.0);\n    float bac = clamp(dot(nor, normalize(vec3(-lig.x, 0.0, -lig.z))), 0.0, 1.0 ) * clamp( 1.0 - pos.y, 0.0, 1.0);\n    float dom = smoothstep(-0.1, 0.1, ref.y);\n    float fre = pow(clamp(1.0 + dot(nor, rd), 0.0, 1.0), 2.0);\n    float spe = pow(clamp(dot(ref, lig), 0.0, 1.0),16.0);\n        \n    dif *= softshadow(pos, lig);\n    dom *= softshadow(pos, ref);\n\n    vec3 lin = vec3(0.0);\n    lin += 1.20 * dif * vec3(1.00, 0.85, 0.55);\n    lin += 1.20 * spe * vec3(1.00, 0.85, 0.55) * dif;\n    lin += 0.20 * amb * vec3(0.50, 0.70, 1.00) * occ;\n    lin += 0.30 * dom * vec3(0.50, 0.70, 1.00) * occ;\n    lin += 0.30 * bac * vec3(0.25, 0.25, 0.25) * occ;\n    lin += 0.40 * fre * vec3(1.00, 1.00, 1.00) * occ;\n\n    col = res.yzw * lin;\n  }\n\n  return clamp(col, 0.0, 1.0);\n}\n\n#ifdef SHADERTOY\nmat3 setCamera( const in vec3 ro, const in vec3 ta, const float cr ){\n  vec3 cw = normalize(ta-ro);\n  vec3 cp = vec3(sin(cr), cos(cr),0.0);\n  vec3 cu = normalize( cross(cw,cp) );\n  vec3 cv = normalize( cross(cu,cw) );\n  return mat3( cu, cv, cw );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord.xy / iResolution.xy;\n  vec2 p = -1.0 + 2.0 * q;\n  p.x *= iResolution.x / iResolution.y;\n  vec2 mo = iMouse.xy / iResolution.xy;\n  float time = 15.0 + iTime;\n\n  // camera \n  vec3 ro = SHADERTOY_ZOOM * vec3( -0.5 + 3.5 * cos(0.1 * time + 6.0 * mo.x), 1.0 + 2.0 * mo.y, 0.5 + 3.5 * sin(0.1 * time + 6.0 * mo.x));\n  vec3 ta = vec3(-0.5, -0.4, 0.5);\n\n  // camera-to-world transformation\n  mat3 ca = setCamera(ro, ta, 0.0);\n\n  // ray direction\n  vec3 rd = ca * normalize(vec3(p.xy, 2.0));\n\n  fragColor = vec4(render(ro, rd), 1.0);\n}\n\n#else\n\nvec3 raymarch(const in vec3 origin, const in mat3 view, const in vec2 uv, const in vec2 invSize) {\n  vec2 p = -1.0 + 2.0 * uv;\n  p.x *= invSize.y / invSize.x;\n  vec3 rd = normalize(view * vec3(p, 2.0));\n  return render(origin, rd);\n}\n\nvoid main() {\n  gl_FragColor = vec4(raymarch(uOrigin, uView, gl_FragCoord.xy * uInvSize, uInvSize), 1.0);\n}\n\n#endif\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nll3WH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "error"}
{"id": "Nll3WN", "name": "小龙猫 - Shadow Experiment", "author": "totetmatt", "description": "Learning shadow and trying to enhance my personal boiler plate code for shader performance", "tags": ["shadow"], "likes": 1, "viewed": 148, "published": "Public API", "date": "1622121182", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\nExperiment on Shadow  + Code Refinement\n\nThe scene is slighty more than just a surface and a volume.\nThe light is between the \"planets\" and the \"torus\" and moving on X axis (so left to right)\n* Little planet should have a shadow on the big planet and torus\n* Big planet should ahve shadow on the torus\n* The Torus **should not** cast any shadow \n\n(Big learning on my side for the algo, if you don't stop properly, \nit's \"bounce back the shadow\" which isn't what we want ... but maybe intersting for effects  ? Who knows ?)\n\n*/\n\n#define fGlobalTime iTime\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nvec2 sdf(vec3 p){\n  vec2 h;\n  h.x=length(p)-1.;\n  h.y=1.;\n  vec2 t;\n  t.y=1.;\n  \n  t.x=length(vec2(length(p.xz)-10.,p.y+1.+sin(fGlobalTime+atan(p.x,p.z)*3.)))-.5;\n  h=t.x<h.x?t:h;\n  \n   t.x = length(p+vec3(-0.5,+0.01,+1.9))-.1;\n    h=t.x<h.x?t:h;\n  return h;\n}\n\n#define q(s)s*sdf(p+s).x\nvec2 nv=vec2(-.01,.01);\nvec3 norm(vec3 p){return normalize(q(nv.xyy)+q(nv.yyx)+q(nv.yxy)+q(nv.xxx));}\n\nfloat raym(inout vec3 rp,vec3 rd, out vec2 mat) { // Yeah trying ways to organise all this sh***. Not sure will keep that way\n      \n      float i=0.;\n      float accDist = 0.; \n      for(;i<=69.;i++){\n          vec2 d = sdf(rp);\n          if(d.x<=0.001){\n               mat = d;\n               return accDist;\n          }\n          rp+=d.x*rd;\n          accDist +=d.x;\n      }\n      return accDist;\n }\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col=vec3(.01);\n\n    vec3 ro=vec3(0.,0.,-5.),rd=normalize(vec3(uv,1.)),rp=ro;\n    vec3 light=vec3(sin(fGlobalTime)*3.63,.0,-3.3);\n\n    vec2 mat;\n    float res = raym(rp,rd,mat);\n    if(res <= 40.){ // Which correspond to the usual \"far plane limit\" ? \n        vec3 n=norm(rp);\n        col=vec3(.05)+vec3(1.)*max(dot(normalize(light-rp),n),.0);\n    }\n\n    // Shadow compute, march along rp -> light, if you reach something it's a match for shadow, if you reach the light, call a monk\n    rd=normalize(light-rp);\n    float maxLightDist = length(light-rp); // The maximum travel to the light from the point, if the ray pass this limit, then it means nothing was between surface an light = no shadow\n    rp+=rd*.1; // Need to march a little bit to avoid the algo to be lost. I would call that \"L'Offset du cul\"\n    res = raym(rp,rd,mat); // reuse of function, WooOOOOooW\n    if(res < maxLightDist){\n     col *=vec3(.1); // Some people put a value, I tried with a mul, do what please you.\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nll3WN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[558, 558, 576, 576, 623], [624, 624, 641, 641, 884], [935, 935, 953, 953, 1012], [1014, 1014, 1063, 1139, 1416], [1419, 1419, 1476, 1526, 2617]], "test": "valid"}
{"id": "Nll3z2", "name": "myco-fractal-2", "author": "Shellderr", "description": "myco-net", "tags": ["fractal", "spore"], "likes": 1, "viewed": 38, "published": "Public", "date": "1622447793", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define res iResolution\n#define ft float\n\nft hm(vec2 uv, vec2 m){\n    ft a = dot(uv,uv);\n    ft b = sin(.6*iTime+uv.x/a/m.x)-sin(uv.y/a/m.y);\nreturn abs(b*1.4);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord.xy-res.xy)/res.y;\n    vec2 m = vec2(2.3);\n    vec2 mouse = iMouse.y < 1.? vec2(.5): iMouse.xy/res.xy;\n    ft a = hm(uv, m);\n    for(ft i; i < 6.; i++){\n    uv = abs(uv/hm(uv,m+i*.2)-.4*mouse);\n    }\n    fragColor = vec4(2.*smoothstep(.1,3.,1.-1./uv.xyy),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nll3z2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 42, 65, 65, 162], [164, 164, 220, 220, 510]], "test": "valid"}
{"id": "Nll3zB", "name": "God Rays - Andrew", "author": "andrew741", "description": "A god ray simulation using ray tracing, and sphere tracing (a type of ray marching). The god rays are created by using volumetrics (transmittance = e ^ -total_density). The scene is very basic and could be further extended (I've made an improved version).", "tags": ["raytracing", "raymarching", "shadows", "godrays", "spheretracing", "volumetrics", "specularhighlights"], "likes": 4, "viewed": 108, "published": "Public", "date": "1622339859", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nfloat DstSphere(vec3 samp, vec3 p, float r) {return length(samp - p) - r;}\n\n\nfloat DstTorus(vec3 p, vec2 r) {\n\tfloat x = length(p.xz) - r.x;\n    return length(vec2(x, p.y)) - r.y;\n}\n\n\nfloat distToCone(vec3 p, float rBase, float height)\n{\n\tfloat dst1 = length(p.xz) - ((-p.y + height / 2.) / height * rBase);\n    dst1 = abs(p.y) > height / 2. ? 200000. : dst1;\n    return dst1;\n}\n\n\nfloat GetDst(vec3 p)\n{\n    float dst1 = DstSphere(p, vec3(1., 2., 4.), 2.);\n    float dst2 = DstSphere(p, vec3(4., 4., 3.), 2.);\n    float dst3 = DstSphere(p, vec3(-2., 0., 6.), 2.);\n    //float dst3 = distToCone(p - vec3(-2., 0., 6.), 2., 3.);\n    float dst4 = p.y + 3.;\n    float dst5 = DstTorus(p - vec3(8., 0., 3.), vec2(3., 1.));\n    \n    return min(min(min(min(dst1, dst2), dst3), dst4), dst5);\n}\n\n\nvec3 GetCol(vec3 p)\n{\n    float dst1 = DstSphere(p, vec3(1., 2., 4.), 2.);\n    float dst2 = DstSphere(p, vec3(4., 4., 3.), 2.);\n    float dst3 = DstSphere(p, vec3(-2., 0., 6.), 2.);\n    //float dst3 = distToCone(p - vec3(-2., 0., 6.), 2., 3.);\n    float dst4 = p.y + 3.;\n    float dst5 = DstTorus(p - vec3(8., 0., 3.), vec2(3., 1.));\n    \n    float dst = min(min(min(min(dst1, dst2), dst3), dst4), dst5);\n    \n    if (dst == dst1) return vec3(0.2, 1. , 0.2);\n    if (dst == dst2) return vec3(1. , 0.2, 0.2);\n    if (dst == dst3) return vec3(0.2, 0.2, 1. );\n    if (dst == dst4) return vec3(1. , 0.2, 1. );\n    if (dst == dst5) return vec3(1. , 1. , 0.2);\n    \n    return vec3(0);\n}\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDst(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 normal = d - vec3(\n        GetDst(p - e.xyy),\n        GetDst(p - e.yxy),\n        GetDst(p - e.yyx));\n    \n    return normalize(normal);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 camera_pos = vec3(0., 0., -8.);\n    vec3 rd = normalize(vec3(uv + iMouse.xy / iResolution.xy, 1.));\n\n    vec3 sun_derection = normalize(vec3(sin(iTime * 1.5) * 0.4, sin(iTime * 0.1) * 0.5 + 0.5, cos(iTime * 1.5) * 0.4));\n    vec3 sun_col = vec3(1., 0.95, 0.85);\n\n    vec3 col = vec3(0., 0., 0.);\n    \n    float dst;\n    float dfs = 0.;\n    vec3 p = camera_pos;\n    float shadowed = 0.;\n    for (int s = 0; s < 200; s++)\n    {\n        dst = 0.1;\n        p += rd * dst;\n        dfs += dst;\n        \n        float dfs2;\n        float dst2;\n        vec3 p2 = p;\n        for (int s2 = 0; s2 < 50; s2++)\n        {\n            dst2 = GetDst(p2);\n            p2 += sun_derection * dst2;\n            dfs2 += dst2;\n            \n            if (dst2 < 0.01)\n            {\n                shadowed += (25. - dfs2) * 0.0075;\n                break;\n            }\n            else if (dfs2 > 25.) break;\n        }\n        \n        if (dfs > 25. || GetDst(p) < 0.01) break;\n    }\n    \n    float god_ray = exp(-shadowed * 0.05);\n    \n    if (GetDst(p) < 0.05)\n    {\n        float d;\n        vec3 np = p + sun_derection * 2.25;\n        for (int s = 0; s < 50; s++)\n        {\n            d = GetDst(np);\n            np += sun_derection * d;\n        }\n        vec3 normal = GetNormal(p);\n        float shadow = 1.;\n        if (dot(normal, sun_derection) < -0.5 || d < 0.01) shadow = 0.4;\n        \n        vec3 object_color = GetCol(p);\n        \n        float smoothness = 0.65;\n        float specularAngle = acos(dot(normalize(sun_derection - rd), normal));\n        float specularExponent = specularAngle / (1. - smoothness);\n        float specularHighlight = exp(-specularExponent * specularExponent);\n        float diffseLighting = clamp(dot(normal, sun_derection), 0., 1.);\n        \n        col = object_color * (dot(normal, sun_derection) * 0.5 + 0.5) * shadow + (sun_col * specularHighlight * shadow) * pow(god_ray, 20.);\n    }\n    else\n    {\n        col = vec3(0.35, 0.35, rd.y * 0.5 + 0.5);\n        col = mix(col, sun_col * 1.2, clamp(pow(dot(rd, sun_derection), 120.), 0., 1.));\n    }\n    col *= god_ray;\n\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nll3zB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 47, 47, 76], [79, 79, 111, 111, 183], [186, 186, 239, 239, 380], [383, 383, 405, 405, 785], [788, 788, 809, 809, 1469], [1472, 1472, 1496, 1496, 1697], [1700, 1700, 1757, 1757, 3959]], "test": "valid"}
{"id": "Nls3Rj", "name": "Simple raymarching shader", "author": "Danimtz", "description": "Testing out raymarching and signed distance functions combined with basic blinn phong lighting. \n\"Manual\" bounce light added for better looks. Added soft shadows", "tags": ["raymarching", "sdf", "blinnphonglighting"], "likes": 2, "viewed": 141, "published": "Public API", "date": "1622432838", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 200.0\n#define SURF_DIST 0.01\n#define AA 2\n\n#define SPHERE1 1.0\n#define PLANE 0.0\nfloat sdSphere(vec3 p, float r)//Signed distance function of sphere\n{\n    return length(p) - r;\n}\n\nvec2 compSDF(vec2 sdf1, vec2 sdf2)\n{\n    return sdf1.x<sdf2.x ? sdf1 : sdf2;\n}\n\nvec2 map(vec3 p) //Scene geometry information\n{\n    vec3 sph_o = vec3(cos(0.2*iTime), 2.0, 10.0+3.0*sin(0.2*iTime));\n    vec2 cur_sdf = vec2(1e10, 0.0);\n\n    cur_sdf = compSDF(cur_sdf, vec2(p.y, PLANE)); //plane\n    cur_sdf = compSDF(cur_sdf, vec2(sdSphere(p-sph_o, 2.0), SPHERE1)); //sphere\n    cur_sdf = compSDF(cur_sdf, vec2(sdSphere(p-sph_o+vec3(3.2,0.5,-0.5), 0.7), SPHERE1)); //sphere\n    \n    return cur_sdf;\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd)\n{\n    float dO = 0.001;\n    vec2 res;\n    for(int i = 0; i<MAX_STEPS; i++)\n    {\n        vec3 p = ro + dO*rd; //Go along ray\n        res = map(p); //Calc distance to surface, res.x\n        if(res.x < SURF_DIST || dO>MAX_DIST) break;\n        dO += res.x ;\n    }\n    if (dO > MAX_DIST) dO = -1.0;\n    return vec2(dO, res.y);\n}\n\nfloat calcSoftShdw(vec3 ro, vec3 rd, float k)\n{\n    //more info: https://iquilezles.org/www/articles/rmshadows/rmshadows.htm\n    //Circle circle intersection: https://mathworld.wolfram.com/Circle-CircleIntersection.html\n\n    float res = 1.0; //1.0 if hard shadow\n    float prev_d = 1e10; //previous closest distance to surface\n    for(float t = 0.0; t<MAX_DIST;)\n    {\n        float d = map(ro + t*rd).x;\n        if(d < SURF_DIST){ return 0.0; }\n        float y = d*d/(2.0*prev_d); //y: distance from curr pos to ray midpoint \n        float d_ys = sqrt(d*d-y*y);//d_ms: distance from y to closest surface\n        float sh =  clamp(k*d_ys/max(0.0, t-y),0.0,1.0);\n        \n        res = min(res, sh*sh*(3.0-2.0*sh));//apply smoothstep (3-2x)*x^2\n        prev_d = d;\n        t += d;\n    }\n\n    return res;\n}\n\nvec3 calcNormal(vec3 p)\n{\n    float d = map(p).x; //get distance to surface\n    vec2 e = vec2(0.01, 0);//error bias for difference\n    vec3 n = normalize(vec3( //find normal using small difference\n            d-map(p-e.xyy).x,    \n            d-map(p-e.yxy).x,  \n            d-map(p-e.yyx).x\n    ));\n    return n;\n}\n\n\n\nvec3 render(vec3 ro, vec3 rd)\n{\n    //Raymarch pixel\n    vec2 res = rayMarch(ro, rd); //distance to point p\n    float d = res.x;\n    //sky colour\n    vec3 col = vec3(0.4, 0.6, 0.8) - 0.7*rd.y;\n    if (d > 0.0){\n\n        vec3 p = ro + d*rd;\n        //colour and lights\n        vec3 mat = vec3(0.0);\n        if(res.y<1.0){ mat = vec3(0.017, 0.02, 0.03);}\n        else if(res.y<2.0){ mat = vec3(0.18);}\n\n        \n\n        vec3 lpos = vec3(1.5, 1.5, -1.0);\n        float speed = 1.0;\n        //lpos.xz += vec2(sin(iTime*speed), cos(iTime*speed))*2.;\n\n        //light & normal vectors\n        vec3 l = normalize(lpos-0.0);\n        vec3 n = calcNormal(p);\n\n        //diffuse light\n        float dif = clamp(dot(n,l), 0.0, 1.0);\n        float sky_dif = clamp(0.5+0.5*dot(n,vec3(0.0, 1.0, 0.0)), 0.0, 1.0);\n        float bounce_dif = clamp(0.2+0.2*dot(n,vec3(0.0, -1.0, 0.0)), 0.0, 1.0);\n        float shdw = calcSoftShdw(p+n*SURF_DIST, l, 16.0); //step(rayMarch((p+n*SURF_DIST), l).x, 0.0);//hard shadows\n        \n        //specular light\n        vec3 h = normalize(l + normalize((ro-p)));\n        float spec = pow(max(0.0, dot(n,h)), 128.0);\n        \n\n        vec3 light_in = vec3(0.0);\n        light_in += vec3(7.0, 5.8, 3.6)*dif*shdw;\n        light_in += vec3(0.5, 0.8, 0.6)*sky_dif;\n        light_in += vec3(0.6, 0.3, 0.1)*bounce_dif;\n\n        col = mat*light_in;\n\n        col += mat*spec*shdw;\n    }\n    return (col);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Camera/Ray origin\n    vec3 ro = vec3(0.0, 2.7, -1.2);\n\n\n    vec3 avrg_col = vec3(0.0);\n#if AA>1 //Supersampling AA\n    for(int i = 0; i < AA; i++)\n    for(int j = 0; j < AA; j++){\n        //Pixel coordinates\n        vec2 of = vec2(float(i),float(j)) / float(AA) - 0.5;\n        vec2 uv = ((fragCoord+of)- .5*iResolution.xy)/iResolution.y;\n#else\n        \n        vec2 uv = (fragCoord- .5*iResolution.xy)/iResolution.y;\n#endif\n        \n        //Ray direction\n        vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n        \n        //Render scene\n        vec3 col = render(ro,rd);\n        \n        \n\n        avrg_col += col;\n\n#if AA>1      \n    }\n    avrg_col /= float(AA*AA);//Apply AA\n#endif\n    //gamma\n    avrg_col = pow(avrg_col, vec3(0.4545));\n\n    fragColor = vec4(avrg_col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nls3Rj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[120, 120, 189, 189, 217], [219, 219, 255, 255, 297], [299, 299, 346, 346, 716], [718, 718, 751, 751, 1074], [1076, 1076, 1123, 1295, 1880], [1882, 1882, 1907, 1907, 2197], [2201, 2201, 2232, 2253, 3619]], "test": "valid"}
{"id": "Nls3RN", "name": "disks screensaver", "author": "4eckme", "description": "zzz", "tags": ["2d", "rgb", "disk"], "likes": 4, "viewed": 64, "published": "Public", "date": "1621662448", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// DOT SIZE\nconst int DS=30;\n// DRAW DOT\nbool DOT(int x, int y, ivec2 p)\n{\n    return x==int(p.x) && y==int(p.y);\n}\n// DRAW NUM\nbool DRAW(int i, int sx, int sy, ivec2 p){\n\n    //ivec2 p = ivec2(fragCoord)/DS;\n    \n    if (i==-1) return//Num :\n    DOT(sx+2,sy+2,p)||\n    DOT(sx+2,sy+4,p)\n    ;\n    \n    if (i==0) return//Num 0\n    DOT(sx+1,sy+1,p)||\n    DOT(sx+2,sy+1,p)||\n    DOT(sx+3,sy+1,p)||\n    DOT(sx+1,sy+5,p)||\n    DOT(sx+2,sy+5,p)||\n    DOT(sx+3,sy+5,p)||\n    DOT(sx+1,sy+2,p)||\n    DOT(sx+1,sy+3,p)||\n    DOT(sx+1,sy+4,p)||\n    DOT(sx+3,sy+2,p)||\n    DOT(sx+3,sy+3,p)||\n    DOT(sx+3,sy+4,p)\n    ;\n\n    if (i==1) return//Num 1\n    DOT(sx+1,sy+1,p)||\n    DOT(sx+2,sy+1,p)||\n    DOT(sx+3,sy+1,p)||\n    DOT(sx+2,sy+2,p)||\n    DOT(sx+2,sy+3,p)||\n    DOT(sx+2,sy+4,p)||\n    DOT(sx+2,sy+5,p)||\n    DOT(sx+1,sy+4,p)\n    ;\n    \n    if (i==2) return//Num 2\n    DOT(sx+1,sy+1,p)||\n    DOT(sx+2,sy+1,p)||\n    DOT(sx+3,sy+1,p)||\n    DOT(sx+1,sy+2,p)||\n    DOT(sx+1,sy+3,p)||\n    DOT(sx+2,sy+3,p)||\n    DOT(sx+3,sy+3,p)||\n    DOT(sx+3,sy+4,p)||\n    DOT(sx+3,sy+5,p)||\n    DOT(sx+1,sy+5,p)||\n    DOT(sx+2,sy+5,p)\n    ;\n    \n    if (i==3) return//Num 3\n    DOT(sx+1,sy+1,p)||\n    DOT(sx+2,sy+1,p)||\n    DOT(sx+3,sy+1,p)||\n    DOT(sx+1,sy+5,p)||\n    DOT(sx+2,sy+5,p)||\n    DOT(sx+3,sy+5,p)||\n    DOT(sx+1,sy+3,p)||\n    DOT(sx+3,sy+2,p)||\n    DOT(sx+3,sy+3,p)||\n    DOT(sx+3,sy+4,p)||\n    DOT(sx+2,sy+3,p)\n    ;\n    \n    if (i==4) return//Num 4\n    DOT(sx+3,sy+1,p)||\n    DOT(sx+1,sy+5,p)||\n    DOT(sx+3,sy+5,p)||\n    DOT(sx+1,sy+3,p)||\n    DOT(sx+1,sy+4,p)||\n    DOT(sx+3,sy+2,p)||\n    DOT(sx+3,sy+3,p)||\n    DOT(sx+3,sy+4,p)||\n    DOT(sx+2,sy+3,p)\n    ;   \n\n    if (i==5) return//Num 5\n    DOT(sx+3,sy+1,p)||\n    DOT(sx+2,sy+1,p)||\n    DOT(sx+1,sy+1,p)||\n    DOT(sx+3,sy+2,p)||\n    DOT(sx+3,sy+3,p)||\n    DOT(sx+2,sy+3,p)||\n    DOT(sx+1,sy+3,p)||\n    DOT(sx+1,sy+4,p)||\n    DOT(sx+1,sy+5,p)||\n    DOT(sx+3,sy+5,p)||\n    DOT(sx+2,sy+5,p)\n    ;\n\n    if (i==6) return//Num 6\n    DOT(sx+3,sy+1,p)||\n    DOT(sx+2,sy+1,p)||\n    DOT(sx+1,sy+1,p)||\n    DOT(sx+3,sy+2,p)||\n    DOT(sx+3,sy+3,p)||\n    DOT(sx+2,sy+3,p)||\n    DOT(sx+1,sy+3,p)||\n    DOT(sx+1,sy+4,p)||\n    DOT(sx+1,sy+5,p)||\n    DOT(sx+3,sy+5,p)||\n    DOT(sx+2,sy+5,p)||\n    DOT(sx+1,sy+2,p)\n    ;\n    \n    if (i==7) return//Num 7\n    DOT(sx+3,sy+1,p)||\n    DOT(sx+3,sy+3,p)||\n    DOT(sx+3,sy+2,p)||\n    DOT(sx+3,sy+4,p)||\n    DOT(sx+2,sy+5,p)||\n    DOT(sx+1,sy+5,p)||\n    DOT(sx+3,sy+5,p)\n    ;\n\n    if (i==8) return//Num 8\n    DOT(sx+1,sy+1,p)||\n    DOT(sx+2,sy+1,p)||\n    DOT(sx+3,sy+1,p)||\n    DOT(sx+1,sy+5,p)||\n    DOT(sx+2,sy+5,p)||\n    DOT(sx+3,sy+5,p)||\n    DOT(sx+1,sy+2,p)||\n    DOT(sx+1,sy+3,p)||\n    DOT(sx+1,sy+4,p)||\n    DOT(sx+3,sy+2,p)||\n    DOT(sx+3,sy+3,p)||\n    DOT(sx+3,sy+4,p)||\n    DOT(sx+2,sy+3,p)\n    ;\n\n    if (i==9) return//Num 9\n    DOT(sx+1,sy+1,p)||\n    DOT(sx+2,sy+1,p)||\n    DOT(sx+3,sy+1,p)||\n    DOT(sx+1,sy+5,p)||\n    DOT(sx+2,sy+5,p)||\n    DOT(sx+3,sy+5,p)||\n    DOT(sx+1,sy+3,p)||\n    DOT(sx+1,sy+4,p)||\n    DOT(sx+3,sy+2,p)||\n    DOT(sx+3,sy+3,p)||\n    DOT(sx+3,sy+4,p)||\n    DOT(sx+2,sy+3,p)\n    ;\n    \n    if (i==10) return//Num A\n    DOT(sx+1,sy+1,p)||\n    DOT(sx+2,sy+3,p)||\n    DOT(sx+3,sy+1,p)||\n    DOT(sx+2,sy+5,p)||\n    DOT(sx+1,sy+2,p)||\n    DOT(sx+1,sy+3,p)||\n    DOT(sx+1,sy+4,p)||\n    DOT(sx+3,sy+2,p)||\n    DOT(sx+3,sy+3,p)||\n    DOT(sx+3,sy+4,p)\n    ;\n    \n    \n    if (i==11) return//Num B\n    DOT(sx+1,sy+1,p)||\n    DOT(sx+2,sy+1,p)||\n    DOT(sx+3,sy+1,p)||\n    DOT(sx+1,sy+5,p)||\n    DOT(sx+2,sy+5,p)||\n    DOT(sx+3,sy+5,p)||\n    DOT(sx+1,sy+2,p)||\n    DOT(sx+1,sy+3,p)||\n    DOT(sx+1,sy+4,p)||\n    DOT(sx+3,sy+2,p)||\n    DOT(sx+3,sy+4,p)||\n    DOT(sx+2,sy+3,p)\n    ;\n    \n    if (i==12) return//Num C\n    DOT(sx+2,sy+1,p)||\n    DOT(sx+3,sy+1,p)||\n    DOT(sx+2,sy+5,p)||\n    DOT(sx+3,sy+5,p)||\n    DOT(sx+1,sy+2,p)||\n    DOT(sx+1,sy+3,p)||\n    DOT(sx+1,sy+4,p)\n    ;\n    \n    if (i==13) return//Num D\n    DOT(sx+1,sy+1,p)||\n    DOT(sx+2,sy+1,p)||\n    DOT(sx+1,sy+5,p)||\n    DOT(sx+2,sy+5,p)||\n    DOT(sx+1,sy+2,p)||\n    DOT(sx+1,sy+3,p)||\n    DOT(sx+1,sy+4,p)||\n    DOT(sx+3,sy+2,p)||\n    DOT(sx+3,sy+3,p)||\n    DOT(sx+3,sy+4,p)\n    ;\n    \n    if (i==14) return//Num E\n    DOT(sx+3,sy+1,p)||\n    DOT(sx+2,sy+1,p)||\n    DOT(sx+1,sy+1,p)||\n    DOT(sx+3,sy+5,p)||\n    DOT(sx+2,sy+5,p)||\n    DOT(sx+1,sy+5,p)||\n    DOT(sx+3,sy+3,p)||\n    DOT(sx+1,sy+2,p)||\n    DOT(sx+1,sy+3,p)||\n    DOT(sx+1,sy+4,p)||\n    DOT(sx+2,sy+3,p)\n    ;\n    \n    if (i==15) return//Num F\n    DOT(sx+1,sy+1,p)||\n    DOT(sx+3,sy+5,p)||\n    DOT(sx+2,sy+5,p)||\n    DOT(sx+1,sy+5,p)||\n    DOT(sx+3,sy+3,p)||\n    DOT(sx+1,sy+2,p)||\n    DOT(sx+1,sy+3,p)||\n    DOT(sx+1,sy+4,p)||\n    DOT(sx+2,sy+3,p)\n    ;\n    return false;\n}\n\nfloat R=100.0; float R2=100.0;\nfloat SPEED=200.0; float SPEED2=-200.0; \nfloat pi = 3.14159265358979323846264338327950288;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 c = fragCoord-iResolution.xy/2.0;float X=c.x;float Y = c.y;\n    float T = iTime; float O = pow(fragCoord.x,2.0)+pow(fragCoord.y,2.0)+T*100.0;\n    float W1 = 5.0;\n    float W2 = 10.0;\n    float W3 = 20.0;\n    float Z = abs(cos((O)/pi/W1)-sin((O)/pi/W1));\n    float ZX = abs(cos((O)/pi/W2)-sin((O)/pi/W2));\n    float ZY = abs(cos((O)/pi/W3)-sin((O)/pi/W3));\n    fragColor = vec4(\n        ZX,\n        abs(ZX-ZY),\n        ZY,\n        0\n    );\n    \n    float dx = 0.0;float dy=0.0;\n    float tx = (T*SPEED)+0.002;float ty = (T*SPEED)+0.002;\n    if (mod(tx,iResolution.x*2.0) > iResolution.x) tx = -tx;\n    if (mod(ty,iResolution.y*2.0) > iResolution.y) ty = -ty;\n    /* float dx1 = 0.0; float dy1=0.0;\n    float tx1 = (T*200.0)+iResolution.x; float ty1 = T*200.0+iResolution.y;\n    if (mod(tx1,iResolution.x*2.0) > iResolution.x) tx1 = -tx1;\n    if (mod(ty1,iResolution.y*2.0) > iResolution.y) ty1 = -ty1; */\n    float dx2 = 0.0; float dy2=0.0;T=T+777.0;\n    float tx2 = (T*SPEED2)-iResolution.x/2.0+0.001; float ty2 = 0.001+T*SPEED2-iResolution.y/2.0;\n    if (mod(tx2,iResolution.x*2.0) > iResolution.x) tx2 = -tx2;\n    if (mod(ty2,iResolution.y*2.0) > iResolution.y) ty2 = -ty2;\n    \n    dx=abs(mod(tx, iResolution.x))-iResolution.x/2.0;\n    dx*=(iResolution.x-R*2.0)/iResolution.x;\n    dy=abs(mod(ty, iResolution.y))-iResolution.y/2.0;\n    dy*=(iResolution.y-R*2.0)/iResolution.y;\n    /* dx1=abs(mod(tx1, iResolution.x))-iResolution.x/2.0;\n    dx1*=(iResolution.x-200.0)/iResolution.x;\n    dy1=abs(mod(ty1, iResolution.y))-iResolution.y/2.0;\n    dy1*=(iResolution.y-200.0)/iResolution.y; */\n    dx2=abs(mod(tx2, iResolution.x))-iResolution.x/2.0;\n    dx2*=(iResolution.x-2.0*R2)/iResolution.x;\n    dy2=abs(mod(ty2, iResolution.y))-iResolution.y/2.0;\n    dy2*=(iResolution.y-2.0*R2)/iResolution.y;\n    \n    if((X-dx)*(X-dx)+(Y-dy)*(Y-dy)<=R*R) {\n         fragColor-=vec4(Z)/3.0;\n    } vec4 fc = fragColor;\n    fc = fragColor;\n    if((X-dx2)*(X-dx2)+(Y-dy2)*(Y-dy2)<=R2*R2) {\n         fragColor+=vec4(Z)/3.0;\n    }\n    \n    int SX=(int(iResolution.x)/DS-18)/2;\n    int SY=(int(iResolution.y)/DS-7)/2;\n    \n    float H=iDate.w/3600.0;\n    float M=mod(iDate.w/60.0, 60.0);\n    int hh=int(H/10.0); int h=int(mod(H,10.0));\n    int mm=int(M/10.0); int m=int(mod(M,10.0));\n    ivec2 p = ivec2(fragCoord)/DS;\n    if(p.x>=SX+1&&p.x<=SX+17&&p.y>=SY+1&&p.y<=SY+5) {\n        if(DRAW(hh,SX,SY,p)) fragColor*=vec4(1.2,0.2,0.3,1);\n        if(DRAW(h,SX+=4,SY,p)) fragColor*=vec4(1.2,0.2,0.3,1);\n        if(DRAW(-1,SX+=3,SY,p)) fragColor*=vec4(1.2,0.2,0.3,1);\n        if(DRAW(mm,SX+=3,SY,p)) fragColor*=vec4(1.2,0.2,0.3,1);\n        if(DRAW(m,SX+=4,SY,p)) fragColor*=vec4(1.2,0.2,0.3,1);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nls3RN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 41, 74, 74, 115], [116, 128, 170, 208, 4693]], "test": "valid"}
{"id": "Nls3z2", "name": "myco-fractal3", "author": "Shellderr", "description": "myco-fract3", "tags": ["fractal", "spore"], "likes": 1, "viewed": 55, "published": "Public", "date": "1622448804", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define res iResolution\n#define ft float\n\nft hm(vec2 uv, vec2 m){\n    ft a = dot(uv,uv);\n    ft b = (sin(.6*iTime+uv.x/a/m.x))-sin(uv.y/a/m.y);\nreturn abs(b*1.4)*a;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (5.*fragCoord.xy-res.xy)/res.y;\n    vec2 m = vec2(.3);\n    vec2 mouse = iMouse.y < 1.? vec2(.5,.05): iMouse.xy/res.xy;\n    ft a = hm(uv, m);\n    for(ft i; i < 8.; i++){\n    uv = abs(uv/hm(uv,m+i*.2)-.4*mouse);\n    }\n    fragColor = vec4(1.-uv.xyy,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nls3z2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 42, 65, 65, 166], [168, 168, 224, 224, 493]], "test": "valid"}
{"id": "NlsGR8", "name": "Equirectangular Projection_test", "author": "kithy", "description": "I would like to map 2D Texture Image to raymarching sphere using Equirectangular Projection...but something went wrong:(", "tags": ["raymarching", "texture", "equirectangular"], "likes": 0, "viewed": 40, "published": "Public", "date": "1621524663", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592\n#define ITR 64\n#define EPS 0.001\n\nmat2 rot(float a){\n\tfloat s=sin(a);\n\tfloat c=cos(a);\n\treturn mat2(c,-s,s,c);\n}\n\nfloat sdSphere(vec3 p){\n\treturn length(p)-0.8;\n}\n\nvec3 genNormal(vec3 p){\n\treturn normalize(vec3(\n\t\tsdSphere(p+vec3(EPS,0.0,0.0))-sdSphere(p+vec3(-EPS,0.0,0.0)),\n\t\tsdSphere(p+vec3(0.0,EPS,0.0))-sdSphere(p+vec3(0.0,-EPS,0.0)),\n\t\tsdSphere(p+vec3(0.0,0.0,EPS))-sdSphere(p+vec3(0.0,0.0,-EPS))\n\t));\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n\tvec2 uv=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\tvec2 vTexCoord=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    //vec2 vTexCoord=fragCoord;\n\n\tfloat longitude=vTexCoord.x*2.0*PI-PI+PI/2.0;\n\tfloat latitude=vTexCoord.y*PI;\n\tvec3 dir=vec3(\n\t\t-sin(longitude)*sin(latitude),\n\t\tcos(latitude),\n\t\t-cos(longitude)*sin(latitude)\n\t\t);\n\n\tnormalize(dir);\n\n\tvec3 ro=vec3(0.0,0.0,0.0);\n\tvec3 rd=normalize(vec3(uv,1.0));\n\n\tfloat d=0.0;\n\tvec3 normal;\n\n\tfor(int i=0;i<ITR;i++){\n\t\tdir.xy*=fract(iTime*0.1);\n\t\td=sdSphere(dir);\n\t\tdir+=ro+rd*d;\n\t\tif(d<EPS)break;\n\t\tnormal=genNormal(dir);\n\t}\n\n\tvec3 color=texture(iChannel0,dir.xy).rgb;\n\n\tfragColor=vec4(color+normal,1.0);\n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlsGR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 54, 72, 72, 132], [134, 134, 157, 157, 182], [184, 184, 207, 207, 429], [431, 431, 484, 484, 1149]], "test": "error"}
{"id": "NlsGWn", "name": "Thing 3", "author": "ebenupton", "description": "Getting a bit silly now.", "tags": ["lavalamp"], "likes": 1, "viewed": 36, "published": "Public", "date": "1621896097", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float squares (float x, float y, float rep)\n{\n    if ((int(floor(x/rep))&1) == (int(floor(y/rep))&1))\n        return 1.0;\n    else\n        return 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float f = fragCoord.x/1000.0+fragCoord.y/2000.0+1.0+iTime/10.0;\n    \n    float f1 = (1.0+sin(iTime))/2.0;\n    float f2 = 1.0-f1;\n    \n    mat2 m = mat2 (f1*sin(f)+f2*cos(f), sin(f), -sin(f), f1*sin(f)+f2*cos(f));\n    \n    vec2 k = (fragCoord.xy-iResolution.xy/2.0)*m;\n\n\tvec3 pixel;\n\n    pixel.r = squares(k.x, k.y+iTime*200.0, 96.0);\n    pixel.g = squares(k.x+iTime*100.0, k.y, 112.0);\n    pixel.b = squares(k.x+iTime*500.0, k.y+iTime*50.0, 200.0);\n\n\tfragColor = vec4(pixel, 1.0);\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlsGWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[154, 154, 211, 211, 698]], "test": "valid"}
{"id": "NlX3Rf", "name": "Сollector", "author": "avin", "description": "visual experiment", "tags": ["tubes", "weaving", "weave", "wicker"], "likes": 4, "viewed": 146, "published": "Public API", "date": "1622486516", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592653589\n\n#define COL1 vec3(1.,0.,0.5)\n#define COL2 vec3(1.,0.8,0.2)\n#define SHADOW vec3(0.)\n\n\n\n#define SF 1./min(iResolution.x,iResolution.y)*.5*SCALE\n#define SS(l,s) smoothstep(SF,-SF,l-s)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ouv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.x;  \n    \n    float SCALE = 1.75 + sin(iTime*.5)*.125;\n    \n    ouv *= SCALE;       \n    \n    vec3 col = vec3(0.);\n    \n    for(float ir=0.;ir<2.;ir+=1.){\n    \n        vec2 uv = ouv;\n        \n        \n        float ca = cos(PI * .25 * ir);\n        float sa = sin(PI * .25 * ir);\n        mat2 rot = mat2(ca, -sa, sa, ca);\n        uv *= rot;        \n                \n        // uv = abs(uv);\n    \n        for(int i=0;i<2;i+=1){\n\n            float x;\n            float y;\n\n            float fr = 16.;\n\n            if(i==0){\n                y = uv.x*fr;\n                x = uv.y;\n            } else {\n                y = uv.y*fr;\n                x = uv.x;\n            }\n            \n            float wooble = sin(-iTime*10. + length(uv)*10.)*.25+.5;\n\n\n            float sf = .05 + wooble*.01 ;   \n            float w = .025 + wooble*.01 ;\n            float ssFrom=.05;\n            float ssTo=.02;\n\n            float l = length(uv);\n            float shDraw; \n            if(ir == 0.){\n                shDraw = step(.15, l);\n            } else {\n                shDraw = step(.25, l);\n            }  \n            \n            \n\n            float d1v = abs(x + sin(y)*sf);    \n            float d1 = SS(d1v, w);\n            float d1o = 1. - smoothstep(0., w*2.25, d1v);\n            float d1s = smoothstep(ssFrom, ssTo, d1v) * shDraw;\n\n            float d2v = abs(x + sin(y + PI)*sf);   \n            float d2 = SS(d2v, w);\n            float d2o = 1. - smoothstep(0., w*2.25, d2v);\n            float d2s = smoothstep(ssFrom, ssTo, d2v) * shDraw;\n\n            float v = sin(y +  PI*.25);\n\n\n            if(v > 0.){\n                col = mix(col, COL1 * d1o, d1);                \n                col = mix(col, SHADOW, d2s); \n                col = mix(col, COL2* d2o, d2);  \n            } else {          \n                col = mix(col, COL2* d2o, d2);  \n                col = mix(col, SHADOW, d1s); \n                col = mix(col, COL1* d1o, d1);  \n            }\n\n            col *= SS(.035 + wooble*.015, l);\n\n        }\n    }\n    \n        \n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlX3Rf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[209, 209, 266, 266, 2408]], "test": "valid"}
{"id": "NlX3zH", "name": "Pulsing Color Pattern", "author": "ashishkingdom", "description": "Hey! This is my second shader! and I'm still learning GLSL. The shader just repeat some colorful pattern based on time.\nYour comments are welcome!", "tags": ["beginner", "color", "learning", "pattern"], "likes": 1, "viewed": 79, "published": "Public", "date": "1621497351", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n    @Title: Pulsing Color Pattern\n    @Author: AshishKingdom\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    vec2 P = fragCoord;\n    P/=iResolution.xy;\n    vec2 R, S;\n    float rad = abs(0.5*sin(t));\n    S.x = 0.5+rad*sin(t*3.0);\n    S.y = 0.5+rad*cos(t*3.0);\n    R.x = abs(sin(t*3.0)*length(P));\n    R.y = abs(cos(t*3.0)*length(P));\n    fragColor = vec4(R.x*2.0,length(P-S),R.y,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlX3zH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 67, 124, 124, 427]], "test": "valid"}
{"id": "NlXGDH", "name": "[OUTLINE 2021] - Le Mandel Cube", "author": "totetmatt", "description": "1st Showdown from Outline 2021 :\n\nAs usual, not fully identical to bonzomatic, find original here :\n https://psenough.github.io/shader_summary/shader_file_sources/outline_shader_showdown_2021/outline_2021_totetmatt_1.glsl", "tags": ["mandelbrot", "cube", "outline", "showdown"], "likes": 8, "viewed": 212, "published": "Public API", "date": "1622020702", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 texNoise(vec2 uv,sampler2D tex ){ float f = 0.; f+=texture(tex, uv*.125).r*.5; f+=texture(tex,uv*.25).r*.25; //Funciton simulating the perlin noise texture we have in Bonzomatic shader editor, written by yx\n                       f+=texture(tex,uv*.5).r*.125; f+=texture(tex,uv*1.).r*.125; f=pow(f,1.2);return vec4(f*.45+.05);}\n\n#define texFFTIntegrated (floor(iTime*.5)+pow(fract(iTime*.5),.125))*.43\n#define texFFTIntegrated2 (floor(iTime*.33)+pow(fract(iTime*.33),.5))*.37\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\n\n\n\nfloat mandel(vec2 uv,float l){\n    float bi3 = texFFTIntegrated;\n    vec2 z = uv;\n    vec2 c = vec2(-.856,.401);\n    float i=0.;\n    for(;i<=l;i++){\n        z = vec2(z.x*z.x-z.y*z.y,2.*z.x*z.y)+ c;\n        z*=rot(floor(bi3*20.));\n        if(length(z) >=2.) break;\n        \n    }\n    return i/l;\n}\nfloat box(vec3 p,vec3 b){\n\n    vec3 q = abs(p)-b;\n    return length(max(vec3(0.),q))+min(0.,max(q.x,max(q.y,q.z)));\n }\nvec2 sdf(vec3 p){\n    float _bit3 = texFFTIntegrated;\n  float _bit6 = texFFTIntegrated2;\n    p.xz *=rot(iTime);\n    vec3 pp= p;\n      p.xy *=rot(floor(_bit3*50.)*6.66);\n     p.zy *=rot(floor(_bit6*75.)*3.66);\n     vec2 mandeluv = vec2(abs(atan(p.x,abs(p.z))),p.y);\n    float q = mandel(mandeluv,10.);\n    vec2 h;\n    h.x = box(p,vec3(1.0-q*.1));\n    h.x = max(h.x,-box(p,vec3(.9-q*.1)));\n    h.y = 1.-q;\n    h.x *=.9;\n  \n    vec2 t;\n    t.x = -box(pp,vec3(10.));\n  \n     pp = abs(pp)-2.5;\n     t.x  = min(box(pp,vec3(1.)),t.x);\n    t.y = t.x == box(pp,vec3(1.)) ? 3.:2.;\n  \n      h = h.x < t.x ? h:t; \n    return h;\n}\nvec2 nv=vec2(-.001,.001);\n#define q(s) s*sdf(p+s).x\nvec3 norm(vec3 p){return normalize(q(nv.xyy)+q(nv.yxy)+q(nv.yyx)+q(nv.xxx));}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n\n      float _bit3 = texFFTIntegrated;\n     _bit3 = cos(texNoise(vec2(uv*.5),iChannel1).r+floor(_bit3*33.)*6.66)*.5;\n   \n  vec3 ro = vec3(0.,0.,-5.),rd=normalize(vec3(uv,1.-_bit3 )),rp=ro;\n  vec3 light= vec3(1.,2.,-3.);\n  \n  \tvec3 col =vec3(.1);\n  \n  vec3 acc = vec3(0.);\n  for(float i=0.;i<=69.;i++){\n      vec2 d = sdf(rp);\n     \n      if(d.y <=.1) {\n          acc += vec3(.1,7,.2)*exp(-abs(d.x))/59.;\n          d.x = max(0.02,abs(d.x));\n      }\n    \n    \n      if(d.x<=0.01) {\n          vec3 n= norm(rp);\n        \n        \n         if(d.y>.1 && d.y <=1.){\n             if(d.y >.5) {\n          col = vec3(.2,.5,.7)*max(0.,dot(normalize(light-rp),n));\n             } else {\n                 col = vec3(9.,.5,.1)*max(0.,dot(normalize(light-rp),n));\n               }\n             break;\n         } \n         if(d.y ==2.){\n             float noize = texNoise(rp.xz*10.,iChannel1).r*.01;\n             col*=vec3(.1,.7,.5)*1.2;\n             rd = reflect(rd,n+noize);\n             rp+=rd*.01;\n           }\n                    if(d.y ==3.){\n             float noize = texNoise(rp.xz*10.,iChannel1).r*.01;\n             col*=vec3(.1,.7,.5)*2.2;\n             rd = reflect(rd,n+noize);\n             rp+=rd*.01;\n           }\n        \n      }\n      rp+=rd*d.x;\n  }\n  col += acc;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlXGDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 332], [481, 481, 499, 499, 546], [550, 550, 580, 580, 846], [847, 847, 872, 872, 965], [966, 966, 983, 983, 1583], [1636, 1636, 1654, 1654, 1713], [1714, 1714, 1771, 1821, 3204]], "test": "error"}
{"id": "NlXGWM", "name": "pattern study", "author": "sympou", "description": "a nice pattern that reminds me of the late sixties !", "tags": ["pattern"], "likes": 9, "viewed": 173, "published": "Public API", "date": "1622225977", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pixSize = 50.0;\nconst float lineWidth = 0.8;\n\nconst vec3 col1 = vec3(.1,.4, 1.);\nconst vec3 col2 = vec3(.1,.1,.4 );\n\n//Dave_Hoskins's hash function\n//https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 fc = fragCoord+iTime*20.;\n    \n    //coordinates of the cell\n    vec2 uv = floor(fc / pixSize);\n    \n    //position inside the cell (0 to pixSize)\n    vec2 diff = mod(fc,pixSize);\n    \n    //direction of the 2 closest cell boundaries\n    vec2 clo = sign(diff-pixSize*0.5);\n    \n    //////\n    \n    // each cell is assigned a random direction (0 to 3)\n    int r = int(hash12(uv)*4.);\n    // w1 and w2 indicates the direction of our cell's closest walls (same 0 to 3 format)\n    int w1 = int(clo.x + 1.);\n    int w2 = int(max(clo.y*2.0,0.0) + 1.);\n    \n    //\n    \n    //we also check the random number of the 2 neighbour cells\n    int rX = int( hash12(uv + vec2(clo.x,0.0))*4.0 );\n    int rY = int( hash12(uv + vec2(0.0,clo.y))*4.0 );\n    //oposite directions\n    int wX = (w1+2)%4;\n    int wY = (w2+2)%4;\n    \n    ////\n        \n    vec3 pix = vec3(0.0); \n    \n    //is our point inside the width of the line ?\n    vec2 truc = abs(diff-pixSize*0.5) - (1.-lineWidth)*0.5*pixSize;\n    \n    // if so, we add color\n    if ( r==w1 && truc.x>0.0 || r==w2 && truc.y>0.0 ) {\n        pix = col1;\n    }\n    \n    // same thing for the neigbours\n    if ( wX==rX && truc.x>0.0 ) {\n        pix += col1;\n    }\n\n    if ( wY==rY && truc.y>0.0 ) {\n        pix += col1;\n    }\n    \n    //round ends\n    if ( pix==vec3(0) && length(abs(diff-pixSize*0.5)-pixSize*0.5) < pixSize*lineWidth*0.5 ) {\n        pix += col1;\n    }\n\n    //if ( (dot(pix,vec3(1.)) == 0.0) && (length(diff-pixSize*0.5) < pixSize*0.3)) {\n    //    pix = vec3(.1,.1,.7);\n    //}\n    \n    //background\n    if ( pix==vec3(0) ) {\n        pix = col2;\n    }\n    \n    fragColor = vec4(pix,1.);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlXGWM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[129, 200, 222, 222, 339], [341, 341, 398, 398, 2054]], "test": "valid"}
{"id": "NlXGz8", "name": "chladni gradient field", "author": "aganztracy", "description": "chladni simulation test", "tags": ["chladnisimulation"], "likes": 1, "viewed": 64, "published": "Public", "date": "1621477470", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define HASHSCALE1 443.8975\n\n#define KALEIDOSCOPE_SPEED_X    4.0\n#define KALEIDOSCOPE_SPEED_Y  -10.0\n#define KALEIDOSCOPE_SPLITS     2.0\n\n#define PI 3.14159265359\n\n//reference：https://www.shadertoy.com/view/XdtBWH\nvec2 kaleidoscope(vec2 uv, vec2 offset, float splits)\n{\n    // XY coord to angle\n    float angle = atan(uv.y, uv.x);\n    // Normalize angle (0 - 1)\n    angle = ((angle / PI) + 1.0) * 0.5;\n    // Rotate by 90°\n    angle = angle + 0.25;\n    // Split angle \n    angle = mod(angle, 1.0 / splits) * splits;\n    \n    // Warp angle\n#ifndef LINEAR\n    float a = (2.0*angle - 1.0);\n    angle = -a*a + 1.0;\n    \n    //angle = -pow(a, 0.4) + 1.0;\n#else\n    angle = -abs(2.0*angle - 1.0) + 1.0;\n#endif\n    \n    angle = angle*0.2;\n    \n    // y is just dist from center\n    float y = length(uv);\n    //y = (y*30.0);\n    \n#ifdef FIX_X\n    //angle = angle * (y*1.0);\n#endif\n    \n    return vec2(angle, y) + offset;\n}\n\nvec2 SymmUV(vec2 uv, float splits){\n    float angle = atan(uv.y, uv.x);\n    //// Normalize angle (0 - 1)\n    angle = ((angle / PI) + 1.0) * 0.5;\n    //split angle\n    angle = mod(angle, 1.0 / splits) * splits;\n    angle = abs((angle -0.5)*2.);\n    angle *= 0.4;\n    \n    float y = length(uv);\n    uv = vec2(cos(angle),sin(angle))*y;\n    return uv;\n}\n//repeat the position in 'pos' every 'q' degree in polar space\nvec2 fan(in vec2 pos, in float q) \n{\n    pos-= vec2(0.5,0.5);\n    pos.x*=iResolution.x/iResolution.y;\n    //q = q / 180. * 3.14159265;\n    //float ang = atan(pos.x, pos.y),\n    //len = length(pos.xy );\n    //ang = mod(ang + q/2., q) - q/2.;\n    //pos.xy = len * vec2(sin(ang), cos(ang));\n    return pos;\n}\n\nfloat hash11(float p)\n{\n\tvec3 p3  = fract(vec3(p) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat lerp(float a, float b, float t)\n{\n\treturn a + t * (b - a);\n}\n\nfloat noise(float p)\n{\n\tfloat i = floor(p);\n    float f = fract(p);\n    \n    float t = f * f * (3.0 - 2.0 * f);\n    \n    return lerp(f * hash11(i), (f - 1.0) * hash11(i + 1.0), t);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;   \n    float signuvx = -sign(uv.x - 0.5);\n    float signuvy = sign(uv.y - 0.5);\n    ////////////////////////////////////////\n    \n\n    uv = fan(uv,45.);\n    vec2 UV = uv;\n    \n    vec2 A = vec2(sin(1.) * 4. * 0.005, \n                  sin(1.) * -10. * 0.005);\n\t//uv = kaleidoscope(uv, A, 8.);//8份对称\n    //uv = abs(uv * 2. - 1.);\n    \n    uv = SymmUV(uv,8.);\n\n    ////mod(angle, 1.0 / splits) * splits = fract(angle * splits);\n    \n    \n    uv.x *= iResolution.x/iResolution.y;\n\n    float m = 3. + sin(iTime*1.2*noise(iTime*0.003))*2.;\n    float n = 4. + sin(iTime*1.3*noise(iTime*0.001))*3.;\n    float L = 1.;\n    float value = cos(PI*n*uv.x/L)*cos(PI*m*uv.y/L)-cos(PI*m*uv.x/L)*cos(PI*n*uv.y/L);\n    value = (value + 1.)*0.5;\n    float finalValue = 10000.;\n    float stepx = 1.0 / iResolution.x;\n    float stepy = 1.0 / iResolution.y;\n    float directionx = 0.;\n    float directiony = 0.;\n    //for (float ny = -1.; ny <= 1.; ny++) {\n    //    for (float nx = -1.; nx <= 1.; nx++) {\n    //        if (nx == 0. && ny == 0.) {\n    //            continue;  // ourselves!\n    //       }\n    //        float tempValue = cos(PI*n*(uv.x+ nx * stepx)/L)*cos(PI*m*(uv.y+ ny * stepy)/L)-cos(PI*m*(uv.x+ nx * stepx)/L)*cos(PI*n*(uv.y+ ny * stepy)/L); \n    //       if (tempValue < finalValue){\n     //           finalValue = tempValue;\n                \n      //          if(abs(nx)>abs(ny)){\n     //               nx = sign(nx)*ny;\n     //               ny = sign(ny)*nx;\n      //          }\n     //           directionx = (nx * signuvx +1.)*0.5 ;\n     //           directiony = (ny * signuvy +1.)*0.5 ;\n      //      }\n      //  }\n    //}\n    \n    //float a = (atan(UV.x, UV.y)+PI)/PI*0.5;\n    float a = atan(UV.x, UV.y);\n    \n    for(float angle = 0.;angle < 2.*PI; angle+=PI*0.125*0.5){//对于所有的方向，计算出当前粒子所在位置对应的运动方向\n        float nx = cos(angle);\n        float ny = sin(angle);\n        \n         float tempValue = cos(PI*n*(uv.x + nx * stepx)/L)*cos(PI*m*(uv.y + ny * stepy)/L)-cos(PI*m*(uv.x+ nx * stepx)/L)*cos(PI*n*(uv.y+ ny * stepy)/L); \n            if (tempValue < finalValue){\n                finalValue = tempValue;\n                \n                if(a>=0.*PI&&a<0.25*PI){\n                    directionx = (nx+1.)*0.5 ;\n                    directiony = (ny+1.)*0.5 ;\n                }\n                else if(a>=0.25*PI&&a<0.5*PI){\n                    directionx = (ny+1.)*0.5 ;\n                    directiony = (nx+1.)*0.5 ;\n                }\n                else if(a>=0.5*PI&&a<0.75*PI){\n                    directionx = (ny+1.)*0.5 ;\n                    directiony = (-nx+1.)*0.5 ;\n                }\n                else if(a>=0.75*PI&&a<1.*PI){\n                    directionx = (nx+1.)*0.5 ;\n                    directiony = (-ny+1.)*0.5 ;\n                }\n                else if(a>=-1.*PI&&a<-0.75*PI){\n                    directionx = (-nx+1.)*0.5 ;\n                    directiony = (-ny+1.)*0.5 ;\n                }else if(a>=-0.75*PI&&a<-0.5*PI){\n                    directionx = (-ny+1.)*0.5 ;\n                    directiony = (-nx+1.)*0.5 ;\n                }else if(a>=-0.5*PI&&a<-0.25*PI){\n                    directionx = (-ny+1.)*0.5 ;\n                    directiony = (nx+1.)*0.5 ;\n                }else if(a>=-0.25*PI&&a<0.*PI){\n                    directionx = (-nx+1.)*0.5 ;\n                   directiony = (ny+1.)*0.5 ;\n                }\n\n            }    \n    }\n    //fragColor = vec4(uv.x*0.6,0.0,0.0, 1.0);\n    //fragColor = vec4(UV.x,UV.y,0.0, 1.0);\n    //fragColor = vec4(directionx,directiony,0.0, 1.0);\n    fragColor = vec4(directionx,directiony,value, 1.0);\n    //fragColor = vec4(value,value,value, 1.0);\n    //fragColor = vec4(uv,0., 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlXGz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[164, 216, 271, 296, 918], [920, 920, 955, 955, 1269], [1270, 1333, 1369, 1369, 1638], [1640, 1640, 1663, 1663, 1781], [1783, 1783, 1822, 1822, 1849], [1851, 1851, 1873, 1873, 2033], [2034, 2034, 2091, 2141, 5912]], "test": "valid"}
{"id": "Ns2SRK", "name": "Cloud Shader", "author": "spectajin", "description": "Cloud shader generated from this tutorial:\nhttps://www.youtube.com/watch?v=hwa6XRXd1xQ", "tags": ["cloudshader"], "likes": 4, "viewed": 195, "published": "Public API", "date": "1620578592", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float noise(vec2 pq) {\n    return fract(\n        sin(\n        (pq.x * 19.) + iTime/11111111150. + \n        (pq.y * 180.) + iTime/11111111150.)* 360.);\n}\n\nfloat noiseSmooth(vec2 pq) {\n    vec2 index = floor(pq);\n    \n    vec2 frag = fract(pq);\n    frag = smoothstep(0.0, 1.0, frag);\n    \n    float topLeft = noise(index);\n    float topRight = noise(index + vec2(1,0));\n    float top = mix(topLeft,topRight, frag.x);\n    \n    float bottomLeft = noise(index + vec2(0,1));\n    float bottomRight = noise(index + vec2(1,1));\n    float bottom = mix(bottomLeft, bottomRight, frag.x);\n    \n    return mix(top, bottom, frag.y);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 sky = vec3(0.09, 0.7, 1.5) * (1.5 - uv.y) / (1.5 - uv.y) * 0.5; \n    \n    // uv += iMouse.xy / 20.;\n    uv.x += iTime / 35.;\n    \n    vec2 uv2 = uv;\n    \n     \n    uv2 += sin(iTime / 120.);\n    vec2 uv3 = uv;\n    uv3 += cos(iTime / 90.);\n     \n     \n    // Time varying pixel color\n    vec3 col = vec3(noiseSmooth(uv * 2.));\n    col += vec3(noiseSmooth(uv3 * 32.)) * 0.125;\n    col += vec3(noiseSmooth(uv3 * 64.)) * 0.0625;\n    col += vec3(noiseSmooth(uv2 * 16.)) * 0.25;\n    col += vec3(noiseSmooth(uv * 8.)) * 0.5;\n    col /= 1.5;\n    \n    col *= smoothstep(0.2, 0.9, (col + vec3(noiseSmooth(uv2 * 8.)) * 0.5)-0.1);\n    col = mix(vec3(1.), sky, 1. - col);\n     \n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns2SRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 152], [154, 154, 182, 182, 619], [620, 620, 677, 727, 1556]], "test": "valid"}
{"id": "Ns2SWD", "name": "weird space gimbal thing", "author": "livvy", "description": "weird space gimbal thing", "tags": ["raymarch"], "likes": 2, "viewed": 56, "published": "Public", "date": "1620262854", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define MAX_STEP 500\n#define EPSILON 0.00001\n#define fGlobalTime iTime\n\nuniform vec2 v2Resolution; // viewport resolution (in pixels)\nuniform float fFrameTime; // duration of the last frame, in seconds\n\nmat2 rot(float q) {\n  return mat2(\n    -sin(q), cos(q),\n     cos(q), sin(q)\n  );\n}\n\nfloat pln(vec3 p, vec3 n, float d)\n{\n  return dot(p, n) - d;\n}\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n\nfloat sdSphere(vec3 p, float r) {\n  //p*=vec3(1.0,sin(fGlobalTime)+0.2,0.6);\n  \n  p.xy*=rot(fGlobalTime/0.5);\n  \n  p*=mat3(\n    1.0,              0.0,              0.0,\n    cos(fGlobalTime*.2), 1.0,              0.0,\n    0.0,              sin(fGlobalTime*.2), 1.0\n  );\n  return length(p) - r;  \n}\n\nfloat scene(vec3 p) {\n  vec3 c = vec3(0.0, 0.0, 8.0);\n  vec3 l = vec3(0.0, 0.0 , 0.0);\n  vec3 q = p-c*clamp(round(p/c),-l,l);\n\t\n  q.xz *= rot(fGlobalTime/3.);\n  q.yz *= rot(fGlobalTime/3.);\n  vec3 r = q;\n  r.xz *= rot(fGlobalTime);\n  \n  \n\n  float objkt = min(min(\n     sdBoxFrame(q, vec3(0.,1.,1.), 0.054)-.1*0.2,\n     sdSphere(p, clamp(sin(fGlobalTime),0.2,0.25))\n  ), sdBoxFrame(r, vec3(0.,1.3,1.3), 0.04)-0.1*.2);\n  return objkt;\n  return min(objkt, pln(p, vec3(0., 1., 0.), -2.0));\n}\n\nvec3 normal(vec3 p)\n{\n    const float eps = EPSILON;\n    return normalize(\n      vec3(\n        scene(p + vec3(eps, 0, 0)) - scene(p - vec3(eps, 0, 0)),\n        scene(p + vec3(0, eps, 0)) - scene(p - vec3(0, eps, 0)),\n        scene(p + vec3(0, 0, eps)) - scene(p - vec3(0, 0, eps))\n      )\n    );\n}\n\n/*\nvec3 normal(vec3 p) {\n  return normalize(vec3(\n    scene(vec3(p.x + EPSILON, p.y, p.z)) - scene(vec3(p.x - EPSILON, p.y, p.z)), \n    scene(vec3(p.x, p.y + EPSILON, p.z)) - scene(vec3(p.x, p.y - EPSILON, p.z)),\n    scene(vec3(p.x, p.y, p.z + EPSILON)) - scene(vec3(p.x, p.y, p.z - EPSILON))\n  )); \n}\n*/\n\nvec3 rayDirection(float fov, vec2 size, vec2 fragCoord)\n{\n  vec2 xy = fragCoord - size / 2.0;\n  float z = size.y / tan(radians(fov) / 2.0);\n  return normalize(vec3(xy, -z));  \n}\n\nvec4 march(vec3 eye, vec3 dir, float start, float end)\n{\n  float depth = start;\n  for (int i=0; i<MAX_STEP; i++) {\n    vec3 p = eye + depth * dir;\n    float dist = scene(eye + depth * dir);\n    if (dist < EPSILON) {\n      return vec4(p, depth);\n    }\n    depth+=dist;\n    if(depth >= end) {\n      return vec4(p, end);  \n    }\n  }  \n}\n\nconst vec3 colors[5] = vec3[5](\n  vec3(0.99, 0.45, 0.20),\n  vec3(0.85, 0.26, 0.17),\n  vec3(0.94, 0.24, 0.36),\n  vec3(0.86, 0.31, 0.75),\n  vec3(0.80, 0.18, 0.98)\n);\n\n// PHONG SHADING\nvec3 phongLightContrib(vec3 kd, vec3 ks, float alpha,\n                       vec3 p, vec3 ro, vec3 lightpos,\n                       vec3 lightint)\n{\n  vec3 N = normal(p);\n  vec3 L = normalize(lightpos - p);\n  vec3 V = normalize(ro - p);\n  vec3 R = normalize(reflect(-L, N));\n  float dotLN = dot(L,N);\n  float dotRV = dot(R,V);\n  \n  if (dotLN < 0.0) return vec3(0.0);\n  if (dotRV < 0.0) return lightint * kd * dotLN;\n  return lightint * (kd * dotLN + ks * pow(dotRV, alpha));  \n}\n\n\nvec3 phong(vec3 ka, vec3 kd, vec3 ks, float alpha, vec3 p, vec3 ro)\n{\n  const vec3 ambientLux = vec3(1.);\n  vec3 color = ambientLux * ka;\n  // LIGHT 1\n  color += phongLightContrib(kd, ks, alpha, p, ro, vec3(7.0, 5.0, 3.0), vec3(10.0));\n  return color;\n}\n\n\nvec3 getSceneColor(vec3 p, vec3 ro) {\n\n  vec3 c = colors[int(round(mod(fGlobalTime*1.,4.)))];\n  vec3 Kd = vec3(20.);     // AMBIENT  LIGHT\n  vec3 Ka = c;     // DIFFUSE  LIGHT\n  vec3 Ks = vec3(2.); // SPECTRAL LIGHT \n  float shine = 300.0;\n  \n  // APPLY PHONG\n  vec3 col = phong(Ka, Kd, Ks, shine, p, ro);\n  \n  return col;\n}\n\nvec3 getSceneColorBasic(vec3 p, vec3 ro) {\n  return colors[int(round(mod(fGlobalTime*1.,4.)))];  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  const float MIN_DIST = 0.;\n  const float MAX_DIST = 20.;\n  vec3 cam = vec3(0,0,9);\n  vec3 dir = rayDirection(45.0, iResolution.xy, fragCoord.xy); \n  vec4 m = march(cam, dir, MIN_DIST, MAX_DIST);\n  vec3 p = m.xyz;  \n  vec3 col = vec3(.001,.0,.001);\n  // SHADE THE SCENE\n  if (m.a < MAX_DIST) {\n    col = getSceneColor(p, cam);\n    // ANTIALIASING\n    float AA_size = 16.0;\n    float count = 0.0;\n    for (float aaY = 0.0; aaY < AA_size; aaY++)\n    {\n        for (float aaX = 0.0; aaX < AA_size; aaX++)\n        {\n            col += getSceneColorBasic(p - vec3(aaX, aaY, p.z) / AA_size, cam);\n            count += 1.0;\n        }\n    }\n    col /= count;\n   \n  }\n  // GAMMA CORRECTION\n  col = smoothstep(0.0,1.0,col);\n  col = pow(col, vec3(0.4545));\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns2SWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[204, 204, 223, 223, 286], [288, 288, 324, 324, 350], [352, 352, 397, 397, 679], [682, 682, 715, 758, 978], [980, 980, 1001, 1001, 1467], [1469, 1469, 1490, 1490, 1766], [2074, 2074, 2131, 2131, 2251], [2253, 2253, 2309, 2309, 2586], [2753, 2770, 2918, 2918, 3248], [3251, 3251, 3320, 3320, 3504], [3507, 3507, 3544, 3544, 3831], [3833, 3833, 3875, 3875, 3932], [3934, 3934, 3991, 3991, 4770]], "test": "error"}
{"id": "Ns2SWh", "name": "Lars-Erik's Julia Set Explorer 2", "author": "larserik", "description": "Fork of original to see about better coloring.\n\nSimple toy to look at different Julia sets of z=z^2+c. Walks around -2,-1i and 1,1i in an oscillating spiral.\nHold mouse to temporarily modify c manually.", "tags": ["juliaset"], "likes": 2, "viewed": 58, "published": "Public", "date": "1620257567", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M_PI 3.1415926535897932384626433832795\n\nconst int maxIter = 2000;\n\n\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nint iterate(vec2 a, vec2 c) {\n    vec2 prev = a;\n    vec2 square;\n    for(int i = 0; i<maxIter; i++) {\n        square = vec2(\n            pow(prev.x, 2.0) - pow(prev.y, 2.0),\n            2.0 * prev.x * prev.y\n        ) + c;\n        if (length(square) > 1e10) {\n            return i;\n        }\n        prev = square;\n    }\n    return maxIter;\n}\n\nconst float speed = 6.;\nconst float spiralSpeed = 20.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 c = vec2(0, 0);\n    if (iMouse.z > 0.) {\n        c = iMouse.xy/iResolution.xy*4.0-2.0;\n    } else {\n        float rad = .2 + 1.4 * (cos(float(iTime/spiralSpeed))+.5)/3.;\n        c = vec2(cos(float(iTime/speed))*rad*1.5-1., sin(float(iTime/speed))*rad);\n    }\n\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 suv = uv * 4.0 - 2.0;\n    suv = suv / vec2(1.0, 1.8); \n    \n    int iterations = iterate(suv, c);\n    float startCol = .6;\n    float rate = float(iterations) / float(maxIter);\n    float col = iterations < 50 ? mod(startCol + float(rate), 1.0) : mod(startCol + float(iterations)/600., 1.0);\n    float intensity = iterations < 50 ? float(iterations) / 50. : .3 + .7 * rate;\n\n    fragColor = vec4(hsl2rgb(vec3(col, 1, intensity)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns2SWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 76, 103, 103, 246], [248, 248, 277, 277, 591], [648, 648, 705, 705, 1457]], "test": "valid"}
{"id": "Ns2SWm", "name": "Giant Orange", "author": "livvy", "description": "I had a weird dream awhile ago about giant oranges so I decided to make one.\n\n~UNFINISHED~", "tags": ["raymarch", "orange", "fruit", "orannayarr"], "likes": 1, "viewed": 57, "published": "Public", "date": "1620409112", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// GIANT ORANGE by livvy / mag3nta\n// TODO:\n// - add specular highlight\n// - use some noise to add dimpled texture pattern\n// - shape slightly\n// - improve leaves and stalk\n// - add something for scale \n\n#define PI 3.14159265\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat sdTri( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat sdQuad( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 dc = d - c; vec3 pc = p - c;\n  vec3 ad = a - d; vec3 pd = p - d;\n  vec3 nor = cross( ba, ad );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ad,nor),pd))<3.0)\n     ?\n     min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat sdCyl( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat map(in vec3 p) {\n    float h = 3.0;\n\n    //p.y*=(1.1+abs(sqrt(p.x)));\n    \n    // orange\n    float d = length(p) - h+0.02;\n    \n    // table/plane\n    float dP = p.y+h-0.04;\n    \n    // middle of leaves\n    float s = 0.1;\n    vec3 p1 = vec3(-s, h, s);\n    vec3 p2 = vec3( s, h, s);\n    vec3 p3 = vec3( s, h,-s);\n    vec3 p4 = vec3(-s, h,-s);\n    float leaf = sdQuad(p, p1, p2, p3, p4);\n    \n    // leaves\n    float tri1 = sdTri(p, p1, p2, vec3( 0.,   h+s*.5,  s*2.));\n    float tri2 = sdTri(p, p2, p3, vec3( s*2., h+s*.5,  0.));\n    float tri3 = sdTri(p, p3, p4, vec3( 0.,   h+s*.5, -s*2.));\n    float tri4 = sdTri(p, p4, p1, vec3(-s*2., h+s*.5,  0.));\n    float tri = min(min(tri1, tri2), min(tri3, tri4));\n    \n    // leafy bits\n    float leaves = min(leaf,tri)-0.008;\n    \n    // stalk\n    p.y-=h;\n    const float k = 2.0; // or some other amount\n    float co = cos(k*p.y);\n    float si = sin(k*p.y);\n    mat2  m = mat2(co,-si,si,co);\n    vec3  q = vec3(m*p.xy,p.z);\n  \n    float stalk = sdCyl(q, 0.08, 0.5);\n    \n    float SL = min(leaves, stalk);\n    return min(min(d,dP), SL);\n}\n\nvec3 norm(in vec3 p) {\n    vec2 o = vec2(0.0001, 0.);\n    return normalize(vec3(map(p+o.xyy)-map(p-o.xyy),\n                          map(p+o.yxy)-map(p-o.yxy),\n                          map(p+o.yyx)-map(p-o.yyx)));\n}\n\nmat3 cam( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nfloat orenNayarDiffuse(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float roughness,\n  float albedo) {\n  \n  float LdotV = dot(lightDirection, viewDirection);\n  float NdotL = dot(lightDirection, surfaceNormal);\n  float NdotV = dot(surfaceNormal, viewDirection);\n\n  float s = abs(LdotV - NdotL * NdotV);\n  float t = mix(1.0, max(NdotL, NdotV), step(0.0, s));\n\n  float sigma2 = roughness * roughness;\n  float A = 1.0 + sigma2 * (albedo / (sigma2 + 0.13) + 0.5 / (sigma2 + 0.33));\n  float B = 0.45 * sigma2 / (sigma2 + 0.09);\n\n  return albedo * max(0.0, NdotL) * (A + B * s / t) / PI;\n}\n\n\nfloat shadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax,p)*ax, p, cos(ro)) + sin(ro)*cross(ax,p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.2);\n    \n    vec3 ro = vec3(sin(iTime/5.)*7.0,5.0,cos(iTime/5.)*7.0);    \n    vec3 ta = vec3( 0.0, -0.0, 0.0 );\n    mat3 ca = cam( ro, ta, 0.0 );\n    vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n    \n    float t = 0.000;\n    for (int i=0; i<255; ++i) {\n        vec3 P = ro+rd*t;\n        float d = map(P);\n        if (d<0.001) {\n            vec3 N = norm(P);\n            vec3 L = normalize(vec3(4.0,5.0,4.));\n            vec3 C = pow(vec3(1.0,0.5,0.), vec3(2))*((-clamp(texture(iChannel1, N.xy*2.).r*2.0,0.2,1.0))-0.8); // orange\n            float I = 0.6;\n            float NdotL = dot(N,L);\n\n            // change material colour depending on the Y-position\n            if (P.y<-2.399){\n                C = texture(iChannel0, P.xz*0.2).rgb; // wood texture\n            }\n\n            if (P.y>=3.0) {\n                C = vec3(0.22,0.24,0.00); // green\n            }\n            \n            C = pow(C,vec3(2));\n            // 'studio lights'\n            vec3 Nrot = erot(N, normalize(vec3(-1,1,0)), 3.0);\n            float studio =  dot(max(Nrot, 0.), vec3(.04));\n            \n            // oren-nayer diffuse lighting\n            float Li = (\n                orenNayarDiffuse(L, rd, N, 0.3, 0.7)\n                * I\n                * shadow(P, L, 0.1, 20.0, 12.));\n\n            Li += studio;\n\n            // colourize\n            col=Li*C;\n\n            col *= exp( -0.0005*t*t*t ); // fog\n            col = sqrt(col);\n            break;\n        }\n        t+=d;\n        if (d>15.) break;\n    }\n    \n    col = pow(col, vec3(0.4545));\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns2SWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[227, 227, 252, 252, 271], [273, 273, 320, 320, 817], [819, 819, 875, 875, 1503], [1505, 1505, 1546, 1546, 1653], [1656, 1656, 1678, 1678, 2746], [2748, 2748, 2770, 2770, 2964], [2966, 2966, 3012, 3012, 3189], [3192, 3192, 3319, 3319, 3799], [3802, 3802, 3875, 3875, 4088], [4091, 4091, 4129, 4129, 4195], [4197, 4197, 4254, 4254, 5901]], "test": "error"}
{"id": "Ns2XDc", "name": "game map -challenger", "author": "jorge2017a1", "description": "game map -challenger", "tags": ["gamemapchallenger"], "likes": 3, "viewed": 161, "published": "Public API", "date": "1621179830", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//por jorge2017a1 ----jorgeFloresP---16/may/2021\n// referencia \n////-------------------\n/// IQ funciones....librerias\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(antialiasing(0.5),b,d)\n\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n    \nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r; }\n\nvec3 ponerBorde2(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S(abs( distObj),0.0));\n  return colOut;\n}\n\n\nvec3 ponerBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj),0.0));\n  return colOut;\n}\n\nconst vec3 colNegro= vec3(0.0);\nconst vec3 col0= vec3(0.5);\nconst vec3 col1= vec3(0.75,0.75,0.75);\nconst vec3 col2= vec3(0.72,0.40,0.03);\nconst vec3 col3= vec3(0.68,0.30,0.00);\nconst vec3 col4= vec3(0.72,0.40,0.03);\nconst vec3 col5= vec3(0.05,0.49,0.00);\nconst vec3 col6= vec3(0.26,0.62,0.17);\nconst vec3 col7= vec3(0.77,0.76,0.79);\nconst vec3 col8= vec3(0.07,0.34,0.72);\nconst vec3 col9= vec3(0.01,0.33,0.70);\nconst vec3 col10= vec3(0.38,0.69,0.95);\nconst vec3 col11= vec3(0.02,0.35,0.73);\nconst vec3 col12= vec3(0.84,0.53,0.16);\nconst vec3 col13= vec3(0.75,0.35,0.07);\nconst vec3 col14= vec3(0.02,0.35,0.72);\n\n\nfloat opU(float d1, float d2) {return min(d1, d2); }\n\n\n#define POLY(N) (in vec2 p, in vec2[N] v) {const int n=v.length();float d=dot(p-v[0],p-v[0]);float s=1.;for(int i=0,j=n-1;i<n;j=i,i++){vec2 e=v[j]-v[i];vec2 w=p-v[i];vec2 b=w-e*clamp(dot(w,e)/dot(e,e),0.,1.);d=min(d,dot(b,b));bvec3 cond=bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);if(all(cond)||all(not(cond))) s=-s;}return s*sqrt(d);}\n\n\nfloat sdPolyc000 POLY(17)\nvec2 ptc000[ 17]=vec2[](  \nvec2(.22,.12),vec2(.01,.28),vec2(.01,.52),vec2(.10,.64),vec2(.09,.70),\nvec2(.01,.82),vec2(.01,.99),vec2(.84,.99),vec2(.85,.76),vec2(.77,.61),\nvec2(.78,.57),vec2(.81,.51),vec2(.77,.46),vec2(.77,.36),vec2(.70,.22),\nvec2(.70,.12),vec2(.22,.12) );\n\n\nfloat sdPolyc001 POLY(17)\nvec2 ptc001[ 17]=vec2[](  \nvec2(.26,.00),vec2(.30,.04),vec2(.45,.04),vec2(.45,.12),vec2(.22,.12),\nvec2(.22,.32),vec2(.15,.32),vec2(.15,.67),vec2(.40,.67),vec2(.41,.59),\nvec2(.74,.59),vec2(.74,.55),vec2(.67,.55),vec2(.66,.12),vec2(1.00,.12),\nvec2(1.00,.00),vec2(.26,.00) );\n\n\nfloat sdPolyc002 POLY(5)\nvec2 ptc002[ 5]=vec2[](  \nvec2(.52,.00),vec2(.52,.08),vec2(1.00,.08),vec2(1.0,.00),vec2(.52,.00) );\n\n\nfloat sdPolyc003 POLY(5)\nvec2 ptc003[ 5]=vec2[](  \nvec2(.52,.08),vec2(.55,.12),vec2(1.00,.12),vec2(1.00,.08),vec2(.52,.08) );\n\nfloat sdPolyc004 POLY(5)\nvec2 ptc004[ 5]=vec2[](  \nvec2(.53,.09),vec2(.55,.12),vec2(1.00,.12),vec2(1.00,.09),vec2(.53,.09) );\n\nfloat sdPolyc005 POLY(5)\nvec2 ptc005[ 5]=vec2[](  \nvec2(.53,.09),vec2(.55,.11),vec2(1.00,.11),vec2(.99,.09),vec2(.53,.09) );\n\n\nfloat sdPolyc006 POLY(5)\nvec2 ptc006[ 5]=vec2[](  \nvec2(.45,.10),vec2(.50,.10),vec2(.50,.06),vec2(.45,.06),vec2(.45,.10) );\n\nfloat sdPolyc007 POLY(5)\nvec2 ptc007[ 5]=vec2[](  \nvec2(.45,.10),vec2(.47,.12),vec2(.52,.12),vec2(.50,.10),vec2(.45,.10) );\n\nfloat sdPolyc008 POLY(10)\nvec2 ptc008[10]=vec2[](  \nvec2(.50,.10),vec2(.52,.12),vec2(.52,.11),vec2(.51,.10),vec2(.51,.08),\nvec2(.52,.09),vec2(.52,.08),vec2(.50,.06), vec2(.50,.07),vec2(.50,.10) );\n\n\nfloat sdPolyc009 POLY(5)\nvec2 ptc009[ 5]=vec2[](  \nvec2(.47,.12),vec2(.51,.12),vec2(.50,.11),vec2(.46,.11),vec2(.47,.12) );\n\nfloat sdPolyc010 POLY(5)\nvec2 ptc010[ 5]=vec2[](  \nvec2(.47,.11),vec2(.47,.11),vec2(.50,.11),vec2(.50,.11),vec2(.47,.11) );\n\nfloat sdPolyc011 POLY(6)\nvec2 ptc011[ 6]=vec2[](  \nvec2(.47,.08),vec2(.48,.08),vec2(.48,.07),vec2(.47,.07),vec2(.47,.07),\nvec2(.47,.08) );\n\nfloat sdPolyc014 POLY(5)\nvec2 ptc014[ 5]=vec2[](  \nvec2(.60,.02),vec2(.60,.01),vec2(.62,.01),vec2(.62,.02),vec2(.60,.02) );\n\nfloat sdPolyc015 POLY(5)\nvec2 ptc015[ 5]=vec2[](  \nvec2(.60,.03),vec2(.60,.03),vec2(.62,.03),vec2(.62,.03),vec2(.60,.03) );\n\nfloat sdPolyc017 POLY(5)\nvec2 ptc017[ 5]=vec2[](  \nvec2(.26,.32),vec2(.37,.32),vec2(.37,.20),vec2(.26,.20),vec2(.26,.32) );\n\nfloat sdPolyc018 POLY(5)\nvec2 ptc018[ 5]=vec2[](  \nvec2(.40,.32),vec2(.59,.32),vec2(.59,.20),vec2(.41,.20),vec2(.40,.32) );\n\nfloat sdPolyc019 POLY(5)\nvec2 ptc019[ 5]=vec2[](  \nvec2(.18,.48),vec2(.30,.48),vec2(.30,.36),vec2(.19,.36),vec2(.18,.48) );\n\n\nfloat sdPolyc020 POLY(7)\nvec2 ptc020[ 7]=vec2[](  \nvec2(.33,.48),vec2(.41,.48),vec2(.41,.55),vec2(.59,.56),vec2(.59,.36),\nvec2(.33,.36),vec2(.33,.48) );\n\nfloat sdPolyc021 POLY(5)\nvec2 ptc021[ 5]=vec2[](  \nvec2(.19,.52),vec2(.18,.63),vec2(.37,.63),vec2(.37,.51),vec2(.19,.52) );\n\nfloat sdPolyc022 POLY(5)\nvec2 ptc022[ 5]=vec2[](  \nvec2(.08,.75),vec2(.44,.75),vec2(.35,.89),vec2(.14,.90),vec2(.08,.75) );\n\nfloat sdPolyc023 POLY(5)\nvec2 ptc023[ 5]=vec2[](  \nvec2(.00,.91),vec2(.08,.83),vec2(.16,.99),vec2(.00,.99),vec2(.00,.91) );\n\nfloat sdPolyc024 POLY(5)\nvec2 ptc024[5]=vec2[](  \nvec2(.08,.83),vec2(.30,.83),vec2(.29,.99),vec2(.16,.99),vec2(.08,.83) );\n\nfloat sdPolyc025 POLY(5)\nvec2 ptc025[ 5]=vec2[](  \nvec2(.19,.83),vec2(.19,.92),vec2(.23,.92),vec2(.23,.84),vec2(.19,.83) );\n\nfloat sdPolyc026 POLY(5)\nvec2 ptc026[ 5]=vec2[](  \nvec2(.19,.75),vec2(.19,.77),vec2(.21,.77),vec2(.21,.75),vec2(.19,.75) );\n\nfloat sdPolyc027 POLY(5)\nvec2 ptc027[ 5]=vec2[](  \nvec2(.24,.85),vec2(.37,.99),vec2(.54,.99),vec2(.68,.85),vec2(.24,.85) );\n\nfloat sdPolyc028 POLY(10)  //casa\nvec2 ptc028[ 10]=vec2[](  \nvec2(.44,.24),vec2(.44,.24),vec2(.44,.24),vec2(.44,.27),vec2(.47,.26),\nvec2(.47,.26),vec2(.48,.26),vec2(.48,.26),vec2(.48,.25),vec2(.44,.24) );\n\nfloat sdPolyc029 POLY(7)\nvec2 ptc029[ 7]=vec2[](  \nvec2(.45,.24),vec2(.45,.25),vec2(.45,.26),vec2(.46,.26),vec2(.46,.25),\nvec2(.46,.24),vec2(.45,.24) );\n\nfloat sdPolyc030 POLY(9)\nvec2 ptc030[ 9]=vec2[](  \nvec2(.45,.26),vec2(.44,.26),vec2(.45,.28),vec2(.47,.28),vec2(.48,.27),\nvec2(.48,.26),vec2(.47,.26),vec2(.46,.27),vec2(.45,.26) );\n\nfloat sdPolyc031 POLY(5)\nvec2 ptc031[ 5]=vec2[](  \nvec2(.45,.26),vec2(.45,.25),vec2(.46,.25),vec2(.46,.26),vec2(.45,.26) );\n\nfloat sdPolyc032 POLY(5)\nvec2 ptc032[ 5]=vec2[](  \nvec2(.46,.26),vec2(.47,.26),vec2(.47,.25),vec2(.46,.25),vec2(.46,.26) );\n\nfloat sdPolyc033 POLY(5)\nvec2 ptc033[ 5]=vec2[](  \nvec2(.47,.26),vec2(.47,.26),vec2(.47,.25),vec2(.47,.25),vec2(.47,.26) );\n\nfloat sdPolyc034 POLY(5)\nvec2 ptc034[ 5]=vec2[](  \nvec2(.292,.28),vec2(.292,.29),vec2(.281,.29),vec2(.281,.28),vec2(.292,.28) );\n\nfloat sdPolyc035 POLY(13) //arbol\nvec2 ptc035[ 13]=vec2[](  \nvec2(.29,.29),vec2(.28,.29),vec2(.27,.29),vec2(.28,.30),\nvec2(.27,.30),vec2(.28,.30),vec2(.28,.31),\nvec2(.29,.31),vec2(.30,.31),vec2(.30,.30),\nvec2(.30,.292),vec2(.30,.292),vec2(.29,.29) );\n\n\nvec3 arbolYTronco(vec2 p, vec3 col)\n{\n    float sdc034 = sdPolyc034(p, ptc034); //tronco\n    col=ponerBorde(col2,col,sdc034 );\n\n    float sdc035 = sdPolyc035(p, ptc035);  //arbol\n    col=ponerBorde(col6,col,sdc035 );\n    return col;\n}\n\n\nvec3 casasCh(vec2 p, vec3 col)\n{\n    float sdc028 = sdPolyc028(p, ptc028); //casa pasto\n    col=ponerBorde(col1,col,sdc028 );\n\n    float sdc029 = sdPolyc029(p, ptc029); //puerta casa\n    col=ponerBorde(col0,col,sdc029 );\n\n    float sdc030 = sdPolyc030(p, ptc030);\n    col=ponerBorde(col8,col,sdc030 );\n\n\n    float sdc031 = sdPolyc031(p, ptc031);\n    col=ponerBorde(col10,col,sdc031 );\n\n    float sdc032 = sdPolyc032(p, ptc032);  //ventana casa\n    col=ponerBorde(col8,col,sdc032 );\n\n\n    float sdc033 = sdPolyc033(p, ptc033);\n    col=ponerBorde(col1,col,sdc033 );\n    return col;\n}\n//***------------****-----------****------------******-------\nvec3 ChallengerNes(in vec2 pp, vec3 col) \n{\n  vec2 p=pp,pr1=pp, pr2=pp;\n\n    float sdc000 = sdPolyc000(p, ptc000); //pasto cafe\n    col=ponerBorde(col4,col,sdc000 );\n    \n    float sdc001 = sdPolyc001(p, ptc001);  //concreto\n    col=ponerBorde(col0,col,sdc001 );\n\n    float sdc002 = sdPolyc002(p, ptc002); //edificio\n    col=ponerBorde(col0,col,sdc002 );\n\n    float sdc003 = sdPolyc003(p, ptc003); //techo edificio\n    col=ponerBorde(col1,col,sdc003 );\n\n    float sdc004 = sdPolyc004(p, ptc004);\n    col=ponerBorde(col0,col,sdc004 );\n    \n    float sdc005 = sdPolyc005(p, ptc005);\n    col=ponerBorde2(col1,col,sdc005 );\n\n    \n    float sdc006 = sdPolyc006(p, ptc006); //cuarto\n    col=ponerBorde(col0,col,sdc006 );\n    \n    float sdc007 = sdPolyc007(p, ptc007);\n    col=ponerBorde(col1,col,sdc007 );\n\n    float sdc008 = sdPolyc008(p, ptc008);\n    col=ponerBorde(col1,col,sdc008 );\n\n    float sdc009 = sdPolyc009(p, ptc009);\n    col=ponerBorde(col0,col,sdc009 );\n\n    float sdc010 = sdPolyc010(p, ptc010); //sombra\n    col=ponerBorde(col2,col,sdc010 );\n\n    float sdc011 = sdPolyc011(p, ptc011); //ventana\n    col=ponerBorde(col8,col,sdc011 );\n    \n    \n    float sdc014 = sdPolyc014(p, ptc014);  //ventana edificio\n    col=ponerBorde(col8,col,sdc014 );\n    \n    float sdc015 = sdPolyc015(p, ptc015);\n    col=ponerBorde(col1,col,sdc015 );\n    \n    float sdc017 = sdPolyc017(p, ptc017);\n    col=mix(col,col5 ,S( sdc017 ,0.0));\n    \n    \n    float sdc018 = sdPolyc018(p, ptc018);\n    col=mix(col,col5 ,S( sdc018 ,0.0));\n\n    float sdc019 = sdPolyc019(p, ptc019);\n    col=mix(col,col5 ,S( sdc019 ,0.0));\n\n    float sdc020 = sdPolyc020(p, ptc020);\n    col=mix(col,col5 ,S( sdc020 ,0.0));\n\n    float sdc021 = sdPolyc021(p, ptc021);\n    col=mix(col,col5 ,S( sdc021 ,0.0));\n\n    float sdc023 = sdPolyc023(p, ptc023); //piramide oculta\n    col=ponerBorde(col3,col,sdc023 );\n\n    float sdc024 = sdPolyc024(p, ptc024);\n    col=ponerBorde(col2,col,sdc024 );  //piramide sombrea oculta\n\n    float sdc025 = sdPolyc025(p, ptc025); //puerta piramide oculta\n    col=ponerBorde(colNegro,col,sdc025 );\n\n    float sdc027 = sdPolyc027(p, ptc027);  //piramide n2 atras\n    col=ponerBorde(col2,col,sdc027 );\n\n    float sdc022 = sdPolyc022(p, ptc022); //piramide n1\n    col=ponerBorde(col3,col,sdc022 );\n\n      float sdc026 = sdPolyc026(p, ptc026);  //puerta piramide 1\n    col=ponerBorde(colNegro,col,sdc026 );\n\n\n col= casasCh( p, col);\n col= casasCh( p-vec2(0.02,0.17), col);\n col= casasCh( p-vec2(-0.06,0.17), col);\n col= casasCh( p-vec2(-0.2,0.17), col);\n col= casasCh( p-vec2(-0.2,0.3), col);\n\n col= arbolYTronco(p-vec2(0.0,0.0), col);\n col= arbolYTronco(p-vec2(0.04,0.0), col);\n \n col= arbolYTronco(p-vec2(0.15,0.20), col);\n col= arbolYTronco(p-vec2(0.18,0.20), col);\n col= arbolYTronco(p-vec2(0.21,0.21), col);\n col= arbolYTronco(p-vec2(-0.07,0.3), col);\n\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    float t=iTime*0.25;\n    vec2 p=uv*0.325-vec2(-0.45,-0.7+0.5*sin(fract(t)));\n    vec3 col=col8;\n    col=ChallengerNes(p, col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns2XDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 315, 351, 351, 396], [402, 402, 437, 437, 461], [463, 463, 524, 524, 648], [651, 651, 711, 711, 837], [1452, 1452, 1483, 1483, 1504], [6748, 6748, 6785, 6785, 6982], [6985, 6985, 7017, 7017, 7566], [7567, 7629, 7672, 7672, 10483], [10485, 10485, 10542, 10542, 10802]], "test": "valid"}
{"id": "Ns2XW3", "name": "Fork Girls Only NikolaErce 259", "author": "NikolaErceg", "description": "A representation of how women have changed over time.", "tags": ["girlpower"], "likes": 2, "viewed": 150, "published": "Public API", "date": "1621164274", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rgbOffset = 0.0;\n\n   float vertScroll = -0.0;\n\n   float horzFuzziness = -1.0;\n\n   float bottomStatic = -0.60;\n   \n   float Static = 1.0;\n\n   float vertMove =0.0;\n\n   float scalines = 1.0;\n\nvec3 HayburnEdit (vec3 y) {\n  return y - round(y * (3.0 / 180.0)) * 180.0;\n}\n\nvec2 HayburnEdit (vec2 y) {\n  return y - round(y * (1.0 / 90.0)) * 10.0;\n}\n\nvec3 changes(vec3 x) {\n  return HayburnEdit (((x*12.0)+1.0)*x);\n}\n\nfloat statickyEffect (vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,\n                      0.366025403784439,\n                     -0.577350269189626,\n                      0.024390243902439);\n                      \n  vec2 i  = round(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = HayburnEdit(i);\n  vec3 p = changes( changes( i.y + vec3(3.0, i1.y, -6.0 ))\n\t\t+ i.x + vec3(9.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.x,x12.y), dot(x12.zw,x12.zw)), -1.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = round(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nfloat staticV(vec2 uv) {\n    float staticHeight = statickyEffect(vec2(9.0,iTime*1.2+1.0))*0.3+5.0;\n    float staticAmount = statickyEffect(vec2(30.0,iTime*1.2-12.0))*0.1+0.5;\n    float staticStrength = statickyEffect(vec2(-5.75,iTime*0.6-7.0))*2.0+4.0;\n\treturn (1.0-step(statickyEffect(vec2(5.0*pow(iTime,2.0)+pow(uv.x*7.0,1.2),pow((mod(iTime,100.0)+100.0)*uv.y*0.3+3.0,staticHeight))),staticAmount))*staticStrength;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uvA = fragCoord / iChannelResolution[1].xy;\n    vec2 uvB = fragCoord / iChannelResolution[0].xy;\n    fragColor = texture(iChannel0, uvA) + texture(iChannel1, uvB);\n\n\tvec2 uv =  fragCoord.xy/iResolution.xy;\n\t\n\tfloat jerkOffset = (1.0-step(statickyEffect(vec2(iTime*1.3,2.0)),0.8))*0.05;\n\t\n\tfloat fuzzOffset = statickyEffect(vec2(iTime*15.0,uv.y*80.0))*0.003;\n\tfloat largeFuzzOffset = statickyEffect(vec2(iTime*1.0,uv.y*3.0))*0.004;\n    \n    float vertMovementOn = (1.0-step(statickyEffect(vec2(iTime*0.2,1.0)),0.4))*vertMove;\n    float vertJerk = (1.0-step(statickyEffect(vec2(iTime*1.5,5.0)),0.6))*vertScroll;\n    float vertJerk2 = (1.0-step(statickyEffect(vec2(iTime*5.5,5.0)),0.2))*vertScroll;\n    float yOffset = abs(sin(iTime)*1.0)*vertMovementOn+vertJerk*vertJerk2*0.3;\n    float y = mod(uv.y+yOffset,1.0);\n    \n\t\n\tfloat xOffset = (fuzzOffset + largeFuzzOffset) * horzFuzziness;\n    \n    float staticVal = 0.0;\n   \n    for (float y = -1.0; y <= -1.0; y += 3.0) {\n        float maxDist = 5.0/200.0;\n        float dist = y/200.0;\n    \tstaticVal += staticV(vec2(uv.x,uv.y+dist))*(maxDist-abs(dist))*1.5;\n    }\n        \n    staticVal *= bottomStatic;\n\t\n\tfloat red \t=   texture(\tiChannel0, \tvec2(uv.x + xOffset -3.01*rgbOffset,y)).r+staticVal;\n\tfloat green = \ttexture(\tiChannel1, \tvec2(uv.x + xOffset,\t  y)).g+staticVal;\n\tfloat blue \t=\ttexture(\tiChannel3, \tvec2(uv.x + xOffset +1.01*rgbOffset,y)).b+staticVal;\n\t\n\tvec3 color = vec3(red,green,blue);\n\tfloat scanline = sin(uv.y*700.0)*-0.12*scalines;\n\tcolor -= scanline;\n\t\n\tfragColor = vec4(color,0.0);\n    }", "image_inputs": [{"id": "Xdf3Rn", "previewfilepath": "/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video"}, {"id": "Xdf3Rn", "previewfilepath": "/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video"}, {"id": "4df3zn", "previewfilepath": "/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns2XW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[195, 195, 222, 222, 271], [273, 273, 300, 300, 347], [349, 349, 371, 371, 414], [416, 416, 449, 449, 1343], [1345, 1345, 1369, 1369, 1763], [1766, 1766, 1823, 1823, 3388]], "test": "error"}
{"id": "Ns2XWc", "name": "Reflecting toruses", "author": "mrange", "description": "CC0: Reflecting toruses\nNumerous examples on shadertoy already on how to do repeating toruses so nothing ground breaking.\nPart of an Amiga tribute demo released earlier. Every late Amiga demo had rotating toruses\n", "tags": ["3d", "raymarching", "torus"], "likes": 34, "viewed": 383, "published": "Public API", "date": "1621175258", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// CC0: Reflecting toruses\n//  Numerous examples on shadertoy already on how to do repeating toruses so nothing ground breaking.\n//  Part of an Amiga tribute demo released earlier. Every late Amiga demo had rotating toruses\n\n// Repeats itself after 20 sec\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define MISS            1E6\n\n#define BB_TOLERANCE            0.0001\n#define BB_NORM_OFF             0.001\n#define BB_MAX_RAY_LENGTH       15.0\n#define BB_MAX_RAY_MARCHES      60\n#define BB_MAX_SHADOW_MARCHES   15\n#define BB_MAX_REFLECTIONS      3\n\nconst mat2 rot0            = ROT(0.0);\nconst vec3 std_gamma       = vec3(2.2);\n\nconst vec3 bb_lightPos     = 2.0*vec3(4.0, 3.0, 1.5);\nconst vec3 bb_backLightPos = bb_lightPos.x*vec3(-1.0, 1.0, -1.0);\nconst vec3 bb_skyCol1      = vec3(0.2, 0.4, 0.6);\nconst vec3 bb_skyCol2      = vec3(0.4, 0.7, 1.0);\nconst vec3 bb_sunCol       = vec3(8.0,7.0,6.0)/8.0;\nconst vec3 bb_sunDir       = normalize(bb_lightPos);\nconst float bb_period      = 20.0;\n\nconst float bb_bottom      = -.85;\n\nvec3   bb_g_baseColor      = vec3(0.0);\nfloat  bb_g_refFactor      = 0.0;\n\nmat2   bb_g_rot            = rot0;\nfloat  bb_g_fi             = 0.0;\nfloat  bb_g_fo             = 0.0;\nfloat  bb_g_fi13           = 0.0;\nfloat  bb_g_fi23           = 0.0;\n\n\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\n// IQ's smooth min: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\n// IQ's box distance function: https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat box(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// IQ's torus distance function: https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat torus(vec3 p, vec2 t) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// From: http://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nvec2 mod2_1(inout vec2 p) {\n  vec2 c = floor(p + 0.5);\n  p = fract(p + 0.5) - 0.5;\n  return c;\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, 1.0/std_gamma);\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nfloat bb_planeIntersect(vec3 ro, vec3 rd, float mint) {\n  vec3 p = ro + rd*mint;\n  return (bb_bottom-p.y)/rd.y;\n}\n\nvec3 bb_skyColor(vec3 rd) {\n  float sunDot = max(dot(rd, bb_sunDir), 0.0);  \n  vec3 final = vec3(0.);\n\n  float roundBox = length(max(abs(rd.xz/max(0.0,rd.y))-vec2(0.5, 0.5),0.0))-0.1;\n  final += vec3(0.75)* pow(saturate(1.0 - roundBox*0.5), 9.0);\n  \n  final += mix(bb_skyCol1, bb_skyCol2, rd.y);\n  final += 0.5*bb_sunCol*pow(sunDot, 20.0);\n  final += 4.0*bb_sunCol*pow(sunDot, 400.0);    \n  return final;\n}\n\nfloat bb_df(vec3 p) {\n  float fi   = bb_g_fi;\n  float fo   = bb_g_fo;\n  mat2  rot  = bb_g_rot;\n  float fi13 = bb_g_fi13;\n  float fi23 = bb_g_fi23;\n  \n  float oo = mix(2.5, 0.5, fi*fo);\n  float ss = mix(0.05, 0.4, fi13*fo);\n  float rr = mix(0.125, 0.75, fi23*fo);\n  \n  vec3 p0 = p;\n  p0.y -= 0.5;\n  p0.zy *= rot;\n  p0.xy *= rot;\n  float d0 = box(p0, vec3(0.65));\n  \n  vec3 p1 = p;\n  p1.y -= oo;\n\n  float s = 1.0;\n\n  float d1 = torus(p1, s*vec2(1.0, 0.125));\n\n  vec3 c1 = vec3(0.125);\n\n  float trf = 0.75;\n  \n  for (int i = 0; i < 3; ++i) {\n    p1.xz *= rot;\n    p1.xyz = p1.zxy;\n\n    float pr = length(p1.xy);\n    float pa = atan(p1.y, p1.x);\n  \n    float n = mod1(pa, TAU/8.0);\n    \n    p1.xy = pr*vec2(cos(pa), sin(pa));\n    p1.x -= s;\n    s *= ss;\n    float dd = torus(p1, s*vec2(1.0, rr));\n\n\n    d1 = pmax(d1, -dd, 0.75*s);\n    trf = dd < d1 ? trf = 1.0-trf : trf;\n    d1 = min(d1, dd);\n  }\n  \n\n  float rf = 0.35;\n  vec3 bc = vec3(0.5);\n\n  float d = d0;\n\n  d = d0;    \n  \n  d = pmax(d, -d1, 0.1);\n\n  if (d1 < d) {\n    bc = c1;\n    rf = trf;\n    d = d1; \n  }\n\n  bb_g_refFactor = rf;\n  bb_g_baseColor = bc;\n\n  return d;\n}\n\nvec3 bb_normal(vec3 pos) {\n  vec3 eps = vec3(BB_NORM_OFF, 0.0, 0.0);\n  vec3 nor;\n  \n  nor.x = bb_df(pos+eps.xyy) - bb_df(pos-eps.xyy);\n  nor.y = bb_df(pos+eps.yxy) - bb_df(pos-eps.yxy);\n  nor.z = bb_df(pos+eps.yyx) - bb_df(pos-eps.yyx);\n  \n  return normalize(nor);\n}\n \nfloat bb_rayMarch(vec3 ro, vec3 rd, float initial, out float nearest, out int iter) {\n  float t = initial;\n\n  float n = 1E6;\n  int ii = 0;\n\n  for (int i = 0; i < BB_MAX_RAY_MARCHES; ++i) {\n    ii = i;\n    vec3 p = ro + rd*t;\n    \n    float d = bb_df(p);\n    n = min(n, d);\n    \n    if (d < BB_TOLERANCE || t >= BB_MAX_RAY_LENGTH) break;\n    \n    t += d;\n  }\n  \n  iter = ii;\n  nearest = n;\n  \n  return t < BB_MAX_RAY_LENGTH ? t : MISS;\n}\n\nfloat bb_softShadow(vec3 ps, vec3 ld, float mint, float k) {\n\n  float res = 1.0;\n  float t = mint*6.0;\n  int mat;\n  for (int i=0; i < BB_MAX_SHADOW_MARCHES; ++i) {\n    vec3 p = ps + ld*t;\n    float d = bb_df(p);\n    res = min(res, k*d/t);\n    if (res < BB_TOLERANCE) break;\n    \n    t += max(d, mint);\n  }\n  return clamp(res, 0.0, 1.0);\n}\n\nvec3 bb_render(vec3 ro, vec3 rd) { \n  vec3 finalCol = vec3(0.0);\n\n  float aggRefFactor = 1.0;\n\n  vec3 bg = bb_skyColor(rd);\n  int titer = 0;\n  int tref = 0;\n  \n  for (int rc = 0; rc < BB_MAX_REFLECTIONS; ++rc) {  \n      if (aggRefFactor < 0.05) break;\n  \n      vec3 sky = bb_skyColor(rd);\n  \n      const float mint = 0.05;\n      float tp = bb_planeIntersect(ro, rd, mint);\n\n      int iter;\n      float nearest;\n      float tm = bb_rayMarch(ro, rd, mint, nearest, iter);\n      titer += iter;\n      ++tref;\n      \n      vec3 baseColor  = bb_g_baseColor;\n      float refFactor = bb_g_refFactor;\n      \n      float shine = exp(-5.0*nearest);\n      const float shinef = 0.125;\n      const vec3 shineCol = vec3(1.25).zyx;\n      shine *= shinef;\n\n      if(tm >= MISS && tp <= 0.0) {\n        // We hit the sky\n        finalCol += aggRefFactor*mix(sky, shineCol, shine);\n        break;\n      }\n\n      vec3 p = ro + tm*rd;\n      vec3 nor = bb_normal(p);\n      float fakeAo = 1.0 - smoothstep(0.5, 1.2, float(iter)/float(BB_MAX_RAY_MARCHES));\n      \n      vec3 pp = ro + tp*rd;\n      vec2 pp1 = pp.xz;\n\n      pp1.x -= -2.0*TIME*0.5;\n      pp1 *= sqrt(0.5);\n      vec2 np1 = mod2_1(pp1);\n      \n      if (tp < tm && tp >= 0.0) {\n        // Hit plane\n        p = pp;\n        float dd = min(abs(pp1.x), abs(pp1.y));\n        baseColor = vec3(0.75)-0.25*exp(-50.0*dd);\n        refFactor = 0.8;\n        nor = vec3(0.0, 1.0, 0.0);\n        fakeAo = 1.0;\n      }\n      \n      refFactor *= pow(abs(dot(nor, rd)), 0.25);\n      vec3 ld  = normalize(bb_lightPos - p);\n      vec3 bld = normalize(bb_backLightPos - p);\n  \n          \n      float dif  = max(dot(nor, ld), 0.0);\n      float bdif = max(dot(nor, bld), 0.0);\n      float spe  = pow(max(dot(reflect(ld, nor), rd), 0.0), 40.0);\n      float sha  = bb_softShadow(p, ld, 0.1, 4.0);\n      vec3 col = 0.8*baseColor*mix(0.2, 1.0, dif*sha*fakeAo) + 0.25*spe;\n      col += baseColor*mix(0.0, 0.2, bdif);\n      col *= refFactor;\n\n      float yy = 1.0-exp(-4.0*float(iter)/float(BB_MAX_RAY_MARCHES));\n      \n      col = mix(col, shineCol, max(shine, yy*shinef));\n      // Very very random code\n      col *= mix(0.95, -1.0, abs(dot(nor,rd)));\n\n      finalCol += aggRefFactor*(col);\n\n      aggRefFactor *= (1.0 - refFactor);\n      \n      ro = p;\n      rd = reflect(rd, nor);\n  }\n\n  return finalCol;\n}\n\nvec3 bb_effect(vec2 p, vec2 q) {\n  float gtime = TIME;\n  float ltime = mod(gtime, bb_period);\n\n  bb_g_rot    = ROT(TAU*TIME*0.75/4.0);\n  bb_g_fi     = smoothstep(0.0, 1.0, ltime);\n  bb_g_fo     = 1.0-smoothstep(bb_period-1.25, bb_period-0.25, ltime);\n  bb_g_fi13   = smoothstep(bb_period*1.0/3.0-0.5, bb_period*1.0/3.0+0.5, ltime);\n  bb_g_fi23   = smoothstep(bb_period*2.0/3.0-0.5, bb_period*2.0/3.0+0.5, ltime);\n  \n  vec3 ro = 0.6*vec3(6.0, 5.0, -2.0);\n  vec3 up = vec3(0.0, 1.0, 0.0);\n\n  ro.xz *= ROT(sin(TIME*sqrt(0.3)));\n\n  vec3 la  = vec3(0.0);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.5*ww);\n\n  vec3 col = bb_render(ro, rd);\n\n  return col;  \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = bb_effect(p, q);\n\n  col = postProcess(col, q);\n\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns2XWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1427, 1427, 1452, 1452, 1481], [1483, 1557, 1596, 1596, 1685], [1687, 1687, 1726, 1726, 1755], [1757, 1860, 1887, 1887, 1974], [1976, 2081, 2110, 2110, 2175], [2177, 2214, 2253, 2253, 2378], [2380, 2380, 2407, 2407, 2476], [2478, 2478, 2514, 2514, 2747], [2749, 2749, 2804, 2804, 2862], [2864, 2864, 2891, 2891, 3270], [3272, 3272, 3293, 3293, 4394], [4396, 4396, 4422, 4422, 4662], [4665, 4665, 4750, 4750, 5101], [5103, 5103, 5163, 5163, 5441], [5443, 5443, 5477, 5477, 7764], [7766, 7766, 7798, 7798, 8524], [8526, 8526, 8581, 8581, 8772]], "test": "error"}
{"id": "NsBGRV", "name": "lens distorsion", "author": "singoltone", "description": "lens distortion", "tags": ["distortion", "displace"], "likes": 1, "viewed": 82, "published": "Public", "date": "1622036332", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n\nmat2 rotate2d_(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    \n    return mat2(c, -s, s, c);\n}\n\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\nfloat Circle(vec2 uv, float radius, float blur)\n{\n    return mix(0.,1.,smoothstep(radius, radius-blur, length(uv)));\n       \n}\n\nvec2 CartToPolar(vec2 uv, float rotation, float distortion, float rotating)\n{\n   vec2 st = vec2(atan(uv.x, uv.y), length(uv));\n   uv = vec2(st.x/6.2831+.5 +(iTime*rotating) *.1+ (st.y*distortion) ,st.y);\n    \n   return uv;\n}\n\n\nfloat PolarForm(vec2 uv, float smooth1, float size1, float size2, \n                float numSide, float rotation, float distortion, float rotating)\n{\n    vec2 st = CartToPolar(uv, rotation, distortion, rotating);\n    float x = st.x * numSide;\n    float m = min(fract(x), fract(1.-x));\n    float c = smoothstep(0., smooth1, m*size1+size2-st.y);\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    //uv=abs(uv);\n    float force = 0.5;\n    float movX = (cos(iTime*1.3)*0.5);\n    float movY = (sin(iTime*1.1)*0.3);\n    \n    vec2 offset = vec2(movX, movY);\n    \n    vec2 center = vec2(offset);\n    \n    //center = vec2(0.);\n    float a = snoise(uv*vec2(cos(iTime*0.15),sin(iTime*0.4))*0.1)*3.1415;\n\n    vec2 randPos = vec2(sin(a),cos(a));\n\n    float mask = Circle(uv-center, 0.1, 0.1);\n    float c = PolarForm(uv-center, length(randPos)*1.9, 0.4, 0.2, 3., snoise(uv+randPos)*2., snoise(uv)*2., 1.); \n    \n    \n    \n    vec2 dist = normalize(uv-center)*force*c;\n    vec3 text = texture(iChannel3, uv+dist).rgb;\n    //text += mask;\n    \n    vec3 col = vec3(uv-dist, 0.);\n    \n    col = vec3(mask);\n    // Output to screen\n    fragColor = vec4(text+col,1.0);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}, {"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsBGRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 47, 47, 94], [95, 95, 116, 116, 163], [164, 164, 186, 186, 221], [224, 224, 249, 249, 330], [332, 332, 354, 407, 2104], [2106, 2106, 2155, 2155, 2232], [2234, 2234, 2311, 2311, 2458], [2461, 2461, 2610, 2610, 2820], [2822, 2822, 2879, 2929, 3788]], "test": "error"}
{"id": "NsBSDV", "name": "Powder Explosion", "author": "kithy", "description": "Playing with displacement using textures.", "tags": ["displacement", "texture", "fur", "uvanim"], "likes": 2, "viewed": 101, "published": "Public", "date": "1621003193", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_DIST 30.0\n#define MIN_DIST 0.001\n\nmat2 rot(float a){\n    float s=sin(a);\n    float c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat rand(float n){\n\treturn fract(sin(dot(vec2(n),vec2(12.9898,4.1414)))*43758.5453);\n}\n\n\nfloat SphereDf(vec3 p,vec3 spherePos,float radius,out vec3 color){\n  \n\tvec2 uv=vec2(p.x+iTime*0.05,p.y);\n   \n\tvec3 displacement=vec3(texture(iChannel0,uv));\n   \n    color=vec3(uv,1.0);\n    color.yz*=rot(iTime);\n   \n    vec3 color1=texture(iChannel1,uv).xyz;\n    color1.xy*=rot(iTime);\n   \n    color+=color1;\n\n\tfloat dist=length(spherePos+p)-radius;\n\tdist+=dot(displacement,displacement)*2.0;\n\treturn dist;\n}\n\nfloat sceneDf(vec3 p,out vec3 color){\n    \n\tvec3 spherePosition=vec3(0.0);\n    \n    float t=(0.5*fract(iTime*0.2)*10.0)-0.5;\n\tfloat dist=SphereDf(p,spherePosition,t,color);\n\treturn dist;\n}\n\nvec3 calcNormal(vec3 p){\n\tfloat e=0.3;\n\tvec3 normal;\n\tvec3 i;\n\tnormal.x=sceneDf(vec3(p.x+e,p.y,p.z),i)-sceneDf(vec3(p.x-e,p.y,p.z),i);\n\tnormal.y=sceneDf(vec3(p.x,p.y+e,p.z),i)-sceneDf(vec3(p.x,p.y-e,p.z),i);\n\tnormal.z=sceneDf(vec3(p.x,p.y,p.z+e),i)-sceneDf(vec3(p.x,p.y,p.z-e),i);\n\n\treturn normalize(normal);\n}\n\nvec3 processLightning(vec3 baseColor,vec3 eyePos,vec3 surfacePoint){\n\tvec3 diffuseDir=normalize(vec3(-1.0,0.0,-1.0));\n\n\tvec3 normal=calcNormal(surfacePoint);\n\tfloat diffDot=max(dot(-diffuseDir,normal),0.0);\n\treturn 0.1+vec3(diffDot)*baseColor;\n}\n\nvec3 marchRay(vec3 eyePos,vec3 dir){\n\tvec3 color=vec3(0.0);\n\tvec3 currentPoint=eyePos;\n\twhile(length(currentPoint)<MAX_DIST){\n\t\tfloat intensity;\n\t\tvec3 sceneCol;\n\t\tfloat dist=sceneDf(currentPoint,sceneCol);\n\t\tif(dist<=MIN_DIST){\n\t\t\tcolor=processLightning(sceneCol,eyePos,currentPoint);\n\t\t\tbreak;\n\t\t}\n\t\tcurrentPoint+=(dist*dir);\n\t}\n\treturn color;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n\tvec3 eye=vec3(0.0,0.0,6.0);\n\tvec3 lookat=vec3(0.0);\n\tvec3 forward=normalize(lookat-eye);\n\tvec3 right=normalize(cross(forward,vec3(0.0,1.0,0.0)));\n\tvec3 up=normalize(cross(right,forward));\n\n\tvec2 p=(-iResolution.xy+2.0*fragCoord)/iResolution.y;\n  \n    \n\tvec3 dir=normalize(p.x*right+p.y*up+2.5*forward);\n\tvec3 color=marchRay(eye,dir);\n\n\tfragColor=vec4(color,1.0);\n}\n", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsBSDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 64, 64, 133], [135, 135, 155, 155, 223], [226, 226, 292, 292, 633], [635, 635, 672, 672, 823], [825, 825, 849, 849, 1135], [1137, 1137, 1205, 1205, 1382], [1384, 1384, 1420, 1420, 1731], [1733, 1733, 1786, 1786, 2152]], "test": "error"}
{"id": "NsBXDm", "name": "unmixing fluid", "author": "julianlumia", "description": ":octopusballoon:", "tags": ["fluid"], "likes": 7, "viewed": 166, "published": "Public", "date": "1620330692", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n vec2 uv = fragCoord/iResolution.xy*10.;\n \n for (float i = 1.; i < 15.; i++)\n  {\n    vec2 uv2 = uv;\n    uv2.x += sin(iTime*.25)*1.25/ i* sin(i *  uv2.y + iTime * 0.55);\n    uv2.y +=  cos(iTime*.2)*2./i* cos(i * uv2.x + iTime * 0.35 ); \n    uv = uv2;\n  }\n  \n float r = abs(sin(uv.x))+.5;\n float g =abs(sin(uv.x+2.+iTime*.2))-.2;\n float b = abs(sin(uv.x+4.));   \n vec3 col = vec3(r,g,b);   \n \n fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsBXDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 479]], "test": "valid"}
{"id": "NsBXDz", "name": "juststars1", "author": "Del", "description": "stars - a rejig of the stars here https://www.shadertoy.com/view/MdSSzW by luther, using less texture fetches\nuse mouse to pan around", "tags": ["juststars"], "likes": 5, "viewed": 169, "published": "Public API", "date": "1619989815", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// slight rejig of stars from https://www.shadertoy.com/view/MdSSzW by luther\n// use mouse to pan around\n\n// colour gradient\nvec3 colgrad(float x)\n{    \n    float r = 1.0 - (pow(x, 1.2) * 0.5);\n    float g = (pow(min(1.0, x+0.6), 2.0) * 0.9) - (x * 0.4);    \t\n    float b = (1.9-r) * 0.5;\n    return vec3(r*0.7,g,b) * 1.1;\n}\n\n// voronoi stars - simplified and slightly optimized to use a single texture fetch for the randomness\nvec3 stars(in vec2 pos)\n{\n    vec3 col = vec3(0.0);\n    vec2 n = floor(pos);\n    vec2 f = fract(pos);\n    vec2 dir = sign(f-0.5);\n    for( float j=0.0; j<=1.0; j+=1.0 )\n    {\n   \t\tfor( float i=0.0; i<=1.0; i+=1.0 )    \n\t    {\n            vec2 cell = vec2(i*dir.x,j*dir.y);\n            vec2 p = (n + cell)+0.5;\n            vec4 rnd1 = texture( iChannel0, p/256.0, -100.0 ).xyzw; // random offset,col,brightness\n            float d = length(cell + rnd1.xy - f);                \n\n            // falloff\n            float dist = max(0.1, 1.0 - d);\n            float starfo = pow(dist, 60.0) * 6.5 + pow(dist, 120.0);\n\t        col += colgrad(rnd1.z*1.2) * rnd1.w * starfo;\n        }\n    }\n    return col;\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    float zoom = 0.8+sin(iTime)*0.2;\n    uv *= zoom;\n    uv *= rot(iTime*0.05);\n\n    // mouse pan\n    vec2 mousep = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n    mousep *= zoom;\n    mousep *= rot(iTime*0.05);\n    uv += vec2(3.1, 1.3)-mousep; // origin\n\n    vec3 col = vec3(0.0);\n    float starscale = 0.5;\n    float starbrightness = 0.6 * (1.0 / pow(zoom, 0.3));\n    for (int i = 0; i < 8; i++)\n    {        \n        col += stars(uv*starscale ) * starbrightness;\n        starbrightness *= .95;// .9\n        starscale *= 1.5;\n        \n    }\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsBXDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 125, 148, 148, 324], [326, 428, 453, 453, 1129], [1131, 1131, 1152, 1152, 1220], [1222, 1222, 1279, 1279, 1929]], "test": "error"}
{"id": "NsBXWG", "name": "Vorotravellers", "author": "metabog", "description": "Thingy!", "tags": ["trigonometry", "voronoin", "knn"], "likes": 2, "viewed": 83, "published": "Public", "date": "1620873253", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//wang from https://www.shadertoy.com/view/ldjczd\nfloat wang(uint u)\n{\n    uint seed = (u*1664525u);\n    \n    seed  = (seed ^ 61u) ^(seed >> 16u);\n    seed *= 9u;\n    seed  = seed ^(seed >> 4u);\n    seed *= uint(0x27d4eb2d);\n    seed  = seed ^(seed >> 15u);\n    \n    float value = float(seed) / (4294967296.0);\n    return value;\n}\n\nvec2 pointgen(uint i)\n{\n    return vec2(wang(i), wang(i+10000u)) - vec2(0.5,0.5);\n}\n\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(3. / 3., 2. / 3., 1. / 3., 3.);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6. - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n#define MAXPOINTS 215u\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y*=(iResolution.y/iResolution.x);\n    \n    uint minknn = MAXPOINTS;\n    float minval = 100000.0;\n        \n    float parameter1 = iMouse.x/iResolution.x;\n    float parameter2 = iMouse.y/iResolution.y + 1.0;\n       \n    \n    for(uint i = 0u; i<MAXPOINTS; i++)\n    {\n        float mytime = (max(iTime,float(i)) - float(i));\n        mytime = mod(mytime,100.0f);\n        vec2 pos = pointgen(i)*cos(mytime)*64.0f;\n        pos*=0.0125;\n        pos += vec2(0.5f,0.25f);\n        float len = length(pos-uv); \n        if(len<minval)\n        {\n            minval = len;\n            minknn = i;\n        }\n        \n    }\n\n    // Time varying pixel color\n    vec2 minknnpos = pointgen(minknn);\n    vec4 col = vec4(hsv2rgb(vec3(length(minknnpos)*5.0, 0.6,0.8)),1.0);\n    \n    fragColor = col;\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsBXWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 50, 70, 70, 330], [332, 332, 355, 355, 415], [417, 417, 439, 439, 600], [626, 626, 683, 738, 1564]], "test": "valid"}
{"id": "NsBXzG", "name": "Material Maker Experiment 002", "author": "PauloFalcao", "description": "Generated using the node based material maker using my raymarching lib (see code comments)\nYoutube video making this https://youtu.be/VzV9zOzzUVA", "tags": ["fractal", "generated", "materialmaker", "nodes"], "likes": 33, "viewed": 524, "published": "Public API", "date": "1620423579", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Material Maker Experiment 002\n// By PauloFalcao\n//\n// Made in the node base material maker\n//\n// Youtube video making this https://youtu.be/VzV9zOzzUVA\n//\n// MaterialMaker is a nodebased shader maker to make procedural textures\n// With custom nodes GLSL nodes created directly in the tool,\n// it's possible to make complex stuff like raymarching :)\n//\n// It's also possible to export the generated code to Shadertoy!\n//\n// I made a library with Ray Marching nodes\n// 1st version 0.01 have 44 new nodes\n// Some nodes are based in code from other authors from shadertoy\n// I always refer the shader author and the shadertoy original code\n// The idea is to reuse the code to quicky create something without coding experience\n// Or just focus on the code of a single node\n//\n// You need Material Maker - https://rodzilla.itch.io/material-maker\n// And my library - https://github.com/paulofalcao/MaterialMakerRayMarching\n//\n// The Material Maker source is here\n//    https://github.com/paulofalcao/MaterialMakerRayMarching/blob/main/Examples/pxf002.mms\n// Just copy-paste into Material Maker\n// \n\n\nfloat iq_sdOctahedron( vec3 p, float s){\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\n\nvec3 rotate3d(vec3 p, vec3 a) {\n\tvec3 rv;\n\tfloat c;\n\tfloat s;\n\tc = cos(a.x);\n\ts = sin(a.x);\n\trv.x = p.x;\n\trv.y = p.y*c+p.z*s;\n\trv.z = -p.y*s+p.z*c;\n\tc = cos(a.y);\n\ts = sin(a.y);\n\tp.x = rv.x*c+rv.z*s;\n\tp.y = rv.y;\n\tp.z = -rv.x*s+rv.z*c;\n\tc = cos(a.z);\n\ts = sin(a.z);\n\trv.x = p.x*c+p.y*s;\n\trv.y = -p.x*s+p.y*c;\n\trv.z = p.z;\n\treturn rv;\n}\nconst float PI=3.14159265359;\n\nvec2 equirectangularMap(vec3 dir) {\n\tvec2 longlat = vec2(atan(dir.y,dir.x),acos(dir.z));\n \treturn longlat/vec2(2.0*PI,PI);\n}\n\n\n//Simple HDRI START\n\n//Hash without Sine Dave_Hoskins\n//https://www.shadertoy.com/view/4djSRW \nfloat Simple360HDR_hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat Simple360HDR_noise(vec2 v){\n  vec2 v1=floor(v);\n  vec2 v2=smoothstep(0.0,1.0,fract(v));\n  float n00=Simple360HDR_hash12(v1);\n  float n01=Simple360HDR_hash12(v1+vec2(0,1));\n  float n10=Simple360HDR_hash12(v1+vec2(1,0));\n  float n11=Simple360HDR_hash12(v1+vec2(1,1));\n  return mix(mix(n00,n01,v2.y),mix(n10,n11,v2.y),v2.x);\n}\n\nfloat Simple360HDR_noiseOct(vec2 p){\n  return\n    Simple360HDR_noise(p)*0.5+\n    Simple360HDR_noise(p*2.0+13.0)*0.25+\n    Simple360HDR_noise(p*4.0+23.0)*0.15+\n    Simple360HDR_noise(p*8.0+33.0)*0.10+\n    Simple360HDR_noise(p*16.0+43.0)*0.05;\n}\n\nvec3 Simple360HDR_skyColor(vec3 p){\n\tvec3 s1=vec3(0.2,0.5,1.0);\n\tvec3 s2=vec3(0.1,0.2,0.4)*1.5;\n    vec3 v=(Simple360HDR_noiseOct(p.xz*0.1)-0.5)*vec3(1.0);\n\tfloat d=length(p);\n    return mix(s2+v,s1+v*(12.0/max(d,20.0)),clamp(d*0.1,0.0,1.0));\n}\n\nvec3 Simple360HDR_floorColor(vec3 p){\n    vec3 v=(Simple360HDR_noiseOct(p.xz*0.1)*0.5+0.25)*vec3(0.7,0.5,0.4);\n    return v;\n}\n\nvec3 Simple360HDR_renderHDR360(vec3 rd, vec3 sun){\n    vec3 col;\n\tvec3 p;\n\tvec3 c;\n\tif (rd.y>0.0) {\n        p=rd*(5.0/rd.y);\n        c=Simple360HDR_skyColor(p);\n    } else {\n        p=rd*(-10.0/rd.y);\n        c=Simple360HDR_floorColor(p);\n\t\tc=mix(c,vec3(0.5,0.7,1.0),clamp(1.0-sqrt(-rd.y)*3.0,0.0,1.0));\n\t}\n\tvec3 skycolor=vec3(0.1,0.45,0.68);\n\tfloat d=length(p);\n\t\n\tfloat ds=clamp(dot(sun,rd),0.0,1.0);\n\tvec3 sunc=(ds>0.9997?vec3(2.0):vec3(0.0))+pow(ds,512.0)*4.0+pow(ds,128.0)*vec3(0.5)+pow(ds,4.0)*vec3(0.5);\n    if (rd.y>0.0){\n\t\tc+=vec3(0.3)*pow(1.0-abs(rd.y),3.0)*0.7;\n\t} \n    return c+sunc;\n}\n\nvec3 Simple360HDR_make360hdri(vec2 p, vec3 sun){\n    float xPI=3.14159265359;\n    vec2 thetaphi = ((p * 2.0) - vec2(1.0)) * vec2(xPI,xPI/2.0); \n    vec3 rayDirection = vec3(cos(thetaphi.y) * cos(thetaphi.x), sin(thetaphi.y), cos(thetaphi.y) * sin(thetaphi.x));\n    return Simple360HDR_renderHDR360(rayDirection,sun);\n}\n//Simple HDRI END\n\nconst float p_o349467_CamY = 2.152000000;\nconst float p_o349467_LookAtX = 0.000000000;\nconst float p_o349467_LookAtY = 0.635000000;\nconst float p_o349467_LookAtZ = 0.000000000;\nconst float p_o349467_CamD = 1.825000000;\nconst float p_o349467_CamZoom = 1.516000000;\nconst float p_o349467_Reflection = 0.200000000;\nconst float p_o349467_Specular = 0.000000000;\nconst float p_o349467_Pow = 64.000000000;\nconst float p_o349467_SunX = 2.500000000;\nconst float p_o349467_SunY = 2.500000000;\nconst float p_o349467_SunZ = 1.000000000;\nconst float p_o349467_AmbLight = 0.250000000;\nconst float p_o349467_AmbOcclusion = 0.502000000;\nconst float p_o349467_Shadow = 1.000000000;\nconst float p_o538946_s = 0.610000000;\nconst float p_o528578_x = 0.000000000;\nconst float p_o528578_y = 1.030000000;\nconst float p_o528578_z = 0.000000000;\nconst float p_o492884_r = 2.514000000;\nconst float p_o492884_x = 0.024000000;\n\nfloat o360551_input_obj3d(vec3 p) {\n    float o492884_0_1_sdf3d = iq_sdOctahedron((p),p_o492884_r)-p_o492884_x;\n    return o492884_0_1_sdf3d;\n}\n\nconst float p_o391263_smooth = 0.000000000;\nconst float p_o373061_x = 1.000000000;\nconst float p_o373061_y = 1.000000000;\nconst float p_o373061_z = 1.000000000;\nconst float p_o382957_xyz = 0.452000000;\nconst float p_o382957_x = 1.000000000;\nconst float p_o382957_y = 1.000000000;\nconst float p_o382957_z = 1.000000000;\n\n\nvec4 o360551_input_trans3d(vec4 p) {\n    vec4 o370386_0_1_v4v4 = (vec4(rotate3d((vec4((vec4((vec4(vec3(sqrt((p).xyz*(p).xyz+p_o391263_smooth)),(p).w)).xyz-vec3(p_o373061_x, p_o373061_y, p_o373061_z),(vec4(vec3(sqrt((p).xyz*(p).xyz+p_o391263_smooth)),(p).w)).w)).xyz/vec3(p_o382957_x, p_o382957_y, p_o382957_z)/p_o382957_xyz,(vec4((vec4(vec3(sqrt((p).xyz*(p).xyz+p_o391263_smooth)),(p).w)).xyz-vec3(p_o373061_x, p_o373061_y, p_o373061_z),(vec4(vec3(sqrt((p).xyz*(p).xyz+p_o391263_smooth)),(p).w)).w)).w)).xyz, -vec3((sin(iTime*0.05)*360.0), (sin(iTime*0.07)*360.0), (sin(iTime*0.03)*360.0))*0.01745329251), (vec4((vec4((vec4(vec3(sqrt((p).xyz*(p).xyz+p_o391263_smooth)),(p).w)).xyz-vec3(p_o373061_x, p_o373061_y, p_o373061_z),(vec4(vec3(sqrt((p).xyz*(p).xyz+p_o391263_smooth)),(p).w)).w)).xyz/vec3(p_o382957_x, p_o382957_y, p_o382957_z)/p_o382957_xyz,(vec4((vec4(vec3(sqrt((p).xyz*(p).xyz+p_o391263_smooth)),(p).w)).xyz-vec3(p_o373061_x, p_o373061_y, p_o373061_z),(vec4(vec3(sqrt((p).xyz*(p).xyz+p_o391263_smooth)),(p).w)).w)).w)).w));\n    vec4 o371615_0_1_v4v4 = o370386_0_1_v4v4;\n    vec4 o_o382957_0=o371615_0_1_v4v4;vec4 o382957_0_1_v4v4 = vec4(o_o382957_0.xyz,(vec4((vec4(vec3(sqrt((p).xyz*(p).xyz+p_o391263_smooth)),(p).w)).xyz-vec3(p_o373061_x, p_o373061_y, p_o373061_z),(vec4(vec3(sqrt((p).xyz*(p).xyz+p_o391263_smooth)),(p).w)).w)).w/min(min(p_o382957_x, p_o382957_y), p_o382957_z)/p_o382957_xyz);\n    vec4 o373061_0_1_v4v4 = o382957_0_1_v4v4;\n    vec4 o391263_0_1_v4v4 = o373061_0_1_v4v4;\n    return o391263_0_1_v4v4;\n}\n\nfloat for_min_o360551(vec4 p) {\n  float d=o360551_input_obj3d(p.xyz);\n  float m=min(999999.0,d);\n  for(int i=0;i<6;i++){\n    p=o360551_input_trans3d(p);\n\td=o360551_input_obj3d(p.xyz);\n\tm=min(m,d/p.w);\n  }\n  return m;\n}\n\n\nfloat o349467_input_sdf_a(vec3 p) {\n    float o360551_0_1_sdf3d = for_min_o360551(vec4((rotate3d(((((p))/p_o538946_s)-vec3(p_o528578_x, p_o528578_y, p_o528578_z)), -vec3((iTime*21.0), (iTime*27.0), (iTime*23.0))*0.01745329251)),1.0));\n    vec2 o512498_0_1_sdf3dc = vec2(o360551_0_1_sdf3d, 0.0);\n    vec2 o528578_0_1_sdf3dc = o512498_0_1_sdf3dc;\n    vec2 o538946_0_in = o528578_0_1_sdf3dc;vec2 o538946_0_1_sdf3dc = vec2(o538946_0_in.x*p_o538946_s, o538946_0_in.y);\n    return (o538946_0_1_sdf3dc).x;\n    }\n\nvec3 o349467_input_tex3d_a(vec4 p) {\n    return vec3(1.0,0.1,0.1);\n}\n\nfloat o349467_input_sdf_b(vec3 p) {\n    return max((p).y+1.0,length(vec3((p).x,(p).y+1.0,(p).z))-10.0);\n}\n\nvec3 o349467_input_tex3d_b(vec4 p) {\n    return vec3(mod(floor((p).x*2.0)+floor((p).z*2.0),2.0))*0.9+0.1;\n}\n\nvec3 o349467_input_hdri(vec2 uv) {\n    return Simple360HDR_make360hdri(vec2((uv).x,-(uv).y+1.0),normalize(vec3(-p_o349467_SunX,p_o349467_SunY,-p_o349467_SunZ)));\n}\n\nvec2 input_o349467(vec3 p) {\n    float sdfa=o349467_input_sdf_a(p);\n\tfloat sdfb=o349467_input_sdf_b(p);\n\tif (sdfa<sdfb) {\n\t  return vec2(sdfa,0.0);\n\t} else {\n\t  return vec2(sdfb,1.0);\n\t}\n}\n\n//tetrahedron normal by PauloFalcao\n//https://www.shadertoy.com/view/XstGDS\nvec3 normal_o349467(vec3 p){  \n  const vec3 e=vec3(0.001,-0.001,0.0);\n  float v1=input_o349467(p+e.xyy).x;\n  float v2=input_o349467(p+e.yyx).x;\n  float v3=input_o349467(p+e.yxy).x;\n  float v4=input_o349467(p+e.xxx).x;\n  return normalize(vec3(v4+v1-v3-v2,v3+v4-v1-v2,v2+v4-v3-v1));\n}\n\nvoid march_o349467(inout float d,inout vec3 p,inout vec2 dS, vec3 ro, vec3 rd){\n    for (int i=0; i < 500; i++) {\n    \tp = ro + rd*d;\n        dS = input_o349467(p);\n        d += dS.x;\n        if (d > 50.0 || abs(dS.x) < 0.0001) break;\n    }\n}\n\n//from https://www.shadertoy.com/view/lsKcDD\nfloat calcAO_o349467( in vec3 pos, in vec3 nor ){\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ ){\n        float h = 0.001 + 0.25*float(i)/4.0;\n        float d = input_o349467( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.98;\n    }\n    return clamp( 1.0 - 1.6*occ, 0.0, 1.0 );    \n}\n\n//from https://www.shadertoy.com/view/lsKcDD\nfloat calcSoftshadow_o349467( in vec3 ro, in vec3 rd, in float mint, in float tmax){\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    for( int i=0; i<32; i++ ){\n\t\tfloat h = input_o349467( ro + rd*t ).x;\n        res = min( res, 10.0*h/t );\n        t += h;\n        if( res<0.0001 || t>tmax ) break;  \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 raymarch_o349467(vec2 uv) {\n    uv-=0.5;\n\tvec3 cam=vec3((sin(sin(iTime*0.2)*0.5+0.5)*4.0),p_o349467_CamY,(sin(sin(iTime*0.3)*0.5+0.5)*4.0))*p_o349467_CamZoom;\n\tvec3 lookat=vec3(p_o349467_LookAtX,p_o349467_LookAtY,p_o349467_LookAtZ);\n\tvec3 ray=normalize(lookat-cam);\n\tvec3 cX=normalize(cross(vec3(0.0,1.0,0.0),ray));\n\tvec3 cY=normalize(cross(cX,ray));\n\tvec3 rd = normalize(ray*p_o349467_CamD+cX*uv.x+cY*uv.y);\n\tvec3 ro = cam;\n\t\n\tfloat d=0.;\n\tvec3 p=vec3(0);\n\tvec2 dS=vec2(0);\n\tmarch_o349467(d,p,dS,ro,rd);\n\t\n    vec3 color=vec3(0.0);\n\tvec3 objColor=(dS.y<0.5)?o349467_input_tex3d_a(vec4(p,1.0)):o349467_input_tex3d_b(vec4(p,1.0));\n\tvec3 light=normalize(vec3(p_o349467_SunX,p_o349467_SunY,p_o349467_SunZ));\n\tif (d<50.0) {\n\t    vec3 n=normal_o349467(p);\n\t\tfloat l=clamp(dot(-light,-n),0.0,1.0);\n\t\tvec3 ref=normalize(reflect(rd,-n));\n\t\tfloat r=clamp(dot(ref,light),0.0,1.0);\n\t\tfloat cAO=mix(1.0,calcAO_o349467(p,n),p_o349467_AmbOcclusion);\n\t\tfloat shadow=mix(1.0,calcSoftshadow_o349467(p,light,0.05,5.0),p_o349467_Shadow);\n\t\tcolor=min(vec3(max(shadow,p_o349467_AmbLight)),max(l,p_o349467_AmbLight))*max(cAO,p_o349467_AmbLight)*objColor+pow(r,p_o349467_Pow)*p_o349467_Specular;\n\t\t//reflection\n\t\td=0.01;\n\t\tmarch_o349467(d,p,dS,p,ref);\n\t\tvec3 objColorRef=vec3(0);\n\t\tif (d<50.0) {\n\t\t\tobjColorRef=(dS.y<0.5)?o349467_input_tex3d_a(vec4(p,1.0)):o349467_input_tex3d_b(vec4(p,1.0));\n\t\t\tn=normal_o349467(p);\n\t\t\tl=clamp(dot(-light,-n),0.0,1.0);\n\t\t\tobjColorRef=max(l,p_o349467_AmbLight)*objColorRef;\n\t\t} else {\n\t\t\tobjColorRef=o349467_input_hdri(equirectangularMap(ref.xzy)).xyz;\n\t\t}\n\t\tcolor=mix(color,objColorRef,p_o349467_Reflection);\n\t} else {\n\t\tcolor=o349467_input_hdri(equirectangularMap(rd.xzy)).xyz;\n\t}\n\treturn color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float minSize = min(iResolution.x, iResolution.y);\n    vec2 UV = vec2(0.0, 1.0) + vec2(1.0, -1.0) * (fragCoord-0.5*(iResolution.xy-vec2(minSize)))/minSize;\n    vec3 o349467_0_1_rgb = raymarch_o349467((UV));\n    fragColor = vec4(o349467_0_1_rgb, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsBXzG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1096, 1096, 1136, 1136, 1416], [1419, 1419, 1450, 1450, 1754], [1786, 1786, 1821, 1821, 1910], [1934, 2008, 2043, 2043, 2160], [2162, 2162, 2195, 2195, 2491], [2493, 2493, 2529, 2529, 2736], [2738, 2738, 2773, 2773, 2982], [2984, 2984, 3021, 3021, 3110], [3112, 3112, 3162, 3162, 3709], [3711, 3711, 3759, 3759, 4029], [4950, 4950, 4985, 4985, 5093], [5416, 5416, 5452, 5452, 6944], [6946, 6946, 6977, 6977, 7164], [7167, 7167, 7202, 7202, 7671], [7673, 7673, 7709, 7709, 7741], [7743, 7743, 7778, 7778, 7848], [7850, 7850, 7886, 7886, 7957], [7959, 7959, 7993, 7993, 8122], [8124, 8124, 8152, 8152, 8312], [8314, 8390, 8418, 8418, 8672], [8674, 8674, 8753, 8753, 8916], [8918, 8963, 9012, 9012, 9280], [9282, 9327, 9411, 9411, 9729], [9731, 9731, 9763, 9763, 11445], [11447, 11447, 11502, 11502, 11759]], "test": "valid"}
{"id": "NsjSDy", "name": "Fork Fork  fracr ", "author": "NikolaErceg", "description": "Creating multiple shapes with one SDF evaluation by repeatedly rotating and folding space", "tags": ["fractalcineshader"], "likes": 2, "viewed": 1332, "published": "Public API", "date": "1621164963", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 palette(float d){\n\treturn mix(vec3(2.0,2.02,1.24),vec3(0.,0.01,1.2),d);\n}\n\nvec2 rotate(vec2 p,float a){\n\tfloat c = cos(a);\n    float s = sin(a);\n    return p*mat2(c,s,-s,c);\n}\n\nfloat map(vec3 p){\n    for( int i = 0; i<43; ++i){\n        float t = iTime*0.01;\n        p.xz =rotate(p.xz,t);\n        p.xy =rotate(p.xy,t*5.0);\n        p.xz = abs(p.xz);\n        p.xz-=.11;\n\t}\n\treturn dot(sign(p),p)/6.;\n}\n\nvec4 rm (vec3 ro, vec3 rd){\n    float t = 1.;\n    vec3 col = vec3(0.006);\n    float d;\n    for(float i =0.; i<36.; i++){\n\t\tvec3 p = ro + rd*t;\n        d = map(p)*.98;\n        if(d<0.07){\n            break;\n        }\n        if(d>22.){\n        \tbreak;\n        }\n        //col+=vec3(3.6,3.8,3.8)/(400.*(d));\n        col+=palette(length(p)*.1)/(222.*(d));\n        t+=d;\n    }\n    return vec4(col,1./(d*20.));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-(iResolution.xy/2.))/iResolution.x;\n\tvec3 ro = vec3(55.,55.,-13.);\n    ro.xz = rotate(ro.xz,iTime);\n    vec3 cf = normalize(-ro);\n    vec3 cs = normalize(cross(cf,vec3(-17,0.,17.)));\n    vec3 cu = normalize(cross(cf,cs));\n    \n    vec3 uuv = ro+cf*3. + uv.x*cs + uv.y*cu;\n    \n    vec3 rd = normalize(uuv-ro);\n    \n    vec4 col = rm(ro,rd);\n    \n    \n    fragColor = col;\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"fractal pyramid\",\n\t\"description\": \"\",\n\t\"model\": \"car\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsjSDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 78], [80, 80, 108, 108, 180], [182, 182, 200, 200, 403], [405, 405, 432, 432, 812], [813, 813, 870, 870, 1269]], "test": "valid"}
{"id": "NsjSR3", "name": "3D SDF Operations", "author": "inspirnathan", "description": "3D SDF operations found on iq's [url=https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm]3D SDF Page[/url]. Visit my tutorial to see how I use 3D SDF operations: [url]https://inspirnathan.com/posts/60-shadertoy-tutorial-part-14/[/url]", "tags": ["3d", "raymarching", "sdf", "tutorial", "inspirnathan"], "likes": 3, "viewed": 81, "published": "Public", "date": "1620688190", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Visit my tutorial to learn how this works: https://inspirnathan.com/posts/60-shadertoy-tutorial-part-14/\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\nconst float PI = 3.14159265359;\nconst vec3 COLOR_BACKGROUND = vec3(.741, .675, .82);\nconst vec3 COLOR_AMBIENT = vec3(0.42, 0.20, 0.1);\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nfloat sdSphere(vec3 p, float r, vec3 offset)\n{\n  return length(p - offset) - r;\n}\n\nfloat opUnion(float d1, float d2) { \n  return min(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n  return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat opIntersection(float d1, float d2) {\n  return max(d1, d2);\n}\n\nfloat opSmoothIntersection(float d1, float d2, float k) {\n  float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n  return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\nfloat opSubtraction(float d1, float d2) {\n  return max(-d1, d2);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n  float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n  return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat opSubtraction2(float d1, float d2) {\n  return max(d1, -d2);\n}\n\nfloat opSmoothSubtraction2(float d1, float d2, float k) {\n  float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n  return mix( d1, -d2, h ) + k*h*(1.0-h);\n}\n\nfloat opSymX(vec3 p, float r, vec3 o)\n{\n  p.x = abs(p.x);\n  return sdSphere(p, r, o);\n}\n\nfloat opSymXZ(vec3 p, float r, vec3 o)\n{\n  p.xz = abs(p.xz);\n  return sdSphere(p, r, o);\n}\n\nfloat opRep(vec3 p, float r, vec3 o, vec3 c)\n{\n  vec3 q = mod(p+0.5*c,c)-0.5*c;\n  return sdSphere(q, r, o);\n}\n\nfloat opRepLim(vec3 p, float r, vec3 o, float c, vec3 l)\n{\n  vec3 q = p-c*clamp(round(p/c),-l,l);\n  return sdSphere(q, r, o);\n}\n\nfloat opDisplace(vec3 p, float r, vec3 o)\n{\n  float d1 = sdSphere(p, r, o);\n  float d2 = sin(p.x)*sin(p.y)*sin(p.z) * cos(iTime);\n  return d1 + d2;\n}\n\nfloat scene(vec3 p) {\n  float d1 = sdSphere(p, 1., vec3(0, -1, 0));\n  float d2 = sdSphere(p, 0.75, vec3(0, 0.5, 0));\n  //return d1;\n  //return d2;\n  //return opUnion(d1, d2);\n  //return opSmoothUnion(d1, d2, 0.2);\n  //return opIntersection(d1, d2);\n  //return opSmoothIntersection(d1, d2, 0.2);\n  //return opSubtraction(d1, d2);\n  //return opSmoothSubtraction(d1, d2, 0.2);\n  //return opSubtraction2(d1, d2);\n  //return opSmoothSubtraction2(d1, d2, 0.2);\n  //return opSymX(p, 1., vec3(1, 0, 0));\n  //return opSymXZ(p, 1., vec3(1, 0, 1));\n  //return opRep(p, 1., vec3(0), vec3(8));\n  //return opRepLim(p, 0.5, vec3(0), 2., vec3(1, 0, 1));\n  return opDisplace(p, 1., vec3(0));\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  float d; // distance ray has travelled\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    d = scene(p);\n    depth += d;\n    if (d < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  d = depth;\n  \n  return d;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(\n      e.xyy * scene(p + e.xyy) +\n      e.yyx * scene(p + e.yyx) +\n      e.yxy * scene(p + e.yxy) +\n      e.xxx * scene(p + e.xxx));\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 mouseUV = iMouse.xy/iResolution.xy;\n  \n  if (mouseUV == vec2(0.0)) mouseUV = vec2(0.5); // trick to center mouse on page load\n\n  vec3 col = vec3(0);\n  vec3 lp = vec3(0);\n  vec3 ro = vec3(0, 0, 3); // ray origin that represents camera position\n  \n  float cameraRadius = 2.;\n  ro.yz = ro.yz * cameraRadius * rotate2d(mix(-PI/2., PI/2., mouseUV.y));\n  ro.xz = ro.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lp.x, lp.z);\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  float d = rayMarch(ro, rd); // signed distance value to closest object\n\n  if (d > MAX_DIST) {\n    col = COLOR_BACKGROUND; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * d; // point discovered from ray marching\n    vec3 normal = calcNormal(p); // surface normal\n\n    vec3 lightPosition = vec3(0, 2, 2);\n    vec3 lightDirection = normalize(lightPosition - p) * .65; // The 0.65 is used to decrease the light intensity a bit\n\n    float dif = clamp(dot(normal, lightDirection), 0., 1.) * 0.5 + 0.5; // diffuse reflection mapped to values between 0.5 and 1.0\n\n    col = vec3(dif) + COLOR_AMBIENT;    \n  }\n\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsjSR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[400, 400, 428, 428, 498], [500, 500, 546, 546, 581], [583, 583, 618, 618, 643], [645, 645, 695, 695, 790], [792, 792, 834, 834, 858], [860, 860, 917, 917, 1012], [1014, 1014, 1055, 1055, 1080], [1082, 1082, 1138, 1138, 1234], [1236, 1236, 1278, 1278, 1303], [1305, 1305, 1362, 1362, 1458], [1460, 1460, 1499, 1499, 1547], [1549, 1549, 1589, 1589, 1639], [1641, 1641, 1687, 1687, 1750], [1752, 1752, 1810, 1810, 1879], [1881, 1881, 1924, 1924, 2030], [2032, 2032, 2053, 2053, 2708], [2710, 2710, 2744, 2744, 3012], [3014, 3014, 3042, 3042, 3234], [3236, 3236, 3283, 3283, 3447], [3449, 3449, 3506, 3506, 4711]], "test": "valid"}
{"id": "NsjSWd", "name": "Color switching ball", "author": "GarrettG", "description": "ball moves in an orbiting pattern and switches color", "tags": ["colorswitch"], "likes": 0, "viewed": 40, "published": "Public", "date": "1621299653", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord.xy - iResolution.xy*.5)/iResolution.y;\n    \n    \n    float u = smoothstep(.15-cos(iTime)/10., .21-cos(iTime)/10., length(vec2(uv.x + sin(iTime)/1.5, uv.y)));\n    \n    float u2 = smoothstep(.15-cos(iTime)/10., .11-cos(iTime)/10., length(vec2(uv.x + sin(iTime)/1.5, uv.y)));\n    vec3 order_flip = vec3(0);\n    \n    if (cos(iTime)/10. >= .0) {\n        u2 *= u += 1.;\n    }\n    else {\n        u *= u2 += 1.;\n    }\n    order_flip += u * u2;\n    fragColor = vec4(order_flip, .2);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsjSWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 559]], "test": "valid"}
{"id": "NsjSWy", "name": "Voxel Reflections", "author": "wildniklin", "description": "Reflections", "tags": ["reflect"], "likes": 19, "viewed": 303, "published": "Public API", "date": "1620930528", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float maxDistance = 100.0;\nconst int reflectionSteps = 10;\n\nfloat saturate(float x) {\n    return clamp(x, 0.0, 1.0);\n}\n\nconst float PI = 3.1415;\nconst float TAU = PI * 2.0;\n\nfloat rand1(vec3 p) {\n    return fract(sin(dot(p, vec3(12.9898, 78.233, 195.1533))) * 43758.5453123);\n}\n\nmat2 rot(float r) {\n    float s = sin(r), c = cos(r);\n    return mat2(c, -s, s, c);\n}\n\nint getVoxel(ivec3 vp) {\n    vec3 p = vec3(vp);\n    float h = texture(iChannel0, p.xz * 0.00390625).x * 36.0;\n    if(p.y < h) return 1;\n    return 0;\n}\n\nbool raycastVoxel(vec3 ro, vec3 rd, out ivec3 pos, out ivec3 nor, out int index, out float d) {\n    float maxdist = length(rd);\n    \n    rd /= maxdist;\n\n    pos = ivec3(floor(ro));\n    ivec3 ppos = pos;\n\n    vec3 s = sign(rd);\n    ivec3 is = ivec3(s);\n\n    vec3 td = s / rd;\n\n    if(isnan(td.x) || isinf(td.x)) td.x = 1e10;\n    if(isnan(td.y) || isinf(td.y)) td.y = 1e10;\n    if(isnan(td.z) || isinf(td.z)) td.z = 1e10;\n    \n    vec3 tm;\n    \n    if(s.x > 0.0) tm.x = td.x * ((1.0 - ro.x) + floor(ro.x)); else tm.x = td.x * fract(ro.x);\n    if(s.y > 0.0) tm.y = td.y * ((1.0 - ro.y) + floor(ro.y)); else tm.y = td.y * fract(ro.y);\n    if(s.z > 0.0) tm.z = td.z * ((1.0 - ro.z) + floor(ro.z)); else tm.z = td.z * fract(ro.z);\n\n    d = 0.0;\n\n    while(true) {\n        if(d > maxdist) break;\n\n        index = getVoxel(pos);\n\n        if(index != 0) {\n            nor = ppos - pos;\n            return true;\n        }\n\n        ppos = pos;\n    \n        if(tm.x < tm.y) {\n            if(tm.x < tm.z) {\n                d = tm.x;\n                pos.x += is.x;\n                tm.x += td.x;\n            }\n            else {\n                d = tm.z;\n                pos.z += is.z;\n                tm.z += td.z;\n            }\n        }\n        else {\n            if(tm.y < tm.z) {\n                d = tm.y;\n                pos.y += is.y;\n                tm.y += td.y;\n            }\n            else {\n                d = tm.z;\n                pos.z += is.z;\n                tm.z += td.z;\n            }\n        }\n    }\n    pos = ivec3(floor(ro));\n    nor = ivec3(0, 0, 0);\n    index = 0;\n    d = maxdist;\n    return false;\n}\n\nvec3 sky(vec3 rd) {\n    float a = abs(rd.y);\n\n    vec3 col = vec3(0.5);\n    return col;\n}\n\nvec3 light(vec3 p, vec3 n, vec3 rd) {\n    vec3 l = vec3(0.5); // Ambient\n    l += vec3(0.8, 0.7, 0.6) * dot(n, vec3(0.2, 0.6, 0.4));\n    return l;\n}\n\nfloat aces(float x) {\n    return saturate((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14));\n}\n\nvec4 image(vec2 uv, vec2 i) {\n    float t = iTime;\n\n    vec3 ro = vec3(0.0, 32.0, t * 20.0);\n    vec3 rd = normalize(vec3(uv, 0.8));\n    rd.xy *= rot(sin(t * PI * 0.125) * PI * 0.0625);\n    rd.yz *= rot(PI * 0.07);\n    rd.xz *= rot(t * PI * 0.0625);\n\n    ivec3 vp, vn;\n    int index;\n    float d;\n    bool hit;\n    float td = 0.0;\n    \n    vec3 surfaceCol = vec3(0.0, 0.0, 0.0);\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    vec3 resultCol = vec3(0.0, 0.0, 0.0);\n\n    float frac = 1.0;\n\n    for(int reflectionIndex = 0; reflectionIndex < reflectionSteps; reflectionIndex++) {\n        hit = raycastVoxel(ro, rd * maxDistance, vp, vn, index, d);\n        \n        if(hit) {\n            vec3 p = ro + (rd * d);\n            vec3 n = vec3(vn);\n\n            vec3 vfp = p - vec3(vp);\n            \n            td += d;\n            \n            float facr = 0.0;\n\n            if(index == 1) {\n                surfaceCol = vec3(rand1(vec3(vp.x, 0.0, vp.z)) * p.y * 0.0625 * 0.5);\n                facr = 0.5;\n            }\n\n            surfaceCol *= light(p, n, rd);\n            \n            surfaceCol = mix(surfaceCol, sky(rd), smoothstep(0.0, maxDistance, td));\n            \n            resultCol += surfaceCol * (1.0 - facr) * frac;\n            frac *= facr;\n            \n            ro = p + (n * 0.01);\n            rd = reflect(rd, n);\n            \n            if(frac < 0.01) break;\n        }\n        else {\n            resultCol += sky(rd) * frac;\n            break;\n        }\n    }\n    \n    resultCol = mix(vec3(0.0), resultCol, smoothstep(0.0, 5.0, t));\n    \n    //resultCol = vec3(aces(resultCol.x), aces(resultCol.y), aces(resultCol.z));\n\n    float depth = 4.0; // 8bit rgba (0-255)\n\n    vec3 cd = resultCol * depth;\n    vec3 di = floor(cd);\n    vec3 df = cd - di;\n    resultCol = (step(texture(iChannel1, i * 0.125).x + 0.00001, df) + di) / depth; // Dithered\n    \n    return vec4(resultCol, 1.0);\n}\n\nvoid mainImage(out vec4 o, in vec2 i) {\n    vec2 uv = (i - (0.5 * iResolution.xy)) / min(iResolution.x, iResolution.y);\n\n    o = image(uv, i);\n}", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}, {"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsjSWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 91, 91, 124], [180, 180, 201, 201, 283], [285, 285, 304, 304, 370], [372, 372, 396, 396, 523], [525, 525, 620, 620, 2137], [2139, 2139, 2158, 2158, 2228], [2230, 2230, 2267, 2267, 2378], [2380, 2380, 2401, 2401, 2482], [2484, 2484, 2513, 2513, 4378], [4380, 4380, 4419, 4419, 4524]], "test": "error"}
{"id": "NsjXDR", "name": "cppn2glsl_me", "author": "vsewall", "description": "this code was generated by lucid neural network in google colab", "tags": ["neural", "colab", "cppn"], "likes": 4, "viewed": 135, "published": "Public", "date": "1620030694", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define N_HIDDEN 16\n \nvec4 bufA[N_HIDDEN/4];\nvec4 bufB[N_HIDDEN/2];\n \n \nvec4 cppn_fn(vec2 coordinate, float in0, float in1, float in2, float in3) {\n    vec4 tmp;\n    bufB[0] = vec4(coordinate.x, coordinate.y, 0., 0.);\nbufA[0] = vec4(-0.01188764,-0.43942106,-0.14258054,0.3249477) + mat4(vec4(0.29039913415908813,-0.8554609417915344,-0.11501175165176392,-1.3809573650360107),vec4(-0.13692305982112885,0.0421893335878849,-0.009313126094639301,-0.8820028305053711),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\nbufA[1] = vec4(0.21546613,0.2608446,0.098036036,-0.2010489) + mat4(vec4(-0.41796863079071045,0.5140892863273621,0.7701433300971985,-0.04710474610328674),vec4(-1.6052683591842651,0.5126020312309265,-0.42065107822418213,0.8761423230171204),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\nbufA[2] = vec4(-0.36623302,-0.077089846,-0.11663237,0.08344309) + mat4(vec4(-0.13002847135066986,-0.5184891223907471,-0.15740260481834412,0.2953604459762573),vec4(0.810996413230896,-0.3671758770942688,0.20885592699050903,-0.04966791719198227),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\nbufA[3] = vec4(-0.22553389,-0.022607671,0.18652718,0.19134004) + mat4(vec4(-0.34162241220474243,-0.041106898337602615,-0.6695432066917419,-1.2537075281143188),vec4(-0.35245105624198914,0.5895901918411255,0.07827363163232803,0.391003280878067),vec4(0.0,0.0,0.0,0.0),vec4(0.0,0.0,0.0,0.0)) * bufB[0];\ntmp = sin(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(-0.3833924,-0.14140745,-0.45909643,0.40375903) + mat4(vec4(-0.26523185,0.021350326,-0.35090148,-0.069892675),vec4(0.20751852,0.03918053,0.11369929,-0.4500449),vec4(0.22889245,0.030816022,0.07816228,0.33423063),vec4(-0.18848836,0.17564122,0.26093265,0.04325231)) * bufB[0] + mat4(vec4(0.25971878,0.20110431,0.0024283545,-0.052223753),vec4(0.019098181,0.29783052,-0.12188559,-0.03591806),vec4(-0.18723741,-0.027540365,-0.4030185,-0.034814067),vec4(0.18350369,0.06527561,0.0044169817,-0.14907603)) * bufB[1] + mat4(vec4(-0.13011774,0.046215486,0.0837102,-0.043688726),vec4(0.17410825,-0.094348796,0.15354447,0.025453521),vec4(-0.3014613,-0.09288419,0.0666113,-0.1316336),vec4(-0.10624473,0.0626873,0.07515812,0.10584962)) * bufB[2] + mat4(vec4(-0.2785868,-0.10202086,0.052261405,-0.05253786),vec4(0.22347347,-0.07248388,0.2338441,0.021692788),vec4(0.084451206,0.12663168,0.44199812,-0.1253795),vec4(0.43168917,0.10620309,-0.23949452,-0.19038317)) * bufB[3] + mat4(vec4(0.03696813,-0.21778765,-0.1220835,-0.3701601),vec4(-0.25470984,0.43430823,0.24351622,-0.027586706),vec4(-0.23020479,-0.23504718,0.17882289,0.44888455),vec4(-0.1730424,-0.051200263,-0.09869131,-0.03978501)) * bufB[4] + mat4(vec4(0.41654468,-0.076496124,0.3304762,0.18556207),vec4(-0.07130955,-0.13180888,-0.37550247,-0.08000799),vec4(0.14965075,-0.25291005,-0.1918616,-0.12933421),vec4(0.037807364,-0.05250817,0.12902494,-0.0019027477)) * bufB[5] + mat4(vec4(0.20915802,0.05243046,0.037038762,0.230563),vec4(-0.057809733,-0.0878921,0.032084756,-0.00041957648),vec4(-0.1072242,-0.32361782,-0.13019624,0.26366085),vec4(-0.23554452,0.16324128,-0.19888256,-0.09398293)) * bufB[6] + mat4(vec4(-0.05100984,0.014853178,0.19684485,0.050880667),vec4(-0.20790285,-0.15672496,-0.29947534,0.013504352),vec4(-0.17040637,0.18531132,-0.19176975,-0.40122318),vec4(0.012158774,-0.30295917,-0.04131333,-0.7229828)) * bufB[7];\nbufA[1] = vec4(0.16414525,-0.31918046,-0.3278578,-0.3776018) + mat4(vec4(-0.36218122,0.12823004,-0.12157088,0.042473197),vec4(-0.27671862,-0.11933126,0.0063715912,-0.21590611),vec4(-0.12835345,-0.39738858,0.5542368,0.08189817),vec4(0.2562657,0.14430413,-0.41153714,0.3035129)) * bufB[0] + mat4(vec4(-0.10081054,0.1766137,0.26837158,-0.0048807557),vec4(0.46331024,0.31960773,-0.09003171,0.042441178),vec4(0.25728273,0.08509976,-0.014875655,-0.16246228),vec4(-0.1671931,0.083737165,-0.09052543,-0.12234629)) * bufB[1] + mat4(vec4(-0.02283654,-0.21874005,-0.21456876,-0.17862795),vec4(0.21780658,-0.31743178,-0.08137168,-0.0630911),vec4(0.08924358,0.21787211,-0.07634679,-0.5851717),vec4(0.062806405,-0.17624849,-0.05426783,0.5623959)) * bufB[2] + mat4(vec4(-0.085722625,-0.14340664,-0.01134395,0.035525683),vec4(0.14353459,-0.04556304,-0.22464678,0.20301038),vec4(0.14553338,0.14493199,-0.07584379,0.45206958),vec4(-0.09635003,0.34473184,-0.07448108,0.37217233)) * bufB[3] + mat4(vec4(-0.123606205,-0.013057303,-0.19964571,-0.10922319),vec4(-0.30685186,0.2355985,-0.18584168,0.14249346),vec4(0.30505788,-0.37679955,-0.30494317,-0.013280034),vec4(-0.2882493,0.07186636,-0.21656406,-0.5141892)) * bufB[4] + mat4(vec4(0.16761462,-0.20235357,0.04089447,-0.14356358),vec4(-0.16980529,-0.35931587,-0.09873247,-0.03923542),vec4(-0.2842888,0.011879346,-0.009229128,-0.012251155),vec4(-0.084403336,-0.21336225,0.007934365,-0.012830244)) * bufB[5] + mat4(vec4(-0.024904067,-0.14785601,-0.0876023,0.03975024),vec4(-0.25582546,-0.30452648,0.13026285,0.16295505),vec4(0.09440614,0.1678543,0.22374114,-0.021953374),vec4(0.07786727,0.026869856,-0.10584843,-0.210267)) * bufB[6] + mat4(vec4(-0.086123966,0.090173535,0.0897448,-0.10080587),vec4(0.035832554,-0.008448913,0.102230966,-0.10287236),vec4(-0.2512072,-0.03406457,0.30384374,-0.5702519),vec4(-0.25785443,-0.14396906,0.42579597,-0.35546055)) * bufB[7];\nbufA[2] = vec4(0.3492497,-0.40059206,0.09329236,0.029065864) + mat4(vec4(0.2567855,0.18944666,0.24711129,0.24822555),vec4(-0.028116994,0.19427817,-0.07277312,-0.0870325),vec4(0.049090922,0.09381051,0.20798711,0.20656487),vec4(0.061421067,-0.14233221,0.080620416,-0.3013644)) * bufB[0] + mat4(vec4(-0.064573966,0.09350138,0.34301654,-0.31899184),vec4(-0.0147023145,-0.21441974,0.13870919,0.2462099),vec4(-0.03671828,-0.26372784,0.3376088,0.1764022),vec4(0.18049258,-0.15789697,0.0011773012,0.28393164)) * bufB[1] + mat4(vec4(0.03988287,-0.2095729,-0.05157495,0.14258836),vec4(0.26740983,0.09132923,-0.104839996,-0.26308012),vec4(0.09032325,-0.0734674,0.011551204,0.22851944),vec4(-0.06203074,0.04898778,0.052567557,0.22305076)) * bufB[2] + mat4(vec4(-0.15017626,0.19987798,-0.27862582,0.006184408),vec4(-0.1455687,-0.21471746,0.09285393,-0.03244415),vec4(-0.07116267,0.28471053,-0.2333106,-0.26379442),vec4(-0.4168409,0.029033938,-0.29349777,-0.032083053)) * bufB[3] + mat4(vec4(-0.10666185,0.21977854,-0.12058142,-0.14395878),vec4(-0.06652354,0.15951931,-0.24728301,0.24720755),vec4(0.054012343,-0.04388549,-0.29568246,0.28890458),vec4(0.0031218815,0.107187584,0.28683168,-0.2548594)) * bufB[4] + mat4(vec4(0.0027799767,-0.29197928,0.05826376,0.19675295),vec4(-0.21477284,0.2844316,0.07661224,-0.07205536),vec4(0.023085296,0.61661965,-0.14921865,-0.028437171),vec4(0.20019183,-0.06311083,0.32809645,-0.36756656)) * bufB[5] + mat4(vec4(0.29815546,-0.04497121,0.12748908,-0.007526323),vec4(-0.14696287,0.15072758,-0.089913756,-0.06521657),vec4(0.3685378,0.039054625,-0.03783802,0.18856877),vec4(0.50744337,-0.16955216,-0.31031576,-0.06937413)) * bufB[6] + mat4(vec4(-0.49566486,0.2491882,0.27117163,0.36631426),vec4(0.18106478,-0.17926298,-0.043639347,0.1669385),vec4(-0.22782995,0.046030525,-0.25290436,0.08577451),vec4(0.03179103,0.23584662,-0.2061788,0.036618657)) * bufB[7];\nbufA[3] = vec4(0.1838494,0.40447015,-0.13704823,-0.36316127) + mat4(vec4(0.24103338,-0.017082544,0.01539502,0.048562042),vec4(-0.27896696,0.33026204,0.4008502,0.060453128),vec4(0.17892544,-0.07690525,-0.013444377,-0.2865501),vec4(-0.097829714,0.14903009,-0.1855413,-0.11407488)) * bufB[0] + mat4(vec4(0.10483587,0.13338569,0.24736628,0.022659944),vec4(0.060497306,-0.12995435,-0.06804258,0.07032137),vec4(0.30557308,0.25488403,-0.04556351,-0.17233516),vec4(0.24519253,-0.05089841,0.17380956,0.30959997)) * bufB[1] + mat4(vec4(-0.061780293,-0.08897885,-0.15841874,-0.028775955),vec4(0.04583087,-0.39142576,-0.13322352,-0.028358998),vec4(0.10009384,-0.26602682,-0.15049033,-0.030531801),vec4(-0.106291346,0.0453833,-0.044375326,-0.006478102)) * bufB[2] + mat4(vec4(-0.15944996,-0.12473488,-0.09933356,-0.04135245),vec4(-0.32902566,0.004249826,0.36499584,-0.076877795),vec4(0.2725726,0.15012619,-0.07032905,0.26499954),vec4(-0.014201372,0.0028424216,0.17644617,0.10234004)) * bufB[3] + mat4(vec4(-0.13094614,-0.020612642,0.15097278,0.28210226),vec4(0.0831231,-0.06572966,0.040067732,-0.15905064),vec4(0.09049544,0.13321951,-0.13992459,0.052573327),vec4(-0.051077187,0.1913895,0.14069302,0.16387706)) * bufB[4] + mat4(vec4(-0.16709737,-0.0011383799,-0.14418411,-0.3884104),vec4(-0.078763485,-0.39354533,0.0032082011,0.020393081),vec4(-0.46720815,-0.095893614,0.06580406,0.16176234),vec4(0.16044423,-0.2792088,0.0725768,-0.064378664)) * bufB[5] + mat4(vec4(0.13752182,-0.10427109,0.08723493,0.16225342),vec4(-0.5077338,-0.14184116,-0.11514835,0.24278252),vec4(-0.03523921,-0.082630105,-0.012624176,-0.09299586),vec4(-0.24476203,0.07013401,-0.11750331,-0.5815024)) * bufB[6] + mat4(vec4(0.1133508,-0.1574737,0.19402452,-0.15923052),vec4(-0.15921894,-0.08824169,0.058825556,0.031857826),vec4(-0.16958371,-0.1489236,0.04722611,-0.21123214),vec4(-0.026267324,-0.39400083,0.01896338,0.03929337)) * bufB[7];\ntmp = sin(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(-0.06634525,-0.13012464,0.46765405,-0.33999035) + mat4(vec4(0.1548786,0.16151586,0.49799153,0.18295309),vec4(-0.011789761,0.06285829,-0.0116498675,-0.13242094),vec4(0.23976423,-0.015400897,-0.2252961,0.1410327),vec4(0.086287454,-0.22047171,0.42295498,0.04716587)) * bufB[0] + mat4(vec4(-0.20396264,0.005902928,0.12966509,-0.33540505),vec4(-0.30427045,-0.19970126,-0.110415645,-0.08364996),vec4(0.3066023,0.119109906,-0.19051032,-0.28788793),vec4(-0.11350199,-0.004799328,-0.30845153,-0.1252226)) * bufB[1] + mat4(vec4(-0.1939325,-0.13711092,-0.2510853,-0.06332061),vec4(0.1834162,-0.11663299,-0.14045222,0.121190436),vec4(-0.15016223,-0.03889104,0.17524572,-0.014390054),vec4(0.15726267,0.0010202611,0.19049078,0.16788992)) * bufB[2] + mat4(vec4(-0.10575971,-0.08418744,0.17654294,0.025445495),vec4(0.0027478242,-0.32241258,0.09673768,-0.018739844),vec4(-0.062098697,-0.27998558,-0.29645464,-0.1532247),vec4(0.026559856,-0.37183386,-0.1835459,0.019925466)) * bufB[3] + mat4(vec4(0.034505956,-0.03821965,-0.5687851,0.24276073),vec4(-0.03909566,-0.0061105187,0.09911771,-0.16066259),vec4(-0.10389083,0.3463947,0.01552871,0.25682557),vec4(0.31655496,-0.20142439,-0.038883165,0.16423656)) * bufB[4] + mat4(vec4(-0.20990598,0.12814218,-0.21247207,-0.20173283),vec4(0.25330544,0.32005015,-0.018163072,-0.28937277),vec4(-0.014981924,0.089018725,0.097303055,0.20975834),vec4(0.06531297,-0.25838804,-0.12190131,0.24491136)) * bufB[5] + mat4(vec4(0.1524627,0.22790195,0.117195636,-0.04588216),vec4(0.20894405,0.0012200575,0.18707922,-0.054577973),vec4(0.11757122,-0.07837552,0.24895816,0.17971607),vec4(0.35032412,0.17829911,0.06928861,0.1249757)) * bufB[6] + mat4(vec4(0.03621342,-0.1625797,-0.054925423,0.17685725),vec4(0.062421117,-0.33985943,0.22091012,0.20599893),vec4(-0.23032968,0.0092758,0.13638754,0.13903119),vec4(0.17219527,0.13357294,0.16298468,-0.083193935)) * bufB[7];\nbufA[1] = vec4(-0.20929174,0.14947553,0.30017656,-0.43691793) + mat4(vec4(0.17685765,-0.10050187,-0.16843776,-0.29453057),vec4(-0.11567853,0.21203068,-0.022750748,0.015204175),vec4(0.17865452,0.23922499,-0.15515631,-0.34135255),vec4(0.20991257,-0.1116075,0.008309434,-0.10948714)) * bufB[0] + mat4(vec4(0.42926833,-0.19561914,0.069853306,0.32505897),vec4(0.07954022,0.22687262,-0.36287615,0.15982114),vec4(-0.03780824,0.2715925,-0.13709463,-0.019349556),vec4(0.16041373,0.2547199,0.030384092,-0.096622534)) * bufB[1] + mat4(vec4(0.00277952,0.080521986,0.008223498,-0.12966222),vec4(0.067876786,0.05525413,-0.364405,-0.12850581),vec4(0.20653905,0.12601897,0.16771908,0.027177377),vec4(0.072342776,-0.47323442,0.18116052,0.20789161)) * bufB[2] + mat4(vec4(0.18613349,0.13587557,0.3764286,0.17251068),vec4(0.2085335,-0.21540646,-0.074169405,-0.026404511),vec4(-0.0018327527,0.07932873,-0.024965595,-0.370095),vec4(-0.07373398,0.0615911,-0.09503924,-0.22755884)) * bufB[3] + mat4(vec4(-0.07184707,-0.14878227,0.12954484,0.23686743),vec4(0.0017209396,-0.07844901,-0.18788283,-0.14071926),vec4(-0.08565883,-0.12097404,0.25017667,0.25625858),vec4(-0.08605453,0.47915635,-0.07999119,0.37434542)) * bufB[4] + mat4(vec4(0.053719975,0.3647946,-0.092832685,0.048967615),vec4(-0.08254196,0.017436324,-0.033677015,-0.24159342),vec4(-0.0871762,-0.31276616,-0.17804402,-0.2057931),vec4(0.065862015,-0.10991276,0.11579323,-0.229635)) * bufB[5] + mat4(vec4(0.2778719,0.40028122,0.20217584,0.33210766),vec4(-0.26651612,0.13894309,-0.1780843,-0.1672568),vec4(0.104864515,-0.018149212,0.48139167,-0.07904076),vec4(-0.24074635,-0.24137492,-0.17527305,0.42846447)) * bufB[6] + mat4(vec4(-0.052198865,0.0563192,-0.023409083,-0.30325738),vec4(-0.13589409,-0.16137458,-0.38953358,-0.5206781),vec4(0.25181654,0.18922253,0.043649323,0.087035336),vec4(-0.2428248,-0.0139860185,0.31343314,0.32188395)) * bufB[7];\nbufA[2] = vec4(0.2787663,-0.37837434,-0.5234401,-0.13854212) + mat4(vec4(-0.03304096,-0.06996132,0.06969349,0.13538374),vec4(-0.119644426,-0.14230525,0.16455323,0.015908277),vec4(0.039206333,-0.34688592,-0.08262391,0.27853987),vec4(-0.17726049,0.041594606,0.016478345,0.2513507)) * bufB[0] + mat4(vec4(-0.017348304,-0.18323673,0.1938728,0.20068124),vec4(-0.4928631,0.33879247,0.18812758,0.28605217),vec4(-0.120600715,-0.5052539,0.32171884,0.0035905335),vec4(0.20026465,0.15410236,0.07247673,0.13724123)) * bufB[1] + mat4(vec4(0.062528856,0.03439998,-0.25063345,-0.04069082),vec4(-0.16740471,0.081823155,-0.20342968,-0.47046652),vec4(0.056957643,-0.11351671,-0.33928633,-0.36019853),vec4(0.15998846,-0.13311788,0.4487714,-0.2850588)) * bufB[2] + mat4(vec4(-0.25313324,0.09822505,-0.07036734,0.11608924),vec4(-0.06154689,-0.032099333,-0.105376564,0.167394),vec4(0.016529279,0.24672987,-0.033785317,-0.227454),vec4(-0.2837657,0.09896525,0.42333093,0.14215761)) * bufB[3] + mat4(vec4(0.16409226,0.20903419,0.28798836,0.0290004),vec4(0.14203426,0.091541484,-0.11529352,0.029620223),vec4(-0.090916574,0.049252216,-0.18791789,0.009214128),vec4(0.20627889,0.27507406,0.3010342,-0.23498529)) * bufB[4] + mat4(vec4(0.13725385,0.08376946,0.31100845,-0.19821994),vec4(-0.37790266,0.26000392,-0.090019055,-0.14819169),vec4(-0.19240753,0.24799691,-0.32340932,0.039478287),vec4(-0.08943322,-0.43672222,0.16715647,0.021575827)) * bufB[5] + mat4(vec4(-0.25114024,-0.2789216,-0.17746657,0.0024553111),vec4(-0.36834008,0.31965572,0.012263784,-0.0346164),vec4(-0.020502683,-0.19830905,-0.18164985,-0.16207431),vec4(-0.37396285,-0.14621477,-0.37001577,0.16174088)) * bufB[6] + mat4(vec4(0.070550695,0.22920543,-0.12486252,-0.025014248),vec4(0.30431417,-0.19934633,-0.07697294,0.08087418),vec4(0.21653816,0.22137196,-0.099470645,-0.072761126),vec4(-0.055476416,-0.31710938,-0.14783671,-0.041536037)) * bufB[7];\nbufA[3] = vec4(-0.25134417,0.03252539,0.14671102,-0.42313758) + mat4(vec4(-0.2815607,0.09040493,0.11623348,0.047952883),vec4(-0.043524314,0.10626559,0.16368458,-0.14927903),vec4(-0.2940522,0.10898003,-0.26815578,-0.22885989),vec4(0.04858299,-0.007852213,0.082099944,0.19787131)) * bufB[0] + mat4(vec4(-0.22647631,0.008422313,0.3890657,0.026693422),vec4(0.18523425,0.20583765,0.22209907,-0.18769188),vec4(-0.0037132858,-0.11937512,0.013615377,-0.14983273),vec4(0.122337215,0.11259784,0.01607875,-0.14585587)) * bufB[1] + mat4(vec4(-0.21297649,-0.21693847,-0.022939058,0.14208548),vec4(0.14204095,0.03036146,-0.1401315,-0.088040404),vec4(0.040602185,0.39718142,-0.11038432,0.03831673),vec4(-0.01235159,-0.10936715,-0.13202304,-0.18159488)) * bufB[2] + mat4(vec4(0.13549478,-0.045030724,-0.07435658,-0.012869195),vec4(0.08255202,0.28876388,0.1091896,0.3168327),vec4(-0.06736121,0.18539989,-0.28138718,0.09149739),vec4(0.39981797,-0.28027597,-0.11568282,0.09988891)) * bufB[3] + mat4(vec4(0.33335182,-0.15953092,-0.2440538,-0.057907518),vec4(0.1082557,0.18419082,0.019702874,-0.248859),vec4(0.23836745,-0.26421714,-0.18860444,0.045136955),vec4(-0.05231039,-0.20832226,0.1975673,-0.20214577)) * bufB[4] + mat4(vec4(-0.30811012,-0.076635525,0.30607626,-0.41599897),vec4(0.2800963,-0.19254594,-0.0021332386,-0.14067876),vec4(-0.079955846,0.028308801,0.15743467,0.14063074),vec4(-0.13806745,0.04998736,-0.28589627,-0.08700665)) * bufB[5] + mat4(vec4(0.1765289,-0.22072698,0.07672732,0.12604655),vec4(0.053277604,-0.17315929,0.08166392,-0.11878506),vec4(-0.0041510006,0.070959985,0.1242931,-0.0015291679),vec4(-0.1801743,0.13106667,0.062245544,0.17557503)) * bufB[6] + mat4(vec4(0.00022076594,0.11895869,-0.056841213,0.08284448),vec4(-0.32575235,0.08075434,-0.026491286,0.17168768),vec4(0.17660294,0.0969657,0.03899093,0.14372727),vec4(-0.14472048,-0.17572434,0.090814374,-0.08919445)) * bufB[7];\ntmp = sin(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(0.09791811,0.1116603,0.2684166,-0.49230948) + mat4(vec4(-0.035831485,0.41174978,0.009807256,-0.09986806),vec4(-0.0900887,0.14490342,-0.13191229,-0.025320584),vec4(-0.1262491,-0.23196308,-0.05174355,-0.21693623),vec4(-0.2816598,0.12749858,-0.039359387,0.11248126)) * bufB[0] + mat4(vec4(0.19546522,-0.16069573,0.0908455,0.37848833),vec4(0.038903695,-0.059954822,-0.0866114,-0.057834446),vec4(-0.115078814,-0.29046002,0.37619558,-0.39126128),vec4(-0.05828952,-0.12048157,0.05065681,0.06871648)) * bufB[1] + mat4(vec4(0.13905396,-0.005590882,-0.07658631,0.14294839),vec4(0.010790725,-0.036145277,0.2216434,-0.36577424),vec4(-0.17596744,0.204304,-0.2931535,0.22881325),vec4(0.37883198,-0.12709512,-0.12593763,0.2154096)) * bufB[2] + mat4(vec4(0.094884545,-0.24709572,0.14121038,0.30263245),vec4(0.21402903,1.740412e-05,-0.05764928,0.47056693),vec4(-0.052127473,0.06674986,0.054871187,-0.40121356),vec4(0.11966491,0.0029393828,-0.113929465,0.024656007)) * bufB[3] + mat4(vec4(-0.30214828,0.04397583,0.38438228,0.14900878),vec4(-0.18389648,0.10977824,0.4499041,-0.30403018),vec4(-0.34493613,-0.08433365,-0.055886675,0.015577665),vec4(-0.21912105,0.07744536,-0.059201524,-0.15359196)) * bufB[4] + mat4(vec4(0.02090904,0.03789012,-0.197542,-0.049426258),vec4(-0.30108088,0.17203511,0.49312937,0.043194972),vec4(-0.08418213,-0.14795296,0.24705626,-0.1102816),vec4(0.025575887,-0.28387657,0.1724576,0.219765)) * bufB[5] + mat4(vec4(-0.037218,0.007253463,0.17567773,0.0022836349),vec4(0.369427,0.2702571,0.013466389,-0.27195168),vec4(0.22898953,-0.03922364,7.784285e-05,0.21503967),vec4(-0.105698176,-0.081976645,-0.26163015,0.18753871)) * bufB[6] + mat4(vec4(0.16632159,0.24288319,0.0023925896,-0.1707287),vec4(-0.31284043,0.07943151,0.0508696,0.35390347),vec4(-0.044334523,-0.107771605,0.3373709,-0.17076284),vec4(-0.0578135,-0.0055028745,0.045668725,-0.3623358)) * bufB[7] + in0;\nbufA[1] = vec4(0.15689363,-0.11407027,0.2216595,0.47322595) + mat4(vec4(-0.14534913,-0.27006274,-0.15962456,-0.4191579),vec4(0.18543226,0.11335669,-0.13400435,0.104731865),vec4(-0.0978346,0.23240611,0.06842731,0.18989201),vec4(-0.44179758,0.010566964,-0.12650919,-0.17823786)) * bufB[0] + mat4(vec4(0.0476421,-0.06527842,-0.038155463,0.053181782),vec4(0.18764065,-0.16378927,0.3822334,0.03039565),vec4(0.07870106,0.079653494,-0.034320217,0.010390667),vec4(-0.0877913,0.051888425,0.1465357,0.03520484)) * bufB[1] + mat4(vec4(-0.059586316,-0.039289266,0.038797937,0.0006051286),vec4(-0.120919004,-0.051590767,0.004853568,-0.018451931),vec4(-0.20079511,0.014390466,-0.11184507,-0.090205856),vec4(-0.11557188,-0.059015576,0.068402484,0.38441113)) * bufB[2] + mat4(vec4(0.00750216,0.10721789,-0.14359021,-0.19854309),vec4(0.22695826,-0.20448072,0.014628803,0.17649105),vec4(-0.08965928,0.21321921,0.006412425,0.20553619),vec4(-0.10644198,-0.0015064309,0.09299679,0.038332865)) * bufB[3] + mat4(vec4(0.38750947,0.17046808,0.07256823,-0.08764277),vec4(0.17726015,0.20568344,0.07662271,-0.42494723),vec4(0.2606885,-0.22982092,-0.064624466,-0.11907005),vec4(-0.40412575,-0.22983046,-0.41372555,0.018911507)) * bufB[4] + mat4(vec4(0.07704875,-0.48940256,-0.14238317,-0.039271135),vec4(-0.3177844,-0.14699833,-0.22334166,0.12945986),vec4(-0.25037435,-0.040461168,-0.10992061,0.05305074),vec4(0.18644577,0.19247375,-0.22102812,-0.0013935659)) * bufB[5] + mat4(vec4(0.044991776,-0.05723841,0.26791257,0.16563961),vec4(-0.0036418615,-0.008242479,-0.2764946,0.21290836),vec4(-0.030374883,-0.24182978,-0.34372878,0.05601205),vec4(0.15255952,-0.060211074,-0.05163057,-0.009096778)) * bufB[6] + mat4(vec4(-0.23127538,-0.052500594,-0.38595322,-0.15921001),vec4(0.13258402,0.28588754,0.22142136,-0.07082553),vec4(-0.14599478,0.07423659,0.090524584,0.14134072),vec4(-0.036992893,0.29069003,0.017743086,0.10433702)) * bufB[7] + in1;\nbufA[2] = vec4(0.39937037,-0.044893857,-0.13296334,-0.14472643) + mat4(vec4(-0.17263614,0.03691866,-0.3588725,-0.08939105),vec4(-0.026240898,0.011585116,0.14932768,0.050558507),vec4(-0.24283327,0.13328892,0.09380133,-0.02482581),vec4(0.10185594,-0.14663762,-0.07850693,-0.010782713)) * bufB[0] + mat4(vec4(0.10264392,0.15440768,0.0899478,-0.21002322),vec4(0.15861839,0.16167456,0.27431676,-0.22998714),vec4(0.0579748,0.3753704,0.023799445,-0.011903203),vec4(0.08674676,0.0030537741,0.03011138,0.025175557)) * bufB[1] + mat4(vec4(0.11798554,0.02415621,-0.17416044,-0.16591775),vec4(0.1284987,-0.10932586,-0.05623715,0.19417563),vec4(0.09478587,0.1091185,-0.3319943,0.12472201),vec4(-0.39473143,-0.015603103,-0.5791753,0.36638707)) * bufB[2] + mat4(vec4(0.112454996,-0.10473139,-0.038805224,-0.16755164),vec4(-0.10912326,0.2115857,-0.2563854,-0.2799681),vec4(0.05159885,0.11740643,-0.14331387,-0.05109042),vec4(-0.25523245,0.14463684,-0.2265123,-0.17937653)) * bufB[3] + mat4(vec4(0.694665,-0.36918047,-0.2486227,-0.13857533),vec4(0.11571031,-0.0730411,0.059144903,0.011861595),vec4(-0.14118691,0.15527995,-0.24685098,-0.036572482),vec4(0.29035994,0.09329477,-0.019560613,-0.0684664)) * bufB[4] + mat4(vec4(-0.37347722,-0.40436333,-0.034815595,0.19162542),vec4(-0.1505109,-0.07993066,0.1489782,-0.24968249),vec4(0.09679089,-0.15876175,-0.03164778,-0.093713745),vec4(-0.006966918,0.22117546,0.21070738,-0.090066805)) * bufB[5] + mat4(vec4(0.04855465,0.2716518,0.0647251,0.5926412),vec4(-0.26556563,0.053129718,0.30426115,-0.22861983),vec4(0.021057263,-0.18784918,0.2882795,0.038454507),vec4(-0.0050545805,-0.2540297,0.1766706,-0.20991871)) * bufB[6] + mat4(vec4(0.18589929,0.02006878,-0.06025894,0.16318674),vec4(-0.27759102,-0.17241444,-0.06401465,0.3260993),vec4(0.021756733,-0.014703089,0.040441494,0.23079586),vec4(0.14853469,0.14350864,-0.19556023,-0.1561395)) * bufB[7] + in2;\nbufA[3] = vec4(0.254827,0.41600135,0.34149423,0.3948766) + mat4(vec4(0.3667217,0.33740753,-0.29526353,0.18311352),vec4(-0.13657054,0.011417283,-0.20483957,0.020019967),vec4(0.054527074,-0.026820771,-0.27498332,0.04790495),vec4(0.21591423,0.022914581,0.06048572,0.14928709)) * bufB[0] + mat4(vec4(0.050732996,-0.00951827,-0.042272504,0.34164038),vec4(0.26964933,-0.08337646,-0.05907262,-0.16106233),vec4(-0.08030521,-0.3176573,-0.018547911,0.06158363),vec4(-0.09607143,0.2794186,-0.12313456,0.05367421)) * bufB[1] + mat4(vec4(0.032248177,0.04188825,-0.07986448,-0.13565372),vec4(-0.26511532,0.14719296,-0.25096667,-0.20042247),vec4(-0.13277985,-0.36480692,0.15987928,-0.1363146),vec4(-0.42265993,0.07493502,-0.048062164,-0.22658503)) * bufB[2] + mat4(vec4(0.25400314,-0.28007713,-0.3735469,0.00459116),vec4(0.09831848,0.093743525,0.19058388,0.05169571),vec4(-0.28951406,-0.1754599,-0.012051245,0.14760938),vec4(0.091696545,-0.12487852,0.01429341,-0.15328903)) * bufB[3] + mat4(vec4(-0.10206561,0.028814368,0.30983838,0.18565592),vec4(0.10012244,0.21124454,0.037077125,0.49343318),vec4(0.28988722,0.044209573,0.031632062,-0.060379755),vec4(-0.107492775,-0.28376994,0.23963974,0.15121485)) * bufB[4] + mat4(vec4(-0.13299571,0.23206863,0.04245144,0.1268881),vec4(-0.24637946,0.12494937,-0.13268973,0.40528333),vec4(-0.062906496,0.31548136,-0.0768825,0.1858887),vec4(0.24748607,0.16491057,0.13102105,0.5639113)) * bufB[5] + mat4(vec4(-0.21480836,-0.1429738,0.6079442,0.06271117),vec4(-0.18023553,0.011217605,-0.076992035,-0.25835624),vec4(-0.00092874165,0.16159754,0.0219093,-0.26598346),vec4(-0.19461834,0.033374626,-0.1684154,-0.028992772)) * bufB[6] + mat4(vec4(-0.049089435,0.27966997,0.21965913,-0.026001122),vec4(0.24804659,-0.09707001,0.17033221,0.027405014),vec4(0.006240101,0.3538046,0.19452727,-0.29744643),vec4(0.05467672,0.10287525,-0.06921728,-0.13954386)) * bufB[7] + in3;\ntmp = sin(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(-0.4823416,-0.4740053,-0.24194978,0.1477281) + mat4(vec4(0.006943338,-0.066365555,-0.10726244,-0.33465907),vec4(-0.09466287,0.34117752,-0.061157703,-0.07706263),vec4(-0.08597946,0.348561,-0.33400437,0.14382291),vec4(0.20575403,-0.030224083,0.34607574,0.23036762)) * bufB[0] + mat4(vec4(0.12523,0.15676709,0.1877742,-0.41068652),vec4(0.12032282,-0.12676273,-0.019900313,0.34819254),vec4(-0.019996984,-0.34733903,0.090404615,-0.06706962),vec4(-0.16776985,0.10046259,0.13936625,0.19375566)) * bufB[1] + mat4(vec4(0.05063052,-0.3630593,0.07937222,0.54742634),vec4(-0.31104308,-0.26342505,-0.2789777,-0.10500127),vec4(0.019873386,-0.053287815,-0.18171865,0.1838488),vec4(-0.13947521,0.071462736,0.09790192,-0.12752181)) * bufB[2] + mat4(vec4(-0.367095,0.25783017,0.3269268,0.05623209),vec4(0.039635237,-0.21753195,0.008259007,-0.09965257),vec4(0.20122144,-0.029168624,-0.02102291,-0.045690835),vec4(-0.14802413,0.14969002,-0.43429932,0.11111736)) * bufB[3] + mat4(vec4(-0.12759346,-0.04137757,-0.23583163,0.18640773),vec4(-0.3427611,0.09573703,0.6020914,0.12683831),vec4(-0.03078156,0.010805691,-0.36683133,0.31363848),vec4(-0.25660178,-0.2668118,0.02178055,-0.031975914)) * bufB[4] + mat4(vec4(-0.20598257,-0.30117542,0.21974972,-0.2355139),vec4(0.21133101,0.1921222,0.2194784,-0.11025199),vec4(0.116797425,-0.032631516,-0.0076721497,0.06936895),vec4(-0.19194475,-0.06992294,-0.32343578,0.056014486)) * bufB[5] + mat4(vec4(8.909206e-06,0.1345564,0.12932822,-0.18151994),vec4(-0.00061694265,-0.17500234,0.29622218,0.6320929),vec4(-0.5209251,0.2779847,-0.0129644275,-0.002806157),vec4(-0.40963778,0.006352651,0.016970612,0.057108816)) * bufB[6] + mat4(vec4(0.39744395,0.28020653,0.13417673,-0.103106976),vec4(0.099737905,0.17354885,0.16072749,0.0018136421),vec4(0.15018371,0.27567413,0.0575056,-0.23438108),vec4(0.18450204,0.17193466,0.034152858,0.016821096)) * bufB[7];\nbufA[1] = vec4(-0.32377392,0.25445062,-0.26664332,-0.2919391) + mat4(vec4(-0.2889758,-0.092247926,0.012509041,0.30794552),vec4(0.55807126,-0.15582895,-0.017404703,0.019170308),vec4(0.039379284,-0.06657117,0.08774918,-0.07654694),vec4(0.16247548,-0.4769969,0.03722407,-0.21784933)) * bufB[0] + mat4(vec4(-0.1382071,0.24822904,0.19052836,-0.0843463),vec4(-0.030259388,0.0022407009,-0.19496429,-0.17578903),vec4(0.046281718,0.061699633,0.09620773,-0.2351925),vec4(-0.07554203,-0.24801187,0.036542043,-0.22858147)) * bufB[1] + mat4(vec4(0.12915234,0.114277035,-0.05858887,-0.07753819),vec4(0.1669319,0.17129642,0.1141785,0.12998906),vec4(0.05292159,-0.22107895,0.060024384,0.080012664),vec4(-0.04878381,0.023004364,-0.3608866,-0.11963696)) * bufB[2] + mat4(vec4(0.1705034,0.07894294,0.06943435,0.032189753),vec4(-0.017868655,0.21306996,0.07061292,0.06600206),vec4(0.008889296,0.021771297,0.15388761,-0.076673694),vec4(-0.15527754,0.112350196,0.21423526,0.06185394)) * bufB[3] + mat4(vec4(0.015153634,0.34081978,0.19701827,0.17767672),vec4(-0.16178757,0.23411833,-0.06370105,0.3687212),vec4(0.25625205,0.10980954,-0.13863988,0.21502523),vec4(0.101151496,0.072896056,0.20914133,0.008121712)) * bufB[4] + mat4(vec4(0.10907603,0.16314547,0.19883743,0.017526388),vec4(0.33005056,-0.17151785,-0.17455202,0.1660308),vec4(0.6112815,-0.2895334,0.012706621,-0.0034544303),vec4(0.04910527,0.24537748,-0.19087273,-0.247766)) * bufB[5] + mat4(vec4(-0.35980564,0.2564833,0.04549896,-0.024667088),vec4(0.24307393,-0.23904046,0.07151583,-0.015918849),vec4(-0.14611717,0.47912827,-0.17661905,0.19552357),vec4(0.13244458,-0.6193301,0.21029831,-0.13553469)) * bufB[6] + mat4(vec4(0.14138159,-0.002381138,-0.23390482,-0.25761524),vec4(-0.075260974,0.0816141,0.22878262,0.023130557),vec4(-0.2681645,0.36451823,0.36493412,0.24111895),vec4(0.20075719,-0.30088148,-0.184824,0.07630358)) * bufB[7];\nbufA[2] = vec4(-0.4344793,-0.22373341,0.23330948,0.5324672) + mat4(vec4(0.24986166,0.18318705,-0.45394835,-0.07553311),vec4(-0.04672613,-0.21976176,-0.38648066,-0.39403665),vec4(0.3314748,0.043520804,-0.081402555,0.03785881),vec4(0.1468437,-0.04913997,-0.37904242,-0.060329527)) * bufB[0] + mat4(vec4(0.38845545,0.020089298,0.039112084,0.1912693),vec4(0.26141495,0.16917408,0.08202348,0.08562621),vec4(0.11808233,0.01142654,0.049768254,-0.1984028),vec4(-0.016727291,0.06998988,0.123660475,0.30692145)) * bufB[1] + mat4(vec4(0.10800995,-0.03979474,-0.30398625,0.06854076),vec4(0.020021781,0.07574997,-0.3621413,-0.54193664),vec4(0.042603314,0.11306377,-0.062202502,0.118892536),vec4(-0.14012761,0.09716645,0.30303138,0.05596733)) * bufB[2] + mat4(vec4(-0.25170326,0.28296015,-0.19442163,-0.0463054),vec4(-0.2837116,0.07933143,-0.15189847,-0.098010585),vec4(-0.10785999,-0.15642008,-0.28649268,0.28840777),vec4(-0.019063497,-0.024672877,-0.037089355,0.07170041)) * bufB[3] + mat4(vec4(-0.026851796,0.124636665,-0.06065226,0.189673),vec4(0.20620793,0.0014897333,0.40853676,0.34326282),vec4(-0.052291803,-0.27187532,0.33372363,-0.06522046),vec4(-0.032275375,0.123948656,-0.05524527,0.14559698)) * bufB[4] + mat4(vec4(0.36589572,-0.29003924,0.1935249,-0.0995841),vec4(0.21174483,-0.068846986,-0.2353508,0.24299176),vec4(-0.26563105,-0.11641735,-0.046076998,-0.2687024),vec4(0.021753503,0.12858391,0.3228246,-0.045005366)) * bufB[5] + mat4(vec4(0.3802244,-0.01729125,0.21089377,0.1872902),vec4(0.005189872,0.06441101,0.18554607,0.3575663),vec4(0.25554544,0.09754002,0.06524801,-0.1902532),vec4(0.17399713,0.17205463,-0.20132194,-0.046430726)) * bufB[6] + mat4(vec4(0.43245506,-0.41297904,0.117766485,0.13195087),vec4(0.056598134,-0.17506358,-0.057482097,0.036997356),vec4(0.2399443,0.4529534,0.026582759,0.32337645),vec4(0.14349899,0.101119764,-0.111907125,0.2632557)) * bufB[7];\nbufA[3] = vec4(-0.4738487,0.26021087,-0.008732008,-0.40019324) + mat4(vec4(0.22375637,0.25812384,-0.10399836,-0.16071244),vec4(-0.1838895,-0.3101666,-0.43636093,-0.022371762),vec4(-0.19695477,-0.11962285,0.09093665,0.22341593),vec4(0.10400764,-0.0009813858,0.00978143,0.076873496)) * bufB[0] + mat4(vec4(-0.18156908,-0.023526246,-0.10853869,0.011355925),vec4(-0.06954607,0.009979201,0.32940665,-0.03390619),vec4(0.114977665,-0.09871876,0.035554625,-0.035640962),vec4(-0.18791199,0.0404613,0.23050646,0.38534734)) * bufB[1] + mat4(vec4(0.17463197,0.2689914,-0.13333367,-0.028520843),vec4(0.013234565,0.067782745,0.058910213,0.26128703),vec4(0.21969454,0.03901822,0.04561156,0.1490241),vec4(-0.26086807,-0.4153149,0.28274658,0.143384)) * bufB[2] + mat4(vec4(-0.0765823,0.08664182,-0.1819237,0.03252018),vec4(-0.11038231,0.08247195,-0.022746393,0.11720161),vec4(-0.15726848,-0.014804401,0.29618177,0.36858875),vec4(-0.034801707,0.22530144,-0.30638015,-0.0345808)) * bufB[3] + mat4(vec4(-0.2967594,-0.07639941,-0.017067391,0.18175042),vec4(-0.12958926,0.21738312,-0.25820646,0.14393842),vec4(-0.37938565,0.13886477,-0.16524252,-0.29051876),vec4(0.031474646,-0.13424702,0.12431775,-0.010791127)) * bufB[4] + mat4(vec4(0.018086728,-0.45710227,-0.050328765,-0.0965101),vec4(-0.16054052,-0.020951439,-0.22270897,-0.11729533),vec4(0.18190445,-0.26198125,0.017207216,-0.21802895),vec4(-0.08443949,-0.04826005,0.2556744,0.4124172)) * bufB[5] + mat4(vec4(0.050835554,0.21652788,-0.04768856,-0.0003305109),vec4(-0.21817411,-0.18007345,-0.14522135,-0.43172166),vec4(-0.013360226,0.00223265,-0.10944808,-0.158838),vec4(-0.12061022,0.2538895,-0.20168452,0.14419703)) * bufB[6] + mat4(vec4(-0.1466083,-0.44860473,0.028665757,0.07582849),vec4(0.2008901,0.20875596,-0.18405314,0.34618428),vec4(-0.12647566,-0.25180218,-0.10267996,0.15869546),vec4(-0.35568136,0.0134833595,-0.0048719984,-0.096900634)) * bufB[7];\ntmp = sin(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(-0.005423534,0.4930743,-0.2955585,-0.34147188) + mat4(vec4(-0.07100183,-0.099307515,-0.110677846,0.3412452),vec4(0.18758209,0.09871116,-0.31163642,-0.15022749),vec4(0.38197142,-0.08681621,0.13319731,0.07326817),vec4(0.42906576,-0.029059416,0.098114304,0.067197874)) * bufB[0] + mat4(vec4(0.3141596,-0.28479746,0.26038983,0.01300973),vec4(0.37927896,0.05766002,-0.091794215,-0.022055978),vec4(0.05161848,0.28528917,0.051881555,-0.31815886),vec4(-0.04701817,0.17671399,0.03221327,0.0071334476)) * bufB[1] + mat4(vec4(0.2241712,-0.088073954,-0.059947517,-0.4652891),vec4(-0.014386236,0.026351351,-0.020755671,0.101138785),vec4(0.50594276,-0.042754438,-0.30270794,-0.012497181),vec4(0.022190612,-0.049795326,0.2203837,-0.3152614)) * bufB[2] + mat4(vec4(0.07869822,-0.42683724,0.18663992,0.08880032),vec4(-0.28861088,-0.060331743,0.10510443,0.18864714),vec4(0.11912746,0.17450513,0.12527694,0.35577235),vec4(0.29175207,0.15434155,-0.23364517,0.00028317678)) * bufB[3] + mat4(vec4(-0.048421197,0.12319302,0.1622977,-0.34042093),vec4(0.06461551,-0.2583421,0.012907023,-0.08583416),vec4(-0.33388376,-0.113881245,0.097783156,0.2591934),vec4(-0.19824725,-0.020810883,0.0054491786,0.1476855)) * bufB[4] + mat4(vec4(0.33605078,-0.29170442,0.28622976,0.1680983),vec4(0.041381676,-0.04679912,0.08735689,-0.110992424),vec4(0.013723179,0.054438155,0.0728512,-0.5743432),vec4(0.008202228,0.008538046,0.011803829,0.1544762)) * bufB[5] + mat4(vec4(0.2162685,-0.13963565,-0.23740546,-0.21975112),vec4(0.09135907,0.36116752,-0.19154504,0.3482604),vec4(-0.13431066,0.062407576,-0.314197,-0.298702),vec4(-0.4214758,0.050571777,-0.06596626,-0.17143562)) * bufB[6] + mat4(vec4(-0.13493803,0.19601622,-0.035719197,-0.024320347),vec4(0.41586605,0.03425776,0.081359334,0.047366377),vec4(0.46078554,0.09396093,0.17724386,-0.105819084),vec4(-0.22514611,-0.18207183,0.33194745,-0.041889064)) * bufB[7];\nbufA[1] = vec4(0.053483658,-0.12863617,0.012655538,0.30951825) + mat4(vec4(0.21052426,0.07536913,-0.47526208,0.28445712),vec4(0.21685514,-0.01431419,0.24393743,0.16180195),vec4(-0.06274468,-0.1982057,-0.05220173,-0.31509224),vec4(-0.03561338,-0.0011869398,-0.052660752,0.0929103)) * bufB[0] + mat4(vec4(-0.08665048,-0.18465406,-0.47978127,0.03822419),vec4(-0.08752394,0.13198048,0.034796935,-0.04426255),vec4(-0.14636524,0.20444356,0.22189978,-0.026325483),vec4(-0.0027138705,0.3550562,0.19845854,-0.42291433)) * bufB[1] + mat4(vec4(-0.00071455963,0.3224859,-0.083633326,-0.018337416),vec4(-0.07717346,0.15881743,0.025032576,0.10163498),vec4(-0.035015807,-0.17879376,0.22156218,-0.06301542),vec4(-0.005258471,-0.24892989,0.45241728,0.053000703)) * bufB[2] + mat4(vec4(0.036747556,0.13805419,0.16841742,-0.1593942),vec4(-0.23326586,0.085680716,-0.019356646,-0.27970275),vec4(0.12418895,0.15771471,0.0361578,0.41571683),vec4(-0.36651284,0.41007087,0.1285729,0.0043097977)) * bufB[3] + mat4(vec4(-0.20339625,0.090867825,0.0045579243,0.0044566463),vec4(-0.2902801,-0.0030961453,-0.0106903305,-0.22565061),vec4(0.28663275,0.21662173,-0.18762186,-0.094857864),vec4(0.036069795,-0.22323142,-0.028557967,0.14314148)) * bufB[4] + mat4(vec4(-0.06424616,0.33368692,-0.036098298,-0.39178386),vec4(-0.04235883,-0.112834714,-0.07189797,0.12834038),vec4(0.16266158,0.023501072,0.051781196,0.07340541),vec4(0.25256285,-0.31030715,-0.0075658266,-0.3580967)) * bufB[5] + mat4(vec4(-0.13331945,-0.0015085518,0.11934441,0.13464196),vec4(0.07981742,0.099081434,-0.056273535,0.07608909),vec4(0.004749164,-0.32603616,0.04879938,-0.02950412),vec4(-0.26516667,0.016421711,-0.09017432,0.14444172)) * bufB[6] + mat4(vec4(0.59095913,0.07918083,-0.07309401,-0.06352074),vec4(-0.112751245,0.018503742,-0.48255235,-0.21025123),vec4(-0.15339427,-0.030868404,0.22723089,-0.11566364),vec4(-0.32938364,0.1095712,0.28184465,0.08896811)) * bufB[7];\nbufA[2] = vec4(-0.42766914,0.2818657,-0.10065589,0.5029465) + mat4(vec4(-0.15890454,-0.3785203,0.03688168,-0.015491568),vec4(0.18572725,0.05489765,0.2164472,-0.16060434),vec4(-0.17012952,0.14161327,-0.3309231,-0.7467491),vec4(0.23131086,0.30965427,0.031857558,-0.007538735)) * bufB[0] + mat4(vec4(0.061047077,0.0076702386,0.3674084,0.014011651),vec4(-0.21109426,0.13328539,0.094690576,-0.03786485),vec4(-0.2786808,0.29421353,0.32878324,-0.4791375),vec4(0.0029874933,-0.44149533,0.0010577722,0.1892743)) * bufB[1] + mat4(vec4(-0.00073308503,-0.21386924,-0.0038927416,-0.24723454),vec4(-0.044903796,-0.1379096,-0.09916334,0.127287),vec4(-0.031142497,-0.003229935,-0.008820418,0.051269587),vec4(-0.28441054,-0.2403257,0.19920376,0.17726152)) * bufB[2] + mat4(vec4(-0.24178573,0.023228494,0.00033642072,-0.024975115),vec4(0.2795204,-0.050744954,0.050496977,0.18405308),vec4(0.028456222,0.42091373,-0.13330285,-0.009802076),vec4(-0.22264548,-0.33697787,-0.1417489,0.11204081)) * bufB[3] + mat4(vec4(0.4476632,0.12229255,-0.14739124,-0.16704677),vec4(-0.05028534,0.2181902,-0.17266594,-0.11003495),vec4(-0.29926488,0.13834418,-0.15239547,-0.31994903),vec4(-0.09970409,0.2529757,-0.12769732,0.00037069013)) * bufB[4] + mat4(vec4(-0.21929476,0.6077096,0.117903635,0.3646789),vec4(0.11161238,-0.23269619,-0.3459012,-0.17657991),vec4(0.06519471,0.13257757,-0.1943055,0.1021659),vec4(0.052076377,-0.049374655,0.2597755,-0.110396266)) * bufB[5] + mat4(vec4(0.1192616,-0.0036411383,0.2916976,0.33520114),vec4(-0.032940388,-0.16958986,0.11399658,-0.15506735),vec4(0.2657325,-0.043353684,-0.30241334,0.19989948),vec4(0.05469219,-0.028430581,-0.09652339,0.17537624)) * bufB[6] + mat4(vec4(-0.2426318,-0.07328498,-0.040728137,-0.15608065),vec4(-0.14166972,-0.3617603,0.15249124,-0.20111798),vec4(0.029080689,0.27717787,0.35793337,-0.15470243),vec4(-0.2257737,-0.12626614,-0.18000662,0.30612534)) * bufB[7];\nbufA[3] = vec4(0.4540791,0.30035308,-0.43283266,0.235482) + mat4(vec4(0.39691153,0.1338818,-0.31558135,0.18362896),vec4(-0.16602173,0.07371897,0.083845384,0.21780089),vec4(0.23421696,-0.18630052,-0.065887295,-0.2609415),vec4(-0.10018126,0.13168491,0.069900975,0.21892317)) * bufB[0] + mat4(vec4(0.27667865,-0.24521013,0.3054227,0.20187081),vec4(-0.4074337,-0.09444422,0.030421745,0.3437136),vec4(0.0105758365,-0.06666353,0.3271819,-0.2072251),vec4(0.08421221,0.25461924,-0.30389142,0.18030429)) * bufB[1] + mat4(vec4(-0.0099942,-0.042866357,-0.15747704,0.011262264),vec4(0.16543666,0.21345167,-0.20469894,0.13924474),vec4(0.13032821,0.0869743,-0.111179546,-0.14777756),vec4(0.105351165,0.09784404,-0.14293289,-0.3098338)) * bufB[2] + mat4(vec4(0.015030443,0.11565258,-0.07609979,0.022891482),vec4(0.083666615,-0.16126774,0.030592721,-0.27758163),vec4(-0.32781434,-0.14441593,-0.15649176,-0.009048806),vec4(0.004503359,0.23967937,0.3455187,-0.094904914)) * bufB[3] + mat4(vec4(0.18979073,0.08051882,-0.105404876,-0.09148656),vec4(-0.14189419,-0.020669155,-0.22759454,-0.0063107866),vec4(0.10779895,-0.17645013,0.042948574,0.28157282),vec4(0.45020124,-0.04337151,-0.18350714,0.09779698)) * bufB[4] + mat4(vec4(0.012985994,0.23810056,-0.08526541,-0.16961388),vec4(-0.13989203,0.15531853,-0.17625976,0.0077860095),vec4(-0.104202636,0.43000242,-0.27615052,-0.3055122),vec4(0.3304734,0.3444831,-0.014338953,0.22964013)) * bufB[5] + mat4(vec4(-0.2881652,0.006834821,-0.2608064,-0.017430529),vec4(0.3475841,0.26736882,-0.10044554,0.214999),vec4(0.09532388,0.30175662,-0.06629203,0.15426752),vec4(-0.3521044,-0.118894234,0.30749863,0.27702418)) * bufB[6] + mat4(vec4(0.10416253,0.40845832,-0.015044494,-0.30158046),vec4(0.35736942,-0.082303315,0.022105668,-0.27006915),vec4(0.09977567,-0.007552528,-0.29667136,-0.14513665),vec4(0.18710923,-0.169822,0.37067893,0.104677565)) * bufB[7];\ntmp = sin(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(0.22652045,0.46857694,-0.48766193,0.32882437) + mat4(vec4(0.024530146,-0.29010934,-0.07128141,-0.3664425),vec4(-0.09461495,0.16813749,-0.2562568,-0.04094862),vec4(0.010386049,0.37919584,0.07368625,0.021452812),vec4(-0.07637981,-0.03688202,0.05607385,0.19069909)) * bufB[0] + mat4(vec4(0.33483398,0.093729995,0.71830344,-0.0999612),vec4(0.21636553,-0.21569431,-0.2613586,0.067653805),vec4(0.22410294,-0.0050320607,-0.21081378,-0.066415906),vec4(-0.19630256,-0.095088266,0.20513418,0.015904497)) * bufB[1] + mat4(vec4(0.3129232,-0.118038796,0.020495292,0.33574525),vec4(0.094575,0.44913927,-0.053962395,-0.07194115),vec4(-0.07634972,0.037208512,0.30842432,-0.048027918),vec4(0.122814156,-0.07144272,-0.05146332,0.28104255)) * bufB[2] + mat4(vec4(-0.17546724,-0.34537524,0.028431885,0.24913721),vec4(0.109438874,0.054701727,-0.08345286,-0.095505625),vec4(-0.16815022,0.028318694,0.03133061,-0.13950436),vec4(-0.017560478,0.0011288349,0.095074534,-0.42435402)) * bufB[3] + mat4(vec4(-0.20787008,-0.15413825,0.027039703,-0.013738293),vec4(-0.28564978,0.11242427,0.045717716,0.16456348),vec4(-0.4448699,0.22690837,-0.6104537,-0.14922802),vec4(-0.37146744,-0.051244862,0.33284986,-0.23871943)) * bufB[4] + mat4(vec4(0.22234471,-0.3432206,-0.015550692,0.4096789),vec4(-0.01256639,-0.22386079,-0.39276403,0.09843174),vec4(-0.06967427,-0.16694415,-0.14316317,-0.35591155),vec4(0.34146175,0.16036157,-0.07164449,-0.14445813)) * bufB[5] + mat4(vec4(-0.22757208,-0.1650562,-0.19290228,0.105060644),vec4(-0.035192262,0.23939103,0.10204788,0.007550137),vec4(0.27746105,0.38803753,-0.20976245,0.10554974),vec4(-0.34755564,-0.068555824,0.22327125,0.03205755)) * bufB[6] + mat4(vec4(-0.1792329,-0.025293706,0.21700318,-0.0018222526),vec4(0.06899751,0.10444907,-0.07118339,-0.006728459),vec4(-0.013464495,-0.31770268,-0.13691609,-0.10016092),vec4(0.11513131,-0.081534296,0.4226651,-0.029311555)) * bufB[7];\nbufA[1] = vec4(-0.2162676,0.07696595,0.29834062,-0.10690433) + mat4(vec4(0.40549812,-0.13851951,0.18339051,-0.32659385),vec4(0.02391127,0.37568387,-0.15716954,-0.13964747),vec4(-0.091538735,0.07513403,-0.023007939,-0.36331204),vec4(-0.06664769,-0.16883907,0.260921,0.1561428)) * bufB[0] + mat4(vec4(-0.13761745,-0.10064148,-0.06303714,0.02760321),vec4(0.17379928,0.37210855,-0.0579397,0.049540773),vec4(0.0537202,0.13396704,0.18121378,-0.29114258),vec4(-0.18768261,0.05135948,0.32541507,0.24066535)) * bufB[1] + mat4(vec4(-0.31662992,0.12623845,-0.27816933,0.17105088),vec4(0.2123483,0.35024244,-0.10210519,-0.15834463),vec4(-0.019712735,-0.18716918,0.041835714,0.05099423),vec4(-0.38334912,-0.13027444,-0.18869208,-0.17276691)) * bufB[2] + mat4(vec4(0.23235908,-0.04246121,-0.037187234,-0.33943552),vec4(-0.030788431,0.028186396,-0.18478332,-0.25024208),vec4(0.030478748,0.18737395,-0.29676965,0.20869875),vec4(-0.042577647,0.26407203,0.228341,0.2849977)) * bufB[3] + mat4(vec4(0.34398872,-0.1752241,-0.0911447,0.11401607),vec4(0.11961007,-0.19950919,-0.32694328,-0.2692876),vec4(0.46786794,-0.31652063,0.112180084,-0.110889904),vec4(0.07835598,0.16513231,-0.08507965,-0.35841465)) * bufB[4] + mat4(vec4(0.12822878,0.01746236,-0.10529441,-0.05723755),vec4(0.09892136,0.16175589,0.3046184,0.092005685),vec4(-0.041266825,0.12049596,-0.04818837,0.17072292),vec4(0.03762006,0.066618346,-0.06609901,0.17432661)) * bufB[5] + mat4(vec4(0.3842484,0.23690508,0.25520116,0.27771044),vec4(0.027082536,0.45313787,0.44007435,-0.3650165),vec4(0.010413763,-0.3435248,0.0029784176,0.020073628),vec4(0.31698236,0.4260201,0.04802069,-0.010507436)) * bufB[6] + mat4(vec4(0.10768101,-0.06255545,-0.05968339,0.07376792),vec4(0.016713146,0.076921046,-0.14672741,-0.24262257),vec4(0.1490774,0.18449977,0.11591523,0.07394678),vec4(0.07620636,0.2966959,-0.19720435,-0.33229023)) * bufB[7];\nbufA[2] = vec4(-0.38446185,-0.24270801,0.20619713,-0.21775113) + mat4(vec4(-0.056072224,0.2672904,-0.113414675,0.07690288),vec4(0.35054716,-0.028107027,0.008139472,-0.102549836),vec4(-0.24900019,0.03437556,0.09604081,-0.08989911),vec4(0.30583552,0.223189,-0.16198666,0.60512376)) * bufB[0] + mat4(vec4(0.29188758,-0.17628387,-0.21075825,0.10496197),vec4(-0.16219735,0.09536851,0.34428617,0.07135073),vec4(0.20411697,-0.27709547,0.11243127,-0.05399074),vec4(0.38719216,0.128694,0.117489204,0.28292233)) * bufB[1] + mat4(vec4(0.35463715,-0.15078685,-0.24214657,0.15069205),vec4(-0.06055143,0.13232228,-0.0995741,0.052539375),vec4(-0.06114714,-0.14894094,-0.48924488,0.15147367),vec4(0.46857917,-0.033327032,0.20990014,0.16311343)) * bufB[2] + mat4(vec4(-0.1123464,-0.07823884,0.17235896,-0.19931276),vec4(-0.0935362,0.024549106,0.43696514,-0.19635625),vec4(-0.14503388,0.28232965,-0.14900449,0.04323808),vec4(-0.055706576,-0.014385736,0.09007548,-0.20344563)) * bufB[3] + mat4(vec4(-0.4210667,0.03566211,0.19943357,-0.22165516),vec4(0.57416296,0.16289252,-0.01764646,-0.085769966),vec4(-0.27765292,0.4105603,0.4469583,0.102713816),vec4(0.17461315,0.033856034,0.20624626,0.34982327)) * bufB[4] + mat4(vec4(-0.066344686,-0.08922214,0.047329433,-0.16122848),vec4(0.07677119,-0.20443304,0.32681638,0.2926242),vec4(-0.3852087,-0.17032096,0.09368738,0.17082721),vec4(-0.11642743,-0.1524953,0.15534896,0.031091174)) * bufB[5] + mat4(vec4(-0.28979954,0.27359,0.15377605,-0.3273905),vec4(-0.2899803,0.11284586,0.07211908,-0.053503178),vec4(-0.13624667,-0.2389846,-0.15970443,-0.47711423),vec4(0.28381547,0.17933933,0.10964762,0.010382858)) * bufB[6] + mat4(vec4(-0.22443548,0.09574494,0.20789462,0.21870495),vec4(-0.12040427,0.247829,0.109423146,-0.43130907),vec4(0.26278263,-0.121860415,0.03217637,0.16935025),vec4(0.5675553,-0.29177433,-0.39690405,0.08175748)) * bufB[7];\nbufA[3] = vec4(-0.19877808,0.19630471,-0.1814521,0.21995287) + mat4(vec4(-0.05523309,0.003341232,0.03549266,0.025715802),vec4(-0.10671235,0.033510912,-0.10914512,0.040118564),vec4(-0.06641512,0.03786633,0.16251026,-0.18003768),vec4(0.28614712,-0.18749829,0.49934304,-0.11646927)) * bufB[0] + mat4(vec4(0.35390243,0.10136614,-0.27478924,-0.24018556),vec4(0.41219753,-0.02729427,0.021444734,0.16599654),vec4(-0.10800606,-0.23304905,0.044667464,-0.051043514),vec4(-0.027491737,0.19180313,0.1279183,-0.3254081)) * bufB[1] + mat4(vec4(0.28993666,-0.21881317,0.37451506,0.061591916),vec4(-0.27074808,0.1646458,-0.16089173,-0.12775992),vec4(0.54603887,-0.20729469,-0.012027236,-0.14073744),vec4(0.27295637,0.030126402,-0.08271182,-0.17942019)) * bufB[2] + mat4(vec4(-0.04497167,-0.16050968,-0.044843536,0.12266973),vec4(0.02426149,0.17681643,-0.060707144,-0.25670663),vec4(0.14662316,0.4095316,0.055546608,-0.053896375),vec4(0.018184498,-0.13233712,-0.24635464,0.084154464)) * bufB[3] + mat4(vec4(-0.26517788,-0.031496026,-0.2464005,-0.48031616),vec4(-0.1827384,-0.37561113,-0.16956426,0.36063072),vec4(-0.3549401,0.3480541,0.059017606,0.36852494),vec4(0.15541673,0.18988396,-0.63726616,0.027439907)) * bufB[4] + mat4(vec4(-0.05293998,-0.10646336,0.48639542,0.15108624),vec4(-0.011545484,-0.009100654,0.09385602,-0.10738314),vec4(-0.39855143,0.0057409755,-0.08943023,0.08938691),vec4(0.09012221,0.12478403,-0.14025207,-0.039965443)) * bufB[5] + mat4(vec4(-0.37438104,-0.033434715,-0.13300511,0.027482035),vec4(0.1513802,-0.12368752,0.029428389,0.12125583),vec4(-0.19427213,0.22455475,-0.2777388,-0.34212628),vec4(0.27306435,0.25568172,0.2413547,-0.12646982)) * bufB[6] + mat4(vec4(0.0038864114,-0.108795196,0.10149331,0.04397712),vec4(-0.43879944,-0.19851789,-0.4099643,-0.09497747),vec4(-0.05390885,0.10556861,-0.10851083,-0.4452001),vec4(0.012771086,0.36855534,-0.49285153,-0.45900983)) * bufB[7];\ntmp = sin(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(0.016208997,-0.12618847,0.24486516,-0.4763399) + mat4(vec4(-0.07792982,0.13946365,0.4903376,0.014657416),vec4(0.24842048,0.04143657,-0.5884402,-0.15710962),vec4(0.24714273,-0.12598766,-0.19569926,-0.3039427),vec4(-0.45604312,0.13694264,-0.08644363,0.37575904)) * bufB[0] + mat4(vec4(-0.08753524,0.28669062,-0.21368486,-0.25437146),vec4(-0.04720662,-0.4994733,0.0923837,-0.17773248),vec4(-0.20805517,-0.122105345,0.43546826,0.31041205),vec4(0.14584108,-0.04716203,0.29324326,-0.32561418)) * bufB[1] + mat4(vec4(0.23308134,0.17147596,-0.12246599,-0.16761582),vec4(0.10080316,-0.2885133,0.025728572,0.254314),vec4(0.58090025,0.23520492,0.12911303,0.22808112),vec4(-0.16329494,-0.10470914,0.078413285,0.4807949)) * bufB[2] + mat4(vec4(0.45529225,0.0969389,-0.31594786,-0.344472),vec4(-0.23695366,0.38285795,-0.10821206,-0.33015972),vec4(-0.19364887,0.13363937,-0.2156121,-0.025313912),vec4(0.41141668,0.39745775,-0.124360345,0.19801341)) * bufB[3] + mat4(vec4(0.228272,-0.14389557,-0.5178728,0.07919282),vec4(-0.56590664,0.30493712,0.5212071,0.13854845),vec4(-0.60546124,0.32119393,-0.316296,-0.03960079),vec4(-0.33675712,0.059952084,0.13218556,0.22151244)) * bufB[4] + mat4(vec4(0.12846552,0.27651533,0.20246802,-0.4372186),vec4(0.073180795,-0.18904863,0.07151825,0.0059769796),vec4(-0.29122394,0.45855364,-0.39654315,0.10632728),vec4(0.5595375,0.10803949,0.3523867,0.25680864)) * bufB[5] + mat4(vec4(-0.43537885,-0.08277738,0.20091707,-0.2127068),vec4(-0.63027453,0.69707793,0.13696434,0.022732804),vec4(-0.088025,-0.29260257,0.10189009,0.62442565),vec4(0.028844066,0.20544183,0.06735656,-0.04961151)) * bufB[6] + mat4(vec4(0.36380464,-0.12928036,0.007838696,0.03155073),vec4(0.23975644,-0.146477,-0.057965,0.25213036),vec4(-0.12042509,-0.12607029,-0.09451865,0.36867663),vec4(0.31819808,0.25657335,-0.18712121,-0.26256913)) * bufB[7];\nbufA[1] = vec4(0.030781375,0.20686755,0.16911587,0.36825886) + mat4(vec4(0.023809219,0.28416094,0.06153757,-0.008593331),vec4(0.37594035,0.06785485,-0.16685165,0.12614141),vec4(-0.52999544,-0.09660542,0.28077176,-0.023967357),vec4(0.16833407,-0.0016651733,0.089434825,0.4946551)) * bufB[0] + mat4(vec4(-0.014309097,0.13009112,0.036580168,0.15512651),vec4(0.17665935,-0.19738175,0.111884095,0.05490424),vec4(0.30770138,0.010528209,-0.38682762,0.035140187),vec4(0.27103698,-0.05272186,0.1590039,0.0661787)) * bufB[1] + mat4(vec4(0.04597043,0.0671794,0.21709101,-0.22935878),vec4(-0.17360704,-0.04668644,-0.18018627,0.0269388),vec4(0.35123152,0.1131569,0.14315446,-0.19060819),vec4(-0.15524659,0.039920703,0.051369652,0.046185613)) * bufB[2] + mat4(vec4(-0.39418116,-0.10758177,0.18942958,-0.3166744),vec4(-0.44884655,0.581317,0.3672387,0.2699743),vec4(0.14016388,0.71874887,-0.2085254,0.2622714),vec4(-0.0767303,-0.33226126,0.45676428,-0.11115014)) * bufB[3] + mat4(vec4(-0.18254752,-0.38465077,0.21933158,-0.18665569),vec4(-0.27156654,0.31991804,0.29703036,0.035422754),vec4(-0.1977538,0.118886605,-0.83222145,0.12435271),vec4(-0.27763334,-0.24137683,-0.1794727,0.23421279)) * bufB[4] + mat4(vec4(-0.24731565,-0.17084138,0.4719704,0.040694725),vec4(-0.29011387,-0.055223566,0.29789004,-0.31197652),vec4(0.061779935,0.21802524,-0.36323935,0.06847944),vec4(0.14109072,-0.37906453,-0.1899254,0.16446753)) * bufB[5] + mat4(vec4(0.25862867,0.31112346,0.16158389,-0.08194304),vec4(-0.2730155,0.10003344,-0.01181535,0.002190992),vec4(0.029266838,0.20016484,-0.11849808,0.2864165),vec4(0.13230026,0.027522704,0.049118172,0.26178378)) * bufB[6] + mat4(vec4(0.26177692,0.6584692,-0.27716187,-0.1023153),vec4(0.60054374,0.28101268,0.41523224,0.49586806),vec4(0.06138185,0.2670764,-0.049483635,0.0778318),vec4(-0.07410579,-0.030577464,0.105877526,0.20039237)) * bufB[7];\nbufA[2] = vec4(-0.09970334,-0.1722546,-0.2641196,0.06783197) + mat4(vec4(-0.17584759,0.13361236,-0.06742852,0.24729161),vec4(-0.19253495,0.07663851,0.21591003,0.24445146),vec4(0.066036895,0.15255396,-0.026354218,-0.14746484),vec4(-0.38395977,-0.42877808,0.1096303,0.0114461575)) * bufB[0] + mat4(vec4(0.22751595,-0.3142223,-0.35121512,0.23883177),vec4(-0.090820655,-0.17059197,-0.25193992,0.058882136),vec4(-0.063448966,-0.15136828,0.3213209,-0.056220323),vec4(0.08823203,-0.5936462,0.48215428,-0.059625223)) * bufB[1] + mat4(vec4(0.14231072,0.09333662,0.027666146,0.105663694),vec4(0.070788994,-0.07069079,0.06610581,-0.10485279),vec4(0.022703644,0.19555898,0.30416492,0.022918208),vec4(0.062190074,0.055428877,-0.083867945,-0.18771937)) * bufB[2] + mat4(vec4(-0.11235085,-0.08999527,-0.15983136,-0.119711205),vec4(-0.2089684,0.16009362,-0.091873735,-0.04170121),vec4(0.13766736,-0.70138156,0.15880498,0.13573757),vec4(0.23082447,-0.27481517,0.254696,-0.117319494)) * bufB[3] + mat4(vec4(-0.15749392,-0.106718615,0.13433029,-0.38322294),vec4(0.29208395,-0.21504891,-0.14251424,0.027985366),vec4(0.19830497,0.019793184,0.0692314,0.015079584),vec4(-0.34359583,0.58216995,-0.21803391,0.019614877)) * bufB[4] + mat4(vec4(0.15955886,0.036495488,-0.100695245,0.0294184),vec4(0.070208125,-0.11835642,-0.118030526,-0.22152604),vec4(0.48427814,-0.3826441,0.09125072,-0.009462609),vec4(-0.029540706,0.18363108,0.5605893,-0.009689908)) * bufB[5] + mat4(vec4(0.15030617,-0.4823868,0.20396312,0.17241937),vec4(0.3960831,-0.013303989,-0.37150186,-0.06695142),vec4(-0.5976029,-0.06259428,-0.08500432,-0.0872998),vec4(0.09979455,0.4740747,-0.09373048,-0.20534791)) * bufB[6] + mat4(vec4(0.27675408,-0.20526339,0.072206385,-0.22737494),vec4(-0.30683368,-0.3857693,0.14061162,-0.02185978),vec4(-0.002855959,-0.35615754,-0.09132144,-0.22300245),vec4(0.1676894,0.16261789,-0.049963336,0.12403064)) * bufB[7];\nbufA[3] = vec4(-0.53259236,-0.42734972,-0.52100813,-0.033705145) + mat4(vec4(-0.13944958,0.24208699,-0.3112038,0.07261596),vec4(-0.14281073,0.1486895,-0.12042675,-0.06949355),vec4(-0.13877465,-0.07513033,0.3309955,0.19813575),vec4(-0.15230119,-0.14731233,0.16751668,0.30868828)) * bufB[0] + mat4(vec4(0.03960414,-0.13427176,-0.18156296,0.12595285),vec4(-0.057897504,-0.13084044,0.020260641,-0.34017196),vec4(0.052758437,-0.15868305,0.046327215,-0.17550161),vec4(0.25140873,-0.14024574,0.102153555,-0.06190315)) * bufB[1] + mat4(vec4(0.017382389,-0.13167746,0.05750892,0.043160453),vec4(-0.0641441,-0.29610673,0.35302785,-0.2032333),vec4(-0.24980015,0.049853444,-0.1307116,0.0026944014),vec4(0.1987963,-0.040912956,-0.12920678,-0.30063516)) * bufB[2] + mat4(vec4(-0.1269044,0.074015014,-0.08534172,-0.23698714),vec4(-0.48132563,-0.09340609,0.07860296,0.16078724),vec4(-0.14612071,0.021496905,-0.11170163,0.035476264),vec4(0.38526705,-0.15503307,0.21611175,-0.12447261)) * bufB[3] + mat4(vec4(0.34473428,-0.16290455,0.4975391,-0.021013038),vec4(0.27097833,-0.04076678,-0.21275097,0.1529415),vec4(0.07675823,0.03125495,-0.4049387,-0.055665534),vec4(-0.07906219,0.0043636346,0.24568017,-0.25565445)) * bufB[4] + mat4(vec4(-0.06743809,0.11403479,-0.24729429,0.36764252),vec4(0.3757386,0.16076036,0.32238066,0.25005144),vec4(0.0067560235,0.10348267,-0.0050340076,0.27337396),vec4(-0.040328577,-0.027294323,0.076789595,-0.20361449)) * bufB[5] + mat4(vec4(0.46905443,0.038633328,0.09966311,0.0970247),vec4(0.119112276,0.57762986,-0.73722976,0.4649084),vec4(0.5219284,-0.0020098803,0.22244236,-0.01626957),vec4(-0.22724044,-0.3234311,0.19427663,-0.25344652)) * bufB[6] + mat4(vec4(0.2229574,0.0019782449,-0.09674873,-0.059323065),vec4(0.2748027,-0.21472007,0.31466642,0.20737709),vec4(0.013394484,-0.06383078,-0.19860849,0.088774905),vec4(-0.33860025,-0.15366605,0.21794009,0.020972447)) * bufB[7];\ntmp = sin(bufA[0]);\nbufB[0] = tmp/0.67;\nbufB[4] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[1]);\nbufB[1] = tmp/0.67;\nbufB[5] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[2]);\nbufB[2] = tmp/0.67;\nbufB[6] = (tmp*tmp) / 0.6;\ntmp = sin(bufA[3]);\nbufB[3] = tmp/0.67;\nbufB[7] = (tmp*tmp) / 0.6;\nbufA[0] = vec4(0.32628417015075684,0.03403554484248161,-0.04858730733394623,0.0) + mat4(vec4(0.046565208584070206,0.036782532930374146,0.03859766945242882,0.0),vec4(-0.3114613890647888,-0.2645445466041565,-0.2505411207675934,0.0),vec4(-0.10350773483514786,-0.09496141225099564,-0.09082332253456116,0.0),vec4(-0.1651027351617813,-0.14072342216968536,-0.12630853056907654,0.0)) * bufB[0] + mat4(vec4(-0.10610052198171616,-0.09595506638288498,-0.09646602720022202,0.0),vec4(-0.12508761882781982,-0.11310730874538422,-0.11003166437149048,0.0),vec4(0.05915644392371178,0.05668460577726364,0.05442323163151741,0.0),vec4(-0.06655494123697281,-0.11688673496246338,-0.11684626340866089,0.0)) * bufB[1] + mat4(vec4(-0.026260044425725937,0.034118253737688065,0.052212584763765335,0.0),vec4(0.16112849116325378,0.1517678201198578,0.15196484327316284,0.0),vec4(-0.35888513922691345,-0.41756364703178406,-0.31814029812812805,0.0),vec4(-0.10999071598052979,-0.051565006375312805,-0.010170236229896545,0.0)) * bufB[2] + mat4(vec4(0.157989501953125,0.13753259181976318,0.13327953219413757,0.0),vec4(-0.29893556237220764,-0.1623815894126892,-0.05592522770166397,0.0),vec4(0.22221533954143524,0.22146247327327728,0.22022749483585358,0.0),vec4(-0.11505631357431412,-0.26717010140419006,-0.30998775362968445,0.0)) * bufB[3] + mat4(vec4(-0.1270071417093277,-0.1169491857290268,-0.11086736619472504,0.0),vec4(-0.17428745329380035,-0.17979727685451508,-0.1734602302312851,0.0),vec4(-0.1177394688129425,-0.09794020652770996,-0.0924767553806305,0.0),vec4(-0.1730496883392334,-0.14830657839775085,-0.1430053859949112,0.0)) * bufB[4] + mat4(vec4(-0.13593046367168427,-0.12552307546138763,-0.12012223899364471,0.0),vec4(-0.14006352424621582,-0.1320587694644928,-0.13583102822303772,0.0),vec4(-0.15564791858196259,-0.13817709684371948,-0.13443511724472046,0.0),vec4(-0.1730218380689621,-0.14726833999156952,-0.15317246317863464,0.0)) * bufB[5] + mat4(vec4(-0.08235582709312439,-0.11641546338796616,-0.123295359313488,0.0),vec4(-0.14577260613441467,-0.12831681966781616,-0.1235114112496376,0.0),vec4(-0.15553538501262665,-0.1975865215063095,-0.13479921221733093,0.0),vec4(0.054225195199251175,0.01446837093681097,-0.006093200296163559,0.0)) * bufB[6] + mat4(vec4(-0.14855040609836578,-0.12536247074604034,-0.11588329821825027,0.0),vec4(0.06269770115613937,-0.009163320064544678,-0.07521555572748184,0.0),vec4(-0.2914826571941376,-0.2470710724592209,-0.22428099811077118,0.0),vec4(-0.1398264616727829,-0.034530140459537506,-0.01965736597776413,0.0)) * bufB[7];\nreturn vec4((1. / (1. + exp(-bufA[0]))).xyz, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouseNorm = (iMouse.xy / iResolution.xy) - vec2(0.5, 0.5);\n\n\n        uv.x *= iResolution.x / iResolution.y;\n        uv.x -= ((iResolution.x / iResolution.y) - 1.) /2.;\n\n\n    // Shifted to the form expected by the CPPN\n    uv = vec2(1., -1.) * 3. * (uv - vec2(0.5, 0.5));\n    // Output to screen\n    float t = iTime * .25;\n    float a = .8;\n    fragColor = cppn_fn(uv, a * sin(t), a * sin(2.*t), a * sin(3.*t), a* sin(4.*t));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsjXDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[73, 73, 148, 148, 58892], [58894, 58894, 58951, 59001, 59477]], "test": "valid"}
{"id": "NsjXRK", "name": "Noisy sphere tracing", "author": "anael", "description": "Trying a silly idea to reduce the number of marching steps with noise", "tags": ["raymarching", "random"], "likes": 3, "viewed": 58, "published": "Public", "date": "1620593546", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// --------------------------------------\n// oldschool rand() from Visual Studio\n// --------------------------------------\nint  seed = 1;\nvoid srand(int s ) { seed = s; }\nint  rand(void) { seed = seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\n\n// --------------------------------------\n// hash to initialize the random sequence (copied from Hugo Elias)\n// --------------------------------------\nint hash( int n )\n{\n\tn = (n << 13) ^ n;\n    return n * (n * n * 15731 + 789221) + 1376312589;\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//////////////////////////////////////////////////////////////////////////\n\n\nfloat sceneSDF(vec3 samplePoint)\n{\n    float t = 3.14 * 0.5;\n    \n    vec3 spherePos = vec3(cos(t), 0.0, sin(t));\n    vec3 torusPos  = vec3(spherePos.x, cos(t), spherePos.z);\n\n    float d = sdSphere(samplePoint + spherePos, 0.5);     \n\n    for (int i = -2; i <= 2; i++) {\n        d = min(d, sdTorus(\n            samplePoint + torusPos + vec3(0.0, float(i) * 1.0, 10.0),\n            vec2(2.0 + abs(float(i)) * 1.0, 0.3)\n            ));\n    }\n        \n    return d;\n}\n\nbool marching_random(out int stepc, vec3 eye, vec3 dir)\n{\n    float noise_range = (1.1 + cos(float(iFrame) * 0.02)) * 0.008;\n\n    int i, count = 0;\n    float depth = 0.0;\n    vec3 p = eye;\n\n    for (i = 0; i < 64; i++) {\n\n        float dist = sceneSDF(p) + depth * noise_range * 0.5;\n        float randf = float(rand()) / 32767.0 * depth * noise_range;\n        \n        if (dist < randf) {\n            count++;\n            stepc = count;\n            return true;\n        }\n\n        float rdist = dist * (1.0 + randf);\n\n        p += dir * rdist;\n        depth += rdist;\n\n        count++;\n\n        if (depth > 1000.0)\n            break;\n    }\n\n    stepc = count;\n    return false;\n}\n\n// from https://www.shadertoy.com/view/WdVyDW\nvec3 ShadeSteps(int n)\n{\n    const vec3 a = vec3(97, 130, 234) / vec3(255.0);\n    const vec3 b = vec3(220, 94, 75) / vec3(255.0);\n    const vec3 c = vec3(221, 220, 219) / vec3(255.0);\n    float t = float(n) * 0.025;   \n    if (t < 0.5)\n        return mix(a, c, 2.0 * t);\n    else\n        return mix(c, b, 2.0 * t - 1.0);\n}\n\nvec3 rayDir(float fov, vec2 resolution, vec2 fragCoord) {\n    vec2 xy = fragCoord - resolution / 2.0;\n    float z = resolution.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool hit;\n    int stepc;\n    \n    ivec2 q = ivec2(fragCoord);\n    srand(hash(q.x+hash(q.y)));\n\n\tvec3 dir = rayDir(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 0.0, 5.0);\n    \n    hit = marching_random(stepc, eye, dir);\n    \n    fragColor = vec4(ShadeSteps(stepc), 1.0);\n\n    //if (hit)\n      //  fragColor = vec4(0.0, 1.0, 0.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsjXRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[139, 139, 159, 159, 171], [172, 172, 189, 189, 246], [248, 399, 418, 418, 494], [648, 648, 683, 683, 707], [709, 709, 742, 742, 807], [885, 885, 919, 919, 1350], [1352, 1352, 1409, 1409, 2032], [2034, 2080, 2104, 2104, 2402], [2404, 2404, 2461, 2461, 2597], [2599, 2599, 2656, 2656, 3010]], "test": "valid"}
{"id": "NsjXRy", "name": "test of ray marching ", "author": "dcyang", "description": "learn from: https://michaelwalczyk.com/blog-ray-marching.html", "tags": ["raymarching"], "likes": 1, "viewed": 38, "published": "Public", "date": "1620494562", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float distance_from_sphere(in vec3 p, in vec3 c, float r)\n{\n    return length(p - c) - r;\n}\n\nfloat map_the_world(in vec3 p)\n{\n    float par = (5.0*iTime);\n    float displacement = sin(5.0 * p.x + par) * sin(5.0 * p.y+ par) * sin(5.0 * p.z+ par) * 0.25;\n    float sphere_0 = distance_from_sphere(p, vec3(0.0),1.0);\n\n    return sphere_0 + displacement;\n}\n\nvec3 calculate_normal(in vec3 p)\n{\n    const vec3 small_step = vec3(0.001, 0.0, 0.0);\n\n    float gradient_x = map_the_world(p + small_step.xyy) - map_the_world(p - small_step.xyy);\n    float gradient_y = map_the_world(p + small_step.yxy) - map_the_world(p - small_step.yxy);\n    float gradient_z = map_the_world(p + small_step.yyx) - map_the_world(p - small_step.yyx);\n\n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n\n    return normalize(normal);\n}\n\nvec3 ray_march(in vec3 ro, in vec3 rd)\n{\n    float total_distance_traveled = 0.0;\n    const int NUMBER_OF_STEPS = 20;\n    const float MINIMUM_HIT_DISTANCE = 0.001;\n    const float MAXIMUM_TRACE_DISTANCE = 1000.0;\n\n    for (int i = 0; i < NUMBER_OF_STEPS; ++i)\n    {\n        vec3 current_position = ro + total_distance_traveled * rd;\n\n        float distance_to_closest = map_the_world(current_position);\n\n        if (distance_to_closest < MINIMUM_HIT_DISTANCE) \n        {\n            vec3 normal = calculate_normal(current_position);\n            vec3 light_position = vec3(2.0, -5.0, 3.0);\n            vec3 direction_to_light = normalize(current_position - light_position);\n\n            float diffuse_intensity = max(0.0, dot(normal, direction_to_light));\n\n            return vec3(0.55, 0.7, 0.2) * diffuse_intensity;\n        }\n\n        if (total_distance_traveled > MAXIMUM_TRACE_DISTANCE)\n        {\n            break;\n        }\n        total_distance_traveled += distance_to_closest;\n    }\n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv = uv*2.0 - 1.0;\n    \n    vec3 camera_position = vec3(0.0, 0.0, -5.0);\n    vec3 ro = camera_position;\n    vec3 rd = vec3(uv, 1.0);\n\n    vec3 shaded_color = ray_march(ro, rd); \n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(shaded_color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsjXRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 59, 59, 91], [93, 93, 125, 125, 352], [354, 354, 388, 388, 816], [818, 818, 858, 858, 1832], [1834, 1834, 1891, 1941, 2326]], "test": "valid"}
{"id": "NsjXzK", "name": "Bosque poly-2d", "author": "jorge2017a1", "description": "Bosque poly-2d", "tags": ["2d", "draw", "poly", "bosquepoly2d", "polygono"], "likes": 2, "viewed": 136, "published": "Public API", "date": "1620587172", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//por jorge2017a1 ----jorgeFloresP---9/may/2021\n// referencia \n////-------------------\n/// IQ funciones....librerias\n//https://www.shadertoy.com/view/tlGBW3\n//Created by manu210404 in 2021-03-13\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n    \nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r; }\n\nvec3 ponerBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S(abs( distObj),0.0));\n  return colOut;\n}\n\nfloat opU(float d1, float d2) {return min(d1, d2); }\nconst vec3 colNegro=vec3(0.0);\nconst vec3 colGris=vec3(0.49,0.49,0.49);\nconst vec3 colGris2=vec3(0.6);\nconst vec3 colBlanco=vec3(1.0);\nconst vec3 colRojo=vec3(1.0,0.0,0.0);\nconst vec3 colAzul=vec3(0.0,0.0,1.0);\nconst vec3 colVerde=vec3(0.0,1.0,0.0);\nconst vec3 colVerde2=vec3(0.1,0.8,0.1);\nconst vec3 colrojoObs=vec3(0.45,0.13,0.15); //rojo obscuro\n\nconst vec3 col1=vec3(0.54,0.49,0.39);\nconst vec3 col2=vec3(0.06,0.07,1.0);\nconst vec3 col3=vec3(0.06,0.07,0.8);\n//const vec3 col4=vec3(0.45,0.13,0.15); //rojo obscuro\nconst vec3 col4=vec3(0.60,0.17,0.17); //vestido\nconst vec3 col5=vec3(0.73,0.60,0.55);\nconst vec3 colDorado=vec3(0.925,0.67,0.0);\n\n#define POLY(N) (in vec2 p, in vec2[N] v) {const int n=v.length();float d=dot(p-v[0],p-v[0]);float s=1.;for(int i=0,j=n-1;i<n;j=i,i++){vec2 e=v[j]-v[i];vec2 w=p-v[i];vec2 b=w-e*clamp(dot(w,e)/dot(e,e),0.,1.);d=min(d,dot(b,b));bvec3 cond=bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);if(all(cond)||all(not(cond))) s=-s;}return s*sqrt(d);}\n\n\nfloat sdPoly9 POLY(9)\nvec2 pt9[ 9]=vec2[](  \nvec2(.13,.01),vec2(.12,.19),vec2(.15,.28),vec2(.15,.20),vec2(.16,.13),\nvec2(.16,.07),vec2(.17,.03),vec2(.18,.01),vec2(.13,.01) );\n\nfloat sdPoly9b POLY(9)\nvec2 pt9b[ 9]=vec2[](  \nvec2(.29,.00),vec2(.30,.17),vec2(.29,.28),vec2(.26,.36),vec2(.32,.26),\nvec2(.35,.13),vec2(.35,.07),vec2(.36,.01),vec2(.29,.00) );\n\nfloat sdPoly12 POLY(12)\nvec2 pt12[ 12]=vec2[](  \nvec2(.47,.01),vec2(.47,.03),vec2(.50,.03),vec2(.52,.03),vec2(.57,.03),\nvec2(.58,.04),vec2(.62,.04),vec2(.65,.03),vec2(.68,.03),vec2(.69,.03),\nvec2(.70,.01),vec2(.47,.01) );\n\nfloat sdPoly14 POLY(14)\nvec2 pt14[ 14]=vec2[](  \nvec2(.57,.03),vec2(.56,.24),vec2(.52,.30),vec2(.53,.32),vec2(.56,.29),\nvec2(.59,.32),vec2(.61,.32),vec2(.60,.27),vec2(.62,.26),vec2(.67,.31),\nvec2(.67,.29),vec2(.62,.21),vec2(.62,.03),vec2(.57,.03) );\n\nfloat sdPoly11 POLY(11)\nvec2 pt11[ 11]=vec2[](  \nvec2(.52,.29),vec2(.47,.30),vec2(.42,.36),vec2(.38,.46),vec2(.43,.66),\nvec2(.56,.72),vec2(.72,.64),vec2(.79,.42),vec2(.75,.31),vec2(.66,.28),\nvec2(.52,.29) );\n\nfloat sdPoly10 POLY(10)\nvec2 pt10[ 10]=vec2[](  \nvec2(.00,.45),vec2(.99,.46),vec2(.83,.70),vec2(.77,.58),vec2(.52,.90),\nvec2(.34,.64),vec2(.19,.83),vec2(.08,.56),vec2(.04,.62),vec2(.00,.45) );\n\n\nfloat sdPoly12b POLY(12)\nvec2 pt12b[ 12]=vec2[](  \nvec2(.83,.24),vec2(.77,.20),vec2(.69,.18),vec2(.66,.13),vec2(.70,.10),\nvec2(.82,.05),vec2(.93,.06),vec2(.99,.12),vec2(.98,.19),vec2(.92,.22),\nvec2(.86,.21),vec2(.83,.24) );\n\n\n//***------------****-----------****------------******-------\nvec3 Bosque1(in vec2 pp, vec3 col) \n{\n  vec2 p=pp,pr1=pp, pr2=pp;\n   pr1.x= opRep1D(pr1.x, 0.4 ); pr1.y-=0.04;\n   pr2.x= opRep1D(pr2.x, 0.7 ); pr2.y+=0.04;\n   \n   float sd9 = sdPoly9(pr1, pt9);\n   float sd9b = sdPoly9b(pr2, pt9b);\n   float sd12 = sdPoly12(p, pt12);\n   float sd14 = sdPoly14(p, pt14);\n   float sd11 = sdPoly11(p, pt11);\n   float sd10 = sdPoly10(p, pt10);\n   float sd10b = sdPoly10(p-vec2(0.5,0.2), pt10);\n   float sd10c = sdPoly10(p-vec2(-0.5,0.1), pt10);\n   float sd12b = sdPoly12b(p, pt12b);\n   float sdcielo=-p.y+0.68;\n   \n   vec3 colsky1=mix(colAzul,vec3(1.0),p.y*.75);\n   \n   col= ponerBorde(colsky1,col,sdcielo); //\n   col= ponerBorde(col4,col,sd10c); //montana\n   col= ponerBorde(col4,col,sd10b); //montana\n   col= ponerBorde(colrojoObs,col,sd10); //montana\n   col= ponerBorde(colAzul,col,sd12b);\n    col= ponerBorde(colVerde,col,sd9); //\n   col= ponerBorde(colVerde,col,sd9b);\n   col= ponerBorde(colVerde2,col,sd12);\n   col= ponerBorde(colVerde2,col,sd11); //arbol ramas\n   col= ponerBorde(colrojoObs,col,sd14); //tronco\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    float t=iTime*0.5;\n    vec2 p=uv*0.5-vec2(-0.5,-0.5);\n    vec3 col=vec3(0.15,0.6,0.3); //vec3(0.25);\n    float tt=mod(iTime,10.0);\n    p.x= opRep1D(p.x+tt, 3.0 );\n    col=Bosque1(p, col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsjXzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[304, 342, 378, 378, 423], [429, 429, 464, 464, 488], [490, 490, 550, 550, 674], [676, 676, 707, 707, 728], [3174, 3236, 3273, 3273, 4296], [4298, 4298, 4355, 4355, 4677]], "test": "valid"}
{"id": "NssSzn", "name": "smooth noise animation", "author": "RiceFields", "description": "test", "tags": ["noise", "animation"], "likes": 0, "viewed": 13, "published": "Public", "date": "1620552185", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand (float x) {\n    return fract(sin(x)*1e4);\n}\n\nfloat noise(float x) {\n  float i = floor(x);\n  float f = fract(x);\n  float u = f * f * (3.0 - 2.0 * f ); // cubic function for smoothstep\n  return mix(rand(i), rand(i + 1.0), u);\n}\n\nvec3 cog1(float a, float r) {\n    float f = smoothstep(-.5,1., cos(a*10.))*0.2+0.5;\n    return vec3(1.0f - smoothstep(f, f+0.02, r));\n}\n\nvec2 rotate2d(vec2 uv, float angle) {\n    mat2 mat = mat2(cos(angle), -sin(angle), sin(angle), cos(angle)); \n    return 0.5f + (mat*(uv-0.5f));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    \n    uv = rotate2d(uv, noise(uv.y + iTime)); // smmoth \n    \n    uv += (1.0f - noise(iTime))*0.2f; // smooth translation\n    \n    uv -= 0.5f;\n    \n    float r = length(uv)*cos(noise(uv.x + iTime))*5.0f; // smooth zoom\n    float a = atan(uv.y, uv.x);\n\n    vec3 col = cog1(a, r);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NssSzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 54], [56, 56, 78, 78, 236], [238, 238, 267, 267, 373], [375, 375, 412, 412, 520], [522, 522, 579, 579, 934]], "test": "valid"}
{"id": "NsSXWt", "name": "Streamer01", "author": "intrometa", "description": "streamer with lines which supports positive and negative slope", "tags": ["streamer"], "likes": 0, "viewed": 29, "published": "Public", "date": "1621246626", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define DEBUG 0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    uv.x *= ratio;\n    vec2 clickUV = iMouse.xy / iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n    \n    float k = 1.0;\n    float b = 0.0;\n    float b1 = b;\n    float kSign = 1.0;\n    float width = 0.1;\n    if (k < 0.0) kSign = -1.0;\n    float b2 = b1 - width * kSign;\n    \n    float leftBound = abs((1.0 - b2) / k);\n    float totalLength = 1.0 * ratio + leftBound;; // 这个域映射时，考虑 ratio.\n    if (k < 0.0) totalLength = 1.0 * ratio + leftBound + width * 2.0;\n\n    float speed = 1.0;\n    float driver = fract(iTime / speed);\n#if DEBUG == 1\n    driver += clickUV.x; \n#endif\n    float x = uv.x + leftBound - driver * totalLength;\n    if (k < 0.0) x = uv.x - driver * totalLength + width;\n    float y = uv.y;\n    float y1 = k * x + b1;\n    float y2 = k * x + b2;\n    if (kSign > 0.0 && y < y1 && y > y2 || kSign < 0.0 && y < y2 && y > y1) col = vec3(1.0);\n    else col = vec3(0.0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsSXWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[16, 16, 73, 123, 1193]], "test": "valid"}
{"id": "NsSXzy", "name": "Galaxy fractal", "author": "jarble", "description": "An edit of my \"Iridescent portals\" fractal.", "tags": ["fractal", "galaxy"], "likes": 2, "viewed": 165, "published": "Public API", "date": "1620447601", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//change this variable to change the pattern\n#define pattern vec4(0,0.0,0.8,.5)\n\n#define ITERS 12\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col=vec3(0.0),col_prev=vec3(0.0);\n    float t=0.0;\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/20.0;\n    uv.y += (iTime)/25.0;\n    for(int c=0;c<ITERS;c++){\n        float scale = 2.16;\n        float scale1 = 1.16;\n        col_prev = col;\n        \n        for(int i=0;i<ITERS;i++)\n        {\n            float uv1 = uv.x-uv.y;\n            uv= fract(pattern.z-uv-(((vec2(uv1+pattern.x*col.x,-pattern.y-uv1))/(scale1*scale*scale))))/scale1;\n            uv.x *= scale1;\n            uv = fract(pattern.z+uv.yx);\n            uv.y /= -scale1;\n            uv -= fract(pattern.w+(uv.x-uv.y)/4.0);\n        }\n        col[2] = abs(fract(uv.y)-fract(uv.x));\n        col = ((col+col_prev.yzx))/2.125;\n\t}\n    fragColor = vec4(vec3(col*3.0),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsSXzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[98, 98, 155, 155, 944]], "test": "valid"}
{"id": "Ntf3DN", "name": "float logger", "author": "4eckme", "description": "IT DISPLAY APPROXIMATE VALS\n\nTo use logger u need copy&paste:\n1) const DS\n2) funcs DOT, DRAW, LOG\n\nUse:\nLOG(3.14, 0, fragColor, fragCoord);\nLOG(2.71828, 1, fragColor, fragCoord);\nLOG(4.20, 2, fragColor, fragCoord);\nLOG(1000000.0, 4, fragColor, fragCoord);", "tags": ["glsl", "numbers", "float", "log", "console", "logger", "logging"], "likes": 3, "viewed": 79, "published": "Public", "date": "1622064576", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// DOT SIZE\nconst int DS=3;\n// DRAW DOT\nbool DOT(int x, int y, ivec2 p)\n{\n    return x==int(p.x) && y==int(p.y);\n}\n// DRAW NUM\nbool DRAW(int i, int sx, int sy, ivec2 p){\n\n    //ivec2 p = ivec2(fragCoord)/DS;\n    \n    if (i==0) return//Num 0\n    DOT(sx+1,sy+1,p)||\n    DOT(sx+2,sy+1,p)||\n    DOT(sx+3,sy+1,p)||\n    DOT(sx+1,sy+5,p)||\n    DOT(sx+2,sy+5,p)||\n    DOT(sx+3,sy+5,p)||\n    DOT(sx+1,sy+2,p)||\n    DOT(sx+1,sy+3,p)||\n    DOT(sx+1,sy+4,p)||\n    DOT(sx+3,sy+2,p)||\n    DOT(sx+3,sy+3,p)||\n    DOT(sx+3,sy+4,p)\n    ;\n\n    if (i==1) return//Num 1\n    DOT(sx+1,sy+1,p)||\n    DOT(sx+2,sy+1,p)||\n    DOT(sx+3,sy+1,p)||\n    DOT(sx+2,sy+2,p)||\n    DOT(sx+2,sy+3,p)||\n    DOT(sx+2,sy+4,p)||\n    DOT(sx+2,sy+5,p)||\n    DOT(sx+1,sy+4,p)\n    ;\n    \n    if (i==2) return//Num 2\n    DOT(sx+1,sy+1,p)||\n    DOT(sx+2,sy+1,p)||\n    DOT(sx+3,sy+1,p)||\n    DOT(sx+1,sy+2,p)||\n    DOT(sx+1,sy+3,p)||\n    DOT(sx+2,sy+3,p)||\n    DOT(sx+3,sy+3,p)||\n    DOT(sx+3,sy+4,p)||\n    DOT(sx+3,sy+5,p)||\n    DOT(sx+1,sy+5,p)||\n    DOT(sx+2,sy+5,p)\n    ;\n    \n    if (i==3) return//Num 3\n    DOT(sx+1,sy+1,p)||\n    DOT(sx+2,sy+1,p)||\n    DOT(sx+3,sy+1,p)||\n    DOT(sx+1,sy+5,p)||\n    DOT(sx+2,sy+5,p)||\n    DOT(sx+3,sy+5,p)||\n    DOT(sx+1,sy+3,p)||\n    DOT(sx+3,sy+2,p)||\n    DOT(sx+3,sy+3,p)||\n    DOT(sx+3,sy+4,p)||\n    DOT(sx+2,sy+3,p)\n    ;\n    \n    if (i==4) return//Num 4\n    DOT(sx+3,sy+1,p)||\n    DOT(sx+1,sy+5,p)||\n    DOT(sx+3,sy+5,p)||\n    DOT(sx+1,sy+3,p)||\n    DOT(sx+1,sy+4,p)||\n    DOT(sx+3,sy+2,p)||\n    DOT(sx+3,sy+3,p)||\n    DOT(sx+3,sy+4,p)||\n    DOT(sx+2,sy+3,p)\n    ;   \n\n    if (i==5) return//Num 5\n    DOT(sx+3,sy+1,p)||\n    DOT(sx+2,sy+1,p)||\n    DOT(sx+1,sy+1,p)||\n    DOT(sx+3,sy+2,p)||\n    DOT(sx+3,sy+3,p)||\n    DOT(sx+2,sy+3,p)||\n    DOT(sx+1,sy+3,p)||\n    DOT(sx+1,sy+4,p)||\n    DOT(sx+1,sy+5,p)||\n    DOT(sx+3,sy+5,p)||\n    DOT(sx+2,sy+5,p)\n    ;\n\n    if (i==6) return//Num 6\n    DOT(sx+3,sy+1,p)||\n    DOT(sx+2,sy+1,p)||\n    DOT(sx+1,sy+1,p)||\n    DOT(sx+3,sy+2,p)||\n    DOT(sx+3,sy+3,p)||\n    DOT(sx+2,sy+3,p)||\n    DOT(sx+1,sy+3,p)||\n    DOT(sx+1,sy+4,p)||\n    DOT(sx+1,sy+5,p)||\n    DOT(sx+3,sy+5,p)||\n    DOT(sx+2,sy+5,p)||\n    DOT(sx+1,sy+2,p)\n    ;\n    \n    if (i==7) return//Num 7\n    DOT(sx+3,sy+1,p)||\n    DOT(sx+3,sy+3,p)||\n    DOT(sx+3,sy+2,p)||\n    DOT(sx+3,sy+4,p)||\n    DOT(sx+2,sy+5,p)||\n    DOT(sx+1,sy+5,p)||\n    DOT(sx+3,sy+5,p)\n    ;\n\n    if (i==8) return//Num 8\n    DOT(sx+1,sy+1,p)||\n    DOT(sx+2,sy+1,p)||\n    DOT(sx+3,sy+1,p)||\n    DOT(sx+1,sy+5,p)||\n    DOT(sx+2,sy+5,p)||\n    DOT(sx+3,sy+5,p)||\n    DOT(sx+1,sy+2,p)||\n    DOT(sx+1,sy+3,p)||\n    DOT(sx+1,sy+4,p)||\n    DOT(sx+3,sy+2,p)||\n    DOT(sx+3,sy+3,p)||\n    DOT(sx+3,sy+4,p)||\n    DOT(sx+2,sy+3,p)\n    ;\n\n    if (i==9) return//Num 9\n    DOT(sx+1,sy+1,p)||\n    DOT(sx+2,sy+1,p)||\n    DOT(sx+3,sy+1,p)||\n    DOT(sx+1,sy+5,p)||\n    DOT(sx+2,sy+5,p)||\n    DOT(sx+3,sy+5,p)||\n    DOT(sx+1,sy+3,p)||\n    DOT(sx+1,sy+4,p)||\n    DOT(sx+3,sy+2,p)||\n    DOT(sx+3,sy+3,p)||\n    DOT(sx+3,sy+4,p)||\n    DOT(sx+2,sy+3,p)\n    ;\n    \n    if (i==10) return//Num A\n    DOT(sx+1,sy+1,p)||\n    DOT(sx+2,sy+3,p)||\n    DOT(sx+3,sy+1,p)||\n    DOT(sx+2,sy+5,p)||\n    DOT(sx+1,sy+2,p)||\n    DOT(sx+1,sy+3,p)||\n    DOT(sx+1,sy+4,p)||\n    DOT(sx+3,sy+2,p)||\n    DOT(sx+3,sy+3,p)||\n    DOT(sx+3,sy+4,p)\n    ;\n    \n    \n    if (i==11) return//Num B\n    DOT(sx+1,sy+1,p)||\n    DOT(sx+2,sy+1,p)||\n    DOT(sx+3,sy+1,p)||\n    DOT(sx+1,sy+5,p)||\n    DOT(sx+2,sy+5,p)||\n    DOT(sx+3,sy+5,p)||\n    DOT(sx+1,sy+2,p)||\n    DOT(sx+1,sy+3,p)||\n    DOT(sx+1,sy+4,p)||\n    DOT(sx+3,sy+2,p)||\n    DOT(sx+3,sy+4,p)||\n    DOT(sx+2,sy+3,p)\n    ;\n    \n    if (i==12) return//Num C\n    DOT(sx+2,sy+1,p)||\n    DOT(sx+3,sy+1,p)||\n    DOT(sx+2,sy+5,p)||\n    DOT(sx+3,sy+5,p)||\n    DOT(sx+1,sy+2,p)||\n    DOT(sx+1,sy+3,p)||\n    DOT(sx+1,sy+4,p)\n    ;\n    \n    if (i==13) return//Num D\n    DOT(sx+1,sy+1,p)||\n    DOT(sx+2,sy+1,p)||\n    DOT(sx+1,sy+5,p)||\n    DOT(sx+2,sy+5,p)||\n    DOT(sx+1,sy+2,p)||\n    DOT(sx+1,sy+3,p)||\n    DOT(sx+1,sy+4,p)||\n    DOT(sx+3,sy+2,p)||\n    DOT(sx+3,sy+3,p)||\n    DOT(sx+3,sy+4,p)\n    ;\n    \n    if (i==14) return//Num E\n    DOT(sx+3,sy+1,p)||\n    DOT(sx+2,sy+1,p)||\n    DOT(sx+1,sy+1,p)||\n    DOT(sx+3,sy+5,p)||\n    DOT(sx+2,sy+5,p)||\n    DOT(sx+1,sy+5,p)||\n    DOT(sx+3,sy+3,p)||\n    DOT(sx+1,sy+2,p)||\n    DOT(sx+1,sy+3,p)||\n    DOT(sx+1,sy+4,p)||\n    DOT(sx+2,sy+3,p)\n    ;\n    \n    if (i==15) return//Num F\n    DOT(sx+1,sy+1,p)||\n    DOT(sx+3,sy+5,p)||\n    DOT(sx+2,sy+5,p)||\n    DOT(sx+1,sy+5,p)||\n    DOT(sx+3,sy+3,p)||\n    DOT(sx+1,sy+2,p)||\n    DOT(sx+1,sy+3,p)||\n    DOT(sx+1,sy+4,p)||\n    DOT(sx+2,sy+3,p)\n    ;\n    return false;\n}\n//LOG FLOAT VALUE\nvec4 LOG(float n, bool flt, int sys, int str, vec4 fragColor, vec2 fragCoord) {\n    // fps speed up\n    ivec2 p = ivec2(fragCoord)/DS;\n    if(p.y<(2+6*(str+1))&&p.y>=(2+6*(str))&&p.x<=(4*45)) \n    {\n        vec4 res = fragColor;\n        vec4 res0 = 1.0-fragColor;//out color\n        \n        str=str*6;\n        int pos = 1; float num = 0.0; float m; int s=-1;\n\n        //draw first minus of float n\n        if (n < 0.0) {\n            n = abs(n);\n            if(DOT(2, str+4, p)) res=res0;\n            if(DOT(3, str+4, p)) res=res0;\n            pos+=3;\n        }\n\n        //length before dot of float n\n        int k=1;\n        for (int i=1;i<=38&&n/pow(float(sys), float(i))>=1.0;i++) {\n            k=i+1;\n        }\n\n        //draw float n before dot\n        for(int j = k; j>=1; j--) {\n            m=pow(float(sys),float(j));\n            num = mod(n, m)*float(sys)/m;\n            if(int(floor(num))>=0)\n            {\n                if (num>=0.0) {\n                    if (DRAW(int(floor(num)), pos, str+1, p)) {\n                        res=res0; //color invert\n                    } pos+=4;\n                }\n\n            }\n        }\n        \n        if (flt) {\n\n            // draw dot\n            if (DOT(pos+1, str+2, p))\n                res=res0;//color invert\n\n            //length after dot of float n\n            float nn=mod(n, 1.0); k=0;\n            for (int i=1;i<=38&&mod(nn*pow(float(sys), float(i)),1.0)!=0.0;i++) {\n                    k=i;\n            } n = nn*pow(float(sys), float(k));\n\n            // draw float n after dot\n            pos = pos+2;\n            for(int j = k; j>=0; j--) {\n                m=pow(float(sys),float(j));\n                num = mod(n, m)*float(sys)/m;\n                if(int(floor(num))>=0)\n                {\n                    if (num>=0.0) {\n                        if (DRAW(int(floor(num)), pos, str+1, p)) {\n                            res=res0;//color invert\n                        } pos+=4;\n                    }\n\n\n                }\n            }\n        }\n\n        return res; //color invert\n    }\n    else {\n        return fragColor;\n    }\n}\nvec4 LOG(float n, int str, vec4 fragColor, vec2 fragCoord) {\n    return LOG(n, true, 10, str, fragColor, fragCoord);\n}\n\nvec4 LOG(int n, int sys, int str, vec4 fragColor, vec2 fragCoord) {\n    return LOG(float(n), false, sys, str, fragColor, fragCoord);\n}\nvec4 LOG(int n, int str, vec4 fragColor, vec2 fragCoord) {\n    return LOG(float(n), false, 10, str, fragColor, fragCoord);\n}\n\n// START\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n    // Mouse: Normalized pixel coordinates (from 0 to 1)\n    vec2 uvm = iMouse.xy/iResolution.xy;\n    // Mouse: Time varying pixel color\n    vec3 colm = 0.5 + 0.5*cos(iTime+uvm.xyx+vec3(0,2,4));\n    // Mouse: Output to buffer\n    vec4 mouseColor = vec4(colm,1.0);\n    \n    // Logging. Int val for string number, started from bottom\n    fragColor = LOG(mouseColor.z, 0, fragColor, fragCoord);\n    fragColor = LOG(mouseColor.y, 1, fragColor, fragCoord);\n    fragColor = LOG(mouseColor.x, 2, fragColor, fragCoord);\n    \n    fragColor = LOG(-int(iMouse.y), 4, fragColor, fragCoord);\n    fragColor = LOG(-int(iMouse.x), 5, fragColor, fragCoord);\n    \n    fragColor = LOG(0xFF1234, 16, 7, fragColor, fragCoord);\n    fragColor = LOG(16, 2, 8, fragColor, fragCoord);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ntf3DN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 40, 73, 73, 114], [115, 127, 169, 207, 4608], [4609, 4627, 4706, 4726, 6724], [6725, 6725, 6785, 6785, 6843], [6845, 6845, 6912, 6912, 6979], [6980, 6980, 7038, 7038, 7104], [7106, 7115, 7172, 7222, 8171]], "test": "valid"}
{"id": "Ntf3Dr", "name": "less then 3min", "author": "gyabo", "description": "livecoding test with REC.\n", "tags": ["raymarching"], "likes": 0, "viewed": 45, "published": "Public", "date": "1621864163", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime\n\nfloat map(vec3 p) {\n    return length(mod(p, 2.0) - 1.0) - 0.5;\n}\n\nvec3 getnor(vec3 p) {\n    float t = map(p);\n    vec2 d = vec2(0.001, 0.0);\n    return normalize(vec3(\n        t - map(p + d.xyy),\n        t - map(p + d.yxy),\n        t - map(p + d.yyx)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 dir = normalize(vec3(uv, 1.0));\n    vec3 pos = vec3(0, 0, iTime);\n    float t = 0.0;\n    for(int i = 0 ; i < 100; i++) {\n        t+= map(t * dir + pos);\n    }\n    vec3 ip = t * dir + pos;\n    vec3 N = getnor(ip);\n    vec3 L = normalize(vec3(1,2,3));\n    float D = max(0.01, dot(N, L));\n    \n    vec3 col = vec3(t * 0.1) * D * N + t * 0.1;\n\n    // Output to screen\n    fragColor = vec4(vec3(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ntf3Dr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 39, 39, 85], [87, 87, 108, 108, 276], [279, 279, 336, 386, 884]], "test": "valid"}
{"id": "NtfGWN", "name": "Sky raymarching", "author": "lisyarus", "description": "Single-scattering visualization of sky including Rayleigh & Mie scattering and ozone absorbtion", "tags": ["raymarching", "sky", "scattering"], "likes": 8, "viewed": 384, "published": "Public", "date": "1622057162", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// View settings\n\nconst float CAMERA_HEIGHT = 10000.0; // meters\nconst int INTEGRATION_STEPS = 8;\n\n// Constants\n\nconst float PI = 3.141592653589793;\nconst float INF = 1e10;//1.0 / 0.0;\n\nconst vec2 EMPTY_INTERVAL = vec2(INF, -INF); // interval [a,b] represented as vec2(a, b)\n\nconst float EARTH_RADIUS = 6400000.0; // meters\nconst float ATMOSPHERE_HEIGHT = 100000.0; // meters\n\nconst vec3 SUN_EMISSION = vec3(1.0);\nconst vec3 EARTH_COLOR = vec3(0.15, 0.025, 0.0);\n\n// Scattering & absorption settings (try to set some to zero to see how important each of them is)\n\nconst vec3 RAYLEIGH_SCATTERING = vec3(5.802, 13.558, 33.1) * 1e-6;\nconst vec3 RAYLEIGH_EXTINSION = RAYLEIGH_SCATTERING;\n\nconst vec3 MIE_ABSOPTION = vec3(4.4) * 1e-6;\nconst vec3 MIE_SCATTERING = vec3(2.1) * 1e-6;\nconst vec3 MIE_EXTINSION = MIE_ABSOPTION + MIE_SCATTERING;\n\nconst vec3 OZONE_ABSORPTION = vec3(0.650, 1.881, 0.085) * 1e-6;\nconst vec3 OZONE_EXTINSION = OZONE_ABSORPTION;\n\nfloat rayleigh_density(float height)\n{\n    return exp(- height / 7994.0);\n}\n\nfloat mie_density(float height)\n{\n    return exp(- height / 1200.0);\n}\n\nfloat ozone_density(float height)\n{\n    return max(0.0, 1.0 - abs(height - 25000.0) / 15000.0);\n}\n\nfloat rayleigh_phase(float c)\n{\n    return (1.0 + c * c) * (3.0 / 16.0 / PI);\n}\n\nfloat mie_phase(float c)\n{\n    float g = 0.76;\n    return (3.0 / 8.0 / PI) * (1.0 - g * g) * (1.0 + c * c) / (2.0 + g * g) / pow(1.0 + g * g - 2.0 * g * c, 1.5);\n}\n\n// Math helpers\n\nvec2 interval_intersection(vec2 i1, vec2 i2)\n{\n    return vec2(max(i1.x, i2.x), min(i1.y, i2.y));\n}\n\nbool empty(vec2 i)\n{\n    return i.x > i.y;\n}\n\nvec2 solve_quadratic(float a, float b, float c)\n{\n    float D = b * b - 4.0 * a * c;\n    if (D < 0.0)\n        return vec2(INF, INF);\n    D = sqrt(D);\n        \n    float x1, x2;\n    if (b >= 0.0)\n    {\n        x1 = (- b - D) / 2.0 / a;\n        x2 = 2.0 * c / (- b - D);\n    }\n    else\n    {\n        x1 = 2.0 * c / (- b + D);\n        x2 = (- b + D) / 2.0 / a;\n    }\n    \n    if (x1 < x2)\n        return vec2(x1, x2);\n    return vec2(x2, x1);\n}\n\n// Raycast\n \nvec2 sphere_raycast(vec3 ray_origin, vec3 ray_direction, float radius)\n{\n//    |o + td| = r\n//    o^2 + 2t do + t^2 d^2 = r^2\n    float a = 1.0;\n    float b = dot(ray_direction, ray_origin) * 2.0;\n    float c = dot(ray_origin, ray_origin) - radius * radius;\n        \n    vec2 t = solve_quadratic(a, b, c);        \n    if (t == vec2(INF, INF))\n        return EMPTY_INTERVAL;\n    return interval_intersection(t, vec2(0.0, INF));\n}\n\nvec2 atmosphere_raycast(vec3 ray_origin, vec3 ray_direction)\n{\n    vec2 i = sphere_raycast(ray_origin, ray_direction, EARTH_RADIUS + ATMOSPHERE_HEIGHT);\n    vec2 ip = sphere_raycast(ray_origin, ray_direction, EARTH_RADIUS);\n    if (!empty(ip))\n        i = interval_intersection(i, vec2(-INF, ip.x));\n    return i;\n}\n\n// Main raymarching\n\nvec3 transmittance(vec3 origin, vec3 direction, float tmax, int steps)\n{\n    vec3 log_result = vec3(0.0);\n    float dt = tmax / float(steps);\n    for (int i = 0; i < steps; ++i)\n    {\n        float t = (float(i) + 0.5) * dt;\n        vec3 p = origin + t * direction;\n        float h = length(p) - EARTH_RADIUS;\n        \n        log_result += RAYLEIGH_EXTINSION * rayleigh_density(h) * dt;\n        log_result += MIE_EXTINSION * mie_density(h) * dt;\n        log_result += OZONE_EXTINSION * ozone_density(h) * dt;\n    }\n    return exp(- log_result);\n}\n\nvec3 sky_color(vec3 ray_origin, vec3 ray_direction, vec3 sun_direction, int steps)\n{\n    vec3 background = vec3(0.0);\n    \n    vec2 interval = sphere_raycast(ray_origin, ray_direction, EARTH_RADIUS + ATMOSPHERE_HEIGHT);\n    \n    vec2 pinterval = sphere_raycast(ray_origin, ray_direction, EARTH_RADIUS);\n    \n    if (!empty(pinterval))\n    {\n        vec3 n = normalize(ray_origin + ray_direction * pinterval.x);\n    \n        background = EARTH_COLOR * max(0.0, dot(n, sun_direction));\n        interval = interval_intersection(interval, vec2(-INF, pinterval.x));\n    }\n    \n    if (empty(interval))\n        return background;\n        \n    vec3 result = vec3(0.0);\n\n    vec3 tcoeff = vec3(0.0);\n    \n    float dt = (interval.y - interval.x) / float(steps);\n    for (int i = 0; i < steps; ++i)\n    {\n        float t = (float(i) + 0.5) * dt + interval.x;\n        vec3 p = ray_origin + t * ray_direction;\n        float h = length(p) - EARTH_RADIUS;\n        \n        // Instead of calling transmittance(p, -ray_direction, t, steps) to\n        // compute how much scattered light actually reachs the camera (as opposed\n        // to being absorbed or scattered again), we make use of the raymarching\n        // and compute transmittance on the go. The actuall transmittance factor\n        // is exp(-tcoeff) * dt\n        \n        tcoeff += RAYLEIGH_EXTINSION * rayleigh_density(h) * dt;\n        tcoeff += MIE_EXTINSION * mie_density(h) * dt;\n        tcoeff += OZONE_EXTINSION * ozone_density(h) * dt;\n        \n        vec2 it = sphere_raycast(p, sun_direction, EARTH_RADIUS);\n        \n        vec3 emitter = vec3(0.0);\n        if (!empty(it))\n            emitter = EARTH_COLOR;\n        else\n        {\n            it = sphere_raycast(p, sun_direction, EARTH_RADIUS + ATMOSPHERE_HEIGHT);\n        \n            if (!empty(it))\n                emitter = SUN_EMISSION;\n        }\n            \n        vec3 incoming = transmittance(p + it.x * sun_direction, sun_direction, it.y - it.x, steps) * SUN_EMISSION;\n        \n        float c = dot(-sun_direction, -ray_direction);\n        \n        vec3 scatter = vec3(0.0);\n        scatter += RAYLEIGH_SCATTERING * rayleigh_phase(c);\n        scatter += MIE_SCATTERING * mie_phase(c);\n        \n        result += incoming * scatter * exp(-tcoeff) * dt;\n    }\n    \n    result += background * exp(-tcoeff);\n\n    return result;\n}\n\nvec3 tone_map(vec3 color)\n{\n    return pow(color / (vec3(1.0) + color), vec3(1.0 / 2.2));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n    float time = iTime + 12.0; // in hours\n\n    vec3 sun_direction = vec3(sin(time / 12.0 * PI), 0.0, -cos(time / 12.0 * PI));\n    \n    vec3 camera_position = vec3(0.0, 0.0, EARTH_RADIUS + CAMERA_HEIGHT);\n    \n    vec2 uv = fragCoord/iResolution.xy;\n        \n    vec2 m = iMouse.xy / iResolution.xy - vec2(0.5);    \n    m *= PI;\n    \n    vec3 view_direction;\n    \n    uv.x = uv.x * 2.0 * PI;\n    uv.y = (uv.y - 0.5) * PI;\n\n    //uv -= m * vec2(2.0 * PI, PI);\n\n    vec3 x = vec3(1.0, 0.0, 0.0);\n    vec3 y = vec3(0.0, 1.0, 0.0);\n    vec3 z = vec3(0.0, 0.0, 1.0);\n    \n    if (iMouse.xy != vec2(0.0, 0.0))\n    {\n        x = x * cos(m.y) + z * sin(m.y);\n        z = cross(x, y);\n\n        x = x * cos(m.x) - y * sin(m.x);\n        y = cross(z, x);\n    }\n\n    // uv.y = max(-PI/2.0, min(PI/2.0, uv.y));\n\n    view_direction =\n        x * cos(uv.x) * cos(uv.y) +\n        y * sin(uv.x) * cos(uv.y) +\n        z * sin(uv.y);\n            \n    vec3 color = sky_color(camera_position, view_direction, sun_direction, INTEGRATION_STEPS);\n        \n    fragColor = vec4(tone_map(color), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtfGWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[948, 948, 986, 986, 1023], [1025, 1025, 1058, 1058, 1095], [1097, 1097, 1132, 1132, 1194], [1196, 1196, 1227, 1227, 1275], [1277, 1277, 1303, 1303, 1440], [1459, 1459, 1505, 1505, 1558], [1560, 1560, 1580, 1580, 1604], [1606, 1606, 1655, 1655, 2047], [2062, 2062, 2134, 2187, 2490], [2492, 2492, 2554, 2554, 2807], [5731, 5731, 5758, 5758, 5822], [5824, 5824, 5879, 5879, 6960]], "test": "valid"}
{"id": "NtfGz4", "name": "not even 60fps", "author": "ShaderMan473", "description": "Extra stuff", "tags": ["funny"], "likes": 1, "viewed": 29, "published": "Public", "date": "1621580212", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Time varying pixel color\n    vec3 col = 0.75 + 0.25*tan(iTime+uv.xyx*vec3(2,4,3))+-0.3;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtfGz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 106, 304]], "test": "valid"}
{"id": "Ntl3zB", "name": "Monjori Eyes", "author": "makc", "description": "A quick tweak of https://www.shadertoy.com/view/lsfyRS", "tags": ["procedural"], "likes": 7, "viewed": 123, "published": "Public", "date": "1622334582", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// See https://www.shadertoy.com/view/lsfyRS fo the credits\n\n// I always wanted to try this since I did it in photoshop many years ago:\n// https://cdn.discordapp.com/attachments/685241247233081381/848338683764408340/no.jpg\n\nfloat a( float x )\n{\n    // \"smooth\" version of abs(x)\n    return sqrt( x * x + 0.02 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (3.4 * fragCoord.xy / iResolution.xy) - 1.7;\n    \n    // flip y vertically\n    p.y *= -1.0;\n\n    // tilt it a bit (-0.3 for \"sad\" look :)\n    p.y += 0.3 * a(p.x);\n    \n    // scale a bit\n    p.y *= 0.7;\n\n    // mirror x to make 2 eyes\n    p.x = a(p.x) - 1.0;\n\n    // a = the time speed up by 40\n    // The 5.0 is to keep ShaderToy at the same speed of the original\n    float a = (iTime*5.0) * 40.0;\n\n    // declare a bunch of variables.\n    float d,e,f,g=1.0/40.0,h,i,r,q;\n\n    // e goes from 0 to 400 across the screen\n    //   = 400 * [(p.x*0.5) + 0.5 ]\n    //   = 400 * 0.5 * (p.x + 1)\n    //   = 200 * p.x + 200\n    // But p.x ranges from -1 to +1\n    // e = 0 to 400\n    e = 400.0*(p.x*0.5+0.5);\n\n    // f goes from 0 to 400 down the screen\n    f = 400.0*(p.y*0.5+0.5);\n\n    // e and f could be simplified as:\n    //vec2 ef = 200.0 * (p + 1.0);\n    \n    // i goes from 200 + or - 20 based\n    // on the sin of e * 1/40th + the slowed down time / 150\n    // or in other words slow down even more.\n    // e * 1/40 means e goes from 0 to 1\n    i = 200.0+sin(e*g+a/150.0)*20.0;\n    \n    // d is 200 + or - 18.0 + or - 7\n    // the first +/- is cos of 0.0 to 0.5 down the screen\n    // the second +/i is cos of 0.0 to 1.0 across the screen\n    d = 200.0+cos(f*g/2.0)*18.0+cos(e*g)*7.0;\n\n    // I'm stopping here. You can probably figure out the rest\n    // see answer\n//  r=sqrt(pow(i-e,2.0)+pow(d-f,2.0));\n    r = length( vec2( i-e, d-f ) );\n    q = f/r;\n\n    e = (r*cos(q))-a/2.0;\n    f = (r*sin(q))-a/2.0;\n    d = sin(e*g)*176.0 + sin(e*g)*164.0 + r;\n\n    h = ((f+d)+a/2.0)*g;\n    i = cos(h+r*p.x/1.3)*(e+e+a) + cos(q*g*6.0)*(r+h/3.0);\n\n    h = sin(f*g)*144.0-sin(e*g)*212.0*p.x;\n    h = (h+(f-e)*q+sin(r-(a+h)/7.0)*10.0+i/4.0)*g;\n\n//  i += cos(h*2.3*sin(a/350.0-q)) * 184.0*sin(q-(r*4.3+a/12.0)*g) + tan(r*g+h)*184.0*cos(r*g+h);\n    i += cos(h*2.3*sin(a/350.0-q)) * 184.0*sin(q-(r*4.3+a/12.0)*g) + sin(r*g+h)*184.0;\n\n    // Split into 4 segments\n    i  = mod(i/5.6,256.0)/64.0;\n\n    if (i <  0.0) i += 4.0;\n    if (i >= 2.0) i  = 4.0-i;\n\n    d  = r/350.0;\n    d += sin(d*d*8.0)*0.52;\n\n    f = (sin(a*g)+1.0)/2.0;\n//  fragColor = vec4(vec3(f*i/1.6,i/2.0+d/13.0,i)*d*p.x+vec3(i/1.3+d/8.0,i/2.0+d/18.0,i)*d*(1.0-p.x),1.0);\n    fragColor = d * mix(\n        vec4( i/1.3+d/8., i/2.+d/18., i, 0) ,\n        vec4( f*i/1.6 ,   i/2.+d/13., i, 0) ,\n        p.x\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ntl3zB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[224, 224, 244, 278, 313], [315, 315, 372, 372, 2747]], "test": "valid"}
{"id": "NtlGRN", "name": "basic  excitebike", "author": "jorge2017a1", "description": "basic  excitebike", "tags": ["basicexcitebike"], "likes": 13, "viewed": 213, "published": "Public API", "date": "1621649647", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//por jorge2017a1 ----jorgeFloresP---21/may/2021\n// referencia \n////-------------------\n/// IQ funciones....librerias\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(antialiasing(0.5),b,d)\n\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n    \n\nvec3 ponerBorde2(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S(abs( distObj),0.0));\n  return colOut;\n}\n\n\nvec3 ponerBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj),0.0));\n  return colOut;\n}\n\nconst vec3 colNegro= vec3(0.0);\nconst vec3 col0= vec3(0.49,0.93,0.29);\nconst vec3 col1= vec3(1.00,0.67,0.31);\nconst vec3 col2= vec3(1.00,0.72,0.67);\nconst vec3 col3= vec3(0.47,0.54,0.00);\nconst vec3 col4= vec3(0.71,0.65,1.00);\nconst vec3 col5= vec3(0.49,0.93,0.29);\nconst vec3 col6= vec3(1.00,0.69,0.34);\nconst vec3 col7= vec3(1.00,0.70,0.47);\nconst vec3 col8= vec3(0.47,0.53,0.00);\nconst vec3 col9= vec3(0.73,0.61,0.15);\nconst vec3 col10= vec3(1.00,0.67,0.31);\nconst vec3 col11= vec3(1.00,0.1,0.1);\nconst vec3 col12= vec3(0.2,0.82,0.42);\n\nfloat opU(float d1, float d2) {return min(d1, d2); }\n\n#define POLY(N) (in vec2 p, in vec2[N] v) {const int n=v.length();float d=dot(p-v[0],p-v[0]);float s=1.;for(int i=0,j=n-1;i<n;j=i,i++){vec2 e=v[j]-v[i];vec2 w=p-v[i];vec2 b=w-e*clamp(dot(w,e)/dot(e,e),0.,1.);d=min(d,dot(b,b));bvec3 cond=bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);if(all(cond)||all(not(cond))) s=-s;}return s*sqrt(d);}\n\n\n\nfloat sdPolyc000 POLY(7)\nvec2 ptc000[ 7]=vec2[](  \nvec2(.019,.502),vec2(.050,.500),vec2(.048,.529),vec2(.045,.536),vec2(.025,.536),\nvec2(.017,.529),vec2(.019,.502) );\n\nfloat sdPolyc001 POLY(7)\nvec2 ptc001[ 7]=vec2[](  \nvec2(.081,.500),vec2(.113,.500),vec2(.111,.529),vec2(.105,.538),vec2(.088,.538),\nvec2(.080,.530),vec2(.081,.500) );\n\nfloat sdPolyc002 POLY(5)\nvec2 ptc002[ 5]=vec2[](  \nvec2(.000,.464),vec2(.997,.466),vec2(.997,.250),vec2(.000,.252),vec2(.000,.464) );\n\nfloat sdPolyc003 POLY(5)\nvec2 ptc003[ 5]=vec2[](  \nvec2(.000,.416),vec2(.991,.418),vec2(.989,.411),vec2(.000,.411),vec2(.000,.416) );\n\nfloat sdPolyc004 POLY(5)\nvec2 ptc004[ 5]=vec2[](  \nvec2(.003,.364),vec2(.991,.364),vec2(.991,.357),vec2(.003,.357),vec2(.003,.364) );\n\n\nfloat sdPolyc005 POLY(5)\nvec2 ptc005[ 5]=vec2[](  \nvec2(.003,.309),vec2(.991,.311),vec2(.991,.304),vec2(.003,.304),vec2(.003,.309) );\n\n\nfloat sdPolyc006 POLY(5)\nvec2 ptc006[ 5]=vec2[](  \nvec2(.000,.250),vec2(.995,.248),vec2(.997,.180),vec2(.000,.180),vec2(.000,.250) );\n\n\nfloat sdPolyc007 POLY(5)\nvec2 ptc007[ 5]=vec2[](  \nvec2(.000,.750),vec2(.994,.750),vec2(.995,.470),vec2(.000,.466),vec2(.000,.750) );\n\n\nfloat sdPolyc008 POLY(5)\nvec2 ptc008[ 5]=vec2[](  \nvec2(.000,.998),vec2(.998,.998),vec2(.995,.750),vec2(.000,.750),vec2(.000,.998) );\n\n\nfloat sdPolyc009 POLY(5)\nvec2 ptc009[ 5]=vec2[](  \nvec2(.000,.857),vec2(.994,.855),vec2(.992,.752),vec2(.000,.752),vec2(.000,.857) );\n\n\nfloat sdPolyc010 POLY(7)\nvec2 ptc010[ 7]=vec2[](  \nvec2(.453,.252),vec2(.516,.321),vec2(.522,.330),vec2(.542,.330),vec2(.547,.321),\nvec2(.609,.254),vec2(.453,.252) );\n\nfloat sdPolyc011 POLY(5)\nvec2 ptc011[ 5]=vec2[](  \nvec2(.455,.254),vec2(.453,.466),vec2(.520,.538),vec2(.519,.329),vec2(.455,.254) );\n\nfloat sdPolyc012 POLY(7)\nvec2 ptc012[ 7]=vec2[](  \nvec2(.550,.325),vec2(.547,.536),vec2(.552,.536),vec2(.614,.466),vec2(.614,.254),\nvec2(.609,.254),vec2(.550,.325) );\n\n\nfloat sdPolyc013 POLY(12)\nvec2 ptc013[ 12]=vec2[](  \nvec2(.517,.534),vec2(.525,.538),vec2(.528,.545),vec2(.541,.545),vec2(.544,.538),\nvec2(.547,.536),vec2(.550,.329),vec2(.547,.325),vec2(.541,.330),vec2(.525,.332),\nvec2(.519,.323),vec2(.517,.534) );\n\n\n\nfloat sdPolyc014 POLY(4)\nvec2 ptc014[ 4]=vec2[](  \nvec2(.477,.361),vec2(.538,.427),vec2(.538,.359),vec2(.477,.361) );\n\nfloat sdPolyc015 POLY(5)\nvec2 ptc015[ 5]=vec2[](  \nvec2(.473,.363),vec2(.475,.463),vec2(.536,.538),vec2(.538,.423),vec2(.473,.363) );\n\nfloat sdPolyc016 POLY(9)\nvec2 ptc016[ 9]=vec2[](  \nvec2(.244,.211),vec2(.238,.213),vec2(.238,.234),vec2(.242,.241),vec2(.270,.239),\nvec2(.277,.236),vec2(.275,.220),vec2(.270,.213),vec2(.244,.211) );\n\n\nfloat sdPolyc017 POLY(6)\nvec2 ptc017[ 6]=vec2[](  \nvec2(.450,.261),vec2(.447,.461),vec2(.569,.530),vec2(.572,.330),vec2(.569,.325),\nvec2(.450,.261) );\n\n\nfloat sdPolyc018 POLY(5)\nvec2 ptc018[ 5]=vec2[](  \nvec2(.445,.254),vec2(.569,.325),vec2(.573,.320),vec2(.456,.254),vec2(.445,.254) );\n\n\nfloat sdPolyc019 POLY(5)\nvec2 ptc019[ 5]=vec2[](  \nvec2(.455,.252),vec2(.572,.318),vec2(.605,.323),vec2(.725,.255),vec2(.455,.252) );\n\n\nfloat sdPolyc020 POLY(5)\nvec2 ptc020[ 5]=vec2[](  \nvec2(.566,.536),vec2(.569,.321),vec2(.606,.323),vec2(.608,.536),vec2(.566,.536) );\n\n\nfloat sdPolyc021 POLY(6)\nvec2 ptc021[ 6]=vec2[](  \nvec2(.608,.323),vec2(.608,.534),vec2(.730,.466),vec2(.733,.254),vec2(.727,.255),\nvec2(.608,.323) );\n\n\nfloat sdPolyc022 POLY(31)\nvec2 ptc022[ 31]=vec2[](  \nvec2(.139,.652),vec2(.139,.673),vec2(.150,.673),vec2(.156,.670),vec2(.164,.666),\nvec2(.164,.664),vec2(.155,.655),vec2(.169,.654),vec2(.170,.657),vec2(.175,.657),\nvec2(.180,.643),vec2(.175,.643),vec2(.169,.643),vec2(.156,.645),vec2(.155,.634),\nvec2(.155,.625),vec2(.166,.609),vec2(.170,.609),vec2(.167,.604),vec2(.155,.605),\nvec2(.147,.616),vec2(.141,.604),vec2(.127,.604),vec2(.127,.609),vec2(.131,.611),\nvec2(.131,.621),vec2(.138,.629),vec2(.131,.632),vec2(.131,.648),vec2(.134,.652),\nvec2(.139,.652) );\n\n\nvec3   HacerPista(vec2 p,  vec3  col)\n{\n     float sdc002 = sdPolyc002(p, ptc002);     //pista\n    col=ponerBorde(col1,col,sdc002 );\n    \n    float sdc003 = sdPolyc003(p, ptc003);    //linea1  pista\n    col=ponerBorde(col11,col,sdc003 );\n\n    float sdc004 = sdPolyc004(p, ptc004);  //linea2  pista\n    col=ponerBorde(col11,col,sdc004 );\n\n    float sdc005 = sdPolyc005(p, ptc005);  //linea3  pista\n    col=ponerBorde(col11,col,sdc005 );\n\n  return col;\n}\n\n\n\nvec3 HacerPiaremide1(vec2  p, vec3 col)\n{\n\n    float sdc010 = sdPolyc010(p, ptc010);  //piramide1\n    col=ponerBorde(col3,col,sdc010 );\n\n    float sdc011 = sdPolyc011(p, ptc011);\n    col=ponerBorde(col3,col,sdc011 );\n\n    float sdc012 = sdPolyc012(p, ptc012);\n    col=ponerBorde(col2,col,sdc012 );\n\n    float sdc013 = sdPolyc013(p, ptc013);\n    col=ponerBorde(col1,col,sdc013 );\nreturn col;\n}\n\nvec3  HacerPiramideV2(vec2 p, vec3 col)\n{\n   //triangulo  chico\n    float sdc014 = sdPolyc014(p, ptc014);  //piramide 2\n    col=ponerBorde(col3,col,sdc014 );\n    \n    float sdc015 = sdPolyc015(p, ptc015);\n    col=ponerBorde(col10,col,sdc015 );\n\n  return col;\n}\n\nvec3  HacerPiramideV3(vec2 p, vec3   col)\n{\n    float sdc017 = sdPolyc017(p, ptc017);   //piramide  3\n    col=ponerBorde(col3,col,sdc017 );\n\n    float sdc018 = sdPolyc018(p, ptc018);\n    col=ponerBorde(col1,col,sdc018 );\n\n  float sdc019 = sdPolyc019(p, ptc019);\n    col=ponerBorde(col3,col,sdc019 );\n\n    float sdc020 = sdPolyc020(p, ptc020);\n    col=ponerBorde(col1,col,sdc020 );\n\n  float sdc021 = sdPolyc021(p, ptc021);\n  col=ponerBorde(col2,col,sdc021 );\nreturn  col;\n}\n\n//***------------****-----------****------------******-------\nvec3 ExciteBikeNes(in vec2 pp, vec3 col) \n{\n  vec2 p=pp;\n  \n  vec2  pr0=p;\n  pr0.x=mod(pr0.x,0.065);\n  \n     float sdc000 = sdPolyc000(pr0, ptc000);\n     col=ponerBorde(col1,col,sdc000 );  //arbolito1\n    vec2  pr=p, pr1=p,pr2=p,pr3=p;\n   \n    pr.x=mod(pr.x,0.95);\n    col=HacerPista(pr,col) ;\n   \n    float sdc006 = sdPolyc006(pr, ptc006);  //parte  inferior  piso\n    col=ponerBorde(col5,col,sdc006 );\n  \n    float sdc008 = sdPolyc008(pr, ptc008);   //publico\n    col=ponerBorde(colNegro,col,sdc008 );   \n    \n    float sdc009 = sdPolyc009(pr, ptc009);  //pared  publico\n    col=ponerBorde(col4,col,sdc009 );\n    \n    pr1.x=mod(pr1.x,1.5);  \n    col= HacerPiaremide1(pr1-vec2(0.35,0.0),col);\n    \n    vec2  pr4=p;\n    pr4.x=mod(pr4.x,0.37);\n    float sdc016 = sdPolyc016(pr4, ptc016);     //flores  2\n    col=ponerBorde(col4,col,sdc016 );\n    \n    pr2.x=mod(pr2.x,0.746);  \n    col=  HacerPiramideV2(pr2,col);\n    \n    pr3.x=mod(pr3.x,2.5);  \n    col=  HacerPiramideV3(pr3-vec2(0.0,0.0), col);\n    \n    float sdc022 = sdPolyc022(pr, ptc022);     //persona\n    col=ponerBorde(col8,col,sdc022 );\n  \n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    float t=iTime*0.35;\n    vec2 p=uv*0.4-vec2(-0.45-t,-0.6);\n    vec3 col=col12;\n     \n    col=ExciteBikeNes(p, col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtlGRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 315, 351, 351, 396], [403, 403, 464, 464, 588], [591, 591, 651, 651, 777], [1319, 1319, 1350, 1350, 1371], [5590, 5590, 5629, 5629, 6042], [6046, 6046, 6087, 6087, 6438], [6440, 6440, 6481, 6503, 6700], [6702, 6702, 6745, 6745, 7174], [7176, 7238, 7281, 7281, 8352], [8354, 8354, 8411, 8411, 8660]], "test": "valid"}
{"id": "NtlGWH", "name": "Sdf Morph", "author": "Stephen_epa", "description": "sdf morph experiment", "tags": ["2d", "sdf"], "likes": 1, "viewed": 45, "published": "Public", "date": "1622009007", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// frome iq's articles\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdStar5(in vec2 p, in float r, in float rf)\n{\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n    float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n    return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\nvec2 random(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)), dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0 * fract(sin(st) * 43758.5453123);\n}\n\nfloat noise (vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random(i), f),\n            dot( random(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n            mix( dot( random(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                dot( random(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n    vec2 p = uv;\n\n    p -= .5;\n    p.x *= iResolution.x / iResolution.y;\n    p *= 2.;\n    \n    float speed = 2.;\n    float jitter = (noise(p*50.+iTime*speed))*0.12;\n    \n    float sdc = sdCircle(p + jitter/2., 0.5);\n    float sdb = sdBox(p + jitter/2., vec2(0.2, 0.2));\n    float sds = sdStar5(p + mix(vec2(0.), vec2(0, jitter)*4., max(0., dot(normalize(p), vec2(0., -1.)))), .6, 0.);\n    float mi = 0.19;\n    float ma = 0.2;\n    float ocb = max(-sdc, sdb);\n    \n\n    ocb = (ocb - mi) / (ma - mi);\n    sdc = sdCircle(p - vec2(.55, 0.), 0.2);\n    sdc = (sdc - mi) / (ma - mi);\n    sdb = (sdb - mi) / (ma - mi);\n    sds = (sds - mi) / (ma - mi);\n    \n    float cb = 0.;\n    col += 1.-vec3(mix(ocb, sds, mix(fract(iTime*1.), iMouse.x / iResolution.x, iMouse.z > 0.)), sds*cb, ocb*cb);\n    float tp = dot(normalize(p), vec2(0., -1.));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtlGWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 23, 58, 58, 86], [88, 88, 125, 125, 205], [207, 207, 258, 258, 636], [638, 638, 659, 659, 788], [790, 790, 813, 813, 1161], [1164, 1164, 1221, 1271, 2239]], "test": "valid"}
{"id": "NtlGWM", "name": "draw antialiased line ", "author": "yuempek", "description": "drawing the line with anti antialiasing.", "tags": ["line", "antialiasing", "weightedline"], "likes": 1, "viewed": 54, "published": "Public", "date": "1622282974", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n    author: https://github.com/yuempek\n*/\n\n#define PI   3.1415926535\n#define PI_2 1.5707963267\n\n//float distToLine(float x, float y, float a, float b, float c){\n//    //https://brilliant.org/wiki/dot-product-distance-between-point-and-a-line/#:~:text=The%20distance%20between%20a%20point,and%20passes%20through%20the%20point.\n//    //distance(point) = a(x0)+b(y0)+c / sqrt(a*a + b*b)\n//    return abs(a*x + b*y + c) / sqrt(a*a+b*b);\n//}\n\nfloat sumPositives(float a, float b, float c, float d){\n    float sump = 0.0;\n    if (a >= 0.0) sump += a;\n    if (b >= 0.0) sump += b;\n    if (c >= 0.0) sump += c;\n    if (d >= 0.0) sump += d;\n    \n    return sump;\n}\n\nfloat sumNegatives(float a, float b, float c, float d){\n    float sump = 0.0;\n    if (a < 0.0) sump += a;\n    if (b < 0.0) sump += b;\n    if (c < 0.0) sump += c;\n    if (d < 0.0) sump += d;\n    \n    return sump;\n}\n\nint countPositives(float a, float b, float c, float d){\n    int cnt = 0;\n    if (a >= 0.0) cnt++;\n    if (b >= 0.0) cnt++;\n    if (c >= 0.0) cnt++;\n    if (d >= 0.0) cnt++;\n    \n    return cnt;\n}\n\nfloat maxest(float a, float b, float c, float d){\n    return max(a,max(b,max(c,d)));\n}\n\nfloat minest(float a, float b, float c, float d){\n    return min(a,min(b,min(c,d)));\n}\n\nvec3 pixelcolor(vec2 unit, vec2 uvLT, vec2 uvRT, vec2 uvLB, vec2 uvRB, float w){\n    int cnt;\n  \n    float D   = 0.0;\n    float DLT = 0.0;\n    float DRT = 0.0;\n    float DLB = 0.0;\n    float DRB = 0.0;\n    \n    DLT = dot(unit, uvLT - unit * w);\n    DRT = dot(unit, uvRT - unit * w);\n    DLB = dot(unit, uvLB - unit * w);\n    DRB = dot(unit, uvRB - unit * w);\n\n    cnt = countPositives(DLT, DRT, DLB, DRB);\n    if (cnt == 4) return vec3(0.0);\n\n    if (cnt > 0) {\n        float k; \n\n        if (cnt == 2) \n            k = (-sumPositives(DLT, DRT, DLB, DRB)/sumNegatives(DLT, DRT, DLB, DRB)); \n        else // if (cnt == 1) or if (cnt == 3) \n            k = (-maxest(DLT, DRT, DLB, DRB)/minest(DLT, DRT, DLB, DRB));\n\n        return vec3(1.0 - k/(k+1.0));\n    }\n    \n    return vec3(1.0);\n}\n    \nvec3 drawLine(vec2 center, float angle, vec2 pixel, float weight, float len){\n    \n    if(distance(center, pixel) > len) return vec3(0);\n    \n    vec2 unit = vec2(cos(angle + PI_2), sin(angle + PI_2));\n    \n    float w = weight;\n    \n    //normilized half weight\n    w = (w / 2.0) / iResolution.x;\n    \n    vec2 aspect = 1.0/iResolution.xx;\n    \n    // find pixel center and corners\n    vec2 uv   = (-center + pixel + vec2(0.5, 0.5)) * aspect;\n    vec2 uvLT = (-center + pixel + vec2(0.0, 0.0)) * aspect;\n    vec2 uvRT = (-center + pixel + vec2(1.0, 0.0)) * aspect;\n    vec2 uvLB = (-center + pixel + vec2(0.0, 1.0)) * aspect;\n    vec2 uvRB = (-center + pixel + vec2(1.0, 1.0)) * aspect;\n    \n    //DLT = distToLine(uvLT.x, uvLT.y, -m, 1.0, 0.0);\n    //DRT = distToLine(uvRT.x, uvRT.y, -m, 1.0, 0.0);\n    //DLB = distToLine(uvLB.x, uvLB.y, -m, 1.0, 0.0);\n    //DRB = distToLine(uvRB.x, uvRB.y, -m, 1.0, 0.0);\n    \n    vec3 col = pixelcolor(unit, uvLT, uvRT, uvLB, uvRB, w);\n    col = min(col, pixelcolor(-unit, uvLT, uvRT, uvLB, uvRB, w));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vars\n    float angle;\n    vec3 col = vec3(0.0);\n\n    //params\n    const int n = 3;\n    float weight = 4.0;\n    float len = 100.0;\n    \n    vec2 pixel = fragCoord.xy;\n    \n    const int linecount = 3;\n    \n    //draw\n    for(float phase = 0.0; phase < float(linecount); phase++){\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                angle = -iTime*1.0 + phase*PI/float(linecount);\n                col = max(col, drawLine(iResolution.xy*vec2(float(i+1), float(j+1))/float(n+1), angle, pixel, weight, len));\n            }\n        }\n    }\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtlGWM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[441, 441, 496, 496, 658], [660, 660, 715, 715, 873], [875, 875, 930, 930, 1070], [1072, 1072, 1121, 1121, 1158], [1160, 1160, 1209, 1209, 1246], [1248, 1248, 1328, 1328, 2034], [2040, 2040, 2117, 2117, 3102], [3104, 3104, 3161, 3172, 3784]], "test": "valid"}
{"id": "NtlGWr", "name": "sanstrifa", "author": "sanstrifa", "description": "shader", "tags": ["shader"], "likes": 0, "viewed": 21, "published": "Public", "date": "1621997220", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 N22(vec2 p) {\n    vec3 a = fract(p.xyx*vec3(123.34, 234.34, 345.65));\n    a += dot(a, a+34.45);\n    return fract(vec2(a.x*a.y, a.y*a.z));\n    }\n  \n  \n  \nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    float m = 0.;  \n    float t = iTime*.2;\n    \n    float minDist = 100.;\n    float cellIndex = 0.;\n    \n    vec3 col = vec3(0);\n    \n    if(false)  {\n    for(float i =0.; i<50.; i++){\n        vec2 n = N22(vec2(i));\n        vec2 p = sin(n*t);\n        \n        float d = length(uv-p);\n         m += smoothstep(.02, .01, d);\n         \n         if(d<minDist) {\n             minDist = d;\n             cellIndex = i;\n         }\n    \n    }\n    } else {\n        uv *= 3.;\n        vec2 gv = fract(uv)-.5;\n        vec2 id = floor(uv);\n        vec2 cid = vec2(0);\n        \n        for(float y=-1.; y<=1.; y++){\n                    for(float x=-1.; x<=1.; x++){\n                        vec2 offs = vec2(x, y);\n                        \n                        vec2 n = N22(id+offs);\n                        vec2 p = offs+sin(n*t)*.5;\n                        p -= gv;\n                        float ed = length(p);\n                        float md = abs (p.x) +abs(p.y);\n                        float d = mix(ed, md, sin(iTime*2.)*.5+.5);\n                                    \n                        if(d<minDist) {\n                         minDist = d;\n                         cid = id+offs;\n                 }\n                 \n                }\n                \n                }\n                \n                col = vec3(minDist);\n               \n        \n                }\n\nfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtlGWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 148], [158, 158, 216, 216, 1678]], "test": "valid"}
{"id": "Nts3zS", "name": "Line segment Coordinate System", "author": "ircss", "description": "A useful coordinate system for procedural effects around lines for my reference", "tags": ["2d", "line", "coordinatesystem"], "likes": 4, "viewed": 178, "published": "Public API", "date": "1622326174", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// The coordinate is a vec3: X is the projection along the line (dot product), \n// Y is the distance to that projection clamped between the beginning and the end \n// of the segment to the actual pixel, Z is the projection of the error \n// vector on the orthogonal of p1 - p2. Note that \n// the Error vector (projection on line - pixelUV) is not nesssecrly orthogonal to the p1-p2,\n// since this projection is clamped to remain between p1 and p2, to function as a line segment\n// X and Z are good for doing procedural textures around the line, since they nicely/seamlessly wrap\n// around the line. Y is good for actually drawing the line with step and fwidth.\n// -------------------------------\nfloat rand(float seed) \n{\n  return fract(sin(seed *52.02) * 762.2);\n}\n\n\nfloat aaStep(float threshold, float x)\n{\n    float afwidth = clamp(length(vec2(dFdx(x), dFdy(x))) * 0.70710678118654757, 0. ,0.05);\n    return smoothstep(threshold-afwidth, threshold+afwidth, x);\n}\n\n\n// -------------------------------\n// THE ACTUAL LINE COORD FUNCTION\n// Alternativly you could also construct a 3x3 matrix with p2-p1 in x column, ortho to that in the y column and z column coordinates of p1, then multiply the pixel coordinates with that to transform the coordinate to the line coordinate. For line segments you would still have to clamp. This will probably be more instructions due to 3x3 having unnesscerly multiplications on zero entries\nvec3 LineSegCoord(vec2 p1, vec2 p2, vec2 uv){\n    \n\n    vec2 vector = p2 - p1;                      // Find the vector between the two lines\n          uv   -= p1;                           // Move the entire coord system so that the point 1 sits on the origin, it is either that or always adding point 1 when you want to find your actual point\n    float len   = length(vector);               // Find the ditance between the two points\n       vector  /= len;                          // normalize the vector \n    float vUv   = dot(vector, uv);              // Find out how far the projection of the current pixel on the line goes along the line using dot product\n    vec2  p     = vector * clamp(vUv, 0.,len) ; // since vector is normalized, the if you multiplied it with the projection amount, you will get to the coordinate of where the current uv has the shortest distance on the line. The clamp there ensures that this point always remains between p1 and p2, take this out if you want an infinite line\n    vec2 ToLine = p - uv;                       \n    float d     = length(ToLine);               // the actual distance between the current pixel and its projection on the line\n    \n    vec2 ortho    = vec2(vector.y, -vector.x);     // For 3D you would have to use cross product or something\n    float signedD = dot(ortho, ToLine);            // this gives you a signed distance between the current pixel and the line. in contrast to the value d, first this value is signed, so different on the different sides of the line, and second, for a line segment with finite ends, beyond the finit end, the magnitude of this value and d start to differ. This value will continue to get smaller, as you go around the corner on the finit edge and goes into negative\n    \n    return vec3(vUv, d, signedD); \n}\n\n// -------------------------------\nfloat movement(float seed)\n{\n  float speed = 1.;\n  float d = sin(rand(seed           ) * 512.2 + iTime  *0.4 * speed) *0.5;\n        d+= sin(rand(seed*12.+613.52) * 61.2  + iTime  *0.3 * speed) *0.25;\n        d+= sin(rand(seed*83.+22.52 ) * 721.2 + iTime  *1.2 * speed) *0.25;\n\n  return d;\n}\n\n\n\n\n// ---------------------\n\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)), \n\t\t\t\t   dot(p,vec2(419.2,371.9)) );\n\treturn fract(sin(q)*43758.5453);\n}\n\n// From https://www.shadertoy.com/view/Xd23Dh\nfloat voronoise( in vec2 p, float u)\n{\n\t\n\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n\tvec2 a = vec2(0.0,0.0);\n    float shortestDis = 1000.0;\n    \n    for( int y=-1; y<=1; y++ )\n    for( int x=-1; x<=1; x++ )\n    {\n        vec2  g = vec2( x, y );\n\t\tvec3  o = hash3( i + g )*vec3(u,u,1.0);\n\t\tvec2  d = g - f + o.xy;\n        float dis = length(d);\n        \n        if(dis<shortestDis) shortestDis = dis;\n    }\n\t\n    return shortestDis;\n}\n// -----------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n        uv -= vec2(0.5);\n        uv.x *= iResolution.x/iResolution.y;\n        \n    vec3 col = vec3(0.8);\n\n    vec2 p1 = vec2(movement(0.)      *0.5*iResolution.x/iResolution.y,  movement(52.21) *0.5);\n    vec2 p2 = vec2(movement(251.83)  *0.5*iResolution.x/iResolution.y,  movement(73.521) *0.5);\n    \n    vec3 lCord = LineSegCoord(p1, p2, uv);\n    \n    \n    col = (1.-pow(voronoise(lCord.xz *10., 1.), 3.)) * lCord;\n    col = mix(vec3(1.), col, aaStep(0.005,lCord.y));\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nts3zS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 695, 720, 720, 764], [767, 767, 807, 807, 964], [967, 1425, 1470, 1470, 3227], [3229, 3264, 3292, 3292, 3554], [3585, 3585, 3607, 3607, 3758], [3760, 3806, 3844, 3844, 4249], [4250, 4301, 4358, 4408, 4981]], "test": "valid"}
{"id": "NtsGW7", "name": "crazy disco", "author": "yunhai", "description": "cleaned my code and write this for fun", "tags": ["raymarching", "fun"], "likes": 7, "viewed": 67, "published": "Public", "date": "1622257075", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SS(a,b,t) smoothstep(a,b,t)\nconst int MAX_STEPS=70;\nconst float MAX_DIS=100.;\nconst float MIN_DIS=.01;\nvec4 s;//sphere\nfloat plane=-5.3;//plane height\nconst int LIGHT_NUM=3;\nconst int nid=0;//nothing id\nconst int pid=1;//plane id\nconst int sid=2;//sphere id\nmat2 rotMat;\nstruct Light\n{\n    vec3 pos;\n    vec3 col;\n};\nLight lig[3];//light pos \nvoid initEnv()\n{\n    lig[0].pos=vec3(0.,5.,0.);\n    lig[0].col=vec3(.5);\n    lig[1].pos=vec3(2.,8.,2.);\n    lig[1].col=vec3(0.,0.,1.);\n    lig[2].pos=vec3(-2.,8.,-2.);\n    lig[2].col=vec3(1.,.3,0.);\n    s=vec4(0.,1.,0.,2.);\n}\n#define DREMAP(type)\\\ntype remap(float a,float b,float x,float y,type t)\\\n{return (t-a)/(b-a)*(y-x)+x;}\\\ntype remapS(float x,float y,type t)\\\n{return remap(-1.,1.,x,y,t);}\nDREMAP(float)\nDREMAP(vec3)\n\n//----------------------Camera------------------------\nstruct Cam\n{\n    vec3 ro;\n    vec3 lookat;\n    vec3 lookdir;\n    vec3 fr;\n    vec3 ri;\n    vec3 up;\n}cam;\nvoid setCam(out Cam cam,vec3 ro,vec3 lookat)\n{\n    cam.ro=ro;\n    cam.lookat=lookat;\n    cam.lookdir=normalize(lookat-ro);\n    cam.fr=cam.lookdir;\n    cam.ri=cross(vec3(0.,1.,0.),cam.fr);\n    cam.up=cross(cam.fr,cam.ri);\n}\n//----------------------------------------------------\n\n\n//----------------------RayMarch----------------------\nstruct Hit\n{\n    int id;\n    vec3 pos;\n    vec3 norm;\n};\nfloat getDist(vec3 pos)\n{\n    float sd=length(pos-s.xyz)-s.w;\n    vec3 pPos=pos;\n    pPos.xy=rotMat*pos.xy;\n    float pd=pPos.y-plane;\n    return min(sd,pd);\n}\nint getId(vec3 pos)\n{\n    float minDis=MAX_DIS;\n    int id;\n    float sd=length(pos-s.xyz)-s.w;\n    vec3 pPos=pos;\n    pPos.xy=rotMat*pos.xy;\n    float pd=pPos.y-plane;\n    if(pd<minDis)\n    {\n        minDis=pd;\n        id=pid;\n    }\n    if(sd<minDis)\n    {\n        minDis=sd;\n        id=sid;\n    }\n    if(minDis>2.*MIN_DIS)\n        id=0;\n    return id;\n}\nfloat rayMarch(vec3 ori,vec3 dir)\n{\n    dir=normalize(dir);\n    float eod=0.;\n    for(int i=0;i<MAX_STEPS;i++)\n    {\n        vec3 curPos=ori+dir*eod;\n        float d=getDist(curPos);\n        eod+=d;\n        if(abs(d)<MIN_DIS||eod>MAX_DIS) break;\n    }\n    return eod;\n}\nvec3 getNormal(vec3 pos)\n{\n   vec2 e=vec2(.01,.00);\n   //getDist is the mapping D=f(x,y,z),\n   //so the following code finds its gradient by grad(f)=(dD/dx,dD/dy,dD/dz)\n   //the gradient point to the direction where the dist increases fastest\n   vec3 normal=getDist(pos)-\n   vec3(getDist(pos-e.xyy),\n       getDist(pos-e.yxy),\n       getDist(pos-e.yyx));\n   return normalize(normal);\n}\nvec3 getLight(Hit h)\n{\n    float ambient=.3;\n    //diffuse\n    vec3 diff=vec3(0.)+ambient;\n    for(int i=0;i<LIGHT_NUM;i++)\n    {\n        vec3 ld=normalize(lig[i].pos-h.pos);\n        float tdiff=clamp(dot(h.norm,ld),0.,1.);\n        \n        //shadow\n        h.pos+=h.norm*MIN_DIS*2.;//take out from attach point\n        if(rayMarch(h.pos,ld)<length(lig[i].pos-h.pos)-MIN_DIS*2.)\n        {\n            tdiff*=.1;\n        }\n        diff+=tdiff*lig[i].col;\n    }      \n    return min(diff,1.);\n}\nHit rayCast(vec3 ro,vec3 rd)\n{\n    Hit h;\n    float len=rayMarch(ro,rd);\n    if(len>MAX_DIS) len=MAX_DIS;\n    h.pos=ro+rd*len;\n    h.norm=getNormal(h.pos);\n    h.id=getId(h.pos);\n    return h;\n}\n//----------------------------------------------------\n\n\n//----------------------hexCoord----------------------\nfloat hexDist(vec2 p)\n{\n    p=abs(p);\n    float d=dot(p,normalize(vec2(1.,1.732)));\n    d=max(d,p.x);//p.x=dot(p,normalize(vec2(1.,0.)));\n    return d;\n}\nvec4 hexCoord(vec2 uv)\n{\n    vec2 r=vec2(1.,1.732)*2.;\n    vec2 auv=mod(uv,r)-.5*r;\n    vec2 buv=mod(uv-.5*r,r)-.5*r;\n    vec2 guv=length(auv)<length(buv)?auv:buv;\n    \n    vec2 id=round(uv-guv);\n    vec2 polar=vec2(hexDist(guv),atan(-guv.y,-guv.x)/6.2832+.5);\n    vec4 coord=vec4(polar.x,polar.y,id.x,id.y);\n    return coord;    \n}\n//----------------------------------------------------\n\nfloat random21(vec2 p)\n{\n    return fract(sin(27.*p.x+137.*p.y)*7492.);\n}\nvec3 getShade(Hit h)\n{\n    if(h.id==0)\n        return vec3(0.);\n    vec3 diff=getLight(h);\n    vec3 col;\n    if(h.id==pid)\n    {\n        float scale=3.;\n        vec4 hc=hexCoord(h.pos.xz/scale);\n        vec3 hcpos;\n        hcpos.xz=hc.zw*scale;\n        hcpos.y=plane;\n        float hcr=min(1.,length(s.xyz-hcpos)/10.);\n        col=vec3(step(hc.x,.98*hcr));\n        if(hcr<.98)\n            col*=vec3(.45,.75,1.);\n        float hcyt=hc.y+iTime+random21(hc.zw)*6.28;\n        \n        col*=remapS(.5,.7,sin(vec3(hcyt,hcyt*2.,hcyt*4.)));\n\n    }\n    else if(h.id==sid)\n        col=vec3(.8,.8,0.);\n    return col*diff;\n}\n\n\nvoid mainImage( out vec4 O, in vec2 C )\n{\n    \n    vec2 uv = (C-.5*iResolution.xy)/iResolution.y;\n    float t=iTime;\n    float a=3.1415*remapS(0.,.05,sin(t));\n    float rc=cos(a);\n    float rs=sin(a);\n    rotMat=mat2(rc,-rs,rs,rc);\n    initEnv();\n    \n    float camMovR=remapS(30.,50.,sin(t*.8));\n    float camMovH=remapS(8.,15.,sin(cos(t*.2)*10.));\n    vec3 ro=vec3(sin(t)*camMovR,camMovH,cos(t)*camMovR);\n    setCam(cam,ro,vec3(0.));\n    vec3 rd=normalize(cam.ri*uv.x+cam.up*uv.y+cam.fr);\n            \n    //scene manage\n    lig[1].pos+=vec3(sin(t*2.),0,cos(t*3.))*30.;\n    lig[2].pos+=vec3(cos(t*4.),0,sin(t*2.))*30.;\n    s.y+=remapS(0.,3.,sin(sin(t)*15.));\n    s.xz+=vec2(sin(t*3.),cos(t*3.))*remapS(5.,20.,sin(t));\n    s.w*=(texture(iChannel0,vec2(100./iResolution.x,0)).x*20.+10.)/20.;\n    //rayMarch\n    Hit h=rayCast(cam.ro,rd);  \n    \n    //shade\n    O.rgb=getShade(h);\n    \n    //post\n    \n}", "image_inputs": [{"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtsGW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[338, 351, 367, 367, 576], [749, 749, 844, 844, 933], [938, 938, 984, 984, 1160], [1330, 1330, 1355, 1355, 1489], [1490, 1490, 1511, 1511, 1845], [1846, 1846, 1881, 1881, 2115], [2116, 2116, 2142, 2142, 2501], [2502, 2502, 2524, 2524, 2994], [2995, 2995, 3025, 3025, 3189], [3247, 3302, 3325, 3325, 3455], [3456, 3456, 3480, 3480, 3788], [3845, 3845, 3869, 3869, 3918], [3919, 3919, 3941, 3941, 4532], [4535, 4535, 4576, 4576, 5436]], "test": "error"}
{"id": "NtsGWH", "name": "Box Edges Sorted By Proximity", "author": "blackle", "description": "a function that returns vectors representing the edges of a rectangle, ordered by distance to a given point. only valid within the box. colours in box cycle between the boundaries for the 1st, 2nd, 3rd, and 4th closest edge.", "tags": ["rectangle", "box", "sorting", "edges", "sorted", "closeness"], "likes": 9, "viewed": 238, "published": "Public API", "date": "1622007733", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nfloat nozerosgn(float x) { return step(0.,x)*2.-1.; }\nvec2  nozerosgn(vec2  x) { return step(0.,x)*2.-1.; }\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvoid edge4(vec2 p, vec2 d, inout vec2 e1, inout vec2 e2, inout vec2 e3, inout vec2 e4) {\n//this probably has some really elegant underlying structure, but I'm too tired to figure it out\n    vec3 p3 = vec3(nozerosgn(p), 0); //this lets us construct the edge vectors\n    p = abs(p);\n    float c2 = nozerosgn(p.x+p.y-d.x-d.y+min(d.x,d.y)*2.);\n    e1 = (p.x-d.x < p.y-d.y) ? p3.zy : p3.xz;\n    e2 =  c2*((c2 < 0. == p.x-d.x < p.y-d.y) ? p3.zy : p3.xz);\n    e3 = -c2*((c2 < 0. == p.x+d.x < p.y+d.y) ? p3.zy : p3.xz);\n    e4 = (p.x+d.x < p.y+d.y) ? -p3.zy : -p3.xz;\n}\n\n//rest of this is visualization code\n//colours in box cycle between the boundaries for the 1st, 2nd, 3rd, and 4th closest edge.\nfloat linedist(vec2 p, vec2 a, vec2 b) {\n    float k = dot(p-a,b-a)/dot(b-a,b-a);\n    return length(p-mix(a,b,clamp(k,0.,1.)));\n}\nvec2 closestonline(vec2 p, vec2 a, vec2 b) {\n    float k = dot(p-a,b-a)/dot(b-a,b-a);\n    return mix(a,b,clamp(k,0.,1.));\n}\n\nfloat aa(float x) {\n    return smoothstep(0., 1.5/iResolution.y, x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    vec2 mouse = (iMouse.xy-iResolution.xy*.5)/iResolution.y;\n\n    vec2 d = vec2(sin(iTime/3.)*.5+1., -sin(iTime/3.)*.5+1.)*.3;\n    vec2 p = vec2(sin(iTime), cos(iTime*3./2.))*min(d.x,d.y);\n    if (iMouse.z > 0.) p = mouse;\n\n    vec2 e1, e2, e3, e4;\n    edge4(p, d, e1, e2, e3, e4);\n\n    float d1 = linedist(uv, d*e1 + d*e1.yx, d*e1 - d*e1.yx);\n    float d2 = linedist(uv, d*e2 + d*e2.yx, d*e2 - d*e2.yx);\n    float d3 = linedist(uv, d*e3 + d*e3.yx, d*e3 - d*e3.yx);\n    float d4 = linedist(uv, d*e4 + d*e4.yx, d*e4 - d*e4.yx);\n    \n    vec2 c1 = closestonline(p, d*e1 + d*e1.yx, d*e1 - d*e1.yx);\n    vec2 c2 = closestonline(p, d*e2 + d*e2.yx, d*e2 - d*e2.yx);\n    vec2 c3 = closestonline(p, d*e3 + d*e3.yx, d*e3 - d*e3.yx);\n    vec2 c4 = closestonline(p, d*e4 + d*e4.yx, d*e4 - d*e4.yx);\n    float dd1 = linedist(uv, p, c1);\n    float dd2 = linedist(uv, p, c2);\n    float dd3 = linedist(uv, p, c3);\n    float dd4 = linedist(uv, p, c4);\n\n    edge4(uv, d, e1, e2, e3, e4);\n    bool vb1 = sin(iTime/4.) < 0.;\n    bool vb2 = sin(iTime/2.) < 0.;\n    vec2 vis = vb1 ? (vb2 ? e1 : e3) : (vb2 ? e2 : e4);\n    \n    vec3 col = length(max(abs(uv)-d,0.)) > 0. ? vec3(1) : vec3(vis*.3+.7,1.);\n    float dmin = min(min(min(d1,dd1),min(d2,dd2)),min(min(d3,dd3),min(d4,dd4)));\n    col = mix(vec3(.00), col, aa(dmin-.007));\n    col = mix(vec3(.75), col, aa(min(d4,dd4)-.005));\n    col = mix(vec3(.50), col, aa(min(d3,dd3)-.005));\n    col = mix(vec3(.25), col, aa(min(d2,dd2)-.005));\n    col = mix(vec3(.00), col, aa(min(d1,dd1)-.005));\n    col = mix(vec3(.85,.05,.05), col, aa(distance(p,uv)-.020));\n\n    // Output to screen\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtsGWH.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[194, 194, 220, 220, 247], [248, 248, 274, 274, 301], [303, 448, 536, 633, 1009], [1011, 1139, 1179, 1179, 1268], [1269, 1269, 1313, 1313, 1392], [1394, 1394, 1413, 1413, 1464], [1466, 1466, 1523, 1523, 3230]], "test": "valid"}
{"id": "NtsGzr", "name": "Simplex Noise (well kinda)", "author": "wildniklin", "description": "Getting there...", "tags": ["simplex"], "likes": 1, "viewed": 139, "published": "Public API", "date": "1621441544", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand1(vec2 p)\n{\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nvec2 skew(vec2 st)\n{\n    vec2 r = vec2(0.0);\n    r.x = 1.1547 * st.x;\n    r.y = st.y + (0.5 * r.x);\n    return r;\n}\n\nvec3 simplexGrid(vec2 st)\n{\n    vec3 m = vec3(0.0);\n\n    vec2 p = fract(skew(st));\n    if (p.x > p.y)\n    {\n        m.xy = 1.0 - vec2(p.x, p.y - p.x);\n        m.z = p.y;\n    }\n    else\n    {\n        m.yz = 1.0 - vec2(p.x - p.y, p.y);\n        m.x = p.x;\n    }\n\n    return fract(m);\n}\n\nfloat simplexNoise(vec2 uv)\n{\n    vec3 m;\n    vec3 r;\n\n    vec2 k = skew(uv);\n    vec2 i = floor(k);\n    vec2 f = k - i;\n    \n    if (f.x > f.y)\n    {\n        m = vec3(1.0 - f.x, 1.0 - (f.y - f.x), f.y);\n        r = vec3(rand1(i), rand1(vec2(i.x + 1.0, i.y)), rand1(i + 1.0));\n    }\n    else\n    {\n        m = vec3(f.x, 1.0 - (f.x - f.y), 1.0 - f.y);\n        r = vec3(rand1(i + 1.0), rand1(vec2(i.x, i.y + 1.0)), rand1(i));\n    }\n    \n\n    m = fract(m);\n    m = smoothstep(0.0, 1.0, m);\n    float a = 0.0;\n    a = mix(mix(r.x, r.z, m.z), mix(r.y, r.z, m.z), m.y);\n    return a;\n}\n\nvoid mainImage(out vec4 o, in vec2 i)\n{\n    vec2 uv = (i - (0.5 * iResolution.xy)) / min(iResolution.x, iResolution.y);\n    vec3 col = vec3(0.0);\n\n    uv *= 10.0;\n    uv += iTime;\n\n    col += simplexNoise(uv);\n    \n    o = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtsGzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 93], [95, 95, 115, 115, 210], [212, 212, 239, 239, 494], [496, 496, 525, 525, 1075], [1077, 1077, 1116, 1116, 1317]], "test": "valid"}
{"id": "NtsGzS", "name": "Slither Boy", "author": "elitewalrus", "description": "He slither.", "tags": ["raymarch", "sdf", "shadows", "snake", "worm"], "likes": 18, "viewed": 119, "published": "Public", "date": "1622318388", "time_retrieved": "2021-10-01T00:00:00", "image_code": "int MAX_STEPS = 200; //max steps for raymarching algorithm\nfloat THRESHOLD = 0.001; //distance for which the ray marcher considers a surface to be hit\nfloat MAX_DISTANCE = 80.0; //the ray marcher will stop after this distance; no hit\nfloat NORMAL_DIFFERENTIAL = 0.0001; //a samll variation for gradient/normal approximations\nfloat SHADOW_MARCH_OFFSET = 0.001; //a small offset to prevent self intersection during the shadow march\nfloat SHADOW_SHARPNESS_FACTOR = 64.0; //how sharp the soft shadows should be\nfloat IMPLICIT_SURFACE_UNDERESTIMATION_FACTOR = 0.7; //controls convergence speed\n\n//not using AO for now\n#define AO_STEPS 0\nfloat AO_INTENSITY = 0.0;\nfloat AO_DIFFERENTIAL = 0.01;\n\nfloat hillInvAmplitude = 1.0; //inverse amplitude of the ground function\nfloat hillFrequency = 0.5; //the frequency of the ground function\n\nvec3 snakePos = vec3(0.0, 0.0, 0.0); //the root position of the snake's head\n\n//a slow way to get a translation-rotation transformation\nmat4 transform(vec3 translation, vec3 rotation) {\n\tfloat g = rotation.x;\n\tfloat b = rotation.y;\n\tfloat a = rotation.z;\n\n    mat4 roll = mat4( //transposed compared to standard math notation\n \t\tcos(a), sin(a), 0.0, 0.0, \t\t\n  \t\t-sin(a), cos(a), 0.0, 0.0, \t\t\n  \t\t0.0, 0.0, 1.0, 0.0, \t\t\n  \t\t0.0, 0.0, 0.0, 1.0  \t\t\t\n\t);\n    mat4 yaw = mat4( //transposed compared to standard math notation\n \t\tcos(b), 0.0, -sin(b), 0.0, \t\t\n  \t\t0.0, 1.0, 0.0, 0.0, \t\t\n  \t\tsin(b), 0.0, cos(b), 0.0, \t\t\n  \t\t0.0, 0.0, 0.0, 1.0  \t\t\t\n\t);\n\tmat4 pitch = mat4( //transposed compared to standard math notation\n \t\t1.0, 0.0, 0.0, 0.0, \t\t\n  \t\t0.0, cos(g), sin(g), 0.0, \t\t\n  \t\t0.0, -sin(g), cos(g), 0.0, \t\t\n  \t\t0.0, 0.0, 0.0, 1.0  \t\t\t\n\t);\n\n\n\tmat4 rot = pitch * yaw * roll;\n    rot[3] = vec4(translation, 1.0);\n    return rot;\n}\n\n//easy way to transform pos into a modified sdf space\nvec3 sdTransform(vec3 translation, vec3 rotation, vec3 pos) {\n    //transform pos instead of the sdf because the sdfs change in a complicated way\n    mat4 trans = inverse(transform(translation, rotation));\n    return vec3(trans*vec4(pos, 1.0));\n}\n\n//union of two sdfs (like OR)\nfloat sdUnion(float dist1, float dist2) {\n    return min(dist1,dist2);\n}\n\n//intersection of two sdfs (like AND)\nfloat sdIntersection(float dist1, float dist2) {\n    return max(dist1,dist2);\n}\n\n//subtraction of two sdfs (like AND but sdf1 is inside out)\nfloat sdSubtraction(float dist1, float dist2) {\n    return max(-dist1,dist2);\n}\n\n//smooth union of two sdfs\nfloat sdSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n//smooth intersection of two sdfs\nfloat sdSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n\n//smooth subtraction of two sdfs\nfloat sdSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\n//sdf to sphere\nfloat sdSphere(vec3 pos) {\n    return length(pos) - 1.0;\n}\n\n//sdf to ellipsoid\nfloat sdEllipsoid(vec3 p, vec3 r){\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n//a function to represent the ground\nfloat groundFunction (vec3 pos) {\n    return sin(hillFrequency*pos.x) + \n    cos(hillFrequency*pos.z) + \n    -hillInvAmplitude*(pos.y );\n}\n\n//the gradient of the ground\nvec3 groundGradient (vec3 pos) {\n    return vec3(\n        hillFrequency*cos(hillFrequency*pos.x), \n        -hillInvAmplitude, \n        -hillFrequency*sin(hillFrequency*pos.z)\n    );\n}\n\n//the approximate signed distance to the ground (just an lower bound and not even an sdf)\nfloat sdGround(vec3 pos) {\n   float f = groundFunction(pos);\n   vec3 grad = groundGradient(pos);\n   return IMPLICIT_SURFACE_UNDERESTIMATION_FACTOR*abs(f)/length(grad);\n}\n\n//the sdf of the head of the snake. All done by trial and error there is no method to the mayhem\nfloat scene_head(vec3 pos){ \n    vec3 q = pos;\n    float head = sdSphere(q);\n    head = sdSmoothUnion(0.7*sdSphere((q-vec3(0.0,-0.3,-1.0))/0.7), head, 0.8);\n    head = sdSmoothSubtraction(2.0*sdSphere((q-vec3(0.0,2.1,0.4))/2.0), head, 0.3);\n    head = sdSmoothSubtraction(0.6*sdSphere((q-vec3(0.65,0.5,0.4))/0.6), head ,0.3);\n    head = sdSmoothSubtraction(0.6*sdSphere((q-vec3(-0.65,0.5,0.4))/0.6), head, 0.3);\n    head = sdSmoothUnion(0.5*sdSphere((q-vec3(-0.3,0.2,-0.3))/0.5), head, 0.3);\n    head = sdSmoothUnion(0.5*sdSphere((q-vec3(0.3,0.2,-0.3))/0.5), head, 0.3);\n    head = sdSmoothSubtraction(0.5*sdSphere((q-vec3(0.35,0.2,-0.2))/0.5), head ,0.05);\n    head = sdSmoothSubtraction(0.5*sdSphere((q-vec3(-0.35,0.2,-0.2))/0.5), head ,0.05);\n    return head;\n}\n\n//the sdf of the eyes of the snake\nfloat scene_eyes(vec3 pos) {\n    vec3 q = pos;\n    float eyes = 0.5*sdSphere((q-vec3(0.35,0.2,-0.2))/0.5);\n    eyes = sdUnion(0.5*sdSphere((q-vec3(-0.35,0.2,-0.2))/0.5), eyes);\n    eyes = sdSmoothSubtraction (0.2*sdSphere((q-vec3(0.4,0.3,0.1))/0.2), eyes, 0.15);\n    eyes = sdSmoothSubtraction (0.2*sdSphere((q-vec3(-0.4,0.3,0.1))/0.2), eyes, 0.15);\n    return eyes;\n}\n\n//the sdf of the pupils of the snake\nfloat scene_pupils(vec3 pos) {\n    vec3 q = pos;\n    float pupils = 0.3*sdSphere((q-vec3(0.4,0.3,-0.02))/0.3);\n    pupils = sdUnion(0.3*sdSphere((q-vec3(-0.4,0.3,-0.02))/0.3), pupils);\n    return pupils;\n}\n\n//the sdf of the body. This is extreamly slow.\nfloat scene_body(vec3 pos, vec3 rootPos){\n    #define segmentCount 48; \n    float segmentLength = 0.5;\n    float segmentWidth = 0.5;\n    float segmentOffsetFactor = 0.5;\n    vec3 root = vec3(0.0, 0.0, -1.0);\n     \n    float body = 1000000.0;\n    for(int i = 0; i < segmentCount i++) { \n        vec3 segmentPos = 2.0*segmentOffsetFactor*segmentLength*float(i)*vec3(0, 0.0, -1);\n        segmentPos += vec3(0, 0, 1) * snakePos;\n        segmentPos += root;\n        segmentPos.y = groundFunction(segmentPos) + segmentWidth;\n        \n        float segment = sdEllipsoid(vec3(pos - segmentPos), vec3(segmentWidth, segmentWidth, segmentLength));\n        body = sdSmoothUnion(body, segment, 0.6);\n    }\n    \n    return body;\n}\n\n//combine all the sdfs for the scene and use the distance to choose the right material id\n//returns vec2 sd where sd.x = distToScene and sd.y = materialID\nvec2 scene (vec3 pos) {\n\n    float ground = sdGround(pos);\n    \n    //slapped together bounding volume; hooray for longer worm.\n    if(pos.y> 5.0 || pos.y < -1.5 || pos.x < -3.0 || pos.x > 2.0 || pos.z > snakePos.z + 4.0) {\n        return vec2(ground, 1);\n    }\n    \n    //head rotation\n    vec3 groundGrad = groundGradient(snakePos);\n    float groundAngleX = acos(dot(groundGrad, vec3(0, 0, 1))/ length(groundGrad)) - 0.5*3.14;\n    float groundAngleZ = -acos(dot(groundGrad, vec3(1, 0, 0))/ length(groundGrad)) + 0.5*3.14;\n    \n    vec3 q = sdTransform(snakePos, vec3(groundAngleX, 0.0, groundAngleZ), pos);\n    float head = scene_head(q);\n    float eyes =  scene_eyes(q);\n    float pupils = scene_pupils(q);\n    float body = scene_body(pos, snakePos);\n    \n    //merge body and head\n    head = sdSmoothUnion(body, head, 0.3);\n\n    //find the shortest sd\n    float dist = min(head, ground);\n    dist = min(dist, eyes);\n    dist = min(dist, pupils);\n    //choose material id based on shortest distance\n    float objectID = -1.0;\n    if (dist >= head) { \n        objectID = 2.0;\n    }else if (dist >= eyes) {\n        objectID = 3.0;\n    }else if (dist >= pupils) {\n        objectID = 4.0;\n    }else {\n        objectID = 1.0;\n    }\n    \n    return vec2 (dist, objectID);\n}\n\n//aproximate normal to scene. Basically central differences method for the gradient\n//returns vec2 rayData where rayData.x = rayLength and rayData.y = materialID\nvec3 getNormal(vec3 pos) {\n    vec3 h = vec3 (NORMAL_DIFFERENTIAL, 0, 0);\n    \n    vec3 normal = vec3(\n        scene(pos + h.xyy).x - scene(pos - h.xyy).x,\n        scene(pos + h.yxy).x - scene(pos - h.yxy).x,\n        scene(pos + h.yyx).x - scene(pos - h.yyx).x\n    );\n\n    return normalize(normal);\n}\n\n//the raymarching algorithm\nvec2 Raymarch (vec3 ro, vec3 rd) {\n    vec2 sceneDistance = vec2 (0.0, -1.0);\n    for(int i = 0; i < MAX_STEPS; i++) {\n        vec3 rayPos = ro + sceneDistance.x*rd;\n        \n        vec2 localDistance = scene(rayPos);\n        if (localDistance.x < THRESHOLD) {\n            break;\n        }\n    \n        sceneDistance.x += localDistance.x;\n        sceneDistance.y = localDistance.y;\n        \n        if (sceneDistance.x > MAX_DISTANCE) {\n            break;\n        }\n    }\n    if(sceneDistance.x > MAX_DISTANCE) {\n        sceneDistance.x = -1.0;\n    }\n    \n    return sceneDistance;\n}\n\n//sdf ambient occlusion. Didn't play well with the implicit surface\nfloat AO (vec3 pos, vec3 normal) {\n    float ao = 0.0;\n    float dist = 0.0;\n    for(int i = 0; i < AO_STEPS; i++) {\n        dist = AO_DIFFERENTIAL * float(i);\n        ao += max (0.0, (dist - scene(pos + normal*dist).x)/dist);\n    }\n    return 1.0 - ao*AO_INTENSITY;\n}\n\nfloat softShadow (vec3 ro, vec3 rd) {\n    float penumbra = 1.0;\n\n    float sceneDistance = 0.0;\n    for(int i = 0; i < MAX_STEPS; i++) {\n        vec3 rayPos = ro + sceneDistance*rd;\n        \n        float localDistance = scene(rayPos).x;\n        \n        penumbra = min(penumbra, SHADOW_SHARPNESS_FACTOR*localDistance/sceneDistance);\n             \n        if (localDistance < THRESHOLD) {\n            break;\n        }\n        \n        sceneDistance += localDistance;\n        \n        if (sceneDistance > MAX_DISTANCE) {\n            break;\n        }\n    }\n    \n    return penumbra;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //normalized screen space coordinates\n    vec2 uv = (fragCoord - 0.5f*iResolution.xy)/iResolution.y;\n    \n    //snake pos \n    snakePos = vec3(0.0, 0.0, 3.0*iTime);\n    snakePos.y = groundFunction(snakePos) + 1.0;\n    \n    //choose a camera angle based on mouse position\n    float anglex = iMouse.xy==vec2(0) ? -0.2 : 10.0*iMouse.x/iResolution.x;\n    float angley = iMouse.xy==vec2(0) ? 5.75 : 10.0*iMouse.y/iResolution.y;\n    \n    //set the ray origin\n    float cameraDist = 12.0;\n    vec3 ro = vec3(cameraDist*sin(anglex), angley, cameraDist*cos(anglex)) + vec3(0.0, 0.0, snakePos.z);\n  \n    //lookat computations\n    vec3 target = snakePos;\n    vec3 w = normalize((target - ro));\n    vec3 u = normalize (cross(w, vec3(0, 1, 0)));\n    vec3 v = normalize (cross(u, w));\n   \n    //set the ray direction using the lookat values\n    vec3 rd = normalize(uv.x*u + uv.y*v + 1.0*w);\n    \n    //use blue gradient to color the sky\n    vec3 col = vec3(0.4, 0.75, 1.0) - 1.0*rd.y;\n    \n    //ray march\n    vec2 sceneDistance = Raymarch(ro, rd);\n    \n    if(sceneDistance.x > 0.0) {\n        //recover the ray\n        vec3 hitPosition = ro + sceneDistance.x*rd;\n        vec3 hitNormal = getNormal(hitPosition);\n        \n        //default material value\n        vec3 material = vec3(0.18);\n        \n        //use the material id to choose the material properies\n        if(sceneDistance.y == 1.0) { //the ground material\n            material = 0.18*vec3(0.129, 0.909, 0.137);\n            \n            //darken the color with sin to get stripes\n            float f = smoothstep(0.4, 0.5, 0.5 + 0.5*sin(6.0*hitPosition.z + 6.0*hitPosition.x));\n            material = mix (material, 0.8*material, f);\n        } else if (sceneDistance.y == 2.0) { //the snake skin material\n            material = 0.18*vec3(1.0, 0.564, 0.180);\n            \n            //darken the color with sin to get stripes\n            float f = smoothstep(0.4, 0.5, 0.5 + 0.5*sin(12.0*(hitPosition.z - snakePos.z)));\n            material = mix (material, 0.8*material, f);\n        } else if (sceneDistance.y == 3.0) { //the eye material\n            material = 0.18*vec3(1.0, 1.0, 1.0);\n        } else if (sceneDistance.y == 4.0) { //the snake pupil material\n            material = 0.18*vec3(0.03, 0.03, 0.03);\n        }\n        \n        //set a direction for the sun light\n        vec3 sunDirection = normalize(vec3(0.8, 0.4, 0.2));\n        \n        //light colors\n        vec3 sunColor = vec3(7.0, 4.5, 3.0);\n        vec3 skyColor = vec3(0.5, 0.8, 0.9);\n        vec3 bounceColor = vec3(0.7, 0.3, 0.2);\n        \n        //specular strengtho constant. Could be changed to be per material.\n        float specularStrength = 0.7;\n        \n        //directional light calculations. The bias for bounceDiffuse and skyDiffuse is in effect an ambient lighting layer\n        float sunDiffuse = clamp(dot(hitNormal, sunDirection), 0.0, 1.0);\n        float skyDiffuse = clamp(0.5 + 0.5*dot(hitNormal, vec3(0.0, 1.0, 0.0)), 0.0, 1.0);\n        float bounceDiffuse = clamp(0.5 + 0.5*dot(hitNormal, vec3(0.0, -1.0, 0.0)), 0.0, 1.0);\n        //specular according to the Phong model\n        float specular = pow(max(dot(rd, reflect(sunDirection, hitNormal)), 0.0), 32.0);\n        //sun showow is computed with a second ray march (a hit is any value not -1.0 so the step funtion is used)\n        float sunShadow = softShadow(hitPosition + SHADOW_MARCH_OFFSET*hitNormal, sunDirection);\n        \n        //calulate ambient occlusion\n        float ao = AO(hitPosition, hitNormal);\n        \n        //combine all the light calculations do get the final pixel color\n        col = material*ao*(\n            sunColor*sunDiffuse*sunShadow + \n            sunColor*specular*specularStrength +\n            skyColor*skyDiffuse + \n            bounceDiffuse*bounceColor\n        );\n    }\n    \n    //gamma correction. Standard value for the average monitor. Makes it easier to choose good colors\n    col = pow(col, vec3(0.4545)); \n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtsGzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[907, 965, 1014, 1014, 1755], [1757, 1811, 1872, 1956, 2057], [2059, 2089, 2130, 2130, 2161], [2163, 2201, 2249, 2249, 2280], [2282, 2342, 2389, 2389, 2421], [2423, 2450, 2502, 2502, 2602], [2604, 2638, 2697, 2697, 2797], [2799, 2832, 2890, 2890, 2991], [2993, 3009, 3035, 3035, 3067], [3069, 3088, 3122, 3122, 3205], [3207, 3244, 3277, 3277, 3382], [3384, 3413, 3445, 3445, 3596], [3598, 3688, 3714, 3714, 3857], [3859, 3956, 3983, 3983, 4720], [4722, 4757, 4785, 4785, 5125], [5127, 5164, 5194, 5194, 5369], [6137, 6292, 6315, 6315, 7562], [7564, 7726, 7752, 7752, 8026], [8028, 8056, 8090, 8090, 8640], [8642, 8710, 8744, 8744, 8978], [8980, 8980, 9017, 9017, 9562], [9564, 9564, 9621, 9663, 13615]], "test": "error"}
{"id": "NtX3Wr", "name": "Distribution Ray Tracing and DOF", "author": "HQ", "description": "Distribution Ray Tracing with depth-of-field and anti-aliasing", "tags": ["raytracing"], "likes": 9, "viewed": 107, "published": "Public", "date": "1621858057", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//============================================================\n// STUDENT NAME: Li Hengqiong\n// STUDENT NO.: A0225542L\n// NUS EMAIL ADDRESS: e0576176@u.nus.edu\n// COMMENTS TO GRADER:\n//\n//============================================================\n\n\n// FRAGMENT SHADER FOR SHADERTOY\n// Run this at https://www.shadertoy.com/new\n// See documentation at https://www.shadertoy.com/howto\n\n// Your browser must support WebGL 2.0.\n// Check your browser at https://webglreport.com/?v=2\n\n\n//============================================================================\n// Constants.\n//============================================================================\n\nconst float PI = 3.1415926536;\n\nconst vec3 BACKGROUND_COLOR = vec3( 0.1, 0.2, 0.6 );\n\n// Vertical field-of-view angle of camera. In degrees.\nconst float FOVY = 50.0;\n\n// Use this for avoiding the \"epsilon problem\" or the shadow acne problem.\nconst float DEFAULT_TMIN = 10.0e-4;\n\n// Use this for tmax for non-shadow ray intersection test.\nconst float DEFAULT_TMAX = 10.0e6;\n\n// Equivalent to number of recursion levels (0 means ray-casting only).\n// We are using iterations to replace recursions.\nconst int NUM_ITERATIONS = 2;\n\n// Constants for the scene objects.\nconst int NUM_LIGHTS = 2;\nconst int NUM_MATERIALS = 3;\nconst int NUM_PLANES = 2;\nconst int NUM_SPHERES = 2;\n\n\n//============================================================================\n// Define new struct types.\n//============================================================================\nstruct Ray_t {\n    vec3 o;  // Ray Origin.\n    vec3 d;  // Ray Direction. A unit vector.\n};\n\nstruct Plane_t {\n    // The plane equation is Ax + By + Cz + D = 0.\n    float A, B, C, D;\n    int materialID;\n};\n\nstruct Sphere_t {\n    vec3 center;\n    float radius;\n    int materialID;\n};\n\nstruct Light_t {\n    vec3 position;  // Point light 3D position.\n    vec3 I_a;       // For Ambient.\n    vec3 I_source;  // For Diffuse and Specular.\n};\n\nstruct Material_t {\n    vec3 k_a;   // Ambient coefficient.\n    vec3 k_d;   // Diffuse coefficient.\n    vec3 k_r;   // Reflected specular coefficient.\n    vec3 k_rg;  // Global reflection coefficient.\n    float n;    // The specular reflection exponent. Ranges from 0.0 to 128.0.\n};\n\n//----------------------------------------------------------------------------\n// The lighting model used here is similar to that on Slides 8 and 12 of\n// Lecture Topic 9 (Ray Tracing). Here it is computed as\n//\n//     I_local = SUM_OVER_ALL_LIGHTS {\n//                   I_a * k_a +\n//                   k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ]\n//               }\n// and\n//     I = I_local  +  k_rg * I_reflected\n//----------------------------------------------------------------------------\n\n\n//============================================================================\n// Global scene data.\n//============================================================================\nPlane_t Plane[NUM_PLANES];\nSphere_t Sphere[NUM_SPHERES];\nLight_t Light[NUM_LIGHTS];\nMaterial_t Material[NUM_MATERIALS];\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Initializes the scene.\n/////////////////////////////////////////////////////////////////////////////\nvoid InitScene()\n{\n    // Horizontal plane.\n    Plane[0].A = 0.0;\n    Plane[0].B = 1.0;\n    Plane[0].C = 0.0;\n    Plane[0].D = 0.0;\n    Plane[0].materialID = 0;\n\n    // Vertical plane.\n    Plane[1].A = 0.0;\n    Plane[1].B = 0.0;\n    Plane[1].C = 1.0;\n    Plane[1].D = 3.5;\n    Plane[1].materialID = 0;\n\n    // Center bouncing sphere.\n    Sphere[0].center = vec3( 0.0, abs(sin(2.0 * iTime)) + 0.7, 0.0 );\n    Sphere[0].radius = 0.7;\n    Sphere[0].materialID = 1;\n\n    // Circling sphere.\n    Sphere[1].center = vec3( 1.5 * cos(iTime), 0.5, 1.5 * sin(iTime) );\n    Sphere[1].radius = 0.5;\n    Sphere[1].materialID = 2;\n\n    // Silver material.\n    Material[0].k_d = vec3( 0.5, 0.5, 0.5 );\n    Material[0].k_a = 0.2 * Material[0].k_d;\n    Material[0].k_r = 2.0 * Material[0].k_d;\n    Material[0].k_rg = 0.5 * Material[0].k_r;\n    Material[0].n = 64.0;\n\n    // Gold material.\n    Material[1].k_d = vec3( 0.8, 0.7, 0.1 );\n    Material[1].k_a = 0.2 * Material[1].k_d;\n    Material[1].k_r = 2.0 * Material[1].k_d;\n    Material[1].k_rg = 0.5 * Material[1].k_r;\n    Material[1].n = 64.0;\n\n    // Green plastic material.\n    Material[2].k_d = vec3( 0.0, 0.8, 0.0 );\n    Material[2].k_a = 0.2 * Material[2].k_d;\n    Material[2].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[2].k_rg = 0.5 * Material[2].k_r;\n    Material[2].n = 128.0;\n\n    // Light 0.\n    Light[0].position = vec3( 4.0, 8.0, -3.0 );\n    Light[0].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[0].I_source = vec3( 1.0, 1.0, 1.0 );\n\n    // Light 1.\n    Light[1].position = vec3( -4.0, 8.0, 0.0 );\n    Light[1].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[1].I_source = vec3( 1.0, 1.0, 1.0 );\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Returns a random number between 0 and 1.\n//\n// This pseudorandom number generator is based on the 32-bit combined LFSR\n// generator proposed in the paper \"Tables of Maximally-Equidistributed\n// Combined LFSR Generators\" by Pierre L'Ecuyer.\n// (http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.43.3639)\n/////////////////////////////////////////////////////////////////////////////\n\n// VERY IMPORTANT: The initial seeds rand_z1, rand_z2, rand_z3, rand_z4\n// must be larger than 1, 7, 15, and 127 respectively.\nconst uint CONST_RAND_SEED = 987654321U;\nuint rand_z1 = uint(CONST_RAND_SEED + 2U);\nuint rand_z2 = uint(CONST_RAND_SEED + 8U);\nuint rand_z3 = uint(CONST_RAND_SEED + 16U);\nuint rand_z4 = uint(CONST_RAND_SEED + 128U);\n\nfloat rand(void)\n{\n    uint b  = ((rand_z1 << 6) ^ rand_z1) >> 13;\n    rand_z1 = ((rand_z1 & 4294967294U) << 18) ^ b;\n    b       = ((rand_z2 << 2) ^ rand_z2) >> 27;\n    rand_z2 = ((rand_z2 & 4294967288U) << 2) ^ b;\n    b       = ((rand_z3 << 13) ^ rand_z3) >> 21;\n    rand_z3 = ((rand_z3 & 4294967280U) << 7) ^ b;\n    b       = ((rand_z4 << 3) ^ rand_z4) >> 12;\n    rand_z4 = ((rand_z4 & 4294967168U) << 13) ^ b;\n    return float(rand_z1 ^ rand_z2 ^ rand_z3 ^ rand_z4) * 2.3283064365386963e-10;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is such an intersection, outputs the value of t, the position\n// of the intersection (hitPos) and the normal vector at the intersection\n// (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray,\n                     in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n\n    // We have a hit -- output results.\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize( N );\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray,\n                     in float tmin, in float tmax )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the\n// smaller t, the position of the intersection (hitPos) and the normal\n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray,\n                      in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    vec3 o_ = ray.o - sph.center;\n    float b = 2. * dot(ray.d, o_);\n    float c = dot(o_, o_) - sph.radius * sph.radius;\n    float d = b * b - 4. * c;\n    if (d < 0.) return false;\n    if (d == 0.) {\n        float t0 = -b / 2.;\n        if ( t0 < tmin || t0 > tmax ) return false;\n        t = t0;\n    }\n    else {\n        float t0 = (-b + sqrt(d)) / 2.;\n        float t1 = (-b - sqrt(d)) / 2.;\n        if ( t0 < tmin || t0 > tmax ) {\n            if ( t1 < tmin || t1 > tmax ) return false;\n            else t = t1;\n        }\n        else {\n            if ( t1 < tmin || t1 > tmax ) t = t0;\n            else t = (t0 < t1)? t0 : t1;\n        }\n    }\n    hitPos = ray.o + t * ray.d;\n    hitNormal = normalize(hitPos - sph.center);\n    return true;  // Replace this with your code.\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray,\n                      in float tmin, in float tmax )\n{\n    vec3 o_ = ray.o - sph.center;\n    float b = 2. * dot(ray.d, o_);\n    float c = dot(o_, o_) - sph.radius * sph.radius;\n    float d = b * b - 4. * c;\n    if (d < 0.) return false;\n    if (d == 0.) {\n        float t0 = -b / 2.;\n        if ( t0 < tmin || t0 > tmax ) return false;\n    }\n    else {\n        float t0 = (-b + sqrt(d)) / 2.;\n        float t1 = (-b - sqrt(d)) / 2.;\n        if ( t0 < tmin || t0 > tmax ) {\n            if ( t1 < tmin || t1 > tmax ) return false;\n        }\n    }\n    return true;  // Replace this with your code.\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes (I_a * k_a) + k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ].\n// Input vectors L, N and V are pointing AWAY from surface point.\n// Assume all vectors L, N and V are unit vectors.\n/////////////////////////////////////////////////////////////////////////////\nvec3 PhongLighting( in vec3 L, in vec3 N, in vec3 V, in bool inShadow,\n                    in Material_t mat, in Light_t light )\n{\n    if ( inShadow ) {\n        return light.I_a * mat.k_a;\n    }\n    else {\n        vec3 R = reflect( -L, N );\n        float N_dot_L = max( 0.0, dot( N, L ) );\n        float R_dot_V = max( 0.0, dot( R, V ) );\n        float R_dot_V_pow_n = ( R_dot_V == 0.0 )? 0.0 : pow( R_dot_V, mat.n );\n\n        return light.I_a * mat.k_a +\n               light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Casts a ray into the scene and returns color computed at the nearest\n// intersection point. The color is the sum of light from all light sources,\n// each computed using Phong Lighting Model, with consideration of\n// whether the interesection point is being shadowed from the light.\n// If there is no interesection, returns the background color, and outputs\n// hasHit as false.\n// If there is intersection, returns the computed color, and outputs\n// hasHit as true, the 3D position of the intersection (hitPos), the\n// normal vector at the intersection (hitNormal), and the k_rg value\n// of the material of the intersected object.\n/////////////////////////////////////////////////////////////////////////////\nvec3 CastRay( in Ray_t ray,\n              out bool hasHit, out vec3 hitPos,\n              out vec3 hitNormal, out vec3 k_rg )\n{\n    // Find whether and where the ray hits some object.\n    // Take the nearest hit point.\n\n    bool hasHitSomething = false;\n    float nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.\n    vec3 nearest_hitPos;              // 3D position of the nearest hit point.\n    vec3 nearest_hitNormal;           // Normal vector at the nearest hit point.\n    int nearest_hitMatID;             // MaterialID of the object at the nearest hit point.\n\n    float temp_t;\n    vec3 temp_hitPos;\n    vec3 temp_hitNormal;\n    bool temp_hasHit;\n\n\n    for (int i=0; i<NUM_PLANES; i++) {\n        temp_hasHit = IntersectPlane(Plane[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal);\n        if (temp_hasHit) {\n            hasHitSomething = true;\n            if (temp_t < nearest_t) {\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n                nearest_hitMatID = Plane[i].materialID;\n            }\n        }\n    }\n\n    for (int i=0; i<NUM_SPHERES; i++) {\n        temp_hasHit = IntersectSphere(Sphere[i], ray, DEFAULT_TMIN, DEFAULT_TMAX, temp_t, temp_hitPos, temp_hitNormal);\n        if (temp_hasHit) {\n            hasHitSomething = true;\n            if (temp_t < nearest_t) {\n                nearest_t = temp_t;\n                nearest_hitPos = temp_hitPos;\n                nearest_hitNormal = temp_hitNormal;\n                nearest_hitMatID = Sphere[i].materialID;\n            }\n        }\n    }\n\n\n    // One of the output results.\n    hasHit = hasHitSomething;\n    if ( !hasHitSomething ) return BACKGROUND_COLOR;\n\n    vec3 I_local = vec3( 0.0 );  // Result color will be accumulated here.\n\n    for (int i=0; i<NUM_LIGHTS; i++) {\n        Ray_t shadowRay;\n        shadowRay.o = nearest_hitPos;\n        vec3 d = Light[i].position - nearest_hitPos;\n        float dst = sqrt(dot(d, d));\n        shadowRay.d = normalize(d);\n        bool inShadow = false;\n        for (int j=0; j<NUM_PLANES; j++) {\n            if (IntersectPlane(Plane[j], shadowRay, DEFAULT_TMIN, dst)) {\n                inShadow = true;\n                break;\n            }\n        }\n        if (!inShadow) {\n            for (int j=0; j<NUM_SPHERES; j++) {\n                if (IntersectSphere(Sphere[j], shadowRay, DEFAULT_TMIN, dst)) {\n                    inShadow = true;\n                    break;\n                }\n            }\n        }\n        I_local += PhongLighting(shadowRay.d, nearest_hitNormal, -ray.d, inShadow, Material[nearest_hitMatID], Light[i]);\n    }\n\n\n    // Populate output results.\n    hitPos = nearest_hitPos;\n    hitNormal = nearest_hitNormal;\n    k_rg = Material[nearest_hitMatID].k_rg;\n\n    return I_local;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Execution of fragment shader starts here.\n// 1. Initializes the scene.\n// 2. Compute a primary ray for the current pixel (fragment).\n// 3. Trace ray into the scene with NUM_ITERATIONS recursion levels.\n/////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Initialize random number generator before the first call to rand().\n    uint RAND_SEED = uint( (mod(iTime*100.0, 100.0) + 101.01) *\n                           (fragCoord.x + 17.0) * (fragCoord.y + 23.0) );\n    rand_z1 = uint(RAND_SEED + 2U);\n    rand_z2 = uint(RAND_SEED + 8U);\n    rand_z3 = uint(RAND_SEED + 16U);\n    rand_z4 = uint(RAND_SEED + 128U);\n\n\n    InitScene();\n\n\n    // Camera position and orientation in world space.\n    vec3 cam_pos = vec3( 2.5, 1.0, 2.5 );\n    vec3 cam_lookat = vec3( 0.25, 1.0, 0.0 );\n    vec3 cam_up_vec = vec3( 0.0, 1.0, 0.0 );\n\n    // Camera coordinate frame in world space.\n    vec3 cam_z_axis = normalize( cam_pos - cam_lookat );\n    vec3 cam_x_axis = normalize( cross(cam_up_vec, cam_z_axis) );\n    vec3 cam_y_axis = normalize( cross(cam_z_axis, cam_x_axis));\n\n    // Vertical field-of-view angle of camera. In radians.\n    float cam_FOVY = FOVY * PI / 180.0;\n\n    // Perpendicular distance of the image rectangle from the camera.\n    // If implementing depth-of-field, the plane of the image rectangle\n    // is the plane of focus.\n    float image_dist = distance(cam_pos, vec3(0.0, 0.7, 0.0));\n\n    float image_height = 2.0 * image_dist * tan(cam_FOVY / 2.0);\n    float image_width = image_height * iResolution.x / iResolution.y;\n    float pixel_width = image_width / iResolution.x;\n\n    // Image rectangle origin (bottom-leftmost corner) position in camera space.\n    vec3 image_origin = vec3(-image_width/2.0, -image_height/2.0, -image_dist);\n\n\n\n    //=======================================================================\n    // These constants are used for distribution ray tracing to produce\n    // depth-of-field effect and for image anti-aliasing (reduce jaggies).\n    //=======================================================================\n    // Number of samples (random primary rays) per pixel.\n    const int SPP = 32;\n\n    // Lens aperture width. Assume square aperture.\n    const float aperture_width = 0.3;\n    //=======================================================================\n\n\n    // Current pixel 3D position in camera space.\n    //vec3 pixel_pos = image_origin + vec3(pixel_width * fragCoord, 0);\n    // Create primary ray.\n    vec2 offsetLen, offsetPixel;\n    vec3 pixel_pos, len_pos;\n    Ray_t pRay[SPP];\n    for (int i=0; i<SPP; i++) {\n        offsetLen.x = rand();\n        offsetLen.y = rand();\n        offsetLen = (offsetLen - 0.5) * aperture_width / 2. / 0.5;\n        offsetPixel.x = rand();\n        offsetPixel.y = rand();\n        offsetPixel = (offsetPixel - 0.5) * pixel_width / 2. / 0.5;\n        len_pos = cam_pos + offsetLen.x * cam_x_axis + offsetLen.y * cam_y_axis;\n        pixel_pos = image_origin + vec3(pixel_width * fragCoord, 0) + vec3(offsetPixel, 0);\n        pRay[i].o = len_pos;\n        pRay[i].d = normalize(cam_pos + pixel_pos.x * cam_x_axis  +\n                                        pixel_pos.y * cam_y_axis  +\n                                        pixel_pos.z * cam_z_axis - pRay[i].o);\n    }\n\n    // Start Ray Tracing.\n    // Use iterations to emulate the recursion.\n    vec3 fragColor_ = vec3(0.);\n    for (int i=0; i<SPP; i++) {\n        Ray_t nextRay = pRay[i];\n        vec3 I_result = vec3( 0.0 );\n        vec3 compounded_k_rg = vec3( 1.0 );\n        for ( int level = 0; level <= NUM_ITERATIONS; level++ ) {\n            bool hasHit;\n            vec3 hitPos, hitNormal, k_rg;\n\n            vec3 I_local = CastRay( nextRay, hasHit, hitPos, hitNormal, k_rg );\n\n            I_result += compounded_k_rg * I_local;\n\n            if ( !hasHit ) break;\n\n            compounded_k_rg *= k_rg;\n\n            nextRay = Ray_t( hitPos, normalize( reflect(nextRay.d, hitNormal) ) );\n        }\n        fragColor_ += I_result;\n    }\n\n    fragColor = vec4( fragColor_ / float(SPP), 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtX3Wr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[3047, 3229, 3247, 3272, 4857], [5674, 5674, 5692, 5692, 6171], [6175, 6671, 6846, 6846, 7176], [7180, 7512, 7616, 7616, 7828], [7832, 8350, 8529, 8529, 9308], [9312, 9645, 9752, 9752, 10294], [10298, 10652, 10782, 10782, 11194], [11198, 11987, 12114, 12205, 14834], [14838, 15199, 15256, 15331, 19034]], "test": "error"}
{"id": "NtX3z4", "name": "大龙猫 - Quicky#053", "author": "totetmatt", "description": "Reading this iq article to extend my knowledge https://iquilezles.org/www/articles/fbm/fbm.htm\nUsed the fbm code and then this happend", "tags": ["fbm", "quicky"], "likes": 6, "viewed": 155, "published": "Public API", "date": "1621583149", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Complete copy of https://iquilezles.org/www/articles/fbm/fbm.htm\n// https://www.shadertoy.com/view/WsV3zz\nfloat gnoise( float nn ) \n{\n    int n = int(nn);\n    n = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return -1.0+2.0*float( n & ivec3(0x0fffffff))/float(0x0fffffff);\n}\nfloat fbm( in float x, in float G )\n{    \n    x += 25.06;\n    float n = -.30;\n    float s = 1.20;\n    float a = 1.10;\n    float f = .50+sin(floor(iTime*8.)*6.66);    \n    for( int i=0; i<16; i++ )\n    {\n        n += s*gnoise(x*f);\n        a += s;\n        s *= G;\n        f *= 2.0;\n        x += 0.31;\n    }\n    return n;\n}\nvec3 pal(float t){return .5+.5*cos(6.2813*(1.*t+vec3(.0,.3,.7)));}\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy -.5* iResolution.xy)/iResolution.y;\n    uv*=2.;\n    \n    \n    vec3 d =vec3(0.);\n    const float lim=100.;\n  \n    for(float i =0.;i<=lim;i++){\n    uv*=rot(.1);\n    float f = fract(i/lim+iTime*.1);\n    float s = mix(12.,.1,f);\n    vec2 uuv = uv*s;\n    uuv.y = -abs(uuv.y);\n    float q = fbm(uuv.x+sin(i*3.33-gnoise(i/lim)*.4)*2.,.25-gnoise(i/lim)*.2);\n    d += pal(i/lim)*step(0.,1.-abs(uuv.y+3.)-q)*f;\n    }\n    d/=lim;\n    vec3 col = vec3(d);\n    col = mix(col,1.-col,sqrt(col)*1.5);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtX3z4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 109, 136, 136, 302], [303, 303, 340, 340, 624], [625, 625, 643, 643, 691], [692, 692, 710, 710, 757], [758, 758, 813, 813, 1358]], "test": "valid"}
{"id": "NtXGD7", "name": "bluenoiseDisk ", "author": "Carandiru", "description": "convergence of bluenoise using Hammersley.\nvery interesting how the blue noise pixels all move to the final destination for that pixel. self-assimilating....\n\n3d bluenoise ?", "tags": ["bluenoise"], "likes": 4, "viewed": 152, "published": "Public API", "date": "1622172098", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// - carandiru\n// http://bit.ly/supersinfulsilicon\n\n// shader is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/NtXGD7\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\n\n// adjust the pixel scale to zoom in\n// adjust the convergence speed to see how the \"samples\" distribute in a blue noise pattern over time.\n\n#define PIXEL_SCALE 0.3333333  // does effect speed\n#define CONVERGENCE_SPEED 0.666666  // ** smaller number is faster\n\nvec3 Hammersley(in vec2 i, in vec2 N, in float inv_density)  // i = iDx, N = # of sample/total iteration (used inside of loop to generate points)\n{\n  return vec3(\n    i / N,\n    textureLod(iChannel0, (i) / (1024.0), 0.0f).r * inv_density\n  );\n}\nvec3 HammersleyDisk(in vec2 i, in vec2 N, in float inv_density) {\n    vec3 h = 2.0f * Hammersley(i, N, inv_density) - 1.0f;\n    h = h * sqrt( 1.0f - 0.5f * h*h ).zyx;\n    return (h / length(N));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 coord = uv * PIXEL_SCALE * iResolution.xy;\n    \n    coord += vec2(cos(iTime), sin(iTime)); // wobble visually\n    \n    vec3 hd = HammersleyDisk(coord, PIXEL_SCALE * iResolution.xy, CONVERGENCE_SPEED / iTime);\n    \n    float opacity = 0.0f;\n    \n    opacity = 1.0f - length((hd.xy)/hd.z);//length(hd);//sqrt(hd.y + hd.x);\n    // Output to screen\n    fragColor = vec4(vec3(opacity),1.0);\n}", "image_inputs": [{"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtXGD7.jpg", "access": "shaders20k", "license": "cc-by-sa-4.0", "functions": [[573, 573, 720, 720, 817], [818, 818, 883, 883, 1014], [1017, 1017, 1074, 1124, 1566]], "test": "error"}
{"id": "NtXGDN", "name": "Swirled Series C010011012", "author": "cmarangu", "description": "@C010011012 / chase marangu 's submission to @cs_kaplan's https://isohedral.ca/swirled-series/", "tags": ["voxel", "penrose", "swirledseries"], "likes": 9, "viewed": 200, "published": "Public API", "date": "1622060275", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n// Current code for: Swirled Series C010011012\n// Date: Made around 2020 November 22nd\n// Tags: swirledseries, penrose, voxel\n// Description: @C010011012 / chase marangu 's submission to @cs_kaplan's https://isohedral.ca/swirled-series/\n\n\n// ↓ i know more\n#define PI 3.14159265358979323846264338327950288419716939937510582\n#define TAU 6.28318530718\n\n#define arg mod(float(iFrame)/60./3., 1.)\n\n#define cam_maus 0\n#define cam_psp 0\n\n#define rrg min(2.*min(2.*arg, 2.-2.*arg), 1.)\n//#define R mix(.05, .5, min(2.*arg, 2.-2.*arg))\n#define R mix(.01, .1, rrg)\n//#define R 0.\n\n//\n//#define sund normalize(vec3(1., .2, -.2))\n#define sund normalize(vec3(1., .0, -.0))\n//vec3 sky_map (vec3 d) {\n    //return vec3(0.);\n    //return vec3(.0, .0, 100./255.);\n    //return vec3(0., 1., 0.);\n    //return texture(iChannel2, d).rgb;\n//}\n\n#define inter_sky vec4(vec3(0.), 1e9)\n\n\n//\n//#define SDF(p) (length(p-vec3(.5) )-.49)\n//#define SDF(p) (length(max(abs(p-vec3(.5))-vec3(.4), 0.) )-.02)\n//#define SDF(p) (length(max(abs(p-vec3(.5))-vec3(.3), 0.) )-.18)\n//#define SDF(p) (length(max(abs(p-vec3(.5))-vec3(.465), 0.) )-.02)\n#define SDF(p) (length(max(abs(p-vec3(.5))-vec3(.5-R-.002), 0.) )-R)\n// try mini n=(1, 0, 0) cylinder\n//#define SDF(p) ( length((p).yz-.5)-.49 )\n//#define SDF(p) ( length((p).xy-.5)-.49 )\n\nvec4 inter_SDF (vec3 p, vec3 d) {\n    //\n    vec3 camp = p;\n    float SDFp;\n    for (int i=0; i<6020; ++i) {\n        SDFp = SDF(p);\n        if (SDFp > 1.8) { // sqrt(3)\n        //if (SDFp > .18) {\n        //if (SDFp > 20.) {\n            break;\n        }\n        else if (abs(SDFp) < 3e-5) {\n            return vec4(\n                normalize(-SDFp+vec3(\n                    SDF(p+vec3(1e-3, 0., 0.)),\n                    SDF(p+vec3(0., 1e-3, 0.)),\n                    SDF(p+vec3(0., 0., 1e-3))\n                )),\n                length(p-camp)\n            );\n            #undef inf\n        }\n        p += d*abs(SDFp)*.99;\n    }\n    return inter_sky;\n}\n\n#define SDF_plane(p, c, n) ( dot(normalize(p-c), n)*length(p-c) )\n#define inter_plane_short(p, d, c, n) (\\\n    dot(-n, d) > 1e-6 ? vec4(n, dot(c-p, -n)/dot(-n, d)) : inter_sky\\\n)\n#define inter_plane_dist(p, d, c, n) (\\\n    dot(-n, d) > 1e-6 ? dot(c-p, -n)/dot(-n, d) : inter_sky\\\n)\nvec4 inter_plane (vec3 p, vec3 d, vec3 c, vec3 n) {\n    vec4 inter_plane1;\n    inter_plane1 = inter_plane_short(p, d, c, n);\n    if (inter_plane1.w < inter_sky.w && inter_plane1.w > 0.) {\n        return inter_plane1;\n    }\n    inter_plane1 = inter_plane_short(p, d, c, -n);\n    if (inter_plane1.w < inter_sky.w && inter_plane1.w > 0.) {\n        return inter_plane1;\n    }\n    return inter_sky;\n}\n\n\n\nvec4 inter_minecraft (vec3 p, vec3 d) {\n    // return inter_SDF(fract(p), d);\n    float dist; vec4 inter_current; bool blockhere;\n    vec3 camp = p, qm, qf;\n    int missedsdf = 0;\n    // space skipping\n    vec3 pane1c = vec3(0., 6., 0.);\n    vec3 pane1n = normalize(vec3(0., 1., 0.));\n    pane1n = normalize(vec3(1.));\n    #if 1\n    if (SDF_plane(p, pane1c, pane1n) > 0.) {\n        inter_current = inter_plane(p, d, pane1c, pane1n);\n        if (inter_current.w >= inter_sky.w) {\n            // never hit bounding cube\n            return inter_sky;\n        }\n        else {\n            //\n            p += d*inter_current.w;\n            p += d*1e-3;\n        }\n    }\n    #else\n    inter_current = inter_rectprism(p_m_bouc, d, bouwhl);\n    return inter_current;\n    #endif\n    for (int voxjumps=0; voxjumps<140; ++voxjumps) {\n        //\n        if (SDF_plane(p, pane1c, pane1n) > .2) {\n            return inter_sky;\n        }\n        //\n        qf = floor(p);\n        qm = fract(p);\n        //\n        //\n        //\n        blockhere = true;\n        //\n        //\n        //blockhere = qf.y <= 0. && blockhere;\n        //blockhere = qf.x+qf.y+qf.z <= 0.;\n        blockhere = floor(qf.x/2.)+floor(qf.y/2.)+floor(qf.z/2.) <= 0.;\n        //blockhere = floor(qf.x/2.)+floor(qf.y/2.)+floor(qf.z/2.) >= -0. && blockhere;\n        //\n        //\n        //\n        if (blockhere) {\n            //\n            inter_current = inter_SDF(qm, d);\n            //\n            //\n            inter_current.w += length(p-camp);\n            vec3 wasp = p;\n            p = camp+d*inter_current.w;\n            if (inter_current.w < inter_sky.w) {\n                return inter_current;\n            }\n            p = wasp;\n            ++missedsdf;\n            if (missedsdf >= 4) {\n                return inter_sky;\n            }\n        }\n        //\n        //\n        dist = inter_sky.w;\n        // macro method\n        #if 0\n    //#define inter_plane_dist(p, d, c, n) (dot(n, d)>1e-6?dot(c-p, n)/dot(n, d):inter_sky.w)\n        //dist = min(dist, inter_plane_dist(fract(p), d, vec3(0.), vec3(-1., 0., 0.)) );\n        //dist = min(dist, inter_plane_dist(fract(p), d, vec3(0.), vec3(0., -1., 0.)) );\n        //dist = min(dist, inter_plane_dist(fract(p), d, vec3(0.), vec3(0., 0., -1.)) );\n        //dist = min(dist, inter_plane_dist(fract(p), d, vec3(1., 0., 0.), vec3(1., 0., 0.)) );\n        //dist = min(dist, inter_plane_dist(fract(p), d, vec3(0., 1., 0.), vec3(0., 1., 0.)) );\n        //dist = min(dist, inter_plane_dist(fract(p), d, vec3(0., 0., 1.), vec3(0., 0., 1.)) );\n        #else\n        // optimized method\n        dist = min(dist, qm.x/-d.x+ max(d.x +1e-6, 0.)*1e20 );\n        dist = min(dist, qm.y/-d.y+ max(d.y +1e-6, 0.)*1e20 );\n        dist = min(dist, qm.z/-d.z+ max(d.z +1e-6, 0.)*1e20 );\n        //\n      dist = min(dist,dot(vec3(1., 0., 0.)-qm, vec3(1., 0., 0.))/d.x+max(-d.x +1e-6, 0.)*1e20);\n      dist = min(dist,dot(vec3(0., 1., 0.)-qm, vec3(0., 1., 0.))/d.y+max(-d.y +1e-6, 0.)*1e20);\n      dist = min(dist,dot(vec3(0., 0., 1.)-qm, vec3(0., 0., 1.))/d.z+max(-d.z +1e-6, 0.)*1e20);\n        //\n        #endif\n        //\n        p += d*dist; p += d*2e-3;\n    }\n    //\n    return inter_sky;\n}\n\nvec3 sky_map2 (vec3 p, vec3 d) {\n    return vec3(0.4);\n    vec4 inter_current, inter_closest;\n    inter_closest = inter_sky;\n    inter_current = inter_plane(p, d, vec3(0., 30., 0.), normalize(vec3(-1.)) );\n    p += d*inter_current.w;\n    //return texture(iChannel1, p.xz*40.).rgb;\n}\n\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    //\n    //\n    vec3 randy; vec2 screen, maus; float samplei2, samplei, ox, oy;\n    //\n    vec3 retina; vec4 inter_current, inter_closest; float shiny; vec3 TEXp;\n    vec3 camp, camd, p, d; mat2 azimuth, zenith; float th, ph;\n    //\n    if (abs( (fragCoord.x-iResolution.x/2.)/(iResolution.y/2.)) > 1.) {\n        //fragColor = vec4(0., 1., 1., 1.);\n        //return;\n    }\n    //\n    th = 0.;\n    ph = 0.;\n    #if cam_maus\n    //#if 0\n    maus = (iMouse.xy-iResolution.xy/2.)/iResolution.y*2.;\n    th += maus.x*PI;\n    ph += maus.y*PI;\n    #endif\n    //\n    //\n    ph -= PI*.5-.001;\n    th += PI;\n    //ph += (.5+.5*sin(arg*PI) )*PI*.5;\n    //ph += arg*TAU;\n    ph += arg*PI*.5;\n    th += arg*PI*.5;\n    //\n    //\n    azimuth = mat2(\n        cos(th), cos(PI*.5+th),\n        sin(th), sin(PI*.5+th)\n    );\n    zenith = mat2(\n        cos(ph), cos(PI*.5+ph),\n        sin(ph), sin(PI*.5+ph)\n    );\n    //\n    #define spp 1.\n    #define spw 1.\n    fragColor.xyz = vec3(0.);\n    //\n    for (samplei2=0.; samplei2<spp*spw*spw; ++samplei2) {\n        ox = mod(samplei2, spw);\n        oy = mod(samplei2/spw, spw);\n        samplei = mod(samplei2/spw/spw, spp);\n        #if 1\n        randy = vec3(\n            fract(sin(\n                mod(\n                    samplei*21.463049023049+\n                    (float(iFrame)+fragCoord.x)*0.021415,\n                    TAU\n                )+fragCoord.y*52.2324352432\n            )),\n            fract(sin(\n                mod(\n                    samplei*421.83743204984+\n                    (float(iFrame)+fragCoord.x)*8.234203,\n                    TAU\n                )+fragCoord.y*123.242543465\n            )),\n            fract(sin(\n                mod(\n                    samplei*952.13454543556+\n                    float(iFrame)*8.234203,\n                    TAU\n                )+fragCoord.y*.003432443\n            ))\n        );\n        #undef samplei\n        #else\n        randy = vec3(0.);\n        #endif\n        //\n        screen = (fragCoord+randy.rg-iResolution.xy/2.)/iResolution.y*2.;\n        //\n        retina = vec3(0.);\n        shiny = 1.;\n        //\n        #if cam_psp\n        //#if 0\n        camp = vec3(0., 0., 0.)*.4;\n        camd = normalize(camp+vec3(screen.xy, 1.)-camp );\n        #else\n        camp = vec3(screen.xy, 0.)*4.;\n        camd = normalize(vec3(0., 0., 1.));\n        #endif\n        //\n        camd.yz = zenith*camd.yz;\n        camp.yz = zenith*camp.yz;\n        camd.xz = azimuth*camd.xz;\n        camp.xz = azimuth*camp.xz;\n        //\n        camd = normalize(camd);\n        camp.y += 10.;\n        //\n        //\n        //\n        //\n        p = camp; d = camd;\n        int reflcount = 0;\n        //\n        for (int bounces=0; bounces<33; ++bounces) {\n        //for (int bounces=0; bounces<2; ++bounces) {\n            // only have 2 bounces anyways\n            if (shiny < .1) { break; }\n            inter_closest = inter_minecraft(p, d);\n            //\n            if (inter_closest.w >= inter_sky.w) {\n                // hits sky - no shading\n                break;\n            }\n            p += d*inter_closest.w;\n            //\n            //\n            if (true) {\n                // hits object\n                //TEXp = abs(inter_closest.xyz);\n                TEXp = vec3(1.);\n                //TEXp = mix(TEXp, .5+.5*inter_closest.xyz, rrg);\n                //TEXp = vec3(1.);\n                //\n                #if 1\n                TEXp *= mod(1.+floor(p.x-.01)+floor(p.y-.01)+\n                        floor(p.z-.01), 2.);\n                #endif\n                //TEXp = vec3(1.);\n                //#define shininess .29999993\n                //#define shininess .9999993\n                #define shininess mix(1., .7, rrg);\n                //\n                //#if 0\n                // failed shadows attempt\n                //vec3 temppT;\n                //vec4 inter_shado1 = inter_tribar(p+sund*1e-2, sund, temppT);\n                //if (inter_shado1.w < inter_sky.w) {\n                //    TEXp *= .5;\n                //}\n                //#endif\n                //\n                retina += TEXp*shiny*shininess;\n                shiny *= 1.-shininess;\n                #undef shininess\n                d = reflect(d, inter_closest.xyz);\n                ++reflcount;\n                if (reflcount >= 4) {\n                    break;\n                }\n                //break;\n            }\n            //p += d*1e-3;\n            p += d*9e-3;\n        }\n        if (shiny >= 1.) {\n            //retina = vec3(0., 0., 100./255.);\n            //shiny *= 0.;\n        }\n        //retina += shiny*sky_map(d);\n        retina += shiny*sky_map2(p, d);\n        fragColor.rgb += retina;\n    }\n    //\n    fragColor.rgb /= spp*spw*spw;\n    fragColor.rgb = vec3(fragColor.r+fragColor.g+fragColor.b)/3.;\n    fragColor.a = 1.;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtXGDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2238, 2238, 2289, 2289, 2633], [2637, 2637, 2676, 2714, 5826], [5828, 5828, 5860, 5860, 6110]], "test": "valid"}
{"id": "NtXGDr", "name": "Bunch of fish in noisy water", "author": "ahmaderfani12", "description": "My practice of using noises. ", "tags": ["noise", "gradient", "gradientnoise"], "likes": 3, "viewed": 210, "published": "Public API", "date": "1621858646", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 random2d(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\nfloat random (in float x) {\n    return fract(sin(x)*1e4);\n}\n// Gradient Noise by Inigo Quilez\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2d(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2d(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2d(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2d(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nmat2 scale2d(vec2 _scale){\n    return mat2(_scale.x,0.0,\n                0.0,_scale.y);\n}\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat circle(vec2 st,float r,vec2 pos,vec2 scale){\n    st -=pos;\n    st = scale2d(scale) * st;\n    st +=pos;\n    \n    float dist = distance(st,pos);\n    dist = smoothstep(r,r+0.003,dist);\n    return dist;\n}\n\nfloat square(vec2 st, float size, vec2 pos,vec2 scale, float angle){\n    st +=pos;\n    st = scale2d(scale) * st;\n    st=rotate2d(angle) * st;\n   \n    float b = smoothstep((size),(size+0.003),abs(st.x))+  smoothstep((size),(size+0.003),abs(st.y));\n    return (clamp(b,0.0,1.));\n}\n\nvec3 fish(vec2 st,float size,vec2 pos, vec3 colorTint){\n\t\n    float time = iTime/2. * random(pos.x)*2.;\n   \t\n    float y=abs(sin(time*1.57)) * (floor(sin(time*3.14))+1.)*1.2 -0.1;\n  \t\n    pos.y=y;\n    \n   float col = circle(st,size,pos,vec2(0.910,0.480)) * ( square(st,size/1.2,1. -pos + vec2(-1.,-0.98),vec2(0.850,0.40),0.78));    \n    col = 1. - col;\n    return col * colorTint;\n}\n\nvec3 drawFishes(vec2 st){\n    vec3 fishes = vec3(0.0);\n    for(int i = 0; i <= 200; i++) { \n        fishes +=vec3(fish(st,0.005,vec2(random(float(i))*2.,0.0),vec3(0.660,0.010,0.073)));   \n    }\n   return fishes;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  //Adjust uv\n    vec2 st = fragCoord/iResolution.xy;\n    st.x *=  iResolution.x/iResolution.y;\n    \n    //St scaler\n    float gridMultiplier=10.;\n    \n    //Fish and water colors\n    vec3 color = vec3(0.0);\n\tvec3 colorA=vec3(0.017,0.037,0.975);\n    vec3 colorB=vec3(0.379,1.000,0.962);\n    \n    //Set uvs(st)\n    st *=gridMultiplier;\n     vec2 fishSt= st+(noise(st+(iTime*1.0)))/3.;\n\tst += noise(st+vec2(0.0,-iTime*2.2));  \n    \n    //Get noise for water\n    float waterWave = noise(st)*0.5 + 0.5;\n    \n    color =  mix(colorA, colorB, waterWave);\n    color  = color +  drawFishes(fishSt/gridMultiplier) ;\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtXGDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 162], [163, 163, 190, 190, 222], [223, 257, 279, 279, 687], [689, 689, 715, 715, 778], [779, 779, 807, 807, 893], [895, 895, 945, 945, 1101], [1103, 1103, 1171, 1171, 1381], [1383, 1383, 1438, 1438, 1765], [1767, 1767, 1792, 1792, 1980], [1982, 1982, 2039, 2053, 2681]], "test": "valid"}
{"id": "NtXGRH", "name": "SDF chopper", "author": "shyuriken", "description": "joetech's \"SDF Editor\" is prototype. There are still few functions, but it can be designed visually.\nI made a converter  form \"SDF Editor output\" to shadertoy code.\nhttps://github.com/ultrahamlet/cnvSDF2", "tags": ["raymarching", "sdf", "modeling"], "likes": 1, "viewed": 79, "published": "Public", "date": "1621484859", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Adapted from original shader: https://www.shadertoy.com/view/ldcyW4\n// modeled by https://joetech.itch.io/sdf-editor\n// converted by https://github.com/ultrahamlet/cnvSDF2\n//----------------------------------------------------------------\n// Processed by 'GLSL Shader Shrinker' (Shrunk by 1,985 characters)\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n\n#define LIGHT\tnormalize(vec3(1, 1, 0))\n\nmat3 rotateMat(vec3 p, float angle, vec3 axis) {\n\tvec3 a = normalize(axis);\n\tfloat s = sin(angle),\n\t      c = cos(angle),\n\t      r = 1. - c;\n\treturn mat3(a.x * a.x * r + c, a.y * a.x * r + a.z * s, a.z * a.x * r - a.y * s, a.x * a.y * r - a.z * s, a.y * a.y * r + c, a.z * a.y * r + a.x * s, a.x * a.z * r + a.y * s, a.y * a.z * r - a.x * s, a.z * a.z * r + c);\n}\n\nvec3 mTranslation(vec3 inv_translation, vec3 p) { return p + inv_translation; }\n\nvec3 mRotation(mat3 inv_rotation, vec3 p) { return inv_rotation * p; }\n\nfloat pEllipsoid(vec3 r, vec3 p) {\n\tfloat k0 = length(p / r);\n\treturn k0 * (k0 - 1.) / length(p / (r * r));\n}\n\nfloat oUnion(float d1, float d2) { return min(d1, d2); }\n\nfloat sdf(vec3 p0) {\n\tfloat d2, d3, d4, d5, d6, d7, d8,\n\t      d1 = pEllipsoid(vec3(2), p0);\n\t{\n\t\tvec3 p1 = mTranslation(vec3(-3, -1, 0), p0);\n\t\t{ d2 = pEllipsoid(vec3(4, 1, .5), mRotation(mat3(.96592583, -.25881905, 0, .25881905, .96592583, 0, 0, 0, 1), p1)); }\n\t}\n\t{\n\t\tvec3 p1 = mTranslation(vec3(-7, -2, -.3), p0);\n\t\t{ d3 = pEllipsoid(vec3(.9, .9, .1), mRotation(mat3(1, 0, 0, 0, 1, 0, 0, 0, 1), p1)); }\n\t}\n\t{\n\t\tvec3 p1 = mTranslation(vec3(0, -2.6, 0), p0);\n\t\t{\n\t\t\tmat3 mt = rotateMat(p1, iTime, vec3(0, 1, 0));\n\t\t\tvec3 p2 = mRotation(mt, p1);\n\t\t\td4 = pEllipsoid(vec3(5, .1, .2), p2);\n\t\t\td5 = pEllipsoid(vec3(.2, .1, 5), p2);\n\t\t}\n\t}\n\t{ d6 = pEllipsoid(vec3(.2, 2, .2), mTranslation(vec3(0, -1.1, 0), p0)); }\n\t{ d7 = pEllipsoid(vec3(2, .6, .6), mTranslation(vec3(0, .9, -1.8), p0)); }\n\t{ d8 = pEllipsoid(vec3(2, .6, .6), mTranslation(vec3(0, .9, 1.8), p0)); }\n\treturn oUnion(d1, oUnion(d2, oUnion(d3, oUnion(d5, oUnion(d4, oUnion(d6, oUnion(d7, d8)))))));\n}\n\nvec3 RayMarch(vec3 rayDir, vec3 cameraOrigin) {\n\tfloat dist = .01,\n\t      totalDist = 0.,\n\t      itter = 0.;\n\tvec3 pos = cameraOrigin;\n\tfor (int i = 0; i < 128; i++) {\n\t\tdist = sdf(pos);\n\t\titter++;\n\t\ttotalDist += dist;\n\t\tpos += dist * rayDir;\n\t\tif (dist < .01 || totalDist > 30.) break;\n\t}\n\n\treturn vec3(dist, totalDist, itter / 128.);\n}\n\nfloat AO(vec3 pos, vec3 n) {\n\tfloat res = 0.;\n\tvec3 aopos = pos;\n\tfor (int i = 0; i < 3; i++) {\n\t\taopos = pos + n * .2 * float(i);\n\t\tfloat d = sdf(aopos);\n\t\tres += d;\n\t}\n\n\treturn clamp(res, 0., 1.);\n}\n\nmat3 SetCamera(vec3 ro, vec3 ta, float cr) {\n\tvec3 cw = normalize(ta - ro),\n\t     cu = normalize(cross(cw, vec3(sin(cr), cos(cr), 0)));\n\treturn mat3(cu, normalize(cross(cu, cw)), cw);\n}\n\nvec4 NorCurv(vec3 p) {\n\tconst vec2 e = vec2(-.01, .01);\n\tfloat t1 = sdf(p + e.yxx),\n\t      t2 = sdf(p + e.xxy),\n\t      t3 = sdf(p + e.xyx),\n\t      t4 = sdf(p + e.yyy);\n\treturn vec4(normalize(e.yxx * t1 + e.xxy * t2 + e.xyx * t3 + e.yyy * t4), .25 / e.y * (t1 + t2 + t3 + t4 - 4. * sdf(p)));\n}\n\nvec3 Lighting(vec3 n, vec3 rayDir, vec3 reflectDir, vec3 pos) { return vec3(max(0., dot(LIGHT, n)), pow(max(0., dot(reflectDir, LIGHT)), 10.), 1. - max(0., dot(-n, rayDir))) * .5; }\n\nfloat TriplanarTexture(vec3 pos, vec3 n) { return 0.; }\n\nfloat BackGround(vec3 rayDir) { return smoothstep(1., 0., clamp(length(rayDir - LIGHT), 0., 1.)) * .5; }\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec3 cameraOrigin = vec3(0);\n\tif (iMouse.z > 0.) {\n\t\tcameraOrigin.x = sin(iMouse.x * .01) * 5.;\n\t\tcameraOrigin.y = iMouse.y * .05 - 10.;\n\t\tcameraOrigin.z = cos(iMouse.x * .01) * 5.;\n\t}\n\telse {\n\t\tcameraOrigin.x = sin(iTime * .25 + 2.) * (6. + sin(iTime * .1));\n\t\tcameraOrigin.y = sin(iTime * .3) - .5;\n\t\tcameraOrigin.z = cos(iTime * .25 + 2.) * (6. + sin(iTime * .15)) - 15.;\n\t}\n\n\tvec2 screenPos = uv * 2. - 1.;\n\tscreenPos.x *= iResolution.x / iResolution.y;\n\tmat3 cam = SetCamera(cameraOrigin, vec3(0, .25, -1), sin(iTime * .15) * .5);\n\tvec3 rayDir = cam * normalize(vec3(screenPos, 2)),\n\t     dist = RayMarch(rayDir, cameraOrigin);\n\tfloat res,\n\t      backGround = BackGround(rayDir);\n\tif (dist.x < .01) {\n\t\tvec3 l,\n\t\t     pos = cameraOrigin + dist.y * rayDir;\n\t\tvec4 n = NorCurv(pos);\n\t\tfloat col,\n\t\t      ao = AO(pos, n.xyz);\n\t\tl = Lighting(n.xyz, rayDir, reflect(rayDir, n.xyz), pos);\n\t\tcol = TriplanarTexture(pos, n.xyz);\n\t\tcol *= n.w * .5 + .5;\n\t\tcol *= ao;\n\t\tcol += ao * (l.x + l.y);\n\t\tcol += l.z * .75;\n\t\tcol += BackGround(n.xyz) * .25;\n\t\tres = col;\n\t}\n\telse res = backGround;\n\n\tfragColor = vec4(vec3(res), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtXGRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[407, 407, 455, 455, 770], [772, 772, 821, 821, 851], [853, 853, 896, 896, 923], [925, 925, 959, 959, 1034], [1036, 1036, 1070, 1070, 1092], [1094, 1094, 1114, 1114, 2053], [2055, 2055, 2102, 2102, 2392], [2394, 2394, 2422, 2422, 2594], [2596, 2596, 2640, 2640, 2781], [2783, 2783, 2805, 2805, 3075], [3077, 3077, 3140, 3140, 3258], [3260, 3260, 3302, 3302, 3315], [3317, 3317, 3348, 3348, 3421], [3423, 3423, 3475, 3475, 4638]], "test": "valid"}
{"id": "sd2XD3", "name": "strange blob", "author": "high_byte", "description": "I really don't know", "tags": ["blob"], "likes": 1, "viewed": 48, "published": "Public", "date": "1621195154", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Exact euclidean distance to a box frame\n\n// List of other 3D SDFs: https://www.shadertoy.com/playlist/43cXRl\n//\n// and http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (sqrt(5.0)*0.5 + 0.5)\n\n float fBlob(vec3 p) {\n\tp = abs(p);\n\tif (p.x < max(p.y, p.z)) p = p.yzx;\n\tif (p.x < max(p.y, p.z)) p = p.yzx;\n\tfloat b = max(max(max(\n\t\tdot(p, normalize(vec3(1, 1, 1))),\n\t\tdot(p.xz, normalize(vec2(PHI+1.0, 1.0)))),\n\t\tdot(p.yx, normalize(vec2(1.0, PHI)))),\n\t\tdot(p.xz, normalize(vec2(1.0, PHI))));\n\tfloat l = length(p);\n\treturn l - 0.35 - 0.2 * (1.5 / 2.0)* cos(min(sqrt(1.02 - b / l)*(PI / 0.25), PI));\n}\n\nfloat map( in vec3 pos )\n{\n    return fBlob(pos);\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n#define AA 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.5*(iTime-10.0);\n\tvec3 ro = 1.2*vec3( 1.0*cos(an), 0.2*cos(iTime), 1.0*sin(an) + 0.5*cos(an) );\n    vec3 ta = vec3( 0.0, -0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n   \n    // render    \n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 5.0;\n        float t = 0.0;\n        for( int i=0; i<25; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h*0.45;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        //if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.87703)), 0.0, 1.0 );\n            float amb = 0.5 + 0.8*dot(nor,vec3(0.0,1.0,0.0));\n            col = vec3(0.5,0.3,0.4)*amb + vec3(0.15,0.75,0.65)*dif;\n        }\n\n        // gamma        \n        col = col + 0.4*sin(iTime); //sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd2XD3.jpg", "access": "shaders20k", "license": "mit", "functions": [[1345, 1345, 1366, 1366, 1748], [1750, 1750, 1776, 1776, 1801], [1803, 1867, 1899, 1899, 2138]], "test": "valid"}
{"id": "sd2XWV", "name": "flow color", "author": "bythesword", "description": "flow color", "tags": ["flowcolor"], "likes": 16, "viewed": 232, "published": "Public", "date": "1621077360", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv =  (2.0 * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    for(float i = 1.0; i < 10.0; i++){\n        uv.x += 0.6 / i * cos(i * 2.5* uv.y + iTime);\n        uv.y += 0.6 / i * cos(i * 1.5 * uv.x + iTime);\n    }\n    vec3 col = 0.5 + 0.5*sin(iTime+uv.xyx+vec3(0,2,4));\n    fragColor = vec4(col/(2.1*abs(cos(iTime-uv.y-uv.x))),1.0);\n    //https://www.shadertoy.com/view/WtdXR8\n    //fragColor = vec4(vec3(0.1)/abs(sin(iTime-uv.y-uv.x)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd2XWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 528]], "test": "valid"}
{"id": "sdBSDt", "name": "Pijpleiding naar Okkie's snor", "author": "evvvvil", "description": "Winning shader made at Outline 2021 Shader Showdown Final\nLive coded on stage in 25 minutes.  Designed beforehand in several hours.\n", "tags": ["noise", "demoscene", "landscape", "caustics", "underwater", "glow", "blend", "organic", "material", "smooth", "lazer", "merge", "plateau", "moustache"], "likes": 35, "viewed": 1045, "published": "Public", "date": "1621263511", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Winning shader made at Outline 2021 Shader Showdown Final\n\n// The \"Shader Showdown\" is a demoscene live-coding shader battle competition.\n// 2 coders battle for 25 minutes making a shader on stage. No google, no cheat sheets.\n// The audience votes for the winner by making noise or by voting on their phone.\n\n// This shader was coded live on stage in 25 minutes. Designed beforehand in several hours.\n\nvec2 z,v,e=vec2(.00035,-.00035);float t,tt,b,g,gg,tn,a,la,pa;vec3 op,bp,pp,po,no,al,ld;vec4 np; //global variables\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));} // simple rotate 2d function\nfloat smin(float a,float b,float k){ float h=max(0.,k-abs(a-b));return min(a,b)-h*h*.25/k;} //smooth blend addition geometry function\nfloat smax(float a,float b,float k){ float h=max(0.,k-abs(-a-b));return max(-a,b)+h*h*.25/k;} //smooth blend substraction geometry function\nvec2 smin( vec2 a, vec2 b,float k ){ float h=clamp(.5+.5*(b.x-a.x)/k,.0,1.);return mix(b,a,h)-k*h*(1.0-h);} //smooth blend add both geometries AND mateiral ID / colour together\nvec4 texNoise(vec2 uv,sampler2D tex ){ float f = 0.; f+=texture(tex, uv*.125).r*.5; f+=texture(tex,uv*.25).r*.25; //Funciton simulating the perlin noise texture we have in Bonzomatic shader editor, written by yx\n                       f+=texture(tex,uv*.5).r*.125; f+=texture(tex,uv*1.).r*.125; f=pow(f,1.2);return vec4(f*.45+.05);}\nvec2 mp( vec3 p)\n{\n  op=p; //remember original position\n  p.z=mod(p.z+tt*2.,20.)-10.; //modulo everything along z to repeat\n  tn=texNoise((op.xz+vec2(.4,tt*2.))*.05,iChannel0).r; //perlin noise (texNoise  perlin texture in Bonzomatic)\n  vec2 h=vec2(1000,1.),t=vec2(p.y+4.9+tn*4.+sin((op.z+tt*2.)*.5)*.5,0.); t.x*=0.6; //define white material id 0, define blue material id 1 with terrain with perlin noise and some diform\n  np=vec4(p,1); //setup our position np as vec4 so we can track np scale in the .w to use np.w as divider to avoid artifact, line 28 + 29\n  for(int i=0;i<3;i++){ //loop 3 times\n    np.xz=abs(np.xz)-14.; //each iter mirrror symatery clone push out a bit\n    a=length(np.xz)+tn*2.5+p.y*1.55+float(i)+cos(p.x*.5)*2.+sin(p.y*15.)*.1; //make mountain features on terrain which we will cut after, line 32+33\n    np.xz-=cos(p.x);//wave deform everything along x axis\n    np*=2.; //scale everything down twice each iter\n   t.x=smin(t.x,a/np.w,1.5); //add mountain feature to blue terrain with smooth blend\n   h.x=smin(h.x,a/np.w+.1,1.3); //add mountain feature to white material with smooth blend\n   h.x=smin(h.x,.8*(length(np.zy+vec2(0,12.+float(i)*7.5))-.7-tn)/np.w,.8); //add horizontal wavey tubes along x axis\n  }\n  t.x=max(t.x,p.y+3.*(1.-tn*.2)); //cut mountain blue terrain to make a \"plateau\", with noise so it's not totally \"flat\"\n  h.x=max(h.x,p.y+2.2*(1.-tn*.5)); //cut mountain white terrain to make a plateau, but bit higher, , with noise so it's not totally \"flat\"\n  pp=op+vec3(0,5,0);pp.x=abs(abs(pp.x)-8.)-4.; //setup position for side tunnels, we will use position in infinite cylinder to cut tunnels\n  a=length(pp.xy)-1.-tn+cos(p.z*.2)*.3; //make both infinite cylinder with position from above to dig tunnels in terrains\n  bp=op;bp.x=abs(abs(abs(bp.x+4.)-8.)-4.)-1.; //prepare position for the white pipeline tubes\n  h.x=smin(h.x,.9*(length(bp.xy+vec2(0,5.5+cos(p.x*.2)))-.9),1.); //Add white pipeline tubes to white material with smooth blend\n  t.x=smax(a,t.x,.5); //dig out tunnel from blue terrain using inifnite tunnel cylinder from line 35\n  h.x=smax(a+.5,h.x,.5); //dig out tunnel from white terrain using inifnite tunnel cylinder from line 35\n  pp.xy*=r2(.785+sin(op.z*.2)+tt); //we gonna reuse the tunnel position for lazers, so rotate it along z here\n  la=length(abs(pp.xy)-vec2(.3)); //carete lazers based on tunnel position which we rotated above\n  b=cos(p.z*.5); //particle offset / dance along z axisgiving them a cool bop \n  pa=max(length(cos(op*.75+vec3(b,b*.5-tt,cos(p.x)))),abs(p.x)-10.); //make particles as 0 radius spheres, using cos of original op position and animated up  wish dance bop offset\n  g+=0.1/(0.1+la*la*(80.-79.5*sin(op.z*.5+tt*2.+tn*5.))); //push lazer into blue glow variable to add glow at end (see last line)\n  gg+=0.1/(0.1+pa*pa*500.);//push particles into white glow variable to add glow at end (see last line)\n  h.x=min(la,h.x); //add lazers to white material so it doesn't glitch\n  t=smin(t,h,.2); //MATERIAL SMOOTH BLEND. In all caps as people tend to ask how to do this. Yes it blends both geometries of white and blue material AS WELL as material ID +colour itself(see line 83)\n  t.x=min(t.x,pa); //Add mmarticle to result scene so it doesn't glitch\n  return t;\n}\nvec2 tr( vec3 ro,vec3 rd ) //simple raymarching function / loop\n{\n  vec2 h,t=vec2(.1); //near plane\n  for(int i=0;i<128;i++){ //march forward up to 128 times\n  h=mp(ro+rd*t.x); //get distance from scene\n    if(h.x<.0001||t.x>40.) break; //if we are too close we hit something we stop, also if we gone too far, we stop (far plane)\n    t.x+=h.x;t.y=h.y; //jump forward to how far we are from geom to optimize and remember material ID\n    if(t.x>40.) t.y=-1.; //vauge optmization for later line 77, jurry is still out on this one...\n  }\n  return t;\n}\n#define a(d) clamp(mp(po+no*d).x/d,0.,1.) \n#define s(d) smoothstep(0.,1.,mp(po+ld*d).x/d)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) //above a(d) is Ambient Occlusion and s(d) is Sub surface scatterring\n{\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1); //get uv\n  tt=12.+mod(iTime,62.83); //modulo time to avoid glitches past 2-3 minutes due to sin floating point precision\n  vec3 ro=mix(vec3(4,-5,-10), vec3(cos(tt*.4+1.)*3.,-cos(tt*.4),-10), ceil(cos(tt*.4))), //ro is ray origin aka camera position\n  cw=normalize(vec3(0,-7,0)-ro), //making a camera, vec3(0,-7,0) is the camera target\n  cu=normalize(cross(cw,vec3(0,1,0))), //making a camera, vec3(0,1,0) is the up vector\n  cv=normalize(cross(cu,cw)), //making a camera,\n  rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),co,fo;  //making a camera,0.5 is the field of view\n  tn=texNoise(rd.xy*10.,iChannel0).r; //sample perlin noise to soften pseudo background caustics\n  co=fo=vec3(.05,.2,.5)+rd.y*.2-cos(rd.x*(20.)+tt)*(.15*tn); //background colour is blue with gradient along camera direction y and with p[seudo caustic wave soften out with noise\n  ld=normalize(vec3(.2,.5,-.5)); //light direction is from above\n  z=tr(ro,rd);t=z.x; //draw scene, cast ray\n  if(z.y>-1.){ //if material id is more than -1 than we muist have hit something\n    po=ro+rd*t; //get position of where we hit \n    no=normalize(e.xyy*mp(po+e.xyy).x+e.yyx*mp(po+e.yyx).x+e.yxy*mp(po+e.yxy).x+e.xxx*mp(po+e.xxx).x); //get normals of where we hit based on position above\n    al=mix(vec3(.1,.2,.5)-tn*.4,vec3(.5),z.y); //Reusing mmaterial ID as smoothblend to merge both material colours\n    al+=pow((sin(po.x*2.+tt*2.)*.5+.5)*(sin(po.z*2.+tt*2.)*.5+.5),2.)*.5; //add size coded  pseudo-caustics\n    float dif=max(0.,dot(no,ld)), //diffuse lighting\n    fr=pow(1.+dot(no,rd),4.), //fresnel reflections\n    sp=pow(max(dot(reflect(-ld,no),-rd),0.),40.); //specular lighting\n    co=mix(sp*0.2+al*(a(.1)*a(.2)+.2)*(dif+s(.2))*vec3(.5,.7,1.),fo,min(fr,.5)); //final lighting is specular + albedo base colour * ambient occlusion twice + .2 ambient lighting * diffuse + subsurface scattering, then softened with fresnel\n    co=mix(fo,co,exp(-.0001*t*t*t));//add pretty heavy fog\n  }\n  co=mix(co,co.xzy,length(uv)*.5); //gradient colours based on circle from center, nice size-coded colouring trick\n  fragColor = vec4(pow(co+gg*.2+g*.2*vec3(.1,.2,.7),vec3(.55)),1); //return final colour with white and blue glows and bit of gamma correction\n}", "image_inputs": [{"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdBSDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[501, 520, 537, 537, 580], [581, 610, 646, 646, 701], [702, 744, 780, 780, 837], [838, 884, 920, 920, 991], [992, 1061, 1099, 1099, 1393], [1394, 1394, 1412, 1412, 4634], [4635, 4635, 4700, 4700, 5182], [5273, 5273, 5400, 5400, 7681]], "test": "error"}
{"id": "sdBSDz", "name": "smoothstep hue cycle", "author": "RavenWorks", "description": "smoother than the traditional, but it still hits the six primaries and secondaries unlike that siney one whose name I can't remember", "tags": ["color", "demo", "hue", "smooth"], "likes": 0, "viewed": 140, "published": "Public API", "date": "1620004431", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float slowSawStraight(float x){\n    float result = min(1.0, mod(x,0.5)*6.0);\n    if (mod(x,1.0) >= 0.5) result = 1.0-result;\n    return result;\n}\nvec3 slowSawStraightThree(float x){\n    return vec3(\n        slowSawStraight(x+0.0),\n        slowSawStraight(x+1.0/3.0),\n        slowSawStraight(x+2.0/3.0)\n    );\n}\n\nfloat slowSawSmooth(float x){\n    float result = smoothstep(0.0,1.0, mod(x,0.5)*6.0);\n    if (mod(x,1.0) >= 0.5) result = 1.0-result;\n    return result;\n}\nvec3 slowSawSmoothThree(float x){\n    return vec3(\n        slowSawSmooth(x),\n        slowSawSmooth(x+1.0/3.0),\n        slowSawSmooth(x+2.0/3.0)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    vec2 uv = fragCoord/iResolution.xy;\n\n    float hueVal = iTime*0.2+uv.x;\n    vec3 col = slowSawSmoothThree(hueVal);\n    if (uv.y < 0.2) col = slowSawStraightThree(hueVal);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdBSDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 145], [146, 146, 181, 181, 310], [312, 312, 341, 341, 466], [467, 467, 500, 500, 619], [621, 621, 677, 677, 891]], "test": "valid"}
{"id": "sdBXWt", "name": "Bouncing dotted ball", "author": "mrange", "description": "I wanted to recreate the classic dotted balls so common during the Amiga era\nThen I messed around a bit more.\n", "tags": ["3d", "retro"], "likes": 36, "viewed": 394, "published": "Public API", "date": "1621259549", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Licence CC0: Bouncing dotted ball\n//  I wanted to recreate the classic dotted balls so common during the Amiga era\n//  Then I messed around a bit more.\n\n#define PI            3.141592654\n#define TAU           (2.0*PI)\n#define ROT(a)        mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PCOS(x)       (0.5 + 0.5*cos(x))\n#define DOT2(x)       dot(x, x)\n#define TIME          iTime\n#define RESOLUTION    iResolution\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst float beat          = 2.0*60.0/125.0;\nconst vec3  grid_color    = HSV2RGB(vec3(0.6, 0.6, 1.0)); \nconst vec3  plate_color   = HSV2RGB(vec3(0.0, 0.0, 0.125)); \nconst vec3  plane_color   = HSV2RGB(vec3(0.7, 0.125, 1.0/32.0)); \nconst vec3  light0_color  = 16.0*HSV2RGB(vec3(0.6, 0.5, 1.0)); \nconst vec3  light1_color  = 8.0*HSV2RGB(vec3(0.9, 0.25, 1.0)); \nconst vec3  sky0_color    = HSV2RGB(vec3(0.0, 0.65, 0.95)); \nconst vec3  sky1_color    = HSV2RGB(vec3(0.6, 0.5, 0.5)); \nconst vec3  light0_pos    = vec3(3.0, 4.0, 4.0);\nconst vec3  light1_pos    = vec3(-3.0, 2.0, -8.0);\nconst vec3  light0_dir    = normalize(light0_pos);\nconst vec3  light1_dir    = normalize(light1_pos);\nconst vec4  planet_sph    = vec4(50.0*normalize(light1_dir+vec3(0.025, -0.025, 0.0)), 10.0);\nconst float truchet_lw    = 0.05;\nconst mat2[] truchet_rots = mat2[](ROT(0.0*PI/2.0), ROT(1.00*PI/2.0), ROT(2.0*PI/2.0), ROT(3.0*PI/2.0));\n\nconst float period        = 18.0;\n\n// IQ's soft minimum: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.7*(b-a)/k, 0.0, 1.0);\n  return mix(b,a,h) - k*h*(1.0-h);\n}\n\n// From: http://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n// IQ's ray plane intersect: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n// IQ's ray sphere intersect: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nvec2 raySphere(vec3 ro, vec3 rd, vec4 sph) {\n  vec3 oc = ro - sph.xyz;\n  float b = dot( oc, rd );\n  float c = dot( oc, oc ) - sph.w*sph.w;\n  float h = b*b - c;\n  if (h < 0.0) return vec2(-1.0);\n  h = sqrt(h);\n  return vec2(-b - h, -b + h);\n}\n\nvec3 toSpherical(vec3 p) {\n  float r   = length(p);\n  float t   = acos(p.z/r);\n  float ph  = atan(p.y, p.x);\n  return vec3(r, t, ph);\n}\n\nvec3 toRect(vec3 p) {\n  return p.x*vec3(cos(p.z)*sin(p.y), sin(p.z)*sin(p.y), cos(p.y));\n}\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nfloat hash(vec2 co) {\n  return fract(sin(dot(co, vec2(12.9898,58.233))) * 13758.5453);\n}\n\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat grid(vec2 p, float f, float mf) {\n  const float steps = 20.0;\n  vec2 gz = vec2(PI/(steps*mf), PI/steps);\n  vec2  n = mod2(p, gz);\n  p.y     *= f;\n  float d = min(abs(p.x), abs(p.y))-0.00125;\n  return d;\n}\n\nfloat dots(vec2 p, float f) {\n  const vec2 gz = vec2(PI/128.0);\n  vec2  n = mod2(p, gz);\n  p.y     *= f;\n  float d = length(p)-0.00125;\n  float r = hash(n+124.0);\n  \n  return d;\n}\n\nfloat plates(vec2 p, float f, float mf) {\n  vec2 gz = vec2(PI/(64.0*mf), PI/64.0);\n  vec2  n = mod2(p, gz);\n  p.y     *= f;\n  float r = hash(n+124.0);\n  \n  if (-1.5*sin(TAU*TIME/period)+r < f) {\n    return 1E6;\n  } else {\n    return 0.0;\n  }\n}\n\nfloat truchet_cell0(vec2 p, float h) {\n  float d0  = circle(p-vec2(0.5), 0.5);\n  float d1  = circle(p+vec2(0.5), 0.5);\n\n  float d = 1E6;\n  d = min(d, d0);\n  d = min(d, d1);\n  return d;\n}\n\nfloat truchet_cell1(vec2 p, float h) {\n  float d0  = abs(p.x);\n  float d1  = abs(p.y);\n  float d2  = circle(p, mix(0.2, 0.4, h));\n\n  float d = 1E6;\n  d = min(d, d0);\n  d = min(d, d1);\n  d = min(d, d2);\n  return d;\n}\n\nfloat truchet(vec2 p, float f, float sections) {\n  float z = TAU/sections; \n  \n  vec2 hp = p/z;\n  hp.x -= sections/4.0;\n  vec2 lp = hp;\n  lp.x = abs(lp.x);\n\n  \n  vec2 hn = mod2(hp, vec2(1.0));\n  float r = hash(hn);\n\n  hp *= truchet_rots[int(r*4.0)];\n  float rr = fract(r*131.0);\n  float cd0 = truchet_cell0(hp, rr);\n  float cd1 = truchet_cell1(hp, rr);\n\n  float d = mix(cd0, cd1, float(fract(r*113.0) > 0.5));\n\n  float ld = lp.x-sections/6.0; \n\n  d = max(d, ld);\n  d = min(d, abs(ld));\n  d = abs(d) - truchet_lw;\n\n  return d*z;\n}\n\nfloat truchet(vec2 p, float f) {\n  float n = floor((TIME-2.0)/period);\n  float r = hash(0.1*n+100.0);\n  float sections = 11.0+2.0*floor(15.0*r*r);\n  float d = truchet(p, f, sections);\n  return d;\n}\n\nfloat bounce() {\n  float tm = TIME/beat;\n  float t = fract(tm*1.0)-0.5;\n  return 0.25 - t*t;\n}\n\nvoid lighting(vec3 pos, vec3 nor, vec3 ref, out vec3 ld0, out vec3 dif0, out vec3 ld1, out vec3 dif1) {\n  float ll0 = 0.05*DOT2(light0_pos-pos);\n  float ll1 = 0.05*DOT2(light1_pos-pos);\n  ld0       = normalize(light0_pos-pos);\n  ld1       = normalize(light1_pos-pos);\n  dif0      = light0_color*max(dot(nor, ld0), 0.0)/ll0;\n  dif1      = light1_color*max(dot(nor, ld1), 0.0)/ll1;\n}\n\nvec3 renderBackground(vec3 ro, vec3 rd, vec3 nrd, vec4 sph) {\n  vec3 sky  = smoothstep(1.0, 0.0, rd.y)*sky1_color+smoothstep(0.5, 0.0, rd.y)*sky0_color;\n\n  vec2 pi = raySphere(ro, rd, planet_sph);\n\n  float lf1 = 1.0;\n  if (pi.x > 0.0) {\n    vec3 ppos = ro+rd*pi.x;\n    float t = 1.0-tanh_approx(1.5*(pi.y - pi.x)/planet_sph.w);\n    sky *= mix(0.5, 1.0, t);\n    lf1 = t;\n  }\n\n  sky += pow(max(dot(rd, light0_dir), 0.0), 800.0)*light0_color; \n  sky += lf1*pow(max(dot(rd, light1_dir), 0.0), 150.0)*light1_color; \n\n  if(rd.y > 0.0) return sky;\n\n  // As suggested by elenzil in the comments\n  float py  = 1.0 + 0.2 * smoothstep(-0.05, 0.1, bounce());\n  float t   = rayPlane(ro, rd, vec4(vec3(0.0, py, 0.0), 0.5));\n\n  vec3 pos  = ro + t*rd;\n  vec3 npos = ro + t*nrd;\n  float aa  = length(npos-pos);\n\n  vec3 nor  = vec3(0.0, 1.0, 0.0);\n  vec3 ref  = reflect(rd, nor); \n  vec3 nref = reflect(nrd, nor); \n\n\n  vec3 ld0 ;\n  vec3 ld1 ;\n  vec3 dif0; \n  vec3 dif1;\n  lighting(pos, nor, ref, ld0, dif0, ld1, dif1);\n\n  vec2 si0 = raySphere(pos, ld0, sph);\n\n  vec2 pp = pos.xz;\n  vec2 op = pp;\n  pp += TIME*0.513;\n  \n  vec2 np = mod2(pp, vec2(0.6));\n  \n  float sha0 = si0.x < 0.0 ? 1.0 : (1.0-1.0*tanh_approx((si0.y-si0.x)*2.5/(0.5+.5*si0.x)));\n  dif0 *= sha0;\n  \n  vec3 col = vec3(0.0);\n\n  float ll = 2.0*DOT2(op);\n  \n  float d = pmin(abs(pp.x), abs(pp.y), 0.05);\n\n  float gm = PCOS(-TAU/beat*TIME+0.25*TAU*length(op));\n  col += mix(vec3(0.75), 2.0*vec3(3.5, 2.0, 1.25), gm)*exp(-mix(400.0, 100.0, gm)*max(d-0.00125, 0.0));\n  col /= (1.0+ll);\n\n  col += plane_color*(dif0+dif1); \n\n  \n  return mix(sky, col, tanh_approx(500.0/(1.0 + DOT2(pos))));\n}\n\nvec3 renderBall(vec3 ro, vec3 rd, vec3 nrd, vec4 sph, vec2 t2) {\n  vec3 pos  = ro + t2.x*rd;\n  vec3 npos = ro + t2.x*nrd;\n  float aa  = length(npos-pos);\n\n  vec3 sp   = pos - sph.xyz;\n  vec3 nor  = normalize(sp);\n  vec3 ref  =reflect(rd, nor); \n  vec3 nref =reflect(nrd, nor); \n  \n  vec3 ld0 ;\n  vec3 ld1 ;\n  vec3 dif0; \n  vec3 dif1;\n  lighting(pos, nor, ref, ld0, dif0, ld1, dif1);\n  \n  sp.yz    *= ROT(TIME*sqrt(0.5));\n  sp.xy    *= ROT(TIME*1.234);\n  vec3 ssp = toSpherical(sp.zxy);\n\n  vec2  pp = ssp.yz;\n  float f  = sin(pp.x); \n\n  float lf2 = -ceil(log(f)/log(2.0));\n  float mf = pow(2.0, lf2);\n\n  float gd = grid(pp, f, mf);\n  float dd = dots(pp, f);\n  float pd = plates(pp, f, mf);\n  float td = truchet(pp, f);\n\n  vec3 rcol= renderBackground(ro, ref, nrd, sph);\n  \n  vec3 col = vec3(0.0);\n  col = mix(col, vec3(1.0), smoothstep(-aa, aa, -dd));\n  vec3 gcol = vec3(0.0); \n  gcol -= 0.5*vec3(1.0, 2.0, 2.0)*exp(-100.0*max(td+0.01, 0.0));\n  gcol = mix(gcol, vec3(0.1, 0.09, 0.125), smoothstep(-aa, aa, -(td+0.005)));\n  gcol += 8.0*vec3(2.0, 1.0, 1.0)*exp(-900.0*abs(td-0.00125));\n  gcol = mix(gcol, 0.5*(plate_color*(dif0+dif1)), vec3(pd > 0.0));\n  col += clamp(gcol, -1.0, 1.0);\n  col = mix(col, grid_color, smoothstep(-aa, aa, -gd));\n  \n  float b = smoothstep(0.15, 0.0, dot(nor, -rd));\n  col *= tanh_approx(1.0*abs(t2.y-t2.x)/sph.w);\n  \n  return col+rcol*(pd <= 0.0 ? 0.275 : 0.1);\n}\n\nvec3 effect(vec2 p, vec2 q) { \n  vec3 ro = 0.65*vec3(2.0, 0, 0.2)+vec3(0.0, 0.5, 0.0);\n  ro.xz *= ROT(TIME*0.312);\n  vec3 la = vec3(0.0,0.125, 0.0); \n\n  vec2 np = p + vec2(4.0/RESOLUTION.y); \n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww));\n  vec3 vv = normalize(cross(ww,uu));\n  float rdd = 2.0;\n  vec3 rd = normalize(p.x*uu + p.y*vv + rdd*ww);\n  vec3 nrd= normalize(np.x*uu + np.y*vv + rdd*ww);\n  \n  vec4 sph= vec4(vec3(0.0, bounce(), 0.0), 0.5);\n  \n  vec2 si = raySphere(ro, rd, sph);\n\n  if (si.x >= 0.0) {\n    return renderBall(ro, rd, nrd, sph, si);\n  } else {\n    return renderBackground(ro, rd, nrd, sph);\n  }\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col = clamp(col, 0.0, 1.0);\n  col = pow(col, vec3(1.0/2.2));\n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1.0 + 2.0*q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = effect(p, q);\n\n  float fi = smoothstep(0.0, 5.0, TIME);\n  col = mix(vec3(0.0), col, fi);\n\n  col = postProcess(col, q);\n  \n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [{"id": "XlfSRf", "previewfilepath": "https://soundcloud.com/slender-boy-380833869/markus-captain-kaarlonen-space-debris-spacesynth-remix", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/slender-boy-380833869/markus-captain-kaarlonen-space-debris-spacesynth-remix", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdBXWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[557, 557, 579, 579, 725], [1876, 1952, 1991, 1991, 2075], [2077, 2114, 2150, 2150, 2244], [2246, 2345, 2387, 2387, 2434], [2436, 2536, 2580, 2580, 2777], [2779, 2779, 2805, 2805, 2914], [2916, 2916, 2937, 2937, 3006], [3008, 3008, 3036, 3056, 3132], [3134, 3134, 3155, 3155, 3222], [3224, 3224, 3246, 3246, 3294], [3296, 3296, 3327, 3327, 3353], [3355, 3355, 3394, 3394, 3565], [3567, 3567, 3596, 3596, 3746], [3748, 3748, 3789, 3789, 3991], [3993, 3993, 4031, 4031, 4179], [4181, 4181, 4219, 4219, 4396], [4398, 4398, 4446, 4446, 4927], [4929, 4929, 4961, 4961, 5126], [5128, 5128, 5144, 5144, 5222], [5224, 5224, 5327, 5327, 5605], [5607, 5607, 5668, 5668, 7238], [7240, 7240, 7304, 7304, 8629], [8631, 8631, 8660, 8660, 9286], [9288, 9288, 9324, 9324, 9557], [9559, 9559, 9614, 9614, 9879]], "test": "error"}
{"id": "sdjSDd", "name": "Rocket 2d y scroller", "author": "jorge2017a1", "description": "Rocket 2d y scroller", "tags": ["rocket2dyscroller"], "likes": 5, "viewed": 172, "published": "Public API", "date": "1621347426", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Modificado por JorgeFloresP. ---jorge2017a1\n//Fork\n//2d sidescroller.....Created by onak in 2019-10-15\n//2D Rocket...........Created by antoineMoPa in 2017-06-28\n//https://www.shadertoy.com/view/lslBDX\n//https://www.shadertoy.com/view/tsKGDc\n\nfloat pixelsize = 2.0;\nfloat scrollSpeed = 0.3;\nfloat roughness = 0.55;\n\nfloat PI = 3.14159265359;\n\n/**\n * compares x to f and returns a value between 1.0 and 0.0\n * depending on the difference as long as its below threshold\n *\n * always returns 1.0 for differences above the threshold\n */\nfloat plot2d(in float x, in float f, in float threshold) {\n    float deviation = abs(x - f);\n    \n    if (deviation < threshold) {\n        return (deviation / threshold);\n    }\n    \n    return 1.0;\n} \n\nvec2 hash22(vec2 p) {\n    p = p*mat2(127.1,311.7,269.5,183.3);\n\tp = -1.0 + 2.0 * fract(sin(p)*43758.5453123);\n\treturn sin(p*6.283);\n}\n\nfloat perlin_noise(vec2 p) {\n\tvec2 pi = floor(p);\n    vec2 pf = p - pi;\n    \n    // interpolation\n    vec2 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    float f00 = dot(hash22(pi + vec2(0.0, 0.0)), pf - vec2(0.0, 0.0));\n    float f01 = dot(hash22(pi + vec2(0.0, 1.0)), pf - vec2(0.0, 1.0));\n    float f10 = dot(hash22(pi + vec2(1.0, 0.0)), pf - vec2(1.0, 0.0));\n    float f11 = dot(hash22(pi + vec2(1.0, 1.0)), pf - vec2(1.0, 1.0));\n    \n    // mixing top & bottom edges\n    float xm1 = mix(f00, f10, w.x);\n    float xm2 = mix(f01, f11, w.x);\n    \n    // mixing to point\n    float ym = mix(xm1, xm2, w.y); \n    \n    return ym;\n}\n\nfloat noise_fBM(float size, int octaves, float persistence, float scale, vec2 coord) {\n    float c = 0.0;\n    float p = 1.0;\n    float n = 0.0;\n    \n    for (int i = 1; i <= octaves; i++) {\n        c += perlin_noise(coord * size) * p;\n        n    += p;\n        size *= scale;\n        p    *= persistence;\n    }\n    // normalize c\n    c /= n;\n    \n    return c;\n}\n\n\n/**\n * two-dimensional fractal Brownian motion\n */\nfloat fBM(float size, int octaves, float persistence, float scale, vec2 coord) {\n    float c = 0.0;\n    float p = 1.0;\n    float n = 0.0;\n    \n    for (int i = 1; i <= octaves; i++) {\n        // apply noise function for the current octave\n        c += p * sin(coord.x * PI * size);\n        \n        // prepare parameters for next octave\n        n    += p;\n        size *= scale;\n        p    *= persistence;\n    }\n    \n    // normalize c\n    c /= n;\n    \n    return c;\n}\n\n\n\nfloat fBMYaX(float size, int octaves, float persistence, float scale, vec2 coord) {\n    float c = 0.0;\n    float p = 1.0;\n    float n = 0.0;\n    \n    for (int i = 1; i <= octaves; i++) {\n        // apply noise function for the current octave\n        c += p * sin(coord.y * PI * size);\n        \n        // prepare parameters for next octave\n        n    += p;\n        size *= scale;\n        p    *= persistence;\n    }\n    \n    // normalize c\n    c /= n;\n    \n    return c;\n}\n\n// photoshop blend modes: https://www.shadertoy.com/view/XdS3RW\nvec4 blend_lighten(vec4 s, vec4 d) {\n    return max(s, d);\n}\nvec3 blend_lighten(vec3 s, vec3 d) {\n    return max(s, d);\n}\n\n\n\n\nvec4 rocket(vec2 pos)\n{\n    vec4 col = vec4(0.0);\n    \n    // Clip (because otherwise a sine is repeated)\n    if(pos.x < -0.5 || pos.x > 0.5){\n        return col;\n    }\n    \n    if(\n      // Base parabolic shape\n      pos.y + 0.02 * cos(12.0 * pos.y + 0.1) * pos.y < 0.5 - pow(3.88 * pos.x, 2.0) && pos.y > -0.1 \n      ||\n        // Lower rectangle\n       ( pos.y < 0.0 && pos.y > -0.2 \n            && \n                // Lower left arc\n                (pos.x > -0.1 || distance(pos, vec2(-0.1,-0.1)) < 0.10) \n                // Lower right arc\n            &&     (pos.x < 0.1  || distance(pos, vec2(0.1,-0.1)) < 0.10)\n       )\n      )\n    {\n        // Window\n        if (\n            distance(pos, vec2(0.0,0.2)) < 0.05\n        )\n        {\n            col.rgb += vec3(0.1,0.1,0.1);\n            col.a = 1.0;\n        }\n        // Rest\n        else\n        {\n            col.rgb += vec3(1.0,1.0,1.0);\n            col.a = 1.0;\n        }\n    }\n    \n    else if (\n        pos.y < -0.4 + 0.5 * cos(4.5 * pos.x)\n        &&\n        pos.y > -0.5 + 0.3 * cos(3.0 * pos.x)\n    )\n    {\n        col.rgb += vec3(1.0,0.1,0.2);\n        col.a = 1.0;\n    }\n    \n    // Propeller\n    else if (pos.x < 0.1 && pos.y < 0.0 && pos.x > -0.1 && pos.y > -0.3)\n    {\n        col.rgb += vec3(0.3,0.3,0.3) + 0.3 * cos(pos.x * 10.0 + 1.0);\n        col.a = 1.0;\n    }\n       \n    \n    return col;\n}\n\n\nvec3 paisajeRio(vec2 uv)\n{\nvec3 col;\n    float surfaceThickness = 0.015;\n    vec3 skyDark = vec3(0.17, 0.289, 0.51); // RGB 44, 74, 105\n    vec3 skyBright = vec3(0.714, 0.829, 0.984); // RGB 183, 238, 247\n    vec3 terrainBright = vec3(0.855, 0.640, 0.179); // RGB 219, 164, 46\n    vec3 terrainDark = vec3(0.585, 0.437, 0.117); // RGB 150, 112, 30 #96701e\n    vec3 surfaceDark = vec3(0.246, 0.398, 0.183); // RGB 63, 102, 47\n    vec3 surfaceBright = vec3(0.312, 0.648, 0.179); // RGB 80, 166, 46\n    float time = iTime * scrollSpeed;\n    \n    \n    // generate fractal noise\n    //float v = fBM(roughness, 7, 0.5, 2.31, uv + time);\n    float v = fBMYaX(roughness, 7, 0.5, 2.31, uv + time);\n     \n    // map to range\n    v = 0.125 + 0.135 * v;\n    \n    // colorize\n    if (abs(v - uv.x) < surfaceThickness  || abs( uv.x-v-0.7) < surfaceThickness )\n    {\n        // surface\n\t\tcol = mix(surfaceBright, surfaceDark, plot2d(uv.x, v + surfaceThickness * 0.5, surfaceThickness));\n    } \n   else if (v < uv.x && (v+0.7 > uv.x  ) ) {\n        // sky\n         vec3 sky = mix(skyBright, skyDark, uv.x);\n        float c = 2.5 * noise_fBM(2.0, 5, 0.5, 2.0, uv.yx + vec2(iTime * (0.7 * scrollSpeed), 0.0));\n        vec3 clouds = vec3(c);\n        col = clamp(sky + clouds, sky, vec3(1.0));\n        \n        //col = vec3(0.0,0.0,1.0);\n    }\n    else {\n        // terrain\n        col = terrainBright;\n        \n        // add some structure\n        float noise = noise_fBM(16.0, 5, 0.5, 2.0, uv + vec2(0.0, time));\n        noise = 0.5 + noise;\n\n        if (noise > 0.7   ) {\n            col = terrainDark;\n        }\n    }\n \n return col;\n}    \n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    \n        // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float time = iTime * scrollSpeed;\n    \n    if (pixelsize > 1.0) {\n   \t\tuv = (pixelsize * floor(iResolution.xy * uv / pixelsize)) / iResolution.xy;\n        time = pixelsize * floor(iResolution.x / pixelsize * iTime * scrollSpeed) / iResolution.x;\n    }\n   \n    vec3 col;\n    col= paisajeRio(uv);\n    vec2 uv2=uv*(6.0+3.0*(sin(iTime)));\n    vec4 colcohete= rocket(uv2-vec2(3.0+2.0*sin(iTime*1.0),0.8));\n    col=mix(col,colcohete.xyz, colcohete.a );\n     \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdjSDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[345, 535, 593, 593, 734], [737, 737, 758, 758, 870], [872, 872, 900, 900, 1495], [1497, 1497, 1583, 1583, 1860], [1863, 1914, 1994, 1994, 2384], [2388, 2388, 2471, 2471, 2861], [2863, 2927, 2963, 2963, 2987], [2988, 2988, 3024, 3024, 3048], [3053, 3053, 3076, 3076, 4420], [4423, 4423, 4449, 4449, 6040], [6051, 6051, 6109, 6168, 6723]], "test": "valid"}
{"id": "sdjSRt", "name": "bang", "author": "spectrum", "description": "particle bang", "tags": ["star"], "likes": 1, "viewed": 165, "published": "Public API", "date": "1620834973", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 hash12(float t) {\n    float x = fract(sin(t*674.31)*432.1);\n    float y = fract(sin(t*472.1)*201.9);\n    return vec2(x, y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 color = vec3(0);\n\n    float t = iTime * 10.;\n    float brightness = .0001*(sin(t)+3.);\n    \n    float dt = 0.;\n    \n\n    for (float i=200.; i>0.; i--) {\n        vec2 dir = hash12(i)-.5;\n        float tt = fract(iTime*.3)*10.;\n        dt = length(uv-dir*tt);\n        color += brightness/dt;\n    }\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdjSRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 130], [132, 132, 189, 189, 590]], "test": "valid"}
{"id": "sdjSW3", "name": "Heart Marching", "author": "kithy", "description": "3d heart repeat.\nOriginal:http://glslsandbox.com/e#39397.0", "tags": ["raymarching", "distancefunction", "heart"], "likes": 2, "viewed": 35, "published": "Public", "date": "1621179639", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Original:http://glslsandbox.com/e#39397.0\n\n#define MAX_STEPS 24\n\nmat2 rot(float a){\n\tfloat s=sin(a);\n\tfloat c=cos(a);\n\treturn mat2(c,-s,s,c);\n}\n\nfloat sdHeart(vec3 p){\n\treturn sqrt(p.x*p.x+2.25*p.y*p.y+p.z*p.z+pow(p.x*p.x+0.1125*p.y*p.y,0.33)*p.z)-1.0;\n}\n\nfloat mainDist(vec3 p){\n\tp.zy*=rot(90.0);\n\t//p.xy*=rot(iTime*0.1);\n\tp=mod(p,8.0)-4.0;\n\t\n\treturn sdHeart(p);\n}\n\nvec3 genNormal(vec3 p){\n\tfloat EPS=0.001;\n\treturn normalize(vec3(\n\t\tmainDist(p+vec3(EPS,0.0,0.0))-mainDist(vec3(-EPS,0.0,0.0)),\n\t\tmainDist(p+vec3(0.0,EPS,0.0))-mainDist(vec3(0.0,-EPS,0.0)),\n\t\tmainDist(p+vec3(0.0,0.0,EPS))-mainDist(vec3(0.0,0.0,-EPS))\n\t\t));\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n\tvec2 p=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\tvec3 cPos=vec3(0.0,0.0,2.5-iTime);\n\tvec3 cDir=vec3(0.0,0.0,-1.0);\n\tvec3 cUp=vec3(0.0,1.0,0.0);\n\tvec3 cSide=cross(cDir,cUp);\n\tfloat targetDepth=1.0;\n\tvec3 ray=normalize(cSide*p.x+cUp*p.y+cDir*targetDepth);\n\tfloat dist=0.0;\n\tfloat rLen=0.0;\n\tvec3 rPos=cPos;\n\n\tvec4 col=vec4(0.0,0.0,0.0,1.0);\n\n\tfor(int i=0;i<MAX_STEPS;i++){\n\t\tdist=mainDist(rPos);\n\t\trLen+=dist;\n\t\trPos=cPos+ray*rLen;\n\t}\n\tif(abs(dist)<0.001){\n\t\tvec3 normal=genNormal(rPos);\n\t\tvec3 light=normalize(vec3(1.0));\n\t\tfloat diff=max(dot(normal,light),0.9);\n\n\t\tcol=vec4(vec3(diff*1.0,diff*0.01,diff*0.01),1.0);\n\t\t\n\t}\n\tfragColor=col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdjSW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 85, 85, 145], [147, 147, 169, 169, 256], [258, 258, 281, 281, 367], [369, 369, 392, 392, 627], [629, 629, 682, 682, 1330]], "test": "valid"}
{"id": "sdjXR3", "name": "my skill graph", "author": "raidan00", "description": "skill graph made for my game wipefire.com", "tags": ["skillgraph"], "likes": 4, "viewed": 85, "published": "Public", "date": "1622199466", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float widthX = 1.0;\nfloat drawGraph(vec2 uv){\n    float graphY = uv.x/(uv.x+0.2);\n    float diffY = abs(uv.y - graphY);\n\n    float graphX = -(0.2*uv.y/(uv.y-1.));\n    float diffX = abs(uv.x - graphX)/widthX;\n    \n    float diff = min(diffX, diffY);\n    \n    float col = smoothstep(0.011, 0.001, diff);\n    if(graphY >1. || graphX < 0. || uv.y < 0.0) col = 0.;\n    \n    return col;\n}\nfloat drawStar(vec2 uv, float score){\n    vec2 p = vec2(score, score/(score+0.2));\n    float len = length(uv-p);\n    return (0.029+(sin(iTime*12.)/2.+0.5)*0.004)/len;\n}\nfloat starLen(vec2 uv, float score){\n    vec2 p = vec2(score, score/(score+0.2));\n    vec2 diff = uv-p;\n    diff.x /= widthX;\n    return length(diff);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // set uv\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.05;\n    uv.x *= iResolution.x/iResolution.y;\n    uv = uv*1.1;\n    uv.x *= widthX;\n    \n    float col = drawGraph(uv);\n   \n    float hori = mod(uv.y, 0.25);\n    col += step(0.247, hori);\n    vec3 colV3 = vec3(0.406, 0.851, 0.361)*col;\n    \n    vec3 starColor1 = vec3(0.506, 0.851, 0.960);\n    float starLen1 = starLen(uv, 0.1);\n    float star1 = (0.029+(sin(iTime*12.)/2.+0.5)*0.004)/starLen1;\n    colV3 = mix(colV3, starColor1, clamp(star1, 0., 1.));\n    \n    vec3 starColor2 = vec3(.9, 0.496, 0.743);\n    float starLen2 = starLen(uv, 0.9);\n    float star2 = 0.02/starLen2;\n    colV3 = mix(colV3, starColor2, clamp(star2, 0., 1.));\n    \n    \n    fragColor = vec4(colV3,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdjXR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 45, 45, 382], [383, 383, 420, 420, 551], [552, 552, 588, 588, 704], [706, 706, 763, 777, 1506]], "test": "valid"}
{"id": "sdSXWV", "name": "Color Touch by Darko", "author": "omegasbk", "description": "Made this simple SDF scene for fun.", "tags": ["sdf", "ball"], "likes": 2, "viewed": 64, "published": "Public", "date": "1621114385", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Made by Darko Supe (omegasbk)\n// 15.5.2021.\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .005\n\n#define PI 3.14159265359\n\n#define BOX1 0\n#define BALL 1\n#define WALL 2\n#define BOX2 3\n\nfloat getDist(vec3 p, out int body) \n{\n    float time = iTime * 3.;\n\n    vec4 s = vec4(2, abs(sin(time)) * 2. + 1.9, 7, 1);\n    \n    float sphereDist = length(p - s.xyz) - s.w;\n    \n    vec3 b = vec3(1., 1, 1);\n    vec3 c = vec3(sin(time + 3. * PI / 2.) + 3., -3.2 + mod(time + PI, 2. * PI), 4.5 + mod(time + PI, 2. * PI));\n    vec3 q = abs(p - c) - b;\n    float cubeDist = length(max(q, 0.0)) + min(max(q.x, max(q.y,q.z)), 0.0);\n    \n    vec3 b1 = vec3(1., 1, 1);\n    vec3 c1 = vec3(sin(time + PI / 2.) + 3., -3.2 + mod(time, 2. * PI), 4.5 + mod(time, 2. * PI));\n    vec3 q1 = abs(p - c1) - b1;\n    float cubeDist1 = length(max(q1, 0.0)) + min(max(q1.x, max(q1.y,q1.z)), 0.0);\n\n    vec3 b2 = vec3(1, 1000, 1000);\n    vec3 c2 = vec3(4, 2, 7);\n    vec3 q2 = abs(p - c2) - b2;\n    float wallDist = length(max(q2, 0.0)) + min(max(q2.x, max(q2.y,q2.z)), 0.0);\n    \n    float minDist = sphereDist;\n    body = BALL;\n    \n    if (cubeDist < minDist)\n    {\n        minDist = cubeDist;\n        body = BOX1;\n    }\n    if (cubeDist1 < minDist)\n    {\n        minDist = cubeDist1;\n        body = BOX2;\n    }\n    if (wallDist < minDist)\n    {\n        minDist = wallDist;\n        body = WALL;\n    }\n        \n    return minDist;\n}\n\nvec3 getNormal(vec3 p) \n{\n    int body;\n    float d = getDist(p, body);\n    \n    vec2 e = vec2(.01, 0); \n    \n    vec3 n = d - vec3(\n        getDist(p - e.xyy, body), \n        getDist(p - e.yxy, body), \n        getDist(p - e.yyx, body));\n        \n    return normalize(n);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, out int body)\n{\n    float dO = 0.;\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd * dO;\n        float dS = getDist(p, body);\n        dO += dS;\n        \n        if (dO > MAX_DIST || dS < SURF_DIST) \n            break;\n    }\n    \n    return dO;\n}\n\nfloat getLight(vec3 p)\n{\n    vec3 lightPosition = vec3(0, 5, 6);\n    int body;\n    \n    lightPosition.xz = vec2(-2, 0);\n    \n    vec3 l = normalize(lightPosition-p);\n    vec3 n = getNormal(p);\n    \n    float diff = clamp(dot(n, l), 0., 1.);\n    \n    float d = rayMarch(p + n * SURF_DIST * 2., l, body);\n    if (d < length(lightPosition - p))\n       diff *= .1;\n    \n    return diff;\n}\n\nvec3 getBodyColor(int body)\n{\n    if (body == BALL)\n        return ((sin((iTime) * 6.) + 1.) / 8.) * vec3(.0, .6, .8);\n    else if (body == BOX1)\n        return (1. - ((sin((iTime) * 3.) + 1.) / 2.)) * step(0.5, (sin((iTime) * 3.) + 1.) / 2.) * vec3(.9, .6, .2);\n    else if (body == BOX2)\n        return (1. - ((sin((iTime + PI) * 3.) + 1.) / 2.)) * step(0.5, (sin((iTime + PI) * 3.) + 1.) / 2.) * vec3(.9, .6, .2);\n        \n    return vec3(0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * 3.;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 1.2, 0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 0.8));\n    \n    int body;\n    float d = rayMarch(ro, rd, body);\n    \n    vec3 p = ro + rd * d;\n    \n    float dif = getLight(p);\n    col = vec3(dif); \n    \n    if (body == WALL)\n    {\n        ro = p;\n        rd = reflect(rd, getNormal(p));\n        d = rayMarch(ro + rd * SURF_DIST * 2., rd, body);\n        \n        p = ro + rd * d;\n                        \n        col = vec3(mix(getLight(p), col.x, 0.96));\n        col *= vec3(0.8, 0.2, 0.6);\n        col = mix(getBodyColor(body), col, 0.8);\n    }\n    else\n    {\n        col += getBodyColor(body);    \n    }\n        \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdSXWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[203, 203, 241, 241, 1417], [1419, 1419, 1444, 1444, 1692], [1694, 1694, 1742, 1742, 2000], [2002, 2002, 2026, 2026, 2386], [2388, 2388, 2417, 2417, 2835], [2838, 2838, 2895, 2895, 3802]], "test": "valid"}
{"id": "sdSXzt", "name": "Forest-bosque- v2", "author": "jorge2017a1", "description": "Forest-bosque- v2", "tags": ["2d", "draw", "poly", "forestbosquev2"], "likes": 3, "viewed": 152, "published": "Public API", "date": "1620787785", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//por jorge2017a1 ----jorgeFloresP---11/may/2021\n// referencia \n////-------------------\n/// IQ funciones....librerias\n//https://www.shadertoy.com/view/tlGBW3\n//Created by manu210404 in 2021-03-13\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n    \nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r; }\n\nvec3 ponerBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S(abs( distObj),0.0));\n  return colOut;\n}\n\nfloat opU(float d1, float d2) {return min(d1, d2); }\nconst vec3 colNegro=vec3(0.0);\nconst vec3 colGris=vec3(0.49,0.49,0.49);\nconst vec3 colGris2=vec3(0.6);\nconst vec3 colBlanco=vec3(1.0);\nconst vec3 colRojo=vec3(1.0,0.0,0.0);\nconst vec3 colAzul=vec3(0.0,0.0,1.0);\nconst vec3 colVerde=vec3(0.0,1.0,0.0);\nconst vec3 colVerde2=vec3(0.1,0.8,0.1);\nconst vec3 colrojoObs=vec3(0.45,0.13,0.15); //rojo obscuro\n\nconst vec3 col1=vec3(0.54,0.49,0.39);\nconst vec3 col2=vec3(0.06,0.07,1.0);\nconst vec3 col3=vec3(0.06,0.07,0.8);\n//const vec3 col4=vec3(0.45,0.13,0.15); //rojo obscuro\nconst vec3 col4=vec3(0.60,0.17,0.17); //vestido\nconst vec3 col5=vec3(0.73,0.60,0.55);\nconst vec3 colDorado=vec3(0.925,0.67,0.0);\n\n#define POLY(N) (in vec2 p, in vec2[N] v) {const int n=v.length();float d=dot(p-v[0],p-v[0]);float s=1.;for(int i=0,j=n-1;i<n;j=i,i++){vec2 e=v[j]-v[i];vec2 w=p-v[i];vec2 b=w-e*clamp(dot(w,e)/dot(e,e),0.,1.);d=min(d,dot(b,b));bvec3 cond=bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);if(all(cond)||all(not(cond))) s=-s;}return s*sqrt(d);}\n\n\nfloat sdPoly15 POLY(15)\nvec2 pt15[ 15]=vec2[](  \nvec2(.10,.65),vec2(.10,.54),vec2(.10,.54),vec2(.10,.54),vec2(.13,.53),\nvec2(.13,.64),vec2(.15,.67),vec2(.14,.68),vec2(.12,.65),vec2(.12,.69),\nvec2(.11,.69),vec2(.11,.66),vec2(.08,.68),vec2(.08,.67),vec2(.10,.65) );\n\nfloat sdPoly11 POLY(11)\nvec2 pt11[ 11]=vec2[](  \nvec2(.07,.66),vec2(.04,.67),vec2(.01,.73),vec2(.01,.80),vec2(.06,.86),\nvec2(.16,.84),vec2(.20,.75),vec2(.20,.69),vec2(.17,.66),vec2(.14,.66),\nvec2(.07,.66) );\n\nfloat sdPoly10 POLY(10)\nvec2 pt10[ 10]=vec2[](  \nvec2(.09,.38),vec2(.12,.42),vec2(.15,.41),vec2(.17,.43),vec2(.20,.46),\nvec2(.22,.44),vec2(.24,.42),vec2(.27,.40),vec2(.28,.38),vec2(.09,.38) );\n\n\nfloat sdPoly32 POLY(32)\nvec2 pt32[ 32]=vec2[](  \nvec2(.15,.09),vec2(.15,.19),vec2(.10,.22),vec2(.06,.26),vec2(.04,.28),\nvec2(.06,.28),vec2(.09,.24),vec2(.12,.22),vec2(.15,.21),vec2(.17,.24),\nvec2(.20,.26),vec2(.22,.27),vec2(.23,.28),vec2(.24,.27),vec2(.18,.23),\nvec2(.17,.21),vec2(.17,.21),vec2(.19,.21),vec2(.21,.22),vec2(.24,.23),\nvec2(.24,.22),vec2(.23,.21),vec2(.19,.20),vec2(.17,.19),vec2(.17,.17),\nvec2(.17,.15),vec2(.18,.15),vec2(.19,.16),vec2(.19,.15),vec2(.17,.14),\nvec2(.17,.10),vec2(.15,.09) );\n\n\nfloat sdPoly7 POLY(7)\nvec2 pt7[ 7]=vec2[](  \nvec2(.00,.53),vec2(.00,.62),vec2(.18,.85),vec2(.26,.81),vec2(.31,.70),\nvec2(.38,.54),vec2(.00,.53) );\n\nfloat sdPoly11b POLY(11)\nvec2 pt11b[11]=vec2[](  \nvec2(.24,.54),vec2(.34,.74),vec2(.41,.82),vec2(.46,.89),vec2(.51,.89),\nvec2(.53,.86),vec2(.54,.77),vec2(.59,.73),vec2(.65,.65),vec2(.67,.54),\nvec2(.24,.54) );\n\n\nfloat sdPoly9 POLY(9)\nvec2 pt9[ 9]=vec2[](  \nvec2(.60,.53),vec2(.67,.59),vec2(.74,.62),vec2(.76,.65),vec2(.81,.63),\nvec2(.84,.60),vec2(.87,.56),vec2(.90,.54),vec2(.60,.53) );\n\n\nfloat sdPoly11c POLY(11)\nvec2 pt11c[ 11]=vec2[](  \nvec2(.48,.53),vec2(.60,.70),vec2(.68,.77),vec2(.71,.77),vec2(.78,.82),\nvec2(.81,.84),vec2(.85,.78),vec2(.89,.71),vec2(.93,.67),vec2(.97,.54),\nvec2(.48,.53) );\n\nfloat sdPoly5 POLY(5)\nvec2 pt5[ 5]=vec2[](  \nvec2(.41,.18),vec2(.40,.28),vec2(.53,.32),vec2(.54,.18),vec2(.41,.18) );\n\nfloat sdPoly5b POLY(5)\nvec2 pt5b[ 5]=vec2[](  \nvec2(.46,.18),vec2(.46,.26),vec2(.49,.26),vec2(.50,.18),vec2(.46,.18) );\n\n\nfloat sdPoly10b POLY(10)\nvec2 pt10b[ 10]=vec2[](  \nvec2(.43,.29),vec2(.42,.33),vec2(.40,.33),vec2(.40,.35),vec2(.44,.35),\nvec2(.45,.35),vec2(.46,.33),vec2(.44,.33),vec2(.44,.29),vec2(.43,.29) );\n\n\nfloat sdPoly11d POLY(11)\nvec2 pt11d[ 11]=vec2[](  \nvec2(.74,.17),vec2(.74,.22),vec2(.76,.24),vec2(.77,.27),vec2(.77,.30),\nvec2(.77,.30),vec2(.77,.27),vec2(.76,.24),vec2(.75,.22),vec2(.74,.17),\nvec2(.74,.17) );\n\nfloat sdPoly9b POLY(9)\nvec2 pt9b[ 9]=vec2[](  \nvec2(.74,.17),vec2(.74,.22),vec2(.71,.25),vec2(.70,.30),vec2(.71,.30),\nvec2(.72,.25),vec2(.75,.22),vec2(.74,.17),vec2(.74,.17) );\n\nfloat sdPoly15b POLY(15)\nvec2 pt15b[ 15]=vec2[](  \nvec2(.75,.97),vec2(.71,.96),vec2(.69,.94),vec2(.65,.93),vec2(.63,.90),\nvec2(.69,.88),vec2(.78,.89),vec2(.82,.90),vec2(.86,.88),vec2(.86,.93),\nvec2(.84,.94),vec2(.80,.94),vec2(.78,.96),vec2(.77,.97),vec2(.75,.97) );\n\n///------------*******-------------------\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\n\n//***------------****-----------****------------******-------\nvec3 Bosque2(in vec2 pp, vec3 col) \n{\n  vec2 p=pp,pr1=pp, pr2=pp;\n   pr1.x= opRep1D(pr1.x, 0.4 ); pr1.y-=0.04;\n   pr2.x= opRep1D(pr2.x, 0.7 ); pr2.y+=0.04;\n   \n   float i = floor(p.x);  // integer\n    float f = fract(p.x);  // fraction\n    float y1 = rand(i)*0.005;\n    float y2 = rand(f)*0.005;\n\n   float sd15 = sdPoly15(p, pt15);\n   float sd11 = sdPoly11(p, pt11);\n   float sd10 = sdPoly10(p-vec2(0.1,0.0), pt10);\n   float sd32 = sdPoly32(p, pt32);\n   float sd7 = sdPoly7(p-vec2(-0.3,0.2), pt7); //montaña\n    float sd11b = sdPoly11b(p-vec2(-0.1,0.0), pt11b); //montaña\n    float sd9 = sdPoly9(p-vec2(0.3,0.3), pt9);\n    float sd11c = sdPoly11c(p, pt11c);\n    float sd5 = sdPoly5(p, pt5);\n    float sd5b = sdPoly5b(p, pt5b);\n    float sd10b = sdPoly10b(p, pt10b);\n    \n    float sd11d = sdPoly11d(p, pt11d);\n    float sd9b = sdPoly9b(p, pt9b);\n    float sd15b = sdPoly15b(p, pt15b);\n    col=ponerBorde(col1,col,sd7 ); //montaña n3\n    col=ponerBorde(col5,col,sd11c );\n    col=ponerBorde(colVerde2,col,sd11 ); //ramas arbol\n    col=ponerBorde(colrojoObs,col,sd15 ); //tronco\n    col=ponerBorde(col1,col,sd10 );  //piedra chica\n    col=ponerBorde(col4,col,sd32 ); //tronco seco\n    col=ponerBorde(col4,col,sd11b ); //montaña n2\n    col=ponerBorde(col4,col,sd9 );  //piedra chica n2\n    col=ponerBorde(col1,col,sd5 ); //casa\n    col=ponerBorde(col4,col,sd5b ); //puerta\n    col=ponerBorde(col4,col,sd10b ); //chimenea\n    col=ponerBorde(col1,col,sd11d );\n    col=ponerBorde(col4,col,sd9b ); //arboito seco\n    col=ponerBorde(col2,col,sd15b );// nube\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    float t=iTime*0.25;\n    vec2 p=uv*0.5-vec2(-0.5,-0.5);\n    vec3 col=vec3(0.15,0.6,0.3); //vec3(0.25);\n    vec2 p2=p+vec2(0.0,3.5);\n    float tt=t;\n    p.y= opRep1D(p.y+tt, 2.2 );\n    p2.y= opRep1D(p2.y+tt, 2.2 );\n    col=Bosque2(p, col);\n    col=Bosque2(p2, col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdSXzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[305, 343, 379, 379, 424], [430, 430, 465, 465, 489], [491, 491, 551, 551, 675], [677, 677, 708, 708, 729], [4735, 4777, 4797, 4797, 4864], [4866, 4866, 4886, 4886, 4924], [4927, 4989, 5026, 5026, 6557], [6559, 6559, 6616, 6616, 7014]], "test": "valid"}
{"id": "sdsXzX", "name": "RayMarch B451C5", "author": "MaxenceClt", "description": "shader", "tags": ["shader"], "likes": 1, "viewed": 25, "published": "Public", "date": "1620435482", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nfloat GetDist(vec3 p){\n    vec4 s = vec4(0, cos(p.y), 6, 1);\n    float sphereDist = length(p-s.xyz)-s.w;\n    float planeDist = p.y;\n    \n    float d = min(sphereDist, planeDist);\n    return d;\n}\n\nvec3 GetNormal(vec3 p){\n    float d = GetDist(p);\n    vec2 e = vec2(0.01,0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx)\n    );\n    \n    return normalize(n);\n    \n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    return dO;\n}\n\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime)) * 2.;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(1.);\n    \n    //ray origin\n    vec3 ro = vec3(0, 1, 0);\n    \n    //ray direction\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d;\n    float dif = GetLight(p);\n    col = vec3(dif);\n    \n    //col = GetNormal(p);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdsXzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 89, 89, 261], [263, 263, 286, 286, 488], [490, 490, 524, 524, 733], [736, 736, 760, 760, 1067], [1072, 1072, 1129, 1129, 1527]], "test": "valid"}
{"id": "slf3RS", "name": "triangle thing", "author": "laney", "description": "saw this concrete wall pattern in a book about soviet metro stations, started out trying to replicate it ended up with this.", "tags": ["grid", "triangle"], "likes": 13, "viewed": 189, "published": "Public API", "date": "1622294429", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 m;\n\nconst float h = 0.9;\nconst mat2 skew = mat2( 1.0, 0.5/h, 0.0, 1.0/h) ;\nconst mat2 unskew = mat2( 1.0, -0.5, 0.0, h);\n\nvec4 tri_grid2(vec2 uv, const float peakY , const float peakZ, float seam_comp) {\n\n  uv *= skew;\n\n  // repeat\n  uv = fract(uv);\n  vec2 seamv = min(abs(uv),abs(uv-1.0));\n  float seam = min(seamv.x,seamv.y);\n  \n  // up or down triangle\n  float d = uv.x-uv.y; \n  seam = min(abs(d),seam);\n  d = sign(d);\n\n  // local coordinates\n  uv *= unskew;\n  uv.y*=d;\n  uv+= d>0.0 ? vec2(-0.5,.0) : vec2(0.0,h);\n  \n  // faces\n  vec2 vs1 = normalize(vec2(1.0,peakY));\n  vec2 vs2 = normalize(vec2(-1.0,peakY));\n\n  float s1 = dot(uv-vec2(-0.5,0.0),vec2(vs1.y,-vs1.x));\n  float s2 = dot(uv-vec2(.5,0.0),vec2(vs2.y,-vs2.x));\n\n  vec4 normal;\n  if(s1>0.0 && s2<0.0) {\n    normal=vec4(normalize(cross(vec3(vs1,peakZ),vec3(vs2,peakZ))),1.0);\n    seam = min(s1,seam);\n    seam = min(-s2,seam);\n  } else if(uv.x < 0.0) {\n    normal=vec4(normalize(cross(vec3(vec2(0.0,-1.0),peakZ),vec3(vs1,peakZ))),0.0);\n    seam = min(-s1,seam);\n    seam = min(-uv.x,seam);\n  } else {\n    normal=vec4(normalize(cross(vec3(vs2,peakZ),vec3(vec2(0.0,-1.0),peakZ))),0.0);\n    seam = min(uv.x,seam);\n    seam = min(s2,seam);\n  }\n\n  normal.y*=d;\n  return vec4(mix(vec3(0.0,0.0,0.3),normal.xyz,smoothstep(0.0,seam_comp,seam)),normal.w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 *  iResolution.xy) / iResolution.y;\n    m = iMouse / iResolution.xyxy;\n \n    float w = 4.0*pow(sin(\n      (1.0+length(uv.x*cos(iTime*0.5)*3.0+uv.y*sin(iTime*0.7)*2.0))\n      -0.2*iTime),8.0);\n\n    vec2 uvs = uv*skew;\n    vec2 grid = (uvs.x-uvs.y) > 0.0 ? vec2(8.0,0.01) : vec2(24.0,0.03);\n\n    vec4 normal = tri_grid2(uv*grid.x, w, 0.6*sin(0.5-length(uv*2.0)+iTime*0.2), grid.y);\n\n    vec3 lightDir = normalize(vec3(sin(iTime*0.5)*50.0, cos(iTime*0.7)*30.0, 100.0));\n\n    vec3 c = normal.w >0.0 ? vec3(1,0.24,0.2) : vec3(1.0);\n    fragColor = vec4(vec3(dot(normal.xyz,lightDir))* c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slf3RS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[127, 127, 208, 208, 1314], [1316, 1316, 1373, 1373, 1993]], "test": "valid"}
{"id": "slf3z4", "name": "Tanjiro sphere", "author": "kithy", "description": "mapping 2D texture to 3D sphere.\npattern is from \"Demon Slayer\"", "tags": ["raymarching", "checker", "polarcoordinate"], "likes": 0, "viewed": 38, "published": "Public", "date": "1621608710", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ITR 64\n#define EPS 0.001\n#define SCALE 5.0\n#define PI 3.141592\n#define TWO_PI 6.2831\n#define GREEN vec3(0.2,0.9,0.7)\n\nmat2 rot(float a){\n\tfloat s=sin(a);\n\tfloat c=cos(a);\n\treturn mat2(c,-s,s,c);\n}\n\nfloat sdSphere(vec3 p){\n\treturn length(p)-0.8;\n}\n\nvec3 genNormal(vec3 p){\n\tvec3 normal=vec3(\n\t\tsdSphere(p+vec3(EPS,0.0,0.0))-sdSphere(p+vec3(-EPS,0.0,0.0)),\n\t\tsdSphere(p+vec3(0.0,EPS,0.0))-sdSphere(p+vec3(0.0,-EPS,0.0)),\n\t\tsdSphere(p+vec3(0.0,0.0,EPS))-sdSphere(p+vec3(0.0,0.0,-EPS))\n\t\t);\n\treturn normalize(normal);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n\tvec2 uv=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\n\tvec3 ro=vec3(0.0,0.0,-6.0);\n\tvec3 lookat=vec3(0.0,0.0,0.0);\n\tfloat zoom=5.0;\n\n\tvec3 f=normalize(lookat-ro);\n\tvec3 r=normalize(cross(vec3(0.0,1.0,0.0),f));\n\tvec3 u=cross(f,r);\n\tvec3 c=ro+f*zoom;\n\tvec3 i=c+uv.x*r+uv.y*u;\n\tvec3 rd=normalize(i-ro);\n\n\tfloat dS,dO;\n\tvec3 p,normal;\n\n\t\n\n\t//Raymarching\n\tfor(int i=0;i<ITR;i++){\n\t\tp=ro+rd*dO;\n\t\tdS=sdSphere(p);\n\t\tnormal=genNormal(p);\n\t\tif(dS<EPS)break;\n\t\tdO+=dS;\n\n\t}\n\t\n\tp.xz*=rot(iTime);\n\tp.xy*=rot(iTime);\n\tvec3 col=vec3(0.0);\n\n\tvec2 checker;\n\n\t//Polar Coordinate\n\tif(dS<EPS){\n\t\tfloat x=atan(p.x+TWO_PI,p.y);\n\t\tfloat y=length(p);\n\n\t\t//2D checker pattern\n\t\tchecker=floor(SCALE*p.xy*vec2(x,y));\n\t\tcol=vec3(mod(checker.x+checker.y,2.0)*GREEN);\n\t}\n\t\n\tfragColor=vec4(col*(1.0-normal.x),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slf3z4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[126, 126, 144, 144, 204], [206, 206, 229, 229, 254], [256, 256, 279, 279, 523], [525, 525, 578, 578, 1369]], "test": "valid"}
{"id": "sll3RN", "name": "scene eggs'n'milk", "author": "sirjofri", "description": "trying a more complex scene", "tags": ["raymarching", "sdf"], "likes": 3, "viewed": 201, "published": "Public API", "date": "1621705086", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// define AA for better performance\n//#define AA\n\nfloat sdist = .002;      // bigger: better performance\nfloat culldist = 20.;    // smaller: better performance\nfloat maxlightdist = 4.; // smaller: better performance\nint basesteps = 256;     // smaller: better performance\nint shadowsteps = 24;    // smaller: better performance\n\nvec3 ambi = vec3(.6, .7, .9);\nvec3 sky = vec3(.3, .35, 1.2);\n\nstruct Sample{\nfloat dist;\nvec3 wp;\nvec3 norm;\nvec3 shadow;\nfloat ao;\nvec3 col;\nint mat;\n};\n\nstruct Map{\nfloat d;\nint m;\n};\n\nstruct Light{\nvec3 p;\nvec3 c;\nfloat d;\n};\n\nMap sdSphere(vec3 p, vec3 pos, float r, int mat)\n{\n    float d = distance(pos, p) - r;\n    return Map(d, d < sdist ? mat : 0);\n}\n\nMap sdBush(vec3 p, vec3 pos, float r, int mat)\n{\n    float d = distance(pos, p) - r - smoothstep(0., 1., texture(iChannel0, p.yz*vec2(.03, .07)+sin(iTime*1.6+p.z*5.)*vec2(0.005, .0)).r)*.6;\n    return Map(d, d < sdist ? mat : 0);\n}\n\nMap sdBox(vec3 p, vec3 pos, vec3 dim, int mat)\n{\n    float d = length(max(vec3(0), abs(p-pos)-dim));\n    return Map(d, d < sdist ? mat : 0);\n}\n\nMap sdGround(vec3 p, float h, int mat)\n{\n    float d = distance(p, vec3(p.x, p.y, h));\n    return Map(d, d < sdist ? mat : 0);\n}\n\nvec3 rotate(vec3 p, vec3 r)\n{\n    mat3 yaw = mat3(\n        cos(r.x), -sin(r.x), 0.,\n        sin(r.x),  cos(r.x), 0.,\n        0.      ,  0.      , 1.\n    );\n    mat3 pitch = mat3(\n        1.,       0.,        0.,\n        0., cos(r.y), -sin(r.y),\n        0., sin(r.y),  cos(r.y)\n    );\n    mat3 roll = mat3(\n         cos(r.z), 0., sin(r.z),\n               0., 1.,       0.,\n        -sin(r.z), 0., cos(r.z)\n    );\n    \n    p *= roll;\n    p *= pitch;\n    p *= yaw;\n    return normalize(p);\n}\n\nMap opUnion(Map a, Map b)\n{\n    float d = min(a.d, b.d);\n    int m = max(a.m, b.m);\n    return Map(d, m);\n}\n\nMap opSubtract(Map a, Map b)\n{\n    float d = max(-a.d, b.d);\n    int m = max(a.m, b.m);\n    return Map(d, m);\n}\n\nMap opIntersect(Map a, Map b)\n{\n    float d = max(a.d, b.d);\n    int m = max(a.m, b.m);\n    return Map(d, m);\n}\n\nMap map(vec3 p)\n{\n    Map bush1 = sdBush(p*vec3(1., 1., .6), vec3(4., -17., 1.1), .5, 6); // right bush\n    Map bush2 = sdBush(p*vec3(1., 1., .6), vec3(1., -17., 1.3), .5, 6); // left bush\n    Map bush3 = sdBush(p*vec3(1., 1., .5), vec3(13., -33., .8), .5, 6); // distant bush right\n    Map bush4 = sdBush(p*vec3(1., 1., .5)-vec3(0., 0., .3), vec3(7.5, -30., -.1), .5, 6); // distant bush left\n    Map ball1 = sdSphere(p*vec3(1., 1., 1.3), vec3(-2.1, -13.5, 1.58), .15, 5); // left ball\n    Map ball2 = sdSphere(p*vec3(1., 1., 1.5), vec3(-1.6, -13.7, 1.79), .15, 5); // right ball\n    Map box = sdBox(p, vec3(-1.4, -13.2, .5), vec3(1.3, 1., .5), 4);\n    Map boxTop = sdBox(p, vec3(-1.4, -13.2, 1.), vec3(1.32, 1.02, .1), 4);\n    Map obox = sdBox(p, vec3(-.7, -13.5, 1.3), vec3(.22, .18, .6), 7);\n    Map wallA = sdBox(p, vec3(-9.5, -15., 3.), vec3(10., .5, 3.), 3);\n    Map wallB = sdBox(p, vec3(1.5, -15, 5.), vec3(1., .5, 1.), 3);\n    Map wallC = sdBox(p, vec3(1.5, -15, .7), vec3(1., .5, .7), 3);\n    Map wallD = sdBox(p, vec3(5.5, -15, 3.), vec3(3., .5, 3.), 3);\n    Map wall = opUnion(opUnion(opUnion(wallA, wallB), wallC), wallD);\n    Map ground = sdGround(p, 0., 1);\n    Map bushes = opUnion(opUnion(bush1, bush2), opUnion(bush3, bush4));\n    Map objects = opUnion(opUnion(opUnion(ball1, ball2), obox), bushes);\n    return opUnion(opUnion(opUnion(wall, ground), opUnion(box, boxTop)), objects);\n}\n\n/* Thanks iq */\nvec3 getNormal(vec3 p)\n{\n    const float h = 0.0002;\n    #define ZERO (min(iFrame,0))\n    vec3 n = vec3(0.);\n    for (int i=ZERO; i<4; i++)\n    {\n        vec3 e = 0.5773*(2.*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.);\n        n += e*map(p+e*h).d; /* btw: s/pos/p */\n    }\n    return normalize(n);\n}\n\nfloat getAO(Sample s)\n{\n    float d = .18;\n    return clamp(mix(.5, 1., map(s.wp + s.norm*d).d/d), 0., 1.);\n}\n\nvec3 wood(Sample s)\n{\n    vec3 col = vec3(1., .4, .05);\n    float top = texture(iChannel0, s.wp.xy*vec2(.3, 1.)).r;\n    float left = texture(iChannel0, s.wp.yz*vec2(.1, 1.)).r;\n    float front = texture(iChannel0, s.wp.xz*vec2(.1, 1.)).r;\n    float m = mix(left, front, dot(s.norm, vec3(0., 1., 0.)));\n    m = mix(m, top, dot(s.norm, vec3(0., 0., 1.)));\n    \n    return col*pow(m, 1.8);\n}\n\nvec3 clay(Sample s)\n{\n    vec3 col = vec3(1., .4, .4);\n    float top = texture(iChannel1, s.wp.xy*2.).r;\n    float left = texture(iChannel1, s.wp.yz*2.).g;\n    float front = texture(iChannel1, s.wp.xz*2.).b;\n    float m = mix(left, front, dot(s.norm, vec3(0., 1., 0.)));\n    m = mix(m, top, dot(s.norm, vec3(0., 0., 1.)));\n    \n    return col*pow(m, .6);\n}\n\nvec3 concrete(Sample s)\n{\n    vec3 top = texture(iChannel0, s.wp.xy).rgb;\n    vec3 left = texture(iChannel0, s.wp.yz).rgb;\n    vec3 front = mix(texture(iChannel0, s.wp.xz).rgb, texture(iChannel0, s.wp.xz+vec2(.3, -.2)).rgb, smoothstep(0.3, .8, texture(iChannel1, s.wp.xz*.01).r));\n    vec3 m = mix(left, front, dot(s.norm, vec3(0., 1., 0.)));\n    m = mix(m, top, dot(s.norm, vec3(0., 0., 1.)));\n    return pow(m, vec3(2.2));\n}\n\nvec3 getColor(Sample s)\n{\n    switch (s.mat){\n    case 0:\n        return vec3(1.);\n    case 1:\n        return vec3(.1, .3, 0.)*smoothstep(0., 1., texture(iChannel0, s.wp.xy*.3).r);\n    case 2:\n        return vec3(0., 1., 0.);\n    case 3:\n        return concrete(s);\n    case 4:\n        return wood(s);\n    case 5:\n        return clay(s);vec3(.4, .3, .9);\n    case 6:\n        return vec3(.1, .3, .0);\n    case 7:\n        return vec3(mix(vec3(.05, .1, 1.), vec3(.7, .7, 1.), smoothstep(.4, .55, sin(s.wp.z*8.-s.wp.x-5.2)*.5+.5)));\n    }\n    return vec3(1., 0., 1.);\n}\n\nSample march(vec3 ro, vec3 rd, int ms, float md)\n{\n    Sample o;\n    Map m;\n    o.dist = 0.;\n    o.mat = 0;\n    float d = 0.;\n    for (int i=0; i<ms; i++){\n        m = map(ro + o.dist*rd);\n        o.dist += m.d;\n        if (m.d < sdist || m.d > md){\n            o.wp = ro + o.dist*rd;\n            o.mat = m.m;\n            o.norm = getNormal(o.wp);\n            o.ao = getAO(o);\n            o.col = getColor(o);\n            return o;\n        }\n    }\n    o.wp = ro + o.dist*rd;\n    o.norm = getNormal(o.wp);\n    o.ao = getAO(o);\n    o.col = getColor(o);\n    return o;\n}\n\nSample clight(Sample s, Light l)\n{\n    vec3 rd = normalize(l.p-s.wp);\n    float n = dot(rd, s.norm);\n    float dist = clamp(distance(l.p, s.wp), 0., l.d);\n    float d = clamp(min(n, march(s.wp+(sdist+.02)*rd, rd, shadowsteps, maxlightdist).dist/dist), 0.05, 1.);\n    s.shadow += d*l.c;\n    return s;\n}\n\nSample calcLight(Sample s)\n{\n    Light l1 = Light(\n        vec3(2., 0., 4.),\n        vec3(1.),\n        80.\n    );\n    Light l2 = Light(\n        vec3(-5., -3., 3.),\n        vec3(.7, .4, .3),\n        80.\n    );\n    s = clight(s, l1);\n    s = clight(s, l2);\n    return s;\n}\n\nvec3 composite(Sample s)\n{\n    s = calcLight(s);\n    vec3 col = mix(s.col * s.ao * s.shadow, sky, step(100., s.dist));\n    float fog = clamp(s.dist*.01-.1, 0., 1.)*smoothstep(0.2, .8, clamp(4.8-s.wp.z*.2, 0., 1.));\n  //  return vec3(fog);\n    return mix(col, ambi, fog);\n}\n\n/* stolen from https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/ */\n/* thanks, demofox */\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    float d = iResolution.x/iResolution.y;\n    uv.x *= d;\n    \n    float f = -2.4;\n    \n    vec3 cr = vec3(0.3+cos(iTime*3.21)*.001-sin(iTime)*.2, 0.05+sin(iTime*3.6)*.001, .0+sin(iTime*2.6)*.002);\n    vec3 cp = vec3(sin(iTime)-2.7, -8.0, 2.);\n    vec3 rd = rotate(vec3(uv.x, f, uv.y), cr);\n    \n    Sample s = march(cp, rd, basesteps, culldist);\n    vec3 col = composite(s);\n    \n#ifdef AA\n    /* sample neighbor pixels (2x2 only) */\n    /*  xx  */\n    /*  x   */\n    vec2 diff = ((fragCoord+vec2(1.))-fragCoord)/2./iResolution.xy;\n    rd = rotate(vec3(uv.x, f, uv.y+diff.y), cr);\n    s = march(cp, rd, basesteps, culldist);\n    col += composite(s);\n    rd = rotate(vec3(uv.x+diff.x, f, uv.y), cr);\n    s = march(cp, rd, basesteps, culldist);\n    col += composite(s);\n    col /= 3.;\n#endif\n\n    col = pow(ACESFilm(col*.6), vec3(1./2.2));\n\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sll3RN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[560, 560, 610, 610, 688], [690, 690, 738, 738, 921], [923, 923, 971, 971, 1065], [1067, 1067, 1107, 1107, 1195], [1197, 1197, 1226, 1226, 1684], [1686, 1686, 1713, 1713, 1793], [1795, 1795, 1825, 1825, 1906], [1908, 1908, 1939, 1939, 2019], [2021, 2021, 2038, 2038, 3424], [3426, 3442, 3466, 3466, 3739], [3741, 3741, 3764, 3764, 3850], [3852, 3852, 3873, 3873, 4240], [4242, 4242, 4263, 4263, 4598], [4600, 4600, 4625, 4625, 5026], [5028, 5028, 5053, 5053, 5593], [5595, 5595, 5645, 5645, 6161], [6163, 6163, 6197, 6197, 6464], [6466, 6466, 6494, 6494, 6736], [6738, 6738, 6764, 6764, 7010], [7012, 7128, 7151, 7151, 7306], [7308, 7308, 7365, 7365, 8292]], "test": "error"}
{"id": "sll3Rr", "name": "REWORK", "author": "waifutaker", "description": "aaaa", "tags": ["aaaa"], "likes": 1, "viewed": 79, "published": "Public", "date": "1621508746", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 600\n#define MAX_DIST 600.\n#define SURF_DIST .001\n//Второй обЬект повороты цвета мягкие тени;\n\n\n/*void sphereFold(inout vec3 z, inout float dz) {\n\tfloat r2 = dot(z,z);\n\tif (r<minRadius2) { \n\t\t// linear inner scaling\n\t\tfloat temp = (fixedRadius2/minRadius2);\n\t\tz *= temp;\n\t\tdz*= temp;\n\t} else if (r2<fixedRadius2) { \n\t\t// this is the actual sphere inversion\n\t\tfloat temp =(fixedRadius2/r2);\n\t\tz *= temp;\n\t\tdz*= temp;\n\t}\n}\n*/\n\n\n\nvoid boxFold(inout vec3 z, inout float dz) {\n\tz = clamp(z, -3., 3.) * 2.0 - z;\n}\n\n\nmat2 Rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c,-s,s,c);\n}\n    \n\nvoid ry(inout vec3 p, float a){  \n \tfloat c,s;vec3 q=p;  \n  \tc = cos(a); s = sin(a);  \n  \tp.y = c * q.y- s * q.z;  \n  \tp.z = s * q.y + c * q.z; \n }  \n \n void ry2(inout vec3 p, float a){  \n \tfloat c,s;vec3 q=p;  \n  \tc = cos(a); s = sin(a);  \n  \tp.x = c * q.x- s * q.z;  \n  \tp.z = s * q.x + c * q.z; \n }  \n \nfloat DE3(vec3 z)\n{\n\tvec3 offset = z;\n\tfloat dr = 1.0;\n\tfor (int n = 0; n <35; n++) {\n\t\tboxFold(z,dr);       // Reflect\n\t\t//sphereFold(z,dr);    // Sphere Inversion\n \t\tfloat Scale =2.;\n                z=Scale*z + offset;  // Scale & Translate\n                dr = dr*abs(Scale)+1.0;\n\t}\n\tfloat r = length(z);\n\treturn r/abs(dr);\n}\n\n\nfloat TetraFOUR(vec3 p) {//Tetraброт\n\t//vec3 z = p;\n    p = vec3(1.*p.x,1.*p.y,1.*p.z);\n    vec4 p_vec4 = vec4(1.*p.x,p.y,p.z,0.0);\n    vec4 z = vec4(p_vec4.x,p_vec4.y,p_vec4.z,p_vec4.w);\n    \n    float t = iTime/3.0;\n\tvec4 c = 0.5*vec4(sin(t),sin(t),sin(t),sin(t));\n    \n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (float i = 0.; i < 14. ; i++) {\n\t\tr = length(z);\n        \n\t\tif (r>2.) break;\n       \n        float Power = 2.;\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;//pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = vec4(z.x*z.x-z.y*z.y-z.z*z.z+z.w*z.w, 2.*(z.x*z.y-z.z*z.w),2.*(z.x*z.z-z.y*z.w),2.*(z.x*z.w+z.y*z.z));\n\t\tz+=p_vec4;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\n\n/*\nfloat TetraFOUR(vec3 p) {//Tetraброт\n\n    p = vec3(1.*p.x,1.*p.y,1.*p.z);\n    vec4 p_vec4 = vec4(1.*p.x,p.y,p.z,0.0);\n    vec4 z = vec4(p_vec4.x,p_vec4.y,p_vec4.z,p_vec4.w);\n    \n    float t = iTime/3.0;\n\tvec4 c = 0.5*vec4(sin(t),sin(t),sin(t),sin(t));\n    vec4 nz;\n    \n\tfloat mz2 = dot(z,z);\n    float md2 = 1.0;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (float i = 0.; i < 14. ; i++) {\n\t\tr = length(z);\n        \n\t\tif (r>2.) break;\n        md2*=4.0*mz2;\n        \n        float Power = 2.;\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = c+vec4(z.x*z.x-z.y*z.y-z.z*z.z+z.w*z.w, 2.*(z.x*z.y-z.z*z.w),2.*(z.x*z.z-z.y*z.w),2.*(z.x*z.w+z.y*z.z));\n\t\tz+=p_vec4;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n*/\n/*\nfloat julia(vec3 pos)\n{\n    float t = iTime/3.0;\n    \n\tvec4 c = 0.5*vec4(cos(t),cos(t*1.1),cos(t*2.3),cos(t*3.1));\n    vec4 z = vec4( pos, 0.0 );\n\tvec4 nz;\n    \n\tfloat md2 = 1.0;\n\tfloat mz2 = dot(z,z);\n\n\tfor(int i=0;i<13;i++)\n\t{\n\t\tmd2*=4.0*mz2;\n\t    nz.x=z.x*z.x-dot(z.yzw,z.yzw);\n\t\tnz.yzw=2.0*z.x*z.yzw;\n\t\tz=nz+c;\n\n\t\tmz2 = dot(z,z);\n\t\tif(mz2>4.0)\n        {\n\t\t\tbreak;\n        }\n\t}\n\n\treturn 0.25*sqrt(mz2/md2)*log(mz2);\n}\n*/\nfloat MandelFOUR(vec3 p) {//Мандельброт 4d\n\t\n    p = vec3(1.*p.x,1.*p.y,1.*p.z);\n    vec4 p_vec4 = vec4(p.x,p.y,p.z,0.);\n    vec4 z = vec4(p,0);\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n    float r2 = 0.0;\n    float r3 = 0.0;\n\tfor (float i = 0.; i < 10. ; i++) {\n\t\tr = length(z);\n        r2 = sqrt(z.x*z.x+z.y*z.y);\n        r3 = sqrt(z.x*z.x+z.y*z.y+z.z*z.z);\n\t\tif (r>2.) break;\n\t\t\n       \n\t\t// convert to polar coordinates\n\t\tfloat phi = atan(z.z,r2);\n        float psi = atan(z.w,r3);\n\t\tfloat theta = atan(z.y,z.x);//float phi = atan(z.y,z.x);\n        float Power = 2.;\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\t\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec4(cos(2.*psi)*cos(2.*theta), cos(2.*psi)*cos(2.*phi), -cos(2.*psi)*sin(2.*phi),sin(2.*psi));\n\t\tz+=vec4(p,0);\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\n\n\n\n\n\nfloat atan3(in float y, in float x) {\n    return x == 0.0 ? sign(y)*(1.5708) : atan(y, x);\n}\nfloat DEQ(in vec3 position){\nint iterations = 26;\nfloat bailout = 8.0;\nfloat power =8.0*abs(sin(iTime/3.))+1.;\n\tvec3 z = position;\n    float dr = 1.0;\n    float r = 0.0;\n    float theta,phi,zr;\n    for(int i=0;i<iterations;i++) {\n    \tr = length(z);\n        if(r>bailout) break;\n        \n        theta = power*atan3(sqrt(z.x*z.x+z.y*z.y),z.z);\n        phi = power*atan3(z.y,z.x);\n        zr = pow(r,power);\n\t\tz = vec3( zr*sin(theta)*cos(phi) + position.x,\n                  zr*sin(phi)*sin(theta) + position.y,\n                  zr*cos(theta) + position.z\t\t );\n    \tdr = ( pow(r, power-1.0)*power*dr ) + 1.0;        \n    }\n    return 0.5*log(r)*r/dr;\n}\n\n\nfloat Quadra(vec3 p) {//quadratics\n\t//vec3 z = p;\n    vec4 p_vec4 = vec4(p.x,p.y,p.z,0);\n    vec4 z =vec4(1.*p.x,p.y,p.z,0);\n\tfloat dr = 1.;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 50 ; i++) {\n\t\tr = length(z);\n\t\tif (r>400.) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = 2.*acos(z.z/r);\n\t\tfloat phi = 2.*atan(2.*z.y,2.*z.x);//float phi = atan(z.y,z.x);\n        float Power = 2.;\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\t\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec4(cos(theta)*cos(phi), sin(phi)*cos(theta), -sin(theta),0);\n\t\tz+=p_vec4;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\n\nfloat Mandel(vec3 p) {//Мандельброт\n\t\n    vec4 p_vec4 = vec4(p.x,p.y,p.z,0);\n    vec4 z =vec4(p.x,p.y,p.z,0);\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 100 ; i++) {\n\t\tr = length(z);\n\t\tif (r>40.) break;\n        \n       \t\tfloat t = iTime/30.0;\n        \n        \n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(2.*z.y,2.*z.x);//float phi = atan(z.y,z.x);\n        float Power = abs(cos(t))*10.+1.5;\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec4(cos(theta)*cos(phi), sin(phi)*cos(theta), sin(theta),0);\n\t\tz+=p_vec4;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\nfloat Mandelbub(vec3 p) {//Мандельбуб \n\t//vec3 z = p;\n    vec4 p_vec4 = vec4(p.x,p.y,p.z,0);\n    vec4 z =vec4(p.x,p.y,p.z,0);\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 100 ; i++) {\n\t\tr = length(z);\n\t\tif (r>3.) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.x,z.y);//float phi = atan(z.y,z.x);\n        float Power =8.*(abs(sin(iTime/2.)))+2.;\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec4(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta),0);\n\t\tz+=p_vec4;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\nfloat julia(vec3 pos)\n{\n    float t = iTime/3.0;\n    \n\tvec4 c = 0.5*vec4(cos(t),cos(t*1.1),cos(t*2.3),cos(t*3.1));\n    vec4 z = vec4( pos, 0.0 );\n\tvec4 nz;\n    \n\tfloat md2 = 1.0;\n\tfloat mz2 = dot(z,z);\n\n\tfor(int i=0;i<21;i++)\n\t{\n\t\tmd2*=4.0*mz2;\n\t    nz.x=z.x*z.x-dot(z.yzw,z.yzw);\n\t\tnz.yzw=2.0*z.x*z.yzw;\n\t\tz=nz+c;\n\n\t\tmz2 = dot(z,z);\n\t\tif(mz2>4.0)\n        {\n\t\t\tbreak;\n        }\n\t}\n\n\treturn 0.25*sqrt(mz2/md2)*log(mz2);\n}\n\nfloat DE(vec3 z)// Треугольник серпинского \n{\n vec3 n1 = vec3(-z.y,z.x,z.z);\n \n //float t = dot(z,n1); if (t<0.0) { z-=2.0*t*n1; }\n \n float r;\n \n \n int n = 0;\n float Scale=2.0;\n float Offset =8.;\n while (n < 15) {\n if(z.x+z.y<0.) z.xy = -z.yx; // fold 1  -z.yx*.8*cos(iTime)\n if(z.x+z.z<0.) z.xz = -z.zx; // fold 2\n if(z.y+z.z<0.) z.zy = -z.yz; // fold 3 \n float t = dot(z,n1); \n //if (t<0.0){ \n //z-=2.0*t*n1; \n \n z = z*Scale - Offset*(Scale-1.0);\n \n n++;\n }\n \n return (length(z) ) * pow(Scale, -float(n));\n}\n\n\n\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n\n\nfloat sphereDist( vec3 p )\n    {\n  vec4 s = vec4(0., 0.1, 0.1, 1);\n  \n  return length(p-s.xyz)-s.w;\n}\n\n\n float f(vec3 p){\n\n\n     return DEQ(1.*p);//TetraFOUR(p);  Quadra\n } \n\n\nfloat opTwist( in vec3 p )//Спираль \n{\n    float k = 0.*sin(iTime); // or some other amount\n    float c = sin(k*p.y);\n    float s = cos(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);//vec3(m*p.xz,p.x);\n    return f(q);\n}\n\nfloat opRep( in vec3 p, in vec3 c )// зеркало \n{\n    vec2 t = vec2(1);//vec2\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return  f(q); //зеркало premitive change \n}\n\n\nfloat opDisplace( in vec3 p )//sin \n{\n    \n    float d2 = (sin(5.*sin(iTime)*p.x)*sin(1.*sin(iTime)*p.y)*sin(sin(iTime)*p.z));\n    return f(p)+d2;\n}\n\n\nfloat GetDist(vec3 p) {\n\tvec3 b = vec3(10);\n    float s = 1.;\n    \n    float planeDist =0.*p.y+11.;//high\n    \n    float dg= opTwist(.4*p);//opDisplace opTwist opRep(p,b) and size \n    \n    float d = min(dg,planeDist);\n\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(1., 1.,1.);\n    lightPos.xyz += vec3(0.,10., 10.5)*6.;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    if(d<length(lightPos-p)) dif *= .01;\n    \n    return dif;\n}\n\n\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 9.0) / (3.1415 * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\n\n\nconst vec3 RED = vec3(3.,0.001103,0.08);\nconst vec3 ORANGE = vec3(0.032,0.01,0.09);\nconst vec3 GREEN = vec3(.0,3.0,3.00);\nconst vec3 BLUE = vec3(0.0,0.0,7.00);\n\n\n///////////\nvec3 GetSky(in vec3 rd, in vec3 sunDir, in vec3 sunCol)\n{\n\tfloat sunAmount = max( dot( rd, sunDir), 0.0 );\n\tfloat v = pow(1.0-max(rd.y,0.0),6.);\n\tvec3  sky = mix(vec3(.14, .24, .39), vec3(.8732, .8732, .8732), v);\n\tsky = sky + sunCol * sunAmount * sunAmount * .25;\n\tsky = sky + sunCol * min(pow(sunAmount, 800.0)*1.5, .3);\n\treturn clamp(sky, 0.0, 1.0);\n}\n///////////\n\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0,5.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n      vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    float t = iTime;\n    vec3 ro = vec3(0, 3, -3);\n    ro.zy *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    \n    \n    float zoom =  .3;\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), zoom);//zoom\n    vec3 col = vec3(0);\n   \n   \n    float d = RayMarch(ro, rd);\n vec3 ld = vec3(0,.102, 0);\n \nvec3 sky = 1.*GetSky(rd, ld, vec3(1.1,1.4,1.2));\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n       // vec3 r = reflect(rd, n);\n\n    \n        float dif = dot(n, normalize(vec3(2)))*.73+.35;\n     \n        col = vec3(dif);\n     \n     \n     \n\n  col *= RED * 0.3;\n    float r = 2.7;\n    float ao = smoothstep(r*.6, r, length(p));\n    col = col*ao*5.0;\n\n\nvec3 l0 = normalize(vec3(-1.0,0.0,-1.0));\n    vec3 l1 = normalize(vec3(.3,.5,0.5));\n    vec3 l2 = normalize(vec3(1.0,1.0,0.4));  \n    \n  col += specular(n,l0,rd,1.1) * BLUE*vec3(.3,.3,.4);//*vec3(cos(iTime)*.5,sin(iTime)*0.4,cos(iTime)*.5);\n   col += specular(n,l1,rd,1.2) *1.1*GREEN;//* vec3(sin(iTime)*1.,cos(iTime)*1.,sin(iTime)*1.) * 1.1; \n  // col += specular(n,l2,rd,1.0) * 1.2;\n //*vec3(sin(iTime)*1.,cos(iTime)*1.,sin(iTime)*1.);\n   col = col*.50;\n   col *= hsv2rgb(col);\n   col *= vec3(dif);\n    }\n    \n  \n   \n // 0убери\n\n    //col += specular(n,l0,rd,1.1) * BLUE;//*vec3(cos(iTime)*.5,sin(iTime)*0.4,cos(iTime)*.5);\n    //col += specular(n,l1,rd,1.2) *1.1*GREEN;//* vec3(sin(iTime)*1.,cos(iTime)*1.,sin(iTime)*1.) * 1.1; \n    //col += specular(n,l2,rd,1.0) * 1.2; //*vec3(sin(iTime)*1.,cos(iTime)*1.,sin(iTime)*1.);\n    //col = col*.20;\n    \n   // col = col*vec3(dif);//col = col*vec3(dif)**vec3(dif2)\n    \n    \n   // col = col*vec3(0.9, 0.8, 0.6) *  0.2 * tc0;\n \t//col=mix(col,sky, 1.0-exp(-0.001*p.x*p.x));\n  // col = mix(hsv2rgb(col), vec3(.323), smoothstep(0., 40., d));\n  // col = pow(col, vec3(.4545));\t// gamma correction   col = pow(col, vec3(.4545)); \n    fragColor = vec4(pow(col,vec3(0.4545)),0.0);//hs2v function\n    fragColor.xyz = mix( fragColor.xyz, sky,1.0-exp( -0.01*d*d ) );//fog (*1.0-exp( -0.01*d*d )\n  }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sll3Rr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[479, 479, 523, 523, 559], [562, 562, 580, 580, 653], [660, 660, 691, 691, 807], [813, 813, 845, 845, 961], [966, 966, 985, 985, 1294], [1297, 1297, 1322, 1352, 2058], [2061, 3288, 3314, 3341, 4167], [4174, 4174, 4211, 4211, 4266], [4267, 4267, 4295, 4295, 4919], [4922, 4922, 4944, 4971, 5580], [5583, 5583, 5605, 5629, 6342], [6344, 6344, 6369, 6407, 7062], [7064, 7064, 7087, 7087, 7484], [7486, 7486, 7553, 7553, 8017], [8023, 8023, 8056, 8056, 8121], [8126, 8126, 8158, 8158, 8227], [8231, 8231, 8247, 8247, 8298], [8302, 8302, 8347, 8347, 8552], [8554, 8554, 8609, 8609, 8727], [8730, 8730, 8767, 8767, 8878], [8881, 8881, 8904, 8904, 9116], [9118, 9118, 9152, 9152, 9358], [9360, 9360, 9384, 9384, 9569], [9571, 9571, 9595, 9595, 9894], [9897, 9897, 9943, 9943, 10047], [10213, 10225, 10282, 10282, 10579], [10594, 10594, 10644, 10644, 10835], [10837, 10837, 10859, 10859, 11027], [11030, 11030, 11087, 11087, 13221]], "test": "valid"}
{"id": "sll3WH", "name": "First Shader Fun", "author": "MrNissenDK", "description": "Just me playing around with Shadertoy", "tags": ["fun", "shader"], "likes": 2, "viewed": 179, "published": "Public API", "date": "1622065647", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float res = 7.;\nint seed = 50152;\nfloat pixel = 0.;\n\nint mod2(int v, int m)\n{\n    return int(mod(float(v), float(m)));\n}\nfloat GetDigitOfPi(int i)\n{\n    float[] randomDigitsPi = float[](\n        3799.6274,9567.3518,8575.2724,\n        8912.2793,8183.0119,4912.9833,\n        6733.6244,0656.6430,8602.1394,\n        9463.9522,4737.1907,0217.9860,\n        9437.0277,0539.2171,6939.9375\n    );\n    return randomDigitsPi[abs(mod2(randomDigitsPi.length() + i, randomDigitsPi.length()))];\n}\nfloat GetDigitOfPi(float i)\n{\n    return GetDigitOfPi(int(i));\n}\n\nvec3 Hash32(vec2 src)\n{\n    src = mod(src,50.);\n    float x = floor(src.x);\n    float y = floor(src.y);\n    {\n        float _x = x;\n        float _y = y;\n        x *= _x;\n        y *= _y;\n        \n        y += _x;\n        x += _y;\n    }\n    float rand1 = GetDigitOfPi(y * GetDigitOfPi(seed + 2) + GetDigitOfPi(seed + 4));\n    float rand2 = GetDigitOfPi(x * GetDigitOfPi(seed + 3) + GetDigitOfPi(seed + 5));\n    \n    vec3 hash = vec3(fract(floor(src) * vec2(rand1,rand2)),0);\n    hash += dot(hash, hash+GetDigitOfPi(seed + 6));\n    \n    hash.z = length(hash)+rand1+rand2;\n    \n    return fract(hash);\n}\n\nfloat cirkle(vec2 uv)\n{\n    float dist = length(uv);\n    float m = smoothstep(.2, .05, dist);\n    \n    return m;\n}\n\nfloat Pixels(int n, bool left)\n{\n    if(left)\n        return pixel*float(n) -.5;\n    return .5 - pixel*float(n);\n}\nfloat Pixels(int n)\n{\n    return Pixels(n,false);\n}\nfloat Pixel(bool left){\n    return Pixels(1,left);\n}\nfloat Pixel(){\n    return Pixels(1,false);\n}\n#ifndef saturate\n#define saturate(v) clamp(v,0.,1.)\n//      clamp(v,0.,1.)\n#endif\nvec3 hsv2rgb(vec3 c){\n\tvec4 K=vec4(1.,2./3.,1./3.,3.);\n\treturn c.z*mix(K.xxx,saturate(abs(fract(c.x+K.xyz)*6.-K.w)-K.x),c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ((fragCoord - .5 * iResolution.xy) / iResolution.y) * res;\n    pixel = iResolution.x / iResolution.y * res / iResolution.x;\n    \n    uv += vec2(iTime,sin(iTime));\n    \n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    \n    vec3 col = vec3(0);\n    for(int y = -1; y <= 1; y++)\n    {\n        for(int x = -1; x <= 1; x++)\n        {\n            vec2 offset = vec2(x,y);\n            vec3 pos = Hash32(id + offset) -.5;\n            vec3 addCol = hsv2rgb(vec3(pos.z, 1 ,cirkle(gv + pos.xy - offset)));\n            col += addCol;\n        }\n    }\n    \n    /*if(\n        gv.x >= Pixel() || gv.x <= Pixel(true) || \n        gv.y >= Pixel() || gv.y <= Pixel(true)   ) col.r = 1.;\n    */\n    fragColor = vec4(col,1);\n}\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sll3WH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 77, 77, 120], [482, 482, 511, 511, 546], [548, 548, 571, 571, 1149], [1151, 1151, 1174, 1174, 1265], [1267, 1267, 1299, 1299, 1381], [1382, 1382, 1403, 1403, 1433], [1434, 1434, 1457, 1457, 1486], [1487, 1487, 1501, 1501, 1531], [1614, 1614, 1635, 1635, 1741], [1743, 1743, 1800, 1800, 2526]], "test": "error"}
{"id": "sll3zn", "name": "TDF_monacoinchan", "author": "jorge2017a1", "description": "TDF_monacoinchan", "tags": ["tdfmonacoinchan"], "likes": 12, "viewed": 84, "published": "Public", "date": "1621453921", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//by TYA-PA-\n\nvec3 skinColor1 = vec3(0.996,0.921,0.862);\nvec3 skinColor2 = vec3(0.960,0.843,0.749);\nvec3 hairColor  = vec3(0.176,0.180,0.196);\nvec3 hairColor2 = vec3(0.100,0.100,0.100);\nvec3 mayuColor  = vec3(0.160,0.078,0.058);\nvec3 mayuColor2 = vec3(0.219,0.121,0.098);\nvec3 eyeColorB  = vec3(0.317,0.184,0.149);\nvec3 eyeColorH  = vec3(0.807,0.607,0.501);\nvec3 eyeColorS  = vec3(0.756,0.717,0.709);\nvec3 ripColor   = vec3(0.925,0.737,0.650);\nvec3 fukuColor  = vec3(0.968,0.701,0.415);\nvec3 blackColor = vec3(0,0,0);\nvec3 whiteColor = vec3(1,1,1);\nvec3 whiteColor2= vec3(0.9,0.9,0.9);\nvec3 RedColor   = vec3(0.9,0.2,0.2);\nvec3 OrangeColor= vec3(0.901,0.568,0.215);\n\nvoid Face(inout vec2 p, inout vec3 col)\n{\n\t\n\t//back hair\n\tif ((length(vec2(1,0.4)*(p-vec2(-0.45,0.06))) < 0.4)\n\t    &&(abs(p.x+0.7) < 0.2 && abs(p.y+0.3) < 0.5)\n\t   ) col = blackColor; // hairBack1\n\tif ((length(vec2(1,0.5)*(p-vec2(-0.6,0.15))) < 0.5)\n\t    &&(length(vec2(1,0.5)*(p-vec2(-0.3,-0.2))) > 0.5)\n\t    &&(abs(p.x+0.9) < 0.2 && abs(p.y+0.3) < 0.5)\n\t   ) col = blackColor; // hairBack2\n\n\tif ((length(vec2(0.7,1)*(p-vec2(0.05,-1.2))) < 0.404)) col = eyeColorB; // kubi\n\tif ((length(vec2(0.7,1)*(p-vec2(0.05,-1.2))) < 0.4)) col = OrangeColor; // kubi\n\n\tif ((length(vec2(1,0.71)*(p-vec2(0.04,-1.1))) < 0.3)) col = eyeColorB; // kubi\n\tif ((length(vec2(1,0.71)*(p-vec2(0.03,-1.1))) < 0.3)) col = skinColor2; // kubi\n\n\t\n\n\t//base\n\tif ((length(vec2(0.73,1)*(p-vec2(-0.21,-0.21))) < 0.8)\n\t    &&(length(vec2(0.8,1)*(p-vec2(0.3,-0.29))) < 0.8)\n\t   ) col = eyeColorB; // face base\n\tif ((length(vec2(0.73,1)*(p-vec2(-0.21,-0.20))) < 0.8)\n\t    &&(length(vec2(0.8,1)*(p-vec2(0.3,-0.28))) < 0.8)\n\t   ) col = skinColor2; // face base\n\t\n\tif ((length(vec2(1,0.71)*(p-vec2(-0.01,0.26))) < 0.905)\n\t    &&(length(vec2(1,0.73)*(p-vec2(-0.15,0.22))) < 0.9)\n\t   ) col = eyeColorB; // face base\n\tif ((length(vec2(1,0.71)*(p-vec2(-0.01,0.26))) < 0.9)\n\t    &&(length(vec2(1,0.73)*(p-vec2(-0.15,0.22))) < 0.9)\n\t   ) col = skinColor1; // face base\n\t\n\tif (length(p-vec2(-0.2,-0.6)) < 0.1) col = mix(skinColor2, skinColor1, (length(p-vec2(-0.2,-0.6))*whiteColor) / 0.11);//nose\n\t\n\t//mouth\n\tif ((length(vec2(0.9,1)*(p-vec2(-0.16,-0.645))) < 0.17)\n\t    &&(length(vec2(0.5,1)*(p-vec2(-0.16,-0.62))) > 0.156)\n\t   ) col = mix(ripColor, skinColor1, (length(p-vec2(-0.16,-0.75))*whiteColor) / 0.17); //ripcolor1\n\n\tif ((length(vec2(0.5,1)*(p-vec2(-0.16,-0.922))) < 0.17)\n\t    &&(length(vec2(0.2,1)*(p-vec2(-0.16,-0.953))) > 0.18)\n\t   ) col = mix(ripColor, skinColor1, (length(p-vec2(-0.16,-0.85))*whiteColor) / 0.17); //ripcolor1\n\t\n\tif ((length(vec2(0.5,1)*(p-vec2(-0.16,-0.64))) < 0.14)\n\t    &&(length(vec2(0.5,1)*(p-vec2(-0.16,-0.62))) > 0.157)\n\t   ) col = mayuColor; //mouth\n\t\n\tif (length(p-vec2(-0.18,-0.795)) < 0.01) col = whiteColor; // hilight1\n\tif (length(p-vec2(-0.16,-0.795)) < 0.005) col = whiteColor; // hilight1\n}\n\nvoid RightEye(inout vec2 p, inout vec3 col)\n{\n\t//bases\n\tif (length(vec2(1,0.6)*(p-vec2(-0.58,-0.12))) < 0.15) col = whiteColor; // base1-1\n\tif (length(vec2(1,0.59)*(p-vec2(-0.645,-0.079))) < 0.11)col = whiteColor; // base1-2\n\tif ((length(vec2(1,0.6)*(p-vec2(-0.603,-0.12))) < 0.159)\n\t    &&(length(vec2(1,0.9)*(p-vec2(-0.61,-0.18))) > 0.2)) col = eyeColorS; // eyeline kage\n\n\t\n\tif (length(vec2(1,0.55)*(p-vec2(-0.58,-0.115))) < 0.11) col = blackColor; // base2-1\n\tif (length(vec2(1,0.56)*(p-vec2(-0.59,-0.08))) < 0.115) col = blackColor; // base2-2\n\tif (length(vec2(1,0.55)*(p-vec2(-0.58,-0.115))) < 0.103) col = eyeColorB; // base3-1\n\tif (length(vec2(1,0.56)*(p-vec2(-0.59,-0.08))) < 0.103) col = eyeColorB; // base3-2\n\n\tif ((length(p-vec2(-0.62,0.0)) < 0.17)\n\t    &&(length(vec2(1,0.56)*(p-vec2(-0.59,-0.08))) < 0.103)\n\t   )col = (length(p-vec2(-0.62,0.0))*eyeColorB) / 0.17; //eye base shadow\n\tif ((length(p-vec2(-0.55,-0.28)) < 0.12)\n\t    &&(length(vec2(1,0.55)*(p-vec2(-0.58,-0.115))) < 0.103)\n\t   )col = mix(eyeColorH, eyeColorB, (length(p-vec2(-0.55,-0.28))*whiteColor) / 0.12); // eye base hilight\n\t\n\t\n\t//center\t\n\tif (length(vec2(1,0.4)*(p-vec2(-0.59,-0.11))) < 0.042) col = mayuColor; //eye center1\n\tif (length(vec2(1,0.36)*(p-vec2(-0.59,-0.11))) < 0.036) col = (length(vec2(1,0.5)*(p-vec2(-0.59,-0.11)))*eyeColorB) / 0.05; // eye center2\n\tif (length(p-vec2(-0.59,-0.11)) < 0.017) col = blackColor; // eye center 3\n\t\n\t// hilight\n\tif (length(vec2(0.6,1)*(p-vec2(-0.53,0.01))) < 0.027) col = whiteColor; //hilight1\n\tif (length(p-vec2(-0.67,-0.22)) < 0.026) col = whiteColor; // hilight2\n\tif (length(p-vec2(-0.61,-0.16)) < 0.015) col = (0.002 / (length(p-vec2(-0.61,-0.16))*whiteColor)) + mayuColor; // hilight3\n\n\t// blow\n\tif ((length(vec2(1,0.6)*(p-vec2(-0.6,-0.15))) < 0.175)\n\t    &&(length(vec2(1,0.56)*(p-vec2(-0.63,-0.179))) > 0.16)\n\t    &&(length(vec2(1,0.59)*(p-vec2(-0.58,-0.2))) > 0.16)\n\t   ) col = mayuColor; //eyeblow1-1\n\tif ((length(vec2(1,0.55)*(p-vec2(-0.65,-0.05))) < 0.12)\n\t    &&(length(vec2(1,0.8)*(p-vec2(-0.615,-0.055))) > 0.13)\n\t    &&(length(vec2(1,0.56)*(p-vec2(-0.645,-0.09))) > 0.11)\n\t   ) col = mayuColor; //eyeblow1-2\n\tif ((length(vec2(1,0.8)*(p-vec2(-0.631,-0.045))) < 0.17)\n\t\t&& (length(vec2(0.8,1)*(p-vec2(-0.65,-0.07))) > 0.2)\n\t   ) col = mayuColor; //eyeblow1-2\n\n\tif ((length(vec2(1,0.97)*(p-vec2(-0.65,-0.0))) < 0.2)\n\t    &&(length(vec2(1,0.9)*(p-vec2(-0.65,-0.085))) > 0.25)) col = mayuColor; //mayu\n}\n\nvoid LeftEye(inout vec2 p, inout vec3 col)\n{\n\t//      sizeraito x y          pos x y      size\n\t// bases\n\tif (length(vec2(1,0.9)*(p-vec2(0.36,-0.12))) < 0.25) col = whiteColor; // base\n\tif ((length(vec2(1,0.9)*(p-vec2(0.36,-0.12))) < 0.25)\n\t    &&(length(vec2(0.9,1)*(p-vec2(0.36,-0.2))) > 0.25)) col = eyeColorS; // eyeline kage\n\t\n\tif (length(vec2(1,0.75)*(p-vec2(0.358,-0.11))) < 0.17) col = blackColor;\n\tif (length(vec2(1,0.75)*(p-vec2(0.358,-0.11))) < 0.16) col = eyeColorB; //base 2\n\tif ((length(p-vec2(0.34,0.0)) < 0.17)\n\t    &&(length(vec2(1,0.75)*(p-vec2(0.358,-0.11))) < 0.16))col = (length(p-vec2(0.34,0.0))*eyeColorB) / 0.17; //eye base shadow\n\tif ((length(p-vec2(0.4,-0.28)) < 0.17)\n\t    &&(length(vec2(1,0.75)*(p-vec2(0.358,-0.11))) < 0.16))col = mix(eyeColorH, eyeColorB, (length(p-vec2(0.4,-0.28))*whiteColor) / 0.17); // eye base hilight\n\t\n\t// center\n\tif (length(vec2(1,0.60)*(p-vec2(0.358,-0.11))) < 0.07) col = mayuColor; //eye center1\n\tif (length(vec2(1,0.55)*(p-vec2(0.358,-0.11))) < 0.06) col = (length(p-vec2(0.358,-0.11))*eyeColorB) / 0.1; // eye center2\n\tif (length(p-vec2(0.358,-0.11)) < 0.025) col = blackColor; // eye center 3\n\t\n\t// hilight\n\tif (length(vec2(0.6,1)*(p-vec2(0.46,0.029))) < 0.035) col = whiteColor; //hilight1\n\tif (length(p-vec2(0.25,-0.27)) < 0.03) col = whiteColor; // hilight2\n\tif (length(p-vec2(0.325,-0.16)) < 0.025) col = (0.003 / (length(p-vec2(0.325,-0.16))*whiteColor)) + mayuColor; // hilight3\n\n\t// blow\n\tif ((length(vec2(1,0.9)*(p-vec2(0.37,-0.115))) < 0.265)\n\t    &&(length(vec2(1,0.9)*(p-vec2(0.36,-0.175))) > 0.255)) col = mayuColor; //eyeblow1\n\tif ((length(vec2(1,1.1)*(p-vec2(0.37,-0.1))) < 0.3)\n\t    &&(length(vec2(1,1.4)*(p-vec2(0.41,-0.15))) > 0.38)\n\t    &&(length(p-vec2(0.5,-0.1)) > 0.3)\n\t   ) col = mayuColor; //eyeblow2\n\tif ((length(vec2(1,1)*(p-vec2(0.87,0.08))) < 0.3)\n\t    &&(length(vec2(1,0.9)*(p-vec2(0.9,0.08))) > 0.3)\n\t    &&(length((p-vec2(0.83,0.2))) > 0.3)\n\t   ) col = mayuColor; //eyeblow3\n\tif ((length(vec2(1,0.9)*(p-vec2(0.37,-0.115))) < 0.245)\n\t    &&(length(vec2(1,0.9)*(p-vec2(0.36,-0.175))) > 0.27)) col = mayuColor2; //eyeblow4\n\t\n\tif ((length(vec2(0.97,1)*(p-vec2(0.38,-0.18))) < 0.4)\n\t    &&(length(vec2(0.9,1)*(p-vec2(0.38,-0.2))) > 0.4)) col = mayuColor; //mayu\n\n\tif ((length(vec2(1,0.5)*(p-vec2(-0.81,0.46))) < 0.2)) col = skinColor2; // hair kage\n}\n\nvoid Hair(inout vec2 p, inout vec3 col)\n{\n\tif ((length(vec2(1,0.5)*(p-vec2(-0.23,0.4))) < 0.25)) col = skinColor2; // hair kage\n\t\n\tif ((length(p-vec2(-0.4,0.6)) < 0.7)&&(length(p-vec2(-1.3,0.61)) < 0.7))col = hairColor; // hair1\n\tif ((length(p-vec2(0.09,0.5)) < 0.7)&&(length(p-vec2(-0.72,0.42)) < 0.7))col = hairColor; // hair1\n\tif ((length(p-vec2(0.63,0.75)) < 0.7)&&(length(p-vec2(-0.05,0.6)) < 0.7))col = hairColor; // hair2\n\tif ((length(vec2(0.7,1)*(p-vec2(-0.4,0.9))) < 0.4)) col = hairColor; // hair\n\n\tif ((length(vec2(1,0.5)*(p-vec2(0.7,0.01))) < 0.5)\n\t    &&(length(vec2(1,0.5)*(p-vec2(0.55,-0.1))) > 0.5)\n\t    &&(abs(p.x-0.9) < 0.3 && abs(p.y+0.92) > 0.2)\n\t   ) col = blackColor; // hair\n\n\t\n\tif ((length(vec2(1,0.5)*(p-vec2(0.54,0.38))) < 0.26)\n\t    &&(length(vec2(1,0.5)*(p-vec2(0.35,0.0))) > 0.26)\n\t   ) col = hairColor; // hair\n\n\tif ((length(vec2(1,0.5)*(p-vec2(0.58,0.01))) < 0.5)\n\t    &&(length(vec2(1,0.5)*(p-vec2(0.3,-0.1))) > 0.5)\n\t   ) col = hairColor; // hair\n\t\n\tif ((length(vec2(1,0.5)*(p-vec2(0.95,0.04))) < 0.5)\n\t    &&(length(vec2(1,0.5)*(p-vec2(0.63,-0.15))) > 0.5)\n\t   ) col = hairColor; // hair\n\n\t\n\tif ((length(vec2(1,0.5)*(p-vec2(-0.615,0.25))) < 0.6)\n\t    &&(length(vec2(1,0.5)*(p-vec2(-0.43,0.15))) > 0.6)\n\t   ) col = blackColor; // hairkage\n\tif ((length(vec2(1,0.5)*(p-vec2(-0.6,0.25))) < 0.6)\n\t    &&(length(vec2(1,0.5)*(p-vec2(-0.43,0.15))) > 0.6)\n\t   ) col = hairColor; // hair\n\n\n\tif ((length(vec2(1,0.5)*(p-vec2(-0.87,0.38))) < 0.26)\n\t    &&(length(vec2(1,0.5)*(p-vec2(-0.66,0.2))) > 0.26)\n\t   ) col = blackColor; // hair\n\n\tif ((length(vec2(1,0.5)*(p-vec2(-0.865,0.4))) < 0.265)\n\t    &&(length(vec2(1,0.5)*(p-vec2(-0.66,0.2))) > 0.25)\n\t   ) col = hairColor; // hair\n\n\t\n\t// kamikage\n\tif ((length(vec2(1,0.5)*(p-vec2(-0.3,0.49))) < 0.3)\n\t    &&(length(vec2(1,0.5)*(p-vec2(-0.47,0.6))) > 0.41)\n\t   )col = hairColor2; // hairkage\n\t\n\tif ((length(vec2(1,0.65)*(p-vec2(-0.92,0.525))) < 0.3)\n\t    &&(length(vec2(1,0.65)*(p-vec2(-1.05,0.63))) > 0.41)\n\t   )col = hairColor2; // hairkage\n\t\n\tif ((length(vec2(1,0.65)*(p-vec2(0.32,0.525))) < 0.3)\n\t    &&(length(vec2(1,0.65)*(p-vec2(0.19,0.62))) > 0.41)\n\t   )col = hairColor2; // hairkage\n\t\n\tif ((length(vec2(1,0.5)*(p-vec2(0.58,0.01))) < 0.5)\n\t    &&(length(vec2(1,0.5)*(p-vec2(0.5,0.0))) > 0.5)\n\t   ) col = hairColor2; // hairkage\n\n\tif ((length(vec2(1,0.5)*(p-vec2(0.95,0.04))) < 0.5)\n\t    &&(length(vec2(1,0.5)*(p-vec2(0.85,-0.0))) > 0.5)\n\t   ) col = hairColor2; // hairkage\n}\n\nvoid Mona(inout vec2 p, inout vec3 col)\n{\n\tif ((length(p-vec2(0.9,1.08)) < 0.88)&&(length(p-vec2(0.76,0.9)) < 0.75))col = whiteColor; // monanabase\n\tif ((length(p-vec2(0.9,1.08)) < 0.88)&&(length(p-vec2(1.1,1.2)) > 1.0))col = whiteColor2;\n\n\tif ((length(vec2(1,0.7)*(p-vec2(0.853,0.83))) < 0.083))col = RedColor;\n\t\n\tif ((length(p-vec2(-0.4,0.0)) < 1.0)\n\t  &&(length(p-vec2(-0.3,-0.2)) > 1.2)\n\t   )col = RedColor;\n\t\n    \tfloat s = sin(sin(-4.0) * 0.75);\n    \tvec2 q = p * mat2(0, -s, s, 0);\t\n\tif(abs(p.x-0.5+q.x) < 0.03 && abs(p.y-0.81) < 0.17)col = blackColor;\n\n    \ts = sin(sin(-2.7) * 0.75);\n    \tq = p * mat2(0, -s, s, 0);\t\n\tif(abs(p.x-1.05+q.x) < 0.03 && abs(p.y-0.84) < 0.2)col = blackColor;\n\t\n    \ts = sin(sin(1.0) * 0.75);\n\tfloat c = cos(sin(1.0 * 2.0));\n    \tq = p * mat2(c, -s, s, c);\t\n\tif(abs(p.x-0.82+q.x) < 0.2 && abs(p.y-1.99 + q.y) < 0.05)col = blackColor;\n\t\n    \ts = sin(sin(-2.4) * 0.75);\n    \tq = p * mat2(0, -s, s, 0);\t\n\tif(abs(p.x-1.67+q.x) < 0.03 && abs(p.y-1.02) < 0.1)col = blackColor;\n}\n\nvec3 snowflake(vec3 coords, vec2 pxPos) { \n\tfloat focalPlane = 0.5 + 2.5 * 0.7; \n\tfloat iris = 0.01;\n\t\n\tfloat pxDiam = abs(coords.z - focalPlane) * iris; \n\tvec2 flakePos = vec2(coords.xy) / coords.z; \n\tfloat flakeDiam = 0.003 / coords.z; \n\t\n\tfloat dist = length(pxPos - flakePos); \n\tfloat bri = (pxDiam + flakeDiam - dist) / (pxDiam * 2.0); \n\tif (pxDiam > flakeDiam) { \n\t\tbri /= (pxDiam / flakeDiam); \n\t} \n\n\treturn vec3(0.7, 0.9, 1.0) * min(1.0, max(0.0, bri)); \n}\n\n\nvec2 EffectBass(inout vec2 p, inout vec3 c, int i)\n{\n    \tc.z = fract(sin(float(i) * 25.643) * 735.5373); \n    \tc.z *= 0.2 + fract(sin(float(i) * 74.753) * 526.5463); \n    \tc.z = 0.5 + (1.0 - c.z) * 2.4; \n    \tfloat gSize = 0.5 / c.z; \n    \tvec2 drift = vec2(0); \n    \tdrift.x = fract(sin(float(i) * 52.3464) * 353.43354) * 4.0; \n    \tdrift.x = drift.x + iTime * 0.06 + 4.0 * sin(iTime * 0.03 + c.z * 7.0); \n    \tdrift.y = fract(sin(float(i) * 63.2356) * 644.53463) * 4.0; \n    \tdrift.y = drift.y + iTime * -0.2; \n    \tdrift /= c.z; \n     \n    \tvec2 grid = vec2(mod((p.x+drift.x)/c.z, gSize), mod((p.y-drift.y)/c.z, gSize)); \n    \tc.x = gSize*0.5; \n    \tc.y = gSize*0.5;\n\treturn grid;\n}\n\nvoid MonaCoinChang(inout vec2 p, inout vec3 col)\n{\n\tcol = vec3(0.75, 0.7, 0.7 ); \n\t\n\t\n\tfor (int i=0; i<50; i++) { \n\t\tvec3 c = vec3(0);      \n\t\tvec2 grid = EffectBass(p,c,i);\n\t\tcol += snowflake(c, grid); \n\t}\n\t\n\tfloat s = sin(sin(0.25))*0.9;\n   \tfloat c = cos(sin(0.25))*0.9;\n    \tp = p * mat2(c, -s, s, c);\n\tp = vec2(p.x-0.1, p.y-0.05);\n\t\n\tFace(p, col);\n\tLeftEye(p, col);\n\tRightEye(p, col);\n\tHair(p, col);\n\tMona(p, col);\t\n\t\n\tfor (int i=0; i<5; i++) { \n\t\tvec3 c = vec3(0);      \n\t\tvec2 grid = EffectBass(p,c,i);\n\t\tcol += snowflake(c, grid); \n\t}\n}\n\nvec3 filterr(vec3 color, vec2 pFragCoord)\n{\n  return color * 0.5 * (2.0 - pFragCoord.x / iResolution.x + pFragCoord.y / iResolution.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 p = 2.0*( fragCoord.xy / iResolution.xy ) -1.0;\n\tp.x *= iResolution.x/iResolution.y; \n\tvec3 col;\n\n\tMonaCoinChang(p, col);\n\tfragColor = vec4(filterr(col,fragCoord),  1.0); \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sll3zn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[667, 667, 708, 723, 2861], [2863, 2863, 2908, 2917, 5304], [5306, 5306, 5350, 5410, 7642], [7644, 7644, 7685, 7685, 10095], [10097, 10097, 10138, 10138, 11105], [11107, 11107, 11148, 11148, 11571], [11574, 11574, 11626, 11626, 12260], [12262, 12262, 12312, 12312, 12806], [12808, 12808, 12851, 12851, 12945], [12947, 12947, 13004, 13004, 13185]], "test": "valid"}
{"id": "sllGR4", "name": "5th try", "author": "TheoWU", "description": "practice", "tags": ["practive"], "likes": 2, "viewed": 28, "published": "Public", "date": "1621674812", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rect(vec2 uv, float l, float r, float b, float t, float blur){\n    float c = clamp(-(uv.x-r)/(.05*blur),0.,1.);\n    c -= clamp(-(uv.x-l)/(1.*blur),0.,1.);\n    c -= clamp(-(uv.y-b)/(.5*blur),0.,1.);\n    c -= clamp((uv.y-t)/(.5*blur),0.,1.);\n    return c;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    //uv.x += uv.y*0.2;\n    float fx = uv.x;\n    float fy = uv.y + sin(8.*(fx+iTime))*.1;\n    //x += y*0.2-0.1;\n    //y += (x-0.5)*(x+0.5); \n    float blur = clamp(fx,0.05,0.3);\n    float c = rect(vec2(fx,fy),-0.5,0.5,-0.1,0.1,blur);\n    // Output to screen\n    fragColor = vec4(vec3(c),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sllGR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 68, 68, 261], [262, 262, 319, 369, 760]], "test": "valid"}
{"id": "sllGzH", "name": "Translate&Rotate&Scale", "author": "xxxbbbooo", "description": "a practice of translate,rotate and scale\ncode refers from the book of shaders\nhttps://thebookofshaders.com/08/", "tags": ["rotate", "radar", "scale", "translate"], "likes": 3, "viewed": 43, "published": "Public", "date": "1621567313", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141593\n#define TWO_PI 6.283185\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0,\n                0.0,_scale.y);\n}\n\nfloat box(in vec2 _st, in vec2 _size){\n    _size = vec2(0.5) - _size*0.5;\n    vec2 uv = smoothstep(_size,\n                        _size+vec2(0.001),\n                        _st);\n    uv *= smoothstep(_size,\n                    _size+vec2(0.001),\n                    vec2(1.0)-_st);\n    return uv.x*uv.y;\n}\n\nvec3 drawPolygon(int n, vec2 st)\n{\n    // Angle and radius from the current pixel\n    float a = atan(st.x,st.y)+PI;\n    float r = TWO_PI/float(n);\n\n    // Shaping function that modulate the distance\n    float d = cos(floor(.5+a/r)*r-a)*length(st);\n\n    return vec3(1.0-smoothstep(.35,.45,d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 st = uv*2.-1.;\n    st.x *= iResolution.x/iResolution.y;\n    \n    float a, b, c = 0.;    \n    \n    // left triangle\n    vec2 st_tri = st*10. + vec2(10.+sin(iTime)*0.5, 0.);\n    st_tri = rotate2d(PI/2.)*st_tri;\n    vec3 col = drawPolygon(3, st_tri);\n    \n    // right triangle\n    st_tri = st*10. - vec2(10.+sin(iTime)*0.5, 0.);\n    st_tri = rotate2d(PI*3./2.)*st_tri;\n    col += drawPolygon(3, st_tri);\n    \n    // center circle\n    for (float i = 0.; i < 4.; ++i) {\n        a = 1.- smoothstep(1.-i*0.25-0.01, 1.-i*0.25, length(scale(vec2(1.))*st));\n        b = 1.- smoothstep(1.-i*0.25-0.05+0.01*i, 1.-i*0.25-0.04+0.01*i, length(scale(vec2(1.))*st));\n        if (i == 0.) {\n            c = (1.-step(abs(st.y-i*0.25), 0.1));\n        } else {\n            c = 1.;\n        }\n        col += vec3(0., (a - b)*c*0.4, 0.);\n    }\n    \n    // center spot\n    a = 1.- smoothstep(0.05, 0.06, length(st));\n    col += vec3(a*sin(iTime*4.), 0., 0.);\n    \n    // grid lines\n    a = smoothstep(-0.01, 0.0, st.x-st.y);\n    b = smoothstep(0.0, 0.01, st.x-st.y);\n    col += vec3(a-b);\n    \n    a = smoothstep(-0.01, 0.0, -st.x-st.y);\n    b = smoothstep(0.0, 0.01, -st.x-st.y);\n    col += vec3(a-b);\n    \n    // needle\n    a = box(rotate2d(iTime/2.+PI/2.)*st+vec2(0.5, 0.02), vec2(0.02, 0.95));\n    //vec3 shadow = vec3(0.3, 0.7, st.x);\n    if (a == 1.) {\n        col += vec3(0.3, 0.7, a);\n    }\n    \n    // obstruction\n    vec2 st_obs = st*10.+ vec2((sin(iTime*0.03)+cos(iTime*0.1))*5., cos(iTime*0.01)*5.);\n    a = 1.- smoothstep(0.1, 0.2, length(st_obs));\n    b = 1.- smoothstep(0.2, 0.3, length(scale(vec2(sin(iTime*2.)+1.5))*st_obs));\n    c = 1.- smoothstep(0.3, 0.35, length(scale(vec2(sin(iTime*2.)+1.5))*st_obs));\n    col += vec3(a+c-b, a+c-b, 0.);\n    \n\n    // Output to screen\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sllGzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 45, 73, 73, 159], [161, 161, 185, 185, 248], [250, 250, 288, 288, 555], [557, 557, 591, 638, 851], [853, 853, 910, 960, 2809]], "test": "valid"}
{"id": "sls3DN", "name": "fleshy voronoi", "author": "schobbejack", "description": "fleshy polar voronoi", "tags": ["voronoi", "polar"], "likes": 9, "viewed": 78, "published": "Public", "date": "1622479525", "time_retrieved": "2021-10-01T00:00:00", "image_code": "uint hash2(uint x)\n{\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nfloat rand(vec2 uv)\n{\n    uint fb = floatBitsToUint(uv.y)^hash2(floatBitsToUint(uv.x));\n\n    fb = hash2(fb) & 0x007fffffu | 0x3f800000u;\n    float f = uintBitsToFloat(fb) - 1.0;\n\n    return f;\n}\n\nvec2 polar(vec2 uv)\n{\n    return vec2(length(uv),(atan(uv.x,uv.y))*1.);\n}\n\nfloat v(vec2 uv)\n{\n    float grid_size = 6.;\n    uv = (polar(uv)-vec2(iTime*0.2,0.)) * grid_size;\n    uv.y =abs(uv.y*0.12);\n    vec2 i_uv = floor(uv);\n    vec2 f_uv = fract(uv);\n        \n    const float m = sqrt(2.);\n    float r = m;\n    \n    for(float y = -1.; y <= 1.; y++)\n    {\n        for(float x = -1.; x <= 1.; x++)\n        {\n            vec2 n = vec2(x,y);\n            vec2 p = vec2(rand(i_uv+n));\n            p = vec2(sin(p.x*(4.+iTime)*0.5),cos(p.y*iTime*1.5))*0.5+0.5;\n            vec2 d = (n + p - f_uv);\n            r = min(r,length(d));\n        }\n    }\n    \n    return 1.0-pow(r*(0.5*m),0.1);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(pow(length(uv*.4),2.))*vec3(0.31,0.13,.2)*v(uv)*40.;\n    \n    fragColor = vec4(pow(col,vec3(1.0/2.2)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sls3DN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 134], [136, 136, 157, 157, 330], [332, 332, 353, 353, 405], [407, 407, 425, 425, 1015], [1018, 1018, 1075, 1125, 1315]], "test": "valid"}
{"id": "slsGRS", "name": "FirsttimeRound", "author": "stephenhalker", "description": "you gotta start somewhere, right?", "tags": ["learningthebasics"], "likes": 0, "viewed": 31, "published": "Public", "date": "1622348137", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime*0.25+uv.xyx+vec3(0,2,4));\n    col.r= sin(col.r*2.0)+0.5*0.5;\n    col.b= sin(col.r*4.0)+0.5*0.5;\n    col.g= pow(length(uv)*col.g,3.0)*-1.0+1.0;\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slsGRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 421]], "test": "valid"}
{"id": "slX3RX", "name": "Fork Psychedeli NikolaErce 707", "author": "NikolaErceg", "description": "A shader I originally wrote for a loading screen. Makes use of iq's voronoi shader.", "tags": ["mattdamon"], "likes": 5, "viewed": 209, "published": "Public API", "date": "1622495780", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec2 uv;\nvec2 pos;\n\nfloat hash1( float n ) { return fract(sin(n)*43758.5453); }\nvec2  hash2( vec2  p ) { p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) ); return fract(sin(p)*43758.5453); }\n\nvec2 rotate(vec2 p, float a) {\n    float cs = cos(a), sn = sin(a);\n    return (mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0) * vec3(p,1.0)).xy;\n}\n\n// ratio: 3 = neon, 4 = refracted, 5+ = approximate white\nvec3 physhue2rgb(float hue, float ratio) {\n    return smoothstep(\n        vec3(0.0),vec3(1.0),\n        abs(mod(hue + vec3(0.0,1.0,2.0)*(1.0/ratio),1.0)*2.0-1.0));\n}\n\nvec4 voronoi( in vec2 x, float c, out vec2 rp)\n{\n    vec2 n = floor( x );\n    vec2 f = fract( x );\n\n\tvec3 m = vec3( 8.0 );\n\tfloat m2 = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = vec2( float(i),float(j) );\n        vec2 o = hash2( n + g );\n\n\t\t// animate\n\t\tfloat cid = hash1( dot(n+g,vec2(7.0,113.0) ) );\n\t\tif (cid < 0.1)\n        \to = 0.5 + 0.5*abs(mod(c + o,2.0)-1.0);\n\n\t\tvec2 r = g - f + o;\n\n        // triangular\n\t\tvec2 d = vec2( max(abs(r.x)*0.866025+r.y*0.5,-r.y), \n\t\t\t\t        1.0 );\n\n\t\t\n        if( d.x<m.x )\n        {\n\t\t\tm2 = m.x;\n            m.x = d.x;\n            m.y = cid;\n\t\t\tm.z = d.y;\n\t\t\trp = n + g;\n        }\n\t\telse if( d.x<m2 )\n\t\t{\n\t\t\tm2 = d.x;\n\t\t}\n\n    }\n    return vec4( m, m2-m.x );\n}\n\nvec4 render_sheet(vec2 p, float fi, float a) {\n\t\n\tfloat z = exp(mix(log(32.0), log(0.5), a));\n\n\t//p.y = abs(p.y);\n\tp.y = -p.y;\n\tfloat tpos = abs(p.x); //max(abs(p.x)*0.866025-p.y*0.5,p.y);\n\tp.x = abs(p.x);\n\tp = rotate(p, radians(60.0));\n\tp.x = abs(p.x);\n\t\n\t//p = rotate(p, radians(-60.0));\n\t//p.x = abs(p.x);\n\t\n\tvec2 rp;\n\tfloat o = fi*128.0-step(fi,0.2)*a*2.0;\n\tvec4 c = voronoi( z*p+o, fi+a*8.0, rp);\n\trp -= o;\n\t\n\tfloat pp = 0.6 - (max(abs(rp.x)*0.866025+rp.y*0.5,-rp.y)/4.0); // + fract(fi+c.y);\n\tpp = clamp(pp, 0.0, 1.0);\n\t\n\tfloat fadein = clamp(a*2.0,0.0,1.0);\n\t\n\tfloat rep = 1.0-a-(pp-sin(c.w*40.0)*0.1)*fadein;//;\n\t\n\tfloat alpha = clamp((rep-c.w)*16.0, 0.0, 1.0);\n\tif (alpha > 0.0) {\t\n\t\tfloat hue = c.w*(1.0+c.y*8.0)\n\t\t\t+fi+a*9.0*c.y*mix(1.0,8.0,step(fi,0.1))\n\t\t\t-tpos*1.0;\n\t\t\n\t\tvec3 w = physhue2rgb(hue, 4.0);\n\t\tw.z = 0.5; //sin(iTime)*0.1+0.5;\n\t\treturn vec4(w, alpha);\n\t}\t\n\t\n\treturn vec4(0.0);\n}\n\nvec4 alpha(vec4 a, vec4 b) {\n\ta = mix(b, a, a.w);\n\ta.w = max(a.w, b.w);\n\treturn a;\n}\n\n#define STEPS 6\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 aspect = vec2(iResolution.x / iResolution.y, 1.0);    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 pos = (uv*2.0-1.0)*aspect;\n    \n\tvec4 col = vec4(0.0);\n\t\n\tfloat s = 1.0/float(STEPS);\n\t\n\tfloat t = iTime*0.5;\n\tfloat a = fract(t)*s;\n\tt -= fract(t);\n\t\n\tfor (int i = STEPS-1; i >= 0; --i) {\n\t\tfloat fi = float(i);\n\t\tcol = alpha(col, render_sheet(pos, hash1(t-fi), a+fi*s));\n\t\tif (col.w >= 1.0) break;\n\t}\n\t\n\tfloat blend = sin(iTime)*0.5+0.5;\n\tblend = 0.2; //smoothstep(0.0,1.0,blend);\n\t\n\tvec3 co = texture(iChannel0, -uv + col.xy*blend*0.1).rgb;\n\tcol.rgb = mix(co, col.rgb, blend);\n\t\n    fragColor = col;\n}", "image_inputs": [{"id": "4sX3Rn", "previewfilepath": "/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slX3RX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 45, 45, 80], [81, 81, 105, 105, 204], [206, 206, 236, 236, 377], [379, 437, 479, 479, 601], [603, 603, 651, 651, 1350], [1352, 1352, 1398, 1398, 2255], [2257, 2257, 2285, 2285, 2341], [2360, 2360, 2417, 2417, 3039]], "test": "error"}
{"id": "slXGz4", "name": "Basic Polar Coordinate 3D", "author": "kithy", "description": "basic mapping 2D texture to 3D sphere.", "tags": ["raymarching", "texture", "polarcoordinate"], "likes": 0, "viewed": 32, "published": "Public", "date": "1621606658", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ITR 64\n#define EPS 0.001\n\nmat2 rot(float a){\n\tfloat s=sin(a);\n\tfloat c=cos(a);\n\treturn mat2(c,-s,s,c);\n}\n\nfloat sdSphere(vec3 p){\n\treturn length(p)-0.8;\n}\n\nvec3 genNormal(vec3 p){\n\tvec3 normal=vec3(\n\t\tsdSphere(p+vec3(EPS,0.0,0.0))-sdSphere(p+vec3(-EPS,0.0,0.0)),\n\t\tsdSphere(p+vec3(0.0,EPS,0.0))-sdSphere(p+vec3(0.0,-EPS,0.0)),\n\t\tsdSphere(p+vec3(0.0,0.0,EPS))-sdSphere(p+vec3(0.0,0.0,-EPS))\n\t\t);\n\treturn normalize(normal);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n\tvec2 uv=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\n\tvec3 ro=vec3(0.0,0.0,-6.0);\n\tvec3 lookat=vec3(0.0,0.0,0.0);\n\tfloat zoom=5.0;\n\n\tvec3 f=normalize(lookat-ro);\n\tvec3 r=normalize(cross(vec3(0.0,1.0,0.0),f));\n\tvec3 u=cross(f,r);\n\tvec3 c=ro+f*zoom;\n\tvec3 i=c+uv.x*r+uv.y*u;\n\tvec3 rd=normalize(i-ro);\n\n\tfloat dS,dO;\n\tvec3 p,normal;\n\n\tfor(int i=0;i<ITR;i++){\n\t\t\n\t\tp=ro+rd*dO;\n\t\tdS=sdSphere(p);\n\t\tnormal=genNormal(p);\n\t\tif(dS<EPS)break;\n\t\tdO+=dS;\n\n\t}\n\t\n\tp.xz*=rot(iTime);\n\tvec3 col=vec3(0.0);\n\n\tif(dS<EPS){\n\t\tfloat x=atan(p.x,p.y);\n\t\tfloat y=length(p);\n\n\t\tcol=vec3(x,y,1.0);\n\t}\n\n\tfragColor=vec4((normal*0.5-0.5)+col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slXGz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 34, 52, 52, 112], [114, 114, 137, 137, 162], [164, 164, 187, 187, 431], [433, 433, 486, 486, 1112]], "test": "valid"}
{"id": "slXGzj", "name": "waving russian flag", "author": "4eckme", "description": "you can fork it to create waving flag of your country", "tags": ["flag", "russia"], "likes": 0, "viewed": 43, "published": "Public", "date": "1622409407", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord-iResolution.xy/2.0;\n    float x=uv.x;float y=uv.y; float t = iTime;\n    x=x+x*sin((degrees(atan(x,y))/20.0+t*2.0)/2.0)/3.1416/2.0;\n    y=y+y*cos((degrees(atan(y,x))/20.0+t*2.0)/2.0)/3.1416/2.0;\n    fragColor=vec4(0.8);\n    if(abs(x)<180.0&&abs(y)<120.0) {\n        if (y>40.0) fragColor=vec4(1);\n        else if (y<-40.0) fragColor=vec4(1,0,0,1);\n        else fragColor=vec4(0,0,1,1);\n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slXGzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 478]], "test": "valid"}
{"id": "ss2XDd", "name": "Outline 15/05/2021 JAM Session", "author": "lechuga", "description": ".", "tags": ["demoscene", "outline", "jam"], "likes": 2, "viewed": 105, "published": "Public", "date": "1621355968", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 e=vec2(0.01, .0);\nvec3 co,fo, n,ld=normalize(vec3(1, 1.,-4.)),al=vec3(.85);\nfloat t,d,dd;\n#define rot(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n#define a(d) clamp(m(p+n*d)/d, 0., 1.)\n#define s(d) smoothstep(0., 1., m(p+ld*d)/d)\n#define COL_P vec3(0., 0.34, 1.)\n#define pi acos(-1.)\nfloat mov;\nfloat h(float p){\n  return fract(sin((p)*344.)*803.5);\n}\nfloat h2(vec2 p){\n  return fract(sin(dot((p+t*10.)*345.,p.yx*456.))*567.);\n}\nfloat c(float t){\n  t*=.05;\n  return mix(h(floor(t)), h(floor(t+1.)), pow(smoothstep(0., 1., fract(t)), 20.));\n}\nfloat sb(vec3 p, vec3 s){\n  p=abs(p)-s;\n  return max(max(p.y,p.x), p.z);\n}\nfloat smin(float a, float b, float k){\n  float h=max(k-abs(a-b), 0.);\n  return min(a,b)-h*h*.25/k;\n}\nvec2 smin(vec2 a, vec2 b, vec2 k){\n  vec2 h=max(k-abs(a-b), 0.);\n  return min(a,b)-h*h*.25/k;\n}\nvec3 smin(vec3 a, vec3 b, vec3 k){\n  vec3 h=max(k-abs(a-b), 0.);\n  return min(a,b)-h*h*.25/k;\n}\nfloat tr(vec3 p, vec3 s){\n  p.y=abs(p.y)-.1;\n  p.zx=abs(p.zx)-s.xz;\n  vec2 a=vec2(.34);\n  return max(max(dot(p.xy,a),dot(p.xz,a)), dot(p.yz,a));\n}\nfloat id1;\nfloat g1,g2,g3,g4;\nfloat tt;\nfloat dia(vec3 p){\n  vec3 p1=p;\n  \n  p1.z+=mov;\n  \n  float re1=30.;\n  \n  \n  p1.yx=abs(p1.yx)-9.-sin(tt*.41);\n  p1.xy*=rot(pi/4.);\n  id1=h2(floor(p1.xz/re1-.5));\n  p1.xz=(fract(p1.xz/re1-.5)-.5)*re1;\n  \n  float cc=sb(p1,vec3(1., 15., 1.));\n  g1+=.01/(.1+cc*cc);\n  vec3 p2=p;\n  float re2=20.;\n  p2.xy+=sin(p2.z*.45+t*2.);\n  for(float i=0.;i<3.;i++)\n  p2=abs(p2)-3.-t,\n  p2.zy*=rot(pi*2.+t*.141),\n  p2.xy*=rot(pi*2.+t*.141),\n  //p2.xy=abs(p2.xy)-15.,\n  p2.xy=smin(p2.xy, 1.-p2.xy, vec2(1.));//exp\n  \n  p2-=1.;\n  p2=(fract(p2/re2-.5)-.5)*re2;\n  float cc1=sb(p2,vec3(1., 60.45, .23));\n  //cc=mix(cc1,cc,1.05);\n  g2+=.1/(.1+cc1*cc1);\n  cc=smin(cc1,cc, 1.);\n  \n  vec3 p3=p;\n  //p3.x=abs(p3.x)-3.;\n  p3.xy*=rot(tt*8.);\n  p3=abs(abs(p3)-1.)-13.;\n  float cc3=tr(p3, vec3(3.));\n  cc=min(cc3,cc);\n  g3=1./(1.+cc3);\n  return cc;\n}\n\nfloat g5;\nfloat m(vec3 p){\n  float d=dia(p);\n  vec3 p1=p;\n  p1.xy*=rot(tt);\n  vec2 s=vec2(1., 10.);\n  float ff=length(vec2(length(p1.xy)-s.y, p1.z))-s.x-sin(p.y*.451+tt)*sin(p.x*.5656+tt)*sin(p.z*.5656+tt)*.5-.5;\n  p1.yx-=2.;\n  p1.xy*=rot(tt);\n  float ff2=length(vec2(length(p1.xy)-s.y, p1.z))-s.x-sin(p.y);\n  ff=smin(ff2,ff, 1.);\n  d=smin(d, ff, 5.);\n  \n  float ss=sin((t*.5))*200.+250.;\n  float ccl=(length(p)-ss);\n  g4+=1./(1.+ccl*ccl);\n  ccl=smoothstep(0., 1., ccl);\n  \n  vec3 p4=p;\n  \n  p4=abs(p)-4.;\n  float at=mov*1.5;\n  p4.xy+=sin(at)*10.;\n  \n  p4.zx=abs(p4.zx)-.5;\n  p4.yz*=rot(at+p4.y*.1);\n  float momo=length(p4)-2.;\n  momo=min(momo, length(p-vec3(0., 1., 0.))-2.-sin(p.y+tt)*sin(p.x+tt)*sin(p.z+tt)*.5-.5);\n  d=smin(d, momo, 1.);\n  g5+=2./(.1+momo*momo);\n  return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \n t=mod(iTime*.5, 50.);\n tt=c(t*.25)*20.+t*.25;\n mov= t*30.;\n\tvec2 uv = fragCoord/iResolution.xy;\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n  float scene=mod(t*.25, 50.);\n  //\n  //if(mm < 0.1)\n  //  scene=50.;\n  \n  \n  float r1=scene*5.;\n  uv=(fract(uv.yx/r1-.5)-.5)*r1;\n  vec3 p=vec3(0.01, 0.01, -20.);\n  p.x=abs(p.x)-100.;\n  p.zx+=abs(sin(t*.45)*6.4)-2.;\n  p.xz*=rot(sin(t*.15)*pi*2.);\n  vec3 pp=vec3(0.01);\n  pp.xz*=rot(sin(t*.05)*pi*.5);\n  pp.xz*=rot(sin(t*.15)*pi*2.);\n  vec3 cz=normalize(pp-p);\n  vec3 cx=normalize(cross(cz, vec3(0.,-1., 0.)));\n  vec3 cy=normalize(cross(cz,cx));\n  vec3 r=mat3(cx,cy,cz)*normalize(vec3(-uv-h2(uv)*.001-h(uv.x)*.25*sin(t*.001)*.25, 1.-length(uv)*1.15+(sin(t*.5)*.33)));\n  r.xy*=rot(sin(t)*.5-.5);\n  co=fo=vec3(0.01);\n  float i;\n\tfor(i=0.;i < 50.;i++) if(d=m(p),dd+=d,p+=d*r,abs(d) < .001) {\n    if(d > 100.){co=vec3(0.1);break;}\n    n=normalize(\n    e.xyy * (m(p+e.xyy)) +\n    e.yyx * (m(p+e.yyx)) +\n    e.yxy * (m(p+e.yxy)) +\n    e.xxx * (m(p+e.xxx))\n    );\n    r=reflect(-r, n),p+=.001;\n    \n    float dif=max(dot(ld,n), 0.);\n    float sp=pow(max(dot(reflect(-ld,n), -r),0.),30.);\n    float fr=pow(1.+dif, 3.);\n    co=mix(sp*al+(a(.7))*(dif+s(.24)),fo, min(fr, .06) );\n  }\n    co+=g3*vec3(.0, 0.1, .5)*50.;\n    co+=g1*vec3(0.73-sin(t*.1)*.0001-.5, 0.,id1*id1)*.65;\n    co+=g2*vec3(0., sin(t*.7)*.0001-.5,.01)*.5;\n    co+=g4*vec3(1., 0.25*-sin(tt)*.5+.5, 0.)*.25;\n    co+=g5*vec3(1.,0.,0.)*.95;\n    \n  \n   \n    co=smoothstep(-0.123, 10., co);\n    co*=smoothstep(0., 1.,1.-length(uv)*1.05);\n    co*= 1.-max(length(dd)/300.,0.);\n\tfragColor = sqrt(vec4(co, 1.));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss2XDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[297, 297, 314, 314, 353], [354, 354, 371, 371, 430], [431, 431, 448, 448, 543], [544, 544, 569, 569, 618], [619, 619, 657, 657, 719], [720, 720, 754, 754, 815], [816, 816, 850, 850, 911], [912, 912, 937, 937, 1058], [1099, 1099, 1117, 1117, 1916], [1928, 1928, 1944, 1944, 2698], [2700, 2700, 2757, 2757, 4375]], "test": "valid"}
{"id": "ss2Xz3", "name": "Bonneval-sur-Arc", "author": "ocb", "description": "Raycast thru a grid with overlapping cell to create contiguous and interconnected set of chalets.\n\nMouse available\n\nChange SEED line 37 to create new village.\n\nMore infos in Image header.\n", "tags": ["grid", "raycasting", "fake", "city", "village", "overlapping"], "likes": 33, "viewed": 526, "published": "Public API", "date": "1620736162", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/***************************************************************************************/\n// Title: Bonneval-sur-Arc\n// author: ocb\n//\n// No copyright on code\n//\n// The purpose of this shader is to create structures using grid with overlapping cells. \n// Interconnections of randomly positionned objects create meta-structures, less\n// geometrical and then more natural or unexpected.\n//\n// I also tried myself with fake 3D. (windows, doors, inside lights).\n// Code is still little messy.\n// \n// Mouse is usable to explore village.\n// Push the mouse forward to go inside, explore narrow passages, hidden squares, secret corners.\n// The aiming point is always the village center.\n// No anti-collision functions. If you go thru the chalets, artifacts will appear.\n// It's a limited tool, as the objective is not a game.\n// Put back the mouse on left edge of the shader image to go back to auto-flight cam.\n//\n//\n// Change the SEED at the first line of the code (line 37) to create new village.\n//\n//\n// Thanks to:\n// iq for the Sphere4 raycasting primitive used for the snowy roof.\n// See iq's article and demo shader:\n// https://www.shadertoy.com/view/3tj3DW\n//\n// Dave_Hoskins for the very good hash functions:\n// https://www.shadertoy.com/view/4djSRW\n//\n/***************************************************************************************/\n\n/* If High Resolution screen */\n//#define HiRes\n\n/* set any SEED (float) to create new village */\n#define SEED 0.1\n\n/* smaller chalets or bigger chalets */\n//#define DEN >.8\n#define DEN <1.2\n\n// Max camera distance from center\n#define CamDist 12.\n\n// Max size of the grid - village\n#define MaxRad 11.\n\n// try to comment this if compilation troubles\n#define WITH_CHURCH\n\n#define PI 3.141592653589793\n#define PIdiv2 1.57079632679489\n#define TwoPI 6.283185307179586\n#define INFINI 1000000.\n//#define ti iTime\n//#define ti iMouse.x/iResolution.x*200.\n\n#define SKY 0\n#define GND 1\n#define BODY 2\n#define ROOF 3\n#define CEIL 4\n#define BALCON 5\n#define CHEM 6\n#define TORCH 7\n#define TOWER 8\n#define STEEP 9\n#define CHURCH 10\n#define NEF 11\n\n#define TOPSFC 2.5\n#define maxCell 30\n\n#define RVAL 1000.\n#define TOP 1000.\n  \n#define ZERO min(0,iFrame)\n \n/*******************************************************/\n/*                       Globals                       */\n/*******************************************************/\nint hitObj = SKY;\n\nvec3 boxCtr = vec3(INFINI);\nvec3 boxSze = vec3(0.);\nfloat boxH = 0.;\nmat2 boxRot = mat2(1,0,0,1);\nvec2 boxCell = vec2(0);\nfloat t = INFINI;\nvec3 n = vec3(0,1,0);\n/*******************************************************/\n/*                         Basic                       */\n/*******************************************************/\n//Dave_Hoskins's hash functions\n\nfloat H12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 H22(vec2 p)\n{\n    p += vec2(15.456,21.0985);\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvec3 H33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n\nvec3 dither(in vec3 p){\n    return vec3(H33(floor(5000.*p))-.5);\n}\n\n\n/*******************************************************/\n/*                 Raycast primitives                  */\n/*******************************************************/\n\nfloat gnd(float py, float ry, float h){\n    float t = (h-py)/ry;\n    if(t<0.) t = INFINI;\n    return t;\n}\n\n// IQ's box function modified\nvec4 iBox( in vec3 p, in vec3 ray, in vec3 box) \n{\n    // ray-box intersection in box space\n    vec3 sg = sign(ray);\n    vec3 t1 = -(p+sg*box)/ray;\n    vec3 t2 = -(p-sg*box)/ray;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF <= 0. || tN <= 0.) return vec4(INFINI);\n    \n    vec3 nor = -sign(ray)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    return vec4(nor,tN);\n}\n\n// IQ's iSphere4D function !!\n// modified to get the second solution and cut off the roof\nvec4 iSphere4( in vec3 ro, in vec3 rd, in float ra)\n{   \n    // -----------------------------\n    // solve quartic equation\n    // -----------------------------\n    float r2 = ra*ra;\n    \n    vec3 d2 = rd*rd; vec3 d3 = d2*rd;\n    vec3 o2 = ro*ro; vec3 o3 = o2*ro;\n\n    float ka = 1.0/dot(d2,d2);\n\n    float k3 = ka* dot(ro,d3);\n    float k2 = ka* dot(o2,d2);\n    float k1 = ka* dot(o3,rd);\n    float k0 = ka*(dot(o2,o2) - r2*r2);\n\n    // -----------------------------\n    // solve cubic\n    // -----------------------------\n\n    float c2 = k2 - k3*k3;\n    float c1 = k1 + 2.0*k3*k3*k3 - 3.0*k3*k2;\n    float c0 = k0 - 3.0*k3*k3*k3*k3 + 6.0*k3*k3*k2 - 4.0*k3*k1;\n\n    float p = c2*c2 + c0/3.0;\n    float q = c2*c2*c2 - c2*c0 + c1*c1;\n    \n    float h = q*q - p*p*p;\n\n    // -----------------------------\n    // skip the case of three real solutions for the cubic, which involves four\n    // complex solutions for the quartic, since we know this objcet is convex\n    // -----------------------------\n    if( h<0.0 ) return vec4(INFINI);\n    \n    // one real solution, two complex (conjugated)\n    float sh = sqrt(h);\n\n    float s = sign(q+sh)*pow(abs(q+sh),1.0/3.0); // cuberoot\n    float t = sign(q-sh)*pow(abs(q-sh),1.0/3.0); // cuberoot\n    vec2  w = vec2( s+t,s-t );\n\n    // -----------------------------\n    // the quartic will have two real solutions and two complex solutions.\n    // we only want the real ones\n    // -----------------------------\n\n    vec2  v = vec2( w.x+c2*4.0, w.y*1.73205081 )*0.5;   // sqrt(3.0)\n    float r = length(v);\n    float a = abs(v.y)/sqrt(r+v.x);\n    float b = c1/r + k3;\n    float t1 = -a-b;\n    if(t1 <= 0.) return vec4(INFINI);\n    \n    // ocb modified part to shape the roof\n    float t2 = a-b;\n    \n    vec3 pos = ro + t1*rd;\n    vec3 norm = normalize(pos*pos*pos);\n\n    float sn = .6*ra; // snow thickness\n    if(pos.y<sn && pos.z<sn){\n        pos = ro + t2*rd;\n        if(pos.y<sn && pos.z<sn) return vec4(INFINI);\n        \n        vec2 tt = vec2((sn-ro.y)/rd.y, (sn-ro.z)/rd.z); \n        if(pos.y<sn) t1 =  tt.y;\n        else if(pos.z<sn) t1 = tt.x;\n        else t1=min(tt.x, tt.y);\n        \n        if(t1 == tt.y) norm = vec3(0,0,-1);\n        else norm = vec3(0,-1,0);\n    }\n    return vec4(norm,t1);\n}\n\nvec2 cylinder(in vec2 pos, in vec2 ray, in vec2 O, in float R){\n    float t1 = INFINI, t2 = INFINI;\n    vec2 op = pos - O;\n\n    float a = dot(ray,ray);\n    float b = dot(op, ray);\n    float c = dot(op,op) - R*R;\n    float d = b*b - a*c;\n    \n    if (d >= 0.){\n        float Vd = sqrt(d);\n        t1 = (-b - Vd)/a;\n        t2 = (-b + Vd)/a;\n    }\n    \n\treturn vec2(t1,t2);\n}\n\nvec2 sphere(in vec3 p, in vec3 ray, in vec3 O, in float r){\n    vec2 t = vec2(INFINI);\n    vec3 d = O - p;\n    float b = dot(d, ray);\n    \n    float c = dot(d,d) - r*r;\n    float D = b*b - c;\n    if (D >= 0.){\n        float VD = sqrt(D);\n        t = vec2(b-VD, b+VD);\n        if(t.x<=0.) t.x = INFINI;\n        if(t.y<=0.) t.y = INFINI;\n    }\n    return t;\n}\n\n\nvec4 curvgnd(in vec3 pos, in vec3 ray, in float f){\n\n    float t = sphere(pos, ray, vec3(0.,RVAL,0.), RVAL).y;\n    vec3 p = pos + t*ray;\n    vec3 n = normalize(vec3(-p.x,RVAL-p.y,-p.z));\n    vec2 a = vec2(abs(atan(p.x,p.z)));\n    float h = .1\n                +.1*texture(iChannel0,.04*a).x\n                +.3*texture(iChannel0,.02*a).x\n                +.6*texture(iChannel0,.005*a).x;\n    if(p.y > TOP*h) t = INFINI;\n    return vec4(n,t);\n}\n\n\nvec4 bellTower(in vec3 p, in vec3 ray,  in vec3 box)\n{\n    vec3 sg = sign(ray);\n    vec3 t1 = -(p+sg*box)/ray;\n    vec3 t2 = -(p-sg*box)/ray;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF <= 0. || tN <= 0.) return vec4(INFINI);\n    \n    vec3 nor;\n    p += tN*ray;\n    if(p.y+min(1.2,3.*(abs(fract(p.z)-.5)+abs(fract(p.x)-.5))) <= box.y){\n        nor = -sign(ray)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n        return vec4(nor,tN);\n    }\n    \n    p += (tF-tN)*ray;\n    if(p.y+min(1.2,3.*(abs(fract(p.z)-.5)+abs(fract(p.x)-.5))) <= box.y){\n        nor = -sign(ray)*step(t2.xyz,t2.yzx)*step(t2.xyz,t2.zxy);\n        return vec4(nor,tF);\n    }    \n    return vec4(INFINI);\n}\n\n\nvec4 steeple(in vec3 p, in vec3 ray, in vec3 size)\n{\n    vec3 np = vec3(.986393923832144,.164398987305357,.0);        // normalize(vec3(6,1.,0));\n    vec3 n = np;\n    float t = INFINI, t2 = INFINI;\n    vec2 pp;\n    \n    float f = dot(ray,np);\n    if(f<=0.){\n        t = -(dot(p,np)-.6575)/f;    // 4./3. x 0.4931 = cos(atan(n.y,n.x))\n        pp = p.zy+t*ray.zy;\n        if(pp.y+6.*abs(pp.x)>= 4. || pp.y <2.) t = INFINI;\n    }\n\n    np.x = -np.x;\n    f = dot(ray,np);\n    if(f<=0.){\n        t2 =-(dot(p,np)-.6575)/f;\n        pp = p.zy+t2*ray.zy;\n        if(pp.y+6.*abs(pp.x)>= 4. || pp.y <2.) t2 = INFINI;\n    }\n    if(t2<t){\n        t=t2;\n        n = np;\n    }\n    \n    np = np.zyx;\n    f = dot(ray,np);\n    if(f<=0.){\n        t2 = -(dot(p,np)-.6575)/f;\n        pp = p.xy+t2*ray.xy;\n        if(pp.y+6.*abs(pp.x)>= 4. || pp.y <2.) t2 = INFINI;\n    }\n    if(t2<t){\n        t=t2;\n        n = np;\n    }\n\n    np.z = -np.z;\n    f = dot(ray,np);\n    if(f<=0.){\n        t2 = -(dot(p,np)-.6575)/f;\n        pp = p.xy+t2*ray.xy;\n        if(pp.y+6.*abs(pp.x)>= 4. || pp.y <2.) t2 = INFINI;\n    }\n    if(t2<t){\n        t=t2;\n        n = np;\n    }\n\n    if(t<=0.) t = INFINI;\n    return vec4(n,t);\n}\n\n/*******************************************************/\n/*                     Grid process                    */\n/*******************************************************/\n\n// finding next cell on the grid\nvec2 getNextCell(in vec2 p, in vec2 v, in vec2 cell){\n    vec2 d = sign(v);\n\tvec2 dt = (cell+d*.5-p)/v;\n    d *= vec2( step(dt.x-0.02,dt.y) , step(dt.y-0.02,dt.x) );\t\t// -0.02 to avoid cell change for epsilon inside\n    return cell+d;\n}\n\n// cell information (center and size of the chalet, if there is.)\nvec2 getBox(in vec2 cell)\n{\n\n#ifdef WITH_CHURCH\n    if(abs(cell.x) <= 1. && abs(cell.y)<=1.) return vec2(-1.);   // Empty spaces for the church\n#endif\n    if(length(cell)>= MaxRad-1.5) return vec2(-1.);\n    vec2 h = H22(cell+SEED);\n    if(h.x+h.y DEN) return vec2(-1.);\n\n    return h;\n}\n\n// raycasting one cell\nvoid checkCell(in vec3 pos, in vec3 ray, in vec2 cell)\n{\n    vec2 h = getBox(cell);\n    if(h.x < -0.1) return;\n    \n    h-=.5;\n    vec3 ctr = vec3(cell.x+h.x,RVAL-sqrt(RVAL*RVAL-cell.x*cell.x-cell.y*cell.y),cell.y+h.y);\n    h = abs(h);\n    float r = (1.5-max(h.x,h.y))*.61;\n    vec3 sze = vec3(r, 1.8*(h.x+h.y)+.4, r );    \n    float ang =  h.x*PI;\n    \n    // convert from ray to box space\n    float c = cos(ang), s = sin(ang);\n    mat2 rotY = mat2(c,-s,s,c);\n    mat2 derotY = mat2(c,s,-s,c);\n    \n    // roof 45 deg\n    // 0.7071 = sin or cos PI/4\n    mat3 rot45 = mat3(1,0,0,  0,.7071,-.7071,  0,.7071,.7071);\n    mat3 derot45 = mat3(1,0,0,  0,.7071,.7071,  0,-.7071,.7071);\n\n\n\tray.xz *= rotY;\n    pos -= ctr;\n\tpos.xz *= rotY;\n    \n    // Main body\n    vec4 res = iBox( pos, ray, sze);\n    vec3 p = pos + res.w*ray;\n    if(res.w<t && p.y+abs(p.z) <= sze.y){\n        t = res.w;\n        n = res.xyz;\n        n.xz*=derotY;\n        hitObj = BODY;\n        boxCtr = ctr;\n        boxSze = sze;\n        boxH = h.x;\n        boxRot = rotY;\n    }    \n    \n    // Chimney\n    pos.z -= .4;\n    res = iBox( pos, ray, vec3(.1,sze.y+.2,.1) );\n    if(res.w<t){\n        t = res.w;\n        n = res.xyz;\n        n.xz*=derotY;\n        hitObj = CHEM;\n        boxCtr = ctr;\n        boxSze = sze;\n        boxH = h.x;\n        boxRot = rotY;\n    }\n    pos.z += .4;\n    \n    // Torch\n    float sx = sze.x+.01;\n    sx *= sign(mod(cell.x,2.)-.5)*sign(mod(cell.y,2.)-.5);\n    pos -= vec3(sx, .35, sx);\n    res = iBox( pos, ray, vec3(.01,.03,.01) );\n    if(res.w<t){\n        t = res.w;\n        n = res.xyz;\n        n.xz*=derotY;\n        hitObj = TORCH;\n        boxCtr = ctr;\n        boxSze = sze;\n        boxH = h.x;\n        boxRot = rotY;\n        boxCell = cell;\n    }\n    pos += vec3(sx, .35, sx);\n\n    // Balcony\n    if(sze.y>1.6){\n        pos.y -= .7;\n        res = iBox( pos, ray, vec3(1.2*sze.x, .1,.7*sze.x) );\n        vec3 pb = pos + res.w*ray;\n        if(res.w<t && res.y!=1. && ( abs(fract(15./sze.x*(pb.z+pb.x))-.5)>.25 || abs(pb.y)>.07) && pb.y<.09+.01*cos(20.*(pb.z+3.*pb.x))){\n            t = res.w;\n            n = res.xyz;\n            n.xz*=derotY;\n            hitObj = BALCON;\n            boxCtr = ctr;\n            boxSze = sze;\n            boxH = h.x;\n            boxRot = rotY;\n        }\n        pos.y += .7;\n    }\n        \n    // Chimney snow cap\n    vec3 O = vec3(0.,sze.y+.2,.4);\n    float u = sphere(pos, ray, O, .13).x;\n    if(u<t){\n        t = u;\n        n = normalize(pos+u*ray - O);\n        n.xz*=derotY;\n        hitObj = ROOF;\n        boxCtr = ctr;\n        boxSze = sze;\n        boxH = h.x;\n        boxRot = rotY;\n    }    \n    \n    \n    pos.y -= sze.y-1.1*sze.x;\n    \n    ray *= rot45;\n    pos *= rot45;\n\n    // Snowy roof\n    res = iSphere4(pos, ray, 1.3*sze.x);\n    if(res.w<t){\n        t = res.w;\n        n = res.xyz*derot45;\n        n.xz*=derotY;\n        if(res.y+res.z == -1.) hitObj = CEIL;\n        else hitObj = ROOF;\n        boxCtr = ctr;\n        boxSze = sze;\n        boxH = h.x;\n        boxRot = rotY;\n    }\n\n    return;\n}\n\n/*******************************************************/\n/*                Main process thru grid               */\n/*******************************************************/\n\nvoid runGrid(in vec3 pos, in vec3 ray){\n\n    vec2 cell, outCell;\n    \n    // first step getting boundary of interesting areas    \n    // Entry and exit point of the voxel run(te and tx)\n    vec3 pe = pos;\n    float te = INFINI, tx = 0.;\n\n    vec2 tc = cylinder(pos.xz, ray.xz, vec2(0.), MaxRad);\n    float th = gnd(pos.y,ray.y,TOPSFC);\n    vec4 res = curvgnd(pos, ray, 1.);\n    float tg = res.w;\n    n = res.xyz;\n\n    if(pos.y>=TOPSFC){\n        te = min(max(tc.x,th),tc.y);\n        tx = min(tg,tc.y);\n    }\n    else{\n        te = tc.x*step(0.,tc.x)+INFINI*step(th,tc.x);\n        tx = min(min(tg,tc.y),th);\n    }\n    \n    \n    // MAIN PROCESS\n    // going thru the grid checking for existing object in each cell\n   \n    t = tg;\n    if(t<INFINI) hitObj = GND;\n    \n    cell = floor(pos.xz+te*ray.xz + .5);\n    outCell = getNextCell(pos.xz, ray.xz, floor(pos.xz+tx*ray.xz + .5));\n\n    int endCheck = 0;\n    const vec3 e = vec3(1,0,-1);\n     \n    for(int i=ZERO; i<maxCell;i++){\n        \n        if(cell == outCell) break;\n                \n        checkCell(pos, ray, cell);\n        checkCell(pos, ray, cell+e.xy);    // 3x3 overlaping\n        checkCell(pos, ray, cell+e.zy);\n        checkCell(pos, ray, cell+e.yx);\n        checkCell(pos, ray, cell+e.yz);\n        \n        checkCell(pos, ray, cell+e.xx);\n        checkCell(pos, ray, cell+e.zz);\n        checkCell(pos, ray, cell+e.xz);\n        checkCell(pos, ray, cell+e.zx);\n        \n        \n        if(endCheck==2) break;\n        \n        if(hitObj >= 2) endCheck += 1;\n        \n        cell = getNextCell(pos.xz,ray.xz,cell);\n    } \n\n\n    return;\n}\n\n/*******************************************************/\n/*                  raycasting Church                  */\n/*******************************************************/\n\n// checking if ray goes in center cell (dim = 1.36 x 1.36)\nbool inChurchBound(in vec2 p, in vec2 r)\n{\n    vec2 s = sign(r);\n    vec2 t1 = -(p+s*1.36)/r;\n    vec2 t2 = -(p-s*1.36)/r;\n\n\tfloat tN = max( t1.x, t1.y );\n\tfloat tF = min( t2.x, t2.y );\n\t\n\tif( tN > tF || tF <= 0.) return false;\n    else return true;\n}\n\n// raycasting whole church\nvoid checkChurch(in vec3 pos, in vec3 ray)\n{\n    vec3 sze = vec3(.9,1.8,.9);\n    vec4 res = iBox( pos, ray, sze);\n    vec3 p = pos + res.w*ray;\n    if(res.w<t && p.y+abs(p.z) <= sze.y){\n        t = res.w;\n        n = res.xyz;\n        hitObj = CHURCH;\n    }\n    \n    res.w = cylinder(pos.xz, ray.xz, vec2(.5,0.), .8).x;\n    p = pos + res.w*ray;\n    if(res.w<t && p.y+abs(.3*p.x) <= .8){\n        t = res.w;\n        n = vec3(p.x-.6,0,p.z);\n        hitObj = NEF;\n    }\n    \n    res.w = sphere(pos, ray, vec3(.5,.25,0), .85).x;\n    p = pos + res.w*ray;\n    if(res.w<t && p.y+abs(.3*p.x) > .75){\n        t = res.w;\n        n = normalize(p - vec3(.5,.3,0));\n        hitObj = ROOF;\n    }\n    \n    pos.xz -= vec2(.4,1.);\n    res = bellTower(pos,ray,vec3(.35,3.5,.35));\n    if(res.w<t){\n        t = res.w;\n        n = res.xyz;\n        hitObj = TOWER;\n    }       \n   \n    res = steeple( pos, ray, vec3(.5,3.,.5));\n    if(res.w<t){\n        t = res.w;\n        n = res.xyz;\n        hitObj = STEEP;\n    }\n    pos.xz += vec2(.4,1.);\n    \n    // roof\n    pos.y -= sze.y-1.1*sze.x;\n    ray *= mat3(1,0,0,  0,.7071,-.7071,  0,.7071,.7071);\n    pos *= mat3(1,0,0,  0,.7071,-.7071,  0,.7071,.7071);\n\n    res = iSphere4(pos, ray, 1.15*sze.x);\n    if(res.w<t){\n        t = res.w;\n        n = res.xyz*mat3(1,0,0,  0,.7071,.7071,  0,-.7071,.7071);\n        if(res.y+res.z == -1.) hitObj = CEIL;\n        else hitObj = ROOF;\n    }\n\n    return;\n}\n\n/*******************************************************/\n/*                 Textures and colors                 */\n/*******************************************************/\nvec3 sky(in float x, in float y)\n{\n    x = .5*x+.5;          \n    return vec3(2.-3.*y, 1.2-1.4*y, .8-.6*y)*x*x+vec3(.0,.05,.1);\n}\n\nfloat snowGlitt(in vec3 p,in vec3 ray)\n{\n    #ifdef HiRes\n    return .6*min(1., step(.9995, H33(floor(2000.*p)+floor(5.*ray)).x ));\n    #else\n    return 0.;\n    #endif\n}\n\n\nvec3 stonewall(in vec2 uv)\n{\n    uv *= vec2(20.,20.);\n\n    vec2 i = floor(uv);\n    uv += vec2(.5,.3)*H22(i);\n    vec2 f = abs(fract(uv)-.5);\n    \n    float h = H12(floor(uv));\n    float tex = texture(iChannel0,.3*(uv+h)).x;\n    vec3 col = .1+ .3*vec3(h);\n    col += .6*tex;\n    col -= .3*(smoothstep(.45+.1*tex,.5,f.x)+smoothstep(.35+.1*tex,.45,f.y));\n\n    return max(vec3(0.),col);\n}\n\nvec3 woodwall(in vec2 p)\n{\n    vec3 col = vec3(.3,.225,.15);\n    col *= 1.-texture(iChannel0,.05*p.yx).x;\n    p*=15.;\n    col -= .4*smoothstep(.34+.2*texture(iChannel0,.01*p.xy).x,.5,abs(fract(p.x)-.5)) ;\n    col *= 1.-.5*H12(floor(p.xx));\n\n    return col;\n}\n\n/************************************************/\n/*               Doors and windows              */\n/************************************************/\n\n/******************** door *******************/\nfloat doorMask(in vec3 p, in vec3 ray, in float pzctr)\n{\n    float apz = abs(pzctr);\n    float m = 1.\n              - smoothstep(.143,.135,apz)*step(p.y,.44)\n              - smoothstep(.205,.20,apz)*smoothstep(.027,.020,abs(p.y-.425));\n    m = max(m,0.);\n    return m;\n}\n\nvec3 door2D(in vec3 p, in vec3 ray, in float pzctr)\n{\n    vec3 tex = vec3(.3,.225,.15)*(.1+texture(iChannel0,3.*p.yz).x);\n    float apz = abs(pzctr);\n    \n    // wood framing\n    vec3 col = tex*smoothstep(.023,.015,abs(p.y-.425))*smoothstep(.2,.19,apz);\n    col += tex*smoothstep(.02,.01,abs(apz-.12))*smoothstep(.40,.398,p.y);\n\n    // door with fake 3D shadows\n    float cy = sign(n.x)*(ray.x*n.z-ray.z*n.x); // cross(ray,n)  \n    float top = step(p.y,.37*(1.-clamp(ray.y,-.08,0.)));\n    if(pzctr < min(.1+.05*cy,.1) && pzctr > max(-.1+.05*cy,-.1)) col += top*woodwall(3.*p.zy);\n    \n    return col;\n}\n\n/******************** window *******************/\n\nfloat winMask(in vec3 apw, in vec3 ray)\n{\n    return 1.-smoothstep(.25,.23,apw.z)*smoothstep(.08,.07,apw.y);\n}\n\nfloat lightWinMask(in vec3 apw)\n{\n    return smoothstep(.18,.16,apw.z)*smoothstep(.055,.05,apw.y);\n}\n\nvec3 window2D(in vec3 pw, in vec3 ray, in float lm, in float h)\n{\n    vec3 tex = vec3(.3,.225,.15)*(.1+texture(iChannel0,pw.zy).x);\n    vec3 col = tex*smoothstep(.24,.22,abs(pw.z))*smoothstep(.075,.07,abs(pw.y));\n;\n    \n    // background light with fake3D light source  \n    vec3 litcol = vec3(.05+.02*h,.03-.01*h,.0)*(2.+.5/(length(vec2(pw.z+.2*(ray.x+ray.z),pw.y+.04+.1*ray.y))+.01));\n    col += 1.5*lm*litcol;\n    \n    // framing with fake 3D shade\n    float cy = sign(n.x)*(ray.x*n.z-ray.z*n.x); // cross(ray,n)  \n    vec2 ctr = vec2(.1*sign(pw.z)*cy ,-.05*sign(pw.y)*ray.y );\n    float mask = lm*smoothstep(.18,.16,abs(pw.z)-ctr.x)*smoothstep(.055,.05,abs(pw.y)-ctr.y);\n    col *= 1.-mask;\n    col += mask*litcol;\n    \n    return col;\n}\n\n/**************** balcony window door ***************/\nvec3 windoorFrame(in vec3 p)\n{\n    vec3 tex = vec3(.3,.225,.15)*(.1+texture(iChannel0,3.*p.yz).x);\n    return tex*smoothstep(.095,.085,abs(p.z))*smoothstep(.19,.17,abs(p.y));\n}\n\n\nfloat wdMask(in vec3 apw)\n{\n    return 1.-smoothstep(.1,.09,apw.z)*smoothstep(.2,.18,apw.y);\n}\n\nfloat lightWDMask(in vec3 apw)\n{\n    return smoothstep(.038,.033,abs(apw.z-.045))*smoothstep(.16,.15,apw.y);\n}\n\nvec3 windoor2D(in vec3 p, in vec3 ray, in float lm, in float h)\n{\n    vec3 col = windoorFrame(p)*(1.-lm); \n    col += lm*vec3(.04,.025-.01*h,.01)*(2.+1./(length(vec2(p.z+.2*(ray.x+ray.z),p.y+.05+.1*ray.y))+.02));\n\n    return col;\n}\n\n/******************** Church windows ********************/\n\n// fake 3D //\nvec2 fake3D(in vec3 ray, in vec2 po)\n{\n    vec3 cr = cross(ray,n);\n    vec2 c = vec2(n.x*cr.z-n.z*cr.x, cr.y);   // face selection\n    return vec2(.1*c.y*sign(po.x)*sign(-n.x+n.z),.1*c.x*sign(po.y));\n}\n\nfloat bellWindow(in vec2 ap, in vec2 poa)\n{\n    float wm = smoothstep(.12,.1,ap.x)*smoothstep(.16,.14,ap.y);\n    wm += smoothstep(.12,.1,length(poa));\n    return min(1.,wm);\n}\n\nfloat churchWindow(in vec2 ap, in vec2 poa)\n{\n    float wm = smoothstep(.07,.06,ap.x)*smoothstep(.05,.04,ap.y);\n    wm += smoothstep(.07,.06,length(poa));\n    return min(1.,wm);\n}\n\n\n\n/*******************************************************/\n/*                       Shadows                       */\n/*******************************************************/\n\n/********************* Fake 3D shadow ******************/\nfloat calcShad(in vec2 cell, in vec2 p, in vec2 lit)\n{    \n    vec2 h= getBox(cell);\n    if(h.x < -0.1 && cell != vec2(0)) return 0.;\n        \n    h-=.5;\n    vec3 ctr = vec3(cell.x+h.x,RVAL-sqrt(RVAL*RVAL-cell.x*cell.x-cell.y*cell.y),cell.y+h.y);\n    h = abs(h);\n    float r = (1.5-max(h.x,h.y))*.61;\n    vec3 sze = vec3(r, 1.8*(h.x+h.y)+.4, r );    \n    float ang =  h.x*PI;\n    \n    float co = cos(ang), si = sin(ang);\n    p -= ctr.xz;\n\n    float da = abs(ang-atan(lit.x,lit.y));\n    float sd = sign(dot(lit,vec2(co,-si)));\n    float sina = sin(da);\n    \n    vec2 ps = p * mat2(lit.x,lit.y,-lit.y,lit.x);\n    p *= mat2(co,-si,si,co);\n    \n    float sh = .5*step(sd*p.x,sze.x)*step(p.y,sze.x)*(1.-step(-sze.x+.01,sd*p.x)*step(-sze.x+.01,p.y))*smoothstep(3.,0.,abs(ps.x))*smoothstep(0.15, -.02*abs(ps.x-sze.x), abs(ps.y)-(1.+.414*sina)*sze.x);\n    \n    lit *= mat2(co,-si,si,co);\n    vec2 s =sign(lit);\n\n    float occ = .5*smoothstep(sze.x+.3,sze.x-.1,abs(p.x)) * smoothstep(sze.x+.3,sze.x-.1,abs(p.y));\n    \n    return sh+occ;\n}\n\n\nfloat fakeShade(in vec2 p, in vec2 lit)\n{\n    vec2 cell = floor(p+.5);\n    float shad = 0.;\n    \n    for(float e=-1.; e<=3.; e++){\n        for(float f=-1.; f<=2.; f++){\n            shad = max(shad,calcShad(cell+vec2(e,f), p, lit));\n        }\n    }\n  \n    return 1.-shad;\n}\n/********************* End of fake 3D shadow ******************/\n\n\n\n/************************* 3D shadow **************************/\n\n/*********** simplified checkCell raycast ************/\nfloat shadCheckCell(in vec3 pos, in vec3 ray, in vec2 cell)\n{\n    float t = INFINI;\n    vec2 h = getBox(cell);\n    if(h.x < -.1) return INFINI;\n    \n    h-=.5;\n    vec3 ctr = vec3(cell.x+h.x,RVAL-sqrt(RVAL*RVAL-cell.x*cell.x-cell.y*cell.y),cell.y+h.y);\n    h = abs(h);\n    float r = (1.5-max(h.x,h.y))*.61;\n    vec3 sze = vec3(r, 1.8*(h.x+h.y)+.4, r );    \n    float ang =  h.x*PI;\n    \n    // convert from ray to box space\n    float c = cos(ang), s = sin(ang);\n    mat2 rotY = mat2(c,-s,s,c);\n    \n    // roof 45 deg\n    mat3 rot45 = mat3(1,0,0,  0,.7071,-.7071,  0,.7071,.7071);\n\n\tray.xz *= rotY;\n    pos -= ctr;\n\tpos.xz *= rotY;\n    \n    // Main body\n    vec4 res = iBox( pos, ray, sze);\n    vec3 p = pos + res.w*ray;\n    if(p.y+abs(p.z) <= sze.y) t = min(t,res.w);\n\n    // Chimney\n    pos.z -= .4;\n    res = iBox( pos, ray, vec3(.1,sze.y+.2,.1) );\n    t = min(t,res.w);\n    pos.z += .4;\n        \n    // Chimney snow cap\n    vec3 O = vec3(0.,sze.y+.2,.4);\n    t = min(t, sphere(pos, ray, O, .13).x);\n\n    \n    pos.y -= sze.y-1.1*sze.x;\n    \n    ray *= rot45;\n    pos *= rot45;\n\n    // Snowy roof\n    res = iSphere4(pos, ray, 1.3*sze.x);\n    t = min(t, res.w);\n\n    return t;\n}\n\n\n/****************** shadows on ground ******************/\nfloat gndShad(in vec3 p, in vec3 lit){\n    vec2 cell = floor(p.xz+.5);\n    p.y+=.001;             // be sure p is above ground surface to avoid ground interception\n    p.xz -= .015*lit.xz;   // to remove some artifacts due to rotation accuracy issue with building\n    float tsh = INFINI;\n    lit -= .1*dither(p);//+.05*n+.1*lit;\n    for(float e=-0.; e<=4.; e++){            // due to fix ambiant light direction\n        for(float f=-1.; f<=2.; f++){        // only checking limited grid area\n            tsh = min(tsh, shadCheckCell(p, lit, cell+vec2(e,f)));\n        }\n    }    \n    return min(.3*tsh+.4,1.);\n}\n\n/********* local shade, for ambiant occlusion *******/\nfloat locShad(in vec3 p, in vec3 lit){\n    vec2 cell = floor(p.xz+.5);\n    float tsh = INFINI;\n    for(float e=-1.; e<=2.; e++){\n        for(float f=-1.; f<=2.; f++){ \n            tsh = min(tsh, shadCheckCell(p, lit, cell+vec2(e,f)));\n        }\n    }    \n\nreturn min(2.*tsh,1.);\n}\n\n/*********************************************************/\n/*                       Lighting                        */\n/*********************************************************/\n\nfloat torch( in vec2 cell, in vec3 p)\n{\n    vec2 h= getBox(cell);\n    if(h.x < 0.) return INFINI;\n    \n    h-=.5;\n    vec3 ctr = vec3(cell.x+h.x,RVAL-sqrt(RVAL*RVAL-cell.x*cell.x-cell.y*cell.y),cell.y+h.y);\n    h = abs(h);\n    float r = (1.5-max(h.x,h.y))*.61;\n    vec3 sze = vec3(r, 1.8*(h.x+h.y)+.4, r );    \n    float ang =  h.x*PI;\n\n    float sx = sze.x+.01;\n    sx *= sign(mod(cell.x,2.)-.5)*sign(mod(cell.y,2.)-.5);  // to change corner side every other one\n\n    vec3 torPos = vec3(sx, .35, sx);\n\n    float c = cos(ang), s = sin(ang);\n    torPos.xz *= mat2(c,s,-s,c);\n    torPos.xz += ctr.xz;\n\n    vec3 u = torPos-p;\n    \n    float l = INFINI;\n    \n    float dt = dot(normalize(u),n);\n    l = length(u)/smoothstep(-.2,0.2,dt);\n\n    return l;\n}\n\nvec3 torchLight(in vec3 p)\n{\n    vec2 cell = floor(p.xz+.5);\n    float d = INFINI;\n    //p -= .1*dither(p)+.05*n;\n    for(float e=-3.; e<=3.; e++){\n        for(float f=-3.; f<=3.; f++){\n            d = min(d,torch(cell+vec2(e,f), p));\n        }\n    }\n    return vec3(.5,.3,.1)*max(0.,(1./(d*d+.1)-.1));\n}\n\n/******************************************************************/\n/*                        CAM functions                          */\n/******************************************************************/\n \nvec3 getCamPos(out vec3 camTarget)\n{\n    vec3 p;\n    /*if(iTime < 30.){\n        float r = 15.;//+3.*cos(.1*iTime);\n        float a = -.075*iTime-2.5;\n        p = vec3(r*cos(a),.25,r*sin(a));\n        camTarget = .5*p;    \n    }\n    else if(iTime < 52.){\n        float ti = iTime-30.;\n        camTarget.y = 1.;\n        p.y = .25;\n        float tiA = .7*ti;\n        float tiB = .4*ti;\n        float tr = smoothstep(15.,20.,ti);\n        tiA = -.1*tiA+2.8;\n        tiB -= 17.;\n        p.xz = mix(11.*vec2(cos(tiA), sin(tiA)), vec2(.15*tiB+1.4, -tiB), tr);\n        camTarget.xz = mix(vec2(.35,7.), vec2(0), tr);\n    }\n    else if(iTime<94.){\n        p.y = .25;\n        float tiA = .4*(iTime-30.);\n        float tiB = .05*(iTime-30.)+6.3;\n        tiA -= 17.+smoothstep(58.,64.,iTime);\n        float tr = smoothstep(59.,63.,iTime);\n        float s = smoothstep(65.,72.,iTime);\n        float sf = smoothstep(82.,90.,iTime);\n        float r = 5.-1.8*s-1.*sf;\n        p.xz = mix(vec2(.15*tiA+1.4, -tiA), r*vec2(cos(tiB),sin(tiB)), tr);\n        camTarget = vec3(-3.*s+4.*sf, 1.+.6*sf, -3.*s+4.*sf);\n    }\n    else if(iTime<120.){\n        float ti = iTime-94.;\n        float s = smoothstep(12.,27.,ti);\n        float rot = smoothstep(16.,27.,ti);\n        float ey = smoothstep(13.,18.,ti);\n        ti= .3*ti-8.;\n        camTarget = (1.-s)*vec3(-ti,.25+ey*.7,-1.73*ti-6.1+.13*sin(ti+1.))+vec3(0,s*1.5,0);\n        ti -= .1;\n        p = mix(vec3(-ti,.23+s*2.3,-1.73*ti-6.1), vec3(4.*cos(-.5*ti-2.5),2.3,4.*sin(-.5*ti-2.5)), rot);\n    }\n    else{\n        float ti = iTime-94.;\n        ti= -.15*ti+1.55;\n        float tr = smoothstep(121.,140.,iTime);\n        float r = 10.+5.*sin(.4*ti);\n        p = vec3(r*cos(.7*ti),2.5,r*sin(.7*ti));\n        p = mix(vec3(4.*cos(ti),2.3,4.*sin(ti)), p, tr);\n        p.y -= 2.1*smoothstep(9.,13.,length(p.xz));\n        camTarget = mix(vec3(0,1.5,0), .5*p, tr);\n    }*/\n    \n    float ti = -.2*iTime+4.;\n    float r = 10.+5.*sin(.4*ti);\n    p = vec3(r*cos(.7*ti),2.5,r*sin(.7*ti));\n    p.y -= 2.1*smoothstep(9.,13.,length(p.xz));\n    camTarget = .8*p;\n    \n    return p;\n}\n\n// used for cam path equation setting\nvec3 laserBeam(in vec3 p)\n{\n    vec3 c = vec3(0);\n    c.r += smoothstep(.02,0.,abs(1.73*p.x-p.z-6.1));\n    c.r += smoothstep(.02,.0,abs(length(p.xz)-11.)) + smoothstep(.02,0.,abs(p.x+.15*p.z-1.4)) + smoothstep(.02,.0,abs(length(p.xz)-5.1));\n    return c;\n}\n\nvec3 mouseCam(in vec3 camTarget)\n{\n    float \trau = 12.,\n            alpha = iMouse.x/iResolution.x*4.*PI,\n            theta = (iMouse.y+.001)/iResolution.y*PI+ (PI/2.0001);\t// +0.001 to avoid black horizontal line\n \n    return rau*vec3(-cos(theta)*sin(alpha),sin(theta),cos(theta)*cos(alpha))+camTarget;\n}\n\n\n/******************************************************************/\n/*                        MAIN functions                          */\n/******************************************************************/\n\nvec3 getRay(in vec2 st, in vec3 pos, in vec3 camTarget){\n    float \tfocal = 1.5;\n    vec3 ww = normalize( camTarget - pos);\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0)) ) ;\n    vec3 vv = cross(uu,ww);\n\treturn normalize( st.x*uu + st.y*vv + focal*ww );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0.);\n    vec3 lit = vec3(.9759,.09759,.19518);   // light dir = (1.,.1,.2)\n    vec3 camTarget = vec3(0), pos = vec3(15.,1.,15.);\n   \n    if(iMouse.x > 2.){\n        camTarget = vec3(0.,1.,0.);\n        pos = mouseCam(camTarget);\n        pos.y = max(.1+RVAL-sqrt(RVAL*RVAL-pos.x*pos.x-pos.z*pos.z),pos.y);\n    }\n    else{\n        pos = getCamPos(camTarget); \n    }\n    \n    vec3 ray = getRay(st, pos,camTarget);\n    \n    \n    runGrid(pos,ray);\n\n#ifdef WITH_CHURCH\n    checkChurch(pos,ray);\n#endif\n\n    vec3 p = pos;\n    if(t<INFINI) p += t*ray; \n    \n    vec3 outp = p+.0001*n;\n    float lm = 0., lm2 = 0., dm = 0.;               // light mask\n    \n    // GROUND with shadows\n    if(hitObj == GND){\n        ray.y = abs(ray.y);\n        float df = texture(iChannel0,.5*p.xz).x-texture(iChannel0,.5*p.xz+vec2(.001)).x;\n        vec2 e = vec2(.001*length(p.xz),.3*atan(p.z,abs(p.x)));\n        col += .6+snowGlitt(p,ray)+.1*df+.4*(texture(iChannel0,.0005*p.xz).x-texture(iChannel0,.0005*p.xz+vec2(.00001*t)).x);   // gnd snow \n        col *= smoothstep(600.,0.,t);                           // fading to the mountains\n        col += min(.3,.0042*p.y*texture(iChannel0,e).x);        // snow and rocks over mountains\n        col += p.y*vec3(0.,.00015,.0002)*ray.x;   // color correction, magenta over exposed top\n        col *= .4+.6*dot(n,lit);\n        col *= fakeShade(p.xz, lit.xz);    // fake shadows (smooth and fast) \n        col *= 1.-.5*smoothstep(2.2,0.,abs(p.x+.4))*smoothstep(1.,0.,abs(p.z-.9))*step(.9,p.z)*smoothstep(.85,.75,p.x);    // towerbell correction        \n        //col *= gndShad(p,lit);               // more real (3D sahdows) slower and need dithering\n    }\n    // BODY bulding with windows and doors\n    else if(hitObj == BODY){\n        p -= boxCtr;\n        p.xz *= boxRot;\n        \n        col += .3*stonewall(p.zy+p.xy);\n         \n        // windows\n        float dctr = 1.6*boxH-.4;    // door center\n        vec3 pw = vec3(p.x, p.y-.3,fract(3.*p.z)-.5);\n        vec3 apw = abs(pw);\n        float fpz = floor(3.*p.z);\n        if(fpz+1.<dctr-.15 || fpz>dctr+.15){\n            lm = lightWinMask(apw);\n            col *= winMask(apw, ray);\n            col += window2D(pw, ray, lm, boxH); // fake 3D window\n        }\n        // window for level2 no balcony\n        if( boxSze.y<1.6 ){\n            pw = vec3(p.x, p.y-.8,fract(4.*p.z+.5)*mod(floor(4.*p.z+.5),2.)-.5);\n            apw = abs(pw);\n            lm2 = lightWinMask(apw);\n            col *= winMask(apw, ray);\n            col += window2D(pw, ray,lm2, boxH);\n        }\n        // balcony door\n        else{\n            pw = vec3(p.x, p.y-.85, p.z);\n            apw = abs(pw);\n            lm2 = lightWDMask(apw);\n            col *= wdMask(apw);\n            col += windoor2D(pw, ray, lm2, boxH);\n        }\n\n        // door\n        float pzCtr = p.z-dctr;   // pos from door center\n        dm = doorMask(p, ray, pzCtr);\n        col *= dm;\n        col += door2D(p, ray, pzCtr);      // fake 3D door\n        \n        // shading and lights\n        float rf = .65*(p.y+abs(p.z))/boxSze.y;    // roof occlusion\n        rf *= rf*rf*rf;\n        col -= rf*(1.-lm2);\n        \n        float gi = .6+.4*dot(n,lit);    // gen. illuminitaion\n        \n        float ls = 1.;\n        if(dot(n,lit)>0.) ls = locShad(outp,lit);\n        lm += lm2;\n        lm *= dm;\n        col *= lm+(1.-lm)*ls*gi;     // removing window mask to avoid erroneous shade on windows light     \n    }\n    // CHIMNEY\n    else if(hitObj == CHEM){\n        p -= boxCtr;\n        p.xz *= boxRot;\n        col += .3*stonewall(p.zy+p.xy);\n        col *= .6+.4*dot(n,lit);\n    }\n    // BALCONY\n    else if(hitObj == BALCON){\n        p -= boxCtr;\n        p.xz *= boxRot;\n        if(p.y > .77) col += .3;\n        else col += woodwall(10.*n.x*p.zy + 2.*n.y*p.xz);\n        col *= .6+.4*dot(n,lit);\n    }\n    // snowy ROOF\n    else if(hitObj == ROOF){\n        p -= boxCtr;\n        p.xz *= boxRot;\n        col += .4;\n        col += snowGlitt(p,ray);\n        col *= .6+.4*dot(n,lit);\n        if(dot(n,lit)>0.) col *= .6+.4*locShad(outp,lit);     \n    }\n    // wooden CEILING below roof\n    else if(hitObj == CEIL){\n        p -= boxCtr;\n        p.xz *= boxRot;\n        col += .3*woodwall(2.5*p.xy);\n        p.z*=8.;\n        col -= .1*(smoothstep(.2+.3*texture(iChannel0,.1*p.xz).x,.4,abs(fract(p.z)-.5)));\n        col *= .5+.5*dot(-ray,lit);\n    }\n    // TORCH street light\n    else if(hitObj == TORCH){\n        p -= boxCtr;\n        p.xz *= boxRot;\n        float sx = boxSze.x+.01;\n        sx *= sign(mod(boxCell.x,2.)-.5)*sign(mod(boxCell.y,2.)-.5);\n        p -= vec3(sx, .35, sx);\n        float l = length(p);\n        col += vec3(.00024,.00012,.00004)/(l*l);\n        col *= step(abs(p.x),.007)+step(abs(p.y),.027)+step(abs(p.z),.007);\n    }\n    \n#ifdef WITH_CHURCH\n\n    // CHURCH\n    else if(hitObj == CHURCH){\n        col += .4*stonewall(p.zy+p.xy);\n        col  *= .6+.4*dot(n,lit); \n        p += .001*n;                   // proximity occlusion\n        if(dot(n,lit)>0.) col *= locShad(p,lit);     \n        \n        \n        /** lateral windows **/\n        vec2 po = vec2(fract(1.7*p.x-.3)-.5, p.y-.35);\n        vec2 ap = abs(po);           // center of the window\n        vec2 poa = po-vec2(0.,.05);  // center of the arche\n        \n        // window mask\n        float wm = churchWindow(ap,poa);\n        \n        // moving center for the black mask (fake 3D)\n        vec2 ctr = .7*fake3D(ray,po);\n               \n        // black mask. same as window mask but with shifted center\n        ap = abs(ap-ctr);\n        poa -= sign(po)*ctr;\n        float bm = churchWindow(ap,poa);\n                \n        ap*=vec2(20.,5.);\n        ap.x = fract(ap.x)-.5;\n        vec3 litcol = vec3(.05,.04,.02)*(1.+2./length(ap));\n\n        // adding texture with brighter color on window mask (sides)\n        col += wm*vec3(.3,.24,.12);\n        // removing shifted hole part (black), in respect of window limits.\n        col *= 1.-wm*bm;\n        \n        po -= sign(po)*ctr;\n        po *= 30.;\n        col += bm*wm*litcol*(.3+.7*H12(floor(vec2(po.x+po.y,po.x-po.y))+floor(1.7*p.x-.3)+12.34));   // inside lights        \n        col *= 1.-wm*bm*(smoothstep(.9,1.,fract(po.x+po.y))+smoothstep(.9,1.,fract(po.x-po.y)));  // window grid\n        \n        \n        /** top round windows **/\n        poa = vec2(p.z, p.y-1.1);\n        wm = smoothstep(.1,.09,length(poa));\n        ctr = .7*fake3D(ray,poa);\n        poa -= sign(poa)*ctr;\n        float lpoa = length(poa);\n        bm =smoothstep(.1,.09,lpoa);\n        float ang = 2.*atan(poa.y,poa.x);\n        litcol = vec3(.04,.032,.016)/(lpoa+.02)*(.5+.5*H12(vec2(floor(ang))))*(1.-smoothstep(.8,1.,fract(ang)));\n        col += wm*vec3(.3,.24,.12);\n        col *= 1.-wm*bm;\n        col += bm*wm*litcol;\n        \n    }    \n    else if(hitObj == NEF){\n        vec2 a = vec2(atan(p.z,p.x),2.*p.y);\n        col += .4*stonewall(a);\n        col  *= .6+.4*dot(n,lit); \n        p += .001*n;                   // proximity occlusion\n        if(dot(n,lit)>0.) col *= locShad(p,lit);   \n        \n        \n        /** slot windows **/\n        vec2 po = vec2(fract(2.5*a.x-.5)-.5, a.y-.55);\n        vec2 ap = abs(po);           // center of the window\n         \n        float wm = smoothstep(.03,.02,ap.x)*smoothstep(.07,.06,ap.y);\n        vec2 ctr = .7*fake3D(ray,po);\n        ap = abs(ap-ctr);\n        float bm = smoothstep(.03,.02,ap.x)*smoothstep(.07,.06,ap.y);\n       \n        ap.y-=.1;\n        vec3 litcol = vec3(.05,.04,.02)*(.4/length(ap));\n        col += wm*vec3(.4,.32,.16);\n        col *= 1.-wm*bm;\n        col += bm*wm*litcol;\n        \n    }\n    else if(hitObj == TOWER){\n        //vec3 o = vec3(.4,1.8,1.);  // center of bell tower for memory\n        vec3 an = abs(n);\n        vec2 po = an.x*(p.zy-vec2(1.,1.8))+an.z*(p.xy-vec2(.4,1.8));   // face selection\n        vec2 ap = abs(po);           // center of the window\n        vec2 poa = po-vec2(0.,.16);  // center of the arche\n        \n        // window mask\n        float wm = bellWindow(ap,poa);\n        \n        // moving center for the black mask (fake 3D)\n        vec2 ctr = fake3D(ray,po);\n               \n        // black mask. same as window mask but with shifted center\n        ap = abs(ap-ctr);\n        poa -= sign(po)*ctr;\n        float bm = bellWindow(ap,poa);\n\n        // adding texture with darker color on window mask (sides)\n        col += (.4-.2*wm)*stonewall(2.*po);\n        // removing shifted hole part (black), in respect of window limits.\n        col *= 1.-bm*wm;\n        \n        col  *= .6+.4*dot(n,lit); \n        p += .001*n;                   // proximity occlusion\n        if(dot(n,lit)>0.) col *= locShad(p,lit);     \n    }\n    else if(hitObj == STEEP){\n        float f = smoothstep(.0,.15,(3.5-p.y)*texture(iChannel0,n.z*p.yx+n.x*p.yz).x);\n        col += (1.-f)*vec3(.43,.4,.37)*stonewall(vec2(.5*(p.z+p.x),.3*p.y));\n        col += .4*f;\n        col  *= .6+.4*dot(n,lit); \n    }\n    \n#endif\n\n    // SKY\n    else col += sky(ray.x, ray.y);\n    \n    // Overall illumination by torch\n    if(hitObj != SKY) col *= 1.+(1.-step(0.05,lm))*torchLight(outp)/(.6+.4*dot(n,lit));\n\n    //if(hitObj == GND) col += laserBeam(p);\n\n    fragColor = vec4(col,1.0);\n}\n\n \n", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "MllXR2", "previewfilepath": "https://soundcloud.com/desert-trax/carbon-based-lifeforms-rca", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/desert-trax/carbon-based-lifeforms-rca", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss2Xz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2751, 2751, 2770, 2770, 2887], [2889, 2889, 2907, 2907, 3072], [3074, 3074, 3093, 3093, 3218], [3221, 3221, 3244, 3244, 3287], [3465, 3465, 3504, 3504, 3570], [3572, 3602, 3652, 3693, 4030], [4032, 4122, 4175, 4282, 6370], [6372, 6372, 6435, 6435, 6745], [6747, 6747, 6806, 6806, 7104], [7107, 7107, 7158, 7158, 7548], [7551, 7551, 7605, 7605, 8286], [8289, 8289, 8341, 8341, 9473], [9650, 9683, 9736, 9736, 9919], [10275, 10298, 10354, 10354, 13332], [13509, 13509, 13548, 13548, 15106], [15283, 15342, 15384, 15384, 15593], [15595, 15622, 15666, 15666, 17040], [17042, 17216, 17250, 17250, 17345], [17347, 17347, 17387, 17387, 17516], [17519, 17519, 17547, 17547, 17903], [17905, 17905, 17931, 17931, 18163], [18319, 18367, 18423, 18423, 18637], [18639, 18639, 18692, 18692, 19241], [19294, 19294, 19335, 19335, 19404], [19406, 19406, 19439, 19439, 19506], [19508, 19508, 19573, 19573, 20249], [20251, 20306, 20336, 20336, 20482], [20485, 20485, 20512, 20512, 20579], [20581, 20581, 20613, 20613, 20691], [20693, 20693, 20758, 20758, 20924], [20986, 21000, 21038, 21038, 21201], [21203, 21203, 21246, 21246, 21378], [21380, 21380, 21425, 21425, 21559], [21738, 21796, 21850, 21850, 22825], [22828, 22828, 22869, 22869, 23100], [23235, 23291, 23352, 23352, 24470], [24473, 24531, 24569, 24569, 25141], [25143, 25198, 25236, 25236, 25478], [25661, 25661, 25700, 25700, 26410], [26412, 26412, 26440, 26440, 26716], [26926, 26926, 26962, 26962, 29015], [29017, 29055, 29082, 29082, 29311], [29313, 29313, 29347, 29347, 29619], [29830, 29830, 29886, 29886, 30091]], "test": "error"}
{"id": "ssBXDc", "name": "Metaballs retro", "author": "Sfora", "description": "some retro demoscene effect", "tags": ["retro", "metaballs", "learning"], "likes": 1, "viewed": 68, "published": "Public", "date": "1621507476", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n\nvec3 kolko(vec2 centrum, vec2 uv){\n\nfloat od = distance(uv, centrum );\nfloat kolko = smoothstep(0.385,0.1,od); //wielkość kulki i kosmatość, zależy od wielkości smootha\nreturn vec3(0.,pow(kolko,4.),kolko); //This place!!!!!\n                                       \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\nvec2 uv = fragCoord.xy / iResolution.xy;\nuv=uv-vec2(0.5,0.5);\nuv.x = uv.x*iResolution.x/iResolution.y; \nvec2 kulki[5];\nkulki[0] = vec2(0.02,0.15);\nkulki[1] = vec2(0.08,0.07);\nkulki[2] = vec2(0.15,-0.1);\nkulki[3] = vec2(-0.15,-0.15);\nkulki[4] = vec2(-0.07,-0.17);\nvec3 kulkiw[5];\nvec3 color;\n\nfor (int i=0;i<5;i++){\nfloat a=float(i);//Pamiętać o komentowaniu kodu :)\nfloat b = mod(a,3.)*sin(iTime*a)*0.08;//zakres odlatywania\n//jak te cholerne kulki odróżnić\nkulkiw[i] = kolko(kulki[i],uv);\nif (mod(a,2.)==0.){\nkulkiw[i] = kolko(vec2(kulki[i].x+0.45*cos(iTime)+b,kulki[i]+0.25*sin(iTime)+b),uv);}//te trasy są też ciekawe, pamiętać żeby dokładnie zrozumieć czemu :)\nif (mod(a,3.)==0.){\nkulkiw[i] = kolko(vec2(kulki[i].x+0.25*cos(iTime)+b,kulki[i]+0.75*sin(iTime)+b),uv);}\ncolor = color+kulkiw[i];\n};\n\nfragColor = vec4(color, 0.3);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssBXDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[3, 3, 37, 37, 274], [276, 276, 333, 333, 1177]], "test": "valid"}
{"id": "ssBXRG", "name": "sdf early out test", "author": "elenzil", "description": "A ring of circles with an 'early out' shell around them.\nWhat problems would I run into extending this to a similar 3D raymarched scene such as [url=https://www.shadertoy.com/view/ssjXWm]a bunch of spheres arranged in a sphere[/url] ?", "tags": ["boundingvolume", "bvh", "earlyout"], "likes": 3, "viewed": 206, "published": "Public API", "date": "1620458887", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdDisk(in vec2 p, in float rad) {\n    return length(p) - rad;\n}\n\nfloat sdCircle(in vec2 p, in float rad) {\n    return abs(sdDisk(p, rad));\n}\n\nfloat sdAnnulus(in vec2 p, in float rad1, in float rad2) {\n    return sdCircle(p, rad1) - rad2;\n}\n\n\nfloat map(in vec2 p) {\n    float d = 1e9;\n    \n    float num  = 7.0;\n    float rad1 = 1.0;\n    float rad2 = (sin(iTime * 0.1) * 0.12 + 0.13) * 10.0 / num;\n    \n    float dEarlyOut = sdAnnulus(p, rad1, rad2) - 0.1 ;\n    if (dEarlyOut > 0.0) {\n        return dEarlyOut + 0.1;\n    }\n    \n    for (float n = 0.0; n < num; ++n) {\n        float theta = 3.14159265359 * 2.0 * n / num;\n        d = min(d, sdDisk(p - vec2(cos(theta), sin(theta)) * rad1, rad2));\n    }\n    \n    return d;\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    vec2 uv = (XY - iResolution.xy / 2.0) / min(iResolution.x, iResolution.y);\n    uv *= 3.0;\n\n    float d = map(uv);\n\n    // colorize, thank-you iq.\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-9.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(80.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n    \n    RGBA = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssBXRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 69], [71, 71, 112, 112, 146], [148, 148, 206, 206, 245], [248, 248, 270, 270, 727], [729, 729, 772, 772, 1137]], "test": "valid"}
{"id": "ssBXRw", "name": "MorphingBox314", "author": "Domain314", "description": "intresting outcome of a short pre-breakfast shader session. kinda funny to watch. :D", "tags": ["raymarching"], "likes": 2, "viewed": 42, "published": "Public", "date": "1619870865", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100    // int\n#define MAX_DIST 100.    // float\n#define SURF_DIST .01\n\nfloat Box(vec3 p, vec3 s) {\n    return length(max(abs(p)-s, 0.));\n}\n\nfloat GetDist(vec3 p) {   \n    float planeDist= p.y+2.1;\n    float boxDist = Box(p-vec3(-1., 0., 6.), vec3(1.3));\n    \n    float d = min(boxDist, planeDist);\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.;\n    for(int i = 0; i < MAX_STEPS; i++){\n        vec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if (dO > MAX_DIST || dS < SURF_DIST) break;\n    }    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p);\n    vec2 e = vec2(.01, 0.);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy), \n        GetDist(p-e.yxy), \n        GetDist(p-e.yyx));\n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(-4., 6., -4.);\n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    \n    float dif = dot(n, l); \n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    if (d < length(lightPos-p)) dif *=.15;\n    return dif;\n}\n\nmat2 Rot (float i) {\n    float s = sin(i), c = cos(i);\n    return mat2(c, -s, s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv *= 1.;\n    //uv *= Scale(uv*-1.);\n\n    // \"Whole magic of this shader\"\n    uv *= vec2(Rot(iTime));\n    // End of \"Whole magic of this shader\"\n    \n    vec3 col = vec3(0.);\n    \n    vec3 ro = vec3(sin(iTime)*2., cos(iTime), sin(iTime));\n    //vec3 ro = vec3(0., 1., 0.);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.));\n\n    float d = RayMarch(ro, rd);    \n    vec3 p = ro + rd * d;\n   \n    float dif = GetLight(p);\n    \n    col = vec3(dif);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssBXRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 89, 116, 116, 156], [158, 158, 181, 181, 331], [333, 333, 367, 367, 583], [585, 585, 609, 609, 799], [801, 801, 825, 825, 1069], [1071, 1071, 1091, 1091, 1157], [1159, 1159, 1216, 1216, 1755]], "test": "valid"}
{"id": "ssjSDt", "name": "PRESS THE LIKE BUTTON, DAVE", "author": "JeanPaulSoftware", "description": "YOU WANT TO PRESS THE LIKE BUTTON AND IT IS ENTIRELY YOUR DECISION, YOU ARE NOT BEING INFLUENCED BY THE SPIRAL.\n\nNaive spiral implementation- if you change 'nCols' to 3  you'll see where it breaks.", "tags": ["simple", "spiral", "quick"], "likes": 6, "viewed": 225, "published": "Public API", "date": "1621331638", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926538\n\nfloat getEdgeFactor (float x, float lineWidth) {\n    // Probably a better way to do this\n    float halfWidth = lineWidth * 0.5;\n    float minDist = 0.0;\n    if (x > halfWidth && x < (1.0 - halfWidth)) {\n        return 0.0;\n    }\n    \n    minDist = min(abs(halfWidth - x), abs(1.0 - halfWidth - x));  \n    return clamp((minDist) / halfWidth, 0.0, 1.0);\n\n}\n\nvec3[5] palette = vec3[](\n    vec3(1., 22., 39.) / 255.0,\n    vec3(253., 255., 252.) / 255.,\n    vec3(46., 196., 182.) / 255.,\n    vec3(231., 29., 54.) / 255.,\n    vec3(255., 159., 28.) / 255.\n);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = 2.3;   \n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    float angleScale = 2.0; // 1.0;\n    float nCols = 4.0; // 2.0;\n    float direction = -1.0; // 1.0;\n\n    float angle = PI * 2.0 + atan(uv.y, uv.x) / PI * angleScale;\n    vec2 scaledUV = scale * uv;\n    \n    float dist = distance(scaledUV, vec2(0.0, 0.0));\n    float distFloor = floor(dist + angle + iTime * direction);\n    float distFract = fract(dist + angle + iTime * direction);\n    \n\n    \n    int paletteIndex = int(mod(distFloor, nCols));\n    vec3 background = palette[paletteIndex];\n    \n    float edgeFactor = getEdgeFactor(distFract, 0.04);\n    vec3 edgeColour = palette[4]; //palette[2];\n\n    // Output to screen\n    fragColor = vec4(mix(background, edgeColour, edgeFactor), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssjSDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 73, 113, 379], [578, 578, 635, 635, 1427]], "test": "valid"}
{"id": "ssjXD1", "name": "Bouncing Eclipse", "author": "Eylrid", "description": "A bouncing ball with a color changing glowing light behind it.", "tags": ["bounce", "colorchanging"], "likes": 2, "viewed": 44, "published": "Public", "date": "1620171903", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Circle(vec2 uv, vec2 p, float r, float blur){\n    float d = length(uv-p);\n    float c = smoothstep(r-blur, r+blur, d);\n    return c;\n}\n\nfloat Bounce(float p, vec2 bounds){\n    \n    float width = bounds[1]-bounds[0];\n\n    p /= 2.;        // divide by 2 to compensate for the fold\n    p -= bounds[0]; // get distance from p to lower bound\n    p /= width;     // scale distance to width\n    p = fract(p);   // wrap p in interval from 0. to 1.\n    p -= 0.5;       // shift to -0.5 to 0.5\n    p = abs(p);     // fold p back to 0. to 0.5\n    p *= 2.;        // stretch p to 0. to 1.\n    p *= width;     // stretch p to 0. to width\n    p += bounds[0]; // shift p based on lower bound\n    \n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float ar = iResolution.x/iResolution.y;\n    uv.x *= ar;\n\n    float t = iTime*.3;\n\n    float r = 0.1;\n\n    float x = Bounce(t*1., vec2(r,ar-r));\n    float y = Bounce(t*1.01, vec2(r,1.-r));\n    vec2 p = vec2(x, y);\n\n    vec3 col = vec3(0);\n\n    float shadow = 1.-Circle(uv, p, r*1.5, r*0.5);\n    vec3 shadowcol = vec3(0);\n\n    t *= 0.41;\n    shadowcol.r = sin(t*1.01)*.5+.5;\n    shadowcol.g = sin(t*2.01)*.5+.5;\n    shadowcol.b = sin(t*4.01)*.5+.5;\n    shadowcol /= length(shadowcol);\n\n    col.r = mix(col.r, shadowcol.r, shadow);\n    col.g = mix(col.g, shadowcol.g, shadow);\n    col.b = mix(col.b, shadowcol.b, shadow);\n\n    float mask = Circle(uv, p, r, 0.003);\n    col *= vec3(mask);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssjXD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 51, 51, 140], [142, 142, 177, 177, 703], [705, 705, 762, 812, 1599]], "test": "valid"}
{"id": "ssSSDd", "name": "Youtarou", "author": "yasuo", "description": "https://en.wikipedia.org/wiki/World_Trigger", "tags": ["reproduction"], "likes": 15, "viewed": 197, "published": "Public API", "date": "1621274582", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 2d distance functions from the Iq's site. https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define Skew(a,b) mat2(1.0,tan(a),tan(b),1.0)\n#define SkewX(a) mat2(1.0,tan(a),0.0,1.0)\n#define SkewY(a) mat2(1.0,0.0,tan(a),1.0)\n#define BendX(uv,k) mat2(cos(k*uv.x),-sin(k*uv.x),sin(k*uv.x),cos(k*uv.x))*uv.xy\n#define BendY(uv,k) mat2(cos(k*uv.y),-sin(k*uv.y),sin(k*uv.y),cos(k*uv.y))*uv.xy\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdRoundedBox( in vec2 p, in vec2 b, in vec4 r )\n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nvec3 youtaroEyebrow(vec2 uv, vec3 col, float addLineThick, float rot) {\n    uv.x = abs(uv.x);\n    uv.x-=0.25;\n    uv*=Rot(radians(-5.0+rot));\n    float d = sdBox(uv,vec2(0.12,0.001+addLineThick));\n    col = mix(col,vec3(0.0),S(d,0.0));\n    return col;\n}\n\nvec3 yotarouEyeAsset1(vec2 uv, vec3 col) {\n    float d = length(uv)-.1;\n    col = mix(col,vec3(0.0),S(d,0.0));\n    uv*=2.0;\n    uv.y*=2.0;\n    d = length(uv)-.1;\n    col = mix(col,vec3(1.0),S(d,0.0));\n    return col;\n}\n\nvec3 yotarouEyeAsset2(vec2 uv, vec3 col, float addLineThick) {\n    uv.x-=0.25;\n    uv.y*=2.0;\n    float d = abs(length(uv)-.13)-(0.002+addLineThick);\n    d = max(-uv.y+0.12,d);\n    col = mix(col,vec3(0.0),S(d,0.0));\n    return col;\n}\n\nvec3 youtaroEye(vec2 uv, vec3 col, float addLineThick) {\n    vec2 prevUV = uv;\n    uv.x = abs(uv.x);\n    uv.x-=0.25;\n    uv.y*=2.0;\n    \n    col = yotarouEyeAsset1(uv,col);\n    \n    uv = prevUV;\n    uv.x = abs(uv.x);\n    col = yotarouEyeAsset2(uv,col,addLineThick);\n    \n    return col;\n}\n\nvec3 youtaroEye2(vec2 uv, vec3 col, float addLineThick) {\n    \n    vec2 prevUV = uv;\n    uv.x = abs(uv.x);\n    uv*=Rot(radians(-20.0));\n    uv.x-=0.25;\n    uv.y*=2.0;\n    uv.y+=0.18;\n    \n    col = yotarouEyeAsset1(uv,col);\n    \n    uv = prevUV;\n    uv.x = abs(uv.x);\n    uv*=Rot(radians(-20.0));\n    uv.y+=0.08;\n    col = yotarouEyeAsset2(uv,col,addLineThick);\n    \n    return col;\n}\n\nvec3 youtaroEye3(vec2 uv, vec3 col, float addLineThick) {\n    \n    vec2 prevUV = uv;\n    uv = abs(uv);\n\n    uv.x-=0.25;\n    uv.y-=0.02;\n    \n    float d = sdBox(uv,vec2(0.07,0.002+addLineThick));\n    col = mix(col,vec3(0.0),S(d,0.0));\n    \n    uv = prevUV;\n    uv.x = abs(uv.x);\n    col = yotarouEyeAsset2(uv,col,addLineThick);\n    \n    return col;\n}\n\nvec3 youtaroMouth(vec2 uv, vec3 col, float addLineThick) {\n    uv*=2.5;\n    uv.y=abs(uv.y);\n    uv*=Rot(radians(15.0));\n    uv.y-=.05;\n    uv.y*=2.0;\n    float d = abs(length(uv)-.1)-(0.01+addLineThick);\n    d = max(d,uv.x);\n    col = mix(col,vec3(0.0),S(d,0.0));\n    return col;\n}\n\nvec3 youtarouHelmetRightEarPad(vec2 uv, vec3 col, float addLineThick) {\n    vec2 prevUV = uv;\n    uv*=SkewY(radians(-15.0));\n    uv.x+=0.395;\n    uv.y-=0.11;\n    uv*=Rot(radians(15.0));\n\n    float d = sdTriangle(uv-vec2(-0.02,-0.005),vec2(0.04,0.0),vec2(-0.04,0.0),vec2(0.0,-0.3))-0.05;\n    col = mix(col,vec3(1.0),S(d,0.0));\n    d = abs(sdTriangle(uv-vec2(-0.02,-0.005),vec2(0.04,0.0),vec2(-0.04,0.0),vec2(0.0,-0.3))-0.05)-(0.002+addLineThick);\n    col = mix(col,vec3(0.0),S(d,0.0));\n\n    d = sdTriangle(uv,vec2(0.04,0.0),vec2(-0.04,0.0),vec2(0.0,-0.3))-0.05;\n    col = mix(col,vec3(1.0),S(d,0.0));\n    d = abs(sdTriangle(uv,vec2(0.04,0.0),vec2(-0.04,0.0),vec2(0.0,-0.3))-0.05)-(0.002+addLineThick);\n    col = mix(col,vec3(0.0),S(d,0.0));    \n\n    uv*=2.5;\n    uv.x-=0.05;\n    uv.y+=0.2;\n    d = sdTriangle(uv,vec2(0.04,0.0),vec2(-0.04,0.0),vec2(0.0,-0.3))-0.05;\n    col = mix(col,vec3(0.5,0.3,0.0),S(d,0.0));\n    \n    uv = prevUV;\n    uv.x+=0.5;\n    uv.y+=0.41;\n    \n    vec2 q = BendY(uv,-3.0);\n    \n    d = sdBox(q,vec2(0.005,0.05))-0.02;\n    col = mix(col,vec3(0.3,0.1,0.0),S(d,0.0));\n    \n    return col;\n}\n\nvec3 youtarouHelmet(vec2 uv, vec3 col, float addLineThick) {\n    vec2 prevUV = uv;\n    uv.x*=0.4;\n    uv.y*=1.1;\n    float mask = length(uv-vec2(0.0,-0.45))-.5;\n    uv = prevUV;\n    uv.y-=7.54;\n    \n    float mask2 = prevUV.x+0.5;\n    float mask3 = -prevUV.x+0.5;\n    float d = length(uv-vec2(0.0,0.45))-8.0;\n    d = max(-mask3,max(-mask2,d));\n    col = mix(col,vec3(1.0),S(d,0.0));\n    d = abs(length(uv-vec2(0.0,0.45))-8.0)-(0.002+addLineThick);\n    d = max(-mask3,max(-mask2,d));\n    col = mix(col,vec3(0.0),S(d,0.0));\n    \n    uv = prevUV;\n    uv.y*=1.1;\n    d = sdRoundedBox(uv,vec2(0.5,0.54),vec4(0.5,0.5,0.5,0.5));\n    d = max(-mask,d);\n    col = mix(col,vec3(1.0),S(d,0.0));\n    d = abs(sdRoundedBox(uv,vec2(0.5,0.54),vec4(0.5,0.5,0.5,0.5)))-(0.002+addLineThick);\n    d = max(-mask,d);\n    col = mix(col,vec3(0.0),S(d,0.0));    \n    \n    uv = prevUV;\n    uv.y -=0.24;\n    d = sdBox(uv,vec2(0.001+addLineThick,0.24));\n    col = mix(col,vec3(0.0),S(d,0.0));\n    \n    uv = prevUV;\n    uv.x-=0.5;\n    uv.y+=0.41;\n    \n    vec2 q = BendY(uv,3.0);\n    d = sdBox(q,vec2(0.005+addLineThick,0.05))-0.02;\n    col = mix(col,vec3(0.3,0.1,0.0),S(d,0.0));      \n    \n    uv = prevUV;\n    uv*=SkewY(radians(15.0));\n    uv.x-=0.43;\n    uv.y-=0.11;\n    uv*=Rot(radians(-15.0));\n    d = sdTriangle(uv-vec2(-0.02,-0.01),vec2(0.04,0.0),vec2(-0.04,0.0),vec2(0.0,-0.3))-0.05;\n    col = mix(col,vec3(1.0),S(d,0.0));\n    d = abs(sdTriangle(uv-vec2(-0.02,-0.01),vec2(0.04,0.0),vec2(-0.04,0.0),vec2(0.0,-0.3))-0.05)-(0.002+addLineThick);\n    col = mix(col,vec3(0.0),S(d,0.0));\n\n    d = sdTriangle(uv,vec2(0.04,0.0),vec2(-0.04,0.0),vec2(0.0,-0.3))-0.05;\n    col = mix(col,vec3(1.0),S(d,0.0));\n    d = abs(sdTriangle(uv,vec2(0.04,0.0),vec2(-0.04,0.0),vec2(0.0,-0.3))-0.05)-(0.002+addLineThick);\n    col = mix(col,vec3(0.0),S(d,0.0));    \n\n    uv*=2.5;\n    uv.x-=0.05;\n    uv.y+=0.2;\n    d = sdTriangle(uv,vec2(0.04,0.0),vec2(-0.04,0.0),vec2(0.0,-0.3))-0.05;\n    col = mix(col,vec3(0.5,0.3,0.0),S(d,0.0));  \n    \n    uv = prevUV;\n    uv.y-=0.18;\n    uv.y*=0.99;\n\n    q = BendX(uv,-0.7);    \n    d = sdBox(q-vec2(0.0,-0.01),vec2(0.3,0.005))-0.14;\n    col = mix(col,vec3(1.0),S(d,0.0));    \n    d = abs(sdBox(q-vec2(0.0,-0.01),vec2(0.3,0.005))-0.14)-(0.002+addLineThick);\n    col = mix(col,vec3(0.0),S(d,0.0));\n    \n    d = sdBox(q-vec2(-0.01,0.01),vec2(0.3,0.005))-0.14;\n    col = mix(col,vec3(1.0),S(d,0.0));  \n    d = abs(sdBox(q-vec2(-0.01,0.01),vec2(0.3,0.005))-0.14)-(0.002+addLineThick);\n    col = mix(col,vec3(0.0),S(d,0.0));  \n    \n    uv = prevUV;\n    uv.x-=0.21;\n    uv.y-=0.145;\n    uv.y*=1.1;\n    uv*=Rot(radians(20.0));\n    d = sdRoundedBox(uv,vec2(0.15,0.12),vec4(0.12,0.12,0.12,0.12));\n    uv*=Rot(radians(20.0));\n    d = max(-uv.x,d);\n    \n    col = mix(col,vec3(0.9),S(d,0.0));\n    \n    uv = prevUV;\n    uv.x+=0.21;\n    uv.y-=0.145;\n    uv.y*=1.1;\n    uv*=Rot(radians(-20.0));\n    d = sdRoundedBox(uv,vec2(0.15,0.12),vec4(0.12,0.12,0.12,0.12));\n    \n    uv*=Rot(radians(30.0));\n    d = max(-uv.x,d);\n    \n    col = mix(col,vec3(0.9),S(d,0.0));    \n    \n    uv = prevUV;\n    uv.x = abs(uv.x);\n    uv.x-=0.21;\n    uv.y-=0.145;\n    uv.y*=1.1;\n    uv*=Rot(radians(20.0));\n    d = abs(sdRoundedBox(uv,vec2(0.19,0.14),vec4(0.14,0.14,0.14,0.14)))-(0.002+addLineThick);\n    d = max(-(length(uv)-0.185),d);\n    col = mix(col,vec3(0.0),S(d,0.0));\n    \n    uv = prevUV;\n    uv.x-=0.21;\n    uv.y-=0.145;\n    uv.y*=1.1;\n    uv*=Rot(radians(20.0));\n    d = abs(sdRoundedBox(uv,vec2(0.15,0.12),vec4(0.12,0.12,0.12,0.12)))-(0.002+addLineThick);\n        \n    uv = prevUV;\n    uv.x+=0.21;\n    uv.y-=0.145;\n    uv.y*=1.1;\n    uv*=Rot(radians(-20.0));\n    float d2 = abs(sdRoundedBox(uv,vec2(0.15,0.12),vec4(0.12,0.12,0.12,0.12)))-(0.002+addLineThick);\n    \n    d = min(d,d2);\n    \n    col = mix(col,vec3(0.0),S(d,0.0));\n    \n    \n    return col;\n}\n\nvec3 youtarouHair(vec2 uv, vec3 col) {\n    vec2 prevUV = uv;\n    uv.x+=0.425;\n    uv.y-=0.05;\n    uv*=Rot(radians(40.0));\n    float d = sdTriangle(uv,vec2(0.05,0.0),vec2(-0.05,0.0),vec2(0.0,-0.22));\n    col = mix(col,vec3(0.0),S(d,0.0));\n    \n    uv = prevUV;\n    uv.x+=0.38;\n    uv.y-=0.05;\n    uv*=Rot(radians(30.0));\n    d = sdTriangle(uv,vec2(0.05,0.0),vec2(-0.05,0.0),vec2(0.0,-0.25));\n    col = mix(col,vec3(0.0),S(d,0.0));\n    \n    uv = prevUV;\n    uv.x+=0.35;\n    uv.y-=0.05;\n    uv*=Rot(radians(20.0));\n    d = sdTriangle(uv,vec2(0.05,0.0),vec2(-0.05,0.0),vec2(0.0,-0.25));\n    col = mix(col,vec3(0.0),S(d,0.0));    \n    \n    uv = prevUV;\n    uv.x+=0.3;\n    uv.y-=0.1;\n    uv*=Rot(radians(10.0));\n    d = sdTriangle(uv,vec2(0.05,0.0),vec2(-0.05,0.0),vec2(0.0,-0.25));\n    col = mix(col,vec3(0.0),S(d,0.0));  \n    \n    uv = prevUV;\n    uv.x+=0.15;\n    uv.y-=0.07;\n    uv*=Rot(radians(40.0));\n    d = sdTriangle(uv,vec2(0.05,0.0),vec2(-0.05,0.0),vec2(0.0,-0.25));\n    col = mix(col,vec3(0.0),S(d,0.0));      \n    \n    uv = prevUV;\n    uv.y-=0.07;\n    uv*=Rot(radians(20.0));\n    d = sdTriangle(uv,vec2(0.04,0.0),vec2(-0.04,0.0),vec2(0.0,-0.15));\n    col = mix(col,vec3(0.0),S(d,0.0));     \n        \n    uv = prevUV;\n    uv.x-=0.42;\n    uv.y-=0.1;\n    uv*=Rot(radians(9.0));\n    d = sdTriangle(uv,vec2(0.05,0.0),vec2(-0.05,0.0),vec2(0.0,-0.35));\n    col = mix(col,vec3(0.0),S(d,0.0)); \n        \n    uv = prevUV;\n    uv.x-=0.38;\n    uv.y-=0.1;\n    uv*=Rot(radians(10.0));\n    d = sdTriangle(uv,vec2(0.05,0.0),vec2(-0.05,0.0),vec2(0.0,-0.25));\n    col = mix(col,vec3(0.0),S(d,0.0)); \n        \n    uv = prevUV;\n    uv.x-=0.35;\n    uv.y-=0.1;\n    uv*=Rot(radians(15.0));\n    d = sdTriangle(uv,vec2(0.05,0.0),vec2(-0.05,0.0),vec2(0.0,-0.2));\n    col = mix(col,vec3(0.0),S(d,0.0));     \n    \n    return col;\n}\n\nvec3 youtarouChin(vec2 uv, vec3 col, float addLineThick) {\n    vec2 prevUV = uv;\n    \n    uv.y*=1.1;\n    uv.y-=0.05;\n    \n    vec2  q = BendX(uv,0.2);\n    float d = sdRoundedBox(q,vec2(0.37,0.54),vec4(0.4,0.2,0.4,0.2));\n    d = max(uv.y,d);\n    col = mix(col,vec3(0.9,0.8,0.6),S(d,0.0));\n    d = abs(sdRoundedBox(q,vec2(0.37,0.54),vec4(0.4,0.2,0.4,0.2)))-(0.001+addLineThick);\n    d = max(uv.y,d);\n    col = mix(col,vec3(0.0),S(d,0.0));\n    return col;\n}\n\nvec3 youtarouEars(vec2 uv, vec3 col, float addLineThick) {\n    uv.x+=0.4;\n    uv.y+=0.16;\n    uv*=SkewY(radians(20.0));\n    uv*=Rot(radians(-10.0));\n    float d = sdRoundedBox(uv,vec2(0.05,0.07),vec4(0.05,0.05,0.05,0.05));\n    col = mix(col,vec3(0.9,0.8,0.6),S(d,0.0));\n    \n    d = abs(sdRoundedBox(uv,vec2(0.05,0.07),vec4(0.05,0.05,0.05,0.05)))-(0.002+addLineThick);\n    col = mix(col,vec3(0.0),S(d,0.0));\n\n    uv*=1.6;\n    d = abs(sdRoundedBox(uv-vec2(0.02,0.01),vec2(0.05,0.07),vec4(0.05,0.05,0.05,0.05)))-(0.002+addLineThick);\n    col = mix(col,vec3(0.0),S(d,0.0));\n    return col;\n}\n\nvec3 youtarou(vec2 uv, vec3 col, int type) {\n    float thickness = 0.004;\n    col = youtarouHelmetRightEarPad(uv,col,thickness);\n    col = youtarouEars(uv,col,thickness);\n    col = youtarouChin(uv,col,thickness);\n    col = youtaroEyebrow(uv-vec2(0.0,-0.05),col,thickness,(type == 1)?-20.0:0.0);\n    col = youtarouHair(uv,col);\n    col = youtarouHelmet(uv,col,thickness);\n    \n    if(type == 0){\n        col = youtaroEye(uv-vec2(0.0,-0.2),col,thickness);\n    } else if(type == 1){\n        col = youtaroEye2(uv-vec2(0.0,-0.2),col,thickness);\n    } else {\n        col = youtaroEye3(uv-vec2(0.0,-0.2),col,thickness);\n    }\n    col = youtaroMouth(uv-vec2(0.0,-0.38),col,thickness);\n    \n    return col;\n}\n\nvec3 bg(vec2 p, vec3 col) {\n    vec2 uv = fract(p)-0.5;\n    vec2 id = floor(p);\n    \n    vec2 randP = fract(sin(id*123.456)*567.89);\n    randP += dot(randP,randP*34.56);\n    float rand = fract(randP.x*randP.y);\n    \n    int type = 2;\n    if(rand<=0.3){\n        type = int(mod(iTime*0.5,3.0));\n    } else if(rand>0.4 && rand<=0.6) {\n        type = 1;\n    } else if(rand>0.7 && rand<0.8) {\n        uv*=Rot(radians(sin(iTime*2.0)*7.0));\n        type = 0;\n    }\n    \n    uv*=1.3;\n    col = youtarou(uv,col,type);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv*=2.5;\n    uv.y+=iTime*0.2;\n    vec3 col = vec3(1.0);\n    col = bg(uv,col);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssSSDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[572, 572, 609, 609, 689], [691, 691, 746, 746, 903], [905, 905, 972, 972, 1537], [1539, 1539, 1610, 1610, 1792], [1794, 1794, 1836, 1836, 2012], [2014, 2014, 2076, 2076, 2247], [2249, 2249, 2305, 2305, 2537], [2539, 2539, 2596, 2596, 2923], [2925, 2925, 2982, 2982, 3275], [3277, 3277, 3335, 3335, 3558], [3560, 3560, 3631, 3631, 4672], [4674, 4674, 4734, 4734, 8497], [8499, 8499, 8537, 8537, 10308], [10310, 10310, 10368, 10368, 10764], [10766, 10766, 10824, 10824, 11354], [11356, 11356, 11400, 11400, 12055], [12057, 12057, 12084, 12084, 12583], [12585, 12585, 12642, 12642, 12821]], "test": "valid"}
{"id": "ssSSRK", "name": "F2-F1 Voronoi", "author": "RiceFields", "description": "Voronoi", "tags": ["voronoi"], "likes": 1, "viewed": 42, "published": "Public", "date": "1620551533", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat aastep(float threshold, float value) {\n    float afwidth = 10.0f/iResolution.y; // pixel width for smoothstep edge \n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n}\n\nfloat stroke(float f, float size, float width) {\n    return aastep(size, f+width*0.5f) - aastep(size, f-width*0.5f);\n}\n\nfloat fill(float f, float size) {\n    return 1.-aastep(size, f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.y;\n    \n    uv *= 10.0f;\n    \n    vec2 iuv = floor(uv);\n    vec2 fuv = fract(uv);\n    \n    vec2 mDist = vec2(1.0f); // x least point distnace, y 2nd least point distance\n    \n    for(int j=-1; j<=1; ++j) {\n        for(int i=-1; i<=1; ++i) {\n            vec2 neighbour = vec2(float(i), float(j));\n            vec2 point = random2(iuv + neighbour);\n            \n            // animate\n            point = 0.5f + 0.5f*sin(iTime + 6.2831f*point);\n            \n            vec2 diff = neighbour + point - fuv;\n                        \n            float dist = dot(diff, diff); // lenght^2\n            \n            if(dist < mDist.x) {\n                mDist.y = mDist.x;\n                mDist.x = dist;\n            } else if(dist < mDist.y) {\n                mDist.y = dist;\n            }\n        }\n    }\n    \n    mDist = sqrt(mDist);\n    \n   vec3 col = vec3(fill(mDist.y - mDist.x, 0.04f)); // F2-F1 Voronoi,\n    //vec3 col = vec3(stroke(mDist.y - mDist.x, 0.05f, 0.02f)); // F2-F1 Voronoi,\n\n\n    fragColor = vec4(1.0f - col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssSSRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 117], [119, 119, 163, 163, 310], [312, 312, 360, 360, 430], [432, 432, 465, 465, 498], [500, 500, 557, 557, 1621]], "test": "valid"}
{"id": "ssSSWc", "name": "HelloLively", "author": "suweitao", "description": "Lively", "tags": ["lively"], "likes": 0, "viewed": 33, "published": "Public", "date": "1621140444", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    uv.x += cos(iTime);\n    vec3 col = vec3(0.);\n    float len = length(uv);\n    col = vec3(smoothstep(0.51, 0.50, len));\n    col *= vec3(1., 0.5, 0.5);\n\n    // Time varying pixel color\n    // vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssSSWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 513]], "test": "valid"}
{"id": "ssSSWR", "name": "Neon Rupture", "author": "Drakyen", "description": "No complex geometry here, only clever lighting and reflections :>", "tags": ["3d", "raymarching", "reflections"], "likes": 6, "viewed": 115, "published": "Public", "date": "1619986728", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NMAT mat(vec3(0.1), 1., 0., 0., 0.)\n\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nstruct mat\n{\n    vec3 col;\n    float diff;\n    float spec;\n    float refl;\n    float fres;\n};\n\nstruct obj\n{\n    float sdf;\n    mat mat;\n};\n\nstruct hit\n{\n    float rdf;\n    vec3 pos;\n    mat mat;\n};\n\nfloat box(vec3 p, vec3 s)\n{\n    vec3 q = abs(p) - s;\n    return min(max(q.x,max(q.y,q.z)),0.) + length(max(q, 0.));\n}\n\nobj om(obj a, obj b)\n{\n    if(a.sdf < b.sdf) {return a;} else {return b;}\n}\n\nobj scene(vec3 p)\n{\n   \n    float stepp = (sin(iTime/4.)*0.5+0.5)*16.+1.;\n    \n    mat A = mat(vec3(cos(iTime/2.)*0.5+0.5,sin(iTime/8.)*0.5+0.5,sin(iTime/4.)*0.5+0.5),1.,1.,1.,1.);\n    mat B = mat(vec3(1),1.,1.,0.2,1.);\n    \n    B.col = mix(vec3(3.,0.6,0.6), vec3(0.,2.,2.),fract(stepp));\n    \n    p.xy *= rot(iTime/8.);\n    \n    float outbox = box(p,vec3(30));\n    float outfill = box(p,vec3(29));\n    \n    p.xy *= rot(-iTime/2.);\n    p.xz *= rot(iTime/2.);\n    \n    float shell = max(-outfill,outbox);\n    float centre = box(p,vec3(1.5)) - 0.5;\n    \n    obj outer = obj(shell,A);\n    obj cube = obj(centre,B);\n    \n    return om(outer,cube);\n}\n\n\nhit trace(vec3 ro, vec3 rd)\n{\n    float d = 0.;\n    vec3 p;\n    obj s;\n    for(int i = 0; i < 256; i++)\n    {\n        p = ro + rd * d; \n        s = scene(p);\n        d += s.sdf;\n        if(s.sdf < 0.001) return hit(d, p, s.mat);\n        if(d > 128.) break;\n    }\n    return hit(-1., vec3(0), NMAT);\n}\n\nvec3 normal(hit h)\n{\n    vec2 e = vec2(0.001, 0.);\n    float d = scene(h.pos).sdf;\n    vec3 n = d - vec3(scene(h.pos - e.xyy).sdf, scene(h.pos - e.yxy).sdf, scene(h.pos - e.yyx).sdf);\n    return normalize(n);\n}\n\nvec3 lit(hit o, vec3 rd)\n{\n    vec3 n = normal(o);\n    \n    //fake diffuse lighting - purely distance-based. Creates a really nice soft effect though!\n    float diff = pow(1. - o.rdf/128.,5.) * o.mat.diff;\n    float fres = pow(1. - abs(dot(n,rd)), 4.) * o.mat.fres;\n    float spec = pow(max(dot(reflect(rd, n), -rd), 0.),10.) * o.mat.spec;\n    vec3 col = o.mat.col * (diff + fres) + spec;\n    return col;\n}\n\nvec3 col(vec3 ro, vec3 rd)\n{\n    mat ret = NMAT;\n    vec3 rfo = ro, rfd = rd;\n    float mxamnt = 1.;\n\n    float refl = (sin(iTime/4.)*0.5+0.5)*16.+1.;\n\n    for(float i = 0.; i < refl; i++)\n    {\n        hit h = trace(rfo, rfd);\n        ret.col = mix(ret.col, lit(h, rfd), mxamnt);\n        if(h.mat.refl <= 0.) break;       \n        vec3 n = normal(h);  \n        rfd = reflect(rfd, n);\n        rfo = h.pos + n * 0.001 * 2.;\n        mxamnt = clamp(mxamnt - (1. - h.mat.refl), 0., 1.);\n    }\n    \n    return ret.col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n\n    float stepp = (sin(iTime/4.)*0.5+0.5)*16.+1.;\n\n    vec3 ro = vec3(0,0,-10. + stepp * 0.3);\n    \n    //uncomment for camera movement around the centre cube\n    //ro.yz *= rot(iTime/4.);\n    \n    vec3 rd = normalize(vec3(uv.x,uv.y, 1.));\n    \n    // Output to screen\n    fragColor = vec4(col(ro,rd),1.0);\n    \n    //this line shows what the scene looks like with no reflections\n    //fragColor = vec4(lit(trace(ro,rd),rd),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssSSWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[298, 298, 325, 325, 415], [417, 417, 439, 439, 492], [494, 494, 513, 513, 1139], [1142, 1142, 1171, 1171, 1442], [1444, 1444, 1464, 1464, 1654], [1656, 1656, 1682, 1682, 2062], [2064, 2064, 2092, 2092, 2579], [2581, 2581, 2638, 2688, 3185]], "test": "valid"}
{"id": "ssSSWV", "name": "2D Planetary Rings", "author": "OceanJeff48", "description": "2D Planetary Rings inspired by No Man's Sky (Hello Games), and 'target with smoothstep' by possum, https://www.shadertoy.com/view/Xsl3RX", "tags": ["2d", "rings"], "likes": 2, "viewed": 44, "published": "Public", "date": "1621016088", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float N11(float p)                                                                        \n{                                                                                         \n   p = fract(sin(p * 813.552) * 34.5f);                                                   \n   p += dot(p, p + 24.2);                                                                 \n   return fract(p);                                                                       \n}                                                                                         \n\nconst float rings = 25.0;\t//exactly the number of complete white rings at any moment.\nconst float velocity=4.;\t\nconst float b = 0.003;\t\t//size of the smoothed border\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 position = fragCoord.xy/iResolution.xy;\n    float aspect = iResolution.x/iResolution.y;\n\tposition.x *= aspect;\n\tfloat dist = distance(position, vec2(aspect*0.5, 0.5));\n\tfloat offset=iTime*velocity;\n\tfloat conv=rings*4.;\n\tfloat v=dist*conv-offset;\n\tfloat ringr=floor(v) + N11(floor(v) + 174.321);\n\tfloat color=smoothstep(-b, b, abs(dist- (ringr+float(fract(v)>0.5)+offset)/conv));\n\tif(mod(ringr,2.)==1.)\n\t\tcolor=1.-color;\n\tfragColor = vec4(vec3(color) * N11(ringr), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssSSWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 92, 92, 456], [714, 714, 771, 771, 1249]], "test": "error"}
{"id": "ssSXD3", "name": "hehe - a typography shader", "author": "blackle", "description": "a shader I wrote while live coding among friends", "tags": ["letters", "hehe", "words"], "likes": 39, "viewed": 438, "published": "Public API", "date": "1621134579", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nfloat corner(vec2 p) {\n  return length(max(p,0.))+min(0.,max(p.x,p.y));\n}\n\nfloat linedist(vec2 p, vec2 a, vec2 b) {\n  float k = dot(p-a,b-a)/dot(b-a,b-a);\n  return distance(p,mix(a,b,clamp(k,0.,1.)));\n}\n\nfloat h_(vec2 p) {\n  float l1 = linedist(p, vec2(0,-.75), vec2(0,-10)) - 1.5;\n  float l2 = linedist(p, vec2(0,-.5), vec2(0,-10)) - .5;\n  float l3 = linedist(p, vec2(-1,10), vec2(-1,-10)) - .5;\n  float ud = abs(p.y)-2.5;\n  return corner(vec2(ud,min(max(l1,-l2),l3)));\n}\n\nfloat e_(vec2 p) {\n  float l1 = linedist(p, vec2(0,-.75), vec2(0,-1.)) - 1.5;\n  float l2 = linedist(p, vec2(0,-.5), vec2(0,-1.25)) - .5;\n  float l3 = linedist(p, vec2(-1,-.65), vec2(1,-.65)) - .25;\n  float ho = linedist(p, vec2(.45,-1.05), vec2(10,-1.05)) - .15;\n  return corner(vec2(min(max(l1,-l2),l3),-ho));\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax,p)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat profile(vec2 p, float stronch) {\n  return corner(vec2(abs(p.x)-stronch-.3,p.y+.05))-.05;\n}\n\nvec3 gploc;\nfloat letter(vec3 p, bool e, float off) {\n  p.z += sin(iTime*3.+off)*.2;\n  p = erot(p,vec3(0,1,0),cos(iTime*4.+off)*.1);\n  p = erot(p,vec3(0,0,1),sin(iTime*4.+off)*.1);\n  p.x += sin(iTime*4.7+off);\n  \n  float x = iTime*(5.+sin(off)*.5)+off;\n  float stronch = (sin(x)*.5+.5+sin(x*3.)*.2)*3.;\n  \n  gploc = p * vec3(1./(stronch+.35),1,1);\n  vec2 h = vec2(p.x,e ? e_(p.yz) : h_(p.yz));\n  return profile(h, stronch);\n}\n\nint gid;\nvec3 ggploc;\nfloat scene(vec3 p) {\n  p -= vec3(0,-1.2,0);\n  float h1 = letter(p-vec3(1,-3,0),false,.4);\n  ggploc = gploc;\n  gid = 0;\n  float e1 = letter(p,true,2.9);\n  if (e1 < h1) {\n    \n  ggploc = gploc;\n    gid = 1;\n    h1 = e1;\n  }\n  float e2 = letter(p-vec3(0,6,0),true,5.9);\n  if (e2 < h1) {\n    gid = 2;\n  ggploc = gploc;\n    h1 = e2;\n  }\n  float h2 = letter(p-vec3(1,3,0),false,4.2);\n  if (h2 < h1) {\n    gid = 3;\n  ggploc = gploc;\n    h1 = h2;\n  }\n  return h1;\n}\n\nvec3 norm(vec3 p) {\n  mat3 k = mat3(p,p,p) - mat3(0.001);\n  return normalize(scene(p) - vec3(scene(k[0]), scene(k[1]), scene(k[2])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n\n  bool ise =  sin(iTime*5.)>0.;\n  \n  vec3 cam = normalize(vec3(2,uv));\n  vec3 init = vec3(-18.+sin(iTime*3.5)*3.,0,0);\n  \n  float yrot = sin(iTime)*.4;\n  float zrot = cos(iTime*5.5)*.4;\n  float xrot = sin(iTime*2.)*.3;\n  cam = erot(cam,vec3(1,0,0),xrot);\n  init = erot(init,vec3(0,1,0),yrot);\n  cam = erot(cam,vec3(0,1,0),yrot);\n  init = erot(init,vec3(0,0,1),zrot);\n  cam = erot(cam,vec3(0,0,1),zrot);\n  init.z += sin(iTime*5.)*.4;\n  \n  vec3 p = init;\n  bool hit = false;\n  bool inside = false;\n  float trigdist = .05;\n  for (int i = 0; i < 150 && !hit; i++) {\n    float dist = scene(p);\n    p += cam*dist;\n    hit = dist*dist < 1e-6;\n    if (dist < trigdist) { \n      inside = true;\n    }\n    if (inside && dist > trigdist) break;\n    if (distance(p,init) > 50.) break;\n  }\n  vec3 ploc = ggploc;\n  float id = float(gid);\n  vec3 n = norm(p);\n  vec3 r = reflect(cam,n);\n  float fact = length(sin(r*4.2)*.5+.5)/sqrt(3.);\n  float diff = length(sin(n*2.9)*.4+.6)/sqrt(3.);\n  float fres = 1. - abs(dot(cam,n))*.98;\n  float spec = (fact*.05 + pow(fact,8.)*2.)*fres;\n  vec3 diffcol = vec3(0.7,.1,.05);\n  diffcol = erot(diffcol,n,.2);\n  diffcol = erot(diffcol,normalize(sin(n*6.)),.2);\n  diffcol = min(max(erot(diffcol,normalize(vec3(1,2,3)),id+floor(iTime*3.))*.8+.5,0.05),.9);\n  if (dot(sin(erot(ploc,normalize(vec3(1,1,1)),.6*id)*20.),vec3(1)) > 0.5) diffcol = pow(fact,4.)*diffcol*10.;\n  vec3 col = diff*diffcol+spec*mix(diffcol,vec3(1),.5);\n  float ang = atan(uv.x,uv.y);\n  float bg = sin(ang*10.+iTime*2.);\n  ang += iTime;\n  vec3 rainbow = vec3(sin(ang),sin(ang+3.14/3.),sin(ang+3.14*2./3.))*.4+.6;\n  bg = smoothstep(fwidth(bg),0.,bg);\n  float circ = length(uv)-.4;\n  circ = smoothstep(fwidth(circ),0.,circ);\n  vec3 bgcol = vec3(mix(rainbow,vec3(1),bg));\n  \n  vec3 fancycol = vec3(0.7,.1,.05);\n  fancycol = min(max(erot(fancycol,normalize(vec3(1,2,3)),9.+floor(iTime*3.)*1.3)*.8+.5,0.05),.9);\n  bgcol = mix(bgcol,fancycol,circ);\n  fragColor.xyz = hit ? col : bgcol;\n  if (inside && !hit) fragColor.xyz = vec3(0);\n  fragColor *= 1.-dot(uv,uv)*.3;\n  fragColor = sqrt(fragColor);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssSXD3.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[194, 194, 216, 216, 267], [269, 269, 309, 309, 396], [398, 398, 416, 416, 666], [668, 668, 686, 686, 980], [982, 982, 1020, 1020, 1080], [1082, 1082, 1120, 1120, 1178], [1192, 1192, 1233, 1233, 1605], [1629, 1629, 1650, 1650, 2087], [2089, 2089, 2108, 2108, 2224], [2226, 2226, 2283, 2283, 4418]], "test": "valid"}
{"id": "ssSXWm", "name": "Shane's Noise, but auto tiled", "author": "DEKTEN", "description": "Wanted to test out my auto tiling logic on a cool shader. So copied[ https://www.shadertoy.com/view/ldscWH ]and added auto tiling logic. Pages through all possible 16 auto tile sub tiles.", "tags": ["tiled", "shane", "autotile", "ruletile"], "likes": 3, "viewed": 157, "published": "Public API", "date": "1620346080", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//: A copy of shane's \"Smooth Noise Countours\" with auto tiling math applied to it.\n//: Pages through the 16 possible sub-tiles of an auto tile sets and maps shanes\n//: shader onto the tile. The screen being the coordinate space of the tile.\n//:\n//: You can use this kind of math to create procedural auto tiling.\n//:\n//: Shane's original shader: https://www.shadertoy.com/view/ldscWH\n//: \n//: My twitch coding stream: www.twitch.com/kanjicoder\n\n\n// Variable to a keep a copy of the noise value prior to palettization. Used to run a soft gradient \n// over the surface, just to break things up a little.\nfloat ns;\n\n\n//float sFract(float x, float sm){ float fx = fract(x); return fx - smoothstep(fwidth(x)*sm, 0., 1. - fx); }\n//float sFract(float x, float sm){ float fx = fract(x); return min(fx, fx*(1. - fx)/fwidth(x)/sm); }\n\n// Based on Ollj's smooth \"fract\" formula.\nfloat sFract(float x, float sm){\n    \n    // Extra smoothing factor. \"1\" is the norm.\n    const float sf = 1.; \n    \n    // The hardware \"fwidth\" is cheap, but you could take the expensive route and\n    // calculate it by hand if more quality was required.\n    vec2 u = vec2(x, fwidth(x)*sf*sm);\n    \n    // Ollj's original formula with a transcendental term omitted.\n    u.x = fract(u.x);\n    u += (1. - 2.*u)*step(u.y, u.x);\n    return clamp(1. - u.x/u.y, 0., 1.); // Cos term ommitted.\n}\n\n\n\n// Only correct for nonnegative values, but in this example, numbers aren't negative.\nfloat sFloor(float x){ return x - sFract(x, 1.); } \n\n// Standard hue rotation formula with a bit of streamlining. \nvec3 rotHue(vec3 p, float a){\n\n    vec2 cs = sin(vec2(1.570796, 0) + a);\n\n    mat3 hr = mat3(0.299,  0.587,  0.114,  0.299,  0.587,  0.114,  0.299,  0.587,  0.114) +\n        \t  mat3(0.701, -0.587, -0.114, -0.299,  0.413, -0.114, -0.300, -0.588,  0.886) * cs.x +\n        \t  mat3(0.168,  0.330, -0.497, -0.328,  0.035,  0.292,  1.250, -1.050, -0.203) * cs.y;\n\t\t\t\t\t\t\t \n    return clamp(p*hr, 0., 1.);\n}\n\n\n\n// vec3 to vec3 hash algorithm.\nvec3 hash33(vec3 p) { \n\n    // Faster, but doesn't disperse things quite as nicely as the block below it. However, when framerate\n    // is an issue, and it often is, this is the one to use. Basically, it's a tweaked amalgamation I put\n    // together, based on a couple of other random algorithms I've seen around... so use it with caution,\n    // because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n)*2. - 1.; // return fract(vec3(64, 8, 1)*32768.0*n)*2.-1.; \n\n    // I'll assume the following came from IQ.\n    //p = vec3( dot(p, vec3(127.1, 311.7, 74.7)), dot(p, vec3(269.5, 183.3, 246.1)), dot(p, vec3(113.5, 271.9, 124.6)));\n    //return (fract(sin(p)*43758.5453)*2. - 1.);\n\n}\n\n\n\n// Cheap, streamlined 3D Simplex noise... of sorts. I cut a few corners, so it's not perfect, but it's\n// artifact free and does the job. I gave it a different name, so that it wouldn't be mistaken for\n// the real thing.\n// \n// Credits: Ken Perlin, the inventor of Simplex noise, of course. Stefan Gustavson's paper - \n// \"Simplex Noise Demystified,\" IQ, other \"ShaderToy.com\" people, etc.\nfloat tetraNoise(in vec3 p)\n{\n    // Skewing the cubic grid, then determining the first vertice and fractional position.\n    vec3 i = floor(p + dot(p, vec3(.333333)) );  p -= i - dot(i, vec3(.166666)) ;\n    \n    // Breaking the skewed cube into tetrahedra with partitioning planes, then determining which side of the \n    // intersecting planes the skewed point is on. Ie: Determining which tetrahedron the point is in.\n    vec3 i1 = step(p.yzx, p), i2 = max(i1, 1. - i1.zxy); i1 = min(i1, 1. - i1.zxy);    \n    \n    // Using the above to calculate the other three vertices -- Now we have all four tetrahedral vertices.\n    // Technically, these are the vectors from \"p\" to the vertices, but you know what I mean. :)\n    vec3 p1 = p - i1 + .166666, p2 = p - i2 + .333333, p3 = p - .5;\n  \n\n    // 3D simplex falloff - based on the squared distance from the fractional position \"p\" within the \n    // tetrahedron to the four vertice points of the tetrahedron. \n    vec4 v = max(.5 - vec4(dot(p, p), dot(p1, p1), dot(p2, p2), dot(p3, p3)), 0.);\n    \n    // Dotting the fractional position with a random vector, generated for each corner, in order to determine \n    // the weighted contribution distribution... Kind of. Just for the record, you can do a non-gradient, value \n    // version that works almost as well.\n    vec4 d = vec4(dot(p, hash33(i)), dot(p1, hash33(i + i1)), dot(p2, hash33(i + i2)), dot(p3, hash33(i + 1.)));\n     \n     \n    // Simplex noise... Not really, but close enough. :)\n    return clamp(dot(d, v*v*v*8.)*1.732 + .5, 0., 1.); // Not sure if clamping is necessary. Might be overkill.\n\n}\n\n\n// The function value. In this case, slightly-tapered, quantized Simplex noise.\nfloat func(vec2 p){\n    \n    // The noise value.\n    float n = tetraNoise(vec3(p.x*4., p.y*4., 0) - vec3(0, .25, .5)*iTime);\n    \n    // A tapering function, similar in principle to a smooth combine. Used to mutate or shape \n    // the value above. This one tapers it off into an oval shape and punches in a few extra holes.\n    // Airtight uses a more interesting triangular version in his \"Cartoon Fire\" shader.\n    float taper = .1 + dot(p, p*vec2(.35, 1));\n\tn = max(n - taper, 0.)/max(1. - taper, .0001);\n    \n    // Saving the noise value prior to palettization. Used for a bit of gradient highlighting.\n    ns = n; \n    \n    // I remember reasoning to myself that the following would take a continuous function ranging\n    // from zero to one, then palettize it over \"palNum\" discreet values between zero and one\n    // inclusive. It seems to work, but if my logic is lacking (and it often is), feel free to \n    // let me know. :)\n    const float palNum = 9.; \n    // The range should strictly fall between zero and one, but for some crazy reason, numbers fall\n    // outside the range, so I've had to clamp it. I know the computer is never wrong, so I'm \n    // probably overlooking something. Having said that, I don't trust the GPU \"fract\" function much.\n    //return clamp(sFloor(n*(palNum - .001))/(palNum - 1.), 0., 1.);\n    return n*.25 + clamp(sFloor(n*(palNum - .001))/(palNum - 1.), 0., 1.)*.75;\n    \n}\n\nvec2 getSubTileCoords( vec2 f_c ){\n\n    //: Pretend the entire screen is one tile for this  -----://\n    //: example code. Center is at [0,0] , top left is  -----://\n    //: at [-1,-1] and bottom right is at [+1,+1]       -----://\n    vec2 uvc   = (f_c -0.5*iResolution.xy)/iResolution.y;\n         uvc.y =( 0.0 - uvc.y ); //:Invert Y axis\n\n//+----------------------------------------------------------+//\n//| What is the current wang-tile touching mask for          |//\n//| the tile you are drawing. In this example,               |//\n//| pretend the entire screen is one tile.                   |//\n//| TIL == Your One Tile                                     |//\n//|          +---+                                           |//\n//|          |y_0|                                           |//\n//|      +---+---+---+      0|1  0|1  |  0|1  0|1            |//\n//|      |x_0|TIL|x_1| -->  ___  ___  |  ___  ___            |//\n//|      +---+---+---+      X_0  X_1  |  Y_0  Y_1            |//\n//|          |y_1|                                           |//\n//|          +---+                                           |//\n//|                                                          |//\n//| toutang means : Touching Tangent                         |//\n//|                                                          |//\n//| [-1,-1]                                                  |//\n//|     +-------------+                                      |//\n//|     |             |                                      |//\n//|     |             |                                      |//\n//|     |     0.0     | <--[ TIL ] www.twitch.com/kanjicoder |//\n//|     |             |                                      |//\n//|     |             |                                      |//\n//|     +-------------+                                      |//\n//|                 [+1,+1]                                  |//\n//|                                                          |//\n//+----------------------------------------------------------+//\n\n    //:Animate the touching value of your tile.         -----://\n    //:Emulating all different combinations of which    -----://\n    //:neighbors can exist above,below,left,and right:  -----://\n\n    uint toutang=(uint(int(mod(iTime,16.0))));\n\n//+----------------------------------------------------------+//\n//|   +-----------------+ If( touself ==BINARY[ 1000 ] )THEN:|//\n//|   |\\\\     y_0     //|                                    |//\n//|   |  \\\\         //  |   We are in the x_0 pie slice.     |//\n//|   |    \\\\     //    |                                    |//\n//|   |      \\\\ //      | If( touself ==BINARY[ 1010 ] )THEN:|//\n//|   |x_0  ( 0.0 )  x_1|                                    |//\n//|   |      // \\\\      |   I fucked up the formula because  |//\n//|   |    //     \\\\    |   only ONE_BIT in touself should   |//\n//|   |  //         \\\\  |   have been set.                   |//\n//|   |//     y_1     \\\\|                                    |//\n//|   +-----------------+                                    |//\n//|   BITS[  0   0   0   0  ]                                |//\n//|   SIDE[ x_0 x_1 y_0 y_1 ]     www.twitch.com/kanjicoder  |//\n//|                                                          |//\n//|   touself means: \"TOUching SELF\"                         |//\n//+----------------------------------------------------------+//\n\n    //:Figure out which pie slice the pixel of  -------------://\n    //:your tile belongs to and set that bit:   -------------://\n    #define A abs\n    #define U uint\n    #define X uvc.x\n    #define Y uvc.y\n    U touself =( U(0)\n    | (( (X <= 0.0 && (A(X)>A(Y))) ? U(1) : U(0) ) << 3)\n    | (( (X >= 0.0 && (A(X)>A(Y))) ? U(1) : U(0) ) << 2)\n    | (( (Y <= 0.0 && (A(Y)>A(X))) ? U(1) : U(0) ) << 1)\n    | (( (Y >= 0.0 && (A(Y)>A(X))) ? U(1) : U(0) ) << 0)\n    );;\n    #undef A\n    #undef U\n    #undef X\n    #undef Y\n\n    //:If we are on a pie slice that is touching a           ://\n    //:neighbor, use the connected gradient(congrad).        ://\n    //:If we are on a pie slice that is __NOT__              ://\n    //:touching a neighbor, use walled-off gradient(walgrad).://\n    float walgrad = float( max( abs(uvc.x),abs(uvc.y) ) );\n    float congrad = float( min( abs(uvc.x),abs(uvc.y) ) );\n    float tougrad = (( touself & toutang )>=uint(1)) \n                 ? congrad   //:TRUE : Connected  Gradient\n                 : walgrad ; //:FALSE: Walled Off Gradient\n\n    float invgrad = (( touself & toutang )>=uint(1)) \n                 ? walgrad   //:INVERTED_GRADIENT\n                 : congrad ; //:INVERTED_GRADIENT\n\n    return( vec2( tougrad , invgrad ) );\n\n} //:[getSubTileCoords]:<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<://\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Screen coordinates.\n\tvec2 u = getSubTileCoords( fragCoord );\n    \n    // Function value.\n    float f = func(u);\n    float ssd = ns; // Saving the unpalettized noise value to add a little gradient to the color, etc.\n    \n    // Four sample values around the original. Used for edging and highlighting.\n    vec2 e = vec2(1.5/iResolution.y, 0);\n    float fxl = func(u + e.xy);\n    float fxr = func(u - e.xy);\n    float fyt = func(u + e.yx);\n    float fyb = func(u - e.yx);\n    \n    // Colorizing the function value, and applying some hue rotation based on position.\n    // Most of it was made up.\n    vec3 col = pow(min(vec3(1.5, 1, 1)*(f*.7 + ssd*.35), 1.), vec3(1, 2., 10)*2.) + .01;\n    col = rotHue(col, -.25+.4*length(u));\n\n    // Applying the dark edges.\n    col *= max(1. - (abs(fxl - fxr) + abs(fyt - fyb))*5., 0.);\n    //col *= max(1. - length(vec2(fxl, fyt) - vec2(fxr, fyb))*7., 0.);\n    // Resampling with a slightly larger spread to provide some highlighting.\n    fxl = func(u + e.xy*1.5);\n    fyt = func(u + e.yx*1.5);\n    col += vec3(.5, .7, 1)*(max(f - fyt, 0.) + max(f - fxl, 0.))*ssd*10.;\n    \n    // Subtle, bluish vignette.\n    //u = fragCoord/iResolution.xy;\n    //col = mix(vec3(0, .1, 1), col, pow( 16.0*u.x*u.y*(1.0-u.x)*(1.0-u.y) , .125)*.15 + .85);\n\n \t\n    // Rough gamma correction.\n    fragColor = vec4(sqrt(clamp(col, 0., 1.)), 1);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssSXWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[827, 870, 902, 955, 1360], [1364, 1450, 1472, 1472, 1500], [1503, 1565, 1594, 1594, 1964], [1968, 2000, 2021, 2387, 2766], [2770, 3160, 3189, 3280, 4769], [4772, 4852, 4871, 4900, 6271], [10987, 10987, 11041, 11069, 12414]], "test": "valid"}
{"id": "stf3D7", "name": "Kinda cool, HSV Wheel Mishap", "author": "MrNissenDK", "description": "Well I tried to use the code I found to convert the HSV value to RGB instead, of the one I wrote and this kind of thing comes out of it, I kinda like it.", "tags": ["wheel", "hsv", "mishap"], "likes": 3, "viewed": 143, "published": "Public API", "date": "1622200559", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float PI = 3.1415926;\nfloat THI = 6.2831853;\n\nvec3 HSV2RGB(vec3 color){//Based on https://www.rapidtables.com/convert/color/hsv-to-rgb.html\n    color.x = fract(color.x);\n    color = clamp(color,0.,1.);\n    \n    float C = color.z * color.y;\n    float X = C * (1. - abs(mod(color.x*360./60.,2.) - 1.));\n    float m = color.z - C;\n    \n    vec3 RGB_1;\n    switch(int(color.x*6.)){\n        case 0:\n            RGB_1 = vec3(C,X,0);\n            break;\n        case 1:\n            RGB_1 = vec3(X,C,0);\n            break;\n        case 2:\n            RGB_1 = vec3(0,C,X);\n            break;\n        case 3:\n            RGB_1 = vec3(0,X,C);\n            break;\n        case 4:\n            RGB_1 = vec3(X,0,C);\n            break;\n        case 5:\n            RGB_1 = vec3(C,0,X);\n            break;\n            \n    }\n    return vec3((RGB_1.x+m),(RGB_1.y+m),(RGB_1.z+m));\n}\nvec3 hsv2rgb(vec3 c){\n\tvec4 K=vec4(1.,2./3.,1./3.,3.);\n\treturn c.z*mix(K.xxx,clamp(abs(fract(c.x+K.xyz)*6.-K.w)-K.x,0.,1.),c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ((fragCoord - .5 * iResolution.xy) / iResolution.y) * 3.;\n    \n    vec3 col = vec3(0);\n    \n    col += hsv2rgb(vec3(atan(uv.y,uv.x)/THI + iTime / 5.,length(uv)*4.,4.-length(uv)*4.));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stf3D7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 71, 139, 860], [861, 861, 882, 882, 991], [993, 993, 1050, 1050, 1280]], "test": "valid"}
{"id": "stf3RM", "name": "flow noise test 2", "author": "RiceFields", "description": "noise", "tags": ["noise", "lava", "flow"], "likes": 0, "viewed": 70, "published": "Public", "date": "1621763976", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define OCTAVES 2\n#define LACUNARITY 2.0\n#define GAIN 0.5\n\nvec2 rotate2d(vec2 uv, float angle) {\n    mat2 mat = mat2(cos(angle), -sin(angle), sin(angle), cos(angle)); \n    return (mat*(uv));\n}\n\n\nvec2 random2(vec2 uv){\n    uv = vec2( dot(uv,vec2(127.1,311.7)), dot(uv,vec2(269.5,183.3)) );\n    vec2 v = -1.0 + 2.0 * fract(sin(uv) * 43758.5453123);  \n    v = rotate2d(v, iTime); // rotated random direction\n    return v;\n}\n\n\nfloat noise(vec2 uv) {\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    \n    // four corners\n    float a = dot( random2(i + vec2(0.0,0.0) ), f);\n    float b = dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) );\n    float c = dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) );\n    float d = dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) );\n    \n    // interplation, cubic hermite\n    vec2 u = f*f*(3.0 - 2.0*f);\n    \n    return mix(mix(a,b, u.x), mix(c, d, u.x), u.y);\n}\n\nfloat fbm(vec2 uv) {\n    float v = 0.0f;\n    float amplitude = 0.5f;\n    float frequency = 5.0f;\n    \n    for(int i = 0; i < OCTAVES; ++i) {\n        float n = abs(noise((uv)*frequency)); //abs(noise) - turbulence, create creases\n        \n        // creating ridge\n        n = 1.0f - n; // invert so creases are at top\n        n *= n*n; // sharpen creases\n        \n        v += amplitude * n; \n        frequency *= LACUNARITY;\n        amplitude *= GAIN;\n    }\n    return v*2.0f - 0.5f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.y;\n\n    float f = fbm(uv);\n    \n    vec3 col = mix(vec3(0.81,0.06,0.13), vec3(0.80,0.40,0.00), f*f);\n    \n    //float u = f; // fix saturation linearly\n    float u = f*f*(3.0f - 2.0f*f); // fix saturation with cubic hermite - looks more natural\n    col *= u; \n    \n    // Output to screen\n    fragColor = vec4(vec3(3.0f*col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stf3RM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 96, 96, 192], [195, 195, 217, 217, 420], [423, 423, 445, 445, 908], [910, 910, 930, 930, 1396], [1398, 1398, 1454, 1454, 1823]], "test": "valid"}
{"id": "stfGDn", "name": "Jewel room", "author": "butadiene", "description": "2 hour coding\nhttps://www.youtube.com/watch?v=LlR4BXY3cWg", "tags": ["raymarching"], "likes": 6, "viewed": 273, "published": "Public API", "date": "1621872034", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Copyright (c) 2021 Butadiene\n//Released under the MIT license\n//https://opensource.org/licenses/mit-license.php\n\n#define T iTime\n\nconst float PI = 3.141592;\n\nmat2 rot(float r){\n  return mat2(cos(r),sin(r),-sin(r),cos(r));\n}\n\nfloat box2d(vec2 p,vec2 s){\n  vec2 q = abs(p);\n  vec2 m = max(s-q,0.);\n  return length(max(q-s,0.))-min(m.x,m.y);\n}\n\nfloat crobox(vec3 p,float sca){\n  float dx = box2d(p.yz,vec2(sca));\n  float dy = box2d(p.xz,vec2(sca));\n  float dz = box2d(p.xy,vec2(sca));\n  return min(min(dx,dy),dz);\n}\n\nfloat box(vec3 p,vec3 s){\n  vec3 q = abs(p);\n  vec3 m = max(s-q,0.);\n  return length(max(q-s,0.))-min(m.z,min(m.x,m.y));\n}\n\nfloat ease(float t,float k){\n  return -exp(-1.0*mod(t,k))+floor(t/k);\n}\n\nvec4 nanika(vec3 p){\n  float kt =T;/// 2.*ease(time*2.,3.);\n  p.xz *= rot(kt);\n  p.yz *= rot(kt);\n  vec3 acol = vec3(0.);\n  float sct = 0.23;\n  vec3 col1 = vec3(0.6,0.6,0.2);\n  vec3 col2 = vec3(0.2,0.6,0.6);\n  vec3 col3 = vec3(0.6,0.6,0.2);\n  for(int i = 0;i<8;i++){\n    p = abs(p)-0.2;\n    p.xy *= rot(sct);\n    p.xz *= rot(sct);\n    p.yz *= rot(sct);\n    if(p.x<p.y&&p.x<p.z){acol += col1;}\n    else if(p.y<p.z){acol += col2;}\n    else{acol += col3;}\n  }\n  \n  float d = length(p)-0.2;\n  d = crobox(p,0.05);\n  vec3 col =1.*acol*exp(-3.0*d);\n  return vec4(col,d);\n}\n\nvec4 yuka(vec3 p,float t){\n  p.y -= 0.;\n  p.z += T*10.;\n  float k = 1.5;\n  float sc = k*40.;\n  float rsc = 0.2;\n  \n  p.y = -abs(p.y);\n  \n  float xzmod = 80.0;\n  p.xz = mod(p.xz,xzmod)-0.5*xzmod;\n  vec3 acol = vec3(0);\n  for(int i = 0;i<7;i++){\n    p.xz = abs(p.xz)-sc;\n    sc *= 0.5;\n    p.xy *= rot(rsc);\n    p.zy *= rot(rsc);\n    p.xz *= rot(0.3);\n    if(p.x<p.z){ acol += vec3(0.2,0.6,0.8);}\n    else{acol += vec3(0.6,0.2,0.5); }\n  }\n  \n\n  float size = k*0.5-0.1;\n  float d = box(p,vec3(size,10.,size));\n  vec3 col = vec3(0);\n  return vec4(2.2*acol*exp(-1.0*d)*exp(-0.08*t),d);\n}\n\nvec4 dist(vec3 p,float totalt){\n  float k = 0.6;\n  //p = mod(p,k)-0.5*k;\n  float scy = 1.0;\n  vec4 yukad = yuka(p*scy,totalt)/scy;\n  float scn = 0.6;\n  vec4 nanikad = nanika(p*scn);\n  float d = min(nanikad.w/scn,yukad.w);\n  vec3 col = nanikad.xyz;\n  col += yukad.xyz;\n  return vec4(col,d);\n}\n\nvec3 gn(vec3 p){\n  vec2 e = vec2(0.001,0.);\n  return normalize(vec3(\n    dist(p+e.xyy,1.).w-dist(p-e.xyy,1.).w,\n    dist(p+e.yxy,1.).w-dist(p-e.yxy,1.).w,\n    dist(p+e.yyx,1.).w-dist(p-e.yyx,1.).w\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){vec2 r=iResolution.xy,p=(fragCoord.xy*2.-r)/min(r.x,r.y);\nvec2 uv = gl_FragCoord.xy/r;\n\nfloat ra = 14.0;\nfloat kt = T*0.3;\nvec3 ro = vec3(ra*cos(kt),6.,ra*sin(kt));\nvec3 ta = vec3(0);\n\nvec3 cdir = normalize(ta-ro);\nvec3 side = cross(cdir,vec3(0,1,0));\nvec3 up = cross(side,cdir);\nvec3 rd = normalize(side*p.x+cdir*0.8+up*p.y);\n\nfloat d,t= 0.;\nfloat es = 0.0001;\nvec3 ac = vec3(0.);\nfor(int i = 0;i<76;i++){\n  vec4 rsd = dist(ro+rd*t,t);\n  d = rsd.w;\n  t += d;\n  ac += rsd.xyz;\n  if(d<es)break;\n}\n\nvec3 col = vec3(0);\ncol = ac*0.01;\n\nif(yuka(ro+rd*t,1.).w<es){\n  vec3 sro =ro;\n  vec3 srd =rd;\n  vec3 sp = ro+rd*t;\n  vec3 normal = gn(sp);\n  rd = reflect(rd,normal);\n  ro = sp;\n  t = 0.01;\n  ac = vec3(0.);\n  for(int i = 0;i<36;i++){\n    vec4 rsd = dist(ro+rd*t,length(rd*t+sp));\n    d = rsd.w;\n    t += d;\n    \n    ac += rsd.xyz;\n    if(d<es)break;\n  }\n  col += 0.01*ac;\n}\n\n\n\nfloat et = 0.1/abs(uv.y*4.-ease(uv.x*16.,4.));\ncol = 1.2*pow(col,vec3(1.2));\nfragColor=vec4(col,1);}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stfGDn.jpg", "access": "shaders20k", "license": "mit", "functions": [[160, 160, 178, 178, 225], [227, 227, 254, 254, 342], [344, 344, 375, 375, 514], [516, 516, 541, 541, 638], [640, 640, 668, 668, 711], [713, 713, 733, 733, 1278], [1280, 1280, 1306, 1306, 1862], [1864, 1864, 1895, 1895, 2155], [2157, 2157, 2173, 2173, 2363], [2365, 2365, 2421, 2421, 3395]], "test": "valid"}
{"id": "stfGRS", "name": "2D Isometric Projection", "author": "Tech_", "description": "Here is a shader demonstrating the concept of transforming from cartesian coordinates to isometric coordinates.", "tags": ["projection", "isometric", "matrices"], "likes": 2, "viewed": 155, "published": "Public API", "date": "1622291314", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst mat2 isometricMat = mat2(vec2(-0.5, 0.5), vec2(1.0));\nconst mat2 isometricMatInv = inverse(isometricMat);\n\nvec2 CartesianToIsometric(in vec2 cartesian) {\n    return isometricMat * cartesian;\n}\n\nvec2 IsometricToCartesian(in vec2 isometric) {\n   return isometricMatInv * isometric;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv *= 10.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    uv = mix(uv, CartesianToIsometric(uv), cos(iTime) * 0.5 + 0.5);\n\n    vec3 col;\n    col += step(fract(uv.x), 0.03);\n    col += step(fract(uv.y), 0.03);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stfGRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[114, 114, 160, 160, 199], [201, 201, 247, 247, 288], [290, 290, 347, 347, 636]], "test": "error"}
{"id": "stl3DN", "name": "an animated distorted circle", "author": "nebbul", "description": "a circle distorted with some noise", "tags": ["circle", "distorted"], "likes": 4, "viewed": 59, "published": "Public", "date": "1622147090", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// background grid from https://www.shadertoy.com/view/XtBfzz\n\nconst float N = 2.0; // grid ratio\nfloat gridTexture( in vec2 p )\n{\n    // coordinates\n    vec2 i = step( fract(p), vec2(1.0/N) );\n    //pattern\n    //return (1.0-i.x)*(1.0-i.y);   // grid (N=10)\n    \n    // other possible patterns are these\n    //return 1.0-i.x*i.y;           // squares (N=4)\n    return 1.0-i.x-i.y+2.0*i.x*i.y; // checker (N=2)\n}\n\n\n// base code taken from:\n// https://www.shadertoy.com/view/XsjGDt\n//\n\n// Draw a circle at \"pos\" with radius \"rad\"\nfloat circle(vec2 uv, vec2 pos, float rad) {\n\tfloat d = length(pos - uv) - rad;\n    // anti aliasing\n    float t = smoothstep(-0.75, 0.75, d);\n    \n\treturn t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // define our UVs\n\tvec2 uv = fragCoord.xy;\n    // get center of image\n\tvec2 center = iResolution.xy * 0.5;\n    // set radius of circle\n\tfloat radius = 0.25 * iResolution.y * ((sin(iTime)+1.0)/2.0 + 0.5);//sin(length(iResolution.y-center)*(iTime*0.02))*1.0;\n    float radius_distorted = radius;\n\n    // Background color\n    vec4 bg_color = 0.2 * vec4(1., 1., 1., 1.) * gridTexture(fragCoord.xy/iResolution.xx * vec2(5., 5.)) + 0.6;\n    // foreground color\n\tvec4 fg_color = vec4(1.0, 1.0, 1.0, 1.0);\n\n\t// Circle A\n\tfloat circle_normal = circle(uv, center, radius);\n    \n    // Distorted circle B\n    vec2 uvtex = fragCoord.xy/iResolution.xy;\n    radius_distorted += (texture(iChannel0, uvtex).r - 0.5) * iResolution.x * 0.05;\n    float circle_distorted = circle(uv, center, radius_distorted);\n    \n    float line = (sin(iTime * 2.) + 1.0) / 2.0;\n    // compare a and b\n    if(uvtex.x < line - 0.001) fragColor = vec4(mix(fg_color, bg_color, circle_normal));\n    if(uvtex.x > line + 0.001) fragColor = vec4(mix(fg_color, bg_color, circle_distorted));\n\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stl3DN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[84, 98, 130, 149, 412], [485, 529, 573, 573, 689], [691, 691, 748, 771, 1804]], "test": "error"}
{"id": "stl3z4", "name": "大龙猫 - Offworld Colony", "author": "totetmatt", "description": "So not 100% fidelity to the bonzomatic but close enough. Can find original glsl here :  https://github.com/totetmatt/shader_summary/blob/main/shader_file_sources/shadow_demoparty_2021/sender_shadow_totetmatt.glsl\n \n", "tags": ["jam", "demoparty"], "likes": 4, "viewed": 214, "published": "Public API", "date": "1621693784", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n/*\nShader done as a Jam for the Shadow Demoparty 2021.\n\nCheck the others : Evvvvil, z0rg, NuSan, ponk and lamogui that also participated and performed great compo !!!\n\nAlso thanks and cheers to the folks : evvvvil, flopine, psenough, FMS_cat, yx, cosamentale, blackle, antic0re, wrighter, rimina and all the other that I forgot :) \n*/\nvec4 texNoise(vec2 uv,sampler2D tex ){ float f = 0.; f+=texture(tex, uv*.125).r*.5; f+=texture(tex,uv*.25).r*.25; //Funciton simulating the perlin noise texture we have in Bonzomatic shader editor, written by yx\n                       f+=texture(tex,uv*.5).r*.125; f+=texture(tex,uv*1.).r*.125; f=pow(f,1.2);return vec4(f*.45+.05);}\nmat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\n#define fGlobalTime iTime\nfloat box(vec3 p,vec3 b){\n    vec3 q= abs(p)-b;\n    return length(max(vec3(0.),q))+min(0.,max(q.x,max(q.y,q.z)));\n}\nvec2 sdf(vec3 p){\n   vec3 op = p;\n   float bt = fract(iTime*.01); // This should be fftIntegrated\n  \n   p += vec3(6,3.,-0.0); // Offset the planet, to have some composition\n   p.xy *= rot(-.785); // Rotation of the planet, yes it's cheap trick and not correct but it works\n  \n  float tt = texNoise(vec2(atan(p.x,p.z),p.y)*.025+bt,iChannel2).r; // TexNoise to have the planet geology\n \n \n  float ttt = texture(iChannel1,fract(vec2(atan(p.x,p.z)+tt*6.+fGlobalTime))).r *.15; // Blyatiful\n/*                                ^----^           ^        ^       ^---- So the whole turns around the planet\n                                  ^                ^        ^------------ This will shift the line, with the noise texture, creating a nice effect\n                                  ^                ^--------------------- Spherical projection (as I phrase it, sorry if it's not correct)\n                                  ^-------------------------------------- This is not needed on bonzomatic as the fftTexture is wrapped repeat                        \n*/\n   tt = floor(tt*100.)/100.; // Create the stairs geology effect\n  \n  vec2 h;\n\n  h.x = length(p)-5.-tt; // That's a sphere with the displacement\n  h.y = 1.-(ttt); // Ok here is the dirty secret, When the fft pass a threshold, it will trigger later the glow\n  \n  vec2 t; // Boring stuff, that utlimately finished as a space Auror Borealis\n   \n  op.x -=2.;\n   op.z = mod(op.z,5.)-2.5;\n   op.y +=sin(op.z*5.+bt);\n   op.xy *=rot(fGlobalTime);\n   op.xz *=rot(floor(bt*20.)*1.33);\n  t.x = box(op,vec3(.9)); // Yeah, a cube as a start, was it necessary ? LOL.\n  t.y = 2.;\n  \n  h = t.x < h.x ? t:h;\n  \n  h.y = max(h.y,.1);\n  return h;\n  }\n  \n/* Normal Routine */\nvec2 nv=vec2(-.005,.005);\n#define q(s) s*sdf(p+s).x\nvec3 norm(vec3 p){return normalize(q(nv.xyy)+q(nv.yyx)+q(nv.yxy)+q(nv.xxx));}\n/* End Normal Routine */\n\n// Da Iq Palette color\nvec3 pal(float t){return .5+.5*cos(6.28*(1.*t+vec3(.0,.3,.7)));}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   \n   // The raymarch init\n   vec3 ro=vec3(.0,.0,-7.),rd=normalize(vec3(uv,1.)),rp=ro;\n   vec3 light = vec3(1.,2.,-3.);\n   \n   float bt = texture(iChannel1,vec2(.2)).r*.1; // did I mention I like to abuse texNoise and texFFT ? \n   float tt = texture(iChannel1,vec2(floor(abs(uv.x)*100.)/100.)).r*.01; // in a unreasonable manner ? \n   tt =sqrt(tt)*3.; \n  \n   vec3 col= vec3(tt)*pal(tt*1.); // The background\n  vec3 acc = vec3(0.); // The glow accumulator \n  \n  for(float i=0.;i<=69.;i++){ // LETS MARCH !\n      vec2 d = sdf(rp); // Get the dist\n      \n     if(d.y <=.92){ // Remember the texture trick ? Here we are \n     // This will accumulate only when fft is high enough, like most of us ?\n       acc += pal(d.y*1.2+fGlobalTime*.1)*max(0.,exp(10.*-abs(d.x))/(25.-d.y*20.))*exp(-abs(i/20.));\n       \n     } \n     if(d.y == 2.) { // The right auror borealis\n       \n        acc += vec3(.1,.8,.4)*max(0.,exp(1.*-abs(d.x))/(39.));\n        d.x  = max(0.1,abs(d.x));\n      }\n    \n      rp +=rd*d.x;\n      if(d.x <=.001){ // march to something\n           // Yolo  simple lighting \n           vec3 n = norm(rp);\n           float fre  = pow(1.-dot(-rd,n),5.);\n           if(d.y <=1.){ // only light the planet\n             col = fre*vec3(.1,.5,.8)+vec3(.3)*max(0.,dot(n,normalize(light-rp)));\n             break; // Don't forget to break \n           } \n        }\n    \n    }\n   \n  col+=acc; // add the glow\n  fragColor = vec4(col,1.0); // See you space cowboy\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "XlfSzf", "previewfilepath": "https://soundcloud.com/bubba-zen/07-track-7", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/bubba-zen/07-track-7", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stl3z4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 336, 374, 374, 668], [669, 669, 687, 687, 734], [761, 761, 786, 786, 876], [877, 877, 894, 894, 2560], [2637, 2637, 2655, 2655, 2714], [2741, 2764, 2782, 2782, 2828], [2831, 2831, 2888, 2938, 4453]], "test": "error"}
{"id": "stl3z8", "name": "Exp - Checkerboard", "author": "Andrew314", "description": "checkerboard pattern", "tags": ["experiment"], "likes": 2, "viewed": 132, "published": "Public API", "date": "1621557603", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n\n    // remove the trig funcs to get normal checkerboard\n    float k = sin(iTime)*10.;\n    float a = cos(iTime)*10.;\n    uv += vec2(cos(iTime), sin(iTime));\n    vec3 col = mix(vec3(0,0,0), vec3(1,1,1), step(1./a,mod(uv.x+ceil(uv.y*k)/k, 2./a)));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stl3z8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 508]], "test": "valid"}
{"id": "stlGDH", "name": "Colorful Mandelbulb", "author": "Zi7ar21", "description": "Just experimenting, check out https://www.shadertoy.com/view/fll3D8", "tags": ["raymarching", "fractal", "ray", "raymarch", "raymarched", "mandelbulb", "colorful", "color", "shadows", "raymarcher", "softshadows", "soft"], "likes": 4, "viewed": 191, "published": "Public API", "date": "1622041582", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ####### Colorful Mandelbulb #######\n// Made by Zi7ar21 on May 26th, 2021\n// Last Updated: May 26th, 2021 at 11:35 Mountain Standard Time\n\n// If you found this anywhere except Shadertoy, the original and possibly updated version can be found at:\n// https://www.shadertoy.com/view/stlGDH\n\n// Check out my friends!\n// michael0884\n// https://www.shadertoy.com/user/michael0884\n// loicvdb\n// https://www.shadertoy.com/user/loicvdb\n// Dumb Psycho\n// https://www.shadertoy.com/user/Dumb_Psycho\n\n// Inspired by \"Raymarched Mandelbulb\" by Dumb Psycho:\n// https://www.shadertoy.com/view/fll3D8\n\n// ##### PARAMETERS #####\n\n#define gamma   2.2\n#define camfov  1.0\n#define hitDist 1E-3\n#define maxDist 8.00\n#define maxStep 128\n\n#define iterations 6\n\n// ##### CONSTANTS #####\n\n// Traditional Input Names\n#define resolution iResolution\n#define time iTime\n\n// http://www.mimirgames.com/articles/programming/digits-of-pi-needed-for-floating-point-numbers/\n#define pi 3.1415926535897932384626433832795028841971693993751058209749445923078164\n\n// ##### RENDERING #####\n\n// Material Datatype\nstruct material {\n    vec3 albedo;\n    vec3 normal;\n};\n\n// Rotate a 3-Component Vector\nvec3 rotate(vec3 vec, vec3 rot)\n{\n    vec3 s = sin(rot), c = cos(rot);\n\n    mat3 rotx = mat3(\n    1.0, 0.0, 0.0,\n    0.0, c.x,-s.x,\n    0.0, s.x, c.x);\n    mat3 roty = mat3(\n    c.y, 0.0,-s.y,\n    0.0, 1.0, 0.0,\n    s.y, 0.0, c.y);\n    mat3 rotz = mat3(\n    c.z,-s.z, 0.0,\n    s.z, c.z, 0.0,\n    0.0, 0.0, 1.0);\n\n    mat3 rotmat = rotx*roty*rotz;\n\n    /*\n    rotmat[0] = normalize(rotmat[0]);\n    rotmat[1] = normalize(rotmat[1]);\n    rotmat[2] = normalize(rotmat[2]);\n    */\n\n    return (vec.x*rotmat[0])+(vec.y*rotmat[1])+(vec.z*rotmat[2]);\n}\n\n// Scene Distance Estimator\nfloat DE(in vec3 pos, out vec3 orbitTrap)\n{\n    // Performance Increase\n    if(dot(pos, pos) > 8.0)\n    {\n        return length(pos)-1.3;\n    }\n\n    pos = rotate(pos, pi*vec3(time*0.125*0.125, time*0.125, 0.0));\n\n    //const float power = 8.0;\n    float power = (sin(0.125*0.5*pi*time)*2.0)+8.0;\n\n    vec3 z = pos;\n    float dr = 1.0;\n    float r = 0.0;\n\n    orbitTrap = vec3(1.0);\n\n    for(int i = 0; i < iterations; i++)\n    {\n        r = length(z);\n\n        if(r > 4.0)\n        {\n            break;\n        }\n\n        // Convert to Polar Coordinates\n        float theta = acos(z.z/r)*power;\n        float phi = atan(z.y, z.x)*power;\n        dr = pow(r, power-1.0)*power*dr+1.0;\n\n        // Scale and Rotate the Point\n        float zr = pow(r, power);\n\n        // Convert back to Cartesian Coordinates\n        z = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\n        // Compute Orbit Trap Color\n        orbitTrap = min(orbitTrap, abs(z));\n\n        z += pos;\n    }\n\n    // Return the Distance to the Fractal\n    return 0.5*log(r)*r/dr;\n}\n\n// Distance Estimator Tetrahedron Numerical Normals\nvec3 getNormal(vec3 pos)\n{\n    const vec2 k = vec2(-1.0, 1.0);\n\n    vec3 n;\n\n    return normalize(\n    k.xxx*DE(pos+k.xxx*hitDist, n)+\n    k.xyy*DE(pos+k.xyy*hitDist, n)+\n    k.yxy*DE(pos+k.yxy*hitDist, n)+\n    k.yyx*DE(pos+k.yyx*hitDist, n));\n}\n\n// Distance Estimator Ray-Marching\nfloat intersectDE(in vec3 ro, in vec3 rd, out material materialProperties)\n{\n    // Set-Up Variables\n    float t = 0.0;\n\n    for(int i = 0; i < maxStep; i++)\n    {\n        if(t > maxDist)\n        {\n            break;\n        }\n\n        float td = DE(ro+rd*t, materialProperties.albedo);\n\n        if(td < hitDist)\n        {\n            materialProperties.normal = getNormal(ro+rd*t);\n            return t;\n        }\n\n        t += td;\n    }\n\n    // No Intersection\n    return -1.0;\n}\n\n// Intersection Function\nfloat intersect(in vec3 ro, in vec3 rd, out material materialProperties)\n{\n    // Compute the Intersection\n    float t = intersectDE(ro, rd, materialProperties);\n\n    // Return the Intersection\n    return t;\n}\n\n// Distance Estimator Soft Shadows\nfloat softShadow(vec3 ro, vec3 rd)\n{\n    float res = 1.0;\n    float t = 0.0;\n    float ph = 1E4;\n    vec3 n;\n    for(int i = 0; i < maxStep; i++)\n    {\n        float h = DE(ro+rd*t, n);\n        float y = i == 0 ? 0.0 : h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n\n        res = min(res, 10.0*d/max(0.0, t-y));\n\n        t += h;\n\n        if(res < hitDist || t > maxDist){break;}\n    }\n\n    res = clamp(res, 0.0, 1.0);\n\n    return res*res*(3.0-2.0*res);\n}\n\n// Rendering\nvec3 radiance(vec3 ro, vec3 rd)\n{\n    // Set-Up Variables\n    material materialProperties;\n\n    // Compute the Intersection\n    float t = intersect(ro, rd, materialProperties);\n\n    // If there was no Intersection\n    if(t < 0.0)\n    {\n        // Return Background Color\n        return (max(vec3(0.4, 0.8, 1.0)*dot(rd, vec3(0.0, 1.0, 0.0)), 0.0)*0.9)+0.1;\n    }\n\n    //vec3 lightPosition = vec3(sin(pi*time)*2.0, 4.0, (cos(pi*time)*2.0)-4.0);\n    const vec3 lightPosition = vec3(4.0, 4.0, -4.0);\n\n    // Direction of the Light\n    vec3 lightDirection = normalize(lightPosition-(ro+rd*t));\n\n    // Compute Lighting\n    float lighting0 = max(dot(materialProperties.normal, lightDirection), 0.0);\n    float lighting1 = max(dot(materialProperties.normal,-lightDirection), 0.0)*0.1;\n    float lighting = lighting0+lighting1+0.2;\n    lighting = mix(softShadow(ro+(rd*t)+(materialProperties.normal*hitDist), lightDirection)*lighting, lighting, 0.4);\n\n    // Return Final Result\n    return materialProperties.albedo*lighting;\n}\n\n// Render and Output the Frame\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Screen UV Coordinates\n    vec2 uv = 2.0*(gl_FragCoord.xy-0.5*resolution.xy)/max(resolution.x, resolution.y);\n\n    // Set-Up Variables\n    const vec3 ro = vec3(2.0, -1.0, -2.0);\n\n    /*\n    const mat3 rotmat = mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);\n    //rotmat[0] = normalize(rotmat[0]);\n    //rotmat[1] = normalize(rotmat[1]);\n    //rotmat[2] = normalize(rotmat[2]);\n    */\n\n    const vec3 camtarget = vec3(0.0);\n\n    // Calculate the Direction of the Ray\n    vec3 targetdir = normalize(camtarget-ro);\n    vec3 left = cross(targetdir, vec3(0.0, 1.0, 0.0));\n    vec3 up = cross(left, targetdir);\n    mat3 rotmat = mat3(left, up, targetdir);\n    vec3 rd = normalize(camfov*(uv.x*rotmat[0]+uv.y*rotmat[1])+rotmat[2]);\n\n    // Render the Frame\n    vec3 color = radiance(ro, rd);\n\n    // HDR Tonemapping\n    color = clamp(pow(color/(color+1.0), vec3(1.0/gamma)), 0.0, 1.0);\n\n    // Output the Rendered Frame\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stlGDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1130, 1161, 1194, 1194, 1705], [1707, 1735, 1778, 1806, 2792], [2794, 2846, 2872, 2872, 3091], [3093, 3128, 3204, 3228, 3609], [3611, 3636, 3710, 3742, 3845], [3847, 3882, 3918, 3918, 4337], [4339, 4352, 4385, 4409, 5371], [5373, 5404, 5459, 5488, 6418]], "test": "error"}
{"id": "stlGz2", "name": "Lorenz attractor for colours", "author": "codecontemplator", "description": "Just playing around with the formulas for the Lorenz attractor", "tags": ["lorenzattractor"], "likes": 2, "viewed": 66, "published": "Public", "date": "1622471791", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define CONST_A  10.0\n#define CONST_B  28.0\n#define CONST_C  (8.0/3.0)\n\n#define NUM_ITERATIONS 12\n#define DT 0.01\n\nvec3 f(in vec3 p, float a, float b, float c)\n{\n    for (int i = 0; i < NUM_ITERATIONS; i++ )\n    {\n        vec3 dp;\n        dp.x = a * (p.y - p.x);\n        dp.y = p.x * (b - p.z) - p.y;\n        dp.z = p.x * p.y - c * p.z;\n        p += DT * dp;\n    } \n    \n    return p;\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    \n    vec3 p = vec3(uv, 0.0) * 150.0;\n    p.z = 150.0 * sin(p.x*0.05+iTime) * cos(p.y * 0.05 + iTime * 0.5);\n    vec3 q = f(p, CONST_A + 5.0* sin(iTime + 0.4), CONST_B * sin(iTime-1.5), CONST_C * sin(iTime));\n    vec3 col = hsv2rgb(normalize(q));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stlGz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[115, 115, 161, 161, 386], [388, 388, 410, 410, 579], [582, 582, 609, 609, 752], [754, 754, 811, 811, 1151]], "test": "valid"}
{"id": "sts3RS", "name": "Checkerboard room (raymarch)", "author": "A_KouZ1", "description": "Something something a port of the python script that renders this room", "tags": ["raymarching", "pianomiles", "trigophers"], "likes": 1, "viewed": 35, "published": "Public API", "date": "1622353134", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 resolution;\nuniform float time;\n\n\nfloat box(vec3 p,vec3 r){return max(abs(p.x)-r.x,max(abs(p.y)-r.y,abs(p.z)-r.z));}\n\nfloat sdf(vec3 p){return min(\n    -box(p-vec3(0,0,-3),vec3(6,2,6)),min(\n        box(p-vec3(2.5,0,2),vec3(1,4,1)),min(\n            box(p-vec3(-2.5,0,0),vec3(1,4,1)),\n            box(p-vec3(2.5,0,-2),vec3(1,4,1))\n            )\n        )\n    );}\n\nvec3 nrm(vec3 p){ vec3 a = vec3(1e-4,0,0);\n    return normalize(vec3(sdf(p+a.xyz),sdf(p+a.yxz),sdf(p+a.yzx)));\n}\n\nfloat ray(vec3 p,vec3 v){float d=0.;\n    for(int i=0; i<64; i++)d+=sdf(p+v*d);\n    return d;\n}\n\nfloat lit(vec3 p,vec3 q){\n    vec3 v = normalize(q-p);\n    float  d = distance(p,q);\n    float  n = dot(nrm(q),-v);\n    float  r = ray(p,v);\n    float  w = distance(p+r*v,q);\n    return n*min(1.,(1./64.)/w/w)/(d*d+1.);\n}\n\nvec3 rot_xy(vec3 v,float r){\nreturn vec3(v.x*cos(r)-v.y*sin(r),v.x*sin(r)+v.y*cos(r),v.z);}\n\nvec3 rot_xz(vec3 v,float r){\nreturn rot_xy(v.xzy,r).xzy;}\n\nvec3 rot_yz(vec3 v,float r){\nreturn rot_xy(v.yzx,r).zyx;}\n\nvec3 ren(vec2 uv){\n    vec3 p = vec3(0,0,-4);\n    vec3 q = normalize(vec3(uv,1));\n    \n    p = p + vec3(0,0,3.*(1.-cos(iTime)));\n    q = rot_xz(q,iTime/2.);\n    \n    \n    float  d = ray(p,q);\n    vec3 r = p+q*d;\n    \n    vec3 f = floor((.5+r-2.*floor(r/2.+.25))+0.001)-0.5;\n    float  g = f.x+f.y+f.z;\n    float  t = 1.-.7*floor(g-2.*floor(g/2.));\n    float B = 4.*t*(lit(vec3(-3,0,-2),r)+0.01);\n    float A = 4.*t*(lit(vec3(-3,0, 2),r)+0.01);\n    return vec3(2.*A+B/12.,4.*A/3.+B/3.,A/24.+B);//1/d*t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 ra = vec2(iResolution.x/iResolution.y,1);\n    vec2 uv = 2.*fragCoord/iResolution.xy*ra-vec2(ra.x,1);\n    fragColor = vec4(sqrt(ren(1.5*uv)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sts3RS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[93, 93, 118, 118, 175], [177, 177, 195, 195, 419], [421, 421, 438, 438, 533], [535, 535, 560, 560, 629], [631, 631, 656, 656, 851], [853, 853, 881, 881, 944], [946, 946, 974, 974, 1003], [1005, 1005, 1033, 1033, 1062], [1064, 1064, 1082, 1082, 1568], [1570, 1570, 1626, 1626, 1783]], "test": "error"}
{"id": "sts3W4", "name": "Good Morning, Little Sparrow!", "author": "gunthern", "description": "2D noise pattern - fullscreen encouraged!", "tags": ["noisecolorful2d"], "likes": 1, "viewed": 72, "published": "Public", "date": "1622137466", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random (in vec2 _uv) {\n    return fract(sin(dot(_uv.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _uv) {\n    vec2 i = floor(_uv);\n    vec2 f = fract(_uv);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat circle(in vec2 uv, in float radius, in vec2 center) {\n    vec2 l = uv - center;\n    return 1.0 - smoothstep(radius - (radius * .05),\n                            radius + (radius * .05),\n                            dot(l,l) * 4.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0.0);\n\n    // Noise pattern with color\n    float pattern = noise(uv*10.-iTime);\n    pattern *= noise(uv*10. + iTime);\n    pattern = smoothstep(.3 * (abs(sin(iTime*.25))+.1),.3 * (abs(cos(iTime*.25))+.1),fract(pattern*2.));\n    col = vec3(pattern) * vec3(noise(uv*10. + ((abs(cos(iTime*.01))*300.)+100.)),noise(uv*10. * ((abs(sin(iTime))*10.)+200.)), noise(uv*10. - ((abs(sin(iTime*.01))*300.)+100.)));\n\n    // Circle 0\n    vec2 circle0UV = vec2(uv.x, uv.y / sin(uv.y*20.*cos(iTime*.9)));\n    float circle0 = circle(circle0UV / (noise(uv*200.)+0.53), 1.0*(abs(sin(iTime))+.5), vec2(0.));\n    col += circle0 * \n           vec3(1.0, 0.25, 0.1) * \n           clamp(ceil(0.0 - cos(iTime*.5)), 0.0, 1.0) *\n           clamp(abs(0.0 - cos(iTime*2.75)), 0.0, 1.0) * \n           clamp(ceil(0.0 - cos(iTime*1.75)), 0.0, 1.0);\n    \n    // Circle 1\n    vec2 circle1UV = vec2(sin(uv.x*20.*noise(uv*(sin(iTime*1.2)+cos(iTime*.9)))), 0.0);\n    float circle1 = circle(circle1UV / (noise(uv*200.)+0.53), 1.0, vec2(0.));\n    col += circle1 * \n           vec3(0.0, 0.25, 0.53*sin(iTime)) * \n           clamp(ceil(0.0 - cos(iTime*.5)), 0.0, 1.0) *\n           clamp(abs(0.0 - sin(iTime*2.35)), 0.0, 1.0);\n           \n    // Circle 2\n    vec2 circle2UV = vec2(cos(uv.x*100.*(noise(uv*(sin(iTime*0.2)+cos(iTime*.19)))+1.)), sin(uv.y*200.*noise(uv*(cos(iTime*1.2)+sin(iTime*.9)))+.1));\n    float circle2 = circle(circle2UV / (noise(uv*200.)+0.53), 1.0, vec2(0.));\n    col += circle2 * \n           vec3(0.0, 0.1, 0.0) * \n           clamp(ceil(cos(iTime*.5)), 0.0, 1.0) *\n           clamp(abs(0.0 - sin(iTime*1.35)), 0.0, 1.0);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sts3W4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 104], [106, 193, 220, 220, 739], [741, 741, 800, 800, 979], [981, 981, 1038, 1088, 2835]], "test": "valid"}
{"id": "sts3zn", "name": " Traveler 2 by Kaneta ", "author": "jorge2017a1", "description": " Traveler 2 by Kaneta ", "tags": ["traveler2bykaneta"], "likes": 3, "viewed": 72, "published": "Public", "date": "1621454358", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Traveler 2 by Kaneta\n\n#define TAU 6.283185307\n#define PI 3.141592654\n#define HALF_PI 1.5707963267948966\n#define U(z,w) (mix(z,w,step(w.x,z.x)))\n\n#define MAT_WING  1.0\n#define MAT_BODY  2.0\n#define MAT_STAGE 3.0\n\n#define saturate(x) (clamp(x, 0.0, 1.0))\n\n#define BPM (130.)\n\n\nconst int Iterations = 3;\n\nfloat orgBeat, beat, sceneBeat, kick, hihat, snare;\nfloat stageScale;\nfloat edgeOnly;\nvec3 fogColor;\nmat3 sphereRot, stageRot, stageRot2;\nvec3 ray;\nvec3 ro, ta, sp;\nvec3 cameraLight, stageLight, travelerLight;\nvec3 stageFlareCol, travelerFlareCol;\nfloat stageFlareIntensity, travelerFlareIntensity, stageFlareExp, travelerFlareExp;\nfloat shadeIntensity, glowIntensity, particleIntensity;\nfloat stageFold, stageRotateZ;\nfloat particle1Intensity, particle2Intensity;\nfloat switchTraveler;\nfloat glitchIntensity;\nvec3 glitchColor;\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sm(float start, float end, float t, float smo)\n{\n    return smoothstep(start, start + smo, t) - smoothstep(end - smo, end, t);\n}\n\nfloat sm2(float start, float end, float t, float bs, float es)\n{\n    return smoothstep(start, start + bs, t) - smoothstep(end - es, end, t);\n}\n\nvec3 hash3( vec3 p ){\n    vec3 q = vec3(dot(p,vec3(127.1,311.7, 114.5)), dot(p,vec3(269.5,183.3, 191.9)), dot(p,vec3(419.2,371.9, 514.1)));\n    return fract(sin(q)*43758.5453);\n}\n\nmat3 rotateMat(float roll, float pitch, float yaw)\n{\n    float cp = cos(pitch);\n    float sp = sin(pitch);\n    float sr = sin(roll);\n    float cr = cos(roll);\n    float sy = sin(yaw);\n    float cy = cos(yaw);\n\n    return mat3(cp * cy, (sr * sp * cy) - (cr * sy), (cr * sp * cy) + (sr * sy),\n                cp * sy, (sr * sp * sy) + (cr * cy), (cr * sp * sy) - (sr * cy),\n                -sp, sr * cp, cr * cp);\n}\n\nfloat stepUp(float t, float len, float smo)\n{\n    float tt = mod(t += smo, len);\n    float stp = floor(t / len) - 1.0;\n    return smoothstep(0.0, smo, tt) + stp;\n}\n\nfloat pingPong(float t, float len, float smo)\n{\n    t = mod(t + smo, len * 2.);\n    return 1.0 - (smoothstep(0., smo, t) - smoothstep(len, len + smo, t));\n}\n\nfloat glowTime(vec3 p)\n{\n    float t = mix(beat, beat - 45.0, step(44.0, beat));\n    t = mix(t, mod(beat - 53.0, 8.), step(108.0, beat));\n    t = mix(t, beat - 177.0, step(176.0, beat) * step(beat, 184.0));\n    t = mix(t, mod(beat - 177.0, 8.), step(184.0, beat) * step(beat, 224.0));\n    t = mix(t, -1.0, saturate(step(beat, 44.0) + (step(52.0, beat) * step(beat, 108.0)) + step(224.0, beat)));\n    return t;\n}\n\nfloat patternIntensity(vec3 p)\n{\n    float t = beat - 28.0;\n    if (t < 0.0) {\n        return 0.0;\n    }\n    t -= 2.5;\n    float len = distance(sp, p);\n    return sm(0.0, 2.5, mod(len - t * 1.5, 6.0), .5);\n}\n\nfloat sphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat de(vec3 p, mat3 rot, float scale) {\n    vec3 offset = vec3(1,1,1);\n\n    float freq = 64.0;\n    for (int i=0; i<Iterations; i++) {\n        if (i != 0) {\n            p*=rot;\n        }\n        p = abs(p);\n\n        // TODO: シーン4のタイミングとbeatが合わない場合はオフセット用意しよう\n        // 全->横->全->縦->前->縦->ループ\n        float b = mix(beat - 44., beat - 192.0, step(176.0, beat));\n        b = mix(b, 0.0, step(beat, 44.0));\n        b = mix(b, mod(beat, 8.0) + 64.0, step(108.0, beat) * step(beat, 176.0));\n        p.yx = mix(p.yx, p.xy, (1.0 - pingPong(b, freq * 0.25, 1.0)) * step(p.x, p.y));\n        p.xz = mix(p.xz, p.zx, (1.0 - pingPong(b, freq * 0.75, 1.0)) * step(p.x, p.z));\n        p.yz = mix(p.yz, p.zy, (1.0 - saturate(pingPong(mod(b, freq * 0.75), freq * 0.25, 1.0) - step(freq * 0.75 - 1.0, mod(b, freq*0.75)))) * step(p.y, p.z));\n\n        p.z -= 0.5*offset.z*(scale-1.)/scale;\n        p.z = -abs(-p.z);\n        p.z += 0.5*offset.z*(scale-1.)/scale;\n\n        p.xy = scale*p.xy - offset.xy*(scale-1.);\n        p.z = scale*p.z;\n    }\n\n    vec3 d = abs(p) - vec3(1.,1.,1.);\n    float distance = length(vec3(max(d, vec3(0.0))));\n    distance *= pow(scale, -float(Iterations));\n    \n    return distance;\n}\n\nmat2 rotate(in float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\n// https://www.shadertoy.com/view/Mlf3Wj\nvec2 foldRotate(in vec2 p, in float s) {\n    float a = PI / s - atan(p.x, p.y);\n    float n = TAU / s;\n    a = floor(a / n) * n;\n    p *= rotate(a);\n    return p;\n}\n\nvec2 distStage(vec3 p, mat3 rot, float scale)\n{\n    p.xy = (p.xy - 0.75) * rotate(p.z * stageRotateZ) + 0.75;\n    p.xy = foldRotate(p.xy - 0.75, stageFold) + 0.75;\n    p = mod(p, 1.5) - 0.75;\n    float d = de(p, rot, scale);\n    d = mix(d, 100., step(144.0, beat) * step(beat, 176.0));\n    return vec2(d, MAT_STAGE);\n}\n\nvec2 distSphere(vec3 p)\n{\n    float wing = sphere(p, 0.1);\n    float b1 = sdBox(p, vec3(10.0, 0.02, 10.0));\n    float b2 = sdBox(p, vec3(0.02, 10.0, 10.0));\n    float b3 = sdBox(p, vec3(10.0, 10.0, 0.02));\n    float s = sphere(p, 0.098);\n    wing = max(-b1, wing);\n    wing = max(-b2, wing);\n    wing = max(-b3, wing);\n    wing = max(-s, wing);\n\n    vec2 w = vec2(wing, MAT_WING);\n    vec2 body = vec2(sphere(p, 0.08), MAT_BODY);\n    return U(w, body);\n}\n\nmat2 rot(float x)\n{\n    return mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\n/*float ifs(vec3 p) {\n    p *= 15.;\n\tfor(int i = 0; i < 3; i++) {\n        p.xy *= rot(0.8 + .8*stepUp(beat + 1.0, 2.0, 0.5));\n        p.xz *= rot(0.4 + .4*stepUp(beat, 2.0, 0.5));\n\t\tp = abs(p);\n\t\tp = 2.0*p - 1.0;\n\t}\n\treturn sdBox(p, vec3(.9))*pow(2.0, -3.0) / 15.0;\n}*/\n\nvec2 distMetaBall(vec3 p)\n{\n    float s1 = sphere((p + vec3(sin(beat) * 0.1, sin(beat) * 0.1, 0.)), 0.05);\n    float s2 = sphere((p + vec3(0., sin(beat * 0.5) * 0.1, sin(beat * 0.5) * 0.1)) , 0.04);\n    float s3 = sphere((p + vec3(sin(beat * 0.25) * 0.1, 0., sin(beat * 0.25) * 0.1)), 0.03);\n    float d = smin(s3, smin(s1, s2, .1), .1);\n    return vec2(d, MAT_WING);\n}\n\nvec2 distTorus(vec3 p)\n{\n    mat3 m1 = rotateMat(beat * 0.1, beat, beat * 0.7);\n    mat3 m2 = rotateMat(beat, beat * 0.5, beat * 0.25);\n    mat3 m3 = rotateMat(beat * 0.3, beat, beat * 0.8);\n    float t1 = sdTorus(p * m1, vec2(0.1, 0.01));\n    float t2 = sdTorus(p * m2, vec2(0.08, 0.005));\n    float t3 = sdTorus(p * m3, vec2(0.06, 0.004));\n    return vec2(min(t3, min(t1, t2)), MAT_WING);\n}\n\nvec2 distBox(vec3 p)\n{\n    float i = sdBox(p, vec3(.06));\n    return vec2(i, MAT_WING);\n}\n\nvec2 distTraveler(vec3 p)\n{\n    return distSphere(p);\n}\n\nvec2 distTraveler2(vec3 p)\n{\n    vec2 d1 = distMetaBall(p);\n    vec2 d3 = distTorus(p);\n    vec2 d2 = distBox(p);\n    float s = mod(stepUp(beat, 6.0, 3.0), 3.0);\n    vec2 d = d1;\n    d.x = mix(d.x, d2.x, saturate(s));\n    d.x = mix(d.x, d3.x, saturate(s - 1.0));\n    d.x = mix(d.x, d1.x, saturate(s - 2.0));\n    return d;\n}\n\nvec2 distAll(vec3 p)\n{\n    vec2 st1 = distStage(p, stageRot, stageScale);\n    vec2 st2 = distStage(p, stageRot2 * stageRot, stageScale);\n    vec2 tr = distTraveler((p - sp) * sphereRot);\n    vec2 tr2 = distTraveler2((p - sp) * sphereRot);\n\n    vec2 trd = tr;\n    trd = mix(trd, tr2, step(0.75 + switchTraveler* 0.1, p.y));\n    trd.x = mix(trd.x, tr2.x, saturate(beat - 208.));\n    trd.x = mix(trd.x, tr.x, saturate(beat - 224.));\n    trd.x *= 0.9;\n\n    float visibleStage = step(176.0, beat) * step(max(beat - 177.0, 0.0) * 1.7, distance(p, sp));\n    st1.x = mix(st1.x, 100.0, visibleStage);\n    st2.x = mix(st2.x, 100.0, visibleStage);\n    return U(trd, U(st1, st2));\n}\n\nvec2 distGlow(vec3 p)\n{\n    vec2 st1 = distStage(p, stageRot, stageScale);\n    vec2 st2 = distStage(p, stageRot2 * stageRot, stageScale);\n\n    float gt = glowTime(p);\n\n    float frontSp = sphere(p - sp, gt + 1.);\n    float backSp = sphere(p - sp, gt);\n    float cut = max(frontSp, -backSp);\n    vec2 st = U(st1, st2);\n    st.x = max(st.x, cut);\n    return st;\n}\n\nfloat distCubeParticle(vec3 pos)\n{\n    pos.y -= beat * 0.25;\n    vec3 id = floor(pos / 1.);\n    pos = mod(pos, 1.) - 0.5;\n    vec3 rnd = hash3(id) * 2.0 - 1.0;\n    mat3 rot = rotateMat(rnd.x * beat * 2.0, rnd.y * beat * 2.0, rnd.z * beat * 2.0);\n    float d = sdBox((pos + rnd * 0.25) * rot, vec3(.025));\n    d = mix(d, .5, step(rnd.x, -0.7));\n    return d;\n}\n\nfloat distSphereParticle(vec3 pos)\n{\n    pos.y -= beat * 0.4;\n    vec3 id = floor(pos / 0.4);\n    pos = mod(pos, 0.4) - 0.2;\n    vec3 rnd = hash3(id) * 2.0 - 1.0;\n    mat3 rot = rotateMat(rnd.x * beat * 2.0, rnd.y * beat * 2.0, rnd.z * beat * 2.0);\n    float d = sphere((pos * rot + rnd * 0.1), 0.01);\n    d = mix(d, .1, step(rnd.x, 0.0));\n    return d;\n}\n\n/*\nvec3 normal(vec3 pos, float e)\n{\n    vec3 eps = vec3(e,0.0,0.0);\n\n    return normalize( vec3(\n           distAll(pos+eps.xyy).x - distAll(pos-eps.xyy).x,\n           distAll(pos+eps.yxy).x - distAll(pos-eps.yxy).x,\n           distAll(pos+eps.yyx).x - distAll(pos-eps.yyx).x ) );\n}\n*/\n\nvec3 normal( in vec3 pos, float eps )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*distAll( pos + e.xyy ).x +\n\t\t\t\t\t  e.yyx*distAll( pos + e.yyx ).x +\n\t\t\t\t\t  e.yxy*distAll( pos + e.yxy ).x +\n\t\t\t\t\t  e.xxx*distAll( pos + e.xxx ).x );\n    /*\n\tvec3 eps = vec3( 0.0005, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n\t*/\n}\n\nmat3 createCamera(vec3 ro, vec3 ta, float cr )\n{\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k)\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<8; i++ )\n    {\n        float h = distAll( ro + rd*t).x;\n        res = min( res, k*h/t );\n        t += clamp( h, 0.05, 0.2 );\n        if( res<0.001 || t>maxt ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat sdRect( vec2 p, vec2 b )\n{\n    vec2 d = abs(p) - b;\n    return min(max(d.x, d.y),0.0) + length(max(d,0.0));\n}\n\nfloat tex(vec2 p, float z)\n{\n    vec2 q = (fract(p / 10.0) - 0.5) * 10.0;\n    float d = 9999.0;\n    for (int i = 0; i < 3; ++i) {\n        q = abs(q) - 0.5;\n        q *= rot(0.785398);\n        q = abs(q) - 0.5;\n        q *= rot(z * 0.5);\n        float k = sdRect(q, vec2(1.0, 0.55 + q.x));\n        d = min(d, k);\n    }\n    float f = 1.0 / (1.0 + abs(d));\n    return pow(f, 16.0) + smoothstep(0.95, 1.0, f);\n}\n\nvec3 light(vec3 pos, vec3 normal, vec3 ray, vec3 col, vec3 lpos, vec3 diffuse, vec3 specular, float smoothness)\n{\n    vec3 lvec = normalize(lpos - pos);\n    vec3 hvec = normalize(lvec - ray);\n    float llen = length(lpos - pos);\n    vec3 diff = diffuse * col * (dot(normal, lvec) * 0.5 + 0.5)  * (1.0 / PI);\n\n    float bpnorm = ( smoothness + 2.0 ) / ( 2.0 * PI );\n    vec3 spec = specular * col * bpnorm * pow( max( 0.0, dot( normal, hvec ) ), smoothness );\n\n    return vec3(diff + spec) / (llen * llen);\n}\n\nvec3 shade(vec3 pos, vec3 normal, vec3 ray, vec3 diffuse, vec3 specular, float smoothness)\n{\n    vec3 col = light(pos, normal, ray, cameraLight * 2.0, ro, diffuse, specular, smoothness);\n    col += light(pos, normal, ray, stageLight, ro + vec3(0.0, 0.0, 2.0), diffuse, specular, smoothness);\n    return col;\n}\n\nvec3 rgb2hsv(vec3 hsv)\n{\n\tvec4 t = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(vec3(hsv.x) + t.xyz) * 6.0 - vec3(t.w));\n\treturn hsv.z * mix(vec3(t.x), clamp(p - vec3(t.x), 0.0, 1.0), hsv.y);\n}\n\nvec3 materialize(vec3 ro, vec3 ray, float depth, vec2 mat)\n{\n    vec3 pos = ro + ray * depth;\n    vec3 nor = normal(pos, 0.0025);\n    vec3 spLocalNormal = normalize((pos - sp) * sphereRot);\n    vec3 col = vec3(0.);\n\n    vec3 coord = mix(19.3602379925 * spLocalNormal, pos * 9.3602379925, step(MAT_BODY, mat.y));\n    vec3 pattern = vec3(tex(coord.zy, 113.09),  tex(coord.xz, 113.09),  tex(coord.xy, 113.09));\n\n    if (mat.y == MAT_WING) {\n        float wing_pattern = saturate(pattern.x + pattern.y + pattern.z);\n        vec3 cameraLightCol = light(pos, nor, ray, cameraLight * 2.0, ro, vec3(.1), vec3(.1), mix(5.0, 100.0, wing_pattern));\n        vec3 stageLightCol = light(pos, nor, ray, stageLight, ro + vec3(0.0, 0.0, 2.0), vec3(.1), vec3(.1), mix(5.0, 100.0, wing_pattern));\n        col += cameraLightCol + stageLightCol;\n\n        col += vec3(1.0, 0.25, 0.35) * 1.3 * wing_pattern * (cos(beat * 0.5) * 0.5 + 1.0);\n    } else if (mat.y == MAT_BODY) {\n        col += vec3(1.0, 0.25, 0.35) * 1. * saturate(cos(beat * 0.5) * 0.5 + 1.0);\n    } else if (mat.y == MAT_STAGE) {\n        vec3 lpos = ro + vec3(0.0, 0.0, 2.0);\n        vec3 lvec = normalize(lpos - pos);\n\n        vec3 cameraLightCol = light(pos, nor, ray, cameraLight * 2.0, ro, vec3(1.), vec3(1.), 25.);\n        vec3 stageLightCol = light(pos, nor, ray, stageLight, ro + vec3(0.0, 0.0, 2.0), vec3(1.), vec3(1.), 25.);\n        float sha = (softshadow(pos, lvec, 0.01, length(lpos - pos), 4.0) + mix(.2, .4, step(160.0, beat)));\n\n        // ステージが出現する演出\n        float noShade = 0.0;\n        noShade = step(distance(pos, sp), sceneBeat) * step(45.0, beat);\n\n        float wing_pattern = pow(saturate(pattern.x + pattern.y + pattern.z), 1.5) * 1.2;\n        col += ((cameraLightCol + stageLightCol * sha + light(pos, nor, ray, travelerLight, sp, vec3(1.), vec3(1.), mix(25., 100., step(176.0, beat)))) * edgeOnly * noShade + max(wing_pattern, 0.0) * (mix(vec3(0.1,0.2,0.4), rgb2hsv(vec3(pos.z * 1.0 + beat * 0.1, .85, 1.5)), step(160.0, beat))) * 4.0 * patternIntensity(pos)) * glowIntensity;\n    }\n\n    return mix(col, fogColor, pow(depth * 0.018, 2.1));\n}\n\nvec3 glowTrace(vec3 ro, vec3 ray, float maxDepth)\n{\n    float t = 0.0;\n    vec3 col = vec3(0.);\n    for (int i = 0; i < 16; i++) {\n        vec3 p = ro+ray*t;\n        float len = distance(sp, p);\n        float gt = glowTime(p);\n\n        // 光らせたくないときは-1.0を返してる\n        if (gt < 0.0) {\n            break;\n        }\n\n        vec3 h = hash3(floor(p * 30.0) / 30.0) * 2.0 - 1.0;\n        float val = 1.0 - sm(gt, gt + 2.0, len, .25);\n        // TODO: smでバラバラ感を制御しているが思った挙動じゃないので調査する\n        vec2 res = distGlow(p + h * 0.15 * val);\n        col += saturate(0.002 / res.x) * rgb2hsv(vec3(p.x * 1., 0.8, 1.0));\n        t += res.x;\n        if (maxDepth < t) {\n            break;\n        }\n    }\n    return col;\n}\n\n\nvec4 particleTrace(vec3 ro, vec3 ray, float maxDepth)\n{\n    float t = 0.0;\n    vec3 col = vec3(0.0);\n\tfor (int i = 0; i < 48; i++)\n\t{\n        vec3 p = ro+ray*t;\n        float d = distSphereParticle(p);\n        col += max(vec3(0.0), particle1Intensity / d * vec3(1.0, 0.5, 0.5));\n        t += d * 0.5;\n        if (maxDepth < t) {\n            break;\n        }\n\t}\n\treturn vec4(saturate(col), t);\n}\n\nvec4 particle2Trace(vec3 ro, vec3 ray, float maxDepth)\n{\n    float t = 0.0;\n    vec3 col = vec3(0.0);\n\tfor (int i = 0; i < 48; i++)\n\t{\n        vec3 p = ro+ray*t;\n        float d = distCubeParticle(p);\n        col += max(vec3(0.0), particle2Intensity / d * vec3(0.0, 0.5, 1.0));\n        t += d * 0.25;\n        if (maxDepth < t) {\n            break;\n        }\n\t}\n\treturn vec4(saturate(col), t);\n}\n\nvec4 trace(vec3 ro, vec3 ray)\n{\n    float t = 0.0;\n    float stepIntensity = 0.0;\n    vec2 res;\n    for (int i = 0; i < 80; i++) {\n        vec3 p = ro+ray*t;\n        res = distAll(p);\n        if( res.x < 0.0001 || t > 100.0) {\n            stepIntensity = float(i) / 64.0;\n            break;\n        }\n        t += res.x;\n    }\n    vec3 p = ro + ray * t;\n    float val = patternIntensity(p);\n    vec3 sg1 = pow(stepIntensity * 1.0, 5.0) * vec3(.2, .4, .8) * val * 5.;\n    vec3 sg2 = pow(stepIntensity * 1.0, 1.0) * vec3(1., 0., 0.) - pow(stepIntensity * 1.0, 2.0) * vec3(0., 1., 1.);\n    vec3 sg3 = pow(stepIntensity * 1.0, 1.0) * vec3(0., 0.5, .75);\n    float v = saturate((beat - 236.0) / 4.0);\n    float v2 = 1.0 - saturate((beat - 239.5) / 1.5);\n    float v3 = saturate((beat - 232.0) / 8.0);\n    return vec4(saturate(materialize(ro, ray, t, res) + sg1 * shadeIntensity - mix(vec3(0.), sg3 * 2.0 * v2, v3) + mix(vec3(0.), sg2 * 2.0 * v2, v)), t);\n}\n\nvoid initBeat(float b)\n{\n    sceneBeat = b;\n\n    kick = mod(sceneBeat, 1.);\n    hihat = sceneBeat < 16.0 ? 0.0 : pingPong(sceneBeat + 0.5, 1.0, 0.1) * 0.1;\n    snare = sceneBeat < 32.0 ? 0.0 : stepUp(sceneBeat - 32.5, 2.0, 0.5);\n}\n\nvec2 hash( vec2 p ){\n    p = vec2( dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3)));\n    return fract(sin(p)*43758.5453) * 2.0 - 1.0;\n}\n\nvec2 fbm_hash( vec2 x )\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( fbm_hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( fbm_hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( fbm_hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( fbm_hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat fbm(vec2 uv, float s)\n{\n    uv *= s;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f  = 0.5000*noise( uv ); uv = m*uv;\n\tf += 0.2500*noise( uv ); uv = m*uv;\n\tf += 0.1250*noise( uv ); uv = m*uv;\n\tf += 0.0625*noise( uv ); uv = m*uv;\n    return f * 0.5 + 0.5;\n}\n\nfloat quadraticInOut(float t) {\n  float p = 2.0 * t * t;\n  return t < 0.5 ? p : -p + (4.0 * t) - 1.0;\n}\n\nfloat elasticOut(float t) {\n\treturn sin(-13.0 * (t + 1.0) * HALF_PI) * pow(2.0, -10.0 * t) + 1.0;\n}\n\nfloat exponentialInOut(float t) {\n\treturn t == 0.0 || t == 1.0\n\t\t? t\n\t\t: t < 0.5\n\t\t? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n\t\t: -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\n\nfloat exponentialIn(float t) {\n\treturn t == 0.0 ? t : pow(2.0, 10.0 * (t - 1.0));\n}\n\nfloat exponentialOut(float t) {\n\treturn t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n\nvec3 scene(vec2 p)\n{\n    float cameraF = sin(beat * 0.25);\n    float scene0Beat = beat;\n    float scene1Beat = beat - 12.;\n    float scene2Beat = beat - 44.;\n    float scene3Beat = beat - 124.;\n    float scene4Beat = beat - 176.;\n\n    float cscene0to1 = step(12.0, beat);\n    float cscene1to2 = exponentialOut(saturate(beat - 44.));\n    float cscene2_1to2_2 = saturate((beat - 108.0) / 16.0);\n    cscene2_1to2_2 = quadraticInOut(cscene2_1to2_2 * cscene2_1to2_2);\n    float cscene3to4 = quadraticInOut(saturate((beat - 172.0) / 4.0));\n    float cscene3to4_2 = exponentialOut(saturate((beat - 176.0) / 1.0));\n\n    float scene2to3FadeOut = saturate((beat - 140.0) / 4.0 );\n\n    ////// Traveler //////\n    float toffset = max(0.0, beat - 239.5) * 0.7;\n    sp = mix(vec3(0.75, 0.75, mix(-20.0, 20.0, beat / 16.0)), vec3(0.75, 0.75, 0.2 + beat * 0.25 + toffset), cscene0to1);\n    //travelerInit(vec3(0.75, 0.75, 0.2 + beat * 0.25 + toffset));\n    //////////////////////\n\n    ////// Camera //////\n    vec3 scene0CameraPos = vec3(0.9, 0.8, 0.0);\n    vec3 scene1CameraPos = sp + vec3(sin(scene1Beat * 0.475) * 0.3 + cameraF * 0.05, .15 + cameraF * 0.05, cos(scene1Beat * 0.475) * 0.3 + cameraF * 0.05);\n    vec3 scene2CameraPos = sp + vec3(sin(scene2Beat * 0.2) * 0.15, cos(scene2Beat * 0.4) * 0.05 + 0.05, cos(scene2Beat * 0.15 + PI) * 0.05 - 0.2);\n    vec3 scene3CameraPos = sp + vec3(cos(scene1Beat * 0.25) * 0.7 + cameraF * 0.05, .15 + cameraF * 0.05, sin(scene1Beat * 0.25) * 0.5 + cameraF * 0.05);\n\n    float cb = scene1Beat - 4.0;\n    vec3 scene4CameraPos = sp + vec3(sin(cb * 0.2) * 0.15, cos(cb * 0.4) * 0.05 + 0.05, cos(cb * 0.15 + PI) * 0.05 - 0.2);\n\n    vec3 scene0CameraTarget = vec3(0.75, 0.75, 1.0);\n    vec3 scene1CameraTarget = sp;\n    vec3 scene2CameraTarget = sp + vec3(0.0, 0.0, (sin(scene2Beat * 0.05) * 0.5 + 0.5) * 3.0);\n    vec3 scene3CameraTarget = sp;\n    vec3 scene4CameraTarget = sp + vec3(0.0, 0.0, (sin(scene2Beat * 0.05) * 0.5 + 0.5) * 3.0);\n\n    float scene0CameraAngle = 0.0;\n    float scene1CameraAngle = sin(beat * 0.5) * 0.1;\n\n    float scene0CameraFov = 3.0;\n    float scene1CameraFov = 2.5;\n    float scene2_1CameraFov = 1.0;\n    float scene2_2CameraFov = 3.5;\n    float scene3_1CameraFov = 1.0;\n    float scene3_2CameraFov = 3.5;\n    float scene3_3CameraFov = 3.5;\n    float scene3_4CameraFov = 1.5;\n    float scene4CameraFov = 0.45;\n\n    vec2 rnd = hash(vec2(beat * 0.5)) * 0.05;\n    rnd *= saturate(max(0.0, 1.0 - distance(scene0CameraPos, sp) / 3.0) * (1.0 - cscene0to1) +\n                     saturate((beat - 234.0) / 6.0) * (1.0 - saturate(beat - 240.0)));\n\n    ro = mix(scene0CameraPos + vec3(rnd, 0.0), scene1CameraPos, cscene0to1);\n    ro = mix(ro, scene2CameraPos, cscene1to2);\n\n    // scene2 side camera\n    float cscene2to2_1 = exponentialInOut(saturate((beat - 61.0) / 4.0));\n    float cscene2to2_2 = exponentialInOut(saturate((beat - 65.0) / 9.0));\n    float cscene2to2_3 = exponentialInOut(saturate((beat - 67.0) / 8.0));\n    float cscene2to2_3_2 = exponentialInOut(saturate((beat - 67.0) / 12.0));\n    vec3 scene2_1SidePos = sp + mix(vec3(30.0, 1.0, -10.0), vec3(1.0, .0, 1.0), cscene2to2_1);\n    vec3 scene2_2SidePos = sp + mix(vec3(1.0, 0.0, 1.0), vec3(sin(-beat * 3. + 0.8) * 1.25, 0.0, cos(-beat * 3. + 0.8)), cscene2to2_2);\n    ro = mix(ro, scene2_1SidePos, cscene2to2_1);\n    ro = mix(ro, scene2_2SidePos, cscene2to2_2);\n    ro = mix(ro, scene2CameraPos, cscene2to2_3);\n    ////\n\n    // scene2 vertical camera\n    float cscene2to2_4 = exponentialInOut(saturate((beat - 96.0) / 4.0));\n    float cscene2to2_5 = exponentialInOut(saturate((beat - 100.0) / 8.0));\n    vec3 scene2VerticalPos = sp + mix(vec3(1.0, 30.0, -10.0), vec3(0.1, sin(-beat * 0.5) * 2., cos(-beat * 0.5)) * 2., cscene2to2_4);\n    ////\n\n    ro = mix(ro, scene2VerticalPos, cscene2to2_4);\n    ro = mix(ro, scene2CameraPos, cscene2to2_5);\n\n    ro = mix(ro, scene3CameraPos, cscene2_1to2_2);\n    ro = mix(ro, scene4CameraPos + vec3(rnd * 2.0, 0.0) - vec3(0., 0., toffset), cscene3to4);\n\n    ta = mix(scene0CameraTarget + vec3(rnd * 2.0, 0.0), scene1CameraTarget, cscene0to1);\n    ta = mix(ta, scene2CameraTarget, cscene1to2);\n\n    // scene2 side camera\n    ta = mix(ta, sp, cscene2to2_1);\n    ta = mix(ta, scene2CameraTarget, cscene2to2_3_2);\n    ////\n\n    // scene2 vertical camera\n    ta = mix(ta, sp, cscene2to2_4);\n    ta = mix(ta, scene2CameraTarget, cscene2to2_5);\n    ////\n\n    ta = mix(ta, scene3CameraTarget, cscene2_1to2_2);\n    ta = mix(ta, scene4CameraTarget + vec3(rnd, 0.0), cscene3to4_2);\n\n    float fov = mix(scene0CameraFov, scene1CameraFov, cscene0to1);\n    fov = mix(fov, scene2_1CameraFov, cscene1to2);\n\n    // scene2 vertical camera\n    fov = mix(fov, 1.0, cscene2to2_4);\n    fov = mix(fov, scene2_1CameraFov, cscene2to2_5);\n    ////\n\n    fov = mix(fov, scene2_2CameraFov, cscene2_1to2_2);\n\n    float scene2_2to3_1FovAnim = elasticOut(quadraticInOut(saturate((beat - 144.0) / 1.0)));\n    fov = mix(fov, scene3_1CameraFov, scene2_2to3_1FovAnim);\n\n    float scene3_1to3_2FovAnim = exponentialInOut(saturate((beat - 148.0) / 12.0));\n    fov = mix(fov, scene3_2CameraFov, scene3_1to3_2FovAnim);\n    fov = mix(fov, scene3_3CameraFov, cscene3to4);\n    fov = mix(fov, scene3_4CameraFov, cscene3to4);\n    fov = mix(fov, scene4CameraFov, cscene3to4_2);\n\n    float cameraAng = mix(scene0CameraAngle, scene1CameraAngle, cscene0to1);\n\n    mat3 cm = createCamera(ro, ta, cameraAng);\n    ray = cm * normalize(vec3(p, fov));\n    ////////////////////\n\n    ////// Fog //////\n    vec3 scene0Fog = vec3(0.0);\n    vec3 scene2Fog = vec3(8., 16., 32.);\n    vec3 scene3Fog = vec3(0.0);\n    vec3 scene4Fog = vec3(8., 16., 32.);\n\n    float scene0to1Fog = saturate((beat - 46.0) * 0.5);\n    float scene3to4Fog = saturate((beat - 184.0) * 0.5);\n    fogColor = mix(scene0Fog, scene2Fog, scene0to1Fog);\n    fogColor = mix(fogColor, scene3Fog, scene2to3FadeOut);\n    fogColor = mix(fogColor, scene4Fog, scene3to4Fog);\n    /////////////////\n\n    ////// Flare //////\n    float scene0StageFlareIntensity = 0.0;\n    float scene2StageFlareIntensity = 0.5;\n    float scene3StageFlareIntensity = 0.0;\n    float scene4StageFlareIntensity = 0.45;\n\n    float scene0StageFlareExp = 1.0;\n    float scene2StageFlareExp = 7.5;\n    float scene4StageFlareExp = 2.0;\n\n    float scene0TravelerFlareIntensity = max(0.2, cos(sceneBeat * 0.5) * 0.5 + 0.5);\n    float scene1TravelerFlareIntensity = max(0.2, cos(beat * 0.5) * 0.5 + 0.5);\n\n    float scene0TravelerFlareExp = mix(1.0, 800.0, distance(ro, sp) / 10.0);\n    float scene1TravelerFlareExp = 8.0;\n\n    stageFlareCol = vec3(.3, .6, 1.2);\n    travelerFlareCol = vec3(1., .25, .35);\n\n    float scene3to4Flare = saturate((beat - 176.0) / 4.0);\n\n    stageFlareIntensity = mix(scene0StageFlareIntensity, scene2StageFlareIntensity, scene0to1Fog);\n    stageFlareIntensity = mix(stageFlareIntensity, scene3StageFlareIntensity, scene2to3FadeOut);\n    stageFlareIntensity = mix(stageFlareIntensity, scene4StageFlareIntensity, scene3to4Flare);\n\n    stageFlareExp = mix(scene0StageFlareExp, scene2StageFlareExp, cscene0to1);\n    stageFlareExp = mix(stageFlareExp, scene4StageFlareExp, scene3to4Flare);\n\n    travelerFlareIntensity = mix(scene0TravelerFlareIntensity, scene1TravelerFlareIntensity, cscene0to1);\n\n    travelerFlareExp = mix(scene0TravelerFlareExp, scene1TravelerFlareExp, cscene0to1);\n    ///////////////////\n\n    ////// Light //////\n    vec3 scene0CameraLight = vec3(.005);\n    vec3 scene4CameraLight = vec3(0.04, 0.06, 0.08) * 0.2;\n\n    vec3 scene0StageLight = vec3(.0);\n    vec3 scene2StageLight = vec3(0.2, 0.4, 0.8);\n    vec3 scene3StageLight = vec3(0.);\n    vec3 scene4StageLight = vec3(0.4, 0.8, 1.6) * 2.;\n\n    cameraLight = mix(scene0CameraLight, scene4CameraLight, cscene3to4_2);\n\n    stageLight = mix(scene0StageLight, scene2StageLight, cscene1to2);\n    stageLight = mix(stageLight, scene3StageLight, scene2to3FadeOut);\n    stageLight = mix(stageLight, scene4StageLight, cscene3to4_2);\n    ///////////////////\n\n    ////// Edge //////\n    edgeOnly = mix(0.0, 1.0, cscene1to2);\n    //////////////////\n\n    ////// Particle //////\n    particleIntensity = mix(0.0, 1.0, saturate((beat - 145.0) * 10.0));\n\n    float particleAnim = saturate((beat - 145.0) / 4.0 );\n    particle1Intensity = mix(0.003, 0.0002, particleAnim);\n    particle2Intensity = mix(0.016, 0.0007, particleAnim);\n    //////////////////////\n\n    ////// Shade //////\n    shadeIntensity = mix(1.0, 0.0, scene2to3FadeOut);\n    shadeIntensity = mix(shadeIntensity, 1.0, cscene3to4);\n    ///////////////////\n\n    ////// Glow //////\n    glowIntensity = mix(1.0, 0.0, scene2to3FadeOut);\n    glowIntensity = mix(glowIntensity, 1.0, cscene3to4);\n    //////////////////\n\n    ////// Last Stage //////\n    stageFold = mix(1.0, stepUp(scene4Beat, 64. * 0.25, 1.0) * 4.0 + 5.0 + stepUp(max(0.0, beat - 244.0), 1.0, 0.2) * 10.0, cscene3to4_2);\n    stageRotateZ = mix(0.0, 1.0 - pingPong(scene4Beat, 64. * 0.25, 1.0), cscene3to4_2);\n    ////////////////////////\n\n    ////// Traveler Light //////\n    travelerLight = mix(vec3(.02, 0.004, 0.004) * 0.8, vec3(.02, .004, .004) * 1.5, cscene3to4_2);\n    ////////////////////////////\n\n    ////// Beat //////\n    float bb = mix(scene1Beat, scene2Beat, cscene1to2);\n    initBeat(bb);\n    /////////////////\n\n    ////// stage //////\n    stageScale = 3.4 - mix(0.00, 0.25, clamp(kick, 0.0, 1.0));\n    stageRot = rotateMat(0.1-hihat,-hihat, 0.4-hihat);\n    vec3 angle = mod(vec3(snare * 1.3, snare * 0.27, snare * 0.69), vec3(TAU) * 0.5);\n    stageRot2 = rotateMat(angle.x, angle.y, angle.z);\n    sphereRot = rotateMat(sin(beat * 0.5),cos(beat * 0.5), sin(beat * 0.5 * .33));\n    ///////////////////\n\n    vec4 c = trace(ro, ray);\n    c.rgb += glowTrace(ro, ray, c.w + 0.01) * glowIntensity;\n    vec4 p1 = particleTrace(ro, ray, c.w);\n    vec4 p2 = particle2Trace(ro, ray, c.w);\n    c.rgb += p1.rgb * particleIntensity;\n    c.rgb = mix(c.rgb + p2.rgb * particleIntensity, mix(p2.rgb, fogColor, pow(p2.w * 0.04, 2.1)), saturate(p2.g) * particleIntensity);\n    return c.rgb;\n}\n\nfloat Bokeh(vec2 p, vec2 sp, float size, float mi, float blur)\n{\n    float d = length(p - sp);\n    float c = smoothstep(size, size*(1.-blur), d);\n    c *= mix(mi, 1., smoothstep(size*.8, size, d));\n    return c;\n}\n\nvec3 dirt(vec2 uv, float n)\n{\n    vec2 p = fract(uv * n);\n    vec2 st = (floor(uv * n) + 0.5) / n;\n    vec2 rnd = hash(st);\n    float c = Bokeh(p, vec2(0.5, 0.5) + vec2(0.3) * rnd, 0.2, abs(rnd.y * 0.4) + 0.3, 0.25 + rnd.x * rnd.y * 0.2);\n    \n    return vec3(c) * exp(rnd.x * 4.0);\n}\n\nvec3 postProcess(vec2 uv, vec3 col)\n{   \n    uv *= 0.5;\n    \n    vec3 di = dirt(uv, 3.5);\n    di += dirt(uv - vec2(0.17), 3.0);\n    di += dirt(uv- vec2(0.41), 2.75);\n    di += dirt(uv- vec2(0.3), 2.5);\n    di += dirt(uv - vec2(0.47), 3.5);\n    di += dirt(uv- vec2(0.21), 4.0);\n    di += dirt(uv- vec2(0.6), 4.5);\n\n    float flare = pow(max(0.0, dot(vec3(0.0, 0.0, 1.0), ray)), stageFlareExp * 1.25);\n    float flare2 = pow(max(0.0, dot(vec3(0.0, 0.0, 1.0), ray)), stageFlareExp);\n    vec3 f = flare * stageFlareCol + flare2 * di * stageFlareCol * 0.05;\n    \n    float sflare = pow(max(0.0, dot(normalize(sp - ro), ray)), travelerFlareExp * 1.25);\n    float sflare2 = pow(max(0.0, dot(normalize(sp - ro), ray)), travelerFlareExp);\n    vec3 s = sflare * travelerFlareCol + sflare2 * di * travelerFlareCol * 0.05;\n    \n    return col + f * stageFlareIntensity + s * travelerFlareIntensity;\n}\n\nfloat triPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat Logo1(vec3 p)\n{\n    float d = 99999.9;\n    d = min(d, triPrism((p + vec3(2.75, -8.0, 0.0)) * vec3(0.76, 1.0, 1.0), vec2(11.45, 0.0)));\n    d = min(d, triPrism((p + vec3(-11.6, -13.8, 0.0)) * vec3(0.76, -1.0, 1.0), vec2(11.45, 0.0)));\n    d = min(d, triPrism((p + vec3(16.9, -13.8, 0.0)) * vec3(0.76, -1.0, 1.0), vec2(11.45, 0.0)));\n    return d;\n}\n\n\nfloat Logo2(vec3 p)\n{\n    float d = 99999.9;\n    d = min(d, triPrism((p + vec3(5.7, -10.05, 0.0)) * vec3(0.76, 1.0, 1.0), vec2(6.85, 0.0)));\n    d = min(d, triPrism((p + vec3(-17.0, -10.8, 0.0)) * vec3(0.76, -1.0, 1.0), vec2(8.45, 0.0)));\n    return d;\n}\n\nfloat gage(vec2 p)\n{\n    float d = 99999.9;\n    p.x += 2.8;\n    p.y += 0.1;\n    d = min(d, sdRect(p, vec2(14.0, 1.0)));\n\n    float t = clamp(iTime / 30.0 * 13.8, 0.0, 13.8);\n    p.x -= t;\n    d = max(d, -sdRect(p, vec2(13.8 - t, 0.8)));\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    float t = iTime - 30.;\n    orgBeat = t * BPM / 60.0;\n    \n    float b = orgBeat;\n    b = mix(b, 226.0 + mod(orgBeat * 2.0, 0.5), step(228.0, orgBeat) * step(orgBeat, 228.5));\n    b = mix(b, 229.0 + mod(orgBeat * 2.0, 0.5), step(231.0, orgBeat) * step(orgBeat, 231.5));\n    b = mix(b, 227.0 + mod(orgBeat * 2.0, 0.5), step(232.0, orgBeat) * step(orgBeat, 232.5));\n    b = mix(b, 238.3 + mod(orgBeat * 4.0, 1.0), step(238.0, orgBeat) * step(orgBeat, 244.0));\n    t = b * 60.0 / BPM;\n    \n    beat = (t + hash(p).x * 0.0065 * (1.0 - saturate((orgBeat - 230.0) / 4.0)) * step(12., orgBeat)) * BPM / 60.0;\n\n    switchTraveler = mix(2.0, -2.0, saturate(sm(126.0, 172.0, orgBeat, 8.0)));\n    glitchIntensity = step(44.0, orgBeat) * exp(-3.0 * max(0.0, orgBeat - 44.0)) +\n                                 step(144.0, orgBeat) * exp(-3.0 * max(0.0, orgBeat - 144.0)) +\n                                 step(176.0, orgBeat) * exp(-3.0 * max(0.0, orgBeat - 176.0)) +\n                                 step(228.0, orgBeat) * exp(-3.0 * max(0.0, orgBeat - 228.0)) +\n                                 step(231.0, orgBeat) * exp(-3.0 * max(0.0, orgBeat - 231.0)) +\n                                 step(232.0, orgBeat) * exp(-3.0 * max(0.0, orgBeat - 232.0)) +\n                                 sm2(234.0, 242.65, orgBeat, 4.0, 0.5);\n    glitchColor = vec3(1.0);\n\n\n    vec2 block = floor((p * vec2(100, 400.0)) / vec2(16));\n    vec2 uv_noise = block / vec2(64);\n    uv_noise += floor(vec2(t) * vec2(1234.0, 3543.0)) / vec2(64);\n\n    float block_thresh = pow(fract(t * 1236.0453), 2.0) * .5;\n    float line_thresh = pow(fract(t * 2236.0453), 3.0) * .6;\n\n    vec2 noise1 = hash(uv_noise) * 0.5 + 0.5;\n    vec2 noise2 = hash(vec2(uv_noise.y, 0.0)) * 0.5 + 0.5;\n\n    if  (noise1.r < block_thresh ||\n        noise2.g < line_thresh) {\n        float intensity = 1.0 - smoothstep(0.3, 1.0, length(p));\n        intensity *= sm(-0.4 + switchTraveler, 0.4 + switchTraveler, p.y, 0.1);\n        intensity = saturate(intensity + glitchIntensity);\n        vec2 dist = (fract(uv_noise) - 0.5) * intensity;\n        fragCoord.x -= dist.x * 350.1 * intensity;\n        fragCoord.y -= dist.y * 350.2 * intensity;\n        vec3 h = hash3(vec3(fract(uv_noise) - 0.5, 0.0)) * 2.0;\n        glitchColor = mix(vec3(1.0), h, intensity);\n    }\n\n    p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    float ttt = (orgBeat - 242.0) * 4.;\n    float val = min(150.0, mix(mix(mix(1.0, 5.0, saturate(exponentialIn(ttt))), 1.1, saturate(exponentialOut(ttt - 1.0))), 2000.0, saturate(exponentialIn(ttt - 2.0))));\n    val = mix(val, 2000.0, saturate(ttt - 3.00));\n    p.y *= val;\n    p.x *= mix(mix(1.0, 3.0, saturate(exponentialOut(ttt - 1.0))), 0.1, saturate(exponentialOut(ttt - 2.0)));\n\n    vec2 size = iResolution.xy / min(iResolution.x, iResolution.y);\n    vec2 pp = p + (vec2(fbm(vec2(beat * 0.1), 1.0), fbm(vec2(beat * 0.1 + 114.514), 1.0)) * 2.0 - 1.0) * .65;\n    vec3 col =  scene(pp) * glitchColor;\n\n    col = postProcess(p, col);\n    col = saturate(col);\n    \n    col = mix(col, 1.0 - col, step(228.0, orgBeat) * step(orgBeat, 228.5));\n    col = mix(col, 1.0 - col, step(231.0, orgBeat) * step(orgBeat, 231.5));\n    col = mix(col, 1.0 - col, step(232.0, orgBeat) * step(orgBeat, 232.5));\n    col = mix(col, 1.0 - col, step(242.0, orgBeat) * step(orgBeat, 244.0));\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 200.0;\n    vig = pow(vig, 0.1);\n    col = saturate(pow(col, vec3(1.0 / 2.2))) * vig;\n    col = mix(col, vec3(1.), saturate((beat - 251.0) / 4.0));\n    col = mix(col, vec3(0.), saturate((beat - 256.0) / 2.0));\n\n    vec2 ppp = p;\n    p *= 12.5 * 1.33333333;\n    p+= vec2(-1.55, 9.5);\n\n    float logo1 = 1.0 - smoothstep(0.0, 0.1, Logo1(vec3(p, 0.0)));\n    float logo2 = 1.0 - smoothstep(0.0, 0.1, Logo2(vec3(p, 0.0)));\n    float g = 1.0 - smoothstep(0.0, 0.1, gage(p));\n\n    col = mix(col, vec3(1.0), 1.0 - smoothstep(1.0, 1.5, t));\n    col = mix(col, vec3(0.23), logo1 * (1.0 - smoothstep(2.0, 3.3, t)));\n    col = mix(col, vec3(0.85, 0.35, 0.35), logo2 * (1.0 - smoothstep(2.0, 3.3, t)));\n    col = mix(col, vec3(0.85, 0.35, 0.35), g * (1.0 - smoothstep(1.0, 1.5, t)));\n\n    col = mix(col, vec3(1.), smoothstep(1.9, 2.0, ttt));\n    col = mix(col, vec3(0.), saturate(step(size.y, ppp.y) + step(ppp.y, -size.y) + step(size.x, ppp.x) + step(ppp.x, -size.x) + step(3.3, ttt)));\n\n    fragColor = vec4(col, 1.0);\n}\n\n\n\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sts3zn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[834, 834, 875, 875, 968], [970, 970, 1024, 1024, 1104], [1106, 1106, 1170, 1170, 1248], [1250, 1250, 1271, 1271, 1428], [1430, 1430, 1482, 1482, 1843], [1845, 1845, 1890, 1890, 2008], [2010, 2010, 2057, 2057, 2166], [2168, 2168, 2192, 2192, 2579], [2581, 2581, 2613, 2613, 2788], [2790, 2790, 2823, 2823, 2849], [2851, 2851, 2882, 2882, 2973], [2975, 2975, 3008, 3008, 3073], [3075, 3075, 3116, 3116, 4341], [4343, 4343, 4368, 4368, 4434], [4436, 4477, 4517, 4517, 4641], [4643, 4643, 4690, 4690, 4961], [4963, 4963, 4988, 4988, 5417], [5419, 5419, 5438, 5438, 5490], [5763, 5763, 5790, 5790, 6132], [6134, 6134, 6158, 6158, 6526], [6528, 6528, 6550, 6550, 6617], [6619, 6619, 6646, 6646, 6674], [6676, 6676, 6704, 6704, 6999], [7001, 7001, 7023, 7023, 7671], [7673, 7673, 7696, 7696, 8034], [8036, 8036, 8070, 8070, 8395], [8397, 8397, 8433, 8433, 8752], [9041, 9041, 9080, 9080, 9529], [9531, 9531, 9579, 9579, 9770], [9772, 9772, 9857, 9857, 10127], [10129, 10129, 10161, 10161, 10244], [10246, 10246, 10274, 10274, 10653], [10655, 10655, 10768, 10768, 11162], [11164, 11164, 11256, 11256, 11473], [11475, 11475, 11499, 11499, 11681], [11683, 11683, 11743, 11743, 13815], [13817, 13817, 13868, 13868, 14606], [14609, 14609, 14664, 14664, 15003], [15005, 15005, 15061, 15061, 15399], [15401, 15401, 15432, 15432, 16352], [16354, 16354, 16378, 16378, 16584], [16586, 16586, 16606, 16606, 16723], [16725, 16725, 16750, 16750, 16888], [16890, 16890, 16916, 16916, 17327], [17329, 17329, 17358, 17358, 17597], [17599, 17599, 17630, 17630, 17702], [17704, 17704, 17731, 17731, 17803], [17805, 17805, 17838, 17838, 17972], [17974, 17974, 18004, 18004, 18057], [18059, 18059, 18090, 18090, 18142], [18144, 18144, 18164, 18164, 28155], [28157, 28157, 28221, 28221, 28370], [28372, 28372, 28401, 28401, 28656], [28658, 28658, 28695, 28695, 29546], [29548, 29548, 29582, 29582, 29669], [29671, 29671, 29692, 29692, 30024], [30027, 30027, 30048, 30048, 30281], [30283, 30283, 30303, 30303, 30535], [30537, 30537, 30594, 30594, 35145]], "test": "valid"}
{"id": "stsGR7", "name": "sad face", "author": "jorge2017a1", "description": "sad face", "tags": ["2d"], "likes": 3, "viewed": 113, "published": "Public API", "date": "1621822928", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//por jorge2017a1 ----jorgeFloresP---23/may/2021\n// referencia \n//sad face\n\n////-------------------\n/// IQ funciones....librerias\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define S2(d,b) smoothstep(antialiasing(0.5),b,d)\n#define Sv(d,b,v) smoothstep(antialiasing(v),b,d)\n\n\n///----------Operacion de Distancia--------\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\n\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\n\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n//-------------------------------------------\n\nvec3 ponerBorde(vec3 pColObj, vec3 colOut, float distObj )\n{\n  colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj),0.0));\n  return colOut;\n}\n\n\nconst vec3 colNegro= vec3(0.0);\nconst vec3 colBlanco= vec3(1.0);\nconst vec3 colRojo= vec3(1.0,0.0,0.0);\nconst vec3 col0= vec3(0.49,0.93,0.29);\nconst vec3 col1= vec3(1.00,0.67,0.31);\nconst vec3 col2= vec3(1.00,0.72,0.67);\nconst vec3 col3= vec3(0.47,0.54,0.00);\nconst vec3 col4= vec3(0.71,0.65,1.00);\nconst vec3 col5= vec3(0.49,0.93,0.29);\nconst vec3 col6= vec3(1.00,0.69,0.34);\nconst vec3 col7= vec3(1.00,0.70,0.47);\nconst vec3 col8= vec3(0.47,0.53,0.00);\nconst vec3 col9= vec3(0.73,0.61,0.15);\nconst vec3 col10= vec3(1.00,0.67,0.31);\nconst vec3 col11= vec3(1.00,0.1,0.1);\nconst vec3 col12= vec3(0.2,0.82,0.42);\n\nfloat opU(float d1, float d2) {return min(d1, d2); }\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n//Uneven Capsule - exact   (https://www.shadertoy.com/view/4lcBWn)\n\nfloat sdUnevenCapsule( vec2 p, float r1, float r2, float h )\n{\n    p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdOrientedBox( in vec2 p, in vec2 a, in vec2 b, float th )\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n\n//***------------****-----------****------------******-------\nvec3 Rostro2d(in vec2 pp, vec3 col) \n{\n  vec2 p=pp;\n   float r1=0.6;float r2=0.8;float h=0.9; \n  float sdcabeza= sdUnevenCapsule( p, r1,  r2,  h );\n \n  \n  r1=0.15;r2=0.15;h=0.2;\n  float sdOjoIzq= sdUnevenCapsule( p-vec2(-0.25,0.7), r1,  r2,  h );\n  float sdOjoDer= sdUnevenCapsule( p-vec2(0.25,0.7), r1,  r2,  h );\n  \n  float sdOjoIzqR= sdUnevenCapsule( p-vec2(-0.25,0.7), r1,  r2,  h );\n  float sdOjoDerR= sdUnevenCapsule( p-vec2(0.25,0.7), r1,  r2,  h );\n  \n  \n  r1=0.05;r2=0.05;h=0.1;\n  float sdPupilaIzq= sdUnevenCapsule( p-vec2(-0.25,0.7), r1,  r2,  h );\n  float sdPupilaDer= sdUnevenCapsule( p-vec2(0.25,0.7), r1,  r2,  h );\n  \n  float sube=0.1*sin(iTime);\n  float sParpadoOjoIzq=sdOrientedBox(p,vec2(-0.3,0.8+sube), vec2(-0.2,0.4), 0.5 );\n  float sParpadoOjoDer=sdOrientedBox(p,vec2(0.3,0.85+sube), vec2(0.2,0.4), 0.5 );\n  \n  //parpado\n  sdOjoIzq =differenceSDF(sdOjoIzq,sParpadoOjoIzq);\n  sdOjoDer =differenceSDF(sdOjoDer,sParpadoOjoDer);\n  col=ponerBorde(col8,col,sdcabeza);\n  \n  //ojo  real\n  col=ponerBorde(colBlanco,col,sdOjoIzqR);\n  col=ponerBorde(colBlanco,col,sdOjoDerR);\n  //parpado\n  col=ponerBorde(col1,col,sdOjoIzq);\n  col=ponerBorde(col1,col,sdOjoDer);\n  \n  sdPupilaDer= differenceSDF(sdPupilaDer,  sdOjoDer);\n  sdPupilaIzq= differenceSDF(sdPupilaIzq,  sdOjoIzq);\n  \n  col=ponerBorde(colNegro,col,sdPupilaIzq);\n  col=ponerBorde(colNegro,col,sdPupilaDer);\n  \n  \n  //nariz\n  r1=0.12; r2=0.05; h=0.2; \n  float  snariz= sdUnevenCapsule(  p-vec2(0.0,0.2),  r1,  r2,  h );\n  col=ponerBorde(colRojo,col,snariz);\n  \n  \n  //Boca\n  r1=0.25; r2=0.05; h=0.3; \n  \n  float  sboca= sdCircle( p-vec2(0.0,0.0+sube), 0.3 );\n  float  sbocab= sdBox(p-vec2(0.0,0.2), vec2(0.32,0.3) );\n  sboca= differenceSDF(sboca,  sbocab);\n  \n  //dientes\n  float r1t=0.006; float r2t=0.05; float he=0.1;\n  float  sdienteA= sdTrapezoid( p-vec2(-0.1,-0.2), r1t, r2t, he );\n  sboca= differenceSDF(sboca,  sdienteA);\n  \n  col=ponerBorde(colBlanco,col,sdienteA);\n  col=ponerBorde(colNegro,col,sboca);\n  \n  \n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    vec2 p=uv*1.5;\n    vec3 col=colBlanco;\n     \n    col= Rostro2d(p-vec2(0.0,-0.3), col);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stsGR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[340, 384, 431, 431, 458], [460, 460, 503, 503, 530], [532, 532, 580, 580, 608], [656, 656, 716, 716, 842], [1457, 1457, 1488, 1488, 1509], [1510, 1510, 1535, 1535, 1554], [1555, 1555, 1580, 1580, 1599], [1600, 1600, 1636, 1636, 1664], [1734, 1734, 1796, 1796, 2035], [2037, 2037, 2089, 2089, 2208], [2210, 2210, 2247, 2247, 2327], [2329, 2329, 2395, 2395, 2612], [2614, 2614, 2649, 2649, 2677], [2679, 2679, 2744, 2744, 3054], [3057, 3119, 3157, 3157, 5120], [5122, 5122, 5179, 5179, 5400]], "test": "valid"}
{"id": "stsGzN", "name": "kd-house", "author": "sympou", "description": "well, it seems to work (for positive values),\nbut it's a bit complicated for raymarching.", "tags": ["kdtree"], "likes": 7, "viewed": 198, "published": "Public API", "date": "1621776593", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define iterations      3\n#define amplitude       0.7\n#define wallThickness   0.03\n#define doorSize        0.1\n\n//Dave_Hoskins's hash function\n//https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec4 kdCell( vec2 p, vec4 limits ) {\n\n    float seed  = floor(iTime*0.25   )*123.456 + 1.111;\n    float seed2 = floor(iTime*0.25+1.)*123.456 + 1.111;\n    float transition = fract(iTime*0.25);\n\n    int k = 1;\n    for (int i = 0; i < iterations; i++) {\n\n        int j = i % 2;\n\n        float r = mix( hash11(seed), hash11(seed2), transition);\n        \n        r = ( (r-0.5)*amplitude + 0.5 ) * (limits[j+2]-limits[j]) + limits[j];\n\n        int c = int(r>p[j]);\n\n        limits[j+c*2] = r;\n        \n        float add = float(k*c);\n        seed  += add;\n        seed2 += add;\n        \n        k += k;\n    }\n    return limits;\n}\n\nfloat sdHouse( in vec2 pos, in vec2 boxSize) {\n\n    //draw ext. corners\n    if ( abs(pos.x)>boxSize.x+wallThickness && abs(pos.y)>boxSize.y+wallThickness ) {\n        vec2 walls2 = abs(pos.xy)-boxSize.xy-wallThickness;\n        return length(walls2);\n    }\n    \n    // current cell coordinates (left up -- right down)\n    vec4 walls = vec4(-boxSize,boxSize);\n    \n    //we find the divided box we are in\n    vec4 cellWalls = kdCell(pos,walls);\n\n    // direction of closest wall (from outside)\n    vec2 w2 = abs(pos) - boxSize;\n    vec2 centerDir = sign(pos) * ( (w2.x>w2.y) ? vec2(1,0) : vec2(0,1));\n\n    //w : side of closest wall (0 to 3)\n    int w = int(centerDir.x + max(centerDir.y*2.0,0.0) + 1.);\n\n    //number of cells to check (1 or 4)\n    //if we are outside of the house, we only check one wall\n    int check = 1 + 3 * int( abs(pos.x)<boxSize.x && abs(pos.y)<boxSize.y );\n\n    float dist2 = 999999.9;\n\n    for (int i = 0; i<check; i++) { \n\n        int w2 = (i+w)%4;\n        int j = (w2+1)%2;\n        int k = 1-j;\n\n        vec2 normals = vec2(j * w2 - j, k * w2 - k * 2);\n\n        //distance from the wall\n        float wallDist = abs(cellWalls[w2]-pos[k]);\n\n        //a point on the other side of the wall\n        vec2 pos2 = pos + normals * ( 0.0001 + wallDist );\n\n        //walls from neighbour cell\n        vec4 cellWalls2 = kdCell(pos2,walls);\n\n        //we place the door on the segment\n        vec2 segment = vec2(max(cellWalls[j],cellWalls2[j]),min(cellWalls[j+2],cellWalls2[j+2]));\n        float center = (segment.x + segment.y)*0.5;\n        float len = abs(segment.x-segment.y)*0.5;\n        float centerDist = abs(center - pos[j]);\n        \n        //closest point\n        vec2 closest = vec2(doorSize - centerDist, wallDist - wallThickness);\n        \n        //adaptative doors (uncomment and remove condition)\n        //closest.x = min(closest.x, len - wallThickness - centerDist);\n\n        //condition : remove door if space is too small\n        closest.x *= float(len - wallThickness > doorSize);\n\n        closest = max(closest, vec2(0.0));\n\n        dist2 = min(dist2, dot( closest,closest ));\n\n    }\n    return sqrt(dist2);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 pos = uv*2.0-1.0;\n    pos.x *= iResolution.x/iResolution.y;\n    pos *= 0.75;\n    \n    //\n    \n    vec2 boxSize = vec2(1.0,0.5);\n\n    float dist = sdHouse(pos,boxSize)*2.;\n    \n    \n    //iq's distance color style\n    //https://www.shadertoy.com/view/3ltSW2\n    vec3 col = vec3(1.0) - sign(dist)*vec3(0.1,0.4,0.7);\n    col *= 1.0 - exp(-3.0*abs(dist));\n\tcol *= 0.8 + 0.2*cos(150.0*dist);\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(dist)) );\n    \n    //masking the inside\n    if (dist<0.0) { col = vec3(1.0); }\n    \n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stsGzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[112, 183, 206, 206, 291], [293, 293, 329, 329, 916], [918, 918, 964, 989, 3070], [3072, 3072, 3129, 3129, 3744]], "test": "valid"}
{"id": "stX3RB", "name": "Labyrinths of Sand", "author": "jarble", "description": "This fractal was generated using triangle waves.", "tags": ["fractal", "sand"], "likes": 7, "viewed": 175, "published": "Public API", "date": "1622300303", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ITERS 6\n\nvec2 triangle_wave(vec2 a){\n    return abs(fract((a/2.))-.5)*2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col=vec3(0.0),col_prev=vec3(0.0);\n    float t=0.0;\n    vec2 uv = (fragCoord*10.0-iResolution.xy)/iResolution.y/15.0;\n    uv += vec2((iTime)/30.0,iTime/70.0)*2.5;\n    for(int c=0;c<ITERS;c++){\n        float scale = 1.45;\n        float scale1 = 1.1;\n        float s1 = scale1*scale;\n        col_prev = col;\n        for(int i=0;i<ITERS;i++)\n        {\n            uv.x /= -scale1;\n            uv= triangle_wave(uv+((vec2(uv.x/scale-uv.y/scale1,uv.y/scale-uv.x/scale1)/(scale))))/scale1;\n            \n            uv = triangle_wave(uv.yx/s1)*s1;\n            uv.y *= scale1;\n        }\n        col[2] = abs((uv.y)-(uv.x));\n        col = ((col+col_prev.yzx));\n\t}\n    fragColor = vec4(vec3(col/float(ITERS)),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stX3RB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 44, 44, 84], [86, 86, 143, 143, 891]], "test": "valid"}
{"id": "stX3zS", "name": "Easy Voronoi Edges", "author": "oneshade", "description": "Detecting voronoi borders.", "tags": ["2d", "voronoi", "edgedetection", "edges"], "likes": 19, "viewed": 162, "published": "Public", "date": "1622494322", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 getPoint(in vec2 cell) {\n    return cell + 0.5 + 0.5 * vec2(sin(cell.x - cell.y + iTime), sin(cell.x) * cos(cell.x + cell.y * iTime));\n}\n\nfloat getId(in vec2 cell) {\n    return fract(sin(cell.x * 4647.543 + cell.y * 2435.32) * 9658.65);\n}\n\nfloat voronoi(in vec2 pixel) {\n    vec2 uv = (pixel - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    vec2 cell = floor(uv);\n\n    float minDist = 1e20;\n    float id = 0.0;\n    for (int i=-1; i < 2; i++) {\n        for (int j=-1; j < 2; j++) {\n            vec2 curCell = cell + vec2(i, j);\n            float curDist = length(uv - getPoint(curCell));\n            if (curDist < minDist) {\n                id = getId(curCell);\n                minDist = curDist;\n            }\n        }\n    }\n\n    return id;\n}\n\nvec4 render(in vec2 px) {\n    float dx = (voronoi(px + vec2(1.0, 0.0)) - voronoi(px - vec2(1.0, 0.0)));\n    float dy = (voronoi(px + vec2(0.0, 1.0)) - voronoi(px - vec2(0.0, 1.0)));\n    return vec4(abs(dx) + abs(dy) > 0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = (render(fragCoord                 ) +\n                 render(fragCoord + vec2(0.5, 0.0)) +\n                 render(fragCoord + vec2(0.0, 0.5)) +\n                 render(fragCoord + vec2(0.5, 0.5))) / 4.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stX3zS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 141], [143, 143, 170, 170, 243], [245, 245, 275, 275, 750], [752, 752, 777, 777, 977], [979, 979, 1034, 1034, 1258]], "test": "error"}
{"id": "stXGRS", "name": "Fibrous ring", "author": "avin", "description": "visual experiment", "tags": ["noise", "lines"], "likes": 9, "viewed": 248, "published": "Public API", "date": "1622292842", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926 \n#define PI2 6.2831852 \n \n#define SF 1./min(iResolution.x,iResolution.y)\n#define SS(l,s) smoothstep(SF,-SF,l-s)\n\n#define MOD3 vec3(.1031, .11369, .13787)\n\nvec3 hash33(vec3 p3)\n{\n    p3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz + 19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y, (p3.y + p3.z) * p3.x));\n}\n\nfloat snoise(vec3 p)\n{\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n\n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n\n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n    vec3 i1 = e * (1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy * (1.0 - e);\n\n    vec3 d1 = d0 - (i1 - 1.0 * K2);\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\n\n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\n\n    return dot(vec4(31.316), n);\n}\n \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{     \n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n          \n    float l = length(uv);\n    \n    float result = 0.;\n    \n    for(float i=0.; i<30.; i+=1.){\n        float zn = .25 + i*.005 + snoise(vec3(uv*i*.5, 10. + iTime*.25))*i*.005;\n        float d = SS(l, zn) * SS(zn, l);\n        result += d;\n    }\n    \n\n    fragColor = vec4(vec3(result), 1.0);\n} \n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stXGRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[176, 176, 198, 198, 365], [367, 367, 389, 389, 1035], [1038, 1038, 1093, 1093, 1467]], "test": "valid"}
{"id": "tdV3RK", "name": "twisting spiral spheres", "author": "atlasxatlas", "description": "twisting spiral spheres rotating with changing colors.\n\n", "tags": ["spiralspheres"], "likes": 2, "viewed": 56, "published": "Public", "date": "1622142890", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float dCircle(vec2 uv, vec2 p, float r){\n    return length(uv-p)-r;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-(iResolution.xy*.5))/iResolution.y;\n    vec2 mPos = (iMouse.xy-(iResolution.xy*.5))/iResolution.y;\n    \n    vec3 col = vec3(0);\n    \n    vec2 p = vec2(0);\n    float f = 100.;\n    float r = .015;\n    float ms = iTime+200.;\n    float n = 200.;\n    vec3 vCol = sin(ms*vec3(1.72345623,1.32634234,1.736474))*.5+.51;\n    vCol *= 10.;\n    for(float i=1.; i<=n; i++){\n        float rf = ms*i/n;\n    \tp += vec2(sin(rf),cos(rf))*i/f;\n    \t\n    \tfloat d = dCircle(uv,p,r*rf*.1);\n    \t\n    \td = smoothstep(0.001, 0., d);\n        d*=(1.-i/n)*(1.-i/n)*(1.-i/n)*(1.-i/n)*(1.-i/n)*(1.-i/n)*(1.-i/n);\n        col += vCol*d*i/n;\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdV3RK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 69], [73, 73, 130, 130, 834]], "test": "valid"}
{"id": "tl3BWX", "name": "bw circle", "author": "rrrzzz", "description": "half", "tags": ["half"], "likes": 1, "viewed": 40, "published": "Public", "date": "1620491616", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rectangle(vec2 c, vec2 wh, vec2 uv)\n{\n    uv -= c;    \n    vec2 res = step(-wh / 2.0, uv) * (1.0 - step(wh / 2.0, uv));\n    return res.x * res.y;\n}\n\nfloat circle(vec2 c, float r, vec2 uv)\n{  \n    return smoothstep(r + 0.01, r, length(uv));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n \n    float aspect = iResolution.x / iResolution.y; \n    uv.x *= aspect; \n    \n    float width = (smoothstep(0., 1.,abs(sin(iTime / 10.))) + 0.2) * 0.05;\n    float wStep = width / 3.;\n    \n    vec3 col = vec3(.0);\n    \n\n    vec2 center = vec2(.5 * aspect, .5);\n    uv = abs(uv) - center;\n    \n    for(float r = mod(iTime / 4., 2.) + 2.; r >= 0.; r -= width)\n    {    \n        float cir = circle(center, r, uv); \n\n        float blackAmount = (width - 0.01) * abs(sin(iTime * 3.0));\n        float div = 1.0 / (width - blackAmount);\n        float len = (length(uv) - (r - (width - blackAmount))) * div;\n        vec3 rimColor = vec3(len);\n        col = mix(col, rimColor, cir); \n    }    \n    \n    fragColor = vec4(col, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl3BWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 43, 43, 153], [155, 155, 195, 195, 247], [249, 249, 304, 304, 1083]], "test": "valid"}
{"id": "tlVcDR", "name": "Underwater (Pool)", "author": "oneshade", "description": "Look around with the mouse.", "tags": ["voronoi", "refraction", "water", "caustic", "pool"], "likes": 12, "viewed": 107, "published": "Public", "date": "1622088088", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct Surface {\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float gloss;\n    float dist;\n    bool iswater;\n};\n\nSurface opUnion(in Surface surf1, in Surface surf2) {\n    Surface surfUnion = surf1;\n    if (surf2.dist < surf1.dist) {\n        surfUnion = surf2;\n    }\n\n    return surfUnion;\n}\n\nSurface opInter(in Surface surf1, in Surface surf2) {\n    Surface surfInter = surf1;\n    if (surf2.dist > surf1.dist) {\n        surfInter = surf2;\n    }\n\n    return surfInter;\n}\n\nSurface opSub(in Surface surf1, in Surface surf2) {\n    return opInter(surf1, Surface(surf2.ambient, surf2.diffuse, surf2.specular, surf2.gloss, -surf2.dist, surf2.iswater));\n}\n\nmat2 Rotate(in float r) {\n    float c = cos(r), s = sin(r);\n    return mat2(c, -s, s, c);\n}\n\n// Hash from \"Hash without Sine\" by Dave_Hoskins (https://www.shadertoy.com/view/4djSRW):\n// I modified it to try avoiding some annoying symmetry hash13() appears to have on the xy plane.\nfloat noise(in vec3 p) {\n\tp = fract(p * 0.731 - p.x * 253.567);\n    p += dot(p + p, p.yzx + 33.33);\n    return fract((p.x + p.y) * p.z);\n}\n\nfloat snoise(in vec3 p) {\n    vec3 cell = floor(p);\n    vec3 local = fract(p);\n    local *= local * (3.0 - 2.0 * local);\n\n    float ldb = noise(cell);                       // Left, Down, Back\n    float rdb = noise(cell + vec3(1.0, 0.0, 0.0)); // Right, Down, Back\n    float ldf = noise(cell + vec3(0.0, 0.0, 1.0)); // Left, Down, Front\n    float rdf = noise(cell + vec3(1.0, 0.0, 1.0)); // Right, Down, Front\n    float lub = noise(cell + vec3(0.0, 1.0, 0.0)); // Left, Up, Back\n    float rub = noise(cell + vec3(1.0, 1.0, 0.0)); // Right, Up, Back\n    float luf = noise(cell + vec3(0.0, 1.0, 1.0)); // Left, Up, Front\n    float ruf = noise(cell + 1.0);                 // Right, Up, Front\n\n    return mix(mix(mix(ldb, rdb, local.x),\n                   mix(ldf, rdf, local.x),\n                   local.z),\n\n               mix(mix(lub, rub, local.x),\n                   mix(luf, ruf, local.x),\n                   local.z),\n\n               local.y);\n}\n\nfloat fnoise(in vec3 p, in float scale, in float octaves) {\n    p *= scale;\n\n    float value = 0.0;\n    float nscale = 1.0;\n    float tscale = 0.0;\n\n    for (float octave=0.0; octave < octaves; octave++) {\n        value += snoise(p) * nscale;\n        tscale += nscale;\n        nscale *= 0.5;\n        p *= 2.0;\n    }\n\n    return value / tscale;\n}\n\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\nfloat smin(in float a, in float b, in float s) {\n    float i = clamp(0.5 + 0.5 * (b - a) / s, 0.0, 1.0);\n    return mix(b, a, i) - s * i * (1.0 - i);\n}\n\nvec2 getCellPoint(in vec2 p) {\n    float rndx = Hash11(p.x + 1000.0) * 2.0, rndy = Hash11(p.y + 1000.0) * 2.0;\n    return 0.5 + 0.5 * vec2(sin(p.x * rndx + p.y * rndy + iTime * rndx), cos(p.y * rndx - p.x * rndy + 2.0 * iTime * rndy * rndx));\n}\n\nfloat voronoi(in vec2 uv) {\n    vec2 cellLocation = floor(uv);\n\n    float minDist = 1000000000.0;\n    for (int i=-1; i < 2; i++) {\n        for (int j=-1; j < 2; j++) {\n            vec2 curCellLocation = cellLocation + vec2(i, j);\n            vec2 curCellPoint = curCellLocation + getCellPoint(curCellLocation);\n            minDist = smin(minDist, length(uv - curCellPoint), 0.1);\n        }\n    }\n\n    return minDist;\n}\n\nfloat fakeCaustic(in vec2 uv) {\n    float color = voronoi(uv);\n    color *= color * color;\n    return color;\n}\n\nSurface mapScene(in vec3 p) {\n    p.z -= iTime;\n\n    Surface sphere = Surface(vec3(0.0), vec3(1.0, vec2(0.0)), vec3(1.0), 8.0, 1000000.0, false);\n\n    float waterDisp = fnoise(vec3(p.xz, 0.25 * iTime), 1.0, 3.0);\n    Surface water = Surface(vec3(0.0), vec3(0.0), vec3(1.0), 128.0, waterDisp - p.y, true);\n\n    vec3 groundCol = vec3(1.0);\n    groundCol -= smoothstep(0.02, 0.0, abs(mod(p.x, 1.0) - 0.5) - 0.025) * 0.5;\n    groundCol -= smoothstep(0.02, 0.0, abs(mod(p.z, 1.0) - 0.5) - 0.025) * 0.5;\n    groundCol += fakeCaustic(p.xz * 0.75);\n    Surface ground = Surface(groundCol, vec3(0.0), vec3(0.0), 0.0, p.y + 4.0, false);\n\n    return opUnion(sphere, opUnion(water, ground));\n}\n\nvec3 getNormal(in vec3 p) {\n    vec3 e = vec3(0.01, 0.0, 0.0);\n    return normalize(vec3(mapScene(p + e.xyy).dist - mapScene(p - e.xyy).dist,\n                          mapScene(p + e.yxy).dist - mapScene(p - e.yxy).dist,\n                          mapScene(p + e.yyx).dist - mapScene(p - e.yyx).dist));\n}\n\nvec3 applyFog(in vec3 color, in float dist) {\n    return mix(color, vec3(0.25, 0.25, 1.0), 1.0 - exp(-dist * 0.15)) / max(1.0, 0.125 * dist);\n}\n\nvec3 getSky(in vec3 ro, in vec3 rd) {\n    if (rd.y > 0.1) {\n        vec2 uv = ro.xz + (5.0 - ro.y) / rd.y * rd.xz;\n        float clouds = fnoise(vec3(uv, 0.0) + iTime, 0.3, 5.0);\n        return mix(vec3(0.5, 0.5, 1.0), vec3(1.0), clouds * clouds * 1.5);\n    }\n\n    return vec3(0.25, 0.25, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenCenter = 0.5 * iResolution.xy;\n\n    vec2 uv = (fragCoord - screenCenter) / iResolution.y;\n    vec2 mouse = (iMouse.xy - screenCenter) / iResolution.y * 3.14;\n    mouse.y *= -1.0;\n\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, -2.0, 5.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n\n    // Mouse control\n    float cx = cos(mouse.y), sx = sin(mouse.y);\n    rd.yz *= mat2(cx, sx, -sx, cx);\n\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    bool hitSky = true, hitWater = false, missed = false;\n    float t = 0.0;\n    for (int i=0; i < 100; i++) {\n        vec3 p = ro + rd * t; p.z *= 1.0;\n        Surface scene = mapScene(p);\n        if (scene.dist < 0.001 * (t * 5.0 + 1.0)) {\n            vec3 n = getNormal(p);\n            vec3 l = normalize(vec3(-1.0, 1.0, 1.0));\n            vec3 r = reflect(l, n);\n\n            if (!scene.iswater) {\n                fragColor.rgb = scene.ambient;\n                float lambert = max(0.0, dot(n, l));\n                fragColor.rgb += scene.diffuse * lambert;\n                if (lambert > 0.0) {\n                    fragColor.rgb += scene.specular * min(1.0, pow(max(0.0, dot(r, rd)), scene.gloss));\n                }\n\n                fragColor.rgb = applyFog(fragColor.rgb, t);\n\n                hitSky = false;\n                break;\n            }\n\n            if (scene.iswater) {\n                fragColor.rgb = scene.ambient;\n                if (dot(-n, l) > 0.0) {\n                    fragColor.rgb += scene.specular * min(1.0, pow(max(0.0, dot(-r, rd)), scene.gloss));\n                }\n\n                rd = refract(rd, n, 1.003 / 1.333);\n                hitWater = true;\n            }\n\n            break;\n        }\n\n        if (t > 100.0) {\n            fragColor.rgb = vec3(0.0);\n            missed = true;\n            break;\n        }\n\n        t += scene.dist;\n    }\n\n    if (hitSky && !missed) {\n        fragColor.rgb += getSky(ro, rd);\n        if (hitWater) {\n            fragColor.rgb = applyFog(fragColor.rgb, t);\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlVcDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[127, 127, 180, 180, 304], [306, 306, 359, 359, 483], [485, 485, 536, 536, 661], [663, 663, 688, 688, 754], [756, 944, 968, 968, 1082], [1084, 1084, 1109, 1109, 2033], [2035, 2035, 2094, 2094, 2380], [2382, 2382, 2408, 2408, 2494], [2496, 2496, 2544, 2544, 2647], [2649, 2649, 2679, 2679, 2893], [2895, 2895, 2922, 2922, 3313], [3315, 3315, 3346, 3346, 3425], [3427, 3427, 3456, 3456, 4108], [4110, 4110, 4137, 4137, 4413], [4415, 4415, 4460, 4460, 4558], [4560, 4560, 4597, 4597, 4856], [4858, 4858, 4913, 4913, 6966]], "test": "valid"}
{"id": "ttyBz1", "name": "planet01", "author": "cody_shader", "description": "реймарчинг", "tags": ["raymarching"], "likes": 3, "viewed": 158, "published": "Public API", "date": "1621025647", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ITERATION 500\n#define MAX_DIST 10.\n#define EX vec3(0.001, 0., 0.)\n#define EY vec3(0., 0.001, 0.)\n#define EZ vec3(0., 0., 0.001)\n#define w iResolution.x\n#define h iResolution.y\n\n// Author @patriciogv - 2015\n// http://patriciogonzalezvivo.com\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nfloat random (vec2 st) {\n    \n    return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return fract(abs(sin(st)*43758.5453123));\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 4\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .6;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\n\nfloat dist(vec3 a, vec3 b) { //Считает расстояние между точками в трехмерном пространстве\n\treturn sqrt(pow(a.x - b.x, 2.) + pow(a.y - b.y, 2.) + pow(a.z - b.z, 2.));\n}\n\nvec3 normalize(vec3 a) { //Нормализует вектор\n    float l = dist(a, vec3(0.,0.,0.));\n    return vec3(a.x / l, a.y / l, a.z / l);\n}\n\nvec3 sum(vec3 a, vec3 b) { //Суммирует вектора\n\treturn vec3(a.x + b.x, a.y + b.y, a.z + b.z);\n}\n\nvec3 sub(vec3 a, vec3 b) { //Вычитает вектора\n\treturn vec3(a.x - b.x, a.y - b.y, a.z - b.z);\n}\n\nvec3 mul(vec3 a, float value) { //Умножает вектор на значение\n\treturn vec3(a.x * value, a.y * value, a.z * value);\n}\n\nfloat smin(float a, float b, float k) {\n\tfloat m = max(min(0.5 + 0.5 * (b - a) / k, 1.), 0.);\n\treturn a * m + b * (1. - m) - k * m * (1. - m);\n}\n\n\n\n\nfloat getDistdotsentra(vec3 p) { //ПОЛУЧИТЬ РАССТОЯНИЕ ОТ ТОЧКИ ДО центра сферы\n\tvec3 sphere = vec3(0.,0.,0.);\n\tfloat sphereDist = dist(p, sphere) - 1.5 ;\n\tfloat d = sphereDist;\n\treturn d;\n\n}\n\nvec3 normalforlit(vec3 p) {\n\tfloat d = getDistdotsentra(p);\n\tfloat p1 = getDistdotsentra(sub(p, EX));\n\tfloat p2 = getDistdotsentra(sub(p, EY));\n\tfloat p3 = getDistdotsentra(sub(p, EZ));\n\tvec3 tri = vec3(p1, p2, p3);\n\tvec3 n = sub(vec3(d,d,d), tri);\n\treturn normalize(n);\n}\n\n\nvec2 getDist(vec3 p) { //ПОЛУЧИТЬ РАССТОЯНИЕ ОТ ТОЧКИ ДО СФЕРЫ\n\tvec3 sphere = vec3(0.,0.,0.);\n    vec3 n = normalforlit(p);\n    \n    vec2 st = p.xy;\n    \n    st.y+= iTime*0.1;\n    \n     // Масштаб\n    float mashtab = 15.;\n    st *= mashtab;\n\n    // Разбиение пространства\n    vec2 i_st = floor(st);\n    vec2 f_st = fract(st);\n\n    float m_dist = 100.0;\n    for (int y= -1; y <= 1; y++) {\n        for (int x= -1; x <= 1; x++) {\n            // Соседняя клетка\n            vec2 neighbor = vec2(float(x),float(y));\n            vec2 point = random2(i_st + neighbor);\n            point = 0.5+0.5*sin(iTime + 6.2831*point);\n            vec2 diff = neighbor + point - f_st; //вектор до точки\n            float dist = length(diff) + 1.*sin(point.x); // Расстояние до точки\n            m_dist = min(m_dist, dist); // Сохранить наименьшее расстояние\n        }\n    }\n\n    //float line = 1./(iResolution.y/mashtab);\n    //vec3 col = vec3(m_dist);\n    //fragColor = vec4(col,1.0);\n    \n    \n\tfloat sphereDist = dist(p, sphere) - m_dist*0.1 - 1.3 ;\n    float fraktal_noise = dist(p, sphere)  - fbm(vec2(n.x*4.+iTime*0.7, n.y*4.))*0.7 - 1. ; \n    \n    float d = smin(sphereDist, fraktal_noise, 0.1);\n    //  + fbm(vec2(n.x*5.+iTime, n.y*5.))*0.5\n    // фрактальный шум\n    float t = 0.;\n    if (sphereDist>fraktal_noise) t = 1.;\n    \n\t//float d = sphereDist;\n\treturn vec2(d, t);\n\n}\n\n\nvec3 normal(vec3 p) {\n\tfloat d = getDist(p).x;\n\tfloat p1 = getDist(sub(p, EX)).x;\n\tfloat p2 = getDist(sub(p, EY)).x;\n\tfloat p3 = getDist(sub(p, EZ)).x;\n\tvec3 tri = vec3(p1, p2, p3);\n\tvec3 n = sub(vec3(d,d,d), tri);\n\treturn normalize(n);\n}\n\n\n\n\n\nfloat light(vec3 p) {\n\t//vec3 lightPos = vec3(-10., 4., 0.);\n    vec3 lightPos = vec3(sin(iTime)*3., 1., cos(iTime)*3.);\n\tvec3 lightDir = normalize(sub(lightPos, p));\n\tvec3 n = normalforlit(p);\n\treturn dot(n, lightDir) * 0.5  + 0.5;\n}\n\nvec3 rayMarching(vec3 ro, vec3 rd) {\n\tvec3 p = ro;\n\tfor (int i = -0; i < 500; i++){\n\t\tfloat d = getDist(p).x;\n        float t = getDist(p).y;\n\t\tif (d > MAX_DIST) {break;}\n\t\tp = sum(p, mul(rd, d));\n\t\tif (d < 0.0001){\n\t\t\t//let dif = i / ITERATION\n\t\t\t//dif = dif+dif\n            float l = light(p);\n            float n = 2.;\n\t\t\treturn vec3(\n            pow(l*t,5.),\n            pow(l,n),\n            pow(l*(1.-t),n)\n            \n            );\n\t\t} \n\t}\n\treturn vec3(0.,0.,0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    const int iteration = 500;\n    const float max_dist = 10.0;\n\n\t//координаты камеры\n\tvec3 ro = vec3(0., 0., -2.5);\n\n    float x = (fragCoord.x / w) * 2. - 1.;\n    float y = (fragCoord.y / h) * 2. - 1.;\n    x *= w / h;\n\n    //направление луча\n    vec3 rd = vec3(x, y , 1.);\n    rd = normalize(rd);\n\n    //круг\n    vec3 color = rayMarching(ro, rd);\n\t\t\t\n\t\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttyBz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[296, 296, 320, 320, 397], [399, 399, 421, 421, 554], [556, 634, 660, 660, 1040], [1060, 1060, 1084, 1106, 1360], [1363, 1363, 1391, 1504, 1582], [1584, 1584, 1608, 1646, 1731], [1733, 1733, 1759, 1795, 1844], [1846, 1846, 1872, 1906, 1955], [1957, 1957, 1988, 2042, 2097], [2099, 2099, 2138, 2138, 2243], [2248, 2248, 2280, 2365, 2477], [2479, 2479, 2506, 2506, 2751], [2754, 2754, 2776, 2848, 4266], [4269, 4269, 4290, 4290, 4507], [4513, 4513, 4534, 4573, 4747], [4749, 4749, 4785, 4785, 5223], [5225, 5225, 5282, 5282, 5747]], "test": "valid"}
{"id": "WlScWK", "name": "math art", "author": "space_sheep", "description": "math art", "tags": ["3d", "cube"], "likes": 2, "viewed": 51, "published": "Public", "date": "1620157455", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float pi = 3.14159265359;\n\nvec3 rotateX(vec3 v, float deg)\n{\n    mat3 m = mat3(\n       1.0, 0.0, 0.0, // first column \n       0.0, cos(deg), -sin(deg), // second column\n       0.0, sin(deg), cos(deg)  // third column\n    );\n    return m*v;\n}\nvec3 rotateZ(vec3 v, float deg)\n{\n    mat3 m = mat3(\n       cos(deg), -sin(deg), 0.0, // first column \n       sin(deg), cos(deg),  0.0, // second column\n       0.0, 0.0, 1.0  // third column\n    );\n    return m*v;\n}\nbool inLine(vec2 uv, vec3 a, vec3 b)\n{\n    vec3 c = a-b;\n    float slp = c.y/c.x;\n    float bb = -slp*a.x+a.y;\n    \n    float size = 0.01;\n    \n    if(a.x>b.x) {float temp = a.x; a.x = b.x; b.x = temp;};\n    if(\n       uv.x>a.x && \n       uv.x<b.x &&\n       uv.y>uv.x*slp-size + bb && \n       uv.y<uv.x*slp+size + bb\n       ) return true;\n    else return false;\n}\nvec3 project(vec3 v)\n{\n    return vec3((1.0/v.z)*v.xy, v.z);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 col = 0.5 + 0.5*cos(iTime+uv.xyxy+vec4(0,2,4,1));\n    fragColor = vec4(.0,.0,.0,.0);\n    \n    vec2 res = iResolution.xy;\n    vec2 p\t = vec2(fragCoord.x/res.x, fragCoord.y/res.y) ;\n    \n    mat2 m = mat2(\n       0.5,  -1.0, // first column (not row!)\n       0.0, 1.0 // second column\n    );\n    \n    p = m*p;\n    \n    float d = atan(p.y/p.x) / (pi/2.0);\n    float l = length(p);\n    \n    float change = (cos(iTime/6.0)+10.0)*6.0;\n    if(\n        mod(floor(l*20.0),2.0)==0.0 && \n        mod(floor(d*change),2.0)==0.0\n    ) \n    fragColor.x=0.5;\n    \n    //--------------------\n    \n    float s = 0.25;\n    vec3[8] points = vec3[8](\n        vec3(-s,s,-s), vec3(s,s,-s), vec3(s,s,s), vec3(-s,s,s),\n        vec3(-s,-s,-s), vec3(s,-s,-s), vec3(s,-s,s), vec3(-s,-s,s)\n    );\n    \n    for(int i=0; i<8; i++) {\n        points[i]=rotateX(points[i], iTime/3.0);\n        points[i]=rotateZ(points[i], iTime/2.0);\n        points[i].z += 1.0;\n        points[i] = project(points[i]);\n        \n        points[i].x += 0.5;\n        points[i].y += 0.5;\n    };\n    \n    for(int i=0; i<4; i++){\n        if(inLine(uv, points[i], points[(i+1)%4]))\n        fragColor = fragColor = col;\n    }\n    for(int i=0; i<4; i++){\n        if(inLine(uv, points[i+4], points[(i+1)%4+4]))\n        fragColor = col;\n    }\n    for(int i=0; i<4; i++){\n        if(inLine(uv, points[i], points[(i+1)%5+3]))\n        fragColor = col;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlScWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 60, 60, 241], [242, 242, 275, 275, 457], [458, 458, 496, 496, 821], [822, 822, 844, 844, 884]], "test": "valid"}
{"id": "wsKXDh", "name": "Butterfly (2004)", "author": "iq", "description": "A procedural butterfly I made back in 2004 for the realtime 64 kilobyte demo [url=https://www.pouet.net/prod.php?which=12821]Paradise[/url]. You can see the butterfly in the rhino sequence: [url]https://www.youtube.com/watch?v=JY9FzRwasjw&t=274s[/url]", "tags": ["procedural", "2d", "demoscene", "butterfly", "paradise"], "likes": 33, "viewed": 559, "published": "Public API", "date": "1621114208", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2004/2021\n// I share this piece (art and code) here in Shadertoy and through its Public API, only for educational purposes. \n// You cannot use, sell, share or host this piece or modifications of it as part of your own commercial or non-commercial product, website or project.\n// You can share a link to it or an unmodified screenshot of it provided you attribute \"by Inigo Quilez, @iquilezles and iquilezles.org\". \n// If you are a teacher, lecturer, educator or similar and these conditions are too restrictive for your needs, please contact me and we'll work it out.\n\n\n// A procedural butterfly I made back in 2004 for the realtime\n// 64 kilobyte demo Paradise (https://www.pouet.net/prod.php?which=12821)\n// You can see the butterfly in the rhino sequence: \n//\n// https://www.youtube.com/watch?v=JY9FzRwasjw&t=274s\n//\n// I converted the code below from C to GLSL. The exact noise patterns are\n// a bit different because in C I used a LUT based hash that I didn't want\n// to duplicate here in the Shadertoy version.\n\n// make 0 to see the static painting\n#define ANIMATE 1\n\nfloat fbm( float x, float y, int octaves );\n\nvec4 butterfly( in vec2 p )\n{\n    p.x = abs(p.x);\n\n    vec4 col = vec4(0.0);\n\n    float a = atan(p.x,p.y);\n    float r = length(p);\n    \n    // bottom wing\n    if( p.y<0.0 )\n    {\n        float f = 0.45 + 0.2*fbm( 1.0+4.0*a,0.0, 2 );\n        float w = 3.1416*max(0.0,a-1.05)/(3.1416-1.05);\n\n        f *= sin(w)*sin(w);\n        f += 0.25*exp(-30.0*abs(a-(1.7+0.7*r)));\n\n        float th = f + 0.001;\n        \n        vec3 wcol = vec3(0.0,0.0,0.0);\n\n        // ala amarilla\n        f = fbm( 5.0*r, 5.0*w/(1.0+1.5*r), 3 );\n        f *= 1.0-pow(r/th,42.0);\n        f = 0.2 + 0.8*f;\n        wcol = mix( wcol, vec3(1.00,0.98,0.59), smoothstep(0.47,0.53,f) );\n        wcol *= 1.4;\n        // borde negro\n        f = w - 0.3*(r/th);\n        f = 0.5 + 0.5*sin(20.0*f);\n        f = 0.3*pow(f, 1.0 + 40.0*r/th );\n        f = sqrt( max(1.0-(r/th),0.0) );\n        wcol *= 1.0-f;\n\n        // manchas negri-naranjas\n        f = fbm( 6.0*p.x, 6.0*p.y, 2 );\n\n        wcol = mix( wcol, vec3(0.00,0.00,0.00), smoothstep( 0.52, 0.53, f ) );\n        wcol = mix( wcol, vec3(0.97,0.64,0.10), smoothstep( 0.53, 0.58, f ) );\n        float d = r-th;\n        //col = mix( col, wcol, smoothstep( 0.0,2.0*fwidth(d),-d) );\n        float al = smoothstep( 0.0,2.0*fwidth(d),-d);\n        col.xyz = wcol;\n        col.w = al;\n    }\n    \n    // top wing\n    if( a<2.2 )\n    {\n        float f = 0.55 + 0.3*fbm( 4.0*a, 46.0, 2 );\n        float w = a*(3.1416/2.356);\n        float th = f*sin(w)*sin(w) + 0.001;\n            \n        // ala roja\n        float h = fbm( p.x*4.0, p.y*4.0, 3 );\n        vec3 col2 = mix( vec3(0.54,0.28,0.09), \n                         vec3(0.55,0.04,0.04), smoothstep( 0.3, 0.7, h ) );\n        col2 *= 1.4;\n        f = fbm( 6.0*r+2.0, 5.0*w/(1.0+0.1*r), 3 );\n        f = 0.2 + 0.8*f;\n\n        // borde negrito\n        f *= 1.0-pow(r/th,42.0);\n        vec3 wcol = mix( vec3(0.0), col2, smoothstep(0.47,0.53,f) );\n\n        // esqueleto\n        f = w - 0.3*(r/th);\n        f = 0.5 + 0.5*sin(32.0*f);\n        f = 0.4*pow(f, 1.0 + 40.0*r/th );\n        f *= 1.0-pow( r/th, 5.0 );\n        wcol *= 1.0-f;\n\n        // manchas blanqui-negras\n        f = fbm(18.5+ 5.0*p.x, 0.0+6.0*p.y, 2 );\n        f = smoothstep( 0.35, 0.65, f);\n        wcol = mix( wcol, vec3(0,0,0), smoothstep( 0.65, 0.85,f ) );\n        wcol = mix( wcol, vec3(1,1,1), smoothstep( 0.99, 1.00,f ) );\n        float d = r-th;\n        float al = smoothstep( 0.0,2.0*fwidth(d),-d);\n        col.xyz = mix( col.xyz, wcol, al );\n        col.w = 1.0 - (1.0-col.w)*(1.0-al);\n    }\n    \n    return col;\n}\n\nint hash( ivec2 z )\n{\n    // 2D to 1D  (feel free to replace by some other)\n    int n = z.x+z.y*11111;\n    // Hugo Elias hash (feel free to replace by another one)\n    n = (n<<13)^n;\n    return (n*(n*n*15731+789221)+1376312589)>>16;\n}\n    \n// this hash differs from the one I used in Paradise, so the color\n// patters don't match exactly.\nvec2 grad( ivec2 z )\n{\n    // Perlin style vectors\n    int n = hash(z) & 7;\n    vec2 gr = vec2(n&1,n>>1)*2.0-1.0;\n    return ( n>=6 ) ? vec2(0.0,gr.x) : \n           ( n>=4 ) ? vec2(gr.x,0.0) :\n                                  gr ;\n}\n\n// some basic gradient noise\nfloat noise( in vec2 p )\n{\n    ivec2 i = ivec2(floor( p ));\n     vec2 f =       fract( p );\n\tvec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( dot( grad( i+ivec2(0,0) ), f-vec2(0.0,0.0) ), \n                     dot( grad( i+ivec2(1,0) ), f-vec2(1.0,0.0) ), u.x),\n                mix( dot( grad( i+ivec2(0,1) ), f-vec2(0.0,1.0) ), \n                     dot( grad( i+ivec2(1,1) ), f-vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat fbm( float x, float y, int octaves )\n{\n    float t = 0.0;\n    float s = 0.5;\n\n    for( int i=0; i<octaves; i++ )\n    {\n        t+=s*noise( vec2(x,y) );\n        x+=x;\n        y+=y;\n        s*=.5;\n    }\n\n    return clamp( 0.5 + 0.6*t, 0.0, 1.0 );\n}\n\n// integral of smoothstep(0,T,t). More info here:\n// https://www.tiktok.com/@inigoquilez/video/6963762978126646534\nfloat s( float t, in float T )\n{\n    if( t<T )\n    {\n        return t*t*t*(1.0-t*0.5/T)/T/T;\n    }\n    return t - T/2.0;\n    \n}\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 3\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // render\n#if ANIMATE==1\n    vec3 col = vec3(0.0);\n    for( int j=0; j<AA; j++ )\n    for( int i=0; i<AA; i++ )\n    {\n        vec2 of = vec2(i,j)/float(AA);\n        vec2 p = (2.0*(fragCoord+of)-iResolution.xy)/iResolution.y;\n\n        // time\n        float di = float( hash(ivec2(fragCoord)*AA+ivec2(i,j))&255 )/255.0;\n        float time = iTime + ((float(j*AA+i)+di)/float(AA*AA))*(0.5/24.0) - 0.5*0.5/24.0;\n        \n        // soften motion        \n        time += 0.07*sin( p.y );\n\n        // wing position\n        float wing = s(time, 8.0);\n       \n        //animate plane\n        float an = 1.55*(0.5-0.5*cos(16.5*(wing-12.0)));\n        vec2  pl = vec2(sign(p.x)*sin(an),-cos(an));\n\n        // intersect plane\n        vec3 ro = vec3(0.0,0.0,1.95);\n        vec3 rd = vec3(p,-3.0);\n        vec3 pos = ro - rd*dot(ro.xz,pl)/dot(rd.xz,pl);\n        vec2 q = vec2( length(pos.xz), pos.y );\n\n        // draw butterfly\n        vec4 tmp = butterfly( q );\n\n        // some basic fake lighting \n        tmp = clamp(tmp,0.0,1.0);\n        tmp.xyz *= 0.1+0.9*mix(1.0,abs(q.y)*0.5+min(q.x*2.0,1.0),pl.x*pl.x);\n        tmp.xyz *= clamp(0.25+0.75*(pl.x-pl.y+1.0),0.0,1.0);\n\n        // accumulate\n        col += mix( vec3(0.56), tmp.xyz, tmp.w );\n    }\n    // resolve (box filter)\n    col /= float(AA*AA);\n#else\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    p *= 0.65;\n    vec3 col = butterfly( p );\n#endif\n\n    // vignette\n    vec2 q = fragCoord/iResolution.xy;\n    col *= 0.05 + 0.95*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.15);\n    \n    // dither\n    col += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsKXDh.jpg", "access": "shaders20k", "license": "proprietary-license", "functions": [[1151, 1151, 1180, 1180, 3693], [3695, 3695, 3716, 3770, 3929], [3935, 4034, 4056, 4084, 4267], [4269, 4298, 4324, 4324, 4706], [4708, 4708, 4752, 4752, 4960], [4962, 5077, 5109, 5109, 5204]], "test": "error"}
