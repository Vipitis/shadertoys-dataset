{"id": "4lf3DB", "name": "inaho", "author": "jirohcl", "description": "power style volume light!(TDF2015)", "tags": ["tdf2015"], "likes": 2, "viewed": 333, "published": "Public", "date": "1424687862", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nfloat PI=3.14159265;\n#define STEP1 128\n#define STEP2 64\n\nvec2 dist_floor(in vec3 p)\n{\n\treturn vec2(sin(p.x*0.1)*2.0+\n\t\t    sin(p.y*0.1)*2.0+\n\t\t    p.y+10.0,0);\n}\n\nvec2 sphere(in vec3 p,in vec3 sh_p,in float size,in float id)\n{\n\tfloat d = length(p - sh_p)-size;\n\treturn vec2(d,id);\n}\n\nvec2 cylinder(in vec3 p,in vec3 cy_p,in float size,in float id)\n{\n\treturn vec2(length(p.xz-cy_p.xz)-size,id);\n}\n\nvec2 dist_gass(in vec3 p)\n{\n\tp.x += sin(iTime+p.y*0.5);\n\tif(sin(p.x*10.5) > 0.9 && sin(p.z*1.5) > 0.6 )\n\t{\n\t\tvec2 floor_d = dist_floor(p);\n\t\treturn vec2(floor_d.x+p.y*13.0,0);\n\t}\n\treturn vec2(1000,0);\n}\n\n//select short dist\nvec2 uni(in vec2 obj0, in vec2 obj1)\n{\n\tif (obj0.x < obj1.x)\n    \treturn obj0;\n\telse\n    \treturn obj1;\n}\n\n//distance field scene\nvec2 scene(in vec3 p)\n{\n\tvec2 dist = vec2(1000,0);;\n\tdist = uni( dist , sphere(p,vec3(sin(iTime)*5.0,4,15),2.0,1.0) );\n\tdist = uni( dist , sphere(p,vec3(cos(iTime)*10.0,-4,25),2.0,2.0) );\n\tdist = uni( dist , sphere(p,vec3(sin(iTime)*-10.0,12,55),2.0,3.0) );\n\tdist = uni( dist , dist_gass(p) );\n\treturn dist;\n}\n\nvec3 select_material(in vec3 p,in float id)\n{\n\tif(id == 0.0)\n    \t\treturn vec3(1);\n\tif(id == 1.0)\n    \t\treturn vec3(0.1,0.1,0.8);\n\tif(id == 2.0)\n   \t\treturn vec3(0.8,0.1,0.1);\n\tif(id == 3.0)\n    \t\treturn vec3(0.1,0.8,0.1);\n\tif(id == 4.0)\n    \t\treturn vec3(0.8,0.8,0.8);\n\treturn vec3(0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 vPos = fragCoord.xy/iResolution.xy - 0.5;\n\t// Camera up vector.\n\tvec3 vuv=vec3(0,1.0,0);\n    \n\t// Camera lookat.\n\tvec3 cpos=vec3(0,13,50);\n\tfloat mx=4.8+iMouse.x/iResolution.x*1.0;\n\tfloat my=0.0+iMouse.y/iResolution.y*1.0;\n\tvec3 prp=vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*12.0;\n\n    \t// Camera setup.\n\tvec3 vpn=normalize(cpos-prp + vec3((iMouse.x/iResolution.x-0.5)*1.0,0,1));\n\tvec3 u=normalize(cross(vuv,vpn));\n\tvec3 v=cross(vpn,u);\n\tvec3 vcv=(prp+vpn);\n\tvec3 scrCoord=vcv+vPos.x*u*iResolution.x/iResolution.y+vPos.y*v;\n\tvec3 scp=normalize(scrCoord-prp);\n\t\n\tvec3 L = vec3(0,15,35);\n\t// Raymarching.\n\tconst vec3 e=vec3(0.02,0,0);\n\tconst float maxd=100.0;//Max depth\n\tvec2 d=vec2(0.1,0.0);\n\tvec3 p,N;\n\t\n\tfloat volLight = 0.0;\n\tvec2 dl=vec2(0.1,0.0);\n\tvec3 pl;\n\tfloat f=1.0;\n\tfor(int m_c=STEP1;m_c>0;m_c--)\n\t{\n\t\tif ((abs(d.x) < .001) || (f > maxd))\n\t\t\tbreak;\n\t\n\t\tf+=min(d.x,1.0);\n\t\n\t\tp=prp+scp*f;\n\t\td = scene(p);\n\t\n\t\tfloat fl=1.0;\n       \t\tdl=vec2(0.1,0.0);\n\t\tfor(int j=0;j<STEP2;j++)\n\t\t{\n\t\t\tif ((abs(dl.x) < 0.01))\n\t\t\tbreak;\n\t\n\t\t\tfl+=dl.x;\n\t\t\tpl=p+normalize(L-p)*fl;\n\t\t\tdl = scene(pl);\n\t\t\n\t\t\tif( abs(dl.x) >= length(L-pl)  || (fl > maxd))\n\t\t\t{\n\t\t\tfl = maxd + 1.0;\n\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(fl > maxd)\n\t\t{\n\t\t\tvolLight += 0.7/pow(length(L-p),1.5);\n\t\t}\n\n\t\tif(m_c == 0)\n\t\t{\n\t\t\tf = maxd+1.0;\n\t\t\tbreak;\n\t\t}        \n\t}\n    \n    \tvolLight = pow(volLight,2.0);\n    \n\tif (f < maxd)\n\t{\n\t\tvec3 col = select_material(p,d.y);\n\t\tvec3 n = vec3(d.x-scene(p-e.xyy).x,\n\t\t\t\td.x-scene(p-e.yxy).x,\n\t\t\t\td.x-scene(p-e.yyx).x);\n\t\tN = normalize(n);\n    \t\tfloat b=dot(N,normalize(prp-p+L));\n    \t\tfragColor=vec4((b*col)*(1.0-f*.01),1.0)+volLight;\n\t}\n\telse\n\t{\n\t\tfragColor= vec4(volLight,volLight,volLight,1);//background color\n\t}\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lf3DB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[103, 103, 131, 131, 207], [209, 209, 272, 272, 328], [330, 330, 395, 395, 441], [443, 443, 470, 470, 645], [647, 667, 705, 705, 771], [773, 796, 819, 819, 1105], [1107, 1107, 1152, 1152, 1395], [1396, 1396, 1453, 1453, 3168]], "test": "valid"}
{"id": "4lf3R2", "name": "IQ's distance function test", "author": "thu_yumeng", "description": "thanks iq introduce me the world of computer graphics,and all my friends who help me :) this is just test", "tags": ["iq"], "likes": 1, "viewed": 149, "published": "Public", "date": "1423232411", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdSphere(vec3 p,float s)\n{\n    return length(p) - s;\n}\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 map(in vec3 pos)\n{\n    //return vec2(sdSphere( pos - vec3(0.,0.25,0.),0.25),46.9);\n    //vec2 res = opU(vec2( udRoundBox(  pos-vec3(-2.0,0.2, 1.0), vec3(0.15),0.05),43.5 ) ,\n\t                //vec2( sdSphere(    pos-vec3( -2.0,0.25, 1.0), 0.25 ), 46.9 ) );\n    vec2 res = vec2( opS(\n\t\t             udRoundBox(  pos-vec3(-2.0,0.2, 1.0), vec3(0.15),0.05),\n\t                 sdSphere(    pos-vec3(-2.0,0.2, 1.0), 0.25)), 13.0 ) ;\n    res = opU(res,vec2(sdPlane( pos - vec3(0.0, -2.0,1.0)),1.0));\n    return res;\n}\n\nvec2 castRay(in vec3 ro, in vec3 rd)\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n    float precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    \n    for(int i = 0;i<50;i++)\n    {\n        vec2 res = map(ro+rd*t);\n        if(res.x < precis || res.x > tmax)break;\n        t += res.x;\n        m = res.y;\n    }\n    if (t>tmax)\n        m = -1.0;\n    return vec2(t,m);\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec3 eps = vec3(0.001,0.0,0.0);\n    vec3 nor = vec3(\n        map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n        map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n        map(pos+eps.yyx).x - map(pos-eps.yyx).x);\n    return normalize(nor);\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec3 col = vec3(0.8,0.9,1.0);\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n    float m = res.y;\n    if( m > -0.5)\n    {\n    \tvec3 pos = ro + t*rd;\n    \tvec3 nor = calcNormal( pos );\n   \t\tvec3 lig = normalize(vec3(-0.6,0.7,-0.5));\n    \tvec3 ref = reflect(rd,nor);\n    \tfloat dif = clamp(dot(nor,lig),0.0,1.0);\n    \n    \tvec3 brdf = vec3(0.0);\n    \tbrdf += 1.20*dif*vec3(1.0,0.9,0.6);\n    \tbrdf += 0.02;\n        col = col*brdf;\n        \n        col = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0005*t*t ) );\n    }\n    \n    return vec3(clamp(col,0.0,1.0));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime;\n\n\t// camera\t\n\tvec3 ro = vec3( -0.5+3.2*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 3.2*sin(0.1*time + 6.0*mo.x) );\n\tvec3 ta = vec3( -0.5, -0.4, 0.5 );\n\t\n\t// camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n    \n     vec3 col = render( ro, rd );\n     col = pow( col, vec3(0.4545) );\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lf3R2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 32, 60], [61, 61, 86, 86, 101], [103, 103, 148, 148, 188], [190, 190, 226, 226, 474], [476, 476, 506, 506, 539], [540, 540, 573, 573, 599], [601, 601, 624, 862, 1116], [1118, 1118, 1156, 1156, 1496], [1498, 1498, 1528, 1528, 1762], [1764, 1764, 1801, 1801, 2366], [2367, 2367, 2424, 2424, 3069]], "test": "valid"}
{"id": "4ll3Rl", "name": "SHADE A DAY ( 2 / 19 / 2015 )", "author": "cabbibo", "description": "Trying to understand volumetric surfaces more with raytracing. Large majority of code stolen from this absolutely divine shader by Robert Cupisz: https://www.shadertoy.com/view/Mdl3Rr", "tags": ["volumetric"], "likes": 8, "viewed": 574, "published": "Public", "date": "1424403181", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\t\n\tAll Code stolen from \n\thttps://www.shadertoy.com/view/Mdl3Rr\n\n\tand\n\t\n\thttp://www.iquilezles.org/www/index.htm\n\thttps://www.shadertoy.com/user/iq\n\n*/\n\n\n\n\n\n\n// Robert Cupisz 2013\n// Creative Commons Attribution-ShareAlike 3.0 Unported\n//\n// Bits of code taken from Inigo Quilez, including fbm(), impulse()\n// and friends, sdCone() and friends; also box() by Simon Green.\n\n#define INF 1.0e38\n#define HIT(x) hit = min(hit, x)\n#define ROOFPOS vec3(0,-1,0.01)\n\nvec4 spherePos[10];\n\nmat2 rot(float angle)\n{\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\treturn mat2(c,-s,s,c);\n}\nvec3 rot (vec3 v, vec3 axis, vec2 sincosangle)\n{\n\treturn v*sincosangle.y + cross(axis, v)*sincosangle.x + axis*(dot(axis, v))*(1.0 - sincosangle.y);\n}\n\nfloat sdSphere (vec3 p, float s)\n{\n\treturn length(p)-s;\n}\n\n\n// rd doesn't have to be normalized\nfloat sphere(vec3 ro, vec3 rd, float r)\n{\n\tfloat b = dot(ro, rd);\n\tfloat c = dot(ro, ro) - r * r;\n\tfloat a = dot(rd, rd);\n\t// Exit if râ€™s origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif (c > 0.0 && b > 0.0)\n\t\treturn INF;\n\tfloat discr = b*b - a*c;\n\t// A negative discriminant corresponds to ray missing sphere\n\tif (discr < 0.0)\n\t\treturn INF;\n\t// Ray now found to intersect sphere, compute smallest t value of intersection\n\tfloat t = - b - sqrt(discr);\n\tt /= a;\n\t// If t is negative, ray started inside sphere so clamp t to zero\n\tt = max(0.0, t);\n\treturn t;\n}\n\n\n\nfloat hash (float n)\n{\n\treturn fract(sin(n)*43758.5453);\n}\n\nfloat noise (in vec3 x)\n{\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\n\tf = f*f*(3.0-2.0*f);\n\n\tfloat n = p.x + p.y*57.0 + 113.0*p.z;\n\n\tfloat res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n\t\t\t\t\t\tmix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n\t\t\t\t\tmix(mix( hash(n+113.0), hash(n+114.0),f.x),\n\t\t\t\t\t\tmix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n\treturn res;\n}\n\nfloat box(vec3 org, vec3 dir, vec3 size, out float far)\n{\n\t// compute intersection of ray with all six bbox planes\n\tvec3 invR = 1.0 / dir;\n\tvec3 tbot = invR * (-0.5*size - org);\n\tvec3 ttop = invR * (0.5*size - org);\n\t\n\t// re-order intersections to find smallest and largest on each axis\n\tvec3 tmin = min (ttop, tbot);\n\tvec3 tmax = max (ttop, tbot);\n\t\n\t// find the largest tmin and the smallest tmax\n\tvec2 t0 = max (tmin.xx, tmin.yz);\n\tfloat near;\n\tnear = max (t0.x, t0.y);\n\tt0 = min (tmax.xx, tmax.yz);\n\tfar = min (t0.x, t0.y);\n\n\t// check for hit\n\treturn near < far && far > 0.0 ? near : INF;\n}\n\n// frustum inscribed in a unit cube centered at 0\n#define INF 1.0e38\nfloat frustum(vec3 org, vec3 dir, float apex, vec3 size, out float far)\n{\n\tvec2 dirf = vec2(0.5 - apex, 0.5); \n\tvec3 tbot, ttop;\n\t\n\t// intersection with near and far planes\n\tfloat invdirx = 1.0 / dir.x;\n\ttbot.x = invdirx * (-0.5*size.x - org.x);\n\tttop.x = invdirx * (0.5*size.x - org.x);\n\n\tfloat temp = dirf.y * (org.x-apex);\n\t\n\t// intersection with inclined planes on y\n\ttbot.y = size.y * (-temp - dirf.x * org.y) / (dirf.x * dir.y + dirf.y * dir.x);\n\tttop.y = size.y * ( temp - dirf.x * org.y) / (dirf.x * dir.y - dirf.y * dir.x);\n\t\n\t// intersection with inclined planes on z\n\ttbot.z = size.z * (-temp - dirf.x * org.z) / (dirf.x * dir.z + dirf.y * dir.x);\n\tttop.z = size.z * ( temp - dirf.x * org.z) / (dirf.x * dir.z - dirf.y * dir.x);\n\t\n\t// if intersecting behind the apex, set t to ray's end\n\tvec4 tempt = vec4(tbot.yz, ttop.yz);\n\ttempt = mix(tempt, INF * sign(dir.xxxx), step(org.xxxx + tempt * dir.xxxx, vec4(apex)));\n\ttbot.yz = tempt.xy;\n\tttop.yz = tempt.zw;\n\n\t// re-order intersections to find smallest and largest on each axis\n\tvec3 tmin = min(ttop, tbot);\n\tvec3 tmax = max(ttop, tbot);\n\t\n\t// find the largest tmin and the smallest tmax\n\tvec2 t0 = max(tmin.xx, tmin.yz);\n\tfloat near = max(t0.x, t0.y);\n\tt0 = min(tmax.xx, tmax.yz);\n\tfar = min(t0.x, t0.y);\n\n\t// check for hit\n\treturn near < far && far > 0.0 ? near : INF;\n}\n\nfloat box(vec3 org, vec3 dir, vec3 size)\n{\n\tfloat far;\n\treturn box(org, dir, size, far);\n}\n\n\n\n// Makes brighter near top\nfloat transmittance (vec3 p)\n{\n    /*vec3 o;\n    o.x = sin( iTime ) * .1;\n    o.y = sin( iTime * .5) * 2.1;\n    o.z = sin( iTime * .05) * 20.1;\n\treturn noise( p * o);*/\n    \n    float a = 0.;\n    for( int i = 0; i < 10; i++ ){\n     \n        vec3 dif = spherePos[i].xyz - p;\n        \n       // float n = noise(dif * 5.);\n        float l = length( dif );\n        a +=  .1 / (l*l);\n        \n    }\n    \n    return a;\n    \n}\n\nfloat intersect (vec3 ro, vec3 rd)\n{\n\tfloat hit = INF;\n\n    for( int i = 0; i < 10; i++ ){\n\t\tHIT(sphere(ro - spherePos[i].xyz, rd,.1));\n    }\n\n\n\tHIT(box (ro - vec3(0.,-1.4,0.), rd, vec3(10.,.01,10.)));\n    HIT(box (ro - vec3(0.,-.9,0.), rd, vec3(2.,.05,2.)));\n    \n    HIT(box (ro - vec3(4.,0.,0.), rd, vec3(.01,10.,10.)));\n    HIT(box (ro - vec3(-4.,0.,0.), rd, vec3(.01,10.,10.)));\n    HIT(box (ro - vec3(0.,0.,4.), rd, vec3(10.,10.,.01)));\n    HIT(box (ro - vec3(0.,0.,-4.), rd, vec3(10.,10.,.01)));\n    //HIT(box (ro - vec3(0.,-.8,0.), rd, vec3(3.,.1,3.)));\n\n\n\treturn hit;\n}\n\n#define STEPS 20\nvec3 inscatter ( vec3 origin, vec3 ro, vec3 rd, vec3 roLight , vec3 rdLight, vec3 lightDir, float hit, vec2 screenPos)\n{\n\tfloat far;\n    //float near = frustum(roLight + vec3(0.0, 1.0, 0.0), rdLight,.01, vec3(1.5, 3.0, 1.5), far);\n\tfloat near = box(roLight + origin, rdLight, vec3(1., 30., 1.), far);\n\tif(near == INF || hit < near)\n\t\treturn vec3(0);\n\t\n\tfloat distAlongView = min(hit, far) - near;\n\tfloat oneOverSteps = 1.0/float(STEPS);\n\tvec3 step = rd*distAlongView*oneOverSteps;\n\tvec3 pos = ro + rd*near;\n\tfloat light = 0.0;\n\t\n\t// add noise to the start position to hide banding\n\tpos += rd*noise(vec3(2.0*screenPos, 0.0))*0.05;\n\n\tfor(int i = 0; i < STEPS; i++)\n\t{\n\t\tfloat l = intersect(pos, lightDir) == INF ? 1.0 : 0.0;\n\t\tl *= transmittance(pos);\n\t\tlight += l;\n        \n        //include light particles later ?\n\t\t//light += particles(pos)*l;\n\t\tpos += step;\n\t}\n\n\tlight *= oneOverSteps * distAlongView;\n\treturn light*vec3(0.3, .2 , 1. );\n}\n\n\n\n\n\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 0.3 + 10.0*mouseX;\n\tcamPos = vec3(3.5*sin(an),1.0,3.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n     for( int i =0; i < 10; i++ ){\n        \n        float x = 1.4 * cos(iTime *.13 * (float( i )+2.));\n        float y = .44 * sin(iTime * .075 * (float( i )+4.));\n        float z = 1.4 * sin(iTime * .1 * (float( i )+3.3));\n        float r = .00001 * ( sin( iTime * .1  *( float( i) +1.))+2.);\n    \tspherePos[i] = vec4( x ,  y ,  z , .001 );\n        \n        \n    }\n\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m.x );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n    \n    // raycast the scene\n\tfloat hit = intersect(ro,rd);\n\tvec3 hitPos = ro + hit * rd;\n\t\n    vec3 col = vec3( 0. );\n    \n   \n\t// white window\n\tif (hit == INF)\n\t{\n\t\tcol = vec3( 1. , 0. , 0. );\n        \n\n    }else{\n        col = vec3( .1 , 0.1 , 0.2 );\n    }\n     \n    \n    // white window\n\tif (hit == INF)\n\t{\n\t\tfragColor = vec4(0.0);\n\t\treturn;\n\t}\n    \n    /*vec3 roLight = vec3( 0. , 4. , 0. );\n    vec3 rdLight = vec3( 0. , -1. , 0. );\n    vec3 lightDir = normalize( rdLight );\n    \n    col += inscatter(ro, rd, roLight, rdLight, lightDir, hit, fragCoord.xy);*/\n    \n    // direct light (screw shading!)\n\tvec3 lightRotAxis = vec3(0.707,0,0.707); //1,0,1 normalized\n    \n    float angle = .28; //* sin(iTime);\n\tvec2 lightAngleSinCos = vec2(sin(angle), cos(angle));\n\tvec3 lightDir = rot(vec3(0,1,0), lightRotAxis, lightAngleSinCos);\n\tfloat shadowBias = 1.0e-4;\n\t//vec3 col = vec3(0.0);\n\tif (intersect(hitPos + lightDir*shadowBias, lightDir) == INF)\n\t\tcol = vec3(0.1,0.2,0.3);\n\t\n\t// inscatter\n\tlightAngleSinCos.x *= -1.0; // rev angle\n\tvec3 roLight = rot(ro + ROOFPOS, lightRotAxis, lightAngleSinCos);\n\tvec3 rdLight = rot(rd, lightRotAxis, lightAngleSinCos);\n\tcol += inscatter(vec3( 0. , 1. , 0.),ro, rd, roLight, rdLight, lightDir, hit, fragCoord.xy);\n    col += inscatter(vec3( 2. , 1. , 0.),ro, rd, roLight, rdLight, lightDir, hit, fragCoord.xy);\n    col += inscatter(vec3( 0. , 1. , 2.),ro, rd, roLight, rdLight, lightDir, hit, fragCoord.xy);\n    col += inscatter(vec3( 0. , 1. , -2.),ro, rd, roLight, rdLight, lightDir, hit, fragCoord.xy);\n    col += inscatter(vec3( -2. , 1. , 0.),ro, rd, roLight, rdLight, lightDir, hit, fragCoord.xy);\n\n    //col += inscatter(ro, rd, roLight, rdLight, lightDir, hit, fragCoord.xy);\n    \n\n    vec3 c = col;\n    // color correction - Sherlock color palette ;)\n\tc.r = smoothstep(0.0, 1.0, c.r * 1.5);\n\tc.g = smoothstep(0.0, 1.0, c.g - 0.0);\n\tc.b = smoothstep(-0.2, 1.3, c.b);\n    \n \tfragColor = vec4( c , 1. );   \n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ll3Rl.jpg", "access": "shaders20k", "license": "cc-by-sa-3.0", "functions": [[482, 482, 505, 505, 577], [578, 578, 626, 626, 728], [730, 730, 764, 764, 787], [790, 826, 867, 867, 1406], [1410, 1410, 1432, 1432, 1468], [1470, 1470, 1495, 1495, 1831], [1833, 1833, 1890, 1947, 2427], [2498, 2498, 2571, 2571, 3830], [3832, 3832, 3874, 3874, 3922], [3926, 3953, 3983, 4121, 4372], [4374, 4374, 4410, 4410, 4952], [4971, 4971, 5091, 5091, 5912], [5919, 5950, 6014, 6014, 6192], [6194, 6194, 6277, 6277, 6390]], "test": "valid"}
{"id": "4ll3RS", "name": "Ico-Twirl", "author": "dr2", "description": "Sometimes you need a REAL polyhedron (joke)...", "tags": ["raymarch", "symmetry", "polyhedron"], "likes": 5, "viewed": 635, "published": "Public API", "date": "1422988697", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Ico-Twirl\" by dr2 - 2015\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nint idObj;\nmat3 rMat[20];\nvec3 ltDir, qHit;\nfloat tCur, eLen, faLen, faThk, faRot;\nconst float dstFar = 20.;\nconst float C_ab = -0.364863828, C_ia = 0.55357435, C_d = 0.288675135,\n   C_r = 0.80901699;\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float s = 0.;\n  float a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return s;\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nvec3 WoodColP (vec2 p)\n{\n  return mix (vec3 (0.35, 0.2, 0.1), vec3 (0.25, 0.1, 0.),\n     Fbm2 (p * vec2 (2., 20.)));\n}\n\nfloat FacetDf (vec3 p, float dHit)\n{\n  vec3 q;\n  float d, df, dc, a;\n  q = p;\n  q.z -= C_r * eLen;\n  q.yz = Rot2D (q.yz, C_ab);\n  q.y += C_d * eLen;\n  q.z += 0.5 * C_r * eLen;\n  dc = PrCylDf (q, 0.05, 0.5 * C_r * eLen);\n  q.z -= 0.5 * C_r * eLen;\n  df = PrCylDf (q, 0.75 * faLen, faThk);\n  a = faRot;\n  df = max (df, dot (q, vec3 (sin (a), cos (a), C_ab)) - C_d * faLen);\n  a += (2./3.) * pi;\n  df = max (df, dot (q, vec3 (sin (a), cos (a), C_ab)) - C_d * faLen);\n  a += (2./3.) * pi;\n  df = max (df, dot (q, vec3 (sin (a), cos (a), C_ab)) - C_d * faLen);\n  d = min (df, dc);\n  if (d < dHit) {\n    dHit = d;\n    qHit = q;\n    if (df < dc) idObj = 1;\n    else idObj = 2;\n  }\n  return dHit;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float d, dHit;\n  dHit = dstFar;\n  q = p * rMat[0] ;  dHit = FacetDf (q, dHit);\n  q = p * rMat[1] ;  dHit = FacetDf (q, dHit);\n  q = p * rMat[2] ;  dHit = FacetDf (q, dHit);\n  q = p * rMat[3] ;  dHit = FacetDf (q, dHit);\n  q = p * rMat[4] ;  dHit = FacetDf (q, dHit);\n  q = p * rMat[5] ;  dHit = FacetDf (q, dHit);\n  q = p * rMat[6] ;  dHit = FacetDf (q, dHit);\n  q = p * rMat[7] ;  dHit = FacetDf (q, dHit);\n  q = p * rMat[8] ;  dHit = FacetDf (q, dHit);\n  q = p * rMat[9] ;  dHit = FacetDf (q, dHit);\n  q = p * rMat[10];  dHit = FacetDf (q, dHit);\n  q = p * rMat[11];  dHit = FacetDf (q, dHit);\n  q = p * rMat[12];  dHit = FacetDf (q, dHit);\n  q = p * rMat[13];  dHit = FacetDf (q, dHit);\n  q = p * rMat[14];  dHit = FacetDf (q, dHit);\n  q = p * rMat[15];  dHit = FacetDf (q, dHit);\n  q = p * rMat[16];  dHit = FacetDf (q, dHit);\n  q = p * rMat[17];  dHit = FacetDf (q, dHit);\n  q = p * rMat[18];  dHit = FacetDf (q, dHit);\n  q = p * rMat[19];  dHit = FacetDf (q, dHit);\n  d = PrSphDf (p, 0.2);\n  if (d < dHit) { dHit = d;  idObj = 2;  qHit = p; }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * vec3 (v.y, v.z, v.w));\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nmat3 RotToRMat (vec3 v, float a)\n{\n  mat3 m;\n  float c, s, a1, a2;\n  c = cos (a);\n  s = sin (a);\n  m[0][0] = (1. - c) * v.x * v.x + c;\n  m[1][1] = (1. - c) * v.y * v.y + c;\n  m[2][2] = (1. - c) * v.z * v.z + c;\n  a1 = (1. - c) * v.x * v.y;\n  a2 = -s * v.z;\n  m[0][1] = a1 + a2;\n  m[1][0] = a1 - a2;\n  a1 = (1. - c) * v.z * v.x;\n  a2 = -s * v.y;\n  m[2][0] = a1 + a2;\n  m[0][2] = a1 - a2;\n  a1 = (1. - c) * v.y * v.z;\n  a2 = -s * v.x;\n  m[1][2] = a1 + a2;\n  m[2][1] = a1 - a2;\n  return m;\n}\n\nvoid BuildRMats ()\n{\n  mat3 axMat[3];\n  axMat[0] = RotToRMat (vec3 (1., 0., 0.), pi);\n  axMat[1] = RotToRMat (vec3 (0., cos (C_ia), sin (C_ia)), 0.4 * pi);\n  axMat[2] = RotToRMat (vec3 (0., 1., 0.), pi);\n  for (int i = 0; i < 3; i ++) {\n    for (int j = 0; j < 3; j ++) rMat[0][i][j] = 0.;\n    rMat[0][i][i] = 1.;\n  }\n  rMat[1]  = axMat[0];\n  rMat[2]  = axMat[1];\n  rMat[3]  = rMat[2] * axMat[1];\n  rMat[4]  = rMat[3] * axMat[1];\n  rMat[5]  = rMat[4] * axMat[1];\n  rMat[6]  = rMat[1] * axMat[1];\n  rMat[7]  = rMat[6] * axMat[1];\n  rMat[8]  = rMat[7] * axMat[1];\n  rMat[9]  = rMat[8] * axMat[1];\n  rMat[10] = axMat[2];\n  rMat[11] = rMat[1] * axMat[2];\n  rMat[12] = rMat[2] * axMat[2];\n  rMat[13] = rMat[3] * axMat[2];\n  rMat[14] = rMat[4] * axMat[2];\n  rMat[15] = rMat[5] * axMat[2];\n  rMat[16] = rMat[6] * axMat[2];\n  rMat[17] = rMat[7] * axMat[2];\n  rMat[18] = rMat[8] * axMat[2];\n  rMat[19] = rMat[9] * axMat[2];\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 objCol;\n  vec3 col, vn;\n  float dstHit, tSeq;\n  tSeq = mod (tCur, 30.);\n  eLen = 1. + 1.4 * SmoothBump (5., 25., 3., tSeq);\n  faRot = 0.;\n  if (tSeq > 8. && tSeq < 22.) faRot = 4. * pi * (tSeq - 8.) / 14.;\n  faLen = 1.01;\n  faThk = 0.2;\n  idObj = -1;\n  dstHit = ObjRay (ro, rd);\n  if (idObj < 0) dstHit = dstFar;\n  if (dstHit >= dstFar) col = vec3 (0.005, 0., 0.);\n  else {\n    ro += rd * dstHit;\n    vn = ObjNf (ro);\n    if (idObj == 1) {\n      qHit.xy = Rot2D (qHit.xy, faRot);\n      objCol = (qHit.z > 0.9 * faThk) ?\n        vec4 (WoodColP (qHit.xy), 0.3) :\n        vec4 (0.2, 0.15, 0.05, 0.1) *\n        (1. - 0.3 * Fbm2 (100. * qHit.xy));\n    } else objCol = vec4 (0.2, 0.4, 0.1, 1.);\n    col = objCol.rgb * (0.3 + 0.7 * max (dot (vn, ltDir), 0.)) +\n       objCol.a * pow (max (0., dot (ltDir, reflect (rd, vn))), 64.);\n  }\n  return sqrt (clamp (col, 0., 1.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n  uv.x *= iResolution.x / iResolution.y;\n  tCur = iTime;\n  mat3 vuMat;\n  vec3 ro, rd;\n  vec2 vEl, vAz;\n  float az, el;\n  el = 0.05 * tCur;\n  az = -0.11 * tCur;\n  vEl = vec2 (cos (el), sin (el));\n  vAz = vec2 (cos (az), sin (az));\n  vuMat = mat3 (1., 0., 0., 0., vEl.x, - vEl.y, 0., vEl.y, vEl.x) *\n     mat3 (vAz.x, 0., vAz.y, 0., 1., 0., - vAz.y, 0., vAz.x);\n  rd = normalize (vec3 (uv, 3.5)) * vuMat;\n  ro = - vec3 (0., 0., 8.) * vuMat;\n  ltDir = normalize (vec3 (1., 1., -1.)) * vuMat;\n  BuildRMats ();\n  vec3 col = ShowScene (ro, rd);\n  fragColor = vec4 (col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ll3RS.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[465, 465, 489, 489, 536], [538, 538, 563, 563, 742], [744, 744, 765, 765, 902], [904, 904, 961, 961, 1044], [1046, 1046, 1076, 1076, 1150], [1152, 1152, 1185, 1185, 1212], [1214, 1214, 1256, 1256, 1307], [1309, 1309, 1333, 1333, 1427], [1429, 1429, 1465, 1465, 2119], [2121, 2121, 2143, 2143, 3221], [3223, 3223, 3244, 3244, 3467], [3469, 3469, 3502, 3502, 3678], [3680, 3680, 3714, 3714, 4168], [4170, 4170, 4190, 4190, 5086], [5088, 5088, 5123, 5123, 5997], [5999, 5999, 6056, 6056, 6680]], "test": "valid"}
{"id": "4ll3zX", "name": "Worm-hole", "author": "andregc", "description": "Something similar to tunnel through space", "tags": ["procedural", "2d", "noise"], "likes": 8, "viewed": 554, "published": "Public", "date": "1423862597", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 n) {\n\tconst vec2 d = vec2(0.0, 1.0);\n\tvec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nfloat fbm(vec2 n) {\n\tfloat total = 0.0, amplitude = 0.5;\n    \n\tfor (int i = 0; i <4; i++) {\n        total += noise(n ) * amplitude;\n\t\tn += n;\n\t\tamplitude *= 0.5;\n\t}\n\treturn total;\n}\n\n\nvec2 field(vec2 uv) {\n    vec2 dir = uv-vec2(0.5, 0.5);\n    vec2 dir2 = vec2(dir.y, -dir.x);\n    float l = length(dir);\n    vec2 a0 = l > 0.3 ? dir/(0.1+(l-0.3)*20.) : dir2*5.;\n    return a0*3. + dir2*l*0.9;\n}\n\n\nfloat getColor(vec2 uv) {\n    return fbm(uv*5.);   \n}\n\nvec2 calcNext(vec2 uv, float t) {\n    vec2 k1 = field(uv);\n    vec2 k2 = field(uv + k1*t/2.);\n    vec2 k3 = field(uv + k2*t/2.);\n    vec2 k4 = field(uv + k3*t);\n       \n    return uv + t/6.*(k1+2.*k2+2.*k2+k3);\n}\n\nvec4 getColor(vec2 uv, float cf, float per) {\n    float t1 = per * cf;\n    float t2 = t1 + per;\n    \n    float k1 = 0.4;\n    float k2 = 0.4;\n    \n    vec2 uv1 = calcNext(uv, t1 * k1 + k2);\n    vec2 uv2 = calcNext(uv, t2 * k1 + k2);\n    \n    float c1 = getColor(uv1);\n    float c2 = getColor(uv2);\n    \n    return vec4(mix(c2, c1, cf));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy + (iResolution.yx - iResolution.xx)/2.)/iResolution.y;\n\n    float per = 2.;\n    \n    float cf = fract(iTime / per);\n    vec4 c = getColor(uv,cf, per);\n    float l = length(field(uv));\n    c =  1. - (abs(c-0.5)*5.);\n    \n    \n    // some empirical coefficients\n    c *= 0.5*vec4(0.3, 0.6, 1.1, 1.)*pow(l,-0.3);\n    c += 0.25*vec4(1.0, 0.6, 0.2, 1.)*pow(abs(l-0.35),-0.7);\n    c*=0.8;\n\n\tfragColor = c;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ll3zX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 87], [89, 89, 110, 110, 307], [309, 309, 328, 328, 490], [493, 493, 514, 514, 702], [705, 705, 730, 730, 758], [760, 760, 793, 793, 972], [974, 974, 1019, 1019, 1311], [1314, 1314, 1371, 1371, 1801]], "test": "valid"}
{"id": "4llGDB", "name": "SHADE A DAY ( 2 / 25 / 2015 )", "author": "cabbibo", "description": "Trying to get more material with depth", "tags": ["glsl"], "likes": 11, "viewed": 1303, "published": "Public", "date": "1424970737", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ALL TAKEN FROM IQs AMAZING SITE / TUTORIALS / SHADERS:\n// http://www.iquilezles.org/www/index.htm\n// https://www.shadertoy.com/user/iq\n\n\nconst float MAX_TRACE_DISTANCE = 10.0;           // max trace distance\nconst float INTERSECTION_PRECISION = 0.001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 200;\n\n\nvec3 hsv(float h, float s, float v)\n{\n  return mix( vec3( 1.0 ), clamp( ( abs( fract(\n    h + vec3( 3.0, 2.0, 1.0 ) / 3.0 ) * 6.0 - 3.0 ) - 1.0 ), 0.0, 1.0 ), s ) * v;\n}\n\n\n// q is point\n// n is normal\n// p is point on plane\nvec3 projOnPlane( vec3 q, vec3 p , vec3 n){\n    \n    vec3 v = q - dot(q - p, n) * n;\n    return v;\n}\n\n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y*1.)), tri(p.z+tri(p.x*1.)), tri(p.y+tri(p.x*1.)));}\n                                 \n\n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat triNoise3D(in vec3 p, in float spd)\n{\n    float z=1.4;\n\tfloat rz = 0.;\n    vec3 bp = p;\n\tfor (float i=0.; i<=3.; i++ )\n\t{\n        vec3 dg = tri3(bp*2.);\n        p += (dg+iTime*.1*spd);\n\n        bp *= 1.8;\n\t\tz *= 1.5;\n\t\tp *= 1.2;\n        //p.xz*= m2;\n        \n        rz+= (tri(p.z+tri(p.x+tri(p.y))))/z;\n        bp += 0.14;\n\t}\n\treturn rz;\n}\n\nfloat posToFloat( vec3 p ){\n \n    float f = triNoise3D( p * .2, .1 );\n    return f;\n    \n}\n\nvoid buildBasis( in vec3 dir , in vec3 up , out vec3 x , out vec3 y , out vec3 z ){\n    \n\n //vec3( 0. , 1. , 0. );\n  //vec3  upVector = normalize( centerOfCircle );// vec3( 0. , 1. , 0. );\n  float upVectorProj = dot( up , dir );\n  vec3  upVectorPara = upVectorProj * dir;\n  vec3  upVectorPerp = up - upVectorPara;\n\n  vec3 basisX = normalize( upVectorPerp );\n  vec3 basisY = cross( dir , basisX );\n    \n    \n  x = basisX;\n  y = basisY;\n  z = dir;\n    \n}\n\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 0.3 + 10.0*mouseX;\n\tcamPos = vec3(3.5*sin(an),.0,3.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n// ROTATION FUNCTIONS TAKEN FROM\n//https://www.shadertoy.com/view/XsSSzG\nmat3 xrotate(float t) {\n\treturn mat3(1.0, 0.0, 0.0,\n                0.0, cos(t), -sin(t),\n                0.0, sin(t), cos(t));\n}\n\nmat3 yrotate(float t) {\n\treturn mat3(cos(t), 0.0, -sin(t),\n                0.0, 1.0, 0.0,\n                sin(t), 0.0, cos(t));\n}\n\nmat3 zrotate(float t) {\n    return mat3(cos(t), -sin(t), 0.0,\n                sin(t), cos(t), 0.0,\n                0.0, 0.0, 1.0);\n}\n\n\nmat3 fullRotate( vec3 r ){\n \n   return xrotate( r.x ) * yrotate( r.y ) * zrotate( r.z );\n    \n}\n\nfloat rotatedBox( vec3 p , vec3 rot , vec3 size , float rad ){\n    \n    vec3 q = fullRotate( rot ) * p;\n    return udRoundBox( q , size , rad );\n    \n    \n}\n\n\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \n\treturn (d1.x<d2.x) ? d1 : d2;\n    \n}\n\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos ){  \n   \n    // using super thin cube as plane\n    vec3 size = vec3( 1.  , 1. , .01 );\n   // vec3 rot = vec3( iTime * .1 , iTime * .4 , -iTime * .3 );\n    vec3 rot = vec3( 0.,0.,0. );\n   \tvec2 res = vec2( rotatedBox( pos , rot , size , .001 ) , 1.0 );\n\n   \treturn res;\n    \n}\n\nmat3 matInverse( mat3 m ){\n    \n  \n    vec3 a = vec3(\n      \n        m[1][1] * m[2][2] - m[2][1] * m[1][2],\n        m[0][2] * m[2][1] - m[2][2] * m[0][1],\n        m[0][1] * m[1][2] - m[1][1] * m[0][2]\n        \n    );\n    \n    vec3 b = vec3(\n      \n        m[1][2] * m[2][0] - m[2][2] * m[1][0],\n        m[0][0] * m[2][2] - m[2][0] * m[0][2],\n        m[0][2] * m[1][0] - m[1][2] * m[0][0]\n        \n    );\n    \n     vec3 c = vec3(\n      \n        m[1][0] * m[2][1] - m[2][0] * m[1][1],\n        m[0][1] * m[2][0] - m[2][1] * m[0][0],\n        m[0][0] * m[1][1] - m[1][0] * m[0][1]\n        \n    );\n    \n    \n    return mat3( \n        \n       a.x , a.y , a.z ,\n       b.x , b.y , b.z ,\n       c.x , c.y , c.z\n        \n    );\n    \n \n  \n    \n}\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t );\n        h = m.x;\n        t += h;\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n}\n\n\n#define STEPS 10\nvec3 fogCube( vec3 ro , vec3 rd , vec3 n , mat3 iMat){\n \n    float lum = 1.;\n    \n    vec3 col = vec3( 0. );\n    for( int i = 0; i < STEPS; i++ ){\n        vec3 p = ro + rd * .1  * float( i );\n\n        lum += abs(sin( p.x * 10. ) + sin( p.y * 10. ));// + sin( p.y * 3. ) + sin( p.z * 5.);\n    \n       \tcol += hsv( lum / 10. + sin( iTime * .1 ) , 1. , 1. ) / lum;\n    }\n    \n    return col/float(STEPS);\n    \n    \n}\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n    \n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m.x );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n    vec2 res = calcIntersection( ro , rd  );\n\n\n    vec3 col = vec3( 0. );\n    \n    mat3 basis = mat3(\n     \n        1. , 0. , 0. ,\n        0. , 1. , 0. ,\n        0. , 0. , 1.\n       \n    );\n        \n    mat3 iMat = matInverse( basis );\n    \n    if( res.y > -.5 ){\n        \n        vec3 pos = ro + rd * res.x;\n        vec3 norm = calcNormal( pos );\n        \n        vec3 depthColor = fogCube( pos , rd , norm , iMat );\n \n        col += depthColor;//lum  * vec3( 1. , .6 , 0.2);\n        \n        \n    }\n\n    fragColor = vec4( col , 1. );\n\n\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4llGDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[333, 333, 370, 370, 502], [505, 557, 600, 600, 657], [659, 711, 733, 733, 758], [759, 759, 780, 780, 860], [896, 948, 991, 991, 1294], [1296, 1296, 1323, 1323, 1386], [1388, 1388, 1471, 1576, 1840], [1843, 1843, 1874, 1874, 1912], [1915, 1915, 1960, 1960, 2000], [2003, 2034, 2098, 2098, 2276], [2278, 2278, 2361, 2361, 2473], [2475, 2548, 2571, 2571, 2677], [2679, 2679, 2702, 2702, 2808], [2810, 2810, 2833, 2833, 2942], [2945, 2945, 2971, 2971, 3040], [3042, 3042, 3104, 3104, 3198], [3202, 3296, 3325, 3325, 3368], [3370, 3454, 3475, 3519, 3748], [3750, 3750, 3776, 3776, 4484], [4486, 4486, 4534, 4534, 5001], [5021, 5021, 5075, 5075, 5434], [5436, 5549, 5580, 5580, 5806], [5810, 5810, 5867, 5867, 6930]], "test": "valid"}
{"id": "4ls3Rj", "name": "Sine Dance", "author": "hamoid", "description": "Learning...", "tags": ["2d", "sine"], "likes": 0, "viewed": 1124, "published": "Public API", "date": "1423352583", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\tAttempt to port http://hamoid.tumblr.com/post/103908919889/sine-dance\n\tto glsl. One of my first shader experiments.\n*/\n#define PI 3.1415926535897932384626433832795\n\nfloat psin(float a, float e) {\n  float b = (sin(a) + 1.0) / 2.0;\n  return pow(b, e) * 2.0 - 1.0;\n}\nfloat thing(float arms, vec2 p, float rot, float sz, float k1, float k2, float k3) {\n    float fa = iTime * 4.0;\n    float a = atan(p.y, p.x);\n    float d = sz * sin(a * arms) * 7.0;\n    d = d + 0.02 * sin(5.4 + d * 16.0 + a * arms);\n    d = d + 0.045 * psin(fa + k1 * a + k2 * psin(a, 5.0) + k3, 5.0);\n    return smoothstep(d, d+0.30, length(p));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p = fragCoord.xy / iResolution.xy;\n    \n    vec3 c = vec3(0.1059, 0.0824, 0.1294);\n    \n    if(thing(5.0, p - vec2(0.52, 0.26), -0.08, 0.01, 0.0, 1.0, 4.1) < 0.5) {\n        c = vec3(0.8314, 0.1176, 0.2706);\n    }\n    if(thing(5.0, p - vec2(0.70, 0.70), -0.10, 0.011, 1.0, 0.0, 0.1) < 0.5) {\n        c = vec3(0.7098, 0.6745, 0.0039);\n    }\n    if(thing(5.0, p - vec2(0.26, 0.67),  0.20, 0.009, 1.0, 0.0, PI/2.0) < 0.5) {\n        c = vec3(0.9255, 0.7294, 0.0353);\n    }\n    \n\tfragColor = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ls3Rj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[169, 169, 199, 199, 267], [268, 268, 352, 352, 617], [619, 619, 676, 676, 1184]], "test": "valid"}
{"id": "4ls3zf", "name": "First Distance Map", "author": "chuckeles", "description": "My first attempt to use a distance map", "tags": ["raymarching", "map", "distance"], "likes": 2, "viewed": 172, "published": "Public", "date": "1423996631", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// credits go to iq and his awesome articles about distance maps:\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\n\n// --- GLOBALS ---\n\nconst float e = 2.71828182845904523536028747135266249;\n\n// sun\nconst vec3 sun = vec3(-0.2, 1.0, 0.5);\n\nconst vec3 amb = vec3(0.01);\nconst vec3 bg = vec3(0.01, 0.01, 0.014);\n\n// --- FUNCTIONS ---\n\n// http://www.java-gaming.org/index.php?topic=28018.0\nfloat Rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 Map(in vec3 p) {\n    float id = 0.0;\n    float d = 1000.0;\n    \n    // sphere\n    float s = length(p - vec3(0.0, 0.5, 0.0)) - 0.6;\n    // block\n    float b = length(max(abs(p - vec3(0.0, 0.5, 0.0)) - vec3(0.4), 0.0)) - 0.1;\n    \n    // main shape\n    float m = max(b, -s);\n    if (m < d) {\n        d = m;\n        id = 1.0;\n    }\n    \n    // sphere 2\n    float x = length(p - vec3(0.0 + pow(sin(iTime * 0.6), 3.0), 0.5, 0.0 + pow(sin(iTime * 0.6 + 0.7853), 3.0))) - 0.3\n        + 0.01 * sin(p.x * 50.0) * sin(p.y * 50.0) * sin(p.z * 50.0);\n    if (x < d) {\n        d = x;\n        id = 3.0;\n    }\n    \n    // ground\n    float g = p.y;\n    if (g < d) {\n        d = g;\n        id = 2.0;\n    }\n    \n    return vec2(d, id);\n}\n\nvec3 MapNormal(in vec3 p) {\n    vec3 e = vec3(0.0001, 0.0, 0.0);\n    vec3 n;\n    \n    n.x = Map(p + e.xyy).x - Map(p - e.xyy).x;\n    n.y = Map(p + e.yxy).x - Map(p - e.yxy).x;\n    n.z = Map(p + e.yyx).x - Map(p - e.yyx).x;\n    \n    return normalize(n);\n}\n\nvec2 Shoot(in vec3 ro, in vec3 rd) {\n    float t = 0.2;\n    for (int i = 0; i < 256; ++i) {\n        // map\n        vec2 m = Map(ro + rd * t);\n        if (m.x < 0.0001)\n            // we hit something\n            return vec2(t, m.y);\n        t += m.x;\n    }\n    return vec2(-1.0, 0.0);\n}\n\nfloat Shadow(in vec3 p, in vec3 n, in vec2 uv) {\n    vec3 ro = p + n * 0.001;\n    vec3 rd = sun;\n    \n    float res = 1.0;\n    float t = Rand(uv) * 0.04 + 0.002;\n    \n    for (int i = 0; i < 64; ++i) {\n        // map\n        float m = Map(ro + rd * t).x;\n        res = min( res, 10.0 * m / t );\n        if(res < 0.0001)\n            break;\n        t += clamp(m, 0.01, 0.02);\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nvec3 Draw(in vec3 ro, in vec3 rd, in vec2 uv) {\n    // background\n    vec3 c = bg;\n    \n    // intersect the ray with geometry\n    vec2 res = Shoot(ro, rd);\n    \n    if (res.y > 0.5) {\n        // hit point\n        vec3 p = ro + rd * res.x;\n        \n        // normal\n        vec3 n = MapNormal(p);\n        \n        vec3 r = reflect(sun, n);\n        float sp = 0.0;\n        float s = 1.0;\n        \n        if (res.y < 1.5) {\n            // main shape\n            c = vec3(1.0, 0.2, 0.2);\n            sp = 0.8;\n            s = 4.0;\n        }\n        \n        else if (res.y < 2.5) {\n            // ground\n            c = vec3(0.4);\n        }\n        \n        else if (res.y < 3.5) {\n            // sphere 2\n            c = vec3(0.1, 0.3, 1.0);\n            sp = 1.0;\n            s = 20.0;\n        }\n        \n        // light\n        float dif = max(dot(n, sun), 0.0);\n        float shd = 0.0;\n        if (dif > 0.0)\n            shd = Shadow(p, n, uv);\n        float spe = sp * max(pow(max(dot(r, rd), 0.0), s), 0.0) * dif;\n        \n        c = clamp((spe + dif * c) * shd + amb * c * smoothstep(-1.5, 1.0, n.y), 0.0, 1.0);\n        \n        // fog\n        float f = pow(e, -pow(res.x*0.3, 2.0));\n        c = mix(bg, c, f);\n    }\n    \n    return c;\n}\n\n// --- MAIN ---\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // uv coords\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uv2 = (uv * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);\n    \n    // create a ray\n    float d = 2.0;\n    vec3 ro = vec3(cos(iTime * 0.1) * d, 1.1, sin(iTime * 0.1) * d);\n    vec3 ta = vec3(0.0, 0.5, 0.0);\n    \n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n    vec3 vv = normalize(cross(uu, ww));\n    \n    vec3 rd = normalize(uv2.x * uu + uv2.y * vv + 2.0 * ww);\n    \n    // get color\n    vec3 color = Draw(ro, rd, uv);\n    \n    // gamma\n    color = sqrt(color);\n    \n    // output\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ls3zf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[423, 477, 497, 497, 569], [571, 571, 592, 592, 1295], [1297, 1297, 1324, 1324, 1551], [1553, 1553, 1589, 1589, 1839], [1841, 1841, 1889, 1889, 2255], [2257, 2257, 2304, 2322, 3502], [3521, 3521, 3578, 3595, 4215]], "test": "valid"}
{"id": "4lsGzl", "name": "melon blobs", "author": "zevanrosser", "description": "visual experiment", "tags": ["2d", "blobs", "texture", "colors"], "likes": 4, "viewed": 231, "published": "Public", "date": "1424351204", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NUM 8 \n        \n  float rand(vec2 co){ \n    return fract(sin(dot(co.xy, vec2(12.9891,78.233))) * 43754.6453);\n  }\n\n  float ting(float i, vec2 uv, vec2 loc){\n    return smoothstep(0.1, 0.7 + i / 20.0, 1. - atan(distance(uv, loc + vec2(0.2, 0.0))) * 3.);\n  }\n\n  void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    uv.y /= iResolution.x / iResolution.y;\n\n    uv.y -= max(0.0,(iResolution.y - iResolution.x) / iResolution.y);\n\n    float cl = 0.0;\n    float dl = 0.0;\n    float v = 2. - smoothstep(0.0, 1.0, 1.0 - (distance(uv, vec2(0.5, 0.5)))) * 2.;\n\n    float t = cos(iTime);\n\n    for (int i = 0; i < NUM; i++){\n      float fi = float(i);\n      float ty = rand(vec2(fi, 0.9));\n      float tx = 0.1 * fi - 0.1 + 0.03 * cos(iTime + fi);\n      float tcos = cos(iTime * float(i - NUM / 2) * 0.3);\n      float tin = ting(fi * 1.2 * tcos, uv, vec2(tx, ty));\n\n      if (tin > cl) {\n        cl += smoothstep(cl, 1.2, tin);\n      }\n\n      tin = ting(fi * 1.1 * tcos, uv, vec2(tx + 0.01, ty + 0.01));\n\n      if (tin > dl) {\n        dl += smoothstep(dl, 1.1, tin);\n      }\n    }\n\n\n    cl = sin(acos(cl - 0.2));\n    dl = sin(acos(dl - 0.2));\n\n    float j = sin(5.0 * smoothstep(0.3, 1.2, dl));\n\n    cl = max(cl , j * 1.2);\n    cl += rand(fragCoord.xy + iTime) * 0.14;\n    cl -= v * 0.6;\n\n    fragColor = vec4(cl * 1.44, (cl + dl) / 2.3, cl * 0.9, 1.0);\n  }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lsGzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 46, 46, 121], [125, 125, 164, 164, 264], [268, 268, 325, 325, 1406]], "test": "valid"}
{"id": "4lsGzX", "name": "2D_Oxlamon_Sun", "author": "Oxlamon", "description": "2D Sun based on https://www.shadertoy.com/view/lsf3RH by", "tags": ["2d", "sun"], "likes": 6, "viewed": 373, "published": "Public", "date": "1423847336", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// based on https://www.shadertoy.com/view/lsf3RH by\n// trisomie21 (THANKS!)\n// My apologies for the ugly code.\n\nfloat snoise(vec3 uv, float res)\t// by trisomie21\n{\n\tconst vec3 s = vec3(1e0, 1e2, 1e4);\n\t\n\tuv *= res;\n\t\n\tvec3 uv0 = floor(mod(uv, res))*s;\n\tvec3 uv1 = floor(mod(uv+vec3(1.), res))*s;\n\t\n\tvec3 f = fract(uv); f = f*f*(3.0-2.0*f);\n\t\n\tvec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,\n\t\t      \t  uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);\n\t\n\tvec4 r = fract(sin(v*1e-3)*1e5);\n\tfloat r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\tr = fract(sin((v + uv1.z - uv0.z)*1e-3)*1e5);\n\tfloat r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\treturn mix(r0, r1, f.z)*2.-1.;\n}\n\nfloat freqs[4];\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfreqs[0] = texture( iChannel1, vec2( 0.01, 0.25 ) ).x;\n\tfreqs[1] = texture( iChannel1, vec2( 0.07, 0.25 ) ).x;\n\tfreqs[2] = texture( iChannel1, vec2( 0.15, 0.25 ) ).x;\n\tfreqs[3] = texture( iChannel1, vec2( 0.30, 0.25 ) ).x;\n\n\tfloat brightness\t= freqs[1] * 0.25 + freqs[2] * 0.25;\n\tfloat radius\t\t= 0.24 + brightness * 0.2;\n\tfloat invRadius \t= 1.0/radius;\n\t\n\tvec3 orange\t\t\t= vec3( 0.8, 0.65, 0.3 );\n\tvec3 orangeRed\t\t= vec3( 0.8, 0.35, 0.1 );\n\tfloat time\t\t= iTime * 0.1;\n\tfloat aspect\t= iResolution.x/iResolution.y;\n\tvec2 uv\t\t\t= fragCoord.xy / iResolution.xy;\n\tvec2 p \t\t\t= -0.5 + uv;\n\tp.x *= aspect;\n\n\tfloat fade\t\t= pow( length( 2.0 * p ), 0.7 );\n\tfloat fVal1\t\t= 1.0 - fade;\n\tfloat fVal2\t\t= 1.0 - fade;\n\t\n\tfloat angle\t\t= atan( p.x, p.y ) * 1.0;\n\tfloat dist\t\t= length(p);\n\tvec3 coord\t\t= vec3( angle, dist, time * 0.1 );\n\t\n\tfloat newTime1\t= abs( snoise( coord + vec3( 0.0, -time * ( 0.35 + brightness * 0.001 ), time * 0.015 ), 15.0 ) );\n\tfloat newTime2\t= abs( snoise( coord + vec3( 0.0, -time * ( 0.15 + brightness * 0.001 ), time * 0.015 ), 45.0 ) );\t\n\tfor( int i=1; i<=7; i++ ){\n\t\tfloat power = pow( 2.0, float(i+1) );\n\t\tfVal1 += ( 0.5 / power ) * snoise( coord + vec3( 0.0, -time, time * 0.2 ), ( power * ( 10.0 ) * ( newTime1 + 1.0 ) ) );\n\t\tfVal2 += ( 0.5 / power ) * snoise( coord + vec3( 0.0, -time, time * 0.2 ), ( power * ( 25.0 ) * ( newTime2 + 1.0 ) ) );\n\t}\n\t\n\tfloat corona\t\t= pow( fVal1 * max( 1.1 - fade, 0.0 ), 2.0 ) * 50.0;\n\tcorona\t\t\t\t+= pow( fVal2 * max( 1.1 - fade, 0.0 ), 2.0 ) * 50.0;\n\tcorona\t\t\t\t*= 1.2 - newTime1;\n\tvec3 sphereNormal \t= vec3( 0.0, 0.0, 1.0 );\n\tvec3 dir \t\t\t= vec3( 0.0 );\n\tvec3 center\t\t\t= vec3( 0.5, 0.5, 1.0 );\n\tvec3 starSphere\t\t= vec3( 0.0 );\n\t\n\tvec2 sp = -1.0 + 2.0 * uv;\n\tsp.x *= aspect;\n\tsp *= ( 2.0 - brightness );\n  \tfloat r = dot(sp,sp);\n\tfloat f = (1.0-sqrt(abs(1.0-r)))/(r) + brightness * 0.5;\n\tif( dist < radius ){\n\t\tcorona\t\t\t*= dist * invRadius;\n  \t\tvec2 newUv;\n \t\tnewUv.x = sp.x*f;\n  \t\tnewUv.y = sp.y*f;\n\t\tnewUv += vec2( time, 1.0 );\n\t\t\n\t\tvec3 texSample \t= texture( iChannel0, newUv ).rgb;\n\t\tfloat uOff\t\t= ( texSample.g * brightness * 4.5 + time );\n\t\tvec2 starUV\t\t= newUv + vec2( uOff, 0.0 );\n\t\tstarSphere\t\t= texture( iChannel0, starUV ).rgb;\n\t}\n\t\n\tfloat starGlow\t= min( max( 1.0 - dist * ( 1.0 - brightness ), 0.0 ), 1.0 );\n\t//fragColor.rgb\t= vec3( r );\n\tfragColor.rgb\t= \n        vec3( f * ( 0.35 + brightness * 0.3 ) * orange ) +\n         starSphere \n        + corona * orange * 0.1\n        + starGlow * orangeRed;\n\tfragColor.a\t\t= 1.0;\n}\n\n", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lsGzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[113, 113, 164, 164, 690], [709, 709, 766, 766, 3249]], "test": "error"}
{"id": "4lX3DB", "name": "Chains", "author": "frutbunn", "description": "My first ray marching shader.", "tags": ["3d"], "likes": 9, "viewed": 909, "published": "Public", "date": "1424692938", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// http://www.letsdive.in/2014/05/18/glsl---raymarching/\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// http://www.iquilezles.org/www/articles/smin/smin.htm\n\n#define PI 3.14159265358979323846\n\n#define MAX_DISTANCE \t\t100.\n#define MARCHING_STEP_INC \t.65\n#define EPSILON \t\t\t0.01\n\n#define MAX_COLOR_BLEED \t.5\n\n#define MAX_STEPS \t\t\t70\n\n#define ANIMATION_SPEED\t\t15.\n\n#define LIGHT_BRIGHTNESS\t2.\n\n/*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\n */\n\n// Current pixel color + z buffer depth (probably not a good way to add different colors\n// to the depth field, but works)!\nfloat zdepth = 10000.;\nvec3 current_color = vec3(0.);\n\n/*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\n */\n\n// Linear displacement timer - probably a faster way of doing this, but works!\nfloat timer(float seconds, float min_val, float max_val) {\n\treturn ( (mod(iTime, seconds) * (max_val - min_val)) / seconds ) + min_val;\n}\n\nvec3 rot_x(vec3 p, float rad) {\n\tfloat c = cos(rad); float s = sin(rad);\n\treturn vec3(p.x, p.y*c+p.z*s, -p.y*s+p.z*c);\n}\n\nvec3 rot_y(vec3 p, float rad) {\n\tfloat c = cos(rad); float s = sin(rad);\n\treturn vec3(p.x*c+p.z*s, p.y, -p.x*s+p.z*c);\n}\n\nvec3 rot_z(vec3 p, float rad) {\n\tfloat c = cos(rad); float s = sin(rad);\n\treturn vec3(p.x*c+p.y*s, -p.x*s+p.y*c, p.z);\n}\n\n/*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\n */\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat smin( float a, float b )\n{\n\tfloat k =68.7;\n    \n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nvec3 opTwist( vec3 p )\n{\n#\tdefine TWIST 0.11\n    \n\tfloat c = cos(TWIST*p.z+TWIST);\n\tfloat s = sin(TWIST*p.z+TWIST);\n\tmat2 m = mat2(c,-s,s,c);\n\n    return vec3(m*p.xy,p.z);\n}\n\n/*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\n */\n\n// Current pixel color within the scene - will be blended with texture below.\n// Probably a better way of doing this, but it works!\nvoid zcolor(float new, vec3 color) {\n\tfloat d = smoothstep(new-MAX_COLOR_BLEED, new+MAX_COLOR_BLEED, zdepth);\n\tzdepth= new*(d) + zdepth*(1.-d);\n    current_color = (1.-d)*current_color + (d)*color;\n}\n\nfloat scene1(vec3 p) {\n   \tconst vec3 c = vec3(2.);\n    \n\tp= opTwist(p);\n\n\tp.x-=2.;\n    vec3 r = mod(p, c)-.5*c;\n\tfloat o1 = sdTorus(r, vec2(.545, .05));\n\tzcolor(o1, vec3(.6,.7, 0.8));\n    \n\tp.z+=5.;\n\tp = rot_z(p, PI/2.);\n    r = mod(p, c)-.5*c;\n\tfloat o2 = sdTorus(r, vec2(.545, .05));\n\tzcolor(o2, vec3(1.,.7, 0.4));\n    \n\treturn smin(o1, o2);\n}\n\nfloat get_distance(vec3 p) {\n\treturn scene1(p);\n}\n\nfloat march(vec3 ray_origin, vec3 ray_direction) {\n    float d = 0.0;\n\n\tfor (int i = 0; i < MAX_STEPS; i++) {\n\t\tvec3 np = ray_origin + ray_direction*d;\n\t\tfloat s = get_distance(np);\n\n        if (s < EPSILON)\n            return d;\n\n        d += s*MARCHING_STEP_INC;\n\n        if (d > MAX_DISTANCE) return MAX_DISTANCE;\n\t}\n\treturn MAX_DISTANCE;\n}\n\nvec3 calc_normal(vec3 p) {\n\tfloat d0 = get_distance(p);\n    \n\tfloat dX = get_distance(p - vec3(EPSILON, 0.0, 0.0));\n\tfloat dY = get_distance(p - vec3(0.0, EPSILON, 0.0));\n\tfloat dZ = get_distance(p - vec3(0.0, 0.0, EPSILON));\n\n\treturn normalize(vec3(dX-d0, dY-d0, dZ-d0));\n}\n\nvec4 texture_pixel (sampler2D t, vec3 p, vec3 n, float scale) {\n\treturn texture(t, p.yz * scale) * abs (n.x)\n\t + texture(t, p.xz * scale) * abs (n.y)\n\t + texture(t, p.xy * scale) * abs (n.z);\n}\n\nvec2 correct_aspect_ratio(in vec2 fragCoord) {\n\tvec2 uv = (fragCoord.xy / iResolution.xy) - vec2(.5);\n    uv.x *= iResolution.x/iResolution.y;\n    \n    return uv;\n}\n\n/*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\t*\n */\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat eye_z=sin(mod(iTime, 100.))*4.;\n    \n    // Eye position and light position:\n\tvec3 eye_pos = vec3(0.0, 0.0, -3.+eye_z);\n    vec3 light = vec3(1., 1., -3.+eye_z);\n    \n    // For calc'n the surface normal:\n    vec3 forward = \tvec3(.0, .0, 1.);\n\tvec3 up = \t\tvec3(.0, 1., .0);\n    \n    // Timers for animation/rotation etc:\n    float rx = timer(ANIMATION_SPEED ,0., PI*2.);    \n    float ry = timer(ANIMATION_SPEED ,0., PI*2.);\n    \n\tfloat rz = timer(20. ,0., PI*2.);\n\n\tfloat wait = timer(ANIMATION_SPEED*2., 0., 2.);\n\n    // Spin off into the scene for half the animation cycle:\n\tif (floor(wait)==1.) {\n\t\teye_pos = rot_x(eye_pos, rx);\n\t\tforward = rot_x(forward, rx);\n\t\tup = rot_x(up, rx);\n\t\tlight = rot_x(light, rx);\n\n        eye_pos = rot_y(eye_pos, ry);\n\t\tforward = rot_y(forward, ry);\n\t\tup = rot_y(up, ry);\n\t\tlight = rot_y(light, ry);       \n\t}\n\n    // Rotate:\n\teye_pos = rot_z(eye_pos, rz);\n\tforward = rot_z(forward, rz);\n\tup = rot_z(up, rz);\n\n    // Rotate light:\n    light = rot_z(light, rz);\n    light = rot_x(light, rz);\n\n    // Ray march:\n    vec2 uv = correct_aspect_ratio(fragCoord);\n    \n\tvec3 right = cross(up, forward);\n\tvec3 ray_dir = normalize(up * uv.y + right*uv.x + forward);\n    \n\tfloat d = march(eye_pos, ray_dir);\n    \n\t// Store final color after marching as calc_normal for lighting below will ruin final pixel\n\t// color calc'd:\n\tvec3 finalcolor = current_color;    \n    \n    // Calc lighting if pixel falls within scene:\n    if (d < MAX_DISTANCE) {\n   \t\t// Light direction:     \n  \t\tvec3 p = (eye_pos+ray_dir*d);\n  \t\tvec3 p_normal = calc_normal(p);\n  \t\tvec3 light_dir = -normalize(light-p);\n\n        // Calc attenuation:\n        //\n        // Mental note to self:\n        // The biger K is the quicker light weakens with distance - don't forget location of \n        // light source - I won't fall for that one again!\n#\t\tdefine K .155\n        float attenuation = 1. / (1. + K*pow( length(light -(p)), 2.0));\n        \n        // Calc ambient light:\n        const float ambient_component = .1;\n        float ambient = 1.;\n  \n        // Calc diffuse light:\n        const float diffuse_component = .5;\n\t\tfloat diffuse = max(0.,  dot(light_dir, p_normal));\n        \n        // Calc specular light:\n        const float specular_component = .4;\n        const float material = 15.;\n        vec3 reflected_light_dir = reflect(-light_dir, p_normal);\n        float specular = min(1., pow( max(dot(reflected_light_dir, light_dir), 0.0), material) );\n        \n        // Calc final light density (the min allows components to be cranked up a bit):\n\t\tfloat light_density = min(1., \n         (diffuse*diffuse_component + ambient*ambient_component + specular*specular_component) );\n        light_density*= attenuation;\n        \n\t\t// Calc final color:        \n        finalcolor *= vec3(light_density);\n        \n        // Add texture:\n        const float texture_component = 1.3;\n        const float texture_scale = .5;\n        vec4 tex_col = texture_pixel(iChannel0, p, (p_normal), texture_scale);\n        const float color_component = 1.7;\n\n        // Final color within the scene:\n        finalcolor = finalcolor*color_component + tex_col.rgb*texture_component*(light_density*LIGHT_BRIGHTNESS);\n \t} else {\n        // Final color outside the scene:\n        finalcolor = vec3(0.01);\n    }\n\n\tfragColor = vec4(finalcolor, 1.);\n}", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lX3DB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[699, 778, 836, 836, 915], [917, 917, 948, 948, 1037], [1039, 1039, 1070, 1070, 1159], [1161, 1161, 1192, 1192, 1281], [1333, 1333, 1366, 1366, 1431], [1433, 1433, 1465, 1465, 1557], [1559, 1559, 1583, 1583, 1732], [1784, 1916, 1952, 1952, 2115], [2117, 2117, 2139, 2139, 2463], [2465, 2465, 2493, 2493, 2514], [2516, 2516, 2566, 2566, 2859], [2861, 2861, 2887, 2887, 3135], [3137, 3137, 3200, 3200, 3330], [3332, 3332, 3378, 3378, 3496], [3548, 3548, 3605, 3605, 6945]], "test": "error"}
{"id": "4lX3RB", "name": "kali-traps d", "author": "bergi", "description": "The kali-set - between round and hashy. \nNo other random function was hurt in the making of this film. ", "tags": ["3d", "raymarching", "fractal", "volume", "kali", "blackwhite", "hybrid"], "likes": 114, "viewed": 4850, "published": "Public API", "date": "1423568433", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// \"kali-traps d\"\n// showing the different shape and scale relationships\n// between geographically different parts in the same parameter set\n// probably very float-accuracy dependent\n// in this case i'd say, less is more \n\n// License aGPLv3\n// 2015, stefan berke\n\n\nconst int NUM_TRACE = 40;\n\n\n// \"kali-set\" by Kali\nvec4 average;\nvec4 kali(in vec3 p)\n{\n    average = vec4(0.);\n\tfloat mag;\n    for (int i=0; i<31; ++i)\n    {\n        mag = dot(p, p);\n        p = abs(p) / mag;\n        average += vec4(p, mag);\n        p -= vec3(.5, .5, 1.1);\n    }\n\taverage /= 31.;\n    mag = dot(p, p);\n    p = abs(p) / mag;\n    return vec4(p, mag);\n}\n\n// volume marcher with surface trap\nvec3 ray_color(vec3 pos, vec3 dir, float stp)\n{\n    vec3 p, col = vec3(0.);\n\tfloat t = 0., ld = 1.;\n\tfor (int i=0; i<NUM_TRACE; ++i)\n\t{\n\t\tp = pos + t * dir;\n\t\tvec4 k = kali(p);\n\n\t\tfloat pick = abs(k.x - .9);\n\t\tfloat mx = smoothstep(0.02, 0., abs(average.y-0.448));\n\t\tfloat bright = 1. / (1. + pick * (1.-0.9*mx) * 200.);\n\n        col += vec3(1., 1.-mx, 1.-mx) * bright;\n\n\t\tt += clamp(pick * stp, 0.00001, 0.0002);\n\t}\n    \n    return col / float(NUM_TRACE) * 5.;\n}\n\n\n\n// a few hand-picked turns\nvec3 path(float ti, float pid)\n{\n    vec3 pos = vec3(0.);\n    float id = mod(pid, 4.);\n    if (id < 1.)\n    {\n    \tti /= 4.;\n    \tpos = vec3(12.966, 1.211, 1.603)\n        \t\t\t+ 0.003 * vec3(sin(ti), 0.2*sin(ti*2.1) + sin(ti/3.1), cos(ti));\n\t}\n    else if (id < 2.)\n    {\n        ti /= 30.;\n        pos = vec3(22., 1.86, 1.61)\n            + 0.04 * vec3(sin(-ti), 0.2*sin(ti*2.+1.6), 2.*cos(ti));\n    }\n    else if (id < 3.)\n    {\n        pos = vec3(8., 1.9, 1.6)\n            + 0.003 * vec3(sin(ti), 0.2*sin(ti*1.1) + sin(ti/3.1), ti);\n    }\n    else if (id < 4.)\n    {\n        ti /= 5.;\n        pos = vec3(1.2, 1.9, 1.92)\n            + 0.002 * vec3(sin(ti), 0.4*sin(ti*0.3), cos(ti));\n    }\n    // add some variation\n    id = floor(mod(pid, 12.));\n    if (id >= 3.)\n    \tpos += 0.0002*id;\n\treturn pos;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.y * 2.;\n    \n    float ti = iTime;\n    \n    // image id\n    float pid = ti/3. + uv.x;\n    \n    vec3 pos = path(ti, pid);\n    vec3 npos = path(ti+0.3, pid);\n    \n    vec3 dir = normalize(vec3(uv, 2. - .3 * length(uv)));\n    vec3 fwd = normalize(npos - pos);\n    vec3 up = normalize(vec3(0,.1,0));\n    // is it left or right? i always forget..\n    vec3 orth = normalize(cross(up, fwd));\n\tup = normalize(cross(fwd,orth));\n    dir = mat3(orth,up,fwd) * dir;\n    \n    fragColor = vec4(ray_color(pos, dir, 0.00035), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lX3RB.jpg", "access": "shaders20k", "license": "agpl-3.0", "functions": [[330, 330, 352, 352, 632], [634, 670, 717, 717, 1133], [1137, 1164, 1196, 1196, 1965], [1967, 1967, 2024, 2024, 2604]], "test": "valid"}
{"id": "4lX3Rj", "name": "Ancient Temple", "author": "Kali", "description": "A neverending visit to a fractal temple.", "tags": ["3dfractal"], "likes": 87, "viewed": 2099, "published": "Public", "date": "1423183233", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Ancient Temple\" by Kali\n\nconst int Iterations=14;\nconst float detail=.00002;\nconst float Scale=2.;\n\nvec3 lightdir=normalize(vec3(0.,-0.3,-1.));\n\n\nfloat ot=0.;\nfloat det=0.;\n\nfloat hitfloor;\nfloat hitrock;\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat tt;\n\nfloat de(vec3 pos) {\n\thitfloor=0.;\n\thitrock=0.;\n\tvec3 p=pos;\n\tp.xz=abs(.5-mod(pos.xz,1.))+.01;\n\tfloat DEfactor=1.;\n\tot=1000.;\n\tfor (int i=0; i<Iterations; i++) {\n\t\tp = abs(p)-vec3(0.,2.,0.);  \n\t\tfloat r2 = dot(p, p);\n\t\tfloat sc=Scale/clamp(r2,0.4,1.);\n\t\tp*=sc; \n\t\tDEfactor*=sc;\n\t\tp = p - vec3(0.5,1.,0.5);\n\t}\n    float rr=length(pos+vec3(0.,-3.03,1.85-tt))-.017;\n    float fl=pos.y-3.013;\n    float d=min(fl,length(p)/DEfactor-.0005);\n\td=min(d,-pos.y+3.9);\n    d=min(d,rr);\n    if (abs(d-fl)<.0001) hitfloor=1.;\n    if (abs(d-rr)<.0001) hitrock=1.;\n    return d;\n}\n\n\n\nvec3 normal(vec3 p) {\n\tvec3 e = vec3(0.0,det,0.0);\n\t\n\treturn normalize(vec3(\n\t\t\tde(p+e.yxx)-de(p-e.yxx),\n\t\t\tde(p+e.xyx)-de(p-e.xyx),\n\t\t\tde(p+e.xxy)-de(p-e.xxy)\n\t\t\t)\n\t\t);\t\n}\n\nfloat shadow(vec3 pos, vec3 sdir) {\n\t\tfloat totalDist =2.0*det, sh=1.;\n \t\tfor (int steps=0; steps<30; steps++) {\n\t\t\tif (totalDist<1.) {\n\t\t\t\tvec3 p = pos - totalDist * sdir;\n\t\t\t\tfloat dist = de(p)*1.5;\n\t\t\t\tif (dist < detail)  sh=0.;\n\t\t\t\ttotalDist += max(0.05,dist);\n\t\t\t}\n\t\t}\n\t\treturn max(0.,sh);\t\n}\n\nfloat calcAO( const vec3 pos, const vec3 nor ) {\n\tfloat aodet=detail*80.;\n\tfloat totao = 0.0;\n    float sca = 10.0;\n    for( int aoi=0; aoi<5; aoi++ ) {\n        float hr = aodet + aodet*float(aoi*aoi);\n        vec3 aopos =  nor * hr + pos;\n        float dd = de( aopos );\n        totao += -(dd-hr)*sca;\n        sca *= 0.75;\n    }\n    return clamp( 1.0 - 5.0*totao, 0.0, 1.0 );\n}\n\n\n\nfloat kset(vec3 p) {\n\tp=abs(.5-fract(p*20.));\n\tfloat es, l=es=0.;\n\tfor (int i=0;i<13;i++) {\n\t\tfloat pl=l;\n\t\tl=length(p);\n\t\tp=abs(p)/dot(p,p)-.5;\n\t\tes+=exp(-1./abs(l-pl));\n\t}\n\treturn es;\t\n}\n\nmat2 rot;\n\nvec3 light(in vec3 p, in vec3 dir) {\n\tfloat hf=hitfloor;\n\tfloat hr=hitrock;\n\tvec3 n=normal(p);\n\tfloat sh=clamp(shadow(p, lightdir)+hf+hr,.4,1.);\n\tfloat ao=calcAO(p,n);\n\tfloat diff=max(0.,dot(lightdir,-n))*sh*1.3;\n\tfloat amb=max(0.2,dot(dir,-n))*.4;\n\tvec3 r = reflect(lightdir,n);\n\tfloat spec=pow(max(0.,dot(dir,-r))*sh,10.)*(.5+ao*.5);\n\tfloat k=kset(p)*.18; \n\tvec3 col=mix(vec3(k*1.1,k*k*1.3,k*k*k),vec3(k),.45)*2.;\n\tvec3 pp=p-vec3(0.,3.03,tt);\n    pp.yz*=rot;\n    if (hr>0.) col=vec3(.9,.8,.7)*(1.+kset(pp*2.)*.3);\n    col=col*ao*(amb*vec3(.9,.85,1.)+diff*vec3(1.,.9,.9))+spec*vec3(1,.9,.5)*.7;\t\n\treturn col;\n}\n\n\nvec3 raymarch(in vec3 from, in vec3 dir) \n{\n\tfloat t=iTime;\n\tfloat cc=cos(t*.03); float ss=sin(t*.03);\n    rot=mat2(cc,ss,-ss,cc);\n    vec2 lig=vec2(sin(t*2.)*.6,cos(t)*.25-.25);\n\tfloat fog,glow,d=1., totdist=glow=fog=0.;\n\tvec3 p, col=vec3(0.);\n\tfloat ref=0.;\n\tfloat steps;\n\tfor (int i=0; i<130; i++) {\n\t\tif (d>det && totdist<3.5) {\n\t\t\tp=from+totdist*dir;\n\t\t\td=de(p);\n\t\t\tdet=detail*(1.+totdist*55.);\n\t\t\ttotdist+=d; \n\t\t\tglow+=max(0.,.02-d)*exp(-totdist);\n\t\t\tsteps++;\n\t\t}\n\t}\n\t//glow/=steps;\n\tfloat l=pow(max(0.,dot(normalize(-dir),normalize(lightdir))),10.);\n\tvec3 backg=vec3(.8,.85,1.)*.25*(2.-l)+vec3(1.,.9,.65)*l*.4;\n\tfloat hf=hitfloor;\n\tif (d<det) {\n\t\tcol=light(p-det*dir*1.5, dir); \n\t\tif (hf>0.5) col*=vec3(1.,.85,.8)*.6;\n\t\tcol*=min(1.2,.5+totdist*totdist*1.5);\n\t\tcol = mix(col, backg, 1.0-exp(-1.3*pow(totdist,1.3)));\n\t} else { \n\t\tcol=backg;\n\t}\n\tcol+=glow*vec3(1.,.9,.8)*.34;\n\tcol+=vec3(1,.8,.6)*pow(l,3.)*.5;\n\treturn col; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\ttt=iTime*.05;\n    vec2 uv = fragCoord.xy / iResolution.xy*2.-1.;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec2 mouse=(iMouse.xy/iResolution.xy-.5);\n\tfloat t=iTime*.15;\n\tfloat y=(cos(iTime*.1+3.)+1.);\n\tif (iMouse.z<1.) mouse=vec2(sin(t*2.),cos(t)+.3)*.15*(.5+y)*min(1.,iTime*.1);\n\tuv+=mouse*1.5;\n\tuv.y-=.1;\n\t//uv+=(texture(iChannel1,vec2(iTime*.15)).xy-.5)*max(0.,h)*7.;\n\tvec3 from=vec3(0.0,3.04+y*.1,-2.+iTime*.05);\n\tvec3 dir=normalize(vec3(uv*.85,1.));\n\tvec3 color=raymarch(from,dir); \n\t//col*=length(clamp((.6-pow(abs(uv2),vec2(3.))),vec2(0.),vec2(1.)));\n\tcolor*=vec3(1.,.94,.87);\n\tcolor=pow(color,vec3(1.2));\n\tcolor=mix(vec3(length(color)),color,.85)*.95;\n\tcolor+=vec3(1,.85,.7)*pow(max(0.,.3-length(uv-vec2(0.,.03)))/.3,1.5)*.65;\n\tfragColor = vec4(color,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lX3Rj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[210, 210, 251, 251, 344], [357, 357, 377, 377, 921], [925, 925, 946, 946, 1097], [1099, 1099, 1134, 1134, 1396], [1398, 1398, 1446, 1446, 1776], [1780, 1780, 1800, 1800, 1968], [1981, 1981, 2017, 2017, 2592], [2595, 2595, 2638, 2638, 3524], [3526, 3526, 3583, 3583, 4345]], "test": "valid"}
{"id": "4lXGRl", "name": "Albert's Canyon", "author": "dr2", "description": "Yet another relativistic shader (do a keyword search for previous\nexamples). Here our flying aces are hitting lightspeed (not to be taken\nseriously); use the mouse to change speed. The distortion of the visual field is the Penrose-Terrell effect.\n\n", "tags": ["flight", "relativity"], "likes": 15, "viewed": 1101, "published": "Public API", "date": "1424107832", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Albert's Canyon\" by dr2 - 2015\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Rather than changing the flying speed we change the value of c (the\n// speed of light); this is of course forbidden, but who cares (the\n// Einstein centenary exhibition in Berne used a similar trick)?\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float s = 0.;\n  float a = 1.;\n  for (int i = 0; i < 6; i ++) {\n    s += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return s;\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s = vec3 (0.);\n  float a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 e = vec3 (0.2, 0., 0.);\n  float s = Fbmn (p, n);\n  vec3 g = vec3 (Fbmn (p + e.xyy, n) - s,\n     Fbmn (p + e.yxy, n) - s, Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h)\n{\n  return max (length (p.xy - vec2 (rhi *\n     clamp (p.x / rhi, -1., 1.), 0.)) - rlo, abs (p.z) - h);\n}\n\nint idObj, idObjGrp;\nmat3 flyerMat[3], flMat;\nvec3 flyerPos[3], flPos, qHit, qHitTransObj, sunDir;\nfloat fusLen, flameLen, tCur;\nconst float dstFar = 150.;\nconst int idCkp = 11, idFus = 12, idEng = 13, idWngI = 14, idWngO = 15,\n   idTlf = 16, idRfl = 17;\n\nvec3 SkyBg (vec3 rd)\n{\n  const vec3 sbCol = vec3 (0.1, 0.2, 0.5);\n  vec3 col;\n  col = sbCol + 0.25 * pow (1. - max (rd.y, 0.), 8.);\n  return col;\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  float cloudFac;\n  if (rd.y > 0.) {\n    ro.x += 10. * tCur;\n    vec2 p = 0.02 * (rd.xz * (150. - ro.y) / rd.y + ro.xz);\n    float w = 0.8;\n    float f = 0.;\n    for (int j = 0; j < 4; j ++) {\n      f += w * Noisefv2 (p);\n      w *= 0.5;\n      p *= 2.;\n    }\n    cloudFac = clamp (3. * f * rd.y - 0.3, 0., 1.);\n  } else cloudFac = 0.;\n  float s = max (dot (rd, sunDir), 0.);\n  col = SkyBg (rd) + (0.35 * pow (s, 6.) + 0.65 * min (pow (s, 256.), 0.3));\n  col = mix (col, vec3 (1.), cloudFac);\n  return col;\n}\n\nvec3 TrackPath (float t)\n{\n  return vec3 (30. * sin (0.035 * t) * sin (0.012 * t) * cos (0.01 * t) +\n     26. * sin (0.0032 * t), 1. + 3. * sin (0.021 * t) * sin (1. + 0.023 * t), t);\n}\n\nfloat GrndHt (vec2 p)\n{\n  float u;\n  u = max (abs (p.x - TrackPath (p.y).x) - 2.5, 0.);\n  u *= u;\n  return SmoothMin ((0.2 + 0.003 * u) * u, 12., 1.) +\n     0.5 * Noisefv2 (0.6 * p) + 4. * Fbm2 (0.1 * p) - 3.;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = 0; j < 150; j ++) {\n    p = ro + s * rd;\n    h = p.y - GrndHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.25, 0.4 * h) + 0.005 * s;\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = 0; j < 6; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      h = step (0., p.y - GrndHt (p.xz));\n      sLo += h * (s - sLo);\n      sHi += (1. - h) * (s - sHi);\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p, float d)\n{\n  float ht = GrndHt (p.xz);\n  vec2 e = vec2 (max (0.01, 0.00001 * d * d), 0.);\n  return normalize (vec3 (ht - GrndHt (p.xz + e.xy), e.x,\n     ht - GrndHt (p.xz + e.yx)));\n}\n\nvec4 GrndCol (vec3 p, vec3 n)\n{\n  const vec3 gCol1 = vec3 (0.3, 0.25, 0.25), gCol2 = vec3 (0.1, 0.1, 0.1),\n     gCol3 = vec3 (0.3, 0.3, 0.1), gCol4 = vec3 (0., 0.5, 0.);\n  vec3 col, wCol, bCol;\n  float cSpec;\n  wCol = mix (gCol1, gCol2, clamp (1.4 * (Noisefv2 (p.xy +\n     vec2 (0., 0.3 * sin (0.14 * p.z)) *\n     vec2 (2., 7.3)) + Noisefv2 (p.zy * vec2 (3., 6.3))) - 1., 0., 1.));\n  bCol = mix (gCol3, gCol4, clamp (0.7 * Noisefv2 (p.xz) - 0.3, 0., 1.));\n  col = mix (wCol, bCol, smoothstep (0.4, 0.7, n.y));\n  cSpec = clamp (0.3 - 0.1 * n.y, 0., 1.);\n  return vec4 (col, cSpec);\n}\n\nfloat GrndSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float sh, d, h;\n  sh = 1.;\n  d = 2.;\n  for (int i = 0; i < 10; i++) {\n    p = ro + rd * d;\n    h = p.y - GrndHt (p.xz);\n    sh = min (sh, 20. * h / d);\n    d += 4.;\n    if (h < 0.01) break;\n  }\n  return clamp (sh, 0., 1.);\n}\n\nfloat FlameDf (vec3 p, float dHit)\n{\n  vec3 q;\n  float d, wr;\n  q = p;\n  q.x = abs (q.x);\n  q -= fusLen * vec3 (0.5, 0., -0.55);\n  q.z -= - 1.1 * flameLen;\n  wr = 0.5 * (q.z / flameLen - 1.);\n  d = PrCapsDf (q, 0.045 * (1. + 0.65 * wr) * fusLen, flameLen);\n  if (d < dHit) {\n    dHit = d;\n    qHitTransObj = q;\n  }\n  return dHit;\n}\n\nfloat TransObjDf (vec3 p)\n{\n  float dHit = dstFar;\n  dHit = FlameDf (flyerMat[0] * (p - flyerPos[0]), dHit);\n  dHit = FlameDf (flyerMat[1] * (p - flyerPos[1]), dHit);\n  dHit = FlameDf (flyerMat[2] * (p - flyerPos[2]), dHit);\n  return dHit;\n}\n\nfloat TransObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = TransObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.01 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 FlameCol (vec3 col)\n{\n  vec3 q = qHitTransObj;\n  float fFac = 0.3 + 0.7 * clamp (mod (3. * (q.z / flameLen + 1.) +\n     0.7 * Noisefv2 (10. * q.xy + tCur * vec2 (200., 210.)) +\n     170. * tCur, 1.), 0., 1.);\n  float c = clamp (0.5 * q.z / flameLen + 0.5, 0., 1.);\n  return fFac * vec3 (c, 0.4 * c * c * c, 0.4 * c * c) +\n     (1. - c) * col;\n}\n\nfloat FlyerDf (vec3 p, float dHit)\n{\n  vec3 pp, q;\n  float d, wr, ws;\n  q = p;\n  q.yz = Rot2D (q.yz, 0.07 * pi);\n  d = PrCapsDf (q - fusLen * vec3 (0., 0.05, 0.),\n      0.11 * fusLen, 0.1 * fusLen);\n  if (d < dHit) { dHit = d;  idObj = idCkp;  qHit = q; }\n  q = p;\n  q -= fusLen * vec3 (0., 0., -0.12);\n  wr = -0.05 + q.z / fusLen;\n  q.xz *= 0.8;\n  d = PrCapsDf (q, (0.14 - 0.14 * wr * wr) * fusLen, fusLen);\n  if (d < dHit + 0.01) {\n    dHit = SmoothMin (dHit, d, 0.01);  idObj = idFus;  qHit = q;\n  }\n  pp = p;\n  pp.x = abs (pp.x);\n  q = pp - fusLen * vec3 (0.5, 0., -0.2);\n  ws = q.z / (0.4 * fusLen);\n  wr = ws - 0.1;\n  d = PrCylDf (q, (0.05 - 0.035 * ws * ws) * fusLen, 0.45 * fusLen);\n  d = min (d, PrCylDf (q, (0.09 - 0.05 * wr * wr) * fusLen, 0.35 * fusLen));\n  if (d < dHit) { dHit = d;  idObj = idEng;  qHit = q; }\n  q = pp - fusLen * vec3 (0.1, 0., -0.15);\n  q.xz = Rot2D (q.xz, 0.12 * pi);\n  wr = 1. - 0.6 * q.x / (0.4 * fusLen);\n  d = PrFlatCylDf (q.zyx, 0.25 * wr * fusLen, 0.02 * wr * fusLen, 0.4 * fusLen);\n  if (d < dHit) { dHit = d;  idObj = idWngI;  qHit = q; }\n  q = pp - fusLen * vec3 (0.6, 0., -0.37);\n  q.xy = Rot2D (q.xy, -0.1 * pi);\n  q -= fusLen * vec3 (0.07, 0.01, 0.);\n  q.xz = Rot2D (q.xz, 0.14 * pi);\n  wr = 1. - 0.8 * q.x / (0.2 * fusLen);\n  d = PrFlatCylDf (q.zyx, 0.06 * wr * fusLen, 0.005 * wr * fusLen, 0.2 * fusLen);\n  if (d < dHit) { dHit = d;  idObj = idWngO;  qHit = q; }\n  q = pp - fusLen * vec3 (0.03, 0., -0.85);\n  q.xy = Rot2D (q.xy, -0.24 * pi);\n  q -= fusLen * vec3 (0.2, 0.02, 0.);\n  wr = 1. - 0.5 * q.x / (0.17 * fusLen);\n  q.xz = Rot2D (q.xz, 0.1 * pi);\n  d = PrFlatCylDf (q.zyx, 0.1 * wr * fusLen, 0.007 * wr * fusLen, 0.17 * fusLen);\n  if (d < dHit) { dHit = d;  idObj = idTlf;  qHit = q; }\n  return dHit;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, gp;\n  float d, dHit, cSep;\n  dHit = dstFar;\n  idObjGrp = 1 * 256;\n  dHit = FlyerDf (flyerMat[0] * (p - flyerPos[0]), dHit);\n  idObjGrp = 2 * 256;\n  dHit = FlyerDf (flyerMat[1] * (p - flyerPos[1]), dHit);\n  idObjGrp = 3 * 256;\n  dHit = FlyerDf (flyerMat[2] * (p - flyerPos[2]), dHit);\n  dHit *= 0.8;\n  cSep = 10.;\n  gp.z = cSep * floor (p.z / cSep) + 0.5 * cSep;\n  gp.x = TrackPath (gp.z).x;\n  gp.y = GrndHt (gp.xz);\n  q = p - gp;\n  d = 0.8 * PrCapsDf (q.xzy, 0.4, 0.1);\n  if (d < dHit) { dHit = d;  idObj = 1;  qHit = p; }\n  return dHit;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * vec3 (v.y, v.z, v.w));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float d, h, sh;\n  sh = 1.;\n  d = 0.02;\n  for (int i = 0; i < 40; i++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, 20. * h / d);\n    d += 0.02;\n    if (h < 0.001) break;\n  }\n  return clamp (sh, 0., 1.);\n}\n\nvec4 FlyerCol (vec3 n)\n{\n  vec3 col;\n  float spec;\n  spec = 1.;\n  int ig = idObj / 256;\n  int id = idObj - 256 * ig;\n  vec3 qq = qHit / fusLen;\n  float br = 4. + 3.5 * cos (10. * tCur);\n  col = vec3 (0.7, 0.7, 1.);\n  if (qq.y > 0.) col *= 0.3;\n  else col *= 1.2;\n  if (id == idTlf) {\n    if (abs (qq.x) < 0.1)\n       col *= 1. - SmoothBump (-0.005, 0.005, 0.001, qq.z + 0.05);\n    if (qq.z < - 0.05)\n       col *= 1. - SmoothBump (- 0.005, 0.005, 0.001, abs (qq.x) - 0.1);\n  }\n  if (id == idCkp && qq.z > 0.) col = vec3 (0.4, 0.2, 0.);\n  else if (id == idEng) {\n    if (qq.z > 0.36) col = vec3 (1., 0., 0.);\n    else if (qq.z > 0.33) {\n      col = vec3 (0.01);\n      spec = 0.;\n    }\n  } else if (id == idWngO && qq.x > 0.17 ||\n     id == idTlf && qq.x > 0.15 && qq.z < -0.03) col = vec3 (1., 0., 0.) * br;\n  else if (id == idFus && qq.z > 0.81) col = vec3 (0., 1., 0.) * br;\n  idObj = idRfl;\n  return vec4 (col, spec);\n}\n\nvec4 ObjCol (vec3 n)\n{\n  vec4 col4;\n  if (idObj == 1) col4 = vec4 (1., 0.3, 0., 1.) *\n     (0.6 + 0.4 * sin (6. * tCur - 0.1 * qHit.z));\n  else col4 = FlyerCol (n);\n  return col4;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstHit, dstGrnd, dstObj, dstFlame, f, bk, sh;\n  int idObjT;\n  bool isGrnd;\n  dstHit = dstFar;\n  dstGrnd = GrndRay (ro, rd);\n  dstFlame = TransObjRay (ro, rd);\n  idObj = -1;\n  dstObj = ObjRay (ro, rd);\n  idObjT = idObj;\n  if (dstObj < dstFlame) dstFlame = dstFar;\n  isGrnd = false;\n  if (dstObj < dstGrnd) {\n    ro += dstObj * rd;\n    dstHit = dstObj;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    col4 = ObjCol (vn);\n    if (idObj == idRfl) col4.rgb = 0.5 * col4.rgb +\n       0.3 * SkyCol (ro, reflect (rd, vn));\n    sh = ObjSShadow (ro, sunDir);\n    bk = max (dot (vn, - normalize (vec3 (sunDir.x, 0., sunDir.z))), 0.);\n    col = col4.rgb * (0.2 + 0.1 * bk  + sh * max (dot (vn, sunDir), 0.)) +\n       sh * col4.a * pow (max (0., dot (sunDir, reflect (rd, vn))), 128.);\n  } else {\n    dstHit = dstGrnd;\n    if (dstHit < dstFar) {\n      ro += dstGrnd * rd;\n      isGrnd = true;\n    } else col = SkyCol (ro, rd);\n  }\n  if (isGrnd) {\n    vn = VaryNf (3.2 * ro, GrndNf (ro, dstHit), 1.5);\n    col4 = GrndCol (ro, vn);\n    sh = GrndSShadow (ro, sunDir);\n    bk = max (dot (vn, - normalize (vec3 (sunDir.x, 0., sunDir.z))), 0.);\n    col = col4.rgb * (0.2 + 0.1 * bk  + sh * max (dot (vn, sunDir), 0.)) +\n       sh * col4.a * pow (max (0., dot (sunDir, reflect (rd, vn))), 128.);\n  }\n  if (dstFlame < dstFar) col = FlameCol (col);\n  if (dstHit < dstFar) {\n    f = dstHit / dstFar;\n    col = mix (col, 0.8 * SkyBg (rd), clamp (1.03 * f * f, 0., 1.));\n  }\n  return sqrt (clamp (col, 0., 1.));\n}\n\nvoid FlyerPM (float t, float vu)\n{\n  vec3 fpF, fpB, vel, acc, ort, cr, sr, va;\n  float tInterp, dt, vy, m1, m2, tDisc, s, vFly;\n  tInterp = 5.;\n  tDisc = floor ((t) / tInterp) * tInterp;\n  s = (t - tDisc) / tInterp;\n  vFly = 18.;\n  t *= vFly;\n  dt = 2.;\n  flPos = TrackPath (t);\n  fpF = TrackPath (t + dt);\n  fpB = TrackPath (t - dt);\n  vel = (fpF - fpB) / (2. * dt);\n  vy = vel.y;\n  vel.y = 0.;\n  acc = (fpF - 2. * flPos + fpB) / (dt * dt);\n  acc.y = 0.;\n  va = cross (acc, vel) / length (vel);\n  if (vu == 0.) { m1 = 1.;  m2 = 25.; }\n  else { m1 = 0.2;  m2 = 15.; }\n  vel.y = vy;\n  ort = vec3 (- m1 * asin (vel.y / length (vel)),\n     atan (vel.z, vel.x) - 0.5 * pi, m2 * length (va) * sign (va.y));\n  if (vu > 0.) { ort.xz *= -1.;  ort.y += pi; }\n  cr = cos (ort);\n  sr = sin (ort);\n  flMat = mat3 (cr.z, - sr.z, 0., sr.z, cr.z, 0., 0., 0., 1.) *\n     mat3 (1., 0., 0., 0., cr.x, - sr.x, 0., sr.x, cr.x) *\n     mat3 (cr.y, 0., - sr.y, 0., 1., 0., sr.y, 0., cr.y);\n  flPos.y = (1. - s) * GrndHt (TrackPath (tDisc).xz) +\n     s * GrndHt (TrackPath (tDisc + tInterp).xz) + 7.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 canvas = iResolution.xy;\n  vec2 uv = 2. * fragCoord.xy / canvas - 1.;\n  vec2 uvs = uv;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  vec4 mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  vec3 ro, rd, col;\n  float tGap, zmFac, beta, cPhi, w, cLen;\n  sunDir = normalize (vec3 (cos (0.031 * tCur), 1.5, sin (0.031 * tCur)));\n  fusLen = 1.;\n  flameLen = 0.25 * fusLen;\n  tGap = 0.3;\n  tCur += tGap;\n  FlyerPM (tCur, 0.);  flyerPos[0] = flPos;  flyerMat[0] = flMat;\n  FlyerPM (tCur, 0.);  flyerPos[1] = flPos;  flyerMat[1] = flMat;\n  FlyerPM (tCur + 0.5 * tGap, 0.);  flyerPos[2] = flPos;  flyerMat[2] = flMat;\n  flyerPos[0].x += 1.2 * fusLen;\n  flyerPos[1].x -= 1.2 * fusLen;\n  FlyerPM (tCur - 0.2 * tGap, -1.);\n  ro = flPos;\n  ro.y += 0.3;\n  zmFac = 1.5;\n  rd = normalize (vec3 (uv, zmFac)) * flMat;\n  w = (mPtr.z > 0.) ? clamp (0.5 + mPtr.y, 0.07, 1.) : 0.9;\n  beta = clamp (pow (w, 0.25), 0.1, 0.999);\n  cPhi = (rd.z - beta) / (1. - rd.z * beta);\n  rd = vec3 (0., 0., cPhi) +\n     sqrt (1. - cPhi * cPhi) * normalize (rd - vec3 (0., 0., rd.z));\n  col = ShowScene (ro, rd);\n  cLen = 0.2;\n  uvs.y = abs (uvs.y - 0.96);\n  if (uvs.y < 0.02 && abs (uvs.x) < cLen) {\n    col = 0.3 * col + 0.5;\n    uvs.x += cLen - 0.01;\n    if (uvs.y < 0.015 && uvs.x > 0. && uvs.x < (2. * cLen - 0.02) *\n       (2. * beta - 1.)) col = vec3 (1., 0.9, 0.5);\n  }\n  fragColor = vec4 (col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lXGRl.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[475, 475, 499, 499, 546], [548, 548, 573, 573, 752], [754, 754, 775, 775, 912], [914, 914, 943, 943, 1145], [1147, 1147, 1186, 1186, 1393], [1395, 1395, 1440, 1440, 1538], [1540, 1540, 1597, 1597, 1680], [1682, 1682, 1712, 1712, 1786], [1788, 1788, 1831, 1831, 1904], [1906, 1906, 1948, 1948, 1999], [2001, 2001, 2060, 2060, 2164], [2422, 2422, 2444, 2444, 2569], [2571, 2571, 2603, 2603, 3123], [3125, 3125, 3151, 3151, 3310], [3312, 3312, 3335, 3335, 3523], [3525, 3525, 3559, 3559, 4096], [4098, 4098, 4129, 4129, 4302], [4304, 4304, 4335, 4335, 4886], [4888, 4888, 4926, 4926, 5163], [5165, 5165, 5201, 5201, 5496], [5498, 5498, 5525, 5525, 5739], [5741, 5741, 5779, 5779, 5959], [5961, 5961, 5987, 5987, 6310], [6312, 6312, 6348, 6348, 8069], [8071, 8071, 8093, 8093, 8643], [8645, 8645, 8678, 8678, 8854], [8856, 8856, 8877, 8877, 9100], [9102, 9102, 9139, 9139, 9350], [9352, 9352, 9376, 9376, 10273], [10275, 10275, 10297, 10297, 10456], [10458, 10458, 10493, 10493, 12016], [12018, 12018, 12052, 12052, 13096], [13098, 13098, 13155, 13155, 14538]], "test": "error"}
{"id": "4tf3Rl", "name": "SHADE A DAY ( 2 / 16 / 2015 ) ", "author": "cabbibo", "description": "Trying out the march function from https://www.shadertoy.com/view/4s2XRd by @nimitz", "tags": ["raytrace"], "likes": 0, "viewed": 331, "published": "Public", "date": "1424117147", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// EVERY THING COOL COMES FROM:`\n//Fast Edge detection by nimitz (twitter: @stormoid)\n//https://www.shadertoy.com/view/4s2XRd\n\n// Also IQ:\n// http://www.iquilezles.org/www/index.htm\n// https://www.shadertoy.com/user/iq\n\n\n#define EDGE_SIZE 0.14\n#define SMOOTH 0.01\n\n#define ITR 120\n#define FAR 40.\n#define time iTime\n\nvec4 spherePos[10];\n\nfloat hash( float n ) { return fract(sin(n)*43758.5453); }\n\n// exponential smooth min (k = 32);\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat opBlend( vec2 d1, vec2 d2 )\n{\n\n    return smin( d1.x , d2.x , 8.);\n}\n\nfloat sdSphere( vec3 p, float s){\n\treturn length( p ) - s * 1.;\n}\n\nvec2 map(vec3 pos)\n{\n\t\n   \tvec2 res = vec2( 10000. , 0.);// vec2( sdPlane( pos - vec3( 0. , -1. , 0. )), 0.0 );\n   \n    for( int i = 0; i < 10; i++ ){\n   \t\t\n        vec2 res2 = vec2( sdSphere( (pos - spherePos[i].xyz) , spherePos[i].w ) , float(i) + 1.);\n        //vec2 res2 = vec2( udRoundBox( (pos - spherePos[i].xyz) , vec3( spherePos[i].w  ) ,spherePos[i].w * .2 ) , float(i) + 1.);\n   \t\tres.x = opBlend( res ,  res2 );\n        \n   \t}\n    \n   \treturn res;\n    \t\n}\n\n\n\n\n//Fast Edge detection by nimitz (twitter: @stormoid)\n//https://www.shadertoy.com/view/4s2XRd\n/*\t\n\tKeeping track of min distance, then, when the min distance \n\tis both under a given threshold and starts increasing (meaning that\n\ta fold was just passed) then I mark that pixel as an edge. The min\n\tdistance can then be smoothed allowing for arbitrarily smooth edges.\n*/\nvec4 calcIntersection(in vec3 ro, in vec3 rd)\n{\n\tfloat precis = 0.01;\n    float h=precis*2.0;\n    vec2 d = vec2(0.,10000.);\n    float md = 1.;\n    float id = 0.;;\n    bool stp = false;\n    for( int i=0; i<ITR; i++ )\n    {\n        if( abs(h)<precis || d.x>=FAR ) break;\n        d.x += h;\n\t   \tvec2 res = map(ro+rd*d.x);\n        if (!stp) \n        {\n            md = min(md,res.x);\n            if (h < EDGE_SIZE && h < res.x && i>0)\n            {\n                stp = true;\n                d.y = d.x;\n            }\n        }\n        h = res.x;\n        id = res.y;\n    }\n    \n    if (stp) md = smoothstep(EDGE_SIZE-SMOOTH, EDGE_SIZE+0.01, md);\n    else md = 1.;\n\treturn vec4(d, md, id);\n}\n\n\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 0.3 + 10.0*mouseX;\n\tcamPos = vec3(3.5*sin(an),1.0,3.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n    \n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<30; i++ )\n    {\n        float hr = 0.01 + 0.612*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.5;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\n\t\n    for( int i =0; i < 10; i++ ){\n        \n        float x = 1. * cos(iTime *.13 * (float( i )+2.));\n        float y = 1. * sin(iTime * .075 * (float( i )+4.));\n        float z = 1. * sin(iTime * .1 * (float( i )+3.3));\n        float r = .2 * ( sin( iTime * .1  *( float( i) +1.))+2.);\n    \tspherePos[i] = vec4( x ,  y ,  z , r  );\n        \n        \n    }\n\n        \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m.x );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n    vec4 res = calcIntersection( ro , rd  );\n\n    vec3 col = vec3( 1. , 0. , 0. );\n    \n    if ( res.x < FAR )\n    {\n        vec3 pos = ro+res.x*rd;\n        float d = distance(ro,pos);\n        vec3 nor= calcNormal(pos);\n        \n        float amb = calcAO( pos,  nor );\n        float match = max( 0. , dot( -nor , rd ));\n\n      \n        col = vec3(amb * match )*vec3( 1., .2, .2 ) *(1.-res.z); //* vec3(res.z); //(nor * .5 +.5);\n        col += ( nor * .5 +.5)* vec3( 0.2 , .2 , 1.) * vec3(amb * (1.-match) );\n    }else{\n    \n        vec3 pos = ro+res.x*rd;\n        float d = distance(ro,pos);\n        vec3 nor= calcNormal(pos);\n       \n        float bg = 1. - res.z;\n       // col = nor * .5 + .5;\n \t\tcol = vec3( 1., .8 , .2 ) * vec3( bg ); //+ vec3(1. , 0. , 0. ) * res.z;\n        \n    }\n\n\t\n\tfragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tf3Rl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[338, 338, 361, 361, 396], [398, 434, 475, 475, 546], [548, 548, 583, 583, 622], [624, 624, 657, 657, 689], [691, 691, 711, 711, 1158], [1163, 1531, 1578, 1578, 2217], [2221, 2252, 2316, 2316, 2494], [2496, 2496, 2579, 2579, 2692], [2694, 2807, 2838, 2838, 3064], [3066, 3066, 3108, 3108, 3408]], "test": "valid"}
{"id": "4tf3zs", "name": "Worm bubbles", "author": "rotmoset", "description": "Messing around", "tags": ["2d"], "likes": 3, "viewed": 3247, "published": "Public", "date": "1424195346", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Refactored by FabriceNeyret2\nvoid mainImage( out vec4 o, vec2 p ) {\n    vec2 R = iResolution.xy;\n    float t = iTime;\n    \n    for(int x=0; x<20; x++) \n    \tfor(int y=0; y<20; y++)\n        {\n            vec4 S = 1. + sin(t*vec4(1,3,5,11));\n            length( p - vec2(x,y)*R/20. ) / R.y < S.w/66.  ?  o = S/2. : o ;                       \n            t += .1;\n        }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tf3zs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 32, 70, 70, 375]], "test": "valid"}
{"id": "4tfGDB", "name": "ngWaves02", "author": "netgrind", "description": "cool", "tags": ["waves", "mobius", "netgrind", "hyperbolic"], "likes": 7, "viewed": 1429, "published": "Public API", "date": "1424660600", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = 5.0;\n    float i = iTime*.5;\n    vec4 o = vec4(0.0);\n\tvec2 uv = fragCoord.xy / iResolution.xy*scale;\n    uv-= scale*0.5;\n    \n    mat2 m = mat2(cos(uv.x-i),sin(sin(uv.x)+i),cos(uv.y+i),cos(uv.y-i*.5));\n    uv = uv*m;\n    \n    float dist = length(uv);\n    float a = atan(uv.y,uv.x);\n    o.r = mod(dist,1.0);\n    o.g = mod(a,0.5)*2.0;\n    o.b = mod(uv.x*uv.y,1.0);\n    \n    o.rgb = (1.0-cos(o.rgb-0.5))*5.0;\n    \n\tfragColor = o;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tfGDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[16, 16, 73, 73, 520]], "test": "valid"}
{"id": "4tfGWj", "name": "electro bands", "author": "echophon", "description": "Electro remix  shadeaday.  ", "tags": ["procedural", "2d", "op"], "likes": 1, "viewed": 130, "published": "Public", "date": "1425021918", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// a very \"I'm still learning\" edit of \n// electro-prim's by @AlexWDunn\n// https://www.shadertoy.com/view/Mll3WS\n//\nprecision mediump float;\n\n#define PI (3.1416)\n\nfloat electro(vec2 pos, float d, float f, float o, float s, float a, float b)\n{\n    float ti = iTime * s * 0.5;\n    \n    float theta = atan(pos.y,pos.x);\n    \n    float amp = smoothstep(0.0, 1.0, (sin(theta+iTime*2.0)*0.5+0.5)-b)*a;\n    float phase = d - sin(theta * f + o + ti *2.5) * amp*0.5;\n    \n    return sin(clamp(phase, 0.0, PI*122.0) + PI/122.0) + 0.999999;\n}\n\nfloat circle(vec2 pos, float r, float a, float o, float s, float f, float b, float t)\n{\n    float d = length(pos); \n    return 1.0 - smoothstep(0.0, t, electro(pos, d/r, f, o, s, a, b));\n}\n\nfloat shape(vec2 pos, float r, float a, float o, float s, float f, float b, float t)\n{\n    float ci = circle(pos+vec2(0.0,-0.20),r,a,o,s,f,b,t);\n    return ci;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n   const float radius = 0.00950;\n   const float amp = 40.0; \n   const float freq = 2.0;\n   const float band = 0.175;\n   const float speed = 0.001;\n   const float thickness = 4.0;\n    \n   vec2 pos = fragCoord.xy / max(iResolution.x, iResolution.y) * vec2(2.0) - vec2(1.0);\n   pos -= vec2(0.0, -0.5);\n    \n    \n   vec3 color = vec3(0.0);\n   color.r = shape(pos, radius, amp, 0.0 *PI, speed*0.01, freq, band, thickness);\n   color.g = shape(pos, radius, amp, 0.1 *PI, speed*0.02,   freq, band, thickness);\n   color.b = shape(pos, radius, amp, 0.2 *PI, speed*0.03, freq, band, thickness);\n\n   fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tfGWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[166, 166, 245, 245, 534], [536, 536, 623, 623, 724], [726, 726, 812, 812, 887], [889, 889, 947, 947, 1566]], "test": "valid"}
{"id": "4tfGzj", "name": "Oil on the Water", "author": "Kali", "description": "A 2D fractal with a 3D lighting technique", "tags": ["2d", "fractal"], "likes": 43, "viewed": 1179, "published": "Public", "date": "1423184602", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime*.05\n\n\n#define width .2\n\nfloat thick=0.;\nfloat pix;\nfloat zoom = .5;\n\n\nfloat formula(vec2 z) {\n\tfloat ot=1000.;\n\tfor (int i=0; i<11; i++) {\n\t\tfloat dz=dot(z,z);\n\t\tz=abs(z*2.)/dz-1.;\n\t\tot=min(ot,dz);\n\t}\n\tfloat h=.014/(max(0.,width-ot)/width*.9+.1);\n\tthick+=max(0.,1.-h);\n\treturn h;\n}\n\nvec3 normal(vec2 z) {\n\tvec2 d=vec2(pix,0.);\n\tvec3 n=normalize(cross( //get normal\n\tvec3(d.x*2.,0.,formula(z-d.xy)-formula(z+d.xy)),\n\tvec3(0.,d.x*2.,formula(z-d.yx)-formula(z+d.yx))));\n\treturn n;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 pos = fragCoord.xy / iResolution.xy;\n\tvec2 uv=pos-.5;\n\tuv.x*=iResolution.x/iResolution.y;\n\tzoom*=1.+sin(time*2.)*.5;\n\tvec2 luv=uv;\n\tuv+=vec2(sin(time),cos(time))*2.;\n\tuv+=sin(uv*30.+time*200.)*.0015;\n\tuv*=zoom;\n\tluv*=zoom;\n\tpix=1./iResolution.x*zoom;\n\tvec2 d=vec2(pix,0.);\n\tvec3 n= normal(uv-d.xy)+normal(uv+d.xy);\n\t     n+=normal(uv-d.yx)+normal(uv+d.yx);\n\t\t n/=4.;\n\tthick/=16.;\n\tvec2 refr=-n.xy*.08;\n\tvec3 tex=texture(iChannel0,((uv+refr)*3.+vec2(time,0.))).xyz+.75;\n\tvec3 colo=tex*mix(vec3(.35,.55,1.)*2.5,vec3(1.,.65,.15)*.25,sqrt(thick));\t\n\tvec3 lightdir=normalize(vec3(1.,.5,2.));\n\tcolo+=max(0.,dot(-n,lightdir))*.4;\n\tcolo+=pow(max(0.,dot(reflect(-n,vec3(0.,0.,-1.)),lightdir)),50.)*.6;\n\tcolo+=pow(max(0.,dot(reflect(vec3(0.,0.,-1.),-n),lightdir)),50.)*.2;\n\tcolo=pow(colo,vec3(1.5))*2.;\n\tfragColor = vec4(colo,1.0);\n}", "image_inputs": [{"id": "XdXGzr", "previewfilepath": "/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tfGzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 89, 112, 112, 300], [302, 302, 323, 323, 498], [501, 501, 558, 558, 1388]], "test": "error"}
{"id": "4tl3RX", "name": "TrippySines", "author": "tajjada", "description": "A simple colorful hallucinative pattern based on sine functions.\n", "tags": ["simple", "colors", "trippy", "lsd", "hallucination", "pattern", "sines"], "likes": 5, "viewed": 241, "published": "Public", "date": "1423827926", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define t (iTime+1234.5)\n#define r iResolution\n#define w(a,b,c,d,e) abs(sin(a*sin(b*t)*sin(c*t)+dot(uv,vec2(cos(d*t),sin(d*t)))*(sin(e*t)+15.0)))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / r.xy;\n    uv.x *= r.x/r.y;\n\tfragColor = vec4(\n        w(17.,.2,.3,.07,.4),\n        w(13.,.5,.2,.05,.5),\n        w(11.,.7,.5,.03,.3), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tl3RX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[147, 147, 204, 204, 370]], "test": "valid"}
{"id": "4tl3z2", "name": "SHADE A DAY ( 2 / 10 / 2015 )", "author": "cabbibo", "description": "I made a mistake, but don't know what it was...\nI think its in the map function though....", "tags": ["raytrace", "bug"], "likes": 2, "viewed": 246, "published": "Public", "date": "1423593754", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ALL TAKEN FROM IQs AMAZING SITE / TUTORIALS / SHADERS:\n// http://www.iquilezles.org/www/index.htm\n// https://www.shadertoy.com/user/iq\n\n\nconst float MAX_TRACE_DISTANCE = 10.0;           // max trace distance\nconst float INTERSECTION_PRECISION = 0.001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 140;\n\t\nvec4 spherePos[10];\n    \n\n\nvec4 texCube( sampler2D sam, in vec3 p, in vec3 n, in float k )\n{\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n    vec3 w = pow( abs(n), vec3(k) );\n\treturn (x*w.x + y*w.y + z*w.z) / (w.x+w.y+w.z);\n}\n\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdPlane( vec3 p )\n{\n    \n    float f = sin( p.z * 5. ) * sin( p.x * 5. );\n    //f = 5. * smoothstep( abs(f) , 0.4 , 0.8 );\n\treturn p.y - (abs( f) * .3)/ max( 1. , pow( length( p ), 1.));\n\n}\n\n\nfloat sdSphere( vec3 p, float s , float offset)\n{\n    //p.x += 0.1*sin( 60.0*p.y * p.x * p.z * abs(sin(offset *iTime)) + iTime );\n    //p.y += 0.1*sin( 60.0*p.y * p.x * p.z * abs(sin(offset *iTime * .4)) + iTime );\n  //  p.y += 0.1*sin( 10.0*p.z + iTime *10.);\n  //  p.z += 0.1*sin( 30.0*p.x + iTime *3.);\n    /*p.x += 0.5*sin( 3.0*p.y + iTime );\n    p.y += 0.5*sin( 3.0*p.z + iTime );\n    p.z += 0.5*sin( 3.0*p.x + iTime );\n    p.x += 0.5*sin( 3.0*p.y + iTime );\n    p.y += 0.5*sin( 3.0*p.z + iTime );\n    p.z += 0.5*sin( 3.0*p.x + iTime );\n    p.x += 0.5*sin( 3.0*p.y + iTime );\n    p.y += 0.5*sin( 3.0*p.z + iTime );\n    p.z += 0.5*sin( 3.0*p.x + iTime );*/\n\n    float d1 = length(p) - .1*smoothstep(0.0,1.0,iTime);;\n    d1 *= .8;\t\n    \n   // vec3 nP = vec3( x , y , z );\n    return d1 -s;\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n\n    float d1 = -p.y-c.z;\n    float d2 = max( dot(q,c.xy), p.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n\n}\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 0.3 + 10.0*mouseX;\n\tcamPos = vec3(3.5*sin(an),1.0,3.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n\n\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \n\treturn (d1.x<d2.x) ? d1 : d2;\n    \n}\n\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos ){  \n    \n    float field = length( pos - vec3( 0. , 0. , 1.)) - 5.;\n    \n    vec2 res = vec2( field , 1. );\n   \t/*vec2 res = vec2( sdPlane( pos - vec3( 0. , -1. , 0. )), 0.0 );\n   \n    for( int i = 0; i < 10; i++ ){\n   \t\t\n        vec2 res2 = vec2( sdSphere( (pos - spherePos[i].xyz) , spherePos[i].w  , float( i )) , float(i) + 1.);\n        //vec2 res2 = vec2( udRoundBox( (pos - spherePos[i].xyz) , vec3( spherePos[i].w  ) ,spherePos[i].w * .2 ) , float(i) + 1.);\n   \t\tres = opU( res ,  res2 );\n        \n   \t}*/\n    \n   \treturn res;\n    \n}\n\n\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t );\n        h = m.x;\n        t += h;\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n}\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n    \n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<50; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 20.*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.612*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.5;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n\n    for( int i =0; i < 10; i++ ){\n        \n        float x = 1. * cos(iTime *.13 * (float( i )+2.));\n        float y = 1. * sin(iTime * .075 * (float( i )+4.));\n        float z = 1. * sin(iTime * .1 * (float( i )+3.3));\n        float r = .1 * ( sin( iTime * .1  *( float( i) +1.))+2.);\n    \tspherePos[i] = vec4( x ,  y+1. ,  z , r  );\n        \n        \n    }\n\n    \n    \n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    m.x = sin(iTime * .01) + cos(( iTime + 4. )* .135 );\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m.x );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n    vec2 res = calcIntersection( ro , rd  );\n    \n    \n    vec3 col = vec3( 0. , 0. , 0. ); \n   \n    // If we have hit something lets get real!\n    if( res.y > -.5 ){\n\n    \tvec3 pos = ro + rd * res.x;\n    \tvec3 nor = calcNormal( pos );\n        \n        vec3 pat = texCube( iChannel0, 0.5*pos, nor, 10.0 ).xyz;\n        col = pat * normalize(vec3(1. ) + vec3( abs(sin( res.y )) , .3  , abs(cos(res.y)) ));\n        if( res.y < .5 ){ col = vec3(1.) * pat; }\n        \n        float AO = calcAO( pos , nor );\n        \n        vec3 light1 =  normalize(vec3( 0. , 1. , 1. ));\n        vec3 color1 = vec3( .1 , .05 , .02 );\n        color1 *=10.;\n        float shadow1 = softshadow( pos , light1 ,  0.1 , 20. );\n        \n        vec3 light2 =  normalize(vec3( 1. , 1. , -1. ));\n        vec3 color2 = vec3( .02, .05 , 0.1 );\n        color2 *= 8.;\n        float shadow2 = softshadow( pos , light2 ,  0.1 , 20. );\n        \n        vec3 light3 =  normalize(vec3( 1. , 1. , 0. ));\n        vec3 color3 = vec3( .02, .1 , .05 );\n        color3 *= 8.;\n        float shadow3 = softshadow( pos , light3 ,  0.1 , 20. );\n        \n        \n\n   \n        // vec3 = calcColor( ro , rd );\n    \n        color1 *= max( 0. , dot( light1 , nor ) );\n        color1 *= shadow1;\n        \n        color2 *= max( 0. , dot( light2 , nor ) );\n        color2 *= shadow2;\n        \n        color3 *= max( 0. , dot( light3 , nor ) );\n        color3 *= shadow3;\n        \n\n        //col = vec3( AO );\n        col *= color1 + color2 + color3; //* ((nor * .5 ) +.5);\n\n        col *= AO;// * .4 * ( nor * .5 + .5 );\n        \n        if( res.y < .5 ){\n            \n            //float f = sin( pos.z * 5. ) * sin( pos.x * 5. );\n            //col *= 5. * smoothstep( abs(f) , 0.4 , 0.8 );\n           // col *= abs( f );\n           // col /= pow( length( pos ), 4.);\n        }\n        \n        col = color1 + color2 + color3;\n    }\n    // apply gamma correction\n    col = pow( col, vec3(0.4545) );\n\n    fragColor = vec4( col , 1. );\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tl3z2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[360, 360, 425, 425, 609], [612, 612, 657, 657, 697], [699, 699, 724, 724, 894], [897, 897, 946, 1557, 1691], [1693, 1693, 1731, 1731, 1902], [1904, 1935, 1999, 1999, 2177], [2179, 2179, 2262, 2262, 2375], [2380, 2474, 2503, 2503, 2546], [2548, 2632, 2653, 2653, 3192], [3196, 3196, 3244, 3244, 3711], [3713, 3826, 3857, 3857, 4083], [4086, 4086, 4160, 4160, 4421], [4424, 4424, 4466, 4466, 4765]], "test": "error"}
{"id": "4tlGDB", "name": "opdots", "author": "echophon", "description": "day 3 shadeAday - op dots - still learning basics ", "tags": ["moire", "magnetic", "op"], "likes": 1, "viewed": 131, "published": "Public", "date": "1424905030", "time_retrieved": "2021-10-01T00:00:00", "image_code": "uniform float time;\nuniform vec2 resolution;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat aspect = iResolution.x / iResolution.y;\n\tvec2 pos = fragCoord.xy / iResolution.x - vec2(0.5, 0.5 / aspect);\n\tvec2 m = vec2(sin(iTime/10.0) - 0.5, (cos(iTime/3.0) - 0.5) / aspect);\n\n\tvec2 p1 = pos - m/5.0;\n\tvec2 p2 = pos + m/5.0;\n    float a = atan(pos.x, pos.y);\n    //p1 *= a;\n\tfloat color = 0.0;\n    float color2 = 0.0;\n\n\tvec2 p3 = pos;\n\tcolor = pow(sin(pow(length(p1) / length(p2), 1.1) + 0.5 * p1.y), 3.0);\n    \n\tcolor2 = pow(sin(pow(length(p1) / length(p2), 1.2) + 0.5 * p1.x), 3.0);\n\tif (color > 0.01) color = 0.01 / color;\n\t\telse color = 1.0;\n\tif (color2 > 0.01) color2 = 0.01 / color2;\n\t\telse color2 = 1.0;\t\n\t\n\t//color = (color * (1.0 - sin(pow(length(p3), 0.25) * 4.0))) * 0.5;\n    //color = mix(1.0, 0.5, sin(length(p1)));\n\tfragColor = vec4(color, color2, color, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tlGDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 47, 104, 104, 893]], "test": "error"}
{"id": "4tlGRl", "name": "Mandelbox cored", "author": "kig", "description": "Crawling towards realtime, shadeADay for 2015-02-18", "tags": ["shadeaday"], "likes": 8, "viewed": 239, "published": "Public", "date": "1424301490", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float mandelbox(vec3 w) {\n    float scale = 2.0;\n    float c = 2.0;\n    float r = 0.5;\n\n    for (int i = 0; i < 20; i++) {\n        if (w.x > 1.0) {\n            w.x = 2.0 - w.x;\n        } else if (w.x < -1.0) {\n            w.x = -2.0 - w.x;\n        }\n        if (w.y > 1.0) {\n            w.y = 2.0 - w.y;\n        } else if (w.y < -1.0) {\n            w.y = -2.0 - w.y;\n        }\n        if (w.z > 1.0) {\n            w.z = 2.0 - w.z;\n        } else if (w.z < -1.0) {\n            w.z = -2.0 - w.z;\n        }\n        float lw = length(w);\n        \n        if (lw > 1000.0) {\n            return float(i)/2.0;\n        }\n\n        if (lw < r) {\n            w = w / (r*r);;\n        } else if (lw < 1.0) {\n            w = w / (lw*lw);\n        }\n        w = scale * w + c;\n    }\n    return 0.0;\n}\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);  \n}\n\nvec3 shadeBg(vec3 nml, vec2 fragCoord)\n{\n\tvec2 aspect = vec2(iResolution.x/iResolution.y, 1.0);\n\tvec2 uv = (2.0 * fragCoord.xy / iResolution.xy - 1.0) * aspect;\n\tvec3 bgLight = normalize(vec3(\n\t\tcos(iTime*0.2/0.954929658551372)*4.0, \n\t\t-sin(iTime/1.1936620731892151)*3.0 + 4.0, \n\t\tsin(iTime*0.2/0.954929658551372)*8.0\n\t));\n\tvec3 sun = vec3(2.0, 2.5, 2.0)*0.5;\n\tfloat bgDiff = dot(nml, vec3(0.0, -1.0, 0.0));\n\tfloat sunPow = dot(nml, bgLight);\n\tfloat sp = max(sunPow, 0.0);\n\tvec3 bgCol = max(0.0, bgDiff)*2.0*vec3(0.5,0.4,0.35);\n\tbgCol += max(0.0, -bgDiff)*vec3(0.5, 0.55, 0.6);\n\tbgCol += vec3(0.65, 0.55, 0.5)*((1.5*pow(1.0-abs(bgDiff), 7.0)));\n\tbgCol += sun*(0.5*pow( sp, 3.0)+pow( sp, 256.0));\n\tbgCol += vec3(0.5, 0.2, 0.15)*(pow( sp, 8.0) + pow( sp, abs(bgLight.y)*128.0));\n    //bgCol += vec3(1.9,0.,0.9) * ((1.0-pow(abs(bgDiff), 0.6)) * 0.5);\n\treturn pow(max(vec3(0.0), bgCol), vec3(1.9));\n}\n\nfloat mandelbox_dist(vec3 pos) {\n    vec4 p = vec4(pos, 1.0), p0 = p;\n    float minRad2 = 0.25;\n    vec4 scale = vec4(2.0) / minRad2;\n    float absScalem1 = abs(2.0 - 1.0);\n    float AbsScaleRaisedTo1mIters = pow(abs(2.0), (1.0 - 10.0));\n    for (int i=0; i<10; i++) {\n        p.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;\n        float r2 = dot(p.xyz, p.xyz);\n        p *= clamp(max(minRad2/r2, minRad2), 0.0, 1.0);\n        p = p * scale + p0;\n    }\n    return ((length(p.xyz) - absScalem1) / p.w - AbsScaleRaisedTo1mIters);\n}\n\nfloat scene(vec3 q) {\nmat3 rot = rotationMatrix(normalize(vec3(1.0, -0.5, 0.5)),-iTime*0.5);\nmat3 rot2 = rot*rotationMatrix(normalize(vec3(1.0, 1.5, 0.5)),iTime*4.5);\nvec3 offset = vec3(5.0*sin(iTime*1.7), 5.0*cos(iTime), -5.0+7.0*sin(iTime*1.5));\n    vec3 p = q + offset;\n    float d = length(p)-7.5;\n    if (d > 0.05) {\n        return d;\n    } else {\n    \treturn min(length(p)-5.0, max(-(d+0.5), max(d, mandelbox_dist(rot*p))));\n    }\n}\n\nvec3 normal(vec3 p, float d)\n{\n\tfloat e = 0.005;\n\tfloat dx = scene(vec3(e, 0.0, 0.0) + p) - d;\n\tfloat dy = scene(vec3(0.0, e, 0.0) + p) - d;\n\tfloat dz = scene(vec3(0.0, 0.0, e) + p) - d;\n\treturn normalize(vec3(dx, dy, dz));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = (0.5 - uv) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    float time = 406.9;\n    float a = 0.0;//cos(/3.53423*0.5);\n    float ca = cos(a), sa = sin(a);\n    uv *= mat2(ca, sa, -sa, ca);\n    vec3 ro = vec3(uv*5.0,0.0)+vec3(0,0,-15.0);\n    vec3 rd = normalize(vec3(uv, 2.7));\n    ro += rd * 4.0;\n    vec3 transmit = vec3(1.0);\n    float bounce = 0.0;\n\n    for (int i=0; i<100; i++) {\n        float t = scene(ro);\n        if (t < 0.005+float(i)/100.0*0.15) {\n\t        vec3 nml = normal(ro, t);\n            rd = normalize(reflect(rd, nml));\n            ro += rd * 0.01;\n            transmit *= vec3(0.85, 0.76, 0.85)*0.7 - (bounce == 0.0 ? float(i)/100.0 : 0.0);\n            bounce++;\n            //if (bounce > 1.0 || abs(length(ro) - 5.5) > 0.1) {\n                break;\n            //}\n        } else {\n\t        ro += rd * t;\n        }\n        if (t > 29.0) {\n            break;\n        }\n    }\n\tfragColor = pow(vec4(transmit*shadeBg(-rd, fragCoord), 1.0), vec4(1.2));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tlGRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 784], [786, 786, 831, 831, 1305], [1307, 1307, 1347, 1347, 2203], [2205, 2205, 2237, 2237, 2733], [2735, 2735, 2756, 2756, 3173], [3175, 3175, 3205, 3205, 3400], [3402, 3402, 3459, 3459, 4487]], "test": "valid"}
{"id": "4tlGzS", "name": "Sine deformation", "author": "iq", "description": "Another weird sculpture. It's one cylinder distorted by a composition of sine waves deformation. Similar to [url=https://www.shadertoy.com/view/Mdl3RH]https://www.shadertoy.com/view/Mdl3RH[/url], but in 3D.", "tags": ["3d", "raymarching", "distancefield", "sine"], "likes": 39, "viewed": 3498, "published": "Public API", "date": "1423033513", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvec4 texCube( sampler2D sam, in vec3 p, in vec3 n, in float k )\n{\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n    vec3 w = pow( abs(n), vec3(k) );\n\treturn (x*w.x + y*w.y + z*w.z) / (w.x+w.y+w.z);\n}\n\nvec4 map( vec3 p )\n{\n    p.x += 0.5*sin( 3.0*p.y + iTime*0.4 );\n    p.y += 0.5*sin( 3.0*p.z + iTime*0.4 );\n    p.z += 0.5*sin( 3.0*p.x + iTime*0.4 );\n    p.x += 0.5*sin( 3.0*p.y + iTime*0.3 );\n    p.y += 0.5*sin( 3.0*p.z + iTime*0.3 );\n    p.z += 0.5*sin( 3.0*p.x + iTime*0.3 );\n    p.x += 0.5*sin( 3.0*p.y + iTime*0.2 );\n    p.y += 0.5*sin( 3.0*p.z + iTime*0.2 );\n    p.z += 0.5*sin( 3.0*p.x + iTime*0.2 );\n    p.x += 0.5*sin( 3.0*p.y + iTime*0.1 );\n    p.y += 0.5*sin( 3.0*p.z + iTime*0.1 );\n    p.z += 0.5*sin( 3.0*p.x + iTime*0.1 );\n    float d1 = length(p.xz) - 1.0;\n    d1 *= 0.01;\t\n\n    return vec4( d1, p );\n}\n\nvec4 intersect( in vec3 ro, in vec3 rd, in float maxd )\n{\n    vec3 res = vec3(-1.0);\n\tfloat precis = 0.0001;\n    float t = 1.0;\n    for( int i=0; i<2048; i++ )\n    {\n\t    vec4 tmp = map( ro+rd*t );\n        res = tmp.yzw;\n        float h = tmp.x;\n        if( h<precis||t>maxd ) break;\n        t += h;\n    }\n\n    return vec4( t, res );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.001;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nfloat calcOcc( in vec3 pos, in vec3 nor )\n{\n    const float h = 0.2;\n\tfloat ao = 0.0;\n    for( int i=0; i<8; i++ )\n    {\n        vec3 dir = sin( float(i)*vec3(1.0,7.13,13.71)+vec3(0.0,2.0,4.0) );\n        dir *= sign(dot(dir,nor));\n        float d = map( pos + h*dir ).x;\n        ao += max(0.0,h-d*2.0);\n    }\n    return clamp( 4.0 - 2.5*ao, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = vec2(0.5);\n\tif( iMouse.z>0.0 ) m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n\t\n\tfloat an = 0.1*iTime - 5.0*m.x;\n\tvec3 ro = vec3(4.5*sin(an),0.0,4.5*cos(an));\n    vec3 ta = vec3(0.0,0.0,0.0);\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n    //-----------------------------------------------------\n\n\tvec3 col = vec3(0.1);\n\n    const float maxd = 8.0;\n    vec4  inn = intersect(ro,rd,maxd);\n    float t = inn.x;\n    if( t<maxd )\n    {\n        vec3 tra = inn.yzw;\n\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\n        col = 0.5 + 0.5*sin(tra.y*1.0 + vec3(0.0,1.0,2.0) );\n        vec3 pat = texCube( iChannel0, 0.3*tra, nor, 4.0 ).xyz;\n        col *= pat;\n\n        \n\t\tfloat occ = calcOcc( pos, nor );\n        float fre = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 4.0 );\n        float spe = 0.3*pat.x*max( 0.0, pow( clamp( dot(-rd,nor), 0.0, 1.0), 32.0 ) )*occ;\n        \n\t\tvec3 lin = vec3(0.0);\n        lin += vec3(0.8,0.9,1.0)*occ;\n        lin += 4.0*fre*vec3(1.00,0.80,0.70)*occ;\n        lin *= 1.0 + nor.y;\n        col = col*lin + spe;\n\n        col = 1.1*pow( col, vec3(0.16,0.31,0.4) );\n\t}\n\n    col *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.2 );\n\t   \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tlGzS.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[125, 125, 190, 190, 374], [376, 376, 396, 396, 993], [995, 995, 1052, 1052, 1330], [1332, 1332, 1364, 1364, 1564], [1566, 1566, 1609, 1609, 1920], [1922, 1922, 1979, 1979, 3506]], "test": "error"}
{"id": "4ts3RB", "name": "Weird Fractal 2", "author": "aiekick", "description": "Weird Fractal 2", "tags": ["fractal", "weird", "2"], "likes": 40, "viewed": 1845, "published": "Public API", "date": "1423054185", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//based on shader from coyote => https://www.shadertoy.com/view/ltfGzS\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = mod(iTime, 150.);\n    vec4 p=vec4(fragCoord,0.,1.0)/iResolution.x-.5,r=p-p,q=r;p.y+=.25;\n   \tq.zw-=t*0.7;\n    \n    for (float i=1.; i>0.; i-=.01) {\n\n        float d=0.,s=1.;\n\n        for (int j = 0; j < 4 ; j++)\n            r=max(r*=r*=r=mod(q*s+1.,2.)-1.,r.yzxw),\n            d=max(d,( .27 -length(r)*.6)/s),\n            s*=1.+(0.5*sin(iTime*0.0005)+0.5);\n\n        q+=p*d;\n        \n        fragColor = p-p+i;\n\n        if(d<1e-5) break;\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ts3RB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 129, 129, 588]], "test": "valid"}
{"id": "4ts3zl", "name": "Knot Curves", "author": "dr2", "description": "Simple parametric knot curves.", "tags": ["knots"], "likes": 4, "viewed": 767, "published": "Public API", "date": "1424365424", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Knot Curves\" by dr2 - 2015\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Simple parametric knot curves.\n\n//#define ALL_KNOTS  // cycle through all knots (enable this at your peril)...\n\n#ifdef ALL_KNOTS\n#define KNOT_A\n#define KNOT_B\n#define KNOT_C\n\n#else\n\n#define KNOT_A  // ...OR choose one of the knots\n//#define KNOT_B\n//#define KNOT_C\n#endif\n\nconst float pi = 3.14159;\n\nfloat PrFlatCylDf (vec3 p, vec3 b)\n{\n  return max (length (p.yz - vec2 (b.y *\n     clamp (p.y / b.y, -1., 1.), 0.)) - b.z, abs (p.x) - b.x);\n}\n\nfloat tCur, pScale, dAng, eAng, ei2Ang;\nvec3 qHit, ltDir;\nint idObj;\nconst int nAngInc = 30, nMarStep = 50;\nconst float dstFar = 40.;\nconst vec3 cSize = vec3 (0.3, 0.12, 0.05);\n\n#ifdef ALL_KNOTS\nint idKnot;\n#endif\n\n/* separate distance function for each knot to avoid performance hit (!?) */\n\nmat3 EvalRMat (vec3 r, vec3 rp, vec3 rm)\n{\n  vec3 ddr, vt, vn;\n  vt = normalize (rp - rm);\n  ddr = ei2Ang * (rp + rm - 2. * r);\n  vn = normalize (ddr - vt * dot (vt, ddr));\n  return mat3 (vt, vn, cross (vt, vn));\n}\n\n#ifdef KNOT_A\n\nvec3 KtPointA (float a)  //trefoil knot\n{\n  const vec3\n     gc1 = vec3 ( 41,   36,   0),\n     gs1 = vec3 (-18,   27,   45),\n     gc2 = vec3 (-83, -113,  -30),\n     gs2 = vec3 (-83,   30,  113),\n     gc3 = vec3 (-11,   11,  -11),\n     gs3 = vec3 ( 27,  -27,   27);\n  return gc1 * cos (a)      + gs1 * sin (a) +\n         gc2 * cos (2. * a) + gs2 * sin (2. * a) +\n         gc3 * cos (3. * a) + gs3 * sin (3. * a);\n}\n\nfloat ObjDfA (vec3 p)\n{\n  vec3 q, r, rp, rm;\n  float d, a;\n  d = dstFar;\n  a = 0.;\n  for (int j = 0; j < nAngInc; j ++) {\n    r = KtPointA (a);\n    rp = KtPointA (a + eAng);\n    rm = KtPointA (a - eAng);\n    q = (p - r * pScale) * EvalRMat (r, rp, rm);\n    d = min (d, PrFlatCylDf (q, cSize));\n    a += dAng;\n  }\n  if (d < dstFar) idObj = 1;\n  return d;\n}\n\nfloat ObjRayA (vec3 ro, vec3 rd)\n{\n  float d, dHit;\n  dHit = 0.;\n  for (int j = 0; j < nMarStep; j ++) {\n    d = ObjDfA (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;              \n  }\n  return dHit;\n}\n\n#endif\n\n#ifdef KNOT_B\n\nvec3 KtPointB (float a)  //figure 8 knot\n{\n  const vec3\n     gc1 = vec3 (  32,   94,   16),\n     gs1 = vec3 ( -51,   41,   73),\n     gc2 = vec3 (-104,  113, -211), \n     gs2 = vec3 ( -34,    0,  -39),\n     gc3 = vec3 ( 104,  -68,  -99),\n     gs3 = vec3 ( -91, -124,  -21);\n  return gc1 * cos (a)      + gs1 * sin (a) +\n         gc2 * cos (2. * a) + gs2 * sin (2. * a) +\n         gc3 * cos (3. * a) + gs3 * sin (3. * a);\n}\n\nfloat ObjDfB (vec3 p)\n{\n  vec3 q, r, rp, rm;\n  float d, a;\n  d = dstFar;\n  a = 0.;\n  for (int j = 0; j < nAngInc; j ++) {\n    r = KtPointB (a);\n    rp = KtPointB (a + eAng);\n    rm = KtPointB (a - eAng);\n    q = (p - r * pScale) * EvalRMat (r, rp, rm);\n    d = min (d, PrFlatCylDf (q, cSize));\n    a += dAng;\n  }\n  if (d < dstFar) idObj = 2;\n  return d;\n}\n\nfloat ObjRayB (vec3 ro, vec3 rd)\n{\n  float d, dHit;\n  dHit = 0.;\n  for (int j = 0; j < nMarStep; j ++) {\n    d = ObjDfB (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;              \n  }\n  return dHit;\n}\n\n#endif\n\n#ifdef KNOT_C\n\nvec3 KtPointC (float a)  //square knot\n{\n  const vec3\n     gc1 = vec3 ( -22,  11,   0),\n     gs1 = vec3 (-128,   0,   0),\n     gc3 = vec3 ( -44, -43,  70),\n     gs3 = vec3 ( -78,   0, -40),\n     gc5 = vec3 (   0,  34,   8),\n     gs5 = vec3 (   0, -39,  -9);\n  return gc1 * cos (a)      + gs1 * sin (a) +\n         gc3 * cos (3. * a) + gs3 * sin (3. * a) +\n         gc5 * cos (5. * a) + gs5 * sin (5. * a);\n}\n\nfloat ObjDfC (vec3 p)\n{\n  vec3 q, r, rp, rm;\n  float d, a;\n  d = dstFar;\n  a = 0.;\n  for (int j = 0; j < nAngInc; j ++) {\n    r = KtPointC (a);\n    rp = KtPointC (a + eAng);\n    rm = KtPointC (a - eAng);\n    q = (p - r * pScale) * EvalRMat (r, rp, rm);\n    d = min (d, PrFlatCylDf (q, cSize));\n    a += dAng;\n  }\n  if (d < dstFar) idObj = 3;\n  return d;\n}\n\nfloat ObjRayC (vec3 ro, vec3 rd)\n{\n  float d, dHit;\n  dHit = 0.;\n  for (int j = 0; j < nMarStep; j ++) {\n    d = ObjDfC (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;              \n  }\n  return dHit;\n}\n\n#endif\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n#ifdef ALL_KNOTS\n  if (idKnot == 1)\n#endif\n#ifdef KNOT_A\n     v = vec4 (ObjDfA (p + e.xxx), ObjDfA (p + e.xyy),\n\tObjDfA (p + e.yxy), ObjDfA (p + e.yyx));\n#endif\n#ifdef ALL_KNOTS\n  else if (idKnot == 2)\n#endif\n#ifdef KNOT_B\n     v = vec4 (ObjDfB (p + e.xxx), ObjDfB (p + e.xyy),\n\tObjDfB (p + e.yxy), ObjDfB (p + e.yyx));\n#endif\n#ifdef ALL_KNOTS\n  else if (idKnot == 3)\n#endif\n#ifdef KNOT_C\n     v = vec4 (ObjDfC (p + e.xxx), ObjDfC (p + e.xyy),\n\tObjDfC (p + e.yxy), ObjDfC (p + e.yyx));\n#endif\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float dstHit;\n  int idObjT;\n  idObj = -1;\n#ifdef ALL_KNOTS\n  if (idKnot == 1) {\n#endif\n#ifdef KNOT_A\n    pScale = 0.015;\n    dstHit = ObjRayA (ro, rd);\n#endif\n#ifdef ALL_KNOTS\n  } else if (idKnot == 2) {\n#endif\n#ifdef KNOT_B\n    pScale = 0.008;\n    dstHit = ObjRayB (ro, rd);\n#endif\n#ifdef ALL_KNOTS\n  } else if (idKnot == 3) {\n#endif\n#ifdef KNOT_C\n    pScale = 0.016;\n    dstHit = ObjRayC (ro, rd);\n#endif\n#ifdef ALL_KNOTS\n  }\n#endif\n  if (idObj < 0) dstHit = dstFar;\n  if (dstHit >= dstFar) col = vec3 (0.2, 0.25, 0.3);\n  else {\n    ro += dstHit * rd;\n    idObjT = idObj;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n#ifdef ALL_KNOTS\n    if (idKnot == 1)\n#endif\n#ifdef KNOT_A\n       col = vec3 (0.9, 0.3, 0.6);\n#endif\n#ifdef ALL_KNOTS\n    else if (idKnot == 2)\n#endif\n#ifdef KNOT_B\n       col = vec3 (0.3, 0.9, 0.6);\n#endif\n#ifdef ALL_KNOTS\n    else if (idKnot == 3)\n#endif\n#ifdef KNOT_C\n       col = vec3 (0.9, 0.6, 0.3);\n#endif\n    col = col * (0.1 + 0.7 * max (dot (vn, ltDir), 0.)) +\n       0.5 * pow (max (0., dot (ltDir, reflect (rd, vn))), 128.);\n  }\n  return sqrt (clamp (col, 0., 1.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n  uv.x *= iResolution.x / iResolution.y;\n  tCur = iTime;\n  mat3 vuMat;\n  float az, el, rl;\n  vec3 rd, ro, ca, sa;\n#ifdef ALL_KNOTS\n  idKnot = 1 + int (mod (floor (tCur / 10.), 3.));\n#endif\n  dAng = 2. * pi / float (nAngInc);\n  eAng = 0.1 * dAng;\n  ei2Ang = 1. / (eAng * eAng);\n  rl = 0.26 * tCur;\n  az = 0.15 * tCur;\n  el = 0.19 * tCur;\n  ca = cos (vec3 (el, az, rl));\n  sa = sin (vec3 (el, az, rl));\n  vuMat = mat3 (ca.z, - sa.z, 0., sa.z, ca.z, 0., 0., 0., 1.) *\n     mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n     mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y);\n  ro = - vec3 (0., 0., 25.) * vuMat;\n  rd = normalize (vec3 (uv, 7.5)) * vuMat;\n  ltDir = normalize (vec3 (1., 1., -1.)) * vuMat;\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ts3zl.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[422, 422, 458, 458, 564], [859, 859, 901, 901, 1073]], "test": "valid"}
{"id": "4tsGRl", "name": "Plane Feature Points", "author": "paniq", "description": "finding feature points of planes with a simplified SVD", "tags": ["mattdamon"], "likes": 4, "viewed": 1367, "published": "Public API", "date": "1424317610", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// minimal SVD implementation for calculating feature points from hermite data\n// works in C++ and GLSL\n\n#define PLANE_COUNT 3\n\n\n// SVD/QEF parts are public domain\n\n#define SVD_NUM_SWEEPS 10\n\n// GLSL prerequisites\n\n#define IN(t,x) in t x\n#define OUT(t, x) out t x\n#define INOUT(t, x) inout t x\n#define rsqrt inversesqrt\n\n#define SWIZZLE_XYZ(v) v.xyz\n\n// SVD\n////////////////////////////////////////////////////////////////////////////////\n\nconst float Tiny_Number = 0.1;\n\nvoid givens_coeffs_sym(float a_pp, float a_pq, float a_qq, OUT(float,c), OUT(float,s)) {\n    if (a_pq == 0.0) {\n        c = 1.0;\n        s = 0.0;\n        return;\n    }\n    float tau = (a_qq - a_pp) / (2.0 * a_pq);\n    float stt = sqrt(1.0 + tau * tau);\n    float tan = 1.0 / ((tau >= 0.0) ? (tau + stt) : (tau - stt));\n    c = rsqrt(1.0 + tan * tan);\n    s = tan * c;\n}\n\nvoid svd_rotate_xy(INOUT(float,x), INOUT(float,y), IN(float,c), IN(float,s)) {\n    float u = x; float v = y;\n    x = c * u - s * v;\n    y = s * u + c * v;\n}\n\nvoid svd_rotateq_xy(INOUT(float,x), INOUT(float,y), INOUT(float,a), IN(float,c), IN(float,s)) {\n    float cc = c * c; float ss = s * s;\n    float mx = 2.0 * c * s * a;\n    float u = x; float v = y;\n    x = cc * u - mx + ss * v;\n    y = ss * u + mx + cc * v;\n}\n\nvoid svd_rotate01(INOUT(mat3,vtav), INOUT(mat3,v)) {\n    if (vtav[0][1] == 0.0) return;\n    \n    float c, s;\n    givens_coeffs_sym(vtav[0][0], vtav[0][1], vtav[1][1], c, s);\n    svd_rotateq_xy(vtav[0][0],vtav[1][1],vtav[0][1],c,s);\n    svd_rotate_xy(vtav[0][2], vtav[1][2], c, s);\n    vtav[0][1] = 0.0;\n    \n    svd_rotate_xy(v[0][0], v[0][1], c, s);\n    svd_rotate_xy(v[1][0], v[1][1], c, s);\n    svd_rotate_xy(v[2][0], v[2][1], c, s);\n}\n\nvoid svd_rotate02(INOUT(mat3,vtav), INOUT(mat3,v)) {\n    if (vtav[0][2] == 0.0) return;\n    \n    float c, s;\n    givens_coeffs_sym(vtav[0][0], vtav[0][2], vtav[2][2], c, s);\n    svd_rotateq_xy(vtav[0][0],vtav[2][2],vtav[0][2],c,s);\n    svd_rotate_xy(vtav[0][1], vtav[1][2], c, s);\n    vtav[0][2] = 0.0;\n    \n    svd_rotate_xy(v[0][0], v[0][2], c, s);\n    svd_rotate_xy(v[1][0], v[1][2], c, s);\n    svd_rotate_xy(v[2][0], v[2][2], c, s);\n}\n\nvoid svd_rotate12(INOUT(mat3,vtav), INOUT(mat3,v)) {\n    if (vtav[1][2] == 0.0) return;\n    \n    float c, s;\n    givens_coeffs_sym(vtav[1][1], vtav[1][2], vtav[2][2], c, s);\n    svd_rotateq_xy(vtav[1][1],vtav[2][2],vtav[1][2],c,s);\n    svd_rotate_xy(vtav[0][1], vtav[0][2], c, s);\n    vtav[1][2] = 0.0;\n    \n    svd_rotate_xy(v[0][1], v[0][2], c, s);\n    svd_rotate_xy(v[1][1], v[1][2], c, s);\n    svd_rotate_xy(v[2][1], v[2][2], c, s);\n}\n\nvoid svd_solve_sym(IN(mat3,a), OUT(vec3,sigma), INOUT(mat3,v)) {\n    // assuming that A is symmetric: can optimize all operations for \n    // the lower left triagonal\n    mat3 vtav = a;\n    // assuming V is identity: you can also pass a matrix the rotations\n    // should be applied to\n    // U is not computed\n    for (int i = 0; i < SVD_NUM_SWEEPS; ++i) {\n        svd_rotate01(vtav, v);\n        svd_rotate02(vtav, v);\n        svd_rotate12(vtav, v);\n    }\n    sigma = vec3(vtav[0][0],vtav[1][1],vtav[2][2]);    \n}\n\nfloat svd_invdet(float x, float tol) {\n    return (abs(x) < tol || abs(1.0 / x) < tol) ? 0.0 : (1.0 / x);\n}\n\nvoid svd_pseudoinverse(OUT(mat3,o), IN(vec3,sigma), IN(mat3,v)) {\n    float d0 = svd_invdet(sigma[0], Tiny_Number);\n    float d1 = svd_invdet(sigma[1], Tiny_Number);\n    float d2 = svd_invdet(sigma[2], Tiny_Number);\n    o = mat3(v[0][0] * d0 * v[0][0] + v[0][1] * d1 * v[0][1] + v[0][2] * d2 * v[0][2],\n             v[0][0] * d0 * v[1][0] + v[0][1] * d1 * v[1][1] + v[0][2] * d2 * v[1][2],\n             v[0][0] * d0 * v[2][0] + v[0][1] * d1 * v[2][1] + v[0][2] * d2 * v[2][2],\n             v[1][0] * d0 * v[0][0] + v[1][1] * d1 * v[0][1] + v[1][2] * d2 * v[0][2],\n             v[1][0] * d0 * v[1][0] + v[1][1] * d1 * v[1][1] + v[1][2] * d2 * v[1][2],\n             v[1][0] * d0 * v[2][0] + v[1][1] * d1 * v[2][1] + v[1][2] * d2 * v[2][2],\n             v[2][0] * d0 * v[0][0] + v[2][1] * d1 * v[0][1] + v[2][2] * d2 * v[0][2],\n             v[2][0] * d0 * v[1][0] + v[2][1] * d1 * v[1][1] + v[2][2] * d2 * v[1][2],\n             v[2][0] * d0 * v[2][0] + v[2][1] * d1 * v[2][1] + v[2][2] * d2 * v[2][2]);\n}\n\nvoid svd_solve_ATA_ATb(\n    IN(mat3,ATA), IN(vec3,ATb), OUT(vec3,x)\n) {\n    mat3 V = mat3(1.0);\n    vec3 sigma;\n    \n    svd_solve_sym(ATA, sigma, V);\n    \n    mat3 Vinv;\n    svd_pseudoinverse(Vinv, sigma, V);\n    x = Vinv * ATb;\n}\n\nvec3 svd_vmul_sym(IN(mat3,a), IN(vec3,v)) {\n    return vec3(\n        dot(a[0],v),\n        (a[0][1] * v.x) + (a[1][1] * v.y) + (a[1][2] * v.z),\n        (a[0][2] * v.x) + (a[1][2] * v.y) + (a[2][2] * v.z)\n    );\n}\n\n// QEF\n////////////////////////////////////////////////////////////////////////////////\n\nvoid qef_add(\n    IN(vec3,n), IN(vec3,p),\n    INOUT(mat3,ATA), \n    INOUT(vec3,ATb),\n    INOUT(vec4,pointaccum))\n{\n    ATA[0][0] += n.x * n.x;\n    ATA[0][1] += n.x * n.y;\n    ATA[0][2] += n.x * n.z;\n    ATA[1][1] += n.y * n.y;\n    ATA[1][2] += n.y * n.z;\n    ATA[2][2] += n.z * n.z;\n\n    float b = dot(p, n);\n    ATb += n * b;\n    pointaccum += vec4(p,1.0);\n}\n\nfloat qef_calc_error(IN(mat3,A), IN(vec3, x), IN(vec3, b)) {\n    vec3 vtmp = b - svd_vmul_sym(A, x);\n    return dot(vtmp,vtmp);\n}\n\nfloat qef_solve(\n    IN(mat3,ATA), \n    IN(vec3,ATb),\n    IN(vec4,pointaccum),\n    OUT(vec3,x)\n) {\n    vec3 masspoint = SWIZZLE_XYZ(pointaccum) / pointaccum.w;\n    ATb -= svd_vmul_sym(ATA, masspoint);\n    svd_solve_ATA_ATb(ATA, ATb, x);\n    float result = qef_calc_error(ATA, x, ATb);\n    \n    x += masspoint;\n        \n    return result;\n}\n\n// uncomment for a cross section view\n//#define CROSS_SECTION\n\n//------------------------------------------------------------------------\n// Camera\n//\n// Move the camera. In this case it's using time and the mouse position\n// to orbitate the camera around the origin of the world (0,0,0), where\n// the yellow sphere is.\n//------------------------------------------------------------------------\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n#ifdef CROSS_SECTION\n    float an = 1.5+sin(0.3*iTime);\n#else\n    float an = 0.3*iTime + 10.0*mouseX;\n#endif\n\tcamPos = vec3(4.5*sin(an),2.0,4.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n\n//------------------------------------------------------------------------\n// Background \n//\n// The background color. In this case it's just a black color.\n//------------------------------------------------------------------------\nvec3 doBackground( void )\n{\n    return vec3( 0.0, 0.0, 0.0);\n}\n\nvec2 min2(vec2 a, vec2 b) {\n    return (a.x <= b.x)?a:b;\n}\n\nvec2 max2(vec2 a, vec2 b) {\n    return (a.x > b.x)?a:b;\n}\n\nvoid rotate_xy(inout float x, inout float y, in float a) {\n    float c = cos(a);\n    float s = sin(a);\n    float u = x; float v = y;\n    x = c * u - s * v;\n    y = s * u + c * v;\n}\n\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n\n//------------------------------------------------------------------------\n// Modelling \n//\n// Defines the shapes (a sphere in this case) through a distance field\n//------------------------------------------------------------------------\n\n#define PLANE_RADIUS 1.0\n#define PLANE_PT_R 0.05\n#define FEATURE_PT_R 0.1\n\nvec4 planef[PLANE_COUNT];\nvec3 normals[PLANE_COUNT];\nvec3 origins[PLANE_COUNT];\nvec3 points[PLANE_COUNT];\n\nmat3 ATA = mat3(0.0);\nvec3 ATb = vec3(0.0);\nvec4 pointaccum = vec4(0.0);\nvec3 corner;\nfloat error;\n\n// pluecker line stored in a matrix\nmat3 line(vec3 p, vec3 q) {\n    return mat3(q-p, cross(p,q), vec3(0.0));\n}\n\nvec4 intersect_line_plane(mat3 l, vec4 e) {\n    vec3 t = l[0];\n    vec3 m = l[1];\n    return vec4(\n        m.z*e.y - m.y*e.z - t.x*e.w,\n        m.x*e.z - m.z*e.x - t.y*e.w,\n        m.y*e.x - m.x*e.y - t.z*e.w,\n        e.x*t.x + e.y*t.y + e.z*t.z\n    );\n}\n\nvoid update_planes() {\n    for (int i = 0; i < PLANE_COUNT; ++i) {\n        float a = float(i)*PI2 / float(PLANE_COUNT);\n        float f = mod(float(i),2.0)*2.0-1.0;\n        normals[i] = normalize(vec3(sin(iTime*0.1+a)*cos(iTime*0.22+a*7.41)*0.8,1.0,0.0));\n        rotate_xy(normals[i].x, normals[i].z, -a*11.2*f);\n        origins[i] = vec3(cos(a)*PLANE_RADIUS,0.0,sin(a)*PLANE_RADIUS);\n        planef[i] = vec4(normals[i], dot(-origins[i],normals[i]));\n    }\n    // push origins onto deepest plane\n    for (int i = 0; i < PLANE_COUNT; ++i) {\n        points[i] = origins[i] * 2.0;\n        points[i].y = 5.0;\n        vec3 n = normals[i];\n        for (int j=0; j < PLANE_COUNT; ++j) {\n            mat3 l = line(points[i], points[i] + vec3(0.0,-1.0,0.0));\n            vec4 np = intersect_line_plane(l, planef[j]);\n            float h = np.y / np.w;\n            if (h < points[i].y) {\n                points[i].y = h;\n                n = normals[j];\n            }                \n        }\n\t    qef_add(n, points[i], ATA, ATb, pointaccum);\n    }\n    \n    error = qef_solve(ATA, ATb, pointaccum, corner);\n}\n\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat plane(vec3 p, vec3 n, vec3 o) {\n    return dot(p,n) + dot(-o,n);\n}\n\nfloat doModel( vec3 p ) {\n    float d = plane(p, normals[0], origins[0]);\n    float s = sphere(p - corner, FEATURE_PT_R + error);\n    s = min(s, sphere(p - points[0], PLANE_PT_R));\n    for (int i = 1; i < PLANE_COUNT; ++i) {\n        d = max(d, plane(p, normals[i], origins[i]));\n        s = min(s, sphere(p - points[i], PLANE_PT_R));\n    }\n    \n  \treturn min(s, d);\n}\n\n//------------------------------------------------------------------------\n// Material \n//\n// Defines the material (colors, shading, pattern, texturing) of the model\n// at every point based on its position and normal. In this case, it simply\n// returns a constant yellow color.\n//------------------------------------------------------------------------\nvec3 doMaterial( in vec3 pos, in vec3 nor )\n{\n    return vec3(0.3);\n}\n\n//------------------------------------------------------------------------\n// Lighting\n//------------------------------------------------------------------------\nfloat calcSoftshadow( in vec3 ro, in vec3 rd );\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec3 mal )\n{\n    vec3 lin = vec3(0.0);\n\n    // key light\n    //-----------------------------\n    vec3  lig = normalize(vec3(1.0,0.7,0.9));\n    float dif = max(dot(nor,lig),0.0);\n    float sha = 0.0; if( dif>0.01 ) sha=calcSoftshadow( pos+0.01*nor, lig );\n    lin += dif*vec3(4.00,4.00,4.00)*sha;\n\n    // ambient light\n    //-----------------------------\n    lin += vec3(0.50,0.50,0.50);\n\n    \n    // surface-light interacion\n    //-----------------------------\n    vec3 col = mal*lin;\n\n    \n    // fog    \n    //-----------------------------\n\tcol *= exp(-0.01*dis*dis);\n\n    return col;\n}\n\nfloat calcIntersection( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 20.0;           // max trace distance\n\tconst float precis = 0.001;        // precission of the intersection\n    float h = precis*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for( int i=0; i<90; i++ )          // max number of raymarching iterations is 90\n    {\n        if( h<precis||t>maxd ) break;\n\t    h = doModel( ro+rd*t );\n        t += h;\n    }\n\n    if( t<maxd ) res = t;\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.002;             // precision of the normal computation\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( pos + v1*eps ) + \n\t\t\t\t\t  v2*doModel( pos + v2*eps ) + \n\t\t\t\t\t  v3*doModel( pos + v3*eps ) + \n\t\t\t\t\t  v4*doModel( pos + v4*eps ) );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.0005;                 // selfintersection avoidance distance\n\tfloat h = 1.0;\n    for( int i=0; i<40; i++ )         // 40 is the max numnber of raymarching steps\n    {\n        h = doModel(ro + rd*t);\n        res = min( res, 64.0*h/t );   // 64 is the hardness of the shadows\n\t\tt += clamp( h, 0.02, 2.0 );   // limit the max and min stepping distances\n    }\n    return clamp(res,0.0,1.0);\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    update_planes();\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m.x );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = doBackground();\n\n\t// raymarch\n    float t = calcIntersection( ro, rd );\n    if( t>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\n        // materials\n        vec3 mal = doMaterial( pos, nor );\n\n        col = doLighting( pos, nor, rd, t, mal );\n\t}\n\n\t//-----------------------------------------------------\n\t// postprocessing\n    //-----------------------------------------------------\n    // gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n\t   \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tsGRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[473, 473, 561, 561, 842], [844, 844, 922, 922, 1000], [1002, 1002, 1097, 1097, 1261], [1263, 1263, 1315, 1315, 1701], [1703, 1703, 1755, 1755, 2141], [2143, 2143, 2195, 2195, 2581], [2583, 2583, 2647, 2749, 3097], [3099, 3099, 3137, 3137, 3206], [3208, 3208, 3273, 3273, 4209], [4211, 4211, 4282, 4282, 4442], [4444, 4444, 4487, 4487, 4655], [4746, 4746, 4860, 4860, 5105], [5107, 5107, 5167, 5167, 5236], [5238, 5238, 5336, 5336, 5577], [5642, 5974, 6057, 6057, 6245], [6248, 6479, 6506, 6506, 6541], [6543, 6543, 6570, 6570, 6601], [6603, 6603, 6630, 6630, 6660], [6662, 6662, 6720, 6720, 6842], [7425, 7461, 7488, 7488, 7535], [7537, 7537, 7580, 7580, 7791], [7793, 7793, 7815, 7815, 8893], [8895, 8895, 8926, 8926, 8954], [8956, 8956, 8993, 8993, 9028], [9030, 9030, 9055, 9055, 9397], [9399, 9752, 9797, 9797, 9821], [10034, 10034, 10118, 10118, 10694], [10696, 10696, 10746, 10746, 11163], [11165, 11165, 11197, 11197, 11609], [11611, 11611, 11659, 11659, 12085], [12087, 12087, 12151, 12151, 12329], [12331, 12331, 12388, 12388, 13614]], "test": "error"}
{"id": "4tsGRs", "name": "GPU delirium 2", "author": "guil", "description": "A by-product of an attempt to make lightning bolt", "tags": ["2d", "fractal", "noise"], "likes": 9, "viewed": 257, "published": "Public", "date": "1424376414", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by S.Guillitte \n\n\nfloat hash( in vec2 p ) \n{\n    return fract(sin(p.x*15.32+p.y*35.78) * 43758.23);\n}\n\nvec2 hash2(vec2 p)\n{\n\treturn vec2(hash(p*.754),hash(1.5743*p.yx+4.5891))-.5;\n}\n\n\nvec2 add = vec2(1.0, 0.0);\n\nvec2 noise2(vec2 x)\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    return mix(mix( hash2(p),          hash2(p + add.xy),f.x),\n                    mix( hash2(p + add.yx), hash2(p + add.xx),f.x),f.y);\n    \n}\n\n\nfloat dseg( vec2 ba, vec2 pa )\n{\t\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0., 1. );\t\n\treturn length( pa - ba*h );\n}\n\n\nvec2 delirium(vec2 x)\n{\n    vec2 r = vec2(2.);\n    float a = 1.;\n    float d=10.;\n    for (int i = 0; i < 12; i++)\n    {\n        vec2 s= noise2(r*a+iTime)/a+.5;\n        d=min(d,dseg(s,x-r));\n        r +=s;      \n        a*=.8;\n    }\n    return normalize(r-x)*d;\n    //return (r-x)*d/dot(r-x,r-x);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.*fragCoord.xy / iResolution.yy;\n    uv*=5.;\n    vec2 p = delirium(uv);\n    float c = length(p)*20.;\n    vec3 col;\n    col=vec3(0.6)*c;\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tsGRs.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[116, 116, 142, 142, 199], [201, 201, 221, 221, 279], [310, 310, 331, 331, 550], [553, 553, 585, 585, 669], [672, 672, 695, 695, 970], [973, 973, 1030, 1030, 1208]], "test": "valid"}
{"id": "4tsGz2", "name": "Peppermint Candy Rain", "author": "SeventySevian", "description": "Quite happy with my first shader. Might not be optimal in many ways, but thanks to iq, I did learn a lot!", "tags": ["3d", "raymarch", "candy"], "likes": 11, "viewed": 285, "published": "Public", "date": "1423443905", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 60\n#define MAX_DISTANCE 30.0\n#define EPSILON 0.01\n#define NORMAL_EPSILON 0.1\n#define CANDY_COUNT 10\n#define CANDY_RADIUS 2.0\n#define CANDY_HEIGHT 0.58\n#define CANDY_SMOOTHNESS 0.5\n#define FALL_SPEED 10.0\n\nfloat smax(float a, float b, float k)\n{\n    float h = 1.0 - clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) + k*h*(1.0-h);\n}\n\nmat4 translate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,  y,   z,   1.0 );\n}\n\nvec3 rotateY(vec3 v, float angle)\n{\n\tvec3 vo = v; \n    float cosa = cos(angle); \n    float sina = sin(angle);\n    \n\tv.x = cosa*vo.x - sina*vo.z;\n\tv.z = sina*vo.x + cosa*vo.z;\n\treturn v;\n}\n\nvec3 rotateX(vec3 v, float angle)\n{\n\tvec3 vo = v; \n    float cosa = cos(angle); \n    float sina = sin(angle);\n    \n\tv.y = cosa*vo.y - sina*vo.z;\n\tv.z = sina*vo.y + cosa*vo.z;\n\treturn v;\n}\n\nvec4 map(vec3 p) \n{\n    float dist = MAX_DISTANCE;\n    vec3 local = vec3(0.0);\n    \n    for (int i = 0; i < CANDY_COUNT; i++) \n    {\n     \tfloat ratio = float(i) / float(CANDY_COUNT);\n        vec3 q = p;\n        \n        // Make them fall\n        q.y += (float(i) * 3.0) + (iTime * FALL_SPEED);\n        \n        // Duplicate along the height\n        float c = 8.0 + (ratio * 10.0);\n    \tq = vec3(q.x, mod(q.y, c) - (0.5 * c), q.z);\n\n        // Spread them appart\n        q = (translate(cos(float(i)) * 7.0, 0.0, float(i) * -1.2) * vec4(q, 1.0)).xyz;\n        \n        // Apply the rotation\n    \tq = rotateX(q, (float(i) * 150.0) + iTime);\n\t\tq = rotateY(q, (float(i) * 150.0) + iTime);\n\n        // Candy\n        float d = length(q.xz) - CANDY_RADIUS;\n        d = smax(d, abs(q.y) - CANDY_HEIGHT, CANDY_SMOOTHNESS);\n        \n        if (d < dist)\n        {\n            dist = d;\n            local = q;\n        }\n    }\n    \n    return vec4(dist, local);\n}\n\nvec3 norm(vec3 point) \n{\n    float d0 = map(point).x;\n    float dX = map(point - vec3(NORMAL_EPSILON, 0.0, 0.0)).x;\n    float dY = map(point - vec3(0.0, NORMAL_EPSILON, 0.0)).x;\n\tfloat dZ = map(point - vec3(0.0, 0.0, NORMAL_EPSILON)).x;\n    return normalize(vec3(dX-d0, dY-d0, dZ-d0));\n}\n\nvec4 raymarch(vec3 rayOrigin, vec3 rayDir) \n{\n\tfloat d = 0.0;\n\n\tfor (int i = 0; i < MAX_STEPS; i++) \n    {\n\t\tvec3 point = rayOrigin + (rayDir * d);\n\t\tvec4 s = map(point);\n        \n    \tif (s.x < EPSILON) \n            return vec4(d, s.yzw);\n        \n    \td += s.x;\n    \tif (d > MAX_DISTANCE) \n            return vec4(MAX_DISTANCE, vec3(0.0));\n  \t}\n    \n    return vec4(MAX_DISTANCE, vec3(0.0));\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float dt = 0.1;\n    float t = mint;\n    for( int i=0; i<30; i++ )\n    {\n        float h = map(ro + rd*t).x;\n        h = max(h,0.0);\n        res = min( res, smoothstep(0.0,1.0,k*h/t) );\n        t += dt;\n\t\tif( h<0.001 ) break;\n    }\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Obtain the screen uv\n    vec2 uv = ((2.0 * fragCoord.xy) - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    // Camera\n    vec3 camPos = vec3(0.0, 2.0, -2.5);\n    vec3 camLookAt = vec3(0.0, 0.0, 0.0);\n    vec3 forward = normalize(camLookAt - camPos);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = cross(up, forward);\n    \n    // Calculate a ray for each pixel\n    vec3 rayDir = normalize((up * uv.y) + (right * uv.x) + (forward * 1.0));\n    vec4 d = raymarch(camPos, rayDir);\n    \n    // Blue background\n    vec4 col = mix(vec4(0.1, 0.3, 0.6, 1.0), vec4(0.15, 0.5, 1.0, 1.0), 1.0 - min(1.0, length(uv) / 1.4));\n    \n    if (d.x < MAX_DISTANCE) \n    {     \n        // Calculate lighting\n        vec4 ambient = vec4(0.1, 0.1, 0.3, 1.0);\t\t// Blue-ish ambient light\n        vec3 lightPos = vec3(0.0, 3.0, 1.0);\n        vec3 point = camPos + rayDir * d.x;\n        vec3 normal = norm(point);\n        vec3 lightDir = -normalize(lightPos - point);\n        float ndotl = max(0.0, dot(lightDir, normal));\n        \n        // Specular\n        vec3 h = normalize(lightDir + forward);\n        float nh = max(0.0, dot(normal, h));\n        float spec = pow(nh, 48.0);\n        \n        // Add color\n        vec4 red = vec4(0.9, 0.1, 0.1, 1.0);\n        vec4 white = vec4(1.0, 0.96, 0.96, 1.0);\n        float radius = length(d.yw);\n        float angle = atan(d.w, d.y);\n        float offset = 0.3 * sin(radius * 5.0) * 0.3;\n        float stripe = cos((angle + offset) * 10.0) * 2.0;\n        \n        col = mix(white, red, max(0.0, stripe));\n        col = mix(white, col, smoothstep(0.5, 2.0, radius));\n        \n        float shadow = softshadow(point, -lightDir, 0.06, 3.0, 3.0);\n        col += spec * 0.4;\n        \n        col = mix(ambient, col, clamp(min(ndotl, shadow), 0.35, 1.0));\n        \n        // Gamma correction\n        col = pow(clamp(col, 0.0, 1.0), vec4(0.45));\n    }\n    \n    fragColor = col; \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tsGz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[223, 223, 262, 262, 361], [363, 363, 408, 408, 523], [525, 525, 560, 560, 712], [714, 714, 749, 749, 901], [1856, 1856, 1880, 1880, 2143], [2145, 2145, 2190, 2190, 2540], [2542, 2542, 2619, 2619, 2893], [2895, 2895, 2952, 2980, 4871]], "test": "valid"}
{"id": "4tsGzB", "name": "Polyhedron fold", "author": "guil", "description": "Based on Polyhedron again by Knighty :\nhttps://www.shadertoy.com/view/XlX3zB", "tags": ["3d", "fractal", "polyhedron"], "likes": 11, "viewed": 258, "published": "Public", "date": "1423086397", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Based on Polyhedron again by Knighty :\n//https://www.shadertoy.com/view/XlX3zB\n\n\n#define PI\t3.14159265359\n#define PI2\t( PI * 2.0 )\n#define time iTime\n\nfloat Type;\nfloat cospin, scospin;\nvec3 nc,ot;\n\n\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\n\nvec3 dmul( vec3 a, vec3 b )  {\n    float r = length(a);\n    \n    b.xy=cmul(normalize(a.xy), b.xy);\n    b.yz=cmul(normalize(a.yz), b.yz);\n    b.xz=cmul(normalize(a.xz), b.xz);\n    \n    return r*b;\n}\n\nvec3 fold(vec3 pos) {\n\tfor(int i=0;i<6 /*Type*/;i++){\n\t\tpos.xy=abs(pos.xy);//fold about xz and yz planes\n\t\tpos-=2.*min(0.,dot(pos,nc))*nc;//fold about nc plane\n\t}\n\treturn pos;\n}\n\n\n\n//-------------------------------------------------\n//From https://www.shadertoy.com/view/XtXGRS#\nvec2 rotate(in vec2 p, in float t)\n{\n\treturn p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\n\nfloat map( vec3 p)\n{\n\tfloat dr = 1.0;\n\tot = vec3(1000.0);\n\tfloat r2;\n\n\tfor( int i=0; i<4;i++ )\n\t{            \n       \tr2 = dot(p,p);      \n       \tif(r2>16.)continue;\n\t\t            \n       \tp=1.5*fold(p);dr*=1.5;p=p.zxy-.5;\n        dr=2.*sqrt(r2)*dr;\n        p=dmul(p,p)-.3;\n        \n        ot = min( ot, abs(p)/(.5+r2) );\n                   \n\t}\n    \n\treturn .3*length(p)*log(length(p))/dr;\t\n       \t\n}\n\n\nvec3 calcNormal(in vec3 p)\n{\n\tconst vec2 e = vec2(0.0001, 0.0);\n\treturn normalize(vec3(\n\t\tmap(p + e.xyy) - map(p - e.xyy),\n\t\tmap(p + e.yxy) - map(p - e.yxy),\n\t\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tconst float maxd = 5.0;\n\tconst float precis = 0.001;\n    float h = precis * 2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for(int i = 0; i < 128; i++)\n    {\n        if(h < precis*t || t > maxd) break;\n\t    h = map(ro + rd * t);\n        t += h;\n    }\n    if(t < maxd) res = t;\n    return res;\n}\n\nvec3 transform(in vec3 p)\n{\n    p.yz = rotate(p.yz, iTime * 0.2 + (iMouse.y-0.5*iResolution.y)*PI2/360.);\n    p.zx = rotate(p.zx, iTime * 0.125 + (0.5*iResolution.x-iMouse.x)*PI2/360.);\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tType=(fract(0.025*time)*3.5)+2.;//4.5;\n\tcospin=cos(PI/(Type)), scospin=sqrt(0.75-cospin*cospin);\n\tnc=vec3(-0.5,-cospin,scospin),ot;\n    \n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 col = vec3(.3);\n   \tvec3 rd = normalize(vec3(p, -1.8));\n\tvec3 ro = vec3(0.0, 0.0, 3.5);\n    vec3 li = normalize(vec3(0.5, 0.8, 3.0));\n    ro = transform(ro);\n\trd = transform(rd);\n\tli = transform(li);\n    float t = march(ro, rd);\n    if(t > -0.001)\n    {\n        vec3 pos = ro + t * rd;\n        vec3 nor = calcNormal(pos);\n\t\tfloat dif = clamp(dot(nor, li), 0.0, 1.0);\n        vec3 col1 =.5*(ot+ot.grb);\n        col1.r+=.5*col1.g-.3*col1.b;\n        nor = reflect(rd, nor);\n        col1 += pow(max(dot(li, nor), 0.0), 25.0)*vec3(1.);\n\t    col = .3+.6*mix( col, col1, t );\n        col = col * dif;\n        col = pow(col, vec3(0.5));\n\t}\n    \n   \tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tsGzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[202, 202, 232, 232, 287], [289, 289, 319, 319, 486], [488, 488, 509, 509, 665], [669, 767, 803, 803, 854], [857, 857, 877, 877, 1260], [1263, 1263, 1291, 1291, 1459], [1461, 1461, 1498, 1498, 1794], [1796, 1796, 1823, 1823, 1997], [1999, 1999, 2056, 2056, 2939]], "test": "valid"}
{"id": "4tX3DB", "name": "Daily: 23/2/15", "author": "hughsk", "description": "Experimenting a little with lighting", "tags": ["rays", "light", "blob", "blinn", "oren", "nayar"], "likes": 2, "viewed": 158, "published": "Public", "date": "1424677084", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592653589793\n\nfloat blinnPhongSpecular(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float shininess) {\n\n  //Calculate Blinn-Phong power\n  vec3 H = normalize(viewDirection + lightDirection);\n  return pow(max(0.0, dot(surfaceNormal, H)), shininess);\n}\n\nfloat fogFactorExp2(\n  const float dist,\n  const float density\n) {\n  const float LOG2 = -1.442695;\n  float d = density * dist;\n  return 1.0 - clamp(exp2(d * d * LOG2), 0.0, 1.0);\n}\n\nfloat orenNayarDiffuse(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float roughness,\n  float albedo) {\n  \n  float LdotV = dot(lightDirection, viewDirection);\n  float NdotL = dot(lightDirection, surfaceNormal);\n  float NdotV = dot(surfaceNormal, viewDirection);\n\n  float s = LdotV - NdotL * NdotV;\n  float t = mix(1.0, max(NdotL, NdotV), step(0.0, s));\n\n  float sigma2 = roughness * roughness;\n  float A = 1.0 + sigma2 * (albedo / (sigma2 + 0.13) + 0.5 / (sigma2 + 0.33));\n  float B = 0.45 * sigma2 / (sigma2 + 0.09);\n\n  return albedo * max(0.0, NdotL) * (A + B * s / t) / PI;\n}\n\nfloat backOut(float t) {\n  float f = t < 0.5 ? 2.0 * t : 1.0 - (2.0 * t - 1.0);\n  float g = pow(f, 3.0) - f * sin(f * PI);\n  return t < 0.5 ? 0.5 * g : 0.5 * (1.0 - g) + 0.5;\n}\n\nvec4 a_x_mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nfloat a_x_mod289(float x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 a_x_permute(vec4 x) {\n  return a_x_mod289(((x * 34.0) + 1.0) * x);\n}\nfloat a_x_permute(float x) {\n  return a_x_mod289(((x * 34.0) + 1.0) * x);\n}\nvec4 a_x_taylorInvSqrt(vec4 r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\nfloat a_x_taylorInvSqrt(float r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\nvec4 a_x_grad4(float j, vec4 ip) {\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p, s;\n  p.xyz = floor(fract(vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz * 2.0 - 1.0) * s.www;\n  return p;\n}\n#define F4 0.309016994374947451\n\nfloat snoise(vec4 v) {\n  const vec4 C = vec4(0.138196601125011, 0.276393202250021, 0.414589803375032, -0.447213595499958);\n  vec4 i = floor(v + dot(v, vec4(F4)));\n  vec4 x0 = v - i + dot(i, C.xxxx);\n  vec4 i0;\n  vec3 isX = step(x0.yzw, x0.xxx);\n  vec3 isYZ = step(x0.zww, x0.yyz);\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n  vec4 i3 = clamp(i0, 0.0, 1.0);\n  vec4 i2 = clamp(i0 - 1.0, 0.0, 1.0);\n  vec4 i1 = clamp(i0 - 2.0, 0.0, 1.0);\n  vec4 x1 = x0 - i1 + C.xxxx;\n  vec4 x2 = x0 - i2 + C.yyyy;\n  vec4 x3 = x0 - i3 + C.zzzz;\n  vec4 x4 = x0 + C.wwww;\n  i = a_x_mod289(i);\n  float j0 = a_x_permute(a_x_permute(a_x_permute(a_x_permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = a_x_permute(a_x_permute(a_x_permute(a_x_permute(i.w + vec4(i1.w, i2.w, i3.w, 1.0)) + i.z + vec4(i1.z, i2.z, i3.z, 1.0)) + i.y + vec4(i1.y, i2.y, i3.y, 1.0)) + i.x + vec4(i1.x, i2.x, i3.x, 1.0));\n  vec4 ip = vec4(1.0 / 294.0, 1.0 / 49.0, 1.0 / 7.0, 0.0);\n  vec4 p0 = a_x_grad4(j0, ip);\n  vec4 p1 = a_x_grad4(j1.x, ip);\n  vec4 p2 = a_x_grad4(j1.y, ip);\n  vec4 p3 = a_x_grad4(j1.z, ip);\n  vec4 p4 = a_x_grad4(j1.w, ip);\n  vec4 norm = a_x_taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= a_x_taylorInvSqrt(dot(p4, p4));\n  vec3 m0 = max(0.6 - vec3(dot(x0, x0), dot(x1, x1), dot(x2, x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3, x3), dot(x4, x4)), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * (dot(m0 * m0, vec3(dot(p0, x0), dot(p1, x1), dot(p2, x2))) + dot(m1 * m1, vec2(dot(p3, x3), dot(p4, x4))));\n}\n\n//------------------------------------------------------------------------\n// Camera\n//\n// Move the camera. In this case it's using time and the mouse position\n// to orbitate the camera around the origin of the world (0,0,0), where\n// the yellow sphere is.\n//------------------------------------------------------------------------\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in vec2 mouse )\n{\n    float an = 10.0*mouse.x;\n\tcamPos = vec3(3.5*sin(an),5.0*mouse.y,3.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n\n//------------------------------------------------------------------------\n// Background \n//\n// The background color. In this case it's just a black color.\n//------------------------------------------------------------------------\nvec3 doBackground( void )\n{\n    return vec3(0.001);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n    \n//------------------------------------------------------------------------\n// Modelling \n//\n// Defines the shapes (a sphere in this case) through a distance field, in\n// this case it's a sphere of radius 1.\n//------------------------------------------------------------------------\nfloat doModel( vec3 p )\n{\n    vec3  sep = vec3(sin(iTime * 0.75), 0, 0);\n    float rad = 0.5;\n    float d = 100000.0;\n    float t = iTime;\n    float swell = 1.0; //(1.0 + snoise(vec4(p * 3.0, iTime)) * 0.06125);\n    float blend = 0.6;\n    \n    sep.x = backOut(0.5 * (sep.x + 1.0)) * 1.5 - 0.25;\n    p = mod(p + 5.0, 10.0) - 5.0;\n    \n    d = smin(d, length(p + sep) - rad * swell, blend);\n    d = smin(d, length(p - sep) - rad * swell, blend);\n    d = smin(d, length(p - sep.yxy) - rad * swell, blend);\n    d = smin(d, length(p + sep.yxy) - rad * swell, blend);\n    d = smin(d, length(p + sep.yyx) - rad * swell, blend);\n    d = smin(d, length(p - sep.yyx) - rad * swell, blend);\n    d = smin(d, length(p) - rad * swell * 0.5, blend);\n    \n    return d;\n}\n\n//------------------------------------------------------------------------\n// Material \n//\n// Defines the material (colors, shading, pattern, texturing) of the model\n// at every point based on its position and normal. In this case, it simply\n// returns a constant yellow color.\n//------------------------------------------------------------------------\nvec3 doMaterial( in vec3 pos, in vec3 nor )\n{\n    return vec3(0.15, 0.04, 0.3);\n}\n\n//------------------------------------------------------------------------\n// Lighting\n//------------------------------------------------------------------------\nfloat calcSoftshadow( in vec3 ro, in vec3 rd );\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec3 mal )\n{\n    vec3 lin = vec3(0.0);\n\n    // key light\n    //-----------------------------\n    vec3  lig1 = normalize(vec3(0.5, 2.5, 2.0));\n    vec3  lig2 = normalize(vec3(-1.5, -5.5, -2.0));\n    float dif1 = orenNayarDiffuse(lig1, normalize(rd), nor, 0.5, 1.0);\n    float dif2 = orenNayarDiffuse(lig2, normalize(rd), nor, 0.5, 1.0);\n    float spc1 = blinnPhongSpecular(lig1, normalize(rd), nor, 0.5);\n    float spc2 = blinnPhongSpecular(lig2, normalize(rd), nor, 0.5);\n    float sha1 = 0.0; if( dif1>0.01 ) sha1=max(0.0, calcSoftshadow( pos+0.01*nor, lig1 ));\n    float sha2 = 0.0; if( dif2>0.01 ) sha2=max(0.0, calcSoftshadow( pos+0.01*nor, lig2 ));\n    \n    vec3 mal2 = vec3(0.0, 0.01, 0.02);\n    \n    lin += mal*dif1*vec3(4.00,4.00,4.00)*sha1;\n    lin += mal2*dif2*vec3(4.00,4.00,4.00)*sha2;\n    lin += mal*spc1*vec3(1.0, 1.5, 2.5)*sha1;\n    lin += mal2*spc2*vec3(1.0, 1.5, 2.5)*sha2;\n    //lin += vec3(0.02);\n\n    \n    // surface-light interacion\n    //-----------------------------\n    vec3 col = lin;\n    //vec3 col = mal * (length(lin) > 0.95 ? 3.0 : 0.2);\n\n    return col;\n}\n\nfloat calcIntersection( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 20.0;           // max trace distance\n\tconst float precis = 0.001;        // precission of the intersection\n    float h = precis*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for( int i=0; i<90; i++ )          // max number of raymarching iterations is 90\n    {\n        if( h<precis||t>maxd ) break;\n\t    h = doModel( ro+rd*t );\n        t += h;\n    }\n\n    if( t<maxd ) res = t;\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.002;             // precision of the normal computation\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( pos + v1*eps ) + \n\t\t\t\t\t  v2*doModel( pos + v2*eps ) + \n\t\t\t\t\t  v3*doModel( pos + v3*eps ) + \n\t\t\t\t\t  v4*doModel( pos + v4*eps ) );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.0005;                 // selfintersection avoidance distance\n\tfloat h = 1.0;\n    for( int i=0; i<5; i++ )         // 40 is the max numnber of raymarching steps\n    {\n        h = doModel(ro + rd*t);\n        res = min( res, 64.0*h/t );   // 64 is the hardness of the shadows\n\t\tt += clamp( h, 0.02, 2.0 );   // limit the max and min stepping distances\n    }\n    return clamp(res,0.0,1.0);\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m.xy );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = doBackground();\n\n\t// raymarch\n    float t = calcIntersection( ro, rd );\n    if( t>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\n        // materials\n        vec3 mal = doMaterial( pos, nor );\n\n        col = mix(doLighting( pos, nor, rd, t, mal ), col, fogFactorExp2(t, 0.12));\n\t}\n\n\t//-----------------------------------------------------\n\t// postprocessing\n    //-----------------------------------------------------\n    // gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n    col.r = mix(pow(col.r, 1.2), pow(col.r, 0.2), col.r);\n    col.b = mix(pow(col.b + 0.75, 0.5) - 0.75, pow(col.b, 1.15), col.b);\n\t   \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tX3DB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 143, 176, 290], [292, 292, 358, 358, 472], [474, 474, 601, 601, 1076], [1078, 1078, 1102, 1102, 1254], [1256, 1256, 1281, 1281, 1330], [1331, 1331, 1358, 1358, 1407], [1408, 1408, 1434, 1434, 1481], [1482, 1482, 1510, 1510, 1557], [1558, 1558, 1590, 1590, 1642], [1643, 1643, 1677, 1677, 1729], [1730, 1730, 1764, 1764, 2023], [2057, 2057, 2079, 2079, 3736], [3738, 4070, 4151, 4151, 4267], [4270, 4501, 4528, 4528, 4554], [4556, 4556, 4597, 4597, 4690], [4696, 4978, 5003, 5003, 5733], [5735, 6088, 6133, 6133, 6169], [6382, 6382, 6466, 6466, 7539], [7541, 7541, 7591, 7591, 8008], [8010, 8010, 8042, 8042, 8454], [8456, 8456, 8504, 8504, 8929], [8931, 8931, 8995, 8995, 9173], [9175, 9175, 9232, 9232, 10602]], "test": "valid"}
{"id": "4tX3Rj", "name": "Britney's Spaceship", "author": "Kali", "description": "Amazing Surface fractal in space + Britney Spears. Kind of surreal mess. Mouse enabled.", "tags": ["raymarching", "fractal"], "likes": 86, "viewed": 3516, "published": "Public", "date": "1423183054", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Britney's Spaceship\" by Kali\n\n//#define LESSDETAIL\n\n#define RAY_STEPS 100\n#define SHADOW_STEPS 50\n#define LIGHT_COLOR vec3(1.,.97,.93)\n#define AMBIENT_COLOR vec3(.75,.65,.6)\n\n#define SPECULAR 0.65\n#define DIFFUSE  1.0\n#define AMBIENT  0.35\n\n#define BRIGHTNESS 1.5\n#define GAMMA 1.35\n#define SATURATION .8\n\n\n#define detail .00004\n#define t iTime*.2\n\n\nvec3 lightdir=normalize(vec3(0.1,-0.15,-1.));\nconst vec3 origin=vec3(-1.,0.2,0.);\nfloat det=0.0;\nvec3 pth1;\n\n\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\n\n\nvec4 formula(vec4 p) {\n\t\tp.xz = abs(p.xz+1.)-abs(p.xz-1.)-p.xz;\n\t\tp=p*2./clamp(dot(p.xyz,p.xyz),.15,1.)-vec4(0.5,0.5,0.8,0.);\n\t\tp.xy*=rot(.5);\n\treturn p;\n}\n\nfloat screen(vec3 p) {\n\tfloat d1=length(p.yz-vec2(.25,0.))-.5;\t\n\tfloat d2=length(p.yz-vec2(.25,2.))-.5;\t\n\treturn min(max(d1,abs(p.x-.3)-.01),max(d2,abs(p.x+2.3)-.01));\n}\n\nvec2 de(vec3 pos) {\n\tfloat hid=0.;\n\tvec3 tpos=pos;\n\ttpos.z=abs(2.-mod(tpos.z,4.));\n\tvec4 p=vec4(tpos,1.5);\n\tfloat y=max(0.,.35-abs(pos.y-3.35))/.35;\n#ifdef LESSDETAIL\n\tfor (int i=0; i<6; i++) {p=formula(p);}\n\tfloat fr=max(-tpos.x-4.,(length(max(vec2(0.),p.yz-2.))-.5)/p.w);\n#else \n\tfor (int i=0; i<8; i++) {p=formula(p);}\n\tfloat fr=max(-tpos.x-4.,(length(max(vec2(0.),p.yz-3.)))/p.w);\n#endif\t\n\n\tfloat sc=screen(tpos);\n\tfloat d=min(sc,fr);\n\tif (abs(d-sc)<.001) hid=1.;\n\treturn vec2(d,hid);\n}\n\nvec2 colorize(vec3 p) {\n\tp.z=abs(2.-mod(p.z,4.));\n\tfloat es, l=es=0.;\n\tfloat ot=1000.;\n\tfor (int i = 0; i < 15; i++) { \n\t\tp=formula(vec4(p,0.)).xyz;\n\t\t\t\tfloat pl = l;\n\t\t\t\tl = length(p);\n\t\t\t\tes+= exp(-10. / abs(l - pl));\n\t\t\t\tot=min(ot,abs(l-3.));\n\t}\n\treturn vec2(es,ot);\n}\n\n\n\nvec3 path(float ti) {\n\tvec3  p=vec3(sin(ti)*2.,(1.-sin(ti*.5))*.5,-cos(ti*.25)*30.)*.5;\n\treturn p;\n}\n\n\nvec3 normal(vec3 p) {\n\tvec3 e = vec3(0.0,det,0.0);\n\t\n\treturn normalize(vec3(\n\t\t\tde(p+e.yxx).x-de(p-e.yxx).x,\n\t\t\tde(p+e.xyx).x-de(p-e.xyx).x,\n\t\t\tde(p+e.xxy).x-de(p-e.xxy).x\n\t\t\t)\n\t\t);\t\n}\n\nfloat shadow(vec3 pos, vec3 sdir) {\n\tfloat sh=1.0;\n\tfloat totdist =2.0*det;\n\tfloat dist=10.;\n\t\tfor (int steps=0; steps<SHADOW_STEPS; steps++) {\n\t\t\tif (totdist<1. && dist>detail) {\n\t\t\t\tvec3 p = pos - totdist * sdir;\n\t\t\t\tdist = de(p).x;\n\t\t\t\tsh = min( sh, max(50.*dist/totdist,0.0) );\n\t\t\t\ttotdist += max(.01,dist);\n\t\t\t}\n\t\t}\n\t\n    return clamp(sh,0.1,1.0);\n}\n\n\nfloat calcAO( const vec3 pos, const vec3 nor ) {\n\tfloat aodet=detail*40.;\n\tfloat totao = 0.0;\n    float sca = 13.0;\n    for( int aoi=0; aoi<5; aoi++ ) {\n        float hr = aodet*float(aoi*aoi);\n        vec3 aopos =  nor * hr + pos;\n        float dd = de( aopos ).x;\n        totao += -(dd-hr)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - 5.0*totao, 0., 1.0 );\n}\n\n\nvec3 light(in vec3 p, in vec3 dir, in vec3 n, in float hid) {\n\tfloat sh=shadow(p, lightdir);\n\tfloat ao=calcAO(p,n);\n\tfloat diff=max(0.,dot(lightdir,-n))*sh*DIFFUSE;\n\tvec3 amb=max(.5,dot(dir,-n))*AMBIENT*AMBIENT_COLOR;\n\tvec3 r = reflect(lightdir,n);\n\tfloat spec=pow(max(0.,dot(dir,-r))*sh,15.)*SPECULAR;\n\tvec3 col;\n\tvec2 getcol=colorize(p);\n\tif (hid>.5) {col=vec3(1.); spec=spec*spec;}\n\telse{\n\t\tfloat k=pow(getcol.x*.11,2.); \n\t\tcol=mix(vec3(k,k*k,k*k),vec3(k),.5)+.1;\n\t\tcol+=pow(max(0.,1.-getcol.y),5.)*.3;\n\t}\n\tcol=col*ao*(amb+diff*LIGHT_COLOR)+spec*LIGHT_COLOR;\t\n\n\tif (hid>.5) {\n\t\tvec3 p2=p;\n\t\tp2.z=abs(1.-mod(p2.z,2.));\n\t\tvec3 c=texture(iChannel0,mod(1.-p.zy-vec2(.4,0.2),vec2(1.))).xyz*2.;\n\t\tcol+=c*abs(.01-mod(p.y-iTime*.1,.02))/.01*ao;\n\t\tcol*=max(0.,1.-pow(length(p2.yz-vec2(.25,1.)),2.)*3.5);\n\t} else{\n\t\tvec3 c=(texture(iChannel0,mod(p.zx*2.+vec2(0.5),vec2(1.))).xyz);\n\t\tc*=abs(.01-mod(p.x-iTime*.1*sign(p.x+1.),.02))/.01;\n\t\tcol+=pow(getcol.x,10.)*.0000000003*c;\n\t\tcol+=pow(max(0.,1.-getcol.y),4.)\n\t\t\t*pow(max(0.,1.-abs(1.-mod(p.z+iTime*2.,4.))),2.)\n\t\t\t*vec3(1.,.8,.4)*4.*max(0.,.05-abs(p.x+1.))/.05;\n\t}\n\treturn col;\n}\n\nvec3 raymarch(in vec3 from, in vec3 dir) \n\n{\n\tfloat glow,eglow,totdist=glow=0.;\n\tvec2 d=vec2(1.,0.);\n\tvec3 p, col=vec3(0.);\n\t\n\tfor (int i=0; i<RAY_STEPS; i++) {\n\t\tif (d.x>det && totdist<30.0) {\n\t\t\tp=from+totdist*dir;\n\t\t\td=de(p);\n\t\t\tdet=detail*(1.+totdist*50.);\n\t\t\ttotdist+=d.x; \n\t\t\tif(d.x<0.015)glow+=max(0.,.015-d.x)*exp(-totdist);\n\t\t}\n\t}\n\tfloat l=max(0.,dot(normalize(-dir),normalize(lightdir)));\n\tvec3 backg=vec3(max(0.,-dir.y+.6))*AMBIENT_COLOR*.5*max(0.4,l);\n\n\tif (d.x<det || totdist<30.) {\n\t\tp=p-abs(d.x-det)*dir;\n\t\tvec3 norm=normal(p);\n\t\tcol=light(p, dir, norm, d.y); \n\t\tcol = mix(col, backg, 1.0-exp(-.15*pow(totdist,1.5)));\n\t} else { \n\t\tcol=backg;\n\t    vec3 st = (dir * 3.+ vec3(1.3,2.5,1.25)) * .3;\n\t\tfor (int i = 0; i < 13; i++) st = abs(st) / dot(st,st) - .9;\n\t\tcol+= min( 1., pow( min( 5., length(st) ), 3. ) * .0025 );\n\n\t}\n\tvec3 lglow=LIGHT_COLOR*pow(l,25.)*.5;\n\tcol+=glow*(.5+l*.5)*LIGHT_COLOR*.7;\n\tcol+=lglow*exp(min(30.,totdist)*.02);\n\treturn col; \n}\n\nvec3 move(inout vec3 dir) {\n\tvec3 go=path(t);\n\tvec3 adv=path(t+.7);\n\tfloat hd=de(adv).x;\n\tvec3 advec=normalize(adv-go);\n\tfloat an=adv.x-go.x; an*=min(1.,abs(adv.z-go.z))*sign(adv.z-go.z)*.7;\n\tdir.xy*=mat2(cos(an),sin(an),-sin(an),cos(an));\n    an=advec.y*1.7;\n\tdir.yz*=mat2(cos(an),sin(an),-sin(an),cos(an));\n\tan=atan(advec.x,advec.z);\n\tdir.xz*=mat2(cos(an),sin(an),-sin(an),cos(an));\n\treturn go;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tpth1 = path(t+.3)+origin;\n\tvec2 uv = fragCoord.xy / iResolution.xy*2.-1.;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec2 mouse=(iMouse.xy/iResolution.xy-.5)*3.;\n\tif (iMouse.z<1.) mouse=vec2(0.,-.2);\n\tvec3 dir=normalize(vec3(uv*.8,1.));\n\tdir.yz*=rot(mouse.y);\n\tdir.xz*=rot(mouse.x);\n\tvec3 from=origin+move(dir);\n\tvec3 color=raymarch(from,dir); \n\tcolor=clamp(color,vec3(.0),vec3(1.));\n\tcolor=pow(color,vec3(GAMMA))*BRIGHTNESS;\n\tcolor=mix(vec3(length(color)),color,SATURATION);\n\tfragColor = vec4(color,1.);\n}", "image_inputs": [{"id": "Xdf3Rn", "previewfilepath": "/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tX3Rj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[464, 464, 483, 483, 530], [534, 534, 556, 556, 689], [691, 691, 713, 713, 860], [862, 862, 881, 881, 1352], [1354, 1354, 1377, 1377, 1625], [1629, 1629, 1650, 1650, 1729], [1732, 1732, 1753, 1753, 1916], [1918, 1918, 1953, 1953, 2272], [2275, 2275, 2323, 2323, 2645], [2648, 2648, 2709, 2709, 3771], [3773, 3773, 3817, 3817, 4740], [4742, 4742, 4769, 4769, 5140], [5143, 5143, 5200, 5200, 5702]], "test": "error"}
{"id": "4tXGDB", "name": "Daily: 22/2/15", "author": "hughsk", "description": "Just mucking around", "tags": ["noise", "rays", "sphere", "blob"], "likes": 2, "viewed": 150, "published": "Public", "date": "1424648996", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592653589793\n\nfloat backOut(float t) {\n  float f = t < 0.5 ? 2.0 * t : 1.0 - (2.0 * t - 1.0);\n  float g = pow(f, 3.0) - f * sin(f * PI);\n  return t < 0.5 ? 0.5 * g : 0.5 * (1.0 - g) + 0.5;\n}\n\nvec4 a_x_mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nfloat a_x_mod289(float x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 a_x_permute(vec4 x) {\n  return a_x_mod289(((x * 34.0) + 1.0) * x);\n}\nfloat a_x_permute(float x) {\n  return a_x_mod289(((x * 34.0) + 1.0) * x);\n}\nvec4 a_x_taylorInvSqrt(vec4 r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\nfloat a_x_taylorInvSqrt(float r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\nvec4 a_x_grad4(float j, vec4 ip) {\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p, s;\n  p.xyz = floor(fract(vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz * 2.0 - 1.0) * s.www;\n  return p;\n}\n#define F4 0.309016994374947451\n\nfloat snoise(vec4 v) {\n  const vec4 C = vec4(0.138196601125011, 0.276393202250021, 0.414589803375032, -0.447213595499958);\n  vec4 i = floor(v + dot(v, vec4(F4)));\n  vec4 x0 = v - i + dot(i, C.xxxx);\n  vec4 i0;\n  vec3 isX = step(x0.yzw, x0.xxx);\n  vec3 isYZ = step(x0.zww, x0.yyz);\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n  vec4 i3 = clamp(i0, 0.0, 1.0);\n  vec4 i2 = clamp(i0 - 1.0, 0.0, 1.0);\n  vec4 i1 = clamp(i0 - 2.0, 0.0, 1.0);\n  vec4 x1 = x0 - i1 + C.xxxx;\n  vec4 x2 = x0 - i2 + C.yyyy;\n  vec4 x3 = x0 - i3 + C.zzzz;\n  vec4 x4 = x0 + C.wwww;\n  i = a_x_mod289(i);\n  float j0 = a_x_permute(a_x_permute(a_x_permute(a_x_permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = a_x_permute(a_x_permute(a_x_permute(a_x_permute(i.w + vec4(i1.w, i2.w, i3.w, 1.0)) + i.z + vec4(i1.z, i2.z, i3.z, 1.0)) + i.y + vec4(i1.y, i2.y, i3.y, 1.0)) + i.x + vec4(i1.x, i2.x, i3.x, 1.0));\n  vec4 ip = vec4(1.0 / 294.0, 1.0 / 49.0, 1.0 / 7.0, 0.0);\n  vec4 p0 = a_x_grad4(j0, ip);\n  vec4 p1 = a_x_grad4(j1.x, ip);\n  vec4 p2 = a_x_grad4(j1.y, ip);\n  vec4 p3 = a_x_grad4(j1.z, ip);\n  vec4 p4 = a_x_grad4(j1.w, ip);\n  vec4 norm = a_x_taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= a_x_taylorInvSqrt(dot(p4, p4));\n  vec3 m0 = max(0.6 - vec3(dot(x0, x0), dot(x1, x1), dot(x2, x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3, x3), dot(x4, x4)), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * (dot(m0 * m0, vec3(dot(p0, x0), dot(p1, x1), dot(p2, x2))) + dot(m1 * m1, vec2(dot(p3, x3), dot(p4, x4))));\n}\n\n//------------------------------------------------------------------------\n// Camera\n//\n// Move the camera. In this case it's using time and the mouse position\n// to orbitate the camera around the origin of the world (0,0,0), where\n// the yellow sphere is.\n//------------------------------------------------------------------------\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 0.3*iTime + 10.0*mouseX;\n\tcamPos = vec3(3.5*sin(an),1.0,3.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n\n//------------------------------------------------------------------------\n// Background \n//\n// The background color. In this case it's just a black color.\n//------------------------------------------------------------------------\nvec3 doBackground( void )\n{\n    return vec3(0.0125);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n    \n//------------------------------------------------------------------------\n// Modelling \n//\n// Defines the shapes (a sphere in this case) through a distance field, in\n// this case it's a sphere of radius 1.\n//------------------------------------------------------------------------\nfloat doModel( vec3 p )\n{\n    vec3  sep = vec3(sin(iTime * 0.25), 0, 0);\n    float rad = 0.5;\n    float d = 100000.0;\n    float t = iTime;\n    float swell = (1.0 + snoise(vec4(p * 3.0, iTime)) * 0.06125);\n    float blend = 0.6;\n    \n    sep.x = backOut(0.5 * (sep.x + 1.0)) * 1.5 - 0.25;\n    \n    d = smin(d, length(p + sep) - rad * swell, blend);\n    d = smin(d, length(p - sep) - rad * swell, blend);\n    d = smin(d, length(p - sep.yxy) - rad * swell, blend);\n    d = smin(d, length(p + sep.yxy) - rad * swell, blend);\n    d = smin(d, length(p) - rad * swell * 0.5, blend);\n    \n    return d;\n}\n\n//------------------------------------------------------------------------\n// Material \n//\n// Defines the material (colors, shading, pattern, texturing) of the model\n// at every point based on its position and normal. In this case, it simply\n// returns a constant yellow color.\n//------------------------------------------------------------------------\nvec3 doMaterial( in vec3 pos, in vec3 nor )\n{\n    return vec3(0.1, 0.3, 0.2);\n}\n\n//------------------------------------------------------------------------\n// Lighting\n//------------------------------------------------------------------------\nfloat calcSoftshadow( in vec3 ro, in vec3 rd );\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec3 mal )\n{\n    vec3 lin = vec3(0.0);\n\n    // key light\n    //-----------------------------\n    vec3  lig = normalize(vec3(0.5, 2.5, 2.0));\n    float dif = max(dot(nor,lig),0.0);\n    float sha = 0.0; if( dif>0.01 ) sha=calcSoftshadow( pos+0.01*nor, lig );\n    lin += dif*vec3(4.00,4.00,4.00)*sha;\n\n    // ambient light\n    //-----------------------------\n    lin += vec3(0.50,0.50,0.50);\n\n    \n    // surface-light interacion\n    //-----------------------------\n    vec3 col = mal*lin;\n    //vec3 col = mal * (length(lin) > 0.95 ? 3.0 : 0.2);\n\n    return col;\n}\n\nfloat calcIntersection( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 20.0;           // max trace distance\n\tconst float precis = 0.001;        // precission of the intersection\n    float h = precis*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for( int i=0; i<90; i++ )          // max number of raymarching iterations is 90\n    {\n        if( h<precis||t>maxd ) break;\n\t    h = doModel( ro+rd*t );\n        t += h;\n    }\n\n    if( t<maxd ) res = t;\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.002;             // precision of the normal computation\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( pos + v1*eps ) + \n\t\t\t\t\t  v2*doModel( pos + v2*eps ) + \n\t\t\t\t\t  v3*doModel( pos + v3*eps ) + \n\t\t\t\t\t  v4*doModel( pos + v4*eps ) );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.0005;                 // selfintersection avoidance distance\n\tfloat h = 1.0;\n    for( int i=0; i<5; i++ )         // 40 is the max numnber of raymarching steps\n    {\n        h = doModel(ro + rd*t);\n        res = min( res, 64.0*h/t );   // 64 is the hardness of the shadows\n\t\tt += clamp( h, 0.02, 2.0 );   // limit the max and min stepping distances\n    }\n    return clamp(res,0.0,1.0);\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m.x );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = doBackground();\n\n\t// raymarch\n    float t = calcIntersection( ro, rd );\n    if( t>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\n        // materials\n        vec3 mal = doMaterial( pos, nor );\n\n        col = doLighting( pos, nor, rd, t, mal );\n\t}\n\n\t//-----------------------------------------------------\n\t// postprocessing\n    //-----------------------------------------------------\n    // gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n    col.r = mix(pow(col.r, 1.2), pow(col.r, 0.2), col.r);\n    col.b = mix(pow(col.b + 0.75, 0.5) - 0.75, pow(col.b, 1.15), col.b);\n\t   \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tXGDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 54, 54, 206], [208, 208, 233, 233, 282], [283, 283, 310, 310, 359], [360, 360, 386, 386, 433], [434, 434, 462, 462, 509], [510, 510, 542, 542, 594], [595, 595, 629, 629, 681], [682, 682, 716, 716, 975], [1009, 1009, 1031, 1031, 2688], [2690, 3022, 3105, 3105, 3224], [3227, 3458, 3485, 3485, 3512], [3514, 3514, 3555, 3555, 3648], [3654, 3936, 3961, 3961, 4532], [4534, 4887, 4932, 4932, 4966], [5179, 5179, 5263, 5263, 5813], [5815, 5815, 5865, 5865, 6282], [6284, 6284, 6316, 6316, 6728], [6730, 6730, 6778, 6778, 7203], [7205, 7205, 7269, 7269, 7447], [7449, 7449, 7506, 7506, 8841]], "test": "valid"}
{"id": "4tXGzf", "name": "Cartoon Planet", "author": "kzy", "description": "Simple cartoonish planet\nfixed for webgl 2", "tags": ["3d", "noise", "raymarch", "earth", "planet"], "likes": 15, "viewed": 1358, "published": "Public API", "date": "1423650981", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.14159265359;\nconst float FOV = 67.0 / 180.0 * PI;\nconst float MAX = 10000.0;\n\n// scatter constants\nconst float K_R = 0.166;\nconst float K_M = 0.025;\nconst float E = 14.3; // light intensity\nconst vec3 C_R = vec3(0.3, 0.7, 1.0); // 1 / wavelength ^ 4\nconst float G_M = -0.85; // Mie g\n\nconst float R_INNER = 1.0;\nconst float R = R_INNER * 1.025;\nconst float SCALE_H = 4.0 / (R - R_INNER);\nconst float SCALE_L = 1.0 / (R - R_INNER);\n\nconst int NUM_OUT_SCATTER = 10;\nconst float FNUM_OUT_SCATTER = 10.0;\n\nconst int NUM_IN_SCATTER = 10;\nconst float FNUM_IN_SCATTER = 10.0;\n\nconst float WATER_HEIGHT = 0.7;\nconst vec3 LIGHT = vec3(0, 0, 1.0);\n\n#define SEED 171.\n\nvec2 ray_vs_sphere(vec3 p, vec3 dir, float r)\n{\n\tfloat b = dot(p, dir);\n\tfloat c = dot(p, p) - r * r;\n\n\tfloat d = b * b - c;\n\tif (d < 0.0)\n\t\treturn vec2(MAX, -MAX);\n\td = sqrt(d);\n\n\treturn vec2(-b - d, -b + d);\n}\n\nfloat phase_mie(float g, float c, float cc)\n{\n\tfloat gg = g * g;\n\n\tfloat a = (1.0 - gg) * (1.0 + cc);\n\n\tfloat b = 1.0 + gg - 2.0 * g * c;\n\tb *= sqrt(b);\n\tb *= 2.0 + gg;\n\n\treturn 1.5 * a / b;\n}\n\nfloat phase_reyleigh(float cc)\n{\n\treturn 0.75 * (1.0 + cc);\n}\n\nfloat density(vec3 p)\n{\n\treturn exp(-(length(p) - R_INNER) * SCALE_H);\n}\n\nfloat optic(vec3 p, vec3 q)\n{\n\tvec3 step = (q - p) / FNUM_OUT_SCATTER;\n\tvec3 v = p + step * 0.5;\n\n\tfloat sum = 0.0;\n\tfor (int i = 0; i < NUM_OUT_SCATTER; i++)\n\t{\n\t\tsum += density(v);\n\t\tv += step;\n\t}\n\tsum *= length(step) * SCALE_L;\n\n\treturn sum;\n}\n\nvec3 in_scatter(vec3 o, vec3 dir, vec2 e, vec3 l)\n{\n\tfloat len = (e.y - e.x) / FNUM_IN_SCATTER;\n\tvec3 step = dir * len;\n\tvec3 p = o + dir * e.x;\n    vec3 pa = p;\n    vec3 pb = o + dir * e.y;\n\tvec3 v = p + dir * (len * 0.5);\n\n\tvec3 sum = vec3(0.0);\n\tfor (int i = 0; i < NUM_IN_SCATTER; i++)\n\t{\n\t\tvec2 f = ray_vs_sphere(v, l, R);\n\t\tvec3 u = v + l * f.y;\n\n\t\tfloat n = (optic(p, v) + optic(v, u)) * (PI * 4.0);\n\n\t\tsum += density(v) * exp(-n * (K_R * C_R + K_M));\n\n\t\tv += step;\n\t}\n\tsum *= len * SCALE_L;\n\n\tfloat c = dot(dir, -l);\n\tfloat cc = c * c;\n\treturn sum * (K_R * C_R * phase_reyleigh(cc) + K_M * phase_mie(G_M, c, cc)) * E;\n}\n\nvec3 scatter(vec3 ro, vec3 rd, vec2 f)\n{\n\tvec2 e = ray_vs_sphere(ro, rd, R);\n\tif (e.x > e.y)\n\t\treturn vec3(0);\n\n\te.y = min(e.y, f.x);\n\n\treturn in_scatter(ro, rd, e, LIGHT);\n}\n//###### end scatter\n\n//###### noise\n// credits to iq for this noise algorithm\n\nmat3 m = mat3(0.00, 0.80, 0.60,\n\t\t-0.80, 0.36, -0.48,\n\t\t-0.60, -0.48, 0.64);\n\nfloat hash(float n)\n{\n\treturn fract(sin(n) * 43758.5453);\n}\n\nfloat noise(in vec3 x)\n{\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\n\tf = f * f * (3.0 - 2.0 * f);\n\n\tfloat n = p.x + p.y * 57.0 + 113.0 * p.z;\n\n\tfloat res = mix(mix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n\t\t\t\tmix(hash(n + 57.0), hash(n + 58.0), f.x), f.y),\n\t\t\tmix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n\t\t\t\tmix(hash(n + 170.0), hash(n + 171.0), f.x), f.y), f.z);\n\treturn res;\n}\n\nfloat fbm(vec3 p)\n{\n\tfloat f;\n\tf = 0.5000 * noise(p);\n\tp = m * p * 2.02;\n\tf += 0.2500 * noise(p);\n\tp = m * p * 2.03;\n\tf += 0.1250 * noise(p);\n\tp = m * p * 2.01;\n\tf += 0.0625 * noise(p);\n\treturn f;\n}\n\n//###### end noise\n\nfloat rnd(float r)\n{\n\treturn r - mod(r, 0.04);\n}\n\nfloat terrain(vec3 p)\n{\n\treturn fbm(p * 10.) / 5. + fbm(p + SEED) - (1. / 5.);\n}\n\nvec3 waterColor(float h)\n{\n\treturn mix(vec3(0, .29, 0.85), vec3(0, 0, .25), h);\n}\n\nvec3 terrainColor(float h)\n{\n//\th *= 1.2;\n\treturn h < .5 ?\n        mix(vec3(1.), vec3(.41, .54, .09), h * 2.) :\n\t\tmix(vec3(.41, .54, .0), vec3(.91, .91, .49), (h - .5) * 2.);\n}\n\nvec3 surfaceColor(float height, float longitude) {\n    if (height < (1.-WATER_HEIGHT))\n        return terrainColor(1.0 - abs(longitude + height + WATER_HEIGHT - 1.0));\n    else\n        return waterColor(height / WATER_HEIGHT);\n}\n\nmat3 rm(vec3 axis, float angle)\n{\n\taxis = normalize(axis);\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tfloat oc = 1.0 - c;\n\n\treturn mat3(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s,\n\t\toc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s,\n\t\toc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c);\n}\n\nvec3 render(vec3 ro, vec3 rd)\n{\n\tmat3 r = rm(vec3(0, 1, 0), iTime / 10.);\n    vec2 d = ray_vs_sphere(ro, rd, R_INNER);\n\tvec3 atmosphere = scatter(ro, rd, d);\n    \n    if (d.x < MAX - 1.0)\n\t{\n\t\tvec3 hit = normalize(d.x * rd + ro) * r;\n\t\tfloat h = (fbm(hit * 10.0) / 5.0 + fbm(hit + SEED)) - 0.2;\n\t\treturn surfaceColor(h, hit.y) * length(atmosphere * 1.5) * (atmosphere + 0.75);\n\t}\n    \n    return atmosphere;\n}\n\nvec3 getRay(vec3 pos, vec3 dir, vec3 up, vec2 fragCoord)\n{\n\tvec2 xy = fragCoord.xy / iResolution.xy - vec2(0.5);\n\txy.y *= -iResolution.y / iResolution.x;\n\n\tvec3 eyed = normalize(dir);\n\tvec3 ud = normalize(cross(vec3(0.0, -1.0, 0.0), eyed));\n\tvec3 vd = normalize(cross(eyed, ud));\n\n\tfloat f = FOV * length(xy);\n\treturn normalize(normalize(xy.x * ud + xy.y * vd) + (1.0 / tan(f)) * eyed);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfloat a = iMouse.x / iResolution.x * 10.;\n\tfloat h = iMouse.y / iResolution.y - 0.5;\n\n\tvec3 pos = vec3(3.5 * cos(a), h * 5., 3.5 * sin(a));\n\tvec3 dir = -normalize(pos);\n\tvec3 up = vec3(0, 1, 0);\n\n\tvec3 color = render(pos, getRay(pos, dir, up, fragCoord));\n\n\tfragColor = vec4(color, 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tXGzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[677, 677, 724, 724, 888], [890, 890, 935, 935, 1082], [1084, 1084, 1116, 1116, 1145], [1147, 1147, 1170, 1170, 1219], [1221, 1221, 1250, 1250, 1467], [1469, 1469, 1520, 1520, 2096], [2098, 2098, 2138, 2138, 2272], [2431, 2431, 2452, 2452, 2490], [2492, 2492, 2516, 2516, 2871], [2873, 2873, 2892, 2892, 3071], [3093, 3093, 3113, 3113, 3141], [3143, 3143, 3166, 3166, 3223], [3225, 3225, 3251, 3251, 3306], [3308, 3308, 3336, 3349, 3484], [3486, 3486, 3536, 3536, 3714], [3716, 3716, 3749, 3749, 4150], [4152, 4152, 4183, 4183, 4561], [4563, 4563, 4621, 4621, 4951], [4953, 4953, 5008, 5008, 5297]], "test": "valid"}
{"id": "4tXGzj", "name": "K-moon", "author": "Kali", "description": "Mouse enabled", "tags": ["moon"], "likes": 41, "viewed": 919, "published": "Public", "date": "1423183906", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Planet K\" by Kali\n\nconst float Saturation= .9;\nconst float ColorDensity= 1.4;\nconst float ColorOffset= 0.1;\nconst vec3 Color1= vec3(1.,0.9,0.8);\nconst vec3 Color2= vec3(1.0,0.85,0.65)*.5;\nconst vec3 Color3= vec3(1.0,0.8,.7)*.4;\n\n#define PI  3.141592\n\nconst vec3 lightdir=-vec3(0.0,0.0,1.0);\n\nfloat colindex;\n\n// Fragmentarium's rotation matrix\nmat3 rotmat(vec3 v, float angle)\n{\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\t\n\treturn mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n\t\t(1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n\t\t(1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z\n\t\t);\n}\n\n// Random number implementation found at: lumina.sourceforge.net/Tutorials/Noise.html\nfloat rand(vec2 co){\n\treturn fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// Formulas used for texture, coloring and stars\n// more info here:\n// http://www.fractalforums.com/new-theories-and-research/very-simple-formula-for-fractal-patterns/\n\nfloat KalisetTexture(vec3 p) {\n\tvec3 pos=p;\n\tfloat l=1.;\n\tfloat ln=0.;\n\tfloat lnprev=0.;\n\tfloat expsmooth=0.;\n\tfor (int i=0; i<13; i++) {\n\t\tp.xyz=abs(p.xyz);\n\t\tp=p/dot(p,p);\n\t\tp=p*2.-vec3(1.);\n\t\tif (mod(float(i),2.)>0.) {\n\t\t\tlnprev=ln;\n\t\t\tln=length(p);\n\t\t\texpsmooth+=exp(-1./abs(lnprev-ln));\n\t\t}\n\t}\n\treturn expsmooth;\n}\n\nfloat KalisetStars(vec3 p) {\n\tvec3 pos=p;\n\tfloat l=1.;\n\tfloat ln=0.;\n\tfloat lnprev=0.;\n\tfloat expsmooth=0.;\n\tp+=vec3(1.35,1.54,1.23);\n\tp*=.3;\n\tfor (int i=0; i<18; i++) {\n\t\tp.xyz=abs(p.xyz);\n\t\tp=p/dot(p,p);\n\t\tp=p*1.-vec3(.9);\n\t}\n\treturn pow(length(p),1.5)*.04;\n}\n\n\n// Distance estimation for sphere with texture displacement\nfloat dsph (in vec4 sph, in vec3 p)\n{\n\t//p*=rotmat(normalize(vec3(0.,1.,0.)),iTime*.05);\n\tvec3 p2=p-sph.xyz;\n\tfloat d=length(p2)-sph.w;\n\tfloat tex=KalisetTexture(p2*.4+vec3(.14,.31,.51));\n\tcolindex=tex;\n\treturn d+tex*.006+.25;\n}\n\n// Intersection with sphere\nfloat isph (in vec4 sph, in vec3 p, in vec3 rd)\n{\n\tfloat t=999.,tnow,b,disc;\n    vec3 sd=sph.xyz-p;    \n    b = dot ( rd,sd );\n    disc = b*b + (sph.w*sph.w) - dot ( sd,sd );\n    if (disc>0.0) t = b - sqrt(disc);\n\treturn t;\n}\n\n// Finite difference normal\nvec3 normal(vec4 sph, vec3 p) {\n\tvec3 e = vec3(0.0,0.01,0.0);\n\t\n\treturn normalize(vec3(\n\t\t\tdsph(sph,p+e.yxx)-dsph(sph,p-e.yxx),\n\t\t\tdsph(sph,p+e.xyx)-dsph(sph,p-e.xyx),\n\t\t\tdsph(sph,p+e.xxy)-dsph(sph,p-e.xxy)\n\t\t\t)\n\t\t);\t\n}\n\n// AO\nfloat AO(in vec4 sph, in vec3 p, in vec3 n) {\n\tfloat ao = 0.0;\n\tfloat de = dsph(sph,p);\n\tfloat wSum = 0.0;\n\tfloat w = 1.0;\n    float d = 1.0;\n\tfloat aodetail=.02;\n\tfor (float i =1.0; i <6.0; i++) {\n\t\tfloat D = (dsph(sph,p+ d*n*i*i*aodetail) -de)/(d*i*i*aodetail);\n\t\tw *= 0.6;\n\t\tao += w*clamp(1.0-D,0.0,1.0);\n\t\twSum += w;\n\t}\n\treturn clamp(.9*ao/wSum, 0.0, 1.0);\n}\n\n// Shadows\nfloat shadow(in vec4 sph, in vec3 p) \n{\n\tvec3 ldir=-normalize(lightdir);\n\tfloat totdist=0., detail=0.01;\n\tfloat sh=1.;\n\tfor (int i=0; i<50; i++){;\n\t\tfloat d=dsph(sph,p+totdist*ldir);\n\t\tif (d<detail) {sh=0.;continue;}\n\t\tif (totdist>sph.w) {sh=1.;continue;}\n\t\ttotdist+=d*.5;\t\n\t}\n\treturn clamp(sh,0.,1.);\n}\n\n\n// Get gradient from 3-color palette using a coloring index \nvec3 getcolor(float index) {\n\tfloat cx=index*ColorDensity+ColorOffset*PI*3.;\n\tvec3 col;\n\tfloat ps=PI/1.5;\n\tfloat f1=max(0.,sin(cx));\n\tfloat f2=max(0.,sin(cx+ps));\n\tfloat f3=max(0.,sin(cx+ps*2.));\n\tcol=mix(Color1,Color2,f1);\n\tcol=mix(col,mix(Color3,Color1,f3),f2);\n\tcol=mix(vec3(length(col)),col,Saturation);\n\treturn col;\n}\n\n// Ligthing - diffusse+specular+ambient\nvec3 light(in vec4 sph, in vec3 p, in vec3 dir) {\n\tvec3 ldir=normalize(lightdir);\n\tvec3 n=normal(sph,p);\n\tfloat sh=shadow(sph,p);\n\tfloat diff=max(0.,dot(ldir,-n))*sh+.12;\n\t//diff*=(1.-AO(sph,p,n));\n\tvec3 r = reflect(ldir,n);\n\tfloat spec=max(0.,dot(dir,-r))*sh;\n\treturn vec3(diff*.7+pow(spec,6.)*0.6);\t\n\t\t}\n\n// Raymarching inside the planet's atmosphere :)\nvec3 march(in vec4 sph, in vec3 from, in vec3 dir) \n{\n\tfloat totdist=0., detail=0.01;\n\tvec3 col, p;\n\tfloat d;\n\tfor (int i=0; i<200; i++) {\n\t\tp=from+totdist*dir;\n\t\td=dsph(sph,p)*.4;\n\t\tif (d<detail || totdist>sph.w) break;\n\t\ttotdist+=d; \n\t}\n\tvec3 back=vec3(1.)*0.5;\n\tif (d<detail) {\n\t\tfloat cindex=colindex;\n\t\tcol=getcolor(cindex)*light(sph, p-detail*dir*10., dir); \n\t} else { \n\t\tcol=vec3(0.);\n\t}\n\treturn col;\n}\n\n// Main code\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 mouse=iMouse.xy/iResolution.xy-vec2(.5);\n\tmat3 camrot1;\n\tmat3 camrot2;\n\tfloat ang=iTime*.15+4.5;\n\tcamrot1=rotmat(vec3(0.,1.,0.),1.+mouse.x*PI*1.5+ang);\n\tcamrot2=rotmat(vec3(1.,0.,0.),1.-mouse.y*PI*1.5);\n\tmat3 camrot=camrot1*camrot2; // camera rotation\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv=uv*2.-1.;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 from=vec3(0.,0.,-8.)*camrot;\n\tvec3 dir=normalize(vec3(uv*.7,1.))*camrot;\n\tvec3 col=vec3(0.);\n\tvec4 sph=vec4(0.,0.,0.,2.8); // sphere position and size \n\t\t\t\t\t\t\t\t // (I leave the coordinate part for future use)\n\tfloat t=isph(sph,from,dir); // intersect with sphere\n\tif (t<999.) {;\n\t\tcol=march(sph,from+t*dir,dir); // raymarch a bit from there for the texture\n\t\t}\n\tfloat dirlen=length(dir.xy);\n\tvec3 suncol=vec3(1.,.9,.85)*(sign(dir.z)+1.)*.5; //I used sign to eliminate the twin sun\n\tfloat occult=min(pow(max(0.,length(from.xy)-sph.w*.92),0.6),.6); // light occulting factor\n\tfloat sundisc=-sign(dirlen-.02); // plain sun disc\n\tfloat sunbody=pow(smoothstep(.1+occult*.1,0.,dirlen),3.)*1.3; // outside glow\n\tfloat rayrad=pow(max(0.,1.-dirlen),4.); // rays length\n\tfloat sunrays=0.;\n\tvec3 rdir=dir*rotmat(vec3(0.,0.,1.),-length(from.xy)*.3);\n\tfor (float s=0.; s<3.; s++){ // get the rays, randomize a bit\n\t\tmat3 rayrot=rotmat(vec3(0.,0.,1.),PI/6.+rand(vec2((s+1.)*5.2165485))*.1);\n\t\tsunrays+=pow(max(0.,1.-abs(rdir.x)*2.-abs(rdir.y)*.05),100.)\n\t\t\t    *pow(rayrad,.2+rand(vec2((s+1.)*12.215685))*1.5)*.4;\n\t\trdir*=rayrot;\n\t\tsunrays+=pow(max(0.,1.-abs(rdir.x)*3.-abs(rdir.y)*.05),150.)\n\t\t\t    *pow(rayrad,.5+rand(vec2((s+1.)*46.243685))*5.)*.3;\n\t\trdir*=rayrot;\n\t}\n\tif (col==vec3(0.)) {// hit nothing\n\t\tcol+=vec3(max(0.,.5*KalisetStars(dir*10.)))*max(0.,1.-sunbody*2.5); //stars\n\t\tcol+=vec3(.95,.93,1.)*exp(-38.*pow(length(uv),3.5))*3.7 //atmosphere backlight glow\n\t\t\t*pow(max(0.,dot(normalize(lightdir),-dir)),3.);\n\t\t//lower the glow and rays when sun is partially hidden\n\t\tfloat sun=min(1.1,sunbody+sunrays*(occult+.2)); \n\t\tsun*=.8+min(.2,occult);\n\t\tcol+=suncol*max(sundisc,sun); // make sundisk visible when partial hidden\n\t} else { //hit planet\n\t\t\tcol+=suncol*sunrays*occult*.8; // rays over planet, based on hide ammount\n\t\t\tcol+=suncol*sunbody*smoothstep(0.435,1.,length(uv))*20.; //tiny bloom effect\n\t}\n\t\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tXGzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[313, 348, 382, 382, 732], [734, 820, 840, 840, 909], [1080, 1080, 1110, 1110, 1399], [1401, 1401, 1429, 1429, 1662], [1665, 1725, 1762, 1813, 1953], [1955, 1983, 2032, 2032, 2208], [2210, 2238, 2269, 2269, 2457], [2459, 2465, 2510, 2510, 2827], [2829, 2840, 2879, 2879, 3143], [3146, 3207, 3235, 3235, 3529], [3531, 3571, 3620, 3620, 3876], [3878, 3927, 3980, 3980, 4336], [4338, 4351, 4408, 4408, 6697]], "test": "valid"}
{"id": "llf3DS", "name": "cylinder - shadeaday", "author": "kig", "description": "adding more primitives little by little, shadeaday for 2015-02-23", "tags": ["shadeaday"], "likes": 7, "viewed": 271, "published": "Public", "date": "1424739718", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct material {\n    vec3 diffuseColor;\n    vec3 specularColor;\n    float specularPower;\n};\n\nvec3 shadeBg(vec3 nml, vec2 fragCoord)\n{\n    vec3 bgLight = normalize(vec3(\n        cos(iTime*0.2/0.954929658551372)*4.0, \n        sin(iTime/1.1936620731892151)*3.0 - 4.0, \n        sin(iTime*0.2/0.954929658551372)*8.0\n    ));\n\n\tvec2 aspect = vec2(iResolution.x/iResolution.y, 1.0);\n\tvec2 uv = (2.0 * fragCoord.xy / iResolution.xy - 1.0) * aspect;\n\tvec3 sun = vec3(1.0, 1.0, 0.5);\n\tfloat bgDiff = dot(nml, vec3(0.0, -1.0, 0.0));\n\tfloat sunPow = dot(nml, bgLight);\n\tfloat sp = max(sunPow, 0.0);\n\tvec3 bgCol = max(0.0, bgDiff)*2.0*vec3(0.2, 0.7, 1.0);\n\tbgCol += max(0.0, -bgDiff)*vec3(0.4, 0.55, 0.7);\n\tbgCol += vec3(0.2, 0.8, 0.7)*((0.5*pow(1.0-abs(bgDiff), 5.0)*(5.0-dot(uv,uv))));\n\tbgCol += sun*(0.5*pow( sp, 3.0)+pow( sp, 256.0));\n\tbgCol += vec3(0.5, 0.8, 0.15)*(pow( sp, 8.0) + pow( sp, abs(bgLight.y)*128.0));\n    bgCol += vec3(1.2,0.4,0.9) * ((1.0-pow(abs(bgDiff), 0.6)));// * 1.0 * map(-nml) * map(-nml*nml.y));\n\treturn pow(max(vec3(0.0), bgCol), vec3(1.9));\n}\n    \nfloat sphereDet(vec3 ray, vec3 dir, vec3 center, float radius, inout float b)\n{\n\tvec3 rc = ray-center;  // 1\n\tfloat c = dot(rc, rc); // 1\n\tc -= radius*radius;    // 2?\n\tb = dot(dir, rc);      // 1\n\treturn b*b - c;        // 2?\n}\n\nfloat sphere(vec3 ray, vec3 dir, vec3 center, float radius, float closestHit, material m, inout vec3 nml, inout material dst)\n{\n\tfloat b;\n\tfloat d = sphereDet(ray, dir, center, radius, b); // 7\n\tif (d < 0.0) { // 1\n\t\treturn closestHit;\n\t}\n\tfloat t = -b - sqrt(d); // 3\n\tif (t > 0.0 && t < closestHit) { // 2\n        nml = center - (ray+dir*t);\n        dst = m;\n\t} else {\n\t\tt = closestHit;\n\t}\n    return t;\n}\n\n// from http://stackoverflow.com/questions/4078401/trying-to-optimize-line-vs-cylinder-intersection\nfloat cylinder(vec3 ro, vec3 rd, vec3 cp, vec3 cd, float r, float closestHit, material m, inout vec3 nml, inout material dst) {\n\n    vec3 rc = ro - cp;\n    vec3 n = cross(rd, cd);\n\n    float len = length(n);\n\n    // Parallel? (?)\n    if(len < 0.00001 && len > 0.00001) {\n        return closestHit;\n    }\n\n    n = normalize(n);\n\n    float d = abs(dot(rc, n));\n\n    if (d <= r)\n    {\n        vec3 o = cross(rc, cd);\n        float t = -dot(o, n) / len;\n        o = normalize(cross(n, cd));\n        float s = abs( sqrt(r*r-d*d) / dot(rd, o) );\n        float inD = t-s;\n        float outD = t+s;\n        float lambda = outD;\n\n        if (inD < -0.00001) {\n            if(outD < -0.00001) {\n                return closestHit;\n            }\n        } else if (outD < -0.00001 || inD < outD) {\n            lambda = inD;\n        }\n        \n        if (lambda < closestHit) {\n            vec3 hb = (ro + rd*lambda) - cp;\n\n            float scale = dot(hb, cd);\n            nml = -normalize(hb - cd*scale);\n            dst = m;\n\n            return lambda;\n        }\n    }\n\n    return closestHit;\n}\n\nfloat triangle(vec3 p, vec3 d, vec3 v0, vec3 v1, vec3 v2, float closestHit, material m, inout vec3 nml, inout material dst, inout vec2 uv)\n{\n\tvec3 e1,e2,h,s,q;\n\tfloat a,f,u,v,t;\n\te1 = v1-v0;\n\te2 = v2-v0;\n\n\th = cross(d,e2);\n\ta = dot(e1,h);\n\n\tf = 1.0 / a;\n\ts = p-v0;\n\tu = f * dot(s,h);\n\n\tq = cross(s,e1);\n\tv = f * dot(d,q);\n\t\n\tif (u < 0.0 || u > 1.0 || v < 0.0 || u+v > 1.0) {\n\t\treturn closestHit;\n\t}\n\n\t// at this stage we can compute t to find out where\n\t// the intersection point is on the line\n\tt = f * dot(e2,q);\n\t\n    if (t > closestHit || t <= 0.00001 || (a > -0.00001 && a < 0.00001)) {\n        return closestHit;\n    }\n    \n    nml = normalize(cross(e1, e2));\n    if (dot(nml, d) < 0.0) {\n        nml = -nml;\n    }\n    dst = m;\n\tuv = vec2(u,v);\n\n    return t;\n}\n\n\nfloat plane(vec3 rp, vec3 rd, vec3 p, vec3 pnml, float closestHit, material m, inout vec3 nml, inout material dst)\n{\n\tfloat pd = dot(pnml, rd);\n\tfloat dist = dot(pnml, p-rp) / pd;\n\tif (abs(pd) > 0.00001 && dist > 0.0 && dist < closestHit) {\n\t\tnml = pnml;\n\t\tif (pd < 0.0) nml = -nml;\n\t\tclosestHit = dist;\n        dst = m;\n\t}\n\treturn closestHit;\n}\n\nfloat disk(vec3 rp, vec3 rd, vec3 p, vec3 pnml, float r1, float r2, float closestHit, material m, inout vec3 nml, inout material dst)\n{\n\tvec3 tmp;\n    material tmpMat;\n\tfloat dist = plane(rp, rd, p, pnml, closestHit, m, tmp, tmpMat);\n\tfloat len = length(rp + dist*rd - p);\n\tif (dist < closestHit && len >= r1 && len <= r2) {\n\t\tnml = tmp;\n\t\tclosestHit = dist;\n        dst = m;\n\t}\n\treturn closestHit;\n}\n\nfloat scene(vec3 ro, vec3 rd, inout vec3 nml, inout material m) {\n    float closestHit = 1e5;\n    float t = iTime * 1.12346;\n    material red, blue, white;\n    \n    red.diffuseColor = vec3(1.0, 0.3, 0.1);\n    red.specularColor = vec3(1.0, 0.6, 0.3) * 2.0;\n    red.specularPower = 8.0;\n\n    blue.diffuseColor = vec3(0.2, 0.5, 1.0) * 2.0;\n    blue.specularColor = vec3(1.0);\n\tblue.specularPower = 32.0;\n\n    white.diffuseColor = vec3(0.1, 0.15, 0.2);\n    white.specularColor = vec3(0.25);\n    white.specularPower = 1024.0;\n    \n    vec2 uv = vec2(0);\n    \n    closestHit = sphere(ro, rd, vec3(cos(t)*2.0, sin(t*0.8)*3.0, 2.0+cos(t*0.5)*2.0), 1.0, closestHit, red, nml, m);\n    closestHit = sphere(ro, rd, vec3(cos(t*1.1)*3.0, sin(t*0.68)*4.0, 2.5+cos(t*0.65)*3.0), 1.0, closestHit, blue, nml, m);\n    //closestHit = plane(ro, rd, vec3(0.0, 7.0, 7.0), normalize(vec3(0.0, 1.0, 1.0)), closestHit, white, nml, m);\n    closestHit = triangle(ro, rd, vec3(1.0,0,7.0), vec3(6.0, 0, 7.0), vec3(1.0, 5.0, 7.0), closestHit, red, nml, m, uv);\n\n    closestHit = triangle(ro, rd, vec3(-0.0,0,7.0), vec3(-5.0, 0, 7.0), vec3(-0.0, 5.0, 7.0), closestHit, red, nml, m, uv);\n    //closestHit = triangle(ro, rd, vec3(-0.0,5.0,7.0), vec3(-5.0, 5.0, 7.0), vec3(-5.0, 0.0, 7.0), closestHit, blue, nml, m, uv);\n\n    closestHit = cylinder(ro, rd, vec3(0.0, 15.0, 0.0), normalize(vec3(sin(iTime+1.0), -1.0, 1.0)), 0.5, closestHit, blue, nml, m);\n    closestHit = cylinder(ro, rd, vec3(-8.0, 0.0, 0.0), normalize(vec3(1.0, cos(iTime), 1.0)), 1.0, closestHit, red, nml, m);\n    closestHit = cylinder(ro, rd, vec3(8.0, 0.0, 0.0), normalize(vec3(-1.0, sin(iTime), 1.0)), 1.5, closestHit, white, nml, m);\n    \n    return closestHit;\n}\n\nvec3 shade(vec3 ro, vec3 rd, vec3 nml, material m) {\n    vec3 bgLight = normalize(vec3(\n        cos(iTime*0.2/0.954929658551372)*4.0, \n        sin(iTime/1.1936620731892151)*3.0 - 4.0, \n        sin(iTime*0.2/0.954929658551372)*8.0\n    ));\n\n    vec3 lightPos = bgLight * 1e5; //vec3(4.0)*vec3(sin(iTime*0.3), cos(iTime*0.7), sin(iTime));\n    material shadowMat;\n    vec3 lightVec = (lightPos - ro);\n    float lightDist = length(lightVec);\n    vec3 lightDir = normalize(lightVec);\n    float diffuse = dot(nml, -lightDir);\n    float diffuseStep = (diffuse > 0.0 && m.specularPower > 0.0 ? 1.0 : 0.0);\n    float specular = diffuseStep * pow(clamp(dot(lightDir, rd), 0.0, 1.0), m.specularPower);\n    ro += rd * 0.005;\n    float shadow = 0.0;\n    float r = 0.2;\n    vec3 lX = normalize(cross(lightDir, vec3(1.0, 0.0, 0.0)));\n    vec3 lY = normalize(cross(lightDir, lX));\n    shadow += scene(ro, lightDir, nml, shadowMat) < lightDist ? 0.0 : 1.0;\n/*\n\tlightDir = normalize(lightPos + r * lX - ro);\n    shadow += scene(ro, lightDir, nml, shadowMat) < lightDist ? 0.0 : 1.0;\n    lightDir = normalize(lightPos + -r * lX - ro);\n    shadow += scene(ro, lightDir, nml, shadowMat) < lightDist ? 0.0 : 1.0;\n    lightDir = normalize(lightPos + r * lY - ro);\n    shadow += scene(ro, lightDir, nml, shadowMat) < lightDist ? 0.0 : 1.0;\n    lightDir = normalize(lightPos + -r * lY - ro);\n    shadow += scene(ro, lightDir, nml, shadowMat) < lightDist ? 0.0 : 1.0;\n    shadow /= 5.0;\n*/\n    return shadow * ( m.diffuseColor*max(0.0, diffuse) + m.specularColor*specular ) + max(0.0, -diffuse)*vec3(0.1, 0.15, 0.2);        \n}\n\nvec3 trace(vec2 xy) {\n    vec2 uv = 1.0 - 2.0 * xy / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, -8.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    \n    vec3 col = vec3(0.0);\n    \n    vec3 nml = vec3(1.0);\n    material m;\n    vec3 transmit = vec3(1.0);\n    for (int i = 0; i < 3; i++) {\n\t    float closestHit = scene(ro, rd, nml, m);\n\t    if (closestHit < 1e5) {\n            ro += rd * closestHit;\n            nml = normalize(nml);\n            rd = reflect(rd, nml);\n            col += transmit * shade(ro, rd, nml, m);\n            transmit *= m.specularColor;\n            ro += rd * 0.01;\n        } else {\n            col += transmit * 0.2 * shadeBg(rd, xy);\n            break;\n        }\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 col = vec3(0.0);\n    col += trace(fragCoord.xy);\n    col += trace(fragCoord.xy+vec2(0.5, 0.0));\n    col += trace(fragCoord.xy+vec2(0.0, 0.5));\n    col += trace(fragCoord.xy+vec2(0.5, 0.5));\n\tfragColor = vec4(col / 4.0, 1.0);    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llf3DS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[94, 94, 134, 134, 1059], [1065, 1065, 1144, 1144, 1293], [1295, 1295, 1422, 1422, 1702], [1704, 1804, 1931, 1931, 2890], [2892, 2892, 3032, 3032, 3659], [3662, 3662, 3778, 3778, 4007], [4009, 4009, 4144, 4144, 4409], [4411, 4411, 4476, 4476, 6113], [6115, 6115, 6167, 6167, 7714], [7716, 7716, 7737, 7737, 8472], [8474, 8474, 8531, 8531, 8768]], "test": "valid"}
{"id": "llf3zS", "name": "Fireflies in mirrors corridor", "author": "PolarNick239", "description": "In fact raymarching here is not raymarching - because of explicit calculation of accurate distance for every march (for performance reasons).", "tags": ["raymarching", "antialiasing", "reflections"], "likes": 3, "viewed": 262, "published": "Public", "date": "1422900528", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision highp float;\n\nconst float idAbyss = -1.0;\nconst float idMirror0 = 0.0;\nconst float idMirror1 = 1.0;\nconst float idMirrorEdge0 = 2.0;\nconst float idMirrorEdge1 = 3.0;\n\nconst float mirrorX = 1.0;\nconst float mirrorWidth = 0.5;\nfloat mirrorHeight;\nconst float mirrorEdgeWidth = 0.01;\nconst float fireflyRadius = 0.005;\nconst float fireflyLightRadius = 0.05;\n\nconst vec3 edgeColor1 = vec3(0.75, 0.75, 0.75);\nconst vec3 edgeColor0 = vec3(1.0, 0.84, 0.0);\nconst vec3 abyssColor = vec3(0.0, 0.0, 0.0);\nconst vec3 errorColor = vec3(1.0, 0.0, 0.0);\n\nconst float INFINITY = 1000.0;\nconst float EPS = 0.000001;\nconst float minDistance = 0.001;\nconst float PI = 3.14159265359;\nconst float START_MOVING_TIME = 10.0;\nconst float ACCELERATION_MOVING_TIME = 5.0;\n\n\nfloat iAntialising = 1.0; // Can be 0/1/2/3/4 (0X / 4X / 16X / 64X / 256X)\n\n\nfloat cameraRollAngle;  // Camera rotation angle around its ray of view.\nvec3 cameraOffset;\nvec3 cameraPosition;  // This is relative camera position. Real world camera position is (cameraOffset + cameraPosition).\n\nconst int firefliesCount = 4;\n\nvec3 firefliesPosition[firefliesCount];\nvec3 firefliesColor[firefliesCount];\n\n\nvoid initFireflies(float time) {\n    firefliesPosition[0] = vec3(-0.7 + sin(time * 5.0) * 0.05, sin(time + PI/2.0)*0.3-0.2, cos(time + PI/2.0)*0.2-0.1);\n    firefliesPosition[1] = vec3(-0.7 + sin(time * 5.0) * 0.05,\n        (mod(time, 4.0 * PI) > 2.0 * PI) ? sin(time + PI/2.0)*0.3-0.2 : sin(-time - PI/2.0)*0.1+0.2,\n        cos(time + PI/2.0)*0.2-0.1);\n    firefliesPosition[2] = vec3(sin(time) * 0.4, sin(time) * 0.1, cos(time) * 0.2);\n    firefliesPosition[3] = vec3(cos(time) * 1.8, sin(time) * mirrorWidth, -0.3);\n\n    firefliesColor[0] = vec3(0.0, 0.0, 1.0);\n    firefliesColor[1] = vec3(1.0, 0.0, 0.0);\n    firefliesColor[2] = vec3(0.0, 1.0, 0.0);\n    firefliesColor[3] = vec3(0.1, 0.3, 0.1);\n}\n\nvoid updateWorld(float time) {\n    time /= 500.0;\n    initFireflies(time);\n    mirrorHeight = mirrorWidth * iResolution.y / iResolution.x;\n\n    if (time < START_MOVING_TIME) {\n        time = 0.0;\n    } else {\n        time -= START_MOVING_TIME;\n        float p = 4.0;\n        float a = 1.0 / (p * pow(ACCELERATION_MOVING_TIME, p - 1.0));\n        if (time < ACCELERATION_MOVING_TIME) {\n            time = a * pow(time, p);\n        } else {\n            time = a * pow(ACCELERATION_MOVING_TIME, p) + (time - ACCELERATION_MOVING_TIME);\n        }\n    }\n    float t = sin(time*0.3);\n    cameraOffset = vec3(0.5 - 0.3 * t * t, t * (mirrorWidth + 0.1), 0.1*t*t);\n    vec2 xMotionNormal = normalize(vec2(2.0*0.3*t, 1.0));\n    cameraPosition = vec3(0.1*xMotionNormal.y, 0.1*xMotionNormal.x, 0.0);\n    cameraRollAngle = 5.0 * sin(time*0.8);\n}\n\nfloat projectPointOnTheSegment(in vec3 position, in vec3 a, in vec3 b) {\n    vec3 ap = position - a;\n    vec3 ab = b - a;\n    return dot(ap, ab) / dot(ab, ab);\n}\n\nfloat segment(in vec3 position, in vec3 a, in vec3 b) {\n    vec3 ap = position - a;\n    vec3 ab = b - a;\n    float t = dot(ap, ab) / dot(ab, ab);\n    return length(ap - ab * clamp(t, 0.0, 1.0));\n}\n\nfloat intersectRayWithYZPlane(in vec3 position, in vec3 direction, in float planeX) {\n    return (planeX - position.x) / direction.x;\n}\n\n\nvec2 update(in vec2 nearest, in vec2 candidate) {\n    return (candidate.x < nearest.x) ? candidate : nearest;\n}\n\nvec2 findNearest(in vec3 position, in vec3 direction) {\n    direction = normalize(direction);\n    float mirrorId = (direction.x < 0.0) ? idMirror0 : idMirror1;\n    float curMirrorX = (mirrorId == idMirror0) ? -mirrorX : mirrorX;\n    float toGoMirror = intersectRayWithYZPlane(position, direction, curMirrorX);\n    if (toGoMirror < -EPS) {\n        return vec2(INFINITY, idAbyss);\n    }\n    vec3 intersection = position + direction * toGoMirror;\n    if (abs(intersection.y) < mirrorWidth + EPS && abs(intersection.z) < mirrorHeight + EPS) {\n        return vec2(toGoMirror, mirrorId);\n    } else if (abs(intersection.y) < mirrorWidth + mirrorEdgeWidth + EPS && abs(intersection.z) < mirrorHeight + mirrorEdgeWidth + EPS) {\n        return vec2(toGoMirror, (mirrorId == idMirror0) ? idMirrorEdge0 : idMirrorEdge1);\n    } else {\n        return vec2(INFINITY, idAbyss);\n    }\n}\n\nvec3 getColor(float id) {\n    if (id == idMirrorEdge0) {\n        return edgeColor0;\n    } else if (id == idMirrorEdge1) {\n        return edgeColor1;\n    } else if (id == idAbyss) {\n        return abyssColor;\n    } else {\n        return errorColor;\n    }\n}\n\nvec3 calcNormal(float id) {\n    if (id == idMirror0 || id == idMirrorEdge0) {\n        return vec3(+1.0, 0.0, 0.0);\n    } else if (id == idMirror1 || id == idMirrorEdge1) {\n        return vec3(-1.0, 0.0, 0.0);\n    } else {\n        return vec3(0.0, 0.0, 1.0);\n    }\n}\n\nvec2 castRay(in vec3 rayStart, in vec3 rayDirection, inout vec3 haloColor) {\n    rayDirection = normalize(rayDirection);\n    vec2 nearest = findNearest(rayStart, rayDirection);\n    float depth = nearest.x;\n\n    for (int j = 0; j < firefliesCount; j++) {\n        float t = projectPointOnTheSegment(firefliesPosition[j], rayStart, rayStart + depth * rayDirection);\n        float dist = segment(firefliesPosition[j], rayStart, rayStart + depth * rayDirection);\n        if (t >= 0.0 && t < 1.0) {\n            if (dist < fireflyRadius) {\n                haloColor += firefliesColor[j];\n            } else if (dist < fireflyLightRadius) {\n                float fraction = 1.0 - sqrt(dist - fireflyRadius) / sqrt(fireflyLightRadius - fireflyRadius);\n                haloColor += firefliesColor[j] * fraction;\n            }\n        }\n    }\n    return nearest;\n}\n\nvec3 render(in vec3 rayStart, in vec3 rayDirection) {\n    const int maxReflections = 4096;\n\n    vec3 halo = vec3(0.0, 0.0, 0.0);\n    float nearestObjectId;\n    vec3 position;\n    for (int i = 0; i < maxReflections; i++) {\n        vec2 res = castRay(rayStart, rayDirection, halo);\n\n        position = rayStart + rayDirection * res.x;\n        nearestObjectId = res.y;\n        if (nearestObjectId == idMirror0 || nearestObjectId == idMirror1) {\n            rayStart = position;\n            rayDirection.x *= -1.0;\n        } else {\n            break;\n        }\n    }\n\n\n    vec3 objectColor = getColor(nearestObjectId);\n    vec3 objectNormal = calcNormal(nearestObjectId);\n\n    float globalAmbient = 0.8;\n    vec3 color = objectColor * globalAmbient;\n\n    color += halo;\n    return min(color, vec3(1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    updateWorld(iTime * 1000.0);\n\n    float cameraAngleOfView = 90.0 * PI / 180.0;\n    float cameraFocalDistance = 1.0 / tan(cameraAngleOfView / 2.0);\n\n    vec3 cameraDirection = normalize(-cameraPosition);\n    vec3 cameraScreenXAxis = normalize( cross(cameraDirection, (cameraDirection.xy != vec2(0.0, 0.0)) ? vec3(0.0, 0.0, 1.0): vec3(0.0, 1.0, 0.0)) );\n    vec3 cameraScreenYAxis = normalize( cross(cameraScreenXAxis, cameraDirection) );\n    vec3 screenCenter = cameraDirection * cameraFocalDistance;\n    float subPixels = pow(4.0, iAntialising);\n    vec3 color = vec3(0.0);\n    for (float i = 0.0; i < 256.0; i++) {\n        if (i >= subPixels) {\n            break;\n        }\n        float subPixelsInRow = pow(2.0, iAntialising);\n        vec2 pixel = fragCoord.xy + vec2(mod(i, subPixelsInRow), mod(i / subPixelsInRow, subPixelsInRow)) / subPixelsInRow;\n        pixel = (pixel / iResolution.xy - 0.5) * 2.0;\n        pixel.y *= iResolution.y / iResolution.x;\n\n        float cosRoll = cos(-cameraRollAngle*PI/180.0);\n        float sinRoll = sin(-cameraRollAngle*PI/180.0);\n        mat2 cameraRollRotation = mat2(cosRoll, -sinRoll, sinRoll, cosRoll);\n        pixel = cameraRollRotation * pixel;\n\n        vec3 rayDirection = normalize( screenCenter + (pixel.x * cameraScreenXAxis) + (pixel.y * cameraScreenYAxis) );\n        color += render(cameraOffset + cameraPosition, rayDirection);\n    }\n\n    fragColor.rgb = color / subPixels;\n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llf3zS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1161, 1161, 1193, 1193, 1862], [1864, 1864, 1894, 1894, 2694], [2696, 2696, 2768, 2768, 2857], [2859, 2859, 2914, 2914, 3055], [3057, 3057, 3142, 3142, 3192], [3195, 3195, 3244, 3244, 3306], [3308, 3308, 3363, 3363, 4178], [4180, 4180, 4205, 4205, 4435], [4437, 4437, 4464, 4464, 4702], [4704, 4704, 4780, 4780, 5557], [5559, 5559, 5612, 5612, 6360], [6362, 6362, 6419, 6419, 7876]], "test": "valid"}
{"id": "llfGRl", "name": "Mandelbox closeup", "author": "kig", "description": "Mandelbox distance field from rrrola's Boxplorer, #shadeADay for 2015-02-17", "tags": ["shadeaday"], "likes": 4, "viewed": 210, "published": "Public", "date": "1424202717", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float mandelbox(vec3 w) {\n    float scale = 2.0;\n    float c = 2.0;\n    float r = 0.5;\n\n    for (int i = 0; i < 20; i++) {\n        if (w.x > 1.0) {\n            w.x = 2.0 - w.x;\n        } else if (w.x < -1.0) {\n            w.x = -2.0 - w.x;\n        }\n        if (w.y > 1.0) {\n            w.y = 2.0 - w.y;\n        } else if (w.y < -1.0) {\n            w.y = -2.0 - w.y;\n        }\n        if (w.z > 1.0) {\n            w.z = 2.0 - w.z;\n        } else if (w.z < -1.0) {\n            w.z = -2.0 - w.z;\n        }\n        float lw = length(w);\n        \n        if (lw > 1000.0) {\n            return float(i)/2.0;\n        }\n\n        if (lw < r) {\n            w = w / (r*r);;\n        } else if (lw < 1.0) {\n            w = w / (lw*lw);\n        }\n        w = scale * w + c;\n    }\n    return 0.0;\n}\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);  \n}\n\nvec3 shadeBg(vec2 fragCoord, vec3 nml)\n{\n\tvec2 aspect = vec2(iResolution.x/iResolution.y, 1.0);\n\tvec2 uv = (2.0 * fragCoord.xy / iResolution.xy - 1.0) * aspect;\n\tvec3 bgLight = normalize(vec3(\n\t\tcos(iTime*0.2/0.954929658551372)*4.0, \n\t\tsin(iTime/1.1936620731892151)*3.0 - 4.0, \n\t\tsin(iTime*0.2/0.954929658551372)*8.0\n\t));\n\tvec3 sun = vec3(2.0, 1.5, 1.0);\n\tfloat bgDiff = dot(nml, vec3(0.0, -1.0, 0.0));\n\tfloat sunPow = dot(nml, bgLight);\n\tfloat sp = max(sunPow, 0.0);\n\tvec3 bgCol = max(0.0, bgDiff)*2.0*vec3(0.4, 0.7, 0.65);\n\tbgCol += max(0.0, -bgDiff)*vec3(0.4, 0.55, 0.9);\n\tbgCol += vec3(0.2, 0.5, 0.7)*((0.5*pow(1.0-abs(bgDiff), 5.0)*(5.0-dot(uv,uv))));\n\tbgCol += sun*(0.5*pow( sp, 3.0)+pow( sp, 256.0));\n\tbgCol += vec3(0.5, 0.2, 0.15)*(pow( sp, 8.0) + pow( sp, abs(bgLight.y)*128.0));\n    //bgCol += vec3(1.9,0.,0.9) * ((1.0-pow(abs(bgDiff), 0.6)) * 0.5);\n\treturn pow(max(vec3(0.0), bgCol), vec3(1.9));\n}\n\nfloat mandelbox_dist(vec3 pos) {\n    vec4 p = vec4(pos, 1.0), p0 = p;\n    float minRad2 = 0.25;\n    vec4 scale = vec4(2.0) / minRad2;\n    float absScalem1 = abs(2.0 - 1.0);\n    float AbsScaleRaisedTo1mIters = pow(abs(2.0), (1.0 - 20.0));\n    for (int i=0; i<20; i++) {\n        p.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;\n        float r2 = dot(p.xyz, p.xyz);\n        p *= clamp(max(minRad2/r2, minRad2), 0.0, 1.0);\n        p = p * scale + p0;\n    }\n    return ((length(p.xyz) - absScalem1) / p.w - AbsScaleRaisedTo1mIters);\n}\n\nfloat scene(vec3 p) {\n    return mandelbox_dist(p);\n}\n\nvec3 normal(vec3 p, float d)\n{\n\tfloat e = 0.005;\n\tfloat dx = scene(vec3(e, 0.0, 0.0) + p) - d;\n\tfloat dy = scene(vec3(0.0, e, 0.0) + p) - d;\n\tfloat dz = scene(vec3(0.0, 0.0, e) + p) - d;\n\treturn normalize(vec3(dx, dy, dz));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = (0.5 - uv) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    float time = 406.9;\n    float a = cos(time/3.53423*0.5);\n    float ca = cos(a), sa = sin(a);\n    uv *= mat2(ca, sa, -sa, ca);\n    mat3 rot = rotationMatrix(normalize(vec3(1.0, -0.5, 0.5)),406.9*2.0);\n    vec3 ro = rot*vec3(0,0,-15.0);\n    vec3 rd = rot*normalize(vec3(uv, 15.0+10.0*sin(3.14159+iTime*0.2)));\n    ro += rd * 4.0;\n    vec3 transmit = vec3(1.0);\n    float bounce = 0.0;\n\n    for (int i=0; i<300; i++) {\n        float t = scene(ro);\n        if (t < 0.0025) {\n\t        vec3 nml = normal(ro, t);\n            rd = normalize(reflect(rd, nml));\n            ro += rd * 0.005;\n            transmit *= vec3(0.75, 0.8, 0.9)*0.7 - (bounce == 0.0 ? float(i)/70.0 : 0.0);\n            break;\n        } else {\n\t        ro += rd * t;\n        }\n        if (t > 17.0) {\n            break;\n        }\n    }\n\tfragColor = vec4(transmit*shadeBg(fragCoord, -rd), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llfGRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 784], [786, 786, 831, 831, 1305], [1307, 1307, 1347, 1347, 2215], [2217, 2217, 2249, 2249, 2745], [2747, 2747, 2768, 2768, 2800], [2802, 2802, 2832, 2832, 3027], [3029, 3029, 3086, 3086, 4062]], "test": "valid"}
{"id": "llfGWB", "name": "SHADE A DAY (  2 / 24 / 2015 )", "author": "cabbibo", "description": "playing with luminance structure more", "tags": ["glsl", "raytrace"], "likes": 16, "viewed": 662, "published": "Public", "date": "1424803355", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// ALL TAKEN FROM IQs AMAZING SITE / TUTORIALS / SHADERS:\n// http://www.iquilezles.org/www/index.htm\n// https://www.shadertoy.com/user/iq\n\n\nconst float MAX_TRACE_DISTANCE = 10.0;           // max trace distance\nconst float INTERSECTION_PRECISION = 0.001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 200;\n\n\n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y*1.)), tri(p.z+tri(p.x*1.)), tri(p.y+tri(p.x*1.)));}\n                                 \n\n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat triNoise3D(in vec3 p, in float spd)\n{\n    float z=1.4;\n\tfloat rz = 0.;\n    vec3 bp = p;\n\tfor (float i=0.; i<=3.; i++ )\n\t{\n        vec3 dg = tri3(bp*2.);\n        p += (dg+iTime*.1*spd);\n\n        bp *= 1.8;\n\t\tz *= 1.5;\n\t\tp *= 1.2;\n        //p.xz*= m2;\n        \n        rz+= (tri(p.z+tri(p.x+tri(p.y))))/z;\n        bp += 0.14;\n\t}\n\treturn rz;\n}\n\nfloat posToFloat( vec3 p ){\n \n    float f = triNoise3D( p * .2, .1 );\n    return f;\n    \n}\n\nvoid buildBasis( in vec3 dir , in vec3 up , out vec3 x , out vec3 y , out vec3 z ){\n    \n\n //vec3( 0. , 1. , 0. );\n  //vec3  upVector = normalize( centerOfCircle );// vec3( 0. , 1. , 0. );\n  float upVectorProj = dot( up , dir );\n  vec3  upVectorPara = upVectorProj * dir;\n  vec3  upVectorPerp = up - upVectorPara;\n\n  vec3 basisX = normalize( upVectorPerp );\n  vec3 basisY = cross( dir , basisX );\n    \n    \n  x = basisX;\n  y = basisY;\n  z = dir;\n    \n}\n\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 0.3 + 10.0*mouseX;\n\tcamPos = vec3(3.5*sin(an),2.0,3.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n// ROTATION FUNCTIONS TAKEN FROM\n//https://www.shadertoy.com/view/XsSSzG\nmat3 xrotate(float t) {\n\treturn mat3(1.0, 0.0, 0.0,\n                0.0, cos(t), -sin(t),\n                0.0, sin(t), cos(t));\n}\n\nmat3 yrotate(float t) {\n\treturn mat3(cos(t), 0.0, -sin(t),\n                0.0, 1.0, 0.0,\n                sin(t), 0.0, cos(t));\n}\n\nmat3 zrotate(float t) {\n    return mat3(cos(t), -sin(t), 0.0,\n                sin(t), cos(t), 0.0,\n                0.0, 0.0, 1.0);\n}\n\n\nmat3 fullRotate( vec3 r ){\n \n   return xrotate( r.x ) * yrotate( r.y ) * zrotate( r.z );\n    \n}\n\nfloat rotatedBox( vec3 p , vec3 rot , vec3 size , float rad ){\n    \n    vec3 q = fullRotate( rot ) * p;\n    return udRoundBox( q , size , rad );\n    \n    \n}\n\n\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \n\treturn (d1.x<d2.x) ? d1 : d2;\n    \n}\n\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos ){  \n    \n   \tvec2 res = vec2( rotatedBox( pos , vec3( iTime * .05 + 1., iTime * .02 + 2. , iTime * .03  ), vec3( 0.7 ) , .1 ) , 1.0 );\n   \t//vec2 res2 = vec2( sdPlane( pos - vec3( 0. , -1. , 0. )), 0.0 );\n   \t//vec2 res2 = vec2( sdSphere( pos - vec3( 0. , 0. , 0. ) , .5 ), 0.0 );\n    //res = opU( res ,  res2 );\n   \treturn res;\n    \n}\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t );\n        h = m.x;\n        t += h;\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n}\n\n\n#define STEPS 50\nfloat fogCube( vec3 ro , vec3 rd , vec3 n ){\n \n    float lum = 1.;\n    for( int i = 0; i < STEPS; i++ ){\n        vec3 p = ro + rd * .01  * float( i );\n        lum += posToFloat( p );// + sin( p.y * 3. ) + sin( p.z * 5.);\n    }\n    \n    return lum;\n    \n    \n}\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n    \n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\nvec3 hsv(float h, float s, float v)\n{\n  return mix( vec3( 1.0 ), clamp( ( abs( fract(\n    h + vec3( 3.0, 2.0, 1.0 ) / 3.0 ) * 6.0 - 3.0 ) - 1.0 ), 0.0, 1.0 ), s ) * v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m.x );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n    vec2 res = calcIntersection( ro , rd  );\n\n\n    vec3 col = vec3( 0. );\n    \n    if( res.y > -.5 ){\n        \n        vec3 pos = ro + rd * res.x;\n        vec3 norm = calcNormal( pos );\n        \n       \tvec3 lightPos = vec3( 5. , 5. , 5. );\n        \n        lightPos -= pos;\n        lightPos = normalize( lightPos );\n        \n        vec3 refl = reflect( lightPos , norm );\n        \n        float eyeMatch = max( 0. , dot( refl , rd ) );\n        float lamb =max( 0.0 , dot( lightPos , norm ));\n        \n        \n        float lum = fogCube( pos , rd , norm );\n       // col = norm * .5 + .5;\n      \n        float lu = max( 0.0 , -dot( lightPos , norm ));\n        \n        vec3 nCol = hsv( posToFloat( pos) + .3 , .4 , 1.);\n        nCol *=pow( lum / 20. , min( 5. , 1./eyeMatch) ) * eyeMatch;\n        \n        vec3 col2 = hsv( posToFloat( pos) + .6, .6, .4);\n        nCol += lamb * col2 * pow( lum / 20. , min( 5. , 1./eyeMatch) ) * ( 1. - eyeMatch );\n        \n        vec3 col3 = hsv( posToFloat( pos) + .6, .9, .2);\n        nCol += col3 * pow( lum / 20. , min( 5. , 1./eyeMatch) ) * ( 1. - lamb );\n        \n       // nCol +=  vec3( .2 ) * ( 1. - eyeMatch );\n       // nCol *= hsv( abs(sin(lum * .1)) , .5 , 1. );\n        \n        //nCol += pow( eyeMatch , 10. ) * vec3( 1. );//hsv( eyeMatch * 1. , .5 , 1. );\n        col += nCol;\n        \n        \n    }\n\n    fragColor = vec4( col , 1. );\n\n\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llfGWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[334, 386, 408, 408, 433], [434, 434, 455, 455, 535], [571, 623, 666, 666, 969], [971, 971, 998, 998, 1061], [1063, 1063, 1146, 1251, 1515], [1518, 1518, 1549, 1549, 1587], [1590, 1590, 1635, 1635, 1675], [1678, 1709, 1773, 1773, 1951], [1953, 1953, 2036, 2036, 2149], [2151, 2224, 2247, 2247, 2353], [2355, 2355, 2378, 2378, 2484], [2486, 2486, 2509, 2509, 2618], [2621, 2621, 2647, 2647, 2716], [2718, 2718, 2780, 2780, 2874], [2878, 2972, 3001, 3001, 3044], [3046, 3130, 3151, 3151, 3485], [3487, 3487, 3535, 3535, 4002], [4022, 4022, 4066, 4066, 4281], [4283, 4396, 4427, 4427, 4653], [4656, 4656, 4693, 4693, 4825], [4827, 4827, 4884, 4884, 6801]], "test": "valid"}
{"id": "lll3DB", "name": "signal field", "author": "kig", "description": "#shadeADay for 2015-02-26", "tags": ["2d", "shadeaday"], "likes": 22, "viewed": 886, "published": "Public", "date": "1425001271", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = vec2(iResolution.x/iResolution.y,1.0) * (-1.0 + 2.0*fragCoord.xy / iResolution.xy);\n   \n    vec2 ouv = uv;\n    \n    float a = sin(iTime*0.5)*0.2;\n    float ca = cos(a);\n    float sa = sin(a);\n    \n    uv *= mat2(ca, sa, -sa, ca);\n\n    float df = abs(uv.y+1.3)*uv.x*uv.x;\n    uv *= 3.0+1.9*df;\n    uv.x += iTime*2.0;\n    uv.y += iTime*2.0;\n    \n    uv *= 2.0;\n\n    uv.x = pow(sin(uv.x+iTime*2.0) * cos(uv.y*3.0) * cos(uv.x*3.0+1.0), 4.0);\n    uv.y = abs(sin(uv.y*16.0) * cos(uv.x*12.0) * sin(uv.y*1.0+3.14159*0.5));\n\n    uv = pow(uv, vec2(1.0, 4.0));\n    \n\tfragColor = (1.0-pow(0.5*length(ouv), 3.0)) * vec4(uv.x+uv.x+0.1, 0.05+uv.y+uv.x, 0.25+uv.y, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lll3DB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 725]], "test": "valid"}
{"id": "lllGR2", "name": "Orbit Fractals", "author": "eiffie", "description": "A satellite orbiting a planet orbiting a sun orbiting a black hole would create interesting patterns if the scale was a bit more linear. The drawing code is based on [url]https://www.shadertoy.com/view/XdSSRw[/url] from nimitz.", "tags": ["fractal", "orbit"], "likes": 11, "viewed": 1727, "published": "Public API", "date": "1423503571", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Orbit Fractals by eiffie, based on Parametrics by nimitz https://www.shadertoy.com/view/XdSSRw\n\n//This is related to rolling fractals - http://www.fractalforums.com/new-theories-and-research/rolling-fractals/\n//I did not expect to find the HEX and TRIANGLE shapes in \"planetary\" orbits and with such strange scales! \n//I doubt they will work in your browser tho :(\n#define SIMP\n//#define SIMP3D\n//#define HEX\n//#define TRI\n//#define HASHTAG\n\n\n#define LOCAL_STEPS 6\n#define MIN_T 0.0\n#define SCALE_Z 0.0\n\n#ifdef SIMP\n\t#define GLOBAL_STEPS 99\n\t#define MAX_T 25.1\n\t#define ITERS 2\n\t#define SCALE -3.5\n#endif\n#ifdef SIMP3D\n\t#define GLOBAL_STEPS 99\n\t#define MAX_T 12.0\n\t#define ITERS 5\n\t#define SCALE -3.0\n\t#undef SCALE_Z\n\t#define SCALE_Z 2.0\n\t#define CAM_3D\n#endif\n#ifdef HEX\n\t#define GLOBAL_STEPS 1024\n\t#define MAX_T 150.0\n\t#define ITERS 3\n\t#define SCALE 3.4495\n#endif\n#ifdef TRI\n\t#define GLOBAL_STEPS 1024\n\t#define MAX_T 200.0\n\t#define ITERS 3\n\t#define SCALE 2.3028\n#endif\n#ifdef HASHTAG\n\t#define GLOBAL_STEPS 1024\n\t#define MAX_T 200.0\n\t#define ITERS 3\n\t#define SCALE -2.992\n#endif\n\n\n#define time iTime\n#define size iResolution\n\nvec3 orbit(float a, float r){return vec3(cos(SCALE_Z*a)*vec2(cos(a),sin(a)),sin(SCALE_Z*a))*r;}\nvec3 F(float t){\n\tfloat r=1.0;\n\tvec3 p=orbit(t,r);\n\tfor(int i=0;i<ITERS;i++){\n\t\tt*=SCALE,r/=abs(SCALE);\n\t\tp+=orbit(t,r);\n\t}\n\treturn p;\n}\nfloat SegD(vec3 pa, vec3 ba, vec3 rd){\n\tfloat d=dot(rd,ba);\n\tfloat t=clamp((dot(rd,pa)*d-dot(pa,ba))/(dot(ba,ba)-d*d),0.0,1.0);\n\tpa+=ba*t;\n\tfloat b=dot(pa,rd);\n\tfloat h=dot(pa,pa)-b*b;\n\treturn h;\n}\nfloat Arms(float t, vec3 ro, vec3 rd){\n\tfloat d=100.0;\n\tvec3 p1=vec3(0.0),p2;\n\tfloat r=1.0;\n\tfor(int i=0;i<ITERS+1;i++){\n\t\tp2=p1+orbit(t,r);\n\t\td=min(d,SegD(p1-ro,p2-p1,rd));\n\t\tt*=SCALE,r/=abs(SCALE);\n\t\tp1=p2;\n\t}\n\treturn d;\n}\nvec4 D=vec4(1000.0),TF=vec4(0.0),TN=vec4(0.0);//a stack of distances (from the curve, not to) and times\nvoid zStack(float d, float tf, float tn){\n\tif(d<D.x){D=vec4(d,D.xyz);TN=vec4(tn,TN.xyz);TF=vec4(tf,TF.xyz);}\n\telse if(d<D.y){D.yzw=vec3(d,D.yz);TN.yzw=vec3(tn,TN.yz);TF.yzw=vec3(tf,TF.yz);}\n\telse if(d<D.z){D.zw=vec2(d,D.z);TN.zw=vec2(tn,TN.z);TF.zw=vec2(tf,TF.z);}\n\telse if(d<D.w){D.w=d;TN.w=tn;TF.w=tf;}\n}\n\nvec3 scene( vec3 ro, vec3 rd )\n{\n\tfloat stride=2.0*(MAX_T-MIN_T)/float(GLOBAL_STEPS);\n\tfloat t=MIN_T,ot=t,d=0.0;\n\tvec3 p1=F(t),p2;\n\tfor(int i=0;i<GLOBAL_STEPS;i++){//stepping thru the whole curve to find possible roots\n\t\tt+=max(stride*0.2,stride*log(d+1.15));\n\t\tp2=F(t);\n\t\td=SegD(p1-ro,p2-p1,rd);\n\t\tzStack(d,t,ot);\n\t\tif(t>MAX_T)break;\n\t\tot=t;\n\t\tp1=p2;\n\t}\n\td=100.0;\n\tfor(int j=0;j<4;j++){//stepping thru the possible roots\n\t\tfloat near=TN.x,far=TF.x;\n\t\tfor(int i=0;i<LOCAL_STEPS;i++){//...and finding local minima\n\t\t\tfloat mid=(near+far)*0.5;\n\t\t\tp1=F(mid);\n\t\t\tfloat mdrv=SegD(p1-ro,F(far)-p1,rd)-SegD(p1-ro,F(near)-p1,rd);\n\t\t\tif(mdrv > 0.0)far=mid;else near=mid;\n\t\t}\n\t\tp1=F(near);p2=F(far);\n\t\td=min(d,SegD(p1-ro,p2-p1,rd));\n\t\tTN=TN.yzwx;TF=TF.yzwx;\n\t}\n\tvec3 col=vec3(smoothstep(0.0,0.0001,d));\n\td=Arms(time*0.5,ro,rd);\n\tcol=mix(vec3(0.0,0.75,0.0),col,smoothstep(0.0,0.0001,d));\n\treturn col;\n}\t \nmat3 lookat(vec3 fw){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,vec3(0.0,1.0,0.0)));return mat3(rt,cross(rt,fw),fw);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\tvec3 ro=vec3(0.0,0.0,3.0);\n#ifdef CAM_3D\n\tro=vec3(cos(time),0.05,sin(time))*3.0;\n#endif\n\tvec3 rd=lookat(-ro)*normalize(vec3(uv,2.0));\n\tfragColor = vec4(scene(ro,rd),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lllGR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1129, 1129, 1158, 1158, 1224], [1225, 1225, 1241, 1241, 1361], [1362, 1362, 1400, 1400, 1559], [1560, 1560, 1598, 1598, 1784], [1831, 1889, 1930, 1930, 2195], [2197, 2197, 2229, 2229, 3088], [3091, 3091, 3112, 3112, 3212], [3213, 3213, 3270, 3270, 3502]], "test": "valid"}
{"id": "lllGzs", "name": "SHADE A DAY ( 2 / 21 / 2015 )", "author": "cabbibo", "description": "making the same scene again. Trying to make light smoke prettier", "tags": ["raycast"], "likes": 1, "viewed": 401, "published": "Public", "date": "1424552173", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\t\n\tAll Code stolen from \n\thttps://www.shadertoy.com/view/Mdl3Rr\n\n\tand\n\t\n\thttp://www.iquilezles.org/www/index.htm\n\thttps://www.shadertoy.com/user/iq\n\n\tand\n\n\thttps://www.shadertoy.com/view/4ts3z2\n\n*/\n\n#define time iTime\n\n\nconst vec3 lightColor = vec3( 1. , .8 , .2 );\nconst vec3 skyColor = vec3( .2 , .3 , .4 ); // .1 , .2 , .3 \nconst float PI = 3.14159;\n   \n\nvec4 texCube( sampler2D sam, in vec3 p, in vec3 n, in float k )\n{\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n    vec3 w = pow( abs(n), vec3(k) );\n\treturn (x*w.x + y*w.y + z*w.z) / (w.x+w.y+w.z);\n}\n\n\n\n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y*1.)), tri(p.z+tri(p.x*1.)), tri(p.y+tri(p.x*1.)));}\n                                 \nmat2 m2 = mat2(0.970,  0.242, -0.242,  0.970);\n\n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat triNoise3d(in vec3 p, in float spd)\n{\n    float z=1.4;\n\tfloat rz = 0.;\n    vec3 bp = p;\n\tfor (float i=0.; i<=3.; i++ )\n\t{\n        vec3 dg = tri3(bp*2.);\n        p += (dg+time*.1*spd);\n\n        bp *= 1.8;\n\t\tz *= 1.5;\n\t\tp *= 1.2;\n        //p.xz*= m2;\n        \n        rz+= (tri(p.z+tri(p.x+tri(p.y))))/z;\n        bp += 0.14;\n\t}\n\treturn rz;\n}\n\n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat fogmap(in vec3 p , float d )\n{\n    //p.x += time*.0005;\n   // p.z += sin(p.x*.00005);\n    return triNoise3d(p*2.2/(d * 20.),0.2);\n}\n\n\n// Robert Cupisz 2013\n// Creative Commons Attribution-ShareAlike 3.0 Unported\n//\n// Bits of code taken from Inigo Quilez, including fbm(), impulse()\n// and friends, sdCone() and friends; also box() by Simon Green.\n\n#define INF 1.0e38\n#define HIT(x) hit = min(hit, x)\n#define ROOFPOS vec3(0,-1,0.01)\n\n\nvec4 spherePos[10];\nvec4 roofPos[9];\n\nmat2 rot(float angle)\n{\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\treturn mat2(c,-s,s,c);\n}\nvec3 rot (vec3 v, vec3 axis, vec2 sincosangle)\n{\n\treturn v*sincosangle.y + cross(axis, v)*sincosangle.x + axis*(dot(axis, v))*(1.0 - sincosangle.y);\n}\n\nfloat sdSphere (vec3 p, float s)\n{\n\treturn length(p)-s;\n}\n\n\n// rd doesn't have to be normalized\nfloat sphere(vec3 ro, vec3 rd, float r)\n{\n\tfloat b = dot(ro, rd);\n\tfloat c = dot(ro, ro) - r * r;\n\tfloat a = dot(rd, rd);\n\t// Exit if râ€™s origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif (c > 0.0 && b > 0.0)\n\t\treturn INF;\n\tfloat discr = b*b - a*c;\n\t// A negative discriminant corresponds to ray missing sphere\n\tif (discr < 0.0)\n\t\treturn INF;\n\t// Ray now found to intersect sphere, compute smallest t value of intersection\n\tfloat t = - b - sqrt(discr);\n\tt /= a;\n\t// If t is negative, ray started inside sphere so clamp t to zero\n\tt = max(0.0, t);\n\treturn t;\n}\n\n\n\nfloat hash (float n)\n{\n\treturn fract(sin(n)*43758.5453);\n}\n\nfloat noise (in vec3 x)\n{\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\n\tf = f*f*(3.0-2.0*f);\n\n\tfloat n = p.x + p.y*57.0 + 113.0*p.z;\n\n\tfloat res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n\t\t\t\t\t\tmix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n\t\t\t\t\tmix(mix( hash(n+113.0), hash(n+114.0),f.x),\n\t\t\t\t\t\tmix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n\treturn res;\n}\n\nfloat box(vec3 org, vec3 dir, vec3 size, out float far)\n{\n\t// compute intersection of ray with all six bbox planes\n\tvec3 invR = 1.0 / dir;\n\tvec3 tbot = invR * (-0.5*size - org);\n\tvec3 ttop = invR * (0.5*size - org);\n\t\n\t// re-order intersections to find smallest and largest on each axis\n\tvec3 tmin = min (ttop, tbot);\n\tvec3 tmax = max (ttop, tbot);\n\t\n\t// find the largest tmin and the smallest tmax\n\tvec2 t0 = max (tmin.xx, tmin.yz);\n\tfloat near;\n\tnear = max (t0.x, t0.y);\n\tt0 = min (tmax.xx, tmax.yz);\n\tfar = min (t0.x, t0.y);\n\n\t// check for hit\n\treturn near < far && far > 0.0 ? near : INF;\n}\n\n\n// frustum inscribed in a unit cube centered at 0\n#define INF 1.0e38\nfloat frustum(vec3 org, vec3 dir, float apex, vec3 size, out float far)\n{\n\tvec2 dirf = vec2(0.5 - apex, 0.5); \n\tvec3 tbot, ttop;\n\t\n\t// intersection with near and far planes\n\tfloat invdirx = 1.0 / dir.x;\n\ttbot.x = invdirx * (-0.5*size.x - org.x);\n\tttop.x = invdirx * (0.5*size.x - org.x);\n\n\tfloat temp = dirf.y * (org.x-apex);\n\t\n\t// intersection with inclined planes on y\n\ttbot.y = size.y * (-temp - dirf.x * org.y) / (dirf.x * dir.y + dirf.y * dir.x);\n\tttop.y = size.y * ( temp - dirf.x * org.y) / (dirf.x * dir.y - dirf.y * dir.x);\n\t\n\t// intersection with inclined planes on z\n\ttbot.z = size.z * (-temp - dirf.x * org.z) / (dirf.x * dir.z + dirf.y * dir.x);\n\tttop.z = size.z * ( temp - dirf.x * org.z) / (dirf.x * dir.z - dirf.y * dir.x);\n\t\n\t// if intersecting behind the apex, set t to ray's end\n\tvec4 tempt = vec4(tbot.yz, ttop.yz);\n\ttempt = mix(tempt, INF * sign(dir.xxxx), step(org.xxxx + tempt * dir.xxxx, vec4(apex)));\n\ttbot.yz = tempt.xy;\n\tttop.yz = tempt.zw;\n\n\t// re-order intersections to find smallest and largest on each axis\n\tvec3 tmin = min(ttop, tbot);\n\tvec3 tmax = max(ttop, tbot);\n\t\n\t// find the largest tmin and the smallest tmax\n\tvec2 t0 = max(tmin.xx, tmin.yz);\n\tfloat near = max(t0.x, t0.y);\n\tt0 = min(tmax.xx, tmax.yz);\n\tfar = min(t0.x, t0.y);\n\n\t// check for hit\n\treturn near < far && far > 0.0 ? near : INF;\n}\n\nfloat box(vec3 org, vec3 dir, vec3 size)\n{\n\tfloat far;\n\treturn box(org, dir, size, far);\n}\n\n\n\n// Makes brighter near top\nfloat transmittance (vec3 p)\n{\n    /*vec3 o;\n    o.x = sin( iTime ) * .1;\n    o.y = sin( iTime * .5) * 2.1;\n    o.z = sin( iTime * .05) * 20.1;\n\treturn noise( p * o);*/\n    \n    float a = 0.;\n    float mL = 100.;\n    float id = 0.;\n    for( int i = 0; i < 10; i++ ){\n     \n        vec3 dif = spherePos[i].xyz - p;\n        \n       // float n = noise(dif * 5.);\n        float l = length( dif ) - (spherePos[i].w*.9) ;\n        a +=  .2  / (l);\n        \n        if( l < mL ){mL = l; id = float( i );}\n        \n    }\n    \n   \n    a = pow(a,2.) / 20. + 3. * pow(fogmap( p * 1.  + sin(iTime*.1 )* .1 + sin(iTime*.174 )* .2 , clamp( a , 0. , 1.1)*1.3+.5  ),3.);\n    \n    return a;\n    \n}\n\nfloat intersect (vec3 ro, vec3 rd)\n{\n\tfloat hit = INF;\n\n    for( int i = 0; i < 10; i++ ){\n        vec4 r = spherePos[i];\n\t\tHIT(sphere(ro - r.xyz, rd,r.w));\n    }\n    \n    for( int i = 0; i < 10; i++ ){\n        vec4 r = roofPos[i];\n\t\tHIT(box (ro - r.xyz, rd, vec3(r.w ,.01,r.w)));\n    }\n\n\n\tHIT(box (ro - vec3(0.,-4.,0.), rd, vec3(10.,.01,10.)));\n    /*HIT(box (ro - vec3(0.,-.9,0.), rd, vec3(2.,.05,2.)));\n    HIT(box (ro - vec3(0.,-.6,0.), rd, vec3(1.,.05,1.)));\n    HIT(box (ro - vec3(0.,-.4,0.), rd, vec3(.5,.05,.5)));\n    HIT(box (ro - vec3(0.,0.,0.), rd, vec3(.3,.3,.3)));*/\n    \n    float s = 5.;\n    HIT(box (ro - vec3(s,0.,0.), rd, vec3(.01,2.*s,2.*s)));\n    HIT(box (ro - vec3(-s,0.,0.), rd, vec3(.01,2.*s,2.*s)));\n    HIT(box (ro - vec3(0.,0.,s), rd, vec3(2.*s,2.*s,.01)));\n    HIT(box (ro - vec3(0.,0.,-s), rd, vec3(2.*s,2.*s,.01)));\n    \n \n\n\n\treturn hit;\n}\n\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal(mat3 camMat , vec2 p, vec3 ro  ){\n    \n    // create view ray\n    vec2 eps = vec2( 0.0001, 0.0 );\n    \n\tvec3 l = normalize( camMat * vec3(p.xy - eps.xy,2.0) ); \n    vec3 r = normalize( camMat * vec3(p.xy + eps.xy,2.0) ); \n    vec3 u = normalize( camMat * vec3(p.xy - eps.yx,2.0) ); \n    vec3 d = normalize( camMat * vec3(p.xy + eps.yx,2.0) ); \n    \n    // raycast the scene\n\tfloat hL = intersect(ro,l);\n\tvec3 pL = ro + hL * l;\n    if( hL == INF ){ return vec3( INF ); }\n        \n    \n     // raycast the scene\n\tfloat hR = intersect(ro,r);\n\tvec3 pR = ro + hR * r;\n    if( hR == INF ){ return vec3( INF ); }\n    \n    // raycast the scene\n\tfloat hU = intersect(ro,u);\n\tvec3 pU = ro + hU * u;\n    if( hU == INF ){ return vec3( INF ); }\n    \n    // raycast the scene\n\tfloat hD = intersect(ro,d);\n\tvec3 pD = ro + hD * d;\n    if( hD == INF ){ return vec3( INF ); }\n    \n    vec3 d1 = pL - pR;\n    vec3 d2 = pU - pD;\n        \n    vec3 nor =cross( d1 , d2 );\n\n\treturn normalize(nor);\n    \n}\n\n#define STEPS 40\nvec3 inscatter ( vec3 origin, vec3 ro, vec3 rd, vec3 roLight , vec3 rdLight, vec3 lightDir, float hit, vec2 screenPos)\n{\n\tfloat far;\n    //float near = frustum(roLight + vec3(0.0, 1.0, 0.0), rdLight,.01, vec3(1.5, 3.0, 1.5), far);\n\tfloat near = box(roLight + origin, rdLight, vec3(4., 30., 4.), far);\n\tif(near == INF || hit < near)\n\t\treturn vec3(0);\n\t\n\tfloat distAlongView = min(hit, far) - near;\n\tfloat oneOverSteps = 1.0/float(STEPS);\n\tvec3 step = rd*distAlongView*oneOverSteps;\n\tvec3 pos = ro + rd*near;\n\tfloat light = 0.0;\n\t\n\t// add noise to the start position to hide banding\n\tpos += rd*noise(vec3(2.0*screenPos, 0.0))*0.05;\n\n\tfor(int i = 0; i < STEPS; i++)\n\t{\n\t\tfloat l = intersect(pos, lightDir) == INF ? 1.0 : 0.0;\n\t\tl *= transmittance(pos);\n\t\tlight += l;\n        \n        //include light particles later ?\n\t\t//light += particles(pos)*l;\n\t\tpos += step;\n\t}\n\n\tlight *= oneOverSteps * distAlongView;\n\treturn light*lightColor;\n}\n\n\n\n\n\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 0.3 + 10.0*mouseX;\n\tcamPos = vec3(3.5*sin(an),1.0,3.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    for( int i =0; i < 10; i++ ){\n\n        float t = (float( i ) / 10. ) * 2. * PI;\n        \t\n        //float t = iTime;\n        float x = (2. +sin( iTime + t * 5. )) * cos( t );\n        float y = mod( iTime * (sin(float(i)*16.12)+2.) * .1 , 10. ) - 5.;//.5 + .1 *sin( iTime + t * 3. );\n        float z = (2. +sin( iTime + t * 5. ))  * sin( t );\n        \n        float r= .2 + .1 * sin( (float(i)+5.) * .01 * iTime);\n\n        //float x = 1. * sin( t *.01* float( i) + t * .9);\n        //float y = 3. * clamp( tan( time *.03* float( i) + time * .09),-4. , 4.  );\n        //float z = 1. * sin( t *.05* float( i) + t * .9);\n    \t\n        spherePos[i] = vec4( x ,  y ,  z , r );\n        \n        \n    }\n    \n    for( int i =0; i < 9; i++ ){\n  \n        float t = (float( i ) / 10. ) * 2. * PI;\n        \t\n        float m = mod( float(i) , 3.);\n        float x = (m - 1. ) *2.2;//(2. +sin( iTime + t * 5. )) * cos( t );\n        float y = 3.5;\n        float z = (floor(float(i)/3.) - 1. ) *2.2;\n        \n    \troofPos[i] = vec4( x ,  2., z , 1. );\n        \n        \n    }\n\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m.x );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n    \n    // raycast the scene\n\tfloat hit = intersect(ro,rd);\n\tvec3 hitPos = ro + hit * rd;\n\t\n    vec3 col = normalize( hitPos ) * .5 + .5; //vec3( 0. );\n    \n   \n\t// white window\n\tif (hit == INF)\n\t{\n\t\tcol = vec3( 1. , 0. , 0. );\n        \n\n    }else{\n        \n        vec3 n;\n        \n        n.x = noise( hitPos * 10. );\n        n.y = noise( hitPos * 20. );\n        n.z = noise( hitPos * 30. );\n        \n       // col = vec3( n );//.3 * (normalize( hitPos ) * .5 + .5);// vec3( .1 , 0.1 , 0.2 );\n    \tcol = vec3( 0. );\n    }\n     \n    \n    // white window\n\tif (hit == INF)\n\t{\n\t\tfragColor = vec4(0.0);\n\t\treturn;\n\t}\n    \n    vec3 n = calcNormal( camMat , p , ro );\n    \n    if( n == vec3(INF) ){\n        fragColor = vec4(1.0);\n\t\treturn;\n    }\n    \n    col = vec3( 0.);//vec3(dot( vec3( 0. , 1. , 0. ) , n ));\n    \n\n    /*vec3 roLight = vec3( 0. , 4. , 0. );\n    vec3 rdLight = vec3( 0. , -1. , 0. );\n    vec3 lightDir = normalize( rdLight );\n    \n    col += inscatter(ro, rd, roLight, rdLight, lightDir, hit, fragCoord.xy);*/\n    \n    // direct light (screw shading!)\n\tvec3 lightRotAxis = vec3(0.707,0,0.707); //1,0,1 normalized\n    \n    \n    float angle = .4;//  + .01 * sin(iTime);\n\tvec2 lightAngleSinCos = vec2(sin(angle), cos(angle));\n\tvec3 lightDir = rot(vec3(0,1,0), lightRotAxis, lightAngleSinCos);\n\tfloat shadowBias = 1.0e-4;\n\t//vec3 col = vec3(0.0);\n    if (intersect(hitPos + lightDir*shadowBias, lightDir) == INF){\n        \n        vec4 t = texCube(iChannel0, hitPos,  n,10. );\n\n        col = t.xyz * vec3(dot( lightDir , n ));\n    \n\t\t//col = normalize( hitPos ) * .5 + .5;\n        //col = lightColor;\n    }\n\t\n\t// inscatter\n\tlightAngleSinCos.x *= -1.0; // rev angle\n\tvec3 roLight = rot(ro + ROOFPOS, lightRotAxis, lightAngleSinCos);\n\tvec3 rdLight = rot(rd, lightRotAxis, lightAngleSinCos);\n    \n    // The 5 lights\n\tcol += inscatter(vec3( 0. , 1. , 0.),ro, rd, roLight, rdLight, lightDir, hit, fragCoord.xy);    \n\n    vec3 c = col;\n    // color correction - Sherlock color palette ;)\n\tc.r = smoothstep(0.0, 1.0, c.r * 1.5);\n\tc.g = smoothstep(0.0, 1.0, c.g - 0.0);\n\tc.b = smoothstep(-0.2, 1.3, c.b);\n    \n \tfragColor = vec4( c , 1. );   \n    \n    \n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lllGzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[361, 361, 426, 426, 610], [614, 666, 688, 688, 713], [714, 714, 735, 735, 815], [898, 950, 993, 993, 1295], [1297, 1349, 1385, 1440, 1486], [1828, 1828, 1851, 1851, 1923], [1924, 1924, 1972, 1972, 2074], [2076, 2076, 2110, 2110, 2133], [2136, 2172, 2213, 2213, 2752], [2756, 2756, 2778, 2778, 2814], [2816, 2816, 2841, 2841, 3177], [3179, 3179, 3236, 3293, 3773], [3845, 3845, 3918, 3918, 5177], [5179, 5179, 5221, 5221, 5269], [5273, 5300, 5330, 5468, 5979], [5981, 5981, 6017, 6017, 6849], [6852, 6965, 7014, 7042, 7962], [7981, 7981, 8101, 8101, 8913], [8920, 8951, 9015, 9015, 9193], [9195, 9195, 9278, 9278, 9391]], "test": "error"}
{"id": "lls3RX", "name": "smin test", "author": "hughsk", "description": "Trying out smin: http://www.iquilezles.org/www/articles/smin/smin.htm", "tags": ["smin"], "likes": 5, "viewed": 205, "published": "Public", "date": "1423971898", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//------------------------------------------------------------------------\n// Camera\n//\n// Move the camera. In this case it's using time and the mouse position\n// to orbitate the camera around the origin of the world (0,0,0), where\n// the yellow sphere is.\n//------------------------------------------------------------------------\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 0.3*iTime + 10.0*mouseX;\n\tcamPos = vec3(3.5*sin(an),1.0,3.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n\n//------------------------------------------------------------------------\n// Background \n//\n// The background color. In this case it's just a black color.\n//------------------------------------------------------------------------\nvec3 doBackground( void )\n{\n    return vec3(0.9);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n    \n//------------------------------------------------------------------------\n// Modelling \n//\n// Defines the shapes (a sphere in this case) through a distance field, in\n// this case it's a sphere of radius 1.\n//------------------------------------------------------------------------\nfloat doModel( vec3 p )\n{\n    float sep = 0.4;\n    float rad = 0.1;\n    float d = 100000.0;\n    float t = iTime;\n    \n    for (float i = .0; i < 40.; i++) {\n    \tfloat I = i;\n        float T = sin(t + I);\n        vec3 pos = vec3(sin(I + T), cos(I + T), 0.0);\n        float r = sin(I + T) +1.0;\n        d = smin(d, length(p + pos) - rad * r, 0.2);\n    }\n    \n    return d;\n}\n\n//------------------------------------------------------------------------\n// Material \n//\n// Defines the material (colors, shading, pattern, texturing) of the model\n// at every point based on its position and normal. In this case, it simply\n// returns a constant yellow color.\n//------------------------------------------------------------------------\nvec3 doMaterial( in vec3 pos, in vec3 nor )\n{\n    return vec3(0.05, 0.05, 0.1);\n}\n\n//------------------------------------------------------------------------\n// Lighting\n//------------------------------------------------------------------------\nfloat calcSoftshadow( in vec3 ro, in vec3 rd );\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec3 mal )\n{\n    vec3 lin = vec3(0.0);\n\n    // key light\n    //-----------------------------\n    vec3  lig = normalize(vec3(1.0,0.7,0.9));\n    float dif = max(dot(nor,lig),0.0);\n    float sha = 0.0; if( dif>0.01 ) sha=calcSoftshadow( pos+0.01*nor, lig );\n    lin += dif*vec3(4.00,4.00,4.00)*sha;\n\n    // ambient light\n    //-----------------------------\n    lin += vec3(0.50,0.50,0.50);\n\n    \n    // surface-light interacion\n    //-----------------------------\n    vec3 col = mal*lin;\n\n    \n    // fog    \n    //-----------------------------\n\tcol *= exp(-0.01*dis*dis);\n\n    return col;\n}\n\nfloat calcIntersection( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 20.0;           // max trace distance\n\tconst float precis = 0.001;        // precission of the intersection\n    float h = precis*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for( int i=0; i<90; i++ )          // max number of raymarching iterations is 90\n    {\n        if( h<precis||t>maxd ) break;\n\t    h = doModel( ro+rd*t );\n        t += h;\n    }\n\n    if( t<maxd ) res = t;\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.002;             // precision of the normal computation\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( pos + v1*eps ) + \n\t\t\t\t\t  v2*doModel( pos + v2*eps ) + \n\t\t\t\t\t  v3*doModel( pos + v3*eps ) + \n\t\t\t\t\t  v4*doModel( pos + v4*eps ) );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.0005;                 // selfintersection avoidance distance\n\tfloat h = 1.0;\n    for( int i=0; i<5; i++ )         // 40 is the max numnber of raymarching steps\n    {\n        h = doModel(ro + rd*t);\n        res = min( res, 64.0*h/t );   // 64 is the hardness of the shadows\n\t\tt += clamp( h, 0.02, 2.0 );   // limit the max and min stepping distances\n    }\n    return clamp(res,0.0,1.0);\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m.x );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = doBackground();\n\n\t// raymarch\n    float t = calcIntersection( ro, rd );\n    if( t>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\n        // materials\n        vec3 mal = doMaterial( pos, nor );\n\n        col = doLighting( pos, nor, rd, t, mal );\n\t}\n\n\t//-----------------------------------------------------\n\t// postprocessing\n    //-----------------------------------------------------\n    // gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n\t   \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lls3RX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 332, 415, 415, 534], [537, 768, 795, 795, 819], [821, 821, 862, 862, 955], [961, 1243, 1268, 1268, 1616], [1618, 1971, 2016, 2016, 2052], [2265, 2265, 2349, 2349, 2925], [2927, 2927, 2977, 2977, 3394], [3396, 3396, 3428, 3428, 3840], [3842, 3842, 3890, 3890, 4315], [4317, 4317, 4381, 4381, 4559], [4561, 4561, 4618, 4618, 5822]], "test": "valid"}
{"id": "lls3zf", "name": "Flowing water", "author": "guil", "description": "Water effect", "tags": ["2d", "noise", "water"], "likes": 27, "viewed": 1153, "published": "Public", "date": "1424133865", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by S.Guillitte \n\n\nfloat hash( in vec2 p ) \n{\n    return fract(sin(p.x*15.32+p.y*35.78) * 43758.23);\n}\n\nvec2 hash2(vec2 p)\n{\n\treturn vec2(hash(p*.754),hash(1.5743*p.yx+4.5891))-.5;\n}\n\n\nvec2 add = vec2(1.0, 0.0);\n\nvec2 noise2(vec2 x)\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    vec2 res = mix(mix( hash2(p),          hash2(p + add.xy),f.x),\n                    mix( hash2(p + add.yx), hash2(p + add.xx),f.x),f.y);\n    return res;\n}\n\nvec2 noise2b( in vec2 p )// Simplex Noise from IQ\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\tp /=2.;\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 nx = h*h*h*h*vec3( dot(a,hash2(i+0.0)), dot(b,hash2(i+o)), dot(c,hash2(i+1.0)));\n    vec3 ny = h*h*h*h*vec3( dot(a,hash2(i+4.5)), dot(b,hash2(i+o+4.5)), dot(c,hash2(i+1.0+4.5)));\n\n    return vec2(dot( nx, vec3(70.0) ),dot( ny, vec3(70.0) ));\n\t\n}\n\n\nmat2 m2;\n\nvec2 fbm2(vec2 x)\n{\n    vec2 r = vec2(0.0);\n    float a = 1.;\n    \n    for (int i = 0; i < 6; i++)\n    {\n        r += m2*noise2b(x+r)*a; \n        x +=.3*r+.4;\n    }     \n    return r;\n}\n\n\nvec2 water(vec2 x)\n{\n    x=fbm2(x);\n    x=abs(x)/dot(x,x)-1.;\n    return abs(x)/dot(x,x)-1.;\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.*fragCoord.xy / iResolution.yy;\n    uv*=10.;\n    float t = 1.5*iTime;\n    float st = sin(t), ct = cos(t);\n    m2 = mat2(ct,st,-st,ct);\n    vec2 p = water(uv+2.*iTime)+2.;\n    float c = length(p)/7.;\n    c=clamp(pow(c,3.),0.,1.);\n    vec3 col=texture(iChannel0,uv/20.+p/45.).rgb;    \n    col=mix(col,vec3(.7,.7,.9),c);\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lls3zf.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[116, 116, 142, 142, 199], [201, 201, 221, 221, 279], [310, 310, 331, 331, 565], [567, 567, 618, 618, 1292], [1305, 1305, 1324, 1324, 1490], [1493, 1493, 1513, 1513, 1587], [1593, 1593, 1650, 1650, 2011]], "test": "error"}
{"id": "llsGDB", "name": "Blackbody Radiation", "author": "Razaekel", "description": "Blackbody Radiation spectra, broken into RGB components.\n\nThis is also at a constant brightness, and doesn't take into account the shifting of blackbody radiation into the infrared or UV regions at the lower or upper temperature ranges.", "tags": ["2d", "blackbody"], "likes": 6, "viewed": 532, "published": "Public", "date": "1424992381", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Blackbody Color Shader\n\n// Written By: Nicholas Whitney\n\n// Modification: Used alternate equations for color. Seems to be more accurate.\n\n// Licensed and released under Creative Commons 3.0 Attribution\n// https://creativecommons.org/licenses/by/3.0/\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nfloat timeFactor = 30.;\n\n// Temperature range in Kelvins from minTemp to maxTemp. \n// The equations are fitted to a minimum of 1,500 K and a maximum temp of 15,000K.\n\n// Minimum temperature to represent.\nfloat minTemp = 1500.;\n\n// Maximum temperature to represent.\nfloat maxTemp = 15000.;\n\nfloat calcRed(float temp) {\n\t\n\tfloat red; \n\t\n\tif ( temp <= 6600. ) {\n\t\t\n\t\tred = 1.;\n\t}\n\telse {\n\t\ttemp = temp - 6000.;\n\t\t\n\t\ttemp = temp / 100.;\n\t\t\n\t\tred = 1.29293618606274509804 * pow(temp, -0.1332047592);\n\t\t\n\t\tif (red < 0.) {\n\t\t\tred = 0.;\n\t\t}\n\t\telse if (red > 1.) {\n\t\t\tred = 1.;\n\t\t}\n\t}\n\t\n\treturn red;\n}\n\nfloat calcGreen(float temp) {\n\t\n\tfloat green; \n\t\n\tif ( temp <= 6600. ) {\n\t\ttemp = temp / 100.;\n\t\t\n\t\tgreen = 0.39008157876901960784 * log(temp) - 0.63184144378862745098;\n\t\t\n\t\tif (green < 0.) {\n\t\t\tgreen = 0.;\n\t\t}\n\t\telse if (green > 1.) {\n\t\t\tgreen = 1.;\n\t\t}\n\t}\n\telse {\n\t\ttemp = temp - 6000.;\n\t\t\n\t\ttemp = temp / 100.;\n\t\n\t\tgreen = 1.12989086089529411765 * pow(temp, -0.0755148492);\n\t\t\n\t\tif (green < 0.) {\n\t\t\tgreen = 0.;\n\t\t}\n\t\telse if (green > 1.) {\n\t\t\tgreen = 1.;\n\t\t}\n\t}\n\t\n\treturn green;\n}\n\nfloat calcBlue(float temp) {\n\t\n\tfloat blue;\n\t\n\tif ( temp <= 1900. ) {\n\t\tblue = 0.;\n\t}\n\telse if ( temp >= 6600.) {\n\t\tblue = 1.;\n\t}\n\telse {\t\n\t\ttemp = temp / 100.;\n\t\t\n\t\tblue = .00590528345530083 * pow(temp, 1.349167257362226); // R^2 of power curve fit: 0.9996\n\t\tblue = 0.54320678911019607843 * log(temp - 10.0) - 1.19625408914;\n\t\t\n\t\tif (blue < 0.) {\n\t\t\tblue = 0.;\n\t\t}\n\t\telse if (blue > 1.) {\n\t\t\tblue = 1.;\n\t\t}\n\t}\n\t\n\treturn blue;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 position = ( fragCoord.xy / iResolution.xy );\n\t\n\tfloat temp = minTemp + position.x * (maxTemp - minTemp);\n\t\n\tvec3 color = vec3(0.);\n\t\n\tif (position.y > .85) {\n\t\tcolor = vec3( calcRed(temp), 0., 0.);\n\t}\n\telse if (position.y > .7) {\n\t\tcolor = vec3( 0., calcGreen(temp), 0.);\n\t}\n\telse if (position.y > .55) {\n\t\tcolor = vec3( 0., 0., calcBlue(temp));\n\t}\n\telse if (position.y > .3) {\n\t\tcolor = vec3(calcRed(temp), calcGreen(temp), calcBlue(temp));\n\t}\n\telse {\n\t\tfloat calcTemp = mod(( iTime / timeFactor), 1.);\n\t\ttemp = minTemp + calcTemp * maxTemp;\n\t\t\n\t\tcolor = vec3(calcRed(temp), calcGreen(temp), calcBlue(temp));\n\t}\n\t\n\tvec3 lineColor = vec3(0.);\n\t\n\tif ((position.x > mod((iTime / timeFactor), 1.)) \n        && (position.x < mod((iTime / timeFactor) + (2. / iResolution.x), 1.))) \n    {\t\n\t\tlineColor = vec3(1.);\n\t}\n\t\n\tif (position.y > 0.3){\n\t\tcolor += lineColor;\n\t}\n\t\n\tfragColor = vec4( color , 1.0 );\n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llsGDB.jpg", "access": "shaders20k", "license": "cc-by-3.0", "functions": [[590, 590, 617, 617, 892], [894, 894, 923, 923, 1378], [1380, 1380, 1408, 1408, 1808], [1810, 1810, 1867, 1867, 2777]], "test": "valid"}
{"id": "llX3DS", "name": "Daily: 24/2/15", "author": "hughsk", "description": "More experimenting", "tags": ["rays", "blob"], "likes": 9, "viewed": 210, "published": "Public", "date": "1424737849", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592653589793\n\nfloat blinnPhongSpecular(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float shininess) {\n\n  //Calculate Blinn-Phong power\n  vec3 H = normalize(viewDirection + lightDirection);\n  return pow(max(0.0, dot(surfaceNormal, H)), shininess);\n}\n\nfloat fogFactorExp2(\n  const float dist,\n  const float density\n) {\n  const float LOG2 = -1.442695;\n  float d = density * dist;\n  return 1.0 - clamp(exp2(d * d * LOG2), 0.0, 1.0);\n}\n\nfloat orenNayarDiffuse(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float roughness,\n  float albedo) {\n  \n  float LdotV = dot(lightDirection, viewDirection);\n  float NdotL = dot(lightDirection, surfaceNormal);\n  float NdotV = dot(surfaceNormal, viewDirection);\n\n  float s = LdotV - NdotL * NdotV;\n  float t = mix(1.0, max(NdotL, NdotV), step(0.0, s));\n\n  float sigma2 = roughness * roughness;\n  float A = 1.0 + sigma2 * (albedo / (sigma2 + 0.13) + 0.5 / (sigma2 + 0.33));\n  float B = 0.45 * sigma2 / (sigma2 + 0.09);\n\n  return albedo * max(0.0, NdotL) * (A + B * s / t) / PI;\n}\n\nfloat backOut(float t) {\n  float f = t < 0.5 ? 2.0 * t : 1.0 - (2.0 * t - 1.0);\n  float g = pow(f, 3.0) - f * sin(f * PI);\n  return t < 0.5 ? 0.5 * g : 0.5 * (1.0 - g) + 0.5;\n}\n\nvec4 a_x_mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nfloat a_x_mod289(float x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 a_x_permute(vec4 x) {\n  return a_x_mod289(((x * 34.0) + 1.0) * x);\n}\nfloat a_x_permute(float x) {\n  return a_x_mod289(((x * 34.0) + 1.0) * x);\n}\nvec4 a_x_taylorInvSqrt(vec4 r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\nfloat a_x_taylorInvSqrt(float r) {\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\nvec4 a_x_grad4(float j, vec4 ip) {\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p, s;\n  p.xyz = floor(fract(vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz * 2.0 - 1.0) * s.www;\n  return p;\n}\n#define F4 0.309016994374947451\n\nfloat snoise(vec4 v) {\n  const vec4 C = vec4(0.138196601125011, 0.276393202250021, 0.414589803375032, -0.447213595499958);\n  vec4 i = floor(v + dot(v, vec4(F4)));\n  vec4 x0 = v - i + dot(i, C.xxxx);\n  vec4 i0;\n  vec3 isX = step(x0.yzw, x0.xxx);\n  vec3 isYZ = step(x0.zww, x0.yyz);\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n  vec4 i3 = clamp(i0, 0.0, 1.0);\n  vec4 i2 = clamp(i0 - 1.0, 0.0, 1.0);\n  vec4 i1 = clamp(i0 - 2.0, 0.0, 1.0);\n  vec4 x1 = x0 - i1 + C.xxxx;\n  vec4 x2 = x0 - i2 + C.yyyy;\n  vec4 x3 = x0 - i3 + C.zzzz;\n  vec4 x4 = x0 + C.wwww;\n  i = a_x_mod289(i);\n  float j0 = a_x_permute(a_x_permute(a_x_permute(a_x_permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = a_x_permute(a_x_permute(a_x_permute(a_x_permute(i.w + vec4(i1.w, i2.w, i3.w, 1.0)) + i.z + vec4(i1.z, i2.z, i3.z, 1.0)) + i.y + vec4(i1.y, i2.y, i3.y, 1.0)) + i.x + vec4(i1.x, i2.x, i3.x, 1.0));\n  vec4 ip = vec4(1.0 / 294.0, 1.0 / 49.0, 1.0 / 7.0, 0.0);\n  vec4 p0 = a_x_grad4(j0, ip);\n  vec4 p1 = a_x_grad4(j1.x, ip);\n  vec4 p2 = a_x_grad4(j1.y, ip);\n  vec4 p3 = a_x_grad4(j1.z, ip);\n  vec4 p4 = a_x_grad4(j1.w, ip);\n  vec4 norm = a_x_taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= a_x_taylorInvSqrt(dot(p4, p4));\n  vec3 m0 = max(0.6 - vec3(dot(x0, x0), dot(x1, x1), dot(x2, x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3, x3), dot(x4, x4)), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * (dot(m0 * m0, vec3(dot(p0, x0), dot(p1, x1), dot(p2, x2))) + dot(m1 * m1, vec2(dot(p3, x3), dot(p4, x4))));\n}\n\n//------------------------------------------------------------------------\n// Camera\n//\n// Move the camera. In this case it's using time and the mouse position\n// to orbitate the camera around the origin of the world (0,0,0), where\n// the yellow sphere is.\n//------------------------------------------------------------------------\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in vec2 mouse )\n{\n    float an = 10.0*mouse.x;\n\tcamPos = vec3(3.5*sin(an),10.0*(mouse.y-0.2),3.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n\n//------------------------------------------------------------------------\n// Background \n//\n// The background color. In this case it's just a black color.\n//------------------------------------------------------------------------\nvec3 doBackground( void )\n{\n    return vec3(0.001);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n    \n//------------------------------------------------------------------------\n// Modelling \n//\n// Defines the shapes (a sphere in this case) through a distance field, in\n// this case it's a sphere of radius 1.\n//------------------------------------------------------------------------\nfloat doModel( vec3 p )\n{\n    vec3  sep = vec3(sin(iTime * 0.75 + p.x * 0.05), 0, 0);\n    float rad = 0.5;\n    float d = 100000.0;\n    float t = iTime * 2.0;\n    float swell = 1.0; //(1.0 + snoise(vec4(p * 3.0, iTime)) * 0.06125);\n    float blend = 0.6;\n    \n    sep.x = backOut(0.5 * (sep.x + 1.0)) * 1.5 - 0.25;\n\n    d = smin(d, length(p) - rad * swell, blend);\n    \n    for (int i = 0; i < 4; i++) {\n        float I = float(i);\n   \t\tvec3 off = vec3(sin(I + t), cos(I + t), sin(I - t));\n        \n        d = smin(d, length(p + off) - rad * 0.5, blend);\n        \n        for (int j = 0; j < 6; j++) {\n            float J = float(j);\n            float T = t * 0.5;\n            vec3 off2 = vec3(cos(J + T), sin(J + T), cos(J - T));\n\n            d = smin(d, length(p + off + off2), blend);\n        }\n    }\n    \n    return d;\n}\n\n//------------------------------------------------------------------------\n// Material \n//\n// Defines the material (colors, shading, pattern, texturing) of the model\n// at every point based on its position and normal. In this case, it simply\n// returns a constant yellow color.\n//------------------------------------------------------------------------\nvec3 doMaterial( in vec3 pos, in vec3 nor )\n{\n    return vec3(0.15, 0.1, 0.05);\n}\n\n//------------------------------------------------------------------------\n// Lighting\n//------------------------------------------------------------------------\nfloat calcSoftshadow( in vec3 ro, in vec3 rd );\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec3 mal )\n{\n    vec3 lin = vec3(0.0);\n\n    // key light\n    //-----------------------------\n    vec3  lig1 = normalize(vec3(0.5, 2.5, 2.0));\n    vec3  lig2 = normalize(vec3(-1.5, -5.5, -2.0));\n    float dif1 = orenNayarDiffuse(lig1, normalize(rd), nor, 0.5, 1.0);\n    float dif2 = orenNayarDiffuse(lig2, normalize(rd), nor, 0.5, 1.0);\n    float spc1 = blinnPhongSpecular(lig1, normalize(rd), nor, 0.5);\n    float spc2 = blinnPhongSpecular(lig2, normalize(rd), nor, 0.5);\n    float sha1 = 0.0; if( dif1>0.01 ) sha1=max(0.0, calcSoftshadow( pos+0.01*nor, lig1 ));\n    float sha2 = 0.0; if( dif2>0.01 ) sha2=max(0.0, calcSoftshadow( pos+0.01*nor, lig2 ));\n    \n    vec3 mal2 = vec3(0.001, 0.015, 0.04);\n    \n    lin += mal*dif1*vec3(4.00,4.00,4.00)*sha1;\n    lin += mal2*dif2*vec3(4.00,4.00,4.00)*sha2;\n    lin += mal*spc1*vec3(1.0, 1.5, 2.5)*sha1;\n    lin += mal2*spc2*vec3(1.0, 1.5, 2.5)*sha2;\n    //lin += vec3(0.02);\n\n    \n    // surface-light interacion\n    //-----------------------------\n    vec3 col = lin;\n    //vec3 col = mal * (length(lin) > 0.95 ? 3.0 : 0.2);\n\n    return col;\n}\n\nfloat calcIntersection( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 20.0;           // max trace distance\n\tconst float precis = 0.001;        // precission of the intersection\n    float h = precis*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for( int i=0; i<90; i++ )          // max number of raymarching iterations is 90\n    {\n        if( h<precis||t>maxd ) break;\n\t    h = doModel( ro+rd*t );\n        t += h;\n    }\n\n    if( t<maxd ) res = t;\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.002;             // precision of the normal computation\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( pos + v1*eps ) + \n\t\t\t\t\t  v2*doModel( pos + v2*eps ) + \n\t\t\t\t\t  v3*doModel( pos + v3*eps ) + \n\t\t\t\t\t  v4*doModel( pos + v4*eps ) );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.0005;                 // selfintersection avoidance distance\n\tfloat h = 1.0;\n    for( int i=0; i<5; i++ )         // 40 is the max numnber of raymarching steps\n    {\n        h = doModel(ro + rd*t);\n        res = min( res, 64.0*h/t );   // 64 is the hardness of the shadows\n\t\tt += clamp( h, 0.02, 2.0 );   // limit the max and min stepping distances\n    }\n    return clamp(res,0.0,1.0);\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m.xy );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = doBackground();\n\n\t// raymarch\n    float t = calcIntersection( ro, rd );\n    if( t>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\n        // materials\n        vec3 mal = doMaterial( pos, nor );\n\n        col = mix(doLighting( pos, nor, rd, t, mal ), col, fogFactorExp2(t, 0.15));\n    }\n\n\t//-----------------------------------------------------\n\t// postprocessing\n    //-----------------------------------------------------\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n    col.r = mix(pow(col.r, 1.2), pow(col.r, 0.2), col.r);\n    col.b = mix(pow(col.b + 0.75, 0.5) - 0.75, pow(col.b, 1.15), col.b);\n    col = mix(col, col * 3.0 * vec3(1.5, 1, 1.1), dot(p, p * 0.1));\n\t   \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llX3DS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 143, 176, 290], [292, 292, 358, 358, 472], [474, 474, 601, 601, 1076], [1078, 1078, 1102, 1102, 1254], [1256, 1256, 1281, 1281, 1330], [1331, 1331, 1358, 1358, 1407], [1408, 1408, 1434, 1434, 1481], [1482, 1482, 1510, 1510, 1557], [1558, 1558, 1590, 1590, 1642], [1643, 1643, 1677, 1677, 1729], [1730, 1730, 1764, 1764, 2023], [2057, 2057, 2079, 2079, 3736], [3738, 4070, 4151, 4151, 4274], [4277, 4508, 4535, 4535, 4561], [4563, 4563, 4604, 4604, 4697], [4703, 4985, 5010, 5010, 5809], [5811, 6164, 6209, 6209, 6245], [6458, 6458, 6542, 6542, 7618], [7620, 7620, 7670, 7670, 8087], [8089, 8089, 8121, 8121, 8533], [8535, 8535, 8583, 8583, 9008], [9010, 9010, 9074, 9074, 9252], [9254, 9254, 9311, 9311, 10739]], "test": "valid"}
{"id": "llX3RS", "name": "alien (Ñ‡ÑƒÐ¶Ð¾Ð¹)", "author": "Lio", "description": "inspired https://www.shadertoy.com/view/MtfGWN\nFull screen will give a full impression...", "tags": ["2d"], "likes": 4, "viewed": 209, "published": "Public", "date": "1422855425", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time  iTime\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float k=2.;\nvec3 color = vec3(0.11, 1., 0.);\nvec2 pos = (fragCoord.xy/iResolution.xy) - .5; \nvec3 d = vec3(pos, 0.0);\n    \n //----------------------------------\n    float t = 2.34;//time;\n   vec2 sc = vec2(sin(t), cos(t));\n   mat3 rotate;\n   rotate = mat3( sc.y,  0.0, -sc.x,\n                     0.0,   1.0,  0.0,\n                     sc.x,  0.0, sc.y);   \n    \n   d = d *  rotate;\n  vec3 o = d, c=color *k*d, p;  \n //----------------------------------\n    for( int i=0; i< 9; i++ )\n    {\n        p = o + cos(time * 0.1);\n      for (int j = 0; j < 9; j++) \n      {\n          p.y += 0.02/ float(j + 1) * sin(float(j + 1) * p.x + (time * 20.0)/20. + 0.3 * float(j + 10)) - 18. + 15. ;\n\n          p = abs(p);\n          k += exp(-8. * abs(dot(p,o)));\n      }\n     \n      k/=3.;\n        o += d * 0.5 /k;\n        c = 1.1 * c + .1 * k *vec3(k*k,k,sin(time));\n    }\n    c =  .4 *log(1.+c);\n    fragColor.rgb = c;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llX3RS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 77, 77, 989]], "test": "valid"}
{"id": "llX3z2", "name": "Water 2D", "author": "Eddh", "description": "What's with all the 3D things?? I'll show you 2D!!! It's not because I'm jelly of all the raymarching people at all!!", "tags": ["procedural", "perlinnoise", "water"], "likes": 9, "viewed": 626, "published": "Public", "date": "1423321426", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nfloat fade(float t) {\n  // return t*t*(3.0-2.0*t); // Old fade, yields discontinuous second derivative\n  return t*t*t*(t*(t*6.0-15.0)+10.0); // Improved fade, yields C2-continuous noise\n}\nvec3 mod289(vec3 x)\n{\nreturn x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 mod289(vec4 x)\n{\nreturn x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n vec4 permute(vec4 x)\n{\nreturn mod289(((x*34.0)+1.0)*x);\n}\nvec4 taylorInvSqrt(vec4 r)\n{\nreturn 1.79284291400159 - 0.85373472095314 * r;\n}\nvec3 fade(vec3 t) {\nreturn t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise implementation found on https://github.com/ashima/webgl-noise\n//license :\n/*Copyright (C) 2011 by Ashima Arts (Simplex noise)\nCopyright (C) 2011 by Stefan Gustavson (Classic noise)\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.*/\nfloat cnoise(vec3 P)\n{\nvec3 Pi0 = floor(P); // Integer part for indexing\nvec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\nPi0 = mod289(Pi0);\nPi1 = mod289(Pi1);\nvec3 Pf0 = fract(P); // Fractional part for interpolation\nvec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\nvec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\nvec4 iy = vec4(Pi0.yy, Pi1.yy);\nvec4 iz0 = Pi0.zzzz;\nvec4 iz1 = Pi1.zzzz;\nvec4 ixy = permute(permute(ix) + iy);\nvec4 ixy0 = permute(ixy + iz0);\nvec4 ixy1 = permute(ixy + iz1);\nvec4 gx0 = ixy0 * (1.0 / 7.0);\nvec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\ngx0 = fract(gx0);\nvec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\nvec4 sz0 = step(gz0, vec4(0.0));\ngx0 -= sz0 * (step(0.0, gx0) - 0.5);\ngy0 -= sz0 * (step(0.0, gy0) - 0.5);\nvec4 gx1 = ixy1 * (1.0 / 7.0);\nvec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\ngx1 = fract(gx1);\nvec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\nvec4 sz1 = step(gz1, vec4(0.0));\ngx1 -= sz1 * (step(0.0, gx1) - 0.5);\ngy1 -= sz1 * (step(0.0, gy1) - 0.5);\nvec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\nvec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\nvec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\nvec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\nvec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\nvec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\nvec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\nvec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\nvec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\ng000 *= norm0.x;\ng010 *= norm0.y;\ng100 *= norm0.z;\ng110 *= norm0.w;\nvec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\ng001 *= norm1.x;\ng011 *= norm1.y;\ng101 *= norm1.z;\ng111 *= norm1.w;\nfloat n000 = dot(g000, Pf0);\nfloat n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\nfloat n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\nfloat n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\nfloat n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\nfloat n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\nfloat n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\nfloat n111 = dot(g111, Pf1);\nvec3 fade_xyz = fade(Pf0);\nvec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\nvec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\nfloat n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\nreturn 2.2 * n_xyz;\n}\n\nfloat fbm(vec3 P,float lacunarity, float gain)\n{\n    float sum = 0.0;\n    float amp = 1.7;\n    float add = 0.0;\n    vec3 pp = P;\n     \n    for(int i = 0; i < 5; i+=1)\n    {\n      add = cnoise(vec3(pp.x, pp.y*4.0, pp.z));\n      add += sin(pp.y*0.5)*0.5;\n      if(add > 0.0)\n\t\tadd = (1.0 - add)*(1.0 - add);\n      else\n        add = (-1.0 - add) * (-1.0 - add);\n\n      sum += amp * add;\n      amp *= gain;\n      pp *= lacunarity;\n        \n    }\n    \n    return sum*(1.0-gain)/(1.0-amp);\n \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n \n  float val = fbm(vec3(vec2(fragCoord.x*.5/iResolution.x + iMouse.x/iResolution.x,\n                            fragCoord.y*.5/iResolution.y + iTime/100.0)*3.0 + iMouse.y/iResolution.y,\n                       \t\tiTime/5.0), 2.1, 0.45);\n \n    val = 0.6 + val/2.0;\n\n  fragColor = vec4(val*val*0.5, val*val*0.5, val, 1);\n  }\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llX3z2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 23, 104, 189], [190, 190, 211, 211, 258], [259, 259, 280, 280, 327], [329, 329, 351, 351, 386], [387, 387, 415, 415, 465], [466, 466, 485, 485, 523], [525, 1292, 1314, 1314, 3486], [3488, 3488, 3536, 3536, 3976], [3977, 3977, 4033, 4033, 4355]], "test": "valid"}
{"id": "llX3zl", "name": "happy chinese new year", "author": "thu_yumeng", "description": "thanks:https://www.shadertoy.com/view/Mlf3WM", "tags": ["forfine2d"], "likes": 1, "viewed": 108, "published": "Public", "date": "1424247028", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by yumeng 2/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat s( float b ) {\n    return abs( b / 2. - mod( iTime* 2e1, b ) );\n}\n\nfloat sArea(vec2 p1,vec2 p2,vec2 p3)\n{\n    float s;\n    s = 0.5*((p1.x*p2.y-p2.x*p1.y)+(p2.x*p3.y-p3.x*p2.y)+(p3.x*p1.y-p1.x*p3.y));\n    return abs(s);\n}\n//ç”»å‡ºä¸¤ä¸ªå›ºå®šçš„ç‚¹æž„æˆçš„æ–œè¾¹\nvec2 getLineColor(vec2 st, vec2 ed, vec2 px)\n{\n    vec2 p = px / 1e1;\n   \n    float a = 10.0;\n    float sr = sArea(p,st,ed);\n    float c = 0.0;\n    \n    vec2 min_b = min(st,ed);\n    vec2 max_b = max(st,ed);\n    \n    float delta = 2.0;\n    if(p.x<min_b.x-delta||p.y<min_b.y-delta||p.x>max_b.x+delta||p.y>max_b.y+delta)\n    {\n        return vec2(a,c);\n    }\n    \n    if ( a > sr)\n    {\n        a = sr/10.0;\n        c =0.6*p.y+p.x;\n        c = c+iTime*3.8;\n        //c = mod(iTime,c);\n    }\n    return vec2(a,c); \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float a = 1e1,d, m = 0.;\n\tvec2 p = fragCoord.xy / a;\n\n    vec2 res = iResolution.xy/a;\n    \n    vec2 st = vec2(res.x*0.38,res.y);\n    vec2 ed = vec2(res.x*0.49,res.y*0.76);\n    vec2 result = getLineColor(st,ed,fragCoord);\n    \n    st = vec2(res.x*0.62,res.y);\n    ed = vec2(res.x*0.51,res.y*0.76);\n    if(result.y == 0.0) \n    {\n        result = getLineColor(st,ed,fragCoord);\n        //result.y = 0.2;\n    }\n    \n    st = vec2(res.x*0.32,res.y*0.73);\n    ed = vec2(res.x*0.68,res.y*0.73);\n    if(result.y == 0.0)\n    {\n        result = getLineColor(st,ed,fragCoord);\n        //result.y = 2.45;\n        //result.x = 1.0;\n    }\n    \n    st = vec2(res.x*0.38,res.y*0.51);\n    ed = vec2(res.x*0.62,res.y*0.51);\n    if(result.y == 0.0)\n    {\n        result = getLineColor(st,ed,fragCoord);\n    }\n    \n    st = vec2(res.x*0.28,res.y*0.3);\n    ed = vec2(res.x*0.72,res.y*0.3);\n    if(result.y == 0.0)\n    {\n        result = getLineColor(st,ed,fragCoord);\n    }\n    \n    st = vec2(res.x*0.5,res.y*0.73);\n    ed = vec2(res.x*0.5,0.);\n    if(result.y == 0.0)\n    {\n        result = getLineColor(st,ed,fragCoord);\n    }\n    m = result.y;\n    a = result.x;\n\n    vec3 c;\n\tfor ( int i = 0 ; i < 3 ; i++ ) {\n        m /= 3.;\n\t\tc[ i ] = fract( m );\n\t}\n    vec2 q = 0.6 * (2.0*fragCoord.xy-iResolution.xy)/min(iResolution.y,iResolution.x);\n\tfloat r = length(q);\n    vec3 bcol = vec3(0.8+0.1*q.y,0.2,0.2-0.1*q.y);\n    bcol *= 1.0 - 0.5*r;\n    \n    vec3 ccol = clamp(c/a,0.,1.);\n    \n    fragColor.rgb = mix(bcol,ccol,ccol.x);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llX3zl.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[116, 116, 136, 136, 187], [189, 189, 227, 227, 342], [343, 432, 478, 478, 944], [945, 945, 1002, 1002, 2517]], "test": "valid"}
{"id": "llX3zs", "name": "Rainbow Ring Illusion", "author": "Glyph", "description": "I'm very new to shaders. This is the first thing I've created that I would consider even mildly interesting. I am positive that my code is horribly inefficient, so if you can tell me how to make it better please do not hesitate to comment. ", "tags": ["illusion", "ring", "wiggle"], "likes": 5, "viewed": 1389, "published": "Public API", "date": "1424365714", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float pi = 3.14159265;//Pi constant\n\n\nbool ring(vec2 origin,float radius,float width){//Function for drawing ring\n    if(length(origin) < radius && length(origin) > radius - width){//Test if current pixel is within ring surface\n        return(true);//Return true if the point is within the ring\n    }\n        return(false);//Return false otherwise\n}\nbool circle(vec2 origin,float radius){//Function for drawing ring\n    if(length(origin) < radius){//Test if current pixel is within ring surface\n        return(true);//Return true if the point is within the ring\n    }\n        return(false);//Return false otherwise\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 finalcol;//Variable to hold the final color for this pixel\n    vec2 mpoint = (fragCoord.xy - iResolution.xy/2.0) - (iMouse.xy - iResolution.xy/2.0);//Set's the default ring origin to the mouse coordinate\n    \n    if(iMouse.xy == vec2(0.0,0.0)){//If the mouse is in the default position set the default origin to the center of the frame\n        mpoint = (fragCoord.xy - iResolution.xy/2.0);\n    }\n    \n   \tfloat sec = iTime*2.0*pi;//time multiplied by 2pi. Using this as sin or cos input makes the function's period 1 second\n    float dens = 100.0;//Density of colors, higher values increases the distance between color changes\n    float doff = -.5*sec;//Speed at which the colors scroll across the rings\n    \n    for(float i = 10.0; i < 600.0/*Controls maximum radius*/; i+=10.0/*Controls difference in radius between rings*/){//For loop that creates the many different rings: i value is radius. \n    \tif(ring(vec2(mpoint.x + i*.5*cos(sec*.15),mpoint.y + i*.5*sin(sec*.15)),i,2.0+ i*.01) || circle(mpoint,1.0)){//Evaluate rings and offset them using trig functions.\n        \tfinalcol=vec4(sin(i*pi/dens + doff),cos(i*pi/dens + doff),cos(i*pi/dens + pi/1.3 + doff),1.0);//Apply the colors and change each colors balance using trig functions\n        \tbreak;\n        }else{finalcol = vec4(0.0,0.0,0.0,1.0);}//If not in a ring set color to black\n    }\n    fragColor=finalcol;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llX3zs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 38, 86, 113, 349], [350, 350, 388, 415, 616], [618, 618, 675, 675, 2058]], "test": "valid"}
{"id": "llXGRX", "name": "Burning Heart", "author": "dnnkeeper", "description": "With love to Unity 3d :) \nThanks eiffie (for heart distance field function) and simesgreen (for fireball shader example).", "tags": ["procedural", "3d", "raymarch"], "likes": 28, "viewed": 3176, "published": "Public API", "date": "1423683852", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int _VolumeSteps = 40;\nconst float _StepSize = 0.08; \nconst float _Density = 0.1;\n\nconst float _SphereRadius = 1.75;\nconst float _NoiseFreq = 1.0;\nconst float _NoiseAmp = 3.0;\nconst float _PulseAmp = 0.05;\nconst float _PulseFreq = 3.0;\nconst float _WaveLength = 0.8;\nconst float _WaveStr = 0.5;\nconst vec3 _NoiseAnim = vec3(-0.50, -1.0, 0.0);\n\n// iq's nice integer-less noise function\n\n// matrix to rotate the noise octaves\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\n\nfloat sqlen(in vec3 p)\n{\n    return (p.x*p.x+p.y*p.y+p.z*p.z);\n}\n\nfloat Heart(in vec3 p)\n{\n    p = vec3(p.z,p.y,p.x);\n    float h=p.x*p.x+p.y*p.y+2.0*p.z*p.z-1.0,pyyy=p.y*p.y*p.y;\n    //float v=h*h*h-(p.x*p.x-0.1*p.z*p.z)*pyyy;//the messed up bit\n    float v=h*h*h-(p.x*p.x)*pyyy;//the messed up bit\n    \n    vec3 g=vec3(6.0*p.x*h*h-2.0*p.x*pyyy,\n                    6.0*p.y*h*h-3.0*p.x*p.x*p.y*p.y-0.3*p.z*p.z*p.y*p.y,\n                    12.0*p.z*h*h-0.2*p.z*pyyy);\n\n    float pulse = (sin(iTime*_PulseFreq)-1.0)*4.0;\n\tpulse = pow(8.0,pulse);\n    \n    return 5.0*(v/length(g)+pulse*_PulseAmp);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    //p = m*p*2.02; f += 0.03125*abs(noise( p ));\t\n    return f;\n}\n\n// returns signed distance to surface\nfloat distanceFunc(vec3 p)\n{\t\n\tfloat d = sqlen(p) - _SphereRadius;\t// distance to sphere\n    d = min(d, sin(d*_WaveLength-iTime*_PulseFreq)+_WaveStr); \n\t//d += min(d,Heart(p));\n\t// offset distance with pyroclastic noise\n\t//p = normalize(p) * _SphereRadius;\t// project noise point to sphere surface\n\td += fbm(p*_NoiseFreq + _NoiseAnim*iTime) * _NoiseAmp;\n    d = min(d,Heart(p));\n\treturn d;\n}\n\n// color gradient \n// this should be in a 1D texture really\nvec4 gradient(float x)\n{\n\t// no constant array initializers allowed in GLES SL!\n\tconst vec4 c0 = vec4(2, 2, 1, 1);\t// yellow\n\tconst vec4 c1 = vec4(1, 0, 0, 1);\t// red\n\tconst vec4 c2 = vec4(0, 0, 0, 0); \t// black\n\tconst vec4 c3 = vec4(0, 0.5, 1, 0.5); \t// blue\n\tconst vec4 c4 = vec4(0, 0, 0, 0); \t// black\n\t\n\tx = clamp(x, 0.0, 0.999);\n\tfloat t = fract(x*4.0);\n\tvec4 c;\n\tif (x < 0.25) {\n\t\tc =  mix(c0, c1, t);\n\t} else if (x < 0.5) {\n\t\tc = mix(c1, c2, t);\n\t} else if (x < 0.75) {\n\t\tc = mix(c2, c3, t);\n\t} else {\n\t\tc = mix(c3, c4, t);\t\t\n\t}\n\t//return vec4(x);\n\t//return vec4(t);\n\treturn c;\n}\n\n// shade a point based on distance\nvec4 shade(float d)\n{\t\n\t// lookup in color gradient\n\treturn gradient(d);\n\t//return mix(vec4(1, 1, 1, 1), vec4(0, 0, 0, 0), smoothstep(1.0, 1.1, d));\n}\n\n// procedural volume\n// maps position to color\nvec4 volumeFunc(vec3 p)\n{\n\tfloat d = distanceFunc(p);\n\treturn shade(d);\n}\n\n// ray march volume from front to back\n// returns color\nvec4 rayMarch(vec3 rayOrigin, vec3 rayStep, out vec3 pos)\n{\n\tvec4 sum = vec4(0, 0, 0, 0);\n\tpos = rayOrigin;\n\tfor(int i=0; i<_VolumeSteps; i++) {\n\t\tvec4 col = volumeFunc(pos);\n\t\tcol.a *= _Density;\n\t\t//col.a = min(col.a, 1.0);\n\t\t\n\t\t// pre-multiply alpha\n\t\tcol.rgb *= col.a;\n\t\tsum = sum + col*(1.0 - sum.a);\t\n#if 0\n\t\t// exit early if opaque\n        \tif (sum.a > 1.0)\n            \t\tbreak;\n#endif\t\t\n\t\tpos += rayStep;\n\t}\n\treturn sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy / iResolution.xy)*2.0-1.0;\n    p.x *= iResolution.x/ iResolution.y;\n\t\n    float rotx = ( iMouse.y / iResolution.y)*4.0;\n    float roty = -(iMouse.x / iResolution.x)*4.0;\n\n    float zoom = 4.0;\n\n    // camera\n    vec3 ro = zoom*normalize(vec3(cos(roty), cos(rotx), sin(roty)));\n    vec3 ww = normalize(vec3(0.0,0.0,0.0) - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    ro += rd*2.0;\n\t\n    // volume render\n    vec3 hitPos;\n    vec4 col = rayMarch(ro, rd*_StepSize, hitPos);\n    //vec4 col = gradient(p.x);\n\t    \n    fragColor = col;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llXGRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[538, 538, 561, 561, 600], [603, 603, 627, 627, 667], [669, 669, 693, 693, 1200], [1202, 1202, 1228, 1228, 1633], [1635, 1635, 1656, 1656, 1889], [1891, 1929, 1957, 1957, 2320], [2322, 2382, 2406, 2461, 2968], [2970, 3005, 3026, 3056, 3155], [3157, 3204, 3229, 3229, 3277], [3279, 3335, 3394, 3394, 3764], [3766, 3766, 3823, 3823, 4496]], "test": "valid"}
{"id": "ltfGzS", "name": "[2TC 15] Fractal Complex", "author": "coyote", "description": "Tried to fit https://www.shadertoy.com/view/XslGzl into two tweets. Couldn't do it as I wanted at first, but then fellow shader programmers jumped in, and voila. 280 chars!", "tags": ["raymarching", "fractal", "menger", "buildings"], "likes": 43, "viewed": 3094, "published": "Public API", "date": "1422878698", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//two tweet version of fb39ca4's Menger Tunnel https://www.shadertoy.com/view/XslGzl\n\n//thanks to Fabrice it is again under 2 tweets\n//278 chars:\n\n\n//2015-11-12\n//had to change it once again to accomodate new shadertoy framework which prohibits using\n//mainImage declaration with \"inout vec4 fragColor\"\n//280 chars:\n\n#define X r = max( r = abs(mod(q*s+1.,2.)-1.) , r.yzxw ), d = max(d, (.29-min(r.x,min(r.y,r.z))) / s ),  s *= 3.\nvoid mainImage( out vec4 o,  vec2 w )\n{\n    vec4 p = vec4(w,0,1)/iResolution.x-.5, r, q = p-p;\n    q.x = .3*sin(q.z=-iTime);\n    o = p/p; //hm, can this fail? for example for w.x == iResolution.x / 2.\n\n    for (int i=0; i < 99; i++) {\n        float d=0.,s=1.;\n        X; X; X; X; X;\n        d > 1e-5 ? q += p*d, o -= .01 : o;\n    }\n}\n\n\n//----------------------------------------------------------------------------\n//below is the [2TC 15] version\n//originally it was 280, but after the last shadertoy interface change it went\n//to 295 chars\n//----------------------------------------------------------------------------\n\n//an attempt to fit fb39ca4's Menger Tunnel https://www.shadertoy.com/view/XslGzl\n//into two tweets\n//\n//I managed to do it, sort of, but didn't like the too simple coloring, and especailly\n//the fact that camera was static\n//\n//so here it is now, with the camera movement that I wanted (291 chars)\n//feel free to add coloring to your liking ;)\n//btw, after 200 or so seconds fp errors might kick in...\n\n\n//UPDATE: Thanks to the great community here at ShaderToy, it is now 280 chars\n\n/*\nvoid mainImage( out vec4 f, vec2 w )\n{\n    vec4 p=vec4(w,0,1)/iResolution.x-.5,r=p-p,q=r;\n    q.x=.3*sin(q.z=-iTime);\n\n    for (float i=1.; i>0.; i-=.01) {\n\n        float d=0.,s=1.;\n\n        for (int j = 0; j < 5; j++)\n            r=max(r=abs(mod(q*s+1.,2.)-1.),r.yzxw),\n            d=max(d,(.29-min(r.x,min(r.y,r.z)))/s),\n            s*=3.;\n\n        q+=p*d;\n        \n        f = p-p+i;\n\n        if(d<1e-5) break;\n    }\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltfGzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[430, 430, 469, 469, 763]], "test": "valid"}
{"id": "ltl3DB", "name": "Animation Test", "author": "Flyguy", "description": " Testing some smooth animation stuff. Change ANIM_FUNC to see the other animation functions.", "tags": ["animation", "shapes"], "likes": 23, "viewed": 1911, "published": "Public API", "date": "1424996209", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define polar(a) vec2(cos(a),sin(a))\n#define rotate(a) mat2(cos(a),sin(a),-sin(a),cos(a));\n\n#define ANIM_FUNC Quart\n\nconst float pi = atan(1.0)*4.0;\n\n//--- 2D Shapes ---\nvec2 hex0 = polar((1.0 * pi) / 6.0);\nvec2 hex1 = polar((3.0 * pi) / 6.0);\nvec2 hex2 = polar((5.0 * pi) / 6.0);\n\nfloat hexagon(vec2 uv,float r)\n{\n    return max(max(abs(dot(uv,hex0)),abs(dot(uv,hex1))),abs(dot(uv,hex2))) - r;\n}\n\nfloat circle(vec2 uv,float r)\n{\n    return length(uv) - r;\n}\n//-----------------\n\n//--- Animation Functions ---\n\nfloat OverShoot(float s,float e,float t)\n{\n    return smoothstep(s,e,t) + sin(smoothstep(s,e,t)*pi) * 0.5;\n}\n\nfloat Spring(float s,float e,float t)\n{\n    t = clamp((t - s) / (e - s),0.0,1.0);\n    return 1.0 - cos(t*pi*6.0) * exp(-t*6.5);\n}\n\nfloat Bounce(float s,float e,float t)\n{\n    t = clamp((t - s) / (e - s),0.0,1.0);\n    return 1.0 - abs(cos(t*pi*4.0)) * exp(-t*6.0);\n}\n\nfloat Quart(float s,float e,float t)\n{\n    t = clamp((t - s) / (e - s),0.0,1.0);\n    return 1.0-pow(1.0 - t,4.0);\n}\n\nfloat Linear(float s,float e,float t)\n{\n    t = clamp((t - s) / (e - s),0.0,1.0);\n    return t;\n}\n\nfloat QuartSine(float s,float e,float t)\n{\n    t = clamp((t - s) / (e - s),0.0,1.0);\n    return sin(t * pi/2.0);\n}\n\nfloat HalfSine(float s,float e,float t)\n{\n    t = clamp((t - s) / (e - s),0.0,1.0);\n    return 1.0 - cos(t * pi)*0.5+0.5;\n}\n//---------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy / iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    uv -= res/2.0;\n    \n    float time = iTime;\n    time = mod(time,10.0);\n    \n    float hexrad = ANIM_FUNC(0.0,1.0,time) - ANIM_FUNC(8.0,9.0,time);\n    \n    hexrad = 0.1 * hexrad + 0.1;\n    \n    float df = hexagon(uv,hexrad);\n    \n    vec2 dirs[6];\n    dirs[0] = hex0;\n    dirs[1] = hex1;\n    dirs[2] = hex2;\n    dirs[3] = -hex0;\n    dirs[4] = -hex1;\n    dirs[5] = -hex2;\n    \n    float coff = 0.0;\n    \n    uv *= rotate(ANIM_FUNC(3.0,6.0,time)*pi*2.0)\n    \n    for(int i = 0;i < 6;i++)\n    {\n        float open = 1.2 + 0.2 * float(i);\n        float close = 6.0 + 0.2 * float(i);\n        \n        coff = ANIM_FUNC(open,open+0.2,time) - ANIM_FUNC(close,close+0.2,time);\n    \tcoff = coff * 0.35;\n        \n        df = min(df,circle(uv-dirs[i]*coff,0.075));\n    }\n    \n    vec3 color = vec3(0);\n    \n    color = vec3(smoothstep(0.005,0.0,df) * 0.5 + 0.25);\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltl3DB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[282, 282, 314, 314, 396], [398, 398, 429, 429, 458], [511, 511, 553, 553, 619], [621, 621, 660, 660, 750], [752, 752, 791, 791, 886], [888, 888, 926, 926, 1003], [1005, 1005, 1044, 1044, 1102], [1104, 1104, 1146, 1146, 1218], [1220, 1220, 1261, 1261, 1343]], "test": "error"}
{"id": "ltl3RS", "name": "Kalisunspotsofgrass", "author": "pandr_dk", "description": "The sunspots of the Kali-Sun are made of disco grass!\nVariant of raymarching the kaliset.", "tags": ["kalisetraymarch"], "likes": 8, "viewed": 195, "published": "Public", "date": "1423357452", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Trying to learn about the kali set, ray marching etc.\n// Inspired by https://www.shadertoy.com/view/XtlGDH and many other\n// cool things on this site!\n\n//#define BOUNCE 0.04\n#define BOUNCE 0.0\n\nvec2 kalidist(vec3 pos, float s)\n{\n    vec3 p = pos;\n    vec3 param = vec3(1.0+0.8*sin(iTime*0.03+2.4),0.8,0.4)*(1.0+(BOUNCE)*s+0.5*sin(iTime*0.03));\n    float d = 100.0;\n    float l = 100.0;\n    for (int i = 0; i < 6; i++)\n    {\n        p = abs(p) / dot(p,p) - param;\n        d = min(d,length(p.xz));\n        l = min(l,length(p.xx));\n    }\n    return vec2(d - 0.01,l);\n}\n\n\nvec3 trace(vec3 pos, vec3 dir)\n{\n    vec3 sx = vec3(0.1);//abs(pos)*3.0; \n    float s =\n        texture(iChannel0, vec2(sx.x*0.05-0.01,0)).r+ \n        texture(iChannel0, vec2(sx.x*0.05   ,0)).r + \n        texture(iChannel0, vec2(sx.x*0.05+0.01,0)).r;\n    s*=0.3333;\n    float d = kalidist(pos, s).x;\n    float step = 0.0;\n    float l = 0.0;\n    vec3 p = pos;\n    for(int i = 0; i < 100; i++)\n    {\n        if(d>0.01)\n        {\n            p = p + step*dir;\n            vec2 kd = kalidist(p,s);\n            l+=kd.y;\n            d = min(d, kd.x);\n\n            step = d*0.1;\n        }\n        else\n        {\n            break;\n        }\n    }\n    float v = length(pos-p);\n    float v1 = 1.0-v;\n    l=0.4/(0.1+l*1.0*2.0)*smoothstep(0.7,0.8,s);\n    return vec3(l*l*l,l*l,l)*0.1+v*vec3(0.2,0.2,0.0) + 1.0*clamp(vec3(v1*v1,v1,v1*v1*v1),0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 pi = fragCoord.xy / iResolution.x * 2.0 - vec2(1.0,iResolution.y/iResolution.x);\n    pi *= 0.95;\n\n    float t = iTime+12.0;\n    float cuttime = floor(t*0.05);\n    float fade = smoothstep(0.0,0.05,0.5-abs(t*0.05-cuttime-0.5));\n    \n    float ti = sin(cuttime)*t*0.03 + cuttime*17.3;\n    vec3 eye = vec3(sin(ti),1,cos(ti));\n    vec3 lookat = vec3(sin(ti*5.0),0,0);\n    vec3 dir = normalize(lookat-eye);\n    vec3 gup = vec3(0,1,0);\n    vec3 right = cross(dir, gup);\n    vec3 up = cross(right, dir);\n\n    vec3 pos = right*pi.x + up*pi.y;\n\n    vec3 c = trace(pos, dir);\n\n    float vi = pow(1.0-length(pi),0.6);\n    \n    \n    \n\tfragColor = fade*clamp(vi*vec4(c,1),0.0,1.0);\n}\n\n", "image_inputs": [{"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltl3RS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[198, 198, 232, 232, 569], [572, 572, 604, 604, 1412], [1414, 1414, 1471, 1471, 2147]], "test": "error"}
{"id": "ltl3WS", "name": "Shortest Cosmos", "author": "Kali", "description": "The quest for the shortest cosmos ended with only 163 chars of code! thanks Fabrice!", "tags": ["kaliset", "tweet"], "likes": 47, "viewed": 1470, "published": "Public", "date": "1424943272", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 o,vec2 i){\n    vec3 p;\n    for (float s=-1.,v; s++ < 2e3; p = abs(p)/v - .8 )\n        int(s)%10 < 1\n          ? o += v/1e3,\n            p = vec3(.1,.2, fract(.01*ceil(.1*s+iTime*25.)) ),\n            p.xy += s*i/3e6 : i,\n        v = dot(p,p);}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltl3WS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 266]], "test": "valid"}
{"id": "ltlGRB", "name": "ColoredWaves", "author": "tholzer", "description": "Interactive animated colored waves.\nUse mouse to change demo parameters.", "tags": ["waves", "animated", "colored"], "likes": 23, "viewed": 479, "published": "Public", "date": "1423148134", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//---------------------------------------------------------\n// Shader:   ColoredWaves.glsl         \n// original: http://glslsandbox.com/e#5398.8\n// added some mouse interaction\n//---------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tfloat scale = iResolution.y / (40.0 + iMouse.y * 0.15);\n\tfloat ring = 25.0 + floor((iMouse.x * 0.01 - 5.5)* 2.0);\t\n\tfloat radius = iResolution.x;\n\tfloat gap = scale * 0.5;\n\tvec2 pos = fragCoord.xy - iResolution.xy * 0.5;\n\tfloat d = length(pos);\n\t\n\t// Create the wiggle\n\td += (sin(pos.y * 0.25 / scale + iTime) * \n          sin(pos.x * 0.25 / scale + iTime * 0.5)) * scale * 2.0;\n\t\n\t// Compute the distance to the closest ring\n\tfloat v = mod(d + radius / (ring * 2.0), radius / ring);\n\tv = abs(v - radius / (ring * 2.0) );\n\tv = clamp(v - gap, 0.0, 1.0);\n\td /= radius;\n\tvec3 m = fract((d - 1.0) * vec3(ring * -0.5, -ring, ring * 0.25) * 0.5);\n\t\n\tfragColor = vec4(m*v, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltlGRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 237, 295, 295, 970]], "test": "valid"}
{"id": "ltlGRl", "name": "Psychedelic Eyeballs", "author": "williamledoux", "description": "Derived from https://www.shadertoy.com/view/Xs2GDd to match with SpirOps.com logo", "tags": ["eye", "random", "spirops"], "likes": 13, "viewed": 308, "published": "Public", "date": "1424426877", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\nvec3 colorBlack = vec3(0.0, 0.0, 0.0);\nvec3 colorWhite = vec3(1.0, 1.0, 1.0);\nvec3 colorPurple = vec3(0.80, 0.100, 0.6); // yellow\n\nfloat disk(vec2 r, vec2 center, float radius) {\n\treturn 1.0 - smoothstep( radius-0.007, radius+0.007, length(r-center));\n}\n\nhighp float rand(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t = iTime*2.;\n\tvec2 r = (2.0*fragCoord.xy - iResolution.xy) / iResolution.y;\n\tr *= 1.0 + 0.05*sin(r.x*5.+iTime) + 0.05*sin(r.y*3.+iTime);\n\tr *= 1.0 + 0.2*length(r);\n\tfloat side = 0.5;\n\tvec2 r2 = mod(r, side);\n\tvec2 r3 = r2-side/2.;\n    vec2 r4 = r3/2.0;\n\tfloat i = floor(r.x/side)+2.;\n\tfloat j = floor(r.y/side)+4.;\n\tfloat ii = r.x/side+2.;\n\tfloat jj = r.y/side+4.;\n\t\n\t// grey background\n    vec3 pix = vec3(.9);\n\t\n\tfloat rad, disks, sinCalc;\n\t\t\n    sinCalc = sin(t+ii*jj);\n\trad = 0.14 + 0.5*sinCalc;\n\tfloat zebradisks = disk(r3, vec2(0.,0.), rad/1.3);\t\n\n\tfloat speed = 2.0;\n\tfloat tt = iTime*speed+0.1*i+0.08*j;\n\tfloat stopEveryAngle = PI/2.0;\n\tfloat stopRatio = 0.7;\n\tfloat t1 = (floor(tt) + smoothstep(0.0, 1.0-stopRatio, fract(tt)) )*stopEveryAngle;\n\t\t\n    float cosTemp = cos(t1+i);\n    float sinTemp = sin(t1+j);\n\tfloat x = (-0.07*(sinTemp))*0.5;\n\tfloat y = (0.055*(cosTemp))*0.5;\n    \n    // eye white background\n\trad = 0.22 + 0.03*sin(t*(1.0+0.01*i));\n\tfloat blancdisks = disk(r3, vec2(0.,0.), rad-0.02);\n\tpix = mix(pix, vec3(0.85+pow(r2.y,1.5)), blancdisks);\n    \n    // eye black border\n    vec2 r5 = vec2(r3.x, r3.y*1.25);\n    float disksA = disk(r5*1.3, vec2(0.00,0.01), rad-0.005);\n\tfloat disksB = disk(r5, vec2(0.,0.), rad-0.005);\n    float diskNoir = max((1.0-(disksB-disksA)), blancdisks) ;\n\tpix -= vec3(1.0-diskNoir);\n    \n    float freq=40.0;\n    float k= rand(vec2(i,j)) * freq;    \n    r3 = vec2(r3.x, r3.y * (floor(mod(t+k, freq) / freq + 0.01*20.0/freq) + 1.0) );\n    \n    // eye white background\n\trad = (0.13 + 0.02*sinCalc)/1.3;\n\tfloat testdisks = disk(r3, vec2(x,y), rad+0.007);\n\t//pix = mix(pix, vec3(1.0), testdisks);\n    \n    // eye color\n\tdisks = disk(r3, vec2(x,y), rad);\n\tpix = mix(pix, colorPurple-0.5*r2.y+(0.2-r2.y), disks);    \n\trad = 0.05+ 0.005*sinCalc;\n    \n    // eye white border around black center\n    disks = disk(r3, vec2(x,y), rad+0.014);\n\tpix = mix(pix, colorWhite, disks);\n    \n\t// eye black center\n    disks = disk(r3, vec2(x,y), rad);\n\tpix = mix(pix, colorBlack, disks);\n\t\n    // eye white reflects on black center\n    disks = disk(r3, vec2(x+0.025,y+0.042), rad/2.3);\n\tpix = mix(pix, colorWhite, disks);\n    disks = disk(r3, vec2(x+0.04,y), (rad/5.5)+sinTemp*0.001);\n\tpix = mix(pix, colorWhite, disks);\n\n    // zebra background\n    pix = mix(pix, vec3(0.95), zebradisks*(1.0-max(disksB,blancdisks)));\n    \n\tfragColor = vec4(pix,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltlGRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[158, 158, 205, 205, 280], [510, 510, 567, 567, 2960]], "test": "valid"}
{"id": "ltlGRX", "name": "Albert's Arches", "author": "dr2", "description": "When moving at relativistic speeds things appear a little different; speed is controlled by the mouse (more information in the source).", "tags": ["einstein", "relativity", "lorentz"], "likes": 7, "viewed": 704, "published": "Public API", "date": "1423938069", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Albert's Arches\" by dr2 - 2015\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n   An earlier OpenGL version of this program (inspired by a\n   visit to the Einstein centenary exhibition in Berne) used\n   polygon rendering, after applying Lorentz contraction in\n   the direction of the observer's motion. In this raymarched\n   version, ray direction is altered by relativistic\n   aberration, as in iapafoto's \"Relativistic Starter\", but\n   the end result is exactly the same. Geometric aspects are\n   covered, but lighting effects are not included. The mouse\n   controls speed (default 0.9 c).\n*/\n\nint idObj;\nvec3 qHit, ltDir;\nfloat tCur;\nconst float dstFar = 100.;\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qq;\n  float d, dHit;\n  float nArch = 12.;\n  dHit = dstFar;\n  d = dHit;\n  p.y -= 0.5;\n  q = p;\n  q.z = mod (q.z + 1., 2.) - 1.;\n  d = PrBoxDf (q, vec3 (2., 2., 0.25));\n  q.y -= - 0.5;\n  d = max (d, - PrBoxDf (q, vec3 (1.5, 2., 0.55)));\n  q = p;  q.z -= nArch - 1.;\n  d = max (d, PrBoxDf (q, vec3 (2.2, 2.2, nArch)));\n  if (d < dHit) { dHit = d;  idObj = 1; qHit = q; }\n  q = p;  q.y -= -2.1875;  q.z -= nArch - 1.;\n  d = PrBoxDf (q, vec3 (2.75, 0.0625, nArch));\n  if (d < dHit) { dHit = d;  idObj = 2; qHit = q; }\n  q.x = abs (q.x) - 1.75;  q.y -= 0.125;\n  d = PrBoxDf (q, vec3 (0.5, 0.0625, nArch));\n  if (d < dHit) { dHit = d;  idObj = 3; qHit = q; }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec3 e = 1e-5 * vec3 (1., -1., 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * vec3 (v.y, v.z, v.w));\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 200; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nfloat CheqCol (vec3 p, vec3 n)\n{\n  p = floor (mod (p, 2.));\n  return dot (abs (n), 0.5 * vec3 (1.) +\n     0.5 * mod (vec3 (p.y + p.z, p.x + p.z, p.x + p.y), 2.));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float dstHit;\n  int idObjT;\n  idObj = -1;\n  dstHit = ObjRay (ro, rd);\n  if (idObj < 0) dstHit = dstFar;\n  if (dstHit >= dstFar) col = vec3 (0., 0., 0.15);\n  else {\n    ro += rd * dstHit;\n    idObjT = idObj;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    if (idObj == 1) col = vec3 (0.8, 0.2, 0.2) * CheqCol (4. * ro, vn);\n    else if (idObj == 2) col = vec3 (0.2, 0.8, 0.2) * CheqCol (ro, vn);\n    else col = vec3 (0.8, 0.8, 0.2) * CheqCol (2. * ro, vn);\n    col = col * (0.5 + 0.5 * max (dot (vn, ltDir), 0.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n  vec2 uvs = uv;\n  uv.x *= iResolution.x / iResolution.y;\n  tCur = iTime;\n  vec4 mPtr = iMouse;\n  mPtr.xy = mPtr.xy / iResolution.xy - 0.5;\n  float beta, cPhi, w, cLen;\n  vec3 ro, rd, col;\n  ltDir = normalize (vec3 (1., 1., -1.));\n  w = (mPtr.z > 0.) ? clamp (0.5 + mPtr.y, 0.07, 1.) : 0.9;\n  beta = clamp (pow (w, 0.25), 0.1, 0.999);\n  rd = normalize (vec3 (uv, 4.5));\n  cPhi = (rd.z - beta) / (1. - rd.z * beta);\n  rd = vec3 (0., 0., cPhi) +\n     sqrt (1. - cPhi * cPhi) * normalize (rd - vec3 (0., 0., rd.z));\n  ro = vec3 (0.);\n  ro.z += (0.3 + 1.7 * beta) * mod (tCur, 10.) - 16. * (1. - beta) - 2.;\n  col = ShowScene (ro, rd);\n  cLen = 0.3;\n  uvs.x = abs (uvs.x - 0.96);\n  if (uvs.x < 0.02 && abs (uvs.y) < cLen) {\n    col = 0.3 * col + 0.5;\n    uvs.y += cLen;\n    if (uvs.x < 0.015 && uvs.y > 0.01 && uvs.y < (2. * cLen - 0.01) *\n       (2. * beta - 1.)) col = vec3 (1., 1., 0.5);\n  }\n  fragColor = vec4 (col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltlGRX.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[712, 712, 744, 744, 839], [841, 841, 863, 863, 1542], [1544, 1544, 1565, 1565, 1783], [1785, 1785, 1818, 1818, 1994], [1996, 1996, 2028, 2028, 2160], [2162, 2162, 2197, 2197, 2761], [2763, 2763, 2820, 2820, 3796]], "test": "valid"}
{"id": "lts3RB", "name": "SuperNovaeFusion", "author": "tholzer", "description": "Burning fantasy fractal may remind to a SuperNovae", "tags": ["fractal", "burning", "mouseinput", "supernovae", "fusion"], "likes": 18, "viewed": 773, "published": "Public", "date": "1423156647", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//---------------------------------------------------------\n// Shader:   SuperNovaeFusion.glsl            by   I.G.P\n// original: https://www.shadertoy.com/view/4tfGRr\n// use mouse to rotate and look around\n//---------------------------------------------------------\n\n#define time iTime \n#define mouse iMouse\n#define resolution iResolution\n//varying vec2 surfacePosition;\n//varying vec2 surfaceSize;\n\n//---------------------------------------------------------\nvec2 cmul( vec2 a, vec2 b )  \n{ \n    return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x );\n}\n\nvec3 dmul( vec3 a, vec3 b )  \n{\n    float r = length(a);   \n    b.xy = cmul(normalize(a.xy), b.xy);\n    b.yz = cmul(normalize(a.yz), b.yz);\n    b.xz += 0.3 * cmul(normalize(a.xz), b.xz);\n    return r*b;\n}\n\nfloat field(in vec3 p) \n{\n    float res = 0.0;\n    vec3 c = p;\n    for (int i = 0; i < 10; ++i) \n    {\n        p = abs(p) / dot(p,p) - 1.0;\n        p = dmul(p,p) + 0.7;\n        res += exp(-6.0 * abs(dot(p,c)-0.15));\n    }\n    return max(0.0, res / 3.0);\n}\n\nvec3 raycast( in vec3 ro, vec3 rd )\n{\n    float t = 1.5;\n    float dt = 0.25;\n    vec3 col = vec3(0.0);\n    for( int i=20; i<25; i++ )\n    {\n        float c = field(ro+t*rd);               \n        t+=dt / (0.35+c*c);\n        c = max(5.0 * c - .9, 0.0);\n        c = c*c*c*c;\n        col = 0.04*col + 0.04*vec3(0.1*c*c, 0.2*c, 0.0);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / resolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= resolution.x / resolution.y;\n    //p += surfacePosition - 0.5;\n\n    // camera\n    float angle = 0.05*time + 0.01 * mouse.x;\n    vec3 ro = vec3(3.2*cos(angle) + 0.5, 0.0 , 3.2*sin(angle) +0.5);\n    vec3 ta = vec3(0.0, 1.2 - 0.01*mouse.y, 0.0);\n    vec3 ww = normalize (ta - ro );\n    vec3 uu = normalize (cross (ww, vec3(0.0, 1.0, 0.0)));\n    vec3 vv = normalize (cross (uu, ww));\n    vec3 rd = normalize (p.x*uu + p.y*vv + 4.0*ww);\n    \n    // raymarch\n    vec3 col = raycast(ro, rd);\n    \n    // shade\n    col =  0.3 *(log(1.0+0.2*col));\n    fragColor = vec4(sqrt(col), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lts3RB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[402, 462, 493, 493, 553], [555, 555, 586, 586, 759], [761, 761, 786, 786, 1016], [1018, 1018, 1055, 1055, 1373], [1375, 1375, 1432, 1432, 2094]], "test": "valid"}
{"id": "lts3W7", "name": "Spinning Tiles of Colourfulness", "author": "Vil", "description": "My Shadertoy version of \"Hello World\"", "tags": ["2d"], "likes": 6, "viewed": 302, "published": "Public API", "date": "1423531554", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float frameDuration = 1.0 / 60.0;\nconst float motionBlurWindow = 0.1; // seconds to motion blur over\nconst int motionBlurSamples = 20;    // number of motion blur samples\nconst float motionBlurDt = motionBlurWindow / float(motionBlurSamples - 1);\n\nconst float tileRotationSpeed = -1.67;\n\n\nvec4 tileColor(vec2 uvT, vec2 numTiles, float t)\n{\n\treturn vec4(floor(uvT) / numTiles, 0.5, 1.0);\n}\n\n\nbool inTile(vec2 uvT)\n{\n    vec2 tmp = abs(uvT);\n    return tmp.x <= 0.5 && tmp.y < 0.5;\n}\n\n\nmat2 rotation(float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, -s, s, c);\n}\n\n\nvec4 rotatedTile(vec2 uv, vec2 numTiles, float t)\n{\n    mat2 m = rotation(t * tileRotationSpeed - texture(iChannel0, uv).x * 0.2);\n    \n    vec2 uvT = uv * numTiles;\n    vec2 lo = floor(uvT) - 0.5;\n    vec2 hi = lo + 1.0;\n    vec2 hl = vec2(hi.x, lo.y);\n    vec2 lh = vec2(lo.x, hi.y);\n    \n    vec4 color = vec4(0.3);\n    if (inTile(m * (uvT - lo))) {\n        color = tileColor(m * (uvT - lo) + lo, numTiles, t);\n    }\n    else if (inTile(m * (uvT - hl))) {\n        color = tileColor(m * (uvT - hl) + hl, numTiles, t);\n    }\n    else if (inTile(m * (uvT - lh))) {\n        color = tileColor(m * (uvT - lh) + lh, numTiles, t);\n    }\n    else if (inTile(m * (uvT - hi))) {\n        color = tileColor(m * (uvT - hi) + hi, numTiles, t);\n    }\n    \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float yScale = iResolution.y / iResolution.x;\n    float size = (sin(iTime) + 1.0) * 32.0 + 32.0;\n    vec2 tileSize = vec2(size, size * yScale);\n    vec2 numTiles = iResolution.xy / tileSize;    \n    \n    vec4 color = vec4(0.0);\n    float weightScale = 2.0 / float(motionBlurSamples * (motionBlurSamples + 1));\n    for (int i = 0; i < motionBlurSamples; ++i) {\n        float frame = iTime - motionBlurDt * float(i);\n        float weight = float(motionBlurSamples - i) * weightScale;\n        vec2 uv = rotation(frame) * (fragCoord.xy / iResolution.xy - 0.5) + 0.5;\n        color += rotatedTile(uv, numTiles, frame) * weight;\n    }\n\n    fragColor = color;\n}", "image_inputs": [{"id": "XsXGRn", "previewfilepath": "/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture"}, {"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lts3W7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[295, 295, 345, 345, 394], [397, 397, 420, 420, 487], [490, 490, 518, 518, 602], [605, 605, 656, 656, 1367], [1370, 1370, 1427, 1427, 2086]], "test": "error"}
{"id": "ltsGzB", "name": "SHADE A DAY ( 2 / 5 / 2015 )", "author": "cabbibo", "description": "First attempt at joining", "tags": ["raytrace"], "likes": 12, "viewed": 487, "published": "Public", "date": "1423162215", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ALL TAKEN FROM IQs AMAZING SITE / TUTORIALS / SHADERS:\n// http://www.iquilezles.org/www/index.htm\n// https://www.shadertoy.com/user/iq\n\nconst float MAX_TRACE_DISTANCE = 10.0;           // max trace distance\nconst float INTERSECTION_PRECISION = .0001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 40;\n\t\nvec4 spherePos[100];\n    \n\n\nvec4 texCube( sampler2D sam, in vec3 p, in vec3 n, in float k )\n{\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n    vec3 w = pow( abs(n), vec3(k) );\n\treturn (x*w.x + y*w.y + z*w.z) / (w.x+w.y+w.z);\n}\n\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdPlane( vec3 p )\n{\n    \n    float f = sin( p.z * 5. ) * sin( p.x * 5. );\n    //f = 5. * smoothstep( abs(f) , 0.4 , 0.8 );\n\treturn p.y - (abs( f) * .3)/ max( 1. , pow( length( p ), 1.));\n\n}\n\n\n\nfloat sdSphere( vec3 p, float s , float offset)\n{\n\n\n    float d1 = length(p) - .1*smoothstep(0.0,1.0,iTime);;\n    d1 *= .8;\t\n    \n   // vec3 nP = vec3( x , y , z );\n    return d1 -s;\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n\n    float d1 = -p.y-c.z;\n    float d2 = max( dot(q,c.xy), p.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n\n}\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 0.3 + 10.0*mouseX;\n\tcamPos = vec3(3.5*sin(an),1.0,3.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n\n\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \n\treturn (d1.x<d2.x) ? d1 : d2;\n    \n}\n\n// exponential smooth min (k = 32);\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat opBlend( vec2 d1, vec2 d2 )\n{\n\n    return smin( d1.x , d2.x , 8.);\n}\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos ){  \n    \n   \tvec2 res = vec2( 10000. , 0.);// vec2( sdPlane( pos - vec3( 0. , -1. , 0. )), 0.0 );\n   \n    for( int i = 0; i < 20; i++ ){\n   \t\t\n        vec2 res2 = vec2( sdSphere( (pos - spherePos[i].xyz) , spherePos[i].w  , float( i )) , float(i) + 1.);\n        //vec2 res2 = vec2( udRoundBox( (pos - spherePos[i].xyz) , vec3( spherePos[i].w  ) ,spherePos[i].w * .2 ) , float(i) + 1.);\n   \t\tres.x = opBlend( res ,  res2 );\n        \n   \t}\n    \n   \treturn res;\n    \n}\n\n\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t );\n        h = m.x;\n        t += h;\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n}\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n    \n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<50; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 20.*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.612*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.5;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n\n    for( int i =0; i < 20; i++ ){\n        \n        float x = 1. * cos(iTime *.13 * (float( i )+2.));\n        float y = 1. * sin(iTime * .075 * (float( i )+4.));\n        float z = 1. * sin(iTime * .1 * (float( i )+3.3));\n        float r = .1 * ( sin( iTime * .1  *( float( i) +1.))+2.);\n    \tspherePos[i] = vec4( x ,  y ,  z , r  );\n        \n        \n    }\n\n    \n    \n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m.x );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n    vec2 res = calcIntersection( ro , rd  );\n    \n    \n    vec3 col = vec3( 0. );//vec3( .8 , .8 , .8 ); \n   \n    // If we have hit something lets get real!\n    if( res.y > -.5 ){\n\n    \tvec3 pos = ro + rd * res.x;\n    \tvec3 nor = calcNormal( pos );\n        \n        float AO = calcAO( pos , nor );\n        \n        float match = -dot( nor , rd );\n        \n\n       // float c = pow(( 1.-AO) , 5.)*  10.;\n        float c = 0.;\n        c += pow((1.- match),4.) * 1.;\n        c += pow(( 1.-AO) , 5.)*  2.;\n        col = vec3( c );// * .4 * ( nor * .5 + .5 );\n        \n       /* if( res.y < .5 ){\n            \n            float f = sin( pos.z * 5. ) * sin( pos.x * 5. );\n            //col *= 5. * smoothstep( abs(f) , 0.4 , 0.8 );\n            col *= abs( f );\n            col /= pow( length( pos ), 4.);\n        }*/\n    }\n    // apply gamma correction\n    col = pow( col, vec3(0.4545) );\n\n    fragColor = vec4( col , 1. );\n    \n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltsGzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[359, 359, 424, 424, 608], [611, 611, 656, 656, 696], [698, 698, 723, 723, 893], [897, 897, 946, 946, 1081], [1083, 1083, 1121, 1121, 1292], [1294, 1325, 1389, 1389, 1567], [1569, 1569, 1652, 1652, 1765], [1770, 1864, 1893, 1893, 1936], [1938, 1974, 2015, 2015, 2086], [2088, 2088, 2123, 2123, 2162], [2163, 2247, 2268, 2268, 2732], [2736, 2736, 2784, 2784, 3251], [3253, 3366, 3397, 3397, 3623], [3626, 3626, 3700, 3700, 3961], [3964, 3964, 4006, 4006, 4305]], "test": "error"}
{"id": "ltX3DB", "name": "Advertisement logo", "author": "Optimus", "description": "I have seen this logo from a start of an advertisement and it brought some memories. In old greek tv, many ads where throwing a logo of the advertisement company before the ad started. I remembered this one after a youtube video and decided to recreate.", "tags": ["retro", "logo", "tv", "advertisement", "greek"], "likes": 1, "viewed": 209, "published": "Public", "date": "1424796464", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// what I am trying to achieve is actually http://www.lifo.gr/icache/520/377/1/793964_Screenshot_23_34.jpg\n// From the start of here https://www.youtube.com/watch?v=-4SSYqGxk1w\n\n#define PI 3.14159265359\n\nfloat rand(vec2 co)\n{\n\treturn fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453) - 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float time = iTime;\n    vec2 resolution = iResolution.xy;\n    \n\tfloat aspect = resolution.x / resolution.y;\n\tvec2 pos = fragCoord.xy / resolution.x - vec2(0.5, 0.5 / aspect);\n\t\n\tfloat t = mod(time, 2.0);\n\tif (t > 1.0) t = 1.0;\n\t//t = 1.0;\n\n\tvec2 m = vec2(0.005 - pow(t, 3.0) * 0.04, sin(t) * 0.004);\n\n\tvec2 p1 = pos - m;\n\tvec2 p2 = pos + m;\n\n\n\tfloat r = length(pos);\n\tfloat a = atan(pos.y, pos.x);\n\n\tfloat wave = pow(sin(pow(length(p1) / length(p2), 0.5) * 64.0), 2.0);\n\t\n\t\n\tfloat c = pow(sin(a * 128.0) * 0.5 + 0.5, 2.0) * pow(r, 2.0) * wave;\n\t\n\tfloat logo = 0.0;\n\tfor (int i = 0; i<2; i++)\n\t{\n\t\tfloat ii = float(i) - 0.5;\n\t\tif (sqrt(pow((pos.x + ii * 0.04) * 2.0, 4.0) + pow(pos.y * 1.8, 6.0)) < 0.002) logo = 1.0;\n\t\tif (sqrt(pow((pos.x + ii * 0.04) * 6.0, 4.0) + pow(pos.y * 7.0, 6.0)) < 0.002) logo = 0.0;\n\t\tif (length(pos.x + ii * 0.07) < 0.01 && length(pos.y) < 0.007) logo = 0.0;\n\t}\n\tif (length(pos.x - 0.022) < 0.02 && length(pos.y - 0.003) < 0.006) logo = 1.0;\n\tif (length(pos.x + 0.022) < 0.02 && length(pos.y - 0.007*sin(pos.x * 90.0 + 3.0) + 0.005) < 0.006) logo = 1.0;\n\t\n\tif (logo < 0.0) logo = 0.0;\n\tif (logo > 1.0) logo = 1.0;\n\t\n\tlogo *= 0.5;\n\t\n\tc += rand(pos*time) * 0.025;\n\n\tvec4 color = vec4(4.0 * c, 4.0 * c, 0.1 + 4.0 * c, 1.0) + vec4(logo, logo, logo, 1.0);\n\t\n\tfragColor = color;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltX3DB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[204, 204, 225, 225, 300], [302, 302, 359, 359, 1666]], "test": "valid"}
{"id": "ltX3W2", "name": "corrupting cube", "author": "kig", "description": "Playing with a corrupting cube concept, #shadeADay for 2015-02-28", "tags": ["noise", "raymarch", "glow", "shadeaday"], "likes": 5, "viewed": 196, "published": "Public", "date": "1425157014", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define THRESHOLD 0.01\n#define MAX_DISTANCE 8.0\n\n#define RAY_STEPS 120\n#define MAX_SAMPLES 4.0\n\nfloat aa_size = 2.0;\n\n\nstruct ray\n{\n\tvec3 p; // ray origin\n\tvec3 d; // ray direction\n\n\t// how much light the ray allows to pass at this point\n\tvec3 transmit; // *= material.transmit\n\t\n\t// how much light has passed through the ray\n\tvec3 light;    // += ray.transmit * material.emit\n\n};\n\nstruct mat\n{\n\tvec3 transmit; // how much of the incoming light the material allows to pass\n\tvec3 emit;     // how much light the material emits\n\tfloat diffuse; // how much to scatter the reflections\n};\n\n// camera rotation\nmat3 rotationXY( vec2 angle ) {\n\t// pitch\n\tfloat cp = cos( angle.x );\n\tfloat sp = sin( angle.x );\n\t// yaw\n\tfloat cy = cos( angle.y );\n\tfloat sy = sin( angle.y );\n\n\treturn mat3(\n\t\tcy     , 0.0, -sy,\n\t\tsy * sp,  cp,  cy * sp,\n\t\tsy * cp, -sp,  cy * cp\n\t);\n}\n\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453123);\n}\n\nvec2 hash2( float n )\n{\n    return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123));\n}\n\nvec3 hash3( float n )\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\n// iq's LUT-based 3D noise\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel0, (uv + 0.5)/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n// cloud fBm with three noise samples, flow direction & exponential y-scale\nfloat map( in vec3 p )\n{\n\tp.y = pow(abs(p.y), 1.3);\n\t\n\tfloat time = iTime * 0.3;\n\tfloat d = -0.1 - p.y;\n\n\tvec3 dir = 8.0*normalize(p);\n\tdir.y = 0.0;\n\tvec3 q = p - dir+vec3(-0.0,3.0,-0.0)*(0.2*time);\n\tfloat f;\n    f  = 0.6*noise( q ); q = q*3.01;\n    f += 0.3*noise( q ); q = q*3.02;\n    f += 0.1*noise( q );\n\n\td += 3.5 * f;\n\n\td = clamp( d, 0.0, 1.0 );\n\t\n\treturn d;\n}\n\n\nfloat scene(vec3 p)\n{\nmat3 mp = rotationXY(vec2(0.0, 0.25*3.14159)) * rotationXY(vec2(3.14159*0.25, 0.0));\n\tfloat cube = length(max(abs(mp*p - vec3(0.0, 0.0, 0.0)) - vec3(1.95), 0.0)) - 0.05;\n\treturn cube;\n}\n\nmat material(vec3 p)\n{\n\tfloat cube = length(max(abs(p - vec3(0.0, 2.0, 0.0)) - vec3(1.95), 0.0)) - 0.05;\n\tmat m;\n\tm.emit = vec3(0.0);\n\tm.transmit = vec3(1.0);\nfloat time = iTime * 0.3;\n    float n = map(p.yzz*1.5*cos(0.5*3.14159*time)-cos(p.z+0.5*3.14159*time));\n\tm.transmit = vec3(1.1)*n; // 0.95, 0.7, 0.5);\n\tm.diffuse = 0.1+(1.0-sqrt(abs(n)));\n\treturn m;\n}\n\nvec3 normal(ray r, float d)\n{\n\tfloat e = 0.001;\n\tfloat dx = scene(vec3(e, 0.0, 0.0) + r.p) - d;\n\tfloat dy = scene(vec3(0.0, e, 0.0) + r.p) - d;\n\tfloat dz = scene(vec3(0.0, 0.0, e) + r.p) - d;\n\treturn normalize(vec3(dx, dy, dz));\n}\n\n\nvec3 shadeBg(vec3 nml, vec2 uv)\n{\n\tvec3 lightPos_ = vec3(0.5, -1.5, 8.0);\n    vec3 bgLight = normalize(lightPos_);\n    vec3 lightPos = bgLight * 9999.0;\n    vec3 sun = vec3(2.0)*4.0; //, 3.5, 2.0)*4.0;\n\n    vec3 bgColz = vec3(0.9);\n\tfloat bgDiff = dot(nml, vec3(0.0, -1.0, 0.0));\n\tfloat sunPow = dot(nml, bgLight);\n\tfloat sp = max(sunPow, 0.0);\n\tvec3 bgCol = vec3(0.0);\n\tbgCol += max(0.0, bgDiff)*vec3(0.8);\n\tbgCol += max(0.0, -bgDiff)*vec3(1.25);\n\tbgCol += vec3(0.15)*( pow(1.0-abs(bgDiff), 6.0) );\n\tbgCol += sun*(0.02*pow( sp, 3.0) + pow( sp, 256.0));\n\tbgCol += bgColz*(pow( sp, 8.0) + pow( sp, abs(bgLight.y)*128.0));\nfloat time = iTime * 0.3;\n    float t = mod(time*1.5, 3.0)-1.5;\n\treturn (bgCol + 0.25) * map(nml.yyz+2.5*t) + 0.1*hash((time)+nml.x*1211.201+nml.z*2531.029+nml.y*2443.029+3289.02);\n}\n\nfloat shade(inout ray r, vec3 nml, float d)\n{\n\tmat m = material(r.p);\n\tr.light += m.emit * r.transmit;\n\tr.transmit *= m.transmit;\n\treturn m.diffuse;\n}\n\nvec2 xy(float k, float n)\n{\n\treturn vec2(floor(k/n), k-(floor(k/n)*n));\n}\n\nvoid offset(inout vec3 nml, float k, float count, float diffuse) {\n\tvec3  uu  = normalize( cross( nml, vec3(0.01,1.0,1.0) ) );\n\tvec3  vv  = normalize( cross( uu, nml ) );\n\tvec2  aa = hash2( count );\n\tfloat ra = sqrt(aa.y);\n\tfloat rx = ra*cos(6.2831*aa.x); \n\tfloat ry = ra*sin(6.2831*aa.x);\n\tfloat rz = sqrt( sqrt(k)*(1.0-aa.y) );\n\tvec3  rr = vec3( rx*uu + ry*vv + rz*nml );\t\n\tnml = normalize(mix(nml, rr, diffuse));\n}\n\n\nray setupRay(vec2 uv, float k) {\n\tmat3 rot = rotationXY( vec2( -0.11, 0.0 )); //iTime*0.0602 ) );\n\tray r;\n\tr.light = vec3(0.0);\n\tr.transmit = vec3(1.0);\n\tr.p = rot * vec3(0.0, 0.0, -9.5) + vec3(0.0, 0.0, 0.0);\n\tr.d = rot * normalize(vec3(uv, 1.5));\n\n\treturn r;\n}\n\nvec3 trace(vec2 uv, vec2 uvD, inout float sceneDist)\n{\t\n\tfloat minDist = 9999999.0;\n\tfloat count = 0.0;\n\tfloat diffuseSum = 0.0, maxDiffuseSum = 0.0;\n\t\n\tvec3 accum = vec3(0.0);\n\tsceneDist = 9999999.0;\n\n\tray r = setupRay(uv, 1.0);\n\tvec3 op = r.p + 1.0*r.d;\n\tr.p = op;\n\tfloat k = 1.0;\n\t\n\tfor (int i=0; i<RAY_STEPS; i++) {\n\t\tif (k > MAX_SAMPLES) break;\n\t\tfloat dist = scene(r.p);\n\t\tminDist = min(minDist, dist);\n\t\tr.p += dist * r.d;\n\t\tif (dist < THRESHOLD) {\n\t\t\tif (sceneDist == 9999999.0) {\n\t\t\t\tsceneDist = length(r.p - op);\n\t\t\t}\n\t\t\tr.p -= dist * r.d;\n\t\t\tvec3 nml = normal(r, dist);\n\t\t\tfloat diffuse = shade(r, nml, dist);\n\t\t\tdiffuseSum += diffuse;\n\t\t\toffset(r.d, k, k+10.0*dot(nml, r.d), diffuse*0.5);\n\t\t\tr.d = reflect(r.d, nml);\n\t\t\tr.p += 4.0*THRESHOLD * r.d;\n\t\t\tcount++;\n\t\t\t\n\t\t\tif (dot(r.transmit, vec3(2.0)) < 0.2) {\n\t\t\t\t// if even the brightest light in the scene can't\n\t\t\t\t// make the ray brighter, let's bail.\n\t\t\t\taccum += r.light;\n\t\t\t\tk++;\n\t\t\t\tr = setupRay(uv+(uvD*mod(xy(k, aa_size), aa_size)/aa_size), k);\n\t\t\t\tmaxDiffuseSum = max(diffuseSum, maxDiffuseSum);\n\t\t\t\tdiffuseSum = 0.0;\n\t\t\t}\n\t\t} else if (dist > MAX_DISTANCE) {\n\t\t\tvec3 bg = shadeBg(-r.d, uv);\n\t\t\tif (minDist > THRESHOLD*10.5) {\n\t\t\t\taccum = bg;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\taccum += r.light + r.transmit * bg;\n\t\t\tk++;\n\t\t\tr = setupRay(uv+(uvD*mod(xy(k, aa_size), aa_size)/aa_size), k);\n\t\t\tif (sceneDist < 9999999.0) {\n\t\t\t\tr.p += sceneDist*0.95*r.d;\n\t\t\t}\n\t\t\tmaxDiffuseSum = max(diffuseSum, maxDiffuseSum);\n\t\t\tdiffuseSum = 0.0;\n\t\t}\n\t}\n\tfloat glow = 0.0;\n    if (minDist > THRESHOLD) {\n        minDist += -4.0*pow(abs(r.d.y), 2.8);\n\t\tglow = 0.04*pow(pow(max(0.0, (1.0-minDist)), 2.0), 5.0);\n    }\n\treturn accum / max(1.0, k-1.0) + glow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 aspect = vec2(iResolution.x/iResolution.y, 1.0);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = (2.0 * uv - 1.0) * aspect;\n\n\tvec2 uvD = 2.0*aspect / iResolution.xy;\n\t\n\tray r;\n\tr = setupRay(uv, 0.0);\n\t\n\tfloat dist = 999999.0;\n\tvec3 light = trace(uv, uvD, dist);\n/*\n\tif (dist > 10000.0) {\n\t\tr.p += 5.0*r.d;\n\t\tfor (int i=0; i<5; i++) {\n\t\t\tfloat c = map( r.p );\n\t\t\tr.p += 1.8*r.d;\n\t\t\tr.transmit *= 1.0+c*0.15;\n\t\t}\n\t}\n*/\n\tr.light = r.transmit * light;\n\t\n\tfragColor = mix( vec4(0.0), vec4( 1.0 - exp(-1.5 * r.light), 1.0 ), 0.5-0.5*cos(3.14159*min(1.0, iTime/1.0)) );\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltX3W2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[585, 604, 635, 645, 858], [860, 860, 883, 883, 925], [927, 927, 950, 950, 1024], [1026, 1026, 1049, 1049, 1143], [1145, 1172, 1198, 1198, 1410], [1412, 1488, 1512, 1512, 1854], [1857, 1857, 1878, 1878, 2064], [2066, 2066, 2088, 2088, 2425], [2427, 2427, 2456, 2456, 2657], [2660, 2660, 2693, 2693, 3463], [3465, 3465, 3510, 3510, 3615], [3617, 3617, 3644, 3644, 3690], [3692, 3692, 3758, 3758, 4109], [4112, 4112, 4144, 4144, 4374], [4376, 4376, 4430, 4430, 6067], [6069, 6069, 6126, 6126, 6697]], "test": "error"}
{"id": "ltX3zf", "name": "Retro City Parallax", "author": "TekF", "description": "Using my infinite city distance field for something a bit more abstract.", "tags": ["parallax"], "likes": 9, "viewed": 1976, "published": "Public API", "date": "1423785544", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Hazel Quantock 2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvec2 Rand( vec2 pos )\n{\n\treturn textureLod( iChannel0, (pos+.5)/256.0, 0.0 ).xz;\n}\n\nvec3 VoronoiPoint(vec2 pos, vec2 delta )\n{\n\tconst float randScale = .8; // reduce this to remove axis-aligned hard edged errors\n\t\n\tvec2 p = floor(pos)+delta;\n\tvec2 r = (Rand(p)-.5)*randScale;\n\tvec2 c = p+.5+r;\n\t\n\t// various length calculations for different patterns\n\t//float l = length(c-pos);\n\t//float l = length(vec3(c-pos,.1));\n\tfloat l = abs(c.x-pos.x)+abs(c.y-pos.y); // more interesting shapes\n\t\n\treturn vec3(c,l);\n}\n\n// For building height I want to know which voronoi point I used\n// For side-walls I want difference between distance of closest 2 points\nvec3 Voronoi( vec2 pos )\n{\n\t// find closest & second closest points\n\tvec3 delta = vec3(-1,0,1);\n\n\t// sample surrounding points on the distorted grid\n\t// could get 2 samples for the price of one using a rotated (17,37) grid...\n\tvec3 point[9];\n\tpoint[0] = VoronoiPoint( pos, delta.xx );\n\tpoint[1] = VoronoiPoint( pos, delta.yx );\n\tpoint[2] = VoronoiPoint( pos, delta.zx );\n\tpoint[3] = VoronoiPoint( pos, delta.xy );\n\tpoint[4] = VoronoiPoint( pos, delta.yy );\n\tpoint[5] = VoronoiPoint( pos, delta.zy );\n\tpoint[6] = VoronoiPoint( pos, delta.xz );\n\tpoint[7] = VoronoiPoint( pos, delta.yz );\n\tpoint[8] = VoronoiPoint( pos, delta.zz );\n\n\tvec3 closest;\n\tclosest.z =\n\t\tmin(\n\t\t\tmin(\n\t\t\t\tmin(\n\t\t\t\t\tmin( point[0].z, point[1].z ),\n\t\t\t\t\tmin( point[2].z, point[3].z )\n\t\t\t\t), min(\n\t\t\t\t\tmin( point[4].z, point[5].z ),\n\t\t\t\t\tmin( point[6].z, point[7].z )\n\t\t\t\t)\n\t\t\t), point[8].z\n\t\t);\n\t\n\t// find second closest\n\t// maybe there's a better way to do this\n\tclosest.xy = point[8].xy;\n\tfor ( int i=0; i < 8; i++ )\n\t{\n\t\tif ( closest.z == point[i].z )\n\t\t{\n\t\t\tclosest = point[i];\n\t\t\tpoint[i] = point[8];\n\t\t}\n\t}\n\t\t\n\tfloat t;\n\tt = min(\n\t\t\tmin(\n\t\t\t\tmin( point[0].z, point[1].z ),\n\t\t\t\tmin( point[2].z, point[3].z )\n\t\t\t), min(\n\t\t\t\tmin( point[4].z, point[5].z ),\n\t\t\t\tmin( point[6].z, point[7].z )\n\t\t\t)\n\t\t);\n\t\n\treturn vec3( closest.xy, t-closest.z );\n}\n\n\nfloat DistanceField( vec3 pos )\n{\n\tvec3 v = Voronoi(pos.xz);\n\tvec2 r = Rand(v.xy*4.0); // per-building seed\n\t\n\tfloat f = (.2+.3*r.y-v.z)*.5; //.7071; // correct for max gradient of voronoi x+z distance calc\n\t\n\t// random height\n\tfloat h = r.x; // v.xy is position of cell centre, use it as random seed\n\th = mix(.2,2.0,pow(h,2.0));\n\th = pos.y-h;\n\n\t// we get precision problems caused by the discontinuity in height\n\t// so clamp it near to the surface and then apply a plane at max height\t\n\th = max( min( h, .08 ), pos.y-2.0 );\n\n//\tf = max( f, h );\n\tif ( f > 0.0 && h > 0.0 )\n\t\tf = sqrt(f*f+h*h); // better distance computation, to reduce errors\n\telse\n\t\tf = max(f,h);\n\t\n\tf = min( f, pos.y ); // ground plane\n\t\n\treturn f;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 iHalfRes = iResolution.xy*.5;\n\tvec2 uv = fragCoord.xy;\n//    uv = floor(uv/6.0)*6.0; // pixellate! (would look better if I aligned each layer to the pixels)\n\tuv = (uv - iHalfRes)/iHalfRes.y;\n    \n    vec3 pos = vec3(1.2,0,0)*iTime+vec3(0,.4+2.0*smoothstep(.0,1.,cos(iTime*.1)),0);\n    float water = step(uv.y/1.4,-pos.y)*-2.0+1.0;\n    \n    fragColor.rgb = sin(vec3(11,7,3)*uv.y*water)*.5+.5;\n\n    float s = 2.;\n    for ( int i=0; i < 20; i++ )\n    {\n        if ( DistanceField( (vec3(uv*.4,1)*s + pos)*vec3(1,water,1) ) < .0 )\n        {\n            fragColor.rgb = sin(vec3(11,7,3)*.2*s+6.)*.5+.5;\n            break;\n        }\n        s *= 1.05+s*.02;\n    }\n    \n    if ( water < .0 )\n    {\n        fragColor.rgb = fragColor.rgb*mix(vec3(1), vec3(.1,.0,.2), smoothstep(-.5,-1.4,uv.y/1.4-pos.y) );\n    }\n    \n\tfragColor.a = 1.0;\n}\n\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltX3zf.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[111, 111, 134, 134, 193], [195, 195, 237, 237, 618], [620, 758, 784, 825, 2074], [2077, 2077, 2110, 2110, 2796], [2799, 2799, 2856, 2856, 3695]], "test": "error"}
{"id": "ltXGRj", "name": "Questionable Kiwi", "author": "eiffie", "description": "It doesn't have an expiration date but I'm still hesitant.", "tags": ["fur", "defur", "kiwi"], "likes": 16, "viewed": 1872, "published": "Public API", "date": "1423242433", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Questionable Kiwi by eiffie\n\n//Another DE Fur example but had trouble coming up with a good hair placement.\n//I think this DE is suffering from discontinuity and hairy ball syndrome (don't search that!)\n\n#define time iTime\n#define size iResolution\nvec3 mcol,LDir;\nfloat DE(in vec3 p){//fur ball\n\tp+=sin(p.yzx*(20.0+5.0*sin(time*0.1))+time*2.0)*0.02;\n\tfloat r=length(p);\n\tif(r<1.0){\n\t\tvec3 p2=p*p;\n\t\tmcol=vec3((r-0.5)*(1.0+0.5*dot(LDir,p)));\n\t\tvec2 v=(p2.x>p2.y && p2.x>p2.z)?p.yz/p.x:(p2.y>p2.z)?p.zx/p.y:p.xy/p.z;\n\t\tfloat m=0.03;//-0.04*dot(p2,p2);\n\t\tv=mod(v+m,2.0*m)-m;\n\t\tfloat r2=(length(v)-0.03+0.04*r);\n\t\tr-=0.8;\n\t\tif(r2<r)r=r2;else mcol.g*=1.25;\n\t}else r-=0.9;\n\treturn r;\n}\n\n\nfloat rndStart(vec2 co){return 0.1+0.9*fract(sin(dot(co,vec2(123.42,117.853)))*412.453);}\n\nmat3 lookat(vec3 fw,vec3 up){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,up));return mat3(rt,cross(rt,fw),fw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tfloat px=4.0/size.y;//find the pixel size\n\tfloat tim=time*0.3;\n\t\n\t//position camera\n\tvec3 ro=vec3(cos(tim),sin(tim*0.7)*0.3,sin(tim))*(2.0+0.7*cos(tim));\n\tvec3 rd=normalize(vec3((2.0*fragCoord.xy-size.xy)/size.y,2.0));\n\trd=lookat(vec3(0.0,(2.7-length(ro))*0.3,0.0)-ro,vec3(0.0,1.0,0.0))*rd;\n\t//ro=eye;rd=normalize(dir);\n\tLDir=normalize(vec3(0.4,0.75,0.4));//direction to light\n\tvec3 bcol=clamp(vec3(1.0-rd.y,1.0-rd.y-0.1*exp(-abs(rd.y*15.0)),1.0-0.5*exp(-abs(rd.y*5.0))),0.0,1.0);//backcolor\n\t//march\n\t\n\tfloat tG=(-0.85-ro.y)/rd.y,d,step=0.0;\n\tif(tG<0.0)tG=1000.0;\n\tfloat MAX_T=min(tG,6.0);\n\tvec2 g=ro.xz+rd.xz*tG;\n\tfloat t=DE(ro)*rndStart(fragCoord.xy);\n\tvec4 col=vec4(0.0);//color accumulator\n\tfor(int i=0;i<99;i++){\n\t\td=DE(ro+rd*t);\n\t\tif(d<px){\n\t\t\tvec3 scol=mcol;\n\t\t\tfloat d2=DE(ro+rd*t+LDir*px);\n\t\t\tfloat shad=0.5*abs(d2/d);\n\t\t\tscol=scol*shad+vec3(0.2,0.0,-0.2)*(shad-0.5);\n\t\t\tfloat alpha=(1.0-col.w)*clamp(1.0-d/(px),0.0,1.0);\n\t\t\tcol+=vec4(clamp(scol,0.0,1.0),1.0)*alpha;\n\t\t\tif(col.w>0.9)break;\n\t\t}\n\t\tt+=d*0.6;\n\t\tif(t>MAX_T)break;\n\t}\n\n\t//color the ground \n\tif(rd.y<0.0){\n\t\tro+=rd*tG;\n\t\tfloat s=1.0,dst=0.1;\n\t\tt=DE(ro)*rndStart(fragCoord.xy);\n\t\tfor(int i=0;i<8;i++){\n\t\t\tfloat d=max(0.0,DE(ro+LDir*t)*1.5)+0.05;\n\t\t\ts=min(s,8.0*d/t);\n\t\t\tt+=dst;dst*=2.0;\n\t\t}\n\t\tbcol*=0.5+0.5*s;\n\t}\n\tcol.rgb+=bcol*(1.0-clamp(col.w,0.0,1.0));\n\n\tfragColor=vec4(col.rgb,1.0);\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltXGRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[266, 266, 286, 296, 681], [684, 684, 708, 708, 773], [775, 775, 804, 804, 889], [891, 891, 947, 947, 2306]], "test": "valid"}
{"id": "ltXGWS", "name": "Honeycomb Pattern", "author": "TekF", "description": "After reading Wikipedia pages about tessellation, I wanted to see what it looked like to use a regular honeycomb of rhombic dodecahedra as a texture. I'm quite pleased with the result, will definitely be using it. ", "tags": ["honeycomb"], "likes": 17, "viewed": 1645, "published": "Public API", "date": "1424688972", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Hazel Quantock 2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//#define DISPLACE\n\nfloat cells( vec3 p )\n{\n    // find distance to closest \"white checker\" in checkerboard pattern\n    p = fract(p/2.0)*2.0;\n    \n    p = min( p, 2.0-p );\n    \n    return min(length(p),length(p-1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // make a shape to place the material on\n    // so we can test lighting, volumetric mapping, etc\n\tvec2 iHalfRes = iResolution.xy/2.0;\n    vec3 ray = normalize(vec3(fragCoord.xy-iHalfRes,iHalfRes.y*2.0));\n    \n    vec2 r = vec2(0);\n    if ( iMouse.z > .0 ) r += vec2(-2,3)*(iMouse.yx/iHalfRes.yx-1.0);\n    else r.y = iTime*.3;\n    \n    vec2 c = cos(r);\n    vec2 s = sin(r);\n    \n    ray.yz = ray.yz*c.x + vec2(-1,1)*ray.zy*s.x;\n    ray.xz = ray.xz*c.y + vec2(1,-1)*ray.zx*s.y;\n\n    vec3 pos = vec3(-c.x*s.y,s.x,-c.x*c.y)*4.0;\n    \n    float h;\n    for ( int i=0; i < 100; i++ )\n    {\n        h = length(pos)-2.0;\n        h = max(h,min( 1.5-length(pos.xy), (length(pos.xz)-abs(pos.y)+.4)*.7 ));\n        \n        #ifdef DISPLACE\n        \th = max( h, (h+(cells(pos*5.0)-.8))*.2 );\n        #endif\n        \n        pos += ray*h;\n        if ( h < .0001 )\n            break;\n    }\n    \n   \tfragColor = vec4(.1,.1,.1,1);\n    if ( h < .1 )\n    {\n        //fragColor.rgb = step(.5,fract(pos*5.0/2.0-.25));//\n    \tfragColor.rgb = vec3(cells(pos*5.0)/1.3);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltXGWS.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[131, 131, 154, 226, 330], [332, 332, 389, 490, 1445]], "test": "valid"}
{"id": "Mlf3DB", "name": "Daily: 25/2/15.", "author": "hughsk", "description": "A tunnel is of course obligatory :)", "tags": ["tunnel", "rays", "rings"], "likes": 9, "viewed": 234, "published": "Public", "date": "1424837200", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdTorus82( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat fogFactorExp2(\n  const float dist,\n  const float density\n) {\n  const float LOG2 = -1.442695;\n  float d = density * dist;\n  return 1.0 - clamp(exp2(d * d * LOG2), 0.0, 1.0);\n}\n\n//------------------------------------------------------------------------\n// Camera\n//\n// Move the camera. In this case it's using time and the mouse position\n// to orbitate the camera around the origin of the world (0,0,0), where\n// the yellow sphere is.\n//------------------------------------------------------------------------\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 0.0;\n\tcamPos = vec3(3.5*sin(an),1.0,3.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n\n//------------------------------------------------------------------------\n// Background \n//\n// The background color. In this case it's just a black color.\n//------------------------------------------------------------------------\nvec3 doBackground( void )\n{\n    return vec3(0.02, 0.01, 0.03);\n}\n    \n//------------------------------------------------------------------------\n// Modelling \n//\n// Defines the shapes (a sphere in this case) through a distance field, in\n// this case it's a sphere of radius 1.\n//------------------------------------------------------------------------\nfloat doModel( vec3 p )\n{\n    float d = 10000000.0;\n    vec2 off = vec2(1.0, 0.0);\n    vec3 origin = vec3(0.0, 0.0, -0.5);\n    float move = iTime * -4.0;\n    float warp = 0.25;\n    \n    for (int i = 0; i < 15; i++) {\n        float I = float(i) - 5.0;\n        float J = I - floor(move);\n        vec3 P = p.xzy;\n        \n        P += off.yxy * I;\n        P += origin;\n        P += vec3(sin(J * 0.5 + move) * warp, mod(move, 1.0), cos(J * 0.9 + move) * warp);\n        \n        d = min(d, sdTorus82(P, vec2(1.5, 0.155)));\n    }\n    \n    return d;\n}\n\n//------------------------------------------------------------------------\n// Material \n//\n// Defines the material (colors, shading, pattern, texturing) of the model\n// at every point based on its position and normal. In this case, it simply\n// returns a constant yellow color.\n//------------------------------------------------------------------------\nvec3 doMaterial( in vec3 pos, in vec3 nor )\n{\n    return vec3(0.95, 0.3, 0.15);\n}\n\n//------------------------------------------------------------------------\n// Lighting\n//------------------------------------------------------------------------\nfloat calcSoftshadow( in vec3 ro, in vec3 rd );\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec3 mal )\n{\n    vec3 lin = vec3(0.0);\n\n    // key light\n    //-----------------------------\n    vec3  lig = normalize(vec3(0.0, 0.0, 1.5)-pos);\n    float dif = max(dot(nor,lig),0.0);\n    float sha = 0.0; if( dif>0.01 ) sha=calcSoftshadow( pos+0.01*nor, lig );\n    lin += dif*vec3(4.00,4.00,4.00)*sha;\n\n    // ambient light\n    //-----------------------------\n    lin += vec3(0.50,0.50,0.50);\n\n    \n    // surface-light interacion\n    //-----------------------------\n    vec3 col = mal*lin;\n\n    \n    // fog    \n    //-----------------------------\n\t//col *= exp(-0.03*dis*dis);\n\n    return col;\n}\n\nfloat calcIntersection( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 20.0;           // max trace distance\n\tconst float precis = 0.001;        // precission of the intersection\n    float h = precis*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for( int i=0; i<90; i++ )          // max number of raymarching iterations is 90\n    {\n        if( h<precis||t>maxd ) break;\n\t    h = doModel( ro+rd*t );\n        t += h;\n    }\n\n    if( t<maxd ) res = t;\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.002;             // precision of the normal computation\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( pos + v1*eps ) + \n\t\t\t\t\t  v2*doModel( pos + v2*eps ) + \n\t\t\t\t\t  v3*doModel( pos + v3*eps ) + \n\t\t\t\t\t  v4*doModel( pos + v4*eps ) );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.0005;                 // selfintersection avoidance distance\n\tfloat h = 1.0;\n    for( int i=0; i<8; i++ )         // 40 is the max numnber of raymarching steps\n    {\n        h = doModel(ro + rd*t);\n        res = min( res, 8.0*h/t );   // 64 is the hardness of the shadows\n\t\tt += clamp( h, 0.02, 2.0 );   // limit the max and min stepping distances\n    }\n    return clamp(res,0.0,1.0);\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m.x );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = doBackground();\n\n\t// raymarch\n    float t = calcIntersection( ro, rd );\n    if( t>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\n        // materials\n        vec3 mal = doMaterial( pos, nor );\n\n        col = mix(col, doLighting( pos, nor, rd, t, mal ), 1.0 - fogFactorExp2(t, 0.2));\n\t}\n\n\t//-----------------------------------------------------\n\t// postprocessing\n    //-----------------------------------------------------\n    // gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n    col.r = smoothstep(0., 1., col.r);\n    col.b = smoothstep(0., 0.8, col.b);\n\t   \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mlf3DB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 100], [102, 102, 168, 168, 282], [284, 616, 699, 699, 798], [801, 1032, 1059, 1059, 1096], [1102, 1384, 1409, 1409, 1928], [1930, 2283, 2328, 2328, 2364], [2577, 2577, 2661, 2661, 3245], [3247, 3247, 3297, 3297, 3714], [3716, 3716, 3748, 3748, 4160], [4162, 4162, 4210, 4210, 4634], [4636, 4636, 4700, 4700, 4878], [4880, 4880, 4937, 4937, 6259]], "test": "valid"}
{"id": "Mlf3RB", "name": "Smoking", "author": "guil", "description": "Experiment with a kind of rotating smoke", "tags": ["3d", "fractal"], "likes": 24, "viewed": 575, "published": "Public", "date": "1422911764", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by S. Guillitte 2015\n#define time iTime\n\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 csqr( vec2 a )  { return vec2( a.x*a.x - a.y*a.y, 2.*a.x*a.y  ); }\n\n\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\nfloat zoom=1.;\n\nmat2 mr;\n\n\n\nfloat field(in vec3 p) {\n\t\n\tfloat res = 0.;\n\t\n    vec3 c = p;\n    c.xz *= mr;\n\tfor (int i = 0; i < 10; ++i) {\n        p = 1.1*abs(p) / dot(p,p) -.6;\n        p.yz= csqr(p.yz);\n        \n        res += exp(-6. * abs(dot(p,c))*dot(p.xz,p.xz));\n        \n\t}\n\treturn res/2.;\n}\n\n\n\nvec3 raycast( in vec3 ro, vec3 rd )\n{\n    float t = 8.0*zoom;\n    float dt = .05*zoom;\n    vec3 col= vec3(0.);\n    for( int i=0; i<64; i++ )\n\t{\n        \n        float c = field(ro+t*rd);               \n        t-=dt*(.3+c*c);\n        col = .92*col+ .19*vec3(c, c*c, c*c*c);\n\t\t\n    }\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tmr = rot(time*.2);\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = vec2(0.);\n\tif( iMouse.z>0.0 )m = iMouse.xy/iResolution.xy*3.14;\n    m-=.5;\n\n    // camera\n\n    vec3 ro = zoom*vec3(4.);\n    ro.yz*=rot(m.y);\n    ro.xz*=rot(m.x+ 0.1*time);\n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\n    \n\n\t// raymarch\n    vec3 col = raycast(ro,rd);\n    \n\t\n\t// shade\n    \n    col =  1.-.5 *(log(1.+col));\n    col = clamp(col,0.,1.);\n    fragColor = vec4( (col), 1.0 );\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mlf3RB.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[139, 139, 169, 169, 224], [225, 225, 247, 247, 296], [299, 299, 318, 318, 365], [395, 395, 419, 419, 664], [668, 668, 705, 705, 973], [976, 976, 1033, 1033, 1747]], "test": "valid"}
{"id": "Mlf3Rj", "name": "SHADE A DAY ( 2 / 8 / 2015 )", "author": "cabbibo", "description": "trying to learn reflections", "tags": ["3d", "reflection", "raytrace"], "likes": 1, "viewed": 260, "published": "Public", "date": "1423424007", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ALL TAKEN FROM IQs AMAZING SITE / TUTORIALS / SHADERS:\n// http://www.iquilezles.org/www/index.htm\n// https://www.shadertoy.com/user/iq\n\n// Specific shaders stolen from\n// ROT FUNCTIONS  : https://www.shadertoy.com/view/XsSSzG\n\n\nconst float MAX_TRACE_DISTANCE = 100.0;           // max trace distance\nconst float INTERSECTION_PRECISION = .001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 120;\n\t\n\nconst float pi = 3.14159;\n\nvec4 spherePos[8];\nvec3 sphereRot[8];\n\n\n// ROTATION FUNCTIONS TAKEN FROM\n//https://www.shadertoy.com/view/XsSSzG\nmat3 xrotate(float t) {\n\treturn mat3(1.0, 0.0, 0.0,\n                0.0, cos(t), -sin(t),\n                0.0, sin(t), cos(t));\n}\n\nmat3 yrotate(float t) {\n\treturn mat3(cos(t), 0.0, -sin(t),\n                0.0, 1.0, 0.0,\n                sin(t), 0.0, cos(t));\n}\n\nmat3 zrotate(float t) {\n    return mat3(cos(t), -sin(t), 0.0,\n                sin(t), cos(t), 0.0,\n                0.0, 0.0, 1.0);\n}\n\n\nvec4 texCube( sampler2D sam, in vec3 p, in vec3 n, in float k )\n{\n\tvec4 x = texture( sam, p.yz *.4);\n\tvec4 y = texture( sam, p.zx *.4);\n\tvec4 z = texture( sam, p.xy *.4 );\n    vec3 w = pow( abs(n), vec3(k) );\n\treturn (x*w.x + y*w.y + z*w.z) / (w.x+w.y+w.z);\n}\n\n\n\nfloat sdPlane( vec3 p )\n{\n\n    //float f = fbm( p.xy );\n    //f *= fbm( p.yz );\n    //f = 5. * smoothstep( abs(f) , 0.4 , 0.8 );\n\treturn p.y;// + sin( p.x * 1. * p.z ) * .002; //- (f * .4); //(abs( f) * .3)/ max( 1. , pow( length( p ), 1.));\n\n}\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\nmat3 fullRotate( vec3 r ){\n \n   return xrotate( r.x ) * yrotate( r.y ) * zrotate( r.z );\n    \n}\n\nfloat rotatedPlane( vec3 p , vec3 rot ){\n    \n    vec3 q = fullRotate( rot ) * p;\n    return sdPlane( q );\n\n    \n}\n\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 0.3 + 10.0*mouseX;\n\tcamPos = vec3(3.5*sin(an),1.0,3.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \n\treturn (d1.x<d2.x) ? d1 : d2;\n    \n}\n\n\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos ){  \n    \n   \tvec2 res = vec2( 100000. , -1000. );\n    \n    vec2 res2 = vec2( rotatedPlane( (pos - vec3( 0., -2. , 0.)) , vec3( .5 , 0. , 0. )) ,  0.);\n   \tres = opU( res ,  res2 );\n    \n    res2 = vec2( rotatedPlane( (pos - vec3( 0., -2. , 0.)) , vec3( -.5 , 0. , 0. )) ,  0.);\n   \tres = opU( res ,  res2 );\n    \n    res2 = vec2( rotatedPlane( (pos - vec3( 0., -2. , 0.)) , vec3( 0. , 0. , -0.5 )) ,  0.);\n   \tres = opU( res ,  res2 );\n    \n    \n    //vec2 res = vec2( 10. , -1. );\n \t\n    res2 = vec2( sdSphere( (pos - vec3( 0.)) , .5 ) ,  1.);\n   \tres = opU( res ,  res2 );\n    \n    res2 = vec2( sdSphere( (pos - vec3( 1.)) , .7 ) ,  2.);\n   \tres = opU( res ,  res2 );\n    \n    res2 = vec2( sdSphere( (pos - vec3( -1. , 1. , -1.)) , .7 ) ,  3.);\n   \tres = opU( res ,  res2 );\n    \n    res2 = vec2( sdSphere( (pos - vec3( -1. , 0. , 1.)) , .7 ) ,  4.);\n   \tres = opU( res ,  res2 );\n    \n    res2 = vec2( sdSphere( (pos - vec3( 1. , 0. , -1.)) , .7 ) ,  5.);\n   \tres = opU( res ,  res2 );\n    \n   \treturn res;\n    \n}\n\n\n// Calculates our intersection by stepping through the\n// map function, and returning both the object hit and the distance\n// it is hit at\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t );\n        h = m.x;\n        t += h;\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n}\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n    \n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<50; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 20.*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.612*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.5;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n\n    for( int i =0; i < 8; i++ ){\n        \n        float x = 1. * cos(iTime *.13 * (float( i )+2.));\n        float y = 1. * sin(iTime * .075 * (float( i )+4.));\n        float z = 1. * sin(iTime * .1 * (float( i )+3.3));\n        float r = .1 * ( sin( iTime * .1  *( float( i) +1.))+2.);\n        \n        spherePos[i] = vec4( x , y , z , r );\n        \n        \n        sphereRot[i] = vec3( \n            (sin( iTime  * (float(i)+2.) * .4)) ,\n            (sin( iTime  * (float(i)+8.2) * .2)) ,\n            (sin( iTime  * (float(i)+3.6) * .01))\n        );\n\n    }\n\n    \n    \n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    //vec2 m = vec2( 1.1 +( sin( iTime * 0.4 ) + sin( iTime * 0.01 )) * .04 , 0. );\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m.x );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,1.5 + abs(sin( iTime * .01 ) + sin( iTime * .0315 ))) ); // 2.0 is the lens length\n    \n    vec2 res = calcIntersection( ro , rd  );\n    \n    \n  //  vec3 pat = texCube( iChannel0, 0.5*pos, nor, 10.0 ).xyz;\n    vec3 col = vec3( 0. );//vec3( .8 , .8 , .8 ); \n    \n    \n    vec3 colors[5];\n    colors[0] = vec3( 1. , 0.8 , 0.8 );\n    colors[1] = vec3( 0.8 , 1. , 0.8 );\n    colors[2] = vec3( 0.8 , 0.8 , 1. );\n    colors[3] = vec3( 1. , 1. , 0.8 );\n    colors[4] = vec3( 1. , 0.8 , 1. );\n   \n    //vec3 col = texCube( iChannel0, ro + rd * 1. , rd , 1.0 ).xyz;\n    // If we have hit something lets get real!\n    if( res.y > -.5 ){\n\n    \tvec3 pos = ro + rd * res.x;\n    \tvec3 nor = calcNormal( pos );\n        \n        for( int i = 0; i < 5; i++ ){\n            if( i ==int( res.y )-1 ){\n        \tcol = colors[ i ] * .5;\n            }\n        }\n        if( int(res.y) == 0 ){\n             \n        \tcol = vec3(.3);\n                \n        }\n        vec3 refl = reflect( rd , nor );\n        vec2 res2 = calcIntersection( pos + refl * .01 , refl  );\n      \n        \n        //col += vec3( res2.y / 3. , 0. , 0. );\n        \n       // col = nor * .5 + .5;\n        if( res2.y > -.5 ){\n            \n            for( int i = 0; i < 5; i++ ){\n                if( i ==int( res2.y )-1 ){\n                \tcol *= colors[ i ] * .5;\n                }\n            }\n            \n            if( int(res2.y) == 0 ){\n             \n                col *= vec3(1.);\n                \n            }\n            vec3 pos2 = pos + refl * res2.x;\n    \t\tvec3 nor2 = calcNormal( pos2 );\n          //  col = vec3( 0. , 1. , 0. );\n            \n            vec3 refl2 = reflect( nor , nor2 );\n        \tvec2 res3 = calcIntersection( pos2  + refl2 * .01 , refl2  );\n            \n            if( res3.y > -.5 ){\n                \n                for( int i = 0; i < 5; i++ ){\n                    if( i == int( res3.y )-1 ){\n                        col *= colors[ i ] * .5;\n                    }\n                }\n                \n                if( int(res3.y) == 0 ){\n             \n                \tcol *= vec3(1.);\n                \n            \t}\n            \n                vec3 pos3 = pos + refl * res3.x;\n                vec3 nor3 = calcNormal( pos3 );\n              //  col = vec3( nor3 * .5 + .5 );\n                \n            }\n            \n            \n        }\n        \n        \n        //col = nor * .5 + .5;\n\n\n    }\n    \n    // apply gamma correction\n    col = pow( col, vec3(0.4545) );\n\n    fragColor = vec4( col , 1. );\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mlf3Rj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[492, 565, 588, 588, 694], [696, 696, 719, 719, 825], [827, 827, 850, 850, 959], [962, 962, 1027, 1027, 1221], [1225, 1225, 1250, 1353, 1469], [1472, 1472, 1507, 1507, 1531], [1534, 1534, 1560, 1560, 1629], [1631, 1631, 1671, 1671, 1745], [1748, 1779, 1843, 1843, 2021], [2023, 2023, 2106, 2106, 2219], [2222, 2316, 2345, 2345, 2388], [2391, 2475, 2496, 2496, 3511], [3514, 3653, 3701, 3701, 4168], [4170, 4283, 4314, 4314, 4540], [4543, 4543, 4617, 4617, 4878], [4881, 4881, 4923, 4923, 5222]], "test": "error"}
{"id": "MlfGWB", "name": "Day 2", "author": "echophon", "description": "ShadeADay - building on the first.  develops over time.  kind of a strange parallax on this.", "tags": ["parallax", "moire"], "likes": 0, "viewed": 157, "published": "Public", "date": "1424761241", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float m = 0.5;\n\tfloat d1 = sqrt( pow(abs(uv[0]-0.5), 1.25) + pow(abs(uv[1]-0.25), 1.75) );\n\tfloat d2 = sqrt( pow(abs(uv[0]-0.5), 1.25) + pow(abs(uv[1]-0.75), 1.75) );    \n\tfloat c1 = sin(d1*iTime*m) * cos(d2*iTime*m) * sin(uv[0]*iTime); \n    float c2 = sin(d1*iTime*m) * cos(d2*iTime*m) * sin(uv[1]*iTime);\n   \n    fragColor = vec4(c1, c2, c2,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlfGWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 459]], "test": "valid"}
{"id": "MlfGWS", "name": "ngTweet0", "author": "netgrind", "description": "a shader that can fit in a tweet", "tags": ["waves", "tweet", "netgrind", "140"], "likes": 2, "viewed": 1312, "published": "Public API", "date": "1424703878", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){vec2 u=fragCoord.xy*.01;float i=iTime;u*=mat2(cos(u.y-i),1,sin(u.x+i*.8),u.y);fragColor=vec4(sin(u),u.x*u.y,1);}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlfGWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 168]], "test": "valid"}
{"id": "Mll3WB", "name": "Fake Volume Light", "author": "eiffie", "description": "Some really cheap volume light effect.", "tags": ["fake", "cheap", "volumelight"], "likes": 38, "viewed": 2556, "published": "Public API", "date": "1424977863", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Fake Volume Light by eiffie\n//A one tap volume light effect\n\n#define rez iResolution\n#define tyme iTime\n\nfloat Torus(in vec3 z, vec2 r){return length(vec2(length(z.xy)-r.x,z.z))-r.y;}\nmat2 rm;\nfloat DE(in vec3 p){\n\tp+=vec3(0.0,-2.0,rm[0]);\n\tfloat dS=length(p)-0.5;\n\tp+=vec3(-3.0,3.0,0.0);\n\tp.xz=p.xz*rm;\n\tp.xy=rm*p.xy;\n\tfloat dB=length(max(abs(p)-vec3(0.5),0.0));\n\tp+=vec3(3.0,0.0,3.0);\n\tfloat dT=Torus(p.yzx,vec2(1.0,0.1));\n\treturn min(dS,min(dB,dT));\n}\n\nvec4 scene(in vec3 ro, in vec3 rd, in vec2 fragCoord){\n\tvec3 col=vec3(0.0);\n\tvec3 LightPos=vec3(0.0);\n\tfloat rnd=fract(sin(fragCoord.x+cos(fragCoord.y))*4317.6219);\n\tfloat t=rnd,d;\n\tro+=rd*t;\n\tfor(int i=0;i<32;i++){\n\t\tt+=d=DE(ro);\n\t\tfloat l=length(LightPos-ro);\n\t\tfloat shad=clamp(2.0*(1.0+d)*DE(ro+d*(LightPos-ro)/l)/d,0.0,1.0);\n\t\tcol+=exp(-l*5.0)+vec3(0.02)*clamp(1.0-l*0.1,0.0,1.0)*sqrt(d)*pow(shad,20.0);\n\t\tif(d<0.0001)break;\n\t\tro+=rd*min(d,0.5);\n\t}\n\treturn vec4(col,t);\n}\nmat3 lookat(vec3 fw,vec3 up){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,up));return mat3(rt,cross(rt,fw),fw);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat tim=tyme*0.6;\n    rm=mat2(cos(tyme),sin(tyme),-sin(tyme),cos(tyme));\n\tvec3 ro=vec3(sin(tim)*2.0,sin(tim*0.7),cos(tim))*5.0;\n\tvec3 rd=lookat(-ro,vec3(0.0,1.0,0.0))*normalize(vec3((2.0*(fragCoord.xy)-rez.xy)/rez.y,1.0));\n\tvec4 color=scene(ro,rd,fragCoord);\n\tfragColor = vec4(color.rgb,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mll3WB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 107, 138, 138, 185], [195, 195, 215, 215, 456], [458, 458, 512, 512, 934], [935, 935, 964, 964, 1049], [1050, 1050, 1107, 1107, 1405]], "test": "valid"}
{"id": "Mll3WS", "name": "Electro-Prim's", "author": "smb02dunnal", "description": "(Or \"Electro-Granny\")\n\nSimple 2D phase field with RGB band oscillation", "tags": ["procedural", "2d", "electro"], "likes": 37, "viewed": 2343, "published": "Public API", "date": "1424946060", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// electro-prim's by @AlexWDunn\nprecision mediump float;\n\n#define PI (3.1416)\n\nfloat electro(vec2 pos, float d, float f, float o, float s, float a, float b)\n{\n    float ti = iTime * s;\n    \n    float theta = atan(pos.y,pos.x);\n    \n    float amp = smoothstep(0.0, 1.0, (sin(theta+iTime*2.0)*0.5+0.5)-b)*a;\n    float phase = d + sin(theta * f + o + ti *2.5) * amp;\n    \n    return sin(clamp(phase, 0.0, PI*2.0) + PI/2.0) + 0.9999;\n}\n\nfloat triangle(vec2 pos, float r, float a, float o, float s, float f, float b, float t)\n{\n    float root2 = sqrt(2.0);\n\n    float d =  dot(pos, vec2(0.0,-1.0));\n    d = max(d, dot(pos, vec2(-root2,1.0)));\n    d = max(d, dot(pos, vec2( root2,1.0)));\n\n    return 1.0 - smoothstep(0.0, t, electro(pos, d/r, f, o, s, a, b));\n}\n\nfloat circle(vec2 pos, float r, float a, float o, float s, float f, float b, float t)\n{\n    float d = length(pos);\n    \n    return 1.0 - smoothstep(0.0, t, electro(pos, d/r, f, o, s, a, b));\n}\n\nfloat square(vec2 pos, float r, float a, float o, float s, float f, float b,float t)\n{\n    float d = max(abs(pos).x, abs(pos).y);\n    \n    return 1.0 - smoothstep(0.0, t, electro(pos, d/r, f, o, s, a, b));\n}\n\nfloat shape(vec2 pos, float r, float a, float o, float s, float f, float b, float t)\n{\n    float sq = square(pos-vec2(0.0,0.0),r,a,o,s,f,b,t);\n    float ci = circle(pos+vec2(0.5,0.0),r,a,o,s,f,b,t);\n    float tri  = triangle(pos-vec2(0.5,0.0),r,a,o,s,f,b,t);\n    return max(tri, max(sq, ci));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n   const float radius = 0.06;\n   const float amp = 0.9; \n   const float freq = 5.0;\n   const float band = 0.75;\n   const float speed = 0.0;\n   const float thickness = 0.003;\n    \n   vec2 pos = fragCoord.xy / max(iResolution.x, iResolution.y) * vec2(2.0) - vec2(1.0);\n   pos -= vec2(0.0, -0.5);\n    \n    \n   vec3 color = vec3(0.0);\n   color.r = shape(pos, radius, amp, 0.0 *PI,-speed, freq, band, thickness);\n   color.g = shape(pos, radius, amp, 0.7 *PI, 0.0,   freq, band, thickness);\n   color.b = shape(pos, radius, amp, 1.4 *PI, speed, freq, band, thickness);\n\n   fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mll3WS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[79, 79, 158, 158, 431], [433, 433, 522, 522, 755], [757, 757, 844, 844, 949], [951, 951, 1037, 1037, 1158], [1160, 1160, 1246, 1246, 1454], [1456, 1456, 1514, 1514, 2111]], "test": "valid"}
{"id": "Mll3zB", "name": "Archimedean Solids", "author": "paniq", "description": "Regular solids formed by intersections between cube, octahedron (the cube's dual) and rhombic dodecahedron, an interpolation of the cube and its dual. Uses IQ's 3D template.\n\nbased on the 3D template by iq", "tags": ["mattdamon"], "likes": 18, "viewed": 1534, "published": "Public API", "date": "1423181380", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// uncomment for a cross section view\n//#define CROSS_SECTION\n\n//------------------------------------------------------------------------\n// Camera\n//\n// Move the camera. In this case it's using time and the mouse position\n// to orbitate the camera around the origin of the world (0,0,0), where\n// the yellow sphere is.\n//------------------------------------------------------------------------\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n#ifdef CROSS_SECTION\n    float an = 1.5+sin(0.3*iTime);\n#else\n    float an = 0.3*iTime + 10.0*mouseX;\n#endif\n\tcamPos = vec3(4.5*sin(an),2.0,4.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n\n//------------------------------------------------------------------------\n// Background \n//\n// The background color. In this case it's just a black color.\n//------------------------------------------------------------------------\nvec3 doBackground( void )\n{\n    return vec3( 0.0, 0.0, 0.0);\n}\n\n// all three basic bodies are symmetric across the XYZ planes\n// octahedron and rhombic dodecahedron have been scaled to align\n// with the vertices of the cube.\n\n// 1D distance of X Y Z planes\nvec2 cube(vec3 p, float r) {\n    vec3 o = abs(p);\n\tfloat s = o.x;\n\ts = max(s, o.y);\n\ts = max(s, o.z);\n\treturn vec2(s-r, 0.0);\n}\n\n// 3D distance of XYZ cross diagonal plane\nvec2 octahedron(vec3 p, float r) {\n    vec3 o = abs(p) / sqrt(3.0);\n\tfloat s = o.x+o.y+o.z;\n\treturn vec2(s-r*2.0/sqrt(3.0), 1.0);\n}\n\n// 2D distance of XY YZ ZX diagonal planes\nvec2 rhombic(vec3 p, float r) {\n    vec3 o = abs(p) / sqrt(2.0);    \n\tfloat s = o.x+o.y;\n\ts = max(s, o.y+o.z);\n\ts = max(s, o.z+o.x);\n\treturn vec2(\n        s-r*sqrt(2.0),\n        2.0);\n}\n\nvec2 min2(vec2 a, vec2 b) {\n    return (a.x <= b.x)?a:b;\n}\n\nvec2 max2(vec2 a, vec2 b) {\n    return (a.x > b.x)?a:b;\n}\n\n#define SHAPE_COUNT 8.0\nvec3 get_factors(int i) {\n    if (i == 0) {\n        // cube\n        return vec3(1.0, 6.0/4.0, 1.0);\n    } else if (i == 1) {\n        // truncated cube\n        return vec3(1.0, 6.0/5.0, 1.0);\n    } else if (i == 2) {\n        // cuboctahedron\n        return vec3(1.0, 1.0, 1.0);\n    } else if (i == 3) {\n        // truncated octahedron\n        return vec3(4.0/3.0, 1.0, 1.0);\n    } else if (i == 4) {\n        // truncated cuboctahedron\n        return vec3(sqrt(3.0/2.0), 2.0/sqrt(3.0), 1.0);\n    } else if (i == 5) {\n        // rhombicuboctahedron\n        return vec3(sqrt(2.0), sqrt(5.0/3.0), 1.0);\n    } else if (i == 6) {\n        // octahedron\n        return vec3(2.0, 1.0, 1.0);\n    }\n    return vec3(0.0);\n}\n\nvec2 plane( vec3 p) {\n    return vec2(p.y+2.0,3.0);\n}\n\n//------------------------------------------------------------------------\n// Modelling \n//\n// Defines the shapes (a sphere in this case) through a distance field, in\n// this case it's a sphere of radius 1.\n//------------------------------------------------------------------------\nvec2 add_plane(vec3 p, vec2 m) {\n#ifdef CROSS_SECTION\n    m.x = max(max(m.x, p.x),-m.x-0.2);\n#endif\n    return min2(plane(p),m);\n}\n\nvec2 doModel( vec3 p ) {\n    float k = iTime*0.5;\n    //k = 1.0;\n    float u = smoothstep(0.0,1.0,smoothstep(0.0,1.0,fract(k)));\n    int s1 = int(mod(k,SHAPE_COUNT));\n    int s2 = int(mod(k+1.0,SHAPE_COUNT));\n    if (s1 == 6) {\n        return add_plane(p, mix(octahedron(p, 1.0), rhombic(p, 1.0), u));\n    } else if (s1 == 7) {\n        return add_plane(p, mix(rhombic(p, 1.0), cube(p, 1.0), u));\n    } else {\n        vec3 f = mix(get_factors(s1),\n                   get_factors(s2), u);\n        return add_plane(p, max2(max2(cube(p,f.x),octahedron(p, f.y)), rhombic(p, f.z)));\n    }\n  \n}\n\n//------------------------------------------------------------------------\n// Material \n//\n// Defines the material (colors, shading, pattern, texturing) of the model\n// at every point based on its position and normal. In this case, it simply\n// returns a constant yellow color.\n//------------------------------------------------------------------------\nvec3 doMaterial( in vec3 pos, in vec3 nor )\n{\n    float k = doModel(pos).y;\n    return mix(mix(mix(vec3(1.0,0.07,0.01),vec3(0.2,1.0,0.01),clamp(k,0.0,1.0)),\n               vec3(0.1,0.07,1.0),\n               clamp(k-1.0,0.0,1.0)),\n               vec3(0.1),\n               clamp(k-2.0,0.0,1.0));\n}\n\n//------------------------------------------------------------------------\n// Lighting\n//------------------------------------------------------------------------\nfloat calcSoftshadow( in vec3 ro, in vec3 rd );\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec3 mal )\n{\n    vec3 lin = vec3(0.0);\n\n    // key light\n    //-----------------------------\n    vec3  lig = normalize(vec3(1.0,0.7,0.9));\n    float dif = dot(nor,lig) * 0.5 + 0.5;\n    float sha = 0.0; if( dif>0.01 ) sha=calcSoftshadow( pos+0.01*nor, lig );\n    lin += dif;\n\n    \n    // surface-light interacion\n    //-----------------------------\n    vec3 col = mal*lin;\n\n    \n    // fog    \n    //-----------------------------\n\tcol *= exp(-0.01*dis*dis);\n\n    return col;\n}\n\nfloat calcIntersection( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 20.0;           // max trace distance\n\tconst float precis = 0.001;        // precission of the intersection\n    float h = precis*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for( int i=0; i<90; i++ )          // max number of raymarching iterations is 90\n    {\n        if( h<precis||t>maxd ) break;\n\t    h = doModel( ro+rd*t ).x;\n        t += h;\n    }\n\n    if( t<maxd ) res = t;\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.002;             // precision of the normal computation\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( pos + v1*eps ).x + \n\t\t\t\t\t  v2*doModel( pos + v2*eps ).x + \n\t\t\t\t\t  v3*doModel( pos + v3*eps ).x + \n\t\t\t\t\t  v4*doModel( pos + v4*eps ).x );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.0005;                 // selfintersection avoidance distance\n\tfloat h = 1.0;\n    for( int i=0; i<40; i++ )         // 40 is the max numnber of raymarching steps\n    {\n        h = doModel(ro + rd*t).x;\n        res = min( res, 64.0*h/t );   // 64 is the hardness of the shadows\n\t\tt += clamp( h, 0.02, 2.0 );   // limit the max and min stepping distances\n    }\n    return clamp(res,0.0,1.0);\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m.x );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = doBackground();\n\n\t// raymarch\n    float t = calcIntersection( ro, rd );\n    if( t>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\n        // materials\n        vec3 mal = doMaterial( pos, nor );\n\n        col = doLighting( pos, nor, rd, t, mal );\n\t}\n\n\t//-----------------------------------------------------\n\t// postprocessing\n    //-----------------------------------------------------\n    // gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n\t   \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mll3zB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[64, 396, 479, 479, 667], [670, 901, 928, 928, 963], [1127, 1158, 1186, 1186, 1285], [1287, 1330, 1364, 1364, 1461], [1463, 1506, 1537, 1537, 1691], [1693, 1693, 1720, 1720, 1751], [1753, 1753, 1780, 1780, 1810], [1836, 1836, 1861, 1861, 2546], [2548, 2548, 2569, 2569, 2601], [2603, 2885, 2917, 2917, 3015], [3017, 3017, 3041, 3041, 3604], [3606, 3959, 4004, 4004, 4254], [4467, 4467, 4551, 4551, 5014], [5016, 5016, 5066, 5066, 5485], [5487, 5487, 5519, 5519, 5939], [5941, 5941, 5989, 5989, 6417], [6419, 6419, 6483, 6483, 6661], [6663, 6663, 6720, 6720, 7924]], "test": "valid"}
{"id": "Mll3zj", "name": "Star Nest Retro", "author": "Loadus", "description": "Modified the original posted by Kali to add some retro sparkle into it. ^.^\n\nAlso demonstrating the use of the S -shaped contrast in practice. Rendering the stuff with a very wide dynamic range and then compressing it.", "tags": ["fractal", "space", "volumetric", "stars"], "likes": 73, "viewed": 3009, "published": "Public", "date": "1423498029", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Star Nest by Pablo RomÃ¡n Andrioli\n\n// This content is under the MIT License.\n\n// Original post by Kali https://www.shadertoy.com/view/XlfGRj\n\n#define iterations 17\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.002 \n\n#define brightness 0.002\n#define darkmatter 0.300\n#define distfading 0.750\n#define saturation 0.750\n\nfloat SCurve (float value) {\n\n    if (value < 0.5)\n    {\n        return value * value * value * value * value * 16.0; \n    }\n    \n    value -= 1.0;\n    \n    return value * value * value * value * value * 16.0 + 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*zoom,1.);\n\tfloat time=iTime*speed+.25;\n\n\t//mouse rotation\n\tfloat a1=.5+iMouse.x/iResolution.x*2.;\n\tfloat a2=.8+iMouse.y/iResolution.y*2.;\n\tmat2 rot1=mat2(cos(a1),sin(a1),-sin(a1),cos(a1));\n\tmat2 rot2=mat2(cos(a2),sin(a2),-sin(a2),cos(a2));\n\tdir.xz*=rot1;\n\tdir.xy*=rot2;\n\tvec3 from=vec3(1.,.5,0.5);\n\tfrom+=vec3(time*2.,time,-2.);\n\tfrom.xz*=rot1;\n\tfrom.xy*=rot2;\n\t\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam; // the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta = pow(a, 2.5); // add contrast\n\t\tif (r>6) fade*=1.-dm; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n    \n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n    \n    vec4 C = vec4(v*.01,1.);\n    \n     \tC.r = pow(C.r, 0.35); \n \t \tC.g = pow(C.g, 0.36); \n \t \tC.b = pow(C.b, 0.4); \n \t\n    vec4 L = C;   \t\n    \n    \tC.r = mix(L.r, SCurve(C.r), 1.0); \n    \tC.g = mix(L.g, SCurve(C.g), 0.9); \n    \tC.b = mix(L.b, SCurve(C.b), 0.6);     \t\n    \n\tfragColor = C;\t\n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mll3zj.jpg", "access": "shaders20k", "license": "mit", "functions": [[403, 403, 431, 431, 620], [622, 622, 679, 707, 2211]], "test": "valid"}
{"id": "Mll3zX", "name": "SHADE A DAY ( 2 / 14 / 2015 )", "author": "cabbibo", "description": "Trying to think about transparency works with raytracing", "tags": ["transparency", "raytrace"], "likes": 1, "viewed": 256, "published": "Public", "date": "1424017100", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// ALL TAKEN FROM IQs AMAZING SITE / TUTORIALS / SHADERS:\n// http://www.iquilezles.org/www/index.htm\n// https://www.shadertoy.com/user/iq\n\n\nconst float MAX_TRACE_DISTANCE = 10.0;           // max trace distance\nconst float INTERSECTION_PRECISION = 0.01;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 80;\n\t\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 0.3 + 10.0*mouseX;\n\tcamPos = vec3(3.5*sin(an),1.0,3.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n\n\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \n\treturn (d1.x<d2.x) ? d1 : d2;\n    \n}\n\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos ){  \n    \n   \tvec2 res = vec2(length( pos ) - 1. , 0.0 );\n    \n   \treturn res;\n    \n}\n\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map2( vec3 pos ){  \n    \n    vec3 offset =  vec3( (5. +sin( iTime ))/ 5. , 1. + .1 * sin( pos.x * 40.) , 1. );\n   \tvec2 res = vec2(length( pos * offset)  - .5 , 0.0 );\n    \n   \treturn res;\n    \n}\n\n\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t );\n        h = m.x;\n        t += h;\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n}\n\n\nvec2 calcIntersection2( in vec3 ro, in vec3 rd ){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map2( ro+rd*t );\n        h = m.x;\n        t += h;\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n}\n\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n    \n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t  \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m.x );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n    vec2 res = calcIntersection( ro , rd  );\n    \n    \n    vec3 col = vec3( 0. , 0. , 0. ); \n  \n    vec3 light = vec3( 2. , 2. , 0. ); \n    // If we have hit something lets get real!\n    if( res.y > -.5 ){\n\t\t   \n        vec3 pos = ro + rd * res.x;\n        vec3 nor = calcNormal(pos );\n        vec3 lightDir = normalize(light - pos);\n\n        float lamb = max( 0., dot( nor , lightDir ) );\n\n        \n        float match = max( 0., dot( -nor , rd ) );\n\n   \n    \t  col = vec3(pow(1. - match , 4. ) ) * lamb * (nor * .5 + .5);\n        \n        vec3 refr = refract( rd , nor , 1. );\n\n\n        vec3 lightRefr = normalize(refract( lightDir , nor , 1. ));\n        \n        vec3 rf = normalize( refr );\n        \n       vec2 res2 = calcIntersection2( pos + rf*.01 , rf );\n       \n        if( res2.y > -.5 ){\n            \n            vec3 pos2 = pos + rf*.01 + rf * res2.x;\n        \t  vec3 nor2 = calcNormal(pos2 );\n\n            float lamb = max( 0., dot( nor2 , lightRefr ) );\n\n    \t\t\n            col += nor2 * .5 + .5;\n            \n       \t\t//col = vec3( 1. , 0. , 0. );\n        \t\n        }\n        \n        \n    }\n    // apply gamma correction\n    col = pow( col, vec3(0.4545) );\n\n    fragColor = vec4( col , 1. );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mll3zX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[333, 364, 428, 428, 606], [608, 608, 691, 691, 804], [809, 903, 932, 932, 975], [977, 1061, 1082, 1082, 1165], [1167, 1251, 1273, 1273, 1451], [1455, 1455, 1503, 1503, 1970], [1973, 1973, 2022, 2022, 2490], [2493, 2606, 2637, 2637, 2863], [2867, 2867, 2924, 2924, 4662]], "test": "valid"}
{"id": "MllGzB", "name": "Evolving Julia", "author": "Marco_Gilardi", "description": "Julia set animation", "tags": ["julia", "fractals"], "likes": 5, "viewed": 121, "published": "Public", "date": "1423164875", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//by Marco Gilardi\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float n = 1024.0;\n\tvec2 p = fragCoord.xy - iResolution.xy * 0.5;\n\tp *= 3.0/(max(iResolution.x,iResolution.y));\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n\tvec2 c = vec2(-0.754, 0.05*(abs(cos(0.1*iTime))+0.8));\n\tvec2 z = p;\n\tfloat scale = 0.01;\n\t\n\tfloat t;\n    \n\tfor ( int i = 0 ; i < int(n); i++ ) {\n\t\tz = c + vec2( z.x * z.x - z.y * z.y, 2.0 * z.x * z.y);\n\t\tif ( dot(z, z) > 10.0 ) {\n\t\t\t\n\t\t\tbreak;\n\t\t}\n        t += 1.0/(n-1.0);\n\t}\n\tvec3 col = vec3(t*3.0);\n\tfragColor = vec4(clamp(col, 0.0, 1.0) ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MllGzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 77, 77, 589]], "test": "valid"}
{"id": "MllGzS", "name": "Julia Slice", "author": "mhnewman", "description": "Random 2D slice through 4D Julia set space", "tags": ["2d", "fractal", "julia", "mandelbrot", "4d"], "likes": 3, "viewed": 293, "published": "Public", "date": "1423123083", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\tThis shader takes random 2D slices through the 4D Julia set space.\n\n//\tThe Mandelbrot set and Julia set generative formulas can be generalized as:\n//\tZ(0) = a + b*i\n//\tZ(n+1) = Z(n)^2 + c + d*i\n//\tStarting a and b at zero generates the Mandelbrot set.\n//\tForcing c and d to remain constant generates a Julia set.\n//\tTogether, these parameters (a, b, c, d) form a four dimensional space.\n//\tThis shader randomly takes a two dimensional slice through this space.\n\n//\tFractal iteration and supersampling adapted from iq:\n//\thttps://www.shadertoy.com/view/4df3Rn\n\n//\tHash function adapted from David Hoskins:\n//\thttps://www.shadertoy.com/view/4djSRW\n\n\n//\tSupersampling factor\n#define AA 3\n\n//\tMaximum fractal iteration\n#define ITER 256\n\n//\t4D Fractal Brownian Motion used for sampling\nvec4 fbm41(float p);\n\n//\tSpecify the 4D sample position as a function of time and screen position\nvec4 getPos(vec2 screenPos, float time) {\n    \n    //\t4D center of image\n    vec4 center = vec4(0.0, 0.0, -0.75, 0.0) + 0.7 * fbm41(0.3 * time);\n\n    //\t4D x and y unit vectors\n    vec4 x = normalize(fbm41(0.2 * time));\n    vec4 y = fbm41(0.2 * time + 9.33);\n    y = normalize(y - x * dot(x, y));\n\n    //\tZoom factor\n    screenPos *= 1.2;\n\n    return center + screenPos.x * x + screenPos.y * y;\n}\n\nvec4 hash41(float p) {\n\tvec4 p2 = fract(p * vec4(5.3983, 5.4427, 6.9371, 5.8815));\n    p2 += dot(p2.zwxy, p2.xyzw + vec4(21.5351, 14.3137, 15.3219, 19.6285));\n\treturn fract(vec4(p2.x * p2.y * 95.4337, p2.y * p2.z * 97.597, p2.z * p2.w * 93.8365, p2.w * p2.x * 91.7612));\n}\n\nvec4 noise41(float p) {\n    float i = floor(p);\n    float f = fract(p);\n\tfloat u = f * f * (3.0 - 2.0 * f);\n    return 1.0 - 2.0 * mix(hash41(i), hash41(i + 1.0), u);\n}\n\nvec4 fbm41(float p) {\n    vec4 f = noise41(p); p *= 2.01;\n    f += 0.4 * noise41(p); p *= 2.01;\n    f += 0.16 * noise41(p); p *= 2.01;\n    f += 0.064 * noise41(p);\n    return f / 1.624;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 color = vec3(0.0);\n#if AA > 1\n    for (int m = 0; m < AA; m++)\n    for (int n = 0; n < AA; n++) {\n        vec2 p = (-iResolution.xy + 2.0 * (fragCoord.xy + vec2(float(m), float(n)) / float(AA))) / iResolution.y;\n        float w = float(AA * m + n);\n        float time = iTime + 0.02 * w / float(AA * AA);\n#else    \n        vec2 p = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;\n        float time = iTime;\n#endif\n\t\tvec4 pos = getPos(p, time);\n\n        float outside = 0.0;\n        float count = 0.0;\n        vec2 z = pos.xy;\n        vec2 c = pos.zw;\n        for (int i = 0; i < ITER; i++) {\n            z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n\n            if (dot(z, z) > 40.0) {\n                outside = 1.0;\n                break;\n            }\n            count += 1.0;\n        }\n\n        float grad = count - log2(log2(dot(z, z)));\n        color += outside * (0.5 + 0.5 * cos(0.25 * grad + vec3(3.0, 4.0, 5.0)));\n#if AA > 1\n    }\n    color /= float(AA * AA);\n#endif\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MllGzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[806, 882, 923, 954, 1278], [1280, 1280, 1302, 1302, 1552], [1554, 1554, 1577, 1577, 1722], [1724, 1724, 1745, 1745, 1911]], "test": "error"}
{"id": "Mls3RS", "name": "Perlin Noise Clouds", "author": "YoYo", "description": "Perlin Noise", "tags": ["noise"], "likes": 2, "viewed": 491, "published": "Public", "date": "1423098026", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst int firstOctave = 3;\nconst int octaves = 8;\nconst float persistence = 0.5;\n\n\n\nfloat noise(vec2 offset, int x, int y, int loop)\n{\n    float fx = mod(float(x), float(loop));\n    float fy = mod(float(y), float(loop));    \n    \n    return 2.0 * fract(sin(dot(offset + vec2(fx, fy) ,vec2(12.9898,78.233))) * 43758.5453) - 1.0;\n}\n\nfloat smoothedNoise(vec2 offset, int x, int y, int loop)\n{\n\treturn (noise(offset, x - 1, y - 1, loop) + noise(offset, x + 1, y - 1, loop) + noise(offset, x - 1, y + 1, loop) + noise(offset, x + 1, y + 1, loop)) / 16.0\n        + (noise(offset, x - 1, y, loop) + noise(offset, x + 1, y, loop) + noise(offset, x, y - 1, loop) + noise(offset, x, y + 1, loop)) / 8.0\n        + noise(offset, x, y, loop) / 4.0;\n}\n\n\nfloat interpolatedNoise(vec2 offset, vec2 p, int loop)\n{\n\tint ix = int(p.x);\n    int iy = int(p.y);\n    \n    float fx = p.x - float(ix);\n    float fy = p.y - float(iy);\n    \n    float v1 = smoothedNoise(offset, ix, iy, loop);\n    float v2 = smoothedNoise(offset, ix + 1, iy, loop);\n    float v3 = smoothedNoise(offset, ix, iy + 1, loop);\n    float v4 = smoothedNoise(offset, ix + 1, iy + 1, loop);\n    \n    float i1 = mix(v1, v2, fx);\n    float i2 = mix(v3, v4, fx);\n    \n    float i = mix(i1, i2, fy);\n    \n    return i;\n}\n\nfloat perlinNoise(vec2 uv)\n{\n\tfloat total = 0.0;\n    \n    float totalWeight = 0.0;\n    for (int i = firstOctave; i < octaves + firstOctave; ++i)\n    {\n\t\tfloat frequency = pow(2.0, float(i));\n        float amplitude = pow(persistence, float(i));\n        \n        vec2 offset = float(i) * vec2(1023.0, 117.0) + 0.0001 * iTime;\n        \n        totalWeight += amplitude;\n        \n        total += interpolatedNoise(offset, uv * frequency, int(frequency)) * amplitude;\n    }\n    \n    total /= totalWeight;\n    \n    return total;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float perlinNoiseValue = 0.5 + 0.5 * perlinNoise(uv);\n    \n\tfragColor = vec4(perlinNoiseValue, perlinNoiseValue, perlinNoiseValue, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mls3RS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[85, 85, 135, 135, 330], [332, 332, 390, 390, 738], [741, 741, 797, 797, 1264], [1266, 1266, 1294, 1294, 1792], [1794, 1794, 1851, 1851, 2041]], "test": "valid"}
{"id": "MlsGRl", "name": "Descending Splats", "author": "eiffie", "description": "Choose a few random splats and reposition them in front of the ray using gradient descent. The idea seems sound - the implementation not so much.", "tags": ["splats", "parametericsurface"], "likes": 16, "viewed": 1710, "published": "Public API", "date": "1424445730", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Descending Splats by eiffie\n\n//more splats will give better coverage near intersections\n#define SPLATS 10\n//more \"gradient descent\" steps fill in the surfaces\n#define DESCENT 10\n\n//total map calls = SPLATS x DESCENT x 3\n\n//if you want to watch the descent\n#define WATCH\n\nfloat SphereD(vec3 po, vec3 rd){\n\tfloat b=dot(po,rd);\n\treturn sqrt(abs(dot(po,po)-b*b));\n}\n\nvec3 sphere( in vec2 t )\n{\n     vec2 q = vec2( t.x*3.1416, acos(t.y) );\n     return vec3( cos(q.x)*sin(q.y), t.y, sin(q.x)*sin(q.y) );\n}\nvec3 cylinder( in vec2 t )\n{\n    float q = t.x*3.1416;\n    return vec3( 0.5*cos(q), t.y, 0.5*sin(q) );\n}\nvec3 quad( in vec2 t )\n{\n    return vec3( t.x, 0.0, t.y );\n}\n\nfloat DE(in vec2 t, in vec3 ro, in vec3 rd){\n\tvec3 s=sphere(t),c=cylinder(t)+vec3(2.0,0.0,0.0),q=2.0*quad(t)+vec3(0.75,-1.0,0.0);\n\treturn min(SphereD(s-ro,rd),min(SphereD(c-ro,rd),SphereD(q-ro,rd)));\n}\nvec2 rnd2(vec2 c){\n\treturn vec2(fract(sin(c.x+c.y+c.x*c.y)*415.231),fract(sin(c.x-c.y-c.x*c.x+c.y*c.y)*113.2537))*2.0-1.0;\n}\n\nmat3 lookat(vec3 fw){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,vec3(0.0,1.0,0.0)));return mat3(rt,cross(rt,fw),fw);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec3 ro=vec3(sin(iTime)*5.0,1.0+sin(iTime*0.7)*0.75,cos(iTime)*5.0);\n\tvec3 rd=lookat(vec3(1.0,0.0,0.0)-ro)*normalize(vec3((2.0*fragCoord.xy-iResolution.xy)/iResolution.y,2.0));\n\t//ro=eye;rd=normalize(dir);\n\tfloat d=100.0;\n  for(int j=0;j<SPLATS;j++){\n      float fj=float(j);\n\tvec2 t=rnd2(fragCoord.xy+vec2(fj,fj*3.1))*0.8,dt=rnd2(fragCoord.yx+vec2(fj*1.3,fj*5.1))*0.05,ff=vec2(0.43);\n#ifdef WATCH\n\tt=rnd2(vec2(fj,fj*3.1))*0.8;dt=rnd2(vec2(fj*1.3,fj*5.1))*0.05;ff=vec2(0.43);\n#endif\n\n\t/*float d1=DE(t,ro,rd),d2;\n\tfor(int i=0;i<DESCENT;i++){\n\t\tt.x+=dt.x;\n\t\tt.x=clamp(t.x,-1.0,1.0);\n\t\td2=DE(t,ro,rd);\n\t\td=min(d,d2);\n\t\tfloat g=clamp(dt.x/(d1-d2),-1.0,1.0);\n\t\tdt.x=ff.x*g*d2;\n\t\td1=d2;\n\t\tt.y+=dt.y;\n\t\tt.y=clamp(t.y,-1.0,1.0);\n\t\td2=DE(t,ro,rd);\n\t\td=min(d,d2);\n\t\tg=clamp(dt.y/(d1-d2),-1.0,1.0);\n\t\tdt.y=ff.y*g*d2;\n\t\td1=d2;\n\t}*/\n      for(int i=0;i<DESCENT;i++){//a more legit descent but uses more DE checks\n            float d1=DE(t,ro,rd);\n            d=min(d,d1);\n            vec2 d2=vec2(DE(t+vec2(dt.x,0.0),ro,rd),DE(t+vec2(0.0,dt.y),ro,rd));\n            dt=ff*log(d2+1.0)*clamp(dt/(vec2(d1)-d2),-1.0,1.0);\n            t=clamp(t+dt,-1.0,1.0);\n      }\n  }\n\td=smoothstep(0.0,0.1,d);\n\tvec3 col=vec3(sqrt(d),d*d,d);\n\tfragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlsGRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[273, 273, 305, 305, 363], [365, 365, 391, 391, 501], [502, 502, 530, 530, 606], [607, 607, 631, 631, 667], [669, 669, 713, 713, 870], [871, 871, 889, 889, 995], [997, 997, 1018, 1018, 1118], [1119, 1119, 1176, 1176, 2416]], "test": "valid"}
{"id": "MlsGRS", "name": "Cypher", "author": "dila", "description": "Fly through and watch blocks move. I wrote this listening to Tool: https://www.youtube.com/watch?v=in_Oyywwqa0 :)", "tags": ["block", "world", "ass"], "likes": 101, "viewed": 3721, "published": "Public", "date": "1423154212", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n\nmat3 xrot(float t)\n{\n    return mat3(1.0, 0.0, 0.0,\n                0.0, cos(t), -sin(t),\n                0.0, sin(t), cos(t));\n}\n\nmat3 yrot(float t)\n{\n    return mat3(cos(t), 0.0, -sin(t),\n                0.0, 1.0, 0.0,\n                sin(t), 0.0, cos(t));\n}\n\nmat3 zrot(float t)\n{\n    return mat3(cos(t), -sin(t), 0.0,\n                sin(t), cos(t), 0.0,\n                0.0, 0.0, 1.0);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat map(vec3 pos)\n{\n    float speed = 1.0;\n    vec3 grid = floor(pos);\n    vec3 gmod = mod(grid, 2.0);\n    vec3 rmod = mod(grid, 4.0) - 2.0;\n    float tm = fract(iTime * speed);\n    rmod *= (cos(tm*PI)-1.0);\n    \n    float g = floor(mod(iTime*speed,3.0));\n    if (g==2.0){\n        if (gmod.y*gmod.x==1.0) {\n            pos.z += rmod.y*rmod.x*0.5;\n        }\n    } else if (g==0.0){\n        if (gmod.y*gmod.z==1.0) {\n            pos.x += rmod.y*rmod.z*0.5;\n        }\n    } else if (g==1.0){\n        if (gmod.z*gmod.x==1.0) {\n            pos.y += rmod.z*rmod.x*0.5;\n        }\n    }\n        \n    grid = floor(pos);\n    pos = pos - grid;\n    pos = pos * 2.0 - 1.0;\n\n    float len = 0.9;\n\n    float d = sdBox(pos,vec3(len));\n\n    bool skip = false;\n\n    if (mod(grid.x,2.0)==0.0 && mod(grid.y,2.0)==0.0) {\n        skip = true;\n    }\n\n    if (mod(grid.x,2.0)==0.0 && mod(grid.z,2.0)==0.0) {\n        skip = true;\n    }\n\n    if (mod(grid.y,2.0)==0.0 && mod(grid.z,2.0)==0.0) {\n        skip = true;\n    }\n\n    if (skip) {\n        d = 100.0;\n        vec3 off = vec3(2.0,0.0,0.0);\n        for (int i = 0; i < 3; ++i) {\n            float a = sdBox(pos + off,vec3(len));\n            float b = sdBox(pos - off,vec3(len));\n            d = min(d,min(a,b));\n            off = off.zxy;\n        }\n        d *= 0.5;\n    } else {\n        d *= 0.8;   \n    }\n    \n    return d;\n}\n\nvec3 surfaceNormal(vec3 pos) {\n \tvec3 delta = vec3(0.01, 0.0, 0.0);\n    vec3 normal;\n    normal.x = map(pos + delta.xyz) - map(pos - delta.xyz);\n    normal.y = map(pos + delta.yxz) - map(pos - delta.yxz);\n    normal.z = map(pos + delta.zyx) - map(pos - delta.zyx);\n    return normalize(normal);\n}\n\nfloat aoc(vec3 origin, vec3 ray)\n{\n    float delta = 0.05;\n    const int samples = 8;\n    float r = 0.0;\n    for (int i = 1; i <= samples; ++i) {\n        float t = delta * float(i);\n     \tvec3 pos = origin + ray * t;\n        float dist = map(pos);\n        float len = abs(t - dist);\n        r += len * pow(2.0, -float(i));\n    }\n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n\tvec3 eye = normalize(vec3(uv, 1.0 - dot(uv,uv) * 0.33));\n    vec3 origin = vec3(0.0);\n    \n    eye = eye * yrot(iTime) * xrot(iTime);\n    \n    float speed = 0.5;\n    \n    float j = iTime * speed;\n    \n    float f = fract(j);\n    float g = 1.0 - f;\n    f = f*f * g + (1.0-g*g) * f;\n    f = f * 2.0 - 1.0;\n\tfloat a = floor(j) + f * floor(mod(j,2.0));\n    float b = floor(j) + f * floor(mod(j+1.0,2.0));\n    \n    origin.x += 0.5 + a;\n    origin.y += 0.5;\n    origin.z += -0.5 + b;\n    \n    float t = 0.0;\n    float d = 0.0;\n    \n    for (int i = 0; i < 32; ++i){\n        vec3 pos = origin + eye * t;\n        d = map(pos);\n        t += d;\n    }\n    \n    vec3 worldPos = origin + eye * t;\n    \n    vec3 norm = surfaceNormal(worldPos);\n    \n    float prod = max(0.0, dot(norm, -eye));\n    \n    float amb = 0.0;//aoc(worldPos, -eye);\n    \n    vec3 ref = reflect(eye, norm);\n    \n    vec3 spec = vec3(0.0);//texture(iChannel0, ref).xyz;\n    \n    prod = pow(1.0 - prod, 2.0);\n    \n    vec3 col = vec3(0.1, 0.3, 0.5);\n    \n    spec *= col;\n    \n    col = mix(col, spec, prod);\n    \n    float shade = pow(max(1.0 - amb, 0.0), 4.0);\n    \n    float fog = 1.0 / (1.0 + t * t * 0.2) * shade;\n    \n    vec3 final = col;\n    \n    final = mix(final, vec3(1.0), fog);\n    \n    fog = 1.0 / (1.0 + t * t * 0.1);\n    \n\tfragColor = vec4(final*fog,0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlsGRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 40, 40, 149], [151, 151, 171, 171, 280], [282, 282, 302, 302, 411], [413, 413, 444, 444, 540], [542, 542, 563, 563, 1899], [1901, 1901, 1931, 1931, 2197], [2199, 2199, 2233, 2233, 2543], [2545, 2545, 2602, 2602, 4050]], "test": "valid"}
{"id": "MlX3RB", "name": "Latt1c3", "author": "dila", "description": "Inspired by puls 256b.", "tags": ["grid", "lattice", "instances"], "likes": 13, "viewed": 324, "published": "Public", "date": "1422904862", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n\nmat3 xrot(float t)\n{\n    return mat3(1.0, 0.0, 0.0,\n                0.0, cos(t), -sin(t),\n                0.0, sin(t), cos(t));\n}\n\nmat3 yrot(float t)\n{\n    return mat3(cos(t), 0.0, -sin(t),\n                0.0, 1.0, 0.0,\n                sin(t), 0.0, cos(t));\n}\n\nmat3 zrot(float t)\n{\n    return mat3(cos(t), -sin(t), 0.0,\n                sin(t), cos(t), 0.0,\n                0.0, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv = uv * 2.0 - 1.0;\n    \n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 eye = normalize(vec3(uv,1.0-dot(uv,uv)*0.5));\n    \n    float t=0.0;\n    float d = 0.0;\n    vec3 col;\n    \n    for(int i = 0; i < 16; ++i){\n        vec3 pos = eye*t;\n        \n        pos = pos * xrot(-PI/4.0) * yrot(-PI/4.0);\n        \n        float theta = iTime;\n        pos = pos * xrot(theta) * yrot(theta) * zrot(theta);\n        \n        pos.z += iTime;\n        pos.y += 0.25 + iTime;\n       \tpos.x += 0.5 + iTime;\n        \n        vec3 coord = floor(pos);\n       \tpos = (pos - coord) - 0.5;\n        \n        d = length(pos)-0.2;\n        float idx = dot(coord,vec3(1.0));\n        idx = floor(fract(idx/3.0)*3.0);\n        if(idx==0.0){\n            col = vec3(1.0, 0.0, 0.0);\n        }else if(idx==1.0){\n            col = vec3(0.0, 1.0, 0.0);\n        }else if(idx==2.0){\n            col = vec3(0.0, 0.0, 1.0);\n        }\n        \n        float k;\n        \n        k = length(pos.xy)-0.05;\n        if(k<d){\n        \td=k;\n            col=vec3(1.0,1.0,1.0);\n        }\n        \n        k = length(pos.xz)-0.05;\n        if(k<d){\n        \td=k;\n            col=vec3(1.0,1.0,1.0);\n        }\n        \n        k = length(pos.yz)-0.05;\n        if(k<d){\n        \td=k;\n            col=vec3(1.0,1.0,1.0);\n        }\n        \n        t+=d;\n    }\n    \n    float fog = 1.0 / (1.0 + t*t*0.5 + d*100.0);\n    \n\tfragColor = vec4(fog*col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlX3RB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 40, 40, 149], [151, 151, 171, 171, 280], [282, 282, 302, 302, 411], [413, 413, 470, 470, 1928]], "test": "valid"}
{"id": "MlX3Rf", "name": "Biplanes in the Badlands", "author": "dr2", "description": "More aviation adventures.", "tags": ["raymarching", "terrain", "aircraft", "flight"], "likes": 12, "viewed": 908, "published": "Public API", "date": "1423765942", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Biplanes in the Badlands\" by dr2 - 2015\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  const vec3 cHashVA3 = vec3 (37.1, 61.7, 12.4);\n  const vec3 e = vec3 (1., 0., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Noisefv3a (vec3 p)\n{\n  vec3 i, f;\n  i = floor (p);  f = fract (p);\n  f *= f * (3. - 2. * f);\n  vec4 t1 = Hashv4v3 (i);\n  vec4 t2 = Hashv4v3 (i + vec3 (0., 0., 1.));\n  return mix (mix (mix (t1.x, t1.y, f.x), mix (t1.z, t1.w, f.x), f.y),\n              mix (mix (t2.x, t2.y, f.x), mix (t2.z, t2.w, f.x), f.y), f.z);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  const mat3 mr = mat3 (0., 0.8, 0.6, -0.8, 0.36, -0.48, -0.6, -0.48, 0.64);\n  float f, a, am, ap;\n  f = 0.;  a = 0.5;\n  am = 0.5;  ap = 4.;\n  p *= 0.5;\n  for (int i = 0; i < 6; i ++) {\n    f += a * Noisefv3a (p);\n    p *= mr * ap;  a *= am;\n  }\n  return f;\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s = vec3 (0.);\n  float a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 e = vec3 (0.2, 0., 0.);\n  float s = Fbmn (p, n);\n  vec3 g = vec3 (Fbmn (p + e.xyy, n) - s,\n     Fbmn (p + e.yxy, n) - s, Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nfloat SmoothStep5 (float xLo, float xHi, float x)\n{\n  x = clamp ((x - xLo) / (xHi - xLo), 0., 1.);\n  return x * x * x * (x * (6. * x - 15.) + 10.);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h)\n{\n  return max (length (p.xy - vec2 (rhi *\n     clamp (p.x / rhi, -1., 1.), 0.)) - rlo, abs (p.z) - h);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r) {\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nint idObj, idObjGrp;\nmat3 flyerMat[3], flMat;\nvec3 flyerPos[3], flPos, qHit, qHitTransObj, sunDir;\nfloat tCur, flyVel;\nfloat fusLen, wSpan;\nconst float dstFar = 150.;\nconst float pi = 3.14159;\nconst int idFus = 11, idPipe = 12, idWing = 13, idStrut = 14,\n   idHstab = 15, idFin = 16, idLeg = 17, idAxl = 18, idWhl = 19,\n   idNose = 20, idCkpit = 21, idPlt = 22;\n\nvec3 SkyBg (vec3 rd)\n{\n  return mix (vec3 (0.1, 0.1, 0.7), vec3 (0.4, 0.4, 0.7),\n     1. - max (rd.y, 0.));\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 p, q, cSun, clCol, col;\n  float fCloud, cloudLo, cloudRngI, atFac, colSum, attSum, s,\n     att, a, dDotS, ds;\n  const int nLay = 30;\n  cloudLo = 100.;  cloudRngI = 1./100.;  atFac = 0.045;\n  fCloud = 0.5;\n  if (rd.y > 0.) {\n    fCloud = clamp (fCloud, 0., 1.);\n    dDotS = max (dot (rd, sunDir), 0.);\n    ro.x += 2.5 * tCur;\n    p = ro;\n    p.xz += (cloudLo - p.y) * rd.xz / rd.y;\n    p.y = cloudLo;\n    ds = 1. / (cloudRngI * rd.y * (2. - rd.y) * float (nLay));\n    colSum = 0.;  attSum = 0.;\n    s = 0.;  att = 0.;\n    for (int j = 0; j < nLay; j ++) {\n      q = p + rd * s;\n      q.z *= 0.7;\n      att += atFac * max (fCloud - Fbm3 (0.02 * q), 0.);\n      a = (1. - attSum) * att;\n      colSum += a * (q.y - cloudLo) * cloudRngI;\n      attSum += a;  s += ds;\n      if (attSum >= 1.) break;\n    }\n    colSum += 0.5 * min ((1. - attSum) * pow (dDotS, 3.), 1.);\n    clCol = vec3 (1.) * 2.8 * (colSum + 0.05);\n    cSun = vec3 (1.) * clamp ((min (pow (dDotS, 1500.) * 2., 1.) +\n       min (pow (dDotS, 10.) * 0.75, 1.)), 0., 1.);\n    col = clamp (mix (SkyBg (rd) + cSun, clCol, attSum), 0., 1.);\n    col = mix (col, SkyBg (rd), pow (1. - rd.y, 16.));\n  } else col = SkyBg (- rd);\n  return col;\n}\n\nvec3 TrackPath (float z)\n{\n  return vec3 (30. * sin (0.035 * z) * sin (0.012 * z) * cos (0.01 * z) +\n     26. * sin (0.0032 * z),\n     5. + 1.5 * SmoothBump (55., 105., 20., mod (z, 140.)), z);\n}\n\nfloat GrndHt (vec2 p)\n{\n  const mat2 qRot = mat2 (0.8, -0.6, 0.6, 0.8);\n  vec2 q;\n  float s, a, w;\n  q = 0.1 * p;\n  s = 0.;\n  for (int i = 0; i < 3; i ++) {\n    s += Noisefv2 (q);\n    q *= 2. * qRot;\n  }\n  s = 10. * (clamp (0.33 * s, 0., 1.) - 0.55);\n  w = clamp (0.5 * abs (p.x - TrackPath (p.y).x) - 1.2, 0., 1.);\n  s = 4. * SmoothStep5 (0., 1., SmoothMin (s, 1.5 * w * w, 0.5));\n  q = 0.04 * p * qRot;\n  a = 1.;\n  for (int i = 0; i < 7; i ++) {\n    s += a * Noisefv2 (q);\n    a *= 0.7;\n    q *= 2. * qRot;\n  }\n  return s;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = 0; j < 180; j ++) {\n    p = ro + s * rd;\n    h = p.y - GrndHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += 0.2 * h + 0.007 * s;\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = 0; j < 7; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      h = step (0., p.y - GrndHt (p.xz));\n      sLo += h * (s - sLo);\n      sHi += (1. - h) * (s - sHi);\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p, float d)\n{\n  vec2 e;\n  float ht;\n  ht = GrndHt (p.xz);\n  e = vec2 (max (0.01, 0.00001 * d * d), 0.);\n  return normalize (vec3 (ht - GrndHt (p.xz + e.xy), e.x,\n     ht - GrndHt (p.xz + e.yx)));\n}\n\nfloat GrndSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.4;\n  for (int i = 0; i < 20; i ++) {\n    p = ro + rd * d;\n    h = p.y - GrndHt (p.xz);\n    sh = min (sh, 20. * h / d);\n    d += 0.4;\n    if (h < 0.001) break;\n  }\n  return clamp (sh, 0., 1.);\n}\n\nvec3 GrndCol (vec3 p, vec3 n)\n{\n  vec3 q;\n  float f;\n  const vec3 wCol1 = vec3 (0.6, 0.3, 0.2), wCol2 = vec3 (0.35, 0.3, 0.4),\n     tCol1 = vec3 (0.4, 0.4, 0.2), tCol2 = vec3 (0., 0.6, 0.),\n     bCol1 = vec3 (0.5, 0.4, 0.2), bCol2 = vec3 (0.6, 0.3, 0.3);\n  vec3 col, vCol, hCol;\n  q = 2.2 * p;\n  vCol = mix (wCol1, wCol2, clamp (1.4 * (Noisefv2 (q.xy +\n     vec2 (0., 0.3 * sin (0.14 * q.z)) *\n     vec2 (2., 7.3)) + Noisefv2 (q.zy * vec2 (3., 6.3))) - 1., 0., 1.));\n  f = clamp (0.7 * Noisefv2 (q.xz) - 0.3, 0., 1.);\n  if (p.y > 3.5) hCol = mix (tCol1, tCol2, f);\n  else hCol = mix (bCol1, bCol2, f);\n  col = 1.4 * mix (vCol, hCol, smoothstep (0.4, 0.7, n.y));\n  return col;\n}\n\nfloat PropelDf (vec3 p, float dHit)\n{\n  vec3 q;\n  float d;\n  q = p - fusLen * vec3 (0., 0.02, 1.07);\n  d = PrCylDf (q, 0.3 * fusLen, 0.007 * fusLen);\n  if (d < dHit) {\n    dHit = d;\n    qHitTransObj = q;\n  }\n  return dHit;\n}\n\nfloat TransObjDf (vec3 p)\n{\n  float dHit;\n  dHit = dstFar;\n  dHit = PropelDf (flyerMat[0] * (p - flyerPos[0]), dHit);\n  dHit = PropelDf (flyerMat[1] * (p - flyerPos[1]), dHit);\n  dHit = PropelDf (flyerMat[2] * (p - flyerPos[2]), dHit);\n  return dHit;\n}\n\nfloat TransObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = TransObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nfloat FlyerDf (vec3 p, float dHit)\n{\n  vec3 q, qq;\n  float d, wr;\n  q = p;\n  wr = -0.2 + q.z / fusLen;\n  d = PrRoundBoxDf (q, vec3 (0.07 * (1. - 0.8 * wr * wr),\n     0.11 * (1. - 0.6 * wr * wr), 1.) * fusLen, 0.05 * fusLen);\n  q -= vec3 (0., 0.1, 0.3) * fusLen;\n  d = max (d, - PrRoundBoxDf (q, vec3 (0.05, 0.1, 0.15) * fusLen,\n     0.03 * fusLen)); \n  if (d < dHit) { dHit = min (dHit, d);  idObj = idObjGrp + idFus;  qHit = q; }\n  q = p;  q -= vec3 (0., 0.08, 0.3) * fusLen;\n  d = PrRoundBoxDf (q, vec3 (0.05, 0.02, 0.15) * fusLen, 0.03 * fusLen); \n  if (d < dHit) { dHit = min (dHit, d);  idObj = idObjGrp + idCkpit;  qHit = q; }\n  q = p;  q.z = abs (q.z - 0.33 * fusLen) - 0.08 * fusLen;\n  q -= vec3 (0., 0.17, 0.) * fusLen;\n  d = PrSphDf (q, 0.04 * fusLen); \n  if (d < dHit) { dHit = min (dHit, d);  idObj = idObjGrp + idPlt;  qHit = q; }\n  q = p - fusLen * vec3 (0., 0.03, 0.8);\n  q.x = abs (q.x) - 0.1 * fusLen;\n  d = PrCapsDf (q, 0.02 * fusLen, 0.15 * fusLen);\n  if (d < dHit) { dHit = min (dHit, d);  idObj = idObjGrp + idPipe;  qHit = q; }\n  q = p - fusLen * vec3 (0., 0.03, 1.05);\n  d = PrCapsDf (q, 0.05 * fusLen, 0.02 * fusLen);\n  if (d < dHit) { dHit = d;  idObj = idObjGrp + idNose;  qHit = q; }\n  q = p - fusLen * vec3 (0., 0.09, 0.2);\n  qq = q;  qq.y = abs (qq.y) - 0.21 * fusLen;\n  wr = q.x / wSpan;\n  d = PrFlatCylDf (qq.zyx, 0.24 * (1. - 0.2 * wr * wr) * fusLen,\n     0.01 * (1. - 0.8 * wr * wr) * fusLen, wSpan);\n  if (d < dHit) { dHit = min (dHit, d);  idObj = idObjGrp + idWing;  qHit = q; }\n  q = p - fusLen * vec3 (0., 0.09, 0.25);\n  q.xz = abs (q.xz) - fusLen * vec2 (0.5, 0.1);\n  d = PrCylDf (q.xzy, 0.01 * fusLen, 0.21 * fusLen);\n  if (d < dHit) { dHit = min (dHit, d);  idObj = idObjGrp + idStrut;  qHit = q; }\n  q = p - fusLen * vec3 (0., 0.15, 0.25);\n  q.x = abs (q.x) - 0.1 * fusLen;\n  d = PrCylDf (q.xzy, 0.01 * fusLen, 0.15 * fusLen);\n  if (d < dHit) { dHit = min (dHit, d);  idObj = idObjGrp + idStrut;  qHit = q; }\n  float tSpan = 0.35 * wSpan;\n  q = p - fusLen * vec3 (0., 0., - 0.9);\n  wr = q.x / tSpan;\n  d = PrFlatCylDf (q.zyx, 0.15 * (1. - 0.25 * wr * wr) * fusLen,\n     0.007 * (1. - 0.2 * wr * wr) * fusLen, tSpan);\n  q.x = abs (q.x);\n  d = max (d, 0.02 * fusLen - 1.5 * q.x - q.z);\n  if (d < dHit) { dHit = min (dHit, d);  idObj = idObjGrp + idHstab;  qHit = q; }\n  float fSpan = 0.32 * wSpan;\n  q = p - fusLen * vec3 (0., 0., - 0.87);\n  q.yz = Rot2D (q.yz, 0.15);\n  wr = q.y / fSpan;\n  d = PrFlatCylDf (q.zxy, 0.15 * (1. - 0.3 * wr * wr) * fusLen,\n     0.007 * (1. - 0.3 * wr * wr) * fusLen, fSpan);\n  d = max (d, - q.y);\n  if (d < dHit) { dHit = min (dHit, d);  idObj = idObjGrp + idFin;  qHit = q; }\n  q = p - fusLen * vec3 (0., -0.25, 0.5);\n  q.x = abs (q.x) - 0.14 * fusLen;\n  q.xy = Rot2D (q.xy, -0.55);  q.yz = Rot2D (q.yz, 0.15);\n  d = PrCylDf (q.xzy, 0.013 * fusLen, 0.12 * fusLen);\n  if (d < dHit) { dHit = d;  idObj = idObjGrp + idLeg;  qHit = q; }\n  q = p - fusLen * vec3 (0., -0.34, 0.515);\n  q.x = abs (q.x) - 0.22 * fusLen;\n  d = PrCylDf (q.yzx, 0.01 * fusLen, 0.035 * fusLen);\n  if (d < dHit) { dHit = d;  idObj = idObjGrp + idAxl;  qHit = q; }\n  q.x -= 0.01 * fusLen;\n  d = PrCylDf (q.yzx, 0.1 * fusLen, 0.015 * fusLen);\n  if (d < dHit) { dHit = d;  idObj = idObjGrp + idWhl;  qHit = q; }\n  return dHit;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dHit;\n  dHit = dstFar;\n  idObjGrp = 1 * 256;\n  dHit = FlyerDf (flyerMat[0] * (p - flyerPos[0]), dHit);\n  idObjGrp = 2 * 256;\n  dHit = FlyerDf (flyerMat[1] * (p - flyerPos[1]), dHit);\n  dHit = FlyerDf (flyerMat[2] * (p - flyerPos[2]), dHit);\n  return 0.9 * dHit;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * vec3 (v.y, v.z, v.w));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02 * fusLen;\n  for (int i = 0; i < 50; i++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, 20. * h / d);\n    d += 0.02 * fusLen;\n    if (h < 0.001) break;\n  }\n  return clamp (sh, 0., 1.);\n}\n\nvec4 FlyerCol (vec3 n)\n{\n  vec3 col, qqHit, nn;\n  float spec, b;\n  int ig, id;\n  spec = 0.2;\n  qqHit = qHit / fusLen;\n  ig = idObj / 256;  id = idObj - 256 * ig;\n  col = (ig == 2) ? vec3 (0., 0.9, 0.1) : vec3 (0.9, 0., 0.1);\n  if (ig == 1) nn = flyerMat[0] * n;\n  else if (ig == 2) nn = flyerMat[1] * n;\n  else nn = flyerMat[2] * n;\n  if (id == idFus) {\n    qqHit.yz -= vec2 (-0.1, -0.7);\n    col *= (1. - 0.5 * SmoothBump (0.06, 0.09, 0.01, length (qqHit.yz))) *\n       (1. - 0.5 * SmoothBump (-0.01, 0.03, 0.01, length (qqHit.yz)));\n    if (nn.z > 0.9 && qqHit.y < -0.03) col *= 0.3;\n  } else if (id == idWing) {\n    b = wSpan / (8. * fusLen);\n    b = mod (qqHit.x + 0.5 * b, b) - 0.5 * b;\n    col *= 1. + 0.1 * SmoothBump (-0.01, 0.01, 0.002, b);\n    if (qqHit.y * nn.y > 0.) {\n      qqHit.x = abs (qqHit.x) - 0.8;\n      qqHit.z -= 0.03;\n      col *= (1. - 0.5 * SmoothBump (0.08, 0.12, 0.01, length (qqHit.xz))) *\n         (1. - 0.5 * SmoothBump (-0.01, 0.03, 0.01, length (qqHit.xz)));\n    }\n  } else if (id == idFin || id == idHstab) {\n    col *= 1. - 0.6 * SmoothBump (-0.062, -0.052, 0.002, qqHit.z);\n  } else if (id == idPipe || id == idNose) {\n    col = vec3 (0.8, 0.8, 0.);\n    spec = 0.4;\n  } else if (id == idStrut || id == idLeg) {\n    col = 0.6 * col + vec3 (0.4);\n  } else if (id == idAxl) {\n    col = vec3 (0.3, 0.2, 0.);\n  } else if (id == idCkpit) {\n    col = vec3 (0.2, 0.15, 0.05);\n  } else if (id == idPlt) {\n    col = vec3 (0.1, 0.07, 0.);\n    if (nn.z > 0.7) {\n      col *= 2.;\n      qqHit.x = abs (qqHit.x) - 0.015 * fusLen;\n      col *= (1. - 0.9 * SmoothBump (0.003, 0.01, 0.001, length (qqHit.xy)));\n    }\n  } else if (id == idWhl) {\n    if (length (qqHit.yz) < 0.07) col = vec3 (0.4, 0.4, 0.4);\n    else {\n      col = vec3 (0.02);\n      spec = 0.;\n    }\n  }\n  return vec4 (col, spec);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, c1, c2, vn;\n  float dstObj, dstGrnd, dstPropel, f, dif, sh, bk;\n  int idObjT;\n  dstGrnd = GrndRay (ro, rd);\n  dstPropel = TransObjRay (ro, rd);\n  idObj = -1;\n  dstObj = ObjRay (ro, rd);\n  if (idObj < 0) dstObj = dstFar;\n  if (min (dstObj, dstGrnd) < dstPropel) dstPropel = dstFar;\n  if (dstObj < dstGrnd) {\n    ro += dstObj * rd;\n    idObjT = idObj;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    col4 = FlyerCol (flyerMat[0] * vn); // [0]!\n    if (idObj == 256 + idWing || idObj == 256 + idHstab) {\n      vn.yz = Rot2D (vn.yz, -0.6 * qHit.z / fusLen);\n      vn = VaryNf (100. * ro, vn, 0.05);\n    } else if (idObj == 256 + idFin) {\n      vn.xz = Rot2D (vn.xz, -0.6 * qHit.z / fusLen);\n    }\n    dif = max (dot (vn, sunDir), 0.);\n    sh = ObjSShadow (ro, sunDir);\n    bk = max (dot (vn.xz, - normalize (sunDir.xz)), 0.);\n    col = col4.rgb * (0.2 + 0.2 * bk + 0.6 * sh * max (0., dif)) +\n       sh * col4.a * pow (max (0., dot (sunDir, reflect (rd, vn))), 128.);\n    col = sqrt (clamp (col, 0., 1.));\n  } else if (dstGrnd < dstFar) {\n    ro += dstGrnd * rd;\n    vn = VaryNf (3.2 * ro, GrndNf (ro, dstGrnd), 1.5);\n    col = GrndCol (ro, vn);\n    sh = GrndSShadow (ro, sunDir);\n    bk = max (dot (vn.xz, - normalize (sunDir.xz)), 0.);\n    col *= (0.7 + 0.3 * sh) * (0.2 + 0.4 * bk +\n       0.7 * max (0., max (dot (vn, sunDir), 0.)));\n    f = dstGrnd / dstFar;\n    f *= f;\n    col = mix (col, SkyBg (rd), clamp (f * f, 0., 1.));\n  } else col = SkyCol (ro, rd);\n  if (dstPropel < dstFar) col = vec3 (0.1) * (1. -\n     0.3 * SmoothBump (0.25, 0.27, 0.006,\n     length (qHitTransObj.xy) / fusLen)) + 0.7 * col;\n  return clamp (col, 0., 1.);\n}\n\nvoid FlyerPM (float t, float vu)\n{\n  vec3 fpF, fpB, vel, acc, va, ort, cr, sr;\n  float vy, dt, vDir, rlFac;\n  dt = 0.2;\n  flPos = TrackPath (t * flyVel);\n  if (vu >= 0.) vDir = 1.;\n  else vDir = -1.;\n  fpF = TrackPath ((t + vDir * dt) * flyVel);\n  fpB = TrackPath ((t - vDir * dt) * flyVel);\n  vel = (fpF - fpB) / (2. * dt);\n  vy = vel.y;\n  vel.y = 0.;\n  acc = (fpF - 2. * flPos + fpB) / (dt * dt);\n  acc.y = 0.;\n  va = cross (acc, vel) / length (vel);\n  vel.y = vy;\n  rlFac = (vu == 0.) ? 0.4 : 0.7;\n  ort = vec3 (0., atan (vel.z, vel.x) - 0.5 * pi,\n     rlFac * length (va) * sign (va.y));\n  cr = cos (ort);\n  sr = sin (ort);\n  flMat = mat3 (cr.z, - sr.z, 0., sr.z, cr.z, 0., 0., 0., 1.) *\n     mat3 (1., 0., 0., 0., cr.x, - sr.x, 0., sr.x, cr.x) *\n     mat3 (cr.y, 0., - sr.y, 0., 1., 0., sr.y, 0., cr.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n  vec2 uvs = uv;\n  uv.x *= iResolution.x / iResolution.y;\n  tCur = iTime;\n  mat3 vuMat;\n  vec3 ro, rd, col;\n  float tSep, t, fHlx, aHlx;\n  sunDir = normalize (vec3 (cos (0.03 * tCur), 1., sin (0.03 * tCur)));\n  fusLen = 0.5;\n  wSpan = 1.2 * fusLen;\n  flyVel = 5.;\n  aHlx = 2. * fusLen;\n  fHlx = 0.03 * flyVel;\n  FlyerPM (tCur, 0.);\n  ro = flPos;\n  vuMat = flMat;\n  ro.xy += 0.6 * aHlx * vec2 (cos (fHlx * tCur), sin (fHlx * tCur));\n  tSep = 80. * fusLen / flyVel;\n  t = ro.z / flyVel + (0.025 + 0.015 * sin (0.1 * tCur)) * tSep;\n  FlyerPM (t, 1.);\n  flyerPos[0] = flPos;\n  flyerMat[0] = flMat;\n  flyerPos[0].xy += aHlx * vec2 (cos (fHlx * t), sin (fHlx * t));\n  t = tSep * (1. + floor (ro.z / (tSep * flyVel))) - mod (tCur, tSep);\n  FlyerPM (t, -1.);\n  flyerPos[1] = flPos;\n  flyerMat[1] = flMat;\n  flyerPos[1].xy -= aHlx * vec2 (cos (fHlx * t), sin (fHlx * t));\n  t += tSep;\n  FlyerPM (t, -1.);\n  flyerPos[2] = flPos;\n  flyerMat[2] = flMat;\n  flyerPos[2].xy -= aHlx * vec2 (cos (fHlx * t), sin (fHlx * t));\n  rd = normalize (vec3 (uv, 2.2)) * vuMat;\n  col = ShowScene (ro, rd);\n  uvs *= uvs * uvs;\n  col = mix (vec3 (0.4), col,\n     pow (max (0., 0.95 - length (uvs * uvs * uvs)), 0.2));\n  fragColor = vec4 (col, 1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlX3Rf.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[253, 253, 277, 277, 324], [326, 326, 350, 350, 589], [591, 591, 616, 616, 795], [797, 797, 823, 823, 1117], [1119, 1119, 1140, 1140, 1400], [1402, 1402, 1431, 1431, 1633], [1635, 1635, 1674, 1674, 1881], [1883, 1883, 1934, 1934, 2032], [2034, 2034, 2079, 2079, 2177], [2179, 2179, 2236, 2236, 2319], [2321, 2321, 2351, 2351, 2425], [2427, 2427, 2460, 2460, 2487], [2489, 2489, 2532, 2532, 2605], [2607, 2607, 2649, 2649, 2700], [2702, 2702, 2761, 2761, 2865], [2867, 2867, 2913, 2913, 2960], [3325, 3325, 3347, 3347, 3434], [3436, 3436, 3468, 3468, 4668], [4670, 4670, 4696, 4696, 4865], [4867, 4867, 4890, 4890, 5393], [5395, 5395, 5429, 5429, 5954], [5956, 5956, 5987, 5987, 6171], [6173, 6173, 6211, 6211, 6452], [6454, 6454, 6485, 6485, 7131], [7133, 7133, 7170, 7170, 7357], [7359, 7359, 7386, 7386, 7611], [7613, 7613, 7651, 7651, 7832], [7834, 7834, 7870, 7870, 11100], [11102, 11102, 11124, 11124, 11396], [11398, 11398, 11431, 11431, 11607], [11609, 11609, 11630, 11630, 11853], [11855, 11855, 11892, 11892, 12121], [12123, 12123, 12147, 12147, 13938], [13940, 13940, 13975, 13975, 15636], [15638, 15638, 15672, 15672, 16448], [16450, 16450, 16507, 16507, 17781]], "test": "error"}
{"id": "MlX3Rj", "name": "SHADE A DAY ( 2 / 7 / 2015 )", "author": "cabbibo", "description": "geting some shading working", "tags": ["metaballs"], "likes": 8, "viewed": 543, "published": "Public", "date": "1423342165", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ALL TAKEN FROM IQs AMAZING SITE / TUTORIALS / SHADERS:\n// http://www.iquilezles.org/www/index.htm\n// https://www.shadertoy.com/user/iq\n\n// Specific shaders stolen from\n// ROT FUNCTIONS  : https://www.shadertoy.com/view/XsSSzG\n\n\nconst float MAX_TRACE_DISTANCE = 20.0;           // max trace distance\nconst float INTERSECTION_PRECISION = .01;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 80;\n\t\n\nconst float pi = 3.14159;\n\nvec4 spherePos[8];\nvec3 sphereRot[8];\n\n\nvec4 texCube( sampler2D sam, in vec3 p, in vec3 n, in float k )\n{\n\tvec4 x = texture( sam, p.yz *.4);\n\tvec4 y = texture( sam, p.zx *.4);\n\tvec4 z = texture( sam, p.xy *.4 );\n    vec3 w = pow( abs(n), vec3(k) );\n\treturn (x*w.x + y*w.y + z*w.z) / (w.x+w.y+w.z);\n}\n\n\n// ROTATION FUNCTIONS TAKEN FROM\n//https://www.shadertoy.com/view/XsSSzG\nmat3 xrotate(float t) {\n\treturn mat3(1.0, 0.0, 0.0,\n                0.0, cos(t), -sin(t),\n                0.0, sin(t), cos(t));\n}\n\nmat3 yrotate(float t) {\n\treturn mat3(cos(t), 0.0, -sin(t),\n                0.0, 1.0, 0.0,\n                sin(t), 0.0, cos(t));\n}\n\nmat3 zrotate(float t) {\n    return mat3(cos(t), -sin(t), 0.0,\n                sin(t), cos(t), 0.0,\n                0.0, 0.0, 1.0);\n}\n\n\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdPlane( vec3 p )\n{\n\n    //float f = fbm( p.xy );\n    //f *= fbm( p.yz );\n    //f = 5. * smoothstep( abs(f) , 0.4 , 0.8 );\n\treturn p.y;// + sin( p.x * 1. * p.z ) * .002; //- (f * .4); //(abs( f) * .3)/ max( 1. , pow( length( p ), 1.));\n\n}\n\n\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 0.3 + 10.0*mouseX;\n\tcamPos = vec3(3.5*sin(an),1.0,3.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n\n\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \n\treturn (d1.x<d2.x) ? d1 : d2;\n    \n}\n\n// exponential smooth min (k = 32);\nfloat smin( float a, float b, float k ){\n    \n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n    \n}\n\nfloat opBlend( vec2 d1, vec2 d2 ){\n\n    return smin( d1.x , d2.x , 8.);\n    \n}\n\n\nmat3 fullRotate( vec3 r ){\n \n   return xrotate( r.x ) * yrotate( r.y ) * zrotate( r.z );\n    \n}\n\nfloat rotatedBox( vec3 p , vec3 rot , vec3 size , float rad ){\n    \n    vec3 q = fullRotate( rot ) * p;\n    return udRoundBox( q , size , rad );\n    \n    \n}\n\n\nfloat rotatedPlane( vec3 p , vec3 rot ){\n    \n    vec3 q = fullRotate( rot ) * p;\n    return sdPlane( q );\n\n    \n}\n\n\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos ){  \n    \n   \t//vec2 res = vec2( sdPlane( pos - vec3( 0. , -1. , 0. )), 0.0 );\n    \n    vec2 res = vec2( rotatedPlane( pos - vec3( 0. , -2. , 0. ) , vec3(.9 , 0. , 0)) , 0.);\n    \n    res.x = opBlend( res , vec2( rotatedPlane( pos - vec3( 0. , -2. , 0. ) , vec3(-.7 , 0. , 0)) , 0.));\n    res.x = opBlend( res , vec2( rotatedPlane( pos - vec3( 0. , -2. , 0. ) , vec3(0. , 0. , 1.)) , 0.));\n    //vec2 res = vec2( sdSphere( pos , 8. ) , 0.); , 1.\n   \n    for( int i = 0; i < 8; i++ ){\n   \t\t\n\n        vec3 rot = sphereRot[i];\n        vec3 p = pos- spherePos[i].xyz;\n        vec3 s = vec3( spherePos[i].w , spherePos[i].w / 100. , spherePos[i].w / 100.);\n        float r = spherePos[i].w / 4.;\n        \n        float intersection = rotatedBox( p , rot , s , r );\n      \tvec2 res2 = vec2( intersection , float(i) + 1.);\n       \tres.x = opBlend( res ,  res2 );\n        \n   \t}\n    \n\n   \treturn res;\n    \n}\n\n\n// Calculates our intersection by stepping through the\n// map function, and returning both the object hit and the distance\n// it is hit at\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t );\n        h = m.x;\n        t += h;\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n}\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n    \n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<50; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 20.*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.612*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.5;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n\n    for( int i =0; i < 8; i++ ){\n        \n        float x = 1. * cos(iTime *.13 * (float( i )+2.));\n        float y = 1. * sin(iTime * .075 * (float( i )+4.));\n        float z = 1. * sin(iTime * .1 * (float( i )+3.3));\n        float r = .4 * ( sin( iTime * .1  *( float( i) +1.))+2.);\n        \n        spherePos[i] = vec4( x , y , z , r );\n        \n        \n        sphereRot[i] = vec3( \n            iTime  * (float(i)+2.) * .4 ,\n            iTime  * (float(i)+8.2) * .2 ,\n            iTime  * (float(i)+3.6) * .01\n        );\n\n    }\n\n    \n    \n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    //vec2 m = iMouse.xy/iResolution.xy;\n    vec2 m = vec2( 1.1 +( sin( iTime * 0.4 ) + sin( iTime * 0.01 )) * .04 , 0. );\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m.x );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,1.5 + abs(sin( iTime * .01 ) + sin( iTime * .0315 ))) ); // 2.0 is the lens length\n    \n    vec2 res = calcIntersection( ro , rd  );\n    \n    \n  //  vec3 pat = texCube( iChannel0, 0.5*pos, nor, 10.0 ).xyz;\n    vec3 col = vec3( .3 , 0.1 , .1 );//vec3( .8 , .8 , .8 ); \n   \n    //vec3 col = texCube( iChannel0, ro + rd * 1. , rd , 1.0 ).xyz;\n    // If we have hit something lets get real!\n    if( res.y > -.5 ){\n\n    \tvec3 pos = ro + rd * res.x;\n    \tvec3 nor = calcNormal( pos );\n        \n        float AO = calcAO( pos , normalize(nor) );\n        \n        float match = -dot( normalize(nor) , rd );\n        \n        vec3 pat = texCube( iChannel0, 0.5*pos, nor, 1.0 ).xyz;\n        col = pat*.2+.1;\n        \n\t\tvec3 light1 =  normalize(vec3( 0. , 1. , 1. ));\n        vec3 color1 = vec3( .1 , .02 , .02 );\n        color1 *=8.;\n        float shadow1 = softshadow( pos , light1 ,  0.1 , 20. );\n        \n        color1 *= max( 0. , dot( light1 , nor ) );\n        color1 *= shadow1;\n        col += color1;  \n        \n        vec3 light2 =  normalize(vec3( -1. , 1. , 0. ));\n        vec3 color2 = vec3( .1 , .05 , .02 );\n        color2 *=8.;\n        float shadow2 = softshadow( pos , light2 ,  0.1 , 20. );\n        \n        color2 *= max( 0. , dot( light2 , nor ) );\n        color2 *= shadow2;\n        col += color2;\n        //*(1.+ abs(sin( shadow1 * 3. ))) / 3.;\n\n\n        //vec3 col = vec3(.8 , 0. , 0. ) * match * AO;//(vec3( 1. , 0. , 0. ) * (vec3( fbm( vec2(match * 10. , AO * 10.) )))) * .5;\n\n        // rim lighting\n        col += pow((1.- match),3.) * vec3( 1. , 1. , 1.);\n        col *= AO * vec3( .8 , .8 , 1. );//pow((1.- AO) , 4.)* vec3( .2 , .1 , .6 );\n        //col *= pow\n        \n        //col += pat;// * .4 * ( nor * .5 + .5 );\n        \n       // col *= vec3( res.y );//vec3( 0. , 1. * sin( res.y *1000.+ 1. ) , 0.);\n       /* if( res.y < .5 ){\n            \n            float f = sin( pos.z * 5. ) * sin( pos.x * 5. );\n            //col *= 5. * smoothstep( abs(f) , 0.4 , 0.8 );\n            col *= abs( f );\n            col /= pow( length( pos ), 4.);\n        }*/\n    }\n    \n    // apply gamma correction\n    col = pow( col, vec3(0.4545) );\n\n    fragColor = vec4( col , 1. );\n    \n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlX3Rj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[489, 489, 554, 554, 748], [751, 824, 847, 847, 953], [955, 955, 978, 978, 1084], [1086, 1086, 1109, 1109, 1218], [1222, 1222, 1267, 1267, 1307], [1309, 1309, 1334, 1437, 1553], [1557, 1588, 1652, 1652, 1830], [1832, 1832, 1915, 1915, 2028], [2033, 2127, 2156, 2156, 2199], [2201, 2237, 2277, 2277, 2358], [2360, 2360, 2394, 2394, 2438], [2441, 2441, 2467, 2467, 2536], [2538, 2538, 2600, 2600, 2694], [2697, 2697, 2737, 2737, 2811], [2814, 2898, 2919, 2995, 3816], [3819, 3958, 4006, 4006, 4473], [4475, 4588, 4619, 4619, 4845], [4848, 4848, 4922, 4922, 5183], [5186, 5186, 5228, 5228, 5527]], "test": "error"}
{"id": "MlX3Rs", "name": "Wonders of Television", "author": "rotmoset", "description": "Adding noise, color filter, frame, scanline and multiple boxes for an old television feeling.", "tags": ["vfx"], "likes": 7, "viewed": 352, "published": "Public", "date": "1424286460", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nvec4 white = vec4(1.0,1.0,1.0,0.0);\nvec4 black = vec4(0.0,0.0,0.0,1.0);\n\nvec4 noise(vec4 c,vec2 px)\n{\n    vec2 uv = px / iResolution.xy;\n    \n    vec4 r = texture(iChannel0,uv+vec2(sin(iTime*10.0),sin(iTime*20.0)));\n    \n    c += r * 0.2; \n\n    return c;\n}\n\nvec4 colorFilter(vec4 c)\n{\n\tfloat g = (c.x + c.y + c.z) / 3.0;\n    c = vec4(g,g,g,1.0);\n    \n    c.x *= 0.3;\n    c.y *= 0.5;\n    c.z *= 0.7;\n    \n    return c;\n}\n\nvec4 frame(vec4 c,vec2 px)\n{\n    vec2 uv = px / iResolution.xy;\n\n    float d = 0.59;\n    float e = 3.8;\n    \n    c += 0.4*pow(distance(uv,vec2(0.5,0.5)) / d,e);\n    \n\treturn c;\n}\n\nvec4 scanline(vec4 c, vec2 px)\n{\n    vec2 uv = px / iResolution.xy;\n\t\n    float y = mod(-iTime / 10.0,1.1);\n    \n    float d = sqrt(abs(uv.y - y));\n    \n    float a = 1.0 - smoothstep(0.001,0.2,d);\n    \n    c = noise(noise(noise(white,px),px),px) * (a*0.5) + (c * (1.0-a));\n    \n    return c;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float aspect = iResolution.x / iResolution.y;\n    \n    float squares = pow((1.0 + float(int(mod(2.0+iTime / 3.5,5.0)))),2.0);\n    \n    vec4 c = black;\n    \n    float sw = sqrt(squares) / aspect;\n    float sh = sqrt(squares);\n    \n    \n    float b = float(int(mod(uv.y*sh,2.0)));\n    // a(0 || 1) selects square\n\tfloat a = float(int(mod(uv.x*sw * aspect + b,2.0)));\n    \n\t// Texture coordinates\n    float vx = mod(uv.x * sw * aspect, 1.0);\n    float vy = mod(uv.y * sh*-1.0, 1.0);\n    \n   \tc += texture(iChannel1,vec2(vx,vy)) * (1.0-a);\n    c += texture(iChannel2,vec2(vx,vy)) * a;\n    \n    \n    c = noise(c,fragCoord);\n    c = scanline(c,fragCoord);\n    c = colorFilter(c);\n    \n\tc = frame(c,fragCoord);\n    \n    c = clamp(black,c,white);\n    \n\tfragColor = c;\n}", "image_inputs": [{"id": "Xdf3Rn", "previewfilepath": "/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video"}, {"id": "4df3zn", "previewfilepath": "/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video"}, {"id": "4df3zn", "previewfilepath": "/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlX3Rs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 75, 103, 103, 258], [260, 260, 286, 286, 421], [423, 423, 451, 451, 601], [603, 603, 635, 635, 902], [904, 904, 961, 961, 1779]], "test": "error"}
{"id": "MlXGRX", "name": "Rotated rays", "author": "andreyu", "description": "Based on inigo quilez shader.", "tags": ["2d", "rays", "background"], "likes": 8, "viewed": 270, "published": "Public", "date": "1423684980", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// rotated rays background by Andrey A. Ugolnik\n// based on inigo quilez shader.\n// 2015\n\nfloat raysCount = 15.0;\nvec3 color0 = vec3(0.4, 0.5, 1.0);\nvec3 color1 = vec3(0.6, 0.7, 1.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//  float smoothness = 0.5;\n    float smoothness = (1.0 + sin(iTime * 2.0)) * 0.5;\n    \n\tvec2 p = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;\n\n    // background\n\tvec2 q = vec2(atan(p.y, p.x), length(p));\n\tfloat f = smoothstep(-smoothness, smoothness, sin(q.x * raysCount + iTime));\n\tvec3 col = mix(color0, color1, f);\n    fragColor = vec4(col, 1.0);\n\n    // mix with texture\n    //vec2 uv = fragCoord.xy / iResolution.xy;\n    //vec4 tc = texture(iChannel0, uv);\n    //fragColor = mix(tc, vec4(col, 1.0), 0.7);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlXGRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[185, 185, 242, 270, 766]], "test": "valid"}
{"id": "Mtf3z2", "name": "Mandel City", "author": "dr2", "description": "On a faraway island where the architects are mathematicians...", "tags": ["fractal", "dda", "architecture"], "likes": 14, "viewed": 921, "published": "Public API", "date": "1423325395", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Mandel City\" by dr2 - 2015\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Branch-free swizzled DDA (Bresenham's algorithm in 3d) suggested\n// by fb39ca4 and iq; architecture by BBM.\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec3 i = floor (p);\n  vec3 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  float q = dot (i, cHashA3);\n  vec4 t1 = Hashv4f (q);\n  vec4 t2 = Hashv4f (q + cHashA3.z);\n  return mix (mix (mix (t1.x, t1.y, f.x), mix (t1.z, t1.w, f.x), f.y),\n     mix (mix (t2.x, t2.y, f.x), mix (t2.z, t2.w, f.x), f.y), f.z);\n}\n\nfloat FbmS (vec2 p)\n{\n  float a = 1.;\n  float v = 0.;\n  for (int i = 0; i < 5; i ++) {\n    v += a * (sin (6. * Noisefv2 (p)) + 1.);\n    a *= 0.5;\n    p *= 2.;\n    p *= mat2 (0.8, -0.6, 0.6, 0.8);\n  }\n  return v;\n}\n\nfloat tCur;\nvec3 fcHit, gCel, sunDir, waterDisp, cloudDisp;\nconst float dstFar = 200.;\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col, skyCol, sunCol, p;\n  float ds, fd, att, attSum, d, dDotS;\n  p = ro + rd * (150. - ro.y) / rd.y;\n  ds = 0.1 * sqrt (distance (ro, p));\n  fd = 0.003 / (smoothstep (0., 10., ds) + 0.1);\n  p.xz *= fd;\n  p.xz += cloudDisp.xz;\n  att = FbmS (p.xz);\n  attSum = att;\n  d = fd;\n  ds *= fd;\n  for (int i = 0; i < 4; i ++) {\n    attSum += FbmS (p.xz + d * sunDir.xz);\n    d += ds;\n  }\n  attSum *= 0.27;\n  att *= 0.27;\n  dDotS = clamp (dot (sunDir, rd), 0., 1.);\n  skyCol = mix (vec3 (0.7, 1., 1.), vec3 (1., 0.4, 0.1), 0.25 + 0.75 * dDotS);\n  sunCol = vec3 (1., 0.8, 0.7) * pow (dDotS, 1024.) +\n     vec3 (1., 0.4, 0.2) * pow (dDotS, 256.);\n  col = mix (vec3 (0.5, 0.75, 1.), skyCol, exp (-2. * (3. - dDotS) *\n     max (rd.y - 0.1, 0.))) + sunCol;\n  attSum = 1. - smoothstep (1., 9., attSum);\n  col = mix (vec3 (0.4, 0., 0.2), mix (col, vec3 (0.2), att), attSum) +\n     vec3 (1., 0.4, 0.) * pow (attSum * att, 3.) * (pow (dDotS, 10.) + 0.5);\n  return col;\n}\n\nfloat WaterHt (vec3 p)\n{\n  p *= 0.05;\n  p += waterDisp;\n  float ht = 0.;\n  const float wb = 1.414;\n  float w = wb;\n  for (int j = 0; j < 7; j ++) {\n    w *= 0.5;\n    p = wb * vec3 (p.y + p.z, p.z - p.y, 2. * p.x) + 20. * waterDisp;\n    ht += w * abs (Noisefv3 (p) - 0.5);\n  }\n  return ht;\n}\n\nvec3 WaterNf (vec3 p, float d)\n{\n  vec2 e = vec2 (max (0.01, 0.001 * d * d), 0.);\n  float ht = WaterHt (p);\n  return normalize (vec3 (ht - WaterHt (p + e.xyy), e.x,\n     ht - WaterHt (p + e.yyx)));\n}\n\nfloat HtMand (vec3 p)\n{\n  vec3 q;\n  vec2 v, w;\n  float h;\n  h = 0.;\n  p.xz *= 0.03;\n  p.x -= 0.85;\n  q = 0.01 * floor (100. * p);\n  if (length (q.xz + vec2 (0.25, 0.)) > 0.45 &&\n     length (q.xz + vec2 (1., 0.)) > 0.2 &&\n     (q.x < 0. || abs (q.z) > 0.04)) {\n    v = q.xz;\n    h = 80.;\n    for (int j = 0; j < 80; j ++) {\n      w = v * v;\n      if (w.x + w.y > 4.) {\n        h = float (j + 1);\n        break;\n      } else v = q.xz + vec2 (w.x - w.y, 2. * v.x * v.y);\n    }\n  }\n  return step (0.3 * h, q.y);\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 gDir, gv, s, cp, rdi;\n  float dHit;\n  bool hit;\n  gCel = floor (ro);\n  gDir = sign (rd);\n  gv = max (gDir, 0.) - ro;\n  rdi = 1. / rd;\n  for (int i = 0; i < 300; i ++) {\n    s = (gCel + gv) * rdi;\n    cp = step (s, s.yzx);\n    fcHit = cp * (1. - cp.zxy);\n    gCel += gDir * fcHit;\n    hit = (HtMand (gCel) == 0.);\n    if (hit) break;\n  }\n  dHit = hit ? dot ((gCel + gv - gDir) * rdi, fcHit) : dstFar;\n  if (length ((ro + rd * dHit).xz - vec2 (8., 0.)) > 50.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  vec2 fp;\n  float dstHit, fcFac, dw;\n  sunDir = normalize (vec3 (0., 0.05, 1.));\n  cloudDisp = -0.05 * tCur * vec3 (1., 0., 1.);\n  waterDisp = -0.005 * tCur * vec3 (-1., 0., 1.);\n  dstHit = ObjRay (ro, rd);\n  if (rd.y < 0. && dstHit >= dstFar) {\n    dw = - (ro.y - 1.) / rd.y;\n    ro += dw * rd;\n    rd = reflect (rd, WaterNf (ro, dw));\n    ro += 0.01 * rd;\n    dstHit = ObjRay (ro, rd);\n  }\n  if (dstHit < dstFar) {\n    ro += rd * dstHit;\n    vn = - fcHit * sign (rd);\n    if (fcHit.y == 0. && gCel.y > 1.) {\n      fp = fract ((fcHit.x != 0.) ? ro.yz : ro.yx);\n      fcFac = 1. - pow (2. * max (abs (fp.x - 0.5), abs (fp.y - 0.5)), 4.);\n      rd = reflect (rd, vn);\n      if (Noisefv3 (2. * gCel + 1. + \n         cos (tCur * vec3 (0.71, 0.87, 1.01))) < 0.5)\n         col = SkyCol (ro, rd);\n      else col = 1.3 * vec3 (0.9, 0.6, 0.);\n      col *= fcFac;\n    } else {\n      if (gCel.y == 0.) col = vec3 (0.05, 0.3, 0.) *\n         (0.7 + 0.3 * Noisefv2 (5. * ro.xz));\n      else if (fcHit.y == 0.) col = vec3 (0.3, 0.2, 0.);\n      else col = vec3 (0.5, 0.4, 0.2) * clamp (0.2 * gCel.y, 0., 1.);\n      col *= (0.3 + 0.7 * max (0., dot (sunDir, vn)));\n    }\n  } else col = SkyCol (ro, rd);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n  uv.x *= iResolution.x / iResolution.y;\n  tCur = iTime;\n  mat3 vuMat;\n  vec3 ro, rd;\n  vec2 vEl, vAz;\n  float az, el;\n  az = -0.5 + 0.05 * tCur;\n  el = 0.34;\n  vEl = vec2 (cos (el), sin (el));\n  vAz = vec2 (cos (az), sin (az));\n  vuMat = mat3 (1., 0., 0., 0., vEl.x, - vEl.y, 0., vEl.y, vEl.x) *\n     mat3 (vAz.x, 0., vAz.y, 0., 1., 0., - vAz.y, 0., vAz.x);\n  rd = normalize (vec3 (uv, 3.)) * vuMat;\n  ro = vec3 (0., 0., -120.) * vuMat;\n  ro.xy += vec2 (8., 5.);\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mtf3z2.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[352, 352, 376, 376, 423], [425, 425, 450, 450, 629], [631, 631, 656, 656, 962], [964, 964, 985, 985, 1177], [1267, 1267, 1299, 1299, 2257], [2259, 2259, 2283, 2283, 2549], [2551, 2551, 2583, 2583, 2750], [2752, 2752, 2775, 2775, 3262], [3264, 3264, 3297, 3297, 3794], [3796, 3796, 3831, 3831, 5051], [5053, 5053, 5110, 5110, 5674]], "test": "valid"}
{"id": "MtfGRs", "name": "Scatter", "author": "gaz", "description": "3d", "tags": ["raymarching", "folding"], "likes": 21, "viewed": 1068, "published": "Public", "date": "1424273250", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI\t3.14159265359\n#define PI2\t( PI * 2.0 )\n\nbool Flag = false;\nint M;\n\nmat2 rotate(float a)\n{\n\treturn mat2(cos(a), sin(a), -sin(a), cos(a));\t\n}\n\nvec3 hsv(float h, float s, float v)\n{\n  return mix( vec3( 1.0 ), clamp( ( abs( fract(\n    h + vec3( 3.0, 2.0, 1.0 ) / 3.0 ) * 6.0 - 3.0 ) - 1.0 ), 0.0, 1.0 ), s ) * v;\n}\n\nfloat map1(in vec3 p)\n{     \n    p.yz *= rotate(iTime * -0.543);\n    p.zx *= rotate(iTime * 0.876);\n    // folding -- https://www.shadertoy.com/view/XlX3zB\n    float cospin = cos(PI / 5.0), scospin = sqrt(0.75 - cospin * cospin);\n    vec3 nc = vec3(-0.5, -cospin ,scospin);\n    for(int i = 0; i < 5; i++)\n    {\n\t\tp.xy = abs(p.xy);\n\t\tp -= 2.0 * min(0.0, dot(p, nc)) * nc;\n\t}\n    float time = mod(iTime, 12.0);\n    p.z -=  0.4;\n    p.z -=  6.0 * smoothstep(1.0,  3.0, time);\n    p.z -= -5.7 * smoothstep(6.0,  9.0, time);\n    p.z -= -0.3 * smoothstep(10.0, 12.0, time);\n    return abs(p.x) +abs(p.y) + abs(p.z)-0.25;\n}\n\nfloat map2(in vec3 p)\n{     \n    p.xz = vec2(length(p) - 1.7, sin(atan(p.z, p.x) * 2.5) * 0.6);\n    return length(p) - 0.08;\n }\n\nfloat map3(in vec3 p)\n{     \n    vec3 q = p;\n\tp.xz = vec2(length(p) - 1.7, sin(atan(p.z, p.x) * 2.5) * 0.5);\n    float de1 = 0.8 * (length(p.xz) - 0.01);\n    float de2 = max(p.x-2.0,length(p.yz)-0.01);\n    p.y = sin(atan(q.y, length(q.zx)) * 7.0) * 0.3;\n    float de3 = 0.7 * (length(p.xy) - 0.01);\n    return min(min(de1,de2),de3);\n}\n\nfloat map(in vec3 p)\n{\n    float de1 = 0.6 * map1(p);\n\tp.xz *= rotate(iTime * 0.234);\n\tp.yz *= rotate(iTime * 0.123); \n    float de2 = 0.5 * map2(p);\n    float de3 = map3(p);\n    if (Flag)\n    {\n        if (de1 < de2 && de1 < de3)\n        {\n            M = 1;\n         } else if (de2 < de3){\n            M = 2;\n         } else{\n            M = 3;   \n         }\n    }    \n    return min(min(de1,de2),de3);\n}\n\nvec3 calcColor(in vec3 p)\n{\n    Flag = true; map(p); Flag = false;\n    if (M == 1)\n    {\n        return hsv(atan(p.z, p.x) / PI2 - 0.02 * iTime, 0.8, 1.0);\n    }\n    if (M == 2) \n    {\n        return hsv(0.18*floor(0.5 * iTime), 1.0, 1.0 );\n    }\n    if (M == 3) \n    {       \n    \tfloat t = smoothstep(0.2, 7.5, mod(iTime, 12.0));\n        return mix(vec3(1.0, 0.1, 0.1), vec3(0.2, 0.5, 0.3), t);\n    }\n    return vec3(1.0);\n}\n\nvec3 calcNormal(in vec3 p)\n{\n\tconst vec2 e = vec2(0.0001, 0.0);\n\treturn normalize(vec3(\n\t\tmap(p + e.xyy) - map(p - e.xyy),\n\t\tmap(p + e.yxy) - map(p - e.yxy),\n\t\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd)\n{\n\tfloat res = 1.0;\n    float t = 0.05;\n    for(int i = 0; i < 32; i++)\n    {\n\t\tfloat h = map(ro + rd * t);\n        res = min(res, 8.0 * h / t);\n        t += clamp(h, 0.02, 0.1);\n        if(h < 0.001 || t > 1.5) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tconst float maxd = 10.0;\n\tconst float precis = 0.001;\n    float h = precis * 2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for(int i = 0; i < 64; i++)\n    {\n        if(h < precis || t > maxd) break;\n\t    h = map(ro + rd * t);\n        t += h;\n    }\n    if(t < maxd) res = t;\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p2d = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 col = vec3(0.2, 0.3, 0.7) * ((p2d.y + 1.0) * 0.3);\n    col = mix(col, texture(iChannel0, p2d * 0.02 - iTime * 0.0005).xyz, 0.3);\n   \tvec3 rd = normalize(vec3(p2d, -1.8));\n\tvec3 ro = vec3(0.0, 0.0, 3.5);\n    vec3 li = normalize(vec3(0.5, 0.8, 3.0));\n    float t = march(ro, rd);\n    if(t > -0.001)\n    {\n        vec3 p3d = ro + t * rd;\n        vec3 n = calcNormal(p3d);\n\t\tfloat dif = clamp((dot(n, li) + 0.5) * 0.7, 0.4, 1.0);\n        dif *= clamp(softshadow(p3d, li), 0.4, 1.0);\n        col = calcColor(p3d) * dif;\n    }\n    col = pow(col, vec3(0.8));\n   \tfragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtfGRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 78, 100, 100, 150], [152, 152, 189, 189, 321], [323, 323, 346, 346, 939], [941, 941, 964, 964, 1068], [1070, 1070, 1093, 1093, 1404], [1406, 1406, 1428, 1428, 1812], [1814, 1814, 1841, 1841, 2240], [2242, 2242, 2270, 2270, 2438], [2440, 2440, 2482, 2482, 2740], [2742, 2742, 2779, 2779, 3073], [3075, 3075, 3132, 3132, 3791]], "test": "error"}
{"id": "Mtl3DB", "name": "Line intersection", "author": "the23", "description": "calculate the point on a line visualised", "tags": ["vector"], "likes": 4, "viewed": 244, "published": "Public", "date": "1425041073", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float soft = 0.01;\nconst vec3 background = vec3(0.95);\n\n// define the visible area\n// - padding to match the screen-ratio might be added...\nconst vec2 bot = vec2(-0.25,-0.25);\nconst vec2 top = vec2(4,5);\n\n// these are the points\n// lines are a-b and a-c\nconst vec2 a = vec2(0,0);\nconst vec2 b = vec2(5,0);\nconst vec2 c = vec2(2,3);\n\nvec2 calcProjPoint(vec2 a, vec2 b, vec2 c)\n{\n    float d = dot(b - a, c - a) / length(b - a);\n    d /= length(b - a);\n    return a + d * (b - a);\n}\n\nvec3 drawDot(vec3 col, vec2 coord, vec2 p, float thickness)\n{\n    float dst = distance(coord, p);\n    dst = 1.0 - smoothstep(thickness - soft, thickness + soft, dst);\n    return mix(col, vec3(1.0, 0.0, 0.0), dst);\n}\n\nvec3 drawDotAnimated(vec3 col, vec2 coord, vec2 p, float thickness)\n{\n    float dst = distance(coord, p);\n    float inside = dst;\n    dst = 1.0 - smoothstep(thickness - soft, thickness + soft, dst);\n    inside = inside / (thickness + soft)+ iTime * 0.5;\n    return mix(col, vec3(1.0, sin(radians(inside*360.0))*0.5 + 0.5, 0.0), dst);\n}\n\nvec3 drawLine(vec3 col, vec2 coord, vec2 p1, vec2 p2, float thickness)\n{\n    float d = dot(coord - p1, p2 - p1) / length(p2 - p1);\n    d /= length(p2 - p1);\n    d = clamp(step(0.0, d) * d, 0.0, 1.0);\n    d = distance(p1 + d * (p2 - p1), coord);\n    \n    float dst = 1.0 - smoothstep(thickness - soft, thickness + soft, d);\n    \n    return mix(col, vec3(0.0), dst);\n}\n\nvec3 drawLineDashed(vec3 col, vec2 coord, vec2 p1, vec2 p2, float thickness, float strips)\n{\n    float lenLine = length(p2 - p1);\n    float d = dot(coord - p1, p2 - p1) / lenLine;\n    d /= lenLine;\n    float seg = clamp(d, 0.0, 1.0);\n    \n    d = clamp(step(0.0, d) * d, 0.0, 1.0);\n    d = distance(p1 + d * (p2 - p1), coord);\n    \n    float dst = 1.0 - smoothstep(thickness - soft, thickness + soft, d);\n\n    float relLinePos = distance(coord, p1) / lenLine * dst;\n    \n    float pattern = step(0.5, mod((seg * strips - 0.25 - iTime), 1.0));\n    dst *= pattern;\n    \n    return mix(col, vec3(1.0, seg, 0.0), dst);\n}\n\nvec3 drawGrid(vec3 col, vec2 coord)\n{\n    float factor = distance(coord - 0.5, floor(coord)) + 0.25;\n    factor = pow(factor, 8.0);\n    return mix(col, vec3(0.2), factor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 area = top - bot;\n    \n    float ratioScreen = iResolution.x/ iResolution.y;\n    float ratioArea = area.x / area.y;\n    \n    vec2 padding = vec2(ratioScreen / ratioArea, ratioArea /ratioScreen);\n    padding = max(vec2(0.0), area * padding - area);\n\n    area += padding;\n    vec2 coord = uv * area + bot - (padding * 0.5);\n    \n    vec2 d = calcProjPoint(a, b, c);\n    \n    vec3 col = background;\n    \n    col = drawGrid(col, coord);\n\n    col = drawLine(col, coord, a, b, 0.05);\n    col = drawLine(col, coord, a, c, 0.05);\n    \n    col = drawLineDashed(col, coord, c, d, 0.03, 2.0);\n\n    col = drawDot(col, coord, a, 0.1);\n    col = drawDot(col, coord, b, 0.1);\n    col = drawDot(col, coord, c, 0.1);\n\n    col = drawDotAnimated(col, coord, d, 0.14);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mtl3DB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[339, 339, 383, 383, 486], [488, 488, 549, 549, 703], [705, 705, 774, 774, 1040], [1042, 1042, 1114, 1114, 1408], [1410, 1410, 1502, 1502, 2026], [2028, 2028, 2065, 2065, 2201], [2203, 2203, 2260, 2260, 3099]], "test": "valid"}
{"id": "Mtl3RB", "name": "Weird Fractal 3", "author": "aiekick", "description": "Colored version of Weird Fractal 2", "tags": ["fractal", "weird", "3"], "likes": 4, "viewed": 1173, "published": "Public API", "date": "1423157432", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//based on shader from coyote => https://www.shadertoy.com/view/ltfGzS\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime,c=0.;\n    vec4 p=vec4(fragCoord,0.,1.)/iResolution.x-.5,r=p-p,q=r;p.y+=.25;\n   \tq.zw-=t*0.7;\n    \n    for (float i=1.; i>0.; i-=.01) \n    {\n        float d=0.,s=1.;\n\n        for (int j = 0; j < 4 ; j++)\n            r=max(r*=r*=r=mod(q*s+1.,2.)-1.,r.yzxw),\n            d=max(d,( .27 -length(r)*.6)/s),\n            s*=1.+(0.5*sin(iTime*0.0005)+0.5);\n\n        q+=p*d;\n        \n        c = i;\n\n        if(d<1e-5) break;\n    }\n    \n    float r1 = c, r2 = dot(r,r);\n    float rxy = mix(r1, r2, sin(t));\n    float rr = mix(min(r1, r2), dot(rxy,r1), 0.5);\n    float gg = mix(rr, dot(rxy,r2), 0.5);\n    float bb = mix(gg, rxy, 0.5);\n    fragColor = vec4(rr,gg,bb,1);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mtl3RB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 129, 129, 814]], "test": "error"}
{"id": "Mtl3RX", "name": "Trench", "author": "unknownloner", "description": "Top down view of a trench of sorts", "tags": ["light", "animated", "sine", "perspective"], "likes": 1, "viewed": 118, "published": "Public", "date": "1423952830", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define INV_PI 0.3183098861837907\n#define INV_PI2 0.15915494309189535\n\n#define SPEED 0.3\n#define LIGHT_OFF -0.3\n\n\nfloat saw(float x) {\n//    float t = x - PI * 0.5;\n    float t = x;\n    return 2.0 * (t * INV_PI2 - floor(0.5 + t * INV_PI2));\n}\n\nfloat tri(float t) {\n \treturn 2.0 * abs(saw(t)) - 1.0;\n}\n\nvec4 blend(vec4 a, vec4 b) {\n \tfloat sfa = a.w;\n    float sfb = 1.0 - a.w;\n    vec3 l = (a * sfa).xyz;\n    vec3 r = (b * sfb).xyz;\n    return vec4(l + r, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime * SPEED;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    //float xOff = sin(uv.y * PI * 4.0) * 0.5 * (sin(iTime * 4.0) + tri(uv.x * PI) * 0.8);\n    float xOff = sin(uv.y * PI * 4.0) * 0.5 * (tri(uv.x * PI) * 1.2);\n    float r = sin((uv.x * 8.0 - 0.5 - xOff + t * 1.5) * PI) * 2.0;\n    float w = clamp(sin(uv.y * 16.0 - t * 32.0), 0.0, 1.0);\n    float o = sin(uv.y * PI * 4.0);\n    float barA = smoothstep(0.0, 1.0, clamp(r, 0.0, 1.0));\n    vec4 bar = vec4(1.0, 1.0, w, barA * barA);\n    vec4 bg  = vec4(0.0, abs(o) + 0.2, o + 0.2, 1.0) * 0.75;\n    \n    float shade = (sin(uv.y * PI * 4.0 + LIGHT_OFF) * 0.5 + 0.5) * 0.5 + 0.5;\n    vec4 shadeVec = vec4(shade, shade, shade + (1.0 - shade), 1.0);\n    fragColor = blend(bar * shadeVec, bg);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mtl3RX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[173, 173, 193, 223, 301], [303, 303, 323, 323, 359], [361, 361, 389, 389, 522], [524, 524, 581, 581, 1339]], "test": "valid"}
{"id": "MtlGR2", "name": "kalizyl und kalizul", "author": "bergi", "description": "we're getting there...\ni could link to eiffies last shader but it's on a page that crashes this browser ..", "tags": ["raymarching", "kaliset", "distancehacks", "identitytheft"], "likes": 25, "viewed": 2159, "published": "Public API", "date": "1423511347", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define thank you eiffie :D \n#define and greetings to Kali :)\n#define and_long_overdue thank_you iq\n#define your_publications_where_a_greater_impact_than_sep11\n\n\n// More Kali-de explorations \n// please by kind to this set\n// License aGPL v3\n// 2015, stefan berke \n\n\n// http://www.musicdsp.org/showone.php?id=238\nfloat Tanh(in float x) { return clamp(x * ( 27. + x * x ) / ( 27. + 9. * x * x ), -1., 1.); }\n\n// two different traps and colorings\n#define mph (.5 + .5 * Tanh(sin(iTime/9.123+1.2)*7.))\n\n\nvec3 kali_sky(in vec3 pos, in vec3 dir)\n{\n\tvec4 col = vec4(0,0,0,1);\n\t\n\tfloat t = 0., pln;\n    for (int k=0; k<50; ++k)\n\t{\n\t\tvec4 p = vec4(pos + t * dir, 1.);\n\n\t\tvec3 param = mix(\n            vec3(1., .5, 1.),\n\t\t\tvec3(.51, .5, 1.+0.1*mph), mph);\n\n        // \"kali-set\" by Kali\n\t\tfloat d = 10.; pln=6.;\n        vec3 av = vec3(0.);\n\t\tfor (int i=0; i<6; ++i)\n\t\t{\n            p = abs(p) / dot(p.xyz, p.xyz);\n            // distance to tretrahedron / cylinder\n            d = min(d, mix(p.x+p.y+p.z, length(p.xy), mph) / p.w);\n            // disc?\n            if (i == 2)\tpln = min(pln, dot(p.xyz, vec3(0,0,1)) / p.w);\n\t\t\tav += p.xyz/(4.+p.w);\n            p.xyz -= param \n                // a little transition that makes it swim\n                - 100.*col.x*mph*(1.-mph);\n\t\t}\n        // blend the gems a bit \n\t\td += .03*(1.-mph)*smoothstep(0.1,0., t);\n\t\tif (d <= 0.0) break;\n        // something like a light trap\n\t\tcol.w = min(col.w, d);\n        \n#if 1\n        // a few more steps for texture\n        for (int i=0; i<3; ++i)\n        {\n            p = abs(p) / dot(p.xyz, p.xyz);\n            av += p.xyz/(4.+p.w);\n            p.xyz -= param;\n        }\n#endif        \n        // (why are these values getting so large?) \n\t\tcol.xyz += av / 4000. + p.xyz / 40000.;\n\t\t\n        // quadratic seems to work pretty good for the gems\n        // well it's just a sum otherwise\n\t\tt += min(0.1, mix(d*d*1., d, mph));\n\t}\n\t\n\treturn mix(col.xyz/col.w*(2.1-2.*mph)/(1.+.2*t), \n               mph-0.001/col.www - (1.-mph*0.8)*vec3(0.1,0.2,0.4)/(1.+pln), \n               mph);\n}\n\n\nvec2 rotate(in vec2 v, float r) { float s = sin(r), c = cos(r);\treturn vec2(v.x * c - v.y * s, v.x * s + v.y * c); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.y * 2.;\n    \n    vec3 dir = normalize(vec3(uv, (.9+.2*mph) - 0.4*length(uv)));\n    \n    float t = iTime-2.;\n\tvec3 pos = vec3((1.-mph*.5)*sin(t/2.), (.3-.2*mph)*cos(t/2.), (.3+2.*mph)*(-1.+sin(t/4.13)));\n    pos.xy *= 1.5 + sin(t/3.47) + 0.5 * -pos.z;\n    dir.yz = rotate(dir.yz, -1.4+mph+(1.-.6*mph)*(-.5+0.5*sin(t/4.13+2.+1.*sin(t/1.75))));\n    dir.xy = rotate(dir.xy, sin(t/2.)+0.2*sin(t+sin(t/3.)));\n    \n\tfragColor = vec4(kali_sky(pos, dir), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtlGR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[266, 312, 336, 336, 405], [500, 500, 541, 541, 2056], [2059, 2059, 2092, 2092, 2175], [2177, 2177, 2234, 2234, 2750]], "test": "valid"}
{"id": "MtlGRf", "name": "chrome sea", "author": "kig", "description": "shadeaday 2015-02-15", "tags": ["broken", "shadeaday"], "likes": 8, "viewed": 249, "published": "Public", "date": "1424026456", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define THRESHOLD 0.015\n#define MAX_DISTANCE 2.0\n\n#define RAY_STEPS 30\n\n\n// iq's LUT based 3d value noise\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel0, (uv + 0.5)/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat map( in vec3 p )\n{\n\tvec3 q = p + 0.2*vec3(-1.0, 1.0, 2.2)*iTime;\n\tfloat f;\n    f = 0.500*noise( q ); q = q*2.0;\n    f += 0.25*noise( q ); q = q*2.0;\n    f += 0.125*noise( q ); q = q*2.0;\n    f += 0.0625*noise( q ); q = q*2.0;\n    f += 0.03125*noise( q ); q = q*2.0;\n    f += 0.015625*noise( q );\n\treturn f;\n}\n\n\nfloat scene(vec3 p)\n{\n\treturn min(length(p-vec3(0.0, 0.9, 0.0))-0.7, (pow(map(p), 6.0)*-2.0+0.2+0.5+p.y));\n}\n\nvec3 normal(vec3 p, float d)\n{\n\tfloat e = 0.05;\n\tfloat dx = scene(vec3(e, 0.0, 0.0) + p) - d;\n\tfloat dy = scene(vec3(0.0, e, 0.0) + p) - d;\n\tfloat dz = scene(vec3(0.0, 0.0, e) + p) - d;\n\treturn normalize(vec3(dx, dy, dz));\n}\n\nvec3 shadeBg(vec3 nml, vec2 fragCoord)\n{\n\tvec2 aspect = vec2(iResolution.x/iResolution.y, 1.0);\n\tvec2 uv = (2.0 * fragCoord.xy / iResolution.xy - 1.0) * aspect;\n\tvec3 bgLight = normalize(vec3(\n\t\tcos(iTime*0.2/0.954929658551372)*4.0, \n\t\tsin(iTime/1.1936620731892151)*3.0 - 4.0, \n\t\tsin(iTime*0.2/0.954929658551372)*8.0\n\t));\n\tvec3 sun = vec3(3.0, 1.0, 0.5);\n\tfloat bgDiff = dot(nml, vec3(0.0, -1.0, 0.0));\n\tfloat sunPow = dot(nml, bgLight);\n\tfloat sp = max(sunPow, 0.0);\n\tvec3 bgCol = max(0.0, bgDiff)*2.0*vec3(0.4, 0.7, 1.0);\n\tbgCol += max(0.0, -bgDiff)*vec3(0.4, 0.55, 0.7);\n\tbgCol += vec3(0.2, 0.5, 0.7)*((0.5*pow(1.0-abs(bgDiff), 5.0)*(5.0-dot(uv,uv))));\n\tbgCol += sun*(0.5*pow( sp, 3.0)+pow( sp, 256.0));\n\tbgCol += vec3(0.5, 0.2, 0.15)*(pow( sp, 8.0) + pow( sp, abs(bgLight.y)*128.0));\n    bgCol += vec3(1.9,0.,0.9) * ((1.0-pow(abs(bgDiff), 0.6)) * 1.0 * map(-nml) * map(-nml*nml.y));\n\treturn pow(max(vec3(0.0), bgCol), vec3(1.9));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 aspect = vec2(iResolution.x/iResolution.y, 1.0);\n\tif (iResolution.x < iResolution.y) {\n\t\taspect = vec2(1.0, iResolution.y / iResolution.x);\n\t}\n\tvec2 uv = (2.0 * fragCoord.xy / iResolution.xy - 1.0) * aspect;\n\tvec3 d = normalize(vec3(uv, 1.0));\n\tvec3 p = vec3(uv*-2.0, -6.5) + d*3.6;\n    for (int i=0; i<RAY_STEPS; i++) {\n        float dist = scene(p);\n        if (dist < THRESHOLD) {\n            vec3 nml = normal(p, dist);\n            d = reflect(d, nml);\n            p += (23.0*THRESHOLD) * d;\n        }\n        if (dist > MAX_DISTANCE) {\n            break; \n        }\n        p += dist * d;\n    }\n\tfragColor = vec4( 1.0 - exp(-1.3 * shadeBg(-d, fragCoord)), 1.0 );\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtlGRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[74, 107, 133, 133, 345], [347, 347, 371, 371, 661], [664, 664, 685, 685, 772], [774, 774, 804, 804, 998], [1000, 1000, 1040, 1040, 1935], [1937, 1937, 1994, 1994, 2670]], "test": "error"}
{"id": "MtsGDS", "name": "Voronoi 2x2x2", "author": "guil", "description": "Experiment with 3d voronoi \"cellular noise\"\nBased on Nimitz Pustules : https://www.shadertoy.com/view/XdSXDc\nI mainly tried to optimize the  voronoi3d with 2x2x2 kernel", "tags": ["3d", "voronoi", "noise"], "likes": 15, "viewed": 430, "published": "Public", "date": "1424969136", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by S.Guillitte \n//based on Pustules by nimitz :https://www.shadertoy.com/view/XdSXDc\n//Using code from Knighty : https://www.shadertoy.com/view/XlX3zB\n\n\n\n#define PI\t3.14159265359\n#define PI2\t( PI * 2.0 )\n\n#define time iTime\n\n\n// 1 = 3*3*3 kernel, 0 = 2*2*2 kernel\n#if 0\nfloat k2 = 1.;\nconst int m =1;\n#else\nfloat k2 = .7;\nconst int m =0;\n#endif\n\n\nfloat hash( in vec3 p ) \n{\n    return fract(sin(p.x*15.32758341+p.y*39.786792357+p.z*59.4583127+7.5312) * 43758.236237153)-.5;\n}\n\n\nvec3 voronoi(in vec3 p)\n{    \n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n\tfloat rid = -1.;\n    vec2 r = vec2(2.);\n    for (int i=-1; i<=m; i++) \n\tfor (int j=-1; j<=m; j++) \n\tfor (int k=-1; k<=m; k++) \n\t{\n\t\tvec3 g = vec3(i, j, k);\n        float h = hash(ip - g);\n        vec3 pp = fp +g +h*k2;\n        float d = dot(pp, pp);\n\n        if (d < r.x)\n\t\t{\n            r.y = r.x;\n            r.x = d;\n            rid = h +.5;\n\t\t}\n        else if(d < r.y)\n\t\t{\n    \t\tr.y = d;\n\t\t}\n\t}    \n    return vec3(r,rid);\n}\n\n\n\n//-------------------------------------------------\n//From https://www.shadertoy.com/view/XtXGRS#\nvec2 rotate(in vec2 p, in float t)\n{\n\treturn p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\n\nfloat map( vec3 p)\n{\n\tfloat d = length(p)-1.5;\n    vec3 vor = voronoi(p*5.0);\n    vor.y += vor.x;\n    d = max( d, (d-((vor.x+vor.y)-1.))*.15 );\n\treturn d;\t\n       \t\n}\n\n\nvec3 calcNormal(in vec3 p)\n{\n\tconst vec2 e = vec2(0.0001, 0.0);\n\treturn normalize(vec3(\n\t\tmap(p + e.xyy) - map(p - e.xyy),\n\t\tmap(p + e.yxy) - map(p - e.yxy),\n\t\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tconst float maxd = 5.0;\n\tconst float precis = 0.001;\n    float h = precis * 2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for(int i = 0; i < 128; i++)\n    {\n        if(h < precis*t || t > maxd) break;\n\t    h = map(ro + rd * t);\n        t += h;\n    }\n    if(t < maxd) res = t;\n    return res;\n}\n\nvec3 transform(in vec3 p)\n{\n    p.yz = rotate(p.yz, iTime * 0.2 + (iMouse.y-0.5*iResolution.y)*PI2/360.);\n    p.zx = rotate(p.zx, iTime * 0.125 + (0.5*iResolution.x-iMouse.x)*PI2/360.);\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 col = vec3(.3);\n   \tvec3 rd = normalize(vec3(p, -2.));\n\tvec3 ro = vec3(0.0, 0.0, 3.5);\n    vec3 li = normalize(vec3(0.5, 0.8, 3.0));\n    ro = transform(ro);\n\trd = transform(rd);\n\tli = transform(li);\n    \n    //Marble background from Nimitz's Pustule\n    vec3 bgvor = voronoi(rd*4.2)*0.35;\n    bgvor += voronoi(rd*9.)*0.25;\n    bgvor += voronoi(rd*25.)*0.1;\n    bgvor.y -= bgvor.x;\n    col = ((bgvor.z*.6 + 0.2)*(.5 - bgvor.x*1.5*(1.5 - bgvor.y*10.)))\n        *(sin(vec3(1.7,1.5,1)+.5 + voronoi(rd*24.).x)*0.5 + 0.5);\n    \n    float t = march(ro, rd);\n    if(t > -0.001)\n    {\n        vec3 pos = ro + t * rd;\n        vec3 nor = calcNormal(pos);\n\t\tfloat dif = clamp(dot(nor, li), 0.0, 1.0);\n        float c = voronoi(pos*5.).x;\n        vec3 col1 =vec3(c*c,c,.9)*c;\n        nor = reflect(rd, nor);\n        col1 += pow(max(dot(li, nor), 0.0), 25.0)*vec3(1.);\n\t    col = .1+col1;\n        col = col * dif;\n        \n\t}\n    \n   \tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtsGDS.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[445, 445, 471, 471, 573], [576, 576, 601, 601, 1084], [1088, 1186, 1222, 1222, 1273], [1276, 1276, 1296, 1296, 1442], [1445, 1445, 1473, 1473, 1641], [1643, 1643, 1680, 1680, 1976], [1978, 1978, 2005, 2005, 2179], [2181, 2181, 2238, 2238, 3260]], "test": "valid"}
{"id": "MtX3Rf", "name": "ScreenTunes", "author": "tajjada", "description": "PLEASE VIEW IN FULLSCREEN; SEIZURE WARNING\n\nThis should make your monitor scream. Results vary.\n\nA shader version of http://thume.ca/screentunes/ <-- I am not the author, I did not come up with this idea; I only reimplemented it in a shader.", "tags": ["glitch", "screentunes", "lcd", "capacitor"], "likes": 6, "viewed": 204, "published": "Public", "date": "1423759066", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This shader is inspired by http://thume.ca/screentunes/\n// I am not the original author of the above, and I did not come\n// up with this idea myself; I only (re)implemented it in shadertoy.\n\n// The bars of varying thickness should cause the capacitors in typical\n// LCD displays to make a high-pitched noise. It may or may not work\n// for you; how loudly you hear it (if at all) highly depends on your\n// specific monitor. Might also work on non-LCD displays, but not tested.\n\n\n// Animation parameters; feel free to tweak.\n\n// Minimum thickness in screen pixels.\n#define minthick 4.0\n\n// Maximum thickness in screen pixels.\n#define maxthick 40.0\n\n// Time multiplier.\n#define speed 1.0\n\n\n// Do not change this.\nconst float hr = ((maxthick-minthick) * 0.5);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float h = iResolution.y - fragCoord.y;\n    \n    float bh = cos(iTime * speed) * hr + minthick + hr;\n    \n    fragColor = (mod(h, bh) < bh * 0.5) ?\n        vec4(1.0, 1.0, 1.0, 1.0) : vec4(0.0, 0.0, 0.0, 0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtX3Rf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[760, 760, 817, 817, 1031]], "test": "valid"}
{"id": "MtXGRs", "name": "Gyrating Gyroscope", "author": "dr2", "description": "Gyroscope; see source for more details.", "tags": ["gyroscope"], "likes": 4, "viewed": 575, "published": "Public API", "date": "1424255698", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Gyrating Gyroscope\" by dr2 - 2015\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Simulation of a simulated gyroscope. A \"real\" simulated gyroscope\n  requires solving differential equations; since this cannot be done\n  without \"historical\" information, trajectories here are approximated\n  by cycloids. The parameters change every 20s to show different\n  combinations of precession and nutation; the red dots trace the\n  trajectory.\n*/\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float s = 0.;\n  float a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return s;\n}\n\nvec3 WoodCol (vec3 p, vec3 n)\n{\n  p *= 4.;\n  float f = dot (vec3 (Fbm2 (p.yz * vec2 (1., 0.1)),\n     Fbm2 (p.zx * vec2 (1., 0.1)), Fbm2 (p.yx * vec2 (1., 0.1))), abs (n));\n  return mix (vec3 (0.8, 0.4, 0.2), vec3 (0.45, 0.25, 0.1), f);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nint idObj;\nvec3 qHit, ltDir;\nfloat tCur, tSeq, tGap, pnRel, avSpin, amNut, frNut, tha0, phi0;\nbool isShadw;\nconst float dstFar = 100.;\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  const float bLen = 6., bRad = 0.6, axLen = 10., wlRad = 6.;\n  float dMin, d, a, psi, tha, phi, t, ti;\n  q = p;\n  dMin = dstFar;\n  d = PrCapsDf (q.xzy, bRad * (1.1 - 0.3 * q.y / bLen), 0.9 * bLen);\n  if (d < dMin) { dMin = d;  qHit = q;  idObj = 2; }\n  q.y -= bLen;\n  d = PrSphDf (q, 0.07 * wlRad);\n  if (d < dMin) { dMin = d;  qHit = q;  idObj = 5; }\n  q.y -= -2.05 * bLen;\n  d = PrCylDf (q.xzy, 10. * bRad, 0.08 * bLen);\n  if (d < dMin) { dMin = d;  qHit = q;  idObj = 3; }\n  q = p;  q.y -= bLen;\n  t = frNut * tSeq;\n  tha = tha0 + amNut * (pnRel * t - sin (t));\n  phi = phi0 + amNut * (pnRel - cos (t));\n  psi = - avSpin * tSeq;\n  q.xz = Rot2D (q.xz, tha);  q.xy = Rot2D (q.xy, phi);\n  q.x -= axLen;\n  d = PrTorusDf (q.zyx, 0.05 * wlRad, wlRad);\n  d = min (d, PrCylDf (q.zyx, 0.07 * wlRad, 0.05 * wlRad));\n  if (d < dMin) { dMin = d;  idObj = 5; }\n  q.x += 0.5 * axLen;\n  d = min (d, PrCylDf (q.zyx, 0.03 * wlRad, 0.5 * axLen));\n  if (d < dMin) { dMin = d;  idObj = 4; }\n  q.x -= 0.5 * axLen;\n  q.yz = Rot2D (q.yz, psi);  \n  q.yz = Rot2D (q.yz, 0.25 * pi *\n     floor ((atan (q.y, q.z) + pi) * 4. / pi + 0.5));\n  q.z += 0.5 * wlRad;\n  d = PrCylDf (q, 0.03 * wlRad, 0.5 * wlRad);\n  if (d < dMin) { dMin = d;  idObj = 5; }\n  if (! isShadw) {\n    p.y -= bLen;\n    ti = tGap * floor (tSeq / tGap);\n    d = dstFar;\n    for (int j = 0; j < 40; j ++) {\n      t = frNut * ti;\n      tha = tha0 + amNut * (pnRel * t - sin (t));\n      phi = phi0 + amNut * (pnRel - cos (t));\n      q = p;  \n      q.xz = Rot2D (q.xz, tha);  q.xy = Rot2D (q.xy, phi);\n      q.x -= 0.8 * axLen;\n      d = min (d, PrSphDf (q, 0.03 * wlRad));\n      ti -= tGap;\n      if (ti < 0.) break;\n    }\n  }\n  if (d < dMin) { dMin = d;  idObj = 1; }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float d, h, sh;\n  sh = 1.;\n  d = 0.1;\n  for (int i = 0; i < 60; i++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, 20. * h / d);\n    d += 0.4;\n    if (h < 0.001) break;\n  }\n  return clamp (sh, 0., 1.);\n}\n\nvec3 ObjCol (vec3 n, float dstHit)\n{\n  vec3 col;\n  if (idObj == 1) col = vec3 (0.9, 0., 0.) *\n     (1. - 0.5 * (dstHit - 40.) / (dstFar - 40.));\n  else if (idObj == 2) col = WoodCol (3. * qHit.xzy, n);\n  else if (idObj == 3) col = WoodCol (qHit, n);\n  else if (idObj == 4) col = vec3 (0.6, 0.6, 0.7);\n  else if (idObj == 5) col = vec3 (0.8, 0.8, 0.1);\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 vn, objCol, col;\n  float dstHit, sh;\n  int idObjT;\n  idObj = -1;\n  isShadw = false;\n  dstHit = ObjRay (ro, rd);\n  if (idObj < 0) dstHit = dstFar;\n  idObjT = idObj;\n  if (dstHit >= dstFar)\n     col = (1. - 2. * dot (rd.xy, rd.xy)) * vec3 (0.2, 0.25, 0.3);\n  else {\n    ro += rd * dstHit;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    objCol = ObjCol (vn, dstHit);\n    isShadw = true;\n    sh = (idObj != 1) ? ObjSShadow (ro, ltDir) : 1.;\n    col = objCol * (0.4 + 0.6 * sh * max (dot (vn, ltDir), 0.)) +\n       sh * pow (max (0., dot (ltDir, reflect (rd, vn))), 128.);\n  }\n  col = sqrt (clamp (col, 0., 1.));\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n  uv.x *= iResolution.x / iResolution.y;\n  tCur = iTime;\n  float tCyc = 20.;\n  float nSeq = floor (tCur / tCyc);\n  tSeq = tCur - nSeq * tCyc;\n  pnRel = 0.2 + 0.4 * mod (nSeq, 5.);\n  amNut = 0.12 * pi * (1. - 0.5 * (pnRel - 1.));\n  frNut = 1.1 * pi;\n  avSpin = 1.2 * pi;\n  phi0 = -0.12 * pi - amNut * (pnRel - 0.2);\n  tha0 = 0.1 * pi;\n  tGap = 0.08;\n  float dist = 50.;\n  vec3 rd = normalize (vec3 (uv, 3.2));\n  vec3 ro = vec3 (0., 0.12, -1.) * dist;\n  ltDir = normalize (vec3 (-0.5, 0.8, -0.4));\n  vec3 col = ShowScene (ro, rd);\n  fragColor = vec4 (col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtXGRs.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[633, 633, 657, 657, 704], [706, 706, 731, 731, 910], [912, 912, 933, 933, 1070], [1072, 1072, 1103, 1103, 1309], [1311, 1311, 1341, 1341, 1415], [1417, 1417, 1450, 1450, 1477], [1479, 1479, 1521, 1521, 1572], [1574, 1574, 1617, 1617, 1690], [1692, 1692, 1738, 1738, 1795], [1933, 1933, 1955, 1955, 3692], [3694, 3694, 3727, 3727, 3903], [3905, 3905, 3926, 3926, 4134], [4136, 4136, 4173, 4173, 4382], [4384, 4384, 4420, 4420, 4751], [4753, 4753, 4788, 4788, 5417], [5419, 5419, 5476, 5476, 6090]], "test": "valid"}
{"id": "MtXGzs", "name": "Yellow Moth", "author": "dr2", "description": "Cousin of the famous Tiger Moth.", "tags": ["raymarching", "landscape", "aeroplane"], "likes": 10, "viewed": 735, "published": "Public API", "date": "1424286941", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Yellow Moth\" by dr2 - 2015\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nconst float pi = 3.14159;\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  const vec3 cHashVA3 = vec3 (37.1, 61.7, 12.4);\n  const vec3 e = vec3 (1., 0., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Noisefv3a (vec3 p)\n{\n  vec3 i, f;\n  i = floor (p);  f = fract (p);\n  f *= f * (3. - 2. * f);\n  vec4 t1 = Hashv4v3 (i);\n  vec4 t2 = Hashv4v3 (i + vec3 (0., 0., 1.));\n  return mix (mix (mix (t1.x, t1.y, f.x), mix (t1.z, t1.w, f.x), f.y),\n              mix (mix (t2.x, t2.y, f.x), mix (t2.z, t2.w, f.x), f.y), f.z);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  const mat3 mr = mat3 (0., 0.8, 0.6, -0.8, 0.36, -0.48, -0.6, -0.48, 0.64);\n  float f, a, am, ap;\n  f = 0.;  a = 0.5;\n  am = 0.5;  ap = 4.;\n  p *= 0.5;\n  for (int i = 0; i < 6; i ++) {\n    f += a * Noisefv3a (p);\n    p *= mr * ap;  a *= am;\n  }\n  return f;\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s = vec3 (0.);\n  float a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 e = vec3 (0.2, 0., 0.);\n  float s = Fbmn (p, n);\n  vec3 g = vec3 (Fbmn (p + e.xyy, n) - s,\n     Fbmn (p + e.yxy, n) - s, Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nfloat PrSphDf (vec3 p, float s)\n{\n  return length (p) - s;\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrFlatCylDf (vec3 p, float rhi, float rlo, float h)\n{\n  return max (length (p.xy - vec2 (rhi *\n     clamp (p.x / rhi, -1., 1.), 0.)) - rlo, abs (p.z) - h);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r) {\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nint idObj;\nmat3 flMat;\nvec3 flPos, qHit, qHitTransObj, sunDir;\nfloat fusLen, wSpan, flyVel, tCur;\nconst float dstFar = 350.;\nconst int idFus = 11, idPipe = 12, idWing = 13, idStrut = 14,\n   idHstab = 15, idFin = 16, idLeg = 17, idAxl = 18, idWhl = 19,\n   idNose = 20, idCkpit = 21, idPlt = 22;\n\nvec3 SkyBg (vec3 rd)\n{\n  return mix (vec3 (0.2, 0.2, 0.9), vec3 (0.4, 0.4, 0.55),\n     1. - max (rd.y, 0.));\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 p, q, cSun, clCol, col;\n  float fCloud, cloudLo, cloudRngI, atFac, colSum, attSum, s,\n     att, a, dDotS, ds;\n  const int nLay = 60;\n  cloudLo = 300.;  cloudRngI = 1./200.;  atFac = 0.035;\n  fCloud = 0.45;\n  if (rd.y > 0.) {\n    fCloud = clamp (fCloud, 0., 1.);\n    dDotS = max (dot (rd, sunDir), 0.);\n    ro.x += 10. * tCur;\n    p = ro;\n    p.xz += (cloudLo - p.y) * rd.xz / rd.y;\n    p.y = cloudLo;\n    ds = 1. / (cloudRngI * rd.y * (2. - rd.y) * float (nLay));\n    colSum = 0.;  attSum = 0.;\n    s = 0.;  att = 0.;\n    for (int j = 0; j < nLay; j ++) {\n      q = p + rd * s;\n      att += atFac * max (fCloud - Fbm3 (0.007 * q), 0.);\n      a = (1. - attSum) * att;\n      colSum += a * (q.y - cloudLo) * cloudRngI;\n      attSum += a;  s += ds;\n      if (attSum >= 1.) break;\n    }\n    colSum += 0.5 * min ((1. - attSum) * pow (dDotS, 3.), 1.);\n    clCol = vec3 (1.) * 2.8 * (colSum + 0.05);\n    cSun = vec3 (1.) * clamp ((min (pow (dDotS, 1500.) * 2., 1.) +\n       min (pow (dDotS, 10.) * 0.75, 1.)), 0., 1.);\n    col = clamp (mix (SkyBg (rd) + cSun, clCol, attSum), 0., 1.);\n    col = mix (col, SkyBg (rd), pow (1. - rd.y, 16.));\n  } else col = SkyBg (rd);\n  return col;\n}\n\nvec3 TrackPath (float t)\n{\n  float s = sin (0.005 * t);\n  float c = cos (0.005 * t);\n  c /= (1. + s * s);\n  return vec3 (1. + 40. * c, 13. + 2. * sin (0.0073 * t), -5. + 40. * s * c);\n}\n\nfloat GrndHt (vec2 p)\n{\n  const mat2 qRot = mat2 (1.6, -1.2, 1.2, 1.6);\n  vec2 q, t, ta, v;\n  float wAmp, pRough, ht;\n  wAmp = 2.;\n  pRough = 1.;\n  q = p * 0.1;\n  ht = 0.0001 * dot (p, p);\n  for (int j = 0; j < 3; j ++) {\n    t = q + 2. * Noisefv2 (q) - 1.;\n    ta = abs (sin (t));\n    v = (1. - ta) * (ta + abs (cos (t)));\n    v = pow (1. - v, vec2 (pRough));\n    ht += (v.x + v.y) * wAmp;\n    q *= 1.5 * qRot;\n    wAmp *= 0.25;\n    pRough = 0.6 * pRough + 0.2;\n  }\n  return ht;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = 0; j < 180; j ++) {\n    p = ro + s * rd;\n    h = p.y - GrndHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.25, 0.4 * h) + 0.005 * s;\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = 0; j < 8; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      h = step (0., p.y - GrndHt (p.xz));\n      sLo += h * (s - sLo);\n      sHi += (1. - h) * (s - sHi);\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p, float d)\n{\n  float ht = GrndHt (p.xz);\n  vec2 e = vec2 (max (0.01, 0.00001 * d * d), 0.);\n  return normalize (vec3 (ht - GrndHt (p.xz + e.xy), e.x,\n     ht - GrndHt (p.xz + e.yx)));\n}\n\nfloat PropelDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  q = p - fusLen * vec3 (0., 0.02, 1.07);\n  d = PrCylDf (q, 0.3 * fusLen, 0.007 * fusLen);\n  if (d < dMin) {\n    dMin = d;\n    qHitTransObj = q;\n    idObj = 1;\n  }\n  return dMin;\n}\n\nfloat TransObjDf (vec3 p)\n{\n  float dMin;\n  dMin = dstFar;\n  dMin = PropelDf (flMat * (p - flPos), dMin);\n  return dMin;\n}\n\nfloat TransObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = TransObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nfloat FlyerDf (vec3 p, float dMin)\n{\n  vec3 q, qq;\n  float d, wr;\n  q = p;\n  wr = -0.2 + q.z / fusLen;\n  d = PrRoundBoxDf (q, vec3 (0.07 * (1. - 0.8 * wr * wr),\n     0.11 * (1. - 0.6 * wr * wr), 1.) * fusLen, 0.05 * fusLen);\n  q -= vec3 (0., 0.1, 0.3) * fusLen;\n  d = max (d, - PrRoundBoxDf (q, vec3 (0.05, 0.1, 0.15) * fusLen,\n     0.03 * fusLen)); \n  if (d < dMin) { dMin = min (dMin, d);  idObj = idFus;  qHit = q; }\n  q = p;  q -= vec3 (0., 0.08, 0.3) * fusLen;\n  d = PrRoundBoxDf (q, vec3 (0.05, 0.02, 0.15) * fusLen, 0.03 * fusLen); \n  if (d < dMin) { dMin = min (dMin, d);  idObj = idCkpit;  qHit = q; }\n  q = p;  q.z = abs (q.z - 0.33 * fusLen) - 0.08 * fusLen;\n  q -= vec3 (0., 0.17, 0.) * fusLen;\n  d = PrSphDf (q, 0.04 * fusLen); \n  if (d < dMin) { dMin = min (dMin, d);  idObj = idPlt;  qHit = q; }\n  q = p - fusLen * vec3 (0., 0.03, 0.8);\n  q.x = abs (q.x) - 0.1 * fusLen;\n  d = PrCapsDf (q, 0.02 * fusLen, 0.15 * fusLen);\n  if (d < dMin) { dMin = min (dMin, d);  idObj = idPipe;  qHit = q; }\n  q = p - fusLen * vec3 (0., 0.03, 1.05);\n  d = PrCapsDf (q, 0.05 * fusLen, 0.02 * fusLen);\n  if (d < dMin) { dMin = d;  idObj = idNose;  qHit = q; }\n  q = p - fusLen * vec3 (0., 0.09, 0.2);\n  qq = q;  qq.y = abs (qq.y) - 0.21 * fusLen;\n  wr = q.x / wSpan;\n  d = PrFlatCylDf (qq.zyx, 0.24 * (1. - 0.2 * wr * wr) * fusLen,\n     0.01 * (1. - 0.8 * wr * wr) * fusLen, wSpan);\n  if (d < dMin) { dMin = min (dMin, d);  idObj = idWing;  qHit = q; }\n  q = p - fusLen * vec3 (0., 0.09, 0.25);\n  q.xz = abs (q.xz) - fusLen * vec2 (0.5, 0.1);\n  d = PrCylDf (q.xzy, 0.01 * fusLen, 0.21 * fusLen);\n  if (d < dMin) { dMin = min (dMin, d);  idObj = idStrut;  qHit = q; }\n  q = p - fusLen * vec3 (0., 0.15, 0.25);\n  q.x = abs (q.x) - 0.1 * fusLen;\n  d = PrCylDf (q.xzy, 0.01 * fusLen, 0.15 * fusLen);\n  if (d < dMin) { dMin = min (dMin, d);  idObj = idStrut;  qHit = q; }\n  float tSpan = 0.35 * wSpan;\n  q = p - fusLen * vec3 (0., 0., - 0.9);\n  wr = q.x / tSpan;\n  d = PrFlatCylDf (q.zyx, 0.15 * (1. - 0.25 * wr * wr) * fusLen,\n     0.007 * (1. - 0.2 * wr * wr) * fusLen, tSpan);\n  q.x = abs (q.x);\n  d = max (d, 0.02 * fusLen - 1.5 * q.x - q.z);\n  if (d < dMin) { dMin = min (dMin, d);  idObj = idHstab;  qHit = q; }\n  float fSpan = 0.32 * wSpan;\n  q = p - fusLen * vec3 (0., 0., - 0.87);\n  q.yz = Rot2D (q.yz, 0.15);\n  wr = q.y / fSpan;\n  d = PrFlatCylDf (q.zxy, 0.15 * (1. - 0.3 * wr * wr) * fusLen,\n     0.007 * (1. - 0.3 * wr * wr) * fusLen, fSpan);\n  d = max (d, - q.y);\n  if (d < dMin) { dMin = min (dMin, d);  idObj = idFin;  qHit = q; }\n  q = p - fusLen * vec3 (0., -0.25, 0.5);\n  q.x = abs (q.x) - 0.14 * fusLen;\n  q.xy = Rot2D (q.xy, -0.55);  q.yz = Rot2D (q.yz, 0.15);\n  d = PrCylDf (q.xzy, 0.013 * fusLen, 0.12 * fusLen);\n  if (d < dMin) { dMin = d;  idObj = idLeg;  qHit = q; }\n  q = p - fusLen * vec3 (0., -0.34, 0.515);\n  q.x = abs (q.x) - 0.22 * fusLen;\n  d = PrCylDf (q.yzx, 0.01 * fusLen, 0.035 * fusLen);\n  if (d < dMin) { dMin = d;  idObj = idAxl;  qHit = q; }\n  q.x -= 0.01 * fusLen;\n  d = PrCylDf (q.yzx, 0.1 * fusLen, 0.015 * fusLen);\n  if (d < dMin) { dMin = d;  idObj = idWhl;  qHit = q; }\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  float dMin = dstFar;\n  dMin = FlyerDf (flMat * (p - flPos), dMin);\n  dMin *= 0.8;\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  const float dTol = 0.001;\n  float d;\n  float dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < dTol || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * vec3 (v.y, v.z, v.w));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh = 1.;\n  float d = 0.02;\n  for (int i = 0; i < 40; i++) {\n    float h = ObjDf (ro + rd * d);\n    sh = min (sh, 20. * h / d);\n    d += 0.02;\n    if (h < 0.001) break;\n  }\n  return clamp (sh, 0., 1.);\n}\n\nvec4 FlyerCol (vec3 n)\n{\n  vec3 col, qqHit, nn;\n  float spec, b;\n  spec = 0.2;\n  qqHit = qHit / fusLen;\n  col = vec3 (0.9, 0.9, 0.);\n  nn = flMat * n;\n  if (idObj == idFus) {\n    qqHit.yz -= vec2 (-0.1, -0.7);\n    col = mix (vec3 (0., 1., 0.), col,\n       (1. - 0.5 * SmoothBump (0.06, 0.09, 0.01, length (qqHit.yz))) *\n       (1. - 0.5 * SmoothBump (-0.01, 0.03, 0.01, length (qqHit.yz))));\n    if (nn.z > 0.9 && qqHit.y < -0.03) col *= 0.3;\n  } else if (idObj == idWing) {\n    b = wSpan / (8. * fusLen);\n    b = mod (qqHit.x + 0.5 * b, b) - 0.5 * b;\n    col *= 1. + 0.1 * SmoothBump (-0.01, 0.01, 0.002, b);\n    if (abs (qqHit.x) > 0.7)\n       col *= 1. - 0.6 * SmoothBump (-0.128, -0.117, 0.002, qqHit.z);\n    if (qqHit.z < -0.125)\n       col *= 1. - 0.6 * SmoothBump (0.695, 0.705, 0.002, abs (qqHit.x));\n    if (qqHit.y * nn.y > 0.) {\n      qqHit.x = abs (qqHit.x) - 0.8;\n      qqHit.z -= 0.03;\n      col = mix (vec3 (0., 1., 0.), col,\n         (1. - 0.5 * SmoothBump (0.08, 0.12, 0.01, length (qqHit.xz))) *\n         (1. - 0.5 * SmoothBump (-0.01, 0.03, 0.01, length (qqHit.xz))));\n    }\n  } else if (idObj == idFin || idObj == idHstab) {\n    col *= 1. - 0.6 * SmoothBump (-0.062, -0.052, 0.002, qqHit.z);\n  } else if (idObj == idPipe || idObj == idNose || idObj == idStrut ||\n     idObj == idLeg || idObj == idAxl) {\n    col = vec3 (0.9, 0., 0.1);\n    spec = 0.4;\n  } else if (idObj == idCkpit) {\n    col = vec3 (0.2, 0.15, 0.05);\n  } else if (idObj == idPlt) {\n    col = vec3 (0.1, 0.07, 0.);\n    if (nn.z > 0.7) {\n      col *= 2.;\n      qqHit.x = abs (qqHit.x) - 0.015 * fusLen;\n      col *= (1. - 0.9 * SmoothBump (0.003, 0.01, 0.001, length (qqHit.xy)));\n    }\n  } else if (idObj == idWhl) {\n    if (length (qqHit.yz) < 0.07) col = vec3 (0.2, 0.2, 0.7);\n    else {\n      col = vec3 (0.02);\n      spec = 0.;\n    }\n  }\n  return vec4 (col, spec);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstHit, dstGrnd, dstObj, dstPropel, f, bk, sh;\n  int idObjT;\n  dstHit = dstFar;\n  dstGrnd = GrndRay (ro, rd);\n  idObj = -1;\n  dstPropel = TransObjRay (ro, rd);\n  if (idObj < 0) dstPropel = dstFar;\n  idObj = -1;\n  dstObj = ObjRay (ro, rd);\n  if (idObj < 0) dstObj = dstFar;\n  if (min (dstObj, dstGrnd) < dstPropel) dstPropel = dstFar;\n  idObjT = idObj;\n  if (dstObj < dstGrnd) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    idObj = idObjT;\n    col4 = FlyerCol (vn);\n    sh = ObjSShadow (ro, sunDir);\n    bk = max (dot (vn, - normalize (vec3 (sunDir.x, 0., sunDir.z))), 0.);\n    col = col4.rgb * (0.3 + 0.2 * bk  + 0.7 * sh * max (dot (vn, sunDir), 0.)) +\n       sh * col4.a * pow (max (0., dot (sunDir, reflect (rd, vn))), 64.);\n    dstHit = dstObj;\n  } else {\n    dstHit = dstGrnd;\n    if (dstHit < dstFar) {\n      ro += dstGrnd * rd;\n      vn = VaryNf (1.2 * ro, GrndNf (ro, dstHit), 1.);\n      col = (mix (vec3 (0.2, 0.4, 0.1), vec3 (0., 0.5, 0.),\n\t clamp (0.7 * Noisefv2 (ro.xz) - 0.3, 0., 1.))) *\n\t (0.1 + max (0., max (dot (vn, sunDir), 0.))) +\n\t 0.1 * pow (max (0., dot (sunDir, reflect (rd, vn))), 100.);\n      f = dstGrnd / dstFar;\n      f *= f;\n      col = mix (col, SkyBg (rd), clamp (f * f, 0., 1.));\n    } else col = SkyCol (ro, rd);\n  }\n  if (dstPropel < dstFar) col = vec3 (0.1) * (1. -\n     0.3 * SmoothBump (0.25, 0.27, 0.006,\n     length (qHitTransObj.xy) / fusLen)) + 0.7 * col;\n  if (dstHit < dstFar) {\n    f = dstHit / dstFar;\n    col = mix (col, SkyBg (rd), clamp (1.03 * f * f, 0., 1.));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid FlyerPM (float t)\n{\n  float tInterp = 100.;\n  float dt = 0.3 * flyVel;\n  flPos = TrackPath (t * flyVel);\n  vec3 fpF = TrackPath (t * flyVel + dt);\n  vec3 fpB = TrackPath (t * flyVel - dt);\n  vec3 vel = (fpF - fpB) / (2. * dt);\n  float vy = vel.y;\n  vel.y = 0.;\n  vec3 acc = (fpF - 2. * flPos + fpB) / (dt * dt);\n  acc.y = 0.;\n  vec3 va = cross (acc, vel) / length (vel);\n  vel.y = vy;\n  vec3 ort = vec3 (0., atan (vel.z, vel.x) - 0.5 * pi,\n     200. * length (va) * sign (va.y));\n  vec3 cr = cos (ort);\n  vec3 sr = sin (ort);\n  flMat = mat3 (cr.z, - sr.z, 0., sr.z, cr.z, 0., 0., 0., 1.) *\n     mat3 (1., 0., 0., 0., cr.x, - sr.x, 0., sr.x, cr.x) *\n     mat3 (cr.y, 0., - sr.y, 0., 1., 0., sr.y, 0., cr.y);\n}\n\nvec3 GlareCol (vec3 rd, vec3 sd, vec2 uv)\n{\n  vec3 col;\n  if (sd.z > 0.) {\n    vec3 e = vec3 (1., 0., 0.);\n    col = 0.2 * pow (sd.z, 8.) *\n       (1.5 * e.xyy * max (dot (normalize (rd + vec3 (0., 0.3, 0.)), sunDir), 0.) +\n        e.xxy * SmoothBump (0.04, 0.07, 0.07, length (uv - sd.xy)) +\n        e.xyx * SmoothBump (0.15, 0.2, 0.07, length (uv - 0.5 * sd.xy)) +\n        e.yxx * SmoothBump (1., 1.2, 0.07, length (uv + sd.xy)));\n  } else col = vec3 (0.);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n  uv.x *= iResolution.x / iResolution.y;\n  tCur = iTime;\n  mat3 vuMat;\n  vec3 ro, rd, vd, u, col;\n  float zmFac, pDist, f;\n  sunDir = normalize (vec3 (sin (0.2 * tCur), 1., cos (0.2 * tCur)));\n  fusLen = 1.;\n  wSpan = 1.2 * fusLen;\n  flyVel = 25.;\n  FlyerPM (tCur);\n  ro = vec3 (0., 10., 0.);\n  vd = flPos - ro;\n  pDist = length (vd);\n  vd = normalize (vd);\n  u = - vd.y * vd;\n  f = 1. / sqrt (1. - vd.y * vd.y);\n  vuMat = mat3 (f * vec3 (vd.z, 0., - vd.x), f * vec3 (u.x, 1. + u.y, u.z), vd);\n  zmFac = 3. + 4. * pDist / 50.;\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  col = ShowScene (ro, rd);\n  col += GlareCol (rd, vuMat * sunDir, uv);\n  fragColor = vec4 (col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtXGzs.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[266, 266, 290, 290, 337], [339, 339, 363, 363, 602], [604, 604, 629, 629, 808], [810, 810, 836, 836, 1130], [1132, 1132, 1153, 1153, 1413], [1415, 1415, 1444, 1444, 1646], [1648, 1648, 1687, 1687, 1894], [1896, 1896, 1953, 1953, 2036], [2038, 2038, 2068, 2068, 2142], [2144, 2144, 2177, 2177, 2204], [2206, 2206, 2249, 2249, 2322], [2324, 2324, 2366, 2366, 2417], [2419, 2419, 2478, 2478, 2582], [2584, 2584, 2630, 2630, 2677], [2974, 2974, 2996, 2996, 3084], [3086, 3086, 3118, 3118, 4300], [4302, 4302, 4328, 4328, 4487], [4489, 4489, 4512, 4512, 4970], [4972, 4972, 5006, 5006, 5543], [5545, 5545, 5576, 5576, 5749], [5751, 5751, 5788, 5788, 5990], [5992, 5992, 6019, 6019, 6114], [6116, 6116, 6154, 6154, 6335], [6337, 6337, 6373, 6373, 9460], [9462, 9462, 9484, 9484, 9585], [9587, 9587, 9620, 9620, 9823], [9825, 9825, 9846, 9846, 10069], [10071, 10071, 10108, 10108, 10319], [10321, 10321, 10345, 10345, 12177], [12179, 12179, 12214, 12214, 13800], [13802, 13802, 13826, 13826, 14515], [14517, 14517, 14560, 14560, 14991], [14993, 14993, 15050, 15050, 15779]], "test": "valid"}
{"id": "Xlf3DB", "name": "ngWaves03", "author": "netgrind", "description": "mouse moves stuff around", "tags": ["waves", "rgb", "netgrind"], "likes": 1, "viewed": 1175, "published": "Public API", "date": "1424687172", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = 6.0;\n    float i = iTime*.3;\n    vec4 o = vec4(0.0);\n\tvec2 uv = fragCoord.xy / iResolution.xy*scale;\n    uv-= scale*0.5;\n    uv = abs(uv);\n    uv+= iMouse.xy/iResolution.xy*10.0-5.0;\n    \n    mat2 m = mat2(cos(uv.x-i),sin(uv.x+i),cos(uv.y+i),cos(uv.y-i*.5));\n    uv = uv*m;\n    \n    float dist = length(uv);\n    float a = atan(uv.y,uv.x);\n    o.r = mod(dist,1.0);\n    o.g = mod(a,0.5)*2.0;\n    o.b = mod(uv.x+uv.y,1.0);\n    \n    o.rgb = (1.0-cos(o.rgb-0.5))*5.0;\n    vec3 c1 = vec3(sin(i)*.5+.5, cos(i)*.5+.5,sin(i*0.5+1.0)*.5+.5);\n    vec3 c2 = vec3(sin(i*2.0)*.5+.5,cos(i*.87+2.0)*.5+.5,sin(i*1.3)*.5+.5);\n    o.rgb = mix(c1,c2,o.rgb);\n    \n\tfragColor = o;\n}", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xlf3DB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[16, 16, 73, 73, 752]], "test": "valid"}
{"id": "Xlf3zf", "name": "DDE", "author": "eiffie", "description": "Marching thru an iso-mess using an extra DE calc to slow the march down only where needed. Left side is just a fudge factor slowing errrything down. It both penetrates and fails to march to the surface. Right side is perfection! :)", "tags": ["isosurface", "gradientmarch", "dde"], "likes": 10, "viewed": 1286, "published": "Public API", "date": "1423670655", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//DDE by eiffie (directional distance estimate using a gradient)\n//The idea is to find a method of optimal marching when analytic gradients fail (or are unknown).\n//This isn't it! But it is a first step. :)\n\n//We need to know how the surface changes in the direction we are marching so the first term is\n//how far ahead we should look based on an initial DE check. It is critical and highly dependant.\n//Second term is still a neccessary fudge factor :( \n//Third term is for comparison (left side). \n#define GRADIENT_DELTA 0.4\n#define FUDGE_FACTOR 0.5\n#define COMPARE_FUDGE_FACTOR 0.2\n\n\n#define time iTime\n#define size iResolution\n\n\nfloat DE(vec3 p0)\n{\n\tvec3 p=p0+sin(p0.yzx*4.0+2.4*sin(p0.zxy*5.0+time)+time*0.7)*0.5;\n\tfloat d=length(p)-1.0;\n\treturn d;\n}\nvec2 fragCoord;\nvec2 DDE(vec3 p, vec3 rd){\n\tfloat d1=DE(p);\n    if(fragCoord.x<size.x*0.5)return vec2(d1,d1*COMPARE_FUDGE_FACTOR);\n\tfloat dt=GRADIENT_DELTA*log(d1+1.0);\n\tfloat d2=DE(p+rd*dt);\n\tdt/=max(dt,d1-d2);\n\treturn vec2(d1,FUDGE_FACTOR*log(d1*dt+1.0));\n}\n\nfloat rndStart(vec2 co){return fract(sin(dot(co,vec2(123.42,117.853)))*412.453);}\n\nmat3 lookat(vec3 fw,vec3 up){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,up));return mat3(rt,cross(rt,fw),fw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 iFragCoord ){\n\tfloat pxl=4.0/size.y;//find the pixel size\n\tfloat tim=time*0.3;\n\tfragCoord = iFragCoord;\n\t//position camera\n\tvec3 ro=vec3(cos(tim),0.5,sin(tim))*3.0;\n\tvec3 rd=normalize(vec3((2.0*fragCoord.xy-size.xy)/size.y,2.0));\n\trd=lookat(-ro,vec3(0.0,1.0,0.0))*rd;\n\t//ro=eye;rd=normalize(dir);\n\tvec3 bcol=vec3(1.0);\n\t//march\n\t\n\tfloat t=DDE(ro,rd).y*rndStart(fragCoord.xy),d,od=1.0;\n\tvec4 col=vec4(0.0);//color accumulator\n\tfor(int i=0;i<64;i++){\n\t\tvec2 v=DDE(ro+rd*t,rd);\n\t\td=v.x;//DE(ro+rd*t);\n\t\tfloat px=pxl*(1.0+t);\n\t\tif(d<px){\n            vec3 mcol=0.5*abs(sin((ro+rd*t)*30.0));\n\t\t\tmcol+=mcol.gbr;\n\t\t\tmcol*=max(0.0,1.0-d/od)*10.0*exp(-t);\n\t\t\tif(d<0.0){\n\t\t\t\tfragColor=vec4(1.0,0.0,0.0,1.0);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfloat alpha=(1.0-col.w)*clamp(1.0-d/(px),0.0,1.0);\n\t\t\tcol+=vec4(clamp(mcol,0.0,1.0),1.0)*alpha;\n\t\t\tif(col.w>0.9)break;\n\t\t}\n\t\tod=d;\n\t\tt+=v.y;//d;\n\t\tif(t>10.0)break;\n\t}\n\tcol.rgb+=bcol*(1.0-clamp(col.w,0.0,1.0));\n\n\tfragColor=vec4(col.rgb,1.0);\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xlf3zf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[633, 633, 652, 652, 755], [772, 772, 798, 798, 1015], [1017, 1017, 1041, 1041, 1098], [1100, 1100, 1129, 1129, 1214], [1216, 1216, 1273, 1273, 2219]], "test": "valid"}
{"id": "XlfGDB", "name": "Moire Bounce", "author": "echophon", "description": "First shader.. still learning.  Builds up moire effects over time", "tags": ["2d", "basic", "moire"], "likes": 4, "viewed": 1050, "published": "Public", "date": "1424673888", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\t\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfloat distance = sqrt( pow(abs(uv[0]-0.5), 0.5) + pow(abs(uv[1]-0.5), abs(sin(iTime/5.)*0.025)) );\n\tfloat color = sin(distance*iTime*10.0) * cos(distance*iTime*0.05);\n\tfragColor = vec4(color, color, color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlfGDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 313]], "test": "valid"}
{"id": "XlfGDj", "name": "Line intersection interactive", "author": "the23", "description": "click on the canvas to set the second point", "tags": ["2d", "line"], "likes": 1, "viewed": 249, "published": "Public", "date": "1425048006", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float soft = 0.01;\nconst float lineWidth = 0.03;\nconst float pointWidth = 0.11;\n\nconst vec3 backgroundColor = vec3(0.05);\nconst vec3 gridColor = vec3(0.0, 0.0, 0.6);\nconst vec3 lineColor = vec3(0.2, 0.2, 1.0);\nconst vec3 pointColor = vec3(0.8, 0.9, 1.0);\nconst vec3 highlightColor = vec3(0.0, 0.0, 1.0);\n\n// define the visible area\n// - padding to match the screen-ratio might be added...\nconst vec2 bot = vec2(-4,-4);\nconst vec2 top = vec2(4,4);\n\nvec2 calcProjPoint(vec2 a, vec2 b, vec2 c)\n{\n    float d = dot(b - a, c - a) / length(b - a);\n    d /= length(b - a);\n    return a + d * (b - a);\n}\n\nvec3 drawDot(vec3 col, vec2 coord, vec2 p, float thickness)\n{\n    float dst = distance(coord, p);\n    dst = 1.0 - smoothstep(thickness - soft, thickness + soft, dst);\n    return mix(col, pointColor, dst);\n}\n\nvec3 drawDotAnimated(vec3 col, vec2 coord, vec2 p, float thickness)\n{\n    float dst = distance(coord, p);\n    float inside = dst;\n    dst = 1.0 - smoothstep(thickness - soft, thickness + soft, dst);\n    inside = inside / (thickness + soft)+ iTime * 0.5;\n    \n    vec3 color = mix(pointColor, highlightColor, sin(radians(inside*360.0))*0.5 + 0.5);\n    return mix(col, color, dst);\n}\n\nvec3 drawLine(vec3 col, vec2 coord, vec2 p1, vec2 p2, float thickness)\n{\n    float d = dot(coord - p1, p2 - p1) / length(p2 - p1);\n    d /= length(p2 - p1);\n    d = clamp(step(0.0, d) * d, 0.0, 1.0);\n    d = distance(p1 + d * (p2 - p1), coord);\n    \n    float dst = 1.0 - smoothstep(thickness - soft, thickness + soft, d);\n    \n    return mix(col, lineColor, dst);\n}\n\nvec3 drawLineDashed(vec3 col, vec2 coord, vec2 p1, vec2 p2, float thickness, float strips)\n{\n    float lenLine = length(p2 - p1);\n    float d = dot(coord - p1, p2 - p1) / lenLine;\n    d /= lenLine;\n    float seg = clamp(d, 0.0, 1.0);\n    \n    d = clamp(step(0.0, d) * d, 0.0, 1.0);\n    d = distance(p1 + d * (p2 - p1), coord);\n    \n    float dst = 1.0 - smoothstep(thickness - soft, thickness + soft, d);\n\n    float relLinePos = distance(coord, p1) / lenLine * dst;\n    \n    float pattern = step(0.5, mod((seg * strips - 0.25 - iTime), 1.0));\n    dst *= pattern;\n    \n    vec3 color = mix(pointColor, highlightColor, seg);\n    return mix(col, color, dst);\n}\n\nvec3 drawGrid(vec3 col, vec2 coord)\n{\n    float factor = distance(coord - 0.5, floor(coord)) + 0.25;\n    float anim = (sin(iTime * 2.0) * 0.5 + 0.5);\n    anim = anim * 0.4 + 0.6;\n    factor = pow(factor, 8.0 * anim);\n    return mix(col, gridColor, factor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 area = top - bot;\n    \n    float ratioScreen = iResolution.x/ iResolution.y;\n    float ratioArea = area.x / area.y;\n    \n    vec2 padding = vec2(ratioScreen / ratioArea, ratioArea /ratioScreen);\n    padding = max(vec2(0.0), area * padding - area);\n\n    area += padding;\n    vec2 coord = uv * area + bot - (padding * 0.5);\n\n    vec2 a = vec2(0,0);\n\tvec2 b = vec2(bot.x - (padding.x * 0.5),0);\n    \n    vec2 c = (iMouse.xy/ iResolution.xy)* area + bot - (padding * 0.5);\n\n    if (c.x > 0.0)\n    {\n\t\tb.x += area.x;\n    }\n    \n    vec2 d = calcProjPoint(a, b, c);\n    \n    vec3 col = backgroundColor;\n    \n    col = drawGrid(col, coord);\n\n    col = drawLine(col, coord, a, b, lineWidth);\n    col = drawLine(col, coord, a, c, lineWidth);\n    \n    col = drawLineDashed(col, coord, c, d, 0.03, 2.0);\n\n    col = drawDot(col, coord, a, pointWidth);\n    col = drawDot(col, coord, b, pointWidth);\n    col = drawDot(col, coord, c, pointWidth);\n\n    col = drawDotAnimated(col, coord, d, 0.14);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlfGDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[454, 454, 498, 498, 601], [603, 603, 664, 664, 809], [811, 811, 880, 880, 1192], [1194, 1194, 1266, 1266, 1560], [1562, 1562, 1654, 1654, 2219], [2221, 2221, 2258, 2258, 2479], [2481, 2481, 2538, 2538, 3609]], "test": "valid"}
{"id": "XlfGDS", "name": "Random Experiments", "author": "martin", "description": "Experiments in random number generation", "tags": ["random"], "likes": 1, "viewed": 236, "published": "Public", "date": "1424578545", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Random_1(vec2 uv, float seed)\n{\n\treturn fract(uv.x * uv.y * seed);\n}\n\nfloat Random_Seed(vec2 uv, float seed)\n{\n    //Seed normalization experiments (all of these look bad)\n\t//float fixedSeed = fract(seed / 491.0);\n    //float fixedSeed = mod(seed, 491.0) / 491.0;\n    //float fixedSeed = tan(fract(seed));\n    //float fixedSeed = fract(tan(1.0 / fract(seed)));\n    //float fixedSeed = tan(1.0 / seed);\n    //float fixedSeed = fract(seed);\n    float fixedSeed = abs(seed) + 1.0;\n    \n\treturn fixedSeed;\n}\n\nfloat Random_StackOverflow(vec2 uv, float seed)\n{\n    const vec2 r = vec2(\n     \t23.1406926327792690,  \t// e^pi (Gelfond's constant)\n     \t2.6651441426902251\t\t// 2^sqrt(2) (Gelfondâ€“Schneider constant)\n   \t);\n  \treturn fract( cos( mod( 123456789.0, 1e-7 + 256.0 * dot(uv,r) ) ) );  \n}\n\nfloat Random_Seeded(vec2 uv, float seed)\n{\n    //Fix our seed to never be negative, and never be near zero\n    float fixedSeed = abs(seed) + 1.0;\n    \n    //Mix our seed into the irrational vector\n    vec2 r = vec2(23.1406926327792690, 2.6651441426902251) * fixedSeed;\n    \n    //Dot product with the irrationals (add 1 to ensure uv is not near zero)\n    float x = dot(uv + vec2(1, 1), r);\n \n    //This is the same as the Random_StackOverflow last line, but produces very bad noise\n    //return fract( cos( mod( 123456789.0, 1e-7 + 256.0 * x ) ) ); \n    \n    //Regular but very complicated pattern\n    //return fract(x);\n    \n    //This is a little more random\n    //return fract(sin(x) * 100.);\n    \n    //So a bigger number must be a lot more random!\n    return fract(sin(x) * 43758.5453);\n}\n\n//Reddit suggestion (https://www.reddit.com/r/devblogs/comments/2wridq/random_gibberish_generating_random_numbers_on_the/cotve0i)\nfloat Random_Cosmologician(vec2 uv, float seed)\n{\n    vec3 r = vec3(12.345, 21.098, 38.902);\n\tvec3 p3 = vec3(uv, seed);\n\treturn fract(sin(dot(r, p3)) * 12345.67);\n}\n\nfloat Random_Final(vec2 uv, float seed)\n{\n    float fixedSeed = abs(seed) + 1.0;\n\tfloat x = dot(uv, vec2(12.9898,78.233) * fixedSeed);\n\treturn fract(sin(x) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(\n        Random_Final(uv, iTime * 2.0),\n        Random_Final(uv, iTime * 3.0),\n        Random_Final(uv, iTime * 4.0),\n        1\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlfGDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 74], [76, 76, 116, 444, 509], [511, 511, 560, 560, 801], [803, 803, 845, 909, 1596], [1598, 1728, 1777, 1777, 1892], [1894, 1894, 1935, 1935, 2066], [2068, 2068, 2125, 2125, 2322]], "test": "valid"}
{"id": "XlfGzf", "name": "mandelbulb slice", "author": "kejran", "description": "uguu", "tags": ["3d", "fractal"], "likes": 3, "viewed": 206, "published": "Public", "date": "1423655551", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define iterations 100\n#define power 7.0\n\n#define rot_speed 0.1\n#define trans_speed 0.7\n\nvec3 vector_pow(in vec3 vec, float p) {\n    float r = length(vec);\n    float phi = p * atan(vec.y, vec.x);\n    float theta = p * atan(length(vec.xy), vec.z);\n    \n  // return vec3(vec.x*vec.x-vec.y*vec.y, 2.0*vec.x*vec.y, 0.0);\n    \n    return pow(r, p) * vec3(\n        sin(theta) * cos(phi),\n        sin(theta) * sin(phi),\n        cos(theta));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat aspect = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 coords = 1.15 * vec3(aspect * (2.0*uv.x-1.0), 2.0*uv.y-1.0, 0.0);\n    //coords.y;\n    //coords += vec3(-0.5, 0.0, 0.0);\n    \n    coords.z = sin(trans_speed*iTime);\n    \n    coords.xy = vec2(\n        coords.x*cos(rot_speed*iTime)-coords.y*sin(rot_speed*iTime), \n        coords.x*sin(rot_speed*iTime)+coords.y*cos(rot_speed*iTime));\n    \n    vec3 pos = vec3(0.0);\n    \n    int its = -1;\n    \n    for (int it = 0; it < iterations; it++) {\n    \t\n        pos = vector_pow(pos, power) + coords;\n        \n        if (dot(pos, pos) > 4.0) {\n            its = it;\n            break;\n        }\n    }\n    \n\tfragColor = vec4((its==-1)?vec3(1.0):pow(vec3(float(its-2)/float(iterations-2)), vec3(2.0, 0.8, 20.0)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlfGzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 89, 128, 128, 435], [437, 437, 494, 494, 1307]], "test": "valid"}
{"id": "XlfGzl", "name": "arches", "author": "public_int_i", "description": "arches\n", "tags": ["arches"], "likes": 2, "viewed": 123, "published": "Public", "date": "1424129422", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n#define MAX_STEP 512\n#define EPILSON 0.001\n#define NORMAL_EPILSON 0.1\n#define FOG_START 0.7\n\n\n\nconst float viewDist = 200.0;\nfloat viewDist8 = viewDist*0.8;\nfloat fogViewMult = 1.0/FOG_START;\n\n\n\nvec3 lightDir = normalize(vec3(40.0,40.0,40.0));\n\nvec3 cameraUp = vec3(0.0,1.0,0.0);\nvec3 cameraRight,cameraPosition,cameraDirection;\n\n\n\n\n//calculate normal of triangle\nvec3 calculateNormal(in vec3 p1, in vec3 p2, in vec3 p3) {\n    vec3 u = p2-p1;\n    vec3 v = p3-p1;\n    \n    return cross(u,v);\n}\n\n\n\n//distance functions\n//a lot are take from iq's site http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat sphere(in vec3 p, in float radius) {//signed\n    return length(p)-radius;\n}\nvec3 sphereNormal(in vec3 p, in float radius) {\n    return normalize(vec3(\n        sphere(vec3(p.x+NORMAL_EPILSON,p.y,p.z),radius)-sphere(vec3(p.x-NORMAL_EPILSON,p.y,p.z),radius),\n        \n\t\tsphere(vec3(p.x,p.y+NORMAL_EPILSON,p.z),radius)-sphere(vec3(p.x,p.y-NORMAL_EPILSON,p.z),radius),\n        \n        sphere(vec3(p.x,p.y,p.z+NORMAL_EPILSON),radius)-sphere(vec3(p.x,p.y,p.z-NORMAL_EPILSON),radius)\n        ));\n}\n\nfloat roundBox(in vec3 p, in vec3 boxExt, in float round) {//unsigned\n    return length(max(abs(p)-boxExt,0.0))-round;\n}\nvec3 roundBoxNormal(in vec3 p, in vec3 boxExt, in float round) {\n    return normalize(vec3(\n        roundBox(vec3(p.x+NORMAL_EPILSON,p.y,p.z), boxExt, round)-roundBox(vec3(p.x-NORMAL_EPILSON,p.y,p.z),boxExt,round),\n        \n\t\troundBox(vec3(p.x,p.y+NORMAL_EPILSON,p.z), boxExt, round)-roundBox(vec3(p.x,p.y-NORMAL_EPILSON,p.z),boxExt,round),\n        \n        roundBox(vec3(p.x,p.y,p.z+NORMAL_EPILSON), boxExt, round)-roundBox(vec3(p.x,p.y,p.z-NORMAL_EPILSON),boxExt,round)\n        ));\n}\n\nfloat box(in vec3 p, in vec3 boxExt) {//unsigned\n    return length(max(abs(p)-boxExt,0.0));\n}\nvec3 boxNormal(in vec3 p, in vec3 boxExt) {\n    return normalize(vec3(\n        box(vec3(p.x+NORMAL_EPILSON,p.y,p.z), boxExt)-box(vec3(p.x-NORMAL_EPILSON,p.y,p.z),boxExt),\n        \n\t\tbox(vec3(p.x,p.y+NORMAL_EPILSON,p.z), boxExt)-box(vec3(p.x,p.y-NORMAL_EPILSON,p.z),boxExt),\n        \n        box(vec3(p.x,p.y,p.z+NORMAL_EPILSON), boxExt)-box(vec3(p.x,p.y,p.z-NORMAL_EPILSON),boxExt)\n        ));\n}\n\n\n\nfloat torus(in vec3 p, in vec2 size) {//signed\n \treturn length(\n        \t\tvec2(length(p.xz)-size.x,p.y)\n                 )-size.y;\n}\nvec3 torusNormal(in vec3 p, in vec2 size) {\n    return normalize(vec3(\n        torus(vec3(p.x+NORMAL_EPILSON,p.y,p.z), size)-torus(vec3(p.x-NORMAL_EPILSON,p.y,p.z),size),\n        \n\t\ttorus(vec3(p.x,p.y+NORMAL_EPILSON,p.z), size)-torus(vec3(p.x,p.y-NORMAL_EPILSON,p.z),size),\n        \n        torus(vec3(p.x,p.y,p.z+NORMAL_EPILSON), size)-torus(vec3(p.x,p.y,p.z-NORMAL_EPILSON),size)\n        ));\n}\n\n\nfloat capsuleLine(in vec3 p, in vec3 v1, in vec3 v2, in float r) {//signed\n    vec3 pa = p - v1, ba = v2 - v1;\n    return length(pa - ba * clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 )) - r;\n}\nvec3 capsuleLineNormal(in vec3 p, in vec3 v1, in vec3 v2, in float r) {\n    return normalize(vec3(\n        capsuleLine(vec3(p.x+NORMAL_EPILSON,p.y,p.z), v1, v2, r)-capsuleLine(vec3(p.x-NORMAL_EPILSON,p.y,p.z), v1, v2, r),\n        \n\t\tcapsuleLine(vec3(p.x,p.y+NORMAL_EPILSON,p.z), v1, v2, r)-capsuleLine(vec3(p.x,p.y-NORMAL_EPILSON,p.z), v1, v2, r),\n        \n        capsuleLine(vec3(p.x,p.y,p.z+NORMAL_EPILSON), v1, v2, r)-capsuleLine(vec3(p.x,p.y,p.z-NORMAL_EPILSON),v1,v2,r)\n        ));\n}\n\n\nfloat cylinder(in vec3 p, in vec2 size) {//signed\n\tvec2 d = abs(vec2(length(p.xz),p.y)) - size;\n\treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nvec3 cylinderNormal(in vec3 p, in vec2 size) {\n    return normalize(vec3(\n        cylinder(vec3(p.x+NORMAL_EPILSON,p.y,p.z), size)-cylinder(vec3(p.x-NORMAL_EPILSON,p.y,p.z), size),\n        \n\t\tcylinder(vec3(p.x,p.y+NORMAL_EPILSON,p.z), size)-cylinder(vec3(p.x,p.y-NORMAL_EPILSON,p.z), size),\n        \n        cylinder(vec3(p.x,p.y,p.z+NORMAL_EPILSON), size)-cylinder(vec3(p.x,p.y,p.z-NORMAL_EPILSON), size)\n        ));\n}\n\n\n\n//ray tracing functions\nfloat rayBox(in vec3 rayPos, in vec3 rayDir, in vec3 boxMin, in vec3 boxMax, out float tmin, out float tmax) {\n    vec3 dirFrac = vec3(1.0)/rayDir;\n    float d = 0.0;\n\n    vec3 tMinExt = (boxMin-rayPos)*dirFrac;\n    vec3 tMaxExt = (boxMax-rayPos)*dirFrac;\n    \n    tmin = max(max(min(tMinExt.x, tMaxExt.x), min(tMinExt.y, tMaxExt.y)), min(tMinExt.z, tMaxExt.z));\n    tmax = min(min(max(tMinExt.x, tMaxExt.x), max(tMinExt.y, tMaxExt.y)), max(tMinExt.z, tMaxExt.z));\n\n    \n    if (tmax < 0.0) {\n        return 0.0;\n    }\n\n    if (tmin > tmax) {\n        return 0.0;\n    }\n\n    return tmin;    \n}\n\n\nfloat raySphere(in vec3 p, in vec3 dir, in float sphereRad) {\n    \n    float c = dot(p, p) - (sphereRad*sphereRad);\n    float b = dot(dir, p);\n\n    float d = b*b - c;\n    float t = -b - sqrt(abs(d));\n    \n    if (!(d < 0.0 || t < 0.0)) {\n        return t;\n    } else {\n    \treturn 0.0;\n    }\n    \n}\n\n\n\n\n//scene functions\n\nfloat s;\n\nconst vec3 NE = vec3(NORMAL_EPILSON,0.0,0.0);\n\nconst vec2 colRepeat = vec2(12.0,16.0);\nfloat columns(in vec3 p) {\n    vec2 pos = mod(p.xz,colRepeat)-0.5*colRepeat;\n    float powY = -pow(p.y,sin(iTime*0.2)+1.0);\n    pos.x += sign(pos.x)*powY;\n    pos.y += sign(pos.y)*powY;\n    \n    return length(max(abs(pos)-vec2(0.5),0.0))*(s/viewDist8+0.2);\n}\nvec3 columnsNorm(in vec3 p) {\n    return normalize(vec3(columns(p+NE.xyz)-columns(p-NE.xyz),\n                     columns(p+NE.yxz)-columns(p-NE.yxz),\n                     columns(p+NE.yzx)-columns(p-NE.yzx)));\n}\n\n\nvoid scene(in vec3 rayPos, out int hitId, out float hitDist) {\n    float db;\n    \n    hitId = 0;\n\thitDist = rayPos.y+3.0;\n    \n    db = columns(rayPos);\n    if (db < hitDist) {\n        hitId = 1;\n        hitDist = db;\n    }\n}\n\n\nvoid trace(in vec3 rayStartPos, in vec3 rayStartDir, in float maxDist, out int hitId, out float hitDist) {\n    \n    s = 0.0;\n    vec3 rayPos;\n    \n    for (int i = 0; i < MAX_STEP; i++) {\n        //get new ray pos\n        rayPos = rayStartPos+rayStartDir*s;\n        \n\t\tscene(rayPos,hitId,hitDist);\n        \n        if (hitDist < EPILSON*s) {\n            hitDist = s;\n            return;\n        }\n        \n\n        s += hitDist;\n        if (s >= maxDist) {\n            break;\n        }\n    }\n    \n    hitDist = maxDist;\n    hitId = -1;//hit id is -1 if nothing is hit\n}\n\n\n\n\n\n//AMBIENT OCCLUSION\n\n#define AO_ITERATIONS 2\n#define AO_PRECISION 0.2\n#define AO_INTENSITY 0.7\n#define AO_ATTEN 0.5\n\nfloat ao(in vec3 p, in vec3 norm) {\n\tfloat sum = 0.0;\n\tfloat atten = 1.0;\n\tfloat s = AO_PRECISION;\n    \n    int hitId = 0;\n    float hitDist = 0.0;\n    \n\tfor (int i = 0; i < AO_ITERATIONS; i++) {\n        scene(p+norm*s,hitId,hitDist);\n        \n\t\tsum += (s-hitDist)*atten;\t\t\n\t\ts += AO_PRECISION;\t\n\t\tatten *= AO_ATTEN;\n\t}\n\t\n\treturn 1.0-max(0.0,sum*AO_INTENSITY);\n}\n\n\n//main\n\nconst vec3 PLANE_NORM = vec3(0.0,1.0,0.0);\n\nconst vec2 CENTER_UV = vec2(0.5,0.5);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //calculate camera\n    cameraPosition = vec3(iTime*1.4,0.0,iTime*3.0);\n    \n    cameraDirection = normalize(vec3(sin(iTime*0.5)*0.3,-0.2+sin(iTime*0.3)*0.1,1.0));\n    \n    \n\tvec2 cUv = (fragCoord.xy / iResolution.xy)-CENTER_UV;\n    cUv.x *= iResolution.x/iResolution.y;\n\t\n    //camera vectors\n    cameraRight = cross(cameraDirection,cameraUp);   \n   \n        \n  \tvec3 rayStartDir = normalize((cUv.x*cameraRight +\n                  \t\t\t\tcUv.y*cameraUp +\n        \t\t  \t\t\t\tcameraPosition + cameraDirection)-cameraPosition);\n    vec3 rayStartPos = cameraPosition;\n    \n\n    //scene\n    \n    int hitId;\n    float hitDist;\n    trace(rayStartPos,rayStartDir,viewDist,hitId,hitDist);\n    \n    vec3 hitPos = rayStartPos+rayStartDir*hitDist;\n    \n    \n    if (hitId == 0) {\n        vec4 samp = vec4(0.6)+texture(iChannel2,hitPos.xz*0.5)*0.2;\n        vec3 norm = vec3(0.0,1.0,0.0);\n        \n\t\tfragColor = samp*0.2+samp*ao(hitPos,norm);\n        return;\n    }\n    \n    if (hitId == 1) {\n        vec3 norm = columnsNorm(hitPos);\n        vec4 samp = vec4(0.6)+texture(iChannel2,hitPos.xz+hitPos.yy)*0.2;\n        \n        fragColor = samp*0.2+max(0.0,dot(-cameraDirection,norm))*samp;\n        return;\n    }\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "XsfGzn", "previewfilepath": "/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlfGzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[335, 366, 424, 424, 494], [623, 623, 665, 673, 704], [705, 705, 752, 752, 1119], [1121, 1121, 1180, 1190, 1241], [1242, 1242, 1306, 1306, 1727], [1729, 1729, 1767, 1777, 1822], [1823, 1823, 1866, 1866, 2218], [2222, 2222, 2260, 2268, 2354], [2355, 2355, 2398, 2398, 2750], [2753, 2753, 2819, 2827, 2940], [2941, 2941, 3012, 3012, 3430], [3433, 3433, 3474, 3482, 3582], [3583, 3583, 3629, 3629, 4002], [4006, 4030, 4140, 4140, 4622], [4625, 4625, 4686, 4686, 4923], [5044, 5044, 5070, 5070, 5302], [5303, 5303, 5332, 5332, 5515], [5518, 5518, 5580, 5580, 5743], [5746, 5746, 5852, 5852, 6315], [6438, 6438, 6473, 6473, 6800], [6894, 6894, 6951, 6974, 8146]], "test": "error"}
{"id": "XllGRl", "name": "Surface Splats", "author": "iq", "description": "Stochastic sampling a point cloud. A points cloud is generated per pixel, and the points are projected into screen space. A z/depth buffer mechanism resolves visibility, and then shading happens in a deferred manner.", "tags": ["3d", "pointcloud", "projection", "rasterization", "points", "splat", "stochastic"], "likes": 70, "viewed": 5610, "published": "Public API", "date": "1424307327", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Stochastic rasterization of splats.\n//\n// Random points are generated at the surface of some parametric objects,\n// and the points are projected into screen space. A z/depth buffer\n// resolves visibility, and then shading happens in a deferred manner.\n//\n// I think I first saw this technique in Texel's entry to js01k a few\n// years ago.\n//\n// The object probability distribution is proportional to the area of\n// the object's surface area.\n\nvec3 sphere( in vec2 t )\n{\n    float y = -1.0 + 2.0*t.y;\n    vec2 q = vec2( t.x*6.2831, acos(y) );\n    return vec3( cos(q.x)*sin(q.y), y, sin(q.x)*sin(q.y) );\n}\n\nvec3 cylinder( in vec2 t )\n{\n    float q = t.x*6.2831;\n    return vec3( 0.5*cos(q), -1.0 + 4.0*t.y, 0.5*sin(q) );\n}\n\nvec3 quad( in vec2 t )\n{\n    return 3.0*vec3( -1.0+2.0*t.x, 0.0, -1.0+2.0*t.y );\n}\n\nfloat rand( in float p )  { return fract( p/0.123454); }\nvec3  rand( in vec3  p )  { return fract( p/0.123454); }\n\nfloat hash1( in float n ) { return fract(sin(n)*43758.5453123); }\nvec2  hash2( in float n ) { return fract(sin(vec2(n,n+3.1))*43758.5453123); }\nvec3  hash3( in float n ) { return fract(sin(vec3(n,n+3.1,n+5.7))*43758.5453123); }\n\nmat4 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat4( cu.x, cu.y, cu.z, 0.0,\n                 cv.x, cv.y, cv.z, 0.0,\n                 cw.x, cw.y, cw.z, 0.0,\n                 ro.x, ro.y, ro.z, 1.0 );\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\n//==============================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // pixel    \n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    // camera\n    float an = iTime;\n    vec3  ro = 4.0*normalize(vec3(cos(an), 0.0, sin(an)));\n\tvec3  ta = vec3(0.0, 0.0, 0.0);\n    \n    // camera-to-world and world-to-camera transform\n    mat4 c2w = setCamera( ro, ta, 0.0 );\n    mat4 w2c = inverse(c2w);\n    \n    vec3 col = vec3( 0.0 );\n\n    float dither = smoothstep( -0.1, 0.1, sin(iTime) );\n    \n    float off = 0.5 + hash1( iTime*0.0 + dither*dot(fragCoord.xy,vec2(113.0,317.0)) );\n    vec3 t = hash3( off );\n    \n    \n    float fz = 1e10;         // depth buffer\n    vec2  uv = vec2(-1.0);                  \n    float fi = -1.0;\n    for( int i=0; i<1024; i++ )\n    {\n        // pick a random point on the surface of the scene\n\n        // area of the sphere   = 12.6\n        // area of the plane    = 36.0\n        // area of the cylinder = 15.7\n        vec3 w; float id;\n             if( t.z<((15.7     )/64.3) ) { id=0.0; w = vec3(2.0, 0.0,0.0)+cylinder( t.xy ); }\n        else if( t.z<((15.7+36.0)/64.3) ) { id=1.0; w = vec3(0.0,-1.0,0.0)+quad(     t.xy ); }\n        else                              { id=2.0; w =                    sphere(   t.xy ); }\n            \n        // convert to camera space\n        vec3 q = (w2c * vec4(w,1.0)).xyz;\n            \n        // if in front of clipping plane\n        if( q.z>0.01 )\n        {\n#if 0            \n            // project            \n            vec2 s = q.xy/q.z;\n\n            // splat with depth test        \n            if( (q.z*q.z*dot2(s-p))<0.02 && q.z<fz )\n#else\n            // project and splat with depth test, WITHOUT divisions!!\n            if( dot2(q.xy-p*q.z)<0.02 && q.z<fz )\n#endif\n            {\n                fz = q.z;\n                uv = t.xy;\n                fi = id;\n            }\n        }\n        \n        // generate new random sample        \n        t = rand( t );\n    }\n    \n    // if splat\n    if( fi>-0.5 )\n    {\n        // compute position, normals and occlusion\n        vec3 pos, nor; float occ;\n        \n             if( fi<0.5 ) { pos = vec3(2.0, 0.0,0.0)+cylinder( uv ); nor = normalize( cylinder( uv )*vec3(1.0,0.0,1.0) ); occ = 0.5 + 0.5*smoothstep(-1.0,1.0,pos.y ); }\n        else if( fi<1.5 ) { pos = vec3(0.0,-1.0,0.0)+quad(     uv ); nor = vec3(0.0,1.0,0.0);                             occ = smoothstep(0.0,2.0,length(pos.xz)) * smoothstep(0.0,2.0,length(pos.xz-vec2(2.0,0.0)));}\n        else              { pos =                    sphere(   uv ); nor = normalize(sphere( uv ));                       occ = 0.5 + 0.5*nor.y; }\n\n        // shade        \n        col = textureLod( iChannel0, 2.0*uv, 0.0 ).xyz * occ + 0.1*nor.yxz*occ;\n        \n        // gamma\n        col = sqrt( col );\n    }\n    \n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "XsXGRn", "previewfilepath": "/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XllGRl.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[571, 571, 597, 597, 731], [733, 733, 761, 761, 848], [850, 850, 874, 874, 932], [934, 934, 961, 961, 990], [991, 991, 1018, 1018, 1047], [1049, 1049, 1076, 1076, 1114], [1115, 1115, 1142, 1142, 1192], [1193, 1193, 1220, 1220, 1276], [1278, 1278, 1330, 1330, 1638], [1640, 1640, 1665, 1665, 1684]], "test": "error"}
{"id": "XllGzl", "name": "ngWaves00", "author": "netgrind", "description": "simple phasing waves", "tags": ["waves", "sine", "matrix", "netgrind"], "likes": 2, "viewed": 1222, "published": "Public API", "date": "1424347890", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n#define TWO_PI (PI*2.0)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv-=0.5;\n    uv*=40.0;\n    \n    float a = atan(uv.y,uv.x);\n    mat2 hyper = mat2(\n       -cos(a), sin(a), \n       sin(a), cos(a)\n    );\n    uv = abs(mod(uv*hyper+iTime,vec2(2.0))-1.0);\n\t\n\tfragColor = vec4(0.5+0.5*cos(iTime*0.1),uv.x,0.5+0.5*sin(iTime),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XllGzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 44, 101, 101, 407]], "test": "valid"}
{"id": "Xls3WS", "name": "Daily: 26/2/15", "author": "hughsk", "description": "Repetition with differences", "tags": ["rays", "cube", "column", "smin"], "likes": 18, "viewed": 298, "published": "Public", "date": "1424978327", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat fog(\n  const float dist,\n  const float density\n) {\n  const float LOG2 = -1.442695;\n  float d = density * dist;\n  return 1.0 - clamp(exp2(d * d * LOG2), 0.0, 1.0);\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n//------------------------------------------------------------------------\n// Camera\n//\n// Move the camera. In this case it's using time and the mouse position\n// to orbitate the camera around the origin of the world (0,0,0), where\n// the yellow sphere is.\n//------------------------------------------------------------------------\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 0.3*iTime + 10.0*mouseX;\n\tcamPos = vec3(3.5*sin(an)+sin(iTime*0.1)*15.0,1.1+sin(iTime*0.25),3.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n\n//------------------------------------------------------------------------\n// Background \n//\n// The background color. In this case it's just a black color.\n//------------------------------------------------------------------------\nvec3 doBackground( void )\n{\n    vec3 c = vec3(1.2, 0.9, 0.975) * 0.05;\n    \n    c = mix(c, vec3(0.9, 0.95, 1.3) * 0.3, 1.0 - gl_FragCoord.y/iResolution.y*1.);\n    \n    return c;\n    //  - fragCoord.y/iResolution.y*0.01;\n}\n    \n//------------------------------------------------------------------------\n// Modelling \n//\n// Defines the shapes (a sphere in this case) through a distance field, in\n// this case it's a sphere of radius 1.\n//------------------------------------------------------------------------\nfloat doModel( vec3 p )\n{\n    vec3 idx = vec3(floor(abs(p.xz - 0.5)), 0.5);\n\tp.xz = mod(p.xz + 0.5, 1.) - 0.5;\n    float h = sin(length(idx.xy * 0.5) + iTime * 1.5) * 0.6;\n    float d = sdBox(p, vec3(0.05, h, 0.05));\n    \n    d = smin(d, sdPlane(p, normalize(vec4(0, 1, 0, 0))), 0.035);\n    \n    return d;\n}\n\n//------------------------------------------------------------------------\n// Material \n//\n// Defines the material (colors, shading, pattern, texturing) of the model\n// at every point based on its position and normal. In this case, it simply\n// returns a constant yellow color.\n//------------------------------------------------------------------------\nvec3 doMaterial( in vec3 pos, in vec3 nor )\n{\n    return vec3(0.15,0.2,0.23);\n}\n\n//------------------------------------------------------------------------\n// Lighting\n//------------------------------------------------------------------------\nfloat calcSoftshadow( in vec3 ro, in vec3 rd );\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec3 mal )\n{\n    vec3 lin = vec3(0.0);\n\n    // key light\n    //-----------------------------\n    vec3  lig = normalize(vec3(1.0,0.7,0.9));\n    float dif = max(dot(nor,lig),0.0);\n    float sha = 0.0; if( dif>0.01 ) sha=calcSoftshadow( pos+0.01*nor, lig );\n    lin += dif*vec3(4.00,4.00,4.00)*sha;\n\n    // ambient light\n    //-----------------------------\n    lin += vec3(0.50,0.50,0.50);\n\n    \n    // surface-light interacion\n    //-----------------------------\n    vec3 col = mal*lin;\n\n\n    return col;\n}\n\nfloat calcIntersection( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 20.0;           // max trace distance\n\tconst float precis = 0.001;        // precission of the intersection\n    float h = precis*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for( int i=0; i<90; i++ )          // max number of raymarching iterations is 90\n    {\n        if( h<precis||t>maxd ) break;\n\t    h = doModel( ro+rd*t );\n        t += h;\n    }\n\n    if( t<maxd ) res = t;\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.002;             // precision of the normal computation\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( pos + v1*eps ) + \n\t\t\t\t\t  v2*doModel( pos + v2*eps ) + \n\t\t\t\t\t  v3*doModel( pos + v3*eps ) + \n\t\t\t\t\t  v4*doModel( pos + v4*eps ) );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.0005;                 // selfintersection avoidance distance\n\tfloat h = 1.0;\n    for( int i=0; i<40; i++ )         // 40 is the max numnber of raymarching steps\n    {\n        h = doModel(ro + rd*t);\n        res = min( res, 48.0*h/t );   // 64 is the hardness of the shadows\n\t\tt += clamp( h, 0.02, 2.0 );   // limit the max and min stepping distances\n    }\n    return clamp(res,0.0,1.0);\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m.x );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = doBackground();\n\n\t// raymarch\n    float t = calcIntersection( ro, rd );\n    if( t>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\n        // materials\n        vec3 mal = doMaterial( pos, nor );\n\n        col = mix(doLighting( pos, nor, rd, t, mal ), col, fog(t, max(0., 0.2 - pos.y * 0.3)));\n\t}\n\n\t//-----------------------------------------------------\n\t// postprocessing\n    //-----------------------------------------------------\n    // gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n    col.g = smoothstep(0., 1.05, col.g);\n    col.r = smoothstep(0.1, 1.1, col.r);\n    col *= 1. + dot(p, p*.08);\n\t   \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xls3WS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 134], [136, 136, 192, 192, 306], [308, 308, 339, 339, 377], [379, 379, 410, 410, 506], [508, 508, 541, 567, 598], [600, 932, 1015, 1015, 1170], [1173, 1404, 1431, 1431, 1625], [1631, 1913, 1938, 1938, 2220], [2222, 2575, 2620, 2620, 2654], [2867, 2867, 2951, 2951, 3443], [3445, 3445, 3495, 3495, 3912], [3914, 3914, 3946, 3946, 4358], [4360, 4360, 4408, 4408, 4834], [4836, 4836, 4900, 4900, 5078], [5080, 5080, 5137, 5137, 6500]], "test": "valid"}
{"id": "Xls3zf", "name": "Harmonograph??", "author": "eiffie", "description": "So I search harmonograph and see it described one way but then find a picture of this little cutie which seems to work differently. I wanted to see what pictures it draws. Don't ask how the paper stays horizontal. I just didn't want to calc the pen height", "tags": ["harmonograph"], "likes": 17, "viewed": 1424, "published": "Public API", "date": "1423931351", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Harmonograph?? by eiffie\n\n#define time iTime\n#define size iResolution\n#define tex iChannel0\n\n#define penAmpX 0.56\n#define penAmpY 0.45\n#define penFreq 1.0\n#define penPhase 0.0\n#define penDamp 0.01\n#define paperAmpX -0.81\n#define paperAmpY 0.45\nfloat paperFreq=0.66;\n#define paperPhase 0.3\n#define paperDamp 0.01\n#define TAO 6.283\n\nvec2 penPos(float t){float a=t*penFreq*TAO+penPhase;return vec2(penAmpX*cos(a),penAmpY*sin(a)*exp(-t*penDamp));}\nvec2 paperPos(float t){float a=t*paperFreq*TAO+paperPhase;return vec2(paperAmpX*cos(a),paperAmpY*sin(a)*exp(-t*paperDamp));}\n\nvec3 pen,paper;\nvoid init(float t){\n\tfloat c=1.0+floor(t/20.0);\n\tc=mod(c,5.0);\n\tif(c==3.0)c=-1.0;\n\tt=mod(t,20.0);\n\tpaperFreq=c/3.0+0.01;\n\tvec2 pn=penPos(t),pp=paperPos(t);\n\tpen=normalize(vec3(pn.x,5.0,pn.y));\n\tpaper=normalize(vec3(pp.x,5.0,pp.y));\n}\n\nvec2 rotate(vec2 v, float angle) {return cos(angle)*v+sin(angle)*vec2(v.y,-v.x);}\nvec2 kaleido(vec2 v, float power){return rotate(v,floor(.5+atan(v.x,-v.y)*power/TAO)*TAO/power);}\nvec2 Tube(vec3 pa, vec3 ba){float h=dot(pa,ba)/dot(ba,ba);return vec2(length(pa-ba*clamp(h,0.0,1.0)),h);}\nfloat ROCyl(in vec3 z, vec3 r){return length(vec2(max(abs(z.y)-r.y,0.0),length(z.xz)-r.x))-r.z;}\nint id=0;\nfloat DE(in vec3 p0){\n\tvec3 p=p0;\n\tp.xz=kaleido(p.xz,3.0*0.79);\n\tp.z+=0.66;\n\tvec2 v=Tube(p,vec3(0.0,-2.0,-0.3));\n\tfloat dLeg=v.x-0.05+v.y*0.025;\n\tfloat dTop=(length(max(abs(p0)-vec3(0.4+p0.z*0.25,0.0,0.7),0.0))-0.05)*0.9;\n\tp=p0;p.z-=0.5;\n    float dWt=length(p+pen*abs(penFreq));\n\tfloat dB=ROCyl(p,vec3(0.035,0.075,0.01));\n\tv=Tube(p-pen,-pen*2.5);\n\tfloat dPenP=v.x-0.01;\n\tv=Tube(p-pen*0.55+vec3(0.02,0.0,-0.5),vec3(0.0,0.0,-1.55));\n\tfloat dPenA=v.x-0.01;\n\tp.z+=1.0;\n    dWt=min(dWt,length(p+paper*abs(paperFreq)));\n\tdB=min(dB,ROCyl(p,vec3(0.035,0.075,0.01)));\n\tv=Tube(p-pen*0.51,vec3(0.0,0.25,0.0));\n\tdWt=min(dWt-0.1,v.x-0.01);\n\tv=Tube(p-paper*0.49,-paper*2.0);\n\tfloat dPaperP=v.x-0.01;\n\tfloat dPaper=length(max(abs(p-paper*0.5)-vec3(0.2,0.005,0.2),0.0));\n\tfloat dW=min(dLeg,dTop);\n\tdB=min(dB,min(dPenP,min(dPaperP,dPenA)));\n\tif(id<0){\n\t\tif(dW<dB && dW<dPaper && dW<dWt)id=1;\n\t\telse if(dB<dPaper && dB<dWt)id=2;\n\t\telse if(dPaper<dWt)id=3;\n        else id=4;\n\t}\n\treturn min(dW,min(dB,min(dWt,dPaper)));\n}\n\nfloat rnd(vec2 c){return fract(sin(dot(vec2(1.317,19.753),c))*413.7972);}\nfloat rndStart(vec2 px){\n\treturn 0.5+0.5*rnd(px);\n}\nvec3 Sky(vec3 rd){//what sky??\n\treturn vec3(0.7,0.8,1.0)*(0.5+0.5*rd.y);\n}\nvec2 F(float t){\n\treturn penPos(t)-paperPos(t);\n}\nvec2 DF(vec2 p, float t){\n\tfloat d1=length(p-F(t)), dt=0.1*log(d1+1.0), d2=length(p-F(t+dt));\n\tdt/=max(d1-d2,dt*0.1);\n\treturn vec2(min(d1,d2),0.1*log(d1*dt+1.0));\n}\nvec3 HarmonographIt(vec2 p, float et, float px){\n\tfloat t=0.0,d=100.0;\n\tfor(int i=0;i<200;i++){\n\t\tvec2 v=DF(p,t);\n\t\td=min(d,v.x);\n\t\tt+=v.y;\n\t\tif(t>et)break;\n\t}\n\td=smoothstep(0.0,10.0*px,d);\n\treturn vec3(sqrt(d),d*d,d);\n}\nfloat shadao(vec3 ro, vec3 rd, float px, float rv){//pretty much IQ's SoftShadow\n\tfloat res=1.0,d,t=2.0*px*rv;\n\tfor(int i=0;i<12;i++){\n\t\td=max(px,DE(ro+rd*t)*1.5);\n\t\tt+=d;\n\t\tres=min(res,d/t+t*0.5);\n\t}\n\treturn res;\n}\n\nvec3 L;\nvec3 Color(vec3 ro, vec3 rd, float t, float px, vec3 col, float rv){\n\tro+=rd*t;\n\tid=-1;float d=DE(ro);\n\tvec2 e=vec2(px*t,0.0);\n\tvec3 dn=vec3(DE(ro-e.xyy),DE(ro-e.yxy),DE(ro-e.yyx));\n\tvec3 dp=vec3(DE(ro+e.xyy),DE(ro+e.yxy),DE(ro+e.yyx));\n\tvec3 N=(dp-dn)/(length(dp-vec3(d))+length(vec3(d)-dn));\n\tvec3 R=reflect(rd,N);\n\tvec3 lc=vec3(1.0,0.9,0.8),sc,rc=Sky(R);\n\tif(id==1){sc=texture(tex,ro.zx+vec2(0.5)).rgb;\n\t}else if(id==2){sc=vec3(0.8,0.4,0.2);\n\t}else if(id==3)sc=HarmonographIt((ro.xz+vec2(0.0,0.5)-paper.xz*0.5)*10.0, mod(time,20.0)-0.1,px*t);\n    else sc=vec3(0.2);\n\tfloat h=0.2*dot(N,R);\n\tsc*=vec3(0.8+h,1.0,0.8-h);\n\tfloat sh=clamp(shadao(ro,L,px*t,rv)+0.4,0.0,1.0);\n\tsh=sh*(0.5+0.5*dot(N,L)+abs(rd.y)*0.2);\n\tvec3 scol=sh*lc*(sc+rc*pow(max(0.0,dot(R,L)),4.0));\n\tcol=mix(scol,col,clamp(d/(px*t),0.0,1.0));\n\treturn col;\n}\nmat3 lookat(vec3 fw){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,vec3(0.0,1.0,0.0)));return mat3(rt,cross(rt,fw),fw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat px=1.0/size.y;\n\tL=normalize(vec3(0.4,0.8,-0.6));\n\tinit(time);\n\tvec3 ro=vec3(cos(time*0.45)*3.0,1.5+sin(time*0.2)*0.75,sin(time*0.5)*3.0);\n\tvec3 rd=lookat(vec3(0.0,0.4,-0.5)-ro)*normalize(vec3((2.0*fragCoord.xy-size.xy)/size.y,3.0));\n\t//ro=eye;rd=normalize(dir);\n    float rv=rndStart(fragCoord);\n\tfloat t=DE(ro)*rv,d=0.0,dm=10.0,tm=0.0;\n\tvec3 col=Sky(rd);\n\tfor(int i=0;i<64;i++){\n\t\tt+=d;\n\t\td=DE(ro+rd*t);\n\t\tif(d<dm){dm=d;tm=t;}\n\t\tif(t>10.0 || d<0.0001)break;\n\t}\n\tcol=Color(ro,rd,tm,px,col,rv);\n\tfragColor = vec4(1.5*col,1.0);\n}\n", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xls3zf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[333, 333, 354, 354, 445], [446, 446, 469, 469, 570], [588, 588, 607, 607, 821], [823, 823, 857, 857, 904], [905, 905, 939, 939, 1002], [1003, 1003, 1031, 1031, 1108], [1109, 1109, 1140, 1140, 1205], [1216, 1216, 1237, 1237, 2219], [2221, 2221, 2239, 2239, 2294], [2295, 2295, 2319, 2319, 2346], [2347, 2347, 2365, 2377, 2421], [2422, 2422, 2438, 2438, 2471], [2472, 2472, 2497, 2497, 2636], [2637, 2637, 2685, 2685, 2857], [2858, 2858, 2909, 2938, 3073], [3083, 3083, 3151, 3151, 3906], [3907, 3907, 3928, 3928, 4028], [4030, 4030, 4087, 4087, 4622]], "test": "error"}
{"id": "Xls3zX", "name": " Volumetric whitney rose", "author": "strimbob", "description": "from https://www.shadertoy.com/view/4dsSRM, and https://www.shadertoy.com/view/Xdf3zB", "tags": ["raymarching", "spiral", "media", "homogenous", "whitney"], "likes": 2, "viewed": 282, "published": "Public", "date": "1423867359", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// https://www.shadertoy.com/view/Xdf3zB\n\n// Implementation of equi-angular sampling for raymarching through homogenous media\n// 2013 @sjb3d\n\n#define PI\t\t\t\t3.1415926535\n#define SIGMA\t\t\t0.3\n#define STEP_COUNT\t\t16\n#define DIST_MAX\t\t10.0\n#define LIGHT_POWER\t\t12.0\n#define SURFACE_ALBEDO\t0.7\nconst float rad = 0.9;\nconst float dots = 64.0;\nconst float duration = 180.0;\nconst vec3 colorsep = vec3(0,2.09,4.18);\n\nconst float PI2 = 2.0*3.1415926535897932384626433832795;\n// shamelessly stolen from iq!\nfloat hash(float n)\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nvoid sampleCamera(vec2 u, out vec3 rayOrigin, out vec3 rayDir, in vec2 fragCoord)\n{\n\tvec2 filmUv = (fragCoord.xy + u)/iResolution.xy;\n\t\n\tfloat tx = (2.0*filmUv.x - 1.0)*(iResolution.x/iResolution.y);\n\tfloat ty = (1.0 - 2.0*filmUv.y);\n\tfloat tz = 0.0;\n\t\n\trayOrigin = vec3(0.0, 0.0, 5.0);\n\trayDir = normalize(vec3(tx, ty, tz) - rayOrigin);\n}\n\nvoid intersectSphere(\n\tvec3 rayOrigin,\n\tvec3 rayDir,\n\tvec3 sphereCentre,\n\tfloat sphereRadius,\n\tinout float rayT,\n\tinout vec3 geomNormal)\n{\n\t// ray: x = o + dt, sphere: (x - c).(x - c) == r^2\n\t// let p = o - c, solve: (dt + p).(dt + p) == r^2\n\t//\n\t// => (d.d)t^2 + 2(p.d)t + (p.p - r^2) == 0\n\t//vec3 p = vec3(0.,0.,0.);\n //   rayOrigin =  vec3(0.,0.,0.);\n\n    \n    \n    //sphereCentre = vec3(star_pos.x,star_pos.y,0.);    /// this is pisotion \n   vec3 p = rayOrigin - sphereCentre;\n\tvec3 d = rayDir;\n\tfloat a = dot(d, d);\n\tfloat b = 2.0*dot(p, d);\n\tfloat c = dot(p, p) - sphereRadius*sphereRadius;\n\tfloat q = b*b - 4.0*a*c;\n\tif (q > 0.0) {\n\t\tfloat denom = 0.5/a;\n\t\tfloat z1 = -b*denom;\n\t\tfloat z2 = abs(sqrt(q)*denom);\n\t\tfloat t1 = z1 - z2;\n\t\tfloat t2 = z1 + z2;\n\t\tbool intersected = false;\n\t\tif (0.0 < t1 && t1 < rayT) {\n\t\t\tintersected = true;\n\t\t\trayT = t1;\n\t\t} else if (0.0 < t2 && t2 < rayT) {\n\t\t\tintersected = true;\n\t\t\trayT = t2;\n\t\t}\n\t\tif (intersected) {\n\t\t\tgeomNormal = normalize(p + d*rayT);\n\t\t}\n\t}\n}\n\nvoid intersectScene(\n\tvec3 rayOrigin,\n\tvec3 rayDir,\n    vec2 fragCoord,\n\tinout float rayT,\n\tinout vec3 geomNormal)\n{\n    \n        \n      vec2 pq = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n  float tm = mod(iTime,duration)/duration;\n  pq.y *= iResolution.y/iResolution.x;\n\n      vec3 gradient = vec3(0.0);\nvec2 star_pos;\n  for (float i=1.0; i<=dots; i++)\n  {\n    float i2pi = i*PI2;\n    float ang = mod(tm*i2pi, PI2);\n    float amp = rad*(1.0-(i-1.0)/dots);\n    float cang = i2pi/dots;\n    float fade = 0.7 - pow(smoothstep(0.0,1.0,ang),2.0)*0.5;\n     star_pos = vec2(cos(ang) * amp, -sin(ang) * amp);\n    gradient += (cos(cang+colorsep) + 1.0/2.0) * ((fade / 384.0) / pow(length(star_pos - pq), 1.5)) * fade;\n  \n  \tintersectSphere(rayOrigin, rayDir, vec3(star_pos.x,  star_pos.y, 0.3), 0.03, rayT, geomNormal);\n\n  \n  }\n    \n\n}\n\nvoid sampleUniform(\n\tfloat u,\n\tfloat maxDistance,\n\tout float dist,\n\tout float pdf)\n{\n\tdist = u*maxDistance;\n\tpdf = 1.0/maxDistance;\n}\n\nvoid sampleScattering(\n\tfloat u,\n\tfloat maxDistance,\n\tout float dist,\n\tout float pdf)\n{\n\t// remap u to account for finite max distance\n\tfloat minU = exp(-SIGMA*maxDistance);\n\tfloat a = u*(1.0 - minU) + minU;\n\n\t// sample with pdf proportional to exp(-sig*d)\n\tdist = -log(a)/SIGMA;\n\tpdf = SIGMA*a/(1.0 - minU);\n}\n\nvoid sampleEquiAngular(\n\tfloat u,\n\tfloat maxDistance,\n\tvec3 rayOrigin,\n\tvec3 rayDir,\n\tvec3 lightPos,\n\tout float dist,\n\tout float pdf)\n{\n\t// get coord of closest point to light along (infinite) ray\n\tfloat delta = dot(lightPos - rayOrigin, rayDir);\n\t\n\t// get distance this point is from light\n\tfloat D = length(rayOrigin + delta*rayDir - lightPos);\n\n\t// get angle of endpoints\n\tfloat thetaA = atan(0.0 - delta, D);\n\tfloat thetaB = atan(maxDistance - delta, D);\n\t\n\t// take sample\n\tfloat t = D*tan(mix(thetaA, thetaB, u));\n\tdist = delta + t;\n\tpdf = D/((thetaB - thetaA)*(D*D + t*t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n//\tvec3 lightPos = vec3(0.8*sin(iTime*7.0/4.0), 0.8*sin(iTime*5.0/4.0), 0.0);\n    vec3 lightPos = vec3(0.0, 0.0, 0.0);\n\tvec3 lightIntensity = vec3(LIGHT_POWER)*200.0;\n\tvec3 surfIntensity = vec3(SURFACE_ALBEDO/PI);\n\tvec3 particleIntensity = vec3(1.0/(900.0*PI));\n\t\n\tvec3 rayOrigin, rayDir;\n\tsampleCamera(vec2(0.5, 0.5), rayOrigin, rayDir, fragCoord);\n\t\n\n\t\n\tvec3 col = vec3(0.0);\n\tfloat t = DIST_MAX;\n\t{\n\t\tvec3 n;\n\t\tintersectScene(rayOrigin, rayDir, fragCoord, t, n);\n\t\t\n\t\tif (t < DIST_MAX) {\n\t\t\t// connect surface to light\n\t\t\tvec3 surfPos = rayOrigin + t*rayDir;\n\t\t\tvec3 lightVec = lightPos - surfPos;\n\t\t\tvec3 lightDir = normalize(lightVec);\n\t\t\tvec3 cameraDir = -rayDir;\n\t\t\tfloat nDotL = dot(n, lightDir);\n\t\t\tfloat nDotC = dot(n, cameraDir);\n\t\t\t\n\t\t\t// only handle BRDF if entry and exit are same hemisphere\n\t\t\tif (nDotL*nDotC > 0.0) {\n\t\t\t\tfloat d = length(lightVec);\n\t\t\t\tfloat trans = exp(-SIGMA*(d + t));\n\t\t\t\tfloat geomTerm = abs(nDotL)/dot(lightVec, lightVec);\n\t\t\t\tcol = surfIntensity*lightIntensity*geomTerm*trans;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfloat offset = hash(fragCoord.y*iResolution.x + fragCoord.x + iTime);\n\tfor (int stepIndex = 0; stepIndex < STEP_COUNT; ++stepIndex) {\n\t\tfloat u = (float(stepIndex)+offset)/float(STEP_COUNT);\n\t\t\n\t\t// sample along ray from camera to surface\n\t\tfloat x;\n\t\tfloat pdf;\n\n\t\t\tsampleEquiAngular(u, t, rayOrigin, rayDir, lightPos, x, pdf);\n\t\n\t\t\n\t\t// adjust for number of ray samples\n\t\tpdf *= float(STEP_COUNT); /// looks amazing!!!!\n\t\t\n\t\t// connect to light and check shadow ray\n\t\tvec3 particlePos = rayOrigin + x*rayDir;\n        //vec3 particlePos = vec3(1.0,0.0,0.0);\n\t\tvec3 lightVec = lightPos - particlePos;\n\t\tfloat d = length(lightVec);\n\t\tfloat t2 = d;\n\t\tvec3 n2;\n\t\tintersectScene(particlePos, normalize(lightVec), fragCoord, t2, n2);\n\t\t\n\t\t// accumulate particle response\n\t\tif (t2 == d) {\n\t\t\tfloat trans = exp(-SIGMA*(d + x));\n\t\t\tfloat geomTerm = 1.0/dot(lightVec, lightVec);\n\t\t\tcol += SIGMA*particleIntensity*lightIntensity*geomTerm*trans/pdf;\n\t\t}\n\t}\n\n\n\n\t\n\tcol = pow(col, vec3(1.0/2.2));\n\t\n\tfragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xls3zX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[465, 496, 517, 517, 559], [561, 561, 644, 644, 900], [902, 902, 1040, 1344, 1907], [1909, 1909, 2025, 2025, 2737], [2739, 2739, 2823, 2823, 2872], [2874, 2874, 2961, 3008, 3184], [3186, 3186, 3321, 3382, 3767]], "test": "valid"}
{"id": "XlsGDS", "name": "ngWaves04", "author": "netgrind", "description": "see line 9/10 for some mouse control", "tags": ["waves", "sine", "netgrind"], "likes": 1, "viewed": 1105, "published": "Public API", "date": "1424837533", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float j = 10.0;\n    float i = iTime*0.5;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv-=0.5;\n    float a = atan(uv.y/uv.x);\n    \n    //vec2 p = iMouse.xy/ iResolution.xy;\n    vec2 p = vec2(sin(i),cos(i))*0.3+0.5;\n    \n    float d = distance(uv,p-.5)*j;\n    float d2 = distance(uv,1.0-p-.5)*j;\n    \n    vec4 c = vec4(0.0);\n    c.b = sin((a+d)*j+i);\n    c.g = sin((a+d2)*j+i);\n    c.r = cos((a+d+d2)*j+i);\n    \n    c = vec4(sin(c.r+i)*0.5+0.5,sin(c.b-i*0.5)*0.5+0.5,cos(c.g+i*0.66)*0.5+0.5,1.0);\n    \n\tfragColor = c;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlsGDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 581]], "test": "valid"}
{"id": "XlsGRl", "name": "Plane From Point Cloud", "author": "paniq", "description": "fit a plane to a point cloud using least squares via singular value decomposition (SVD); toggle INVERSE_ITER_EIGEN for a cheaper computation of the tangent space only", "tags": ["pca"], "likes": 25, "viewed": 3217, "published": "Public API", "date": "1424328467", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// fit a plane to a point cloud using least squares via singular value decomposition (SVD)\n// the technique is called PCA (Principle Component Analysis)\n\n// number of random points to track\n// you need at least 3 or ... well.\n// less points need more sweeps.\n#define POINT_COUNT 13\n\n// set to 1 to see some mightly fine plane fittin'\n#define SHAPE_CLOUD 0\n\n// plane needs to orient towards smallest eigenvalue, so leave this on\n#define SORT_EIGENVALUES 1\n\n// SVD parts are public domain\n\n// for some reason, too many sweeps ruin the anisotropic distribution\n// of the eigenvalues; so higher is not always better.\n#define SVD_NUM_SWEEPS 6\n\n// use approximate eigensolver instead\n#define INVERSE_ITER_EIGEN 0\n\n// GLSL prerequisites\n\n#define IN(t,x) in t x\n#define OUT(t, x) out t x\n#define INOUT(t, x) inout t x\n#define rsqrt inversesqrt\n\n#define SWIZZLE_XYZ(v) v.xyz\n            \n// SVD\n////////////////////////////////////////////////////////////////////////////////\n\nconst float Small_Number = 1.e-3;\nconst float Tiny_Number = 1.e-20;\n\nvoid givens_coeffs_sym(float a_pp, float a_pq, float a_qq, OUT(float,c), OUT(float,s)) {\n    if (a_pq == 0.0) {\n        c = 1.0;\n        s = 0.0;\n        return;\n    }\n    float tau = (a_qq - a_pp) / (2.0 * a_pq);\n    float stt = sqrt(1.0 + tau * tau);\n    float tan = 1.0 / ((tau >= 0.0) ? (tau + stt) : (tau - stt));\n    c = rsqrt(1.0 + tan * tan);\n    s = tan * c;\n}\n\nvoid svd_rotate_xy(INOUT(float,x), INOUT(float,y), IN(float,c), IN(float,s)) {\n    float u = x; float v = y;\n    x = c * u - s * v;\n    y = s * u + c * v;\n}\n\nvoid svd_rotateq_xy(INOUT(float,x), INOUT(float,y), INOUT(float,a), IN(float,c), IN(float,s)) {\n    float cc = c * c; float ss = s * s;\n    float mx = 2.0 * c * s * a;\n    float u = x; float v = y;\n    x = cc * u - mx + ss * v;\n    y = ss * u + mx + cc * v;\n}\n\nvoid svd_rotate01(INOUT(mat3,vtav), INOUT(mat3,v)) {\n    if (vtav[0][1] == 0.0) return;\n    \n    float c, s;\n    givens_coeffs_sym(vtav[0][0], vtav[0][1], vtav[1][1], c, s);\n    svd_rotateq_xy(vtav[0][0],vtav[1][1],vtav[0][1],c,s);\n    svd_rotate_xy(vtav[0][2], vtav[1][2], c, s);\n    vtav[0][1] = 0.0;\n    \n    svd_rotate_xy(v[0][0], v[0][1], c, s);\n    svd_rotate_xy(v[1][0], v[1][1], c, s);\n    svd_rotate_xy(v[2][0], v[2][1], c, s);\n}\n\nvoid svd_rotate02(INOUT(mat3,vtav), INOUT(mat3,v)) {\n    if (vtav[0][2] == 0.0) return;\n    \n    float c, s;\n    givens_coeffs_sym(vtav[0][0], vtav[0][2], vtav[2][2], c, s);\n    svd_rotateq_xy(vtav[0][0],vtav[2][2],vtav[0][2],c,s);\n    svd_rotate_xy(vtav[0][1], vtav[1][2], c, s);\n    vtav[0][2] = 0.0;\n    \n    svd_rotate_xy(v[0][0], v[0][2], c, s);\n    svd_rotate_xy(v[1][0], v[1][2], c, s);\n    svd_rotate_xy(v[2][0], v[2][2], c, s);\n}\n\nvoid svd_rotate12(INOUT(mat3,vtav), INOUT(mat3,v)) {\n    if (vtav[1][2] == 0.0) return;\n    \n    float c, s;\n    givens_coeffs_sym(vtav[1][1], vtav[1][2], vtav[2][2], c, s);\n    svd_rotateq_xy(vtav[1][1],vtav[2][2],vtav[1][2],c,s);\n    svd_rotate_xy(vtav[0][1], vtav[0][2], c, s);\n    vtav[1][2] = 0.0;\n    \n    svd_rotate_xy(v[0][1], v[0][2], c, s);\n    svd_rotate_xy(v[1][1], v[1][2], c, s);\n    svd_rotate_xy(v[2][1], v[2][2], c, s);\n}\n\nfloat svd_off(IN(mat3,a)) {\n    return sqrt(2.0 * ((a[0][1] * a[0][1]) + (a[0][2] * a[0][2]) + (a[1][2] * a[1][2])));\n}\n\n\nvoid svd_solve_sym(IN(mat3,a), OUT(vec3,sigma), INOUT(mat3,v)) {\n    // assuming that A is symmetric: can optimize all operations for \n    // the lower left triagonal\n    mat3 vtav = a;\n    // assuming V is identity: you can also pass a matrix the rotations\n    // should be applied to\n    // U is not computed\n    for (int i = 0; i < SVD_NUM_SWEEPS; ++i) {\n        if (svd_off(vtav) < Small_Number)\n            continue;\n        svd_rotate01(vtav, v);\n        svd_rotate02(vtav, v);\n        svd_rotate12(vtav, v);        \n    }\n    sigma = vec3(vtav[0][0],vtav[1][1],vtav[2][2]);    \n}\n\n// QEF\n////////////////////////////////////////////////////////////////////////////////\n\nvoid qef_add(\n    IN(vec3,p),\n    IN(vec3,masspoint),\n    INOUT(mat3,ATA)) {\n    p -= masspoint;\n    ATA[0][0] += p.x * p.x;\n    ATA[0][1] += p.x * p.y;\n    ATA[0][2] += p.x * p.z;\n    ATA[1][1] += p.y * p.y;\n    ATA[1][2] += p.y * p.z;\n    ATA[2][2] += p.z * p.z;\n}\n\nvoid swap(inout float a, inout float b) {\n    float x = a;\n    a = b;\n    b = x;\n}\n\nvoid swap_vec3(inout vec3 a, inout vec3 b) {\n    vec3 x = a;\n    a = b;\n    b = -x;\n}\n\nmat3 transp(mat3 m) {\n    return mat3(\n        \tm[0][0], m[1][0], m[2][0],\n        \tm[0][1], m[1][1], m[2][1],\n        \tm[0][2], m[1][2], m[2][2]\n        );\n}\n\n// approximate eigensolver for smallest eigenvalue\n// tuned by ryg\n\nconst float singularEps = 2.0 * 1.192092896e-7; // float32 epsilon, *2 to have a bit of margin\n\n// QR factorization using MGS\n// store 1 / diag elements in diag of R since that's what we need\nbool QR(IN(mat3,m),OUT(mat3,q),OUT(mat3,r)) {\n    q[0] = normalize(m[0]);\n    q[1] = normalize(m[1] - dot(m[1], q[0])*q[0]);\n    q[2] = cross(q[0], q[1]);\n\n    float d0 = dot(m[0], q[0]);\n    float d1 = dot(m[1], q[1]);\n    float d2 = dot(m[2], q[2]);\n    float maxd = max(max(abs(d0), abs(d1)), abs(d2));\n    float mind = min(min(abs(d0), abs(d1)), abs(d2));\n\n    // Are we numerically singular? (This test is written to work\n    // in the presence of NaN/Inf; using >= won't work right.)\n    if (!(maxd * singularEps < mind))\n        return false;\n    \n    r[0] = vec3(1.0 / d0, 0.0, 0.0);\n    r[1] = vec3(dot(m[1],q[0]), 1.0 / d1, 0.0);\n    r[2] = vec3(dot(m[2],q[0]), dot(m[2],q[1]), 1.0 / d2);\n    return true;\n}\n\n// matrix a must be upper triangular\n// with main diagonal storing reciprocal of actual vals\nvec3 solve_Ux_b(IN(mat3,a), IN(vec3,b)) {\n    float x2 = b[2] * a[2][2];\n    float x1 = (b[1] - a[2][1]*x2) * a[1][1];\n    float x0 = (b[0] - a[1][0]*x1 - a[2][0]*x2) * a[0][0];\n    return vec3(x0,x1,x2);\n}    \n\n// rayleigh quotient iteration from Q R matrices\nvoid rayleigh_quot(IN(mat3,a), INOUT(float,mu), INOUT(vec3, x)) {\n    mat3 q, r;\n    vec3 y = x;\n    for (int i = 0; i < 5; ++i) {\n        x = y / length(y);\n        if (!QR(a - mat3(mu), q, r))\n            break;\n        y = solve_Ux_b(r, x * q);\n        mu = mu + 1.0 / dot(y,x);\n    }\n}\n\n// inverse iter to find EV closest to mu\nvoid inverse_iter(IN(mat3,a), INOUT(float,mu), INOUT(vec3, x)) {\n    mat3 q, r;\n\n    // If a - mat3(mu) is singular, we already have an eigenvector!\n    if (!QR(a - mat3(mu), q, r))\n        return;\n\n    // If you know eigenvalues aren't too large/small, can skip\n    // normalize here. (It's only there to present over-/underflow.)\n    // Normalizing once at the end (before calc of mu) works fine.\n    for (int i = 0; i < 4; ++i)\n        x = normalize(solve_Ux_b(r, x * q));\n\n    mu = dot(x, a*x);\n}\n\nvec3 orthogonal(vec3 v)\n{\n    return abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0)\n                               : vec3(0.0, -v.z, v.y);\n}\n\n\nmat3 qef_solve(IN(mat3,ATA), OUT(vec3,sigma)) {\n#if INVERSE_ITER_EIGEN    \n    ATA[1][0] = ATA[0][1];\n    ATA[2][0] = ATA[0][2];\n    ATA[2][1] = ATA[1][2];\n    \n    vec3 e0 = vec3(1.0);    \n    float mu = 0.0; \n    // so the problem with rayleigh is that it really likes to latch on to\n    // the eigenvalue with largest absolute value.\n    // better to use normal inverse iteration if we want the EV closest to 0!\n    //rayleigh_quot(a, mu, x);\n \n    // once to get close to smallest EV, second pass to polish\n    inverse_iter(ATA, mu, e0);\n    inverse_iter(ATA, mu, e0);\n\n    mat3 iATA = inverse(ATA);\n    vec3 e1 = vec3(1.0);\n    float mu2 = 0.0;\n    inverse_iter(iATA, mu2, e1);\n    inverse_iter(iATA, mu2, e1);\n    \n\n    //vec3 e1 = orthogonal(e0);\n    vec3 e2 = cross(e0,e1);\n    sigma = vec3(1.0,1.0,max(0.01,sqrt(mu)*0.5));\n    return mat3(e2,e1,e0);\n#else // SVD\n    mat3 V = mat3(1.0);\n    \n    svd_solve_sym(ATA, sigma, V);\n    V = transp(V);\n    \n#if SORT_EIGENVALUES    \n    if (sigma[0] < sigma[1]) {\n        swap(sigma[0],sigma[1]);\n        swap_vec3(V[0],V[1]);\n    }\n    if (sigma[0] < sigma[2]) {\n        swap(sigma[0],sigma[2]);\n        swap_vec3(V[0],V[2]);\n    }\n    if (sigma[1] < sigma[2]) {\n        swap(sigma[1],sigma[2]);\n        swap_vec3(V[1],V[2]);\n    }\n#endif    \n    sigma = vec3(sqrt(sigma[0]),sqrt(sigma[1]),sqrt(sigma[2]))*0.5;\n    \n    return V;\n#endif\n}\n\n// uncomment for a cross section view\n//#define CROSS_SECTION\n\n//------------------------------------------------------------------------\n// Camera\n//\n// Move the camera. In this case it's using time and the mouse position\n// to orbitate the camera around the origin of the world (0,0,0), where\n// the yellow sphere is.\n//------------------------------------------------------------------------\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 10.0*mouseX;\n\tcamPos = vec3(4.5*sin(an),2.0,4.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n\n//------------------------------------------------------------------------\n// Background \n//\n// The background color. In this case it's just a black color.\n//------------------------------------------------------------------------\nvec3 doBackground( void )\n{\n    return vec3( 0.0, 0.0, 0.0);\n}\n\nvec3 min3(vec3 a, vec3 b) {\n    return (a.x <= b.x)?a:b;\n}\n\nvec3 max3(vec3 a, vec3 b) {\n    return (a.x > b.x)?a:b;\n}\n\nvoid rotate_xy(inout float x, inout float y, in float a) {\n    float c = cos(a);\n    float s = sin(a);\n    float u = x; float v = y;\n    x = c * u - s * v;\n    y = s * u + c * v;\n}\n\n// Fractional Brownian Motion code by IQ.\n\nfloat noise( float x, float y )\n{\n\treturn sin(1.5*x)*sin(1.5*y);\n}\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\nfloat fbm4( float x, float y )\n{\n    vec2 p = vec2( x, y );\n    float f = 0.0;\n    f += 0.5000*noise( p.x, p.y ); p = m*p*2.02;\n    f += 0.2500*noise( p.x, p.y ); p = m*p*2.03;\n    f += 0.1250*noise( p.x, p.y ); p = m*p*2.01;\n    f += 0.0625*noise( p.x, p.y );\n    return f/0.9375;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nvec3 hue2rgb(float hue) {\n    return clamp( \n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, \n        0.0, 1.0);\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec3 rgb = hue2rgb(c.x);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n\n//------------------------------------------------------------------------\n// Modelling \n//\n// Defines the shapes (a sphere in this case) through a distance field\n//------------------------------------------------------------------------\n\n#define POINT_PT_R 0.05\n#define AXIS_PT_R 0.01\n#define CENTER_PT_R 0.15\n\nvec3 points[POINT_COUNT];\nvec3 center;\nmat3 orientation;\nvec3 sigma;\n\nvoid update_points() {\n\tmat3 ATA = mat3(0.0);\n\tvec4 pointaccum = vec4(0.0);\n    \n    float t = iTime*0.05;\n    for (int i = 0; i < POINT_COUNT; ++i) {\n        vec3 f = float(i) * vec3(1.0,3.0,5.0);\n        points[i] = vec3(fbm4(f.y+t,f.z+t),fbm4(f.x+t,f.z+t),fbm4(f.x+t,f.y+t))*3.0;\n#if SHAPE_CLOUD        \n        points[i].x *= 0.21;\n        float d = points[i].z + points[i].y;        \n        points[i].z = mix(points[i].z, d, 0.9);\n        points[i].y = mix(points[i].y, d, 0.5);\n#endif\n        pointaccum += vec4(points[i],1.0);\n    }\n    \n    center = pointaccum.xyz / pointaccum.w;    \n\n    for (int i = 0; i < POINT_COUNT; ++i) {\n\t    qef_add(points[i], center, ATA);\n    }\n    \n    orientation = qef_solve(ATA, sigma);\n}\n\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nvec3 doModel2( vec3 p ) {\n    vec3 s = vec3(sphere(p - points[0], POINT_PT_R),0.9,1.0);\n    for (int i = 1; i < POINT_COUNT; ++i) {\n        s = min3(s, vec3(sphere(p - points[i], POINT_PT_R),0.9,1.0));\n    }\n    \n    s = min3(s, vec3(sdCapsule(p, center, center + orientation[0]*sigma.x, AXIS_PT_R),0.0,1.0));\n    s = min3(s, vec3(sdCapsule(p, center, center + orientation[1]*sigma.y, AXIS_PT_R),0.33,1.0));\n    s = min3(s, vec3(sdCapsule(p, center, center + orientation[2]*sigma.z, AXIS_PT_R),0.66,1.0));\n    \n    s = min3(s, vec3(udRoundBox((p - center) * orientation, vec3(sigma.x,sigma.y,0.005), 0.0),0.0,0.0));\n    \n  \treturn s;\n}\n\nfloat doModel( vec3 p ) {\n    return doModel2(p).x;\n}\n    \n//------------------------------------------------------------------------\n// Material \n//\n// Defines the material (colors, shading, pattern, texturing) of the model\n// at every point based on its position and normal. In this case, it simply\n// returns a constant yellow color.\n//------------------------------------------------------------------------\nvec3 doMaterial( in vec3 pos, in vec3 nor )\n{\n    vec3 m = doModel2(pos);\n    \n    return hsv2rgb(vec3(m.yz,0.5))*0.5;\n}\n\n//------------------------------------------------------------------------\n// Lighting\n//------------------------------------------------------------------------\nfloat calcSoftshadow( in vec3 ro, in vec3 rd );\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec3 mal )\n{\n    vec3 lin = vec3(0.0);\n\n    // key light\n    //-----------------------------\n    vec3  lig = normalize(vec3(1.0,0.7,0.9));\n    float dif = max(dot(nor,lig),0.0);\n    float sha = 0.0; if( dif>0.01 ) sha=calcSoftshadow( pos+0.01*nor, lig );\n    lin += dif*vec3(4.00,4.00,4.00)*sha;\n\n    // ambient light\n    //-----------------------------\n    lin += vec3(0.50,0.50,0.50);\n\n    \n    // surface-light interacion\n    //-----------------------------\n    vec3 col = mal*lin;\n\n    \n    // fog    \n    //-----------------------------\n\tcol *= exp(-0.01*dis*dis);\n\n    return col;\n}\n\nfloat calcIntersection( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 20.0;           // max trace distance\n\tconst float precis = 0.001;        // precission of the intersection\n    float h = precis*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for( int i=0; i<90; i++ )          // max number of raymarching iterations is 90\n    {\n        if( h<precis||t>maxd ) break;\n\t    h = doModel( ro+rd*t );\n        t += h;\n    }\n\n    if( t<maxd ) res = t;\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.002;             // precision of the normal computation\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( pos + v1*eps ) + \n\t\t\t\t\t  v2*doModel( pos + v2*eps ) + \n\t\t\t\t\t  v3*doModel( pos + v3*eps ) + \n\t\t\t\t\t  v4*doModel( pos + v4*eps ) );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.0005;                 // selfintersection avoidance distance\n\tfloat h = 1.0;\n    for( int i=0; i<40; i++ )         // 40 is the max numnber of raymarching steps\n    {\n        h = doModel(ro + rd*t);\n        res = min( res, 64.0*h/t );   // 64 is the hardness of the shadows\n\t\tt += clamp( h, 0.02, 2.0 );   // limit the max and min stepping distances\n    }\n    return clamp(res,0.0,1.0);\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    update_points();\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m.x );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = doBackground();\n\n\t// raymarch\n    float t = calcIntersection( ro, rd );\n    if( t>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\n        // materials\n        vec3 mal = doMaterial( pos, nor );\n\n        col = doLighting( pos, nor, rd, t, mal );\n\t}\n\n\t//-----------------------------------------------------\n\t// postprocessing\n    //-----------------------------------------------------\n    // gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n\t   \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlsGRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1037, 1037, 1125, 1125, 1406], [1408, 1408, 1486, 1486, 1564], [1566, 1566, 1661, 1661, 1825], [1827, 1827, 1879, 1879, 2265], [2267, 2267, 2319, 2319, 2705], [2707, 2707, 2759, 2759, 3145], [3147, 3147, 3174, 3174, 3266], [3269, 3269, 3333, 3435, 3855], [3946, 3946, 4022, 4022, 4212], [4214, 4214, 4255, 4255, 4296], [4298, 4298, 4342, 4342, 4383], [4385, 4385, 4406, 4406, 4543], [4709, 4805, 4850, 4850, 5522], [5524, 5617, 5658, 5658, 5823], [5829, 5878, 5943, 5943, 6167], [6169, 6210, 6274, 6274, 6710], [6712, 6712, 6737, 6737, 6848], [6851, 6851, 6898, 6898, 8241], [8306, 8638, 8721, 8721, 8828], [8831, 9062, 9089, 9089, 9124], [9126, 9126, 9153, 9153, 9184], [9186, 9186, 9213, 9213, 9243], [9245, 9245, 9303, 9303, 9425], [9470, 9470, 9503, 9503, 9536], [9588, 9588, 9620, 9620, 9871], [9873, 9873, 9925, 9925, 10052], [10054, 10054, 10099, 10099, 10139], [10141, 10141, 10166, 10166, 10275], [10277, 10277, 10299, 10299, 10373], [10758, 10758, 10780, 10780, 11488], [11490, 11490, 11521, 11521, 11549], [11551, 11551, 11576, 11576, 12186], [12188, 12188, 12213, 12213, 12241], [12247, 12600, 12645, 12645, 12720], [12933, 12933, 13017, 13017, 13593], [13595, 13595, 13645, 13645, 14062], [14064, 14064, 14096, 14096, 14508], [14510, 14510, 14558, 14558, 14984], [14986, 14986, 15050, 15050, 15228], [15230, 15230, 15287, 15287, 16513]], "test": "error"}
{"id": "XlsGRs", "name": "jetstream", "author": "srtuss", "description": "something i made some moths ago, when i was experimenting with volumetric stuff.", "tags": ["clouds", "rain", "lightning", "calm"], "likes": 304, "viewed": 12393, "published": "Public", "date": "1424377905", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// srtuss, 2015\n//\n// Volumetric cloud tunnel, a single light source, lightning and raindrops.\n//\n// The code is a bit messy, but in this case it's visuals that count. :P\n\n\n#define pi 3.1415926535897932384626433832795\n\nstruct ITSC\n{\n\tvec3 p;\n\tfloat dist;\n\tvec3 n;\n    vec2 uv;\n};\n\nITSC raycylh(vec3 ro, vec3 rd, vec3 c, float r)\n{\n\tITSC i;\n\ti.dist = 1e38;\n\tvec3 e = ro - c;\n\tfloat a = dot(rd.xy, rd.xy);\n\tfloat b = 2.0 * dot(e.xy, rd.xy);\n\tfloat cc = dot(e.xy, e.xy) - r;\n\tfloat f = b * b - 4.0 * a * cc;\n\tif(f > 0.0)\n\t{\n\t\tf = sqrt(f);\n\t\tfloat t = (-b + f) / (2.0 * a);\n\t\t\n\t\tif(t > 0.001)\n\t\t{\n\t\t\ti.dist = t;\n\t\t\ti.p = e + rd * t;\n\t\t\ti.n = -vec3(normalize(i.p.xy), 0.0);\n\t\t}\n\t}\n\treturn i;\n}\n\nvoid tPlane(inout ITSC hit, vec3 ro, vec3 rd, vec3 o, vec3 n, vec3 tg, vec2 si)\n{\n    vec2 uv;\n    ro -= o;\n    float t = -dot(ro, n) / dot(rd, n);\n    if(t < 0.0)\n        return;\n    vec3 its = ro + rd * t;\n    uv.x = dot(its, tg);\n    uv.y = dot(its, cross(tg, n));\n    if(abs(uv.x) > si.x || abs(uv.y) > si.y)\n        return;\n    \n    //if(t < hit.dist)\n    {\n        hit.dist = t;\n        hit.uv = uv;\n    }\n    return;\n}\n\n\nfloat hsh(float x)\n{\n    return fract(sin(x * 297.9712) * 90872.2961);\n}\n\nfloat nseI(float x)\n{\n    float fl = floor(x);\n    return mix(hsh(fl), hsh(fl + 1.0), smoothstep(0.0, 1.0, fract(x)));\n}\n\nvec2 rotate(vec2 p, float a)\n{\n\treturn vec2(p.x * cos(a) - p.y * sin(a), p.x * sin(a) + p.y * cos(a));\n}\n\nfloat nse3d(in vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f * f * (3.0 - 2.0 * f);\n\tvec2 uv = (p.xy + vec2(37.0, 17.0) * p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+.5)/256., 0.).yx;\n\treturn mix(rg.x, rg.y, f.z);\n}\n\nfloat nse(vec2 p)\n{\n    return texture(iChannel0, p).x;\n}\n\nfloat density2(vec2 p, float z, float t)\n{\n    float v = 0.0;\n    float fq = 1.0, am = 0.5, mvfd = 1.0;\n    vec2 rnd = vec2(0.3, 0.7);\n    for(int i = 0; i < 7; i++)\n    {\n        rnd = fract(sin(rnd * 14.4982) * 2987253.28612);\n        v += nse(p * fq + t * (rnd - 0.5)) * am;\n        fq *= 2.0;\n        am *= 0.5;\n        mvfd *= 1.3;\n    }\n    return v * exp(z * z * -2.0);\n}\n\nfloat densA = 1.0, densB = 2.0;\n\nfloat fbm(vec3 p)\n{\n    vec3 q = p;\n    //q.xy = rotate(p.xy, iTime);\n    \n    p += (nse3d(p * 3.0) - 0.5) * 0.3;\n    \n    //float v = nse3d(p) * 0.5 + nse3d(p * 2.0) * 0.25 + nse3d(p * 4.0) * 0.125 + nse3d(p * 8.0) * 0.0625;\n    \n    //p.y += iTime * 0.2;\n    \n    float mtn = iTime * 0.15;\n    \n    float v = 0.0;\n    float fq = 1.0, am = 0.5;\n    for(int i = 0; i < 6; i++)\n    {\n        v += nse3d(p * fq + mtn * fq) * am;\n        fq *= 2.0;\n        am *= 0.5;\n    }\n    return v;\n}\n\nfloat fbmHQ(vec3 p)\n{\n    vec3 q = p;\n    q.xy = rotate(p.xy, iTime);\n    \n    p += (nse3d(p * 3.0) - 0.5) * 0.4;\n    \n    //float v = nse3d(p) * 0.5 + nse3d(p * 2.0) * 0.25 + nse3d(p * 4.0) * 0.125 + nse3d(p * 8.0) * 0.0625;\n    \n    //p.y += iTime * 0.2;\n    \n    float mtn = iTime * 0.2;\n    \n    float v = 0.0;\n    float fq = 1.0, am = 0.5;\n    for(int i = 0; i < 9; i++)\n    {\n        v += nse3d(p * fq + mtn * fq) * am;\n        fq *= 2.0;\n        am *= 0.5;\n    }\n    return v;\n}\n\nfloat density(vec3 p)\n{\n    vec2 pol = vec2(atan(p.y, p.x), length(p.yx));\n    \n    float v = fbm(p);\n    \n    float fo = (pol.y - 1.5);//(densA + densB) * 0.5);\n    //fo *= (densB - densA);\n    v *= exp(fo * fo * -5.0);\n    \n    float edg = 0.3;\n    return smoothstep(edg, edg + 0.1, v);\n}\n\nfloat densityHQ(vec3 p)\n{\n    vec2 pol = vec2(atan(p.y, p.x), length(p.yx));\n    \n    float v = fbmHQ(p);\n    \n    float fo = (pol.y - 1.5);//(densA + densB) * 0.5);\n    //fo *= (densB - densA);\n    v *= exp(fo * fo * -5.0);\n    \n    float edg = 0.3;\n    return smoothstep(edg, edg + 0.1, v);\n}\n\nvec2 drop(inout vec2 p)\n{\n    vec2 mv = iTime * vec2(0.5, -1.0) * 0.15;\n    \n    float drh = 0.0;\n    float hl = 0.0;\n    \n    vec4 rnd = vec4(0.1, 0.2, 0.3, 0.4);\n    for(int i = 0; i < 20; i++)\n    {\n        rnd = fract(sin(rnd * 2.184972) * 190723.58961);\n        float fd = fract(iTime * 0.2 + rnd.w);\n        fd = exp(fd * -4.0);\n        float r = 0.025 * (rnd.w * 1.5 + 1.0);\n        float sz = 0.35;\n        \n        \n        vec2 q = (fract((p - mv) * sz + rnd.xy) - 0.5) / sz;\n        mv *= 1.06;\n        \n        q.y *= -1.0;\n        float l = length(q + pow(abs(dot(q, vec2(1.0, 0.4))), 0.7) * (fd * 0.2 + 0.1));\n        if(l < r)\n        {\n        \tfloat h = sqrt(r * r - l * l);\n        \tdrh = max(drh, h * fd);\n        }\n        hl += exp(length(q - vec2(-0.02, 0.01)) * -30.0) * 0.4 * fd;\n    }\n    p += drh * 5.0;\n    return vec2(drh, hl);\n}\n\n\nfloat hash1(float p)\n{\n\treturn fract(sin(p * 172.435) * 29572.683) - 0.5;\n}\n\nfloat hash2(vec2 p)\n{\n\tvec2 r = (456.789 * sin(789.123 * p.xy));\n\treturn fract(r.x * r.y * (1.0 + p.x));\n}\n\nfloat ns(float p)\n{\n\tfloat fr = fract(p);\n\tfloat fl = floor(p);\n\treturn mix(hash1(fl), hash1(fl + 1.0), fr);\n}\n\nfloat fbm(float p)\n{\n\treturn (ns(p) * 0.4 + ns(p * 2.0 - 10.0) * 0.125 + ns(p * 8.0 + 10.0) * 0.025);\n}\n\nfloat fbmd(float p)\n{\n\tfloat h = 0.01;\n\treturn atan(fbm(p + h) - fbm(p - h), h);\n}\n\nfloat arcsmp(float x, float seed)\n{\n\treturn fbm(x * 3.0 + seed * 1111.111) * (1.0 - exp(-x * 5.0));\n}\n\nfloat arc(vec2 p, float seed, float len)\n{\n\tp *= len;\n\t//p = rotate(p, iTime);\n\tfloat v = abs(p.y - arcsmp(p.x, seed));\n\tv += exp((2.0 - p.x) * -4.0);\n\tv = exp(v * -60.0) + exp(v * -10.0) * 0.6;\n\t//v += exp(p.x * -2.0);\n\tv *= smoothstep(0.0, 0.05, p.x);\n\treturn v;\n}\n\nfloat arcc(vec2 p, float sd)\n{\n\tfloat v = 0.0;\n\tfloat rnd = fract(sd);\n\tfloat sp = 0.0;\n\tv += arc(p, sd, 1.0);\n\tfor(int i = 0; i < 4; i ++)\n\t{\n\t\tsp = rnd + 0.01;\n\t\tvec2 mrk = vec2(sp, arcsmp(sp, sd));\n\t\tv += arc(rotate(p - mrk, fbmd(sp)), mrk.x, mrk.x * 0.4 + 1.5);\n\t\trnd = fract(sin(rnd * 195.2837) * 1720.938);\n\t}\n\treturn v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv = 2.0 * uv - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 drh = drop(uv);\n    \n    float camtm = iTime * 0.15;\n    vec3 ro = vec3(cos(camtm), 0.0, camtm);\n    vec3 rd = normalize(vec3(uv, 1.2));\n    rd.xz = rotate(rd.xz, sin(camtm) * 0.4);\n    rd.yz = rotate(rd.yz, sin(camtm * 1.3) * 0.4);\n    \n    vec3 sun = normalize(vec3(0.2, 1.0, 0.1));\n    \n    float sd = sin(fragCoord.x * 0.01 + fragCoord.y * 3.333333333 + iTime) * 1298729.146861;\n    \n    vec3 col;\n    float dacc = 0.0, lacc = 0.0;\n    \n    vec3 light = vec3(cos(iTime * 8.0) * 0.5, sin(iTime * 4.0) * 0.5, ro.z + 4.0 + sin(iTime));\n    \n    ITSC tunRef;\n    #define STP 15\n    for(int i = 0; i < STP; i++)\n    {\n        ITSC itsc = raycylh(ro, rd, vec3(0.0), densB + float(i) * (densA - densB) / float(STP) + fract(sd) * 0.07);\n        float d = density(itsc.p);\n        vec3 tol = light - itsc.p;\n        float dtol = length(tol);\n        tol = tol * 0.1 / dtol;\n        \n        float dl = density(itsc.p + tol);\n        lacc += max(d - dl, 0.0) * exp(dtol * -0.2);\n        dacc += d;\n        tunRef = itsc;\n    }\n    dacc /= float(STP);\n    ITSC itsc = raycylh(ro, rd, vec3(0.0), 4.0);\n    vec3 sky = vec3(0.6, 0.3, 0.2);\n    sky *= 0.9 * pow(fbmHQ(itsc.p), 2.0);\n    lacc = max(lacc * 0.3 + 0.3, 0.0);\n    vec3 cloud = pow(vec3(lacc), vec3(0.7, 1.0, 1.0) * 1.0);\n    col = mix(sky, cloud, dacc);\n    col *= exp(tunRef.dist * -0.1);\n    col += drh.y;\n    \n    vec4 rnd = vec4(0.1, 0.2, 0.3, 0.4);\n    float arcv = 0.0, arclight = 0.0;\n    for(int i = 0; i < 3; i++)\n    {\n        float v = 0.0;\n        rnd = fract(sin(rnd * 1.111111) * 298729.258972);\n        float ts = rnd.z * 4.0 * 1.61803398875 + 1.0;\n        float arcfl = floor(iTime / ts + rnd.y) * ts;\n        float arcfr = fract(iTime / ts + rnd.y) * ts;\n        \n        ITSC arcits;\n        arcits.dist = 1e38;\n        float arca = rnd.x + arcfl * 2.39996;\n        float arcz = ro.z + 1.0 + rnd.x * 12.0;\n        tPlane(arcits, ro, rd, vec3(0.0, 0.0, arcz), vec3(0.0, 0.0, -1.0), vec3(cos(arca), sin(arca), 0.0), vec2(2.0));\n\n        float arcseed = floor(iTime * 17.0 + rnd.y);\n        if(arcits.dist < 20.0)\n        {\n            arcits.uv *= 0.8;\n            v = arcc(vec2(1.0 - abs(arcits.uv.x), arcits.uv.y * sign(arcits.uv.x)) * 1.4, arcseed * 0.033333);\n        }\n\t\tfloat arcdur = rnd.x * 0.2 + 0.05;\n        float arcint = smoothstep(0.1 + arcdur, arcdur, arcfr);\n        v *= arcint;\n        arcv += v;\n        arclight += exp(abs(arcz - tunRef.p.z) * -0.3) * fract(sin(arcseed) * 198721.6231) * arcint;\n    }\n    vec3 arccol = vec3(0.9, 0.7, 0.7);\n    col += arclight * arccol * 0.5;\n    col = mix(col, arccol, clamp(arcv, 0.0, 1.0));\n    col = pow(col, vec3(1.0, 0.8, 0.5) * 1.5) * 1.5;\n    col = pow(col, vec3(1.0 / 2.2));\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlsGRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[281, 281, 330, 330, 688], [690, 690, 771, 771, 1115], [1118, 1118, 1138, 1138, 1190], [1192, 1192, 1213, 1213, 1312], [1314, 1314, 1344, 1344, 1418], [1420, 1420, 1444, 1444, 1659], [1661, 1661, 1680, 1680, 1718], [1720, 1720, 1762, 1762, 2098], [2133, 2133, 2152, 2152, 2619], [2621, 2621, 2642, 2642, 3106], [3108, 3108, 3131, 3131, 3398], [3400, 3400, 3425, 3425, 3694], [3696, 3696, 3721, 3721, 4553], [4556, 4556, 4578, 4578, 4631], [4633, 4633, 4654, 4654, 4739], [4741, 4741, 4760, 4760, 4851], [4853, 4853, 4873, 4873, 4956], [4958, 4958, 4979, 4979, 5040], [5042, 5042, 5077, 5077, 5143], [5145, 5145, 5187, 5187, 5411], [5413, 5413, 5443, 5443, 5741], [5743, 5743, 5800, 5800, 8665]], "test": "error"}
{"id": "XlsGWS", "name": "Stormy flight 2", "author": "guil", "description": "Improved version of my lightning bolt effect", "tags": ["2d", "noise"], "likes": 24, "viewed": 987, "published": "Public", "date": "1424816406", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by S.Guillitte\n\n\nfloat hash(float x)\n{\n\treturn fract(21654.6512 * sin(385.51 * x));\n}\nfloat hash( in vec2 p ) \n{\n    return fract(sin(p.x*15.32+p.y*35.78) * 43758.23);\n}\n\nvec2 hash2(vec2 p)\n{\n\treturn vec2(hash(p*.754),hash(1.5743*p.yx+4.5891))-.5;\n}\n\nvec2 hash2b(vec2 p)\n{\n\treturn vec2(hash(p*.754),hash(1.5743*p+4.5476351));\n}\nvec2 add = vec2(1.0, 0.0);\n\nvec2 noise2(vec2 x)\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    vec2 res = mix(mix( hash2(p),          hash2(p + add.xy),f.x),\n                    mix( hash2(p + add.yx), hash2(p + add.xx),f.x),f.y);\n    return res;\n}\n\nvec2 fbm2(vec2 x)\n{\n    vec2 r = vec2(0.0);\n    float a = 1.0;\n    \n    for (int i = 0; i < 8; i++)\n    {\n        r += abs(noise2(x)+.5 )* a;\n        x *= 2.;\n        a *= .5;\n    }\n     \n    return r;\n}\n\nmat2 m2;\n\nvec2 fbm3(vec2 x)\n{\n    vec2 r = vec2(0.0);\n    float a = 1.;\n    \n    for (int i = 0; i < 6; i++)\n    {\n        r += m2*noise2((x+r)/a)*a; \n        r=-.8*abs(r);\n        a*=1.7;\n    }     \n    return r;\n}\n\nvec3 storm(vec2 x)\n{\n    float t = .5*iTime;\n    float st = sin(t), ct = cos(t);\n    m2 = mat2(ct,st,-st,ct);\n    x=fbm3(x+0.5*iTime)+2.;\n    x*=.35;\n        \n    float c = length(x);\n    c=c*c*c;\n    vec3 col=vec3(0.6-.1*x.x,0.7,0.8-.1*x.y)*c*x.y;   \n    return clamp(col,0.,1.);\n}\n\n\n\nfloat dseg( vec2 ba, vec2 pa )\n{\n\t\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), -0.2, 1. );\t\n\treturn length( pa - ba*h );\n}\n\nfloat arc(vec2 x,vec2 p, vec2 dir)\n{\n    vec2 r = p;\n    float d=10.;\n    for (int i = 0; i < 5; i++)\n    {\n        vec2 s= noise2(r+iTime)+dir;\n        d=min(d,dseg(s,x-r));\n        r +=s;      \n    }\n    return d*3.;\n    \n}\n\n\n\nfloat thunderbolt(vec2 x,vec2 tgt)\n{\n    vec2 r = tgt;\n    float d=1000.;\n    float dist=length(tgt-x);\n     \n    for (int i = 0; i < 19; i++)\n    {\n        if(r.y>x.y+.5)break;\n        vec2 s= (noise2(r+iTime)+vec2(0.,.7))*2.;\n        dist = dseg(s,x-r);\n        d=min(d,dist);\n        \n        r +=s;\n        if(i-(i/5)*5==0){\n            if(i-(i/10)*10==0)d=min(d,arc(x,r,vec2(.3,.5)));\n            else d=min(d,arc(x,r,vec2(-.3,.5)));\n        }\n    }\n    return exp(-5.*d)+.2*exp(-1.*dist);\n   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n\t\n\tvec2 p = 2.*fragCoord.xy/iResolution.yy-1.;\n    vec2 d;\n    vec2 tgt = vec2(1., -8.);\n    float c=0.;\n    vec3 col;\n    if(p.y>=0.)\n        col=storm((5.*p+.2)*p.y+.7*iTime)*p.y+2.5*(1.-(fbm2((p+.2)*p.y+.1*iTime)).x)*p.y*vec3(.4,.5,1.);\n\telse \n    {c = 2.*(1.-(fbm2(p+.2+.1*iTime)).x)*p.y*p.y;\n     col = c*vec3(.3,.5,1.);}\n    \n    \n    float t = hash(floor(5.*iTime));\n    tgt+=8.*hash2b(tgt+t);\n    if(hash(t+2.3)>.8)\n\t {\n\t\tc= thunderbolt(p*10.+2.*fbm2(5.*p),tgt);\t\n\t\tcol+=clamp(1.7*vec3(0.8,.7,.9)*c,0.,1.);\t\n\t}\n    \n\tfragColor = vec4(col, 0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlsGWS.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[115, 115, 136, 136, 183], [184, 184, 210, 210, 267], [269, 269, 289, 289, 347], [349, 349, 370, 370, 425], [454, 454, 475, 475, 709], [711, 711, 730, 730, 914], [926, 926, 945, 945, 1131], [1133, 1133, 1153, 1153, 1415], [1419, 1419, 1451, 1451, 1538], [1540, 1540, 1576, 1576, 1765], [1769, 1769, 1805, 1805, 2269], [2271, 2271, 2328, 2328, 2885]], "test": "valid"}
{"id": "XlsGzf", "name": "Clock style bar", "author": "andreyu", "description": "Clock style bar.", "tags": ["2d", "clock", "gui", "widget"], "likes": 1, "viewed": 238, "published": "Public", "date": "1423929171", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// clock style bar by Andrey A. Ugolnik\n// 2015\n\n#define M_PI 3.1415926535897932384626433832795\n\nvec4 col = vec4(0.0, 0.2, 0.0, 1.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float angle = mod(iTime, M_PI * 2.0);\n\n\tvec2 p = (iResolution.xy - 2.0 * fragCoord.xy) / iResolution.y;\n\n    float q = atan(-p.x, p.y);\n\tfloat f = step(0.0, cos((q + angle) * 0.5));\n\n    // mix with texture\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 tc = texture(iChannel0, uv);\n    fragColor = mix(tc, col, f);\n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlsGzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[135, 135, 192, 192, 521]], "test": "error"}
{"id": "XlX3DS", "name": "[TDF15]Shell", "author": "FMS_Cat", "description": "GLSL Graphics for Tokyo Demo Fest 2015\nraymarching\nmenger sponge mutation II", "tags": ["3d", "fractal"], "likes": 18, "viewed": 1522, "published": "Public", "date": "1424622303", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// FMS_Cat - Shell\n// GLSL Graphics for Tokyo Demo Fest 2015\n// 2015/02/22\n//\n// Greeting:\n//   doxas\n//   gyabo\n//   Jugem-T\n//   RTX1911\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define C vec3(.5,.1,.2)*2.\n#define ITER 72\n#define SITER 32\n\n#define tMax 40.\n#define t mod(iTime,tMax)\n#define r iResolution.xy\n#define v vec2(0.,1.)\n#define cl(i) clamp(i,0.,1.)\n#define PI 3.1415926\n\nfloat hash(vec2 _v)\n{\n  return fract(sin(dot(_v,vec2(89.44,19.36)))*229.22);\n}\n\nfloat iHash(vec2 _v,vec2 _r)\n{\n  float h00 = hash(vec2(floor(_v*_r+v.xx)/_r));\n  float h10 = hash(vec2(floor(_v*_r+v.yx)/_r));\n  float h01 = hash(vec2(floor(_v*_r+v.xy)/_r));\n  float h11 = hash(vec2(floor(_v*_r+v.yy)/_r));\n  vec2 ip = vec2(smoothstep(v.xx,v.yy,mod(_v*_r,1.)));\n  return (h00*(1.-ip.x)+h10*ip.x)*(1.-ip.y)+(h01*(1.-ip.x)+h11*ip.x)*ip.y;\n}\n\nfloat noise(vec2 _v)\n{\n  float sum = 0.;\n  for(int i=1; i<6; i++)\n  {\n    sum += iHash(_v+vec2(i),vec2(2.*pow(2.,float(i))))/pow(2.,float(i));\n  }\n  return sum;\n}\n\nfloat noiseT(vec2 _v)\n{\n  float sum = 0.;\n  for(int i=1; i<6; i++)\n  {\n    sum += iHash(_v+vec2(i)*t,vec2(2.*pow(2.,float(i))))/pow(2.,float(i));\n  }\n  return sum;\n}\n\nvec2 rotate(vec2 i,float th)\n{\n  return mat2(cos(th),-sin(th),sin(th),cos(th))*i;\n}\n\nfloat box(vec3 p,vec3 b)\n{\n  vec3 d=abs(p)-b;\n  return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.));\n}\n\nfloat box(vec3 p,float b){return box(p,vec3(b));}\n\nfloat bar(vec2 p,vec2 b)\n{\n  vec2 d=abs(p)-b;\n  return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\n\nfloat crossBar(vec3 p,float b)\n{\n  float da=bar(p.xy,vec2(b)),\n  db=bar(p.yz,vec2(b)),\n  dc=bar(p.zx,vec2(b));\n  return min(da,min(db,dc));\n}\n\nfloat spongePre(vec3 p)\n{\n  p.xy=rotate(p.xy,t*.23);\n  p.yz=rotate(p.yz,t*.13);\n  p.zx=rotate(p.zx,t*.43);\n  return box(p,.4);\n}\n\nvec2 sponge(vec3 p)\n{\n  p.xy=rotate(p.xy,t*.23);\n  p.yz=rotate(p.yz,t*.13);\n  p.zx=rotate(p.zx,t*.43);\n  float ret=box(p,.4);\n  vec3 pt=p;\n  for(float c=0.;c<4.;c+=1.)\n  {\n    p=pt;\n    float h0=pow(1.17+hash(floor(t/5.+361.)*v.yy),c*.5);\n    float h1=pow(1.17+hash(ceil(t/5.+361.)*v.yy),c*.5);\n    float pw=h1+exp(-mod(t,5.)*12.)*(h0-h1);\n    ret=max(ret,-crossBar(mod(p+.15/pw,.6/pw)-.15/pw,.1/pw));\n  }\n  return vec2(ret,0.);\n}\n\nvec2 oil(vec3 p)\n{\n  return vec2(p.y+.9,1.);\n}\n\nvec2 flo(vec3 p)\n{\n  return vec2(max(p.y+.7,.8-length(p.xz)),2.);\n}\n\nvec2 pole(vec3 p)\n{\n  return vec2(length(mod(p.xz,4.)-2.)-.3,2.);\n}\n\n#define check if(disC.x<dis.x){dis=disC;}\nvec2 distFunc(vec3 p)\n{\n  vec2 dis=spongePre(p)*v.yx;\n  if(dis.x<.1)\n  {\n    dis=sponge(p);\n  }\n  vec2 disC=oil(p);check;\n  disC=flo(p);check;\n  disC=pole(p);check;\n  return dis;\n}\n\nvec2 tube(vec3 p)\n{\n  vec2 dis=vec2(max(length(p.xz)-.8,-p.y-.7),0.);\n  vec2 disC=pole(p);check;\n  return dis;\n}\n\nvec3 getNormal(vec3 p,float d)\n{\n  return normalize(vec3(\n    distFunc(p+vec3(d,0.,0.)).x-distFunc(p+vec3(-d,0.,0.)).x,\n    distFunc(p+vec3(0.,d,0.)).x-distFunc(p+vec3(0.,-d,0.)).x,\n    distFunc(p+vec3(0.,0.,d)).x-distFunc(p+vec3(0.,0.,-d)).x\n    ));\n}\n\nfloat shadow(vec3 _ray,vec3 _lig,float k)\n{\n  vec3 ray=normalize(_lig-_ray);\n  float maxL=length(_lig-_ray);\n  float ret=1.;\n  float dist=0.;\n  float rayL=0.;\n  vec3 rayP=_ray;\n  for(int c=0;c<SITER;c++)\n  {\n    float dist=distFunc(rayP).x;\n    if(dist<1E-4){return 0.;}\n    rayL+=dist;\n    rayP=_ray+ray*rayL;\n    ret=min(ret,dist*k/rayL);\n    if(maxL<rayL){return ret;}\n  }\n  return 0.;\n}\n\nvec3 shadeBox(vec3 rayP,vec3 camP)\n{\n  vec3 col=v.xxx;\n\n  vec3 nor=getNormal(rayP,1E-4);\n\n  vec3 lig=v.xxx;\n  float dif=cl(dot(normalize(lig-rayP),nor))*.3;\n  float sha=shadow(rayP+1E-2*nor,lig,3E1);\n  float dec=exp(-length(lig-rayP)*.1);\n  col+=(dif*(sha*.5+.5)*dec*v.yyy)*C;\n\n  float edge=pow(cl((1.-dot(nor,getNormal(rayP,6E-3)))*8.+.1),14.)*(.01+floor(cl(1.-abs(mod(t/5.,1.)-length(rayP))*12.)*2.)*.4);\n  col+=edge*C;\n\n  return col;\n}\n\nvec3 shadeOil(vec3 rayP,vec3 camP)\n{\n  vec3 col=v.xxx;\n\n  vec3 nor=v.xyx;\n  nor.x+=(noiseT(rayP.xz*11.)-.5)*3.;\n  nor.z+=(noiseT(rayP.xz*11.+v.yy*29.)-.5)*3.;\n  nor=normalize(nor);\n\n  vec3 lig=v.xxx;\n  float sha=shadow(rayP+1E-2*nor,lig,3E1);\n  float spe=cl(pow(dot(normalize(normalize(lig-rayP)+normalize(camP-rayP)),nor)*1.02,3E2));\n  col+=spe*(sha*.9+.1)*C;\n\n  return col;\n}\n\nvec3 shadeFloor(vec3 rayP,vec3 camP)\n{\n  vec3 col=v.xxx;\n\n  vec3 nor=getNormal(rayP,1E-4);\n\n  vec3 lig=v.xxx;\n  float sha=shadow(rayP+1E-2*nor,lig,3E1);\n  float dif=cl(dot(normalize(lig-rayP),nor));\n  float spe=cl(pow(dot(normalize(normalize(lig-rayP)+normalize(camP-rayP)),nor),3E2));\n  float dec=exp(-length(lig-rayP)*.1);\n  col+=((dif*(sha*.7+.3))*v.yyy*dec+spe*sha*dec)*C;\n\n  float edge=cl(1.-abs(.3-rayP.y)*70.)*3.;\n  col+=edge*C;\n\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 p=(fragCoord.xy*2.-r)/r.x;\n  p.x+=((hash(floor(p.yy*100.))-.5))*exp(-t*.8)*.4; // first horizontal glitch\n  p.x+=hash(vec2(p.y,t*8.))*exp(-(tMax-t))*.2; // last horizontal noise\n\n  float camR=4.+exp(-t*.4)*10.;\n  if(8.<t){ camR-=(1.-exp(-(t-8.)*5.))*2.; }\n\n  float camT=t*.1+.3;\n  if(8.<t){ camT+=(1.-exp(-(t-8.)*5.))*.4; }\n\n  vec3 camP=vec3(cos(camT),.1,sin(camT))*camR;\n  vec3 camC=vec3(0.,-.2,0.);\n  vec3 camA=vec3(0.,1.,0.);\n  vec3 camS=cross(normalize(camC-camP),camA);\n  vec3 camU=cross(camS,normalize(camC-camP));\n  vec3 ray=normalize(camS*p.x+camU*p.y+normalize(camC-camP));\n\n  vec2 dist=v.xx;\n  float rayL=0.;\n  vec3 rayP=camP;\n  for(int i=0;i<ITER;i++)\n  {\n    dist=distFunc(rayP);\n    rayL+=dist.x*.95;\n    if(length(camP)*10.<rayL){ break; }\n    rayP=camP+ray*rayL;\n  }\n\n  vec3 col=v.xxx;\n\n  if(abs(dist.x)<1E-3)\n  {\n    float dis=1.6/clamp(rayL,1.8,99.);\n    if(dist.y==0.)\n    {\n      col+=shadeBox(rayP,camP);\n    }\n    else if(dist.y==1.)\n    {\n      col+=shadeOil(rayP,camP);\n    }\n    else if(dist.y==2.)\n    {\n      col+=shadeFloor(rayP,camP);\n    }\n  }\n\n  col+=cl(1.-(abs(min(rayL,length(camP))-length(camP))*10.))*pow(cl(dot(-ray,normalize(camP))),1E3*length(camP))*(C+v.yyy);\n\n  if(.8<length(camP.xz))\n  {\n    rayL=0.;\n    rayP=camP;\n    for(int i=0;i<ITER;i++)\n    {\n      dist=tube(rayP);\n      rayL+=dist.x;\n      if(length(camP)*2.<rayL){ break; }\n      rayP=camP+ray*rayL;\n    }\n\n    if(dist.x<1E-3&&dist.y==0.)\n    {\n      col+=(C+v.yyy)*max(.2-rayP.y*.1,.05)*.2;\n\n      vec3 lig=v.xxx;\n      float sha=shadow(rayP,lig,3E1);\n      float dec=exp(-length(lig-rayP)*.1);\n      col+=.03*sha*dec*C;\n    }\n  }\n\n  col+=shadow(camP+ray*.1,v.xxx,3E1)*exp(-length(camP)*.1)*C*.4;\n\n  col=cl(cl(col+sin(p.y*500.+t*10.)*.003)*5.*exp(-length(p)*2.))-exp(-t*.8)-exp(-(tMax-t));\n\n  fragColor=vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlX3DS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[389, 389, 410, 410, 467], [469, 469, 499, 499, 823], [825, 825, 847, 847, 987], [989, 989, 1012, 1012, 1154], [1156, 1156, 1186, 1186, 1239], [1241, 1241, 1267, 1267, 1346], [1348, 1348, 1374, 1374, 1397], [1399, 1399, 1425, 1425, 1495], [1497, 1497, 1529, 1529, 1638], [1640, 1640, 1665, 1665, 1768], [1770, 1770, 1791, 1791, 2200], [2202, 2202, 2220, 2220, 2248], [2250, 2250, 2268, 2268, 2317], [2319, 2319, 2338, 2338, 2386], [2430, 2430, 2453, 2453, 2610], [2612, 2612, 2631, 2631, 2724], [2726, 2726, 2758, 2758, 2978], [2980, 2980, 3023, 3023, 3370], [3372, 3372, 3408, 3408, 3810], [3812, 3812, 3848, 3848, 4189], [4191, 4191, 4229, 4229, 4643], [4645, 4645, 4702, 4702, 6529]], "test": "valid"}
{"id": "XlX3RB", "name": "Ocean Rescue", "author": "Trisomie21", "description": "Tweaked version of a leftover from the 2TC. (See comment for <280 char version.)", "tags": ["3d", "raymarching", "wave", "displacement", "ocean", "short"], "likes": 54, "viewed": 1827, "published": "Public", "date": "1422860500", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define T(a) texture(iChannel0,p.xz*.1-t*a)\nvoid mainImage( out vec4 o, in vec2 c ) {\n    vec4 p = vec4(c,0.,1.)/iResolution.xyxy-.5, d=p, e;\n    float t = iTime+6., x;\n    d.y -= .2;\n    p.z += t*.3;\n    for(float i=1.; i>0.; i-=.02)\n    {\n        e = sin(p*6.+t);\n        x = abs(p.y+e.x*e.z*.1-.75)-(e=T(.01)+T(.02)).x*.08;\n        o = .3/length(p.xy+vec2(sin(t),-.4)) - e*i*i;\n        if(x<.01) break;\n        p -= d*x*.5;\n     }\n}\n\n", "image_inputs": [{"id": "XsXGRn", "previewfilepath": "/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlX3RB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 44, 85, 85, 435]], "test": "error"}
{"id": "XlX3Rj", "name": "Circuits", "author": "Kali", "description": "A 2D fractal with some effects.", "tags": ["2d", "fractal"], "likes": 227, "viewed": 4258, "published": "Public", "date": "1423183174", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This content is under the MIT License.\n\n#define time iTime*.02\n\n\n#define width .005\nfloat zoom = .18;\n\nfloat shape=0.;\nvec3 color=vec3(0.),randcol;\n\nvoid formula(vec2 z, float c) {\n\tfloat minit=0.;\n\tfloat o,ot2,ot=ot2=1000.;\n\tfor (int i=0; i<9; i++) {\n\t\tz=abs(z)/clamp(dot(z,z),.1,.5)-c;\n\t\tfloat l=length(z);\n\t\to=min(max(abs(min(z.x,z.y)),-l+.25),abs(l-.25));\n\t\tot=min(ot,o);\n\t\tot2=min(l*.1,ot2);\n\t\tminit=max(minit,float(i)*(1.-abs(sign(ot-o))));\n\t}\n\tminit+=1.;\n\tfloat w=width*minit*2.;\n\tfloat circ=pow(max(0.,w-ot2)/w,6.);\n\tshape+=max(pow(max(0.,w-ot)/w,.25),circ);\n\tvec3 col=normalize(.1+texture(iChannel1,vec2(minit*.1)).rgb);\n\tcolor+=col*(.4+mod(minit/9.-time*10.+ot2*2.,1.)*1.6);\n\tcolor+=vec3(1.,.7,.3)*circ*(10.-minit)*3.*smoothstep(0.,.5,.15+texture(iChannel0,vec2(.0,1.)).x-.5);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 pos = fragCoord.xy / iResolution.xy - .5;\n\tpos.x*=iResolution.x/iResolution.y;\n\tvec2 uv=pos;\n\tfloat sph = length(uv); sph = sqrt(1. - sph*sph)*1.5; \n\tuv=normalize(vec3(uv,sph)).xy;\n\tfloat a=time+mod(time,1.)*.5;\n\tvec2 luv=uv;\n\tfloat b=a*5.48535;\n\tuv*=mat2(cos(b),sin(b),-sin(b),cos(b));\n\tuv+=vec2(sin(a),cos(a*.5))*8.;\n\tuv*=zoom;\n\tfloat pix=.5/iResolution.x*zoom/sph;\n\tfloat dof=max(1.,(10.-mod(time,1.)/.01));\n\tfloat c=1.5+mod(floor(time),6.)*.125;\n\tfor (int aa=0; aa<36; aa++) {\n\t\tvec2 aauv=floor(vec2(float(aa)/6.,mod(float(aa),6.)));\n\t\tformula(uv+aauv*pix*dof,c);\n\t}\n\tshape/=36.; color/=36.;\n\tvec3 colo=mix(vec3(.15),color,shape)*(1.-length(pos))*min(1.,abs(.5-mod(time+.5,1.))*10.);\t\n\tcolo*=vec3(1.2,1.1,1.0);\n\tfragColor = vec4(colo,1.0);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlX3Rj.jpg", "access": "shaders20k", "license": "mit", "functions": [[152, 152, 183, 183, 791], [794, 794, 851, 851, 1603]], "test": "error"}
{"id": "XlX3Wj", "name": "divinus waves", "author": "divinus", "description": "test shader", "tags": ["wave"], "likes": 3, "viewed": 116, "published": "Public", "date": "1425027227", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tfloat pos = iTime/50.0;\n\tvec2 position = ( fragCoord.xy / iResolution.xy )-pos;\n    \n    float phase1 = position.x*15.0+iTime*1.0;\n    float phase2 = position.x*25.0;\n    float phase3 = iTime*2.0;\n\n\tfloat wave = sin(phase1)*0.05*sin(phase3) + sin(phase2)*0.01*sin(phase3);\n    \n    vec3 color1 = vec3(0.933, 0.4, 0.145);\n    vec3 color2 = vec3(0.752, 0.098, 0.537);\n    \n    vec3 color3 = vec3(1.0, 0.694, 0.592);\n    vec3 color4 = vec3(1.0, 0.556, 0.850);\n    \n    vec4 texColor1 = texture(iChannel0, ( fragCoord.xy / iResolution.xy )-vec2(iTime/50.0, wave*0.2+iTime/50.0));\n    vec4 texColor2 = texture(iChannel0, ( fragCoord.xy / iResolution.xy )-vec2(-iTime/50.0, wave*0.4+iTime/25.0));\n    \n    fragColor = vec4( position.y < wave ? mix(color1, color2, min(1.0, pow((fragCoord.y / iResolution.y)/pos, 2.0))) : vec3(0.0,0.0,0.0), 1 );\n    \n    if (position.y < wave) {\n        if (position.y > wave*1.2 || position.y > wave*0.8 || position.y > wave-0.005) {\n            fragColor = vec4( mix(color3, color4, sin(fragCoord.x/100.0+iTime)+1.0), 1.0);\n        }\n        \n        if (position.y  < wave-0.02 && wave > 0.0) {\n            fragColor = mix(fragColor, vec4(1.0, 1.0, 1.0, 1.0), abs(wave*20.0)*((fragCoord.y / iResolution.y)/2.0));\n            //fragColor *= position.y/20.0;\n        }\n        \n        fragColor = mix(fragColor, texColor1, texColor1.r);\n        fragColor = mix(fragColor, texColor2, texColor2.b);\n    }\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlX3Wj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1493]], "test": "error"}
{"id": "XlX3zB", "name": "Polyhedron again", "author": "knighty", "description": ":D", "tags": ["de", "polyhedron"], "likes": 58, "viewed": 1984, "published": "Public", "date": "1422817818", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI\t3.14159265359\n#define PI2\t( PI * 2.0 )\n\n#define DISPLAY_FACES true\n#define DISPLAY_SEGMENTS true\n#define DISPLAY_VERTICES true\n\nint Type=3;\nfloat U=0.,V=0.,W=1.;\nfloat SRadius=0.03, VRadius=0.07;\n\nvec3 nc,p,pab,pbc,pca;\nvoid init() {//setup folding planes and vertex\n\tfloat t=iTime;\n    Type=int(fract(0.025*t)*3.)+3;\n    U=0.5*sin(t*1.5)+0.5;\n    V=0.5*sin(t*0.8)+0.5;\n    W=0.5*sin(t*0.3)+0.5;\n    float cospin=cos(PI/float(Type)), scospin=sqrt(0.75-cospin*cospin);\n\tnc=vec3(-0.5,-cospin,scospin);//3rd folding plane. The two others are xz and yz planes\n\tpab=vec3(0.,0.,1.);\n\tpbc=vec3(scospin,0.,0.5);//No normalization in order to have 'barycentric' coordinates work evenly\n\tpca=vec3(0.,scospin,cospin);\n\tp=normalize((U*pab+V*pbc+W*pca));//U,V and W are the 'barycentric' coordinates (coted barycentric word because I'm not sure if they are really barycentric... have to check)\n\tpbc=normalize(pbc);\tpca=normalize(pca);//for slightly better DE. In reality it's not necesary to apply normalization :) \n}\n\nvec3 fold(vec3 pos) {\n\tfor(int i=0;i<5 /*Type*/;i++){\n\t\tpos.xy=abs(pos.xy);//fold about xz and yz planes\n\t\tpos-=2.*min(0.,dot(pos,nc))*nc;//fold about nc plane\n\t}\n\treturn pos;\n}\n\nfloat D2Planes(vec3 pos) {//distance to the 3 faces\n\tpos-=p;\n    float d0=dot(pos,pab);\n\tfloat d1=dot(pos,pbc);\n\tfloat d2=dot(pos,pca);\n\treturn max(max(d0,d1),d2);\n}\n\nfloat length2(vec3 p){ return dot(p,p);}\n\nfloat D2Segments(vec3 pos) {\n\tpos-=p;\n\tfloat dla=length2(pos-min(0.,pos.x)*vec3(1.,0.,0.));\n\tfloat dlb=length2(pos-min(0.,pos.y)*vec3(0.,1.,0.));\n\tfloat dlc=length2(pos-min(0.,dot(pos,nc))*nc);\n\treturn sqrt(min(min(dla,dlb),dlc))-SRadius;\n}\n\nfloat D2Vertices(vec3 pos) {\n\treturn length(pos-p)-VRadius;\n}\n\nfloat Polyhedron(vec3 pos) {\n\tpos=fold(pos);\n\tfloat d=10000.;\n\tif(DISPLAY_FACES) d=min(d,D2Planes(pos));\n\tif(DISPLAY_SEGMENTS) d=min(d,D2Segments(pos));\n\tif(DISPLAY_VERTICES)  d=min(d,D2Vertices(pos));\n\treturn d;\n}\n\nvec3 getColor(vec3 pos){//Not optimized.\n#define Face0Color vec3(.8,0.6,0.);\n#define Face1Color vec3(0.3,0.7,0.2);\n#define Face2Color vec3(0.1,0.4,1.);\n#define SegmentsColor vec3(0.4,0.4,0.7);\n#define VerticesColor vec3(1.,.4,.3);\n\tpos=fold(pos);\n\tfloat d0=1000.0,d1=1000.0,d2=1000.,df=1000.,dv=1000.,ds=1000.;\n\tif(DISPLAY_FACES){\n\t\td0=dot(pos-p,pab);\n\t\td1=dot(pos-p,pbc);\n\t\td2=dot(pos-p,pca);\n\t\tdf=max(max(d0,d1),d2);\n\t}\n\tif(DISPLAY_SEGMENTS) ds=D2Segments(pos);\n\tif(DISPLAY_VERTICES) dv=D2Vertices(pos);\n\tfloat d=min(df,min(ds,dv));\n\tvec3 col=Face0Color;\n\tif(d==df){\n\t\tif(d==d1) col=Face1Color;\n\t\tif(d==d2) col=Face2Color;\n\t}else{\n\t\tif(d==ds) col=SegmentsColor;\n\t\tif(d==dv) col=VerticesColor;\n\t}\n\treturn col;\n}\n//-------------------------------------------------\n//From https://www.shadertoy.com/view/XtXGRS#\nvec2 rotate(in vec2 p, in float t)\n{\n\treturn p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nfloat map(in vec3 p)\n{\n    //return length(p)-1.;\n\treturn mix(length(p)-1.,Polyhedron(p),0.8);//just for fun\n}\n\nvec3 calcNormal(in vec3 p)\n{\n\tconst vec2 e = vec2(0.0001, 0.0);\n\treturn normalize(vec3(\n\t\tmap(p + e.xyy) - map(p - e.xyy),\n\t\tmap(p + e.yxy) - map(p - e.yxy),\n\t\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tconst float maxd = 5.0;\n\tconst float precis = 0.001;\n    float h = precis * 2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for(int i = 0; i < 64; i++)\n    {\n        if(h < precis || t > maxd) break;\n\t    h = map(ro + rd * t);\n        t += h;\n    }\n    if(t < maxd) res = t;\n    return res;\n}\n\nvec3 transform(in vec3 p)\n{\n    p.yz = rotate(p.yz, iTime * 0.2 + (iMouse.y-0.5*iResolution.y)*PI2/360.);\n    p.zx = rotate(p.zx, iTime * 0.125 + (0.5*iResolution.x-iMouse.x)*PI2/360.);\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 col = vec3(0.3 + p.y * 0.1);\n   \tvec3 rd = normalize(vec3(p, -1.8));\n\tvec3 ro = vec3(0.0, 0.0, 2.5);\n    vec3 li = normalize(vec3(0.5, 0.8, 3.0));\n    ro = transform(ro);\n\trd = transform(rd);\n\tli = transform(li);\n    init();\n    float t = march(ro, rd);\n    if(t > -0.001)\n    {\n        vec3 pos = ro + t * rd;\n        vec3 n = calcNormal(pos);\n\t\tfloat dif = clamp(dot(n, li), 0.0, 1.0);\n        col = getColor(pos) * dif;\n        col = pow(col, vec3(0.8));\n\t}\n   \tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlX3zB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[231, 231, 244, 277, 1015], [1017, 1017, 1038, 1038, 1194], [1196, 1196, 1222, 1247, 1361], [1363, 1363, 1385, 1385, 1403], [1405, 1405, 1433, 1433, 1645], [1647, 1647, 1675, 1675, 1708], [1710, 1710, 1738, 1738, 1924], [1926, 1926, 1950, 1966, 2638], [2639, 2737, 2773, 2773, 2824], [2826, 2826, 2848, 2875, 2936], [2938, 2938, 2966, 2966, 3134], [3136, 3136, 3173, 3173, 3466], [3468, 3468, 3495, 3495, 3669], [3671, 3671, 3728, 3728, 4294]], "test": "valid"}
{"id": "XlXGD7", "name": "Fly by Night", "author": "mhnewman", "description": "Flying over earth at night.", "tags": ["earth", "space", "night", "orbit", "spacestation"], "likes": 40, "viewed": 1029, "published": "Public", "date": "1423017580", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\tMy first contribution to Shadertoy\n//\tI have been a big fan of this community for a while and I want to thank iq for\n//\tthis wonderful site.\n//\tHash functions from David Hoskins via https://www.shadertoy.com/view/4djSRW\n\nconst mat2 m = mat2(1.616, 1.212, -1.212, 1.616);\n\nfloat hash12(vec2 p) {\n\tp = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n\treturn fract(p.x * p.y * 95.4337);\n}\n\nvec2 hash21(float p) {\n\tvec2 p2 = fract(p * vec2(5.3983, 5.4427));\n    p2 += dot(p2.yx, p2.xy +  vec2(21.5351, 14.3137));\n\treturn fract(vec2(p2.x * p2.y * 95.4337, p2.x * p2.y * 97.597));\n}\n\nfloat noise(in vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(mix(hash12(i + vec2(0.0, 0.0)), \n                   hash12(i + vec2(1.0, 0.0)), u.x),\n               mix(hash12(i + vec2(0.0, 1.0)), \n                   hash12(i + vec2(1.0, 1.0)), u.x), u.y);\n}\n\nfloat hash12_3(vec2 p) {\n\tfloat f = hash12(p);\n    return f * f * f;\n}\n\nfloat noise_3(in vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(mix(hash12_3(i + vec2(0.0, 0.0)), \n                   hash12_3(i + vec2(1.0, 0.0)), u.x),\n               mix(hash12_3(i + vec2(0.0, 1.0)), \n                   hash12_3(i + vec2(1.0, 1.0)), u.x), u.y);\n}\n\nfloat fbm(vec2 p) {\n    float f = 0.0;\n    f += 0.5 * noise(p); p = m * p;\n    f += 0.25 * noise(p); p = m * p;\n    f += 0.125 * noise(p); p = m * p;\n    f += 0.0625 * noise(p); p = m * p;\n    f += 0.03125 * noise(p); p = m * p;\n    f += 0.015625 * noise(p);\n    return f / 0.984375;\n}\n\nvec3 getDir(vec2 screenPos) {\n    screenPos -= 0.5;\n\tscreenPos.x *= iResolution.x / iResolution.y;\n    \n    return normalize(vec3(0.0, -1.0, -3.0)\n                     + screenPos.x * vec3(1.0, 0.0, 0.0)\n                     - screenPos.y * vec3(0.0, -0.948683298, 0.316227766));\n}\n\nbool getPosition(in vec3 camera, in vec3 dir, out vec2 pos) {\n    bool valid = false;\n    \n\tfloat b = dot(camera, dir);\n\tfloat c = dot(camera, camera) - 1.0;\n\tfloat h = b * b - c;\n\tif (h > 0.0) {\n        valid = true;\n        \n        vec3 p = camera + (-b - sqrt(h)) * dir;\n        pos = p.xz + iTime * vec2(0.005, 0.02);\n\t}\n\n\treturn valid;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 screen = fragCoord.xy / iResolution.xy;\n    \n    vec3 camera = vec3(0.0, 1.2, 0.7);\n    vec3 dir = getDir(screen);\n    \n    vec3 earth = vec3(0.0, 0.0, 0.0);\n    vec2 position;\n    if (getPosition(camera, dir, position)) {\n        float geography = fbm(6.0 * position);\n\n        float coast = 0.2 * pow(geography + 0.5, 50.0);\n        float population = smoothstep(0.2, 0.6, fbm(2.0 * position) + coast);\n        vec2 p = 40.0 * position;\n        population *= (noise_3(p) + coast); p = m * p;\n        population *= (noise_3(p) + coast); p = m * p;\n        population *= (noise_3(p) + coast); p = m * p;\n        population *= (noise_3(p) + coast); p = m * p;\n        population *= (noise_3(p) + coast);\n        population = smoothstep(0.0, 0.02, population);\n\n        vec3 land = vec3(0.1 + 2.0 * population, 0.07 + 1.3 * population, population);\n        vec3 water = vec3(0.0, 0.05, 0.1);\n        vec3 ground = mix(land, water, smoothstep(0.49, 0.5, geography));\n\n        vec2 wind = vec2(fbm(30.0 * position), fbm(60.0 * position));\n        float weather = fbm(20.0 * (position + 0.03 * wind)) * (0.6 + 0.4 * noise(10.0 * position));\n\n        float clouds = 0.8 * smoothstep(0.35, 0.45, weather) * smoothstep(-0.25, 1.0, fbm(wind));\n        earth = mix(ground, vec3(0.5, 0.5, 0.5), clouds); \n\n        float lightning = 0.0;\n        vec2 strike;\n        if (getPosition(camera, getDir(hash21(iTime)), strike)) {\n            vec2 diff = position - strike;\n            lightning += clamp(1.0 - 1500.0 * dot(diff, diff), 0.0, 1.0);\n        }\n        lightning *= smoothstep(0.65, 0.75, weather);\n        earth += lightning * vec3(1.0, 1.0, 1.0);\n    }\n    \n    vec3 altitude = camera - dir * dot(camera, dir);\n    float horizon = sqrt(dot(altitude, altitude));\n    \n    vec3 atmosphere = vec3(0.2, 0.25, 0.3);\n    atmosphere = mix(atmosphere, vec3(0.04, 0.06, 0.1), smoothstep(0.996, 1.004, horizon));\n    atmosphere = mix(atmosphere, vec3(0.1, 0.0, 0.0), smoothstep(1.0, 1.008, horizon));\n    atmosphere = mix(atmosphere, vec3(0.2, 0.17, 0.1), smoothstep(1.008, 1.015, horizon));\n    atmosphere = mix(atmosphere, vec3(0.0, 0.0, 0.0), smoothstep(1.015, 1.02, horizon));\n\n    horizon = clamp(pow(horizon, 20.0), 0.0, 1.0);\n    fragColor = vec4(mix(earth, atmosphere, horizon), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlXGD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[275, 275, 297, 297, 424], [426, 426, 448, 448, 615], [617, 617, 641, 641, 933], [935, 935, 959, 959, 1005], [1007, 1007, 1033, 1033, 1333], [1335, 1335, 1354, 1354, 1620], [1622, 1622, 1651, 1651, 1903], [1905, 1905, 1966, 1966, 2248], [2250, 2250, 2307, 2307, 4595]], "test": "valid"}
{"id": "XlXGDj", "name": "Blinn Phong", "author": "jimmikaelkael", "description": "A sphere with blinn phong shading.", "tags": ["phong", "blinn"], "likes": 18, "viewed": 2184, "published": "Public", "date": "1425042117", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvec3 ambientColor = vec3(0.05, 0.15, 0.2);\nvec3 diffuseColor = vec3(0.2, 0.6, 0.8);\nvec3 specularColor = vec3(1.0, 1.0, 1.0);\nvec3 lightDir = normalize(vec3(0.0, 4.0, 5.0));\nvec3 spherePos = vec3(0.0, 0.5, 0.0);\n\nfloat raytraceSphere(in vec3 ro, in vec3 rd, float tmin, float tmax, float r) {\n    vec3 ce = ro - spherePos;\n    float b = dot(rd, ce);\n    float c = dot(ce, ce) - r * r;\n    float t = b * b - c;\n    if (t > tmin) {\n        t = -b - sqrt(t);\n        if (t < tmax)\n            return t;\n        }\n    return -1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;\n    vec3 eye = vec3(0.0, 1.0, 2.0);\n    vec2 rot = 6.2831 * (vec2(0.1 + iTime * 0.25, 0.0) + vec2(1.0, 0.0) * (iMouse.xy - iResolution.xy * 0.25) / iResolution.x);\n    eye.yz = cos(rot.y) * eye.yz + sin(rot.y) * eye.zy * vec2(-1.0, 1.0);\n    eye.xz = cos(rot.x) * eye.xz + sin(rot.x) * eye.zx * vec2(1.0, -1.0);\n\n    vec3 ro = eye;\n    vec3 ta = vec3(0.0, 0.5, 0.0);\n\n    vec3 cw = normalize(ta - eye);\n    vec3 cu = normalize(cross(vec3(0.0, 1.0, 0.0), cw));\n    vec3 cv = normalize(cross(cw, cu));\n    mat3 cam = mat3(cu, cv, cw);\n\n    vec3 rd = cam * normalize(vec3(p.xy, 1.5));\n\n    vec3 color;\n\n    float tmin = 0.1;\n    float tmax = 50.0;\n    float t = raytraceSphere(ro, rd, tmin, tmax, 1.0);\n    if (t > tmin && t < tmax) {\n        vec3 pos = ro + rd * t;\n        vec3 norm = normalize(pos - spherePos);\n        float occ = 0.5 + 0.5 * norm.y;\n\n        float amb = clamp(0.5 + 0.5 * norm.y, 0.0, 1.0);\n        float dif = clamp(dot(lightDir, norm), 0.0, 1.0);\n\n        vec3 h = normalize(-rd + lightDir);\n        float spe = pow(clamp(dot(h, norm), 0.0, 1.0), 64.0);\n\n        color = amb * ambientColor * occ;\n        color += dif * diffuseColor * occ;\n        color += dif * spe * specularColor * occ;\n    }\n\n    vec3 gamma = vec3(1.0 / 2.2);\n    fragColor = vec4(pow(color, gamma), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlXGDj.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[301, 301, 380, 380, 616], [618, 618, 675, 675, 2044]], "test": "valid"}
{"id": "XlXGRf", "name": "SHADE A DAY ( 2 / 12 / 2015 )", "author": "cabbibo", "description": "continuing on the path of gold", "tags": ["raytrace", "reflections"], "likes": 3, "viewed": 282, "published": "Public", "date": "1423753544", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float MAX_TRACE_DISTANCE = 10.0;             // max trace distance\nconst float INTERSECTION_PRECISION = 0.0001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 100;\nconst float PI = 3.14159;\n\nconst int lightNum = 10;\nvec3 lightPos[ lightNum ];\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \n\treturn (d1.x<d2.x) ? d1 : d2;\n    \n}\n\n\nvec2 centerSphere( vec3 pos , float time ){\n    return vec2( sin(iTime + cos( pos.x * 2. ) + sin( pos.y )+ cos( pos.z * .59))*.1 + length( pos ) - .8 , 0. );\n}\n\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos ){  \n    \n   \t//vec2 res = vec2( (abs(sin( pos.x * pos.y * pos.z  * 10.)) * 1.9 ) + length( pos ) - 1., 0.0 );\n  \n    vec2 res = centerSphere( pos , iTime );\n    \n    //vec2 res = vec2( length( pos ) - .6  , 0. );\n    \n    for( int i = 0; i < lightNum; i++ ){\n     \n        float d = length( pos - lightPos[i] );\n        vec2 res2 =vec2( d - (pow(((sin(float( i) + 10.*sin( iTime ))) / float(lightNum)) , 2.) * 10.5 + .3) , 1. ); \n        res = opU( res ,  res2 );\n        \n    }\n    \n\n    \n   \treturn res;\n    \n}\n\n\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 0.3 + 1.0*mouseX;\n\tcamPos = vec3(3.5*sin(an),cos( time * .1 ),3.5*cos(an));\n    camTar = vec3(sin( time * .1) ,0.0,0.0);\n}\n\n\n\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n    \n\tvec3 eps = vec3( 0.01, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\n\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t );\n        h = m.x;\n        t += h;\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n   \n}\n\n\nvec3 lightCol( vec3 pos , vec3 nor , vec3 lig , vec3 eye ){\n  \n    vec3 col;\n    \n\n \tvec3 light = normalize( lig - pos );\n \tfloat lightLength = length( lig - pos );\n    vec3 refl = reflect( light , nor );\n\n    float lightMatch = max( 0. , dot( light  , nor ));\n\n    float reflMatch =  max( 0. , dot( eye , refl) );\n\n\n\n    vec3 lamb = pow( lightMatch,3.) *  vec3( 1. , .3 , .1 );\n    vec3 spec = pow( reflMatch , 20. ) *  vec3( 1. , .5 , .0 ) ;\n\n    col = spec + lamb;\n\n\treturn col;\n    \n    \n}\n\nvec3 doBackground( vec3 rd , vec3 ogRD ){\n \n    vec3 col = vec3(0.);\n    col = pow( max( 0. , dot( ogRD , rd )) , 100.)* vec3( 1. , .6 , .2 );; \n    col +=pow( max( 0. , dot( vec3( 0. , 0. , 1. ) , rd )) , 10.)* vec3( 1. , .5 , .2 );\n    col +=pow( max( 0. , dot( normalize(vec3( 1. , 1. , -1. )) , rd )) , 10.)* vec3( 1. , .5 , .2 );   \n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n   \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    m.x = sin( iTime * .1 );\n    \n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m.x );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    vec3 ogRD = normalize( camMat * vec3(0. , 0.,2.0) );\n    \n       \t    \n    for( int i = 0; i < lightNum; i++ ){\n     \n        float x = 1.5 * cos( (float(i) / float( lightNum ) ) * 2. * PI );\n        float z = 1.5 * sin( (float(i) / float( lightNum )  ) * 2. * PI );\n        float y = 1. * cos( (float(i) / float( lightNum ) ) * 8. * PI );\n        lightPos[i] = vec3( x  , y , z );\n        \n    }\n    \n    vec2 res = calcIntersection( ro , rd  );\n    \n    vec3 col = vec3( 0. , 0. , 0. ); \n    \n        // If we have hit something lets get real!\n    if( res.y > -.5 ){\n            \n        vec3 pos = ro + rd * res.x;\n        vec3 nor = calcNormal( pos );\n            \n\n        float eyeMatch = max( 0. , dot( -nor , rd ));\n\t\tvec3 rim  = pow( (1.-eyeMatch) , 3. ) * vec3( 1. , .5 , .2 );// * ( nor * .5 + .5 );\n\n\n\n        \n        vec3 refl = normalize( reflect( rd , nor ));\n        vec3 sta2 = pos + (refl * .001 );\n        vec2 res2 = calcIntersection( sta2 , refl );\n\n        if( res2.y > -.5 ){\n\n\n            vec3 p2 = pos + refl * res2.x;\n            vec3 n2 = calcNormal( p2 );\n            \n            //col = n2 * .5  + .5;\n            for( int i =0; i < lightNum; i++ ){  \n                col +=  lightCol( sta2 , n2 , lightPos[i] , refl );  \n            }\n            \n            \n            float eyeMatch = max( 0. , dot( -n2 , refl ));\n\t\t\tvec3 rim  = pow( (1.-eyeMatch) , 3. ) * vec3( 1. , .5 , .2 );\n            if( res2.y < .5 ){\n                \n                col = rim;\n                \n                \n            }\n            \n          \n\n        }else{\n\n            for( int i =0; i < lightNum; i++ ){  \n                col +=  lightCol( pos , nor , lightPos[i] , rd );  \n            }\n\n            col += rim;\n            \n            if( res.y < .5 ){\n                \n                col = rim;\n                \n                \n            }\n\n        }\n\n\n\n        \n    }else{\n    \tcol = doBackground(rd , ogRD);  \n    }\n    \n    // apply gamma correction\n    col = pow( col, vec3(0.4545) );\n\n    fragColor = vec4( col , 1. );\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlXGRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[274, 274, 294, 294, 366], [368, 462, 491, 491, 534], [537, 537, 580, 580, 696], [698, 782, 803, 911, 1314], [1318, 1349, 1413, 1413, 1591], [1593, 1593, 1676, 1676, 1814], [1819, 1932, 1963, 1963, 2188], [2193, 2193, 2241, 2241, 2712], [2715, 2715, 2774, 2774, 3208], [3210, 3210, 3251, 3251, 3570]], "test": "valid"}
{"id": "XlXGzS", "name": "Martian Elevated", "author": "ForestCSharp", "description": "Modifications to the Elevated Shader created by iq", "tags": ["proceduralterrain"], "likes": 3, "viewed": 1376, "published": "Public API", "date": "1425158361", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst mat2 m2 = mat2(0.8,-0.6,0.6,0.8);\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*texture( iChannel0, p/256.0 ).x; p = m2*p*2.02;\n    f += 0.2500*texture( iChannel0, p/256.0 ).x; p = m2*p*2.03;\n    f += 0.1250*texture( iChannel0, p/256.0 ).x; p = m2*p*2.01;\n    f += 0.0625*texture( iChannel0, p/256.0 ).x;\n    return f/0.9375;\n}\n// value noise, and its analytical derivatives\nvec3 noised( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    vec2 u = f*f*(3.0-2.0*f);\n\tfloat a = texture(iChannel0,(p+vec2(0.5,0.5))/256.0,-100.0).x;\n\tfloat b = texture(iChannel0,(p+vec2(1.5,0.5))/256.0,-100.0).x;\n\tfloat c = texture(iChannel0,(p+vec2(0.5,1.5))/256.0,-100.0).x;\n\tfloat d = texture(iChannel0,(p+vec2(1.5,1.5))/256.0,-100.0).x;\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\t6.0*f*(1.0-f)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\nvec3 noiseFrac(in vec2 x)\n{\n \tvec3 f = vec3(0.,0.,0.);\n    f+= 0.5000 * noised(x); x = x * 1.02;\n    f+= 0.2500 * noised(x); x = x * 11.01;\n    f+= 0.1250 * noised(x); x = x * 1.03;\n    f+= 0.0625 * noised(x); x = x * 1.015;\n    return f;\n}\n\n\nfloat terrain( in vec2 x )\n{\n\tvec2  p = x*0.003;\n    float a = 0.0;\n    float b = 1.0;\n\tvec2  d = vec2(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 n = noiseFrac(p);\n        d += n.yz;\n        a += b*n.x/(1.0+dot(d,d));\n\t\tb *= 0.5;\n        p = m2*p*2.0;\n    }\n\n\treturn 140.0*a;\n}\n\nfloat terrain2( in vec2 x )\n{\n\tvec2  p = x*0.003;\n    float a = 0.0;\n    float b = 1.0;\n\tvec2  d = vec2(0.0);\n    for( int i=0; i<12; i++ )\n    {\n        vec3 n = noised(p);\n        d += n.yz;\n        a += b*n.x/(1.0+dot(d,d));\n\t\tb *= 0.56;\n        p = m2*p*2.0;\n    }\n\n\treturn 140.0*a;\n}\n\nfloat terrain3( in vec2 x )\n{\n\tvec2  p = x*0.003;\n    float a = 0.10;\n    float b = 1.0;\n\tvec2  d = vec2(0.0);\n    for( int i=0; i<2; i++ )\n    {\n        vec3 n = noiseFrac(p * 0.0625);\n        d += n.yz;\n        a += b*n.x/(1.0+dot(d,d));\n\t\tb *= 0.5;\n        p = m2*p*2.0;\n    }\n\n\treturn 190.0*a;\n}\n\nfloat map( in vec3 p )\n{\n    return p.y - terrain(p.xz);\n}\n\nfloat interesct( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\n{\n    float t = tmin;\n\tfor( int i=0; i<120; i++ )\n\t{\n\t\tfloat h = map( ro + t*rd );\n\t\tif( h<(0.002*t) || t>tmax ) break;\n\t\tt += 0.5*h;\n\t}\n\n\treturn t;\n}\n\n\nvec3 calcNormal( in vec3 pos, float t )\n{\n    vec2  eps = vec2( 0.002*t, 0.0 );\n    return normalize( vec3( terrain2(pos.xz-eps.xy) - terrain2(pos.xz+eps.xy),\n                            2.0*eps.x,\n                            terrain2(pos.xz-eps.yx) - terrain2(pos.xz+eps.yx) ) );\n}\n\nvec3 camPath( float time )\n{\n\treturn 1100.0* vec3( cos(0.0+0.23*time), 200.0, cos(1.5+0.21*time*0.25) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = -1.0 + 2.0*fragCoord.xy/iResolution.xy;\n\tvec2 s = xy*vec2(iResolution.x/iResolution.y,1.0);\n\t\n    float time = 20.0 + iTime * 0.25;\n\t\n\tvec3 light1 = normalize( vec3(-0.8,0.4,-0.3) );\n\n    // camera position\n\tvec3 ro = camPath( time );\n\tvec3 ta = camPath( time + 3.0 );\n\tro.y = terrain3( ro.xz ) + 11.0;\n\tta.y = ro.y - 20.0;\n\tfloat cr = 0.2*cos(0.1*time);\n\n    // Generate Ray   \n\tvec3  cw = normalize(ta-ro);\n\tvec3  cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3  cu = normalize( cross(cw,cp) );\n\tvec3  cv = normalize( cross(cu,cw) );\n\tvec3  rd = normalize( s.x*cu + s.y*cv + 2.0*cw );\n    \n    // bounding plane\n    float tmin = 2.0;\n    float tmax = 2000.0;\n    float maxh = 210.0;\n    float tp = (maxh-ro.y)/rd.y;\n    if( tp>0.0 )\n    {\n        if( ro.y>maxh ) tmin = max( tmin, tp );\n        else            tmax = min( tmax, tp );\n    }\n\n\tvec3 col = vec3(0.0,0.0,0.0);\n    float t = interesct( ro, rd, tmin, tmax );\n    \n    if( t>tmax) //SKY//\n    {\n        // clouds\n\t\tvec2 sc = ro.xz + rd.xz*(1000.0-ro.y)/rd.y * 25.;\n\t\tcol = mix( col, vec3(1.0,0.95,1.0), 0.5*smoothstep(0.1,1.8,fbm(0.000045*sc)) );\n        // horizon\n        col = mix( col, vec3(0.7,0.1,0.0), pow( 1.0-max(rd.y/ 4.,0.0), 8.0 ) );\n\t}\n    \n\telse //TERRAIN//\n\t{\n        // mountains\t\t\n\t\tvec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, t );\n        vec3 ref = reflect( rd, nor );\n        float fre = clamp( 1.0+dot(rd,nor), 0.0, 1.0 );\n        \n        // rock\n\t\tfloat r = texture( iChannel2, 7.0*pos.xz/256.0 ).x;\n        col = (r*0.25+0.75)*0.9*mix( vec3(0.06,0.05,0.03), vec3(0.40,0.00,0.08), texture(iChannel0,0.00007*vec2(pos.x,pos.y*48.0)).x );\n\n\t\t// dirt\n\t\tfloat h = 1.0;\n        float e = smoothstep(1.0-0.5*h,1.0-0.1*h,nor.y);\n        float o = 1.0;\n        float s = h*e*o;\n        col = mix( col, 0.29*vec3(0.92,0.45,0.4), smoothstep( 0.1, 0.9, s ) );\n\t\t\n         // lighting\t\t\n        float amb = 0.1;\n\t\tfloat dif =  0.4 *clamp( dot( light1, nor ), 0.0, 1.0 );\n\t\tfloat bac = clamp( 0.2 + 0.8*dot( normalize( vec3(-light1.x, 0.0, light1.z ) ), nor ), 0.0, 1.0 );\n\t\tfloat sh = 0.8;\n\t\t\n\t\tvec3 lin  = vec3(0.0);\n\t\tlin += dif*vec3(7.00,5.00,3.00)*vec3( sh, sh*sh*0.5+0.5*sh, sh*sh*0.8+0.2*sh );\n\t\tlin += amb*vec3(0.40,0.60,0.80)*1.2;\n        lin += bac*vec3(0.40,0.50,0.60);\n\t\tcol *= lin;\n        \n        col += s*0.1*pow(fre,4.0)*vec3(7.0,5.0,3.0)*sh * pow( clamp(dot(light1,ref), 0.0, 1.0),16.0);\n        col += s*0.1*pow(fre,4.0)*vec3(0.4,0.5,0.6)*smoothstep(0.0,0.6,ref.y);\n\n\t}\n\n    // gamma\n\tcol = pow(col,vec3(0.4045));\n\n\tfragColor=vec4(col,1.0);\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlXGzS.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[166, 166, 187, 187, 470], [471, 518, 544, 544, 983], [985, 985, 1012, 1012, 1225], [1228, 1228, 1256, 1256, 1516], [1518, 1518, 1547, 1547, 1806], [1808, 1808, 1837, 1837, 2107], [2109, 2109, 2133, 2133, 2167], [2169, 2169, 2242, 2242, 2391], [2394, 2394, 2435, 2435, 2676], [2678, 2678, 2706, 2706, 2784], [2787, 2787, 2844, 2844, 5396]], "test": "error"}
{"id": "Xtf3RB", "name": "Ico-Disco", "author": "dr2", "description": "This is the answer to nimitz's next question; the dodecahedron (see MtsGW7) is left as an exercise.", "tags": ["raymarching", "icosahedron", "symmetry"], "likes": 2, "viewed": 815, "published": "Public API", "date": "1422786984", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Ico-Disco\" by dr2 - 2015\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nint idObj;\nmat3 rMat[20];\nvec3 ltDir;\nfloat tCur, eLen, chLen, chRad;\nconst float C_ab = -0.364863828, C_ia = 0.55357435, C_d = 0.288675135,\n   C_r = 0.80901699;\nconst float pi = 3.14159;\nconst float dstFar = 20.;\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) * vec2 (1., 1.) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n\nfloat IcosDf (vec3 p)\n{\n  p.z -= C_r * eLen;\n  p.yz = Rot2D (p.yz, C_ab);\n  p.y += C_d * eLen;\n  p.xy = Rot2D (p.xy, floor (0.5 + atan (p.x, p.y) * (1.5 / pi)) * (pi / 1.5));\n  p.y -= C_d * chLen;  \n  return PrCapsDf (p.yzx, chRad, 0.5 * chLen);\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float d, dHit;\n  dHit = dstFar;\n  d = dHit;\n  q = p * rMat[0] ;  d = min (d, IcosDf (q));\n  q = p * rMat[1] ;  d = min (d, IcosDf (q));\n  q = p * rMat[2] ;  d = min (d, IcosDf (q));\n  q = p * rMat[3] ;  d = min (d, IcosDf (q));\n  q = p * rMat[4] ;  d = min (d, IcosDf (q));\n  q = p * rMat[5] ;  d = min (d, IcosDf (q));\n  q = p * rMat[6] ;  d = min (d, IcosDf (q));\n  q = p * rMat[7] ;  d = min (d, IcosDf (q));\n  q = p * rMat[8] ;  d = min (d, IcosDf (q));\n  q = p * rMat[9] ;  d = min (d, IcosDf (q));\n  q = p * rMat[10];  d = min (d, IcosDf (q));\n  q = p * rMat[11];  d = min (d, IcosDf (q));\n  q = p * rMat[12];  d = min (d, IcosDf (q));\n  q = p * rMat[13];  d = min (d, IcosDf (q));\n  q = p * rMat[14];  d = min (d, IcosDf (q));\n  q = p * rMat[15];  d = min (d, IcosDf (q));\n  q = p * rMat[16];  d = min (d, IcosDf (q));\n  q = p * rMat[17];  d = min (d, IcosDf (q));\n  q = p * rMat[18];  d = min (d, IcosDf (q));\n  q = p * rMat[19];  d = min (d, IcosDf (q));\n  if (d < dHit) { dHit = d;  idObj = 1; }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  vec4 v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * vec3 (v.y, v.z, v.w));\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nmat3 RotToRMat (vec3 v, float a)\n{\n  mat3 m;\n  float c, s, a1, a2;\n  c = cos (a);\n  s = sin (a);\n  m[0][0] = (1. - c) * v.x * v.x + c;\n  m[1][1] = (1. - c) * v.y * v.y + c;\n  m[2][2] = (1. - c) * v.z * v.z + c;\n  a1 = (1. - c) * v.x * v.y;\n  a2 = -s * v.z;\n  m[0][1] = a1 + a2;\n  m[1][0] = a1 - a2;\n  a1 = (1. - c) * v.z * v.x;\n  a2 = -s * v.y;\n  m[2][0] = a1 + a2;\n  m[0][2] = a1 - a2;\n  a1 = (1. - c) * v.y * v.z;\n  a2 = -s * v.x;\n  m[1][2] = a1 + a2;\n  m[2][1] = a1 - a2;\n  return m;\n}\n\nvoid BuildRMats ()\n{\n  mat3 axMat[3];\n  axMat[0] = RotToRMat (vec3 (1., 0., 0.), pi);\n  axMat[1] = RotToRMat (vec3 (0., cos (C_ia), sin (C_ia)), 0.4 * pi);\n  axMat[2] = RotToRMat (vec3 (0., 1., 0.), pi);\n  for (int i = 0; i < 3; i ++) {\n    for (int j = 0; j < 3; j ++) rMat[0][i][j] = 0.;\n    rMat[0][i][i] = 1.;\n  }\n  rMat[1]  = axMat[0];\n  rMat[2]  = axMat[1];\n  rMat[3]  = rMat[2] * axMat[1];\n  rMat[4]  = rMat[3] * axMat[1];\n  rMat[5]  = rMat[4] * axMat[1];\n  rMat[6]  = rMat[1] * axMat[1];\n  rMat[7]  = rMat[6] * axMat[1];\n  rMat[8]  = rMat[7] * axMat[1];\n  rMat[9]  = rMat[8] * axMat[1];\n  rMat[10] = axMat[2];\n  rMat[11] = rMat[1] * axMat[2];\n  rMat[12] = rMat[2] * axMat[2];\n  rMat[13] = rMat[3] * axMat[2];\n  rMat[14] = rMat[4] * axMat[2];\n  rMat[15] = rMat[5] * axMat[2];\n  rMat[16] = rMat[6] * axMat[2];\n  rMat[17] = rMat[7] * axMat[2];\n  rMat[18] = rMat[8] * axMat[2];\n  rMat[19] = rMat[9] * axMat[2];\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float dstHit;\n  eLen = 1. + 0.3 * (1. + cos (tCur));\n  chLen = 0.85;\n  chRad = 0.03;\n  idObj = -1;\n  dstHit = ObjRay (ro, rd);\n  if (idObj < 0) dstHit = dstFar;\n  if (dstHit >= dstFar) col = vec3 (0.05);\n  else {\n    ro += rd * dstHit;\n    vn = ObjNf (ro);\n    col = HsvToRgb (vec3 (mod (0.5 * tCur, 1.), 1., 1.)) *\n       (0.3 + 0.8 * max (dot (vn, ltDir), 0.)) +\n       0.5 * pow (max (0., dot (ltDir, reflect (rd, vn))), 128.);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n  uv.x *= iResolution.x / iResolution.y;\n  tCur = iTime;\n  mat3 vuMat;\n  vec3 ro, rd;\n  vec2 vEl, vAz;\n  float az, el;\n  el = 0.05 * tCur;\n  az = 0.11 * tCur;\n  vEl = vec2 (cos (el), sin (el));\n  vAz = vec2 (cos (az), sin (az));\n  vuMat = mat3 (1., 0., 0., 0., vEl.x, - vEl.y, 0., vEl.y, vEl.x) *\n     mat3 (vAz.x, 0., vAz.y, 0., 1., 0., - vAz.y, 0., vAz.x);\n  rd = normalize (vec3 (uv, 5.5)) * vuMat;\n  ro = - vec3 (0., 0., 8.) * vuMat;\n  ltDir = normalize (vec3 (1., 1., -1.)) * vuMat;\n  BuildRMats ();\n  vec3 col = ShowScene (ro, rd);\n  fragColor = vec4 (col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xtf3RB.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[332, 332, 362, 362, 436], [438, 438, 481, 481, 554], [556, 556, 579, 579, 803], [805, 805, 827, 827, 1862], [1864, 1864, 1885, 1885, 2108], [2110, 2110, 2143, 2143, 2319], [2321, 2321, 2355, 2355, 2809], [2811, 2811, 2831, 2831, 3727], [3729, 3729, 3753, 3753, 3884], [3886, 3886, 3921, 3921, 4406], [4408, 4408, 4465, 4465, 5088]], "test": "valid"}
{"id": "Xtf3Rj", "name": "Dawn of the Tentacle", "author": "Kali", "description": "Mouse enabled.", "tags": ["raymarching", "distancefield"], "likes": 23, "viewed": 803, "published": "Public", "date": "1423183475", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* \n---------------------------------------------------------------------------------------\n\n \"Dawn of the Tentacle\" by Pablo Roman Andrioli (Kali)\n \n Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n--------------------------------------------------------------------------------------- \n*/\n\n\n//smooth version by iq\n#define smoothversion \n\n//remove if you see a flat shaded tentacle \n//(it happens to me in firefox)\n#define underwater \n\n\n// Raymarching \nconst float zoom=.95; \nconst float detail=.017;    // distance to stop tracing\nconst float maxdist=14.;    // scene depth\nconst int maxsteps=55;      // max ray steps\n\n// Light \nconst vec3 lightdir=vec3(.6,-1.,0.); \nconst float diffuse=.7;\nconst float specular=.7;\nconst float specularexp=5.;\n\n// Tentacle Shape\nconst float maxiter=28.;    // Max iterations \nconst float width=.9; \nconst float height=0.52;\nconst float scaling=0.92;\t   // Scaling factor at each iteration\nconst vec3 rotvector=vec3(1.,0.,0.); // Base vector for rotation\nconst float anglevary=.2;    // Angle variation at each iteration\n\n// Animation \nconst float amplitude=0.55;   \nconst float speed=0.6;\nconst float dynscaling=0.9; // Scaling factor for the dynamic fractal animation\n\n\n//-------------------------------------------------------------------------------------------\n\nvec3 dir;\nvec2 pix;\nvec2 coord;\n\n\n// Rotation function included in MathUtils.frag of Syntopia's Fragmentarium \nmat3 rotationMat(vec3 v, float angle)\n{\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\t\n\treturn mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n\t\t(1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n\t\t(1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z\n\t\t);\n}\n\n\n// Water\nfloat water(vec3 p){\n\t//p.z-=15.;\n\tfloat l=length(p.xz);\n\tp.x+=l*3.;\n\tp.x-=iTime*1.5;\n\tfloat h=(sin(p.x)+cos(p.z))*.05;\n\tp.xz*=vec2(3,2.5);\n\tp.xz+vec2(1.,2.5);\n\th+=(cos(p.x)+sin(p.z))*.05;\n\th+=texture(iChannel0,p.xz*.2).z*max(0.1,.2-l*l*.01); //texture displacement\n\treturn p.y-h;\n}\n\n\nfloat smin( float a, float b )\n{\nfloat k = 0.1; float h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\nreturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n// Scene DE\nvec2 DE(vec3 pos){\n\n\tfloat angle=0.;\n\tvec3 p=pos;\n\tint n = 0;\n\tfloat sc=1.;\n\tfloat time=iTime*speed+100.;\n\tfloat amp=sin(time/2.)*amplitude;\n\tfloat dtent=1e10;\n\tfloat dd=1e10;\n\tfloat minit=maxiter;\n\tvec3 minp=pos;\n\tfor (float n=0.; n < maxiter; n++) {\n\t\tfloat d1=length(p)-width*sc; \n\t\tfloat d2=length(p+vec3(width*sc*.75,0.,0.))-width*sc*.4; \n\t\tfloat d=min(d1,d2);\n\t\tif (n<1.) dtent=d;\n\t\tif (d<=dtent) { //test min distance and save iteration & vector\n\t\t\tdtent=d;\n\t\t\tminit=n;\n\t\t\tminp=p;\n\t\t}\n\t\t#ifdef smoothversion\n\t\tdd=smin(dd,d);\n\t\t#endif\n\t\t\n\t\tp*=rotationMat(normalize(rotvector+vec3(0.,sin(iTime)*.7,0.)),sin(time)*amp+angle);\n\t\tp.y-=height*sc; // go up\n\t\tsc*=scaling; // scale size\n\t//\tamp*=dynscaling; // scale amplitude\n\t\ttime/=dynscaling; // scale time\n\t\tangle+=radians(anglevary); // vary rotation\n\t}\n\t\t#ifdef smoothversion\n\t\tdtent=dd;\n\t\t#endif\t\n\t\n\tdtent+=length(texture(iChannel1,vec2(minp.y*2.,atan(minp.x,minp.z)*.8)).xyz)*.025;\n\t\n\tfloat dwat=water(pos);\n\tfloat de=min(dwat,dtent);\n\tfloat col=0.;\n\tif (de!=dwat) col=minit+1.; // return coloring parameter\n\treturn vec2(de,col);\n}\n\n\n// finite difference normal\nvec3 normal(vec3 pos) {\n\tvec3 e = vec3(0.0,detail,0.0);\n\t\n\treturn normalize(vec3(\n\t\t\tDE(pos+e.yxx).x-DE(pos-e.yxx).x,\n\t\t\tDE(pos+e.xyx).x-DE(pos-e.xyx).x,\n\t\t\tDE(pos+e.xxy).x-DE(pos-e.xxy).x\n\t\t\t)\n\t\t);\t\n}\n\n// coloring\nvec3 color(float obj, vec3 p) {\n\n\tif (obj<1.) { //water\n\t\tvec3 tex=texture(iChannel0,p.xz*.1).xyz;\n\t\treturn (tex+.2)*vec3(1.7,1.2,1.2);\n\t} \n\telse if (obj>0.) {//tentacle\n\t\tfloat g=(maxiter-obj)/maxiter;\n\t\treturn vec3(.9,g+.2,0.6);\n\t}\n\t\n}\n\n//lighting\nvec3 light(vec3 p) {\nvec3 ldir=normalize(lightdir);\nvec3 n=normal(p);\nfloat diff=max(0.0,dot(-n, ldir))*diffuse;\nvec3 r = reflect(ldir,n);\nfloat spec=max(0.,dot(dir,-r));\nreturn vec3(1.,.8,.5)*(diff+pow(spec,specularexp)*specular);\t\n}\n\n//raymarching\nvec3 raymarch(vec3 from, vec3 dir) {\n\tvec3 p,p2;\n\tfloat totdist=0., totdist2=0.;\n\tvec3 col;\n\tvec2 d=vec2(0.);\n\tfloat d2=100000.;\n\t//march\n\tfor (int i=1; i<maxsteps; i++) {\n\t\tp=from+totdist*dir;\n\t\td=DE(p);\n\t\tif (d.x<detail || totdist>maxdist) break;\n\t\t#ifdef smoothversion\n\t\t\ttotdist+=max(.1,d.x); \n\t\t#else\n\t\t\ttotdist+=max(.01,d.x); \n\t\t#endif\n\t}\n\n\t//underwater\n\tif (d.x<detail && d.y<.5) {\n\t\ttotdist2=totdist+detail*3.;\n\t\tfor (int i=1; i<maxsteps; i++) {\n\t\t\tp2=from+totdist2*dir;\n\t\t\td2=length(p2.xz)-width/scaling+p2.y*.2;\n\t\t\tif (d2<detail || totdist2>maxdist) break;\n\t\t\ttotdist2+=d2; \n\t\t}\n\t}\n\t\n\t\n\tvec3 back=mix(vec3(1.3,.95,.7),vec3(.52,.5,.56) //background gradient\n\t*1.25,clamp((dir.y+.13)*2.5,0.,1.35)); \n\tback+=vec3(1.,1.,.5)*(.04+dot(lightdir,-dir)*.4); //dawn\n\t\n\tif (d.x<detail) {\n\t\tcol=color(d.y,p)*light(p-detail*dir*.5); //apply color+light\n\t\tcol=mix(col,back,smoothstep(0.,2.2,totdist*.17)); //fog\n\t} else { //background-sky \n\t\tcol=back+.85*vec3(1.,.85,.7)*texture(iChannel1,\n\t\tvec2(dir.y*4.+.5,atan(dir.z,dir.x)*1.8)*.15+vec2(iTime*.002)).b*(dir.y*.75+.15)\n\t\t*vec3(max(0.1,.5-coord.y*2.5))*1.4;\n\t\tcol-=vec3(max(0.,coord.y*.3));\n\t}\n\t#ifdef underwater\n\tif (d2<detail) {\n\t\tvec3 col2=color(1.1,p2)*light(p+p2-detail*dir*.5); \n\t\tcol=mix(col,col2,.3); //underwater\n\t}\n\t#endif\n\t\n\tcol+=vec3(1.,.7,.5)*max(0.,9.-totdist)*.04; //camlight\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//Camera\n\tpix=fragCoord.xy / iResolution.xy;\n\tfloat viewangle=-135.+(iMouse.x/iResolution.x)*100.; \n\tmat3 rotview=rotationMat(vec3(0.,1.,0.),radians(viewangle));\n\tcoord = pix-vec2(.5);\n\tcoord.y*=iResolution.y/iResolution.x;\n\tvec3 from=vec3(0.,2.85,8.)*rotview*zoom;\n\tdir=normalize(vec3(coord*1.8,-1.))*rotview;\n\t\n\t//Draw scene\n\tvec3 col=vec3(0.);\n\tcol=raymarch(from,dir); \n\t\n\t//adjust levels\n\tcol*=pow(length(col),1.8)*.41; \n\tcol+=vec3(0.02,-.01,0.05);\n\tcol=mix(col,vec3(length(col))*.6,.3);\n\t\n\tfragColor = vec4(col,1);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xtf3Rj.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1366, 1443, 1482, 1482, 1832], [1835, 1844, 1864, 1877, 2126], [2129, 2129, 2161, 2161, 2263], [2266, 2278, 2296, 2296, 3367], [3370, 3398, 3421, 3421, 3599], [3601, 3613, 3644, 3644, 3850], [3852, 3863, 3883, 3883, 4097], [4099, 4113, 4149, 4149, 5466], [5468, 5468, 5525, 5535, 6048]], "test": "error"}
{"id": "Xtf3WB", "name": "effusing lava", "author": "nexor", "description": "I tried to create a cracks as the lava covers the ground, but couldn't figure out how to control voronoi to look like it.\nHash, noise, fbm and voronoi functions are all taken from iq's tutorial.", "tags": ["voronoi", "noise", "lava"], "likes": 34, "viewed": 1038, "published": "Public", "date": "1424645266", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime\n#define resolution iResolution.xy\n\nfloat hash( float n ){\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( vec2 uv ){\n    vec3 x = vec3(uv, 0);\n\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    \n    f       = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    \n    return mix(mix(mix( hash(n+0.0), hash(n+1.0),f.x),\n                   mix( hash(n+57.0), hash(n+58.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\nmat2 m = mat2(0.8,0.6,-0.6,0.8);\n\nfloat fbm(vec2 p)\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p*=m*2.02;\n    f += 0.2500*noise( p ); p*=m*2.03;\n    f += 0.1250*noise( p ); p*=m*2.01;\n    f += 0.0625*noise( p );\n    f /= 0.9375;\n    return f;\n}\n\nvec3 voronoi( in vec2 x )\n{\n    ivec2 p = ivec2(floor( x ));\n    vec2 f = fract(x);\n\n    ivec2 mb = ivec2(0);\n    vec2 mr = vec2(0.0);\n    vec2 mg = vec2(0.0);\n\n    float md = 8.0;\n    for(int j=-1; j<=1; ++j)\n    for(int i=-1; i<=1; ++i)\n    {\n        ivec2 b = ivec2( i, j );\n        vec2  r = vec2( b ) + noise( vec2(p + b) ) - f;\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = vec2(noise( vec2(p) + g ));\n        float d = length(r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\n    md = 8.0;\n    for(int j=-2; j<=2; ++j)\n    for(int i=-2; i<=2; ++i)\n    {\n        ivec2 b = ivec2( i, j );\n        vec2 r = vec2( b ) + noise( vec2(p + b) ) - f;\n\n\n        if( length(r-mr)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n    return vec3( md, mr );\n}\n\nvec2 tr(vec2 p)\n{\n \tp = -1.0+2.0*(p/resolution.xy);\n    p.x *= resolution.x/resolution.y;\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float map_radius = mod(600.0 - 250.0 * (time*0.05),600.0);\n\tvec2 focus = vec2(map_radius,0.0);\n\tfloat crack_radius = 50.0;\n\n\tfloat radius = max(1e-20,map_radius);\n\tvec2 fc = fragCoord.xy + focus - resolution/2.0;\n\tvec2 p = tr(fc);\n\n\tvec3 col = \tvec3(0.0);\n\n\tvec3 lava = vec3(0.0);\n\tvec3 ground = vec3(0.5,0.3,0.1);\n\tfloat vor = 0.0;\n\tfloat len = length(fc) + cos(fbm(p*15.0)*15.0)*15.0;\n    float crack = smoothstep(radius-crack_radius,radius,len);\n\n\t{\n\t\tfloat val = 1.0 + cos(p.x*p.y + fbm(p*5.0) * 20.0 + time*2.0)/ 2.0;\n\t\tlava = vec3(val*1.0, val*0.33, val*0.1);\n\t\tlava = mix(lava*0.95,lava,len-radius);\n\t\tlava *= exp(-1.8);\n\t}\n\n\t{\n\t\tfloat val = 1.0 + sin(fbm(p * 7.5) * 8.0) / 2.0;\n\t\tground *= exp(-val*0.3);\n\t\tvec3 sand = vec3(0.2,0.25,0.0);\n\t\tground = mix(ground,sand,val*0.1);\n\t}\n\n\t{   \n\t\tvor = voronoi(p*3.5).x*(1.0-crack)*0.75;\n\t\tvor = 1.0-vor;\n\t\tvor *= smoothstep(0.0,radius,len);\n\t}\n\n\tcol = mix(ground,lava,crack);\n\tcol = mix(col,lava,smoothstep(radius-crack_radius,radius,vor*radius));\n\n\tfragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xtf3WB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 54, 76, 76, 115], [117, 117, 140, 140, 543], [579, 579, 598, 598, 795], [797, 797, 824, 824, 1645], [1647, 1647, 1664, 1664, 1752], [1754, 1754, 1811, 1811, 2845]], "test": "valid"}
{"id": "XtfGW2", "name": "Daily: 28/2/15", "author": "hughsk", "description": "More tunnels!", "tags": ["tunnel", "rays", "shadeaday"], "likes": 10, "viewed": 395, "published": "Public", "date": "1425157204", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat fogFactorExp2(\n  const float dist,\n  const float density\n) {\n  const float LOG2 = -1.442695;\n  float d = density * dist;\n  return 1.0 - clamp(exp2(d * d * LOG2), 0.0, 1.0);\n}\n\n//------------------------------------------------------------------------\n// Camera\n//\n// Move the camera. In this case it's using time and the mouse position\n// to orbitate the camera around the origin of the world (0,0,0), where\n// the yellow sphere is.\n//------------------------------------------------------------------------\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 0.0;\n\tcamPos = vec3(3.5*sin(an),1.0,3.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n\n//------------------------------------------------------------------------\n// Background \n//\n// The background color. In this case it's just a black color.\n//------------------------------------------------------------------------\nvec3 doBackground( void )\n{\n    return vec3(0.02, 0.01, 0.03);\n}\n    \n//------------------------------------------------------------------------\n// Modelling \n//\n// Defines the shapes (a sphere in this case) through a distance field, in\n// this case it's a sphere of radius 1.\n//------------------------------------------------------------------------\nfloat doModel( vec3 p )\n{\n    float d = 10000000.0;\n\n    vec2 off = vec2(1.0, 0.0);\n    vec3 origin = vec3(0.0, 0.0, -0.5);\n    float move = iTime * -4.0;\n    float warp = 0.25;\n    \n    for (int i = 0; i < 15; i++) {\n        float I = float(i) - 5.0;\n        float J = I - floor(move);\n        vec3 P = p.xzy;\n        \n        P += off.yxy * I;\n        P += origin;\n        P += vec3(sin(J * 0.5 + move) * warp, mod(move, 1.0), cos(J * 0.9 + move) * warp);\n        \n        d = smin(d, sdTorus82(P, vec2(1.5, 0.155)), 1.4);\n    }\n    \n    return d;\n}\n\n//------------------------------------------------------------------------\n// Material \n//\n// Defines the material (colors, shading, pattern, texturing) of the model\n// at every point based on its position and normal. In this case, it simply\n// returns a constant yellow color.\n//------------------------------------------------------------------------\nvec3 doMaterial( in vec3 pos, in vec3 nor )\n{\n    return vec3(0.15, 0.3, 0.45);\n}\n\n//------------------------------------------------------------------------\n// Lighting\n//------------------------------------------------------------------------\nfloat calcSoftshadow( in vec3 ro, in vec3 rd );\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec3 mal )\n{\n    vec3 lin = vec3(0.0);\n\n    // key light\n    //-----------------------------\n    vec3  lig = normalize(vec3(0.0, 0.0, 1.5)-pos);\n    float dif = max(dot(nor,lig),0.0);\n    float sha = 0.0; if( dif>0.01 ) sha=calcSoftshadow( pos+0.01*nor, lig );\n    lin += dif*vec3(4.00,4.00,4.00)*sha;\n\n    // ambient light\n    //-----------------------------\n    lin += vec3(0.50,0.50,0.50);\n\n    \n    // surface-light interacion\n    //-----------------------------\n    vec3 col = mal*lin;\n\n    \n    // fog    \n    //-----------------------------\n\t//col *= exp(-0.03*dis*dis);\n\n    return col;\n}\n\nfloat calcIntersection( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 20.0;           // max trace distance\n\tconst float precis = 0.001;        // precission of the intersection\n    float h = precis*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for( int i=0; i<90; i++ )          // max number of raymarching iterations is 90\n    {\n        if( h<precis||t>maxd ) break;\n\t    h = doModel( ro+rd*t );\n        t += h;\n    }\n\n    if( t<maxd ) res = t;\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.002;             // precision of the normal computation\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( pos + v1*eps ) + \n\t\t\t\t\t  v2*doModel( pos + v2*eps ) + \n\t\t\t\t\t  v3*doModel( pos + v3*eps ) + \n\t\t\t\t\t  v4*doModel( pos + v4*eps ) );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.0005;                 // selfintersection avoidance distance\n\tfloat h = 1.0;\n    for( int i=0; i<8; i++ )         // 40 is the max numnber of raymarching steps\n    {\n        h = doModel(ro + rd*t);\n        res = min( res, 8.0*h/t );   // 64 is the hardness of the shadows\n\t\tt += clamp( h, 0.02, 2.0 );   // limit the max and min stepping distances\n    }\n    return clamp(res,0.0,1.0);\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m.x );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = doBackground();\n\n\t// raymarch\n    float t = calcIntersection( ro, rd );\n    if( t>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\n        // materials\n        vec3 mal = doMaterial( pos, nor );\n\n        col = mix(col, doLighting( pos, nor, rd, t, mal ), 1.0 - fogFactorExp2(t, 0.2));\n    }\n\n\t//-----------------------------------------------------\n\t// postprocessing\n    //-----------------------------------------------------\n    // gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n    col = col * (1.0 + dot(p, p * 0.1));\n    col.b = smoothstep(0.0, 0.8, col.b);\n    col = 1.5 - col;\n\t   \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtfGW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 134], [136, 136, 171, 171, 236], [238, 238, 304, 304, 418], [420, 752, 835, 835, 934], [937, 1168, 1195, 1195, 1232], [1238, 1520, 1545, 1545, 2071], [2073, 2426, 2471, 2471, 2507], [2720, 2720, 2804, 2804, 3388], [3390, 3390, 3440, 3440, 3857], [3859, 3859, 3891, 3891, 4303], [4305, 4305, 4353, 4353, 4777], [4779, 4779, 4843, 4843, 5021], [5023, 5023, 5080, 5080, 6429]], "test": "valid"}
{"id": "Xtl3RS", "name": "Basic line drawing", "author": "luutifa", "description": "Did this by request from a friend.\nWas harder than I thought it'd be.\nI think there is a \"faster\" way than ifs but not gonna do it now.", "tags": ["line", "geometry"], "likes": 4, "viewed": 530, "published": "Public", "date": "1422963683", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float PI = 3.14159265;\n\n    vec2 pos = fragCoord.xy/iResolution.yy;\n\n    //set bg color to black\n    fragColor = vec4(vec3(0.0), 1.0);\n\n    //Line width and point radius in openGL screen space 'units'\n    float lineSize = 0.005;\n    float pointSize = 0.007;\n\n    //points\n    //Feel free to set these however you want\n    vec2 point1 = vec2(sin(iTime)*0.2+0.5, cos(iTime)*0.2+0.5);\n    vec2 point2 = vec2(sin(iTime+PI)*0.2+0.5, cos(iTime+PI)*0.2+0.5);\n\n    //'k' for kulmakerroin :D\n    float k = (point1.y - point2.y)/(point1.x - point2.x);\n    float b = point1.y - k*point1.x;\n\n    /* //DAMN this was hard to wrap my head around!\n    point1.y = k*point1.x + b // -k*point1.x\n    point1.y - k*point1.x = b\n    */\n\n    vec2 line = vec2((pos.y-b)/k, pos.x*k+b);\n    float lineSizeHalf = lineSize/2.0;\n    \n    //if current pixel is inside the line, set it's color to white\n    if ((pos.y > line.y-lineSizeHalf && pos.y < line.y+lineSizeHalf) || (pos.x > line.x-lineSizeHalf && pos.x < line.x+lineSizeHalf))\n        fragColor = vec4(1.0);\n    \n    //if current pixel is inside any of the points, set it's color to red\n    if (length(pos-point1) < pointSize || length(pos-point2) < pointSize)\n        fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xtl3RS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 1300]], "test": "valid"}
{"id": "XtlGDS", "name": "Manhattan Voronoi", "author": "triclops200", "description": "Voronoi Diagram using Manhattan Distance", "tags": ["manhattan", "voroni"], "likes": 10, "viewed": 575, "published": "Public", "date": "1424821411", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 points[6];\nfloat abs_sum(vec2 xs){\n\treturn abs(xs[0]) + abs(xs[1]);\n}\n\nvec3 color_from_point(vec2 point){\n\treturn vec3(point[0]+cos(iTime*0.02)*0.1+0.1,sin(iTime*0.01)*0.1+0.1,point[1]+0.3);\n}\n\nvec3 minimumDistColor(vec2 point){\n\tvec2 del = points[0] - point;\n\tfloat min_dist_sq = abs_sum(del);\n\tvec3 min_color = color_from_point(points[0]);\n\tif(min_dist_sq<0.005) return color_from_point(vec2(0.5,0.2))-vec3(0.2,0.2,0.2);\n\tfor(int i=0;i<6;i++){\n\t\tdel = points[i]-point;\n\t\tfloat d = abs_sum(del);\n\t\tif(d < 0.005) return color_from_point(vec2(0.5,0.2))-vec3(0.2,0.2,0.2);\n\t\tif(d < min_dist_sq){\n\t\t\tmin_color = color_from_point(points[i]);\n\t\t\tmin_dist_sq = d;\n\t\t}\n\t}\n\treturn min_color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tpoints[0] = vec2(0.4+sin(iTime)*0.1,0.3+cos(iTime*3.1)*0.05);\n\tpoints[1] = vec2(0.9+sin(iTime*1.1)*0.1,0.1+cos(iTime*3.3+.2)*0.05);\n\tpoints[2] = vec2(0.2+sin(iTime*0.2)*0.1,0.5+cos(iTime*2.1+.2)*0.05);\n\tpoints[3] = vec2(0.8+sin(iTime*0.4)*0.1,0.4+cos(iTime*2.7+.7)*0.05);\n\tpoints[4] = vec2(0.2+sin(iTime*2.4)*0.13,0.15+cos(iTime*1.5+.7)*0.09);\n\tpoints[5] = vec2(0.5+sin(iTime*0.6)*0.13,0.15+cos(iTime*0.7+.7)*0.09);\n\tfloat u = fragCoord.x / iResolution.x;\n\tfloat v = fragCoord.y / iResolution.x;\n\tvec2 uv = vec2(u,v);\n\n\tfragColor = vec4(minimumDistColor(uv),1.0);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtlGDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[16, 16, 39, 39, 74], [76, 76, 110, 110, 197], [199, 199, 233, 233, 690], [693, 693, 750, 750, 1318]], "test": "valid"}
{"id": "XtlGzf", "name": "Raytracing, 2 Spheres, 2 Lights", "author": "chuckeles", "description": "I added more spheres and more lights", "tags": ["raytracing", "spheres", "lights"], "likes": 1, "viewed": 128, "published": "Public", "date": "1423910531", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// --- GLOBALS ---\nconst float e = 2.71828182845904523536028747135266249;\n\n// sun\nvec3 sunDir = normalize(vec3(0.4, 1.0, 0.2));\n\n// red light\nvec3 redLight = vec3(1.2, 1.5, -0.4);\nvec3 redLightc = vec3(1.0, 0.2, 0.1);\nfloat redLightd = 8.0;\n\n// ambient color\nvec3 amb = vec3(0.0, 0.01, 0.02);\n\n// sphere 1\nvec4 sphere1 = vec4(1.0, 0.5, 0.2, 0.5);\nvec3 sphere1c = vec3(0.5, 0.72, 0.92);\n\n// sphere 2\nvec4 sphere2 = vec4(-0.7, 0.3, 1.2, 0.3);\nvec3 sphere2c = vec3(0.8, 0.65, 0.7);\n\n\n// --- GEOMETRY ---\n\n// test ray against a sphere\nfloat sphere(in vec3 ro, in vec3 rd, in vec4 s) {\n    float t = -1.0;\n    \n    ro -= s.xyz;\n    float r = s.w;\n    \n    // t^2 + 2 * <ro, rd> * t + |ro|^2 - r^2 = 0\n    \n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - r * r;\n    float h = b * b - c;\n    \n    if (h >= 0.0)\n        t = (-b - sqrt(h));\n    \n    return t;\n}\n\n// get sphere normal in position\nvec3 sphereNormal(in vec3 point, in vec4 s) {\n    return (point - s.xyz) / s.w;\n}\n\n// test ray against a plane\nfloat plane(in vec3 ro, in vec3 rd) {\n    float t = -1.0;\n    \n    // ro.y + t * rd.y = 0\n    \n    t = -ro.y / rd.y;\n    \n    vec3 p = ro + t * rd;\n    float l = length(p.xz);\n    if (l > 3.0)\n        t = -1.0;\n    \n    return t;\n}\n\n// shoot the ray into the world\nvec2 shoot(in vec3 ro, in vec3 rd) {\n    vec2 res;\n    float t = 1000.0;\n    \n    // test sphere 1\n    float s = sphere(ro, rd, sphere1);\n    if (s > 0.0) {\n        t = s;\n        res.y = 1.0;\n    }\n    \n    // test sphere 2\n    float s2 = sphere(ro, rd, sphere2);\n    if (s2 > 0.0 && s2 < t) {\n        t = s2;\n        res.y = 3.0;\n    }\n    \n    // test plane\n    float p = plane(ro, rd);\n    if (p > 0.0 && p < t) {\n        t = p;\n        res.y = 2.0;\n    }\n    \n    res.x = t;\n    return res;\n}\n\n// --- LIGHTING ---\n\n// diffuse lighting\nvec3 diffuseLight(vec3 normal, vec3 light) {\n    return max(dot(normal, light), 0.0) * vec3(1.0);\n}\n\n// specular highlights\nvec3 specularLight(vec3 normal, vec3 light, vec3 rd, float s) {\n    vec3 r = reflect(light, normal);\n    return pow(max(dot(r, rd), 0.0), s) * vec3(1.0);\n}\n\n// --- MAIN ---\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // screen uv\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    \n    // ray\n    float d = 2.0;\n    vec3 ro = vec3(cos(iTime * -0.2) * d, 1.0, sin(iTime * -0.2) * d);\n    vec3 ta = vec3(0.0, 0.4, 0.0);\n    \n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n    vec3 vv = normalize(cross(uu, ww));\n    \n    vec3 rd = normalize(uv.x * (iResolution.x / iResolution.y) * uu + uv.y * vv + 2.0 * ww);\n    \n    // shoot the ray\n    vec2 res = shoot(ro, rd);\n    \n    // background\n    vec3 color = amb;\n    \n    // objects\n    if (res.x > 0.0 && res.x < 1000.0) {\n        \n        vec3 point = ro + res.x * rd;\n        \n        if (res.y < 1.5) {\n            // sphere\n            color = sphere1c;\n            \n            vec3 normal = sphereNormal(point, sphere1);\n            vec3 rld = redLight - point;\n            float d = length(redLight - point);\n            rld = normalize(rld);\n            \n            // light\n            vec3 diff = diffuseLight(normal, sunDir) + diffuseLight(normal, rld) * redLightc * (1.0 - smoothstep(0.0, redLightd, d));\n            \n            color = color * diff + amb;\n        }\n        \n        else if (res.y < 2.5) {\n            // plane\n            color = vec3(0.35, 0.33, 0.2);\n            \n            vec3 normal = vec3(0.0, 1.0, 0.0);\n            vec3 rld = redLight - point;\n            float d = length(redLight - point);\n            rld = normalize(rld);\n            d = 1.0 - smoothstep(0.0, redLightd, d);\n            \n            // light\n            vec3 diff = diffuseLight(normal, sunDir) + diffuseLight(normal, rld) * redLightc * d;\n            \n            // shadow\n            vec3 sh = vec3(0.0);\n            float sd = 0.0;\n            for(float sx = -0.1; sx <= 0.1; sx += 0.05)\n                for(float sz = -0.1; sz <= 0.1; sz += 0.05) {\n                    vec2 sr = shoot(point + vec3(0.0, 0.01, 0.0), sunDir + vec3(sx, 0.0, sz));\n                    if (sr.x > 0.0 && sr.x < 1000.0)\n                        sh += 1.0;\n                    sd += 1.0;\n                    \n                    vec2 sr2 = shoot(point + vec3(0.0, 0.01, 0.0), rld + vec3(sx, 0.0, sz));\n                    if (sr2.x > 0.0 && sr2.x < 1000.0)\n                        sh += redLightc * d;\n                    sd += 1.0;\n                }\n            sh /= sd;\n            \n            color *= 1.0 - sh * 0.8;\n            \n            color = color * diff + amb;\n        }\n        \n        else if (res.y < 3.5) {\n            // sphere 2\n            color = sphere2c;\n            \n            vec3 normal = sphereNormal(point, sphere2);\n            vec3 rld = redLight - point;\n            float d = length(redLight - point);\n            rld = normalize(rld);\n            \n            // light\n            vec3 diff = diffuseLight(normal, sunDir) + diffuseLight(normal, rld) * redLightc * (1.0 - smoothstep(0.0, redLightd, d));\n            vec3 spe = specularLight(normal, sunDir, rd, 10.0) + specularLight(normal, rld, rd, 10.0) * redLightc;\n            \n            color = color * diff + amb + spe;\n        }\n        \n        // fog\n        float f = pow(e, -pow(res.x*0.3, 2.0));\n        color = mix(amb, color, f);\n            \n    }\n        \n    // gamma\n    color = sqrt(color);\n    \n    // output\n    fragColor = vec4(color, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtlGzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[502, 531, 580, 580, 859], [861, 894, 939, 939, 975], [977, 1005, 1042, 1042, 1236], [1238, 1270, 1306, 1306, 1767], [1790, 1810, 1854, 1854, 1909], [1911, 1934, 1997, 1997, 2089], [2108, 2108, 2165, 2187, 5508]], "test": "valid"}
{"id": "Xts3R2", "name": "Joukowski", "author": "yakoudbz", "description": "CLICK ABOVE THE AIRFOIL TO CHANGE WIDTH AND CURVATURE\n\nAll parameters can be safely modified.", "tags": ["mechanics", "fluid", "joukowski"], "likes": 13, "viewed": 322, "published": "Public", "date": "1423400335", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* \n\nIRROTATIONAL INCOMPRESSIBLE FLOW AROUND A JOUKOWSKI PROFILE\n===========================================================\n\nThe irrotational and incompressible flow around a Joukowski profile is largley documented\nHowever, few people implement the inverse Joukowski transformation.\n\ncreated by CÃ©lestin Marot\nLicense Creative Commons Attribution-ShareAlike 4.0 International\n*/\n\n#define time iTime\n#define mouse iMouse\n#define resolution iResolution.xy\n#define pi 3.14159265359\n\n\n/* PARAMETERS\n ******************/\n\nvec2 pos = vec2(0.0,0.0);\n\n// the lines\nfloat interval = 0.1;   // interval between isolines (the window height is 2)\nfloat linewidth = 0.33;  // the unit is the interval\n#define ISOX 0.03   // draw isox, the number is the thickness of the line (comment=disable)\n#define ISOY 1.0    // draw isoy, the number is the thickness of the line (comment=disable)\n\n// some color parameters (comment to disable)\n#define COLOR       // color corresponding to argument\n#define SHADE       // shade corresponding to modulus\n\n\n\n/* Useful complex functions \n ***************************/\nvec2 cartToPol(vec2 z){\n\treturn vec2(length(z),atan(z.y,z.x));\n}\n\nvec2 polToCart(vec2 p){\n\treturn vec2(p.r*cos(p.g),p.r*sin(p.g));\n}\n\nvec2 fracz(vec2 z1, vec2 z2){\n    return vec2(dot(z1,z2),z1.y*z2.x-z1.x*z2.y)/dot(z2,z2);\n}\n\nvec2 mulz(vec2 z1, vec2 z2)\n{\n    return vec2(z1.x*z2.x-z1.y*z2.y,z1.x*z2.y+z1.y*z2.x);\n}\n\nvec2 powz(vec2 z , float power){\n    vec2 p = cartToPol(z);\n    return polToCart(vec2(pow(p.r,power),power*p.g));\n}\n\nvec2 logz(vec2 z, float angle){\n    vec2 p = cartToPol(z);\n    return vec2(log(p.r),mod(p.g+angle,2.0*pi)-angle);\n}\n\nvec2 expz(vec2 z){\n    return polToCart(vec2(exp(z.x),z.y));\n}\n\nvec2 I(float n){\n    return vec2(0.0,n);\n}\n\nvec2 R(float n){\n    return vec2(n,0.0);\n}\n\n\n/* put color given z\n ****************************/\nvec3 colorize(vec2 z,float r){\n    vec2 p = cartToPol(z);\n\n    #ifdef COLOR\n    float A = p.g/pi; // angle from -1 to 1\n    float AA = abs(A + 1.0/3.0) - 1.0;\n    float AAA = 1.0 - abs(A - 1.0/3.0);\n    vec3 color = vec3(1.0 - abs(A), 1.0 - abs(AA),1.0 - abs(AAA));\n    #else\n    vec3 color=vec3(.5);\n    #endif\n\n    #ifdef SHADE\n    color *= exp(-0.5*p.r)*1.5;\n    #endif\n\t\n    #ifdef ISOX\n    color+=smoothstep(linewidth,0.,abs(mod(z.x,interval)*2./interval-1.))*ISOX;\n    #endif\n    #ifdef ISOY\n    color+=smoothstep(linewidth,0.,abs(mod(z.y+interval*.5,interval)*2./interval-1.))*ISOY;\n    #endif\n\n    color*=smoothstep(0.99,1.05,r);\n\n    return color;\n}\n\n\n/*   MAIN\n *************************/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 Z = ( (2.0*fragCoord.xy-resolution) / resolution.y)-pos ;\n    \n    // parameters for the Joukowski transform\n\t#define JOUKO       // Joukowski transform (comment for flow around a sphere )\n    // the radius of the circle (from which the Joukowski profile originate)\n    float a = 4.0*interval; // radius (chord)\n    float e = clamp(2.0*mouse.y/resolution.y-1.0-pos.y,0.0,a); // thickness (0<e<a)\n\tfloat d = mouse.x/resolution.x*pi/2.0;               // camber (-pi/2<=d<=pi/2)\n\tfloat alpha = cos(0.2*time)*pi/6.0;                  // angle of attack\n\n//Circulation  ( K=-circulation/(4*pi*a*sin(alpha+beta)) )\nfloat K = 1.0; // = 1.0 for Kutta condition\n\t\n    // rotating the airfoil + the flow\n    Z=mulz(Z,expz(I(alpha)));\n    \n    #ifdef JOUKO\n    /******************************\n     *  Inverse Joukowki transform\n     ******************************/\n        float b = -e*cos(d)+sqrt(e*e*cos(d)*cos(d)-e*e+a*a);\n        vec2 Z0 = e*expz(I(-d));\n        float beta = -atan(Z0.y,Z0.x+b);\n\n        vec2 Z1 = powz(mulz(Z-Z0,Z-Z0)-R(4.*b*b),0.5);\n    \t\n    \t/*\n    \tvec2 z1 = 0.5*(Z0+Z+Z1);\n    \tvec2 z2 = 0.5*(Z0+Z-Z1);\n    \tif(length(z1)>=a)\n            Z=z1;\n    \telse\n            Z=z2;\n\t\t*/\n    \t\n    \t// same as commented above but faster and better\n        Z = Z+Z0;\n    \tZ = 0.5*(Z+sign(dot(Z,Z1))*Z1);\n\n    /*******************************/\n    #else\n        float beta=0.0;\n    #endif\n\t\n    // rotating the flow in the opposite dir\n    Z=mulz(Z,expz(I(-alpha)));\n    \n    // modulus compare to radius\n    float r = length(Z)/a;\n\n    // flow around a circle of radius a\n    vec2 z = Z+fracz(R(a*a),Z);\n    \n    // adding circulation\n    float T = -2.0*K*a*sin(alpha+beta);\n    z-=mulz(I(T),logz(Z/a,(alpha+beta)*step(z.y/T,log(r))));\n\n    fragColor = vec4(colorize(z,r), 1.0 );\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xts3R2.jpg", "access": "shaders20k", "license": "cc-by-sa-2.5", "functions": [[1035, 1094, 1117, 1117, 1158], [1160, 1160, 1183, 1183, 1226], [1228, 1228, 1257, 1257, 1319], [1321, 1321, 1350, 1350, 1410], [1412, 1412, 1444, 1444, 1527], [1529, 1529, 1560, 1560, 1644], [1646, 1646, 1664, 1664, 1708], [1710, 1710, 1726, 1726, 1752], [1754, 1754, 1770, 1770, 1796], [1799, 1851, 1881, 1881, 2509], [2551, 2551, 2608, 2608, 4405]], "test": "valid"}
{"id": "Xts3WB", "name": "spiral cuts", "author": "nexor", "description": "dizzy :)", "tags": ["spiral", "rotation"], "likes": 5, "viewed": 129, "published": "Public", "date": "1424878594", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 tr(vec2 p, vec2 res)\n{\n    p = -1.0+2.0*p/res.xy;\n    p.x *= res.x/res.y;\n    return p;\n\t   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = vec2(cos(iTime),sin(iTime)) * iResolution.xy/4.0 + iResolution.xy/2.0;\n\tvec2 p = tr(fragCoord.xy - mouse + iResolution.xy/2.0,iResolution.xy);\n    float angle = degrees(atan(p.y,p.x));\n    \n    float len = length(p)*6.0;\n    \n    float val = mod(angle + log(len)*60.0 + (step(mod(len,1.0),0.75)*2.0-1.0)*30.0*iTime,30.0);\n\n    \n    vec3 col = vec3(0.0);\n    \n    col = mix(vec3(1.0,0.5,0.0),vec3(0.0),step(mod(val,25.0),12.5));\n    col = mix(col,1.0-col,smoothstep(0.6,0.65,1.0/len));\n    \n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xts3WB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 99], [101, 101, 158, 158, 700]], "test": "valid"}
{"id": "Xts3WS", "name": "TwistyGrid", "author": "Elkar", "description": "simple twisting grid", "tags": ["raymarch"], "likes": 5, "viewed": 161, "published": "Public", "date": "1424815495", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define DO_ROT 1\n\n#define M_PI 3.1415926535897932384626433832795\n\nconst int MAX_ITERS = 100;\nconst int BIN_ITERS =  5;\nconst float EPS = 0.001;\nconst float FOV_Y = 45.0 / 180.0 * M_PI;\nconst float FOG_DIST = 100.0;\n\nfloat smin( float a, float b, float k)\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat dist(vec3 pt)\n{      \n    float f = (1.0/15.0) * sin(iTime / (M_PI * 2.0));\n    \n    float rotAngle = pt.z * f;\n    float ca = cos(rotAngle);\n    float sa = sin(rotAngle);\n      \n    pt.xy = mat2(ca,sa,-sa,ca)*pt.xy;\n \n    pt += vec3(2.0, 2.0, 2.0);\n    pt = mod(pt + vec3(2.0,2.0,2.0), vec3(4.0,4.0,4.0)) - vec3(2.0,2.0,2.0);\n    \n    float d = length(pt) - 1.0;\n    \n    d = smin(d, length(pt.xy) - 0.2, 0.15);\n    d = smin(d, length(pt.yz) - 0.2, 0.15);\n    d = smin(d, length(pt.xz) - 0.2, 0.15);\n    \n    return d;\n}\n\nvec3 getGrad(vec3 pt)\n{\n    float d = dist(pt);\n   \tfloat dx = dist(pt + vec3(EPS, 0.0, 0.0));\n    float dy = dist(pt + vec3(0.0, EPS, 0.0));\n    float dz = dist(pt + vec3(0.0, 0.0, EPS));\n    \n    return vec3(dx,dy,dz) - d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv*2.0 - 1.0;\n    \n    float aspectX = iResolution.x / iResolution.y;\n    float fovCoef = tan(FOV_Y / 2.0);\n    \n    vec3 camPos = vec3(0.0,0.0,0.0);\n    \n   \tvec3 dir = normalize(vec3(uv.x * aspectX * fovCoef, uv.y * fovCoef, -1.0));\n  \n#if DO_ROT\n    float angle = iTime/10.0;\n    float pitch = sin(iTime/M_PI) / 6.0;\n    \n    float cp = cos(pitch);\n    float sp = sin(pitch);\n    \n    dir.yz = mat2(cp,sp,-sp,cp) * dir.yz;\n    \n    float ca = cos(angle);\n    float sa = sin(angle);\n   \n    dir.xz = mat2(ca,-sa,sa,ca) * dir.xz; \n#endif\n    \n    dir = normalize(dir);\n    \n    vec3 p = camPos + dir * 0.1;\n   \tvec3 prevPt = vec3(0,0,0);\n    \n    vec3 epsDelta = dir*EPS;   \n    float val = 1.0;\n    bool hit = false;\n    \n    float d = 0.0;\n    float prevd = 0.0;\n    \n    for(int i = 0; i < MAX_ITERS; ++i)\n    {\n        d = dist(p);\n       \t\n        if(d < 0.0){\n            val = float(i) / float(MAX_ITERS-1);\n            hit = true;\n     \t\tbreak;       \n        }\n       \n        if(dot(p,p) > 1000.0*1000.0){\n            break;\n        }\n        \n        prevPt = p;\n        prevd = d;\n        p += d * dir + epsDelta;\n    }  \n    \n    // bin-search\n    if(hit)\n    {\n    \tfor(int j = 0; j < BIN_ITERS; ++j)\n    \t{\n\t    \tvec3 mid = (p + prevPt) / 2.0;               \n            if(dist(mid) < 0.0)\n            { p = mid; }\n            else {prevPt = mid;}\n\t    }\n    }       \n        \n   \tvec3 n = normalize(getGrad(p));\n    \n    float halo = 1.0 - max(dot(-dir, n), 0.0);\n    float camDist = length(camPos - p);\n    \n    vec3 objColor1 = vec3(val);\n    vec3 objColor2 = vec3(camDist/100.0) + pow(halo, 5.0)+ pow(val, 2.0);\n    //vec3 objColor2 = (n + vec3(1.0)) / 2.0; \n    \n    objColor2 = clamp(objColor2, vec3(0.0), vec3(1.0));\n    //vec3 objColor = step(0.0, uv.x) * objColor1 + (1.0 - step(0.0, uv.x)) * objColor2;\n    \n    //vec3 objColor = hit ? objColor2 : vec3(0.0);\n    vec3 objColor = objColor2;\n    //vec3 objColor = vec3(1.0);\n    \n    float fogCoef = max(0.0, 1.0 - exp(-(camDist-5.0) / FOG_DIST)); \n    vec3 fogColor = vec3(0.0,abs(dir.z),abs(dir.x));\n     \n    vec3 color = mix(objColor, fogColor, fogCoef);\n    \n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xts3WS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[216, 216, 256, 256, 349], [351, 351, 372, 372, 878], [880, 880, 903, 903, 1106], [1108, 1108, 1165, 1165, 3387]], "test": "valid"}
{"id": "Xts3zX", "name": "Obfuskali", "author": "bergi", "description": "kali fan shader", "tags": ["3d", "raymarching", "fractal", "kaliset", "obfuscation"], "likes": 8, "viewed": 806, "published": "Public API", "date": "1423872312", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* KALI fan shader \n\n   2015, stefan berke\n   License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n*/\n\n\n#define Iterations \t\t5\n#define Surface \t\t0.05\n#define Time \t\t\t(iTime)\n\n#define TraceSteps\t\t20\n#define Fudge\t\t\t0.7\n#define MultiSample\t\t1\t\t\t// not quadratic, actual number of samples\n\n#define kTime (Time/4.)\n#define KaliParam vec3(0.501+.5*sin(kTime/11.1), .9, .3) + 0.1*vec3(sin(kTime), sin(kTime*1.1), sin(kTime*1.2));\n\nfloat kscale;\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    p.x = mod(p.x, 18./kscale);\n    p.y = mod(p.y, 13./kscale);\n    float koffs = .005;\n    a /= kscale;\n    b /= kscale;\n    r /= kscale;\n\t// by IQ\n    vec3 pa = p - a - koffs, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n// the shape trap\nfloat inDE(in vec3 p)\n{\n    float d = sdCapsule(p, vec3(0,0,0), vec3(0,4,0), Surface);\n    d = min(d, sdCapsule(p, vec3(0,2,0), vec3(2,4,0), Surface));\n    d = min(d, sdCapsule(p, vec3(0,2,0), vec3(2,0,0), Surface));\n    \n    d = min(d, sdCapsule(p, vec3(3,0,0), vec3(4.5,4,0), Surface));\n    d = min(d, sdCapsule(p, vec3(6,0,0), vec3(4.5,4,0), Surface));\n    d = min(d, sdCapsule(p, vec3(4,2,0), vec3(5,2,0), Surface));\n    \n    d = min(d, sdCapsule(p, vec3(7,0,0), vec3(7,4,0), Surface));\n    d = min(d, sdCapsule(p, vec3(7,0,0), vec3(9,0,0), Surface));\n    \n    d = min(d, sdCapsule(p, vec3(10,0,0), vec3(10,4,0), Surface));\n    \n    return d;\n}\n\n// the arch structure\n// \"kali-set\" by Kali\nfloat DE(vec3 z)\n{\n\tfloat d = 100.;\n\tvec4 p = vec4(z, 1.);\n\tfloat s = Surface;\n    kscale = 1.;\n\tfor (int i=0; i<Iterations; ++i)\n\t{\n\t\tp = abs(p) / dot(p.xyz, p.xyz);\n        if (i!=0)\n\t\t\td = min(d, inDE(p.xyz/p.w) - s); \n        s = s * .4;\n        kscale = pow(kscale,1.03) * 3.5;\n\t\tp.xyz -= KaliParam;\n\t}\n\treturn d;\n}\n\n// nimitz https://www.shadertoy.com/view/lslXRS\nfloat hash(in vec2 x) { return fract(sin(dot(x, vec2(12.9898, 4.1414))) * 43758.5453); }\n\nfloat seed=0.;\nfloat rnd(in vec2 x) { float r = hash(x + seed); seed += 1.; return r; }\n\nmat2 rotate(float r) { float s = sin(r), c = cos(r); return mat2(c, -s, s, c); }\n\nvec3 render(in vec3 ro, in vec3 dir)\n{    \n\tvec3 col = vec3(0.);\n\n    // march\n    float d, t = DE(ro) * Fudge * rnd(dir.xy);\n    for (int i=0; i<TraceSteps; ++i)\n    {\n        vec3 p = ro + t * dir;\n        \n        float d = DE(p);\n        \n        col += 1./max(1., 1.+10.*d);\n       \n        t += d * Fudge;\n    }\n  \n\treturn col / (1. + 100.*t*t*t) / float(TraceSteps);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ti = Time/14.;\n    \n    vec3 ro = vec3(0.2*sin(ti*4.),0.,-1.5+sin(ti*1.21));\n    mat2 r = rotate(-ti);\n    ro.yz = r * ro.yz;\n    ro.x += 0.;\n\n    vec3 col = vec3(0.);\n    for (int i=0; i<MultiSample; ++i)\n    {\n\t\tvec2 uv = ((fragCoord.xy + rnd(fragCoord.xy)) * 2. - iResolution.xy) / iResolution.y;\n    \n        vec3 dir = normalize(vec3(uv, 1. - .4*dot(uv,uv)));\n        dir.yz = r * dir.yz;\n        dir.yz = rotate(.5+sin(ti*2.23)) * dir.yz;\n        dir.xy = rotate(2.*sin(ti*2.)) * dir.xy;\n        \n        col += render(ro, dir);\n    }\n    col /= float(MultiSample);\n    \n    fragColor = vec4(clamp(pow(col,vec3(.5)),0.,1.),1.0);\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xts3zX.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[470, 470, 522, 522, 806], [808, 826, 849, 849, 1474], [1476, 1520, 1538, 1538, 1840], [1842, 1890, 1913, 1913, 1978], [1995, 1995, 2017, 2017, 2067], [2069, 2069, 2091, 2091, 2149], [2151, 2151, 2189, 2189, 2526], [2528, 2528, 2585, 2585, 3232]], "test": "valid"}
{"id": "XtsGR2", "name": "simple terrian", "author": "EvilRyu", "description": "Try some simplest terrian.", "tags": ["raymarching", "fbm", "terrian"], "likes": 21, "viewed": 1762, "published": "Public API", "date": "1424079000", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by EvilRyu 2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat hash(vec2 p)\n{\n    p=fract(p*vec2(5.3983,5.4472));\n   \tp+=dot(p.yx,p.xy+vec2(21.5351,14.3137));\n    return fract(p.x*p.y*95.4337);\n}\n\nfloat noise(vec2 p)\n{\n    vec2 f;\n    f=fract(p);\n    p=floor(p);\n    f=f*f*(3.0-2.0*f);\n    return mix(mix(hash(p),hash(p+vec2(1.0,0.0)),f.x),\n               mix(hash(p+vec2(0.0,1.0)),hash(p+vec2(1.0,1.0)),f.x),f.y);\n}\n\nfloat fbm(vec2 p)\n{\n    p*=0.09;\n    float f=0.;\n    float freq=4.0;\n    float amp=0.8;\n    for(int i=0;i<10;++i)\n    {\n        f+=noise(p*freq)*amp;\n        amp*=0.5;\n        freq*=1.79;\n    }\n\n    return f;\n}\n\nfloat f(vec3 p)\n{\n    float h=fbm(p.xz);\n    h+=smoothstep(-.5,1.5,h);\n    h=p.y-h;\n    return h;\n}\n\nvec3 getnormal(vec3 p,float t)\n{\n    vec3 eps=vec3(0.001*t,0.0,0.0);\n    vec3 n=vec3(f(p-eps.xyy)-f(p+eps.xyy),\n                2.0*eps.x,\n                f(p-eps.yyx)-f(p+eps.yyx));\n  \n    return normalize(n);\n}\n\nfloat tmax = 20.0;\n\nfloat intersect(vec3 ro,vec3 rd )\n{\n    float h=1.0;\n    float t=0.01;\n    for(int i=0;i<150;++i)\n    {\n        h=f(ro+t*rd);\n        if(h<0.001*t||t>tmax)\n  \t\t\tbreak;\n        t+=h*0.5;\n    }\n    return t;\n}\n// from iq's Terrian Tubes https://www.shadertoy.com/view/4sjXzG\nvec3 dome(vec3 rd, vec3 sun_dir)\n{\n    float sun=dot(rd,sun_dir);\n    float sda=clamp(0.5+0.5*sun,0.0,1.0);\n    float cho=max(rd.y,0.0);\n    vec3 bgcol=mix(mix(vec3(0.00,0.40,0.80)*0.7, \n                       vec3(0.70,0.70,0.40),\n                       pow(1.0-cho,1.0 + 3.0-3.0*sda)), \n                   vec3(0.53+0.2*sda,0.45-0.1*sda,0.4-0.25*sda),\n                   pow(0.95-cho,10.0+8.0-8.0*sda));\n    bgcol*=0.8+0.2*sda;\n    return bgcol*0.4;\n}\n\nvec3 l1dir;\nvec3 lighting(vec3 n,vec3 p,vec3 rd)\n{\n    l1dir.z*=-1.0;\n    float dif=max(0.0,dot(l1dir,n));\n    float bac=max(0.0,dot(normalize(vec3(-l1dir.x,0.0,l1dir.z)),n));\n    float sky=max(0.0,dot(vec3(0.0,1.0,0.0),n));\n    float sha=smoothstep(0.0,0.1,p.y-1.13);\n    float spe=pow(max(0.0,dot(reflect(rd,n),l1dir)),2.0);\n   \tfloat amb=0.5*smoothstep(0.0,2.0,p.y);\n    vec3 col=2.3*dif*vec3(1.32,1.12,0.45)*sha;\n    col+=0.8*bac*vec3(1.32,1.10,0.4);\n    col+=0.3*sky*vec3(0.0,0.6,1.0);\n    col+=vec3(0.5)*spe;\n    col+=0.3*amb*vec3(1.0);\n    if(p.y-1.1<0.18)col*=vec3(0.4,0.6,0.7);\n    return col;\n}\n    \nvec3 camerapath(float t)\n{\n    vec3 p=vec3(-13.0+3.5*cos(t),3.3,-1.1+2.4*cos(2.4*t+2.0));\n\treturn p;\n} \n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{ \n    vec2 q=fragCoord.xy/iResolution.xy; \n \tvec2 uv = -1.0 + 2.0*q; \n \tuv.x*=iResolution.x/iResolution.y; \n\n \tvec3 ta=camerapath(iTime*0.2+0.3);\n    ta.y-=0.2;\n\tvec3 ro=camerapath(iTime*0.2);\n\n \tvec3 cf = normalize(ta-ro); \n    vec3 cs = normalize(cross(cf,vec3(0.0,1.0,0.0))); \n    vec3 cu = normalize(cross(cs,cf)); \n \tvec3 rd = normalize(uv.x*cs + uv.y*cu + 1.5*cf);  // transform from view to world\n\n    l1dir=normalize(vec3(0., 0.15, -1.1));\n   \n    vec3 sun_dir=l1dir;\n    float sun=clamp(dot(sun_dir,rd),0.0,1.0);\n    \n    vec3 col=dome(rd,l1dir);\n   \n    float t=intersect(ro,rd);\n\tif(t>tmax) // sky\n    { \n        col += 0.8*vec3(1.0,0.8,0.7)*pow(sun,512.0);//sun\n\t\tcol += 0.1*vec3(1.0,0.4,0.2)*pow(sun,4.0);\n\t\tvec2 cuv=ro.xz+rd.xz*(10.0-ro.y)/rd.y;//cloud\n        vec3 cloud=mix(vec3(1.0,0.7,0.1),vec3(1.0),1.0-sun);\n\t\tcol=mix(col, cloud, 0.5*pow(texture(iChannel0,0.001*cuv).x,1.6));\n    }\n    else\n    {\n        vec3 p=ro+t*rd;\n        vec3 n=getnormal(p,t);\n        col=0.2*vec3(1.0,1.0,1.0)*lighting(n,p,rd);\n        col=mix(col, 0.25*vec3(0.4,0.75,1.0), 1.0-exp(-0.006*t*t) );\n    }\n   \tcol+=vec3(1.0,0.6,0.2)*0.2*pow(sun,2.0);\n\n\n    // post\n    col=pow(clamp(col,0.0,1.0),vec3(0.45)); \n  \n    col = col*1.3*vec3(1.0,1.0,1.02) + vec3(0.0,0.0,0.11);\n    col = clamp(col,0.0,1.0);\n    col = col*col*(3.0-2.0*col);\n    col = mix( col, vec3(dot(col,vec3(0.333))), 0.25 );\n    col*=0.5+0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n \tfragColor = vec4(col.xyz, 1.0); \n }", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtsGR2.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[115, 115, 135, 135, 253], [255, 255, 276, 276, 474], [476, 476, 495, 495, 686], [688, 688, 705, 705, 787], [789, 789, 821, 821, 1001], [1023, 1023, 1058, 1058, 1230], [1231, 1296, 1330, 1330, 1749], [1763, 1763, 1801, 1801, 2355], [2361, 2361, 2387, 2387, 2463], [2470, 2470, 2528, 2528, 4023]], "test": "error"}
{"id": "XtsGRf", "name": "Volumetric Cube", "author": "Flyguy", "description": "Testing a mix of ray marching and volume ray casting.", "tags": ["raymarching", "volume", "cube"], "likes": 9, "viewed": 1598, "published": "Public API", "date": "1423876664", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define RotateX(v,a) v.yz *= mat2(cos(a),sin(a),-sin(a),cos(a))\n#define RotateY(v,a) v.xz *= mat2(cos(a),sin(a),-sin(a),cos(a))\n#define RotateZ(v,a) v.xy *= mat2(cos(a),sin(a),-sin(a),cos(a))\n\n#define MIN_MARCH_DIST 0.001\n#define MAX_MARCH_STEPS 48\n#define MAX_VOLUME_STEPS 290\n#define VOLUME_STEP_SIZE 0.01\n\nvec4 Volume(vec3 pos)\n{\n    RotateY(pos,iTime);\n    RotateZ(pos,-0.5);\n    \n    float vol = dot(normalize(pos),vec3(1,0,0));\n    \n    vec3 col = mix(vec3(1.0,0.2,0.2),vec3(0.2,0.2,1.0),step(0.0,vol));\n    \n    vol = smoothstep(0.6,0.9,abs(vol));\n    \n\treturn vec4(col, max(0.0,vol)*0.01);  \n}\n\nvec3 MarchVolume(vec3 orig, vec3 dir)\n{\n    //Ray march to find the cube surface.\n    float t = 0.0;\n    vec3 pos = orig;\n    for(int i = 0;i < MAX_MARCH_STEPS;i++)\n    {\n        pos = orig + dir * t;\n        float dist = 100.0;\n        \n        dist = min(dist, 8.0-length(pos));\n        dist = min(dist, max(max(abs(pos.x),abs(pos.y)),abs(pos.z))-1.0);//length(pos)-1.0);\n        \n        t += dist;\n        \n        if(dist < MIN_MARCH_DIST){break;}\n    }\n    \n    //Step though the volume and add up the opacity.\n    vec4 col = vec4(0.0);\n    for(int i = 0;i < MAX_VOLUME_STEPS;i++)\n    {\n    \tt += VOLUME_STEP_SIZE;\n        \n    \tpos = orig + dir * t;\n        \n        //Stop if the sample becomes completely opaque or leaves the volume.\n        if(max(max(abs(pos.x),abs(pos.y)),abs(pos.z))-1.0 > 0.0) {break;}\n        \n        vec4 vol = Volume(pos);\n        vol.rgb *= vol.w;\n        \n        col += vol;\n    }\n    \n    return col.rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy / iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    \n    vec3 dir = normalize(vec3(uv-res/2.0,1.0));\n    vec3 orig = vec3(0,0,-3.5);\n\n        \n    RotateX(dir,radians(iMouse.y));\n    RotateX(orig,radians(iMouse.y));\n    RotateY(dir,radians(-iMouse.x));\n    RotateY(orig,radians(-iMouse.x));\n\n    \n    vec3 color = MarchVolume(orig,dir);\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtsGRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[309, 309, 332, 332, 601], [603, 603, 642, 684, 1548], [1550, 1550, 1607, 1607, 2022]], "test": "valid"}
{"id": "XtsGRX", "name": "machine city", "author": "raziel", "description": "Messing around with mandelbox fractals.  Thanks to iq for all the sdf resources. ", "tags": ["fractal", "ray", "marching", "mandelbox", "ggx"], "likes": 10, "viewed": 577, "published": "Public", "date": "1423839200", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// --- thanks to iq for all the ray-marching sdf info and awesomeness\n\nvec3 op_u(vec3 d1, vec3 d2)\n{\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\nvoid sphere_fold(inout vec3 p, inout float dr, float m_rad_sq, float f_rad_sq, float m_rad_sq_inv)\n{\n    float r_sq = dot(p, p);\n    if (r_sq < m_rad_sq)\n    {\n        float t = f_rad_sq * m_rad_sq_inv;\n        p *= t;\n        dr *= t;\n    }\n    else if (r_sq < f_rad_sq)\n    {\n        float t = f_rad_sq / r_sq;\n        p *= t;\n        dr *= t;\n    }\n}\n\nvoid box_fold(inout vec3 p, float fold_limit)\n{\n    p = clamp(p, -fold_limit, fold_limit) * 2.0 - p;\n}\n\n// estimators return (dist, mat_id, custom_value)\n\nvec3 estimator_mandelbox(vec3 p, float scale, float m_rad_sq, float f_rad_sq, float fold_limit, float mat_id)\n{\n    vec3 off = p;\n    float dr = 1.0;\n    float dist = 1e20;\n    float mrs_inv = 1.0 / m_rad_sq;\n    for (int i = 0; i < 10; ++i)\n    {\n        box_fold(p, fold_limit);\n        sphere_fold(p, dr, m_rad_sq, f_rad_sq, mrs_inv);\n\n        p = scale * p + off;\n        dr = dr * abs(scale) + 1.0;\n        vec3 ot = p - vec3(0.5);\n        dist = min(dist, dot(ot, ot));\n    }\n    return vec3(length(p) / abs(dr), mat_id, sqrt(dist));\n}\n\nvec3 mod_pos(vec3 p, float a, float b)\n{\n    p.zx = mod(p.zx, a) - b;  \n    return p;\n}\n\nvec3 estimate(vec3 p)\n{\n    vec3 p_mb = mod_pos(p, 4.4, 2.2);\n   \tvec3 res_mb = estimator_mandelbox(p_mb, -2.5, 0.1, 2.5, 1.0, 0.2);\n    // second\n    vec3 p_pl = p;\n    p_pl.y += 4.0;\n    p_pl = mod_pos(p_pl, 2.0, 1.0);\n    vec3 res_pl = estimator_mandelbox(p_pl, -1.5, 0.3, 2.9, 1.0, 0.1);\n\n    return op_u(res_mb, res_pl);\n\n}\n\nvec4 ray_march(vec3 origin, vec3 direction)\n{\n    float total_distance = 0.0;\n    int steps_total = 0;\n    float orbit_trap;\n    float material = -1.0;\n    float dist;\n    for (int steps = 0; steps < 100; ++steps)\n    {\n        vec3 point = origin + total_distance * direction;\n        vec3 res = estimate(point);\n        dist = res.x;\n        \n        if (dist < 0.003)\n            break;\n        \n        total_distance += dist;\n        steps_total++;\n        \n        orbit_trap = res.z;\n        material = res.y;\n    }\n    float ao = float(steps_total) / 200.0;\n    return vec4(total_distance, material, ao, orbit_trap);\n}\n\nvec3 compute_normal(vec3 pos)\n{\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n    vec3 pos00 = (pos + eps.xyy);\n    vec3 pos01 = (pos - eps.xyy);\n    vec3 pos10 = (pos + eps.yxy);\n    vec3 pos11 = (pos - eps.yxy);\n    vec3 pos20 = (pos + eps.yyx);\n    vec3 pos21 = (pos - eps.yyx);\n\tvec3 normal = vec3(estimate(pos00).x - estimate(pos01).x, \n                       estimate(pos10).x - estimate(pos11).x, \n                       estimate(pos20).x - estimate(pos21).x);\n\treturn normalize(normal);\n}\n\nvec3 render(vec3 origin, vec3 direction, vec2 uv)\n{\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    vec4 res = ray_march(origin, direction);\n    \n    vec3 light_dir = normalize(vec3(-0.6, -0.7, 0.5));\n    float lg = length(uv - vec2(0.0));\n    vec3 bg = exp(-vec3(5.0 - lg * 0.8, lg, lg * 0.5) * 2.0);\n    color = bg;\n    \n    if (res.y > 0.0)\n    {\n        vec3 new_pos = origin + res.x * direction;\n        float ao = 1.0 - res.z;   \n        if (res.y == 0.2)\n        {  \n            vec3 normal = compute_normal(new_pos);\n            \n            vec3 h = normalize(light_dir - direction);\n            float noh = clamp(dot(normal, h), 0.0, 1.0); \n            float voh = clamp(dot(-direction, h), 0.0, 1.0);\n            float nol = clamp(dot(normal, light_dir), 0.0, 1.0);\n            float nol_i = clamp(dot(normal, normalize(light_dir * vec3(-1.0, 0.0, -1.0))), 0.0, 1.0);\n\n            float roughness = 0.54;\n            float alphaSq = roughness * roughness * roughness * roughness;\n            float denom = noh * noh * (alphaSq - 1.0) + 1.0;\n            float D = alphaSq / (3.1416 * denom * denom);\n\n            vec3 f0 = vec3(0.664, 0.824, 0.850);\n            vec3 F = f0 + (1.0 - f0) * exp2((-5.55473 * voh - 6.98316) * voh);  \n\n            vec3 spec = D * F;\n            \n            vec3 diff = nol * vec3(0.01, 0.49, 0.70) *  pow(vec3(ao), vec3(1.5, 1.2, 1.0));\n            diff *= spec;\n            diff += nol_i * vec3(0.41, 0.12, 0.16);\n            diff *= vec3(cos(res.w * 0.71) * 0.5 + 0.5, sin(res.w * 0.01) * 0.01 + 0.5, 0.54);\n            color = diff * ao;\n        }\n        else\n        {\n            vec3 diff = vec3(cos(res.w * 0.71) * 0.7 + 0.3, sin(res.w * 0.11) * 0.5 + 0.5, 0.54);\n            color = diff * ao * ao * ao * vec3(1.64, 1.27, 0.99) * pow(vec3(ao),vec3(1.0, 1.2, 1.5));\n        }\n        \n        float fog_factor = 0.1;\n        float fog = 1.0 - exp(-res.x * fog_factor);\n        color = mix(color, bg, fog);\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 offsets[5];\n    offsets[0] = vec2(0.0, 0.0);\n    offsets[1] = vec2(0.25, 0.0);\n    offsets[2] = vec2(-0.25, -0.0);\n    offsets[3] = vec2(0.0, 0.25);\n    offsets[4] = vec2(0.0, -0.25);\n    \n    vec2 mo = iMouse.xy / iResolution.xy;\n    \n    vec3 cam_pos = vec3(0.0  , sin(0.1  + 2.0 * mo.y), -iTime);\n    vec3 cam_up = normalize(vec3(0.0, 0.8, 0.2));\n    vec3 cam_right = vec3(1.0, 0.0, 0.0);\n    vec3 cam_forward = normalize(cross(cam_up, cam_right));\n    float focal_length = 2.77;\n    vec3 color = vec3(0.0);\n    \n    const int numSamples = 1;\n    for (int i = 0; i < numSamples; ++i)\n    {\n        vec2 coords_ss = (fragCoord.xy + offsets[i]) / iResolution.xy;\n    \tvec2 coords_cs = 2.0 * coords_ss - 1.0;\n   \t \tcoords_cs.x *= iResolution.x / iResolution.y;\n        \n        vec3 ray_d = normalize(cam_forward * focal_length + cam_right * coords_cs.x + cam_up * coords_cs.y);\n    \tvec3 ray_o = cam_pos;\n    \n        color += render(ray_o, ray_d, coords_cs);\n    }\n    \n    color /= float(numSamples);\n\tcolor = pow(color, vec3(0.4545));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtsGRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 71, 100, 100, 135], [137, 137, 237, 237, 490], [492, 492, 539, 539, 594], [647, 647, 758, 758, 1188], [1190, 1190, 1230, 1230, 1277], [1279, 1279, 1302, 1302, 1607], [1609, 1609, 1654, 1654, 2235], [2237, 2237, 2268, 2268, 2725], [2727, 2727, 2778, 2778, 4706], [4708, 4708, 4765, 4765, 5850]], "test": "valid"}
{"id": "XtX3WB", "name": "SHADE A DAY ( 2 / 22 / 2015 )", "author": "cabbibo", "description": "Playing more with colors / volumetric lighting", "tags": ["glsl", "volumetric", "rainbow"], "likes": 16, "viewed": 783, "published": "Public", "date": "1424638332", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n/*\n\t\n\tAll Code stolen from \n\thttps://www.shadertoy.com/view/Mdl3Rr\n\n\tand\n\t\n\thttp://www.iquilezles.org/www/index.htm\n\thttps://www.shadertoy.com/user/iq\n\n\tand\n\n\thttps://www.shadertoy.com/view/4ts3z2\n\n*/\n\n#define INF 1.0e38\n#define HIT(x) hit = min(hit, x)\n#define ROOFPOS vec3(0,-1,0.01)\n#define time iTime\n\nconst float PI = 3.14159;\n\n\nmat2 rot(float angle)\n{\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\treturn mat2(c,-s,s,c);\n}\nvec3 rot (vec3 v, vec3 axis, vec2 sincosangle)\n{\n\treturn v*sincosangle.y + cross(axis, v)*sincosangle.x + axis*(dot(axis, v))*(1.0 - sincosangle.y);\n}\n\n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y*1.)), tri(p.z+tri(p.x*1.)), tri(p.y+tri(p.x*1.)));}\n                                 \nmat2 m2 = mat2(0.970,  0.242, -0.242,  0.970);\n\n\n\n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat triNoise3d(in vec3 p, in float spd)\n{\n    float z=1.4;\n\tfloat rz = 0.;\n    vec3 bp = p;\n\tfor (float i=0.; i<=3.; i++ )\n\t{\n        vec3 dg = tri3(bp*2.);\n        p += (dg+time*.1*spd);\n\n        bp *= 1.8;\n\t\tz *= 1.5;\n\t\tp *= 1.2;\n        //p.xz*= m2;\n        \n        rz+= (tri(p.z+tri(p.x+tri(p.y))))/z;\n        bp += 0.14;\n\t}\n\treturn rz;\n}\n\n\n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat fogmap(in vec3 p , float d )\n{\n    //p.x += time*.0005;\n   // p.z += sin(p.x*.00005);\n    return triNoise3d(p*2.2/(d * 20.),0.2);\n}\n\n\nfloat hash (float n)\n{\n\treturn fract(sin(n)*43758.5453);\n}\n\nfloat noise (in vec3 x)\n{\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\n\tf = f*f*(3.0-2.0*f);\n\n\tfloat n = p.x + p.y*57.0 + 113.0*p.z;\n\n\tfloat res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n\t\t\t\t\t\tmix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n\t\t\t\t\tmix(mix( hash(n+113.0), hash(n+114.0),f.x),\n\t\t\t\t\t\tmix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n\treturn res;\n}\n\n\nfloat box(vec3 org, vec3 dir, vec3 size, out float far)\n{\n\t// compute intersection of ray with all six bbox planes\n\tvec3 invR = 1.0 / dir;\n\tvec3 tbot = invR * (-0.5*size - org);\n\tvec3 ttop = invR * (0.5*size - org);\n\t\n\t// re-order intersections to find smallest and largest on each axis\n\tvec3 tmin = min (ttop, tbot);\n\tvec3 tmax = max (ttop, tbot);\n\t\n\t// find the largest tmin and the smallest tmax\n\tvec2 t0 = max (tmin.xx, tmin.yz);\n\tfloat near;\n\tnear = max (t0.x, t0.y);\n\tt0 = min (tmax.xx, tmax.yz);\n\tfar = min (t0.x, t0.y);\n\n\t// check for hit\n\treturn near < far && far > 0.0 ? near : INF;\n}\n\nfloat box(vec3 org, vec3 dir, vec3 size)\n{\n\tfloat far;\n\treturn box(org, dir, size, far);\n}\n\n\n\n// Makes brighter near top\nfloat transmittance (vec3 p)\n{\n    /*vec3 o;\n    o.x = sin( iTime ) * .1;\n    o.y = sin( iTime * .5) * 2.1;\n    o.z = sin( iTime * .05) * 20.1;\n\treturn noise( p * o);*/\n    \n    float a = 0.;\n    float mL = 100.;\n    float id = 0.;\n  \n    \n   \n    a = pow(a,2.) / 20. + 3. * pow(fogmap( p * 1.  + sin(iTime*.1 )* .1 + sin(iTime*.174 )* .2 , clamp( a , 0. , 1.1)*1.3+.5  ),3.);\n    \n    vec3 dif = p - vec3( 0. );\n    \n    float theta = acos( dif.z / length( dif ) );\n    float phi = atan( dif.y / dif.x );\n    \n    float r = max(0., 1.5 - length( dif ));\n   // a = pow( r , 2.)*/  * triNoise3d(p*2.2/(1. * 20.),0.2);\n    \n    a =  triNoise3d(vec3( sin( theta *r + 20.) , theta , phi ) , .2 ) * r * 3.;\n    return a;\n    \n}\n\n\nfloat transmittance (vec3 p , float offset){\n\n    vec3 dif = p - vec3( 0. );\n    \n    float theta = acos( dif.z / length( dif ) );\n    float phi = atan( dif.y / dif.x );\n    \n    float r = max(0., 1.5 - length( dif ));\n\n    float a =  triNoise3d(vec3( r + 2. * (offset +3.) , theta * .1 , phi *.1) , .2 ) * r * 3.;\n    return a;\n    \n}\n\nfloat intersect (vec3 ro, vec3 rd)\n{\n\tfloat hit = INF;\n\n\t//HIT(box (ro - vec3(0.,0.,0.), rd, vec3(.4,.4,.4)));\n    \n    HIT(box (ro - vec3(0.,-2.,0.), rd, vec3(10.,.1,10.)));\n    HIT(box (ro - vec3(4.,0.,0.), rd, vec3(.1,10.,10.)));\n    HIT(box (ro - vec3(-4.,0.,0.), rd, vec3(.1,10.,10.)));\n    HIT(box (ro - vec3(0.,0.,4.), rd, vec3(10.,10.,.1)));\n    HIT(box (ro - vec3(0.,0.,-4.), rd, vec3(10.,10.,.1)));\n    //HIT(box (ro - vec3(0.,-2.,0.), rd, vec3(10.,.1,10.)));\n\n  //  HIT(box (ro - vec3(0.,2.,0.), rd, vec3(10.,.1,10.)));\n\n\treturn hit;\n}\n\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal(mat3 camMat , vec2 p, vec3 ro  ){\n    \n    // create view ray\n    vec2 eps = vec2( 0.0001, 0.0 );\n    \n\tvec3 l = normalize( camMat * vec3(p.xy - eps.xy,2.0) ); \n    vec3 r = normalize( camMat * vec3(p.xy + eps.xy,2.0) ); \n    vec3 u = normalize( camMat * vec3(p.xy - eps.yx,2.0) ); \n    vec3 d = normalize( camMat * vec3(p.xy + eps.yx,2.0) ); \n    \n    // raycast the scene\n\tfloat hL = intersect(ro,l);\n\tvec3 pL = ro + hL * l;\n    if( hL == INF ){ return vec3( INF ); }\n        \n    \n     // raycast the scene\n\tfloat hR = intersect(ro,r);\n\tvec3 pR = ro + hR * r;\n    if( hR == INF ){ return vec3( INF ); }\n    \n    // raycast the scene\n\tfloat hU = intersect(ro,u);\n\tvec3 pU = ro + hU * u;\n    if( hU == INF ){ return vec3( INF ); }\n    \n    // raycast the scene\n\tfloat hD = intersect(ro,d);\n\tvec3 pD = ro + hD * d;\n    if( hD == INF ){ return vec3( INF ); }\n    \n    vec3 d1 = pL - pR;\n    vec3 d2 = pU - pD;\n        \n    vec3 nor =cross( d1 , d2 );\n\n\treturn normalize(nor);\n    \n}\n\n\nvec3 rainbowTransmit( vec3 p ){\n    \n    vec3 r = vec3( 1. , 0. , 0.);\n    vec3 g = vec3( 0. , 1. , 0.);\n    vec3 b = vec3( 0. , 0. , 1.);\n    \n    \n    float rT = transmittance( p , 0. );\n    float gT = transmittance( p , 1. );\n    float bT = transmittance( p , 2. );\n \n    vec3 col = vec3( rT , gT , bT );\n    \n    return col;\n    \n}\n\n#define STEPS 40\nvec3 inscatter ( vec3 origin, vec3 ro, vec3 rd, vec3 roLight , vec3 rdLight, vec3 lightDir, float hit, vec2 screenPos)\n{\n\tfloat far;\n    //float near = frustum(roLight + vec3(0.0, 1.0, 0.0), rdLight,.01, vec3(1.5, 3.0, 1.5), far);\n\tfloat near = box(roLight + origin, rdLight, vec3(3., 3., 3.), far);\n\tif(near == INF || hit < near)\n\t\treturn vec3(0);\n\t\n\tfloat distAlongView = min(hit, far) - near;\n\tfloat oneOverSteps = 1.0/float(STEPS);\n\tvec3 step = rd*distAlongView*oneOverSteps;\n\tvec3 pos = ro + rd*near;\n\tfloat light = 0.0;\n\t\n\t// add noise to the start position to hide banding\n\tpos += rd*noise(vec3(2.0*screenPos, 0.0))*0.05;\n\n    vec3 col = vec3( 0. );\n\tfor(int i = 0; i < STEPS; i++)\n\t{\n\t\tfloat l = intersect(pos, lightDir) == INF ? 1.0 : 0.0;\n\t\t//l *= transmittance(pos);\n\t\t//light += l;\n        \n        vec3 c = rainbowTransmit( pos );\n        //include light particles later ?\n\t\t//light += particles(pos)*l;\n\t\tpos += step;\n        \n       // vec3 c = vec3( 1. - length( pos - vec3( 0.) ) , abs( sin( 20. * length(pos-vec3(0.)))) , 1. );\n        col += c * l;\n\t}\n\n\tlight *= oneOverSteps * distAlongView;\n    col *= oneOverSteps * distAlongView;\n\treturn col * .4; //light * vec3( 1.);\n}\n\n\n\n\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 0.3 + 10.0*mouseX;\n\tcamPos = vec3(3.5*sin(an),0.0,3.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m.x );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n    \n    // raycast the scene\n\tfloat hit = intersect(ro,rd);\n\tvec3 hitPos = ro + hit * rd;\n\t\n    vec3 col = normalize( hitPos ) * .5 + .5; //vec3( 0. );\n    \n   \n\t// white window\n\tif (hit == INF)\n\t{\n\t\tcol = vec3( 1. , 0. , 0. );\n        \n\n    }else{\n        \n        vec3 n;\n        \n        n.x = noise( hitPos * 10. );\n        n.y = noise( hitPos * 20. );\n        n.z = noise( hitPos * 30. );\n        \n       // col = vec3( n );//.3 * (normalize( hitPos ) * .5 + .5);// vec3( .1 , 0.1 , 0.2 );\n    \tcol = vec3( 0. );\n    }\n     \n    \n    // white window\n\tif (hit == INF)\n\t{\n        \n        // DO BACKGROUND\n\t\tfragColor = vec4(1.0 , 0. , 0. , 1.);\n\t\treturn;\n\t}\n    \n    vec3 n = calcNormal( camMat , p , ro );\n    \n    if( n == vec3(INF) ){\n        fragColor = vec4(1.0);\n\t\treturn;\n    }\n    \n    col = vec3( 1. , 0. , 0. );//vec3(dot( vec3( 0. , 1. , 0. ) , n ));\n    \n\n    \n    // direct light (screw shading!)\n\tvec3 lightRotAxis = vec3(0.707,0,0.707); //1,0,1 normalized\n    \n    \n    float angle = 0.;//  + .01 * sin(iTime);\n\tvec2 lightAngleSinCos = vec2(sin(angle), cos(angle));\n\tvec3 lightDir = rot(vec3(0,1,0), lightRotAxis, lightAngleSinCos);\n\tfloat shadowBias = 1.0e-4;\n\t//vec3 col = vec3(0.0);\n    if (intersect(hitPos + lightDir*shadowBias, lightDir) == INF){\n        \n        col = n * .5 + .5;\n\n    }\n\t\n\t// inscatter\n\tlightAngleSinCos.x *= -1.0; // rev angle\n\tvec3 roLight = rot(ro , lightRotAxis, lightAngleSinCos);\n\tvec3 rdLight = rot(rd, lightRotAxis, lightAngleSinCos);\n    \n    // The 5 lights\n\tcol = inscatter(vec3( 0. , 0. , 0.),ro, rd, roLight, rdLight, lightDir, hit, fragCoord.xy);    \n\n    vec3 c = col;\n    // color correction - Sherlock color palette ;)\n\tc.r = smoothstep(0.0, 1.0, c.r * 1.5);\n\tc.g = smoothstep(0.0, 1.0, c.g - 0.0);\n\tc.b = smoothstep(-0.2, 1.3, c.b);\n    \n \tfragColor = vec4( c , 1. );   \n    \n    \n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtX3WB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[335, 335, 358, 358, 430], [431, 431, 479, 479, 581], [583, 635, 657, 657, 682], [683, 683, 704, 704, 784], [869, 921, 964, 964, 1266], [1269, 1321, 1357, 1412, 1458], [1461, 1461, 1483, 1483, 1519], [1521, 1521, 1546, 1546, 1882], [1885, 1885, 1942, 1999, 2479], [2481, 2481, 2523, 2523, 2571], [2575, 2602, 2632, 2770, 3324], [3327, 3327, 3371, 3371, 3662], [3664, 3664, 3700, 3700, 4210], [4213, 4326, 4375, 4403, 5323], [5326, 5326, 5357, 5357, 5661], [5680, 5680, 5800, 5800, 6873], [6879, 6910, 6974, 6974, 7152], [7154, 7154, 7237, 7237, 7350], [7353, 7353, 7409, 7409, 9787]], "test": "valid"}
{"id": "XtX3WS", "name": "f(z) = z^6 + c", "author": "den", "description": "Just another damn fractal, 6th power, 9x antialiasing", "tags": ["fractal"], "likes": 5, "viewed": 195, "published": "Public", "date": "1424626835", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float fractal(vec2 coord)\n{\n    vec2 z = 4.0 * ( coord / iResolution.xx - vec2(0.5, 0.5 * iResolution.y / iResolution.x));\n\tvec2 c = vec2(0.71 + cos(765.0 * iTime / 943.0) / 64.0, 0.125 + sin(654.0 * iTime / 791.0) / 64.0);\n    float power = 6.0;\n    \n    for(int n = 0; n < 32; ++n)\n    {\n        float r = sqrt(z.x * z.x + z.y * z.y);\n        float phi = power * atan(z.y / z.x);\n        z = pow(r, power) * vec2(cos(phi), sin(phi)) + c;\n    }\n    \n    return length(z) < 4.0 ? 1.0 : 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float c = 0.0;\n    \n    for(float y = 0.0; y < 3.0; ++y)\n    {\n        for(float x = 0.0; x < 3.0; ++x)\n        {\n            c += fractal(fragCoord.xy + vec2(x / 3.0, y / 3.0));\n        }\n    }\n    \n    c /= 9.0;\n    \n\tfragColor = vec4(c, c, c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtX3WS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 492], [494, 494, 551, 551, 809]], "test": "valid"}
{"id": "XtX3z2", "name": "Polyhedral Rosetta Stone", "author": "paniq", "description": "Cube, octahedron and rhombic dodecahedron tesselating each other.", "tags": ["mattdamon"], "likes": 18, "viewed": 1622, "published": "Public API", "date": "1423238847", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// uncomment for a cross section view\n// #define CROSS_SECTION\n\n//------------------------------------------------------------------------\n// Camera\n//\n// Move the camera. In this case it's using time and the mouse position\n// to orbitate the camera around the origin of the world (0,0,0), where\n// the yellow sphere is.\n//------------------------------------------------------------------------\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n#ifdef CROSS_SECTION\n    float an = 1.5+sin(0.3*iTime);\n#else\n    float an = 0.3*iTime + 10.0*mouseX;\n#endif\n\tcamPos = vec3(4.5*sin(an),2.0,4.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n\n//------------------------------------------------------------------------\n// Background \n//\n// The background color. In this case it's just a black color.\n//------------------------------------------------------------------------\nvec3 doBackground( void )\n{\n    return vec3( 0.0, 0.0, 0.0);\n}\n\n// all three basic bodies are symmetric across the XYZ planes\n// octahedron and rhombic dodecahedron have been scaled to align\n// with the vertices of the cube.\n\n// 1D distance of X Y Z planes\nvec2 cube(vec3 p, float r) {\n    vec3 o = abs(p);\n\tfloat s = o.x;\n\ts = max(s, o.y);\n\ts = max(s, o.z);\n\treturn vec2(s-r, 0.0);\n}\n\n// 3D distance of XYZ cross diagonal plane\nvec2 octahedron(vec3 p, float r) {\n    vec3 o = abs(p) / sqrt(3.0);\n\tfloat s = o.x+o.y+o.z;\n\treturn vec2(s-r*2.0/sqrt(3.0), 1.0);\n}\n\n// 2D distance of XY YZ ZX diagonal planes\nvec2 rhombic(vec3 p, float r) {\n    vec3 o = abs(p) / sqrt(2.0);    \n\tfloat s = o.x+o.y;\n\ts = max(s, o.y+o.z);\n\ts = max(s, o.z+o.x);\n\treturn vec2(\n        s-r*sqrt(2.0),\n        2.0);\n}\n\nvec2 min2(vec2 a, vec2 b) {\n    return (a.x <= b.x)?a:b;\n}\n\nvec2 max2(vec2 a, vec2 b) {\n    return (a.x > b.x)?a:b;\n}\n\nvec2 plane( vec3 p) {\n    return vec2(p.y+2.0,3.0);\n}\n\n//------------------------------------------------------------------------\n// Modelling \n//\n// Defines the shapes (a sphere in this case) through a distance field, in\n// this case it's a sphere of radius 1.\n//------------------------------------------------------------------------\nvec2 add_plane(vec3 p, vec2 m) {\n#ifdef CROSS_SECTION\n    m.x = max(max(m.x, p.x),-m.x-0.2);\n#endif\n    return min2(plane(p),m);\n}\n\nvec2 doModel( vec3 p ) {\n    \n    float s = sin(iTime)*0.5+0.5;\n    float f = s*0.13;\n    float q = 1.0+f;\n    \n    p /= q;\n    \n    float k = iTime*0.5;\n    //k = 1.0;\n    float u = smoothstep(0.0,1.0,smoothstep(0.0,1.0,fract(k)));\n    \n    vec2 rho = rhombic(p, 1.0);\n    vec2 cub = cube(p, 1.0);\n    vec2 oct = octahedron(p, 1.0);\n    \n    vec2 cuboct = max2(cub, oct);\n    vec2 icuboct = min2(cub, oct);\n    vec2 rcuboct = min2(cuboct, max2(icuboct, vec2(-cuboct.x, cuboct.y)));\n    \n    vec2 rhocuboct = min2(rcuboct, max2(rho, vec2(-icuboct.x, icuboct.y)));\n    \n    vec2 m = rhocuboct;\n    \n    m.x += f;\n    m.x *= q;\n    \n    return add_plane(p, m);\n}\n\n//------------------------------------------------------------------------\n// Material \n//\n// Defines the material (colors, shading, pattern, texturing) of the model\n// at every point based on its position and normal. In this case, it simply\n// returns a constant yellow color.\n//------------------------------------------------------------------------\nvec3 doMaterial( in vec3 pos, in vec3 nor )\n{\n    float k = doModel(pos).y;\n    return mix(mix(mix(vec3(1.0,0.07,0.01),vec3(0.2,1.0,0.01),clamp(k,0.0,1.0)),\n               vec3(0.1,0.07,1.0),\n               clamp(k-1.0,0.0,1.0)),\n               vec3(0.1),\n               clamp(k-2.0,0.0,1.0));\n}\n\n//------------------------------------------------------------------------\n// Lighting\n//------------------------------------------------------------------------\nfloat calcSoftshadow( in vec3 ro, in vec3 rd );\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec3 mal )\n{\n    vec3 lin = vec3(0.0);\n\n    // key light\n    //-----------------------------\n    vec3  lig = normalize(vec3(1.0,0.7,0.9));\n    float dif = max(dot(nor,lig),0.0);\n    float sha = 0.0; if( dif>0.01 ) sha=calcSoftshadow( pos+0.01*nor, lig );\n    lin += dif*vec3(4.00,4.00,4.00)*sha;\n\n    // ambient light\n    //-----------------------------\n    lin += vec3(0.50,0.50,0.50);\n\n    \n    // surface-light interacion\n    //-----------------------------\n    vec3 col = mal*lin;\n\n    \n    // fog    \n    //-----------------------------\n\tcol *= exp(-0.01*dis*dis);\n\n    return col;\n}\n\nfloat calcIntersection( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 20.0;           // max trace distance\n\tconst float precis = 0.001;        // precission of the intersection\n    float h = precis*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for( int i=0; i<90; i++ )          // max number of raymarching iterations is 90\n    {\n        if( h<precis||t>maxd ) break;\n\t    h = doModel( ro+rd*t ).x;\n        t += h;\n    }\n\n    if( t<maxd ) res = t;\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.002;             // precision of the normal computation\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( pos + v1*eps ).x + \n\t\t\t\t\t  v2*doModel( pos + v2*eps ).x + \n\t\t\t\t\t  v3*doModel( pos + v3*eps ).x + \n\t\t\t\t\t  v4*doModel( pos + v4*eps ).x );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.0005;                 // selfintersection avoidance distance\n\tfloat h = 1.0;\n    for( int i=0; i<40; i++ )         // 40 is the max numnber of raymarching steps\n    {\n        h = doModel(ro + rd*t).x;\n        res = min( res, 64.0*h/t );   // 64 is the hardness of the shadows\n\t\tt += clamp( h, 0.02, 2.0 );   // limit the max and min stepping distances\n    }\n    return clamp(res,0.0,1.0);\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m.x );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = doBackground();\n\n\t// raymarch\n    float t = calcIntersection( ro, rd );\n    if( t>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\n        // materials\n        vec3 mal = doMaterial( pos, nor );\n\n        col = doLighting( pos, nor, rd, t, mal );\n\t}\n\n\t//-----------------------------------------------------\n\t// postprocessing\n    //-----------------------------------------------------\n    // gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n\t   \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtX3z2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 397, 480, 480, 668], [671, 902, 929, 929, 964], [1128, 1159, 1187, 1187, 1286], [1288, 1331, 1365, 1365, 1462], [1464, 1507, 1538, 1538, 1692], [1694, 1694, 1721, 1721, 1752], [1754, 1754, 1781, 1781, 1811], [1813, 1813, 1834, 1834, 1866], [1868, 2150, 2182, 2182, 2280], [2282, 2282, 2306, 2306, 2942], [2944, 3297, 3342, 3342, 3592], [3805, 3805, 3889, 3889, 4465], [4467, 4467, 4517, 4517, 4936], [4938, 4938, 4970, 4970, 5390], [5392, 5392, 5440, 5440, 5868], [5870, 5870, 5934, 5934, 6112], [6114, 6114, 6171, 6171, 7375]], "test": "valid"}
{"id": "XtXGDS", "name": "ngWaves01", "author": "netgrind", "description": "x - mad moire\ny - color shift", "tags": ["wave", "moire", "sine", "netgrind"], "likes": 4, "viewed": 1230, "published": "Public API", "date": "1424563021", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv-=0.5;\n    float a = abs(atan(uv.y/uv.x))/PI;\n    vec4 c = vec4(a,a,a,1.0);\n    float off = iMouse.y/iResolution.y*PI*2.0;\n    c.r += sin(a*iMouse.x*10.0+iTime)*0.1;\n    c.g += sin(a*iMouse.x*10.0+iTime+off)*0.1;\n    c.b += sin(a*iMouse.x*10.0+iTime+off*2.0)*0.1;\n\tfragColor = c;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtXGDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 83, 83, 413]], "test": "valid"}
{"id": "XtXGRS", "name": "Polyhedron DE", "author": "gaz", "description": "inspired by https://www.shadertoy.com/view/MtsGW7", "tags": ["raymarching", "de", "polyhedron"], "likes": 4, "viewed": 212, "published": "Public", "date": "1422797823", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI\t3.14159265359\n#define PI2\t( PI * 2.0 )\n\nvec2 rotate(in vec2 p, in float t)\n{\n\treturn p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nfloat tetrahedron(in vec3 p) // 4\n{\n    vec3 v = vec3(0.0, 1.0, 0.0);\n    float d = dot(p, (v));\n    v.xy = rotate(v.xy, 1.91063); // ?\n    for(float i = 0.0; i < 3.0; i++)\n    {\n        d = max(d, dot(p, vec3(rotate(v.xz, i * PI2 / 3.0), v.y).xzy));\n    }\n    return d;\n}\n\n\nfloat hexahedron(in vec3 p) // 6\n{\n    vec3 v = vec3(0.0, 1.0, 0.0);\n    float d = abs(dot(p, (v)));\n    v.xy = rotate(v.xy, PI / 2.0);\n    d = max(d, abs(dot(p, (v))));\n    v.xz = rotate(v.xz, PI / 2.0);\n    d = max(d, abs(dot(p, (v))));\n    return d;\n}\n\nfloat octahedron(in vec3 p) // 8\n{\n    vec3 v = vec3(0.0, 1.0, 0.0);\n\tfloat a = atan(1.0, sin(PI / 4.0));\n    v.xy = rotate(v.xy, a);\n    float d = 1.0;    \n    for(float i = 0.0; i < 4.0; i++)\n    {\n    \td = max(d, abs(dot(p, vec3(rotate(v.xz, i * PI2 / 4.0), v.y).xzy)));\n    }\n    return d;\n}\n\nfloat dodecahedron(in vec3 p) // 12\n{    \n    vec3 v = vec3(0.0, 1.0, 0.0);\n    float d = abs(dot(p, (v)));\n    v.xy = rotate(v.xy, PI2 / 6.0);\n    for(float i = 0.0; i < 5.0; i++)\n    {\n        d = max(d, abs(dot(p, vec3(rotate(v.xz, i * PI2 / 5.0), v.y).xzy)));\n    }\n    return d;\n}\n\nfloat icosahedron(in vec3 p) // 20\n{\n    vec3 v = vec3(0.0, 1.0, 0.0);\n    float n =  0.69; // ?\n    vec3 v1 = vec3(rotate(v.xy, n), v.z);\n    vec3 v2 = vec3(rotate(v.xy, n * 2.0), v.z);\n    float d = 1.0;    \n    for(float i = 0.0; i < 5.0; i++)\n    {\n    \td = max(d, abs(dot(p, vec3(rotate(v1.xz, i * PI2 / 5.0), v1.y).xzy)));\n    \td = max(d, abs(dot(p, vec3(rotate(v2.xz, i * PI2 / 5.0), v2.y).xzy)));\n    }\n    return d;\n}\n\n\nfloat map(in vec3 p)\n{\n    float t = mod(iTime * 0.5, 15.0);\n    if (t < 3.0)  return mix(tetrahedron(p) - 0.5, hexahedron(p)  -1.0, smoothstep( 1.0,  2.0, t));\n    if (t < 6.0)  return mix(hexahedron(p)  - 1.0, octahedron(p)  -1.0, smoothstep( 4.0,  5.0, t));\n    if (t < 9.0)  return mix(octahedron(p)  - 1.0, dodecahedron(p)-1.0, smoothstep( 7.0,  8.0, t));\n    if (t < 12.0) return mix(dodecahedron(p)- 1.0, icosahedron(p) -1.0, smoothstep(10.0, 11.0, t));\n    if (t < 15.0) return mix(icosahedron(p) - 1.0, tetrahedron(p) -0.5, smoothstep(13.0, 14.0, t));\n    return 1.0;\n}\n\nvec3 calcNormal(in vec3 p)\n{\n\tconst vec2 e = vec2(0.0001, 0.0);\n\treturn normalize(vec3(\n\t\tmap(p + e.xyy) - map(p - e.xyy),\n\t\tmap(p + e.yxy) - map(p - e.yxy),\n\t\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tconst float maxd = 50.0;\n\tconst float precis = 0.001;\n    float h = precis * 2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for(int i = 0; i < 64; i++)\n    {\n        if(h < precis || t > maxd) break;\n\t    h = map(ro + rd * t);\n        t += h;\n    }\n    if(t < maxd) res = t;\n    return res;\n}\n\nvec3 transform(in vec3 p)\n{\n    p.yz = rotate(p.yz, iTime * 0.8);\n    p.zx = rotate(p.zx, iTime * 0.5);\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 col = vec3(0.1 + p.y * 0.15);\n   \tvec3 rd = normalize(vec3(p, -1.8));\n\tvec3 ro = vec3(0.0, 0.0, 4.5);\n    vec3 li = normalize(vec3(0.5, 0.8, 3.0));\n    ro = transform(ro);\n\trd = transform(rd);\n\tli = transform(li);\n    float t = march(ro, rd);\n    if(t > -0.001)\n    {\n        vec3 pos = ro + t * rd;\n        vec3 n = calcNormal(pos);\n\t\tfloat dif = clamp((dot(n, li) + 0.5) * 0.7, 0.3, 1.0);\n        col = vec3(0.95, 0.9, 0.7) * dif;\n    }\n   \tfragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtXGRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 87, 87, 138], [140, 140, 175, 175, 412], [415, 415, 449, 449, 669], [671, 671, 705, 705, 966], [968, 968, 1005, 1005, 1253], [1255, 1255, 1291, 1291, 1681], [1684, 1684, 1706, 1706, 2262], [2264, 2264, 2292, 2292, 2460], [2462, 2462, 2499, 2499, 2793], [2795, 2795, 2822, 2822, 2914], [2916, 2916, 2973, 2973, 3517]], "test": "valid"}
{"id": "XtXGzj", "name": "Mate ", "author": "Kali", "description": "Mate, also known as \"yerba mate\", is a traditional South American caffeine-rich infused drink", "tags": ["df"], "likes": 12, "viewed": 406, "published": "Public", "date": "1423183824", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Mate, also known as \"yerba mate\", is a traditional South American caffeine-rich infused drink\n\n#define RAYMARCH_STEPS 60\n\nconst float detail=0.005;\nconst vec3 lightpos=vec3(13.,30.,-25.);\n\nfloat specular;\nfloat ref=0.;\nfloat gall=0.;\nvec3 color=vec3(0.);\n\n\nmat2 rot2D(float angle) {\n\tfloat a=radians(angle);\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\n\nfloat salpicre(vec2 p) {\n\tp*=.025;\n\tfloat c=texture(iChannel0,p.xy).x;\t\n\tc+=texture(iChannel0,p.xy*2.).y*.5;\t\n\tc+=texture(iChannel0,p.xy*4.).z*.25;\t\n\treturn c*.05;\n}\n\nfloat texture1(vec3 p) {\n\tp=abs(.5-fract(p*2.));\n\tvec3 c=vec3(3.,2.,5.);\n\tfloat es, l=es=0.;\n\tfor (int i = 0; i < 10; i++) { \n\t\t\tp = abs(p + c) - abs(p - c) - p; \n\t\t\tp/= clamp(dot(p, p), .25, 1.);\n\t\t\tp = p* -1.5 + c;\n\t\t\tif ( mod(float(i), 2.) < 1. ) { \n\t\t\t\tfloat pl = l;\n\t\t\t\tl = length(p);\n\t\t\t\tes+= exp(-1. / abs(l - pl));\n\t\t\t}\n\t}\n\treturn es/10.;\n}\n\n\nfloat rand(vec2 co){\n\treturn fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat cyl(vec3 p, vec2 c) {\n\treturn max(length(p.xz)-c.x,abs(p.y)-c.y);\n}\n\nfloat mesa(vec3 p) {\n\tp.y+=texture(iChannel1,p.xz*.04).z*.03;\n\treturn cyl(p+vec3(4.,1.6,5.),vec2(12.,.3));\t\n}\n\nfloat piso(vec3 p) {\n\treturn p.y+13.;\t\n}\n\nfloat pared1(vec3 p) {\n\treturn -p.z+25.+salpicre(p.xy);\t\n}\n\nfloat pared2(vec3 p) {\n\treturn p.x+35.+salpicre(p.zy);\t\n}\n\nfloat pared3(vec3 p) {\n\treturn (-p.x+20.+salpicre(p.zy));\t\n}\n\n\nfloat galleta(vec3 p, inout float c) {\n\tp.y-=-.1;\n\tp.x*=.8;\n\tc=length(sin(p.xz*16.))*.7-texture(iChannel0,p.xz*.06).x*.3;\n\tp.y-=c*.05+texture(iChannel0,p.xz*.15).y*.008;\n;\n\tfloat shape1=length(pow(abs(p),vec3(3.)));\n\tshape1=pow(abs(shape1),1./3.)-.8;\n\tfloat shape2=length(pow(abs(p-vec3(0.,1.3,0.)),vec3(3.)));\n\tshape2=pow(abs(shape2),1./3.)-.8;\n\treturn max(shape1,shape2);\n}\n\nfloat mate(vec3 p)\n{\n\tfloat c=sin(p.y*2.5)*(.03+(p.y+1.)*.03)-pow(abs(p.y-1.),.5)*.15-pow(abs(p.y+1.1),.3)*.12;\n\tc+=smoothstep(0.,1.,max(0.,-p.y)*.25);\n\tp.zx*=1.+c;\n\tfloat exter=cyl(p,vec2(1.,1.4));\n\tfloat inter=cyl(p-vec3(0.,.1,0.),vec2(.85,1.4));\n\treturn max(exter,-inter)*.9+texture(iChannel1,vec2(atan(p.x,p.z),p.y*.5)).x*.005;\n}\n\nfloat yerba(vec3 p) \n{\n\tfloat s=sin(iTime);\n\tfloat ag=cyl(p-vec3(0.,.58+s*.17,0.),vec2(.95,.1));\t\n\tp.y*=1.+p.x*.3;\n\tfloat y=texture(iChannel0, p.xz*.05).x;\n\ty+=texture(iChannel0, p.xz*.1).x*.5;\n\tfloat d=cyl(p-vec3(0.,.58,0.),vec2(.95,.1))-y*.065;\t\n\treturn min(d*.7,ag);\n}\n\nfloat bombilla(vec3 p) \n{\n\tp.y-=.5;\n\tp.xy*=rot2D(-32.-max(0.,p.y-1.5)*7.);\n\tp.x*=1.+pow(clamp(p.y-1.5,0.,1.),2.)*.5;\n\tp.z*=1.-pow(clamp(p.y-1.8,0.,1.),5.)*.15;\n\tfloat y=sin(p.y*50.+p.x*50.)*.015*pow(1.-min(1.,abs(p.y-2.)),4.);\n\tfloat exte=cyl(p-vec3(0.4,1.,0.),vec2(.09,2.))+y;\n\tfloat inte=cyl(p-vec3(0.4,1.05,0.),vec2(.08,2.))+y;\n\treturn max(exte,-inte)*.5;\n}\n\n\nfloat de(vec3 p) {\n\n\tref=gall=0.;\n\t\n\tfloat c1,c2;\n\tfloat ma=mate(p);\n\tfloat ye=yerba(p);\n\tfloat bo=bombilla(p);\n\tfloat me=mesa(p);\n\tfloat pis=piso(p);\n\tfloat pa1=pared1(p);\n\tfloat pa2=max(-p.z-30., min(pared2(p),pared3(p)));\n\n\tvec3 pc=p;\n\tpc+=vec3(4.,1.75,0.);\n\tpc.xz*=mat2(0.6428,0.766,-0.766,0.6428);//rot2D(50.);\n\tfloat cr1=galleta(pc,c1);\n\t\n\tpc=p;\n\tpc+=vec3(4.,1.65,0.8);\n\tpc.yz*=mat2(0.9848,-0.1736,0.1736,0.9848);//rot2D(-10.);\n\tpc.xz*=mat2(0.5,-0.866,0.866,0.5);//rot2D(-60.);\n\tfloat cr2=galleta(pc,c2);\n\n\tfloat d=min(ma,ye);\n\td=min(d,bo);\n\td=min(d,me);\n\td=min(d,pis);\n\td=min(d,pa1);\n\td=min(d,pa2);\n\td=min(d,cr1);\n\td=min(d,cr2);\n\n\tif (abs(d-bo)<.001) ref=1.;\n\tif (cr1+cr2<2.) gall=1.;\n\treturn d;\t\n}\n\nvec3 colorize(vec3 p) {\n\tvec3 color=vec3(0.);\n\tfloat c1,c2;\n\tfloat ma=mate(p);\n\tfloat ye=yerba(p);\n\tfloat bo=bombilla(p);\n\tfloat me=mesa(p);\n\tfloat pis=piso(p);\n\tfloat pa1=pared1(p);\n\tfloat pa2=max(-p.z-30., min(pared2(p),pared3(p)));\n\n\tvec3 pc=p;\n\tpc+=vec3(4.,1.75,0.);\n\tpc.xz*=rot2D(50.);\n\tfloat cr1=galleta(pc,c1);\n\t\n\tpc=p;\n\tpc+=vec3(4.,1.65,0.8);\n\tpc.yz*=rot2D(-10.);\n\tpc.xz*=rot2D(-60.);\n\tfloat cr2=galleta(pc,c2);\n\n\tfloat d=min(ma,ye);\n\td=min(d,bo);\n\td=min(d,me);\n\td=min(d,pis);\n\td=min(d,pa1);\n\td=min(d,pa2);\n\td=min(d,cr1);\n\td=min(d,cr2);\n\n\tref=0.; specular=0.;\n\t\n\t\tif (abs(ma-d)<.001) {\n\t\t\tspecular=.3;\n\t\t\tfloat c=pow(texture1(p)*1.15,1.3);\n\t\t\tcolor=vec3(c*.9,c*c*1.4,c*c*c)+.2;\n\t\t}\n\t\tif (abs(ye-d)<.001) {\n\t\t\tspecular=max(0.,p.x+1.3)*.35;\n\t\t\tfloat c=pow(texture(iChannel0, p.xz*.1).x,2.);\n\t\t\tfloat w=pow(texture(iChannel0, p.xz*.015).y,4.);\n\t\t\tcolor=mix(vec3(1.,.85,.5)*.3,vec3(1.,.8,0.1),c)*.6+w*vec3(1.,.9,.8)*.4;\n\t\t}\n\t\tif (abs(bo-d)<.001) {\n\t\t\tspecular=1.;\n\t\t\tcolor=vec3(.3);\n\t\t}\n\t\tif (abs(me-d)<.001) {\n\t\t\tvec3 tex=pow(texture(iChannel1,p.zx*.15).xyz,vec3(1.5))*vec3(.7,1.,1.)+.15;\n\t\t\tspecular=length(tex)*.5;\n\t\t\tcolor=vec3(1.,.8,.6)*tex*.35+.15;\n\t\t}\n\t\tif (abs(pis-d)<.001) {\n\t\t\tspecular=.1;\n\t\t\tcolor=vec3(.9,.95,1.)*(texture(iChannel2,p.xz*.05).xyz*.5+.1);\n\t\t}\n\t\tif (abs(pa1-d)<.001) {\n\t\t\tspecular=.07;\n\t\t\tcolor=texture(iChannel1,p.xy*.005).xxx*.2+.5;\n\t\t}\n\t\tif (abs(pa2-d)<.001) {\n\t\t\tspecular=.07;\n\t\t\tcolor=texture(iChannel1,p.zy*.005).xxx*.2+.5;\n\t\t}\n\t\tif (abs(cr1-d)<.001) {\n\t\t\tspecular=.1;\n\t\t\tcolor=mix(vec3(1.,.7,.5)*.8,vec3(1.,.65,.3),min(1.,c1))*.53;\n\t\t\tcolor*=1.-texture(iChannel0,p.xz*.05).y*.3;\n\t\t}\n\t\tif (abs(cr2-d)<.001) {\n\t\t\tspecular=.1;\n\t\t\tcolor=mix(vec3(1.,.7,.5)*.8,vec3(1.,.65,.3),min(1.,c2))*.53;\n\t\t\tcolor*=1.-texture(iChannel0,p.xz*.05).y*.3;\n\t\t}\n\treturn color;\n}\n\n\nvec3 normal(vec3 p, float d) {\n\tvec3 e = vec3(0.0,detail,0.0);\n\treturn normalize(vec3( de(p+e.yxx)-d, de(p+e.xyx)-d, de(p+e.xxy)-d) );\n}\n\nfloat AO( const vec3 pos, vec3 nor ) {\n\tfloat totao = 0.0;\n\tfloat pd=de(pos);\n\tfloat dd;\n\tif (gall>0.) dd=.07; else dd=.15;\n\tfloat aodet=dd*(1.+max(0.,pos.z*.15));\n\tfor( int aoi=1; aoi<5; aoi++ ) {\n\t\tfloat d=float(aoi)*aodet;\n\t\ttotao+=(d-de(pos+nor*d))*exp(-2.2*d);\n\t}\n    return clamp(1.-totao, 0., 1.0 );\n}\n\n\nvec3 light(in vec3 p, in vec3 dir, in vec3 n, in float sp, in vec3 col) {\n\tvec3 ldir=-normalize(lightpos-p);\n\tfloat ldist=distance(p,lightpos);\n\tfloat diff=max(0.,dot(ldir,-n))*exp(-.00015*ldist*ldist);\n\tdiff+=max(0.,dot(vec3(1.,0.,0.),-n))*.12;\n\tdiff+=max(0.,dot(vec3(0.,0.,-1.),-n))*.25;\n\tdiff+=max(0.,dot(vec3(0.,-1.,0.),-n))*.2;\n\tdiff+=max(0.,dot(vec3(0.,1.,0.),-n))*.12;\n\tdiff+=.15;\n\tdiff*=AO(p,n);\n\tvec3 r = reflect(ldir,n);\n\tfloat spec=pow(max(0.,dot(dir,-r)),15.);\n\tfloat c=texture1(p);\n\treturn (col*diff+spec*sp);\t\n\t\t}\n\nvec3 raymarch(in vec3 from, in vec3 dir) \n{\n\tvec3 lightdir=-normalize(lightpos-from);\n\tfloat totdist=0., refl=0.; \n\tvec3 col, refcol=col=vec3(0.);\n\tvec3 p,p2;\n\tfloat d=100.;\n\tvec3 norm=vec3(0.);\n\tvec3 odir=dir;\n\tp=p2=from;\n\tfor (int i=0; i<RAYMARCH_STEPS; i++) {\n\t\tif (d>detail) {\n\t\t\td=de(p);\n\t\t\tp+=d*dir;\n\t\t\ttotdist+=d; \n\t\t} \n\t}\n\n\tif (ref>0.) {\n\t\t\trefcol=light(p,dir,norm,specular,vec3(1.5));\n\t\t\trefl=.4;\n\t\t\tp-=d*dir;\n\t\t\tnorm=normal(p,d);\n\t\t\tdir=reflect(dir,-norm);\n\t\t\tp+=detail*2.*dir;\n\t\t\td=1.;\n\t\t\tfor (int i=0; i<40; i++) {\n\t\t\t\tif (d>detail) {\n\t\t\t\t\td=de(p);\n\t\t\t\t\tp+=d*dir;\n\t\t\t\t\ttotdist+=d; \n\t\t\t\t} \n\t\t\t}\n\t}\n\t\t\n\tp+=(d-detail)*dir;\n\tnorm=normal(p,de(p));\n\tcol=mix(light(p, dir, norm, specular, colorize(p)),refcol,refl); \n\tcol+=pow(max(0.,dot(dir,-lightdir)),2.)*refl;\n\tcol+=pow(max(0.,dot(odir,-lightdir)),2.5)*.5;\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t=iTime*.2;\n\tvec2 ang;\n\tif (iMouse.z>0.) {\n\t\tang=iMouse.xy/iResolution.xy-.5;\n\t} else {\n\t\tang=vec2(sin(t*2.),cos(t))*.4;\n\t}\n\tmat2 camrot1=rot2D(ang.x*180.);\n\tmat2 camrot2=rot2D((ang.y-.5)*60.);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv=uv*2.-1.;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 from=vec3(-0.5,0.3,-8.5);\n\tfrom.yz*=camrot2;\n\tfrom.xz*=camrot1;\n\tvec3 dir=normalize(vec3(uv*.75,1.));\n\tdir.yz*=camrot2;\n\tdir.xz*=camrot1;\n\tvec3 col=vec3(0.);\n\tcol=raymarch(from,dir); \n\tcol*=vec3(1.,.9,.75)+.2;\n\tfragColor = vec4(col*1.2,1.0);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtXGzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[260, 260, 285, 285, 356], [359, 359, 383, 383, 524], [526, 526, 550, 550, 874], [877, 877, 897, 897, 966], [968, 968, 995, 995, 1041], [1043, 1043, 1063, 1063, 1152], [1154, 1154, 1174, 1174, 1194], [1196, 1196, 1218, 1218, 1254], [1256, 1256, 1278, 1278, 1313], [1315, 1315, 1337, 1337, 1375], [1378, 1378, 1416, 1416, 1753], [1755, 1755, 1775, 1775, 2088], [2090, 2090, 2112, 2112, 2361], [2363, 2363, 2388, 2388, 2723], [2726, 2726, 2744, 2744, 3431], [3433, 3433, 3456, 3456, 5225], [5228, 5228, 5258, 5258, 5364], [5366, 5366, 5404, 5404, 5674], [5677, 5677, 5750, 5750, 6204], [6206, 6206, 6249, 6249, 7036], [7038, 7038, 7095, 7095, 7638]], "test": "error"}
{"id": "XtXGzl", "name": "SHADE A DAY ( 2 / 17 / 2015)", "author": "cabbibo", "description": "trying to understand volumetric fog Using method by @stormoid / nimitz", "tags": ["raytrace"], "likes": 10, "viewed": 722, "published": "Public", "date": "1424190784", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Trying to understand how volumetric fog works using\n// Fog from nimitz (twitter: @stormoid): https://www.shadertoy.com/view/4ts3z2\n\n\nconst float MAX_TRACE_DISTANCE = 50.0;           // max trace distance\nconst float INTERSECTION_PRECISION = .0001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 40;\n\t\nvec4 spherePos[100];\n\n#define time iTime\n\n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y*1.)), tri(p.z+tri(p.x*1.)), tri(p.y+tri(p.x*1.)));}\n                                 \nmat2 m2 = mat2(0.970,  0.242, -0.242,  0.970);\n\n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat triNoise3d(in vec3 p, in float spd)\n{\n    float z=1.4;\n\tfloat rz = 0.;\n    vec3 bp = p;\n\tfor (float i=0.; i<=3.; i++ )\n\t{\n        vec3 dg = tri3(bp*2.);\n        p += (dg+time*.1*spd);\n\n        bp *= 1.8;\n\t\tz *= 1.5;\n\t\tp *= 1.2;\n        //p.xz*= m2;\n        \n        rz+= (tri(p.z+tri(p.x+tri(p.y))))/z;\n        bp += 0.14;\n\t}\n\treturn rz;\n}\n\n\n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat fogmap(in vec3 p, in float d)\n{\n    //p.x += time*.0005;\n   // p.z += sin(p.x*.00005);\n    return triNoise3d(p*2.2/(d+20.),0.2);\n}\n\n\n// Taken from https://www.shadertoy.com/view/4ts3z2\nvec3 fog(in vec3 col, in vec3 ro, in vec3 rd, in float mt)\n{\n    float d = .05;\n    for(int i=0; i<50; i++)\n    {\n        vec3  pos = ro + rd*d;\n        float rz = fogmap(pos, d);\n\t\tfloat grd =  clamp((rz - fogmap(pos+1.-float(i)*0.1,0.))*20., 0.1, 1. );\n        vec3 col2 = (vec3((.5+d/20.), max(0.,(.4-d/20.)) ,0.)*pow((grd), 1.));\n        col = mix(col,col2,clamp(rz*smoothstep(d-.9,d*2.75,mt/9.),0.0,.1) );\n        d *=1.1; //MAX_TRACE_DISTANCE / 400.;\n        if (d>mt)break;\n    }\n    return col;\n}\n\n// ALL TAKEN FROM IQs AMAZING SITE / TUTORIALS / SHADERS:\n// http://www.iquilezles.org/www/index.htm\n// https://www.shadertoy.com/user/iq\n\n    \n\n\nvec4 texCube( sampler2D sam, in vec3 p, in vec3 n, in float k )\n{\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n    vec3 w = pow( abs(n), vec3(k) );\n\treturn (x*w.x + y*w.y + z*w.z) / (w.x+w.y+w.z);\n}\n\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\n\nfloat sdPlane( vec3 p )\n{\n  return p.y;\n}\n\n\nfloat sdSphere( vec3 p, float s , float offset)\n{\n\n\n    float d1 = length(p) - .1*smoothstep(0.0,1.0,iTime);;\n    d1 *= .8;\t\n    \n   // vec3 nP = vec3( x , y , z );\n    return d1 -s;\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n\n    float d1 = -p.y-c.z;\n    float d2 = max( dot(q,c.xy), p.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n\n}\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 0.3 + 10.0*mouseX;\n\tcamPos = vec3(3.5*sin(an),1.0,3.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n\n\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \n\treturn (d1.x<d2.x) ? d1 : d2;\n    \n}\n\n// exponential smooth min (k = 32);\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat opBlend( vec2 d1, vec2 d2 )\n{\n\n    return smin( d1.x , d2.x , 8.);\n}\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos ){  \n    \n    vec2 res = vec2( sdPlane( pos - vec3( 0. , -1. , 0. )), 0.0 );\n    vec2 res2 = vec2( length( pos- vec3( 0. , -.4 , 0. ) )-1., 3. );\n    \n    res.x = opBlend( res , res2 );\n    \n    return res;\n    //return vec2(length( pos )-1., 3.);\n   \t\n}\n\n\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t );\n        h = m.x;\n        t += h;\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ){ id =-1.0; res = MAX_TRACE_DISTANCE; }\n    \n    return vec2( res , id );\n    \n}\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n    \n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n\n    for( int i =0; i < 20; i++ ){\n        \n        float x = 1. * cos(iTime *.13 * (float( i )+2.));\n        float y = 1. * sin(iTime * .075 * (float( i )+4.));\n        float z = 1. * sin(iTime * .1 * (float( i )+3.3));\n        float r = .1 * ( sin( iTime * .1  *( float( i) +1.))+2.);\n    \tspherePos[i] = vec4( x ,  y ,  z , r  );\n        \n        \n    }\n\n    \n    \n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m.x );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n    vec2 res = calcIntersection( ro , rd  );\n    \n   \n    vec3 col = vec3( 0. );//vec3( .8 , .8 , .8 ); \n   \n    // If we have hit something lets get real!\n    if( res.y > -.5 ){\n\n    \tvec3 pos = ro + rd * res.x;\n    \tvec3 nor = calcNormal( pos );\n        \n        //float AO = calcAO( pos , nor );\n        \n        vec3 l = vec3( -10. , 10. , 0.);\n        vec3 dir = l - pos;\n       // vec3 l = normalize(vec3( -1. , 1. , 0.));\n        float match = max( 0., -dot( normalize(dir ), nor ));\n        float eyeMatch = max(0., dot(  -rd, nor ) );\n\n\n       // float c = pow(( 1.-AO) , 5.)*  10.;\n        float c = 0.;\n        c += 10. * pow((1.- match),4.) / length( dir );\n        //c += pow(( 1.-AO) , 5.)*  2.;\n        col = vec3( 4. * c ,0., 4. * pow((1.-eyeMatch),2.));// * .4 * ( nor * .5 + .5 );\n        \n       /* if( res.y < .5 ){\n            \n            float f = sin( pos.z * 5. ) * sin( pos.x * 5. );\n            //col *= 5. * smoothstep( abs(f) , 0.4 , 0.8 );\n            col *= abs( f );\n            col /= pow( length( pos ), 4.);\n        }*/\n    }\n    \n    //then volumetric fog\n    col = fog(col, ro, rd, res.x);\n    \n    // apply gamma correction\n    col = pow( col, vec3(0.4545) );\n\n    fragColor = vec4( col , 1. );\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtXGzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[371, 423, 445, 445, 470], [471, 471, 492, 492, 572], [655, 707, 750, 750, 1052], [1055, 1107, 1144, 1199, 1243], [1246, 1298, 1358, 1358, 1802], [1950, 1950, 2015, 2015, 2199], [2202, 2202, 2247, 2247, 2287], [2290, 2290, 2315, 2315, 2331], [2334, 2334, 2383, 2383, 2518], [2520, 2520, 2558, 2558, 2729], [2731, 2762, 2826, 2826, 3004], [3006, 3006, 3089, 3089, 3202], [3207, 3301, 3330, 3330, 3373], [3375, 3411, 3452, 3452, 3523], [3525, 3525, 3560, 3560, 3599], [3600, 3684, 3705, 3705, 3957], [3961, 3961, 4009, 4009, 4505], [4507, 4620, 4651, 4651, 4877]], "test": "error"}
