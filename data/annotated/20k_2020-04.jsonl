{"id": "3d2cRt", "name": "infinity ballz", "author": "johndoe", "description": "tis but a shader", "tags": ["shader", "ballz"], "likes": 1, "viewed": 58, "published": "Public", "date": "1587163801", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.1415926535897932384626433832795;\nconst float scale = 200.;\nconst float radius = 10.;\nconst int   count = 50;\nconst float delta = 2.*PI/float(count);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = fragCoord.xy;\n\tvec2 center = iResolution.xy/2.;\n    \n    fragColor = vec4(1.);\n    for (int i=0; i<count; ++i) {\n        float x = float(i)*delta + iTime;\n        vec2 point = center + scale*vec2(cos(x), sin(x)*cos(x));\n        if (distance(xy, point) <  radius)\n        \tfragColor = vec4(0.);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d2cRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[170, 170, 227, 227, 543]], "test": "valid"}
{"id": "3d2cRV", "name": "Cobwebs in 1 tweet", "author": "notargs", "description": "Minified shader for 1 tweet\nhttps://twitter.com/notargs/status/1250468645030858753?s=20", "tags": ["onetweetglsl"], "likes": 40, "viewed": 745, "published": "Public API", "date": "1586975243", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 e, in vec2 v)\n{\n    vec3 d=.5-vec3(gl_FragCoord.xy,1)/iResolution.y,p,o;\n    for(int i=0;i<32;i++)\n    {\n        o=p;\n        o.z-=iTime*9.;\n        float a=o.z*.1;\n        o.xy*=mat2(cos(a),sin(a),-sin(a),cos(a));\n        p+=(.1-length(cos(o.xy)+sin(o.yz)))*d;\n    }\n    e=vec4((sin(p)+vec3(2,5,9))/length(p)*vec3(1), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d2cRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 348]], "test": "valid"}
{"id": "3d2cWc", "name": "Heart_fireworks", "author": "bhuwan0000", "description": "particle motion \nbasic firework simulation with kinematics\nhow can I make it run more faster? please help..", "tags": ["heart", "physics", "fireworks", "particle", "kinematics"], "likes": 6, "viewed": 194, "published": "Public", "date": "1587460459", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//fireworks in heart shape\n//np = no. of particles\n//snp = no. of spawned particles\n\n#define rad(x) radians(x)\n#define np 20.\n#define snp 40.\n#define spawn 1\n#define trail 1\n\n//random value\nvec2 N22(vec2 p){\n    vec3 a = fract(p.xyx*vec3(123.34, 234.34, 345.65));\n    a += dot(a, a+34.45);\n\treturn fract(vec2(a.x*a.y, a.y*a.z));\n}\n\n//particle\nvec3 particle(vec2 st, vec2 p, float r, vec3 col){\n \tfloat d = length(st-p);\n    d = smoothstep(r, r-2.0/iResolution.y, d);//d<r?1.0:0.0;\n    return d*col;\n}\n//particle with light\nvec3 burst(vec2 st, vec2 pos, float r, vec3 col, int heart) {\n\tst -= pos;\n    if (heart==1) st.y -= sqrt(abs(st.x))*0.1;\n    r *=0.6*r;\n    return (r/dot(st, st))*col*0.6;\n}\n\n//displacement with s = p0 + ut + 0.5at^2\nvec2 get_pos(vec2 u, vec2 a, vec2 p0, float t, float ang){\n    ang = rad(ang);\n    vec2 d = p0 + vec2(u.x*cos(ang), u.y*sin(ang))*t + 0.5*a*t*t;\n    return d;\n}\n//velocity at time t\nvec2 get_velocity(vec2 u, vec2 a, float t, float ang){\n    ang = rad(ang);\n    return vec2(u.x*cos(ang), u.y*sin(ang)) + a*t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    float aspect = iResolution.x/iResolution.y;\n    vec3 col = vec3(0.0);\n    float t = mod(iTime, 5.0);\n    \n    //particle\n    float r = 0.04;\n    vec2 u = vec2(5.); //init velocity\n    vec2 a = vec2(0.0, -9.8); //acc due to gravity\n    float ang = 75.0; //angle of projection\n\n    vec3 p1 = vec3(0.0); //particle\n    \n    for (float i=0.; i<np; i++)\n    {\n        vec2 rand = N22(vec2(i));\n        vec2 ip = vec2(sin(15.*rand.x)*aspect, -1.+r); //initial pos\n        u = vec2(sin(5.*rand.x), 5.+sin(4.*rand.y)); //initial velocity\n        float t1 = t-i/5.;\n    \tvec2 s = get_pos(u, a, ip, t1, ang); // displacement\n    \tvec2 v = get_velocity(u, a, t1, ang);\n        float Tf = 2.0*u.y*sin(rad(ang))/abs(a.y); //time of flight\n\t\tvec2 H = get_pos(u, a, ip, Tf/2.0, ang); //max height\n        \n        vec3 pcol = vec3(sin(22.*rand.x), sin(5.*rand.y), sin(1.*rand.x)); //color per particle\n\n        if (v.y<-0.5){\n            //p1+= burst(uv, H, max(0.0, 0.1-(t1*t1-Tf*0.5)), pcol*0.5, 1 );\n        \tr=0.0; //die\n        }\n        p1 += burst(uv, s, r, pcol, 0); //main particle\n        \n        //trail particle\n        if (trail==1){\n        \tfor (float k=4.0; k>0.0; k--){\n                vec2 strail = get_pos(u, a, ip, t1-(k*0.02), ang); //delay for trail particles\n        \t\tp1 += burst(uv, strail, v.y<-0.5?0.0:r-(k*0.006), pcol, 0);\n        \t}\n        }\n        \n        //spawn\n        if (v.y<=0.0 && t1>=Tf/2.0 && spawn==1)\n        {\n            for (float j=0.0; j<snp; j++)\n            {\n                vec2 rand2 = N22(vec2(j));\n                float ang2 = (j*(360./snp));\n                r = 0.035; // radius of spawned particles\n                r -= (t1-Tf*0.5)*0.04;\n                //r/=(t-(Tf/2.)+0.2);\n                \n                float x = cos(rad(ang2)); //coords of unit circle \n                float y = sin(rad(ang2));\n                \n                y = y + abs(x) * sqrt( (8.- abs(x))/50.0 ); // heart shape as a function of j\n\t\t\t\t\n                vec2 heart = vec2(x*x + y*y)*(0.4/(t1*sqrt(t1))); //velocity vector\n                vec2 S = get_pos(heart, a*0.03, H, t1-(Tf/2.), ang2);\n                pcol = vec3(sin(8.*rand2.x), sin(6.*rand2.y), sin(2.*rand2.x)); // color per spawn particle\n                p1 += burst(uv, S, max(0.0,r), pcol, 0);\n                \n            }\n        } \n\n    }\n    \n    //bg\n    col = p1;\n    vec3 night = vec3(0.06, 0.02, 0.18)*vec3(uv.y*0.5+0.5);\n    col += night*(1.0-p1);\n    //col = vec3(light(uv, vec2(0.0), 0.1));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d2cWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[175, 190, 207, 207, 330], [332, 343, 393, 393, 500], [501, 523, 584, 584, 696], [698, 740, 798, 798, 900], [901, 922, 976, 976, 1049], [1051, 1051, 1108, 1159, 3746]], "test": "valid"}
{"id": "3d2cz3", "name": "retrobloomwavey", "author": "kpo", "description": "nah", "tags": ["2d"], "likes": 7, "viewed": 125, "published": "Public", "date": "1587068919", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float wave(vec2 uv, vec2 coords, float height, float frequency)\n{\n    float argument = coords.x + frequency * uv.x;\n    float normalizedSine = height * sin(argument);\n    \n\tfloat col = 1.0 - smoothstep(-2.0,2.0, ((uv.y - coords.y) -normalizedSine)*iResolution.y);\n    col *= uv.y + 2.0;\n    \n    return col;\n}\n\nfloat sun(vec2 uv, vec2 center, float radius, float bloom)\n{\n    float dist = distance(uv, center);\n\tfloat circle = 1.0 - smoothstep(-3.0,3.0, (dist-radius)*iResolution.y);\n    \n    uv.y -= 0.;\n    float visible = 1.0 - step(sin(uv.y * 40.0 + 5.0 * iTime) + 2.7 * uv.y - 0.3, 0.5);\n    visible *= (uv.y + 0.5);\n    return visible * circle + (1.0 - dist + bloom);\n}\n\nvec4 draw(vec4 inputImage, float mask, vec4 color)\n{\n\tinputImage += mask * color;\n    return inputImage;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\t\n    vec4 image = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    float animatedValue = iTime + 0.3 * sin(iTime);\n    float speed = 2.0;\n    image = draw(image, wave(uv, vec2(animatedValue * speed ,-0.2), 0.04, 7.0), vec4(0.1, 0.2, 0.3, 0.0));\n    image = draw(image, wave(uv, vec2(animatedValue * speed * 1.3 ,-0.4), 0.07, 6.0), vec4(0.1, 0.2, 0.3, 0.0));\n    image = draw(image, wave(uv, vec2(animatedValue * speed * 1.5 ,-0.7), 0.1, 5.0), vec4(0.1, 0.2, 0.3, 0.0));\n    image = draw(image, sun(uv, vec2(0.0, 0.4), 0.55, 0.3), vec4(1.0, 85.0/255.0, 0.0, 0.0));\n    \n    // Output to screen\n    fragColor = vec4(image);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d2cz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 65, 65, 309], [311, 311, 371, 371, 675], [677, 677, 729, 729, 783], [785, 785, 842, 892, 1569]], "test": "valid"}
{"id": "3d2czy", "name": "modular multiplication", "author": "omeometo", "description": "something", "tags": ["math"], "likes": 4, "viewed": 75, "published": "Public", "date": "1586878659", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.x*1.1;\n    \n    const int p=17;\n    int k=int(floor(iTime))%(p-2)+2;\n    const float r=0.8/float(p);\n    \n    float t=fract(iTime);\n    t=t*t*(3.0-2.0*t);\n    t=t*t*(3.0-2.0*t);\n    float mindist=1e9;\n    for(int i=1;i<p;i++){\n    \tfloat x=mix(float(i),float((i*k)%p),t)/float(p);\n\t\tfloat y=float((i*k)%p-i)*(t-t*t)*0.1;\n        vec2 c=vec2(2.*x-1., y);\n        mindist=min(mindist, length(uv-c)/r);\n    }\n    fragColor = vec4(smoothstep(1.2, 0.8, mindist));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d2czy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 575]], "test": "valid"}
{"id": "3d2yWy", "name": "Live Code With Friends: Rings", "author": "blackle", "description": "live coded with some friends in about an hour over discord live c:", "tags": ["rings", "livecode"], "likes": 10, "viewed": 328, "published": "Public API", "date": "1587271841", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nfloat hash(float a, float b) {\n  return fract(sin(dot(vec2(a,b), vec2(12.9898, 78.233))) * 43758.5453)*2.-1.;\n}\n\nfloat id;\nfloat scene(vec3 p) {\n  float xscale = 1.;\n  id = floor(p.x*xscale);\n  p.x = (fract(p.x*xscale)-0.5)/xscale;\n  \n  float m1 = hash(id, 69.);\n  float m2 = hash(id, 38.);\n  float m3 = hash(id, 41.);\n  float myTime = iTime + m3*10.;\n  p.yz += vec2(m1,m2)*0.2 * sin(myTime*2.);\n  \n  return 0.8*(length(vec2(length(p.yz)-0.5, p.x))-0.1);\n}\n\nvec3 norm(vec3 p) {\n  mat3 k = mat3(p,p,p)-mat3(0.001);\n  return normalize(scene(p) - vec3(scene(k[0]), scene(k[1]), scene(k[2])));\n}\n\nvec3 srgb(float a, float b, float c) {\n  return pow(vec3(a,b,c), vec3(2.));\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax,p)*ax, p, cos(ro)) + sin(ro)*cross(ax,p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n  \n  float n1 = hash(hash(uv.x, uv.y), iTime * 11.);\n  float n2 = hash(hash(uv.x, uv.y), iTime * 23.);\n  uv += vec2(n1,n2)*0.002;\n\n  vec3 cam = normalize(vec3(1, uv));\n  float rot = iTime;\n  float shift = iTime;\n  float outside = smoothstep(0.0,0.5, asin(sin(iTime*acos(-1.)/4.)));\n  float look = mix(0.05, 0.4, outside);\n  vec3 init = vec3(shift,0,0) + vec3(0, sin(rot), cos(rot))*mix(0.15, 1., outside);\n  cam = erot(cam, vec3(0,1,0), cos(rot)*look);\n  cam = erot(cam, vec3(0,0,1), -sin(rot)*look);\n  vec3 p = init;\n  bool hit = false;\n  float mini = 100000.;\n  int i;\n  for (i = 0 ; i < 100 && !hit; i++) {\n    float dist = scene(p);\n    mini = min(dist, mini);\n    hit = dist*dist < 1e-6;\n    p+=dist*cam;\n  }\n  float glow = pow(exp(-mini*20.), 2.);\n  float idloc = id;\n  float fog = (float(i)/100.);\n  vec3 n = norm(p);\n  vec3 r = reflect(cam, n);\n  float diff = length(sin(n*2.)*0.5+0.5)/sqrt(3.);\n  float spec = length(sin(r*2.)*0.5+0.5)/sqrt(3.);\n  vec3 col = mix(srgb(0.4,0.1,0.2), srgb(0.9,0.7,0.4), spec);\n  col = abs(erot(col, normalize(vec3(1,7,1)), idloc)) + pow(spec, 15.)*2.;\n  vec3 bg = mix(srgb(0.5, 0.2, 0.3), srgb(0.2, 0.1, 0.3), sqrt(length(uv))) + glow*0.2;\n  fragColor.xyz = hit ? mix(col, bg, fog) : bg;\n  fragColor.xyz = sqrt(fragColor.xyz) + hash(hash(uv.x, uv.y), iTime)*0.04;\n  \n  fragColor.xyz = smoothstep(vec3(-0.1), vec3(1.1), fragColor.xyz);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d2yWy.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[194, 194, 224, 224, 305], [317, 317, 338, 338, 650], [652, 652, 671, 671, 785], [787, 787, 825, 825, 864], [866, 866, 904, 904, 968]], "test": "valid"}
{"id": "3d2yzc", "name": "Escher Intersecting Planes", "author": "ZiMMaBuE", "description": "Esheder", "tags": ["escher", "reproduction"], "likes": 8, "viewed": 188, "published": "Public", "date": "1587122964", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 64\n#define MAX_DIST 20.\n#define EPS 0.001\nconst float PI = acos(-1.0);\n\nmat3 rotX(float angle)\n{\n    return mat3(1,\t0,\t\t\t0,\n               0,\tcos(angle), -sin(angle),\n               0,\tsin(angle), cos(angle));\n}\n\nmat3 rotY(float angle)\n{\n\treturn mat3(cos(angle), 0, sin(angle),\n               0,\t\t\t1, 0,\n               -sin(angle), 0, cos(angle));\n}\n\nmat3 rotZ(float angle)\n{\n\treturn mat3(cos(angle), -sin(angle), 0,\n               sin(angle), \tcos(angle),\t 0,\n               0,\t\t \t0,\t\t\t 1);\n}\n\nvec2 opRepLim( in vec2 p, in float s, in vec2 lima, in vec2 limb )\n{\n    return p-s*clamp(round(p/s),lima,limb);\n}\n\n\nfloat sdCube(vec2 pos, float r)\n{\n\tvec2 q = abs(pos) - r;\n\treturn length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\nfloat sdCube(vec3 pos, vec3 r)\n{\n\tvec3 q = abs(pos) - r;\n\treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat plane(vec3 pos)\n{\n    pos.z = mod((pos.z + iTime*0.2), 0.5);\n    pos.xz = opRepLim(pos.xz, 0.5, vec2(-1., -1), vec2(1., 1.0));\n    \n    return sdCube(pos, vec3(0.125,0.02,0.125));\n}\n\nfloat map(vec3 pos)\n{\n    vec3 p = vec3(0);\n    vec2 rot = vec2(PI/4., PI/2.);\n    \n    p = pos;\n    float d1 = max(p.z-0.65, plane(p));\n    \n    p = pos;\n    p *= rotY(rot.x);\n    p *= rotZ(rot.y);\n    p *= rotY(rot.x);\n    float d2 = max(p.z-0.65, plane(p));\n    \n    p = pos;\n    p *= rotY(-rot.x);\n    p *= rotZ(-rot.y);\n    p *= rotY(-rot.x);\n    float d3 = max(p.z-0.65, plane(p));\n    \n    float res = MAX_DIST;\n    res = min(res, d1);\n    res = min(res, d2);\n    res = min(res, d3);\n    return res;\n}\n\nvec3 normals(vec3 pos)\n{\n    vec2 e = vec2(0, 0.01);\n    return normalize(vec3(\n    \tmap(pos+e.yxx)-map(pos-e.yxx),\n        map(pos+e.xyx)-map(pos-e.xyx),\n        map(pos+e.xxy)-map(pos-e.xxy)\n    ));\n}\n\nconst vec4 miss = vec4(MAX_DIST, vec3(0));\nvec4 raymarch(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    for(int i = 0; i<MAX_STEPS; i++)\n    {\n        vec3 pos = ro + rd*t;\n        float d = map(pos);\n        \n        if(abs(d)<=EPS) return vec4(length(pos-ro), normals(pos));\n        if(d >= MAX_DIST) return miss;\n        \n        t+=d;\n    }\n         \n    \n    return miss;\n}\n\nconst vec3 BACK_GROUND = vec3(0.2);\nvec3 GetScene(vec3 ro, vec3 rd, vec3 lightDir)\n{\n    \n    vec4 a = raymarch(ro, rd);\n    float d = a.x;\n    vec3 nor = a.yzw;\n    \n    vec3 col = BACK_GROUND;\n    \n    if(d < MAX_DIST)\n    {\n        float li = dot(lightDir, nor);\n        \n        vec3 pos = ro+rd*d;\n        pos *= rotX(0.9);\n        \n        float lines = sin(pos.y * 300.) * 0.5+0.5;\n        lines = smoothstep(li+0.25, li-0.25, lines);\n        lines = lines*0.7+0.3;\n        \n        col = vec3(1, 0.94, 0.8) * lines;\n        col = mix(col, BACK_GROUND, smoothstep(1., 10., d)); // fog\n    }\n    \n    return col;\n    \n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.x;\n    \n    vec2 mouse = iMouse.xy / iResolution.xy;\n    float camAngle = PI/2.;\n    \n    vec2 p = 1.3 * vec2(cos(camAngle), sin(camAngle));\n    \n    \n    vec3 ro = vec3(p.x,0.915,p.y);\n    mat3 ca = setCamera(ro, vec3(0,0.2,0), 0.0);\n    vec3 rd = ca*normalize(vec3(uv,0.9));\n    \n    vec3 ld = normalize(vec3(1, 0.5, -0.5));\n    \n    vec3 col = GetScene(ro, rd, ld);\n    \n    float v = dot(uv,uv);\n    col = mix(col, vec3(0.4), pow(v,2.));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d2yzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[90, 90, 114, 114, 229], [231, 231, 255, 255, 367], [369, 369, 393, 393, 511], [513, 513, 581, 581, 627], [630, 630, 663, 663, 741], [743, 743, 775, 775, 862], [864, 864, 887, 887, 1051], [1053, 1053, 1074, 1074, 1561], [1563, 1563, 1587, 1587, 1765], [1810, 1810, 1843, 1843, 2141], [2179, 2179, 2227, 2227, 2768], [2770, 2770, 2822, 2822, 2999], [3001, 3001, 3058, 3058, 3615]], "test": "error"}
{"id": "3d2yzd", "name": "Day4: Stroke/Fill Tapered Lines", "author": "fluxatron", "description": "Yesterday I figured out how to draw a line. Last night my dreams plagued me with thoughts of tapered line maths D:\n\nSo I wrote a function that draws a tapered segment with an outline and/or fill :)\n\nBonus: All transform functions are now column major.", "tags": ["line", "stroke", "fill", "taper"], "likes": 1, "viewed": 97, "published": "Public", "date": "1587181087", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nstruct Vertex\n{\n    vec2 pos;\n    float radius;\n};\n    \nfloat segment(in vec2 p, vec2 a, vec2 b, out float ratio)\n{\n\tvec2 ap = p - a;\n\tvec2 ab = b - a;\n\tratio = clamp(dot(ap,ab)/dot(ab,ab), 0.0, 1.0); // Project ap onto ab. Clamp to edges of line if we project beyond it.\n\treturn length( ap - ab*ratio ); // finds length of vec from p to the projection of p onto ab\n}\n\n// returns the distance of p from the taped thicc boi line. negative length indicates p is within the shape\nfloat taperedSegment(vec2 p, vec2 ap, float ar, vec2 bp, float br)\n{\n    float ratio; // Where we are along the line [0,1]. 0 means at a and 1 means b\n    float len = segment(p, ap, bp, ratio); // Compute len from the center line running from point a to b\n    \n    float v = mix(ar, br, ratio);\n    float dist = len - v;\n        \n\treturn dist;\n}\n\n\n// Shape /////////////////////////////////////////////////////////////////////////////////////////////////\nvec3 strokeCol = vec3(0.8,0.2,0.4);\nvec3 fillCol = vec3(0.7,0.3,0.6)*0.6;\nconst int numVerts = 7;\nVertex[numVerts] shape = Vertex[numVerts] (\n    Vertex(vec2(0.25,-0.1), 2.0), // bot left 2\n    Vertex(vec2( 0.0, 0.0), 4.0), // bot left\n    Vertex(vec2( 0.0, 1.0), 2.5), // top left\n    Vertex(vec2( 0.5, 0.5), 5.0), // pivot\n    Vertex(vec2( 1.0, 1.0), 2.5), // top right\n    Vertex(vec2( 1.0, 0.0), 4.0), // bot right\n    Vertex(vec2(0.75,-0.1), 2.0)  // bot right 2\n);\n\n// Finds the distance of P from the line A to B\nvec3 drawShape(vec2 p, mat3 tform, vec3 col, bool stroke, bool fill)\n{\n    float thicc = 0.01;\n    float strokeThicc = 0.008;\n    \n    for(int i = 1; i < numVerts; i++)\n    {\n        Vertex a = shape[i-1];\n        Vertex b = shape[i];\n    \tvec2 ap = (tform * vec3(a.pos, 1)).xy;\n    \tvec2 bp = (tform * vec3(b.pos, 1)).xy;\n        \n        float dist = taperedSegment(p, ap, thicc*a.radius, bp, thicc*b.radius);\n        if (dist < strokeThicc) \n        {\t\n            // stroke\n            col = mix(col, strokeCol, vec3(stroke));\n            \n            // fill\n            if (dist < 0.0) \n            {\n            \tcol = mix(col, fillCol, vec3(fill));\n            }\n        }\n    }\n     \n    return col;\n}\n\n// Move some verts around and scale radii for funsies\nvoid updateShape()\n{\n    shape[2].pos += 0.7 * vec2(0.2*sin(iTime), 0.1*cos(iTime));\n    shape[4].pos += 0.7 * vec2(0.2*-cos(iTime), 0.1*sin(iTime));\n    \n    for (int i = 0; i < numVerts; i++)\n    {\n        shape[i].radius += sin(float(i) + iTime * (1.0 + 0.5*shape[i].radius));\n    }\n}\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////\n/** \n\tMatrix notes\n \t- These are column major.\n\t- Although written as rows, think of them transposed as columns.\n\t- Concatenate transformations in reverse order. Eg. M=T*R*S; Will evaluate left to right (duh) \n\t  but the transformation order will be Scale, Rotate then Translate.\n**/\nmat3 createTranslationMat(vec2 translation)\n{\n    return mat3(vec3(1,0,0), \n                vec3(0,1,0), \n                vec3(translation,1));\n}\nmat3 createScaleMat(vec2 scale)\n{\n    return mat3(scale.x, 0, 0,\n                0, scale.y, 0,\n                0, 0,       1);\n}\nmat3 createRotationMat(float rad)\n{\n    return mat3(cos(rad), sin(rad), 0,\n               -sin(rad), cos(rad), 0,\n                0,        0,        1);\n}\nmat3 createAffineMat(vec2 translation, float rotation, vec2 scale)\n{\n    mat3 S = mat3(createScaleMat(scale));\n    mat3 R = mat3(createRotationMat(rotation));\n    mat3 T = createTranslationMat(translation);\n    return T*R*S;\n}\n\nmat3 matTranslate(mat3 m, vec2 translation)\n{\n    return m * createTranslationMat(translation);\n}\nmat3 matRotate(mat3 m, float rad)\n{\n    return m * createRotationMat(rad);\n}\nmat3 matScale(mat3 m, float scale)\n{\n    return m * createScaleMat(vec2(scale));\n}\nmat3 matScale(mat3 m, vec2 scale)\n{\n    return m * createScaleMat(scale);\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.yy;\n    vec2 uvNorm = fragCoord/iResolution.xy;\n\n    updateShape();\n    \n    // Shape tform - moves pivot to the middle of our shape\n    mat3 shapeMat = mat3(1);\n    shapeMat = matTranslate(shapeMat, vec2(-.5,-.5));\n    \n    // Model tform - moves/rotates and squishes our model\n    mat3 modelMat = mat3(1);\n\tmodelMat = matTranslate(modelMat, vec2(aspectRatio/2., 0.5));\n    modelMat = matRotate(modelMat, sin(iTime*0.7)*0.7);\n   \tmodelMat = matScale(modelMat, 0.5 + 0.08 * vec2(sin((iTime+3.0)*3.0), cos(iTime*3.0)));\n    \n    // View tform - pan the view about\n    mat3 viewMat = mat3(1);\n    viewMat = matTranslate(viewMat, 0.05 * vec2(2.0*sin(1.2*iTime+3.0), cos(iTime+5.0)) );\n    \n    // Draw\n    vec3 col = vec3(1);\n    col = viewMat * vec3(uvNorm,1)*0.2; // Draw background\n    col = drawShape(uv, viewMat*modelMat*shapeMat, col, true, false); // fill\n    col = drawShape(uv, viewMat*modelMat*shapeMat, col, false, true); // stroke. Done in 2 passes to hide interior strokes. Could be nicer :)\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d2yzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[57, 57, 116, 116, 368], [370, 478, 546, 546, 823], [1405, 1453, 1523, 1523, 2163], [2165, 2219, 2239, 2239, 2506], [2509, 2898, 2943, 2943, 3043], [3044, 3044, 3077, 3077, 3173], [3174, 3174, 3209, 3209, 3329], [3330, 3330, 3398, 3398, 3556], [3558, 3558, 3603, 3603, 3655], [3656, 3656, 3691, 3691, 3732], [3733, 3733, 3769, 3769, 3815], [3816, 3816, 3851, 3851, 3891], [3894, 3997, 4054, 4054, 5185]], "test": "valid"}
{"id": "3d2yzW", "name": "menger--v4-sdCylinder", "author": "jorge2017a1", "description": "menger--v4-sdCylinder", "tags": ["mengerv4sdcylinder"], "likes": 3, "viewed": 55, "published": "Public", "date": "1586205308", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/////modificado por jorge flores.p --\n//Gracias a ....Created by russ in 2017-04-06\n//https://www.shadertoy.com/view/XsfczB\n    \n\nconst int iter =100;\nconst float eps = 0.001, far = 20.;\nvec3 lDir0 = normalize(vec3(1,2,1)), lDir1 = normalize(vec3(-1,1.0,-2));\nvec3 lCol0 = vec3(1,.8,.5), lCol1 = vec3(.6,0.8,1); \n\n\n#define PI 3.1415926\n\n///-------------------------------------\nconst int MAX_RAY_STEPS = 64;\nconst float RAY_STOP_TRESHOLD = 0.0001;\nconst int MENGER_ITERATIONS = 5;\n///-------------------------------------\n\nfloat NumCol;\n\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3  di = abs(p) - b;\n  float mc = maxcomp(di);\n  return min(mc,length(max(di,0.0)));\n}\n\n//-------------------------------------------\n\n\n//oooooooooooooooooooooooooooooooooooooooooooooooooooo\nfloat sdCross(vec3 p) {\n\tp = abs(p);\n\tvec3 d = vec3(max(p.x, p.y),\n\t\t\t\t  max(p.y, p.z),\n\t\t\t\t  max(p.z, p.x));\n\treturn min(d.x, min(d.y, d.z)) - (1.0 / 3.0);\n}\n\nfloat sdCrossRep(vec3 p) {\n\tvec3 q = mod(p + 1.0, 2.0) - 1.0;\n\treturn sdCross(q);\n}\n\nfloat sdCrossRepScale(vec3 p, float s) {\n\treturn sdCrossRep(p * s) / s;\t\n}\n\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n//---------------------\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\n\nfloat diso( vec3 p)\n{\n    \n    vec2 res=vec2(9999.,0.0);\n    float dif1;\n   \n    p.z=mod(p.z,2.0);\n    float sdcy1 =sdCylinder(  p.yzx, vec2(6.0,6.0) ) ;\n    float sdcy2 =sdCylinder(  p.yzx, vec2(4.7,6.78) ) ;\n   \tfloat sdb1 =sdBox( p, vec3(5.0,-1.0,6.0) );\n    \n    dif1 = differenceSDF(sdcy1,sdcy2);\n    dif1 = differenceSDF(dif1,sdb1);\n    \n    \n    res=opU(res, vec2(dif1,9.0) );\n   \n    return res.x;\n}  \n\n//--------------------------\nfloat DE(vec3 p) {\n\t\n    \n    float scale = 0.35;\n    vec2 res=vec2(9999.9,0.0) ;\n\n    float dist, dist1;\n     dist=-999.0;\n     dist =diso(p);\n \n\tfor (int i = 0; i < MENGER_ITERATIONS; i++) {\n\t\tdist = max(dist, -sdCrossRepScale(p, scale));\n\t\tscale *= 3.0;\n\t}\n\n\t\n    \n    \n    if (mod(iTime, 10.0)>0.5 )\n    {\n    \tres=opU(res, vec2(dist,8.0) );\n\t}\n    else\n    {\n    \tres=opU(res, vec2(dist,11.0) );\n\t}   \n    \n    \n    NumCol =res.y;\n    \n\treturn res.x;\n}\n\n//oooooooooooooooooooooooooooooooooooooooooooooooooooo\n\n\n\nvec2 march(vec3 ro, vec3 rd){\n\tfloat t=0. , d = far, it = 0.;\n    for (int i=0;i<iter;i++){\n     \tt += (d = DE(ro+t*rd));\n        if(d<eps || t> far) break;\n        it += 1.;\n    }\n    return vec2(t,it/float(iter));\n}\n\nfloat getShadow(vec3 p, vec3 n, vec3 ld){\n    p +=  2. * eps * n;\n    float t=0.,d=far;\n    for(int i=0;i<50;i++){\n        t += (d=DE(p + t*ld));\n        if (d<eps || t>3.) break;\n    }\n    return t<=3. ? 0.1 : 1. ;\n}\n\nvec3 getRay(vec3 ro, vec3 look, vec2 uv){\n    vec3 f = normalize(look - ro);\n    vec3 r = normalize(vec3(f.z,0,-f.x));\n    vec3 u = cross (f,r);\n    return normalize(f + uv.x * r + uv.y * u);\n}\n\nvec3 getNorm(vec3 p){\n    vec2 e = vec2(eps, 0);\n    return normalize(vec3(DE(p+e.xyy)-DE(p-e.xyy),DE(p+e.yxy)-DE(p-e.yxy),DE(p+e.yyx)-DE(p-e.yyx)));\n}\n\nvec3 light(vec3 p, vec3 n){\n    vec3 col = vec3(0.01);\n    for(int i=0;i<2;i++){\n        vec3 ld = (i==0) ? lDir0 : lDir1;\n        float diff = max(dot(n, (ld)),0.);\n        diff *= getShadow(p, n, ld);\n        col += diff * (i==0 ? lCol0 : lCol1);\n    }\n    return col * .7;\n}\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) {\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n\n//-----------------------------------\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tif(i==0 )\n    {\n    \n        return vec3(0.,0.,0.);\n    }\n    \n    if(i== 1 )\n    {\n        \n        return vec3(0.,0.,1.);\n    } \n    if(i== 2 )\n    {\n       return vec3(0.,1.,0.);\n    } \n    if(i== 3 )\n    {\n        return vec3(0.,1.,1.);\n    } \n    if(i== 4 )\n    {\n        return vec3(1., 0., 0.);\n    } \n    \n    if(i== 5 )\n    {\n        return vec3(1., 0.,1.);\n        } \n    if(i== 6 )\n    {\n        \n    \t//return vec3(1., 1., 0.);\n         \n    } \n        \n    if(i== 7 )\n    {\n        return vec3(1., 1., 1.);\n       } \n    if(i== 8 )\n    {\n       \n        return vec3(0.425, 0.56, 0.9); \n       } \n    if(i== 9 )\n    {\n        \n        return vec3(0.5, 0.6, 0.6); \n     } \n    if(i== 10 )\n    {\n        return vec3(0.0, 1.0, 0.0);\n    } \n    \n    \n    if(i== 11 )\n    {\n        return  vec3(0.5, 0.8, 0.9);;\n    } \n    \n    \n    \n  \n    \t\n}\n\n\n//----------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float time = iTime * 0.5;\n   \n\tvec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n  \n    \n    \n \n   \n    vec3 ro = vec3(0.0,5.0+0.5*sin(iTime),-5.0+iTime);\n    \n   \n    vec3 rd =normalize(vec3(uv,1.0) );\n    \n    vec2 hit = march(ro, rd);\n    vec3 p = ro + hit.x*rd;\n    \n    vec3 col = hit.x<far ? light(p, getNorm(p)) : vec3(.1*(1.-length(uv)));\n    \n    vec3 colobj=getSphereColor( int( NumCol));\n    col *=colobj;\n    \n    \n    col += pow(hit.y,3.);\n\tfragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d2yzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[538, 538, 565, 565, 596], [598, 598, 629, 629, 720], [770, 825, 848, 848, 983], [985, 985, 1011, 1011, 1068], [1070, 1070, 1110, 1110, 1144], [1147, 1147, 1195, 1195, 1228], [1255, 1255, 1291, 1291, 1394], [1396, 1396, 1425, 1425, 1551], [1554, 1554, 1575, 1575, 1961], [1965, 1994, 2012, 2012, 2451], [2511, 2511, 2540, 2540, 2728], [2730, 2730, 2771, 2771, 2947], [2949, 2949, 2990, 2990, 3142], [3144, 3144, 3165, 3165, 3295], [3297, 3297, 3324, 3324, 3574], [3631, 3675, 3692, 3692, 3763], [3788, 3880, 3905, 3905, 4168], [4210, 4210, 4238, 4238, 5118], [5177, 5177, 5234, 5234, 5746]], "test": "error"}
{"id": "3dBcR3", "name": "sdLine Continuity", "author": "harry7557558", "description": "Use a power higher than 2 to increase the continuity of line segment primitive for modeling", "tags": ["sdf", "smooth", "g2"], "likes": 4, "viewed": 69, "published": "Public", "date": "1587029897", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Time measured with Shadertoy unofficial plugin by Patu\n\n// 1.00ms\nfloat sdLine(vec3 p, vec3 a, vec3 b){\n    vec3 pa = p-a, ba = b-a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba),0.,1.);\n    return length(pa-ba*h);\n}\n\n// 1.15ms\nfloat sdLine4(vec3 p, vec3 a, vec3 b){\n    vec3 pa = p-a, ba = b-a;\n    float h = dot(pa,ba)/dot(ba,ba);\n    pa -= ba*h;\n    h = max(abs(h-.5)-.5,0.);\n    return sqrt(length(vec2(dot(pa,pa),h*h*dot(ba,ba))));\n}\n\n// 1.25ms\nfloat sdLine3(vec3 p, vec3 a, vec3 b){\n    vec3 pa = p-a, ba = b-a;\n    float h = dot(pa,ba)/dot(ba,ba);\n    float u = length(pa-ba*h), v = max(abs(h-.5)-.5,0.)*length(ba);\n    return pow(u*u*u+v*v*v,1./3.);\n}\n\n// 1.5ms-1.6ms\nfloat sdLineN(vec3 p, vec3 a, vec3 b, float n){\n    vec3 pa = p-a, ba = b-a;\n    float h = dot(pa,ba)/dot(ba,ba);\n    float u = length(pa-ba*h), v = max(abs(h-.5)-.5,0.)*length(ba);\n    return pow(pow(u,n)+pow(v,n),1./n);\n}\n// n=2:    G1\n// 2<n<3:  G2 with divergent 3rd derivative, looks like G1\n// n=3:    G2, looks like G2\n// 3<n<4:  G3 with divergent 4th derivative\n// n≥4:    G3+\n\n\n\nvec3 a, b;\nfloat map(vec3 p){\n    return sdLineN(p,a,b,3.-cos(iTime))-1.0;\n}\nvec3 grad(vec3 p){\n    const float e = .001;\n\tfloat a = map(p+vec3(e,e,e));\n\tfloat b = map(p+vec3(e,-e,-e));\n\tfloat c = map(p+vec3(-e,e,-e));\n\tfloat d = map(p+vec3(-e,-e,e));\n\treturn normalize(vec3(a+b-c-d,a-b+c-d,a-b-c+d));\n}\n\n\n#define res iResolution.xy\nvoid mainImage(out vec4 col, in vec2 coord) {\n    vec3 p = vec3(0,0,10.);\n    float sc = 1./length(res);\n    vec3 d = normalize(vec3(10.*(coord-.5*res)*sc,0.)-p);\n    \n    if (iMouse.z>0.){\n        vec2 uv = 3.*(iMouse.xy-.5*res)*sc;\n        a = 1.2*normalize(vec3(uv,cos(2.*length(uv)))), b=-a;\n    }\n    else{\n        //float c = cos(iTime), s = sin(iTime);\n        float c = 1., s = 0.;\n        a = vec3(1.2*c,.4*c,-s), b=-a;\n    }\n    \n    // the usual raymarching code\n    col = vec4(0,0,0,1);\n    float t=0., dt;\n    for (int i=0;i<64;i++){\n        dt = map(p+t*d);\n        t += dt;\n        if (dt<.001) break;\n        if (t>100.) return;\n    }\n    col.xyz=vec3(.9*max(dot(grad(p+t*d),vec3(.55)),0.)+.1);\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dBcR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 69, 106, 106, 215], [217, 227, 265, 265, 437], [439, 449, 487, 487, 658], [660, 675, 722, 722, 898], [1076, 1076, 1094, 1094, 1141], [1142, 1142, 1160, 1160, 1368], [1398, 1398, 1443, 1443, 2110]], "test": "valid"}
{"id": "3dByDc", "name": "HW_09_2 XuechengSun_Noise", "author": "hehehaha12138", "description": "HW09 for CIS461 Shadow Noise Scene", "tags": ["3d"], "likes": 1, "viewed": 183, "published": "Public API", "date": "1587681636", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SQUARE_PLANE 0\n#define CUBE 1\n#define SPHERE 2\n#define POINT_LIGHT 0\n#define FOCAL_LENGTH 8.0\n#define FOCAL_RANGE 20.0\nconst float AO_DIST = 0.2;\nconst float FIVETAP_K = 2.0;\n\nconst float FOVY = 3.141569 * 0.25;\nconst int RAY_STEPS = 256;\n\nstruct Intersection {\n    float t;\n    vec3 color;\n    vec3 p;\n    int object; // Assign every object in our scene a unique ID int\n};\n    \nstruct Transform\n{\n\tvec3 trans;\n    vec3 scale;\n    vec3 rotate;\n};\n\nstruct Primitive\n{\n\tint id;\n    Transform transform;\n    vec3 matColor;\n    int primitiveId;\n};\n    \nstruct Light\n{\n\tint id;\n    int typeId;\n    float intensity;\n    Transform transform;\n    vec3 lightColor;\n};\n   \n    \nPrimitive floorSquare;\nPrimitive redWall;\nPrimitive greenWall;\nPrimitive backWall;\nPrimitive ceilingWall;\nPrimitive shortCube;\nPrimitive sphere1;\nLight pointLight;\nPrimitive primitives[7];\nLight lights[1];\n\nvoid initializeCornelBox()\n{\n    \n    \n    // Primitive initialization\n\tfloorSquare.transform.trans = vec3(0, -2.5, 0);\n\tfloorSquare.transform.rotate = vec3(-90, 0, 0);\n\tfloorSquare.transform.scale = vec3(10, 10, 1);\n    floorSquare.primitiveId = SQUARE_PLANE;\n    floorSquare.matColor = vec3(0.85, 0.81, 0.78);\n    primitives[0] = floorSquare;\n    \n    redWall.transform.trans = vec3(5, 2.5, 0);\n\tredWall.transform.rotate = vec3(0, -90, 0);\n\tredWall.transform.scale = vec3(10, 10, 1);\n    redWall.primitiveId = SQUARE_PLANE;\n    redWall.matColor = vec3(0.63, 0.065, 0.05);\n    primitives[1] = redWall;\n    \n    greenWall.transform.trans = vec3(-5, 2.5, 0);\n    greenWall.transform.rotate = vec3(0, 90, 0);\n\tgreenWall.transform.scale = vec3(10, 10, 1);\n    greenWall.primitiveId = SQUARE_PLANE;\n    greenWall.matColor = vec3(0.14, 0.45, 0.091);\n    primitives[2] = greenWall;\n    \n    backWall.transform.trans = vec3(0, 2.5, 5);\n    backWall.transform.rotate = vec3(0, 180,  0);\n\tbackWall.transform.scale = vec3(10, 10, 1);\n    backWall.primitiveId = SQUARE_PLANE;\n    backWall.matColor = vec3(0.85, 0.81, 0.78);\n    primitives[3] = backWall;\n    \n    ceilingWall.transform.trans = vec3(0, 7.5, 0);\n    ceilingWall.transform.rotate = vec3(90, 0, 0);\n\tceilingWall.transform.scale = vec3(10, 10, 1);\n    ceilingWall.primitiveId = SQUARE_PLANE;\n    ceilingWall.matColor = vec3(0.85, 0.81, 0.78);\n    primitives[4] = ceilingWall;\n    \n    shortCube.transform.trans = vec3(-2, -1, 0.75);\n    shortCube.transform.rotate = vec3(0, -17.5, 0);\n\tshortCube.transform.scale = vec3(3, 3, 3);\n    shortCube.primitiveId = CUBE;\n    shortCube.matColor = vec3(0.85, 0.81, 0.78);\n    primitives[5] = shortCube;\n    \n    sphere1.transform.trans = vec3(2, 0, 3);\n    sphere1.transform.rotate = vec3(0, 27.5, 0);\n\tsphere1.transform.scale = vec3(3, 3, 3);\n    sphere1.primitiveId = SPHERE;\n    sphere1.matColor = vec3(0.85, 0.81, 0.78);\n    primitives[6] = sphere1;\n    \n \n    \n    // Light initlaization\n    pointLight.id = 0;\n    pointLight.typeId = POINT_LIGHT;\n    pointLight.intensity = 2.0;\n    pointLight.lightColor = vec3(17, 12, 4);\n    pointLight.transform.trans = vec3(0, 7.0, -2.0);\n    pointLight.transform.rotate = vec3(90, 0, 0);\n    pointLight.transform.scale = vec3(3, 3, 1);\n    \n    return;\n}\n\n\n\nfloat random1( vec3 p ) {\n    return fract(sin((dot(p, vec3(127.1,\n                                  311.7,\n                                  191.999)))) *         \n                 43758.5453);\n}\n\nfloat random1(vec2 n)\n{\n\treturn fract(\n                 sin(\n                     dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nvec2 random2(vec2 p)\n{\n\treturn fract(sin(vec2(dot(p, vec2(127.1, 311.7)),\n                          dot(p, vec2(269.5, 183.3))))\n                          * 42121.32);\n}\n\nvec3 random3( vec3 p ) {\n    return fract(sin(vec3(dot(p,vec3(127.1, 311.7, 191.999)),\n                          dot(p,vec3(269.5, 183.3, 765.54)),\n                          dot(p, vec3(420.69, 631.2,109.21))))\n                 *43758.5453);\n}\n\nfloat fbm2D(vec2 n)\n{\n    float result = 0.0f;\n    float persistence = 0.5f;\n    int octaves = 8;\n\n\n\n\n    for(int i = 1; i <= octaves; i++)\n    {\n        float freq = pow(3.0, float(i));\n        float amp = pow(persistence, float(i));\n\n        float x = n.x * freq;\n        float y = n.y * freq;\n\n        float v1 = random1(vec2(floor(x), floor(y)));\n        float v2 = random1(vec2(floor(x) + 1.0, floor(y)));\n        float v3 = random1(vec2(floor(x), floor(y) + 1.0));\n        float v4 = random1(vec2(floor(x) + 1.0, floor(y) + 1.0));\n\n        float i1 = mix(v1, v2, fract(x));\n        float i2 = mix(v3, v4, fract(x));\n\n        result += mix(i1, i2, fract(y)) * amp;\n    }\n    result = pow(result, 2.0);\n    return result;\n}\n\nvec3 pow3D(vec3 p, float power)\n{\n\treturn vec3(pow(p.x, power), pow(p.y, power), pow(p.z, power));\n}\n\nfloat surflet(vec3 p, vec3 gridPoint) {\n    // Compute the distance between p and the grid point along each axis, and warp it with a\n    // quintic function so we can smooth our cells\n    vec3 t2 = abs(p - gridPoint);\n    vec3 t = vec3(1.0) - 6.0 * pow3D(t2, 5.0) - 15.0 * pow3D(t2, 4.0) + 10.0 * pow3D(t2, 3.0);\n    // Get the random vector for the grid point (assume we wrote a function random2\n    // that returns a vec2 in the range [0, 1])\n    vec3 gradient = random3(gridPoint) * 2.0 - vec3(1, 1, 1);\n    // Get the vector from the grid point to P\n    vec3 diff = p - gridPoint;\n    // Get the value of our height field by dotting grid->P with our gradient\n    float height = dot(diff, gradient);\n    // Scale our height field (i.e. reduce it) by our polynomial falloff function\n    return height * t.x * t.y;\n}\n\nfloat PerlinNoise3D(vec3 pos) {\n\tfloat surfletSum = 0.0;\n    \n    int cell = 1;\n    \n\tfor(int dx = 0; dx <= cell; ++dx) {\n\t\tfor(int dy = 0; dy <= cell; ++dy) {\n            for(int dz=0; dz <= cell; ++dz)\n            {\n            \tsurfletSum += surflet(pos, floor(pos) + vec3(dx, dy, dz));\n            }\n\t\t\t\n\t\t}\n\t}\n\treturn surfletSum;\n}\n\n\nfloat WorleyNoise3D(vec3 p) {\n    // Tile the space\n    vec3 pointInt = floor(p);\n    vec3 pointFract = fract(p);\n\n    float minDist = 1.0; // Minimum distance initialized to max.\n\n    // Search all neighboring cells and this cell for their point\n    for(int z = -1; z <= 1; z++)\n    {\n        for(int y = -1; y <= 1; y++)\n        {\n            for(int x = -1; x <= 1; x++)\n            {\n                vec3 neighbor = vec3(float(x), float(y), float(z));\n\n                // Random point inside current neighboring cell\n                vec3 point = random3(pointInt + neighbor);\n\n                // Animate the point\n                point = 0.5 + 0.5 * sin(iTime * 0.01 + 6.2831 * point); // 0 to 1 range\n\n                // Compute the distance b/t the point and the fragment\n                // Store the min dist thus far\n                vec3 diff = neighbor + point - pointFract;\n                float dist = length(diff);\n                minDist = min(minDist, dist);\n            }\n        }\n    }\n    return minDist;\n}\n\nfloat WorleyNoise2D(vec2 p) {\n    // Tile the space\n    p = p * 5.0;\n    vec2 pointInt = floor(p);\n    vec2 pointFract = fract(p);\n\n    float minDist = 1.0; // Minimum distance initialized to max.\n\n    // Search all neighboring cells and this cell for their point\n    int cell = 1;\n   \n    for(int y = -cell; y <= cell; y++)\n    {\n        for(int x = -cell; x <= cell; x++)\n        {\n            vec2 neighbor = vec2(float(x), float(y));\n\n            // Random point inside current neighboring cell\n            vec2 point = random2(pointInt + neighbor);\n\t\t\tpoint = 0.5 + 0.5 * sin(4.2132 * point + iTime);\n            \n            // Animate the point\n            point = 0.5 + 0.5 * sin(iTime * 0.01 + 6.2831 * point); // 0 to 1 range\n\n            // Compute the distance b/t the point and the fragment\n            // Store the min dist thus far\n            vec2 diff = neighbor + point - pointFract;\n            float dist = length(diff);\n            minDist = min(minDist, dist);\n        }\n    }\n    \n    return minDist;\n}\n\nvoid CoordinateSystem(in vec3 v1, out vec3 v2, out vec3 v3) {\n    if (abs(v1.x) > abs(v1.y))\n            v2 = vec3(-v1.z, 0.0, v1.x) / sqrt(v1.x * v1.x + v1.z * v1.z);\n        else\n            v2 = vec3(0.0, v1.z, -v1.y) / sqrt(v1.y * v1.y + v1.z * v1.z);\n        v3 = cross(v1, v2);\n}\n\nvec3 WorleyTangentSpaceNormal(vec3 pos) {\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( WorleyNoise3D(pos + epsilon.yxx) - WorleyNoise3D(pos - epsilon.yxx),\n                            WorleyNoise3D(pos + epsilon.xyx) - WorleyNoise3D(pos - epsilon.xyx),\n                            WorleyNoise3D(pos + epsilon.xxy) - WorleyNoise3D(pos - epsilon.xxy)));\n\n}\n\nvec3 PerlinTangentSpaceNormal(vec3 pos) {\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( PerlinNoise3D(pos + epsilon.yxx) - PerlinNoise3D(pos - epsilon.yxx),\n                            PerlinNoise3D(pos + epsilon.xyx) - PerlinNoise3D(pos - epsilon.xyx),\n                            PerlinNoise3D(pos + epsilon.xxy) - PerlinNoise3D(pos - epsilon.xxy)));\n\n}\n\n    \n    \nmat4 transformMatrix(Transform t)\n{\n\tmat4 translate = mat4(      1.0,       0.0,       0.0, 0.0,\n                                0.0,       1.0,       0.0, 0.0,\n                                0.0,       0.0,       1.0, 0.0,\n                                t.trans.x,       t.trans.y,       t.trans.z, 1.0);\n    \n    float xRot = radians(t.rotate.x);\n    float yRot = radians(t.rotate.y);\n    float zRot = radians(t.rotate.z);\n    \n    mat4 rotateX = mat4(1.0,        0.0,       0.0, 0.0,\n                        0.0,  cos(xRot), sin(xRot), 0.0,\n                        0.0, -sin(xRot), cos(xRot), 0.0,\n                        0.0,        0.0,       0.0, 1.0);\n    \n    mat4 rotateY = mat4(cos(yRot), 0.0, -sin(yRot), 0.0,\n                              0.0, 1.0,        0.0, 0.0,\n                        sin(yRot), 0.0,  cos(yRot), 0.0,\n                              0.0, 0.0,        0.0, 1.0);\n    \n    mat4 rotateZ = mat4( cos(zRot), sin(zRot), 0.0, 0.0,\n                        -sin(zRot), cos(zRot), 0.0, 0.0,\n                               0.0,       0.0, 1.0, 0.0,\n                               0.0,       0.0, 0.0, 1.0);\n    \n    mat4 scale = mat4(      t.scale.x,       0.0,       0.0, 0.0,\n                            0.0,       t.scale.y,       0.0, 0.0,\n                            0.0,       0.0,       t.scale.z, 0.0,\n                            0.0,       0.0,       0.0, 1.0);\n    \n    return translate * rotateX * rotateY * rotateZ * scale;\n}\n\nmat4 rotMat(Transform t)\n{\n\tfloat xRot = radians(t.rotate.x);\n    float yRot = radians(t.rotate.y);\n    float zRot = radians(t.rotate.z);\n    \n    mat4 rotateX = mat4(1.0,        0.0,       0.0, 0.0,\n                        0.0,  cos(xRot), sin(xRot), 0.0,\n                        0.0, -sin(xRot), cos(xRot), 0.0,\n                        0.0,        0.0,       0.0, 1.0);\n    \n    mat4 rotateY = mat4(cos(yRot), 0.0, -sin(yRot), 0.0,\n                              0.0, 1.0,        0.0, 0.0,\n                        sin(yRot), 0.0,  cos(yRot), 0.0,\n                              0.0, 0.0,        0.0, 1.0);\n    \n    mat4 rotateZ = mat4( cos(zRot), sin(zRot), 0.0, 0.0,\n                        -sin(zRot), cos(zRot), 0.0, 0.0,\n                               0.0,       0.0, 1.0, 0.0,\n                               0.0,       0.0, 0.0, 1.0);\n    \n    return rotateX * rotateY * rotateZ;\n}\n\nmat3 TangentToWorld(vec3 nor) {\n\tvec3 tangent, bitangent;\n    CoordinateSystem(nor, tangent, bitangent);\n    return mat3(tangent, bitangent, nor);\n}\n\n// SDF of a sphere\nfloat sphere(vec3 p, Transform trans) {\n    p = vec3(inverse(transformMatrix(trans)) * vec4(p, 1.0));\n    return distance(p, vec3(0.0)) - 0.5f;\n}\n\n// Cube SDF\nfloat cube(vec3 p, Transform cubeTrans)\n{\n\tvec3 q = vec3(abs(inverse(transformMatrix(cubeTrans)) * vec4(p, 1.0))) - vec3(0.5);\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// SquarePlane SDF\nfloat squarePlane(vec3 p, Transform squareTrans)\n{\n    mat4 squareMat = transformMatrix(squareTrans);\n    vec3 planeNormal = vec3(0, 0, 1);\n    vec3 actualPoint = vec3(inverse(squareMat) * vec4(p, 1.0f));    \n\treturn abs(dot(actualPoint, planeNormal));\n}\n\nfloat squarePlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p, n.xyz) + n.w;\n}\n\n\nbool isOnPlane(vec3 p, Transform squareTrans)\n{\n    mat4 squareMat = transformMatrix(squareTrans);\n\tvec3 ap = vec3(inverse(squareMat) * vec4(p, 1.0));\n    if(ap.x < 0.5f && ap.x > -0.5f && ap.y < 0.5f && ap.y > -0.5f)\n    {\n    \treturn true;\n    }\n    else\n    {\n    \treturn false;\n    }\n}\n\n\nvoid sceneMap3D(vec3 pos, out float t, out int obj)\n{\n    float minT = 10000.0;\n    obj = -1;\n    for(int i = 0; i < primitives.length(); i = i + 1)\n    {\n        if(primitives[i].primitiveId == SQUARE_PLANE)\n        {\n            vec4 curNor = normalize(rotMat(primitives[i].transform) * vec4(0.0, 0.0, 1.0, 0.0));\n            float maxOffset = max(max(abs(primitives[i].transform.trans.x), \n                                      abs(primitives[i].transform.trans.y)), \n                                      abs(primitives[i].transform.trans.z));\n            curNor.w = maxOffset;\n        \tt = squarePlane(pos, curNor);\n        }\n        else if(primitives[i].primitiveId == CUBE)\n        {\n        \tt = cube(pos, primitives[i].transform);\n        }\n        else if(primitives[i].primitiveId == SPHERE)\n        {\n        \tt = sphere(pos, primitives[i].transform);\n        }\n        \n       \n        \n        if(t < minT)\n        {\n        \tminT = t;\n            obj = i;\n        }\n    }\n   \n    t = minT;\n}\n\nfloat sceneMap3D(vec3 pos)\n{\n    float minT = 10000.0;\n    float t = minT;\n    for(int i = 0; i < primitives.length(); i++)\n    {\n        if(primitives[i].primitiveId == SQUARE_PLANE)\n        {\n        \tvec4 curNor = normalize(rotMat(primitives[i].transform) * vec4(0.0, 0.0, 1.0, 0.0));\n            float maxOffset = max(max(abs(primitives[i].transform.trans.x), \n                                      abs(primitives[i].transform.trans.y)), \n                                      abs(primitives[i].transform.trans.z));\n            curNor.w = maxOffset;\n        \tt = squarePlane(pos, curNor);\n        }\n        else if(primitives[i].primitiveId == CUBE)\n        {\n        \tt = cube(pos, primitives[i].transform);\n        }\n        \n       \n        if(t < minT)\n        {\n        \tminT = t;\n        }\n    }\n    t = minT;\n    return t;\n}\n\n\nfloat fiveTapAO(vec3 p, vec3 n, float k) {\n    float aoSum = 0.0;\n    for(float i = 0.0; i < 5.0; ++i) {\n        float coeff = 1.0 / pow(2.0, i);\n        aoSum += coeff * (i * AO_DIST - sceneMap3D(p + n * i * AO_DIST));\n    }\n    return 1.0 - k * aoSum;\n}\n\nvec3 computeNormal(vec3 pos) {\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( sceneMap3D(pos + epsilon.yxx) - sceneMap3D(pos - epsilon.yxx),\n                            sceneMap3D(pos + epsilon.xyx) - sceneMap3D(pos - epsilon.xyx),\n                            sceneMap3D(pos + epsilon.xxy) - sceneMap3D(pos - epsilon.xxy)));\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj) {\n    t = 0.001;\n    for(int i = 0; i < RAY_STEPS; ++i) {\n        vec3 pos = origin + t * dir;\n    \tfloat m;\n        sceneMap3D(pos, m, hitObj);\n        if(abs(m) < 0.01) \n        {\n            return;\n        }\n        \n        t += m;\n    }\n    t = -1.0;\n    hitObj = -1;\n}\n\nconst vec3 a = vec3(0.5, 0.5, 0.5);\nconst vec3 b = vec3(0.5, 0.5, 0.5);\nconst vec3 c = vec3(2.0, 1.0, 1.0);\nconst vec3 d = vec3(0.5, 0.2, 0.25);\n\nvec3 colorPalette(float t) {\n    return a + b * cos(6.28 * (t * c + d));\n}\n\nvec3 computeMaterial(int hitObj, vec3 p, vec3 n, vec3 lightVec, vec3 view) {\n    float lambert = max(0.0, dot(lightVec, n));\n    if(hitObj == -1)\n        return vec3(0.0, 0.0, 0.0);\n    if(hitObj == 3)\n    {\n    \t// Back Wall\n        vec2 worleyPoint = vec2(inverse(transformMatrix(primitives[hitObj].transform)) * vec4(p, 1.0));\n        float worley = WorleyNoise2D(worleyPoint);\n        vec3 worleyColor = colorPalette(worley);\n        vec3 color = primitives[hitObj].matColor * lambert * worleyColor;\n        return color;\n    }\n    \n    if(hitObj == 5)\n    {\n        p = vec3(inverse(transformMatrix(primitives[hitObj].transform)) * vec4(p, 1.0));\n    \tfloat cubePerlin = PerlinNoise3D(p);\n        vec3 perlinColor = colorPalette(cubePerlin + iTime);\n       \tvec3 color = primitives[hitObj].matColor * lambert * perlinColor;\n    \treturn color;\n    }\n    \n    if(hitObj == 6)\n    {\n    \tlambert = max(0.0, dot(lightVec, -n));\n        float sphereFBM = fbm2D(vec2(p + iTime));\n        vec3 fbmColor = colorPalette(sphereFBM + iTime);\n        vec3 color = primitives[hitObj].matColor * lambert * fbmColor;\n    \treturn color;\n    }\n    vec3 color = primitives[hitObj].matColor * lambert * vec3(1.0, 1.0, 1.0);\n    return color;\n    \n}\n\n\nIntersection sdf3D(vec3 dir, vec3 eye) {\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj);\n\n    vec3 isect = eye + t * dir;\n    vec3 nor = computeNormal(isect);\n    \n    isect = isect + 0.01 * nor;\n    //vec3 lightDir = normalize(lightPos - isect);\n    \n    vec3 lightDir = normalize(pointLight.transform.trans - isect);\n    \n    vec3 surfaceColor = computeMaterial(hitObj, isect, nor, lightDir, normalize(eye - isect));\n    \n    vec3 normalAsColor = 0.5 * (nor + vec3(1.0, 1.0, 1.0));\n    \n    return Intersection(t, surfaceColor, isect, hitObj);\n}\n\n\nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\n// Returns direction of ray\nvec3 rayCast(vec3 eye, vec3 ref, vec2 ndc) {\n    vec3 F = ref - eye;\n    vec3 R = normalize(cross(F, vec3(0,1,0)));\n    vec3 U = normalize(cross(R, F)); \n    \n    vec3 V = U * length(F) * tan(FOVY * 0.5);\n    vec3 H = R * length(F) * tan(FOVY * 0.5) * float(iResolution.x) / iResolution.y;\n    \n    vec3 p = ref + ndc.x * H + ndc.y * V;\n    \n    return normalize(p - eye);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initializeCornelBox();\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    // Convert to range [-1, 1]\n    uv = uv * 2.0 - vec2(1.0, 1.0);\n    \n    vec3 eye = vec3(0, 4, -15);\n    vec3 ref = vec3(0, 2, 0);\n    \n    vec3 rayDir = rayCast(eye, ref, uv);\n    \n    Intersection isect = sdf3D(rayDir, eye);\n    \n    float focalLength = (sin(iTime) *  FOCAL_RANGE +  FOCAL_RANGE) / 2.0;\n\t\n    vec3 focalLine = isect.p - eye;\n    float distance = length(focalLine);\n    float disAlongCamZ = dot(focalLine, normalize(ref - eye));\n    float t = abs(disAlongCamZ - focalLength) / FOCAL_RANGE;\n    \n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    //fragColor = vec4(0.5 * (rayDir + vec3(1., 1., 1.)), 1.0);\n    fragColor = vec4(isect.color, t);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dByDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[883, 883, 911, 953, 3172], [3176, 3176, 3201, 3201, 3372], [3374, 3374, 3397, 3397, 3503], [3505, 3505, 3527, 3527, 3674], [3676, 3676, 3700, 3700, 3919], [3921, 3921, 3942, 3942, 4648], [4650, 4650, 4683, 4683, 4750], [4752, 4752, 4791, 4935, 5569], [5571, 5571, 5602, 5602, 5907], [5910, 5910, 5939, 5961, 6934], [6936, 6936, 6965, 6987, 7961], [7963, 7963, 8024, 8024, 8248], [8250, 8250, 8291, 8291, 8629], [8631, 8631, 8672, 8672, 9010], [9022, 9022, 9057, 9057, 10481], [10483, 10483, 10509, 10509, 11369], [11371, 11371, 11402, 11402, 11519], [11521, 11540, 11579, 11579, 11685], [11687, 11699, 11740, 11740, 11895], [11897, 11916, 11966, 11966, 12170], [12172, 12172, 12209, 12235, 12267], [12270, 12270, 12317, 12317, 12559], [12562, 12562, 12615, 12615, 13569], [13571, 13571, 13599, 13599, 14406], [14409, 14409, 14451, 14451, 14664], [14666, 14666, 14696, 14696, 15015], [15017, 15017, 15081, 15081, 15355], [15503, 15503, 15531, 15531, 15577], [15579, 15579, 15655, 15655, 16813], [16816, 16816, 16856, 16856, 17376], [17379, 17379, 17410, 17410, 17493], [17495, 17523, 17567, 17567, 17897], [17899, 17899, 17956, 17956, 18811]], "test": "error"}
{"id": "3dfBDN", "name": "journey around mandelbrot set", "author": "matthen", "description": "a journey around the mandelbrot set, with corresponding julia set", "tags": ["fractal", "julia", "mandelbrot"], "likes": 3, "viewed": 264, "published": "Public", "date": "1588232511", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// based on https://www.shadertoy.com/view/tsBcDc\n\n#define ITER 256\n\n\nconst float zoomWidth = 0.05;\nconst vec4 boxCol = vec4(0.99, 0.99, 0.99, 1.0);\n\nvec3 gradient(in float r) {\t\n    r /= 20.;\n    r = pow(r, 0.2);\n    vec3 rainbow = 0.5 + 0.5 * cos((5.5 * r + vec3(0.2, 0.45, 0.8)*6.));\n    \n    return rainbow;\n}\n\n\nvec2 uv2coord(vec2 uv) {\n    vec2 coord = 4.0 * uv - 2.0;\n    return vec2((mod(coord.x, 2.0) - 1.0) * iResolution.x/iResolution.y - 0.5, coord.y);\n}\n\nvec4 fractal(vec2 z, vec2 c) {\n    for (int i = 0; i < ITER; ++i) {\n        z = vec2(\n            z.x*z.x - z.y*z.y + c.x,\n            2.0 * z.x*z.y + c.y\n        );\n\n        float distSqr = dot(z, z);\n        \n        if (distSqr > 16.0)\n            return vec4(gradient(float(i) + 1.0 - log2(log(distSqr) / 2.0)), 1.);\n    }\n    \n    return vec4(0.0, 0.0, 0.0, 1.0);\n}\n\nvec2 centre(in float t) {\n     //r = (1 - cos(theta))/2, x = r*cos(theta)+0.25, y = r*sin(theta)\n//* the boundary of the period 2 disk: r = 0.25, x = r*cos(theta)-1, y = r*sin(theta)\n    if (t < 1.) {\n\t    return vec2(-2. + 0.75 * smoothstep(0., 1., t), 0.);\n    } else if (t < 3.) {\n        t = 3.141593 * smoothstep(1., 3., t);\n    \treturn vec2(-0.25 * cos(t) - 1., 0.25 * sin(t));\n    } else if (t < 7.) {\n     \tt = 3.141593 * smoothstep(3., 7., t);\n        vec2 c = vec2(-cos(t), -sin(t));\n        c *= (1. + cos(t)) / 2.;\n        c.x += 0.2499;\n        return c;\n    } else {\n        t = smoothstep(7., 10., t);\n    \treturn vec2(0.25 - 2.25 * t, sin(6.281 * t)/ (1. + 2. * t));   \n        \n    }\n    \n    \n    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    float ar = iResolution.y / iResolution.x;\n    vec2 coord = uv2coord(uv);\n    \n    float t = mod(iTime * 0.25, 10.);\n    \n    vec2 c = centre(t);\n    //vec2 c = uv2coord(iMouse.xy/iResolution.xy);\n    \n    \n    vec2 box = vec2(0.17, 0.17);\n    float boxWidth = 0.32;\n    \n    float boxDist = max(abs(uv.x - box.x), abs(uv.y - box.y))\n        -boxWidth / 2.;\n    \n    if (boxDist < 0.0) {\n       coord -= uv2coord(box);\n       coord *= zoomWidth * 2.;\n       coord += c;\n        \n       fragColor = fractal(vec2(0.0, 0.0), coord);\n       \n       fragColor = mix(\n           boxCol,\n           fragColor,\n           smoothstep(0., 0.005, abs(boxDist)));\n       \n        \n    } else if (uv.x < 0.5) {\n        // Mandelbrot\n        coord += vec2(-0.3, -0.4);\n        fragColor = fractal(vec2(0.0, 0.0), coord);\n        fragColor = mix(\n            boxCol,\n            fragColor,\n        \tsmoothstep(\n                0., \n                0.015,\n                abs(max(ar * abs(coord.x - c.x), abs(coord.y - c.y))-zoomWidth)\n                )\n        );\n    }\n    else {\n        // Julia\n        fragColor = fractal(coord + vec2(0.5, 0.0), c);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dfBDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[150, 150, 177, 177, 313], [316, 316, 340, 340, 464], [466, 466, 496, 496, 836], [838, 838, 863, 1020, 1555], [1557, 1557, 1612, 1612, 2804]], "test": "valid"}
{"id": "3dfBW8", "name": "viper mushroom", "author": "elmtili", "description": "my code 100%", "tags": ["elmtili"], "likes": 1, "viewed": 74, "published": "Public", "date": "1588091948", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (15.0+sin(iTime)*8.0) * (fragCoord - iResolution.xy / (2.0)) / min(iResolution.y, iResolution.x);\n    \n    float lar;\n\n    for (float i=0.0; i < 6.0; i++)\n    {\n        lar = length(vec2(uv.x, uv.y));\n\t\tfloat uvx1= uv.x;\n        uv.x = - uv.y + sin(uv.x)*(uv.x);\n        uv.y = - uvx1 + sin(uv.y)*(uv.y);\n    }\n    // Output to screen\n    fragColor = vec4(cos(lar * 2.0), cos(lar * 3.0), cos(lar * 1.0), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dfBW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 59, 109, 535]], "test": "valid"}
{"id": "3dfBzr", "name": "cis 561 hw09 Penumbra Shadows ", "author": "sireesha98", "description": "Hard and soft shadows with various primitives ", "tags": ["hw"], "likes": 0, "viewed": 96, "published": "Public", "date": "1587613989", "time_retrieved": "2021-10-01T00:00:00", "image_code": "///---------------///\n/// All Constants ///\n///---------------///\nconst vec3 lightPos = vec3(0., 7.1, 0.);\n\nconst float FOVY = 3.141569 * 0.25;\nconst int RAY_STEPS = 256;\nconst float HALF_PI = 3.14159 * 0.5;\n\nconst float FOCAL_LENGTH = 20.;\nconst float FOCAL_RANGE = 16.0;\nconst int AO_SAMPLES = 256;\nconst float AO_DIST = 0.15;\nconst float FIVETAP_K = 2.0;\n\n\n#define ANTIALIASING 1\n#define DOF; //No DOF in this project \n//#define NO_DOF; //Don't forget to comment BLUR in Image \n\n// The higher the value, the smaller the penumbra\nconst float SHADOW_HARDNESS = 6.0;\n\n// 0 for penumbra shadows, 1 for hard shadows\n#define HARD_SHADOW 0\n\n\n#define PI 3.14159265359\n\n//Set Color palatte :\n//http://www.iquilezles.org/www/articles/palettes/palettes.htm\n\nconst vec3 a = vec3(0.5, 0.5, 0.5);\nconst vec3 b = vec3(0.5, 0.5, 0.5);\nconst vec3 c = vec3(2.0, 1.0, 1.0);\nconst vec3 d = vec3(0.5, 0.2, 0.25);\n\nvec3 colorPalette(float t) \n{\n    return a + b * cos(6.28 * (t * c + d));\n}\n\n///------------///\n/// Structures ///\n///------------///\n\nstruct Intersection {\n    float t;\n    vec3 color;\n    vec3 p;\n    int object; // Assign every object in our scene a unique ID int\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir; \n    \n};\n  \n///--------------------///\n/// Local Space Matrix ///\n///--------------------///\n    \n// Returns the inverse trasnformation matrix for the given t,r and s components \nmat4 inverseTransform(vec3 scale, vec3 rDeg, vec3 trans) {\n    \n    // convert from degrees to radians\n    vec3 rotate = vec3(radians(rDeg.x), radians(rDeg.y), radians(rDeg.z));\n    \n    mat4 r_x;\n    r_x[0] = vec4(1., 0., 0., 0.);\n    r_x[1] = vec4(0., cos(rotate.x), sin(rotate.x), 0.);\n    r_x[2] = vec4(0., -sin(rotate.x), cos(rotate.x), 0.);\n    r_x[3] = vec4(0., 0., 0., 1.);\n                                    \n                                    \n    mat4 r_y;\n    r_y[0] = vec4(cos(rotate.y), 0., -sin(rotate.y), 0.);\n    r_y[1] = vec4(0., 1, 0., 0.);\n    r_y[2] = vec4(sin(rotate.y), 0., cos(rotate.y), 0.);\n    r_y[3] = vec4(0., 0., 0., 1.);\n\n    mat4 r_z;\n    r_z[0] = vec4(cos(rotate.z), sin(rotate.z), 0., 0.);\n    r_z[1] = vec4(-sin(rotate.z), cos(rotate.z), 0., 0.);\n    r_z[2] = vec4(0., 0., 1., 0.);\n    r_z[3] = vec4(0., 0., 0., 1.);\n\n    mat4 r = r_x * r_y * r_z;\n    \n    // creating worldTransform matrix\n    mat4 t;\n    t[0] = vec4(1., 0., 0., 0.);\n    t[1] = vec4(0., 1., 0., 0.);\n    t[2] = vec4(0., 0., 1., 0.);\n    t[3] = vec4(trans.x, trans.y, trans.z, 1.);\n    \n    mat4 s;\n    s[0] = vec4(scale.x, 0., 0., 0.);\n    s[1] = vec4(0., scale.y, 0., 0.);\n    s[2] = vec4(0., 0., scale.z, 0.);\n    s[3] = vec4(0., 0., 0., 1.);\n\n    mat4 worldTrans = t * r * s;\n    \n    return inverse(worldTrans);\n}\n\n///--------------------///\n/// Rotation Functions ///\n///--------------------///\n\nvec3 rotateX(in vec3 p, float a) {\n\tfloat c = cos(a); float s = sin(a);\n\treturn vec3(p.x, c * p.y - s * p.z, s * p.y + c * p.z);\n}\n\nvec3 rotateY(vec3 p, float a) {\n\tfloat c = cos(a); float s = sin(a);\n\treturn vec3(c * p.x + s * p.z, p.y, -s * p.x + c * p.z);\n}\n\nvec3 rotateZ(vec3 p, float a) {\n\tfloat c = cos(a); float s = sin(a);\n\treturn vec3(c * p.x - s * p.y, s * p.x + c * p.y, p.z);\n}\n\n///-----------------///\n/// Noise Functions /// \n///-----------------///\n\nfloat random1( vec3 p ) {\n    return fract(sin((dot(p, vec3(127.1,\n                                  311.7,\n                                  191.999)))) *         \n                 43758.5453);\n}\n\nvec2 random2(vec3 p) {\n    return fract(sin(vec2(p.x, p.x + 1.0)) * vec2(43758.5453123, 22578.1459123));\n}\n\n\nvec3 random3( vec3 p ) {\n    return fract(sin(vec3(dot(p,vec3(127.1, 311.7, 191.999)),\n                          dot(p,vec3(269.5, 183.3, 765.54)),\n                          dot(p, vec3(420.69, 631.2,109.21))))\n                 *43758.5453);\n}\n\n//3D Worley Noise \nfloat WorleyNoise3D(vec3 p) {\n    // Tile the space\n    vec3 pointInt = floor(p);\n    vec3 pointFract = fract(p);\n\n    float minDist = 1.0; // Minimum distance initialized to max.\n\n    // Search all neighboring cells and this cell for their point\n    for(int z = -1; z <= 1; z++)\n    {\n        for(int y = -1; y <= 1; y++)\n        {\n            for(int x = -1; x <= 1; x++)\n            {\n                vec3 neighbor = vec3(float(x), float(y), float(z));\n\n                // Random point inside current neighboring cell\n                vec3 point = random3(pointInt + neighbor);\n\n                // Animate the point\n                point = 0.5 + 0.5 * sin(iTime * 0.01 + 6.2831 * point); // 0 to 1 range\n\n                // Compute the distance b/t the point and the fragment\n                // Store the min dist thus far\n                vec3 diff = neighbor + point - pointFract;\n                float dist = length(diff);\n                minDist = min(minDist, dist);\n            }\n        }\n    }\n    return minDist;\n}\n\n///---------------------///\n/// Coordinate Systems  ///\n///---------------------///\n\n// Returns a Coorinate system given one of the vectors \nvoid CoordinateSystem(in vec3 v1, out vec3 v2, out vec3 v3) {\n    if (abs(v1.x) > abs(v1.y))\n            v2 = vec3(-v1.z, 0.0, v1.x) / sqrt(v1.x * v1.x + v1.z * v1.z);\n        else\n            v2 = vec3(0.0, v1.z, -v1.y) / sqrt(v1.y * v1.y + v1.z * v1.z);\n        v3 = cross(v1, v2);\n}\n\nvec3 WorleyTangentSpaceNormal(vec3 pos) {\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( WorleyNoise3D(pos + epsilon.yxx) - WorleyNoise3D(pos - epsilon.yxx),\n                            WorleyNoise3D(pos + epsilon.xyx) - WorleyNoise3D(pos - epsilon.xyx),\n                            WorleyNoise3D(pos + epsilon.xxy) - WorleyNoise3D(pos - epsilon.xxy)));\n\n}\n\nmat3 TangentToWorld(vec3 nor) {\n\tvec3 tangent, bitangent;\n    CoordinateSystem(nor, tangent, bitangent);\n    return mat3(tangent, bitangent, nor);\n}\n\n///----------///\n/// ALL SDFs ///\n///----------///\n    \n// SDF of a sphere - done\nfloat sphere(vec3 p, float r, vec3 c) {\n    return distance(p, c) - r;\n}\n\n\nfloat plane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\t\n\n//SDF of a Cube - done\nfloat cube(vec3 p, vec3 s, vec3 r, vec3 t) \n{\n    //Local space of the cube \n    mat4 inverseTrans = inverseTransform(s, r, t);\n    vec4 tempP = inverseTrans * vec4(p, 1.f);\n    p = vec3(tempP.x, tempP.y, tempP.z);\n    \n    vec3 q = abs(p) - vec3(0.5, 0.5, 0.5);\n  \treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat box(vec3 p, vec3 b)\n{\n  return length(max(abs(p) - b, 0.0));\n}\n\n//done \n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x;\n    float d2 = abs(p.z)-h.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n//to do\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    float m = p.x + p.y + p.z - s;\n\n    // exact distance\n    #if 0\n    vec3 o = min(3.0*p - m, 0.0);\n    o = max(6.0*p - m*2.0 - o*3.0 + (o.x+o.y+o.z), 0.0);\n    return length(p - s*o/(o.x+o.y+o.z));\n    #endif\n    \n    // exact distance\n    #if 1\n \tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n    #endif\n    \n    // bound, not exact\n    #if 0\n\treturn m*0.57735027;\n    #endif\n}\n\nfloat sdPyramid( in vec3 p, in float h )\n{\n    float m2 = h*h + 0.25;\n    \n    // symmetry\n    p.xz = abs(p.xz);\n    p.xz = (p.z>p.x) ? p.zx : p.xz;\n    p.xz -= 0.5;\n\t\n    // project into face plane (2D)\n    vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n\tfloat b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n    // recover 3D and scale, and add sign\n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));;\n}\n///--------------------------///\n/// Scene SDFs and their IDs ///\n///--------------------------///\n\nfloat opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1.x : d2.x;\n}\n\n#define SPHERE_SDF sphere(pos, 2.0, vec3(0.0, 0.0, 6.0))\n#define CUBE_SDF cube(pos, vec3(3., 4., 3.), vec3(0., 0., 0.), vec3(-5., 0., 8.))\n#define TRI_PRISM_SDF sdTriPrism( pos-vec3(-5.0, 3., 8.0), vec2(2.25,2.05) )\n#define TORUS_SDF sdTorus(pos-vec3( 4.5,0.25, 4.0), vec2(1.60, .5))\n#define OCTA_SDF sdOctahedron( pos-vec3(8., 0., 2.), 2.35 )\n\n///-----------------///\n/// Scene Functions ///\n///-----------------///\n\nvoid sceneMap3D(vec3 pos, out float t, out int obj) {\n    t = SPHERE_SDF;\n    vec2 res = vec2( 1e10, 0.0 );\n    float t2;\n    obj = 0; // 0 is center sphere\n    if((t2 = TRI_PRISM_SDF ) < t) {\n        t = t2;\n        obj = 1;\n    }\n    if((t2 = CUBE_SDF) < t) {\n        t = t2;\n        obj = 2;\n    }\n    if((t2 = TORUS_SDF) < t) {\n        t = t2;\n        obj = 4;\n    }\n   if((t2 = OCTA_SDF) < t) {\n        t = t2;\n        obj = 5;\n    }\n    if((t2 = box(pos + vec3(0.0, 3.0, 0.0), vec3(50.0, 1.0, 50.0))) < t) {\n        t = t2;\n        obj = 3;\n    }\n}\n\n\nfloat sceneMap3D(vec3 pos) {\n    float t = SPHERE_SDF;\n    t = min(t, TRI_PRISM_SDF);\n    t = min(t, CUBE_SDF);\n    t = min(t, TORUS_SDF);\n    t = min(t, OCTA_SDF);\n    t = min(t, box(pos + vec3(0.0, 3.0, 0.0), vec3(50.0, 1.0, 50.0)));\n    return t;\n}\n\nvec3 computeNormal(vec3 pos) {\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( sceneMap3D(pos + epsilon.yxx) - sceneMap3D(pos - epsilon.yxx),\n                            sceneMap3D(pos + epsilon.xyx) - sceneMap3D(pos - epsilon.xyx),\n                            sceneMap3D(pos + epsilon.xxy) - sceneMap3D(pos - epsilon.xxy)));\n}\n\nvoid rayMarch(vec3 origin, vec3 dir, out float t, out int hitObj) {\n    t = 0.001;\n    for(int i = 0; i < RAY_STEPS; ++i) {\n        vec3 pos = origin + t * dir;\n    \tfloat m;\n        sceneMap3D(pos, m, hitObj);\n        if(m < 0.01) {\n            return;\n        }\n        t += m;\n    }\n    t = -1.0;\n    hitObj = -1;\n}\n\n\nvec3 computeMaterial(int hitObj, vec3 p, vec3 n, vec3 lightDir, vec3 viewVec) \n{\n    float t;\n    switch(hitObj) {\n        case 0:\n        // Sphere\n        return vec3(1.0, 0.67, 0.67);\n        break;\n        case 1:\n        // TriPrism\n        return vec3(0.67, 1.0, 0.67);\n        break;\n        case 2:\n        // Cube\n        return vec3(0.67, 0.67, 1.0);\n        break;\n        case 3:\n        // Floor\n        t = floor(mod(0.5 * (sin(p.x) + sin(p.z)), 3.0));\n        return mix(vec3(0.1), vec3(0.5), t);\n        break;\n        //Torus \n        case 4: \n        return vec3(0.37, 0.67, 0.5);\n        //Octa \n        case 5: \n        return vec3(0.7, 0.07, 0.2);\n        case -1:\n        // Background\n        return vec3(0.99, 0.88, 0.69);\n        break;\n    }\n    return vec3(0.99, 0.88, 0.69);\n}\n\n///------------------SHADOWS----------------------///\n\nfloat hardShadow(vec3 dir, vec3 origin, float min_t) {\n    float t = min_t;\n    for(int i = 0; i < RAY_STEPS; ++i) {\n        float m = sceneMap3D(origin + t * dir);\n        if(m < 0.0001) {\n            return 0.0;\n        }\n        t += m;\n    }\n    return 1.0;\n}\n\nfloat softShadow(vec3 dir, vec3 origin, float min_t, float k) {\n    float res = 1.0;\n    float t = min_t;\n    for(int i = 0; i < RAY_STEPS; ++i) {\n        float m = sceneMap3D(origin + t * dir);\n        if(m < 0.0001) {\n            return 0.0;\n        }\n        res = min(res, k * m / t);\n        t += m;\n    }\n    return res;\n}\n\nfloat shadow(vec3 dir, vec3 origin, float min_t) {\n    #if HARD_SHADOW\n    return hardShadow(dir, origin, min_t);\n    #else\n    return softShadow(dir, origin, min_t, SHADOW_HARDNESS);\n    #endif\n}\n\n//Takes a ray in the scene and returns an intersection \nIntersection sceneIntersection(Ray ray) \n{\n    //To be set \n    float t;\n    int hitObj;\n    \n    //RayMarch will set t and object hit by raymarching using SDFs \n    rayMarch(ray.origin, ray.dir, t, hitObj);\n\n    //Intersection point in our scene \n    vec3 isect_point = ray.origin + t * ray.dir;\n    \n    //Normal at POI  \n    vec3 nor = computeNormal(isect_point);\n    vec3 lightDir = normalize(lightPos - isect_point);\n    \n    //Compute Material returns color at the POI \n    vec3 material = computeMaterial(hitObj, isect_point, nor, lightDir, \n                                        normalize(ray.origin - isect_point));\n    \n    vec3 warmDir = rotateY(normalize(vec3(1.0, 1.0, 1.0)), sin(iTime * 0.5));\n    vec3 coolDir = rotateY(normalize(vec3(-1.0, 0.0, -1.0)), sin(iTime * 0.5));\n\n    float warmDot = max(0.0, dot(nor, warmDir));\n    float coolDot = max(0.0, dot(nor, coolDir));\n\n    vec3 overallColor = warmDot * vec3(1.0, 0.88, 0.7) * shadow(warmDir, isect_point, 0.1);\n    overallColor += coolDot * vec3(0.05, 0.2, 0.5);\n    overallColor *= material;\n    overallColor = clamp(overallColor + vec3(0.05, 0.1, 0.15), 0.0, 1.0);\n    \n    vec3 sdfColor = overallColor;\n \n    return Intersection(t, sdfColor, isect_point, hitObj);\n}\n\n// Returns direction of ray\nRay rayCast(vec3 eye, vec3 ref, vec2 ndc) \n{\n    vec3 F = ref - eye;\n    vec3 R = normalize(cross(F, vec3(0,1,0)));\n    vec3 U = normalize(cross(R, F));\n    \n    vec3 V = U * length(F) * tan(FOVY * 0.5);\n    vec3 H = R * length(F) * tan(FOVY * 0.5) * float(iResolution.x) / iResolution.y;\n    \n    vec3 p = ref + ndc.x * H + ndc.y * V;\n    \n    return Ray(eye, normalize(p - eye));\n}\n\n///---------------///\n/// Main Function ///\n///---------------///\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    //Anti aliasing    \n    if(ANTIALIASING == 1)\n    {  \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // [-1, 1]\n    vec2 uv2 = 2.0 * uv - vec2(1.0);\n    \n    Intersection aaIsects[4];\n    //Camera's eye and reference points \n\n    vec3 eye = vec3(-4, 9., -15.);\n    vec3 ref = vec3(0, 3.5, 0);\n    int idx = 0;\n    for(float i = 0.0; i < 1.0; i += 0.5) {\n        for(float j = 0.0; j < 1.0; j += 0.5) {\n            vec2 ndc = uv2 + vec2(i, j) / iResolution.xy;\n            Ray ray = rayCast(eye, ref, ndc);\n            aaIsects[idx++] = sceneIntersection(ray);\n        }\n    }\n        \n    vec3 avgColor = vec3(0.0);\n    for(int i = 0; i < 4; ++i) {\n        avgColor += aaIsects[i].color;\n    }\n        \n    avgColor *= 0.25;\n    \n    #ifdef DOF\n    float distAlongCamZ = abs(dot(normalize(ref - eye), (aaIsects[0].p - eye)));\n    float dofZ = min(1.0, abs(distAlongCamZ - FOCAL_LENGTH) / FOCAL_RANGE);\n    dofZ = pow(dofZ, 0.5);\n\n    fragColor = vec4(avgColor * step(0.0, aaIsects[0].t), dofZ);\n    float fogT = smoothstep(50.0, 100.0, distance(aaIsects[0].p, eye));\n    fragColor.rgb = mix(fragColor.rgb, vec3(0.0), fogT);\n    #endif \n    \n   #ifdef NO_DOF \n        fragColor = vec4(avgColor.rgb, 1.);\n    #endif\n    \n    }\n    else //No Anti aliasing\n    {\n        // Normalized pixel coordinates (from 0 to 1)\n        vec2 uv = fragCoord / iResolution.xy;\n        // Convert to range [-1, 1]\n        uv = uv * 2.0 - vec2(1.0, 1.0);\n\n        //Camera's eye and reference points \n        vec3 eye = vec3(0, 3.5, -15.);\n        vec3 ref = vec3(0, 2.5, 0);\n        \n\n        //Ray cast returns a ray in the camera's direction to the reference point \n        Ray ray = rayCast(eye, ref, uv);\n\n        //Scene Intersection \n        Intersection isect = sceneIntersection(ray);\n        vec3 avgColor = isect.color;\n    \n        #ifdef DOF\n            float distAlongCamZ = abs(dot(normalize(ref - eye), (isect.p - eye)));\n            float dofZ = min(1.0, abs(distAlongCamZ - FOCAL_LENGTH) / FOCAL_RANGE);\n            dofZ = pow(dofZ, 0.5);\n            fragColor = vec4(avgColor * step(0.0, isect.t), dofZ);\n            float fogT = smoothstep(50.0, 100.0, distance(isect.p , eye));\n            fragColor.rgb = mix(fragColor.rgb, vec3(0.0), fogT);\n        #endif \n\n       #ifdef NO_DOF \n            fragColor = vec4(avgColor.rgb, 1.);\n        #endif\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dfBzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[896, 896, 925, 925, 971], [1308, 1389, 1447, 1491, 2712], [2796, 2796, 2830, 2830, 2926], [2928, 2928, 2959, 2959, 3056], [3058, 3058, 3089, 3089, 3185], [3261, 3261, 3286, 3286, 3457], [3459, 3459, 3481, 3481, 3565], [3568, 3568, 3592, 3592, 3811], [3813, 3832, 3861, 3883, 4856], [4943, 4999, 5060, 5060, 5284], [5286, 5286, 5327, 5327, 5665], [5667, 5667, 5698, 5698, 5815], [5873, 5899, 5938, 5938, 5971], [5974, 5974, 6005, 6031, 6062], [6065, 6088, 6133, 6164, 6415], [6417, 6417, 6444, 6444, 6485], [6496, 6496, 6532, 6532, 6882], [6893, 6893, 6926, 6926, 6981], [6983, 6983, 7019, 7019, 7330], [7332, 7332, 7396, 7396, 7674], [7676, 7676, 7713, 7713, 8307], [8309, 8309, 8351, 8351, 8951], [9052, 9052, 9083, 9083, 9120], [9540, 9540, 9593, 9593, 10094], [10097, 10097, 10125, 10125, 10348], [10350, 10350, 10380, 10380, 10699], [10701, 10701, 10768, 10768, 11019], [11022, 11022, 11102, 11102, 11826], [11883, 11883, 11937, 11937, 12146], [12148, 12148, 12211, 12211, 12476], [12478, 12478, 12528, 12528, 12674], [12676, 12732, 12774, 12791, 13971], [13973, 14001, 14045, 14045, 14384], [14453, 14453, 14510, 14538, 16919]], "test": "error"}
{"id": "3dffz4", "name": "[TWITCH] Potichat", "author": "Flopine", "description": "A retake on my shader for the Semifinals of Revision 2020! I made it on Twitch and you can see the replay here: \nhttps://www.twitch.tv/flopine/videos", "tags": ["raymarching", "cute", "cat", "hearts", "npr"], "likes": 14, "viewed": 228, "published": "Public", "date": "1587734893", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n#define time iTime\n#define PI 3.141592\n#define anim(t) (abs(sin(t))*0.3-1.2);\n\nmat2 rot (float a)\n{return mat2 (cos(a),sin(a),-sin(a),cos(a));}\n\nfloat hash21(vec2 x)\n{return fract(sin(dot(x,vec2(12.1,23.4)))*1245.5);}\n\nfloat hash11(float x)\n{return fract(sin(x)*124.4);}\n\nfloat vcaps( vec3 p, float h, float r )\n{\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\n\n// french for jar\nfloat pot (vec3 p)\n{\n    float radius = (p.y>0.7) ? 0.6: 0.5+sin((p.y+0.8)*2.)*0.3;\n    return max(p.y-.9,abs(max(length(p.xz)-radius, abs(p.y)-1.))-0.05);\n}\n\nfloat yeux;\nfloat g1 = 0.;\n// french for cat\nfloat chat (vec3 p)\n{ \n    p.y -= 1.1;\n    float sy = anim((time+p.y*0.07)*6.);\n    float sxz = 1./sy;\n    vec3 psize = vec3(sxz,sy,sxz);\n    p *= -psize;\n\n    vec3 pp = p;\n    float sphe = length(p)-.5;\n\n    p = pp;\n    p.z += 0.45;\n    p.y -= 0.2;\n    p.x = abs(p.x)-0.15;  \n    // french for eyes\n    yeux = length(p)-0.05;  \n    g1 += 0.01/(0.01+yeux*yeux);\n\n    p = pp;\n    p.y -= 0.35;\n    p.z += 0.2;\n    p.x = abs(p.x)-0.3;  \n    p.xy *= rot(-PI/4.);\n    float or =  max(-(p.z-0.04),abs(max(-p.y,dot(p,normalize(sign(p)))-0.12))-0.002);\n\n    return min(sphe, min(yeux,or));\n}\n\n// french for paws\nfloat pattes (vec3 p)\n{  \n    p.z += 0.7;\n    p.y -= 0.8;\n    p.x = abs(p.x)-0.2;\n    return vcaps(p,0.15, 0.08);\n}\n\nfloat papat, chacha, popo;\nfloat idchat;\nfloat SDF (vec3 p)\n{\n    \n    float per = 4.;\n    float dt = time*0.5;\n    p.x += per*(floor(dt)+pow(fract(dt),12.));\n    idchat = floor((p.x-per*0.5)/per);\n    p.x = mod(p.x-per*0.5, per)-per*0.5;\n\n    papat = pattes(p);\n    chacha = chat(p);\n    popo = pot(p);\n    return min(min(papat,chacha),popo);\n}\n\nvec3 palette (float t, vec3 c, vec3 d)\n{return vec3(0.5)+vec3(0.5)*cos(2.*PI*(c*t+d));}\n\nvec3 text_pot (vec2 uv, float detail, float cid)\n{\n    uv.y *= detail;\n    float id = floor(uv.y);\n    vec3 col1 = vec3(1.,.9,hash11(idchat*0.1));\n    vec3 col2 = palette(id, vec3(0.1), vec3(cid*0.1,cid*0.8,cid*0.5));\n    return clamp((abs(uv.y) > 10.) ? col1 : col2,0.,1.);\n}\n\nfloat background(vec2 uv)\n{\n    uv *= 5.;\n    vec2 id = floor(uv);\n    uv = fract(uv)-0.5;\n    uv.x = abs(uv.x);\n    uv *= rot(PI/4.);\n    float r = 0.03+sin(length(id*2.)-time)*0.05+0.08;\n    return smoothstep(r,r*1.1, length(uv*vec2(0.5,1.)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    float dither = hash21(uv);\n\n    vec3 ro = vec3(0.01,1.6,-4.),\n        rd = normalize(vec3(uv+vec2(0.,-0.3),1.)),\n        p = ro,\n        col = clamp(mix(vec3(1.,0.,0.),vec3(0.95),background(uv)),0.,1.);\n\n    float shad,d;\n    bool hit = false;\n\n    for (float i=0.; i<64.; i++)\n    {\n        d = SDF(p);\n        if (d<0.01)\n        {\n            hit = true;\n            shad = i/64.;\n            break;\n        }\n        d *= 0.7+dither*0.1;\n        p+=d*rd;\n    }\n    if (hit)\n    {\n        vec2 cuv = vec2(atan(p.z,p.x), p.y);\n        if (d == papat || d == chacha) col = palette(abs(idchat), vec3(0.1),vec3(0.,0.,0.1));\n        if (d == popo) col = text_pot(cuv,15., abs(idchat));\n        if (d == yeux) col = vec3(0.9);\n\n        col *= (1.-shad); \n    }\n    col += g1*0.05;\n    \n    // vignetting (from iq)\n    vec2 q = fragCoord.xy / iResolution.xy;\n    col *= .5 + 0.5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), 0.1);\n    \n    fragColor = vec4(sqrt(col),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dffz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[391, 391, 411, 411, 455], [457, 457, 479, 479, 529], [531, 531, 554, 554, 582], [584, 584, 625, 625, 688], [690, 708, 728, 728, 865], [894, 912, 933, 933, 1495], [1497, 1516, 1539, 1539, 1631], [1674, 1674, 1694, 1694, 1978], [1980, 1980, 2020, 2020, 2067], [2069, 2069, 2119, 2119, 2345], [2347, 2347, 2374, 2374, 2594], [2596, 2596, 2653, 2653, 3774]], "test": "valid"}
{"id": "3dffzn", "name": "Suminagashi", "author": "jarble", "description": "Another modification of my [url=https://www.shadertoy.com/view/3s2cW3]\"Marbled landscape\"[/url] fractal.\n\nClick and drag the mouse to zoom in!", "tags": ["fractal", "marbling", "suminagashi"], "likes": 0, "viewed": 220, "published": "Public API", "date": "1587575862", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//This parameter changes the magnification.\nconst float mag = 9.0;\nconst float distortion_scale = mag*mag;\n\nconst int GREEN = 0;\nconst int BLUE = 1;\nconst int GRAY = 2;\nconst int YELLOW = 3;\nconst int WHITE = 4;\nconst int FOREST_GREEN = 5;\nconst int LIGHTBLUE = 6;\nconst int SKYBLUE = 7;\nconst int SNOW = 8;\nconst int WHITESMOKE = 9;\nconst int LIGHTGRAY = 10;\nconst int LIME = 11;\nconst int LIGHTYELLOW = 12;\nconst int BEIGE = 13;\nconst int SAND = 14;\nconst int TAN = 15;\nconst int ORANGE = 16;\nconst int RED = 17;\nconst int BLACK = 18;\nconst int DARKGRAY = 19;\nconst int ORANGERED = 20;\n\nconst int FOREST_BIOME = 5;\n\n//this function is from https://www.shadertoy.com/view/4djSRW\nint hash12(vec2 p,float num_colors)\n{\n    //set the number of colors to be randomly generated\n    \n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return int(floor(fract((p3.x + p3.y) * p3.z)*num_colors));\n}\n    \nint magnify(vec2 fragCoord,float mag,float num_colors){\n    return hash12(floor(fragCoord/pow(3.0,mag)),num_colors);\n}\n\nivec4 get_neighbors(vec2 fragCoord,float mag,float colors){\n\treturn ivec4(magnify(fragCoord+vec2(0,1),mag,colors),\n        magnify(fragCoord+vec2(1,0),mag,colors),\n        magnify(fragCoord-vec2(0,1),mag,colors),\n        magnify(fragCoord-vec2(1,0),mag,colors));\n}\n\n\nbool is_next_to(int color,ivec4 neighbors){\n\treturn (neighbors.x == color)\n        || (neighbors.y == color)\n        || (neighbors.z == color)\n        || (neighbors.w == color);\n}\n\nvec3 rgb(float r,float g,float b){\n\treturn vec3(r,g,b)/255.0;\n}\n\nvec3 get_color(int color){\n    if(color == BLUE){\n    \treturn vec3(0.149,0.141,0.912);\n   \t}\n    else if(color == GREEN){\n    \treturn vec3(0.000,0.833,0.224);\n   \t}\n    else if(color == FOREST_GREEN){\n    \treturn rgb(34.0,139.0,34.0);\n   \t}\n    else if(color == WHITE){\n    \treturn vec3(1.0,1.0,1.0);\n   \t}\n    else if(color == GRAY){\n    \treturn vec3(192.0,192.0,192.0)/255.0;\n    }\n    else if(color == YELLOW){\n    \treturn vec3(1.0,1.0,0.0);\n   \t}\n    else if(color == LIGHTBLUE){\n    \treturn rgb(173.0,216.0,230.0);\n   \t}\n    else if(color == SKYBLUE){\n    \treturn rgb(135.0,206.0,235.0);\n    }\n    else if(color == SNOW){\n    \treturn rgb(255.0,250.0,250.0);\n    }\n    else if(color == WHITESMOKE){\n    \treturn rgb(245.0,245.0,245.0);\n    }\n    else if(color == LIGHTGRAY){\n    \treturn rgb(211.0,211.0,211.0);\n    }\n    else if(color == LIME){\n    \treturn rgb(0.0,255.0,0.0);\n    }\n    else if(color == LIGHTYELLOW){\n    \treturn rgb(255.0,255.0,153.0);\n    }\n    else if(color == BEIGE){\n    \treturn rgb(245.0,245.0,220.0);\n    }\n    else if(color == TAN){\n    \treturn rgb(210.,180.,140.);\n    }\n    else if(color == ORANGE){\n    \treturn vec3(255,127,80)/255.0;\n    }\n    else if(color == RED){\n    \treturn vec3(1.0,0.0,0.0);\n   \t}\n    else if(color == DARKGRAY){\n    \treturn rgb(128.0,128.0,128.0);\n    }\n    else if(color == ORANGERED){\n    \treturn rgb(255.0,69.0,0.0);\n    }\n}\n\n\nint forest_biome(inout int color1, ivec4 neighbors){\n\tint BLUE = 0;\n    int GREEN = 1;\n    int YELLOW = 2;\n    int GRAY = 3;\n    int FOREST_GREEN = 4;\n    int WHITE = 5;\n    return (color1 == BLUE && is_next_to(GREEN,neighbors))\n        ? GREEN\n    :(color1 == YELLOW)\n        ? GREEN\n    :(color1 == WHITE && is_next_to(FOREST_GREEN,neighbors))\n        ? FOREST_GREEN\n    :(color1 == GRAY && is_next_to(GREEN,neighbors))\n        ? WHITE\n    :(color1 == GREEN && is_next_to(YELLOW,neighbors))\n        ? WHITE\n    :(color1 == GREEN && is_next_to(WHITE,neighbors))\n        ? FOREST_GREEN\n    :(color1 == FOREST_GREEN && is_next_to(GREEN,neighbors))\n        ? GREEN\n    :color1;\n\n}\n\n\nvoid biome(inout int color1, ivec4 neighbors,int biome){\n    color1 = forest_biome(color1,neighbors);\n}\n\nint biome(in vec2 fragCoord,float mag,float zoom,int colors[6],int biome1){\n    fragCoord *= zoom;\n\n    \n    float num_colors = float(colors.length());\n    float warp = 50.0;\n    float avg = (warp*(mag));\n    fragCoord += vec2(sin(fragCoord.y/avg),sin(fragCoord.x/avg))*mag*mag;\n\n    int color1 = magnify(fragCoord,mag,num_colors);\n    \n    ivec4 neighbors;\n    \n    while(mag > 1.0){\n        avg =(warp*(mag));\n        fragCoord += vec2(sin((fragCoord.y)/avg+iTime)*(3.0+sin(fragCoord.y/warp)*2.0),sin(fragCoord.x/avg+iTime)*(3.0+sin(fragCoord.x/warp)*2.0))*mag*mag;\n\n        neighbors = get_neighbors(fragCoord,mag,num_colors);\n    biome(color1, neighbors,biome1);\n    mag -= 1.0;\n    }\n    return colors[int(color1)];;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = mag*(((iMouse.x-iMouse.y)*2.0+iResolution.x)/iResolution.x);\n    fragCoord *= zoom;\n    fragCoord = fragCoord + floor(iTime*50.0)*vec2(mag,0.0);\n\n    //choose the biome here\n\tint biome = biome(fragCoord,mag,1.0,int[](BLUE,GREEN,YELLOW,GRAY,FOREST_GREEN,WHITE),FOREST_BIOME);\n    \n    fragColor = vec4(get_color(biome),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dffzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[619, 681, 718, 774, 922], [928, 928, 983, 983, 1046], [1048, 1048, 1107, 1107, 1312], [1315, 1315, 1358, 1358, 1494], [1496, 1496, 1530, 1530, 1559], [1561, 1561, 1587, 1587, 2944], [2947, 2947, 2999, 2999, 3625], [3628, 3628, 3684, 3684, 3731], [3733, 3733, 3808, 3808, 4456]], "test": "error"}
{"id": "3djcDy", "name": "Conformal Droste - 322 chars", "author": "FabriceNeyret2", "description": "antialiasing + golfing RadoKirov's shader [url]https://shadertoy.com/view/3sjyWG[/url] ( 1303 chars  )\n", "tags": ["droste", "escher", "short", "golf", "conformalmapping", "3tweets"], "likes": 18, "viewed": 338, "published": "Public API", "date": "1587279606", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// antialiasing + golfing RadoKirov's shader ( 1303 chars ) https://shadertoy.com/view/3sjyWG 2020-04-19\n\n// --- 322 again with analytic form of the version with \"even better antialiasing\" \n\n#define g(g,r) ( c = abs( fract(g/e +.5) -.5 ),                \\\n                 c = min(c,c.y) - r/20. ,                      \\\n                 smoothstep(-g, g, c*.4* l*R  ).x )           //\nvoid mainImage(out vec4 O, vec2 U) {\n    vec2  R = iResolution.xy,\n          c = U+U - R, l = length(c) / R,\n          e = mat2(.75, -.1103, .1103,.75)\n              * vec2( atan(c.y, c.x) , log(l) );\n    e  = exp( .7 * fract( iTime/2. ) -e.y )\n         / abs( cos( e.x + vec2(0,1.57)) );\n    e /= exp2( ceil( log( min(e,e.yx) ) / .7 ) );\n    O +=   g( 1.01, .7 )\n         * g( 3.  , .5 );\n}/*\n\n\n\n\n\n\n// --- +12 -8: analytic form of the version with \"even better antialiasing\" \n\n#define g(g,r) ( R = abs( fract(e*g +.5) -.5 ),                \\\n                 R = min(R,R.y) - r/20. ,                      \\\n                 smoothstep(-g, g, R*.4* length(c)  ).x )     //\n#define mainImage(O,U)                                         \\\n    vec2  R = iResolution.xy,                                  \\\n          c = U+U - R,                                         \\\n          e = mat2(.75, -.1103, .1103,.75)                     \\\n              * vec2( atan(c.y, c.x) , log( length(c) / R ) ); \\\n    e  = exp( e.y -.7 * fract( iTime/2. ) )                    \\\n         * abs( cos( e.x + vec2(0,1.57)) );                    \\\n    e *= exp2( ceil( -log( max(e.x,e.y) ) / .7 ) );            \\\n    O +=   g( 1.01, .7 )                                       \\\n         * g( 3.  , .5 )                                      /*\n\n\n\n\n\n// --- 334 chars : +12 : version with even better antialiasing\n\n#define g(e,r) ( c = abs( fract(e +.5) -.5 ),                  \\\n                 c = min(c,c.y) - r/20. ,                      \\\n                 smoothstep(-1., 1., c/fwidth(length(e)) ).x )//\n#define mainImage(O,U)                                         \\\n    vec2  R = iResolution.xy,                                  \\\n          c = U+U - R,                                         \\\n          e = mat2(.75, -.1103, .1103,.75)                     \\\n              * vec2( atan(c.y, c.x) , log( length(c) / R ) ); \\\n    e =   exp( e.y -.7 * fract( iTime/2. ) )                   \\\n        * abs( cos( e.x + vec2(0,1.57)) );                     \\\n    e *= exp2( ceil( -log( max(e.x,e.y) ) / .7 +.02) );        \\\n    O +=   g( e   , .7 )                                       \\\n         * g( e*3., .5 )                                      /*\n\n\n\n\n\n// --- 322 chars   ( with pretty good antialiasing )   < < <\n\n#define g(e,r) ( c = abs( fract(e +.5) -.5 ),                  \\\n                 c = min(c,c.y) - r/20. ,                      \\\n                 smoothstep(-1., 1., c/fwidth(c) ).x )        //\n#define mainImage(O,U)                                         \\\n    vec2  R = iResolution.xy,                                  \\\n          c = U+U - R,                                         \\\n          e = mat2(.75, -.1103, .1103,.75)                     \\\n              * vec2( atan(c.y, c.x) , log( length(c) / R ) ); \\\n    e =   exp( e.y -.7 * fract( iTime/2. ) )                   \\\n        * abs( cos( e.x + vec2(0,1.57)) );                     \\\n    e *= exp2( ceil( -log( max(e.x,e.y) ) / .7 ) );            \\\n    O +=   g( e   , .7 )                                       \\\n         * g( e*3., .5 )                                      /*\n\n\n\n\n\n// --- 327 chars\n\n#define g(g,r) ( c = abs( fract(e * g +.5) -.5 ),                \\\n                 c = min(c,c.y),                                 \\\n                 smoothstep(-1., 1., ( c - r ) / fwidth(c) ).x )//\n#define mainImage(O,U)                                           \\\n    vec2  R = iResolution.xy,                                    \\\n          c = U+U - R,                                           \\\n          e = mat2(.75, .1103, -.1103,.75)                       \\\n              * vec2( log(length(c)/R.x) , atan(c.y, c.x) );     \\\n    e =   exp(e.x -.7 * fract( iTime / 2.) )                     \\\n        * abs( cos( e.y + vec2(0,1.57)) );                       \\\n    e *= exp2( ceil( -log( max(e.x,e.y) ) / .7 ) );              \\\n    O +=   g(1., .035)                                           \\\n         * g(3., .025)                                          /*\n\n\n\n\n\n// --- 352 chars\n\n#define g(g,r) ( a = abs( fract(e * g +.5) -.5 ),              \\\n                 l = min(a.x,a.y),                             \\\n                 smoothstep(-1., 1., ( l - r ) / fwidth(l) ) )//\n#define mainImage(O,U)                                         \\\n    float l;                                                   \\\n    vec2  R = iResolution.xy, a,                               \\\n          c = ( U+U - R) / R.x,                                \\\n          e =  vec2( .75, .1103 );                             \\\n    e = mat2(e, -e.y,e.x)                                      \\\n        * vec2( log(length(c)) , atan(c.y, c.x) );             \\\n    e = exp(e.x) * abs( cos( e.y + vec2(0,1.57)) )             \\\n        / exp(.7 * fract( iTime / 2.) );                       \\\n    e *= exp2( ceil( -log( max(e.x,e.y) ) / .7 ) );            \\\n    O +=   g(1., .035)                                         \\\n         * g(3., .025)                                        /*\n\n\n\n\n\n// --- 372 chars\n\n#define g(g,r) ( a = abs( fract(e * g +.5) -.5 ),              \\\n             t = min(a.x,a.y),                                 \\\n             smoothstep(-1., 1., ( t - r ) / fwidth(t) ) )    //\n#define mainImage(O,U)                                         \\\n    float t = iTime / 3. , l = log(2.);                        \\\n    vec2  R = iResolution.xy, a,                               \\\n          c = (2. * U - R) / R.x,                              \\\n          e =  vec2( .75, l / 6.28 );                          \\\n    e = mat2(e, -e.y,e.x)                                      \\\n        * vec2( log(length(c)) , atan(c.y, c.x) );             \\\n    e = exp(e.x) * cos( e.y + vec2(0,1.57) )                   \\\n        / exp(l * fract(t / l) );                              \\\n    e *= exp2( floor( -log( max(abs(e.x),abs(e.y)) ) / l ) );  \\\n    O +=   g(2., .035)                                         \\\n         * g(6., .025)                                        /*\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3djcDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[386, 386, 422, 422, 777]], "test": "valid"}
{"id": "3djcRV", "name": "1Tweet xor-y thing", "author": "jeyko", "description": "You", "tags": ["1tweet"], "likes": 2, "viewed": 229, "published": "Public API", "date": "1586973891", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvoid mainImage(out vec4 C,vec2 U ){\n    #define f float\n    #define t iTime*0.05\n    U/=iResolution.xy;U-=0.5;f j,i=0.;for(;i <7.;i++){j=f(int(U.y*0.5)^int(U.x*10.));U=abs(U)-2.-j*0.15;U*=mat2(cos(i+t),-sin(i+t),sin(i+t),cos(i+t));}C=vec4(max(U.y,U.x)*40.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3djcRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 36, 36, 260]], "test": "valid"}
{"id": "3djcRW", "name": "Day 109", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 11, "viewed": 341, "published": "Public API", "date": "1586206950", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// HYPERBOLIC CODE FROM http://roy.red/generating-spherical-and-hyperbolic-tilings-in-glsl-.html#generating-spherical-and-hyperbolic-tilings-in-glsl\n// Super interesting read, I am still in the process of understanding all of it, so I copied the UV generation\n// and added some textures on top to make it shiny\n\n\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\n#define PI acos(-1.)\n\n#define pi acos(-1.)\n#define tau (1.*pi)\n\n// Adjust p, q, r\nconst float p = 3.; const float q=4.; const float r=3.;\nfloat space = float(sign(q*r+p*r+p*q-p*q*r));\nvec3 fold( vec3 p, in vec3 dir, inout int n) {\n// Reflect if we're outside the fundamental region\n    float dt = dot(p,dir);\n    if (dt < 0.) {\n        n = n + 1;\n        return p-2.*dt*dir*vec3(1,1,space);\n    }\n    return p;\n}\nfloat sdBox(vec2 p, vec2 s){\n\tfloat d = 10e8;\n    p = abs(p) - s;\n    d = max(p.x,p.y);\n    return d;\n}\nfloat xor(float a, float b){\n\treturn float(int(a)^ int(b));\n}\nvec4 noise(float t){return texture(iChannel0,vec2(floor(t), floor(t))/256.);}\n\nvec3 get(vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec2 z = uv;\n    z *= 2.5;\n    \n    // - HYPERBOLIC UV - //\n    \n    if(length(z) > 1.)\n    \tz /= dot(z,z);\n    \n    // Stereographically project\n    vec3 w=vec3(2.*z,1.-space*dot(z,z))*1./(1.+space*dot(z,z));\n    \n    // Hyperbolic rotation\n    float amt = mod(iTime, 2.45*2.);\n    \n    float envA = smoothstep(0.,1.,amt/2.45)*0.2;\n    float envB = smoothstep(0.,1.,amt/2.45 - 1.)*0.2;\n    \n    if(amt > 2.45)\n        amt -= 2.45*2.;\n    w.yz *= mat2(cosh(amt), sinh(amt), sinh(amt),cosh(amt));\n    //w.yz *= mat2(cosh(amt), sinh(amt), sinh(amt),cosh(amt));\n    // Calculate cutting planes\n    float ab = -cos(PI/p);\n    float bc = -cos(PI/q);\n    float ac = -cos(PI/r);\n    vec3 a = vec3(1.,0.,0);\n    vec3 b = vec3(ab,sin(PI/p),0.);\n    float c0 = ac;\n    float c1 = (bc-b[0]*c0)/b[1];\n    vec3 c = vec3(c0,c1,sqrt(abs(1.-c0*c0-c1*c1)));\n    if (space==0.)\n        c[2] = .5;\n\n    // Fold across the planes a few times\n    int n=0; int m = 0;\n    for (int i=0;i<10;i++){\n        w = fold(w,a,m);\n        w = fold(w,b,m);\n        w = fold(w,c,n);\n    }\n\n    \n    // - COLORING - //\n    //w.x += iTime;\n    \n    float d = 10e7;\n    vec4 no = noise(float(n + m));\n    vec2 p = w.xy;\n    //p = sin(p*7.);\n    #define pmod(p,x) (mod(p,x) - 0.5*x)\n    //vec2 j = pmod(p, 20.);\n    vec2 j = p;\n    j.x -= 2.5;\n    j = sin(j*7.);\n    vec3 col = vec3(0);\n    //col += w*1.;\n    \n    \n    vec3 ff = 1. - vec3(1.)*(dot(w*1.,a*8.));\n    \n    ff = clamp(ff, 0.,1.);\n    //col += ff*0.1;\n\t\n    p.x -= 0.5;\n    float db = sdBox(j, vec2(0.2,0.9));\n    #define pal(a,b,c,d,e) (a + b*sin((c)*(d)+(e)))\n    vec3 cc = pal(0., 0.5, vec3(4.7,4.4,3.4), 1.7,.4 + w*2. + iTime*0.);\n    \n    cc = texture(iChannel1,w.xy, 1.3 + dot(uv*0.5,uv*0.5)*5.).xyz;\n    \n    cc = sin(cc*(5.4) + vec3(0.,0. ,.4 - envB + envA));\n    cc = max(cc, 0.);\n    \n    //cc.bg *= 0.2 +  pow(1. - length(w.x), 2.)*0.8;\n    float bb = length(cc) * pow(1. - length(w), 1.)*1.;\n    cc = sin(cc*1.  + bb*20.);\n    cc *= pow(1. - length(w.x)*1.25, 1.)*1.;\n    cc = smoothstep(0.,1.,cc);\n    cc = smoothstep(0.,1.,cc);\n    col += cc;\n    \n    \n    col -= smoothstep(0.,1.*dFdy(uv.x),-db );\n    col = max(col, 0.);\n    vec3 cb = smoothstep(0.,1.*dFdy(uv.x),-db )*pal(0.5, 0.5, vec3(0.7,0.4,0.9), 0.7 ,0.4 + uv.x + iTime);\n    \n    //col += cb;\n    \n    col = clamp(col, 0., 1.);\n    \n    //col = vec3(1);\n    \n    //col *= 1. - exp2(-abs(length(uv) - 0.4)*20.)*1.;\n    //col *= 1. - exp2(-abs(length(uv) - 0.4)*20.)*1.;\n    \n    float edge = exp2(-abs (length(uv) - 0.4)*50.)*1.;\n    \n    edge = smoothstep(0.,1.,edge);\n    edge = smoothstep(0.,1.,edge);\n    //edge = smoothstep(0.,1.,edge);\n    \n    //col = pow(col, vec3(1. + pow(edge, 0.5)));\n    col = max(col, 0.);\n    col.gb = pow(col.gb, vec2(1. + pow(edge, 0.5) ));\n    \n    col *= 1. - edge*1.0;\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;  \n    vec3 col = vec3(0);\n    \n    float aa = 4.;\n    \n    for(float i =0.; i < aa*aa + min(float(iFrame),0.); i++){\n    \tcol += get(fragCoord + vec2(mod(i,aa),floor(i/aa))/aa);\n    }\n    col /= aa*aa;\n    \n    col = clamp(col, 0., 1.);\n    //col *= 0.999;\n    //col = 1. - col;\n    \n    \n    \n    //col *= max((1. + 1.*cos(iTime*1.+length(uv)*2.+vec3(4,2.5,1.5)))*1., 0.);\n    //col *= max((1.5 + 1.4*cos(iTime+length(uv)*2.+vec3(1,1.5,1.5)))*1., 0.);\n    col *= 2.;\n    col *= 1. - pow(smoothstep(0.,1.,dot(uv,uv)*0.9),0.9)*1.;\n    //col = 1. - col;\n    col = max(col, 0.);\n    \n    col = pow(col, vec3(0.45454));\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": "XsXGRn", "previewfilepath": "/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3djcRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[548, 548, 594, 645, 776], [777, 777, 805, 805, 880], [881, 881, 909, 909, 942], [943, 943, 963, 963, 1020], [1022, 1022, 1048, 1048, 3944], [3947, 3947, 4004, 4004, 4715]], "test": "error"}
{"id": "3djcRz", "name": "Watercolor Trance", "author": "jywhy6", "description": "modified from: https://www.shadertoy.com/view/lsyfWD\nyou can try dragging it for different watercolor patterns", "tags": ["2d"], "likes": 4, "viewed": 145, "published": "Public", "date": "1585981760", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// modified from: https://www.shadertoy.com/view/lsyfWD\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    float speed = .2;\n    float scale = 0.003;\n    vec2 p = fragCoord * scale;   \n    for(int i=1; i<10; i++){\n        p.x+=0.3/float(i)*sin(float(i)*3.*p.y+iTime*speed)+iMouse.x/1000.;\n        p.y+=0.3/float(i)*cos(float(i)*3.*p.x+iTime*speed)+iMouse.y/1000.;\n    }\n    // scale = 0.03;\n    // p = fragCoord * scale;\n    float r=cos(sin(p.x)-sin(p.y)+iTime*speed*2.)*.3+.5;\n    float g=sin(cos(p.x)+cos(p.y)-iTime*speed*2.)*.3+.5;\n    float b=(sin(cos(p.x)*cos(p.y)+iTime*speed*2.)-cos(sin(p.x)*sin(p.y)+iTime*speed*2.))*.3+.5;\n    // r = 0.;\n\t// g = 0.;\n    // b = 0.;\n    vec3 color = vec3(r,g,b);\n    fragColor = vec4(color,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3djcRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 56, 113, 113, 750]], "test": "valid"}
{"id": "3djcWV", "name": "DEAD SPACE", "author": "os0450", "description": "Day 19. DEAD SPACE", "tags": ["dailycodingchallenge"], "likes": 4, "viewed": 57, "published": "Public", "date": "1587353970", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 s) {\n    return fract(sin(dot(s, vec2(4212.3213, 2889.32)))*132132.2312);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.*fragCoord - iResolution.xy)/iResolution.yy;\n\n    float e = 0.005;\n    float r = 2.0;\n    \n    float s = sin(iTime*0.2), c = cos(iTime*0.2);\n    p.x -= 0.2;\n    p *= mat2(c, -s, s, c);\n    \n    vec2 q = p;\n    q = abs(q);\n    \n    float d = smoothstep(-e, e, length(q) - r);\n    for(int i=0; i<6; i++) {\n        float pr = r;\n        r /= (sqrt(2.) + 1.);\n        q = abs(q);\n    \tq.xy -= vec2( (pr - r)*1./sqrt(2.));\n        \n        float phase = sin(iTime+rand(step(0., p)+float(i)))*0.5+0.5;\n        \n        if(i%2 == 0) {\n    \t\td = max(d, smoothstep(-e, e, -(length(q)-r*phase)));\n        } else {\n    \t\td = min(d, smoothstep(-e, e, length(q)-r*phase));\n        }\n    }\n    \n    \n    vec3 col = mix(vec3(242.0, 226.0, 214.0)/255.,\n                   mix(vec3(0.44, 0.27, 0.09), vec3(153., 100., 60.)/255., p.x)*length(p),\n                   d);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3djcWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 91], [93, 93, 150, 150, 1079]], "test": "valid"}
{"id": "3djcWW", "name": "ping", "author": "lennyjpg", "description": "ping", "tags": ["grid", "radius"], "likes": 2, "viewed": 227, "published": "Public API", "date": "1586652471", "time_retrieved": "2021-10-01T00:00:00", "image_code": "# define PI 3.141592653589793\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.y;\n    uv.y+=iTime*0.1;\n    \n    vec2 u = fract(uv.xy*5.)-0.5;\n    \n   \n    float z = 5.;\n    vec2 g = iTime*.02 + floor(uv * z);\n    float b =  rand(floor(g + 3.321))*3.;\n    float r =.7;\n    float angle = PI*0.25+floor(rand(floor(g))*4.)*PI*0.5;      \n    u.x+=sin(angle)*r;\n    u.y+=cos(angle)*r;\n    float d = length(u*.3);\n //\tfloat k = smoothstep(d,d*1.01,0.5);\n    float k = fract(d*3.0-iTime*(b-0.5)*0.2);\n    k += sin(iTime * r + angle);\n    k = sin(fract(k*.13)*1.5)*1.2;\n    vec3 cc = mix( vec3(.08, 0.15, 0.3), vec3(1.2, 0.13, 0.2), k);\n    fragColor = vec4(cc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3djcWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 50, 50, 122], [124, 124, 181, 181, 801]], "test": "valid"}
{"id": "3djczG", "name": "Rocky Cave", "author": "omeometo", "description": "result of some playing around", "tags": ["something"], "likes": 2, "viewed": 94, "published": "Public", "date": "1586866720", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float noise(in vec3 pos){return 0.8+0.2*cos(pos.z*9.);}\n\nmat2 rot(in float t){return mat2(cos(t),-sin(t),sin(t),cos(t));}\n\nfloat lat(in vec3 p){return length(p-round(p));}\nfloat dist(in vec3 p){\n\tvec3 q=p;\n    p.xy *= rot(0.1);\n    p += 0.5;\n    q -= 3.4;\n    q.xy *= rot(2.1);\n    q.yz *= rot(1.1);\n    q.zx *= rot(1.3);\n    return (lat(p)-lat(q*1.2)/1.2)*0.5;\n}\n\nvec3 getNormal(in vec3 pos){\n    float eps=0.001;\n    vec2 s = vec2(eps, -eps);\n    return normalize(dist(pos+s.xxx)*s.xxx\n                    +dist(pos+s.xyy)*s.xyy\n                    +dist(pos+s.yxy)*s.yxy\n                    +dist(pos+s.yyx)*s.yyx);\n}\n\nfloat getAO(in vec3 pos, in vec3 nor){\n\tfloat ao=1.0;\n    float wt=1.0;\n    for(int i=1;i<=5;i++){\n    \tfloat t=float(i)*0.01;\n        float d=dist(pos+t*nor);\n        ao -= (t-d)*wt;\n        wt*=0.5;\n    }\n    return clamp(ao, 0.0, 1.0);\n}\n\nvoid getColor(out vec4 fragColor, in vec3 cen, in vec3 rd){\n\tfragColor = vec4(vec3(0), 1.0);\n    float t=0.01;\n    for(int i=0;i<100;i++){\n    \tvec3 pos = cen + t * rd;\n        float d = dist(pos);\n        if(d<1e-3){\n            vec3 nor = getNormal(pos);\n\t\t\tfloat occ = getAO(pos, nor);\n            fragColor = vec4(vec3(1.5,0.15,0.0)*noise(pos)*(dot(nor, -rd)*0.8+0.2)*occ, 1);\n            fragColor *= (1.0-0.01*float(i));\n\t\t\t//fragColor = vec4(v02c3(occ), 1);\n            //fragColor = vec4(vec3(1.0-float(i)/64.0), 1);\n            \n            break;\n        }\n        t += d;\n        if(t>=1e2){\n        \tbreak;\n        }\n    }\n    \n    fragColor = pow(fragColor, vec4(0.45));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\t\n    vec3 cam = vec3(0,0,-iTime);\n    vec3 fwd = normalize(vec3(sin(iTime*0.2),sin(iTime*0.3),-5));\n    vec3 up = vec3(0,1,0);\n    vec3 right = cross(fwd, up);\n    \n    vec3 rd = normalize(fwd + 0.3 * (uv.x * right + uv.y * up));\n    \n    getColor(fragColor, cam, rd);\n}\n\nvoid mainVR(out vec4 fragColor, in vec2 fragCoord, in vec3 cam, in vec3 rd){\n\tgetColor(fragColor, cam, rd);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3djczG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 55], [57, 57, 78, 78, 121], [123, 123, 144, 144, 171], [172, 172, 194, 194, 363], [365, 365, 393, 393, 620], [622, 622, 660, 660, 862], [864, 864, 923, 923, 1549], [1551, 1551, 1608, 1608, 1946], [1948, 1948, 2024, 2024, 2057]], "test": "valid"}
{"id": "3djyWd", "name": "Inedible plants", "author": "gaz", "description": "bace: https://twitter.com/gaziya5/status/1250687942441361408", "tags": ["3d", "2tweets"], "likes": 5, "viewed": 106, "published": "Public", "date": "1587521206", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 O, vec2 C)\n{\n    O-=O;\n\tvec2 q=C.xy/iResolution.y-.4;\n    vec3 p,d=normalize(vec3(q,-2.-dot(q,q)*3.)).xzy;\n    d.xz+=sin(d.xz*9.-iTime)*8.;\n    float t,e,i;\n    for(i=0.;i<30.;i++){\n        p=d*t;\n        t+=e=(length(vec3(mod(p.xz,4.)-2.,p.y+2.)))*.05;\n    }\n    O=vec4(cos(vec3(5,6,9)+d)/30./e,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3djyWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 325]], "test": "valid"}
{"id": "3djyWG", "name": "Web 2", "author": "aiekick", "description": "based on the [url=https://www.shadertoy.com/view/3d2cRV]Shader[/url] of notargs\n\nvariation of [url=https://www.shadertoy.com/view/WdSyWV]Web 1[/url]\n\nalso better in fullscreen", "tags": ["web", "trabeculum"], "likes": 9, "viewed": 329, "published": "Public API", "date": "1587308724", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// based on the shader of notargs\n// https://www.shadertoy.com/view/3d2cRV\n\n// Web 1 : https://www.shadertoy.com/view/WdSyWV\n// Web 2 : https://www.shadertoy.com/view/3djyWG#\n\n// final\nconst vec4 colorBalance = vec4(0.3,0.7,0.5,0.3);\nconst vec3 uColor = vec3(0.5,1,0);\nconst vec3 uFog = vec3(0.005,0.001,0.0035);\nconst vec3 uLightDir = vec3(-1,-1,1);\n\n// shape\nconst vec3 uRatio = vec3(-0.37762,0.36364,0);\nconst float uRot = 0.1;\nconst vec2 uvOffset = vec2(2.69231,1.71329);\n\nfloat camZ = 0.0;\n\nvec2 path(float t)\n{\n\treturn vec2(cos(t * uRot) * 0.7, \n                sin(t * uRot) * 0.5) * uvOffset;\t\n}\n\nfloat map(vec3 p)\n{\n\tfloat a = p.z * uRot;\n    p.xy *= mat2(cos(a),sin(a),-sin(a),cos(a));\n    float th = mix(0.001, 0.06, cos(camZ - p.z)*0.5+0.5);\n    return th-length(\n        sin(p.xyz)*uRatio.x+\n        sin(p.zxy)*uRatio.y+\n        sin(p.yzx)*uRatio.z);\n}\n\nvec3 nor(vec3 p, float prec)\n{\n\tvec3 e = vec3(prec,0,0);\n\treturn normalize(vec3(\n\t\tmap(p+e)-map(p-e),\n\t\tmap(p+e.yxz)-map(p-e.yxz),\n\t\tmap(p+e.zyx)-map(p-e.zyx)));\n}\n\nvoid mainImage(out vec4 e, in vec2 v)\n{\n    vec3 rd = normalize(.5 - vec3(v,1)/iResolution.y);\n    camZ = iTime * -5.0;\n\tvec3 ro = vec3(uvOffset + path(camZ),camZ);\n\tvec3 p = vec3(0);\n\t\n\tfloat d = 0.0, s = d;\n    for(int i=0;i<250;i++)\n    {\n\t\tif (abs(s)<d*d*1e-6) break;\n\t\td += s = map(p);\n\t\tp = ro + rd * d;\n    }\n\t\n\tvec3 ld = normalize(uLightDir);\n\tvec3 n = nor(p, 0.01);\n\tfloat diff = max(dot(n,-ld),0.0);\n\tfloat spec = max(dot(reflect(ld,n), rd),0.0);\n\tvec3 col = sin(d*uColor)*0.5+0.5;\n\tvec3 fog = exp(-uFog*d*d);\n    vec3 c = \n\t\tdiff * colorBalance.x * fog.x + \n\t\tcol * colorBalance.y * fog.y + \n\t\tsqrt(spec * colorBalance.z * 10.0) * colorBalance.w * fog.z;\n\t\n\te = vec4(c, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3djyWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[496, 496, 516, 516, 603], [605, 605, 624, 624, 865], [867, 867, 897, 897, 1030], [1032, 1032, 1071, 1071, 1718]], "test": "valid"}
{"id": "3djyWh", "name": "Sine Net", "author": "loni852", "description": "Net", "tags": ["net"], "likes": 0, "viewed": 47, "published": "Public", "date": "1586541863", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float iterations = 20.0;\n    vec3 col;\n    col = vec3(1.0,1.0,1.0);\n    float iterated = 0.0;\n    \n    for (float i = 0.0; i <= iterations; i++)\n    {\n    \t\n        int x = int(i);\n        float colony = sin(uv.x+( iTime*0.5*(float(x)*0.05))+i)+(((sin(iTime))*0.5*(float(x)*0.05))+0.5);\n        if (colony >= uv.y-0.05 && colony <= uv.y+0.05 && iterated == 0.0)\n    \t{\n            if (x % 4 == 1)\n            {\n                col *= 0.5;\n    \t\t\tcol.r = 0.5;\n            \tcol.b = 0.8;\n                iterated = 1.0;\n            }\n            else if (x % 4 < 1)\n            {\n                col *= 0.5;\n    \t\t\tcol.b = 0.5;\n           \t\tcol.g = 0.8;\n                iterated = 1.0;\n            }\n            else if (x % 4 > 1)\n            {\n                col *= 0.5;\n    \t\t\tcol.g = 0.5;\n                col.r = 0.8;\n                iterated = 1.0;\n            }\n    \t}\n        \n    }\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3djyWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "valid"}
{"id": "3djyzK", "name": "Voronoi Experimentation_", "author": "Pixdigit", "description": "A playground to play with voronoi tiling", "tags": ["voronoi"], "likes": 0, "viewed": 56, "published": "Public API", "date": "1586965908", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst float cells = 40.;\nconst float subtile = 1.;\nconst bool boxed = true;\n\nvec2 N22(vec2 p) {\n    vec3 a = fract(p.xyx*vec3(123.34, 234.34, 345.65));\n    a += dot(a, a+34.45);\n    return fract(vec2(a.x*a.y, a.y*a.z));\n}\n\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n\tfloat t = iTime * 0.2+200.;\n    \n    vec3 col;\n    \n    float id = 0.;\n    float minD = 1000.;\n    \n    if (boxed) {\n        vec2 guv = fract(uv*subtile)-.5;\n        vec2 gid = floor(uv*subtile);\n\t\tvec2 cid;\n        \n        for (float x = -1.; x < 2.; x++) {\n            for (float y = -1.; y < 2.; y++) {\n                vec2 off = vec2(x, y);\n                vec2 n = N22(gid+off);\n                vec2 p = off + sin(n * t*4.)*0.5;\n                vec2 dVec = guv-p;\n                float d = abs(dVec.x)+abs(dVec.y);\n                if (d < minD) {\n                    minD = d;\n                    cid = off+gid;\n                }\n            }\n        }\n        float h = N22(cid).x*0.2;\n        float s = smoothstep(1., -0.6, minD);\n        float b = 0.3+N22(cid).x*(1.-minD);\n\n        col = hsb2rgb(vec3(h, s, b));\n    } else {\n        for (float i = 0.; i < cells; i++) {\n            vec2 n = N22(vec2(i));\n            vec2 p = sin(n * t);\n            p.x *= iResolution.x / iResolution.y;\n            vec2 dVec = uv-p;\n            float d = abs(dVec.x)+abs(dVec.y);\n            if (d < minD) {\n                minD = d;\n                id = i / cells;\n            }\n            float h = id*0.2;\n            float s = smoothstep(0.7, -0.6, minD);\n            float b = 0.3+id*(1.-minD);\n\n            col = hsb2rgb(vec3(h, s, b));\n        }\n    }\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3djyzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 78, 96, 96, 222], [224, 224, 250, 250, 482], [484, 484, 541, 541, 1991]], "test": "valid"}
{"id": "3dlBWH", "name": "one line britney", "author": "flockaroo", "description": "Hilb-Toning: halftoning using a hilbert curve in different scales.\nmove mouse to adjust detail\n\n...btw this effect is also available for AfterEffects and OpenFX (e.g. Nuke, DaVinci, Natron) here: [url]https://10xfx.com?package=pack2[/url]\n", "tags": ["effect", "halftone", "hilbert"], "likes": 44, "viewed": 1031, "published": "Public API", "date": "1588169326", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// created by florian berger (flockaroo) - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// one line britney - \"Hilb-toning\"\n\n// this and more effect for AfterEffects/OpenFX available at https://10xfx.com\n\n\n#define Res vec2(iResolution.xy)\n#define Res0 vec2(textureSize(iChannel0,0))\n#define Res1 vec2(textureSize(iChannel1,0))\n#define PI  3.14159265359\n#define PI2 6.28318530718\n#define PIH 1.57079632679\n\n#define ROT(ang) mat2(cos(ang+vec2(0.,PI*.5)),sin(ang+vec2(0.,PI*.5)))\n\n//#define PatternRot 0.\n#define PatternRot (iTime*.1)\n#define randness .0\n\nvec4 getRand(int idx)\n{\n    return texelFetch(iChannel1,ivec2(idx%256,(idx/256)%256),0);\n}\n\nmat2 getHilbTrans(int idx)\n{\n//  mirr, ang  (4 points)\n//    -1,-90\n//     1,  0\n//     1,  0\n//    -1, 90\n    float a=float( (((idx/2)&1)*2-1)*(((idx+3)/2)&1) ); // (-1,-1,1,1)*(1,0,0,1)=(-1,0,0,1)\n    float mir=-abs(a)*2.+1.;\n    float ang=a*PIH;\n    vec2 cs=cos(ang-vec2(0,PIH));\n    return mat2(cs,cs.yx*vec2(-1,1))*mat2(mir,0,0,1);\n    //return vec2(mir,ang);\n}\n    \nvec2 getHilbPoint(int idx)\n{\n    return vec2((ivec2(idx,idx+1)/2)&1)-.5;\n}\n\nint getHilbIdx03(vec2 sc)\n{\n    // get quadrant index\n    // 1 2\n    // 0 3\n    //return int(step(0.,-sc.y*sc.x)+2.*step(0.,sc.x));\n    return int(atan(sc.x,sc.y)/PIH+2.);\n}\n\nfloat dDirLine(vec3 p, vec3 c, vec3 dir, float l)\n{\n    p-=c;\n    dir=normalize(dir);\n    float dp=dot(p,dir);\n    //return length(p-dp*dir);\n    return max(max(length(p-dp*dir),-dp),dp-l);\n}\n\nfloat dLine(vec3 p, vec3 p1, vec3 p2) { return dDirLine(p,p1,normalize(p2-p1),length(p2-p1)); }\n\nfloat dLine(vec2 p, vec2 p1, vec2 p2) { return dLine(vec3(p,0),vec3(p1,0),vec3(p2,0)); }\n\n// get hilbert point of index idx with lev subdivision levels\nvec2 getHilbPoint(int idx,int lev)\n{\n    vec2 p=vec2(0);\n    float scale=1.;\n    mat2 m=mat2(1,0,0,1);\n    for(int l=0;l<lev;l++)\n    {\n        int il=(idx>>((lev-1-l)*2))&3;\n        p+=m*(getHilbPoint(il)*scale);\n        m=m*getHilbTrans(il);\n        scale*=.5;\n    }\n    return p;\n}\n\nvec2 getHilbPointF(int idx,float lev)\n{\n    vec2 p=vec2(0);\n    float scale=1.;\n    mat2 m=mat2(1,0,0,1);\n    int maxLev=int(floor(lev)+1.)-1;\n    maxLev=min(maxLev,10);\n    for(int l=0;l<=maxLev;l++)\n    {\n        int il=(idx>>((maxLev-l)*2))&3;\n        float levFade=1.;\n        if(l==maxLev) levFade=fract(lev);\n        vec2 offs=vec2(0.);\n        if(l==maxLev-1) offs=(getRand(idx).xy-.5)*.2*randness;\n        if(l==maxLev) offs=(getRand(idx).xy-.5)*.2*(1.-fract(lev))*randness;\n        p+=m*((getHilbPoint(il)+offs)*scale)*levFade;\n        m=m*getHilbTrans(il);\n        scale*=.5;\n    }\n    return p;\n}\n\nint getClosestHilbIdx(vec2 p,int lev)\n{\n    float scale=1.;\n    int idxAll=0;\n    for(int l=0;l<lev;l++)\n    {\n        int idx=getHilbIdx03(p);\n        idxAll=idxAll*4+idx;\n        mat2 m=getHilbTrans(idx);\n        p=m*(p-getHilbPoint(idx)*scale);\n        scale*=.5;\n    }\n    return idxAll;\n}\n\nfloat hilbert2d(vec2 pos, int level)\n{\n    float d=10000.;\n    for(int i=0; i<int(iMouse.x/10.); i++)\n    {\n        vec2 p1=getHilbPoint(i,level);\n        vec2 p2=getHilbPoint(i+1,level);\n        d=min(d,dLine(pos,p1,p2));\n    }\n    return d;\n}\n\n\nvec2 getInterPoint(vec2 p[11], int num, float fact)\n{\n    fact=clamp(fact,0.,1.);\n    float idxf=fact*(float(num)-.001);\n    int fi=int(idxf);\n    return mix(p[fi],p[min(fi+1,num-1)],fract(idxf));\n}\n\nvec2 getSmoothInterPoint(vec2 p[11], int num, float fact, float w)\n{\n    vec2 p1=getInterPoint(p, num, fact-w);\n    vec2 p2=getInterPoint(p, num, fact+w);\n    return mix(p1,p2,.5);\n}\n\nfloat hilbDistF(vec2 p, float lev)\n{\n    vec2 h[11];\n    int idx0=getClosestHilbIdx(p,int(lev+1.));\n    for(int i=0;i<=8;i++)\n    {\n        h[i]=getHilbPointF(idx0+i-4,lev);\n    }\n    float d=10000.;\n    //d=dSpline(h,8);\n    for(int i=0;i<8;i++)\n    {\n        d=min(d,dLine(p,h[i],h[i+1]));\n    }\n    return d;\n}\n\nfloat hilbPat(vec2 p, float lev)\n{\n    float sc=1.*exp2(lev);\n    return hilbDistF(p, lev);\n}\n\n#define LineWidth (1.*pow(Res.x/700.,.3)*(.75+iMouse.y/Res.y))\n#define Inverse 0.\n\n#define VidTex iChannel0\n\nfloat WhiteVign=1.;\n\nvec4 getCol(vec2 c)\n{\n    vec2 uv=(c-.5*Res)*min(Res0.x/Res.x,Res0.y/Res.y)/Res0+.5;\n    //return textureLod(VidTex,c/Res,0.);\n    vec4 col=vec4(0);\n    float sum=0.;\n    for(int i=0;i<4;i++) \n    {\n        float f=exp2(-float(i)*1.);\n        col+=f*textureLod(VidTex,uv,.5+float(i)*1.2);\n        sum+=f;\n    }\n    col/=sum;\n    float l=length(c/Res-.5);\n\t//col*=1.1;\n    //col-=.1;\n    col=mix(col,vec4(1),clamp(WhiteVign*l*l,0.,1.));\n    return clamp(col,0.,.9);\n}\n\nfloat getVal(vec2 c)\n{\n    //return dot(getCol(c).xyz,vec3(.3,.5,.2));\n    return dot(getCol(c).xyz,vec3(.3333));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float fitRes=min(Res.x,Res.y);\n    vec2 sc=(fragCoord-Res*.5)/fitRes*2.;\n    sc=ROT(PatternRot)*sc;\n    \n    /*vec4 c=\n     1.  *textureLod(iChannel0,fragCoord/Res,0.5)\n    +.5  *textureLod(iChannel0,fragCoord/Res,1.5)\n    +.25 *textureLod(iChannel0,fragCoord/Res,2.5)\n    +.125*textureLod(iChannel0,fragCoord/Res,3.5);\n    c*=1./(1.+.5+.25+.125)*.9;\n    float br=dot(c.xyz,vec3(.333));*/\n    float br=getVal(fragCoord);\n    br=clamp(br,0.,1.);\n    //br*=.9;\n    br=mix(br,1.-br,Inverse);\n    //sc+=(texture(iChannel1,sc*.2).xy-.5)*.006;\n    //br=.1+.9*br;\n    float scale=1.;\n    //scale*=exp(-iMouseData.z/3000.)/sqrt(Res.x/600.);\n    scale*=exp(-iMouse.x/Res.x)/sqrt(Res.x/600.);\n    scale*=max(.8,.01)*(fitRes/Res.x);\n    float d=hilbPat(sc, log2(br*.5*Res.x*scale));\n    \n    float s=2./(fitRes*length(vec2(fwidth(sc.y),fwidth(sc.x))));\n    \n    d=hilbDistF(sc, log2((1.-br)*1.*Res.x*scale))*fitRes/2.;\n    //d=hilbPat(sc, iMouse.x/Res.x*10.);\n    \n    float w=1.4*fwidth(d);\n    fragColor.xyz = vec3(0)+exp(-(d-1.+br)*(d-1.+br)/w/w);\n    float th=LineWidth-.35;\n    //float p=smoothstep(th-.7,th+.7,d);\n    float p=clamp(d*s*1.4+1.-LineWidth,0.,1.);\n    p=mix(p,1.-p,Inverse);\n    fragColor.xyz = vec3(0)+p;\n}\n\n", "image_inputs": [{"id": "Xdf3Rn", "previewfilepath": "/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dlBWH.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[601, 601, 624, 624, 691], [693, 693, 721, 799, 1059], [1065, 1065, 1093, 1093, 1139], [1141, 1141, 1168, 1272, 1314], [1316, 1316, 1367, 1367, 1507], [1509, 1509, 1548, 1548, 1604], [1606, 1606, 1645, 1645, 1694], [1696, 1758, 1794, 1794, 2042], [2044, 2044, 2083, 2083, 2651], [2653, 2653, 2692, 2692, 2946], [2948, 2948, 2986, 2986, 3192], [3395, 3395, 3463, 3463, 3577], [3579, 3579, 3615, 3615, 3892], [3894, 3894, 3928, 3928, 3987], [4119, 4119, 4140, 4140, 4585], [4587, 4587, 4609, 4657, 4702], [4704, 4704, 4761, 4761, 5981]], "test": "error"}
{"id": "3dlcD4", "name": "Simple sinus 2", "author": "Mihairu", "description": "My first shader ever", "tags": ["sin"], "likes": 5, "viewed": 65, "published": "Public", "date": "1586168630", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 color1;\n\n    float sinX1 = sin(uv.x * 2.0 + iTime * 1.0) / 3.0 + 0.65;\n    if(uv.y < sinX1) {\n        if(uv.y + 0.15 > sinX1) {\n            \n    \t\tcolor1 = vec4(uv.x, uv.y, 1.0, 1.0);\n            if(uv.y + 0.2 > sinX1) {\n                color1 -= (uv.y + 0.1 - sinX1) * 10.0;\n            }\n        \n        } else {\n            color1 = vec4(uv.x, uv.y, 1.0, 1.0);\n        \tif(uv.y + 0.4 > sinX1) {\n               color1 += (uv.y + 0.2 - sinX1) * 10.0;\n            } else {\n            \t color1 = vec4(0.0, 0.0, 0.0, 1.0);\n            }\n        }\n           \n\t\tfragColor = color1;\n    }\n  \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dlcD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 703]], "test": "valid"}
{"id": "3dlcWl", "name": "30 torus", "author": "XT95", "description": "Pouet", "tags": ["torus", "neon", "demostyle"], "likes": 53, "viewed": 878, "published": "Public API", "date": "1585841211", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// helpers\nfloat hash(float s) { return fract(sin(s)*42422.42); }\nmat2 rot(float v) { float a = cos(v), b = sin(v); return mat2(a,b,-b,a); }\nfloat torus(vec3 p, vec2 q) { return length( vec2(length(p.xz)-q.x,p.y) ) - q.y; } \n\n// global + params\n#define att 15.\nfloat time;\nfloat id;\nvec3 glow;\n\n// distance function\nfloat map( vec3 p ) {\n    // rotate the world\n\tp.xy *= rot(time*.1);\n\tp.xz *= rot(time*.2);\n    \n    // small point light on the center\n\tfloat d =  length(p);\n\tglow += vec3(1.) / ( .1 + d*200.);\n    \n    // 30 torus\n\tfloat s = .25;\n\tfor(int i=0; i<30; i++) {\n    \ts += .25;\n    \tp.xy *= rot(time*.05);\n    \tp.xz *= rot(time*.1);\n        \n    \tfloat d2 = torus(p,vec2(s, 0.14));\n        \n        // we accumulate the lighting here\n    \tfloat intensity = 1. / ( 1. + pow(abs(d2*att),1.3));\n    \tif(i == 6 && id == 0.) {\n    \t\tglow += vec3(1.,.3,1.) * intensity;\n    \t} else if(i == 15 && id == 1.) {\n      \t\tglow += vec3(1.,1.,.1) * intensity;\n    \t} else if(i == 20 && id == 2.) {\n      \t\tglow += vec3(.1,1.,.1) * intensity;\n    \t} else if(i == 25 && id == 3.) {\n      \t\tglow += vec3(.1,1.,1.) * intensity;\n    \t}\n        \n    \td = min(d, d2);\n\t}\n\treturn d;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\ttime = iTime + 10.;\n    \n    // uv stuff\n    vec2 uv = fragCoord/iResolution.xy;\n  \tvec2 v = uv*2.-1.;\n  \tv.x /= iResolution.y / iResolution.x;\n\n    // which torus is on ?\n\tid = floor(hash(floor(iTime*5.*hash(floor(time*.2))))*5.);\n    \n    // ray setup\n  \tvec3 ro = vec3(0.,0.,-10.);\n  \tvec3 rd = normalize(vec3(v, 1.));\n\n\n    // raymarching by distance field\n  \tvec3 p = ro+rd ;\n  \tglow = vec3(0.);\n  \tfor(int i=0; i<32; i++) {\n    \tp += rd * map(p);\n  \t}\n    \n    // glow + vignetting + gamma correction\n  \tvec3 col = glow;\n  \tcol *= pow(uv.x*uv.y*(1.-uv.x)*(1.-uv.y), .8)*2.;\n  \tcol = pow(col,vec3(1./2.2));\n    \n  \tfragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dlcWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 11, 32, 32, 65], [66, 66, 85, 85, 140], [141, 141, 170, 170, 223], [295, 316, 337, 361, 1174], [1178, 1178, 1235, 1235, 1884]], "test": "valid"}
{"id": "3dlfDH", "name": "Fractal Tomography", "author": "dr2", "description": "Looking inside the Mandelbox and Mandalay fractals", "tags": ["mandelbox", "mandalay"], "likes": 4, "viewed": 295, "published": "Public API", "date": "1588175885", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Fractal Tomography\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n Looking inside the Mandelbox and Mandalay fractals.\n Step-through showing slices overlaid on full view.\n Mouse-x rotates, -y zooms\n*/\n\n#define M_TYPE   0  // = 0/1 for Mandelbox / Mandalay fractals\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat PrBoxDf (vec3 p, vec3 b);\nvec3 HsvToRgb (vec3 c);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\n\nvec3 ltDir, pFold;\nfloat tCur, dstFar, mScale, bxLim, slPos, slWid;\nint mType;\nconst int itMax = 12;\nbool isTrans;\nconst float pi = 3.14159;\n\nfloat PPFoldD (vec3 p)\n{\n  vec3 s;\n  p.y = max (p.y, p.z);\n  s = vec3 (p.x, max (abs (p.x - pFold.x) - pFold.x, p.y - 4. * pFold.x),\n     max (p.x - 2. * pFold.x - pFold.y, p.y - pFold.z));\n  return Minv3 (s);\n}\n\nvec3 PPFold (vec3 p)\n{\n  return vec3 (PPFoldD (p), PPFoldD (p.yzx), PPFoldD (p.zxy));\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec4 p4;\n  float d;\n  p4 = vec4 (p, 1.);\n  for (int j = 0; j < itMax; j ++) {\n    p4.xyz = 2. * clamp (p4.xyz, -1., 1.) - p4.xyz;\n    if (mType == 1) p4.xyz = - sign (p4.xyz) * PPFold (abs (p4.xyz));\n    p4 = mScale * p4 / clamp (dot (p4.xyz, p4.xyz), 0.25, 1.) + vec4 (p, 1.);\n  }\n  d = max (length (p4.xyz) / p4.w, PrBoxDf (p, vec3 (bxLim)));\n  if (! isTrans) d = max (d, abs (p.z - slPos) - slWid);\n  return d;\n}\n\nvec3 ObjTDist (vec3 p)\n{\n  vec4 p4;\n  vec3 pMin;\n  pMin = vec3 (1.);\n  p4 = vec4 (p, 1.);\n  for (int j = 0; j < itMax; j ++) {\n    p4.xyz = 2. * clamp (p4.xyz, -1., 1.) - p4.xyz;\n    if (mType == 1) p4.xyz = - sign (p4.xyz) * PPFold (abs (p4.xyz));\n    pMin = min (pMin, abs (p4.xyz));\n    p4 = mScale * p4 / clamp (dot (p4.xyz, p4.xyz), 0.25, 1.) + vec4 (p, 1.);\n  }\n  return pMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, h, s, sLo, sHi, eps;\n  eps = 0.0005;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    h = ObjDf (ro + s * rd);\n    if (h < eps || s > dstFar) {\n      sHi = s;\n      break;\n    }\n    sLo = s;\n    s += h;\n  }\n  if (h < eps) {\n    for (int j = VAR_ZERO; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      if (ObjDf (ro + s * rd) > eps) sLo = s;\n      else sHi = s;\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0002, -0.0002);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, colT, vn, roo;\n  float dstObj, dstObjT;\n  bool isBg;\n  mScale = (mType == 1) ? 3. : 2.5;\n  roo = ro;\n  isTrans = false;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    isBg = false;\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col = HsvToRgb (vec3 (mod (0.2 + 0.15 * Maxv3 (abs (ObjTDist (ro))), 1.), 0.5, 1.)) *\n       (0.3 + 0.7 * max (dot (vn, ltDir), 0.)) +\n       0.1 * pow (max (0., dot (ltDir, reflect (rd, vn))), 16.);\n   } else {\n    isBg = true;\n    col = vec3 (0.3, 0.3, 0.3);\n  }\n  isTrans = true;\n  ro = roo;\n  dstObjT = ObjRay (ro, rd);\n  if (dstObjT < min (dstObj, dstFar)) {\n    ro += dstObjT * rd;\n    vn = ObjNf (ro);\n    colT = HsvToRgb (vec3 (mod (0.2 + 0.15 * Maxv3 (abs (ObjTDist (ro))), 1.), 0.5, 1.)) *\n       (0.3 + 0.7 * max (dot (vn, ltDir), 0.));\n    colT = mix (colT, vec3 (0.6, 0.65, 0.6) * smoothstep (0., 1., Maxv3 (colT)), 0.7);\n    col = mix (col, colT, (isBg ? 0.35 : 0.15));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col[2];\n  vec2 canvas, uv;\n  float el, az, zmFac, tCyc;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  mType = M_TYPE;\n  bxLim = (mType == 1) ? 5. : 2.8;\n  if (mType == 1) pFold = HsvToRgb (vec3 (0.5, 0.2, 1.));\n  dstFar = 80.;\n  az = -0.25 * pi;\n  el = 0.;\n  zmFac = (mType == 1) ? 5.6 : 5.2;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    zmFac += (mType == 1) ? 15. * (mPtr.y + 0.5) : 30. * (mPtr.y + 0.5);\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -6.6 * bxLim);\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  ltDir = vuMat * normalize (vec3 (1., 2., -1.));\n  slWid = 0.05;\n  tCyc = 100.;\n  tCur *= 1.5;\n  for (int k = VAR_ZERO; k <= 1; k ++) {\n    slPos = (bxLim - slWid) * (4. * (0.5 - abs (mod ((float (k) +\n       floor (tCur)), tCyc) / tCyc - 0.5)) - 1.);\n    col[k] = ShowScene (ro, rd);\n  }\n  fragColor = vec4 (mix (col[0], col[1], smoothstep (0.1, 0.9, fract (tCur))), 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dlfDH.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[672, 672, 696, 696, 883], [885, 885, 907, 907, 972], [974, 974, 996, 996, 1414], [1416, 1416, 1440, 1440, 1800], [1802, 1802, 1835, 1835, 2289], [2291, 2291, 2312, 2312, 2569], [2571, 2571, 2606, 2606, 3577], [4715, 4715, 4747, 4747, 4847], [4849, 4849, 4873, 4873, 4990], [4992, 4992, 5014, 5014, 5052], [5054, 5054, 5076, 5076, 5114], [5116, 5116, 5152, 5152, 5358], [5360, 5360, 5390, 5390, 5503]], "test": "valid"}
{"id": "3dlfR7", "name": "snowcrash", "author": "blepfo", "description": "snow", "tags": ["random", "static"], "likes": 2, "viewed": 66, "published": "Public", "date": "1587928538", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random(vec2 v, float seed) {\n    return fract(sin(dot(v, vec2(25.2332, 19.399)))*seed);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float randomSeed = 98183.232;\n    \n    float uvScale = 15.;\n    vec2 scaleLayer = uv * uvScale;\n    \n    // Snow = finer resolution than the grid\n    float snowScale = uvScale * 6.;\n    vec2 snowLayer = uv * snowScale;\n    vec2 snowGrid = floor(snowLayer);\n    // Only update snow ever 1s\n    float snowUpdate = floor(iTime);\n    float snow = random(snowGrid * snowUpdate, randomSeed);\n    // gridSquares fall at random speed by row\n    float gridX = floor(scaleLayer.x);\n    float gridY = floor(scaleLayer.y);\n    float gridYSpeed = random(vec2(gridX+1.), randomSeed) * 20.;\n    float minSpeed = 5.;\n    vec2 gridIdx = floor(scaleLayer + vec2(0.0, (gridYSpeed + minSpeed) * iTime));\n    \n    float gridValue = random(gridIdx, randomSeed);\n    gridValue = step(0.756, gridValue);\n    \n    \n    vec3 color = vec3(0.);\n    color = mix(color, vec3(snow), gridValue);\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dlfR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 95], [98, 98, 155, 155, 1148]], "test": "valid"}
{"id": "3dsBRr", "name": "Penumbra Shadows by giaosame", "author": "giaosame", "description": "Implement the penumbra shadows approximation of soft shadows, refer to the code from https://www.shadertoy.com/view/wsjGDG.", "tags": ["3d"], "likes": 1, "viewed": 199, "published": "Public API", "date": "1587608445", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec4 FLOOR_VEC       = vec4(0.0, 1.0, 0.0, 3.0);\nconst vec3 LONG_BOX_POS    = vec3(2.1, -0.5, -2);\nconst vec3 LONG_BOX_SCALE  = vec3(1.5, 3.0, 1.5);\nconst vec3 SPHERE_POS      = vec3(2.2, -1.0, 1.7);\nconst vec3 TORUS_POS       = vec3(0.5, 2.0, 1);\nconst vec2 TORUS_RADIUS    = vec2(1.0, 0.45);\n\nconst vec3 EYE_POS         = vec3(0.0, 2.5, -14.5);\nconst vec3 REF_POS         = vec3(0.0, 2.5, 0.0);\n\nconst int RAY_STEPS     = 256;\nconst int FLOOR_ID      = 0;\nconst int LONG_BOX_ID   = 1;\nconst int SPHERE_ID     = 2;\nconst int TORUS_ID      = 3;\nconst float PI_OVER_180 = 3.1415926 / 180.0;\n\n// The higher the value, the smaller the penumbra\nconst float SHADOW_HARDNESS = 7.0;\n\n// 0 for penumbra shadows, 1 for hard shadows\n#define HARD_SHADOW 0\n\nstruct Intersection\n{\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n};\n\nfloat plane(vec3 p, vec4 n)\n{\n  // n must be normalized\n  return dot(p, n.xyz) + n.w;\n}\n\n// Box with side lengths b\nfloat box(vec3 p, vec3 b)\n{\n  return length(max(abs(p) - b, 0.0));\n}\n\n\nfloat sphere(vec3 p, float r, vec3 c)\n{\n    return distance(p, c) - r;\n}\n\nfloat torus(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nvec3 rotateY(vec3 p, float a) \n{\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\nvec3 rotateX(vec3 p, float amt) \n{\n    return vec3(p.x, cos(amt) * p.y - sin(amt) * p.z, sin(p.y) + cos(p.z));\n}\n\n\nvoid sceneMap3D(vec3 pos, out float t, out int objId)\n{\n    // floor\n    t = plane(pos, FLOOR_VEC);  \n    objId = FLOOR_ID;  \n\n    float t2;\n    if((t2 = box(rotateY(pos + LONG_BOX_POS, 27.5 * PI_OVER_180), LONG_BOX_SCALE)) < t)  // long bix\n    {\n        t= t2;\n        objId = LONG_BOX_ID;\n    }\n    if((t2 = sphere(pos, 2.0, SPHERE_POS)) < t)\n    {\n        t= t2;\n        objId = SPHERE_ID;\n    }\n    if((t2 = torus(pos + TORUS_POS, TORUS_RADIUS)) < t)\n    {\n        t= t2;\n        objId = TORUS_ID;\n    }\n}\n\nfloat sceneMap3D(vec3 pos)\n{\n    float t = plane(pos, FLOOR_VEC);\n    t = min(t, box(rotateY(pos + LONG_BOX_POS, 27.5 * PI_OVER_180), LONG_BOX_SCALE));\n    t = min(t, sphere(pos, 2.0, SPHERE_POS));\n    t = min(t, torus(pos + TORUS_POS, TORUS_RADIUS));\n    return t;\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int objId)\n{\n    t = 0.001;\n    for(int i = 0; i < RAY_STEPS; ++i)\n    {\n        vec3 pos = origin + t * dir;\n        float m;\n        sceneMap3D(pos, m, objId);\n        if(m < 0.01)\n        {\n            return;\n        }\n        t += m;\n    }\n\n    t = -1.0;\n    objId = -1;\n}\n\nvec3 computeMaterial(int objId, vec3 p, vec3 n)\n{\n    switch(objId) \n    {\n    case FLOOR_ID:  // floor\n    {\n        return vec3(1.0, 1.0, 1.0);\n        break;\n    }\n    case LONG_BOX_ID:  // Cuboid, the long box\n    {\n        return vec3(1.0, 0.4, 0.0);\n        break;\n    }\n    case SPHERE_ID:  // Sphere\n    {\n        return vec3(0.0, 1.0, 1.0);\n        break;\n    }   \n    case TORUS_ID:  // Torus\n    {\n        return vec3(0.9, 0.2, 0.9);\n        break;\n    }\n    default:\n        return vec3(0.0);\n        break;\n    }\n\n    return vec3(1.0);\n}\n\nvec3 computeNormal(vec3 pos)\n{\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize(vec3(sceneMap3D(pos + epsilon.yxx) - sceneMap3D(pos - epsilon.yxx),\n                          sceneMap3D(pos + epsilon.xyx) - sceneMap3D(pos - epsilon.xyx),\n                          sceneMap3D(pos + epsilon.xxy) - sceneMap3D(pos - epsilon.xxy)));\n}\n\nfloat hardShadow(vec3 dir, vec3 origin, float min_t)\n{\n    float t = min_t;\n    for(int i = 0; i < RAY_STEPS; ++i)\n    {\n        float m = sceneMap3D(origin + t * dir);\n        if(m < 0.0001) \n        {\n            return 0.0;\n        }\n        t += m;\n    }\n    \n    return 1.0;\n}\n\nfloat softShadow(vec3 dir, vec3 origin, float min_t, float k) \n{\n    float res = 1.0;\n    float t = min_t;\n    for(int i = 0; i < RAY_STEPS; ++i) \n    {\n        float m = sceneMap3D(origin + t * dir);\n        if(m < 0.0001) \n        {\n            return 0.0;\n        }\n        \n        res = min(res, k * m / t);\n        t += m;\n    }\n    \n    return res;\n}\n\nfloat shadow(vec3 dir, vec3 origin, float min_t) \n{\n    #if HARD_SHADOW\n    return hardShadow(dir, origin, min_t);\n    #else\n    return softShadow(dir, origin, min_t, SHADOW_HARDNESS);\n    #endif\n}\n\n\nIntersection sdf3D(vec3 dir, vec3 eye)\n{\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj);\n\n    vec3 isect = eye + t * dir;\n    vec3 nor = computeNormal(isect);\n    \n    vec3 material = computeMaterial(hitObj, isect, nor);\n    \n    vec3 warmDir = rotateY(normalize(vec3(1.0, 1.0, 1.0)), sin(iTime * 0.5));\n    vec3 coolDir = rotateY(normalize(vec3(-1.0, 0.0, -1.0)), sin(iTime * 0.5));\n\n    float warmDot = max(0.0, dot(nor, warmDir));\n    float coolDot = max(0.0, dot(nor, coolDir));\n\n    vec3 overallColor = warmDot * vec3(1.0, 0.88, 0.7) * shadow(warmDir, isect, 0.1);\n    overallColor += coolDot * vec3(0.05, 0.2, 0.5);\n    overallColor *= material;\n    overallColor = clamp(overallColor + vec3(0.05, 0.1, 0.15), 0.0, 1.0);\n    \n    vec3 sdfColor = overallColor;\n    \n    return Intersection(t, sdfColor, isect, hitObj);\n}\n\nvoid raycast(vec2 uv, out vec3 dir, out vec3 eye, out vec3 ref)\n{\n    eye = EYE_POS;\n    ref = REF_POS;\n    \n    float len = tan(3.14159 * 0.125) * distance(eye, ref);\n    vec3 H = normalize(cross(vec3(0.0, 1.0, 0.0), ref - eye));\n    vec3 V = normalize(cross(H, eye - ref));\n    V *= len;\n    H *= len * float(iResolution.x) / float(iResolution.y);\n    vec3 p = ref + uv.x * H + uv.y * V;\n    dir = normalize(p - eye);\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // [-1, 1]\n    vec2 uv2 = 2.0 * uv - vec2(1.0);\n\n    vec3 dir, eye, ref;\n    raycast(uv2, dir, eye, ref);\n    Intersection intersection = sdf3D(dir, eye);\n\n    // Output to screen    \n    fragColor = vec4(intersection.color * step(0.0, intersection.t), 1.0);\n    float fogT = smoothstep(30.0, 50.0, distance(intersection.p, eye));\n    fragColor.rgb = mix(fragColor.rgb, vec3(0.0), fogT);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dsBRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[835, 835, 864, 890, 922], [924, 951, 978, 978, 1019], [1022, 1022, 1061, 1061, 1094], [1096, 1096, 1125, 1125, 1199], [1201, 1201, 1233, 1233, 1316], [1318, 1318, 1352, 1352, 1430], [1433, 1433, 1488, 1501, 1943], [1945, 1945, 1973, 1973, 2212], [2214, 2214, 2277, 2277, 2542], [2544, 2544, 2593, 2593, 3094], [3096, 3096, 3126, 3126, 3439], [3441, 3441, 3495, 3495, 3722], [3724, 3724, 3788, 3788, 4081], [4083, 4083, 4134, 4134, 4280], [4283, 4283, 4323, 4323, 5120], [5122, 5122, 5187, 5187, 5543], [5546, 5546, 5603, 5653, 6087]], "test": "error"}
{"id": "3dsBW8", "name": "simple Lava lamp", "author": "iyadahmed", "description": "please comment and like ^_", "tags": ["procedural", "lava", "aniamted"], "likes": 0, "viewed": 64, "published": "Public", "date": "1588142722", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//adapted from https://gist.github.com/thomaswilburn/b9f049875c251496b8143bd86ab587eb\nprecision highp float;\n\nconst vec3 top = vec3(.8, .7, .7);\nconst vec3 bottom = vec3(.9, .7, .7);\nconst vec3 plastic = vec3(.8, .2, .1);\nfloat rand(float seed) {\n  return fract(sin(dot(vec2(12.87042, 48.382097), vec2(seed, seed + 40238.842))) * 479283.48293);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\n  vec2 coord = fragCoord.xy / iResolution.x;\n  float aspect = iResolution.x / iResolution.y;\n  coord.x *= aspect;\n  float t = iTime * 0.3;\n  float d = 0.0;\n  for (float i = 0.0; i < 12.0; i++) {\n    vec2 center = vec2(\n      cos(rand(i - rand(i)) + i - t * (rand(i) - .5)) * .5 + .5 * aspect,\n      sin(rand(i + rand(i)) + i + t * rand(i)) * .5 + .5\n    );\n    float size = i * 0.02;\n    d += smoothstep(.9, .7, distance(center, coord) / size);\n  }\n  float lava = step(d, .4);\n  vec3 foreground = mix(plastic * (.8 + smoothstep(.1, .9, d) * .2), vec3(1.0), .3 - coord.y * .3);\n  vec3 background = mix(bottom, top, coord.y);\n  vec3 color = mix(foreground, background, lava);\n  fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dsBW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[222, 222, 246, 246, 346], [348, 348, 405, 405, 1119]], "test": "valid"}
{"id": "3dscDl", "name": "Square + Circle contour ", "author": "plosique", "description": "Performs a ternary search to find the minimum distance to point from a given contour. The contour smoothly transitions from a square to a circle using a homotopic function which is just an interpolated contour.", "tags": ["complex", "ternarysearch"], "likes": 2, "viewed": 87, "published": "Public", "date": "1585852556", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi=acos(-1.);\n\n\n//convert distance to smoothly produce line color if within a\n//certain threshold\nvec3 line(float dist){ \n    \n    return 1.0-vec3(smoothstep(0.,0.05,abs(dist)));\n}\n\n//Homotopic function that transtions from circle contour when s=0 \n//to square contour when s=1 on the 0 to pi/8 region (for variable t) \nvec2 h(float s,float t){ \n    return vec2(s+(1.-s)*cos(2.*pi*t),s*t/(pi/8.)+(1.-s)*sin(2.*pi*t));\n} \n//Ternary search for point and an s defining the current contour\n//to find the minimum distance to the contour.\n//Assuming distance to contour for a fixed point is convex within the region\n//It should be for this specific case.\nfloat ternary(float s,vec2 z){\n    //map z to within the pi/8 region\n    z=abs(z);\n    if(z.y>z.x){ \n        z=z.yx;\n    } \n    float l=0.;\n    float r=pi/8.;\n    float m1,m2;\n    vec2 contour1,contour2;\n    float mindist; \n    for(int i=0;i<30;i++){\n        m1=l+(r-l)/3.;\n        m2=r-(r-l)/3.;\n        contour1=h(s,m1);\n        contour2=h(s,m2); \n        float f1=length(z-contour1); \n        float f2=length(z-contour2);\n        if(f1<f2){ \n            r=m2;\n            mindist=f1;\n        }else{\n            l=m1; \n            mindist=f2;\n        } \n    } \n    return mindist;\n}\n        \n        \n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    vec2 z=2.*uv-vec2(iResolution.x/iResolution.y,1.);\n    z*=1.3;\n    float dist=ternary(abs(sin(pi*iTime/10.)),z); \n    vec3 col=line(dist); \n\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dscDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 110, 132, 132, 192], [194, 332, 356, 356, 431], [433, 661, 691, 729, 1245], [1268, 1268, 1325, 1375, 1622]], "test": "error"}
{"id": "3dScDW", "name": "flower_01", "author": "bhuwan0000", "description": "just playing with art :)", "tags": ["flower", "random"], "likes": 1, "viewed": 40, "published": "Public", "date": "1586610591", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265358979323846\n\nfloat circle(vec2 st, float r, float i, float aa)\n{\n    r = r+i*abs(sin(6.0\n                    *atan(st.y, st.x)\n                    +iTime*1.));\n    float d = length(st);\n    float d1 = smoothstep(r, r-aa, d);//d<r?1.0:0.0;\n    float d2 = smoothstep(r, r-aa, d+0.02);//d<r-0.01?1.0:0.0;\n    return d1-d2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(uv, 0.0);\n    float mus = texelFetch(iChannel0, ivec2(1, 0), 0).x;\n    mus *= .5;\n    \n    //circle\n    float amp = 0.01;\n    float aa = 0.1+\n        \t\tpow( (0.5+0.5*sin(PI*iTime+uv.y)), 4.)\n        \t\t*0.1;\n    float cir1 = 0.;//circle(uv, 0.3, amp, aa);\n    for (float i=0.1; i<0.27; i+=0.04)\n    \tcir1 += circle(uv, i, amp, aa);\n\t\n    float cir2 = circle(uv, 0.4, amp+0.1, aa+0.02);\n    cir1 += cir2;\n    // Output to screen\n    vec3 A = vec3(0.8, 0.6, 0.1)*(1.0-length(uv));\n    vec3 B = vec3(0.1, 0.1, 0.5);\n    col = mix(B, A, (1.0-cir1)*(2.3));\n    col = clamp(col, 0.0, 1.0);\n    \n    //gamma correction\n    col *= 0.8+mus*0.4;\n    //col = pow(col, vec3(1./2.4));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dScDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 86, 86, 343], [345, 345, 402, 452, 1236]], "test": "error"}
{"id": "3dScRc", "name": "Slime Cube", "author": "donnerbrenn", "description": "Simple raymarching scene featuring a cube, sofshadows and some nice ligthning. My very first attempt in raymarching.", "tags": ["raymarching", "cube", "spheretracing"], "likes": 7, "viewed": 273, "published": "Public API", "date": "1587033515", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//rotate a vector... Not very happy with this huge function...\nmat3 rotateXYZ(vec3 t)\n{\n      float cx = cos(t.x);\n      float sx = sin(t.x);\n      float cy = cos(t.y);\n      float sy = sin(t.y);\n      float cz = cos(t.z);\n      float sz = sin(t.z);\n      mat3 m=mat3(\n        vec3(1, 0, 0),\n        vec3(0, cx, -sx),\n        vec3(0, sx, cx));\n\n      m*=mat3(\n        vec3(cy, 0, sy),\n        vec3(0, 1, 0),\n        vec3(-sy, 0, cy));\n\n      return m*mat3(\n        vec3(cz, -sz, 0),\n        vec3(sz, cz, 0),\n        vec3(0, 0, 1));\n}\n\n//SDF-Functions\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\nfloat softmin(float f1, float f2, float val)\n{\n      float e = max(val - abs(f1 - f2), 0.0);\n      return min(f1, f2) - e*e*0.25 / val;     \n}\n\nfloat map(vec3 p)\n{\n      vec3 rotPlane=(rotateXYZ(vec3(1.5,.0,.0))*p);\n      vec3 rotCube=(rotateXYZ(vec3(1,iTime,sin(iTime*.5)*.5))*p);\n      float myplane=sdRoundBox(rotPlane-vec3(.0,.0,1.5),vec3(20.,20,.01),.1);\n      float mycube=sdRoundBox(rotCube+vec3(0.,.5,0.),vec3(.75/2.),.1);\n      return(softmin(myplane,mycube,1.));\n}\n\n\nvec3 normal(vec3 p)\n{\n      vec2 eps=vec2(.005,0);\n      return normalize(vec3(map(p+eps.xyy)-map(p-eps.xyy),\n                            map(p+eps.yxy)-map(p-eps.yxy),\n                            map(p+eps.yyx)-map(p-eps.yyx)));\n}\n\n// LIGHT\nfloat diffuse_directional(vec3 n,vec3 l, float strength)\n{\n      return (dot(n,normalize(l))*.5+.5)*strength;\n}\n\nfloat specular_directional(vec3 n, vec3 l, vec3 v, float strength)\n{\n      vec3 r=reflect(normalize(l),n);\n      return pow(max(dot(v,r),.0),128.)*strength;\n}\n\nfloat ambient_omni(vec3 p, vec3 l)\n{\n      float d=1.-abs(length(p-l))/100.;\n      return pow(d,32.)*1.5;\n}\n\n\n\n//SHADOW\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t);\n        if( h<0.0001 )\n            return .0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\n// MAINLOOP\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{  \n    vec2 uv= fragCoord.xy/iResolution.xy-.5;\n    uv.x/=iResolution.y/iResolution.x;\n    vec3 ro=vec3(.0,.0,-3.5); \n    vec3 p=ro;\n    vec3 rd=normalize(vec3(uv,1.));\n    float shading=.0;\n    bool hit=false;\n\n    vec3 color;\n    while(p.z<20.)\n    {\n        float d=map(p);\n        if(d<.0001)\n        {\n            hit=true;\n            break;\n        }\n        p += rd*d;\n    }\n\n    float t=length(ro-p);\n    if (hit)\n    {\n        shading=length(p*10.);\n        vec3 n=normal(p);\n        vec3 l1=vec3(1,.5,-.25);\n        float rl=ambient_omni(p,l1)*diffuse_directional(n,l1,.5)+specular_directional(n,l1,rd,.9);\n        color=vec3(rl)+vec3(.1,.4,.1);\n        color*=color;\n        vec3 pos = ro + t*rd;\n        color=mix(vec3(.0),color,softshadow(pos,normalize(l1),.01,10.0,20.)*.25+.75);\n    }\n    color*=mix(color,vec3(1.,1.,1.),1.-exp(-.1*pow(t,128.)));\n    color-=t*.05;\n    color=sqrt(color);\n\n    fragColor=vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dScRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 63, 87, 87, 533], [535, 551, 596, 596, 687], [690, 690, 736, 736, 832], [834, 834, 853, 853, 1164], [1167, 1167, 1188, 1188, 1398], [1400, 1409, 1467, 1467, 1520], [1522, 1522, 1590, 1590, 1680], [1682, 1682, 1718, 1718, 1789], [1793, 1802, 1879, 1879, 2205], [2207, 2219, 2275, 2275, 3211]], "test": "valid"}
{"id": "3dScRR", "name": "Flower-like Fractal", "author": "kruzifix", "description": "Fractal created by folding space multiple times along different normals and then applying the sdf of a box.", "tags": ["raymarching"], "likes": 2, "viewed": 69, "published": "Public", "date": "1585916179", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Source Material:\n// Great source for all kinds of computer graphics stuff: http://iquilezles.org/\n// Fractals: http://blog.hvidtfeldts.net/index.php/2011/06/distance-estimated-3d-fractals-part-i/\n\n// Videos:\n// Ray marching setup and HDR colors: https://www.youtube.com/watch?v=Cfe5UQ-1L9Q\n// SDF maths: https://www.youtube.com/watch?v=sl9x19EnKng\n\nfloat boxSDF(in vec3 p, in vec3 r)\n{\n    return length(max(abs(p) - r, 0.0));\n}\n\nvec3 fold3(in vec3 p, in vec3 n)\n{\n    return p - 2.0 * min(0.0, dot(p, n)) * n;\n}\n\n// Signed distance function that describes the scene\nfloat sceneSDF(in vec3 pos)\n{    \n    for (int i = 0; i < 15; ++i)\n    {\n        float t = float(i) * 1.0 + cos(iTime) * 0.18;\n        vec3 n = normalize(vec3(cos(t), sin(t), sin(t)));\n        \n        pos = fold3(pos, n);\n        \n        if (mod(float(i), 2.0) < 1.0)\n        {\n            float x = n.x;\n            n.x = n.z;\n            n.z = x;\n            pos = fold3(pos, n);\n        }\n    }\n    \n    vec3 off = vec3(1.8, 0, 0);\n    return boxSDF(pos - off, vec3(2.7, 0.2, 0.3)) - 0.3;\n}\n\n// Approximates the normal of the surface at the given position\n// by calculating the gradient of the scene SDF\nvec3 calcNormal(in vec3 pos)\n{\n    vec2 e = vec2(0.0001, 0.0);\n    \n    return normalize(vec3(\n        sceneSDF(pos + e.xyy) - sceneSDF(pos - e.xyy),\n        sceneSDF(pos + e.yxy) - sceneSDF(pos - e.yxy),\n        sceneSDF(pos + e.yyx) - sceneSDF(pos - e.yyx)));\n}\n\n// Returns the distance to scene surface.\n// If the ray hit nothing this returns -1.0\nfloat rayMarchScene(in vec3 rayOrigin, in vec3 rayDir)\n{\n    float t = 0.0;\n    for (int i = 0; i < 100; ++i)\n    {\n        vec3 pos = rayOrigin + rayDir * t;\n        \n        float dist = sceneSDF(pos);\n        t += dist;\n        if (dist < 0.00001)\n            break;\n        if (t > 100.0)\n            return -1.0;\n    }\n    \n    return t;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    //vec2 mouse = vec2(0.5, 1.0);\n    float time = mouse.x * 6.28;//iTime * 0.2;\n    float cameraDist = 2.6;\n    float upDownAngle = mouse.y-0.6;\n    \n    vec3 rayOrigin = vec3(cos(time), sin(upDownAngle)*1.2, sin(time)) * cameraDist;\n    vec3 lookAtPos = vec3(0.0, 0.6, 0.0);\n    \n    vec3 forward = normalize(lookAtPos - rayOrigin);\n    vec3 right = cross(forward, vec3(0.0, 1.0, 0.0));\n    vec3 up = cross(right, forward);\n    \n    vec3 rayDir = normalize(forward + right * uv.x + up * uv.y);\n    \n    float t = rayMarchScene(rayOrigin, rayDir);\n    \n    // Skybox color\n    vec3 skyCol = vec3(0.5, 0.2, 0.1) + rayDir.y * 0.1;\n    vec3 col = skyCol;\n    if (t > 0.0)\n    {\n        vec3 surfacePos = rayOrigin + rayDir * t;\n        vec3 normal = calcNormal(surfacePos);\n        \n        col = normal;\n        col.x = abs(col.x);\n        col.z = -abs(col.z);\n        col *= 0.5;\n        col += 0.5;\n    }\n    \n    // Gamma correction\n    col = pow(col, vec3(0.4545));    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dScRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[352, 352, 388, 388, 431], [433, 433, 467, 467, 515], [517, 570, 599, 599, 1065], [1067, 1179, 1209, 1209, 1442], [1444, 1530, 1586, 1586, 1874], [1876, 1876, 1931, 1931, 3051]], "test": "valid"}
{"id": "3dscWs", "name": "yardthinkexperiment", "author": "yardthink", "description": "test experiment", "tags": ["test"], "likes": 0, "viewed": 58, "published": "Public", "date": "1585859291", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int N = 99;\n//const vec2 center = vec2(-0.1599, 1.0409);\n//const vec2 center =  vec2(-0.749608,0.1003); // seahorse valley\nconst vec2 center = vec2( -0.235125, 0.827215);\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 getColor(int n, vec2 zn)\n{\n    //https://stackoverflow.com/questions/369438/smooth-spectrum-for-mandelbrot-set-rendering\n    float sn = (float(n) + 1.0 - log(log(length(zn)))/log(2.0))/float(N);\n\treturn vec4(hsv2rgb(vec3(sn,1,1)), 1);\n}\n\nvec4 mandel(in vec2 c)\n{\n    vec2 z = c;\n    int i;\n    vec4 color;\n    for (int j = 0; j < N; j++) {\n        i = j;\n\t\tif (length(z) > 2.2)\n            break;\n        z = vec2(z.x*z.x - z.y*z.y + c.x, \n                 2.0*z.x*z.y + c.y);   \t    \n    }\n\n    if (i >= N)\n        color = vec4(0,0,0,1);\n   \telse\n        color = getColor(i, z);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = fragCoord/iResolution.xy;\n\t// origo lower left, x right, y up\n    float ci = 2.5/cosh(iTime/4.0);\n    vec2 wh = ci*vec2(3,2);\n    vec2 c = center - wh*0.5 + p*wh; \n    // Output to screen\n    fragColor = mandel(c);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dscWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[177, 177, 199, 199, 368], [613, 613, 637, 637, 974], [976, 976, 1033, 1083, 1313]], "test": "valid"}
{"id": "3dsfW8", "name": "Drowning_1", "author": "postpoptart", "description": "swim into the light", "tags": ["intro"], "likes": 4, "viewed": 131, "published": "Public", "date": "1588148713", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"Experiment_1\" by okh0056. https://shadertoy.com/view/wd2czc\n// 2020-04-29 08:23:23\n\n\n#define t iTime\n#define r iResolution.xy\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec3 c;\n\tfloat l,z=t;\n    for(float j=0.0;j<4.3;j+=.1) {\n\t    for(int i=0;i<3;i++) {\n\t\t    vec2 uv,p=fragCoord.xy/r;\n\t\t    uv=p;\n\t\t    p-=.5;\n\t\t    p.x*=r.x/r.y;\n\t\t    z+=0.3;\n\t\t    l=length(p);\n            uv+=p/l*(sin(z)+(j/((sin(t*.1)+.001)*4.)))*abs(sin((l*j)+z*(j+0.6)));\n\t\t    c[i]=.02/length(abs(mod(uv,1.)-2.7/j));\n        }\n\t}\n\tfragColor=vec4(c/l,t);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dsfW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[139, 139, 195, 195, 558]], "test": "valid"}
{"id": "3dSyDD", "name": "Individual Project", "author": "JonathanAlderson", "description": "Just to show how simple functions can be combined to achieve nice shader results", "tags": ["education"], "likes": 3, "viewed": 102, "published": "Public", "date": "1586619960", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Coordinate Scaling\n\tvec2 uv = (fragCoord - .5*iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    // polar coordinates\n    float theta = atan(uv.y / uv.x);\n    float r = length(uv) - .1*iTime;\n    \n    // repeats\n    float d = 0.1; \n    \n\t// get ID\n    float ringID = floor(r / d);\n    // Make every other ID negative\n    if(mod(ringID, 2.0) == 1.0){ ringID *= -1.; }\n    \n    // Colouring with polar coordinates\n    // and spinning from ring number\n    float l = mod(r, d) * sin(theta*20. + iTime*ringID);\n    \n    // Ring colouring\n   \tvec3 colour = vec3(1., cos(ringID), sin(ringID));   // red\n    float strength = l / d;                           // Will give 1 when l = d and 0 when l = 0\n    \n    // smooth step shadows\n    strength *= smoothstep(0.1, 0.3, length(uv)) * smoothstep(0.9, 0.5, length(uv));\n    \n    // final colour\n    fragColor.xyz = colour * strength;\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dSyDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 83, 951]], "test": "valid"}
{"id": "3dsyDl", "name": "Ray Marching Hello World", "author": "Ractive", "description": "learn from http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/", "tags": ["raymarching"], "likes": 3, "viewed": 111, "published": "Public", "date": "1585847521", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 200\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat boxSDF(vec3 p, vec3 size) {\n    vec3 d = abs(p) - (size / 2.0);\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\nfloat cubeSDF( vec3 p)\n{\n  vec3 q = abs(p) - 1.;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat cylinderSDF(vec3 p, float h, float r) {\n    float inOutRadius = length(p.xy) - r;\n    float inOutHeight = abs(p.z) - h/2.0;\n    float insideDistance = min(max(inOutRadius, inOutHeight), 0.0);\n\n    float outsideDistance = length(max(vec2(inOutRadius, inOutHeight), 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\nfloat ballOffset(float offset){\n    return 0.4 + 1.0 + sin(1.7 * iTime+offset*3.1415926);\n}\n\nfloat sceneSDF(vec3 samplePoint) {\n    samplePoint = rotateY(iTime / 2.0) * samplePoint;\n    \n    float cylinderRadius = 0.4 + (1.0 - 0.4) * (1.0 + sin(1.7 * iTime)) / 2.0;\n    float cylinder1 = cylinderSDF(samplePoint, 2.0, cylinderRadius);\n    float cylinder2 = cylinderSDF(rotateX(radians(90.0)) * samplePoint, 2.0, cylinderRadius);\n    float cylinder3 = cylinderSDF(rotateY(radians(90.0)) * samplePoint, 2.0, cylinderRadius);\n    \n    float cube = boxSDF(samplePoint, vec3(1.8, 1.8, 1.8));\n    \n    float sphere = sphereSDF(samplePoint, 1.2);\n\n    float ballRadius = 0.3;\n    \n    float balls = sphereSDF(samplePoint - vec3(ballOffset(1.), 0.0, 0.0), ballRadius);\n    balls = unionSDF(balls, sphereSDF(samplePoint + vec3(ballOffset(1.), 0.0, 0.0), ballRadius));\n    balls = unionSDF(balls, sphereSDF(samplePoint - vec3(0.0, ballOffset(2.), 0.0), ballRadius));\n    balls = unionSDF(balls, sphereSDF(samplePoint + vec3(0.0, ballOffset(2.), 0.0), ballRadius));\n    balls = unionSDF(balls, sphereSDF(samplePoint - vec3(0.0, 0.0, ballOffset(3.)), ballRadius));\n    balls = unionSDF(balls, sphereSDF(samplePoint + vec3(0.0, 0.0, ballOffset(3.)), ballRadius));\n\n    \n    float csgNut = differenceSDF(intersectSDF(cube, sphere),\n                         unionSDF(cylinder1, unionSDF(cylinder2, cylinder3)));\n    \n    return unionSDF(balls, csgNut);\n}\n\nfloat GetDist(vec3 p) {\n    \n    float planeDist = p.y+1.8;\n    float fScene=sceneSDF(vec3(p.x,p.y-1.,p.z));\n\n    float n=min(planeDist,fScene);\n    return n;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n    float dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 phongContribForLight(vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n                         \n    vec3 k_a = vec3(0.2, 0.2, 0.2);\n    vec3 k_d = vec3(1, 1, 1);\n    vec3 k_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    vec3 N = GetNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = clamp(dot(L, N),0.,1.);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, shininess));\n}\n\nvec3 phongIllumination(vec3 p, vec3 eye) {\n    vec3 k_a = vec3(0.2, 0.2, 0.2);\n    const vec3 ambientLight = 0.6 * vec3(1.0, 0.8, 1.0);\n    vec3 color = ambientLight * k_a*1.;\n    \n    vec3 light1Pos = vec3(2.0 * sin(iTime),\n                          2.0,\n                          2.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.3, 0.4, 0.9);\n    \n    color += phongContribForLight(p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.7, 0.4, 0.3);\n    \n    color += phongContribForLight(p, eye,\n                                  light2Pos,\n                                  light2Intensity);  \n    vec3 light3Pos = vec3(0.0 * sin(0.37 * iTime),\n                          -2.0 * cos(0.37 * iTime),\n                          -2.0);\n    vec3 light3Intensity = vec3(0.7, 0.4, 0.3);\n    \n    color += phongContribForLight(p, eye,\n                                  light3Pos,\n                                  light3Intensity);    \n                                  \n    return color;\n}\n\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 3, 3);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 lightPos2 = vec3(0, 1, 3);\n    lightPos2.xz += vec2(sin(iTime+1.), cos(iTime+1.))*2.;\n    vec3 l = normalize(lightPos-p);\n    vec3 l2 = normalize(lightPos2-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    if(d<length(lightPos-p)) dif *= .1;\n    if(d<length(lightPos2-p)) dif +=clamp(dot(n, l2), 0., 1.)*.1;\n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 1, -5);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n\n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d;\n    \n    float dif = GetLight(p);\n    col=phongIllumination(p,ro);\n    //col = vec3(dif);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dsyDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 95, 95, 242], [244, 244, 271, 271, 418], [421, 421, 467, 467, 499], [501, 501, 543, 543, 575], [577, 577, 624, 624, 657], [659, 659, 693, 693, 721], [723, 723, 756, 756, 956], [958, 958, 982, 982, 1070], [1072, 1072, 1117, 1117, 1400], [1402, 1402, 1433, 1433, 1493], [1495, 1495, 1529, 1529, 2841], [2843, 2843, 2866, 2866, 3003], [3006, 3006, 3040, 3040, 3252], [3254, 3254, 3278, 3278, 3470], [3472, 3472, 3579, 3579, 4176], [4178, 4178, 4220, 4220, 5390], [5393, 5393, 5417, 5417, 5916], [5918, 5918, 5975, 5975, 6332]], "test": "valid"}
{"id": "3dSyRV", "name": "Gaming cube:234chars", "author": "butadiene", "description": "226chars  https://twitter.com/butadiene121/status/1250237898214928384?s=20", "tags": ["raymarching", "codegolf"], "likes": 1, "viewed": 294, "published": "Public API", "date": "1586925844", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define l iTime\nvoid mainImage(out vec4 o,vec2 u){vec3 p=vec3(0),e,d=vec3(u/5e2-.5,.3);p.z+=l;for(int i=0;i<99;i++)p.yz+=.01*sin(p.zy+l),e.x=length(max(abs(mod(p,.8)-.4)-.2-.1*step(.5,sin(l)),0.)),p+=d*e.x;o=vec4(12.*e.x*sin(l+p),1);}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dSyRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[16, 16, 50, 50, 234]], "test": "valid"}
{"id": "3dSyWV", "name": "Interactive Droste Spiral", "author": "mla", "description": "A variation on @RadoKirov's [url]https://www.shadertoy.com/view/3sjyWG[/url], also incorporating many of Fabrice's suggestions.\n\nMouse sets spiral parameters, t,g,h,z also do things, see code. ", "tags": ["spiral", "droste"], "likes": 21, "viewed": 434, "published": "Public API", "date": "1587310896", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Interactive Droste spiral\n// Matthew Arcus, mla, 2020\n//\n// Derived from @FabriceNeyret2's reworking of @RadoKirov's original:\n// https://www.shadertoy.com/view/3sjyWG\n//\n// Parameterized things, added mouse control etc.\n//\n// <mouse>: horizontal = scale factor, vertical = number of spirals\n// t: use texture\n// g,h: show major and minor grids\n// z: autozoom\n//\n////////////////////////////////////////////////////////////////////////////////\n\nint AA = 2;\n\nfloat N = 1.0;\n// There are M spirals\nfloat M = 2.0;\n// Scale factor for each turn\nfloat X = 2.0, logX = log(2.0);\n\n// Grid dimensions\nfloat majorGrid = 2.0;\nfloat minorGrid = 4.0;\nconst float speed = 3.0;\nconst float PI = 3.1415927;\n\nfloat grid(vec2 uv, float g, float r) {\n  uv *= g;\n  vec2  a = abs(fract(uv+0.5)-0.5);\n  // Antialiasing by Fabrice. Thanks.\n  float m = min(a.x,a.y)-r;\n  return smoothstep(-g,g,m*100.0*log(X*length(gl_FragCoord)));\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n  return z.x*w + vec2(-z.y*w.y,w.x*z.y);\n}\n\nvec2 polar(vec2 z) {\n  return vec2(log(length(z)), atan(z.y, z.x));\n}\n\nvec2 cartesian(vec2 z) {\n  return exp(z.x) * normalize(vec2(cos(z.y),sin(z.y)));\n}\n\nconst int CHAR_D = 68;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_M = 77;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_Z = 90;\n\nbool key(int key) {\n  return texelFetch(iChannel3,ivec2(key,2),0).x != 0.0;\n}\n\n// Smooth HSV to RGB conversion \n// Function by iq, from https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb(in vec3 c) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 getcolor(vec2 z) {\n  vec3 col = vec3(1);\n  col = hsv2rgb(vec3(0.5*z+0.5,1));\n  if (key(CHAR_T)) col = texture(iChannel0,0.5*z+0.5).xyz;\n  if (!key(CHAR_G)) col *= grid(z,majorGrid,0.06);\n  if (!key(CHAR_H)) col *= grid(z,minorGrid,0.06);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n  vec2 m = vec2(0);\n  if (iMouse.x > 0.0) {\n    m = iMouse.xy/iResolution.xy;\n  }\n  X = 2.0+floor(16.1*m.y);\n  logX = log(X);\n  majorGrid = X;\n  minorGrid = 4.0*X;\n  M = floor(16.1*(m.x-0.5));\n  float t = iTime / speed;\n  vec3 col = vec3(0);\n  for (int i = 0; i < AA; i++) {\n    for (int j = 0; j < AA; j++) {\n      vec2 z = (2.0 * (fragCoord+vec2(i,j)/float(AA)) - iResolution.xy) / iResolution.y;\n      if (key(CHAR_Z)) z *= exp(-t); // Zooming it\n      vec2 e = vec2(N,M*logX/PI/2.0);\n      z = cmul(polar(z),e);\n      z = cartesian(z);\n      z /= exp(mod(t,logX));\n      // Multiply z to bring it into range, ie. find power of\n      // X that brings max(x,y) into range 1..X\n      float tt = ceil(log(max(abs(z.x),abs(z.y)))/logX);\n      z *= pow(X,-tt);\n      col += getcolor(z);\n    }\n  }\n  fragColor = vec4(col/float(AA*AA),1);\n}\n", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}, {"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dSyWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[780, 780, 819, 819, 997], [999, 999, 1026, 1026, 1069], [1071, 1071, 1091, 1091, 1140], [1142, 1142, 1166, 1166, 1224], [1457, 1457, 1476, 1476, 1534], [1536, 1631, 1656, 1656, 1832], [1834, 1834, 1857, 1857, 2092], [2094, 2094, 2147, 2147, 2984]], "test": "error"}
{"id": "3dSyzh", "name": "Heritable xenobiotic (edit 2)", "author": "jarble", "description": "Here's another edit of the [url=https://www.shadertoy.com/view/tdlyD2]\"Heritable xenobiotic\"[/url] shader. I only modified the \"sph\" function to change the geometry.", "tags": ["raymarching"], "likes": 0, "viewed": 198, "published": "Public API", "date": "1586028068", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//-------------------------------------------------------------------\n// Trying out ShaderToy and trying to get to grips with ray marching.\n// Inspired by the amazing creations of Evvvvil, Nusan and Shane\n//-------------------------------------------------------------------\n\n#define MD 30.\t\t// max distance\n#define SD 0.0001    // surface distance\n#define MS 250      // max number of steps to march\n#define EPS 0.0001   // distance used for sampling the gradient\n\nfloat time;\n\n// always handy to have PI available\nconst float PI = acos(-1.);\nconst float TWOPI = 2.*PI;\n\n// fog color.\nconst vec3 fog = vec3(.05,.25, .05);\n\n// always need some glow!\nfloat glw = 0.;\n\n// sphere SDF\nfloat sph(vec3 p, float r){return length(p)-r/sin(p.y);}\n\n// min and max which preserve material\nvec2 mmin(vec2 a, vec2 b) {return a.x < b.x ? a:b;}\nvec2 mmax(vec2 a, vec2 b) {return a.x > b.x ? a:b;}\n\n\n// 2d rotation\nvoid rot(inout vec2 p, float a) {\n    float c=cos(a), s=sin(a);\n    p *= mat2(c,-s,s,c);\n}\n\n// I was going to do something complicated here,\n// but ended up doing a sphere!\nvec2 prim(vec3 p) {\n    return vec2(sph(p, .5), 5);\n}\n\n// the SDF for the scene\nvec2 map(vec3 p) {\n    \n    // wiggle x\n    p.x += sin(p.z + time*.2)*.5;\n    // spiral\n    rot(p.xy, sin(p.z / 3.));\n    // scroll along z\n    p.z -= time/3.;\n    \n    // repeat everything\n    vec3 mp;\n    mp.x = mod(p.x, 2.3)-1.15;\n    mp.y = mod(p.y, 2.3)-1.15;\n    mp.z = mod(p.z,.6)-.3;\n    \n    // fractal (ish)\n    vec4 ap = vec4(mp,1.);\n    // big purple sphere\n    vec2 a=prim(mp);\n    a.x *= .6;\n    // smaller black spheres\n    int n=4;\n    for(int i=1; i<=n; ++i) {\n    \tap *= 2.5; // scale\n        ap.xyz = abs(ap.xyz)-vec3(.8); // symmetry\n        rot(ap.xy, ap.z*.1 + time*.5); // movement\n        vec2 b = prim(ap.xyz); // sphere\n        b.x /= ap.w; // correct for scaling\n        b.x *= .6;   // patch up the SDF\n        b.y= 1.;     // paint it black\n        a=mmin(a, b);\n        \n    }\n    \n    // Sparkles. Lots of them.\n    rot(p.xy, time*.3);\n    vec2 b = vec2(length(cos(p*1.+vec3(1.5+p.z*.05*sin(time),1.7+sin(time)*.2,time*2.)))-.001 ,6.);\n    glw += .1/(.1*b.x*b.x*10000.);\n    b.x *= .6;\n    \n    // final distance\n    vec2 d=mmin(a,b);\n    return d;\n}\n\n// determine the normal at point p by sampling the gradient of the SDF\nvec3 normal(vec3 p) {\n \tvec2 off = vec2(EPS, 0.);\n    return normalize(map(p).x - vec3(map(p-off.xyy).x,map(p-off.yxy).x,map(p-off.yyx).x));\n}\n\n//-------------------------------------------------------------\n// lighting and colour,\n// heavily based on Evvvvil's Micro Lighting Engine Broski (TM)\n//-------------------------------------------------------------\n\n// shortcuts for calculating fake ambient occlusion and subsurface scattering\n#define aoc(d) clamp(map(p + n * d).x/d, 0., 1.)\n#define sss(d) smoothstep(0.,1.,map(p+ld*d).x/d)\n\nvec3 surface(vec3 ro, vec3 rd, vec2 hit) {\n\tfloat d=hit.x;         // distance from ray origin\n    float m = hit.y;       // materialID\n    \n    // albedo, or base color, based on material ID\t\n    vec3 al = m < 5. ? vec3(0) : \n    \t\tm > 5. ? vec3(1) :\n    \t\tvec3(.1,.1,.4);\n    \n    vec3 p = ro + rd * d;  // the point in space\n    vec3 n = normal(p);    // normal of the SDF at point p\n    \n    vec3 ld = normalize(vec3(-1));     // light direction\n    float diff = max(0., dot(n, -ld)); // diffuse illumination\n    \n    vec3 lr = reflect(ld, n);          // reflected light ray\n    float spec = pow(max(0., dot(lr,-rd)),32.); // specular component\n \n    float frz = pow(max(0.1, 1. - dot(n,-rd)),4.)*.5; // freznel)\n\t\n    float ao = aoc(.1); // fake AO\n    float ss = sss(1.); // fake subsurface scattering\n    \n    vec3 col =  al * ao * (diff + ss) + spec; // combine it all together\n    col = mix(col, fog, frz);         // fog the edges\n    \n    return col; // the final color\n}\n\n// ray marching loop\nvec3 march(vec3 ro, vec3 rd) {\n\tfloat dd=0.1;\t\t// start with a slight z offset\n    vec3 col=vec3(0);   // no color initially\n    vec3 p=ro + rd * dd;// current point\n    \n    for(int i=0; i<MS; ++i) {  // start marching\n     \tvec2 d = map(p);  // distance to SDF\n        \n        if(d.x < SD) { // close to a surface\n            // get the color of the surface\n            col += d.y > 0. ? surface(ro, rd, vec2(dd, d.y)) : vec3(0.);\n            break; // we're done\n        }\n        \n        if(dd > MD) { // we've reached the max draw distance,\n            dd = MD;\n            break;    // and we're done\n        }\n        \n        dd += d.x;     // track the total distance\n        p += rd * d.x; // and update the current position\n    }\n    \n    // blend in some distance-based fog and return\n    return mix(fog * pow(max(0., dot(rd, vec3(0,0,-1))),20.), col, exp(-0.003*dd*dd*dd));\n}\n\n\n// given the ray origin, lookat point and uv's, calculate the ray direction\nvec3 raydir(vec3 ro, vec3 la, vec2 uv) {\n    // x,y and z axes\n    vec3 cz = normalize(la-ro);\n    vec3 cx = normalize(cross(cz,vec3(0,1,0)));\n    vec3 cy = normalize(cross(cx,cz));\n    // project and normalize\n    return normalize(cx*uv.x + cy*uv.y + cz);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    // make sure that the pixels are square\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    // get rid of some artifacts\n    time = mod(iTime, 62.39);\n    \n    // setup the ray\n    vec3 ro = vec3(0,0,1);\n    vec3 rd = raydir(ro, vec3(0)-ro, uv);\n    \n    // march\n    vec3 col = march(ro, rd);\n\n    col += glw;\n    // exposure\n    col = vec3(1) - exp(-col * 1.1);\n    // gamma\n    col = pow(col, vec3(1./2.2));\n    // final color\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dSyzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[667, 681, 708, 708, 737], [739, 778, 805, 805, 829], [830, 830, 857, 857, 881], [884, 899, 932, 932, 989], [991, 1072, 1091, 1091, 1125], [1127, 1152, 1170, 1191, 2233], [2235, 2306, 2327, 2327, 2448], [2844, 2844, 2886, 2886, 3827], [3829, 3850, 3880, 3880, 4740], [4743, 4819, 4859, 4881, 5077], [5080, 5080, 5137, 5187, 5712]], "test": "error"}
{"id": "3dXBD8", "name": "my ultra violet sunshiny stripes", "author": "tiagomoraismorgado88", "description": "my ultra violet sunshiny stripes", "tags": ["strips", "ultraviolet", "sunshiny"], "likes": 2, "viewed": 74, "published": "Public", "date": "1588163639", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 6.0 * fragCoord/iResolution.xx;\n    \n    for (int n = 1; n < 8; n++){\n         float i = float(n);\n         uv += vec2(0.743 / i * sin(i * uv.x + iTime + 0.322 * i) + 0.808, 0.4613 / i * sin(uv.x + iTime +0.322 * i) + 1.6);\n    }\n    uv += vec2(0.714 / cos(sin(uv.x + iTime + 0.333) * 3.22) + 0.8, 0.432 / sin(uv.x + iTime +0.322) + 1.43);\n\n    // Time varying pixel color\n    vec3 col = vec3(0.322 * sin(uv.x) + 0.909, 0.505 * sin(uv.x) + 0.505, sin(uv.x + uv.x));\n                    \n\n    // Output to screen\n    fragColor = vec4(sin(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dXBD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 671]], "test": "valid"}
{"id": "3dXBR4", "name": "Start Iridiscence", "author": "BlancC", "description": "trying to build up on the star design design from the art of code : \nhttps://www.shadertoy.com/view/tlyGW3", "tags": ["light"], "likes": 8, "viewed": 161, "published": "Public", "date": "1587750268", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M_PI 3.14159265358979323846264338\n\nvec3 Rainbow(vec2 uv, float zoomAmnt, float speed, vec2 startFinishSteps){\n    \n    float ratioRnbow = uv.x * 20.;\n    float angleRnbow = uv.y * 6. * cos(1.1 * speed);\n    vec3 rgbRnbow = cos(speed + ratioRnbow + angleRnbow + vec3(0., 1., 2.));\n    \n    \n    float ratioStartStep = startFinishSteps.x;\n    float ratioFinishStep = startFinishSteps.y;\n    \n    vec2 sStep = smoothstep(0., ratioStartStep * zoomAmnt, abs(uv));\n\tvec2 fStep = smoothstep(ratioFinishStep * zoomAmnt, ratioStartStep * zoomAmnt, abs(uv)); \n    \n    float stepper = sStep.x * fStep.x + sStep.y * fStep.y;\n    \n    return stepper * rgbRnbow; \n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34, 456.21));\n    p += dot(p, p+45.32);\n    return fract(p.x*p.y);\n}\n\nmat2 Rot(float a){\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\nvec3 Star(vec2 uv, float flare, float zoomAmnt, float rotSpeed){\n    float d = length(uv);\n    vec3 m = vec3(.04/d);\n    \n    \n    vec3 rnb = Rainbow(uv, zoomAmnt, iTime + uv.x * uv.y, vec2(0.3, 0.55));\n    float ray = max(0., 1. - abs(uv.x * uv.y * 400.));\n    m += ray * (1. + rnb) * (abs(flare) + .4);\n    \n    uv *= Rot(M_PI / 4. + iTime * rotSpeed);\n    ray = max(0., 1. - abs(uv.x * uv.y * 800.));\n    m += ray * (.6 + .5 * rnb) * (abs(flare) + .4);\n    \n    m *= smoothstep(1., .2, d);\n    \n    return m;\n}\n\nvec3 starLayer(vec2 uv, float zoomAmnt, float index){\n    \n    vec3 col = vec3(0);\n    vec2 gv = fract(uv) -.5;\n    vec2 id = floor(uv);\n    \n    int y,x;\n    \n    for(y = -1; y <=1; y++){\n        for(x = -1; x <=1; x++){\n            vec2 offs = vec2(x,y);\n            float r = Hash21(id + offs + index);\n            float size = 1. - .5 * fract(r * 345.223);\n\n            vec3 star = Star(gv - offs - vec2(r, fract(r* 34.)) + .5, sin(iTime * size) * r, zoomAmnt, (-.4 + fract(r * 1723.2)));\n            \n            \n    \t\tstar *= sin(iTime * (.4 + r)) * .5 + .5; \n            col += star * size * (sin(iTime + index * 32.1) * .5 + .5);\n        }\n    }\n    \n    return col ;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    float zoomAmnt = 3.;\n    uv *= zoomAmnt;\n\n    vec3 col = vec3(0.);\n\t\n    int k = 0;\n    int AmnLayers = 6;\n    for( k = 0; k < AmnLayers; k++){\n        \n        \n    \tcol += starLayer(uv, zoomAmnt, float(k) / float(AmnLayers) * 3.);\n    }\n    \n    \n\n    //if(gv.x >.48 || gv.y > .48) col.r = 1.;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n    //fragColor = vec4(vec3(stepper), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dXBR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 43, 117, 117, 660], [662, 662, 684, 684, 778], [780, 780, 798, 798, 860], [861, 861, 925, 925, 1374], [1376, 1376, 1429, 1429, 2054], [2055, 2055, 2112, 2162, 2632]], "test": "valid"}
{"id": "3dXBR8", "name": "Quick Sky", "author": "supereggbert", "description": "just a quick sky", "tags": ["sky"], "likes": 4, "viewed": 68, "published": "Public", "date": "1587641632", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\tSimplex 3D Noise \n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C \n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 ); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nvec3 skyColor( vec3 cameraRay, vec3 sunDirection, bool nosun ){\n    vec3 skyColor = vec3( 1.0, 1.2, 1.7 );\n    \n    float sunHeight = (sunDirection.y + 1.0 ) * 0.5;\n    float hozHeight = clamp(smoothstep(-0.2,1.0,sunHeight),0.0,1.0);\n    \n    float hozHeightAbs = clamp(smoothstep(0.2,1.0,sunHeight), 0.0,1.0)+0.01;\n    float eyeHeight = clamp(( cameraRay.y + 0.1 ),0.0,1.0 ) ;\n    \n    vec3 sunColor = mix( vec3(1.2,0.0,0.0), vec3(0.95,0.95,0.7), hozHeightAbs );\n    \n    float sunDot = pow( ( dot( cameraRay, sunDirection ) + 1.0 ) * 0.5, 2000.0*pow(eyeHeight,2.0)+1.0);\n    \n    vec3 sunGlow = sunColor * sunDot * hozHeightAbs;\n    \n    vec3 skyGlow = skyColor * hozHeightAbs;\n    \n    float stars = clamp(smoothstep(0.8,1.0,snoise(cameraRay*100.0)),0.0,1.0)*0.3 * clamp(smoothstep(0.1,0.5,cameraRay.y),0.0,1.0) * clamp(smoothstep(0.1,-0.1,sunDirection.y),0.0,1.0);\n    \n    float ground = pow(1.0-clamp(-cameraRay.y,0.0,1.0),20.0);\n    \n    \n    float fog = pow( 1.0 - abs(cameraRay.y), 2.0 )*(hozHeight+0.2);\n     \n    vec3 col = skyGlow*0.4 + sunGlow*0.9 + stars + fog*sunColor*0.1*hozHeight;\n    \n    vec3 groundColor = vec3(0.09,0.1,0.08) * clamp( sunDirection.y, 0.0,1.0 ) * sunColor * 2.0;\n \n    if(cameraRay.y<0.0){\n    \tcol= mix(groundColor, col, ground); \n    }\n    \n    if(!nosun){\n        float sun = clamp(smoothstep(0.9995,0.9996,dot( cameraRay, sunDirection )),0.0,1.0) * clamp(smoothstep(0.0,0.1,cameraRay.y),0.0,1.0)*0.3;\n        col+=sun*sunColor;\n    }\n    \n    return col;\n}\n\nfloat cloudValue( vec3 cloudCoord ){\n    float time = iTime * 0.1;\n    cloudCoord.z+=time;\n\tfloat cloud = snoise(cloudCoord)*0.55+snoise(cloudCoord*2.0+time*0.3)*0.2+snoise(cloudCoord*4.0+time*0.2)*0.2+snoise(cloudCoord*8.0+time*0.5)*0.05+snoise(cloudCoord*16.0)*0.05;\n    cloud = ( cloud + 1.0 ) * 0.5;\n    return cloud;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy - 0.5 ) * 2.0;\n    \n    vec2 mouse = 1.0-( iMouse.xy/iResolution.xy - 0.5 ) * 2.0;\n    \n    float aspect = iResolution.x/iResolution.y;\n    \n    uv.x*=aspect;\n    \n    vec3 sunDirection = normalize( vec3( 0.0,sin(iTime*0.2)*1.0,1.0) );\n    \n    vec3 cameraRay = normalize( vec3(uv, 2.0) );\n    \n    mat2 rotx = mat2( cos( mouse.y * 3.14159 ),-sin( mouse.y * 3.14159 ),sin( mouse.y * 3.14159 ),cos( mouse.y * 3.14159 ) );\n    cameraRay.yz = rotx * cameraRay.yz;\n    \n    mat2 roty = mat2( cos( mouse.x * 3.14159 ),-sin( mouse.x * 3.14159 ),sin( mouse.x * 3.14159 ),cos( mouse.x * 3.14159 ) );\n    cameraRay.xz = roty * cameraRay.xz;\n    \n        \n        \n    vec3 col = skyColor( cameraRay, sunDirection, false );\n    \n    vec3 cloudCoord = cameraRay / (cameraRay.y + 0.2 ) * 0.5;\n    \n    float cloud = cloudValue( cloudCoord );\n    \n    vec3 normal = vec3( cloudValue(cloudCoord + vec3(0.1,0.0,0.0)), cloudValue(cloudCoord + vec3(0.0,0.1,0.0)), cloudValue(cloudCoord + vec3(0.0,0.0,0.1))  );\n    normal -= cloud;\n    normalize(normal);\n    normal.y = abs(normal.y);\n                       \n    \n    vec3 cloudColor = vec3(cloud);\n    \n    float cloudCover = 0.2;\n    \n    if( cameraRay.y > 0.0 ){\n        cloud = clamp(cloud-pow(1.0-abs(cameraRay.y),50.0)*0.5,0.0,1.0);\n        vec3 sunColor = skyColor( sunDirection, sunDirection, true );\n        float sunLighting = pow( dot( -normal, sunDirection ) + 1.0, 3.0 );\n        float cloudLuma = pow( clamp(sunDirection.y,0.0,1.0),0.8);\n        vec3 cloudColor = sunLighting * sunColor * cloudLuma;\n        float cloudmix = clamp(smoothstep((0.8 - cloudCover*2.0),1.0,cloud),0.0,1.0);\n        col = mix(col, cloudColor,pow(cloudmix,(0.8 - cloudCover) * 2.0));\n\n    }\n    \n    col = pow(col,vec3(0.5));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dXBR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 54, 75, 75, 112], [113, 113, 140, 140, 188], [190, 190, 211, 211, 2047], [2049, 2049, 2112, 2112, 3546], [3548, 3548, 3584, 3584, 3871], [3875, 3875, 3932, 3932, 5755]], "test": "valid"}
{"id": "3dXBW8", "name": "2D clouds i wanted to do", "author": "Leria", "description": "What a Sunny day !\n\ninspired from this shader : https://www.shadertoy.com/view/tlB3zK (zxxuan1001)", "tags": ["2d", "noise", "cloud", "sky"], "likes": 1, "viewed": 289, "published": "Public API", "date": "1588090907", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//noise function from iq: https://www.shadertoy.com/view/Msf3WH\nvec2 hash( vec2 p ) \n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n//quintique\nvec2 fade5(vec2 f) {return f * f * f * (f * (f * 6.0 - 15.0) + 10.0);}\n\n//cubique\nvec2 fade3(vec2 f) {return f*f*(3.0-2.0*f);}\n\nfloat noise(vec2 p)\n{\n \tvec2 i = floor( p );\n    vec2 f = fract( p );\n    \n    vec2 u = fade5(f);\n    \n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n        \n}\n\n\nfloat fractal_noise(vec2 p)\n{\n    float f = 0.0;\n\tfloat amp = 1.;\n    p = p*2.;\n    for(int i = 0; i < 5 ; i++)\n    {\n     \tf += amp/2.*noise(p);\n        p = p*2.;\n    }\n    \n    return f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 sky = vec3(0.5, 0.7, 0.8);\n    vec3 col = vec3(0.0);\n    \n    vec3 cloud_color = vec3(1.0);\n   \n    float n = fractal_noise(fragCoord/(200.+iTime/1000.));\n    col = mix( sky, cloud_color, smoothstep(-1., 40., n));\n    col = mix( col, cloud_color, smoothstep(.75, -1.25, n));\n    col = min(col, cloud_color);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dXBW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 65, 87, 87, 202], [204, 216, 236, 236, 286], [288, 298, 318, 318, 342], [344, 344, 365, 365, 773], [776, 776, 805, 805, 966], [968, 968, 1025, 1025, 1381]], "test": "valid"}
{"id": "3dXfDr", "name": "Implicit Star", "author": "harry7557558", "description": "A modification of my first shader https://www.shadertoy.com/view/WtjSD3. Make the code faster and look less naive.", "tags": ["star", "implicit"], "likes": 8, "viewed": 104, "published": "Public", "date": "1588004495", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// the equation of the star shape:\n// 4(x²+2y²+z²-1)²-(5x⁴z-10x²z³+z⁵)-1=0\n// or: 4(x²+2y²+z²-1)²-Im((x+zi)⁵)-1=0\n\nfloat func(in vec3 p){\n    vec3 u = p*p;\n    float d = u.x+2.0*u.y+u.z-1.0;\n    if (d>3.0) return d;  // clipping needed because its degree is odd\n    return 4.0*d*d-p.z*(5.*u.x*u.x-10.*u.x*u.z+u.z*u.z)-1.0;\n}\n\nvec3 calcGrad(vec3 p){\n    const float e = .0001;\n\tfloat a = func(p+vec3(e,e,e));\n\tfloat b = func(p+vec3(e,-e,-e));\n\tfloat c = func(p+vec3(-e,e,-e));\n\tfloat d = func(p+vec3(-e,-e,e));\n\treturn vec3(a+b-c-d,a-b+c-d,a-b-c+d)*(.25/e);\n}\n\n\nconst vec3 light = normalize(vec3(-0.3, 0.1, 1));\n\nvec3 castRay(vec3 p, vec3 d) {\n\tfloat t = 1e-3, dt;\n\tif (func(p) < 0.0) return vec3(0.0, 0.0, 0.0);\n\tfor (int i = 0; i < 1024; i++) {\n\t\tdt = func(p + t * d);\n        dt /= length(calcGrad(p + t * d));\n\t\tt += 0.5*dt;\n        if (dt < 1e-2) {\n\t\t\tp += t * d;\n    \t\tvec3 n = normalize(calcGrad(p));\n    \t\tif (dot(n, d) > 0.0) n = -n;\n    \t\tfloat dif = clamp(dot(n, light), 0.0, 1.0);\n    \t\treturn (0.7*dif+0.2*pow(max(dot(d, light),0.0),4.0)+0.4)*vec3(1.0,0.6,0.1);\n        }\n\t\tif (t > 20.0) break;\n\t}\n    vec3 col = sin(30.0*d.x)+sin(30.0*d.y)+sin(30.0*d.z)>0.0 ?\n        vec3(1.0,0.8,0.6) : vec3(0.9,0.6,0.8);\n\tt = max(dot(d,light), 0.0);\n\treturn (0.3+0.7*t)*col;\n}\n\n#define AA 2\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float h = 1.5*cos(0.4*iTime)+1.0;\n    float r = sqrt(20.0-h*h)+0.2*(cos(iTime)+1.0);\n    vec3 pos = vec3(r*cos(iTime), r*sin(iTime), h);\n    float Unit = 0.5*length(iResolution);\n\n    vec3 w = normalize(pos);\n    vec3 u=normalize(vec3(-w.y,w.x,0));\n    vec3 v=cross(w,u);\n    mat3 M=-mat3(u,v,w);\n\n    vec3 col;\n    for (int i=0;i<AA;i++) for (int j=0;j<AA;j++) {\n        vec3 d=M*vec3(0.5*iResolution.xy-(fragCoord.xy+vec2(i,j)/float(AA)),Unit);\n        col += castRay(pos,normalize(d));\n    }\n    col/=float(AA*AA);\n\n    col.x=pow(col.x,0.75),col.y=pow(col.y,0.75),col.z=pow(col.z,0.75);\n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dXfDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[131, 131, 153, 153, 340], [342, 342, 364, 364, 574], [628, 628, 658, 658, 1291], [1306, 1306, 1361, 1361, 1989]], "test": "error"}
{"id": "3dXfR7", "name": "Lurnin;SimpleCircle", "author": "nimda32", "description": "just a test\n\ncredit:\nhttps://www.shadertoy.com/view/MssXDn", "tags": ["test"], "likes": 2, "viewed": 78, "published": "Public", "date": "1587868390", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define Pi 3.141592\n#define Pi2 6.2918\n#define NumberOfParticles 64\n\nfloat starline(vec2 relpos,float confradius,float filmsize)\n{\n\tif(abs(relpos.y)>confradius) return 0.0;\n\tfloat y=relpos.y/confradius;\n\tfloat d=abs(relpos.x/filmsize);\n\treturn sqrt(1.0-y*y)/(0.0001+d*d)*0.00001;\n}\n\nfloat star(vec2 relpos,float confradius,float filmsize)\n{\n\tvec2 rotpos=mat2(cos(Pi/3.0),-sin(Pi/3.0),sin(Pi/3.0),cos(Pi/3.0))*relpos;\n\tvec2 rotpos2=mat2(cos(Pi/3.0),sin(Pi/3.0),-sin(Pi/3.0),cos(Pi/3.0))*relpos;\n\n    return starline(relpos,confradius,filmsize)+\n\t\tstarline(rotpos,confradius,filmsize)+\n\t\tstarline(rotpos2,confradius,filmsize);\n}\nvec3 palette(float x)\n{\n\treturn vec3(\n\t\tsin(x*2.0*Pi)+1.5,\n\t\tsin((x+1.0/3.0)*2.0*Pi)+1.5,\n\t\tsin((x+2.0/3.0)*2.0*Pi)+1.5\n\t)/2.5;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 screenpos=(2.0*fragCoord.xy-iResolution.xy)/max(iResolution.x,iResolution.y);\n\n\tfloat focaldistance=0.5+sin(iTime*0.05)*0.013;\n\tfloat focallength=0.100;\n\tfloat filmsize=0.036;\n\tfloat minconf=filmsize/10000.0;\n\tfloat lensradius=focallength/(1.5 + (.5 * 1.0+cos(iTime )) ) ;\n\n\tfloat filmdistance=1.0/(1.0/focallength-1.0/focaldistance);\n\t\n\tvec3 c=vec3(0.0);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0,0.0,0.0);// 0.25*sin(iTime+uv.xyx+vec3(0,2,4));\n    \n    float r = iResolution.y * .2;\n    float r2 = r * r;\n    \n    float x = iResolution.x * .5;\n    float y = iResolution.y * .5;\n        \n    float xPos = fragCoord.x - x;\n    float yPos = fragCoord.y - y;\n    \n    xPos = xPos * xPos;\n    yPos = yPos * yPos;\n    \n    if( xPos + yPos < r2  ){\n\t    //col =  .5 + 0.5 * sin( 10.0 * iTime + uv.xyx + vec3(0, 2, 4));\n    }\n\n     //(x0 + r cos theta, y0 + r sin theta)\n    \n    for(int i=0;i<NumberOfParticles;i++)\n\t{\n        float fi = float(i);\n        float fNum = float(NumberOfParticles);\n\t\tfloat t= fi / fNum;\n\t\tfloat a= t * Pi2 + iTime*0.1;\n        \n\t\t//vec3 pos = vec3( sin(2.0*a), -cos(2.0*a), -sin(3.0*a)) * 0.01;\n\t\tvec3 pos = vec3((.5 +cos(iTime)) + (r * sin(  a )) , (r * -sin( 2.0 * a )), 0) * .0002;\n\n\t\tpos.z+= 0.5 + (.01* (sin(sin(iTime))));\n\n\t\t\n\t\tfloat intensity=0.00005 + 0.00005 *(cos(iTime * 1.0)) ;\n\n\t\tvec2 filmpos=pos.xy/pos.z*filmdistance;\n\t\tfloat confradius=lensradius*filmdistance*abs(1.0/focaldistance-1.0/pos.z)+minconf;\n\n\t\tfloat diffusedintensity=intensity/(confradius*confradius);\n\n\t\tvec3 colour = palette(t);\n\n\t\tvec2 relpos=filmpos-screenpos/2.0*filmsize;\n\t\tif(length(relpos)<confradius) c+=colour*diffusedintensity;\n\n\t\tc+=colour*diffusedintensity*star(relpos,confradius,filmsize);\n\t}\n    \n    \n    // Output to screen    \n    fragColor = vec4(pow(c,vec3(1.0/1.0)),1.0) +  vec4( pow(col,vec3(1.0/2.2)),1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dXfR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 130, 130, 281], [283, 283, 340, 340, 626], [627, 627, 650, 650, 756], [757, 757, 814, 814, 2769]], "test": "valid"}
{"id": "3dXfRH", "name": "wheelofconf.", "author": "nabr", "description": "displacement mapping alike don't take the code too serious.", "tags": ["wheel", "what", "me", "to", "it", "like", "you", "make", "does", "take"], "likes": 12, "viewed": 170, "published": "Public", "date": "1587656562", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// -----------------------------------------------------\n// wheelofconf. by nabr\n// https://www.shadertoy.com/view/3dXfRH\n// License Creative Commons Attribution-NonCommercial 4.0 International (CC BY-NC 4.0)\n// https://creativecommons.org/licenses/by-nc/4.0/\n// -----------------------------------------------------\n\n\n// displacement mapping alike don't take the code too serious\n\nfloat pch(vec2);\n#define t iTime\n\nfloat f(vec3 p)\n{\n    float f = 0., \n          z = .05 * t + p.z, \n          v = 1. - smoothstep(0., 2., length(p));\n    for(float i = 10.; i > 0.; --i)\n    {\n        float c = p.y * sin(i / 1.57 + z), \n              s = p.x * cos(i / 1.57 + z), \n              b = v * mod(1.57 * v, .636);\n        f += min(v, .0125 / abs(b +(fract(.05*t)>.5?2.:1.) * (c + s)));\n    }\n    return (p + normalize(smoothstep(0., f, vec3(.15, 1, .5)))).z;\n}\n\nvoid mainImage(out vec4 O, in vec2 U)\n{\n    vec2 R = iResolution.xy, e = vec2(.001, 0);\n    U = (U - .5 * R) / R.y;\n    \n    vec3 c, p, N;\n    \n    vec3 o = vec3(0, 0, .5+(sin(.2*t)*.2+.2)), \n         d = vec3(U, -1),\n         dn = vec3(0, 0, 1.), \n         D = dot(dn, o) / dot(dn, d) * d - o;\n    \n    vec3 ld = normalize(vec3(.7 * sin(.5 * t), cos(.5 * t), 1));\n    vec3 l = -normalize(ld + d);\n    float lr = exp2(.1 * dot(l, l));\n    \n    float h; \n    for(int i = 10; i > 0; --i)\n        \th += f(p = (D * h));\n    \n    N = normalize(f(p) - vec3(f(p - e.xyy), f(p - e.yxy), f(p - e.yyx)));\n    \n    c = mix(vec3(.2, .6, .95), \n            max(dot(N, l), .05) * lr * vec3(.8), \n            fract(.05 * t + .5 + h) + .5);\n    c += vec3(.1, .2, .2) * max(0., .8 - dot(reflect(l, N), -d)) * fract(.5 * h);\n    \n    O = vec4(vec3(.4)* pch(U) + c , 1.);\n}\n\n// char by FabriceNeyret2\n#define char(_p,_C)(((_p.x<0.||_p.x>1.||_p.y<0.||_p.y>1.))?vec4(0,0,0,1e5):textureGrad(iChannel3,_p/16.+fract(vec2(_C,15-_C/16)/16.),dFdx(_p/16.),dFdy(_p/16.))).x\nint msg[]=int[](84,104,101,32,119,111,114,108,100,32,119,105,108,108,32,115,116,105,108,108,32,98,101,32,116,117,114,110,105,110,103,32,119,104,101,110,32,121,111,117,39,114,101,32,103,111,110,101,89,101,97,104,44,32,119,104,101,110,32,121,111,117,39,114,101,32,103,111,110,101,45,32,79,122,122,121);\nfloat pch(vec2 u){\n    vec2 tp=24.*vec2(u.x+.25,u.y-.3);\n    float p; \n    for(int i=(msg.length()-1);i>=0;--i){\n        p+= char(tp,msg[i]);\n        switch(i){\n        case 70:tp.x-=2.;tp.y-=.75;break;\n        case 48:tp.x-=24.;tp.y-=.75;\n        }\n        tp.x+=.5;\n    };return p*max(0., 1.-t*.1); \n}", "image_inputs": [{"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 3, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dXfRH.jpg", "access": "shaders20k", "license": "cc-by-nc-4.0", "functions": [[416, 416, 433, 433, 852], [854, 854, 893, 893, 1708], [2200, 2200, 2218, 2218, 2503]], "test": "error"}
{"id": "3dXfWn", "name": "Weird TV effect thing", "author": "LowSpecCorgi", "description": "A weird tv effect that I accidentally made, click screen for it to work", "tags": ["tv", "shader", "thing"], "likes": 1, "viewed": 63, "published": "Public", "date": "1587981442", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord * iMouse.xy / iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dXfWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 308]], "test": "valid"}
{"id": "3dXyDs", "name": "logistic_difference_v0009", "author": "darkczar", "description": "math fun", "tags": ["psychedelic", "trippy"], "likes": 2, "viewed": 40, "published": "Public", "date": "1585808316", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// based on...\n// https://www.shadertoy.com/view/lssfW2\n\nfloat nsin(float x)\n{\n    return .5+.5*sin(x);\n}\nfloat ncos(float x)\n{\n    return .5+.5*cos(x);\n}\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}  //https://gist.github.com/companje/29408948f1e8be54dd5733a74ca49bb9\n\nhighp float rand(vec2 co)  //from stackoverflow\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nuint hash( uint x ) {  //http://amindforeverprogramming.blogspot.com/2013/07/random-floats-in-glsl-330.html\n\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\nfloat random( float f ) {  //http://amindforeverprogramming.blogspot.com/2013/07/random-floats-in-glsl-330.html\n\n    const uint mantissaMask = 0x007FFFFFu;\n    const uint one          = 0x3F800000u;\n   \n    uint h = hash( floatBitsToUint( f ) );\n    h &= mantissaMask;\n    h |= one;\n    \n    float  r2 = uintBitsToFloat( h );\n    return r2 - 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float r = 0.0;\n    float g = 0.0;\n    float b = 0.0;\n    vec2 xy0 = vec2(0.,0.);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p=(fragCoord.xy-iResolution.xy)/iResolution.y;\n    \n    vec2 xy = vec2(0.,0.);\n    float rr = .5*(nsin(.15*iTime))+3.45; // + .5*nsin(iTime*.5); //2.57 +nsin(iTime); //+cos(iTime);\n    xy = uv;\n    for (int i = 0; i<9; i++)\n    {\n        xy = rr*xy*(vec2(1.0,1.0)-xy);\n        if(i==0)\n        {\n          xy0 = xy;  \n        }\n        if (i>0)\n            {\n                if(abs(length(xy) - length(xy0)) < .005 +.02*ncos(iTime*.15)) // try and tease out the cycles and color them\n                {\n                    r = 1.*random(float(mod(float(i),7.0)));\n                    g = 1.*random(1.28+float(mod(float(i),7.0)));\n                    b = 1.*random((1.0 - float(mod(float(i),7.0))));\n                }\n            }\n    }\n    if (length(xy) > 3.0 +sin(iTime*.9))\n    {\n        r = 1.0 - mod(length(xy),3.);\n        g = 0.2;\n        b = mod(length(xy),3.);\n    } else\n    {\n        //r = .05;\n        //g = .99;\n        //b = .3;\n    }\n        \n        //m = (rand_point.x-prev_point.x) / ((rand_point.y-prev_point.y);\n        //line_y = m*p.x +  \n\n\n    \n    vec3 col = vec3(r, g, b);\n    float dn = col.x + col.y + col.z;\n    col /= dn;\n    // Output to screen\n    //fragColor = vec4(col,1.0);\n    fragColor = vec4( pow(col,vec3(1./2.2)),1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dXyDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 79, 79, 106], [107, 107, 128, 128, 155], [156, 156, 228, 228, 294], [615, 615, 636, 722, 854], [855, 855, 880, 966, 1203], [1205, 1205, 1262, 1262, 2706]], "test": "valid"}
{"id": "3l2XW3", "name": "template: raymarching", "author": "takumifukasawa", "description": "[Frequently updated]\n- directional light, point light, ambient light\n- AO\n- distance fog\n- softshadow", "tags": ["template"], "likes": 1, "viewed": 42, "published": "Public", "date": "1585840967", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define EPS .0001\n#define NORMAL_EPS .0001\n#define PI 3.14159265359\n#define PI2 PI * 2.\n\n#define MAT_SPHERE 1.\n#define MAT_BOX 2.\n#define MAT_FLOOR 3.\n\n#define saturate(a) clamp(a, 0., 1.)\n#define repeat(a, b) mod(a, b) - b * .5 \n\nprecision highp float;\n\nstruct Light {\n\tvec3 position;\n  \tfloat intensity;\n  \tvec3 color;\n  \tvec3 diffuse;\n  \tvec3 specular;\n  \tfloat attenuation;\n};\n    \nstruct Surface {\n  \tfloat depth;\n  \tvec3 position;\n  \tvec3 baseColor;\n    vec3 specularColor;\n    float specularPower;\n  \tvec3 normal;\n  \tvec3 emissiveColor;\n  \tfloat material;\n};\n\nconst float stopThreshold = .001;\nconst int maxShadowIterations = 32;\n\nvec3 glow = vec3(0.);\n\n//---------------------------------------------------------------------------------------------\n// utils\n//---------------------------------------------------------------------------------------------\n\n// ref: https://www.shadertoy.com/view/ldlcRf\nvec2 minMat(vec2 d1, vec2 d2) {\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\nbool checkMat(float material, float check) {\n\treturn material < (check + .5);\n}\n\nmat3 camera(vec3 o, vec3 t) {\n\tvec3 forward = normalize(t - o);\n    vec3 right = cross(forward, vec3(0., 1., 0.));\n    vec3 up = cross(right, forward);\n    return mat3(right, up, forward);\n}\n\nmat2 rot2(float t) {\n    return mat2(cos(t), -sin(t), sin(t), cos(t));\n}\n\n//---------------------------------------------------------------------------------------------\n// sdf\n//---------------------------------------------------------------------------------------------\n\n// ra: radius\n// rb: round\n// h: height\nfloat sdRoundedCylinder(vec3 p, float ra, float rb, float h) {\n    vec2 d = vec2(length(p.xz) - 2. * ra + rb, abs(p.y) - h);\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - rb;\n}\n\n// a: begin pos\n// b: begin thin\n// ra: end pos\n// rb: end thin\nfloat sdStick(in vec3 p, vec3 a, vec3 b, float ra, float rb) {\n\tvec3 ba = b - a;\n    vec3 pa = p - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n    float r = mix(ra, rb, h);\n\treturn length(pa - h * ba) - r;\n}\n\nfloat sdElipsoid(in vec3 pos, vec3 rad) {\n\tfloat k0 = length(pos / rad);\n\tfloat k1 = length(pos / rad / rad);\n\treturn k0 * (k0 - 1.) / k1;\n}\n\nfloat sdPlane(vec3 p, vec4 n) {\n  return dot(p, n.xyz) + n.w;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x, max(d.y, d.z)), 0.) + length(max(d, 0.));\n}\n\nfloat smin(in float a, in float b, float k) {\n    float h = max(k - abs(a - b), 0.);\n\treturn min(a, b) - h * h / (k * 4.);\n}\n\nfloat smax(in float a, in float b, float k) {\n    float h = max(k - abs(a - b), 0.);\n\treturn max(a, b) + h * h / (k * 4.);\n}\n\n//---------------------------------------------------------------------------------------------\n// raymarch\n//---------------------------------------------------------------------------------------------\n\nvec2 scene(vec3 p) {\n    // dummy float max and min\n    vec2 res = vec2(10000., -10000.);\n    float d = 0.;\n\n    {\n\t\tfloat pl = sdPlane(p - vec3(0., 2., 0.), vec4(0., 1., 0., 2.));\n        res = minMat(res, vec2(pl, MAT_FLOOR));\n    }\n    {\n\t    float s1 = sdElipsoid(p - vec3(0., .8, 0.), vec3(.5));        \n        res = minMat(res, vec2(s1, MAT_SPHERE));\n    }\n    {\n\t\tfloat b1 = sdBox(p - vec3(1., .25, 0.), vec3(.2, .5, .2));\n        res = minMat(res, vec2(b1, MAT_BOX));\n    }\n    {\n\t\tfloat b2 = sdBox(p - vec3(-1., .25, 0.), vec3(.2, .5, .2));\n        res = minMat(res, vec2(b2, MAT_BOX));\n    }\n\n    return res;\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(NORMAL_EPS, 0);\n    return normalize(\n    \tvec3(\n            scene(p + e.xyy).x - scene(p - e.xyy).x,\n            scene(p + e.yxy).x - scene(p - e.yxy).x,\n            scene(p + e.yyx).x - scene(p - e.yyx).x\n        )\n    );\n}\n\nvec2 raymarch(vec3 ro, vec3 rd) {\n\tfloat tmin = .01;\n    float tmax = 80.;\n    float m = -1.;\n    float t = tmin;\n    for(int i = 0; i < 99; i++) {\n\t\tvec3 pos = ro + rd * t;\n        vec2 h = scene(pos);\n        m = h.y;\n        if(abs(h.x) < (stopThreshold * t)) break;\n        t += h.x;\n        if(t > tmax) break;\n    }\n    if(t > tmax) m = -1.;\n    return vec2(t, m);\n}\n\n//---------------------------------------------------------------------------------------------\n// shading\n//---------------------------------------------------------------------------------------------\n\nfloat softShadow(vec3 ro, vec3 rd, float mint, float tmax, float power) {\n  float res = 1.;\n  float t = mint;\n  float ph = 1e10;\n  for(int i = 0; i < maxShadowIterations; i++) {\n    float h = scene(ro + rd * t).x;\n\n    // pattern 1\n    // res = min(res, power * h / t);\n\n    // pattern 2\n    float y = h * h / (2. * ph);\n    float d = sqrt(h * h - y * y);\n    res = min(res, power * d / max(0., t - y));\n    ph = h;\n\n    t += h;\n\n    float e = EPS;\n    if(res < e || t > tmax) break;\n  }\n  return clamp(res, 0., 1.);\n}\n \n\nfloat getSpecular(Surface surface, vec3 lightDir, float diffuse, vec3 cameraPos) {\n  \t//vec3 lightDir = light.position - surface.position;\n  \tvec3 ref = reflect(-normalize(lightDir), surface.normal);\n  \tfloat specular = 0.;\n  \tif(diffuse > 0.) {\n    \tspecular = max(0., dot(ref, normalize(cameraPos - surface.normal)));\n    \tfloat specularPower = surface.specularPower;\n    \tspecular = pow(specular, specularPower);\n  \t}\n  \treturn specular;\n}\n\nvoid calcDirectionalLight(inout Light light, Surface surface, vec3 cameraPos) {\n    light.position = normalize(light.position);\n    light.attenuation = 1.;\n    \n    // diffuse\n  \tfloat diffuseCoef = max(0., dot(surface.normal, normalize(light.position)));\n  \tvec3 diffuse = diffuseCoef * light.attenuation * light.color * light.intensity;\n  \t// specular\n  \tfloat specularCoef = getSpecular(\n        //light,\n        surface,\n        light.position,\n        diffuseCoef,\n        cameraPos\n    );\n  \tvec3 specular = vec3(specularCoef * light.attenuation * light.color * light.intensity);  \n\n  \tlight.diffuse = diffuse * softShadow(surface.position, normalize(light.position), .1, 10., 10.);\n    light.specular = specular;\n}\n\nvoid calcPointLight(inout Light light, Surface surface, vec3 cameraPos) {\n  \tfloat d = distance(light.position, surface.position);\n  \tvec3 k = vec3(.06, .08, .09);\n  \tlight.attenuation = 1. / (k.x + (k.y * d) + (k.z * d * d));\n\n  \t// point light\n  \tvec3 lightDir = normalize(light.position - surface.position);\n  \t// diffuse\n  \tfloat diffuseCoef = max(0., dot(surface.normal, lightDir));\n  \tvec3 diffuse = diffuseCoef * light.color * light.intensity * light.attenuation;\n  \t// specular\n  \tfloat specularCoef = getSpecular(\n        surface,\n        lightDir,\n        diffuseCoef,\n        cameraPos\n    );\n  \tvec3 specular = vec3(specularCoef * light.attenuation * light.color * light.intensity); \n    \n  \tlight.diffuse = diffuse * softShadow(surface.position, normalize(light.position), .1, 10., 10.);\n  \tlight.specular = specular;\n}\n\nfloat ambientOcculusion(vec3 pos, vec3 nor) {\n\tfloat occ = 0.;\n    float sca = 1.;\n    for(int i = 0; i < 5; i++) {\n    \tfloat h = .01 + .11 * float(i) / 4.;\n        vec3 opos = pos + h * nor;\n        float d = scene(opos).x;\n        occ += (h - d) * sca;\n        sca *= .95;\n    }\n    return clamp(1. - 2. * occ, 0., 1.);\n}\n\nvec3 fog(vec3 color, float dist, vec3 fogColor, float b) {\n  float fogAmount = 1. - exp(-dist * b);\n  return mix(color, fogColor, fogAmount);\n}\n\nvec3 lighting(Surface surface, vec3 cameraPos, vec3 cameraDir) {\n  \tvec3 position = surface.position;\n\n  \tvec3 color = vec3(0.);\n  \tvec3 normal = surface.normal;\n\n  \tLight directionalLight;\n  \tdirectionalLight.position = vec3(.5, 1., .5);\n  \tdirectionalLight.intensity = .7;\n  \tdirectionalLight.color = vec3(1., 1., 1.);\n  \tcalcDirectionalLight(directionalLight, surface, cameraPos);\n    \n  \tLight pointLight;\n  \tpointLight.position = vec3(sin(iTime) * 2., 2., 1.);\n  \tpointLight.intensity = .3;\n  \tpointLight.color = vec3(1., 1., 1.);\n  \tcalcPointLight(pointLight, surface, cameraPos);\n    \n  \tvec3 diffuse = directionalLight.diffuse + pointLight.diffuse;\n  \tvec3 specular = directionalLight.specular + pointLight.specular;\n    \n    // calc ambient\n\tfloat occ = ambientOcculusion(surface.position, surface.normal);\n  \tfloat amb = clamp(.5 + .5 * surface.normal.y, 0., 1.);\n  \tvec3 ambient = surface.baseColor * amb * occ * vec3(0., .08, .1);  \n    \n  \tcolor =\n        surface.emissiveColor +\n        surface.baseColor * diffuse +\n        surface.specularColor * specular +\n        ambient;  \n  \n  \treturn color;\n}\n\n//---------------------------------------------------------------------------------------------\n// main\n//---------------------------------------------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = (fragCoord.xy - iResolution.xy * .5) / min(iResolution.x, iResolution.y);\n\tvec2 mouse = (iMouse.xy - iResolution.xy * .5) / min(iResolution.x, iResolution.y);\n    \n    vec3 ro = vec3(mouse * 3., 4.)  + vec3(0., 3., 0.);\n    vec3 target = vec3(0., .5, 0.);\n    float fov = 1.5;\n    \n    vec3 rd = camera(ro, target) * normalize(vec3(uv, fov));\n    \n\tvec2 result = raymarch(ro, rd);\n\tvec3 color = vec3(0.);\n    \n    if(result.y > 0.) {\n\t    float depth = result.x;\n    \tfloat material = result.y;    \n   \n    \tvec3 position = ro + rd * depth;\n    \tvec3 normal = getNormal(position);\n\n\t    Surface surface;\n    \tsurface.depth = depth;\n    \tsurface.position = position;\n    \tsurface.normal = normal;\n    \tsurface.material = result.y;       \n        \n    \tvec3 objColor = vec3(0.);\n\n        if(checkMat(material, MAT_SPHERE)) {\n        \tsurface.baseColor = vec3(1., .1, .1);\n            surface.specularColor = vec3(1.);\n        \tsurface.specularPower = 16.;\n        } else if(checkMat(material, MAT_BOX)) {\n        \tsurface.baseColor = vec3(.1, .1, 1.);\n            surface.specularColor = vec3(1.);\n        \tsurface.specularPower = 32.;\n        } else if(checkMat(material, MAT_FLOOR)) {\n        \tsurface.baseColor = vec3(.1, 1., .1);\n            surface.specularColor = vec3(1.);\n        \tsurface.specularPower = 64.;\n        }\n        \n\t\tcolor = lighting(surface, ro, rd);\n    }\n\n    // fog\n    color = fog(color, result.x, vec3(.02, .02, .04), .08);    \n\n    // gamma\n    color = pow(saturate(color), vec3(.4545));\n    \n    \n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l2XW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[864, 910, 941, 941, 976], [978, 978, 1022, 1022, 1057], [1059, 1059, 1088, 1088, 1249], [1251, 1251, 1271, 1271, 1323], [1525, 1565, 1627, 1627, 1752], [1754, 1818, 1880, 1880, 2040], [2042, 2042, 2083, 2083, 2182], [2184, 2184, 2215, 2215, 2247], [2249, 2249, 2278, 2278, 2367], [2369, 2369, 2414, 2414, 2493], [2495, 2495, 2540, 2540, 2619], [2826, 2826, 2846, 2877, 3447], [3449, 3449, 3473, 3473, 3717], [3719, 3719, 3752, 3752, 4091], [4297, 4297, 4370, 4370, 4815], [4819, 4819, 4901, 4957, 5261], [5263, 5263, 5342, 5342, 5984], [5986, 5986, 6059, 6059, 6818], [6820, 6820, 6865, 6865, 7144], [7146, 7146, 7204, 7204, 7289], [7291, 7291, 7355, 7355, 8405], [8608, 8608, 8663, 8663, 10234]], "test": "valid"}
{"id": "3lVXzV", "name": "Raycast testing 314", "author": "josepp14", "description": "For raycast testing\n", "tags": ["raycast"], "likes": 0, "viewed": 41, "published": "Public", "date": "1586618946", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define VEC3_MAX vec3(1e20,1e20,1e20)\n#define VEC3_NULL vec3(0.,0.,0.) // Also works as black\n\n\n\n\nstruct CAMERA\n{\n    vec3 pos;\n    vec3 lookat;\n\tfloat focal_length;\n    \n    vec3 Forward; // Same as Lookat but specifically normalized\n    vec3 Right;\n    vec3 Up;\n};  \n\nvec3 Plane = vec3(0.0, -1.0,0.0);\nvec3 SphereCenter = vec3(1.0, 0.0, 0.0);\nfloat SphereRadius = 0.5;\n\nvoid SetupCamFromFocalLength(out CAMERA cam, in float focal_length, vec3 expected_pos)\n{\n    // at focal Length 1., at distance sqrt(3), object of size .2 is .6\n    \n    float ratio = 1. / 50.;\n    cam.focal_length = focal_length*ratio;\n    \n    cam.pos = expected_pos*(focal_length/10.);\n    \n    // Camera is set to (0,0,0)\n    cam.lookat = VEC3_NULL;\n}\n\nvec3 ex2(in vec2 fragCoord)\n{    \n   \tCAMERA cam;\n    \n    // Color variable for use instead of ruining directly fragColor\n\tvec3 color = vec3(0.0,0.0,0.0);\n    \n    // 1 - Setup Camera    \n    SetupCamFromFocalLength(cam, 50., vec3(1.,2.,1.));\n    \n    // 1.2 - Camera Animation\n    // Camera rotates around center at the expected distance calculated with the previous fucntion\n    cam.pos *= vec3(sin(iTime/10.),.1,cos(iTime/10.));\n    cam.pos *= vec3(1., abs(sin(iTime/5.)), 1.);\n    //cam.pos *= vec3(0., 1., 0.);\n    \n    \n    // Imagine F to be parallel to z and x vector = Perpendicular to Y\n    // We generate Right vector with this, then the real Up Vector\n    // cross product between 2 vectors returns a perpendicular one always\n    cam.Forward = normalize(cam.lookat - cam.pos);\n    cam.Right \t= cross(vec3(0.,1.,0.), cam.Forward);\n    cam.Up\t\t= cross(cam.Forward, cam.Right);    \n    \n    // 2 - Calculate Center of the screen\n    vec3 center = cam.pos + cam.Forward * cam.focal_length;\n    \n    // We calculate initial World Coordinate from screen\n    vec3 world_coord = vec3((fragCoord - (iResolution.xy / 2.)) / iResolution.y, 0.);\n\t\n    // Transform it according to the Camera\n    vec3 coord = center + world_coord.x*cam.Right + world_coord.y * cam.Up;\n\n    // 3 - Start raying\n    vec3 raycastDir = normalize(coord - cam.pos);\n        \n    \n    //Plane Grey\n    float t = -cam.pos.y+Plane.y/raycastDir.y;\n    \n    Plane.x = cam.pos.x+t*raycastDir.x;\n    Plane.z = cam.pos.z+t*raycastDir.z;\n    \n    vec3 blue = vec3(0.0,0.5,0.5);\n    vec3 white = vec3(1.0,1.0,1.0);\n    \n    \n    if (t > 0.0)\n    {\n        color = vec3(0.9,0.9,0.9);\n    }\n    else\n    {\n        color = mix(white,blue,coord.y);\n    }\n    \n    //Sphere                \n    // d = Ray Direction\n    \n       \n    // Calculate OC\n    vec3 OC = SphereCenter-cam.pos;\n    \n    //Get t_OCD with OC(L) projected in direction (D)   \n    float t_OCD = dot(raycastDir,OC);\n    if (t_OCD < 0.) return color;\n    \n    //Pythagorean theorem h^2 = co^2 + cc^2 -> co^2 = h^2 - cc^2 -> co = sqrt(h^2-cc^2) -> distance_oc_ocd = sqrt(OC^2-t_OCD^2)     \n    float distance_OC_OCD = dot(OC,OC) - t_OCD*t_OCD;\n    \n    float t_OC_OCD_R = sqrt(pow(SphereRadius,2.) - pow(distance_OC_OCD,2.0));\n    if (t_OC_OCD_R > SphereRadius) return color;\n    \n    vec3 intersection1 = (t_OCD - t_OC_OCD_R)*raycastDir + cam.pos;\n    vec3 intersection2 = (t_OCD + t_OC_OCD_R)*raycastDir + cam.pos;\n    \n    if(length(intersection1 - cam.pos) < length(intersection2 - cam.pos) && (t_OCD - t_OC_OCD_R) > 0.)\n    {\n        \n        return color = vec3(1.0,0.0,0.0);\n    }\n    \n    if(length(intersection2 - cam.pos) < length(intersection1 - cam.pos) && (t_OCD + t_OC_OCD_R) > 0.)\n    {\n        return color = vec3(0.0,1.0,0.0);\n    }    \n    return color;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec3 color = ex2(fragCoord);\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lVXzV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[372, 372, 460, 532, 727], [729, 729, 758, 758, 3531], [3532, 3532, 3589, 3589, 3685]], "test": "valid"}
{"id": "3s2cRm", "name": "Hexagram Vesica", "author": "Dain", "description": "Pretty basic, vesica is used for tips of hexagram", "tags": ["hexagram", "vesica"], "likes": 1, "viewed": 201, "published": "Public API", "date": "1586343218", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n\nfloat sdHexagramVesica(vec2 p, float r, float d)\n{ \n    //Hexagram stuff by iq\n \tconst vec4 k = vec4(-0.5,0.86602540378,0.57735026919,1.73205080757);\n\t\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n \tp -= 2.0*min(dot(k.yx,p),0.0)*k.yx;\n    p -= vec2(clamp(p.x,r*k.z,r*k.w),r);\n    \n   // p = abs(p) - r;//optional fun\n    p = abs(p);//abs again to prevent wigging out on inside, and make it hollow\n\t\n    //IQ Vesica code\n    float b = sqrt(r*r-d*d);  // can delay this sqrt by rewriting the comparison\n    return ((p.y-b)*d > p.x*b) ? length(p-vec2(0.0,b))*sign(d)\n                               : length(p-vec2(-d,0.0))-r;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n\tfloat d = sdHexagramVesica( p, 0.37, -0.25*abs(cos(iTime)) )- 0.2*(sin(iTime*1.3));\n\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-4.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(140.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.005,abs(d)) );\n\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s2cRm.jpg", "access": "shaders20k", "license": "mit", "functions": [[20, 20, 70, 98, 655], [656, 656, 713, 713, 1141]], "test": "valid"}
{"id": "3s2cW3", "name": "Marbled landscape", "author": "jarble", "description": "This fractal is based on my [url=https://www.shadertoy.com/view/tlKSDG]\"Snow forest biome\"[/url] shader.", "tags": ["fractal", "landscape", "pseudorandom", "biome"], "likes": 1, "viewed": 204, "published": "Public API", "date": "1587439689", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//This parameter changes the magnification.\nconst float mag = 9.0;\nconst float distortion_scale = mag*mag;\n\nconst int GREEN = 0;\nconst int BLUE = 1;\nconst int GRAY = 2;\nconst int YELLOW = 3;\nconst int WHITE = 4;\nconst int FOREST_GREEN = 5;\nconst int LIGHTBLUE = 6;\nconst int SKYBLUE = 7;\nconst int SNOW = 8;\nconst int WHITESMOKE = 9;\nconst int LIGHTGRAY = 10;\nconst int LIME = 11;\nconst int LIGHTYELLOW = 12;\nconst int BEIGE = 13;\nconst int SAND = 14;\nconst int TAN = 15;\nconst int ORANGE = 16;\nconst int RED = 17;\nconst int BLACK = 18;\nconst int DARKGRAY = 19;\nconst int ORANGERED = 20;\n\nconst int FOREST_BIOME = 5;\n\n//this function is from https://www.shadertoy.com/view/4djSRW\nint hash12(vec2 p,float num_colors)\n{\n    //set the number of colors to be randomly generated\n    \n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return int(floor(fract((p3.x + p3.y) * p3.z)*num_colors));\n}\n    \nint magnify(vec2 fragCoord,float mag,float num_colors){\n    return hash12(floor(fragCoord/pow(3.0,mag)),num_colors);\n}\n\nivec4 get_neighbors(vec2 fragCoord,float mag,float colors){\n\treturn ivec4(magnify(fragCoord+vec2(0,1),mag,colors),\n        magnify(fragCoord+vec2(1,0),mag,colors),\n        magnify(fragCoord-vec2(0,1),mag,colors),\n        magnify(fragCoord-vec2(1,0),mag,colors));\n}\n\n\nbool is_next_to(int color,ivec4 neighbors){\n\treturn (neighbors.x == color)\n        || (neighbors.y == color)\n        || (neighbors.z == color)\n        || (neighbors.w == color);\n}\n\nvec3 rgb(float r,float g,float b){\n\treturn vec3(r,g,b)/255.0;\n}\n\nvec3 get_color(int color){\n    if(color == BLUE){\n    \treturn vec3(0.149,0.141,0.912);\n   \t}\n    else if(color == GREEN){\n    \treturn vec3(0.000,0.833,0.224);\n   \t}\n    else if(color == FOREST_GREEN){\n    \treturn rgb(34.0,139.0,34.0);\n   \t}\n    else if(color == WHITE){\n    \treturn vec3(1.0,1.0,1.0);\n   \t}\n    else if(color == GRAY){\n    \treturn vec3(192.0,192.0,192.0)/255.0;\n    }\n    else if(color == YELLOW){\n    \treturn vec3(1.0,1.0,0.0);\n   \t}\n    else if(color == LIGHTBLUE){\n    \treturn rgb(173.0,216.0,230.0);\n   \t}\n    else if(color == SKYBLUE){\n    \treturn rgb(135.0,206.0,235.0);\n    }\n    else if(color == SNOW){\n    \treturn rgb(255.0,250.0,250.0);\n    }\n    else if(color == WHITESMOKE){\n    \treturn rgb(245.0,245.0,245.0);\n    }\n    else if(color == LIGHTGRAY){\n    \treturn rgb(211.0,211.0,211.0);\n    }\n    else if(color == LIME){\n    \treturn rgb(0.0,255.0,0.0);\n    }\n    else if(color == LIGHTYELLOW){\n    \treturn rgb(255.0,255.0,153.0);\n    }\n    else if(color == BEIGE){\n    \treturn rgb(245.0,245.0,220.0);\n    }\n    else if(color == TAN){\n    \treturn rgb(210.,180.,140.);\n    }\n    else if(color == ORANGE){\n    \treturn vec3(255,127,80)/255.0;\n    }\n    else if(color == RED){\n    \treturn vec3(1.0,0.0,0.0);\n   \t}\n    else if(color == DARKGRAY){\n    \treturn rgb(128.0,128.0,128.0);\n    }\n    else if(color == ORANGERED){\n    \treturn rgb(255.0,69.0,0.0);\n    }\n}\n\n\nint forest_biome(inout int color1, ivec4 neighbors){\n\tint BLUE = 0;\n    int GREEN = 1;\n    int YELLOW = 2;\n    int GRAY = 3;\n    int FOREST_GREEN = 4;\n    int WHITE = 5;\n    return (color1 == BLUE && is_next_to(GREEN,neighbors))\n        ? GREEN\n    :(color1 == YELLOW)\n        ? GREEN\n    :(color1 == WHITE && is_next_to(FOREST_GREEN,neighbors))\n        ? FOREST_GREEN\n    :(color1 == GRAY && is_next_to(GREEN,neighbors))\n        ? WHITE\n    :(color1 == GREEN && is_next_to(YELLOW,neighbors))\n        ? WHITE\n    :(color1 == GREEN && is_next_to(WHITE,neighbors))\n        ? FOREST_GREEN\n    :(color1 == FOREST_GREEN && is_next_to(GREEN,neighbors))\n        ? GREEN\n    :color1;\n\n}\n\n\nvoid biome(inout int color1, ivec4 neighbors,int biome){\n    color1 = forest_biome(color1,neighbors);\n}\n\nint biome(in vec2 fragCoord,float mag,float zoom,int colors[6],int biome1){\n    fragCoord *= zoom;\n\n    \n    float num_colors = float(colors.length());\n    float warp = 20.0;\n    float avg = (warp*(mag));\n    fragCoord += vec2(sin(fragCoord.y/avg),sin(fragCoord.x/avg))*mag*mag;\n\n    int color1 = magnify(fragCoord,mag,num_colors);\n    \n    ivec4 neighbors;\n    \n    while(mag > 1.0){\n        avg =(warp*(mag));\n        fragCoord += vec2(sin(fragCoord.y/avg),sin(fragCoord.x/avg))*mag*mag;\n\n        neighbors = get_neighbors(fragCoord,mag,num_colors);\n    biome(color1, neighbors,biome1);\n    mag -= 1.0;\n    }\n    return colors[int(color1)];;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = mag*(((iMouse.x-iMouse.y)*2.0+iResolution.x)/iResolution.x);\n    fragCoord *= zoom;\n    fragCoord = fragCoord + floor(iTime*100.0)*vec2(mag,0.0);\n\n    //choose the biome here\n\tint biome = biome(fragCoord,mag,1.0,int[](BLUE,GREEN,YELLOW,GRAY,FOREST_GREEN,WHITE),FOREST_BIOME);\n    \n    fragColor = vec4(get_color(biome),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s2cW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[619, 681, 718, 774, 922], [928, 928, 983, 983, 1046], [1048, 1048, 1107, 1107, 1312], [1315, 1315, 1358, 1358, 1494], [1496, 1496, 1530, 1530, 1559], [1561, 1561, 1587, 1587, 2944], [2947, 2947, 2999, 2999, 3625], [3628, 3628, 3684, 3684, 3731], [3733, 3733, 3808, 3808, 4378]], "test": "error"}
{"id": "3s2yDd", "name": "Noise & UV Mapping_HaoyuSui", "author": "HaoyuSui", "description": "Noise & UV Mapping", "tags": ["noise", "uvmapping"], "likes": 1, "viewed": 37, "published": "Public", "date": "1587598877", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int RAY_STEPS = 256;\nconst float HALF_PI = 3.14159 * 0.5;\n\nconst vec3 a = vec3(0.5, 0.5, 0.4);\nconst vec3 b = vec3(0.5, 0.5, 0.43);\nconst vec3 c = vec3(0.46, 0.57, 0.4);\nconst vec3 d = vec3(0.63, 0.4233, -1.573);\n\nvec3 cosinePalette(float t) {\n    return clamp(a + b * cos(2.0 * 3.14159 * (c * t + d)), 0.0, 1.0);\n}\n\nvec3 cosinePalette1(float t) {\n    return clamp(d + b * sin(iTime) * cos(2.0 * 3.14159 * (a * t + c)), 0.0, 1.0);\n}\n\nfloat random1( vec2 p ) {\n    return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);\n}\n\nfloat random12( vec2 p ) {\n    return fract(sin(dot(p,vec2(789.152,434.7)))*65433.6543);\n}\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat mySmoothStep(float a, float b, float t) {\n    t = t*t*t*(t*(t*6.0 - 15.0) + 10.0);\n    return mix(a, b, t);\n}\n\nfloat WorleyNoise(vec2 uv)\n{\n    // Tile the space\n    vec2 uvInt = floor(uv);\n    vec2 uvFract = fract(uv);\n\n    float minDist = 1.0; // Minimum distance initialized to max.\n\n    // Search all neighboring cells and this cell for their point\n    for(int y = -1; y <= 1; y++)\n    {\n        for(int x = -1; x <= 1; x++)\n        {\n            vec2 neighbor = vec2(float(x), float(y));\n\n            // Random point inside current neighboring cell\n            vec2 point = random2(uvInt + neighbor);\n\n            // Animate the point\n            point = 0.5 + 0.5 * sin(iTime + 6.2831 * point); // 0 to 1 range\n\n            // Compute the distance b/t the point and the fragment\n            // Store the min dist thus far\n            vec2 diff = neighbor + point - uvFract;\n            float dist = length(diff);\n            minDist = min(minDist, dist);\n        }\n    }\n    return minDist;\n}\n\n\nfloat interpNoise2D(vec2 uv) {\n    vec2 uvFract = fract(uv);\n    float ll = random12(floor(uv));\n    float lr = random12(floor(uv) + vec2(1,0));\n    float ul = random12(floor(uv) + vec2(0,1));\n    float ur = random12(floor(uv) + vec2(1,1));\n\n    float lerpXL = mySmoothStep(ll, lr, uvFract.x);\n    float lerpXU = mySmoothStep(ul, ur, uvFract.x);\n\n    return mySmoothStep(lerpXL, lerpXU, uvFract.y);\n}\n\nfloat fbm(vec2 uv) {\n    float amp = 0.5;\n    float freq = 8.0;\n    float sum = 0.0;\n    float maxSum = 0.0;\n    // octaves 4\n    for(int i = 0; i < 4; i++) {\n        sum += interpNoise2D(uv * freq) * amp;\n        maxSum += amp;\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    return sum / maxSum;\n}\n\n\n\nfloat surflet(vec2 P, vec2 gridPoint) {\n    // Compute falloff function by converting linear distance to a polynomial (quintic smootherstep function)\n    float distX = abs(P.x - gridPoint.x);\n    float distY = abs(P.y - gridPoint.y);\n    float tX = 1.0 - 6.0 * pow(distX, 5.0) + 15.0 * pow(distX, 4.0) - 10.0 * pow(distX, 3.0);\n    float tY = 1.0 - 6.0 * pow(distY, 5.0) + 15.0 * pow(distY, 4.0) - 10.0 * pow(distY, 3.0);\n\n    // Get the random vector for the grid point\n    vec2 gradient = random2(gridPoint);\n    // Get the vector from the grid point to P\n    vec2 diff = P - gridPoint;\n    // Get the value of our height field by dotting grid->P with our gradient\n    float height = dot(diff, gradient);\n    // Scale our height field (i.e. reduce it) by our polynomial falloff function\n    return height * tX * tY;\n}\n\n\nfloat PerlinNoise(vec2 uv) {\n    // Tile the space\n    vec2 uvXLYL = floor(uv);\n    vec2 uvXHYL = uvXLYL + vec2(1,0);\n    vec2 uvXHYH = uvXLYL + vec2(1,1);\n    vec2 uvXLYH = uvXLYL + vec2(0,1);\n\n    return surflet(uv, uvXLYL) + surflet(uv, uvXHYL) + surflet(uv, uvXHYH) + surflet(uv, uvXLYH);\n}\n\nvec3 random3( vec3 p ) {\n    return fract(sin(vec3(dot(p,vec3(127.1, 311.7, 191.999)),\n                          dot(p,vec3(269.5, 183.3, 765.54)),\n                          dot(p, vec3(420.69, 631.2,109.21))))\n                 *43758.5453);\n}\n\nfloat surflet3D(vec3 p, vec3 gridPoint)\n{\n    vec3 t3 = abs(p - gridPoint);\n    \n    float tX = 1.f - 6.f * pow(t3.x, 5.f) - 15.f * pow(t3.x, 4.f) + 10.f * pow(t3.x, 3.f);\n    float tY = 1.f - 6.f * pow(t3.y, 5.f) - 15.f * pow(t3.y, 4.f) + 10.f * pow(t3.y, 3.f);\n    float tZ = 1.f - 6.f * pow(t3.z, 5.f) - 15.f * pow(t3.z, 4.f) + 10.f * pow(t3.z, 3.f);\n    \n    vec3 t = vec3(tX, tY, tZ);\n    \n    vec3 gradient = random3(gridPoint);\n    vec3 diff = p - gridPoint;\n    float height = dot(diff, gradient);\n    return height * t.x * t.y * t.z;\n}\n\nfloat PerlinNoise3D(vec3 p)\n{\n    float surfletSum = 0.0;\n    vec3 pXLYLZL = floor(p);\n    \n    for(int dx = 0; dx <= 1; ++dx)\n    {\n        for(int dy = 0; dy <= 1; ++dy)\n        {\n            for(int dz = 0; dz <= 1; ++dz)\n            {\n                surfletSum += surflet3D(p, pXLYLZL + vec3(dx, dy, dz));\n            }\n        }\n    }\n    \n    return surfletSum;\n}\n\n\n\nstruct Intersection\n{\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n};\n    \n// Box with side lengths b\nfloat box(vec3 p, vec3 b)\n{\n  return length(max(abs(p) - b, 0.0));\n}\n\n\nfloat plane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sphere(vec3 p, float r, vec3 c)\n{\n    return distance(p, c) - r;\n}\n\nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\n\n\nvoid sceneMap3D(vec3 pos, out float t, out int hitObj, vec3 lightPos)\n{\n    // back wall\n    t = plane(pos, vec4(0.0, 0.0, -1.0, 5.0));  \n    hitObj = 0;  // 0 is the back wall\n    \n    float t2;\n    \n    if((t2 = plane(pos, vec4(-1.0, 0.0, 0.0, 5.0))) < t)  // right wall\n    {\n        t= t2;\n        hitObj = 1;\n    } \n    if((t2 = plane(pos, vec4(1.0, 0.0, 0.0, 5.0))) < t)  // left wall\n    {\n        t= t2;\n        hitObj = 2;\n    }\n    if((t2 = plane(pos, vec4(0.0, -1.0, 0.0, 7.5))) < t)  // celling \n    {\n        t= t2;\n        hitObj = 3;\n    }\n    if((t2 = plane(pos, vec4(0.0, 1.0, 0.0, 2.5))) < t)  // floor\n    {\n        t= t2;\n        hitObj = 4;\n    }\n    if((t2 = box(rotateY(pos + vec3(-2.2, 0.5, -3), -27.5 * 3.14159 / 180.0), vec3(1.5, 3.0, 1.5))) < t)  // large box\n    {\n        t= t2;\n        hitObj = 5;\n    }\n    if((t2 = sphere(pos, 1.5, vec3(-1.5, 1.0, -1.0))) < t)  // sphere\n    {\n        t= t2;\n        hitObj = 6;\n    }\n}\n\nfloat sceneMap3D(vec3 pos)\n{\n    float t = plane(pos, vec4(0.0, 0.0, -1.0, 5.0));\n    \n    t = min(t, plane(pos, vec4(-1.0, 0.0, 0.0, 5.0)));\n    t = min(t, plane(pos, vec4(1.0, 0.0, 0.0, 5.0)));\n    t = min(t, plane(pos, vec4(0.0, -1.0, 0.0, 7.5)));\n    t = min(t, plane(pos, vec4(0.0, 1.0, 0.0, 2.5)));\n    t = min(t, box(rotateY(pos + vec3(-2.2, 0.5, -3), -27.5 * 3.14159 / 180.0), vec3(1.5, 3.0, 1.5)));\n    t = min(t, sphere(pos, 1.5, vec3(-1.5, 1.0, -1.0)));\n    \n    return t;\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj, vec3 lightPos)\n{\n    t = 0.001;\n    for(int i = 0; i < RAY_STEPS; ++i)\n    {\n        vec3 pos = origin + t * dir;\n        float m;\n        sceneMap3D(pos, m, hitObj, lightPos);\n        if(m < 0.01)\n        {\n            return;\n        }\n        t += m;\n    }\n    // No intersection\n    t = -1.0;\n    hitObj = -1;\n}\n\nvec3 computeNormal(vec3 pos)\n{\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( sceneMap3D(pos + epsilon.yxx) - sceneMap3D(pos - epsilon.yxx),\n                            sceneMap3D(pos + epsilon.xyx) - sceneMap3D(pos - epsilon.xyx),\n                            sceneMap3D(pos + epsilon.xxy) - sceneMap3D(pos - epsilon.xxy)));\n}\n\nvec2 sphereUV(vec3 center, float r, vec3 p)\n{\n    vec3 pDir = normalize(p - center);\n    vec3 worldUp = vec3(0.0, 1.0, 0.0);\n    float theta = acos(dot(pDir, worldUp));\n    // If p is located at the positive part of z axis, then phi is 0-180.\n    // If p is located at the negative part of z axis, then phi is 180-360.\n    vec3 xzDir = normalize(vec3(pDir.x, 0.0, pDir.z));\n    float phi = acos(dot(xzDir, vec3(1.0, 0.0, 0.0)));\n    \n    if(pDir.z < 0.0)\n    {\n        phi = phi + 3.14159;\n    }\n    \n    return vec2(theta / 3.14159, phi / (2.0 * 3.14159));\n}\n\nvoid planeUVAxis(in vec3 p, in vec3 n, out vec3 u, out vec3 v)\n{\n    vec3 worldUp = vec3(0.0, 1.0, 0.0);\n    u = normalize(cross(worldUp, n));\n    v = normalize(cross(n, u));\n}\n\nvec2 planeUV(vec3 origin, vec3 n, vec3 p)\n{\n    vec3 uAxis;\n    vec3 vAxis;\n    planeUVAxis(origin, n, uAxis, vAxis);\n    vec3 diff = p - origin;\n    float uVal = dot(diff, uAxis);\n    float vVal = dot(diff, vAxis);\n    return vec2(uVal, vVal);\n}\n\nvec3 computeMaterial(int hitObj, vec3 p, vec3 n, vec3 lightDir, vec3 view)\n{\n    switch(hitObj)\n    {\n        case 0:  // back wall\n        vec3 normal = vec3(0.0, 0.0, -1.0);\n        vec2 uv0 = planeUV(normal * 5.0, normal, p);\n        float worleyNoiseUV = WorleyNoise(uv0);\n        vec3 color0 = cosinePalette(1.0 - worleyNoiseUV) * dot(lightDir, n);\n        return color0;\n        break;\n        \n        case 1:  // right wall \n        vec3 color1 = vec3(1.0, 0.0, 0.0) * dot(lightDir, n);\n        return color1;\n        break;\n        \n        case 2:  // left wall\n        vec3 color2 = vec3(0.0, 1.0, 0.0) * dot(lightDir, n);\n        return color2;\n        break;\n        \n        case 3:  // celling\n        vec3 color3 = vec3(1.0, 1.0, 1.0) * dot(lightDir, n);\n        return color3;\n        break;\n        \n        case 4:  // floor\n        vec3 normal1 = vec3(0.0, 0.0, -1.0);\n        vec2 uv4 = planeUV(normal1 * 5.0, normal1, p);      \n        uv4.x = (uv4.x + sin(iTime * 0.3) + 1.0) / 3.0;\n        uv4.y = (uv4.y + sin(iTime * 0.3) + 1.0) / 3.0;        \n        float fbmUV4 = fbm(uv4);\n        vec3 color4 = cosinePalette1(fbmUV4);        \n        return color4 * dot(lightDir, n); \n        break;\n        \n        case 5:  // large box\n        vec3 noisePosition = vec3(p.x + sin(iTime * 0.5), p.y + sin(iTime * 0.5), p.z + sin(iTime * 0.5));\n        float perlinNoise = PerlinNoise3D(noisePosition);\n        vec3 color5 = cosinePalette(perlinNoise);\n        return color5 * dot(lightDir, n);\n        break;\n        \n        case 6:  // sphere\n        vec2 uv6 = sphereUV(vec3(2.0, 0.0, 1.0), 1.0, p);        \n        uv6.x = (uv6.x + sin(iTime * 0.2) + 1.0) / 3.0;\n        uv6.y = (uv6.y + sin(iTime * 0.2) + 1.0) / 3.0;        \n        float fbmUV = fbm(uv6);\n        vec3 color6 = cosinePalette1(fbmUV);        \n        return color6 * dot(lightDir, n); \n        break;\n        \n        case -1:\n        return vec3(0., 0., 0.);\n        break;\n        \n    }\n    return vec3(0.0);\n}\n\nIntersection sdf3D(vec3 dir, vec3 eye, vec3 lightPos)\n{\n\tfloat t;\n    int hitObj;\n    \n    march(eye, dir, t, hitObj, lightPos);\n    \n    vec3 isect = eye + t * dir;\n    vec3 nor = computeNormal(isect);\n    vec3 lightDir = normalize(lightPos - isect);\n    \n    vec3 surfaceColor = computeMaterial(hitObj, isect, nor, lightDir, normalize(eye - isect));\n    return Intersection(t, surfaceColor, isect, hitObj);\n}\n\nvoid raycast(vec2 uv, out vec3 dir, out vec3 eye, out vec3 ref)\n{\n    \n    eye = vec3(0.0, 3.0, -15.0);\n    ref = vec3(0.0, 3, 0.0);\n    \n    vec3 look = normalize(ref - eye);\n    vec3 right = normalize(cross(look, vec3(0.0, 1.0, 0.0)));\n    vec3 up = cross(right, look);\n    \n    float tanFovV = tan(3.14159 * 0.125);\n    float len = distance(ref, eye);\n    float aspect = float(iResolution.x) / float(iResolution.y);\n    \n    vec3 V = up * len * tanFovV;\n    vec3 H = right * len * aspect * tanFovV;\n    \n    vec3 p =ref + uv.x * H + uv.y * V;\n    dir = normalize(p - eye);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Light\n\tvec3 lightPos = vec3(0.0, 5.3, -5.0);\n    \n    //Normalized pixel coordinate (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    //[-1, 1]\n    vec2 uv2 = 2.0 * uv - vec2(1.0);\n    \n    vec3 dir, eye, ref;\n    // Cast ray\n    raycast(uv2, dir, eye, ref);\n    \n    // Intersection\n    Intersection isect;\n    \n    isect = sdf3D(dir, eye, lightPos);\n    \n\t \n    \n    //Output color\n    fragColor = vec4(isect.color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s2yDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[220, 220, 249, 249, 321], [323, 323, 353, 353, 438], [440, 440, 465, 465, 527], [529, 529, 555, 555, 619], [621, 621, 645, 645, 738], [740, 740, 787, 787, 855], [857, 857, 885, 907, 1744], [1747, 1747, 1777, 1777, 2147], [2149, 2149, 2169, 2169, 2451], [2455, 2455, 2494, 2604, 3274], [3277, 3277, 3305, 3327, 3571], [3573, 3573, 3597, 3597, 3816], [3818, 3818, 3859, 3859, 4362], [4364, 4364, 4393, 4393, 4734], [4825, 4852, 4879, 4879, 4920], [4923, 4923, 4954, 4980, 5011], [5013, 5013, 5052, 5052, 5085], [5087, 5087, 5118, 5118, 5201], [5205, 5205, 5276, 5293, 6157], [6159, 6159, 6187, 6187, 6644], [6646, 6646, 6725, 6725, 7024], [7026, 7026, 7056, 7056, 7375], [7377, 7377, 7422, 7422, 7936], [7938, 7938, 8002, 8002, 8114], [8116, 8116, 8159, 8159, 8362], [8364, 8364, 8440, 8440, 10367], [10369, 10369, 10424, 10424, 10779], [10781, 10781, 10846, 10846, 11358], [11360, 11360, 11417, 11430, 11860]], "test": "error"}
{"id": "3s2yRm", "name": "Psyche color test", "author": "trinketMage", "description": "Psyche color test", "tags": ["fbm"], "likes": 11, "viewed": 159, "published": "Public", "date": "1586339726", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(a,b,t) smoothstep(a,b,t)\n\n\nfloat N21 (vec2 p){\n\tfloat d = fract(sin(p.x*110.+(8.21-p.y)*331.)*1218.);\n    return d;\n}\n\nfloat Noise2D(vec2 uv){\n    vec2 st = fract(uv);\n    vec2 id = floor(uv);\n    st = st*st*(3.0-2.0*st);\n    float c=mix(mix(N21(id),N21(id+vec2(1.0,0.0)),st.x),mix(N21(id+vec2(0.0,1.0)),N21(id+vec2(1.0,1.0)),st.x),st.y);\n\treturn c;\n}\n\nfloat fbm (vec2 uv){\n    \n    float c=0.;\n\tc+=Noise2D(uv)/2.;\n    c+=Noise2D(2.*uv)/4.;\n    return c/(1.-1./16.);\n}\n\nvec3 fbm3(vec2 uv){\n    vec3 color;\n\tfloat f1 = fbm(uv);\n    color= mix(vec3(0.1,0.0,0.0),vec3(0.9,0.1,0.1),2.5*f1);\n    \n    float f2 = fbm(2.4*f1+uv+0.15*sin(iTime)*vec2(7.0,-8.0));\n    color= mix(color,vec3(0.6,0.5,0.1),1.5*f2);\n    float f3 = fbm(3.5*f2+uv-0.15*cos(1.5*iTime)*vec2(4.0,3.0));\n    color= mix(color,vec3(0.1,0.35,0.45),f3);\n    \n    return color;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x;\n    vec3 c = fbm3(vec2(5.0,5.0)*uv+sin(0.3*iTime)*0.5);\n    vec3 col = c;\n\n    col.r *= .825;\n    col.g *= .825;\n    fragColor = vec4(col * 2.5,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s2yRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[37, 37, 56, 56, 127], [129, 129, 152, 152, 361], [363, 363, 383, 383, 478], [480, 480, 499, 499, 848], [850, 850, 907, 907, 1098]], "test": "valid"}
{"id": "3s2yzz", "name": "Star rot", "author": "wnu", "description": "1/x rotated", "tags": ["star"], "likes": 3, "viewed": 98, "published": "Public", "date": "1586052573", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592\n\nvec2 rotate(float a,vec2 pos){\n    float c = cos(a);\n    float s = sin(a);\n    mat2 rot = mat2(c,-s,s,c);\n \treturn rot*pos;  \n}\n\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5*iResolution.xy);\n    uv /= iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    //uv *= 200.*(1.-0.8*abs(sin(iTime)));\n    uv *= 16.;\n    \n    //uv = rot*uv;\n\tfloat fVal = 0.;\n    // Time varying pixel color\n    float linterp = abs(fract(iTime/4.)*2.-1.);\n    float linterp0 = abs(fract(iTime/16.)*2.-1.);\n    //linterp = step(0.5,linterp0);\n    linterp = 1.;\n    float linterp1 = abs(fract(iTime/4.)*2.-1.)*0.1+0.55;\n    float linterp2 = abs(fract(iTime/4.)*2.-1.)*0.1+0.0;\n    \n    //float rain = step(0.5,linterp);\n    float rain = 0.;\n    //int iter = int(abs(fract(iTime/2.)*2.-1.)*8.+1.9);\n    //int iter = int(abs(sin(iTime*1.)*8.)+2.);\n    int iter = 8;\n    \n    vec3 sc;\n    vec3 fc = vec3(0.);\n    for(int i = 0; i <iter; i++){\n    float it = float(i);\n    float n = float(iter);\n    uv = rotate(PI/(2.*float(iter)),uv);\n    //vec2 p = rotate(iTime*5.,uv);\n    vec2 p = uv;\n  \t//uv = rot* uv;\n    float xval = 1./abs(p.x);\n    p.y *= 1.;\n    float val = 1.-smoothstep(xval,xval+abs(p.y),abs(p.y));\n    float r = 255.*(it/(n-1.));\n    float b = 255.*((n-1.-it)/(n-1.));\n    //r = 255.;\n    //vec3 color = vec3(b,0.,r)/255.;\n    vec3 color = hsl2rgb(vec3(linterp1*(linterp) + (1.-linterp)*linterp2,0.5,abs(sin((it/(n-1.))+iTime*2.))));\n    \n        \n        \n    sc = vec3(val)*color;    \n        \n    float pbright = 1.-step(0.1,(fc.x+fc.y+fc.z)/3.); \n    float cbright = smoothstep(0.9,1.,val);\n    //fc = cbright*sc + (1.-cbright)*fc; \n    fc = mix(fc,sc,cbright);\n        \n    //fc = mix(sc,fc,0.55);    \n    \n    //fc += sc;    \n        \n    //fVal = max(val,fVal);  \n    \n    }\n    //float val = smoothstep(xval,xval+0.1,abs(uv.y));\n    //float val = step(xval,uv.y);\n    //vec3 col = vec3(fVal);\n    vec3 col = fc;\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s2yzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 51, 51, 148], [150, 150, 177, 177, 320], [322, 322, 379, 429, 2319]], "test": "valid"}
{"id": "3sBcDK", "name": "mandelbrot-zoom-demo", "author": "feefi", "description": "demo for mandelbrot zoom", "tags": ["mandelbrot"], "likes": 1, "viewed": 79, "published": "Public", "date": "1587307204", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float mandelbrot(vec2 c){\n    const float N = 120.;\n    vec2 z = vec2(0.);\n    for(float i = 0.;i<1.0;i+=1./N)\n    {\n        z = vec2(1.*(z.x*z.x-z.y*z.y),2.0*z.x*z.y)+c;\n        if(dot(z,z)>4.) return i/2.;\n        float t = z.x;\n    }\n    return 1.;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    vec2 c = vec2(-.7452,.186) + 2.45*uv *pow(.0015,1.+cos(.2*iTime));\n    \n    float n = mandelbrot(c);\n    //n = 0.5+ 0.5*sin(n);\n    //vec3 red = mix(vec3(0.05,0.12,0.4),vec3(1),0.2);\n    vec3 blue = vec3(40./255., 64./255., 92./255.);\n    float circle = smoothstep(0.0,0.01,length(uv) - .5);\n    vec3 v = mix(vec3(0.92),blue,n);\n    vec3 bg = vec3(25./255., 41./255., 66./255.);\n    v = mix(v,bg,circle);\n    fragColor = vec4(v,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sBcDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 253], [254, 254, 311, 311, 816]], "test": "valid"}
{"id": "3sBcW1", "name": "wavy boi", "author": "nexor", "description": ".", "tags": ["wave"], "likes": 3, "viewed": 111, "published": "Public", "date": "1586510837", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision highp float;\n#define resolution iResolution.xy\n#define time iTime\n#define pi 3.14159\n\nvec3 render(vec2 fc)\n{\n    vec2 p=(fc.xy-.5*resolution)/\n        max(resolution.x,resolution.y);\n    vec2 q=p;\n    float vig=smoothstep(.55,.1,length(p));\n    float cnt=smoothstep(.0,.075,length(p));\n    vec3 col=vec3(.0);\n    float r=10.;\n    float t=fract(time/r);\n    t*=pi*2.;\n    vec3 d=vec3(.0);\n    p*=150.;\n    float k=t*2.;\n    float f=fwidth(length(p));\n    float sky=smoothstep(.0,-.01,q.y);\n    p.xy=p.yx*vec2(-1,1);\n    float g=pow(sin(t*2.),3.)*.4;\n    g*=.3;\n    float i=.3;\n    float j=-5.;\n    p.x=abs(p.x);\n    p.y+=sin(p.x+time)*sky*3.;\n    \n    d.x=abs(pow(p.x,i)/p.x+(1.-sky)*.2)\n        *cos(p.x+j-time*2.)/sin(pow(p.x,i)-k*1.*sky+90.+sky*.2);\n    d.y=sin(j*p.y/p.x-g*sky-time*sky);\n    float w=d.x/d.y;\n    \n    float v=w;\n    w=smoothstep(f*f*length(p),0.,abs(w));\n    col=mix(vec3(.3,.7,1.)\n            ,vec3(1.)\n            ,1.-sky)*v*w;\n    col*=smoothstep(.0,.12,abs(q.y));\n    col*=5.;\n    col*=vig;\n    return col;\n}\n\nvoid mainImage( out vec4 fragcol, in vec2 coord )\n{\n    vec2 fc = coord.xy;\n    vec3 col=render(fc);\n    col=pow(col,vec3(1./2.2));\n    fragcol=vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sBcW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[96, 96, 118, 118, 1042], [1044, 1044, 1095, 1095, 1203]], "test": "valid"}
{"id": "3sBcz3", "name": "Social Distancing", "author": "dr2", "description": "Correct behavior even on a distant icy planet...", "tags": ["space", "fibonacci", "penguin", "tux"], "likes": 10, "viewed": 469, "published": "Public API", "date": "1587029710", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Social Distancing\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Correct behavior even on a distant icy planet...\n// (Pseudopenguins may absorb cp-violating neutrinos)\n\n#define AA  0   // optional antialiasing\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrEllipsDf (vec3 p, vec3 r);\nvec3 SphFib (vec3 v, float n);\nfloat Maxv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec3 RotToDir (vec3 v1, vec3 v2, vec3 p);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec3 Hashv3v3 (vec3 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltDir, qHit, pRand;\nfloat tCur, dstFar, plRot;\nint idObj;\nconst float pi = 3.14159;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat PengDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d, dh, fAng;\n  fAng = -0.2 * pi + 0.1 * pi * SmoothBump (0.25, 0.75, 0.1, mod (0.2 * tCur + pRand.z, 1.)) *\n     sin (16. * pi * tCur);\n  p.y -= 1.5;\n  p.xz = Rot2D (p.xz, 2. * pi * (pRand.y - 0.5) * (1. + 0.05 * tCur));\n  q = p;\n  d = PrEllipsDf (q.xzy, vec3 (1.3, 1.2, 1.4));\n  q.y -= 1.5;\n  dh = PrEllipsDf (q.xzy, vec3 (0.8, 0.6, 1.3));\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.3, 2., -0.4);\n  d = SmoothMin (d, max (dh, - PrCylDf (q, 0.15, 0.3)), 0.2);\n  DMINQ (1);\n  q = p;\n  q.yz -= vec2 (1.6, -0.6);\n  d = max (PrEllipsDf (q, vec3 (0.4, 0.2, 0.6)), 0.01 - abs (q.y));\n  DMINQ (2);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.3, 2., -0.4);\n  d = PrSphDf (q, 0.15);\n  DMINQ (3);\n  q = p;\n  q.x = abs (q.x);\n  q.xy -= vec2 (0.4, -0.8);\n  d = PrCylDf (q.xzy, 0.12, 0.7);\n  DMINQ (4);\n  q -= vec3 (0.1, -0.67, -0.4);\n  q.xz = Rot2D (q.xz, -0.07 * pi);\n  d = PrEllipsDf (q.xzy, vec3 (0.15, 0.5, 0.05));\n  q.z -= 0.5;\n  q.xz = Rot2D (q.xz, 0.15 * pi);\n  q.z -= -0.5;\n  d = SmoothMin (d, PrEllipsDf (q.xzy, vec3 (0.15, 0.5, 0.05)), 0.05);\n  q.z -= 0.5;\n  q.xz = Rot2D (q.xz, -0.3 * pi);\n  q.z -= -0.5;\n  d = SmoothMin (d, PrEllipsDf (q.xzy, vec3 (0.15, 0.5, 0.05)), 0.05);\n  DMINQ (5);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (1.1, 0.3, -0.2);\n  q.yz = Rot2D (q.yz, -0.25 * pi);\n  q.xy = Rot2D (q.xy, fAng) - vec2 (0.1, -0.4);\n  d = PrEllipsDf (q.xzy, vec3 (0.05, 0.25, 0.9));\n  DMINQ (6);\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qn, uf;\n  float dMin, d, rdFac, pszFac;\n  dMin = dstFar;\n  rdFac = 4.;\n  d = PrSphDf (p, rdFac * (1. + 0.14 * 4.));\n  if (d < 0.1) {\n    dMin /= rdFac;\n    q = p / rdFac;\n    q.xz = Rot2D (q.xz, plRot);\n    qn = normalize (q);\n    uf = SphFib (qn, 42.);\n    d = PrSphDf (q, 1.);\n    DMINQ (7);\n    q = RotToDir (uf, vec3 (0., 0., 1.), q - uf);\n    pRand = Hashv3v3 (41. * uf);\n    pszFac = 0.14 * (0.7 + 0.3 * pRand.x);\n    dMin = rdFac * pszFac * PengDf (q.xzy / pszFac, dMin / pszFac);\n  } else dMin = min (dMin, d);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 160; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0002, -0.0002);\n  for (int j = 0; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = 0; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.03 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.7 + 0.3 * sh;\n}\n\nvec3 StarPat (vec3 rd, float scl)\n{\n  vec3 tm, qn, u;\n  vec2 q;\n  float f;\n  tm = -1. / max (abs (rd), 0.0001);\n  qn = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  u = Maxv3 (tm) * rd;\n  q = atan (vec2 (dot (u.zxy, qn), dot (u.yzx, qn)), vec2 (1.)) / pi;\n  f = 0.57 * (Fbm2 (11. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 131.13 * scl * q) +\n      Fbm2 (13. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 171.13 * scl * q.yx));\n  return 16. * vec3 (1., 1., 0.8) * pow (f, 16.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  vec2 vf;\n  float dstObj, sh;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    vf = vec2 (0.);\n    if (idObj == 1 || idObj == 6) vf = vec2 (64., 0.3);\n    else if (idObj == 7) vf = vec2 (16., 4.);\n    if (vf.x > 0.) {\n      vn.xz = Rot2D (vn.xz, plRot);\n      vn = VaryNf (vf.x * qHit, vn, vf.y);\n      vn.xz = Rot2D (vn.xz, - plRot);\n    }\n    if (idObj == 1) col4 = (qHit.z < -0.2 || qHit.z < 0. && length (qHit.xy) < 0.2) ?\n       vec4 (0.95, 0.95, 0.95, 0.05) : vec4 (0.2, 0.2, 0.25, 0.1);\n    else if (idObj == 2) col4 = (qHit.z > -0.3) ? vec4 (1., 0.8, 0.2, 0.2) : vec4 (0.3, 0.7, 1., 0.);\n    else if (idObj == 3) col4 = vec4 (0.15, 0.3, 0.1, 0.3);\n    else if (idObj == 4) col4 = vec4 (0.05, 0.1, 0.05, 0.1);\n    else if (idObj == 5) col4 = vec4 (0.9, 0.9, 0., 0.3);\n    else if (idObj == 6) col4 = vec4 (0.2, 0.2, 0.25, 0.1);\n    else if (idObj == 7) col4 = vec4 (0.7, 0.7, 0.75, 0.);\n    sh = (idObj == 7) ? ObjSShadow (ro, ltDir) : 1.;\n    col = col4.rgb * (0.2 + 0.2 * max (- dot (vn, ltDir), 0.) + 0.8 * sh * max (dot (vn, ltDir), 0.)) +\n       col4.a * step (0.95, sh) * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n  } else {\n    col = StarPat (rd, 32.);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.2 * pi;\n  if (mPtr.z > 0.) {\n    az += 3. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -30. + 10. * sin (0.1 * pi * tCur));\n  zmFac = 4.;\n  dstFar = 80.;\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n  plRot = 0.03 * pi * tCur;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (pow (col, vec3 (0.9)), 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nvec3 SphFib (vec3 v, float n)\n{   // Keinert et al's inverse spherical Fibonacci mapping\n  vec4 b;\n  vec3 vf, vfMin;\n  vec2 ff, c;\n  float fk, ddMin, dd, a, z, ni;\n  const float phi = 1.618034;\n  ni = 1. / n;\n  fk = pow (phi, max (2., floor (log (n * pi * sqrt (5.) * dot (v.xy, v.xy)) /\n     log (phi + 1.)))) / sqrt (5.);\n  ff = vec2 (floor (fk + 0.5), floor (fk * phi + 0.5));\n  b = vec4 (ff * ni, pi * (fract ((ff + 1.) * phi) - (phi - 1.)));\n  c = floor ((0.5 * mat2 (b.y, - b.x, b.w, - b.z) / (b.y * b.z - b.x * b.w)) *\n     vec2 (atan (v.y, v.x), v.z - (1. - ni)));\n  ddMin = 4.1;\n  for (int j = 0; j < 4; j ++) {\n    a = dot (ff, vec2 (j - 2 * (j / 2), j / 2) + c);\n    z = 1. - (2. * a + 1.) * ni;\n    vf = vec3 (sin (2. * pi * fract (phi * a) + vec2 (0.5 * pi, 0.)) * sqrt (1. - z * z), z);\n    dd = dot (vf - v, vf - v);\n    if (dd < ddMin) {\n      ddMin = dd;\n      vfMin = vf;\n    }\n  }\n  return vfMin;\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec3 RotToDir (vec3 v1, vec3 v2, vec3 p)\n{\n  vec3 n;\n  float c;\n  n = normalize (cross (v1, v2));\n  c = dot (v1, v2);\n  return c * p + sqrt (1. - c * c) * cross (n, p) + (1. - c) * dot (n, p) * n;\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec3 Hashv3v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec3 (0., cHashVA3.xy)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sBcz3.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[893, 893, 928, 928, 2354], [2356, 2356, 2378, 2378, 2924], [2926, 2926, 2959, 2959, 3136], [3138, 3138, 3159, 3159, 3409], [3411, 3411, 3448, 3448, 3670], [3672, 3672, 3707, 3707, 4161], [4163, 4163, 4198, 4198, 5496], [5498, 5498, 5554, 5554, 6574], [6576, 6576, 6609, 6609, 6636], [6638, 6638, 6680, 6680, 6731], [6733, 6733, 6768, 6768, 6830], [6832, 6832, 6863, 6920, 7749], [7751, 7751, 7773, 7773, 7811], [7813, 7813, 7858, 7858, 7961], [7963, 7963, 8020, 8020, 8103], [8105, 8105, 8147, 8147, 8303], [8305, 8305, 8341, 8341, 8547], [8549, 8549, 8579, 8579, 8692], [8726, 8726, 8750, 8750, 8862], [8864, 8864, 8888, 8888, 9006], [9008, 9008, 9033, 9033, 9219], [9221, 9221, 9242, 9242, 9397], [9399, 9399, 9428, 9428, 9640], [9642, 9642, 9681, 9681, 9866]], "test": "error"}
{"id": "3sByD1", "name": "Birthday Wish", "author": "piyushslayer", "description": "This is how I'm wishing my friends and relatives a Happy Birthday from now on! ;)", "tags": ["2d", "sdf", "font", "birthday"], "likes": 7, "viewed": 487, "published": "Public API", "date": "1586880957", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535\n#define SAT(x) clamp(0., 1., x)\n#define S(a, b, x) smoothstep(a, b, x)\n\nmat2 rot(float a)\n{\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat sdBox(vec2 p, vec2 b)\n{\n    vec2 d = abs(p) - b;\n    return length(max(d, 0.)) + min(max(d.x, d.y), 0.);\n}\n\nfloat sdA(vec2 uv, float ah, float al, float t, bool inner)\n{\n    uv *= rot(sin((iTime) * 4.) * .1);\n \tfloat a = 0.;\n    a = S(ah, al, sdBox(vec2(uv.x + .1, uv.y) * rot(PI * .08), vec2(t, .25 + t)));\n    a += S(ah, al, sdBox(vec2(uv.x - .1, uv.y) * rot(-PI * .08), vec2(t, .25 + t)));\n    a += S(ah, al, sdBox(vec2(uv.x, uv.y + .05), vec2(.1, t * .8)));\n    a = min(a, S(ah, al, sdBox(uv, vec2(.26, .26))));\n    if(inner)\n    \ta = min(a, S(ah, al, sdBox(uv, vec2(.26, .25))));\n    return a;\n}\n\nfloat sdB(vec2 uv, float ah, float al, float t, float inner)\n{\n\tuv *= rot(sin((iTime) * 4.) * .1);\n    float b = S(ah, al, sdBox(vec2(uv.x + .12, uv.y), vec2(t, .2 + t)));\n    b += S(ah, al, abs(sdBox(vec2(uv.x+t+inner, uv.y-.12), vec2(.1, .0001))-.09)-t*.9);\n    b += S(ah, al, abs(sdBox(vec2(uv.x+t+inner, uv.y+.12), vec2(.1, .0001))-.09)-t*.9);\n    b = min(b, S(ah, al, sdBox(vec2(uv.x - .04, uv.y), vec2(.22, .28))));\n    if (inner > 0.)\n        b = min(b, S(ah, al, sdBox(vec2(uv.x - .0435, uv.y), vec2(.21, .28))));\n    return b; \n}\n\nfloat sdD(vec2 uv, float ah, float al, float t, float inner)\n{\n    uv *= rot(sin(iTime * 4.) * .1);\n\tfloat d = S(ah, al, sdBox(vec2(uv.x + .12, uv.y), vec2(t, .2 + t)));\n    d += S(ah, al, abs(sdBox(vec2(uv.x+t+inner+.06, uv.y), vec2(.1, .0001))-.202)-t);\n    d = min(d, S(ah, al, sdBox(vec2(uv.x - .04, uv.y), vec2(.22, .28))));\n    if (inner > 0.)\n        d = min(d, S(ah, al, sdBox(vec2(uv.x - .07, uv.y), vec2(.236, .26))));\n    return d;\n}\n\nfloat sdH(vec2 uv, float ah, float al, float t)\n{\n    uv *= rot(sin(iTime * 4.) * .1);\n\tfloat h = 0.;\n    h = S(ah, al, sdBox(vec2(uv.x + .12, uv.y), vec2(t, .2 + t)));\n    h += S(ah, al, sdBox(vec2(uv.x - .12, uv.y), vec2(t, .2 + t)));\n    h += S(ah, al, sdBox(uv, vec2(.1, t)));\n    return h;\n}\n\nfloat sdI(vec2 uv, float ah, float al, float t)\n{\n    uv *= rot(sin(iTime * 4.) * .1);\n    return S(ah, al, sdBox(uv, vec2(t, .2 + t)));\n}\n\nfloat sdP(vec2 uv, float ah, float al, float t, float inner)\n{\n    uv *= rot(sin(iTime * 4.) * .1);\n    float p = S(ah, al, sdBox(vec2(uv.x + .12, uv.y), vec2(t, .2 + t)));\n    p += S(ah, al, abs(sdBox(vec2(uv.x+t+inner, uv.y-.106), vec2(.1, .0001))-.1)-t);\n    p = min(p, S(ah, al, sdBox(vec2(uv.x - .04, uv.y), vec2(.22, .28))));\n    if (inner > 0.)\n        p = min(p, S(ah, al, sdBox(vec2(uv.x - .043, uv.y), vec2(.21, .28))));\n    return p;\n}\n\nfloat sdR(vec2 uv, float ah, float al, float t, float inner)\n{\n    uv *= rot(sin(iTime * 4.) * .1);\n    float r = S(ah, al, sdBox(vec2(uv.x + .12, uv.y), vec2(t, .2 + t)));\n    r += S(ah, al, abs(sdBox(vec2(uv.x+t+inner, uv.y-.106), vec2(.1, .0001))-.1)-t);\n    r += S(ah, al, sdBox(vec2(uv.x - .1, uv.y + .18) * rot(-PI * .2), vec2(t, .2)));\n    r = min(r, S(ah, al, sdBox(vec2(uv.x - .04, uv.y - .02), vec2(.22, .28))));\n    if (inner > 0.)\n        r = min(r, S(ah, al, sdBox(vec2(uv.x-.04, uv.y-.02-inner), vec2(.207, .28))));\n    return r;\n}\n\nfloat sdT(vec2 uv, float ah, float al, float t, bool inner)\n{\n    uv *= rot(sin(iTime * 4.) * .1);\n\tfloat tt = S(ah, al, sdBox(vec2(uv.x, uv.y + .03), vec2(t, .23)));\n    tt += S(ah, al, sdBox(vec2(uv.x, uv.y - .2), vec2(.23, t)));\n    if(inner)\n        tt = min(tt, S(ah, al, sdBox(uv, vec2(.22, .25))));\n    return tt;\n}\n\nfloat sdY(vec2 uv, float ah, float al, float t, bool inner)\n{\n    uv *= rot(sin(iTime * 4.) * .1);\n    float y = S(ah, al, sdBox(vec2(uv.x, uv.y + .14), vec2(t, .12)));\n    y += S(ah, al, sdBox(vec2(uv.x + .1, uv.y - .14) * rot(PI * .86), vec2(t, .24)));\n    y += S(ah, al, sdBox(vec2(uv.x - .1, uv.y - .14) * rot(-PI * .86), vec2(t, .24)));\n    y = min(y, S(ah, al, sdBox(vec2(uv.x, uv.y + .2), vec2(.45))));\n    if (inner)\n        y = min(y, S(ah, al, sdBox(vec2(uv.x, uv.y + .005), vec2(.3, .245))));\n    return y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n    // background **modified** from: https://www.shadertoy.com/view/wlBGDG\n    vec2 p = uv, o = p;\n    vec3 bk = vec3(0.);\n    float t = (iTime + 25.) * .075, e = length(o), k = o.y + o.x, l, r, a;\n    for(int i = 0; i < 40; ++i)\n    {\n        a = float(i);\n        r = fract(sin(a * 9.7)) * .75;\n        l = length(p = mod(p + vec2(sin(a + a - t), cos(t + a) + t * .1), 2.) - 1.);\n        bk += pow(mix(vec3(.32, .08 , .16), vec3(.4, .3, .1) + vec3(0, k, k) * .064, a / 40.),\n                vec3(3.)) * (pow(max(1. - abs(l - r + e * .2), 0.), 25.) * .2 + smoothstep(r, r - e * .2, l));\n    }\n    \n    vec3 col = mix(mix(vec3(.25, .1, .25), vec3(.35, .25, .015), dot(uv, vec2(.2, .7))), \n                    bk * 6.4, SAT(bk.r + bk.g + bk.b));\n    const vec3 white = vec3(1.);\n    const vec3 shadow = vec3(.1);\n    float shadowStr = .666;\n    float topGrad = SAT(sqrt(uv.y * 1.2));\n    float botGrad = SAT(pow(uv.y * .7 + .5, .24));\n    \n    vec2 st = vec2(uv.x + .76, uv.y - .4);\n\tcol = mix(col, shadow, shadowStr * sdH(st, .06, -.05, .06));\n    col = mix(col, white, sdH(st, .015, .005, .06));\n    col = mix(col, mix(white, vec3(.006, .08, .99), topGrad), \n              SAT(sdH(st, .015, .005, .048)));\n    \n    st = vec2(uv.x + .37, uv.y - .4);\n    col = mix(col, shadow, shadowStr * SAT(sdA(st, .05, -.05, .05, false)));\n    col = mix(col, white, sdA(st, .015, .005, .055, false));\n    col = mix(col, mix(white, vec3(.99, .001, .005), topGrad), \n              sdA(st, .015, .005, .044, true));\n    \n    st = vec2(uv.x, uv.y - .4);\n    col = mix(col, shadow, shadowStr * sdP(st, .06, -.06, .05, 0.));\n    col = mix(col, white, sdP(st, .015, .005, .06, 0.));\n    col = mix(col, mix(white, vec3(.02, .95, .06), topGrad),\n              sdP(st, .015, .005, .046, .01));\n    \n    st = vec2(uv.x - .34, uv.y - .4);\n    col = mix(col, shadow, shadowStr * sdP(st, .06, -.06, .05, 0.));\n    col = mix(col, white, sdP(st, .015, .005, .06, 0.));\n    col = mix(col, mix(white, vec3(.98, .42, .01), topGrad),\n              sdP(st, .015, .005, .046, .01));\n    \n    st = vec2(uv.x - .66, uv.y - .4);\n    col = mix(col, shadow, shadowStr * sdY(st, .05, -.05, .05, false));\n    col = mix(col, white, sdY(st, .015, .005, .06, false));\n    col = mix(col, mix(white, vec3(.98, .01, .34), topGrad), \n              sdY(st, .015, .005, .048, true));\n    \n    st = vec2(uv.x + 1.2, uv.y + .4);\n    col = mix(col, shadow, shadowStr * sdB(st, .06, -.06, .05, 0.));\n    col = mix(col, white, sdB(st, .015, .005, .06, 0.));\n    col = mix(col, mix(white, vec3(.99, .001, .005), botGrad),\n              sdB(st, .015, .005, .046, .01));\n    \n    st = vec2(uv.x + .96, uv.y + .4);\n    col = mix(col, shadow, shadowStr * sdI(st, .06, -.06, .06));\n    col = mix(col, white, sdI(st, .015, .005, .06));\n    col = mix(col, mix(white, vec3(.01, .56, .87), botGrad), \n              sdI(st, .015, .005, .048));\n    \n    st = vec2(uv.x + .71, uv.y + .4);\n    col = mix(col, shadow, shadowStr * sdR(st, .06, -.06, .05, .0));\n\tcol = mix(col, white, sdR(st, .015, .005, .06, .0));\n    col = mix(col, mix(white, vec3(.48, .005, .76), botGrad),\n              sdR(st, .015, .005, .046, .01));\n    \n    st = vec2(uv.x + .32, uv.y + .4);\n    col = mix(col, shadow, shadowStr * sdT(st, .06, -.06, .06, false));\n    col = mix(col, white, sdT(st, .015, .005, .06, false));\n    col = mix(col, mix(white, vec3(.97, .96, .006), botGrad), \n              SAT(sdT(st, .015, .005, .048, true)));\n    \n    st = vec2(uv.x - .08, uv.y + .4);\n    col = mix(col, shadow, shadowStr * sdH(st, .06, -.05, .06));\n    col = mix(col, white, sdH(st, .015, .005, .06));\n    col = mix(col, mix(white, vec3(.98, .01, .34), botGrad), \n              SAT(sdH(st, .015, .005, .048)));\n\n    st = vec2(uv.x - .45, uv.y + .4);\n    col = mix(col, shadow, shadowStr * sdD(st, .06, -.06, .05, 0.));\n    col = mix(col, white, sdD(st, .015, .005, .06, 0.));\n    col = mix(col, mix(white, vec3(.02, .95, .06), botGrad), \n              sdD(st, .015, .005, .046, .01));\n    \n    st = vec2(uv.x - .82, uv.y + .4);\n    col = mix(col, shadow, shadowStr * sdA(st, .05, -.05, .05, false));\n    col = mix(col, white, sdA(st, .015, .005, .055, false));\n    col = mix(col, mix(white, vec3(.006, .08, .99), botGrad), \n              sdA(st, .015, .005, .044, true));\n    \n    st = vec2(uv.x - 1.12, uv.y + .4);\n    col = mix(col, shadow, shadowStr * sdY(st, .05, -.05, .05, false));\n    col = mix(col, white, sdY(st, .015, .005, .06, false));\n    col = mix(col, mix(white, vec3(.98, .42, .01), botGrad), \n              sdY(st, .015, .005, .048, true));\n    \n    fragColor = vec4(pow(col, vec3(.8)), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sByD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[96, 96, 115, 115, 167], [169, 169, 198, 198, 281], [283, 283, 344, 344, 775], [777, 777, 839, 839, 1315], [1317, 1317, 1379, 1379, 1761], [1763, 1763, 1812, 1812, 2059], [2061, 2061, 2110, 2110, 2199], [2201, 2201, 2263, 2263, 2647], [2649, 2649, 2711, 2711, 3194], [3196, 3196, 3257, 3257, 3518], [3520, 3520, 3581, 3581, 4039], [4041, 4041, 4098, 4098, 8781]], "test": "valid"}
{"id": "3sByRc", "name": "大龙猫 - Quicky#035", "author": "totetmatt", "description": "3Ding\nKind of like the unintentional  color / cellshading like effect ", "tags": ["quicky"], "likes": 3, "viewed": 237, "published": "Public API", "date": "1587322714", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n#define ITER 32.\n#define PI 3.141592\n#define bpm iTime * (130/60)\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\nmat2 r(float a){\n    float c=cos(a),s=sin(a);\n    return mat2(c,s,-s,c);\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat fig(vec3 p,float offset) {\n     p.yz = p.zy;\n     p.xy*=r(p.z*2.+iTime+offset);\n     \n     \n     //float t = fract(iTime*.1)*10. <= 5. ? iTime*8. : floor(iTime*8.) ;\n     float  t = iTime*4.;\n     return sdTorus(p,vec2(.4+sin(offset+t+atan(p.x,p.z)*6.)*.2+.75,.05))*.4;\n}\nvec2 SDF(vec3 p) {\n     float f = 100.;\n     float id = 0.;\n     for(float i=0.;i<=1.;i+=1./6.){\n         float o = fig(p,i*acos(-1.)/(4.+sin(iTime+i)));\n         \n         f = min(f,o);\n         if(f == o) id = i;\n     \n     }\n     \n     return vec2(id,f);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n     \n    vec3 ro =vec3(0.,0.,-3.),\n    p = ro,\n    rd = normalize(vec3(uv,1.)),\n    col = vec3(0);\n     \n    float shad = 0.;\n    bool hit = false;\n    vec2 d = vec2(0.);\n    for(float i=0.;i < ITER; i++) {\n        d = SDF(p);\n        if(d.y< 0.001) {\n            hit = true;\n            shad = i / ITER;\n            break;\n        }\n        p += d.y*rd;\n    }\n    \n    if(hit) {\n      \n        col = vec3(1.-shad*d.x,1.10*shad*(1./d.x),smoothstep(.1,0.9,d.x));\n      \n\n    }\n    \n     \n     \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sByRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 38, 38, 121], [188, 188, 241, 241, 300], [301, 301, 317, 317, 375], [376, 376, 409, 409, 474], [475, 475, 507, 507, 752], [753, 753, 771, 771, 1012], [1013, 1013, 1068, 1068, 1659]], "test": "valid"}
{"id": "3sByzG", "name": "Implicit destination", "author": "gambhiro", "description": "Abstract raymarching", "tags": ["abstract"], "likes": 4, "viewed": 286, "published": "Public API", "date": "1586804556", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define i_time iTime\n#define i_resolution iResolution\n\nfloat tt;\nvec3 ap, bp;\nfloat attr;\n\nmat2 rot2(float r) {\n  return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\nfloat sd_cylinder(vec3 p, float r, float height) {\n  float d = length(p.xz) - r;\n  d = max(d, abs(p.y) - height);\n  return d;\n}\n\nfloat sd_box(vec3 p, vec3 b) {\n  vec3 q  = abs(p) - b;\n  return max(max(q.x, q.y), q.z);\n}\n\nfloat spiral(vec3 p) {\n  vec3 q = p - vec3(.0, 2.5, .0);\n  q.y *= 0.04;\n  q.xz *= rot2((sin(q.y + 3.0)-tt*.05)*20.0);\n  q.yz *= rot2(radians(20.0));\n  q.y *= 0.18;\n  q = abs(q) - vec3(0.3, -.55, 3.0);\n  q -= vec3(.5, .05, 0.);\n  float d = length(q) - .7;\n  return d*0.5;\n}\n\nvec2 rails(vec3 p) {\n  vec3 q = p;\n\n  q.y -= .4;\n  q = abs(q) - vec3(1.2, .2, 0.);\n  vec2 a = vec2(sd_box(q, vec3(.1, .3, 20.)), 1.0);\n\n  q = p;\n  q.z = abs(q.z) - 2.0;\n  q.xy *= rot2(radians(90.0));\n  vec2 b = vec2(sd_cylinder(q - vec3(.8, 0, 0), 0.2, 5.), 1.0);\n\n  a = (a.x < b.x) ? a : b;\n\n  a.x *= 0.8;\n  return a;\n}\n\nvec2 map(vec3 p) {\n  attr = max(0.0, (6.0 - (length(p + vec3(0., 0., 1.0-tt*2.5)) - 6.0)));\n\n  vec3 q = p;\n  vec2 a = vec2(length(q - vec3(0., 0., 10. + tt*2.5)) - 2.5, 2.0);\n\n  q = p;\n  q.z = mod(q.z - 1.0, 11.0);\n  q = abs(q) - vec3(0., 6., 11.);\n  for (int i=0; i<6; i++) {\n    q = abs(q) - vec3(2.0, 0.0, 0.5);\n    //q.xz *= rot2(radians(i*5));\n    q.xy *= rot2(radians(4.+float(i)*1.5));\n  }\n\n  vec2 b = rails(q);\n\n  a = (a.x < b.x) ? a : b;\n\n  float s = sin(tt*.5)*2.0 +  + 1.5;\n  float ss = cos(tt*.5)*2.0 +  + 1.5;\n  q = abs(q) - vec3(s, ss*2.0, 0.);\n  b = rails(q);\n\n  a = (a.x < b.x) ? a : b;\n\n  q = p;\n  q.yz *= rot2(radians(90.0));\n  b = vec2(spiral(q), 1.0);\n\n  a = (a.x < b.x) ? a : b;\n\n  return a;\n}\n\nvec2 trace(vec3 ro, vec3 rd) {\n  vec2 h, t = vec2(0.1);\n  for (int i=0; i<128; i++) {\n    h = map(ro+rd*t.x);\n    if (h.x < .0001 || t.x > 50.0) break;\n    t.x += h.x;\n    t.y = h.y;\n  }\n  if (t.x > 50.0) t.x = 0.0;\n  return t;\n}\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n  vec2 uv = vec2(frag_coord.x / i_resolution.x, frag_coord.y / i_resolution.y);\n  uv -= 0.5;\n  uv /= vec2(i_resolution.y / i_resolution.x, 1);\n\n  tt = i_time*0.5;\n\n  vec3 ro = vec3(0., 1., -20.);\n  ro.z += tt*2.5;\n  // ro.xz *= rot2(tt*.5);\n\n  vec3 cam_target = vec3(0, 5, 0);\n  cam_target.z += tt*2.5;\n\n  vec3 cw = normalize(cam_target - ro);\n  vec3 cu = normalize(cross(cw, vec3(0,1,0)));\n  vec3 cv = normalize(cross(cu, cw));\n\n  vec3 rd = mat3(cu, cv, cw) * normalize(vec3(uv, 0.5));\n\n  vec3 ld = normalize(vec3(.3, .5, -.5));\n\n  // Fibonacci Blue #112358, R: 17, G: 35 B: 88\n\n  vec3 fog = vec3(.066, .137, .345) * (1.0 - (length(uv)-0.2));\n  vec3 col = fog;\n\n  vec2 scene = trace(ro, rd);\n  float t = scene.x;\n\n  if (t > 0.0) {\n    vec3 pp = ro+rd*t;\n\n    vec2 e = vec2(.00035, -.00035);\n    vec3 nor = normalize(e.xyy*map(pp+e.xyy).x +\n                         e.yyx*map(pp+e.yyx).x +\n                         e.xyx*map(pp+e.xyx).x +\n                         e.xxx*map(pp+e.xxx).x);\n\n    vec3 b0 = vec3(.1, .5, .8);\n    vec3 b1 = vec3(0.7, .8, .8);\n    vec3 base = mix(b0, b1, attr);\n\n    if (scene.y == 1.0) {\n\n      float diff = max(0., dot(nor, ld));\n\n      float aor = t/30.;\n      float ao = exp2(-2.*pow(max(0.,1.-map(pp+nor*aor).x/aor),2.));\n\n      float fr = pow(1.+dot(nor,rd),2.);\n\n      vec3 sss = vec3(0.5)*smoothstep(0.,1.,map(pp+ld*0.4).x/0.4);\n\n      col = base*(0.9*ao+0.2)*(diff+sss);\n      col = mix(col, b0, min(fr, 0.2));\n\n    }\n\n    col = mix(col, fog, 1.0 - exp(-.00005*t*t*t));\n\n    if (scene.y == 2.0) {\n      float fr = pow(1.+dot(nor,rd),5.);\n      col = mix(vec3(0.), base, min(fr, 0.8));\n    }\n\n  }\n\n  frag_color = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sByzG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[91, 91, 111, 111, 161], [163, 163, 213, 213, 290], [292, 292, 322, 322, 382], [384, 384, 406, 406, 656], [658, 658, 678, 678, 978], [980, 980, 998, 998, 1694], [1696, 1696, 1726, 1726, 1925], [1927, 1927, 1984, 1984, 3650]], "test": "valid"}
{"id": "3sfBD8", "name": "3D Perlin Noise Function Test", "author": "jstrom2002", "description": "Testing the 3D perlin noise functions from Micah Caunter's book on procedural generation: https://openworks.wooster.edu/cgi/viewcontent.cgi?article=1705&context=independentstudy", "tags": ["3d", "noise", "perlin"], "likes": 2, "viewed": 96, "published": "Public", "date": "1588097958", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float perlinNoise3D(float x , float y , float z );\nfloat noise3D(float x , float y , float z );\nfloat findNoise3D(int x, int y , int z);\nfloat interpolate(float a , float b , float x);\n\nivec3 seed=ivec3(10,200,300);\nint octaves=11;\nfloat zoom=0.001;\nfloat persistence=50.;\n\nfloat interpolate(float a, float b, float x)\n{\n   //Quintic Interpolation Formula\n\tfloat f = 6.0 * pow(x , 5.0) - 15.0 * pow(x , 4.0) + 10.0 * pow(x , 3.0);\n\treturn a * (1.0 - f) + b * f ; \n}\n\nfloat findNoise3D(int x ,int y ,int z)\n{\n\tint n = x*seed.x + y*seed.y + z*seed.z;\n\tn = (n << 13) ^ n;\n\tint nn = (60493 * (n * n * n) + 19990303 * n + 1376312589) & 0x7fffffff;\n\treturn 1.0 * (float(nn) / 1073741824.0);\n}\n\nfloat perlinNoise3D(float x,float y, float z)\n{\n\tfloat frequency, amplitude ,returnVal = 0.0, maxH= 0.0;\n    for (int o = 0 ; o < octaves ; o++){\n\t\tfrequency = pow(2.0,float(o));\n\t\tamplitude = pow(persistence, float(o) );\n\t\tmaxH += amplitude ;\n\t\treturnVal += (noise3D(x*frequency / zoom, y * frequency / zoom, z * frequency/zoom)) * amplitude;\n\t}\n\treturn (returnVal/maxH);\n}   \n    \n\nfloat noise3D(float x ,float y ,float z)\n{\n\tvec3 Pos = vec3(x , y , z );\n\tivec3 Flr = ivec3 (floor(Pos));\n    \n\tfloat s,t,u,v,a,b,c,d;\n    \n\ts = findNoise3D(Flr.x, Flr.y, Flr.z);\n\tt = findNoise3D(Flr.x + 1, Flr.y, Flr.z);\n\tu = findNoise3D(Flr.x, Flr.y + 1, Flr.z);\n\tv = findNoise3D(Flr.x + 1, Flr.y + 1, Flr.z);\n\ta = findNoise3D(Flr.x, Flr.y, Flr.z + 1);\n\tb = findNoise3D(Flr.x + 1, Flr.y, Flr.z + 1);\n\tc = findNoise3D(Flr.x, Flr.y + 1, Flr.z + 1);\n\td = findNoise3D(Flr.x + 1, Flr.y + 1, Flr.z + 1);\n\n\tfloat int1 = interpolate(s, t, fract(x));\n\tfloat int2 = interpolate(u, v, fract(x));\n\tfloat int3 = interpolate(a, b, fract(x));\n\tfloat int4 = interpolate(c, d, fract(x));\n\tfloat int5 = interpolate(int1, int2, fract(y));\n\tfloat int6 = interpolate(int3, int4, fract(y));\n\n\treturn interpolate(int5, int6 , fract(z));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = iTime*fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = vec3(perlinNoise3D(uv.x,uv.y,sin(uv.y)));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sfBD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[274, 274, 320, 355, 465], [688, 688, 735, 735, 1062], [1072, 1072, 1114, 1114, 1889], [1892, 1892, 1949, 1999, 2193]], "test": "error"}
{"id": "3sfBRn", "name": "Function001", "author": "PoetLuchnik", "description": "Sum of sin", "tags": ["function"], "likes": 2, "viewed": 190, "published": "Public API", "date": "1587567251", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float f(float x)\n{\n    float y = 0.0;\n    float size = 0.25;\n    float speed = 3.14;\n    \n    while(size > 0.001)\n    {\n        y += sin(x * speed + iTime) * size;\n        speed *= 2.0;\n        size *= 0.5;\n    }\n    \n    return y + 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    fragColor = vec4( abs( f(uv.x) - uv.y ) < 0.005 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sfBRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 239], [241, 241, 298, 298, 398]], "test": "error"}
{"id": "3sfBzH", "name": "ruin your vision maybe?", "author": "kamjam21xx", "description": "idk just some trash junk that might mess up your vision.", "tags": ["bad"], "likes": 1, "viewed": 40, "published": "Public", "date": "1587657867", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n        float cX = fragCoord.x/2.0;\n    float resWalkX = iResolution.x / 0.20;\n    \n    float cY = fragCoord.y/2.0;\n    float resWalkY = iResolution.y / 0.20;\n    \n    float flip = sin(iTime);\n    fragColor.b *= 2.0 * fragColor.b; \n    fragColor.b *= 0.2;\n    if(flip >= 0.0) {\n            fragColor.r *= 0.8 + sin(cX + sin(resWalkX));\n            fragColor.g *=0.2;\n    }\n    if(flip <= 0.0){\n        fragColor.g *= 0.8 + sin(cY + sin(resWalkY));\n        fragColor.r *= 0.2;\n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sfBzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 786]], "test": "valid"}
{"id": "3sffz4", "name": "Digital beetroot.", "author": "Logos", "description": "Digital beetroot swiching between natural and alert state :D", "tags": ["fractal", "julia", "sdf", "orbit", "digital", "quaternion", "trap", "beetroot"], "likes": 9, "viewed": 159, "published": "Public", "date": "1587740286", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Robert Śmietana (Logos) - 24.04.2020\n// Dobrzyca, Poland, UE, Earth, Sol, Milky Way, Local Group, Laniakea :)\n\n\n\n//--- some globals ---//\n\nvec3 orbitTrap = vec3(10000.0);\n\n\n//--- camera stuff ---//\n\nmat3 setCamera(in vec3 ro, in vec3 ta)\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(0.0, 1.0, 0.0);\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = normalize(cross(cu, cw));\n\n    return mat3(cu, cv, cw);\n}\n\n\n//--- scene description ---//\n\nvec2 rotate(vec2 v, float a)\n{\n    float ca = cos(a);\n    float sa = sin(a);\n    \n\treturn vec2(ca*v.x + sa*v.y, -sa*v.x + ca*v.y);\n}\n\n\nfloat spring_cyl(vec3 p)\n{\n    bool b = mod(iTime, 5.0) > 2.5;\n    \n\tp.xy  = rotate(b ? p.xy : p.yz, (1.5 + 0.05*sin(17.0*iTime - 2.1*p.z)) * p.z);\n\tp.xy -= vec2(-0.63564, -0.75968);\n\n\treturn max(abs(p.z) - 10.0, length(p.xy) - 0.14414);\n}\n\n\nfloat c3(vec3 p)\n{\n\treturn min(spring_cyl(p), spring_cyl(p.zyx));\n}\n\n\nfloat distanceToScene(vec3 pos)\n{\n\tfloat d = 10000.0;\n\tvec4  p = vec4(pos, 0.0);\n\tvec4 dp = vec4(1.0, 0.0, 0.0, 0.0);\n\tvec4  C = vec4(0.0303, -0.0303, 0.01516, 0.21);\n    \n\tfor (int i = 0; i < 6; i++)\n    {\n\t\tdp = 2.0*vec4(p.x*dp.x - dot(p.yzw, dp.yzw), p.x*dp.yzw + dp.x*p.yzw + cross(p.yzw, dp.yzw));\n\t\tp = vec4(p.x*p.x - dot(p.yzw, p.yzw), vec3(2.0*p.x*p.yzw)) + C;\n\n\t\tfloat r = c3(p.yxz);\n\t\td = min(d, 0.5 * r / length(dp));\n\n        float p2 = dot(p, p);\n\t\torbitTrap = min(orbitTrap, abs(p.zxy));\n\t\tif (p2 > 14.286) break;\n\t}\n\n\treturn 0.45*min(d, length(pos) - 0.9771);\n}\n\n\n//--- cheap normal computing ---//\n\nvec3 computeSurfaceNormal(vec3 p)\n{\n    float d = distanceToScene(p);\n    \n    return normalize(vec3(\n        distanceToScene(p + vec3(0.001, 0.0, 0.0)) - d,\n        distanceToScene(p + vec3(0.0, 0.001, 0.0)) - d,\n        distanceToScene(p + vec3(0.0, 0.0, 0.001)) - d));\n}\n\n\n//--- output color ---//\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    \n    //--- camera setup ---//\n    \n    float rtime = 0.32165*iTime;\n    \n    vec2 p   = (-iResolution.xy + 2.0*fragCoord - 1.0) / iResolution.y;\n \tvec3 pos = vec3(25.0*cos(rtime), 25.0*sin(rtime), 10.0);\n    vec3 tar = vec3(0.0);\n    vec3 dir = setCamera(pos, tar) * normalize(vec3(p.xy, 11.6));  \n    \n    \n    //--- distance to nearest object in the scene ---//\n    \n\tfloat t = 0.0;\n\tfor(int i = 0; i < 256; i++)\n    {\n\t\tfloat d = distanceToScene(pos + t*dir);\n\t\tif(d < 0.0023) break;\n        \n\t\tt += d;\n\n        \n\t\t//--- early skip of background pixels ---//\n    \n        if (t > 35.0)\n        {\n            fragColor = vec4(1.0);\n            return;\n        }\n\t}\n    \n    \n    //--- output color depends on few things ---//\n    \n    //bool   b = mod(iTime, 4.0) > 2.0;\n    vec3  sn = computeSurfaceNormal(pos + t*dir);\t\t\t// surface normal\n    float dc = clamp(dot(sn, normalize(pos)), 0.0, 1.0);\t// diffuse component\n    float sr = pow(dc, 56.2);\t\t\t\t\t\t\t\t// specular reflection\n    \n\tfragColor     = 0.4*orbitTrap.xyzz;\n    fragColor    *= 0.75 + 0.5*dc;\n    fragColor    += sr;\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sffz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[214, 214, 254, 254, 423], [457, 457, 487, 487, 589], [592, 592, 618, 618, 831], [834, 834, 852, 852, 901], [904, 904, 937, 937, 1480], [1519, 1519, 1554, 1554, 1792], [1821, 1821, 1876, 1910, 2969]], "test": "valid"}
{"id": "3sffzr", "name": "Sundial by RM. simple shapes", "author": "Shiera", "description": "Following tutorials  \"ShaderToy Tutorial - Ray Marching for Dummies!\"  and \"Ray Marching Simple Shapes\" by \"The Art of Code\". Ended up doing an sundial.", "tags": ["raymarching", "training"], "likes": 1, "viewed": 57, "published": "Public", "date": "1587585310", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\n//for rotating, copied from http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/#rotation-and-translation\nmat4 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, 0, s, 0),\n        vec4(0, 1, 0, 0),\n        vec4(-s, 0, c, 0),\n        vec4(0, 0, 0, 1)\n    );\n}\n\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r){\n    \n    vec3 ab = b-a; \n    vec3 ap = p-a; \n    \n    float t = dot(ab, ap)/dot(ab, ab); \n    t = clamp(t, 0., 1.); \n    \n    vec3 c = a+t*ab;\n    return length(p-c)-r;   \n      \n}   \n\nfloat sdThorus(vec3 p, vec3 o, vec2 r){ \n    p = p-o; \n    float x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n\n    \n} \n\n\nfloat sdSphere(vec3 p, vec3 o, float r){\n   return length(p-o)-r; \n}    \n\nfloat sdBox(vec3 p, vec3 o, vec3 s, float angle){\n   //box with added stuff for rotating the squares in clock face\n   o.z = o.z+2.; \n   p = p-o;\n   p = (inverse(rotateY(angle)) * vec4(p, 1.0)).xyz; \n   p = p-vec3(0, 0, -2); \t\t\n    \n   return length(max(abs(p)-s, 0.)); \n} \n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r){\n    vec3 ab = b-a; \n    vec3 ap = p-a; \n    \n    float t = dot(ab, ap)/dot(ab, ab);     \n    vec3 c = a+t*ab;\n    float x = length(p-c)-r; \n    float y = (abs(t-.5)-.5)*length(ab); \n    float e = length(max(vec2(x, y), 0.)); \n    float i = min(max(x, y), 0.); \n    return e+i;\n}\n\n\n\nfloat GetDist(vec3 p) {\n\n    \n    float sd = sdSphere(p, vec3(0, 0., 7), 1.);\n    float planeDist = p.y;\n    float cd = sdCapsule(p, vec3(0, 2.5, 7), vec3(0, .4, 7), .05); \n    float td = sdThorus(p, vec3(0, .4, 7), vec2(2, .3)); \n    float cyd = sdCylinder(p, vec3(0, -10, 7), vec3(0, .5, 7 ), 2.2);\n    \n    float d = min(sd, planeDist); \n    d = min(d, cd);\n    d = min(d, td);\n    \n    d = min(d, cyd);\n    //12 squares for sun dial face\n    for (int i = 0; i <= 12; i++){\n        float bd = sdBox(p, vec3(0, .61, 5), vec3(.05,.1,.2), .1+(2.*3.14*float(i)/12.)); //draw box\n        d = min(d, bd);\n    }        \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.; \n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p); \n        dO += dS; \n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p); \n    vec2 e = vec2(.01, 0); \n    \n    vec3 n = d - vec3( \n        GetDist(p-e.xyy), \n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n); \n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 3.5, 7); \n    lightPos.xz += 1.*vec2(sin(iTime), cos(iTime)); \n    vec3 l = normalize(lightPos-p); \n    vec3 n = GetNormal(p); \n    \n    float dif = clamp(dot(n, l), 0., 1.); \n    float d = RayMarch(p+n*SURF_DIST*2., l); \n    if(d<length(lightPos-p)) dif *= .1; \n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y; \n\n    vec3 col = vec3(0); \n    \n    //camera\n    vec3 ro = vec3(0, 3, 0); \n    vec3 rd = normalize(vec3(uv.x, uv.y-.2, 1));\n    \n    //march\n    float d = RayMarch(ro, rd); \n    vec3 p = ro + rd * d;\n    \n    //light\n    float dif = GetLight(p); \n    col = vec3(dif); \n    \n    //color\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sffzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 193, 220, 220, 403], [406, 406, 455, 455, 636], [641, 641, 680, 680, 772], [776, 776, 816, 816, 844], [850, 850, 899, 964, 1121], [1124, 1124, 1174, 1174, 1453], [1457, 1457, 1480, 1480, 2088], [2090, 2090, 2124, 2124, 2333], [2335, 2335, 2359, 2359, 2553], [2555, 2555, 2579, 2579, 2893], [2895, 2895, 2952, 2952, 3330]], "test": "error"}
{"id": "3sjcDV", "name": "Rainbow Temple - 263 chars", "author": "GregRostami", "description": "All credits goes to @yosshin4004.\nhttps://twitter.com/yosshin4004/status/1251357672504360966\nThis is a fork of vahidk's Infinite Tunnel.\nI just LOVE the shadows!\n\nA BIG thanks to Fabrice for helping me reduce the original shader.", "tags": ["raymarching", "2tweets", "short", "golf", "infinitetunnel"], "likes": 15, "viewed": 420, "published": "Public API", "date": "1587363334", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"Infinite Tunnel\" by vahidk. https://shadertoy.com/view/tdSyDG\n// 2020-04-20 06:00:14\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    O-=O;\n    vec3  R = iResolution,\n          d = vec3((U+U-R.xy)/R.y, 1),\n          q, p=R-R;\n    for (p.z = .1*iTime; O.a++ < 99.;\n         p += .5*d * min( .65-length(fract(p+.5)-.5), p.y + .3) )\n         O.a==65. ? q = p -= d*.01, d += 1.-d : q;\n    ivec3 u = ivec3(q*5e2) & 255;\n    O = vec4( u.yzx ^ u.zxy, 0) / 1e3\n        * (length(p-q)+.8) + p.z*.1-.01*iTime;\n}\n\n// 263 chars - Thanks to Fabrice, everything gets shorter!!\n/*\n#define mainImage(O,U)                                            \\\n    vec3  R = iResolution,                                        \\\n          d = vec3((U+U-R.xy)/R.y, 1),                            \\\n          q, p=R-R;                                               \\\n    for (p.z = .1*iTime; O.a++ < 99.;                             \\\n         p += .5*d * min( .65-length(fract(p+.5)-.5), p.y + .3) ) \\\n         O.a==65. ? q = p -= d*.01, d += 1.-d : q;                \\\n    ivec3 u = ivec3(q*5e2) & 255;                                 \\\n    O = vec4( u.yzx ^ u.zxy, 0) / 1e3                             \\\n        * (length(p-q)+.8) + p.z*.1-.01*iTime\n\n\n// 259 chars - Shortest version, but I don't like the floor.\n\n#define mainImage(O,U)                                            \\\n    vec3  R = iResolution,                                        \\\n          d = vec3((U+U-R.xy)/R.y, 1),                            \\\n          q, p=R-R;                                               \\\n    for (p.z = .1*iTime; O.a++ < 99.;                             \\\n         p += .5*d * min( .65-length(fract(p+.5)-.5), p.y + .3) ) \\\n         O.a==65. ? q = p -= d*.01, d += 1.-d : q;                \\\n    ivec3 u = ivec3(q*5e2) & 255;                                 \\\n    O = vec4( u ^ u.zxy, 0) / 1e3                             \\\n        * (length(p-q)+.9) + p.z*.1-.01*iTime\n\n\n// 278 chars - Greg's Original Fork\n\n#define mainImage(O,U)                                                           \\\n    vec3 R = iResolution, d = vec3((U+U-R.xy)/R.y, 1), q, p=d-d; p.z = iTime*.1; \\\n    for (int i=0; i++<99; p += .5*d* min( .65-length(fract(p+.5)-.5), p.y + .3)) \\\n        i==60 ? q = p -= d*.01, d += 1.-d : q;                                   \\\n    ivec3 u = ivec3(q*5e2) & 255;                                                \\\n    O = vec4(u.x^u.y,u.y^u.z,u.x^u.z,0)/2e3 * (length(p-q)+.9) + (p.z-iTime*.1)*.1\n*/", "image_inputs": [{"id": "Ml23WW", "previewfilepath": "https://soundcloud.com/filipnikolaevic/jean-michel-jarre-oxygen-8-magnetik-rmx", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/filipnikolaevic/jean-michel-jarre-oxygen-8-magnetik-rmx", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sjcDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[98, 98, 134, 134, 506]], "test": "valid"}
{"id": "3sjcRR", "name": "RayMarchingDinner", "author": "DinnerPlz", "description": "RayMarching", "tags": ["raymarching"], "likes": 0, "viewed": 37, "published": "Public", "date": "1585964910", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nfloat GetDist(vec3 p) {\n\tvec4 s = vec4(0,1,6,1);\n    float sphereDist = length(p-s.xyz)-s.w;\n    float  planeDist = p.y;\n    \n    float d = min(sphereDist, planeDist);\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO = 0.;\n    \n    for(int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro +rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO > MAX_DIST || dS < SURF_DIST) break;\n    }\n    \n    return dO;\n}\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01,0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight (vec3 p) {\n    vec3 lightPos = vec3(0,5,6);\n    lightPos.xz += vec2(sin(iTime)*2., cos(iTime)*2.);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l),0.,1.);\n    float d = RayMarch(p+n*SURF_DIST*2.,l);\n    if(d<length(lightPos-p)) dif *=.1;\n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3 (0,1,0);\n    vec3 rd = normalize(vec3(uv.x,uv.y,1));\n    \n    float d = RayMarch(ro,rd);\n    \n    vec3 p = ro + rd * d;\n    \n    float dif = GetLight(p);\n    col = vec3(dif);\n    \n\n    \n    fragColor = vec4(col, 1.);\n    \n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sjcRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 90, 90, 250], [252, 252, 286, 286, 504], [505, 505, 529, 529, 717], [719, 719, 744, 744, 1041], [1043, 1043, 1100, 1100, 1438]], "test": "valid"}
{"id": "3sjcWy", "name": "Noise UV Maps", "author": "sanjanarao", "description": "CIS461 University of Pennsylvania", "tags": ["cis461"], "likes": 0, "viewed": 55, "published": "Public", "date": "1587371005", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int RAY_STEPS = 256;\nconst vec3 lightPos = vec3(0., 5., -7.);\nconst vec3 eyePos = vec3(0.0, 2.5, -20.0);\nconst vec3 refPos = vec3(0., 2.5, 0.);\nconst float PI = 3.14159265359;\nconst float FOVY = 19.5 * PI / 180.;\nconst vec3 center = vec3(0.0, -2.0, -3.0);\n\n\n// Toggle to affect the normals of cube with perliin noise\nbool AFFECT_NORMALS = true;\n    \nstruct Intersection\n{\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n};\n\n/***************** COLOR PALETTES *******************/\n\nconst vec3 a = vec3(0.596, 1., 0.596);\nconst vec3 b = vec3(0.2, 0.4, 0.2);\nconst vec3 c = vec3(2.0, 1.0, 1.0);\nconst vec3 d = vec3(0.00, 0.25, 0.25);\n\nvec3 colorPaletteWorley(float t) { return a + b * cos(6.28 * (t * c + d)); }\nvec3 colorPalettePerlin(float t) { return a + b * cos(6.28 * (t * c + d)); }\nvec3 colorPaletteFBM(float t) {   return a + b * cos(6.28 * (t * c + d)); }\n\n/***************** BASIC SCENE SET UP *******************/\n    \n#define FLOOR_SDF plane(pos, vec4(0, 1, 0, 2.5));\n#define RED_WALL_SDF plane(pos, vec4(1, 0, 0, 5));\n#define GREEN_WALL_SDF plane(pos, vec4(-1, 0, 0, 5));\n#define BACK_WALL_SDF plane(pos, vec4(0, 0, -1, 5));\n#define CEILING_SDF plane(pos, vec4(0, -1, 0, 7.5));\n#define TALL_BOX_SDF sphere(pos, 4., center);\n#define SMALL_BOX_SDF box(rotateY(pos + vec3(-2, 1, 5), -30. * PI / 180.), vec3(1, 7, 1));\n\nconst int FLOOR_ID = 0;\nconst int RED_WALL_ID = 1;\nconst int GREEN_WALL_ID = 2;\nconst int BACK_WALL_ID = 3;\nconst int CEILING_ID = 4;\nconst int TALL_BOX_ID = 5;\nconst int SMALL_BOX_ID = 6;\n\nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\n// Box with side lengths b\nfloat box(vec3 p, vec3 b)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat plane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sphere(vec3 p, float r, vec3 c) {\n    return distance(p, c) - r;\n}\n\nfloat sceneMap3D(vec3 pos) {\n    float flr = FLOOR_SDF;\n    float red_wall = RED_WALL_SDF;\n    float green_wall = GREEN_WALL_SDF;\n    float back_wall = BACK_WALL_SDF;\n    float ceiling = CEILING_SDF;\n    float tall_box = TALL_BOX_SDF;\n    float small_box = SMALL_BOX_SDF;\n    return min(back_wall, min(red_wall, min(green_wall, min(ceiling, min(flr, min(tall_box, small_box))))));\n\n}\n\nvoid sceneMap3D(vec3 pos, out float t, out int obj) {\n    t = FLOOR_SDF;\n    obj = FLOOR_ID;\n\n    float t2 = RED_WALL_SDF\n    if (t2 < t) {\n        t = t2;\n        obj = RED_WALL_ID;\n    } \n    t2 = GREEN_WALL_SDF;\n    if (t2 < t) {\n        t = t2;\n        obj = GREEN_WALL_ID;\n    }\n    t2 = BACK_WALL_SDF;\n    if (t2 < t) {\n        t = t2;\n        obj = BACK_WALL_ID;\n    }\n    t2 = CEILING_SDF;\n    if (t2 < t) {\n        t = t2;\n        obj = CEILING_ID;\n    }\n    t2 = TALL_BOX_SDF;\n    if (t2 < t) {\n        t = t2;\n        obj = TALL_BOX_ID;\n    }\n    t2 = SMALL_BOX_SDF\n    if (t2 < t) {\n        t = t2;\n        obj = SMALL_BOX_ID;\n    }\n}\n\n/***************** RAY MARCHING LOGIC *******************/\n\nvec3 rayCast(vec3 eye, vec3 ref, vec2 uv) {\n\n    float len = tan(FOVY) * distance(eye, ref);\n    vec3 H = normalize(cross(vec3(0.0, 1.0, 0.0), ref - eye));\n    vec3 V = normalize(cross(H, eye - ref));\n    V *= len;\n    H *= len * iResolution.x / iResolution.y;\n    vec3 p = ref + uv.x * H + uv.y * V;\n    return normalize(p - eye);\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj)\n{\n    t = 0.001;\n    for(int i = 0; i < RAY_STEPS; ++i)\n    {\n        vec3 pos = origin + t * dir;\n        float m;\n        sceneMap3D(pos, m, hitObj);\n        if(m < 0.01) { return; }\n        t += m;\n    }\n    t = -1.0;\n    hitObj = -1;\n}\n\n/***************** EFFECTS *******************/\n\nvec2 random2(vec2 p) {\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)),\n        dot(p, vec2(127.1, 311.7)))));\n}\n\n\n\nvec3 random3 ( vec3 p ) {\n    return fract(sin(vec3(dot(p,vec3(127.1, 311.7, 191.999)),\n                          dot(p,vec3(269.5, 183.3, 765.54)),\n                          dot(p, vec3(420.69, 631.2,109.21))))\n                 *43758.5453);\n}\n\nfloat random1(vec2 p) {\n    return fract(dot(fract(cos(vec2(dot(p, vec2(127.1908, 311.7340)),\n        dot(p, vec2(127.1, 311.7))))), vec2(0.1288971, 2403.7)));\n}\n\nvec2 random4 ( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1, 191.999)),\n                          dot(p,vec2(269.5, 765.54)))) * 43758.5453);\n}\n\nfloat noise1D( vec2 p ) {\n    return fract(sin(dot(p, vec2(127.1, 311.7))) *\n                 43758.5453);\n}\n\n\n\nfloat WorleyNoise2D(vec2 p) {\n    // Tile the space\n    vec2 pointInt = floor(p);\n    vec2 pointFract = fract(p);\n\n    float minDist = 1.0; // Minimum distance initialized to max.\n\n    // Search all neighboring cells and this cell for their point\n\n    for (int y = -1; y <= 1; y++) {\n        for (int x = -1; x <= 1; x++) {\n            vec2 neighbor = vec2(float(x), float(y));\n\n            // Random point inside current neighboring cell\n            vec2 point = random4(pointInt + neighbor);\n\n            // Animate the point\n            point = 0.5 + 0.5 * sin(iTime *  point); // 0 to 1 range\n\n            // Compute the distance b/t the point and the fragment\n            // Store the min dist thus far\n            vec2 diff = neighbor + point - pointFract;\n            float dist = length(diff);\n            minDist = min(minDist, dist);\n        }\n    }\n    return minDist;\n}\n\nfloat interpNoise2D(float x, float y) {\n    float intX = floor(x);\n    float fractX = fract(x);\n    float intY = floor(y);\n    float fractY = fract(y);\n\n    float v1 = random1(vec2(intX, intY));\n    float v2 = random1(vec2(intX + 1., intY));\n    float v3 = random1(vec2(intX, intY + 1.));\n    float v4 = random1(vec2(intX + 1., intY + 1.));\n\n    float i1 = mix(v1, v2, fractX);\n    float i2 = mix(v3, v4, fractX);\n    return mix(i1, i2, fractY);\n}\n\n\nfloat fbm(vec2 p) {\n    float total = 0.;\n    float persistence = 0.5f;\n    float octaves = 4.;\n\n    for(float i = 1.; i <= octaves; i++) {\n        float freq = pow(2.f, i);\n        float amp = pow(persistence, i);\n\n        total += interpNoise2D(p.x * freq + cos(iTime),\n                               p.y * freq + sin(iTime)) * amp;\n    }\n    return total;\n}\n\n\nfloat surflet(vec3  p, vec3 gridPoint) {\n    // Compute the distance between p and the grid point along each axis, and warp it with a\n    // quintic function so we can smooth our cells\n    vec3 t2 = abs(p - gridPoint);\n    vec3 t;\n    t.x = 1.f - 6.f * pow(t2.x, 5.f) + 15.f * pow(t2.x, 4.f) - 10.f * pow(t2.x, 3.f);\n    t.y = 1.f - 6.f * pow(t2.y, 5.f) + 15.f * pow(t2.y, 4.f) - 10.f * pow(t2.y, 3.f);\n    t.z = 1.f - 6.f * pow(t2.z, 5.f) + 15.f * pow(t2.z, 4.f) - 10.f * pow(t2.z, 3.f);\n\n    // Get the random vector for the grid point (assume we wrote a function random2\n    // that returns a vec2 in the range [0, 1])\n    vec3 gradient = random3(gridPoint) * 2. - vec3(1.);\n    // Get the vector from the grid point to P\n    vec3 diff = p - gridPoint;\n    // Get the value of our height field by dotting grid->P with our gradient\n    float height = dot(diff, gradient);\n    // Scale our height field (i.e. reduce it) by our polynomial falloff function\n    return height * t.x * t.y * t.z;\n}\n\nfloat perlin(vec3 p) {\n    float surfletSum = 0.f;\n    // Iterate over the four integer corners surrounding uv\n    for(int dx = 0; dx <= 1; ++dx) {\n        for(int dy = 0; dy <= 1; ++dy) {\n             for(int dz = 0; dz <= 1; ++dz) {\n                 surfletSum += surflet(p, floor(p) + vec3(dx, dy, dz));\n             }\n        }\n    }\n    return surfletSum + sin(iTime);\n}\n \nvoid CoordinateSystem(in vec3 v1, out vec3 v2, out vec3 v3) {\n    if (abs(v1.x) > abs(v1.y))\n            v2 = vec3(-v1.z, 0.0, v1.x) / sqrt(v1.x * v1.x + v1.z * v1.z);\n        else\n            v2 = vec3(0.0, v1.z, -v1.y) / sqrt(v1.y * v1.y + v1.z * v1.z);\n        v3 = cross(v1, v2);\n}\n\nvec3 perlinTangentSpaceNormal(vec3 pos) {\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( perlin(pos + epsilon.yxx) - perlin(pos - epsilon.yxx),\n                            perlin(pos + epsilon.xyx) - perlin(pos - epsilon.xyx),\n                            perlin(pos + epsilon.xxy) - perlin(pos - epsilon.xxy)));\n}\n\n\nmat3 TangentToWorld(vec3 nor) {\n    vec3 tangent, bitangent;\n    CoordinateSystem(nor, tangent, bitangent);\n    return mat3(tangent, bitangent, nor);\n}\n\n\nvec2 uvSphere(vec3 pos) {\n    \n    vec3 d =  normalize(center - pos); \n    float u = 0.5 + atan(d.z, d.x) / (2. * PI);\n    float v = 0.5 - asin(d.y) / PI;\n    return vec2(u, v);\n}\n\n\n/***************** MATERIALS *******************/\n\nvec3 computeNormal(vec3 pos)\n{\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( sceneMap3D(pos + epsilon.yxx) - sceneMap3D(pos - epsilon.yxx),\n                            sceneMap3D(pos + epsilon.xyx) - sceneMap3D(pos - epsilon.xyx),\n                            sceneMap3D(pos + epsilon.xxy) - sceneMap3D(pos - epsilon.xxy)));\n}\n\nvec3 computeMaterial(int hitObj, vec3 p, vec3 n, vec3 lightDir, vec3 view) {\n    //disrupt normals \n    vec3 perlin_normal = perlinTangentSpaceNormal(p);\n    perlin_normal = TangentToWorld(n) * perlin_normal;\n    float perlin_lambert = max(0., dot(view, perlin_normal));\n\n    float lambert = max(0., dot(lightDir, n));\n    if (hitObj == 3) { return lambert *  colorPaletteWorley(WorleyNoise2D(vec2(p.x, p.y))); }\n    if (hitObj == 5) { return lambert * colorPaletteFBM(fbm(uvSphere(p))); }\n    if (hitObj == 6) { \n        if (AFFECT_NORMALS) { return colorPalettePerlin(perlin(p))* perlin_lambert; } \n        else { return colorPalettePerlin(perlin(p)) * lambert; }    \n    } else { return vec3(0., 0., 1) * lambert; }\n}\n\n/***************** BASIC FUNCTIONALITY *******************/\n\nIntersection sdf3D(vec3 dir, vec3 eye)\n{\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj);\n\n    vec3 isect = eye + t * dir;\n    vec3 nor = normalize(computeNormal(isect));\n    vec3 lightDir = normalize(lightPos - isect);\n    \n    vec3 surfaceColor = computeMaterial(hitObj, isect, nor, lightDir, normalize(eye - isect));\n    \n    return Intersection(t, surfaceColor, isect, hitObj);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //Convert to range [-1,1]\n    uv = uv * 2.0 - vec2(1.);\n    \n    vec3 eye = eyePos;\n    vec3 ref = refPos;\n\n    vec3 dir = rayCast(eye, ref, uv);\n    \n    Intersection isect = sdf3D(dir, eye);\n     \n    // Output to screen\n    fragColor = vec4(isect.color, 1.);\n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sjcWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[646, 646, 680, 680, 722], [723, 723, 757, 757, 799], [800, 800, 831, 831, 875], [1530, 1530, 1561, 1561, 1644], [1646, 1673, 1700, 1700, 1787], [1789, 1789, 1820, 1846, 1877], [1879, 1879, 1918, 1918, 1951], [1953, 1953, 1981, 1981, 2336], [3046, 3046, 3089, 3089, 3379], [3381, 3381, 3445, 3445, 3683], [3734, 3734, 3756, 3756, 3851], [3855, 3855, 3880, 3880, 4099], [4101, 4101, 4124, 4124, 4262], [4264, 4264, 4289, 4289, 4416], [4418, 4418, 4443, 4443, 4526], [4530, 4530, 4559, 4581, 5411], [5413, 5413, 5452, 5452, 5860], [5863, 5863, 5882, 5882, 6223], [6226, 6226, 6266, 6410, 7220], [7222, 7222, 7244, 7244, 7597], [7600, 7600, 7661, 7661, 7885], [7887, 7887, 7928, 7928, 8223], [8226, 8226, 8257, 8257, 8377], [8380, 8380, 8405, 8405, 8559], [8613, 8613, 8643, 8643, 8962], [8964, 8964, 9040, 9063, 9684], [9747, 9747, 9787, 9787, 10142], [10144, 10144, 10200, 10200, 10517]], "test": "valid"}
{"id": "3sjyRR", "name": "Chocolate Waterfall", "author": "propagant", "description": "Simple chocolate waterfall. Using traditional raymarching methods... Practicing as always", "tags": ["raymarching", "chocolate"], "likes": 1, "viewed": 261, "published": "Public API", "date": "1585954674", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//---By Matej Vanco 2020 - educational purposes & for fun!\n#define MAX_RENDER 64\n#define MIN_RENDER 16.\n#define EPSILON 0.001\n\nstruct ray\n{\n\tvec3 o;\n    vec3 d;\n    float l;\n};\n\n//---Iq's smooth opu\nvec4 opu(vec4 a, vec4 b)\n{\n    float k = 0.35;\n    float d1 = a.w;\n    float d2 = b.w;\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return vec4(mix(b.rgb,a.rgb,h),mix( d2, d1, h ) - k*h*(1.0-h));\n}\n//---'Geometry' calculation\nvec4 geo(vec3 p)\n{   \n    float fsin = sin(iTime * 1. + p.y * 8.); //---'Chocolate effect'\n\tvec4 s = vec4(vec3(0.5,0.3,0.1)*0.5, pow(length(p - vec3(fsin*0.5,0.2,1.5)) - 0.2,2.)); //---'Sphere'\n\n    vec4 pp = vec4(vec3(0.5,0.3,0.1)*0.2, p.y + 0.25); //---Ground\n    \n    vec4 g0 = opu(s,pp); //---Combine all objects\n    return g0;\n}\n//---'Normals' calculation\nvec3 normal(vec3 p)\n{\n\tvec2 of = vec2(EPSILON,0.);\n    float copy = geo(p).w;\n    return normalize(copy - vec3(geo(p - of.xyy).w, geo(p - of.yxy).w, geo(p - of.yyx).w)); //---Subtract from copy\n}\n//---Traditional soft shadows\nfloat shadow(vec3 ro, vec3 rd, float b)\n{\n\tfloat t = EPSILON;\n    float r = 1.;\n    for(int i = 0; i < 16; i++)\n    {\n        float g = geo(ro + rd * t).w;\n        r = min(r, b * g / t);\n        t += g;\n        if(g < EPSILON)\n            break;\n        \n        if(g >= 4.)\n            break;\n    }\n    return clamp(r,0.4,1.);\n}\n//---Traditional Lambert lighting model + Phong reflection specular\nfloat lighting(vec3 p)\n{\n\tvec3 lpos = vec3(2.5,2.5,-2.5);\n    vec3 lposVec = normalize(p - lpos);\n    vec3 n = normal(p);\n    \n    float spec = pow(max(dot(p, reflect(lposVec,n))*1.5,1.0),2.); //---Specular Phong theory\n    \n    float light = clamp(dot(lposVec, p),0.,1.) * shadow(p, lpos,0.4) * spec;\n    return light;\n}\n\n//---Traditional ray-march\nvec4 march(ray r)\n{\n\tvec3 col = vec3(1.);\n    for(int i = 0; i < MAX_RENDER; i++)\n    {\n        vec3 p = r.o + r.d * r.l;\n        vec4 g = geo(p);\n        r.l += g.w;\n        col = g.rgb;\n    \tif(r.l > MIN_RENDER)\n        \tbreak;   \n    }\n    return vec4(col, r.l);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    ray r;\n    r.o = vec3(0.);\n    r.d = vec3(uv, 1.);\n    vec4 m = march(r);\n    vec3 col = m.rgb * lighting(r.o + r.d * m.w);\n    col*=exp(-0.1 * m.w * m.w * m.w); //---Fog\n    if(m.w > 2.5)\n        col = mix(col,vec3(0.5,0.3,0.), uv.y+0.2); //---'Gradient' background\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sjyRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[178, 199, 225, 225, 409], [410, 438, 456, 456, 771], [772, 799, 820, 820, 994], [995, 1025, 1066, 1066, 1354], [1355, 1423, 1447, 1447, 1744], [1746, 1773, 1792, 1792, 2040], [2043, 2043, 2100, 2100, 2472]], "test": "valid"}
{"id": "3sjyWG", "name": "Conformal Droste effect", "author": "RadoKirov", "description": "math behind this conformal mapping - http://www.ams.org/notices/200304/fea-escher.pdf", "tags": ["droste", "escher", "conformalmapping"], "likes": 7, "viewed": 207, "published": "Public", "date": "1587264506", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision highp float;\n\n#define M_PI 3.1415926535897932384626433832795\n\n// Parameters\nfloat winding = 3.0;\nfloat numSpirals = 1.0;\n\nfloat u_f = 2.0; // scaling\nfloat majorGrid = 2.0;\nfloat minorGrid = 2.0 /* majorGrid */ * 3.0;\n\nfloat speed = 3.0;\n\n// convert from cartisian to polar.\n// returns [r, theta] in x+iy = r e^i * theta\nvec2 polarz(in vec2 c) {\n  return vec2(length(c), atan(c.y, c.x));\n}\n\n// convert from polar to cartisian.\nvec2 cart(in vec2 c) {\n  return vec2(c.x * cos(c.y), c.x * sin(c.y));\n}\n\nvec2 powz(in vec2 c1, in vec2 c2) {\n  vec2 polarC = polarz(c1);\n\n  // (r * e ^ i theta) ^ (x + i y) = r ^ x * r ^ i y * e ^ i x theta * e ^ - y theta\n  // r ^ x * e ^ - y theta * e ^ i (x theta + log (r) y)\n  // |--------- r -------| * e ^ i |------- theta -----|\n\n  float r = pow(polarC.x, c2.x) * exp(-polarC.y * c2.y);\n  float theta = c2.x * polarC.y + log(polarC.x) * c2.y;\n\n  return cart(vec2(r, theta));\n}\n\nvec4 grid(in vec2 uv) {\n  float x = fract(uv.x * majorGrid + 0.07/2.0);\n  float y = fract(uv.y * majorGrid + 0.07/2.0);\n  if (abs(x) < 0.07 || abs(y) < 0.07) {\n    float c = smoothstep(0.9 * 0.07, 0.07, min(abs(x), abs(y)));\n    return vec4(c, c, c, 1.0);\n  }\n  x = fract(uv.x * minorGrid + 0.05/2.0);\n  y = fract(uv.y * minorGrid + 0.05/2.0);\n  if (abs(x) < 0.05 || abs(y) < 0.05){\n    float c = smoothstep(0.0045, 0.05, min(abs(x), abs(y)));\n    return vec4(c, c, c, 1.0);\n  }\n  return vec4(1.0, 1.0, 1.0, 1.0);\n}\n\nvec2 conformal(in vec2 uv) {\n  float P = log(u_f) / M_PI / 2.0;\n  vec2 alpha = vec2(winding / 4.0, numSpirals * P);\n  return powz(uv, alpha);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 c = (2.0 * fragCoord - iResolution.xy) / iResolution.x;\n    vec2 e = conformal(c);\n    \n    float t = iTime / speed;\n    e /= exp(log(u_f) * fract(t / log(u_f)));\n    while (abs(e.x) > 1.0 || abs(e.y) > 1.0) {\n      e /= u_f;\n    }\n    while (abs(e.x) < 1.0 / u_f && abs(e.y) < 1.0 / u_f) {\n      e *= u_f;\n    }\n    \n    fragColor = grid(e + 1.0 / 2.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sjyWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[249, 331, 355, 355, 399], [401, 437, 459, 459, 508], [510, 510, 545, 545, 921], [923, 923, 946, 946, 1438], [1440, 1440, 1468, 1468, 1583], [1585, 1585, 1642, 1693, 2059]], "test": "valid"}
{"id": "3sjyWK", "name": "3D Perlin Noise Ray Marching", "author": "jpayne36", "description": "Rendered with ray marching.", "tags": ["procedural", "3d", "raymarching", "perlinnoise"], "likes": 4, "viewed": 590, "published": "Public", "date": "1587330155", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define EPSILON 0.01\n#define MAX_ITERATIONS 256.0\n#define FAR_PLANE 100.0\n\nvec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nvec4 perm(vec4 x) { return mod289(((x * 34.0) + 1.0) * x); }\n\nfloat noise(vec3 p)\n{\n\tvec3 a = floor(p);\n\tvec3 d = p - a;\n\td = d * d * (3.0 - 2.0 * d);\n\tvec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n\tvec4 k1 = perm(b.xyxy);\n\tvec4 k2 = perm(k1.xyxy + b.zzww);\n\tvec4 c = k2 + a.zzzz;\n\tvec4 k3 = perm(c);\n\tvec4 k4 = perm(c + 1.0);\n\tvec4 o1 = fract(k3 * (1.0 / 41.0));\n\tvec4 o2 = fract(k4 * (1.0 / 41.0));\n\tvec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n\tvec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\treturn o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\nfloat NoiseSDF(vec3 ray)\n{\n\treturn noise(ray) - 1.0;\n}\n\nvec3 SceneColor(vec3 origin, vec3 ray, vec2 uv)\n{\n    vec3 color = vec3(1.0);\n    float depth = 0.1;\n    for (int i = 0; i < int(MAX_ITERATIONS); i++)\n    {\n        float d = NoiseSDF(ray * depth + origin) + clamp(1.0 - depth / 6.0, 0.0, 1.0);\n        if (d < EPSILON)\n        {\n            float t = iTime / 10.0;\n            color.r = cos(uv.x + t + sin(uv.y));\n            color.g = sin(uv.y - t + cos(uv.x));\n            color.b = 0.0;\n            color = color * 0.5 + 0.5;\n            float a = float(i) / MAX_ITERATIONS;\n            return color * (1.0 - a) + a * vec3(1.0);\n        }\n        depth += d;\n        if (depth > FAR_PLANE) { break; }\n    }\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    vec2 xy = fragCoord / iResolution.xy;\n    vec2 uv = (2.0 * fragCoord / iResolution.xy - 1.0) * vec2(1.0, iResolution.y / iResolution.x);\n    vec3 origin = vec3(0.0, 0.0, iTime / 10.0);\n    /*for (int x = -1; x <= 1; x++)\n    {\n        for (int y = -1; y <= 1; y++)\n        {\n            vec3 ray = normalize(vec3(uv + 4.0 * vec2(x, y) / iResolution.xy, 1.0));\n            float weight = 0.0;\n            if (abs(float(x)) + abs(float(y)) == 2.0) { weight = 1.0 / 16.0; }\n            else if (abs(float(x)) + abs(float(y)) == 1.0) { weight = 1.0 / 8.0; }\n            else { weight = 1.0 / 4.0; }\n            fragColor.rgb += weight * SceneColor(origin, ray, xy);\n        }\n    }*/\n    vec3 ray = normalize(vec3(uv, 1.0));\n    fragColor.rgb = SceneColor(origin, ray, uv);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sjyWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 75, 96, 96, 143], [145, 145, 164, 164, 205], [207, 207, 228, 228, 672], [674, 674, 700, 700, 728], [730, 730, 779, 779, 1409], [1411, 1411, 1468, 1468, 2286]], "test": "valid"}
{"id": "3slBD8", "name": "Star with spikes", "author": "toninoni", "description": "Dead simple procedural star with spikes", "tags": ["star", "astronomy", "spike"], "likes": 4, "viewed": 97, "published": "Public", "date": "1588157001", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SPIKE_WIDTH 0.01\n#define CORE_SIZE 0.4\n\nfloat parabola( float x, float k ){\n    return pow( 4.0*x*(1.0-x), k );\n}\n\nfloat cubicPulse( float c, float w, float x ){\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\nvec3 starWithSpikes(vec2 uv, vec3 starColor){\n    float d = 1.0 - length(uv - 0.5);\n\n    float spikeV = cubicPulse(0.5, SPIKE_WIDTH, uv.x) * parabola(uv.y, 2.0) * 0.5;\n    float spikeH = cubicPulse(0.5, SPIKE_WIDTH, uv.y) * parabola(uv.x, 2.0) * 0.5;\n    float core = pow(d, 20.0) * CORE_SIZE;\n    float corona = pow(d, 6.0);\n    \n    float val = spikeV + spikeH + core + corona;\n    return vec3(val * (starColor + val));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.x;\n    uv.y += 0.2;\n    \n    vec3 starColor = vec3(abs(sin(iTime)), 0.1, abs(cos(iTime)));\n    vec3 col = starWithSpikes(uv, starColor);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3slBD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 48, 83, 83, 121], [123, 123, 169, 169, 263], [265, 265, 310, 310, 688], [690, 690, 744, 794, 1031]], "test": "valid"}
{"id": "3slfR4", "name": "Uctumi - Seed of Eucalyptus", "author": "Kali", "description": "My attempt to recreate a music video made in blender by Uctumi, a great chiptune musician and member of our demogroup LIA. \nYoutube video: https://www.youtube.com/watch?v=Riq1D7ngPi0\n", "tags": ["raymarching", "video", "music"], "likes": 9, "viewed": 357, "published": "Public", "date": "1587837551", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float det=.005;\nconst float maxdist=13.;\nconst float pi=3.1459;\nconst vec4 blue=vec4(0.,0.3,1.,0.);\nconst vec4 cyan=vec4(.2,.7,1.5,1.);\nconst vec4 pink=vec4(1.,0.,1.,2.);\nconst vec4 yellow=vec4(1.,1.,0.,3.);\nconst vec4 green=vec4(0.,1.,0.,4.);\nconst vec4 white=vec4(.8, .8,.8,5.);\nfloat id1,id2,id3,id4;\nfloat gdist;\nfloat hitplane;\nfloat rotspeed;\n#define iTime (iChannelTime[0]+step(iChannelTime[0],119.5)*step(118.5,iChannelTime[0])*abs(.5-fract(iChannelTime[0]*2.)))\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nmat2 rot(float a) {\n\tfloat s=sin(a), c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\n\nfloat eq(float a, float b) {\n\treturn step(abs(a-b),.001);\n}\n\nfloat box( vec3 p, vec3 c)\n{\n  vec3 q = abs(p) - c + .05;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - .05;\n}\n\nvec4 radialfold(vec3 p, float s, float o) {\n\tfloat id=floor(atan(p.x,p.z)/pi*s*.5+o+s*.5);\n\tp=vec3(abs(.5-fract(atan(p.x,p.z)/pi*s*.5+o)),p.y,length(p.xz));\n    return vec4(p,id);\n}\n\nfloat ring1(vec3 p) {\n\tvec4 pp=radialfold(p,32.,0.);\n    id1=0.;\n    id1+=yellow.a*eq(pp.a,0.);\n    id1+=yellow.a*eq(pp.a,6.);\n    id1+=yellow.a*eq(pp.a,23.);\n    id1+=pink.a*eq(pp.a,3.);\n    id1+=pink.a*eq(pp.a,15.);\n    id1+=pink.a*eq(pp.a,29.);\n    id1+=green.a*eq(pp.a,11.);\n    id1+=green.a*eq(pp.a,19.);\n    id1+=green.a*eq(pp.a,27.);\n    float d=box(pp.xyz-vec3(0.,0.,5.),vec3(.3));\n    return d;\n}\n\nfloat ring2(vec3 p) {\n\tvec4 pp=radialfold(p,16.,.25);\n    id2=0.;\n    id2+=cyan.a*eq(pp.a,2.);\n    id2+=cyan.a*eq(pp.a,7.);\n    id2+=cyan.a*eq(pp.a,10.);\n    id2+=cyan.a*eq(pp.a,14.);\n    float d=box(pp.xyz-vec3(0.,0.,5.),vec3(.3));\n    return d;\n}\n\nfloat ring3(vec3 p) {\n\tvec4 pp=radialfold(p,32.,0.);\n    id3=0.;\n    id3+=white.a*eq(pp.a,2.);\n    id3+=white.a*eq(pp.a,4.);\n    id3+=white.a*eq(pp.a,6.);\n    id3+=white.a*eq(pp.a,8.);\n    id3+=white.a*eq(pp.a,11.);\n    id3+=white.a*eq(pp.a,13.);\n    id3+=white.a*eq(pp.a,16.);\n    id3+=white.a*eq(pp.a,18.);\n    id3+=white.a*eq(pp.a,21.);\n    id3+=white.a*eq(pp.a,23.);\n    id3+=white.a*eq(pp.a,26.);\n    id3+=white.a*eq(pp.a,30.);\n    id3+=white.a*eq(pp.a,31.);\n    float d=box(pp.xyz-vec3(0.,0.,5.),vec3(.2,.35,.3));\n    return d;\n}\n\nfloat ring4(vec3 p) {\n\tvec4 pp=radialfold(p,18.,.2);\n    id4=0.;\n    id4+=pink.a*eq(pp.a,7.);\n    id4+=pink.a*eq(pp.a,13.);\n    id4+=pink.a*eq(pp.a,17.);\n    id4+=yellow.a*eq(pp.a,10.);\n    id4+=yellow.a*eq(pp.a,3.);\n    float d=box(pp.xyz-vec3(0.,0.,5.),vec3(.3));\n    return d;\n}\n\nvec3 getcolor(float id) {\n\tvec3 col=vec3(0.);\n    col+=blue.rgb*eq(id,blue.a);\n    col+=cyan.rgb*eq(id,cyan.a);\n    col+=pink.rgb*eq(id,pink.a);\n    col+=yellow.rgb*eq(id,yellow.a);\n    col+=green.rgb*eq(id,green.a);\n    col+=white.rgb*eq(id,white.a);\n\treturn col;\n}\n\nfloat tex(vec3 p) {\n    p=abs(.5-fract(p*.3));\n    for (int i=0; i<6; i++) {\n        p=abs(p)/(dot(p,p)+.1)-.8;\n    }\n    return abs(p.y)*.003;\n}\n\n\nfloat planes(vec3 p) {\n    float t=tex(p);\n    float d=p.y+t+.4;\n    d=min(d,-p.y+t+7.5);\n    return d;\n}\n\nvec3 rotscene(vec3 p) {\n\tp.xz*=rot(iTime*rotspeed);\n    return p;\n}\n\n\nvec4 de(vec3 p) {\n    p=rotscene(p);\n\tfloat r1=ring1(p);\n\tfloat r2=ring2(p+vec3(0.,-2.,0.));\n\tfloat r3=ring3(p+vec3(0.,-4.,0.));\n\tfloat r4=ring4(p+vec3(0.,-6.,0.));\n    float d=min(r1,min(r2,min(r3,r4)));\n    float pla=planes(p);\n    d=min(d,pla);\n    hitplane=step(pla,d);\n\tvec3 col=vec3(0.,0.,.5)*hitplane;\n    col+=getcolor(id1)*eq(d,r1);\n    col+=getcolor(id2)*eq(d,r2);\n    col+=getcolor(id3)*eq(d,r3);\n    col+=getcolor(id4)*eq(d,r4);\n    return vec4(col,d);\n}\n\nvec3 normal(vec3 p) {\n\tvec2 d=vec2(0.,.01);\n    return normalize(vec3(de(p+d.yxx).a,de(p+d.xyx).a,de(p+d.xxy).a)-de(p).a);\n}\n\n\n\nvec3 shade(vec3 p, vec3 dir, vec3 col) {\n    vec3 pr=rotscene(p);\n\tif (col!=blue.rgb && hitplane<.5) return col;\n    if (hitplane>.5) {\n    \tcol*=1.+smoothstep(1.,5.,length(p.xz))*(max(0.,sin(atan(pr.x,pr.z)*3.)));\n        col+=smoothstep(0.,5.,length(p.xz)-p.y)*.3;\n    }\n    vec3 n=normal(p);\n\tfloat amb=max(0.,dot(dir,-n))*.3;\n    vec3 ref=reflect(vec3(1.,0.,0.),-n);\n    float spe=pow(max(0.,dot(dir,-ref)),20.);\n    float dif=max(0.,dot(normalize(vec3(1.,.5,0.)),-n));\n    dif+=max(0.,dot(normalize(vec3(0.,-.5,-1.)),-n));\n    return (amb+dif)*col+spe*.3;\n}\n\n\nvec3 march(vec3 from, vec3 dir) {\n\tvec4 d;\n    float td=0.,ref=0.,std=0.;\n    vec3 glow=vec3(0.);\n    vec3 p=from, back=vec3(0.,0.,.1), col=back;\n    vec3 savecol=vec3(0.);\n    vec3 odir=dir;\n    for (int i=0; i<100; i++) {\n    \tp+=dir*d.a;\n        d=de(p);\n        if ((d.a<det && (hitplane<.5 || ref>0.)) || td>maxdist) break;\n        if (d.a<det && hitplane>.5) {\n\t\t\tvec3 n=normal(p);\n            savecol=mix(shade(p, dir, d.rgb),back,smoothstep(5.,8.,length(p.xz)));\n            dir=reflect(dir,n);\n            p+=dir*.1;\n            ref=.5;\n        }\n        td+=d.a;\n    }\n    if (d.a<det) {\n    \tp-=det*2.*dir;\n        col=shade(p, dir, d.rgb);\n    } else {\n        p=from+dir*maxdist;\n        p=rotscene(p);\n        p.y-=2.;\n    \tcol*=1.+pow(max(0.,dot(normalize(p),vec3(1.,0.,0.))),20.)*2.;\n    \tcol*=1.+pow(max(0.,dot(normalize(p),vec3(-1.,0.,0.))),20.)*2.;\n    }\n    col=mix(col,savecol,ref);\n    vec3 sp=p;\n    p=from; d.a=0.;\n    float gtd=0.;\n    float h=hash12(gl_FragCoord.xy)*.05;\n    for (int i=0; i<50; i++) {\n    \tp+=odir*(max(.15,d.a)+h);\n        d=de(p);\n        gtd+=d.a;\n        if (td<maxdist && distance(from,p)>distance(from,sp)+.5) break;\n        //if (length(p.xz)>6.) break;\n        if (d.a<1. && d.rgb!=blue.rgb && hitplane < .5) glow+=d.rgb*exp(-7.*d.a)*(1.2-length(d.rgb)*.2);\n    }\n    \n    float mus=pow(smoothstep(.0,.6,texture(iChannel0,vec2(.3)).r),3.);\n    \n    return col+glow*.3*mus;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(fragCoord-iResolution.xy*.5)/iResolution.y;\n    vec3 dir, from;\n    if (iTime < 32. || (iTime > 95.5 && iTime < 118.5) || (iTime > 150.)) {\n\t    rotspeed=.5;\n        uv.y+=.1;\n        from=vec3(0.,2.2+sin(iTime*.7)*2.2,-4.);\n        dir=normalize(vec3(uv,.7));\n        dir.yz*=rot(.05);\n    }\n    if ((iTime > 32. && iTime < 65.) || (iTime > 118.5 && iTime < 150.)) {\n\t    rotspeed=1.;\n        float s=sin(iTime*.7)*2.5;\n        from=vec3(0.,2.5+s,-6.3);\n        dir=normalize(vec3(uv,.7));\n        dir.yz*=rot(.05-(s+1.)*.1);\n    }\n    if (iTime > 65. && iTime < 95.5) {\n\t    rotspeed=-1.;\n\t    uv.y+=.1;\n        from=vec3(0.,0.2,-4.);\n        dir=normalize(vec3(uv,.7));\n        dir.yz*=rot(.1);\n    }\n\n\n    vec3 col=march(from, dir);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "Mt2GWD", "previewfilepath": "https://soundcloud.com/uctumi/seed-of-eucalyptus", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/uctumi/seed-of-eucalyptus", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3slfR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[478, 478, 500, 500, 617], [619, 619, 638, 638, 694], [697, 697, 725, 725, 756], [758, 758, 786, 786, 885], [887, 887, 930, 930, 1068], [1070, 1070, 1091, 1091, 1475], [1477, 1477, 1498, 1498, 1725], [1727, 1727, 1748, 1748, 2262], [2264, 2264, 2285, 2285, 2545], [2547, 2547, 2572, 2572, 2813], [2815, 2815, 2834, 2834, 2960], [2963, 2963, 2985, 2985, 3068], [3070, 3070, 3093, 3093, 3137], [3140, 3140, 3157, 3157, 3606], [3608, 3608, 3629, 3629, 3732], [3736, 3736, 3776, 3776, 4298], [4301, 4301, 4334, 4334, 5727], [5729, 5729, 5786, 5786, 6569]], "test": "error"}
{"id": "3slfWn", "name": "FlyingToastBoy", "author": "jj99", "description": "Flying Toast Boy", "tags": ["boy", "flying", "toast"], "likes": 5, "viewed": 249, "published": "Public API", "date": "1588033685", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// FLYING TOASTBOY (C) ME\nvec2 rot(vec2 p, float a)\n{\nfloat sa = sin(a), ca = cos(a);\nreturn p * mat2(ca, -sa, sa, ca);\n}   \nfloat seg( in vec2 p, in vec2 a, in vec2 b )\n{\nvec2 ba = b-a;\nvec2 pa = p-a;\nfloat h =clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\nreturn length(pa-h*ba);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nfloat time = iTime;\nvec2 p = (gl_FragCoord.xy - iResolution.xy/2.) / iResolution.y;\np*=1.7+sin(p.x+time*0.9)*0.3;\np = rot(p,0.5+sin(time+p.y*1.2+p.x*0.2)*0.5);\np += sin(time*.87)*1.4;\nvec2 pp = rot(p,degrees(-45.0*0.5));\nfloat d = length(pp-vec2(0.25,0.2))-0.04;\nd = min(d,length(pp-vec2(0.0,0.3))-0.04);\npp = rot(pp,degrees(((pp.x-0.1)*-0.05))*abs(sin(time)*0.85));\nfloat d2 = seg(pp, vec2(-0.1,0.0), vec2(0.2,-0.1));\nfloat angle = atan(p.y, p.x);\nfloat radius = length(p*p) * (1. + sin(p.x*6.0+angle+p.y*9.0 + time)*.1);\nfloat thin = 0.035 + 0.02*sin(p.y*10.0+time*1. + angle);\nvec3 col = vec3(0.5+0.4*cos(angle*vec3(3.7,1.8,2.9))) * thin / abs (radius - 0.3+sin(20.0*p.x*p.y)*0.1);\nd = abs(d)+0.015;\nd = 1.0-smoothstep(0.02,0.025,d);\ncol+=d*(vec3(0.3,1.,0.3)*1.0+sin(time*4.0)*0.3);\nd2 = abs(d2)+0.02;\nd2 = 1.0-smoothstep(0.03,0.04,d2);\ncol.rgb+=d2*vec3(0.9,0.9,0.9);\nfragColor = vec4(col,1.0);\n}\n \n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3slfWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 26, 53, 53, 121], [125, 125, 171, 171, 278], [279, 279, 336, 336, 1236]], "test": "valid"}
{"id": "3slfzN", "name": "Raymarch Infinite spheres", "author": "NRGsama", "description": "Raymarch Infinite spheres\nSDF and infinite duplication code from Inigi Quilez\nSort of fake DOF effect using 1/(1+d*d*0.1) ", "tags": ["raymarching"], "likes": 2, "viewed": 209, "published": "Public", "date": "1587843922", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 50\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nfloat sdSphere( vec3 p, vec3 b )\n{\n  return sin(length(p)) - b.x  ;\n}\nfloat opRep( in vec3 p, in vec3 c , float s )\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return sdSphere(q,vec3(s,s,s));\n}\nfloat getDist(vec3 p) {\n    return opRep(p,vec3(1,1,1),0.04);\n}\nfloat rayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = getDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\nvec3 getNormal(vec3 p) {\n\tfloat d = getDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        getDist(p-e.xyy),\n        getDist(p-e.yxy),\n        getDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat getLight(vec3 p){\n\tvec3 lightPos = vec3(0,1,iTime) ;\n    //lightPos.xz += vec2(2.*sin(iTime),2.*cos(iTime));\n    vec3 lv = normalize(lightPos - p ); \n    vec3 n = getNormal(p) ;\n    float dif = clamp(dot(n,lv),0.,1.)*5. ;\n    float d = rayMarch(p+n*SURF_DIST*2.,lv) ;\n    //if(d<length(lightPos-p)) dif *=.1 ;\n    return dif ;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float speed = 0.05 ; \n    mat2 mat = mat2(vec2(cos(iTime*speed), sin(iTime*speed)), \t\t// first column (not row!)    \n             \t\tvec2(-sin(iTime*speed), cos(iTime*speed)));\n    uv = mat*uv ;\n\tvec3 ro = vec3(0,0.5,iTime);\n    vec3 rd = normalize(vec3(uv.x,uv.y,1));\n    float d = rayMarch(ro,rd);\n    //vec3 p = ro + rd * d ;\n    float dif = 1.0/(1.0+d*d*0.1);\n    vec3 col = vec3(dif*2.,dif/d*2.0,0);\n    //float fog = 1.0 / 1.0 + d*d*0.1;\n    //vec3 col  = vec3(fog) ;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3slfzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 100, 100, 135], [136, 136, 183, 183, 256], [257, 257, 280, 280, 320], [321, 321, 355, 355, 561], [562, 562, 586, 586, 775], [777, 777, 800, 800, 1111], [1112, 1112, 1169, 1169, 1738]], "test": "valid"}
{"id": "3slyWf", "name": "Psychedelic  Kaleidoscope", "author": "brechrt", "description": "Kaleidoscope", "tags": ["psychedelic", "kaleidoscope"], "likes": 4, "viewed": 269, "published": "Public API", "date": "1586362713", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265\n#define TWO_PI 6.28318530\n\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\nuint hash( uvec2 v ) { \n    return hash( v.x ^ hash(v.y)); \n}\n\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\nfloat random( vec2  v ) { \n    return floatConstruct(hash(floatBitsToUint(v)));\n}\n\nfloat noise(vec2 uv){\n\tvec2 i = floor(uv);\n    vec2 f = fract(uv);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat noise( vec2 uv, float detail){\n\tfloat n = 0.;\n    float m = 0.;\n\n    for(float i = 0.; i < detail; i++){\n    \tfloat x = pow(2., i);\n        float y = 1./x;\n        \n        n += noise(uv*x+y)*y;\n        m += y;\n    }\n    \n    return n/m;\n    \n}\nmat2 rot(float a){\n\tfloat c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 selectColor(float b){\n    float n = 4.;\n    vec3 cols[5];\n    cols[0] = vec3( 0.9490196078431372, 0.5686274509803921, 0.23529411764705882);\n    cols[1] = vec3( 0.2627450980392157, 0, 0.39215686274509803);\n    cols[2] = vec3( 0.8784313725490196, 0.08627450980392157, 0.4823529411764706);\n    cols[3] = vec3( 0, 0.7137254901960784, 0.7372549019607844);\n    cols[4] = vec3( 1, 0.5019607843137255, 0);\n    \n    float i = floor(b*n);\n    float f = fract(b*n);\n    f = f*f*(3.-2.*f);\n    int i1 = int(i);\n    int i2 = int(i) + 1;\n    vec3 col = mix(cols[i1], cols[i2], f);\n    //col = col*col*(3.0-2.0*col);\n    \n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec2 gv = vec2(length(uv), atan(uv.y, uv.x)+iTime*.5);\n\t//gv.y += gv.x*.5*sin(iTime*.1);\n    gv.y = (gv.y+PI)/TWO_PI;\n    \n    gv.y = abs(fract(gv.y*5.)-.5);\n    gv.x *= 1.;\n    gv.x += sin(iTime*.05)*sin(iTime*.08+.4)*7.-7.;\n    \n    gv *= rot(noise(gv,2.));\n    float n = noise(gv*5., 1.);\n    vec3 col = selectColor(n*n);//hsv2rgb(vec3(n*n,1.,1.));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3slyWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 70, 70, 201], [202, 202, 224, 224, 263], [265, 265, 297, 297, 717], [718, 718, 743, 743, 799], [801, 801, 822, 822, 1336], [1338, 1338, 1374, 1374, 1588], [1589, 1589, 1607, 1607, 1680], [1682, 1682, 1708, 1708, 2316], [2318, 2318, 2375, 2375, 2849]], "test": "valid"}
{"id": "3ssBWH", "name": "Cuernos--v1", "author": "jorge2017a1", "description": "Cuernos--v1", "tags": ["cuernosv1"], "likes": 2, "viewed": 60, "published": "Public", "date": "1588166859", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//por jorge2017a1-\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define PI 3.14159265358979323846264\n\n\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n\nfloat pi = atan(1.0)*4.0;\nfloat tau = atan(1.0)*8.0;\n\n///------------------------------------\nstruct TObj\n{\n    float tipo;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n   \n};\n\n\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\n\n//-----------------------------------------\n#define MAXREFLECTIONS 2\n#define MAXITER 64\n//-----------------------------------------\nvec3 ambientColor = vec3(0.05, 0.15, 0.2);\nvec3 diffuseColor = vec3(0.2, 0.6, 0.8);\nvec3 specularColor = vec3(1.0, 1.0, 1.0);\nvec3 lightDir = normalize(vec3(0.0, 4.0, 5.0));\nvec3 spherePos = vec3(0.0, 0.5, 0.0);\n//-----------------------------------\n\n\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n\n\n\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n//Sphere function\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\n\n// signed\nfloat box(vec3 p, vec3 b)\n{\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat cyl(vec3 p, float r, float h) {\n\treturn max(length(p.xz) - r, abs(p.y) - h);\n}\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n//---------------------------------------------\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); \n    float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, -sa, +.0,\n\t\t+sa, +ca, +.0,\n\t\t+.0, +.0, +1.0);\n}\n\n\n///---------------------------------------------\n\nfloat opU( float d1, float d2 )\n{\n    return min(d2,d2);\n}\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\n\nfloat sdGrid(vec3 p) {\n\treturn opU(opU(sdBox(p,vec3(5.,.8,.3)),\n               sdBox(p,vec3(1.31,55.2,.3))),\n               sdBox(p,vec3(0.,0.,0.)));\n}\nfloat sdCross(vec3 p) {\n\treturn opU(sdBox(p,vec3(0.,0.,0.)),\n            sdBox(p,vec3(2.6,2.6,2.6)));\n}\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat sdCrossedGrid( vec3 p )\n{\n    float d1 = sdCross(p);\n    float d2 = sdGrid(p);\n    return smin( d2, d1, d2);\n}\n\nvec2 distance_to_obj(in vec3 p)\n{\n    vec3 q = opRep(p,vec3(10.0,10.0,10.0));\n    return vec2(\n       \tsdCrossedGrid(q)\n    );\n}\n\n//----------------------------------------------\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n\n///-----------------------------------------\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\nvec3 LightShading(vec3 N,vec3 L,vec3 V,vec3 color)\n{\n    vec3 diffuse = max(0.,dot(N,-L))*color;\n    vec3 specular = pow(max(0.,dot(N,normalize(-L-V))),100.)*vec3(1.,1.,1.); \n    return diffuse + specular;\n}\n\n    \n    \n//-------------------------------------------------\n\n\n\n\n//0000000000000000000000000000000000000000000000000000000\n\nfloat hash( in vec2 p ) \n{\n    return fract(sin(p.x*15.32+p.y*35.78) * 43758.23);\n}\n\nvec2 hash2(vec2 p)\n{\n\treturn vec2(hash(p*.754),hash(1.5743*p.yx+4.5891))-.5;\n}\n\n\nvec2 noise2(vec2 x)\n{\n    vec2 add = vec2(1.0, 0.0);\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    return mix(mix( hash2(p),          hash2(p + add.xy),f.x),\n                    mix( hash2(p + add.yx), hash2(p + add.xx),f.x),f.y);\n    \n}\n\nmat2 rotate(float a) {\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\n//------------------------------------------\n///https://www.shadertoy.com/view/3dScRc\nfloat softmin(float f1, float f2, float val)\n{\n      float e = max(val - abs(f1 - f2), 0.0);\n      return min(f1, f2) - e*e*0.25 / val;     \n}\n///---------------------------\n\nfloat bxLength(vec2 p)\n{\n    p=abs(p);\n    return max(p.x,p.y);\n}\n\n\n//----------------------------\n// Tunnel pattern studied from shane & shau\n// i.e. https://www.shadertoy.com/view/4tKXzV\nvec2 path(float t) {\n\tfloat a = sin(t*.2 + 1.5), b = sin(t*.2);\n\treturn vec2(a*2., a*b);\n}\n//-------------------------\n\nvec2 pathv2(float t) \n{\n\tfloat a = sin(t*.2 + 1.5), b = sin(t*.2);\n\t//return vec2(a*2., a*b);\n    return vec2(a*2., 1.0);\n}\n\n\n\nfloat GetDist(vec3 p  ) \n{\t\n\n      float d;\n    float dif1;\n    float dif2;\n    \n    d=999.9;\n \n    \n   vec3 pp, p2;\n    pp=p;\n    p2=p;\n    \n \n    float planeDist1 = p.y-5.0;  //piso inf\n    float planeDist1sup = 20.0-p.y;  //piso sup\n    float planeDist2 = p.x+10.0; //pared izq\n    float planeDist3 = 10.0-p.x;  //pared der\n    float planeDist4 = -p.z+30.0;  //pared atras\n   \n    vec2 res;\n    res = vec2(9999, 0);\n    \n    if (iTime<20.0)\n    {\n        float  sdp1= sdSphere(p-vec3(0.0,10.0,20.0+iTime), 1.5 );\n    \tres =opU(res, vec2(sdp1,28)); \n \t}   \n    \n    \n    if (iTime>20.0 &&  iTime<40.0)\n    {\n        float  sdp1= sdSphere(p-vec3(0.0,10.0,40.0+iTime), 1.5 );\n    \tres =opU(res, vec2(sdp1,28)); \n \t}   \n    \n    \n    \n    p.xy -= pathv2(p.z);\n\n    \n    \n    // spinal\n\tfloat t = 2.;\n    p.y=p.y-4.0;\n\tp.z = mod(p.z - t*.65, t) - t*.75;\n\tfloat dd = max(cyl(p.yzx, 1.2, .1), -cyl(p.yzx - vec3(.12, 0, 0), 1.1, 1.9));\n\n    //res =opU(res, vec2(planeDist1,21));\n    res =opU(res, vec2(planeDist1,28));\n    \n   res =opU(res, vec2(dd,6));\n   res =opU(res, vec2(1.0,6));\n  \n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n    \n    return d;\n}\n\n\n\n///----------------------------------------------------------\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n\tfloat dO=0.2;\n    //Determines size of shadow\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = ro + rd*dO;\n        \n        float dS = GetDist(p);\n        \n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) \n        {\n            //mObj.dist=dO; \t\n            mObj.p=p; \t\n            gres2 = vec2(dO,dS); \n            break;\n    \t}    \n        \n    }\n    \n    return dO;\n}\n\n\n//---------------------------------------------------\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n\nfloat GetLightPar(vec3 p, vec3 plig) {\n    vec3 lightPos = plig;\n    //Determine movement of light ex. shadow and light direction and diffusion\n    //lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat saturate(float f)\n{\n\treturn clamp(f,0.0,1.0);\n}\n\n    \n\n#define offset1 4.7\n#define offset2 4.6\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) \n{\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\n\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tif(i==0 )\n    {\n    \n        \n      return vec3(0.0,0.0,0.0);\n    }\n    \n    if(i== 1 )\n    {\n        \n        //return vec3(1, 0.5, 0);\n        \treturn vec3(1.0,0.0,0.0);\n        } \n    if(i== 2 )\n    {\n        //return vec3(1.0, 1.0, 1.0);\n        \treturn vec3(0.0,1.0,0.0);\n        } \n    if(i== 3 )\n    {\n        //return vec3(247./255., 168./255.,  184./255.); \n        \treturn vec3(0.0,0.0,1.0);\n       } \n    if(i== 4 )\n    {\n        \n        //return vec3(0, 1, 1);\n        \treturn vec3(0.0,1.0,1.0);\n        } \n    if(i== 5 )\n    {\n        //return vec3(85./255., 205./255., 252./255.);\n        return vec3(1.0,0.0,1.0);\n        \n        } \n    if(i== 6 )\n    {\n        \n        ///return  vec3(0.5, 0.8, 0.9);\n        return vec3(1.0,0.5,1.0);\n        } \n        \n    if(i== 7 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n       } \n    if(i== 8 )\n    {\n       \n        \n        return vec3(0.425, 0.56, 0.9); \n       } \n    if(i== 9 )\n    {\n        \n        return vec3(0.5, 0.6, 0.6); \n     } \n    if(i== 10 )\n    {\n        return vec3(0.0, 1.0, 0.0);\n    } \n    \n    if(i== 11 )\n    {\n        return vec3(0.25, 0.25, 0.25);\n    } \n    \n     if(i== 15 )\n    {\n    \t\treturn vec3(1.0,0.0,1.);\n       } \n     if(i== 16 )\n    {\n    \t\treturn vec3(1.0,1.0,0.0);\n     } \n    \n    \n    \n    if(i== 21 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*0.12;\n            marbleP.z += sin(p.y*23.0)*0.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.3);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.4,0.4,0.6),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n    \n    \n    \n     if(i== 23)\n    {\n    \n        \n        return  vec3(0.425, 0.16, 0.6);\t\n        \t\n\t} \n    \n    \n    \n    if(i== 24)\n    {\n      float size = (-mObj.uv.y+.1)/2.5;\n     vec3 color = vec3(0.,0.,0.);\n     color += vec3(mod(floor(mObj.uv.x/size+sin(iTime)) + floor(mObj.uv.y*20./size+iTime),2.)-.8-mObj.uv.y);\n\n     // Lightsource falloff on floor\n     color *= vec3(smoothstep(0.,1.,1.-length(vec2(.2-mObj.uv.x/6.,.6+mObj.uv.y/1.5))));\n        return color;\n\t}    \n    \n    \n    if(i== 25)\n    {\n      float size = (-mObj.p.y+.1)/2.5;\n     vec3 color = vec3(0.,0.,0.);\n     color += vec3(mod(floor(mObj.p.x/size) + floor(mObj.p.y*20./size),2.)-.8-mObj.p.y);\n\n     // Lightsource falloff on floor\n     color *= vec3(smoothstep(0.,1.,1.-length(vec2(.2-mObj.p.x/6.,.6+mObj.p.y/1.5))));\n        return color;\n\t} \n    \n    if(i== 26)\n    {\n        // checkerboard hack\n\t\t\tvec2 cb = floor(mObj.p.xz);\n\t\t\tfloat cb2 = mod(cb.x*1.2 + cb.y, 2.);\n        \treturn vec3(1.4 + 0.1*cb2, 0.3 + 0.85*cb2, 0.35 - 0.3*cb2)*0.8;\n            \n    }   \n    \n    \n    \n    if(i== 27)\n    {\n      vec3 outColor = vec3(0.0);\n      float sinus1 = sin(mObj.uv.x*5.1 +iTime*0.5) * 0.1 - 0.2;\n      float land1 = step(sinus1, mObj.uv.y);\n      vec3 landColor1 = vec3(0.2, 0.4, 0.3);\n      outColor = mix(outColor, landColor1, 1.0 - land1);\n        return outColor;\n    }\n    \n    \n    if (i== 28)\n     {   \n    \tvec3 position=mObj.p;\n        vec3 normal=mObj.normal;\n    \t//position *= scale;\n         position *= 0.25;\n    \t\n    \t//vec3 color = vec3(1.0);\n        vec3 color = vec3(0.98,0.86,0.4);\n    \n    \tcolor = color * 0.75 + 0.25;\n    \tcolor *= normal * .25 + .75;\n    \tfloat checker = sin(position.x * pi * 4.0) * sin(position.y * pi * 4.0) * sin(position.z * pi * 4.0);\n    \tcolor *= step(0.0,checker) * 0.25 + 0.75;\n         return color;\n    }\n    \n    \n    \n}\n\n///--------------------------------------------\n\n// phong shading\nvec3 p_shadingv2( vec3 v, vec3 n, vec3 eye, vec3 plight_pos1,  vec3 plight_color1 )\n{\n\t// ...add lights here...\n\t\n\tfloat shininess = 16.0;\n\t\n\tvec3 final = vec3( 0.0 );\n\t\n\tvec3 ev = normalize( v - eye );\n\tvec3 ref_ev = reflect( ev, n );\n\t\n\t// light\n\t{\n\t\n\t\tvec3 vl = normalize( plight_pos1 - v );\n\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n\t\t\n\t\tfinal += plight_color1 * ( diffuse + specular ); \n\t}\n\t\n\t\n\n    return (final);\n}\n\n\n\n\nvec3 camera(vec3 ro, vec2 uv, vec3 ta) {\n\tvec3 fwd = normalize(ta - ro);\n\tvec3 left = cross(vec3(0, 1, 0), fwd);\n\tvec3 up = cross(fwd, left);\n\treturn normalize(fwd + uv.x*left + up*uv.y);\n}\n\n\n//-------------------------------------------\nvec3 Shade(vec3 position, vec3 normal, vec3 direction, vec3 camera)\n{\n    //position *= scale;\n    position *= 0.125;\n    vec3 color = vec3(1.0);\n    \n    color = color * 0.75 + 0.25;\n    \n    color *= normal * .25 + .75;\n    \n    float ambient = 0.1;\n    float diffuse = 0.5 * -dot(normal,direction);\n    float specular = 1.0 * max(0.0, -dot(direction, reflect(direction,normal)));\n    \n    color *= vec3(ambient + diffuse + pow(specular,5.0));\n\n    color *= smoothstep(12.0,6.0,length(position));\n    \n    return color;\n}\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n    \n\n\tlight_pos1   = vec3( -20.0, -20.0, -iTime*2.0);\n \tlight_color1 = vec3( 0.3, 0.2, 1.0 );\n\n \tlight_pos2   = vec3( 20.0,20.0, 20.0 +iTime*2.0 );\n \tlight_color2 = vec3( 1.0, 0.7, 0.7);\n    \n\n    \n    \n    vec3 ro = vec3(0.0,6.0,iTime*2.0);\n    ro.xz += pathv2(ro.z);\n \t\n    \n\t//ro =get_mouse(ro);\n    vec3 rd = normalize( vec3(uv,1.0));\n    \n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    mObj.uv=uv;\n    mObj.rd=rd;\n    mObj.ro=ro;\n\n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n  \n    vec3 p = (ro + rd * d ); \n    glpRoRd=p;\n    mObj.p=p;\n    \n    float dif=1.5;\n    \n    vec3 colp1 = GetLightPar(p,light_pos1)*light_color1;\n    vec3 colp2 = GetLightPar(p,light_pos2)*light_color2;\n    \n    \n    \n    mObj.dist =d;\n    vec3 colobj;\n    \n    vec3 nor= GetNormal( p);\n    mObj.normal=nor;\n    colobj=getSphereColor(int( Obj.tipo));\n    \n    \n    \n    \n    \n    vec3 col2=vec3(0.0);\n    col2+= p_shadingv2( p, nor, ro, light_pos1, light_color1 );\n    col2+= p_shadingv2( p, nor, ro, light_pos2, light_color2 );\n    col2=(col2)/2.0;\n    col2=(col2+colp1+colp2)/2.0;\n    col2= colobj*col2;\n    col= col2*dif;\n    \n    int f = int(mod(iTime * 60.0, 30.0));\n  \n    \n    if  ( float(f)<iTime )\n    {\n    \tvec3 sh= Shade( p, nor, rd, ro);\n        if (iTime<40.0)\n    \t\tcol =col*sh*8.0;\n \t}   \n    \n    \n    \n    col = pow(col, vec3(1.0/2.2));  \n    \n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ssBWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[981, 998, 1031, 1031, 1096], [1118, 1118, 1153, 1153, 1177], [1180, 1195, 1226, 1226, 1376], [1379, 1389, 1416, 1416, 1505], [1507, 1527, 1563, 1563, 1650], [1651, 1667, 1699, 1727, 1788], [1790, 1790, 1826, 1826, 1929], [1931, 1931, 1968, 1968, 2015], [2018, 2018, 2063, 2063, 2154], [2206, 2206, 2252, 2252, 2284], [2286, 2286, 2329, 2329, 2361], [2363, 2363, 2411, 2411, 2444], [2447, 2447, 2476, 2476, 2602], [2604, 2604, 2640, 2640, 2757], [2759, 2759, 2795, 2795, 2913], [2916, 2916, 2952, 2952, 3075], [3128, 3128, 3161, 3161, 3186], [3187, 3187, 3217, 3217, 3246], [3249, 3249, 3271, 3271, 3400], [3401, 3401, 3424, 3424, 3504], [3505, 3505, 3546, 3546, 3617], [3619, 3619, 3650, 3650, 3735], [3737, 3737, 3770, 3770, 3865], [3867, 3928, 3950, 3950, 4258], [4260, 4305, 4322, 4322, 4395], [4398, 4398, 4450, 4450, 4605], [4732, 4732, 4758, 4758, 4815], [4817, 4817, 4837, 4837, 4895], [4898, 4898, 4919, 4919, 5169], [5171, 5171, 5193, 5193, 5260], [5262, 5348, 5394, 5394, 5490], [5523, 5523, 5547, 5547, 5588], [5591, 5712, 5732, 5732, 5802], [5832, 5832, 5855, 5855, 5955], [5959, 5959, 5985, 5985, 7128], [7195, 7195, 7229, 7229, 7622], [7680, 7680, 7704, 7704, 7936], [7940, 7940, 7978, 7978, 8335], [8338, 8338, 8363, 8363, 8391], [8495, 8539, 8556, 8556, 8627], [8652, 8744, 8770, 8770, 9033], [9092, 9092, 9120, 9120, 14123], [14174, 14191, 14276, 14302, 14708], [14713, 14713, 14753, 14753, 14902], [14905, 14951, 15020, 15045, 15474], [15476, 15525, 15582, 15582, 17042]], "test": "error"}
{"id": "3sScDd", "name": "Grid and particles", "author": "Vermifuge", "description": "Beginner stuff", "tags": ["gridparticles"], "likes": 2, "viewed": 100, "published": "Public", "date": "1587492812", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 one = vec2(1., 0.);\n\nuniform int pointerCount;\nuniform vec3 pointers[10];\nuniform vec3 orientation;\n\nfloat hash(vec2 x) {\n\treturn fract(cos(\n\t\tdot(x, vec2(672.529,198.3862))\n\t\t)*9857.733);\n}\n\nfloat noise(vec2 x) {\n\tvec2 ix =floor(x);\n\tvec2 fx = fract(x);\n\tfx=fx*fx*(3.-2.*fx);\n\n\tfloat bl = hash(ix);\n\tfloat br = hash(ix+one.xy);\n\tfloat tl = hash(ix+one.yx);\n\tfloat tr = hash(ix+one.xx);\n\n\treturn mix(\n\t\tmix(bl, br, fx.x),\n\t\tmix(tl, tr, fx.x),\n\t\tfx.y);\n}\n\nfloat fbm(vec2 p) {\n\treturn (\n\t\t.5* noise(p)\n\t\t+ .25* noise(p*2.1)\n\t\t+ .175* noise(p*3.9)\n\t\t+ .0875* noise(p*8.2)\n\t);\n}\n\nvec2 pat(vec2 uv) {\n\treturn vec2(\n\t\tnoise(floor(uv) + iTime),\n\t\tnoise(floor(uv) + iTime + 3.53));\n}\n\nfloat dist(vec2 d, vec2 x) {\n\tfloat c = dot(d, x) / dot(d, d);\n\tif (sign(c) < 0.) {\n\t\treturn 1000.;\n\t} else {\n\t\treturn length(x - c*d);\n\t}\n}\n\nfloat particles(vec2 uv) {\n\tvec2 p = pat(uv);\n\tvec2 pr = pat(uv+one)+one;\n\tvec2 pl = pat(uv-one)-one;\n\tvec2 pu = pat(uv+one.yx)+one.yx;\n\tvec2 pb = pat(uv-one.yx)-one.yx;\n\tvec2 pbr = pat(uv+one.xx)+one.xx;\n\tvec2 pul = pat(uv-one.xx)-one.xx;\n\n\tvec2 dhere = fract(uv)-p;\n\tvec2 ppl = pl-p;\n\tvec2 ppr = pr-p;\n\tvec2 ppu = pu-p;\n\tvec2 ppb = pb-p;\n\n\tfloat upl = dist(normalize(ppl), dhere);\n\tfloat upr = dist(normalize(ppr), dhere);\n\tfloat upu = dist(normalize(ppu), dhere);\n\tfloat upb = dist(normalize(ppb), dhere);\n\n\treturn 1.-smoothstep(.02, .2, length(dhere))\n\t\t+ .5/pow(length(ppl), 4.)*smoothstep(.03, .01, upl)\n\t\t+ .5/pow(length(ppr), 4.)*smoothstep(.03, .01, upr)\n\t\t+ .5/pow(length(ppu), 4.)*smoothstep(.03, .01, upu)\n\t\t+ .5/pow(length(ppb), 4.)*smoothstep(.03, .01, upb)\n\t\t+ .5/(length(ppb)+1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tfloat mx = max(iResolution.x, iResolution.y);\n\tvec2 uv = fragCoord.xy/mx;\n\tvec3 color = vec3(.1,.4,.5);\n\tcolor = mix(color, vec3(.9), particles(uv*10.));\n\tfragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sScDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 126, 126, 195], [197, 197, 218, 218, 458], [460, 460, 479, 479, 579], [581, 581, 600, 600, 680], [682, 682, 710, 710, 822], [824, 824, 850, 850, 1622], [1624, 1624, 1679, 1679, 1867]], "test": "error"}
{"id": "3sScRh", "name": "Heritable xenobiotic (edit)", "author": "jarble", "description": "I edited the \"prim\" function in the [url=https://www.shadertoy.com/view/tdlyD2]\"Heritable xenobiotic\"[/url] shader. The geometry seems much more complex now.", "tags": ["raymarching"], "likes": 0, "viewed": 198, "published": "Public API", "date": "1586025301", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//-------------------------------------------------------------------\n// Trying out ShaderToy and trying to get to grips with ray marching.\n// Inspired by the amazing creations of Evvvvil, Nusan and Shane\n//-------------------------------------------------------------------\n\n#define MD 30.\t\t// max distance\n#define SD 0.0001    // surface distance\n#define MS 250      // max number of steps to march\n#define EPS 0.0001   // distance used for sampling the gradient\n\nfloat time;\n\n// always handy to have PI available\nconst float PI = acos(-1.);\nconst float TWOPI = 2.*PI;\n\n// fog color.\nconst vec3 fog = vec3(.05,.25, .05);\n\n// always need some glow!\nfloat glw = 0.;\n\n// sphere SDF\nfloat sph(vec3 p, float r){return length(p)-r;}\n\n// min and max which preserve material\nvec2 mmin(vec2 a, vec2 b) {return a.x < b.x ? a:b;}\nvec2 mmax(vec2 a, vec2 b) {return a.x > b.x ? a:b;}\n\n\n// 2d rotation\nvoid rot(inout vec2 p, float a) {\n    float c=cos(a), s=sin(a);\n    p *= mat2(c,-s,s,c);\n}\n\n// I was going to do something complicated here,\n// but ended up doing a sphere!\nvec2 prim(vec3 p) {\n    return vec2(sph(p, .5)*(1.0+sin(p.x)), 5)*10.0;\n}\n\n// the SDF for the scene\nvec2 map(vec3 p) {\n    \n    // wiggle x\n    p.x += sin(p.z + time*.2)*.5;\n    // spiral\n    rot(p.xy, sin(p.z / 3.));\n    // scroll along z\n    p.z -= time/3.;\n    \n    // repeat everything\n    vec3 mp;\n    mp.x = mod(p.x, 2.3)-1.15;\n    mp.y = mod(p.y, 2.3)-1.15;\n    mp.z = mod(p.z,.6)-.3;\n    \n    // fractal (ish)\n    vec4 ap = vec4(mp,1.);\n    // big purple sphere\n    vec2 a=prim(mp);\n    a.x *= .6;\n    // smaller black spheres\n    int n=4;\n    for(int i=1; i<=n; ++i) {\n    \tap *= 2.5; // scale\n        ap.xyz = abs(ap.xyz)-vec3(.8); // symmetry\n        rot(ap.xy, ap.z*.1 + time*.5); // movement\n        vec2 b = prim(ap.xyz); // sphere\n        b.x /= ap.w; // correct for scaling\n        b.x *= .6;   // patch up the SDF\n        b.y= 1.;     // paint it black\n        a=mmin(a, b);\n        \n    }\n    \n    // Sparkles. Lots of them.\n    rot(p.xy, time*.3);\n    vec2 b = vec2(length(cos(p*1.+vec3(1.5+p.z*.05*sin(time),1.7+sin(time)*.2,time*2.)))-.001 ,6.);\n    glw += .1/(.1*b.x*b.x*10000.);\n    b.x *= .6;\n    \n    // final distance\n    vec2 d=mmin(a,b);\n    return d;\n}\n\n// determine the normal at point p by sampling the gradient of the SDF\nvec3 normal(vec3 p) {\n \tvec2 off = vec2(EPS, 0.);\n    return normalize(map(p).x - vec3(map(p-off.xyy).x,map(p-off.yxy).x,map(p-off.yyx).x));\n}\n\n//-------------------------------------------------------------\n// lighting and colour,\n// heavily based on Evvvvil's Micro Lighting Engine Broski (TM)\n//-------------------------------------------------------------\n\n// shortcuts for calculating fake ambient occlusion and subsurface scattering\n#define aoc(d) clamp(map(p + n * d).x/d, 0., 1.)\n#define sss(d) smoothstep(0.,1.,map(p+ld*d).x/d)\n\nvec3 surface(vec3 ro, vec3 rd, vec2 hit) {\n\tfloat d=hit.x;         // distance from ray origin\n    float m = hit.y;       // materialID\n    \n    // albedo, or base color, based on material ID\t\n    vec3 al = m < 5. ? vec3(0) : \n    \t\tm > 5. ? vec3(1) :\n    \t\tvec3(.1,.1,.4);\n    \n    vec3 p = ro + rd * d;  // the point in space\n    vec3 n = normal(p);    // normal of the SDF at point p\n    \n    vec3 ld = normalize(vec3(-1));     // light direction\n    float diff = max(0., dot(n, -ld)); // diffuse illumination\n    \n    vec3 lr = reflect(ld, n);          // reflected light ray\n    float spec = pow(max(0., dot(lr,-rd)),32.); // specular component\n \n    float frz = pow(max(0.1, 1. - dot(n,-rd)),4.)*.5; // freznel)\n\t\n    float ao = aoc(.1); // fake AO\n    float ss = sss(1.); // fake subsurface scattering\n    \n    vec3 col =  al * ao * (diff + ss) + spec; // combine it all together\n    col = mix(col, fog, frz);         // fog the edges\n    \n    return col; // the final color\n}\n\n// ray marching loop\nvec3 march(vec3 ro, vec3 rd) {\n\tfloat dd=0.1;\t\t// start with a slight z offset\n    vec3 col=vec3(0);   // no color initially\n    vec3 p=ro + rd * dd;// current point\n    \n    for(int i=0; i<MS; ++i) {  // start marching\n     \tvec2 d = map(p);  // distance to SDF\n        \n        if(d.x < SD) { // close to a surface\n            // get the color of the surface\n            col += d.y > 0. ? surface(ro, rd, vec2(dd, d.y)) : vec3(0.);\n            break; // we're done\n        }\n        \n        if(dd > MD) { // we've reached the max draw distance,\n            dd = MD;\n            break;    // and we're done\n        }\n        \n        dd += d.x;     // track the total distance\n        p += rd * d.x; // and update the current position\n    }\n    \n    // blend in some distance-based fog and return\n    return mix(fog * pow(max(0., dot(rd, vec3(0,0,-1))),20.), col, exp(-0.003*dd*dd*dd));\n}\n\n\n// given the ray origin, lookat point and uv's, calculate the ray direction\nvec3 raydir(vec3 ro, vec3 la, vec2 uv) {\n    // x,y and z axes\n    vec3 cz = normalize(la-ro);\n    vec3 cx = normalize(cross(cz,vec3(0,1,0)));\n    vec3 cy = normalize(cross(cx,cz));\n    // project and normalize\n    return normalize(cx*uv.x + cy*uv.y + cz);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    // make sure that the pixels are square\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    // get rid of some artifacts\n    time = mod(iTime, 62.39);\n    \n    // setup the ray\n    vec3 ro = vec3(0,0,1);\n    vec3 rd = raydir(ro, vec3(0)-ro, uv);\n    \n    // march\n    vec3 col = march(ro, rd);\n\n    col += glw;\n    // exposure\n    col = vec3(1) - exp(-col * 1.1);\n    // gamma\n    col = pow(col, vec3(1./2.2));\n    // final color\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sScRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[667, 681, 708, 708, 728], [730, 769, 796, 796, 820], [821, 821, 848, 848, 872], [875, 890, 923, 923, 980], [982, 1063, 1082, 1082, 1136], [1138, 1163, 1181, 1202, 2244], [2246, 2317, 2338, 2338, 2459], [2855, 2855, 2897, 2897, 3838], [3840, 3861, 3891, 3891, 4751], [4754, 4830, 4870, 4892, 5088], [5091, 5091, 5148, 5198, 5723]], "test": "error"}
{"id": "3sscWf", "name": "Helical Ramps with Spiders", "author": "dr2", "description": " Spiders on a double helix ramp - from Leonardo's Chateau de Chambord staircase;\n normal and panoramic views - mouseable.\n", "tags": ["helix", "spider", "symmetry", "walk"], "likes": 15, "viewed": 270, "published": "Public API", "date": "1585749667", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Helical Ramps with Spiders\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define N_SPD  5  // Number of spiders per turn (1-20, roughly)\n\n#define AA  0   // optional antialiasing\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrEETapCylDf (vec3 p, vec3 v1, vec3 v2, float r, float rf);\nfloat PrEllipsDf (vec3 p, vec3 r);\nfloat Maxv3 (vec3 p);\nmat3 StdVuMat (float el, float az);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nfloat Fbm2 (vec2 p);\n\nvec3 footPos[8], kneePos[8], hipPos[8], ltDir, qHit;\nfloat tCur, dstFar, legLenU, legLenD, bdyHt, spdVel, nSpd, vGap, radExt, radRmp;\nint idObj;\nconst int idRmp = 1, idCol = 2, idWalI = 3, idWalM = 4, idWalO = 5, idBm = 6,\n   idBdy = 11, idHead = 12, idEye = 13, idAnt = 14, idLegU = 15, idLegD = 16;\nconst float pi = 3.14159;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat SpdDf (vec3 p, float dMin, int tpId)\n{\n  vec3 q;\n  float d, s, len, szFac;\n  szFac = 0.22;\n  p /= szFac;\n  dMin /= szFac; \n  p.y -= bdyHt + 0.8;\n  q = p - vec3 (0., -0.15, 0.2);\n  d = PrEllipsDf (q, vec3 (0.7, 0.5, 1.3));\n  DMINQ (idBdy + tpId);\n  q = p - vec3 (0., 0.1, 1.1);\n  d = PrEllipsDf (q, vec3 (0.2, 0.4, 0.5));\n  DMINQ (idHead + tpId);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.15, 0.25, 1.5);\n  d = PrSphDf (q, 0.13);\n  DMINQ (idEye + tpId);\n  q -= vec3 (0., 0.15, -0.3);\n  d = PrEETapCylDf (q, 1.3 * vec3 (0.3, 1.1, 0.4), vec3 (0.), 0.07, 0.7);\n  DMINQ (idAnt + tpId);\n  p.y += bdyHt;\n  for (int j = VAR_ZERO; j < 8; j ++) {\n    q = p - hipPos[j];\n    d = 0.6 * PrEETapCylDf (q, kneePos[j], hipPos[j], 0.25, 0.3);\n    DMINQ (idLegU + tpId);\n    q = p - kneePos[j];\n    d = 0.6 * PrEETapCylDf (q, footPos[j] - vec3 (0.3), kneePos[j] - vec3 (0.3), 0.2, 1.2);\n    DMINQ (idLegD + tpId);\n  }\n  return dMin * szFac;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, widRmp, aRot, r, a, ai, s;\n  dMin = dstFar;\n  widRmp = 1.2;\n  r = length (p.xz);\n  a = (r > 0.) ? atan (p.z, - p.x) / (2. * pi) + 0.5 : 0.;\n  q = p;\n  q.y = mod (q.y + (0.5 - 2. * a) * vGap, vGap) - 0.5 * vGap;\n  d = PrBox2Df (vec2 (r - radRmp, q.y), vec2 (widRmp, 0.1));\n  DMIN (idRmp);\n  d = max (PrBox2Df (vec2 (r - 0.5 * radRmp, q.y + 0.2), vec2 (0.1, 0.5)),\n     - PrBox2Df (vec2 (abs (mod (7. * a, 1.) - 0.5), q.y + 0.2), vec2 (0.3, 0.2)));\n  DMIN (idWalI);\n  d = PrBox2Df (vec2 (abs (r - radRmp) - widRmp, q.y - 0.2), vec2 (0.07, 0.3));\n  DMIN (idWalM);\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (7. * a + 0.5) / 7. - 0.5));\n  q.x += 0.5 * radRmp;\n  d = length (q.xz) - 0.2;\n  DMIN (idCol);\n  q.x += 0.25 * radRmp + 0.5 * widRmp;\n  s = -0.03 * q.x;\n  q.y = mod (q.y + 0.15 + (0.5 - 2. * a) * vGap, vGap) - 0.5 * vGap - s;\n  d = PrBoxDf (q, vec3 (0.25 * radRmp + 0.5 * widRmp, 0.15 - s, 0.1));\n  DMIN (idBm);\n  q = p;\n  d = max (abs (length (q.xz) - radExt - 0.2) - 0.2,\n     - PrBox2Df (mod (vec2 (21. * (0.5 + a), 0.125 * q.y) + 0.5, 1.) - 0.5, vec2 (0.2, 0.3)));\n  DMIN (idWalO);\n  aRot = atan (vGap / (2. * pi * radRmp));\n  for (float k = float (VAR_ZERO); k <= 1.; k ++) {\n    s = sign (1. - 2. * k);\n    q = p;\n    a = s * spdVel * tCur / (2. * pi * radRmp);\n    q.xz = Rot2D (q.xz, a);\n    ai = 2. * pi * floor (nSpd * ((r > 0.) ? atan (q.z, - q.x) / (2. * pi) : 0.) + 0.5) / nSpd;\n    q.xz = Rot2D (q.xz, ai);\n    q.y = mod (q.y + 0.2 + k * vGap + (1. - (ai + a) / pi) * vGap, 2. * vGap) - vGap;\n    q.yz = Rot2D (q.yz, aRot);\n    q.x += radRmp;\n    q.xz *= s;\n    if (PrCylDf (q.xzy, 1., 0.7) < dMin) dMin = SpdDf (q, dMin, int (10. * k));\n  }\n  return 0.8 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.002, -0.002);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd, float dstLim)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.03 * d, h));\n    d += clamp (2. * h, 0.05, 0.3);\n    if (sh < 0.05 || d > dstLim) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec3 SpdCol ()\n{\n  vec3 col, c[2];\n  vec2 cc;\n  cc = vec2 (1., 0.2);\n  if (idObj >= idBdy + 10) {\n    idObj -= 10;\n    c[0] = cc.xxy;\n    c[1] = cc.xyy;\n  } else {\n    c[0] = cc.yyx;\n    c[1] = cc.yxy;\n  }\n  if (idObj == idBdy) {\n    col = mix (c[0], c[1], SmoothBump (0.2, 0.7, 0.05, mod (4. * qHit.z, 1.)));\n  } else if (idObj == idHead) {\n    col = c[1];\n    if (qHit.z > 0.4) col *= 0.2 + 0.8 * smoothstep (0.02, 0.04, abs (qHit.x));\n  } else if (idObj == idEye) {\n    col = cc.xxx;\n  } else if (idObj == idLegU || idObj == idLegD) {\n    col = mix (c[1], c[0],  SmoothBump (0.4, 1., 0.2, fract (3.5 * length (qHit))));\n  } else if (idObj == idAnt) {\n    col = cc.xyx;\n  }\n  return col;\n}\n\nvec3 StarPat (vec3 rd, float scl)\n{\n  vec3 tm, qn, u;\n  vec2 q;\n  float f;\n  tm = -1. / max (abs (rd), 0.0001);\n  qn = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  u = Maxv3 (tm) * rd;\n  q = atan (vec2 (dot (u.zxy, qn), dot (u.yzx, qn)), vec2 (1.)) / pi;\n  f = 0.57 * (Fbm2 (11. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 131.13 * scl * q) +\n      Fbm2 (13. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 171.13 * scl * q.yx));\n  return 16. * vec3 (1., 1., 0.8) * pow (f, 16.);\n}\n\nvec3 ShStagGrid (vec2 p)\n{\n  vec2 q, sq, ss;\n  q = p;\n  if (2. * floor (0.5 * floor (q.y)) != floor (q.y)) q.x += 0.5;\n  sq = smoothstep (0.05, 0.1, abs (fract (q + 0.5) - 0.5));\n  q = fract (q) - 0.5;\n  ss = 0.25 * smoothstep (0.3, 0.5, abs (q.xy)) * sign (q.xy);\n  if (abs (q.x) < abs (q.y)) ss.x = 0.;\n  else ss.y = 0.;\n  return vec3 (ss.x, 0.8 + 0.2 * sq.x * sq.y, ss.y);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, bgCol, vn, rg;\n  float dstObj, vDotL, sh, atten, a, s, sa, saa;\n  bgCol = StarPat (rd, 12.);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    a = atan (ro.z, - ro.x) / (2. * pi);\n    vn = ObjNf (ro);\n    if (idObj == idRmp) {\n      col4 = vec4 (0.4, 0.4, 0.45, 0.1) * (0.7 + 0.3 * Fbm2 (64. * ro.xz));\n    } else if (idObj == idWalI) {\n      col4 = vec4 (0.7, 0.7, 0.2, 0.2);\n    } else if (idObj == idCol) {\n      col4 = vec4 (0.7, 0.7, 0.2, 0.2) * (0.7 + 0.3 * smoothstep (0.05, 0.1, mod (4. * ro.y, 1.)));\n    } else if (idObj == idWalM) {\n      col4 = (vn.y < 0.9) ? vec4 (0.8, 0.75, 0.75, 0.1) : vec4 (0.7, 0.7, 0.2, 0.2);\n      col4.rgb *= (0.7 + 0.3 * smoothstep (0.05, 0.1, 0.5 * (1. + sin (256. * pi * a))));\n    } else if (idObj == idBm) {\n      col4 = vec4 (0.8, 0.75, 0.75, 0.);\n    } else if (idObj == idWalO) {\n      col4 = vec4 (0.7, 0.7, 0.6, 0.) * (0.7 + 0.3 * step (length (ro.xz), radExt + 0.01)); \n      s = mod (21. * (0.5 + a) + 0.5, 1.) - 0.5;\n      if (abs (s) < 0.08) {\n        sa = mod (1.5 * ro.y + 0.5, 1.) - 0.5;\n        saa = smoothstep (0., 0.1, abs (sa));\n        col4 *= 0.8 + 0.2 * saa;\n        vn.y = -0.3 * (1. - saa) * sign (sa);\n        vn.xz *= sqrt (1. - vn.y * vn.y);\n        vn.xz = Rot2D (vn.xz, asin (pi * clamp (4. * s, -0.5, 0.5)));\n      } else {\n        rg = ShStagGrid (3. * vec2 (42. * a, ro.y));\n        col4 *= rg.y;\n        rg.xz *= sign ((abs (vn.x) > 0.5) ? vn.x : vn.z);\n        if (abs (vn.x) > 0.5) {\n          if (rg.x == 0.) vn.xy = Rot2D (vn.xy, rg.z);\n          else vn.xz = Rot2D (vn.xz, rg.x);\n        } else {\n          if (rg.x == 0.) vn.zy = Rot2D (vn.zy, rg.z);\n          else vn.zx = Rot2D (vn.zx, rg.x);\n        }\n      }\n    } else {\n      col4 = vec4 (SpdCol (), 0.3);\n    } \n    vDotL = max (dot (vn, ltDir), 0.);\n    if (idObj >= idBdy) vDotL *= vDotL;\n    atten = min (1., 1.2 / (1. + 0.2 * dstObj * dstObj / (radExt * radExt)));\n    sh = 1.;\n    if (idObj != idWalO) sh = ObjSShadow (ro, ltDir, dstObj);\n    if (col4.a >= 0.) col = atten * (col4.rgb * (0.2 + 0.8 * sh * vDotL) +\n       step (0.95, sh) * col4.a * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.));\n    else col = atten * col4.rgb;\n    col = mix (col, bgCol, smoothstep (0.8, 1., abs (ro.y) / (2. * radExt)));\n  } else {\n    col = bgCol;\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid SpdSetup (float gDisp)\n{\n  vec3 v;\n  float a, az, fz, d, ll;\n  nSpd = float (N_SPD);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    a = 0.2 * (1. + float (j)) * pi;\n    hipPos[j] = 0.5 * vec3 (- sin (a), 0., 1.5 * cos (a));\n    hipPos[j + 4] = hipPos[j];\n    hipPos[j + 4].x *= -1.;\n  }\n  bdyHt = 1.5;\n  legLenU = 2.2;\n  legLenD = 3.;\n  ll = legLenD * legLenD - legLenU * legLenU;\n  for (int j = VAR_ZERO; j < 8; j ++) {\n    fz = fract ((gDisp + 0.93 + ((j < 4) ? -1. : 1.) + mod (7. - float (j), 4.)) / 3.);\n    az = smoothstep (0.7, 1., fz);\n    footPos[j] = 5. * hipPos[j];\n    footPos[j].x *= 1.7;\n    footPos[j].y += 0.7 * sin (pi * clamp (1.4 * az - 0.4, 0., 1.));\n    footPos[j].z += ((j < 3) ? 0.5 : 1.) - 3. * (fz - az);\n    hipPos[j] += vec3 (0., bdyHt - 0.3, 0.2);\n    v = footPos[j] - hipPos[j];\n    d = length (v);\n    a = asin ((hipPos[j].y - footPos[j].y) / d);\n    kneePos[j].y = footPos[j].y + legLenD *\n       sin (acos ((d * d + ll) / (2. * d *  legLenD)) + a);\n    kneePos[j].xz = hipPos[j].xz + legLenU * sin (acos ((d * d - ll) /\n       (2. * d *  legLenU)) + 0.5 * pi - a) * normalize (v.xz);\n  }\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, uvv, ut, mSize, mMid, msw;\n  float el, az, zmFac, asp, sr, regId;\n  int vuMode;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  mSize = (1./6.) * vec2 (asp, 1.);\n  mMid = vec2 (asp * (1. - mSize.y), - 1. + mSize.y);\n  ut = abs (uv - mMid) - mSize;\n  vuMode = 0;\n  if (max (ut.x, ut.y) < 0.) {\n    uv = (uv - mMid) / mSize.y;\n    vuMode = 1;\n  }\n  az = 0.05 * pi * (floor (0.2 * tCur) + smoothstep (0.9, 1., mod (0.2 * tCur, 1.)));\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    regId = 0.;\n    msw = (mPtr.xy * vec2 (asp, 1.) - 0.5 * mMid) / mSize;\n    if (max (abs (msw.x), abs (msw.y)) < 0.5) regId = 1.;\n    else msw = mPtr.xy;\n    if (vuMode == 0) {\n      az += 2. * pi * msw.x;\n      el += pi * msw.y;\n    }\n    if (regId == 1.) vuMode = 1 - vuMode;\n  }\n  if (length (uv * vec2 (1. / asp, 1.)) < 1.5 * SmoothBump (0.25, 0.75, 0.1,\n     mod (0.03 * tCur, 1.))) vuMode = 1 - vuMode;\n  if (vuMode == 0) el = clamp (el, -0.25 * pi, 0.25 * pi);\n  vuMat = StdVuMat (el, az);\n  spdVel = 2.5;\n  SpdSetup (spdVel * tCur);\n  radExt = 15.;\n  radRmp = 6.;\n  vGap = 3.;\n  if (vuMode == 0) {\n    ro = vuMat * vec3 (0., 0., - (radExt - 0.2));\n    zmFac = 2.2;\n  } else if (vuMode == 1) {\n    ro = vec3 (0.);\n    zmFac = 0.5;\n  }\n  dstFar = 4. * radExt;\n  ltDir = vuMat * normalize (vec3 (0.5, 0.5, -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) * pi)) / zmFac;\n    if (vuMode == 0) rd = normalize (vec3 (uvv, 1.));\n    else rd = normalize (vec3 (sin (uvv.x + vec2 (0., 0.5 * pi)), uvv.y).xzy);\n    rd = vuMat * rd;\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  if (vuMode == 1) col = pow (col, vec3 (0.9));\n  if (max (ut.x, ut.y) < 0. && min (abs (ut.x), abs (ut.y)) * canvas.y < 2.) col = vec3 (0.2, 0.5, 0.2);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrEETapCylDf (vec3 p, vec3 v1, vec3 v2, float r, float rf)\n{\n  vec3 v;\n  float s;\n  v = v1 - v2;\n  s = clamp (dot (p, v) / dot (v, v), 0., 1.);\n  return length (p - s * v) - r * (1. - rf * s * s);\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sscWf.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1140, 1140, 1184, 1184, 2071], [2073, 2073, 2095, 2095, 3810], [3812, 3812, 3845, 3845, 4028], [4030, 4030, 4051, 4051, 4306], [4308, 4308, 4359, 4359, 4626], [4628, 4628, 4644, 4644, 5319], [5321, 5321, 5356, 5356, 5810], [5812, 5812, 5838, 5838, 6189], [6191, 6191, 6226, 6226, 8599], [8601, 8601, 8630, 8630, 9724], [9726, 9726, 9782, 9782, 12000], [12002, 12002, 12034, 12034, 12134], [12136, 12136, 12169, 12169, 12258], [12260, 12260, 12293, 12293, 12320], [12322, 12322, 12364, 12364, 12415], [12417, 12417, 12483, 12483, 12621], [12623, 12623, 12658, 12658, 12720], [12722, 12722, 12744, 12744, 12782], [12784, 12784, 12820, 12820, 13026], [13028, 13028, 13085, 13085, 13168], [13170, 13170, 13200, 13200, 13313], [13347, 13347, 13371, 13371, 13483], [13485, 13485, 13510, 13510, 13696], [13698, 13698, 13719, 13719, 13874]], "test": "error"}
{"id": "3sSczR", "name": "Basic MandelBulb", "author": "boris159", "description": "I really have no ideas how does it work but it looks nice.", "tags": ["3d", "raymarching", "fractal", "mandelbulb"], "likes": 10, "viewed": 299, "published": "Public", "date": "1585925597", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define EPSILON 0.001\n#define PI 3.141592\n#define MAX_DIST 256.0\n#define MAX_STEPS 256\n#define it 10\n\nvec3 makeRay(vec2 origin)\n{\n    vec2 res;\n    res.x = origin.x - iResolution.x * 0.5;\n    res.y = origin.y - iResolution.y * 0.5;\n    \n    return normalize(vec3(res / iResolution.yy, 1));\n}\n\nmat2 rot(float ang)\n{\n    float s = sin(ang);\n    float c = cos(ang);\n    return mat2(c, -s, s, c);\n}\n\nvec3 rotVec(vec3 p, vec3 r)\n{\n    p.yz *= rot(r.x);\n    p.xz *= rot(r.y);\n    p.xy *= rot(r.z);\n    return p;\n}\n\nfloat mandelBulb(vec3 p, vec3 fp, float power, vec3 ang)\n{\n    p -= fp;\n    p = rotVec(p, ang);\n    \n\tvec3 z = p;\n\tfloat r, theta, phi;\n\tfloat dr = 1.0;\n\t\n\tfor(int i = 0; i < it; ++i)\n    {\n\t\tr = length(z);\n        \n\t\tif(r > 2.0)\n            continue;\n        \n\t\ttheta = atan(z.y / z.x);\n        phi = asin(z.z / r) + iTime;\n\t\t\n\t\tdr = pow(r, power - 1.0) * dr * power + 1.0;\n\t\tr = pow(r, power);\n        \n\t\ttheta = theta * power;\n\t\tphi = phi * power;\n\t\t\n\t\tz = r * vec3(cos(theta) * cos(phi),\n                     sin(theta) * cos(phi), \n                     sin(phi)) + p;\n\t}\n    \n\treturn 0.5 * log(r) * r / dr;\n}\n\nfloat getDist(vec3 origin)\n{\n    vec3 fp = vec3(0);\n    vec3 fr = vec3(0, PI + PI / 4.0, 0);\n    float power = 8.0;\n    \n    return mandelBulb(origin, fp, power, fr);\n}\n\nvec2 rayMarch(vec3 origin, vec3 direct)\n{\n    float res = 0.0;\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 tmp = origin + direct * res;\n        float d = getDist(tmp);\n        res += d;\n        \n        if (res >= MAX_DIST || d < EPSILON)\n        \treturn vec2(res, float(i));\n    }\n\n    return vec2(res, float(MAX_STEPS));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 origin = vec3(0, 0, -3);\n    vec3 dir = makeRay(fragCoord);\n    \n    vec2 res = rayMarch(origin, dir);\n    float d = res.x;\n    vec3 col;\n    \n    vec3 startCol = vec3(cos(iTime) * 0.25 + 0.75, 0, 0);\n    vec3 finCol = vec3(0, 0, sin(iTime) * 0.25 + 0.75);\n    float delta = 0.5;\n    \n    if (d < MAX_DIST)\n    {\n    \tvec3 p = origin + d * dir;\n        delta = length(p) / 2.0;\n    }\n    \n    col = mix(startCol, finCol, delta) * res.y / float(MAX_STEPS) * 5.0;\n    fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sSczR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 102, 129, 129, 291], [293, 293, 314, 314, 394], [396, 396, 425, 425, 507], [509, 509, 567, 567, 1122], [1124, 1124, 1152, 1152, 1292], [1294, 1294, 1335, 1335, 1638], [1640, 1640, 1697, 1697, 2200]], "test": "valid"}
{"id": "3ssfR4", "name": "[2TC] Julia smooth", "author": "balkhan", "description": "https://twitter.com/balkhan8/status/1253512984212713474\nI forgot that log2(2.)==1. in the original :-]. ", "tags": ["2d", "julia", "2tc", "codegolf"], "likes": 3, "viewed": 59, "published": "Public", "date": "1587794797", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nsmooth coloring  : https://www.iquilezles.org/www/articles/mset_smooth/mset_smooth.htm\n*/\n\n// 225c (coyote)\nvoid mainImage(out vec4 o, vec2 f)\n{\n    for(\n        vec2 u = 4.*f/iResolution.xy - 2., i = u-u;\n        i.x < 1e2 && dot(u,u) < 4e3;\n        o.xy = i++ - log2(log2(dot(u,u)))\n    )\n        u = mat2(u,-u.y,u)*u + vec2(cos(iTime/4.),sin(iTime/8.));\n    o = sin( o.x + vec4(0,1,2,0) )/4. + vec4(.5,.3,.2,0);\n}\n\n// 237c (original)\n/*\n#define mainImage( o, f )\\\n\tvec2 R=iResolution.xy, u = 4.*(f-R*.5)/R;\\\n    for(float i = .0; i < 99. && dot(u, u) < 4000.; i++)\\\n        u.xy = mat2(u, -u.y, u.x)*u + vec2(cos(iTime/4.), sin(iTime/8.)),\\\n        o.x = i - log2(log2(dot(u, u)));\\\n    o = sin(o.x + vec4(.0, 1., 2., .0) )/4. + vec4(.5, .3, .2, .0)\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ssfR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[94, 111, 147, 147, 419]], "test": "error"}
{"id": "3sSyD3", "name": "Water Condensation on Glass", "author": "D4v1D", "description": "one of my first GLSL studies, based on Warping - procedural 4 (inspired by https://www.shadertoy.com/view/MdSXzz)", "tags": ["procedural", "water", "condensation"], "likes": 2, "viewed": 140, "published": "Public", "date": "1587394106", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// based and inspired by Warping - procedural 4 (https://www.shadertoy.com/view/MdSXzz - by inigo quilez - iq/2014)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// it's WORK IN PROGRESS!!\n\nconst mat2 m = mat2(0.81,0.60,-.9,.8);\nfloat hash( vec2 p ) { float h = dot(p,vec2(127.1,311.7)); return -1.0 + 2.0*fract(sin(h)*43758.5453123); }\n\nfloat noise( in vec2 p) \n{   vec2 i = floor(p);\n    vec2 f = fract(p);\n\tvec2 u = f*f*(3.0-2.0*f);\n    return mix(mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y); }\n\nfloat fbm( vec2 p )\n{   float f = 0.0;\n    f += 0.30 * noise( p ); p = m*p*2.00;\n \tf *= 0.700  + noise( p ); p = m*p*1.00;\n    f *= 0.1250 + noise( p ); p = m*p*2.00;\n    f += 0.1725 * noise( p );\n    return f/0.9375; }\n\nvec2 fbm2( in vec2 p )\n{return vec2( fbm(p.yx), fbm(p.xy) );}\n\nvec3 map( vec2 p )\n{   p *= 0.7;\n    float f = dot( fbm2( 1.0*(0.24*iTime - p + fbm2(-0.05*iTime+2.0*(p / fbm2(5.0*p)))) ), vec2(1.0,-1.0) ); // condensa\n    float bl = smoothstep(-0.8, 0.8, f );\n    float ti = smoothstep(0.0,1.0, fbm(p) );\n    return mix( mix( vec3(0.1,0.0,.2),\n                     vec3(1.0,1.0,0.0), ti ), \n                     vec3(1.0,1.0,1.0), bl );   }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   vec2 p = (-iResolution.xy+2.0*fragCoord.xy)/iResolution.y;\n    float e = 0.0045;\n    vec3 colc = map(e-p);\n    float gc = dot(colc,vec3(0.333));\n    vec3 cola = map(p + vec2(e,0.0)); \n    float ga = dot(cola,vec3(0.333));\n    vec3 colb = map(p + vec2(0.0,e));\n    float gb = dot(colb,vec3(0.333));\n    vec3 col = colc;\n    col += vec3(0.1,0.1,.11)*1.0*abs(1.0*gc-ga-gb); // defines color for highlight in outlines/border\n    vec2 q = -fragCoord.xy/iResolution.xy; // this traces screen coordinates;\n    col *= pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.1);  // vignetting\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sSyD3.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[270, 270, 292, 292, 377], [379, 379, 405, 405, 689], [691, 691, 712, 712, 910], [912, 912, 936, 936, 973], [975, 975, 995, 995, 1351], [1353, 1353, 1410, 1410, 2016]], "test": "valid"}
{"id": "3sSyR1", "name": "bad shapes 0", "author": "KilledByAPixel", "description": "bad shapes 1", "tags": ["badshapes1"], "likes": 0, "viewed": 201, "published": "Public API", "date": "1586034408", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ZzArt - Generation: 112-E (1574121639091)\n\nfloat audio_freq( in float f) { return texture( iChannel0, vec2(f, 0.25) ).x; }\nfloat audio_ampl( in float t) { return texture( iChannel0, vec2(t, 0.75) ).x; }\n\nconst float PI=3.141592653589793;\nvec3 SmoothHSV(vec3 c) { vec3 rgb = clamp(abs(mod(c.x*6.+vec3(0,4,2),6.)-3.)-1.,0.,1.); return c.z * mix( vec3(1), rgb*rgb*(3.-2.*rgb), c.y); }\nvec4 lengthA(vec4 a)      { return vec4(length(a)); }\nvec4 asinA(vec4 a)        { return asin(clamp(a,-1.,1.)); }\nvec4 acosA(vec4 a)        { return acos(clamp(a,-1.,1.)); }\nvec4 logA(vec4 a)         { return log(abs(a)); }\nvec4 log2A(vec4 a)        { return log2(abs(a)); }\nvec4 sqrtA(vec4 a)        { return sqrt(abs(a)); }\nvec4 inversesqrtA(vec4 a) { return inversesqrt(abs(a)); }\nvec4 pow2(vec4 a)         { return a*a; }\nvec4 pow3(vec4 a)         { return a*a*a; }\n\nvoid mainImage(out vec4 a, in vec2 p)\n{\n    a=p.xyxy/iResolution.xyxy;\n    a.xywz *= vec2(2.279, 3.527).xyxy;\n    a.xywz += vec2(-4.296, -7.673).xyxy;\n    vec4 b = a;\n\n    // Generated Code - Line Count: 14\n    b.xywz *= (b).zxwz;\n    a.wzyx = cos(b+iTime).xyww;\n    a.yzxw -= exp2(a).yxwy;\n    b.xwzy = (a).wyzy;\n    b.xywz += (b).wwxz;\n    b.xwzy /= sign(b).yyyy;\n    a.xwzy /= fract(vec4(-1.035, -4.122, 0.418, -0.302)).zzyz;\n\n    a.z += audio_freq(a.x+a.w);\n    a.wyxz /= (a).xzxx;\n    a.yxzw -= log2(b).wwxx;\n    a.yzwx -= normalize(b).xywy;\n    a.zwyx += (b).wwzz;\n\n\n    //a.x = audio_freq(a.x);\n    //a.z = a.z - audio_freq(a.z);\n\n\n    // Smooth HSV by iq\n    a.x = a.x * -0.150+0.618;\n    a.y *= 0.124;\n    a.xyz = SmoothHSV(a.xyz);\n}", "image_inputs": [{"id": "XsXGRr", "previewfilepath": "/media/ap/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sSyR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 77, 77, 125], [126, 126, 157, 157, 205], [241, 241, 265, 265, 384], [385, 385, 412, 412, 438], [439, 439, 466, 466, 498], [499, 499, 526, 526, 558], [559, 559, 586, 586, 608], [609, 609, 636, 636, 659], [660, 660, 687, 687, 710], [711, 711, 738, 738, 768], [769, 769, 796, 796, 810], [811, 811, 838, 838, 854], [856, 856, 895, 895, 1598]], "test": "error"}
{"id": "3sXBRr", "name": "Shiny sphere lights with subsurf", "author": "Iris_", "description": "original work from https://www.shadertoy.com/view/ltjGDd\nTest subsurface shader", "tags": ["subsurface"], "likes": 2, "viewed": 234, "published": "Public API", "date": "1587581763", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Adjust these to alter where the subsurface glow shines through and how brightly\nconst float FIVETAP_K = 2.0;\nconst float AO_DIST = 0.085;\n\n// The larger the DISTORTION, the smaller the glow\nconst float DISTORTION = 0.2;\n// The higher GLOW is, the smaller the glow of the subsurface scattering\nconst float GLOW = 6.0;\n// The higher the BSSRDF_SCALE, the brighter the scattered light\nconst float BSSRDF_SCALE = 3.0;\nconst float AMBIENT = 0.0;\n// Fun with spherical lights, area shadows, occlusion and reflections.\n// Sphere and trace functions by inigo quilez, http://www.iquilezles.org\n#define ATTENUATION 0\n\n#define BIAS 0.0001\n#define PI 3.1415927\n#define SEED 4.\n\n\nfloat subsurface(vec3 lightDir, vec3 normal, vec3 viewVec, float thickness) \n{\n    vec3 scatteredLightDir = lightDir + normal * DISTORTION;\n    float lightReachingEye = pow(clamp(dot(viewVec, -scatteredLightDir), 0.0, 1.0), GLOW) * BSSRDF_SCALE;\n    float attenuation = 1.0;\n    #if ATTENUATION\n    // attenuation = max(0.0, dot(normal, lightDir) + dot(viewVec, -lightDir));\n    #endif\n\tfloat totalLight = attenuation * (lightReachingEye + AMBIENT) * thickness;\n    return totalLight;\n}\n\nfloat sphIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n  vec3 oc = ro - sph.xyz;\n  float b = dot( oc, rd );\n  float c = dot( oc, oc ) - sph.w*sph.w;\n  float h = b*b - c;\n  if( h<0.0 ) return -1.0;\n  return -b - sqrt( h );\n}\n\nfloat sphOcclusion( in vec3 pos, in vec3 nor, in vec4 sph )\n{\n    vec3  r = sph.xyz - pos;\n    float l = length(r);\n    float d = dot(nor,r);\n    float res = d;\n\n    if( d<sph.w ) res = pow(clamp((d+sph.w)/(2.0*sph.w),0.0,1.0),1.5)*sph.w;\n    \n    return clamp( res*(sph.w*sph.w)/(l*l*l), 0.0, 1.0 );\n\n}\n\nfloat sphAreaShadow( vec3 P, in vec4 L, vec4 sph )\n{\n  vec3 ld = L.xyz - P;\n  vec3 oc = sph.xyz - P;\n  float r = sph.w - BIAS;\n  \n  float d1 = sqrt(dot(ld, ld));\n  float d2 = sqrt(dot(oc, oc));\n  \n  if (d1 - L.w / 2. < d2 - r) return 1.;\n  \n  float ls1 = L.w / d1;\n  float ls2 = r / d2;\n\n  float in1 = sqrt(1.0 - ls1 * ls1);\n  float in2 = sqrt(1.0 - ls2 * ls2);\n  \n  if (in1 * d1 < in2 * d2) return 1.;\n  \n  vec3 v1 = ld / d1;\n  vec3 v2 = oc / d2;\n  float ilm = dot(v1, v2);\n  \n  if (ilm < in1 * in2 - ls1 * ls2) return 1.0;\n  \n  float g = length( cross(v1, v2) );\n  \n  float th = clamp((in2 - in1 * ilm) * (d1 / L.w) / g, -1.0, 1.0);\n  float ph = clamp((in1 - in2 * ilm) * (d2 / r) / g, -1.0, 1.0);\n  \n  float sh = acos(th) - th * sqrt(1.0 - th * th) \n           + (acos(ph) - ph * sqrt(1.0 - ph * ph))\n           * ilm * ls2 * ls2 / (ls1 * ls1);\n  \n  return 1.0 - sh / PI;\n}\n\n\n//-------------------------------------------------------------------------------------------\nconst int SPH = 27; //3x3x3\n\nvec4 sphere[SPH];\nvec4 L;\n\nvec3 rand3( float x, float seed )\n{ \n  float f = x+seed;\n  return fract( PI*sin( vec3(f,f+5.33,f+7.7)) );\n}\n\nfloat areaShadow( in vec3 P )\n{\n  float s = 1.0;\n  for( int i=0; i<SPH; i++ )\n    s = min( s, sphAreaShadow(P, L, sphere[i] ) );\n  return s;           \n}\n\nvec3 reflections( vec3 P, vec3 R, vec3 tint, int iid )\n{\n  float t = 1e20;\n\n  vec3 s = vec3(R.y < 0. ? 1.-sqrt(-R.y/(P.y+1.)) : 1.); // P.y+1 floor pos\n  for( int i=0; i<SPH; i++ )\n  {    \n    float h = sphIntersect( P, R, sphere[i] );\n    if( h>0.0 && h<t )\n    {\n      s = i == iid ? tint * 2. : vec3(0.);\n      t = h;\n    }\n  }     \n  return max( vec3(0.), s);           \n}\n\nfloat occlusion( vec3 P, vec3 N )\n{\n  float s = 1.0;\n  for( int i=0; i<SPH; i++ )\n    s *= 1.0 - sphOcclusion( P, N, sphere[i] ); \n  return s;           \n}\n\nfloat sphLight( vec3 P, vec3 N, vec4 L)\n{\n  vec3 oc = L.xyz  - P;\n  float dst = sqrt( dot( oc, oc ));\n  vec3 dir = oc / dst;\n  \n  float c = dot( N, dir );\n  float s = L.w  / dst;\n  return max(0., c * s);\n}\n  \n//-------------------------------------------------------------------------------------------\n\nvec3 shade( vec3 I, vec3 P, vec3 N, float id, float iid )\n{\n  vec3 base = rand3( id, SEED );\n  vec3 wash = mix( vec3(0.9), base, 0.4);\n  vec3 hero = rand3( iid, SEED );\n  \n  vec3 ref = reflections( P, I - 2.*(dot(I,N))*N, hero, int(iid) );\n  float occ = occlusion( P, N );\n  float ocf = 1.-sqrt((0.5 + 0.5*-N.y)/(P.y+1.25))*.5; //floor occusion. 1.25 floor P.\n  float fre = clamp(1. + dot(I, N), 0., 1.); fre = (0.01+0.2*pow(fre,3.5));\n  vec3 dir = -(L.xyz  - P);\n    float len = dot(dir, dir);\n    dir = normalize(dir);\n  float thickness = abs(dot(I, N));\n  float sub = subsurface(dir, N, I, 0.5 - thickness * 0.3);\n  float lgh = sphLight( P, N, L)  *  areaShadow( P );\n  float inc = ( id == iid ? 1.0 : 0.0 );\n\n   \n  // Env light\n  vec3 C = vec3(1., 1., 1.) * occ * ocf * 0.5;\n  // C = vec3(0., 0., 0.);\n  // subsurface\n  if( id>-0.5 )\n  {\n      inc += sub / len * 3.;\n  }\n  // Sphere light\n  C += ( inc + lgh * 1.3 ) * hero;\n                  \n\n  // Reflections\n  C = mix( C, ref, fre );\n  \n  return C;\n}    \n\nvec3 trace( vec3 E, vec3 I, vec3 C, float px, float iid )\n{\n  float t = 1e20;\n  float id  = -1.0;\n  vec4  obj = vec4(0.);\n  for( int i=0; i<SPH; i++ )\n  {\n    vec4 sph = sphere[i];\n    float h = sphIntersect( E, I, sph ); \n    if( h>0.0 && h<t ) \n    {\n      t = h;\n      obj = sph;\n      id = float(i);\n    }\n  }\n              \n  if( id>-0.5 )\n  {\n    vec3 P = E + t*I;\n    vec3 N = normalize(P-obj.xyz);\n    C = shade( I, P, N, id, iid  );\n  }\n\n  return C;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    vec2 m = step(0.0001,iMouse.z) * iMouse.xy/iResolution.xy;\n    \n    //-----------------------------------------------------\n    \n    float time = iTime;\n    float an = 0.3*time - 7.0*m.x;\n    float sec = mod(time,1.);\n    \n    float spI = floor(mod(time,float(SPH)));\n    // float spI = \n    //-----------------------------------------------------\n    for( int i=0; i<SPH; i++ )\n    {\n      float ra = 0.4;\n      float id = float(i);\n      sphere[i] = vec4( mod( id, 3.0) - 1.0,\n                        mod( floor( id/3.0 ), 3.0 ) - .55,\n                        floor( id/9.0 )-1.0, ra );\n\n      if( i == int(spI) )\n      {\n        sphere[i].w += 0.025 * sin(sec*50.) / sqrt(sec) * ( 1.-sqrt(sec));\n        L = sphere[i];\n      }\n    }\n\n    //-----------------------------------------------------\n    \n    float fov = 1.8;\n    vec3 E = vec3( 3.5*sin(an), 2.0, 3.5*cos(an));\n    vec3 V = normalize( -E );\n    vec3 uu = normalize( cross( V, vec3(0., 1., 0.)));\n    vec3 vv = normalize( cross( uu, V));\n    vec3 I = normalize( p.x*uu + p.y*vv + fov*V );\n\n    float px = 1.0*(2.0/iResolution.y)*(1.0/fov);\n\n\n    //-----------------------------------------------------\n    \n    vec3 C = vec3(1.);\n\n    float tmin = 1e20;\n    float t = -(1.0+E.y)/I.y;\n    if( t>0.0 )\n    {\n        tmin = t;\n        vec3 pos = E + t*I;\n        vec3 nor = vec3(0.0,1.0,0.0);\n        C = shade( I, pos, nor, -1.0, spI );\n    }    \n    \n    C = trace( E, I, C, px, spI );\n    \n    // post\n    C = pow( C, vec3(0.41545) );   \n    C *= 0.5 + 0.5*pow(18.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.12);\n\n    fragColor = vec4( C, 1. );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sXBRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[670, 670, 748, 748, 1156], [1158, 1158, 1217, 1217, 1386], [1388, 1388, 1449, 1449, 1691], [1693, 1693, 1745, 1745, 2569], [2722, 2722, 2757, 2757, 2829], [2831, 2831, 2862, 2862, 2984], [2986, 2986, 3042, 3042, 3362], [3364, 3364, 3399, 3399, 3519], [3521, 3521, 3562, 3562, 3726], [3825, 3825, 3884, 3884, 4832], [4838, 4838, 4897, 4897, 5298], [5300, 5300, 5357, 5357, 7064]], "test": "valid"}
{"id": "3sXfRH", "name": "Landscape in a tweet", "author": "clepirelli", "description": "Small experiment with displaying as much as I could with as little code as I could\n\nLater much improved by Fabrice Neyret", "tags": ["landscape", "short", "tweet"], "likes": 2, "viewed": 188, "published": "Public API", "date": "1587654405", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//second version, by Fabrice Neyret, 220 chars (with AA)\n\n\n#define z(c) fract(4e5*sin(c*1e5))\nvoid mainImage(out vec4 o, vec2 u) {                                  \\\n    for(vec2 j = 6.* u/iResolution.xy - 2.4, c,x,f, i = j-j ;\n        i++.x < 6.;\n\t\to += smoothstep( c = fwidth(f),-c, f ).x / (2.+i).x\n       )\n       x = floor( c= j+i*iTime ), f = c-x,\n       f = j.y + 3.-i + mix( z(x),z(++x), f*f*(2.-f) );}\n\n\n\n\n\n\n\n\n\n\n\n//first version, by me, 258 chars: \n\n\n//#define z(c)fract(dot(vec3(sin(c*12.015)),vec3(84.942, 92.229, 74.298)))\n//void mainImage(out vec4 a,vec2 b){\n//\tvec2 j=(b/iResolution.xy-.4)*6.;\n//\tfor(float i; i<5.;i++){\n//\t\tfloat c=j.x+i*iTime,x=floor(c),f=c-x;\n//\t\ta+=float(j.y+3.-i+mix(z(x),z(++x),f*f*(2.-1.*f))<.5)/(3.+i);\n//\t}\n//}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sXfRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[95, 95, 131, 131, 411]], "test": "valid"}
{"id": "3tB3D1", "name": "UI VIPHead", "author": "magician0809", "description": "UI VIP Head", "tags": ["ui", "viphead"], "likes": 4, "viewed": 82, "published": "Public", "date": "1586423011", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec3 hash33(vec3 p3)\n{\n    p3 = fract(p3 * vec3(.1031,.11369,.13787));\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3(p3.x+p3.y, p3.x+p3.z, p3.y+p3.z)*p3.zyx);\n}\nfloat snoise3(vec3 p)\n{\n    const float K1 = 0.3333333;\n    const float K2 = 0.1666667;\n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n    vec3 i1 = e * (1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy * (1.0 - e);\n    vec3 d1 = d0 - (i1 - K2);\n    vec3 d2 = d0 - (i2 - K1);\n    vec3 d3 = d0 - (1.0 - 0.5);\n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h*h*h*h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i+i1)), dot(d2, hash33(i+i2)), dot(d3, hash33(i+1.0)));\n    return dot(vec4(31.316), n);\n}\n\n\n#define time (iTime * 0.9)\nconst vec3 color1 = vec3(1., 1., 0.1);\nconst vec3 color2 = vec3(1., 0.5, 0.1);\nconst float innerRadius = 0.25;\nconst float ringWidth = 0.03;\n\nvoid draw(out vec4 FragColor, in vec2 vUv)\n{\n    vec2 uv = vUv;\n    float len = length(uv);\n    float ang = atan(uv.y, uv.x);\n    float v0, v1, v2, v3;\n    vec4 col = vec4(1.0);\n    // ring\n    v0 = sin(ang * 2.0) * 0.5 + 0.5;\n    col.rgb = mix(color1, color2, v0);\n    v1 = smoothstep(innerRadius + ringWidth + 0.02, innerRadius + ringWidth, len);\n    // light\n    float n = snoise3(vec3(normalize(uv), time)) * 0.5 + 0.5;\n    n = n*n*n*n;\n    float d = len - innerRadius;\n    v2 = n * 1.0 / (1.0 + d);\n    v2 += 0.1 / (0.1 + d);\n    col.rgb = mix(vec3(1.0), col.rgb, v1);\n    // mask\n    v3 = smoothstep(innerRadius, innerRadius + 0.02, len);\n    v3 *= smoothstep(1.0, innerRadius + ringWidth, len);\n    // color\n    col.a = max(v1, v2);\n    col.a *= v3;\n    col = clamp(col, 0.0, 1.0);\n    //gl_FragColor = col;\n    FragColor = col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\n    vec4 col;\n    draw(col, uv);\n\n    vec3 bg = vec3(0.85, 0.15, 0.05);\n    \n    fragColor.rgb = mix(bg, col.rgb, col.a);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tB3D1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 23, 23, 183], [184, 184, 207, 207, 815], [987, 987, 1031, 1031, 1824], [1826, 1826, 1883, 1883, 2067]], "test": "valid"}
{"id": "4dcyR7", "name": "Speedy Spin - nmaga", "author": "nmaga23", "description": "Speedy Spin for CIS566", "tags": ["spin"], "likes": 1, "viewed": 42, "published": "Public", "date": "1586638075", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat bias( in float t, in float b) {\n    return (t / ((((1.0 / b) - 2.0) * (1.0 - t)) + 1.0));\n}\n\nfloat gain( in float t, in float g ) {\n\treturn t < 0.5 ? (bias(t * 2.0, g) * 0.5) : (0.5 + bias(t * 2.0 - 1.0, 1.0 - g) * 0.5);\n}\n\n// IQ\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d)\n{\n    return a + b * cos(6.28318 * (c * t + d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 pt = 2.0 * uv - 1.0;\n    float aspect = iResolution.x/iResolution.y;\n    pt.x *= aspect;\n    \n    vec3 accumCol = vec3(0.0);\n    float numSteps = 30.0;\n    \n    vec3 ac = vec3(0.5);\n    vec3 bc = vec3(0.5);\n    vec3 cc = vec3(1.0);\n    vec3 dc = vec3(0.0, 0.333, 0.667);\n    \n    // 30 samples of motion blur\n    for (int i = 0; i < 30; ++i){\n    \tfloat delta = (float(i) / (numSteps - 1.0) - 0.5) * .18;\n        float time = 2.75 * iTime - delta;\n        \n        vec2 pos = pt;\n        \n        // rectangular motion from circular motion\n        float sx = 0.5 + 0.5 * sin(3.14159 * time);\n    \t//sx = gain(sx, 0.1);\n    \t//sx = smoothstep(0.0, 1.0, sx);\n        float sy = 0.5 + 0.5 * cos(3.14159 * time);\n        //sy = gain(sy, 0.1);\n        //sy = smoothstep(0.0, 1.0, sy);\n        \n         // base pauses then animates, used for color and rotation\n        float rotationBase = floor(0.5 * time) + max(0.0, 8.0 * fract(0.5 * time) - 7.0); \n        float rotationTime = 0.875 * rotationBase * 2.0 * 3.1415962;\n        //rotationTime = 0.0;\n        float ct = cos(rotationTime);\n        float st = sin(rotationTime);\n\n        float scaleX = abs(sin(2.0 * 3.1415962 * time));\n        //scaleX = smoothstep(0.0, 1.0, scaleX);\n\n        // apply all transformations\n        //pos = vec2(ct * pt.x - st * pt.y, ct * pt.y + st * pt.x);\n        //pos.x /= 2.0;\n        pos -= 0.5 * vec2(sx, sy) - 0.25;\n        //pos.x *= 2.0;\n        //pos /= 0.75 + 0.5 * scaleX;\n        \n        \n        // pulse effect at end of rotation\n        float pulse = 0.5 + 0.5 * sin((time + 0.4) * 3.14159);\n        pulse = bias(pulse, 0.009);\n        //pos /= 1.0 + 1.0 * pulse;\n        float cp = cos(-0.25 * pulse * 3.1415962);\n        float sp = sin(-0.25 * pulse * 3.1415962);\n        //pos = vec2(cp * pos.x - sp * pos.y, cp * pos.y + sp * pos.x);\n        \n        accumCol +=  2.0 * step(length(pos) - 0.01, 0.05) / numSteps;\n    }\n    \n    vec3 col = vec3(0.0);\n\t\n    col = accumCol;\n    // gamma correct to improve visibility\n    col = pow(col, vec3(0.454545454545454545));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dcyR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 38, 38, 98], [100, 100, 138, 138, 229], [231, 237, 307, 307, 356]], "test": "valid"}
{"id": "4tVGzV", "name": "Single Star PSF", "author": "toninoni", "description": "SImplified version of the shader fround in https://www.shadertoy.com/view/XdsGWs#, only with one star rendered and accepting a rgb color.", "tags": ["star", "cosmos", "astrophysics", "astronomy", "psf"], "likes": 2, "viewed": 117, "published": "Public", "date": "1588155422", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float star_luminosity = 5.0;\nvec2 FragCoord;\n\nvec3 draw_star(vec2 pos, vec3 star_col) {\n\tpos -= FragCoord.xy / iResolution.x; \n\tfloat d = length(pos) * 50.0;\n\tvec3 col, spectrum = star_col;\n\tcol = spectrum / (d * d * d);\n\t\n\t// produce spikes\n\td = length(pos * vec2(10., .2)) * 50.0;\n\tcol += spectrum / (d * d * d);\n\td = length(pos * vec2(.2, 10.)) * 50.0;\n\tcol += spectrum / (d * d * d);\n\n\treturn col;\n}\n\n// --- main -----------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec3 col;\n\tFragCoord=fragCoord;\n    \n    vec3 star_color = vec3(abs(sin(iTime)), 0.2, abs(cos(iTime))) * star_luminosity;\n\tcol = draw_star(vec2(.5,.3), star_color);\n\t\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tVGzV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 87, 87, 403], [405, 459, 516, 516, 714]], "test": "valid"}
{"id": "ltXyD7", "name": "Geode", "author": "KilledByAPixel", "description": "Continuing experiments with my pixel zoom code to make cool endless zooming fractals.", "tags": ["fractal", "zoom", "recursion"], "likes": 4, "viewed": 272, "published": "Public API", "date": "1586285596", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//////////////////////////////////////////////////////////////////////////////////\n// Eye of God Zoom - Copyright 2017 Frank Force\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//////////////////////////////////////////////////////////////////////////////////\n\nconst float zoomSpeed\t\t\t= 10.0;\t// how fast to zoom (negative to zoom out)\nconst float zoomScale\t\t\t= 0.00001;\t// how much to multiply overall zoom (closer to zero zooms in)\nconst int recursionCount\t\t= 8;\t// how deep to recurse\nconst int glyphSize\t\t\t\t= 3;\t// width & height of glyph in pixels\nconst float curvature\t\t\t= -16.0;\t// time warp to add curvature\n\n//////////////////////////////////////////////////////////////////////////////////\n// Precached values and math\n\nconst float glyphSizeF = float(glyphSize);\nconst float glyphSizeLog = log(glyphSizeF);\n\nconst float e = 2.718281828459;\nconst float pi = 3.14159265359;\nfloat RandFloat(int i) { return (fract(sin(float(i)) * 43758.5453)); }\nint RandInt(int i) { return int(100000.0*RandFloat(i)); }\n\nvec3 HsvToRgb(vec3 c) \n{\n    float s = c.y * c.z;\n    float s_n = c.z - s * .5;\n    return vec3(s_n) + vec3(s) * cos(2.0 * pi * (c.x + vec3(1.0, 0.6666, .3333)));\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n// Color and image manipulation\n\nfloat GetRecursionFade(int r, float timePercent)\n{\n    if (r > recursionCount)\n        return timePercent;\n    \n    // fade in and out recusion\n    float rt = max(float(r) - timePercent, 0.0);\n    float rc = float(recursionCount);\n    return rt / rc;\n}\n\nvec3 InitPixelColor() { return vec3(0); }\nvec3 CombinePixelColor(vec3 color, float timePercent, int i, int r, vec2 pos, ivec2 glyphPos, ivec2 glyphPosLast)\n{\n    i = (i+r) + (glyphPosLast.y + glyphPos.y);\n\n    vec3 myColor = vec3\n    (\n    \tmix(-0.05, 0.05, RandFloat(i)),\n    \tmix(0.0, 0.2, RandFloat(i + 10)),\n        mix(0.0, 0.2, RandFloat(i + 20))\n    );\n\n    // combine with my color\n    float f = GetRecursionFade(r, timePercent);\n    //myColor.y = pow(myColor.y, 2.0);\n    //myColor.z = pow(myColor.z, 2.0);\n    color += myColor*f;\n    return color;\n}\n\nvec3 FinishPixel(vec3 color, vec2 uv)\n{\n    // color wander\n    color.x += 0.01*iTime;\n    \n    // convert to rgb\n    color = HsvToRgb(color);\n    return color;\n}\n\nvec2 InitUV(vec2 uv)\n{\n    // spin\n    float theta = pi/2.0;//0.05*iTime;\n\tfloat c = cos(theta);\n\tfloat s = sin(theta);\n\tuv = vec2((uv.x*c - uv.y*s), (uv.x*s + uv.y*c));\n    \n\t// wave\n\tuv.x += 0.05*sin(10.0*uv.y + 0.17*iTime);\n\tuv.y += 0.05*sin(10.0*uv.x + 0.13*iTime);\n\tuv.x += 0.2*sin(1.0*uv.y + 0.31*iTime);\n\tuv.y += 0.2*sin(1.0*uv.x + 0.27*iTime);\n    return uv;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////\n// Fractal functions\n\nivec2 GetFocusPos(int i) { return ivec2(glyphSize/2); }\n      \n// get color of pos, where pos is 0-1 point in the glyph\nvec3 GetPixelFractal(vec2 pos, int iterations, float timePercent)\n{\n\tivec2 glyphPosLast = GetFocusPos(-2);\n\tivec2 glyphPos =     GetFocusPos(-1);\n\tvec3 color = InitPixelColor();\n    \n\tfor (int r = 0; r <= recursionCount + 1; ++r)\n\t{\n        color = CombinePixelColor(color, timePercent, iterations, r, pos, glyphPos, glyphPosLast);\n        if (r > recursionCount)\n\t\t\treturn color;\n           \n        // update pos\n        pos *= glyphSizeF;\n\n        // get glyph and pos within that glyph\n        glyphPosLast = glyphPos;\n        glyphPos = ivec2(pos);\n        \n        // next glyph\n\t\tpos -= vec2(floor(pos));\n\t}\n}\n \n//////////////////////////////////////////////////////////////////////////////////\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// use square aspect ratio\n\tvec2 uv = fragCoord;\n\tuv = fragCoord / iResolution.y;\n\tuv -= vec2(0.5*iResolution.x / iResolution.y, 0.5);\n    uv = InitUV(uv);\n    \n    // time warp\n    float time = iTime + curvature*pow(length(uv), 0.2);\n    \n\t// get time \n\tfloat timePercent = time*zoomSpeed;\n\tint iterations = int(floor(timePercent));\n\ttimePercent -= float(iterations);\n\t\n\t// update zoom, apply pow to make rate constant\n\tfloat zoom = pow(e, -glyphSizeLog*timePercent);\n\tzoom *= zoomScale;\n    \n\t// get offset\n\tvec2 offset = vec2(0);\n    const float gsfi = 1.0 / glyphSizeF;\n\tfor (int i = 0; i < 13; ++i)\n\t\toffset += (vec2(GetFocusPos(i)) * gsfi) * pow(gsfi,float(i));\n    \n\t// apply zoom & offset\n    vec2 uvFractal = uv * zoom + offset;\n\t\n\t// check pixel recursion depth\n\tvec3 pixelFractalColor = GetPixelFractal(uvFractal, iterations, timePercent);\n    pixelFractalColor = FinishPixel(pixelFractalColor, uv);\n    \n\t// apply final color\n\tfragColor = vec4(pixelFractalColor, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltXyD7.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[923, 923, 947, 947, 993], [994, 994, 1014, 1014, 1051], [1053, 1053, 1077, 1077, 1217], [1335, 1335, 1385, 1385, 1587], [1589, 1589, 1612, 1612, 1630], [1631, 1631, 1746, 1746, 2148], [2150, 2150, 2189, 2209, 2312], [2314, 2314, 2336, 2348, 2682], [2790, 2790, 2816, 2816, 2845], [2853, 2910, 2977, 2977, 3526], [3614, 3614, 3671, 3699, 4655]], "test": "error"}
{"id": "MtcyRB", "name": "Dimension", "author": "EthanZappa", "description": "Dimension Tunnel", "tags": ["dimension"], "likes": 4, "viewed": 114, "published": "Public", "date": "1585776380", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 p = (-iResolution.xy + 2.3*fragCoord)/iResolution.y;\n\n    \n    float a = atan(p.y,p.x);\n    \n  \n    float r = pow( pow(p.x-p.x,2.0) + pow(p.y*p.y,4.0), 1.0/9.0 );\n    \n   \n    vec2 uv = vec2( 1.0/r + 1.4*iTime, a );\n\n    \n    float f = cos(15.0*uv.x)*cos(5.0*uv.y);\n\n    \n    vec3 col = 1.5 + 1.4*sin( 23.616*f + vec3(1.0,3.0,4.0) );\n    \n      \n    col = col*f;\n    \n    \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtcyRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 480]], "test": "valid"}
{"id": "td2cDd", "name": "Doodle: 4D Rendering", "author": "blackle", "description": "playing around with the raymarching equation and SDFs in 4 dimensions", "tags": ["raymarching", "4d"], "likes": 8, "viewed": 361, "published": "Public API", "date": "1587563488", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nfloat smin(float a, float b, float k) {\n  float h = max(0., k-abs(a-b))/k;\n  return min(a,b)-h*h*h*k/6.;\n}\n\n//smooth triangle wave for smooth domain repetition https://www.desmos.com/calculator/ototv6tja8\nvec4 stri(vec4 p, float k) {\n  return asin(sin(p*3.14)*k)/3.14+0.5;\n}\n\nfloat scene(vec4 p) {\n  vec4 q = abs(p) - 1.;\n  float cube = length(max(q,0.0)) + min(max(max(q.x,q.w),max(q.y,q.z)),0.0) - 0.1;\n  float scale = 1.;\n  vec4 p2 = p+iTime*0.2;\n  p2 = (stri(p2/scale, .9)-0.5)*scale;\n  float spheres = length(p2)-0.2;\n  spheres = -smin(-(length(p) - 2.), -spheres, 0.1);\n  return smin(cube, spheres, 0.5);\n}\n\nvec4 norm(vec4 p) {\n  mat4 k = mat4(p,p,p,p) - mat4(0.001);\n  return normalize(scene(p) - vec4( scene(k[0]),scene(k[1]),scene(k[2]),scene(k[3]) ) );\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax,p)*ax,p,cos(ro)) + sin(ro)*cross(ax,p);\n}\n\nvec3 srgb(float r, float g, float b) {\n  return pow(vec3(r,g,b),vec3(2.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n  vec2 mouse = (iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n\n  vec4 cam = normalize(vec4(1,uv,0));\n  vec4 init = vec4(-5,0,0,sin(iTime*0.1));\n\n  float wrot = cos(iTime*0.5);\n  float zrot = cos(iTime*0.25);\n  float yrot = sin(iTime*0.5);\n  float zrot2 = iTime;\n  if (iMouse.z > 0.) {\n    zrot = mouse.x*2.;\n    wrot = radians(45.0);\n    yrot = mouse.y*2.;\n    zrot2 = 0.;\n  }\n  cam.xyw = erot(cam.xyw, vec3(0,1,0), zrot);\n  init.xyw = erot(init.xyw, vec3(0,1,0), zrot);\n  cam.xyz = erot(cam.xyz, vec3(0,1,0), yrot);\n  init.xyz = erot(init.xyz, vec3(0,1,0), yrot);\n  cam.yzw = erot(cam.yzw, vec3(0,1,0), wrot);\n  init.yzw = erot(init.yzw, vec3(0,1,0), wrot);\n  cam.xyz = erot(cam.xyz, vec3(0,0,1), zrot2);\n  init.xyz = erot(init.xyz, vec3(0,0,1), zrot2);\n  \n  vec4 p = init;\n  bool hit = false;\n  for (int i = 0; i<200 && !hit;i++) {\n    float dist = scene(p);\n    hit = dist*dist < 1e-6;\n    p+=dist*cam;\n  }\n  vec4 n = norm(p);\n  vec4 r = reflect(cam,n);\n  vec4 aon = reflect(cam, norm(p+r*0.3));\n  float factor = length(sin(aon*3.)*0.5+0.5)/2.;\n  vec3 color = mix(srgb(0.1,0.1,0.2), srgb(0.2,0.6,0.9), factor) + pow(factor, 10.);\n  fragColor.xyz = hit ? color : srgb(0.1,0.1,0.1);\n  fragColor.xyz = sqrt(fragColor.xyz);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td2cDd.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[194, 194, 233, 233, 300], [302, 399, 427, 427, 468], [470, 470, 491, 491, 806], [808, 808, 827, 827, 958], [960, 960, 998, 998, 1060], [1062, 1062, 1100, 1100, 1138], [1140, 1140, 1197, 1197, 2486]], "test": "valid"}
{"id": "td2cDw", "name": "Into NaCl Crystal", "author": "Smake", "description": "Experiments with 3d RB and R-Cyan glasses. The next steps are tuning of disparity and making up for more realistic virtuality ).", "tags": ["3d", "anaplyph", "rgbglasses"], "likes": 2, "viewed": 116, "published": "Public", "date": "1586858521", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// https://www.shadertoy.com/view/XdKGWm as start point\n// https://www.shadertoy.com/view/td2cDw autolink\n\nfloat map(vec3 p){\n   vec3 q = fract(p) * 2.0 -1.0;\n   float radius = .15;\n \treturn length(q) - radius;   \n}\n\nfloat trace(vec3 o, vec3 r){\n    float t = 0.0;\n    for (int i =0; i <32; i++){\n       \tvec3 p = o+r*t;   \n        float d=map(p);\n      t += 0.5* d;//* 0.5;\t\n    }\n     return t;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 r = normalize(vec3(uv,1.0));\n    \n    vec3 ol = vec3(0.0,0.0, iTime*.5);\n    vec3 or = vec3(0.1,0.0, iTime*.5);\n  \n    float tr = trace(or, r);\n    float tl = trace(ol, r);\n    \n    float fogR =  1.0/(0.1 + tr);\n    float fogL =  1.0/(0.1 + tl);\n    \n    //  vec3 fc = vec3 (fogR, fogL,fogL); //for R-Cyan glasses   \n    vec3 fc = vec3(fogR, 0.0,fogL);       // for R-B glasses\n       \n\tfragColor = vec4(fc,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td2cDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 107, 125, 125, 215], [217, 217, 245, 245, 403], [405, 405, 462, 462, 1001]], "test": "valid"}
{"id": "td2cDy", "name": "Single Layer Glitter", "author": "qwert33", "description": "First step towards building a renderer for https://youtu.be/BtYKDamqo2I?t=334\n\nStep two: https://www.shadertoy.com/view/tsjyWV\nStep three: https://www.shadertoy.com/view/wdXfzN#", "tags": ["glitter"], "likes": 1, "viewed": 164, "published": "Public API", "date": "1587300959", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define TAU 6.28318530718\n#define PI TAU/2\n    \n// biases x to be closer to 0 or 1\n// can act like a parameterized smoothstep\n// https://www.desmos.com/calculator/c4w7ktzhhk\n// if b is near 1.0 then numbers a little closer to 1.0 are returned\n// if b is near 0.0 then numbers a little closer to 0.0 are returned\n// if b is near 0.5 then values near x are returned\nfloat bias(float x, float b) {\n    x = clamp(x, 0., 1.);\n    b = -log2(1.0 - b);\n    return 1.0 - pow(1.0 - pow(x, 1./b), b);\n}\n\n// Dave Hoskins hash\nfloat hash13( in vec3 p3 ) {\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nconst vec3 default_debug = vec3(-100, -20, -10);\nvec3 debug = default_debug;\nconst vec3 orange = vec3(1., .5, 0.);\nconst vec3 cornflowerblue = vec3(100./255., 149./255., 237./255.);\n\nvec2 domsMouse;\n\nvec2 project(vec2 pixel) {\n    vec2 uv = pixel/iResolution.xy - vec2(0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv;\n}\n\n\nfloat circle(vec2 uv) {\n    //uv *= 2.;\n    if (length(uv)< 0.9) {\n        if (abs(uv.y) < .1) return .8;\n        return 0.3;\n    }\n    if (length(uv)< 1.) {\n        return 1.;\n    }\n    return 0.;\n    return clamp(length(uv)-8., 0., 1.);\n    return bias(1.-(abs(length(uv) - 1. +.018) / .02), .8);\n}\n// Returns a unit-length vector at a given rotation.\n// Analogous to e^(-i*theta)\n// i.e. rotate (1,0) anticlockwise for theta radians. (+y means facing up)\nvec2 e(float theta) {\n    return vec2(cos(theta), sin(theta));\n}\nfloat monochrome(vec2 uv) {\n    float height = 4.;\n    \n    const float cell_wd = 1.;\n    vec2 inner_uv = mod(uv+cell_wd, 2.*cell_wd) - cell_wd;  // position within grid cell.\n\tvec2 outer_uv = floor((uv+cell_wd)/ 2.*cell_wd);      // index of grid cell.\n    \n    \n    //vec2 angular_vel = vec2(outer_uv.yx);\n    vec2 outer_hash_pos = outer_uv + vec2(1030., 0);\n    float yaw = TAU * hash13(vec3(outer_hash_pos, 2.));\n    float angular_speed = 3. + hash13(vec3(outer_hash_pos, 3.));\n    vec2 angular_vel = angular_speed* vec2(cos(yaw), sin(yaw));\n    //if ( outer_uv.y < -1.1) debug = cornflowerblue;\n    float pitch = length(angular_vel) * (iTime+100.)*0.1;\n    vec2 a = normalize(angular_vel);  // axis of rotation\n    mat2 rot = mat2(a.x, a.y,\n                    -a.y, a.x);\n    inner_uv = rot * inner_uv;\n    inner_uv.y /= cos(pitch);\n    inner_uv = transpose(rot) * inner_uv;  // note: could be removed when our object is rotationally symmetric..\n    inner_uv *= 1.5; // don't make the circles take up the entire inner square\n\n    vec3 normal = vec3(0.0, sin(pitch), cos(pitch));\n    mat3 rot3 = mat3(a.x, a.y, 0.,\n                     -a.y, a.x, 0.,\n                     0., 0., 1.);\n    normal = transpose(rot3) * normal;\n    const vec3 LIGHT_DIR = normalize(vec3(1.5, -1.0, 2.0));\n    float light = \n        .2 + // ambient\n        .8 * smoothstep(.98, .99, abs(dot(normal, LIGHT_DIR)));  // cheap (wrong-ish) specular\n           \n    float acc = 0.;\n    acc += light * circle(inner_uv);\n    \n\treturn clamp(acc, 0., 1.);\n}\n\nfloat f(vec2 fragCoord) {\n    vec2 uv = project(fragCoord);\n    uv /= project(domsMouse.xy).xx / 3.;\n    return monochrome(uv);\n}\n\n// antialiasing\nfloat sampleSubpixel(vec2 pixels) {\n\tconst int size = 1; \n\tfloat disp = 1.0 / (float(size) + 2.0);\n\tfloat contrb = 0.0;\n\tfloat maxContrb = 0.0;\n\tfor (int j = -size; j <= size; j++) {\n\t\tfor (int i = -size; i <= size; i++) {\n\t\t\tcontrb += f(pixels + vec2(float(i) * (disp / 3.0), float(j) * disp));\n\t\t\tmaxContrb += 1.0;\n\t\t}\n\t}\n\treturn contrb / maxContrb;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    domsMouse = iMouse.xy;\n    if (iMouse.x == 0.) { domsMouse.x = iResolution.x * .5 + 30.; }\n    fragColor = vec4(orange * sampleSubpixel(fragCoord), 1.0);\n    if (debug != default_debug) fragColor.rgb = debug;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td2cDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 365, 395, 395, 492], [494, 515, 543, 543, 646], [848, 848, 874, 874, 982], [985, 985, 1008, 1024, 1285], [1286, 1443, 1464, 1464, 1507], [1508, 1508, 1535, 1535, 3038], [3040, 3040, 3065, 3065, 3169], [3542, 3542, 3596, 3596, 3811]], "test": "valid"}
{"id": "td2cWz", "name": "Lines Testing", "author": "CornerPin", "description": "Drawing lines with shaders.", "tags": ["test", "lines"], "likes": 1, "viewed": 99, "published": "Public", "date": "1586474492", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float Pi = 3.141592653589793;\nconst float OneThird = 2.0 * Pi/3.0;\n\nvec4 drawLine(vec2 fragCoord, vec2 from, vec2 to, vec4 clrFrom, vec4 clrTo) {\n    vec2 diff = to - from;\n    float len = length(diff);\n    vec2 localSpace = fragCoord - from;\n    \n    float dist = determinant(mat2(diff, localSpace)) / len;\n    \n    if (abs(dist) < 0.005) {\n        float proj = dot(diff, localSpace) / len / len;\n        \n        if (proj >= 0.0 && proj <= 1.0)\n\t        return mix(clrFrom, clrTo, proj);\n    }\n    \n    return vec4(0.0, 0.0, 0.0, 1.0);\n}\n\nvec4 red   = vec4(1.0, 0.0, 0.0, 1.0);\nvec4 green = vec4(0.0, 1.0, 0.0, 1.0);\nvec4 blue  = vec4(0.0, 0.0, 1.0, 1.0);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = 2.0 * fragCoord / iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec2\n        a = 0.5 * vec2(cos(iTime), sin(iTime)),\n        b = 0.5 * vec2(cos(iTime + OneThird), sin(iTime + OneThird)),\n        c = 0.5 * vec2(cos(iTime - OneThird), sin(iTime - OneThird));\n    \n    fragColor = drawLine(uv, a, b, red, green);\n    fragColor += drawLine(uv, b, c, green, blue);\n    fragColor += drawLine(uv, c, a, blue, red);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td2cWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[74, 74, 151, 151, 545], [665, 665, 720, 720, 1170]], "test": "valid"}
{"id": "td2czc", "name": "raymarchShader_fractal2", "author": "newboldTom", "description": "raymarch fractal", "tags": ["fractal", "raymarch"], "likes": 0, "viewed": 35, "published": "Public", "date": "1587116926", "time_retrieved": "2021-10-01T00:00:00", "image_code": "int MARCH_ITERATIONS = 250;\nfloat SMOOTHING = 0.0005;\nint FRACTAL_ITERATIONS = 9;\nbool DEFORM = false;\nfloat MIN_VIEWDIS = 0.75;\nfloat MAX_VIEWDIS = 3.0;\nbool AO = false;\nbool GLOW = true;\nfloat glowThreshold = 0.0001;\nfloat glowRadius = 0.005;\nbool FIXED_CAMERA = false;\nbool ORBIT = true;\n\nvec3 transform(vec3 p, vec3 rot){\n    //x axis rot\n    p = vec3(p.x, p.y*cos(rot.x) - p.z*sin(rot.x), p.y*sin(rot.x) + p.z*cos(rot.x));\n    //y axis rot\n    p = vec3(p.x*cos(rot.y) + p.z*sin(rot.y), p.y, p.x*sin(rot.y) - p.z*cos(rot.y));\n    //z axis rot\n    p = vec3(p.x*cos(rot.z) - p.y*sin(rot.z), p.x*sin(rot.z) + p.y*cos(rot.z), p.z);\n    \n    p = abs(p);\n    \n    return p;\n}\n\n//http://www.fractalforums.com/sierpinski-gasket/kaleidoscopic-(escape-time-ifs)/?PHPSESSID=6c514a6be466438969dd15d053d618b2\n\nfloat prim_tetra(vec3 p, float scale){\n\tfor(int i=0;i<FRACTAL_ITERATIONS;i++){\n        if(DEFORM){\n        \tp = transform(p,vec3(iTime*0.1,0.2,iTime*0.25));\n        }\n        if(p.x+p.y<0.0){p.xy = -p.yx;}\n        if(p.x+p.z<0.0){p.xz = -p.zx;}\n        if(p.y+p.z<0.0){p.zy = -p.zy;}\n        p = p*scale - (scale - 1.0);\n    }\n    return (length(p)-scale)*pow(scale,-float(FRACTAL_ITERATIONS));\n}\n\n\nfloat scene(vec3 p){\n    if(!FIXED_CAMERA){\n        if(!ORBIT){\n    \t\tvec3 rot = vec3(2.5*sin(iTime*0.25),0.2*iTime,cos(iTime*0.1));\n    \t\tp = transform(p, rot);\n        } else {\n    \t\tp = transform(p, vec3(0.6*iTime, 0.0, 0.5*(0.5+cos(iTime*0.35))));\n        }\n    }\n    //return min(torus(p,vec2(0.8,0.2)),prim_tetra(p));\n    return prim_tetra(p, 2.0);\n}\n\nvec3 calNormal(vec3 p, float smoothVal){\n    return normalize(vec3(\n        scene(p+vec3(smoothVal,0,0))-scene(p+vec3(-smoothVal,0,0)),\n        scene(p+vec3(0,smoothVal,0))-scene(p+vec3(0,-smoothVal,0)),\n        scene(p+vec3(0,0,smoothVal))-scene(p+vec3(0,0,-smoothVal))));\n}\n\nvec3 raymarch(vec2 uv, vec3 cam, vec3 lightDir, vec3 lightCol, vec3 matCol, vec3 ambient, vec3 fogCol){\n    vec3 dir = normalize(vec3(2.0*uv.x-1.0,2.0*uv.y-1.0,1.0));;\n    float totalDis = 0.0;\n    float minDis = 100000000.0;\n    vec3 p;\n    //raymarch\n    int i = 0;\n    while(i<MARCH_ITERATIONS){\n        p = cam + totalDis*dir;\n        float stepDis = scene(p)*0.5;\n        totalDis = totalDis + stepDis;\n        if(stepDis < minDis){minDis = stepDis;}\n        if(stepDis < 0.01*minDis){break;}\n        i++;\n    }\n    //lighting\n    if(minDis < glowThreshold){\n    \tvec3 normal = calNormal(p,SMOOTHING);\n    \tfloat diffuse = dot(lightDir,normal);\n    \tdiffuse = 0.5*diffuse + 0.5;\n    \tvec3 diffuseLit = diffuse*lightCol*matCol*ambient;\n        if(AO){diffuseLit = diffuseLit*smoothstep(0.75,1.0,float(i/MARCH_ITERATIONS));}\n    \treturn mix(diffuseLit,fogCol,smoothstep(MIN_VIEWDIS,MAX_VIEWDIS,totalDis));\n    } else if(GLOW) {\n        return mix(vec3(0.25,0.45,0.25),vec3(0.075,0.075,0.075),smoothstep(glowThreshold,glowRadius,minDis));\n    } else {\n        return vec3(0.05,0.05,0.05);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t//gen inputs\n    vec3 cam;\n    if(FIXED_CAMERA || ORBIT){\n        cam = vec3(0,0,-3.0);\n    } else if(!ORBIT){\n    \tcam = vec3(0,0,-(0.8+0.6*sin(iTime*0.5)));\n    }\n    vec3 lightDir = normalize(vec3(-0.1,-0.2,-0.5));\n    vec3 lightCol = vec3(1.0,1.0,1.0);\n    vec3 matCol = vec3(0.1,0.75,0.6);\n    vec3 ambient = vec3(0.2,0.2,0.6);\n    vec3 fogCol = vec3(0.1,0.0,0.2);\n    //raymarch\n    vec3 col = raymarch(uv,cam,lightDir,lightCol,matCol,ambient,fogCol);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td2czc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[292, 292, 325, 342, 673], [801, 801, 839, 839, 1197], [1200, 1200, 1220, 1220, 1556], [1558, 1558, 1598, 1598, 1833], [1835, 1835, 1938, 1938, 2933], [2935, 2935, 2992, 3042, 3598]], "test": "valid"}
{"id": "td2yRG", "name": "Hindsight Sketch", "author": "baksej", "description": "Hindsight Sketch", "tags": ["static"], "likes": 2, "viewed": 116, "published": "Public", "date": "1586882096", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random1f(vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat map(float v, float a, float b, float c, float d) {\n    float nv = (v - a) / (b - a);\n    nv = pow(nv, 3.0);\n    float o = nv * (d - c) + c;\n    \n    return o;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.y /= iResolution.x / iResolution.y;\n    \n    vec2 A = vec2(-0.5, -.2);\n    vec2 B = vec2(0.5, -.2);\n    vec2 C = vec2(0, 0.5);\n    vec2 D = vec2(0.5, -.8);\n    \n    float k1 = 0.8; // size\n    float k2 = 2.0; // shape\n    \n    // warp domains\n    vec2 uvA = uv * vec2(1.0, 0.8);\n    uvA.x += sin(uv.y * 5.0 + iTime) * 0.1;\n    vec2 uvB = uv * vec2(0.8, 1.0);\n    uvB.x += sin(uv.y * 4.0 + iTime) * 0.1;\n    vec2 uvC = uv * vec2(1.0, 0.8);\n    uvC.y += sin(uv.x * 4.0 + iTime) * 0.1;\n    vec2 uvD = uv * vec2(0.2, 0.8);\n    uvD.y += sin(uv.x * 4.0 + iTime) * 0.1;\n    \n    // create shaped gradient\n    float dA = max(0.0, 1.0 - pow(distance(uvA, A) / k1, k2));\n    float dB = max(0.0, 1.0 - pow(distance(uvB, B) / k1, k2));\n    float dC = max(0.0, 1.0 - pow(distance(uvC, C) / k1, k2));\n    float dD = max(0.0, 1.0 - pow(distance(uvD, D) / k1, k2));\n    \n    // smooth in, out\n    dA = smoothstep(0.0, 1.0, dA);\n    dB = smoothstep(0.0, 1.0, dB);\n    dC = smoothstep(0.0, 1.0, dC);\n    dD = smoothstep(0.0, 1.0, dD);\n    \n    // define colors\n    vec3 blue = vec3(35.0, 122.0, 144.0) / 255.0;\n    vec3 pink = vec3(255.0, 122.0, 114.0) / 255.0;\n    vec3 green = vec3(44.0, 162.0, 148.0) / 255.0;\n    vec3 black = vec3(20.0, 10.0, 0.0) / 255.0;\n    \n    vec3 vanta = vec3(-25, -25, -25) / 255.0;\n    \n    // lay in color blobs\n    vec3 color = vec3(0.0);\n    color = mix(color, blue, dA);\n    color = mix(color, vanta, dC);\n    color = mix(color, pink, dB);\n    color = mix(color, green, dD);\n    \n    // add noise\n    color += vec3(\n        random1f(uv),\n        random1f(uv + 1.0),\n        random1f(uv + 2.0)\n    ) * 0.1;\n    \n    color += vec3(\n        random1f(uv),\n        0,\n        0\n    ) * 0.5 * dB;\n    \n    // complex noise\n    \n    // float t = floor(iTime * 10.0);\n    // float t_next = floor(iTime * 10.0 + 1.0);\n    // float f = fract(iTime * 10.0);\n    \n    // vec3 noise = mix(\n        //     vec3(\n            //         random1f(uv + t),\n            //         random1f(uv + t + 1.0),\n            //         random1f(uv + t + 2.0)\n        //     ),\n        //     vec3(\n            //         random1f(uv + t_next),\n            //         random1f(uv + t_next + 1.0),\n            //         random1f(uv + t_next + 2.0)\n        //     ),\n    // f);\n    \n    // color += noise * 0.1;\n    \n    fragColor = vec4(color, 1.0);\n    // fragColor = vec4(vec3(ddA + 0.1), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td2yRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 101], [103, 103, 159, 159, 269], [271, 271, 326, 326, 2787]], "test": "valid"}
{"id": "td2yRR", "name": "Some Simple Waves", "author": "GabrielFelix", "description": "Some Waves", "tags": ["waves", "beginner"], "likes": 1, "viewed": 209, "published": "Public API", "date": "1586010175", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 Rect(vec2 uv, vec4 size, float blur, vec2 position, vec3 color){\n\t//position: left right up down\n    uv -= position;\n    \n    float left = smoothstep(size.x - blur, size.x + blur, uv.x);\n    float right = smoothstep(size.y + blur, size.y - blur, uv.x);\n    \n    float up = smoothstep(size.z - blur, size.z + blur, uv.y);\n    float down = smoothstep(size.w + blur, size.w - blur, uv.y);\n    \n    \n    return (left * right * up * down) * color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Setup\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    //Drawing\n    uv.y += cos(cos(iTime + uv.x) );  \n    vec3 col = Rect(vec2(uv.x, uv.y), vec4(-1., 1, -0.5, 0.1), 0.001, vec2(0., 0.5), vec3(0., 1., 1.));\n    \n    // Output\n    fragColor = vec4(col ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td2yRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 69, 101, 449], [452, 452, 509, 521, 831]], "test": "valid"}
{"id": "td2yWh", "name": "Sonic Salad", "author": "blackle", "description": "an impromptu shader live coded in 30 minutes in front of my roommate. I was inspired by shader showdown and wanted to try it out. programmed on my phone with a bluetooth keyboard which was immensely frustrating", "tags": ["livecode"], "likes": 14, "viewed": 460, "published": "Public API", "date": "1586566028", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n#define time iTime\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n\treturn mix(dot(p,ax)*ax,p,cos(ro)) + sin(ro)*cross(ax,p);\n}\n\nfloat linedist(vec2 p, vec2 a, vec2 b) {\n  float k = dot(p-a,b-a)/dot(b-a,b-a);\n  return distance(p, mix(a, b, clamp(k,0.,1.) ));\n}\n\nfloat hash(float a, float b) {\n\treturn -1.+2.*fract(sin(dot(vec2(a,b), vec2(12.4348,74.38483)))*48573.2394);\n}\n\nfloat scene(vec3 p ) {\n\tfloat scale  = 0.2;\n\tvec3 id = floor(p*scale);\n    float idhash = hash(hash(id.y, id.x), id.z);\n\tfloat hash1 = hash(idhash, id.y)*6.28;\n\tfloat hash2 = hash(id.x, idhash)*6.28;\n\tvec3 ax = normalize(vec3(cos(hash1), sin(hash1)*cos(hash2), sin(hash1)*sin(hash2)));\n\tfloat ro = hash(hash1+id.y, idhash)*6.28;\n\tp = (fract(p*scale)-0.5)/scale;\n\tp = erot(p, ax, ro+time*0.7);\n\tp += vec3(hash(hash1,hash2+6.), hash(hash1+5.,hash2), hash(hash2,hash1+3.))*1.;\n\tfloat sphere = length(p)-1.;\n\treturn min(.5,linedist(vec2(p.z, sphere), vec2(-0.1,0.), vec2(0.1,0.))-0.1);\n}\n\nvec3 norm(vec3 p) {\n\tmat3 k = mat3(p,p,p) - mat3(0.01);\n\treturn normalize(scene(p) - vec3(scene(k[0]), scene(k[1]), scene(k[2])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n  uv = erot(vec3(uv,0.), vec3(0,0,1), cos(time*0.5)*0.5).xy;\n  vec3 cam = normalize(vec3(1,uv));\n  vec3 init = vec3(time,0,cos(time*0.4)*2.);\n  cam=erot(cam,vec3(0,1,0),cos(time/8.)*0.3);\n  cam=erot(cam,vec3(0,0,1),time/4.);\n  vec3 p = init;\n  bool hit = false;\n  for (int i = 0; i< 100; i++) {\n  \tfloat dist = scene(p);\n  \tif (dist*dist < 0.00001) { hit = true; break; }\n  \tif (distance(p,init)>30.) break;\n  \tp+=cam*dist;\n  }\n\n  uv *=32.;\n  uv += vec2(sin(time*1.), cos(time*1.5))*2.;\n  //uv = erot(vec3(uv,0.), vec3(0,0,1), cos(time*0.5)*0.5).xy;\n\n  fragColor = cos(uv.y)*cos(uv.x) < 0. ? vec4(0.2,0.5,0.9,1.) : vec4(0.);\n  if (hit) {\n  \tvec3 n = norm(p);\n  \tvec3 rf = reflect(cam, n);\n    float shadow = scene(p+rf) + .5;\n  \tfloat factor = shadow*length(sin(rf*3.)*0.5+0.5)/sqrt(2.);\n  \tvec3 col = mix(vec3(0.3,0.25,0.1), vec3(0.8,0.6,0.2), factor) + pow(factor*0.8, 6.);\n    fragColor.xyz = mix(col, fragColor.xyz, pow(distance(p, init)/30., 50.));\n  }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td2yWh.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[214, 214, 252, 252, 313], [315, 315, 355, 355, 446], [448, 448, 478, 478, 558], [560, 560, 582, 582, 1143], [1145, 1145, 1164, 1164, 1277], [1279, 1279, 1336, 1336, 2354]], "test": "valid"}
{"id": "td2yWR", "name": "Shader 01 : Shapes", "author": "Melokey", "description": "First Shader :D", "tags": ["circle", "square", "rectangle", "shape"], "likes": 0, "viewed": 81, "published": "Public", "date": "1586457962", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14\n\nfloat circle( vec2 coord, float radius )\n{\n    return step(radius, length(coord));\n}\n\nfloat smoothcircle( vec2 coord, float radius, float blur )\n{\n    return smoothstep(radius*(1.-blur), radius*(1.+blur), length(coord));\n}\n\nfloat rect( vec2 coord, vec2 size )\n{\n    vec2 rect = step(abs(coord), size);\n    return 1. - rect.x * rect.y;\n}\n\nmat2 rotate2d(float angle)\n{\n    return mat2(cos(angle),-sin(angle),sin(angle),cos(angle));\n}\n\nfloat rays(vec2 uv, float nbr)\n{\n\tuv = uv * rotate2d(iTime * 0.5);\n\tfloat propeller = cos(atan(uv.y, uv.x) * nbr);\n    return smoothstep(0., 0.1, propeller);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // - Normalize Coordinate -\n    vec2 uv = -(2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n    // - Set Background - \n    vec3 col = vec3(1.);\n\n    // - Useful Functions -\n    //col = vec3( length(uv) );\t\t\t\t\t\t\t\t\t// length(coord)\n    //col = vec3( step(uv.x + 0.5, sin(iTime)) );\t\t\t\t// step(edge, source_value) => if (source_value > edge)\n    //col = vec3( smoothstep(uv.x-0.2, uv.x+0.2, sin(iTime)) );\t// step(lower_edge, upper_edge, source_value)\n    \n    // - Add Shapes -\n    \n    //Coords\n    vec2 pos = uv + vec2(0.);\n    \n    //pos = uv + vec2(-0.8, 0.5);\n    //col *= vec3( circle(pos, 0.3) );\n    \n    // Rays\n    col.z = rays(uv, 10.);\n    \n    // Head\n    pos = uv + vec2(0.);\n    col *= vec3( smoothcircle(pos, 0.98, 0.005) );\n    col += 1. - vec3( smoothcircle(pos, .88, 0.005) );\n    \n    // Eyes\n    pos = uv * vec2(1.2, 1.) + vec2(0. + 0.05 * cos(4.*iTime), 0.43 + 0.05 * sin(4.*iTime));\n    vec2 new_pos = vec2(0.);\n    float delta = 0.5;\n    \n    // Eye Left\n    new_pos = pos + vec2(delta, 0.);\n    col *= vec3( smoothcircle(new_pos, 0.3, 0.01) );\n    col += 1. - vec3( smoothcircle(new_pos, 0.23, 0.01) );\n    \n    new_pos += 0.15 * vec2(cos(iTime), sin(iTime));\n    col *= vec3( smoothcircle(new_pos, 0.1, 0.01) );\n    \n    \n    // Eye Right\n    new_pos = pos + vec2(-delta, 0.);\n    col *= vec3( smoothcircle(new_pos, 0.3, 0.01) );\n    col += 1. - vec3( smoothcircle(new_pos, 0.23, 0.01) );\n    \n    new_pos += 0.15 * vec2(cos(-iTime + PI), sin(-iTime + PI));\n    col *= vec3( smoothcircle(new_pos, 0.1, 0.01) );\n    \n    // Nose\n    pos = uv + vec2(0., -0.05);\n    col *= vec3( rect(pos, vec2(0.05, 0.2)) );\n    col *= vec3( rect(pos, vec2(0.2, 0.05)) );\n    \n    // Mouth\n    pos = uv + vec2(0., -0.45 + 0.05*cos(2.*iTime));\n    col *= vec3( rect(pos, vec2(0.2, 0.05)) );\n    \n    pos = uv + vec2(0., -0.65 + 0.05*sin(2.*iTime));\n    col *= vec3( rect(pos, vec2(0.2, 0.05)) );\n\n    // - Output -\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td2yWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 17, 59, 59, 101], [103, 103, 163, 163, 239], [241, 241, 278, 278, 353], [355, 355, 383, 383, 448], [450, 450, 482, 482, 609], [611, 611, 668, 700, 2633]], "test": "valid"}
{"id": "td2yWy", "name": "♫ Loss of Containment", "author": "SomeGuy", "description": "A random assortment of procedurally generated gelatinous micro- (or maybe nano-) organisms.\nI started out by playing around with blobby KIFS fractals, then got sucked into translucency and glow. At some point, things went a bit techno. Apologies for that.", "tags": ["raymarching", "music", "lifeforms"], "likes": 15, "viewed": 200, "published": "Public", "date": "1587657287", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nAuthor:  https://www.shadertoy.com/user/SomeGuy\nLicense: Creative Commons Attribution-NonCommercial 3.0 Unported License\n\t     https://creativecommons.org/licenses/by-nc/3.0\n\n\nThere was a power system alert last night during \nthe solar flux event. The logs for the containment\nfield generators show a series of short duration\npower fluctuations just after midnight.\n\nWhile heading to the generator array in order to \nvisually inspect it for damage, I noticed a small \npool of oily fluid near the exhaust vent of \ncontainment building three. The fluid was stinking,\na sour odour like putrid meat, overlayed with the \nsweet, pear-like fragrance of ethyl esters.\n\nI took a sample back to the lab for closer examination.\nBy the time I had walked the short distance back to \nbuilding one, the boro-silicate tube that I was \ntransporting the sample in had begun to soften and \nbecome slightly soft and gelatinous.\n\nI transferred a droplet of the sample to an observation\nslide, and loaded it into the high-frequency Higgs \nTunnelling Nanoscope (TM) for closer examination.\nThe Higgs has been glitchy recently, and I have \nstruggled to get stable images from it. Today the \npicture was stable enough for me to record the footage\nthat you are about to see.\n*/\n\n#define MS 50\t\t\t// max steps\n#define MD 30.          // max distance\n#define SD .001         // surface distance threshold\n#define EP .05          // offset for gradient normal\n\n#define GLITCH\t\t    // enable glitchy effects?\n#define WAIT_SYNC       // wait for sound to load before advancing time\n\n#define SND_BPM 150.         // beats per minute\n#define SND_BPS SND_BPM/60.  // beats per second\n#define SND_OFS 0.            // offset\n\n\nfloat PI = acos(-1.);   // PI!\n\nfloat o1=0., o2=0., o3=0.; // orgone accumulators\nvec3 oc1;                  // base color that gets used in multiple places\n\nfloat time;\n\n//----------------------------------------------\n// SDFs\n//----------------------------------------------\nfloat sph(vec3 p, float r) {return length(p)-r;}\t// sphere\n\nfloat cyl(vec2 p, float r) {return length(p)-r;}    // cylinder\n\n//----------------------------------------------\n// utility functions\n//----------------------------------------------\nvoid rot(inout vec2 p, float a) { // 2d rotation\n  \tfloat c=cos(a), s=sin(a);\n  \tp *= mat2(c,-s,s,c);\n}\n\nfloat rnd(float a) { // hash a single float\n  \treturn fract(sin(a * 58.9199) * 4533.9863);\n}\n\nfloat rnd(vec2 p) {// hash 2 floats\n    return fract(sin(dot(p, vec2(44.1885, 28.1643)))*4689.19966);\n}\n\nfloat curve(float a, float b) { // interpolation between random values (thanks Nusan)\n  \tfloat k = a / b;\n  \treturn mix(rnd(floor(k)), rnd(floor(k)+1.), pow(smoothstep(0.,1.,fract(k)), 12.));\n}\n\nfloat smin(float a, float b, float h) { // smooth minimun\n  \tfloat k = clamp((a-b)/h*.5+.5,0.,1.);\n  \treturn mix(a,b,k)-h*k*(1.-k);\n}\n\n//----------------------------------------------\n// Creature definition\n//----------------------------------------------\nstruct thing {\n    float rn;\n    float blobpos;\n    float blobsize;\n    int reps;\n    vec2 offs;\n    vec3 rots;\n    float scale;\n    float squishy;\n    float tt;\n};\n\n//----------------------------------------------\n// The scene\n//----------------------------------------------    \nfloat prim(vec3 p, thing th) { // The creature building block: a blob and a tentacle\n  \tp.z += sin(p.y+th.tt*4.)*.2; // some time based oscillation\n  \tp.x += cos(p.z+th.tt*3.)*.2;\n  \tp.y += cos(p.x+p.z+th.tt*3.5)*.1;\n  \n    // noise lookup from texture\n  \tvec3 np = p / 5.;\n    float n = (texture(iChannel0, np.xy).r + texture(iChannel0, np.xz).r + texture(iChannel0, np.yz).r)/3.;\n  \tn = n * .1 - .05;\n    \n    float a = cyl(p.xz,cos(p.y/4.)*.1+n);               // main tentacle piece\n  \ta = smin(a, sph(p, 9.), -3.);                       // clamp it, trying to keep the end pointy\n  \n  \tfloat b = sph(p-vec3(0.,th.blobpos,0.),th.blobsize+n);  // spherical blob part \n    b = abs(b) - .1 * th.blobsize;                          // onion trick to make it hollow\n    \n    float d = smin(a, b, th.squishy);  // merge the blob and the tentacle together\n    \n    d *= .8; // avoid artifacts due to distorted geometry\n    \n    o1 += .1 / (.1 + a*a*10.); // glow from tentacle\n    o2 += .1 / (.1 + b*b*10.); // glow from blob\n\n    return d;\n}\n\n    \nfloat map(vec3 p) {\n  \n    // set up a random creature\n  \tthing th;\n    th.tt = time / 2.;                                // creature pulsates at this rate\n    th.rn = rnd(floor(time / 16.));                   // pick a new creature every 16 beats\n    if(time > 224. && time < 300.) th.rn = rnd(228.); // but keep it fixed during the breakdown\n    if(time > 300.) th.rn = rnd(floor(time / 4.));    // then pick a creature every 4 beats when we come back up\n    \n    th.blobpos = mix(0.,3., th.rn);                   // position of the blob on the tentacle\n    th.blobsize=mix(.3, 2., th.rn);                   // size of the blob\n    \n    // number of fractal repetitions - between 2 and 4 for the first part of the tune,\n    // but more complex (between 3 and 4) following the breakdown\n    th.reps = time < 16. ? 0 : time > 300. ? int(mix(3.,4.,th.rn+.1)) : int(mix(2.,4.,th.rn+.1));\n    th.offs = mix(vec2(.4), vec2(.8), th.rn); // position offset\n    \n    \n    th.rots = vec3(// rotations around x,y and z axes\n        mix(-PI/2.,PI/2.,rnd(th.rn+1.)), \n        mix(-PI,PI, rnd(th.rn+2.)), \n        mix(-PI/2.,-PI/2., rnd(th.rn+3.)));\n    \n    th.scale = mix(1.1, 1.5, th.rn);      // scale reduction per iteration\n    th.squishy=mix(.1, 1.5, th.rn);       // squishiness (tightness of the smooth minimum function)\n    \n    oc1 = vec3(.1,.9,.1); \t\t\t \t  // base color for tentacles\n    rot(oc1.xy, mix(-PI/2.,PI/2.,th.rn)); // modify it based on random id\n    oc1 = max(vec3(0.), oc1);             // don't let it go negative\n    \n    if (time < 224. || time >300.)        // oscillate rotation except during the breakdown\n  \t\trot(p.xz, sin(time));\n      \n  \tfloat d = 9999.;                      // distance to the creature\n  \tvec4 fp = vec4(p,1);                  // trick to track scale during fractal iterations (stole it from Evvvvil)\n  \tfloat s = 1.;                         // initial scale\n  \tfor(int i=0; i<5; ++i) {              // using a fixed loop size but bailing early for older WebGL compatability\n        if (i == th.reps) break;\n    \tfp *= s;\t\t\t\t\t\t  // apply the scale\n    \ts *= th.scale;                    // change the scale to be used next iteration\n    \n    \tfp.xz = abs(fp.xz) - th.offs;     // absolute symmetry with offset\n    \trot(fp.yz, th.rots.x*s);          // apply the rotations\n        rot(fp.xz, th.rots.y*s);\n    \trot(fp.xy, th.rots.z*s);\n    \n    \td = min(d, (prim(fp.xyz, th) / fp.w)); // make a tentacle\n  \t}\n    \n  \td = th.reps == 0 ? prim(fp.xyz, th) : d; // draw a single tentacle if the loop was skipped\n   \n    float sw = mix(d-.2, d-10., pow(fract(time / 4.),2.));  // shockwave position\n    o3 += (.1 / (.1 + sw * sw * 1000.));                         // shockwave glow\n    \n  \treturn d;\n}\n\n\n//----------------------------------------------\n// The marching machinery \n//----------------------------------------------\nvec3 normal(vec3 p) { // gradient normal\n  \tvec2 off = vec2(EP,0.);\n  \treturn normalize(map(p) - vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n}\n\n\nvec3 march(vec3 ro, vec3 rd) {\n    // main ray marching loop\n  \tfloat dd=0.1;\n  \tvec3 col=vec3(0), // color\n         p=ro+rd*dd;  // position\n  \tfloat side = sign(map(p)); // Nusan's translucency trick\n    float att = 1.;   // attenuation\n    for(int i=0; i<MS; ++i) {\n    \tfloat d = map(p);\n    \td *= side;\n        float atten = att;\n        float diff = 0.; // base 'surface' color\n        float frez = 0.; // freznel\n        if(d < SD) {\n            // close enough to an object to notice\n      \t\tvec3 n = normal(p)*side;\n            side = -side;\n            rd = refract(rd, n, 1. + .05*side); // do some refraction\n      \t\td = .01; // step away for next iteration\n            att *= .4;\n            diff = .1;\n            frez = .2*pow(max(.5, 1.-dot(n, -rd)), 3.);\n    \t}\n    \tif(dd > MD) { // falling of the edge of the world\n      \t\tdd = MD;\n      \t\tbreak;\n    \t}\n        \n        \n        // color based on the accumulated orgones\n        // oc1 is random for each creature. \n        // oc2 and oc3 are calculated from oc1\n    \tvec3 oc2 = 1. - oc1;\n    \tvec3 oc3 = normalize(o1 * oc1 + o2 * oc2);\n    \n        float dst = exp(-.0001*dd*dd*dd); // some fog\n     \n        // apply the colors and surface\n        #define c(x,y) x*atten*dst*y\n        vec3 c1 = oc1*o1, c2 = oc2*o2, c3=oc3*o3;\n    \tcol += c(c1, diff*frez) +  c(c1, .01); \n    \tcol += c(c2, diff*frez) + c(c2, .001);\n    \tcol += c(c3, .1) * float(time > 16. && (time < 227.|| time >288.)); // no shock wave initially or during breakdown \n        \n        // distance and pos for next iteration\n    \tp += rd * d;\n    \tdd += d;\n  \t}\n  \n  \treturn col;\n}\n\n\nvec3 raydir(vec3 ro, vec3 la, vec2 uv) {\n\t// construct a ray\n    vec3 cz = normalize(la-ro),\n  \tcx = normalize(cross(cz, vec3(0,1,0))),\n  \tcy=normalize(cross(cx,cz));\n  \treturn normalize(cx*uv.x + cy*uv.y + cz);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    time = (iTime * SND_BPS) - SND_OFS; // convert time to beats\n    \n#ifdef WAIT_SYNC\n    // don't advance the timeline if the soundtrack hasn't loaded.\n    // Doing a texture lookup for this is a bit expensive, but I \n    // can't figure out another way to check for this\n    if (texture( iChannel1, vec2(.1, 0.) ).x == 0.)\n        time = mod(time, 16.);\n#endif\n    \n    // camera position\n    vec3 cam;\n    if (time > 224. && time <300.) { // simple rotate during the breakdown\n        //cam = vec3(0.,2., 5. * sin(time / 4.));\n        cam = vec3(1.,2.,5.);\n        rot(cam.xz, time/4.);\n    }\n    else { // otherwise, do some random zooming and rotating\n        cam = vec3(\n        \tmix(-4.,4.,curve(time,3.)),\n        \tmix(-4.,4., curve(time-3.,3.)),\n        \tmix(3.,8.,curve(time+2.,3.))\n    \t)*2.5;\n    }\n\t\n    vec2 ouv = uv;\n#ifdef GLITCH\n    float glitch = curve(time,.5);\n    glitch = smoothstep(.9, 1., glitch);\n    uv.x += sin(uv.y*100.+time*glitch*100.)*glitch * max(0., .2-uv.y*uv.y); // sin wave glitch\n    uv += mix(vec2(0), uv * (rnd(uv + time)-.5), smoothstep(.95, 1., curve(time,.1))*.5); // noisy fuzz glitch\n#endif\n    \n    // set up the ray\n\tvec3 ro=cam, la=vec3(0), rd=raydir(ro,la,uv);\n    \n    // clear to black\n  \tvec3 col = vec3(0.);\n    \n    // raymarch\n  \tcol += march(ro, rd);\n  \n    // vignette\n    col *= 1. - length(uv);\n    \n    // exposure\n    col = vec3(1.) - exp(-col*1.5);\n       \n\t// gamma\n    col = pow(col, vec3(1./2.2));\n\n    // final color\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}, {"id": "Mtj3DW", "previewfilepath": "https://soundcloud.com/ed_e_t_uk/ed-et-dtr-vs-mcp-biological-weapon", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/ed_e_t_uk/ed-et-dtr-vs-mcp-biological-weapon", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td2yWy.jpg", "access": "shaders20k", "license": "cc-by-3.0", "functions": [[1865, 1971, 1999, 1999, 2019], [2031, 2031, 2059, 2059, 2079], [2096, 2215, 2248, 2263, 2318], [2320, 2320, 2340, 2363, 2412], [2414, 2414, 2433, 2449, 2517], [2519, 2519, 2550, 2604, 2712], [2714, 2714, 2753, 2771, 2847], [3136, 3251, 3281, 3335, 4289], [4296, 4296, 4315, 4350, 7032], [7035, 7160, 7181, 7200, 7313], [7316, 7316, 7346, 7376, 8937], [8940, 8940, 8980, 9000, 9153], [9157, 9157, 9214, 9261, 10874]], "test": "error"}
{"id": "td2yzR", "name": "Icecream warped FBM", "author": "mrange", "description": "License: CC0\nResult after playing around with warped FBMs for a few hours\nBased on: https://iquilezles.org/www/articles/warp/warp.htm\n", "tags": ["2d", "fbm", "warp"], "likes": 8, "viewed": 246, "published": "Public API", "date": "1586007627", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License: CC0\n//   Result after playing around with warped FBMs for a few hours\n//   Based on: https://iquilezles.org/www/articles/warp/warp.htm\n\n#define PI    3.141592654\n#define TAU   (2.0*PI)\n#define TTIME (iTime*TAU)\n\nconst mat2 frot = mat2(0.80, 0.60, -0.60, 0.80);\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nfloat noise(vec2 p) {\n  float a = sin(p.x);\n  float b = sin(p.y);\n  float c = 0.5 + 0.5*cos(p.x + p.y);\n  float d = mix(a, b, c);\n  return d;\n}\n\nfloat fbm(vec2 p) {    \n  float f = 0.0;\n  float a = 1.0;\n  float s = 0.0;\n  float m = 2.0;\n  for (int x = 0; x < 4; ++x) {\n    f += a*noise(p); p = frot*p*m;\n    m += 0.01;\n    s += a;\n    a *= 0.5;\n  }\n  return f/s;\n}\n\nfloat warp(vec2 p, out vec2 v, out vec2 w) {\n\n  vec2 vx = vec2(0.0, 0.0);\n  vec2 vy = vec2(3.2, 1.3);\n\n  vec2 wx = vec2(1.7, 9.2);\n  vec2 wy = vec2(8.3, 2.8);\n\n  rot(vx, TTIME/1000.0);\n  rot(vy, TTIME/900.0);\n\n  rot(wx, TTIME/800.0);\n  rot(wy, TTIME/700.0);\n\n  v = vec2(fbm(p + vx), fbm(p + vy));\n  \n  w = vec2(fbm(p + 3.0*v + wx), fbm(p + 3.0*v + wy));\n  \n  return fbm(p + 2.25*w);\n}\n\nvec3 normal(vec2 p) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(0.0001, 0);\n  \n  vec3 n;\n  n.x = warp(p + e.xy, v, w) - warp(p - e.xy, v, w);\n  n.y = 2.0*e.x;\n  n.z = warp(p + e.yx, v, w) - warp(p - e.yx, v, w);\n  \n  return normalize(n);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= iResolution.x/iResolution.y;\n\n  p += TTIME*0.01;\n  p *= 2.0;\n  vec3 col = vec3(1.0);\n \n  vec2 v;\n  vec2 w;\n \n  float f = warp(p, v, w);\n  vec3 n = normal(p);\n\n  vec3 lig = normalize(vec3(0., 0.2, -0.4));\n  rot(lig.xy, TTIME/10.0);\n  float dif = max(dot(lig, n), 0.5);\n\n  const vec3 col1 = vec3(0.1, 0.7, 0.8);\n  const vec3 col2 = vec3(0.7, 0.3, 0.5);\n  \n  col = pow(dif, 0.75)*tanh(pow(abs(f + 0.5), 1.5)) + (length(v)*col1 + length(w)*col2);\n\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td2yzR.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[274, 274, 307, 307, 392], [394, 394, 415, 415, 537], [539, 539, 558, 558, 758], [760, 760, 804, 804, 1144], [1146, 1146, 1167, 1167, 1379], [1381, 1381, 1436, 1436, 1983]], "test": "valid"}
{"id": "tdBcDd", "name": "alien forensic noise", "author": "henry", "description": "analyzing heart of algorithm in skaplun's [url]https://shadertoy.com/view/tdsSzs[/url] borrowed from diviaki's [url]https://www.shadertoy.com/view/4t3SWN[/url] , looking like Gabor noise or reaction-diffusion.\nSee first comment below (i.e. downest ).", "tags": ["noise", "texture", "diffusion", "short", "golf", "reaction", "fingerprint", "gabornoise", "ajax"], "likes": 8, "viewed": 143, "published": "Public", "date": "1587510699", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"Gabor-noise / reac-diff like\" by FabriceNeyret2. https://shadertoy.com/view/3slXDf\n// 2020-04-21 23:09:02\n\n// simplified from skaplun's \"AFC Ajax\" https://shadertoy.com/view/tdsSzs\n// borrowing diviaki's \"fingerprint\" https://www.shadertoy.com/view/4t3SWN\n\n#define hash(p) (-1. + 2.* fract(sin( (p) * vec3(63.31,395.467,1) ) *43141.59265) )\n\nvoid mainImage(out vec4 O, vec2 U) {\n    vec2 R = iResolution.xy;\n         U = 5.*sin(iTime*0.34)+35.* (2.*U - R ) / R.y;\n    \n    float a =iTime*20.134 ;\n\n    for(float i=0.; i<200.; i++){\n        vec3 h = sin(iTime*0.34)*40.*hash(i); \n      //h.xy += cos(iTime+vec2(0,11)+h.z*6.28) * vec2(5,1); // animation\n    \ta += sign(h.z) * atan(U.x-h.x, U.y-h.y);\n    }\n\n    O = vec4( .5+.5*sin( 3.14*length(U) +a ) );\n  //O.r = .5+.5*sin(a);                         // display perturbating field\n  //O =vec4(.5+.5*sin( 3.14*length(U) ), .5+.5*sin( 3.14*length(U) +a ) ,0,0);\n  //O = ( .6 + .6 * cos( a + vec4(0,23,21,0)  ) ); // https://www.shadertoy.com/view/ll2cDc\n}\n\n\n\n\n/* // the 190 chars golfed version\n\n#define mainImage(O,u)                             \\\n    vec3 R = iResolution, h;                       \\\n    vec2 U = 45.* ( u+u - R.xy ) / R.y;            \\\n    float a = 0., i = a;                           \\\n    for (; i++ < 1e2;                              \\\n    \t a += sign(h.z) * atan(U.x-h.x, U.y-h.y)   \\\n       ) h = 60.* fract( sin( i * R ) *4e4) - 30.; \\\n    O += .5+.5* sin( 3.*length(U) +a )  /*\n\n/* */", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdBcDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[354, 354, 390, 390, 1015]], "test": "valid"}
{"id": "tdBcWc", "name": "My first shader ever **", "author": "Chico", "description": "My first shader", "tags": ["first"], "likes": 2, "viewed": 40, "published": "Public", "date": "1588200065", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat ChangeRadius(){\n    float r = abs(sin(iTime * 0.5))*0.4 + 0.1;\n    return r;\n}\n\nvec3 ChangeColors(vec2 uv){ \n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)); \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float d = length(uv);\n    float r = ChangeRadius();\n    \n    vec3 c = smoothstep(r, r-0.01,d) * ChangeColors(uv);\n    \n    if(c == vec3(0.0) && uv.x > 0.0)\n        c = vec3(1.0);\n    \n    fragColor = vec4(c, 1.0);\n        \n      \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdBcWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 22, 22, 85], [87, 87, 114, 114, 190], [192, 192, 249, 249, 590]], "test": "valid"}
{"id": "tdBcWz", "name": "RaymarchIsosurface", "author": "Raxmo", "description": "Raymarch rendering of an isosurface. Not entirely sure why I can't get shadows to work, nor why I can't even identify where the light actually is, or change the color of the light, or surfaces at all. But as a proof of concept, it works.", "tags": ["raymarch"], "likes": 3, "viewed": 122, "published": "Public", "date": "1586444416", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAXDIST 100.\n#define SURFDIST 0.001\n#define STEPS 100\n\nvec3 col = vec3(1.);\n\n\nfloat lerp(float a, float b, float t)\n{\n    return ((1. - t) * a) + (t * b);\n}\n\nfloat tlerp(vec4 a, vec4 n, vec3 p)\n{\n    float x1 = lerp(a.x, a.y, p.x);\n    float x2 = lerp(a.z, a.w, p.x);\n    float x3 = lerp(n.x, n.y, p.x);\n    float x4 = lerp(n.z, n.w, p.x);\n    \n    float y1 = lerp(x1, x2, p.y);\n    float y2 = lerp(x3, x4, p.y);\n    \n    return lerp(y1, y2, p.z);\n}\n\nfloat blerp(vec4 s, vec2 p)\n{\n    vec2 q = 1. - p;\n    \n    float v =\n        s.x * q.x * q.y +\n        s.y * p.x * q.y +\n        s.z * q.x * p.y +\n        s.w * p.x * p.y;\n    \n    return v;\n}\n\nfloat derp1 (float a, float b, float t)\n{\n    return lerp(a, b, t) / (a - b);\n}\n\nfloat derp3 (vec4 a, vec4 b, vec3 t)\n{\n    vec3 d;\n    \n    d.z = derp1(blerp(a, t.xy), blerp(b, t.xy), t.z);\n    d.y = derp1(blerp(vec4(a.xy, b.xy), t.xz), blerp(vec4(a.zw, b.zw), t.xz), t.y);\n    d.x = derp1(blerp(vec4(a.xz, b.xz), t.yz), blerp(vec4(a.yw, b.yw), t.yz), t.x);\n    \n    return 1./length(1./d);\n}\n    \nfloat vlerp(vec4 a, vec4 b, vec3 p)\n{\n    // causses tearing in the depth field\n    //p = p * p * (3. - 2. * p);\n    vec3 q = 1. - p; //create a conjugate of the point\n    \n    \n    // yes... this mess is a perfectly valid 3D interpolation.\n    return a.x * p.x * p.y * p.z\n         + a.y * q.x * p.y * p.z\n         + a.z * p.x * q.y * p.z\n         + a.w * q.x * q.y * p.z\n         + b.x * p.x * p.y * q.z\n         + b.y * q.x * p.y * q.z\n         + b.z * p.x * q.y * q.z\n         + b.w * q.x * q.y * q.z;\n}\n\nfloat getdist(vec3 p)\n{\n    vec4 sphere = vec4(0., 1., 6., 1.);\n    \n    \n    \n    float sd = length(p - sphere.xyz) - sphere.w;\n    float pd = p.y + 1.5;\n    \n    //return min(sd, pd);\n    vec4 iso = vec4(0., -0.49, 6., 1.);\n    \n    float time = iTime / 5.;\n    \n    \n    vec4 isovala = vec4(sin(time * 1.1), cos(time * 1.2), -1., -1.);\n    vec4 isovalb = vec4( cos(time * 1.3), sin(time * 1.4),-1., -1.);\n    \n    float isod = 0.;\n    \n    if(any(greaterThanEqual(abs(p - iso.xyz), iso.www)))\n    {\n        isod = length(max(abs(p - iso.xyz) - iso.www, 0.)) + SURFDIST * 1.5;\n        col = vec3(1.);\n    }\n    else\n    {\n        vec3 np = (p - iso.xyz) / (2.0 * iso.w) + 0.5;\n        \n        float bdist = max(-np.x, np.x - 1.);\n        bdist = max(bdist, -np.y);\n        bdist = max(bdist, np.y - 1.);\n        bdist = max(bdist, -np.z);\n        bdist = max(bdist, np.z - 1.);\n        \n        isod = derp3(isovala, isovalb, fract(np));\n        \n        isod = max(isod, bdist);\n        \n        //bit of a hack-job, but this is effectively 3D uv coordinates. so, I suppose they would be uvt coordinates?\n        \n            vec3 uvt = (p - iso.xyz)/(2.0 * iso.w) + 0.5;\n            float res = 64. * 64.;\n            float r3 = pow(res, 1./3.);\n            float r2 = 512.;\n            float r6 = pow(r3, 0.5);\n            \n            //uvt.xyz = uvt.xzy;\n            \n            uvt.xz = uvt.xz / r6;\n            uvt.y = floor(uvt.y * r3);\n            vec2 uvo = vec2(0.);\n            uvo.x = mod(uvt.y, r6) / r6;\n            uvo.y = floor(uvt.y / r6) / r6;\n            \n            \n            vec2 uv = uvt.xz + uvo;\n            \n            //col = uvt;\n            col = texture(iChannel0, uv).xyz;\n            col.y = 1.- col.x;\n            col.z = 0.5;\n    }\n    \n    //return min(sd, pd);\n    \n    //return isod;\n    \n    \n   // if(isod < pd){col.gb *=0.;}\n    return min(isod, pd);\n    //return min(sd, pd);\n}\n\nvec3 getnorm(vec3 p)\n{\n    vec2 e = vec2(0.00001, 0.);\n    float d = (getdist(p));\n    \n    vec3 norm = d - vec3(\n        getdist(p - e.xyy),\n        getdist(p - e.yxy),\n        getdist(p - e.yyx)\n    );\n    \n    \n    \n    return normalize(- norm);\n}\n\nfloat march(vec3 ro, vec3 rd)\n{\n    float d = 0.;\n    float df = MAXDIST;\n    vec3 p = ro + rd * d;\n    \n    for(int i = 0; i < STEPS && d < MAXDIST && df > SURFDIST; i++)\n    {\n        df = getdist(p);\n        d += df;\n        p = ro + rd * d;\n    }\n    \n    return d;\n}\n//vec3 light = vec3(0.);\n    \nfloat lighting(vec3 p)\n{\n    vec3 light = 2. * vec3(cos(iTime), 0., sin(iTime)) + vec3(0., 1.5, 4.);\n    \n    vec3 ldir = normalize(p - light);\n    \n    \n    float dif = clamp(dot(getnorm(p), ldir), 0., 1.);\n    \n    //if(march(p + getnorm(p) * SURFDIST * 2., ldir) < length(light - p)) dif *= 0.1;\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    \n    vec3 ro = vec3(0., 1., 0.);\n    vec3 rd = normalize(vec3(uv, 1.));\n    \n    float d = march(ro, rd);\n    //float d = mod(iTime / 3., 10.);\n    vec3 p = ro + rd * d;\n    \n    vec3 norm = getnorm(p);\n    \n    float lightf = lighting(p);\n    \n    //col = vec3(texture(iChannel0,uv).x);\n    \n    col *= clamp(lighting(p), 0.2, 1.0);\n    \n    //col = vec3(d) / 10.;\n    \n    //col = (norm + 1.) / 2.;\n    \n    //col = p / 20.;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdBcWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[86, 86, 125, 125, 164], [166, 166, 203, 203, 457], [459, 459, 488, 488, 652], [654, 654, 695, 695, 733], [735, 735, 773, 773, 1047], [1053, 1053, 1090, 1165, 1560], [1562, 1562, 1585, 1585, 3489], [3491, 3491, 3513, 3513, 3741], [3743, 3743, 3774, 3774, 4014], [4045, 4045, 4069, 4069, 4366], [4368, 4368, 4425, 4480, 5033]], "test": "error"}
{"id": "tdBczd", "name": "Funny lil sea", "author": "Rondaar", "description": "Just my first lil, shadertoy-made shader. Coolio.", "tags": ["sea"], "likes": 2, "viewed": 215, "published": "Public API", "date": "1587160346", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14\n#define col0 vec4(0.58,0.56,0.66,1.0)\n#define col1 vec4(0.39,0.29,0.4,1.0)\n#define col2 vec4(0.09,0.01,0.05,1.0)\n#define sunCol vec4(0.9,1.0,0.87,1.0)\n\nfloat waveAlpha(vec2 uv, float height, float rate, float amplitude, float xOffset, float yOffset, float yWaveAmount){\n    return step(uv.y-height+sin(iTime + yOffset)*yWaveAmount, (sin(uv.x*PI*rate+ sin(xOffset*iTime))*0.5 + 0.5)*amplitude);\n}\nfloat circleAlpha(vec2 uv, vec2 pos, float radius){\n    uv.y = uv.y*iResolution.y/iResolution.x;\n \treturn step(distance(uv,pos),radius);\n}\nfloat circleAlphaOutline(vec2 uv, vec2 pos, float radius){\n    uv.y = uv.y*iResolution.y/iResolution.x;\n \treturn clamp(1.0-distance(uv,pos)/radius,0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tfloat wave0 = waveAlpha(uv, 0.2, 8.0, 0.15, 0.25, 0.0, 0.01);\n\tfloat wave1 = waveAlpha(uv, 0.1, 8.0, 0.15, -0.5, 0.1, 0.025);\n    float wave2 = waveAlpha(uv, 0.0, 8.0, 0.15, 0.5, 0.2, 0.03);\n\tfloat circle = circleAlpha(uv, vec2(0.75,0.4), 0.1);\n    float circleOutline = circleAlphaOutline(uv, vec2(0.75,0.4), 0.4);\n    vec4 col = vec4(0.73,0.8, 0.8, 1.0);\n    col = mix(col,col0,wave0);\n    col = mix(col,col1, wave1);\n    col = mix(col,col2, wave2);\n    col = mix(col, sunCol, circle);\n    col = mix(col, sunCol, circleOutline);\n    //col += vec4(circleOutline);\n    // Output to screen\n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdBczd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[168, 168, 285, 285, 411], [412, 412, 463, 463, 550], [551, 551, 609, 609, 709], [711, 711, 768, 818, 1471]], "test": "valid"}
{"id": "tdBczm", "name": "incomplete circle experiment", "author": "benhardy", "description": "just circles and stuff, using the kind of min/max distance functions used in raymarching to perform csg in 2d.\n\nridiculous overkill on the antialiasing.", "tags": ["2d", "geometry"], "likes": 3, "viewed": 199, "published": "Public API", "date": "1586345911", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circle(vec2 pos, vec2 centre, float radius) {\n\n\treturn length(pos - centre) - radius;\n}\n\nfloat edge(float dist, float thickness) {\n    return abs(dist) - thickness;\n}\n\n#define ID_LEFT 1.0\n#define ID_MIDDLE 2.0\n#define ID_RIGHT 3.0\n\nvec2 measure(vec2 uv )\n{ \n    vec3 col = vec3(0);\n    vec2 center = vec2(0);\n    float rad = 0.25;\n    float thicc = 0.005;\n    vec2 movingCentre = 0.125 * vec2( sin(iTime), cos(iTime*1.1));\n    \n    // the red one\n\tfloat c1 = circle(uv, vec2(-0.25, 0), 0.252);\n    // the blue one\n\tfloat c4 = circle(uv, vec2(0.25, 0), 0.252);\n    // the green one\n    float c3 = circle(uv, movingCentre, 0.202);\n    // the hole around the green one\n    float hole = circle(uv, movingCentre, 0.252);\n\n    float left = max(c1, -hole);\n    if (left <= 0.0) {\n        return vec2(left, ID_LEFT);\n    }\n    \n    float right = max(c4, -hole);\n    if (right <= 0.0) {\n        return vec2(right, ID_RIGHT);\n    }\n    if (c3 <= 0.0) {\n        return vec2(c3, ID_MIDDLE);\n    }\n}\n\n#define THICC 0.005\n#define NORM_DELTA 0.00001\n\nvec3 trace(vec2 uv) {\n    vec2 di = measure(uv);\n    vec2 dx = measure(uv + vec2(-NORM_DELTA, 0));\n    vec2 dy = measure(uv + vec2(0, -NORM_DELTA));\n    vec2 dx2 = measure(uv + vec2(NORM_DELTA, 0));\n    vec2 dy2 = measure(uv + vec2(0, NORM_DELTA));\n    vec2 normal = normalize(vec2(dx2.x - dx.x, dy2.x - dy.x));\n    vec2 toLight = normalize(vec2(-0.5, 1.0));\n    float lightD = dot(normal, toLight);\n    vec3 lighting =  vec3(lightD, lightD, lightD);\n    vec3 col = vec3(0);\n    \n    if (di.y == ID_LEFT) {\n        if (di.x < -THICC) {\n            float m = fract(di.x*50.0);\n            col = vec3(0.5,0.1,0.1);\n            if (m < 0.15) {\n                col *= 0.7;\n            }\n        } else {\n            col = vec3(1,1,1);\n        }\n    }\n    \n    if (di.y == ID_RIGHT) {\n        if (di.x < -THICC) {\n            float m = fract(di.x*50.0);\n            col = vec3(0.1,0.1,0.5);\n            if (m < 0.15) {\n                col *= 0.7;\n            }\n        } else {\n            col = vec3(1,1,1);\n        }\n    }\n    \n    if (di.y == ID_MIDDLE) {\n        if (di.x < -THICC) {\n            float m = fract(di.x*50.0);\n            col = vec3(0.1,0.5,0.1);\n            if (m < 0.15) {\n                col *= 0.7;\n            }\n        } else {\n            col = vec3(1,1,1);\n        }\n    }\n    \n    if (di.x < -THICC && di.y > 0.0) {\n        float ratio = cos(di.x * 10.0);\n\t\tcol += lighting * 0.5 * ratio;\n    }\n    return clamp(col, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    float aspect = iResolution.y / iResolution.x;\n    \n    \n    vec3 col = vec3(0);\n    for (int i=-2; i <= 2; i++) {\n        float dx = 0.20 * float(i);\n\t    for (int j = -2; j <= 2; j++) {\n            float dy = 0.20 * float(j);\n            vec2 subpixel = fragCoord+vec2(dx,dy);\n\t\t    vec2 uv = (subpixel/iResolution.xy-vec2(0.5)) \n                * vec2(1, aspect);\n            col += trace(uv);\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(col / 25.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdBczm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 51, 51, 93], [95, 95, 136, 136, 172], [238, 238, 262, 262, 992], [1042, 1042, 1063, 1063, 2493], [2495, 2495, 2552, 2552, 3035]], "test": "error"}
{"id": "tdByR3", "name": "Concentricity", "author": "mla", "description": "Concentric spheres, inspired by [url]https://www.shadertoy.com/view/wd2cWW[/url] by ZiMMaBuE.\n\nMouse moves things around, eg. changes the lighting and the lurid background.", "tags": ["escher", "concentric", "octahedral", "rinds"], "likes": 4, "viewed": 271, "published": "Public API", "date": "1587071271", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Concentricity\n// Matthew Arcus, mla, 2020\n//\n// Octahedral symmetry again.\n//\n// Inspired by: https://www.shadertoy.com/view/wd2cWW\n//\n// Nested spherical disdyakis dodecahedrons (this is actually what they are\n// called: https://en.wikipedia.org/wiki/Disdyakis_dodecahedron)\n//\n////////////////////////////////////////////////////////////////////////////////\n\nint AA = 1; // Set to 2 for quality\n\nvec3 light = vec3(0,-2,1); // Position of light\nfloat eradius = 0.03; // Thickness of an edge\nfloat eyedist = 2.5;  // Eye is at (0,0,eyedist);\nfloat PI = 3.1415927; \n\n// Raymarching configuration.\nint maxsteps = 100;\nfloat precis = 1e-3; \n\nbool dorotate = false;\n\n// Find the distance to a spherical segment, encapsulated in m.\n// m maps p to nearest point in some subspace (ie. a plane).\nfloat ssegment(vec3 p, mat3 m) {\n  vec3 p1 = normalize(m*p);\n  // And return the 'distance' to the closest point.\n  float len = length(p);\n  float x = distance(p/len,p1);    // Distance on surface\n  float y = len-1.0; // Radial distance\n  return max(x,abs(y))-eradius;\n}\n\n// Matrix for segment through q and r - take a point p,\n// Use q and r as basis vectors for subspace, so first\n// take dot products with q and r, then map to coordinates\n// in that basis (matrix m), then map back to R3. This is\n// then the nearest point to p in the subspace.\n// Assumes q and r normalized\nmat3 mkmatrix(vec3 q, vec3 r) {\n  mat2 m = inverse(mat2(1,dot(q,r),dot(q,r),1));\n  return mat2x3(q,r)*m*transpose(mat2x3(q,r));\n}\n\nmat3 m0,m1,m2;\nvec4 q0,q1,q2,qbg,qlight;\n\nvoid init() {\n  vec3 A = vec3(1,0,0);\n  vec3 B = vec3(0,1,0);\n  vec3 C = vec3(0,0,1);\n  // The midpoints of the sides, named for opposites\n  vec3 A1 = normalize(0.5*(B+C));\n  vec3 B1 = normalize(0.5*(C+A));\n  vec3 C1 = normalize(0.5*(A+B));\n  m0 = mkmatrix(A,B);\n  m1 = mkmatrix(A,A1);\n  m2 = mkmatrix(C,C1);\n\n  float t = 0.1*iTime;\n  q0 = vec4(sin(t)*normalize(vec3(1,1,0)),cos(t));\n  q1 = vec4(sin(t)*normalize(-vec3(1,1,1)),cos(t));\n  q2 = vec4(sin(t)*normalize(vec3(0,1,1)),cos(t));\n  qbg = vec4(sin(t)*normalize(vec3(1,0,1)),cos(t));\n  qlight = vec4(sin(t)*normalize(vec3(0,1,0.5)),cos(t));\n}\n\nfloat de0(vec3 p, float k) {\n  p *= k;\n  p = abs(p); // Map to single face - skip this to see single face.\n  // Sort the coordinates to map to fundamental region.\n  if (p.x < p.y) p.xy = p.yx;\n  if (p.y < p.z) p.yz = p.zy;\n  if (p.x < p.y) p.xy = p.yx;\n\n  float d = 1e8;\n  d = min(d,ssegment(p,m0));\n  d = min(d,ssegment(p,m1));\n  d = min(d,ssegment(p,m2));\n  return d/k;\n}\n\n// Quaternion multiplication\nvec4 qmul(vec4 p, vec4 q) {\n  vec3 P = p.xyz, Q = q.xyz;\n  return vec4(p.w*Q+q.w*P+cross(P,Q),p.w*q.w-dot(P,Q));\n}\n\nvec4 qconj(vec4 p) {\n  return vec4(-p.xyz,p.w);\n}\n\n// Might be better to turn into a matrix.\nvec3 qrot(vec3 p, vec4 q) {\n  vec4 r = qmul(qconj(q),qmul(vec4(p,0),q));\n  return r.xyz;\n}\n\nfloat de(vec3 p) {\n  float d = 1e8;\n  float k = 1.2;\n  d = min(d,de0(qrot(p,q0),k));\n  d = min(d,de0(qrot(p,q1),1.0));\n  d = min(d,de0(qrot(p,q2),1.0/k));\n  return d;\n}\n\n// Get the normal of the surface at point p.\nvec3 getnormal(vec3 p) {\n  float eps = 0.001;\n  vec2 e = vec2(eps,0);\n  return normalize(vec3(de(p + e.xyy) - de(p - e.xyy),\n                        de(p + e.yxy) - de(p - e.yxy),\n                        de(p + e.yyx) - de(p - e.yyx)));\n}\n\n// Rotate vector p by angle t.\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n\n// Rotate according to mouse position\nvec3 transformframe(vec3 p) {\n  if (iMouse.x > 0.0) {\n    // Full range of rotation across the screen.\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  // autorotation\n  if (dorotate) {\n    p.yz = rotate(p.yz,-iTime*0.125);\n    p.zx = rotate(p.zx,iTime*0.1);\n  }\n  return p;\n}\n\nvec3 getbasecolor(int type) {\n  return vec3(0.75,1,0.75);\n}\n\nvec3 getbackground(vec3 r) {\n  vec3 col = qrot(r,qbg);\n  col = abs(col);\n  col = pow(col,vec3(1.5));\n  return col; // Colourful fun\n  return vec3(0,0,0.1); // The more sober option.\n}\n\nfloat maxdist = 10.0;\nfloat march(vec3 q, vec3 r) {\n  float t = 0.0;\n  for (int i = 0; i < maxsteps; i++) {\n    vec3 p = q+t*r;\n    float d = de(p);\n    if (abs(d) < precis) return t; // Close enough to the surface.\n    t += d;\n    if (t > maxdist) break;\n  }\n  return -1.0;\n}\n\nvec3 raycolor(vec3 q, vec3 r) {\n  float t = march(q,r);\n  if (t < 0.0) return getbackground(r);\n  // Get the surface point that has been hit,\n  vec3 p = q+t*r;\n  // and the normal at that point.\n  vec3 normal = getnormal(p);\n  if (dot(normal,r) > 0.0) normal = vec3(0);\n  \n  // Apply lighting. This is a basic \"Lambertian\" model.\n  vec3 lightdir = normalize(light-p);\n  vec3 color = getbasecolor(0);\n  float ambient = 0.3;\n  float diffuse = 0.7*clamp(dot(normal,lightdir),0.0,1.0);\n  color *= ambient+ diffuse;\n  color = mix(color,getbackground(r),t/maxdist); // Fog\n  return color;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n  init();\n  maxdist = eyedist + 1.0;\n  vec3 eye = vec3(0,0,eyedist);\n  eye = transformframe(eye);\n  light = qrot(light,qlight);\n  light = transformframe(light);\n  vec3 col = vec3(0);\n  for (int i = 0; i < AA; i++) {\n    for (int j = 0; j < AA; j++) {\n      vec2 z = (2.0*(fragCoord+vec2(i,j)/float(AA))-iResolution.xy)/iResolution.y;\n      vec3 ray = vec3(z,-2);\n      ray = transformframe(ray);\n      ray = normalize(ray);\n      col += raycolor(eye,ray);\n    }\n  }\n  col /= float(AA*AA);\n  col = pow(col,vec3(0.4545)); // Gamma\n  fragColor = vec4(col,1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdByR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[750, 875, 907, 907, 1145], [1147, 1453, 1484, 1484, 1582], [1626, 1626, 1639, 1639, 2223], [2225, 2225, 2253, 2253, 2598], [2600, 2629, 2656, 2656, 2743], [2745, 2745, 2765, 2765, 2794], [2796, 2838, 2865, 2865, 2928], [2930, 2930, 2948, 2948, 3098], [3100, 3145, 3169, 3169, 3383], [3385, 3416, 3446, 3446, 3491], [3493, 3531, 3560, 3560, 3953], [3955, 3955, 3984, 3984, 4014], [4016, 4016, 4044, 4044, 4199], [4223, 4223, 4252, 4252, 4477], [4479, 4479, 4510, 4510, 5063], [5065, 5065, 5116, 5116, 5674]], "test": "error"}
{"id": "tdByz3", "name": "hindsight - edited", "author": "Nedelstein", "description": "hindsight sketch. 99% credit goes to https://www.shadertoy.com/view/td2yRG\n", "tags": ["noise", "blob", "gradent"], "likes": 8, "viewed": 110, "published": "Public", "date": "1587047930", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//edited version of https://www.shadertoy.com/view/td2yRG\n\n\nfloat random1f(vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat map(float v, float a, float b, float c, float d) {\n    float nv = (v - a) / (b - a);\n    nv = pow(nv, 3.0);\n    float o = nv * (d - c) + c;\n    \n    return o;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.y /= iResolution.x / iResolution.y;\n    \n    \n     vec2 A=vec2(-.5,-.2);\n    vec2 B=vec2(.5,-.2);\n    vec2 C=vec2(0,.5);\n    vec2 D=vec2(.5,-.8);\n    vec2 E=vec2(.9,.79);\n    \n    float k1=.7;// size\n    float k2=3.;// shape\n    \n    // warp domains\n    vec2 uvA=uv*vec2(.69,.8);\n    uvA.x+=sin(uv.y*5.+ iTime)*.1;\n    vec2 uvB=uv*vec2(.7,.4);\n    uvB.x+=sin(uv.y*4.+ iTime)*.1;\n    vec2 uvC=uv*vec2(.6,.8);\n    uvC.y+=sin(uv.x*4.+ iTime)*.1;\n    vec2 uvD=uv*vec2(.2,.8);\n    uvD.y+=sin(uv.x*4.+ iTime)*.1;\n    vec2 uvE=uv*vec2(-1.1,.9);\n    uvE.x+=sin(uv.y*4.+ iTime)*.1;\n    \n    // create shaped gradient\n    float dA=max(0.,1.-pow(distance(uvA,A)/k1,k2));\n    float dB=max(0.,1.-pow(distance(uvB,B)/k1,k2));\n    float dC=max(0.,1.-pow(distance(uvC,C)/k1,k2));\n    float dD=max(0.,1.-pow(distance(uvD,D)/k1,k2));\n    float dE=max(0.,1.-pow(distance(uvE,E)/k1,k2));\n    \n     // smooth in, out\n    dA=smoothstep(0.,1.,dA);\n    dB=smoothstep(0.,1.,dB);\n    dC=smoothstep(0.,1.,dC);\n    dD=smoothstep(0.,1.,dD);\n    dE=smoothstep(0.,1.,dE);\n    \n    // define colors\n    \n    vec3 blue=vec3(35.,122.,144.)/255.;\n    vec3 pink=vec3(255.,122.,114.)/255.;\n    vec3 green=vec3(44.,162.,148.)/255.;\n    vec3 black=vec3(20.,10.,0.)/255.;\n    vec3 orange=vec3(255.,78.,0.)/255.;\n    \n    vec3 vanta=vec3(-25,-25,-25)/255.;\n    \n    // lay in color blobs\n    vec3 color=vec3(0.);\n    color=mix(color,blue,dA);\n    color=mix(color,vanta,dC);\n    color=mix(color,pink,dB);\n    color=mix(color,green,dD);\n    color=mix(color,orange,dE);\n    \n    // add noise\n    color+=vec3(\n        random1f(uv),\n        random1f(uv+1.),\n        random1f(uv+2.)\n    )*.2;\n    \n    \n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdByz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 85, 85, 161], [163, 163, 219, 219, 329], [334, 334, 391, 391, 2180]], "test": "valid"}
{"id": "tdByzw", "name": "menger--v5-sdCylinder", "author": "jorge2017a1", "description": "menger--v5-sdCylinder", "tags": ["mengerv5sdcylinder"], "likes": 1, "viewed": 56, "published": "Public", "date": "1586291336", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/////modificado por jorge flores.p --\n//Gracias a ....Created by russ in 2017-03-06\n//https://www.shadertoy.com/view/XsfczB\n    \n\nconst int iter =80;\nconst float eps = 0.001, far = 20.;\nvec3 lDir0 = normalize(vec3(1,2,1)), lDir1 = normalize(vec3(-1,1.0,-2));\nvec3 lCol0 = vec3(1,.8,.5), lCol1 = vec3(.6,0.8,1); \n\n\n#define PI 3.1415926\n\n///-------------------------------------\nconst int MAX_RAY_STEPS = 64;\nconst float RAY_STOP_TRESHOLD = 0.0001;\nconst int MENGER_ITERATIONS = 5;\n///-------------------------------------\n\nfloat NumCol;\n\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3  di = abs(p) - b;\n  float mc = maxcomp(di);\n  return min(mc,length(max(di,0.0)));\n}\n\n\n\n//-------------------------------------------\n\n//oooooooooooooooooooooooooooooooooooooooooooooooooooo\nfloat sdCross(vec3 p) {\n\tp = abs(p);\n\tvec3 d = vec3(max(p.x, p.y),\n\t\t\t\t  max(p.y, p.z),\n\t\t\t\t  max(p.z, p.x));\n\treturn min(d.x, min(d.y, d.z)) - (1.0 / 3.0);\n}\n\nfloat sdCrossRep(vec3 p) {\n\tvec3 q = mod(p + 1.0, 2.0) - 1.0;\n\treturn sdCross(q);\n}\n\nfloat sdCrossRepScale(vec3 p, float s) {\n\treturn sdCrossRep(p * s) / s;\t\n}\n\n\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n//---------------------\n\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\n\nfloat diso( vec3 p)\n{\n    \n    vec2 res=vec2(9999.,0.0);\n    float dif1,dif2;\n    vec3 pp=p;\n   \n   \n     pp.z=mod(pp.z,10.0)-11.0;\n    float  sdc1 =sdCylinder( pp-vec3(0.0,-3.0,-5.0), vec2(4.,3.0) ); \n    float  sdc2 =sdCylinder( pp-vec3(0.0,-3.0,-5.0), vec2(3.0,3.5) ); \n    \n    dif2= differenceSDF( sdc1,sdc2); \n  \n    res=opU(res, vec2(dif2,6 ));\n    \n   \n    \n    //NumCol=res.y;\n   // d = res.x;\n    return res.x;\n}  \n\n//--------------------------\nfloat DE(vec3 p) {\n\t\n    \n    float scale = 0.33;\n    vec2 res=vec2(9999.9,0.0) ;\n\n    float dist, dist1;\n     dist=-999.0;\n     dist =diso(p);\n \n    \n\tfor (int i = 0; i < MENGER_ITERATIONS; i++) {\n\t\tdist = max(dist, -sdCrossRepScale(p, scale));\n\t\tscale *= 3.0;\n\t}\n\n\n   \n    p.z=mod(p.z,2.0);\n    float sdb1 =sdBox(p-vec3(0.0), vec3(10.0,10.0,10.0));\n    float sdb2 =sdBox(p-vec3(0.0,1.0,0.0), vec3(7.0,7.0,11.0));\n    float  dif= differenceSDF(sdb1, sdb2); \n    \n \n    res=opU(res, vec2(dist,11.0) );\n \n    \n    NumCol =res.y;\n    \n\treturn res.x;\n}\n\n//oooooooooooooooooooooooooooooooooooooooooooooooooooo\n\n\n\nvec2 march(vec3 ro, vec3 rd){\n\tfloat t=0. , d = far, it = 0.;\n    for (int i=0;i<iter;i++){\n     \tt += (d = DE(ro+t*rd));\n        if(d<eps || t> far) break;\n        it += 1.;\n    }\n    return vec2(t,it/float(iter));\n}\n\nfloat getShadow(vec3 p, vec3 n, vec3 ld){\n    p +=  2. * eps * n;\n    float t=0.,d=far;\n    for(int i=0;i<50;i++){\n        t += (d=DE(p + t*ld));\n        if (d<eps || t>3.) break;\n    }\n    return t<=3. ? 0.1 : 1. ;\n}\n\nvec3 getRay(vec3 ro, vec3 look, vec2 uv){\n    vec3 f = normalize(look - ro);\n    vec3 r = normalize(vec3(f.z,0,-f.x));\n    vec3 u = cross (f,r);\n    return normalize(f + uv.x * r + uv.y * u);\n}\n\nvec3 getNorm(vec3 p){\n    vec2 e = vec2(eps, 0);\n    return normalize(vec3(DE(p+e.xyy)-DE(p-e.xyy),DE(p+e.yxy)-DE(p-e.yxy),DE(p+e.yyx)-DE(p-e.yyx)));\n}\n\nvec3 light(vec3 p, vec3 n){\n    vec3 col = vec3(0.01);\n    for(int i=0;i<2;i++){\n        vec3 ld = (i==0) ? lDir0 : lDir1;\n        float diff = max(dot(n, (ld)),0.);\n        diff *= getShadow(p, n, ld);\n        col += diff * (i==0 ? lCol0 : lCol1);\n    }\n    return col * .7;\n}\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) {\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n\n//-----------------------------------\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tif(i==0 )\n    {\n    \n        return vec3(0.,0.,0.);\n    }\n    \n    if(i== 1 )\n    {\n        \n        return vec3(0.,0.,1.);\n    } \n    if(i== 2 )\n    {\n       return vec3(0.,1.,0.);\n    } \n    if(i== 3 )\n    {\n        return vec3(0.,1.,1.);\n    } \n    if(i== 4 )\n    {\n        return vec3(1., 0., 0.);\n    } \n    \n    if(i== 5 )\n    {\n        return vec3(1., 0.,1.);\n        } \n    if(i== 6 )\n    {\n        \n    \t//return vec3(1., 1., 0.);\n         \n    } \n        \n    if(i== 7 )\n    {\n        return vec3(1., 1., 1.);\n       } \n    if(i== 8 )\n    {\n       \n        return vec3(0.425, 0.56, 0.9); \n       } \n    if(i== 9 )\n    {\n        \n        return vec3(0.5, 0.6, 0.6); \n     } \n    if(i== 10 )\n    {\n        return vec3(0.0, 1.0, 0.0);\n    } \n    \n    \n    if(i== 11 )\n    {\n        return  vec3(0.5, 0.8, 0.9);;\n    } \n    \n    \n    \n  \n    \t\n}\n\n//----------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float time = iTime * 0.5;\n   \n\tvec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n  \n    vec3 ro = vec3(0.0,-1.0+0.7*sin(iTime),-15.0+iTime);\n    \n \n  \n    vec3 rd =normalize(vec3(uv,1.0) );\n    \n    vec2 hit = march(ro, rd);\n    vec3 p = ro + hit.x*rd;\n    \n    vec3 col = hit.x<far ? light(p, getNorm(p)) : vec3(.1*(1.-length(uv)));\n    \n    \n    \n    col += pow(hit.y,3.);\n\tfragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdByzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[537, 537, 564, 564, 595], [597, 597, 628, 628, 719], [770, 825, 848, 848, 983], [985, 985, 1011, 1011, 1068], [1070, 1070, 1110, 1110, 1144], [1148, 1148, 1196, 1196, 1229], [1257, 1257, 1293, 1293, 1396], [1398, 1398, 1427, 1427, 1553], [1556, 1556, 1577, 1577, 1978], [1982, 2011, 2029, 2029, 2560], [2620, 2620, 2649, 2649, 2837], [2839, 2839, 2880, 2880, 3056], [3058, 3058, 3099, 3099, 3251], [3253, 3253, 3274, 3274, 3404], [3406, 3406, 3433, 3433, 3683], [3740, 3784, 3801, 3801, 3872], [3897, 3989, 4014, 4014, 4277], [4319, 4319, 4347, 4347, 5227], [5285, 5285, 5342, 5342, 5776]], "test": "error"}
{"id": "tdfcDl", "name": "Day 105", "author": "jeyko", "description": "potato", "tags": ["mograph", "motiongraphics", "mdtmjvm"], "likes": 18, "viewed": 414, "published": "Public API", "date": "1585827391", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"Day 104\" by jeyko. https://shadertoy.com/view/WdlcDX\n// 2020-04-02 10:14:03\n\n\n// USING YX/LUNA'S AWESOME DITHERED MOTION BLUR - https://www.shadertoy.com/view/wsfcWX\n// I modified it to not be framerate dependent like the original.\n\n\n\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\n#define timeStep (1./60.)\n#define motionBlurSteps 10\n\n\nfloat bayer8(ivec2 uv)\n{   \n    uv %= 8;\n\treturn texelFetch(iChannel1,uv,0).r;\n}\n\n\n// from https://necessarydisorder.wordpress.com/\nfloat ease(float p, float g) {\n    if(p < 0.){\n        return 0.;\n    } else if(p > 1.){\n    \treturn 1.;\n    } else {\n        if (p < 0.5) \n            return 0.5 * pow(2.*p, g);\n        else\n            return 1. - 0.5 * pow(2.*(1. - p), g);\n    }\n}\n\nfloat ease(float p, float power, float jump, float offs, float end) {\n    float j = p;\n    p *= offs;\n    float r = (1.-cos(pi*p))/2.*jump;\n    r = pow(r, power);\n    r = mix(r, 1., pow(smoothstep(0.,1.,j),end));\n\treturn r;\n}\nfloat smease(float p, float g) {\n    float s = p;\n    for(float i = 0.; i < g; i++){\n    \ts = smoothstep(0.,1.,s);\n    }\n    return s;\n}\n\n\nfloat sdBox(vec2 p, vec2 s){\n\tp = abs(p) - s;\n\treturn max(p.x, p.y);\n}\nfloat sdCirc(vec2 p, float s){\n    return length(p) - s;\n}\n\nfloat sdEquilateralTriangle(  vec2 p, float s )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - s;\n    p.y = p.y + s/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d = -length(p)*sign(p.y);\n    \n    return d;\n}\nconst float speed = 0.28;\nfloat[] scenes = float[4](3.2*speed,1.7*speed, 2.6*speed, 1.2*speed); \n\nconst float S = 1.;\n\nvec3 get( vec2 uv, float t  )\n{\n vec2 suv = uv;   \n    //uv += S*0.05;\n    uv *= 2.;\n    \n    uv.y += S*0.25;\n    float col = 0.;\n    \n    float d = 10e6;\n    \n    float bA;\n    float bB;\n    float bC;\n    float bD;\n    float bE;\n    \n    float pl;\n    \n    \n    //col += smoothstep(0.5,0.1, abs(uv.y));\n    \n    //t += scenes[0];\n    //t += scenes[1] - 0.1;\n    //t += scenes[2] - 0.1;\n    t = mod(t, scenes[0] + scenes[1] + scenes[2] + scenes[3]  );\n    \n    \n    float iters = 45.;\n           \n    float sep = 5.;\n    float pp = 1.645;\n    \n    #define sc(x) vec2(sin((x)*tau), cos((x)*tau))\n    \n    if(t < scenes[0]){\n        float lsp = 1.2;\n        float env = ease(t/scenes[0]*lsp, 3.);  \n        \n        for(float i = 0.; i < iters + min(float(iFrame),0.); i++){\n            vec2 suv = uv;\n            if(i != iters - 1.){\n            \tsuv *= rot((iters - i)*1.65*env/pi);\n            }\n            float dTriA = sdEquilateralTriangle(  suv, S/exp((iters - i)/sep) );\n        \n            d = max(d, dTriA);\n        \td = min(d, abs(dTriA) - dFdx(uv.x)/2.);\n        \n        }\n    } else if(t < scenes[0] + scenes[1]){\n        t -= scenes[0];\n        float lsp = 1.2;\n        float env = ease(t/scenes[1]*lsp, 3.);  \n        \n           \n        for(float i = 0.; i < iters + min(float(iFrame),0.); i++){\n            vec2 suv = uv;\n            if(i != iters - 1.){\n            \tsuv *= rot((iters - i)*pp/pi + (iters - i)*pp/pi*env);\n            }\n            float dTriA = sdEquilateralTriangle(  suv, S/exp((iters - i)/sep) );\n        \n            d = max(d, dTriA);\n        \td = min(d, abs(dTriA) - dFdx(uv.x)/2.);\n        \n        }\n    } else if(t < scenes[0] + scenes[1] + scenes[2]){\n        t -= scenes[0] + scenes[1];\n        float lsp = 1.2;\n        float env = ease(t/scenes[2]*lsp, 3.);  \n        \n        for(float i = 0.; i < iters + min(float(iFrame),0.); i++){\n            vec2 suv = uv;\n            if(i != iters - 1.){\n            \tsuv *= rot((iters - i)*pp/pi + (iters - i)*pp/pi + (iters - i)*pp/pi*env*2. );\n            }\n            float dTriA = sdEquilateralTriangle(  suv, S/exp((iters - i)/sep) );\n        \n            d = max(d, dTriA);\n        \td = min(d, abs(dTriA) - dFdx(uv.x)/2.);\n        \n        }\n    }else if(t < scenes[0] + scenes[1] + scenes[2] + scenes[3]){\n        t -= scenes[0] + scenes[1] + scenes[2];\n        float lsp = 1.2;\n        float env = ease(t/scenes[3]*lsp, 3.)*smoothstep(1.,0.,t/scenes[3]*lsp)*0.05;  \n        \n        for(float i = 0.; i < iters + min(float(iFrame),0.); i++){\n            vec2 suv = uv;\n            if(i != iters - 1.){\n            }\n            float dTriA = sdEquilateralTriangle(  suv, (S + env)/exp((iters - i )/(sep - env*1. )) );\n        \n            d = max(d, dTriA);\n        \td = min(d, abs(dTriA) - dFdx(uv.x)/2.);\n        \n        }\n    }\n    \n    //d = min(d, abs(suv.y) - 0.001);\n    //d = min(d, abs(suv.x) - 0.001);\n    return vec3(d);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;  \n    vec3 col = vec3(0);\n    \n    float edge = dFdx(uv.x)*1.;\n    \n    for (int i = 0; i < motionBlurSteps  ; ++i) {\n        float subsample = bayer8(ivec2(fragCoord));\n        float time = iTime + ((float(i)+subsample)/float(motionBlurSteps)-.5) * timeStep;\n        col += smoothstep(-edge,edge,-get(uv,time));\n    }\n    col/=float(motionBlurSteps);\n    \n    col = clamp(col, 0., 1.);\n    col *= 0.999;\n    \n    //col *= max((1. + 1.*cos(sin(0.25*tau*iTime/(scenes[0] + scenes[1] ))*tau+length(uv)*2.+vec3(4,2.5,1.5)))*1., 0.);\n    //col *= max((1.5 + 1.4*cos(iTime+length(uv)*2.+vec3(1,1.5,1.5)))*1., 0.);\n    \n    col *= 1. - pow(smoothstep(0.,1.,dot(uv,uv)*0.9),0.9)*1.;\n    \n    col = pow(col, vec3(0.454545));\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}, {"id": "4dXGR8", "previewfilepath": "/media/previz/buffer00.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/previz/buffer00.png", "ctype": "buffer"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdfcDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[394, 394, 418, 418, 474], [477, 526, 556, 556, 776], [778, 778, 847, 847, 1003], [1004, 1004, 1036, 1036, 1140], [1143, 1143, 1171, 1171, 1213], [1214, 1214, 1244, 1244, 1272], [1274, 1274, 1323, 1323, 1552], [1672, 1672, 1703, 1703, 4606]], "test": "error"}
{"id": "tdffRr", "name": "Noise Cornell Box", "author": "felixcui", "description": "Cornell Box with Worley and Perlin noise applied.  For CIS 461 HW09", "tags": ["noise"], "likes": 0, "viewed": 40, "published": "Public", "date": "1587594128", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SMALLBOXPOS vec3(-2.0, -1.0, 3.75)\n#define LARGEBOXPOS vec3(-3.5, 0.0, -5.0)\n#define BACKPOS vec3(-10.0, 0.0, 0.0)\n#define RIGHTPOS vec3(0.0, 0.0, 10.0)\n#define LEFTPOS vec3(0.0, 0.0, -10.0)\n#define CEILINGPOS vec3(0.0, -18.0, 0.0)\n\n#define LIGHT_POS vec3(0.0, 7.45, 0.0)\n#define FOVY 3.141569 * 0.25\n\n// constants\nconst int RAY_STEPS = 256;\nconst float PI = 3.14159;\n\nstruct Intersection\n{\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n};\n    \nvec2 random2(vec2 v)\n{\n    return fract(sin(vec2(dot(v, vec2(839, 919)),dot(v, vec2(239, 911)))) * vec2(55249));\n}\n\nfloat random1(vec3 p) \n{\n\treturn fract(sin((dot(p, vec3(127.1,\n                                  311.7,\n                                  191.999)))) *\n                 \t\t\t\t  43758.5453);\n}\n\n\nvec3 random3(vec3 p) \n{\n    return fract(sin(vec3(dot(p, vec3(127.1, 313.7, 60.2)),\n                         dot(p, vec3(269.5, 183.3, 765.54)),\n                         dot(p, vec3(110.2, 631.2, 109.21))))\n                \t\t *10421.5453);\n}\n\nfloat surflet(vec3 p, vec3 gridPoint) {\n    vec3 t2 = abs(p - gridPoint);\n    vec3 t = vec3(1.f) - 6.f * pow(t2, vec3(5.f)) + 15.f * pow(t2, vec3(4.f)) - 10.f * pow(t2, vec3(3.f));\n    vec3 gradient = random3(gridPoint) * 2. - vec3(1., 1., 1.);\n    vec3 diff = p - gridPoint;\n    float height = dot(diff, gradient);\n\n    return height * t.x * t.y * t.z;\n}\nfloat perlinNoise3D(vec3 p) {\n\tfloat surfletSum = 0.f;\n\tfor(int dx = 0; dx <= 1; ++dx) {\n\t\tfor(int dy = 0; dy <= 1; ++dy) {\n\t\t\tfor(int dz = 0; dz <= 1; ++dz) {\n\t\t\t\tsurfletSum += surflet(p, floor(p) + vec3(dx, dy, dz));\n\t\t\t}\n\t\t}\n\t}\n\treturn surfletSum;\n}\n\n    \nfloat WorleyNoise3D(vec3 p)\n{\n    vec3 tile = floor(p);\n    vec3 pixel = fract(p);\n    \n    float minDist = 1.0;\n    for (int z = -1; z <= 1; z++) {\n        for (int y = -1; y <= 1; y++) {\n            for (int x = -1; x <= 1; x++) {\n                vec3 neighbor = vec3(float(x), float(y), float(z));\n                \n                vec3 point = random3(tile + neighbor);\n                point = 0.5 + 0.5 * sin(iTime * 0.5 + 6.28 * point);\n                \n                vec3 diff = neighbor + point - pixel;\n                float dist = length(diff);\n                minDist = min(minDist, dist);\n            }\n        }\n    }\n    return minDist;\n\n}\n\nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n    \n// Box with side lengths b\nfloat box(vec3 p, vec3 b)\n{\n  return length(max(abs(p) - b, 0.0));\n}\n\nfloat plane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sceneMap3D(vec3 pos, vec3 lightPos) {\n    float t0 = box(rotateY(pos + SMALLBOXPOS, -9.9), vec3(3.0, 3.0, 3.0));\n    float t1 = box(rotateY(pos + LARGEBOXPOS, -0.9), vec3(3.0, 8.0, 3.0));\n    float t2 = box(pos + vec3(0.0, 3.0, 0.0), vec3(15.0, 1.0, 15.0));\n\tfloat t3 = plane(pos + RIGHTPOS, vec4(0.0, 0.0, 1.0, 1.0));\n    float t4 = plane(pos + LEFTPOS, vec4(0.0, 0.0, -1.0, 1.0));\n\tfloat t5 = plane(pos + CEILINGPOS, vec4(0.0, -1.0, 0.0, 1.0));\n    float t6 = plane(pos + BACKPOS, vec4(-1.0, 0.0, 0.0, 1.0));\n    \n    float min = min(t5, min(t4, min(t3, min(t0, min(t2, min(t1, t6))))));\n    return min;\n}\n\nvoid sceneMap3D(vec3 pos, out float t, out int obj, vec3 lightPos) {\n\tfloat t0 = box(rotateY(pos + SMALLBOXPOS, -9.9), vec3(3.0, 3.0, 3.0));\n    float t1 = box(rotateY(pos + LARGEBOXPOS, -0.9), vec3(3.0, 8.0, 3.0));\n    float t2 = box(pos + vec3(0.0, 3.0, 0.0), vec3(15.0, 1.0, 15.0));\n\tfloat t3 = plane(pos + RIGHTPOS, vec4(0.0, 0.0, 1.0, 1.0));\n    float t4 = plane(pos + LEFTPOS, vec4(0.0, 0.0, -1.0, 1.0));\n\tfloat t5 = plane(pos + CEILINGPOS, vec4(0.0, -1.0, 0.0, 1.0));\n    float t6 = plane(pos + BACKPOS, vec4(-1.0, 0.0, 0.0, 1.0));\n    \n    obj = 0;\n    float min = min(t5, min(t4, min(t3, min(t0, min(t2, min(t1, t6))))));\n    t = min;\n    if (min == t0) {obj = 3;}\n    else if (min == t1) {obj = 3;}\n    else if (min == t3) {obj = 0;}\n    else if (min == t4) {obj = 1;}\n    else if (min == t6) {obj = 3;}\n    else {obj = 3;}\n}\n\nvoid rayCast(vec2 uv, out vec3 dir, out vec3 eye, out vec3 ref) {\n    eye = rotateY(vec3(0.0, 1.0, 15.0), PI * 1.5);\n    ref = vec3(0.0, 0.0, 0.0);\n    \n    float len = tan(3.14159 * 0.125) * distance(eye, ref);\n    vec3 H = normalize(cross(vec3(0.0, 1.0, 0.0), ref - eye));\n    vec3 V = normalize(cross(H, eye - ref));\n    V *= len;\n    H *= len * iResolution.x / iResolution.y;\n    \n    vec3 p = ref + uv.x * H + uv.y * V;\n    dir = normalize(p - eye);\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj, vec3 lightPos)\n{\n\tt = 0.001;\n    for (int i = 0; i < RAY_STEPS; ++i) \n    {\n    \tvec3 pos = origin + t * dir;\n        float m;\n        sceneMap3D(pos, m, hitObj, lightPos);\n        \n        if (m < 0.01) \n        {\n         \treturn;   \n        }\n        \n        t += m;\n    }\n    \n    t = -1.0;\n    hitObj = -1;\n}\n\nvec3 computeMaterial(int hitObj, vec3 p, vec3 n, vec3 light, vec3 view) {\n    float lambert = max(0.0, dot(n, light));\n\tswitch(hitObj)\n    {\n        case 0: // left wall\n        return vec3(1.0, 0.88, 0.7) * vec3(1.0, 0.0, 0.0) * lambert * perlinNoise3D(p);\n        break;\n        case 1: // right wall\n        return vec3(1.0, 0.88, 0.7) * vec3(0.0, 0.88, 0.0) * lambert * perlinNoise3D(p);\n        break;\n        case 3: // floor, ceiling, boxes\n        return vec3(1.0, 1.0, 1.0) * lambert * WorleyNoise3D(p);\n        break;\n        case -1:\n        return vec3(0.0);\n        break;\n    }\n    \n    return vec3(1.0);\n}\n\nvec3 computeNormal(vec3 pos, vec3 lightPos) {\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( sceneMap3D(pos + epsilon.yxx, lightPos) - sceneMap3D(pos - epsilon.yxx, lightPos),\n                            sceneMap3D(pos + epsilon.xyx, lightPos) - sceneMap3D(pos - epsilon.xyx, lightPos),\n                            sceneMap3D(pos + epsilon.xxy, lightPos) - sceneMap3D(pos - epsilon.xxy, lightPos)));\n}\n\nIntersection sdf3D(vec3 dir, vec3 eye, vec3 lightPos) {\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj, lightPos);\n    \n    vec3 isect = eye + t * dir;\n    vec3 nor = computeNormal(isect, lightPos);\n    vec3 lightDir = normalize(lightPos - isect);\n    \n    vec3 surfaceColor = computeMaterial(hitObj, isect, nor, lightDir, normalize(eye - isect));\n    return Intersection(t, surfaceColor, isect, hitObj);\n}\n\n\n\n        \n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Convert to [-1, 1]\n    uv = 2.0 * uv - vec2(1.0, 1.0);\n    vec3 lightPos = vec3(-4.0, 18.0, 0.0);\n\tIntersection aaIsects[4];\n    vec3 dir, eye, ref;\n    int idx = 0;\n    for(float i = 0.0; i < 1.0; i += 0.5) {\n        for(float j = 0.0; j < 1.0; j += 0.5) {\n            rayCast(uv + vec2(i, j) / iResolution.xy, dir, eye, ref);\n            aaIsects[idx++] = sdf3D(dir, eye + vec3(-12.0, 8.0, 0.0), lightPos);\n        }\n    }\n    vec3 avgColor = vec3(0.0);\n    for(int i = 0; i < 4; ++i) {\n        avgColor += aaIsects[i].color;\n    }\n    avgColor *= 0.25;\n    fragColor = vec4(avgColor * step(0.0, aaIsects[0].t), 1.0);\n    float fogT = smoothstep(30.0, 50.0, distance(aaIsects[0].p, eye));\n    fragColor.rgb = mix(fragColor.rgb, vec3(0.0), fogT);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdffRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[464, 464, 486, 486, 578], [580, 580, 604, 604, 769], [772, 772, 795, 795, 1013], [1015, 1015, 1054, 1054, 1370], [1371, 1371, 1400, 1400, 1623], [1630, 1630, 1659, 1659, 2284], [2286, 2286, 2317, 2317, 2400], [2406, 2433, 2460, 2460, 2501], [2503, 2503, 2534, 2560, 2591], [2593, 2593, 2636, 2636, 3206], [3208, 3208, 3276, 3276, 4043], [4045, 4045, 4110, 4110, 4501], [4503, 4503, 4582, 4582, 4880], [4882, 4882, 4955, 4955, 5502], [5504, 5504, 5549, 5549, 5928], [5930, 5930, 5985, 5985, 6348], [6366, 6366, 6423, 6473, 7271]], "test": "error"}
{"id": "tdffz8", "name": "fajne", "author": "TosterMocy", "description": "fajne zrobilam", "tags": ["fajne"], "likes": 2, "viewed": 55, "published": "Public", "date": "1587668053", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n\tfloat pixelSize = 2.0 / iResolution.y;\n    \n    \n    //uv.x = sqrt(abs(uv.x));\n    uv.x*=0.80;\n    uv.y+=0.3;\n    uv.y -= sqrt(abs(sin(uv.x *iTime*2.5))) *0.7  ;\n   \n    \n    float radius=0.6;\n    float circle = 1.0 - smoothstep(radius - pixelSize, radius + pixelSize, length(uv));\n     \n   \n    \n    fragColor = vec4(circle );\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdffz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 470]], "test": "valid"}
{"id": "tdffzN", "name": "wallpaper_tiles", "author": "blepfo", "description": "https://en.wikipedia.org/wiki/Wallpaper_group#/media/File:Wallpaper_group-p4g-2.jpg", "tags": ["tile"], "likes": 1, "viewed": 58, "published": "Public", "date": "1587777587", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141\n\nfloat unionSdf(float d1, float d2) {\n    return min(d1, d2);\n}\n\n\nfloat rectSdf(\n    vec2 uv, \n\tvec2 halfSize\n) {\n    vec2 componentDist = abs(uv) - halfSize;\n    float dOut = length(max(componentDist, 0.));\n    float dIn = min(max(componentDist.x, componentDist.y), 0.);\n    return dOut + dIn;\n}\n\n\nvec2 translate(\n\tvec2 uv,\n    vec2 t\n) {\n    return uv - t;\n}\n\n\nmat2 rotate2d(float theta) {\n    return mat2(cos(theta), -sin(theta),\n               sin(theta), cos(theta));\n}\n\n\nfloat baseShapeSdf(vec2 uv) {\n    // Long \n    vec2 shortBarScale = vec2(1./7., 1.);\n    // Main shapes\n    float longBar = rectSdf(uv, vec2(0.5,4.5));\n    float shortBarTop = rectSdf(\n        translate(uv, vec2(0., 4.)), \n        vec2(3.5, 0.5)\n    );\n    float shortBarBottom = rectSdf(\n    \ttranslate(uv, vec2(0., -4.)),\n        vec2(3.5, 0.5)\n    );\n    float detailBoxQ1 = rectSdf(\n        translate(uv, vec2(2., 3.)),\n        vec2(.5, .5)\n    );\n    float detailBoxQ2 = rectSdf(\n        translate(uv, vec2(-2., 3.)),\n        vec2(.5, .5)\n    );\n    float detailBoxQ3 = rectSdf(\n        translate(uv, vec2(-2., -3.)),\n        vec2(.5, .5)\n    );\n    float detailBoxQ4 = rectSdf(\n        translate(uv, vec2(2., -3.)),\n        vec2(.5, .5)\n    );\n    float shape = longBar;\n    shape = unionSdf(shape, shortBarTop);\n    shape = unionSdf(shape, shortBarBottom);\n    shape = unionSdf(shape, detailBoxQ1);\n    shape = unionSdf(shape, detailBoxQ2);\n    shape = unionSdf(shape, detailBoxQ3);\n    shape = unionSdf(shape, detailBoxQ4);\n    return shape;\n}\n\nfloat outlineShape(float shapeSdf) {\n    return smoothstep(0., 0.05, shapeSdf) - smoothstep(0.07, 0.1, shapeSdf);\n}\n\nfloat placeShape(\n\tvec2 uv, \n    vec2 t,\n    float theta\n) {\n    float shapeSdf = baseShapeSdf(rotate2d(theta)*translate(uv, t));\n    return outlineShape(shapeSdf);\n}\n\n\nfloat singleTile(vec2 uv) {\n    uv = abs(uv);\n    float mainShape = placeShape(uv, vec2(0.), 0.);\n    \n    float tlShape = placeShape(uv, vec2(5., 5.), 0.);\n    \n    float tile = mainShape + tlShape ;\n    return tile;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    float tileScale = 3.;\n    vec2 scaleUv = uv*tileScale;\n    scaleUv += iTime / 3.5;\n    vec2 fractUv = fract(scaleUv);\n    // Map each tile to [-5.5, -5.5] x [5.5, 5.5]\n    fractUv = 10.*fractUv - 5.;\n    float tile = singleTile(fractUv);\n\n    vec3 color = vec3(0.061,0.300,0.274);\n    color = mix(color, vec3(0.379,1.000,0.084), tile);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdffzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 18, 54, 54, 80], [83, 83, 130, 130, 313], [316, 316, 356, 356, 377], [380, 380, 408, 408, 491], [494, 494, 523, 536, 1545], [1547, 1547, 1583, 1583, 1662], [1664, 1664, 1724, 1724, 1830], [1833, 1833, 1860, 1860, 2052], [2055, 2055, 2112, 2112, 2573]], "test": "valid"}
{"id": "tdjcR3", "name": "Penumbra + SS", "author": "ez21", "description": "Subsurface Scattering, Penumbra shadows, Noise-custom textures", "tags": ["approx"], "likes": 1, "viewed": 56, "published": "Public", "date": "1587080288", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The larger the DISTORTION, the smaller the glow\nconst float DISTORTION = 0.4;\n// The higher GLOW is, the smaller the glow of the subsurface scattering\nconst float GLOW = 4.0;\n// The higher the BSSRDF_SCALE, the brighter the scattered light\nconst float SCALE = 8.0;\n// Boost the shadowed areas in the subsurface glow with this\nconst float AMBIENT = 2.;\n\n// ambient occlusion\nconst float KSTEP = 2.;\nconst float OCCDist = 0.085;\n\n\n#define FLOOR_SDF plane(pos, vec3(0., 1.0, 0.), vec3(0., -2.5, 0.))\n#define SPHERE1_SDF sphere(pos, 1., vec3(-7.5, 0., 12.))\n#define SPHERE2_SDF sphere(pos, 5., vec3(2.5, 0.5, 10.))\n#define SUN_SDF sphere(pos, 1.5, lightPos)\n\n    \n#define FLOOR_ID 3\n#define SPHERE1_ID 4\n#define SPHERE2_ID 5\n#define SUN_ID 6\n\n\nconst float FOVY = (3.141569 * 2.) * 19.5 / 360.;\nconst int RAY_STEPS = 256;\n\nstruct Intersection {\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n    vec3 n;\n};\n    \n/********************************/\n/***** NOISE FUNCTIONS BEGIN*****/\n/********************************/\n\nvec3 random3(vec3 p) {\n    return fract(sin(vec3(dot(p, vec3(127.1, 311.7, 191.999)),\n                          dot(p, vec3(269.5, 183.3, 765.54)), \n                          dot(p, vec3(420.69, 631.2, 109.21))))\n                 * 43758.5453);\n}\n\nvec2 random2(vec2 p) {\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)),\n                          dot(p, vec2(269.5, 183.3))))\n                 * 43758.5453);\n}\n\nfloat WorleyNoise2D(vec2 p) {\n    \n    // Tile the space\n    vec2 pointInt = floor(p);\n    vec2 pointFract = fract(p);\n\n    float minDist = 1.0; // Minimum distance initialized to max.\n\n    // Search all neighboring cells and this cell for their point\n    for(int y = -1; y <= 1; y++)\n    {\n        for(int x = -1; x <= 1; x++)\n        {\n            vec2 neighbor = vec2(float(x), float(y));\n\n            // Random point inside current neighboring cell\n            vec2 point = random2(pointInt + neighbor);\n\n            // Animate the point\n            point = 0.5 + 0.5 * sin(iTime * 0.01 + 6.2831 * point); // 0 to 1 range\n\n            // Compute the distance b/t the point and the fragment\n            // Store the min dist thus far\n            vec2 diff = neighbor + point - pointFract;\n            float dist = length(diff);\n            minDist = min(minDist, dist);\n        }\n    }\n    return minDist;\n}\n\n\nconst vec3 a = vec3(0.5, 0.5, 0.5);\nconst vec3 b = vec3(0.5, 0.5, 0.5);\nconst vec3 c = vec3(1., 1., 1.);\nconst vec3 d = vec3(0.81,0.81,0.74);\n\nvec3 colorPalette(float t) {\n    return a + b * cos(6.28 * (t * c + d));\n}\n\nconst vec3 a2 = vec3(0.5, 0.5, 0.5);\nconst vec3 b2 = vec3(0.5, 0.5, 0.5);\nconst vec3 c2 = vec3(1., 1., 1.);\nconst vec3 d2 = vec3(0.2,0.25,0.25);\n\n\nvec3 colorPalette2(float t) {\n    return a2 + b2 * cos(6.28 * (t * c2 + d2));\n}\n\nfloat noise2D(vec2 p ) {\n    return fract(sin(dot(p, vec2(127.1, 311.7))) *\n                 43758.5453);\n}\n\n\nfloat interpNoise2D(float x, float y) {\n    float intX = floor(x);\n    float fractX = fract(x);\n    float intY = floor(y);\n    float fractY = fract(y);\n\n    float v1 = noise2D(vec2(intX, intY));\n    float v2 = noise2D(vec2(intX + 1., intY));\n    float v3 = noise2D(vec2(intX, intY + 1.));\n    float v4 = noise2D(vec2(intX + 1., intY + 1.));\n\n    float i1 = mix(v1, v2, fractX);\n    float i2 = mix(v3, v4, fractX);\n    return mix(i1, i2, fractY);\n}\n\nfloat fbm(vec2 p) {\n    float total = 0.;\n    float persistence = 0.7f;\n    float octaves = 8.;\n\n    for(float i = 1.; i <= octaves; i++) {\n        float freq = pow(2.f, i);\n        float amp = pow(persistence, i);\n\n        total += interpNoise2D(p.x * freq,\n                               p.y * freq) * amp;\n    }\n    return total;\n}\n\n\n\n/********************************/\n/***** NOISE FUNCTIONS END ******/\n/********************************/\n    \n\n// SDF of a sphere\nfloat sphere(vec3 p , float r, vec3 c) {\n    return distance(p, c) - r;\n}\n\n// SDF of plane\nfloat plane(vec3 p, vec3 n, vec3 c)\n{\n  \t// n must be normalized\n  \tvec3 a = p - c;\n  \tvec3 b = n;\n    \n    if (dot(a, b) < -0.001) {\n        return 10000.;\n    }\n  \n  \treturn dot(a ,b) / length(b);\n}\n\n// Box with side lengths b\nfloat box(vec3 p, vec3 b)\n{\n  return length(max(abs(p) - b, 0.0));\n}\n\n// transformation\nmat4 inverseTransform(vec3 s, vec3 rDeg, vec3 t) {\n    \n    // convert from degrees to radians\n    vec3 rotate = vec3(radians(rDeg.x), radians(rDeg.y), radians(rDeg.z));\n    \n    mat4 r_x;\n    r_x[0] = vec4(1., 0., 0., 0.);\n    r_x[1] = vec4(0., cos(rotate.x), sin(rotate.x), 0.);\n    r_x[2] = vec4(0., -sin(rotate.x), cos(rotate.x), 0.);\n    r_x[3] = vec4(0., 0., 0., 1.);\n                                    \n                                    \n    mat4 r_y;\n    r_y[0] = vec4(cos(rotate.y), 0., -sin(rotate.y), 0.);\n    r_y[1] = vec4(0., 1, 0., 0.);\n    r_y[2] = vec4(sin(rotate.y), 0., cos(rotate.y), 0.);\n    r_y[3] = vec4(0., 0., 0., 1.);\n\n    mat4 r_z;\n    r_z[0] = vec4(cos(rotate.z), sin(rotate.z), 0., 0.);\n    r_z[1] = vec4(-sin(rotate.z), cos(rotate.z), 0., 0.);\n    r_z[2] = vec4(0., 0., 1., 0.);\n    r_z[3] = vec4(0., 0., 0., 1.);\n\n    mat4 rMat = r_x * r_y * r_z;\n    \n    // creating worldTransform matrix\n    mat4 translateMat;\n    translateMat[0] = vec4(1., 0., 0., 0.);\n    translateMat[1] = vec4(0., 1., 0., 0.);\n    translateMat[2] = vec4(0., 0., 1., 0.);\n    translateMat[3] = vec4(t.x, t.y, t.z, 1.);\n    \n    mat4 scaleMat;\n    scaleMat[0] = vec4(s.x, 0., 0., 0.);\n    scaleMat[1] = vec4(0., s.y, 0., 0.);\n    scaleMat[2] = vec4(0., 0., s.z, 0.);\n    scaleMat[3] = vec4(0., 0., 0., 1.);\n\n    mat4 worldTrans = translateMat * rMat * scaleMat;\n    \n    return inverse(worldTrans);\n}\n\nmat4 rotateMat(vec3 rDeg) {\n        // convert from degrees to radians\n    vec3 rotate = vec3(radians(rDeg.x), radians(rDeg.y), radians(rDeg.z));\n    \n    mat4 r_x;\n    r_x[0] = vec4(1., 0., 0., 0.);\n    r_x[1] = vec4(0., cos(rotate.x), sin(rotate.x), 0.);\n    r_x[2] = vec4(0., -sin(rotate.x), cos(rotate.x), 0.);\n    r_x[3] = vec4(0., 0., 0., 1.);\n                                    \n                                    \n    mat4 r_y;\n    r_y[0] = vec4(cos(rotate.y), 0., -sin(rotate.y), 0.);\n    r_y[1] = vec4(0., 1, 0., 0.);\n    r_y[2] = vec4(sin(rotate.y), 0., cos(rotate.y), 0.);\n    r_y[3] = vec4(0., 0., 0., 1.);\n\n    mat4 r_z;\n    r_z[0] = vec4(cos(rotate.z), sin(rotate.z), 0., 0.);\n    r_z[1] = vec4(-sin(rotate.z), cos(rotate.z), 0., 0.);\n    r_z[2] = vec4(0., 0., 1., 0.);\n    r_z[3] = vec4(0., 0., 0., 1.);\n\n    mat4 rMat = r_x * r_y * r_z;\n    return rMat;\n}\n\n// SDF of box\nfloat box(vec3 p, vec3 s, vec3 r, vec3 t) {\n    mat4 inverseTrans = inverseTransform(s, r, t);\n    vec4 tempP = inverseTrans * vec4(p, 1.f);\n    p = vec3(tempP.x, tempP.y, tempP.z);\n    \n    vec3 q = abs(p) - vec3(0.5, 0.5, 0.5);\n  \treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvoid sceneMap3D(vec3 pos, out float t, out int obj, vec3 lightPos) {\n    t = FLOOR_SDF;\n    obj = FLOOR_ID;\n    \n    float t2;\n    if ((t2 = SPHERE1_SDF) <t) {\n        t = t2;\n        obj = SPHERE1_ID;\n    }\n    if ((t2 = SPHERE2_SDF) <t) {\n        t = t2;\n        obj = SPHERE2_ID;\n    }\n    if ((t2 = SUN_SDF) <t) {\n        t = t2;\n        obj = SUN_ID;\n    }\n}\n\nfloat sceneMap3D(vec3 pos, vec3 lightPos) {\n    float t = FLOOR_SDF;\n    \n    float t2;\n    if ((t2 = SPHERE1_SDF) < t) {\n        t = t2;\n    }\n    if ((t2 = SPHERE2_SDF) < t) {\n        t = t2;\n    }\n    if ((t2 = SUN_SDF) < t) {\n        t = t2;\n    }\n    return t;\n}\n\nfloat subsurface(vec3 lightDir, vec3 normal, vec3 viewVec, float thin) {\n\tvec3 scatterDir = lightDir + normal * DISTORTION; // Last term is tunable\n\tfloat lightReachingEye = pow(clamp(dot(viewVec, -scatterDir),\n\t\t\t\t\t\t\t     0.0, 1.0), GLOW) * SCALE;\n\tfloat attenuation = max(0.0, dot(normal, lightDir)\n                             + dot(viewVec, -lightDir));\n    //attenutation = 1.f;\n\tfloat totalLight = attenuation * (lightReachingEye + AMBIENT) * thin;\n\treturn totalLight;\n}\n\nfloat softShadow(vec3 dir, vec3 origin, float min_t, float max_t, float k) {\n    float res = 1.0;\n    for(float t = min_t; t < max_t; /*No update in loop header*/) {\n        float m = sceneMap3D(origin + t * dir, vec3(0., 0., 0.));\n        if(m < 0.0001) {\n            return 0.0; // In shadow\n        }\n        res = min(res, k * m / t);\n        t += m;\n    }\n    return res;\n}\n\nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\nvec2 sphereUVMapSun(vec3 pos, vec3 lightPos) {\n    vec3 n = normalize(pos - lightPos); // sphere point - sphere center: for the sun\n    float phi = atan(n.z, n.x);\n    if (phi < 0.) {\n        phi += 2. * 3.1415926;\n    }\n    float theta = acos(n.y);\n    float u = 1. - phi / (2. * 3.1415926);\n    float v = 1. - theta / 3.1415926;\n    return vec2(u, v);\n}\n\nvec2 planeUVMap(vec3 pos) {\n    vec3 n = vec3(0., 1., 0.);\n    vec3 u = normalize(vec3(1., 0., 0.));\n    vec3 v = cross(n, u);\n    \n    float u_coord = dot(u, pos);\n\tfloat v_coord = dot(v,pos);\n    return vec2(u_coord, v_coord);\n}\n\nvec3 computeMaterial(int hitObj, vec3 pos, vec3 n, vec3 lightVec, vec3 view, float thickness, vec3 lightPos) {\n    float lambert = max(0., dot(lightVec, n)) * softShadow(lightVec, pos, 0.1, 50., 6.0);\n    switch(hitObj) {\n        case FLOOR_ID:\n        \treturn vec3(1., 1., 1.) * lambert * colorPalette(cos(iTime / 2.)* WorleyNoise2D(planeUVMap(pos)));\n        \tbreak;\n        case SPHERE1_ID:\n        \treturn vec3(1., 0., 0.) * lambert;\n            break;\n\t\tcase SPHERE2_ID:\n        \tvec3 color = vec3(0.1, 0.4, 1.) * lambert;\n        \treturn color + subsurface(lightVec, n, view, thickness) * vec3(0.2, 0.5, 1.);\n            break;\n        case SUN_ID:\n        \treturn vec3(1.0, 0.88, 0.7) * colorPalette2(fbm(sphereUVMapSun(pos, lightPos)) * cos(iTime / 8.));\n        \tbreak;\n        case -1:\n            return vec3(0., 0., 0.);\n        \tbreak;\n    }\n    return vec3(0., 0., 0.);\n}\n\n\nvec3 computeNormal(vec3 pos, vec3 lightPos) {\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize(vec3(sceneMap3D(pos + epsilon.yxx, lightPos) - sceneMap3D(pos - epsilon.yxx, lightPos), \n                    \t  sceneMap3D(pos + epsilon.xyx, lightPos) - sceneMap3D(pos - epsilon.xyx, lightPos),\n                          sceneMap3D(pos + epsilon.xxy, lightPos) - sceneMap3D(pos - epsilon.xxy, lightPos)));\n}\n    \n\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj, vec3 lightPos) {\n    t = 0.001;\n    for (int i = 0; i < RAY_STEPS; ++i) {\n        vec3 pos = origin + t * dir;\n        float m;\n        sceneMap3D(pos, m, hitObj, lightPos);\n        if (m < 0.01) {\n            return;\n        }\n        t += m;\n    }\n    t = -1.0;\n    hitObj = -1;\n}\n\n\nfloat AO5Step(vec3 p, vec3 n) {\n    float sum = 0.;\n    for (float i = 1.; i <= 5.; i = i + 1.) {\n        float distSDF = sceneMap3D(p + n * i * OCCDist, vec3(0.));\n        sum += (1. / pow(2., i)) * (i * OCCDist - distSDF);\n    }\n    float ao = 1.0 - KSTEP * sum;\n    return ao;\n}\n\n\nIntersection sdf3D(vec3 dir, vec3 eye, vec3 lightPos) {\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj, lightPos);\n    \n    vec3 isect = eye + t * dir;\n    \n    vec3 nor = computeNormal(isect, lightPos);\n    \n    vec3 lightDir = normalize(lightPos - isect);\n    float thickness = AO5Step(isect, -nor);\n    \n    vec3 surfaceColor = computeMaterial(hitObj, isect, nor, lightDir, normalize(eye - isect), thickness, lightPos);\n        \n    return Intersection(t, surfaceColor, isect, hitObj, nor);\n}\n\n// returns direction of ray\nvec3 rayCast(vec3 eye, vec3 ref, vec2 ndc) {\n    vec3 F = ref - eye;\n    vec3 R = normalize(cross(F, vec3(0, 1, 0)));\n    vec3 U = normalize(cross(R, F));\n    \n    vec3 V = U * length(F) * tan(FOVY * 0.5);\n    vec3 H = R * length(F) * tan(FOVY * 0.5) * float(iResolution.x) / iResolution.y;\n    \n    vec3 p = ref + ndc.x * H + ndc.y * V;\n    \n    return normalize(p - eye);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv = uv * 2.0 - vec2(1.0, 1.0);\n    \n    vec3 eye = vec3(0, 5.5, -35);\n    vec3 ref = vec3(0, 2.5, 0);\n    \n    vec3 rayDir = rayCast(eye, ref, uv);\n    vec3 lightPos = rotateY(vec3(0, 3.4, 18.0), sin(iTime * 0.5));\n\n    Intersection isect = sdf3D(rayDir, eye, lightPos);\n    \n\n    // Output to screen\n    fragColor = vec4(isect.color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdjcR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1026, 1026, 1048, 1048, 1272], [1274, 1274, 1296, 1296, 1439], [1441, 1441, 1470, 1497, 2351], [2497, 2497, 2525, 2525, 2571], [2720, 2720, 2749, 2749, 2799], [2801, 2801, 2825, 2825, 2908], [2911, 2911, 2950, 2950, 3358], [3360, 3360, 3379, 3379, 3694], [3809, 3828, 3868, 3868, 3901], [3903, 3919, 3956, 3983, 4119], [4121, 4148, 4175, 4175, 4216], [4218, 4236, 4286, 4330, 5641], [5643, 5643, 5670, 5713, 6517], [6519, 6533, 6576, 6576, 6827], [6829, 6829, 6897, 6897, 7192], [7194, 7194, 7237, 7237, 7461], [7463, 7463, 7535, 7535, 7939], [7941, 7941, 8017, 8017, 8319], [8321, 8321, 8352, 8352, 8435], [8437, 8437, 8483, 8483, 8792], [8794, 8794, 8821, 8821, 9024], [9026, 9026, 9136, 9136, 9911], [9914, 9914, 9959, 9959, 10330], [10338, 10338, 10417, 10417, 10683], [10686, 10686, 10717, 10717, 10967], [10970, 10970, 11025, 11025, 11477], [11479, 11507, 11551, 11551, 11882], [11885, 11885, 11942, 11992, 12384]], "test": "error"}
{"id": "tdjcWG", "name": "Penumbra Shadows Approx", "author": "sanjanarao", "description": "CIS461 University of Pennsylvania\n\n", "tags": ["cis461"], "likes": 2, "viewed": 33, "published": "Public", "date": "1587370977", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int RAY_STEPS = 256;\nconst vec3 lightPos = vec3(15., 20., -20.);\nconst vec3 eyePos = vec3(0.0, 2., -30.0);\nconst vec3 refPos = vec3(0., 2.5, 0.);\nconst float PI = 3.14159265359;\nconst float FOVY = 19.5 * PI / 180.;\n\n// The higher the value, the smaller the penumbra\nconst float SHADOW_HARDNESS = 10.0;\n\nstruct Intersection\n{\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n};\n\n/***************** BASIC SCENE SET UP *******************/\n    \n#define FLOOR_SDF plane(pos, vec4(0, 1, 0, 2.5));\n#define BACK_WALL_SDF plane(pos, vec4(0, 0, -1, 5));\n#define RIGHT_SPHERE_SDF sphere(pos + vec3(0., 2.5, 0.), 3., vec3(7.0, 7., 3));\n#define GROUND_SPHERE_SDF sphere(pos + vec3(0., 2.5, 0.), 3., vec3(0.0, 3., 0.));\n#define LEFT_SPHERE_SDF sphere(pos + vec3(0, 2.5, 0.), 3., vec3(-5.0, 7.0, -5.0));\n \nconst int FLOOR_ID = 0;\nconst int RED_WALL_ID = 1;\nconst int GREEN_WALL_ID = 2;\nconst int BACK_WALL_ID = 3;\nconst int GROUND_SPHERE_ID = 5;\nconst int RIGHT_SPHERE_ID = 6;\nconst int LEFT_SPHERE_ID = 7;\n\nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\nfloat plane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sphere(vec3 p, float r, vec3 c) {\n    return distance(p, c) - r;\n}\n\nfloat sceneMap3D(vec3 pos) {\n    float flr = FLOOR_SDF;\n    float back_wall = BACK_WALL_SDF;\n    float ground_sphere = GROUND_SPHERE_SDF;\n    float right_sphere = RIGHT_SPHERE_SDF;\n    float left_sphere = LEFT_SPHERE_SDF;\n    return min(back_wall, \n       min(flr, min(ground_sphere, min(right_sphere, left_sphere))));\n}\n\nvoid sceneMap3D(vec3 pos, out float t, out int obj) {\n    t = FLOOR_SDF;\n    obj = FLOOR_ID;\n\n    float t2 = BACK_WALL_SDF;\n    if (t2 < t) {\n        t = t2;\n        obj = BACK_WALL_ID;\n    }\n    t2 = GROUND_SPHERE_SDF;\n    if (t2 < t) {\n        t = t2;\n        obj = GROUND_SPHERE_ID;\n    }\n    t2 = RIGHT_SPHERE_SDF\n    if (t2 < t) {\n        t = t2;\n        obj = RIGHT_SPHERE_ID;\n    }\n    t2 = LEFT_SPHERE_SDF;\n    if (t2 < t) {\n        t = t2;\n        obj = LEFT_SPHERE_ID;\n    }\n}\n\n/***************** RAY MARCHING LOGIC *******************/\n\nvec3 rayCast(vec3 eye, vec3 ref, vec2 uv) {\n    \n    float len = tan(FOVY) * distance(eye, ref);\n    vec3 H = normalize(cross(vec3(0.0, 1.0, 0.0), ref - eye));\n    vec3 V = normalize(cross(H, eye - ref));\n    V *= len;\n    H *= len * iResolution.x / iResolution.y;\n    vec3 p = ref + uv.x * H + uv.y * V;\n    return normalize(p - eye);\n}\n\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj)\n{\n    t = 0.001;\n    for(int i = 0; i < RAY_STEPS; ++i)\n    {\n        vec3 pos = origin + t * dir;\n        float m;\n        sceneMap3D(pos, m, hitObj);\n        if(m < 0.01) { return; }\n        t += m;\n    }\n    t = -1.0;\n    hitObj = -1;\n}\n\n/***************** EFFECTS *******************/\n\nfloat shadow(vec3 dir, vec3 origin, float min_t) {\n    float res = 1.0;\n    float t = min_t;\n    for(int i = 0; i < RAY_STEPS; ++i) {\n        float m = sceneMap3D(origin + t * dir);\n        if(m < 0.0001) {\n            return 0.0;\n        }\n        res = min(res, SHADOW_HARDNESS * m / t);\n        t += m;\n    }\n    return res;\n}\n\n/***************** MATERIALS *******************/\n\nvec3 computeNormal(vec3 pos)\n{\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( sceneMap3D(pos + epsilon.yxx) - sceneMap3D(pos - epsilon.yxx),\n                            sceneMap3D(pos + epsilon.xyx) - sceneMap3D(pos - epsilon.xyx),\n                            sceneMap3D(pos + epsilon.xxy) - sceneMap3D(pos - epsilon.xxy)));\n}\n\n\nvec3 computeMaterial(int hitObj, vec3 p, vec3 nor, vec3 lightDir, vec3 view) {\n    float lambert = max(0., dot(lightDir, nor));\n    if (hitObj == GROUND_SPHERE_ID) { return vec3 (0.596, 1., 0.596) * lambert; }\n    if (hitObj == LEFT_SPHERE_ID) { return vec3 (1, 0.549, 0.412) * lambert; } \n    if (hitObj == RIGHT_SPHERE_ID) { return vec3 (0., 0.6, 1.) * lambert; } \n\n    return vec3(0.15, 0.15, 1.0) * lambert;        \n        \n}\n\n/***************** BASIC FUNCTIONALITY *******************/\n\n\nIntersection sdf3D(vec3 dir, vec3 eye)\n{\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj);\n\n    vec3 isect = eye + t * dir;\n    vec3 nor = computeNormal(isect);\n    vec3 currLight = lightPos + sin(iTime * 0.75) * lightPos;\n    \n   float radius = 5.;\n   \n    float x  = 5. + radius * cos(iTime);\n    float z  = -24. + radius * sin(iTime);\n      \n    \n    vec3 lightDir = normalize(vec3(x, 20., z) - isect);\n    \n        \n    vec3 surfaceMaterial = computeMaterial(hitObj, isect, nor, lightDir, normalize(eye - isect));\n\n    surfaceMaterial = surfaceMaterial * shadow(lightDir, isect, 0.1);\n    \n    return Intersection(t, surfaceMaterial, isect, hitObj);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //Convert to range [-1,1]\n    uv = uv * 2.0 - vec2(1.);\n    \n    vec3 eye = eyePos;\n    vec3 ref = refPos;\n\n    vec3 dir = rayCast(eye, ref, uv);\n    \n    Intersection isect = sdf3D(dir, eye);\n     \n    // Output to screen\n    fragColor = vec4(isect.color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdjcWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1008, 1008, 1039, 1039, 1122], [1124, 1124, 1155, 1181, 1212], [1214, 1214, 1253, 1253, 1286], [1288, 1288, 1316, 1316, 1608], [2158, 2158, 2201, 2201, 2495], [2498, 2498, 2562, 2562, 2800], [2851, 2851, 2901, 2901, 3180], [3233, 3233, 3263, 3263, 3582], [3585, 3585, 3663, 3663, 4015], [4079, 4079, 4119, 4119, 4745], [4747, 4747, 4804, 4804, 5117]], "test": "valid"}
{"id": "tdjczc", "name": "Rounded Rectangle Demo", "author": "hyouka", "description": "demo to show the rounded rectangle and moving along the shape", "tags": ["newbie"], "likes": 0, "viewed": 68, "published": "Public", "date": "1587111684", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926\n#define W 0.4\n#define H 0.4\n#define R 0.1\n#define T 0.02\n\n#define LH (H - R * 2.0)\n#define LR (PI * R / 2.0)\n#define LW (W - R * 2.0)\n\n\n\nfloat roundedRectangle (vec2 coord, vec2 size, float radius, float thickness)\n{\n    vec2 halfsize = size / 2.0;\n    halfsize = halfsize - vec2(radius + thickness / 2.0, radius + thickness / 2.0);\n\n    float d = length( max( abs(coord), halfsize ) - halfsize) - radius;\n    return smoothstep(thickness / 2.0, 0.0, abs( d - thickness / 2.0 ) );\n}\n\n\nfloat circle (vec2 coord, float radius)\n{\n    return smoothstep( 0.001, 0.0, length(coord) - radius );\n} \nvec2 trajectory(float l)\n{\n    while (l >= LH + LR + LW + LR + LH + LR + LW + LR) {\n        l = l - (LH + LR + LW + LR + LH + LR + LW + LR);\n    }\n\n    // may use `step` to optimize\n    // TODO: figure out a simpler way to represent the trajectory function\n    if (0.0 <= l && l < LH) {\n        return vec2( W / 2.0, - H / 2.0 + R )\n             + vec2( 0.0, l );\n    }\n\n    else if ( LH <= l && l < LH + LR ) {\n        l = l - LH;\n        return vec2( W / 2.0 - R, H / 2.0 - R)\n             + vec2( R * cos( l / R ), R * sin( l / R ) );\n    }\n\n    else if ( LH + LR <= l && l < LH + LR + LW) {\n        l = l - LH - LR;\n        return vec2( LW / 2.0 , H / 2.0 )\n             - vec2( l , 0.0 );\n    }\n\n    else if ( LH + LR + LW <= l && l < LH + LR + LW + LR ) {\n        l = l - LH - LW;\n        return vec2( - W / 2.0 + R, H / 2.0 - R )\n             + vec2( R * cos( l / R ), R * sin( l / R ) );\n    }\n\n    else if ( LH + LR + LW + LR <= l && l < LH + LR + LW + LR + LH ) {\n        l = l - LH - LW - LR - LR;\n        return vec2( - W / 2.0, H / 2.0 - R )\n             + vec2( 0, - l );\n    }\n\n    else if ( LH + LR + LW + LR + LH <= l && l < LH + LR + LW + LR + LH + LR ) {\n        l = l - (LH + LW + LH);\n        return vec2( - W / 2.0 + R, - H / 2.0 + R )\n             + vec2( R * cos( l / R ), R * sin( l / R ) );\n    }\n\n    else if ( LH + LR + LW + LR + LH + LR <= l && l < LH + LR + LW + LR + LH + LR + LW ) {\n        l = l - (LH + LR + LW + LR + LH + LR);\n        return vec2( - W / 2.0 + R, - H / 2.0 )\n             + vec2( l, 0.0 );\n    }\n\n    else if ( LH + LR + LW + LR + LH + LR + LW <= l && l < LH + LR + LW + LR + LH + LR + LW + LR ) {\n        l = l - (LH + LW + LH + LW);\n        return vec2( W / 2.0 - R, - H / 2.0 + R )\n             + vec2( R * cos( l / R ), R * sin( l / R ) );\n    }\n\n    return vec2( W / 2.0, - H / 2.0 + R )\n         + vec2( 0.0, 0.0 );\n}\n\n\nvec2 differential(float l) {\n    return trajectory(l + 0.001) - trajectory(l);\n}\n\nfloat distanceFunction(vec2 pos) {\n    if ( W / 2.0 - T / 2.0 < pos.x\n      && pos.x < W / 2.0 + T / 2.0\n      && 0.0 < pos.y\n      && pos.y < LH / 2.0)\n    {\n        return pos.y;\n    }\n    else if ( pos.y > LH / 2.0 && pos.x > H / 2.0 - R )\n    {\n        pos = pos - vec2(LW / 2.0, LH / 2.0);\n        return acos(dot(pos, vec2(1., 0.)) / length(pos)) * R + LH / 2.0;\n    }\n    else if ( pos.y > 0.0 && 0. < pos.x && pos.x < LW / 2.0 )\n    {\n        return LW / 2.0 - pos.x + LH / 2.0 + LR;\n    }\n\n    return 0.0;\n}\n\n\n// 三角波\nfloat period(float phase, float p, float t)\n{\n    float a = LH + LR + LW + LR + LH + LR + LW + LR;\n\n    float scaleT = (t - phase) / p;\n\n    // x \\in [0, 1)\n    float x = fract(scaleT);\n\n    return a * x;\n}\n\n// 正弦波\n// float period()\n// {\n//     return ;\n// }\n\n\nfloat colors(float l)\n{\n    return l;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 pos = uv - vec2(0.5, 0.5);\n\n    // Time varying pixel color\n    float colRoundedRectangle = roundedRectangle(pos, vec2(0.4, 0.4), 0.1, 0.02);\n\n    float colStart = circle(pos - trajectory(period(0.0, 3.0, iTime)), 0.01);\n    float colEnd = circle( pos - trajectory(period(0.1, 3.0, iTime)), 0.01);\n\n    float colStart2 = circle(pos - trajectory(period(1.5, 3.0, iTime)), 0.01);\n    float colEnd2 = circle(pos - trajectory(period(1.6, 3.0, iTime)), 0.01);\n\n    // float col = colCircle;\n    float col = colRoundedRectangle * (colStart + colEnd + colStart2 + colEnd2 + distanceFunction(pos) * 2.0);\n\n    // Output to screen\n    fragColor = vec4(col, col / 2.0, 0.0, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdjczc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[158, 158, 237, 237, 502], [505, 505, 546, 546, 609], [611, 611, 637, 637, 2485], [2488, 2488, 2516, 2516, 2568], [2570, 2570, 2604, 2604, 3086], [3089, 3102, 3147, 3147, 3308], [3369, 3369, 3392, 3392, 3408], [3411, 3411, 3468, 3518, 4239]], "test": "valid"}
{"id": "tdjczK", "name": "Flying over the night city", "author": "ilyaev", "description": "Flying over the night city. Looks better fullscreen. Use mouse to control camera rotation. Move mouse to center to switch back to demo mode (Thanks to Fabrice for suggestion)", "tags": ["mouse", "grid", "night", "city", "generated", "fly"], "likes": 11, "viewed": 336, "published": "Public", "date": "1587360779", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define CAMERA_RANGE 8.\n#define CAMERA_TIME_SCALE .1\n#define SHOW_CARS true\n#define COLOR_WINDOW vec3(1., .9, .45)\n#define COLOR_WINDOW_TINT vec3(0.9, .3, .1)\n#define COLOR_BUILDING_BASE vec3(0.3,.5, .1)\n#define COLOR_ROAD_DELIMETER vec3(0.87, .72, .14)\n#define COLOR_ROAD vec3(0.1)\n#define COLOR_ROAD_SIDEWALK vec3(.7)\n#define COLOR_CAR_ROOF vec3(.3)\n#define MAX_STEPS 256\n#define MIN_DISTANCE 0.0001\n#define MAX_DISTANCE 10.\n#define defaultBaseSize .3\n#define defaultBaseSpacing 2.5\n#define bounds vec3(7.0, 7.0, 0.)\n#define BLD_RECT 1.\n#define BLD_HEX 2.\n#define BLD_TUBE 4.\n#define OBJ_FLOOR 3.\n#define OBJ_CAMERA 5.\n#define OBJ_DOME 6.\n#define OBJ_CAR 7.\n#define BULDING_BASE_SIZE .4\n#define PI 3.14\n\nvec2 mouse;\n\nfloat CELL_SIZE = (defaultBaseSize + defaultBaseSpacing/2.);\nfloat HALF_CELL_SIZE;\n\nstruct Camera {\n    float z;\n    float x;\n    float y;\n    float verticalAngle;\n    float horizontalAngle;\n    float rotation;\n};\n\nCamera camera;\n\nbool isScripted = true;\n\n// #iUniform float my_scalar = 1.0 in { 0.0, 5.0 } // This will expose a slider to edit the value\n\n\n\nstruct DistBuilding {\n    float d;\n    vec3 size;\n    float height;\n    vec3 q1;\n    float objId;\n};\n\nstruct DistResult {\n    float d;\n    vec3 id;\n    vec3 q1;\n    vec3 p;\n    float h;\n    float obj;\n    DistBuilding building;\n    DistBuilding cars;\n};\n\nstruct TraceResult {\n    vec3 id;\n    float dt;\n    float ds;\n    float h;\n    vec3 p;\n    vec3 q1;\n    DistResult dist;\n    float obj;\n};\n\n\n\n\nfloat hexDist(vec2 uv) {\n    uv = abs(uv);\n    return max(uv.x, dot(uv, normalize(vec2(1., 1.73))));\n}\n\n\nmat2 rot2d(float a) {\n    float ca = cos(a);\n    float sa = sin(a);\n    return mat2(vec2(sa, ca), vec2(-ca, sa));\n}\n\nfloat n21(vec2 n) {\n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat smoothNoise(vec2 uv) {\n    vec2 lv = smoothstep(0., 1., fract(uv));\n    vec2 id = floor(uv);\n\n    float bl = n21(id);\n    float br = n21(id + vec2(1.,0.));\n    float b = mix(bl, br, lv.x);\n\n    float tl = n21(id + vec2(0.,1.));\n    float tr = n21(id + vec2(1.,1.));\n    float t = mix(tl, tr, lv.x);\n\n    float n = mix(b, t, lv.y);\n    return n;\n}\n\nfloat noise(vec2 uv, int level) {\n    float n = 0.;\n    float d = 1.;\n    if (level > 0) {\n\t    n += smoothNoise(uv * 4.);\n    }\n    if (level > 1) {\n\t    n += smoothNoise(uv * 8.) * .5;\n        d += .5;\n    }\n    if (level > 2) {\n    \tn += smoothNoise(uv * 16.) * .25;\n        d += .25;\n    }\n    if (level > 3) {\n\t    n += smoothNoise(uv * 32.) * .125;\n        d += .125;\n    }\n    if (level > 4) {\n\t    n += smoothNoise(uv * 64.) * .025;\n        d += .0625;\n    }\n    return n / d;\n}\n\nvec3 getColorById(vec3 id) {\n    float n = max(.2, n21(vec2(id.x, id.y)));\n    vec3 rcol = vec3(n, fract(n*567.433), fract(n*1689.33));\n    return rcol;\n}\n\nvec3 withMouse(vec3 p) {\n        vec2 mouse = iMouse.xy/iResolution.xy;\n        float a = max(mouse.y, .505) * 3.14 * 2.;\n        p.yz *= rot2d(a);\n        float aa = mouse.x * 3.14 * 2.;\n        p.xy *= rot2d(aa);\n        return p;\n}\n\nvec3 setSceneAngle(vec3 p) {\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    p.yz *= rot2d(PI);\n    p.xy *= rot2d(camera.horizontalAngle);\n    p.x += HALF_CELL_SIZE;\n    p.y += HALF_CELL_SIZE;\n    // p.xy -= .77;\n    p += vec3(camera.x, camera.y, camera.z);\n    return p;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nDistBuilding distBuilding(vec3 q1, vec3 id) {\n    DistBuilding res;\n    float n = n21(id.xy);\n    float n1 = fract(n*4553.33);\n    float n2 = fract(n*145.33);\n\n    float obj = BLD_RECT;\n\n    if (n1 > .7) {\n        obj = BLD_HEX;\n    } else if (n2 > .8) {\n        obj = BLD_TUBE;\n    }\n\n    float baseSize = defaultBaseSize;\n\n    float h = baseSize;\n\n    if (obj == BLD_TUBE && n1 < .2 ) {\n        n = (sin(q1.x + (n1*50.)) * .5 + .5);\n    }\n\n    float ah = n * .5;\n\n    h += ah;\n    q1.z -= ah;\n    q1.z -= defaultBaseSize;\n\n    float d;\n\n\n\n    vec3 size = vec3(baseSize, baseSize, h);\n\n    if (obj == BLD_HEX) {\n        d = sdHexPrism(q1, vec2(size.x, size.z));\n    } else if (obj == BLD_TUBE) {\n        float tmp = q1.z;\n        q1.z = q1.y;\n        q1.y = tmp;\n        d = sdCappedCylinder(q1, baseSize, size.z);\n    } else {\n        if (n1 > .3) {\n            size.x *= .5;\n            size.y *= 1.5;\n        } else if (n2 > .5) {\n            size.y *= .5;\n            size.x *= 1.5;\n        }\n\n        if (n < .6) {\n            vec3 q2,nsize, nsize3, q3, d3;\n            if (n2 < .2 && size.x == size.y) {\n                d = sdBox(q1, size);\n                q2 = vec3(q1.x, q1.y, q1.z - size.z);\n                nsize = vec3(size.xy/1.5, size.z*2.);\n                q3 = vec3(q1.x, q1.y, q1.z - size.z - size.z / 1.8);\n                nsize3 = vec3(size.xy/(1.5*1.5), size.z*2. + size.z / 1.8);\n            } else {\n                q1 += vec3(0.1, -0.08, 0.);\n                d = sdBox(q1, size);\n                float extraH = size.z + size.z * n1;\n                q2 = vec3(q1.x - .18, q1.y + .18, q1.z - extraH);\n                nsize = vec3(size.xy, size.z + extraH);\n                if (n1 > .4) {\n                    nsize.xy = nsize.yx;\n                }\n            }\n\n            float d2 = sdBox(q2, nsize);\n            if (d2 < d) {\n                q1 = q2;\n                size = nsize;\n                d = d2;\n            }\n\n            if (nsize3.x != 0.) {\n                float d3 = sdBox(q3, nsize3);\n                if (d3 < d) {\n                    q1 = q3;\n                    size = nsize3;\n                    d = d3;\n                }\n            }\n\n        } else {\n            d = sdBox(q1, size);\n        }\n    }\n\n    res.d = d;\n    res.q1 = q1;\n    res.size = size;\n    res.objId = obj;\n    res.height = size.z;\n\n    return res;\n}\n\nDistBuilding distCars(vec3 po) {\n    DistBuilding res;\n\n\n    float carSize = .02;\n\n    po -= vec3(vec2(HALF_CELL_SIZE), carSize / 2.);\n\n    vec3 baseSpacing = vec3(CELL_SIZE);\n    vec3 rc1 = vec3(baseSpacing);\n    vec3 direction = vec3(-1, 0., 0.);\n\n    float t = iTime * 2.;\n\n    vec3 p = po;\n\n    p.x -= t;\n\n    vec3 id = round(p/rc1);\n    if (mod(id.y, 2.) == 0.) {\n        p = po;\n        p.x += t;\n        id = round(p/rc1);\n        direction.x = 1.;\n    }\n    float n = n21(id.xy);\n\n    vec3 q1 = p - rc1*vec3(id.xy, 0.);\n\n    q1.x -= (sin(iTime*7. * n)*.5 + .5)*HALF_CELL_SIZE;\n    q1.y -= (n - .5)/6.;\n\n    float d = sdBox(q1, vec3(carSize*2., carSize, carSize));\n\n    p = po;\n\n    p.y -= t;\n    vec3 direction2 = vec3(0., -1., 0.);\n\n    id = round(p/rc1);\n    if (mod(id.x , 2.) == 0.) {\n        p = po;\n        p.y += t;\n        id = round(p/rc1);\n        direction2.y = 1.;\n    }\n    n = n21(id.xy);\n\n    q1 = p - rc1*vec3(id.xy, 0.);\n\n    q1.y -= (sin(iTime*5. * n)*.5 + .5)*HALF_CELL_SIZE; //(n - .5)/CELL_SIZE;\n    q1.x -= (n - .5)/6.;\n\n    float d1 = sdBox(q1, vec3(carSize, carSize * 2., carSize));\n\n    res.d = min(d, d1);\n    res.q1 = d1 > d ? direction : direction2;\n    return res;\n}\n\n\nDistResult getDist(vec3 p) {\n    vec3 baseSpacing = vec3(defaultBaseSize + defaultBaseSpacing/2.);\n\n    vec3 l = bounds;\n    vec3 rc1 = vec3(baseSpacing);\n\n    vec3 id = round(p/rc1);\n\n    vec3 q1 = p - rc1 * clamp(id, -l, l);\n\n    DistBuilding building = distBuilding(q1, id);\n\n    float d = building.d;\n    float obj = building.objId;\n    q1 = building.q1;\n\n    // d = 1000000.;\n    float floord = p.z;\n\n    if (floord < d) {\n        obj = OBJ_FLOOR;\n    }\n\n    d = min(d, floord);\n\n    float skyD = -(length(p) - 30.);\n\n    if (skyD < d) {\n        obj = OBJ_DOME;\n        d = skyD;\n    }\n    DistBuilding cars;\n    if (SHOW_CARS) {\n        cars = distCars(p);\n        if (cars.d < d) {\n            d = cars.d;\n            obj = OBJ_CAR;\n        }\n    }\n\n    // if (!isScripted) {\n    //     vec3 cameraQ = vec3(-p.x + HALF_CELL_SIZE, -p.y + HALF_CELL_SIZE, p.z-.3) + vec3(camera.x, camera.y, camera.z);\n    //     cameraQ.xy *= rot2d(-camera.horizontalAngle);\n    //     float cd = sdBox(cameraQ, vec3(.1, .2, .1));\n    //     if (cd < d) {\n    //         p = cameraQ;\n    //         obj = OBJ_CAMERA;\n    //     }\n\n    //     d = min(d, cd);\n    // }\n\n\n    DistResult r;\n    r.d = d;\n    r.id = id;\n    r.q1 = q1;\n    r.building = building;\n    r.cars = cars;\n    r.p = p;\n    r.obj = obj;\n    return r;\n}\n\nTraceResult trace(vec3 ro, vec3 rd) {\n    float ds,dt;\n    float n;\n    vec3 id, shift;\n    vec3 p;\n    vec3 q1;\n\n    DistResult dist;\n\n\n    for(int i = 0 ; i < MAX_STEPS ; i++) {\n        p = ro + rd * ds;\n\n        if (isScripted) {\n            p = setSceneAngle(p);\n        } else {\n            p = withMouse(p);\n        }\n\n        dist = getDist(p);\n\n        dt = dist.d;\n        id = dist.id;\n        q1 = dist.q1;\n\n        ds += dt * .4;\n\n        if (abs(dt) < MIN_DISTANCE || dt > MAX_DISTANCE) {\n            break;\n        }\n    }\n\n    TraceResult res;\n\n    res.id = id;\n    res.dt = dt;\n    res.ds = ds;\n    res.p = p;\n    res.q1 = q1;\n    res.obj = dist.obj;\n    res.dist = dist;\n\n    return res;\n}\n\nvec3 getNormal(vec3 p, float d) {\n    vec2 e = vec2(0.00001, 0.);\n    vec3 n = d - vec3(\n        getDist(p - e.xyy).d,\n        getDist(p - e.yxy).d,\n        getDist(p - e.yyx).d\n    );\n    return normalize(n);\n}\n\n\nvec3 getCubeUV(vec3 p, vec3 normal, vec3 fsize) {\n    vec2 cuv = vec2(0.);\n    vec2 size = fsize.yz;\n    if (normal.z != 0.) {\n        // roof\n        cuv.xy = vec2(p.x, p.y);\n        size = fsize.xy;\n        // size.y = size.x;\n    }\n    if (normal.x != 0.) {\n        cuv.xy = vec2(p.y, p.z);\n        size = fsize.yz;\n    }\n    if (normal.y != 0.) {\n        cuv = vec2(p.x, p.z);\n        size = fsize.xz;\n    }\n\n    cuv /= size*2.;\n\n    cuv += vec2(.5, .5);\n\n    float r = size.x / size.y;\n\n    cuv -= vec2((r-1.)*.03, 0.);\n\n    cuv.x *= r;\n\n    return vec3(cuv, r);\n}\n\nvec2 getTubeUV(vec3 p, vec3 normal, vec2 size) {\n    float x = atan(p.x, p.z) / 6.28;\n    float y = p.y/size.y;\n\n    vec2 cuv = vec2(x, y);\n    if (normal.z != 0.) {\n        cuv = p.xz / size.x;\n    }\n    return cuv;\n}\n\nvec2 getHexUV(vec3 p, vec3 normal, vec2 size) {\n\n    float x = atan(p.x, p.y) / 6.28;\n    float y = p.z/size.y;\n\n    vec2 cuv = vec2(x, y);\n\n    if (normal.z != 0.) {\n        cuv = p.xy / size.x;\n    }\n\n    cuv += vec2(.5, .5);\n\n    return cuv;\n}\n\nvec4 allWindowsSkyscraperTexture(vec3 p, vec2 uv, vec3 normal, vec3 bid, float xr, float obj, float w, vec3 size) {\n    vec3 col = vec3(0.15);\n    vec2 wuv = uv;\n\n    float frameWidth = .03;\n\n    float frame;\n\n    float fogMultiplier = 0.;\n\n    if (obj == BLD_RECT) {\n        if (normal.z == 0.) {\n            frame = step(uv.x, frameWidth) +  step((1. - frameWidth) * xr, uv.x) + step((1. - frameWidth), uv.y);\n            frame += step(uv.y, frameWidth);\n        } else {\n            if (size.x > size.y) {\n                frame = step(uv.x, frameWidth - .15) +  step((.95 - frameWidth) * xr, uv.x) + step((1. - frameWidth), uv.y);\n            } else {\n                frame = step(uv.x, frameWidth) +  step((1. - frameWidth) * xr, uv.x) + step((1. - frameWidth), uv.y);\n            }\n            frame += step(uv.y, frameWidth);\n        }\n        uv *= 40. * w / xr;\n    } else if (obj == BLD_HEX) {\n        vec2 huv = uv;\n        if (normal.z == 0.) {\n            frame = step(fract(huv.x*6. + .53), .1);\n            frame += step(1.46, huv.y);\n        } else {\n            frame = step(1. - frameWidth * 2., hexDist((uv - .5)*rot2d(3.14)));\n        }\n        float scaleY = 20. * defaultBaseSize / xr;\n        uv *= vec2(scaleY*(6.*xr), scaleY);\n    } else if (obj == BLD_TUBE) {\n        vec2 huv = uv;\n        if (normal.z != 0.) {\n            float hl = length(huv);\n            frame = step(hl, 1.1) - step(hl, 1. - frameWidth * 2.);\n        } else {\n            frame = step(1. - frameWidth * 2., huv.y);\n        }\n        float scaleY = 20. * defaultBaseSize / xr;\n        uv *= vec2(scaleY*(6.*xr), scaleY);\n    }\n\n    col += frame;\n\n    if (normal.z == 0. && frame == 0.) {\n\n        float bn = fract(n21(bid.xy)*567.85);\n        float distToBuilding = distance(bid*CELL_SIZE, vec3(camera.x, camera.y, camera.z));\n\n        bool isLight = bn > .6 && distToBuilding > 6. ? true : false;\n        col = vec3(0.);\n        vec2 id = floor(uv);\n        uv = fract(uv);\n        float n = n21(id + bid.xy + 22.*floor(normal.xy));\n        float borders = (step(uv.x, .3) + step(uv.y, .3));\n        if (!isLight && n > .7 && abs(sin(bid.x + bid.y + fract(n*23422.)*110. + iTime/50.)) > fract(n*123.22)) {\n            col += COLOR_WINDOW * (1. - borders);\n            col += borders * COLOR_WINDOW_TINT;\n            fogMultiplier = .3;\n        } else {\n            if (borders != 0.) {\n                col = vec3(0.2);\n                if (isLight) {\n                    vec2 lights = vec2(sin(wuv.x + iTime + fract(bn * 3322.)*10.), sin(wuv.y + iTime + fract(bn * 3322.)*10.));\n                    if (bn > .85) {\n                        col.rb += lights;\n                    } else {\n                        col.rg += lights;\n                    }\n                }\n            }\n        }\n\n    }\n\n    return vec4(col, fogMultiplier);\n}\n\nvec3 domeTexture(vec3 p) {\n    vec3 q1 = p;\n    q1.yz *= rot2d(PI);\n    p = q1;\n    vec3 col = vec3(.01);\n    float x = acos(p.y/length(p));\n    float y = atan(p.z, p.x) / 6.28;\n    vec2 uv = vec2(x, y) + .5;\n\n    float rize = .1 + sin(iTime/6.)*.1;\n\n    vec2 muv = uv*vec2(1., 5.);\n    vec2 id = floor(muv);\n    muv = fract(muv) - .5;\n    muv += vec2(rize, 0.);\n\n    bool isMoon = false;\n\n    if (id.y == 2.) {\n        float muvl = length(muv);\n        float ml = muvl * 1.5;\n        vec3 mc = step(ml, .1) * vec3(noise(5. + muv*4. + iTime/50., 5));\n        if (ml > .1) {\n            mc += pow(.05 / muvl, 6.0);\n        }\n        if (ml < .15) {\n            isMoon = true;\n        }\n        col += mc * vec3(.9, .6, .1);\n    }\n\n    vec2 suv = uv * vec2(30., 150.);\n    vec2 sid = floor(suv);\n    suv = fract(suv) - .5;\n\n    float n = n21(sid);\n    if (n > .7 && !isMoon) {\n        col += step(length(suv + vec2(fract(n*3432.33) - .5, fract(n*78953.2) - .5)), .04*fract(n*123.123));\n    }\n\n    return col;\n}\n\nvec4 floorTexture(vec3 p, vec3 q1) {\n    vec3 col = vec3(0.);\n\n    float fogMultiplier = 0.;\n\n    vec2 uv = mod((p.xy - HALF_CELL_SIZE), CELL_SIZE) / CELL_SIZE - .5;\n    vec2 roadUV = mod((p.xy), CELL_SIZE) / CELL_SIZE;\n    vec2 blockID = floor(p.xy / CELL_SIZE);\n\n    if (abs(blockID.x) > bounds.x || abs(blockID.y) > bounds.y) {\n        return vec4(COLOR_BUILDING_BASE, fogMultiplier);\n    }\n\n    float roadX = step(BULDING_BASE_SIZE, roadUV.x) - step(1. - BULDING_BASE_SIZE, roadUV.x);\n    float roadY = step(BULDING_BASE_SIZE, roadUV.y) - step(1. - BULDING_BASE_SIZE, roadUV.y);\n\n    float road = max(roadX, roadY);\n\n\n    col += road * COLOR_ROAD;\n\n    // col.rg = roadUV;\n    // col.rg = uv;\n\n    vec2 baseUV = abs(uv);\n    col += step(max(baseUV.x, baseUV.y), BULDING_BASE_SIZE*.9) * COLOR_BUILDING_BASE;\n\n    uv = fract((uv + .26)*8.);\n\n    if (roadX == 0.) {\n        uv.x /= 4.;\n    }\n    if (roadY == 0.) {\n        uv.y /= 4.;\n    }\n\n    float delimeter = step(max(uv.x, uv.y), .1) * road;\n\n    fogMultiplier = delimeter * 1.5;\n\n    col += delimeter * COLOR_ROAD_DELIMETER;\n\n    if (col.x == 0.) {\n        col = COLOR_ROAD_SIDEWALK;\n    }\n\n    vec2 zebraUV = roadUV * 12.;\n    vec2 zebraID = floor(zebraUV);\n    zebraUV = fract(zebraUV);\n\n    float n = n21(blockID);\n\n    if (zebraID.x == 3. && road > 0. && n > .7) {\n        col += step(fract((zebraUV - .08)*vec2(1., 3.)).y + .1, .4);\n    }\n    if (zebraID.y == 3. && road > 0. && fract(n*123.33) > .7) {\n        col += step(fract((zebraUV - .08)*vec2(3., 1.)).x + .1, .4);\n    }\n\n    return vec4(col, fogMultiplier);\n}\n\nvec3 carTexture(TraceResult tr, vec3 normal) {\n    vec3 col = vec3(0.);\n    vec3 dir = tr.dist.cars.q1;\n\n    if (normal.y > 0. && dir.x == 0.) {\n        if (dir.y > 0.) {\n            col.r += 1.;\n        } else {\n            col.rgb += 1.;\n        }\n    } else\n    if (normal.y < 0. && dir.x == 0.) {\n        if (dir.y < 0.) {\n            col.r += 1.;\n        } else {\n            col.rgb += 1.;\n        }\n    } else\n\n    if (normal.x > 0. && dir.y == 0.) {\n        if (dir.x > 0.) {\n            col.r += 1.;\n        } else {\n            col.rgb += 1.;\n        }\n    } else\n    if (normal.x < 0. && dir.y == 0.) {\n        if (dir.x < 0.) {\n            col.r += 1.;\n        } else {\n            col.rgb += 1.;\n        }\n    } else {\n        col = COLOR_CAR_ROOF;\n    }\n\n    return col;\n}\n\nvec4 getBuildingTexture(TraceResult tr, vec3 normal) {\n    vec3 col = vec3(0.);\n\n    vec3 id = tr.id;\n    float objId = tr.obj;\n\n    vec3 p = tr.p;\n\n    float baseSize = normal.x == 0. ? tr.dist.building.size.x : tr.dist.building.size.y;\n\n    vec2 size = vec2(baseSize, tr.dist.building.height);\n\n    vec3 cubeUV = getCubeUV(tr.q1, normal, tr.dist.building.size);\n    vec2 uv = cubeUV.xy;\n\n    if (objId == BLD_HEX) {\n        uv = getHexUV(tr.q1, normal, size);\n    }\n    if (objId == BLD_TUBE) {\n        uv = getTubeUV(tr.q1, normal, size);\n    }\n\n    vec4 tc = allWindowsSkyscraperTexture(p, uv, normal, id, cubeUV.z, tr.obj, baseSize, tr.dist.building.size);\n\n    col += tc.rgb;\n\n    return vec4(col, tc.w);\n}\n\nvec2 getCameraIterationPosition(float iteration) {\n    if (iteration == 0.) {\n        return vec2(0.);\n    }\n    float n = n21(vec2(iteration));\n\n    float m = CAMERA_RANGE;\n    return round(vec2((n - .5) * m, (fract(n*113.43) - .5) * m));\n}\n\nvec3 cameraNextPosition() {\n    float t = iTime * CAMERA_TIME_SCALE;\n\n    vec2 center = vec2(.0);\n\n    float iterationDuration = 1.;\n\n    float iteration = floor(t / iterationDuration) + 1.;\n    float stepSize = 1.;\n\n    float cellStepSize = CELL_SIZE*stepSize;\n\n    vec2 prevPosition = getCameraIterationPosition(iteration - 1.)*cellStepSize;\n    vec2 nextPosition = getCameraIterationPosition(iteration)*cellStepSize;\n\n\n    float iterationTime = mod(t, iterationDuration) / iterationDuration;\n\n    float iterationSteps = 2.;\n    float stepDuration = iterationDuration / iterationSteps;\n    float iterationStep = floor(iterationTime / stepDuration) + 1.;\n\n    float iterationStepTime = mod(iterationTime, stepDuration) / stepDuration;\n\n    vec2 f = (nextPosition - prevPosition) * vec2(iterationStepTime);\n\n    if (iterationStep == 1.) {\n        f.y = 0.;\n    } else if (iterationStep == 2.) {\n        prevPosition.x = nextPosition.x;\n        f.x = 0.;\n    }\n\n\n    center = prevPosition + f;\n\n    return vec3(center, iteration*2. - iterationStep);\n}\n\nvoid scriptCamera() {\n    float t = iTime / 18.;\n\n    vec3 nextPosition = cameraNextPosition();\n\n    camera.x = nextPosition.x;\n    camera.y = nextPosition.y;\n\n    camera.z = .5 - cos(iTime/2.) * .5;\n\n    float verticalA = 1.0;\n    float horizA = 0.;\n    horizA = sin(t*8.);\n\n    verticalA = 1. - (sin(t*8.)*.02 + .01);\n\n    camera.rotation = sin(iTime) * PI/64.;\n\n    float n = n21(vec2(nextPosition.z + 13.));\n\n    float topDown = step(.2, n);\n\n    horizA  *= topDown;\n    verticalA *= topDown;\n    camera.z -= (topDown - 1.) * n/2.;\n\n    if (length(mouse.xy - .5) > .1) {\n        horizA = PI * mouse.x;\n        verticalA = PI/3. * mouse.y;\n    }\n\n    camera.horizontalAngle = horizA;\n    camera.verticalAngle = verticalA;\n}\n\nvoid setupCamera() {\n    camera.x = 0.;\n    camera.y = 0.;\n    camera.z = 0.;\n    camera.rotation = 0.;\n    scriptCamera();\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoords) {\n\n    HALF_CELL_SIZE = CELL_SIZE / 2.;\n\n    mouse = iMouse.xy/iResolution.xy;\n    if (mouse.x == 0. || mouse.y == 0.) {\n        mouse += .5;\n    }\n    isScripted = true; //!isKeyDown(Key_Shift);\n\n    setupCamera();\n\n    vec2 uv = ((fragCoords.xy / iResolution.xy) - .5) * vec2(iResolution.x / iResolution.y, 1.);\n\n    vec3 col = vec3(.0);\n\n    float a = 0.;\n\n    vec3 ro = vec3(0., 1. , 0.1);\n    vec3 lookat = vec3(0., 1.*camera.verticalAngle, 0.);\n\n    if (!isScripted) {\n        ro = vec3(0., 0. , -4.);\n        lookat = vec3(0., 0., 0.);\n    }\n\n    float zoom = .9;\n    vec3 up = vec3(0., 1., 0.);\n    up.xy *= rot2d(PI / 2. + camera.rotation);\n\n    vec3 f = normalize(lookat - ro);\n    vec3 r = normalize(cross(up, f));\n    vec3 u = cross(f, r);\n\n    vec3 c = ro + f * zoom;\n    vec3 I = c + uv.x * r + uv.y * u;\n\n    vec3 rd = normalize(I - ro);\n\n    TraceResult tr = trace(ro, rd);\n    float fogMultiplier = 0.;\n\n    if (tr.dt < MIN_DISTANCE) {\n        float objId = tr.obj;\n\n        vec3 normal;\n\n        if (objId == OBJ_FLOOR) {\n            vec4 fc = floorTexture(tr.p, tr.q1);\n            col += fc.rgb;\n            normal = vec3(0., -1., 0.);\n            fogMultiplier = fc.w;\n        } else if (objId == OBJ_CAMERA) {\n            col += mix(vec3(0., 0., 1.), vec3(1., 0., 0.), (.7 + tr.dist.p.y*10.));\n        } else if (objId == OBJ_DOME) {\n            col += domeTexture(tr.p);\n        } else if (objId == OBJ_CAR) {\n            normal = getNormal(tr.p, tr.dt);\n            col += carTexture(tr, normal);\n            fogMultiplier = 2.;\n        } else {\n            normal = getNormal(tr.p, tr.dt);\n            vec4 bt = getBuildingTexture(tr, normal);\n            col += bt.rgb;\n            fogMultiplier = bt.w;\n        }\n\n    }\n\n    float d = length(tr.p - vec3(camera.x, camera.y, camera.z))/(1. + camera.z/8.);\n    float fog = (2.2) - d/1.8;\n\n    fragColor = vec4(min(vec3(1.), col), 1.);\n    if (tr.obj != OBJ_DOME) {\n        if (fogMultiplier != 0.) {\n             fragColor *= fog > -fogMultiplier ?  (1. - (fog < 0. ? abs(fog)/fogMultiplier : 0.)) : fog;\n        } else {\n            fragColor *= fog;\n        }\n\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdjczK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1474, 1474, 1498, 1498, 1576], [1579, 1579, 1600, 1600, 1694], [1696, 1696, 1715, 1715, 1784], [1786, 1786, 1814, 1814, 2138], [2140, 2140, 2173, 2173, 2626], [2628, 2628, 2656, 2656, 2782], [2784, 2784, 2808, 2808, 3018], [3020, 3020, 3048, 3048, 3292], [3294, 3294, 3325, 3325, 3412], [3414, 3414, 3466, 3466, 3573], [3576, 3576, 3612, 3612, 3885], [3887, 3887, 3932, 3932, 6250], [6252, 6252, 6284, 6284, 7455], [7458, 7458, 7486, 7486, 8767], [8769, 8769, 8806, 8806, 9475], [9477, 9477, 9510, 9510, 9688], [9691, 9691, 9740, 9740, 10260], [10262, 10262, 10310, 10310, 10480], [10482, 10482, 10529, 10529, 10728], [10730, 10730, 10845, 10845, 13566], [13568, 13568, 13594, 13594, 14576], [14578, 14578, 14614, 14614, 16158], [16160, 16160, 16206, 16206, 16946], [16948, 16948, 17002, 17002, 17660], [17662, 17662, 17712, 17712, 17903], [17905, 17905, 17932, 17932, 18955], [18957, 18957, 18978, 18978, 19683], [19685, 19685, 19705, 19705, 19810], [19813, 19813, 19869, 19869, 22013]], "test": "valid"}
{"id": "tdjczy", "name": "spiral 4 truchet -Robinsong", "author": "Robinsong", "description": "truchet spiral", "tags": ["spiraltruchet"], "likes": 3, "viewed": 95, "published": "Public", "date": "1586898978", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define CENTER (iResolution.xy / 2.0)\n#define PI 3.1415\n#define TAU (2.0 * PI)\n\n//Convert rectangular to polar coordinates\nvec2 rect_to_polar(vec2 rect) {\n    float r = log(length(rect)*10.);\n    float theta = atan(rect.y, rect.x);\n    \n    //Fix the coordinates so they go from 0 to 2PI\n    //instead of -PI to PI. These two lines are optional\n//    if (theta < 0.0)\n//        theta += TAU;\n    \n    return vec2(r, theta);\n}\n\nvec2 normalized_polar(vec2 coord) {\n    //Centered UV coordinates accounting for aspect ratio\n    \n    vec2 nCenter = vec2(CENTER.x,CENTER.y);\n    nCenter.x = CENTER.x+sin(iTime)*(iResolution.x/3.);\n    nCenter.y = CENTER.y+cos(iTime)*(iResolution.y/5.);\n\n    \n    vec2 uv = vec2(1.0,1.0);\n    uv.y = (coord.y - nCenter.y ) / iResolution.y;\n    uv.x = (coord.x - nCenter.x ) / iResolution.y;\n    \n    //Convert to polar. Normalize the angle component by\n    //dividing by a full circle.\n    vec2 polar = rect_to_polar(uv);\n    polar.y /= TAU;\n       \n    return polar;\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(234.34, 435.35));\n    p += dot(p, p+34.23);\n    return fract(p.x*p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n \tvec2 uv = fragCoord/iResolution.xy;\n   \n    uv = normalized_polar(fragCoord);\n    \n    float gp = uv.y;\n    float gx = uv.x;\n        \n    uv.x *= 5.;\n//    uv.x = fract(uv.x);\n    \n    uv.x = uv.x + sin(uv.y*TAU+iTime)*3.;\n   \n    uv.x = uv.x - iTime*3.;\n       \n    vec3 col = vec3(0,0,0);\n      \n\tcol.x = .4+sin(uv.x*TAU-(uv.y*TAU*5.))*.5;\n    col.x = clamp(col.x, 0., 1.);\n    col.x = min(col.x, gx*2.+3.);\n\n//    col.y = -20.+sin(uv.y*TAU*8.+iTime)*25.;\n//    col.y = clamp(col.y, 0., 1.);\n//    col.y = min(col.y, gx+.01);\n\n// truchet\n    uv.y -= iTime*.12;\n    float rep = 6.;\n    uv.y = mod(uv.y, rep/2.);\n    uv *= rep;\n    uv.y *= rep*2.;\n    uv.y = mod(uv.y, rep*2.);\n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    \n    float n = Hash21(id/rep);\n    \n    float width = .25;\n    \n    if(n<.5) gv.x *= -1.;\n    float d = abs(abs(gv.x+gv.y)-.5);\n    float mask = smoothstep(.01, -.01, d-width);\n    \n\tcol.x -= mask;\n\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdjczy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[80, 123, 154, 154, 425], [427, 427, 462, 520, 997], [999, 999, 1021, 1021, 1115], [1117, 1117, 1174, 1224, 2222]], "test": "valid"}
{"id": "tdjyR3", "name": "Eye Stimuli", "author": "Smake", "description": "Color flashes.\nMouse: X - speed of color changing, Y - freq of flash. Start from left bottom corner.\nCAUTION !!! Apply carefully at own risk !!!. \nIt may cause an epilepsy attack.", "tags": ["fx", "relax", "alert", "flashes", "psycho", "eyestimuli"], "likes": 0, "viewed": 66, "published": "Public", "date": "1587142795", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Color flashes.\n//Mouse: X - speed of color changing, Y - freq of flash. Start from left bottom corner.\n//CAUTION !!! Apply carefully at own risk !!!. \n//It may cause an epilepsy attack.\n\n// Nice color transitions\n// Mouse X - color change velocity\n// Mouse Y - flash frequency  \n\nvoid mainImage(out vec4 zyx, vec2 xy)\n{\n    vec2 x = iMouse.xy/iResolution.xy + 0.003;\n     \n    vec2 y = xy/iResolution.xy - 0.5;\n    \n    vec2 z = vec2 (y*(cos(60. * x.y * iTime + vec2 (0,.75))));\n    \n    vec3 xyz = vec3 (1.- length(z )) *\n               vec3 (.3+cos(3.26 * x.x *  iTime)/2.,  \n                     .6+cos(2.13 * x.x *  iTime)/2.,\n                     .3+cos(1.09 * x.x *  iTime)/2.);\n \n    zyx = vec4(xyz,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdjyR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[282, 282, 321, 321, 715]], "test": "valid"}
{"id": "tdlBRn", "name": "Ambient Occlusion Shangru", "author": "pandaleo", "description": "hw9", "tags": ["cis561"], "likes": 0, "viewed": 52, "published": "Public", "date": "1587612308", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat3 rotateY(float rad)\n{\n    return mat3(vec3(cos(rad), 0, -sin(rad)),\n                vec3(0, 1, 0),\n                vec3(sin(rad), 0, cos(rad))\n               );\n}\nmat3 rotateZ(float rad)\n{\n    return mat3(vec3(cos(rad), -sin(rad), 0),\n                vec3(sin(rad), cos(rad), 0),\n                vec3(0, 0, 1)\n               );\n}\nmat3 rotateX(float rad)\n{\n    return mat3(vec3(1, 0, 0),\n        \t\tvec3(0, cos(rad), -sin(rad)),\n                vec3(0, sin(rad), cos(rad))\n               );\n}\nmat3 scale(float a, float b, float c)\n{\n    return mat3(vec3(a, 0, 0), vec3(0, b, 0), vec3(0, 0, c));\n}\nmat3 scale(float a)\n{\n    return scale(a, a, a);\n}\nfloat sdfBox(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.) + length(max(d, 0.));\n}\nfloat sdfSphere(vec3 p)\n{\n    return length(p) - 0.5;\n}\nfloat sdfPlane(vec3 p)\n{\n    return dot(p, vec3(0, 0, 1));\n}\nvec2 closer(vec2 a, vec2 b)\n{\n    return a.x < b.x ? a: b;\n}\nfloat deg2rad(float r)\n{\n\treturn r / 180. * 3.14159;\n}\nvec2 map(vec3 pos) // find closest object\n{\n    vec3 sphereWorld = vec3(0.3, 0.3, -0.4);\n    vec3 posSphereModel = pos - sphereWorld; // position in sphere model space\n    vec2 sphereInfo = vec2(sdfSphere(posSphereModel), 1.);\n    \n    vec3 boxWorld = vec3(-0.35, -0.6, 0.3);\n    vec3 posBoxModel = inverse(rotateY(deg2rad(35.))) * (pos - boxWorld);\n    vec3 boxSize = vec3(0.2, 0.4, 0.2);\n    vec2 boxInfo = vec2(sdfBox(posBoxModel, boxSize), 2.);\n    \n    vec3 boxWorld2 = vec3(0.35, -0.8, 0.3);\n    vec3 posBoxModel2 = inverse(rotateY(deg2rad(60.))) * (pos - boxWorld2);\n    vec3 boxSize2 = vec3(0.22, 0.22, 0.22);\n    vec2 boxInfo2 = vec2(sdfBox(posBoxModel2, boxSize2), 8.);\n    \n    vec3 planeWorld1 = vec3(-1, 0, 0);\n    vec3 posPlaneModel1 = inverse(rotateY(3.14 / 2.)) * (pos - planeWorld1);\n    vec2 planeInfo1 = vec2(sdfPlane(posPlaneModel1), 3.);\n    \n    vec3 planeWorld2 = vec3(1, 0, 0);\n    vec3 posPlaneModel2 = inverse(rotateY(3. * 3.14 / 2.)) * (pos - planeWorld2);\n    vec2 planeInfo2 = vec2(sdfPlane(posPlaneModel2), 4.);\n    \n    vec3 planeWorld3 = vec3(0, 0, 0);\n    vec3 posPlaneModel3 = (pos - planeWorld3);\n    vec2 planeInfo3 = vec2(sdfPlane(posPlaneModel3), 5.);\n    \n    vec3 planeWorld4 = vec3(0, 1, 0);\n    vec3 posPlaneModel4 = inverse(rotateX(3. * 3.14 / 2.)) * (pos - planeWorld4);\n    vec2 planeInfo4 = vec2(sdfPlane(posPlaneModel4), 6.);\n    \n    vec3 planeWorld5 = vec3(0, -1, 0);\n    vec3 posPlaneModel5 = inverse(rotateX(3.14 / 2.)) * (pos - planeWorld5);\n    vec2 planeInfo5 = vec2(sdfPlane(posPlaneModel5), 7.);\n    \n    vec2 closest;\n    closest = closer(boxInfo, planeInfo1);\n    closest = closer(closest, planeInfo2);\n    closest = closer(closest, planeInfo3);\n    closest = closer(closest, planeInfo4);\n    closest = closer(closest, planeInfo5);\n    closest = closer(closest, boxInfo2);\n    return closest;\n}\nfloat fiveTapAO(vec3 p, vec3 n, float k) {\n    float aoSum = 0.0;\n    for(float i = 0.0; i < 5.0; ++i) {\n        float coeff = 1.0 / pow(2.0, i);\n        aoSum += coeff * (i * 0.15 - map(p + n * i * 0.15).x);\n    }\n    return 1.0 - k * aoSum;\n}\nvec2 calcIntersection(in vec3 ro, in vec3 rd){\n    float currentMinSdf = 0.002;\n    float t = 0.0; // distance from ro (ray origin)\n\tfloat resDistance = -1.;\n    float id = -1.;\n    for (int i = 0; i < 100; ++i){\n        if (currentMinSdf < 0.001 || t > 10.) break; // hit or exceed max distance\n\t   \tvec2 hitInfo = map(ro + rd * t); // hit object distance and id\n        currentMinSdf = hitInfo.x; // distance\n        t += currentMinSdf; // update current distance from ro\n        id = hitInfo.y;\n    }\n    if (t <= 10.) resDistance = t; // if in distance\n    else id = -1.; // no hit\n    return vec2(resDistance, id);\n}\nvec3 calcNormal(in vec3 pos){\n    \n\tvec3 dx = vec3(0.001, 0.0, 0.0);    \n\tvec3 dy = vec3(0.0, 0.001, 0.0);    \n\tvec3 dz = vec3(0.0, 0.0, 0.001);\n\tvec3 nor = vec3(\n\t    map(pos + dx).x - map(pos - dx).x,\n\t    map(pos + dy).x - map(pos - dy).x,\n\t    map(pos + dz).x - map(pos - dz).x\n    );\n\treturn normalize(nor);\n}\nvec3 render(vec2 res, in vec3 ro, in vec3 rd)\n{\n    float ambient = 0.05;\n    vec3 color = vec3(0);\n    float lightX = 0.5 * sin(iTime * 4.);\n    vec3 lightPos = vec3(lightX, 0.9, 0.8);\n    if (res.y > 0.) // id\n    {\n    \tvec3 pos = ro + rd * res.x;\n    \tvec3 norm = calcNormal(pos);\n    \tvec3 lightDir = normalize(lightPos - pos);\n        float match = max(0., dot(lightDir, norm) / pow(length(lightPos - pos), 0.3));\n        float ao = fiveTapAO(pos, norm, 2.);\n        if (res.y == 1.) color = ao * vec3(1., 0., 0.) * match + ambient;\n        else if (res.y == 2.) color = ao * vec3(0.4, 0.4, 0.4) * match + ambient;\n\t\telse if (res.y == 3.) color = ao * vec3(1, 0, 0) * match + ambient;\n        else if (res.y == 4.) color = ao * vec3(0, 1, 0) * match + ambient;\n\t\telse if (res.y == 5.) color = ao * vec3(1, 1, 1) * match + ambient;   \n        else if (res.y == 6.) color = ao * vec3(0.5, 0.5, 0.5) * match + ambient;\n\t\telse if (res.y == 7.) color = ao * vec3(1, 1, 1) * match + ambient;  \n\t\telse if (res.y == 8.) color = ao * vec3(1, 1, 1) * match + ambient;   \n    }\n    return color;\n}\nmat3 lookAt(in vec3 eye, in vec3 ref)\n{\n    vec3 front = normalize(ref - eye);\n    vec3 right = normalize(cross(front, vec3(0, 1, 0)));\n    vec3 up = normalize(cross(right, front));\n    return mat3(right, up, front);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n    vec3 eye = vec3(0, 0, 2), ref = vec3(0, 0, 0);\n    vec3 direction = normalize(lookAt(eye, ref) * vec3(p.xy, 1));\n    vec2 res = calcIntersection(eye, direction);\n    fragColor = vec4(render(res, eye, direction), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdlBRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 166], [167, 167, 192, 192, 333], [334, 334, 359, 359, 494], [495, 495, 534, 534, 598], [599, 599, 620, 620, 649], [650, 650, 680, 680, 773], [774, 774, 799, 799, 829], [830, 830, 854, 854, 890], [891, 891, 920, 920, 951], [952, 952, 976, 976, 1006], [1007, 1007, 1050, 1050, 2859], [2860, 2860, 2902, 2902, 3104], [3105, 3105, 3151, 3151, 3726], [3727, 3727, 3756, 3756, 4041], [4042, 4042, 4089, 4089, 5134], [5135, 5135, 5174, 5174, 5353], [5354, 5354, 5411, 5411, 5700]], "test": "error"}
{"id": "tdlBWH", "name": "Elders looking at the sky", "author": "maz", "description": "This is an experiment in creating a scene using layers of 2D distance functions. The code follows the design from here: https://www.shadertoy.com/view/Xds3zN. This was harder than I thought it would be :)", "tags": ["2d", "sdf", "characters"], "likes": 21, "viewed": 183, "published": "Public", "date": "1588190095", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// maz 2020\n// Experiment in creating a scene using layers of 2D distance functions\n\nfloat noise1(vec2 p)\n{\n   return fract(sin(p.x*p.y)*1175.5453123);\n}\n\nfloat noise2(vec2 p)\n{\n   return fract(sin(p.x*p.y+5209.)*1175.5453123);\n}\n\nfloat noise3(vec2 p)\n{\n   return fract(sin(p.x*p.y+1103.)*1175.5453123);\n}\n\n// smooth \"noise\", not that noisy...\nfloat noise(float t)\n{\n    return sin(t)*cos(t*4.0);\n}\n\n// rotate pos (x,y) by theta radians around the Z axis\nvec2 rot(float theta, vec2 pos)\n{\n    vec2 R1 = vec2(cos(theta), -sin(theta));\n    vec2 R2 = vec2(sin(theta),  cos(theta));\n    return vec2(dot(R1, pos), dot(R2, pos));\n}\n\n// mirrors pos (x,y) around the Y axis\nvec2 mirror(vec2 pos)\n{\n    return vec2(abs(pos.x), pos.y);\n}\n\n// operation \"union\"\n// v1 and v2 are (distance, color index) pairs\n// the union is determined by the pair with the smaller distance\nvec2 opU(in vec2 v1, in vec2 v2)\n{\n    return v1.x < v2.x? v1 : v2;\n}\n\n// operation \"front\"\n// v1 and v2 are (distance, color index) pairs\n// v2 replaces the color of v1 if v1.x is a distance outside the shape\nvec2 opF(in vec2 v1, in vec2 v2)\n{\n    return v1.x > 0.0? v2 : v1;\n}\n\n// returns negative distance to edge if inside; positive distance if outside\nfloat sdCircle(in vec2 p, in vec2 center, in float radius)\n{\n    return length(p - center) - radius; \n}\n\n// boundary test for super-ellipse\n// returns -1.0 if inside the ellipse and 1.0 if outside\nfloat bSuperEllipse(vec2 p, vec2 c, float a, float b, float n, float r)\n{\n    vec2 localp = p - c;\n    float v = pow(abs(localp.x/a), n) + pow(abs(localp.y/b), n);\n    float d = v - pow(r,n);\n    return mix(1.0, -1.0, step(0.0, -d));\n}\n\n// https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdEllipse(vec2 p, vec2 r)\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdArc(in vec2 pos, in float rOuter, in float rInner, in float arcAngleRad)\n{\n    pos.x = abs(pos.x); // mirror about y-axis\n    float theta = 0.5*(3.14 - arcAngleRad);\n    vec2 sc = vec2(cos(theta),sin(theta)); \n    float k = pos.x * sc.y - sc.x * pos.y; // cross product\n    float len = length(pos.xy); \n    float d = k < 0.? max(len - rOuter, -len + rInner) : 1e0;\n    return d;\n}\n\nfloat stemFn(float x, float p)\n{\n    return (p*x*x);\n}\n\nvec2 elder(in float id, in vec2 pos)\n{\n    float w = 0.1;\n    float wstems[5] = float[](0.4, 1.5, 0.05, -1.1, -0.2);\n    float ystems[5] = float[](1.5, 0.9, 2.0, 1.0, 1.6); \n\n    float blossom = 1e10;\n    float stem = 1e10;\n    for (int i = 0; i < 5; i++)\n    {\n        float ws = wstems[i]+0.1*sin(iTime);\n        float w1 = stemFn(pos.y, ws);\n        float l1 = pos.y > 0.0 && pos.y < ystems[i]? max(w1-pos.x, pos.x - w1 - w) : 1e10; \n\n        vec2 center = vec2(stemFn(ystems[i], ws), ystems[i]);\n        float s1 = sdCircle(pos, center, 0.3);\n        float noise = 0.01*(sin(10.0*pos.y)+cos(10.0*pos.x));\n        blossom = min(blossom, s1+noise);\n        stem = min(l1, stem);\n    }\n\n    float e3 = sdEllipse(pos-vec2(0.0, 0.05), vec2(0.6, 0.3));\n\n    float yoffset = 0.0;//0.05 * sin(iTime);\n    vec2 result = vec2(1e10);\n    result = opU(vec2(sdCircle(pos, vec2( 0.6 + yoffset,  0.6), 0.2),  2.0), result);\n    result = opU(vec2(sdCircle(pos, vec2(-0.6 + yoffset,  0.8), 0.15), 2.0), result);\n    result = opU(vec2(sdCircle(pos, vec2(-1.3 + yoffset,  0.4), 0.1),  2.0), result);\n    result = opU(vec2(sdCircle(pos, vec2(-0.1 + yoffset,  1.4), 0.1),  2.0), result);\n    result = opU(vec2(sdCircle(pos, vec2( 0.35 + yoffset, 1.2), 0.08), 2.0), result);\n    result = opU(vec2(sdCircle(pos, vec2(-0.35 + yoffset, 0.4), 0.08), 2.0), result);\n    result = opU(vec2(sdCircle(pos, vec2( 1.35 + yoffset, 0.4), 0.1),  2.0), result);\n    result = opF(result, vec2(blossom, 2.0));\n    result = opF(result, vec2(stem, 2.0));\n    result = opF(result, vec2(e3, 2.0));\n\n    float eye = sdCircle(mirror(pos), vec2(0.3, 0.1), 0.06);\n    result = opF(vec2(eye, 0.0), result);\n    \n    float lid = sdArc(rot(3.14, mirror(pos)- vec2(0.3, 0.17)), 0.2, 0.17, 1.0);\n    result = opF(vec2(lid, 0.0), result);\n\n    float mouth = sdEllipse(pos, vec2(0.13, 0.05));\n    result = opF(vec2(mouth, 0.0), result);\n\n    return result;\n}\n\n// Returns a color based on an index\nvec3 pallet(float id)\n{\n    vec3 colors[] = vec3[](\n        vec3(0.0, 0.0, 0.0), // 0\n        vec3(1.0, 1.0, 1.0), // 1\n        vec3(0.8, 0.8, 0.4), // 2\n        vec3(0.8, 0.6, 0.6), // 3\n        vec3(0.6, 0.2, 0.2), // 4\n        vec3(214.0, 228.0, 232.0)/255.0, // 5\n        vec3(0x13, 0x24, 0x34)/255.0, // 6\n        vec3(40.0, 75.0, 90.0)/255.0, // 7\n        vec3(21.0, 50.0, 70.0)/255.0 // 8\n    );\n\n    return colors[int(id)];\n}\n\nvec4 layerElders( in vec2 pos )\n{\n    vec2 p[] = vec2[](\n        pos + vec2( 0.0, -0.5),\n        pos + vec2(-2.2, 1.5),\n        pos + vec2(2.8, 3.0) \n        );\n\n    float r[] = float[](0.1, 0.1, -0.05);\n\n    vec2 res = vec2(1e10);\n    for (int i = 0; i < 3; i++)\n    {\n        float id = float(i);\n        float offset = 0.1*sin(id+iTime);\n        vec2 p = rot(r[i]+offset, p[i]);\n        res = opU(elder(id, p), res);\n    }\n \n    float base = 1e10;\n    for (int i = 0; i < 3; i++)\n    {\n        float noise = 0.05*(sin(6.0*pos.y) + cos(6.0*pos.x));\n        float val = p[i].y + p[i].x * p[i].x - 1.0;\n        base = min(base, val+noise);\n    }\n    vec2 body = abs(mod(res.x, 0.35)) > 0.05? vec2(base, 4.0) : vec2(base, 3.0);\n    res = opF(res, body);\n    return vec4(pallet(res.y), 1.0-step(0.0, res.x)); \n}\n\nvec4 layerMoon( in vec2 pos )\n{\n    vec2 moon = vec2(1e10,0.0);\n    for (float i = 0.0; i < 10.0; i++)\n    {\n        float noise = 0.01*sin(6.0*pos.y) + 0.01*cos(6.0*pos.x);\n        float d = sdCircle(pos, vec2(-3.5, 3.5), 0.6 + i + 0.5*sin(i)) + noise;\n        float c = mix(5.0, mod(i,3.0)+6.0, step(1.0, i));\n        moon = opF(moon, vec2(d, c));\n    }\n    return vec4(pallet(moon.y), 1.0);\n}\n\nvec4 motes(in vec2 pos)\n{\n    float cs = 0.9;\n    vec2 cell = floor(pos/cs)*cs;\n    float d = 1e10;\n    float size = 1e10;\n    for (float r = -1.0; r <= 1.0; r += 1.0 )\n    {\n      for (float c = -1.0; c <= 1.0; c += 1.0 )\n      {\n        vec2 offset = cs * vec2(r,c);\n        vec2 bl = cell + offset;\n        vec2 tr = cell + offset + vec2(cs,cs);\n        vec2 vel = noise(bl.x) * vec2(0.05*sin(iTime), 0.15*sin(iTime*noise(bl.y)));\n        vec2 center = mix(bl, tr, vec2(noise2(bl)+vel));\n        float size = clamp(noise(bl.y), 0.3, 1.0)+sin(2.0*noise(bl.y)*iTime+noise(bl.x)*10.0)*0.15;\n        \n        float se = bSuperEllipse(pos, center, 1.0, 0.75, 0.3, size);\n        d = min(d, se);\n      }\n    }\n    return d < 0.0? vec4(pallet(5.0), 0.5) : vec4(0.0);\n}\n\nvec3 scene( in vec2 pos )\n{\n    vec4 background = vec4(0.0);\n    vec4 l1 = layerMoon(pos); \n    vec4 l2 = motes(pos);\n    vec4 l3 = layerElders(pos);\n\n    vec3 color = mix(background.xyz, l1.xyz, l1.w);\n    color = mix(color, l2.xyz, l2.w); \n    color = mix(color, l3.xyz, l3.w); \n    return color;\n}\n\n#define ZERO min(0, iFrame)\n#define AA 4\n// anti-aliasing+gamma correction from: \n// https://www.shadertoy.com/view/Xds3zN\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates to 2D world coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else\n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n\n        float zPlane = 2.0;\n        vec3 rd = normalize( vec3(p,0.5) );\n        vec3 pos = rd*(zPlane/rd.z);\n        vec3 col = scene(pos.xy);\n\n\t\t// gamma\n        col = pow( clamp(col, 0.0, 1.0), vec3(0.4545) );\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    fragColor = vec4( tot, 1.0 );\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdlBWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[85, 85, 107, 107, 153], [155, 155, 177, 177, 229], [231, 231, 253, 253, 305], [307, 344, 366, 366, 398], [400, 455, 488, 488, 625], [627, 666, 689, 689, 727], [729, 862, 896, 896, 931], [933, 1072, 1106, 1106, 1140], [1142, 1219, 1279, 1279, 1322], [1324, 1416, 1489, 1489, 1651], [1653, 1728, 1761, 1761, 1850], [1852, 1852, 1934, 1934, 2240], [2242, 2242, 2274, 2274, 2296], [5491, 5491, 5522, 5522, 5886], [5888, 5888, 5913, 5913, 6652], [6654, 6654, 6681, 6681, 6954]], "test": "error"}
{"id": "tdlBzH", "name": "Library Lost and Found", "author": "dr2", "description": "Transient knowledge ... ", "tags": ["pattern", "architecture", "stairs", "book"], "likes": 15, "viewed": 289, "published": "Public API", "date": "1587722528", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Library Lost and Found\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Alternating regular and pano images; mouseable - click in upper-right corner to\n  switch image type, lower-right corner for monochrome image.\n*/\n\nfloat PrCylDf (vec3 p, float r, float h);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nfloat Hashfv2 (vec2 p);\nfloat Hashfv3 (vec3 p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val);\n\nvec3 bGrid, qHit, ltPos, ltAx, cId;\nfloat dstFar, tCur, tDir, stAng;\nint idObj, stLib;\nbool isPano, colImg;\nconst int idFlr = 1, idCol = 2, idRail = 3, idStr = 4, idShlf = 5, idBk = 6, idLt = 7;\nconst float pi = 3.14159;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qr;\n  float dMin, d, r, a, s;\n  dMin = dstFar;\n  p -= bGrid * (cId + 0.5);\n  r = length (p.xz);\n  q = p;\n  q.y = 0.5 * bGrid.y - 0.3 - abs (p.y);\n  d = max (q.y, 9.8 - r);\n  DMINQ (idFlr);\n  if (stLib >= 3) {\n    q.xz = abs (q.xz) - 15.;\n    q.y -= 0.1;\n    d = min (length (q.xz) - 0.6, PrCylDf (q.xzy, 1., 0.1));\n    DMINQ (idCol);\n  }\n  if (stLib >= 4) {\n    qr = p;\n    qr.xz = Rot2D (qr.xz, stAng);\n    q = qr;\n    q.xy = Rot2D (q.xy - vec2 (10., -10.), 0.25 * pi);\n    s = mod (q.x, sqrt (2.));\n    d = 0.5 * max (max (q.y - min (s, sqrt (2.) - s), abs (q.z) - 2.), -0.2 - q.y);\n    DMINQ (idStr);\n  }\n  if (stLib >= 5) {\n    q = qr;\n    d = max (length (vec2 (r - 10.2, abs (q.y + 6.) - 1.3)) - 0.13, 2. - abs (qr.z));\n    d = min (d, PrCylDf (vec3 (abs (q.x) - 10., q.y + 7.1, abs (q.z) - 2.).xzy, 0.25, 2.8));\n    q.xz = Rot2D (q.xz, 2. * pi / 32.);\n    a = (r > 0.) ? atan (q.z, - q.x) / (2. * pi) : 0.;\n    q.xz = Rot2D (q.xz, 2. * pi * (floor (16. * a + 0.5) / 16.));\n    d = min (d, PrCylDf ((q + vec3 (10.2, + 7.2, 0.)).xzy, 0.13, 2.5));\n    q = qr;\n    q.xy = Rot2D (q.xy, 0.25 * pi);\n    d = min (d, max (length (vec2 (abs (q.y - 2.9) - 0.9, abs (q.z) - 2.)) - 0.13, abs (qr.x) - 10. ));\n    q = qr;\n    q.x += 20.;\n    q.xy = Rot2D (q.xy, 0.25 * pi);\n    d = min (d, max (length (vec2 (abs (q.y - 2.9) - 0.9, abs (q.z) - 2.)) - 0.13, abs (qr.x) - 10.));\n    DMINQ (idRail);\n  }\n  if (stLib >= 6) {\n    q = p;\n    q.y -= -6.7;\n    s = min (abs (q.x), abs (q.z));\n    d = max (max (max (abs (r - 17.) - 1., abs (q.y) - 3.), 5. - s),\n       - max (max (abs (r - 16.) - 1.5, abs (abs (q.y) - 1.4) - 1.2), 5.5 - s));\n    DMINQ (idShlf);\n  }\n  if (stLib == 7 && q.y > 0. || stLib >= 8) {\n    d = max (max (abs (r - 17.) - 0.5, abs (q.y) - 2.8), 5.2 - s);\n    DMINQ (idBk);\n  }\n  if (stLib >= 2) {\n    q = p;\n    q.y -= 9.4;\n    d = length (vec2 (r - 11., q.y)) - 0.3;\n    q.xz = abs (q.xz) - 0.5 * bGrid.xz;\n    d = min (d, PrCylDf (q.xzy, 2., 0.3));\n    DMINQ (idLt);\n  }\n  return dMin;\n}\n\nvoid SetGConf ()\n{\n  stAng = 0.5 * pi * floor (4. * Hashfv2 (cId.xz + vec2 (27.1, 37.1)));\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p, rdi, s, cIdP;\n  float dHit, d, eps;\n  eps = 0.0005;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  rdi = 1. / rd;\n  cIdP = vec3 (-99.);\n  dHit = eps;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    p = ro  + dHit * rd;\n    cId = floor (p / bGrid);\n    if (cId != cIdP) {\n      SetGConf ();\n      cIdP = cId;\n    }\n    d = ObjDf (p);\n    s = (bGrid * (cId + step (0., rd)) - p) * rdi;\n    d = min (d, abs (Minv3 (s)) + eps);\n    dHit += d;\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjAO (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float ao, d;\n  ao = 0.;\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    d = 0.1 + float (j) / 8.;\n    p = ro + d * rd;\n    cId = floor (p / bGrid);\n    SetGConf ();\n    ao += max (0., d - 3. * ObjDf (p));\n  }\n  return 0.5 + 0.5 * clamp (1. - 0.2 * ao, 0., 1.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, bgCol, ltVec, roo, vn;\n  vec2 vf;\n  float dstObj, ltDist, ao, atten, r, s, a, y;\n  int idObjT;\n  bgCol = vec3 (0.05);\n  roo = ro;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    vf = vec2 (0.);\n    if (idObj == idFlr || idObj == idShlf || idObj == idBk) {\n      r = length (qHit.xz);\n      a = (r > 0.) ? atan (qHit.z, - qHit.x) / pi + 0.5 : 0.;\n    }\n    if (idObj == idFlr) {\n      s = length (abs (qHit.xz) - 20.);\n      if (vn.y > 0.99) {\n        col4 = vec4 (0.4, 0.2, 0.1, 0.1) * (1. - 0.3 * Fbm2 (2. * ro.xz));\n        if (stLib >= 4) col4.rgb *= 0.5 + 0.5 * SmoothBump (0.03, 0.97, 0.01, mod (r, 1.));\n        if (stLib >= 2) col4.rgb *= ((1. - 0.3 * smoothstep (1., 5., s)) +\n           (1. - 0.3 * smoothstep (1., 5., r - 11.)));\n        vf = vec2 (32., 1.);\n      } else if (vn.y < -0.99) {\n        col4 = vec4 (vec3 (0.8), -1.);\n        if (stLib >= 3) col4.rgb *= (1. - 0.4 * smoothstep (3., 7., s)) *\n           (1. - 0.4 * smoothstep (0., 4., r - 11.));\n        else col4 = vec4 (vec3 (0.4), 0.1);\n      } else {\n        col4 = vec4 (0.3, 0.3, 0.7, 0.1);\n        vf = vec2 (32., 1.);\n      }\n    } else if (idObj == idCol) {\n      col4 = vec4 (0.7, 0.7, 0.6, 0.05);\n      if (abs (vn.y) < 0.1) {\n        vn.y += 0.1 * sin (2. * pi * 4. * qHit.y);\n        vn = normalize (vn);\n      }\n      vf = vec2 (32., 1.);\n    } else if (idObj == idRail) {\n      col4 = vec4 (0.8, 0.8, 0.85, 0.2);\n      vf = vec2 (32., 0.2);\n    } else if (idObj == idStr) {\n      if (abs (qHit.z) > 1.9) {\n        col4 = vec4 (0.5, 0.55, 0.5, 0.1);\n        vf = vec2 (32., 0.2);\n      } else if (vn.y > -0.01) {\n        col4 = vec4 (0.5, 0.3, 0.1, 0.1) * (1. - 0.2 * Fbm2 (2. * ro.xz));\n        vf = vec2 (32., 0.2);\n      } else {\n        col4 = vec4 (0.6, 0.6, 0.6, -1.);\n      }\n    } else if (idObj == idShlf) {\n      col4 = vec4 (vec3 (0.7, 0.4, 0.2) * (0.5 + 0.5 * Fbm2 ((r > 17.99) ?\n         vec2 (128. * a, 0.5 * qHit.y) :\n         ((abs (vn.y) < 0.01) ? vec2 (4. * r, 0.5 * qHit.y) : vec2 (32. * a, 4. * r)))), 0.1);\n      vf = vec2 (32., 0.1);\n      a = mod (4. * a + 0.5, 1.) - 0.5;\n      if (stLib >= 7 && r > 17.99 && abs (a) < 0.07 && abs (qHit.y - 2.2) < 0.4) {\n        if (ShowInt (vec2 (- 10. * a - 0.5, 0.8 * (qHit.y - 2.)), vec2 (1., 0.25), 4.,\n           dot (mod (vec2 (66., 60.) + cId.xz, 100.), vec2 (100., 1.))) != 0.) \n           col4 = vec4 (0.2, 0.4, 1., -1.);\n      }\n    } else if (idObj == idBk) {\n      a *= 128.;\n      s = Hashfv2 (vec2 (floor (a), 1. + floor (qHit.y / 2.8)));\n      y = mod (qHit.y / 2.8, 1.) / (0.9 - 0.3 * s);\n      if (y < 1.) {\n        a = mod (a, 1.);\n        col4 = vec4 (HsvToRgb (vec3 (mod (Hashfv3 (cId) + 0.2 * s, 1.), 0.7,\n           0.7 * (0.5 + 0.5 * SmoothBump (0.05, 0.95, 0.02, a)))), 0.1);\n        col4.rgb = mix (mix (col4.rgb, vec3 (0.7, 0.7, 0.3), SmoothBump (0.2, 0.25, 0.01, y)),\n           vec3 (0.8, 0.8, 0.2), step (abs (y - 0.5), 0.15) *\n           step (abs (a - 0.5), 0.25) * step (0.5, Noisefv2 (cId.xz * vec2 (19., 31.) +\n           floor (vec2 (16. * a, 16. * qHit.y)))));\n        vn.xz = Rot2D (vn.xz, 0.5 * pi * (a - 0.5));\n      } else {\n        col4 = vec4 (0.1, 0.04, 0., -1.);\n      }\n    } else if (idObj == idLt) {\n      col4 = (stLib >= 3) ? vec4 (vec3 (1., 1., 0.8) * (0.8 - 0.3 * vn.y), -1.) : vec4 (vec3 (0.8), 0.1);\n    }\n    ltVec = roo + ltPos - ro;\n    ltDist = length (ltVec);\n    ltVec /= ltDist;\n    atten = 1.2 / (1. + 0.002 * pow (ltDist, 1.5));\n    if (stLib <= 3 && ! isPano) atten *= 0.05 + 0.95 * smoothstep (0.7, 0.9, dot (ltAx, - ltVec));\n    ao = 1.;\n    if (stLib >= 2 && idObj != idBk) {\n      idObjT = idObj;\n      ao = ObjAO (ro, vn);\n      idObj = idObjT;\n    }\n    if (stLib == 1) vf = vec2 (256., 2.);\n    if (col4.a >= 0.) {\n      if (vf.x > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n      col = col4.rgb * (0.2 + 0.8 * max (dot (vn, ltVec), 0.)) +\n         col4.a * pow (max (dot (normalize (ltVec - rd), vn), 0.), 32.);\n      if (idObj == idBk) col += 0.3 * col4.rgb * (0.6 - 0.4 * dot (normalize (vn.xz),\n         normalize (qHit.xz)));\n      col *= atten;\n    } else col = col4.rgb * (0.2 + 0.8 * atten);\n    col *= ao;\n    col = clamp (mix (bgCol, col, exp (32. * min (0., 0.7 - dstObj / dstFar))), 0., 1.);\n    col = mix (col, vec3 (1.) * Maxv3 (col), 0.2);\n  } else col = bgCol;\n  if (stLib <= 2) col = vec3 (0.95, 0.95, 1.) * Maxv3 (col);\n  if (stLib == 1) col *= (tDir < 0.) ? vec3 (1., 0.2, 0.2) : vec3 (0.2, 1., 0.2);\n  col = clamp (col, 0., 1.);\n  if (! colImg) col = vec3 (0.95, 0.95, 1.) * pow (Maxv3 (col), 0.9);\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col, colF[2];\n  vec2 canvas, uv, ut;\n  float az, el, asp, zmFac, phCyc, tc, t, mb;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  bGrid = vec3 (40., 20., 40.);\n  tc = 0.3 * tCur;\n  colImg = true;\n  isPano = (floor (mod ((tc + 9.5) / 9., 4.)) > 1.); //false;\n  ut = vec2 (mPtr.x, abs (mPtr.y)) + 0.05 * vec2 (1. / asp, 1.) - 0.5;\n  mb = min (ut.x, ut.y);\n  if (mPtr.z > 0. && mb > 0.) {\n    if (mPtr.y > 0.) isPano = ! isPano;\n    else colImg = ! colImg;\n  }\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0. && colImg && ! isPano && mb < 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.7 * pi * mPtr.y;\n  } else {\n    t = 0.04 * tCur;\n    az = 0.6 * pi * (mod (floor (t), 2.) - 0.5) * SmoothBump (0.25, 0.75, 0.15, mod (t, 1.));\n  }\n  el = clamp (el, -0.45 * pi, 0.45 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -1.) + vec3 (0., 9., 4. * tCur);\n  zmFac = isPano ? 0.5 : 1.6;\n  ut = uv;\n  uv /= zmFac;\n  rd = vuMat * normalize (isPano ? vec3 (sin (uv.x + vec2 (0., 0.5 * pi)), uv.y).xzy : \n     vec3 (2. * tan (0.5 * atan (uv.x / asp)) * asp, uv.y, 1.));\n  ltPos = vuMat * vec3 (0., 1., -1.);\n  ltAx = vuMat * vec3 (0., 0., 1.);\n  dstFar = 8. * bGrid.x;\n  for (int k = VAR_ZERO; k < 2; k ++) {\n    t = mod ((tc + float (k)) / 9., 2.);\n    tDir = (2. * floor (t) - 1.) * (1. - abs (t - 1.));\n    stLib = 9 - int (9. * abs (tDir));\n    colF[k] = ShowScene (ro, rd);\n  }\n  col = mix (colF[0], colF[1], smoothstep (0.2, 0.8, fract (tc)));\n  col *= 1. - step (5. * abs (mod ((tc + 0.5) / 9., 2.) - 1.),\n     min (1.5, length (ut * vec2 (1. / asp, 1.))));\n  if (mPtr.z > 0. && min (ut.x - asp, abs (ut.y) - 1.) > -0.1)\n     col = mix (col, vec3 (1., 1., 0.), 0.3);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, vec3 (37., 39., 41.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 3; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nfloat DigSeg (vec2 q)\n{\n  return step (abs (q.x), 0.12) * step (abs (q.y), 0.6);\n}\n\n#define DSG(q) k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q)\n\nfloat ShowDig (vec2 q, int iv)\n{\n  float d;\n  int k, kk;\n  const vec2 vp = vec2 (0.5, 0.5), vm = vec2 (-0.5, 0.5), vo = vec2 (1., 0.);\n  if (iv == -1) k = 8;\n  else if (iv < 2) k = (iv == 0) ? 119 : 36;\n  else if (iv < 4) k = (iv == 2) ? 93 : 109;\n  else if (iv < 6) k = (iv == 4) ? 46 : 107;\n  else if (iv < 8) k = (iv == 6) ? 122 : 37;\n  else             k = (iv == 8) ? 127 : 47;\n  q = (q - 0.5) * vec2 (1.5, 2.2);\n  d = 0.;\n  kk = k;\n  DSG (q.yx - vo);  DSG (q.xy - vp);  DSG (q.xy - vm);  DSG (q.yx);\n  DSG (q.xy + vm);  DSG (q.xy + vp);  DSG (q.yx + vo);\n  return d;\n}\n\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, sgn, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (min (q.x, q.y) >= 0. && max (q.x, q.y) < 1.) {\n    q.x *= mxChar;\n    sgn = sign (val);\n    val = abs (val);\n    nDig = (val > 0.) ? floor (max (log (val) / log (10.), 0.) + 0.001) + 1. : 1.;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    v = val / pow (10., mxChar - idChar - 1.);\n    if (idChar == mxChar - nDig - 1. && sgn < 0.) s = ShowDig (q, -1);\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdlBzH.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1035, 1035, 1057, 1057, 3068], [3070, 3070, 3088, 3088, 3162], [3164, 3164, 3197, 3197, 3788], [3790, 3790, 3811, 3811, 4066], [4068, 4068, 4100, 4100, 4371], [4373, 4373, 4408, 4408, 9033], [9035, 9035, 9088, 9088, 10980], [10982, 10982, 11024, 11024, 11075], [11077, 11077, 11134, 11134, 11217], [11219, 11219, 11241, 11241, 11279], [11281, 11281, 11303, 11303, 11341], [11343, 11343, 11379, 11379, 11585], [11587, 11587, 11617, 11617, 11730], [11732, 11732, 11756, 11756, 11873], [11907, 11907, 11931, 11931, 11991], [11993, 11993, 12017, 12017, 12082], [12084, 12084, 12108, 12108, 12220], [12222, 12222, 12247, 12247, 12433], [12435, 12435, 12456, 12456, 12611], [12613, 12613, 12642, 12642, 12854], [12856, 12856, 12895, 12895, 13080], [13082, 13082, 13105, 13105, 13164], [13237, 13237, 13269, 13269, 13811], [13813, 13813, 13873, 13873, 14423]], "test": "error"}
{"id": "tdlfW4", "name": "Projet Shaders", "author": "Ares13Nyx", "description": "Traitement d'image d'étoiles filantes", "tags": ["project"], "likes": 7, "viewed": 135, "published": "Public", "date": "1588278982", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415\n\nmat2 rotation(float angle){\n    \n   float cosinus = cos(angle);\n   float sinus =sin(angle);\n    return mat2(cosinus, -sinus, sinus, cosinus);\n    \n}\n\nfloat etoile(vec2 gv, float flare) {\n\n    //dessiner une etoile\n      \n      //placer etoile au milieu\n      float dist = length(gv);\n      \n      //dessiner un cercle avec ses tailles\n      float cercle = .05/dist;\n    \n    \n      // rendre le cercle en etoile (ligne verticale et horizontale de etoile)\n        //le max afin deviter davoir 0 et avoir un rayonnement\n        float rayon =max(0., 1.-abs(gv.y*gv.x*1000.));\n        \n        //ajouter un rayonement\n        cercle += rayon*flare;\n    \n        //ajouter les autres rayons \n        gv *= rotation(PI/4.);\n    \n        rayon = max(0., 1.-abs(gv.x*gv.y*1000.));\n        cercle += rayon*.3*flare;\n        cercle *= smoothstep(1., .2, dist);\n      \n    return cercle;\n}\n\n//fonction de hashage\nfloat hash(vec2 p) {\n    p = fract(p*vec2(123.34, 456.21));\n    p += dot(p, p+45.32);\n    return fract(p.x*p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y;\n    \n    //clic et changement de la direction des etoiles\n\tvec2 clic = (iMouse.xy-iResolution.xy*.5)/iResolution.y;\n\n    //zoomer\n     uv *= 1.;\n    \n    vec3 col = vec3(0);\n    float t = iTime*.02;\n        \n    //definition de l'orientation des etoile\n    uv *= rotation(t);\n    \n    //changement de direction\n    uv += clic*4.;\n    \n    //les couches d'etoiles\n    for(float i=0.; i<1.; i+=1./2.){ \n        \n        vec3 col2 = vec3(0);\n        float scale = mix(20., .2, fract(i+t));\n        vec2 gv = fract(uv*scale-clic)-.5;\n        vec2 id = floor(uv*scale-clic);\n        float e;\n        \n       for(int y=-1;y<=1;y++) {\n          for(int x=-1;x<=1;x++) {\n              \n              //offs afin de ne pas avoir chaque etoile dans un box\n              vec2 offs = vec2(x, y);\n              float n = hash(id+offs);\n              float taille = fract(n*345.32);\n              \n              //à fin davoir plusieurs couleurs on applique cette combinaison de fonction\n              vec3 couleur = sin(vec3(.2, .3, .9)*fract(n*2345.2)*123.2)*.5+.5;\n              couleur = couleur*vec3(1,.25,1.+taille)+vec3(.2, .2, .1)*2.;\n              \n              //construction de etoile et son affichage \n              float e = etoile(gv-offs-vec2(n, fract(n*34.))+.5, smoothstep(.85, 1., taille));\n              col2+= e*taille*couleur;\n          }\n           \n        }\n        col += col2;\n   }\n    \n        \n       \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdlfW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 46, 46, 167], [169, 169, 205, 271, 897], [899, 921, 941, 941, 1035], [1037, 1037, 1094, 1094, 2606]], "test": "valid"}
{"id": "tdlyD2", "name": "Heritable xenobiotic", "author": "SomeGuy", "description": "An attempt (possibly failed) to make something interesting with some movement and a bit of atmosphere.\nPossibly some kind of alien genetic material.", "tags": ["raymarching"], "likes": 14, "viewed": 132, "published": "Public", "date": "1586021233", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//-------------------------------------------------------------------\n// Trying out ShaderToy and trying to get to grips with ray marching.\n// Inspired by the amazing creations of Evvvvil, Nusan and Shane\n//-------------------------------------------------------------------\n\n#define MD 30.\t\t// max distance\n#define SD 0.0001    // surface distance\n#define MS 250      // max number of steps to march\n#define EPS 0.0001   // distance used for sampling the gradient\n\nfloat time;\n\n// always handy to have PI available\nconst float PI = acos(-1.);\nconst float TWOPI = 2.*PI;\n\n// fog color.\nconst vec3 fog = vec3(.05,.25, .05);\n\n// always need some glow!\nfloat glw = 0.;\n\n// sphere SDF\nfloat sph(vec3 p, float r){return length(p)-r;}\n\n// min and max which preserve material\nvec2 mmin(vec2 a, vec2 b) {return a.x < b.x ? a:b;}\nvec2 mmax(vec2 a, vec2 b) {return a.x > b.x ? a:b;}\n\n\n// 2d rotation\nvoid rot(inout vec2 p, float a) {\n    float c=cos(a), s=sin(a);\n    p *= mat2(c,-s,s,c);\n}\n\n// I was going to do something complicated here,\n// but ended up doing a sphere!\nvec2 prim(vec3 p) {\n    return vec2(sph(p, .5), 5);\n}\n\n// the SDF for the scene\nvec2 map(vec3 p) {\n    \n    // wiggle x\n    p.x += sin(p.z + time*.2)*.5;\n    // spiral\n    rot(p.xy, sin(p.z / 3.));\n    // scroll along z\n    p.z -= time/3.;\n    \n    // repeat everything\n    vec3 mp;\n    mp.x = mod(p.x, 2.3)-1.15;\n    mp.y = mod(p.y, 2.3)-1.15;\n    mp.z = mod(p.z,.6)-.3;\n    \n    // fractal (ish)\n    vec4 ap = vec4(mp,1.);\n    // big purple sphere\n    vec2 a=prim(mp);\n    a.x *= .6;\n    // smaller black spheres\n    int n=4;\n    for(int i=1; i<=n; ++i) {\n    \tap *= 2.5; // scale\n        ap.xyz = abs(ap.xyz)-vec3(.8); // symmetry\n        rot(ap.xy, ap.z*.1 + time*.5); // movement\n        vec2 b = prim(ap.xyz); // sphere\n        b.x /= ap.w; // correct for scaling\n        b.x *= .6;   // patch up the SDF\n        b.y= 1.;     // paint it black\n        a=mmin(a, b);\n        \n    }\n    \n    // Sparkles. Lots of them.\n    rot(p.xy, time*.3);\n    vec2 b = vec2(length(cos(p*1.+vec3(1.5+p.z*.05*sin(time),1.7+sin(time)*.2,time*2.)))-.001 ,6.);\n    glw += .1/(.1*b.x*b.x*10000.);\n    b.x *= .6;\n    \n    // final distance\n    vec2 d=mmin(a,b);\n    return d;\n}\n\n// determine the normal at point p by sampling the gradient of the SDF\nvec3 normal(vec3 p) {\n \tvec2 off = vec2(EPS, 0.);\n    return normalize(map(p).x - vec3(map(p-off.xyy).x,map(p-off.yxy).x,map(p-off.yyx).x));\n}\n\n//-------------------------------------------------------------\n// lighting and colour,\n// heavily based on Evvvvil's Micro Lighting Engine Broski (TM)\n//-------------------------------------------------------------\n\n// shortcuts for calculating fake ambient occlusion and subsurface scattering\n#define aoc(d) clamp(map(p + n * d).x/d, 0., 1.)\n#define sss(d) smoothstep(0.,1.,map(p+ld*d).x/d)\n\nvec3 surface(vec3 ro, vec3 rd, vec2 hit) {\n\tfloat d=hit.x;         // distance from ray origin\n    float m = hit.y;       // materialID\n    \n    // albedo, or base color, based on material ID\t\n    vec3 al = m < 5. ? vec3(0) : \n    \t\tm > 5. ? vec3(1) :\n    \t\tvec3(.1,.1,.4);\n    \n    vec3 p = ro + rd * d;  // the point in space\n    vec3 n = normal(p);    // normal of the SDF at point p\n    \n    vec3 ld = normalize(vec3(-1));     // light direction\n    float diff = max(0., dot(n, -ld)); // diffuse illumination\n    \n    vec3 lr = reflect(ld, n);          // reflected light ray\n    float spec = pow(max(0., dot(lr,-rd)),32.); // specular component\n \n    float frz = pow(max(0.1, 1. - dot(n,-rd)),4.)*.5; // freznel)\n\t\n    float ao = aoc(.1); // fake AO\n    float ss = sss(1.); // fake subsurface scattering\n    \n    vec3 col =  al * ao * (diff + ss) + spec; // combine it all together\n    col = mix(col, fog, frz);         // fog the edges\n    \n    return col; // the final color\n}\n\n// ray marching loop\nvec3 march(vec3 ro, vec3 rd) {\n\tfloat dd=0.1;\t\t// start with a slight z offset\n    vec3 col=vec3(0);   // no color initially\n    vec3 p=ro + rd * dd;// current point\n    \n    for(int i=0; i<MS; ++i) {  // start marching\n     \tvec2 d = map(p);  // distance to SDF\n        \n        if(d.x < SD) { // close to a surface\n            // get the color of the surface\n            col += d.y > 0. ? surface(ro, rd, vec2(dd, d.y)) : vec3(0.);\n            break; // we're done\n        }\n        \n        if(dd > MD) { // we've reached the max draw distance,\n            dd = MD;\n            break;    // and we're done\n        }\n        \n        dd += d.x;     // track the total distance\n        p += rd * d.x; // and update the current position\n    }\n    \n    // blend in some distance-based fog and return\n    return mix(fog * pow(max(0., dot(rd, vec3(0,0,-1))),20.), col, exp(-0.003*dd*dd*dd));\n}\n\n\n// given the ray origin, lookat point and uv's, calculate the ray direction\nvec3 raydir(vec3 ro, vec3 la, vec2 uv) {\n    // x,y and z axes\n    vec3 cz = normalize(la-ro);\n    vec3 cx = normalize(cross(cz,vec3(0,1,0)));\n    vec3 cy = normalize(cross(cx,cz));\n    // project and normalize\n    return normalize(cx*uv.x + cy*uv.y + cz);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    // make sure that the pixels are square\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    // get rid of some artifacts\n    time = mod(iTime, 62.39);\n    \n    // setup the ray\n    vec3 ro = vec3(0,0,1);\n    vec3 rd = raydir(ro, vec3(0)-ro, uv);\n    \n    // march\n    vec3 col = march(ro, rd);\n\n    col += glw;\n    // exposure\n    col = vec3(1) - exp(-col * 1.1);\n    // gamma\n    col = pow(col, vec3(1./2.2));\n    // final color\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdlyD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[667, 681, 708, 708, 728], [730, 769, 796, 796, 820], [821, 821, 848, 848, 872], [875, 890, 923, 923, 980], [982, 1063, 1082, 1082, 1116], [1118, 1143, 1161, 1182, 2224], [2226, 2297, 2318, 2318, 2439], [2835, 2835, 2877, 2877, 3818], [3820, 3841, 3871, 3871, 4731], [4734, 4810, 4850, 4872, 5068], [5071, 5071, 5128, 5178, 5703]], "test": "error"}
{"id": "tdsBD4", "name": "Polar of a Cardioid", "author": "mla", "description": "The polar curve of the mouse position for a cardioid.\n\n[url]https://en.wikipedia.org/wiki/Polar_curve[/url]", "tags": ["polar", "cardioid"], "likes": 7, "viewed": 290, "published": "Public API", "date": "1588282514", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Polar of a Cardioid\n// Matthew Arcus, mla, 2020\n//\n// Given an implicit curve f(z) = 0, the polar curve for a point w is\n// polar(z) = p.x + p.y where p = grad(f,z)*(w-z)\n// The intersection of the polar with the curve itself gives the points\n// on the curve whose tangents pass through p.\n//\n// Here we have a cardioid, drawn as a tangent envelope, and the polar of\n// the pointer position, drawn as an implicit curve - the tangents through the\n// pointer position meet the curve at its intersections with the polar.\n//\n// NEW FEATURE: (press 'g' to hide): a graph showing the distance of the\n// pointer position from tangent(t), where tangent(t) is the line between\n// (cos(t),sin(t)) and (cos(2t),sin(2t)) - zeros of this function are where\n// a line passes through the point. The vertical lines are at -PI and +PI\n// and there is a bogus zero at t = 0 in the middle (the two points\n// coincide).\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.1415927;\n\nfloat line(vec2 p, vec2 a, vec2 b) {\n  vec2 pa = p - a;\n  vec2 ba = b - a;\n  float h = dot(pa, ba) / dot(ba, ba);\n  float d = length(pa - ba * h);\n  return d;\n}\n\nconst int N = 108;\nfloat card0(vec2 z) {\n  // Draw the envelope\n  float d = 1e8;\n  float k = 2.0*PI/float(N);\n  float t = 2.0;\n  for (int i = 0; i < N; i++) {\n    float theta = float(i)*k;\n    vec2 p = vec2(cos(theta),sin(theta));\n    vec2 q = vec2(cos(t*theta),sin(t*theta));\n    d = min(d,line(z,p,q));\n  }\n  return d;\n}\n\n// Maybe use dual numbers here?\n// I did the diff for card by hand, but it got tedious for the polar,\n// so it's numeric all the way (it's more generic anyway).\n// Some macrology instead of higher order functions.\n#define GRAD(F,Z,EPS)                      \\\n  (vec2(F(Z+vec2(EPS,0))-F(Z-vec2(EPS,0)), \\\n        F(Z+vec2(0,EPS))-F(Z-vec2(0,EPS)))/(2.0*EPS))\n\nfloat card(vec2 p) {\n  // Implicit function for cardioid\n  float a = 1.0/3.0; // Line up with the unit circle\n  p.x += a;\n  float x = p.x, y = p.y;\n  float t = x*x+y*y;\n  return t*t - 4.0*a*x*t - 4.0*a*a*y*y;\n}\n\nvec2 cardgrad(vec2 z) {\n#define F(Z) (card(Z))\n  return GRAD(F,z,0.01);\n#undef F\n}\n\nfloat carddist(vec2 z) {\n  float d = card(z);\n  vec2 ds = cardgrad(z);\n  d /= length(ds);\n  return d;\n}\n\nfloat polar(vec2 z, vec2 w) {\n  float eps = 0.01;\n  vec2 e = vec2(eps,0);\n  return dot(vec2(1),cardgrad(z)*(w-z));\n}\n\nvec2 polargrad(vec2 z, vec2 w) {\n#define F(Z) (polar(Z,w))\n  return GRAD(F,z,0.01);\n#undef F\n}\n\nfloat polardist(vec2 z, vec2 w) {\n  float d = polar(z,w);\n  vec2 ds = polargrad(z,w);\n  return d/length(ds);\n}\n\nfloat line(vec3 p, vec3 l) {\n  return abs(dot(p,l)/(p.z*length(l.xy)));\n}\n\nfloat graph(vec2 z, vec2 w) {\n  // Draw curve, y = f(x), ie. f(x)-y = 0\n  float t = PI*z.x;\n  float y = 6.0*z.y;\n  vec3 p0 = vec3(cos(t),sin(t),1);\n  vec3 p1 = vec3(cos(2.0*t),sin(2.0*t),1);\n  vec3 l = vec3(sin(t)-sin(2.0*t),\n                cos(2.0*t)-cos(t),\n                cos(t)*sin(2.0*t)-sin(t)*cos(2.0*t));\n  return dot(vec3(w,1),l) - y;\n}\n\nvec2 graphgrad(vec2 z, vec2 w) {\n#define F(Z) (graph(Z,w))\n  return GRAD(F,z,0.01);\n#undef F\n}\n\nfloat graphdist(vec2 z, vec2 w) {\n  return graph(z,w)/length(graphgrad(z,w));\n}\n\nbool key(int code) {\n  return texelFetch(iChannel3, ivec2(code,2),0).x != 0.0;\n}\n\nconst int CHAR_G = 71;\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  int AA = 2;\n  vec3 col = vec3(0);\n  vec2 w;\n  if (iMouse.x > 0.0) w = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n  else w = cos(0.5*iTime-vec2(0,0.4*PI));\n  for (int i = 0; i < AA; i++) {\n    for (int j = 0; j < AA; j++) {\n      vec2 z = (2.0*(fragCoord+vec2(i,j)/float(AA))-iResolution.xy)/iResolution.y;\n      float ldist = graphdist(z,w);\n      float lmin = 0.002, lmax = max(0.003,fwidth(z.x));\n      float pmin = 0.015, pmax = max(0.02,2.0*fwidth(z.x));\n      vec3 c = vec3(0.75);\n      c.rg += 0.25*cos(2.0*PI*8.0*polardist(z,w));\n      c.b += 0.25*cos(2.0*PI*8.0*carddist(z));\n      c = mix(c,vec3(0.1),1.0-smoothstep(lmin,lmax,abs(card0(z))));\n      c = mix(c,vec3(0,0,1),1.0-smoothstep(lmin,lmax,abs(carddist(z))));\n      c = mix(c,vec3(1,0,0),1.0-smoothstep(lmin,lmax,abs(polardist(z,w))));\n      if (!key(CHAR_G)) {\n          c *= 0.8;\n          c = mix(c,vec3(1),1.0-smoothstep(lmin,lmax,abs(ldist)));\n          c = mix(c,vec3(1),1.0-smoothstep(lmin,lmax,line(z,vec2(-1,0),vec2(1,0))));\n          c = mix(c,vec3(1),1.0-smoothstep(lmin,lmax,line(z,vec2(-1,0),vec2(-1,1))));\n          c = mix(c,vec3(1),1.0-smoothstep(lmin,lmax,line(z,vec2(1,0),vec2(1,1))));\n      }\n      c = mix(c,vec3(0),1.0-smoothstep(pmin,pmax,distance(z,w)));\n      col += c;\n    }\n  }\n  col /= float(AA*AA);\n  col = pow(col,vec3(0.4545));\n  fragColor = vec4(col,1);\n}\n", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdsBD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1101, 1101, 1137, 1137, 1261], [1282, 1282, 1303, 1326, 1585], [1946, 1946, 1966, 2002, 2156], [2242, 2242, 2266, 2266, 2345], [2347, 2347, 2376, 2376, 2463], [2561, 2561, 2594, 2594, 2671], [2673, 2673, 2701, 2701, 2746], [2748, 2748, 2777, 2819, 3095], [3193, 3193, 3226, 3226, 3272], [3274, 3274, 3294, 3294, 3354], [3380, 3380, 3432, 3432, 4789]], "test": "error"}
{"id": "tdsBzN", "name": "Mosaic bubble", "author": "HyiKing", "description": "generated pattern with randomness", "tags": ["circle", "random", "pattern", "mosaic"], "likes": 3, "viewed": 95, "published": "Public", "date": "1587844144", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SCALE 64.0\n\nfloat circle(in vec2 _st, in float _radius){\n    vec2 l = _st-vec2(0.5);\n    return 1.-smoothstep(_radius-(_radius*0.01),\n                         _radius+(_radius*0.01),\n                         dot(l,l)*4.0);\n}\n\nfloat rand1(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(4.2574,72.233))) * 43758.5453);\n}\n\nfloat rand2(vec2 x) {\n    int n = int(x.x * 40.0 + x.y * 6400.0);\n    n = (n << 13) ^ n;\n    return 1.0 - float( (n * (n * n * 15731 + 789221) + \\\n             1376312589) & 0x7fffffff) / 1073741824.0;\n}\n\nvec2 posFragInsideGrid(vec2 stScaled) {\n    return vec2(floor(stScaled)+1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 st = gl_FragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n    vec3 color = vec3(0.3);\n\n    vec2 stScaled = st*SCALE; // Scale up the space by SCALE value\n    vec2 stTiled = fract(stScaled); // Wrap arround 1.0\n    \n    vec2 posFrag = posFragInsideGrid(stScaled);\n    float randomRadius = rand2(posFrag)*rand2(posFrag); // random according to the position in grid.\n\n   \tfloat variationRadius = 4.0*(cos(iTime)+1.0)/2.0;\n    \n    color += vec3(circle(stTiled,randomRadius*variationRadius))*vec3(0.5,0.5,0.5);\n\tfragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdsBzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 64, 64, 232], [234, 234, 255, 255, 326], [328, 328, 349, 349, 531], [533, 533, 572, 572, 612], [614, 614, 670, 670, 1235]], "test": "valid"}
{"id": "tdScDh", "name": "Toy1", "author": "ArthMax", "description": "This is Toy1 for my followers-students. Make Your own Toy which is Your recognizable Portrait!\n", "tags": ["toy1forfollowers"], "likes": 3, "viewed": 94, "published": "Public", "date": "1586530666", "time_retrieved": "2021-10-01T00:00:00", "image_code": "     mat2 rotate2d(float _angle){\n                                 return mat2(\n                                             cos(_angle),-sin(_angle),\n                                             sin(_angle), cos(_angle)\n                                            );\n     }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv  = 1.0-2.0*fragCoord/iResolution.xy;\n    // Normalized mouse coordinates (from -1 to 1)\n    vec2 muv = 1.0-2.0*iMouse.xy/iResolution.xy;\n    \n    // mouse coordinates (from -1 to 1)\n    float mx = muv.x;\n    float my = muv.y;\n    \n    // x and y  shifted by mouse coordinates (from -1 to 1)\n    float x = uv.x-mx;\n    float y = uv.y-my;\n    \n     // scaled and squared distance to current center\n     float r = (x*x+y*y)*5.0;\n     // angle from x axis to mouse position on click\n     float a = atan(my,mx);\n       mat2 R = rotate2d(a); \n        vec2 rxy = R*vec2(x,y);\n        \n     // max distance from current center to rotated xy\n     float m = max(abs(rxy.x),abs(rxy.y))*1.0;\n\n        \n      // varying pixel color by Time and mouse down\n       vec3 col = cos((m+sin(r-iTime))*10.0+vec3(4.0*mx,a,3.0*my));\n\n       // Output to screen\n             fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdScDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[5, 5, 33, 33, 274], [276, 276, 333, 384, 1276]], "test": "valid"}
{"id": "tdScDy", "name": "CIS561_HW9_BSSRDF", "author": "JerryYan", "description": "CIS561_BSSRDF", "tags": ["hw9"], "likes": 1, "viewed": 72, "published": "Public", "date": "1587267627", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int RAY_STEPS = 256;\nconst float FOVY = 3.141569 * 0.25;\n\n// The higher the value, the smaller the penumbra\nconst float SHADOW_HARDNESS = 10.0;\n\n// Adjust these to alter where the subsurface glow shines through and how brightly\nconst float FIVETAP_K = 2.0;\nconst float AO_DIST = 0.085;\n\n// The larger the DISTORTION, the smaller the glow\nconst float DISTORTION = 0.2;\n// The higher GLOW is, the smaller the glow of the subsurface scattering\nconst float GLOW = 6.0;\n// The higher the BSSRDF_SCALE, the brighter the scattered light\nconst float BSSRDF_SCALE = 3.0;\n// Boost the shadowed areas in the subsurface glow with this\nconst float AMBIENT = 0.0;\n// Toggle this to affect how easily the subsurface glow propagates through an object\n#define ATTENUATION 0\n\nstruct Intersection\n{\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n};\n    \nfloat sphere(vec3 p, float r, vec3 c)\n{\n    return distance(p, c) - r;\n}\n\nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\nfloat plane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n// Box with side lengths b\nfloat box(vec3 p, vec3 b)\n{\n  return length(max(abs(p) - b, 0.0));\n}\n\nfloat subsurface(vec3 lightDir, vec3 normal, vec3 viewVec, float thickness) {\n    vec3 scatteredLightDir = lightDir + normal * DISTORTION;\n    float lightReachingEye = pow(clamp(dot(viewVec, -scatteredLightDir), 0.0, 1.0), GLOW) * BSSRDF_SCALE;\n    float attenuation = 1.0;\n    #if ATTENUATION\n    attenuation = max(0.0, dot(normal, lightDir) + dot(viewVec, -lightDir));\n    #endif\n\tfloat totalLight = attenuation * (lightReachingEye + AMBIENT) * thickness;\n    return totalLight;\n}\n\n#define SPHERE_1_SDF sphere(pos, 1.0, vec3(0., 3., 3.))\n#define SPHERE_2_SDF sphere(pos, 2.0, vec3(4., 2., 0.))\n#define SPHERE_1_ID 1\n#define SPHERE_2_ID 2\n\n#define BACK_WALL_SDF plane(pos, vec4(0.0, 0.0, -1.0, 5.0))\n#define BACK_WALL_ID 3 \n\n#define LEFT_WALL_SDF plane(pos, vec4(1.0, 0.0, 0.0, 5.0))\n#define LEFT_WALL_ID 4\n\n#define RIGHT_WALL_SDF plane(pos, vec4(-1.0, 0.0, 0.0, 5.0))\n#define RIGHT_WALL_ID 5\n\n#define CEILING_WALL_SDF plane(pos, vec4(0.0, -1.0, 0.0, 7.5))\n#define CEILING_WALL_ID 6\n\n#define FLOOR_SDF plane(pos, vec4(0.0, 1.0, 0.0, 3.5))\n#define FLOOR_ID 7\n\n#define TALL_BOX_SDF box(rotateY(pos + vec3(2, -1, -1), 27.5 * 3.14159 / 180.0), vec3(1, 2, 1))\n#define TALL_BOX_ID 8\n\n#define SMALL_BOX_SDF box(rotateY(pos + vec3(-2, -2, -0.75), -27.5 * 3.14159 / 180.0), vec3(1, 1, 1))\n#define SMALL_BOX_ID 9\n\n\nvoid sceneMap3D(vec3 pos, out float t, out int obj)\n{\n    t = FLOOR_SDF;\n    obj = FLOOR_ID;\n    \n    float t2;\n\n    if((t2 = TALL_BOX_SDF) < t)\n    {\n        t = t2;\n        obj = TALL_BOX_ID;\n    }\n    if((t2 = SMALL_BOX_SDF) < t)\n    {\n        t = t2;\n        obj = SMALL_BOX_ID;\n    }\n    if((t2 = SPHERE_1_SDF) < t)\n    {\n        t = t2;\n        obj = SPHERE_1_ID;\n    }\n}\n\nfloat sceneMap3D(vec3 pos)\n{\n    float t = FLOOR_SDF;\n    \n    t = min(t, TALL_BOX_SDF);\n    t = min(t, SMALL_BOX_SDF);\n    t = min(t, SPHERE_1_SDF);\n    \n    return t;\n}\n\nfloat shadowMap3D(vec3 pos)\n{\n    float t = FLOOR_SDF;\n    t = min(t, TALL_BOX_SDF);\n    t = min(t, SMALL_BOX_SDF);\n    return t;\n}\n\n\nfloat fiveTapAO(vec3 p, vec3 n, float k) {\n    float aoSum = 0.0;\n    for(float i = 0.0; i < 5.0; ++i) {\n        float coeff = 1.0 / pow(2.0, i);\n        aoSum += coeff * (i * AO_DIST - shadowMap3D(p + n * i * AO_DIST));\n    }\n    return 1.0 - k * aoSum;\n}\n\nvec3 computeNormal(vec3 pos)\n{\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( sceneMap3D(pos + epsilon.yxx) - sceneMap3D(pos - epsilon.yxx),\n                            sceneMap3D(pos + epsilon.xyx) - sceneMap3D(pos - epsilon.xyx),\n                            sceneMap3D(pos + epsilon.xxy) - sceneMap3D(pos - epsilon.xxy)));\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj)\n{\n    t = 0.001;\n    for(int i = 0; i < RAY_STEPS; ++i)\n    {\n        vec3 pos = origin + t * dir;\n    \tfloat m;\n        sceneMap3D(pos, m, hitObj);\n        if(m < 0.01)\n        {\n            return;\n        }\n        t += m;\n    }\n    t = -1.0;\n    hitObj = -1;\n}\n\nfloat softShadow(vec3 dir, vec3 origin, float min_t, float k) {\n    float res = 1.0;\n    float t = min_t;\n    for(int i = 0; i < RAY_STEPS; ++i) {\n        float m = shadowMap3D(origin + t * dir);\n        if(m < 0.0001) {\n            return 0.0;\n        }\n        res = min(res, k * m / t);\n        t += m;\n    }\n    // return 0.5;\n    return res;\n}\n\n\nvec3 computeMaterial(int hitObj, vec3 p, vec3 n, vec3 lightVec, vec3 view, float thick)\n{\n    float lambert = dot(-lightVec, n);\n    float shadow = softShadow(-lightVec, p, 0.1, 14.0);\n    vec3 lightColor = vec3(1.0, 0.88, 0.7);\n    float sss = subsurface(-lightVec, n, view, thick);\n    \n    switch(hitObj){\n        case TALL_BOX_ID:\n        return vec3(1., 1., 0.) * lambert * shadow + sss * lightColor * vec3(1., 1., 0.);\n        break;\n        case SMALL_BOX_ID:\n        return vec3(0., 1., 1.) * lambert * shadow + sss * lightColor * vec3(0., 1., 1.);\n        break;\n        case SPHERE_1_ID:\n        return vec3(1.0, 0.88, 0.7);\n        case FLOOR_ID:\n        return lambert * shadow * lightColor;\n        break;\n        case -1:\n        return vec3(0., 0., 0.);\n        break;\n    }\n    return vec3(0., 0., 0.);\n}\n\nIntersection sdf3D(vec3 dir, vec3 eye)\n{\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj);\n\n    vec3 isect = eye + t * dir;\n    vec3 nor = computeNormal(isect);\n    vec3 lightPos = vec3(0., 3., 3.);\n    vec3 lightDir = normalize(isect - lightPos);\n    float thickness = fiveTapAO(isect, -nor, FIVETAP_K);\n    \n    vec3 surfaceColor = computeMaterial(hitObj, isect, nor, lightDir, normalize(eye - isect), thickness);\n\n    return Intersection(t, surfaceColor, isect, hitObj);\n}\n\n\nvec3 rayCast(vec3 eye, vec3 ref, vec2 ndc)\n{\n    vec3 F = ref - eye;\n    vec3 R = normalize(cross(F, vec3(0.0, 1.0, 0.0)));\n    vec3 U = normalize(cross(R, F));\n    \n    vec3 V = U * length(F) * tan(FOVY * 0.5);\n    vec3 H = R * length(F) * tan(FOVY * 0.5) * float(iResolution.x) / iResolution.y;\n    \n    vec3 p = ref + ndc.x * H + ndc.y * V;\n    \n    return normalize(p - eye);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // [-1, 1]\n    uv = uv * 2.0 - vec2(1.0, 1.0);\n    \n    vec3 eye = rotateY(vec3(0, 2, -20), iTime);\n    \n    vec3 ref = vec3(0, 0, 0);\n    \n    vec3 rayDir = rayCast(eye, ref, uv);\n    \n    Intersection isect = sdf3D(rayDir, eye);\n \n    // Output to screen\n    fragColor = vec4(isect.color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdScDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[851, 851, 890, 890, 923], [925, 925, 956, 956, 1039], [1041, 1041, 1072, 1098, 1129], [1131, 1158, 1185, 1185, 1226], [1228, 1228, 1305, 1305, 1710], [2534, 2534, 2587, 2587, 2911], [2913, 2913, 2941, 2941, 3083], [3085, 3085, 3114, 3114, 3216], [3219, 3219, 3261, 3261, 3475], [3477, 3477, 3507, 3507, 3826], [3828, 3828, 3892, 3892, 4155], [4157, 4157, 4220, 4220, 4505], [4508, 4508, 4597, 4597, 5328], [5330, 5330, 5370, 5370, 5816], [5819, 5819, 5863, 5863, 6200], [6202, 6202, 6259, 6309, 6657]], "test": "error"}
{"id": "tdScW3", "name": "HW_09_3 XuechengSun_Subsurface", "author": "hehehaha12138", "description": "HW09 for CIS461 Shadow Subsurface Scene", "tags": ["3d"], "likes": 2, "viewed": 54, "published": "Public", "date": "1587681643", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SQUARE_PLANE 0\n#define CUBE 1\n#define POINT_LIGHT 0\n#define FOCAL_LENGTH 8.0\n#define FOCAL_RANGE 20.0\nconst float AO_DIST = 0.15;\nconst float FIVETAP_K = 2.0;\n\nconst float FOVY = 3.141569 * 0.25;\nconst int RAY_STEPS = 256;\n\n// BSSRDF \n// The larger the DISTORTION, the smaller the glow\nconst float DISTORTION = 0.1;\n// The higher GLOW is, the smaller the glow of the subsurface scattering\nconst float GLOW = 1.0;\n// The higher the BSSRDF_SCALE, the brighter the scattered light\nconst float BSSRDF_SCALE = 3.0;\n// Boost the shadowed areas in the subsurface glow with this\nconst float AMBIENT = 0.0;\n// Toggle this to affect how easily the subsurface glow propagates through an object\n#define ATTENUATION 0\n\n\nstruct Intersection {\n    float t;\n    vec3 color;\n    vec3 p;\n    int object; // Assign every object in our scene a unique ID int\n};\n    \nstruct Transform\n{\n\tvec3 trans;\n    vec3 scale;\n    vec3 rotate;\n};\n\nstruct Primitive\n{\n\tint id;\n    Transform transform;\n    vec3 matColor;\n    int primitiveId;\n};\n    \nstruct Light\n{\n\tint id;\n    int typeId;\n    float intensity;\n    Transform transform;\n    vec3 lightColor;\n};\n   \n    \nPrimitive floorSquare;\nPrimitive redWall;\nPrimitive greenWall;\nPrimitive backWall;\nPrimitive ceilingWall;\nPrimitive shortCube;\nPrimitive longCube;\nLight pointLight;\nPrimitive primitives[7];\nLight lights[1];\n\nvoid initializeCornelBox()\n{\n    \n    \n    // Primitive initialization\n\tfloorSquare.transform.trans = vec3(0, -2.5, 0);\n\tfloorSquare.transform.rotate = vec3(-90, 0, 0);\n\tfloorSquare.transform.scale = vec3(10, 10, 1);\n    floorSquare.primitiveId = SQUARE_PLANE;\n    floorSquare.matColor = vec3(0.85, 0.81, 0.78);\n    primitives[0] = floorSquare;\n    \n    redWall.transform.trans = vec3(5, 2.5, 0);\n\tredWall.transform.rotate = vec3(0, -90, 0);\n\tredWall.transform.scale = vec3(10, 10, 1);\n    redWall.primitiveId = SQUARE_PLANE;\n    redWall.matColor = vec3(0.63, 0.065, 0.05);\n    primitives[1] = redWall;\n    \n    greenWall.transform.trans = vec3(-5, 2.5, 0);\n    greenWall.transform.rotate = vec3(0, 90, 0);\n\tgreenWall.transform.scale = vec3(10, 10, 1);\n    greenWall.primitiveId = SQUARE_PLANE;\n    greenWall.matColor = vec3(0.14, 0.45, 0.091);\n    primitives[2] = greenWall;\n    \n    backWall.transform.trans = vec3(0, 2.5, 5);\n    backWall.transform.rotate = vec3(0, 180,  0);\n\tbackWall.transform.scale = vec3(10, 10, 1);\n    backWall.primitiveId = SQUARE_PLANE;\n    backWall.matColor = vec3(0.85, 0.81, 0.78);\n    primitives[3] = backWall;\n    \n    ceilingWall.transform.trans = vec3(0, 7.5, 0);\n    ceilingWall.transform.rotate = vec3(90, 0, 0);\n\tceilingWall.transform.scale = vec3(10, 10, 1);\n    ceilingWall.primitiveId = SQUARE_PLANE;\n    ceilingWall.matColor = vec3(0.85, 0.81, 0.78);\n    primitives[4] = ceilingWall;\n    \n    shortCube.transform.trans = vec3(-2, -1, 0.75);\n    shortCube.transform.rotate = vec3(0, -17.5, 0);\n\tshortCube.transform.scale = vec3(3, 3, 3);\n    shortCube.primitiveId = CUBE;\n    shortCube.matColor = vec3(0.85, 0.81, 0.78);\n    primitives[5] = shortCube;\n    \n    longCube.transform.trans = vec3(2, 0, 3);\n    longCube.transform.rotate = vec3(0, 27.5, 0);\n\tlongCube.transform.scale = vec3(3, 6, 3);\n    longCube.primitiveId = CUBE;\n    longCube.matColor = vec3(0.85, 0.81, 0.78);\n    primitives[6] = longCube;\n    \n \n    \n    // Light initlaization\n    pointLight.id = 0;\n    pointLight.typeId = POINT_LIGHT;\n    pointLight.intensity = 2.0;\n    pointLight.lightColor = vec3(17, 12, 4);\n    pointLight.transform.trans = vec3(0, 7.0, -2.0);\n    pointLight.transform.rotate = vec3(90, 0, 0);\n    pointLight.transform.scale = vec3(3, 3, 1);\n    \n    return;\n}\n\n// SDF of a sphere\nfloat sphere(vec3 p, float r, vec3 c) {\n    return distance(p, c) - r;\n}\n\nfloat random1( vec3 p ) {\n    return fract(sin((dot(p, vec3(127.1,\n                                  311.7,\n                                  191.999)))) *         \n                 43758.5453);\n}\n\nvec3 random3( vec3 p ) {\n    return fract(sin(vec3(dot(p,vec3(127.1, 311.7, 191.999)),\n                          dot(p,vec3(269.5, 183.3, 765.54)),\n                          dot(p, vec3(420.69, 631.2,109.21))))\n                 *43758.5453);\n}\n\n\nfloat WorleyNoise3D(vec3 p) {\n    // Tile the space\n    vec3 pointInt = floor(p);\n    vec3 pointFract = fract(p);\n\n    float minDist = 1.0; // Minimum distance initialized to max.\n\n    // Search all neighboring cells and this cell for their point\n    for(int z = -1; z <= 1; z++)\n    {\n        for(int y = -1; y <= 1; y++)\n        {\n            for(int x = -1; x <= 1; x++)\n            {\n                vec3 neighbor = vec3(float(x), float(y), float(z));\n\n                // Random point inside current neighboring cell\n                vec3 point = random3(pointInt + neighbor);\n\n                // Animate the point\n                point = 0.5 + 0.5 * sin(iTime * 0.01 + 6.2831 * point); // 0 to 1 range\n\n                // Compute the distance b/t the point and the fragment\n                // Store the min dist thus far\n                vec3 diff = neighbor + point - pointFract;\n                float dist = length(diff);\n                minDist = min(minDist, dist);\n            }\n        }\n    }\n    return minDist;\n}\n\nvoid CoordinateSystem(in vec3 v1, out vec3 v2, out vec3 v3) {\n    if (abs(v1.x) > abs(v1.y))\n            v2 = vec3(-v1.z, 0.0, v1.x) / sqrt(v1.x * v1.x + v1.z * v1.z);\n        else\n            v2 = vec3(0.0, v1.z, -v1.y) / sqrt(v1.y * v1.y + v1.z * v1.z);\n        v3 = cross(v1, v2);\n}\n\nvec3 WorleyTangentSpaceNormal(vec3 pos) {\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( WorleyNoise3D(pos + epsilon.yxx) - WorleyNoise3D(pos - epsilon.yxx),\n                            WorleyNoise3D(pos + epsilon.xyx) - WorleyNoise3D(pos - epsilon.xyx),\n                            WorleyNoise3D(pos + epsilon.xxy) - WorleyNoise3D(pos - epsilon.xxy)));\n\n}\n\n    \n    \nmat4 transformMatrix(Transform t)\n{\n\tmat4 translate = mat4(      1.0,       0.0,       0.0, 0.0,\n                                0.0,       1.0,       0.0, 0.0,\n                                0.0,       0.0,       1.0, 0.0,\n                                t.trans.x,       t.trans.y,       t.trans.z, 1.0);\n    \n    float xRot = radians(t.rotate.x);\n    float yRot = radians(t.rotate.y);\n    float zRot = radians(t.rotate.z);\n    \n    mat4 rotateX = mat4(1.0,        0.0,       0.0, 0.0,\n                        0.0,  cos(xRot), sin(xRot), 0.0,\n                        0.0, -sin(xRot), cos(xRot), 0.0,\n                        0.0,        0.0,       0.0, 1.0);\n    \n    mat4 rotateY = mat4(cos(yRot), 0.0, -sin(yRot), 0.0,\n                              0.0, 1.0,        0.0, 0.0,\n                        sin(yRot), 0.0,  cos(yRot), 0.0,\n                              0.0, 0.0,        0.0, 1.0);\n    \n    mat4 rotateZ = mat4( cos(zRot), sin(zRot), 0.0, 0.0,\n                        -sin(zRot), cos(zRot), 0.0, 0.0,\n                               0.0,       0.0, 1.0, 0.0,\n                               0.0,       0.0, 0.0, 1.0);\n    \n    mat4 scale = mat4(      t.scale.x,       0.0,       0.0, 0.0,\n                            0.0,       t.scale.y,       0.0, 0.0,\n                            0.0,       0.0,       t.scale.z, 0.0,\n                            0.0,       0.0,       0.0, 1.0);\n    \n    return translate * rotateX * rotateY * rotateZ * scale;\n}\n\nmat4 rotMat(Transform t)\n{\n\tfloat xRot = radians(t.rotate.x);\n    float yRot = radians(t.rotate.y);\n    float zRot = radians(t.rotate.z);\n    \n    mat4 rotateX = mat4(1.0,        0.0,       0.0, 0.0,\n                        0.0,  cos(xRot), sin(xRot), 0.0,\n                        0.0, -sin(xRot), cos(xRot), 0.0,\n                        0.0,        0.0,       0.0, 1.0);\n    \n    mat4 rotateY = mat4(cos(yRot), 0.0, -sin(yRot), 0.0,\n                              0.0, 1.0,        0.0, 0.0,\n                        sin(yRot), 0.0,  cos(yRot), 0.0,\n                              0.0, 0.0,        0.0, 1.0);\n    \n    mat4 rotateZ = mat4( cos(zRot), sin(zRot), 0.0, 0.0,\n                        -sin(zRot), cos(zRot), 0.0, 0.0,\n                               0.0,       0.0, 1.0, 0.0,\n                               0.0,       0.0, 0.0, 1.0);\n    \n    return rotateX * rotateY * rotateZ;\n}\n\nmat3 TangentToWorld(vec3 nor) {\n\tvec3 tangent, bitangent;\n    CoordinateSystem(nor, tangent, bitangent);\n    return mat3(tangent, bitangent, nor);\n}\n\n// Cube SDF\nfloat cube(vec3 p, Transform cubeTrans)\n{\n\tvec3 q = vec3(abs(inverse(transformMatrix(cubeTrans)) * vec4(p, 1.0))) - vec3(0.5);\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// SquarePlane SDF\nfloat squarePlane(vec3 p, Transform squareTrans)\n{\n    mat4 squareMat = transformMatrix(squareTrans);\n    vec3 planeNormal = vec3(0, 0, 1);\n    vec3 actualPoint = vec3(inverse(squareMat) * vec4(p, 1.0f));    \n\treturn abs(dot(actualPoint, planeNormal));\n}\n\nfloat squarePlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p, n.xyz) + n.w;\n}\n\n\nbool isOnPlane(vec3 p, Transform squareTrans)\n{\n    mat4 squareMat = transformMatrix(squareTrans);\n\tvec3 ap = vec3(inverse(squareMat) * vec4(p, 1.0));\n    if(ap.x < 0.5f && ap.x > -0.5f && ap.y < 0.5f && ap.y > -0.5f)\n    {\n    \treturn true;\n    }\n    else\n    {\n    \treturn false;\n    }\n}\n\n\nvoid sceneMap3D(vec3 pos, out float t, out int obj)\n{\n    float minT = 10000.0;\n    obj = -1;\n    for(int i = 0; i < primitives.length(); i = i + 1)\n    {\n        if(primitives[i].primitiveId == SQUARE_PLANE)\n        {\n            vec4 curNor = normalize(rotMat(primitives[i].transform) * vec4(0.0, 0.0, 1.0, 0.0));\n            float maxOffset = max(max(abs(primitives[i].transform.trans.x), \n                                      abs(primitives[i].transform.trans.y)), \n                                      abs(primitives[i].transform.trans.z));\n            curNor.w = maxOffset;\n        \tt = squarePlane(pos, curNor);\n        }\n        else if(primitives[i].primitiveId == CUBE)\n        {\n        \tt = cube(pos, primitives[i].transform);\n        }\n        \n       \n        \n        if(t < minT)\n        {\n        \tminT = t;\n            obj = i;\n        }\n    }\n   \n    t = minT;\n}\n\n/*void sceneMap3D(vec3 pos, out float t, out int obj) {\n    t = cube(pos, longCube.transform);\n    obj = CUBE_1_ID;\n    \n    float t2;\n    if((t2 = SPHERE_2_SDF) < t) {\n        t = t2;\n        obj = SPHERE_2_ID;\n    }\n}*/\n\nfloat sceneMap3D(vec3 pos)\n{\n    float minT = 10000.0;\n    float t = minT;\n    for(int i = 0; i < primitives.length(); i++)\n    {\n        if(primitives[i].primitiveId == SQUARE_PLANE)\n        {\n        \tvec4 curNor = normalize(rotMat(primitives[i].transform) * vec4(0.0, 0.0, 1.0, 0.0));\n            float maxOffset = max(max(abs(primitives[i].transform.trans.x), \n                                      abs(primitives[i].transform.trans.y)), \n                                      abs(primitives[i].transform.trans.z));\n            curNor.w = maxOffset;\n        \tt = squarePlane(pos, curNor);\n        }\n        else if(primitives[i].primitiveId == CUBE)\n        {\n        \tt = cube(pos, primitives[i].transform);\n        }\n        \n       \n        if(t < minT)\n        {\n        \tminT = t;\n        }\n    }\n    t = minT;\n    return t;\n}\n\nfloat softShadow(vec3 dir, vec3 origin, float min_t, float k) {\n    float res = 1.0;\n    float t = min_t;\n    for(int i = 0; i < RAY_STEPS; ++i) {\n        float m = sceneMap3D(origin + t * dir);\n        if(m < 0.0001) {\n            return 0.0;\n        }\n        res = min(res, k * m / t);\n        t += m;\n    }\n    return res;\n}\n\nfloat fiveTapAO(vec3 p, vec3 n, float k) {\n    float aoSum = 0.0;\n    for(float i = 0.0; i < 5.0; ++i) {\n        float coeff = 1.0 / pow(2.0, i);\n        aoSum += coeff * (i * AO_DIST - sceneMap3D(p + n * i * AO_DIST));\n    }\n    return 1.0 - k * aoSum;\n}\n\nvec3 computeNormal(vec3 pos) {\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( sceneMap3D(pos + epsilon.yxx) - sceneMap3D(pos - epsilon.yxx),\n                            sceneMap3D(pos + epsilon.xyx) - sceneMap3D(pos - epsilon.xyx),\n                            sceneMap3D(pos + epsilon.xxy) - sceneMap3D(pos - epsilon.xxy)));\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj) {\n    t = 0.001;\n    for(int i = 0; i < RAY_STEPS; ++i) {\n        vec3 pos = origin + t * dir;\n    \tfloat m;\n        sceneMap3D(pos, m, hitObj);\n        if(primitives[hitObj].primitiveId == CUBE)\n        {\n        \tif(abs(m) < 0.01) \n                return;\n        }\n        else if(primitives[hitObj].primitiveId == SQUARE_PLANE)\n        {\n            if(abs(m) < 0.01) \n            {\n            \treturn;\n            }\n        \t\n        }\n        t += m;\n    }\n    t = -1.0;\n    hitObj = -1;\n}\n\nconst vec3 a = vec3(0.5, 0.5, 0.5);\nconst vec3 b = vec3(0.5, 0.5, 0.5);\nconst vec3 c = vec3(2.0, 1.0, 1.0);\nconst vec3 d = vec3(0.5, 0.2, 0.25);\n\nvec3 colorPalette(float t) {\n    return a + b * cos(6.28 * (t * c + d));\n}\n\nfloat subsurface(vec3 lightDir, vec3 normal, vec3 viewVec, float thickness) {\n    vec3 scatteredLightDir = lightDir + normal * DISTORTION;\n    float lightReachingEye = pow(clamp(dot(viewVec, scatteredLightDir), 0.0, 1.0), GLOW) * BSSRDF_SCALE;\n    float attenuation = 1.0;\n    #if ATTENUATION\n    attenuation = max(0.0, dot(normal, lightDir) + dot(viewVec, -lightDir));\n    #endif\n\tfloat totalLight = attenuation * (lightReachingEye + AMBIENT) * thickness;\n    return totalLight;\n}\n\nvec3 computeMaterial(int hitObj, vec3 p, vec3 n, vec3 lightVec, vec3 view, float thick) {\n    float lambert = max(0.0, dot(lightVec, n));\n    if(hitObj == -1)\n        return vec3(0.0, 0.0, 0.0);\n    if(hitObj == 5)\n    {\n    \tvec3 color = primitives[hitObj].matColor * lambert * vec3(1.0, 1.0, 1.0);\n        float sub = subsurface(lightVec, n, view, thick);\n        color = color + vec3(1.0, 0.0, 0.0) * sub * vec3(1.0, 1.0, 1.0);\n        //color = vec3(sub);\n    \treturn color;\n    }\n    vec3 color = primitives[hitObj].matColor * lambert * vec3(1.0, 1.0, 1.0);\n    return color;\n    \n}\n\nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\nIntersection sdf3D(vec3 dir, vec3 eye) {\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj);\n\n    vec3 isect = eye + t * dir;\n    vec3 nor = computeNormal(isect);\n    isect = isect + 0.01 * nor;\n    //vec3 lightDir = normalize(lightPos - isect);\n    \n    vec3 lightDir = normalize(rotateY(pointLight.transform.trans, iTime) - isect);\n    float thickness = fiveTapAO(isect, -nor, FIVETAP_K);\n    \n    vec3 surfaceColor = computeMaterial(hitObj, isect, nor, lightDir, normalize(eye - isect), thickness);\n   \t\n    \n    vec3 normalAsColor = 0.5 * (nor + vec3(1.0, 1.0, 1.0));\n    \n    return Intersection(t, surfaceColor, isect, hitObj);\n}\n\n\n\n\n// Returns direction of ray\nvec3 rayCast(vec3 eye, vec3 ref, vec2 ndc) {\n    vec3 F = ref - eye;\n    vec3 R = normalize(cross(F, vec3(0,1,0)));\n    vec3 U = normalize(cross(R, F)); \n    \n    vec3 V = U * length(F) * tan(FOVY * 0.5);\n    vec3 H = R * length(F) * tan(FOVY * 0.5) * float(iResolution.x) / iResolution.y;\n    \n    vec3 p = ref + ndc.x * H + ndc.y * V;\n    \n    return normalize(p - eye);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initializeCornelBox();\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    // Convert to range [-1, 1]\n    uv = uv * 2.0 - vec2(1.0, 1.0);\n    \n    vec3 eye = vec3(0, 4, -15);\n    vec3 ref = vec3(0, 2, 0);\n    \n    vec3 rayDir = rayCast(eye, ref, uv);\n    \n    Intersection isect = sdf3D(rayDir, eye);\n    \n    float focalLength = (sin(iTime) *  FOCAL_RANGE +  FOCAL_RANGE) / 2.0;\n\t\n    vec3 focalLine = isect.p - eye;\n    float distance = length(focalLine);\n    float disAlongCamZ = dot(focalLine, normalize(ref - eye));\n    float t = abs(disAlongCamZ - focalLength) / FOCAL_RANGE;\n    \n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    //fragColor = vec4(0.5 * (rayDir + vec3(1., 1., 1.)), 1.0);\n    fragColor = vec4(isect.color, t);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdScW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1351, 1351, 1379, 1421, 3644], [3646, 3665, 3704, 3704, 3737], [3739, 3739, 3764, 3764, 3935], [3937, 3937, 3961, 3961, 4180], [4183, 4183, 4212, 4234, 5207], [5209, 5209, 5270, 5270, 5494], [5496, 5496, 5537, 5537, 5875], [5887, 5887, 5922, 5922, 7346], [7348, 7348, 7374, 7374, 8234], [8236, 8236, 8267, 8267, 8384], [8386, 8398, 8439, 8439, 8594], [8596, 8615, 8665, 8665, 8869], [8871, 8871, 8908, 8934, 8966], [8969, 8969, 9016, 9016, 9258], [9261, 9261, 9314, 9314, 10144], [10369, 10369, 10397, 10397, 11204], [11206, 11206, 11269, 11269, 11534], [11536, 11536, 11578, 11578, 11791], [11793, 11793, 11823, 11823, 12142], [12144, 12144, 12208, 12208, 12703], [12851, 12851, 12879, 12879, 12925], [12927, 12927, 13004, 13004, 13408], [13410, 13410, 13499, 13499, 13997], [13999, 13999, 14030, 14030, 14113], [14115, 14115, 14155, 14155, 14759], [14764, 14792, 14836, 14836, 15166], [15168, 15168, 15225, 15225, 16080]], "test": "error"}
{"id": "tdScWV", "name": "Metaobjects", "author": "codecontemplator", "description": "Some more experiments", "tags": ["metaballs"], "likes": 1, "viewed": 122, "published": "Public", "date": "1587323645", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n// ref: http://www.iquilezles.org/www/articles/smin/smin.htm\nfloat smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n    \nfloat circle( vec2 p, float r) \n{\n    return length(p) - r;\n}\n\nfloat sdUnevenCapsule( vec2 p, float r1, float r2, float h )\n{\n    p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{  \n    vec2 p = fragCoord / iResolution.xy * 2.0 - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n      \n    p *= 0.75;\n    float time = iTime;\n    vec2 p1 = p;\n    pR(p1, time);\n    \n    p1 += vec2(0.2*sin(time), -0.25*cos(time));\n    time*=sqrt(0.5);\n    vec2 p2 = p + vec2(0.25*sin(time+2.0), 0.1*cos(time));\n    time*=sqrt(0.75);\n    vec2 p3 = p + vec2(0.1*sin(time), 0.3*cos(time));\n        \n    float d1 = sdUnevenCapsule(p1, .15, 0.25, 0.3);\n    float d2 = circle(p2, .15);\n    float d3 = circle(p3, .25);\n    float d = d1;\n    d = smin(d, d3, 10.0);\n    d = opSmoothSubtraction(d2, d, 0.4);\n        \n    fragColor = mix(vec4(0.5, 0.8, 0.3, 1), vec4(0.5, 0.2, 0.7, 1.0), 1.0);\n    \n    fragColor += pow(abs(sin(d*2.0)), 0.25 + abs(sin(iTime*0.1)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdScWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 63, 104, 104, 178], [180, 180, 238, 238, 338], [340, 340, 372, 372, 417], [423, 423, 456, 456, 484], [486, 486, 548, 548, 787], [789, 789, 844, 844, 1601]], "test": "valid"}
{"id": "tdsfDr", "name": "Градієнт", "author": "Drak_Lowell", "description": "Цікавий шейдер, в якому синій шар поглинає чорний, потім все перевертається", "tags": [], "likes": 0, "viewed": 185, "published": "Public API", "date": "1588088699", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float colCoef = mod(iTime, 10.0)/10.0; // Коефіцієнт кольору, який міняється з часом ( Коефіцієнт від 0.0 до 1.0 )\n    if(colCoef>0.5){\n        colCoef = 1.0 - colCoef; // Якщо коефіцієнт більше 0.5, перевертаємо його, роблячи зациклення ( Стає 0.0 до 0.5\n    }\n    colCoef += 0.5; // Збільшуємо коефіцієнт на 0.5 ( Тепер він від 0.5 до 1.0)\n    vec2 uv = (fragCoord/iResolution.xy)*vec2(4,4)-vec2(2,2); // Перетворюємо координати на діапазон від -2 до 2\n    float formulaCol = (uv.x*exp(-(pow(uv.x, 2.0)+pow(uv.y, 2.0)))+2.0)/4.0; // Виконуємо f(x, y) = xe−(x2 + y2) \n    float col = -formulaCol+colCoef; // Виконуємо накладання коефеціенту на колір\n    fragColor = vec4(0, 0, col, 1.0); // Виводимо колір на екран з прозорістю 1 ( НЕ прозорий )\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdsfDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1085]], "test": "valid"}
{"id": "tdSyDG", "name": "Infinite Tunnel", "author": "vahidk", "description": "All credits goes to @yosshin4004.\nhttps://twitter.com/yosshin4004/status/1251357672504360966", "tags": ["infinitetunnel"], "likes": 12, "viewed": 324, "published": "Public", "date": "1587242136", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 fragColor,in vec2 fragCoord) {\n  vec3 d=vec3(gl_FragCoord.xy/iResolution.xy-.5,.8),\n       p=vec3(0,sin(iTime*12.)/2e2,iTime),q;\n  for(int i=0;i<99;i++){\n    p+=d*min(.65-length(fract(p+.5)-.5),p.y+.2);\n    if(i==50) {\n      q=p,p-=d*.01,d=vec3(.7);\n    }\n  }\n  ivec3 u=ivec3(q*5e2);\n  fragColor=vec4((u.x^u.y^u.z)&255)/3e3*min(length(p-q)+1.,9.)+(p.z-iTime)*.1;\n}", "image_inputs": [{"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdSyDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 54, 54, 388]], "test": "valid"}
{"id": "tdSyDh", "name": "mandelbulb--derivate--v4", "author": "jorge2017a1", "description": "mandelbulb--derivate--v4\n///Original por IQ --> https://www.shadertoy.com/view/ltfSWn", "tags": ["mandelbulbderivatev4"], "likes": 4, "viewed": 68, "published": "Public", "date": "1586528428", "time_retrieved": "2021-10-01T00:00:00", "image_code": "///Original por IQ --> https://www.shadertoy.com/view/ltfSWn\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// The source code for these videos from 2009: \n// https://www.youtube.com/watch?v=eKUh4nkmQbc\n// https://www.youtube.com/watch?v=erS6SKqtXLY\n\n// More info here: http://iquilezles.org/www/articles/mandelbulb/mandelbulb.htm\n\n// See https://www.shadertoy.com/view/MdfGRr to see the Julia counterpart\n\n\n/*\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2  // make AA 1 for slow machines or 3 for fast machines\n#endif\n*/\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n///-----------------------------\n\nvec2 isphere( in vec4 sph, in vec3 ro, in vec3 rd )\n{\n    vec3 oc = ro - sph.xyz;\n    \n\tfloat b = dot(oc,rd);\n\tfloat c = dot(oc,oc) - sph.w*sph.w;\n    float h = b*b - c;\n    \n    if( h<0.0 ) return vec2(-1.0);\n\n    h = sqrt( h );\n\n    return -b + vec2(-h,h);\n}\n\n#define ZERO (min(iFrame,0))\n\n\nfloat map( in vec3 p, out vec4 resColor )\n{\n    vec3 w = p;\n    float m = dot(w,w);\n\n    vec4 trap = vec4(abs(w),m);\n\tfloat dz = 1.0;\n    \n    \n\tfor( int i=0; i<4; i++ )\n    {\n    \n        float potencia=8.0;\n        \n        dz = potencia*pow(sqrt(m),7.0)*dz + 1.0;\n\t\t//dz = 8.0*pow(m,3.5)*dz + 1.0;\n        \n        float r = length(w);\n        float b = potencia*acos( w.y/r);\n        float a = potencia*atan( w.x, w.z );\n        w = p + pow(r,potencia) * vec3( sin(b)*sin(a), cos(b), sin(b)*cos(a) );\n\n        trap = min( trap, vec4(abs(w),m) );\n\n        m = dot(w,w);\n\t\tif( m > 100.0 )\n            break;\n    }\n\n    resColor = vec4(m,trap.yzw);\n\n    float fra =0.25*log(m)*sqrt(m)/dz;\n    \n    \n    float sdb1 =sdBox(p- vec3(0.0), vec3(0.75) );\n    \n    float res=999.9 ;\n    \n    float dif1= differenceSDF(sdb1,fra) ;\n    \n    res=min(res,dif1);\n    return res;\n    \n    \n    \n}\n\nfloat intersect( in vec3 ro, in vec3 rd, out vec4 rescol, in float px )\n{\n    float res = -1.0;\n\n    // bounding sphere\n    vec2 dis = isphere( vec4(0.0,0.0,0.0,1.25), ro, rd );\n    if( dis.y<0.0 )\n        return -1.0;\n    dis.x = max( dis.x, 0.0 );\n    dis.y = min( dis.y, 10.0 );\n\n    // raymarch fractal distance field\n\tvec4 trap;\n\n\tfloat t = dis.x;\n    \n\tfor( int i=0; i<100; i++  )\n    { \n        vec3 pos = ro + rd*t;\n\t\tfloat h = map( pos, trap );\n\t     if(h < 0.001 || h > 1.){break;}\n        t += h;\n    }\n    \n    \n    if( t<dis.y )\n    {\n        rescol = trap;\n        res = t;\n    }\n\n    return res;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float k )\n{\n    float res = 1.0;\n    float t = 0.0;\n    for( int i=0; i<20; i++ )\n    {\n        vec4 kk;\n        float h = map(ro + rd*t, kk);\n        res = min( res, k*h/t );\n        if( res<0.001 ) break;\n        t += clamp( h, 0.01, 0.2 );\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos, in float t, in float px )\n{\n    vec4 tmp;\n    vec2 e = vec2(1.0,-1.0)*0.1*px;\n    \n    return normalize( e.xyy*map( pos + e.xyy,tmp ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx,tmp ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy,tmp ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx,tmp ) );\n}\n\nconst vec3 light1 = vec3(  0.577, 0.577, -0.577 );\nconst vec3 light2 = vec3( -0.707, 0.010,  0.707 );\n//const vec3 light3 = vec3( 0.707, -0.010,  0.707 );\nconst vec3 light3 = vec3( 0.0, 0.1,  0.0 );\n\n\nvec3 render( in vec2 p, in mat4 cam )\n{\n\t// ray setup\n    const float fle = 3.5;\n\n    vec2  sp = (2.0*p-iResolution.xy) / iResolution.y;\n    float px = 2.0/(iResolution.y*fle);\n\n    vec3  ro = vec3( cam[0].w, cam[1].w, cam[2].w );\n   \n\tvec3  rd = normalize( (cam*vec4(sp,fle,0.0)).xyz );\n   \n\n    // intersect fractal\n\tvec4 tra;\n    float t = intersect( ro, rd, tra, px );\n    \n\tvec3 col;\n\n    // color sky\n    if( t<0.0 )\n    {\n     \tcol  = vec3(0.8,.9,1.1)*(0.6+0.4*rd.y);\n\t\tcol += 5.0*vec3(0.8,0.7,0.5)*pow( clamp(dot(rd,light1),0.0,1.0), 32.0 );\n\t}\n    // color fractal\n\telse\n\t{\n        // color\n        col = vec3(0.01);\n\t\tcol = mix( col, vec3(0.10,0.20,0.30), clamp(tra.y,0.0,1.0) );\n\t \tcol = mix( col, vec3(0.02,0.10,0.30), clamp(tra.z*tra.z,0.0,1.0) );\n        col = mix( col, vec3(0.30,0.10,0.02), clamp(pow(tra.w,6.0),0.0,1.0) );\n        \n        // lighting terms\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, t, px );\n        vec3 hal = normalize( light1-rd);\n        vec3 ref = reflect( rd, nor );\n        float occ = clamp(0.05*log(tra.x),0.0,1.0);\n        float fac = clamp(1.0+dot(rd,nor),0.0,1.0);\n\n        // sun\n        //float sha1 = softshadow( pos+0.001*nor, light1, 32.0 );\n        float sha1 =0.55;\n        \n        float dif1 = clamp( dot( light1, nor ), 0.0, 1.0 )*sha1;\n        \n        \n        float spe1 = pow( clamp(dot(nor,hal),0.0,1.0), 32.0 )*dif1*(0.04+0.96*pow(clamp(1.0-dot(hal,light1),0.0,1.0),5.0));\n        // bounce\n        float dif2 = clamp( 0.5 + 0.5*dot( light2, nor ), 0.0, 1.0 )*occ;\n        \n        // sky\n        float dif3 = (0.7+0.3*nor.y)*(0.2+0.8*occ);\n   \n        float dif4 = clamp( dot( light3, nor ), 0.0, 1.0 );\n        \n        \n\t\tvec3 lin = vec3(0.0); \n\t\t     lin += 7.0*vec3(1.50,1.10,0.70)*dif1;\n\t\t     lin += 4.0*vec3(0.25,0.20,0.15)*dif2;\n        \t lin += 1.5*vec3(0.10,0.20,0.30)*dif3;\n             lin += 2.5*vec3(0.35,0.30,0.25)*(0.05+0.95*occ); // ambient\n   \n        \t  lin += 7.0*vec3(1.50,1.10,0.70)*dif4;\n        \n\t\tcol *= lin;\n\t\tcol = pow( col, vec3(0.7,0.9,1.0) );                  // fake SSS\n   \n        col += spe1*vec3(1.0)*20.0;\n        \n    }\n\n    // gamma\n\tcol = sqrt( col );\n    \n    // vignette\n    //col *= 1.0 - 0.05*length(sp);\n\n    return col;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    float time = iTime*0.5;\n\n    \n    // camera\n\tfloat di = 1.4+0.2*cos(time);\n\tvec3  ro = di * vec3( cos(.33*time), 0.8*sin(.37*time), sin(.31*time) );\n\tvec3  ta = vec3(0.0,0.1,0.0);\n\tfloat cr = 0.5*cos(0.1*time);\n\n    // camera matrix\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cw = normalize(ta-ro);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv =          (cross(cu,cw));\n    mat4 cam = mat4( cu, ro.x, cv, ro.y, cw, ro.z, 0.0, 0.0, 0.0, 1.0 );\n    \n   \n   vec3 col = render(  fragCoord, cam );\n    \n   \n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdSyDh.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[610, 610, 645, 645, 669], [672, 687, 718, 718, 868], [871, 871, 919, 919, 952], [988, 988, 1041, 1041, 1248], [1281, 1281, 1324, 1324, 2165], [2167, 2167, 2240, 2240, 2779], [2781, 2781, 2837, 2837, 3111], [3113, 3113, 3170, 3170, 3398], [3601, 3601, 3640, 3654, 5854], [5860, 5860, 5917, 5917, 6466]], "test": "valid"}
{"id": "tdSyWt", "name": "Rainbow yaaay", "author": "KavabONga", "description": "No idea what this is gonna be yaaaay", "tags": ["3dperlinnoise"], "likes": 3, "viewed": 72, "published": "Public", "date": "1587495298", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float noise(float x) {\n\treturn mod(sin(x * 1267.123 + 2346.723) * 13212.32 , 1.);\n}\nfloat noise(vec2 pos) {\n    //return noise(sin(pos.x * 1823.213 + 71322.123) * 381237. + sin(pos.y  *46372.123 + 6721.12) * 21973.213);\n    return noise(noise(pos.x) * 7821.23 + noise(pos.y) * 13798.321);\n}\nfloat noise(vec3 pos) {\n    return noise(noise(pos.xy * 1239.2136 + 213.21) * 2678.213 + noise(pos.xz * 1387. + 2137.) * 7312.321 + noise(pos.yz * 168. + 1237.) * 123.321);\n}\nvec2 pixelate(vec2 pos, vec2 cell) {\n\treturn floor(pos / cell) * cell;\n}\n\nfloat perlin(vec2 p)\n{\n\tvec2 fl = floor(p);\n\tvec2 fr = fract(p);\n\t\n\tfr.x = smoothstep(0.0,1.0,fr.x);\n\tfr.y = smoothstep(0.0,1.0,fr.y);\n\t\n\tfloat a = mix(noise(fl + vec2(0.0,0.0)), noise(fl + vec2(1.0,0.0)),fr.x);\n\tfloat b = mix(noise(fl + vec2(0.0,1.0)), noise(fl + vec2(1.0,1.0)),fr.x);\n\t\n\treturn mix(a,b,fr.y);\n}\nfloat perlin(vec3 p) {\n    vec3 fl = floor(p);\n\tvec3 fr = fract(p);\n\t\n\tfr = smoothstep(0.,1.,fr);\n\t\n\tfloat a = noise(fl + vec3(0., 0., 0.)),\n          b = noise(fl + vec3(1., 0., 0.)),\n          c = noise(fl + vec3(1., 1., 0.)),\n          d = noise(fl + vec3(0., 1., 0.)),\n          e = noise(fl + vec3(0., 0., 1.)),\n          f = noise(fl + vec3(1., 0., 1.)),\n          g = noise(fl + vec3(1., 1., 1.)),\n          h = noise(fl + vec3(0., 1., 1.));\n    float ab = mix(a, b, fr.x),\n          dc = mix(d, c, fr.x),\n          ef = mix(e, f, fr.x),\n          hg = mix(h, g, fr.x);\n    float abef = mix(ab, ef, fr.z), dchg = mix(dc, hg, fr.z);\n    return mix(abef, dchg, fr.y);\n}\nmat2x2 rotate(float a) {\n\treturn mat2x2(cos(a), -sin(a), sin(a), cos(a));\n} \nfloat fbm(vec2 p)\n{\n    float result = 0.;\n    float gain = .5, lacunarity = 2.;\n\t\n    float cur_gain = 1.;\n    int iterations = 5;\n\tfor(int i = 0;i < iterations; i++)\n\t{\n\t\tresult += perlin(p) * cur_gain;\n\t\tp = rotate(1.3) * p * lacunarity;\n\t\tcur_gain *= gain;\n\t}\n\tresult /= (pow(gain, float(iterations)) - 1.) / (gain - 1.);\n\treturn result;\n}\nfloat fbm(vec3 p)\n{\n    float result = 0.;\n    float gain = .5, lacunarity = 2.;\n\t\n    float cur_gain = 1.;\n    int iterations = 2;\n\tfor(int i = 0;i < iterations; i++)\n\t{\n\t\tresult += perlin(p) * cur_gain;\n\t\tp = p * lacunarity;\n\t\tcur_gain *= gain;\n\t}\n\tresult /= (pow(gain, float(iterations)) - 1.) / (gain - 1.);\n\treturn result;\n}\nfloat fbm(vec2 p, float height)\n{\n    return fbm(vec3(p, height));\n}\n\nconst vec3 red = vec3(255., 0., 0.) / 256.;\nconst vec3 orange = vec3(255., 127., 0.) / 256.;\nconst vec3 yellow = vec3(255., 255., 0.) / 256.;\nconst vec3 green = vec3(0., 255., 0.) / 256.;\nconst vec3 blue = vec3(80., 80., 255.) / 256.;\nconst vec3 purple = vec3(129., 0., 127.) / 256.;\nconst vec3 pink = vec3(255., 192., 203.) / 256.;\n\n\nfloat between(float left, float right, float x) {\n    float w = 1. / min(iResolution.x, iResolution.y);\n    return smoothstep(left - w, left + w, x) * smoothstep(x - w, x + w, right);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Pixelated coordinates\n    vec2 uv = fragCoord/min(iResolution.x, iResolution.y);\n    //uv = pixelate(uv, vec2(0.01, 0.01));\n\n    // Assigning color depending on value\n    float level = clamp(length(uv + fbm(vec3(uv * 8. + iTime, iTime)) / 6.) / 2.2, 0., 1.);\n    vec3 col = vec3(0.);\n    col += between(0., .14, level) * pink;\n    col += between(.14, .28, level) * purple;\n    col += between(.28, .42, level) * blue;\n    col += between(.42, .56, level) * green;\n    col += between(.56, .68, level) * yellow;\n    col += between(.68, .8, level) * orange;\n    col += between(.8, 1., level) * red;\n    \n    // Adding noise (idk why)\n    //col = col * (50. + noise(pixelate(uv, vec2(0.01)) + iTime)) / 51.;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdSyWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 83], [84, 84, 107, 219, 290], [291, 291, 314, 314, 465], [466, 466, 502, 502, 538], [540, 540, 562, 562, 853], [854, 854, 876, 876, 1528], [1529, 1529, 1553, 1553, 1604], [1606, 1606, 1625, 1625, 1949], [1950, 1950, 1969, 1969, 2279], [2280, 2280, 2313, 2313, 2348], [2685, 2685, 2734, 2734, 2870], [2872, 2872, 2929, 2958, 3700]], "test": "valid"}
{"id": "tdXBD8", "name": "ValueNoiseTutorial", "author": "oroborositron", "description": "Some initial experiments with value noise following the Art of Coding tutorial on this subject at https://www.youtube.com/watch?v=zXsWftRdsvU . Thanks! :)", "tags": ["valuenoise", "artofcoding", "youtubetutorial", "experimentswithglsl"], "likes": 2, "viewed": 54, "published": "Public", "date": "1588115741", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random(vec2 uv)\n{\n\treturn fract(sin(uv.x*123. + uv.y*987.)*456. + cos(uv.y*123. + uv.x*987.)*456.);\n}\n\nfloat flip_coin(vec2 uv)\n{\n\tfloat gen = random(uv);\n    if(gen < 0.5)\n    {\n    \treturn -1.;\n    }\n    else if(gen == 0.5)\n    {\n    \treturn 0.;\n    }\n    else\n    {\n    \treturn +1.;\n    }\n}\n\nfloat smoothNoise(vec2 uv)\n{\n\tvec2 luv = fract(uv);\n    vec2 lid = floor(uv);\n    \n    luv = luv*luv*(3.-2.*luv);\n    \n    float bl = random(lid);\n    float br = random(lid + vec2(1,0));\n    float b = mix(bl, br, luv.x);\n    \n    float tl = random(lid + vec2(0,1));\n    float tr = random(lid + vec2(1,1));\n    float t = mix(tl, tr, luv.x);\n    \n    return mix(b, t, luv.y);\n}\n\nfloat smoothNoiseLayered(vec2 uv, float startingZoom)\n{\n\tfloat o = smoothNoise(uv*startingZoom);\n    //o += smoothNoise(uv * 2.) * 1./2.;\n    //o += smoothNoise(uv * 4.) * 1./4.;\n    o += smoothNoise(uv * startingZoom * 2.) * 1./(2.);\n    o += smoothNoise(uv * startingZoom * 4.) * 1./(4.);\n    o += smoothNoise(uv * startingZoom * 8.) * 1./(8.);\n    o += smoothNoise(uv * startingZoom * 16.) * 1./(16.);\n    \n    return o / 2.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv += vec2(iTime * 0.025, iTime * 0.025);\n    \n    float base = 4.;\n    \n    float rand = 1.2;\n    \n    //rand = fract(uv.x + uv.y + rand);\n    \n    float gen_sign = 1.;\n    \n    float r = smoothNoiseLayered(uv, base + gen_sign * rand);\n    \n    rand = 1.4;\n    \n    //rand = fract(uv.x + uv.y + rand);\n    \n    gen_sign = 1.;\n    \n    float g = smoothNoiseLayered(uv, base + gen_sign * rand);\n    \n    rand = 1.1;\n    \n    //rand = fract(uv.x + uv.y + rand);\n    \n    gen_sign = -1.;\n    \n    float b = smoothNoiseLayered(uv, base + gen_sign * rand);\n    \n    vec3 col = vec3(r, g, b);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdXBD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 107], [109, 109, 135, 135, 299], [301, 301, 329, 329, 676], [678, 678, 733, 733, 1108], [1110, 1110, 1167, 1217, 1915]], "test": "valid"}
{"id": "tdXBDH", "name": "Blue, Purple, Plaid", "author": "somaholiday", "description": "A pulsing weave of diagonal lines.\n\nMy first GLSL shader from scratch.", "tags": ["blue", "purple", "plaid"], "likes": 3, "viewed": 85, "published": "Public", "date": "1588136719", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float stroke(float x, float s, float w) {\n    float feather = 0.005;\n    // float d = step(s, x + w*0.5) - step(s, x - w*0.5);\n    float d = smoothstep(s - feather, s + feather, x + w*0.5) - smoothstep(s - feather, s + feather, x - w*0.5);\n    return clamp(d, 0., 1.);\n}\n\nfloat sinN(float x) {\n    return (sin(x) + 1.) / 2.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 R = iResolution.xy;\n    vec2 pos = ( 2.*fragCoord - R ) / min(R.x,R.y);\n    \n    vec3 color = vec3(0.);\n    \n    float color_divisor = 6.;\n    float w_max = .1;\n    float nudge = .05;\n    \n    for (int i = 0; i < 10; i++) {\n        float w = sinN(iTime * 1.5 + pos.x - pos.y) * w_max;\n        \n        float sdf = (pos.x + float(i) * (w_max + nudge) - pos.y);\n        color += stroke(sdf, 0., w) / color_divisor;\n        \n        sdf = (pos.x - float(i) * (w_max + nudge) - pos.y);\n        color += stroke(sdf, 0., w) / color_divisor;\n    }\n    \n    for (int i = 0; i < 10; i++) {\n        float w = sinN(iTime * 1.5 + pos.x + pos.y) * w_max;\n        \n        float sdf_inv = (pos.x + float(i) * (w_max + nudge) + pos.y);\n        color += stroke(sdf_inv, 0., w) / color_divisor;\n        \n        sdf_inv = (pos.x - float(i) * (w_max + nudge) + pos.y);\n        color += stroke(sdf_inv, 0., w) / color_divisor;\n    }\n    \n    color *= vec3(sinN(iTime * 0.65 + pos.y) * 0.65, 0., 0.5);\n    \n    \n    // https://learnopengl.com/Advanced-Lighting/Gamma-Correction\n    float gamma = 1.8;\n    color = pow(color, vec3(1.0/gamma));\n    \n\tfragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdXBDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 270], [272, 272, 293, 293, 326], [329, 329, 386, 386, 1554]], "test": "valid"}
{"id": "tdXBW4", "name": "SimpleCloudNoise", "author": "mengxin", "description": "a simple noise", "tags": ["noise2d"], "likes": 1, "viewed": 66, "published": "Public", "date": "1588239055", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec2 hash22(vec2 p)\n{\n\tp = vec2(dot(p, vec2(127.1, 311.7)),\n\t\tdot(p, vec2(269.5, 183.3)));\n\n\treturn -1.0 + 2.0 * fract(sin(p)*43758.5453123);\n}\nfloat perlin_noise(vec2 p)\n{\n\tvec2 pi = floor(p);\n\tvec2 pf = p - pi;\n\n\tvec2 w = pf * pf * (3.0 - 2.0 * pf);\n\n\treturn mix(mix(dot(hash22(pi + vec2(0.0, 0.0)), pf - vec2(0.0, 0.0)),\n\t\tdot(hash22(pi + vec2(1.0, 0.0)), pf - vec2(1.0, 0.0)), w.x),\n\t\tmix(dot(hash22(pi + vec2(0.0, 1.0)), pf - vec2(0.0, 1.0)),\n\t\t\tdot(hash22(pi + vec2(1.0, 1.0)), pf - vec2(1.0, 1.0)), w.x),\n\t\tw.y);\n}\n\nfloat noise_sum(vec2 p)\n{\n\tfloat f = 0.0;\n\tp = p * 4.0;\n\tf += 1.0000 * perlin_noise(p); p = 2.0 * p;\n\tf += 0.5000 * perlin_noise(p); p = 2.0 * p;\n\tf += 0.2500 * perlin_noise(p); p = 2.0 * p;\n\tf += 0.1250 * perlin_noise(p); p = 2.0 * p;\n\tf += 0.0625 * perlin_noise(p); p = 2.0 * p;\n\n\treturn f;\n}\n\nfloat noise(vec2 uv){\n    return sin(uv.x)*sin(uv.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv=0.1*iTime+uv.xy;\n    uv*=1.0;\n    float value=noise_sum(uv.xy);\n    \n    vec3 col = vec3(value,value,value);\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdXBW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 22, 22, 144], [145, 145, 173, 173, 522], [524, 524, 549, 549, 818], [820, 820, 841, 841, 875], [878, 878, 935, 985, 1290]], "test": "valid"}
{"id": "tdXBWn", "name": "Stranded island", "author": "42yeah", "description": "This actually started as a water rendering experiment - http://www.iquilezles.org/www/articles/simplewater/simplewater.htm , but then I suddenly wanted to create an island and so I made one. I still have absolutely no idea about rendering water though.", "tags": ["raymarching", "water", "island"], "likes": 7, "viewed": 330, "published": "Public API", "date": "1588004851", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rand2d(vec2 p) {\n    return fract(sin(vec2(\n        dot(p, vec2(12.345, 67.890)),\n        dot(p, vec2(190.61, 312.21))\n    )) * 41235.45) * 2.0 - 1.0;\n}\n\nfloat perlin(vec3 p) {\n    vec2 u = floor(p.xz);\n    vec2 f = fract(p.xz);\n    vec2 s = smoothstep(0.0, 1.0, f);\n\n    vec2 a = rand2d(u);\n    vec2 b = rand2d(u + vec2(1.0, 0.0));\n    vec2 c = rand2d(u + vec2(0.0, 1.0));\n    vec2 d = rand2d(u + vec2(1.0, 1.0));\n\n    return mix(\n        mix(dot(a, f), dot(b, f - vec2(1.0, 0.0)), s.x),\n        mix(dot(c, f - vec2(0.0, 1.0)), dot(d, f - vec2(1.0, 1.0)), s.x),\n        s.y\n    );\n}\n\nfloat fbm(vec3 p) {\n    p.xz *= 2.0;\n    int octaves = 2;\n    float amplitude = 0.5;\n    float value = 0.0;\n    for (int i = 0; i < octaves; i++) {\n        p += iTime * vec3(0.1, 0.0, 0.3);\n        value += amplitude * perlin(p);\n        p *= 2.0;\n        amplitude *= 0.5;\n    }\n    return value;\n}\n\nfloat water(vec3 p) {\n    p.xz *= 0.2;\n    float f = fbm(p);\n    float g = fbm(p + vec3(0.5, 1.0, 0.2));\n    return p.y + fbm(vec3(f, 0.0, g)) - 0.5;\n}\n\nfloat distToCenter(vec3 p) {\n    return clamp(1.5 - length(p.xz) / 5.0, 0.0, 1.5);\n}\n\nfloat sol(vec3 p) {\n    float dtm = distToCenter(p);\n    float per = perlin(p * 0.7) * 1.0 + 3.5;\n    return p.y - per * dtm;\n//    return p.y + distToMiddle;\n}\n\nvec2 map(vec3 p) {\n    float closest = 1000.0;\n    float id = -1.0;\n    \n    float dist = water(p);\n    if (dist < closest) { closest = dist; id = 0.5; }\n    \n    dist = sol(p);\n    if (dist < closest) { closest = dist; id = 1.5; }\n    \n    return vec2(closest, id);\n}\n\nvec2 intersect(vec3 ro, vec3 rd) {\n    float depth = 0.0;\n    float id = -1.0;\n    for (int i = 0; i < 160; i++) {\n        vec2 info = map(ro + rd * depth);\n        if (info.x <= 0.001) {\n            id = info.y;\n            break;\n        }\n        depth += info.x;\n    }\n    return vec2(depth, id);\n}\n\nvec3 getIslandColor(vec3 p) {\n    vec3 baseColor = vec3(0.5, 0.21, 0.1);\n    float total = 1.0;\n    float sandiness = 1.0 - clamp((p.y - 0.2) * (perlin(p) * 0.5 + 0.5) * 1.3, 0.0, 1.0);\n    baseColor = mix(baseColor, vec3(0.76, 0.69, 0.5), sandiness);\n    \n    float grassiness = (total - sandiness) * clamp(1.0 - (p.y - 3.87), 0.0, 1.0);\n    baseColor = mix(baseColor, vec3(0.28, 0.6, 0.21), grassiness);\n    \n    baseColor = mix(baseColor, vec3(1.0, 1.0, 1.0), total - sandiness - grassiness);\n//    float dtm = distToMiddle(p);\n    return vec3(baseColor);\n}\n\nvec3 getSkyColor(vec3 p, vec3 rd) {\n    vec3 skyColor = vec3(0.3, 0.65, 0.99);\n    skyColor = mix(skyColor, vec3(1.0), pow(clamp(rd.y, 0.0, 1.0), 0.7));\n    return skyColor;\n}\n\nvec3 getColor(float id, vec3 p, vec3 rd) {\n    if (id < -0.5) { return getSkyColor(p, rd); }\n    if (id < 1.0) { return vec3(0.21, 0.67, 0.89) * 0.7; }\n    if (id < 2.0) { return getIslandColor(p); }\n    return vec3(1.0, 0.0, 0.0);\n}\n\nvec3 getNormal(vec3 p) {\n    const float epsilon = 0.001;\n    return normalize(vec3(\n        map(vec3(p.x + epsilon, p.yz)).x - map(vec3(p.x - epsilon, p.yz)).x,\n        map(vec3(p.x, p.y + epsilon, p.z)).x - map(vec3(p.x, p.y - epsilon, p.z)).x,\n        map(vec3(p.x, p.y, p.z + epsilon)).x - map(vec3(p.x, p.y, p.z - epsilon)).x\n    ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    float aspect = iResolution.x / iResolution.y;\n    uv.x *= aspect;\n    vec3 ro = vec3(13.0 - (sin(iTime) * 0.5 + 0.5), 3.0 + sin(iTime * 0.5), 1.0 + cos(iTime));\n    vec3 center = vec3(0.0, 1.5, 0.0);\n    \n    vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n    \n    vec3 front = normalize(center - ro);\n    vec3 right = normalize(cross(front, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(right, front));\n    mat4 lookAt = mat4(\n        vec4(right, 0.0),\n        vec4(up, 0.0),\n        vec4(front, 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n    vec3 rd = normalize(vec3(lookAt * vec4(uv, 2.0, 1.0)));\n    \n    vec2 info = intersect(ro, rd);\n    \n    vec3 pos = ro + rd * info.x;\n    \n    float foginess = 1.0 - clamp(distToCenter(pos) * 6.0, 0.0, 1.0);\n    if (foginess >= 1.0) {\n        vec3 objColor = getSkyColor(pos, rd);\n        objColor = pow(objColor, vec3(0.4545));\n        fragColor = vec4(objColor, 1.0);\n        return;\n    }\n    vec3 n = getNormal(pos);\n    \n    float ambient = 1.0;\n    float diffuse = max(dot(n, lightDir), 0.0);\n    float dome = 0.2 + 0.8 * clamp(n.y, 0.0, 1.0);\n    float back = max(dot(n, vec3(-lightDir.x, 0.0, -lightDir.z)), 0.0);\n    \n    vec3 light = vec3(0.0);\n    light += ambient * vec3(0.1, 0.1, 0.1);\n    light += diffuse * vec3(1.0, 1.0, 1.12);\n    light += dome * vec3(0.1, 0.1, 0.4);\n    light += back * vec3(5.0, 2.9, 2.0);\n\n    if (info.y < -0.5) {\n        light = vec3(1.0);\n    }\n\n    vec3 objColor = getColor(info.y, pos, rd) * light;\n    objColor = mix(objColor, getSkyColor(pos, rd), foginess);\n    objColor = pow(objColor, vec3(0.4545));\n\n    fragColor = vec4(objColor, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdXBWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 157], [159, 159, 181, 181, 588], [590, 590, 609, 609, 889], [891, 891, 912, 912, 1042], [1044, 1044, 1072, 1072, 1128], [1130, 1130, 1149, 1149, 1290], [1292, 1292, 1310, 1310, 1560], [1562, 1562, 1596, 1596, 1864], [1866, 1866, 1895, 1895, 2426], [2428, 2428, 2463, 2463, 2603], [2605, 2605, 2647, 2647, 2838], [2840, 2840, 2864, 2864, 3180], [3182, 3182, 3237, 3237, 4940]], "test": "valid"}
{"id": "tdXcDf", "name": "logistic_difference_v0003", "author": "darkczar", "description": "I'm reading James Gleick's book \"Chaos\" and got interested in x(n+1) = rx(n)*(1 - x(n))", "tags": ["psychedelic", "trippy"], "likes": 0, "viewed": 39, "published": "Public", "date": "1585716928", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// based on...\n// https://www.shadertoy.com/view/lssfW2\n\nfloat nsin(float x)\n{\n    return .5+.5*sin(x);\n}\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}  //https://gist.github.com/companje/29408948f1e8be54dd5733a74ca49bb9\n\nhighp float rand(vec2 co)  //from stackoverflow\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nuint hash( uint x ) {  //http://amindforeverprogramming.blogspot.com/2013/07/random-floats-in-glsl-330.html\n\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\nfloat random( float f ) {  //http://amindforeverprogramming.blogspot.com/2013/07/random-floats-in-glsl-330.html\n\n    const uint mantissaMask = 0x007FFFFFu;\n    const uint one          = 0x3F800000u;\n   \n    uint h = hash( floatBitsToUint( f ) );\n    h &= mantissaMask;\n    h |= one;\n    \n    float  r2 = uintBitsToFloat( h );\n    return r2 - 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float r = 0.0;\n    float g = 0.0;\n    float b = 0.0;\n    vec2 xy0 = vec2(0.,0.);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p=(fragCoord.xy-iResolution.xy)/iResolution.y;\n    \n    vec2 xy = vec2(0.,0.);\n    float rr = .5*(nsin(.15*iTime))+3.5; // + .5*nsin(iTime*.5); //2.57 +nsin(iTime); //+cos(iTime);\n    xy = uv;\n    for (int i = 0; i<6; i++)\n    {\n        xy = rr*xy*(vec2(1.0,1.0)-xy);\n        if(i==0)\n        {\n          xy0 = xy;  \n        }\n        if (i>0)\n            {\n                if(abs(length(xy) - length(xy0)) < .05) // try and tease out the cycles and color them\n                {\n                    r = 1.*random(float(mod(float(i),7.0)));\n                    g = 1.*random(1.28+float(mod(float(i),7.0)));\n                    b = 1.*random((1.0 - float(mod(float(i),7.0))));\n                }\n            }\n    }\n    if (length(xy) > 1.0)\n    {\n        r = .05;\n        g = 0.2;\n        b = 0.9;\n    } else\n    {\n        //r = .05;\n        //g = .99;\n        //b = .3;\n    }\n        \n        //m = (rand_point.x-prev_point.x) / ((rand_point.y-prev_point.y);\n        //line_y = m*p.x +  \n\n\n    \n    vec3 col = vec3(r, g, b);\n    float dn = col.x + col.y + col.z;\n    col /= dn;\n    // Output to screen\n    //fragColor = vec4(col,1.0);\n    fragColor = vec4( pow(col,vec3(1./2.2)),1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdXcDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 79, 79, 106], [108, 108, 180, 180, 246], [567, 567, 588, 674, 806], [807, 807, 832, 918, 1155], [1157, 1157, 1214, 1214, 2584]], "test": "valid"}
{"id": "tdXcDX", "name": "36 Days Of Type - J", "author": "nicolasdnl", "description": "36 Days Of Type - J", "tags": ["letter"], "likes": 0, "viewed": 32, "published": "Public", "date": "1585872500", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535897932384626433832795\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat msign( in float x ) { return (x>0.0)?1.0:-1.0; }\n\n// http://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nvec2 sdSqLine( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( dot2(pa-ba*h), ba.x*pa.y-ba.y*pa.x );\n}\n\nfloat sdCrescent(vec2 p, float r0, float r1, float d, float sign0, float sign1)\n{\n    float a = (r0*r0 - r1*r1 + d*d) / (2.0 * d);\n    \n    if( a < r0)\n    {\n        p.y = abs(p.y);\n        float b = sqrt(r0*r0-a*a);\n        float k = p.y*a - p.x*b;\n        float h = min(d*sign0*(d*(p.y-b)-k ),\n                      d*sign1*k);\n        if (h>0.0)\n        {\n            return length(p-vec2(a,b));\n        }\n    }\n    \n    return max(sign0*(length(p          )-r0),\n               sign1*(length(p-vec2(d,0))-r1));\n}\n\n// http://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nvec2 sdSqArc( in vec2 p, in vec2 a, in vec2 b, in float h, float d2min )\n{\n    vec2  ba  = b-a;\n    float l   = length(ba);\n    float ra2 = h*h + l*l*0.25;\n\n    // recenter\n    p -= (a+b)/2.0 + vec2(-ba.y,ba.x)*h/l;\n    \n    float m = ba.y*p.x-ba.x*p.y;\n    float n = dot(p,p);\n    \n    if( abs(h)*abs(ba.x*p.x+ba.y*p.y) < msign(h)*l*0.5*m )\n    {\n        d2min = min( d2min, n + ra2 - 2.0*sqrt(n*ra2) );\n    }\n\n    return vec2(d2min, -max(m,ra2-n) );\n}\n\n\n//------------------------------------------------------------\n\n\n\n// SDF of a shape made of a set line and arc segments\nfloat sdShape( in vec2 p, int kType[5], float kPath[13] )\n//float sdShape( in vec2 p, int kType[2], float kPath[7] )\n{\n    vec2 vb = vec2(kPath[0],kPath[1]);\n    \n    float d = dot2(p-vb);\n    int off = 0;\n    float s = 1.0;\n    for( int i=0; i<kType.length(); i++ )\n    {\n        vec2 va = vb;\n        vec2 ds;\n        \n        if( kType[i]==0) // line (x,y)\n        {\n            vb = vec2(kPath[off+2],kPath[off+3]);\n            ds = sdSqLine( p, va, vb );\n            off += 2;\n        }\n        else if( kType[i]==1 || kType[i]==2 ) // arc (x,y,r)\n        {\n            vb = vec2(kPath[off+3],kPath[off+4]);\n            ds = sdSqArc(p, va, vb, kPath[off+2], d );\n        \toff += 3;\n\n        }\n        \n        // in/out test\n        if ( kType[i]==2 )\n        {\n            bvec3 cond = bvec3( p.y<va.y, p.y<vb.y, ds.y>0.0 );\n            if( all(cond) || all(not(cond)) ) s*=-1.0;\n        }\n        else\n        {\n            bvec3 cond = bvec3( p.y>=va.y, p.y<vb.y, ds.y>0.0 );\n            if( all(cond) || all(not(cond)) ) s*=-1.0;\n        }\n\n        d = min( d, ds.x );\n    }\n    \n    if( p.y > 0. ) s*=-1.0;\n    \n\treturn s*sqrt(d);\n}\n\nfloat sdA( in vec2 p )\n{\n    float width = 1.;\n    float height = 1.;\n    \n   \tint kType[] = int[](0,0,2,0,0);\n\tfloat kPath[] = float[](  0.0,  height*0.5,\n                              width*0.5, height*0.5,\n                              width*0.5, 0.0, 0.0,\n                             -width*0.5, 0.0,\n                              0.0, 0.0,\n                              0.0,  height*0.5 );\n    /*int kType[] = int[](1,0);\n\tfloat kPath[] = float[](  width*0.5, 0.0, 0.0,\n                             -width*0.5, 0.0,\n                              width*0.5, 0.0 );*/\n    return sdShape(p,kType,kPath );\n}\n\nvec3 generateBorder(in vec3 col, in float border)\n{\n    col = mix( col, vec3(0.0), 1.0-smoothstep(0.0,0.015,border) );\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    vec2 p2 = p;\n    \n    // distance computations\n    float lineWidth = 0.08;\n    \n    float dMask = sdA(p);\n    \n    float t = mod(iTime * 0.5, 1.) * PI * 2.;\n    \n    p += vec2(-sin(t), cos(t)) * 0.08;\n    float transform = sign(mod(p.x, lineWidth) / lineWidth - 0.5);\n    float d = sdA(p);\n    \n    p2 -= vec2(-sin(t), cos(t)) * 0.08;\n    float transform2 = sign(mod(p2.x, lineWidth) / lineWidth - 0.5);\n    float d2 = sdA(p2);\n    \n    vec3 col = vec3(1.0) - sign(d)*vec3(1.0);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.15,abs(d)) );\n    col *= transform;\n    \n    vec3 col2 = vec3(1.0) - sign(d2)*vec3(1.0);\n\tcol2 = mix( col2, vec3(1.0), 1.0-smoothstep(0.0,0.15,abs(d2)) );\n    col2 *= transform2;\n    \n    vec3 color = col + col2;\n    \n    float mask = 1. - sign(dMask);\n\tmask = mix(mask, 1., 1.0-smoothstep(0.0,0.05,abs(dMask)));\n    \n    //color = (1.-color)*mask + color*(1.-mask);\n    color *= 1.-mask;\n\n    // output\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdXcDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 71, 71, 90], [91, 91, 118, 118, 145], [147, 221, 271, 271, 404], [406, 406, 487, 487, 922], [924, 998, 1072, 1072, 1451], [1520, 1574, 1692, 1692, 2716], [3329, 3329, 3380, 3380, 3465], [3467, 3467, 3524, 3560, 4588]], "test": "error"}
{"id": "tdXfD8", "name": "Simple DNA helis ", "author": "MetRiko", "description": "DNA helis", "tags": ["2d", "simple", "depth", "dna"], "likes": 0, "viewed": 112, "published": "Public", "date": "1588123355", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535897932384626433832795\n\nconst vec3 BACK = vec3(0,0,0);\nconst vec3 COLOR = vec3(0.8,0.8,0.7);\nconst vec3 SHADOW = vec3(0.2,0.2,0.35);\n\nconst float SPACE = 60.0; // space between lines\nconst float RADIUS = 80.0;\nconst float WIDTH = 4.0;\nconst float SQUARE_SIZE = 30.0;\nconst float MIN_SQUARE_SIZE = 15.0;\n\nconst float ANGLE = PI * 0.125 * 0.5;\nconst float Y_POSITION = 140.0;\nconst float TIME_SCALE = 16.0;\n\n// Draw rectangle\nfloat rectangle(vec2 coord, vec2 pos, vec2 size, float depth) { \n    vec2 bl = smoothstep(pos - size * 0.5 - 1.0 - depth, pos - size * 0.5 + 1.0 + depth, coord);\n\tvec2 tr = smoothstep(coord - 1.0 - depth, coord + 1.0 + depth, pos + size * 0.5);\n    return bl.x * bl.y * tr.x * tr.y;\n}\n\n// Range conversion: -1.0 - 1.0 -> 0.0 - 1.0\nfloat range(float x) { \n\treturn x * 0.5 + 0.5;\n}\n\n// 2D rotation matrix\nmat2 rotate(float a){\n    return mat2(cos(a), -sin(a),\n                sin(a), cos(a));\n}\n\nfloat linstep(float a, float b, float c) {\n\treturn clamp((c - a) / (b - a), 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float t = iTime * TIME_SCALE;\n    vec2 fc = rotate(ANGLE) * fragCoord;\n    float x = fc.x; // + t * 4.0;\n    float y = fc.y - Y_POSITION;\n       \n    // SINGLE ELEMENT COORD\n    \n    vec2 elCoord = vec2(mod(x, SPACE) - SPACE * 0.5, y);\n    x = floor(x / SPACE) * SPACE + t;\n    \n    // CALC\n    \n    float angle = -x * 0.097;\n    float sinV = sin(angle);\n    float cosV = cos(angle);\n    \n    // POSITIONS\n    \n    vec2 p1 = vec2(cosV, sinV);\n    vec2 p2 = vec2(-cosV, -sinV);\n    \n    // CONDITIONS\n    \n    bool condA = p1.x < p2.x; // amplitude condition\n    bool condI = p1.y < p2.y; // intersection condition\n    \n    // DEPTHS\n    \n    float lineDepth = mix(range(p1.x), range(p2.x), linstep(p1.y * RADIUS, p2.y * RADIUS, y));\n    float sq1Depth = range(p1.x);\n    float sq2Depth = range(p2.x);\n    \n    // SHAPES : LINE\n    \n    float lineHeight = abs(sinV) * RADIUS * 2.0 + 1.0;   \n    float line = rectangle(elCoord,  vec2(0.0), vec2(WIDTH, lineHeight), lineDepth * 3.0); \n    \n    // SHAPES : SQUARES\n    \n    float sqSize1 = mix(SQUARE_SIZE, MIN_SQUARE_SIZE, sq1Depth);\n    float sqSize2 = mix(SQUARE_SIZE, MIN_SQUARE_SIZE, sq2Depth);\n    \n    float[2] sq = float[2](\n    \trectangle(elCoord,  vec2(0.0, p1.y * RADIUS), vec2(sqSize1), sq1Depth * 3.0),\n    \trectangle(elCoord,  vec2(0.0, p2.y * RADIUS), vec2(sqSize2), sq2Depth * 3.0)\n    );\n    \n    // COLORS\n    \n    vec3[2] sqColors = vec3[2](\n        mix(COLOR, SHADOW, sq1Depth),\n        mix(COLOR, SHADOW, sq2Depth)\n    );\n    vec3 lineColor = mix(COLOR, SHADOW, lineDepth);\n    \n    vec3 color = mix(BACK, lineColor, float(line));\n    color = mix(mix(color, sqColors[int(condA)], float(sq[int(condA)])), sqColors[int(!condA)], sq[int(!condA)]);\n\n    fragColor = vec4(color, 0.0);\n    \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdXfD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[428, 446, 509, 509, 730], [732, 777, 799, 799, 825], [827, 849, 870, 870, 938], [940, 940, 982, 982, 1028]], "test": "valid"}
{"id": "tdXfzM", "name": "Intense M1", "author": "yasuo", "description": "https://www.pinkbike.com/news/the-history-of-intense-m-bikes.html", "tags": ["raymarching", "mountainbike"], "likes": 4, "viewed": 220, "published": "Public API", "date": "1587904293", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// All the distance functions from:http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define PI 3.141592653589793\n#define USE_MOUSE 0\n#define MAX_STEPS 126\n#define MAX_DIST 30.\n#define SURF_DIST .002\n#define framethickness 0.1\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define matRotateX(rad) mat3(1,0,0,0,cos(rad),-sin(rad),0,sin(rad),cos(rad))\n#define matRotateY(rad) mat3(cos(rad),0,-sin(rad),0,1,0,sin(rad),0,cos(rad))\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n\nvec4 combine(vec4 val1, vec4 val2 ){\n    return (val1.w < val2.w)?val1:val2;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// https://www.shadertoy.com/view/wdGXzK\n// http://mercury.sexy/hg_sdf/\nvec2 pModPolar(inout vec2 p, float repetitions, float fix) {\n    float angle = 2.0*PI/repetitions;\n    float a = atan(p.y, p.x) + angle/2.;\n    float r = length(p);\n    float c = floor(a/angle);\n    a = mod(a,angle) - angle/2.*fix;\n    p = vec2(cos(a), sin(a))*r;\n\n    return p;\n}\n\nfloat frameDist1(vec3 p) {\n    float size = 1.5;\n    float thickness = framethickness;\n    vec4 a1 = vec4(-0.6,size,0.0,0.0); // btm\n    float p1 = dot(p,a1.xyz) + a1.w;\n    \n    vec4 a2 = vec4(0.0,-size,0.0,1.0); // top\n    float p2 = dot(p,a2.xyz) + a2.w;\n        \n    vec4 a3 = vec4(size,2.0,0.0,0.8); // right\n    float p3 = dot(p,a3.xyz) + a3.w;\n            \n    vec4 a4 = vec4(-size,0.0,0.0,0.8); // left\n    float p4 = dot(p,a4.xyz) + a4.w;\n                \n    vec4 a5 = vec4(0.0,0.0,-size,thickness); // foward\n    float p5 = dot(p,a5.xyz) + a5.w;\n                    \n    vec4 a6 = vec4(0.0,0.0,size,thickness); // back\n    float p6 = dot(p,a6.xyz) + a6.w;\n\n    float d = max(-p1,max(-p2,max(-p3,max(-p4,max(-p5,-p6)))));\n    return d;\n}\n\nfloat frameDist1_2(vec3 p) {\n    float size = 3.0;\n    float thickness = framethickness;\n    vec4 a1 = vec4(-1.2,size,0.0,0.0); // btm\n    float p1 = dot(p,a1.xyz) + a1.w;\n    \n    vec4 a2 = vec4(0.0,-size,0.0,1.0); // top\n    float p2 = dot(p,a2.xyz) + a2.w;\n        \n    vec4 a3 = vec4(size,2.0,0.0,0.8); // right\n    float p3 = dot(p,a3.xyz) + a3.w;\n            \n    vec4 a4 = vec4(-size,0.0,0.0,0.8); // left\n    float p4 = dot(p,a4.xyz) + a4.w;\n                \n    vec4 a5 = vec4(0.0,0.0,-size,thickness); // foward\n    float p5 = dot(p,a5.xyz) + a5.w;\n                    \n    vec4 a6 = vec4(0.0,0.0,size,thickness); // back\n    float p6 = dot(p,a6.xyz) + a6.w;\n\n    float d = max(-p1,max(-p2,max(-p3,max(-p4,max(-p5,-p6)))));\n    return d;\n}\n\nfloat frameDist2(vec3 p) {\n    float size = 1.5;\n    float thickness = framethickness;\n    vec4 a1 = vec4(-1.0,size+1.0,0.0,0.0); // btm\n    float p1 = dot(p,a1.xyz) + a1.w;\n    \n    vec4 a2 = vec4(1.0,-size-1.0,0.0,0.8); // top\n    float p2 = dot(p,a2.xyz) + a2.w;\n        \n    vec4 a3 = vec4(size,0.0,0.0,1.0); // right\n    float p3 = dot(p,a3.xyz) + a3.w;\n            \n    vec4 a4 = vec4(-size,0.0,0.0,1.0); // left\n    float p4 = dot(p,a4.xyz) + a4.w;\n                \n    vec4 a5 = vec4(0.0,0.0,-size,thickness); // foward\n    float p5 = dot(p,a5.xyz) + a5.w;\n                    \n    vec4 a6 = vec4(0.0,0.0,size,thickness); // back\n    float p6 = dot(p,a6.xyz) + a6.w;\n\n    float d = max(-p1,max(-p2,max(-p3,max(-p4,max(-p5,-p6)))));\n    return d;\n}\n\nfloat frameDist3(vec3 p) {\n    float size = 1.5;\n    float thickness = framethickness;\n    vec4 a1 = vec4(1.5,size+1.0,0.0,0.0); // btm\n    float p1 = dot(p,a1.xyz) + a1.w;\n    \n    vec4 a2 = vec4(-1.5,-size-1.0,0.0,1.0); // top\n    float p2 = dot(p,a2.xyz) + a2.w;\n        \n    vec4 a3 = vec4(size,0.0,0.0,0.7); // right\n    float p3 = dot(p,a3.xyz) + a3.w;\n            \n    vec4 a4 = vec4(-size,0.0,0.0,0.7); // left\n    float p4 = dot(p,a4.xyz) + a4.w;\n                \n    vec4 a5 = vec4(0.0,0.0,-size,thickness); // foward\n    float p5 = dot(p,a5.xyz) + a5.w;\n                    \n    vec4 a6 = vec4(0.0,0.0,size,thickness); // back\n    float p6 = dot(p,a6.xyz) + a6.w;\n\n    float d = max(-p1,max(-p2,max(-p3,max(-p4,max(-p5,-p6)))));\n    return d;\n}\n\nfloat frameDist4(vec3 p) {\n    float size = 1.5;\n    float thickness = framethickness;\n    vec4 a1 = vec4(0.0,size+1.0,0.0,0.0); // btm\n    float p1 = dot(p,a1.xyz) + a1.w;\n    \n    vec4 a2 = vec4(0.0,-size-1.0,0.0,1.0); // top\n    float p2 = dot(p,a2.xyz) + a2.w;\n        \n    vec4 a3 = vec4(size,0.0,0.0,0.2); // right\n    float p3 = dot(p,a3.xyz) + a3.w;\n            \n    vec4 a4 = vec4(-size,0.0,0.0,0.2); // left\n    float p4 = dot(p,a4.xyz) + a4.w;\n                \n    vec4 a5 = vec4(0.0,0.0,-size,thickness); // foward\n    float p5 = dot(p,a5.xyz) + a5.w;\n                    \n    vec4 a6 = vec4(0.0,0.0,size,thickness); // back\n    float p6 = dot(p,a6.xyz) + a6.w;\n\n    float d = max(-p1,max(-p2,max(-p3,max(-p4,max(-p5,-p6)))));\n    return d;\n}\n\nfloat frameDist5(vec3 p) {\n    float size = 1.5;\n    float thickness = framethickness;\n    vec4 a1 = vec4(-3.2,size+1.0,0.0,0.0); // btm\n    float p1 = dot(p,a1.xyz) + a1.w;\n    \n    vec4 a2 = vec4(3.2,-size-1.0,0.0,1.2); // top\n    float p2 = dot(p,a2.xyz) + a2.w;\n        \n    vec4 a3 = vec4(size,0.0,0.0,0.44); // right\n    float p3 = dot(p,a3.xyz) + a3.w;\n            \n    vec4 a4 = vec4(-size,0.0,0.0,0.44); // left\n    float p4 = dot(p,a4.xyz) + a4.w;\n                \n    vec4 a5 = vec4(0.0,0.0,-size,thickness); // foward\n    float p5 = dot(p,a5.xyz) + a5.w;\n                    \n    vec4 a6 = vec4(0.0,0.0,size,thickness); // back\n    float p6 = dot(p,a6.xyz) + a6.w;\n\n    float d = max(-p1,max(-p2,max(-p3,max(-p4,max(-p5,-p6)))));\n    return d;\n}\n\nfloat frameDist6(vec3 p) {\n    float size = 1.5;\n    float thickness = framethickness*0.5;\n    vec4 a1 = vec4(-0.5,size+1.0,0.0,0.0); // btm\n    float p1 = dot(p,a1.xyz) + a1.w;\n    \n    vec4 a2 = vec4(0.5,-size-1.0,0.0,0.5); // top\n    float p2 = dot(p,a2.xyz) + a2.w;\n        \n    vec4 a3 = vec4(size,0.0,0.0,1.2); // right\n    float p3 = dot(p,a3.xyz) + a3.w;\n            \n    vec4 a4 = vec4(-size,0.0,0.0,1.2); // left\n    float p4 = dot(p,a4.xyz) + a4.w;\n                \n    vec4 a5 = vec4(0.0,0.0,-size,thickness); // foward\n    float p5 = dot(p,a5.xyz) + a5.w;\n                    \n    vec4 a6 = vec4(0.0,0.0,size,thickness); // back\n    float p6 = dot(p,a6.xyz) + a6.w;\n\n    float d = max(-p1,max(-p2,max(-p3,max(-p4,max(-p5,-p6)))));\n    return d;\n}\n\nfloat frameDist7(vec3 p) {\n    float size = 1.5;\n    float thickness = framethickness*0.5;\n    vec4 a1 = vec4(1.8,size+1.0,0.0,0.0); // btm\n    float p1 = dot(p,a1.xyz) + a1.w;\n    \n    vec4 a2 = vec4(-1.8,-size-1.0,0.0,0.5); // top\n    float p2 = dot(p,a2.xyz) + a2.w;\n        \n    vec4 a3 = vec4(size,0.0,0.0,0.4); // right\n    float p3 = dot(p,a3.xyz) + a3.w;\n            \n    vec4 a4 = vec4(-size,0.0,0.0,0.4); // left\n    float p4 = dot(p,a4.xyz) + a4.w;\n                \n    vec4 a5 = vec4(0.0,0.0,-size,thickness); // foward\n    float p5 = dot(p,a5.xyz) + a5.w;\n                    \n    vec4 a6 = vec4(0.0,0.0,size,thickness); // back\n    float p6 = dot(p,a6.xyz) + a6.w;\n\n    float d = max(-p1,max(-p2,max(-p3,max(-p4,max(-p5,-p6)))));\n    return d;\n}\n\nfloat frameDist8(vec3 p) {\n    float size = 1.5;\n    float thickness = framethickness*0.5;\n    vec4 a1 = vec4(-1.8,size+1.0,0.0,0.0); // btm\n    float p1 = dot(p,a1.xyz) + a1.w;\n    \n    vec4 a2 = vec4(1.8,-size-1.0,0.0,0.5); // top\n    float p2 = dot(p,a2.xyz) + a2.w;\n        \n    vec4 a3 = vec4(size,0.0,0.0,0.82); // right\n    float p3 = dot(p,a3.xyz) + a3.w;\n            \n    vec4 a4 = vec4(-size,0.0,0.0,0.82); // left\n    float p4 = dot(p,a4.xyz) + a4.w;\n                \n    vec4 a5 = vec4(0.0,0.0,-size,thickness); // foward\n    float p5 = dot(p,a5.xyz) + a5.w;\n                    \n    vec4 a6 = vec4(0.0,0.0,size,thickness); // back\n    float p6 = dot(p,a6.xyz) + a6.w;\n\n    float d = max(-p1,max(-p2,max(-p3,max(-p4,max(-p5,-p6)))));\n    return d;\n}\n\nfloat frameDist9(vec3 p) {\n    float size = 1.5;\n    float thickness = framethickness*2.0;\n    vec4 a1 = vec4(1.8,size+1.0,0.0,0.0); // btm\n    float p1 = dot(p,a1.xyz) + a1.w;\n    \n    vec4 a2 = vec4(-1.8,-size-1.0,0.0,0.5); // top\n    float p2 = dot(p,a2.xyz) + a2.w;\n        \n    vec4 a3 = vec4(size,0.0,0.0,0.2); // right\n    float p3 = dot(p,a3.xyz) + a3.w;\n            \n    vec4 a4 = vec4(-size,0.0,0.0,0.2); // left\n    float p4 = dot(p,a4.xyz) + a4.w;\n                \n    vec4 a5 = vec4(0.0,0.0,-size,thickness); // foward\n    float p5 = dot(p,a5.xyz) + a5.w;\n                    \n    vec4 a6 = vec4(0.0,0.0,size,thickness); // back\n    float p6 = dot(p,a6.xyz) + a6.w;\n\n    float d = max(-p1,max(-p2,max(-p3,max(-p4,max(-p5,-p6)))));\n    return d;\n}\n\nfloat spokeDist(vec3 p) {\n    float size = 1.5;\n    float thickness = framethickness*0.2;\n    vec4 a1 = vec4(0.0,size+1.0,0.0,0.8); // btm\n    float p1 = dot(p,a1.xyz) + a1.w;\n    \n    vec4 a2 = vec4(0.0,-size-1.0,0.0,0.8); // top\n    float p2 = dot(p,a2.xyz) + a2.w;\n        \n    vec4 a3 = vec4(size,0.0,0.0,0.01); // right\n    float p3 = dot(p,a3.xyz) + a3.w;\n            \n    vec4 a4 = vec4(-size,0.0,0.0,0.01); // left\n    float p4 = dot(p,a4.xyz) + a4.w;\n                \n    vec4 a5 = vec4(0.0,0.0,-size,thickness); // foward\n    float p5 = dot(p,a5.xyz) + a5.w;\n                    \n    vec4 a6 = vec4(0.0,0.0,size,thickness); // back\n    float p6 = dot(p,a6.xyz) + a6.w;\n\n    float d = max(-p1,max(-p2,max(-p3,max(-p4,max(-p5,-p6)))));\n    return d;\n}\n\nfloat frameFrontDist(vec3 p) {\n    float f1 = frameDist1(p-vec3(0.0,0.1,0.0));\n    float f2 = frameDist2(p-vec3(-1.,-0.3,0.0));\n    float f3 = frameDist3(p-vec3(-1.1,0.43,0.0));\n    float f4 = frameDist4(p-vec3(-1.25,0.3,0.0));\n    float f5 = frameDist5(p-vec3(-1.37,-0.2,0.0));\n    \n    float f6 = sdCappedCylinder(p-vec3(0.6,0.54,0.0),0.08,0.3);\n    float f7 = sdCappedCylinder(p-vec3(-1.65,1.0,0.0),0.08,0.4);\n    \n    p.z = abs(p.z);\n    p.z-=0.05;\n    float f8 = frameDist1_2(p-vec3(0.1,0.28,0.0));\n    \n    float d = min(f1,min(f2,min(f3,min(f4,min(f5,min(f6,f7))))));\n    d = max(-f8,d);\n    return d*0.6;\n}\n\nfloat frameBackDist(vec3 p) {\n    vec3 prevP = p;\n    p.z = abs(p.z);\n    p *= matRotateY(radians(5.0));\n    p.z-=0.2;\n    float f1 = frameDist6(p-vec3(0.25,-0.9,0.0));\n    float f2 = frameDist7(p-vec3(0.8,-0.4,0.0));\n    float f3 = frameDist8(p-vec3(-0.02,-0.6,0.0));\n    p = prevP;\n    float f4 = frameDist9(p-vec3(0.8,-0.4,0.0));\n    \n    vec3 p2 = p-vec3(-0.4,-0.8,0.0);\n    p2*=matRotateX(radians(90.0));\n    float f5 = sdCappedCylinder(p2,0.07,0.2);\n    \n    float d = min(f1,min(f2,min(f3,min(f4,f5))));\n    return d*0.6;\n}\n\nfloat rearSuspensionDist(vec3 p) {\n    vec3 prevP = p;\n    p.y = mod(p.y,0.1)-0.05;\n    vec3 fp1 = p;\n    float f1 = sdTorus(fp1,vec2(0.07,0.03));\n    p = prevP;\n    fp1 = p;\n    float mask = sdBox(fp1,vec3(0.1,0.22,0.1));\n    float d3 = max(mask,f1);\n    return d3*0.6;\n}\n\nvec4 frontSuspension(vec3 p) {\n    vec3 prevP = p;\n    p.x -= 1.1;\n    p.y -= 1.2;\n    p.z = abs(p.z);\n    p.z -=0.19;\n    vec3 sp1 = p-vec3(0.0,0.0,0.0);\n    float s1 = sdCappedCylinder(sp1,0.08,0.5);\n    float d = s1;\n    vec4 res = vec4(vec3(0.7,0.0,0.0),d*0.6);\n    \n    vec3 sp2 = p-vec3(0.0,0.9,0.0);\n    float s2 = sdCappedCylinder(sp2,0.05,0.53);\n    d = s2;\n    vec4 res2 = vec4(vec3(0.9,0.9,0.6),d*0.6);\n    \n    p = prevP;\n    vec3 sp3 = p-vec3(1.1,0.8,0.0);\n    sp3*=matRotateX(radians(90.0));\n    float s3 = sdCappedCylinder(sp3,0.07,0.12);\n    d = s3;\n    vec4 res3 = vec4(vec3(0.8),d*0.3);\n    \n    return combine(res,combine(res2,res3));\n}\n\nvec4 stemandhandle(vec3 p) {\n    vec3 prevP = p;\n    vec3 sp1 = p-vec3(0.31,2.8,0.0);\n    float s1 = sdBox(sp1,vec3(0.16,0.08,0.12));\n    float d = s1;\n    vec4 res = vec4(vec3(0.8),d*0.6);\n    \n    vec3 sp2 = p-vec3(0.37,2.8,0.0);\n    \n    p.z = abs(p.z);\n    p.z -=0.4;\n    vec3 sp3 = p-vec3(0.28,2.9,0.0);\n    sp2*=matRotateX(radians(90.0));\n    sp3*=matRotateX(radians(-50.0))*matRotateZ(radians(-30.0));\n    float s2 = sdCappedCylinder(sp2,0.04,0.3);\n    float s3 = sdCappedCylinder(sp3,0.04,0.2);\n    d = min(s2,s3);\n    vec4 res2 = vec4(vec3(0.3),d*0.6);\n    \n    return combine(res,res2);\n}\n\nvec4 tyre(vec3 p) {\n    p.x = abs(p.x);\n    p.x -=0.95;\n    vec3 prevP = p;\n    p-=vec3(0.95,1.1,0.0);\n    p.yx = pModPolar(p.yx,20.0,1.0);\n    p.y -= 0.4;\n    \n    vec3 tp1 = p-vec3(0.0,0.0,0.0);\n    float t1 = spokeDist(tp1); \n    p = prevP;\n    \n    vec3 tp2 = p-vec3(0.95,1.1,0.0);\n    tp2*=matRotateX(radians(90.0));\n    float t2 = sdTorus(tp2,vec2(0.75,0.03));\n    float d = min(t1,t2);\n    vec4 res = vec4(vec3(0.6),d*0.6);\n    \n    vec3 tp3 = p-vec3(0.95,1.1,0.0);\n    tp3*=matRotateX(radians(90.0));\n    float t3 = sdTorus(tp3,vec2(0.8,0.05));\n    vec4 res2 = vec4(vec3(0.2),t3*0.3);\n    \n    return combine(res,res2);\n}\n\nvec4 saddles(vec3 p) {\n    vec3 prevP = p;\n    vec3 sp1 = p-vec3(-1.85,2.9,0.0);\n    \n    float sc = mix(0.1,3.0,smoothstep(-1.0,1.0,sp1.x));\n    sp1.yz *= sc;\n    sp1.y*= 3.0;\n    sp1.z*= 1.2;\n    float s1 = length(sp1)-0.3;\n    float d = s1;\n    vec4 res = vec4(vec3(0.3),d*0.3);\n    \n    vec3 sp2 = p-vec3(-1.8,2.7,0.0);\n    sp2*=matRotateZ(radians(-15.0));\n    float s2 = sdCappedCylinder(sp2,0.04,0.2);\n    \n    d = s2;\n    vec4 res2 = vec4(vec3(0.8),d*0.3);\n    \n    return combine(res,res2);\n}\n\nvec4 intenseM1(vec3 p){\n    vec3 front = p-vec3(1.5,1.0,0.0);\n    mat3 frot = matRotateZ(radians(-15.0));\n    front *= frot;\n    float d = frameFrontDist(front);\n    vec4 res = vec4(vec3(0.8,0.0,0.0),d*0.5);\n    \n    vec3 back = p-vec3(-1.0,1.0,0.0);\n    d = frameBackDist(back);\n    vec4 res2 = vec4(vec3(0.8),d*0.5);\n    \n    vec3 sus = p-vec3(-0.12,0.9,0.0);\n    sus *= matRotateZ(radians(50.0));\n    d = rearSuspensionDist(sus);\n    vec4 res3 = vec4(vec3(0.8,0.8,0.0),d*0.5);\n    \n    vec3 fsus = p-vec3(1.55,-0.87,0.0);\n    fsus *= frot;\n    vec4 res4 = frontSuspension(fsus);\n    \n    vec3 stem = p-vec3(2.35,-0.75,0.0);\n    stem *= frot;\n    vec4 res5 = stemandhandle(stem);\n    \n    vec3 tyreP = p-vec3(0.5,-0.9,0.0);\n    vec4 res6 = tyre(tyreP);\n    \n    vec3 saddleP = p-vec3(1.3,-0.6,0.0);\n    vec4 res7 = saddles(saddleP);\n    \n    return combine(res,combine(res2,combine(res3,combine(res4,combine(res5,combine(res6,res7))))));\n}\n\nvec4 GetDist(vec3 p) {\n    vec4 res = intenseM1(p-vec3(-0.4,0.0,0.0));\n    return res;\n}\n\nvec4 RayMarch(vec3 ro, vec3 rd) {\n    vec4 dO= vec4(0.0,0.0,0.0,1.0);\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO.w;\n        vec4 dS = GetDist(p);\n        dO.w += dS.w;\n        dO.xyz = dS.xyz;\n        if(dO.w>MAX_DIST || dS.w<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).w;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).w,\n        GetDist(p-e.yxy).w,\n        GetDist(p-e.yyx).w);\n    \n    return normalize(n);\n}\n\nvec2 GetLight(vec3 p) {\n    vec3 lightPos = vec3(2,9,3);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l).w;\n    \n    float lambert = max(.0, dot( n, l))*0.1;\n    \n    return vec2((lambert+dif),1.0);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    float t = mod(iTime,8000.0);\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 4, -4.5);\n    #if USE_MOUSE == 1\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    #else\n    ro.yz *= Rot(radians(-30.0));\n    ro.xz *= Rot(t*.3+1.0);\n    #endif\n    \n    vec3 rd = R(uv, ro, vec3(0,1,0), 1.);\n\n    vec4 d = RayMarch(ro, rd);\n    \n    if(d.w<MAX_DIST) {\n        vec3 p = ro + rd * d.w;\n    \n        vec2 dif = GetLight(p);\n        col = vec3(dif.x)*d.xyz;\n        col *= dif.y;\n        \n    } else {\n        // background\n        col =.84*max(mix(vec3(1.2,1.2,1.1)+(.1-length(uv.xy)/3.),vec3(1),.1),0.);\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdXfzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[590, 590, 626, 626, 668], [670, 670, 699, 699, 783], [785, 785, 837, 837, 944], [946, 946, 979, 979, 1044], [1046, 1118, 1178, 1178, 1398], [1400, 1400, 1426, 1426, 2147], [2149, 2149, 2177, 2177, 2898], [2900, 2900, 2926, 2926, 3655], [3657, 3657, 3683, 3683, 4412], [4414, 4414, 4440, 4440, 5168], [5170, 5170, 5196, 5196, 5927], [5929, 5929, 5955, 5955, 6688], [6690, 6690, 6716, 6716, 7449], [7451, 7451, 7477, 7477, 8212], [8214, 8214, 8240, 8240, 8973], [8975, 8975, 9000, 9000, 9734], [9736, 9736, 9766, 9766, 10350], [10352, 10352, 10381, 10381, 10882], [10884, 10884, 10918, 10918, 11156], [11158, 11158, 11188, 11188, 11813], [11815, 11815, 11843, 11843, 12413], [12415, 12415, 12434, 12434, 13044], [13046, 13046, 13068, 13068, 13546], [13548, 13548, 13571, 13571, 14489], [14491, 14491, 14513, 14513, 14579], [14581, 14581, 14614, 14614, 14879], [14881, 14881, 14905, 14905, 15106], [15108, 15108, 15131, 15131, 15420], [15422, 15422, 15464, 15464, 15659], [15661, 15661, 15718, 15718, 16481]], "test": "valid"}
{"id": "tlBSWt", "name": "Raymarching Wip", "author": "badjano", "description": "My first raymarching test", "tags": ["raymarching", "raymarch"], "likes": 2, "viewed": 191, "published": "Public", "date": "1586847019", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n * Part 5 Challenges:\n * - Change the axis of motion of the cube being intersected with the sphere\n * - Rotate the intersection \n */\n\nconst int MAX_MARCHING_STEPS = 500;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 500.0;\nconst float EPSILON = 0.01;\n\n\nvec3 rotate(vec3 v, vec4 q){\n    vec3 temp = cross(q.xyz, v) + q.w * v;\n\treturn v + 2.0*cross(q.xyz, temp);\n}\n\n\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat intersectSDF(float distA, float distB) {\n    return smin(distA, distB, sin(iTime*5.)*.5+.5);\n}\n\n/**\n * Signed distance function for a cube centered at the origin\n * with width = height = length = 2.0\n */\nfloat cubeSDF(vec3 p) {\n    // If d.x < 0, then -1 < p.x < 1, and same logic applies to p.y, p.z\n    // So if all components of d are negative, then p is inside the unit cube\n    vec3 d = abs(p) - vec3(1.0, 1.0, 1.0);\n    \n    // Assuming p is inside the cube, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    \n    // Assuming p is outside the cube, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\n/**\n * Signed distance function for a sphere centered at the origin with radius 1.0;\n */\nfloat sphereSDF(vec3 p) {\n    return length(p*vec3(1.,1.,1.)) - 1.0;\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {\n    float s = 5.;\n    //s = sin(iTime)*s + s*2.;\n    float inv_s = 1./s;\n    float d = inv_s * 2.5;\n    samplePoint = fract(samplePoint*inv_s + d)*s - d*s;\n    float sphereDist = sphereSDF(samplePoint / 1.2) * 1.2;\n    float cubeDist = cubeSDF(samplePoint + vec3(0.0, sin(iTime), 0.0));\n    return intersectSDF(cubeDist, sphereDist);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(iMouse.x - iResolution.x*.5,\n                          iMouse.y - iResolution.y*.5,\n                          0.0) * 0.1;\n    vec3 light1Intensity = vec3(0.4, 0.4, 1.0);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(1.0, 1.0, 1.0) * 10.0;\n    vec3 light2Intensity = vec3(1.0, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    float t = 3. + iTime*2.*0.1;\n    vec3 eye = normalize(vec3(sin(t), 0.5, -cos(t))*20.)*18.;\n    \n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n        \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = vec3(0.2, 0.2, 0.2);\n    vec3 K_d = vec3(0.7, 0.2, 0.2);\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlBSWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[262, 262, 290, 290, 371], [374, 374, 415, 415, 499], [501, 501, 547, 547, 601], [603, 711, 734, 885, 1322], [1324, 1413, 1438, 1438, 1483], [1485, 1725, 1759, 1759, 2095], [2097, 2518, 2609, 2609, 2915], [2930, 3184, 3249, 3249, 3381], [3383, 3472, 3501, 3501, 3811], [3813, 4305, 4445, 4445, 5035], [5037, 5407, 5492, 5492, 6235], [6237, 6564, 6613, 6648, 6874], [6876, 6876, 6933, 6933, 7839]], "test": "valid"}
{"id": "ts2cDm", "name": "moon over water", "author": "inco", "description": "My 1st glsl generated image/animation. ", "tags": ["2dimage"], "likes": 2, "viewed": 64, "published": "Public", "date": "1586796052", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Band(float t, float start, float end, float blur)\n{\n    float step1 = smoothstep(start-blur, start+blur, t);\n    float step2 = smoothstep(end+blur, end-blur, t);\n    return step1*step2;\n}\n\nfloat Rect(vec2 uv, float left, float right, float bottom, float top, float blur)\n{\n\tfloat band1 = Band(uv.x, left, right, blur);\n    float band2 = Band(uv.y, bottom, top, blur);\n    \n    return band1*band2;\n}\n\nfloat rand(vec2 co){\n      return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat Star(vec2 uv, float x, float y)\n{\n    x *= 2.0;\n    y /= 2.0;\n\tfloat dist = length(vec2(uv.x + x - 0.9, uv.y-y));\n    return smoothstep(0.008, 0.001, dist);    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 skyColor = vec3(0.1);\n    \n    float x = uv.x;\n    \n    float m = abs(cos(iTime+x*18.0)*0.05);\n    \n    float y = uv.y+m;\n    \n\t//waves\n\tfloat wave0 = Rect(vec2(x, uv.y+abs(cos(-0.1+iTime+x*18.0)*0.05)), -1.5, 1.5, -0.0, 0.7, 0.005);\n    float wave1 = Rect(vec2(x, uv.y+abs(cos(0.05+iTime+x*18.0)*0.05)), -1.5, 1.5, -0.13, 0.0, 0.005);\n    float wave2 = Rect(vec2(x, uv.y+abs(cos(-0.10+iTime+x*18.0)*0.05)), -1.5, 1.5, -0.28, -0.13, 0.005);\n    float wave3 = Rect(vec2(x, y), -1.5, 1.5, -0.55, -0.28, 0.005);\n    \n    //sun, but it's actually moon\n    //creating vars to avoid stars later\n    //but in the end they weren't needed\n    vec2 moonPos = vec2(uv.x + 0.3, uv.y - 0.3);\n    float moonRadius = 0.16;\n    float moonBlur = 0.12;\n    float dist = length(moonPos);\n    float moon = smoothstep(moonRadius, moonBlur, dist);\n    \n    //stacking waves into one pixel data\n    vec3 waves = (skyColor*wave0) + (vec3(0.2, 0.5, 0.9)*wave1) + (vec3(0.35, 0.6, 0.8)*wave2) + (vec3(0.56, 0.76, 0.85)*wave3);\n\n    vec3 moonMask = (vec3(0.9, 0.35, 0.1))*moon*5.0;   \n    \n    //scales from left to right\n    vec3 pct = vec3(uv.x+0.37);\n\n    vec3 starMask = vec3(0.0);\n    for(int i=0; i <= 70; i=i+1)\n    {\n        float star1 = Star(uv, rand(vec2(iDate.z, i)), rand(vec2(i, i)));\n        float star2 = Star(uv, rand(vec2(iDate.z, i)), rand(vec2(i, i)));\n    \tstarMask += vec3(rand(vec2(iTime/700000.0, i)))*star1;\n    }\n\n    \n    //black magic happens here\n    \n    //gradient for halfmoon\n    vec3 halfMoon = mix(vec3(0.0), moonMask, pct); //pct\n    \n    \n\t//po odjęciu pomarańczowego księżyca od gwiazd na masce z gwiazdami zostają nam niebieskie gwiazdy\n    starMask -= moonMask;\n    vec3 col = max(waves*0.6,halfMoon);\n    //więc bierzemy inną wartość niż niebieską, która dla białej gwiazdy przyjmuje wartość 1.0\n    col = max(col, starMask.r);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts2cDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 193], [195, 195, 278, 278, 404], [406, 406, 426, 426, 500], [502, 502, 541, 541, 670], [672, 672, 729, 779, 2782]], "test": "valid"}
{"id": "ts2czd", "name": "Trying out some non sin/cos/frac", "author": "samel", "description": "Trying out some non sin/cos/dot noise", "tags": ["noise", "random", "nosin", "nocos", "nodot"], "likes": 1, "viewed": 72, "published": "Public", "date": "1587739781", "time_retrieved": "2021-10-01T00:00:00", "image_code": "int lehmerSeed=0;\n\nvoid srandomLehmer(vec2 uv)\n{\n int a=int(uv.x)<<16;\n int b=int(uv.y);\n lehmerSeed=a^b;\n}\n\nfloat randomLehmer()\n{\n int tmp=0;\n tmp=lehmerSeed*1234567890;\n tmp=(tmp>>16)^tmp;\n tmp=tmp*1234567890;\n return float((tmp>>16)^tmp)/pow(2.,31.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float col=0.;\n    \n    uv+=iTime*.2;\n    vec2 zoomedUv=uv*20.;\n    \n    vec2 uvFloor=floor(zoomedUv);\n    vec2 uvFract=fract(zoomedUv);\n    vec2 inter=smoothstep(0.,1.,uvFract);\n    \n    srandomLehmer(uvFloor+vec2(+0,+0));\n    float x0y0=randomLehmer();\n    \n    srandomLehmer(uvFloor+vec2(+1,+0));\n    float x1y0=randomLehmer();\n    \n    srandomLehmer(uvFloor+vec2(+0,+1));\n    float x0y1=randomLehmer();\n    \n    srandomLehmer(uvFloor+vec2(+1,+1));\n    float x1y1=randomLehmer();\n    \n    float y0=mix(x0y0,x1y0,inter.x);\n    float y1=mix(x0y1,x1y1,inter.x);\n    col=+mix(y0,y1,inter.y);\n\n    // Output to screen\n    fragColor = vec4(col,0.0,0.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts2czd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 48, 48, 107], [109, 109, 131, 131, 256], [259, 259, 316, 366, 1067]], "test": "valid"}
{"id": "ts2yWV", "name": "Rainbow Temple, Ungolfed", "author": "mla", "description": "Ungolfed version of GregRostami's [url]https://www.shadertoy.com/view/3sjcDV[/url], derived from vahidk's [url]https://www.shadertoy.com/view/tdSyDG[/url].\n\nyoshin4004's original: [url]https://twitter.com/yosshin4004/status/1251357672504360966[/url]", "tags": ["raymarching", "tunnel", "ungolf"], "likes": 12, "viewed": 674, "published": "Public API", "date": "1587378205", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Rainbow Temple, Ungolfed. Matthew Arcus, mla, 2020.\n//\n// Ungolfed and rationalized version of GregRostami's Rainbow Temple:\n// https://www.shadertoy.com/view/3sjcDV, which is derived from vahidk's\n// Infinite Tunnel: https://www.shadertoy.com/view/tdSyDG which is derived\n// from yoshin4004's original: https://twitter.com/yosshin4004/status/1251357672504360966\n//\n// <mouse>: look around\n// f: floor\n// l: change light direction\n// v: vary sphere overlap\n// z: move along z axis\n//\n// Logic is mostly the same, have dinked with the lighting a little.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// Rotate vector p by angle t.\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n\nfloat PI = 3.14159;\n\nvec3 transform(vec3 p) {\n  if (iMouse.x > 0.0) {\n    // Full range of rotation across the screen.\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    p.yz = rotate(p.yz,-theta);\n    p.zx = rotate(p.zx,phi);\n  }\n  return p;\n}\n\nconst int CHAR_F = 70;\nconst int CHAR_L = 76;\nconst int CHAR_V = 86;\nconst int CHAR_Z = 90;\n\nbool key(int key) {\n  return texelFetch(iChannel3,ivec2(key,2),0).x != 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  // Orthographic projection - this is the ray direction\n  vec3 d = vec3((2.0*fragCoord-iResolution.xy)/iResolution.y, 1);\n  d = transform(d);\n  vec3 p = vec3(0); // Ray marching origin\n  if (!key(CHAR_Z)) p.z = 0.2*iTime;\n  vec3 q,p0 = p;\n  vec3 lightdir = vec3(1,1,1);\n  if (key(CHAR_L)) lightdir.xz = rotate(lightdir.xz,0.123*iTime);\n  for (int i = 0; i < 120; i++) {\n    float lfactor = 0.5;\n    float overlap = 0.65;\n    if (key(CHAR_V)) overlap += 0.1*sin(0.1*iTime);\n    float floorheight = 0.3;\n    float s = overlap-length(fract(p+0.5)-0.5);\n    if (!key(CHAR_F)) s = min(s, p.y + floorheight);\n    p += lfactor*d*s;\n    if (i == 80) {\n      // We must have hit the surface by now.\n      q = p; // Remember position\n      p -= d*.01; // Back up a little to stop self-shadowing\n      d = lightdir; // Light direction (for shadows)\n    }\n  }\n  ivec3 u = ivec3(q*5e2); // u in [0..255]\n  u = u.yzx^u.zxy;             // Mix up for chequer effect\n  u &= 255;\n  vec3 col = vec3(u)/255.0;\n  col *= 0.25*(length(p-q) + 0.9);\n  col += 0.1*(length(p-p0));\n  fragColor = vec4(col,1);\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts2yWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[725, 756, 786, 786, 831], [854, 854, 878, 878, 1158], [1253, 1253, 1272, 1272, 1330], [1332, 1332, 1384, 1441, 2469]], "test": "error"}
{"id": "ts2yzG", "name": "blob zwy", "author": "asforever123", "description": "My first 3D shader\ntry blob", "tags": ["sdfsample"], "likes": 1, "viewed": 106, "published": "Public", "date": "1587542753", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n//common\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n//ray\n#define TOLERANCE 0.01\n#define MAX_DEPTH 100.\n#define MAX_MARCHING_STEPS 255\n\n#define DIRECTIONAL_LIGHT_NUM 2\n#define POINT_LIGHT_NUM 1\n\nmat3 rotateByEuler(vec3 euler){\n\tfloat x = euler.x, y = euler.y, z = euler.z;\n    float a = cos( x ), b = sin( x );\n\tfloat c = cos( y ), d = sin( y );\n\tfloat e = cos( z ), f = sin( z );\n    float ae = a * e, af = a * f, be = b * e, bf = b * f;\n\treturn  mat3(\n    \tvec3(c * e,af + be * d,bf - ae * d),\n\t\tvec3( - c * f,ae - bf * d,be + af * d),\n        vec3(d,- b * c,a * c)\n    );\n}\n\nmat3 rotateX(float angle){\n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn  mat3(\n    \tvec3(1.,0.,0.),\n\t\tvec3(0.,c,-s),\n        vec3(0.,s,c)\n    );\n}\n\nmat3 rotateY(float angle){\n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn  mat3(\n    \tvec3(c,0.,s),\n\t\tvec3(0.,1.,0.),\n        vec3(-s,0.,c)\n    );\n}\n\nmat3 rotateZ(float angle){\n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn  mat3(\n    \tvec3(c,-s,0.),\n\t\tvec3(s,c,0.),\n        vec3(0.,0.,0.)\n    );\n}\n\nmat3 rotateAxis(vec3 axis,float rad){\n\tfloat c = cos( rad );\n\tfloat s = sin( rad );\n\tfloat t = 1. - c;\n\tfloat x = axis.x, y = axis.y, z = axis.z;\n\tfloat tx = t * x, ty = t * y;\n    \n\treturn  mat3(\n    \tvec3(tx * x + c,tx * y + s * z, tx * z - s * y),\n\t\tvec3(tx * y - s * z,ty * y + c,ty * z + s * x),\n        vec3(tx * z + s * y,ty * z - s * x,t * z * z + c)\n    );\n}\n\nstruct Camera{\n\tvec3 eye;\n};\n\nstruct DirectionalLight{\n\tvec3 diffuse;\n    vec3 specular;\n    vec3 dir;\n    float intensity;\n};\n\nstruct PointLight{\n    vec3 diffuse;\n    vec3 specular;\n    vec3 position;\n\tfloat constant;\n    float linear;\n    float quadratic;\n    float intensity;\n};\n\nstruct Geometry{\n\tvec3 position;\n    vec3 normal;\n};\nstruct Material{\n\tvec3 diffuse;\n    vec3 specular;\n    float shininess;\n};\n\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n};\n\nfloat sphereSDF(vec3 p,float radius){\n\treturn length(p) - radius;\n}\n\nfloat boxSDF(vec3 p,float l,float w,float h){\n    vec3 d = abs(p) - vec3(l,w,h);\n\treturn length(max(d,0.0));\n}\n\nfloat planeSDF(vec3 p,vec3 normal){\n\treturn dot(p,normal);\n}\n//https://www.shadertoy.com/view/Xls3R7\nfloat blob(float d1,float d2,float d3,float d4){\n    float k = 3.;\n\treturn -log(exp(-k*d1)+exp(-k*d2)+exp(-k*d3)+exp(-k*d4))/k;\n}\n\nfloat sceneSDF(vec3 p){\n    float x = 3.0*sin(iTime*2.);\n    float z = 3.0*cos(iTime*2.);\n    vec3 a = vec3(0.,-z-1.,x);\n    vec3 b = vec3(x,z-1.5,0.);\n    vec3 v = vec3(-x,z-1.5,-.5);\n    \n\tfloat sphere = sphereSDF(p + a,2.);\n    float sphere1 = sphereSDF(p + b,2.);\n    float box = boxSDF(p + v,1.,1.,1.);\n    float plane = boxSDF(p + vec3(.0,2.,0.),10.,.2,10.);\n   \treturn blob(sphere,box,sphere1,plane);\n}\n\n//http://www.iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal(vec3 p )\n{\n    const float h = 0.0001;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*sceneSDF( p + k.xyy*h ) + \n                      k.yyx*sceneSDF( p + k.yyx*h ) + \n                      k.yxy*sceneSDF( p + k.yxy*h ) + \n                      k.xxx*sceneSDF( p + k.xxx*h ) );\n}\n\nvec3 ray(vec2 uv,float fovy,float aspect){\n    float z = -1./tan(fovy/2.);\n    return normalize(vec3(uv.x*aspect,uv.y,z));\n}\n\nfloat rayCast(vec3 ro,vec3 rd){\n   float depth = 0.;\n   for(int i=0;i<MAX_MARCHING_STEPS&&depth<MAX_DEPTH;i++){\n      vec3 pos = ro + rd * depth;\n      float distance = sceneSDF(pos);\n      depth+=distance;\n   }\n   return depth;\n}\n\n\nReflectedLight calcReflectedLight(\n    Camera camera,\n    DirectionalLight directionalLights[DIRECTIONAL_LIGHT_NUM],\n\tPointLight pointLights[POINT_LIGHT_NUM],\n    Geometry geometry,\n    Material material\n){\n    vec3 diffuse = vec3(0.);\n    vec3 specular = vec3(0.);\n    \n    vec3 position = geometry.position;\n    vec3 mDiffuse = material.diffuse;\n    vec3 mSpecular = material.specular;\n    float shininess = material.shininess;\n    \n    vec3 N = geometry.normal;\n    vec3 V = camera.eye - position;\n    \n    ReflectedLight reflectedLight;\n    for(int i =0;i<DIRECTIONAL_LIGHT_NUM;++i){\n    \tDirectionalLight directionalLight = directionalLights[i];\n     \n        vec3 dDiffuse = directionalLight.diffuse;\n        vec3 dSpecular = directionalLight.specular;\n        \n        float intensity = directionalLight.intensity;\n        \n        vec3 L = -normalize(directionalLight.dir);\n        vec3 R = reflect(-L,N);\n        vec3 H = normalize(V + L);\n    \n        float dotNL = dot(N,L);\n        float dotNH = dot(N,H);\n        float spec = pow(max(0.,dotNH),shininess);\n        \n        diffuse += dDiffuse*dotNL*mDiffuse*intensity;\n        specular += dSpecular*spec*mSpecular*intensity;\n    }\n   \n    reflectedLight.directDiffuse = diffuse;\n    reflectedLight.directSpecular = specular;\n    return reflectedLight;  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2. * fragCoord/iResolution.xy-1.;\n\n   \t//camera\n    float aspect = iResolution.x/iResolution.y;\n    float fovy = PI/3.;\n    float angleX = PI/4.;\n    float angleY = iMouse.x/100.;\n    mat3 cameraMat = rotateY(angleY) * rotateX(angleX);\n    vec3 ro = cameraMat * vec3(0.,0.,15.);\n    vec3 rd = cameraMat * ray(uv, fovy, aspect);\n    float depth = rayCast(ro,rd);\n    \n\n    //geometry\n    vec3 p = ro + rd * depth;\n    vec3 n = calcNormal(p);\n    Geometry geometry = Geometry(p,n);\n    //material\n    vec3 diffuse = vec3(0.4,0.7,0.9);\n    vec3 specular = vec3(1.);\n    Material material = Material(diffuse,specular,32.);\n    //lights\n    DirectionalLight directionalLight = DirectionalLight(\n        vec3(0.6),\n        vec3(0.4),\n        vec3(0.0,-1.0,0.0),\n        1.\n    );\n    DirectionalLight directionalLight1 = DirectionalLight(\n        vec3(.6,0.2,0.7),\n        vec3(0.4),\n   \t\tvec3(0.0,-0.4,-1.),\n        1.\n    );\n    \n    PointLight pointLight = PointLight(\n     \tvec3(1.),\n        vec3(0.),\n        vec3(-1.,-1.,-1.),\n        1.,\n        0.01,\n        0.00032,\n        1.\n    );\n   \n    \n    DirectionalLight directionalLights[DIRECTIONAL_LIGHT_NUM];\n    PointLight pointLights[POINT_LIGHT_NUM];\n    directionalLights[0] = directionalLight;\n    directionalLights[1] = directionalLight1;\n    pointLights[0] = pointLight;\n    //lights\n    Camera camera = Camera(ro);\n    \n   \n    \n    ReflectedLight reflectedLight = calcReflectedLight(\n        camera,\n        directionalLights,\n        pointLights,\n        geometry,\n        material\n        \n    );\n\n    //result\n    vec3 color = reflectedLight.directDiffuse + reflectedLight.directSpecular;\n        \n    if(depth>=MAX_DEPTH){\n    \tfragColor = vec4(0.,0.,0.,1.);\n        return;\n    }\n        \n    fragColor = vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts2yzG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[213, 213, 244, 244, 594], [596, 596, 622, 622, 762], [764, 764, 790, 790, 930], [932, 932, 958, 958, 1098], [1100, 1100, 1137, 1137, 1467], [1953, 1953, 1990, 1990, 2020], [2022, 2022, 2067, 2067, 2132], [2134, 2134, 2169, 2169, 2194], [2195, 2235, 2283, 2283, 2364], [2366, 2366, 2389, 2389, 2775], [2777, 2844, 2870, 2870, 3151], [3153, 3153, 3195, 3195, 3277], [3279, 3279, 3310, 3310, 3509], [3512, 3512, 3718, 3718, 4830], [4832, 4832, 4889, 4889, 6691]], "test": "valid"}
{"id": "ts2yzw", "name": "shadow mandelbrot", "author": "sanderoneil", "description": "another way to visualize overflow from set", "tags": ["mandelbrot"], "likes": 0, "viewed": 196, "published": "Public API", "date": "1586357575", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy-.5;\n    \n    uv=uv/(iTime*iTime)*100.0;\n    \n    uv+=(iMouse.xy-iResolution.xy/2.0)/100.0;\n    \n    vec3 iro = vec3(uv.xy,0);\n\tfloat sq=0.0;\n    float sq2=0.0;\n    while (iro.z < 1.0){\n        sq=iro.x*iro.x;\n        sq2=iro.y*iro.y;\n        if (sq+sq2>10.0){\n            break;}\n        iro.x=sq-sq2+uv.x;\n        iro.y=2.0*iro.x*iro.y+uv.y;\n        iro.z+=.1;\n    }\n    \n    // Output to screen\n    fragColor = vec4((sq+sq2-10.0)/10.0,(sq+sq2-10.0)/10.0,iro.z,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts2yzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 616]], "test": "valid"}
{"id": "ts2yzz", "name": "Glowing Light Stripes", "author": "SeaiaeS", "description": "The first shader of my learning series. You can change the values. \nI know it is really really basic.", "tags": ["light", "glow", "fragment", "stripe", "winking"], "likes": 4, "viewed": 80, "published": "Public", "date": "1586019713", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float winkingSpeed = 0.74;\n    float winking = abs(sin(time*winkingSpeed))+0.2;\n    \n    float glow = 0.08 * winking; //Brightness.\n    \n    float segmentation = 1408. ; //Change this value to alternate pattern. Higher values act strange.\n    \n    float flowSpeed = 1.; //Alternate vertical flow.\n    \n\tfloat nc = tan(.147 -uv.x * segmentation ) * abs(sin(uv.y*time*flowSpeed)) * sin(uv.y*segmentation) * glow;\n    \n    vec3 col = vec3(nc, nc*.6, nc*.35);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts2yzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 77, 77, 615]], "test": "valid"}
{"id": "tsBcDG", "name": "Hyperbolic octagons II", "author": "sl2c", "description": "Uses anti-aliasing, and travels through a translation.  Variant of [url]https://www.shadertoy.com/view/3d2cz1[/url]", "tags": ["tiling", "hyperbolic", "poincare"], "likes": 7, "viewed": 98, "published": "Public", "date": "1588005829", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Copyright 2020 Google LLC\n// SPDX-License-Identifier: Apache-2.0\n// NOT an official Google project; see Google Open Source guidelines for more info on copyright transfer\n// written by William Cadegan-Schlieper \n#define swap(x,y) {t=x;x=y;y=t;}\n\n\nvec3 color(vec2 z, float ds) {\n    float pi = 3.14159265359;\n    float theta = pi/8.0;\n    // someday I'll explain the cross-ratio magic that got me these numbers\n    float r = 2.0 / (1.0 - sqrt(1.0 - 4.0 * sin(theta) * sin(theta)));\n    float p = - r * cos(theta);\n    bool fl = false;\n    vec3[3] colors;\n    colors[0] = vec3(1.0,0.5,0.0);\n    colors[1] = vec3(0.0,1.0,0.5);\n    colors[2] = vec3(0.5,0.0,1.0);\n    vec3 t; // for temp space\n    for(int i=0;i<100;i++) {\n        if (z.x < 0.0) {\n            z.x = -z.x;\n            colors[2] = 1.0 - colors[2];\n            fl = !fl;\n            continue;\n        }\n        if (dot(z,z) < 1.0) {\n            z /= dot(z,z);\n            ds *= dot(z,z);\n            fl = !fl;\n            swap(colors[0],colors[1]);\n            continue;\n        }\n        z.x -= p;\n        if (dot(z,z) > r*r) {\n            ds *= r * r / dot(z,z);\n            z *= r * r / dot(z,z);\n            fl = !fl;\n            z.x += p;\n            swap(colors[1],colors[2]);\n            continue;\n        }\n        z.x += p;\n        \n        break;\n        \n\n    }\n    vec3 col = colors[0];\n    float f = 1.0;\n    f = min(f, z.x / ds);\n    z.x -= p;\n    f = min(f, (r * r - dot(z,z)) / (ds * 2.0 * r));\n    z.x += p;\n    f = 0.75 + 0.25 * f;\n    if (fl) {\n        f = 1.5 - f;\n    }\n    col *= f;\n    if (dot(z,z) - 1.0 < ds * 2.0) {\n        float t = (dot(z,z) - 1.0) / (ds * 2.0);\n        vec3 col2 = colors[1] * (1.5 - f);\n        col = (1.0 + t) * col + (1.0 - t) * col2;\n        col *= 0.5;\n    }\n    return col * min(1.0,1.0 / ds);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * (fragCoord - iResolution.xy * 0.5)/iResolution.y;\n    float ds = 2.0 / iResolution.y;\n\n    float r2 = dot(uv,uv);\n    if (r2 < 1.0) {\n        uv.y -= 1.0;\n        uv /= dot(uv,uv); ds *= dot(uv,uv);\n        uv.y = -0.5 - uv.y;\n        \n        float t = 0.1 * iTime;\n        float period = 6.0 * 0.6329743192009469;\n        t = mod(t,period) - period * 0.5;\n        uv *= exp(t); ds *= exp(t);\n        \n        uv.x -= 0.43973261203230474;\n        uv /= dot(uv,uv); ds *= dot(uv,uv);\n        uv.x += 1.6782507245215834;\n        \n        fragColor = vec4(color(uv,ds),1.0);\n    } else {\n        fragColor = vec4(0.0,0.0,0.0,1.0);\n    }\n    fragColor = pow(fragColor, vec4(1./2.2));\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsBcDG.jpg", "access": "shaders20k", "license": "apache-2.0", "functions": [[1810, 1810, 1867, 1867, 2571]], "test": "valid"}
{"id": "tsBcRd", "name": "n4uj_GLPlotter", "author": "n4uj", "description": "Just plotting a sine function.", "tags": ["shader", "graph", "plot"], "likes": 1, "viewed": 251, "published": "Public API", "date": "1587155628", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\n\n\nfloat line = 0.1;\n\nfloat smin( float d1, float d2)\n{\n\tfloat k = 0.6521; k = 1.1;\n\tfloat h = clamp( 0.5+0.5*(d2-d1)/k, 0.0, 1.0 );\n\treturn mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat f(vec2 uv)\n{\n\tfloat x = uv.x;\n\tfloat y = uv.y;\n    float f1 = cos((iTime + x)) - y;\n    float f2 = sin(iTime + x)*abs(cos(iTime)) - y;\n    //return smin(f1, f2);\n    return f1;\n}\n\nvec2 df( in vec2 x )\n\n{\n\tvec2 h = vec2( 0.01, 0.001 );\n\treturn vec2( f(x+h.xy) - f(x-h.xy), f(x+h.yx) - f(x-h.yx) )/(2.0*h.x);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 uv = fragCoord/iResolution.xy * vec2(10.0f, 10.0f);\n    uv += vec2(0.0, -4.0);\n\tfloat col = float (abs(f(uv))/length(df(uv)));\n\tcol = abs(f(uv))/sqrt(1.0 + pow(df(uv).x, 2.0));\n\tfragColor = vec4(smoothstep(0.98* line, line, col));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsBcRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[117, 117, 150, 150, 269], [271, 271, 289, 289, 455], [457, 457, 480, 480, 585], [588, 588, 645, 645, 885]], "test": "valid"}
{"id": "tsBcRh", "name": "Black Body Radiation", "author": "SeaiaeS", "description": "Black body radiation for metals. Texture pattern, mass and heating speed are adjustable.", "tags": ["blackbody", "radiation", "black", "micro", "body", "heater", "heating", "microwave"], "likes": 2, "viewed": 55, "published": "Public", "date": "1586108334", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime\n#define PI 3.141592\n\n//grid -> # of sections each direction. Set an even number for symmetry. 0 to inf. 0 is fullscreen.\n//mass -> how hard to heat material\n//power -> power of the heater\n\n\n#define grid 16.\n#define mass 20.\n#define power 4.\n\n\nfloat heat(float s) {return power*cos(s*PI*time*grid)/(mass*s);}\n\nfloat burnerKnob(float c) {return c * iMouse.y/20.;}\n\nfloat microwave(vec2 uv){return uv.x*uv.y*(heat(uv.x/time)*heat(uv.y/time));}\n\nfloat chaos(float c) {return  (-1./heat(1.-c));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float pat = microwave(uv);\n    \n    //pat = burnerKnob(pat); // Change heater power along y-axis\n    //pat = chaos(pat); //EXPERIMENTAL\n    \n    vec3 col = vec3(pat*0.27,pat*0.07,pat*0.05);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsBcRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[262, 262, 283, 283, 326], [328, 328, 355, 355, 380], [382, 382, 407, 407, 459], [461, 461, 483, 483, 509], [511, 511, 568, 568, 836]], "test": "valid"}
{"id": "tsBcWy", "name": "Wind from west", "author": "SGPlague", "description": "To move vertices for wind in 2d", "tags": ["wind"], "likes": 1, "viewed": 64, "published": "Public", "date": "1587250811", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv.x*=iResolution.x/iResolution.y;\n    \n    // THIS USES SCREEN SPACE NOT WORLD SPACE\n  \t\n    \n    float ZOOMOUT = 1.;\n    float SPEED = 1.;\n    \n    uv=ZOOMOUT*uv;\n    \n    float myTime=iTime*0.5+0.1*sin(iTime)*cos(2.2*iTime);\n    //I dont experience time like a mortal\n    \n    myTime=SPEED * myTime;\n    \n    float lowManipulation= mod((2.*3.1415*uv.x*0.2-4.*myTime +sin(myTime)*3.*3.1415*uv.y*0.1+0.3*sin(uv.y) )*0.3,2.*3.1415);\n    \n    float highManipulation= (((sin(lowManipulation)*cos(7.*lowManipulation))+1.)/2.);\n    \n    fragColor = vec4( highManipulation , 0. , highManipulation ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsBcWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 707]], "test": "valid"}
{"id": "tsByDh", "name": "ALTERNATE", "author": "os0450", "description": "dailycodingchallenge. Day 9: ALTERNATE.", "tags": ["dailycodingchallenge"], "likes": 10, "viewed": 81, "published": "Public", "date": "1586529535", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat circle(vec2 p, float r, float w) {\n    return abs(length(p)-r)-w;\n}\n\nfloat half_pi = acos(0.);\n\nvec2 dist(vec2 p, float t) {\n    float d;\n    float w = 0.004;\n\n    vec2 q = p - vec2(-0.75, -0.5);\n    float d1 = min(\n        circle(q, 0.3, w),\n        circle(q, 0.4, w));\n    \n    float a = -(t-half_pi);\n    vec2 q1 = q-0.35*vec2(cos(a), sin(a));\n    float d2 = circle(q1, 0.04, 0.04);\n    d = min(d1, d2);\n\n    vec2 q2 = q - vec2(0., 1.0 + cos(t)*0.4);\n    float d3 = circle(q2, 0.04, 0.04);\n    d = min(d, d3);\n\n    vec2 q3 = q2;\n    float d4 = abs(dot(q3, normalize(q1-q2)*rot(half_pi)));\n    d = min(d, d4);\n\n    float d5 = abs(dot(q, normalize(q-q1)*rot(half_pi)));\n    d = min(d, d5);\n\n    float d6 = circle(q, 0.04, 0.04);\n    d = min(d, d6);\n\n    float s1 = dot(normalize(q1-q2)*rot(half_pi), q2+vec2(-0.005, 0.));\n    float s2 = dot(normalize(q-q1)*rot(half_pi), q+vec2(-0.005, 0.));\n    float s = ((s1 > 0.) && (s2 > 0.)) || ((s1 < 0.) && (s2 < 0.)) ? 1. : -1.;\n\n    if(s > 0.) {\n    \tfloat d7 = abs(sin( q.x*9.+t+half_pi)*0.4 - q.y + 1.0) - w*2.;\n    \td = min(d, d7);\n    } else {\n \t   float d8 = circle(mod((p+vec2(t*0.3, 0.))+0.1, 0.2)-0.1, 0.005, 0.005);\n    \td = min(d, d8);\n    }\n    \n    return vec2(d, s);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy*2.0 - iResolution.xy)/min(iResolution.x, iResolution.y);\n    vec4 col = vec4(0.);\n\n    float l = 0.2;\n\n    vec2 m = dist(p, iTime*3.2);\n    float d = m.x;\n    float r = m.y;\n    float e = 0.1;\n\n    if(r > 0.0) {\n      col = vec4(smoothstep(0.02, 0.0, d)*0.8+0.1);\n    } else {\n      col = vec4(smoothstep(0.0, 0.02, d)*0.8+0.1);\n    }\n\n    fragColor = vec4(col.xyz, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsByDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 85], [87, 87, 127, 127, 160], [189, 189, 217, 217, 1318], [1320, 1320, 1377, 1377, 1777]], "test": "valid"}
{"id": "tsByR1", "name": "just playing around", "author": "scry", "description": "haha yes", "tags": ["2d"], "likes": 2, "viewed": 230, "published": "Public API", "date": "1586080703", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{//from https://iquilezles.org/www/articles/palettes/palettes.htm\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 tv = uv;\n    uv = -1. + 2. * uv;\n    //vec2 tv = inData.v_texcoord;\n    vec3 col = vec3(0.);\n    float time = iTime;\n    //float stime = sin(time);\n    //float ptime = -4.2+time;\n    time += 90.;\n    time = abs(mod(time*1.,180.)-90.);\n    //uv.x += time*0.1;\n  \t\n    //uv = tv;\n    //uv = mix(uv,tv,0.99);\n    \n    //uv.y += sin(uv.x*2.);\n    //uv.y += abs(fract(uv.x*4.)-0.5);\n    float us = 0.1*sin(time*0.04);\n    float tc = clamp(iTime,60.5,iTime+1.)-60.5;\n    float tc1 = clamp(iTime,24.,iTime+1.)-24.;\n    uv.x *= tc1*0.05;\n    //uv *= 1.+(100./(iTime+10.));\n    //uv.y += time;\n    uv.y -= time*0.05;\n    for (float i=0.;i<12.;i++) {\n        uv.y += sin(uv.x*i)*us;\n        uv.x += time*0.002*sin(time*0.01);\n        uv.y += abs(fract(uv.x*4.*i)-0.5)*us;\n    }\n    //uv.y += time*10.;\n    \n    //uv.y *= sin(time*10.)*.5+0.5;\n    uv = mix((tv*sin((iTime+2.2)*3.14159*(0.5*(1./(time+1.))))),uv,0.1);\n    //uv *= 0.1;\n    //time = abs(mod(time,74.)-74.);\n    uv *= vec2(sin((uv.y+uv.x)*1.));\n    col += uv.y;\n    col.r += time*0.01;\n    time -= 4.2;\n    //time *= 0.9;\n    //col = abs(col);\n    //col.r = col.r*col.r*-1.;\n    col = palette(col.r*((time-tc*0.5)),vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,0.7,0.4),vec3(0.,0.15,.2));\n    col *= vec3(0.6,0.6,1.);\n    //col.rg = fract(uv*2.);\n    fragColor = vec4(col,1.);\n}", "image_inputs": [{"id": "XtB3Dh", "previewfilepath": "https://soundcloud.com/georgeclanton/bleed", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/georgeclanton/bleed", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsByR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 72, 136, 179], [181, 181, 238, 238, 1620]], "test": "valid"}
{"id": "tsByRd", "name": "n4uj_raymarcher", "author": "n4uj", "description": "It was about time I created my very own raymarcher.", "tags": ["ray", "sphere", "raymarcher", "march"], "likes": 0, "viewed": 211, "published": "Public API", "date": "1587152834", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define ACCURACY 0.001\n#define MAX_DIST 100.0\n\n\nfloat GetDist(vec3 p)\n{\n\tvec4 s = vec4(0, 1, 6, 1); //(posx, posy, poz, radius)\n\tfloat sphereDist =  length(p - s.xyz) - s.w;\n\t\n\tfloat planeDist = p.y; //Plane formed by world x and world z\n\tfloat d = min(sphereDist, planeDist);\n\t\n\treturn d;\n}\n\nvec3 GetNormal(vec3 p)\n{\n\tfloat d = GetDist(p);\n\tvec2 e = vec2(.01, 0);\n\t\n\tvec3 n = d - vec3(\tGetDist(p-e.xyy),\n\t\t\t\t\t\tGetDist(p-e.yxy),\n\t\t\t\t\t\tGetDist(p-e.yyx)\n\t\t\t\t\t );\n\t\n\treturn normalize(n);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd)\n{\n\tfloat traveled = 0.;\n\n\tfor (int i=0; i<MAX_STEPS; i++)\n\t{\n\t\tvec3 p = ro + rd*traveled;\n\t\tfloat dist = GetDist(p);\n\t\ttraveled += dist;\n\t\tif(traveled > MAX_DIST || dist < ACCURACY) break;\n\t}\n\n\treturn traveled;\n}\n\nfloat GetLight(vec3 p)\n{\n\n\tvec3 lightDir = normalize(vec3 (sin(iTime), 1.0 , cos(iTime)));\n\tvec3 normal = GetNormal(p);\n\tfloat diffuse = clamp(dot(lightDir, normal), 0.0, 1.0);\n\n\tfloat d = rayMarch(p + normal * ACCURACY * 2.0, lightDir);\t//If we didn't add normal * ACCURACY * 2.0, the whole plane will be in shade,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//since the rayMarch will return the min dist between dSphere and dPlane, that's why we offset it.\n\tif (d < length(lightDir)) diffuse *= .1;\n\n\treturn diffuse;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n\t\n\tfloat fov = 1.0;\n\tvec3 ro = vec3(0.0, 1.0, 0.0);\n\tvec3 rd = normalize(vec3(uv.x, uv.y, fov));\n\n\tfloat d = rayMarch(ro, rd);\n\tvec3 p = ro + rd * d;\n\t\n\tvec3 col = vec3(uv.x, uv.y, 0.0);\n\tcol = vec3(p/10.0);\n\t// Output to screen\n\t//fragColor = vec4(col,1.0);\n\tfragColor = vec4(GetLight(p));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsByRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 93, 93, 313], [315, 315, 339, 339, 508], [510, 510, 544, 544, 755], [757, 757, 781, 781, 1249], [1251, 1251, 1308, 1308, 1662]], "test": "valid"}
{"id": "tsByRh", "name": "Iterative Bouncing - Spheres", "author": "amhall", "description": "Iteratively bouncing rays in ray marching rendered on a scene of spheres. See TODOs to reduce anti-aliasing and bounces to speed up rendering.", "tags": ["raymarching", "spheres", "bouncing"], "likes": 7, "viewed": 90, "published": "Public", "date": "1586079662", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Ray marching limits\nconst float epsilon = 0.01;\nconst float maxDistance = 30.0; // This is per bounce rather than total\nconst int maxIterations = 100;\n\n// Supersample 2x2 by default - TODO change ssDimension to 1 to speed up rendering\nconst int ssDimension = 2;\nconst int samplesPerPixel = ssDimension * ssDimension;\nconst float sampleWeight = 1.0 / float(samplesPerPixel);\nconst float ssIncrement = 1.0 / float(ssDimension);\nconst float ssOffset = ssIncrement / 2.0 - 0.5;\n\n// Camera/Light\nvec3 cameraPos; // Set in mainImage(...)\nvec3 lightPos; \nconst vec3 lightIntensity = vec3(1200.0);\n\n// Light constants\nconst float kAmbient = 0.15;\nconst float kDiffuse = 1.0;\nconst float kSpecular = 1.0;\nconst float specularExponent = 8.0;\n\n// Bounce\nconst int maxBounces = 3; // TODO change the number of bounces calculated\nconst float bounceWeight = 0.55; // Percentage of color that the new bounce will occupy\n\n// Sphere at (0, 0, 0), r = 0.85\nconst vec3 spherePos = vec3(0.0, 0.0, 0.0);\nconst float sphereRadius = 1.45;\nconst float sphereCycle = 4.0; // Dimensions of repeating box\nconst vec3 sphereOffset = vec3(sphereCycle/2.0, sphereCycle/2.0, sphereCycle/2.0); // Offset from center to corner of repeating box\nconst vec3 sphereColor = vec3(0.1, 0.6, 1.0);\n\nconst vec3 fogColor = vec3(0.7, 0.8, 1.0);\n\n// (Repeating) sphere signed distance function\nfloat sphereSDF(vec3 point)\n{\n\t// Calculate point within repeating box\n\tpoint += sphereOffset;\n\tpoint = mod(point, sphereCycle);\n\tpoint -= sphereOffset;\n\treturn length(spherePos - point) - sphereRadius;\n}\n\n// Minimum distance to scene - currently just using spheres\nfloat minDistance(vec3 point) {\n \treturn sphereSDF(point);   \n}\n\n// Approximates the normal at an intersection by calculating the gradient\nvec3 estimateNormal(vec3 point) {\n\treturn normalize(vec3(\n        minDistance(vec3(point.x + epsilon, point.y, point.z)) - minDistance(vec3(point.x - epsilon, point.y, point.z)),\n        minDistance(vec3(point.x, point.y + epsilon, point.z)) - minDistance(vec3(point.x, point.y - epsilon, point.z)),\n        minDistance(vec3(point.x, point.y, point.z  + epsilon)) - minDistance(vec3(point.x, point.y, point.z - epsilon))\n    ));\n}\n\n// Linear interpolate a vec3 based on (clamped) decimal\n// Lower weight shifts to a, higher weight shifts to b\nvec3 lerp(vec3 a, vec3 b, float weight) {\n\tweight = clamp(weight, 0.0, 1.0);\n\treturn (1.0 - weight) * a + weight * b;\n}\n\n// Returns the direction of a ray bounce based on the incident ray and surface normal\n// Ray direction and normal should already be normalized by other parts of the code so they are\n// assumed to be normal\nvec3 getBounceDirection(vec3 incidentRay, vec3 normal) {\n    // This calculation should result in a unit vector, so no need to normalize\n \treturn incidentRay - 2.0 * normal * dot(incidentRay, normal);\n}\n\n// Returns the shaded color based on the original surface color\n// Only does ambient and diffuse shading\nvec3 shadePoint(vec3 point, vec3 normal, vec3 color) {\n\tvec3 result = vec3(0.0, 0.0, 0.0);\n\t\n\t// Ambient\n\tresult += color * kAmbient;\n\t\n\tvec3 toLight = lightPos - point;  \n\tvec3 falloff = lightIntensity / dot(toLight, toLight);\n    toLight = normalize(toLight);\n    \n    vec3 toCamera = normalize(cameraPos - point);\n    vec3 viewAngleBisector = normalize(toLight + toCamera);\n\t\n    // Diffuse\n\tresult += kDiffuse * color * falloff * max(0.0, dot(normal, toLight));\n\tresult += kSpecular * falloff * pow(max(0.0, dot(normal, viewAngleBisector)), specularExponent);\n    \n\treturn result;\n}\n\n// Returns the color of casting a ray from rayOrigin in rayDirection\n// Normalizes ray direction\nvec3 castRay(vec3 rayOrigin, vec3 rayDirection)\n{\n\tvec3 color = fogColor;\n\t\n\tvec3 testPoint = rayOrigin; // Point to test distance function at\n\trayDirection = normalize(rayDirection);\n    \n    // Result colors and distances for each cast\n    vec3[maxBounces + 1] results;\n    float[maxBounces + 1] distances;\n    \n    // The index of current cast\n    int castIndex;\n    int lastCastIndex;\n    \n    for (castIndex = 0; castIndex <= maxBounces; castIndex++)\n    {\n        lastCastIndex = castIndex;\n\t\tbool hit = false; // Flag to test if this iteration hit\n        \n        // The result color of this cast\n        vec3 resultColor = fogColor;\n        \n        float tCurrent = 0.0; // Scalar of rayDirection from testPoint (i.e. t for current iteration)\n    \tfloat tTotal = 0.0; // Scalar of rayDirection from rayOrigin (i.e. total t)\n        \n        for (int i = 0; i < maxIterations && tTotal < maxDistance; i++)\n        {\n            tCurrent = minDistance(testPoint);\n            if(tCurrent < epsilon) // HIT\n            { \n                hit = true;\n                \n                vec3 hitNormal = estimateNormal(testPoint);\n\n                resultColor = shadePoint(testPoint, hitNormal, sphereColor); // shade result\n                \n                // Calculate new ray direction\n                rayDirection = getBounceDirection(rayDirection, hitNormal);\n\n                // March ray slightly more than the epsilon away from the hit point\n                testPoint = testPoint + rayDirection * epsilon * 1.1;            \n\n                break;\n            }\n            testPoint += tCurrent * rayDirection; // March ray\n            tTotal += tCurrent;\n        }\n        // Store color and distance results\n        results[castIndex] = resultColor;\n        distances[castIndex] = tTotal;\n\n        // Stop recursing if we don't hit anything\n        if(!hit) {\n            break;\n        }\n    }\n    \n    // Go backwards to calculate bounce colors with fog fades\n    for(int i = lastCastIndex; i >= 0; i--)\n    {\n        float fogWeight = distances[i] / maxDistance;\n        \n        // Blend hit color with fog if we are at last cast,\n        // otherwise do bounce blend then fog blend\n        if(i == lastCastIndex) {\n         \tcolor = lerp(results[i], fogColor, fogWeight);\n        }\n        else {\n            vec3 colorWithBounce = lerp(results[i], color, bounceWeight);\n            color = lerp(colorWithBounce, fogColor, fogWeight);\n        }\n    }\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // CAMERA AND LIGHTS\n\tfloat zOffset = 0.9*iTime; // Move camera and lights backward over time\n\t\n\t// Move camera and light backward\n\tcameraPos = vec3(sphereOffset.xy, zOffset);\n\tlightPos = vec3(22.0, 22.0, zOffset + 22.0);\n\n    // Assume camera is always upright and pointed in -z direction\n\t\n\t// Field of view in shortest axis\n\tfloat fov = 60.0;\n    float scale = tan(radians(fov/2.0));\n    float limit = min(iResolution.x, iResolution.y); // Limiting dimension for FOV\n    \n    // Initialize sample coord and color for supersampling\n    vec2 sampleCoord = fragCoord + ssOffset;\n    vec3 color = vec3(0.0);\n    \n    for(int j = 0; j < ssDimension; j++) {\n        for(int i = 0; i < ssDimension; i++)\n        {\n            // Normaize pixel coordinate such that y is in [-1, 1]\n            vec2 rayXY = (2.0 * sampleCoord - iResolution.xy) / limit;\n\n            // Scale coordinate based on camera FOV, then create ray pointing at -Z\n            vec3 rayDirection = vec3(rayXY *= scale, -1.0);\n            \n            color += sampleWeight * castRay(cameraPos, rayDirection);\n            sampleCoord.x += ssIncrement;\n        }\n        // Reset x, increment y\n        sampleCoord.x = fragCoord.x + ssOffset;\n        sampleCoord.y += ssIncrement;\n    }\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsByRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1304, 1351, 1380, 1421, 1555], [1557, 1617, 1648, 1648, 1680], [1682, 1756, 1789, 1789, 2186], [2188, 2299, 2340, 2340, 2418], [2420, 2626, 2682, 2762, 2828], [2830, 2935, 2989, 2989, 3521], [6108, 6108, 6165, 6190, 7454]], "test": "valid"}
{"id": "tsByRt", "name": "pierwszy shader", "author": "TosterMocy", "description": "my first szader", "tags": ["moon"], "likes": 2, "viewed": 54, "published": "Public", "date": "1587138782", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv= (fragCoord*2.0 -iResolution.xy) / iResolution.y  ;\n    \n    vec4 backColor = vec4(0.2,0.0,0.2,1.0);\n    \n    \n    vec2 circleCenter = vec2(0.0,0.0);\n    \n    circleCenter = circleCenter + vec2(0.8,0.5);\n    \n    float radius = 0.25;\n    \n    float dist = distance(circleCenter,uv);\n    \n    float circle = smoothstep(dist,dist+0.01,radius);\n    \n    \n    vec4 outColor = vec4(0.0);\n    \n    float bloomDist = dist -0.2;\n    float bloom = clamp((1.0 - bloomDist),0.0,1.0)/3.0;\n    vec4 bloomColor = vec4(1.0) + bloom;\n    \n    float sinus1 = sin(uv.x*1.1 +iTime*0.2) * 0.1 - 0.2;\n    float land1 = smoothstep(sinus1,sinus1+0.01 ,uv.y);\n    vec4 landColor1 = vec4(0.0, 0.4, 0.3, 1.0);\n    \n    float sinus2 = sin(uv.x*2.0 +iTime*0.95) * 0.2 - 0.45;\n    float land2 = smoothstep(sinus2,sinus2+0.01, uv.y);\n    vec4 landColor2 = vec4(0.0, 0.5, 0.3, 1.0);\n    \n    float sinus3 = sin(uv.x*5.0 +iTime*5.0) * 0.15 - 0.7;\n    float land3 = smoothstep(sinus3,sinus3+0.01, uv.y);\n    vec4 landColor3 = vec4(0.0, 0.55, 0.25, 1.0);\n    \n    \n    \n    \n   \n    \n    \n    outColor = mix(outColor, backColor, 1.0);\n    outColor = mix(outColor, landColor1, 1.0 - land1);\n    outColor = mix(outColor, landColor2, 1.0 - land2);\n    outColor = mix(outColor, landColor3, 1.0 - land3);\n    outColor = mix(outColor, bloomColor,bloom*1.5);\n    outColor = mix(outColor,vec4(1.0), circle);\n    \n     \n    \n    \n    fragColor = vec4(outColor );\n    \n  \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsByRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1499]], "test": "valid"}
{"id": "tsfBDr", "name": "sgasket", "author": "blepfo", "description": "Testing a function for mapping plane rectangles to the biunit square", "tags": ["ifs", "sierpinski"], "likes": 2, "viewed": 68, "published": "Public", "date": "1588054935", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI (3.141)\n#define MAX_ITERATIONS  (128)\n\n// Translate\nvec2 translate(vec2 uv, vec2 t) {\n    return uv - t;\n}\n\n// 2d rotation matrix\nmat2 rotate2d(float theta) {\n    return mat2(cos(theta), -sin(theta),\n                sin(theta), cos(theta));\n}\n\n// Rectangle centered at (0, 0)\nfloat rectSdf(vec2 uv, vec2 halfSize) {\n    vec2 edgeDist = abs(uv) - halfSize;\n    float inDist = min(max(edgeDist.x, edgeDist.y), 0.);\n    float outDist = length(max(edgeDist, 0.));\n    return inDist + outDist;\n}\n\n// 1. if x in [a, b], else 0.\nfloat inInterval(float x, float a, float b) {\n    return step(a, x) - step(b, x);\n}\n\n// 1 if p in box centered at c, else 0.\nfloat inBox(vec2 p, vec2 c, vec2 halfSize) {\n    float xInBox = inInterval(p.x, c.x - halfSize.x, c.x + halfSize.x);\n    float yInBox = inInterval(p.y, c.y - halfSize.y, c.y + halfSize.y);\n    return xInBox * yInBox;\n}\n\nfloat AND(float a, float b) {\n    return a*b;\n}\n\nfloat NOT(float a) {\n    return 1. - a;\n}\n\n// Remap a square centered at c with given scale to the unit square\n// Useful for creating scaled replicas around the plane\nvec2 mapToUnitSquare(vec2 uv, vec2 c, vec2 scale) {\n    // Rescale so entire replication square maps to biunit square\n    vec2 scaleUv = uv.xy / scale.xy;\n    // Remap if in target square, but preserve biunit square\n    float inRemapBox = inBox(\n        scaleUv,\n        c,\n        vec2(1.)\n    );\n    float inUnitSquare = inBox(\n    \tuv,\n        vec2(0.), \n        vec2(1.)\n    );\n    float shouldRemap = AND(inRemapBox, NOT(inUnitSquare));\n    return\n        // If should remap, move back to origin\n        (shouldRemap * translate(scaleUv, c))\n        // Else return original coordinate for points outside biunit square\n        + (NOT(shouldRemap) * uv);\n}\n\n// Single Sierpinski IFS iteration\n// Scale space by 0.5, create 3 copies in triangle\nvec2 sierpinski1(vec2 uv) {\n    vec2 scaledCoords = (2.*uv) + vec2(0., -1.);\n    vec2 withIdentifiedBl = mapToUnitSquare(\n        scaledCoords,\n        vec2(-1, -2),\n        vec2(1.)\n    );\n    vec2 withIdentifiedBr = mapToUnitSquare(\n        withIdentifiedBl,\n        vec2(1, -2),\n        vec2(1.)\n    );\n    return withIdentifiedBr;\n}\n\n// N iterations of Sierpinski IFS\nvec2 sierpinskiCoords(vec2 uv, int iterations) {\n    for(int i = 0; i < MAX_ITERATIONS; i++) {\n        if (i >= iterations) { break; }\n        uv = sierpinski1(uv);\n    }\n    return uv;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    // Center at (0, 0) \n    uv = translate(uv, vec2(.5));\n    // Normalize dimensions\n    uv.x *= iResolution.x/iResolution.y;\n    // Rescale to unit square\n    uv = 2.*uv;\n    \n    float time = iTime * 1.5;\n    time = mod(time, PI*2.);\n    // Remap to [-globalScale -globalScale] x [globalScale, globalScale]\n    float globalScale = time;\n    vec2 scaleLayer = uv * globalScale;\n    scaleLayer *= rotate2d(time);\n    scaleLayer = fract(scaleLayer);\n    \n    scaleLayer = translate(scaleLayer, vec2(0.5,1.));\n    \n    // Mirror [0, 0] x [1, 1] in tiles acrros scaleLayer\n    vec2 tileLayer = fract(scaleLayer);\n   \n    vec2 sCoords = sierpinskiCoords(scaleLayer, 7);\n    float unitSquare = rectSdf(sCoords, vec2(1.));\n    float shape = step(0., unitSquare);\n\n    vec3 color = vec3(0.026,0.027,0.200);\n\tcolor = mix(color, vec3(0.374,0.541,0.990), (1.-shape));\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsfBDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 63, 96, 96, 117], [119, 141, 169, 169, 253], [255, 287, 326, 326, 501], [503, 533, 578, 578, 616], [618, 658, 702, 702, 876], [878, 878, 907, 907, 925], [927, 927, 947, 947, 968], [970, 1094, 1145, 1211, 1753], [1755, 1841, 1868, 1868, 2177], [2179, 2213, 2261, 2261, 2400], [2404, 2404, 2461, 2461, 3404]], "test": "valid"}
{"id": "tsfBWH", "name": "rotation z", "author": "carlchen", "description": "Based on this shader:\nhttps://www.shadertoy.com/view/XlsGWf\n\nrotate the texture around it's center - keep  aspect ratio", "tags": ["rotation"], "likes": 1, "viewed": 94, "published": "Public", "date": "1588132209", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    //Angle you want to rotate the texture to  \n    float rot = radians(iTime * 45.0);  \n    mat2 m = mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n    \n    vec2 rCoord = (fragCoord.xy - iResolution.xy/vec2(2.0));\n    rCoord = (m *rCoord + iResolution.xy/vec2(2.0));\n    vec2 uv = rCoord.xy / iResolution.xy;\n    \n    if(uv.x>0.0 && uv.y>0.0 && uv.x<1.0 && uv.y<1.0)\n    \tfragColor = texture(iChannel0, uv);\n    else\n        fragColor = vec4(1.0,1.0,1.0,1.0);\n}", "image_inputs": [{"id": "Xdf3Rn", "previewfilepath": "/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsfBWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 106, 521]], "test": "error"}
{"id": "tsfBWn", "name": "Land of Commodore", "author": "friol", "description": "Balls are not touching.", "tags": ["c64", "commodore", "64", "cbm"], "likes": 14, "viewed": 359, "published": "Public API", "date": "1588109412", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//\n// friol 2o2o\n// crt effect from https://www.shadertoy.com/view/Ms23DR\n// sdf functions and fake AO by iq\n// music Clutter by Induktiv\n// 02.05.2020: used proper normal for reflections\n// 06.05.2020: optimized compilation times a bit\n//\n\nconst int iterationAmount=256;\nconst int numBalls=16;\nvec4 ballsPositions[numBalls];\n\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nvec3 rotx(in vec3 p, float a) \n{\n\treturn vec3(p.x,\n                cos(a) * p.y + sin(a) * p.z,\n                cos(a) * p.z - sin(a) * p.y);\n}\n\nvec3 roty(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.z,\n                p.y,\n                cos(a) * p.z - sin(a) * p.x);\n}\n\nvec3 rotz(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.y,\n                cos(a) * p.y - sin(a) * p.x,\n                p.z);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCappedCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n  vec3  ba = b - a;\n  vec3  pa = p - a;\n  float baba = dot(ba,ba);\n  float paba = dot(pa,ba);\n  float x = length(pa*baba-ba*paba) - r*baba;\n  float y = abs(paba-baba*0.5)-baba*0.5;\n  float x2 = x*x;\n  float y2 = y*y*baba;\n  float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n  return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nvec2 SDF(vec3 r)\n{\n    vec3 rOrig=r;\n    vec3 rDist=rOrig;\n    float mat=0.0;\n    float t=0.0;\n    \n    float logoDepth=.5;\n    float bendAmt=.2;\n\n    //r=roty(r,r.y*sin(iTime)*bendAmt);\n    r=rotx(r,3.141592/2.0);\n    //float cylouter=sdCappedCylinder(r,vec3(0.0,0.0,0.0),vec3(0.0,.6,0.0),1.0);\n    //float cylinner=sdCappedCylinder(r,vec3(0.0,-2.0,0.0),vec3(0.0,1.7,0.0),0.58);\n\n    float cylouter=sdRoundedCylinder(r,0.50,0.05,0.3);\n    float cylinner=sdCappedCylinder(r,vec3(0.0,-2.0,0.0),vec3(0.0,logoDepth,0.0),0.58);\n    \n    t=opSubtraction(cylinner,cylouter);\n    \n    //vec3 rcb=roty(rOrig,rOrig.y*sin(iTime)*bendAmt);\n    vec3 rcb=rOrig;\n    float cuttingBox=sdBox(rcb-vec3(0.75,0.0,0.0),vec3(0.5,1.0,logoDepth));\n\tt=opSubtraction(cuttingBox,t);                           \n\n    //vec3 r2=roty(rOrig,rOrig.y*sin(iTime)*bendAmt);\n    vec3 r2=rotx(rOrig,3.141592);\n    float upperVent=sdRoundBox(r2-vec3(.58,0.25,0.0),vec3(0.3,0.16,.3),0.03);\n    t=min(t,upperVent);\n    float lowerVent=sdRoundBox(r2-vec3(.58,-0.25,0.0),vec3(0.3,0.16,.3),0.03);\n    t=min(t,lowerVent);\n\n    //vec3 r3=roty(rOrig,rOrig.y*sin(iTime)*bendAmt);\n    vec3 r3=rotz(rOrig,3.141592/4.01);\n    float minusCube=sdBox(r3-vec3(0.8,-0.8,0.0),vec3(.45,.45,.5));\n    \n    t=opSubtraction(minusCube,t);\n    float cbmLogo=t;\n\n    float floorPlane=sdPlane(rDist-vec3(0.0,-0.1*sin(rDist.x)*2.0*cos(rDist.z),0.0),\n                             vec4(0.0,1.0,0.0,1.0));\n    t=min(floorPlane,t);\n\n    float teeMin=100.0;\n    for (int i=0;i<numBalls;i++)\n    {\n        float amigaBall=sdSphere(rOrig-vec3(2.0+ballsPositions[i].x,\n                                            -0.7+abs(sin(iTime+ballsPositions[i].w)),\n                                            ballsPositions[i].z),\n                                 \t\t\t0.4+0.2*ballsPositions[i].w);\n        t=min(amigaBall,t);\n        teeMin=min(t,teeMin);\n    }\n    \n    \n    //\n    \n    if (t==cbmLogo) mat=0.0;\n    else if (t==floorPlane) mat=1.0;\n    else if (t==teeMin) mat=2.0;\n    if (t==upperVent) mat=3.0;\n    if (t==lowerVent) mat=4.0;\n    \n    return vec2(t,mat);   \n}\n\nvec3 calcNormal(vec3 pos)\n{\n\tvec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        // iOS fix\n        //vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        vec3 e = 0.5773*(2.0*vec3(( mod(float((i+3)/2),2.0) ),(mod(float(i/2),2.0)),(mod(float(i),2.0)))-1.0);\n        n += e*SDF(pos+0.0005*e)[0];\n    }\n    return normalize(n);\n}\n\nvec2 castRay(vec3 rayOrigin, vec3 rayDir)\n{\n    float t = 0.0;\n     \n    for (int i = 0; i < iterationAmount; i++)\n    {\n        vec2 res = SDF(rayOrigin + rayDir * t);\n        if (res[0] < (0.0001*t))\n        {\n            return vec2(t,res[1]);\n        }\n        t += res[0];\n    }\n     \n    return vec2(-1.0,-1.0);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = SDF( aopos )[0];\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\nvec3 Sky( vec3 ray )\n{\n\treturn mix( vec3(.8), vec3(0), exp2(-(1.0/max(ray.y,.01))*vec3(.4,.6,1.0)) );\n}\n\nfloat hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\nvec3 fog(vec3 c, float dist, vec3 fxcol)\n{\n    const float FOG_DENSITY = 0.06;\n    vec3 FOG_COLOR = fxcol.xyz;\n    \n    float fogAmount = 1.0 - exp(-dist * FOG_DENSITY);\n        \n    return mix(c, FOG_COLOR, fogAmount);\n}\n\nvec4 bounceRender(vec3 rayOrigin, vec3 rayDir, vec2 uv)\n{\n    vec3 col=vec3(.52);\n    vec3 L=normalize(vec3(1.0,0.2,-2.0));\n\n    vec2 rayHit = castRay(rayOrigin, rayDir);\n    float t=rayHit[0];\n\n    if (t>0.0)\n    {\n    \tvec3 pHit=rayOrigin + rayDir * t;\n        float mat=rayHit[1];\n        vec3 N=calcNormal(rayOrigin + rayDir * t);\n        float NoL = max(dot(N, L), 0.0);\n      \n\t\tif (mat==0.0)\n        {\n            col=vec3(NoL)*0.75;\n            col+=vec3(.15,.15,.15);\n        }        \n        else if (mat==1.0)\n        {\n            float occ = calcAO( pHit, vec3(0.0,1.0,0.0) );\n            float cdist=pow(distance(pHit,rayOrigin),1.202);\n            col=vec3(0.5)*occ;\n            \n            float tee = -rayOrigin.y / rayDir.y;\n\n            vec2 P = rayOrigin.xz + t * rayDir.xz;\n            vec2 Q = floor(P);\n            P = mod(P, 1.0);\n\n            const float gridLineWidth = 0.1;\n\n            float res = clamp(2048.0 / iResolution.y, 1.0, 3.0);\n            P = 1.0 - abs(P - 0.5) * 2.0;\n            float d = clamp(min(P.x, P.y) / (gridLineWidth * clamp(tee + res * 2.0, 1.0, 2.0)) + 0.5, 0.0, 1.0);\n\n            float shade = mix(hash(120.0 + Q * 0.1) * 0.4, 0.3, min(tee * tee * 0.001, 1.0)) + 0.6;\n            vec3 colFloor= vec3(pow(d, \n                           clamp(150.0 / (pow(max(tee - 2.0, 0.1), res) + 1.0), 0.1, 31.0)\n                      )) * shade + 0.1;            \n            colFloor*=vec3(0.51,0.12,0.23);\n            col=mix(colFloor,col,0.5);\n            col=fog(col,pow(cdist,.7642),Sky(rayDir));\n        }\n        else if (mat==2.0)\n        {\n            vec3 q=N;\n            vec2 matuv = vec2( atan(N.x,N.z), acos(N.y ) );\n            vec2 qp = floor(matuv*2.51);\n            float intensity=mod( qp.x+qp.y, 2.0 );\n            if (intensity==1.0) col=vec3(1.0,0.0,0.0);\n            else col=vec3(1.0);\n            //float NoL = max(dot(N, L), 0.2);\n            col*=NoL;\n\n            float cdist=pow(distance(pHit,rayOrigin),1.202);\n            col=fog(col,pow(cdist,.7642),Sky(rayDir));\n        }\n        else if ((mat==3.0)||(mat==4.0))\n        {\n            col=vec3(NoL)*0.75;\n            if (mat==4.0) col+=vec3(231.0/256.0,12.0/256.0,52.0/256.0);\n            else col+=vec3(0.0,112.0/256.0,232.0/256.0);\n            float cdist=pow(distance(pHit,rayOrigin),1.202);\n            col=fog(col,pow(cdist,.7642),Sky(rayDir));\n            col/=4.0;\n        }\n    }\n    else\n    {\n        vec3 sk=Sky(rayDir);\n        col=vec3(clamp(sk.x,0.0,1.0),clamp(sk.y,0.0,1.0),clamp(sk.z,0.0,1.0));\n        //col=vec3(1.0,0.0,0.0);\n    }\n\n    //col=pow(col,vec3(0.58));\n    return vec4(col,1.0);\n}\n\n\nvec4 render(vec3 rayOrigin, vec3 rayDir, vec2 uv)\n{\n    vec3 col=vec3(0.);\n    vec3 L=normalize(vec3(4.0,0.2,-2.0));\n\n    vec2 rayHit = castRay(rayOrigin, rayDir);\n    float t=rayHit[0];\n    vec3 N=calcNormal(rayOrigin + rayDir * t);\n    float NoL = max(dot(N, L), 0.0);\n\n    if (t>0.0)\n    {\n    \tvec3 pHit=rayOrigin + rayDir * t;\n        float mat=rayHit[1];\n      \n        if (mat==0.0) // c= logo\n        {\n            col=vec3(NoL)*0.75;\n            col+=vec3(.25,.25,.25);\n            vec3 refDir = reflect(rayDir,N);\n            vec4 colReflect=bounceRender(pHit,refDir,uv);\n            col=mix(col,colReflect.xyz,0.6);\n\n            float cdist=pow(distance(pHit,rayOrigin),1.202);\n            col=fog(col,pow(cdist,.7642),Sky(rayDir));\n        }\n        else if (mat==1.0) // floor\n        {\n            float occ = calcAO( pHit, vec3(0.0,1.0,0.0) );\n            float cdist=pow(distance(pHit,rayOrigin),1.202);\n            col=vec3(0.5)*occ;\n            \n            float tee = -rayOrigin.y / rayDir.y;\n\n            vec2 P = rayOrigin.xz + t * rayDir.xz;\n            vec2 Q = floor(P);\n            P = mod(P, 1.0);\n\n            const float gridLineWidth = 0.05;\n\n            float res = clamp(2048.0 / iResolution.y, 1.0, 3.0);\n            P = 1.0 - abs(P - 0.5) * 2.0;\n            float d = clamp(min(P.x, P.y) / (gridLineWidth * clamp(tee + res * 2.0, 1.0, 2.0)) + 0.5, 0.0, 1.0);\n\n            float shade = mix(hash(120.0 + Q * 0.1) * 0.4, 0.3, min(tee * tee * 0.001, 1.0)) + 0.6;\n            vec3 colFloor= vec3(pow(d, \n                           clamp(150.0 / (pow(max(tee - 2.0, 0.1), res) + 1.0), 0.1, 31.0)\n                      )) * shade + 0.1;            \n            \n            colFloor*=vec3(0.51,0.12,0.23);\n            col=mix(colFloor,col,0.5);\n            col=fog(col,pow(cdist,.7642),Sky(rayDir));\n        }\n        else if (mat==2.0) // amiga balls\n        {\n            vec3 q=N;\n            vec2 matuv = vec2( atan(N.x,N.z), acos(N.y ) );\n            vec2 qp = floor(matuv*2.51);\n            float intensity=mod( qp.x+qp.y, 2.0 );\n            if (intensity==1.0) col=vec3(1.0,0.0,0.0);\n            else col=vec3(1.0);\n            float NoL = max(dot(N, L), 0.1);\n            col*=NoL;\n            col+=pow(NoL,32.0);\n            \n            vec3 refDir = reflect(rayDir,N);\n\n            vec4 colReflect=bounceRender(pHit,refDir,uv);\n            col=mix(col,colReflect.xyz,0.7);\n\n            float cdist=pow(distance(pHit,rayOrigin),1.202);\n            col=fog(col,pow(cdist,.7642),Sky(rayDir));\n        }\n        else if ((mat==3.0)||(mat==4.0))\n        {\n            col=vec3(NoL)*0.75;\n            if (mat==4.0) col+=vec3(231.0/256.0,12.0/256.0,52.0/256.0);\n            else col+=vec3(0.0,112.0/256.0,232.0/256.0);\n            vec3 refDir = reflect(rayDir,N);\n            vec4 colReflect=bounceRender(pHit,refDir,uv);\n            col=mix(col,colReflect.xyz,0.6);\n\n            float cdist=pow(distance(pHit,rayOrigin),1.202);\n            col=fog(col,pow(cdist,.7642),Sky(rayDir));\n        }\n        else\n        {\n            col=vec3(1.0,1.0,0.0);\n        }\n        \n    }\n    else\n    {\n        col=Sky(rayDir);\n    }\n\n    col=pow(col,vec3(0.58));\n    return vec4(col,1.0);\n}\n\nvec3 getCameraRayDir(vec2 uv, vec3 camPos, vec3 camTarget)\n{\n    vec3 camForward = normalize(camTarget - camPos);\n    vec3 upz=vec3(0.,1.,0.);\n    vec3 camRight = normalize(cross(upz, camForward));\n    vec3 camUp = normalize(cross(camForward, camRight));\n     \n    float fPersp = 2.0;\n    vec3 vDir = normalize(uv.x * camRight + uv.y * camUp + camForward * fPersp);\n \n    return vDir;\n}\n\nvec2 normalizeScreenCoords(vec2 screenCoord)\n{\n    vec2 result = 2.0 * (screenCoord/iResolution.xy - 0.5);\n    result.x *= iResolution.x/iResolution.y;\n    return result;\n}\n\nfloat onelinerRandom(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid initBalls()\n{\n    float ballSpread=16.0;\n    int seed=234;\n    for (int b=0;b<numBalls;b++)\n    {\n        float x=-ballSpread/2.0+onelinerRandom(vec2(seed))*ballSpread; seed+=0x42;\n        float y=onelinerRandom(vec2(seed))*3.141592*2.0; seed+=0x42;\n        float z=-ballSpread/2.0+onelinerRandom(vec2(seed))*ballSpread; seed+=0x42;\n        float delta=onelinerRandom(vec2(seed));\n\t\tballsPositions[b]=vec4(x,y,z,delta);        \n    }\n}\n\nvec2 curve(vec2 uv)\n{\n\tuv = (uv - 0.5) * 2.0;\n\tuv *= 1.1;\t\n\tuv.x *= 1.0 + pow((abs(uv.y) / 5.0), 2.0);\n\tuv.y *= 1.0 + pow((abs(uv.x) / 4.0), 2.0);\n\tuv  = (uv / 2.0) + 0.5;\n\tuv =  uv *0.92 + 0.04;\n\treturn uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initBalls();\n    \n    float myTime=(iTime+1.34)/2.0;\n\tvec2 uv = normalizeScreenCoords(fragCoord);\n\n    vec3 camPos,camTarget;\n\n    float radius=4.0;\n    camPos = vec3(radius*sin(myTime),1.0+cos(myTime/4.0)*0.9,-radius*cos(myTime));\n    camTarget = vec3(0.0,0.,0.0);\n    \n    vec3 rayDir = getCameraRayDir(uv, camPos, camTarget);   \n\n    vec4 finalCol = vec4(render(camPos, rayDir,uv).xyz,1.0);\n\t//vec4 col=finalCol;\n    \n\tvec2 coord = (uv - 0.5) * (iResolution.x/iResolution.y) * 2.0;\n    vec2 uv2 = fragCoord.xy / iResolution.xy;\n\tvec3 col = finalCol.rgb;\n    col=clamp(col*0.6+0.4*col*col*1.0,0.0,1.0);\n    float vig = (0.0 + 1.0*16.0*uv2.x*uv2.y*(1.0-uv2.x)*(1.0-uv2.y));\n\tcol *= vec3(pow(vig,0.3));\n    col *= vec3(0.95,0.90,0.95)*2.7;\n\tfloat scans = clamp( 0.35+0.35*sin(3.5*iTime+uv2.y*iResolution.y*1.5), 0.0, 1.0);\n\tfloat s = pow(scans,1.7);\n\tcol = col*vec3( 0.4+0.7*s) ;\n    col *= 1.0+0.01*sin(110.0*iTime);\n\tcol*=1.0-0.65*vec3(clamp((mod(fragCoord.x, 2.0)-1.0)*2.0,0.0,1.0));\n    float comp = smoothstep( 0.1, 0.9, sin(iTime) );\n    \n    //vec3 col2=mix(col,finalCol.rgb,0.5);\n    //col=mix(col,finalCol.rgb,(1.0-pow(distance(uv,vec2(0.0,0.0)),0.039))/1.0);\n\tcol=mix(col,finalCol.rgb,0.4);\n    //vec3 col=finalCol.xyz;\n    \n    fragColor=vec4(col.rgb, 1.0);\n}\n", "image_inputs": [{"id": "MljGDw", "previewfilepath": "https://soundcloud.com/studiodrumandbass/induktiv-clutter-free-download?in=different-drumz/sets/free-drum-bass-downloads-from", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/studiodrumandbass/induktiv-clutter-free-download?in=different-drumz/sets/free-drum-bass-downloads-from", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsfBWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[329, 329, 372, 372, 394], [396, 396, 428, 428, 539], [541, 541, 572, 572, 683], [685, 685, 716, 716, 827], [829, 829, 881, 881, 980], [982, 982, 1015, 1015, 1043], [1045, 1045, 1090, 1090, 1181], [1183, 1183, 1216, 1216, 1247], [1249, 1249, 1280, 1280, 1367], [1369, 1369, 1426, 1426, 1762], [1764, 1764, 1828, 1828, 1945], [1947, 1947, 1965, 1965, 4041], [4043, 4043, 4070, 4070, 4401], [4403, 4403, 4446, 4446, 4722], [4724, 4724, 4766, 4766, 5080], [5082, 5082, 5104, 5104, 5185], [5187, 5187, 5207, 5207, 5295], [5297, 5297, 5339, 5339, 5518], [5520, 5520, 5577, 5577, 8157], [8160, 8160, 8211, 8211, 11372], [11374, 11374, 11434, 11434, 11760], [11762, 11762, 11808, 11808, 11934], [11936, 11936, 11966, 11966, 12038], [12040, 12040, 12058, 12058, 12480], [12482, 12482, 12503, 12503, 12691], [12693, 12693, 12750, 12750, 14025]], "test": "valid"}
{"id": "tsfcDf", "name": "logistic_difference_v0006", "author": "darkczar", "description": "logistic difference equation fun", "tags": ["psychedelic", "trippy"], "likes": 1, "viewed": 33, "published": "Public", "date": "1585721745", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// based on...\n// https://www.shadertoy.com/view/lssfW2\n\nfloat nsin(float x)\n{\n    return .5+.5*sin(x);\n}\nfloat ncos(float x)\n{\n    return .5+.5*cos(x);\n}\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}  //https://gist.github.com/companje/29408948f1e8be54dd5733a74ca49bb9\n\nhighp float rand(vec2 co)  //from stackoverflow\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nuint hash( uint x ) {  //http://amindforeverprogramming.blogspot.com/2013/07/random-floats-in-glsl-330.html\n\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\nfloat random( float f ) {  //http://amindforeverprogramming.blogspot.com/2013/07/random-floats-in-glsl-330.html\n\n    const uint mantissaMask = 0x007FFFFFu;\n    const uint one          = 0x3F800000u;\n   \n    uint h = hash( floatBitsToUint( f ) );\n    h &= mantissaMask;\n    h |= one;\n    \n    float  r2 = uintBitsToFloat( h );\n    return r2 - 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float r = 0.0;\n    float g = 0.0;\n    float b = 0.0;\n    vec2 xy0 = vec2(0.,0.);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord /iResolution.xy;\n    //vec2 p=uv;//(fragCoord.xy-iResolution.xy)/iResolution.y;\n    \n    vec2 xy = vec2(0.,0.);\n    // r between 3.75 and 4.0 produces chaotic behavior\n    float rr = .5*(ncos(.5*iTime))+3.5; // + .5*nsin(iTime*.5); //2.57 +nsin(iTime); //+cos(iTime);\n    xy = uv;\n    //int max_iter = int(6.0 + floor(8.0*nsin(iTime*.2)));\n    for (int i = 0; i<9; i++)\n    {\n        xy = rr*xy*(vec2(1.0,1.0)-xy + .5*nsin(.1*iTime)*vec2(sin(.5*iTime + 6.28*xy.y),cos(.5*iTime+6.28*xy.x)));\n        if(i==0)\n        {\n          xy0 = xy;  \n        }\n        if (i>1)\n            {\n                if(abs(length(xy) - length(xy0)) < .1) // try and tease out the cycles and color them\n                {\n                    r = 1.*random(float(mod(float(i),15.00)))*nsin(iTime);\n                    g = 1.*random(1.28+float(mod(float(i),15.0)));\n                    b = 1.*random((1.0 - float(mod(float(i),15.0))))*ncos(iTime);\n                } else if (dot(normalize(xy),normalize(xy0)) > .08)\n                {\n                    r = 1.*random((1.0 - float(mod(float(i),15.0))))*ncos(iTime);\n                    g = 1.0 - 1.*random(1.28+float(mod(float(i),15.0)));\n                    b = 1.*random(float(mod(float(i),15.00)))*nsin(iTime);\n                }\n            }\n    }\n    if (length(xy) > 20000.0)\n    {\n        r = nsin(iTime)*mod(length(xy),20000.0)/8000000.0;\n        g = 0.0;\n        b = ncos(iTime)*20000.0/length(xy);\n    } \n        \n        //m = (rand_point.x-prev_point.x) / ((rand_point.y-prev_point.y);\n        //line_y = m*p.x +  \n\n\n    \n    vec3 col = vec3(r, g, b);\n    float dn = col.x + col.y + col.z;\n    col /= dn;\n    // Output to screen\n    //fragColor = vec4(col,1.0);\n    fragColor = vec4( pow(col,vec3(1./2.2)),1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsfcDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 79, 79, 106], [107, 107, 128, 128, 155], [157, 157, 229, 229, 295], [616, 616, 637, 723, 855], [856, 856, 881, 967, 1204], [1206, 1206, 1263, 1263, 3175]], "test": "valid"}
{"id": "tsfcWf", "name": "kraken", "author": "yuntaRobo", "description": "Inspired by glow-in-the-dark figures.\nThe luminescent effect is derived from the pseudo-SSS technique.", "tags": ["raymarching", "sss", "kraken", "octopus", "luminous"], "likes": 14, "viewed": 370, "published": "Public API", "date": "1585756827", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.1415926;\nconst float E = 0.005;\n\nconst vec3 light_dir = normalize(vec3(-0.6, 0.2, -1.0));\nconst vec3 light_color = vec3(0.3, 0.6, 1.0);\n\nstruct Ray\n{\n    vec3 pos;\n    vec3 dir;\n};\n\nmat2 rotate2D(float rad)\n{\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat2(c, s, -s, c);\n}\n\n// https://www.iquilezles.org/www/articles/smin/smin.htm\nvec2 smin(float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return vec2(mix(d2, d1, h) - k * h * (1.0 - h), h);\n}\n\n// https://gaz.hateblo.jp/entry/2019/05/17/231141\nvec2 spfold4(vec2 p, float k)\n{\n    const int n = 4;\n    for(int i = 0; i < n; i++)\n    {\n        float a = PI / exp2(float(i));\n        vec2 v = vec2(cos(a), sin(a));  \n        p -= 2.0 * smin(0.0, dot(p, v), k).x * v;\n    }\n    return p;\n}\n\nfloat deBody(vec3 p, float t)\n{\n    float a = atan(p.z, p.x);\n    p *= vec3(1.0, 0.7, 1.0);\n    p += vec3(0.0, 0.7 - sin(t) * 0.25, 0.0);\n    float d = length(p) - 0.9 - sin(a * 20.0) * 0.05;\n    d = abs(d) - 0.2;\n    return d;\n}\n\nfloat deLeg(vec3 p, float h, float r)\n{\n    float a = atan(p.z, p.x);\n    p.y -= clamp(p.y, 0.0, h);\n    float d = length(p) - r - sin(a * 10.0) * pow(r, 0.8) * 0.05;\n    return d;\n}\n\nfloat deOctopus(vec3 p)\n{\n    float t = iTime - pow(length(p), 0.5) * 1.5;\n    \n    p.y *= -1.0;\n    p.xz *= rotate2D(0.45);\n    p.yz *= rotate2D(1.2 + sin(iTime * 0.333) * 0.25);\n    \n    float body = deBody(p, t);\n    \n    p.xz *= rotate2D(0.4);\n    p.xz = spfold4(p.xz, 0.04);\n    float h = 5.0;\n    float r = exp(-length(p) * 0.7) * 0.75;\n    mat2 m = rotate2D(0.35 + cos(length(p) * 1.75 + t) * 0.1);\n    p.yz *= m;\n    float leg = deLeg(p, h, r);\n    p.yz *= m;\n    leg = smin(leg, deLeg(p, h, r), 0.04).x;\n\n    float d = smin(body, leg, 0.3).x;\n    d *= 0.5;\n    \n    return d;\n}\n\nfloat deSea(vec3 p)\n{\n    float t = iTime - pow(length(p), 0.5) * 1.5;\n    \n    p.xz *= rotate2D(t);\n    float d = p.y + 0.2\n        - sin(p.x * 2.0) * 0.05\n        - sin(p.z * 3.111) * 0.05\n        - (sin(t * 0.333) * 0.5 + 0.5) * 0.5;\n    return d;\n}\n\nvec2 de(vec3 p)\n{\n    vec2 o = smin(deOctopus(p), deSea(p), 0.1);\n    return o;\n}\n\nfloat sss(vec3 o, vec3 dir, float ed, float la)\n{\n    const int ei = 4;\n    float accum = 0.0;\n    float st = ed / float(ei);\n    float d = st;\n    for (int i = 0; i < ei; i++)\n    {\n        accum += max(de(o + dir * d).x, 0.0);\n        d += st;\n    }\n    accum = clamp(accum / ed / (float(ei) * 0.5 + 0.5), 0.0, 1.0);\n    return exp(-(1.0 - accum) * la);\n}\n\nfloat luminous(vec3 o, vec3 dir, float ed, float la)\n{\n    const int ei = 16;\n    float accum = 0.0;\n    float st = ed / float(ei);\n    float d = st;\n    for (int i = 0; i < ei; i++)\n    {\n        accum += max(-de(o + dir * d).x / d, 0.0);\n        d += st;\n    }\n    accum = clamp(accum / float(ei), 0.0, 1.0);\n    return exp(-(1.0 - accum) * la);\n}\n\n// iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 normal(vec3 p)\n{\n    float h = E;\n    vec2 k = vec2(1.0, -1.0);\n    return normalize(\n            k.xyy * de(p + k.xyy * h).x + \n            k.yyx * de(p + k.yyx * h).x + \n            k.yxy * de(p + k.yxy * h).x + \n            k.xxx * de(p + k.xxx * h).x\n        );\n}\n\nvoid trace(Ray ray, inout vec3 color, float md)\n{\n    float ad = 0.0;\n    for (float i = 1.0; i > 0.0; i -= 1.0 / 150.0)\n    {\n        vec2 o = de(ray.pos);\n        if (o.x < E)\n        {\n            // normal\n            vec3 n = normal(ray.pos);\n            \n            // fresnel\n            float f0 = 0.075;\n            float f = f0 + (1.0 - f0) * pow(1.0 - max(dot(-ray.dir, n), 0.0), 5.0);\n            \n            // color\n            vec3 em = vec3(0.1, 1.0, 0.3);\n            \n            vec3 color1 = luminous(ray.pos, ray.dir, 0.35, 7.5) * em * 60.0;\n            color1 += sss(ray.pos, light_dir, 0.35, 5.0) * light_color * 5.0;\n            \n            vec3 color2 = sss(ray.pos, ray.dir, 0.5, 5.0) * vec3(0.0, 0.0, 1.0) * 2.0 * f;\n            color2 += sss(ray.pos, light_dir, 0.5, 6.0) * light_color * 0.3 * f;\n            color2 += exp(-deOctopus(ray.pos) * 17.5) * (em + light_color) * 0.01 * exp(-length(ray.pos) * 0.25);\n            \n            color += mix(color2, color1, pow(o.y, 5.0));\n            \n            color *= exp(-ad * ad * 0.03);\n            \n            return;\n        }\n\n        ray.pos += ray.dir * o.x;\n        ad = ad + o.x;\n        if (ad > md)\n        {\n            break;\n        }\n    }\n\n    // background\n    color += pow(max(dot(ray.dir, light_dir), 0.0), 800.0) * light_color * 3.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    // view\n    vec3 view = vec3(-1.0, 1.0, 6.75);\n    vec3 at = normalize(vec3(-2.0, 0.0, 0.0) - view);\n    vec3 right = normalize(cross(at, vec3(0.0, 1.0, 0.0)));\n    vec3 up = cross(right, at);\n    float focallength = 2.25;\n\n    // ray\n    Ray ray;\n    ray.pos = view;\n    ray.dir = normalize(right * p.x + up * p.y + at * focallength);\n\n    // ray marching\n    trace(ray, color, 20.0);\n\n    // cheap tonemapping\n    // https://www.desmos.com/calculator/adupt0spl8\n    float k = 0.75;\n    color = mix(color, 1.0 - exp(-(color - k) / (1.0 - k)) * (1.0 - k), step(k, color));\n\n    // gamma correction\n    color = pow(color, vec3(0.454545));\n\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsfcWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[201, 201, 227, 227, 307], [309, 366, 406, 406, 522], [524, 574, 605, 605, 815], [817, 817, 848, 848, 1046], [1048, 1048, 1087, 1087, 1230], [1232, 1232, 1257, 1257, 1818], [1820, 1820, 1841, 1841, 2072], [2074, 2074, 2091, 2091, 2155], [2516, 2516, 2570, 2570, 2865], [2867, 2924, 2945, 2945, 3196], [3198, 3198, 3247, 3247, 4533], [4535, 4535, 4592, 4592, 5368]], "test": "error"}
{"id": "tsfczn", "name": "simple 3d raytrace", "author": "loni852", "description": "3d", "tags": ["3d"], "likes": 2, "viewed": 51, "published": "Public", "date": "1587736287", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define lenght 1.0f\n#define height 1.0f\nstruct ray\n{\n\tvec3 o,d;\n};\n\nray GetRay(vec2 uv, vec3 campos,vec3 lookat,float zoom)\n{\n    ray a;\n    \n    a.o = campos;\n    //Front Vector\n    vec3 f = normalize(lookat - campos);\n    //Right Vector\n    vec3 r = cross(vec3(0,1,0),f);\n    //Up Vector\n    vec3 u = cross(f,r);\n    //Center\n    vec3 c = a.o + f*zoom;\n    \n    vec3 i = c + uv.x * r +uv.y * u;\n    \n    a.d = normalize(i-a.o);\n    \n    return a;\n    \n}\nfloat DistLine(vec3 ro, vec3 rd, vec3 p) {\n\treturn length(cross(p-ro, rd))/length(rd);\n}\n\n\nfloat DrawPoint(vec3 ro,vec3 rd,vec3 p){\n\tfloat d = DistLine(ro, rd, p);\n    \n    d = smoothstep(.1,0.09, d);\n    \n    return d;\n\n}\n\nvec3 DrawCube(vec3 ro,vec3 rd,vec3 center)\n{\n    float r = 0.0;\n    float g = 0.0;\n    float b = 0.0;\n    int colorchange;\n    float d;\n    \n    \n\td += DrawPoint(ro,rd,vec3(center.x+0.,center.y+0.,center.z+0.));\n    if (d > 0.0 && colorchange == 0){\n    \tr += 1.0;\n        g += 0.0;\n        b += 0.0;\n        colorchange = 1;\n    }\n    \n    \n    d += DrawPoint(ro,rd,vec3(center.x+0.,center.y+0.,center.z+lenght));\n    if (d > 0.0 && colorchange == 0){\n    \tr += 0.0;\n        g += 1.0;\n        b += 0.0;\n        colorchange = 1;\n    }\n    d += DrawPoint(ro,rd,vec3(center.x+0.,center.y+height,center.z+0.));\n    if (d > 0.0 && colorchange == 0){\n    \tr += 0.0;\n        g += 0.0;\n        b += 1.0;\n        colorchange = 1;\n    }\n    d += DrawPoint(ro,rd,vec3(center.x+0.,center.y+height,center.z+lenght));\n    if (d > 0.0 && colorchange == 0){\n    \tr += 1.0;\n        g += 1.0;\n        b += 0.0;\n        colorchange = 1;\n    }\n    d += DrawPoint(ro,rd,vec3(center.x+lenght,center.y+0.,center.z+0.));\n    if (d > 0.0 && colorchange == 0){\n    \tr += 1.0;\n        g += 0.0;\n        b += 1.0;\n        colorchange = 1;\n    }\n    d += DrawPoint(ro,rd,vec3(center.x+1.,center.y+0.,center.z+lenght));\n    if (d > 0.0 && colorchange == 0){\n    \tr += 0.0;\n        g += 1.0;\n        b += 1.0;\n        colorchange = 1;\n    }\n    d += DrawPoint(ro,rd,vec3(center.x+lenght,center.y+height,center.z+0.));\n    if (d > 0.0 && colorchange == 0){\n    \tr += 1.0;\n        g += 1.0;\n        b += 1.0;\n        colorchange = 1;\n    }\n    d += DrawPoint(ro,rd,vec3(center.x+lenght,center.y+height,center.z+lenght));\n    if (d > 0.0 && colorchange == 0){\n    \tr += 1.0;\n        g += 0.5;\n        b += 0.5;\n        colorchange = 1;\n    }\n\treturn vec3(r,g,b);\n\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy; // 0 <> 1\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;// -0.5 <> 0.5\n    \n    \n    float t = iTime;\n    \n    \n    \n    //origen del ray \n    vec3 camPos = vec3(sin(t)*3.0, 2., -3.*cos(t));\n    \n    //direccion hacia la que mira el ray\n    vec3 lookAt = vec3(0.5, 0.5, 0.5);\n    \n    float zoom = 0.5;\n    \n    ray ray = GetRay(uv,camPos,lookAt,zoom);\n    \n    \n    \n    //color de los puntos\n    vec3 d = vec3(0.0,0.0,0.0);\n    \n    //centro de los puntos\n    vec3 center = vec3(0.0,0.0,0.0);\n    \n    float backgroundcolor = (0.2,0.0,0.3);\n    \n    d += DrawCube(ray.o,ray.d,center);\n    \n    if (d == vec3(0.0,0.0,0.0))\n    {\n    \td+= backgroundcolor;\n    }\n    \n\tfragColor = vec4(d.r,d.g,d.b,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsfczn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 125, 125, 455], [456, 456, 498, 498, 544], [547, 547, 587, 587, 678], [680, 680, 724, 724, 2413], [2415, 2415, 2472, 2472, 3227]], "test": "error"}
{"id": "tsffzM", "name": "spec amb diffuse lighting", "author": "bradjamesgrant", "description": "I'm a noob who forgets this stuff all the time. Hopefully helps someone else when searching for lighting examples\n\n28/05 - normalize l when doing dot prods", "tags": ["specularambientdiffuselighting"], "likes": 2, "viewed": 85, "published": "Public", "date": "1587906331", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//off makes unlit surfaces still show bit of colour\nfloat diffuse(vec3 n, vec3 l){\n    l = normalize(l);\n    float off = 0.03;\n\treturn max(0.,dot(n,l)*.9)+off;\n}\n\n//higher s = larger effect area\n//higher e = more defined spec\n//higher m = scaled down overall lighting\nfloat spec(vec3 n, vec3 ro, vec3 rd, vec3 l,vec3 p){\n    l = normalize(l);\n    vec3 v = rd;\n    vec3 r = reflect(l,n);\n    float s = 0.15;\n    float e = 10.;\n    float m = 2.;\n    \n    //clamp before exp or you get light on both sides..\n    return pow(clamp(dot(v,r)-s,0.,1.),e)/m;\n}\n\n\nfloat map(vec3 p){\n    float c =length(p)-0.25;\n    \n\treturn c;\n   \n}\n\nvec3 calcNormal(vec3 p){\n\tvec2 e = vec2(0.001,0.);\n    return normalize(vec3(map(p+e.xyy)-map(p-e.xyy),\n                     map(p+e.yxy)-map(p-e.yxy),\n                     map(p+e.yyx)-map(p-e.yyx)));\n}\n\nvec3 castRay(vec3 ro, vec3 rd, vec3 l){\n\n    float t = 0.;\n    for(int i = 0; i<100; i++){\n    \tvec3 p = ro + t*rd;\n        float d = map(p);\n        t+=d;\n\t\tif(d>10.)\n            break;\n        if(d<0.01*t*.5){\n\t\t\tvec3 amb = vec3(0.4,0.5,0.6);\n            float ll = length(p-l);\n            float att=1.0/(1.0+0.1*ll+0.01*ll*ll);\n            vec3 n =calcNormal(ro + t*rd); \n        \treturn att*amb*vec3(diffuse(n, l)+spec(n,ro,rd,l, p) );\n            break;\n        }\n    }\n    return vec3(0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.x;\n \t\n   \n    vec3 ro = vec3(0.,0.,-1.);\n    \n    vec3 cf = -ro;\n    vec3 cs = cross(cf,vec3(0.,1.,0.));\n    vec3 cu = cross(cf, cs);\n\t                   \n   \tvec3 uuv = -ro*.1+uv.x*cs + uv.y*cu;\n    \n    vec3 rd = uuv-ro;\n    \n\n    vec3 p = vec3(0.);\n    float t = 0.;\n   \tfloat d = 0.;\n    vec3 l = vec3(sin(iTime),-1.,cos(iTime));\n    vec3 col = castRay(ro,rd, l);\n    \n   \n    \n    \n   \n    \n    fragColor = vec4(col,0.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsffzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 53, 83, 83, 162], [164, 269, 321, 321, 552], [555, 555, 573, 573, 624], [626, 626, 650, 650, 829], [831, 831, 870, 870, 1329], [1331, 1331, 1388, 1388, 1872]], "test": "valid"}
{"id": "tsjcD3", "name": "glslpractice2", "author": "bigdra50", "description": "practice", "tags": ["practice"], "likes": 0, "viewed": 194, "published": "Public API", "date": "1587466634", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rot(vec2 p, float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return vec2(p.x*c - p.y*-s, p.x*s+p.y*c);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 c = vec3(0);\n    vec2 p = ((fragCoord.xy/iResolution.xy)-.5)*2.;\n    \n    c.yz = vec2(.04/abs(.03-length(p)));\n    p+=rot(c.xy, iTime);\n\n    float t = atan(p.y, p.x)+iTime*2.5;\n    p = rot(rot(p, iTime), t);\n    vec2 q = p;\n    q*= p*(1.2+sin(t*7.))*.5;  // -1 ~ 1 -> 0 ~ 1\n    q*= p*(1.2+cos(t*3.5))*5.;  // -1 ~ 1 -> 0 ~ 1\n    vec2 v = vec2(1.+cos(t*10.), 1.+tan(iTime*10.));\n    c.x = dot(p, v) / abs(.5-(length(q)*abs(length(q))));\n    c = smoothstep(0., .1, c);\n    c.yz += p;\n\n    fragColor = vec4(vec3(abs(.5-length(c.x+q.y)), 1.-(c.y*p.x), c.z+q.x+p.y), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsjcD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 131], [133, 133, 188, 188, 765]], "test": "valid"}
{"id": "tsjcW1", "name": "Desargues Theorem", "author": "mla", "description": "Another projective favourite.\n\nHit 'x' for a surprise.", "tags": ["theorem", "desargues"], "likes": 4, "viewed": 249, "published": "Public API", "date": "1586593991", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Desargues' Theorem.\n//\n// Matthew Arcus, mla, 2020\n//\n// If two triangles (blue lines) are in perspective from a point\n// (green lines), then corresponding sides meet in colinear points\n// (red line).\n//\n// Mouse moves things around\n// Press 'x' for a different perspective on the diagram.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n\nconst float PI = 3.14159;\n\nstruct Ray {\n  vec3 q;               // origin\n  vec3 d;               // direction\n};\n\nstruct Hit {\n  float t;      // solution to p=q+t*d\n  vec3 n;       // (unnormalized) normal\n  int id;       // what was hit\n};\n\nstruct Sphere {\n  float r2;      // radius squared\n  vec3 p;       // centre\n  int id;\n};\n\nstruct Cylinder {\n  float r2;      // radius squared\n  // points s and t are end points of cylinder\n  vec3 s,t;\n  int id;\n};\n\n// Solve Ax^2 + 2Bx + C = 0\nbool quadratic(float A, float B, float C, out vec2 t) {\n   float D = B*B - A*C;\n   if (D < 0.0) return false;\n   D = sqrt(D);\n   t.x = B > 0.0 ? -B-D : -B+D;\n   t.y = C/t.x;\n   t.x = t.x/A;\n   if (t.x > t.y) t.xy = t.yx;\n   return true;\n}\n\nbool intersectSphere(Sphere s, Ray ray, inout Hit hit) {\n  vec3 p = s.p;\n  float r2 = s.r2;\n  float c2 = dot(p,p);\n  vec3 q = ray.q, d = ray.d;\n  // |q + t*d - p|^2 = r^2\n  float A = 1.0;\n  float B = dot(q-p,d);\n  float C = dot(q,q)-2.0*dot(q,p)+c2-r2;\n  A *= 2.5;B *= 2.5;C *= 2.5;\n  vec2 res;\n  if (!quadratic(A,B,C,res)) return false;\n  float t = res.x;\n  if (t < 0.0) t = res.y;\n  if (t < 0.0 || t >= hit.t) return false;\n  // Normal is the radial vector of sphere\n  // We normalize it later\n  hit = Hit(t, q+t*d-p, s.id);\n  return true;\n}\n\nbool cylinder(vec3 q, vec3 s, float r2, vec3 p, vec3 r, out float t, out vec3 normal) {\n  vec3 n = s-q; // Line direction\n  float k2 = dot(n,n);\n  vec3 p1 = p-q; // Move p to line space\n  float rs = dot(r,n);\n  float ps = dot(p1,n);\n  float pr = dot(p1,r);\n  float pp = dot(p1,p1);\n  float A = 1.0 - rs*rs/k2;\n  float B = pr - ps*rs/k2;\n  float C = pp - ps*ps/k2 - r2;\n  vec2 res;\n  if (!quadratic(A,B,C,res)) return false;\n  t = res.x;\n  if (t < 0.0) t = res.y;\n  if (t < 0.0) return false;\n  p1 += t*r; // Final point in line space\n  float lambda = dot(p1,n)/k2;\n  if (lambda < 0.0 || lambda > 1.0) return false;\n  normal = p1-lambda*n;\n  return true;\n}\n\nbool intersectCylinder(Cylinder c, Ray ray, inout Hit hit) {\n  vec3 s0 = c.s;\n  vec3 s1 = c.t;\n  float r2 = c.r2;\n  vec3 q = ray.q, d = ray.d;\n  float t;\n  vec3 normal;\n  if (!cylinder(s0,s1,r2,q,d,t,normal) || t >= hit.t) return false;\n  // Normal is the radial vector of cylinder\n  hit = Hit(t, normal, c.id);\n  return true;\n}\n\n// (p+P)(q+Q) = pq + pQ + qP + PQ\nvec4 qmul(vec4 p, vec4 q) {\n  return p.w*q + q.w*p + vec4(cross(p.xyz,q.xyz),-dot(p.xyz,q.xyz));\n}\n\nvec3 intersect(vec3 p0,vec3 p1,vec3 q0,vec3 q1) {\n  vec3 n = p1-p0;\n  vec3 m = q1-q0;\n  // Want p0 + kn = q0 + km\n  // or\n  // kn = q0 - p0 + km\n  // k(n x m) = (q0 - p0) x m\n  vec3 t1 = cross(n,m);\n  vec3 t2 = cross(q0-p0,m);\n  float k = dot(t1,t2)/dot(t1,t1);\n  return p0+k*n;\n}\n\nbool dorotate = true;\nbool do3d = false;\n\nHit intersectScene(Ray ray) {\n  // O,A,B,C are arbitrary\n  vec3 O = vec3( 0, 1,-1); // Centre of projection\n  vec3 A = vec3( 0,-1,-1); // ABC is base triangle\n  vec3 B = vec3(-1,-1,-1);\n  vec3 C = vec3( 0,-1, 0);\n  // G must be on CA, I on AB and D on OA, but exact position arbitrary\n  float j = 2.0;\n  vec3 G = j*C+(1.0-j)*A; // GHI is intersection line\n  vec3 I = j*A+(1.0-j)*B;\n  float k = 0.5;\n  vec3 D = k*O+(1.0-k)*A; // DEF is perspective triangle\n  // The other points are now determined\n  vec3 E = intersect(D,I,B,O);\n  vec3 F = intersect(G,D,C,O);\n  vec3 H = intersect(B,C,I,G);\n  Hit hit = Hit(1e8,vec3(0),0);\n  float s2 = 0.04*0.04;\n  float c2 = 0.015*0.015;\n  intersectSphere(Sphere(s2,O,1),ray,hit);\n  intersectSphere(Sphere(s2,A,1),ray,hit);\n  intersectSphere(Sphere(s2,B,1),ray,hit);\n  intersectSphere(Sphere(s2,C,1),ray,hit);\n  intersectSphere(Sphere(s2,D,1),ray,hit);\n  intersectSphere(Sphere(s2,E,1),ray,hit);\n  intersectSphere(Sphere(s2,F,1),ray,hit);\n  intersectSphere(Sphere(s2,G,1),ray,hit);\n  intersectSphere(Sphere(s2,H,1),ray,hit);\n  intersectSphere(Sphere(s2,I,1),ray,hit);\n  if (!do3d && hit.t < 1e8) return hit;\n  intersectCylinder(Cylinder(c2,A,O,2),ray,hit);\n  intersectCylinder(Cylinder(c2,B,O,2),ray,hit);\n  intersectCylinder(Cylinder(c2,C,O,2),ray,hit);\n  intersectCylinder(Cylinder(c2,A,G,3),ray,hit);\n  intersectCylinder(Cylinder(c2,D,G,3),ray,hit);\n  intersectCylinder(Cylinder(c2,B,H,3),ray,hit);\n  intersectCylinder(Cylinder(c2,E,H,3),ray,hit);\n  intersectCylinder(Cylinder(c2,B,I,3),ray,hit);\n  intersectCylinder(Cylinder(c2,E,I,3),ray,hit);\n  intersectCylinder(Cylinder(c2,G,I,0),ray,hit); // Intersection line\n  return hit;\n}\n\nvec3 light = vec3(0,0,-1);\nfloat ambient = 0.5;\nfloat diffuse = 0.5;\n\nvec3 getColor(int i) {\n  if (i == 0) return vec3(1,0,0);\n  if (i == 1) return vec3(1,1,0);\n  if (i == 2) return vec3(0,1,0);\n  if (i == 3) return vec3(0,0,1);\n  if (i == 4) return vec3(0,1,1);\n  return vec3(1,1,1);\n}\n\nvec3 solve(Ray r) {\n  Hit hit = intersectScene(r);\n  if (hit.t >= 1e8) {\n    return vec3(0);\n  } else {\n    vec3 n = normalize(hit.n);\n    if (dot(r.d,n) > 0.0) n = -n;\n    vec3 baseColor = 0.7*getColor(hit.id);\n    vec3 color = baseColor;\n    if (do3d) {\n      color *= ambient+diffuse*max(0.0,dot(light,n));\n      float specular = pow(max(0.0,dot(reflect(light,n),r.d)),2.0);\n      color += 0.5*specular*vec3(1.0,1.0,1.0);\n    }\n    return color;\n  }\n}\n\nvec2 rotate(vec2 p, float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,-theta);\n    p.zx = rotate(p.zx,phi);\n  }\n  if (dorotate) {\n    float t = iTime;\n    p.yz = rotate(p.yz,-t*0.223);\n    p.zx = rotate(p.zx,-t*0.15);\n  }\n  return p;\n}\n\nconst int CHAR_E = 69;\nconst int CHAR_I = 73;\nconst int CHAR_X = 88;\nbool keypress(int key) {\n  return texelFetch(iChannel0, ivec2(key,2),0).x != 0.0;\n}\n\nint AA = 2;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  do3d = keypress(CHAR_X);\n  vec3 aacol = vec3(0);\n  for (int i = 0; i < AA; i++) {\n    for (int j = 0; j < AA; j++) {\n      vec2 uv = (2.0*(fragCoord.xy + vec2(i,j)/float(AA)) - iResolution.xy)/iResolution.y;\n      vec3 p = vec3(1.5*uv,2);\n      vec3 r = vec3(0,0,-1);\n      p = transform(p);\n      r = transform(r);\n      r = normalize(r);\n      float t = 0.5*iTime;\n      light = vec3(1,1,1);\n      light = normalize(light);\n      light = transform(light);\n      aacol += solve(Ray(p,r));\n    }\n  }\n  aacol /= float(AA*AA);\n  aacol = pow(aacol,vec3(0.4545));\n  fragColor = vec4(aacol,1);\n}\n", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsjcW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[924, 952, 1007, 1007, 1190], [1192, 1192, 1248, 1248, 1735], [1737, 1737, 1824, 1824, 2392], [2394, 2394, 2454, 2454, 2722], [2724, 2758, 2785, 2785, 2856], [2858, 2858, 2907, 2907, 3138], [3182, 3182, 3211, 3238, 4850], [4922, 4922, 4944, 4944, 5138], [5140, 5140, 5159, 5159, 5594], [5596, 5596, 5626, 5626, 5678], [5680, 5680, 5707, 5707, 6048], [6119, 6119, 6143, 6143, 6202], [6216, 6216, 6273, 6273, 6866]], "test": "error"}
{"id": "tsjyDm", "name": "Weighted Normal Blending", "author": "Donzanoid", "description": "Weighted normal blending using @ZigguraVertigo test shader.", "tags": ["normals"], "likes": 4, "viewed": 274, "published": "Public API", "date": "1586793319", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec4 RotationBetween(vec3 v0, vec3 v1)\n{\n    // Shortest arc\n    float d = dot(v0, v1);\n    float s = sqrt((1.0 + d) * 2.0);\n    float invs = 1.0 / s;\n    vec3 c = cross(v1, v0);\n    return vec4(c.xyz * invs, 0.5 * s);\n}\n\nvec4 RotationFromZ(vec3 v1)\n{\n    // Shortest arc from <0, 0, 1>\n    int x = floatBitsToInt(2.0 + v1.z * 2.0);\n    //x = 0x1FBD1DF5 + (x >> 1);\n    // rsqrt from Robin's new math paper, allows one less div\n    x = 0x5F37624F - (x >> 1);\n    float s = intBitsToFloat(x);\n    //return vec4(v1.y / s, -v1.x / s, 0.0, 0.5 * s);\n    return vec4(v1.y * s, -v1.x * s, 0.0, 0.5 / s);\n}\n\nvec4 nlerp(vec4 q0, vec4 q1, float t)\n{\n    return normalize(mix(q0, q1, t));\n}\n\nvec4 fnlerp(vec4 l, vec4 r, float t)\n{\n\tfloat ca = dot(l, r);\n\tfloat k = 0.931872f + ca * (-1.25654f + ca * 0.331442f);\n\tfloat ot = t + t * (t - 0.5f) * (t - 1.0) * k;\n    return normalize(mix(l, r, ot));\n}\n\nvec4 slerp(vec4 a, vec4 b, float t)\n{\n    // Get half-angle between quaternions\n    float cos_theta = clamp(dot(a, b), -1.0, 1.0);\n    float theta = acos(cos_theta);\n    float sin_theta = sqrt(1.0 - cos_theta * cos_theta);\n\n    // Slerp\n    float t0 = sin((1.0 - t) * theta) / sin_theta;\n    float t1 = sin(t * theta) / sin_theta;\n    vec4 r;\n    r.x = a.x * t0 + b.x * t1;\n    r.y = a.y * t0 + b.y * t1;\n    r.z = a.z * t0 + b.z * t1;\n    r.w = a.w * t0 + b.w * t1;\n    return r;\n}\n\nvec3 Transform(vec4 q, vec3 v)\n{\n    return v * (q.w * q.w - dot(q.xyz, q.xyz)) + 2.0 * q.xyz * dot(q.xyz, v) + 2.0 * q.w * cross(q.xyz, v);\n    //return v + 2.0 * cross(q.xyz, q.w * v + cross(q.xyz, v));\n}\n\nvec3 TransformZ(vec4 q)\n{\n    // Transforming <0,0,1> by q where q.z = 0 for tangent-space normal\n    vec3 r;\n    r.x = -2.0 * q.w * q.y;\n    r.y =  2.0 * q.w * q.x;\n    r.z =  q.w * q.w - dot(q.xy, q.xy);\n    return r;\n    \n    // c = cross(a, b)\n    // c.x = a.y * b.z - b.y * a.z\n    // c.y = a.z * b.x - b.z * a.x\n    // c.z = a.x * b.y - b.x * a.y\n}\n\nvec3 NormalBlend(vec3 n1, vec3 n2, float t)\n{\n    n1 = n1 * 2.0 - 1.0;\n    n2 = n2 * 2.0 - 1.0;\n    \n    //return n1;\n    \n    //return normalize(mix(n1, n2, 0.8));\n    \n    #if 1\n    \n    //vec4 q1 = RotationBetween(vec3(0.0, 0.0, 1.0), n1);\n    vec4 q1 = RotationFromZ(n1);\n        \n    //vec4 q2 = RotationBetween(vec3(0.0, 0.0, 1.0), n2);\n    vec4 q2 = RotationFromZ(n2);    \n    \n    vec4 qa = nlerp(q1, q2, t);\n    vec4 qb = fnlerp(q1, q2, t);\n    vec4 qc = slerp(q1, q2, t);\n    \n    //vec4 d = qc - qb;\n    //return vec3(abs(dot(d, d)) * 10000.0);\n    \n    //return Transform(qa, vec3(0.0, 0.0, 1.0));\n    return TransformZ(qa);\n    \n    #else\n    \n    vec4 q = RotationBetween(n1, n2);\n    \n    //vec4 qr = slerp(vec4(0.0, 0.0, 0.0, 1.0), q, 0.2);\n    vec4 qr = nlerp(vec4(0.0, 0.0, 0.0, 1.0), q, 1 - t);\n    \n    if (abs(qr.w) < 0.001) return vec3(1.0);\n    \n    //qr.z = 0.0;\n    \n    vec3 p = Transform(qr, n2);\n    \n    return p;\n    \n    #endif\n}\n\n\n// Compute base normal (since we don't have a texture)\nvec3 ComputeBaseNormal(vec2 uv) \n{\n    uv = fract(uv) * 2.0 - 1.0;    \n        \n    vec3 ret;\n    ret.xy = sqrt(uv * uv) * sign(uv);\n    ret.z = sqrt(abs(1.0 - dot(ret.xy,ret.xy)));\n    \n    ret = ret * 0.5 + 0.5;\n    return mix(vec3(0.5,0.5,1.0), ret, smoothstep(1.0,0.95,dot(uv,uv)));\n}\n\n// Compute a detail normal (since we don't have a texture)\nvec3 ComputeDetailNormal(vec2 uv)\n{\n    const vec4 avgRGB0 = vec4(1.0/3.0, 1.0/3.0, 1.0/3.0, 0.0);\n    const float scale = 0.02;\n    const vec2 du = vec2(1.0/512.0, 0.0);\n    const vec2 dv = vec2(0.0, 1.0/512.0);\n\n    float h0  = dot(avgRGB0, texture(iChannel0, uv)) * scale;\n    float hpx = dot(avgRGB0, texture(iChannel0, uv + du)) * scale;\n    float hmx = dot(avgRGB0, texture(iChannel0, uv - du)) * scale;\n    float hpy = dot(avgRGB0, texture(iChannel0, uv + dv)) * scale;\n    float hmy = dot(avgRGB0, texture(iChannel0, uv - dv)) * scale;\n    \n    float dHdU = (hmx - hpx) / (2.0 * du.x);\n    float dHdV = (hmy - hpy) / (2.0 * dv.y);\n    \n    return normalize(vec3(dHdU, dHdV, 1.0)) * 0.5 + 0.5;\n}\n//---------------------------------------------------------------------------------------------\n// Main\n//---------------------------------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{\n    vec2 uv = fragCoord.xy / iResolution.x;\n    \n    //---------------------------------------------------------------------------------------------------------\n    // [LEFT SIDE] - Combined normal, switches between technique\n    //---------------------------------------------------------------------------------------------------------\n    // Base Normal (Disk)\n    vec2 uvN = uv * (iResolution.x / iResolution.y) * 1.2 - vec2(0.12, 0.16);\n\n  \tvec3 BN = vec3(0.5, 0.5, 1.0);\n    if (uvN.x > 0.0 && uvN.x < 0.83 && uvN.y < 0.83 && uvN.y > 0.0)\n    {\n        BN = ComputeBaseNormal(uvN * vec2(1.2,1.2));\n    }\n    \n    // Detail Normal\n\tvec2 uvDN = uvN;\n    vec3 n1 = ComputeDetailNormal(uvDN);\n    \n    float t = 0.5;\n    t = fract(iTime * 0.1);\n \n\t// Combined Normal\n    vec3 N = NormalBlend(BN, n1, t);\n\n    //---------------------------------------------------------------------------------------------------------\n    // [RIGHT SIDE] - Combined normal with lighting, switches between technique\n    //---------------------------------------------------------------------------------------------------------\n    // Base Normal (Disk)\n    uvN = (uv + vec2(0.28, 0.0)) * (iResolution.x / iResolution.y) * 1.2 - vec2(0.12, 0.16);\n\n  \tBN = vec3(0.5, 0.5, 1.0);\n    if (uvN.x > 1.66 && uvN.y > 0.0 && uvN.y < 0.83 && uvN.x < 2.50)\n    {\n        BN = ComputeBaseNormal(uvN * vec2(1.2,1.2));\n    }\n    \n    // Detail Normal\n\tuvDN = uvN+vec2(0.33,0);\n    n1 = ComputeDetailNormal(uvDN);\n \n\t// Combined Normal\n    vec3 N2 = NormalBlend(BN, n1, t);\n   \t\n\tvec3 light = normalize(vec3(1.0, 0.0, 1.0));    \n    vec3 lit = vec3(clamp(dot(light, N2), 0.0, 1.0));\n\n    // Mix normal and lit result\n\tvec3 color = mix(N*0.5 + 0.5, lit, float(uv.x > 0.5));\n\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsjyDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 41, 61, 221], [223, 223, 252, 287, 600], [602, 602, 641, 641, 681], [683, 683, 721, 721, 889], [891, 891, 928, 970, 1373], [1375, 1375, 1407, 1407, 1581], [1583, 1583, 1608, 1680, 1937], [1939, 1939, 1984, 1984, 2899], [2902, 2957, 2991, 2991, 3245], [3247, 3306, 3341, 3341, 4008], [4009, 4209, 4265, 4265, 6040]], "test": "error"}
{"id": "tsjyRc", "name": "explosions in the sky", "author": "ericfode", "description": "its pretty + and fft", "tags": ["sky", "stars"], "likes": 2, "viewed": 61, "published": "Public", "date": "1587097111", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//  Adapted from \n// https://www.shadertoy.com/view/MdXSzS\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy) - .5;\n\tfloat t = iTime * .1 + ((.25 + .05 * cos(iTime * .1))/(length(uv.xy) + .07)) * 2.2;\n\tfloat si = tan(t);\n\tfloat co = cos(t);\n    int tf = int(uv*512.0);\n   // first row is frequency data (48Khz/4 in 512 texels, meaning 23 Hz per texel)\n\tvec3 fft  = texelFetch( iChannel0, ivec2(t,0), 0 ).xyz; \n\n\tfloat s = 0.0;\n\tmat2 ma =  mat2(co*co, si, -si*si, co);\n    //mat2 ma = mat2(si,-si,-co,co);\n\tfloat v1, v2, v3;\n\tv1 = v2 = v3 = 0.0;\n\t\n    \n\n\tfor (int i = 0; i < 90; i++)\n\t{\n\t\tvec3 p = s * vec3(uv, 1.0)*fft*2.0 ;\n\t\tp.xy *= ma;\n\t\tp += vec3(.12, .2, s - 1.1 - sin(iTime * .223) * .1) ;\n\t\tfor (int i = 0; i < 10; i++)\tp = abs(p) / dot(p,p) - 0.459;\n\t\tv1 += dot(p,p) * .0015 * (1.8 + tan(length(uv.xy * 1.0) + .5  - iTime * .2));\n\t\tv2 += dot(p,p) * .0013 * (1.5 + tan(length(uv.xy * 1.5) + 1.2 - iTime * .3));\n\t\tv3 += length(p.xy*10.) * .0003;\n\t\ts  += .035;\n\t}\n\t\n\tfloat len = length(uv);\n\tv1 *= smoothstep(.7, .0, len);\n\tv2 *= smoothstep(.5, .0, len);\n\tv3 *= smoothstep(.9, .0, len);\n\t// the sound texture is 512x2\n\n\n\tvec3 col = vec3( v3 * (1.5 + sin(iTime * .2) * .4),\n\t\t\t\t\t(v1 + v3) * .05,\n\t\t\t\t\t v2) * + smoothstep(0.4, .0, len) * .85 + smoothstep(.0, .2, v3) * .3;\n\n\tfragColor=vec4(min(pow(abs(col), vec3(1.2)), 1.0), 1.0);\n}", "image_inputs": [{"id": "4tS3DD", "previewfilepath": "https://soundcloud.com/eric-fode-842615103/deserts", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/eric-fode-842615103/deserts", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsjyRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 118, 118, 1388]], "test": "error"}
{"id": "tsjyWD", "name": "inverting tiles", "author": "julianlumia", "description": "0kay now im done playing:)\nthe code is a complete hacked together mess but I like the look", "tags": ["tiles"], "likes": 5, "viewed": 96, "published": "Public", "date": "1586699343", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"Tile Generator v2. (WIP)\" by julianlumia. https://shadertoy.com/view/Ws2cWD\n// 2020-04-12 13:26:43\n\n// Fork of \"Islamic Tile Generator (WIP)\" by julianlumia. https://shadertoy.com/view/tdScWD\n// 2020-04-12 08:06:23\n\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n#define S(a, b, t) smoothstep(a, b, t)\n\n// inigo quilez\nfloat sdTri(  vec2 p, float s )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - s;\n    p.y = p.y + s/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdCircle( vec2 p, float r )\n{\n  return length(p) - r;\n}\n\n\n\nfloat sdOctogon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.9238795325, 0.3826834323, 0.4142135623 );\n    p = abs(p);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\n//from iq : https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat smin( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord  )\n{\n vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;    \nvec2 centuv = uv;\n    \n    \n    \n    \n    \n    \n    float dp = dot(uv*4.,uv*2.)*.3;\n uv /= dp;\n uv.y=sin(uv-vec2(iTime*.5)).y;\n    uv *= .5;\n    \n vec3 col = vec3(0);\n float d = 10e6;\n float triA;\n \n    uv = fract(vec2(uv.x-0.0,uv.y-.5)) -.5;\n uv *= 1.;\n    vec2 cuv = uv;\n\n float wave =20.;\n float wavemultip = 0.05;//sin(iTime*0.5)*.2+0.2*.9;\n float offset = (sin(iTime*0.3)*2.)*0.03;\n vec2 uv2;\n vec2 objsize =vec2(abs(uv.x*1.)*.001+0.00001,5.);\n for(int i = 0; i <4; ++i)\n {\n  uv = vec2((uv)*rot(float(.25)*pi));\n  vec2 wpos = vec2(uv.x+sin(uv.y*wave)*wavemultip,uv.y)*1.;\n  triA = sdBox(wpos+offset, objsize);\n float   triB = sdBox(wpos-offset, objsize);\n triA = min(triB, triA);       \n float   triC = sdBox(vec2(uv.x+sin(uv.y*wave-pi)*wavemultip,uv.y)-offset, objsize);\n float   triD = sdBox(vec2(uv.x+sin(uv.y*wave-pi)*wavemultip,uv.y)+offset, objsize);\n triC = min(triC, triD);\n triA = min(triC, triA);\nif( triA < d)\n {\n  d = triA;\n  }\n } \n float c;   \n   // vec2 cuv = uv;\n    \nfloat tr6;    \nfloat tr5;    \n\n    \n  wave =25.;\n  wavemultip = 0.02;//sin(iTime*0.5)*.2+0.2*.9;\n  offset = (sin(iTime*0.6)*0.5)*0.06;\n  uv2;\n  objsize =vec2(abs(centuv.x*3.)*.01+0.009,1.);\n    for(int i = 0; i <5; ++i)\n {\n  centuv = vec2((centuv)*rot(float(.25)*pi));\n  vec2 wpos = vec2(centuv.x+sin(centuv.y*wave)*wavemultip,centuv.y)*1.;\n  tr6 = sdBox(wpos+offset, objsize);\n float   triB = sdBox(wpos-offset, objsize);\n tr6 = min(triB, tr6);       \n float   triC = sdBox(vec2(centuv.x+sin(centuv.y*wave-pi)*wavemultip,centuv.y)-offset, objsize);\n float   triD = sdBox(vec2(centuv.x+sin(centuv.y*wave-pi)*wavemultip,centuv.y)+offset, objsize);\n triC = min(triC, triD);\n tr6 = min(triC, tr6);\nif( tr6 < tr5)\n {\n  tr5 = tr6;\n  }\n } \n    \n    \n    \n    \n    \n    \n    \n    \ncuv*= .5;\n    cuv += vec2(0.0,0.);\n\ncuv = abs(cuv)-.2;\n    for(int i = 0; i <1; ++i)\n  {\ncuv += vec2(-0.);\n\n      cuv = vec2((cuv)*rot(float(.25)*pi));\n\ncuv = abs(cuv)-.1+(offset);\n     //   cuv = vec2((cuv)*rot(float(.05)*pi));\n      c = sdOctogon(vec2((cuv.x)+float(i)*.2,cuv.y+float(i)*.05),.16);\n      \n   float c2 = c +0.001;\n   c = max(c,-c2);\n if( c < d)\n  {\n   c = c;\n  }\n } \n float ca = sdOctogon(vec2((uv.x),uv.y),.36);\n    \n     float cat = sdCircle(vec2((centuv.x),centuv.y),.1);\n\n    cat *= .5;\n float c2a = ca -0.3;\n ca = max(ca,c2a);\n    ca += .0;\n// triA = min(triA,-ca);\n triA = min(triA,c);\n d = min(d, triA);\n  //  cat = min(-cat,tr5);\n       // cat = smin(cat,d,.5);\n\n    d = max(d, -cat);\n        cat = min(-cat,tr5);\n\n    d = max(-d, cat);\n\n//cat = max(cat,tr5);\n //       d = min(d, -cat);\n\n    col += smoothstep(0.01,.001/iResolution.y,-d);\n col += vec3(sin(cuv.y*1.*iTime)*.4,sin(cuv.y*.5*iTime),sin(cuv.y*0.06*iTime)+.0)*0.5;\n // col *= .6;\n       col*=1.3;\n col=smoothstep(0.0,2.,col);\n col=pow(col, vec3(0.4545));\n fragColor = vec4(col,1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsjyWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[359, 375, 408, 408, 615], [616, 616, 668, 668, 787], [789, 789, 824, 824, 850], [854, 854, 896, 896, 1180], [1182, 1266, 1310, 1310, 1410], [1412, 1412, 1449, 1449, 1529], [1531, 1531, 1589, 1589, 4486]], "test": "valid"}
{"id": "tsjyWV", "name": "Single Layer Blurred Glitter", "author": "qwert33", "description": "Second step towards building a renderer for https://youtu.be/BtYKDamqo2I?t=334\nMouse click/drag to adjust depth-of-field blur.\n\nStep one: https://www.shadertoy.com/view/td2cDy\nStep three: https://www.shadertoy.com/view/wdXfzN#", "tags": ["dof", "glitter"], "likes": 0, "viewed": 188, "published": "Public API", "date": "1587635252", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst vec3 default_debug = vec3(-100, -20, -10);\nconst vec3 orange = vec3(1., .5, 0.);\nconst vec3 cornflowerblue = vec3(100./255., 149./255., 237./255.);\nvec3 debug = default_debug;\n\nfloat blurRadius;\n\n\n#define TAU 6.28318530718\n#define PI TAU/2.\n// Dave Hoskins hash\nfloat hash13(in vec3 p3) {\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// https://www.shadertoy.com/view/4sS3zz\nfloat sdEllipse(vec2 p, in vec2 ab) {\n    if (abs(ab.x-ab.y) < .00001) return length(p) - ab.x;  // haaax due to numerical stability issues.\n\n\tp = abs(p); \n    if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\t\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\n\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n\t\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if (d<0.0) {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    } else {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx) + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt( 1.0 - co*co );\n \n    vec2 r = ab * vec2(co,si);\n\t\n    return length(r-p) * sign(p.y-r.y);\n}\nfloat sdEllipsoidApproximated( in vec2 p, in vec2 r ) {\n    float k0 = length(p/r);\n \treturn length(p/r) - 1.;\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n\n// How many cells around the central_cell we check for ellipses.\n#define SAMPLE_RADIUS 2\n\nfloat monochrome(vec2 uv) {\n    \n    const float cell_wd = 5.5;\n    vec2 central_cell_center = floor((uv+.5*cell_wd) / cell_wd) * cell_wd;\n    \n\tfloat hashTime = iTime + 100.;  // Don't want thing to be synchonous when the shader starts    \n    \n    int j;\n    float acc = 0.;\n    for (int i = -SAMPLE_RADIUS; i<=SAMPLE_RADIUS; ++i) {\n        for (j = -SAMPLE_RADIUS; j<=SAMPLE_RADIUS; ++j) {\n            vec2 cell_center = central_cell_center + cell_wd*vec2(ivec2(i,j));\n            \n            vec2 cell_hash_pos = cell_center + vec2(1030., 0);\n            float yaw = TAU * hash13(vec3(cell_hash_pos, 2.));\n            float angular_speed = 3. + hash13(vec3(cell_hash_pos, 3.));\n            vec2 angular_vel = angular_speed * vec2(cos(yaw), sin(yaw));\n            float pitch = length(angular_vel) * hashTime * 0.1;\n            vec2 a = normalize(angular_vel);  // axis of rotation - major axis of projected ellipse.\n            vec2 b = vec2(-a.y, a.x) * cos(pitch);  // minor axis\n            vec2 ab = vec2(length(a), length(b));\n            mat2 rot = mat2(a.x, a.y,\n                            -a.y, a.x);\n\n            vec3 normal = vec3(0.0, sin(pitch), cos(pitch));\n            mat3 rot3 = mat3(a.x, a.y, 0.,\n                             -a.y, a.x, 0.,\n                             0., 0., 1.);\n            normal = transpose(rot3) * normal;\n            const vec3 LIGHT_DIR = normalize(vec3(1.5, -1.0, 2.0));\n            float light_per_area = \n                .2 + // ambient\n                50.0 * smoothstep(.98, .99, abs(dot(normal, LIGHT_DIR)));  // cheap (wrong-ish) specular\n            float total_light = light_per_area * ab.x * ab.y;  // total amount of light emitted by this object towards all pixels.\n\n            // Have a random offset from the cell_center.\n            vec2 ellipse_center = cell_center + (.5*cell_wd - ab.x) * vec2(\n            \tsin(hashTime * (.01 + .06*hash13(vec3(cell_hash_pos, 4.)))),\n                cos(hashTime * (.01 + .06*hash13(vec3(cell_hash_pos, 4.))))\n            );\n\t\t\tvec2 ellipse_uv = uv - ellipse_center;   \n            \n            vec2 extended_ab = ab + vec2(blurRadius);\n            //float sd = sdEllipse(transpose(rot)*inner_uv, extended_ab);\n            //float sd = sdEllipsoidApproximated(transpose(rot)*inner_uv, extended_ab);\n            float sd = length(transpose(rot)*ellipse_uv / extended_ab) - 1.;  // Signed distance approximation only accurate for values near zero.\n            float proportional_area = extended_ab.x * extended_ab.y;\n            float edge_blurryness = 0.1/length(extended_ab);\n            float is_in_ellipse = smoothstep(edge_blurryness, -edge_blurryness, sd);\n            acc += is_in_ellipse * (total_light / proportional_area);\n\n            // Debug major/minor axes.\n            //if (abs(dot(uv-ellipse_center, normalize(b))) <.01 && length(uv-ellipse_center) < 1.) acc += .9;\n            //if (abs(dot(uv-ellipse_center, normalize(a))) <.01 && length(uv-ellipse_center) < length(b))  acc += .9;\n\n            acc += 1.-smoothstep(0., .1, abs(length(uv) - blurRadius));\n        }\n    }\n\treturn acc;\n}\n\nvec2 project(vec2 pixel) {\n    vec2 uv = pixel/iResolution.xy - vec2(0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv *50.;\n}\n\n\n// antialiasing\nfloat sampleSubpixel(vec2 pixels) {\n\tconst int size = 0; \n    const float numContrb = float(size+1)*float(size+1);\n\tfloat disp = 1.0 / (float(size) + 2.0);\n\tfloat contrb = 0.0;\n\tfor (int j = -size; j <= size; j++) {\n\t\tfor (int i = -size; i <= size; i++) {\n\t\t\tcontrb += monochrome(project(\n                pixels + vec2(float(i) * (disp / 3.0), float(j) * disp)\n            ));\n\t\t}\n\t}\n\treturn contrb / numContrb;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    blurRadius = (iMouse.xy == vec2(0.))? .6 : max(0., length(project(iMouse.xy))-.5);\n    vec3 light = vec3(.1,.2,.9) * sampleSubpixel(fragCoord);\n    light = 1. - exp(-2. * light); // Simulate exposure\n    fragColor = vec4(light, 1.0);\n    if (debug != default_debug) fragColor.rgb = debug;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsjyWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[248, 269, 295, 295, 398], [400, 441, 478, 478, 1637], [1638, 1638, 1693, 1693, 1809], [1902, 1902, 1929, 1929, 5006], [5008, 5008, 5034, 5034, 5147], [5582, 5582, 5636, 5636, 5931]], "test": "valid"}
{"id": "tsjyzw", "name": "Mandelbrot with mouse control", "author": "sanderoneil", "description": "my first shader", "tags": ["mandelbrot"], "likes": 0, "viewed": 207, "published": "Public API", "date": "1586357040", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy-.5;\n    \n    uv=uv/(iTime)*100.0;\n    \n    uv+=(iMouse.xy-iResolution.xy/2.0)/100.0;\n    \n    vec3 iro = vec3(uv.xy,0);\n\tfloat sq=0.0;\n    float sq2=0.0;\n    while (iro.z < 1.0){\n        sq=iro.x*iro.x;\n        sq2=iro.y*iro.y;\n        if (sq+sq2>10.0){\n            break;}\n        iro.x=sq-sq2+uv.x;\n        iro.y=2.0*iro.x*iro.y+uv.y;\n        iro.z+=.1;\n    }\n    \n    // Output to screen\n    fragColor = vec4(cos(sq),cos(sq2),iro.z,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsjyzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 589]], "test": "valid"}
{"id": "tsjyzy", "name": "spiral 3 truchet -Robinsong", "author": "Robinsong", "description": "truchet spiral", "tags": ["spiral"], "likes": 3, "viewed": 71, "published": "Public", "date": "1586896963", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define CENTER (iResolution.xy / 2.0)\n#define PI 3.1415\n#define TAU (2.0 * PI)\n\n//Convert rectangular to polar coordinates\nvec2 rect_to_polar(vec2 rect) {\n    float r = length(rect);\n    float theta = atan(rect.y, rect.x);\n    \n    //Fix the coordinates so they go from 0 to 2PI\n    //instead of -PI to PI. These two lines are optional\n    if (theta < 0.0)\n        theta += TAU;\n    \n    return vec2(r, theta);\n}\n\nvec2 normalized_polar(vec2 coord) {\n    //Centered UV coordinates accounting for aspect ratio\n    vec2 uv = (coord - CENTER ) / iResolution.y;\n    \n    //Convert to polar. Normalize the angle component by\n    //dividing by a full circle.\n    vec2 polar = rect_to_polar(uv);\n    polar.y /= TAU;\n    \n    return polar;\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(234.34, 435.35));\n    p += dot(p, p+34.23);\n    return fract(p.x*p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n \tvec2 st = fragCoord/iResolution.xy;\n    \n    vec2 uv = normalized_polar(fragCoord);\n    \n    \n    float gp = uv.y;\n    float gx = uv.x;\n    \n    \n    uv.x = -pow(uv.x,.1);\n    uv.x = uv.x + iTime/10.;\n//    uv.x = mod(uv.x, 1.);\n    \n    vec3 col = vec3(0,0,0);\n      \n//  col.x = sin(uv.x*100.);\n\tcol.x = -3.+sin(uv.x*100.-(gp*TAU))*10.;\n    col.x = clamp(col.x, 0., 1.);\n    col.x = min(col.x, gx+.01);\n\n    col.y = -2.+sin(uv.y*TAU*8.+iTime)*25.;\n    col.y = clamp(col.y, 0., 1.);\n    col.y = min(col.y, gx+.01);\n        \n// truchet\n    uv.y -= iTime*.03;\n    uv *= 55.;\n    //uv.y += iTime*3.;\n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    \n    float n = Hash21(id);\n    \n    float width = .25;\n        \n    if(n<.5) gv.x *= -1.;\n    float d = abs(abs(gv.x+gv.y)-.5);\n    float mask = smoothstep(.01, -.01, d-width);\n    \n    \n    //col += n;\n    col.x -= mask;\n    //mask = mask*-1.;\n\tcol.y *= mask-col.y;\n\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsjyzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[80, 123, 154, 154, 412], [414, 414, 449, 507, 732], [734, 734, 756, 756, 850], [852, 852, 909, 959, 1946]], "test": "valid"}
{"id": "tslBDH", "name": "led screen", "author": "bkpjjj", "description": ".", "tags": ["led", "postpro"], "likes": 3, "viewed": 101, "published": "Public", "date": "1588196314", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 distort = vec2(sin(uv.y * 10.0 + iTime * 3.) * 0.005,0.);\n    vec3 col = texture(iChannel0,uv + distort).rgb;\n    //vertical lines\n    float vlines = floor(uv.x * iResolution.x * 0.5);\n    float vrep = mod(vlines ,3.);\n    //rgb color\n    col += vec3(0.15,0.3,0.45);\n    col += vec3(0.5,0.,0.) * float(vrep == 0.);\n    col += vec3(0.0,0.5,0.) * float(vrep == 1.);\n    col += vec3(0.0,0.,0.5) * float(vrep == 2.);\n    //horizontal lines\n    float hlines = floor(uv.y * iResolution.y);\n    float hrep = mod(hlines,4.);\n    \n    col *= step(hrep,2.0);\n    col *= sin(sin(iTime * 1.) * 2.) * 0.2 + 0.5;\n    col += mod(1. - uv.y * 3.0 - iTime * 0.5,1.0) * 0.2;\n    //vign\n    vec2 U = pow((uv - 0.5) * 1.9, vec2(5));\n    col *= pow(1.0 - dot(U,U), 3.);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tslBDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 893]], "test": "error"}
{"id": "tslBR8", "name": "xy circular basis", "author": "darknoon", "description": "Just messing with some functions, but I turned it into a nice picture. Trying to make a function that has a lobe jutting out but doesn't have discontinuities.", "tags": ["trippy"], "likes": 1, "viewed": 172, "published": "Public API", "date": "1587700728", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec3 a = vec3(0.5, 0.5, 0.5);\nvec3 b = vec3(0.5, 0.5, 0.5);\nvec3 c = vec3(1.0, 1.0, 1.0);\nvec3 d = vec3(0.00, 0.33, 0.67);\n\n// isquilez color mapper\nvec3 colorMap(float t) {\n\treturn (a + b * cos(2. * 3.141 * (c * t + d)));\n}\n\n// Working on this as an oriented basis function for CPPNs\nfloat dv(vec2 uv, int am, float angle) {\n    float r = length(uv);\n    \n    float th = atan(uv.y, uv.x);\n    \n    //float rin = 32.;\n    //float rscale = (1.+rin)/rin - 1. / (rin*r + 1.);\n    float rscale = tanh(3.*r*r);\n    \n    float value = 1.8 + rscale * 0.7*cos(float(am)*th + angle) - r;\n    return tanh(value*value);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n\n    float scale = 2.5;\n    \n    float value = 0.0;\n    vec3 color = vec3(0.0);\n    for (int i=0; i<3; i++) {\n    \tfloat v = dv(uv * scale, 1+i, iTime * (0.8 + 0.4*float(i)) * float(i%2-1));\n        value += v;\n        color[i] = v;\n    }\n    //fragColor = vec4(value);\n    //fragColor = vec4(tanh(value));\n    color = mix(color, colorMap(1.5*value + 0.3*iTime), 0.15);\n    fragColor.xyz = color;\n    //fragColor.xyz = colorMap(value);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tslBR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[125, 150, 174, 174, 225], [227, 286, 326, 326, 611], [613, 613, 670, 720, 1254]], "test": "valid"}
{"id": "tslBRn", "name": "Saw cape", "author": "gaz", "description": "https://twitter.com/gaziya5/status/1253162058645831680", "tags": ["3d", "2tweets"], "likes": 6, "viewed": 105, "published": "Public", "date": "1587612915", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M(p)p=length(p)*sin(vec2(-.4,1.2)+mod(atan(p.x,p.y),.8))\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O-=O;\n\tfor(float g,e,i=0.;i<80.;i++)\n    {\n        vec3 p=g*vec3(C.xy/iResolution.y-.5,1.);\n        p.z+=iTime*3.;\n        p=mod(p,6.)-3.;\n        M(p.xz);\n        p.z=fract(p.z)-.5;\n        M(p.xz);\n        M(p.zy);\n        g+=e=dot(abs(p),vec3(.5))-1.2;\n        O+=(e<.01)?.3/i:0.;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tslBRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 65, 101, 101, 397]], "test": "valid"}
{"id": "tslBWn", "name": "153rd keyhole", "author": "gaz", "description": "https://twitter.com/gaziya5/status/1255065261205360642", "tags": ["3d", "2tweets"], "likes": 3, "viewed": 114, "published": "Public", "date": "1588066669", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 O, vec2 C) {\n\tfor(float g=0.,e,j,i=0.;i++<50.;){\n   \t\tvec3 p=g*vec3((C*2.-iResolution.xy)/iResolution.y,1),q;\n        p.z+=iTime;\n        q=p;\n        p=fract(p)-.5;\n        for(j=6.;--j>0.;)\n\t\t\tp.xy=abs(p.xy)-.08*j,\n            p.xy=vec2((p.x+p.y)*.6,(p.x-p.y)*.4)*j,\n            p.xy*=.6;\n        g+=e=.6*length(p.yz)-2e-3;\n        e<.01?O.xyz+=abs(sin(q*35.))*.6/i:p;\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tslBWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 402]], "test": "valid"}
{"id": "tslfRM", "name": "jardin y nube falsa v2", "author": "jorge2017a1", "description": "jardin y nube falsa v2", "tags": ["jardinynubefalsav2"], "likes": 1, "viewed": 70, "published": "Public", "date": "1587944545", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//por jorge2017a1-\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define PI 3.14159265358979323846264\n\n\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n\n///------------------------------------\nstruct TObj\n{\n    float tipo;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n};\n\n\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\n\n//-----------------------------------------\n#define MAXREFLECTIONS 2\n#define MAXITER 64\n//-----------------------------------------\nvec3 ambientColor = vec3(0.05, 0.15, 0.2);\nvec3 diffuseColor = vec3(0.2, 0.6, 0.8);\nvec3 specularColor = vec3(1.0, 1.0, 1.0);\nvec3 lightDir = normalize(vec3(0.0, 4.0, 5.0));\nvec3 spherePos = vec3(0.0, 0.5, 0.0);\n//-----------------------------------\n\n\n//vec3 light_pos   = vec3( -20.0, -20.0, -20.0 );\n//vec3 light_color = vec3( 0.3, 0.2, 1.0 );\n//vec3 light_pos   = vec3( 20.0, 20.0, 20.0 );\n//vec3 light_color = vec3( 1.0, 0.7, 0.7 );\n\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n\n\n\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//Sphere function\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); \n    float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, -sa, +.0,\n\t\t+sa, +ca, +.0,\n\t\t+.0, +.0, +1.0);\n}\n\n\n///---------------------------------------------\n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3.0 - 2.0 * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n\n///-----------------------------------------\nfloat random() \n{\n\treturn fract(sin(dot(mObj.uv, vec2(12.9898, 78.233)) ) * 43758.5453);\n}\n\n\nvec3 LightShading(vec3 N,vec3 L,vec3 V,vec3 color)\n{\n    vec3 diffuse = max(0.,dot(N,-L))*color;\n    vec3 specular = pow(max(0.,dot(N,normalize(-L-V))),100.)*vec3(1.,1.,1.); \n    return diffuse + specular;\n}\n\n    \n    \n//-------------------------------------------------\n\n\n\n\n//0000000000000000000000000000000000000000000000000000000\n\nfloat hash( in vec2 p ) \n{\n    return fract(sin(p.x*15.32+p.y*35.78) * 43758.23);\n}\n\nvec2 hash2(vec2 p)\n{\n\treturn vec2(hash(p*.754),hash(1.5743*p.yx+4.5891))-.5;\n}\n\n\nvec2 noise2(vec2 x)\n{\n    vec2 add = vec2(1.0, 0.0);\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    return mix(mix( hash2(p),          hash2(p + add.xy),f.x),\n                    mix( hash2(p + add.yx), hash2(p + add.xx),f.x),f.y);\n    \n}\n\nmat2 rotate(float a) {\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\n//------------------------------------------\n///https://www.shadertoy.com/view/3dScRc\nfloat softmin(float f1, float f2, float val)\n{\n      float e = max(val - abs(f1 - f2), 0.0);\n      return min(f1, f2) - e*e*0.25 / val;     \n}\n///---------------------------\n\nfloat GetDist(vec3 p  ) \n{\t\n\n      float d;\n    float dif1;\n    float dif2;\n    \n    d=999.9;\n \n    \n   vec3 pp, p2;\n    pp=p;\n    p2=p;\n    \n \n    float planeDist1 = p.y-5.0;  //piso inf\n    float planeDist1sup = 20.0-p.y;  //piso sup\n    float planeDist2 = p.x+10.0; //pared izq\n    float planeDist3 = 10.0-p.x;  //pared der\n    float planeDist4 = -p.z+30.0;  //pared atras\n   \n    vec2 res;\n    res = vec2(9999, 0);\n    \n    p2.z= p2.z-10.0;\n    p2.y=-6.0+p2.y+2.0*cos(iTime*3.0);\n    \n    \n    float sdsp1 =sdSphere( p2- vec3(0.0,2.0,0.), 4.0 );\n  \tres =opU(res, vec2(sdsp1,4));\n    \n   \n    float sdb03 = sdSphere( p2- vec3(-8.0,2.0,0.), 2.5 );\n    float sdb02 = sdSphere( p2- vec3(-6.0,2.0,0.), 3.5 );\n    float sdb01 = sdSphere( p2- vec3(-4.0,2.0,0.), 3.5 );\n    float sdb10 = sdSphere( p2- vec3(-2.0,2.0,0.), 5.0 );\n    float sdb11 = sdSphere( p2- vec3(3.0,2.0,0.), 3.5 );\n    float sdb21 = sdSphere( p2- vec3(5.0,2.0,0.), 3.0 );\n    float sdb31 = sdSphere( p2- vec3(7.0,2.0,0.), 2.0 );\n    float sdb41 = sdSphere( p2- vec3(9.0,2.0,0.), 1.0 );\n    \n    \n    \n    res =opU(res, vec2(sdb10,7));\n    \n    float ss= 999.0;\n    ss  =(softmin(ss,sdsp1,1.));\n    ss  =(softmin(ss,sdb03,1.));\n    ss  =(softmin(ss,sdb02,1.));\n    ss  =(softmin(ss,sdb01,1.));\n    ss  =(softmin(ss,sdb10,1.));\n    ss  =(softmin(ss,sdb11,1.));\n    ss  =(softmin(ss,sdb21,1.));\n    ss  =(softmin(ss,sdb31,1.));\n    ss  =(softmin(ss,sdb41,1.));\n    \n    \n    res=opU(res, vec2(ss,5  ));\n    \n    \n    \n    vec3 p5;\n    p5 =p+vec3(0.,-3.0,0.);\n    //p5.yx =-3.0+p.yx+2.0*cos(iTime*2.0);\n    p5.x =-p.x+iTime*3.0;\n    \n    p5.y+=sin(p5.x*0.5+5.0)-1.0;\n    p5.x=mod(p5.x,2.0)-1.0;\n    float sdb5= sdBox(p5- vec3(0.0,0.0,25.0) , vec3(10.0,8.0,2.0) );\n \tres=opU(res, vec2(sdb5,2 ));\n    \n    \n    //res =opU(res, vec2(planeDist1,6));\n    res =opU(res, vec2(planeDist1,21));\n    res =opU(res, vec2(planeDist4,4));\n   \n\t    \n\n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n    \n    return d;\n}\n\n\n\n///----------------------------------------------------------\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n\tfloat dO=0.2;\n    //Determines size of shadow\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = ro + rd*dO;\n        \n        float dS = GetDist(p);\n        \n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) \n        {\n            //mObj.dist=dO; \t\n            mObj.p=p; \t\n            gres2 = vec2(dO,dS); \n            break;\n    \t}    \n        \n    }\n    \n    return dO;\n}\n\n\n//---------------------------------------------------\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n\nfloat GetLightPar(vec3 p, vec3 plig) {\n    vec3 lightPos = plig;\n    //Determine movement of light ex. shadow and light direction and diffusion\n    //lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat saturate(float f)\n{\n\treturn clamp(f,0.0,1.0);\n}\n\n    \n\n#define offset1 4.7\n#define offset2 4.6\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) \n{\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\n\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tif(i==0 )\n    {\n    \n        \n      return vec3(0.0,0.0,0.0);\n    }\n    \n    if(i== 1 )\n    {\n        \n        //return vec3(1, 0.5, 0);\n        \treturn vec3(1.0,0.0,0.0);\n        } \n    if(i== 2 )\n    {\n        //return vec3(1.0, 1.0, 1.0);\n        \treturn vec3(0.0,1.0,0.0);\n        } \n    if(i== 3 )\n    {\n        //return vec3(247./255., 168./255.,  184./255.); \n        \treturn vec3(0.0,0.0,1.0);\n       } \n    if(i== 4 )\n    {\n        \n        //return vec3(0, 1, 1);\n        \treturn vec3(0.0,1.0,1.0);\n        } \n    if(i== 5 )\n    {\n        //return vec3(85./255., 205./255., 252./255.);\n        return vec3(1.0,0.0,1.0);\n        \n        } \n    if(i== 6 )\n    {\n        \n        ///return  vec3(0.5, 0.8, 0.9);\n        return vec3(1.0,0.5,1.0);\n        } \n        \n    if(i== 7 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n       } \n    if(i== 8 )\n    {\n       \n        \n        return vec3(0.425, 0.56, 0.9); \n       } \n    if(i== 9 )\n    {\n        \n        return vec3(0.5, 0.6, 0.6); \n     } \n    if(i== 10 )\n    {\n        return vec3(0.0, 1.0, 0.0);\n    } \n    \n    if(i== 11 )\n    {\n        return vec3(0.25, 0.25, 0.25);\n    } \n    \n     if(i== 15 )\n    {\n    \t\treturn vec3(1.0,0.0,1.);\n       } \n     if(i== 16 )\n    {\n    \t\treturn vec3(1.0,1.0,0.0);\n     } \n    \n    \n    \n    if(i== 21 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*0.12;\n            marbleP.z += sin(p.y*23.0)*0.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.3);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.4,0.4,0.6),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n    \n    \n    \n     if(i== 23)\n    {\n    \n        \n        return  vec3(0.425, 0.16, 0.6);\t\n        \t\n\t} \n    \n    \n    \n    if(i== 24)\n    {\n      float size = (-mObj.uv.y+.1)/2.5;\n     vec3 color = vec3(0.,0.,0.);\n     color += vec3(mod(floor(mObj.uv.x/size+sin(iTime)) + floor(mObj.uv.y*20./size+iTime),2.)-.8-mObj.uv.y);\n\n     // Lightsource falloff on floor\n     color *= vec3(smoothstep(0.,1.,1.-length(vec2(.2-mObj.uv.x/6.,.6+mObj.uv.y/1.5))));\n        return color;\n\t}    \n    \n    \n    if(i== 25)\n    {\n      float size = (-mObj.p.y+.1)/2.5;\n     vec3 color = vec3(0.,0.,0.);\n     color += vec3(mod(floor(mObj.p.x/size) + floor(mObj.p.y*20./size),2.)-.8-mObj.p.y);\n\n     // Lightsource falloff on floor\n     color *= vec3(smoothstep(0.,1.,1.-length(vec2(.2-mObj.p.x/6.,.6+mObj.p.y/1.5))));\n        return color;\n\t} \n    \n    if(i== 26)\n    {\n        // checkerboard hack\n\t\t\tvec2 cb = floor(mObj.p.xz);\n\t\t\tfloat cb2 = mod(cb.x*1.2 + cb.y, 2.);\n        \treturn vec3(1.4 + 0.1*cb2, 0.3 + 0.85*cb2, 0.35 - 0.3*cb2)*0.8;\n            \n    }   \n    \n    \n    \n    if(i== 27)\n    {\n      vec3 outColor = vec3(0.0);\n      float sinus1 = sin(mObj.uv.x*5.1 +iTime*0.5) * 0.1 - 0.2;\n      float land1 = step(sinus1, mObj.uv.y);\n      vec3 landColor1 = vec3(0.2, 0.4, 0.3);\n      outColor = mix(outColor, landColor1, 1.0 - land1);\n        return outColor;\n    }\n    \n}\n\n///--------------------------------------------\n\n\n\n\n\n\n// phong shading\nvec3 p_shadingv2( vec3 v, vec3 n, vec3 eye, vec3 plight_pos1,  vec3 plight_color1 )\n{\n\t// ...add lights here...\n\t\n\tfloat shininess = 16.0;\n\t\n\tvec3 final = vec3( 0.0 );\n\t\n\tvec3 ev = normalize( v - eye );\n\tvec3 ref_ev = reflect( ev, n );\n\t\n\t// light 0\n\t{\n\t\n\t\tvec3 vl = normalize( plight_pos1 - v );\n\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n\t\t\n\t\tfinal += plight_color1 * ( diffuse + specular ); \n\t}\n\t\n\t\n\n    return (final);\n}\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n    \n light_pos1   = vec3( -20.0, -20.0, -20.0 );\n light_color1 = vec3( 0.3, 0.2, 1.0 );\n\n light_pos2   = vec3( 20.0,20.0, 20.0 );\n light_color2 = vec3( 1.0, 0.7, 0.7 );\n\n    \n    \n    vec3 ro = vec3(0.0,10.0,-10.0);\n\t //ro =get_mouse(ro);\n    vec3 rd = normalize( vec3(uv,1.0));\n    \n    \n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    mObj.uv=uv;\n    mObj.rd=rd;\n    mObj.ro=ro;\n\n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n  \n    vec3 p = (ro + rd * d ); \n    glpRoRd=p;\n    mObj.p=p;\n    \n    float dif=1.5;\n    \n    vec3 colp1 = GetLightPar(p,light_pos1)*light_color1;\n    vec3 colp2 = GetLightPar(p,light_pos2)*light_color2;\n    \n    \n    \n    mObj.dist =d;\n    vec3 colobj;\n    colobj=getSphereColor(int( Obj.tipo));\n    \n    vec3 nor= GetNormal( p);\n    \n    vec3 col2=vec3(0.0);\n    col2+= p_shadingv2( p, nor, ro, light_pos1, light_color1 );\n    col2+= p_shadingv2( p, nor, ro, light_pos2, light_color2 );\n    col2=(col2)/2.0;\n    col2=(col2+colp1+colp2)/2.0;\n    col2= colobj*col2;\n    col= col2*dif;\n    \n    col = pow(col, vec3(1.0/2.2));  \n    \n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tslfRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1109, 1126, 1159, 1159, 1224], [1225, 1243, 1279, 1279, 1348], [1349, 1364, 1395, 1395, 1545], [1546, 1566, 1602, 1602, 1689], [1690, 1706, 1738, 1766, 1827], [1829, 1829, 1865, 1865, 1968], [1972, 1972, 2017, 2017, 2108], [2113, 2113, 2159, 2159, 2191], [2193, 2193, 2236, 2236, 2268], [2270, 2270, 2318, 2318, 2351], [2354, 2354, 2383, 2383, 2509], [2511, 2511, 2547, 2547, 2664], [2666, 2666, 2702, 2702, 2820], [2823, 2823, 2859, 2859, 2982], [3035, 3047, 3069, 3069, 3377], [3379, 3424, 3441, 3441, 3514], [3517, 3517, 3569, 3569, 3724], [3851, 3851, 3877, 3877, 3934], [3936, 3936, 3956, 3956, 4014], [4017, 4017, 4038, 4038, 4288], [4290, 4290, 4312, 4312, 4379], [4381, 4467, 4513, 4513, 4609], [4642, 4642, 4668, 4668, 6621], [6688, 6688, 6722, 6722, 7115], [7173, 7173, 7197, 7197, 7429], [7433, 7433, 7471, 7471, 7828], [7831, 7831, 7856, 7856, 7884], [7988, 8032, 8049, 8049, 8120], [8145, 8237, 8263, 8263, 8526], [8585, 8585, 8613, 8613, 13122], [13178, 13195, 13280, 13306, 13714], [13716, 13765, 13822, 13822, 14996]], "test": "error"}
{"id": "tslfWH", "name": "Original--Mandelbox--mandelbulb", "author": "jorge2017a1", "description": "Original--Mandelbox--mandelbulb", "tags": ["originalmandelboxmandelbulb"], "likes": 7, "viewed": 126, "published": "Public", "date": "1588192737", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 lightdir = normalize(vec3(-1., 1, -0.5));\n\nconst float detail = .00002;\nfloat det = 0.;\n\nfloat de2(vec3 p) {\n    vec3 op = p;\n    p = abs(1.0 - mod(p, 2.));\n    float r = 0., power = 8., dr = 1.;\n    vec3 z = p;\n    \n    for (int i = 0; i < 7; i++) {\n        op = -1.0 + 2.0 * fract(0.5 * op + 0.5);\n        float r2 = dot(op, op);\n        r = length(z);\n\n\n        if (r > 1.616) break;\n        float theta = acos(z.z / r);\n        float phi = atan(z.y, z.x);\n\n        dr = pow(r, power - 1.) * power * dr + 1.;\n        float zr = pow(r, power);\n        theta = theta * power;\n        phi = phi * power;\n        z = zr * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));\n        z += p;\n    }\n    return (.5 * log(r) * r / dr);\n}\n\nfloat de1(vec3 p) {\n    float s = 1.;\n    float d = 0.;\n    vec3 r,q;\n        r = p;\n      q = r;\n    \n    for (int j = 0; j < 6; j++) {\n\t   \n        r = abs(mod(q * s + 1.5, 2.) - 1.);\t\n        r = max(r, r.yzx);\n        //r = max(r = abs(mod(q * s + 1., 2.) - 1.), r.yzx);\n\t    \n        d = max(d, (.3 - length(r *0.985) * .3) / s);\n\t    \n\ts *= 2.1;\n    }\n    return d;\n}\n\n\nfloat map(vec3 p) {\n    return min(de1(p), de2(p));;\n}\n\nvec3 normal( in vec3 p) {\n    //vec2 e = vec2(0.005, -0.005);\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize(e.xyy * map(p + e.xyy) + e.yyx * map(p + e.yyx) + e.yxy * map(p + e.yxy) + e.xxx * map(p + e.xxx));\n}\n\nfloat shadow( in vec3 ro, in vec3 rd){\n\tfloat res = .0;\n    \tfloat t = 0.05;\n\tfloat h;\t\n    \tfor (int i = 0; i < 4; i++)\n\t{\n\t\th = map( ro + rd*t );\n\t\tres = min(6.0*h / t, res);\n\t\tt += h;\n\t}\n    return max(res, 0.0);\n}\n\nfloat calcAO(const vec3 pos,const vec3 nor) {\n    float aodet = detail * 80.;\n    float totao = 0.0;\n    float sca = 10.0;\n    \n    for (int aoi = 0; aoi < 5; aoi++) {\n        float hr = aodet + aodet * float(aoi * aoi);\n        vec3 aopos = nor * hr + pos;\n        float dd = map(aopos);\n        totao += -(dd - hr) * sca;\n        sca *= 0.75;\n    }\n    //return clamp(1.0 - 5.0 * totao, 0.0, 1.0);\n    return clamp(1.0 - 4.0 * totao, 0.0, 1.0);\n}\n\n\nfloat kset(vec3 p) {\n\t    p = abs(.5 - fract(p * 80.));\n    float es, l = es = 0.;\n    for (int i = 0; i < 13; i++) {\n        float pl = l;\n        l = length(p);\n        p = abs(p) / dot(p, p) - .5;\n        es += exp(-1. / abs(l - pl));\n    }\n    return es;\n}\n\nvec3 light( in vec3 p, in vec3 dir) {\n\n    vec3 n = normal(p);\n    float sh = min(5., shadow(p, lightdir));\n\n    float ao = calcAO(p, n);\n\n    float diff = max(0., dot(lightdir, -n)) * sh * 1.3;\n    float amb = max(0.2, dot(dir, -n)) * .4;\n    vec3 r = reflect(lightdir, n);\n    float spec = pow(max(0., dot(dir, -r)) * sh, 10.) * (.5 + ao * .5);\n    float k = kset(p) * .18;\n    vec3 col = mix(vec3(k * 1.1, k * k * 1.3, k * k * k), vec3(k), .45) * 2.;\n    col = col * ao * (amb * vec3(.9, .85, 1.) + diff * vec3(1., .9, .9)) + spec * vec3(1, .9, .5) * .7;\n    return col;\n}\n\n\n\n\nvec3 raymarch( in vec3 from, in vec3 dir) {\n    vec3 color, pos;\n    float t = 0.;\n    float td = 0.;\n    float d = 0.;\n    for (int i = 0; i < 128; i++) {\n        pos = from + t * dir;\n        float precis = 0.001 * t;\n        d = map(from + dir * t);\n\tdet=detail*(1.+t*55.);\n   \n        if (d < 0.0002) break;\n\t        t += d;\n    }\n    vec3 backg = vec3(.4,0.5,0.8);\n    //vec3 backg = vec3(.5);\n\n    color = light(pos - det * dir * 1.5, dir);\n    color *= vec3(1., .75, .8) * .9;\n    color = mix(color, backg, 1.0 - exp(-1.3 * pow(t, 1.3)));\n\n    return color;\n}\n\nvec3 camPath(float time) {\n    vec2 p = 600.0 * vec2(cos(1.4 + 0.37 * time),cos(3.2 + 0.31 * time));\n    return vec3(p.x, 0.0, p.y);\n}\n\nfloat hash(vec2 p)\n{\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 33758.5453)-.5;\n} \n\nvec3 postprocess(vec3 rgb, vec2 xy)\n{\n\trgb = pow(rgb, vec3(0.67));\n    \n\t//#define CONTRAST 1.4\n    #define CONTRAST 1.6\n    \n\t#define SATURATION 1.4\n\t#define BRIGHTNESS 1.2\n    \n    \n\trgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb*BRIGHTNESS)), rgb*BRIGHTNESS, SATURATION), CONTRAST);\n\t//rgb = clamp(rgb+hash(xy*time)*.1, 0.0, 1.0);\n\treturn rgb;\n}\n\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec2 uv = (fragCoord.xy / iResolution.xy) - .5;\n    float t = iTime * 0.5;\n    vec2 s = uv * vec2(1.75, 1.0);\n\n\n    vec3 campos = camPath(t * 0.001);\n    vec3 camtar = camPath(t + 2.0);\n    //float roll = 15.0*sin(t*.5+.4);\n\t\n    float roll = 0.4 * cos(0.4 * t);\n    vec3 cw = normalize(camtar - campos);\n    vec3 cp = vec3(sin(roll), cos(roll), 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n    vec3 rd = normalize(s.x * cu + s.y * cv + .6 * cw);\n\n    vec3 col = raymarch(campos, rd);\n\tcol = postprocess(col,s);\n    fragColor  = vec4(col, 0.0);\n\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tslfWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[94, 94, 113, 113, 748], [750, 750, 769, 769, 1123], [1126, 1126, 1145, 1145, 1180], [1182, 1182, 1207, 1243, 1409], [1411, 1411, 1449, 1449, 1628], [1630, 1630, 1675, 1675, 2078], [2081, 2081, 2101, 2101, 2341], [2343, 2343, 2380, 2380, 2918], [2923, 2923, 2966, 2966, 3489], [3491, 3491, 3517, 3517, 3625], [3627, 3627, 3647, 3647, 3716], [3719, 3719, 3756, 3756, 4084], [4092, 4092, 4148, 4148, 4743]], "test": "valid"}
{"id": "tslyDl", "name": "36 Days Of Type - N", "author": "nicolasdnl", "description": "36 Days Of Type - N", "tags": ["letter"], "likes": 1, "viewed": 46, "published": "Public", "date": "1586307502", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535897932384626433832795\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat msign( in float x ) { return (x>0.0)?1.0:-1.0; }\n\n// http://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nvec2 sdSqLine( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( dot2(pa-ba*h), ba.x*pa.y-ba.y*pa.x );\n}\n\nfloat sdCrescent(vec2 p, float r0, float r1, float d, float sign0, float sign1)\n{\n    float a = (r0*r0 - r1*r1 + d*d) / (2.0 * d);\n    \n    if( a < r0)\n    {\n        p.y = abs(p.y);\n        float b = sqrt(r0*r0-a*a);\n        float k = p.y*a - p.x*b;\n        float h = min(d*sign0*(d*(p.y-b)-k ),\n                      d*sign1*k);\n        if (h>0.0)\n        {\n            return length(p-vec2(a,b));\n        }\n    }\n    \n    return max(sign0*(length(p          )-r0),\n               sign1*(length(p-vec2(d,0))-r1));\n}\n\n// http://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nvec2 sdSqArc( in vec2 p, in vec2 a, in vec2 b, in float h, float d2min )\n{\n    vec2  ba  = b-a;\n    float l   = length(ba);\n    float ra2 = h*h + l*l*0.25;\n\n    // recenter\n    p -= (a+b)/2.0 + vec2(-ba.y,ba.x)*h/l;\n    \n    float m = ba.y*p.x-ba.x*p.y;\n    float n = dot(p,p);\n    \n    if( abs(h)*abs(ba.x*p.x+ba.y*p.y) < msign(h)*l*0.5*m )\n    {\n        d2min = min( d2min, n + ra2 - 2.0*sqrt(n*ra2) );\n    }\n\n    return vec2(d2min, -max(m,ra2-n) );\n}\n\n\n//------------------------------------------------------------\n\n\n\n// SDF of a shape made of a set line and arc segments\nfloat sdShape( in vec2 p, int kType[8], float kPath[18] )\n{\n    vec2 vb = vec2(kPath[0],kPath[1]);\n    \n    float d = dot2(p-vb);\n    int off = 0;\n    float s = 1.0;\n    for( int i=0; i<kType.length(); i++ )\n    {\n        vec2 va = vb;\n        vec2 ds;\n        \n        if( kType[i]==0) // line (x,y)\n        {\n            vb = vec2(kPath[off+2],kPath[off+3]);\n            ds = sdSqLine( p, va, vb );\n            off += 2;\n        }\n        else if( kType[i]==1 || kType[i]==2 ) // arc (x,y,r)\n        {\n            vb = vec2(kPath[off+3],kPath[off+4]);\n            ds = sdSqArc(p, va, vb, kPath[off+2], d );\n        \toff += 3;\n\n        }\n        \n        // in/out test\n        if ( kType[i]==2 )\n        {\n            bvec3 cond = bvec3( p.y<va.y, p.y<vb.y, ds.y>0.0 );\n            if( all(cond) || all(not(cond)) ) s*=-1.0;\n        }\n        else\n        {\n            bvec3 cond = bvec3( p.y>=va.y, p.y<vb.y, ds.y>0.0 );\n            if( all(cond) || all(not(cond)) ) s*=-1.0;\n        }\n\n        d = min( d, ds.x );\n    }\n    \n    //if( p.y < 0. ) s*=-1.0;\n    \n\treturn s*sqrt(d);\n}\n\nfloat sdA( in vec2 p )\n{\n    float width = 1.;\n    float height = 1.;\n    \n   \tint kType[] = int[](0,0,0,0,0,0,0,0);\n\tfloat kPath[] = float[]( -width*0.5,  height*0.5,\n                             -width*0.5, -height*0.5,\n                             -width*0.0, -height*0.5,\n                             -width*0.0, -height*0.1,\n                              width*0.5, -height*0.5,\n                              width*0.5,  height*0.5,\n                              width*0.0,  height*0.5,\n                              width*0.0,  height*0.1,\n                             -width*0.5,  height*0.5 );\n    /*int kType[] = int[](1,0);\n\tfloat kPath[] = float[](  width*0.5, 0.0, 0.0,\n                             -width*0.5, 0.0,\n                              width*0.5, 0.0 );*/\n    return sdShape(p,kType,kPath );\n}\n\nvec3 generateBorder(in vec3 col, in float border)\n{\n    col = mix( col, vec3(0.0), 1.0-smoothstep(0.0,0.015,border) );\n    return col;\n}\n\nfloat getLetter(float d)\n{\n    float letter = 1.-sign(d);\n\tletter = mix( letter, 1., 1.0-smoothstep(0.0,0.015,abs(d)) );\n    \n    return letter;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pBase = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0.);\n    \n    vec3 cols[6] = vec3[6](\n    \tvec3(1.,0.,0.),\n        vec3(0.,0.,1.),\n        vec3(0.,1.,0.),\n        vec3(1.,1.,0.),\n        vec3(0.,1.,1.),\n        vec3(1.,0.,1.)\n    );\n    \n    float t = mod(iTime * 0.1, 0.1) / 0.1 * PI * 2.;\n    float count = 50.;\n    \n    for (int i=50; i>=0; i--)\n    {\n    \tvec2 p = pBase * (1. + float(i)*0.05);\n        p.x += sin(t) * (float(i)-count*0.) * 0.008;\n\t\t//p.y += cos(t) * (float(i)-count*0.) * 0.008;\n        p.y += float(i) * 0.01;\n        \n        float d = sdA(p);\n        \n        float letter = getLetter(d);\n        \n        //col = mix(col, 0.94-vec3((float(i)+1.)/(count+10.)), min(1., max(0., letter)));\n        col = mix(0.94-vec3((float(i)+1.)/(count+10.)), col, min(1., max(0., letter)));\n        //col = mix(col, cols[i], min(1., max(0., letter)));\n    }\n    \n    float d = sdA(pBase);\n    float letter = getLetter(d);\n    //col *= letter;\n    col = mix(vec3(0.96), col, min(1., max(0., letter)));\n\n    // output\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tslyDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 71, 71, 90], [91, 91, 118, 118, 145], [147, 221, 271, 271, 404], [406, 406, 487, 487, 922], [924, 998, 1072, 1072, 1451], [1520, 1574, 1633, 1633, 2659], [3478, 3478, 3529, 3529, 3614], [3616, 3616, 3642, 3642, 3762]], "test": "error"}
{"id": "tslyWf", "name": "Gentle Bloby Thing", "author": "propagant", "description": "Playing around and made this... Uncomment WALLS_ENABLED to see walls. Just for fun.", "tags": ["raymarching", "blob", "softshadows"], "likes": 4, "viewed": 253, "published": "Public API", "date": "1585770189", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#define WALLS_ENABLED\n\nstruct ray\n{\n\tvec3 o;\n\tvec3 d;\n\tfloat l;\n};\n    \nvec4 opu(vec4 a, vec4 b)\n{\n\tif(a.w < b.w) return a;\n    else return b;\n}\n\t\nvec4 geo(vec3 p)\n{\n    float sXsin = sin(iTime * 0.8)*0.3; //---Sphere horizontal movement\n    float sXsin2 = sin(iTime * 0.8)*0.23;\n    float sXsinDouble = 0.2+sin(iTime * 1.5 )*0.1; //---Sphere horizontal movement 2xSpeed\n    float sBlob = sin(iTime * 3. + p.y * 8.); //---'Sphere blob'\n    \n\tvec4 o0 = vec4(0.2,0.6,1.0, length(p - vec3(sXsin,0.,1.5)) - 0.2 + sBlob * 0.0999);\n    o0.w *= smoothstep(0.1,0.05, -p.y-0.22) + clamp(abs(sXsin),0.05,0.2); //---The little 'slimy' effect below the 'blob'\n    #ifdef WALLS_ENABLED\n    o0.w *= smoothstep(0.02,0.01, abs(p.x)*0.02); //---'Wall' generation\n    #endif\n\tvec4 o0eye = vec4(vec3(1.0,1.0,1.0)*1.5, abs(length(p - vec3(sXsin,sXsinDouble,1.2)) - 0.01 + clamp(sBlob,-0.3,-0.1) * 0.0999)*0.45);\n    vec4 o0eyeb = vec4(vec3(0.0,0.0,0.0)*1.5, abs(length(p - vec3(sXsin2,sXsinDouble,1.15)) - 0.08 * 0.0999)*0.5);\n    vec4 o2 = vec4(0.2,0.4,0.5, p.y + 0.35);\n\t\n    vec4 g = opu(o2, o0);\n    vec4 g2 = opu(g, o0eye);\n    vec4 g3 = opu(g2, o0eyeb);\n    return g3;\n}\n\nvec4 march(ray r)\n{\n\tvec3 col = vec3(1.0);\n\tfor(int i = 0; i < 16; i++)\n\t{\n\t\tvec3 p = r.o + r.d * r.l; //---Traditional march operation\n\t\tvec4 g = geo(p);\n\t\tr.l += g.w;\n\t\tcol = g.rgb;\n\t\tif(r.l > 8.)\n\t\t\tbreak;\n\t}\n\treturn vec4(col, r.l);\n}\n\nvec3 normal(vec3 p)\n{\n\tvec2 of = vec2(0.001,0.0);\n\tvec4 copy = geo(p);\n\treturn normalize(copy.w - vec3(geo(p - of.xyy).w, geo(p - of.yxy).w, geo(p - of.yyx).w)); //---Traditional normals\n}\n\nfloat shadows(vec3 ro, vec3 rd, float b)\n{\n\tfloat t = 0.01;\n\tfloat res = 1.0;\n\tfor(int i = 0; i < 32; i++)\n\t{\n\t\tfloat g = geo(ro+rd*t).w;\n\t\tres = min(res, b * g / t); //---Traditional soft shadows\n\t\tt += g;\n\t\tif(g < 0.0005|| g > 3.0)\n        {\n\t\t\tbreak;\n        }\n\t}\n\treturn clamp(res,0.1,1.0);\n}\n\nfloat lighting(vec3 p, vec3 lp)\n{\n\tvec3 lPos = normalize(lp - p); //---Light source & uv position difference\n\tvec3 n = normal(p);\n    \n    float spec = pow(max(dot(lPos, n),0.),80.)*0.2; //---Specular Blinn Phong\n\t\n\tfloat light = clamp(dot(n, lPos), 0.6, 1.); //---Lighter ambient light\n\treturn light * shadows(p, normalize(lp), 1.0) + spec;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy) / iResolution.y;\n\n    ray r;\n\tr.o = vec3(0.);\n\tr.d = vec3(uv, 1.0);\n\tvec4 mm = march(r);\n\n\tvec3 m = r.o + r.d * mm.w;\n\tvec3 lPos = vec3(0.,2.5,1.);\n    #ifdef WALLS_ENABLED\n    #else\n        lPos = vec3(sin(iTime * 1.0)*1.5,1.5,cos(iTime * 1.0)*1.5); //---Light position\n    #endif\n\tvec3 col = mm.rgb * lighting(m, lPos);\n\tcol *= exp(-0.2 * mm.w * mm.w * mm.w * mm.w) *  5.; //---Fog + quick 'fake' gamma\n    if(mm.w > 2.5) col = mix(col, vec3(0.2,0.3,0.8), uv.y-0.1); //---Simple background gradient\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tslyWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[74, 74, 100, 100, 146], [149, 149, 167, 167, 1158], [1160, 1160, 1179, 1179, 1397], [1399, 1399, 1420, 1420, 1587], [1589, 1589, 1631, 1631, 1885], [1887, 1887, 1920, 1920, 2230], [2232, 2232, 2289, 2289, 2869]], "test": "valid"}
{"id": "tssBRr", "name": "Many balls in 1 tweet", "author": "iY0Yi", "description": "https://twitter.com/iY0Yi/status/1253162301705777155?s=20\n\ntwigl.app:\nbit.ly/2VumdtZ", "tags": ["ball", "golf", "1tc"], "likes": 11, "viewed": 271, "published": "Public API", "date": "1587629992", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//* My current...(274 => 259ch): -------------------------------------------------------------\n#define M(p)min((p).y,length(p-vec3(\\\nsin(Q.z),\\\nabs(cos(iTime*7.+Q.z))+.5,\\\ncos(Q.x)\\\n))-.5)\n\nvoid mainImage(out vec4 O, vec2 C)\n{\n    vec3 P,Q,R=iResolution,T;\n    for(;O.w++<99.;T+=M(P)*.5)\n        P=1.-vec3((.5*R.xy-C)/R.y,1)*T,\n        Q=ceil(P/4.)+iTime,\n        P.xz=mod(P.xz,4.)-2.,\n        O+=M(P)<.1?M(P+.2)*.03:0.;\n}\n\n\n/* By iapafoto(244ch): ----------------------------------------------------------------------\n#define M min(P.y,length(P-vec3(sin(Q.z),abs(cos(iTime*6.+Q.z))+.5, cos(Q.x)))-.5)\n#define mainImage(O,C)\\\n\tvec3 Q,R=iResolution,P=R-R+.9,T=P;\\\n    for(;++O.w<3e2;P=T-=vec3(R.xy-C-C,R)/R.y*M*.3,Q=ceil(P/4.)+iTime,P.xz=mod(P.xz,4.)-2.);\\\n    O+=M<.1?P+=.2,M:0.\n//*/\n\n\n\n/* My original w/ spalmer's tips(280 => 274ch): ---------------------------------------------\n#define M(p)min((p).y,length(p+vec3(\\\nsin(iTime+Q.z),\\\n-abs(cos(iTime*7.+Q.z))-.5,\\\ncos(iTime+Q.x)\\\n))-.5)\n\n#define mainImage(O,C){\\\n    vec3 P,Q,R=iResolution;\\\n    for(float T,i=0.;i++<99.;T+=M(P)*.5)\\\n        P=.9-vec3((.5*R.xy-C)/R.y,1)*T,\\\n        Q=ceil(P/4.),\\\n        P.xz=mod(P.xz,4.)-2.,\\\n        O+=M(P)<.1?M(P+.2)*.03:0.;\\\n}\n//*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tssBRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[190, 190, 226, 226, 422]], "test": "valid"}
{"id": "tssBW4", "name": "tunel--otro-v1", "author": "jorge2017a1", "description": "tunel--otro-v1", "tags": ["tunelotrov1"], "likes": 2, "viewed": 68, "published": "Public", "date": "1588279004", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//por jorge2017a1-\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define PI 3.14159265358979323846264\n\n\n#define PI2 6.28318530717\n#define TriplePI (3.0 * PI)\n#define DoublePI (2.0 * PI)\n#define HalfPI (PI / 2.0)\n\nfloat pi = atan(1.0)*4.0;\nfloat tau = atan(1.0)*8.0;\n\n///------------------------------------\nstruct TObj\n{\n    float tipo;\n    float dist;\n    vec3 normal;\n    vec3 ro;\n    vec3 rd;\n    vec2 uv;\n    vec3 color;\n    vec3 p;\n    vec3 path;\n};\n\n\n\n    \nTObj mObj;\nvec3 glpRoRd;\nvec2 gres2;\n\n//-----------------------------------------\n#define MAXREFLECTIONS 2\n#define MAXITER 64\n//-----------------------------------------\nvec3 ambientColor = vec3(0.05, 0.15, 0.2);\nvec3 diffuseColor = vec3(0.2, 0.6, 0.8);\nvec3 specularColor = vec3(1.0, 1.0, 1.0);\nvec3 lightDir = normalize(vec3(0.0, 4.0, 5.0));\nvec3 spherePos = vec3(0.0, 0.5, 0.0);\n//-----------------------------------\n\n\nvec3 light_pos1   ;\nvec3 light_color1 ;\nvec3 light_pos2   ;\nvec3 light_color2 ;\n\n\n\n\n//Torus function\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n//Sphere function\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\n\n// signed\nfloat box(vec3 p, vec3 b)\n{\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n//Triprism function\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n//Cone function\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat cyl(vec3 p, float r, float h) {\n\treturn max(length(p.xz) - r, abs(p.y) - h);\n}\n\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n//---------------------------------------------\n\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) \n{\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); \n    float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, -sa, +.0,\n\t\t+sa, +ca, +.0,\n\t\t+.0, +.0, +1.0);\n}\n\n\n///---------------------------------------------\n\nfloat opU( float d1, float d2 )\n{\n    return min(d2,d2);\n}\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\n\n\n\n    \n//-------------------------------------------------\n\nmat2 rotate(float a) {\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\n//------------------------------------------\n\n\nfloat GetDist(vec3 p  ) \n{\t\n\n      float d;\n    float dif1;\n    float dif2;\n    \n    d=999.9;\n \n    \n   vec3 pp, p2;\n    pp=p;\n    p2=p;\n    \n /*\n    float planeDist1 = p.y-5.0;  //piso inf\n    float planeDist1sup = 20.0-p.y;  //piso sup\n    float planeDist2 = p.x+10.0; //pared izq\n    float planeDist3 = 10.0-p.x;  //pared der\n    float planeDist4 = -p.z+30.0;  //pared atras\n   */\n    \n    vec2 res;\n    res = vec2(9999, 0);\n\n   float anchotubo =8.0;\n   float largotubo =5.0; \n    \n    vec3 pa=rotate_x(p, 1.7); \n    \n    pa.y =pa.y- iTime*6.0;\n    pa.x =pa.x- 2.0*cos(iTime*4.0);\n    pa.z =pa.z- 3.0*sin(iTime*6.0);\n    \n    pa.y =mod(pa.y,8.0)-2.0;\n    \n   float  sdc10= sdCylinder(pa- vec3(0.0,0.0,20.0), vec2(anchotubo,   largotubo+2.5)  );\n   float  sdc11= sdCylinder(pa- vec3(0.0,0.0,20.0), vec2(anchotubo+2.0,largotubo)  );\n   float  sdc21= sdCylinder(pa- vec3(0.0,0.0,12.0), vec2(1.0,largotubo+2.5)  );\t   \n   float  sdc22= sdCylinder(pa- vec3(8.0,0.0,19.0), vec2(1.0,largotubo+2.5)  );\t    \n   float  sdc23= sdCylinder(pa- vec3(-8.0,0.0,19.0), vec2(1.0,largotubo+2.5)  );\n   float  sdc24= sdCylinder(pa- vec3(0.0,0.0,27.0), vec2(1.0,largotubo+2.5)  );\t    \n    \n   \n   float df1=1000.0;\n       \t df1=differenceSDF( sdc11,sdc10);\n   \t\t df1=differenceSDF( df1,sdc21);\n    \t df1=differenceSDF( df1,sdc22);\n    \t df1=differenceSDF( df1,sdc23);\n    \t df1=unionSDF( df1,sdc24);\n\n    //res =opU(res, vec2(df1,5));\n    res =opU(res, vec2(df1,28));\n    \n    \n   res =opU(res, vec2(1.0,6));\n  \n    \n    d = res.x;\n    mObj.dist = res.x;\n    mObj.tipo = res.y;\n    \n    return d;\n}\n\n\n\n///----------------------------------------------------------\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n\tfloat dO=0.2;\n    //Determines size of shadow\n    \n    for(int i=0; i<MAX_STEPS; i++) \n    {\n    \tvec3 p = ro + rd*dO;\n        \n        float dS = GetDist(p);\n        \n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) \n        {\n            //mObj.dist=dO; \t\n            mObj.p=p; \t\n            gres2 = vec2(dO,dS); \n            break;\n    \t}    \n        \n    }\n    \n    return dO;\n}\n\n\n//---------------------------------------------------\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    //Texture of white and black in image\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\n\nfloat GetLightPar(vec3 p, vec3 plig) {\n    vec3 lightPos = plig;\n    //Determine movement of light ex. shadow and light direction and diffusion\n    //lightPos.xz += vec2(1, 2);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l );\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\n\nfloat saturate(float f)\n{\n\treturn clamp(f,0.0,1.0);\n}\n\n    \n\n#define offset1 4.7\n#define offset2 4.6\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) \n{\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\n\n\nvec3 getSphereColor(int i)\n{\n    \n    float m;\n        \n\tif(i==0 )\n    {\n    \n        \n      return vec3(0.0,0.0,0.0);\n    }\n    \n    if(i== 1 )\n    {\n        \n        //return vec3(1, 0.5, 0);\n        \treturn vec3(1.0,0.0,0.0);\n        } \n    if(i== 2 )\n    {\n        //return vec3(1.0, 1.0, 1.0);\n        \treturn vec3(0.0,1.0,0.0);\n        } \n    if(i== 3 )\n    {\n        //return vec3(247./255., 168./255.,  184./255.); \n        \treturn vec3(0.0,0.0,1.0);\n       } \n    if(i== 4 )\n    {\n        \n        //return vec3(0, 1, 1);\n        \treturn vec3(0.0,1.0,1.0);\n        } \n    if(i== 5 )\n    {\n        //return vec3(85./255., 205./255., 252./255.);\n        return vec3(1.0,0.0,1.0);\n        \n        } \n    if(i== 6 )\n    {\n        \n        ///return  vec3(0.5, 0.8, 0.9);\n        return vec3(1.0,0.5,1.0);\n        } \n        \n    if(i== 7 )\n    {\n        return vec3(1.0, 1.0, 1.0);\n       } \n    if(i== 8 )\n    {\n       \n        \n        return vec3(0.425, 0.56, 0.9); \n       } \n    if(i== 9 )\n    {\n        \n        return vec3(0.5, 0.6, 0.6); \n     } \n    if(i== 10 )\n    {\n        return vec3(0.0, 1.0, 0.0);\n    } \n    \n    if(i== 11 )\n    {\n        return vec3(0.25, 0.25, 0.25);\n    } \n    \n     if(i== 15 )\n    {\n    \t\treturn vec3(1.0,0.0,1.);\n       } \n     if(i== 16 )\n    {\n    \t\treturn vec3(1.0,1.0,0.0);\n     } \n    \n    \n    \n    if(i== 21 )\n    {\n     \n        vec3 p = glpRoRd;\n           vec3 marbleP = p;\n    \n    \t\t\n\n            marbleP.x += sin(p.y*20.0)*0.12;\n            marbleP.z += sin(p.y*22.0)*0.1;\n            marbleP.y += sin(p.x*25.0)*0.13;\n            marbleP.y += sin(p.z*23.0)*0.14;\n\n            marbleP.y += sin(p.x*1.3)*0.5;\n            marbleP.y += sin(p.z*1.5)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 20.0;\n            marbleP.z *= 20.0;\n            marbleP.y *= 10.0;\n\n            float marbleAmtA = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtA = pow(1.0-marbleAmtA,5.0);\n\n            marbleP = p;\n\n            marbleP.x += sin(p.y*21.0)*0.12;\n            marbleP.z += sin(p.y*23.0)*0.1;\n            marbleP.y += sin(p.x*22.0)*0.13;\n            marbleP.y += sin(p.z*24.0)*0.14;\n\n            marbleP.y += sin(p.x*1.2)*0.5;\n            marbleP.y += sin(p.z*1.4)*0.6;\n\n            marbleP.x += sin(p.y*150.0)*0.011;\n            marbleP.z += sin(p.y*162.0)*0.013;\n            marbleP.y += sin(p.x*145.0)*0.012;\n            marbleP.y += sin(p.z*153.0)*0.015;\n\n            marbleP.x *= 22.0;\n            marbleP.z *= 23.0;\n            marbleP.y *= 11.0;\n\n            float marbleAmtB = abs(sin(marbleP.x)+sin(marbleP.y)+sin(marbleP.z))/3.0;\n            marbleAmtB = pow(1.0-marbleAmtB,9.0);\n            marbleAmtB = 1.0-(1.0-marbleAmtB*0.3);\n\n            float marbleAmt = marbleAmtA + marbleAmtB;\n            marbleAmt = clamp(marbleAmt,0.0,1.0);\n\t\t\tvec3 surfaceColor;\n            \n    \t\n        \tsurfaceColor = mix(vec3(0.4,0.4,0.6),vec3(0.50,0.1,0.2),marbleAmtA);\n        \n        \treturn surfaceColor;\t\n        \n\t\t\t}  \n    \n    \n    \n     if(i== 23)\n    {\n    \n        \n        return  vec3(0.425, 0.16, 0.6);\t\n        \t\n\t} \n    \n    \n    \n    if(i== 24)\n    {\n      float size = (-mObj.uv.y+.1)/2.5;\n     vec3 color = vec3(0.,0.,0.);\n     color += vec3(mod(floor(mObj.uv.x/size+sin(iTime)) + floor(mObj.uv.y*20./size+iTime),2.)-.8-mObj.uv.y);\n\n     // Lightsource falloff on floor\n     color *= vec3(smoothstep(0.,1.,1.-length(vec2(.2-mObj.uv.x/6.,.6+mObj.uv.y/1.5))));\n        return color;\n\t}    \n    \n    \n    if(i== 25)\n    {\n      float size = (-mObj.p.y+.1)/2.5;\n     vec3 color = vec3(0.,0.,0.);\n     color += vec3(mod(floor(mObj.p.x/size) + floor(mObj.p.y*20./size),2.)-.8-mObj.p.y);\n\n     // Lightsource falloff on floor\n     color *= vec3(smoothstep(0.,1.,1.-length(vec2(.2-mObj.p.x/6.,.6+mObj.p.y/1.5))));\n        return color;\n\t} \n    \n    if(i== 26)\n    {\n        // checkerboard hack\n\t\t\tvec2 cb = floor(mObj.p.xz);\n\t\t\tfloat cb2 = mod(cb.x*1.2 + cb.y, 2.);\n        \treturn vec3(1.4 + 0.1*cb2, 0.3 + 0.85*cb2, 0.35 - 0.3*cb2)*0.8;\n            \n    }   \n    \n    \n    \n    if(i== 27)\n    {\n      vec3 outColor = vec3(0.0);\n      float sinus1 = sin(mObj.uv.x*5.1 +iTime*0.5) * 0.1 - 0.2;\n      float land1 = step(sinus1, mObj.uv.y);\n      vec3 landColor1 = vec3(0.2, 0.4, 0.3);\n      outColor = mix(outColor, landColor1, 1.0 - land1);\n        return outColor;\n    }\n    \n    \n    if (i== 28)\n     {   \n    \tvec3 position=mObj.p;\n        vec3 normal=mObj.normal;\n    \t//position *= scale;\n         position *= 0.25;\n    \t\n    \t//vec3 color = vec3(1.0);\n        vec3 color = vec3(0.98,0.86,0.4);\n    \n    \tcolor = color * 0.75 + 0.25;\n    \tcolor *= normal * .25 + .75;\n    \tfloat checker = sin(position.x * pi * 4.0) * sin(position.y * pi * 4.0) * sin(position.z * pi * 4.0);\n    \tcolor *= step(0.0,checker) * 0.25 + 0.75;\n         return color;\n    }\n    \n    \n    \n}\n\n///--------------------------------------------\n\n\n\n\n\n\n// phong shading\nvec3 p_shadingv2( vec3 v, vec3 n, vec3 eye, vec3 plight_pos1,  vec3 plight_color1 )\n{\n\t// ...add lights here...\n\t\n\tfloat shininess = 16.0;\n\t\n\tvec3 final = vec3( 0.0 );\n\t\n\tvec3 ev = normalize( v - eye );\n\tvec3 ref_ev = reflect( ev, n );\n\t\n\t// light 0\n\t{\n\t\n\t\tvec3 vl = normalize( plight_pos1 - v );\n\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n\t\t\n\t\tfinal += plight_color1 * ( diffuse + specular ); \n\t}\n\t\n\t\n\n    return (final);\n}\n\n\n\n\n//-------------------------------------------\nvec3 Shade(vec3 position, vec3 normal, vec3 direction, vec3 camera)\n{\n    //position *= scale;\n    position *= 0.125;\n    vec3 color = vec3(1.0);\n    \n    color = color * 0.75 + 0.25;\n    \n    color *= normal * .25 + .75;\n    \n    float ambient = 0.1;\n    float diffuse = 0.5 * -dot(normal,direction);\n    float specular = 1.0 * max(0.0, -dot(direction, reflect(direction,normal)));\n    \n    color *= vec3(ambient + diffuse + pow(specular,5.0));\n\n    color *= smoothstep(12.0,6.0,length(position));\n    \n    return color;\n}\n\n///---------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    \n    \n//light_pos1   = vec3( -20.0, -20.0, -20.0 +iTime*2.0);\nlight_pos1   = vec3( -20.0, -20.0, -iTime*2.0);\n light_color1 = vec3( 0.3, 0.2, 1.0 );\n\n light_pos2   = vec3( 20.0,20.0, 20.0 +iTime*2.0 );\n light_color2 = vec3( 1.0, 0.7, 0.7);\n    \n\n    vec3 ro = vec3(0.0,20.0,10.0);\n    \n\t//ro =get_mouse(ro);\n    vec3 rd = normalize( vec3(uv,1.0));\n    \n \n    \n    vec3 col = vec3(0);\n    \n    TObj Obj;\n    \n    mObj.uv=uv;\n    mObj.rd=rd;\n    mObj.ro=ro;\n\n    float d = RayMarch(ro, rd);\n    Obj=mObj;\n    \n  \n    vec3 p = (ro + rd * d ); \n    glpRoRd=p;\n    mObj.p=p;\n    \n    float dif=1.5;\n    \n  \n    \n    mObj.dist =d;\n    vec3 colobj;\n    \n    vec3 nor= GetNormal( p);\n    mObj.normal=nor;\n    colobj=getSphereColor(int( Obj.tipo));\n    \n    \n    \n    \n    \n    vec3 col2=vec3(0.0);\n    col2+= p_shadingv2( p, nor, ro, light_pos1, light_color1 );\n    col2+= p_shadingv2( p, nor, ro, light_pos2, light_color2 );\n    col2=(col2)/2.0;\n    ///col2=(col2+colp1+colp2)/2.0;\n    col2= colobj*col2;\n    col= col2*dif;\n    \n  \n    \n    \n    col = pow(col, vec3(1.0/2.2));  \n    \n    fragColor = vec4(col,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tssBW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[991, 1008, 1041, 1041, 1106], [1128, 1128, 1163, 1163, 1187], [1190, 1205, 1236, 1236, 1386], [1389, 1399, 1426, 1426, 1515], [1517, 1537, 1573, 1573, 1660], [1661, 1677, 1709, 1737, 1798], [1800, 1800, 1836, 1836, 1939], [1941, 1941, 1978, 1978, 2025], [2028, 2028, 2073, 2073, 2164], [2216, 2216, 2262, 2262, 2294], [2296, 2296, 2339, 2339, 2371], [2373, 2373, 2421, 2421, 2454], [2457, 2457, 2486, 2486, 2612], [2614, 2614, 2650, 2650, 2767], [2769, 2769, 2805, 2805, 2923], [2926, 2926, 2962, 2962, 3085], [3138, 3138, 3171, 3171, 3196], [3197, 3197, 3227, 3227, 3256], [3319, 3319, 3341, 3341, 3408], [3457, 3457, 3483, 3483, 5039], [5106, 5106, 5140, 5140, 5533], [5591, 5591, 5615, 5615, 5847], [5851, 5851, 5889, 5889, 6246], [6249, 6249, 6274, 6274, 6302], [6406, 6450, 6467, 6467, 6538], [6563, 6655, 6681, 6681, 6944], [7003, 7003, 7031, 7031, 12034], [12090, 12107, 12192, 12218, 12626], [12631, 12677, 12746, 12771, 13200], [13202, 13251, 13308, 13308, 14482]], "test": "error"}
{"id": "tssBWn", "name": "HSB explorer", "author": "Francio", "description": "Sets the color of one circle as a function of a point on an HSB map.\n\nBased on the hsb map from https://thebookofshaders.com/06/.", "tags": ["color", "hsb"], "likes": 2, "viewed": 51, "published": "Public", "date": "1588071481", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define TWO_PI          6.283185307179586\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat circle(vec2 coord, vec2 pos, float r, float edge){\n    vec2 tc = pos - coord;\n    float radius = length(tc);\n    float circle = 1. - smoothstep(r, r+edge, radius);\n    return circle;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.);\n\n    uv *=2.2;\n    uv.y -= 0.55;\n    \n    vec2 toCenter = -uv;\n    float angle = atan(toCenter.y,toCenter.x);\n    float radius = length(toCenter)*2.0;\n\n    // Map the angle (-PI to PI) to the Hue (from 0 to 1)\n    // and the Saturation to the radius\n    col = hsb2rgb(vec3((angle/TWO_PI)+0.5,radius,1.0));\n    float circle_shape = circle(uv,vec2(0.),0.5,0.01);\n    col*=circle_shape;\n\n    //Modify these lines to change hue and saturation values\n    float h = fract(iTime/5.);\n    float s = 0.4*(1.+ sin(iTime/4.));\n    \n    //Draw point on map\n    float r = s/2.;\n    float ang = h*TWO_PI;\n    vec2 center = r*vec2(cos(ang),sin(ang));\n    float point = circle(uv, center, 0.02, 0.01);\n    col += point;\n\n    //Draw circle with color\n    uv.y +=1.1;\n    circle_shape = circle(uv,vec2(0.),0.5,0.01);\n    col +=circle_shape*hsb2rgb(vec3(h,s,1.0));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tssBWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 163, 189, 189, 422], [424, 424, 480, 480, 614], [616, 616, 673, 673, 1661]], "test": "valid"}
{"id": "tsScDG", "name": "Volumetric Raymarching Sample", "author": "suyoku", "description": "Simple-ish volume raymeracher. Use the mouse to move the camera around.\n\nSet PERFORMANCE_MODE 1 if you want to run this on slower hardware (laptop or phone)", "tags": ["volume"], "likes": 102, "viewed": 5672, "published": "Public API", "date": "1587658223", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Christopher Wallis\n#define PI 3.14\n\n#define NUM_LIGHTS 3\n#define NUM_LIGHT_COLORS 3\n\n#define CHECKER_FLOOR_MATERIAL_ID 0\n#define LIGHT_BASE_MATERIAL_ID 1\n#define NUM_MATERIALS (LIGHT_BASE_MATERIAL_ID + NUM_LIGHTS)\n\n#define PERFORMANCE_MODE 0\n\n#define INVALID_MATERIAL_ID int(-1)\n#define LARGE_NUMBER 1e20\n#define EPSILON 0.0001\n#define MAX_SDF_SPHERE_STEPS 15\n#define ABSORPTION_COEFFICIENT 0.5\n#define CAST_VOLUME_SHADOW_ON_OPAQUES 1\n\n#if PERFORMANCE_MODE\n#define MAX_VOLUME_MARCH_STEPS 20\n#define MAX_VOLUME_LIGHT_MARCH_STEPS 4\n#define ABSORPTION_CUTOFF 0.25\n#define MARCH_MULTIPLIER 1.8\n#define LIGHT_ATTENUATION_FACTOR 2.0\n#define MAX_OPAQUE_SHADOW_MARCH_STEPS 10\n#else\n#define MAX_VOLUME_MARCH_STEPS 50\n#define MAX_VOLUME_LIGHT_MARCH_STEPS 25\n#define ABSORPTION_CUTOFF 0.01\n#define MARCH_MULTIPLIER 1.0\n#define LIGHT_ATTENUATION_FACTOR 1.65\n#define MAX_OPAQUE_SHADOW_MARCH_STEPS 25\n#endif\n\n#define UNIFORM_FOG_DENSITY 0\n#define UNIFORM_LIGHT_SPEED 1\n\nstruct CameraDescription\n{\n    vec3 Position;\n    vec3 LookAt;    \n\n    float LensHeight;\n    float FocalDistance;\n};\n    \nstruct OrbLightDescription\n{\n    vec3 Position;\n    float Radius;\n    vec3 LightColor;\n};\n    \nCameraDescription Camera = CameraDescription(\n    vec3(0, 70, -165),\n    vec3(0, 5, 0),\n    2.0,\n    7.0\n);\n\nvec3 GetLightColor(int lightIndex)\n{\n    switch(lightIndex % NUM_LIGHT_COLORS)\n    {\n        case 0: return vec3(1, 0.0, 1.0);\n        case 1: return vec3(0, 1.0, 0.0);\n    }\n    return vec3(0, 0.0, 1.0);\n}\n\nOrbLightDescription GetLight(int lightIndex)\n{\n    const float lightMultiplier = 17.0f;\n#if UNIFORM_LIGHT_SPEED\n    float theta = iTime * 0.7 + float(lightIndex) * PI * 2.0 / float(NUM_LIGHT_COLORS);\n    float radius = 18.5f;\n#else\n    float theta = iTime * 0.4 * (float(lightIndex) + 1.0f);\n    float radius = 19.0f + float(lightIndex) * 2.0;\n#endif\n    \n    OrbLightDescription orbLight;\n    orbLight.Position = vec3(radius * cos(theta), 6.0 + sin(theta * 2.0) * 2.5, radius * sin(theta));\n    orbLight.LightColor = GetLightColor(lightIndex) * lightMultiplier;\n    orbLight.Radius = 0.8f;\n\n    return orbLight;\n}\n\nfloat GetLightAttenuation(float distanceToLight)\n{\n    return 1.0 / pow(distanceToLight, LIGHT_ATTENUATION_FACTOR);\n}\n    \n// --------------------------------------------//\n//               Noise Functions\n// --------------------------------------------//\n// Taken from Inigo Quilez's Rainforest ShaderToy:\n// https://www.shadertoy.com/view/4ttSWf\nfloat hash1( float n )\n{\n    return fract( n*17.0*fract( n*0.3183099 ) );\n}\n\n// Taken from Inigo Quilez's Rainforest ShaderToy:\n// https://www.shadertoy.com/view/4ttSWf\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    \n    float n = p.x + 317.0*p.y + 157.0*p.z;\n    \n    float a = hash1(n+0.0);\n    float b = hash1(n+1.0);\n    float c = hash1(n+317.0);\n    float d = hash1(n+318.0);\n    float e = hash1(n+157.0);\n\tfloat f = hash1(n+158.0);\n    float g = hash1(n+474.0);\n    float h = hash1(n+475.0);\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z);\n}\n\nconst mat3 m3  = mat3( 0.00,  0.80,  0.60,\n                      -0.80,  0.36, -0.48,\n                      -0.60, -0.48,  0.64 );\n\n// Taken from Inigo Quilez's Rainforest ShaderToy:\n// https://www.shadertoy.com/view/4ttSWf\nfloat fbm_4( in vec3 x )\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=min(0, iFrame); i<4; i++ )\n    {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        x = f*m3*x;\n    }\n\treturn a;\n}\n\n// Taken from https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\n// Taken from https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\n// Taken from https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSmoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nvec3 Translate(vec3 pos, vec3 translate)\n{\n    return pos -= translate;\n}\n\n// Taken from https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere( vec3 p, vec3 origin, float s )\n{\n  p = Translate(p, origin);\n  return length(p)-s;\n}\n\n#define MATERIAL_IS_LIGHT_SOURCE 0x1\nstruct Material\n{\n    vec3 albedo;\n    int flags;\n};\n    \nMaterial NormalMaterial(vec3 albedo, int flags)\n{\n    return Material(albedo, flags);\n}\n\nbool IsLightSource(in Material m)\n{\n    return (m.flags & MATERIAL_IS_LIGHT_SOURCE) != 0;\n}\n\nMaterial GetMaterial(int materialID, vec3 position)\n{\n    Material materials[NUM_MATERIALS];\n\tmaterials[CHECKER_FLOOR_MATERIAL_ID] = NormalMaterial(vec3(0.6, 0.6, 0.7), 0);\n    for(int lightIndex = 0; lightIndex < NUM_LIGHTS; lightIndex++)\n    {\n        materials[LIGHT_BASE_MATERIAL_ID + lightIndex] = NormalMaterial(GetLight(lightIndex).LightColor, MATERIAL_IS_LIGHT_SOURCE);\n    }\n    \n    Material mat;\n    if(materialID < int(NUM_MATERIALS))\n    {\n        mat = materials[materialID];\n    }\n    else\n    {\n        // Should never get hit\n   \t\treturn materials[0];\n    }\n    \n    if(materialID == CHECKER_FLOOR_MATERIAL_ID)\n    {\n        vec2 uv = position.xz / 13.0;\n        uv = vec2(uv.x < 0.0 ? abs(uv.x) + 1.0 : uv.x, uv.y < 0.0 ? abs(uv.y) + 1.0 : uv.y);\n        if((int(uv.x) % 2 == 0 && int(uv.y) % 2 == 0) || (int(uv.x) % 2 == 1 && int(uv.y) % 2 == 1))\n        {\n            mat.albedo = vec3(1, 1, 1) * 0.7;\n        }\n    }\n\n    return mat;    \n}\n\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-plane-and-ray-disk-intersection\nfloat PlaneIntersection(vec3 rayOrigin, vec3 rayDirection, vec3 planeOrigin, vec3 planeNormal, out vec3 normal) \n{ \n    float t = -1.0f;\n    normal = planeNormal;\n    float denom = dot(-planeNormal, rayDirection); \n    if (denom > EPSILON) { \n        vec3 rayToPlane = planeOrigin - rayOrigin; \n        return dot(rayToPlane, -planeNormal) / denom; \n    } \n \n    return t; \n} \n    \nfloat SphereIntersection(\n    in vec3 rayOrigin, \n    in vec3 rayDirection, \n    in vec3 sphereCenter, \n    in float sphereRadius, \n    out vec3 normal)\n{\n      vec3 eMinusC = rayOrigin - sphereCenter;\n      float dDotD = dot(rayDirection, rayDirection);\n\n      float discriminant = dot(rayDirection, (eMinusC)) * dot(rayDirection, (eMinusC))\n         - dDotD * (dot(eMinusC, eMinusC) - sphereRadius * sphereRadius);\n\n      if (discriminant < 0.0) \n         return -1.0;\n\n      float firstIntersect = (dot(-rayDirection, eMinusC) - sqrt(discriminant))\n             / dDotD;\n      \n      float t = firstIntersect;\n    \n      normal = normalize(rayOrigin + rayDirection * t - sphereCenter);\n      return t;\n}\n\n\nvoid UpdateIfIntersected(\n    inout float t,\n    in float intersectionT, \n    in vec3 intersectionNormal,\n    in int intersectionMaterialID,\n    out vec3 normal,\n    out int materialID\n\t)\n{    \n    if(intersectionT > EPSILON && intersectionT < t)\n    {\n\t\tnormal = intersectionNormal;\n        materialID = intersectionMaterialID;\n        t = intersectionT;\n    }\n}\n\nfloat IntersectOpaqueScene(in vec3 rayOrigin, in vec3 rayDirection, out int materialID, out vec3 normal)\n{\n    float intersectionT = LARGE_NUMBER;\n    vec3 intersectionNormal = vec3(0, 0, 0);\n\n    float t = LARGE_NUMBER;\n    normal = vec3(0, 0, 0);\n    materialID = INVALID_MATERIAL_ID;\n\n    for(int lightIndex = 0; lightIndex < NUM_LIGHTS; lightIndex++)\n    {\n        UpdateIfIntersected(\n            t,\n            SphereIntersection(rayOrigin, rayDirection, GetLight(lightIndex).Position, GetLight(lightIndex).Radius, intersectionNormal),\n            intersectionNormal,\n            LIGHT_BASE_MATERIAL_ID + lightIndex,\n            normal,\n            materialID);\n    }\n\n    \n    UpdateIfIntersected(\n        t,\n        PlaneIntersection(rayOrigin, rayDirection, vec3(0, 0, 0), vec3(0, 1, 0), intersectionNormal),\n        intersectionNormal,\n        CHECKER_FLOOR_MATERIAL_ID,\n        normal,\n        materialID);\n\n    \n    return t;\n}\n\nfloat QueryVolumetricDistanceField( in vec3 pos)\n{    \n    // Fuse a bunch of spheres, slap on some fbm noise, \n    // merge it with ground plane to get some ground fog \n    // and viola! Big cloudy thingy!\n    vec3 fbmCoord = (pos + 2.0 * vec3(iTime, 0.0, iTime)) / 1.5f;\n    float sdfValue = sdSphere(pos, vec3(-8.0, 2.0 + 20.0 * sin(iTime), -1), 5.6);\n    sdfValue = sdSmoothUnion(sdfValue,sdSphere(pos, vec3(8.0, 8.0 + 12.0 * cos(iTime), 3), 5.6), 3.0f);\n    sdfValue = sdSmoothUnion(sdfValue, sdSphere(pos, vec3(5.0 * sin(iTime), 3.0, 0), 8.0), 3.0) + 7.0 * fbm_4(fbmCoord / 3.2);\n    sdfValue = sdSmoothUnion(sdfValue, sdPlane(pos + vec3(0, 0.4, 0)), 22.0);\n    return sdfValue;\n}\n\nfloat IntersectVolumetric(in vec3 rayOrigin, in vec3 rayDirection, float maxT)\n{\n    // Precision isn't super important, just want a decent starting point before \n    // ray marching with fixed steps\n\tfloat precis = 0.5; \n    float t = 0.0f;\n    for(int i=0; i<MAX_SDF_SPHERE_STEPS; i++ )\n    {\n\t    float result = QueryVolumetricDistanceField( rayOrigin+rayDirection*t);\n        if( result < (precis) || t>maxT ) break;\n        t += result;\n    }\n    return ( t>=maxT ) ? -1.0 : t;\n}\n\nvec3 Diffuse(in vec3 normal, in vec3 lightVec, in vec3 diffuse)\n{\n    float nDotL = dot(normal, lightVec);\n    return clamp(nDotL * diffuse, 0.0, 1.0);\n}\n\nvec3 GetAmbientLight()\n{\n\treturn 1.2 * vec3(0.03, 0.018, 0.018);\n}\n\nfloat GetFogDensity(vec3 position, float sdfDistance)\n{\n    const float maxSDFMultiplier = 1.0;\n    bool insideSDF = sdfDistance < 0.0;\n    float sdfMultiplier = insideSDF ? min(abs(sdfDistance), maxSDFMultiplier) : 0.0;\n \n#if UNIFORM_FOG_DENSITY\n    return sdfMultiplier;\n#else\n   return sdfMultiplier * abs(fbm_4(position / 6.0) + 0.5);\n#endif\n}\n\nfloat BeerLambert(float absorption, float dist)\n{\n    return exp(-absorption * dist);\n}\n\nfloat GetLightVisiblity(in vec3 rayOrigin, in vec3 rayDirection, in float maxT, in int maxSteps, in float marchSize)\n{\n    float t = 0.0f;\n    float lightVisibility = 1.0f;\n    float signedDistance = 0.0;\n    for(int i = 0; i < maxSteps; i++)\n    {                       \n        t += max(marchSize, signedDistance);\n        if(t > maxT || lightVisibility < ABSORPTION_CUTOFF) break;\n\n        vec3 position = rayOrigin + t*rayDirection;\n\n        signedDistance = QueryVolumetricDistanceField(position);\n        if(signedDistance < 0.0)\n        {\n            lightVisibility *= BeerLambert(ABSORPTION_COEFFICIENT * GetFogDensity(position, signedDistance), marchSize);\n        }\n    }\n    return lightVisibility;\n}\n\n\nfloat Luminance(vec3 color)\n{\n    return (color.r * 0.3) + (color.g * 0.59) + (color.b * 0.11);\n}\n\nbool IsColorInsignificant(vec3 color)\n{\n    const float minValue = 0.009;\n    return Luminance(color) < minValue;\n}\n\nvoid CalculateLighting(vec3 position, vec3 normal, vec3 reflectionDirection, Material material, inout vec3 color)\n{\n    for(int lightIndex = 0; lightIndex < NUM_LIGHTS; lightIndex++)\n    {\n        vec3 lightDirection = (GetLight(lightIndex).Position - position);\n        float lightDistance = length(lightDirection);\n        lightDirection /= lightDistance;\n\n        vec3 lightColor = GetLight(lightIndex).LightColor * GetLightAttenuation(lightDistance); \n\n        float lightVisiblity = 1.0;\n        #if CAST_VOLUME_SHADOW_ON_OPAQUES\n        if(!IsColorInsignificant(lightColor))\n        {\n            const float shadowMarchSize = 0.65f * MARCH_MULTIPLIER;\n            lightVisiblity = GetLightVisiblity(position, lightDirection, lightDistance, MAX_OPAQUE_SHADOW_MARCH_STEPS, shadowMarchSize); \n        }\n        #endif\n        \n        color += lightVisiblity * lightColor * pow(max(dot(reflectionDirection, lightDirection), 0.0), 4.0);\n        color += lightVisiblity * lightColor * Diffuse(normal, lightDirection, material.albedo);\n    \n    }\n    color += GetAmbientLight() * material.albedo;\n}\n\nvec3 Render( in vec3 rayOrigin, in vec3 rayDirection)\n{\n    float depth = LARGE_NUMBER;\n    vec3 opaqueColor = vec3(0.0f);\n    \n    vec3 normal;\n    float t;\n    int materialID = INVALID_MATERIAL_ID;\n    t = IntersectOpaqueScene(rayOrigin, rayDirection, materialID, normal);\n    if( materialID != INVALID_MATERIAL_ID )\n    {\n        // Defer lighting calculations after volume lighting so we can \n        // avoid doing shadow tracing on opaque objects that aren't visible anyways\n        depth = t;\n    }\n    \n    float volumeDepth = IntersectVolumetric(rayOrigin, rayDirection, depth);\n    float opaqueVisiblity = 1.0f;\n    vec3 volumetricColor = vec3(0.0f);\n    if(volumeDepth > 0.0)\n    {\n        const vec3 volumeAlbedo = vec3(0.8);\n        const float marchSize = 0.6f * MARCH_MULTIPLIER;\n        float distanceInVolume = 0.0f;\n        float signedDistance = 0.0;\n        for(int i = 0; i < MAX_VOLUME_MARCH_STEPS; i++)\n        {\n            volumeDepth += max(marchSize, signedDistance);\n            if(volumeDepth > depth || opaqueVisiblity < ABSORPTION_CUTOFF) break;\n            \n            vec3 position = rayOrigin + volumeDepth*rayDirection;\n\n            signedDistance = QueryVolumetricDistanceField(position);\n\t\t\tif(signedDistance < 0.0f)\n            {\n                distanceInVolume += marchSize;\n                float previousOpaqueVisiblity = opaqueVisiblity;\n                opaqueVisiblity *= BeerLambert(ABSORPTION_COEFFICIENT * GetFogDensity(position, signedDistance), marchSize);\n                float absorptionFromMarch = previousOpaqueVisiblity - opaqueVisiblity;\n                \n                for(int lightIndex = 0; lightIndex < NUM_LIGHTS; lightIndex++)\n    \t\t\t{\n                    float lightVolumeDepth = 0.0f;\n                    vec3 lightDirection = (GetLight(lightIndex).Position - position);\n                    float lightDistance = length(lightDirection);\n                    lightDirection /= lightDistance;\n                    \n                    vec3 lightColor = GetLight(lightIndex).LightColor * GetLightAttenuation(lightDistance); \n                    if(IsColorInsignificant(lightColor)) continue;\n                    \n                    const float lightMarchSize = 0.65f * MARCH_MULTIPLIER;\n                    float lightVisiblity = GetLightVisiblity(position, lightDirection, lightDistance, MAX_VOLUME_LIGHT_MARCH_STEPS, lightMarchSize); \n                    volumetricColor += absorptionFromMarch * lightVisiblity * volumeAlbedo * lightColor;\n                }\n                volumetricColor += absorptionFromMarch * volumeAlbedo * GetAmbientLight();\n            }\n        }\n    }\n    \n    if( materialID != INVALID_MATERIAL_ID && opaqueVisiblity > ABSORPTION_CUTOFF)\n    {\n        vec3 position = rayOrigin + t*rayDirection;\n        Material material = GetMaterial(materialID, position);\n\t\tif(IsLightSource(material))\n        {\n            opaqueColor = min(material.albedo, vec3(1.0));\n        }       \n        else\n        {\n    \t    vec3 reflectionDirection = reflect( rayDirection, normal);\n\t        CalculateLighting(position, normal, reflectionDirection, material, opaqueColor);\n        }\n    }\n    \n    return min(volumetricColor, 1.0f) + opaqueVisiblity * opaqueColor;\n}\n\nmat3 GetViewMatrix(float xRotationFactor)\n{ \n   float xRotation = ((1.0 - xRotationFactor) - 0.5) * PI * 0.4 + PI * 0.25;\n   return mat3( cos(xRotation), 0.0, sin(xRotation),\n                0.0,           1.0, 0.0,    \n                -sin(xRotation),0.0, cos(xRotation));\n}\n\nfloat GetCameraPositionYOffset()\n{\n    return 100.0 * (iMouse.y / iResolution.y);\n}\n\nfloat GetRotationFactor()\n{\n    return iMouse.x / iResolution.x;\n}\n\nvec3 GammaCorrect(vec3 color) \n{\n    return pow(color, vec3(1.0/2.2));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float aspectRatio = iResolution.x /  iResolution.y; \n    float lensWidth = Camera.LensHeight * aspectRatio;\n    \n    vec3 CameraPosition = Camera.Position + GetCameraPositionYOffset();\n    \n    vec3 NonNormalizedCameraView = Camera.LookAt - CameraPosition;\n    float ViewLength = length(NonNormalizedCameraView);\n    vec3 CameraView = NonNormalizedCameraView / ViewLength;\n\n    vec3 lensPoint = CameraPosition;\n    \n    // Pivot the camera around the look at point\n    {\n        float rotationFactor = GetRotationFactor();\n        mat3 viewMatrix = GetViewMatrix(rotationFactor);\n        CameraView = CameraView * viewMatrix;\n        lensPoint = Camera.LookAt - CameraView * ViewLength;\n    }\n    \n    // Technically this could be calculated offline but I like \n    // being able to iterate quickly\n    vec3 CameraRight = cross(CameraView, vec3(0, 1, 0));    \n    vec3 CameraUp = cross(CameraRight, CameraView);\n\n    vec3 focalPoint = lensPoint - Camera.FocalDistance * CameraView;\n    lensPoint += CameraRight * (uv.x * 2.0 - 1.0) * lensWidth / 2.0;\n    lensPoint += CameraUp * (uv.y * 2.0 - 1.0) * Camera.LensHeight / 2.0;\n    \n    vec3 rayOrigin = focalPoint;\n    vec3 rayDirection = normalize(lensPoint - focalPoint);\n    \n    vec3 color = Render(rayOrigin, rayDirection);\n    fragColor=vec4( GammaCorrect(clamp(color, 0.0, 1.0)), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsScDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1297, 1297, 1333, 1333, 1503], [2121, 2121, 2171, 2171, 2238], [2244, 2469, 2493, 2493, 2544], [2546, 2638, 2664, 2664, 3392], [3526, 3618, 3644, 3644, 3869], [3871, 3953, 3978, 3978, 3993], [3995, 4077, 4107, 4107, 4140], [4142, 4224, 4277, 4277, 4377], [4379, 4379, 4421, 4421, 4452], [4454, 4536, 4584, 4584, 4636], [4733, 4733, 4782, 4782, 4820], [4822, 4822, 4857, 4857, 4913], [5877, 6016, 6130, 6130, 6391], [6398, 6398, 6552, 6552, 7104], [7107, 7107, 7296, 7296, 7470], [7472, 7472, 7578, 7578, 8411], [8413, 8413, 8463, 8619, 9099], [9101, 9101, 9181, 9300, 9585], [9587, 9587, 9652, 9652, 9740], [9742, 9742, 9766, 9766, 9808], [9810, 9810, 9865, 9865, 10157], [10159, 10159, 10208, 10208, 10246], [10248, 10248, 10366, 10366, 10960], [10963, 10963, 10992, 10992, 11060], [11062, 11062, 11101, 11101, 11177], [11179, 11179, 11294, 11294, 12278], [12280, 12280, 12335, 12335, 15519], [15521, 15521, 15564, 15564, 15796], [15798, 15798, 15832, 15832, 15881], [15883, 15883, 15910, 15910, 15949], [15951, 15951, 15983, 15983, 16023], [16025, 16025, 16082, 16082, 17480]], "test": "error"}
{"id": "tsscDs", "name": "Day 106", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 4, "viewed": 246, "published": "Public API", "date": "1585908235", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi acos(-1.)\n#define tau (2.*pi)\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\n#define timeStep (1./30.)\n#define motionBlurSteps 100\n\n// USING YX/LUNA'S AWESOME DITHERED MOTION BLUR - https://www.shadertoy.com/view/wsfcWX\n// I modified it to not be framerate dependent like the original.\n\n\nfloat bayer8(ivec2 uv)\n{   \n    uv %= 8;\n\treturn texelFetch(iChannel1,uv,0).r;\n}\n\n// from https://necessarydisorder.wordpress.com/\nfloat ease(float p, float g) {\n    if(p < 0.){\n        return 0.;\n    } else if(p > 1.){\n    \treturn 1.;\n    } else {\n        if (p < 0.5) \n            return 0.5 * pow(2.*p, g);\n        else\n            return 1. - 0.5 * pow(2.*(1. - p), g);\n    }\n}\n\nfloat ease(float p, float power, float jump, float offs, float end) {\n    float j = p;\n    p *= offs;\n    float r = (1.-cos(pi*p))/2.*jump;\n    r = pow(r, power);\n    r = mix(r, 1., pow(smoothstep(0.,1.,j),end));\n\treturn r;\n}\n\nvec3 get(  vec2 uv, float t, inout float edge )\n{\n    \n    float modD = 3.;\n    \n    t *= 1.;\n    t = mod(t, 1.);\n    vec3 col = vec3(0);\n\n    vec2 uvv = uv * 1.9;\n    //uv *= 1. - dot(uvv,uvv)*0.1;\n    \n    uv *= 1.;\n    \n    edge = dFdx(uv.x)*(1. + exp(-length(uv)*30.)*2500.);    \n    float dpp = dot(uv,uv);\n    \n    uv /= dpp;\n    \n    uv.y +=  (floor(t) + ease(fract(t), 3.))*modD*modD + modD*2.;\n    //uv.x += t;\n    \n    vec2 id = floor(mod(uv/modD, modD));\n    uv = mod(uv,modD) - modD*0.5;\n    //uv = sin(uv*22./8./2.);\n\n    \n    float d = length(uv) - modD*0.2;\n    if(id.y < 1. || mod(abs(id.x), 2.) == 1.)\n    \tcol = vec3(d);\n    else \n        col = vec3(10);    \n    //col = vec3\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;  \n    vec3 col = vec3(0.);\n    \n    \n    float e = 0.;\n    for (int i = 0; i < motionBlurSteps  ; ++i) {\n        float subsample = bayer8(ivec2(fragCoord));\n        float time = iTime + ((float(i)+subsample)/float(motionBlurSteps)-.5) * timeStep;\n        float edge;\n        vec3 d = get(uv,time, edge);\n        col += smoothstep(-edge,edge,-d);\n        e += exp(-abs(d.x)*40.);\n    }\n    col/=float(motionBlurSteps);\n    e/=float(motionBlurSteps);\n    \n    col *= 0.999;\n    \n    \n    \n    col *= 1. - exp(-length(uv)*100.)*2.;\n    col *= vec3(2.,0.4,0.1);\n    \n    col.gb -= e;\n    col = clamp(col, 0., 1.);\n    col = mix(col, vec3(0.06,0.1,0.4)*0.02, smoothstep(1.,0.,length(col)*1.));\n    \n    //col *= max((1. + 1.*cos(sin(0.25*tau*iTime)*tau+length(uv)*2.+vec3(4,2.5,1.5)))*1., 0.);\n    //col *= max((1.5 + 1.4*cos(iTime+length(uv)*2.+vec3(1,1.5,1.5)))*1., 0.);\n    \n    \n    \n    \n    col *= 1. - pow(smoothstep(0.,1.,length(uv)*1.),1.)*1.;\n    \n    col = pow(col, vec3(0.454545));\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsscDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[303, 303, 327, 327, 383], [385, 434, 464, 464, 684], [686, 686, 755, 755, 911], [913, 913, 962, 962, 1629]], "test": "error"}
{"id": "tsScRK", "name": "another synthwave sunset thing", "author": "stduhpf", "description": "I was thinking of a way to make pseudo tesselation noise and i made this to illustrate it, i might not be the first one to come up with this solution.", "tags": ["raymarching", "sunset", "tesselation", "synthwave", "cineshader"], "likes": 20, "viewed": 2541, "published": "Public API", "date": "1587042330", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#define VAPORWAVE\n//#define AA 2 //The antialiasing breaks the stars, because those are just fancy aliasing\n//#define stereo\n\nfloat jTime;\n\nfloat amp(vec2 p){\n    return smoothstep(1.,8.,abs(p.x));\n    \n}\nfloat pow512(float a){\n    a*=a;//^2\n    a*=a;//^4\n    a*=a;//^8\n    a*=a;//^16\n    a*=a;//^32\n    a*=a;//^64\n    a*=a;//^128\n    a*=a;//^256\n    return a*a;\n}\nfloat pow1d5(float a){\n    return a*sqrt(a);\n}\nfloat hash21(vec2 co){\n    return fract(sin(dot(co.xy,vec2(1.9898,7.233)))*45758.5433);\n}\nfloat hash(vec2 uv){\n    float a = amp(uv);\n    float w = a>0.?(1.-.4*pow512(.51+.49*sin((.02*(uv.y+.5*uv.x)-jTime)*2.))):0.;\n    return a>0.?\n        a*pow1d5(\n        //texture(iChannel0,uv/iChannelResolution[0].xy).r\n        hash21(uv)\n        )*w\n        :0.;\n}\n\nvec2 trinoise(vec2 uv){\n    const float sq = sqrt(3./2.);\n    uv.x *= sq;\n    uv.y -= .5*uv.x;\n    vec2 d = fract(uv);\n    uv -= d;\n    if(dot(d,vec2(1))<1.){\n        float n1 = hash(uv);\n        float n2 = hash(uv+vec2(1,0));\n        float n3 = hash(uv+vec2(0,1));\n        float nmid = mix(n2,n3,d.y);\n        float ng = mix(n1,n3,d.y);\n        float dx = d.x/(1.-d.y);\n        return vec2(mix(ng,nmid,dx),min(min((1.-dx)*(1.-d.y),d.x),d.y));\n\t}else{\n    \tfloat n2 = hash(uv+vec2(1,0));\n        float n3 = hash(uv+vec2(0,1));\n        float n4 = hash(uv+1.);\n        float nmid = mix(n2,n3,d.y);\n        float nd = mix(n2,n4,d.y);\n        float dx = (1.-d.x)/(d.y);\n        return vec2(mix(nd,nmid,dx),min(min((1.-dx)*d.y,1.-d.x),1.-d.y));\n\t}\n    return vec2(0);\n}\n\n\nvec2 map(vec3 p){\n    vec2 n = trinoise(p.xz);\n    return vec2(p.y-2.*n.x,n.y);\n}\n\nvec3 grad(vec3 p){\n    const vec2 e = vec2(.005,0);\n    float a =map(p).x;\n    return vec3(map(p+e.xyy).x-a\n                ,map(p+e.yxy).x-a\n                ,map(p+e.yyx).x-a)/e.x;\n\n}\n\nvec2 intersect(vec3 ro,vec3 rd){\n    float d =0.,h=0.;\n    for(int i = 0;i<500;i++){\n        vec3 p = ro+d*rd;\n        vec2 s = map(p);\n        h = s.x;\n        d+= h*.5;\n        if(abs(h)<.003*d)\n            return vec2(d,s.y);\n        if(d>150.|| p.y>2.) break;\n    }\n    \n    return vec2(-1);\n}\n\n\nvec3 sun(vec3 rd,vec3 ld,vec3 base){\n    \n\tfloat sun = smoothstep(.21,.2,distance(rd,ld));\n    \n    if(sun>0.){\n        float yd = (rd.y-ld.y);\n\n        float a =sin(3.1*exp(-(yd)*14.)); \n\n        sun*=smoothstep(-.8,0.,a);\n\n        base = mix(base,vec3(1.,.8,.4)*.75,sun);\n    }\n    return base;\n}\nvec3 gsky(vec3 rd,vec3 ld,bool mask){\n    float haze = exp2(-5.*(abs(rd.y)-.2*dot(rd,ld)));\n    //float st = mask?pow512(texture(iChannel0,(rd.xy+vec2(300.1,100)*rd.z)*10.).r)*(1.-min(haze,1.)):0.;\n    float st = mask?pow512(hash21((rd.xy+vec2(300.1,100)*rd.z)*10.))*(1.-min(haze,1.)):0.;\n    vec3 col=clamp(mix(vec3(.4,.1,.7),vec3(.7,.1,.4),haze)+st,0.,1.);\n    return mask?sun(rd,ld,col):col;\n   \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor=vec4(0);\n    #ifdef AA\n    for(float x = 0.;x<1.;x+=1./float(AA)){\n    for(float y = 0.;y<1.;y+=1./float(AA)){\n    #else\n        const float AA=1.,x=0.,y=0.;\n    #endif\n    vec2 uv = (2.*(fragCoord+vec2(x,y))-iResolution.xy)/iResolution.x;\n    \n\t//float dt = fract(texture(iChannel0,float(AA)*(fragCoord+vec2(x,y))/iChannelResolution[0].xy).r+iTime);\n    float dt = fract(hash21(float(AA)*(fragCoord+vec2(x,y)))+iTime);\n    jTime = mod(iTime-dt*iTimeDelta*.25,4000.);\n    vec3 ro = vec3(0.,1,(-2000.+jTime)*10.);\n    \n        #ifdef stereo\n            ro+=vec3(.2*(float(uv.x>0.)-.5),0.,0.);\n            uv.x=uv.x+.5*(uv.x>0.?-1.:1.);\n            uv*=2.;\n\t\t#endif\n        \n    vec3 rd = normalize(vec3(uv,.75));//vec3(uv,sqrt(1.-dot(uv,uv)));\n    \n    vec2 i = intersect(ro,rd);\n    float d = i.x;\n    \n    vec3 ld = normalize(vec3(0,.125+.05*sin(.1*jTime),1));\n\n    float fog = d>0.?exp2(-d*.14):0.;\n    vec3 sky = gsky(rd,ld,d<0.);\n    \n    vec3 p = ro+d*rd;\n    vec3 n = normalize(grad(p));\n    \n    float diff = dot(n,ld)+.1*n.y;\n    vec3 col = vec3(.1,.11,.18)*diff;\n    \n    vec3 rfd = reflect(rd,n); \n    vec3 rfcol = gsky(rfd,ld,true);\n    \n    col = mix(col,rfcol,.05+.95*pow(max(1.+dot(rd,n),0.),5.));\n    #ifdef VAPORWAVE\n    col = mix(col,vec3(.4,.5,1.),smoothstep(.05,.0,i.y));\n    col = mix(sky,col,fog);\n    col = sqrt(col);\n    #else\n    col = mix(col,vec3(.8,.1,.92),smoothstep(.05,.0,i.y));\n    col = mix(sky,col,fog);\n    //no gamma for that old cg look\n    #endif\n    if(d<0.)\n        d=1e6;\n    d=min(d,10.);\n    fragColor += vec4(clamp(col,0.,1.),d<0.?0.:.1+exp2(-d));\n     #ifdef AA\n    }\n    }\n    fragColor/=float(AA*AA);\n    #endif\n    \n}\n\n/** SHADERDATA\n{\n\t\"title\": \"another synthwave sunset thing\",\n\t\"description\": \"I was thinking of a way to make pseudo tesselation noise and i made this to illustrate it, i might not be the first one to come up with this solution.\",\n\t\"model\": \"car\"\n}\n*/", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsScRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[142, 142, 160, 160, 206], [207, 207, 229, 229, 366], [367, 367, 389, 389, 413], [414, 414, 436, 436, 503], [504, 504, 524, 524, 769], [771, 771, 794, 794, 1535], [1538, 1538, 1555, 1555, 1619], [1621, 1621, 1639, 1639, 1805], [1807, 1807, 1839, 1839, 2104], [2107, 2107, 2143, 2143, 2405], [2406, 2406, 2443, 2443, 2806]], "test": "valid"}
{"id": "tssyDX", "name": "LaserOilSlick", "author": "Reva", "description": "Ex07", "tags": ["fpm"], "likes": 4, "viewed": 82, "published": "Public", "date": "1585765035", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author: Reva 20200402\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n\n// Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n\n#define OCTAVES 1\nfloat fpm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = 0.6;\n    float frequency = 2.0;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * fract(snoise(st+snoise(vec2(st.y+iTime*0.1,st.x))));\n        st *= frequency;\n        amplitude *= .5;\n    }\n    return value;\n}\n\nfloat pattern( in vec2 p, out vec2 q)\n{\n    q.x = fpm( p + vec2(0.240,0.670) );\n    q.y = fpm( p + vec2(5.2,1.3) ) ;\n\n    return fpm( p + q*1.5 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 st = fragCoord.xy/iResolution.y;\n    //st -= vec2(0.5);\n    vec3 color = vec3(0.0);\n    \n    vec2 q = vec2(1.0);\n    float f = pattern(st*1.0,q);\n\n    color = vec3(1.000,0.881,0.631);\n    color = mix(color, vec3(0.243,0.646,0.945),f);\n    color = mix(color, vec3(0.220,0.835,0.352),q.x*q.x);\n    color = mix(color, vec3(0.830,0.626,0.835),q.y*q.y*2.0);\n    color = mix(color, vec3(0.765,0.975,0.928), 0.5*smoothstep(0.368,0.844,abs(q.y)+abs(q.x)) );\n\n    vec2 ex = vec2( 1.0 / iResolution.x, 0.0 );\n    vec2 ey = vec2( 0.0, 1.0 / iResolution.y );\n    vec3 nor = normalize( vec3( fpm(st+ex) - f, ex.x, fpm(st+ey) - f ) );\n        \n    vec3 lig = normalize( vec3(0.8,-0.5,-0.47) );\n    float dif = clamp( 0.9+0.1*dot( nor, lig ), 0.0, 1.0 );\n\n    vec3 bdrf;\n    bdrf  = vec3(0.924,0.965,0.922)*(nor.y*0.5+0.5);\n    bdrf += vec3(0.030,0.036,0.050)*dif;\n    bdrf  = vec3(0.85,0.90,0.95)*(nor.y*0.5+0.5);\n    bdrf += vec3(0.545,0.474,0.351)*dif;\n\n    color *= bdrf;\n    //color = color*color;\n    color *= vec3(1.0,1.0,1.15);\n    vec2 p = fragCoord.xy/iResolution.xy;\n\t color *= 0.5 + 0.5 * sqrt(40.0*p.x*p.y*(1.0-p.x)*(1.0-p.y));\n    \n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tssyDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[73, 98, 119, 119, 166], [167, 167, 188, 188, 235], [236, 236, 258, 258, 293], [295, 616, 638, 691, 2388], [2408, 2408, 2432, 2454, 2759], [2761, 2761, 2800, 2800, 2909], [2911, 2911, 2967, 2967, 4142]], "test": "valid"}
{"id": "tsSyWh", "name": "moyamoya", "author": "tono", "description": "moyamoya", "tags": ["2d", "cell"], "likes": 2, "viewed": 84, "published": "Public", "date": "1586523609", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 random22(vec2 st)\n{\n    st = vec2(dot(st, vec2(127.1, 311.7)),\n                dot(st, vec2(269.5, 183.3))\n                );\n    return -1.0 + 2.0 * fract(sin(st) * 43758.5453123);\n}\n\nvec3 celler2D(vec2 i,vec2 sepc)\n{\n    vec2 sep = i * sepc;\n    vec2 fp = floor(sep);\n    vec2 sp = fract(sep);\n    float dist = 5.;\n    vec2 mp = vec2(0.);\n\n    for (int y = -1; y <= 1; y++)\n    {\n        for (int x = -1; x <= 1; x++)\n        {\n            vec2 neighbor = vec2(x, y);\n            vec2 pos = vec2(random22(fp+neighbor));\n            pos = sin( (pos*6. +iTime/2.) )* 0.5 + 0.5;\n            float divs = length(neighbor + pos - sp);\n            mp = (dist >divs)?pos:mp;\n            dist = (dist > divs)?divs:dist;\n        }\n    }\n    return vec3(mp,dist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tfloat cell = celler2D(uv,vec2(6.5)).z;\n    float celln = 0.;\n    for (int y = -1; y <= 1; y++)\n    {\n        for (int x = -1; x <= 1; x++)\n        {\n            vec2 ne = vec2(x, y);\n            celln +=  celler2D(uv + ne,vec2(6.5)).z;\n        }\n    }\n    cell = smoothstep(cell,celln,2.2);\n    vec3 col = vec3(1.) * sin( cell * 8. + iTime) ;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsSyWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 188], [190, 190, 223, 223, 762], [764, 764, 821, 821, 1238]], "test": "valid"}
{"id": "tsXBD8", "name": "Colorful lines", "author": "tantalum", "description": "Started out trying to distort a checker board pattern with FBM noise, ended up with some colorful contouring lines. ", "tags": ["fbm", "trippy"], "likes": 3, "viewed": 120, "published": "Public", "date": "1588117966", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define TWOPI 6.28318530718\n#define NUM_OCTAVES 3\n\nvec3 g_a = vec3(0.66,0.56,0.68);\nvec3 g_b = vec3(0.718,0.438,0.720);\nvec3 g_c = vec3(0.520,0.8,0.520);\nvec3 g_d = vec3(-0.430,-0.397,-0.083);\n\n//iq's cosine gradient https://www.iquilezles.org/www/articles/palettes/palettes.htm\nvec3 grad( in float t)\n{\n    return g_a + g_b*cos( 6.28318*(g_c*t+g_d) );\n}\n\nfloat random (in vec2 uv) {\n    return fract(sin(dot(uv.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n//From book of shaders ch. 13 https://thebookofshaders.com/13/\nfloat fbm ( in vec2 st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.50));\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        v += a * noise(st);\n        st = rot * st * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    float stime = iDate.w * 0.09;\n    float ctime = iTime * 0.3273;\n    float ttime = iTime * 0.0697;\n    float ptime = iTime * 0.0987;\n    \n    float mx = max(iResolution.x , iResolution.y);\n    \n    vec2 uv = gl_FragCoord.xy / mx;\n    vec2 st = uv * 3.2; \n    vec2 tuv = uv * 1.2;\n    \n    float n_x = 2.0 * fbm(st + vec2(7.29 , ttime)) - 1.0;\n    float n_y = 2.0 * fbm(st + vec2(3.67 , ttime)) - 1.0;\n    float n_z = 0.5 * fbm(st + vec2(0.0 , 0.0)) + 0.5;\n\n    vec3 n = normalize(vec3(n_x , n_y , n_z));\n    vec3 l = normalize(vec3(cos(ttime) , sin(ttime) , 1.0));\n\n    float c = dot(l,n);\n\n    vec2 cuv = fract(9.7 * vec2(n_x , n_y) * tuv + vec2(0.0 , ctime * 0.1));\n    float cx = cuv.x;\n    float cy = cuv.y;\n    cx = step(0.5 * sin(cx * TWOPI) + 0.5 , 0.5);\n    cy = step(0.5 * sin(cy * TWOPI) + 0.5 , 0.5);\n  \n    \n    vec2 duv = fract(9.7 * vec2(n_x , n_y) * tuv + vec2(0.0 , ptime * 0.1));\n    float dx = duv.x;\n    float dy = duv.y;  \n    dx = step(0.5 * sin(dx * TWOPI) + 0.5 , 0.5);\n    dy = step(0.5 * sin(dy * TWOPI) + 0.5 , 0.5); \n    \n    float total = cx+cy;\n    bool isWhite = mod(total , 2.0) == 0.0;\n\n    vec3 w = vec3(1.0);\n\n    vec3 b = vec3(0.0);\n\n    vec3 ch = isWhite ? w:b;\n\n   \tch -= vec3(floor(dx + dy * 0.975));\n\n    vec3 o = grad(c + ttime * 0.5 + stime);\n\t\t\n    //Uncomment for more chaotic shapes\n    //ch -= vec3(floor(fract(c * 12.0) + 0.25));\n\n    fragColor = vec4(ch + o , 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsXBD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[195, 280, 304, 304, 355], [357, 357, 384, 384, 456], [458, 536, 562, 562, 942], [944, 1007, 1032, 1032, 1367], [1369, 1369, 1426, 1426, 2849]], "test": "valid"}
{"id": "tsXBWN", "name": "RayMarchingCameraTest", "author": "erkan612", "description": "This is a camera test with ray marching techniq.", "tags": ["raymarching"], "likes": 0, "viewed": 83, "published": "Public", "date": "1588253345", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec3 shadowAndAmbientColor = vec3(1.0)-vec3(0.1, 0.2, 0.4);\n\nfloat sph(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat plane(vec3 p, vec3 n, float d) {\n\treturn dot(p, n) - d;\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat box(vec3 p, vec3 s) {\n\treturn vmax(abs(p)-s);\n}\n\nfloat sdf(vec3 p) {\n\tfloat s1 = sph(p, 1.0);\n    \n    float p1 = plane(p, vec3(0.0, 1.0, 0.0), -1.0);\n    \n    float b1 = box(vec3(2.0, 0.0, 0.0)-p, vec3(1.0));\n    \n    float m1 = min(s1, p1);\n    m1 = min(m1, b1);\n    \n    return m1;\n}\n\nvec3 getnormal(vec3 p) {\n\tfloat c = sdf(p);\n    vec2 off = vec2(-0.01, 0.0);\n    \n    return normalize(vec3(sdf(p - off.xyy) - c, sdf(p - off.yxy) - c, sdf(p - off.yyx) - c));\n}\n\nvec3 shadow(vec3 ro, vec3 rd) {\n    vec3 color = vec3(1.0);\n    \n    int steps = 50;\n    float s = 10.0/float(steps);\n    \n    float tq = 0.05;\n    float t = tq;\n    \n    vec3 sundir = vec3(1.0, 1.0, -1.0);\n    \n    for (int i = 0; i < steps; i++) {\n        vec3 pos = ro + rd*t;\n    \tfloat d = sdf(pos + getnormal(pos)*0.02);\n        \n        color = min(color, 10.0*d/t);\n        \n        if (d < 0.01) {\n            color = vec3(0.0);\n            break;\n        }\n        \n        t += d;\n    }\n    \n    return color * shadowAndAmbientColor;\n}\n\nvec3 march(vec3 ro, vec3 rd) {\n    vec3 color = vec3(0.0);\n    \n    int steps = 50;\n    float s = 10.0/float(steps);\n    \n    float tq = 0.05;\n    float t = tq;\n    \n    vec3 sundir = vec3(1.0, 1.0, -1.0);\n    \n    for (int i = 0; i < steps; i++) {\n        vec3 pos = ro + rd*t;\n    \tfloat d = sdf(pos);\n        \n        if (d < 0.01) {\n            vec3 n = getnormal(pos);\n            vec3 shad = shadow(pos, normalize(sundir));\n            float lum = max(0.0, dot(n, normalize(sundir)));\n            float fog = 10.0/(t*t);\n        \tcolor = vec3(lum * max(min(fog, 1.0), 0.0)) * shad;\n            break;\n        }\n        \n        t += d;\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ((fragCoord-0.5*iResolution.xy)/min(iResolution.x,iResolution.y)) * 2.0;\n\n    float t = float(iTime);\n    float d = 4.0;\n    \n    vec3 ro = vec3(cos(t) * d, 0.5*d, sin(t)*d);\n    vec3 ta = vec3(0.0);\n    \n    vec3 cz = normalize(ta - ro);\n    vec3 cx = normalize(cross(vec3(0.0, 1.0, 0.0), cz));\n    vec3 cy = normalize(cross(cz, cx));\n    //vec3 rd = normalize(vec3(uv, 1.0));\n    vec3 rd = normalize(cx * uv.x + cy * uv.y + cz * 1.0);\n    \n    vec3 color = march(ro, rd);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsXBWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 95, 95, 120], [122, 122, 160, 160, 185], [187, 187, 207, 207, 242], [244, 244, 271, 271, 297], [299, 299, 318, 318, 536], [538, 538, 562, 562, 715], [717, 717, 748, 748, 1263], [1265, 1265, 1295, 1295, 1937], [1939, 1939, 1996, 1996, 2521]], "test": "valid"}
{"id": "tsXBWr", "name": "challenge 2", "author": "TosterMocy", "description": "wip", "tags": ["dna"], "likes": 5, "viewed": 97, "published": "Public", "date": "1588017926", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdBox(in vec2 p, in vec2 b)\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float angle = 0.2; //kat w radianach\n    \n    vec2 uv = (fragCoord *2.0 - iResolution.xy) / iResolution.y;\n    \n    \n    uv *= mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n    uv*=3.0;\n    uv.x+=iTime*3.0;\n    float uvID = floor(uv.x);\n    uv.x = fract(uv.x);\n    \n    float pixelSize = 2.0 / iResolution.y;\n    \n    \n    \n    \n    float squareSDF = sdBox(vec2(uv.x-0.5,uv.y), abs(vec2(0.05, sin(uvID/2.0+iTime))));\n    float square = 1.0 - smoothstep(-pixelSize, pixelSize, squareSDF);\n    float radius1 = abs(sin(abs(uv.x)+iTime/2.0+3.14)/3.0);\n    float radius2 = abs(cos(abs(uv.x)+iTime/2.0+3.14)/3.0);\n   \n    float sin1 = 1.0 - smoothstep(radius1-pixelSize, radius1 + pixelSize, distance(uv, vec2(0.5, sin(uvID/2.0+iTime))));\n    //float cos1 = 1.0 - step(0.3, distance(uv, vec2(0.5, cos(uvID/2.0+iTime))));\n    float sin2 = 1.0 - smoothstep(radius2-pixelSize, radius2 + pixelSize, distance(uv, vec2(0.5, -sin(uvID/2.0+iTime))));\n   \n    \n    vec4 uvVisualisation = clamp(vec4(uv, 0.0, 0.0), 0.0, 1.0);\n    \n    fragColor =  vec4(square+sin1+sin2) ;\n   \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsXBWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 119], [125, 125, 182, 182, 1263]], "test": "valid"}
{"id": "tsXBzM", "name": "Simple terrain (SS13)", "author": "angelo12", "description": "Thought this looked pretty cool even though it's really simple. :) ", "tags": ["procedural", "3d", "raymarching", "terrain", "shadersundays"], "likes": 5, "viewed": 576, "published": "Public API", "date": "1587903759", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define saturate(val) clamp(val, 0.0, 1.0)\n\n/*\n\tShader Sundays! (13/52) \n\t\"Simple Terrain\"\n\t\n\tI've dabled in terrain raymarching before but never did a deep dive on it.\n\tBeen working on that on and off this week and I'm pretty happy with this one even\n\tthough it's so simple. There's something really cool about looking into depth buffers,\n\tso although I did some experiments with more elaborate shading I thought\n\tthis simple colored depth buffer looked pretty interesting already. \n\n\tHere are some sources that I used for this and other cool shaders worth checking out\n\tanyway :\n\n\thttps://www.shadertoy.com/view/ttcSD8 (Swiss alps)\n\thttps://www.shadertoy.com/view/MdX3Rr (Elevated)\n\thttps://www.shadertoy.com/view/MdlGW7 (Cloudy terrain)\n\thttps://www.shadertoy.com/view/ttc3zr (High quality murmur hashes)\n*/\n\n\n//https://www.shadertoy.com/view/ttc3zr\nuint murmurHash12(uvec2 src) {\n    const uint M = 0x5bd1e995u;\n    uint h = 1190494759u;\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 1 output, 2 inputs\nfloat hash12(vec2 src) {\n    uint h = murmurHash12(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\nfloat\nSmoothNoise(vec2 uv)\n{\n    vec2 id = floor(uv);\n    vec2 fr = fract(uv);\n\n    fr = fr*fr*(3.0 - 2.0*fr);\n\n    float bl = hash12(id);\n    float br = hash12(id + vec2(1.0, 0.0));\n    float b  = mix(bl, br, fr.x);\n\n    float tl = hash12(id + vec2(0.0, 1.0));\n    float tr = hash12(id + vec2(1.0, 1.0));\n    float t  = mix(tl, tr, fr.x);\n\n    return mix(b, t, fr.y);\n}\n\nfloat\nValueNoise(vec2 uv, int octaves)\n{\n    float noise;\n    float totalAmplitude;\n    float amplitude = 1.0;\n    float frequency = 1.0;\n\n    for(int i = 0; i < octaves; ++i)\n    {\n        totalAmplitude += amplitude;\n        noise += SmoothNoise(uv * frequency) * amplitude;\n        frequency *= 2.0;\n        amplitude /= 2.0;\n    }\n\n    return noise / totalAmplitude;\n}\n\nmat3\nSetCamera(vec3 eye, vec3 target, float roll)\n{\n    vec3 i, j, k, temp;\n\n    k = normalize(target - eye);\n    temp = normalize(vec3(sin(roll), cos(roll), 0.0));\n    i = normalize(cross(temp, k));\n    j = cross(k, i);\n\n    return mat3(i, j, k);\n}\n\n#define HI_LOD 8\n#define LO_LOD 2\nfloat\nterrain(vec3 p)\n{\n    return p.y - ValueNoise(p.xz, HI_LOD);\n}\n\n// I know I could change MAX_STEPS and remove the weird haze when you get close to the ground\n// but I like it :)\n#define MAX_STEPS 23\n#define MAX_DIST 20.0\n#define MIN_DIST 0.01\nfloat\nintersectTerrain(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n\n    for(int i = 0; i < MAX_STEPS && t < MAX_DIST; ++ i)\n    {\n        float hit = terrain(ro + t*rd);\n\t\t\n        //Some fancy inigo thing I don't fully understand yet\n        //\tif ray is partially in it's still cool?\n        //\twe make the min distance larger when further away?\n        //  Optimization or stylistic thing?\n        if(abs(hit) < MIN_DIST *t)break;\n\n        t += hit;\n    }\n    return t;\n}\n\nvec3\nRender(vec3 ro, vec3 rd)\n{\n    vec3 col;\n\t\n    //Raymarching the terrain\n    float t = intersectTerrain(ro, rd);\n    \n    //Simple shading\n    col += t / 9.80665; // :) \n    col *= vec3(0.78, 0.9, 1.0);\n\n    return saturate(col);\n}\n\n#define INV_GAMMA 0.45454545\n#define ONE(val) (val * 0.5 - 0.5)\nvoid\nmainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    //Camera Setup\n    float nearp = 1.0;\n    float roll = 0.0;\n    vec3 ta = vec3(0.0 + iTime, 0.0, 0.0);\n    vec3 ro = ta + vec3(0.0, 2.0 + 1.25*ONE(sin(iTime / 5.0)) , -abs(10.0*sin(iTime / 30.0)));\n    vec2 uv = ((fragCoord) - 0.5*iResolution.xy)/iResolution.y;\n    mat3 cam = SetCamera(ro, ta, roll);\n    vec3 rd = cam * normalize(vec3(uv, nearp));\n\n    vec3 col = Render(ro, rd);\n    \n    //Noise debug\n    //col = vec3(hash12(uv));\n    //col = vec3(SmoothNoise(uv * 20.0));\n    //col = vec3(ValueNoise(uv* 2.0 + iTime, 8));\n\t\n    col = pow(col, vec3(1.0 / (0.65)));\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsXBzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[813, 853, 883, 883, 1080], [1082, 1104, 1128, 1128, 1244], [1246, 1246, 1274, 1274, 1616], [1618, 1618, 1658, 1658, 1990], [1992, 1992, 2043, 2043, 2241], [2277, 2277, 2300, 2300, 2345], [2526, 2526, 2568, 2568, 2995], [2997, 2997, 3028, 3028, 3233], [3299, 3299, 3354, 3373, 3961]], "test": "valid"}
{"id": "tsXfR8", "name": "Do You Want To Build A Snowman", "author": "42yeah", "description": "First time trying to render an actual raymarching scene. I am still bad at this :(\nDon't look behind the wall. Lots of (lighting) code taken from fruxis: https://www.shadertoy.com/view/ldl3zl , which is awesome, but I am still learning them.", "tags": ["raymarching"], "likes": 5, "viewed": 320, "published": "Public API", "date": "1587664634", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float smin(float a, float b, float k) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat snowhead(vec3 p, vec3 off) {\n    float body = length(p - off) - 1.0;\n    float head = length(p - vec3(0.0, 1.4, 0.0) - off) - 0.6;\n    return smin(body, head, 0.2);\n}\n\nfloat carrot(vec3 p, vec3 off) {\n    p = p - off;\n    if (length(p) > 1.0) {\n        return 1.0;\n    }\n    float rad = radians(75.0);\n    float q = length(p.xy);\n    return dot(vec2(sin(rad), cos(rad)), vec2(q, p.z));\n}\n\nfloat snoweye(vec3 p, vec3 off) {\n    float left = length(p - vec3(-0.25, 0.0, 0.0) - off) - 0.1;\n    float right = length(p - vec3(0.25, 0.0, 0.0) - off) - 0.1;\n    return min(left, right);\n}\n\nfloat sol(vec3 p) {\n    return p.y;\n}\n\nfloat rect(vec3 p, vec3 b, vec3 off) {\n    vec3 q = abs(p - off) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - 0.1;\n}\n\nfloat window(vec3 p, vec3 off) {\n    return max(rect(p, vec3(2.0, 2.0, 0.1), off),\n        -rect(p, vec3(1.8, 1.7, 1.0), off + vec3(0.0, 0.0, 0.1)));\n}\n\nfloat wall(vec3 p, vec3 windowOff) {\n    if (p.z < -3.0) {\n        return 1.0;\n    }\n    float x = abs(p.x + 3.0) - 0.001;\n    float z = abs(p.z + 3.0) - 0.001;\n    return max(min(x, z),\n        -rect(p, vec3(2.0, 2.0, 1.0), windowOff));\n}\n\nfloat cubic(vec3 p, vec3 off) {\n    float sol = rect(p, vec3(3.0, 0.01, 3.0), off);\n    float plafond = smin(sol, rect(p, vec3(3.0, 0.01, 3.0), off + vec3(0.0, 6.0, 0.0)), 0.1);\n    float wall = smin(plafond, rect(p, vec3(3.0, 6.0, 0.01), off + vec3(0.0, 0.0, -3.0)), 0.1);\n    wall = smin(wall, rect(p, vec3(0.01, 6.0, 3.0), off + vec3(-3.0, 0.0, 0.0)), 0.1);\n    wall = smin(wall, rect(p, vec3(0.01, 6.0, 3.0), off + vec3(3.0, 0.0, 0.0)), 0.1);\n    return wall;\n}\n\nfloat lamp(vec3 p, vec3 off) {\n    return rect(p, vec3(0.5, 0.1, 0.4), off);\n}\n\nvec2 map(vec3 p) {\n    float closest = 1000.0;\n    float id = -1.0;\n    \n    float dist = sol(p);\n    if (dist < closest) { closest = dist; id = 0.5; }\n    \n    dist = snowhead(p, vec3(0.0, 0.5, 0.0));\n    if (dist < closest) { closest = dist; id = 1.5; }\n    \n    dist = snoweye(p, vec3(0.0, 2.2, 0.5));\n    if (dist < closest) { closest = dist; id = 2.5; }\n    \n    dist = carrot(p, vec3(0.0, 1.9, 1.0));\n    if (dist < closest) { closest = dist; id = 3.5; }\n    \n    dist = wall(p, vec3(0.0, 3.8, -4.0));\n    if (dist < closest) { closest = dist; id = 4.5; }\n    \n    dist = window(p, vec3(0.0, 3.8, -3.1));\n    if (dist < closest) { closest = dist; id = 5.5; }\n    \n    dist = cubic(p, vec3(1.0, 0.0, -6.15));\n    if (dist < closest) { closest = dist; id = 6.5; }\n    \n    dist = lamp(p, vec3(1.0, 6.0, -6.15));\n    if (dist < closest) { closest = dist; id = 7.5; }\n    \n    return vec2(closest, id);\n}\n\nvec3 calcNormal(vec3 p) {\n    const float epsilon = 0.001;\n    return normalize(vec3(\n        map(p).x - map(vec3(p.x - epsilon, p.yz)).x,\n        map(p).x - map(vec3(p.x, p.y - epsilon, p.z)).x,\n        map(p).x - map(vec3(p.xy, p.z - epsilon)).x\n    ));\n}\n\nvec2 intersect(vec3 ro, vec3 rd) {\n    vec2 dv = vec2(0.0, -1.0);\n    \n    for (int i = 0; i < 300; i++) {\n        vec2 distId = map(ro + rd * dv.x);\n        if (distId.x <= 0.001) {\n            dv.y = distId.y;\n            break;\n        }\n        dv.x += distId.x;\n    }\n    return dv;\n}\n\nvec3 wallColor(vec3 p) {\n    const vec3 base = vec3(0.8, 0.6, 0.7);\n    vec3 f = fract(p);\n    float clamped = length(clamp(p, 0.0, 1.0));\n    return base * (f.y + 0.4);\n}\n\nvec3 carrotColor(vec3 p) {\n    const vec3 base = vec3(1.5, 0.3, 0.0);\n    vec3 f = fract(p * 10.0);\n    vec3 color = base * (1.0 - pow(f.z, 12.0) * 0.3);\n    return color;\n}\n\nvec3 getColor(vec3 p, float id) {\n    if (id <= -0.5) { return vec3(0.0, 0.0, 0.0); }\n    if (id <= 1.0) { return vec3(1.0, 1.0, 1.0); }\n    if (id <= 2.0) { return vec3(1.0, 1.0, 1.0); }\n    if (id <= 3.0) { return vec3(0.1, 0.1, 0.1); }\n    if (id <= 4.0) { return carrotColor(p); } // carrot\n    if (id <= 5.0) { return wallColor(p); } // wall\n    if (id <= 6.0) { return vec3(0.5, 0.2, 0.1); }\n    if (id <= 7.0) { return vec3(2.2, 2.2, 2.2); }\n    if (id <= 8.0) { return vec3(100.0, 100.0, 100.0); }\n    return vec3(1.0, 0.0, 0.0);\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float k) {\n    float res = 1.0;\n    float depth = 0.0001;\n    vec2 dv = vec2(1.0, -1.0);\n\n    for (int i = 0; i < 50; i++) {\n        dv = map(ro + rd * depth);\n        res = min(res, smoothstep(0.0, 1.0, k * dv.x / depth));\n        if (res < 0.0001) { break; }\n        depth += clamp(dv.x, 0.01, 0.06);\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat directLighting(vec3 p, vec3 n, vec3 lightPos, vec3 lightDir) {\n    vec3 u = normalize(cross(lightDir, vec3(0.0, 1.0, 0.0)));\n    vec3 v = cross(u, lightDir);\n    float shadowIntensity = softShadow(p + 0.001 * n, lightDir, 10.0);\n    \n    vec3 toLight = lightPos - p;\n    float attenuation = smoothstep(0.9, 1.0, dot(normalize(toLight), lightDir));\n    \n    return attenuation * shadowIntensity;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    float aspect = iResolution.x / iResolution.y;\n    uv.x *= aspect;\n\n    const float r = 2.0;\n    vec3 ro = vec3(r * (sin(iTime * 0.3) * 0.5 + 0.5) * 0.9 + r, 3.0 * (sin(iTime * 0.5) * 0.1 + 0.9), r * (cos(iTime * 0.3) * 0.5 + 0.5) + r);\n    vec3 center = vec3(0.0, 2.0 + sin(iTime * 0.2) * 0.8 + 0.2, 0.0);\n    vec3 front = normalize(vec3(center - ro));\n    vec3 right = normalize(cross(front, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(right, front));\n    mat4 lookAt = mat4(\n        vec4(right, 0.0),\n        vec4(up, 0.0),\n        vec4(front, 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n    vec3 rd = normalize(vec3(lookAt * vec4(uv, 2.0, 1.0)));\n    \n    vec2 result = intersect(ro, rd);\n    vec3 pos = ro + rd * result.x;\n    vec3 n = calcNormal(pos);\n    \n    vec3 lightPos = vec3(-1.5, 5.5, -4.65);\n    vec3 lightDir = normalize(lightPos);\n    vec3 hal = normalize(lightDir - rd); // WHAT?\n\n    float ambient = 1.0;\n    float diffuse = max(dot(lightDir, n), 0.0);\n    float attenuation = 0.1 + 0.9 * smoothstep(0.9, 1.0, dot(normalize(lightPos - pos), lightDir));\n    float back = max(dot(n, normalize(vec3(-lightDir.x, 0.0, -lightDir.z))), 0.0);\n    float fr = pow(clamp(1.0 + dot(n , rd), 0.0, 1.0), 3.0);\n    float dome = clamp(n.y * 0.8 + 0.2, 0.0, 1.0);\n    float sol = clamp(-n.y * 0.8 + 0.2, 0.0, 0.0) * pow(clamp(1.0 - pos.y, 0.0, 1.0), 2.0);\n    float specular = pow(clamp(dot(n, hal), 0.0, 1.0), 8.0);\n    float shadow = directLighting(pos, n, lightPos, lightDir);\n    \n    vec3 light = vec3(0.0, 0.0, 0.0);\n    light += ambient * vec3(0.03, 0.02, 0.01) * attenuation;\n    light += diffuse * vec3(1.01, 1.0, 1.0) * pow(vec3(shadow), vec3(1.0, 1.0, 1.0)) * attenuation;\n    light += back * vec3(0.42, 0.20, 0.1) * attenuation;\n    light += fr * vec3(3.0, 3.0, 3.0) * attenuation * (0.25 + 0.25 * diffuse);\n    light += dome * vec3(0.15, 0.1, 0.1) * attenuation;\n    light += sol * vec3(0.2, 0.2, 0.2) * attenuation;\n    light += specular * vec3(0.5, 0.5, 0.5) * attenuation;\n    \n    vec3 color = getColor(pos, result.y) * light;\n    color = pow(color, vec3(0.4545));\n\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsXfR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 132], [134, 134, 168, 168, 306], [308, 308, 340, 340, 527], [529, 529, 562, 562, 721], [723, 723, 742, 742, 760], [762, 762, 800, 800, 907], [909, 909, 941, 941, 1060], [1062, 1062, 1098, 1098, 1301], [1303, 1303, 1334, 1334, 1768], [1770, 1770, 1800, 1800, 1848], [1850, 1850, 1868, 1868, 2756], [2758, 2758, 2783, 2783, 3015], [3017, 3017, 3051, 3051, 3306], [3308, 3308, 3332, 3332, 3479], [3481, 3481, 3507, 3507, 3654], [3656, 3656, 3689, 3689, 4195], [4197, 4197, 4242, 4242, 4575], [4577, 4577, 4645, 4645, 4979], [4981, 4981, 5036, 5036, 7229]], "test": "valid"}
{"id": "tsXfzr", "name": "Infinite Raymarch Spheres", "author": "KeeganPillow", "description": "Uses modulo to create infinite raymarched spheres", "tags": ["raymarched", "spheres", "infinite"], "likes": 2, "viewed": 183, "published": "Public", "date": "1587597123", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAXSTEPS 100\n#define MAX_DISTANCE 100.0\n#define GLERP 0.01\n\n//Returns the distance to a sphere\n//Pos is the position of the object.\n//Sphere\n//xyz describes the position of the sphere.\n//w describes the radius of the sphere.\nfloat Sphere (vec3 Pos, vec4 Sphere)\n{\n    return distance(Pos, Sphere.xyz) - Sphere.w;\n}\n\n//Returns the distance from objects in the scene.\nfloat GetDistanceFromScene(vec3 Pos)\n{\n   float modDist = 2.0;\n    \n   vec3 ModPos = vec3(mod(Pos, modDist));\n    \n   //Sphere 'nuff said.\n   float SP = Sphere(ModPos, \n                     vec4(1.0,\n                     1.0,\n                     1.0,\n                     0.25 + sin(iTime) * 0.125));\n    \n   //Sphere 'nuff said.\n   //float SP2 = Sphere(Pos, \n   //                   vec4(1.0 + cos(iTime / 4.0) * 2.0,\n   //                   1.0,\n   //                   6.0 + sin(iTime / 4.0) * 2.0, \n   //                   1.0) ); \n    \n   //SP = min (SP, mod(3.0, SP));\n    \n   //Ground plane (XZ)\n   float G = Pos.y; \n   \n   float minDist = min(SP, SP);\n   minDist = min(minDist, G);\n   return minDist;\n}\n\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDistanceFromScene(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDistanceFromScene(p-e.xyy),\n        GetDistanceFromScene(p-e.yxy),\n        GetDistanceFromScene(p-e.yyx));\n    \n    return normalize(n);\n}\n\n//Gets the depsth of the camera in the direction it's facing.\nfloat GetDepth(vec3 Position, vec3 direction)\n{\n   //Total accumulated distance\n   float dist = 0.0;\n    \n   //Raymarching loop.\n   for (int i = 0; i < MAXSTEPS; ++i)\n   {\n       //Finds the current position of ray\n       vec3 p = Position + dist * direction;\n       //Finds the distance from objects in the scene\n       float distScene = GetDistanceFromScene(p);\n       //Adds that distance to the total.\n       dist += distScene;\n       //Check for a break condition\n       if (distScene < GLERP || distScene > MAX_DISTANCE) break;\n   }\n   //Return the distance\n   return dist;\n}\n\n//Gets the normal of an object\n//Pos is the position of the object.\nfloat GetLight(vec3 p)\n{\n    vec3 LightPos = vec3(0.0, 5.0, iTime);\n    \n    vec3 l = normalize(LightPos - p);\n    \n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    \n    //Look for shadows\n    \n    //Get distance raymarched from surface point to the light\n    float d = GetDepth(p + n * GLERP * 2.0, l);\n    \n    //Check is shorter than the distance to the light\n    if (d < length(LightPos - p)) dif *= .1;\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) /iResolution.y;\n   \n    \n    //Hey some camera stuff.\n    vec3 Position  = vec3(0.0, 1.0, -5.0 + iTime);\n    vec3 RayDir    = normalize(vec3(uv.x, uv.y, 1.0));\n    \n    // Time varying pixel color\n    float depth = GetDepth(Position, RayDir);\n\n    //Diffuse lighting by finding normal from last position found in depth function\n    float dif = GetLight(Position + RayDir * depth);\n    \n    // Output to screen\n    fragColor = vec4(dif, dif, dif,1.0);\n    //fragColor = vec4(depth/10.0, depth/10.0, depth/10.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsXfzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 233, 271, 271, 322], [324, 374, 412, 412, 1085], [1087, 1087, 1111, 1111, 1355], [1357, 1419, 1466, 1498, 2000], [2002, 2070, 2094, 2094, 2531], [2533, 2533, 2590, 2640, 3206]], "test": "valid"}
{"id": "tsXyDf", "name": "Rainbow Meatballs", "author": "EmmaChase", "description": "Experimenting with noise", "tags": ["noise", "raymarcher"], "likes": 2, "viewed": 64, "published": "Public", "date": "1585715265", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_MARCH_STEPS 120\n#define CLIP_DIST 1000.0\n#define EPSILON 0.01\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\nfloat texNoise(vec3 p) {\n    return texture(iChannel0, vec2(p.xy)).r;\n}\n\n\nfloat sdBall(vec3 pos, float radius)\n{\n    return 0.006*texNoise(1.5*pos) + 0.04*noise(5.*pos) + length(pos) - radius;\n}\n\nfloat sceneSDF(vec3 pos) {\n    pos = mod(pos, 10.0) - 5.0;\n    \n    float temp;\n    float dist = CLIP_DIST;\n\n    dist = (temp = sdBall(pos - vec3(0.0, 0.0, 5.0), 1.0)) < dist ? temp : dist;\n\n    return dist;\n}\n\nfloat raymarch(vec3 ro, vec3 rd, float mint, float maxt) {\n    float depth = mint;\n    for(int i=0;i<MAX_MARCH_STEPS;i++)  {\n        float dist = sceneSDF(ro+rd*depth);\n        if (dist < EPSILON) return depth;\n\n        depth += dist;\n        if (depth > maxt) break;\n    }\n\n    return maxt;\n}\n\nvec3 calcNormal(vec3 pos) {\n    const vec2 eps = vec2(0.001, 0.0);\n\n    vec3 nor = vec3(\n        sceneSDF(pos + eps.xyy) - sceneSDF(pos - eps.xyy),\n        sceneSDF(pos + eps.yxy) - sceneSDF(pos - eps.yxy),\n        sceneSDF(pos + eps.yyx) - sceneSDF(pos - eps.yyx));\n    return normalize(nor);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 aspect = vec2(1.0, iResolution.y / iResolution.x);\n    uv = 2.0 * uv - 1.0;\n    uv *= aspect;\n\n    vec3 col = vec3(0.0);\n\n    vec3 ro = vec3(2.0*cos(iTime), 5.0, 2.0*sin(iTime));\n\n    const float FOV = 90.0;\n    const float RDF = 1.0 / tan(radians(FOV / 2.0));\n    vec3 rd = normalize(vec3(uv, RDF));\n\n    float dist = raymarch(ro, rd, 0.01, CLIP_DIST);\n\n    if (dist < CLIP_DIST) {\n        vec3 hitPos = ro + rd*dist;\n\n        vec3 normal = calcNormal(hitPos);\n\n        const vec3 lightPosition = vec3(-2.0, 2.0, 1.0);\n        float lightness = max(0.0, dot(-normalize(hitPos - lightPosition), normal));\n\n        col = vec3(mod(hitPos / 30., 1.));\n        col = smoothstep(0., 1., col); // Brightens up the colors\n        col *= 0.2 + 0.8*lightness;\n        col *= mix(1.0, 0.0, length(hitPos - lightPosition) / 250.0);\n    }\n\n    col = pow (col, vec3 (1.0 / 2.2)); // Gamma correction\n    fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsXyDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 75, 97, 97, 142], [143, 143, 163, 163, 208], [209, 209, 227, 227, 266], [268, 268, 288, 288, 779], [781, 781, 805, 805, 852], [855, 855, 893, 893, 975], [977, 977, 1003, 1003, 1186], [1188, 1188, 1246, 1246, 1481], [1483, 1483, 1510, 1510, 1778], [1780, 1780, 1835, 1835, 2807]], "test": "error"}
{"id": "tsXyDl", "name": "Glow intro 2", "author": "Tomza", "description": "rework of first shader 2 times less chars!", "tags": ["star", "neon"], "likes": 6, "viewed": 284, "published": "Public API", "date": "1585821467", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define Rot(a) mat2(cos(a), -sin(a),sin(a), cos(a))\n#define PI 3.141592\n#define tau 6.283185\n\nfloat sdCapsule( vec2 p, vec2 a, vec2 b)\n{\n  vec2 pa = p - a;\n  vec2 ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h );\n}\n\nfloat Branch(vec2 p, float zoom)\n{\n    p*=Rot(0.945);\n    p -= zoom*vec2(0.31,0.43);\n    float d = sdCapsule(p, vec2(0.,0.), zoom*vec2(1.,0.));\n    d = min(d,sdCapsule(p* -Rot(tau/5.), vec2(0.,0.), zoom*vec2(1.,0.)));\n    return d;\n}\n\nvec3 Star(vec2 p, float zoom, vec3 col)\n{\n    p*=Rot(tau/4.);\n    \n    float an = tau/5.;\n    float sector = round(atan(p.y,p.x)/an);\n    vec2 q = p;\n    \n    q.xy = Rot(an*sector)*p.xy;\n\n    return 0.02/abs(Branch(q,zoom))*col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.*(2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 m,col = vec3(0.);\n    \n    for(float i=0.;i<10.;i++)\n    {     \n        m = max(m,Star(uv, mod(2.5*iTime-i,10.)+0.01,vec3(0.86-mod(i,10.)*0.2,0.0,0.48+0.02*mod(i,10.))));   \n    }\n    \n    col = m;\n\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsXyDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[94, 94, 136, 136, 260], [262, 262, 296, 296, 495], [497, 497, 538, 538, 727], [730, 730, 787, 787, 1090]], "test": "valid"}
{"id": "wd2cDh", "name": "YinfinitY", "author": "lucastakejame", "description": "Trying to make an infinite zoom", "tags": ["2d", "fractal", "chaos", "yinyang"], "likes": 10, "viewed": 89, "published": "Public", "date": "1587236037", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define SOFT .005\n#define PIXELATED 0\n\n#define ss(a,b,c) smoothstep(a,b,c)\n\nfloat circle(vec2 uv, float r, vec2 c, float softness)\n{\n    return ss(r+softness, r-softness, length(uv - c));\n}\n\nvec2 rot(vec2 uv, float a)\n{\n    vec2 i = vec2(cos(a),sin(a));\n    return vec2(uv.x*i.x - uv.y*i.y, uv.y*i.x + uv.x*i.y);\n}\n\n\nfloat window(float center, float val, float width, float fall)\n{\n    return ss(width + fall, width, length(center - val));\n}\n\n// map square coordinates of center c, radial range and angular range.\n// map to [-.5, 5]\nvec2 mapCrown(vec2 uv, vec2 c, vec2 radLim)\n{\n    float radius = (radLim.x + radLim.y)/2.;\n    float radrange = (radLim.y - radLim.x);\n    vec2 nuv = uv - c;\n    vec2 puv  =  vec2(length(nuv), atan(nuv.y, nuv.x) );\n    \n    uv = vec2((puv.x - radLim.x)/radrange - .5,\n              puv.y/PI);\n\t\n    return uv;\n}\n\n\n// generate a yinyang (yy) on .x and a round mask on .y\n// fits in [-.5, .5] when scale 1.\nvec2 yinyang(vec2 uv, float softness, float scale)\n{\n    \n    float r = .25*scale;\n    float whole = max(\n        \t\t\t\t// upper ball\n        \t\t\t\tcircle(uv, r, vec2(0., r), softness),\n                      \t(uv.x > 0.)?0.:1.-circle(uv, r,vec2(0., -r), softness)\n        \n                     );\n    whole +=  circle(uv, .06125*scale , vec2(0.,-r), softness);\n    whole -=  circle(uv, .06125*scale , vec2(0.,r), softness);\n    float br = .5*scale ;\n    float mask = ss(br+softness, br-softness, length(uv));\n    whole = mix(.0, whole, ss(br+softness, br-softness, length(uv)));\n    \n    return vec2(whole, mask);\n    \n}\n\n// generates big yy with a curve string of small yys on its edge\nvec2 chaos(vec2 uv, float softness, float scale, float scaleDiv)\n{\n    vec2 yy = vec2(0.);\n    \n\t\n    // first YY\n    yy += yinyang(uv, softness, scale);\n    \n    // uv for mapping small YY's in the big YY edge\n    vec2 nuv = rot(uv, PI/2.) - vec2(-0.25*scale, .0);\n    vec2 nuv2 = rot(uv, PI/2.) - vec2(0.25*scale, .0);\n        \n    // crown thickness\n    float thick = .5/scaleDiv;\n    \n    vec2 rads = scale*vec2(.25 - thick, .25 + thick);\n    \n    // morph UV to form an S shape on YY edge\n    uv = mix(mapCrown(nuv,  vec2(.0), rads.xy),\n             mapCrown(rot(nuv2,PI), vec2(.0), rads.yx) * vec2(1., -1.),\n             ss( 0.01, .0, sign(uv.x)) );\n\t\n    // angle of section in crown \n    // Calculated trying to aproximate section to a square\n    // r2 - r1 = angle*(r2 + r1)/2\n    float angle = 2.*(rads.y-rads.x)/(rads.y+rads.x);\n    \n    // repetition of angular coord\n    uv.y = fract(uv.y*floor(PI/angle)) - .5;\n    \n    // string phase shift \n    uv.y = (uv.y >= 0.)?uv.y-.5:uv.y+.5;\n    \n    // scale param is 1. cause uv has been scaled here already \n\tvec2 yyString = yinyang(uv, softness, 1.);\n    yy = mix(yy, yyString,  yyString.y);\n    \n    \n    // fill space out of YY\n    yy.x = (yy.y > 0.)?yy.x: (uv.x < 0.)?1.:0.;\n    \n    return yy;\n}\n\n// super pose 1 chaos small YYs with the big YY of another chaos\nvec2 connectYYs(vec2 uv, float softness, float startScale, float scaleDiv)\n{\n    float endScale = startScale/scaleDiv;\n    vec2 yy = chaos(uv, softness, startScale, scaleDiv);\n\t\n    //TODO: Make extra YYs follow edge curvature\n    // extra YYs\n    vec2 yy1 = chaos(uv+vec2(.0,  startScale *1.004), softness, startScale, scaleDiv);\n\tvec2 yy2 = chaos(uv+vec2(.0, -startScale *1.004), softness, startScale, scaleDiv);\n    yy = mix(yy, yy1, yy1.y);\n    yy = mix(yy, yy2, yy2.y);\n    \n\n    vec2 nuv = rot(uv, PI/2.);\n    vec2 newYY = chaos(nuv, softness, endScale, scaleDiv);\n    \n    // extra strings\n    vec2 newYY1 = chaos(nuv+vec2(0., endScale), softness, endScale, scaleDiv);\n    vec2 newYY2 = chaos(nuv+vec2(0., -endScale), softness, endScale, scaleDiv);\n    newYY = mix(newYY, newYY1, newYY1.y);\n    newYY = mix(newYY, newYY2, newYY2.y);\n    \n    yy = mix(yy, newYY, newYY.y);\n    \n    return yy;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    \n    #if (PIXELATED == 1)\n    float f = 40.;\n    uv = floor(uv*f)/f;\n    #endif\n    \n    // rotate everything\n    //uv = rot(uv,mix( 0., iTime, ss(1., 10., iTime)) );\n    \n    vec2 muv = iMouse.xy/iResolution.xy;\n    \n    float period = 8.;\n    float startScale = 4000.;\n    float scaleDiv = 150.;\n    \n    float tt;\n    float t;\n    float t1;\n    float t2;\n    float t3;\n    \n    // total time [0,1]\n    tt = fract(iTime/period);\n    //tt = mix(0.,tt,ss( 0., 3., iTime));\n    //tt = muv.x;\n    //tt = fragCoord.x/iResolution.x;\n    \n    #define SECTION_W 1.\n    #define DD 3.\n    tt *= 4.;\n    \n    // section time, the .9 mult is a workaround to make zoom more seamless\n    t  = (clamp( tt, 0.*SECTION_W, 1.*SECTION_W) - 0.*SECTION_W)/SECTION_W;\n    t1 = (clamp( tt, 1.*SECTION_W, 2.*SECTION_W) - 1.*SECTION_W)/SECTION_W;\n    t2 = (clamp( tt, 2.*SECTION_W, 3.*SECTION_W) - 2.*SECTION_W)/SECTION_W;\n    t3 = (clamp( tt, 3.*SECTION_W, 4.*SECTION_W) - 3.*SECTION_W)/SECTION_W;\n       \n    // Came to this experimenting trying to make zoom more linear\n          \n    // Tip from user mla\n \tvec2 uv0 = uv*startScale*exp(-t*log(scaleDiv));\n \tvec2 uv1 = uv*startScale*exp(-t1*log(scaleDiv));\n \tvec2 uv2 = uv*startScale*exp(-t2*log(scaleDiv));\n \tvec2 uv3 = uv*startScale*exp(-t3*log(scaleDiv));\n    \n    vec2 yy = vec2(0.);\n    vec2 newYY;\n    \n    float crossfade = .0001;\n    float softness = .0001;\n    \n    vec2 yy0 = connectYYs(uv0, softness, startScale, scaleDiv)*window(1.*SECTION_W/2., tt, SECTION_W/2., crossfade);\n\n    uv1 = rot(uv1, PI/2.);\n    vec2 yy1 = connectYYs(uv1, softness, startScale, scaleDiv)*window(3.*SECTION_W/2., tt, SECTION_W/2., crossfade);\n    \n    uv2 = rot(uv2, PI);\n    vec2 yy2 = connectYYs(uv2, softness, startScale, scaleDiv)*window(5.*SECTION_W/2., tt, SECTION_W/2., crossfade);\n\n    uv3 = rot(uv3, 3.*PI/2.);\n    vec2 yy3 = connectYYs(uv3, softness, startScale, scaleDiv)*window(7.*SECTION_W/2., tt, SECTION_W/2., crossfade);\n    \n    \n    // Stitching the 4 parts to make it a loop\n    yy = yy0 + yy1 + yy2 + yy3;\n    \n    // delineate yy\n    if(iTime < period/4.)\n        yy *= yy.y;\n    \n    fragColor = vec4(yy.x);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd2cDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[101, 101, 157, 157, 214], [216, 216, 244, 244, 339], [342, 342, 406, 406, 466], [468, 558, 603, 603, 869], [872, 963, 1015, 1015, 1579], [1581, 1646, 1712, 1712, 2905], [2907, 2972, 3048, 3048, 3872], [3875, 3875, 3932, 3982, 6204]], "test": "valid"}
{"id": "wd2cDt", "name": "Party Parrots", "author": "simatten", "description": "party!!!", "tags": ["raymarching"], "likes": 1, "viewed": 362, "published": "Public API", "date": "1587550514", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n  vec3 p;\n  vec2 r=iResolution.xy;\n  float t=iTime;\n  float d,l,b1,b2,R=1.57;\n  \n  fragColor=vec4(.1,.3,.6,1.);\n  for(int i=0;i<77;i++)\n  {\n    p=vec3((gl_FragCoord.xy-r*.5)/r.y,1.)*l;\n    p.yz*=mat2(cos(-.2+vec4(0,-R,R,0)));\n    p+=vec3(0,3.,t);\n    p.y=mod(p.y-1.5,6.)-3.;\n    p.xz=mod(p.xz,1.)-.5;\n    b1=length(p-vec3(sin(t*R*12.)/5.,cos(t*R*12.)/8.-2.82,.0))-.1;\n    b2=length(p-vec3(0,-3.1,.0))-.2;\n    d=min(b1,b2);\n    l+=d;\n    if(d<.01||b1+b2<.19){fragColor+=vec4(sin(vec3(R*4./3.,R/3.*8.,0)+p.x+l*9.+t*30.)*2.+2.,1)/(l);break;};\n  }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd2cDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 608]], "test": "error"}
{"id": "Wd2cDy", "name": "Subsurface Scattering Approx", "author": "sanjanarao", "description": "CIS461 University of Pennsylvania\n\nBottom and Right hemisphere materials subsurface scatter. The left hemisphere is a solid lambert material for contrast.", "tags": ["cis461"], "likes": 0, "viewed": 94, "published": "Public", "date": "1587364651", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int RAY_STEPS = 256;\nconst vec3 lightPos = vec3(0., 3., 3.);\nconst vec3 eyePos = vec3(0.0, 2., -20.0);\nconst vec3 refPos = vec3(0., 2.5, 0.);\nconst float PI = 3.14159265359;\nconst float FOVY = 19.5 * PI / 180.;\n\n// Toggle ATTENUATION \nconst bool ATTENUATION = false;\n// Adjust these to alter where the subsurface glow shines through and how brightly\nconst float FIVETAP_K = 2.0;\nconst float AO_DIST = 0.085;\n\n// The larger the DISTORTION, the smaller the glow\nconst float DISTORTION = 0.2;\n// The higher GLOW is, the smaller the glow of the subsurface scattering\nconst float GLOW = 6.0;\n// The higher the BSSRDF_SCALE, the brighter the scattered light\nconst float BSSRDF_SCALE = 3.0;\n// Boost the shadowed areas in the subsurface glow with this\nconst float AMBIENT = 0.0;\n// Toggle this to affect how easily the subsurface glow propagates through an object\n\nstruct Intersection\n{\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n};\n\n/***************** BASIC SCENE SET UP *******************/\n    \n#define FLOOR_SDF plane(pos, vec4(0, 1, 0, 2.5));\n#define LEFT_WALL_SDF plane(pos, vec4(1, 0, 0, 5));\n#define RIGHT_WALL_SDF plane(pos, vec4(-1, 0, 0, 5));\n#define BACK_WALL_SDF plane(pos, vec4(0, 0, -1, 5));\n#define CEILING_SDF plane(pos, vec4(0, -1, 0, 7.5));\n#define GROUND_SPHERE_SDF sphere(rotateY(pos + vec3(0., 2.5, 0.), 27.5 * 3.14/180.0), 4., vec3(-2.0, 0.0, -3.0));\n#define RIGHT_SPHERE_SDF sphere(pos + vec3(0., 2.5, 0.), 4., vec3(5.0, 7.0, -5.0));\n#define LEFT_SPHERE_SDF sphere(pos + vec3(0, 2.5, 0.), 4., vec3(-5.0, 7.0, -5.0));\n    \nconst int FLOOR_ID = 0;\nconst int LEFT_WALL_ID = 1;\nconst int RIGHT_WALL_ID = 2;\nconst int BACK_WALL_ID = 3;\nconst int CEILING_ID = 4;\nconst int GROUND_SPHERE_ID = 5;\nconst int RIGHT_SPHERE_ID = 6;\nconst int LEFT_SPHERE_ID = 7;\n\n\nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\n// Box with side lengths b\nfloat box(vec3 p, vec3 b)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat plane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sphere(vec3 p, float r, vec3 c) {\n    return distance(p, c) - r;\n}\n\nfloat sceneMap3D(vec3 pos) {\n    float flr = FLOOR_SDF;\n    float left_wall = LEFT_WALL_SDF;\n    float right_wall = RIGHT_WALL_SDF;\n    float back_wall = BACK_WALL_SDF;\n    float ceiling = CEILING_SDF;\n    float ground_sphere = GROUND_SPHERE_SDF;\n    float right_sphere = RIGHT_SPHERE_SDF;\n    float left_sphere = LEFT_SPHERE_SDF;\n    return min(back_wall, min(left_wall, min(right_wall, \n       min(ceiling, min(flr, min(ground_sphere, min(right_sphere, left_sphere)))))));\n}\n\nvoid sceneMap3D(vec3 pos, out float t, out int obj) {\n    t = FLOOR_SDF;\n    obj = FLOOR_ID;\n\n    float t2 = LEFT_WALL_SDF\n    if (t2 < t) {\n        t = t2;\n        obj = LEFT_WALL_ID;\n    } \n    t2 = RIGHT_WALL_SDF;\n    if (t2 < t) {\n        t = t2;\n        obj = RIGHT_WALL_ID;\n    }\n    t2 = BACK_WALL_SDF;\n    if (t2 < t) {\n        t = t2;\n        obj = BACK_WALL_ID;\n    }\n    t2 = CEILING_SDF;\n    if (t2 < t) {\n        t = t2;\n        obj = CEILING_ID;\n    }\n    t2 = GROUND_SPHERE_SDF;\n    if (t2 < t) {\n        t = t2;\n        obj = GROUND_SPHERE_ID;\n    }\n    t2 = RIGHT_SPHERE_SDF\n    if (t2 < t) {\n        t = t2;\n        obj = RIGHT_SPHERE_ID;\n    }\n    t2 = LEFT_SPHERE_SDF;\n    if (t2 < t) {\n        t = t2;\n        obj = LEFT_SPHERE_ID;\n    }\n}\n\n/***************** RAY MARCHING LOGIC *******************/\n\nvec3 rayCast(vec3 eye, vec3 ref, vec2 uv) {\n\n    float len = tan(FOVY) * distance(eye, ref);\n    vec3 H = normalize(cross(vec3(0.0, 1.0, 0.0), ref - eye));\n    vec3 V = normalize(cross(H, eye - ref));\n    V *= len;\n    H *= len * iResolution.x / iResolution.y;\n    vec3 p = ref + uv.x * H + uv.y * V;\n    return normalize(p - eye);\n}\n\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj)\n{\n    t = 0.001;\n    for(int i = 0; i < RAY_STEPS; ++i)\n    {\n        vec3 pos = origin + t * dir;\n        float m;\n        sceneMap3D(pos, m, hitObj);\n        if(m < 0.01) { return; }\n        t += m;\n    }\n    t = -1.0;\n    hitObj = -1;\n}\n\n/***************** EFFECTS *******************/\n\nfloat fiveTapAO(vec3 p, vec3 n, float k) {\n    float aoSum = 0.0;\n    for(float i = 0.0; i < 5.0; ++i) {\n        float coeff = 1.0 / pow(2.0, i);\n        aoSum += coeff * (i * AO_DIST - sceneMap3D(p + n * i * AO_DIST));\n    }\n    return 1.0 - k * aoSum;\n}\nfloat subsurface(vec3 lightDir, vec3 normal, vec3 viewVec, float thickness) {\n    vec3 scatteredLightDir = lightDir + normal * DISTORTION;\n    float lightReachingEye = pow(clamp(dot(viewVec, -scatteredLightDir), 0.0, 1.0), GLOW) * BSSRDF_SCALE;   \n    float attenuation = 1.0;\n    if (ATTENUATION) { attenuation = max(0.0, dot(normal, lightDir) + dot(viewVec, -lightDir)); }\n\tfloat totalLight = attenuation * (lightReachingEye + AMBIENT) * thickness;\n    return totalLight;\n}\n\n/***************** MATERIALS *******************/\n\nvec3 computeNormal(vec3 pos)\n{\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( sceneMap3D(pos + epsilon.yxx) - sceneMap3D(pos - epsilon.yxx),\n                            sceneMap3D(pos + epsilon.xyx) - sceneMap3D(pos - epsilon.xyx),\n                            sceneMap3D(pos + epsilon.xxy) - sceneMap3D(pos - epsilon.xxy)));\n}\n\nvec3 computeMaterial(int hitObj, vec3 p, vec3 nor, vec3 lightDir, vec3 view, float thick) {\n    float lambert = max(0., dot(lightDir, nor));\n    \n    if (hitObj == GROUND_SPHERE_ID) {\n       vec3 color = vec3(1.0, 0.88, 0.7) * vec3(1.0, 0.67, 0.67) * max(0.0, dot(nor, lightDir));\n       return color + vec3(1.0, 0.67, 0.67) * subsurface(lightDir, nor, view, thick) * vec3(1.0, 0.88, 0.7);\n    } else if (hitObj == RIGHT_SPHERE_ID) {         \n       vec3 color = vec3(0.45, 0.45, 1.0) * vec3(1.0, 0.67, 0.67) * max(0.0, dot(nor, lightDir));\n       return color + vec3(0.45, 0.45, 1.0) * subsurface(lightDir, nor, view, thick) * vec3(1.0, 0.88, 0.7);\n    } else {\n        return vec3(0.15, 0.15, 1.0)  * lambert;\n    }\n}\n\n/***************** BASIC FUNCTIONALITY *******************/\n\nIntersection sdf3D(vec3 dir, vec3 eye)\n{\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj);\n\n    vec3 isect = eye + t * dir;\n    vec3 nor = normalize(computeNormal(isect));\n\n    //oscillating light\n    float radius = 3.;\n    \n    float x  = 5. + radius * cos(iTime);\n    float z  = 2. + radius * sin(iTime);\n      \n    vec3 lightDir = normalize(vec3(x,3.,z) - isect);\n\n    //SSS logic\n    float thickness = fiveTapAO(isect, -nor, FIVETAP_K);\n    vec3 surfaceColor = computeMaterial(hitObj, isect, nor, lightDir, normalize(eye - isect), thickness);\n    \n    return Intersection(t, surfaceColor, isect, hitObj);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //Convert to range [-1,1]\n    uv = uv * 2.0 - vec2(1.);\n    \n    vec3 eye = eyePos;\n    vec3 ref = refPos;\n\n    vec3 dir = rayCast(eye, ref, uv);\n    \n    Intersection isect = sdf3D(dir, eye);\n     \n    // Output to screen\n    fragColor = vec4(isect.color, 1.);\n    \n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd2cDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1789, 1789, 1820, 1820, 1903], [1905, 1932, 1959, 1959, 2046], [2048, 2048, 2079, 2105, 2136], [2138, 2138, 2177, 2177, 2210], [2212, 2212, 2240, 2240, 2688], [3512, 3512, 3555, 3555, 3845], [3848, 3848, 3912, 3912, 4150], [4201, 4201, 4243, 4243, 4456], [4457, 4457, 4534, 4534, 4932], [4985, 4985, 5015, 5015, 5334], [5336, 5336, 5427, 5427, 6055], [6118, 6118, 6158, 6158, 6739], [6742, 6742, 6799, 6799, 7118]], "test": "valid"}
{"id": "Wd2cR1", "name": "Elliptic curve group operation", "author": "NinjaKoala", "description": "Visualization of the construction of the group operation on elliptic curves.\nSee header comment for a verbose explanation", "tags": ["2d", "math", "group", "ellipticcurve"], "likes": 5, "viewed": 227, "published": "Public API", "date": "1586110228", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nVisualization of the group structure construction\nfor an elliptic curve.\n\nGiven two points p and q on the curve,\np * q is the third intersection of the\nline through p and q with the curve.\n(Tangent if p=q)\n\nDefine 0 to be an inflection point of the curve.\n\nWe want an abelian (commutative) group on the points of the\ncurve such that 0 is the neutral element and\nfor three points p,q,r\np + q + r = 0 <=> p,q,r collinear\n\nFor a point p, define q := 0 * p\nThen p, q and 0 are collinear and therefore\np + 0 + q = 0 => p + q = 0 => -p = q = 0 * p\n\nSo if there is an inverse element, it has to be 0 * p\nfor each point p on the curve\n\nAssume there is indeed an inverse element, and\nlet now p,q be arbitrary points on the curve, then\np + q + (p*q) = 0 => p + q = -(p*q) = 0 * (p*q)\n\nSo the only operation \"+\" that fulfills the above requirements\nis defined by: p + q := 0 * (p * q)\n\nWe can now test if -p is indeed the inverse element:\np + (-p) = 0 * (p * (-p)) = 0 * (p * (0*p)) = 0 * 0\n                                \\_________/\n                                     v\n                                    = 0\n\nSo \"-p\" is an inverse exactly when 0 = 0 * 0,\nwhich means 0 is the only intersection of the\ncurves tangent in 0 with the curve,\nwhich is the defining property of an inflection point.\n\nFor a geometric proof of associativity, see:\nhttps://www.shadertoy.com/view/3djyz1\n\nNote:\nIt is standard to take the inflection point at infinity\nas neutral element. In that case, 0 * p\nbecomes the reflection of p at the x axis.\nThis leads to an particularly easy computation of\nthe operation. However, i decided to use an\ninflection point that can be actually seen.\n\nThe letters are from the Latin Modern font\n(https://en.wikipedia.org/wiki/Computer_Modern#Latin_Modern)\nconverted to shader with\nhttps://gist.github.com/Ninja-Koala/74fa7652fb4de248949ce1e27b989c14\n*/\n\n//#define ZERO 0\n#define ZERO min(0,iFrame)\n\nfloat border;\n\n// Modified from http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c\n// Credits to Doublefresh for hinting there\nint solve_quadric(vec2 coeffs, inout vec2 roots){\n\n\t// normal form: x^2 + px + q = 0\n\tfloat p = coeffs[1] / 2.;\n\tfloat q = coeffs[0];\n\n\tfloat D = p * p - q;\n\n\tif (D < 0.){\n\t\treturn 0;\n\t}\n\telse{\n\t\troots[0] = -sqrt(D) - p;\n\t\troots[1] = sqrt(D) - p;\n\n\t\treturn 2;\n\t}\n}\n\n//From Trisomie21\n//But instead of his cancellation fix i'm using a newton iteration\nint solve_cubic(vec3 coeffs, inout vec3 r){\n\n\tfloat a = coeffs[2];\n\tfloat b = coeffs[1];\n\tfloat c = coeffs[0];\n\n\tfloat p = b - a*a / 3.0;\n\tfloat q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n\tfloat p3 = p*p*p;\n\tfloat d = q*q + 4.0*p3 / 27.0;\n\tfloat offset = -a / 3.0;\n\tif(d >= 0.0) { // Single solution\n\t\tfloat z = sqrt(d);\n\t\tfloat u = (-q + z) / 2.0;\n\t\tfloat v = (-q - z) / 2.0;\n\t\tu = sign(u)*pow(abs(u),1.0/3.0);\n\t\tv = sign(v)*pow(abs(v),1.0/3.0);\n\t\tr[0] = offset + u + v;\t\n\n\t\t//Single newton iteration to account for cancellation\n\t\tfloat f = ((r[0] + a) * r[0] + b) * r[0] + c;\n\t\tfloat f1 = (3. * r[0] + 2. * a) * r[0] + b;\n\n\t\tr[0] -= f / f1;\n\n\t\treturn 1;\n\t}\n\tfloat u = sqrt(-p / 3.0);\n\tfloat v = acos(-sqrt( -27.0 / p3) * q / 2.0) / 3.0;\n\tfloat m = cos(v), n = sin(v)*1.732050808;\n\n\t//Single newton iteration to account for cancellation\n\t//(once for every root)\n\tr[0] = offset + u * (m + m);\n\tr[1] = offset - u * (n + m);\n\tr[2] = offset + u * (n - m);\n\n\tvec3 f = ((r + a) * r + b) * r + c;\n\tvec3 f1 = (3. * r + 2. * a) * r + b;\n\n\tr -= f / f1;\n\n\treturn 3;\n}\n\nfloat cubic_bezier_normal_iteration(float t, vec2 a0, vec2 a1, vec2 a2, vec2 a3){\n\t//horner's method\n\tvec2 a_2=a2+t*a3;\n\tvec2 a_1=a1+t*a_2;\n\tvec2 b_2=a_2+t*a3;\n\n\tvec2 uv_to_p=a0+t*a_1;\n\tvec2 tang=a_1+t*b_2;\n\n\tfloat l_tang=dot(tang,tang);\n\treturn t-dot(tang,uv_to_p)/l_tang;\n}\n\nfloat cubic_bezier_dis_approx_sq(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\tvec2 a3 = (-p0 + 3. * p1 - 3. * p2 + p3);\n\tvec2 a2 = (3. * p0 - 6. * p1 + 3. * p2);\n\tvec2 a1 = (-3. * p0 + 3. * p1);\n\tvec2 a0 = p0 - uv;\n\n\tfloat d0 = 1e38;\n\n\tfloat t;\n\tvec3 params=vec3(0,.5,1);\n\n\tif(all(lessThan(uv,max(max(p0,p1),max(p2,p3))+border)) && all(greaterThan(uv,min(min(p0,p1),min(p2,p3))-border))){\n\t\tfor(int i=ZERO;i<3;i++){\n\t\t\tt=params[i];\n\t\t\tfor(int j=ZERO;j<3;j++){\n\t\t\t\tt=cubic_bezier_normal_iteration(t,a0,a1,a2,a3);\n\t\t\t}\n\t\t\tt=clamp(t,0.,1.);\n\t\t\tvec2 uv_to_p=((a3*t+a2)*t+a1)*t+a0;\n\t\t\td0=min(d0,dot(uv_to_p,uv_to_p));\n\t\t}\n\t}\n\n\treturn d0;\n}\n\n//segment_dis_sq by iq\nfloat length2( vec2 v ) { return dot(v,v); }\n\nfloat segment_dis_sq( vec2 p, vec2 a, vec2 b ){\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length2( pa - ba*h );\n}\n\nint segment_int_test(vec2 uv, vec2 p0, vec2 p1){\n\tp0-=uv;\n\tp1-=uv;\n\n\tint ret;\n\t\n\tif(p0.y*p1.y<0.){\n\t\tvec2 nor=p0-p1;\n\t\tnor=vec2(nor.y,-nor.x);\n\t\t\n\t\tfloat sgn;\n\t\t\n\t\tif(p0.y>p1.y){\n\t\t\tsgn=1.;\n\t\t}\n\t\telse{\n\t\t\tsgn=-1.;\n\t\t}\n\n\t\tif(dot(nor,p0)*sgn<0.){\n\t\t\tret=0;\n\t\t}\n\t\telse{\n\t\t\tret=1;\n\t\t}\n\t}\n\telse{\n\t\tret=0;\n\t}\n\n\treturn ret;\n}\n\nint cubic_bezier_int_test(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\n\tfloat cu = (-p0.y + 3. * p1.y - 3. * p2.y + p3.y);\n\tfloat qu = (3. * p0.y - 6. * p1.y + 3. * p2.y);\n\tfloat li = (-3. * p0.y + 3. * p1.y);\n\tfloat co = p0.y - uv.y;\n\n\tvec3 roots = vec3(1e38);\n\tint n_roots;\n\n\tint n_ints=0;\n\n\tif(uv.x<min(min(p0.x,p1.x),min(p2.x,p3.x))){\n\t\tif(uv.y>=min(p0.y,p3.y) && uv.y<=max(p0.y,p3.y)){\n\t\t\tn_ints=1;\n\t\t}\n\t}\n\telse{\n\t\tif(abs(cu) < .0001){\n\t\t\tn_roots = solve_quadric(vec2(co/qu,li/qu),roots.xy);\n\t\t}\n\t\telse{\n\t\t\tn_roots = solve_cubic(vec3(co/cu,li/cu,qu/cu),roots);\n\t\t}\n\n\t\tfor(int i=ZERO;i<n_roots;i++){\n\t\t\tif(roots[i] >= 0. && roots[i] <= 1.){\n\t\t\t\tfloat x_pos = -p0.x + 3. * p1.x - 3. * p2.x + p3.x;\n\t\t\t\tx_pos = x_pos * roots[i] + 3. * p0.x - 6. * p1.x + 3. * p2.x;\n\t\t\t\tx_pos = x_pos * roots[i] + -3. * p0.x + 3. * p1.x;\n\t\t\t\tx_pos = x_pos * roots[i] + p0.x;\n\n\t\t\t\tif(x_pos > uv.x){\n\t\t\t\t\tn_ints++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn n_ints;\n}\n\nvec3 line(vec2 p_0, vec2 p_1){\n\tvec2 tan1 = p_1-p_0;\n\tvec2 nor1 = normalize(vec2(tan1.y,-tan1.x));\n\treturn vec3(nor1,-dot(nor1,p_0));\n}\n\nvec2 third_intersection(vec2 p0, vec2 p1, float g_2, float g_3){\n\tvec2 tang=p1-p0;\n\tfloat p0_val = p0.y*p0.y - (( 4.*p0.x*p0.x - g_2 ) * p0.x - g_3);\n\n\tfloat co=p0_val;\n\tfloat li=-12.*p0.x*p0.x*tang.x + g_2*tang.x + 2.*p0.y*tang.y;\n\tfloat qu=-12.*p0.x*tang.x*tang.x+tang.y*tang.y;\n\tfloat cu=-4.*tang.x*tang.x*tang.x;\n\n\tvec3 roots = vec3(1e38);\n\tint n_roots = solve_cubic(vec3(co/cu,li/cu,qu/cu),roots);\n\n\tvec2 p2=vec2(1e38);\n\n\tfor(int i=ZERO;i<n_roots;i++){\n\t\tvec2 tmp=p0+roots[i]*tang;\n\t\tif(distance(tmp,p0)>0.0001 && distance(tmp,p1)>0.0001){\n\t\t\tp2=tmp;\n\t\t}\n\t}\n\n\treturn p2;\n}\n\nfloat plus_dis_sq(vec2 uv){\n\tfloat dis_sq=1e38;\n\n\tint num_its=0;\n\n\tvec2[32] p=vec2[](vec2(0.0257924,-0.0),\n\t                  vec2(0.0257924,0.00155143),\n\t                  vec2(0.0243185,0.00155143),\n\t                  vec2(0.0232326,0.00155143),\n\t                  vec2(0.00159032,0.00155143),\n\t                  vec2(0.00159032,0.0232712),\n\t                  vec2(0.00159032,0.0243572),\n\t                  vec2(0.00159032,0.0258311),\n\t                  vec2(3.88912e-05,0.0258311),\n\t                  vec2(-0.00151253,0.0258311),\n\t                  vec2(-0.00151253,0.0243572),\n\t                  vec2(-0.00151253,0.0232712),\n\t                  vec2(-0.00151253,0.00155143),\n\t                  vec2(-0.0232323,0.00155143),\n\t                  vec2(-0.0243183,0.00155143),\n\t                  vec2(-0.0257922,0.00155143),\n\t                  vec2(-0.0257922,-0.0),\n\t                  vec2(-0.0257922,-0.00155143),\n\t                  vec2(-0.0243183,-0.00155143),\n\t                  vec2(-0.0232323,-0.00155143),\n\t                  vec2(-0.00151253,-0.00155143),\n\t                  vec2(-0.00151253,-0.0232712),\n\t                  vec2(-0.00151253,-0.0243572),\n\t                  vec2(-0.00151253,-0.0258311),\n\t                  vec2(3.88912e-05,-0.0258311),\n\t                  vec2(0.00159032,-0.0258311),\n\t                  vec2(0.00159032,-0.0243572),\n\t                  vec2(0.00159032,-0.0232712),\n\t                  vec2(0.00159032,-0.00155143),\n\t                  vec2(0.0232326,-0.00155143),\n\t                  vec2(0.0243185,-0.00155143),\n\t                  vec2(0.0257924,-0.00155143));\n\n\tivec2[8] seg=ivec2[](ivec2(3,4),\n\t                     ivec2(4,5),\n\t                     ivec2(11,12),\n\t                     ivec2(12,13),\n\t                     ivec2(19,20),\n\t                     ivec2(20,21),\n\t                     ivec2(27,28),\n\t                     ivec2(28,29));\n\n\tivec4[8] c_bez=ivec4[](ivec4(0,1,2,3),\n\t                       ivec4(5,6,7,8),\n\t                       ivec4(8,9,10,11),\n\t                       ivec4(13,14,15,16),\n\t                       ivec4(16,17,18,19),\n\t                       ivec4(21,22,23,24),\n\t                       ivec4(24,25,26,27),\n\t                       ivec4(29,30,31,0));\n\n\tif(all(lessThan(uv,vec2(0.0257924,0.0258311)+border)) && all(greaterThan(uv,vec2(-0.0257922,-0.0258311)-border))){\n\t\tfor(int i=ZERO;i<8;i++){\n\t\t\tdis_sq=min(dis_sq,segment_dis_sq(uv,p[seg[i][0]],p[seg[i][1]]));\n\t\t\tnum_its+=segment_int_test(uv,p[seg[i][0]],p[seg[i][1]]);\n\t\t}\n\t\tfor(int i=ZERO;i<8;i++){\n\t\t\tdis_sq=min(dis_sq,cubic_bezier_dis_approx_sq(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]));\n\t\t\tnum_its+=cubic_bezier_int_test(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]);\n\t\t}\n\t}\n\n\tfloat sgn=1.;\n\n\tif(num_its%2==1){\n\t\tsgn=-1.;\n\t}\n\n\treturn sgn*dis_sq;\n}\n\nfloat minus_dis_sq(vec2 uv){\n\tfloat dis_sq=1e38;\n\n\tint num_its=0;\n\n\tvec2[14] p=vec2[](vec2(0.0257924,-4.39771e-08),\n\t                  vec2(0.0257924,0.00155138),\n\t                  vec2(0.0243185,0.00155138),\n\t                  vec2(0.0232326,0.00155138),\n\t                  vec2(-0.0232323,0.00155138),\n\t                  vec2(-0.0243183,0.00155138),\n\t                  vec2(-0.0257922,0.00155138),\n\t                  vec2(-0.0257922,-4.39771e-08),\n\t                  vec2(-0.0257922,-0.00155143),\n\t                  vec2(-0.0243183,-0.00155143),\n\t                  vec2(-0.0231548,-0.00155143),\n\t                  vec2(0.023155,-0.00155143),\n\t                  vec2(0.0243185,-0.00155143),\n\t                  vec2(0.0257924,-0.00155143));\n\n\tivec2[2] seg=ivec2[](ivec2(3,4),\n\t                     ivec2(10,11));\n\n\tivec4[4] c_bez=ivec4[](ivec4(0,1,2,3),\n\t                       ivec4(4,5,6,7),\n\t                       ivec4(7,8,9,10),\n\t                       ivec4(11,12,13,0));\n\n\tif(all(lessThan(uv,vec2(0.0257924,0.00155138)+border)) && all(greaterThan(uv,vec2(-0.0257922,-0.00155143)-border))){\n\t\tfor(int i=ZERO;i<2;i++){\n\t\t\tdis_sq=min(dis_sq,segment_dis_sq(uv,p[seg[i][0]],p[seg[i][1]]));\n\t\t\tnum_its+=segment_int_test(uv,p[seg[i][0]],p[seg[i][1]]);\n\t\t}\n\t\tfor(int i=ZERO;i<4;i++){\n\t\t\tdis_sq=min(dis_sq,cubic_bezier_dis_approx_sq(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]));\n\t\t\tnum_its+=cubic_bezier_int_test(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]);\n\t\t}\n\t}\n\n\tfloat sgn=1.;\n\n\tif(num_its%2==1){\n\t\tsgn=-1.;\n\t}\n\n\treturn sgn*dis_sq;\n}\n\nfloat asterisk_dis_sq(vec2 uv){\n\tfloat dis_sq=1e38;\n\n\tint num_its=0;\n\n\tvec2[57] p=vec2[](vec2(0.0143119,-0.00725288),\n\t                  vec2(0.0143119,-0.0063996),\n\t                  vec2(0.0140015,-0.00577904),\n\t                  vec2(0.0126829,-0.00515847),\n\t                  vec2(0.00174542,-3.87878e-05),\n\t                  vec2(0.0125278,0.00508085),\n\t                  vec2(0.0140016,0.00577899),\n\t                  vec2(0.0143119,0.00632202),\n\t                  vec2(0.0143119,0.00725284),\n\t                  vec2(0.0143119,0.00826128),\n\t                  vec2(0.0134586,0.00942483),\n\t                  vec2(0.0122175,0.00942483),\n\t                  vec2(0.0116745,0.00942483),\n\t                  vec2(0.0115193,0.00942483),\n\t                  vec2(0.00950251,0.00795098),\n\t                  vec2(0.000892179,0.00159017),\n\t                  vec2(0.00205573,0.0147772),\n\t                  vec2(0.00205573,0.0159408),\n\t                  vec2(0.00104729,0.0167165),\n\t                  vec2(3.88912e-05,0.0167165),\n\t                  vec2(-0.00120223,0.0167165),\n\t                  vec2(-0.00205552,0.0157856),\n\t                  vec2(-0.00205552,0.0147772),\n\t                  vec2(-0.000891973,0.00159017),\n\t                  vec2(-0.0105107,0.00857154),\n\t                  vec2(-0.0115967,0.00942483),\n\t                  vec2(-0.0117519,0.00942483),\n\t                  vec2(-0.0122173,0.00942483),\n\t                  vec2(-0.0134584,0.00942483),\n\t                  vec2(-0.0143117,0.00826128),\n\t                  vec2(-0.0143117,0.00725284),\n\t                  vec2(-0.0143117,0.0063996),\n\t                  vec2(-0.0140012,0.00577899),\n\t                  vec2(-0.0126827,0.00515843),\n\t                  vec2(-0.00174522,3.87878e-05),\n\t                  vec2(-0.0125276,-0.0050809),\n\t                  vec2(-0.0140014,-0.00577904),\n\t                  vec2(-0.0143117,-0.00632202),\n\t                  vec2(-0.0143117,-0.00725288),\n\t                  vec2(-0.0143117,-0.00725288),\n\t                  vec2(-0.0143117,-0.00942487),\n\t                  vec2(-0.0117519,-0.00942487),\n\t                  vec2(-0.000891973,-0.00159021),\n\t                  vec2(-0.00205552,-0.0147772),\n\t                  vec2(-0.00205552,-0.0159408),\n\t                  vec2(-0.00104708,-0.0167165),\n\t                  vec2(-3.86845e-05,-0.0167165),\n\t                  vec2(0.00120244,-0.0167165),\n\t                  vec2(0.00205573,-0.0157857),\n\t                  vec2(0.00205573,-0.0147772),\n\t                  vec2(0.000892179,-0.00159021),\n\t                  vec2(0.0109764,-0.00895942),\n\t                  vec2(0.0113642,-0.00919206),\n\t                  vec2(0.0115969,-0.00942487),\n\t                  vec2(0.0122175,-0.00942487),\n\t                  vec2(0.0134586,-0.00942487),\n\t                  vec2(0.0143119,-0.00826128));\n\n\tivec2[12] seg=ivec2[](ivec2(3,4),\n\t                      ivec2(4,5),\n\t                      ivec2(14,15),\n\t                      ivec2(15,16),\n\t                      ivec2(22,23),\n\t                      ivec2(23,24),\n\t                      ivec2(33,34),\n\t                      ivec2(34,35),\n\t                      ivec2(41,42),\n\t                      ivec2(42,43),\n\t                      ivec2(49,50),\n\t                      ivec2(50,51));\n\n\tivec4[15] c_bez=ivec4[](ivec4(0,1,2,3),\n\t                        ivec4(5,6,7,8),\n\t                        ivec4(8,9,10,11),\n\t                        ivec4(11,12,13,14),\n\t                        ivec4(16,17,18,19),\n\t                        ivec4(19,20,21,22),\n\t                        ivec4(24,25,26,27),\n\t                        ivec4(27,28,29,30),\n\t                        ivec4(30,31,32,33),\n\t                        ivec4(35,36,37,38),\n\t                        ivec4(38,39,40,41),\n\t                        ivec4(43,44,45,46),\n\t                        ivec4(46,47,48,49),\n\t                        ivec4(51,52,53,54),\n\t                        ivec4(54,55,56,0));\n\n\tif(all(lessThan(uv,vec2(0.0143119,0.0167165)+border)) && all(greaterThan(uv,vec2(-0.0143117,-0.0167165)-border))){\n\t\tfor(int i=ZERO;i<12;i++){\n\t\t\tdis_sq=min(dis_sq,segment_dis_sq(uv,p[seg[i][0]],p[seg[i][1]]));\n\t\t\tnum_its+=segment_int_test(uv,p[seg[i][0]],p[seg[i][1]]);\n\t\t}\n\t\tfor(int i=ZERO;i<15;i++){\n\t\t\tdis_sq=min(dis_sq,cubic_bezier_dis_approx_sq(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]));\n\t\t\tnum_its+=cubic_bezier_int_test(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]);\n\t\t}\n\t}\n\n\tfloat sgn=1.;\n\n\tif(num_its%2==1){\n\t\tsgn=-1.;\n\t}\n\n\treturn sgn*dis_sq;\n}\n\nfloat zero_dis_sq(vec2 uv){\n\tfloat dis_sq=1e38;\n\n\tint num_its=0;\n\n\tvec2[48] p=vec2[](vec2(0.0163288,-0.000155151),\n\t                  vec2(0.0163288,0.00605055),\n\t                  vec2(0.0159409,0.0122562),\n\t                  vec2(0.013226,0.0179964),\n\t                  vec2(0.0096577,0.0254432),\n\t                  vec2(0.00329689,0.0266843),\n\t                  vec2(3.89352e-05,0.0266843),\n\t                  vec2(-0.00461534,0.0266843),\n\t                  vec2(-0.010278,0.0246675),\n\t                  vec2(-0.0134584,0.0174534),\n\t                  vec2(-0.0159407,0.012101),\n\t                  vec2(-0.0163286,0.00605055),\n\t                  vec2(-0.0163286,-0.000155151),\n\t                  vec2(-0.0163286,-0.00597297),\n\t                  vec2(-0.0160181,-0.0129543),\n\t                  vec2(-0.0128379,-0.0188497),\n\t                  vec2(-0.00950234,-0.0251329),\n\t                  vec2(-0.00383967,-0.0266843),\n\t                  vec2(-3.86845e-05,-0.0266843),\n\t                  vec2(0.00415014,-0.0266843),\n\t                  vec2(0.0100455,-0.0250554),\n\t                  vec2(0.0134586,-0.0176862),\n\t                  vec2(0.0159409,-0.0123337),\n\t                  vec2(0.0163287,-0.00628323),\n\t                  vec2(0.00989038,0.000775669),\n\t                  vec2(0.00989038,-0.00504211),\n\t                  vec2(0.00989038,-0.0103169),\n\t                  vec2(0.00903714,-0.0152815),\n\t                  vec2(0.00787359,-0.0226507),\n\t                  vec2(0.003452,-0.0249778),\n\t                  vec2(-3.86405e-05,-0.0249778),\n\t                  vec2(-0.00306392,-0.0249778),\n\t                  vec2(-0.00764062,-0.0230385),\n\t                  vec2(-0.00903685,-0.0155917),\n\t                  vec2(-0.00989013,-0.0109375),\n\t                  vec2(-0.00989013,-0.00380099),\n\t                  vec2(-0.00989013,0.000775669),\n\t                  vec2(-0.00989013,0.00574025),\n\t                  vec2(-0.00989013,0.0108599),\n\t                  vec2(-0.00926957,0.0150488),\n\t                  vec2(-0.00779577,0.0242797),\n\t                  vec2(-0.0019779,0.0249778),\n\t                  vec2(-3.86405e-05,0.0249778),\n\t                  vec2(0.00252114,0.0249778),\n\t                  vec2(0.00764087,0.0235816),\n\t                  vec2(0.00911472,0.015902),\n\t                  vec2(0.00989038,0.0115581),\n\t                  vec2(0.00989038,0.00566267));\n\n\tivec4[16] c_bez=ivec4[](ivec4(0,1,2,3),\n\t                        ivec4(3,4,5,6),\n\t                        ivec4(6,7,8,9),\n\t                        ivec4(9,10,11,12),\n\t                        ivec4(12,13,14,15),\n\t                        ivec4(15,16,17,18),\n\t                        ivec4(18,19,20,21),\n\t                        ivec4(21,22,23,0),\n\t                        ivec4(24,25,26,27),\n\t                        ivec4(27,28,29,30),\n\t                        ivec4(30,31,32,33),\n\t                        ivec4(33,34,35,36),\n\t                        ivec4(36,37,38,39),\n\t                        ivec4(39,40,41,42),\n\t                        ivec4(42,43,44,45),\n\t                        ivec4(45,46,47,24));\n\n\tif(all(lessThan(uv,vec2(0.0163288,0.0266843)+border)) && all(greaterThan(uv,vec2(-0.0163286,-0.0266843)-border))){\n\t\tfor(int i=ZERO;i<16;i++){\n\t\t\tdis_sq=min(dis_sq,cubic_bezier_dis_approx_sq(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]));\n\t\t\tnum_its+=cubic_bezier_int_test(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]);\n\t\t}\n\t}\n\n\tfloat sgn=1.;\n\n\tif(num_its%2==1){\n\t\tsgn=-1.;\n\t}\n\n\treturn sgn*dis_sq;\n}\n\nfloat p_dis_sq(vec2 uv){\n\tfloat dis_sq=1e38;\n\n\tint num_its=0;\n\n\tvec2[84] p=vec2[](vec2(0.0192376,0.0125665),\n\t                  vec2(0.0192376,0.0208666),\n\t                  vec2(0.0145834,0.0246675),\n\t                  vec2(0.00992917,0.0246675),\n\t                  vec2(0.00612818,0.0246675),\n\t                  vec2(0.00279265,0.021875),\n\t                  vec2(0.000543133,0.0192375),\n\t                  vec2(-0.000387731,0.0237367),\n\t                  vec2(-0.00387846,0.0246675),\n\t                  vec2(-0.00581768,0.0246675),\n\t                  vec2(-0.00861022,0.0246675),\n\t                  vec2(-0.0101616,0.0228834),\n\t                  vec2(-0.0114028,0.0205563),\n\t                  vec2(-0.0128766,0.0174535),\n\t                  vec2(-0.013885,0.0127216),\n\t                  vec2(-0.013885,0.0127216),\n\t                  vec2(-0.013885,0.0119459),\n\t                  vec2(-0.0131093,0.0119459),\n\t                  vec2(-0.0127215,0.0119459),\n\t                  vec2(-0.0117131,0.0119459),\n\t                  vec2(-0.0116355,0.0120233),\n\t                  vec2(-0.0112477,0.0137301),\n\t                  vec2(-0.00985139,0.01916),\n\t                  vec2(-0.0083775,0.022961),\n\t                  vec2(-0.00597287,0.022961),\n\t                  vec2(-0.00395599,0.022961),\n\t                  vec2(-0.00395599,0.0207114),\n\t                  vec2(-0.00395599,0.0198581),\n\t                  vec2(-0.00395599,0.0193927),\n\t                  vec2(-0.00395599,0.0181516),\n\t                  vec2(-0.00449902,0.0159796),\n\t                  vec2(-0.0133421,-0.0195478),\n\t                  vec2(-0.0139626,-0.0219525),\n\t                  vec2(-0.0145832,-0.0221852),\n\t                  vec2(-0.0176085,-0.0222628),\n\t                  vec2(-0.0183066,-0.0222628),\n\t                  vec2(-0.0192375,-0.0222628),\n\t                  vec2(-0.0192375,-0.0237366),\n\t                  vec2(-0.0192375,-0.0242796),\n\t                  vec2(-0.0188496,-0.0246675),\n\t                  vec2(-0.0183066,-0.0246675),\n\t                  vec2(-0.0162122,-0.0246675),\n\t                  vec2(-0.0139626,-0.0244348),\n\t                  vec2(-0.0117906,-0.0244348),\n\t                  vec2(-0.0093084,-0.0244348),\n\t                  vec2(-0.00667101,-0.0246675),\n\t                  vec2(-0.00426629,-0.0246675),\n\t                  vec2(-0.00380088,-0.0246675),\n\t                  vec2(-0.00279244,-0.0246675),\n\t                  vec2(-0.00279244,-0.0231936),\n\t                  vec2(-0.00279244,-0.0222628),\n\t                  vec2(-0.00356816,-0.0222628),\n\t                  vec2(-0.00465413,-0.0222628),\n\t                  vec2(-0.00861027,-0.0222628),\n\t                  vec2(-0.00861027,-0.0217974),\n\t                  vec2(-0.00861027,-0.0210216),\n\t                  vec2(-0.00861027,-0.0205562),\n\t                  vec2(-0.00806728,-0.0185394),\n\t                  vec2(-0.00775698,-0.0172983),\n\t                  vec2(-0.00496443,-0.00597293),\n\t                  vec2(-0.00442145,-0.00729163),\n\t                  vec2(-0.00248219,-0.010472),\n\t                  vec2(0.00155153,-0.010472),\n\t                  vec2(0.0100067,-0.010472),\n\t                  vec2(0.0192376,0.00100844),\n\t                  vec2(0.00969645,-0.00139623),\n\t                  vec2(0.00876563,-0.00333553),\n\t                  vec2(0.00543005,-0.00876552),\n\t                  vec2(0.00147395,-0.00876552),\n\t                  vec2(-0.00302517,-0.00876552),\n\t                  vec2(-0.00380088,-0.00217194),\n\t                  vec2(-0.00380088,-0.00155138),\n\t                  vec2(-0.00380088,-0.00131874),\n\t                  vec2(-0.00372348,-0.00108597),\n\t                  vec2(-0.00356825,-0.000465454),\n\t                  vec2(7.75911e-05,0.0141955),\n\t                  vec2(0.000698152,0.0168328),\n\t                  vec2(0.00550754,0.022961),\n\t                  vec2(0.00977393,0.022961),\n\t                  vec2(0.0132646,0.022961),\n\t                  vec2(0.0140403,0.0185394),\n\t                  vec2(0.0140403,0.0160572),\n\t                  vec2(0.0140403,0.0127992),\n\t                  vec2(0.011946,0.00356826));\n\n\tivec2[3] seg=ivec2[](ivec2(30,31),\n\t                     ivec2(58,59),\n\t                     ivec2(74,75));\n\n\tivec4[27] c_bez=ivec4[](ivec4(0,1,2,3),\n\t                        ivec4(3,4,5,6),\n\t                        ivec4(6,7,8,9),\n\t                        ivec4(9,10,11,12),\n\t                        ivec4(12,13,14,15),\n\t                        ivec4(15,16,17,18),\n\t                        ivec4(18,19,20,21),\n\t                        ivec4(21,22,23,24),\n\t                        ivec4(24,25,26,27),\n\t                        ivec4(27,28,29,30),\n\t                        ivec4(31,32,33,34),\n\t                        ivec4(34,35,36,37),\n\t                        ivec4(37,38,39,40),\n\t                        ivec4(40,41,42,43),\n\t                        ivec4(43,44,45,46),\n\t                        ivec4(46,47,48,49),\n\t                        ivec4(49,50,51,52),\n\t                        ivec4(52,53,54,55),\n\t                        ivec4(55,56,57,58),\n\t                        ivec4(59,60,61,62),\n\t                        ivec4(62,63,64,0),\n\t                        ivec4(65,66,67,68),\n\t                        ivec4(68,69,70,71),\n\t                        ivec4(71,72,73,74),\n\t                        ivec4(75,76,77,78),\n\t                        ivec4(78,79,80,81),\n\t                        ivec4(81,82,83,65));\n\n\tif(all(lessThan(uv,vec2(0.0192376,0.0246675)+border)) && all(greaterThan(uv,vec2(-0.0192375,-0.0246675)-border))){\n\t\tfor(int i=ZERO;i<3;i++){\n\t\t\tdis_sq=min(dis_sq,segment_dis_sq(uv,p[seg[i][0]],p[seg[i][1]]));\n\t\t\tnum_its+=segment_int_test(uv,p[seg[i][0]],p[seg[i][1]]);\n\t\t}\n\t\tfor(int i=ZERO;i<27;i++){\n\t\t\tdis_sq=min(dis_sq,cubic_bezier_dis_approx_sq(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]));\n\t\t\tnum_its+=cubic_bezier_int_test(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]);\n\t\t}\n\t}\n\n\tfloat sgn=1.;\n\n\tif(num_its%2==1){\n\t\tsgn=-1.;\n\t}\n\n\treturn sgn*dis_sq;\n}\n\nfloat q_dis_sq(vec2 uv){\n\tfloat dis_sq=1e38;\n\n\tint num_its=0;\n\n\tvec2[74] p=vec2[](vec2(0.00981294,-0.0231936),\n\t                  vec2(0.00981294,-0.0222628),\n\t                  vec2(0.00903727,-0.0222628),\n\t                  vec2(0.00795126,-0.0222628),\n\t                  vec2(0.00399516,-0.0222628),\n\t                  vec2(0.00399516,-0.0217974),\n\t                  vec2(0.00399516,-0.0210216),\n\t                  vec2(0.00399516,-0.0204787),\n\t                  vec2(0.0041504,-0.0200908),\n\t                  vec2(0.0042278,-0.0196254),\n\t                  vec2(0.014855,0.0227283),\n\t                  vec2(0.0149324,0.0229609),\n\t                  vec2(0.0150876,0.0237367),\n\t                  vec2(0.0150876,0.0237367),\n\t                  vec2(0.0150876,0.0244348),\n\t                  vec2(0.0144671,0.02459),\n\t                  vec2(0.0142344,0.02459),\n\t                  vec2(0.0133811,0.02459),\n\t                  vec2(0.0105885,0.021875),\n\t                  vec2(0.00934736,0.019703),\n\t                  vec2(0.00841654,0.0219525),\n\t                  vec2(0.0063997,0.0246675),\n\t                  vec2(0.00267629,0.0246675),\n\t                  vec2(-0.00593408,0.0246675),\n\t                  vec2(-0.0150874,0.0128768),\n\t                  vec2(-0.0150874,0.00155143),\n\t                  vec2(-0.0150874,-0.00504211),\n\t                  vec2(-0.0115192,-0.010472),\n\t                  vec2(-0.00570136,-0.010472),\n\t                  vec2(-0.00252097,-0.010472),\n\t                  vec2(0.000349194,-0.00845522),\n\t                  vec2(0.00252114,-0.00636081),\n\t                  vec2(0.000969711,-0.0124113),\n\t                  vec2(0.00104729,-0.0124113),\n\t                  vec2(-0.000504094,-0.0185394),\n\t                  vec2(-0.00135738,-0.0218749),\n\t                  vec2(-0.00143491,-0.0221852),\n\t                  vec2(-0.00639949,-0.0222628),\n\t                  vec2(-0.00740793,-0.0222628),\n\t                  vec2(-0.00826122,-0.0222628),\n\t                  vec2(-0.00826122,-0.0237366),\n\t                  vec2(-0.00826122,-0.0244348),\n\t                  vec2(-0.00779577,-0.0246675),\n\t                  vec2(-0.00725278,-0.0246675),\n\t                  vec2(-0.00477054,-0.0246675),\n\t                  vec2(-0.00205552,-0.0244348),\n\t                  vec2(0.000504345,-0.0244348),\n\t                  vec2(0.00306412,-0.0244348),\n\t                  vec2(0.00585671,-0.0246675),\n\t                  vec2(0.008339,-0.0246675),\n\t                  vec2(0.00880441,-0.0246675),\n\t                  vec2(0.00981277,-0.0246675),\n\t                  vec2(0.00407269,-0.000155107),\n\t                  vec2(0.00345218,-0.00255978),\n\t                  vec2(-0.00127972,-0.00876548),\n\t                  vec2(-0.00554612,-0.00876548),\n\t                  vec2(-0.00919191,-0.00876548),\n\t                  vec2(-0.00981247,-0.00418878),\n\t                  vec2(-0.00981247,-0.00186164),\n\t                  vec2(-0.00981247,0.00201688),\n\t                  vec2(-0.0074078,0.0110927),\n\t                  vec2(-0.00601153,0.0143506),\n\t                  vec2(-0.00407227,0.0190825),\n\t                  vec2(-0.000504007,0.022961),\n\t                  vec2(0.00267642,0.022961),\n\t                  vec2(0.00329698,0.022961),\n\t                  vec2(0.00508109,0.0228836),\n\t                  vec2(0.00647736,0.0207114),\n\t                  vec2(0.00725308,0.0194703),\n\t                  vec2(0.00802879,0.0172207),\n\t                  vec2(0.00802879,0.0157469),\n\t                  vec2(0.00802879,0.0155143),\n\t                  vec2(0.00795139,0.0152039),\n\t                  vec2(0.00779615,0.0147385));\n\n\tivec2[2] seg=ivec2[](ivec2(9,10),\n\t                     ivec2(73,52));\n\n\tivec4[24] c_bez=ivec4[](ivec4(0,1,2,3),\n\t                        ivec4(3,4,5,6),\n\t                        ivec4(6,7,8,9),\n\t                        ivec4(10,11,12,13),\n\t                        ivec4(13,14,15,16),\n\t                        ivec4(16,17,18,19),\n\t                        ivec4(19,20,21,22),\n\t                        ivec4(22,23,24,25),\n\t                        ivec4(25,26,27,28),\n\t                        ivec4(28,29,30,31),\n\t                        ivec4(31,32,33,34),\n\t                        ivec4(34,35,36,37),\n\t                        ivec4(37,38,39,40),\n\t                        ivec4(40,41,42,43),\n\t                        ivec4(43,44,45,46),\n\t                        ivec4(46,47,48,49),\n\t                        ivec4(49,50,51,0),\n\t                        ivec4(52,53,54,55),\n\t                        ivec4(55,56,57,58),\n\t                        ivec4(58,59,60,61),\n\t                        ivec4(61,62,63,64),\n\t                        ivec4(64,65,66,67),\n\t                        ivec4(67,68,69,70),\n\t                        ivec4(70,71,72,73));\n\n\tif(all(lessThan(uv,vec2(0.0150876,0.0246675)+border)) && all(greaterThan(uv,vec2(-0.0150874,-0.0246675)-border))){\n\t\tfor(int i=ZERO;i<2;i++){\n\t\t\tdis_sq=min(dis_sq,segment_dis_sq(uv,p[seg[i][0]],p[seg[i][1]]));\n\t\t\tnum_its+=segment_int_test(uv,p[seg[i][0]],p[seg[i][1]]);\n\t\t}\n\t\tfor(int i=ZERO;i<24;i++){\n\t\t\tdis_sq=min(dis_sq,cubic_bezier_dis_approx_sq(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]));\n\t\t\tnum_its+=cubic_bezier_int_test(uv,p[c_bez[i][0]],p[c_bez[i][1]],p[c_bez[i][2]],p[c_bez[i][3]]);\n\t\t}\n\t}\n\n\tfloat sgn=1.;\n\n\tif(num_its%2==1){\n\t\tsgn=-1.;\n\t}\n\n\treturn sgn*dis_sq;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tfloat aspect_ratio = iResolution.x / iResolution.y;\n\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv-=.5;\n\tuv.x *= aspect_ratio;\n\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n\tmouse-=.5;\n\tmouse.x *= iResolution.x / iResolution.y;\n\n\tvec2 mouse2 = iMouse.zw / iResolution.xy;\n\tmouse2-=.5;\n\tmouse2.x *= iResolution.x / iResolution.y;\n\n\tconst float line_width = .001;\n\tconst float curve_width = .001;\n\tconst float dot_size = .005;\n\n\tconst float axis_width = .005;\n\n\tconst vec3 bg_col = vec3(1,1,1);\n\tconst vec3 axis_col = vec3(0,0,0);\n\tconst vec3 line_col = vec3(0,1,0);\n\tconst vec3 second_line_col = vec3(1,1,0);\n\tconst vec3 curve_col = vec3(0,0,1);\n\tconst vec3 dot_col = vec3(1,0,0);\n\tconst vec3 text_col = vec3(0,0,0);\n\n    border = 2./iResolution.y;\n\n\tfloat curve_dis = 1e38;\n\tfloat second_curve_dis = 1e38;\n\tfloat dot_dis = 1e38;\n\tfloat axis_dis = 1e38;\n\tfloat line_dis = 1e38;\n\tfloat second_line_dis = 1e38;\n\tfloat text_dis_sq = 1e38;\n\tfloat text_dis = 1e38;\n\n\t//elliptic curve parameters (weierstrass normal form)\n\tfloat g_2 = .3;\n\tfloat g_3 = -.05;\n\n\t//initial approximations for various points (not exactly lying on the curve)\n\t//you can play around with these values, but the gradient descent\n\t//can get unstable if the points are too far away from the curve\n\n\tvec2 p0=vec2(0.043,-0.193); //0: the inflection point\n\tvec2 p1=vec2(-.3,.05*sin(mod(iTime,6.28318530717959))); //p\n\tvec2 p2=vec2(.1,-.1); //q\n\n\t//compute points lying exactly on the curve by gradient descent\n\tconst int grad_descent_iterations=8;\n\tfloat p0_val, hesse_p0_val, p1_val, p2_val;\n\tvec2 p0_grad, hesse_p0_grad, p1_grad, p2_grad;\n\n\tfor(int i=ZERO;i<grad_descent_iterations;i++){\n\t\tp0_val = p0.y*p0.y - (( 4.*p0.x*p0.x - g_2 ) * p0.x - g_3);\n\t\tp0_grad = vec2(-12.*p0.x*p0.x+g_2,2.*p0.y);\n\t\tp0-=(p0_grad*p0_val)/dot(p0_grad,p0_grad);\n\n\t\t//compute inflection point by alternately gradient descenting to curve and hessian of curve\n\t\thesse_p0_val = -96.*g_2*p0.x*p0.x + 96.*p0.x*p0.y*p0.y - 8.*g_2*g_2 - 288.*g_3*p0.x;\n\t\thesse_p0_grad = vec2(-192.*g_2*p0.x + 96.*p0.y*p0.y - 288.*g_3,192.*p0.x*p0.y);\n\t\tp0-=(hesse_p0_grad*hesse_p0_val)/dot(hesse_p0_grad,hesse_p0_grad);\n\n\t\tp1_val = p1.y*p1.y - (( 4.*p1.x*p1.x - g_2 ) * p1.x - g_3);\n\t\tp1_grad = vec2(-12.*p1.x*p1.x+g_2,2.*p1.y);\n\t\tp1-=(p1_grad*p1_val)/dot(p1_grad,p1_grad);\n\n\t\tp2_val = p2.y*p2.y - (( 4.*p2.x*p2.x - g_2 ) * p2.x - g_3);\n\t\tp2_grad = vec2(-12.*p2.x*p2.x+g_2,2.*p2.y);\n\t\tp2-=(p2_grad*p2_val)/dot(p2_grad,p2_grad);\n\t}\n\n\tvec2 p3=third_intersection(p1,p2,g_2,g_3); //p*q\n\tvec2 p4=third_intersection(p0,p3,g_2,g_3); //p+q\n\tvec2 p5=third_intersection(p0,p1,g_2,g_3); //-p\n\n\tdot_dis=min(dot_dis,distance(p0,uv)-dot_size); //0\n\tdot_dis=min(dot_dis,distance(p1,uv)-dot_size); //p\n\tdot_dis=min(dot_dis,distance(p2,uv)-dot_size); //q\n\tdot_dis=min(dot_dis,distance(p3,uv)-dot_size); //p*q\n\tdot_dis=min(dot_dis,distance(p4,uv)-dot_size); //p+q\n\tdot_dis=min(dot_dis,distance(p5,uv)-dot_size); //-p\n\n\tvec3 l0=line(p1,p2);\n\tvec3 l1=line(p0,p4);\n\n\tline_dis=min(line_dis,abs(dot(vec3(uv,1),l0)));\n\tline_dis=min(line_dis,abs(dot(vec3(uv,1),l1)));\n\n\tvec3 l2=line(p1,p5);\n\n\tp0_grad = vec2(-12.*p0.x*p0.x+g_2,2.*p0.y);\n\tvec3 tangent=vec3(normalize(p0_grad),0);\n\ttangent.z=-dot(p0,tangent.xy);\n\n\tsecond_line_dis=min(second_line_dis,abs(dot(vec3(uv,1),l2)));\n\tsecond_line_dis=min(second_line_dis,abs(dot(vec3(uv,1),tangent)));\n\n\tfloat uv_val = uv.y*uv.y - (( 4.*uv.x*uv.x - g_2 ) * uv.x - g_3);\n\tvec2 uv_grad = vec2(-12.*uv.x*uv.x+g_2,2.*uv.y);\n\n\tcurve_dis=min(curve_dis, abs(uv_val)/length(uv_grad)-curve_width);\n\n\taxis_dis=min(axis_dis, abs(uv.x));\n\taxis_dis=min(axis_dis, abs(uv.y));\n\n\tvec2[4] p_positions=vec2[](vec2(.03,.05)-p1,vec2(-.04,-.03)-p3,vec2(.13,.03)-p4,vec2(.03,.03)-p5);\n\tvec2[3] q_positions=vec2[](vec2(-.01,-.05)-p2,p_positions[1]+vec2(-.1,.0),p_positions[2]+vec2(-.1,.0));\n\n\tvec2 plus_position=p_positions[2]+vec2(-.05,1e-7);\n\tvec2 minus_position=p_positions[3]+vec2(.05,1e-7);\n\tvec2 zero_position=vec2(.003,.0425)-p0;\n\tvec2 asterisk_position=p_positions[1]+vec2(-.05,0.);\n\n\ttext_dis_sq=min(text_dis_sq,plus_dis_sq(uv+plus_position));\n\ttext_dis_sq=min(text_dis_sq,minus_dis_sq(uv+minus_position));\n\ttext_dis_sq=min(text_dis_sq,asterisk_dis_sq(uv+asterisk_position));\n\ttext_dis_sq=min(text_dis_sq,zero_dis_sq(uv+zero_position));\n\n\tfor(int i=ZERO;i<4;i++){\n\t\ttext_dis_sq=min(text_dis_sq,p_dis_sq(uv+p_positions[i]));\n\t}\n\tfor(int i=ZERO;i<3;i++){\n\t\ttext_dis_sq=min(text_dis_sq,q_dis_sq(uv+q_positions[i]));\n\t}\n\n\ttext_dis=sign(text_dis_sq)*sqrt(abs(text_dis_sq));\n\n\tvec3 color = bg_col;\n\n\tcolor=vec3(mix(axis_col,color,smoothstep(0., border, axis_dis)));\n\tcolor=vec3(mix(line_col,color,smoothstep(0., border, line_dis)));\n\tcolor=vec3(mix(second_line_col,color,smoothstep(0., border, second_line_dis)));\n\tcolor=vec3(mix(curve_col,color,smoothstep(0., border, curve_dis)));\n\tcolor=vec3(mix(dot_col,color,smoothstep(0., border, dot_dis)));\n\tcolor=vec3(mix(text_col,color,smoothstep(-border/2., border/2., text_dis)));\n\n\tfragColor = vec4(color,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd2cR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1921, 2042, 2091, 2126, 2306], [2308, 2393, 2436, 2436, 3445], [3447, 3447, 3528, 3547, 3722], [3724, 3724, 3802, 3802, 4360], [4362, 4385, 4410, 4410, 4429], [4431, 4431, 4478, 4478, 4589], [4591, 4591, 4639, 4639, 4909], [4911, 4911, 4982, 4982, 5846], [5848, 5848, 5878, 5878, 5983], [5985, 5985, 6049, 6049, 6562]], "test": "valid"}
{"id": "Wd2cRG", "name": "Projective plane disk", "author": "NinjaKoala", "description": "Mapping the whole plane plus points at infinity to a finite disk.\nPoints on the border with the same color are the same points in the projective plane.", "tags": ["2d", "math", "geometry", "projective"], "likes": 5, "viewed": 244, "published": "Public API", "date": "1586867288", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nMapping of the projective plane to a disk.\n\nThe whole affine plane is mapped to the disk without border,\nthe border is the line at infinity. Two opposing points on\nthe disk border are corresponding to just one point in the\nprojective plane. I gave two opposing points the same color\nto emphasize this.\n\nBasically, the lines parallel to the x axis are\nan interpolation between the x axis and the disk border,\nthose parallel to the y axis between y axis and disk border accordingly.\nEvery point can then be described as the intersection of two\nof those circles.\n(You can think of the disk border as third axis)\n\nThe animation shows how ellipses are those conic sections without\nintersections with the line at infinity,\nparabolas are those with exactly one intersection, and\nhyperbolas those with exactly two intersections.\n\n(Or optionally a triangle where one point is movable with mouse)\n(Or optionally an elliptic curve whose parameters you can change with mouse)\n\nI got the basic idea of the mapping from a prof of mine,\ni derived the exact formulas myself. I don't know\nhow this mapping is called, but this has certainly been done\nbefore.\n*/\n\n//#define TRIANGLE\n//#define ELLIPTIC_CURVE\n\nconst float pi=3.14159265358979;\n\nconst float eps=.000001;\n\nconst float t0=2.00001;\nconst float t1=4.00002;\nconst float t2=7.00003;\nconst float t3=9.00004;\nconst float tt=11.00005;\n//the perturbations are a workaround for https://gitlab.freedesktop.org/mesa/mesa/issues/2610\n\nfloat sgn(float a){\n\tif(a<0.){\n\t\treturn -1.;\n\t}\n\telse{\n\t\treturn 1.;\n\t}\n}\n\nvec2 from_projective(vec3 p, float stretch_factor, float radius, out vec2 int_p2){\n\tvec2 int_p;\n\n\tfloat a=p.x*p.x+p.y*p.y;\n\tfloat b=p.z*p.x/(stretch_factor*stretch_factor);\n\tfloat c=-p.x*p.x*radius*radius;\n\n\tfloat int_x=(-b+sgn(p.x)*sqrt(b*b-4.*a*c))/(2.*a);\n\tfloat int_y=int_x*p.y/p.x;\n\n\tint_p=vec2(int_x,int_y);\n\n\tif(abs(p.z)<eps){\n\t\tint_p2=-int_p;\n\t}\n\telse{\n\t\tint_p2=int_p;\n\t}\n\n\treturn int_p;\n}\n\nvec3 to_projective(vec2 p, float stretch_factor, float radius){\n\treturn vec3(p.xy,stretch_factor*stretch_factor*(radius*radius-dot(p,p)));\n}\n\nmat2x3 to_projective_jacobi(vec2 p, float stretch_factor, float radius){\n\tvec3 column1=vec3(1.,0.,-2.*stretch_factor*stretch_factor*p.x);\n\tvec3 column2=vec3(0.,1.,-2.*stretch_factor*stretch_factor*p.y);\n\n\treturn mat2x3(column1, column2);\n}\n\nfloat to_projective_line(float a, float b){\n\treturn -sgn(a)*sgn(b)*abs(a)/(abs(a)+abs(b));\n}\n\nvec2 from_projective_line(float a){\n\treturn vec2(a,1.-abs(a));\n}\n\nfloat line_dist(vec2 uv, const vec2 p0, vec2 p1){\n\tvec2 tang=p1-p0;\n\tvec2 nor=normalize(vec2(tang.y,-tang.x));\n\n\tif(dot(tang,uv)<dot(tang,p0)){\n\t\treturn distance(p0,uv);\n\t}\n\telse if(dot(tang,uv)>dot(tang,p1)){\n\t\treturn distance(p1,uv);\n\t}\n\telse{\n\t\treturn abs(dot(nor,uv)-dot(nor,p0));\n\t}\n}\n\nvec3 line(vec2 p_0, vec2 p_1){\n\tvec2 tan1 = p_1-p_0;\n\tvec2 nor1 = normalize(vec2(tan1.y,-tan1.x));\n\treturn vec3(nor1,-dot(nor1,p_0));\n}\n\nvec3 line(vec3 p_0, vec3 p_1){\n\treturn normalize(cross(p_0,p_1));\n}\n\n//mapping from barth's skript:\n//https://web.archive.org/web/20051104003320/http://www.mi.uni-erlangen.de/~barth/docs/geoset.ps (german)\n//it basically gives the formula and says:\n//by this formula, you see the projective plane can be bijectively mapped to a disk, but this is not too useful\n//the mapping does not have any favorably properties compared to the other one, i just implemented it for reference\nvec2 from_projective_barth(vec3 p, float radius, out vec2 int_p2){\n\tvec2 int_p = 2.*radius/pi*p.xy*atan(dot(p.xy,p.xy)/(p.z*p.z))/length(p.xy);\n\n\tif(abs(p.z)<eps){\n\t\tint_p=radius*normalize(p.xy);\n\t\tint_p2=-int_p;\n\t}\n\telse{\n\t\tint_p2=int_p;\n\t}\n\n\treturn int_p;\n}\n\nvec3 to_projective_barth(vec2 p, float radius){\n\treturn vec3(p.xy*sqrt(tan(pi/(2.*radius)*length(p))),length(p));\n}\n\nmat2x3 to_projective_jacobi_barth(vec2 p, float radius){\n\tfloat fac=pi/(2.*radius);\n\tfloat len=length(p);\n\n\tfloat tmp=tan(len*fac);\n\n\tfloat a11=.5*(tmp*tmp + 1.)*fac*p.x*p.x/(len*sqrt(tmp)) + sqrt(tmp);\n\tfloat a12=.5*(tmp*tmp + 1.)*fac*p.x*p.y/(len*sqrt(tmp));\n\tfloat a22=.5*(tmp*tmp + 1.)*fac*p.y*p.y/(len*sqrt(tmp)) + sqrt(tmp);\n\n\tvec3 column1=vec3(a11,a12,p.x/len);\n\tvec3 column2=vec3(a12,a22,p.y/len);\n\n\treturn mat2x3(column1,column2);\n}\n\n//elliptic degree is the same but for lines instead of points\nfloat elliptic_distance(vec3 p1, vec3 p2){\n\treturn acos(1./sqrt(dot(p1,p1)*dot(p2,p2))*dot(p1,p2));\n}\n\nfloat spectral(float x){\n        return clamp(abs(mod((x/pi+1.)*4.,8.)-4.)-2.,-.75,.75)*.5/.75+.5;\n}\n\nvec3 to_col(vec2 z){\n\tfloat direction = 2.*atan(z.x,z.y);\n\treturn vec3(spectral(direction),spectral(direction+pi/2.),spectral(direction-pi));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv-=.5;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n\tmouse-=.5;\n\tmouse.x *= iResolution.x / iResolution.y;\n\n\tvec2 mouse2 = iMouse.zw / iResolution.xy;\n\tmouse2-=.5;\n\tmouse2.x *= iResolution.x / iResolution.y;\n    \n    #ifdef TRIANGLE\n    float animation=1.;\n    #else\n    #ifdef ELLIPTIC_CURVE\n    float animation=1.;\n    #else\n    float animation;\n    \n    float tc=abs(mod(iTime-tt,2.*tt)-tt);\n    \n    if(tc<t1){\n        animation=exp(mix(5.,0.,smoothstep(0.,t0,tc)));\n    }\n    else if(tc<.5*(t1+t2)){\n        animation=exp(mix(0.,5.,smoothstep(t1,.5*(t1+t2),tc)));\n    }\n    else if(tc<t3){\n        animation=exp(mix(5.,0.,smoothstep(.5*(t1+t2),t2,tc)));\n    }\n    else{\n        animation=exp(mix(0.,5.,smoothstep(t3,tt,tc)));\n    }\n    #endif\n    #endif\n    \n    float stretch_factor=1./animation;\n    float radius=.47*animation;\n\n\tconst float line_width = .001;\n\tconst float circle_width = .003;\n\tconst float grid_width = .0;\n\tconst float curve_width = .001;\n\tconst float dot_size = .005;\n\tconst float axis_width = .005;\n\n\tconst float grid_size = .8;\n\n\tconst vec3 bg_col = vec3(1,1,1);\n\tconst vec3 axis_col = vec3(0,0,0);\n\tconst vec3 grid_col = vec3(.75);\n\tconst vec3 line_col = vec3(0,1,0);\n\tconst vec3 curve_col = vec3(0,0,1);\n\tconst vec3 dot_col = vec3(1,0,0);\n\n\tvec3 circle_col = to_col(uv);\n\n    float border = 2./iResolution.y;\n\n\tfloat curve_dis = 1e38;\n\tfloat dot_dis = 1e38;\n\tfloat axis_dis = 1e38;\n\tfloat grid_dis = 1e38;\n\tfloat line_dis = 1e38;\n\tfloat circle_dis = 1e38;\n\n\tvec3 color=bg_col;\n\n\tcircle_dis=min(circle_dis,abs(length(uv)-radius)-circle_width);\n\n\taxis_dis=min(axis_dis,line_dist(uv,vec2(0,radius),vec2(0,-radius))-line_width);\n\taxis_dis=min(axis_dis,line_dist(uv,vec2(radius,0),vec2(-radius,0))-line_width);\n\n\tvec3 uv_p=to_projective(uv,stretch_factor,radius);\n\n\tmat2x3 jac=to_projective_jacobi(uv,stretch_factor,radius);\n\n    #ifdef TRIANGLE\n\tvec2 m0=normalize(mouse)*min(length(mouse),radius);\n\tvec3 p0=to_projective(m0,stretch_factor,radius);\n\tvec3 p1=vec3(2.7,2.2,1.);\n\tvec3 p2=vec3(2.,-2.,1.);\n    \n    vec2 int_p;\n\tvec2 int_p2;\n\n\tint_p = from_projective(p0,stretch_factor,radius,int_p2);\n\n\tdot_dis=min(dot_dis,distance(uv,int_p)-dot_size);\n\tdot_dis=min(dot_dis,distance(uv,int_p2)-dot_size);\n\n\tint_p = from_projective(p1,stretch_factor,radius,int_p2);\n\n\tdot_dis=min(dot_dis,distance(uv,int_p)-dot_size);\n\tdot_dis=min(dot_dis,distance(uv,int_p2)-dot_size);\n\n\tint_p = from_projective(p2,stretch_factor,radius,int_p2);\n\n\tdot_dis=min(dot_dis,distance(uv,int_p)-dot_size);\n\tdot_dis=min(dot_dis,distance(uv,int_p2)-dot_size);\n    \n    vec3 l1=line(p0,p1);\n\tvec3 l2=line(p1,p2);\n\tvec3 l3=line(p2,p0);\n    \n\tcurve_dis=min(curve_dis,abs(dot(uv_p,l1)/length(l1*jac)));\n\tcurve_dis=min(curve_dis,abs(dot(uv_p,l2)/length(l2*jac)));\n\tcurve_dis=min(curve_dis,abs(dot(uv_p,l3)/length(l3*jac)));\n    #else\n    #ifdef ELLIPTIC_CURVE\n    \n\tfloat g_2 = 10.*mouse.x;\n\tfloat g_3 = 10.*mouse.y;\n\n\tfloat elliptic_curve_val=(4.*uv_p.x*uv_p.x-g_2*uv_p.z*uv_p.z)*uv_p.x-(g_3*uv_p.z*uv_p.z+uv_p.y*uv_p.y)*uv_p.z;\n\tvec3 elliptic_curve_grad=vec3(12.*uv_p.x*uv_p.x-g_2*uv_p.z*uv_p.z,-2.*uv_p.y*uv_p.z,(-3.*g_3*uv_p.z-2.*g_2*uv_p.x)*uv_p.z-uv_p.y*uv_p.y);\n    \n    curve_dis=min(curve_dis,abs(elliptic_curve_val/length(elliptic_curve_grad*jac)));\n    #else\n\tfloat hyperbola_val=8.*uv_p.x*uv_p.x-4.*uv_p.y*uv_p.y+uv_p.z*uv_p.z;\n\tvec3 hyperbola_grad=vec3(8.*2.*uv_p.x,-4.*2.*uv_p.y,+2.*uv_p.z);\n\n\tfloat parabola_val=uv_p.x*uv_p.x-uv_p.y*uv_p.z;\n\tvec3 parabola_grad=vec3(2.*uv_p.x,-uv_p.z,-uv_p.y);\n\n\tfloat circle_val=uv_p.x*uv_p.x+uv_p.y*uv_p.y-uv_p.z*uv_p.z;\n\tvec3 circle_grad=vec3(2.*uv_p.x,2.*uv_p.y,-2.*uv_p.z);\n    \n\tfloat mix_val;\n\tvec3 mix_grad;\n    \n    mix_val=mix(circle_val,parabola_val,smoothstep(t0,t1,tc));\n\tmix_grad=mix(circle_grad,parabola_grad,smoothstep(t0,t1,tc));\n    \n    if(tc>t2){\n        mix_val=mix(parabola_val,hyperbola_val,smoothstep(t2,t3,tc));\n\t\tmix_grad=mix(parabola_grad,hyperbola_grad,smoothstep(t2,t3,tc));\n    }\n\n\tcurve_dis=min(curve_dis,abs(mix_val/length(mix_grad*jac)));\n    #endif\n    #endif\n\n\tvec3 grid_grad=vec3(1./uv_p.z,0.,-uv_p.x/(uv_p.z*uv_p.z));\n\tgrid_dis = min(grid_dis, abs(mod(uv_p.x/uv_p.z-grid_size*.5,grid_size)-grid_size*.5)/length(grid_grad*jac)-grid_width);\n\tgrid_grad=vec3(0.,1./uv_p.z,-uv_p.y/(uv_p.z*uv_p.z));\n\tgrid_dis = min(grid_dis, abs(mod(uv_p.y/uv_p.z-grid_size*.5,grid_size)-grid_size*.5)/length(grid_grad*jac)-grid_width);\n\n\tfloat d0=length(uv)-radius;\n\n\tgrid_dis=max(d0,grid_dis);\n\tcurve_dis=max(d0,curve_dis);\n\n\tcolor=vec3(mix(grid_col,color,smoothstep(0., border, grid_dis)));\n\tcolor=vec3(mix(axis_col,color,smoothstep(0., border, axis_dis)));\n\tcolor=vec3(mix(line_col,color,smoothstep(0., border, line_dis)));\n\tcolor=vec3(mix(circle_col,color,smoothstep(0., border, circle_dis)));\n\tcolor=vec3(mix(curve_col,color,smoothstep(0., border, curve_dis)));\n\tcolor=vec3(mix(dot_col,color,smoothstep(0., border, dot_dis)));\n\n\tfragColor = vec4(color,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd2cRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1469, 1469, 1488, 1488, 1541], [1543, 1543, 1625, 1625, 1940], [1942, 1942, 2005, 2005, 2082], [2084, 2084, 2156, 2156, 2323], [2325, 2325, 2368, 2368, 2417], [2419, 2419, 2454, 2454, 2483], [2485, 2485, 2534, 2534, 2774], [2776, 2776, 2806, 2806, 2911], [2913, 2913, 2943, 2943, 2980], [2982, 3390, 3456, 3456, 3649], [3651, 3651, 3698, 3698, 3766], [3768, 3768, 3824, 3824, 4209], [4211, 4273, 4315, 4315, 4374], [4376, 4376, 4400, 4400, 4476], [4478, 4478, 4498, 4498, 4621], [4623, 4623, 4677, 4677, 9676]], "test": "valid"}
{"id": "wd2cRV", "name": "Day2: Heart Monitor", "author": "fluxatron", "description": "Had a crack at writing a pulse monitor. Has some issues but was fun anyways.\n\nIdeally I'd have an even width pulse line. Multipass rendering with glow effect. And a more accurate pulse shape.", "tags": ["noob"], "likes": 10, "viewed": 148, "published": "Public", "date": "1587014738", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst vec3 gamma = vec3(2.2);\n\n// Palette (RGB 2.2 color space)\nvec3 green = vec3(81.0/255.0, 201.0/255.0, 150.0/255.0);\nvec3 darkGreen = vec3(0.0/255.0, 40.0/255.0, 19.0/255.0);\nvec3 headGreen = vec3(223.0/255.0, 252.0/255.0, 226.0/255.0);\n\nfloat aspectRatio;\nvec2 uv;\nvec2 uvAspect;\n\n\nvec3 ACESFitted(vec3 color);\n\nvec3 circle(vec2 samplePoint, vec2 center, float radius)\n{\n    vec2 sampleDisp = samplePoint - center;\n    float sampleLen2 = sampleDisp.x*sampleDisp.x + sampleDisp.y*sampleDisp.y;\n    float ratio = sampleLen2 / (radius*radius);\n\n    return vec3(1.0 - min(ratio,1.0));\n}\nvec3 background()\n{\n    // Flat shade\n    vec3 col = darkGreen;\n    float intensity = 2.0;\n    \n    // Grid lines\n    {\n        float thickness = 0.003;\n        float spacing = 0.065;\n        \n        // Compute first line pos\n        float leftBound = 0.0;\n    \tfloat firstX = leftBound - fract(iTime*0.4)*spacing;\n        \n        // Vertical Grid Lines\n        for (float x = firstX; x < aspectRatio; x += spacing)\n        {\n            if (uvAspect.x > (x-thickness) && uvAspect.x < (x+thickness))\n            {\n                col += darkGreen;\n            }\n        }\n        \n\t\t// Horizontal Grid Lines\n        for (float y = 0.0; y < 1.0; y += spacing)\n        {\n            if (uvAspect.y > (y-thickness) && uvAspect.y < (y+thickness))\n            {\n                col += darkGreen;\n            }\n        }\n    }\n    \n    return col * intensity;\n}\nfloat shape(float x, float offset) // x:[0,1]\n{\n    x += offset;\n    if (x > 1.0) x -= floor(x);\n    \n    float s1 = 0.15;         // flat\n    float s2 = s1 + 0.2;     // b1\n    float s3 = s2 + 0.34;     // flat\n    float s4 = s3 + 0.1;     // b2\n    float s5 = s4 + 0.03;    // flat\n    float s6 = s5 + 0.2;     // b3\n    \n    float y = 0.0;\n    \n    if (x < s1) { return 0.0; }\n    \n    if (x < s2)\n    {\n    \treturn 0.05 - 0.05*cos((x-s1)*30.0);\n    }\n    \n    if (x < s3) { return 0.0; }\n    \n    if (x < s4)\n    {\n    \treturn 0.02 - 0.02*cos((x-s3)*60.0);\n    }\n    \n    if (x < s5) { return 0.0; }\n    \n    if (x < s6)\n    {\n    \treturn 0.3*sin((x-s5)*35.0);\n    }\n    \n    if (x > 1.0) return -.4;\n}\nfloat wrapIntensity(float sampleX, float xMax, float h)\n{\n    float v = sampleX + xMax - h; // wrap\n    if (v > xMax) v -= xMax; // clamp to [0,xMax]\n    return v/xMax; // normalize\n}\nvec3 line()\n{   \n    float repeats = 3.0;\n    float scanRate = 0.18;\n\tfloat intensity = 1.5;\n    float offset = iTime*0.1;\n    \n    vec3 col = vec3(0,0,0);\n    \n    // Calc head position\n    float x =  aspectRatio * (scanRate*iTime - floor(scanRate*iTime)); // x:[0,aspectRatio)\n\tfloat yOffset = 0.5;\n    \n    vec2 headPos = vec2(x, yOffset + shape(x * repeats/aspectRatio, offset));\n    vec2 linePos = vec2(uvAspect.x, yOffset + shape(uvAspect.x * repeats/aspectRatio, offset));\n    \n    // Line\n    float thickness = 0.015/2.0;\n    if (uv.y > linePos.y - thickness && uv.y < linePos.y + thickness)\n    {\n        col = green * pow(wrapIntensity(linePos.x, aspectRatio, headPos.x), 2.0);\n    }\n    \n    // Glowing Head\n    vec3 mask = pow(circle(uvAspect, headPos, 0.2), vec3(200.0));\n    col += 2.0 * headGreen * mask;\n    \n    return col * intensity;\n}\n\nvec3 vignette()\n{\n    float darkest = 0.00;\n    vec3 shade = circle(uvAspect, vec2(aspectRatio/2.0, 0.5), 0.85);\n    return darkest + (1.0-darkest)*shade;\n}\nvoid linearizePallete()\n{\n    green = pow(green, gamma);\n    darkGreen = pow(darkGreen, gamma);\n    headGreen = pow(headGreen, gamma);\n}\n\nvec3 flicker(vec3 col)\n{\n    return col * (1.0 + 0.03*sin(iTime*50.0) + 0.04*sin(iTime*29.0) ); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Globals\n    linearizePallete();\n    aspectRatio = iResolution.x / iResolution.y;\n    uv = fragCoord / iResolution.xy;       // w:[0,1], h:[0,1]\n    uvAspect = fragCoord / iResolution.yy; // w:[0,apsect], h:[0,1]\n    \n    // Set color\n    vec3 col = vec3(0,0,0);\n    col += background();\n    col += line();\n    col = flicker(col);\n    col *= vignette();\n    \n    // Post\n\tcol *= 1.5; // exposure bias\n  \tcol = ACESFitted(col); // tonemap \n    col = pow(col, 1.0/gamma); // gamma\n    \n    fragColor = vec4(col,1.0);\n}\n\n\n\n\n\n\n\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// ACES Tonemap: https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\n\nconst mat3 ACESInputMat = mat3(\n\t0.59719, 0.07600, 0.02840, \n\t0.35458, 0.90834, 0.13383,\n\t0.04823, 0.01566, 0.83777\n);\nconst mat3 ACESOutputMat = mat3(\n\t 1.60475, -0.10208, -0.00327,\n\t-0.53108,  1.10813, -0.07276,\n\t-0.07367, -0.00605,  1.07602\n);\nvec3 RRTAndODTFit(vec3 v)\n{\n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFitted(vec3 color)\n{\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit(color);\n\tcolor = ACESOutputMat * color;\n\tcolor = clamp(color,0.0,1.0);\n\treturn color;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd2cRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[318, 318, 376, 376, 588], [589, 589, 608, 626, 1446], [1447, 1447, 1494, 1494, 2153], [2154, 2154, 2211, 2211, 2337], [2338, 2338, 2351, 2351, 3192], [3194, 3194, 3211, 3211, 3350], [3351, 3351, 3376, 3376, 3487], [3489, 3489, 3513, 3513, 3587], [3589, 3589, 3646, 3661, 4169], [4635, 4635, 4662, 4662, 4777], [4778, 4778, 4807, 4807, 4948]], "test": "error"}
{"id": "wd2cWG", "name": "Julia in 3D", "author": "themasmo", "description": "this time Julia, (shame about the bad effect on the edges, i tried to remove it but failed).", "tags": ["3d", "juliafractal", "frattale"], "likes": 2, "viewed": 80, "published": "Public", "date": "1587286770", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 50.\n#define SURF_DIST .01\n#define MAXITE 32.0\n\nmat3 rotx(float a) { mat3 rot; rot[0] = vec3(1.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 1.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\n\nfloat formula(vec2 p) { // Plasma\n    vec3 col;\n    float t = iTime;\n    for(float j = 0.0; j < 3.0; j++){\n        for(float i = 1.0; i < 5.0; i++){\n            p.x += 0.1 / (i + j) * sin(i * 10.0 * p.y + t + cos((iTime / (12. * i)) * i + j));\n            p.y += 0.1 / (i + j)* cos(i * 10.0 * p.x + t + sin((iTime / (12. * i)) * i + j));\n        }\n        col[int(j)] = abs(p.x + p.y);\n    }\n    return (col.x+col.y+col.z)/3.;\n}\n\nfloat mandel(vec2 p) // or Julia\n{    \n    float zre=p.x*0.6;\n    float zim=p.y*0.7;\n    float cre=-0.8041213550817069;\n    float cim=0.14839772190510192;\n    float col=0.;\n\n    for(float i=0.;i<MAXITE;i++)\n    {\n        float dam=zre*zre-zim*zim+cre;\n        zim=2.0*zre*zim+cim;\n        zre=dam;\n        col++;\n        if( (zre*zre+zim*zim)>4.0 )\n            break;\n    }\n    \n    return (col/MAXITE);\n}\n\n\nfloat GetDist(vec3 p) {\n    float v=0.;\n    if(p.x>-7. && p.x<7. && p.z>-7. && p.z<7.)\n    \tv=0.5*mandel(p.xz/3.0);\n\tvec4 s1 = vec4(p.x,v*sin(iTime),p.z,0.8);\n  \n\tfloat cube = length(max(abs(p-s1.xyz)-vec3(0.5,0.5,0.5), 0.))/3.0;\n    float planeDist = p.y;\n    \n    float d = min(cube, planeDist);\n    return d;    \n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        \n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    float dif=0.;\n    if(p.x>-7. && p.x<7. && p.z>-7. && p.z<7.)\n    {\n\n        vec3 lightPos = vec3(0, 6, 2);\n        lightPos.xz += vec2(sin(iTime), cos(iTime))*4.;\n        vec3 l = normalize(lightPos-p);\n        vec3 n = GetNormal(p);\n\n        dif = clamp(dot(n, l), 0., 1.);\n    }\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0., 6, -8.5);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n\n    rd = rd*(rotx(0.4));\n    float d = RayMarch(ro, rd);\n\n    vec3 p = ro + rd * d;\n\n    float dif = GetLight(p);\n    col = vec3(dif);\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd2cWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[86, 86, 106, 106, 233], [234, 234, 254, 254, 381], [383, 383, 406, 416, 811], [813, 813, 847, 847, 1218], [1221, 1221, 1244, 1244, 1538], [1540, 1540, 1574, 1574, 1789], [1791, 1791, 1815, 1815, 2004], [2006, 2006, 2030, 2030, 2338], [2340, 2340, 2397, 2397, 2738]], "test": "valid"}
{"id": "wd2cWm", "name": "Cable Vortex", "author": "blinry", "description": "I'm quite happy with this, but there is some distortion going on in the background (most visible in the lower left). What can I do to avoid that? -> decreasing the step size to 70% as suggested by ilyaev helped a lot! :)", "tags": ["raymarching", "question", "cables"], "likes": 8, "viewed": 412, "published": "Public API", "date": "1586791609", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 cell;\nfloat g;\nfloat time;\nfloat pi = 3.14159;\n\nfloat noise(vec3 p) {\n    return fract(sin(dot(p, vec3(4.3243241, 34.234, 234.23))) * 342.234);\n}\n\nmat2 rotate(float r) { return mat2(cos(r), sin(r), -sin(r), cos(r)); }\n\nfloat scene(vec3 p) {\n    p.x += p.z * p.z * 0.02 * sin(time * 2. * pi);\n\n    p.z += time * 40. * pi;\n    p.xy *= rotate(p.z * 0.10);\n\n    vec3 cellsize = vec3(4, 4, 0);\n    cell = floor(p / cellsize);\n\n    p = mod(p, cellsize) - cellsize / 2.;\n\n    return length(p.xy) - 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    time = mod(iTime / 10., 1.);\n\n    vec3 cam = vec3(0, 0, -5);\n    vec3 dir = normalize(vec3(uv, 1));\n\n    float t = 0.;\n    for (int i = 0; i < 128; ++i) {\n        t += scene(cam + dir * t) * .7;\n        if (t < 0.0001 || t > 50.)\n            break;\n    }\n\n    vec3 h = cam + dir * t;\n    vec2 o = vec2(.001, 0);\n    vec3 n = normalize(vec3(scene(h + o.xyy) - scene(h - o.xyy),\n                            scene(h + o.yxy) - scene(h - o.yxy),\n                            scene(h + o.yyx) - scene(h - o.yyx)));\n\n    vec3 light = normalize(vec3(0, 1, 1));\n    float diffuse = max(0., dot(n, light));\n    vec3 albedo =\n        0.05 + 0.95 * vec3(noise(cell.xyy), noise(cell.yxy), noise(cell.yyx));\n    float specular = pow(max(dot(normalize(light + -dir), n), 0.), 10000.);\n    float ambient = 0.4;\n    float fresnel = min(0.5, pow(1. + dot(n, dir), 4.));\n    vec3 bg = vec3(0.001);\n    vec3 col = mix((ambient + diffuse) * albedo + specular * vec3(1, 0.5, 0.5),\n                   bg, fresnel);\n\n    col = mix(col, bg, 1. - exp(-.0001 * t * t * t)); // apply fog\n\n    col = pow(col, vec3(.454)); // gamma correction\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd2cWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 74, 74, 150], [152, 152, 174, 174, 222], [224, 224, 245, 245, 502], [504, 504, 561, 561, 1827]], "test": "valid"}
{"id": "wd2cWW", "name": "The Dyson Sphere", "author": "ZiMMaBuE", "description": "Dyson sphere", "tags": ["sphere", "reproduction", "dyson"], "likes": 11, "viewed": 172, "published": "Public", "date": "1586968676", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 64\n#define MAX_DIST 20.\n#define EPS 0.001\nconst float PI = acos(-1.0);\n\nmat3 rotX(float angle)\n{\n    return mat3(1,\t0,\t\t\t0,\n               0,\tcos(angle), -sin(angle),\n               0,\tsin(angle), cos(angle));\n}\n\nmat3 rotY(float angle)\n{\n\treturn mat3(cos(angle), 0, sin(angle),\n               0,\t\t\t1, 0,\n               -sin(angle), 0, cos(angle));\n}\n\nmat3 rotZ(float angle)\n{\n\treturn mat3(cos(angle), -sin(angle), 0,\n               sin(angle), \tcos(angle),\t 0,\n               0,\t\t \t0,\t\t\t 1);\n}\n\nvec2 opRevolution( in vec3 p, float w )\n{\n    return vec2( length(p.xz) - w, p.y );\n}\n\nfloat sdCube(vec2 pos, vec2 r)\n{\n\tvec2 q = abs(pos) - r;\n\treturn length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\nfloat sdCube(vec3 pos, vec3 r)\n{\n\tvec3 q = abs(pos) - r;\n\treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere(vec3 pos, float r)\n{\n    return length(pos) - r;\n}\n\nfloat sdRing(vec3 pos, float r)\n{\n    pos.zy = opRevolution(pos, r);\n    return sdCube(vec2(pos.z, pos.y), vec2(0.02, 0.03));\n}\n\nfloat sdRingsCross1( in vec3 pos, in float r )\n{\n    float d1 = sdRing(pos, r);\n    \n    pos *= rotZ(PI/2.);\n    float d2 = sdRing(pos, r);\n    \n    pos *= rotX(PI/2.);\n    float d3 = sdRing(pos, r);\n    \n    pos *= rotX(PI/4.);\n    float d4 = sdRing(pos, r);\n    \n    return min(d1,min(d2,min(d3,d4)));\n}\n\nfloat sdRingsCross2( in vec3 pos, in float r )\n{\n    pos *= rotZ(PI/4.);\n    float d1 = sdRing(pos, r);\n    \n    pos *= rotZ(PI/2.);\n    float d2 = sdRing(pos, r);\n    \n    return min(d1,d2);\n}\n\nfloat sdDysonSphere( in vec3 pos, in float r )\n{\n    float d1 = sdRingsCross1(pos, r);\n    \n    pos *= rotY(PI/4.);\n    float d2 = sdRingsCross2(pos, r);\n    \n    pos *= rotY(PI/2.);\n    float d3 = sdRingsCross2(pos, r);\n    \n    return min(d1, min(d2, d3));\n}\n\nfloat map(vec3 pos)\n{\n    \n    float d0 = sdSphere(pos, 0.2+sin(iTime*0.3)*0.05);\n    float d1 = sdDysonSphere(pos * rotY(iTime * 1.00), 0.5);\n    float d2 = sdDysonSphere(pos * rotY(iTime * 0.50), 0.7);\n    float d3 = sdDysonSphere(pos * rotY(iTime * 0.25), 0.9);\n    \n    float res = MAX_DIST;\n    res = min(res, d0);\n    res = min(res, d1);\n    res = min(res, d2);\n    res = min(res, d3);\n    return res;\n}\n\nvec3 normals(vec3 pos)\n{\n    vec2 e = vec2(0, 0.01);\n    return normalize(vec3(\n    \tmap(pos+e.yxx)-map(pos-e.yxx),\n        map(pos+e.xyx)-map(pos-e.xyx),\n        map(pos+e.xxy)-map(pos-e.xxy)\n    ));\n}\n\nconst vec4 miss = vec4(MAX_DIST, vec3(0));\nvec4 raymarch(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    for(int i = 0; i<MAX_STEPS; i++)\n    {\n        vec3 pos = ro + rd*t;\n        float d = map(pos);\n        \n        if(abs(d)<=EPS) return vec4(length(pos-ro), normals(pos));\n        if(d >= MAX_DIST) return miss;\n        \n        t+=d;\n    }\n         \n    \n    return miss;\n}\n\nconst vec3 BACKGROUND = vec3(0.2);\nvec3 GetScene(vec3 ro, vec3 rd)\n{\n    \n    vec4 a = raymarch(ro, rd);\n    float d = a.x;\n    vec3 nor = a.yzw;\n    \n    vec3 col = BACKGROUND;\n    \n    if(d < MAX_DIST)\n    {\n        vec3 pos = ro+rd*d;\n        \n        float li = dot(normalize(-pos), nor);\n        li = li*0.5+0.5;\n        li = li*0.9+0.1;\n        \n        col = vec3(1, 0.94, 0.8) * li;\n    }\n    \n    return col;\n    \n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.x;\n    \n    vec2 mouse = iMouse.xy / iResolution.xy;\n    float camAngle = PI/4.; // mouse.x*PI*2.;\n    vec2 p = 3.0 * vec2(cos(camAngle), sin(camAngle));\n    vec3 ro = vec3(p.x,1.5,p.y);\n    mat3 ca = setCamera(ro, vec3(0,0,0), 0.0);\n    vec3 rd = ca*normalize(vec3(uv,1.8));\n    \n    vec3 col = GetScene(ro, rd);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd2cWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[90, 90, 114, 114, 229], [231, 231, 255, 255, 367], [369, 369, 393, 393, 511], [513, 513, 554, 554, 598], [600, 600, 632, 632, 710], [712, 712, 744, 744, 831], [833, 833, 868, 868, 898], [900, 900, 933, 933, 1027], [1029, 1029, 1077, 1077, 1334], [1336, 1336, 1384, 1384, 1529], [1531, 1531, 1579, 1579, 1791], [1793, 1793, 1814, 1814, 2202], [2204, 2204, 2228, 2228, 2406], [2451, 2451, 2484, 2484, 2782], [2819, 2819, 2852, 2852, 3208], [3210, 3210, 3262, 3262, 3439], [3441, 3441, 3498, 3498, 3927]], "test": "error"}
{"id": "wd2yDm", "name": "Cracked", "author": "Kali", "description": "Marching a terrain with a dark mood, using trig functions and fractals. ", "tags": ["fractal", "terrain"], "likes": 25, "viewed": 314, "published": "Public", "date": "1586795449", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float st=.02, maxdist=8.,m,mc;\nvec3 ldir=vec3(-.5,-1.,-1.);\n\nmat2 rot(float a) {\n\tfloat s=sin(a),c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\nfloat map(vec2 p) {\n    float s=0.;\n    m=mc=100.;\n    float l2;\n    float y=(sin(p.x+cos(p.y*2.)+2.724)+cos(p.y))*8.;\n    vec2 mcol=vec2(100.);\n\tp=abs(.5-fract(p*.03));\n    y+=smoothstep(.5,.4,length(p.xy))*10.;\n    vec2 pos=p;\n    for (int i=0; i<6; i++) {\n    \tp=abs(p+1.)-abs(p-1.)-p;\n        float l=dot(p,p);\n        p=p*2./clamp(l,.25,1.)-pos;\n        s+=exp(-.3*abs(l-l2));\n        l2=l;\n        if (i>2 && i<5) m=min(min(abs(p.y),abs(p.x)),m);\n        mc=min(mc,l);\n    }\n    m=pow(max(0.,1.-m),6.);\n    return (y+s)*.05-m*.1;\n}\n\n\nvec3 normal(vec2 p) {\n\tvec2 eps=vec2(0.,.01);\n    return normalize(vec3(map(p+eps.yx)-map(p-eps.yx),2.*eps.y,map(p+eps.xy)-map(p-eps.xy)));\n}\n\nvec2 hit(vec3 p) {\n    float h=map(p.xz);\n    return vec2(step(p.y,h),h);\n}\n\nfloat fog(vec3 p,float h) {\n    p.y=p.y*2.-1.-h*1.5;\n    p.x+=p.z*1.234+iTime*.5;\n\tp=abs(2.-mod(p,4.));\n    for (int i; i<10; i++) {\n    \tp=abs(p)/dot(p,p)-.8;\n    }\n    return length(p);\n}\n\nvec3 bsearch(vec3 from, vec3 dir, float td) {\n    vec3 p;\n    st*=-.5;\n    td+=st;\n    float h2=1.;\n    for (int i=0; i<20; i++) {\n        p=from+td*dir;\n        float h=hit(p).x;\n        if (abs(h-h2)>.001) {\n            st*=-.5;\n\t        h2=h;\n        }\n        td+=st;\n    }\n\treturn p;\n}\n\nvec3 shade(vec3 p, vec3 dir, float h) {\n    float val = dot(sin(p*6. - cos(p.yzx*12.)*3.), vec3(.166)) + .5; // Or noise, etc.\n    vec3 ember = pow(vec3(1.6, 1, 1)*val, vec3(1, 8, 34)); // Poor man's fire palette. \n \tvec3 col = ember *m*pow(smoothstep(.3,.5,abs(.5-fract(mc*.5+h*.5+iTime*.5))),2.);\n\n    ldir=normalize(ldir);\n\tvec3 n=normal(p.xz);\n    vec3 ref=reflect(dir,ldir);\n    float spe=pow(max(0.,dot(ref,-n))*.5,3.)*2.5;\n    return col+spe;\n}\n\n\nvec3 march(vec3 from, vec3 dir) {\n\tvec3 p, col=vec3(0.);\n    float td=1., k=0.;\n    vec2 h;\n    for (int i=0; i<350; i++) {\n    \tp=from+dir*td;\n        h=hit(p);\n        k+=fog(p,h.y)*pow(max(0.,1.-abs(p.y-h.y)*.25),2.);\n        if (h.x > .5 || td>maxdist) break;\n        td+=st;\n    }\n    float f=pow(td/maxdist,2.);\n    if (h.x > .5) {\n        p=bsearch(from, dir, td);\n    \tcol=shade(p,dir,h.y);\n    } \n\tcol=mix(col,vec3(.2*(1.-p.y*.25)),f)*min(1.,iTime*.5);\n    return col*vec3(1.,.9,.8)+k*.0007;\n}\n\nmat3 lookat(vec3 dir, vec3 up) {\n\tdir=normalize(dir);vec3 rt=normalize(cross(dir,normalize(up)));\n    return mat3(rt,cross(rt,dir),dir);\n}\n\nvec3 path(float t) {\n\treturn vec3(sin(t*.2645)+cos(t*.1213)*2.,2.5+sin(t*.354)*.2,t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n\tfloat t=iTime+15.;\n    vec3 from=path(t);\n    vec3 dir=normalize(vec3(uv,1.));\n    vec3 adv=from-path(t-1.);\n    dir=lookat(adv+vec3(0.,-.5,0.),vec3(adv.x*.3,1.,0.))*dir;\n    vec3 col=march(from, dir);\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd2yDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 80, 80, 135], [137, 137, 156, 156, 674], [677, 677, 698, 698, 818], [820, 820, 838, 838, 895], [897, 897, 924, 924, 1086], [1088, 1088, 1133, 1133, 1378], [1380, 1380, 1419, 1419, 1831], [1834, 1834, 1867, 1867, 2336], [2338, 2338, 2370, 2370, 2476], [2478, 2478, 2498, 2498, 2565], [2567, 2567, 2624, 2624, 2918]], "test": "valid"}
{"id": "wd2yRG", "name": "Gotta Catch em All", "author": "Skatzogirous", "description": "teehee", "tags": ["gottacatchemall"], "likes": 1, "viewed": 179, "published": "Public API", "date": "1586882298", "time_retrieved": "2021-10-01T00:00:00", "image_code": "    \nstruct Material\n{\n    vec3 albedo;\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float shininess;\n    \n};\n    \nstruct Sphere\n{\n    vec3 center;\n    float radius;\n    Material material;\n};\n\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float aspect_ratio = iResolution.x/iResolution.y;\n    \n    uv.x *= aspect_ratio;\n\n\tSphere sph;   \n\n\tfloat outlineLength = 0.006;\n    sph.center = vec3(0.5,0.5,5.0);\n    sph.center.x *= aspect_ratio;\n    sph.radius = 0.3;\n    \n    sph.material.albedo = vec3(1.0,0.1,0.1);\n    \n    sph.material.ambient = vec3(0.52,0.52,0.52);\n    \n    sph.material.diffuse = vec3(0.1,0.1,0.1);\n    \n    sph.material.specular = vec3(0.52,0.52,0.52);\n    sph.material.shininess = 16.0;\n    \n    vec3 camera = vec3 (0.5,0.5,0.0);\n    \n    float centerDist = 0.23;\n    vec3 lightPos = vec3(9.0 * sin(iTime)*0.5,6.0 * cos(iTime)*0.5,-5.0);\n    vec3 lightColor = vec3(1.0);\n    \n    vec3 col = vec3(0.0);\n    if(length(uv - vec2(sph.center.x,sph.center.y)) < sph.radius - centerDist)\n    {\n        if(length(uv - vec2(sph.center.x,sph.center.y)) > sph.radius - centerDist-0.015)\n        {\n            float custom_z = (sph.center.z - sqrt(pow(sph.radius,2.0) - pow(uv.y - sph.center.y,2.0)));\n        \n        vec3 uv_3D = vec3(uv,custom_z);\n\t\n        vec3 ambient = vec3(0.0);\n        vec3 diffuse = vec3(0.0);\n        vec3 specular = vec3(0.0);\n        \n        ambient = sph.material.ambient * vec3(0.1,0.1,0.1) * lightColor;\n        \n        vec3 normal = normalize(uv_3D - sph.center);\n        vec3 lightDir = normalize(lightPos - uv_3D);\n        float diff = max(dot(normal, lightDir),0.0);\n        \n        \n        diffuse = sph.material.albedo * vec3(0.0,0.0,0.0) * lightColor * diff;\n        \n        vec3 viewDir = normalize(camera - uv_3D);\n        vec3 reflectDir = reflect(-lightDir,normal); //might need normalize\n        float spec = pow(max(dot(viewDir, reflectDir),0.0),sph.material.shininess);\n        specular = vec3(0.2,0.2,0.2) * spec;\n        \n        col = ambient + diffuse + specular;\n        }\n        else if(length(uv - vec2(sph.center.x,sph.center.y)) > sph.radius - centerDist-0.035)\n        {\n           float custom_z = (sph.center.z - sqrt(pow(sph.radius,2.0) - pow(uv.y - sph.center.y,2.0)) + 0.8);\n        \n        vec3 uv_3D = vec3(uv,custom_z);\n\t\n        vec3 ambient = vec3(0.0);\n        vec3 diffuse = vec3(0.0);\n        vec3 specular = vec3(0.0);\n        \n        ambient = sph.material.ambient * vec3(1.0,1.0,1.0) * lightColor;\n        \n        vec3 normal = normalize(uv_3D - sph.center);\n        vec3 lightDir = normalize(lightPos - uv_3D);\n        float diff = max(dot(normal, lightDir),0.0);\n        \n        \n        diffuse = sph.material.albedo * sph.material.diffuse * lightColor * diff;\n        \n        vec3 viewDir = normalize(camera - uv_3D);\n        vec3 reflectDir = reflect(-lightDir,normal); //might need normalize\n        float spec = pow(max(dot(viewDir, reflectDir),0.0),sph.material.shininess);\n        specular = sph.material.specular * spec;\n        \n        col = ambient + diffuse + specular;\n        }\n        else\n        {\n            float custom_z = sph.center.z - sqrt(pow(sph.radius,2.0) - pow(uv.y - sph.center.y,2.0) + 1.0);\n        \n        vec3 uv_3D = vec3(uv,custom_z);\n\t\n        vec3 ambient = vec3(0.0);\n        vec3 diffuse = vec3(0.0);\n        vec3 specular = vec3(0.0);\n        \n        ambient = sph.material.ambient * vec3(0.98,0.98,0.98) * lightColor;\n        \n        vec3 normal = normalize(uv_3D - sph.center);\n        vec3 lightDir = normalize(lightPos - uv_3D);\n        float diff = max(dot(normal, lightDir),0.0);\n        \n        \n        diffuse = sph.material.albedo * sph.material.diffuse * lightColor * diff;\n        \n        vec3 viewDir = normalize(camera - uv_3D);\n        vec3 reflectDir = reflect(-lightDir,normal); //might need normalize\n        float spec = pow(max(dot(viewDir, reflectDir),0.0),sph.material.shininess);\n        specular = sph.material.specular * spec;\n        \n        col = ambient + diffuse + specular;\n        }\n       \n    }\n    if(length(uv - vec2(sph.center.x,sph.center.y)) <= sph.radius && length(uv - vec2(sph.center.x,sph.center.y)) >= sph.radius - outlineLength )\n    {\n        float custom_z = sph.center.z - sqrt(pow(sph.radius,2.0) - pow(uv.y - sph.center.y,2.0));\n        \n        vec3 uv_3D = vec3(uv,custom_z);\n\t\n        vec3 ambient = vec3(0.0);\n        vec3 diffuse = vec3(0.0);\n        vec3 specular = vec3(0.0);\n        \n        ambient = vec3(0.8,0.8,0.8) * lightColor;\n        \n        vec3 normal = normalize(uv_3D - sph.center);\n        vec3 lightDir = normalize(lightPos - uv_3D);\n        float diff = max(dot(normal, lightDir),0.0);\n        \n        \n        diffuse = sph.material.albedo * sph.material.diffuse * lightColor * diff;\n        \n        vec3 viewDir = normalize(camera - uv_3D);\n        vec3 reflectDir = reflect(-lightDir,normal); //might need normalize\n        float spec = pow(max(dot(viewDir, reflectDir),0.0),sph.material.shininess);\n        specular = sph.material.specular * spec;\n        \n        col = ambient + diffuse + specular;\n    }\n    if(length(uv - vec2(sph.center.x,sph.center.y)) < sph.radius - outlineLength && length(uv - vec2(sph.center.x,sph.center.y)) >= sph.radius - centerDist)\n    {\n        if(uv.y <= 0.485)\n        {\n            float custom_z = sph.center.z - sqrt(pow(sph.radius,2.0) - pow(uv.y - sph.center.y,2.0) + 0.8);\n        \n        vec3 uv_3D = vec3(uv,custom_z);\n\t\n        vec3 ambient = vec3(0.0);\n        vec3 diffuse = vec3(0.0);\n        vec3 specular = vec3(0.0);\n        \n        ambient = sph.material.ambient * vec3(1.0,1.0,1.0) * lightColor;\n        \n        vec3 normal = normalize(uv_3D - sph.center);\n        vec3 lightDir = normalize(lightPos - uv_3D);\n        float diff = max(dot(normal, lightDir),0.0);\n        \n        \n        diffuse = sph.material.albedo * sph.material.diffuse * lightColor * diff;\n        \n        vec3 viewDir = normalize(camera - uv_3D);\n        vec3 reflectDir = reflect(-lightDir,normal); //might need normalize\n        float spec = pow(max(dot(viewDir, reflectDir),0.0),sph.material.shininess);\n        specular = sph.material.specular * spec;\n        \n        col = ambient + diffuse + specular;\n        }else if (uv.y>=0.505)\n        {\n             float custom_z = sph.center.z - sqrt(pow(sph.radius,2.0) - pow(uv.y - sph.center.y,2.0) + 0.8);\n        \n        vec3 uv_3D = vec3(uv,custom_z);\n\t\n        vec3 ambient = vec3(0.0);\n        vec3 diffuse = vec3(0.0);\n        vec3 specular = vec3(0.0);\n        \n        ambient = sph.material.ambient * sph.material.albedo * lightColor;\n        \n        vec3 normal = normalize(uv_3D - sph.center);\n        vec3 lightDir = normalize(lightPos - uv_3D);\n        float diff = max(dot(normal, lightDir),0.0);\n        \n        \n        diffuse = sph.material.albedo * sph.material.diffuse * lightColor * diff;\n        \n        vec3 viewDir = normalize(camera - uv_3D);\n        vec3 reflectDir = reflect(-lightDir,normal); //might need normalize\n        float spec = pow(max(dot(viewDir, reflectDir),0.0),sph.material.shininess);\n        specular = sph.material.specular * spec;\n        \n        col = ambient + diffuse + specular;\n        }else\n        {\n            float custom_z = (sph.center.z - sqrt(pow(sph.radius,2.0) - pow(uv.y - sph.center.y,2.0)));\n        \n        vec3 uv_3D = vec3(uv,custom_z);\n\t\n        vec3 ambient = vec3(0.0);\n        vec3 diffuse = vec3(0.0);\n        vec3 specular = vec3(0.0);\n        \n        ambient = sph.material.ambient * vec3(0.1,0.1,0.1) * lightColor;\n        \n        vec3 normal = normalize(uv_3D - sph.center);\n        vec3 lightDir = normalize(lightPos - uv_3D);\n        float diff = max(dot(normal, lightDir),0.0);\n        \n        \n        diffuse = sph.material.albedo * vec3(0.0,0.0,0.0) * lightColor * diff;\n        \n        vec3 viewDir = normalize(camera - uv_3D);\n        vec3 reflectDir = reflect(-lightDir,normal); //might need normalize\n        float spec = pow(max(dot(viewDir, reflectDir),0.0),sph.material.shininess);\n        specular = vec3(0.2,0.2,0.2) * spec;\n        \n        col = ambient + diffuse + specular;\n        }\n       \n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd2yRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[212, 212, 269, 319, 8396]], "test": "valid"}
{"id": "Wd2yRW", "name": "Hyperbolic Zoom", "author": "mla", "description": "From one extreme to the other: zooming into the hyperbolic half plane (two of them).\n\nVariation on sl2c's excellent [url]https://www.shadertoy.com/view/3d2cz1[/url]", "tags": ["zoom", "hyperbolic", "halfplane"], "likes": 5, "viewed": 240, "published": "Public API", "date": "1586200289", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Original by sl2c: https://www.shadertoy.com/view/3d2cz1\n// Zooming modification by Matthew Arcus, mla, 2020.\n\n#define swap(x,y) {t=x;x=y;y=t;}\n\n\nvec3 color(vec2 z) {\n    float pi = 3.14159265359;\n    float theta = pi/9.0;\n    // someday I'll explain the cross-ratio magic that got me these numbers\n    float r = 2.0 / (1.0 - sqrt(1.0 - 4.0 * sin(theta) * sin(theta)));\n    float p = - r * cos(theta);\n    bool fl = false;\n    vec3[3] colors;\n    colors[0] = vec3(1.0,0.0,0.0);\n    colors[1] = vec3(0.0,1.0,0.0);\n    colors[2] = vec3(0.0,0.0,1.0);\n    vec3 t; // for temp space\n    for(int i=0;i<100;i++) {\n        if (z.x < 0.0) {\n            z.x = -z.x;\n            colors[2] = 1.0 - colors[2];\n            fl = !fl;\n            continue;\n        }\n        if (dot(z,z) < 1.0) {\n            z /= dot(z,z);\n            fl = !fl;\n            swap(colors[0],colors[1]);\n            continue;\n        }\n        z.x -= p;\n        if (dot(z,z) > r*r) {\n            z *= r * r / dot(z,z);\n            fl = !fl;\n            z.x += p;\n            swap(colors[1],colors[2]);\n            continue;\n        }\n        z.x += p;\n        vec3 col = colors[0];\n        if (fl) {\n            col = 0.5 * col;\n        }\n    return col;\n    }\n    return vec3(1.0,1.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * (fragCoord - iResolution.xy * 0.5)/iResolution.y;\n    uv *= exp(50.0-mod(iTime,50.0)-24.0);\n        //uv.x += 1.0 * iTime;\n        fragColor = vec4(color(uv),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd2yRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1261, 1261, 1318, 1318, 1504]], "test": "valid"}
{"id": "Wd2yRy", "name": "AA in 2D", "author": "rontinoum", "description": "Test AA in 2D", "tags": ["2d", "aa"], "likes": 2, "viewed": 72, "published": "Public", "date": "1586976686", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = asin(1.0) * 2.0;\nconst float pi_to_rad = pi / 180.0;\nconst float rad_to_pi = 180.0 / pi;\n\nconst vec2 cam_pos = vec2(0.0, 0.0);\nconst float cam_rot = 10.0 * pi_to_rad;\nconst float vp_size = 10.0;\n\nvec2 fragToNDC(in vec2 fragCoord)\n{\n    return 2.0 * vec2(fragCoord / iResolution.xy) - 1.0;\n}\n\nvec2 NDCToOrigin(in vec2 ndc)\n{\n    float aspect_ratio = iResolution.x / iResolution.y;\n    return vec2(ndc.x * aspect_ratio, ndc.y);\n}\n\nvec2 originToCamSpace(in vec2 pos)\n{\n    float dcr = iTime * cam_rot;\n    \n    return cam_pos + (pos * vp_size) * mat2(cos(dcr), -sin(dcr), sin(dcr), cos(dcr));\n}\n\nvec4 map(in vec2 pos)\n{\n    vec4 res = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    vec3 color = vec3(0.0);\n\n    // checker board\n    {\n        vec2 fract_p = fract(pos + vec2(0.5));\n        vec2 floor_p = floor(pos);\n\n        // lines\n        vec2 ln_gradient = smoothstep(0.0, 0.01, 0.5 * cos(fract_p * 2.0 * pi) + 0.5);\n        float ln_strength = ln_gradient.x * ln_gradient.y;\n\n        // background\n        float bg_strength = floor_p.x + floor_p.y;\n        vec3 bg_color = mix(vec3(0.99), vec3(0.01), mod(bg_strength, 2.0));\n\n        // combine\n        color += bg_color * ln_strength;\n    }\n    \n    // sphere\n    {\n        float r = 1.0;\n        vec2 p = vec2(0.0, 5.0);\n\t\tfloat d = 1.0 - smoothstep(0.9, 1.0, length(pos - p) / r);\n        vec3 c = vec3(1.0, 0.0, 0.5);\n        \n        color = d * c + (1.0 - d) * color;\n    }\n    \n    res.xyz = color;\n    \n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    int aa = 4;\n    float aa_nom = 1.0 / float(aa);\n    float aaa = 1.0 / float(aa * aa);\n    \n    for(int AA_x = 0; AA_x < aa; AA_x++)\n        for(int AA_y = 0; AA_y < aa; AA_y++)\n        {\n            vec2 frc = fragCoord + vec2(float(AA_x) * aa_nom, float(AA_y) * aa_nom);\n            vec2 ndc = fragToNDC(frc);\n            vec2 org = NDCToOrigin(ndc);\n            vec2 pos = originToCamSpace(org);\n            \n            vec4 res = map(pos);\n            \n            tot += res.xyz;\n        }\n    \n    tot = tot * aaa;\n    tot = pow(tot, vec3(1.0/2.2));\n    \n    fragColor = vec4(tot,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd2yRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[213, 213, 248, 248, 307], [309, 309, 340, 340, 444], [446, 446, 482, 482, 608], [610, 610, 633, 633, 1485], [1487, 1487, 1544, 1544, 2173]], "test": "error"}
{"id": "Wd2yWw", "name": "Divine Light", "author": "dr2", "description": "Truchet tubing +...", "tags": ["sunbeam", "truchet"], "likes": 19, "viewed": 337, "published": "Public API", "date": "1586766755", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Divine Light\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat Minv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashfv3 (vec3 p);\nfloat Noisefv3 (vec3 p);\nfloat Fbm1 (float p);\n\nvec3 ltPos, ltAx;\nvec2 trkAx, trkAy, trkFx, trkFy;\nfloat dstFar, tCur;\nconst float pi = 3.14159;\n\nvec3 TrackPath (float t)\n{\n  return vec3 (dot (trkAx, sin (trkFx * t)), dot (trkAy, sin (trkFy * t)), t);\n}\n\nvec3 TrackVel (float t)\n{\n  return vec3 (dot (trkAx * trkFx, cos (trkFx * t)), dot (trkAy * trkFy, cos (trkFy * t)), 1);\n}\n\nfloat TubeDist (vec3 p)\n{\n  vec2 s, t;\n  float w, a;\n  t = p.xy;\n  t *= t;\n  s = vec2 (sqrt (sqrt (dot (t, t))), p.z) - 0.5;\n  t = cos (64. * pi * s);\n  w = 0.03 * (1. + 0.1 * t.x * t.y);\n  a = 2. * pi * (floor (16. * (atan (p.y, - p.x) / (2. * pi)) + 0.5) / 16.);\n  return min (SmoothMax (PrRoundBox2Df (s, vec2 (w), 0.03),\n     0.04 - abs (dot (p.yx, sin (a + vec2 (0.5 * pi, 0.)))), 0.01),\n     PrRoundBox2Df (s, vec2 (0.5 * w), 0.03));\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, db;\n  float r;\n  q = p;\n  q.xy -= TrackPath (q.z).xy;\n  r = floor (8. * Hashfv3 (floor (q)));\n  q = fract (q);\n  if (r >= 4.) q = q.yxz;\n  r = mod (r, 4.);\n  if (mod (r, 2.) == 0.) q.x = 1. - q.x;\n  if (abs (r - 1.5) == 0.5) q.y = 1. - q.y;\n  db = vec3 (TubeDist (q), TubeDist (vec3 (q.z, 1. - q.x, q.y)), TubeDist (vec3 (1. - q.yz, q.x)));\n  return 0.7 * Minv3 (db);\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0005, -0.0005);\n  for (int j = 0; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 BgCol (vec3 rd)\n{\n  float t, gd, b;\n  t = 4. * tCur;\n  b = dot (vec2 (atan (rd.x, rd.y), 0.5 * pi - acos (rd.z)), vec2 (2., sin (rd.x)));\n  gd = clamp (sin (5. * b + t), 0., 1.) * clamp (sin (3.5 * b - t), 0., 1.) +\n     clamp (sin (21. * b - t), 0., 1.) * clamp (sin (17. * b + t), 0., 1.);\n  return mix (vec3 (0.8, 0.5, 0.), vec3 (0.9, 0.4, 0.2), 0.5 + 0.5 * rd.z) *\n     (0.12 + 0.22 * (rd.z + 1.) * (rd.z + 1.)) * (2. + 0.3 * gd);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, bgCol, vn, ltVec, ltDir;\n  float dstObj, nDotL, ltDist, atten;\n  dstObj = ObjRay (ro, rd);\n  bgCol = BgCol (rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col4 = vec4 (mix (vec3 (0.75, 0.7, 0.7), vec3 (0.8, 0.7, 0.7),\n       smoothstep (0.45, 0.55, Noisefv3 (32. * ro))), 0.1);\n    ltVec = ltPos - ro;\n    ltDist = length (ltVec);\n    ltDir = ltVec / ltDist;\n    atten = min (1., 0.2 + smoothstep (0.7, 0.95, dot (ltAx, - ltDir))) / (1. + 0.2 * ltDist * ltDist);\n    nDotL = max (dot (vn, ltDir), 0.);\n    col = atten * (col4.rgb * (0.2 + 0.8 * nDotL * nDotL) +\n       col4.a * pow (max (dot (reflect (rd, vn), ltDir), 0.), 32.));\n    col = mix (col, bgCol, 0.1 + 0.9 * smoothstep (0., 0.85, dstObj / dstFar));\n  } else col = bgCol;\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, vd, col;\n  vec2 canvas, uv;\n  float az, el, zmFac, fSpd, t;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az += pi * mPtr.x;\n    el += 0.5 * pi * mPtr.y;\n  }\n  trkAx = 0.07 * vec2 (2., 0.9);\n  trkAy = 0.07 * vec2 (1.3, 0.66);\n  trkFx = vec2 (0.2, 0.23);\n  trkFy = vec2 (0.17, 0.24);\n  fSpd = 1.;\n  t = fSpd * tCur;\n  ro = TrackPath (t);\n  ro.xy += 0.05 * sin (0.05 * pi * tCur);\n  vd = normalize (TrackVel (t));\n  vuMat = StdVuMat (el + sin (vd.y), az + atan (vd.x, vd.z));\n  zmFac = 2.5;\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  rd.xy = Rot2D (rd.xy, 0.07 * pi * (Fbm1 (0.2 * tCur) - 0.5));\n  ltPos = ro + vuMat * vec3 (0.1, 0.1, 0.);\n  ltAx = vuMat * vec3 (0., 0., 1.);\n  dstFar = 50.;\n  col = ShowScene (ro, rd);\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, vec3 (37., 39., 41.))) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec4 (0., cHashVA3.xyz)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd2yWw.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[515, 515, 541, 541, 622], [624, 624, 649, 649, 746], [748, 748, 773, 773, 1189], [1191, 1191, 1213, 1213, 1593], [1595, 1595, 1628, 1628, 1804], [1806, 1806, 1827, 1827, 2077], [2079, 2079, 2101, 2101, 2520], [2522, 2522, 2557, 2557, 3378], [3380, 3380, 3433, 3433, 4397], [4399, 4399, 4446, 4446, 4493], [4495, 4495, 4517, 4517, 4555], [4557, 4557, 4602, 4602, 4705], [4707, 4707, 4752, 4752, 4790], [4792, 4792, 4828, 4828, 5034], [5036, 5036, 5066, 5066, 5179], [5213, 5213, 5237, 5237, 5302], [5304, 5304, 5328, 5328, 5381], [5383, 5383, 5407, 5407, 5526], [5528, 5528, 5553, 5553, 5699], [5701, 5701, 5726, 5726, 5951], [5953, 5953, 5975, 5975, 6129]], "test": "error"}
{"id": "wd2yz3", "name": "Day3: Line Drawing + Transforms", "author": "fluxatron", "description": "Learning how to draw lines and some transformation fun", "tags": ["line", "transform", "segments"], "likes": 1, "viewed": 65, "published": "Public", "date": "1587103212", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Shape /////////////////////////////////////////////////////////////////////////////////////////////////\nvec3 shapeCol = vec3(0.8,0.2,0.4);\nconst int numVerts = 5;\nvec2[] shape = vec2[] (\n    vec2( 0.0, 0.0), // bot left\n    vec2( 0.0, 1.0), // top left\n    vec2( 0.5, 0.5), // pivot\n    vec2( 1.0, 1.0), // top right\n    vec2( 1.0, 0.0)  // bot right\n);\n\n// Find the y values given an x along the line\nfloat findY(float x, vec2[numVerts] shape)\n{\n    // bsearch?? to find first value higher than x\n    // handle edge cases\n    // lerp between i and i-1's y values\n    return 0.0; \n}\n\n// Finds the distance of P from the line A to B\nfloat segment( in vec2 p, vec2 a, vec2 b )\n{\n\tvec2 ap = p - a;\n\tvec2 ab = b - a;\n\tfloat h = clamp(dot(ap,ab)/dot(ab,ab), 0.0, 1.0); // project ap onto ab\n\treturn length( ap - ab*h ); // finds length of vec from p to the projection of p onto ab\n}\n\nvec3 drawShape(vec2 p, mat3 tform, vec3 col)\n{\n    float thicc = 0.01;\n    \n    for(int i = 1; i < numVerts; i++)\n    {\n    \tvec3 a = tform * vec3(shape[i-1], 1);\n    \tvec3 b = tform * vec3(shape[i], 1);\n        \n        if (segment(p, a.xy, b.xy) < thicc)\n        \treturn shapeCol;\n    }\n     \n    return col;\n}\n\nvoid updateShape()\n{\n    shape[0] += vec2(0.2*sin(iTime), 0.1*cos(iTime));\n    shape[4] += vec2(0.2*-cos(iTime), 0.1*sin(iTime));\n}\n\n\n// Matrix transform helpers ////////////////////////////////////////////////////////////////////////////\nmat3 createTransMat(vec2 translation)\n{\n    return mat3(vec3(1,0,0), \n                vec3(0,1,0), \n                vec3(translation,1));\n}\nmat3 createScaleMat(vec2 scale)\n{\n    return mat3(scale.x, 0, 0,\n                0, scale.y, 0,\n                0, 0,       1);\n}\nmat3 createRotationMat(float rad)\n{\n    return mat3(cos(rad), sin(rad), 0,\n               -sin(rad), cos(rad), 0,\n                0,        0,        1);\n}\nmat3 createAffineMat(vec2 translation, float rotation, vec2 scale)\n{\n    mat3 S = mat3(createScaleMat(scale));\n    mat3 R = mat3(createRotationMat(rotation));\n    mat3 T = createTransMat(translation);\n    return S*R*T;\n}\n\n\n// Transformations ////////////////////////////////////////////////////////////////////////////////////\nmat3 matTranslate(mat3 m, vec2 translation)\n{\n    return createTransMat(translation) * m;\n}\nmat3 matRotate(mat3 m, float rad)\n{\n    return createRotationMat(rad) * m;\n}\nmat3 matScale(mat3 m, vec2 scale)\n{\n    return createScaleMat(scale) *  m;\n}\n/*\nmat3 matRotate(mat3 m, float rad, vec2 pivot)\n{\n    return createTransMat(-pivot) * matRotate(m, rad) * createTransMat(pivot);\n}\nmat3 matScale(mat3 m, vec2 scale, vec2 pivot)\n{\n    return createTransMat(-pivot) * matScale(m, scale) * createTransMat(pivot);\n}\n*/\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.yy;\n    vec2 uvNorm = fragCoord/iResolution.xy;\n\n    updateShape();\n    \n    // Shape mat - moves pivot to the middle of our shape\n    mat3 shapeMat = createTransMat(vec2(-.5,-.5));\n    \n    // Model mat - moves/rotates and squishes our model\n    mat3 modelMat = mat3(1);\n   \tmodelMat = matScale(modelMat, 0.5 + vec2(0.1*sin((iTime+3.0)*3.0), 0.1*cos(iTime*3.0)));\n    modelMat = matRotate(modelMat, sin(iTime*0.7)*0.7);\n    modelMat = matTranslate(modelMat, vec2(aspectRatio/2., 0.5));\n    \n    // View mat - pan the view about\n    mat3 viewMat = mat3(1);\n    viewMat = matTranslate(viewMat, 0.05 * vec2(2.0*sin(1.2*iTime+3.0), cos(iTime+5.0)) );\n    \n    vec3 col = viewMat*vec3(uvNorm,1) * 0.2; // Draw background\n    col = drawShape(uv, viewMat*modelMat*shapeMat, col);\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd2yz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[588, 636, 680, 680, 881], [883, 883, 929, 929, 1195], [1197, 1197, 1217, 1217, 1328], [1331, 1436, 1475, 1475, 1575], [1576, 1576, 1609, 1609, 1705], [1706, 1706, 1741, 1741, 1861], [1862, 1862, 1930, 1930, 2082], [2085, 2189, 2234, 2234, 2280], [2281, 2281, 2316, 2316, 2357], [2358, 2358, 2393, 2393, 2434], [2702, 2805, 2862, 2862, 3765]], "test": "error"}
{"id": "Wd2yzd", "name": "Up the River", "author": "sl2c", "description": "Another version of https://www.shadertoy.com/view/wdjyzh that auto-aliases using automatic differentiation. Also, it's animating (3z+4)/(2z+3), whose fixed points are ±sqrt(2); replace line 60 to check other periodic paths!", "tags": ["tiling", "hyperbolic", "poincare"], "likes": 12, "viewed": 136, "published": "Public", "date": "1587399831", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Copyright 2020 Google LLC\n// SPDX-License-Identifier: Apache-2.0\n// NOT an official Google project; see Google Open Source guidelines for more info on copyright transfer\n// written by William Cadegan-Schlieper \n\n#define invert(z,ds) {z/=dot(z,z); ds*=dot(z,z);}\n\n#define R {b+=a; d+=c;}\n#define L {a+=b; c+=d;}\n\nvec3 color(vec2 z, float ds) {\n    bool fl = false;\n    for(int i=0;i<60;i++) {\n        z.x = fract(z.x);\n        if (z.x > 0.5) {\n            z.x = 1.0-z.x;\n            fl = !fl;\n        }\n        if (dot(z,z) < 1.0) {\n            invert(z,ds);\n            fl = !fl;\n            continue;\n        }\n        \n    }\n    float c = 0.0;\n    if (ds > z.x) {\n        c = 0.5 * (1.0 - (z.x / ds));\n    }\n    if (ds > 0.5 - z.x) {\n        c = max(c, 0.5 * (1.0 - ((0.5 - z.x) / ds)));\n    }\n    if (2.0 * ds > dot(z,z) - 1.0) {\n        c = max(c, 0.5 * (1.0 - ((dot(z,z) - 1.0) / (2.0 * ds))));\n    }\n    c = max(c,ds);\n    c = min(c,0.5);\n    if (fl) {\n        c = 1.0 - c;\n    }\n    return vec3(c,c,c);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * (fragCoord - iResolution.xy * 0.5)/iResolution.y;\n    float ds = 2.0 / iResolution.y;\n    \n    float r2 = dot(uv,uv);\n    if (r2 < 1.0) {\n        uv.y -= 1.0;\n        invert(uv,ds);\n        uv.y = -0.5 - uv.y;\n        \n        int a=1; int b=0; int c=0; int d=1;\n        L; R; R; L;\n        if (a+d<=2) {\n            // treat null rotations specially\n            if (c>0) {\n                uv.x += 0.5;\n            } else {\n                uv.x = 0.5 - uv.x;\n            }\n            invert(uv,ds);\n            uv.x -= 0.1 * iTime;\n            fragColor = vec4(color(uv,ds),1.0);  // gamma correction suggested by FabriceNeyret2\n            fragColor = pow(fragColor, vec4(1./2.2));\n            return;\n        }\n        float disc = sqrt(float((a+d)*(a+d)-4));\n        float inverse_diff = float(c) / disc;\n        float root = (float(a-d) + disc) / (2.0 * float(c));\n        float period = 2.0 * log((float(a+d) + disc) * 0.5);\n        \n        float t = 0.1 * iTime;\n        t = mod(t,period) - period * 0.5;\n        uv *= exp(t); ds *= exp(t);\n        \n        uv.x -= inverse_diff;\n        invert(uv,ds);\n        uv.x += root;\n        fragColor = vec4(color(uv,ds),1.0);\n    } else {\n        float c = (r2 - 1.0) / (2.0 * ds);\n        fragColor = vec4(0.5,0.5 + 0.5 * c ,0.5,1.0);\n    }\n    fragColor = pow(fragColor, vec4(1./2.2));  // gamma correction suggested by FabriceNeyret2\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd2yzd.jpg", "access": "shaders20k", "license": "apache-2.0", "functions": [[315, 315, 345, 345, 1019]], "test": "valid"}
{"id": "Wd2yzt", "name": "ImSmile", "author": "Imene_BH", "description": "it is an animated smile", "tags": ["becreative"], "likes": 1, "viewed": 127, "published": "Public API", "date": "1587498182", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ImSmile //\n\n#define S(a,b,t) smoothstep (a, b ,t)\n#define sat(x) clamp(x, 0. , 1.) \n\nfloat remap01 (float a, float b , float t){\n  \treturn sat((t-a) / (b-a) );\t\t\t\t\t\t\t\t\t\t// sat is used to be sure that the value returned  is between 0 & 1\n}\n\nfloat remap (float a , float b , float c , float d, float t ){\n    return sat(((t-a)/(b-a)) * (d-c)+c);\n\n}\n\nvec2 within (vec2 uv , vec4 rect ){ \t\t\t\t\t\t\t\t// return uv coordinate within that rectangle \n\treturn (uv-rect.xy)/(rect.zw-rect.xy);\n\n}\nvec4 Brow (vec2 uv){\n    \n\tfloat y = uv.y;\n    uv.y += uv.x*.1-2.;\n    uv.x-=.1;\n    uv -=.5;\n    \n    vec4 col = vec4(0.);\n    float blur =.1; \n    float d1 = length(uv);\n    float s1 = S (.40,.45-blur,d1);\n    float d2 = length(uv-vec2(1.,-.2)*.7);\n    float s2 = S(.5,.55-blur,d2);\n    float browMask = sat (s1-s2);\n      \n    vec4 browCol = vec4(.7,.5,.3,1.);\n    col = mix (col, browCol,S(.2,.4,browMask));\n\treturn col;\n}  \nvec4 Eye (vec2 uv,float side,vec2 m,float smile){\n\tuv -=.5;\n    uv.x *= side;\t\t\t\t\t\t\t\t\t\t\t\t\t// desable mirior effect for mvt eyes \n    float d = length(uv);\n    vec4 irisCol = vec4(.0,.6,.0,4.);\t\t\t\t\t\t\t\t// iris color\n    vec4 col = mix (vec4(1.),irisCol,S(.2,.50,d)*.6);\t\t\t\t// gradien in eye-white\n    col.a= S(.5,.48,d);// eye mask\n    col.rgb *= 1. - S(.45,.5,d)*.7*sat(-uv.y+uv.x);\t\t\t\t\t// add a little shadow , sat doesn't get negative in\n  \n    d = length(uv-m*.5);\t\t\t\t\t\t\t\t\t\t\t// distance of mouse mvt \n    col.rgb = mix (col.rgb,vec3(0.), S(.29,.15,d));\t\t\t\t\t// iris outline\n    \n    irisCol.rgb *= 1.2 + S(.35,.001,d);\n    col.rgb = mix (col.rgb,irisCol.rgb, S(.28,.12,d));\n    \n    float pupilSize=mix (.30,.18,smile);\t\t\t\t\t\t\t// pupil size is bigger if we're not smiling\n    d = length(uv-m*.65);\n    col.rgb = mix (col.rgb,vec3(0.), S(pupilSize,pupilSize*.95,d)); // blend\n    \n    //highlight\n    uv.x += sin(iTime+uv.y*20.)*.03;\n    float p = length(uv -vec2(-.11,.15));\n    float p2 = length(uv +vec2(-.06,.10));\n    \n    float highlight = S (.1,.07,p);\n    highlight += S(.1,.0001,p2);\n    col.rgb= mix (col.rgb, vec3(1.),highlight);\n    col.rgb= mix (col.rgb, vec3(1.),highlight);\n   \n    return col;\n}\nvec4 Mouth (vec2 uv,float smile){\n\tuv-=.5;//renormalize\n    vec4 col = vec4(.9,.1,.2,1.);\n\t   \n    uv.y*=1.5;\n    uv.y -= uv.x*uv.x*2.*smile;\n    uv.x *= mix(3.,1.,smile);\n    float d = length(uv);\n    col.rgb= mix (col.rgb,vec3(.2,.10,.05),S(.55,.45,d));\n    \n    float teeth = length(uv-vec2(0.005,.65));\n    vec3 toothcol= vec3(1.)*S(.9,.7,d);\n    col.rgb= mix(col.rgb,toothcol,S(.47,.35,teeth));\n    \n    float tongue = length(uv-vec2(-.005,-.55));\n    col.rgb = mix(col.rgb, vec3(1.,.5,.5),S(.5,.2,tongue));\n    \n    col.a= S(.6,.47,d);\n    return col;\n    \n}\n\nvec4 Head (vec2 uv){\n\tvec4 col = vec4(.9,.70, .1, 1.);    \n    float d = length(uv);\n    \n    col.a = S(.5,.49,d);\n    float edgeShade = remap01(.35,.5,d);\n    edgeShade *= edgeShade;\n    col.rgb *= 1.-edgeShade*.5;\n    \n    col.rgb = mix (col.rgb,vec3(.65,.4,.1),S(.48,.48,d));\t\t\t// draw \"contour\"\n    \n    float highlight = S(.41,.405,d)*.75;\n    highlight *=remap(.41,-.1,.75,0.,uv.y);\n    highlight *=S(.16,.18,length(uv-vec2(.207,.11)));\n    col.rgb = mix(col.rgb,vec3(1.),highlight);\n    \n    //cheek\n    d = length(uv-vec2(.30, -.17));\t\t\t\t\t\t\t\t\t// position of cheek in the image\n    float cheek= S(.20,.02,d)*.35;   \n    col.rgb = mix(col.rgb,vec3(1.,.1,.1),cheek);\n    \n    return col;\n}\n\nvec4 Smiley (vec2 uv,vec2 m,float smile,vec4 fragColor,vec2 fragCoord){\n\t\n    vec2 uv1 = (fragCoord*2.-iResolution.xy)/40.;\n    vec4 col = vec4(.2,0.4,0.3,.2);\n     col += vec4(sin(iTime*10.+3.141592653589793*2.)*0.5)*0.3+0.5;\n    col+=sin((uv1.x-uv1.y)*60.)/2.;\n   \n    //head\n    float side = sign (uv.x);\t\t\t\t\t\t\t\t\t\t\t// Every think on one side will be drawn on\n   \tuv.x=abs(uv.x);\t\t\t\t\t\t\t\t\t\t\t\t\t\t// The other side too \"mirror x cordinates \n     \n    \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n    vec4 Head = Head (uv);\t\t\t\t\t\t\t\t\t\t\t\t// The color from the head\n    vec4 Eye = Eye (within(uv,vec4(.03,-.05,.36,.26)),side,m,smile);\t// Make the eyes\n    vec4 Mouth = Mouth (within(uv,vec4(-.3,-.42,.28,-.1)),smile);\t\t// Make Mouth\n    vec4 Brow = Brow (within(uv,vec4(.03,.2,.30,.27)));\n   \n    //mix color\n    col = mix (col, Head,Head.a); \n    col = mix (col, Eye,Eye.a);\n    col = mix (col, Mouth,Mouth.a);\n    col = mix (col, Brow,Brow.a);\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tuv-= .5;\n    uv.x *=iResolution.x / iResolution.y;\n    \n\tvec2 m = iMouse.xy / iResolution.xy;\n    m -=.5;\n    uv-=m*(.5-dot(uv,uv));\t\t\t\t\t\t\t\t\t\t\t\t// expenential mvt\n    \n    // Output to screen\n    float smile= -sin(iTime)*.5+.5;\t\t\t\t\t\t\t\t\t\t//sinus function of time \n    fragColor = Smiley(uv,m,smile,fragColor,fragCoord);\n    \n    // sound \n    float t = iTime;\n     \n    // add wave form on top\t\n    vec3 col;\n\tcol -= 1. - smoothstep( 0.0, 0.15, smile );\n\t// output final color\n\tfragColor += vec4(col,1.0);\n    \n}", "image_inputs": [{"id": "ltS3Dw", "previewfilepath": "https://soundcloud.com/ladouceplaylist/la-douce-playlist-mixtape-14-nth-sound-mix", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/ladouceplaylist/la-douce-playlist-mixtape-14-nth-sound-mix", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd2yzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[88, 88, 131, 131, 241], [243, 243, 305, 305, 349], [351, 351, 386, 441, 484], [485, 485, 505, 505, 911], [914, 914, 963, 963, 2123], [2124, 2124, 2157, 2157, 2688], [2690, 2690, 2710, 2710, 3384], [3386, 3386, 3457, 3457, 4320], [4323, 4323, 4380, 4430, 4988]], "test": "valid"}
{"id": "wd2yzz", "name": "Something go wrongv3", "author": "Arseny", "description": "yes", "tags": ["raymarching"], "likes": 0, "viewed": 206, "published": "Public API", "date": "1586019726", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// template copied form inigo quilez - iq/2019\n\n//   Step 1: https://www.shadertoy.com/view/ws3GD2\n\n\n#define AA 2\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdSphere( in vec3 p, in float r )\n{\n    return length(p)-r;\n}\n\nfloat sdEgg(in vec3 p, in float r, in float h){\n    float x = p.y;\n   \tfloat y = length(p.xz);\n    x = pow(x, 0.8);\n    x /= h;\n    float f = sqrt(1. - (x * 2. - 1.) * (x * 2. - 1.));\n    return y - f;\n}\n\n//float sdTransOct(in vec3 p, in vec3\n\nvec4 map( in vec3 p, float time )\n{\n    //float d = sdSphere( p, 0.1 );\n    float d = sdEgg( p, 0.1, 0.1 );\n    d = min(d, length(p.xy));\n    return vec4( d, p );\n}\n\n#define ZERO min(iFrame,0)\n\nvec3 calcNormal( in vec3 pos, in float time )\n{\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e,time).x;\n    }\n    return normalize(n);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor, in float time )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos+h*nor, time ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float k, in float time )\n{\n    float res = 1.0;\n    \n    float tmax = 2.0;\n    float t    = 0.001;\n    for( int i=0; i<64; i++ )\n    {\n        float h = map( ro + rd*t, time ).x;\n        res = min( res, k*h/t );\n        t += clamp( h, 0.012, 0.2 );\n        if( res<0.001 || t>tmax ) break;\n    }\n    \n    return clamp( res, 0.0, 1.0 );\n}\n\nvec4 intersect( in vec3 ro, in vec3 rd, in float time )\n{\n    vec4 res = vec4(-1.0);\n    \n    float t = 0.001;\n    float tmax = 10.0;\n    for( int i=0; i<128 && t<tmax; i++ )\n    {\n        vec4 h = map(ro+t*rd,time);\n        if( h.x<0.0001 ) { res=vec4(t,h.yzw); break; }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        float d = 0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n        float time = iTime;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        float time = iTime;\n        #endif\n\n\t    // camera\t\n        float an = 6.2831*time/30.0;\n        vec3 ta = vec3( 0.0, 0.0, 0.0 );\n        vec3 ro = ta + vec3( 0.5*cos(an), 0.5, 0.5*sin(an) );\n        \n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta, 0.0 );\n        \n        // ray direction\n        float fl = 2.0;\n        vec3 rd = ca * normalize( vec3(p,fl) );\n\n        // background\n        vec3 col = vec3(1.0+rd.y)*0.03;\n        \n        // raymarch geometry\n        vec4 tuvw = intersect( ro, rd, time );\n        if( tuvw.x>0.0 )\n        {\n            // shading/lighting\t\n            vec3 pos = ro + tuvw.x*rd;\n            vec3 nor = calcNormal(pos, time);\n                        \n            col = 0.5 + 0.5*nor;\n        }\n        \n        \n        // gamma        \n\t    tot += pow(col,vec3(0.45) );\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // cheap dithering\n    tot += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n\n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd2yzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[115, 115, 156, 156, 249], [251, 251, 292, 292, 318], [320, 320, 367, 367, 523], [564, 564, 599, 635, 728], [758, 758, 805, 805, 1014], [1016, 1016, 1073, 1073, 1338], [1340, 1340, 1415, 1415, 1726], [1728, 1728, 1785, 1785, 2046], [2048, 2048, 2100, 2100, 2277]], "test": "valid"}
{"id": "WdBcDc", "name": "Canarick - Subsurface Scattering", "author": "canarick", "description": "Subsurface Scattering Approximation", "tags": ["cis461"], "likes": 1, "viewed": 33, "published": "Public", "date": "1587600698", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define LIGHT_POS vec3(0.0 + 2. * sin(iTime), 2., 9.0)\n\n// Adjust these to alter where the subsurface glow shines through and how brightly\nconst float FIVETAP_K = 2.0;\nconst float AO_DIST = 0.085;\n\n// The larger the DISTORTION, the smaller the glow\nconst float DISTORTION = 0.2;\n// The higher GLOW is, the smaller the glow of the subsurface scattering\nconst float GLOW = 6.0;\n// The higher the BSSRDF_SCALE, the brighter the scattered light\nconst float BSSRDF_SCALE = 3.0;\n// Boost the shadowed areas in the subsurface glow with this\nconst float AMBIENT = 0.0;\n// Toggle this to affect how easily the subsurface glow propagates through an object\n#define ATTENUATION 0\n\nconst float FOVY = tan(3.14159 * 19.5 / 180.);\nconst int RAY_STEPS = 256;\n\nstruct Intersection {\n    float t;\n    vec3 color;\n    vec3 p;\n    int object; // Assign every object in our scene a unique ID int\n};\n        \n// SDF of a Sphere\nfloat sphere(vec3 p, float r, vec3 c) {\n    return distance(p, c) - r;\n}\n\n//SDF of a Torus\nfloat torus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n} \n\n//SDF of a Cone\nfloat cone(vec3 p, vec2 c) {\n\t//c must be normalized\n    float q = length(p.xy);\n    return dot(c, vec2(q, p.x));\n}\n        \n// SDF of a Plane\nfloat plane( vec3 p, vec4 n ) {\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n//SDF of a Box\nfloat box (vec3 p, vec3 b) {\n\treturn length(max(abs(p) - b, 0.0));\n}\n\n//RANDOM Noise Functions\nfloat random1( vec3 p ) {\n    return fract(sin((dot(p, vec3(127.1,\n                                  311.7,\n                                  191.999)))) *         \n                 43758.5453);\n}\n\nvec3 random3( vec3 p ) {\n    return fract(sin(vec3(dot(p,vec3(127.1, 311.7, 191.999)),\n                          dot(p,vec3(269.5, 183.3, 765.54)),\n                          dot(p, vec3(420.69, 631.2,109.21))))\n                 *43758.5453);\n}\n\n\nfloat WorleyNoise3D(vec3 p) {\n    // Tile the space\n    vec3 pointInt = floor(p);\n    vec3 pointFract = fract(p);\n\n    float minDist = 1.0; // Minimum distance initialized to max.\n\n    // Search all neighboring cells and this cell for their point\n    for(int z = -1; z <= 1; z++)\n    {\n        for(int y = -1; y <= 1; y++)\n        {\n            for(int x = -1; x <= 1; x++)\n            {\n                vec3 neighbor = vec3(float(x), float(y), float(z));\n\n                // Random point inside current neighboring cell\n                vec3 point = random3(pointInt + neighbor);\n\n                // Animate the point\n                point = 0.5 + 0.5 * sin(iTime * 0.01 + 6.2831 * point); // 0 to 1 range\n\n                // Compute the distance b/t the point and the fragment\n                // Store the min dist thus far\n                vec3 diff = neighbor + point - pointFract;\n                float dist = length(diff);\n                minDist = min(minDist, dist);\n            }\n        }\n    }\n    return minDist;\n}\n\nvoid CoordinateSystem(in vec3 v1, out vec3 v2, out vec3 v3) {\n    if (abs(v1.x) > abs(v1.y))\n            v2 = vec3(-v1.z, 0.0, v1.x) / sqrt(v1.x * v1.x + v1.z * v1.z);\n        else\n            v2 = vec3(0.0, v1.z, -v1.y) / sqrt(v1.y * v1.y + v1.z * v1.z);\n        v3 = cross(v1, v2);\n}\n\nvec3 WorleyTangentSpaceNormal(vec3 pos) {\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( WorleyNoise3D(pos + epsilon.yxx) - WorleyNoise3D(pos - epsilon.yxx),\n                            WorleyNoise3D(pos + epsilon.xyx) - WorleyNoise3D(pos - epsilon.xyx),\n                            WorleyNoise3D(pos + epsilon.xxy) - WorleyNoise3D(pos - epsilon.xxy)));\n\n}\n\nmat3 TangentToWorld(vec3 nor) {\n\tvec3 tangent, bitangent;\n    CoordinateSystem(nor, tangent, bitangent);\n    return mat3(tangent, bitangent, nor);\n}\n\n//Rotates the camera around the Y-axis\nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\n//This is where you can create your scene\n#define SPHERE_1_SDF sphere(pos, 2.5, vec3(0., 6.5, 1.))\n#define SPHERE_2_SDF sphere(pos, 1.5, vec3(-4., 2.5, 0.))\n#define SPHERE_3_SDF sphere(pos, 2.5, vec3(4., 0., -3.))\n\n//Primitive SDFs\n#define BACK_WALL_SDF plane(pos, vec4(0.0, 0.0, -1.0, 10.0))\n#define LEFT_WALL_SDF plane(pos, vec4(1.0, 0.0, 0.0, 5.0))\n#define RIGHT_WALL_SDF plane(pos, vec4(-1.0, 0.0, 0.0, 5.0))\n#define CEILING_SDF plane(pos, vec4(0.0, -1.0, 0.0, 7.5))\n#define FLOOR_SDF plane(pos, vec4(0.0, 1.0, 0.0, 2.0))\n#define TALL_BOX_SDF box(rotateY(pos + vec3(-1.5, 0.0, -2.0), 65.0 * 3.14159 / 180.0), vec3(1.0, 2.0, 1.2))\n#define SMALL_BOX_SDF box(rotateY(pos + vec3(1.5, 1.0, 0.0), -65.0 * 3.14159 / 180.0), vec3(1.0, 1.0, 1.0))\n\n\n//Primtives IDs\n#define BACK_WALL 0\n#define LEFT_WALL 1\n#define RIGHT_WALL 2\n#define CEILING 3\n#define FLOOR 4\n#define TALL_BOX 5\n#define SMALL_BOX 6\n#define SPHERE_1 7\n#define SPHERE_2 8\n#define SPHERE_3 9\n\nvoid sceneMap3D(vec3 pos, out float t, out int obj) {\n    t = BACK_WALL_SDF;\n    obj = BACK_WALL;\n    \n    float t2;\n    if((t2 = LEFT_WALL_SDF) < t) {\n        t = t2;\n        obj = LEFT_WALL;\n    }\n    if((t2 = RIGHT_WALL_SDF) < t) {\n        t = t2;\n        obj = RIGHT_WALL;\n    }\n    if((t2 = CEILING_SDF) < t) {\n        t = t2;\n        obj = CEILING;\n    }\n    if((t2 = FLOOR_SDF) < t) {\n        t = t2;\n        obj = FLOOR;\n    } \n    if ((t2 = SPHERE_1_SDF) < t) {\n    \tt = t2;\n        obj = SPHERE_1;\n    }\n    if ((t2 = SPHERE_2_SDF) < t) {\n    \tt = t2;\n        obj = SPHERE_2;\n    }\n    if ((t2 = SPHERE_3_SDF) < t) {\n    \tt = t2;\n        obj = SPHERE_3;\n    }\n}\n\n\nfloat sceneMap3D(vec3 pos) {\n    float t = BACK_WALL_SDF;\n    \n    float t2;\n    if((t2 = LEFT_WALL_SDF) < t) {\n        t = t2;\n    }\n    if((t2 = RIGHT_WALL_SDF) < t) {\n        t = t2;\n    }\n    if((t2 = CEILING_SDF) < t) {\n        t = t2;\n    }\n    if((t2 = FLOOR_SDF) < t) {\n        t = t2;\n    }  \n    if ((t2 = SPHERE_1_SDF) < t) {\n    \tt = t2;\n    }\n    if ((t2 = SPHERE_2_SDF) < t) {\n    \tt = t2;\n    }\n    if ((t2 = SPHERE_3_SDF) < t) {\n    \tt = t2;\n    }\n    \n    return t;\n}\n\nvec3 computeNormal(vec3 pos) {\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( sceneMap3D(pos + epsilon.yxx) - sceneMap3D(pos - epsilon.yxx),\n                            sceneMap3D(pos + epsilon.xyx) - sceneMap3D(pos - epsilon.xyx),\n                            sceneMap3D(pos + epsilon.xxy) - sceneMap3D(pos - epsilon.xxy)));\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj) {\n    t = 0.001;\n    for(int i = 0; i < RAY_STEPS; ++i) {\n        vec3 pos = origin + t * dir;\n    \tfloat m;\n        sceneMap3D(pos, m, hitObj);\n        if(m < 0.0001) {\n            return;\n        }\n        t += m;\n    }\n    t = -1.0;\n    hitObj = -1;\n}\n\nconst vec3 a = vec3(0.5, 0.5, 0.5);\nconst vec3 b = vec3(0.5, 0.5, 0.5);\nconst vec3 c = vec3(2.0, 1.0, 1.0);\nconst vec3 d = vec3(0.5, 0.2, 0.25);\n\nvec3 colorPalette(float t) {\n    return a + b * cos(6.28 * (t * c + d));\n}\n\nfloat fiveTapAO(vec3 p, vec3 n, float k) {\n    float aoSum = 0.0;\n    for(float i = 0.0; i < 5.0; ++i) {\n        float coeff = 1.0 / pow(2.0, i);\n        aoSum += coeff * (i * AO_DIST);\n    }\n    return 1.0 - k * aoSum;\n}\n\n\nfloat subsurface(vec3 lightDir, vec3 normal, vec3 viewVec, float thickness) {\n    vec3 scatteredLightDir = lightDir + normal * DISTORTION;\n    float lightReachingEye = pow(clamp(dot(viewVec, -scatteredLightDir), 0.0, 1.0), GLOW) * BSSRDF_SCALE;\n    float attenuation = 1.0;\n    #if ATTENUATION\n    attenuation = max(0.0, dot(normal, lightDir) + dot(viewVec, -lightDir));\n    #endif\n\tfloat totalLight = attenuation * (lightReachingEye + AMBIENT) * thickness;\n    return totalLight;\n}\n\n// This is where you give your objects in the scene materials\nvec3 computeMaterial(int hitObj, vec3 p, vec3 n, vec3 lightVec, vec3 view, float thickness) {\n    float lambert = dot(n, lightVec) + 0.2;\n    \n    switch(hitObj) {\n        case BACK_WALL:\n        case CEILING:\n        case FLOOR:\n        return vec3(0.85, 0.81, 0.78) * lambert;\n        break;\n        case RIGHT_WALL:\n        case LEFT_WALL:\n        return vec3(0.09, 0.65, 0.2) * lambert;\n        break;\n        case SPHERE_1:\n        return vec3(0.0, 0.67, 1.67) * subsurface(lightVec, n, view, thickness);\n        break;\n        case SPHERE_2:\n        case SPHERE_3:\n        return vec3(0.0, 0.67, 1.67) * subsurface(lightVec, n, view, thickness);\n        break;\n        case -1:\n        return vec3(0., 0., 0.);\n        break;\n    }\n    return vec3(0., 0., 0.);\n}\n\n\nIntersection sdf3D(vec3 dir, vec3 eye) {\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj);\n\n    vec3 isect = eye + t * dir;\n    vec3 nor = computeNormal(isect);\n    vec3 lightDir = normalize(LIGHT_POS - isect);\n    float thickness = fiveTapAO(isect, -nor, FIVETAP_K);\n    \n    vec3 surfaceColor = computeMaterial(hitObj, isect, nor, lightDir, normalize(eye - isect), thickness);\n    \n    return Intersection(t, surfaceColor, isect, hitObj);\n}\n\n// Returns direction of ray\nvec3 rayCast(vec3 eye, vec3 ref, vec2 ndc) {\n    vec3 F = ref - eye;\n    vec3 R = normalize(cross(F, vec3(0,1,0)));\n    vec3 U = normalize(cross(R, F));\n    \n    // Vertical and Horizontal Aspects\n    vec3 V = U * length(F) * tan(FOVY * 0.5);\n    vec3 H = R * length(F) * tan(FOVY * 0.5) * float(iResolution.x) / iResolution.y;\n    \n    vec3 p = ref + ndc.x * H + ndc.y * V;\n    \n    return normalize(p - eye);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    // Convert to range [-1, 1]\n    uv = uv * 2.0 - vec2(1.0, 1.0);\n    \n    vec3 eye = vec3(0, 4.5, -30);\n    vec3 ref = vec3(0, 3., 0);\n    \n    vec3 rayDir = rayCast(eye, ref, uv);\n    \n    Intersection isect = sdf3D(rayDir, eye);\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    // fragColor = vec4(0.5 * (rayDir + vec3(1., 1., 1.)), 1.0);\n    fragColor = vec4(isect.color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdBcDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[887, 906, 945, 945, 978], [980, 997, 1026, 1026, 1100], [1103, 1119, 1147, 1171, 1234], [1244, 1262, 1293, 1319, 1350], [1352, 1367, 1395, 1395, 1435], [1437, 1462, 1487, 1487, 1658], [1660, 1660, 1684, 1684, 1903], [1906, 1906, 1935, 1957, 2930], [2932, 2932, 2993, 2993, 3217], [3219, 3219, 3260, 3260, 3598], [3600, 3600, 3631, 3631, 3748], [3750, 3789, 3820, 3820, 3903], [4857, 4857, 4910, 4910, 5528], [5531, 5531, 5559, 5559, 6015], [6017, 6017, 6047, 6047, 6366], [6368, 6368, 6432, 6432, 6685], [6833, 6833, 6861, 6861, 6907], [6909, 6909, 6951, 6951, 7130], [7133, 7133, 7210, 7210, 7615], [7617, 7679, 7772, 7772, 8447], [8450, 8450, 8490, 8490, 8903], [8905, 8933, 8977, 8977, 9345], [9347, 9347, 9404, 9454, 9950]], "test": "error"}
{"id": "wdBcDW", "name": "glsl workshop from CharStiles", "author": "mpinner", "description": "converted from The Force", "tags": ["tutorial"], "likes": 2, "viewed": 42, "published": "Public", "date": "1586639170", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst float PI = 3.1415926535;\n\nfloat noise1d(float n){\n    return fract(cos(n*89.42)*343.42);\n}\nfloat noise2d(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(1.0,73))) * 43758.5453);\n}\n\nvec2 hash2( vec2 p )\n{\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec2 rotate(in vec2 position,in vec2 center,in float angle)\n{\n    //Function seen from https://www.shadertoy.com/view/XlsGWf\n    float rot = radians(angle);\n    mat2 rotation = mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n    return vec2((position-center)*rotation);\n}\n\n// http://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat equiTri(vec2 p){\n    float side = sqrt(3.0);\n    \n //   side = sqrt(10.0);\n //   side = sqrt(noise2d(p));\n    \n    p.x = abs(p.x) - 1.0;\n    p.y = p.y +1.0/side;\n    if(p.x + side*p.y > 0.0){\n        p = vec2(p.x - side*p.y, -side*p.x - p.y)/2.0;\n    }\n    p.x -= clamp(p.x,-2.0,0.0);\n    return -length(p)*sign(p.y);\n    \n}\n\n// http://www.iquilezles.org/www/articles/palettes/palettes.htm\n// As t runs from 0 to 1 (our normalized palette index or domain), \n//the cosine oscilates c times with a phase of d. \n//The result is scaled and biased by a and b to meet the desired constrast and brightness.\nvec3 cosPalette( float t, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat sphere(vec2 p) {\n    float r = 2.0;\n//r = 5.2*noise2d(p);\n    return length(p)-r;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n//void main () {\n//    vec2 pos = uv();\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 pos = uv;\n    \n    // vec2 rot = rotate(vec2(1.9, 1.9),  pos, time/10.0);\n    vec2 rot = rotate(vec2(0, 0),  pos, PI+sin(iTime)/10.0);\n    vec2 rot2 = rotate(vec2(0, 0),  pos, PI+sin(iTime)/-10.0);\n  //  pos = rot2;\n    \n     //vec2 rot = rotate(vec2(1.9, 1.9),  pos, time/10.0);\n    // pos.x += sin(noise(time))/10.0;\n\n    pos *= 4.0;\n    pos -= 2.0;\n    float shape = equiTri(rot);\n    //shape = clamp(shape, 0.1, 0.75);\n\n    float shape2 = sphere(pos);\n    \n    shape = smin(shape,shape2, 0.1);\n    \n\t//gl_FragColor = vec4(shape);\n\t\n\tvec3 a = vec3(0.5, 0.5, 0.9);\n\tvec3 b = vec3(0.5, 0.3, 0.5);\n\tvec3 c = vec3(2.0, 1.0, 10.0);\n\tvec3 d = vec3(0.0, 0.1, 0.25);\n\t\n\tvec3 col2 = cosPalette(0.5,vec3(0.5),vec3(0.5),vec3(1),vec3(iTime*0.1,iTime*0.1,iTime*.2));\n\tvec3 col = cosPalette(shape+(-iTime/10.0), a, b, c, d);\n// \t,vec3(0.5),vec3(0.5),vec3(1),vec3(time*0.01,time*0.1,time*.2));\n\n// \tfragColor = vec4(col2, 1);\n\tfragColor = vec4((vec3(col.x, col.y, col.z)), 1);\n// \tfragColor = vec4((vec3(pos.x, pos.y,1)), 1);\n// \tfragColor = vec4(hsv2rgb(vec3(pos.x, pos.y,0.5)), rand(1.0));\n// \tfragColor = vec4(hsv2rgb(vec3(pos.x, pos.y,.5)), rand(1.0));\n//\tfragColor = vec4(vec3(noise1d(pos[1]),noise2d(pos),0.5), 1.0);\n//\tfragColor = vec4(pos[0],pos[1],0.5, 1.0);\n}\n\n\n\n\n    \n//\tfragColor = vec4((vec3(pos.x, pos.y, .5)), 1);\n   \n    \n    \n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdBcDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[33, 33, 56, 56, 97], [98, 98, 121, 121, 183], [185, 185, 207, 207, 300], [302, 302, 363, 426, 572], [574, 648, 670, 670, 978], [980, 1254, 1314, 1314, 1357], [1359, 1359, 1381, 1381, 1448], [1450, 1450, 1491, 1491, 1584], [1587, 1627, 1684, 1734, 3041]], "test": "valid"}
{"id": "wdBcRd", "name": "Text output", "author": "NonGrate", "description": "Text output\n\nIt is Work In Progress, but getLetter(ascii) works, but only when letterbox position is (0;0)", "tags": ["text"], "likes": 1, "viewed": 80, "published": "Public", "date": "1587299684", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int V_COUNT = 16;\nconst int H_COUNT = 16;\n\nvec2 steps;\n\nvec3 getLetter(int ascii, int row, int column, vec2 uv) {\n    uv = vec2(uv.x - (steps.x*float(column))/iChannelResolution[0].x, uv.y - (steps.y*float(row))/iChannelResolution[0].y);\n    return texture(iChannel0, uv+(vec2(ascii,15-ascii/16))/16.).xxx;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    steps.x = iChannelResolution[0].x / float(H_COUNT);\n\tsteps.y = iChannelResolution[0].y / float(V_COUNT);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv_tex = fragCoord/iChannelResolution[0].xy;\n    vec2 nSteps = steps/iChannelResolution[0].xy;\n    \n    vec3 col;\n    \n    float xIndex = uv.x / (steps.x/iResolution.x);\n    float yIndex = uv.y / (steps.y/iResolution.y);\n    \n    if (int(ceil(yIndex)) == 1 || int(ceil(xIndex)) == 1) {\n        col = getLetter(65, int(yIndex), int(xIndex), uv_tex);\n    } else {\n        col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    }\n    \n    fragColor = vec4(col,1.0);\n   \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdBcRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[62, 62, 119, 119, 314], [316, 316, 371, 371, 1100]], "test": "error"}
{"id": "WdBcRh", "name": "Pig Squad 9 Year Anniversary", "author": "bpfarrell", "description": "A Shader to celebrate the Portland Indie Game Squad's 9th Anniversary. Happy developing everyone!", "tags": ["raymarch", "sdf", "pig", "portland", "indiegames"], "likes": 12, "viewed": 105, "published": "Public", "date": "1586026686", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define AUTO  //Comment this line to gain mouse controll.\n\n#define MAX_STEPS 300\n#define SURF_DIST 1e-3\n#define MAX_DIST 100.\n#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n#define lerp mix\n#define frac fract\n#define saturate(v) clamp(v,.0,.1)\n#define fmod mod\nfloat hash21(float2 p) {\n    p = frac(p * float2(233.34, 851.74));\n    p += dot(p, p + 23.45);\n    return frac(p.x * p.y);\n}\nfloat2 hash22(float2 p) {\n    float k = hash21(p);\n    return float2(k, hash21(p + k));\n}\nfloat sdSphere(float3 p, float s)\n{\n    return length(p) - s;\n}\n\nmat3x3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat3x3(\n        float3(c, 0, s),\n        float3(0, 1, 0),\n        float3(-s, 0, c)\n    );\n}\nfloat opSmoothUnion(float d1, float d2, float k) {\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return lerp(d2, d1, h) - k * h * (1.0 - h);\n}\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n    float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n    return lerp(d2, -d1, h) + k * h * (1.0 - h);\n}\nfloat sdPlane(float3 p, float4 n)\n{\n    return dot(p, n.xyz) + n.w;\n}\nfloat sdRoundBox(float3 p, float3 b, float r)\n{\n    float3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - r;\n}\n\nfloat sdPig(float3 p,float jump) {\n    p*= 1.0 + vec3(-0.2,0.2,-0.2)*(0.5+0.5*sin(iTime*10.0+3.5));\n    float3 j = float3(.0, -jump, .0);\n    p.x = abs(p.x);\n    float g = opSmoothUnion(sdRoundBox(p+j, float3(1.), 0.1), sdSphere(p + j, 1.2), 1.); //Main Body\n    g = min(g,\n            opSmoothUnion(\n                sdRoundBox(p - float3(0, -0.25, 0.9) + j, float3(0.4, 0.3, 0.5), 0.1),\n                sdSphere(p - float3(0, -0.25, 0.9) + j, .5), .5) //nose\n           );\n    float s = sdRoundBox(p - float3(.2, -0.25, 1.5) + j, float3(0.03, 0.13, 0.2), 0.05); //nostrile\n    s = min(s, sdRoundBox(p - float3(.4, 0.5, 1.3) + j, float3(0.05, 0.2, 0.05), 0.05)); //eye\n    return opSmoothSubtraction(s, g, 0.02);\n}\n\nfloat sdBridge(float3 p, float t) {\n    float gap = 2.4;\n    float tread = min(fmod(t, 3.141529 * 2.) / 3.141529, 1.) * gap;\n    float backScale = smoothstep(3.141529 * 2., 3.141529, fmod(t, 3.141529 * 2.));\n    float frontScale = smoothstep(0., 3.141529, fmod(t, 3.141529 * 2.));\n    float g = min(\n        sdRoundBox(p - float3(0., -2.3 - ((1. - backScale) * 3.), gap * -1. - tread), float3(backScale), 0.1),\n        sdRoundBox(p - float3(0., -2.3, 0. - tread), float3(1.), 0.1)\n    );\n    g = min(g, sdRoundBox(p - float3(0., -2.3, gap - tread), float3(1.), 0.1));\n    float alternate = fmod(floor(t / (3.141529 * 2.)), 2.);\n    p = (rotateY(alternate > 0.5 ? (frontScale - 1.) : (1. - frontScale))* p);\n    return min(g, sdRoundBox(p - float3(0., -2.3, gap * 2. - tread), float3(frontScale), 0.1));\n\t\t\t}\nfloat GetDist(float3 p) {\n    \n    float t = iTime * 10.;\n    //float2 id = floor(p.xz * 0.2);\n    //p.xz = frac(p.xz * 0.2) *5. - 2.5;\n    //float2 h = hash22(id);\n    float g = sdPig(p, max(sin(iTime * 10. /*+ h.x * 3.141529 * 2.*/), .0));\n    //g = min(g, sdPlane(p-float3(0,-1.3,0), float4(0, 1, 0, 0)));\n    g = min(g, sdBridge(p, t));\n    \n    return g;\n}\nfloat CalculateAO(float3 p, float3 n) {\n    float d = 0.6;\n    return smoothstep(0.,d,GetDist(p + n*d));\n}\nfloat Raymarch(float3 ro, float3 rd) {\n    float dO = 0.;\n    float dS;\n    for (int i = 0; i < MAX_STEPS; i+=1) {\n        float3 p = ro + rd * dO;\n        dS = GetDist(p);\n        dO += dS;\n        if (dS<SURF_DIST || dO>MAX_DIST) break;\n    }\n    return dO;\n}\n\nfloat3 GetNormal(float3 p) {\n    float2 e = float2(1e-2, 0.);\n\n    float3 n = GetDist(p) - float3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx)\n    );\n\n    return normalize(n);\n}\n\nfloat4 scene (float3 ro,float3 rd)\n{\n\n    float4 col = float4(0);\n\n    float d = Raymarch(ro, rd);\n    float3 light1Dir = normalize(float3(.8, 1, .2));\n    float3 light1Color = float3(1, 0.9, 0.9);\n\n    if (d < MAX_DIST) {\n        float3 p = ro + d * rd;\n        float3 n = GetNormal(p);\n        float ground = smoothstep(-1.18, -1.19, p.y);\n        col.rgb = lerp(float3(1, .7, .8), float3(0.5, 0.6, 0.9), ground);\n        col.rgb += pow(saturate(dot(reflect(rd, n), light1Dir)), .6) * light1Color * 0.3;\n        col.rgb += n * 0.15;\n        col.rgb *= CalculateAO(p, n) * 0.4 + 0.6;\n    }\n    else\n    {\n        float3 bg = lerp(float3(1, .7, .8), float3(0.5, 0.6, 0.9), rd.x);\n        bg = lerp(bg, float3(.8, .5, .8), rd.y);\n        col.rgb = bg;\n    }\n    return col;\n}\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 5, -5);\n    if(iMouse.w<0.5){\n    \tro.yz *= Rot(-0.4);\n    \tro.xz *= Rot(iTime*0.5+2.);\n    }else{\n        ro.yz *= Rot(-m.y*3.14+1.);\n    \tro.xz *= Rot(-m.x*6.2831);\n    }\n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n    \n    fragColor = scene(ro,rd);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdBcRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[274, 274, 298, 298, 398], [399, 399, 424, 424, 488], [489, 489, 524, 524, 552], [554, 554, 583, 583, 739], [740, 740, 790, 790, 898], [899, 899, 955, 955, 1064], [1065, 1065, 1100, 1100, 1134], [1135, 1135, 1182, 1182, 1283], [1285, 1285, 1319, 1319, 1999], [2001, 2001, 2036, 2036, 2808], [2809, 2809, 2834, 2834, 3170], [3171, 3171, 3210, 3210, 3277], [3278, 3278, 3316, 3316, 3539], [3541, 3541, 3569, 3569, 3751], [3753, 3753, 3789, 3789, 4527], [4529, 4529, 4548, 4548, 4624], [4626, 4626, 4678, 4678, 4873], [4876, 4876, 4933, 4933, 5340]], "test": "valid"}
{"id": "wdBcRK", "name": "NoiseWorld", "author": "hhotatea", "description": "BoxNoise", "tags": ["noise"], "likes": 2, "viewed": 61, "published": "Public", "date": "1586944697", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float noise(vec3 pos)\n{\n    return fract(sin(length(dot(pos,vec3(501.,301.,1501.))))*1e5);\n}\n\nvec3 rot_x (vec3 vec, float angle)\n{\n    return vec3(vec.x,vec.y*cos(angle)+vec.z*sin(angle),vec.z*cos(angle)-vec.y*sin(angle));\n}\n\nvec3 rot_y (vec3 vec, float angle)\n{\n    return vec3(vec.x*cos(angle)-vec.z*sin(angle),vec.y,vec.x*sin(angle)+vec.z*cos(angle));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.*fragCoord/iResolution.xy -1.;\n    fragColor = vec4(0.,0.,0.,1.);\n    vec3 startPos = vec3(iTime*.3,cos(iTime),iTime);\n    for(int i=0; i<500; i++)\n    {\n        vec3 lay = rot_y( rot_x(normalize(vec3(uv,1.)), iMouse.y*.003), iMouse.x*0.003);\n        vec3 pos = startPos + lay * float(i)*0.03;\n        pos = floor(pos*1.);\n        float fog = pow(noise(pos),7.)*0.01;\n        fragColor.rgb += vec3(fog,0.,0.);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdBcRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 92], [94, 94, 130, 130, 224], [226, 226, 262, 262, 356], [357, 357, 414, 414, 848]], "test": "valid"}
{"id": "WdBcRV", "name": "NewtonFractal on sphere", "author": "elle", "description": "Newton fractal on sphere", "tags": ["fractal", "newton"], "likes": 2, "viewed": 232, "published": "Public API", "date": "1587153249", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 sphere = vec4(0.0, 0.0, 1.0, 0.4);\nvec3 lightPos = vec3(-9.0, 8.0, -8.0);\nvec3 lightCol = vec3(1.0, 1.0, 1.0);\n\nfloat sphereDist1(vec3 ro, vec3 rd)\n{\n\tfloat R = sphere.w;\n\tvec3 d1 = sphere.xyz - ro;\n\tfloat b = dot(rd, d1);\n\tfloat d2 = dot(d1, d1) - b * b;\n\tfloat h2 = R * R - d2;\n    if (h2 <= 0.0)\n        return (-1.0);\n    return (b - sqrt(h2));\n}\n\nfloat sphereDist(vec3 p)\n{\n return (length(p - sphere.xyz) - sphere.w);   \n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0,4.0,2.0),6.0) - 3.0) - 1.0, 0.0, 1.0);\n\treturn (c.z * mix(vec3(1.0), rgb, c.y));\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat getShadow(vec3 ro, vec3 rd, float tmin, float tmax, const float k)\n{\n\tfloat res = 1.0;\n    float t = tmin;\n    for( int i = 0; i < 50; i++)\n    {\n\t\tfloat h = sphereDist(ro + rd * t);\n        res = min(res, k * h / t);\n        t += clamp(h, 0.02, 0.20);\n        if(res < 0.005 || t > tmax)\n            break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 getNormal(vec3 pos)\n{\n    const float ep = 0.0001;\n    vec2 e = vec2(1.0, -1.0) * 0.5773;\n    return normalize( e.xyy*sphereDist(pos + e.xyy*ep) + \n\t\t\t\t\t  e.yyx*sphereDist(pos + e.yyx*ep) + \n\t\t\t\t\t  e.yxy*sphereDist(pos + e.yxy*ep) + \n\t\t\t\t\t  e.xxx*sphereDist(pos + e.xxx*ep));\n}\n\n\nvec2 f(vec2 z)\n{\n    float mag = dot(z, z);\n    return (2.0 * z + vec2(z.x * z.x - z.y * z.y, -2.0 * z.x * z.y) / (mag * mag)) / 3.0;\n}\n\nvec2 roots[] = vec2[](vec2(1.0, 0.0), vec2(-0.5, 0.5 * sqrt(3.0)), vec2(-0.5, -0.5 * sqrt(3.0)));\n\nfloat newton(vec2 z) \n{\n    vec4 res;\n    for (int i = 0; i < 100; ++i)\n    {\n    \tz = f(z); \n        for (int root = 0; root < roots.length(); ++root)\n        {\n            vec2 differ = z - roots[root];\n            float dist = dot(differ, differ);\n            if (dist < 0.00001)\n\t\t\t\treturn (0.78 * cos(1.5 * log2(log(dist) / log(0.0001))));\n        }\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n   vec2 aspectRatio = vec2(iResolution.x / iResolution.y, 1.0);\n    vec2 uv = aspectRatio * (fragCoord.xy / iResolution.xy - 0.5);\n    vec2 mouse = 7.0 * (iMouse.xy / iResolution.xy - 0.5);  \n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    mouse.y += 0.3;\n\tfloat rot = -0.2;//iTime * 0.2;\n    mat3 rotX = mat3(\n        vec3(cos(mouse.x - rot), 0.0, sin(mouse.x - rot)),\n        vec3(0.0, 1.0, 0.0),\n        vec3(-sin(mouse.x - rot), 0.0, cos(mouse.x - rot)));  \n\tmat3 rotY = mat3(\n        vec3(1.0, 0.0, 0.0),\n        vec3(0.0, cos(mouse.y), sin(mouse.y)),\n        vec3(0.0, -sin(mouse.y), cos(mouse.y)));\n\t\n    float dSphere = sphereDist1(ro, rd);\n\tvec3 pos = ro + dSphere * rd;\n\tvec3 normal = getNormal(pos);\n\tvec3 v3 = rotX * rotY * normal;\n    vec2 v2 = 9.0 * (cos(iTime * 0.2)) * v3.xy / abs(v3.z);\n    vec3 material;\n    if (dSphere < 0.0)\n        material = hsv2rgb(vec3(newton(v2), 0.8, 0.5));\n    else\n        material = hsv2rgb(vec3(newton(v2), 1.0, 1.2));\n    vec3 lightDir = normalize(vec3(lightPos - pos));\n    vec3 reflectDir = normalize(reflect(lightDir, normal));\n    float shadow = getShadow(pos, lightDir, 0.001, 1.0, 32.0);\n        \n    float diffuse = clamp(dot(normal, lightDir), 0.0, 1.0) * shadow * 0.4;\n    float ambient = 0.4 + 0.55 * normal.y;\n\tfloat specular = pow(clamp(dot(reflectDir, rd), 0.0, 1.0), 32.0) * 1.2 * shadow;\n        \n\tvec3 color = lightCol * material * (diffuse + specular + ambient);\n    color = sqrt(color);\n    color = pow(color, lightCol);\n    fragColor = vec4(color, 1.0); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdBcRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[117, 117, 154, 154, 355], [357, 357, 383, 383, 433], [435, 435, 457, 457, 590], [592, 654, 728, 728, 1008], [1010, 1074, 1100, 1100, 1356], [1359, 1359, 1375, 1375, 1494], [1595, 1595, 1618, 1618, 1957], [1959, 1959, 2014, 2014, 3570]], "test": "error"}
{"id": "WdByRd", "name": "fracDemo", "author": "okh0056", "description": "psuedo fractal", "tags": ["fractal", "demo"], "likes": 5, "viewed": 286, "published": "Public API", "date": "1588116313", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define ANGLE 2.1\n#define DELTA 0.00635\n#define XOFF .034531\n\n#define time iTime\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n\n\nfloat f(vec2 p, float featureSize)\n{\n\tp.x = cos(p.x*0.6+time*0.2)*log(time+p.x*0.1)*ANGLE;\t\n    p += sin(p.x*0.5)*ANGLE;\n    return smoothstep(-0.01,featureSize,abs(p.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x/iResolution.y;\n    float featureSize = 135./((iResolution.x*aspect+iResolution.y));\n\n    vec2 p = (fragCoord.xy/(ANGLE*XOFF)) / (iResolution.xy*ANGLE);\n\tp.x *= aspect;\n\tp.y = abs(p.y);\n\t\n\tvec3 col = vec3(.04);\n    vec3 col2 = (cos(vec3(3.3,2.5,2.2)-2.*0.15)*0.74)*(1.-f(p,featureSize));\n\tfor(float i=0.;i<26.;i+=(XOFF*12.))\n\t{\n\t\tcol2 = (cos(vec3(3.3,2.5,2.2)-i*ANGLE)*0.74)*(1.-f(p,featureSize));\n\t\tcol = max(col,col2);\n\t\t\n        p.x -= XOFF;\n        p.y -= tanh(time*0.31+1.5)*3.;//((ANGLE/XOFF)*XOFF); //1.5+1.5;\n\t\tp*= mm2(i*DELTA+ANGLE);\n\t\t\n        vec2 pa = vec2(abs(p.x-0.9),abs(p.y));\n        vec2 pb = vec2(p.x,abs(p.y));\n        \n        p = mix(pa,pb,smoothstep(-.47,.67,cosh(time*0.14)-ANGLE));\n\t}\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdByRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[82, 82, 103, 103, 155], [158, 158, 194, 194, 331], [333, 333, 390, 390, 1162]], "test": "valid"}
{"id": "WdByRR", "name": "UnderWater", "author": "Hei149", "description": "raymarching", "tags": ["raymarching"], "likes": 4, "viewed": 111, "published": "Public", "date": "1585910400", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdCylinder(vec3 p, float r, float h)\n{\n    return max(length(p.xz) -r, abs(p.y) - h);\n}\n\nfloat hash( float n )\n{\n    return fract(sin(n) * 43758.5453);\n}\n\n//Hash from iq\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 k = fract(x);\n\tk = k*k*(3.0-2.0*k);\n\t\n    float n = p.x + p.y * 57.0 + p.z * 113.0;\n\tfloat a = hash(n);\n    float b = hash(n + 1.0);\n    float c = hash(n + 57.0);\n    float d = hash(n + 58.0);\n\n    float e = hash(n + 113.0);\n    float f = hash(n + 114.0);\n    float g = hash(n + 170.0);\n    float h = hash(n + 171.0);\n\t\n    float res = mix(mix(mix(a, b, k.x), mix(c, d, k.x), k.y),\n                    mix(mix(e, f, k.x), mix(g, h, k.x), k.y),\n                k.z);\n    return res;                \n}\n#define rotate(ang) mat2(cos(ang), sin(ang), -sin(ang), cos(ang))\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat map(vec3 p)\n{\n    vec3 rp = p;\n    vec2 id = floor(rp.xz / 20.0);\n    rp.xz = mod(rp.xz, 20.0) - 10.0;\n    float d = sdCylinder(rp + vec3(hash(id.x) * 20.0 - 10.0, 0.0, hash(id.y) * 20.0 - 10.), 2.0, 50.);\n    float ground = noise(p * 0.5) + noise(p) * 0.5 + noise(p * 2.0) * 0.25;\n    d = smin(d, p.y + 10.0, 5.0);\n    return d - ground;\n}\n\nvec3 norm(vec3 p)\n{\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n    ));\n}\n\nfloat caustic(vec3 p)\n{\n    return abs(noise(p + mod(iTime, 40.0) * 2.0) - noise(p + vec3(4.0, 0.0, 4.0) + mod(iTime,40.0) * 2.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 r0 = vec3(20.0, 10.0, -20.0);\n    r0.xz *= rotate(0.58);\n\n    vec3 ww = normalize(-r0);\n    vec3 uu = normalize(cross(vec3(0, 1, 0), ww));\n    vec3 vv = normalize(cross(ww, uu));\n\n    vec3 rd = normalize(uu * uv.x + vv * uv.y + ww);\n\n    float d = 0.0;\n    for(int i = 0; i < 100; ++i)\n    {\n        vec3 p = r0 + d * rd;\n        float t = map(p);\n        d += t;\n        if(d > 100.0 || t < 0.001) break;\n    }\n    vec3 col = vec3(0.0);\n    vec3 p = r0 + d * rd;\n    if(d < 100.0)\n    {\n        vec3 n = norm(p);\n        vec3 ld = normalize(vec3(0.5, 1.0, -0.5));\n        float diff = max(dot(n, ld), 0.0);\n        col += diff * vec3(0.6, 0.8, 1.0);\n        col += (n.y * 0.5 + 0.5) * vec3(0.16, 0.20, 0.28);\n        float n1 = noise(p * 0.5);\n        float n2 = noise(p);\n        float n3 = noise(p * 8.);\n        col *= n1 * vec3(0.2, 1.0, 0.1) * 2.0 + n2 * vec3(2.0, 0.2, 0.1) * 2.0 + n3 * vec3(0.5, 0.5, 0.1);\n    }\n    \n    col += smoothstep(0.0, 1.0, (1.0 - caustic(p * 0.5)) * 0.5);\n    float fog = clamp(exp(-d * 0.035), 0.0, 1.0);\n    col = mix(col, vec3(0.2, 0.5, 1.0), 1.0 - fog);\n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdByRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 44, 44, 93], [95, 95, 118, 118, 159], [161, 176, 202, 202, 734], [801, 801, 842, 842, 935], [937, 937, 956, 956, 1283], [1285, 1285, 1304, 1304, 1494], [1496, 1496, 1519, 1519, 1629], [1631, 1631, 1686, 1686, 2930]], "test": "valid"}
{"id": "WdByRW", "name": "Voxel Flower", "author": "Roninkoi", "description": "Trying to figure out voxels", "tags": ["raymarching", "flower", "voxel"], "likes": 5, "viewed": 273, "published": "Public API", "date": "1586147673", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265\n#define MAXIT 180\n#define EPSILON 0.05\n \n#define minx4(a, b) ((a.w) < (b.w) ? (a) : (b))\n#define minx2(a, b) ((a.x) < (b.x) ? (a) : (b))\n\nmat3 rotX(float a)\n{\n    return mat3(\n        1., 0., 0.,\n        0., cos(a), -sin(a),\n        0., sin(a), cos(a)\n    );\n}\n \nmat3 rotY(float a)\n{\n    return mat3(\n        cos(a), 0.0, -sin(a),\n        0., 1., 0.,\n        sin(a), 0.0, cos(a)\n    );\n}\n \nmat3 rotZ(float a)\n{\n    return mat3(\n        cos(a), -sin(a), 0.,\n        sin(a), cos(a), 0.,\n        0., 0., 1.\n    );\n}\n \nfloat t;\n \nfloat sphere(vec3 r, float a)\n{\n    return length(r) - a;\n}\n \nfloat torus(vec3 r, vec2 a)\n{\n    vec2 p = vec2(length(r.xz) - a.x, r.y);\n    return length(p) - a.y;\n}\n \nfloat plane(vec3 r, vec3 o, vec3 n) {\n    return dot(r - o, n);\n}\n\nfloat cylinder(vec3 r, vec2 a)\n{\n\tvec2 p = abs(vec2(length(r.xz), r.y)) - a;\n\t\n\treturn min(max(p.x, p.y), 0.0) + length(max(p, 0.));\n}\n \nfloat bud(vec3 r, float a)\n{\n\tr.xz += cos((r.y + r.z) * 3.) * 0.2;\n\t\n\tr.y += sin(length(r.xzx) * 6.) * 0.2;\n\t\n    return length(r) - a + sin(length(r.xz) * 12.) * 0.4;\n}\n\nfloat stem(vec3 r, vec2 a)\n{\n\tr.xz += cos(r.y) * 0.15 + sin(r.y * 1.5) * 0.3;\n\tr.xz += cos(r.y * 0.25) * 1.;\n\t\n\tvec2 p = abs(vec2(length(r.xz), r.y)) - a;\n\t\n\treturn min(max(p.x, p.y), 0.0) + length(max(p, 0.));\n}\n\nfloat leaf(vec3 r, vec3 a)\n{\n\tr.xz += sin(length(r.xz + 1.) * 1.5);\n\tr.y += (r.x + r.z) * 0.5;\n\tr.x *= 0.9;\n\t\n    vec3 p = abs(r) - a;\n\t\n    return length(max(p, 0.));\n}\n\nfloat box(vec3 r, vec3 a)\n{\n    vec3 p = (abs(r) - a);\n    return length(max(p, 0.));\n}\n \nfloat shade(vec3 n, vec3 rd)\n{\n    return clamp(max(dot(n, -rd), 0.) + 1., 0., 1.);\n}\n \nvec3 fog(float z, vec3 col, vec3 fogCol)\n{\n    return mix(fogCol, col, exp(-z));\n}\n \nfloat hash(vec2 r) {\n    return fract(sin(dot(r, vec2(15.5921, 96.654654))) * 23626.3663);\n}\n\nmat3 obj;\n \nvec2 map(vec3 r)\n{\n    float b = 0.05;\n    vec3 rr = vec3(0.);\n    rr.x = floor(r.x / b) * b;\n    rr.y = floor(r.y / b) * b;\n    rr.z = floor(r.z / b) * b;\n\t\n    vec3 rb1 = obj * rr;\n    \n    vec2 b1 = vec2(\n        bud(rotX(0.6) * rotZ(-0.1) * rb1, 2.),\n        (int(sin(rb1.xyz * 5.) * cos(rb1.yxz * 5.) * 2.) % 2)\n    );\n\tvec2 s1 = vec2(\n        stem(rb1 + vec3(0., 7., 1.), vec2(.3, 6.81)),\n        (int(sin(rb1.y * 3.1) * 2.) % 2) + 2\n    );\n\t\n\tvec2 l1 = vec2(\n        leaf(rb1 + vec3(1.5, 5., 2.2), vec3(1., 0.1, 1.0)),\n        (int(sin(rb1.x * rb1.z * 4.1) * 2.) % 2) + 4\n    );\n    \n    return minx2(l1, minx2(b1, s1));\n}\n\nvec3 matCol(vec2 o)\n{\n    if (o.y == 0.)\n        return normalize(vec3(1., 0., .0));\n   \n    if (o.y == 1.)\n        return normalize(vec3(1.1, 0., .6));\n    \n    if (o.y == 2.)\n        return (vec3(0.4, .5, 0.));\n    \n    if (o.y == 3.)\n        return normalize(vec3(.2, 1., 0.4));\n    \n    if (o.y == 4.)\n        return (vec3(0.8, .5, 0.));\n    \n    if (o.y == 5.)\n        return normalize(vec3(.5, .5, 0.));\n   \n    return vec3(0.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    t = -iTime * 0.4;\n    \n    obj = rotY(t);\n    obj *= mat3(2.);\n   \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n   \n    mat3 cam = rotY(-PI) * rotX(0.3);\n       \n    vec3 ro = vec3(0., 0.5, -3.3);\n    vec3 rd = cam * normalize(vec3(uv * 2., -1.));\n    vec3 r = ro;\n   \n    vec3 bcol = normalize(vec3(.8, 2., 0.7)) * (.7 + cos(length(uv.xy) * 1.5) * .6) * 0.8;\n    vec4 col = vec4(0.);\n    col.rgb = bcol;\n   \n    float sh = 1.;\n   \n    for (int i = 0; i < MAXIT; ++i) {\n        vec2 d = map(r);\n        float z = length(r - ro);\n       \n        if (d.x < EPSILON) {\n            col.rgb = mix(col.rgb, \n\t\t\t\tmatCol(d), \n\t\t\t\tshade(normalize(r), rd));\n            col.rgb = fog(z * 0.1, col.rgb, bcol);\n            break;\n        }\n       \n        d.x *= 0.7 - 0.1 * hash(uv);\n\t\tr += rd * d.x * 0.15;\n       \n        sh = (float(i) / float(MAXIT));\n    }\n   \n    if (sh < 0.8)\n\t\tcol.rgb *= exp(-sqrt(sh) * 1.2);\n   \n    fragColor = vec4(col.rgb, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdByRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[160, 160, 180, 180, 282], [285, 285, 305, 305, 409], [412, 412, 432, 432, 534], [548, 548, 579, 579, 607], [610, 610, 639, 639, 713], [716, 716, 753, 753, 781], [783, 783, 815, 815, 917], [920, 920, 948, 948, 1089], [1091, 1091, 1119, 1119, 1303], [1305, 1305, 1333, 1333, 1474], [1476, 1476, 1503, 1503, 1563], [1566, 1566, 1596, 1596, 1651], [1654, 1654, 1696, 1696, 1736], [1739, 1739, 1759, 1759, 1831], [2476, 2476, 2497, 2497, 2912]], "test": "valid"}
{"id": "WdByRy", "name": "Sierpinski_pieces", "author": "elle", "description": "Sierpinski triangle", "tags": ["fractal", "sierpinski"], "likes": 3, "viewed": 209, "published": "Public API", "date": "1586821573", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sierpinski(vec3 p)\n{\n    const int iter_cnt = 20;\n    float scale = clamp(sin((iTime - 7.0) * 0.2) + 2.02, 1.0, 2.0);\n    float offset = 1.0;\n    for (int n = 0; n < iter_cnt; n++)\n    {\n       if(p.x + p.y < 0.0) p.xy = -p.yx; // fold 1\n       if(p.x + p.z < 0.0) p.xz = -p.zx; // fold 2\n       if(p.y + p.z < 0.0) p.zy = -p.yz; // fold 3\t\n       p = p * scale - offset * (scale - 1.0);\n    }\n    return (length(p)) * pow(scale, -float(iter_cnt));\n}\n\nvec3 rotate(vec3 p, float angleX, float angleY)\n{\n    float cosA = cos(angleY);\n\tfloat sinA = sin(angleY);\n\tvec3 r = vec3(p.x, sinA * p.z + cosA * p.y, cosA * p.z - sinA * p.y);\n    cosA = cos(angleX);\n\tsinA = sin(angleX);\n\treturn (-vec3(cosA * r.x - sinA * r.z, r.y, sinA * r.x + cosA * r.z));\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0,4.0,2.0),6.0) - 3.0) - 1.0, 0.0, 1.0);\n\treturn (c.z * mix(vec3(1.0), rgb, c.y));\n}\n\nfloat distSphere(vec3 p, float r)\n{\n\treturn (length(p) - r);\n}\n\nfloat distPlane(vec3 p, vec4 n)\n{\n\treturn (dot(p, n.xyz) + n.w);\n}\n\nbool bgS = false;\nbool bgP = false;\nfloat distanceEstimate(vec3 p)\n{\n\tfloat dSphere = -distSphere(p, 30.0);\t\n\tfloat dFractal = sierpinski(p);\n    float dPlane = distPlane(p, normalize(vec4(-10.0, -10.0, 10.0, 10.1)));\n    bgP = dPlane < dFractal ? true : false;\n    bgS = dSphere < dPlane ? true : false;\n\treturn (min(min(dFractal, dPlane), dSphere));\n}\n\nvec3 getNormal(vec3 pos, float dist)\n{\n    vec2 eps = vec2(0.001, 0.0);\n\treturn normalize(vec3(\n           distanceEstimate(pos + eps.xyy),\n           distanceEstimate(pos + eps.yxy),\n           distanceEstimate(pos + eps.yyx)) - dist);\n}\n\nfloat softShadow(in vec3 ro, in vec3 rd, in float k)\n{\n    float res = 1.0;\n    float t = 0.0;\n    for(int i = 0; i < 64; i++)\n    {\n        float d = distanceEstimate(ro + rd * t);\n        res = min(res, k * d/t);\n        if(res < 0.001)\n            break;\n        t += clamp(d, 0.01, 0.2);\n    }\n    return (clamp(res, 0.0, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 aspectRatio = vec2(iResolution.x/iResolution.y, 1.0);\n\tvec2 uv = aspectRatio * (fragCoord.xy / iResolution.xy - 0.5);\n    vec2 mouse = 4.0 * (iMouse.xy / iResolution.xy - 0.5);\n    mouse.x += 2.7;\n    mouse.y -= 0.4;\n    vec3 ro = rotate(vec3(0.0, -0.1, sin((iTime - 7.0) * 0.2) + 2.5), mouse.x, mouse.y);\n    vec3 rd = -rotate(vec3(uv, 1.0), mouse.x, mouse.y);  \n    vec3 light = rotate(vec3(0.7, -0.22, 0.5), mouse.x, mouse.y);\n    vec3 lightColor = vec3(0.9, 1.0, 1.0);\n    vec3 material;\n    vec3 color;\n    float eps = 0.002;\n\tfloat dist;\n\tfor(float n = 0.0; n < 200.0; n++)\n    {\n\t\tdist = distanceEstimate(ro);\n\t\tif(dist < eps)\n\t\t\tbreak;\n\t\tro += rd * dist * 0.5;\n\t}\n\tif(bgS == true)\n\t{ \n        color = vec3(1.0, 1.0, 0.5) * (1.0 + 0.9 * uv.y);\n\t\tfragColor = vec4(color, 1.0);\n\t\treturn;\n\t}\n    if(bgP == true) \n        material = hsv2rgb(vec3(dot(ro, ro) * 0.0001 + 0.52, ro.y, 0.4));\n    else\n        material = hsv2rgb(vec3(dot(ro, ro) * 0.11 + 0.62, 0.98, 1.2));\n\tvec3 norm = getNormal(ro, dist);\n\tvec3 lightDir = normalize(light - rd);   \n\tfloat shadow = softShadow(ro + 0.001 * norm, light, 20.0);\n    float ambient = 0.5;\n\tfloat diff = clamp(dot(light, norm), 0.0, 1.0) * shadow * 2.5;\n\tfloat spec = pow(clamp(dot(norm, lightDir), 0.0, 1.0), 32.0) * shadow * 2.0;\n \tcolor = (lightColor * (ambient + diff + spec) * material);   \n    color = pow(color, 0.9 * lightColor);\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdByRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 456], [458, 458, 507, 507, 754], [756, 756, 778, 778, 911], [913, 913, 948, 948, 975], [977, 977, 1010, 1010, 1043], [1081, 1081, 1113, 1113, 1398], [1400, 1400, 1438, 1438, 1638], [1640, 1640, 1694, 1694, 1974], [1976, 1976, 2031, 2031, 3455]], "test": "valid"}
{"id": "wdByRz", "name": "star-pattern", "author": "bckmnn", "description": "my first attempt to create a shader.\nthanks to The Art of Code (https://www.youtube.com/channel/UCcAlTqd9zID6aNX3TzwxJXg) it actually turned out ok.", "tags": ["bckmnn"], "likes": 0, "viewed": 27, "published": "Public", "date": "1586076374", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(a, b, t) smoothstep(a, b, t)\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\nvec4 makeStar(vec2 uv, vec2 p, float size){\n    // Angle and radius from the current pixel\n    uv -= p;\n    uv = uv/size;\n    float a = atan(-uv.x,uv.y)+PI;\n    float b = atan(uv.x,uv.y)+PI;\n    float r = TWO_PI/float(3);\n\n    // Shaping function that modulate the distance\n    float d = cos(floor(.5+a/r)*r-a+.3)*length(uv);\n    float e = cos(floor(.5+b/r)*r-b+.3)*length(uv);\n    d = min(d,e);\n    return vec4(1.-S(.1,.1,d));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 UV = uv;\n\t//uv.x = abs(uv.x);\n\n    vec4 col = vec4(.94);\n    \t\n\tfloat d = 0.0;\n    //uv.x = abs(uv.x);\n  \tuv *= 10.+2.*sin(iTime*0.7);\n    //uv += iTime*0.9;\n    \n    //uv += cos(UV*3.14);\n    \n    vec2 id=floor(uv);\n    float checker = mod(id.y,2.);\n    \n    vec4 star0 = makeStar(UV, vec2(0.,-0.1), 1.2); \n        \n    vec2 gv = fract(uv);  // split domains\n    \n    vec4 star = makeStar(gv, vec2(0.5,0.5), .7);\n    \n    vec4 star1 = makeStar(gv, vec2(0., 0.5), .7);\n    vec4 star2 = makeStar(gv, vec2(1.,0.5), .7);\n    \n    \n    //col.rg = UV;\n    float fade = (1.-abs(UV.x))*(.7-UV.y);\n    //col = mix(col,star0-0.1, star0.a);\n\n    if(checker == 1.0){\n    \tcol = mix(col, star, star.a*fade);\n    }else{\n    \tcol = mix(col, star1, star1.a*fade);\n    \tcol = mix(col, star2, star2.a*fade);\n    }\n    \n   \t//col.rg += id*.2; // show cells\n    //col.rg = gv;  // show domains\n    //col.rg *= UV;\n    \n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdByRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[94, 94, 137, 184, 523], [526, 526, 583, 583, 1574]], "test": "valid"}
{"id": "wdByWc", "name": "Fun With Vornoi", "author": "Abarrow", "description": "Having a bit of fun with Vornoi diagrams.", "tags": ["2d", "vornoi"], "likes": 5, "viewed": 64, "published": "Public", "date": "1587421127", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int pt_count = 8;\n\nconst float pi = 3.14159265359;\n\n\nvec3 hsv_to_rgb(float h, float s, float v) {\n    float c = v * s;\n    float m = v - c;    \n    float x = c * (1.0 - abs(mod(h / (pi / 3.0), 2.0) - 1.0));\n    \n    vec3 pure;\n    if (h < (pi/3.0)) {\n        pure = vec3(c, x, 0.0);\n    } else if (h < (2.0 * pi / 3.0)) {\n        pure = vec3(x, c, 0.0);\n    } else if (h < pi) {\n        pure = vec3(0.0, c, x);\n    } else if (h < (4.0 * pi / 3.0)) {\n        pure = vec3(0.0, x, c);\n    } else if (h < (5.0 * pi / 3.0)) {\n        pure = vec3(x, 0.0, c);\n    } else {\n    \tpure = vec3(c, 0.0, x);\n    }\n\n    return m + pure;\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.yy;\n    vec2 center = vec2(iResolution.x / iResolution.y / 2.0, 0.5);\n    \n    float pixel_size = 3.0 / iResolution.x;\n    \n    vec3 col = vec3(0.0, 0.0, 0.0);\n   \tfloat min_dist = length(iResolution.xy);\n\n    for (int i = 0; i < pt_count; ++i) {\n        float prop = float(i);\n        float hue = prop / float(pt_count) * 2.0 * pi;\n        \n        float time = iTime + hue;\n        float radius = cos(time * 3.0) * 0.25 + 0.25;\n        vec2 pt = vec2(cos(time) * radius, sin(time) * radius) + center;\n        vec3 pt_color = hsv_to_rgb(hue, 1.0, 1.0);\n        \n        float dist = length(pt - uv);\n        if (dist < min_dist) {\n            min_dist = dist;\n            if (dist < pixel_size) {\n                col = vec3(1.0, 1.0, 1.0);\n            } else {\n                col = pt_color;\n            }\n        }\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdByWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 103, 103, 630], [633, 633, 690, 690, 1584]], "test": "valid"}
{"id": "WdByWd", "name": "Very Ugly Earth", "author": "42yeah", "description": "Because today's Earth Day? Anyway, you don't want to look behind the globe. I am still terrible at raymarching.", "tags": ["whatevs"], "likes": 0, "viewed": 37, "published": "Public", "date": "1587563374", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define EPSILON 0.001\n\nvec2 rand2d(vec2 p) {\n\treturn fract(sin(vec2(\n        dot(p, vec2(31.516, 42.567)),\n        dot(p, vec2(74.52, 636.642))\n    )) * 10000.0);\n}\n\nvec2 ballProject(vec3 p) {\n    return vec2(p.x / (1.0 - p.z), p.y / (1.0 - p.z)); \n}\n\nfloat perlin(vec2 p) {\n    vec2 u = floor(p);\n    vec2 f = fract(p);\n    vec2 s = smoothstep(0.0, 1.0, f);\n\n    vec2 a = rand2d(u);\n    vec2 b = rand2d(u + vec2(1.0, 0.0));\n    vec2 c = rand2d(u + vec2(0.0, 1.0));\n    vec2 d = rand2d(u + vec2(1.0, 1.0));\n    \n    return mix(mix(dot(a, f), dot(b, f - vec2(1.0, 0.0)), s.x),\n               mix(dot(c, f - vec2(0.0, 1.0)), dot(d, f - vec2(1.0, 1.0)), s.x),\n               s.y) * 0.5 + 0.5;\n}\n\nfloat sphereSDF(vec3 p) {\n    return length(p) - 1.0;\n}\n\nfloat sceneSDF(vec3 p) {\n \treturn sphereSDF(p);   \n}\n\nvec3 rayDirection(float fov, vec2 size, vec2 coord) {\n    vec2 xy = coord - size / 2.0;\n    float z = size.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, z));\n}\n\nvec3 normalOf(vec3 p) {\n    return normalize(vec3(\n    \tsceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 phong(vec3 p, vec3 eye) {\n    vec3 lightPos = vec3(sin(iTime) * 30.0, 10.0, cos(iTime) * 30.0),\n        lightColor = vec3(1.0, 1.0, 1.0),\n        objColor = vec3(1.0, 0.5, 0.0);\n    \n    vec3 n = normalOf(p);\n    float shinyness = 32.0;\n    float specularMultiplier = 0.0;\n\n    vec2 proj = ballProject(p);\n    float perl = perlin(proj);\n\n    if (perl < 0.45) {\n        objColor = vec3(0.1, 0.2, 0.7);\n        n = n + normalize(p - eye) * perl * 0.3;\n        specularMultiplier = 1.0;\n    } else if (perl < 0.55) {\n        objColor = vec3(0.3, 0.9, 0.3);\n        n = n + vec3(rand2d(proj), rand2d(proj + 1.0).x) * 0.1;\n    } else {\n        objColor = vec3(1.0, 1.0, 1.0);\n        n = n - normalize(p - eye) * perl * 0.5;\n        specularMultiplier = 1.3;\n    }\n\n    \n    vec3 lightDir = normalize(lightPos - p);\n    vec3 refl = normalize(reflect(-lightDir, n));\n    vec3 eyeDir = normalize(eye - p);\n    \n    float diffuse = dot(lightDir, n);\n    if (diffuse < 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    \n    vec3 o = objColor * (0.1                                       // ambient\n        + dot(lightDir, n)                                         // diffuse\n        + pow(dot(eyeDir, refl), shinyness) * specularMultiplier); // specular\n    return o;\n}\n\nfloat march(vec3 eye, vec3 direction, float start, float end) {\n    float depth = start;\n    \n    for (int i = 0; i < 200; i++) {\n    \tfloat dist = sceneSDF(eye + direction * depth);\n        if (dist <= EPSILON) {\n            return depth + dist;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    vec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 0.0, -6.0);\n    float dist = march(eye, dir, 0.0, 200.0);\n    if (dist >= 200.0) {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        return;  \n    }\n    \n    vec3 p = eye + dir * dist;\n    fragColor = vec4(phong(p, eye), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdByWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 44, 44, 164], [166, 166, 192, 192, 250], [252, 252, 274, 274, 691], [693, 693, 718, 718, 748], [750, 750, 774, 774, 802], [804, 804, 857, 857, 976], [978, 978, 1001, 1001, 1307], [1309, 1309, 1339, 1339, 2578], [2580, 2580, 2643, 2643, 2945], [2947, 2947, 3004, 3054, 3417]], "test": "valid"}
{"id": "WdByzc", "name": "Mandelbrot on sphere", "author": "elle", "description": "mandelbrot on sphere", "tags": ["fractal", "mandelbrot"], "likes": 3, "viewed": 213, "published": "Public API", "date": "1587038656", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 sphere = vec4(0.0, 0.0, 1.0, 0.4);\nvec3 lightPos = vec3(-9.0, 8.0, -8.0);\nvec3 lightCol = vec3(0.8, 0.9, 1.0);\n\nfloat sphereDist1(vec3 ro, vec3 rd)\n{\n\tfloat R = sphere.w;\n\tvec3 d1 = sphere.xyz - ro;\n\tfloat b = dot(rd, d1);\n\tfloat d2 = dot(d1, d1) - b * b;\n\tfloat h2 = R * R - d2;\n    if (h2 <= 0.0)\n        return (-1.0);\n    return (b - sqrt(h2));\n}\n\nfloat sphereDist(vec3 p)\n{\n return (length(p - sphere.xyz) - sphere.w);   \n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat getShadow(vec3 ro, vec3 rd, float tmin, float tmax, const float k)\n{\n\tfloat res = 1.0;\n    float t = tmin;\n    for( int i = 0; i < 50; i++)\n    {\n\t\tfloat h = sphereDist(ro + rd * t);\n        res = min(res, k * h / t);\n        t += clamp(h, 0.02, 0.20);\n        if(res < 0.005 || t > tmax)\n            break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 getNormal(vec3 pos)\n{\n    const float ep = 0.0001;\n    vec2 e = vec2(1.0, -1.0) * 0.5773;\n    return normalize( e.xyy*sphereDist(pos + e.xyy*ep) + \n\t\t\t\t\t  e.yyx*sphereDist(pos + e.yyx*ep) + \n\t\t\t\t\t  e.yxy*sphereDist(pos + e.yxy*ep) + \n\t\t\t\t\t  e.xxx*sphereDist(pos + e.xxx*ep));\n}\n\n//smooth color gradient - https://www.shadertoy.com/view/4df3Rn\nfloat mandelbrot(vec2 c)\n{\n    vec2 z = vec2(0.0);\n    const float B = 256.0;\n    float l = 0.0;\n    for (int i = 0; i < 512; i++)\n    {\n        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n        if (dot(z, z) > (B * B))\n            break;\n        l += 1.0;\n    }\n    if (l > 511.0)\n        return (0.0); \n    //float l = l - log(log(length(z))/log(B))/log(2.0);\n    l = l - log2(log2(dot(z, z))) + 4.0;\n    return (l);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 aspectRatio = vec2(iResolution.x / iResolution.y, 1.0);\n    vec2 uv = aspectRatio * (fragCoord.xy / iResolution.xy - 0.5);\n    vec2 mouse = 7.0 * (iMouse.xy / iResolution.xy - 0.5);  \n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    \n\tfloat rot = iTime * 0.2;\n    mat3 rotX = mat3(\n        vec3(cos(mouse.x - rot), 0.0, sin(mouse.x - rot)),\n        vec3(0.0, 1.0, 0.0),\n        vec3(-sin(mouse.x - rot), 0.0, cos(mouse.x - rot)));  \n\tmat3 rotY = mat3(\n        vec3(1.0, 0.0, 0.0),\n        vec3(0.0, cos(mouse.y), sin(mouse.y)),\n        vec3(0.0, -sin(mouse.y), cos(mouse.y)));\n\t\n    vec3 color = vec3(0.09 - uv.x, 0.38, uv.x + 0.4) * (0.9 - uv.x);\n    \n    float dSphere = sphereDist1(ro, rd);\n    if (dSphere < 0.0)\n    {\n\t\tfragColor = vec4(color, 1.0);\n\t\treturn;\n    }\n\tvec3 pos = ro + dSphere * rd;\n\tvec3 normal = getNormal(pos);\n\tvec3 v3 = rotX * rotY * normal;\n    vec2 v2 = 1.5 * v3.xy / abs(v3.z);\n    float dMb = mandelbrot(v2);\n        \n    vec3 material = 0.44 + 0.5 * cos(3.0 + dMb * 0.11 + vec3(0.0, 0.5, 1.0)); \n    vec3 lightDir = normalize(vec3(lightPos - pos));\n    vec3 reflectDir = normalize(reflect(lightDir, normal));\n    float shadow = getShadow(pos, lightDir, 0.001, 1.0, 8.0);\n        \n    float diffuse = clamp(dot(normal, lightDir), 0.0, 1.0) * shadow * 2.0;\n    float ambient = 0.6 + 0.6 * normal.y;\n\tfloat specular = pow(clamp(dot(reflectDir, rd), 0.0, 1.0), 16.0) * 2.2 * shadow;\n        \n\tcolor = lightCol * material * (diffuse + specular + ambient);\n    color = sqrt(color);\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdByzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[117, 117, 154, 154, 355], [357, 357, 383, 383, 433], [435, 497, 571, 571, 851], [853, 917, 943, 943, 1199], [1201, 1265, 1291, 1291, 1697], [1699, 1699, 1754, 1754, 3334]], "test": "valid"}
{"id": "WdfBD8", "name": "interaction with color ", "author": "elmtili", "description": "click randomly and enjoy it !!!", "tags": ["colors", "elmtili"], "likes": 0, "viewed": 46, "published": "Public", "date": "1588095932", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 20.0 * (fragCoord - iResolution.xy / 2.0) / min(iResolution.y, iResolution.x);\n    \n    float lar;\n    \n    for (int i=0; i <15; i++)\n    {\n     lar = length(vec2(uv.x, uv.y));\n        \n        uv.x = uv.x - cos(uv.y + sin(lar)) + cos(iTime / 9.0);\n        uv.y = uv.y - cos(uv.x + cos(lar)) + sin(iTime / 12.0);\n    }\n    \n\n    \n    \n    \n    // Normal Mode\n    fragColor = vec4(cos(lar * 2.0), cos(lar * 3.0), cos(lar * 1.0), 1.0);\n    \n    //Darck mode\n    //fragColor = vec4(cos(lar * 3.0), cos(lar * 1.0), cos(lar * 1.0), 1.0);\n    \n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdfBD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 662]], "test": "valid"}
{"id": "WdfBDr", "name": "Overlapping squares - need help", "author": "newtoglsl77", "description": "I'm hoping somebody can chime in with an easier way to accomplish this. I tiled my coordinate system, rotated each tile using a rotation matrix, and used the inverse of the rotation matrix to determine overlapping", "tags": ["beginner", "help", "request"], "likes": 1, "viewed": 124, "published": "Public", "date": "1587998192", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265358979323846\n#define aa 0.02\n\nvec2 rotate2D (vec2 st, float angle, float offset) \n{\n    st -= offset;\n    st = mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle)) * st;\n    st += offset;\n    return st;\n}\n\nvec2 inverseMatrix(vec2 st, float angle, float offset) \n{\n\t//st -= offset;\n\t//float s = (st.y + st.x*cos(angle)/sin(angle))/(sin(angle)+(cos(angle)*cos(angle)/sin(angle)));\n\t//float t = (s*cos(angle)-st.x)/sin(angle);\n    //float s = st.y*sin(angle) + st.x*cos(angle);\n \t//float t = st.y*cos(angle) - st.x*sin(angle);\n\t//st = vec2(s,t);\n\t//st += offset;\n    \n    // this line replaces the above 7 lines\n    st = rotate2D(st, angle, offset);\n\t\n\t// this is a mask so that just the overlapping values are selected\n    st *= step(0.0,st.x) * (1.0-step(1.0, st.x));\n    st *= step(0.0,st.y) * (1.0-step(1.0, st.y));\n    st *= smoothstep(0.0,aa,st.x) * (smoothstep(1.0,1.0-aa,st.x));\n    st *= smoothstep(0.0,aa,st.y) * (smoothstep(1.0,1.0-aa,st.y));\n\t\n\treturn st;\n}\n\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord ) \n{\n    //vec2 st = fragCoord/iResolution.xy;\n    //st.x *= iResolution.x/iResolution.y;\n\tvec2 st = fragCoord/iResolution.y;\n    \n\t//create a grid of tiles that is 5 tall\n    float numTiles = 5.0;\n    st *= numTiles;    \n    vec2 i_st = floor(st);\n    vec2 f_st = fract(st);\n    vec2 tile = f_st;\n    \n    // rotate each tile by the angle, which increases in each column\n    float angle = PI/10.0*(i_st.x+1.0)*sin(iTime);\n    float offset = 0.5;\n    st = rotate2D(tile,angle,offset);\n    \n    // only show the square, we want black space in between each square\n    st *= smoothstep(0.0,aa,st.x) * (smoothstep(1.0,1.0-aa,st.x));\n    st *= smoothstep(0.0,aa,st.y) * (smoothstep(1.0,1.0-aa,st.y));\n    \n    // this section finds the values of the neighbor's overlapping corner\n    angle = PI/10.0*(i_st.x)*sin(iTime);\n    vec2 neighborLeft = f_st + vec2(1.0,0.0);\n    neighborLeft = inverseMatrix(neighborLeft,angle,offset);\n    angle = PI/10.0*(i_st.x+1.0)*sin(iTime);\n    vec2 neighborBelow = f_st + vec2(0.0,1.0);\n    neighborBelow = inverseMatrix(neighborBelow,angle,offset);\n    angle = PI/10.0*(i_st.x+2.0)*sin(iTime);\n    vec2 neighborRight = f_st + vec2(-1.0,0.0);\n    neighborRight = inverseMatrix(neighborRight,angle,offset);\n    angle = PI/10.0*(i_st.x+1.0)*sin(iTime);\n    vec2 neighborAbove = f_st + vec2(0.0,-1.0);\n    neighborAbove = inverseMatrix(neighborAbove,angle,offset);\n    \n    // this is my hacky method of masking in the overlapped section\n    //st *= step(neighborLeft.x+neighborLeft.y, 0.01);\n    //st *= step(neighborBelow.x+neighborBelow.y, 0.01);\n    //st *= step(neighborRight.x+neighborRight.y, 0.01);\n    //st *= step(neighborAbove.x+neighborAbove.y, 0.01);\n    //st += neighborLeft;\n    //st += neighborBelow;\n    //st += neighborRight;\n    //st += neighborAbove;\n    st = max(st,neighborLeft);\n    st = max(st,neighborBelow);\n    st = max(st,neighborRight);\n    st = max(st,neighborAbove);\n    \n    // output\n    vec3 color = vec3(st,0.0);\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdfBDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 104, 104, 240], [242, 242, 299, 644, 1002], [1004, 1004, 1063, 1148, 3066]], "test": "valid"}
{"id": "wdfBWn", "name": "Rotating Rect", "author": "themasmo", "description": "Simple rotating rectangles.", "tags": ["rotate", "rectangle"], "likes": 8, "viewed": 125, "published": "Public", "date": "1588008621", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define N 32.\n \nvec2 rot(vec2 v, float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, -s, s, c)*v;\n}\n \nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n \nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0;\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n}\n \nvec4 rect(vec2 uv, vec2 pos, vec2 dim, vec3 col){\n\t\n\tif ((uv.x>=pos.x && uv.x<=pos.x+dim.x) && (uv.y>=pos.y && uv.y<=pos.y+dim.y)) {\n\t\treturn vec4(col,1.0);\n\t}\n\treturn vec4(0.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 p = gl_FragCoord.xy / iResolution.xy - 0.5;\n  p.x *= iResolution.x / iResolution.y;\n\n\tvec4 color=vec4(0.);\n\tfloat dx=1./N;\n\tfloat dy=1./N;\n\tfor(float t=0.;t<=1.;t+=(1./N))\n\t{\n\t\tfloat xi=N*t*dx;\n\t\tfloat yi=N*t*dy;\n\t\tfloat ddx=1.-xi*2.0;\n\t\tfloat ddy=1.-yi*2.0;\n\t\t//float an=noise(vec2(t*4.,iTime*4.));\n\t\t//vec2 r=rot(p,an);\n\t\tvec2 r=rot(p,1.4*sin(iTime+t*4.));\n\t\tcolor+=rect(r,vec2(-0.5+xi,-0.5+yi),vec2(ddx,ddy),vec3(t));\n\t}\n\t\n\t\n\tcolor=sqrt(color*0.2);\n\t\n\tfragColor = vec4( vec3( color ), 1.0 );\n \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdfBWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[16, 16, 47, 47, 133], [136, 136, 159, 159, 198], [201, 201, 227, 227, 445], [448, 448, 497, 497, 627], [629, 629, 685, 685, 1191]], "test": "valid"}
{"id": "wdfBz4", "name": "Alone", "author": "livvy", "description": "Song: Leafar Legov - Alone [Giegling]\n\nJust trying my hand at some raymarched geometry using distance functions and some phong shading. I thought I'd add some music to tie it all into some kind of theme. =)\n\nThanks to:\n@mla for the tips\n@iq for resources", "tags": ["phong", "raymarched", "music"], "likes": 2, "viewed": 141, "published": "Public", "date": "1587759231", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n*/\n\n#define MAX_STEPS 300\n#define MAX_DEPTH 50.0\n#define EPSILON 0.001\n\nmat2 rot(float a)\n{\n  return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\n// iq's anti-aliased checker pattern\nfloat checkers(vec2 p)\n{\n    vec2 w = fwidth(p) + 0.001;\n    vec2 i = 0.9*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    return 1.2 - 0.5*i.x*i.y;\n}\n\nfloat opSU(float d1, float d2, float k) {\n  float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0);\n  return mix( d2, d1, h) - k*h*(1.0-h);\n}\n\nfloat line( vec3 p, vec3 a, vec3 b )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h );\n}\n\nfloat pln(vec3 p, vec3 n, float d)\n{\n  return dot(p, n) - d;\n}\n\nfloat box(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sph(vec3 p, float s)\n{\n  return length(p) - s;\n}\n\nfloat pyramid(vec3 p) {\n   float s = 1.2;\n   p.xz = abs(p.xz);\n   float l1 = line(p,vec3(s, -s, s),vec3(0, -s, s));\n   float l2 = line(p,vec3(s, -s, s), vec3(s, -s, 0));\n   float l3 = line(p,vec3(0, s, 0), vec3(s, -s, s));\n   return min(min(l1,l2),l3)-0.025;\n}\n\n\nfloat sdf(vec3 p)\n{\n  p.xz *= rot(iTime/2.0)*rot(0.3);\n\n  float t = iTime/2.0;\n  float c = cos(t)/3.;\n  float s = sin(t)/3.;\n \n  float p1 = pln(p, vec3(0.0, 1.0, 0.0), -2.0);\n  float py1 = abs(pyramid(p));\n  \n  vec3 ps = p-vec3(0,-0.43,0);\n  float r = 0.5;\n  float us = 0.4;\n  float s1 = sph(ps-vec3(c,  0., s ), r);\n  float s2 = sph(ps-vec3(c,  s , 0.), r);\n  float s3 = sph(ps+vec3(0., c , s ), r);\n  float fft = texture(iChannel0, vec2(0.35, 0.)).r*.1;\n\n  float ss = opSU(opSU(s1, s2, us), s3, us)-fft;\n  return min(min(ss, py1), p1);\n}\n\nvec3 getNormal(vec3 p) {\n   const float h = 0.00001;\n   const vec2 k = vec2(1,-1);\n   return normalize( k.xyy*sdf( p + k.xyy*h ) +\n                     k.yyx*sdf( p + k.yyx*h ) +\n                     k.yxy*sdf( p + k.yxy*h ) +\n                     k.xxx*sdf( p + k.xxx*h) );\n}\n\nvec3 phongLightContrib(vec3 kd, vec3 ks, float alpha, vec3 p, vec3 eye, vec3 lightPos, vec3 lightInt)\n{\n  vec3 N = getNormal(p);\n  vec3 L = normalize(lightPos - p);\n  vec3 V = normalize(eye - p);\n  vec3 R = normalize(reflect(-L, N));\n\n  float dotLN = dot(L, N);\n  float dotRV = dot(R, V);\n\n  if (dotLN < 0.0) {return vec3(0.0);}\n  if (dotRV < 0.0) {return lightInt * (kd * dotLN);}\n  return lightInt * (kd * dotLN + ks * pow(dotRV, alpha));\n}\n\nvec3 phong(vec3 ka, vec3 kd, vec3 ks, float alpha, vec3 p, vec3 eye)\n{\n  const vec3 ambientLux = vec3(0.3);\n  vec3 colour = ambientLux * ka;\n  \n  vec3 light1Pos = vec3(0.0, 0.4, -2.0);\n  vec3 light1Int = vec3(0.7);\n  \n  vec3 light2Pos = vec3(0.0, 0.5, -1.0);\n  vec3 light2Int = vec3(0.3);\n  \n  colour += phongLightContrib(kd, ks, alpha, p, eye, light1Pos, light1Int);\n  //colour += phongLightContrib(kd, ks, alpha, p, eye, light2Pos, light2Int);\n  return colour;\n}\n\nvec3 calcSceneColour(vec3 p, float t1, vec3 ro)\n{\n  vec3 lum = phong(\n    vec3(  0.7,  0.0, 0.0), // ambient\n    vec3(  1.0,  0.0, 0.0), // diffuse\n    vec3(  1.0, 1.0, 1.0), // spectral\n    3000.0,                 // shininess\n    p,\n    ro\n  );\n  return lum;\n}\n\nvec3 march(vec3 ro, vec3 rd)\n{\n  vec3  col   = vec3(0);\n  float depth = 10.0/float(MAX_STEPS);\n  float dist;\n  vec3 pf;\n  vec3 rf;\n  vec3 pp;\n  float tf;\n  for (int i=0; i<MAX_STEPS; i++)\n  {\n      vec3 p = ro + rd * depth;\n      p.y -= 1.3;\n      p.z -= 0.5;\n      dist = sdf(p.xyz);\n      if (depth > MAX_DEPTH) {\n          break;\n      } else if (dist < EPSILON)\n      {\n        pf = p;\n        tf = depth;\n        rf = ro;\n        if (pf.y > -1.4) {\n           col = calcSceneColour(p, tf, rf);\n        }\n        break;\n      }\n      depth += dist*0.85;\n  }\n  if (pf.y < -1.4) {\n          pf.xz *= rot(iTime/2.0) * rot(0.3);\n\n    float r = texture(iChannel0, vec2(0.35, 0.)).r*.7;\n    col = vec3(checkers(pf.xz)*mix(vec3(0.24,0.03,0.15), vec3(0.3,0.03,0.4), r));\n    col*=30.0/(tf*tf*tf);\n  } else {\n   \n  }\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  vec3 ro = vec3(0.0,1.0,-4.0);\n  vec3 rd = vec3(uv, 1.0);\n  vec3 c = march(ro, rd);\n  fragColor = vec4(c, 1.0);\n  fragColor = vec4(pow(c,vec3(0.4545)), 1.0);\n}", "image_inputs": [{"id": "MljGDW", "previewfilepath": "https://soundcloud.com/billybelgium/leafar-legov-alone-unreleased", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/billybelgium/leafar-legov-alone-unreleased", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdfBz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 76, 95, 95, 145], [147, 184, 208, 208, 354], [356, 356, 397, 397, 490], [492, 492, 530, 530, 647], [649, 649, 685, 685, 711], [713, 713, 740, 740, 827], [829, 829, 857, 857, 883], [885, 885, 908, 908, 1145], [1148, 1148, 1167, 1167, 1687], [1689, 1689, 1713, 1713, 1965], [1967, 1967, 2070, 2070, 2409], [2411, 2411, 2481, 2481, 2875], [2877, 2877, 2926, 2926, 3139], [3141, 3141, 3171, 3171, 3968], [3970, 3970, 4027, 4027, 4325]], "test": "error"}
{"id": "WdfBz8", "name": "Procedural landmass", "author": "Krafpy", "description": "Procedural landmass generation using perlin noise and voronoi.", "tags": ["procedural", "noise", "terrain", "water"], "likes": 8, "viewed": 124, "published": "Public", "date": "1587653475", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265\n\n// decrease octaves for better performances\n#define OCTAVES 10\n\n// rotation matrix\nmat2 rot(float a){\n\treturn mat2(cos(a), -sin(a),\n               sin(a), cos(a));\n}\n\n\n// perlin noise functions\n// https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nfloat rand(vec2 c){\n\treturn fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise(vec2 p, float freq ){\n\tfloat unit = 1./freq;\n\tvec2 ij = floor(p/unit);\n\tvec2 xy = mod(p,unit)/unit;\n\txy = 3.*xy*xy-2.*xy*xy*xy;\n\tfloat a = rand((ij+vec2(0.,0.)));\n\tfloat b = rand((ij+vec2(1.,0.)));\n\tfloat c = rand((ij+vec2(0.,1.)));\n\tfloat d = rand((ij+vec2(1.,1.)));\n\tfloat x1 = mix(a, b, xy.x);\n\tfloat x2 = mix(c, d, xy.x);\n\treturn mix(x1, x2, xy.y);\n}\n\nfloat pnoise(vec2 p, int res){\n\tfloat persistance = .4;\n\tfloat n = 0.;\n\tfloat normK = 0.;\n\tfloat f = 4.;\n\tfloat amp = 1.;\n\tfor (int i = 0; i<res; i++){\n\t\tn+=amp*noise(p, f);\n\t\tf*=2.;\n\t\tnormK+=amp;\n\t\tamp*=persistance;\n\t}\n\tfloat nf = n/normK;\n\treturn nf*nf*nf*nf;\n}\n\n\n// height function for terrain generation\nfloat f(vec2 p){\n    return clamp(pnoise(p*0.5, OCTAVES)*0.7, 0.01, 100.); // clamp see level at 0.01\n}\n\nfloat f(float x, float y){ // overloaded method of previous function\n\treturn f(vec2(x, y));\n}\n\n// ray marching for terrain detection\n// from : https://www.iquilezles.org/www/articles/terrainmarching/terrainmarching.htm\nbool castRay(in vec3 ro, in vec3 rd, out float resT){\n    float dt0 = 0.005;\n    float mint = 0.25;\n    float maxt = 4.;\n    \n    float lh = 0.;\n    float ly = 0.;\n    \n    vec3 p = ro;\n    \n    float dt = dt0;\n    for(float t = mint; t < maxt; t += dt){\n    \tp = ro + rd * t;\n        float h = f(p.xz);\n        \n        if(p.y < h){\n            resT = t - dt + dt*(lh-ly)/(p.y-ly-h+lh);\n            return true;\n        }\n        lh = h;\n        ly = p.y;\n        \n        dt = dt0 + 0.005*t;\n    }\n    return false;\n}\n\n// get the normal vector for a given point on the terrain\nvec3 getNormal( in vec3 p )\n{\n    float eps = 0.001;\n    return normalize( vec3( f(p.x-eps,p.z) - f(p.x+eps,p.z),\n                            2.0f*eps,\n                            f(p.x,p.z-eps) - f(p.x,p.z+eps) ) );\n}\n\n// give a random 2d vector\nvec2 rand2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// smooth animated voronoi for water rendering\n// adapted from : https://iquilezles.org/www/articles/smoothvoronoi/smoothvoronoi.htm\nfloat vor(in vec2 uv){\n    vec2 p = floor(uv);\n    vec2 f = fract(uv);\n\n    float res = 8.0;\n    for( int j=-1; j<=1; j++ )\n        for( int i=-1; i<=1; i++ )\n        {\n            vec2 b = vec2( i, j );\n            vec2 pt = rand2( p + b );\n            //animate the point\n            pt = 0.5+0.5*sin(pt*6. + iTime*5.);\n            vec2  r = vec2( b ) - f + pt;\n            float d = dot( r, r );\n\n            res += 1.0/pow( d, 8.0 );\n        }\n    return pow( 1.0/res, 1.0/16.0 );\n}\n\nfloat fw(float x, float y){\n    return vor(vec2(x, y)*75.)*0.0005;// only a small variation in height\n}\n\n// get the normal vector on water based on voronoi height map\nvec3 getNormalWater( in vec3 p )\n{\n    float eps = 0.001;\n    return normalize( vec3( fw(p.x-eps,p.z) - fw(p.x+eps,p.z),\n                            2.0f*eps,\n                            fw(p.x,p.z-eps) - fw(p.x,p.z+eps) ) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // pixel color\n    vec3 col = vec3(0.);\n    \n    // camera movements\n    float time = iTime * 0.01;\n    float c2 = cos(time);\n    c2 *= c2;\n    float s2 = sqrt(2.);\n    float cx = 6.*s2*sin(time)/(1.+c2);\n    float cz = 6.*s2*sin(time)*cos(time)/(1.+c2);\n\t\n    // ray\n    vec3 ro = vec3(cx, 0., cz);\n    float h = f(ro.xz);\n    ro.y = 0.5 + h;\n    vec3 rd = normalize(vec3(uv, 1.));\n    \n    // rotate the ray\n    rd.yz *= rot(0.35);\n    rd.xz *= rot(2.*sin(iTime*0.1));\n    \n    const vec3 sky = vec3(0.65, 0.6, 0.55); // sky color\n    const vec3 sun = normalize(vec3(1., 1., 0.)); // sun direction\n    \n    float t = 10.;\n    float t1; // keep track of the first distance, for the fog\n    if(castRay(ro, rd, t)){\n        t1 = t;\n        vec3 p = ro + rd * t;\n        \n        bool calcColor = true;\n        bool hitWater = false;\n        \n        vec3 nml; // normal vector\n        \n        if(p.y-0.001 <= 0.01){ // if the ray hits the water level\n            hitWater = true;\n            \n            nml = getNormalWater(p);\n            \n            rd = reflect(rd, nml); // reflect the ray\n            \n            if(castRay(p, rd, t)){ // if the ray hits the terrain again\n                p = p + rd * t;\n                hitWater = false;\n            } else {\n                calcColor = false;\n            }\n        }\n        \n        if(calcColor){ // calculate terrain coloring if the ray ends on it\n            vec3 tex1 = texture(iChannel0, p.xz*2.).rgb;\n            vec3 tex2 = texture(iChannel1, p.xz).rgb;\n\n            if(!hitWater) nml = getNormal(p);\n\n            float ud = clamp(dot(vec3(0., 1., 0.), nml), 0., 1.);\n            ud = pow(ud, 12.);\n\n            vec3 grass = vec3(0.5, 1., 0.5);\n            vec3 rock = vec3(0.6, 0.55, 0.5);\n            vec3 sand = vec3(1.2, 1.2, 0.8);\n\n            col = grass * (tex2 + tex1) / 1.5 * ud;\n            col += rock * (1.-ud) * tex1.rrr;\n\n            col = mix(col, vec3(1.), smoothstep(0.1, 0.15, p.y)*ud);\n            \n            float v = texture(iChannel0, p.xz*20.).r;\n            col = mix(sand * v, col, smoothstep(0.01, 0.0155, p.y));\n\n            float nd = clamp(dot(nml, sun), 0., 1.);\n            col *= (nd*(2.-ud));\n        } else {\n            float nd = clamp(dot(nml, sun), 0., 1.);\n            col = sky * nd;\n        }\n        \n        if(hitWater) col = mix(col, vec3(0., 0.35, 0.7), 0.1); // add blue color to water\n        \n        col = clamp(col, 0., 1.);\n        col = mix(col, sky, smoothstep(0.5, 4.5, t1)); // fog based on ray hit distance\n    } else {\n    \tcol = sky;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdfBz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[87, 106, 124, 124, 188], [191, 286, 305, 305, 373], [375, 375, 408, 408, 741], [743, 743, 773, 773, 1006], [1009, 1051, 1067, 1067, 1154], [1156, 1156, 1182, 1224, 1249], [1251, 1375, 1428, 1428, 1894], [1896, 1954, 1983, 1983, 2172], [2174, 2201, 2223, 2223, 2316], [2318, 2451, 2473, 2473, 2937], [2939, 2939, 2966, 2966, 3042], [3044, 3106, 3140, 3140, 3333], [3336, 3336, 3393, 3393, 6124]], "test": "error"}
{"id": "WdfBzH", "name": "bubler with backdrop", "author": "run", "description": "bubler with backdrop", "tags": ["bubler", "backdrop"], "likes": 2, "viewed": 210, "published": "Public API", "date": "1587657686", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//-----------------------------------------------------------------------------\n// Simple test/port of Mercury's SDF GLSL library: http://mercury.sexy/hg_sdf/\n// by Tom '2015\n// Disclaimer:\n//   The library is done by Mercury team for OpenGL 4+ (look below),\n//   not me, and this is just an unofficial port.\n//-----------------------------------------------------------------------------\n\n////////////////////////////////////////////////////////////////\n//\n//                           HG_SDF\n//\n//     GLSL LIBRARY FOR BUILDING SIGNED DISTANCE BOUNDS\n//\n//     version 2015-12-15 (initial release)\n//\n//     Check http://mercury.sexy/hg_sdf for updates\n//     and usage examples. Send feedback to spheretracing@mercury.sexy.\n//\n//     Brought to you by MERCURY http://mercury.sexy\n//\n//\n//\n// Released as Creative Commons Attribution-NonCommercial (CC BY-NC)\n//\n////////////////////////////////////////////////////////////////\n\n\n////////////////////////////////////////////////////////////////\n//\n//             HELPER FUNCTIONS/MACROS\n//\n////////////////////////////////////////////////////////////////\n\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (1.618033988749895)\n     // PHI (sqrt(5)*0.5 + 0.5)\n\n// Clamp to [0,1] - this operation is free under certain circumstances.\n// For further information see\n// http://www.humus.name/Articles/Persson_LowLevelThinking.pdf and\n// http://www.humus.name/Articles/Persson_LowlevelShaderOptimization.pdf\n#define saturate(x) clamp(x, 0., 1.)\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n\treturn (x<0.)?-1.:1.;\n}\n\nfloat square (float x) {\n\treturn x*x;\n}\n\nvec2 square (vec2 x) {\n\treturn x*x;\n}\n\nvec3 square (vec3 x) {\n\treturn x*x;\n}\n\nfloat lengthSqr(vec3 x) {\n\treturn dot(x, x);\n}\n\n\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n\nfloat vmin(vec2 v) {\n\treturn min(v.x, v.y);\n}\n\nfloat vmin(vec3 v) {\n\treturn min(min(v.x, v.y), v.z);\n}\n\nfloat vmin(vec4 v) {\n\treturn min(min(v.x, v.y), min(v.z, v.w));\n}\n\n\n\n\n////////////////////////////////////////////////////////////////\n//\n//             PRIMITIVE DISTANCE FUNCTIONS\n//\n////////////////////////////////////////////////////////////////\n//\n// Conventions:\n//\n// Everything that is a distance function is called fSomething.\n// The first argument is always a point in 2 or 3-space called <p>.\n// Unless otherwise noted, (if the object has an intrinsic \"up\"\n// side or direction) the y axis is \"up\" and the object is\n// centered at the origin.\n//\n////////////////////////////////////////////////////////////////\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\n// Cheap Box: distance to corners is overestimated\nfloat fBoxCheap(vec3 p, vec3 b) { //cheap box\n\treturn vmax(abs(p) - b);\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Same as above, but in two dimensions (an endless box)\nfloat fBox2Cheap(vec2 p, vec2 b) {\n\treturn vmax(abs(p)-b);\n}\n\nfloat fBox2(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n\n\n// Endless \"corner\"\nfloat fCorner (vec2 p) {\n\treturn length(max(p, vec2(0))) + vmax(min(p, vec2(0)));\n}\n\n// Blobby ball object. You've probably seen it somewhere. This is not a correct distance bound, beware.\nfloat fBlob(vec3 p) {\n\tp = abs(p);\n\tif (p.x < max(p.y, p.z)) p = p.yzx;\n\tif (p.x < max(p.y, p.z)) p = p.yzx;\n\tfloat b = max(max(max(\n\t\tdot(p, normalize(vec3(1, 1, 1))),\n\t\tdot(p.xz, normalize(vec2(PHI+1., 1)))),\n\t\tdot(p.yx, normalize(vec2(1, PHI)))),\n\t\tdot(p.xz, normalize(vec2(1, PHI))));\n\tfloat l = length(p);\n\treturn l - 1.5 - 0.2 * (1.5 / 2.)* cos(min(sqrt(1.01 - b / l)*(PI / 0.25), PI));\n}\n\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\n// Capsule: A Cylinder with round caps on both sides\nfloat fCapsule(vec3 p, float r, float c) {\n\treturn mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n}\n\n// Distance to line segment between <a> and <b>, used for fCapsule() version 2below\nfloat fLineSegment(vec3 p, vec3 a, vec3 b) {\n\tvec3 ab = b - a;\n\tfloat t = saturate(dot(p - a, ab) / dot(ab, ab));\n\treturn length((ab*t + a) - p);\n}\n\n// Capsule version 2: between two end points <a> and <b> with radius r \nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\treturn fLineSegment(p, a, b) - r;\n}\n\n// Torus in the XZ-plane\nfloat fTorus(vec3 p, float smallRadius, float largeRadius) {\n\treturn length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;\n}\n\n// A circle line. Can also be used to make a torus by subtracting the smaller radius of the torus.\nfloat fCircle(vec3 p, float r) {\n\tfloat l = length(p.xz) - r;\n\treturn length(vec2(p.y, l));\n}\n\n// A circular disc with no thickness (i.e. a cylinder with no height).\n// Subtract some value to make a flat disc with rounded edge.\nfloat fDisc(vec3 p, float r) {\n float l = length(p.xz) - r;\n\treturn l < 0. ? abs(p.y) : length(vec2(p.y, l));\n}\n\n// Hexagonal prism, circumcircle variant\nfloat fHexagonCircumcircle(vec3 p, vec2 h) {\n\tvec3 q = abs(p);\n\treturn max(q.y - h.y, max(q.x*sqrt(3.)*0.5 + q.z*0.5, q.z) - h.x);\n\t//this is mathematically equivalent to this line, but less efficient:\n\t//return max(q.y - h.y, max(dot(vec2(cos(PI/3), sin(PI/3)), q.zx), q.z) - h.x);\n}\n\n// Hexagonal prism, incircle variant\nfloat fHexagonIncircle(vec3 p, vec2 h) {\n\treturn fHexagonCircumcircle(p, vec2(h.x*sqrt(3.)*0.5, h.y));\n}\n\n// Cone with correct distances to tip and base circle. Y is up, 0 is in the middle of the base.\nfloat fCone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tvec2 tip = q - vec2(0, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\t\n\t// distance to tip\n\tif ((q.y > height) && (projected < 0.)) {\n\t\td = max(d, length(tip));\n\t}\n\t\n\t// distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 0)));\n\t}\n\treturn d;\n}\n\n//\n// \"Generalized Distance Functions\" by Akleman and Chen.\n// see the Paper at https://www.viz.tamu.edu/faculty/ergun/research/implicitmodeling/papers/sm99.pdf\n//\n// This set of constants is used to construct a large variety of geometric primitives.\n// Indices are shifted by 1 compared to the paper because we start counting at Zero.\n// Some of those are slow whenever a driver decides to not unroll the loop,\n// which seems to happen for fIcosahedron und fTruncatedIcosahedron on nvidia 350.12 at least.\n// Specialized implementations can well be faster in all cases.\n//\n\n// Macro based version for GLSL 1.2 / ES 2.0 by Tom\n\n#define GDFVector0 vec3(1, 0, 0)\n#define GDFVector1 vec3(0, 1, 0)\n#define GDFVector2 vec3(0, 0, 1)\n\n#define GDFVector3 normalize(vec3(1, 1, 1 ))\n#define GDFVector4 normalize(vec3(-1, 1, 1))\n#define GDFVector5 normalize(vec3(1, -1, 1))\n#define GDFVector6 normalize(vec3(1, 1, -1))\n\n#define GDFVector7 normalize(vec3(0, 1, PHI+1.))\n#define GDFVector8 normalize(vec3(0, -1, PHI+1.))\n#define GDFVector9 normalize(vec3(PHI+1., 0, 1))\n#define GDFVector10 normalize(vec3(-PHI-1., 0, 1))\n#define GDFVector11 normalize(vec3(1, PHI+1., 0))\n#define GDFVector12 normalize(vec3(-1, PHI+1., 0))\n\n#define GDFVector13 normalize(vec3(0, PHI, 1))\n#define GDFVector14 normalize(vec3(0, -PHI, 1))\n#define GDFVector15 normalize(vec3(1, 0, PHI))\n#define GDFVector16 normalize(vec3(-1, 0, PHI))\n#define GDFVector17 normalize(vec3(PHI, 1, 0))\n#define GDFVector18 normalize(vec3(-PHI, 1, 0))\n\n#define fGDFBegin float d = 0.;\n\n// Version with variable exponent.\n// This is slow and does not produce correct distances, but allows for bulging of objects.\n#define fGDFExp(v) d += pow(abs(dot(p, v)), e);\n\n// Version with without exponent, creates objects with sharp edges and flat faces\n#define fGDF(v) d = max(d, abs(dot(p, v)));\n\n#define fGDFExpEnd return pow(d, 1./e) - r;\n#define fGDFEnd return d - r;\n\n// Primitives follow:\n\nfloat fOctahedron(vec3 p, float r, float e) {\n\tfGDFBegin\n    fGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n    fGDFExpEnd\n}\n\nfloat fDodecahedron(vec3 p, float r, float e) {\n\tfGDFBegin\n    fGDFExp(GDFVector13) fGDFExp(GDFVector14) fGDFExp(GDFVector15) fGDFExp(GDFVector16)\n    fGDFExp(GDFVector17) fGDFExp(GDFVector18)\n    fGDFExpEnd\n}\n\nfloat fIcosahedron(vec3 p, float r, float e) {\n\tfGDFBegin\n    fGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n    fGDFExp(GDFVector7) fGDFExp(GDFVector8) fGDFExp(GDFVector9) fGDFExp(GDFVector10)\n    fGDFExp(GDFVector11) fGDFExp(GDFVector12)\n    fGDFExpEnd\n}\n\nfloat fTruncatedOctahedron(vec3 p, float r, float e) {\n\tfGDFBegin\n    fGDFExp(GDFVector0) fGDFExp(GDFVector1) fGDFExp(GDFVector2) fGDFExp(GDFVector3)\n    fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n    fGDFExpEnd\n}\n\nfloat fTruncatedIcosahedron(vec3 p, float r, float e) {\n\tfGDFBegin\n    fGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n    fGDFExp(GDFVector7) fGDFExp(GDFVector8) fGDFExp(GDFVector9) fGDFExp(GDFVector10)\n    fGDFExp(GDFVector11) fGDFExp(GDFVector12) fGDFExp(GDFVector13) fGDFExp(GDFVector14)\n    fGDFExp(GDFVector15) fGDFExp(GDFVector16) fGDFExp(GDFVector17) fGDFExp(GDFVector18)\n    fGDFExpEnd\n}\n\nfloat fOctahedron(vec3 p, float r) {\n\tfGDFBegin\n    fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDFEnd\n}\n\nfloat fDodecahedron(vec3 p, float r) {\n    fGDFBegin\n    fGDF(GDFVector13) fGDF(GDFVector14) fGDF(GDFVector15) fGDF(GDFVector16)\n    fGDF(GDFVector17) fGDF(GDFVector18)\n    fGDFEnd\n}\n\nfloat fIcosahedron(vec3 p, float r) {\n\tfGDFBegin\n    fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n    fGDF(GDFVector11) fGDF(GDFVector12)\n    fGDFEnd\n}\n\nfloat fTruncatedOctahedron(vec3 p, float r) {\n\tfGDFBegin\n    fGDF(GDFVector0) fGDF(GDFVector1) fGDF(GDFVector2) fGDF(GDFVector3)\n    fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDFEnd\n}\n\nfloat fTruncatedIcosahedron(vec3 p, float r) {\n\tfGDFBegin\n    fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n    fGDF(GDFVector11) fGDF(GDFVector12) fGDF(GDFVector13) fGDF(GDFVector14)\n    fGDF(GDFVector15) fGDF(GDFVector16) fGDF(GDFVector17) fGDF(GDFVector18)\n    fGDFEnd\n}\n\n\n////////////////////////////////////////////////////////////////\n//\n//                DOMAIN MANIPULATION OPERATORS\n//\n////////////////////////////////////////////////////////////////\n//\n// Conventions:\n//\n// Everything that modifies the domain is named pSomething.\n//\n// Many operate only on a subset of the three dimensions. For those,\n// you must choose the dimensions that you want manipulated\n// by supplying e.g. <p.x> or <p.zx>\n//\n// <inout p> is always the first argument and modified in place.\n//\n// Many of the operators partition space into cells. An identifier\n// or cell index is returned, if possible. This return value is\n// intended to be optionally used e.g. as a random seed to change\n// parameters of the distance functions inside the cells.\n//\n// Unless stated otherwise, for cell index 0, <p> is unchanged and cells\n// are centered on the origin so objects don't have to be moved to fit.\n//\n//\n////////////////////////////////////////////////////////////////\n\n\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Shortcut for 45-degrees rotation\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n// Same, but mirror every second cell so they match at the boundaries\nfloat pModMirror1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize,size) - halfsize;\n\tp *= mod(c, 2.0)*2. - 1.;\n\treturn c;\n}\n\n// Repeat the domain only in positive direction. Everything in the negative half-space is unchanged.\nfloat pModSingle1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tif (p >= 0.)\n\t\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n// Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n\n// Same, but mirror every second cell so all boundaries match\nvec2 pModMirror2(inout vec2 p, vec2 size) {\n\tvec2 halfsize = size*0.5;\n\tvec2 c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\tp *= mod(c,vec2(2))*2. - vec2(1);\n\treturn c;\n}\n\n// Same, but mirror every second cell at the diagonal as well\nvec2 pModGrid2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\tp *= mod(c,vec2(2))*2. - vec2(1);\n\tp -= size/2.;\n\tif (p.x > p.y) p.xy = p.yx;\n\treturn floor(c/2.);\n}\n\n// Repeat in three dimensions\nvec3 pMod3(inout vec3 p, vec3 size) {\n\tvec3 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\treturn c;\n}\n\n// Mirror at an axis-aligned plane which is at a specified distance <dist> from the origin.\nfloat pMirror (inout float p, float dist) {\n\tfloat s = sign(p);\n\tp = abs(p)-dist;\n\treturn s;\n}\n\n// Mirror in both dimensions and at the diagonal, yielding one eighth of the space.\n// translate by dist before mirroring.\nvec2 pMirrorOctant (inout vec2 p, vec2 dist) {\n\tvec2 s = sign(p);\n\tpMirror(p.x, dist.x);\n\tpMirror(p.y, dist.y);\n\tif (p.y > p.x)\n\t\tp.xy = p.yx;\n\treturn s;\n}\n\n// Reflect space at a plane\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) {\n\tfloat t = dot(p, planeNormal)+offset;\n\tif (t < 0.) {\n\t\tp = p - (2.*t)*planeNormal;\n\t}\n\treturn sign(t);\n}\n\n\n////////////////////////////////////////////////////////////////\n//\n//             OBJECT COMBINATION OPERATORS\n//\n////////////////////////////////////////////////////////////////\n//\n// We usually need the following boolean operators to combine two objects:\n// Union: OR(a,b)\n// Intersection: AND(a,b)\n// Difference: AND(a,!b)\n// (a and b being the distances to the objects).\n//\n// The trivial implementations are min(a,b) for union, max(a,b) for intersection\n// and max(a,-b) for difference. To combine objects in more interesting ways to\n// produce rounded edges, chamfers, stairs, etc. instead of plain sharp edges we\n// can use combination operators. It is common to use some kind of \"smooth minimum\"\n// instead of min(), but we don't like that because it does not preserve Lipschitz\n// continuity in many cases.\n//\n// Naming convention: since they return a distance, they are called fOpSomething.\n// The different flavours usually implement all the boolean operators above\n// and are called fOpUnionRound, fOpIntersectionRound, etc.\n//\n// The basic idea: Assume the object surfaces intersect at a right angle. The two\n// distances <a> and <b> constitute a new local two-dimensional coordinate system\n// with the actual intersection as the origin. In this coordinate system, we can\n// evaluate any 2D distance function we want in order to shape the edge.\n//\n// The operators below are just those that we found useful or interesting and should\n// be seen as examples. There are infinitely more possible operators.\n//\n// They are designed to actually produce correct distances or distance bounds, unlike\n// popular \"smooth minimum\" operators, on the condition that the gradients of the two\n// SDFs are at right angles. When they are off by more than 30 degrees or so, the\n// Lipschitz condition will no longer hold (i.e. you might get artifacts). The worst\n// case is parallel surfaces that are close to each other.\n//\n// Most have a float argument <r> to specify the radius of the feature they represent.\n// This should be much smaller than the object size.\n//\n// Some of them have checks like \"if ((-a < r) && (-b < r))\" that restrict\n// their influence (and computation cost) to a certain area. You might\n// want to lift that restriction or enforce it. We have left it as comments\n// in some cases.\n//\n// usage example:\n//\n// float fTwoBoxes(vec3 p) {\n//   float box0 = fBox(p, vec3(1));\n//   float box1 = fBox(p-vec3(1), vec3(1));\n//   return fOpUnionChamfer(box0, box1, 0.2);\n// }\n//\n////////////////////////////////////////////////////////////////\n\n\n// The \"Chamfer\" flavour makes a 45-degree chamfered edge (the diagonal of a square of size <r>):\nfloat fOpUnionChamfer(float a, float b, float r) {\n\tfloat m = min(a, b);\n\t//if ((a < r) && (b < r)) {\n\t\treturn min(m, (a - r + b)*sqrt(0.5));\n\t//} else {\n\t\treturn m;\n\t//}\n}\n\n// Intersection has to deal with what is normally the inside of the resulting object\n// when using union, which we normally don't care about too much. Thus, intersection\n// implementations sometimes differ from union implementations.\nfloat fOpIntersectionChamfer(float a, float b, float r) {\n\tfloat m = max(a, b);\n\tif (r <= 0.) return m;\n\tif (((-a < r) && (-b < r)) || (m < 0.)) {\n\t\treturn max(m, (a + r + b)*sqrt(0.5));\n\t} else {\n\t\treturn m;\n\t}\n}\n\n// Difference can be built from Intersection or Union:\nfloat fOpDifferenceChamfer (float a, float b, float r) {\n\treturn fOpIntersectionChamfer(a, -b, r);\n}\n\n// The \"Round\" variant uses a quarter-circle to join the two objects smoothly:\nfloat fOpUnionRound(float a, float b, float r) {\n\tfloat m = min(a, b);\n\tif ((a < r) && (b < r) ) {\n\t\treturn min(m, r - sqrt((r-a)*(r-a) + (r-b)*(r-b)));\n\t} else {\n\t return m;\n\t}\n}\n\nfloat fOpIntersectionRound(float a, float b, float r) {\n\tfloat m = max(a, b);\n\tif ((-a < r) && (-b < r)) {\n\t\treturn max(m, -(r - sqrt((r+a)*(r+a) + (r+b)*(r+b))));\n\t} else {\n\t\treturn m;\n\t}\n}\n\nfloat fOpDifferenceRound (float a, float b, float r) {\n\treturn fOpIntersectionRound(a, -b, r);\n}\n\n\n// The \"Columns\" flavour makes n-1 circular columns at a 45 degree angle:\nfloat fOpUnionColumns(float a, float b, float r, float n) {\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n\t\tpR45(p);\n\t\tp.x -= sqrt(2.)/2.*r;\n\t\tp.x += columnradius*sqrt(2.);\n\t\tif (mod(n,2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\t// At this point, we have turned 45 degrees and moved at a point on the\n\t\t// diagonal that we want to place the columns on.\n\t\t// Now, repeat the domain along this direction and place a circle.\n\t\tpMod1(p.y, columnradius*2.);\n\t\tfloat result = length(p) - columnradius;\n\t\tresult = min(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn min(result, b);\n\t} else {\n\t\treturn min(a, b);\n\t}\n}\n\nfloat fOpDifferenceColumns(float a, float b, float r, float n) {\n\ta = -a;\n\tfloat m = min(a, b);\n\t//avoid the expensive computation where not needed (produces discontinuity though)\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.)/n/2.0;\n\t\tcolumnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n\n\t\tpR45(p);\n\t\tp.y += columnradius;\n\t\tp.x -= sqrt(2.)/2.*r;\n\t\tp.x += -columnradius*sqrt(2.)/2.;\n\n\t\tif (mod(n,2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\tpMod1(p.y,columnradius*2.);\n\n\t\tfloat result = -length(p) + columnradius;\n\t\tresult = max(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn -min(result, b);\n\t} else {\n\t\treturn -m;\n\t}\n}\n\nfloat fOpIntersectionColumns(float a, float b, float r, float n) {\n\treturn fOpDifferenceColumns(a,-b,r, n);\n}\n\n// The \"Stairs\" flavour produces n-1 steps of a staircase:\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat d = min(a, b);\n\tvec2 p = vec2(a, b);\n\tpR45(p);\n\tp = p.yx - vec2((r-r/n)*0.5*sqrt(2.));\n\tp.x += 0.5*sqrt(2.)*r/n;\n\tfloat x = r*sqrt(2.)/n;\n\tpMod1(p.x, x);\n\td = min(d, p.y);\n\tpR45(p);\n\treturn min(d, vmax(p -vec2(0.5*r/n)));\n}\n\n// We can just call Union since stairs are symmetric.\nfloat fOpIntersectionStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, -b, r, n);\n}\n\nfloat fOpDifferenceStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, b, r, n);\n}\n\n// This produces a cylindical pipe that runs along the intersection.\n// No objects remain, only the pipe. This is not a boolean operator.\nfloat fOpPipe(float a, float b, float r) {\n\treturn length(vec2(a, b)) - r;\n}\n\n////////////////////////////////////////////////////////////////\n// The end of HG_SDF library\n////////////////////////////////////////////////////////////////\n\n\n\n\n//------------------------------------------------------------------------\n// Here rather hacky and very basic sphere tracer, feel free to replace.\n//------------------------------------------------------------------------\n\n// fField(p) is the final SDF definition, declared at the very bottom\n\nconst int iterations = 2000;\nconst float dist_eps = .0001;\nconst float ray_max = 2000.0;\nconst float fog_density = .001;\n\nconst float cam_dist = 35.;\n\nfloat fField(vec3 p);\n\nvec3 dNormal(vec3 p)\n{\n   const vec2 e = vec2(.005,0);\n   return normalize(vec3(\n      fField(p + e.xyy) - fField(p - e.xyy),\n      fField(p + e.yxy) - fField(p - e.yxy),\n      fField(p + e.yyx) - fField(p - e.yyx) ));\n}\n\nvec4 trace(vec3 ray_start, vec3 ray_dir)\n{\n   float ray_len = 0.0;\n   vec3 p = ray_start;\n   for(int i=0; i<iterations; ++i) {\n   \t  float dist = fField(p);\n      if (dist < dist_eps) break;\n      if (ray_len > ray_max) return vec4(0.0);\n      p += dist*ray_dir / 2.;\n      ray_len += dist;\n   }\n   return vec4(p, 1.0);\n}\n\n// abs(0+0-1)=1\n// abs(1+0-1)=0\n// abs(0+1-1)=0\n// abs(1+1-1)=1\nfloat xnor(float x, in float y) { return abs(x+y-1.0); }\n\nvec4 checker_texture(vec3 pos, float sample_size)\n{\n   pos = pos*8.0 + .5;\n   vec3 cell = step(1.0,mod(pos,2.0));\n   float checker = xnor(xnor(cell.x,cell.y),cell.z);\n   vec4 col = mix(vec4(.4),vec4(.5),checker);\n   float fade = 1.-min(1.,sample_size*24.); // very fake \"AA\"\n   col = mix(vec4(.95, .8, .2, .5),col,fade);\n   pos = abs(fract(pos)-.5);\n   float d = max(max(pos.x,pos.y),pos.z);\n   d = smoothstep(.45,.5,d)*fade;\n   return mix(col,vec4(0.0),d);\n}\n\nvec3 sky_color(vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float b_o = max(cos (uv.x * PI * 2.), cos (uv.y * PI * 2.));\n    vec3 col_o = vec3(b_o);\n    \n    vec2 uv_i = mod(uv * vec2(16., 9.), vec2(16., 9.));\n    uv_i = vec2(uv_i.x + uv_i.y, -uv_i.x + uv_i.y);\n    \n    \n    float b_i = max(cos (uv_i.x * PI * 2.), cos (uv_i.y * PI * 2.));\n    vec3 col_i = (b_i>.9?.2:0.) * vec3(1., 0.5, 1.);\n    col_i *= b_i = min(b_i, -b_o * 2.5);\n\n\n    // Output to screen\n    return vec3(b_o< 0.? col_i: col_o);\n}\n\n/*vec3 sky_color(vec3 ray_dir, vec3 light_dir)\n{\n   float d = max(0.,dot(ray_dir,light_dir));\n   float d2 = light_dir.y*.7+.3;\n   vec3 base_col;\n   base_col = mix(vec3(.3),vec3((ray_dir.y<0.)?0.:1.),abs(ray_dir.y));\n   return base_col*d2;\n}*/\n\nvec4 debug_plane(vec3 ray_start, vec3 ray_dir, float cut_plane, inout float ray_len)\n{\n    // Fancy lighty debug plane\n    if (ray_start.y > cut_plane && ray_dir.y < 0.) {\n       float d = (ray_start.y - cut_plane) / -ray_dir.y;\n       if (d < ray_len) {\n           vec3 hit = ray_start + ray_dir*d;\n           float hit_dist = fField(hit);\n           float iso = fract(hit_dist*5.0);\n           vec3 dist_color = mix(vec3(.2,.4,.6),vec3(.2,.2,.4),iso);\n           dist_color *= 1.0/(max(0.0,hit_dist)+.001);\n           ray_len = d;\n           return vec4(dist_color,.1);\n      }\n   }\n   return vec4(0);\n}\n\nvec3 shade(vec3 ray_start, vec3 ray_dir, vec3 light_dir, vec4 hit, vec2 fragCoord)\n{\n   vec3 fog_color = sky_color(fragCoord);\n   \n   float ray_len;\n   vec3 color;\n   if (hit.w == 0.0) {\n      ray_len = 1e16;\n      color = fog_color;\n   } else {\n      vec3 dir = hit.xyz - ray_start;\n      vec3 norm = dNormal(hit.xyz);\n      float diffuse = max(0.0, dot(norm, light_dir));\n      float spec = max(0.0,dot(reflect(light_dir,norm),normalize(dir)));\n      spec = pow(spec, 16.0)*.5;\n       \n      ray_len = length(dir);\n   \n      vec3 base_color = checker_texture(hit.xyz,ray_len/iResolution.y).xyz;\n      color = mix(vec3(0.,.1,.3),vec3(1.,1.,.9),diffuse)*base_color +\n         spec*vec3(1.,1.,.9);\n\n      float fog_dist = ray_len;\n      float fog = 1.0 - 1.0/exp(fog_dist*fog_density);\n      color = mix(color, fog_color, fog);\n   }\n   \n   \n    \n   float cut_plane0 = sin(iTime)*.15 - .8;\n   for(int k=0; k<4; ++k) {\n      vec4 dpcol = debug_plane(ray_start, ray_dir, cut_plane0+float(k)*.75, ray_len);\n      //if (dpcol.w == 0.) continue;\n      float fog_dist = ray_len;\n      dpcol.w *= 1.0/exp(fog_dist*.05);\n      //color = mix(color,dpcol.xyz,dpcol.w);\n   }\n\n   return color;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n   vec2 uv = (fragCoord.xy - iResolution.xy*0.5) / iResolution.y;\n    \n   vec3 light_dir = normalize(vec3(.5, 1.0, -.25));\n   \n   // Simple model-view matrix:\n   float ang, si, co;\n   ang = (iMouse.z > 0.0) ? (iMouse.x - iResolution.x*.5) * -.018 :\n      .5; //iTime*.25;\n   si = sin(ang); co = cos(ang);\n   mat4 cam_mat = mat4(\n      co, 0., si, 0.,\n      0., 1., 0., 0.,\n     -si, 0., co, 0.,\n      0., 0., 0., 1.);\n   ang = (iMouse.z > 0.0) ? (iMouse.y - iResolution.y*.5) * -.018 :\n      .6; //iTime*.2;\n   si = sin(ang); co = cos(ang);\n   cam_mat = cam_mat * mat4(\n      1., 0., 0., 0.,\n      0., co, si, 0.,\n      0.,-si, co, 0.,\n      0., 0., 0., 1.);\n\n   vec3 pos = vec3(cam_mat*vec4(0., -0., -cam_dist, 1.0));\n   vec3 dir = normalize(vec3(cam_mat*vec4(uv, 1., 0.)));\n   \n   vec3 color = shade(pos, dir, light_dir, trace(pos, dir), fragCoord);\n   color = pow(color,vec3(.44));\n   fragColor = vec4(color, 1.);\n}\n\n//------------------------------------------------------------------------\n// Your custom SDF\n//------------------------------------------------------------------------\n\n\n/*float fField(vec3 p)\n{\n   float towerspacing = 3.5;\n   vec2 c = pMod2(p.xz, vec2(towerspacing));\n   float towerfaces = 5. + floor(2. * sin(9. * c.x + 2.12345 * c.y));\n   pModPolar(p.xz, towerfaces);\n   \n   //pMirrorOctant(p.xz, vec2(.4, .4));\n   p.y += 1.;\n   float basewidth = 0.5 + .2 * sin(1. * c.x + 5.12345 * c.y);\n   float wallthinkness = .05 + .02 * sin(2. *c.x + 6.12345 * c.y);\n   float mainfaceheight = 1. + 1. * sin(3. *c.x + 6.12345 * c.y);\n   float balconywidth = 0.2 + .15 * sin(4. *c.x + 7.12345 * c.y);\n   float balconyheight = 0.2 + .1 * sin(5. *c.x + 8.12345 * c.y);\n   float breastguardheight = 0.15 + .1 * sin(c.x + 0.12345 * c.y);\n   p.x -= basewidth;\n   float mainface = fBox2(p.xy,vec2(wallthinkness, mainfaceheight));\n   p.y -= mainfaceheight;\n   p.x -= balconywidth;\n   float balconyfloor = fBox2(p.xy,vec2(balconywidth, wallthinkness));\n   p.y -= balconyheight;\n   p.x -= balconywidth;\n   float balconywall = fBox2(p.xy,vec2(wallthinkness, balconyheight));\n   p.y -= balconyheight;\n   pMod1(p.z, wallthinkness * 4.);\n   float breastguard = fBox(p,vec3(.1, breastguardheight, wallthinkness));\n   float wall = fOpUnionStairs(mainface, balconyfloor, .2, 3.);\n   wall = fOpUnionStairs(wall, balconywall, .2, 3.);\n   wall = min(wall, breastguard);\n   return wall;\n}\n*/\n\n/*float fField(vec3 p)\n{\n    float pilar_width = 0.1;\n    float pilar_spacing = 3.0;\n    float floor_height = .8;\n    float floor_thickness = 0.1;\n    float railing_thickness = 0.05;\n    float railing_height = 0.5;\n    float wall_height = 0.2;\n    float wall_width = 0.05;\n    \n    \n    vec3 po = p; // Save original position for reseting for frame.\n    \n    \n    pModPolar(p.xz, 4.);\n    p.x -= (1.5 + sin( iTime) * 1.5) * pilar_spacing;\n    \n    // Mirror at an axis-aligned plane which is at a specified distance <dist> from the origin.\n    pMirror(p.x, 3.);\n    \n    pMod1(p.z, pilar_spacing); // Repeat horizontally\n    \n    float ground =  fPlane(p, vec3(0., 1., 0.), 0.);\n    \n    p.y -= floor_height * 2.4;\n    float pilar = fBox(p,vec3(pilar_width, floor_height * 2.4, pilar_width));\n    \n    p.y = po.y;\n    p.y -= railing_height;\n    pModInterval1(p.y, floor_height * 2., 0., 2.);\n    //p.z -= pilar_spacing;\n    pR(p.yz, PI/2.);\n    float railing = fCylinder(p, railing_thickness, pilar_spacing);\n    \n    p.y = po.y;\n    p.y -= wall_height / 2.0;\n    pModInterval1(p.y, floor_height * 2., 0., 2.);\n    float wall = fBox2(p.xy, vec2(wall_width, wall_height)); \n    \n    \n    p.y = po.y;\n    p.y -= floor_height * 2.;\n    pModInterval1(p.y, floor_height * 2., -1., 1.);\n    p.x += 100. - pilar_width;\n    float parking_floor = fBox2(p.xy, vec2(100., floor_thickness));\n    \n    return min(min(min(min(pilar, railing), wall), parking_floor), 10000.);\n}*/\n\nfloat fField(vec3 p) {\n    float height = 1.;\n    \n    float ball = fSphere(p, 8.);\n    p.y -= height;\n    float cut = fSphere(vec3(p.x+28.*sin(iTime * .4), p.y-19., p.z), 19.);\n    \n    p.y += 3.2;\n    ball = fOpUnionRound(ball, fSphere(p, 5.), 0.8);\n    \n    float bumper = fOpUnionRound(fSphere(vec3(p.x, p.y-7., p.z + 5.+ sin(iTime * .4)), 5.), fSphere(vec3(p.x-3.+ sin(iTime * .2), p.y-7., p.z - 4.), 5.), 0.8);\n    bumper = fOpUnionRound(bumper, fSphere(vec3(p.x+3.+ sin(iTime * .3), p.y-6., p.z - 4.), 4.), .8);\n    bumper = fOpUnionRound(bumper, fSphere(vec3(p.x, p.y-23. + sin(iTime * .2), p.z), 19.), 0.8);\n    bumper = fOpUnionRound(bumper, fSphere(vec3(p.x+3., p.y-5. + sin(iTime * .6), p.z - 4.), 4.), 0.8);\n    bumper = fOpUnionRound(bumper, fSphere(vec3(p.x+3. * sin(iTime * .6), p.y-5., p.z + 4.), 4.), 0.8);\n    bumper = fOpUnionRound(bumper, fSphere(vec3(p.x-4., p.y-6., p.z + 2. + 2. * sin(iTime * .6)), 4.), 0.8);\n    \n    ball = max(ball, -bumper);\n    \n    ball = fOpUnionRound(ball, fSphere(vec3(p.x + 2. + 2. * sin(iTime * 3.), p.y - 3. + 7. * sin(iTime * 6.), p.z), 1.7), .5);\n    ball = fOpUnionRound(ball, fSphere(vec3(p.x - 2. + 2. * sin(iTime * 3. + 3.), p.y - 3. + 7. * sin(iTime * 6. + 4.), p.z), 1.), .5);\n    ball = fOpUnionRound(ball, fSphere(vec3(p.x, p.y - 3. + 7. * sin(iTime * 6. + 2.), p.z - 2. + 2. * sin(iTime * 3. + 3.)), 1.), .5);\n    \n    \n    return ball;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdfBzH.jpg", "access": "shaders20k", "license": "cc-by-4.0 OR cc-by-3.0", "functions": [[1494, 1533, 1553, 1553, 1578], [1580, 1580, 1604, 1604, 1619], [1621, 1621, 1643, 1643, 1658], [1660, 1660, 1682, 1682, 1697], [1699, 1699, 1724, 1724, 1745], [1748, 1788, 1808, 1808, 1833], [1835, 1835, 1855, 1855, 1890], [1892, 1892, 1912, 1912, 1957], [1959, 1959, 1979, 1979, 2004], [2006, 2006, 2026, 2026, 2061], [2063, 2063, 2083, 2083, 2128], [2686, 2686, 2718, 2718, 2743], [2745, 2819, 2875, 2875, 2917], [2919, 2970, 3003, 3015, 3043], [3045, 3081, 3109, 3109, 3190], [3192, 3249, 3283, 3283, 3309], [3311, 3311, 3340, 3340, 3421], [3424, 3444, 3468, 3468, 3527], [3529, 3633, 3654, 3654, 4027], [4029, 4074, 4122, 4122, 4196], [4198, 4251, 4293, 4293, 4387], [4389, 4473, 4517, 4517, 4620], [4622, 4694, 4743, 4743, 4780], [4782, 4807, 4867, 4867, 4938], [4940, 5039, 5071, 5071, 5132], [5134, 5267, 5297, 5297, 5378], [5380, 5421, 5465, 5465, 5705], [5707, 5744, 5784, 5784, 5848], [5850, 5946, 5995, 5995, 6494]], "test": "error"}
{"id": "WdffD8", "name": "Cow-Headed Fractal", "author": "jarble", "description": "This fractal is based on [url=https://www.shadertoy.com/view/3dfBW8]this shader[/url].", "tags": ["fractal", "cow"], "likes": 0, "viewed": 248, "published": "Public API", "date": "1588099022", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (12.0+sin(iTime)*4.0) * (fragCoord - iResolution.xy / (2.0)) / min(iResolution.y, iResolution.x);\n    \n    float lar;\n\n    for (float i=0.0; i < 6.0; i++)\n    {\n        lar = length(vec2(uv.x, uv.y));\n\t\tfloat uvx1= uv.x;\n        uv.x = - uv.y + sin(uv.x)*(uv.x);\n        uv.y = - uvx1 + sin(uv.y)*(uv.y);\n    }\n    // Output to screen\n    fragColor = vec4(cos(lar * 2.0), cos(lar * 3.0), cos(lar * 1.0), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdffD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 533]], "test": "valid"}
{"id": "wdffDn", "name": "2nd Reality Techno Circles", "author": "hisojarvi", "description": "Techno Circles effect from the demo Second Reality by Future Crew.", "tags": ["demoscene", "interference", "demoeffect"], "likes": 4, "viewed": 78, "published": "Public", "date": "1588016938", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    \n    vec2 board1Center = vec2(1.0 + 0.6 * sin(1.4*iTime), 0.5 + 0.5*cos(1.4*iTime));\n    vec2 board2Center = vec2(1.2 + 0.5 * sin(2.2*iTime), 0.3 + 0.4*cos(2.2*iTime));\n       \n    float board1RingSize = 0.07;\n    float board1PulseSpeed = 5.0f;   \n    float board2RingSize = 0.07;   \n    \n    float intensity = 1.0 - mod(-board1PulseSpeed*iTime + distance(board1Center, uv)/board1RingSize, 1.0);       \n    float intensityXor = mod(-board1PulseSpeed*iTime + distance(board1Center, uv)/board1RingSize, 1.0);\n    \n    vec2 board2DistortUv = vec2(uv.x + 0.2*sin(iTime+3.0*uv.x), uv.y + 0.2*sin(1.1*iTime+2.0*uv.y));\n    float xorPhase = floor(mod(distance(board2Center, board2DistortUv)/board2RingSize, 2.0));\n    \n    fragColor = vec4(intensity*xorPhase + intensityXor*(1.0-xorPhase), 0.8*intensity*xorPhase + intensityXor*(1.0-xorPhase), intensity*xorPhase + intensityXor*(1.0-xorPhase), 1.0 );\n    \n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdffDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1051]], "test": "valid"}
{"id": "wdffWH", "name": "SDF 2D Convex Polygon Shape", "author": "RiggsDK", "description": "This variant of a generic (convex) polygon shader uses \"point-in-polygon\" testing if a point is at a right-hand turn away from all the line segments of the polygon.\nThe approach requires all line segments to be in clockwise order. (invert sign otherwise)", "tags": ["2d", "sdf", "convex", "distance", "polygon", "shape"], "likes": 2, "viewed": 226, "published": "Public", "date": "1588136132", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2020 Anders Riggelsen\n// Based uppon Inigo Quilez original code\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\nstruct Result{\n    float dist;     //Regular SDF distance\n    float side;     //Which side of the line segment the point is (-1,0,1)\n};\n   \nResult udSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    Result res;\n    //All this is basically Inigo's regular line SDF function - but store it in 'dist' instead: \n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    res.dist = length(pa-h*ba);\n    //Is the movement (a->b->p) a righthand turn? (cross product)\n    res.side = sign( (b.x - a.x)*(p.y - a.y) - (b.y - a.y)*(p.x - a.x) ); \n    return res;\n}\n\nvec2 jiggle(vec2 p)\n{\n    return p + vec2(sin(iTime*p.y), cos(iTime*p.x))*0.25;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    //List of points. All could be put into a loop if need be.\n    //Jiggled for your viewing pleasure.\n    vec2 pA = jiggle(vec2(-0.8,  0.7));\n    vec2 pB = jiggle(vec2( 1.0,  0.8));\n    vec2 pC = jiggle(vec2( 1.0, -0.4));\n    vec2 pD = jiggle(vec2( 0.0, -1.2));\n    vec2 pE = jiggle(vec2(-1.0, -0.6));\n\n    //Get the SDF distances for the line segments along with the 'side':\n    Result rA = udSegment( p, pA, pB);\n    Result rB = udSegment( p, pB, pC );\n    Result rC = udSegment( p, pC, pD );\n    Result rD = udSegment( p, pD, pE );\n    Result rE = udSegment( p, pE, pA );\n    \n    //Union of all distances\n    float d =  rA.dist;\n    d = min(d, rB.dist);\n    d = min(d, rC.dist);\n    d = min(d, rD.dist);\n    d = min(d, rE.dist);\n    //At this point all we have is a SDF of an infinitely thin shape.\n    //To make it \"solid\" we have to give all the points on the inside a negative distance.\n    \n    //But which side is the point on?\n    //If the \"side\" is negative for *all* N segments the sum will be -N.\n    //Adding N and subtracting a small value ]0-1[ before getting the sign\n    //of this sum makes it either 1 (outside of shape) or -1 (inside of shape)\n    d = d * sign(rA.side + rB.side + rC.side + rD.side + rE.side + 5.0 - 0.5);\n        \n    //Inigo's pretty colors:\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n    col *= 1.0 - exp(-3.0*abs(d));\n    col *= 0.8 + 0.2*cos(120.0*d);\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdffWH.jpg", "access": "shaders20k", "license": "mit", "functions": [[1265, 1265, 1318, 1318, 1716], [1718, 1718, 1739, 1739, 1799], [1801, 1801, 1858, 1858, 3429]], "test": "valid"}
{"id": "WdffzM", "name": "Yellow butterfly", "author": "gaz", "description": "https://twitter.com/gaziya5/status/1254182551037472768", "tags": ["3d", "2tweets"], "likes": 3, "viewed": 98, "published": "Public", "date": "1587855546", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 O, vec2 C) {\n\tfor(float g=0.,e,i=1.;i++<60.;){\n        vec3 p=g*vec3((C*2.-iResolution.xy)/iResolution.y,1.);\n        p.z+=iTime;\n        p.z=fract(p.z);\n        for(int j=0;j++<6;)p=abs(p)-.4;\n        g+=e=length(vec2(dot(abs(p.xy),vec2(.6))-.3,p.z))-.001;\n\t\te<.1?O.xyz+=sin(p*30.+length(p.xy)*15.)/e/30./i:p;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdffzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 342]], "test": "valid"}
{"id": "WdfyDl", "name": "Banana Feeder", "author": "propagant", "description": "Exploring random methods, made this just for fun & practice...", "tags": ["raymarching", "cartoon"], "likes": 3, "viewed": 264, "published": "Public API", "date": "1585795445", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//---Made by Matej Vanco just for fun and practice\n\nstruct ray\n{\n\tvec3 o;\n\tvec3 d;\n\tfloat l;\n};\n\t\nmat2 rot(float a)\n{\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\treturn mat2(c, -s, s, c);\n}\n\nvec4 opu(vec4 a, vec4 b)\n{\n\treturn (a.w < b.w) ? a : b;\t\n}\n\nfloat nnn(float p, float a, float b, float c)\n{\n\treturn cos(-p*a + iTime * b)*c;\n}\n\t\nvec4 geo(vec3 p)\n{\n\tvec3 color_head = mix(vec3(0.0,1.0,0.0), vec3(1.0,1.0,0.0), cos(iTime * 11.));\n\n\tfloat height = -0.1;\n    \n\tvec4 head = vec4(color_head,length(p - vec3(0.75,height,1.5))-0.4) \n        + nnn(p.x,4.2,10.5,0.2);\n\tvec4 eye = vec4(vec3(1.0),length(p - vec3(0.75,height+0.15,1.3))-0.25) \n        + nnn(p.x, 4.2, 10.5, 0.2);\n\tvec4 eyeB = vec4(vec3(0.),length(p - vec3(0.6,height+0.18,1.28))-0.15) \n        + clamp(nnn(p.x, 4.2, 10.5, 0.2),-0.9,0.15);\n\tvec4 plane = vec4(0.2,0.6,0.4,(p.y + 0.55));\n\tvec3 bRot = p;\n\tbRot.yz *= rot(0.4);\n\tvec4 box = vec4(1.0,1.0,0.0,length(\n        max(abs(bRot - vec3(-0.9,-0.6,1.3)) - vec3(1.15,0.02,0.02),0.0) + nnn(p.x, 2.1, 10.5, 0.2)) - 0.06);\n\n\tvec4 g = opu(head, plane);\n\tvec4 g2 = opu(g, box);\n\tvec4 g3 = opu(g2, eye);\n\tvec4 g4 = opu(g3, eyeB);\n\treturn g4;\n}\n\nvec4 march(ray r)\n{\n\tvec3 col = vec3(1.0);\n\tfor(int i = 0; i < 64; i++)\n\t{\n\t\tvec3 p = r.o + r.d * r.l;\n\t\tvec4 g = geo(p);\n\t\tr.l += g.w;\n\t\tcol = g.rgb;\n\t\tif(r.l > 32.)\n\t\t\tbreak;\n\t}\n\treturn vec4(col, r.l);\n}\n\nvec3 normal(vec3 p)\n{\n\tvec2 of = vec2(0.001, 0.0);\n\tfloat copy = geo(p).w;\n\treturn normalize(copy - vec3(geo(p - of.xyy).w, geo(p - of.yxy).w, geo(p - of.yyx).w));\n}\n\nfloat shadow(vec3 ro, vec3 rd, float b)\n{\n\tfloat t = 0.01;\n\tfloat res = 1.;\n\tfor(int i = 0; i < 16; i++)\n\t{\n\t\tfloat copy = geo(ro + rd * t).w;\n\t\tres = min(res, b * copy/t);\n\t\tif(copy < 0.001)\n\t\t\tbreak;\t\n\t\tt += copy;\n\t\tif(t < 0.01 || t > 3.)\n\t\t\tbreak;\n\t}\n\treturn clamp(res,0.2,1.);\n}\n\nfloat lighting(vec3 p)\n{\n\tvec3 lp = vec3(1.0,2.,-1.);\n\tvec3 lPos = normalize(lp - p);\n\tvec3 n = normal(p);\n\t\n\tfloat light = clamp(dot(lPos, n), 0.1,1.);\n\treturn light * shadow(p, lp, 0.8);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord -0.5 *iResolution.xy)/iResolution.y;\n    \n   \tray r;\n\tr.o = vec3(0.);\n\tuv.xy += sin(iTime * 25.)*0.015;\n\tr.d = vec3(uv, 1.0);\n\tvec4 m = march(r);\n\tvec3 mm = r.o + r.d * m.w;\n    \n    vec2 p = mm.xz;\n    p.x-=iTime * 6.;\n    if(m.rgb == vec3(0.2,0.6,0.4))\n    {\n     \tif(fract(sin(p.x*0.5)*0.5)>0.45) m.rgb = mix(m.rgb,vec3(0.6,0.6,0.3)*2.,uv.x); \n    }\n    \n\tvec3 col = m.rgb * lighting(mm);\n    col *= exp(-0.05 * pow(m.w, 3.));\n\tcol += (vec3(0.2,0.35,0.25) * 0.6) / 1.5;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdfyDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[98, 98, 117, 117, 184], [186, 186, 212, 212, 244], [246, 246, 293, 293, 328], [331, 331, 349, 349, 1142], [1144, 1144, 1163, 1163, 1349], [1351, 1351, 1372, 1372, 1516], [1518, 1518, 1559, 1559, 1800], [1802, 1802, 1826, 1826, 1992], [1995, 1995, 2052, 2052, 2583]], "test": "valid"}
{"id": "wdfyWf", "name": "36 Days Of Type - L", "author": "nicolasdnl", "description": "36 Days Of Type - L", "tags": ["letter"], "likes": 0, "viewed": 33, "published": "Public", "date": "1585872508", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535897932384626433832795\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat msign( in float x ) { return (x>0.0)?1.0:-1.0; }\n\n// http://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nvec2 sdSqLine( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( dot2(pa-ba*h), ba.x*pa.y-ba.y*pa.x );\n}\n\nfloat sdCrescent(vec2 p, float r0, float r1, float d, float sign0, float sign1)\n{\n    float a = (r0*r0 - r1*r1 + d*d) / (2.0 * d);\n    \n    if( a < r0)\n    {\n        p.y = abs(p.y);\n        float b = sqrt(r0*r0-a*a);\n        float k = p.y*a - p.x*b;\n        float h = min(d*sign0*(d*(p.y-b)-k ),\n                      d*sign1*k);\n        if (h>0.0)\n        {\n            return length(p-vec2(a,b));\n        }\n    }\n    \n    return max(sign0*(length(p          )-r0),\n               sign1*(length(p-vec2(d,0))-r1));\n}\n\n// http://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nvec2 sdSqArc( in vec2 p, in vec2 a, in vec2 b, in float h, float d2min )\n{\n    vec2  ba  = b-a;\n    float l   = length(ba);\n    float ra2 = h*h + l*l*0.25;\n\n    // recenter\n    p -= (a+b)/2.0 + vec2(-ba.y,ba.x)*h/l;\n    \n    float m = ba.y*p.x-ba.x*p.y;\n    float n = dot(p,p);\n    \n    if( abs(h)*abs(ba.x*p.x+ba.y*p.y) < msign(h)*l*0.5*m )\n    {\n        d2min = min( d2min, n + ra2 - 2.0*sqrt(n*ra2) );\n    }\n\n    return vec2(d2min, -max(m,ra2-n) );\n}\n\n\n//------------------------------------------------------------\n\n\n\n// SDF of a shape made of a set line and arc segments\nfloat sdShape( in vec2 p, int kType[7], float kPath[17] )\n{\n    vec2 vb = vec2(kPath[0],kPath[1]);\n    \n    float d = dot2(p-vb);\n    int off = 0;\n    float s = 1.0;\n    for( int i=0; i<kType.length(); i++ )\n    {\n        vec2 va = vb;\n        vec2 ds;\n        \n        if( kType[i]==0) // line (x,y)\n        {\n            vb = vec2(kPath[off+2],kPath[off+3]);\n            ds = sdSqLine( p, va, vb );\n            off += 2;\n        }\n        else if( kType[i]==1 || kType[i]==2 ) // arc (x,y,r)\n        {\n            vb = vec2(kPath[off+3],kPath[off+4]);\n            ds = sdSqArc(p, va, vb, kPath[off+2], d );\n        \toff += 3;\n\n        }\n        \n        // in/out test\n        if ( kType[i]==2 )\n        {\n            bvec3 cond = bvec3( p.y<va.y, p.y<vb.y, ds.y>0.0 );\n            if( all(cond) || all(not(cond)) ) s*=-1.0;\n        }\n        else\n        {\n            bvec3 cond = bvec3( p.y>=va.y, p.y<vb.y, ds.y>0.0 );\n            if( all(cond) || all(not(cond)) ) s*=-1.0;\n        }\n\n        d = min( d, ds.x );\n    }\n    \n    if( p.y < 0. ) s*=-1.0;\n    if( p.y < 0.0 && p.y > -0.5 && p.x < 0.5 && p.x > 0.0 ) s=-1.0; // hack\n    if( p.y < 0.0 && p.y > -0.5 && p.x > 0.5 ) s=1.0; // hack\n    \n\treturn s*sqrt(d);\n}\n\nfloat sdA( in vec2 p )\n{\n    float width = 1.;\n    float height = 1.;\n    \n   \t/*int kType[] = int[](0,1,0,0,0);\n\tfloat kPath[] = float[]( -width*0.5, height*0.5,\n                              0.0, height*0.5, 0.25,\n                              width*0.5, 0.0,\n                              width*0.5,-height*0.5,\n                             -width*0.5,-height*0.5,\n                             -width*0.5, height*0.5 );*/\n    int kType[] = int[](0,0,0,0,0,1,0);\n\tfloat kPath[] = float[]( -width*0.5, height*0.5,\n                              0.0, height*0.5,\n                              0.0, 0.0,\n                              width*0.5, 0.0,\n                              width*0.5,-height*0.5,\n                              0.0,-height*0.5,-0.4,\n                             -width*0.5,-0.0,\n                             -width*0.5, height*0.5 );\n    return sdShape(p,kType,kPath );\n}\n\nvec3 generateBorder(in vec3 col, in float border)\n{\n    col = mix( col, vec3(0.0), 1.0-smoothstep(0.0,0.015,border) );\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n    vec2 p = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    vec2 p2 = p;\n    \n    // distance computations\n    float lineWidth = 0.08;\n    \n    float dMask = sdA(p);\n    \n    float t = mod(iTime * 0.5, 1.) * PI * 2.;\n    \n    p += vec2(-sin(t), cos(t)) * 0.08;\n    float transform = sign(mod(p.y, lineWidth) / lineWidth - 0.5);\n    float d = sdA(p);\n    \n    p2 -= vec2(-sin(t), cos(t)) * 0.08;\n    float transform2 = sign(mod(p2.y, lineWidth) / lineWidth - 0.5);\n    float d2 = sdA(p2);\n    \n    vec3 col = vec3(1.0) - sign(d)*vec3(1.0);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.15,abs(d)) );\n    col *= transform;\n    \n    vec3 col2 = vec3(1.0) - sign(d2)*vec3(1.0);\n\tcol2 = mix( col2, vec3(1.0), 1.0-smoothstep(0.0,0.15,abs(d2)) );\n    col2 *= transform2;\n    \n    vec3 color = col + col2;\n    \n    float mask = 1. - sign(dMask);\n\tmask = mix(mask, 1., 1.0-smoothstep(0.0,0.05,abs(dMask)));\n    \n    //color = (1.-color)*mask + color*(1.-mask);\n    color *= 1.-mask;\n\n    // output\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdfyWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 71, 71, 90], [91, 91, 118, 118, 145], [147, 221, 271, 271, 404], [406, 406, 487, 487, 922], [924, 998, 1072, 1072, 1451], [1520, 1574, 1633, 1633, 2795], [3690, 3690, 3741, 3741, 3826], [3828, 3828, 3885, 3921, 4949]], "test": "error"}
{"id": "WdjcDG", "name": "Circle radius perturbations", "author": "nickcody", "description": "Use mouse: y adjusts strength of sinusoidal perturbation of radius, x adjusts number of petals.\n", "tags": ["geometry", "basics"], "likes": 0, "viewed": 210, "published": "Public API", "date": "1587269562", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec3 white = vec3(1., 1., 1.);\nconst vec3 black = vec3(0., 0., 0.);\nconst vec3 gray  = vec3(.2, .2, .3);\n\n// circleTest\n//\n// coord      - pixel to test\n// center     - center of circle\n// radius     - radius of circle\n// width      - thickness of circle line\n// pixelWidth - blendiness\n\nvec3 circleTest(vec2 coord, vec2 center, float radius, float width, float pixelWidth) {\n    float delta = distance(coord, center)-radius;\n    \n    // From shadertoy default shader\n    vec3 inside = .5 + .5*cos(iTime+coord.xyx+vec3(0,2,4));\n    \n    float blend = smoothstep(0., pixelWidth, abs(delta) - width);\n    \n    if (delta  < 0.)\n        return mix(white, inside, blend); // rgb -> white (inside  edge)\n    else if (delta  > 0.)\n        return mix(white, black, blend);  // white -> black (outside edge)\n    else\n        return white;\t\t\t\t\t  // can't decide\n        \n}\n\n// Credit: https://thebookofshaders.com/edit.php#10/ikeda-simple-grid.frag\n//\nfloat grid(vec2 st, float res){\n    vec2 grid = fract(st*res);\n    return 1.-(step(res,grid.x) * step(res,grid.y));\n}\n\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord) {\n    \n    float aspect     = iResolution.y/iResolution.x,\n          pixelWidth = 1./iResolution.x,\n          width      = 2./iResolution.x,\n          maxPetals  = 12.,\n          br         = .1;\n\n    \n    vec2 dMouse = iMouse.xy == vec2(0) ? iResolution.xy/2. : iMouse.xy,\n         cen    = vec2(1., aspect) / 2.,\n    \t q      = fragCoord.xy/iResolution.x,\n    \t nq     = q - cen,\n    \t m      = dMouse.xy/iResolution.x,\n         nm     = m - cen;\n    \n    float a   = atan(nq.y,nq.x);\n    float p   = ceil(maxPetals * m.x);\n\tfloat vr  = 8. * br * aspect * nm.y; // -1./petals keeps bottom row as vr=0\n    float s   = sin(p * a);\n    float r   = br  + vr * s;\n    \n    vec3 c = circleTest(\n        q, \n        cen,\n        r,\n        width, \n        pixelWidth\n    );\n\t\n    c = c == vec3(0.) ? gray * grid(fragCoord, maxPetals/iResolution.x ) : c;\n    \n    out_color = vec4(c, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdjcDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[294, 294, 381, 381, 868], [870, 948, 979, 979, 1065], [1068, 1068, 1120, 1120, 2003]], "test": "valid"}
{"id": "WdjcDW", "name": "blade", "author": "lennyjpg", "description": "dfgdfgdfgdfg", "tags": ["dfgdfgdfg"], "likes": 1, "viewed": 204, "published": "Public API", "date": "1586661280", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;    \n    uv.x+=uv.y*0.2;\n    float t = iTime * 0.2;\n    t*= uv.y > fract(uv.x*2.0)? 1.0: -1.0;\n    uv.x += t;\n    float y = uv.y;\n    float e = uv.x*40.;\n    float d = tan(e)*0.1+0.4+sin(uv.x*5.5)*0.1;\n    float k = smoothstep(abs(y+0.5)*0.5,y*0.3,d);\n    fragColor = vec4(k);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdjcDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 375]], "test": "valid"}
{"id": "WdjcDy", "name": "TEARS", "author": "os0450", "description": "Tear drops", "tags": ["dailycodingchallenge"], "likes": 1, "viewed": 58, "published": "Public", "date": "1587280917", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 p) {\n    return fract(sin(dot(p, vec2(12.344532, 4321.3432))) * 321321.6);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.xx;\n\t\n    \n    vec3 col = vec3(0.);\n    \n    for(int j=-1; j<=1; j++) {\n        vec2 q = p;\n        q = mod(q*6., 1.)-0.5;\n        q.y -= float(j);\n\n        vec2 id = floor(p*6.);\n\n        q /= 0.5;\n        q.y -= mod(-iTime*(0.5+rand(id.xx)*3.), 2.);\n        q.y = q.y > 0. ? q.y/(2.0*exp(-abs(q.x))) : q.y;\n        float d = smoothstep(0.1, 0.0, length(q)-0.3);\n\n        col += d*vec3(0.6, 0.6, 1.0*(0.5+q.x) + (0.5-q.y));\n    }\n    \n    fragColor = vec4(col,1.0);\n }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdjcDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 92], [94, 94, 151, 151, 677]], "test": "valid"}
{"id": "WdjcW3", "name": "Chaotic standard map", "author": "Roninkoi", "description": "Standard map from chaos theory with varying K.", "tags": ["map", "chaos", "standard", "standardmap"], "likes": 4, "viewed": 261, "published": "Public API", "date": "1587436724", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    float x0 = uv.x * 2. * PI;\n    float p0 = uv.y * 2. * PI;\n    \n    float k = sin(iTime * 0.2) + 1.0;\n    \n    float p = p0;\n    float x = x0;\n    \n    for (int i = 0; i < 50; ++i) {\n    \tp = mod(p + k * sin(x), 2. * PI);\n    \tx = mod(x + p, 2. * PI);\n    }\n    \n    float q = abs(p - p0);\n    \n    vec3 col = vec3(\n        sin(q), sin(q + PI / 3.), sin(q + 2. * (PI / 3.))\n    );\n    \n    fragColor = vec4(col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdjcW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 78, 78, 547]], "test": "valid"}
{"id": "wdjcWV", "name": "Relief Mapping Demo", "author": "benpigchu", "description": "My first shadertoy entry.", "tags": ["3d"], "likes": 0, "viewed": 109, "published": "Public", "date": "1587379879", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 quaternion(vec3 axis,float angle){\n\tfloat halfang=angle/2.;\n    return vec4(axis*sin(halfang),cos(halfang));\n}\n\nvec4 quaternionMultiply(vec4 q1,vec4 q2){\n\treturn vec4(q1.xyz*q2.w+q1.w*q2.xyz+cross(q1.xyz,q2.xyz),q1.w*q2.w-dot(q1.xyz,q2.xyz));\n}\n\nvec3 rotation(vec4 q,vec3 pos){\n\treturn pos+2.*cross(q.xyz,cross(q.xyz,pos)+q.w*pos);\n}\n\nfloat hash(float v){\n\treturn fract(sin(v*438.9)*43758.5453);\n}\n\nvec4 texColor(vec3 pos)\n{\t\n    if(pos.x<=1.&&pos.x>=0.&&pos.y<=1.&&pos.y>=0.){\n        float value=hash(floor(pos.z*64.))*.5+fract(pos.z*64.)*.5;\n        vec3 color=.5+.5*cos(radians(360.*(value/8.+vec3(1.5,2.5,3.5)/10.)));\n        return vec4(color,1.0);\n    }\n\treturn vec4(0,0,0,0);\n}\n\nfloat texDepth(vec2 pos){\n\tfloat baseDepth=.5-max(abs(pos.x-0.5),abs(pos.y-0.5));\n    float dsquare=(pos.x-0.5)*(pos.x-0.5)+(pos.y-0.5)*(pos.y-0.5);\n    float ball=dsquare>1./16.?.25:(.25-sqrt(1./16.-dsquare));\n    return min(ball,clamp(baseDepth,0.,.25));\n}\n\nvec3 texNormal(vec2 pos){\n    if(abs(pos.x-0.5)>=0.25||abs(pos.y-0.5)>=0.25){\n        if(abs(pos.x-0.5)<=0.5&&abs(pos.y-0.5)<=0.5){\n            vec3 leftdown=(pos.x>pos.y)?vec3(0,1,1):vec3(1,0,1);\n            vec3 rightup=(pos.x>pos.y)?vec3(-1,0,1):vec3(0,-1,1);\n            return normalize((pos.x+pos.y>=1.)?rightup:leftdown);\n        }\n    }\n    float dsquare=(pos.x-0.5)*(pos.x-0.5)+(pos.y-0.5)*(pos.y-0.5);\n    if(dsquare<=1./16.){\n        return normalize(vec3(pos.x-0.5,pos.y-0.5,sqrt(1./16.-dsquare)));\n    }\n\treturn vec3(0,0,1);\n}\n\nvec3 rayDirection(vec2 fragCoord){\n    float zoom=1.2;\n    vec2 offset=fragCoord/iResolution.xy-0.5;\n    offset.y/=iResolution.x/iResolution.y;\n    vec3 rawDir=vec3(offset/zoom,-1.);\n    vec2 mouseAngles=iMouse.xy/iResolution.xy-0.5;\n    vec4 qUpDown=quaternion(vec3(1,0,0),radians(45.+mouseAngles.y*30.0));\n    vec4 qLeftRight=quaternion(vec3(0,0,1),radians(-45.-mouseAngles.x*30.0));\n    vec4 q=quaternionMultiply(qLeftRight,qUpDown);\n    return normalize(rotation(q,rawDir));\n}\n\n#define iteration 128\n#define binaryPass 16\nvec3 rayMarching(vec3 start,vec3 dir,float maxDepth){\n    vec3 steps=-dir/dir.z*maxDepth/float(iteration);\n    vec3 pos=start;\n    for(int i=0;i<iteration+1;i++){\n        vec3 next=pos+steps;\n        if(next.z+texDepth(next.xy)<0.){\n            for(int j=0;j<binaryPass;j++){\n                vec3 mid=(pos+next)/2.;\n                if(mid.z+texDepth(mid.xy)<0.){\n                    next=mid;\n                }else{\n                \tpos=mid;\n                }\n            }\n            return pos;\n        }\n        pos=next;\n    }\n    return pos;\n}\n\nfloat lighting(vec3 pos){\n    vec3 light=vec3(2.1*sin(iTime)+0.5,2.1*cos(iTime)+0.5,1.75);\n    float diffuse=clamp(dot(normalize(light-pos),texNormal(pos.xy)),0.,1.);\n    vec3 lightdir=normalize(pos-light);\n    vec3 start=light-(light.z/lightdir.z)*lightdir;\n    vec3 steps=(pos-start)/float(iteration);\n    for(int i=0;i<iteration;i++){\n        vec3 current=steps*float(i)+start;\n        if(current.z+texDepth(current.xy)<0.){\n        \treturn diffuse*.25+.5;\n        }\n    }\n\treturn diffuse*.5+.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cameraPos=vec3(-1.+.25*sin(iTime),-1.-.25*sin(iTime),2.0);\n    vec3 dir=rayDirection(fragCoord);\n    float t=-cameraPos.z/dir.z;\n    vec3 pos=rayMarching(cameraPos+t*dir,dir,.25);\n    fragColor = texColor(pos)*lighting(pos);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdjcWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 115], [117, 117, 158, 158, 249], [251, 251, 282, 282, 338], [340, 340, 360, 360, 402], [404, 404, 429, 429, 690], [692, 692, 717, 717, 950], [952, 952, 977, 977, 1491], [1493, 1493, 1527, 1527, 1973], [2019, 2019, 2072, 2072, 2568], [2570, 2570, 2595, 2595, 3070], [3072, 3072, 3129, 3129, 3365]], "test": "valid"}
{"id": "WdjcWy", "name": "Conformal Droste effect (ver2)", "author": "RadoKirov", "description": "math behind this conformal mapping - http://www.ams.org/notices/200304/fea-escher.pdf", "tags": ["escher", "conformal"], "likes": 13, "viewed": 187, "published": "Public", "date": "1587273909", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision highp float;\n\n#define M_PI 3.1415926535897932384626433832795\n\n// Parameters\nfloat winding = 4.0;\nfloat numSpirals = 3.0;\n\nfloat u_f = 2.5; // scaling\n\nfloat speed = 3.0;\n\n// convert from cartisian to polar.\n// returns [r, theta] in x+iy = r e^i * theta\nvec2 polarz(in vec2 c) {\n  return vec2(length(c), atan(c.y, c.x));\n}\n\n// convert from polar to cartisian.\nvec2 cart(in vec2 c) {\n  return vec2(c.x * cos(c.y), c.x * sin(c.y));\n}\n\nvec2 powz(in vec2 c1, in vec2 c2) {\n  vec2 polarC = polarz(c1);\n\n  // (r * e ^ i theta) ^ (x + i y) = r ^ x * r ^ i y * e ^ i x theta * e ^ - y theta\n  // r ^ x * e ^ - y theta * e ^ i (x theta + log (r) y)\n  // |--------- r -------| * e ^ i |------- theta -----|\n\n  float r = pow(polarC.x, c2.x) * exp(-polarC.y * c2.y);\n  float theta = c2.x * polarC.y + log(polarC.x) * c2.y;\n\n  return cart(vec2(r, theta));\n}\n\n\n\nvec3 grid2(in vec2 uv) {\n\n  return (vec3(\n               0.2 * (uv.y * 2.0 - 1.0) + 0.5,\n               0.2 * (uv.x * 2.0 - 1.0) + 0.3,\n               0.2 * length(uv - 0.5) + 0.2));\n}\n\nvec2 conformal(in vec2 uv, float winding, float numSpirals) {\n  float P = log(u_f) / M_PI / 2.0;\n  vec2 alpha = vec2(winding / 4.0, numSpirals * P);\n  return powz(uv, alpha);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 c = (2.0 * fragCoord - iResolution.xy) / iResolution.x;\n    vec2 e = conformal(c, winding, numSpirals);\n    \n    float t = iTime / speed;\n    e /= exp(log(u_f) * fract(t / log(u_f)));\n    while (abs(e.x) > 1.0 || abs(e.y) > 1.0) {\n      e /= u_f;\n    }\n    while (abs(e.x) < 1.0 / u_f && abs(e.y) < 1.0 / u_f) {\n      e *= u_f;\n    }\n    \n    fragColor = vec4(grid2(e + 1.0 / 2.0), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdjcWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[181, 263, 287, 287, 331], [333, 369, 391, 391, 440], [442, 442, 477, 477, 853], [857, 857, 881, 881, 1041], [1043, 1043, 1104, 1104, 1219], [1221, 1221, 1278, 1329, 1728]], "test": "valid"}
{"id": "Wdjczm", "name": "Stretchy plasma", "author": "aolsystemmsg", "description": "Far out man", "tags": ["trippy", "acid"], "likes": 1, "viewed": 205, "published": "Public API", "date": "1586345293", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535897932384626433832795\n\n//#define u_k vec2(.001, .001)\n#define in_w = 449\n#define in_h = 483\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat v = 0.0;\n    vec2 u_k = vec2(sin(iTime * 2.0) * .05 + .051, cos(iTime * 2.0) * .050 + .051);\n    vec2 c = fragCoord * u_k - u_k/2.0;\n    v += sin((c.x+iTime));\n    v += sin((c.y+iTime)/2.0);\n    v += sin((c.x+c.y+iTime)/2.0);\n    c += u_k/2.0 * vec2(sin(iTime/3.0), cos(iTime/2.0));\n    v += sin(sqrt(c.x*c.x+c.y*c.y+1.0)+iTime);\n    v = v/2.0;\n    vec3 col = vec3(1, sin(PI*v), cos(PI*v));\n\n    // Output to screen\n    fragColor = vec4(col*.5 + .5, 1);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wdjczm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[117, 117, 174, 174, 637]], "test": "valid"}
{"id": "WdjyDd", "name": "Traffic route", "author": "gaz", "description": "https://twitter.com/gaziya5/status/1252796743084765184", "tags": ["3d", "2tweets"], "likes": 6, "viewed": 131, "published": "Public", "date": "1587526230", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 O, in vec2 C)\n{\n\tO-=O;\n    O+=.05;\n    for(float i,j=0.;j<12.;j++)\n    for(i=0.;i<150.;i++)\n        O+=abs(cos(vec4(6,3,5,0)+i*5.)+.2-.3)*\n        exp(-40.*length(cross((abs(fract(fract(37.*sin((vec3(6,5,9)+i*.3)))+\n        (iTime+j*.07)*.1)*2.-1.)*2.-1.)*3.,\n        vec3(C.xy/iResolution.y,1))));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdjyDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 324]], "test": "valid"}
{"id": "WdjyDh", "name": "mandelbulb--derivate---v5", "author": "jorge2017a1", "description": "mandelbulb--derivate---v5", "tags": ["mandelbulbderivatev5"], "likes": 1, "viewed": 64, "published": "Public", "date": "1586550239", "time_retrieved": "2021-10-01T00:00:00", "image_code": "///Original por IQ --> https://www.shadertoy.com/view/ltfSWn\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// The source code for these videos from 2009: \n// https://www.youtube.com/watch?v=eKUh4nkmQbc\n// https://www.youtube.com/watch?v=erS6SKqtXLY\n\n// More info here: http://iquilezles.org/www/articles/mandelbulb/mandelbulb.htm\n\n// See https://www.shadertoy.com/view/MdfGRr to see the Julia counterpart\n\n\n//------------------------------\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n///-----------------------------\n\n\n\n\nvec2 isphere( in vec4 sph, in vec3 ro, in vec3 rd )\n{\n    vec3 oc = ro - sph.xyz;\n    \n\tfloat b = dot(oc,rd);\n\tfloat c = dot(oc,oc) - sph.w*sph.w;\n    float h = b*b - c;\n    \n    if( h<0.0 ) return vec2(-1.0);\n\n    h = sqrt( h );\n\n    return -b + vec2(-h,h);\n}\n\n#define ZERO (min(iFrame,0))\n\n\nfloat map( in vec3 p, out vec4 resColor )\n{\n    vec3 w = p;\n    float m = dot(w,w);\n\n    vec4 trap = vec4(abs(w),m);\n\tfloat dz = 1.0;\n    \n    \n\tfor( int i=0; i<4; i++ )\n    {\n        dz = 8.0*pow(sqrt(m),7.0)*dz + 1.0;\n\t\t//dz = 8.0*pow(m,3.5)*dz + 1.0;\n        \n        float r = length(w);\n        float b = 8.0*acos( w.y/r);\n        float a = 8.0*atan( w.x, w.z );\n        w = p + pow(r,8.0) * vec3( sin(b)*sin(a), cos(b), sin(b)*cos(a) );\n\n        \n        trap = min( trap, vec4(abs(w),m) );\n\n        m = dot(w,w);\n\t\tif( m > 256.0 )\n            break;\n    }\n\n    resColor = vec4(m,trap.yzw);\n\n   float fra =0.25*log(m)*sqrt(m)/dz;\n    \n    \n    float sdb1 =sdBox(p- vec3(0.0), vec3(0.3,1.0,1.0) );\n    \n    float res=999.9 ;\n    \n    float dif1= differenceSDF(sdb1,fra) ;\n    \n    res=min(res,dif1);\n    return res;\n}\n\nfloat intersect( in vec3 ro, in vec3 rd, out vec4 rescol, in float px )\n{\n    float res = -1.0;\n\n    // bounding sphere\n    vec2 dis = isphere( vec4(0.0,0.0,0.0,1.25), ro, rd );\n    if( dis.y<0.0 )\n        return -1.0;\n    dis.x = max( dis.x, 0.0 );\n    dis.y = min( dis.y, 10.0 );\n\n    // raymarch fractal distance field\n\tvec4 trap;\n\n\tfloat t = dis.x;\n\tfor( int i=0; i<128; i++  )\n    { \n        vec3 pos = ro + rd*t;\n        float th = 0.25*px*t;\n\t\tfloat h = map( pos, trap );\n\t\tif( t>dis.y || h<th ) break;\n        t += h;\n    }\n    \n    \n    if( t<dis.y )\n    {\n        rescol = trap;\n        res = t;\n    }\n\n    return res;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float k )\n{\n    float res = 1.0;\n    float t = 0.0;\n    for( int i=0; i<64; i++ )\n    {\n        vec4 kk;\n        float h = map(ro + rd*t, kk);\n        res = min( res, k*h/t );\n        if( res<0.001 ) break;\n        t += clamp( h, 0.01, 0.2 );\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos, in float t, in float px )\n{\n    vec4 tmp;\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.25*px;\n    return normalize( e.xyy*map( pos + e.xyy,tmp ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx,tmp ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy,tmp ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx,tmp ) );\n}\n\nconst vec3 light1 = vec3(  0.577, 0.577, -0.577 );\nconst vec3 light2 = vec3( -0.707, 0.500,  0.707 );\n\n\nvec3 render( in vec2 p, in mat4 cam )\n{\n\t// ray setup\n    const float fle = 1.5;\n\n    vec2  sp = (2.0*p-iResolution.xy) / iResolution.y;\n    float px = 2.0/(iResolution.y*fle);\n\n    vec3  ro = vec3( cam[0].w, cam[1].w, cam[2].w );\n\tvec3  rd = normalize( (cam*vec4(sp,fle,0.0)).xyz );\n\n    // intersect fractal\n\tvec4 tra;\n    float t = intersect( ro, rd, tra, px );\n    \n\tvec3 col;\n\n    // color sky\n    if( t<0.0 )\n    {\n     \tcol  = vec3(0.8,.9,1.1)*(0.6+0.4*rd.y);\n\t\tcol += 5.0*vec3(0.8,0.7,0.5)*pow( clamp(dot(rd,light1),0.0,1.0), 32.0 );\n\t}\n    // color fractal\n\telse\n\t{\n        // color\n        col = vec3(0.01);\n\t\tcol = mix( col, vec3(0.10,0.20,0.30), clamp(tra.y,0.0,1.0) );\n\t \tcol = mix( col, vec3(0.2,0.50,0.30), clamp(tra.z*tra.z,0.0,1.0) );\n        col = mix( col, vec3(0.30,0.10,0.2), clamp(pow(tra.w,6.0),0.0,1.0) );\n        col *= 0.5;\n\t\t//col = vec3(0.1);\n        \n        // lighting terms\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, t, px );\n        vec3 hal = normalize( light1-rd);\n        vec3 ref = reflect( rd, nor );\n        float occ = clamp(0.015*log(tra.x),0.0,1.0);\n        float fac = clamp(1.0+dot(rd,nor),0.0,1.0);\n\n        // sun\n        float sha1 = softshadow( pos+0.001*nor, light1, 32.0 );\n        float dif1 = clamp( dot( light1, nor ), 0.0, 1.0 )*sha1;\n        float spe1 = pow( clamp(dot(nor,hal),0.0,1.0), 32.0 )*dif1*(0.04+0.96*pow(clamp(1.0-dot(hal,light1),0.0,1.0),5.0));\n        // bounce\n        float dif2 = clamp( 0.5 + 0.5*dot( light2, nor ), 0.0, 1.0 )*occ;\n        // sky\n        float dif3 = (1.0+0.3*nor.y)*(0.2+0.8*occ);\n        \n\t\tvec3 lin = vec3(0.0); \n\t\t     lin += 7.0*vec3(1.50,1.10,0.70)*dif1;\n\t\t     lin += 4.0*vec3(0.25,0.20,0.15)*dif2;\n        \t lin += 1.5*vec3(0.10,0.20,0.30)*dif3;\n             lin += 2.5*vec3(0.35,0.30,0.25)*(0.05+0.95*occ); // ambient\n        \t lin += 4.0*fac*occ;                          // fake SSS\n\t\tcol *= lin;\n\t\tcol = pow( col, vec3(0.7,0.9,1.0) );                  // fake SSS\n        col += spe1*15.0;\n        //col += 8.0*vec3(0.8,0.9,1.0)*(0.2+0.8*occ)*(0.03+0.97*pow(fac,5.0))*smoothstep(0.0,0.1,ref.y )*softshadow( pos+0.01*nor, ref, 2.0 );\n        //col = vec3(occ*occ);\n    }\n\n    // gamma\n\tcol = sqrt( col );\n    \n    // vignette\n    col *= 1.0 - 0.05*length(sp);\n\n    return col;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime*.5;\n\n    // camera\n\tfloat di = 1.4+0.1*cos(.29*time);\n\tvec3  ro = di * vec3( cos(.33*time), 0.8*sin(.37*time), sin(.31*time) );\n\tvec3  ta = vec3(0.0,0.1,0.0);\n\tfloat cr = 0.5*cos(0.1*time);\n\n    // camera matrix\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cw = normalize(ta-ro);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv =          (cross(cu,cw));\n    mat4 cam = mat4( cu, ro.x, cv, ro.y, cw, ro.z, 0.0, 0.0, 0.0, 1.0 );\n\n\tvec3 col = render(  fragCoord, cam );\n    \n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdjyDh.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[520, 520, 555, 555, 579], [582, 597, 628, 628, 778], [781, 781, 829, 829, 862], [901, 901, 954, 954, 1161], [1194, 1194, 1237, 1237, 2016], [2018, 2018, 2091, 2091, 2648], [2650, 2650, 2706, 2706, 2980], [2982, 2982, 3039, 3039, 3270], [3376, 3376, 3415, 3429, 5678], [5684, 5684, 5741, 5741, 6270]], "test": "valid"}
{"id": "WdjyDz", "name": "Savukvartsia, komissario Palmu!", "author": "elefAntti", "description": "Wanted to play around with attenuation of light, ended up adding some refraction as well.\nThe code is hacky due to working late at night, but it gets the job done:)", "tags": ["refraction", "attenuation"], "likes": 4, "viewed": 66, "published": "Public", "date": "1586507474", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define GammaValue 0.5\n#define VignetteStrength 1.1\n#define FocalLength 2.0\n#define GroundHeight 4.0\n\nmat3 rot_y(float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return mat3(c, 0.0 , -s,\n              0.0, 1.0, 0.0,\n               s, 0.0, c);\n}\n\n//The distance field fot the diamond\nfloat diamond3( vec3 pos )\n{\n    float r = 2.0;\n    return max(\n        max(\n            max(\n                max(\n                    max(abs(pos.x), abs(pos.y))\n                    , abs(pos.z))\n                , abs(pos.x + pos.y))\n            , abs(pos.z + pos.y))\n        , abs(pos.x + pos.z)) / 2.0 - r;\n}\n\n//Distance between two skew lines\nfloat distBetweenLines(vec3 origin, vec3 dir, vec3 origin2, vec3 dir2)\n{\n    vec3 normal = normalize(cross(dir, dir2));\n    return abs(dot(normal, origin - origin2));\n}\n\n//Distance to a line from origin along a ray\nfloat distToLine(vec3 origin, vec3 dir, vec3 origin2, vec3 dir2)\n{\n    vec3 normal = normalize(cross(dir, dir2));\n    vec3 n2 = cross(dir2, normal);\n    return dot(origin2 - origin, n2) / dot(dir, n2);\n}\n\n//Laser brightness as a function of distance from surface\nfloat laserBrightness(float dist)\n{\n    return smoothstep(0.2, 0.1,dist);\n}\n\n//The distance field function\nfloat distModel(vec3 pos, float time)\n{\n    return min(diamond3(rot_y(time) * pos), -pos.y + GroundHeight);\n}\n\n//Computes the normal of the distance field \nvec3 normModel(vec3 pos, float time)\n{\n    float delta = 0.001;\n    return normalize(vec3(\n         distModel(pos + vec3(delta, 0.0, 0.0), time) - distModel(pos - vec3(delta, 0.0, 0.0), time),\n         distModel(pos + vec3(0.0, delta, 0.0), time) - distModel(pos - vec3(0.0, delta, 0.0), time),\n         distModel(pos + vec3(0.0, 0.0, delta), time) - distModel(pos - vec3(0.0, 0.0, delta), time)\n    ) / (2.0 * delta));\n}\n\nfloat castRay(vec3 pos, vec3 dir, float time, float mult)\n{\n    float totalDist = 0.0;\n    float distToSurface = distModel(pos, time) * mult;\n    \n    while(totalDist < 100.0)\n    {\n        totalDist += distToSurface + 0.01;\n        vec3 currentPos = pos + dir * totalDist;\n        distToSurface = distModel(currentPos, time) * mult;\n        \n        if(distToSurface < 0.00)\n        {\n        \ttotalDist += distToSurface;\n            return totalDist;\n        }\n    }\n    \n    return 100.0;\n}\n\nvec3 rtMain(in vec2 fragCoord, in float time)\n{\n    vec2 position = fragCoord * -2.0 + 1.0;\n    vec3 rayDir = normalize(vec3( position, FocalLength));\n    vec3 cameraPos = vec3( 0, -2.0, -30.0 );\n    vec3 lightPos = vec3(-3.784, -2.0, 3.26);\n    vec3 laserPos = vec3(-1.0, -1.0, 2.0);\n    vec3 laserLookAt = vec3(0.0, 0.0, 2.0);\n    vec3 laserDir = normalize(laserLookAt - laserPos);\n    vec3 laserColor = vec3(1.0, 0.01, 0.01);\n    //The attenuation of light within the diamond\n    float lightDecay = 0.4;\n    float refractiveIndex = 1.0/1.43;\n    //The attenuation of laser when ray is traversing through the diamond\n    float laserAttenuation = 0.7;\n\n    float laserHitDist = castRay(laserPos, laserDir, time, 1.0) ;\n    vec3 laserHitPos = laserPos + laserDir * (laserHitDist + 0.05);\n    vec3 normalAtLaserHit = normModel(laserHitPos, time);\n    vec3 refractedLaserDir = refract(laserDir, normalAtLaserHit, refractiveIndex);\n    \n    \n    float internalCastLen = castRay(laserHitPos, refractedLaserDir, time, -1.0);\n    vec3 laserExitPos = laserHitPos + refractedLaserDir * internalCastLen;\n    float laserInsideDist = length(laserExitPos - laserHitPos);\n    vec3 normalAtLaserExit = -normModel(laserExitPos, time);\n    vec3 laserExitDir = refract(refractedLaserDir, normalAtLaserExit, 1.0/refractiveIndex);    \n    \n    float distToSurface = castRay(cameraPos, rayDir, time, 1.0);\n    vec3 cameraRayEnter = cameraPos + rayDir * (distToSurface + 0.1);\n    float distInside = castRay(cameraRayEnter, rayDir, time, -1.0);\n    vec3 cameraRayExit = cameraRayEnter + rayDir * distInside;\n\n    \n    \n    vec3 frontNormal = normModel(cameraRayEnter, time);\n    vec3 backNormal = normModel(cameraRayExit, time);\n    vec3 lightDirFront = normalize(lightPos - cameraRayEnter);\n    vec3 lightDirBack = normalize(lightPos - cameraRayExit);\n    float shadeFront = max(0.0, dot(lightDirFront, frontNormal));\n    float shadeBack = max(0.0, -dot(lightDirBack, backNormal));\n\n    vec3 diamondColor = vec3(shadeBack) * exp(-lightDecay * distInside) + vec3(shadeFront);\n    \n    \n    //Background\n    diamondColor *= smoothstep(100.0, 80.0, distToSurface);\n        \n    float laserDist = distToLine(cameraPos, rayDir, laserPos, laserDir);    \n    float laserIntensity = 0.0; \n    \n    vec3 laserPoint = cameraPos + laserDist * rayDir;\n    float distanceToLaser = dot(laserDir, laserPoint - laserPos);\n    \n    if(distanceToLaser < laserHitDist)\n    {\n        //Ray hasn't yet hit the diamond\n        laserIntensity = laserBrightness(distBetweenLines(cameraPos, rayDir, laserPos, laserDir));\n    }\n    else\n    {\n        laserDist = distToLine(cameraPos, rayDir, laserHitPos, refractedLaserDir);\n        laserPoint = cameraPos + laserDist * rayDir;\n    \tfloat distanceToLaserEnter = dot(refractedLaserDir, laserPoint - laserHitPos);\n        \n        if(distanceToLaserEnter < laserInsideDist)\n        {\n            //Laser is inside the diamond\n            laserAttenuation *= exp(-lightDecay * (distanceToLaser - laserHitDist));\n            laserIntensity = laserBrightness(distBetweenLines(cameraPos, rayDir, laserHitPos, refractedLaserDir));\n        }\n        else\n        {\n            //Laser has exited the diamond\n            laserAttenuation *= exp(-lightDecay * laserInsideDist);\n            laserIntensity = laserBrightness(distBetweenLines(cameraPos, rayDir, laserExitPos, laserExitDir));\n            laserDist = distToLine(cameraPos, rayDir, laserExitPos, laserExitDir);\n            laserPoint = cameraPos + laserDist * rayDir;\n        }\n    }\n    \n    if(laserPoint.y > GroundHeight)\n    {\n        //Laser has entered the ground\n        laserAttenuation = 0.0;\n    }\n    \n    //The attenuation of laser when ray is returning through the diamond\n    float returnLaserAttenuation = 1.0;\n    if(laserDist < distToSurface)\n    {\n        //Laser seen in front of the diamond\n    }\n    else if(laserDist < (distToSurface + distInside))\n    {\n       //Laser seen inside the diamond\n       returnLaserAttenuation *= exp(-lightDecay * (laserDist - distToSurface));\n    }\n    else\n    {\n       //Laser seen behind the diamond\n       returnLaserAttenuation *=  exp(-lightDecay * distInside);\n    }\n    \n    //Add a laser dot to where the laser enters the diamond\n    float laserOnSurface =  (laserBrightness(length(laserHitPos - laserPoint)))\n        * abs(dot(frontNormal, -laserDir));\n    laserOnSurface += (laserBrightness(length(laserExitPos - laserPoint)))\n        * exp(-lightDecay * laserInsideDist)\n        * 2.0 //Hack to make it more visible\n        * abs(dot(backNormal, -refractedLaserDir));\n    \n    //If laser refracts back inside, there is no hitpoint on the ground plane\n    if(dot(refractedLaserDir, laserExitDir) > 0.0)\n    {\n       \tfloat distAfterExit = castRay(laserExitPos, laserExitDir, time, 1.0);\n    \tvec3 laserGroundPos = laserExitPos + laserExitDir * distAfterExit;\n        laserOnSurface += (laserBrightness(length(laserGroundPos - laserPoint)))\n            * exp(-lightDecay * laserInsideDist)\n            * 2.0 //Hack to make it more visible\n            * abs(dot(backNormal, -refractedLaserDir));        \n    }\n    \n    diamondColor += laserOnSurface * returnLaserAttenuation * laserColor;\n    \n    return diamondColor + laserIntensity * laserColor * laserAttenuation * returnLaserAttenuation;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.y/iResolution.x;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy - vec2(0.5f)) * vec2(1.0, aspect) + vec2(0.5);\n    // Time varying pixel color\n    vec3 color = rtMain(uv, iTime * 0.3);\n\n    //Gamma\n    color.rgb = pow(color.rgb, vec3(GammaValue));\n\n    //Saturate channels\n    color.rgb = min(color.rgb, vec3(1.0));\n\n    //Vignette\n    color.rgb *= pow(1.0 - length(uv - vec2(0.5, 0.5)) * VignetteStrength, 0.5); \n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdjyDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[102, 102, 127, 127, 271], [273, 310, 338, 338, 621], [623, 657, 729, 729, 825], [827, 872, 938, 938, 1075], [1077, 1135, 1170, 1170, 1210], [1212, 1242, 1281, 1281, 1351], [1353, 1398, 1436, 1436, 1819], [1821, 1821, 1880, 1880, 2314], [2316, 2316, 2363, 2363, 7629], [7631, 7631, 7688, 7688, 8240]], "test": "valid"}
{"id": "WdjyR1", "name": "Rotating pentagon", "author": "Whekin", "description": "No comments", "tags": ["pentagon"], "likes": 0, "viewed": 52, "published": "Public", "date": "1586106651", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n\n    float a = atan(uv.y, uv.x);\n    float smth = length(uv) * sin(a * 5.) - sin(a * 5. + iTime);\n    \n    float r = 0.2;\n    vec3 col = vec3(smoothstep(r, r + 0.02, smth));\n    // col = vec3(smth);\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdjyR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 356]], "test": "valid"}
{"id": "wdjyzh", "name": "the (2,3,infinity) tiling", "author": "sl2c", "description": "In the Poincare half-plane model, the symmetries are functions f(z)=(az+b)/(cz+d) where a,b,c,d are real numbers and ad-bc=1.  For this tiling, the symmetries are those functions where a,b,c,d are integers.  This animates (2z+1)/(z+1).", "tags": ["tiling", "hyperbolic", "poincare"], "likes": 5, "viewed": 72, "published": "Public", "date": "1587144577", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Copyright 2020 Google LLC\n// SPDX-License-Identifier: Apache-2.0\n// NOT an official Google project; see Google Open Source guidelines for more info on copyright transfer\n// written by William Cadegan-Schlieper \nvec3 color(vec2 z) {\n    bool fl = false;\n    float w = 0.0;\n    for(int i=0;i<60;i++) {\n        w += z.y;\n        w += abs(z.x);\n        z.x = fract(z.x);\n        if (z.x > 0.5) {\n            z.x = 1.0-z.x;\n            fl = !fl;\n        }\n        if (dot(z,z) < 1.0) {\n            z /= dot(z,z);\n            fl = !fl;\n            continue;\n        }\n        \n    }\n    float c = 0.5 - 40.0 / w;\n    if (fl) {\n        c = 1.0 - c;\n    }\n    return vec3(c,c,c);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * (fragCoord - iResolution.xy * 0.5)/iResolution.y;\n    \n    float r2 = dot(uv,uv);\n    if (r2 < 1.0) {\n        uv.y -= 1.0;\n        uv /= dot(uv,uv);\n        uv.y = -0.5 - uv.y;\n        \n        float t = 0.1 * iTime;\n        float period = 4.0 * log((1.0 + sqrt(5.0))*0.5);\n        t = mod(t,period) - period * 0.5;\n        uv *= exp(t);\n        \n        uv.x -= sqrt(0.2);\n        uv /= dot(uv,uv);\n        uv.x += 0.5 * (1.0 + sqrt(5.0));\n        //uv.x += 0.1 * iTime;\n        //uv.x = fract(uv.x);\n        fragColor = vec4(color(uv),1.0);\n    } else {\n        fragColor = vec4(0.5,1.0,0.5,1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdjyzh.jpg", "access": "shaders20k", "license": "apache-2.0", "functions": [[0, 214, 234, 234, 681], [683, 683, 740, 740, 1367]], "test": "valid"}
{"id": "Wdjyzm", "name": "Poincaré Disc Tilings", "author": "mla", "description": "The Poincaré disc model of 2d hyperbolic space. Lots of controls, see code header.\n\nInspired by discussion here: [url]https://www.shadertoy.com/view/3d2cz1[/url]", "tags": ["disc", "hyperbolic", "poincare"], "likes": 10, "viewed": 356, "published": "Public API", "date": "1586349483", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Tiling the Poincare Disc\n//\n// Construct 2,P,Q hyperbolic triangle, centred at the origin, with\n// sides on the x and y axes, and a circular side making angles PI/P\n// and PI/Q with the first two sides. Fold into triangle by iterated\n// reflection in its sides (so the triangle is a fundamental region\n// for the group of reflections). Show resulting tiling.\n//\n// Lots of options:\n// 1,2,3: show different edge types\n// c: clip to unit disc\n// h: halfplane\n// i: use ideal triangle (2,inf,inf)\n// m: mouse isometry\n// n: null rotation\n// p: progressive folding\n// t: show parity\n// z: exponential zoom out (halfplane only)\n//\n////////////////////////////////////////////////////////////////////////////////\n\nint P = 7, Q = 4; // Triangle is (2,P,Q) with 1/P + 1/Q < 1/2\n\nbool dotwotone = true;      // Show parity of fundamental regions\nbool doedge1 = true;        // Show x-axis edge\nbool doedge2 = true;        // Show y-axis edge\nbool doedge3 = true;        // Show circular edge\nbool donullrotation = true; // Do a \"null rotation\"\nbool domouse = true;        // Invert origin to mouse position\nbool dozoom = false;        // Zoom out, in halfplane mode only\nbool dohalfplane = false;   // Show the halfplane model, instead of the disc\nbool doideal = false;       // Use ideal (2,inf,inf) triangle instead of (2,P,Q)\nbool doprogressive = false; // Progressively increase max number of folds\nbool doclip = true;        // Clip to unit disc\n\nfloat PI = 3.141592654;\n\n// Compute parameters for hyperbolic triangle, with angles 2,a,b. You\n// might want to draw a picture for this. Triangle sides are x=0,y=0\n// and a circular arc, centre (x,y) and radius r (with r2 = r*r). The\n// arc needs to be a \"straight line\" in the disc model, which means it\n// must intersect the unit disc at right angles. This results in\n// condition (i) by Pythagoras' Theorem. The arc must intersect the\n// x-axis at angle a, and the y-axis at angle b, which give conditions\n// (ii) and (iii).\n\nvec4 solve(float a, float b) {\n  // (i) r^2 + 1 = x^2 + y^2 - condition to be orthogonal to unit circle\n  // (ii) r cos(a) = x => x = r/cos(a)\n  // (iii) r cos(b) = y => y = r/cos(b)\n  float r2 = 1.0/(cos(a)*cos(a) + cos(b)*cos(b) - 1.0);\n  float r = sqrt(r2);\n  float x = r*cos(a);\n  float y = r*cos(b);\n  return vec4(x,y,r,r2);\n}\n\nfloat ds;\nvec3 diagram(vec2 z, vec2 m) {\t\n    ds = max(1.0,abs(1.0-dot(z,z)));\n    ds /= (0.5*iResolution.y);\n  vec4 T = doideal ? solve(PI/3.0,0.0) : solve(PI/float(P),PI/float(Q));\n  if (dohalfplane) {\n    z.y += 1.0;\n    if (dozoom) z *= exp(0.41*iTime);\n    z.y += 1.0;\n    z *= 2.0/dot(z,z);\n    z.y -= 1.0;\n  }\n  // Map origin to m with an inversion\n  if (domouse && m != vec2(0)) {\n    float k = 1.0/dot(m,m);\n    vec2 c = k*m; // m inverted in unit circle\n    float t = (k-1.0)/dot(z-c,z-c);\n    z = t*z+(1.0-t)*c;\n    z.x = -z.x; // Keep chirality\n  }\n  if (doclip && dot(z,z) > 1.0) return vec3(0);\n  if (donullrotation) {\n    // Can't do this with an inversion, so map to halfplane, where\n    // it's just a  translation.\n    vec2 c = vec2(0,-1);\n    z -= c;\n    z *= 2.0/dot(z,z);\n    z.x += 0.2*iTime;\n    z *= 2.0/dot(z,z);\n    z += c;\n  }\n  vec2 a = T.xy; float r = T.z, r2 = T.w;\n  int nsteps = !doprogressive ? 50 : min(50,int(iTime));\n  int i, folds = 0;\n  for (i = 0; i < nsteps; i++) {\n    int folds1 = int(z.x < 0.0) + int(z.y < 0.0);\n    z = abs(z);\n    float k = dot(z-a,z-a);\n    if (k < r2) {\n      folds1++;\n      z = r2*(z-a)/k + a;\n    }\n    if (folds1 == 0) break;\n    folds += folds1;\n  }\n  if (i == nsteps) return vec3(0);\n  // We have now folded the original point z into the fundamental\n  // region, now draw whatever should be in there. Things get smaller\n  // as we move outwards in the disc, so need a scale factor.\n  float scalefactor = abs(1.0 - dot(z,z));\n  vec3 col = vec3(1,1,0);\n  // Euclidean distances to edge of fundamental regions\n  float d1 = abs(z.x);\n  float d2 = abs(z.y);\n  float d3 = abs(length(z-a)-r);\n    //ds = fwidth(length(z));\n  // Desired widths, appropriately scaled.\n  float ewidth = scalefactor*0.00+ds;\n  float lwidth = scalefactor*0.005;\n  if (dotwotone) {\n    // Keep Fabrice happy with a smooth blend between tiles\n    // This is easy with only two tile colours.\n    float d = min(min(d1,d2),d3);\n    col *= 0.5+0.5*smoothstep(-ewidth,+ewidth, folds%2 == 0 ? d : -d);\n  }\n  if (doedge1 || doedge2 || doedge3) {\n    // Draw the edges of the region, if desired.\n    float d = 1e8;\n    if (doedge1) d = min(d,d1);\n    if (doedge2) d = min(d,d2);\n    if (doedge3) d = min(d,d3);\n    // But make him unhappy with a pixel-independent minimum line width.\n    col = mix(vec3(0),col,smoothstep(0.5*lwidth,lwidth+2.0*ds,d));\n    //if (fwidth(length(z)) > 0.1) col = vec3(0);\n  }\n  return col;\n}\n\nbool key(int code) {\n  return texelFetch(iChannel0, ivec2(code,2),0).x != 0.0;\n}\n\nconst int CHAR_0 = 48;\nconst int CHAR_C = 67;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_P = 80;\nconst int CHAR_T = 84;\nconst int CHAR_Z = 90;\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n  dotwotone = dotwotone != key(CHAR_T);\n  doedge1 = doedge1 != key(CHAR_0+1);\n  doedge2 = doedge2 != key(CHAR_0+2);\n  doedge3 = doedge3 != key(CHAR_0+3);\n  donullrotation = donullrotation != key(CHAR_N); \n  domouse = domouse != key(CHAR_M); \n  dozoom = dozoom != key(CHAR_Z); // halfplane only\n  dohalfplane = dohalfplane != key(CHAR_H);\n  doideal = doideal != key(CHAR_I);\n  doprogressive = doprogressive != key(CHAR_P);\n  doclip = doclip != key(CHAR_C);\n  \n  vec2 p = vec2((2.0*fragCoord-iResolution.xy)/iResolution.y);\n  vec2 P = iMouse.x <= 0.0 ? vec2(0)\n    : vec2((2.0*iMouse.xy-iResolution.xy)/iResolution.y);\n  vec3 col = diagram(p,P);\n  fragColor = vec4(pow(col,vec3(0.4545)),1);\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wdjyzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2060, 2060, 2090, 2242, 2391], [2403, 2403, 2433, 2433, 4844], [4846, 4846, 4866, 4866, 4926], [5136, 5136, 5189, 5189, 5880]], "test": "error"}
{"id": "WdlBD8", "name": "Day11: Cubic Bezier", "author": "fluxatron", "description": "Just practicing some maths and having fun with shadertoy!\n\nI researched these cubic bezier functions about 3-4 years back and was surprised to find I could code this in an hour without looking anything up! Weird how the brain retains such random info.", "tags": ["cubicbezier"], "likes": 7, "viewed": 117, "published": "Public", "date": "1588154540", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// TYPES //////////////////////////////////////////////////////////////////////////////////\nstruct CubicBezierSegment\n{\n    vec2 A, B;   // Vertices A and B the line is drawn between\n\tvec2 CA, CB; // Control points for verts A/B control the shape\n};\n\nstruct BezierLook\n{\n    vec3 BezierCol;\n    vec3 HandleCol;\n    vec3 LineCol;\n    float BezierThicc;\n};\n    \nstruct Hit\n{\n    float Dist;\n    vec3 Col;\n};\n    \n\n// TRANSFORMATIONS ////////////////////////////////////////////////////////////////////////\nmat2 Rotate(float rads) \n{ \n    float s = sin(rads); \n    float c = cos(rads); \n    return mat2(c, s, \n               -s, c); \n}\n\n\n// SHAPES /////////////////////////////////////////////////////////////////////////////////\nfloat sdCircle(vec2 p, float r)\n{\n    return length(p) - r;\n}\nfloat sdLineSegment(vec2 p, vec2 a, vec2 b, float halfThicc)\n{\n    vec2 ap = p-a;\n    vec2 ab = b-a;\n    float h = clamp(dot(ap,ab)/dot(ab,ab), 0.0, 1.0); // project ap onto ab\n\treturn length( ap - ab*h ) - halfThicc; // finds length of vec from p to the projection of p onto ab\n}\n\nvec2 SampleBezier(CubicBezierSegment seg, float t)\n{\n    // First degree\n    vec2 p11 = mix(seg.A, seg.CA, t);\n    vec2 p12 = mix(seg.CA, seg.CB, t);\n    vec2 p13 = mix(seg.CB, seg.B, t);\n\n    // Second degree\n    vec2 p21 = mix(p11, p12, t);\n    vec2 p22 = mix(p12, p13, t);\n\n    // Third degree\n    return mix(p21, p22, t);\n}\n\n\n// SCENE  /////////////////////////////////////////////////////////////////////////////////\nHit Closest(Hit a, Hit b)\n{\n    // Not sure how to be more performance with this as the ternary operator doesn't support structs :|\n    if (a.Dist <= b.Dist) \n    \treturn a;\n    else\n        return b;\n}\n\nHit HitSegment(vec2 p, CubicBezierSegment seg, BezierLook look)\n{\n    const int subdivs = 30;\n    \n    Hit hit;\n    hit.Dist = 999999.;\n    Hit newHit;\n    \n      \n    // Vertices\n    newHit.Col = look.HandleCol;\n    //newHit.Dist = sdCircle(p-seg.A, 0.02); hit = Closest(hit, newHit);\n    //newHit.Dist = sdCircle(p-seg.B, 0.02); hit = Closest(hit, newHit);\n    \n    // Control Points\n    newHit.Col = look.HandleCol*0.75;\n    newHit.Dist = sdCircle(p-seg.CA, 0.025); hit = Closest(hit, newHit);\n    newHit.Dist = sdCircle(p-seg.CB, 0.025); hit = Closest(hit, newHit);\n\n    // Lines\n    newHit.Col = look.LineCol;\n    newHit.Dist = sdLineSegment(p, seg.A, seg.CA, 0.); hit = Closest(hit, newHit);\n    newHit.Dist = sdLineSegment(p, seg.B, seg.CB, 0.); hit = Closest(hit, newHit);\n    \n\t// Cubic Bezier\n    newHit.Col = look.BezierCol;\n    vec2 last = SampleBezier(seg, 0.);\n    for (int i = 1; i <= subdivs; i++)\n    {\n        float t = float(i)/float(subdivs);\n        vec2 s = SampleBezier(seg, t);\n        \n       \tnewHit.Dist = sdLineSegment(p, last, s, look.BezierThicc*0.5); hit = Closest(hit, newHit);\n        \n        last = s;\n    }\n    \n    return hit;\n}\n\nvec3 Scene(vec2 p, float aspect, vec2 mouse)\n{\n    BezierLook look;\n    look.BezierCol = vec3(0.8,0.2,0.4);\n    look.LineCol = vec3(1,1,1)*0.5;\n    look.HandleCol = vec3(1,1,1);\n    look.BezierThicc = 0.02;\n    \n    vec2 v1 = vec2(-.75, 0);\n    vec2 v2 = vec2(0, 0);\n    vec2 v3 = vec2(.75, 0);\n    \n    CubicBezierSegment seg1;\n    seg1.A  = v1;\n    seg1.B  = v2;\n    seg1.CA = mouse;//v1 + 0.7* vec2(sin(iTime*.75), cos(iTime*.75));\n    seg1.CB = v2 - 0.5* vec2(cos(iTime*1.4), sin(iTime*1.4+1.));\n    \n    CubicBezierSegment seg2;\n    seg2.A  = v2;\n    seg2.B  = v3;\n    seg2.CA = v2 + v2-seg1.CB;\n    seg2.CB = v3 + 0.7* vec2(sin(iTime*.75), -cos(iTime*.75));\n    \n    \n    Hit closest;\n    closest.Dist = 9999999.;\n    closest = Closest(closest, HitSegment(p, seg1, look));\n    closest = Closest(closest, HitSegment(p, seg2, look));\n    \n    return closest.Col * smoothstep(0.005,0.,closest.Dist);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float aspect = iResolution.x/iResolution.y;\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.yy; // -[aspect,1] to [aspect,1]\n    vec2 uvNorm = fragCoord/iResolution.xy; // [0,0] to [1,1]\n    vec2 mouse = (2.*iMouse.xy - iResolution.xy)/iResolution.yy;\n\n    vec3 col = vec3(0);\n    col = vec3(uvNorm,1) * 0.2;\n    col += Scene(uv, aspect, mouse);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdlBD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[413, 505, 531, 531, 633], [636, 728, 761, 761, 789], [790, 790, 852, 852, 1070], [1072, 1072, 1124, 1144, 1399], [1402, 1494, 1521, 1625, 1696], [1698, 1698, 1763, 1763, 2863], [2865, 2865, 2911, 2911, 3769], [3772, 3772, 3827, 3827, 4220]], "test": "valid"}
{"id": "WdlBR4", "name": "burning film?", "author": "mralvar", "description": "noisey color wave audio reactive thing.", "tags": ["reactive"], "likes": 1, "viewed": 88, "published": "Public", "date": "1587779460", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision lowp float;\n#endif\n\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\n\n\nvec3 cosPalette( float t, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d));\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 rs = vec2(uv.x-sin(iTime),uv.y+sin(iTime));\n    float r = random(rs);\n    float shape = sdBox(sin(iTime)-uv, vec2(-sin(uv.y),-sin(uv.y)));\n   \t\n    vec3 a = vec3(.1,.1,.1);\n    vec3 b = vec3(.5,.5,.5);\n    vec3 c = vec3(r, 1.0,0.0);\n    vec3 d = vec3(.5,.2,.25);\n    float s = texture(iChannel0,vec2(0.0,0.0)).x;\n    \n    vec3 color = cosPalette(cos(iTime-uv.y) + s,a,b,c,d);\n    vec3 final = (cos(shape-s) + color);\n    \n    fragColor = vec4(final,1.0);\n}", "image_inputs": [{"id": "lt2GDW", "previewfilepath": "https://soundcloud.com/noisey/regret", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/noisey/regret", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdlBR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[209, 209, 269, 269, 311], [313, 313, 350, 350, 434], [436, 436, 464, 464, 572], [737, 737, 792, 792, 1303]], "test": "error"}
{"id": "wdlBRn", "name": "Penumbra Shangru", "author": "pandaleo", "description": "hw9", "tags": ["cis561"], "likes": 0, "viewed": 48, "published": "Public", "date": "1587612605", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The larger the DISTORTION, the smaller the glow\nconst float DISTORTION = 0.2;\n// The higher GLOW is, the smaller the glow of the subsurface scattering\nconst float GLOW = 6.0;\n// The higher the BSSRDF_SCALE, the brighter the scattered light\nconst float BSSRDF_SCALE = 3.0;\n// Boost the shadowed areas in the subsurface glow with this\nconst float AMBIENT = 0.0;\n// Toggle this to affect how easily the subsurface glow propagates through an object\n\n\nfloat subsurface(vec3 lightDir, vec3 normal, vec3 viewVec, float thickness) {\n    vec3 scatteredLightDir = lightDir + normal * DISTORTION;\n    float lightReachingEye = pow(clamp(dot(viewVec, -scatteredLightDir), 0.0, 1.0), GLOW) * BSSRDF_SCALE;\n    float attenuation = 1.0;\n\tfloat totalLight = attenuation * (lightReachingEye + AMBIENT) * thickness;\n    return totalLight;\n}\nmat3 rotateY(float rad)\n{\n    return mat3(vec3(cos(rad), 0, -sin(rad)),\n                vec3(0, 1, 0),\n                vec3(sin(rad), 0, cos(rad))\n               );\n}\nmat3 rotateZ(float rad)\n{\n    return mat3(vec3(cos(rad), -sin(rad), 0),\n                vec3(sin(rad), cos(rad), 0),\n                vec3(0, 0, 1)\n               );\n}\nmat3 rotateX(float rad)\n{\n    return mat3(vec3(1, 0, 0),\n        \t\tvec3(0, cos(rad), -sin(rad)),\n                vec3(0, sin(rad), cos(rad))\n               );\n}\nmat3 scale(float a, float b, float c)\n{\n    return mat3(vec3(a, 0, 0), vec3(0, b, 0), vec3(0, 0, c));\n}\nmat3 scale(float a)\n{\n    return scale(a, a, a);\n}\nfloat sdfBox(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.) + length(max(d, 0.));\n}\nfloat sdfSphere(vec3 p)\n{\n    return length(p) - 0.5;\n}\nfloat sdfPlane(vec3 p)\n{\n    return dot(p, vec3(0, 0, 1));\n}\nvec2 closer(vec2 a, vec2 b)\n{\n    return a.x < b.x ? a: b;\n}\nfloat deg2rad(float r)\n{\n\treturn r / 180. * 3.14159;\n}\nvec2 map(vec3 pos) // find closest object\n{\n    vec3 sphereWorld = vec3(0.3, 0.3, -0.4);\n    vec3 posSphereModel = pos - sphereWorld; // position in sphere model space\n    vec2 sphereInfo = vec2(sdfSphere(posSphereModel), 1.);\n    \n    vec3 boxWorld = vec3(-0.35, -0.6, 0.3);\n    vec3 posBoxModel = inverse(rotateY(deg2rad(35.))) * (pos - boxWorld);\n    vec3 boxSize = vec3(0.2, 0.4, 0.2);\n    vec2 boxInfo = vec2(sdfBox(posBoxModel, boxSize), 2.);\n    \n    vec3 boxWorld2 = vec3(0.35, -0.8, 0.3);\n    vec3 posBoxModel2 = inverse(rotateY(deg2rad(60.))) * (pos - boxWorld2);\n    vec3 boxSize2 = vec3(0.22, 0.22, 0.22);\n    vec2 boxInfo2 = vec2(sdfBox(posBoxModel2, boxSize2), 8.);\n    \n    vec3 planeWorld1 = vec3(-1, 0, 0);\n    vec3 posPlaneModel1 = inverse(rotateY(3.14 / 2.)) * (pos - planeWorld1);\n    vec2 planeInfo1 = vec2(sdfPlane(posPlaneModel1), 3.);\n    \n    vec3 planeWorld2 = vec3(1, 0, 0);\n    vec3 posPlaneModel2 = inverse(rotateY(3. * 3.14 / 2.)) * (pos - planeWorld2);\n    vec2 planeInfo2 = vec2(sdfPlane(posPlaneModel2), 4.);\n    \n    vec3 planeWorld3 = vec3(0, 0, 0);\n    vec3 posPlaneModel3 = (pos - planeWorld3);\n    vec2 planeInfo3 = vec2(sdfPlane(posPlaneModel3), 5.);\n    \n    vec3 planeWorld4 = vec3(0, 1, 0);\n    vec3 posPlaneModel4 = inverse(rotateX(3. * 3.14 / 2.)) * (pos - planeWorld4);\n    vec2 planeInfo4 = vec2(sdfPlane(posPlaneModel4), 6.);\n    \n    vec3 planeWorld5 = vec3(0, -1, 0);\n    vec3 posPlaneModel5 = inverse(rotateX(3.14 / 2.)) * (pos - planeWorld5);\n    vec2 planeInfo5 = vec2(sdfPlane(posPlaneModel5), 7.);\n    \n    vec2 closest;\n    closest = closer(boxInfo, planeInfo1);\n    closest = closer(closest, planeInfo2);\n    closest = closer(closest, planeInfo3);\n    closest = closer(closest, planeInfo4);\n    closest = closer(closest, planeInfo5);\n    closest = closer(closest, boxInfo2);\n    return closest;\n}\nfloat fiveTapAO(vec3 p, vec3 n, float k) {\n    float aoSum = 0.0;\n    for(float i = 0.0; i < 5.0; ++i) {\n        float coeff = 1.0 / pow(2.0, i);\n        aoSum += coeff * (i * 0.15 - map(p + n * i * 0.15).x);\n    }\n    return 1.0 - k * aoSum;\n}\nvec2 calcIntersection(in vec3 ro, in vec3 rd){\n    float currentMinSdf = 0.002;\n    float t = 0.0; // distance from ro (ray origin)\n\tfloat resDistance = -1.;\n    float id = -1.;\n    for (int i = 0; i < 100; ++i){\n        if (currentMinSdf < 0.001 || t > 10.) break; // hit or exceed max distance\n\t   \tvec2 hitInfo = map(ro + rd * t); // hit object distance and id\n        currentMinSdf = hitInfo.x; // distance\n        t += currentMinSdf; // update current distance from ro\n        id = hitInfo.y;\n    }\n    if (t <= 10.) resDistance = t; // if in distance\n    else id = -1.; // no hit\n    return vec2(resDistance, id);\n}\nvec3 calcNormal(in vec3 pos){\n    \n\tvec3 dx = vec3(0.001, 0.0, 0.0);    \n\tvec3 dy = vec3(0.0, 0.001, 0.0);    \n\tvec3 dz = vec3(0.0, 0.0, 0.001);\n\tvec3 nor = vec3(\n\t    map(pos + dx).x - map(pos - dx).x,\n\t    map(pos + dy).x - map(pos - dy).x,\n\t    map(pos + dz).x - map(pos - dz).x\n    );\n\treturn normalize(nor);\n}\nconst float SHADOW_HARDNESS = 10.0;\nfloat softShadow(vec3 lightPos, vec3 origin, float min_t, float k) {\n    vec3 dir = normalize(lightPos - origin);\n    float dist = length(lightPos - origin);\n    float res = 1.0;\n    float t = min_t;\n    for(int i = 0; i < 1000; ++i) {\n        vec2 mapRes = map(origin + t * dir);\n        float m = mapRes.x;\n        if(m < 0.0001) {\n            return 0.;\n        }\n        res = min(res, k * m / t);\n        t += m;\n        if (t > dist) break;\n    }\n    return res;\n}\nvec3 render(vec2 res, in vec3 ro, in vec3 rd)\n{\n    float ambient = 0.05;\n    vec3 color = vec3(0);\n    float lightX = 0.5 * sin(iTime * 4.);\n    vec3 lightPos = vec3(lightX, 0.8, 0.8);\n    if (res.y > 0.) // id\n    {\n    \tvec3 pos = ro + rd * res.x;\n    \tvec3 norm = calcNormal(pos);\n    \tvec3 lightDir = normalize(lightPos - pos);\n        float match = max(0., dot(lightDir, norm) / pow(length(lightPos - pos), 0.3));\n        float ao = fiveTapAO(pos, norm, 2.);\n        vec3 view = ro - pos;\n        if (res.y == 1.) color = subsurface(-lightDir, norm, view, ao) * vec3(1., 1., 0.) * match + ambient;\n        else if (res.y == 2.) color = softShadow(lightPos, pos, 0.1, SHADOW_HARDNESS) * subsurface(-lightDir, norm, view, ao) * vec3(1., 0.8, 0.4) * match + ambient;\n\t\telse if (res.y == 3.) color = softShadow(lightPos, pos, 0.1, SHADOW_HARDNESS) * ao * vec3(1, 0, 0) * match + ambient;\n        else if (res.y == 4.) color = softShadow(lightPos, pos, 0.1, SHADOW_HARDNESS) * ao * vec3(0, 1, 0) * match + ambient;\n\t\telse if (res.y == 5.) color = softShadow(lightPos, pos, 0.1, SHADOW_HARDNESS) * ao * vec3(1, 1, 1) * match + ambient;   \n        else if (res.y == 6.) color = softShadow(lightPos, pos, 0.1, SHADOW_HARDNESS) * ao * vec3(0.5, 0.5, 0.5) * match + ambient;\n\t\telse if (res.y == 7.) color = softShadow(lightPos, pos, 0.1, SHADOW_HARDNESS) * ao * vec3(1, 1, 0.8) * match + ambient;  \n\t\telse if (res.y == 8.) color = softShadow(lightPos, pos, 0.1, SHADOW_HARDNESS) * subsurface(-lightDir, norm, view, ao) * vec3(0.4, 0.4, 1) * match + ambient;   \n    }\n    return color;\n}\nmat3 lookAt(in vec3 eye, in vec3 ref)\n{\n    vec3 front = normalize(ref - eye);\n    vec3 right = normalize(cross(front, vec3(0, 1, 0)));\n    vec3 up = normalize(cross(right, front));\n    return mat3(right, up, front);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n    vec3 eye = vec3(0, 0, 2), ref = vec3(0, 0, 0);\n    vec3 direction = normalize(lookAt(eye, ref) * vec3(p.xy, 1));\n    vec2 res = calcIntersection(eye, direction);\n    fragColor = vec4(render(res, eye, direction), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdlBRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[450, 450, 527, 527, 824], [825, 825, 850, 850, 991], [992, 992, 1017, 1017, 1158], [1159, 1159, 1184, 1184, 1319], [1320, 1320, 1359, 1359, 1423], [1424, 1424, 1445, 1445, 1474], [1475, 1475, 1505, 1505, 1598], [1599, 1599, 1624, 1624, 1654], [1655, 1655, 1679, 1679, 1715], [1716, 1716, 1745, 1745, 1776], [1777, 1777, 1801, 1801, 1831], [1832, 1832, 1875, 1875, 3684], [3685, 3685, 3727, 3727, 3929], [3930, 3930, 3976, 3976, 4551], [4552, 4552, 4581, 4581, 4866], [4903, 4903, 4971, 4971, 5373], [5374, 5374, 5421, 5421, 6956], [6957, 6957, 6996, 6996, 7175], [7176, 7176, 7233, 7233, 7522]], "test": "error"}
{"id": "WdlcDX", "name": "Day 104", "author": "jeyko", "description": "potato", "tags": ["mograph", "motiongraphics", "mdtmjvm"], "likes": 10, "viewed": 338, "published": "Public API", "date": "1585738205", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// USING YX/LUNA'S AWESOME DITHERED MOTION BLUR - https://www.shadertoy.com/view/wsfcWX\n// I modified it to not be framerate dependent like the original.\n\n\n\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\n#define timeStep (1./30.)\n#define motionBlurSteps 100\n\n\nfloat bayer8(ivec2 uv)\n{   \n    uv %= 8;\n\treturn texelFetch(iChannel1,uv,0).r;\n}\n\n\n// from https://necessarydisorder.wordpress.com/\nfloat ease(float p, float g) {\n    if(p < 0.){\n        return 0.;\n    } else if(p > 1.){\n    \treturn 1.;\n    } else {\n        if (p < 0.5) \n            return 0.5 * pow(2.*p, g);\n        else\n            return 1. - 0.5 * pow(2.*(1. - p), g);\n    }\n}\n\nfloat ease(float p, float power, float jump, float offs, float end) {\n    float j = p;\n    p *= offs;\n    float r = (1.-cos(pi*p))/2.*jump;\n    r = pow(r, power);\n    r = mix(r, 1., pow(smoothstep(0.,1.,j),end));\n\treturn r;\n}\nfloat smease(float p, float g) {\n    float s = p;\n    for(float i = 0.; i < g; i++){\n    \ts = smoothstep(0.,1.,s);\n    }\n    return s;\n}\n\n\nfloat sdBox(vec2 p, vec2 s){\n\tp = abs(p) - s;\n\treturn max(p.x, p.y);\n}\nfloat sdCirc(vec2 p, float s){\n    return length(p) - s;\n}\n\nfloat sdEquilateralTriangle(  vec2 p, float s )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - s;\n    p.y = p.y + s/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d = -length(p)*sign(p.y);\n    \n    d = abs(d) - 0.001;\n    return d;\n}\nconst float speed = 0.44;\nfloat[] scenes = float[3](2.*speed,1.7*speed, 0.6*speed); \n\nconst float W = 0.4;\nconst float dotW = 0.05;\nconst float triS = W*0.85;\n\nvec3 get( vec2 uv, float t  )\n{\n    uv *= 2.;\n    float col = 0.;\n    \n    float d = 10e6;\n    \n    float bA;\n    float bB;\n    float bC;\n    float bD;\n    float bE;\n    \n    float pl;\n    \n    \n    //t += scenes[0];\n    //t += scenes[1] - 0.1;\n    //t += scenes[2] - 0.1;\n    t = mod(t, scenes[0] + scenes[1] /* + scenes[2]*/  );\n    \n    \n    \n    if(t < scenes[0]){\n        float lsp = 1.3;\n        float env = ease(t/scenes[0]*lsp, 1., 1.05, 0.98, 1.);  \n        \n        \n        d = min(d, sdCirc(uv - vec2(0,1)*W, dotW));\n        d = min(d, sdCirc(uv - vec2(sin(tau*1./3.),cos(tau*1./3.))*W, dotW));\n        d = min(d, sdCirc(uv - vec2(sin(tau*2./3.),cos(tau*2./3.))*W, dotW));\n        \n        d = 10e6;\n        for(float i = 1.; i < 4.; i++){\n        \n        }\n        \n        vec2 uvo = uv;\n        uv.y += W;\n        uv *= rot(tau/2.);\n        uv *= rot(tau*1./3.);\n        uv.y -= W;\n        uv *= rot(env*pi*4./3.);\n        uv.y += W;\n        \n        d = min(d,  sdEquilateralTriangle( uv, triS ));\n        \n        uv = uvo;\n        uv *= rot(tau/3.);\n        uv *= rot(tau*2./3.);\n        uv.y -= W;\n        uv *= rot(env*pi*4./3. + pi/3.);\n        uv.y += W;\n        d = min(d,  sdEquilateralTriangle( uv, triS ));\n        \n        uv = uvo;\n        uv *= rot(tau*3.);\n        uv *= rot(tau*1./3.);\n        uv.y -= W;\n        uv *= rot(env*pi*4./3. + pi/3.);\n        uv.y += W;\n        d = min(d,  sdEquilateralTriangle( uv, triS ));\n        \n    } else if(t < scenes[1] + scenes[0]){\n        t -= scenes[0];\n        \n        float lsp = 1.8;\n        float env = ease(t/scenes[1]*lsp, 1., 1.14, 0.96, 10.)*smoothstep(1.,0.,t/scenes[1]*lsp);\n\n        float mov = env*0.3;\n        \n        d = min(d, sdCirc(uv - vec2(0,1)*W, dotW));\n        d = min(d, sdCirc(uv - vec2(sin(tau*1./3.),cos(tau*1./3.))*W, dotW));\n        d = min(d, sdCirc(uv - vec2(sin(tau*2./3.),cos(tau*2./3.))*W, dotW));\n        \n        d = 10e6;\n        \n        vec2 uvo = uv;\n        uv.y += W;\n        \n        \n        uv.y += mov;\n        uv *= rot(tau/2.);\n        uv *= rot(tau*1./3.);\n        d = min(d,  sdEquilateralTriangle( uv, triS ));\n        \n        uv = uvo;\n        uv *= rot(tau/3.);\n        uv.y += mov;\n        uv *= rot(tau*2./3.);\n        uv.y -= W;\n        uv *= rot(pi/3.);\n        uv.y += W;\n        d = min(d,  sdEquilateralTriangle( uv, triS ));\n        \n        uv = uvo;\n        uv *= rot(tau*1./3.);\n        uv.y -= W;\n        uv *= rot(pi/3.);\n        uv.y += mov*0.5;\n        uv.x += mov;\n        uv.y += W;\n        d = min(d,  sdEquilateralTriangle( uv, triS ));\n                \n        \n    }  \n    \n    return vec3(d);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;  \n    vec3 col = vec3(0);\n    \n    float edge = dFdx(uv.x)*1.;\n    \n    for (int i = 0; i < motionBlurSteps + min(iFrame,0); ++i) {\n        float subsample = bayer8(ivec2(fragCoord));\n        float time = iTime + ((float(i)+subsample)/float(motionBlurSteps)-.5) * timeStep;\n        col += smoothstep(-edge,edge,-get(uv,time));\n    }\n    col/=float(motionBlurSteps);\n    \n    col = clamp(col, 0., 1.);\n    col *= 0.999;\n    \n    col *= max((1. + 1.*cos(sin(0.25*tau*iTime/(scenes[0] + scenes[1] ))*tau+length(uv)*2.+vec3(4,2.5,1.5)))*1., 0.);\n    //col *= max((1.5 + 1.4*cos(iTime+length(uv)*2.+vec3(1,1.5,1.5)))*1., 0.);\n    \n    col *= 1. - pow(smoothstep(0.,1.,dot(uv,uv)*0.9),0.9)*1.;\n    \n    col = pow(col, vec3(0.454545));\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}, {"id": "4dXGR8", "previewfilepath": "/media/previz/buffer00.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/previz/buffer00.png", "ctype": "buffer"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdlcDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[306, 306, 330, 330, 386], [389, 438, 468, 468, 688], [690, 690, 759, 759, 915], [916, 916, 948, 948, 1052], [1055, 1055, 1083, 1083, 1125], [1126, 1126, 1156, 1156, 1184], [1186, 1186, 1235, 1235, 1488], [1649, 1649, 1680, 1680, 4294]], "test": "error"}
{"id": "WdlcWs", "name": "logistic_difference_v0012", "author": "darkczar", "description": "psychedelic", "tags": ["trippy"], "likes": 2, "viewed": 65, "published": "Public", "date": "1585856405", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// based on...\n// https://www.shadertoy.com/view/lssfW2\n\nfloat nsin(float x)\n{\n    return .5+.5*sin(x);\n}\nfloat ncos(float x)\n{\n    return .5+.5*cos(x);\n}\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}  //https://gist.github.com/companje/29408948f1e8be54dd5733a74ca49bb9\n\nhighp float rand(vec2 co)  //from stackoverflow\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nuint hash( uint x ) {  //http://amindforeverprogramming.blogspot.com/2013/07/random-floats-in-glsl-330.html\n\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\nfloat random( float f ) {  //http://amindforeverprogramming.blogspot.com/2013/07/random-floats-in-glsl-330.html\n\n    const uint mantissaMask = 0x007FFFFFu;\n    const uint one          = 0x3F800000u;\n   \n    uint h = hash( floatBitsToUint( f ) );\n    h &= mantissaMask;\n    h |= one;\n    \n    float  r2 = uintBitsToFloat( h );\n    return r2 - 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float r = 0.0;\n    float g = 0.0;\n    float b = 0.0;\n    vec2 xy0 = vec2(0.,0.);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p=(fragCoord.xy-iResolution.xy)/iResolution.y;\n    \n    vec2 xy = vec2(0.,0.);\n    float rr = .35*(nsin(.15*iTime))+3.55; // + .5*nsin(iTime*.5); //2.57 +nsin(iTime); //+cos(iTime);\n    xy = uv;\n    for (int i = 0; i<8; i++)\n    {\n        xy = rr*xy*(vec2(1.0,1.0)-xy);\n        if(i==0)\n        {\n          xy0 = xy;  \n        }\n        if (i>0)\n            {\n                if(abs(length(xy) - length(xy0)) < .005 +.02*ncos(iTime*.15)) // try and tease out the cycles and color them\n                {\n                    r = 1.*random(float(mod(float(i),7.0)));\n                    g = 1.*random(1.8+float(mod(float(i),7.0)));\n                    b = 1.*random((1.30 - float(mod(float(i),7.0))));\n                }\n            }\n        if(i>6)\n        {\n            r=0.;\n            g=0.;\n            b=0.;\n        }\n    }\n    if (length(xy) > .25+1.0*sin(iTime*.15))\n    {\n        r = 1.0 - mod(length(xy),2.);\n        g = 0.2*pow(dot(normalize(xy),normalize(xy0)),4.0);\n        b = min(1.0,mod(2.,length(xy)));\n    }\n    if (dot(xy,xy0) > 1.150 +.05*nsin(iTime*.3))\n    {\n        r = pow(ncos(iTime*2.5),.5);\n        g = 2.0/dot(xy,xy0);\n        b = 1.0 - g;\n    }\n    if (dot(xy,xy0) < 1.05*nsin(iTime*.3))\n    {\n        r = 1.0 - pow(ncos(iTime*.3),.5);\n        g = 1.0 - 1.05/dot(xy,xy0);\n        b = 1.0 - pow(length(xy),4.);\n    }        \n        //m = (rand_point.x-prev_point.x) / ((rand_point.y-prev_point.y);\n        //line_y = m*p.x +  \n\n\n    \n    vec3 col = vec3(r, g, b);\n    float dn = col.x + col.y + col.z;\n    col /= dn;\n    // Output to screen\n    //fragColor = vec4(col,1.0);\n    fragColor = vec4( pow(col,vec3(1./2.2)),1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdlcWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 79, 79, 106], [107, 107, 128, 128, 155], [156, 156, 228, 228, 294], [615, 615, 636, 722, 854], [855, 855, 880, 966, 1203], [1205, 1205, 1262, 1262, 3098]], "test": "valid"}
{"id": "WdlcWX", "name": "_2020_", "author": "Kapsy", "description": "Demo or die!", "tags": ["kapsy"], "likes": 2, "viewed": 101, "published": "Public", "date": "1585727757", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"Abstractionz\" by Kapsy. https://shadertoy.com/view/3slyWX\n// 2020-04-01 04:54:09\n\n\n#define time iTime*0.3\n#define PI 3.145926\nmat2 rot(float a){return mat2(sin(a),cos(a),-cos(a),sin(a));}\nfloat k,room,front;\n\nvec3 smin(vec3 a, vec3 b, float h){\n  vec3 k = clamp((a-b)/h*0.5+0.5,0.,1.);\n  return mix(a,b,k)-k*(1.-k)*h;\n  }\n \n  \nfloat smin(float a, float b, float h){\n  float k = clamp((a-b)/h*0.5+0.5,0.,1.);\n  return mix(a,b,k)-k*(1.-k)*h;\n  }\n\n  \nvec2 moda(vec3 p, float per){\n   float a = atan(p.x,p.y);\n   a = mod(a-per,per)-per*0.5;\n   float l = length(p)-0.;\n   return vec2(cos(a),sin(a))*l;\n   }\n\n\nfloat kali(vec3 p){\n  p = mod(p,vec3(0.,8.,10.))-vec3(0.,8.,10.)*0.5;\n  for(int i=0; i<8; ++i){\n    p.zx*=rot(sin(0.9));\n    p.zy*=rot(time*float(i)+3.145926);\n    p =  smin(p,-p,-0.2);\n    p.x -= 0.4;\n    }\n  return length(p)-0.8;\n}\n\nfloat box(vec3 p, vec3 b){\n  p=abs(p)-b;\n  return max(p.x,max(p.y,p.z));\n  }\n  //rama start\n  float up,down,left,right;\n \nfloat rama_up(vec3 p){\n   p = mod(p,vec3(0.,0.,0.))-vec3(0.,0.,0.)*0.5;\n   up = box(p+vec3(0,0.,0.),vec3(2.5+(abs(p.x)*p.y),0.4,1.));\n   return up;\n   }\n   \nfloat rama_down(vec3 p){\n   p.zy*=rot(2.3);   \n   down = box(p+vec3(0,0.,0.),vec3(2.5-(abs(p.x)*p.y),0.4,1.));\n   return down;\n   }\n   \nfloat rama_left(vec3 p,vec2 uv){\n   p.zx*=rot(time*7.5);\n   p = mod(p,vec3(0.,0.,0.))-vec3(0.,0.,0.)*0.5;\n   if(uv.x>0. && uv.x<0.5 || (uv.x>-9. && uv.x<-0.5) ){\n      left = box(p+vec3(0.,0.,0.),vec3(0.4,1.7+(p.x*abs(p.y)),1.));}\n   else  left = box(p+vec3(0.,0.,0.),vec3(0.4,3.5+(p.x*abs(p.y)),1.));\n   return left;\n   }\n   \nfloat rama_right(vec3 p){\n   p.xz*=rot(time*7.5);    \n   right = box(p+vec3(0.,0.,0.),vec3(0.4,3.5-(p.x*abs(p.y)),1.));\n   return right;\n   }\n //rama end \nfloat sdBox( vec3 p, vec3 b ){\n  vec3 q = vec3(abs(p.x),min((p.y-p.x)-10.,(p.y+p.x)-10.)+18.3,p.z) - vec3(b.x,b.y,b.z);\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n  }\n\nfloat shader(vec3 p, vec2 uv){\n   vec3 pp2 = p;\n   vec3 pp =p;\n   p.z-=15.5;\n  \nfloat k2 = kali(p); \n   k=kali(mod(p-vec3(0.,0.,0.),vec3(5.6,0.,20.))-vec3(5.6,0.,20.)*0.5);;\n   float rd = rama_up(p+vec3(0.,-3.8,5));\n   float ru = rama_down(p+vec3(0.,4.8,5));\n   float rl;\n   if((uv.x>0.&& uv.x<0.5) || (uv.x>-9. && uv.x<-0.5)) rl = rama_left(p+vec3(6.9+(p.x-p.y),0,8),uv);\n   else  rl = rama_left(p+vec3(-2.9,0.,5),uv);\n   float rr = rama_right(p+vec3(2.9,0.,5));\n   \nfloat rama;\n   float room = -sdBox(pp+vec3(0.,0.,0),vec3(10,10,38));\n   if(uv.x>0. && uv.x<0.5 || (uv.x>-9. && uv.x<-0.5) )rama = min(rl,min(ru,rd));\n   else rama = min(min(rl,rr),min(ru,rd));\n    \n   float alls = min(rama,min(room,k));\n   front = length(vec3(pp2)+vec3(0.,-2.,6))-mix(0.5,0.7,sin(time));\n   float alls2 = min(alls,front);\n   float change = (front>k)? room : room;\n   float smena = min(change,front);\n   return alls2;\n   }\n\nfloat SDF(vec3 p, vec2 uv){\n   return shader(p, uv);\n   }\n\nvoid mainImage( out vec4 out_color, in vec2 fragCoord ){\n  vec2 uv = fragCoord/iResolution.xy;\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  vec2 uv3 = uv;\n  vec2  uv2=fract(uv*2.)-0.5; \n  if(uv.y>0.) uv = uv2;\n  else uv=fract(-uv*2.)-0.5;\n  \n  vec3 ro = vec3(0.001,0.001, -10.); vec3 p = ro;\n  vec3 rd = normalize(vec3(-uv,1.));\n  float dd = 0.;\n  vec3 col = vec3(0.);\n  for(int i =0; i<100; ++i){\n    float d = SDF(p, uv3);\n    if(d<0.001) {break;}\n    if(dd>100.) {dd=100.; break;}\n    p+=d*rd;\n    dd+=d;\n     }\n  vec2 eps = vec2(0.001, 0.);\n  vec3 n = normalize(SDF(p,uv3)-vec3(SDF(p-eps.xyy,uv3),SDF(p-eps.yxy,uv3),SDF(p-eps.yyx,uv3)));\n  vec3 l = normalize(-vec3(3.,5.,3.));\n  float fog = 1.-clamp(dd/100.,0.6,1.);\n  col+=max(0.,dot(n,l))*vec3(1.,0.6,0.)*fog;\n  vec3 h = normalize(vec3(l-rd));\n  if(k<1.1) col+=vec3(-1.,0.,1.)*vec3(0.5,-0.,5.)+pow(max(0.,dot(n,h)),30.)*pow(max(0.,dot(n,h)),5.)*fog;\n  if(room<=15.6) col+=vec3(1.5,10.,-1.)*vec3(10.,0.3,-1.0)*pow(max(0.,dot(n,h)),4.)*pow(max(0.,dot(n,h)),13.)*fog;\n  if(front<=15.6) col+=vec3(0.,10.,-0.)*vec3(0.,30.3,.0)*pow(max(0.,dot(n,h)),20.)+pow(max(0.,dot(n,h)),3.)*fog;\n  if(right<=0.1 || left<=0.1 || up<=0.1 || down <=0.1) col=vec3(.6,0.,0.2)*vec3(0.,0.2,-10.)+pow(max(0.,dot(n,h)),10.)+pow(max(0.,dot(n,h)),3.);\n  vec3 col2 = exp(-col*5.);\n  col*=smoothstep(0.1,0.9,length(abs(uv.x*5.)-2.4));\n  col2*=smoothstep(0.1,0.9,length(abs(uv.x*5.)-2.4));\n  if(floor(mod(time,2.))!=0.){ \n     out_color = vec4(sqrt(col),1.);}\n  else out_color = vec4(sqrt(col2),1.);\n  }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdlcWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[138, 138, 156, 156, 199], [221, 221, 256, 256, 333], [339, 339, 377, 377, 455], [460, 460, 489, 489, 613], [616, 616, 635, 635, 849], [851, 851, 877, 877, 927], [973, 973, 995, 995, 1125], [1130, 1130, 1154, 1154, 1261], [1266, 1266, 1298, 1298, 1588], [1593, 1593, 1618, 1618, 1734], [1736, 1748, 1778, 1778, 1933], [1935, 1935, 1965, 1965, 2841], [2843, 2843, 2870, 2870, 2900], [2902, 2902, 2958, 2958, 4447]], "test": "valid"}
{"id": "WdlfR4", "name": "Flowing Marbled Fractal", "author": "jarble", "description": "Here's another edit of my \"[url=https://www.shadertoy.com/view/wsSyWV]Ink-Marbling Fractal[/url].\"", "tags": ["fractal", "psychedelic", "marbling"], "likes": 1, "viewed": 215, "published": "Public API", "date": "1587787978", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//This parameter changes the number of iterations.\nconst float mag = 9.0;\nconst float GREEN = 0.;\nconst float BLUE = 1.;\nconst float GRAY = 2.;\nconst float YELLOW = 3.;\nconst float WHITE = 4.;\nconst float RED = 5.;\n\n\n//this function is from https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n    float num_colors = 5.0;\n    //set the number of colors to be randomly generated\n    \n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return floor(fract((p3.x + p3.y) * p3.z)*num_colors);\n}\n    \n\n\nfloat magnify(vec2 fragCoord,float mag){\n    return hash12(floor(fragCoord/pow(3.0,mag)));\n}\n\nvec4 get_neighbors(vec2 fragCoord,float mag){\n    return vec4(magnify(fragCoord+vec2(0,1),mag),\n        magnify(fragCoord+vec2(1,0),mag),\n        magnify(fragCoord-vec2(0,1),mag),\n        magnify(fragCoord-vec2(1,0),mag));\n}\n\n\nbool is_next_to(float color,vec4 neighbors){\n\treturn (neighbors.x == color)\n        || (neighbors.y == color)\n        || (neighbors.z == color)\n        || (neighbors.w == color);\n}\n\n\n\nvec3 get_color(float color){\n    if(color == BLUE){\n    \treturn vec3(0.149,0.141,0.912);\n   \t}\n    else if(color == GREEN){\n    \treturn vec3(0.000,0.833,0.224);\n   \t}\n    else if(color == RED){\n    \treturn vec3(1.0,0.0,0.0);\n   \t}\n    else if(color == WHITE){\n    \treturn vec3(1.0,1.0,1.0);\n   \t}\n    else if(color == GRAY){\n    \treturn vec3(192.0,192.0,192.0)/255.0;\n    }\n    else if(color == YELLOW){\n    \treturn vec3(1.0,1.0,0.0);\n   \t}\n}\n\nvec3 iterations(float color1,in vec2 fragCoord,float mag){\n    float colors[] = float[](GREEN,BLUE,GRAY,YELLOW,WHITE,RED);\n    float mag1 = mag;\n    vec4 neighbors;\n    vec3 color;\n    float steps = 0.0;\n    while(mag > 1.0){\n        float avg =((100.0+sin((fragCoord.x+iTime*300.0)/(20.0*mag)))*(mag/color1));\n        fragCoord += vec2(sin(fragCoord.y/avg)*10.0,sin(fragCoord.x/(avg))*10.0)*mag*mag;\n\n        neighbors = get_neighbors(fragCoord,mag);\n    color1 = color1 == GREEN && is_next_to(BLUE,neighbors)\n    \t? YELLOW\n    :color1 == BLUE && is_next_to(GREEN,neighbors)\n        ? GREEN\n    :color1 == YELLOW && is_next_to(GRAY,neighbors)\n        ? BLUE\n    :color1 == GRAY && is_next_to(YELLOW,neighbors)\n        ? YELLOW\n    :color1 == WHITE && is_next_to(YELLOW,neighbors)\n        ? GRAY\n    :color1 == GRAY && is_next_to(BLUE,neighbors)\n        ? BLUE\n    :color1;\n\n    color += get_color(color1);\n    //mag -= 1.0+(sin(fragCoord.x+iTime)+cos(fragCoord.y+iTime))*0.0002;\n    mag -= 1.0;\n    steps += 1.0;\n\n    }\n    return color/steps;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord *= mag*(((iMouse.x-iMouse.y)+iResolution.x)/iResolution.x);\n    fragCoord = fragCoord + floor((iTime)*100.0)*vec2(mag,0.0);\n    fragCoord += vec2(sin(fragCoord.y/(100.0*(mag+1000.0)))*10.0,sin(fragCoord.x/(100.0*(mag)))*10.0)*mag*mag;\n\n    float color1 = magnify(fragCoord,mag);\n    //color1 = replace_pattern(mat2(1.0,1.0,1.0,1.0),mat2(0.0,2.0,2.0,0.0),fragCoord,mag);\n\n    vec3 color2 = iterations(color1,fragCoord,mag-1.0);\n\n    fragColor = vec4(color2,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdlfR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[218, 280, 302, 302, 529], [537, 537, 577, 577, 629], [631, 631, 676, 676, 855], [858, 858, 902, 902, 1038], [1042, 1042, 1070, 1070, 1484], [2535, 2535, 2591, 2591, 3069]], "test": "error"}
{"id": "wdlfRH", "name": "Loading Ellipse Flat", "author": "Paltoquet", "description": "A basic loading ellipse for flat design ", "tags": ["loading"], "likes": 1, "viewed": 216, "published": "Public API", "date": "1587718489", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n/***\nAuthor: Thibault Ober\nThere is no license attach feel free to enjoy  \n***/\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float PI = 3.14159;\n    \n    vec3 color = vec3(0.448,0.800,0.785);\n    vec3 background = vec3(0.418,0.421,0.440);\n    \n    float width = iResolution.x;\n    float height = iResolution.y;\n    float ellipseScale = 2.0;\n    \n    float scale = 1.3;\n    float borderWidthRatio = 0.06;\n    float glowWidthRatio = 1.58;\n    float animationSpeed = 0.42;\n\t\n    float x = (fragCoord.x / iResolution.x);\n    float y = (fragCoord.y / iResolution.y);\n    \n    x = (x * 2.0) - 1.0;\n    y = (y * 2.0) - 1.0;\n    \n\tfloat theta = atan(y, x);\n    float tanTheta = y/x;\n\n    float a = width / scale;\n    float b = height / scale;\n\n    //intersections with the ellipse and the function y = x * tan(theta) https://math.stackexchange.com/questions/22064/calculating-a-point-that-lies-on-an-ellipse-given-an-angle\n    float x1 = a*b / sqrt(b*b + a*a * tanTheta * tanTheta);\n    float y1 = a*b*tanTheta / sqrt(b*b + a*a * tanTheta * tanTheta);\n\n    vec2 point = vec2(x, y) * max(width, height); // work in a square space\n    vec2 pointOnEllipse = vec2(x1, y1);\n\n    float distanceToEllipse = abs(length(pointOnEllipse) - length(point)) / max(width, height);\n    float r = (distanceToEllipse / borderWidthRatio);\n\n    float progress = mod(iTime * animationSpeed, 1.0);\n    float current = (theta + PI); //[0 - 360]\n    current = mod(current + PI / 2.0, 2.0 * PI);  //offset to put the beguining at the top\n    current = current / (2.0 * PI); //ratio for animation\n\t\n    \n    vec3 currentColor = current <= progress  ? color.xyz : background.xyz;\n    float glowRatio = current <= progress ? 1.0 / glowWidthRatio : 3.0;\n\n    if(r < 1.0){\n        fragColor = vec4(currentColor, 1.0);\n    } else {\n        float alpha = 1.0 - (r - 1.0) * glowRatio;\n        fragColor = vec4(vec3(currentColor * alpha), alpha);\n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdlfRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[83, 83, 140, 140, 1942]], "test": "valid"}
{"id": "wdlfRr", "name": "Optical illusion/dithering", "author": "bikemule", "description": "Accidentally rotating the wrong part of a sine wave gave this cool effect. Gets better with time. Try different rotations and multipliers for sin", "tags": ["effect", "dither", "illusion", "opticalillusion", "bw", "dithering"], "likes": 2, "viewed": 137, "published": "Public", "date": "1587630583", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nImplemented from scratch using math from \"Computer Graphics with OpenGL 3rd Ed.\"\n*/\n\n#define PI 3.1415926535897932384626433832795028841971693993751058209\n\nmat3 make2DRotation(in vec3 uv, in float angle) {\n    // Probably remembering this function too well from Iniqo Quilez or someplace else...\n    \n    // Matrix math is implemented from p. 239 \n    return mat3(vec3(cos(angle), sin(angle), 0.),\n                vec3(-sin(angle), cos(angle), 0.),\n                vec3(0., 0., 1.));\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.y *=2.;\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 uvR = make2DRotation(vec3(uv, 1.), PI/(iTime*iTime)) * vec3(uv, 1.);\n    \n    vec3 col = vec3(1.,1.,1.);\n    vec3 bgcol = vec3(0.,0.,0.);\n    \n    if(uvR.y < sin(uvR.x*PI*iTime))\n        col = bgcol;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdlfRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[158, 158, 207, 349, 492], [494, 494, 551, 601, 979]], "test": "valid"}
{"id": "WdlfWr", "name": "Venn diagram", "author": "os0450", "description": "Day 27: Venn diagram", "tags": ["dailycodingchallenge"], "likes": 2, "viewed": 38, "published": "Public", "date": "1588057219", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.yy;\n\n    vec3 col = vec3(0.0);\n    float t = iTime*0.2 + p.x*0.2+sin(p.y)*0.2+p.x*sin(iTime*0.2)+100.0;\n    \n    float pi = acos(-1.0);\n    int cnt = 0;\n    for(float r=t; r<pi*2.0 + t; r+=pi/3.0) {\n        float c = cos(r), s = sin(r);\n        \n        if(length(p + 1.5*vec2(c, s)*sin(t+sin(r)))-0.6 <= 0.0) {\n            cnt += 1;\n        }\n        \n        if(length(p + 0.8*vec2(c, s)*sin(t+cos(r)))-0.2 <= 0.0) {\n            cnt += 1;\n        }\n        \n        \n        if(length(p + 1.2*vec2(c, s)*sin(t+clamp(tan(r), -10., 10.)))-0.05 <= 0.0) {\n            cnt += 1;\n        }\n    }\n    \n    switch(cnt%3) {\n        case 0:\n        col = vec3(0.0, 0.1, 0.5*(fract(sin(length(p)*20.+t*200.))*0.2+0.8));\n        break;\n        case 1:\n        col = vec3(0.5, 0.5, 1.0)\n            *(smoothstep(0.005, 0.006, fract(p.x+t))*0.2+0.6)\n            *(smoothstep(0.005, 0.006, fract(p.y+t))*0.2+0.6);\n        break;\n        case 2:\n        col = vec3(0.0, 0.0, 0.3)*(fract(t) - 0.2);\n        break;\n        default:\n        col = vec3(0.0);\n        break;\n    }\n\n    col *= 1.-length(p)*0.3;\n    col = pow(col, vec3(0.5));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdlfWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1269]], "test": "valid"}
{"id": "wdlfz4", "name": "Srinivasa Ramanujan, 1887-1920", "author": "mla", "description": "Ramanujan died exactly 100 years ago today:\n\n[url]https://en.wikipedia.org/wiki/Srinivasa_Ramanujan[/url]\n[url]https://trinitycollegelibrarycambridge.wordpress.com/2020/04/24/remembering-ramanujan/[/url]\n", "tags": ["partition", "1729", "ramanujan"], "likes": 7, "viewed": 241, "published": "Public API", "date": "1587891653", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Srinivasa Ramanujan, 22 December 1887 – 26 April 1920.\n//\n// https://en.wikipedia.org/wiki/Srinivasa_Ramanujan\n//\n// Here we have a 12x12x12 cube, total volume 1728, that can be dissected and,\n// with an extra piece, reassembled into a 9x9x9 cube and a 10x10x10 cube,\n// Key 'x' shows the 10x10x10 cube.\n//\n// Some of Ramanujan's more profound work was in the area of partition theory,\n// for example, Ramanujan's Congruences concerning p(n), the number of\n// partitions of integer n (ie. the number of ways of expressing positive n as a\n// sum of positive integers):\n//\n// https://en.wikipedia.org/wiki/Ramanujan%27s_congruences:\n//\n// p(5k+4) = 0 mod 5\n// p(7k+5) = 0 mod 7\n// p(11k+6) = 0 mod 11\n//\n// The first two are nicely illustrated with p(19) = 490 and all 490\n// partitions appear in the background, grouped appropriately. (Key 'b'\n// shows just the background).\n//\n// Matthew Arcus, mla, 26th April 2020\n//\n////////////////////////////////////////////////////////////////////////////////\n\nint AA = 2; // Set to 1 if too slow.\n\nfloat eyedist = 40.0;     // Eye is at (0,0,eyedist);\nvec3 light = normalize(vec3(0,1,3)); // Direction of light\nbool dorotate = true;\n\nfloat PI = 3.1415927; \n\n// Raymarching configuration.\nint maxsteps = 100;\nfloat precis = 1e-3; \n\nint cubesize = 6; // Half width of cube\nfloat dicesize = 0.4; // \nfloat de(vec3 p) {\n  vec3 p0 = abs(p);\n  p = fract(p);\n  p -= 0.5;\n  p = abs(p);\n  float d = -1e8;\n  d = max(d,p.x-dicesize);\n  d = max(d,p.y-dicesize);\n  d = max(d,p.z-dicesize);\n  // Clip to cubesize\n  d = max(d,p0.x-float(cubesize));\n  d = max(d,p0.y-float(cubesize));\n  d = max(d,p0.z-float(cubesize));\n  return d;\n}\n\nvec3 getnormal(vec3 p, vec3 rd) {\n  // Repeat DE calculation, but return normal to closest plane.\n  p = fract(p);\n  p -= 0.5;\n  p = abs(p);\n  float d1, d = -1e8;\n  vec3 n = vec3(0);\n  d1 = p.x-dicesize;\n  if (d1 > d) { d = d1; n = vec3(1,0,0); }\n  d1 = p.y-dicesize;\n  if (d1 > d) { d = d1; n = vec3(0,1,0); }\n  d1 = p.z-dicesize;\n  if (d1 > d) { d = d1; n = vec3(0,0,1); }\n  // Make sure normal points the right way.\n  return dot(n,rd) < 0.0 ? n : -n;\n}\n\n// Rotate vector p by angle t.\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n\n// Rotate according to mouse position\nvec3 transformframe(vec3 p) {\n  if (iMouse.x > 0.0) {\n    // Full range of rotation across the screen.\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  // autorotation\n  if (dorotate) {\n    p.yz = rotate(p.yz,-iTime*0.125);\n    p.zx = rotate(p.zx,iTime*0.1);\n  }\n  return p;\n}\n\nvec3 colours[] =\n  vec3[](vec3(0,0,1),\n         vec3(1,0,0),\n         vec3(1,1,0),\n         vec3(0,1,0),\n         vec3(1));\n\n// p is integer coordinates of 'dice'.\nvec3 getdicecolor(ivec3 p) {\n  p += cubesize;\n  int t = int(p.x >= 9) + int(p.y >= 9) + int(p.z >= 9);\n  return colours[t+int(cubesize == 5)];\n}\n\nfloat march(vec3 q, vec3 r) {\n  float maxdist = 2.0*eyedist;\n  float t = 0.0;\n  for (int i = 0; i < maxsteps; i++) {\n    vec3 p = q+t*r;\n    float d = de(p);\n    if (abs(d) < precis) return t; // Close enough to the surface.\n    t += d;\n    if (t > maxdist) break;\n  }\n  return -1.0;\n}\n\nbool raycolor(vec3 q, vec3 r, out vec3 color) {\n  float t = march(q,r);\n  if (t < 0.0) return false;\n  // Get the surface point that has been hit,\n  vec3 p = q+t*r;\n  // and the normal at that point.\n  vec3 normal = getnormal(p,r);\n  \n  // Apply lighting. This is a basic \"Lambertian\" model.\n  color = 0.2+0.8*getdicecolor(ivec3(floor(p)));\n  float ambient = 0.3;\n  float diffuse = 0.7*clamp(dot(normal,light),0.0,1.0);\n  color *= ambient+ diffuse;\n  return true;\n}\n\n// Partitions. p(n,m) = number of partitions of n with parts no larger than m\n// p(0,_) = 1\n// p(n,0) = 0\n// p(n,m) = p(n,m-1) + p(n-m,m)\n\nconst int ptable[20*20] =\n  int[] (1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2,\n         2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 3, 3, 3,\n         3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 3, 4, 5, 5, 5, 5, 5,\n         5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 1, 3, 5, 6, 7, 7, 7, 7, 7, 7, 7,\n         7, 7, 7, 7, 7, 7, 7, 7, 7, 1, 4, 7, 9, 10, 11, 11, 11, 11, 11, 11,\n         11, 11, 11, 11, 11, 11, 11, 11, 11, 1, 4, 8, 11, 13, 14, 15, 15, 15,\n         15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 1, 5, 10, 15, 18, 20,\n         21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 1, 5, 12,\n         18, 23, 26, 28, 29, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,\n         1, 6, 14, 23, 30, 35, 38, 40, 41, 42, 42, 42, 42, 42, 42, 42, 42,\n         42, 42, 42, 1, 6, 16, 27, 37, 44, 49, 52, 54, 55, 56, 56, 56, 56,\n         56, 56, 56, 56, 56, 56, 1, 7, 19, 34, 47, 58, 65, 70, 73, 75, 76,\n         77, 77, 77, 77, 77, 77, 77, 77, 77, 1, 7, 21, 39, 57, 71, 82, 89,\n         94, 97, 99, 100, 101, 101, 101, 101, 101, 101, 101, 101, 1, 8, 24,\n         47, 70, 90, 105, 116, 123, 128, 131, 133, 134, 135, 135, 135, 135,\n         135, 135, 135, 1, 8, 27, 54, 84, 110, 131, 146, 157, 164, 169, 172,\n         174, 175, 176, 176, 176, 176, 176, 176, 1, 9, 30, 64, 101, 136, 164,\n         186, 201, 212, 219, 224, 227, 229, 230, 231, 231, 231, 231, 231, 1,\n         9, 33, 72, 119, 163, 201, 230, 252, 267, 278, 285, 290, 293, 295,\n         296, 297, 297, 297, 297, 1, 10, 37, 84, 141, 199, 248, 288, 318,\n         340, 355, 366, 373, 378, 381, 383, 384, 385, 385, 385, 1, 10, 40,\n         94, 164, 235, 300, 352, 393, 423, 445, 460, 471, 478, 483, 486, 488,\n         489, 490, 490, 1, 11, 44, 108, 192, 282, 364, 434, 488, 530, 560,\n         582, 597, 608, 615, 620, 623, 625, 626, 627\n);\n\nint pcount(int n, int m) {\n  if (n == 0) return 1;\n  if (m == 0) return 0;\n  return ptable[20*(n-1)+m-1];\n}\n\n// Recurrence:\n// parts(0,_) = [[]]\n// parts(_,0) = []\n// parts(n,m) = parts(n,m-1) + parts(n-m,m)\n// Use p(n,m) to decide which branch of the recursion to follow.\nint unrank(int n, int k, int t) {\n  int m = n, i = 0;\n  while (true) {\n    int k1 = pcount(n,m-1);\n    if (k < k1) m = m-1;\n    else {\n      t -= m;\n      if (t < 0) return i;\n      i++; n -= m; k -= k1;\n    }\n  }\n}\n\nvec3 bgcolor(vec2 fragCoord) {\n  // 490 = 2*5*7*7 items, each 19 squares, arranged in 14 rows of 7\n  // blocks of 5 subrows of 19 square. With a border.\n  ivec2 pdim = ivec2(iResolution.xy);\n  ivec2 pcoord = ivec2(fragCoord);\n  pcoord.y = pdim.y-1-pcoord.y;\n  vec3 col = vec3(0.2);\n  // Width is 7 blocks of 19, plus 8 separators\n  // Height is 14 blocks of 5, plus 15 separators\n  int W = 7, W1 = 19;\n  int H = 14, H1 = 5;\n  int M = 1;\n  ivec2 bdim = ivec2(W*(W1+M)+M, H*(H1+M)+M); //7*19+8;\n  ivec2 bcoord = pcoord*bdim/pdim;\n  int nwidth = bdim.x; //14*5+15;\n  int nheight = bdim.y; //14*5+15;\n  int i = bcoord.x, j = bcoord.y;\n  int i1 = (i+W1)%(W1+M); // Index within a horizontal block\n  int j1 = (j+H1)%(H1+M);   // Index within a vertical block\n  if (i1 < W1 && j1 < H1) {\n    int p = unrank(19,(i-M)/(W1+M)*(H*H1)+(j-M)/(H1+M)*H1+j1,i1);\n    if (p%2 != 0) col = vec3(0.8);\n    else col = vec3(0.5);\n  }\n  ivec2 boffset = (bcoord*pdim+bdim-1)/bdim; // Index of 1st pixel in block\n  if (bcoord.x > 0 && j1 < H1 && pcoord.x == boffset.x) col = vec3(0);\n  if (bcoord.y > 0 && i1 < W1 && pcoord.y == boffset.y) col = vec3(0);\n  return col;\n}\n\nconst int CHAR_B = 66;\nconst int CHAR_R = 82;\nconst int CHAR_X = 88;\n\nbool key(int code) {\n  return texelFetch(iChannel3, ivec2(code,2),0).x != 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n  if (key(CHAR_X)) cubesize = 5;\n  dorotate = !key(CHAR_R);\n  vec3 eye = vec3(0,0,eyedist);\n  eye = transformframe(eye);\n  light = transformframe(light);\n  vec3 bgcol = bgcolor(fragCoord);\n  vec3 col = vec3(0);\n  if (key(CHAR_B)) {\n    col = bgcol;\n  } else {\n    for (int i = 0; i < AA; i++) {\n      for (int j = 0; j < AA; j++) {\n        vec2 z = (2.0*(fragCoord+vec2(i,j)/float(AA))-iResolution.xy)/iResolution.y;\n        vec3 ray = vec3(z,-4);\n        ray = transformframe(ray);\n        ray = normalize(ray);\n        vec3 raycol;\n        if (!raycolor(eye,ray,raycol)) raycol = bgcol;\n        col += raycol;\n      }\n    }\n    col /= float(AA*AA);\n  }\n  col = pow(col,vec3(0.4545)); // Gamma\n  fragColor = vec4(col,1);\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdlfz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1379, 1427, 1445, 1445, 1747], [1749, 1749, 1782, 1846, 2203], [2205, 2236, 2266, 2266, 2311], [2313, 2351, 2380, 2380, 2773], [2900, 2939, 2967, 2967, 3083], [3085, 3085, 3114, 3114, 3370], [3372, 3372, 3419, 3419, 3837], [5812, 5812, 5838, 5838, 5919], [5921, 6085, 6118, 6118, 6300], [6302, 6302, 6332, 6454, 7447], [7519, 7519, 7539, 7539, 7599], [7601, 7601, 7652, 7652, 8376]], "test": "error"}
{"id": "wdlfz8", "name": "Onion hill", "author": "gaz", "description": "https://twitter.com/gaziya5/status/1253539880316985345", "tags": ["3d", "2tweets"], "likes": 4, "viewed": 92, "published": "Public", "date": "1587712395", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 O, vec2 C) {\n\tO-=O;\n\tfor(float e,g=0.,i=0.;++i<50.;){\n\t\tvec3 p=g*vec3(C/iResolution.y-.7,1);\n\t\tp.z+=iTime*4.;\n\t\tp=mod(p,8.)-4.;\n\t\tp.xz=length(p.xz)*vec2(sin(iTime)*.5,2.);\n\t\tp.z=fract(p.z)-.5;\n        for(int j=0;j++<3;)p.yz=abs(p.yz)-.1;\n\t\tg+=e=dot(abs(p),.5+p-p)-1.;\n        e<.01?O.xyz+=abs(cos(p*9.+iTime))/i:p;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdlfz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 347]], "test": "valid"}
{"id": "Wdlfzr", "name": "Subsurface Scattering Shangru", "author": "pandaleo", "description": "hw9", "tags": ["cis561"], "likes": 1, "viewed": 50, "published": "Public", "date": "1587611604", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The larger the DISTORTION, the smaller the glow\nconst float DISTORTION = 0.2;\n// The higher GLOW is, the smaller the glow of the subsurface scattering\nconst float GLOW = 6.0;\n// The higher the BSSRDF_SCALE, the brighter the scattered light\nconst float BSSRDF_SCALE = 3.0;\n// Boost the shadowed areas in the subsurface glow with this\nconst float AMBIENT = 0.0;\n// Toggle this to affect how easily the subsurface glow propagates through an object\n\nfloat subsurface(vec3 lightDir, vec3 normal, vec3 viewVec, float thickness) {\n    vec3 scatteredLightDir = lightDir + normal * DISTORTION;\n    float lightReachingEye = pow(clamp(dot(viewVec, -scatteredLightDir), 0.0, 1.0), GLOW) * BSSRDF_SCALE;\n    float attenuation = 1.0;\n\tfloat totalLight = attenuation * (lightReachingEye + AMBIENT) * thickness;\n    return totalLight;\n}\nmat3 rotateY(float rad)\n{\n    return mat3(vec3(cos(rad), 0, -sin(rad)),\n                vec3(0, 1, 0),\n                vec3(sin(rad), 0, cos(rad))\n               );\n}\nmat3 rotateZ(float rad)\n{\n    return mat3(vec3(cos(rad), -sin(rad), 0),\n                vec3(sin(rad), cos(rad), 0),\n                vec3(0, 0, 1)\n               );\n}\nmat3 rotateX(float rad)\n{\n    return mat3(vec3(1, 0, 0),\n        \t\tvec3(0, cos(rad), -sin(rad)),\n                vec3(0, sin(rad), cos(rad))\n               );\n}\nmat3 scale(float a, float b, float c)\n{\n    return mat3(vec3(a, 0, 0), vec3(0, b, 0), vec3(0, 0, c));\n}\nmat3 scale(float a)\n{\n    return scale(a, a, a);\n}\nfloat sdfBox(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.) + length(max(d, 0.));\n}\nfloat sdfSphere(vec3 p)\n{\n    return length(p) - 0.5;\n}\nfloat sdfPlane(vec3 p)\n{\n    return dot(p, vec3(0, 0, 1));\n}\nvec2 closer(vec2 a, vec2 b)\n{\n    return a.x < b.x ? a: b;\n}\nfloat deg2rad(float r)\n{\n\treturn r / 180. * 3.14159;\n}\nvec2 map(vec3 pos) // find closest object\n{\n    vec3 sphereWorld = vec3(0.3, 0.3, -0.4);\n    vec3 posSphereModel = pos - sphereWorld; // position in sphere model space\n    vec2 sphereInfo = vec2(sdfSphere(posSphereModel), 1.);\n    \n    vec3 boxWorld = vec3(-0.35, -0.6, 0.3);\n    vec3 posBoxModel = inverse(rotateY(deg2rad(35.))) * (pos - boxWorld);\n    vec3 boxSize = vec3(0.2, 0.4, 0.2);\n    vec2 boxInfo = vec2(sdfBox(posBoxModel, boxSize), 2.);\n    \n    vec3 boxWorld2 = vec3(0.35, -0.8, 0.3);\n    vec3 posBoxModel2 = inverse(rotateY(deg2rad(60.))) * (pos - boxWorld2);\n    vec3 boxSize2 = vec3(0.22, 0.22, 0.22);\n    vec2 boxInfo2 = vec2(sdfBox(posBoxModel2, boxSize2), 8.);\n    \n    vec3 planeWorld1 = vec3(-1, 0, 0);\n    vec3 posPlaneModel1 = inverse(rotateY(3.14 / 2.)) * (pos - planeWorld1);\n    vec2 planeInfo1 = vec2(sdfPlane(posPlaneModel1), 3.);\n    \n    vec3 planeWorld2 = vec3(1, 0, 0);\n    vec3 posPlaneModel2 = inverse(rotateY(3. * 3.14 / 2.)) * (pos - planeWorld2);\n    vec2 planeInfo2 = vec2(sdfPlane(posPlaneModel2), 4.);\n    \n    vec3 planeWorld3 = vec3(0, 0, 0);\n    vec3 posPlaneModel3 = (pos - planeWorld3);\n    vec2 planeInfo3 = vec2(sdfPlane(posPlaneModel3), 5.);\n    \n    vec3 planeWorld4 = vec3(0, 1, 0);\n    vec3 posPlaneModel4 = inverse(rotateX(3. * 3.14 / 2.)) * (pos - planeWorld4);\n    vec2 planeInfo4 = vec2(sdfPlane(posPlaneModel4), 6.);\n    \n    vec3 planeWorld5 = vec3(0, -1, 0);\n    vec3 posPlaneModel5 = inverse(rotateX(3.14 / 2.)) * (pos - planeWorld5);\n    vec2 planeInfo5 = vec2(sdfPlane(posPlaneModel5), 7.);\n    \n    vec2 closest;\n    closest = closer(boxInfo, planeInfo1);\n    closest = closer(closest, planeInfo2);\n    closest = closer(closest, planeInfo3);\n    closest = closer(closest, planeInfo4);\n    closest = closer(closest, planeInfo5);\n    closest = closer(closest, boxInfo2);\n    closest = closer(closest, sphereInfo);\n    return closest;\n}\nfloat fiveTapAO(vec3 p, vec3 n, float k) {\n    float aoSum = 0.0;\n    for(float i = 0.0; i < 5.0; ++i) {\n        float coeff = 1.0 / pow(2.0, i);\n        aoSum += coeff * (i * 0.15 - map(p + n * i * 0.15).x);\n    }\n    return 1.0 - k * aoSum;\n}\nvec2 calcIntersection(in vec3 ro, in vec3 rd){\n    float currentMinSdf = 0.002;\n    float t = 0.0; // distance from ro (ray origin)\n\tfloat resDistance = -1.;\n    float id = -1.;\n    for (int i = 0; i < 100; ++i){\n        if (currentMinSdf < 0.001 || t > 10.) break; // hit or exceed max distance\n\t   \tvec2 hitInfo = map(ro + rd * t); // hit object distance and id\n        currentMinSdf = hitInfo.x; // distance\n        t += currentMinSdf; // update current distance from ro\n        id = hitInfo.y;\n    }\n    if (t <= 10.) resDistance = t; // if in distance\n    else id = -1.; // no hit\n    return vec2(resDistance, id);\n}\nvec3 calcNormal(in vec3 pos){\n    \n\tvec3 dx = vec3(0.001, 0.0, 0.0);    \n\tvec3 dy = vec3(0.0, 0.001, 0.0);    \n\tvec3 dz = vec3(0.0, 0.0, 0.001);\n\tvec3 nor = vec3(\n\t    map(pos + dx).x - map(pos - dx).x,\n\t    map(pos + dy).x - map(pos - dy).x,\n\t    map(pos + dz).x - map(pos - dz).x\n    );\n\treturn normalize(nor);\n}\nvec3 render(vec2 res, in vec3 ro, in vec3 rd)\n{\n    float ambient = 0.05;\n    vec3 color = vec3(0);\n    float lightX = 0.5 * sin(iTime * 4.);\n    vec3 lightPos = vec3(lightX, 0.9, 0.8);\n    if (res.y > 0.) // id\n    {\n    \tvec3 pos = ro + rd * res.x;\n    \tvec3 norm = calcNormal(pos);\n    \tvec3 lightDir = normalize(lightPos - pos);\n        float match = max(0., dot(lightDir, norm) / pow(length(lightPos - pos), 0.3));\n        float ao = fiveTapAO(pos, norm, 2.);\n        vec3 view = ro - pos;\n        if (res.y == 1.) color = subsurface(-lightDir, norm, view, ao) * vec3(1., 1., 0.) * match + ambient;\n        else if (res.y == 2.) color = subsurface(-lightDir, norm, view, ao) * vec3(1., 0.8, 0.4) * match + ambient;\n\t\telse if (res.y == 3.) color = ao * vec3(1, 0, 0) * match + ambient;\n        else if (res.y == 4.) color = ao * vec3(0, 1, 0) * match + ambient;\n\t\telse if (res.y == 5.) color = ao * vec3(1, 1, 1) * match + ambient;   \n        else if (res.y == 6.) color = ao * vec3(0.5, 0.5, 0.5) * match + ambient;\n\t\telse if (res.y == 7.) color = ao * vec3(1, 1, 0.8) * match + ambient;  \n\t\telse if (res.y == 8.) color = subsurface(-lightDir, norm, view, ao) * vec3(0.4, 0.4, 1) * match + ambient;   \n    }\n    return color;\n}\nmat3 lookAt(in vec3 eye, in vec3 ref)\n{\n    vec3 front = normalize(ref - eye);\n    vec3 right = normalize(cross(front, vec3(0, 1, 0)));\n    vec3 up = normalize(cross(right, front));\n    return mat3(right, up, front);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n    vec3 eye = vec3(0, 0, 2), ref = vec3(0, 0, 0);\n    vec3 direction = normalize(lookAt(eye, ref) * vec3(p.xy, 1));\n    vec2 res = calcIntersection(eye, direction);\n    fragColor = vec4(render(res, eye, direction), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wdlfzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[449, 449, 526, 526, 823], [824, 824, 849, 849, 990], [991, 991, 1016, 1016, 1157], [1158, 1158, 1183, 1183, 1318], [1319, 1319, 1358, 1358, 1422], [1423, 1423, 1444, 1444, 1473], [1474, 1474, 1504, 1504, 1597], [1598, 1598, 1623, 1623, 1653], [1654, 1654, 1678, 1678, 1714], [1715, 1715, 1744, 1744, 1775], [1776, 1776, 1800, 1800, 1830], [1831, 1831, 1874, 1874, 3726], [3727, 3727, 3769, 3769, 3971], [3972, 3972, 4018, 4018, 4593], [4594, 4594, 4623, 4623, 4908], [4909, 4909, 4956, 4956, 6141], [6142, 6142, 6181, 6181, 6360], [6361, 6361, 6418, 6418, 6707]], "test": "error"}
{"id": "wdlyDl", "name": "36 Days Of Type - M", "author": "nicolasdnl", "description": "36 Days Of Type - M", "tags": ["letter"], "likes": 0, "viewed": 42, "published": "Public", "date": "1586307499", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535897932384626433832795\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat msign( in float x ) { return (x>0.0)?1.0:-1.0; }\n\n// http://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nvec2 sdSqLine( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( dot2(pa-ba*h), ba.x*pa.y-ba.y*pa.x );\n}\n\nfloat sdCrescent(vec2 p, float r0, float r1, float d, float sign0, float sign1)\n{\n    float a = (r0*r0 - r1*r1 + d*d) / (2.0 * d);\n    \n    if( a < r0)\n    {\n        p.y = abs(p.y);\n        float b = sqrt(r0*r0-a*a);\n        float k = p.y*a - p.x*b;\n        float h = min(d*sign0*(d*(p.y-b)-k ),\n                      d*sign1*k);\n        if (h>0.0)\n        {\n            return length(p-vec2(a,b));\n        }\n    }\n    \n    return max(sign0*(length(p          )-r0),\n               sign1*(length(p-vec2(d,0))-r1));\n}\n\n// http://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nvec2 sdSqArc( in vec2 p, in vec2 a, in vec2 b, in float h, float d2min )\n{\n    vec2  ba  = b-a;\n    float l   = length(ba);\n    float ra2 = h*h + l*l*0.25;\n\n    // recenter\n    p -= (a+b)/2.0 + vec2(-ba.y,ba.x)*h/l;\n    \n    float m = ba.y*p.x-ba.x*p.y;\n    float n = dot(p,p);\n    \n    if( abs(h)*abs(ba.x*p.x+ba.y*p.y) < msign(h)*l*0.5*m )\n    {\n        d2min = min( d2min, n + ra2 - 2.0*sqrt(n*ra2) );\n    }\n\n    return vec2(d2min, -max(m,ra2-n) );\n}\n\n\n//------------------------------------------------------------\n\n\n\n// SDF of a shape made of a set line and arc segments\n//float sdShape( in vec2 p, int kType[10], float kPath[22] )\nfloat sdShape( in vec2 p, int kType[5], float kPath[12] )\n{\n    vec2 vb = vec2(kPath[0],kPath[1]);\n    \n    float d = dot2(p-vb);\n    int off = 0;\n    float s = 1.0;\n    for( int i=0; i<kType.length(); i++ )\n    {\n        vec2 va = vb;\n        vec2 ds;\n        \n        if( kType[i]==0) // line (x,y)\n        {\n            vb = vec2(kPath[off+2],kPath[off+3]);\n            ds = sdSqLine( p, va, vb );\n            off += 2;\n        }\n        else if( kType[i]==1 || kType[i]==2 ) // arc (x,y,r)\n        {\n            vb = vec2(kPath[off+3],kPath[off+4]);\n            ds = sdSqArc(p, va, vb, kPath[off+2], d );\n        \toff += 3;\n\n        }\n        \n        // in/out test\n        if ( kType[i]==2 )\n        {\n            bvec3 cond = bvec3( p.y<va.y, p.y<vb.y, ds.y>0.0 );\n            if( all(cond) || all(not(cond)) ) s*=-1.0;\n        }\n        else\n        {\n            bvec3 cond = bvec3( p.y>=va.y, p.y<vb.y, ds.y>0.0 );\n            if( all(cond) || all(not(cond)) ) s*=-1.0;\n        }\n\n        d = min( d, ds.x );\n    }\n    \n    //if( p.y < 0. ) s*=-1.0;\n    \n\treturn s*sqrt(d);\n}\n\nfloat sdA( in vec2 p )\n{\n    float width = 1.;\n    float height = 1.;\n    \n   \tint kType[] = int[](0,0,0,0,0);\n\tfloat kPath[] = float[]( -width*0.5,  height*0.5,\n                             -width*0.5, -height*0.5,\n                              width*0.5, -height*0.5,\n                              width*0.5,  height*0.5,\n                              0.0, 0.0,\n                             -width*0.5,  height*0.5 );\n    /*int kType[] = int[](0,0,0,0,0,0,0,0,0,0);\n\tfloat kPath[] = float[]( -width*0.5,  height*0.5,\n                             -width*0.5, -height*0.5,\n                             -width*0.4, -height*0.5,\n                             -width*0.4, 0.0,\n                              0.0, -height*0.22,\n                              width*0.4, 0.0,\n                              width*0.4, -height*0.5,\n                              width*0.5, -height*0.5,\n                              width*0.5,  height*0.5,\n                              0.0, height*0.22,\n                             -width*0.5,  height*0.5 );*/\n    return sdShape(p,kType,kPath );\n}\n\nvec3 generateBorder(in vec3 col, in float border)\n{\n    col = mix( col, vec3(0.0), 1.0-smoothstep(0.0,0.015,border) );\n    return col;\n}\n\nfloat getLetter(float d)\n{\n    float letter = 1.-sign(d);\n\tletter = mix( letter, 1., 1.0-smoothstep(0.0,0.015,abs(d)) );\n    \n    return letter;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pBase = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0.);\n    \n    vec3 cols[6] = vec3[6](\n    \tvec3(1.,0.,0.),\n        vec3(0.,0.,1.),\n        vec3(0.,1.,0.),\n        vec3(1.,1.,0.),\n        vec3(0.,1.,1.),\n        vec3(1.,0.,1.)\n    );\n    \n    float t = mod(iTime * 0.1, 0.1) / 0.1 * PI * 2.;\n    float count = 50.;\n    \n    for (int i=50; i>=0; i--)\n    {\n    \tvec2 p = pBase * (1. + float(i)*0.05);\n        p.x += sin(t) * (float(i)-count*0.) * 0.008;\n\t\t//p.y += cos(t) * (float(i)-count*0.) * 0.008;\n        p.y += float(i) * 0.01;\n        \n        float d = sdA(p);\n        \n        float letter = getLetter(d);\n        \n        //col = mix(col, 0.94-vec3((float(i)+1.)/(count+10.)), min(1., max(0., letter)));\n        col = mix(0.94-vec3((float(i)+1.)/(count+10.)), col, min(1., max(0., letter)));\n        //col = mix(col, cols[i], min(1., max(0., letter)));\n    }\n    \n    float d = sdA(pBase);\n    float letter = getLetter(d);\n    //col *= letter;\n    col = mix(vec3(0.96), col, min(1., max(0., letter)));\n\n    // output\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdlyDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 71, 71, 90], [91, 91, 118, 118, 145], [147, 221, 271, 271, 404], [406, 406, 487, 487, 922], [924, 998, 1072, 1072, 1451], [1520, 1635, 1694, 1694, 2720], [3797, 3797, 3848, 3848, 3933], [3935, 3935, 3961, 3961, 4081]], "test": "error"}
{"id": "wdsBR4", "name": "The magic mirror", "author": "friol", "description": "What's inside the magic mirror?", "tags": ["raymarching", "metaballs", "mirror", "mondrian"], "likes": 8, "viewed": 255, "published": "Public API", "date": "1588000501", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//\n// friol 2o2o\n// music KV by Bloc https://soundcloud.com/kvmusicprod/bloc\n// (watch this with music, please. be sure music is in sync)\n// sdf functions by iq\n// blob taken from mercury and modified\n// da rest is by P.Mondrian\n// 06.05.2020: reduced compilation time as for suggestions by iq\n//\n\nconst int iterationAmount=256;\nconst float patternLength=14.5;\nconst float numPatterns=4.0;\n\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nvec3 rotx(in vec3 p, float a) \n{\n\treturn vec3(p.x,\n                cos(a) * p.y + sin(a) * p.z,\n                cos(a) * p.z - sin(a) * p.y);\n}\n\nvec3 roty(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.z,\n                p.y,\n                cos(a) * p.z - sin(a) * p.x);\n}\n\nvec3 rotz(in vec3 p, float a) {\n\treturn vec3(cos(a) * p.x + sin(a) * p.y,\n                cos(a) * p.y - sin(a) * p.x,\n                p.z);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdPyramid( vec3 p, float h)\n{\n  float m2 = h*h + 0.25;\n    \n  p.xz = abs(p.xz);\n  p.xz = (p.z>p.x) ? p.zx : p.xz;\n  p.xz -= 0.5;\n\n  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n  float s = max(-q.x,0.0);\n  float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n  return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat fBlob(vec3 p) \n{\n    float fft = texture( iChannel0, vec2(0.0,0.0) ).x;\n    p*=(1.5+(fft*0.4));\n    p=roty(p,iTime);\n    p=rotx(p,iTime);\n\n    float PHI=(sqrt(5.0)*0.5 + 0.5);\n\tp = abs(p);\n\tif (p.x < max(p.y, p.z)) p = p.yzx;\n\tif (p.x < min(p.y, p.z)) p = p.yzx;\n\tfloat b = max(max(min(\n\t\tdot(p, normalize(vec3(.3, 1., 1.))),\n\t\tdot(p.xz, normalize(vec2(PHI+1., 1.)))),\n\t\tdot(p.yx, normalize(vec2(1, PHI)))),\n\t\tdot(p.xz, normalize(vec2(1, PHI))));\n\tfloat l = length(p)/(1.0+.01*abs(sin(iTime)));\n\treturn l - 1.5 - 0.2 * (1.5 / 2.0)* .4*sin(min(sqrt(1.01 - b / l)*(3.141592 / 0.25), 3.141592));\n}\n\nvec2 SDF(vec3 r)\n{\n    vec3 rOrig=r;\n    float mat=0.0;\n\n    float plane0=sdPlane(r\t\t\t\t\t,vec4(0.0,1.0,0.0,1.0));\n    float plane1=sdPlane(r-vec3(0.0,0.1,0.0),vec4(0.0,-1.0,0.0,1.0));\n    \n    float domainRep=10.0;\n    vec3 c=vec3(domainRep);\n    r = mod(r+0.5*c,c)-0.5*c;\n    \n    float b0=sdBox(r,vec3(1.0,1.1,1.0));\n    float b1=sdBox(r,vec3(2.0,.9,.8));\n    float b2=sdBox(r-vec3(0.0,0.,0.0),vec3(0.8,0.9,2.0));\n    \n    float b3=sdBox(r-vec3(0.0,-0.9,-0.9),vec3(10.0,0.1,0.1));\n    float b4=sdBox(r-vec3(0.9,-0.9,0.0),vec3(0.1,0.1,10.0));\n    float b5=sdBox(r-vec3(-0.9,-0.9,0.0),vec3(0.1,0.1,10.0));\n    float b6=sdBox(r-vec3(0.0,-0.9,0.9),vec3(10.0,0.1,0.1));\n    float t1=opSubtraction(b1,b0);\n    float t0=opSubtraction(b2,t1);\n    t0=min(t0,b3);\n    t0=min(t0,b4);\n    t0=min(t0,b5);\n    t0=min(t0,b6);\n    \n    float s0=sdSphere(r-vec3(.6*sin(iTime),0.2*cos(iTime),.5*sin(iTime)),0.3);\n    float s1=sdSphere(r-vec3(.5*cos(iTime),-0.2*sin(iTime),0.0),0.2);\n    float s2=sdSphere(r-vec3(.7*cos(iTime),-0.5*cos(iTime),-.2*sin(iTime)),0.2);\n    \n    //vec2 uv = ((normal.xy + 1.0) * 0.5)*4.0;\n\t//float h = texture(iChannel0, uv).x/32.0;  \n\n    float h0=0.,h1=0.,h2=0.;\n    float unionCoeff=0.2;\n    float spheres=opSmoothUnion(opSmoothUnion(s0-h0,s1-h1,unionCoeff),s2-h2,unionCoeff);\n    \n    float pyr0=sdOctahedron((((r)-vec3(2.0,-2.0,0.0))),1.5);\n    float pyr1=sdOctahedron((((r)-vec3(-2.0,-2.0,0.0))),1.5);\n\n    float roamingSphere;\n    float sphTime=iTime*(patternLength/10.615);\n    \n    float modTime=mod(iTime,patternLength*numPatterns);    \n    if (modTime<patternLength)\n    {\n    \troamingSphere=sdSphere(r-vec3(0.0,-10.6,1.5+abs(5.0*sin(sphTime))),0.4);\n    }\n    else\n    {\n    \troamingSphere=sdSphere(r-vec3(0.0,-.6,1.5+abs(5.0*sin(sphTime))),0.4);\n    }\n    \n    vec3 rr=rotz(r,3.141592/2.0);\n    float roamingSphere2=sdTorus(rr-vec3(-.5,0.0,-1.5-abs(5.0*cos(sphTime))),vec2(0.35,0.2));\n\n    float mirror=sdBox(r-vec3(0.0,0.0,5.0),vec3(.8,1.1,.1));\n\n    \n    float t=min(min(min(min(min(min(min(min(t0,plane0),plane1),spheres),pyr0),pyr1),roamingSphere),mirror),roamingSphere2);\n    if (t==plane0) mat=1.0;\n    if (t==plane1) mat=1.0;\n    if (t==spheres) mat=2.0;\n    if (t==pyr0) mat=3.0;\n    if (t==pyr1) mat=4.0;\n\tif (t==roamingSphere) mat=6.0;                                 \n\tif (t==roamingSphere2) mat=7.0;                                 \n    if (t==mirror) mat=5.0;\n\n    if (modTime>=patternLength*3.0)        \n    {\n        float centeredBlob=fBlob(rOrig-vec3(5.0,0.0,1.0+iTime));\n        if (centeredBlob<t)\n        {\n            return vec2(centeredBlob,8.0);\n        }\n    }\n    \n    return vec2(t,mat);   \n}\n\nvec3 calcNormal(vec3 pos)\n{\n    float c = SDF(pos)[0];\n    vec2 eps_zero = vec2(0.01, 0.0);\n    return normalize(vec3( SDF(pos + eps_zero.xyy)[0], SDF(pos + eps_zero.yxy)[0], SDF(pos + eps_zero.yyx)[0] ) - c);\n}\n\nvec2 castRay(vec3 rayOrigin, vec3 rayDir)\n{\n    float t = 0.0;\n     \n    for (int i = 0; i < iterationAmount; i++)\n    {\n        vec2 res = SDF(rayOrigin + rayDir * t);\n        if (res[0] < (0.0001*t))\n        {\n            return vec2(t,res[1]);\n        }\n        t += res[0];\n    }\n     \n    return vec2(-1.0,-1.0);\n}\n\nvec3 bounceRender(vec3 rayOrigin, vec3 rayDir, vec2 uv)\n{\n    vec3 col;\n    vec3 L=normalize(vec3(1.0,0.2,-2.0));\n\n    vec2 rayHit = castRay(rayOrigin, rayDir);\n    float t=rayHit[0];\n    \n    if (t!=-1.0)\n    {\n    \tvec3 pHit=rayOrigin + rayDir * t;\n        vec3 N=calcNormal(pHit);\n        float NoL = max(dot(N, L), 0.0);\n        float mat=rayHit[1];\n        if (mat==0.0)\n        {\n            col=vec3(NoL);\n        }\n        else if (mat==1.0) // plane\n        {\n            float lDist=distance(pHit,L+rayOrigin);\n        \tvec2 a = vec2(1.)*smoothstep(-0.05, 0.05, mod(pHit.x, 1.))*smoothstep(-0.05, 0.05, mod(pHit.z, 1.));\n        \tcol = vec3(1.0-a.x,1.0-a.y,1.0-a.x);\n            \n            //col+=vec3(pow(clamp(1.0-lDist/6.0,0.0,1.0),1.0));\n        }\n        \n        else if (mat==2.0) // spheres\n        {\n            NoL+=pow(NoL,32.0);\n            col+=vec3(.2,.3,.5)*vec3(NoL);\n        }\n        else if (mat==3.0)\n        {\n            NoL+=pow(NoL,32.0);\n            col+=vec3(1.0,0.0,0.0)*vec3(NoL);\n        }\n        else if (mat==4.0)\n        {\n            NoL+=pow(NoL,32.0);\n            col+=vec3(1.0,1.0,0.0)*vec3(NoL);\n        }\n\n        col/=distance(pHit-rayOrigin,vec3(0.))*.3;\n    }\n\n    col=pow(col,vec3(0.58));\n    return col;\n}\n\nvec4 render(vec3 rayOrigin, vec3 rayDir, vec2 uv)\n{\n    vec3 col=vec3(0.);\n    vec3 L=normalize(vec3(1.0,0.2,-2.0));\n\n    vec2 rayHit = castRay(rayOrigin, rayDir);\n    float t=rayHit[0];\n\n    if (t!=-1.0)\n    {\n    \tvec3 pHit=rayOrigin + rayDir * t;\n        float mat=rayHit[1];\n        vec3 N=calcNormal(rayOrigin + rayDir * t);\n        float NoL = max(dot(N, L), 0.0);\n      \n        if (mat==0.0)\n        {\n            col=vec3(NoL);\n        }\n        else if (mat==1.0) // plane\n        {\n            float lDist=distance(pHit,L+rayOrigin);\n        \tvec2 a = vec2(1.)*smoothstep(-0.05, 0.05, mod(pHit.x, 1.))*smoothstep(-0.05, 0.05, mod(pHit.z, 1.));\n        \tcol = vec3(1.0-a.x,1.0-a.y,1.0-a.x);\n            \n            col+=vec3(pow(clamp(1.0-lDist/6.0,0.0,1.0),2.2));\n        }\n        else if ((mat==2.0)||(mat==6.0)||(mat==7.0)) // meatballs/roaming spheres\n        {\n            float modTime=mod(iTime,30.0);    \n    \t\tif ((modTime<10.0)&&(mat==6.0))\n            {\n                return vec4(0.,0.,0.,0.);\n            }\n            \n            NoL=pow(NoL,32.0);\n            NoL=clamp(NoL,0.0,1.0);\n            vec3 colReflect=bounceRender(pHit,N,uv);\n            if (mat==2.0) col=vec3(1.0,1.0,1.0)*vec3(NoL);\n            else if (mat==7.0) col=vec3(1.,1.,1.)*vec3(NoL);\n            else col=vec3(.2,.2,.85)*vec3(NoL);\n            //col=vec3(0.5,0.5,0.5)*vec3(NoL);\n            col=mix(col,colReflect,0.2);\n        }\n        else if (mat==3.0) // pyr1\n        {\n            NoL+=pow(NoL,32.0);\n            col+=vec3(1.0,0.0,0.0)*vec3(NoL);\n        }\n        else if (mat==4.0) // pyr2\n        {\n            NoL+=pow(NoL,32.0);\n            col+=vec3(1.0,1.0,0.0)*vec3(NoL);\n        }\n        else if (mat==5.0) // magic mirror\n        {\n            vec3 N=vec3(0.0,0.0,-1.0);\n            vec3 colReflect=bounceRender(pHit,N,uv);\n            col=colReflect*0.5;\n        }\n        else if (mat==8.0) // mysterious blob\n        {\n            vec3 centerVec=vec3(5.0,0.0,1.0+iTime);\n            vec3 edgeVec=pHit-centerVec;\n            \n            edgeVec=normalize(edgeVec);\n            float edge=1.0-dot(edgeVec,vec3(0.,0.,-1.0));\n            edge=pow(edge,3.0);\n            \n            vec3 color1 = vec3(0.0,0.0,0.0);\n            vec3 color2 = vec3(0.726,0.726,0.726);\n            col = mix(color1,color2,edge);\n           \tcol+=edge*pow(distance(pHit,centerVec)*.4,2.0)*vec3(0.38,0.38,0.64);\n            //col=mix(col,color3,min(0.,edge-0.6)*2.0);\n        }\n\n    \tfloat modTime=mod(iTime,patternLength*numPatterns);    \n        if (modTime>=patternLength*3.0)        \n        {\n            if (mat!=8.0)\n            {\n                vec3 nrd=normalize(rayDir);\n                float fft = texture( iChannel0, vec2(0.0,0.0) ).x;\n                float myTime=iTime/8.0;\n                vec2 b=abs(fract(vec2(1.)*nrd.z+myTime)-.5)*abs(fract(vec2(1.)*nrd.z+myTime)-.5);\n                col+=vec3(\n                    (.01*pow(b.x+.8,20.)+b.y/dot(nrd.xy,nrd.xy)*exp(.24-1./4.))*fft,\n                    (.01*pow(b.x+.2,20.)+b.y/dot(nrd.xy,nrd.xy)*exp(.1-1./4.))*fft,\n                    (.01*pow(b.x+.1,20.)+b.y/dot(nrd.xy,nrd.xy)*exp(.32-1./2.))*fft)/3.0;\n            }\n        }\n        \n        col/=distance(pHit-rayOrigin,vec3(0.))*.6;\n    }\n\n    col=pow(col,vec3(0.58));\n    return vec4(col,1.0);\n}\n\nvec3 getCameraRayDir(vec2 uv, vec3 camPos, vec3 camTarget)\n{\n    vec3 camForward = normalize(camTarget - camPos);\n    vec3 upz=vec3(0.,1.,0.);\n    vec3 camRight = normalize(cross(upz, camForward));\n    vec3 camUp = normalize(cross(camForward, camRight));\n     \n    float fPersp = 2.0;\n    vec3 vDir = normalize(uv.x * camRight + uv.y * camUp + camForward * fPersp);\n \n    return vDir;\n}\n\nvec2 normalizeScreenCoords(vec2 screenCoord)\n{\n    vec2 result = 2.0 * (screenCoord/iResolution.xy - 0.5);\n    result.x *= iResolution.x/iResolution.y;\n    return result;\n}\n\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float myTime=iTime/8.0;\n\tvec2 uv = normalizeScreenCoords(fragCoord);\n\n    vec3 camPos,camTarget;\n\n    float modTime=mod(iTime,patternLength*numPatterns);\n    \n    if (modTime<patternLength) // magic mirror\n    {\n        modTime/=8.0;\n        camPos = vec3(0.0,0.,-3.0+7.5-modTime);\n        camTarget = vec3(.0, 0.,0.0+7.5-modTime);\n    }\n    else if ((modTime>=patternLength)&&(modTime<(patternLength*2.0))) // roaming camera\n    {\n        if (iTime>(patternLength*4.0))\n        {\n            camPos = vec3(cos(myTime)*4.0,0.,-3.0+iTime);\n            camTarget = vec3(.0, 0.,0.0+iTime);\n        }\n        else\n        {\n            camPos = vec3(sin(myTime)*4.0,0.,-3.0+iTime);\n            camTarget = vec3(.0, 0.,0.0+iTime);\n        }\n    }\n    else if ((modTime>=patternLength*2.0)&&(modTime<(patternLength*3.0))) // fisheye\n    {\n    \tuv*=(asin(length(uv)*0.75));\n        camPos = vec3(sin(myTime)*5.0,0.6*cos(myTime),-3.0+iTime);\n        camTarget = vec3(.0, 0.,0.0+iTime);\n    }\n    else // glowsphere\n    {\n        camPos = vec3(5.0,0.0,-3.0+iTime);\n        camTarget = vec3(5.0, 0.,0.0+iTime);\n    }\n\n    \n    \n    \n    vec3 rayDir = getCameraRayDir(uv, camPos, camTarget);   \n\n    float fft = texture( iChannel0, vec2(0.0,0.0) ).x;\n    \n    vec4 finalCol = vec4(render(camPos, rayDir,uv).xyz*(1.2+fft*2.0),1.0);\n\n    vec4 distCol=finalCol;\n    float pixx=mod(abs(uv.x*64.0),1.0);\n    if (pixx<0.33) distCol.x/=2.0;\n    if ((pixx>=0.33)&&(pixx<0.66)) distCol.y/=2.0;\n    if (pixx>0.66) distCol.z/=2.0;\n\n    if ((modTime>=patternLength*2.0)&&(modTime<(patternLength*3.0)))\n    {\n        float mult=4.0;\n        distCol+=sin(uv.x*mult)*cos(uv.y*mult);\n    }\n    \n   \tfinalCol=mix(distCol,finalCol,0.5);\n    \n    if (iTime>(patternLength*4.0))\n    {\n        vec3 value = finalCol.rgb;\n        vec3 oldcolor = value + (value * texture(iChannel1, (mod(fragCoord, 8.0) / 8.0)).rrr);\n        finalCol = vec4(floor(oldcolor),1.0);    \n    }\n  \n    fragColor=finalCol;\n}\n", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}, {"id": "MtBGWw", "previewfilepath": "https://soundcloud.com/kvmusicprod/bloc", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/kvmusicprod/bloc", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdsBR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[393, 393, 436, 436, 458], [460, 460, 492, 492, 603], [605, 605, 636, 636, 747], [749, 749, 780, 780, 891], [893, 893, 945, 945, 1044], [1046, 1046, 1079, 1079, 1107], [1109, 1109, 1154, 1154, 1245], [1247, 1247, 1280, 1280, 1311], [1313, 1313, 1344, 1344, 1431], [1433, 1433, 1468, 1468, 1953], [1955, 1955, 1993, 1993, 2273], [2275, 2275, 2308, 2308, 2373], [2375, 2375, 2397, 2397, 2975], [2977, 2977, 2995, 2995, 5619], [5621, 5621, 5648, 5648, 5832], [5834, 5834, 5877, 5877, 6153], [6155, 6155, 6212, 6212, 7416], [7418, 7418, 7469, 7469, 10736], [10738, 10738, 10798, 10798, 11124], [11126, 11126, 11172, 11172, 11298], [11304, 11304, 11361, 11361, 13334]], "test": "error"}
{"id": "WdsBW8", "name": "Pipe line", "author": "gaz", "description": "https://twitter.com/gaziya5/status/1255386763738124289", "tags": ["3d", "2tweets"], "likes": 7, "viewed": 131, "published": "Public", "date": "1588142939", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(a)a=vec2(a.x+a.y,a.x-a.y)*.7\n#define G(a,n)R(a);a=abs(a)-n;R(a)\nvoid mainImage(out vec4 O, vec2 C) {\n\tfor(float g,e,i;i++<45.;){\n   \t\tvec3 p=g*vec3((C*2.-iResolution.xy)/iResolution.y,1);\n        p.z+=iTime;\n        p=fract(p)-.5;\n        G(p.xz,.3);\n        G(p.zy,.1);\n        G(p.yz,.15);\n        g+=e=.6*length(p.xy)-.01;\n        e<.01?O+=abs(cos(p.z*99.))/i:O;\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdsBW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[74, 74, 110, 110, 383]], "test": "valid"}
{"id": "WdScD1", "name": "Invasion Of The Covoids", "author": "dr2", "description": "Close encounters of a different kind", "tags": ["space", "symmetry", "flight", "virus"], "likes": 7, "viewed": 312, "published": "Public API", "date": "1586514486", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Invasion Of The Covoids\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsAnDf (vec3 p, float r, float w, float h);\nvec3 SphFib (vec3 v, float n);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 VToRMat (vec3 v, float a);\nvec3 RotToDir (vec3 v1, vec3 v2, vec3 p);\nvec2 Rot2D (vec2 q, float a);\nmat3 StdVuMat (float el, float az);\nfloat Hashfv3 (vec3 p);\nvec4 Hashv4v3 (vec3 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nmat3 flMat, obMat;\nvec4 obRnd;\nvec3 trkAx, trkAy, trkFx, trkFy, sunDir, flPos, cId, qHit, obDisp, crMid;\nvec2 scrMid;\nfloat bGrid, tCur, dstFar, spd, obOcc, nSpk, obSzFac, rScrn;\nint idObj;\nconst int idCage = 1, idScrn = 2, idVbal = 3, idVspk = 4, idVcap = 5;\nconst float pi = 3.14159;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nvec3 TrackPath (float t)\n{\n  return vec3 (dot (trkAx, cos (trkFx * t)), dot (trkAy, cos (trkFy * t)), t);\n}\n\nvec3 TrackVel (float t)\n{\n  return vec3 (- dot (trkFx * trkAx, sin (trkFx * t)),\n     - dot (trkFy * trkAy, sin (trkFy * t)), 1.);\n}\n\nvec3 TrackAcc (float t)\n{\n  return vec3 (- dot (trkFx * trkFx * trkAx, cos (trkFx * t)),\n     - dot (trkFy * trkFy * trkAy, cos (trkFy * t)), 0.);\n}\n\nvoid ObjState ()\n{\n  obRnd = Hashv4v3 (cId + 17.11);\n  obDisp = 0.5 * bGrid * (obRnd.xyz - 0.5);\n  obMat = VToRMat (normalize (obRnd.xyz - 0.5), (0.2 + 0.8 * obRnd.w) * tCur);\n  nSpk = floor (100. + 40. * obRnd.y);\n  obSzFac = 0.4 + 0.2 * obRnd.y;\n}\n\nfloat VbalDf (vec3 p, float dMin)\n{\n  vec3 q, qn, uf;\n  float d, rad, len, h;\n  dMin /= 0.6 * obSzFac;\n  q = p / obSzFac;\n  rad = 1.;\n  qn = normalize (q);\n  uf = SphFib (qn, nSpk);\n  d = PrSphDf (q, rad * (1. - 0.05 * smoothstep (0.1, 0.2, length (qn - uf))));\n  DMIN (idVbal);\n  q = RotToDir (uf, vec3 (0., 0., 1.), q - uf);\n  h = Hashfv3 (41. * uf);\n  len = 0.3 * (1. - 0.2 * h);\n  q.z -= len;\n  d = PrCylDf (q, 0.04 * (1. - 0.1 * q.z / len), len);\n  DMIN (idVspk);\n  q.z -= len + 0.05;\n  q.xy = Rot2D (q.xy, pi * h / 3.);\n  q.xy = Rot2D (q.xy, 2. * pi * floor (3. * atan (q.y, - q.x) / (2. * pi) + 0.5) / 3.);\n  q.x += 0.08;\n  d = PrSphDf (q * vec3 (1., 1., 1.3), 0.1);\n  DMIN (idVcap);\n  return 0.6 * obSzFac * dMin;\n}\n\nfloat ObjCDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  q = p - obDisp;\n  d = PrSphDf (q, 1.7 * obSzFac);\n  if (d < 0.05) dMin = VbalDf (obMat * q, dMin);\n  else dMin = min (dMin, d);\n  return dMin;\n}\n\nfloat ObjCRay (vec3 ro, vec3 rd)\n{\n  vec3 cIdP, p, s, rdi;\n  float dHit, d, eps;\n  eps = 0.0005;\n  if (rd.x == 0.) rd.x = 0.001;\n  if (rd.y == 0.) rd.y = 0.001;\n  if (rd.z == 0.) rd.z = 0.001;\n  rdi = 1. / rd;\n  cIdP = vec3 (-999.);\n  dHit = eps;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ro + dHit * rd;\n    cId = floor (p / bGrid);\n    if (cId != cIdP) {\n      ObjState ();\n      cIdP = cId;\n    }\n    s = (bGrid * (cId + step (0., rd)) - p) * rdi;\n    d = abs (Minv3 (s)) + eps;\n    if (obRnd.x < obOcc && length (cId.xy - floor (TrackPath (bGrid * cId.z).xy / bGrid)) >= 1.)\n       d = min (d, ObjCDf (p - (bGrid * (cId + 0.5))));\n    dHit += d;\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjCNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0005, -0.0005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjCDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, len, rad, s, b;\n  dMin = dstFar;\n  len = 1.;\n  rad = 0.8;\n  p = flMat * (p - flPos);\n  q = p;\n  q.yz -= vec2 (-0.1 * rad, 0.3 * len);\n  b = length (q.xy);\n  s = (q.z > len) ? 16. * (atan (q.z - len, b) / (2. * pi) + 0.5) : 2. * q.z / len;\n  s = min (abs (fract (s) - 0.5), abs (fract (12. * atan (q.y, - q.x) / (2. * pi)) - 0.5));\n  d = 0.7 * max (max (PrCapsAnDf (q, rad, 0.01 * (1.5 - clamp (20. * s, 0.5, 1.75)), len),\n     -1.25 * len - 0.03 - q.z), 0.2 * rad - b);\n  DMINQ (idCage);\n  q = p;\n  q.yz -= vec2 (-0.17, 0.5);\n  scrMid = q.xy;\n  q.xy = Rot2D (q.xy, pi / 4.);\n  q.xy -= 1.02 * rScrn * sign (q.xy);\n  d = PrCylDf (q, rScrn, 0.003);\n  DMINQ (idScrn);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 80; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0005, -0.0005);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 StarPat (vec3 rd, float scl)\n{\n  vec3 tm, qn, u;\n  vec2 q;\n  float f;\n  tm = -1. / max (abs (rd), 0.0001);\n  qn = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  u = Maxv3 (tm) * rd;\n  q = atan (vec2 (dot (u.zxy, qn), dot (u.yzx, qn)), vec2 (1.)) / pi;\n  f = 0.57 * (Fbm2 (11. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 131.13 * scl * q) +\n      Fbm2 (13. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 171.13 * scl * q.yx));\n  return 5. * vec3 (1., 1., 0.8) * pow (f, 16.);\n}\n\nvec3 ErCol (vec3 rd)\n{\n  vec3 erDir, col, vn;\n  float erRad, bs, ts;\n  erDir = normalize (vec3 (0.02, -0.04, 1.));\n  erRad = 0.04;\n  col = vec3 (0.);\n  bs = dot (rd, erDir);\n  ts = bs * bs - 1. + erRad * erRad;\n  if (ts > 0.) {\n    ts = bs - sqrt (ts);\n    if (ts > 0.) {\n      vn = normalize ((ts * rd - erDir) / erRad);\n      col = mix (vec3 (0.3, 0.4, 0.8), vec3 (1., 1., 0.95),\n         smoothstep (0.2, 0.8, Fbm2 (6. * vn.xy + 7.1))) * (0.5 + 0.5 * max (- dot (vn, rd), 0.)) *\n         (0.2 + 0.8 * max (dot (vn, sunDir), 0.));\n    }\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  vec2 vf;\n  float dstObj, nDotS, t;\n  bool isScrn, showBg;\n  rScrn = 0.03;\n  isScrn = false;\n  showBg = true;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == idCage) {\n      col = mix (vec3 (0.45, 0.5, 0.5), vec3 (0.5, 0.5, 0.6), smoothstep (0.4, 0.6,\n         Fbm3 (64. * qHit)));\n      vn = VaryNf (128. * qHit, vn, 0.2);\n    } else if (idObj == idScrn) {\n      if (length (qHit.xy) < 0.95 * rScrn) {\n        qHit.xy = Rot2D (qHit.xy, - pi / 4.);\n        if (min (abs (qHit.x), abs (qHit.y)) > 0.03 * rScrn) {\n          ro = flPos;\n          rd = normalize (vec3 (qHit.xy, - rScrn)).xzy;\n          if (abs (scrMid.y) > abs (scrMid.x)) rd.yz = Rot2D (rd.yz, -0.25 * pi * sign (scrMid.y));\n          else rd.xy = Rot2D (rd.xy, 0.25 * pi * sign (scrMid.x));\n          ro += 0.5 * rd;\n          isScrn = true;\n        } else col = vec3 (0.7, 0.7, 0.8) * (0.7 + 0.3 * sin (4096. * length (qHit.xy)));\n      } else {\n        col = vec3 (0.5, 0.5, 0.6) * (0.7 + 0.3 * sin (256. * atan (qHit.y, qHit.x)));\n      }\n    }\n    if (! isScrn) {\n      nDotS = max (dot (vn, sunDir), 0.);\n      nDotS *= nDotS;\n      col = col * (0.3 + 0.3 * max (- dot (vn, sunDir), 0.) + 0.7 * nDotS * nDotS);\n      showBg = false;\n    }\n  }\n  if (dstObj >= dstFar || isScrn) {\n    dstObj = ObjCRay (ro, rd);\n    if (dstObj < dstFar) {\n      ro += dstObj * rd;\n      cId = floor (ro / bGrid);\n      ObjState ();\n      ro -= bGrid * (cId + 0.5);\n      vn = ObjCNf (ro);\n      vf = vec2 (0.);\n      if (idObj == idVbal) {\n        col4 = vec4 (0.5, 0.4, 0.2, 0.1);\n        vf = vec2 (8., 8.);\n      } else if (idObj == idVspk) {\n        col4 = vec4 (0.5, 0.6, 0.5, 0.4);\n        vf = vec2 (64., 0.1);\n      } else if (idObj == idVcap) {\n        col4 = vec4 (1., 0.2, 0.2, 0.3);\n        vf = vec2 (64., 2.);\n      }\n      if (! isScrn) {\n        t = 0.3 * tCur + obRnd.z;\n        if (idObj == idVbal) col4.rgb = mix (col4.rgb, vec3 (0.2, 1., 0.2), \n           SmoothBump (0.45, 0.55, 0.005, mod (t, 1.)));\n        else if (idObj == idVspk || idObj == idVcap) col4.rgb = mix (col4.rgb, vec3 (1., 1., 0.7),\n           SmoothBump (0.49, 0.51, 0.005, mod (0.5 * length (ro - obDisp) - t, 1.)));\n        if (vf.x > 0.) vn = VaryNf (vf.x * (obMat * (ro - obDisp)), obMat * vn, vf.y) * obMat;\n      }\n      col = col4.rgb * (0.2 + 0.2 * max (- dot (vn, sunDir), 0.) + 0.8 * max (dot (vn, sunDir), 0.)) +\n          col4.a * pow (max (dot (reflect (rd, vn), sunDir), 0.), 16.);\n      if (! isScrn) {\n        col = mix (col, ErCol (rd), smoothstep (0.6, 1., dstObj / dstFar));\n      } else {\n        col = mix (col, vec3 (0.), smoothstep (0.6, 1., dstObj / dstFar));\n        col = sqrt (Maxv3 (col)) * vec3 (0.5, 0.5, 1.);\n      }\n      showBg = false;\n    } else {\n      col = vec3 (0.);\n      if (! isScrn) col += ErCol (rd);\n    }\n  }\n  if (showBg) {\n    col = ErCol (rd);\n    if (length (col) < 0.03) col += StarPat (rd, 8.);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid FlyerPM (float s, float rl, float vu)\n{\n  vec3 vel, ort, ca, sa;\n  float el, az;\n  flPos = TrackPath (s);\n  vel = normalize (TrackVel (s));\n  el = -0.2 * asin (vel.y);\n  az = 0.2 * (atan (vel.z, vel.x) - 0.5 * pi);\n  rl = clamp (rl - 0.5 * TrackAcc (s).x, -0.3 * pi, 0.3 * pi);\n  ort = (vu >= 0.) ? vec3 (el, az, rl) : vec3 (- el, az + pi, - rl);\n  ca = cos (ort);\n  sa = sin (ort);\n  flMat = mat3 (ca.z, - sa.z, 0., sa.z, ca.z, 0., 0., 0., 1.) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x) *\n          mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y);\n}\n\n#define AA  0\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur = mod (tCur, 1800.) + 10.;\n  az = 0.;\n  el = -0.03 * pi;\n  if (mPtr.z > 0.) {\n    az += 1.5 * pi * mPtr.x;\n    el += 1.5 * pi * mPtr.y;\n    az = clamp (az, -0.5 * pi, 0.5 * pi);\n    el = clamp (el, -0.4 * pi, 0.4 * pi);\n  }\n  vuMat = StdVuMat (el, az);\n  spd = -2.;\n  obOcc = 0.4;\n  bGrid = 4.;\n  trkAx = 0.5 * vec3 (0.7, 0.8, 1.2);\n  trkAy = 0.5 * vec3 (1., 1.1, 0.9);\n  trkFx = vec3 (0.43, 0.33, 0.23);\n  trkFy = vec3 (0.41, 0.31, 0.12);\n  FlyerPM (spd * tCur, 0.1 * pi * (Fbm1 (0.01 * tCur) - 0.5), 1.);\n  ro = flPos;\n  zmFac = 2.6;\n  dstFar = 60.;\n  sunDir = normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    rd = vuMat * (rd * flMat);\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (pow (col, vec3 (0.9)), 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsAnDf (vec3 p, float r, float w, float h)\n{\n  p.z = abs (p.z);\n  return max (length (p - vec3 (0., 0., min (p.z, h + w))) - r,\n     - length (p - vec3 (0., 0., min (p.z, h - w))) + r) - w;\n}\n\nvec3 SphFib (vec3 v, float n)\n{   // Keinert et al's inverse spherical Fibonacci mapping\n  vec4 b;\n  vec3 vf, vfMin;\n  vec2 ff, c;\n  float fk, ddMin, dd, a, z, ni;\n  const float phi = 1.618034;\n  ni = 1. / n;\n  fk = pow (phi, max (2., floor (log (n * pi * sqrt (5.) * dot (v.xy, v.xy)) /\n     log (phi + 1.)))) / sqrt (5.);\n  ff = vec2 (floor (fk + 0.5), floor (fk * phi + 0.5));\n  b = vec4 (ff * ni, pi * (fract ((ff + 1.) * phi) - (phi - 1.)));\n  c = floor ((0.5 * mat2 (b.y, - b.x, b.w, - b.z) / (b.y * b.z - b.x * b.w)) *\n     vec2 (atan (v.y, v.x), v.z - (1. - ni)));\n  ddMin = 4.1;\n  for (int j = 0; j < 4; j ++) {\n    a = dot (ff, vec2 (j - 2 * (j / 2), j / 2) + c);\n    z = 1. - (2. * a + 1.) * ni;\n    vf = vec3 (sin (2. * pi * fract (phi * a) + vec2 (0.5 * pi, 0.)) * sqrt (1. - z * z), z);\n    dd = dot (vf - v, vf - v);\n    if (dd < ddMin) {\n      ddMin = dd;\n      vfMin = vf;\n    }\n  }\n  return vfMin;\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 VToRMat (vec3 v, float a)\n{\n  mat3 m;\n  vec2 cs;\n  float a1, a2;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  m[0][0] = (1. - cs.x) * v.x * v.x + cs.x;\n  m[1][1] = (1. - cs.x) * v.y * v.y + cs.x;\n  m[2][2] = (1. - cs.x) * v.z * v.z + cs.x;\n  a1 = (1. - cs.x) * v.x * v.y;\n  a2 = - cs.y * v.z;\n  m[0][1] = a1 + a2;\n  m[1][0] = a1 - a2;\n  a1 = (1. - cs.x) * v.z * v.x;\n  a2 = - cs.y * v.y;\n  m[2][0] = a1 + a2;\n  m[0][2] = a1 - a2;\n  a1 = (1. - cs.x) * v.y * v.z;\n  a2 = - cs.y * v.x;\n  m[1][2] = a1 + a2;\n  m[2][1] = a1 - a2;\n  return m;\n}\n\nvec3 RotToDir (vec3 v1, vec3 v2, vec3 p)\n{\n  vec3 n;\n  float c;\n  n = normalize (cross (v1, v2));\n  c = dot (v1, v2);\n  return c * p + sqrt (1. - c * c) * cross (n, p) + (1. - c) * dot (n, p) * n;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, vec3 (37., 39., 41.))) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (dot (p, cHashVA3) + vec4 (0., cHashVA3.xyz)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm3 (vec3 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv3 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdScD1.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1134, 1134, 1160, 1160, 1241], [1243, 1243, 1268, 1268, 1375], [1377, 1377, 1402, 1402, 1525], [1527, 1527, 1545, 1545, 1776], [1778, 1778, 1813, 1813, 2501], [2503, 2503, 2526, 2526, 2717], [2719, 2719, 2753, 2753, 3469], [3471, 3471, 3493, 3493, 3751], [3753, 3753, 3775, 3775, 4483], [4485, 4485, 4518, 4518, 4711], [4713, 4713, 4734, 4734, 4991], [4993, 4993, 5028, 5028, 5481], [5483, 5483, 5505, 5505, 6041], [6043, 6043, 6078, 6078, 9098], [9100, 9100, 9144, 9144, 9680], [9697, 9697, 9753, 9753, 11104], [11106, 11106, 11139, 11139, 11166], [11168, 11168, 11210, 11210, 11261], [11263, 11263, 11317, 11317, 11464], [11466, 11466, 11497, 11554, 12383], [12385, 12385, 12421, 12421, 12627], [12629, 12629, 12651, 12651, 12689], [12691, 12691, 12713, 12713, 12751], [12753, 12753, 12810, 12810, 12893], [12895, 12895, 12927, 12927, 13433], [13435, 13435, 13477, 13477, 13633], [13635, 13635, 13665, 13665, 13778], [13812, 13812, 13836, 13836, 13901], [13903, 13903, 13927, 13927, 13980], [13982, 13982, 14006, 14006, 14118], [14120, 14120, 14144, 14144, 14263], [14265, 14265, 14290, 14290, 14436], [14438, 14438, 14463, 14463, 14649], [14651, 14651, 14676, 14676, 14901], [14903, 14903, 14925, 14925, 15079], [15081, 15081, 15102, 15102, 15257], [15259, 15259, 15280, 15280, 15435], [15437, 15437, 15466, 15466, 15678], [15680, 15680, 15719, 15719, 15899]], "test": "error"}
{"id": "wdScD3", "name": "Tile Runner", "author": "bar4488", "description": "im  a noob but its something", "tags": ["noob"], "likes": 3, "viewed": 52, "published": "Public", "date": "1587417621", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a){\n\treturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x * 40.;\n    float columns = 30.;\n    float rows = 10.;\n    float interval = 0.03;\n    float rowInterval = columns * interval;\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv.x *= columns;\n    uv.y *= rows;\n    float column = floor(abs(mod(iTime/interval, columns * 2.) - columns)) + 1.;\n    float row = floor(abs(mod(iTime/rowInterval, rows * 2.) - rows)) + 1.;\n    //slot -= floor(slot);\n\tif(uv.x < column && uv.x > column-1.){\n        if( uv.y < row && uv.y > row-1.){\n        \tfragColor = vec4(0.0, 1.0, 0.0, 1.0);  \n        }\n    }\n    if(pow(uv.x - round(uv.x), 2.) < 0.01 || pow(uv.y - round(uv.y), 2.) < 0.01){\n    \tfragColor = vec4(abs(sin(iTime)) + 0.2, abs(sin(iTime*7.3)) + 0.2, abs(sin(iTime*4.)) + 0.2, 1.);\n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdScD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 64], [65, 65, 122, 240, 958]], "test": "valid"}
{"id": "wdscDs", "name": "smooth min/max trial", "author": "ankd", "description": "learning smooth min/max function from iq\nhttps://www.iquilezles.org/www/articles/smin/smin.htm", "tags": ["smooth"], "likes": 2, "viewed": 45, "published": "Public", "date": "1585906679", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = acos(-1.);\n#define SS smoothstep\n\n#define usin(x) (0.5+0.5*sin(x))\n#define ucos(x) (0.5+0.5*cos(x))\n\n// smooth min function from iq\n// https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat smin( float a, float b, float k ) { \n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0); \n}\nfloat smax( float a, float b, float k ) {\n    float h = max( k-abs(a-b), 0.0 )/k;\n\treturn max( a, b ) + h*h*k*(1./4.);\n}\n\nfloat line( in vec2 uv, in float y, in float w ) { return SS(y-w, y, uv.y) - SS(y, y+w, uv.y); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // calc equation value \n    float x = uv.x + iTime*0.1;\n    float v1 = usin(fract(x*1.3)*PI*2.);\n    float v2 = ucos(fract(x*2.3)*PI*2.);\n    \n    // calc smooth min/max\n    float k = 0.2*usin(iTime);\n    float vsmin = smin(v1, v2, k);\n    float vsmax = smax(v1, v2, k);\n\n    vec3 col = vec3(0.);\n    // draw equation value\n    col += line(uv, v1, 0.01) * vec3(1., 0., 0.);// red line = v1\n    col += line(uv, v2, 0.01) * vec3(0., 0., 1.);// blue line = v2\n\t// draw smooth min/max value\n    col = mix(col, vec3(1.,1.,0.), line(uv, vsmin, 0.01));// yellow line = smin\n    col = mix(col, vec3(0.,1.,1.), line(uv, vsmax, 0.01));// cyan line = smax\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdscDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[118, 206, 247, 247, 333], [334, 334, 375, 375, 454], [456, 456, 506, 506, 552], [554, 554, 611, 611, 1343]], "test": "error"}
{"id": "WdScDt", "name": "Noise demo (by spanditime)", "author": "spanditime", "description": "My first shader\n\nNOISE EVERYWHERE\n\ntodo list:\n-add:\n|- hairs\n|- nose\n|- mouth", "tags": ["noise", "random"], "likes": 3, "viewed": 77, "published": "Public", "date": "1587483423", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec2 p){\n    return fract(sin(p.x*102.33+p.y*3623.42)*27827.);\n}\n\nfloat smoothrand(vec2 p){\n    vec2 lv = fract(p);\n    vec2 id = floor(p);\n    \n    lv = lv*lv*(3.-2.*lv);\n    \n    float b = mix(rand(id),rand(id+vec2(1.,0.)),lv.x);\n\tfloat t = mix(rand(id+vec2(0.,1.)),rand(id+vec2(1.,1.)),lv.x);\n    \n    return mix(b,t,lv.y);\n}\n\nfloat noise(vec2 p,uint depth){\n    float c=0.;\n    float amp=1.;\n    float a=0.;\n    for(uint i = 0U;i<=depth;i++){\n        c+=smoothrand(p+vec2(float(i)))*amp;\n        \n        p*=2.*vec2(( (i%2U == 0U)?(-1.):(1.) ),( (i%2U == 0U)?(1.):(-1.) ));\n        a+=amp;\n        amp/=2.;\n    }\n    return c / a;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    float zoom = 1.4;\n    uv *= zoom;\n    \n    vec3 col;\n    vec2 bv = uv*0.5;\n    float t = iTime;\n    float len = length(bv);\n    col = vec3(noise(vec2(bv.x*bv.y,len-t),2U),noise(vec2(bv.x*bv.y+100.,len-t),2U),noise(vec2(bv.x*bv.y-100.,len-t),2U));\n    \n    \n    bv = uv;\n    bv.x = abs(uv.x) - 1.26;\n    bv.y += 0.702;\n    \n    \n    len = length(bv);\n    float v = 0.94 + noise(bv/len+vec2(150.,100.),2U)*0.06;\n    col = mix(vec3(0.),col,smoothstep(v*0.28 - 0.005,v*0.28,len));\n    float noisytexture = (1.-.12*noise(uv*3.,10U));\n    col = mix(vec3(.97*noisytexture,.77*noisytexture,.62*noisytexture),col,smoothstep(v*0.265-0.005,v*0.265,len));\n    \n    bv = uv;\n    \n    bv.y += 0.286;\n    bv.y *= 1.;\n    len = length(bv);\n     v = 0.94 + noise(bv/len+vec2(150.,100.),2U)*0.06;\n    col = mix(vec3(0.),col,smoothstep(v*1.41 - 0.005,v*1.41,len));\n    noisytexture = (1.-.12*noise(uv*3.,10U));\n    col = mix(vec3(.97*noisytexture,.77*noisytexture,.62*noisytexture),col,smoothstep(v*1.395-0.005,v*1.395,len));\n    \n    \n    \n    float xsign = sign(uv.x);\n    uv.x = abs(uv.x) - 0.629;\n    \n    len = length(uv);\n    v = 0.92 + noise((uv/len+vec2(100.+t,143.-t)*0.1)*1.,3U)*0.08;\n    col = mix(vec3(0.),col,smoothstep(v*0.5 - 0.005,v*0.5,len));\n    col = mix(vec3(1.),col,smoothstep(v*0.485-0.005,v*0.485,len));\n    \n    \n    \n    bv = uv;\n    float r = noise(vec2(t*1.),3U);\n    float sr = smoothrand(vec2(t));\n    bv -= vec2((.24*sin(r*6.28)*sr)*xsign,.2*cos(r*6.28)*sr);\n    len = length(bv);\n\tv = 0.2 + noise((bv/len+vec2(t*.6))*1.,3U)*0.8;\n    col = mix(vec3(0.),col,smoothstep(v*0.1-0.005,v*0.1,len));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdScDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 75], [77, 77, 102, 102, 339], [341, 341, 372, 372, 647], [649, 649, 706, 706, 2440]], "test": "valid"}
{"id": "WdscRf", "name": "大龙猫 - Quicky#029", "author": "totetmatt", "description": "I know, one day I'll need to learn a Ray marching by heart to start 3D :D ", "tags": ["instagram", "quicky"], "likes": 5, "viewed": 224, "published": "Public API", "date": "1586117848", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float fig(vec2 uv,float nb){\n    return smoothstep(0.005,0.01,abs(length(uv)-0.3+sin(iTime+atan(uv.x,uv.y)*nb)*.15)-.02);\n}\nmat2 r(float a){\n    float c=cos(a),s=sin(a);\n    return mat2(c,-s,s,c);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy -.5* iResolution.xy)/iResolution.y;\n    uv*=1.5;\n    float d = fig(uv,4.0);\n     float b = 0.;\n    for(float i=0.;i<=1.;i+=1./4.){\n        uv  = abs(uv)-.2;\n        uv *= r(i*3.14);\n        b +=fig(uv*r(i-iTime),3.0)*1./4.;\n    }\n      uv*=r(floor(length(sin(uv*10.)*.9)*10.));\n     float q = fig(uv,10.0);\n    vec3 col = vec3( (.5/d*b) + q ,(.3/d*b) + q  ,((sin(iTime+length(uv*10.))*.1+.2)/d*b) + q   );\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdscRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 123], [124, 124, 140, 140, 198], [199, 199, 254, 254, 721]], "test": "valid"}
{"id": "WdScRm", "name": "magic crystal thingy ma gig", "author": "trupples", "description": "i can into raymarching", "tags": ["raymarching"], "likes": 2, "viewed": 45, "published": "Public", "date": "1586275216", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//////////\n// Permutation polynomial: (34x^2 + x) mod 289\nvec3 permute(vec3 x) {\n  return mod((34.0 * x + 1.0) * x, 289.0);\n}\n\nvec3 dist(vec3 x, vec3 y, vec3 z,  bool manhattanDistance) {\n  return manhattanDistance ?  abs(x) + abs(y) + abs(z) :  (x * x + y * y + z * z);\n}\n\nvec2 worley(vec3 P, float jitter, bool manhattanDistance) {\nfloat K = 0.142857142857; // 1/7\nfloat Ko = 0.428571428571; // 1/2-K/2\nfloat  K2 = 0.020408163265306; // 1/(7*7)\nfloat Kz = 0.166666666667; // 1/6\nfloat Kzo = 0.416666666667; // 1/2-1/6*2\n\n    vec3 Pi = mod(floor(P), 289.0);\n    vec3 Pf = fract(P) - 0.5;\n\n    vec3 Pfx = Pf.x + vec3(1.0, 0.0, -1.0);\n    vec3 Pfy = Pf.y + vec3(1.0, 0.0, -1.0);\n    vec3 Pfz = Pf.z + vec3(1.0, 0.0, -1.0);\n\n    vec3 p = permute(Pi.x + vec3(-1.0, 0.0, 1.0));\n    vec3 p1 = permute(p + Pi.y - 1.0);\n    vec3 p2 = permute(p + Pi.y);\n    vec3 p3 = permute(p + Pi.y + 1.0);\n\n    vec3 p11 = permute(p1 + Pi.z - 1.0);\n    vec3 p12 = permute(p1 + Pi.z);\n    vec3 p13 = permute(p1 + Pi.z + 1.0);\n\n    vec3 p21 = permute(p2 + Pi.z - 1.0);\n    vec3 p22 = permute(p2 + Pi.z);\n    vec3 p23 = permute(p2 + Pi.z + 1.0);\n\n    vec3 p31 = permute(p3 + Pi.z - 1.0);\n    vec3 p32 = permute(p3 + Pi.z);\n    vec3 p33 = permute(p3 + Pi.z + 1.0);\n\n    vec3 ox11 = fract(p11*K) - Ko;\n    vec3 oy11 = mod(floor(p11*K), 7.0)*K - Ko;\n    vec3 oz11 = floor(p11*K2)*Kz - Kzo; // p11 < 289 guaranteed\n\n    vec3 ox12 = fract(p12*K) - Ko;\n    vec3 oy12 = mod(floor(p12*K), 7.0)*K - Ko;\n    vec3 oz12 = floor(p12*K2)*Kz - Kzo;\n\n    vec3 ox13 = fract(p13*K) - Ko;\n    vec3 oy13 = mod(floor(p13*K), 7.0)*K - Ko;\n    vec3 oz13 = floor(p13*K2)*Kz - Kzo;\n\n    vec3 ox21 = fract(p21*K) - Ko;\n    vec3 oy21 = mod(floor(p21*K), 7.0)*K - Ko;\n    vec3 oz21 = floor(p21*K2)*Kz - Kzo;\n\n    vec3 ox22 = fract(p22*K) - Ko;\n    vec3 oy22 = mod(floor(p22*K), 7.0)*K - Ko;\n    vec3 oz22 = floor(p22*K2)*Kz - Kzo;\n\n    vec3 ox23 = fract(p23*K) - Ko;\n    vec3 oy23 = mod(floor(p23*K), 7.0)*K - Ko;\n    vec3 oz23 = floor(p23*K2)*Kz - Kzo;\n\n    vec3 ox31 = fract(p31*K) - Ko;\n    vec3 oy31 = mod(floor(p31*K), 7.0)*K - Ko;\n    vec3 oz31 = floor(p31*K2)*Kz - Kzo;\n\n    vec3 ox32 = fract(p32*K) - Ko;\n    vec3 oy32 = mod(floor(p32*K), 7.0)*K - Ko;\n    vec3 oz32 = floor(p32*K2)*Kz - Kzo;\n\n    vec3 ox33 = fract(p33*K) - Ko;\n    vec3 oy33 = mod(floor(p33*K), 7.0)*K - Ko;\n    vec3 oz33 = floor(p33*K2)*Kz - Kzo;\n\n    vec3 dx11 = Pfx + jitter*ox11;\n    vec3 dy11 = Pfy.x + jitter*oy11;\n    vec3 dz11 = Pfz.x + jitter*oz11;\n\n    vec3 dx12 = Pfx + jitter*ox12;\n    vec3 dy12 = Pfy.x + jitter*oy12;\n    vec3 dz12 = Pfz.y + jitter*oz12;\n\n    vec3 dx13 = Pfx + jitter*ox13;\n    vec3 dy13 = Pfy.x + jitter*oy13;\n    vec3 dz13 = Pfz.z + jitter*oz13;\n\n    vec3 dx21 = Pfx + jitter*ox21;\n    vec3 dy21 = Pfy.y + jitter*oy21;\n    vec3 dz21 = Pfz.x + jitter*oz21;\n\n    vec3 dx22 = Pfx + jitter*ox22;\n    vec3 dy22 = Pfy.y + jitter*oy22;\n    vec3 dz22 = Pfz.y + jitter*oz22;\n\n    vec3 dx23 = Pfx + jitter*ox23;\n    vec3 dy23 = Pfy.y + jitter*oy23;\n    vec3 dz23 = Pfz.z + jitter*oz23;\n\n    vec3 dx31 = Pfx + jitter*ox31;\n    vec3 dy31 = Pfy.z + jitter*oy31;\n    vec3 dz31 = Pfz.x + jitter*oz31;\n\n    vec3 dx32 = Pfx + jitter*ox32;\n    vec3 dy32 = Pfy.z + jitter*oy32;\n    vec3 dz32 = Pfz.y + jitter*oz32;\n\n    vec3 dx33 = Pfx + jitter*ox33;\n    vec3 dy33 = Pfy.z + jitter*oy33;\n    vec3 dz33 = Pfz.z + jitter*oz33;\n\n    vec3 d11 = dist(dx11, dy11, dz11, manhattanDistance);\n    vec3 d12 =dist(dx12, dy12, dz12, manhattanDistance);\n    vec3 d13 = dist(dx13, dy13, dz13, manhattanDistance);\n    vec3 d21 = dist(dx21, dy21, dz21, manhattanDistance);\n    vec3 d22 = dist(dx22, dy22, dz22, manhattanDistance);\n    vec3 d23 = dist(dx23, dy23, dz23, manhattanDistance);\n    vec3 d31 = dist(dx31, dy31, dz31, manhattanDistance);\n    vec3 d32 = dist(dx32, dy32, dz32, manhattanDistance);\n    vec3 d33 = dist(dx33, dy33, dz33, manhattanDistance);\n\n    vec3 d1a = min(d11, d12);\n    d12 = max(d11, d12);\n    d11 = min(d1a, d13); // Smallest now not in d12 or d13\n    d13 = max(d1a, d13);\n    d12 = min(d12, d13); // 2nd smallest now not in d13\n    vec3 d2a = min(d21, d22);\n    d22 = max(d21, d22);\n    d21 = min(d2a, d23); // Smallest now not in d22 or d23\n    d23 = max(d2a, d23);\n    d22 = min(d22, d23); // 2nd smallest now not in d23\n    vec3 d3a = min(d31, d32);\n    d32 = max(d31, d32);\n    d31 = min(d3a, d33); // Smallest now not in d32 or d33\n    d33 = max(d3a, d33);\n    d32 = min(d32, d33); // 2nd smallest now not in d33\n    vec3 da = min(d11, d21);\n    d21 = max(d11, d21);\n    d11 = min(da, d31); // Smallest now in d11\n    d31 = max(da, d31); // 2nd smallest now not in d31\n    d11.xy = (d11.x < d11.y) ? d11.xy : d11.yx;\n    d11.xz = (d11.x < d11.z) ? d11.xz : d11.zx; // d11.x now smallest\n    d12 = min(d12, d21); // 2nd smallest now not in d21\n    d12 = min(d12, d22); // nor in d22\n    d12 = min(d12, d31); // nor in d31\n    d12 = min(d12, d32); // nor in d32\n    d11.yz = min(d11.yz,d12.xy); // nor in d12.yz\n    d11.y = min(d11.y,d12.z); // Only two more to go\n    d11.y = min(d11.y,d11.z); // Done! (Phew!)\n    return sqrt(d11.xy); // F1, F2\n\n}\n\n\n\n//////////\n\n\nfloat dstSphere(const in vec3 p, const in float r) {\n    return length(p)-r;\n}\n\nfloat dstBox(const in vec3 p, const in vec3 r) {\n    return length(max(abs(p), r)-r);\n}\n\n//float dstSquareTorus(const in vec3 p, const in float r, const int float thicc, const int float high) {\n    // daca e deasupra planului y=high/2 => p.y-high/2\n    // daca e dedesubt y=-high/2 => -p.y-high/2\n    // not quite\n    \n//}\n\nvec3 translate(const in vec3 p, const in vec3 shape_origin) {\n    return p-shape_origin;\n}\n\nvec3 twistY(const in vec3 p, const in float angle) {\n    return p * mat3(cos(angle), 0, sin(angle),\n              0,          .5,          0,\n             -sin(angle), 0, cos(angle));\n}\n\nfloat norm(const in vec3 v, float n) {\n    return pow(pow(v.x,n) + pow(v.y,n) + pow(v.z,n), 1.0/n);\n}\nfloat dstSphereN(const in vec3 p, const in float r, const in float no) {\n    return norm(p, no)-r;\n}\n\nfloat dstBoxN(const in vec3 p, const in vec3 r, const in float no) {\n    return norm(max(abs(p), r)-r, no);\n}\n\nfloat dist(vec3 p) {\n    float res = 1e38;\n    \n    const vec3 repeat_box = vec3(40.0, 40.0, 40.0);\n    \n    float rounding = 10.0-pow(abs(cos(iTime)),1.0)*10.0;\n    float N = 4.0;\n    float case_dist = max(-dstSphereN(twistY(p,iTime*0.1), 6.0, N), dstBoxN(twistY(p,iTime*0.1), vec3(5.0,5.0,5.0), N));\n    \n    // twist p\n    rounding = 7.0 - pow(sin(iTime*5.0), 8.0)*.2;\n    res = min(res, dstBox(twistY(p,p.y*0.5-iTime), vec3(5.0 - rounding,6.0 - rounding,2.0 - rounding)) - rounding);\n    \n    res = min(res, case_dist);\n                          \n    return res;\n}\n\nfloat grid_color(vec3 p) {\n    p *= 3.1415;\n    //p += vec3(10.0, 3.0, 12.0) * iTime;\n    return min(pow(cos(p.x),8.0)+pow(cos(p.y),8.0)+pow(cos(p.z),8.0), 3.0)/3.0;\n}\nfloat polkadot_color(vec3 p) {\n    p *= 3.1415;\n    //p += vec3(10.0, 3.0, 12.0) * iTime;\n    return min(pow(cos(p.x),2.0)*pow(cos(p.y),2.0)*pow(cos(p.z),4.0), 3.0)/3.0;\n}\n\n// vec4 iMouse  image/buffer    xy = current pixel coords (if LMB is down). zw = click pixel\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 scr = (fragCoord - iResolution.xy/2.0)/iResolution.x;\n\n    float camera_angle = iTime * 0.0, camera_dist = 20.0, F = .5;\n    vec3 camera_origin = vec3(cos(camera_angle)*camera_dist, camera_dist*0.5, sin(camera_angle)*camera_dist);\n    vec3 camera_right = vec3(-sin(camera_angle), 0, cos(camera_angle));\n    vec3 camera_up = normalize(cross(camera_right, camera_origin));\n    vec3 ray_direction = normalize(normalize(-camera_origin)*F + camera_right * scr.x + camera_up * scr.y);\n    vec3 ray_position = camera_origin;\n    \n    float d;\n    float num_hops = 0.0;\n    float closest = 1e38;\n    do {\n        d = dist(ray_position);\n        closest = min(closest, d);\n       ray_position += ray_direction * d;\n        num_hops += 1.0;\n    } while(d > 0.1 && length(ray_position) < 1000.0);\n    \n    vec3 p = ray_position;\n    float angle = p.y*0.5-iTime;\n    p *= mat3(cos(angle), 0, sin(angle),\n              0,          .5,          0,\n             -sin(angle), 0, cos(angle));\n    vec2 N = worley(p/2.0, 1.0, false);\n    vec3 col = (pow(abs(N.y-N.x),-0.4)) * normalize(ray_position)/2.0 + vec3(0.5,0.5,0.5);;\n    \n    if(length(ray_position) > 999.0) col = vec3(0.2, 0.2, 0.2);\n    \n    if(closest != d) col = vec3(pow(1.0-col.x, closest*2.0), col.y, col.z);\n    \n    fragColor = vec4(col,1.0);\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdScRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 58, 80, 80, 125], [127, 127, 187, 187, 272], [274, 274, 333, 333, 5102], [6117, 6117, 6137, 6137, 6685], [6687, 6687, 6713, 6713, 6854], [6855, 6855, 6885, 6885, 7026], [7122, 7122, 7179, 7234, 8549]], "test": "error"}
{"id": "WdScWR", "name": "Julia Sets - Chili's Upload", "author": "chilipepperhott", "description": "Graphing some julia sets", "tags": ["fractal"], "likes": 0, "viewed": 48, "published": "Public", "date": "1586376873", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float zoom = float(.5f);\n\nint jPix(){\n    vec2 complexLocation = vec2(sin(iTime), cos(iTime));\n    \n    int i = 0;\n    vec2 uv = gl_FragCoord.xy;\n\n    float zx = (float(uv.x) - float(iResolution.x) / float(2)) / (float(iResolution.x) / float(2)) / zoom;\n    float zy = (float(uv.y) - float(iResolution.y) / float(2)) / (float(iResolution.y) / float(2)) / (zoom * (iResolution.x / iResolution.y));\n\n    while (zx * zx + zy * zy < float(4) && i < 256)\n    {\n        float xTemp = zx * zx - zy * zy;\n        zy = float(2) * zx * zy + complexLocation.y;\n        zx = xTemp + complexLocation.x;\n\n        i++;\n    }\n\n    return i;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n    int i = jPix();\n\n    if (i > 255)\n        fragColor = vec4(1, 1, 1, 1.0);\n    else\n    {\n        float value = sqrt(float(i) / float(256));\n        fragColor = vec4(float(.2) * value, float(.2) * value, value, 1);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdScWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[628, 628, 683, 683, 913]], "test": "valid"}
{"id": "WdscWs", "name": "logistic_difference_v0013", "author": "darkczar", "description": "psychedelic, ok, so this is more about tan", "tags": ["trippy"], "likes": 2, "viewed": 54, "published": "Public", "date": "1585885912", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// based on...\n// https://www.shadertoy.com/view/lssfW2\n\nfloat nsin(float x)\n{\n    return .5+.5*sin(x);\n}\nfloat ncos(float x)\n{\n    return .5+.5*cos(x);\n}\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}  //https://gist.github.com/companje/29408948f1e8be54dd5733a74ca49bb9\n\nhighp float rand(vec2 co)  //from stackoverflow\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nuint hash( uint x ) {  //http://amindforeverprogramming.blogspot.com/2013/07/random-floats-in-glsl-330.html\n\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\nfloat random( float f ) {  //http://amindforeverprogramming.blogspot.com/2013/07/random-floats-in-glsl-330.html\n\n    const uint mantissaMask = 0x007FFFFFu;\n    const uint one          = 0x3F800000u;\n   \n    uint h = hash( floatBitsToUint( f ) );\n    h &= mantissaMask;\n    h |= one;\n    \n    float  r2 = uintBitsToFloat( h );\n    return r2 - 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float r = 0.0;\n    float g = 0.0;\n    float b = 0.0;\n    vec2 xy0 = vec2(0.,0.);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p=(fragCoord.xy-iResolution.xy)/iResolution.y;\n    \n    vec2 xy = vec2(0.,0.);\n    //xy = xy + 12.*vec2(8.*sin(12.*xy.x),8.*cos(12.*xy.y));\n    float rr = .35*(nsin(.15*iTime))+3.55; // + .5*nsin(iTime*.5); //2.57 +nsin(iTime); //+cos(iTime);\n    float spin = sin(p.x+.3*iTime) + cos(p.y+.3*iTime);\n    xy = uv + .08*vec2(.8*tan(20.*(p.y+spin)),.8*tan(20.*(p.x+spin)));;\n    for (int i = 0; i<8; i++)\n    {\n        xy.x = xy.x + .01*sin(xy.x*3.+iTime +float(i)*1.57);\n        xy.y = xy.y + .01*cos(xy.y*3.+iTime +float(i)*1.57);\n        xy = rr*xy*(vec2(1.,1.)- .2*xy -.25*vec2(xy.y,xy.x));\n        if(i==0)\n        {\n          xy0 = xy;  \n        }\n        if (i>0)\n            {\n                if(abs(length(xy) - length(xy0)) < .005 +.02*ncos(iTime*.15)) // try and tease out the cycles and color them\n                {\n                    r = 1.*random(float(mod(float(i),7.0)));\n                    g = 1.*random(1.8+float(mod(float(i),7.0)));\n                    b = 1.*random((1.30 - float(mod(float(i),7.0))));\n                }\n            }\n        if(i>6)\n        {\n            r=0.;\n            g=0.;\n            b=0.;\n        }\n    }\n    if (length(xy) > .25+1.0*sin(iTime*.15))\n    {\n        r = 1.0 - mod(length(xy),2.);\n        g = 0.2*pow(dot(normalize(xy),normalize(xy0)),4.0);\n        b = min(1.0,mod(2.,length(xy)));\n    }\n    if (dot(xy,xy0) > .50 +.05*nsin(iTime*.3))\n    {\n        r = pow(ncos(iTime*2.5),.5);\n        g = 2.0/dot(xy,xy0);\n        b = 1.0 - g;\n    }\n    if (dot(xy,xy0) < .5*nsin(iTime*.3))\n    {\n        r = 1.0 - pow(ncos(iTime*.3),.5);\n        g = 1.0 - 1.05/dot(xy,xy0);\n        b = 1.0 - pow(length(xy),4.);\n    }        \n        //m = (rand_point.x-prev_point.x) / ((rand_point.y-prev_point.y);\n        //line_y = m*p.x +  \n\n\n    \n    vec3 col = vec3(r, g, b);\n    float dn = col.x + col.y + col.z;\n    col /= dn;\n    // Output to screen\n    //fragColor = vec4(col,1.0);\n    fragColor = vec4( pow(col,vec3(1./2.2)),1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdscWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 79, 79, 106], [107, 107, 128, 128, 155], [156, 156, 228, 228, 294], [615, 615, 636, 722, 854], [855, 855, 880, 966, 1203], [1205, 1205, 1262, 1262, 3415]], "test": "valid"}
{"id": "wdScWt", "name": "Rectangle Rotating", "author": "Jaman", "description": "Rectangle that rotates", "tags": ["rectangle"], "likes": 0, "viewed": 206, "published": "Public API", "date": "1587495890", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float width = 0.05; // Width ratio of rectangle\nconst float height = 0.05; // Height ratio of rectangle\n\nvec2 func1(vec2 uv, float time) {\n\tfloat hypot = length(uv);\n    float uvang = atan(uv.y, uv.x);\n    float newang = uvang + time;\n\treturn hypot * vec2(cos(newang), sin(newang));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n    fragColor = vec4(0.25, 0.25, 0.25, 1.0);\n    \n    vec2 R = iResolution.xy;\n    vec2 uv = (fragCoord.xy -.5 * R) / R.y;\n    uv.x += cos(iTime) * 0.1;\n    \n    vec2 rot = func1(uv, iTime);\n    \n    rot = abs( rot ) - vec2( width, height );\n    if(rot.x <= width && rot.x >= -width && rot.y <= height && rot.y >= -height){\n        fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdScWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[111, 111, 144, 144, 290], [292, 292, 346, 346, 726]], "test": "valid"}
{"id": "wdScWw", "name": "Twitch: CupWorld(tm)", "author": "blackle", "description": "live coded on twitch in 1 hour. https://www.twitch.tv/videos/590568063\n\ncan you survive the incessant clanging in cupworld?", "tags": ["terrain", "cups", "livecode", "coffeecup"], "likes": 6, "viewed": 303, "published": "Public API", "date": "1586737894", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nfloat linedist(vec3 p, vec3 a, vec3 b) {\n  float k = dot(p-a, b-a)/dot(b-a, b-a);\n  return distance(p, mix(a, b, clamp(k,0.,1.)));\n}\nfloat linedist(vec2 p, vec2 a, vec2 b) {\n  float k = dot(p-a, b-a)/dot(b-a, b-a);\n  return distance(p, mix(a, b, clamp(k,0.,1.)));\n}\n\n#define FK(k) floatBitsToInt(cos(k))^floatBitsToInt(k)\nfloat hash(float a, float b) {\n  int x = FK(a);int y = FK(b);\n  return float((x*x-y)*(y*y+x)-y)/2.14e9;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax,p)*ax, p, cos(ro)) + sin(ro)*cross(ax,p);\n}\n\nvec3 idglob;\nfloat hsglob;\nint mat;\n\nfloat hillheight(vec2 p) {\n  float hillscale = 0.5;\n  return cos(dot(p.xy*hillscale, vec2(0.05,0.02)))*2.5\n  + cos(dot(p.xy*hillscale, vec2(0.01,0.03)))*2.5\n  + cos(dot(p.xy*hillscale, vec2(0.02,0.05)))*2.5\n  + cos(dot(p.xy*hillscale, vec2(0.08,0.05)))*2.5;\n}\n\nfloat scene(vec3 p) {\n  p.z += hillheight(p.xy);\n  float fl = p.z;\n\n  float scale = 10.;\n  vec2 id = floor(p.xy/scale);\n  idglob = idglob;\n  p.xy = (fract(p.xy/scale)-0.5)*scale;\n\n  \n  float seed = hash(id.x, id.y);\n  float h1 = hash(seed, seed);\n  float h2 = hash(h1, seed);\n  float h3 = hash(h2, seed);\n  float h4 = hash(h3, seed);\n  float h5 = hash(h4, seed);\n  float h6 = hash(h5, seed);\n  float arcx = fract(iTime+h6*5.);\n  p.z -= arcx*(1.-arcx)*10.;\n  hsglob = hash(h5, h5);\n  vec3 ax = normalize(tan(vec3(h1, h2, h3)));\n  vec3 off = vec3(0, 0, 1.2);\n  p -= off;\n  p = erot(p, ax, h4*100. + iTime);\n  \n  p = erot(p, vec3(0,0,1), h5*100.);\n  p.x += asin(sin(iTime*0.5*acos(-1.)));\n  p += off;\n  \n  float sphere = length(p.xy)-1.;\n  float crds = linedist(vec2(sphere, p.z), vec2(0,2.2), vec2(0,0))/sqrt(2.);\n  float bottom = linedist(vec2(length(p.xy), p.z), vec2(-0.5,0), vec2(1.,0))/sqrt(2.);\n  \n  float handle_skel = linedist(vec2(max(p.y,1.3), p.z), vec2(1.3,1.4), vec2(1.3,0.9))-0.3;\n  float handle = linedist(vec2(p.x, handle_skel), vec2(-0.2, 0.), vec2(0.2, 0.))/sqrt(2.);\n  handle = max(1.-p.y, handle);\n  float cup = 0.9*min(crds, min(bottom,handle))-0.05;\n  mat = 0;\n  if (fl < cup) {\n    mat = 1;\n    return fl;\n  }\n  return cup;\n}\n\nvec3 norm(vec3 p) {\n  mat3 k = mat3(p,p,p)-mat3(0.001);\n  return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\n#define ITERCOUNT 500\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n\n  vec3 cam =normalize(vec3(1,uv));\n  vec3 init = vec3(0,0,10);\n  float rot = 0.1;\n  float zrot = cos(iTime)*0.4-0.5;\n  cam = erot(cam, vec3(0,1,0), rot);\n  init = erot(init, vec3(0,1,0), rot);\n  cam = erot(cam, vec3(0,0,1), zrot);\n  init = erot(init, vec3(0,0,1), zrot);\n  init += fract(iTime/100.)*2000.*vec3(1,1,0);\n  init.z -= hillheight(init.xy) + sin(iTime)*5.;\n  vec3 p = init;\n  bool hit = false;\n  int i;\n  for (i = 0; i < ITERCOUNT && !hit; i++) {\n    float dist = scene(p);\n    hit = hit || dist*dist < 1e-6;\n    p += cam*dist;\n  }\n  float perc = float(i)/float(ITERCOUNT);\n  \n  vec3 idloc = idglob;\n  float hsloc = hsglob;\n  int matloc = mat;\n  \n  float fog = pow(exp(-distance(init, p)*0.05), .05);\n \n  vec3 n = norm(p);\n  vec3 r = reflect(cam, n);\n  float ao = sqrt(sqrt(scene(p+n*0.5)+0.5));\n  \n  vec3 col = pow(vec3(0.2,0.1,0.05), vec3(2));\n  col = abs(erot(col,vec3(1,0,0), hsloc*400.));\n  if (matloc == 1) {\n    col = abs(erot(col,vec3(0,1,0), hsloc*900.));\n  } else {\n    col = abs(erot(col,vec3(0,1,0), hsloc*1800.));\n  }\n  float factor = ao*length(sin(r*3.)*0.5+0.5)/sqrt(3.);\n  vec3 brass = mix(col, col*10., factor) + pow(factor, 7.);\n  vec3 bgcol = mix(vec3(0.6,0.3,0.8), vec3(0.3,0.6,.9), smoothstep(0., 1., uv.y+0.5));\n  \n  fragColor.xyz = hit ? mix(bgcol, brass, 1.-perc) : bgcol;\n  fragColor.xyz = sqrt(fragColor.xyz) + hash(hash(uv.x,uv.y),iTime)*0.02;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdScWw.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[194, 194, 234, 234, 326], [327, 327, 367, 367, 459], [516, 516, 546, 546, 621], [623, 623, 661, 661, 725], [764, 764, 790, 790, 1023], [1025, 1025, 1046, 1046, 2271], [2273, 2273, 2292, 2292, 2404], [2428, 2428, 2485, 2485, 3927]], "test": "valid"}
{"id": "wdSczm", "name": "Cherenkov radiation shockwave", "author": "Carandiru", "description": " the blue noise rabbit hole seems to be even more interesting\n than I originally thought with its applications in cg....", "tags": ["voxel", "shockwave", "iso", "radiation", "cherenkov"], "likes": 2, "viewed": 114, "published": "Public", "date": "1587363331", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// - carandiru\n// http://bit.ly/supersinfulsilicon\n\n// shader is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/wdSczm\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\n// ***Cherenkov radiation***\n// - a (almost) pure natural source of blue noise (reality)\n// emission is also blue light when observed\n// Cherenkov radiation is a particle emission that travels\n// faster than the speed of light inside a specific medium (like water)\n// but is still slower than the speed of light in a vacuum (space)\n\n// the hypothetical \"tachyon\" derives from this type of radiation\n// however has never been observed or proven that they exist\n// tachyon's would be particles that travel faster than the speed of light in a vacuum\n//\n// the blue noise rabbit hole seems to be even more interesting\n// than I originally thought with its applications in cg....\n\n#define PI (3.14159265358979323846)\n\n#define EPSILON 0.000000001f\n#define light rgb\n#define tran a\n#define MIN_STEP 0.00005f\t// absolute minimum before performance degradation or infinite loop, no artifacts or banding\n#define MAX_STEPS 256.0f\n#define WAVE_TIME_SCALAR 1.0f\n#define CAMERA_SPEED 0.111f\n#define REPEAT_MOD 3.5f\n#define ZOOM 0.4f  \t\t// less = more zoom\n\n#define sq(a) (a*a)\n\nconst float k_sqrtMaxSteps = sqrt(MAX_STEPS);\nconst vec3  k_eyePos = vec3(-120.0f, -84.851589f, -120.0f).xzy * 0.1f * ZOOM;\nconst float k_VolumeDimensions = (MAX_STEPS);\nconst float k_InvVolumeDimensions = 1.0f / k_VolumeDimensions;\n\nvec2 intersect_box(in vec3 orig, in vec3 dir) {\n\n\tvec3 inv_dir = 1.0f / dir;\n\tvec3 tmin_tmp = (vec3(-1.0f) - orig) * inv_dir;\n\tvec3 tmax_tmp = (vec3(1.0f) - orig) * inv_dir;\n\tvec3 tmin = min(tmin_tmp, tmax_tmp);\n\tvec3 tmax = max(tmin_tmp, tmax_tmp);\n\n\treturn vec2(max(tmin.x, max(tmin.y, tmin.z)), min(tmax.x, min(tmax.y, tmax.z)));\n}\n\n#define fma(a,b,c) ((a) * (b) + (c))\n\nvec3 v3_rotate_azimuth(in vec3 p, in float angle)\n{\n    vec2 inOrient = vec2(cos(angle), sin(angle));\n    \n\treturn vec3(fma(p.x, inOrient.x, -p.y * inOrient.y),\n\t\t\t\tfma(p.x, inOrient.y, p.y * inOrient.x),\n\t\t\t\tp.z);\n}\n\nfloat singlewave(float x, float t)\n{\n    float X = x - t * t;\n    return -cos(X) * exp(-X * X);\n}\n\nfloat tT;\nfloat fetch_wave_power(in vec3 v)\n{\n    return singlewave(length(v.xy), mod(tT, REPEAT_MOD));\n}\n\nfloat fetch_distance(in vec3 uvw)\n{   \n    return fetch_wave_power(uvw);\n\n    // power -> distance\n    // w = wavelength\n    // p = sq(w) / (sq(4pi) * sq(d))\n    // d = (w * sqrt(p)) / (4pi * p)\n    \n    //float d = (w * sqrt(p)) / (4.0*PI * p);\n}\n\nvec3 fetch_normal(in vec3 uvw, in vec3 rd, in float dt)\n{\n\tvec3 gradient;\n\n\tgradient.x = fetch_distance(uvw + (vec3(dt, 0.0f, 0.0f) * rd)) - fetch_distance(uvw - (vec3(dt, 0.0f, 0.0f) * rd));\n\tgradient.y = fetch_distance(uvw + (vec3(0.0f, dt, 0.0f) * rd)) - fetch_distance(uvw - (vec3(0.0f, dt, 0.0f) * rd));\n\tgradient.z = fetch_distance(uvw + (vec3(0.0f, 0.0f, dt) * rd)) - fetch_distance(uvw - (vec3(0.0f, 0.0f, dt) * rd));\n\n    // bugfix: nan, add epsilon\n\treturn( -normalize(gradient + EPSILON) ); // normal from central differences (gradient) \n}\n\nconst float grid_stroke = 0.666f;\nfloat comb(float v)\n{\n    return (grid_stroke * 0.5f) - 0.05f / pow(0.5 + 0.5 * cos(v * 2.0 * PI), 10.0);\n}\n\nfloat texGrid(vec3 v)\n{\n    v.xy = fract(v.xy * grid_stroke);\n    float q = 0.0;\n    q = max(q, comb(v.x));\n    q = max(q, comb(v.y));\n    return q;\n}\n\nvec2 texHeight(float d)\n{\n    return vec2(d, 1.0f - d);\n}\n\nvec3 eye;\nvec3 camera(in vec3 v)\n{\n    v.y -= 3.0f * (2.0f/3.0f); // center offset\n        \n    // orthographic isometry\n    vec3 iso;\n    iso.x =  v.x - v.y - v.z;\n    iso.y = -v.x - v.y - v.z;\n    iso.z =        v.y - v.z;\n    \n    iso = v3_rotate_azimuth(iso, tT * CAMERA_SPEED);\n    \n    // camera world position\n    eye = v3_rotate_azimuth(k_eyePos, tT * CAMERA_SPEED);\n    iso = iso * k_eyePos;\n\n    return iso;\n}\n\n// Cherenkov radiation\n// - a (almost) pure natural source of blue noise (reality)\n// emission is also blue light when observed\n// Cherenkov radiation is a particle emission that travels\n// faster than the speed of light inside a specific medium (like water)\n// but is still slower than the speed of light in a vacuum (space)\n\n// the hypothetical \"tachyon\" derives from this type of radiation\n// however has never been observed or proven that they exist\n// tachyon's would be particles that travel faster than the speed of light in a vacuum\n//\n// the blue noise rabbit hole seems to be even more interesting\n// than I originally thought with its applications in cg....\nfloat cherenkov_radiation(out float b, in float h, in float dt)\n{\n    const float c = 299792458.0f;  // universal constant for speed of light in a vacuum (m/s)\n    const float n = 1.33f; // refraction index of water\n    const float e = 10e5f; // total energy emitted\n    const float q = 24e3f; // energy in a particle\n    \n    // n = refraction index of medium\n    // c/n < v < c  : speed of particle is greater than speed of light\n    //\t\t\t\t  in the medium, but still less than the speed of light in a vacuum\n    // B = v/c\t\t: speed of particle in medium / speed of light\n    // cos = 1/(nB) : angle of emission\n    \n    // (modified) frank-tamm formula\n    // sq(d) * e      sq(q)                sq(c)\n    // ---------  =  -------  *  1 -  --------------- \n    //     d           4pi             sq(v) * sq(n)\n    \n    //                sq(q) * (sq(n)*sq(v) - sq(c))\n    //     d       = -------------------------------\n    //                  4 * e * pi * sq(n) * sq(v)\n    \n    float v = c/n;\n    v += (h) * v * dt;\n    v = min(v, c);\n    \n    b = (1.0f / (n * (v / c)));\n    \n    float d;\n    d = sq(q) * (sq(n)*sq(v) - sq(c));\n    d /= 4.0f * e * PI * sq(n) * sq(v);\n    \n    return (d);\n}\n\nconst vec3 grid_color = vec3(0.5f);\n// rgb(0.222f,0.222f,1.0f) (far depth color) - royal blue (cooler)\nconst vec3 royal_blue = vec3(0.222f,0.222f,1.0f); // components are maximized\n// rgb(0.80f,0.65f,1.0f) (near depth color) - royal purle (warmer) \nconst vec3 royal_purple = vec3(0.80f,0.65f,1.0f); // components are maximized\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    tT = iTime * WAVE_TIME_SCALAR;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n  \tvec2 v = uv*2.-1.;\n\t    \n    // init raymarch\n    vec3 ro = camera(vec3(v.xy, 1.0f));\n\n    vec3 rd = normalize(-ro);\n    \n    vec2 t_hit = intersect_box(ro, rd);\n\tif (t_hit.x > t_hit.y) {\n        discard;\n        //fragColor = vec4(0);\n        //return;\n\t}\n\n\tt_hit.x = max(t_hit.x, 0.0f);\n    \n\tfloat interval_length = (t_hit.y - t_hit.x);\n    \n    float inv_num_steps = 1.0f / length(k_VolumeDimensions * abs(rd)); // number of steps for full volume\n\tfloat dt = (interval_length) * inv_num_steps;\t// dt calculated @ what would be the full volume interval\n    dt = max(MIN_STEP, dt);\n    \n    vec3 p = eye + t_hit.x * rd + textureLod(iChannel1, uv, 0.0f).r * rd * dt * 0.5f; // start with bluenoise jitter offset (up to 1/2 dt)\n    \n    // begin volumetric raymarch\n    vec4 voxel = vec4(vec3(0.0f), 1.0f);\n\t\n    for( float interval_remaining = interval_length; \n         interval_remaining >= 0.0f ; interval_remaining -= dt ) \n    {  // fast sign test       \n\n        vec3 n = fetch_normal(p, rd, dt);\n        float d = fetch_distance(p);\n\t\t        \n        // signed distance (wave & grid)\n        vec2 height = texHeight(d);\n        float wave = (height.x + (1.0 - height.y)) * 0.5f + 0.5;\n        float grid = texGrid(p);\n        float dot_emission;\n        float rad = cherenkov_radiation(dot_emission, -d, dt);\n        \n        float NdotV = max(0.0f, dot(rd, n));\n        float fresnel = pow(1.0f - NdotV, 5.0f);\n        vec3 wave_light = royal_purple * royal_blue * dot_emission;\n        wave_light += fresnel * dot_emission * royal_blue;\n        \n        // grid fading\n        vec3 grid_light = grid_color * grid * (1.0f - voxel.tran);\n       \n        grid_light += pow((1.0f/(0.5f + d*d)) * grid, 5.0f) * royal_blue * wave_light;\n                               \n        vec3 light_color = mix(grid_light, wave_light, rad);\n\n        // integration\n        float sigmaS = wave + grid;\n\t\tfloat sigmaE = max(EPSILON, sigmaS); // to avoid division by zero extinction\n                \n        vec3 Li = light_color * sigmaS;// incoming light\n        float sigma_dt = exp2(sigmaE * k_sqrtMaxSteps * dt * -2.0f);\n        vec3 Sint = (Li - Li * sigma_dt) / sigmaE; // integrate along the current step segment\n\n        voxel.light += voxel.tran * Sint; // accumulate and also take into account the transmittance from previous steps\n\n        // Evaluate transmittance to view independentely (change in transmittance)\n        voxel.tran *= sigma_dt;\n\n        p += (dt) * rd;\n    }\n    \n    // Output to screen\n    fragColor = vec4(voxel.light * (1.0f - voxel.tran),1.0);\n}", "image_inputs": [{"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdSczm.jpg", "access": "shaders20k", "license": "cc-by-sa-4.0", "functions": [[1609, 1609, 1656, 1656, 1943], [1983, 1983, 2034, 2034, 2199], [2201, 2201, 2237, 2237, 2298], [2310, 2310, 2345, 2345, 2405], [2407, 2407, 2442, 2442, 2654], [2656, 2656, 2713, 2713, 3206], [3242, 3242, 3263, 3263, 3349], [3351, 3351, 3374, 3374, 3501], [3503, 3503, 3528, 3528, 3560], [3572, 3572, 3596, 3596, 3981], [4310, 4652, 4717, 4717, 5847], [6177, 6177, 6234, 6234, 8890]], "test": "error"}
{"id": "wdSczt", "name": "Crazy Shaker", "author": "creationix", "description": "Playing with bend.", "tags": ["sdf", "vr"], "likes": 3, "viewed": 80, "published": "Public", "date": "1587149451", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst int MAX_MARCHING_STEPS=256;\nconst float MIN_DIST=4.;\nconst float MAX_DIST=6.;\nconst float EPSILON=.0001;\n\n// Primitives from http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat sdSphere(vec3 p,float s)\n{\n    return length(p)-s;\n}\n\nfloat sdBox(vec3 p,vec3 b)\n{\n    vec3 q=abs(p)-b;\n    return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.);\n}\n\nfloat sdRoundBox(vec3 p,vec3 b,float r)\n{\n    vec3 q=abs(p)-b;\n    return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.)-r;\n}\n\nfloat sdVerticalCapsule(vec3 p,float h,float r)\n{\n    p.y-=clamp(p.y,0.,h);\n    return length(p)-r;\n}\n\nfloat sdCapsule(vec3 p,vec3 a,vec3 b,float r)\n{\n    vec3 pa=p-a,ba=b-a;\n    float h=clamp(dot(pa,ba)/dot(ba,ba),0.,1.);\n    return length(pa-ba*h)-r;\n}\n\nfloat opUnion(float d1,float d2){return min(d1,d2);}\n\nfloat opSubtraction(float d1,float d2){return max(-d1,d2);}\n\nfloat opIntersection(float d1,float d2){return max(d1,d2);}\n\nfloat opSmoothUnion(float d1,float d2,float k){\n    float h=clamp(.5+.5*(d2-d1)/k,0.,1.);\nreturn mix(d2,d1,h)-k*h*(1.-h);}\n\nfloat opSmoothSubtraction(float d1,float d2,float k){\n    float h=clamp(.5-.5*(d2+d1)/k,0.,1.);\nreturn mix(d2,-d1,h)+k*h*(1.-h);}\n\nfloat opSmoothIntersection(float d1,float d2,float k){\n    float h=clamp(.5-.5*(d2-d1)/k,0.,1.);\nreturn mix(d2,d1,h)+k*h*(1.-h);}\n\nvec3 rotateX(vec3 p,float angle){\n    return vec3(mat4(\n            1,0,0,0,\n            0,cos(angle),-sin(angle),0,\n            0,sin(angle),cos(angle),0,\n            0,0,0,1\n        )*vec4(p,0)\n    );\n}\n\nvec3 rotateY(vec3 p,float angle){\n    return vec3(mat4(\n            cos(angle),0,sin(angle),0,\n            0,1,0,0,\n            -sin(angle),0,cos(angle),0,\n            0,0,0,1\n        )*vec4(p,0)\n    );\n}\n\nvec3 rotateZ(vec3 p,float angle){\n    return vec3(mat4(\n            cos(angle),-sin(angle),0,0,\n            sin(angle),cos(angle),0,0,\n            0,0,1,0,\n            0,0,0,1\n        )*vec4(p,0)\n    );\n}\n\nvec3 repeat(in vec3 p,in vec3 c){\n    return mod(p+.5*c,c)-.5*c;\n}\n\nvec3 twist(in vec3 p,float k){\n    float c=cos(k*p.y);\n    float s=sin(k*p.y);\n    mat2 m=mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\nvec3 cheapBend(in vec3 p,float k){\n    float c=cos(k*p.x);\n    float s=sin(k*p.x);\n    mat2 m=mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\nfloat sdGrid(in vec3 p){\n    return sdSphere(repeat(p,vec3(.2,.8,.4)),.05);\n}\n\nfloat grimace(in vec3 p) {\n    return opSmoothUnion(\n        sdBox(cheapBend(p,sin(iTime*8.)),vec3(.8,.1,.3)),\n        sdBox(cheapBend(rotateY(p, iTime),cos(iTime*8.)),vec3(.8,.1,.3)),\n        .4\n    );\n}\n\nfloat sceneSDF(in vec3 p){\n    return grimace(rotateZ(rotateX(p, iTime),iTime*1.5));\n}\n\nvec4 render(in vec3 ro,in vec3 rd){\n    float depth=MIN_DIST;\n    int cost=MAX_MARCHING_STEPS;\n    for(int i=0;i<MAX_MARCHING_STEPS;i++){\n        float dist=sceneSDF(ro+depth*rd);\n        if(dist<EPSILON){\n            cost=i;\n            break;\n        }\n        depth+=dist;\n        if(depth>=MAX_DIST){\n            cost=i;\n            depth=MAX_DIST;\n            break;\n        }\n    }\n    if(cost==MAX_MARCHING_STEPS)depth=MAX_DIST;\n    \n    float hard=clamp(log(float(cost))/log(float(MAX_MARCHING_STEPS)),0.,1.);\n    float deep=clamp(1.-(depth-MIN_DIST)/(MAX_DIST-MIN_DIST),0.,1.);\n    \n    if(depth>MAX_DIST-EPSILON){\n        return vec4(hard*.5,hard,1.,hard*hard);\n    }\n    return vec4(vec3(deep-hard),1.);\n    //return vec4(hard*hard*1.5,hard*hard*hard*1.2,deep*deep*(1.-hard),1);\n    \n}\n\nvec3 rayDirection(float fieldOfView,vec2 size,vec2 fragCoord){\n    vec2 xy=fragCoord-size/2.;\n    float z=size.y/tan(radians(fieldOfView)/2.);\n    return normalize(vec3(xy,-z));\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    fragColor=render(\n        vec3(0.,0.,5.),// ray origin\n        rayDirection(50.,iResolution.xy,fragCoord)\n    );\n}\n\nvoid mainVR(out vec4 fragColor,in vec2 fragCoord,in vec3 fragRayOri,in vec3 fragRayDir)\n{\n    fragColor=render(\n        fragRayOri+vec3(0.,0.,2.),\n    fragRayDir);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdSczt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[200, 200, 232, 232, 258], [260, 260, 288, 288, 371], [373, 373, 414, 414, 499], [501, 501, 550, 550, 602], [604, 604, 651, 651, 755], [757, 757, 790, 790, 809], [811, 811, 850, 850, 870], [872, 872, 912, 912, 931], [933, 933, 980, 980, 1055], [1057, 1057, 1110, 1110, 1186], [1188, 1188, 1242, 1242, 1317], [1319, 1319, 1352, 1352, 1523], [1525, 1525, 1558, 1558, 1729], [1731, 1731, 1764, 1764, 1935], [1937, 1937, 1970, 1970, 2003], [2005, 2005, 2035, 2035, 2141], [2143, 2143, 2177, 2177, 2283], [2285, 2285, 2309, 2309, 2362], [2364, 2364, 2390, 2390, 2568], [2570, 2570, 2596, 2596, 2656], [2658, 2658, 2693, 2693, 3454], [3456, 3456, 3518, 3518, 3635], [3637, 3637, 3690, 3690, 3809], [3811, 3811, 3900, 3900, 3976]], "test": "valid"}
{"id": "WdsfD8", "name": "Orange stream", "author": "gaz", "description": "https://twitter.com/gaziya5/status/1255461113380077568", "tags": ["3d", "2tweets"], "likes": 5, "viewed": 104, "published": "Public", "date": "1588163242", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define F(a,n)a=abs(a)-n,a=vec2(a.x*.5+a.y,a.x-a.y*.5)\nvoid mainImage(out vec4 O, vec2 C) {\n\tfor(float g,e,i;i++<70.;){\n   \t\tvec3 p=g*vec3((C*2.-iResolution.xy)/iResolution.y,1);\n        p.z+=iTime;\n        p=fract(p)-.5;\n        for(int j=0;j++<8;)\n            F(p.zy,.0),\n            F(p.xz,.55);\n        g+=e=.4*length(p.yz)-2e-3;\n        e<.01?O+=vec4(.7,.2,.05,1)/i:O;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdsfD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 55, 91, 91, 381]], "test": "valid"}
{"id": "wdsfDH", "name": "Clouds 3D", "author": "murieron", "description": "Shader for In memoriam", "tags": ["cineshader"], "likes": 18, "viewed": 16636, "published": "Public API", "date": "1588199587", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// based in https://www.shadertoy.com/view/4sXGRM\n\nvec3 skytop = vec3(0.05, 0.2, 0.5);\n\nvec3 light = normalize(vec3(0.1, 0.25, 0.9));\n\nvec2 cloudrange = vec2(0.0, 10000.0);\n\nmat3 m = mat3(0.00, 1.60, 1.20, -1.60, 0.72, -0.96, -1.20, -0.96, 1.28);\n\n// hash function              \nfloat hash(float n)\n{\n    return fract(cos(n) * 114514.1919);\n}\n\n// 3d noise function\nfloat noise(in vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = smoothstep(0.0, 1.0, fract(x));\n        \n    float n = p.x + p.y * 10.0 + p.z * 100.0;\n    \n    return mix(\n        mix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n            mix(hash(n + 10.0), hash(n + 11.0), f.x), f.y),\n        mix(mix(hash(n + 100.0), hash(n + 101.0), f.x),\n            mix(hash(n + 110.0), hash(n + 111.0), f.x), f.y), f.z);\n}\n\n// Fractional Brownian motion\nfloat fbm(vec3 p)\n{\n    float f = 0.5000 * noise(p);\n    p = m * p;\n    f += 0.2500 * noise(p);\n    p = m * p;\n    f += 0.1666 * noise(p);\n    p = m * p;\n    f += 0.0834 * noise(p);\n    return f;\n}\n\nvec3 camera(float time)\n{\n    return vec3(5000.0 * sin(1.0 * time), 5000. + 1500. * sin(0.5 * time), 6000.0 * time);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float time = (iTime + 13.5 + 44.) * 1.0;\n    vec3 campos = camera(time);\n    vec3 camtar = camera(time + 0.4);\n\n    vec3 front = normalize(camtar - campos);\n    vec3 right = normalize(cross(front, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(right, front));\n    vec3 fragAt = normalize(uv.x * right + uv.y * up + front);\n    \n    // clouds\n    vec4 sum = vec4(0, 0, 0, 0);\n    for (float depth = 0.0; depth < 100000.0; depth += 200.0)\n    {\n        vec3 ray = campos + fragAt * depth;\n        if (cloudrange.x < ray.y && ray.y < cloudrange.y)\n        {\n            float alpha = smoothstep(0.5, 1.0, fbm(ray * 0.00025));\n            vec3 localcolor = mix(vec3(1.1, 1.05, 1.0), vec3(0.3, 0.3, 0.2), alpha);\n            alpha = (1.0 - sum.a) * alpha;\n            sum += vec4(localcolor * alpha, alpha);\n        }\n    }\n    \n    float alpha = smoothstep(0.7, 1.0, sum.a);\n    sum.rgb /= sum.a + 0.0001;\n\n    float sundot = clamp(dot(fragAt, light), 0.0, 1.0);\n    vec3 col = 0.8 * (skytop);\n    col += 0.47 * vec3(1.6, 1.4, 1.0) * pow(sundot, 350.0);\n    col += 0.4 * vec3(0.8, 0.9, 1.0) * pow(sundot, 2.0);\n    \n    sum.rgb -= 0.6 * vec3(0.8, 0.75, 0.7) * pow(sundot, 13.0) * alpha;\n    \n    sum.rgb += 0.2 * vec3(1.3, 1.2, 1.0) * pow(sundot, 5.0) * (1.0 - alpha);\n\n    col = mix(col, sum.rgb, sum.a);\n\n    fragColor = vec4(col, 1.0);\n    // fragColor = vec4(col, sum.a);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"Murieron\",\n\t\"description\": \"Homenaje a las víctimas del COVID-19\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdsfDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[248, 279, 300, 300, 342], [344, 365, 389, 389, 771], [773, 803, 822, 822, 1000], [1002, 1002, 1027, 1027, 1120], [1122, 1122, 1177, 1177, 2661]], "test": "valid"}
{"id": "WdsfR4", "name": "circular truchet", "author": "blepfo", "description": "https://en.wikipedia.org/wiki/Truchet_tiles", "tags": ["truchet", "tile"], "likes": 2, "viewed": 49, "published": "Public", "date": "1587792069", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141\n#define MAX_HISTORY 200\n#define MAX_SIMUL_ROTATIONS 50\n\n\nvec2 translate(\n\tvec2 uv,\n    vec2 t\n) {\n    return uv - t;\n}\n\nmat2 rotate2d(float theta) {\n    return mat2(cos(theta), -sin(theta),\n                sin(theta), cos(theta));\n}\n\nfloat random (vec2 uv, float bigSeed) {\n    return fract(sin(\n        dot(uv,vec2(12.9898,78.233)))\n                 *bigSeed);\n}\n\nfloat rectSdf(\n    vec2 uv,\n    vec2 halfSize\n) {\n\tvec2 edgeDist = abs(uv) - halfSize;\n    float insideDist = min(0., max(edgeDist.x, edgeDist.y));\n    float outsideDist = length(max(edgeDist, 0.));\n    return insideDist + outsideDist;\n}\n\nfloat circSdf(\n\tvec2 uv,\n\tfloat r\n) {\n    return length(uv) - r;\n}\n\nfloat annularSdf(\n\tfloat d, \n    float w\n) {\n    return abs(d) - w;\n}\n\nfloat unionSdf(float d1, float d2) {\n    return min(d1, d2);\n}\n\nfloat annulus(vec2 uv, float r, float w, float blur) {\n    float circ = circSdf(uv, r);\n    return smoothstep(0.-blur, 0.+blur, annularSdf(circ, w));\n}\n\nfloat baseTile(\n    vec2 uv,\n    float circW,\n    float blur\n) {\n    float circTr = annulus(translate(uv, vec2(1.)), 1., circW, blur);\n    float circBl = annulus(translate(uv, vec2(-1.)), 1., circW, blur);\n    float shape = 1. - unionSdf(circTr, circBl);\n    return  shape;\n}\n\nfloat randomGridSquare(\n\tvec2 scaledUv,\n    float iTime,\n    float scaleFactor,\n    float seed\n) {\n    float xRandom = scaleFactor * random(vec2(floor(iTime)), seed);\n    float yRandom = scaleFactor * random(vec2(xRandom), seed);\n    float xIdx = floor(mod(xRandom, scaleFactor));\n    float yIdx = floor(mod(yRandom, scaleFactor));\n\t// Create circular mask for smother rotation\n    vec2 circC = translate(vec2(xIdx, yIdx), vec2(-0.5));\n    float circMaskSdf = circSdf(translate(scaledUv, circC), 0.500);\n    float randomSquare = 1. - step(0., circMaskSdf);\n    return randomSquare;\n}\n\nfloat randomGridSquares(\n    int nSquares,\n\tvec2 scaledUv, \n    float iTime,\n    float scaleFactor,\n    float seed\n) {\n    float allSquares = 0.;\n    for (int i = 0; i < MAX_SIMUL_ROTATIONS; i++) {\n        if (i >= nSquares) { break; }\n        allSquares += randomGridSquare(scaledUv, iTime, scaleFactor, seed);\n        seed *= 2.;\n    }\n    return min(1., allSquares);\n}\n\nvec2 aggregateRotations(\n    vec2 fractUv,\n    vec2 scaledUv,\n    int nSquares,\n    float iTime,\n    float scaleFactor,\n    float seed\n) {\n    vec2 rotatedUv = fractUv;\n    // Keep track of all tile rotations for up to MAX_HISTORY\n\tfor (int historySecond = 0; historySecond < MAX_HISTORY; historySecond++) {\n        if (historySecond >= int(floor(mod(iTime, float(MAX_HISTORY))))) { break; }\n        float rotateSquare = randomGridSquares(\n            nSquares,\n            scaledUv, \n            float(historySecond), \n            scaleFactor, \n            seed\n        );\n        // Rotate 90 degrees \n        float theta = (PI / 2.) * rotateSquare;\n        rotatedUv *= rotate2d(theta);\n    }\n    return rotatedUv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    float scaleFactor = 14.;\n    vec2 scaledUv = uv * scaleFactor;\n    vec2 tileIdx = floor(scaledUv);\n    vec2 fractUv = fract(scaledUv);\n    fractUv = 2. * fractUv - 1.;\n    \n    float randSeed = 212034.331;\n    \n    // Random initial orientations\n    float rand = 2.*random(tileIdx, randSeed);\n\tfloat isEven = floor(mod(rand, 2.));\n\tfractUv.x *= 2.*isEven - 1.;\n    \n    float iTime = iTime;\n    iTime = mod(iTime, float(MAX_HISTORY));\n    // Move backwards in time once we reach MAX_HISTORY\n    float timeForward = 1. - step(float(MAX_HISTORY / 2), iTime);\n    iTime = (iTime * timeForward) + (float(MAX_HISTORY) - iTime) * (1. - timeForward);\n    \n    int nSquares = 10;\n    vec2 rotatedUv = aggregateRotations(\n        fractUv, \n        scaledUv, \n        nSquares, \n        iTime, \n        scaleFactor, \n        randSeed\n    );\n    //  Current rotation\n\tfloat rotateSquare = randomGridSquares(nSquares, scaledUv, iTime, scaleFactor, randSeed);\n    float theta = (PI / 2.) * fract(iTime) * rotateSquare;\n\trotatedUv *= rotate2d(theta);\n    \n    float shape = baseTile(\n        vec2(rotatedUv.x, rotatedUv.y),\n    \t.08,\n    \t.03\n    );\n    \n    vec3 color = vec3(0.013,0.185,0.380);\n    color = mix(color, vec3(1.000,0.978,0.858), shape);\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdsfR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[74, 74, 114, 114, 135], [137, 137, 165, 165, 249], [251, 251, 290, 290, 380], [382, 382, 431, 431, 619], [621, 621, 658, 658, 687], [689, 689, 733, 733, 758], [760, 760, 796, 796, 822], [824, 824, 878, 878, 975], [977, 977, 1041, 1041, 1252], [1254, 1254, 1352, 1352, 1837], [1839, 1839, 1957, 1957, 2210], [2212, 2212, 2350, 2350, 2931]], "test": "valid"}
{"id": "WdsfRM", "name": "checkerb", "author": "merrecurent_", "description": "simple circle inversion", "tags": ["noob"], "likes": 1, "viewed": 105, "published": "Public", "date": "1587934796", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n   \n    //vec2 p = .5*vec2(cos(iTime), sin(iTime));\n    //uv += p;\n\tuv.x *= iResolution.x/iResolution.y;\n    \n    //uv *= pow(fract(4.*uv), vec2(.3));\n    uv  *= 30.;\n    vec3 col = vec3(0.);\n    \n    float d = length(uv);\n    float r = 6.5;\n    float D = r*r/d;\n    vec2 new;\n    float wop = 3.5;\n    float smt = 1.;\n    float smt1 = 2.;\n    \n    new.x = (uv.x - wop*cos(iTime))*D/d;\n    new.y = (uv.y - wop*sin(iTime))*D/d;\n    \n    if(new.x < 0.) new.x -= smt*fract(smt1*iTime);\n        else if (new.x > 0.) new.x += smt*fract(smt1*iTime);\n    \n    if(new.y < 0.) new.y -= smt*fract(smt1*iTime);\n        else if (new.y > 0.) new.y += smt*fract(smt1*iTime);\n    \n    \n    for(float i = -30.; i <= 30.; i++)\n    {\n        new += vec2(i, -i);\n        for (float j = -30.; j <= 30.; j++)    \n    \t\tif (floor(new) == vec2(j))\n        \t\tcol += vec3(1.4 - .85*pow(.13*(abs(i) + abs(j)), 3.), 1.2 - 1.2*pow(.14*(abs(i) + abs(j)), 3.), 0.)\n                \t\t* smoothstep(floor(new.x)-.03, floor(new.x) + .03, new.x)\n                \t\t* smoothstep(floor(new.y)-.03, floor(new.y) + .03, new.y);\n            \n        \telse if (floor(new) == vec2(j-1., j))\n                col += vec3(.38 - 1.2*pow(.13*(abs(i) + abs(j)), 3.), .7 -1.15*pow(.12*(abs(i) + abs(j)), 3.), .85 - 1.1*pow(.13*(abs(i) + abs(j)), 3.))\n                \t    * smoothstep(floor(new.x -1.) - .03, floor(new.x - 1.) + .03, new.x)\n                \t\t* smoothstep(floor(new.y) - .03, floor(new.y) + .03, new.y);\n                \n    \t\telse col += vec3(0.);\n                \n        new -= vec2(i, -i);\n    }\n    \n    \n    \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdsfRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1725]], "test": "valid"}
{"id": "wdsfz7", "name": "coronapacman", "author": "FabriceNeyret2", "description": "reference: [img]https://static.boredpanda.com/blog/wp-content/uploads/2020/04/9-5ea2fa3a27cf1__700.jpg[/img]\nUncomment line16 to make them out of phase.", "tags": ["pacman", "short", "reproduction", "coronavirus", "covid19"], "likes": 15, "viewed": 385, "published": "Public API", "date": "1587976394", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(v)   smoothstep(1.5,0.,(v)/fwidth(v))  // antialiased draw // 15./R.y\n#define L(x,y) length(vec2(x,y))\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = 5.* ( 2.*u - R ) / R.y, V=U;\n    U.x = mod(U.x-3.*iTime, 4.)-2.;      // horizontal tranlation\n\n    float t = 2.*iTime, f,F,c,\n#define setT(t) f = fract(t), F = min(f,1.-f), c = F - A\n          a = atan(U.y,U.x), A = abs(a)/1.6, n = 6.,\n       // B = (2.-A) / (2.-F),           // normalized angle along deformed perimeter\n          l = length(U);\n    O-=O;\n // t += .06*V.x;                        // make them out of phase \n    \n    // --- body\n    setT(t);\n    O.g =   S ( l-1.) * S ( c*l );       // disk * pie\n    \n    // --- eye\n    a = a/1.6 - 1.5/(2.-F);              // local eye coordinates\n    O += S( L(a,l-.5) -.25 );            //   white part\n    O -= S( L(a,l-.5) -.12 ) * 2.;       //   black part\n // O += S( abs(a/1.6 - 1.5/(2.-F) )-.2 ) * S( abs(l-.5) - .25 ); // square\n    \n    // --- hairs\n    setT( t - .3*(l-1.) );               // deform: small time delay\n    A = fract( n* (2.-A) / (2.-F) ) -.5; // local hair ordinate\n    O.g += (   S( L(A,2.*(l-1.2)) -.2 )  //   disk + bar\n             + S( abs(A)-.1 ) * S ( abs(l-1.1)-.1 ) ) * S ( c*l );\n // O.g +=     S( A ) * S ( abs(l-1.2)-.2 )  * S ( c*l ) ;  // squares\n}", "image_inputs": [{"id": "XtS3Dm", "previewfilepath": "https://soundcloud.com/fabo-orlando/minimal-pacman", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/fabo-orlando/minimal-pacman", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdsfz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "valid"}
{"id": "Wdsfzr", "name": "Cornell Box Shangru", "author": "pandaleo", "description": "hw9", "tags": ["cis561"], "likes": 0, "viewed": 33, "published": "Public", "date": "1587611961", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat3 rotateY(float rad)\n{\n    return mat3(vec3(cos(rad), 0, -sin(rad)),\n                vec3(0, 1, 0),\n                vec3(sin(rad), 0, cos(rad))\n               );\n}\nmat3 rotateZ(float rad)\n{\n    return mat3(vec3(cos(rad), -sin(rad), 0),\n                vec3(sin(rad), cos(rad), 0),\n                vec3(0, 0, 1)\n               );\n}\nmat3 rotateX(float rad)\n{\n    return mat3(vec3(1, 0, 0),\n        \t\tvec3(0, cos(rad), -sin(rad)),\n                vec3(0, sin(rad), cos(rad))\n               );\n}\nmat3 scale(float a, float b, float c)\n{\n    return mat3(vec3(a, 0, 0), vec3(0, b, 0), vec3(0, 0, c));\n}\nmat3 scale(float a)\n{\n    return scale(a, a, a);\n}\nfloat sdfBox(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.) + length(max(d, 0.));\n}\nfloat sdfSphere(vec3 p)\n{\n    return length(p) - 0.5;\n}\nfloat sdfPlane(vec3 p)\n{\n    return dot(p, vec3(0, 0, 1));\n}\nvec2 closer(vec2 a, vec2 b)\n{\n    return a.x < b.x ? a: b;\n}\nfloat deg2rad(float r)\n{\n\treturn r / 180. * 3.14159;\n}\nvec2 map(vec3 pos) // find closest object\n{\n    vec3 sphereWorld = vec3(0.3, 0.3, -0.4);\n    vec3 posSphereModel = pos - sphereWorld; // position in sphere model space\n    vec2 sphereInfo = vec2(sdfSphere(posSphereModel), 1.);\n    \n    vec3 boxWorld = vec3(-0.35, -0.6, 0.3);\n    vec3 posBoxModel = inverse(rotateY(deg2rad(35.))) * (pos - boxWorld);\n    vec3 boxSize = vec3(0.2, 0.4, 0.2);\n    vec2 boxInfo = vec2(sdfBox(posBoxModel, boxSize), 2.);\n    \n    vec3 boxWorld2 = vec3(0.35, -0.8, 0.3);\n    vec3 posBoxModel2 = inverse(rotateY(deg2rad(60.))) * (pos - boxWorld2);\n    vec3 boxSize2 = vec3(0.22, 0.22, 0.22);\n    vec2 boxInfo2 = vec2(sdfBox(posBoxModel2, boxSize2), 8.);\n    \n    vec3 planeWorld1 = vec3(-1, 0, 0);\n    vec3 posPlaneModel1 = inverse(rotateY(3.14 / 2.)) * (pos - planeWorld1);\n    vec2 planeInfo1 = vec2(sdfPlane(posPlaneModel1), 3.);\n    \n    vec3 planeWorld2 = vec3(1, 0, 0);\n    vec3 posPlaneModel2 = inverse(rotateY(3. * 3.14 / 2.)) * (pos - planeWorld2);\n    vec2 planeInfo2 = vec2(sdfPlane(posPlaneModel2), 4.);\n    \n    vec3 planeWorld3 = vec3(0, 0, 0);\n    vec3 posPlaneModel3 = (pos - planeWorld3);\n    vec2 planeInfo3 = vec2(sdfPlane(posPlaneModel3), 5.);\n    \n    vec3 planeWorld4 = vec3(0, 1, 0);\n    vec3 posPlaneModel4 = inverse(rotateX(3. * 3.14 / 2.)) * (pos - planeWorld4);\n    vec2 planeInfo4 = vec2(sdfPlane(posPlaneModel4), 6.);\n    \n    vec3 planeWorld5 = vec3(0, -1, 0);\n    vec3 posPlaneModel5 = inverse(rotateX(3.14 / 2.)) * (pos - planeWorld5);\n    vec2 planeInfo5 = vec2(sdfPlane(posPlaneModel5), 7.);\n    \n    vec2 closest;\n    closest = closer(boxInfo, planeInfo1);\n    closest = closer(closest, planeInfo2);\n    closest = closer(closest, planeInfo3);\n    closest = closer(closest, planeInfo4);\n    closest = closer(closest, planeInfo5);\n    closest = closer(closest, boxInfo2);\n    return closest;\n}\nvec2 calcIntersection(in vec3 ro, in vec3 rd){\n    float currentMinSdf = 0.002;\n    float t = 0.0; // distance from ro (ray origin)\n\tfloat resDistance = -1.;\n    float id = -1.;\n    for (int i = 0; i < 100; ++i){\n        if (currentMinSdf < 0.001 || t > 10.) break; // hit or exceed max distance\n\t   \tvec2 hitInfo = map(ro + rd * t); // hit object distance and id\n        currentMinSdf = hitInfo.x; // distance\n        t += currentMinSdf; // update current distance from ro\n        id = hitInfo.y;\n    }\n    if (t <= 10.) resDistance = t; // if in distance\n    else id = -1.; // no hit\n    return vec2(resDistance, id);\n}\nvec3 calcNormal(in vec3 pos){\n    \n\tvec3 dx = vec3(0.001, 0.0, 0.0);    \n\tvec3 dy = vec3(0.0, 0.001, 0.0);    \n\tvec3 dz = vec3(0.0, 0.0, 0.001);\n\tvec3 nor = vec3(\n\t    map(pos + dx).x - map(pos - dx).x,\n\t    map(pos + dy).x - map(pos - dy).x,\n\t    map(pos + dz).x - map(pos - dz).x\n    );\n\treturn normalize(nor);\n}\nvec3 render(vec2 res, in vec3 ro, in vec3 rd)\n{\n    float ambient = 0.05;\n    vec3 color = vec3(0);\n    float lightX = 0.5 * sin(iTime * 4.);\n    vec3 lightPos = vec3(lightX, 0.9, 0.8);\n    if (res.y > 0.) // id\n    {\n    \tvec3 pos = ro + rd * res.x;\n    \tvec3 norm = calcNormal(pos);\n    \tvec3 lightDir = normalize(lightPos - pos);\n        float match = max(0., dot(lightDir, norm) / pow(length(lightPos - pos), 0.3));\n        if (res.y == 1.) color = vec3(1., 0., 0.) * match + ambient;\n        else if (res.y == 2.) color = vec3(0.4, 0.4, 0.4) * match + ambient;\n\t\telse if (res.y == 3.) color = vec3(1, 0, 0) * match + ambient;\n        else if (res.y == 4.) color = vec3(0, 1, 0) * match + ambient;\n\t\telse if (res.y == 5.) color = vec3(1, 1, 1) * match + ambient;   \n        else if (res.y == 6.) color = vec3(0.5, 0.5, 0.5) * match + ambient;\n\t\telse if (res.y == 7.) color = vec3(1, 1, 1) * match + ambient;  \n\t\telse if (res.y == 8.) color = vec3(1, 1, 1) * match + ambient;   \n    }\n    return color;\n}\nmat3 lookAt(in vec3 eye, in vec3 ref)\n{\n    vec3 front = normalize(ref - eye);\n    vec3 right = normalize(cross(front, vec3(0, 1, 0)));\n    vec3 up = normalize(cross(right, front));\n    return mat3(right, up, front);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n    vec3 eye = vec3(0, 0, 2), ref = vec3(0, 0, 0);\n    vec3 direction = normalize(lookAt(eye, ref) * vec3(p.xy, 1));\n    vec2 res = calcIntersection(eye, direction);\n    fragColor = vec4(render(res, eye, direction), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wdsfzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 166], [167, 167, 192, 192, 333], [334, 334, 359, 359, 494], [495, 495, 534, 534, 598], [599, 599, 620, 620, 649], [650, 650, 680, 680, 773], [774, 774, 799, 799, 829], [830, 830, 854, 854, 890], [891, 891, 920, 920, 951], [952, 952, 976, 976, 1006], [1007, 1007, 1050, 1050, 2859], [2860, 2860, 2906, 2906, 3481], [3482, 3482, 3511, 3511, 3796], [3797, 3797, 3844, 3844, 4804], [4805, 4805, 4844, 4844, 5023], [5024, 5024, 5081, 5081, 5370]], "test": "error"}
{"id": "wdSyD3", "name": "Clouds on Jupiter", "author": "jarble", "description": "This is an edit of my [url=https://www.shadertoy.com/view/3sBcD3]\"Kaleidoscopic Lava\"[/url] shader.", "tags": ["fractal", "clouds", "jupiter"], "likes": 2, "viewed": 246, "published": "Public API", "date": "1587414676", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//This parameter changes the magnification.\nconst float mag = 15.0;\nconst float distortion_scale = mag*mag;\n\nconst int GREEN = 0;\nconst int BLUE = 1;\nconst int GRAY = 2;\nconst int YELLOW = 3;\nconst int WHITE = 4;\nconst int FOREST_GREEN = 5;\nconst int LIGHTBLUE = 6;\nconst int SKYBLUE = 7;\nconst int SNOW = 8;\nconst int WHITESMOKE = 9;\nconst int LIGHTGRAY = 10;\nconst int LIME = 11;\nconst int LIGHTYELLOW = 12;\nconst int BEIGE = 13;\nconst int SAND = 14;\nconst int TAN = 15;\nconst int ORANGE = 16;\nconst int RED = 17;\nconst int BLACK = 18;\nconst int DARKGRAY = 19;\nconst int ORANGERED = 20;\n\nconst int SWAMP_BIOME = 1;\nconst int GLACIER_BIOME = 2;\nconst int FORESTS_AND_MOUNTAINS = 3;\nconst int SAVANNA_BIOME = 4;\nconst int FOREST_BIOME = 5;\n\n//this function is from https://www.shadertoy.com/view/4djSRW\nint hash12(vec2 p,float num_colors)\n{\n    //set the number of colors to be randomly generated\n    p = sin(p.xx-p.yy);\n    vec3 p3 = (vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return int(floor(fract((p3.x + p3.y) * p3.z)*num_colors));\n}\n    \nint magnify(vec2 fragCoord,float mag,float num_colors){\n    //fragCoord += vec2(sin(fragCoord.y/(distortion_scale*mag)+iTime),sin(fragCoord.x/(distortion_scale*mag)+iTime))*10.0*mag*mag;\n\n    return hash12(floor(fragCoord/pow(3.0,mag)),num_colors);\n}\n\nivec4 get_neighbors(vec2 fragCoord,float mag,float colors){\n\treturn ivec4(magnify(fragCoord+vec2(0,1),mag,colors),\n        magnify(fragCoord+vec2(1,0),mag,colors),\n        magnify(fragCoord-vec2(0,1),mag,colors),\n        magnify(fragCoord-vec2(1,0),mag,colors));\n}\n\n\nbool is_next_to(int color,ivec4 neighbors){\n\treturn (neighbors.x == color)\n        || (neighbors.y == color)\n        || (neighbors.z == color)\n        || (neighbors.w == color);\n}\n\nvec3 rgb(float r,float g,float b){\n\treturn vec3(r,g,b)/255.0;\n}\n\nvec3 get_color(int color){\n    if(color == BLUE){\n    \treturn vec3(0.149,0.141,0.912);\n   \t}\n    else if(color == GREEN){\n    \treturn vec3(0.000,0.833,0.224);\n   \t}\n    else if(color == FOREST_GREEN){\n    \treturn rgb(34.0,139.0,34.0);\n   \t}\n    else if(color == WHITE){\n    \treturn vec3(1.0,1.0,1.0);\n   \t}\n    else if(color == GRAY){\n    \treturn vec3(192.0,192.0,192.0)/255.0;\n    }\n    else if(color == YELLOW){\n    \treturn vec3(1.0,1.0,0.0);\n   \t}\n    else if(color == LIGHTBLUE){\n    \treturn rgb(173.0,216.0,230.0);\n   \t}\n    else if(color == SKYBLUE){\n    \treturn rgb(135.0,206.0,235.0);\n    }\n    else if(color == SNOW){\n    \treturn rgb(255.0,250.0,250.0);\n    }\n    else if(color == WHITESMOKE){\n    \treturn rgb(245.0,245.0,245.0);\n    }\n    else if(color == LIGHTGRAY){\n    \treturn rgb(211.0,211.0,211.0);\n    }\n    else if(color == LIME){\n    \treturn rgb(0.0,255.0,0.0);\n    }\n    else if(color == LIGHTYELLOW){\n    \treturn rgb(255.0,255.0,153.0);\n    }\n    else if(color == BEIGE){\n    \treturn rgb(245.0,245.0,220.0);\n    }\n    else if(color == TAN){\n    \treturn rgb(210.,180.,140.);\n    }\n    else if(color == ORANGE){\n    \treturn vec3(255,127,80)/255.0;\n    }\n    else if(color == RED){\n    \treturn vec3(1.0,0.0,0.0);\n   \t}\n    else if(color == DARKGRAY){\n    \treturn rgb(128.0,128.0,128.0);\n    }\n    else if(color == ORANGERED){\n    \treturn rgb(255.0,69.0,0.0);\n    }\n}\n\n\nint glacier_biome(inout int color1, ivec4 neighbors){\n\tint GREEN = 0;\n    int BLUE = 1;\n    int GRAY = 2;\n    int WHITE = 3;\n    int YELLOW = 4;\n    \n    return (color1 == GREEN && is_next_to(BLUE,neighbors))\n        ? GRAY\n    : (color1 == GREEN && is_next_to(WHITE,neighbors))\n        ? GRAY\n    : (color1 == BLUE && is_next_to(GREEN,neighbors))\n        ? WHITE\n    : (color1 == YELLOW && is_next_to(GREEN,neighbors))\n        ? GRAY\n    : (color1 == YELLOW && is_next_to(GRAY,neighbors))\n        ? BLUE\n    :(color1 == WHITE && is_next_to(YELLOW,neighbors))\n        ? GRAY\n    :(color1 == YELLOW && is_next_to(WHITE,neighbors))\n        ? WHITE\n    :(color1 == GRAY && is_next_to(BLUE,neighbors))\n        ? BLUE\n    :color1;\n}\n\nvoid biome(inout int color1, ivec4 neighbors,int biome){\n    color1 =\n        glacier_biome(color1,neighbors);\n}\n\nvec3 biome(in vec2 fragCoord,float mag,float zoom,int colors[5],int biome1){\n    fragCoord *= zoom;\n    fragCoord += vec2(sin(fragCoord.y/(distortion_scale*mag)+iTime),sin(fragCoord.x/(distortion_scale*mag)+iTime))*10.0*mag*mag;\n\n    float num_colors = float(colors.length());\n\n    int color1 = magnify(fragCoord,mag,num_colors);\n\n    \n    ivec4 neighbors;\n    vec3 color;\n    float steps = 0.0;\n    while(mag > 1.0){\n        float avg =(100.0*(mag/float(color1)));\n        fragCoord += vec2(sin(fragCoord.y/avg+iTime)*10.0,sin(fragCoord.x/avg+iTime)*10.0)*mag*mag;\n\n    neighbors = get_neighbors(fragCoord,mag,num_colors);\n    biome(color1, neighbors,biome1);\n    mag -= 1.0;\n    steps += 1.0;\n    color += get_color(colors[int(color1)]);\n\n    }\n\n    return color/steps;\n}\n\n\nvec3 glacier_biome(in vec2 fragCoord,float mag,float zoom,int[5] colors){\n    return biome(fragCoord,mag,zoom,colors,GLACIER_BIOME);\n}\n\nvec3 lava_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn glacier_biome(fragCoord,mag,zoom,int[](DARKGRAY,YELLOW,ORANGERED,ORANGE,ORANGERED));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = mag;\n    fragCoord *= zoom*(((iMouse.x-iMouse.y)*2.0+iResolution.x)/iResolution.x);\n    fragCoord = fragCoord + floor(iTime*100.0)*vec2(zoom,0.0);\n    \n\tvec3 biome = lava_biome(fragCoord,mag,1.0);\n    \n    fragColor = vec4(biome,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdSyD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[742, 804, 841, 897, 1058], [1064, 1064, 1119, 1250, 1314], [1316, 1316, 1375, 1375, 1580], [1583, 1583, 1626, 1626, 1762], [1764, 1764, 1798, 1798, 1827], [1829, 1829, 1855, 1855, 3212], [3215, 3215, 3268, 3268, 3942], [3944, 3944, 4000, 4000, 4056], [4058, 4058, 4134, 4134, 4831], [5124, 5124, 5181, 5181, 5435]], "test": "error"}
{"id": "wdSyDG", "name": "Octahedralis II", "author": "sl2c", "description": "Version of https://www.shadertoy.com/view/WdSyDh with anti-aliasing and a different zoom-in.", "tags": ["fractal", "circles", "hyperbolic"], "likes": 9, "viewed": 107, "published": "Public", "date": "1588090892", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Copyright 2020 Google LLC\n// SPDX-License-Identifier: Apache-2.0\n// NOT an official Google project; see Google Open Source guidelines for more info on copyright transfer\n// written by William Cadegan-Schlieper \nfloat s = 0.4142135623730951; // silver ratio\n\nvoid octant1(inout vec2 z, inout float ds, inout vec3[3] colors) {\n    if (z.x < 0.0) {\n        z.x = -z.x;\n        colors[2]=1.0-colors[2];\n    }\n    if (z.y < 0.0) {\n        z.y = -z.y;\n        colors[1]=1.0-colors[1];\n    }\n    float r2 = dot(z,z);\n    if (r2 > 1.0) {\n        z /= r2; ds /= r2;\n        colors[0]=1.0-colors[0];\n    }\n}\n\nvec3 color(vec2 z, float ds, bool fl) {\n    vec3[3] colors;\n    colors[0]=vec3(1.0,0.5,0.0);\n    colors[1]=vec3(0.0,1.0,0.5);\n    colors[2]=vec3(0.5,0.0,1.0);\n    \n    if (fl) {\n        colors[0]=1.0-colors[0];\n        colors[1]=1.0-colors[1];\n        colors[2]=1.0-colors[2];\n    }\n    \n    float r2;\n    int n = 60;\n    int i;\n    for(i=0;i<n;i++) {\n        octant1(z, ds, colors);\n        z -= vec2(s,s);\n        r2 = dot(z,z);\n        if (r2 < s * s) {\n            z *= s * s / r2; ds *= s * s / r2;\n            fl = !fl;\n            z += vec2(s,s);\n        } else {\n            z += vec2(s,s);\n        \tbreak;\n        }\n    }\n    octant1(z, ds, colors);\n    r2 = dot(z,z);\n    float v = (r2 - 2.0 * (z.x + z.y) * s + s * s) / (2.0 * ds * s * s);\n    v = min(v,1.0);\n    v = 0.75 + 0.25 * float(n-i) / float(n) * v;\n    if (fl) v = 1.5 - v;\n    float zz = 0.5 * (1.0 - r2);\n    if (zz > z.x && zz > z.y) {\n        return colors[0] * v * min(1.0, min((zz - z.x) / ds, (zz - z.y) / ds));\n    }\n    if (z.y > z.x) {\n        return colors[1] * v * min(1.0, min((z.y - zz) / ds, (z.y - z.x) / ds));\n    }\n    return colors[2] * v * min(1.0, min((z.x - zz) / ds, (z.x-z.y) / ds));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = 2.0 * (fragCoord - iResolution.xy * 0.5)/iResolution.y;\n    float ds = 4.0 / iResolution.y;\n    \n    float period = 4.2549485065150545;\n    float t = iTime * 0.5;\n    bool r = false;\n    \n    while (t > period * 0.5) {\n        t -= period;\n        float c = 0.766311365; float s = -0.64246936;\n        uv = vec2(uv.x * c - uv.y * s, uv.x * s + uv.y * c);\n        r = !r;\n    }\n    \n    uv *= exp(-t); ds *= exp(-t);\n    \n    uv += vec2(0.25262046414724887,-1.0187347727326157);\n\tuv /= dot(uv,uv); ds *= dot(uv,uv);\n    uv += vec2(0.22732631827540598,0.4228686518338363);\n\n    fragColor = vec4(color(uv,ds,r),1.0);\n    fragColor = pow(fragColor, vec4(1./2.2));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdSyDG.jpg", "access": "shaders20k", "license": "apache-2.0", "functions": [[1784, 1784, 1839, 1839, 2515]], "test": "valid"}
{"id": "wdSyDh", "name": "❤️ for lug00ber", "author": "Alie", "description": "Just ❤️ for lug00ber :P\n\nQuick hack as a background for the revision 2020 livestream during his DJ set. Expect code to look like a quick hack.", "tags": ["raymarching", "heart"], "likes": 0, "viewed": 206, "published": "Public API", "date": "1586531549", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Rotation\n#define R(p,a) p=cos(a)*p+sin(a)*vec2(-p.y,p.x);\n#define kPI 3.141592\n\n// maximum iteration count\n#define kMAXITERS 100\n#define kEPSILON 0.001\n    \nfloat dist(in vec3 p){\n    // Rotate\n    R(p.xz, iTime*.3);\n    // Scale Z to flatten\n    p.z *= 1.7;\n    // Shift on Y to form heart\n    //p.y -= smoothstep(0., 1., abs(p.x)) / 2.;\n    //p.y -=pow(abs(p.x)/2.,1.7)*1.3;\n    p.y -=pow(abs(p.x)/2.,-p.y*.3+1.5)*1.3;\n    // Scale X to widen\n    p.x *=.8;\n \treturn length(p) - 1.5;   \n}\n\n// Gets the normal\nvec3 normal(in vec3 p) {\n    vec2 eps = vec2(0.0001, 0);\n    float baseDist = dist(p);\n \treturn normalize(vec3(\n        dist(p + eps.xyy) - baseDist,\n        dist(p + eps.yxy) - baseDist,\n        dist(p + eps.yyx) - baseDist\n        ));\n}\n\n// Calulcate a fresnel term for reflections\nfloat fresnelTerm(in vec3 d, in vec3 n, in float power) {\n\tfloat fresnel = min(1., dot(d, n) + 1.0);\n\tfresnel = pow(fresnel, power);\n    return fresnel;\n}\n\nvec4 iC(vec3 p, vec3 d,vec3 ba, vec3 bb){\n\tvec3 a=(ba-p)/d, // near\n\tb=(bb-p)/d, // far\n\tf=max(a,b), // furthest\n\tn=min(a,b); // nearest\n\tfloat x=min(f.x,min(f.y,f.z)), // furthest plane\n\tdist=max(n.x,max(n.y,n.z)), // nearest plane\n\to=dist<0.?x:dist; // nearest in front\n\t//if(dist>=x||o<0.) return vec4(0,0,0,-100.); // d>=x = invalid, o>t = behind other geometry, o<0 behind\n\t\n\tvec3 normal = normalize(step(kEPSILON,abs(a-dist))-step(kEPSILON,abs(b-dist)))*sign(dist);\n\t//h.m=m;\n    return vec4(normal, dist);\n}\n\nvec3 bkg(in vec3 p, in vec3 d, bool heart, vec2 uv) {\n    vec4 box = iC(p, d, vec3(-100.), vec3(100.));\n    p += d * box.w;\n    if (heart) {\n    \t//float spec = (p.y < -99. && p.x>10. && abs(p.z+30.) < 30.) ? 1. : 0.;\n    \tfloat spec = p.y > -99. ? 0. : \n        (1.-smoothstep(40., 50., abs(p.x-50.))) * (1.-smoothstep(30., 40., abs(p.z+30.)));\n        //    && p.x>10. && abs(p.z+30.) < 30.) ? 1. : 0.;\n        return vec3(1,.2,.2) * (dot(d, normalize(vec3(3,2,-1)))*.3+.7) + spec;\n    }\n    \n    vec3 col = vec3(d.y *.5 + .5);\n    \n    return col;\n  //  return abs(box.zxy); \n}\n\n// The main marching loop\nvec3 marchRay(in vec3 p, in vec3 d, vec2 uv) {\n    float td = 0.;\n    \n    for (int i=0; i<kMAXITERS; i++) {\n        // Get distance to nearest surface\n        float result = dist(p);\n        td += result;\n        if ((p.z) > 3.0) { break; }\n        \n        p += d * result * 0.6;\n        \n        if (result < kEPSILON * td) {\n            // colision\n            // normal\n            // Get the normal, then clamp the intersection to the surface\n    \t\tvec3 n = normal(p);\n            d = reflect(d, n);\n            return bkg(p, d, true, uv);\n        }\n    }\n    // Ray did not hit, background\n    vec3 col = bkg(p, d, false, uv)*.6 + vec3(.2, .3, 1.);\n    \n\tcol = col*pow(clamp(0., 1., 1.2-length(uv)),.75);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy)*2.-1.;\n    vec2 uv2 = uv;\n    uv.y *= iResolution.y/iResolution.x;\n    vec3 cp = vec3(0,.5,-4.5);\n    vec3 rd = normalize(vec3(uv, 1)); \n\n    // Time varying pixel color\n    vec3 col = marchRay(cp, rd, uv2);\n\t//col = col*pow(clamp(0., 1., 1.-length(uv2)),.75);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdSyDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[161, 161, 183, 197, 493], [495, 514, 538, 538, 752], [754, 798, 855, 855, 952], [954, 954, 995, 995, 1468], [1470, 1470, 1523, 1523, 2050], [2052, 2078, 2124, 2124, 2807], [2809, 2809, 2866, 2916, 3275]], "test": "valid"}
{"id": "WdSyWV", "name": "Web 1", "author": "aiekick", "description": "based on the [url=https://www.shadertoy.com/view/3d2cRV]Shader[/url] of notargs\n\nbetter in fullscreen :)", "tags": ["web", "trabeculum"], "likes": 11, "viewed": 273, "published": "Public API", "date": "1587308656", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// based on the shader of notargs\n// https://www.shadertoy.com/view/3d2cRV\n\n// final\nconst vec4 colorBalance = vec4(0.3,0.7,0.5,0.3);\nconst vec3 uColor = vec3(0.5,1,0);\nconst vec3 uFog = vec3(0.005,0.001,0.0035);\nconst vec3 uLightDir = vec3(-1,-1,1);\n\n// shape\nconst vec3 uRatio = vec3(-0.37762,0.36364,0);\nconst float uRot = 0.1;\nconst vec2 uvOffset = vec2(2.69231,1.71329);\n\nfloat camZ = 0.0;\n\nvec2 path(float t)\n{\n\treturn vec2(cos(t * uRot) * 0.7, \n                sin(t * uRot) * 0.5) * uvOffset;\t\n}\n\nfloat map(vec3 p)\n{\n\tfloat a = p.z * uRot;\n    p.xy *= mat2(cos(a),sin(a),-sin(a),cos(a));\n    return length(\n        sin(p.xyz)*uRatio.x+\n        sin(p.zxy)*uRatio.y+\n        sin(p.yzx)*uRatio.z)-0.04;\n}\n\nvec3 nor(vec3 p, float prec)\n{\n\tvec3 e = vec3(prec,0,0);\n\treturn normalize(vec3(\n\t\tmap(p+e)-map(p-e),\n\t\tmap(p+e.yxz)-map(p-e.yxz),\n\t\tmap(p+e.zyx)-map(p-e.zyx)));\n}\n\nvoid mainImage(out vec4 e, in vec2 v)\n{\n    vec3 rd = normalize(.5 - vec3(v,1)/iResolution.y);\n    camZ = iTime * 5.0;\n\tvec3 ro = vec3(uvOffset + path(camZ),camZ);\n\tvec3 p = vec3(0);\n\t\n\tfloat d = 0.0, s = d;\n    for(int i=0;i<150;i++)\n    {\n\t\tif (abs(s)<d*d*1e-4) break;\n\t\td += s = map(p);\n\t\tp = ro + rd * d;\n    }\n\t\n\tvec3 ld = normalize(uLightDir);\n\tvec3 n = nor(p, 0.01);\n\tfloat diff = max(dot(n,-ld),0.0);\n\tfloat spec = max(dot(reflect(ld,n), rd),0.0);\n\tvec3 col = sin(d*uColor)*0.5+0.5;\n\tvec3 fog = exp(-uFog*d*d);\n    vec3 c = \n\t\tdiff * colorBalance.x * fog.x + \n\t\tcol * colorBalance.y * fog.y + \n\t\tsqrt(spec * colorBalance.z * 10.0) * colorBalance.w * fog.z;\n\t\n\te = vec4(c, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdSyWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[396, 396, 416, 416, 503], [505, 505, 524, 524, 709], [711, 711, 741, 741, 874], [876, 876, 915, 915, 1561]], "test": "valid"}
{"id": "wdSyWw", "name": "Day 115", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 16, "viewed": 273, "published": "Public API", "date": "1586732660", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define pi acos(-1.)\n\n#define tau (2.*pi)\n#define pal(a,b,c,d,e) ((a) + (b)*sin((c)*(d) + (e)))\n\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\nvec3 glow = vec3(0);\n\n\n\nfloat minRadius2 = 0.9;\nfloat fixedRadius2 = 5.7 ;\nfloat foldingLimit = 1.3;\n\nint Iterations = 7;\nfloat Scale = 2.;\n\nvoid sphereFold(inout vec3 z, inout float dz) {\n\tfloat r2 = dot(z,z);\n\tif (r2<minRadius2) { \n\t\t// linear inner scaling\n\t\tfloat temp = (fixedRadius2/minRadius2);\n\t\tz *= temp;\n\t\tdz*= temp;\n\t} else if (r2<fixedRadius2) { \n\t\t// this is the actual sphere inversion\n\t\tfloat temp =(fixedRadius2/r2);\n\t\tz *= temp;\n\t\tdz*= temp;\n\t}\n}\n\nvoid boxFold(inout vec3 z, inout float dz) {\n\tz = clamp(z, -foldingLimit, foldingLimit) * 2.0 - z;\n}\n\n\n#define pmod(p,j) mod(p,j) - 0.5*j\n\nfloat map(vec3 z, float t){\n\tfloat d = 10e7;\n\tvec3 p = z;\n    z.z = pmod(z.z, 10.);\n    \n    \n    for(int i = 0; i < 4;i ++){\n    \tz = abs(z);\n        \n        z.xy *= rot(0.125*pi);\n        //z.t -= 0.2;\n        //z.z -= 0.3;\n    }\n    \n    \n    vec3 q = vec3(z);\n    \n    vec3 j;\n    float jdr;\n    \n\tvec3 offset = z;\n\tfloat dr = 1.;\n\tfor (int n = 0; n < Iterations; n++) {\n\t\tboxFold(z,dr);       // Reflect\n\t\tsphereFold(z,dr);    // Sphere Inversion\n        \n        if(n == 2){\n            j = z;\n            jdr = dr;\n        }\n \t\t\n                z=Scale*z + offset;  // Scale & Translate\n                dr = dr*abs(Scale)+1.0;\n\t}\n    \n    \n    //z = abs(z);\n    //z.y -= 10.4;\n    \n\tfloat r = length(z);\n    \n    \n    \n    d = r/abs(dr);\n    \n    d *= 0.7;\n    \n    d += smoothstep(1.,0.,t*0.75)*0.15;\n    \n    float db = length(j)/abs(jdr);;\n    \n    glow += 0.5/(0.6 + pow( (abs(d) + 0.001)*0.7,2.)*800000.)*0.9;\n    \n    db += 0.001;\n    \n    \n    float att = pow(abs(sin(p.z + iTime + length(p.xy))),50.);\n    glow -= 0.92/(0.04 + pow( (abs(db) + 0.001)*0.7,2.)*16000.)*vec3(0.5,0.9,1.4)*att;\n    \n    \n    \n    d = min(d, db);\n        \n    //d *= 0.7;\n    d = abs(d) + 0.001;\n    \n    //glow -= 0.01/(0.1 + d*d*10.)*vec3(0.7,0.4,0.8);\n    //glow += 0.12/(0.001 + d*d*4000.);\n    \n    \n    return d;\n    \n    \n    //float da = length(z.xyz)/q.w - 0.01;\n    \n        \n    \n    float sc = 0.5;\n    //d = min(d,da);\n    d *= sc;\n    d += smoothstep(1.,0.,t*.5)*0.7;\n    d = abs(d) + 0.003;\n    \n    vec3 c = vec3(1,1.,1.);\n    return d;\n}\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n\tvec3 dir = normalize(lookAt - ro);\n\tvec3 right = normalize(cross(vec3(0.,1.,0), dir));\n\tvec3 up = normalize(cross( dir, right));\n\treturn normalize(dir + right*uv.x + up*uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    \n    \n    vec3 col = vec3(0.9,0.6,0.4);\n\n    vec3 ro = vec3(0);\n    ro.z += iTime;\n    \n    //ro.xz -= 4.6;\n    \n    float T = iTime*1./tau + pi*0.25;\n    ro.xy += vec2(cos(T), sin(T))*0.7;\n    \n    vec3 lookAt = vec3(0.001);\n    \n    lookAt.z = ro.z + 4.;\n    \n    vec3 rd = getRd(ro, lookAt, uv);\n    \n    float d;\n    vec3 p = ro; float t = 0.; bool hit = false;\n    \n    for(int i = 0; i < 120; i++){\n    \td = map(p, t);\n        if(d < 0.001){\n        \thit = true;\n            //break;\n        }\n\t\tt += d;\n    \tp = ro + rd*t;\n    }\n    \n    \n    col -= glow*0.07;\n    \n    col = max(col, 0.);\n    \n    col = pow(col, vec3(1. + dot(uv,uv)*1.));\n    \n    //col = smoothstep(0.,1.,col);\n    \n    col = pow(col, vec3(0.454545));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdSyWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[290, 290, 337, 337, 613], [615, 615, 659, 659, 715], [754, 754, 781, 781, 2301], [2302, 2302, 2344, 2344, 2523], [2525, 2525, 2582, 2582, 3416]], "test": "valid"}
{"id": "wdSyzK", "name": "raymarchTest_1", "author": "newboldTom", "description": "test of raymarching", "tags": ["test", "raymarch"], "likes": 1, "viewed": 51, "published": "Public", "date": "1586959934", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 transform(vec3 p, float modFac, float rotX, float rotZ){\n    //twisty!!\n    //rotX = rotX*p.y+iTime*0.6+p.x;\n    //rotZ = rotZ+cos(iTime*1.25)+p.z;\n    //not so twisty\n    rotX = rotX + mod(iTime+0.2*p.z,radians(360.0));\n    rotZ = rotZ + mod(0.25*iTime+0.1*p.x,radians(360.0));\n    //translation\n    p = p + vec3(0.4,p.z,-2);\n    //modulo 8\n    p = mod(p+(0.5*vec3(modFac,modFac,modFac)),vec3(modFac,modFac,modFac))-(0.5*vec3(modFac,modFac,modFac));\n    //x axis rot\n    p = vec3(p.x, p.y*cos(rotX) - p.z*sin(rotX), p.y*sin(rotX) + p.z*cos(rotX));\n    //z axis rot\n    p = vec3(p.x*cos(rotZ) - p.y*sin(rotZ), p.x*sin(rotZ) + p.y*cos(rotZ), p.z);\n    return p;\n}\n\nfloat torus(vec3 p, vec2 t){\n    p = transform(p,5.0,1.1,0.65);\n    return length(vec2(length(vec2(p.x,p.z))-t.x,p.y)) - t.y;\n}\n\nvec3 raymarch(vec2 uv, vec3 cam, vec2 args){\n    vec3 dir = normalize(vec3(2.0*uv.x-1.0,2.0*uv.y-1.0,1.0));;\n    float totalDis = 0.0;\n    vec3 p;\n    for(int i=0;i<100;i++){\n        vec3 p = cam + totalDis*dir;\n        totalDis = totalDis + torus(p,args)*0.5;\n    }\n    return mix(vec3(0.8,0.0,0.0),vec3(0.05,0.05,0.05),smoothstep(10.0,50.0,totalDis));\n}\n\nvec3 calNormal(vec3 p, float smoothVal, vec2 args){\n    return normalize(vec3(\n        torus(p+vec3(smoothVal,0,0),args)-torus(p+vec3(-smoothVal,0,0),args),\n        torus(p+vec3(0,smoothVal,0),args)-torus(p+vec3(0,-smoothVal,0),args),\n        torus(p+vec3(0,0,smoothVal),args)-torus(p+vec3(0,0,-smoothVal),args)));\n}\n\nvec3 raymarch_withLight(vec2 uv, vec3 cam, vec3 lightDir, vec3 lightCol, vec3 matCol, vec2 args){\n    vec3 dir = normalize(vec3(2.0*uv.x-1.0,2.0*uv.y-1.0,1.0));;\n    float totalDis = 0.0;\n    vec3 p;\n    for(int i=0;i<100;i++){\n        p = cam + totalDis*dir;\n        totalDis = totalDis + torus(p,args)*0.5;\n    }\n    matCol.x = 0.5+0.5*sin(p.z+p.y);\n    matCol.y = 0.5+0.5*sin(0.25*p.x);\n    matCol.z = 0.5+0.5*sin(0.5*p.x*p.y+2.0);\n    vec3 normal = calNormal(p,0.0001,args);\n    float diffuse = dot(lightDir,normal);\n    vec3 diffuseLit = diffuse*lightCol*matCol;\n    return mix(diffuseLit,vec3(0.05,0.05,0.05),smoothstep(10.0,80.0,totalDis));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //vec3 col = raymarch(uv,vec3(0,0.2,-2),vec2(0.8,0.3));\n    vec3 col = raymarch_withLight(uv,vec3(2.0+cos(iTime*0.5+10.0)*1.5,sin(iTime*1.5)*3.0,iTime*5.0),\n                                  normalize(vec3(-0.2, -0.3, -0.5)),vec3(1.0, 0.6, 0.2),\n                                  vec3(1.0,1.0,1.0),vec2(0.75,0.25));\n    fragColor = vec4(col.xyz, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdSyzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 61, 172, 667], [669, 669, 697, 697, 796], [798, 798, 842, 842, 1153], [1155, 1155, 1206, 1206, 1471], [1473, 1473, 1570, 1570, 2122], [2125, 2125, 2182, 2232, 2630]], "test": "valid"}
{"id": "wdSyzw", "name": "Simple Color Circle", "author": "nickcody", "description": "Click and drag to expand/contract circle radius. Its the default color cycle for shadertoy in a circle boundary.", "tags": ["geometry", "basics"], "likes": 0, "viewed": 140, "published": "Public API", "date": "1586289330", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 white = vec3(1.0, 1.0, 1.0);\nvec3 black = vec3(0.0, 0.0, 0.0);\nconst float R = 40.;\nconst float pixelWidth = 1.;\nconst float thickness = .5;\n\n//\n// coord - pixel to test\n// center - center of circle\n// radius - radius of circle\n// tolerance - thickness of circle line\nvec3 test(vec2 coord, vec2 center, float radius, float thickness) {\n    float dist_to_center = sqrt(pow(coord.x - center.x, 2.) + pow(coord.y - center.y, 2.));\n    float delta = dist_to_center-radius;\n\n    vec2 uv = gl_FragCoord.xy/iResolution.xy;\n    vec3 inside = .5 + .5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    float blend = smoothstep(0., pixelWidth, abs(delta) - thickness);\n    if (delta == 0.) {\n        return black;\n    } else if (delta  < 0.) {\n        return mix(white, inside, blend);\n    } else if (delta  > 0.) {\n        return mix(white, black, blend);\n    }\n        \n}\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord) {\n\tvec2 center = iResolution.xy/2.;\n    float r;\n    \n    if (iMouse.xy == vec2(0) ) r = R; else r = distance(center, iMouse.xy);\n        \n    vec3 c = test(gl_FragCoord.xy.xy, center, r, thickness);\n\t\n    out_color = vec4(c, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdSyzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[147, 273, 340, 340, 857], [859, 859, 911, 911, 1142]], "test": "error"}
{"id": "WdXBR4", "name": "Function002", "author": "PoetLuchnik", "description": "Function001, but around", "tags": ["lovemath"], "likes": 3, "viewed": 210, "published": "Public API", "date": "1587728488", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Function002\nfloat f(float x)\n{\n    float y = 0.0;\n    float size = 0.125;\n    float speed = 3.14;\n    while(size > 0.0001)\n    {\n        //y += sin(x * speed + iTime) * size;\n        y += abs(sin(x * speed + iTime) * size);\n        speed *= 2.5;\n        size *= 0.6;\n    }\n    return y + 0.19;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 point = fragCoord / iResolution.yy;\n    //Relative to center:\n    point -= vec2(iResolution.x * 0.5 / iResolution.y, 0.5);\n    //x, y -> angle, length:\n    float len = length(point);\n    point = vec2(acos(point.x / len), len);\n    //Set color:\n    vec3 col = 0.5 + 0.5 * cos(iTime + point.xyx + vec3(0,2,4));\n    if(abs( f(point.x / 3.14) - point.y ) < 0.01)\n    \tfragColor = vec4(col, 1);\n    else\n        fragColor = vec4(0, 0, 0, 1);\n        \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdXBR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 14, 32, 32, 297], [299, 299, 356, 356, 813]], "test": "valid"}
{"id": "WdXBW4", "name": "Clouds-2D", "author": "murieron", "description": "murieron shader", "tags": ["cineshader"], "likes": 30, "viewed": 16919, "published": "Public API", "date": "1588200933", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// https://www.shadertoy.com/view/WdXBW4\n \nconst float cloudscale = 1.1;\nconst float speed = 0.03;\nconst float clouddark = 0.5;\nconst float cloudlight = 0.3;\nconst float cloudcover = 0.2;\nconst float cloudalpha = 8.0;\nconst float skytint = 0.5;\nconst vec3 skycolour1 = vec3(0.2, 0.4, 0.6);\nconst vec3 skycolour2 = vec3(0.4, 0.7, 1.0);\n\nconst mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\nvec2 hash( vec2 p ) {\n\tp = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\tvec2 i = floor(p + (p.x+p.y)*K1);\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n    vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot(n, vec3(70.0));\t\n}\n\nfloat fbm(vec2 n) {\n\tfloat total = 0.0, amplitude = 0.1;\n\tfor (int i = 0; i < 7; i++) {\n\t\ttotal += noise(n) * amplitude;\n\t\tn = m * n;\n\t\tamplitude *= 0.4;\n\t}\n\treturn total;\n}\n\n// -----------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = fragCoord.xy / iResolution.xy;\n\tvec2 uv = p*vec2(iResolution.x/iResolution.y,1.0);    \n    float time = iTime * speed;\n    float q = fbm(uv * cloudscale * 0.5);\n    \n    //ridged noise shape\n\tfloat r = 0.0;\n\tuv *= cloudscale;\n    uv -= q - time;\n    float weight = 0.8;\n    for (int i=0; i<8; i++){\n\t\tr += abs(weight*noise( uv ));\n        uv = m*uv + time;\n\t\tweight *= 0.7;\n    }\n    \n    //noise shape\n\tfloat f = 0.0;\n    uv = p*vec2(iResolution.x/iResolution.y,1.0);\n\tuv *= cloudscale;\n    uv -= q - time;\n    weight = 0.7;\n    for (int i=0; i<8; i++){\n\t\tf += weight*noise( uv );\n        uv = m*uv + time;\n\t\tweight *= 0.6;\n    }\n    \n    f *= r + f;\n    \n    //noise colour\n    float c = 0.0;\n    time = iTime * speed * 2.0;\n    uv = p*vec2(iResolution.x/iResolution.y,1.0);\n\tuv *= cloudscale*2.0;\n    uv -= q - time;\n    weight = 0.4;\n    for (int i=0; i<7; i++){\n\t\tc += weight*noise( uv );\n        uv = m*uv + time;\n\t\tweight *= 0.6;\n    }\n    \n    //noise ridge colour\n    float c1 = 0.0;\n    time = iTime * speed * 3.0;\n    uv = p*vec2(iResolution.x/iResolution.y,1.0);\n\tuv *= cloudscale*3.0;\n    uv -= q - time;\n    weight = 0.4;\n    for (int i=0; i<7; i++){\n\t\tc1 += abs(weight*noise( uv ));\n        uv = m*uv + time;\n\t\tweight *= 0.6;\n    }\n\t\n    c += c1;\n    \n    vec3 skycolour = mix(skycolour2, skycolour1, p.y);\n    vec3 cloudcolour = vec3(1.1, 1.1, 0.9) * clamp((clouddark + cloudlight*c), 0.0, 1.0);\n   \n    f = cloudcover + cloudalpha*f*r;\n    \n    vec3 result = mix(skycolour, clamp(skytint * skycolour + cloudcolour, 0.0, 1.0), clamp(f + c, 0.0, 1.0));\n    \n\tfragColor = vec4( result, 1.0 );\n}\n\n/** SHADERDATA\n{\n    \"title\": \"Murieron\",\n    \"description\": \"Homenaje a las víctimas del COVID-19\",\n    \"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdXBW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[383, 383, 404, 404, 517], [519, 519, 545, 545, 1069], [1071, 1071, 1090, 1090, 1244], [1298, 1298, 1355, 1355, 2977]], "test": "valid"}
{"id": "wdXBz4", "name": "Spiral Offset 3", "author": "Del", "description": "Deeply Trippy Spiral Action :)", "tags": ["spiraltrippysinwibble"], "likes": 7, "viewed": 327, "published": "Public API", "date": "1587755188", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// non-black screen version - go full screen, keep watching... !!\n\n#define TAU 6.283185\n\nvec2 rot(vec2 v, float angle)\n{\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, -s, s, c)*v;\n}\n\n// IQ UnevenCapsule distance func\nfloat cro(in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\nfloat sdUnevenCapsule( in vec2 p, in vec2 pa, in vec2 pb, in float ra, in float rb )\n{\n    p  -= pa;\n    pb -= pa;\n    float h = dot(pb,pb);\n    vec2  q = vec2( dot(p,vec2(pb.y,-pb.x)), dot(p,pb) )/h;\n    \n    //-----------\n    \n    q.x = abs(q.x);\n    \n    float b = ra-rb;\n    vec2  c = vec2(sqrt(h-b*b),b);\n    \n    float k = cro(c,q);\n    float m = dot(c,q);\n    float n = dot(q,q);\n    \n         if( k < 0.0 ) return sqrt(h*(n            )) - ra;\n    else if( k > c.x ) return sqrt(h*(n+1.0-2.0*q.y)) - rb;\n                       return m                       - ra;\n}\n\nfloat TimerInOut(vec4 v)\n{\n    return smoothstep(v.y,v.y+v.w,v.x) - smoothstep(v.z-v.w,v.z,v.x);\n}\nfloat Stime(float _t, float scale)\n{\n    return fract(_t*scale)*TAU;\n}\nfloat Mtime(float _t, float mval)\n{\n    return mod(_t,mval);\n}\n\n// Trippy spiral calc - Del 06/01/2018\nvec2 spiral(vec2 uv,float zoom, float len, float offset,vec2 capoff, float trip, float scount,float rmod)\n{\n    float d = length(uv) * zoom;\n    d=log(d*trip);\n    uv = rot(uv,sin(d*offset)+d*scount*rmod);\n\tfloat v = 1.0-sdUnevenCapsule(uv,vec2(0.0,0.0)+capoff,vec2(0.4*len,0.0)+capoff,0.0,0.4*len)*14.0;\n    return vec2(v,d);\t// dx , dy\n}\n\nvec2 directionalWaveNormal(vec2 p, float amp, vec2 dir, float freq, float speed, float time, float k)\n{\t\n\tfloat a = dot(p, dir) * freq + time * speed;\n\tfloat b = 0.5 * k * freq * amp * pow((sin(a) + 1.0) * 0.5, k) * cos(a);\n\treturn vec2(dir.x * b, dir.y * b);\n}\n\nvec3 summedWaveNormal(vec2 p)\n{\n    float time = iTime;\n\tvec2 sum = vec2(0.0);\n\tsum += directionalWaveNormal(p, 0.5, normalize(vec2(1, 1)), 5.0, 1.5, time, 1.0);\n\tsum += directionalWaveNormal(p, 0.25,normalize(vec2(1.4, 1.0)), 11.0, 2.4, time, 1.5);\n\tsum += directionalWaveNormal(p, 0.125, normalize(vec2(-0.8, -1.0)), 10.0, 2.0, time, 2.0);\n\tsum += directionalWaveNormal(p, 0.0625, normalize(vec2(1.3, 1.0)), 15.0, 4.0, time, 2.2);\n\tsum += directionalWaveNormal(p, 0.03125, normalize(vec2(-1.7, -1.0)), 5.0, 1.8, time, 3.0);\n\treturn normalize(vec3(-sum.x, -sum.y, 1.0));\n}\nvec3 background(vec2 p)\n{\n\tvec3 normal = summedWaveNormal(p);\n\tvec3 c = mix(vec3(0.1, 0.15, 0.1), vec3(0.2, 0.25, 0.4),  dot(normal, normalize(vec3(0.2, 0.2, 0.5))) * 0.5 + 0.5);\n\tc = mix(c, vec3(0.7, 0.9, 1.0), pow(dot(normal, normalize(vec3(-0.4, 0.1, 1.0))) * 0.5 + 0.5, 2.0));\n\tc = mix(c, vec3(0.95, 0.98, 1.0), pow(dot(normal, normalize(vec3(-0.1, -0.3, 0.5))) * 0.5 + 0.5, 10.0));\n    return clamp(c,0.0,1.0);\n}\n\nfloat Bub(vec2 uv,float scale)\n{\n    float time = iTime*0.75;\n    uv.y-=time*2./scale;\n    //uv.x += time*0.2;\n    uv.x+=sin(uv.y+time*.95)*0.025;\t///scale;\n\tuv*=scale;\n    vec2 s=floor(uv);\n    vec2 f=fract(uv);\n    float k=3.0;\n\tvec2 p =.5+.35*sin(11.*fract(sin((s+scale)*mat2(7.0,3.0,6.0,5.0))*5.))-f;\n    float d=length(p);\n    k=min(d,k);\n\tk=smoothstep(0.0,k,sin(f.x+f.y)*0.01);\n   \treturn k;\n}\n\nvec3 Bubbles(vec2 uv,float head,float d)\n{\n\tfloat c = Bub(uv,30.)*.3;\n\tc+=Bub(uv,20.)*.5;\n\tc+=Bub(uv,15.)*.8;\n\tc+=Bub(uv,10.);\n\tc+=Bub(uv,8.);\n\tc+=Bub(uv,6.);\n\tc+=Bub(uv,5.);\n    vec3 scol = vec3(clamp(c*0.3,0.0,0.3));\n    return scol;\n}\n\nvec3 checks(vec2 p)\n{\n    float d = length(p);\n    float head = 1.0-length(p);\n    d+=(0.5+sin(iTime*2.0)*0.5)*0.25;\n    p *= 0.25;\n    return Bubbles(p*(d+0.5), head,d);\n}\n\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat pMod1(inout float p, float size)\n{\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    float _t = iTime+2.8;\n    \n\n    // Create some blends over time...\n    float t1 = TimerInOut(vec4(Mtime(_t,9.6),1.0, 7.2, 1.8));\n    float t2 = TimerInOut(vec4(Mtime(_t,12.0),1.0, 9.0, 1.5));\n    float t3 = TimerInOut(vec4(Mtime(_t,21.0),6.0, 14.2, 2.8));\n    float t4 = TimerInOut(vec4(Mtime(_t,60.0),15.0,45.0,1.0));\n    float t5 = TimerInOut(vec4(Mtime(_t,85.0),57.0, 67.0, 3.1));\n    float t6 = TimerInOut(vec4(Mtime(_t,123.0),77.0,101.0,10.0));\n    float t7 = TimerInOut(vec4(Mtime(_t,50.0),28.0,45.0,3.5));\n    float t8 = TimerInOut(vec4(Mtime(_t,20.0),1.0,13.0,3.1));\n    float t9 = TimerInOut(vec4(Mtime(_t,200.0),100.0,159.0,0.5));\n    float t10 = TimerInOut(vec4(Mtime(_t,45.0),21.0,31.0,0.75));\n    float t11 = TimerInOut(vec4(Mtime(_t,30.0),7.0,11.0,0.75));\n    \n    // various spiral modifiers applied over time\n    float t = Stime(_t,0.4);\n    float offset = 25.0 * t1;\n\tfloat zoom = 1.0 + (sin(Stime(_t,0.17))*0.5) * t2;\n    vec2 capoff = vec2(sin(uv.y*4.0+Stime(_t,0.125))*0.25, sin(uv.x*2.0+Stime(_t,0.25))*0.75) * t3;\n    float m = 0.48+sin(Stime(_t,0.15)+uv.y+uv.x)*0.5;\n    float trip = 1.0-(m*t4);\n    float scmod = sin(Stime(_t,0.176));\n    float scount = 5.0+((3.0+(scmod*5.0))*t5);\n\n    float rmod = mix (1.0,sin(Stime(_t,0.1))*2.5,t11);\n\n    // debug... (disable effects)\n    //scount = 5.0;\n    //offset=0.0;\n    //zoom = 1.0;\n    //trip = 1.0;\n    //capoff = vec2(0.0);\n    \n\tvec2 dist = spiral(uv, zoom, t, offset, capoff, trip, scount,rmod);\n    \n    float distmod = 0.49+sin(dist.x*0.34+dist.y*1.6+sin(Stime(_t,.1)))*0.5;\n    dist.x = mix(dist.x, dist.x*distmod, t10);\n    \n//\tfloat v2 = smoothstep(0.5-0.1,0.5+0.1,dist.x);\n//\tfloat v2 = smoothstep(0.0,0.5,dist.x);\n\tfloat v2 = smoothstep(0.0, 1.5*fwidth(dist.x-0.5), dist.x-0.5);\n    \n\tfloat v = mix(v2,clamp(dist.x,0.0,3.0), t6);\n    //vec3 col = vec3(v*1.0-l/t);\n    vec3 col1 = checks(uv);\t////vec3(0.0,0.0,0.2);\n    vec3 col2 = vec3(1.0,0.6,0.5);\n    \n    // rainbow flavour...\n\tcol2 = mix(col2,hsv2rgb_smooth(vec3(fract(iTime*0.2)+dist.x*0.09+dist.y*0.2,0.8,clamp(v,0.35,1.0)))*0.7,t9);\n    \n    vec3 col3 = background(uv);\t//vec3(0.5,0.7,0.5);\n    col1 = mix(col1,col3*0.3, t7);\n    col2 = mix(col2,col3*0.9, t8);\n    //vec3 col = mix(col1,col2,v*1.0-dist.y/t);\n\n    float finalblend = clamp(v*1.0-dist.y/t,0.0,5.0);\n    vec3 col = mix(col1,col2,finalblend);\n\n    // vignette\n \tvec2 q = fragCoord/iResolution.xy;\n    col *= 0.3 + 0.7*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.25);\n    \n    // utter hack, overlay some coloured circles to show active mods... :)\n    if (iMouse.z>0.5)\n    {\n        uv.xy += 0.05;\n        float c = pMod1(uv.y,0.1);\n        if (c<-3.0)\n        {\n            uv.x -= 0.3;\n            c = pMod1(uv.x,0.1);\n            if (c>=-8.0)\n            {\n                float dd = length(uv)*2.0;\n                dd = 1.0-smoothstep(0.0,0.1,dd);\n                vec3 cf = vec3(0.0);\n                vec3 cc = hsv2rgb_smooth( vec3((c+8.0)/12.0,1.0,dd));\n                if (c<-7.0) cf = cc*t1;\n                else if (c<-6.0) cf = cc*t2;\n                else if (c<-5.0) cf = cc*t3;\n                else if (c<-4.0) cf = cc*t4;\n                else if (c<-3.0) cf = cc*t5;\n                else if (c<-2.0) cf = cc*t6;\n                else if (c<-1.0) cf = cc*t7;\n                else if (c<-0.0) cf = cc*t8;\n                else if (c<1.0) cf = cc*t9;\n                else if (c<2.0) cf = cc*t10;\n                else if (c<3.0) cf = cc*t11;\n                float _mm = smoothstep(0.0,0.1,length(cf)-0.2);\n                col = mix(col,cf,_mm);\n           \t}\n        }\n    }\n    \n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdXBz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 89, 120, 120, 206], [208, 242, 276, 276, 304], [305, 305, 391, 391, 878], [880, 880, 906, 906, 978], [979, 979, 1015, 1015, 1049], [1050, 1050, 1085, 1085, 1112], [1114, 1153, 1260, 1260, 1492], [1494, 1494, 1597, 1597, 1755], [1757, 1757, 1788, 1788, 2330], [2331, 2331, 2356, 2356, 2748], [2750, 2750, 2782, 2782, 3149], [3151, 3151, 3193, 3193, 3388], [3390, 3390, 3411, 3411, 3562], [3564, 3564, 3598, 3598, 3776], [3778, 3778, 3818, 3818, 3939], [3941, 3941, 3998, 3998, 7694]], "test": "error"}
{"id": "WdXBzH", "name": "4D Lattice Slice", "author": "mla", "description": "Slicing through a 4-dimensional cubic lattice.", "tags": ["4d", "slice", "lattice"], "likes": 5, "viewed": 245, "published": "Public API", "date": "1587670647", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// 4D Lattice Slice\n//\n// Matthew Arcus, mla, 2020\n//\n// Slices through a 4 dimensional cubic lattice.\n// <mouse x>: slice angle\n// <mouse-y>: scale\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.1415927;\n\nmat4 qmat_left(vec4 q) {\n  float x = q.x, y = q.y, z = q.z, t = q.w;\n  return mat4( t, z,-y,-x, \n              -z, t, x,-y,\n               y,-x, t,-z,\n               x, y, z, t );\n}\n\nmat4 qmat_right(vec4 q) {\n  float x = q.x, y = q.y, z = q.z, t = q.w;\n  return mat4( t,-z, y,-x, \n               z, t,-x,-y,\n              -y, x, t,-z,\n               x, y, z, t );\n}\n\nvec4 qmul(vec4 p, vec4 q) {\n  vec3 P = p.xyz, Q = q.xyz;\n  return vec4(p.w*Q+q.w*P+cross(P,Q),p.w*q.w-dot(P,Q));\n}\n\nvec4 qrot(vec4 p, vec4 q, vec4 r) {\n  p = qmul(q,p);\n  p = qmul(p,r);\n  return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  float size = 5.0;\n  float time = 0.1*iTime+0.1;\n  float theta = 0.618*time;\n  if (iMouse.x > 0.0) {\n    size *= exp((2.0*iMouse.y -iResolution.y)/iResolution.y);\n    theta = PI*(2.0*iMouse.x-iResolution.x)/iResolution.x;\n  }\n  uv *= size;\n  float tq = time;\n  float tr = theta;\n  vec4 q = vec4(sin(tq)*vec3(1,0,0),cos(tq));\n  vec4 r = vec4(sin(tr)*vec3(0,1,0),cos(tr));\n  vec4 p = vec4(uv,0,0);\n  mat4 qm = qmat_left(q)*qmat_right(r);\n  float ds = fwidth(p.x);\n  p = qm*p; // qrot(p,q,r);\n  p = mod(p,2.0);\n  vec4 dp = fract(p);\n  dp = min(dp,1.0-dp);\n  p = floor(p);\n  int parity = int(dot(p,vec4(1)))%2;\n\n  mat4x2 dm = transpose(mat2x4(qm));\n  dp /= vec4(length(dm[0]),length(dm[1]),length(dm[2]),length(dm[3]));\n  float d = min(min(dp.x,dp.y),min(dp.z,dp.w));\n  vec3 color = vec3(smoothstep(-ds,+ds,parity==0?d:-d));\n  color = mix(vec3(1,0,0),color,smoothstep(0.01,0.02+ds,d));\n  color = pow(color,vec3(0.4545));\n  fragColor = vec4(color,1);\n}\n", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdXBzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[347, 347, 371, 371, 528], [530, 530, 555, 555, 712], [714, 714, 741, 741, 828], [830, 830, 865, 865, 913], [915, 915, 972, 972, 1979]], "test": "valid"}
{"id": "wdXBzM", "name": "pendulam", "author": "bhuwan0000", "description": "pendulam motion\nmove the extreme points with mouse", "tags": ["oscillation", "pendulam"], "likes": 3, "viewed": 51, "published": "Public", "date": "1587992014", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define iR iResolution.xy\n// a great video about this here: https://www.youtube.com/watch?v=keBLKqHEeT8\n\nfloat sweep(vec2 st, vec2 p, float r, float theta)\n{\n    st -= p;\n    float ang = theta>=0.0?radians(90.- theta):radians(-90.-theta);\n    float d1 = smoothstep(r-0.15, r-6./iR.y-0.16, abs(length(st)-r));\n    float ang_c = atan(max(0.,-st.y)/st.x);\n    float d = ang_c<ang?theta>=0.0?0.0:d1:theta<0.0?0.0:d1;\n    return d;\n}\nfloat line(vec2 p1, vec2 p2, vec2 uv, float t) {\n  float a = abs(distance(p1, uv));\n  float b = abs(distance(p2, uv));\n  float c = abs(distance(p1, p2));\n  if ( a >= c || b >=  c ) return 0.0;\n  float p = (a + b + c) * 0.5;\n  float h = 2.0 / c * sqrt( p * ( p - a) * ( p - b) * ( p - c));\n  return mix(1.0, 0.0, smoothstep(0.5 * t, 1.5 * t, h));\n}\n\nfloat ball(vec2 st, vec2 p, float r)\n{\n    return smoothstep(r, r-2./iResolution.y, length(st-p));\n}\n\nvec3 shm(vec2 po, vec2 cent, float ang, float t)\n{\n    float c = ang;\n    float l = length(po-cent);\n    float f = c*sin((t)*sqrt(9.8/l)-PI/2.); //from T = 2PI*sqrt(L/g) but here as a function of angle and time\n    float x = l*sin(f)+cent.x; //calc x and y based on angle\n    float y = -l*cos(f)+cent.y;\n    \n    return vec3(x,y,f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iR)/iR.y;\n    vec2 mouse = (2.*vec2(iMouse.x, iMouse.y)-iR)/iR.y;\n    vec3 col = vec3(uv,0.0);\n    float t = iTime*2.;  \n\n    vec2 po = mouse; //point from which angle to the center is being measured\n    vec2 cent = vec2(0.0, 0.5); // pendulam center\n    float ang1 = atan((cent.x-po.x)/(cent.y-po.y));\n    vec3 pos = shm(po, cent, ang1, t);\n    \n    float cent_cir = ball(uv,cent,0.05);\n    float p1 = ball(uv, pos.xy, 0.08);//moving ball\n    p1 += ball(vec2(abs(uv.x), uv.y), po, 0.03);\n    float string = line(cent, pos.xy, uv, 0.006);\n\n\t\n    float sweep_cir = sweep(uv, cent, 0.2, pos.z*57.2958);\n    \n    col = vec3(string+p1+sweep_cir+cent_cir);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdXBzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[130, 130, 182, 182, 453], [454, 454, 502, 502, 801], [803, 803, 841, 841, 903], [905, 905, 955, 955, 1239], [1241, 1241, 1298, 1298, 2011]], "test": "valid"}
{"id": "wdXcDf", "name": "logistic_difference_v0004", "author": "darkczar", "description": "logistic difference equation", "tags": ["psychedelic", "trippy"], "likes": 3, "viewed": 53, "published": "Public", "date": "1585718520", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// based on...\n// https://www.shadertoy.com/view/lssfW2\n\nfloat nsin(float x)\n{\n    return .5+.5*sin(x);\n}\nfloat ncos(float x)\n{\n    return .5+.5*cos(x);\n}\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}  //https://gist.github.com/companje/29408948f1e8be54dd5733a74ca49bb9\n\nhighp float rand(vec2 co)  //from stackoverflow\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nuint hash( uint x ) {  //http://amindforeverprogramming.blogspot.com/2013/07/random-floats-in-glsl-330.html\n\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\nfloat random( float f ) {  //http://amindforeverprogramming.blogspot.com/2013/07/random-floats-in-glsl-330.html\n\n    const uint mantissaMask = 0x007FFFFFu;\n    const uint one          = 0x3F800000u;\n   \n    uint h = hash( floatBitsToUint( f ) );\n    h &= mantissaMask;\n    h |= one;\n    \n    float  r2 = uintBitsToFloat( h );\n    return r2 - 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float r = 0.0;\n    float g = 0.0;\n    float b = 0.0;\n    vec2 xy0 = vec2(0.,0.);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p=(fragCoord.xy-iResolution.xy)/iResolution.y;\n    \n    vec2 xy = vec2(0.,0.);\n    // r between 3.75 and 4.0 produces chaotic behavior\n    float rr = .25*(nsin(.5*iTime))+3.75; // + .5*nsin(iTime*.5); //2.57 +nsin(iTime); //+cos(iTime);\n    xy = uv;\n    //int max_iter = int(6.0 + floor(8.0*nsin(iTime*.2)));\n    for (int i = 0; i<6; i++)\n    {\n        xy = rr*xy*(vec2(1.0,1.0)-xy);\n        if(i==0)\n        {\n          xy0 = xy;  \n        }\n        if (i>1)\n            {\n                if(abs(length(xy) - length(xy0)) < .01) // try and tease out the cycles and color them\n                {\n                    r = 1.*random(float(mod(float(i),15.00)))*nsin(iTime);\n                    g = 1.*random(1.28+float(mod(float(i),15.0)));\n                    b = 1.*random((1.0 - float(mod(float(i),15.0))))*ncos(iTime);\n                } else if (abs(length(xy) - length(xy0)) > .85)\n                {\n                    r = 1.*random((1.0 - float(mod(float(i),15.0))))*ncos(iTime);\n                    g = 1.0 - 1.*random(1.28+float(mod(float(i),15.0)));\n                    b = 1.*random(float(mod(float(i),15.00)))*nsin(iTime);\n                }\n            }\n    }\n    if (length(xy) > 1.0)\n    {\n        r = .0;\n        g = 0.0;\n        b = 0.0;\n    } else\n    {\n        //r = .05;\n        //g = .99;\n        //b = .3;\n    }\n        \n        //m = (rand_point.x-prev_point.x) / ((rand_point.y-prev_point.y);\n        //line_y = m*p.x +  \n\n\n    \n    vec3 col = vec3(r, g, b);\n    float dn = col.x + col.y + col.z;\n    col /= dn;\n    // Output to screen\n    //fragColor = vec4(col,1.0);\n    fragColor = vec4( pow(col,vec3(1./2.2)),1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdXcDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 79, 79, 106], [107, 107, 128, 128, 155], [157, 157, 229, 229, 295], [616, 616, 637, 723, 855], [856, 856, 881, 967, 1204], [1206, 1206, 1263, 1263, 3088]], "test": "valid"}
{"id": "WdXcDs", "name": "6 Neighbor Voronoi  - (failed)", "author": "TLC123", "description": "\nA cell in a square grid borders 8 other cells. in a hex grid there is only six bordering cells to check.", "tags": ["2d", "voronoi", "worley"], "likes": 1, "viewed": 49, "published": "Public", "date": "1585812327", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"Voronoi - basic\" by iq. https://shadertoy.com/view/MslGD8\n// 2020-04-02 06:34:14\n\n// The MIT License\n// Copyright © 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\nvec2 hash( vec2 p ) { p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*18.5453); }\n\n// return distance, and cell id\nvec2 voronoi( in vec2 p )\n{\n    vec2 n = floor( p ) ;\n    vec2 f = fract( p ) ;\n\n\tvec3 m = vec3( 8.0 ); \n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<= 1        -abs(j)\n        ; i++ )\n    {\n        vec2  g = vec2( float(i) , float(j) ) ;\n        vec2  o =   hash( n + g +vec2(floor(mod(p.y  +float(j) ,2.))*.5,0.5 ) )  ;\n     vec2  r = g - f \n          +vec2(1.-floor(mod(p.y  +float(j) ,2.))*.5,0.5)\n         \n          + o\n         ;\n \t\tfloat d = dot( r, r );\n        if( d<m.x )\n            m = vec3( d, o );\n    }\n\n    return vec2( sqrt(m.x), m.y+m.z );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy/max(iResolution.x,iResolution.y);\n    vec2 asp =   iResolution.xy/max(iResolution.x,iResolution.y) ;\n    p=p-(asp*0.5);\n    // computer voronoi patterm\n    vec2 c = voronoi( (14.0+6.0*sin(0.2*iTime))*p );\n\n    // colorize\n    vec3 col = 0.5 + 0.5*cos( c.y*6.2831 + vec3(0.0,1.0,2.0) );\t\n    col *= clamp(1.0 - 0.4*c.x*c.x,0.0,1.0);\n    col -= (1.0-smoothstep( 0.08, 0.09, c.x));\n\t\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdXcDs.jpg", "access": "shaders20k", "license": "mit", "functions": [[1173, 1173, 1194, 1194, 1285], [1287, 1319, 1346, 1346, 1886], [1888, 1888, 1945, 1945, 2388]], "test": "valid"}
{"id": "wdXcDX", "name": "Playing with geometry", "author": "EmmaChase", "description": "Quick test with geometry building", "tags": ["raymarcher", "geometry"], "likes": 0, "viewed": 44, "published": "Public", "date": "1585700391", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_MARCH_STEP 120\n#define MAX_SHADE_STEP 60\n#define CLIP_DIST 1000.0\n#define EPSILON 0.001\n\nfloat maxcomp(vec3 p) { return max(max(p.x, p.y), p.z); }\n\nfloat intersect(float shape1, float shape2){\n    return max(shape1, shape2);\n}\n\nfloat subtract(float base, float subtraction){\n    return intersect(base, -subtraction);\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdBox(vec3 p, vec3 b, float r) {\n    vec3 d = abs(p) - (b - r);\n    return length(max(d, 0.0)) + min(maxcomp(d), 0.0) - r;\n}\n\nfloat sdPlane(vec3 p, vec3 n) {\n    return dot(n, p);\n}\n\nfloat eatenSphere(vec3 pos) {\n    return intersect(subtract(sdSphere(pos - vec3(0.0, 0.0, 5.0), 1.0),\n                    sdSphere(pos - vec3(-0.3, 0.0, 4.38), 0.4)), sdBox(pos - vec3(-1.3, 0.0, 5.0), vec3(1.0), 0.65));\n}\n\nfloat otherBox(vec3 pos) {\n\treturn sdBox(pos - vec3(1.0, 0.0, 6.0), vec3(0.7), 0.2);\n}\n\nfloat sceneSDF(vec3 pos) {\n    float temp;\n    float dist = CLIP_DIST;\n\n    dist = (temp = sdPlane(pos - vec3(0.0, -2.0, 0.0), vec3(0.0, 1.0, 0.0))) < dist ? temp : dist;\n    dist = (temp = eatenSphere(pos)) < dist ? temp : dist;\n    dist = (temp = otherBox(pos)) < dist ? temp : dist;\n\n    return dist;\n}\n\nvec3 calcNormal(vec3 pos) {\n    const vec2 eps = vec2(0.001, 0.0);\n\n    vec3 nor = vec3(\n        sceneSDF(pos + eps.xyy) - sceneSDF(pos - eps.xyy),\n        sceneSDF(pos + eps.yxy) - sceneSDF(pos - eps.yxy),\n        sceneSDF(pos + eps.yyx) - sceneSDF(pos - eps.yyx));\n    return normalize(nor);\n}\n\nfloat raymarch(vec3 ro, vec3 rd, float mint, float maxt) {\n    float depth = mint;\n    for (int i = 0; i < MAX_MARCH_STEP; ++i) {\n        vec3 pos = ro + rd*depth;\n        float dist = sceneSDF(pos);\n        if (dist < EPSILON) return depth;\n        if (dist < 0.00015*depth) return depth;\n\n        depth += dist;\n        if (depth >= maxt) break;\n    }\n\n    return maxt;\n}\n\nfloat softshadow( vec3 ro, vec3 rd, float mint, float maxt, float w ) {\n    float s = 1.0;\n    float t = mint;\n    for(int i = 0; i < MAX_SHADE_STEP; ++i) {\n        float h = sceneSDF(ro + rd*t);\n        s = min( s, 0.5+0.5*h/(w*t) );\n        if( s<0.0 ) break;\n        t += h;\n    }\n    s = max(s,0.0);\n    return s*s*(3.0-2.0*s); // smoothstep\n}\n\nvec3 sceneColor(vec3 pos) {\n    if (eatenSphere(pos) < EPSILON) return vec3(1.0, 1.0, 0.0);\n\tif (otherBox(pos) < EPSILON) return vec3(0.0, 0.0, 1.0);\n    \n    // Fallback\n    return vec3(1.0);\n}\n\nvec3 shadeScene(vec3 pos) {\n    const vec3 lightPos = vec3(-4.0, 3.0, -2.0);\n\n    vec3 col = vec3(1.0);\n\n    vec3 normal = calcNormal(pos);\n    vec3 lightVec = pos - lightPos;\n    vec3 lightDir = normalize(lightVec);\n\n    float lightFalloff = mix(1.0, 0.0, length(lightVec) / 32.0);\n    col *= lightFalloff;\n    col *= dot(-lightDir, normal);\n\n    col *= softshadow(pos, -lightDir, 0.01, 10.0, 0.2);\n\n    // Apply per-object coloring\n    col *= sceneColor(pos);\n\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 aspect = vec2(1.0, iResolution.y / iResolution.x);\n\n    float FOV = 90.0 + 20.*sin(iTime);\n    float RFD = 1.0 / tan(radians(FOV) / 2.0);\n    vec3 ro = vec3(0.0);\n    vec3 rd = normalize(vec3((uv * 2.0 - 1.0) * aspect, RFD));\n\n    float depth = raymarch(ro, rd, 0.1, CLIP_DIST);\n    vec3 col = vec3(0.0);\n    if (depth < CLIP_DIST) {\n        col = shadeScene(ro + rd*depth);\n    }\n\n    col = pow (col, vec3 (1.0 / 2.2)); // Gamma correction\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdXcDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[101, 101, 124, 124, 158], [160, 160, 204, 204, 238], [240, 240, 286, 286, 330], [332, 332, 365, 365, 393], [395, 395, 433, 433, 525], [527, 527, 558, 558, 582], [584, 584, 613, 613, 805], [807, 807, 833, 833, 893], [895, 895, 921, 921, 1200], [1202, 1202, 1229, 1229, 1497], [1499, 1499, 1557, 1557, 1872], [1874, 1874, 1945, 1945, 2221], [2223, 2223, 2250, 2250, 2417], [2419, 2419, 2446, 2446, 2899], [2901, 2901, 2956, 2956, 3480]], "test": "valid"}
{"id": "WdXfRM", "name": "Senin Flower", "author": "mikelsv", "description": "Draw any flowers.", "tags": ["flower"], "likes": 1, "viewed": 71, "published": "Public", "date": "1587852636", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Research for http://senin.world\n// Idea: https://youtu.be/hsA1UfGwIHs?t=828\n\n#define PI 3.141592653589793\n\n// Maticals core functions\nfloat box_sin(float angle){\n\tif(angle < 0.)\n    \tangle = -1. * ( - PI * 2. - angle);\n    angle = mod(angle, PI * 2.);\n    \n\tif(angle <= PI * 0.75)\n\t\treturn min(angle / (PI * 0.25), 1.);\n \n\tif(angle <= PI * 1.75)\n\t\treturn max(-1., 1. - (angle - PI * 0.75) / (PI * 0.25));\n    \n    if(angle <= PI * 2.)\n\t\treturn -1. + (angle - PI * 1.75) / (PI * 0.25);\n\n\treturn 0.;\n}\n\nfloat box_cos(float angle){\n    if(angle < 0.)\n        angle = -1. * ( - PI * 2. - angle);\n    angle = mod(angle, PI * 2.);\n\n    if(angle <= PI * 0.25)\n        return 1.;\n    if(angle <= PI * 0.75)\n        return 1. - (angle - PI * 0.25) / (PI * 0.25);\n    if(angle <= PI * 1.25)\n        return -1.;\n    if(angle <= PI * 1.75)\n        return -1. + (angle - (PI * 1.25)) / (PI * 0.25);\n    if(angle <= PI * 2.)\n        return 1.;\n\n    return 0.;\n}\n\nfloat ms_angle(float angle){\n    if(angle < 0.)\n        angle = -1. * ( - PI * 2. - angle);\n    angle = mod(angle, PI * 2.);\n\n    if(angle <= PI * 0.5)\n\t\treturn angle / (PI * 0.5);\n    \n\tif(angle <= PI * 1.5)\n\t\treturn 1. - (angle - PI * 0.5) / (PI * 0.5);\n    \n    if(angle <= PI * 2.)\n\t\treturn -1. + (angle - PI * 1.5) / (PI * 0.5);\n\n    return 0.;\n}\n\n\n// From 0 to 2 PI\nfloat GetAngle(vec2 point){\n    if(point.y >= 0.)\n        if(point.x > 0.)\n        \treturn atan(point.x / point.y);\n        else\n            return atan(-point.y / point.x) + PI * 1.5;\n    else\n        if(point.x > 0.)\n        \treturn atan(-point.y / point.x) + PI * .5;\n        else\n            return atan(point.x / point.y) + PI;\n}\n\nfloat addVawe(float v, float m){\n    return 1. + v * m;\n}\n\n// Flower structure\nstruct Flower{\n    float count;\n    float spin;\n\t//float scale;\n};\n    \nFlower flo[] = Flower[](\n\tFlower(4., 2.),\n    Flower(8., .5),\n    Flower(8., -1.),\n    Flower(16., -.5),\n    Flower(16., 1.)//,\n    //Flower(32., .5)\n);\n\n\nfloat allCall(int id, float v){\n    switch(id){\n        default:\n    \tcase 0: return sin(v);   \n        case 1: return cos(v);\n        case 2: return box_sin(v);\n        case 3: return box_cos(v);\n        case 4: return ms_angle(v);\n    }\n}\n\nfloat allCall(float v){\n\tint id = int(mod(iTime * .5, 5.));\n    float t = mod(iTime * .5, 1.);\n    \n    return allCall(id, v) * (1. - t) + allCall(id + 1, v) * t;    \n}\n\n// Configure it <--------------------------------------------- CONFIG Flowers type\n// Use: sin, cos, box_sin, box_cos, ms_angle, allCall, any else.\n#define FLOVER_CALL(v)\tallCall(v)\n\n// Mouse reaction: click to center\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uc = fragCoord/iResolution.xy - 0.5;\n    vec2 mc = iMouse.xy/iResolution.xy - 0.5;\n    \n    // Configure it <--------------------------------------------------------------------- CONFIG Scale & color\n    float gscale = 16. + 4.; // Global scale\n    vec3 fcol = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)); // Flowers color\n    \n    // Go\n    float scale = 1.;\n    vec3 col = vec3(0., 0., 0.);\n    float opt = 1.;\n    \n    for(int i = 0; i < flo.length(); i ++){\n        // Mouse reaction\n        if(length(mc) <= 0.3)\n        \topt = sin(mod(iTime * flo[i].spin, PI * 2.));\n        \n        // Get angle\n        float a = GetAngle(uc) - mod(iTime * flo[i].spin, PI * 2.);\n        \n        // Get len\n    \tfloat fc = length(uc) * scale * gscale * opt; //(float(i) / float(flo.length()) * 1.);\n    \n    \t// Add vawe\n    \tfloat v = addVawe(FLOVER_CALL(a * flo[i].count), .1);\n    \n        // Mult\n    \tfc *= v;\n\n        // Crop\n      \tif(fc > 1.)\n          fc = 1. - (fc - 1.) * 40.1;\n        \n        // Result color\n        if(fc > 0.1)\n    \t\tcol = col + fcol * fc;\n        \n        // Next flower scale\n        scale *= .6;        \n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdXfRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[110, 137, 164, 164, 502], [504, 504, 531, 531, 950], [952, 952, 980, 980, 1303], [1306, 1324, 1351, 1351, 1658], [1660, 1660, 1692, 1692, 1717], [1966, 1966, 1997, 1997, 2206], [2208, 2208, 2231, 2231, 2376], [2597, 2597, 2652, 2702, 3946]], "test": "error"}
{"id": "WdXfRN", "name": "Newtons fucked up cradle", "author": "run", "description": "Newtons fucked up cradle.\n\nNope it's not broken :) This is what I wanted you to see :)", "tags": ["newtons"], "likes": 6, "viewed": 246, "published": "Public API", "date": "1587752384", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// based on www.shadertoy.com/view/Xds3zN Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define PI_16TH 0.39269908169 \n#define HALF_PI 1.57079632679\n#define PI 3.14159265359\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere( vec3 p, float s , float a, float b)\n{\n    mat3 rot1 = mat3(vec3(sin(b),cos(b),0.0), \n                     vec3(cos(b),-sin(b),0.0),\n                     vec3(0.0,0.0,1.0));\n    mat3 rot2 = mat3(vec3(sin(a),0.0,cos(a)), \n                     vec3(0.0, 1.0, 0.0),\n                     vec3(cos(a), 0.0, -sin(a)));\n    p -= rot2*rot1*vec3(0.0,0.9,0.0);\n    return length(p)-s;\n}\n\nfloat sdTorus( vec3 p, vec2 t , float a)\n{\n  mat3 rot = mat3(vec3(sin(a),0.0,cos(a)), \n                  vec3(0.0, 1.0, 0.0),\n                  vec3(cos(a), 0.0, -sin(a)));\n  \n  p = rot*p;\n  p -= -vec3( 0.0,0.0, 0.0);\n  return length( vec2(length(p.yz)-t.x,p.x) )-t.y;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvec2 map( in vec3 pos )\n{\n    pos.z += .7;\n    float time = 2.0 * iTime;\n \tfloat sphere_size = 0.35;\n    vec2 res = vec2(11111111.0,0.0);\n    \n    float balls = 11111111.;\n\n    for( int i=0; i<4; i++ )\n    {\n    \t//res = opU( res, vec2( sdTorus(pos, vec2(0.90,0.01), float(i) * PI_16TH ), 25.0 ) );  \n        //res = opU(res, vec2( sdSphere(    pos, 0.13 , float(i) * PI_16TH, time + PI_16TH * float(i)), time + float(i)));\n        balls = min(balls, sdSphere( pos + vec3(float(i - 2) * sphere_size, 0., 0.), sphere_size / 2. , 0., 0.));\n    }\n    float pendulum = sin(time * 0.6) * .7;\n    //balls = opU(balls, vec2( sdSphere( pos + vec3(2. * sphere_size + sin(pendulum), 0., 1. - cos(pendulum)), sphere_size / 2. , 0., 0.), time));\n    balls = min(balls, sdSphere( pos + vec3(2. * sphere_size + sin(pendulum) * .9, (-1. + cos(pendulum)) * .5, 0.), sphere_size / 2. , 0., 0.));\n    vec3 cp = pos - vec3(0., 0., 0.875);\n    \n    float mount = sdBox( cp, vec3(1., 1., .51) );\n    mount = max(mount, -sdBox( cp - vec3(0., .1, 0.), vec3(2., 1., .42) ));\n    mount = max(mount, -sdBox( cp - vec3(0., -.1, 0.), vec3(.9, 1., 2.) ));\n    \n    vec3 pt = cp;\n    \n    pt.yz -= vec2(.65, .3);\n    pR(pt.yz, .53);\n    mount = min(mount, sdBox( pt - vec3(0., -.1, 0.), vec3(.02, .45, .02) ));\n    pt = cp;\n    \n    pt.yz -= vec2(.65, -.3);\n    pR(pt.yz, -.53);\n    mount = min(mount, sdBox( pt - vec3(0., -.1, 0.), vec3(.02, .45, .02) ));\n    pt = cp;\n    \n    pt.x += sphere_size;\n    pt.yz -= vec2(.65, .3);\n    pR(pt.yz, .53);\n    mount = min(mount, sdBox( pt - vec3(0., -.1, 0.), vec3(.02, .45, .02) ));\n    pt = cp;\n    \n    pt.x += sphere_size;\n    pt.yz -= vec2(.65, -.3);\n    pR(pt.yz, -.53);\n    mount = min(mount, sdBox( pt - vec3(0., -.1, 0.), vec3(.02, .45, .02) ));\n    pt = cp;\n    \n    pt.x -= sphere_size;\n    pt.yz -= vec2(.65, .3);\n    pR(pt.yz, .53);\n    mount = min(mount, sdBox( pt - vec3(0., -.1, 0.), vec3(.02, .45, .02) ));\n    pt = cp;\n    \n    pt.x -= sphere_size;\n    pt.yz -= vec2(.65, -.3);\n    pR(pt.yz, -.53);\n    mount = min(mount, sdBox( pt - vec3(0., -.1, 0.), vec3(.02, .45, .02) ));\n    pt = cp;\n    \n    pt.x -= sphere_size * 2.;\n    pt.yz -= vec2(.65, .3);\n    pR(pt.yz, .53);\n    mount = min(mount, sdBox( pt - vec3(0., -.1, 0.), vec3(.02, .45, .02) ));\n    pt = cp;\n    \n    pt.x -= sphere_size * 2.;\n    pt.yz -= vec2(.65, -.3);\n    pR(pt.yz, -.53);\n    mount = min(mount, sdBox( pt - vec3(0., -.1, 0.), vec3(.02, .45, .02) ));\n    pt = cp;\n    \n    pt.x += sphere_size * 2.;\n    pt.x += sin(pendulum) * 0.3;\n    pt.yz -= vec2(.65, .3);\n    pR(pt.xy, -sin(pendulum));\n    pR(pt.yz, .53);\n    mount = min(mount, sdBox( pt - vec3(0., -.1, 0.), vec3(.02, .45, .02) ));\n    pt = cp;\n    \n    pt.x += sphere_size * 2.;\n    pt.x += sin(pendulum) * 0.3;\n    pt.yz -= vec2(.65, -.3);\n    pR(pt.xy, -sin(pendulum));\n    pR(pt.yz, -.53);\n    mount = min(mount, sdBox( pt - vec3(0., -.1, 0.), vec3(.02, .49, .02) ));\n    pt = cp;\n    \n    \n    return vec2(min(mount, balls), time);\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n\tfloat precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n\t\t\n        if( m<1.5 )\n        {\n            \n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n            col = 0.4 + 0.1*f*vec3(1.0);\n        }\n\n        // lighitng        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.20*dif*vec3(1.00,0.85,0.55);\n\t\tlin += 1.20*spe*vec3(1.00,0.85,0.55)*dif;\n        lin += 0.20*amb*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*dom*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.002*t*t ) );\n\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 0.0 + iTime/3.0;\n    float cra = HALF_PI - clamp(HALF_PI * (cos(time)), 0.0, HALF_PI); // camera rotation angle\n    \n    float y = (0.5 + 0.5 * cos(time))*3.0;\n    \n\t// camera\t\n\tvec3 ro = vec3( 0.0, sqrt(9.0-y*y), y);\n\tvec3 ta = vec3( 0.0, 0.0, 0.0 );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n\tcol = pow( col, vec3(0.4545) );\n\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdXfRN.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[251, 251, 282, 282, 369], [371, 371, 424, 424, 762], [764, 764, 806, 806, 1034], [1036, 1036, 1066, 1066, 1099], [1101, 1101, 1133, 1133, 1175], [1177, 1177, 1202, 1202, 4178], [4180, 4180, 4220, 4220, 4540], [4543, 4543, 4617, 4617, 4878], [4880, 4880, 4912, 4912, 5133], [5135, 5135, 5177, 5177, 5476], [5478, 5478, 5517, 5517, 7088], [7090, 7090, 7142, 7142, 7319], [7321, 7321, 7378, 7378, 8055]], "test": "valid"}
{"id": "wdXfz8", "name": "QuasiCrystals - Dragon Eye", "author": "mrange", "description": "Found bunch of examples of quasicrystals on shadertoy and combined them with FBM. I liked the result so decided to share it.", "tags": ["2d", "quasicrystals"], "likes": 4, "viewed": 295, "published": "Public API", "date": "1587667643", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define LAYERS      6\n#define FBM         3\n#define LIGHTNING   3\n#define DISTORT     1.4\n#define TIME        iTime\n#define TTIME       (TAU*TIME)\n\nfloat wave(float theta, vec2 p) {\n  return (cos(dot(p,vec2(cos(theta),sin(theta)))));\n}\n\nfloat noise(vec2 p, float time) {\n  float sum = 0.;\n  float a = 1.0;\n  for(int i = 0; i < LAYERS; ++i)  {\n    float theta = float(i)*PI/float(LAYERS);\n    sum += wave(theta, p)*a;\n    a*=DISTORT;\n  }\n\n  return abs(tanh(sum+1.0+0.75*cos(time)));\n}\n\nfloat fbm(vec2 p, float time) {\n  float sum = 0.;\n  float a = 1.0;\n  float f = 1.0;\n  for(int i = 0; i < FBM; ++i)  {\n    sum += a*noise(p*f, time);\n    a *= 2.0/3.0;\n    f *= 2.31;\n  }\n\n  return 0.45*(sum);\n}\n\nvec3 lightning(vec2 pos, float offset) {\n  vec3 col = vec3(0.0);\n  vec2 f = vec2(0);\n         \n  const float w=0.15;\n          \n  for (int i = 0; i < LIGHTNING; i++) {\n    float time = TIME + 0.5*float(i);   \n    float d1 = abs(offset * w / (0.0 + offset - fbm((pos + f) * 3.0, time)));\n    float d2 = abs(offset * w / (0.0 + offset - fbm((pos + f) * 2.0, 0.9 * time + 10.0)));\n    col += vec3(clamp(d1, 0.0, 1.0) * vec3(0.1, 0.5, 0.8));\n    col += vec3(clamp(d2, 0.0, 1.0) * vec3(0.7, 0.5, 0.3));\n  }\n          \n  return (col);\n}\n\nvec3 postProcess(vec3 col, vec2 q) {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(p.x*c + p.y*s, -p.x*s + p.y*c);\n}\n\nvec3 normal(vec2 p, float time) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(0.00001, 0);\n  \n  vec3 n;\n  n.x = fbm(p + e.xy, time) - fbm(p - e.xy, time);\n  n.y = 2.0*e.x;\n  n.z = fbm(p + e.yx, time) - fbm(p - e.yx, time);\n  \n  return normalize(n);\n}\n\nvec3 dragonEye(vec2 p) {\n  vec2 pp = 10.0*p;\n\n  rot(p, -0.75); \n  p *= vec2(1.1/tanh(1.0 + length(p)), 1.0);\n  float l = length(p);\n  \n  float dd = 0.2 + 0.65*(-0.5 + 1.75*(0.5 + 0.5*cos(3.0*l-TTIME/12.0)))*tanh(1.0/((pow(l, 4.0) + 2.0)));\n  dd *= smoothstep(9.0, 12.0, TIME-l*2.0);\n  vec3 col = vec3(0.0);\n  float f = fbm(pp, TIME*0.1);\n  vec3 ld = normalize(vec3(p.x, 0.5, p.y));\n  vec3 n = normal(pp, TIME*0.1);\n  float diff = max(dot(ld, n), 0.0);\n  col += vec3(0.5, 1.0, 0.8)*pow(diff, 20.0)/(0.5+dot(p, p));\n  col += lightning(pp, dd);\n  col *= pow(vec3(f), vec3(1.5, 5.0, 5.0));\n//  col += -0.1+0.3*vec3(0.7, 0.2, 0.4)*vec3(tanh((pow(0.6/f, 10))));\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord.xy/iResolution.xy;    \n  vec2 p = -1.0 + 2.0*q;\n\n  p.x *= iResolution.x/iResolution.y;    \n  \n  vec3 col = dragonEye(p);\n  \n  col = postProcess(col, q);\n\n  col *= smoothstep(0.0, 4.0, TIME);\n  \n  fragColor = vec4(col, 1.0);  \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdXfz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[209, 209, 242, 242, 296], [298, 298, 331, 331, 544], [546, 546, 577, 577, 755], [757, 757, 797, 797, 1287], [1289, 1289, 1325, 1325, 1574], [1576, 1576, 1609, 1609, 1694], [1696, 1696, 1729, 1729, 1938], [1940, 1940, 1964, 1964, 2611], [2613, 2613, 2668, 2668, 2917]], "test": "valid"}
{"id": "WdXfzH", "name": "tile gradient test", "author": "blepfo", "description": "Color gradient with tiling", "tags": ["basic"], "likes": 0, "viewed": 45, "published": "Public", "date": "1587660046", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circ(\n\tvec2 uv,\n    float r1,\n    float r2,\n    float blend\n) {\n    return (smoothstep(r1-blend, r1+blend, length(uv))\n           - smoothstep(r2-blend, r2+blend, length(uv)));\n}\n\nfloat square(\n\tvec2 uv,\n    float r,\n    float blend\n) {\n    vec2 dist = abs(uv);\n    float d = max(dist.x, dist.y);\n    return 1. - smoothstep(r-blend, r+blend, d);\n}\n\nmat2 rotate2d(float theta) {\n    return mat2(cos(theta), -sin(theta),\n                sin(theta), cos(theta));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n\n    float scale = 10.2;\n    uv *= scale;\n    vec2 tileIdx = floor(uv);\n    vec2 tileUv = fract(uv);\n    tileUv = tileUv*2. - 1.;\n    \n    // Background\n    vec3 color = vec3(0.147,0.208,0.320);\n    float cBlur = circ(tileUv, 0.2, 3.192, 2.236);\n    vec3 cBlurColor = vec3(0.228,0.770,0.825);\n    color = mix(color, cBlurColor, cBlur);\n    \n    // Gradient for shape colors using non-tile coordinates\n    vec2 gradientUv = uv - vec2(iTime*3.);\n    float colorGrad = sin(gradientUv.x + gradientUv.y) * 0.2;\n    \n    // Shapes\n    vec2 shapeCoords = rotate2d(3.14/4.)*tileUv;\n    // Square\n    float s = square(shapeCoords, .45, 0.01);\n    vec3 squareColor = vec3(0.427, 0.166 + colorGrad, .5 - colorGrad);\n    // Circle\n    float c = circ(tileUv, 0.504, 0.668, 0.01);\n    vec3 circColor = vec3(0.845,0.756 - colorGrad,.3 + colorGrad);\n\t// Alternate shapes by row/column\n    float circPercent = mod(tileIdx.x + tileIdx.y, 2.);\n    float squarePercent = 1. - mod(tileIdx.x + tileIdx.y, 2.);  \n    float shapeMask = c*circPercent + s*squarePercent;\n    vec3 shapeColor = mix(circColor, squareColor, squarePercent);\n    \n    color = mix(color, shapeColor, shapeMask);\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdXfzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 69, 69, 184], [186, 186, 242, 242, 353], [355, 355, 383, 383, 467], [470, 470, 527, 527, 1810]], "test": "valid"}
{"id": "wdXfzN", "name": "Glitter Depth of Field", "author": "qwert33", "description": "Third step towards building a renderer for https://youtu.be/BtYKDamqo2I?t=334\nMouse click/drag to adjust focal distance.\n\nStep one: https://www.shadertoy.com/view/td2cDy\nStep two: https://www.shadertoy.com/view/tsjyWV", "tags": ["dof", "glitter"], "likes": 3, "viewed": 375, "published": "Public API", "date": "1587807672", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nfloat focalPlane; // along the z-axis\n\n#define TAU 6.28318530718\n#define PI TAU/2.\n\nfloat hash13(in vec3 p) {\n    /*\n\tp  = fract(p * .103177);\n    p += dot(p, p.yzx + 1.91979);\n    return fract((p.x + p.y) * p.z);\n\t*/\n    // This hash is slightly cheaper.\n    return fract(sin(dot(p, vec3(12.9898,78.233,7.279237))) * 43758.5453);\n}\n\n// How many cells around the central_cell we check for ellipses.\n#define SAMPLE_RADIUS 2\nconst float num_layers = 50.;\nconst float depth_of_field = 30.; // the distance between in-focus and having a blurRadius of 1.\n\n/*\n// Debugging things.\nconst vec3 default_debug = vec3(-100, -20, -10);\nconst vec3 orange = vec3(1., .5, 0.);\nconst vec3 cornflowerblue = vec3(100./255., 149./255., 237./255.);\nvec3 debug = default_debug;\n*/\n\nfloat monochrome(vec2 uv) {\n    \n    const float cell_wd = 6.0;\n    vec2 central_cell_center = floor((uv+.5*cell_wd) / cell_wd) * cell_wd;\n    \n\tfloat hashTime = iTime + 100.;  // Don't want thing to be synchonous when the shader starts    \n    \n    float acc = 0.;\n    // Painters algorithm.\n    for (float z = 1.0; z>=-0.001; z -= 1./num_layers) {\n        vec2 shifted_central_cell_center = central_cell_center + cell_wd * vec2(\n            hash13(vec3(10.2, 1.13, z)),\n            hash13(vec3(20.3, 2.34, z))\n        );\n        \n        int j;\n        for (int i = -SAMPLE_RADIUS; i<=SAMPLE_RADIUS; ++i) {\n            for (j = -SAMPLE_RADIUS; j<=SAMPLE_RADIUS; ++j) {\n                vec2 cell_center = shifted_central_cell_center + cell_wd*vec2(ivec2(i,j));\n              \t//cell_center = round(cell_center);\n                //cell_center = round(cell_center);\n\n                float hash_z = 10. * z;\n                vec2 cell_hash_pos = cell_center + vec2(1030., 0);\n                float blurRadius = depth_of_field*abs((z+.5*hash13(vec3(cell_hash_pos, ++hash_z))) - focalPlane);\n\n                float yaw = .1*hashTime + TAU * hash13(vec3(cell_hash_pos, ++hash_z));\n                float angular_speed = 3. + hash13(vec3(cell_hash_pos, ++hash_z));\n                vec2 angular_vel = angular_speed * vec2(cos(yaw), sin(yaw));\n                float pitch = length(angular_vel) * hashTime * 0.6;\n                vec2 a = normalize(angular_vel);  // axis of rotation - major axis of projected ellipse.\n                //vec2 b = vec2(-a.y, a.x) * cos(pitch);  // minor axis\n                vec2 ab = vec2(1., abs(cos(pitch)));\n                vec2 extended_ab = ab + vec2(blurRadius);\n\n                mat2 rot = mat2(a.x, -a.y,\n                                a.y, a.x);\n\n                vec3 normal = vec3(0.0, sin(pitch), cos(pitch));\n                mat3 rot3 = mat3(a.x, -a.y, 0.,\n                                 a.y, a.x, 0.,\n                                 0., 0., 1.);\n                normal = rot3 * normal;\n                const vec3 LIGHT_DIR = normalize(vec3(1.5, -1.0, 2.0));\n                float light_per_area = \n                    .2 + // ambient\n                    100.0 * smoothstep(.98, .99, abs(dot(normal, LIGHT_DIR)));  // cheap (wrong-ish) specular\n                float total_light = light_per_area * ab.x * ab.y;  // total amount of light emitted by this object towards all pixels.\n                // Have a random offset from the cell_center.\n                vec2 ellipse_center = cell_center + (.5*cell_wd - ab.x) * vec2(\n                    sin(hashTime * (.01 + .06*hash13(vec3(cell_hash_pos, ++hash_z)))),\n                    cos(hashTime * (.01 + .06*hash13(vec3(cell_hash_pos, ++hash_z))))\n                );\n                vec2 ellipse_uv = uv - ellipse_center;   \n\n                //float sd = sdEllipse(transpose(rot)*inner_uv, extended_ab);\n                //float sd = sdEllipsoidApproximated(transpose(rot)*inner_uv, extended_ab);\n                float sd = length(rot*ellipse_uv / extended_ab) - 1.;  // Signed distance approximation only accurate for values near zero.\n                float proportional_area = extended_ab.x * extended_ab.y;\n                float edge_blurryness = 0.1/length(extended_ab);\n                float is_in_ellipse = smoothstep(edge_blurryness, -edge_blurryness, sd);\n                \n                \n                float opacity = is_in_ellipse * ab.x / extended_ab.x;\n                //acc = mix(acc, total_light / proportional_area, opacity);\n                //if (opacity > .9) debug=orange;\n                acc *= 1.-(opacity*opacity*opacity*opacity*opacity);  // haax to allow dark in-focus objects in front of blurry backgrounds.\n                acc += opacity * total_light / proportional_area;\n            }\n        }\n    }\n\treturn acc;\n}\n\nvec2 project(vec2 pixel) {\n    vec2 uv = pixel/iResolution.xy - vec2(0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    return uv *50.;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    focalPlane = (iMouse.xy == vec2(0.))? .7 : iMouse.x/iResolution.x;\n    vec3 light = vec3(.1,.2,.9) * monochrome(project(fragCoord));\n    light = 1. - exp(-2. * light); // Simulate exposure\n    fragColor = vec4(light, 1.0);\n    //if (debug != default_debug) fragColor.rgb = debug;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdXfzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[86, 86, 111, 257, 334], [763, 763, 790, 790, 4591], [4593, 4593, 4619, 4619, 4732], [4735, 4735, 4789, 4789, 5075]], "test": "valid"}
{"id": "Wly3Wh", "name": "TRSi Megademo bouncing scroller", "author": "toomuchvoltage", "description": "I really really really wanted to replicate the TRSi Megademo colored bouncing scroller some day :D\n\nRe-play audio and re-wind the shader.\n\nhttps://youtu.be/oTmpqBn4dfA?t=1204", "tags": ["amiga", "megademo", "trsi", "redsector", "tristar"], "likes": 3, "viewed": 267, "published": "Public API", "date": "1586757408", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/***********************************************************\n\n   I really really really wanted to replicate the TRSi Megademo colored bouncing scroller :D\n   See the demo here: https://youtu.be/oTmpqBn4dfA?t=1204\n   2D Simplex by iq: https://www.shadertoy.com/view/Msf3WH\n   3D Simplex by nikat: https://www.shadertoy.com/view/XsX3zB\n\n   Everything else covered under the MIT license:\n\n   Copyright (c) 2020 Baktash Abdollah-shamshir-saz.\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in all\n   copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n\n\n   Hit me up! :)\n\n   Twitter: twitter.com/toomuchvoltage\n   Facebook: fb.com/toomuchvoltage\n   YouTube: youtube.com/toomuchvoltage\n   Mastodon: https://mastodon.gamedev.place/@toomuchvoltage\n   Website: www.toomuchvoltage.com\n\n************************************************************/\n\n#define M_PI 3.1415926535\n\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\nvec2 toSpherical(vec3 inpVec)\n{\n\tvec2 inpVecOnXZ = ((inpVec.xz == vec2 (0.0)) ? vec2 (0.0) : normalize (inpVec.xz));\n\tfloat phi = acos(clamp (inpVecOnXZ.x, -1.0, 1.0));\n\tif (inpVecOnXZ.y < 0.0) phi = (2.0 * M_PI) - phi;\n\tfloat theta = acos(clamp (inpVec.y, -1.0, 1.0));\n\treturn vec2(phi / (2.0*M_PI), theta / M_PI);\n}\n\nconst uint textArr0[34] = uint[](3503345872u,2511917264u,2558840969u,3734340245u,3000032990u,2441386897u,2563807363u,3516236437u,2194717136u,2627506581u,2508378249u,2308742289u,2442494672u,3498679452u,2224984455u,2228262037u,2508378271u,2510000541u,2576909520u,2676215939u,2496697757u,3504245137u,2241319097u,3498279829u,2224134276u,2308019408u,3498285520u,2442436484u,3100696201u,3499458719u,3498418057u,2510002588u,3498351056u,3504265674u);\n\n#define _1_OVER_16 0.0625\n\nfloat worldDensity (vec3 inpCoord, vec3 scale, out float azimuth)\n{\n    if ( iChannelTime[0] > 38.0 )\n    {\n        float fieldForce = pow ((dot (normalize (inpCoord), vec3 (sign(sin(iTime * 5.0)), 0.0, 0.0)) + 1.0) * 0.5, 1.0);\n        float fieldForceRemap = (clamp (fieldForce, 0.5, 1.0) - 0.5) * 2.0;\n        inpCoord = normalize (inpCoord) * (length(inpCoord) + fieldForceRemap * 0.7 * abs(sin(iTime * 5.0))); // Apply force to field\n    \n\t    inpCoord.x -= sin(iTime * 5.0);\n    }\n\n    float icLen = length (inpCoord);\n    if ( icLen < 1.0 || icLen > 2.0 ) return 0.0;\n    vec3 icNorm = inpCoord / icLen;\n    vec2 icNormSph = toSpherical (icNorm);\n    azimuth = icNormSph.x;\n    vec3 sphCoord = vec3 (icNormSph, icLen) * scale;\n    float timeTnt;\n    if ( iChannelTime[0] > 7.75 ) sphCoord.y += sin(iChannelTime[0] + sphCoord.x * 3.0) * 0.5;\n    if ( iChannelTime[0] > 23.0 ) sphCoord.y += sin(iChannelTime[0] + sphCoord.x * 15.0) * 0.1;\n    vec3 intPart;\n    vec3 localCoord = modf (sphCoord, intPart);\n    if ( intPart.y != 5.0 ) return 0.0;\n   \n\n    float textOffset = sphCoord.x + iTime;\n    float textOffsetIntPart;\n    float textOffsetFractPart = modf (textOffset, textOffsetIntPart);\n    int charIndex = int(textOffsetIntPart);\n    int arrIndex = (charIndex / 4) % 34;\n    uint wordFetch = textArr0[arrIndex];\n    uint charFetch = (wordFetch >> ((charIndex % 4) * 8)) & 0x000000FFu;\n    float charX = float (int (charFetch & 0x0000000Fu)     );\n    float charY = float (int (charFetch & 0x000000F0u) >> 4);\n    vec2 charCoords = vec2(charX, charY);\n    \n    vec2 charUVBase = vec2 (_1_OVER_16, _1_OVER_16) * charCoords;\n\tcharUVBase.y = 1.0 + charUVBase.y;\n    return texture (iChannel1, charUVBase + vec2 (textOffsetFractPart, localCoord.z) * vec2(_1_OVER_16, _1_OVER_16)).x;\n}\n\n\nmat4 rotationMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nfloat worldOpaque (vec3 inpCoord, out float azimuth)\n{\n\treturn worldDensity (inpCoord, vec3 (10.0, 10.0, 1.0), azimuth) > 0.5 ? 1.0 : 0.0;\n}\n\nvec2 rotate(vec2 v, float a)\n{\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y / iResolution.x;\n    \n    vec3 curEye = vec3 (0.0, 3.0, -3.0);\n    float timeInt;\n    vec3 curLook = normalize (-curEye);\n    vec3 curSide = normalize (cross (curLook, vec3 (0.0, 1.0, 0.0)));\n    vec3 curUp = cross (curSide, curLook);\n    \n    vec3 sampleDirNorm = normalize (curLook + curUp * uv.y + curSide * uv.x);\n    vec3 sampleDir = sampleDirNorm * 0.01;\n    vec3 samplePt = curEye + sampleDir;\n\n    for (int i = 0; i != 650; i++)\n    {\n        float hitAzimuth;\n        if ( worldOpaque (samplePt, hitAzimuth) == 1.0 )\n        {\n            vec3 azimuthColor;\n            azimuthColor.x = abs (noise(vec2 (iTime * 0.25)));\n            azimuthColor.y = abs (noise(vec2 (iTime * 0.25 + 100.0)));\n            azimuthColor.z = abs (noise(vec2 (iTime * 0.25 + 200.0)));\n            azimuthColor = azimuthColor * 3.0;\n            fragColor.rgb = clamp (samplePt.y + 1.0, 0.0, 1.0) * azimuthColor;\n            return;\n        }\n        samplePt += sampleDir;\n    }\n    \n    float shiftedTime = iTime + 1000.0; // Better noise around here...\n    vec3 tunnelDir = normalize (vec3 (uv.x, uv.y, 1.0));\n    tunnelDir.xy = rotate(tunnelDir.xy, shiftedTime);\n\n    float uvLen = length(tunnelDir.xy);\n    if ( uvLen == 0.0 )\n    {\n        fragColor.rgb = vec3 (0.0);\n        return ;\n    }\n\tvec3 sampleLoc = (10.0 / uvLen) * tunnelDir;\n    sampleLoc.z += shiftedTime * 60.0;\n    fragColor.rgb = vec3 (max(simplex3d(sampleLoc) - 0.75, 0.0) * 10.0) * uvLen;\n}", "image_inputs": [{"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}, {"id": "Xl2GD1", "previewfilepath": "https://soundcloud.com/user-322280034/scrollertrsimegademo", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/user-322280034/scrollertrsimegademo", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wly3Wh.jpg", "access": "shaders20k", "license": "mit", "functions": [[1827, 1827, 1884, 1884, 1999], [2001, 2001, 2027, 2027, 2506], [2508, 2508, 2530, 2530, 2703], [2764, 2764, 2789, 3042, 3959], [3961, 3961, 3992, 3992, 4278], [4751, 4751, 4818, 4818, 6541], [6544, 6544, 6589, 6589, 7217], [7219, 7219, 7273, 7273, 7359], [7361, 7361, 7391, 7391, 7475], [7477, 7477, 7534, 7534, 9062]], "test": "error"}
{"id": "Ws2cD3", "name": "glsl_practice2", "author": "bigdra50", "description": "glsl practice", "tags": ["practice"], "likes": 0, "viewed": 165, "published": "Public API", "date": "1587443951", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = ((fragCoord.xy / iResolution.xy)-.5)*2.;\t// 0 ~ 1 -> -1 ~ 1\n\n    float d = length(pos);\n    vec3 col = vec3(1.-d*sin(iTime*2.5), 1.-d*sin(iTime*3.)+.3, 1.-d*sin(iTime*2.) - .2);\n\n    fragColor = vec4(abs(col), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws2cD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 290]], "test": "valid"}
{"id": "Ws2cDK", "name": "gettin' learnt on ray marching", "author": "Nicholas_Cowge", "description": "a very well commented ray marching demo.  best if you watch some videos on the subject beforehand.", "tags": ["rays"], "likes": 0, "viewed": 24, "published": "Public", "date": "1587351969", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// lower these numbers if it lags\n#define MAX_STEPS 300 \n#define MAX_DIST 100.\n\n//dont touch this or bad things happen\n#define SURF_DIST .001\n\n// pixels in shadow have thier brightness multiplied by this number\n#define AMBIENT_LIGHT 0.1\n\nfloat GetDist(vec3 p) { //this function is called whenever the shader needs the distance to something, so the contents of the scene are placed here.\n    vec4 s = vec4(0, 2, 6, 0.8); //defines the size of the sphere, and the center of its motions\n    s.xz += vec2(sin(iTime*1.5), cos(iTime*1.5))*(cos(iTime*0.5)*2.); // moves the sphere around in a circle\n    s.y += (sin(iTime))*0.6; //moves the sphere up and down\n    \n    \n    \n    float sphereDist = length(p-s.xyz)-s.w;\n    float planeDist = p.y;\n    \n    float d = min(sphereDist, planeDist); //defines the ground plane\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) { //this function works in tandem with the \"GetDist\" function to calculate collisions of rays.\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) { // it does this by esssentially by asking \"are we there yet?\" up to 300 times per pixel.\n        vec3 p = ro + rd*dO;\n        float dS = GetDist(p); //its question gets answered with a distance to \"there\", or the length of thr shortest path to the scene.\n        dO += dS; // it moves up (or marches, hence the name) along the ray by the distance it was given, and asks the question again, but this time it gets the distance from the point on the ray that it previously moved up to.\n        if(dO>MAX_DIST || dS<SURF_DIST) break; // at this point the distance is small enough that it considers itself \"there\", and reports the final distance.\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) { // this function is responsible for figuring out how much light there is at a given surface.\n    float d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3( // calculates how directly the light rays are hitting the surface\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n); // less direct rays will be get a lower brightness, and light rays that hit head-on will get a higher brightness.\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 6, 6);\n    //lightPos.xz += vec2(sin(iTime), cos(iTime))*3.; // moves the light around in a circle.\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = max(dot(n, l), 0.); // calculates shadows by marching a ray from each point that is illuminated to the light.\n    float d = RayMarch(p+n*SURF_DIST*2., vec3(l));\n    if(d<length(lightPos-p)) dif *= AMBIENT_LIGHT; // if the ray does not reach the light source, then it is in shadow, and it's brightnes value is multplied by the ambient light variable.\n    \t\t\t\t\t\t// multiplying the brightness value by the ambient light rather than making it completley black simulates ambient lighting. (go figure.) kinda lazy, but works well enough.\n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) // \"Oh yeah, it's all coming together.\"\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 1, -2);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.));\n    \n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d; \n    \n    float dif = GetLight(p);\n    col = vec3(dif);\n    col = sqrt(col);\n\n    fragColor = vec4(col,1.0); // brings everything together to calculate the color of a single pixel.\n}\t\t\t\t\t\t\t   // repeat for every pixel on the screen, and you have an image.", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws2cDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[238, 238, 261, 386, 828], [830, 830, 864, 957, 1683], [1685, 1685, 1709, 1802, 2174], [2176, 2176, 2200, 2200, 2962], [2964, 2964, 3061, 3061, 3478]], "test": "valid"}
{"id": "Ws2cRh", "name": "Projective Conic Envelope", "author": "mla", "description": "An ellipse, constructed as an envelope of tangent lines.\n\nDual to: [url]https://www.shadertoy.com/view/tdSyDz[/url]\n\nMouse changes ellipse.", "tags": ["envelope", "conic", "projective", "loopless"], "likes": 11, "viewed": 346, "published": "Public API", "date": "1586100203", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Projective Conic Envelope\n//\n// Copyright (c) Matthew Arcus, 2020\n// MIT License: https://opensource.org/licenses/MIT\n//\n// More projective magic - generate an ellipse as an envelope of lines.\n// In fact, we start with the ellipse and find a network of lines\n// enveloping it: at each point p, find tangents to the ellipse,\n// intersect these with a fixed axis at x = -3 - this will be the\n// source of the rays. From axis intersection point, map to a radial\n// parameter, then find closest displayed ray, map that back to the\n// axis and find the tangents from there & these are the lines that\n// actually get displayed.\n//\n// Mouse changes size and orientation of ellipse.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI =  3.141592654;\n\nvec3 join(vec3 p, vec3 q) {\n  // Return either intersection of lines p and q\n  // or line through points p and q, r = kp + jq\n  return cross(p,q);\n}\n\nfloat line(vec3 p, vec3 q) {\n  return abs(dot(p,q)/(p.z*length(q.xy)));\n}\n\n// Set tan1 and tan2 to the two tangents to conic X from point p.\n// Return false if no tangents (eg. inside an ellipse).\nbool tangents(vec3 p, mat3 X, out vec3 tan1, out vec3 tan2) {\n  vec3 polar = X*p; // Line between tangents\n  float a = polar.x, b = polar.y, c = polar.z;\n  // Two points on the polar line. Q is the nearest point to origin,\n  // R is at infinity, ie. is direction vector.\n  vec3 Q = vec3(a,b,-(a*a+b*b)/c);\n  vec3 R = vec3(-b,a,0);\n\n  // Find intersection of QR with conic, ie. dot(Q+kR,X*(Q+kR)) = 0\n  float A = dot(R,X*R), B = dot(Q,X*R), C = dot(Q,X*Q);\n  float D = B*B-A*C;\n  if (D < 0.0) return false;\n  D = sqrt(D);\n  float k1,k2;\n  if (B > 0.0) {\n    k1 = (-B-D)/A; k2 = C/(A*k1);\n  } else {\n    k2 = (-B+D)/A; k1 = C/(A*k2);\n  }\n  tan1 = join(p,Q+k1*R); tan2 = join(p,Q+k2*R);\n  return true;\n}\n\nvec3 hsv2rgb( in vec3 c ) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n  float scale = 3.0;\n  float t = 0.2*iTime+PI/6.0;\n  float A = 0.25, B = 1.0;\n  if (iMouse.x > 0.0) {\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    t += PI*(m.y);\n    B = exp(-m.x);\n  }\n  float cost = cos(t), sint = sin(t);\n  // Conic matrix - conic is points p with pXp = 0\n  mat3 X = mat3(A,0,0,0,B,0,0,0,-1);\n  // Apply tranformation to conic matrix.\n  mat3 P = mat3(cost,sint,0, -sint,cost,0, 0,0,1);\n  X = transpose(P)*X*P;\n\n  vec3 p = vec3(scale*(2.0*fragCoord - iResolution.xy)/iResolution.y,1);\n\n  vec3 col = vec3(0);\n  \n  float lwidth0 = 0.0;\n  float lwidth1 = max(0.02,fwidth(p.x));\n\n  vec3 tan1,tan2,tan11,tan12,tan21,tan22;\n  if (tangents(p,X,tan1,tan2)) {\n    float N = 64.0;\n    vec3 axis = vec3(1,0,3);\n    float index1,index2;\n\n    vec3 p1 = join(tan1,axis);\n    float t1 = atan(p1.y/p1.z);\n    t1 += 0.1*iTime;\n    t1 *= N/PI; t1 = round(t1); index1 = t1; t1 *= PI/N;\n    t1 -= 0.1*iTime;\n    p1 = vec3(-3,tan(t1),1);\n    p1.y = sign(p1.y)*min(abs(p1.y),1e4); // Fix up silly values\n    if (tangents(p1,X,tan11,tan12)) {\n      vec3 c1 = hsv2rgb(vec3(index1/N,1,1));\n      float d = line(p,tan11);\n      col = mix(c1,col,smoothstep(lwidth0,lwidth1,d));\n      float tt = dot(normalize(tan2.xy),normalize(tan12.xy));\n      // Try not to get the wrong tangent here. There must be a better\n      // way of doing this.\n      if (abs(tt) < 0.99) {\n        d = line(p,tan12);\n        col = mix(c1,col,smoothstep(lwidth0,lwidth1,d));\n      }\n    }\n\n    vec3 p2 = join(tan2,axis);\n    float t2 = atan(p2.y/p2.z);\n    t2 += 0.1*iTime;\n    t2 *= N/PI; t2 = round(t2); index2 = t2; t2 *= PI/N;\n    t2 -= 0.1*iTime;\n    p2 = vec3(-3,tan(t2),1);\n    p2.y = sign(p2.y)*min(abs(p2.y),1e4); // Fix up silly values\n    if (tangents(p2,X,tan21,tan22)) {\n      vec3 c2 = hsv2rgb(vec3(index2/N,1,1));\n      float d = line(p,tan22);\n      col = mix(c2,col,smoothstep(lwidth0,lwidth1,d));\n      float tt = dot(normalize(tan1.xy),normalize(tan21.xy));\n      // Try not to get the wrong tangent here.\n      if (abs(tt) < 0.99) {\n        d = line(p,tan21);\n        col = mix(c2,col,smoothstep(lwidth0,lwidth1,d));\n      }\n    }\n  }\n  col = pow(col,vec3(0.4545));\n  fragColor = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws2cRh.jpg", "access": "shaders20k", "license": "mit", "functions": [[879, 879, 906, 1004, 1027], [1029, 1029, 1057, 1057, 1102], [1104, 1226, 1287, 1287, 1926], [1928, 1928, 1955, 1955, 2131], [2133, 2133, 2186, 2186, 4385]], "test": "valid"}
{"id": "ws2cRV", "name": "Apple (redux)", "author": "blackle", "description": "worked on this a lot more and ended up with something that looks a lot better!\n\nold version here. be warned that it compiles VERY slow: https://www.shadertoy.com/view/wsjczK", "tags": ["apple"], "likes": 58, "viewed": 812, "published": "Public API", "date": "1587007786", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nuniform int donttouch;\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(p,ax)*ax, p, cos(ro)) + sin(ro)*cross(ax,p);\n}\n\nfloat linedist(vec2 p, vec2 a, vec2 b) {\n  float k = dot(p-a, b-a)/dot(b-a,b-a);\n  return distance(p, mix(a,b,clamp(k,0.,1.)));\n}\n\nfloat linedist(vec3 p, vec3 a, vec3 b) {\n  float k = dot(p-a, b-a)/dot(b-a,b-a);\n  return distance(p, mix(a,b,clamp(k,0.,1.)));\n}\n\nfloat smin(float a, float b, float k) {\n  float h = max(0., k-abs(a-b))/k;\n  return min(a,b) - k*h*h*h/6.;\n}\n\nfloat hash(float a, float b) {\n  return fract(sin(dot(vec2(a,b), vec2(12.9898, 78.233))) * 43758.5453)*2.-1.;\n}\n\nfloat apple(vec3 p) {\n  p.x += sin(dot(p, vec3(4,2,5)))*0.02;\n  p.z += sin(dot(p, vec3(2,3,7)))*0.02;\n  p.y += sin(dot(p, vec3(2,6,2)))*0.01;\n  \n  vec2 cords = vec2(sqrt(pow(length(p.xy),2.)+0.005), p.z);\n  float sphere1 = length(cords-vec2(0.1,-0.1))-0.85;\n  float sphere2 = length(cords-vec2(0.6,0.6))-0.5;\n  float sphere3 = length(cords-vec2(0.4,-0.8))-0.3;\n  float profile = smin(smin(sphere1, sphere2, 0.9), sphere3, 0.5);\n  float linez = -1.2;\n  float linesub1 = linedist(p, vec3(0,-5,linez), vec3(0,5,linez)) - 0.2;\n  float linesub2 = linedist(p, vec3(-5,0,linez), vec3(5,0,linez)) - 0.2;\n  //return linedist(vec2(profile, p.x), vec2(0), vec2(-10,0))-0.1;\n  return -smin(-profile, smin(linesub1, linesub2, 0.3), 0.4);\n}\n\nvec3 globalstemcoords;\nfloat stem(vec3 p) {\n  float rad = 0.8;\n  float len = 0.6;\n  vec2 torcords = vec2(length(p.xz-vec2(rad,0))-rad, p.y);\n  float tor = length(torcords)-(smoothstep(0., len, p.z)*0.03+0.04);\n  float stemsurf = -smin(-tor, -length(p)+len, 0.06);\n  vec3 stemcords = vec3(atan(torcords.x, torcords.y)*0.1, atan(p.x-rad,p.z), tor);\n  globalstemcoords = stemcords;\n  return stemsurf;\n}\n\nint mat;\nfloat scene(vec3 p) {\n  float body = apple(p - vec3(0,0,1.15));\n  float stm = stem(erot(p, vec3(0,0,1), -0.8)-vec3(0,0,2));\n  float gnd = p.z;\n  float appl = min(stm,body);\n  if (appl < gnd) {\n    mat = 0;\n    if (stm < body) {\n      mat = 2;\n      return stm;\n    }\n    return appl;\n  }\n  mat = 1;\n  return gnd;\n}\n\nfloat scene_proxy(vec3 p) {\n  return min(p.z, min(length(abs(p)-vec3(0,0,1.3))-1., length(abs(p)-vec3(.1,.1,0.5))-0.5));\n}\n\nfloat noise_comp(vec2 p) {\n  vec2 id = floor(p);\n  p = fract(p);\n  float h1 = hash(id.x, id.y);\n  float h2 = hash(id.x+1., id.y);\n  float h3 = hash(id.x, id.y+1.);\n  float h4 = hash(id.x+1., id.y+1.);\n  return mix(mix(h1, h2, p.x), mix(h3, h4, p.x), p.y);\n}\n\nfloat noise(vec2 p) {\n  float n = 0.;\n  for (int i = 0; i < 6; i++) {\n    float h1 = hash(float(i), 8.);\n    float h2 = hash(h1, float(i));\n    float h3 = hash(h2, float(i));\n    n += noise_comp(erot(vec3(p*sqrt(float(i+1))/1.5 + vec2(h2, h3)*100.,0), vec3(0,0,1), h1*100.).xy);\n  }\n  return n/6.;\n}\n\nfloat dots(vec3 p, float scale) {\n  float m = 10000.;\n  for(int i = 0; i < 10; i++) {\n    float ax1 = hash(float(i),68.);\n    float ax2 = hash(ax1,float(i));\n    float ax3 = hash(ax2,float(i));\n    float rot = hash(ax3,float(i));\n    float off = hash(rot,float(i));\n    vec3 ax = normalize(tan(vec3(ax1, ax2, ax3)));\n    vec3 lp = erot(p + off, ax, rot*100.);\n    m = min(m, length((fract(lp/scale)-0.5)*scale));\n  }\n  return m;\n}\n\n/*\nvec3 norm(vec3 p) {\n  mat3 k  = mat3(p,p,p) - mat3(0.001);\n  return normalize(scene(p)-vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}*/\n// suggested from tdhooper. Thanks!\n// improve compilation time & overall fps.\nconst int NORMAL_STEPS = 6;\nvec3 norm(vec3 pos) {\n    vec3 eps = vec3(.01, 0, 0);\n    vec3 nor = vec3(0);\n    float invert = 1.;\n    for (int i = 0; i < NORMAL_STEPS; i++) {\n        nor += scene(pos + eps * invert) * eps * invert;\n        eps = eps.zxy;\n        invert *= -1.;\n    }\n    return normalize(nor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 cam = normalize(vec3(2,uv));\n  vec3 init = vec3(-9,0,1.1);\n  \n  float yrot = 0.3;\n  float zrot = sin(iTime)*0.4-0.9;\n  cam = erot(cam, vec3(0,1,0), yrot);\n  init = erot(init, vec3(0,1,0), yrot);\n  cam = erot(cam, vec3(0,0,1), zrot);\n  init = erot(init, vec3(0,0,1), zrot);\n  vec3 p = init;\n  bool hit = false;\n  for (int i = 0; i < 200 + donttouch; i ++){\n    float dist = scene(p);\n    if (dist*dist < 1e-6) {\n      hit = true;\n      break;\n    }\n    p+=dist*cam;\n  }\n  vec3 localstemcoords = globalstemcoords;\n  int matloc = mat;\n  vec3 n = norm(p);\n  float ao = sqrt(scene_proxy(p+n*0.5)+0.5);\n  ao *= sqrt(scene_proxy(p+n*0.2)/0.2*0.5+0.5);\n  ao *= sqrt(scene_proxy(p+vec3(1))/sqrt(2.)*0.5+0.5);\n  ao *= sqrt(scene_proxy(p+vec3(.5))/sqrt(2.)+0.55);\n  //ao *= smoothstep(0., 0.5, length(p.xy))*0.2+0.8;\n  vec3 r = reflect(cam, n);\n  float wildness = 3.5;\n  float powr = 20.;\n  float specmult = 1.5;\n  vec3 darkcol;\n  vec3 litecol;\n\n  \n  float splaty = noise(p.zy*vec2(2,10))*0.3+0.6;\n  float splatx = noise(p.zx*vec2(2,10)+100.)*0.3+0.6;\n  float splatz = noise(vec2(length(p.xy), atan(p.x,p.y)*5.)+200.)*0.3+0.6;\n  float marble = mix(mix(splaty, splatx, abs(n.y)), splatz, abs(n.z));\n  if (matloc == 1) {\n    darkcol = vec3(0.01);\n    litecol = mix(vec3(1.,0.05,0.04), vec3(0.1), smoothstep(-1.2, 1.8, scene_proxy(p+r)/dot(r,n))*0.7+0.5);\n  } else if (matloc == 0) {\n    litecol = vec3(1.,0.05,0.04);\n    litecol = mix(vec3(1.,0.2,0.15), litecol, sqrt(marble*0.5+0.5));\n    float d = pow(smoothstep(0.01, 0.06, dots(p, 0.26)), 0.4);\n    litecol = mix(vec3(1.1,0.01,0.05), litecol, d);\n    litecol = mix(vec3(1.5,0.45,0.2), litecol, pow(d, 0.2));\n    litecol *= marble;\n    darkcol = litecol*0.02;\n\n    vec3 noffset = vec3(0);\n    noffset.x += cos(dot(p, 8.*vec3(3,2,2)));\n    noffset.z += cos(dot(p, 8.*vec3(4,1,8)));\n    noffset.y += cos(dot(p, 8.*vec3(4,2,2)));\n    noffset.z += cos(dot(p, 10.*vec3(5,2,4)));\n    noffset.y += cos(dot(p, 10.*vec3(1,1,6)));\n    noffset.y += cos(dot(p, 10.*vec3(1,6,2)));\n    noffset.x += cos(dot(p, 10.*vec3(2,1,5)));\n    noffset.x += cos(dot(p, 10.*vec3(3,6,1)));\n    n = normalize(n+noffset*0.01);\n  } else {\n    float grad = smoothstep(2.56, 2.3, p.z);\n    vec2 messscale = vec2(500.,50.);\n    float mess = noise(1.5+localstemcoords.xy*messscale);\n    float mess2 = noise(1.+localstemcoords.xy*messscale);\n    float mess3 = noise(0.5+localstemcoords.xy*messscale);\n    float stemmix = cos(localstemcoords.z*90.-0.8)*0.5+0.5;\n    n = normalize(n - normalize(tan(vec3(mess,mess2,mess3)))*0.3*(stemmix*0.5+0.5));\n    litecol = mix(vec3(0.5,0.07,0.02), vec3(0.4,0.03,0.025), grad);\n    litecol = mix(vec3(0.6,0.3,0.2), litecol, stemmix);\n    powr = 5.;\n    specmult = mix(0.25, 0.1, grad);\n    litecol *= marble;\n    darkcol = litecol*0.04;\n  }\n  r = reflect(cam, n);\n  float spec = pow(length(sin(r*wildness)*0.5+0.5)/sqrt(3.), powr)*specmult;\n  float diff = length(sin(n*wildness)*0.5+0.5)/sqrt(3.)*0.6;\n  vec3 diffcol = mix(darkcol, litecol, diff);\n  vec3 speccol = vec3(1,0.7,0.7)*spec;\n  fragColor.xyz = hit ? ao*(diffcol + speccol) : vec3(0.05);\n  fragColor.xyz = sqrt(fragColor.xyz);\n  fragColor.xyz = mix(fragColor.xyz, smoothstep(vec3(0),vec3(1), fragColor.xyz), 0.3) + hash(hash(uv.x, uv.y), iTime)*0.02;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws2cRV.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[218, 218, 256, 256, 320], [322, 322, 362, 362, 451], [453, 453, 493, 493, 582], [584, 584, 623, 623, 692], [694, 694, 724, 724, 805], [807, 807, 828, 828, 1533], [1558, 1558, 1578, 1578, 1934], [1945, 1945, 1966, 1966, 2259], [2261, 2261, 2288, 2288, 2383], [2385, 2385, 2411, 2411, 2642], [2644, 2644, 2665, 2665, 2943], [2945, 2945, 2978, 2978, 3375], [3622, 3622, 3643, 3643, 3905], [3907, 3907, 3964, 3964, 7362]], "test": "error"}
{"id": "Ws2cWD", "name": "Tile Generator v2. (WIP)", "author": "julianlumia", "description": "tiles tiles tiles", "tags": ["tiles"], "likes": 6, "viewed": 81, "published": "Public", "date": "1586696280", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"Islamic Tile Generator (WIP)\" by julianlumia. https://shadertoy.com/view/tdScWD\n// 2020-04-12 08:06:23\n\n#define pi acos(-1.)\n#define tau (2.*pi)\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n#define S(a, b, t) smoothstep(a, b, t)\n\n// inigo quilez\nfloat sdTri(  vec2 p, float s )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - s;\n    p.y = p.y + s/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdCircle( vec2 p, float r )\n{\n  return length(p) - r;\n}\n\n\n\nfloat sdOctogon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.9238795325, 0.3826834323, 0.4142135623 );\n    p = abs(p);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\n//from iq : https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat smin( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord  )\n{\n vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;    \n\n    uv *= 2.;\n    \n vec3 col = vec3(0);\n float d = 10e6;\n float triA;\n uv = fract(vec2(uv.x-0.0,uv.y-.5)) -.5;\n uv *= .75;\n         vec2 cuv = uv;\n\n float wave =19.;\n float wavemultip = 0.05;//sin(iTime*0.5)*.2+0.2*.9;\n float offset = (sin(iTime*0.7)*0.5)*0.03;\n vec2 uv2;\n vec2 objsize =vec2(abs(uv.x*3.)*.01+0.01,1.);\n for(int i = 0; i <4; ++i)\n {\n  uv = vec2((uv)*rot(float(.25)*pi));\n  vec2 wpos = vec2(uv.x+sin(uv.y*wave)*wavemultip,uv.y)*1.;\n  triA = sdBox(wpos+offset, objsize);\n float   triB = sdBox(wpos-offset, objsize);\n triA = min(triB, triA);       \n float   triC = sdBox(vec2(uv.x+sin(uv.y*wave-pi)*wavemultip,uv.y)-offset, objsize);\n float   triD = sdBox(vec2(uv.x+sin(uv.y*wave-pi)*wavemultip,uv.y)+offset, objsize);\n triC = min(triC, triD);\n triA = min(triC, triA);\nif( triA < d)\n {\n  d = triA;\n  }\n } \n float c;   \n   // vec2 cuv = uv;\ncuv*= 1.;\n    cuv += vec2(0.0,0.);\n\ncuv = abs(cuv)-.50;\n    for(int i = 0; i <1; ++i)\n  {\ncuv += vec2(0.2);\n\n      cuv = vec2((cuv)*rot(float(.25)*pi));\n\ncuv = abs(cuv)-.1+(offset);\n     //   cuv = vec2((cuv)*rot(float(.05)*pi));\n      c = sdOctogon(vec2((cuv.x)+float(i)*.2,cuv.y+float(i)*.05),.16);\n      \n   float c2 = c +0.02;\n   c = max(c,-c2);\n if( c < d)\n  {\n   c = c;\n  }\n } \n float ca = sdOctogon(vec2((uv.x),uv.y),.36);\n float c2a = ca -0.2;\n ca = max(ca,c2a);\n    ca += .0;\n// triA = min(triA,-ca);\n triA = min(triA,c);\n d = min(d, triA);\n col += smoothstep(0.01,1./iResolution.y,-d);\n col = col;\n fragColor = vec4(col,1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws2cWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[247, 263, 296, 296, 503], [504, 504, 556, 556, 675], [677, 677, 712, 712, 738], [742, 742, 784, 784, 1068], [1070, 1154, 1198, 1198, 1298], [1300, 1300, 1337, 1337, 1417], [1419, 1419, 1477, 1477, 3033]], "test": "valid"}
{"id": "ws2cWt", "name": "Mandelbrot Constructed Smoothly", "author": "matthen", "description": "Mandelbrot Constructed Smoothly", "tags": ["fractal", "mandelbrot"], "likes": 9, "viewed": 448, "published": "Public", "date": "1587540330", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 square(in vec2 z) {\n\treturn vec2(z.x * z.x - z.y * z.y, 2. * z.x * z.y);   \n}\n\n\nvec2 map(in vec2 uv, in float t) {\n    vec2 z = uv;    \n    \n    for (float i = 0.; i < t; i += 1.) {\n        if(length(z) > 100.) {\n            return z;   \n        }\n        vec2 newZ = square(z) + uv;\n        z = (\n            smoothstep(0., 1., t - i) * newZ\n            + (1. - smoothstep(0., 1., t - i)) * z\n        );\n    }\n    return z;\n}\n\n\nvec3 gradient(in vec2 z) {\t\n    float r = length(z);\n    r /= 3.;\n    r = pow(r, 0.6);\n    vec3 rainbow = 0.5 + 0.5 * cos((5.5 * r + vec3(0.2, 0.45, 0.8)*6.));\n    rainbow *= (1. - smoothstep(1., 1.03, r));\n    rainbow *= (smoothstep(0.0, 0.03, abs(r-0.4)));\n    return rainbow;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / min(iResolution.y, iResolution.x);\n    \n    float t = iTime;\n    \n    t = mod(t, 14.);\n    t = 0.1 * t * t;\n    t = min(t, 16.);\n    \n    uv.x -= 0.2 * smoothstep(0., 5., t);\n    \n    uv *= 15.;\n    uv /= 1. + 5. * smoothstep(0., 5., t);\n\t\n    uv = map(uv, t);\n    //float col = smoothstep(0., 0.01, abs(length(uv)-1.));\n    \n    \n    vec3 rgb = gradient(uv);\n    \n    fragColor = vec4(rgb, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws2cWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 82], [85, 85, 119, 119, 431], [434, 434, 460, 460, 714], [717, 717, 772, 772, 1222]], "test": "valid"}
{"id": "Ws2czV", "name": "Da Rasterizer-v2", "author": "jorge2017a1", "description": "//Da Rasterizer\n///https://www.shadertoy.com/view/MsjSzz\n\n//Example of Rasterizer .... Da Rasterizer by TDM ....\n//https://www.shadertoy.com/view/MsjSzz\n///Modificado por Jorge f.p //jorge2017a1", "tags": ["darasterizermodificadov2"], "likes": 7, "viewed": 122, "published": "Public", "date": "1586982664", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Da Rasterizer\n///https://www.shadertoy.com/view/MsjSzz\n\n//Example of Rasterizer .... Da Rasterizer by TDM ....\n//https://www.shadertoy.com/view/MsjSzz\n///Modificado por Jorge f.p //jorge2017a1\n\n\n#define LINEAR_ROTATION\n\n#define WEIGHT (3.0 / iResolution.x)\nconst vec3 RED = vec3(1.0,0.0,0.0);\nconst vec3 GREEN = vec3(0.0,1.0,0.0);\nconst vec3 BLUE = vec3(0.0,0.8,1.0);\nconst vec3 WHITE = vec3(1.0,1.0,0.97);\nconst vec3 YELLOW = vec3(1.0,1.0,0.0);\n\n// rasterize functions\nfloat line(vec2 p, vec2 p0, vec2 p1, float w) {\n    vec2 d = p1 - p0;\n    float t = clamp(dot(d,p-p0) / dot(d,d), 0.0,1.0);\n    vec2 proj = p0 + d * t;\n    float dist = length(p - proj);\n    dist = 1.0/dist*WEIGHT*w;\n    return min(dist*dist,1.0);\n}\nfloat circle(vec2 p, vec2 c, float r, float w) {\n    float dist = abs(length(p - c)) + r;\n    dist = 1.0/dist*WEIGHT*w;\n    return min(dist*dist,1.0);\n}\n\n// matrices\nmat4 getRotMatrix(vec3 a) {\n    vec3 s = sin(a);\n    vec3 c = cos(a);    \n    mat4 ret;\n    ret[0] = vec4(c.y*c.z,c.y*s.z,-s.y,0.0);\n    ret[1] = vec4(s.x*s.y*c.z-c.x*s.z,s.x*s.y*s.z+c.x*c.z,s.x*c.y,0.0);\n    ret[2] = vec4(c.x*s.y*c.z+s.x*s.z, c.x*s.y*s.z-s.x*c.z,   c.x*c.y,0.0);    \n    ret[3] = vec4(0.0,0.0,0.0,1.0);\n    return ret;\n}\nmat4 getPosMatrix(vec3 p) {   \n    mat4 ret;\n    ret[0] = vec4(1.0,0.0,0.0,p.x);\n    ret[1] = vec4(0.0,1.0,0.0,p.y);\n    ret[2] = vec4(0.0,0.0,1.0,p.z);   \n    ret[3] = vec4(0.0,0.0,0.0,1.0);\n    return ret;\n}\n\n// utils\nvec3 mix3(vec3 a, vec3 b, vec3 c, float t) {\n    if(t>0.5) return mix(b,c,t*2.0-1.0);\n    else return mix(a,b,t*2.0);\n}\nvec3 fragment(vec3 p) {\n    float t = sin(p.x*0.8+iTime*0.5)*0.5+0.5;\n    float fog = min(pow(p.z,3.0)*400.0,1.0);\n    return mix3(RED,GREEN,BLUE,t) * fog;\n}    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    //uv = uv * (1.0 + pow(length(uv)*0.4,0.5)) * 0.6;\n    \n    float line_width = 0.4;\n    float time = iTime * 0.31415;\n    vec3 c = vec3(mix(vec3(0.19,0.13,0.1),vec3(1.0), 0.5*pow(length(uv)*0.5,2.0)));\n    mat4 cam = getPosMatrix(vec3(0.0,0.0,10.0));\n    \n#ifdef LINEAR_ROTATION\n    mat4 rot = getRotMatrix(vec3(time,time*0.86,time*0.473));\n#else\n    float p = 0.08;\n    mat4 rot = getRotMatrix(vec3(time\t\t+sin(time*30.0)*p,\n                                 time*0.860\t+sin(time*20.0)*p*1.24,\n                                 time*0.473\t+sin(time*10.0)*p));\n#endif\n    \n    \n    \n    \n    vec3 instances1[18];\n    instances1[0] = vec3( 0.0, 0.0,-1.0);\n    instances1[1] = vec3(-1.0, 0.0,-1.0);\n    instances1[2] = vec3( 1.0, 0.0,-1.0);\n    instances1[3] = vec3(-1.0, 0.0, 0.0);\n    instances1[4] = vec3( 1.0, 0.0, 0.0);\n    instances1[5] = vec3( 0.0, 0.0, 1.0);\n    instances1[6] = vec3(-1.0, 0.0, 1.0);\n    instances1[7] = vec3( 1.0, 0.0, 1.0);\n    \n    \n    \n    \n        // box pipeline\n    //for(int dip = 0; dip < 18; dip++) \n    for(int dip = 0; dip < 8; dip++) \n    {\n        \n        // input assembly\n        vec3 vert[5];\n        \n        vert[0] = vec3(-1.0,0.0, 1.0);\n        vert[1] = vec3(1.0, 0.0, 1.0);    \n        vert[2] = vec3(1.0, 0.0, -1.0);    \n        vert[3] = vec3(-1.0,0.0, -1.0);\n        vert[4] = vec3(0.0, 1.0, 0.0)*vec3(1.0,5.0,1.0);\n        \n        \n        \n\n        // vertex processing        \n        mat4 pos = getPosMatrix(instances1[dip] * 4.0);\n        mat4 mat = pos * rot * cam;\n\n        for(int i = 0; i < 5; i++) {\n\n            // transform\n            vert[i] = (vec4(vert[i],1.0) * mat).xyz;\n\n            // perspective\n            vert[i].z = 1.0 / vert[i].z;\n            vert[i].xy *= vert[i].z;\n        }    \n\n        // primitive assembly and rasterize\n        float i;\n        \n        //cuadro inferior\n        i  = line(uv,vert[0].xy,vert[1].xy,line_width);\n        i += line(uv,vert[1].xy,vert[2].xy,line_width);\n        i += line(uv,vert[2].xy,vert[3].xy,line_width);\n        i += line(uv,vert[3].xy,vert[0].xy,line_width);\n        \n        // 1er triangulo\n        i += line(uv,vert[0].xy,vert[1].xy,line_width);\n        i += line(uv,vert[1].xy,vert[4].xy,line_width);\n        i += line(uv,vert[4].xy,vert[0].xy,line_width);\n        \n        \n        // 2do triangulo\n        i += line(uv,vert[1].xy,vert[2].xy,line_width);\n        i += line(uv,vert[2].xy,vert[4].xy,line_width);\n        i += line(uv,vert[4].xy,vert[1].xy,line_width);\n        \n        // 3do triangulo\n        i += line(uv,vert[0].xy,vert[4].xy,line_width);\n        i += line(uv,vert[4].xy,vert[3].xy,line_width);\n        i += line(uv,vert[3].xy,vert[0].xy,line_width);\n        \n        // 4to triangulo\n        i += line(uv,vert[2].xy,vert[4].xy,line_width);\n        i += line(uv,vert[4].xy,vert[3].xy,line_width);\n        i += line(uv,vert[3].xy,vert[2].xy,line_width);\n        \n        \n       \n\n        c += fragment(vert[0]) * min(i,1.0);\n    }\n        \n\n    \n    \n    \n    \n    // fragment\n\tfragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws2czV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[449, 472, 519, 519, 721], [722, 722, 770, 770, 874], [876, 888, 915, 915, 1226], [1227, 1227, 1254, 1254, 1436], [1438, 1447, 1491, 1491, 1566], [1567, 1567, 1590, 1590, 1724], [1730, 1730, 1787, 1787, 4949]], "test": "valid"}
{"id": "ws2yR1", "name": "CG lab 3  Ellipsoid ", "author": "pgkg", "description": "simple Ellipsoid ray tracer", "tags": ["ellipsoid"], "likes": 1, "viewed": 67, "published": "Public", "date": "1586128262", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Макаров И 4.2 \n//поворот в радианах\n#define ellipsoidRotationAlongX 3.1415/4.0\n#define ellipsoidRotationAlongY 3.1415\n#define ellipsoidRotationAlongZ 3.1415\n//полуоси \n#define ellipsoidSizeX 2.0\n#define ellipsoidSizeY 1.0\n#define ellipsoidSizeZ 1.0\n//точность (т.к. используются ЧМ, то возможна нехватка производительности)\n#define numberOfIteration 50\n\n//rotation matrix reference - https://gist.github.com/yiwenl/3f804e80d0930e34a0b33359259b556c\nmat4 rotationMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec3 rotate(vec3 v, vec3 axis, float angle) {\n\tmat4 m = rotationMatrix(axis, angle);\n\treturn (m * vec4(v, 1.0)).xyz;\n}\nbool pointInsideEllipsoid(vec3 point, vec3 center)\n{\n    float a = ellipsoidSizeX;\n    float b = ellipsoidSizeY;\n    float c = ellipsoidSizeZ;\n    point = rotate(point, vec3(0.0, 0.0, 1.0), ellipsoidRotationAlongX);\n    point = rotate(point, vec3(0.0, 1.0, 0.0), ellipsoidRotationAlongY);\n    point = rotate(point, vec3(1.0, 0.0, 0.0), ellipsoidRotationAlongZ);\n\tif(pow(point.x, 2.0) / pow(a, 2.0) + pow(point.y, 2.0) / pow(b, 2.0) + pow(point.z, 2.0) / pow(c, 2.0) <= 1.0)\n    {\n\t\treturn true;\n    } else {\n     \treturn false;   \n    }\n}\n\nfloat sic(vec3 ro, vec3 rd, vec3 so, float r)\n{\n\tconst int nos = numberOfIteration;\n    float d = 0.0;\n    vec3 cd = so - ro;\n\tfloat stepSize = (sqrt((pow(length(so - ro), 2.0)) + (r * r)) / float(nos));\n    for(int i = 0; i < nos; i++)\n    {\n\t\td = d + stepSize;\n        if(pointInsideEllipsoid(ro + rd * d, so) == true)\n        {\n\t\t\treturn d;\n        }\n    }\n    return -1.0;\n}\n//background function reference - https://www.shadertoy.com/view/ldS3DW#\nvec3 background(float t, vec3 rd, vec3 sunPos)\n{\n\tvec3 light = normalize(sunPos);\n\tfloat sun = max(0.0, dot(rd, light));\n\tfloat sky = max(0.0, dot(rd, vec3(0.0, 1.0, 0.0)));\n\treturn \n\t\t(pow(sun, 256.0)+0.2*pow(sun, 2.0))*vec3(2.0, 1.6, 1.0) +\n\t\tpow(sky, 1.0)*vec3(0.5, 0.6, 0.7);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //нормализуем координаты от -1 до 1 \n    vec2 uv = (-1.0 + 2.0*fragCoord.xy / iResolution.xy) * \n\t\tvec2(iResolution.x/iResolution.y, 1.0);\n    //нормализуем кординаты клика мыши\n    vec2 nmc = (-1.0 + 2.0*iMouse.zw / iResolution.xy) * \n\t\tvec2(iResolution.x/iResolution.y, 1.0);\n    vec2 nmd = (-1.0 + 2.0*iMouse.xy / iResolution.xy) * \n\t\tvec2(iResolution.x/iResolution.y, 1.0);\n    //позиция камеры и ray origin\n    vec3 cameraPos = rotate(vec3(nmd.x * 1.0, nmd.y * 1.0, -5.0), vec3(0.0, 1.0, 0.0), mod(iTime, 6.283));\n    //позиция экрана и ray direction\n    vec3 pixelGridPos = rotate(normalize(vec3(uv, 1)), vec3(0.0, 1.0, 0.0), mod(iTime, 6.283));\n    vec3 spherePos = vec3(0.0, 0.0, 0.0);\n    vec3 sunPos = vec3(2.0, 3.0, -5.0);\n    float id = sic(cameraPos, pixelGridPos, spherePos, 1.0); //intersection distance -1 если не пересекает\n    vec3 hp = cameraPos + pixelGridPos * sic(cameraPos, pixelGridPos, spherePos, 1.0); //точка пересечения\n    if(id < -0.00001)\n    {\n\t\tfragColor = vec4(background(id, pixelGridPos, sunPos), 1.0);\n    } else {\n        vec3 reflectDir = normalize(hp - spherePos);\n        float dotSign = dot(hp - spherePos, sunPos - hp);\n        if(dotSign >= 0.0)\n        {\n            float angle = (3.1415 - acos(dot(hp - spherePos, sunPos - hp)/length(hp - spherePos) / length(sunPos - hp)))/3.1415;\n        \tfragColor = vec4(vec3(1.0, 1.0, 1.0) * angle, 1.0); \n        } else {\n            fragColor = vec4(vec3(1.0, 1.0, 1.0) * 0.5 , 1.0);\n        }\n        \n         \n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws2yR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[448, 542, 587, 587, 1215], [1217, 1217, 1262, 1262, 1335], [1336, 1336, 1388, 1388, 1874], [1876, 1876, 1923, 1923, 2254], [2255, 2328, 2376, 2376, 2609], [2610, 2610, 2667, 2733, 4298]], "test": "valid"}
{"id": "Ws2yR3", "name": "RivLand", "author": "rivFox", "description": "Land", "tags": ["land"], "likes": 1, "viewed": 104, "published": "Public", "date": "1587067172", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M_PI 3.1415926535897932384626433832795\n\n// Official HSV to RGB conversion \n// source: https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n//https://gist.github.com/ayamflow/c06bc0c8a64f985dd431bd0ac5b557cd\nvec2 rotateUV(vec2 uv, float rotation)\n{\n    float mid = 0.0;\n    return vec2(\n        cos(rotation) * (uv.x - mid) + sin(rotation) * (uv.y - mid) + mid,\n        cos(rotation) * (uv.y - mid) - sin(rotation) * (uv.x - mid) + mid\n    );\n}\n\nfloat DrawCircle(vec2 uv, float pixelSize, float time, float timeOffset, float paramA, float paramB)\n{\n    time+=timeOffset;\n    vec2 center = vec2(cos(time + timeOffset) + 0.5, sin(time + timeOffset)) - 0.5;\n    float dist = distance(uv, center) * paramA;\n   \tfloat circle = 1.0 - (step(paramB, dist));\n    float circleLight = 1.0 - clamp(dist, 0.0, 1.0);\n    circle+=circleLight;\n    \n    circle = clamp(circle, 0.0, 1.0);\n    return circle;\n}\n\n\nvec4 DrawMoon(vec2 uv, float pixelSize, float worldTime)\n{\n    float circle = DrawCircle(uv, pixelSize, worldTime, M_PI * 0.5, 4.0, 0.4);\n    return vec4(circle);\n}\n\nvec4 DrawRainbow(vec2 uv, float pixelSize, float worldTime)\n{\n    pixelSize *= 10.0;\n    \n    uv *= 0.8;\n    uv.y += 0.8;\n    \n    worldTime *= 2.0;\n    float vertAlpha = step(0.4, uv.y);\n    uv = rotateUV(uv, 3.0 -worldTime);\n\n\n    \n    float dist = distance(uv, vec2(0.0));\n    vec3 rgb = hsv2rgb(vec3( pow(dist, 5.0), 1.0, 1.0));\n    float alpha = 1.0 \n                - smoothstep(dist - pixelSize, dist + pixelSize, 0.9) \n                - smoothstep(1.1 - pixelSize, 1.1 + pixelSize, dist);\n                                \n\n    float angle = (atan(uv.y, uv.x))/(M_PI*2.0) + .5;\n    angle = 0.0 + smoothstep(0.5 - pixelSize, 0.5 + pixelSize, angle)\n                + (1.0 - smoothstep(0.1 - pixelSize, 0.1 + pixelSize, angle));\n\n    return vec4(rgb, alpha * angle * 0.6 * vertAlpha);\n}\n\nvec4 DrawSun(vec2 uv, float pixelSize, float worldTime)\n{\n    float circle = DrawCircle(uv,pixelSize, worldTime, 0.0, 1.5, 0.2);\n\n    vec3 yellow = vec3(1.0, 1.0, 0);\n    vec3 organge = vec3(1.0, 0.3, 0);\n    \n    float colorTime = (cos(worldTime * 2.0) + 1.0) * 0.5;\n    vec3 color = mix(yellow, organge, colorTime);\n    \n    vec3 sun = vec3(circle);\n    sun *= 1.1 - clamp(colorTime, 0.0, 0.5);               \n    sun *= color;\n      \n    return vec4(sun, circle);\n\t//return vec4(color, 1.0);\n}\n\nvec4 DrawWave(vec2 uv, float pixelSize, float period, float amplitude, float hight, float speed, vec3 color)\n{\n    float sinus = sin(uv.x * period + iTime * speed) * amplitude + hight;\n    float landMask = (1.0 - smoothstep(sinus - pixelSize, sinus + pixelSize, uv.y));\n    return vec4(landMask * color, landMask);\n}\n\nvec4 DrawLight(vec2 uv, float worldTime)\n{\n\tfloat light = DrawCircle(uv, 0.0, worldTime, 0.0, 0.3, 0.0);\n    \n    float isDay = clamp(sin(worldTime * 1.0), 0.0, 0.75);\n    \n    light *= isDay;\n    light = clamp(light, 0.0, 0.5);\n\tvec3 color = vec3(1.0, 1.0, 0.6);\n       \n    return vec4(vec3(light*color), light);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\tfloat worldTime = iTime * 0.2;\n    float pixelSize = 2.0 / iResolution.y;\n    \n    vec4 bg = vec4(0.0071, 0, 0.10, 1.0);\n    vec4 sun = DrawSun(uv, pixelSize, worldTime);\n    vec4 moon = DrawMoon(uv, pixelSize, worldTime);\n    vec4 rainbow = DrawRainbow(uv, pixelSize, worldTime);\n    vec4 wave1 = DrawWave(uv, pixelSize, 4.0, 0.10, -0.2, 1.0, vec3(0.125, 0.266, 0.203));\n    vec4 wave2 = DrawWave(uv, pixelSize, 3.0, 0.05, -0.4, 2.0, vec3(0.180, 0.372, 0.243));\n    vec4 wave3 = DrawWave(uv, pixelSize, 1.0, 0.03, -0.6, 5.0, vec3(0.254, 0.541, 0.309));\n    vec4 light = DrawLight(uv, worldTime);\n    \n    fragColor = bg;\n    fragColor = mix(fragColor, vec4(sun), sun.a);\n    fragColor = mix(fragColor, vec4(moon), moon.a);\n    fragColor = mix(fragColor, vec4(wave1), wave1.a);\n    fragColor = mix(fragColor, vec4(rainbow), rainbow.a);\n    fragColor = mix(fragColor, vec4(wave2), wave2.a);\n    fragColor = mix(fragColor, vec4(wave3), wave3.a);\n    fragColor = mix(fragColor, vec4(light), light.a);\n\n\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws2yR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 132, 159, 159, 285], [287, 355, 395, 395, 591], [593, 593, 695, 695, 1038], [1041, 1041, 1099, 1099, 1205], [1207, 1207, 1268, 1268, 1998], [2000, 2000, 2057, 2057, 2496], [2498, 2498, 2608, 2608, 2814], [2816, 2816, 2858, 2858, 3132], [3134, 3134, 3191, 3241, 4311]], "test": "valid"}
{"id": "ws2yWc", "name": "Hoop rush", "author": "gaz", "description": "https://twitter.com/gaziya5/status/1251824948382855170", "tags": ["3d", "2tweets"], "likes": 7, "viewed": 162, "published": "Public", "date": "1587470028", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 O, vec2 C)\n{\n    O-=O;\n\tfor(float g,e,i=0.;i<30.;i++)\n    {\n        vec3 p=vec3(C.xy/iResolution.y-.6,1.)*g;\n        p.xy+=sin(iTime)*.1;\n        g+=e=length(vec2(mod(length(p.xy),.4)-.2,mod(p.z+iTime*2.,.8)-.4))-.01;\n        O+=cos(vec4(6,2,9,0)+atan(p.x,p.y)*16.)*((e<.01)?1./i:0.);\n    }\n}\n\n/*\n// thanks jeyko\n\n#define lengthH(p) length(p)/2.\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O-=O;\n\tfor(float g,e,i=0.;i<30.;i++)\n    {\n        vec3 p=vec3(C.xy/iResolution.y-.6,1.)*g;\n        p.xy+=sin(iTime)*.1;\n        g+=e=lengthH(vec2(mod(length(p.xy),.4)-.2,mod(p.z+iTime*2.,.8)-.4))-.01;\n        O+=cos(vec4(6,2,9,0)+atan(p.x,p.y)*16.)*((e<.01)?1./i:0.);\n    }\n}\n*/\n\n/*\n#define lengthN(p) pow(abs(dot(p,p)),.7)*2.\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O-=O;\n\tfor(float g,e,i=0.;i<30.;i++)\n    {\n        vec3 p=vec3(C.xy/iResolution.y-.6,1.)*g;\n        p.xy+=sin(iTime)*.1;\n        g+=e=lengthN(vec2(mod(length(p.xy),.4)-.2,mod(p.z+iTime*2.,.8)-.4))-.01;\n        O+=cos(vec4(6,2,9,0)+atan(p.x,p.y)*16.)*((e<.01)?1./i:0.);\n    }\n}\n*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws2yWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 316]], "test": "valid"}
{"id": "Ws2yWd", "name": "Penumbra Shadows on Chess Board", "author": "fakeljl", "description": "Penumbra Shadows.", "tags": ["softshadows"], "likes": 1, "viewed": 77, "published": "Public", "date": "1587576618", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int RAY_STEPS = 256;\nconst float FOV = 45.0 * 3.14159 / 180.0;\n\nstruct Intersection {\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n};\n    \nmat4 scale(vec3 s){\n    return mat4(\n        vec4(s.x,   0.0, 0.0, 0.0),\n        vec4(0.0, s.y,   0.0, 0.0),\n        vec4(0.0, 0.0, s.z,   0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n}\n\nmat4 translate(vec3 t){\n    return mat4(\n        vec4(1.0, 0.0, 0.0, 0.0),\n        vec4(0.0, 1.0, 0.0, 0.0),\n        vec4(0.0, 0.0, 1.0, 0.0),\n        vec4(t.x,   t.y,   t.z,   1.0)\n    );\n}\n\nmat4 rotateX(float theta){\n    theta *= 3.14159 / 180.0;\n    return mat4(\n        vec4(1.,0.,0.,0),\n        vec4(0.,cos(theta),-sin(theta),0.),\n        vec4(0.,sin(theta),cos(theta),0.),\n        vec4(0.,0.,0.,1.));\n}\n\nmat4 rotateY(float theta){\n    theta *= 3.14159 / 180.0;\n    return mat4(\n        vec4(cos(theta),0.,-sin(theta),0),\n        vec4(0.,1.,0.,0.),\n        vec4(sin(theta),0.,cos(theta),0.),\n        vec4(0.,0.,0.,1.));\n}\n\nmat4 rotateZ(float theta){\n    theta *= 3.14159 / 180.0;\n    return mat4(\n        vec4(cos(theta),-sin(theta),0.,0),\n        vec4(sin(theta),cos(theta),0.,0.),\n        vec4(0.,0.,1.,0.),\n        vec4(0.,0.,0.,1.));\n}\n\nfloat plane(vec3 p, vec4 n) {\n    return dot(p, n.xyz) + n.w;\n}\n    \nfloat sphere(vec3 p, float r, vec3 c) {\n    return distance(p, c) - r;\n}\n\nfloat dot2( vec3 v ) { return dot(v,v); }\nfloat udQuad( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d ) {\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 dc = d - c; vec3 pc = p - c;\n  vec3 ad = a - d; vec3 pd = p - d;\n  vec3 nor = cross( ba, ad );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ad,nor),pd))<3.0)\n     ?\n     min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat box(vec3 pos, vec3 t, vec3 r, vec3 s) {\n    mat4 worldInverse = inverse(translate(t) * rotateX(r.x) * rotateY(r.y) * rotateZ(r.z) * scale(s));\n    vec3 p = vec3(worldInverse * vec4(pos, 1));\n    float sFactor = min(min(abs(s.x), abs(s.y)), abs(s.z));\n    float dX = 0.0;\n    float dY = 0.0;\n    float dZ = 0.0;\n    if (p.x > 0.5) {\n        dX = p.x - 0.5;\n    }\n    else if (p.x < -0.5) {\n        dX = -0.5 - p.x;\n    }\n    if (p.y > 0.5) {\n        dY = p.y - 0.5;\n    }\n    else if (p.y < -0.5) {\n        dY = -0.5 - p.y;\n    }\n    if (p.z > 0.5) {\n        dZ = p.z - 0.5;\n    }\n    else if (p.z < -0.5) {\n        dZ = -0.5 - p.z;\n    }\n    if (dX == 0.0 && dY == 0.0 && dZ == 0.0) {\n        float xmin = min(0.5 - p.x, p.x + 0.5);\n        float ymin = min(0.5 - p.y, p.y + 0.5);\n        float zmin = min(0.5 - p.z, p.z + 0.5);\n        return -min(min(xmin, ymin), zmin) * sFactor;\n    }\n    else {\n        return sqrt(dX * dX + dY * dY + dZ * dZ) * sFactor;\n    }\n}\n\nvoid rayCast(vec2 uv, out vec3 dir, out vec3 eye, out vec3 ref) {\n    eye = vec3(15.0 * sin(0.3 * iTime), 5.0, 15.0 * cos(0.3 * iTime));\n    ref = vec3(0.0, 0.0, 0.0);\n    \n    float len = tan(FOV * 0.5) * distance(eye, ref);\n    vec3 H = normalize(cross(ref - eye, vec3(0.0, 1.0, 0.0)));\n    vec3 V = normalize(cross(H, ref - eye));\n    V *= len;\n    H *= len * iResolution.x / iResolution.y;\n    vec3 p = ref + uv.x * H + uv.y * V;\n    dir = normalize(p - eye);\n}\n\nvec3 computeMaterial(int hitObj, vec3 p, vec3 d, vec3 n) {\n    switch(hitObj) {\n        case 0: // Floor\n        float t = mod(floor(0.25 * p.x), 2.0) == mod(floor(0.25 * p.z), 2.0) ? 1.0 : 0.0;\n        return mix(vec3(0.5), vec3(1.0), t);\n        break;\n        case 1: // Sphere Red\n        return vec3(0.63, 0.065, 0.05);\n        break;\n        case 2: // Short Cube\n        return vec3(0.85, 0.81, 0.78);\n        break;\n        case -1:\n        return vec3(0.0);\n        break;\n    }\n    return vec3(0.0);\n}\n\nvoid sceneMap3D(vec3 pos, out float t, out int obj) {\n    t = plane(pos, vec4(0.0, 1.0, 0.0, 2.5));\n    obj = 0; // Floor\n    float t2;\n    \n    if ((t2 = sphere(pos, 2.5, vec3(10.0, 2.5, 3.0))) < t) {\n        t = t2;\n        obj = 1; // Sphere Red\n    }\n    if ((t2 = box(pos, vec3(-2.0, -1.0, 0.75), vec3(0.0, -17.5, 0.0), vec3(3, 3, 3))) < t) {\n        t = t2;\n        obj = 2; // Short Cube\n    }\n}\n\nfloat sceneMap3D(vec3 pos) {\n    float t;\n    int o;\n    sceneMap3D(pos, t, o);\n    return t;\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj) {\n    t = 0.001;\n    for(int i = 0; i < RAY_STEPS; ++i)\n    {\n        vec3 pos = origin + t * dir;\n    \tfloat m;\n        sceneMap3D(pos, m, hitObj);\n        if(m < 0.01)\n        {\n            return;\n        }\n        t += m;\n    }\n    t = -1.0;\n    hitObj = -1;\n}\n\nvec3 computeNormal(vec3 pos) {\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( sceneMap3D(pos + epsilon.yxx) - sceneMap3D(pos - epsilon.yxx),\n                            sceneMap3D(pos + epsilon.xyx) - sceneMap3D(pos - epsilon.xyx),\n                            sceneMap3D(pos + epsilon.xxy) - sceneMap3D(pos - epsilon.xxy)));\n}\n\nfloat softShadow(vec3 dir, vec3 origin, float min_t, float k) {\n    float res = 1.0;\n    float t = min_t;\n    for (int i = 0; i < RAY_STEPS; i++ ) {\n        float m = sceneMap3D(origin + t * dir);\n        if (m < 0.0001) {\n            return 0.0;\n        }\n        res = min(res, k * m / t);\n        t += m;\n    }\n    return res;\n}\n\nIntersection sdf3D(vec3 dir, vec3 eye) {\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj);\n    if (t == -1.0) {\n        return Intersection(t, vec3(0.0), eye + 1000.0 * dir, -1);\n    }\n    vec3 isect = eye + t * dir;\n    vec3 nor = computeNormal(isect);\n    vec3 material = computeMaterial(hitObj, isect, dir, nor);\n    \n    vec3 light = vec3(10.0, 7.45, 10.0);\n    float lambert = dot(normalize(light - isect), nor);\n    \n    float k = 10.0;\n    float shadow = softShadow(normalize(light - isect), isect, 0.1, k);\n    \n    vec3 col = shadow * lambert * material;\n    \n    return Intersection(t, col, isect, hitObj);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // [-1, 1]\n    uv = 2.0 * uv - vec2(1.0);\n    \n    vec3 dir, eye, ref;\n    rayCast(uv, dir, eye, ref);\n    vec3 col = sdf3D(dir, eye).color;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws2yWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[157, 157, 176, 176, 343], [345, 345, 368, 368, 535], [537, 537, 563, 563, 753], [755, 755, 781, 781, 971], [973, 973, 999, 999, 1189], [1191, 1191, 1220, 1220, 1254], [1260, 1260, 1299, 1299, 1332], [1334, 1334, 1356, 1356, 1375], [1376, 1376, 1432, 1432, 2060], [2062, 2062, 2107, 2107, 3035], [3037, 3037, 3102, 3102, 3502], [3504, 3504, 3562, 3562, 4015], [4017, 4017, 4070, 4070, 4419], [4421, 4421, 4449, 4449, 4516], [4518, 4518, 4582, 4582, 4845], [4847, 4847, 4877, 4877, 5196], [5198, 5198, 5261, 5261, 5529], [5531, 5531, 5571, 5571, 6160], [6162, 6162, 6219, 6269, 6516]], "test": "error"}
{"id": "ws2yz1", "name": "COVID, Stop!", "author": "harry7557558", "description": "Today's Google Doodle: Stay Home. Save Lives: Help Stop Coronavirus.\n\n(of course, you don't your home to have virus.)\n", "tags": ["virus", "coronavirus", "covid19", "covid"], "likes": 1, "viewed": 78, "published": "Public", "date": "1586141443", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Shadertoy version of https://www.desmos.com/calculator/59x14hqpt3\n// I made this because that one is too slow\n\n#define res iResolution.xy\n#define t (1.2*iTime)\n#define PI 3.14159265358979\n\n#define cp(x) clamp(x,0.,1.)\n#define ss(x) (x)*(x)*(x)*((6.*(x)-15.)*(x)+10.)\n\nfloat smin(float a, float b, float k){\n    float d = a-b;\n    return abs(d)>k?min(a,b):.5*(-0.5/k*d*d+a+b-.5*k);\n}\n\n\n// Virus Modeling\n\n#define R 0.74\n#define r 0.25\n#define n 8.\n#define df 0.058\n#define ff 14.4\n#define rc 1.06\nfloat u(vec2 p){ return length(vec2(rc*(p.x+df*cos(ff*p.y)-(R+r)),p.y))-r; }\n\n#define sm 0.156\nfloat V(vec2 p, float td, inout vec3 col){\n    float a = mod(atan(p.y,p.x)-td, 2.*PI/n)-PI/n;\n    vec2 q = length(p)*vec2(cos(a),sin(a));\n    float d = smin(u(q),length(p)-R,sm);\n    if (d<0.) col-=sqrt(dot(p,p)+.1)*vec3(0,1,1);\n    return d;\n}\n\n\n// Virus Crowd\n\n#define P1 vec2(-0.82,-0.35)\n#define v1 -0.5\n#define s1 0.85\n#define m1 0.095\n#define f1 3.\n#define P2 vec2(0.81,0.54)\n#define to 2.56\n#define v2 0.625\n#define s2 0.58\n#define m2 0.044\n#define f2 4.\n\nfloat Vs(vec2 p, inout vec3 col){\n    vec3 c1; float d1 = V((p-P1)/s1+vec2(0,m1*sin(f1*t)),v1*t,c1);\n    vec3 c2; float d2 = V((p-P2)/s2+vec2(0,m2*sin(f2*(t+to))),v2*(t+to),c2);\n    col += c1 + c2;\n    return min(d1,d2);\n}\n\n\n// Liquid\n\n#define wf 6.77\n#define wm 0.14\n#define wv 5.\n#define whf 0.15\nfloat whfs(float x) { return x<0.5?0.:x<1.5?ss(x-0.5):x<2.?1.:1.-ss(x-2.); }\n\nfloat W(float x, float y, inout vec3 col){\n    float wh = 4.*whfs(mod(whf*t,3.))-2.5;\n    float d = y-(wm*exp(sin(wf*x+wv*t))+wh);\n    if (d<0.) col-=(1.-exp(y-wh-3.*wm))*vec3(1,.8,0);\n    return d;\n}\n\n\n// Main\n\nfloat scene(vec2 p, inout vec3 col){\n    float clip = max(abs(p.x)-3.,abs(p.y)-2.);\n    float sd = smin(Vs(p,col),W(p.x,p.y,col),0.1);\n    if (clip>0.) col=vec3(1.);\n    return max(clip,sd);\n}\n\nfloat house(vec2 p){\n    vec2 b = abs(p);\n    float u = max(b.x-3.,b.y-2.);\n    float v = min(p.y+2.,min(3.-b.x,(7.-2.*p.y-b.x)/sqrt(5.)));\n    return min(abs(u),abs(v));\n}\n\nvoid mainImage(out vec4 col, in vec2 coord) {\n    col.xyz = vec3(1.0);\n    float S = min(res.x,res.y);\n    vec2 p = 7.0*(coord-0.5*res)/S-vec2(0,-.5);\n    float ds = scene(p,col.xyz);\n    float d = abs(ds)/length(vec2(dFdx(ds),dFdy(ds))) - .001*S;\n    col.xyz *= cp(d)*cp(house(p)*.14*S-.001*S);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws2yz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[271, 271, 309, 309, 385], [499, 499, 515, 515, 575], [594, 594, 636, 636, 838], [1057, 1057, 1090, 1090, 1279], [1356, 1356, 1377, 1377, 1432], [1434, 1434, 1476, 1476, 1634], [1646, 1646, 1682, 1682, 1838], [1840, 1840, 1860, 1860, 2012], [2014, 2014, 2059, 2059, 2311]], "test": "valid"}
{"id": "Ws2yzc", "name": "SynthWaveSun", "author": "rivFox", "description": "Sun", "tags": ["sun"], "likes": 3, "viewed": 178, "published": "Public", "date": "1587079170", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec4 DrawSun(vec2 uv, float speed)\n{\n    float dist = distance(uv, vec2(0.0));\n    float circle = step(dist, 0.5);   \n    \n    float lines =sin(uv.y * 50.0 + iTime * speed) * ((1.0 - uv.y) * 0.5);\n    lines *= 1.0;\n    lines = step(lines, 0.5);\n    \n    circle *= lines;\n    \n    vec3 yellow = vec3(0.921, 0.843, 0);\n    vec3 pink = vec3(0.941, 0, 0.737);\n\t\n    float gradientMask = ((1.0 - uv.y) * 0.5);\n    gradientMask += 0.1;\n    gradientMask *= gradientMask;\n   \tvec3 gradient = mix(yellow, pink, gradientMask);\n    \n    vec3 sun = circle * gradient;\n    \n    dist = 1.0 - dist;\n    dist = clamp(dist, 0.0, 0.5);\n    \n    dist *= (sin(iTime * 2.0) + 10.0) * 0.11;\n    \n \n    gradient *= dist;\n    sun = mix(sun, gradient, dist);\n    return vec4(sun, 1.0);\n}\n\n\nvec4 DrawGrid(vec2 uv)\n{   \n    float isVisible = step(uv.y, -0.1);\n    float gradientMask = ((0.85 - uv.y) * 1.0);\n    \n    uv.y = 2.0 / uv.y;\n    uv.x *= uv.y;\n    \n    vec2 grid = fract(uv - vec2(0.0, iTime * 5.0)) * 0.05 * (1.0 - uv.y) / fwidth(uv);\n    float line = min(grid.x, grid.y);\n    line = clamp(line, 0.0, 1.0);\n    line = 1.0 - line;\n    \n    vec3 blue = vec3(0, 0.047, 0.239);\n    vec3 pink = vec3(0.941, 0, 0.737);\n\t\n    gradientMask *= gradientMask;\n    gradientMask = clamp(gradientMask, 0.0, 1.0);\n    gradientMask -= isVisible;\n   \tvec3 gradient = gradientMask * pink;\n\n    vec3 bg = (isVisible - (isVisible * line * 1.8)) * blue;\n    \n    return vec4((clamp(isVisible * line, 0.0, 1.0) * pink) + gradient + bg, gradientMask + isVisible);\n    //return vec4(vec3(bg), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n    vec4 sun = DrawSun(uv + vec2(0.0, -0.35), 20.0);\n    vec4 grid = DrawGrid(uv + vec2(0.0, 0.15));\n    \n\n\tfragColor = sun;\n    fragColor = mix(fragColor, grid, grid.a); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws2yzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 37, 37, 763], [766, 766, 790, 790, 1561], [1563, 1563, 1620, 1620, 1861]], "test": "valid"}
{"id": "Ws2yzh", "name": "whRing", "author": "Whekin", "description": "An intresting effect appears if change the ring radius using sin and uv.x or uv.y of uv.x * uv.y", "tags": ["ring"], "likes": 2, "viewed": 52, "published": "Public", "date": "1586101993", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define effect1 abs(sin(iTime * 10. * uv.x))\n#define effect2 abs(sin(iTime * 10. * uv.y))\n#define effect3 abs(sin(iTime * 100. * uv.x * uv.y))\n\nfloat sdCircle(vec2 uv) {\n\treturn 1. - length(uv);\n}\n\nfloat ring(vec2 uv, float r) {\n    float d = sdCircle(uv);\n    r = 1. - r * effect1;\n    float blur = 0.02;\n\treturn smoothstep(r - blur, r       , d) - \n           smoothstep(r       , r + blur, d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n\n    float ring1 = ring(uv, 0.5);\n    \n    vec3 col = vec3(ring1);\n \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws2yzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[144, 144, 169, 169, 196], [198, 198, 228, 228, 398], [400, 400, 457, 457, 624]], "test": "valid"}
{"id": "Ws2yzy", "name": "Random without sin/cos/dot", "author": "samel", "description": "Just a random function that doesn't use trigonometric/vector functions.\nYou can seed it with uv or just a vec2 with some arbitrary values.", "tags": ["random", "lehmer"], "likes": 5, "viewed": 117, "published": "Public", "date": "1586877863", "time_retrieved": "2021-10-01T00:00:00", "image_code": "int lehmerSeed=0;\n\nvoid srandomLehmer(vec2 uv,float zoom)\n{\n uv*=zoom;\n int a=int(uv.x)<<16;\n int b=int(uv.y);\n lehmerSeed=a^b;\n}\n\n#define ZOOM (1000.0)\n\nfloat randomLehmer()\n{\n     int tmp=0;\n     tmp=lehmerSeed*1234567890;\n     tmp=(tmp>>16)^tmp;\n     tmp=tmp*1234567890;\n     return float((tmp>>16)^tmp)/float(2147483647);\n    \n    //real lehmer\n     /*int tmp=0;\n     int multiplier1=0;\n     lehmerSeed+=0xe120fc15;\n     tmp=lehmerSeed*0x4a39b70d;\n     multiplier1=(tmp>>16)^tmp;\n     tmp=multiplier1*0x12fad5c9;\n     return float((tmp>>16)^tmp)/float(2147483647);*/\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y=-uv.y;\n\n    srandomLehmer(uv,iTime*iTime);\n    float col = randomLehmer();\n\n    // Output to screen\n    fragColor = vec4(col,0.0,0.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws2yzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 59, 59, 129], [154, 154, 176, 176, 572], [575, 575, 632, 682, 872]], "test": "valid"}
{"id": "WsBcD1", "name": "Escher Cubes", "author": "ZiMMaBuE", "description": "Esheder", "tags": ["escher", "reproduction"], "likes": 5, "viewed": 133, "published": "Public", "date": "1586907031", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 64\n#define MAX_DIST 20.\n#define EPS 0.001\nconst float PI = acos(-1.0);\n\nmat3 rotX(float angle)\n{\n    return mat3(1,\t0,\t\t\t0,\n               0,\tcos(angle), -sin(angle),\n               0,\tsin(angle), cos(angle));\n}\n\nmat3 rotY(float angle)\n{\n\treturn mat3(cos(angle), 0, sin(angle),\n               0,\t\t\t1, 0,\n               -sin(angle), 0, cos(angle));\n}\n\nfloat sdCube(vec2 pos, float r)\n{\n\tvec2 q = abs(pos) - r;\n\treturn length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\nfloat sdCube(vec3 pos, float r)\n{\n\tvec3 q = abs(pos) - r;\n\treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat map(vec3 pos)\n{\n    pos = fract(pos)-0.5;\n    \n    float d1 = sdCube(pos, 0.1);\n    float d2 = sdCube(vec2(pos.x, pos.z), 0.02);\n    float d3 = sdCube(vec2(pos.x, pos.y), 0.02);\n    float d4 = sdCube(vec2(pos.z, pos.y), 0.02);\n    \n    float res = MAX_DIST;\n    res = min(res, d1);\n    res = min(res, d2);\n    res = min(res, d3);\n    res = min(res, d4);\n    return res;\n}\n\nvec3 normals(vec3 pos)\n{\n    vec2 e = vec2(0, 0.0001);\n    return normalize(vec3(\n    \tmap(pos+e.yxx)-map(pos-e.yxx),\n        map(pos+e.xyx)-map(pos-e.xyx),\n        map(pos+e.xxy)-map(pos-e.xxy)\n    ));\n}\n\nconst vec4 miss = vec4(MAX_DIST, vec3(0));\nvec4 raymarch(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    for(int i = 0; i<MAX_STEPS; i++)\n    {\n        vec3 pos = ro + rd*t;\n        float d = map(pos);\n        \n        if(abs(d)<=EPS) return vec4(length(pos-ro), normals(pos));\n        if(d >= MAX_DIST) return miss;\n        \n        t+=d;\n    }\n         \n    \n    return miss;\n}\n\nconst vec3 BACK_GROUND = vec3(0.2);\nvec3 GetScene(vec3 ro, vec3 rd, vec3 lightDir)\n{\n    \n    vec4 a = raymarch(ro, rd);\n    float d = a.x;\n    vec3 nor = a.yzw;\n    \n    vec3 col = BACK_GROUND;\n    \n    if(d < MAX_DIST)\n    {\n        float li = dot(lightDir, nor);\n        \n        vec3 pos = ro+rd*d;\n        pos *= rotX(0.9);\n        \n        float lines = sin(pos.y * 600.) * 0.5+0.5;\n        lines = smoothstep(li+0.25, li-0.25, lines);\n        lines = lines*0.7+0.3;\n        \n        col = vec3(1, 0.94, 0.8) * lines;\n        col = mix(col, BACK_GROUND, smoothstep(1., 8., d)); // fog\n    }\n    \n    return col;\n    \n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.x;\n    \n    vec2 mouse = iMouse.xy / iResolution.xy;\n    float camAngle = 0.09*PI*2.; // mouse.x*PI*2.;\n    vec2 p = 2.0 * vec2(cos(camAngle), sin(camAngle));\n    \n    vec3 scroll = vec3(0,0,iTime * 0.3);\n    \n    vec3 ro = vec3(p.x,0.08,p.y) - scroll;\n    mat3 ca = setCamera(ro, vec3(0,-0.5,0) - scroll, 0.0);\n    vec3 rd = ca*normalize(vec3(uv,1.8));\n    \n    vec3 ld = normalize(vec3(1, 0.5, -0.5));\n    \n    vec3 col = GetScene(ro, rd, ld);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsBcD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[90, 90, 114, 114, 229], [231, 231, 255, 255, 367], [369, 369, 402, 402, 480], [482, 482, 515, 515, 602], [604, 604, 625, 625, 981], [983, 983, 1007, 1007, 1187], [1232, 1232, 1265, 1265, 1563], [1601, 1601, 1649, 1649, 2189], [2191, 2191, 2243, 2243, 2420], [2422, 2422, 2479, 2479, 3040]], "test": "error"}
{"id": "WsBcDc", "name": "Canarick - Penumbra Shadows", "author": "canarick", "description": "Penumbra Shadows", "tags": ["cis461"], "likes": 1, "viewed": 46, "published": "Public", "date": "1587601032", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define LIGHT_POS vec3(3.f * cos(iTime) + 2.0, 10.0, -4.0)\n\nconst float FOVY = tan(3.14159 * 19.5 / 180.);\nconst int RAY_STEPS = 256;\n\n// The higher the value, the smaller the penumbra\nconst float SHADOW_HARDNESS = 10.0;\n\n// 0 for penumbra shadows, 1 for hard shadows\n#define HARD_SHADOW 0\n\nstruct Intersection {\n    float t;\n    vec3 color;\n    vec3 p;\n    int object; // Assign every object in our scene a unique ID int\n};\n        \n// SDF of a Sphere\nfloat sphere(vec3 p, float r, vec3 c) {\n    return distance(p, c) - r;\n}\n\n//SDF of a Torus\nfloat torus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n} \n\n//SDF of a Cone\nfloat cone(vec3 p, vec2 c) {\n\t//c must be normalized\n    float q = length(p.xy);\n    return dot(c, vec2(q, p.x));\n}\n        \n// SDF of a Plane\nfloat plane( vec3 p, vec4 n ) {\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n//SDF of a Box\nfloat box (vec3 p, vec3 b) {\n\treturn length(max(abs(p) - b, 0.0));\n}\n\n//RANDOM Noise Functions\nfloat random1( vec3 p ) {\n    return fract(sin((dot(p, vec3(127.1,\n                                  311.7,\n                                  191.999)))) *         \n                 43758.5453);\n}\n\nvec3 random3( vec3 p ) {\n    return fract(sin(vec3(dot(p,vec3(127.1, 311.7, 191.999)),\n                          dot(p,vec3(269.5, 183.3, 765.54)),\n                          dot(p, vec3(420.69, 631.2,109.21))))\n                 *43758.5453);\n}\n\n\nfloat WorleyNoise3D(vec3 p) {\n    // Tile the space\n    vec3 pointInt = floor(p);\n    vec3 pointFract = fract(p);\n\n    float minDist = 1.0; // Minimum distance initialized to max.\n\n    // Search all neighboring cells and this cell for their point\n    for(int z = -1; z <= 1; z++)\n    {\n        for(int y = -1; y <= 1; y++)\n        {\n            for(int x = -1; x <= 1; x++)\n            {\n                vec3 neighbor = vec3(float(x), float(y), float(z));\n\n                // Random point inside current neighboring cell\n                vec3 point = random3(pointInt + neighbor);\n\n                // Animate the point\n                //point = 0.5 + 0.5 * sin(iTime * 0.01 + 6.2831 * point); // 0 to 1 range\n\n                // Compute the distance b/t the point and the fragment\n                // Store the min dist thus far\n                vec3 diff = neighbor + point - pointFract;\n                float dist = length(diff);\n                minDist = min(minDist, dist);\n            }\n        }\n    }\n    return minDist;\n}\n\nvoid CoordinateSystem(in vec3 v1, out vec3 v2, out vec3 v3) {\n    if (abs(v1.x) > abs(v1.y))\n            v2 = vec3(-v1.z, 0.0, v1.x) / sqrt(v1.x * v1.x + v1.z * v1.z);\n        else\n            v2 = vec3(0.0, v1.z, -v1.y) / sqrt(v1.y * v1.y + v1.z * v1.z);\n        v3 = cross(v1, v2);\n}\n\nvec3 WorleyTangentSpaceNormal(vec3 pos) {\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( WorleyNoise3D(pos + epsilon.yxx) - WorleyNoise3D(pos - epsilon.yxx),\n                            WorleyNoise3D(pos + epsilon.xyx) - WorleyNoise3D(pos - epsilon.xyx),\n                            WorleyNoise3D(pos + epsilon.xxy) - WorleyNoise3D(pos - epsilon.xxy)));\n\n}\n\nmat3 TangentToWorld(vec3 nor) {\n\tvec3 tangent, bitangent;\n    CoordinateSystem(nor, tangent, bitangent);\n    return mat3(tangent, bitangent, nor);\n}\n\n//Rotates the camera around the Y-axis\nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\n//This is where you can create your scene\n#define SPHERE_1_SDF sphere(pos, 1.0, vec3(-.5, 2., 0.))\n#define SPHERE_2_SDF sphere(pos, 2.0, vec3(4., 2., 0.))\n\n//Primitive SDFs\n#define BACK_WALL_SDF plane(pos, vec4(0.0, 0.0, -1.0, 3.0))\n#define LEFT_WALL_SDF plane(pos, vec4(1.0, 0.0, 0.0, 5.0))\n#define RIGHT_WALL_SDF plane(pos, vec4(-1.0, 0.0, 0.0, 5.0))\n#define CEILING_SDF plane(pos, vec4(0.0, -1.0, 0.0, 7.5))\n#define FLOOR_SDF plane(pos, vec4(0.0, 1.0, 0.0, 2.0))\n#define TALL_BOX_SDF box(rotateY(pos + vec3(-2.5, 0.0, -2.0), 65.0 * 3.14159 / 180.0), vec3(1.0, 2.0, 1.2))\n#define SMALL_BOX_SDF box(rotateY(pos + vec3(2.5, 1.0, 0.0), -65.0 * 3.14159 / 180.0), vec3(1.0, 1.0, 1.0))\n\n\n//Primtives IDs\n#define BACK_WALL 0\n#define LEFT_WALL 1\n#define RIGHT_WALL 2\n#define CEILING 3\n#define FLOOR 4\n#define TALL_BOX 5\n#define SMALL_BOX 6\n#define SPHERE_1 7\n\nvoid sceneMap3D(vec3 pos, out float t, out int obj) {\n    t = FLOOR_SDF;\n    obj = FLOOR;\n    \n    float t2;\n    if ((t2 = TALL_BOX_SDF) < t) {\n    \tt = t2;\n        obj = TALL_BOX;\n    }\n    if ((t2 = SMALL_BOX_SDF) < t) {\n    \tt = t2;\n        obj = SMALL_BOX;\n    }\n    if ((t2 = SPHERE_1_SDF) < t) {\n    \tt = t2;\n        obj = SPHERE_1;\n    }\n}\n\n\nfloat sceneMap3D(vec3 pos) {\n    float t = FLOOR_SDF;\n    \n    float t2; \n    if ((t2 = TALL_BOX_SDF) < t) {\n    \tt = t2;\n    }\n    if ((t2 = SMALL_BOX_SDF) < t) {\n    \tt = t2;\n    }\n    if ((t2 = SPHERE_1_SDF) < t) {\n    \tt = t2;\n    }\n    \n    return t;\n}\n\nvec3 computeNormal(vec3 pos) {\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( sceneMap3D(pos + epsilon.yxx) - sceneMap3D(pos - epsilon.yxx),\n                            sceneMap3D(pos + epsilon.xyx) - sceneMap3D(pos - epsilon.xyx),\n                            sceneMap3D(pos + epsilon.xxy) - sceneMap3D(pos - epsilon.xxy)));\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj) {\n    t = 0.001;\n    for(int i = 0; i < RAY_STEPS; ++i) {\n        vec3 pos = origin + t * dir;\n    \tfloat m;\n        sceneMap3D(pos, m, hitObj);\n        if(m < 0.0001) {\n            return;\n        }\n        t += m;\n    }\n    t = -1.0;\n    hitObj = -1;\n}\n\nfloat hardShadow(vec3 dir, vec3 origin, float min_t) {\n    float t = min_t;\n    for(int i = 0; i < RAY_STEPS; ++i) {\n        float m = sceneMap3D(origin + t * dir);\n        if(m < 0.0001) {\n            return 0.0;\n        }\n        t += m;\n    }\n    return 1.0;\n}\n\nfloat softShadow(vec3 dir, vec3 origin, float min_t, float k) {\n    float res = 1.0;\n    float t = min_t;\n    for(int i = 0; i < RAY_STEPS; ++i) {\n        float m = sceneMap3D(origin + t * dir);\n        if(m < 0.0001) {\n            return 0.0;\n        }\n        res = min(res, k * m / t);\n        t += m;\n    }\n    return res;\n}\n\nfloat shadow(vec3 dir, vec3 origin, float min_t) {\n    #if HARD_SHADOW\n    return hardShadow(dir, origin, min_t);\n    #else\n    return softShadow(dir, origin, min_t, SHADOW_HARDNESS);\n    #endif\n}\n\n\nconst vec3 a = vec3(0.5, 0.5, 0.5);\nconst vec3 b = vec3(0.5, 0.5, 0.5);\nconst vec3 c = vec3(2.0, 1.0, 1.0);\nconst vec3 d = vec3(0.5, 0.2, 0.25);\n\nvec3 colorPalette(float t) {\n    return a + b * cos(6.28 * (t * c + d));\n}\n\nfloat power(float base, float exponent) {\n\tfloat result=1.0;\n\tfor (exponent; exponent > 0.f; exponent--) {\n\t\tresult = result * base;\n\t}\n\treturn result;\n}\n\nfloat noise2D(vec2 p) {\n    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n}\n\nfloat interpNoise2D(float x, float y) {\n    float intX = floor(x);\n    float fractX = fract(x);\n    float intY = floor(y);\n    float fractY = fract(y);\n\n    float v1 = noise2D(vec2(intX, intY));\n    float v2 = noise2D(vec2(intX + 1.f, intY));\n    float v3 = noise2D(vec2(intX, intY + 1.f));\n    float v4 = noise2D(vec2(intX + 1.f, intY + 1.f));\n\n    float i1 = mix(v1, v2, fractX);\n    float i2 = mix(v3, v4, fractX);\n\n    return mix(i1, i2, fractY);\n}\n\n//FRACTAL BROWNIAN MOTION NOISE\nfloat FBM2D(vec2 p) {\n\tfloat total = 0.f;\n    float persistance = 0.5f;\n    float octaves = 4.f;\n\n    for (float i = 1.f; i <= octaves; i++) {\n        float freq = power(2.f, i);\n        float amp = power(persistance, i);\n\n        total += interpNoise2D(p.x * freq + sin(iTime), p.y * freq + sin(iTime)) * amp;\n    }\n    return total;\n}\n\n// This is where you give your objects in the scene materials\nvec3 computeMaterial(int hitObj, vec3 p, vec3 n, vec3 lightVec, vec3 view) {\n    float lambert = dot(n, lightVec) + 0.2;\n    \n    switch(hitObj) {\n        case BACK_WALL:\n        case FLOOR:\n        return vec3(0.85, 0.81, 1.) * lambert;\n        case TALL_BOX:\n        return vec3(1.5, 0.0, 0.0) * lambert * WorleyNoise3D(p);\n        case SMALL_BOX:\n        return vec3(1.5, 1.5, .5) * lambert * WorleyNoise3D(p);\n        case SPHERE_1:\n        return vec3(0.5, 0.5, 1.0) * lambert * WorleyNoise3D(p);\n        break;\n        case RIGHT_WALL:\n        return vec3(0.63, 0.065, 0.05) * lambert;\n        break;\n        case LEFT_WALL:\n        return vec3(0.065, 0.63, 0.05) * lambert;\n        break;\n        case -1:\n        return vec3(0., 0., 0.);\n        break;\n    }\n    return vec3(0., 0., 0.);\n}\n\n\nIntersection sdf3D(vec3 dir, vec3 eye) {\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj);\n\n    vec3 isect = eye + t * dir;\n    vec3 nor = computeNormal(isect);\n    vec3 lightDir = normalize(LIGHT_POS - isect);\n    \n    vec3 surfaceColor = computeMaterial(hitObj, isect, nor, lightDir, normalize(eye - isect));\n    \n    surfaceColor *= shadow(lightDir, isect, 0.1);\n    \n    return Intersection(t, surfaceColor, isect, hitObj);\n}\n\n// Returns direction of ray\nvec3 rayCast(vec3 eye, vec3 ref, vec2 ndc) {\n    vec3 F = ref - eye;\n    vec3 R = normalize(cross(F, vec3(0,1,0)));\n    vec3 U = normalize(cross(R, F));\n    \n    // Vertical and Horizontal Aspects\n    vec3 V = U * length(F) * tan(FOVY * 0.5);\n    vec3 H = R * length(F) * tan(FOVY * 0.5) * float(iResolution.x) / iResolution.y;\n    \n    vec3 p = ref + ndc.x * H + ndc.y * V;\n    \n    return normalize(p - eye);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    // Convert to range [-1, 1]\n    uv = uv * 2.0 - vec2(1.0, 1.0);\n    \n    //This is with the rotating part\n    //vec3 eye = rotateY(vec3(0, 0, -10), iTime);\n    \n    vec3 eye = vec3(0, 5.5, -30);\n    vec3 ref = vec3(0, 1.5, 0);\n    \n    vec3 rayDir = rayCast(eye, ref, uv);\n    \n    Intersection isect = sdf3D(rayDir, eye);\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    // fragColor = vec4(0.5 * (rayDir + vec3(1., 1., 1.)), 1.0);\n    fragColor = vec4(isect.color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsBcDc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[434, 453, 492, 492, 525], [527, 544, 573, 573, 647], [650, 666, 694, 718, 781], [791, 809, 840, 866, 897], [899, 914, 942, 942, 982], [984, 1009, 1034, 1034, 1205], [1207, 1207, 1231, 1231, 1450], [1453, 1453, 1482, 1504, 2479], [2481, 2481, 2542, 2542, 2766], [2768, 2768, 2809, 2809, 3147], [3149, 3149, 3180, 3180, 3297], [3299, 3338, 3369, 3369, 3452], [4308, 4308, 4361, 4361, 4654], [4657, 4657, 4685, 4685, 4914], [4916, 4916, 4946, 4946, 5265], [5267, 5267, 5331, 5331, 5584], [5586, 5586, 5640, 5640, 5849], [5851, 5851, 5914, 5914, 6179], [6181, 6181, 6231, 6231, 6377], [6526, 6526, 6554, 6554, 6600], [6602, 6602, 6643, 6643, 6755], [6757, 6757, 6780, 6780, 6846], [6848, 6848, 6887, 6887, 7300], [7302, 7334, 7355, 7355, 7670], [7672, 7734, 7810, 7810, 8531], [8534, 8534, 8574, 8574, 8974], [8976, 9004, 9048, 9048, 9416], [9418, 9418, 9475, 9525, 10114]], "test": "error"}
{"id": "WsBcDR", "name": "Live by The Sword", "author": "kstyler", "description": "Going through a tunnel of swords.", "tags": ["raymarch", "sdf", "sword"], "likes": 3, "viewed": 330, "published": "Public API", "date": "1586385663", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nint matID = 0;\n\n//https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){\n    return a + b*cos( 6.28318*(c*t+d) +iTime);\n}\nmat2 rotate(float a){\n\treturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}\n\nfloat sdfBox( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdfSphere(vec3 p,float size){\n\treturn length(p)-size;\n}\n\nfloat sdfCutAwayBox(vec3 translate,mat2 rot){\n    translate.xz*= rot;\n    float a = 0.5;\n    float b = 0.2;\n    float height = 4.0;\n    \n    float a2= length(vec2(a/1.5,b/2.)); \n     \n\treturn sdfBox(translate,vec3(a2,height,b));\n}\n\nfloat sdfPlane(vec3 p){\n    return p.y +15.5;\n}\n\nfloat sdfSword(vec3 p){\n    vec3 tip = p;\n    tip-=vec3(0,2,1.4);\n    tip.zy*=rotate((-12.*3.14)/180.);\n    vec3 tip2 = p;\n    tip2-=vec3(0,2,-1.4);\n    tip2.zy*=rotate((12.*3.14)/180.);\n    \n    vec3 tip3 = p;\n    tip3-=vec3(2.5,2,0);\n    tip3.xy*=rotate((-24.*3.14)/180.);\n    vec3 tip4 = p;\n    tip4-=vec3(-2.5,2,0);\n    tip4.xy*=rotate((24.*3.14)/180.);\n    \n    \n    float a = 0.5;\n    float b = 0.2;\n    float height = 4.;\n    \n    float a2= length(vec2(a/2.,b/2.)); \n    float box = sdfBox(p+vec3(0,-1,0),vec3(a,height,b));\n    \n    float box2 = sdfCutAwayBox(p+vec3(-0.53,-1,-0.3),rotate((20.*3.14)/180.));\n    float box3 = sdfCutAwayBox(p+vec3(-0.53,-1,0.3),rotate((-20.*3.14)/180.));\n    \n    float box4 = sdfCutAwayBox(p+vec3(0.53,-1,-0.3),rotate((-20.*3.14)/180.));\n    float box5 = sdfCutAwayBox(p+vec3(0.53,-1,0.3),rotate((20.*3.14)/180.));\n    float box6 = sdfBox(tip,vec3(2,2,1.2));\n    float box7 = sdfBox(tip2,vec3(2,2,1.2));\n    float box8 = sdfBox(tip3,vec3(2,4,1.2));\n    float box9 = sdfBox(tip4,vec3(2,4,1.2));\n    \n    float crossGuard = sdfBox(p+vec3(0.,3.3,0.),vec3(1.,0.3,0.3));\n    float pom = sdfSphere(p+vec3(0,6.4,0),0.4);\n    p.xz*=rotate(p.y*8.);\n    float handle = sdfBox(p+vec3(0.,4.8,0),vec3(0.2,1.3,0.2));\n \n  \n    float best = max(min(handle,min(crossGuard,min(pom,box))),\n                     -min(box8,min(box6,min(box9,min(box5,min(box4,min(box3,min(box2,box7))))))));\n    \n\n    return best;\n}\n\nfloat map(vec3 p){    \n    p.x+=sin(iTime*2.)*1.5;\n    float plane = sdfPlane(p);\n    float plane2 = sdfPlane(p*vec3(1,-1,1));\n  \n    float ang = 6.283185/13.0;\n    float sector = round(atan(p.x,p.y)/ang);\n    float c = 44.;\n    vec3 r = mod(p+0.5*c,c)-0.5*c;\n    vec3 q = p;\n    q.z = r.z;\n    \n    float an = sector*ang;\n    \n    q.xy *= rotate(an);\n    \n    q.zy *=rotate((180.*3.14)/180.);\n    vec3 q2 = q;\n    q2.zy*=rotate((180.*3.14)/180.);\n    \n   \n    float sword = sdfSword(q+ vec3(0,6,0));\n    float sword2 = sdfSword(q2- vec3(0,10,22));\n    float best = min(plane,min(plane2,min(sword2,sword)));\n    if(best == sword || best == sword2){\n    \tmatID=1;\n    } else if(best == plane || best == plane2){matID=2;}\n    return best;\n}\n\nvec3 normal(vec3 p){\n    vec2 e= vec2(0,0.01);\n\treturn normalize(vec3(map(p+e.yxx)-map(p-e.yxx),\n                          map(p+e.xyx)-map(p-e.xyx),\n                          map(p+e.xxy)-map(p-e.xxy)));\n}\n\nvec3 march(vec3 ro, vec3 rd){\n    float total = 0.;\n    float dist = 0.;\n    for(int i = 0; i<100; i++){\n        dist = map(ro+rd*total);\n        total+=dist;\n        if(dist < 0.1){\n        \tbreak;\n        }\n    }\n    \n   \n    return (ro+rd*total);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n   \n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\tvec3 ro = vec3(0,0,iTime*20.);\n    vec3 rd = normalize(vec3(uv,1.));\n    vec2 st = uv*5.*sin(iTime);\n    st*=rotate(iTime);\n    st = fract(st);\n    \n    ro.xy*= rotate(iTime*.5);\n    rd.xy*= rotate(iTime*.5);\n    \n   \n    vec3 col = (march(ro,rd));\n    vec3 p = (march(ro,rd));\n    vec3 n = normal(p);\n    \n  \tif(matID ==1){\n        col = 1.-pal((max(dot(normalize(ro-p),n),0.)),vec3(0.8,0.5,0.4),vec3(0.2,0.4,0.2),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25) );\n    }\n     if(matID ==2){\n         col = mix(vec3(0.04,0.14,0.15),vec3(0.04,0.33,0.32),vec3(smoothstep(0.2,0.19,length(st-0.5))));\n    }\n   \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsBcDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 57, 124, 124, 173], [174, 174, 195, 195, 241], [243, 243, 274, 274, 361], [363, 363, 398, 398, 424], [426, 426, 471, 471, 656], [658, 658, 681, 681, 705], [707, 707, 730, 730, 2141], [2143, 2143, 2161, 2161, 2881], [2883, 2883, 2903, 2903, 3089], [3091, 3091, 3120, 3120, 3347], [3349, 3349, 3405, 3405, 4100]], "test": "valid"}
{"id": "WsBcRy", "name": "spiral 2 -Robinsong", "author": "Robinsong", "description": "spiral 2", "tags": ["spiral"], "likes": 1, "viewed": 77, "published": "Public", "date": "1586815850", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define CENTER (iResolution.xy / 2.0)\n#define PI 3.1415\n#define TAU (2.0 * PI)\n\n//Convert rectangular to polar coordinates\nvec2 rect_to_polar(vec2 rect) {\n    float r = pow(length(rect),.3);\n    float theta = atan(rect.y, rect.x);\n    \n    //Fix the coordinates so they go from 0 to 2PI\n    //instead of -PI to PI. These two lines are optional\n//    if (theta < 0.0)\n//        theta += TAU;\n    \n    return vec2(r, theta);\n}\n\nvec2 normalized_polar(vec2 coord) {\n    //Centered UV coordinates accounting for aspect ratio\n    \n    vec2 nCenter = vec2(CENTER.x,CENTER.y);\n    nCenter.x = CENTER.x+sin(iTime)*(iResolution.x/3.);\n    nCenter.y = CENTER.y+cos(iTime)*(iResolution.y/5.);\n\n    \n    vec2 uv = vec2(1.0,1.0);\n    uv.y = (coord.y - nCenter.y ) / iResolution.y;\n    uv.x = (coord.x - nCenter.x ) / iResolution.y;\n    \n    //Convert to polar. Normalize the angle component by\n    //dividing by a full circle.\n    vec2 polar = rect_to_polar(uv);\n    polar.y /= TAU;\n       \n    return polar;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n \tvec2 uv = fragCoord/iResolution.xy;\n   \n    uv = normalized_polar(fragCoord);\n    \n    float gp = uv.y;\n    float gx = uv.x;\n        \n    uv.x *= 15.;\n    uv.x = fract(uv.x);\n    \n    uv.x = uv.x + sin(uv.y*TAU+iTime);\n   \n    uv.x = uv.x - iTime*3.;\n       \n    vec3 col = vec3(0,0,0);\n      \n\tcol.x = -5.+sin(uv.x*TAU-(gp*TAU))*10.;\n    col.x = clamp(col.x, 0., 1.);\n    col.x = min(col.x, gx-.3);\n\n//    col.y = -20.+sin(uv.y*TAU*8.+iTime)*25.;\n    col.y = clamp(col.y, 0., 1.);\n    col.y = min(col.y, gx+.01);\n        \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsBcRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[80, 123, 154, 154, 424], [426, 426, 461, 519, 996], [999, 999, 1056, 1106, 1688]], "test": "valid"}
{"id": "WsBcW1", "name": "circly boi", "author": "nexor", "description": ".", "tags": ["circle"], "likes": 2, "viewed": 69, "published": "Public", "date": "1586511082", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision highp float;\n#define resolution iResolution.xy\n#define time iTime\n#define pi 3.14159\nvec3 render(vec2 fc)\n{\n    vec2 p=(gl_FragCoord.xy-.5*resolution)/\n        max(resolution.x,resolution.y);\n    vec2 q=p;\n    float vig=smoothstep(.5,.2,length(p));\n    float cnt=smoothstep(.0,.075,length(p));\n    vec3 col=vec3(.0);\n    float r=10.;\n    float t=fract(time/r);\n    t*=pi*2.;\n    p*=mat2(.5,.0,.0,2.);\n    p*=25.;\n    float a=.0;\n    a+=length(p)*4.;\n    float f=fwidth(a);\n    \n    vec2 d = vec2(0.);\n    d.x=cos(p.x*p.x+t*2.-a);\n    d.y=sin(p.y*p.y-t*3.+a);\n    \n    d=smoothstep(f*2.,0.,abs(d-1.));\n    col+=d.xyy;\n    col=clamp(col,.0,1.);\n    col*=vig;\n    col*=smoothstep(.2,-.5,abs(q.y));\n    return col;\n}\n\nvoid mainImage( out vec4 fragcol, in vec2 coord )\n{\n    vec2 fc = coord.xy;\n    vec3 col=render(fc);\n    col=pow(col,vec3(1./2.2));\n    fragcol=vec4(col,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsBcW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[95, 95, 117, 117, 722], [724, 724, 775, 775, 883]], "test": "valid"}
{"id": "WsBcW3", "name": "smooth functions", "author": "forij", "description": "Example of how to draw smooth math functions ", "tags": ["functionssmooth"], "likes": 0, "viewed": 57, "published": "Public", "date": "1587472810", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    float c = uv.y + sin(uv.x * 33.0 + iTime)*0.1;\n    float thikness = 0.005;\n    c = smoothstep(-thikness, 0.0, c) \n      - smoothstep(0.0,  thikness, c);\n    fragColor = vec4(vec3(c), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsBcW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 298]], "test": "valid"}
{"id": "wsBcWD", "name": "Day 114", "author": "jeyko", "description": "potato", "tags": ["mdtmjvm"], "likes": 11, "viewed": 258, "published": "Public API", "date": "1586648717", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define pi acos(-1.)\n\n#define tau (2.*pi)\n#define pal(a,b,c,d,e) ((a) + (b)*sin((c)*(d) + (e)))\n\n#define rot(x) mat2(cos(x),-sin(x),sin(x),cos(x))\n\nvec3 glow = vec3(0);\n\n\n\n\nfloat map(vec3 p, float t){\n\tfloat d = 10e7;\n\t\n    vec4 q = vec4(p, 1.);\n    \n    float id = floor(p.z);\n    \n    \n    \n    for(float i = 0.; i <0. ; i++){\n    \tq.xyz = abs(q.xyz);\n        q.xy *= rot(0.125*pi + i);\n    \n        q -= 0.1;\n    }\n    \n    \n    float dpp = dot(q.xyz,q.xyz);\n    \n    \n    //    q = q/dpp;\n    \n    vec4 j;\n    \n    //q /= dot(q.xyz,q.xyz);\n    vec3 b = vec3(2.4, 0.6, 1.);\n    \n    for(int i = 0; i <4 ; i++){\n    \tq.xyz = abs(q.xyz);\n        q.xy *= rot(0.25*pi);\n        q.xz *= rot(1.5);\n    \tq.x += 0.1;\n    }\n    \n    for(float i = 0.; i < 10.; i++){\n    \tq.xyz = abs(mod(q.xyz - 0.5*b, b) )- 0.5*b;\n        \n        float dpp = dot(q.xyz,q.xyz);\n        \n        \n        dpp = clamp(dpp, 0. ,1.54);\n        if(i == 2.)\n            j = q;\n        \n        q = q/dpp;\n        if(i == 20.)\n        \tq.xz *= rot(0.7 );\n        \n    }\n    \n    q.xyz *= 1. ;\n    \n    float db = length(j.yx)/q.w - 0.01;\n    \n        \n\tfloat da = length(q.yz)/q.w - 0.02;\n    \n    float sc = 0.5;\n    d = min(db,da);\n    //d = da;\n    d *= 0.5;\n    d += smoothstep(1.,0.,t*.5)*0.7;\n    d = abs(d) + 0.003;\n    \n    //d += exp(-t*4.)*0.7;\n    \n    \n    vec3 c = vec3(1,1.,1.);\n    da *= 0.5;\n    db *= 0.5;\n    da = abs(da) + 0.003;\n    db = abs(db) + 0.003;\n    glow += 0.9/(0.01 + da*da*1500.)*c;\n    glow -= 0.9/(0.01 + db*db*2000.)*c*vec3(0.,0.8,2.);\n    return d;\n}\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n\tvec3 dir = normalize(lookAt - ro);\n\tvec3 right = normalize(cross(vec3(0.,1.,0), dir));\n\tvec3 up = normalize(cross( dir, right));\n\treturn normalize(dir + right*uv.x + up*uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0.9,0.6,0.4);\n\n    vec3 ro = vec3(0);\n    ro.z += iTime;\n    \n    float T = iTime*0.2;\n    ro.xy += vec2(cos(T), sin(T))*3.;\n    \n    vec3 lookAt = vec3(0);\n    \n    lookAt.z = ro.z + 4.;\n    \n    vec3 rd = getRd(ro, lookAt, uv);\n    \n    float d;\n    vec3 p = ro; float t = 0.; bool hit = false;\n    \n    for(int i = 0; i < 60; i++){\n    \td = map(p, t);\n        if(d < 0.001){\n        \thit = true;\n            //break;\n        }\n\t\tt += d;\n    \tp = ro + rd*t;\n    }\n    \n    \n    col -= glow*0.001;\n    \n    col = pow(col, vec3(0.454545));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsBcWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[174, 174, 201, 201, 1558], [1559, 1559, 1601, 1601, 1780], [1782, 1782, 1839, 1839, 2500]], "test": "valid"}
{"id": "WsBcWV", "name": "Soap", "author": "klk", "description": "Fake soap bubble dispersion", "tags": ["plasma", "color"], "likes": 5, "viewed": 360, "published": "Public API", "date": "1587311402", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Alex Kluchikov\n\n\nvec2 rot(vec2 p,float a)\n{\n    float c=cos(a*15.83);\n    float s=sin(a*15.83);\n    return p*mat2(s,c,c,-s);\n}\n\nvoid mainImage(out vec4 o, in vec2 uv)\n{\n    uv/=iResolution.xx;\n    uv=vec2(.125,.75)+(uv-vec2(.125,.75))*.015;\n    float T=iTime*.5;\n\n    vec3 c = normalize(.75-.25*vec3(\n        sin(length(uv-vec2(.1,0))*132.+T*3.3),\n        sin(length(uv-vec2(.9,0))*136.-T*2.5),\n        sin(length(uv-vec2(.5,1))*129.+T*4.1)\n        ));\n\n    vec3 c0=vec3(0);\n    float w0=0.;\n    float N=164.*(iMouse.y+1.)/iResolution.y;\n    for(float i=0.;i<N;i++)\n    {\n        float wt=(i*i/N/N-.2)*.3;\n        float wp=0.5+(i+1.)*(i+1.5)*0.001;\n        float wb=.1+i/N*0.05;\n        wb=.1*(iMouse.x+1.)/iResolution.x;\n    \tc.zx=rot(c.zx,1.6+T*0.65*wt+(uv.x+.7)*23.*wp);\n    \tc.xy=rot(c.xy,c.z*c.x*wb+1.7+T*wt+(uv.y+1.1)*15.*wp);\n    \tc.yz=rot(c.yz,c.x*c.y*wb+2.4-T*0.79*wt+(uv.x+uv.y*(fract(i/2.)-0.25)*4.)*17.*wp);\n    \tc.zx=rot(c.zx,c.y*c.z*wb+1.6-T*0.65*wt+(uv.x+.7)*23.*wp);\n    \tc.xy=rot(c.xy,c.z*c.x*wb+1.7-T*wt+(uv.y+1.1)*15.*wp);\n        float w=(1.5-i/N);\n        c0+=c*w;\n        w0+=w;\n    }\n    c0=c0/w0*2.+.5;//*(1.-pow(uv.y-.5,2.)*2.)*2.+.5;\n    \n\to=vec4(c0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsBcWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 31, 57, 57, 140], [142, 142, 182, 182, 1197]], "test": "valid"}
{"id": "WsBcWy", "name": "Plasma in 3D", "author": "themasmo", "description": "Like the previous mandelbrot but using a different formula.", "tags": ["3d", "plasma"], "likes": 3, "viewed": 84, "published": "Public", "date": "1587230469", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 64\n#define MAX_DIST 100.\n#define SURF_DIST .01\n#define MAXITE 32.0\n\nmat3 rotx(float a) { mat3 rot; rot[0] = vec3(1.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 1.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\n\nfloat rnd(vec2 n){\n  return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat formula(vec2 p) {\n    vec3 col;\n    float t = iTime;\n    for(float j = 0.0; j < 3.0; j++){\n        for(float i = 1.0; i < 15.0; i++){\n            p.x += 0.1 / (i + j) * sin(i * 10.0 * p.y + t + cos((iTime / (12. * i)) * i + j));\n            p.y += 0.1 / (i + j)* cos(i * 10.0 * p.x + t + sin((iTime / (12. * i)) * i + j));\n        }\n        col[int(j)] = abs(p.x + p.y);\n    }\n    return (col.x+col.y+col.z)/3.;\n}\n\n// MandelBrot not used\nfloat mandel(vec2 p)\n{    \n    float zre=sin(iTime)/4.0;\n    float zim=cos(iTime)/3.0;\n    float cre=p.x;\n    float cim=p.y;\n    float col=0.;\n\n    for(float i=0.;i<MAXITE;i++)\n    {\n        float dam=zre*zre-zim*zim+cre;\n        zim=2.0*zre*zim+cim;\n        zre=dam;\n        col++;\n        if( (zre*zre+zim*zim)>4.0 )\n            break;\n    }\n    \n    return (col/MAXITE);\n}\n\n\nfloat GetDist(vec3 p) {\n    //float v=0.1*mandel(p.xz/6.0);\n    float v=0.;\n    if(p.x>-6. && p.x<6. && p.z>-6. && p.z<6.)\n    \tv=0.5*formula(p.xz/12.0);\n\tvec4 s1 = vec4(p.x,v,p.z,0.8);\n  \n    //float sphereDist1 =  length(p-s1.xyz)-s1.w;\n\tfloat cube = length(max(abs(p-s1.xyz)-vec3(0.01,0.01,0.01), 0.));\n    float planeDist = p.y;\n    \n    float d = min(cube, planeDist); //sphereDist1, planeDist);\n    return d;    \n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        \n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    float dif=0.;\n    if(p.x>-6. && p.x<6. && p.z>-6. && p.z<6.)\n    {\n\n        vec3 lightPos = vec3(0, 6, 2);\n        vec3 l = normalize(lightPos-p);\n        vec3 n = GetNormal(p);\n\n        dif = clamp(dot(n, l), 0., 1.);\n        float d = RayMarch(p+n*SURF_DIST*2., l);\n        if(d<length(lightPos-p)) dif *= .1;\n    }\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(-2., 6, -7.5);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n\n    ro = ro*(rotx(-0.4));\n    ro.x=0.0+4.0*cos(iTime/2.0);\n    ro.z=-8.0+2.0*sin(iTime/1.5);\n    float d = RayMarch(ro, rd);\n\n    vec3 p = ro + rd * d;\n\n    float dif = GetLight(p);\n    col = vec3(dif)*vec3(0.0,0.6,0.9);\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsBcWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[86, 86, 106, 106, 233], [234, 234, 254, 254, 381], [383, 383, 401, 401, 468], [470, 470, 493, 493, 889], [891, 914, 936, 936, 1289], [1292, 1292, 1315, 1351, 1712], [1714, 1714, 1748, 1748, 1963], [1965, 1965, 1989, 1989, 2178], [2180, 2180, 2204, 2204, 2549], [2551, 2551, 2608, 2608, 3036]], "test": "valid"}
{"id": "WsBczc", "name": "Circle section", "author": "sixclones", "description": "Quick explanation.", "tags": ["2d", "circle"], "likes": 2, "viewed": 95, "published": "Public API", "date": "1587043081", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// CONSTANTS & UTILS\n#define QP 0.785398163397448\n#define HP 1.570796326794897\n#define P 3.141592653589793\n#define TP 6.283185307179586\n\n#define t iTime\n#define ht 0.5 * t\n#define tt 0.1 * t\n\n\n// UTILS FN\n/* map a value `n` from a range `start1` -> `stop1` to a range `start2` -> `stop2` */\nfloat map(float n, float start1, float stop1, float start2, float stop2) {\n  \treturn (n - start1) / (stop1 - start1) * (stop2 - start2) + start2;\n}\n\n/* map a value `n` from the range -1.0 -> 1.0 to a range `start2` -> `stop2`\nto be used with cos/sin\n`map01(sin(x), 0.0, 1.0)`\n*/\nfloat map01(float n, float start2, float stop2) {\n  \treturn (0.5 * n + 0.5) * (stop2 - start2) + start2;\n}\n\n\n// MAIN\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  \tvec2 uv = fragCoord.xy / iResolution.xy;\n  \tvec2 uv0 = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n  \n  \tvec3 color = vec3(0.0);\n    vec3 palette = vec3(1.0, 1.0, 0.0);\n\t\n    // compute the angle from the center of the screen and the current pixel\n    float angle = atan(uv0.y, uv0.x);\n    // `atan` returns values from {-PI -> PI}, the mapping is just for conveniance\n    angle = map(angle, -P, P, 0.0, 1.0);\n    // define the section of the circle that is displayed\n    float section = map01(sin(t), 0.0, 0.125); \n    // section = 0.125;\n    \n    // signed distance field of a circle\n    float circSDF = length(uv0.xy);\n    // compute the circle drawing\n    float circ = 1.0 - step(0.5, circSDF);\n    \n    // cooking everything together and tadaa!\n    color += step(section, angle) * circ;\n    // pacman\n    color *= palette;\n    \n  \tfragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsBczc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[193, 291, 365, 365, 438], [440, 570, 619, 619, 676], [679, 687, 742, 742, 1624]], "test": "valid"}
{"id": "WsBczK", "name": "watershade", "author": "benhardy", "description": "trying to do waeter", "tags": ["noise", "water"], "likes": 6, "viewed": 91, "published": "Public", "date": "1586925219", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// convert screen coordinates to space ones with origin in centre\nvec2 pixelToSpace(vec2 pixel) {\n    return (pixel/iResolution.xy) *\n        vec2(1.0, iResolution.y / iResolution.x);\n}\n\nint hash(vec2 where) {\n    ivec2 i = ivec2(where);\n    return (31 * i.x) ^  (i.y * 91);\n}\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\nfloat smoothie(float x) {\n    return tanh(((x-0.5)*5.0)+1.0)/2.0;\n}\nvec2 smoothie(vec2 v) {\n    return vec2(smoothie(v.x), smoothie(v.y));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 where = 16.0 * pixelToSpace(fragCoord);\n\n    float dx = 1.0* noise(where+vec2(iTime*0.2));\n    float dy = 1.0* noise(where+vec2(-iTime*0.2));\n    float swirl = noise(vec2(0,dy));\n    float r = 3.0* noise(vec2(dx,0));\n    float effect = 1.0 / (1.0+ r*r);\n    float t = 4.0 * effect * noise(vec2(dx,dy));\n    vec2 ds = vec2(r*cos(t), r*sin(t));\n    where = where + ds;\n\tfloat lev = noise(where);\n    float blot = clamp(4.0*noise(where*0.2)+2.0, 0.0, 1.1);\n    lev = (lev+0.5) *blot;\n    vec3 col = vec3(lev);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsBczK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 66, 97, 97, 185], [187, 187, 209, 209, 276], [278, 278, 300, 300, 439], [441, 526, 548, 548, 952], [953, 953, 978, 978, 1020], [1021, 1021, 1044, 1044, 1093], [1094, 1094, 1151, 1151, 1725]], "test": "valid"}
{"id": "wsByDh", "name": "Epicycloids - Cremona method", "author": "andretugan", "description": "Cremona method of epicycloid generation. https://en.wikipedia.org/wiki/Cardioid#Cardioid_as_envelope_of_a_pencil_of_lines", "tags": ["lines", "epicycloid"], "likes": 2, "viewed": 274, "published": "Public API", "date": "1586529714", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Author: https://www.shadertoy.com/user/andretugan\n// Creative Commons Attribution-NonCommercial 3.0 Unported License\n// https://creativecommons.org/licenses/by-nc/3.0\n\n#define NUM_CHORDS 128\n\n#define M_PI 3.14159265358\n#define M_2_PI (2. * 3.14159265358)\n\n#define FADE_INNER_RADIUS 0.8\n#define FADE_OUTER_RADIUS 1.1\n#define LINE_WIDTH 4.\n\n// Function from Inigo Quilez\n// https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;                   \n    float uv2 = dot(uv, uv);        \n    if (uv2 > FADE_OUTER_RADIUS * FADE_OUTER_RADIUS) { \n    \tfragColor = vec4(0.0,0.0,0.0,1.0);\n        return;\n    }\n               \n    float multiplier = 1.99 + 5. * (.5 - .5 * cos(iTime * 0.03));\n    float start = multiplier * M_PI * 0.25;\n    float val = 0.;\n\n    for (int i = 0; i < NUM_CHORDS; ++i) {\n        float angle1 = start + M_2_PI / float(NUM_CHORDS) * float(i);\n        float angle2 = multiplier * angle1;\n        vec2 point1 = vec2(cos(angle1), sin(angle1));\t                       \n        vec2 point2 = vec2(cos(angle2), sin(angle2));\n\n        vec2 diff = point2 - point1;\n        vec2 perp = point1 + (dot(uv - point1, diff) / dot(diff, diff)) * diff - uv;\n        float dist2 = dot(perp, perp);\n        \n        float line_width = LINE_WIDTH / iResolution.y;                                        \n    \tfloat add_val = smoothstep(line_width * line_width, line_width * line_width * 0.5, dist2);                                                 \n        add_val *= smoothstep(FADE_OUTER_RADIUS * FADE_OUTER_RADIUS, FADE_INNER_RADIUS * FADE_INNER_RADIUS, uv2);        \n        val += add_val;\n    }\n    \n    val *= 20. / float(NUM_CHORDS);\n    val = pow(val, 0.5);\n    \n    float hue = sin(iTime * 0.05 + uv2 * 0.3);                                  \n    fragColor = vec4(hsv2rgb(vec3(hue, 1., val)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsByDh.jpg", "access": "shaders20k", "license": "cc-by-3.0", "functions": [[342, 413, 440, 440, 618], [620, 620, 676, 676, 2123]], "test": "valid"}
{"id": "wsByDy", "name": "Rainbubbles", "author": "tr0sle", "description": "first try on shader coding", "tags": ["color", "radial", "bubbles", "rainbow"], "likes": 1, "viewed": 85, "published": "Public", "date": "1587253702", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float map(vec3 p)\n{\n    vec3 q = fract(p) * 2.0 - 1.0;\n    return length(q) - 0.1;\n    \n    \n}\n\nfloat trace(vec3 o, vec3 r)\n{\n    float t = 0.5;\n    for (int i = 1; i < 10; ++i)\n    {\n        vec3 p = o + r * t;\n        float d = map(p);\n        t +=d * 1.0;\n           \n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\tuv = uv *2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\t\n   \n        \n\tvec3 r = normalize(vec3(uv, 1.0));\n    \n    float the = iTime * 0.5; //Time defined\n    \n    r.xz *= mat2(-cos(the), sin(the), -sin(the), -cos(the)); //Camera Rotation\n    \n    vec3 o = vec3(0, iTime, -iTime);\n    float t = trace(o, r);\n    \n    \n    \n    float fog = 2.0 / (2.0 + t*t*0.10);\n    vec3 fc = vec3(fog);\n\t\n      vec3 col = fc + fc*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    fragColor = vec4(col, 1.0);\n\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsByDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 94], [96, 96, 125, 125, 292], [294, 294, 351, 351, 889]], "test": "valid"}
{"id": "wsByDz", "name": "sdf cylinder", "author": "bradjamesgrant", "description": "various sdf functions for cylinder", "tags": ["sdf"], "likes": 1, "viewed": 297, "published": "Public", "date": "1586430280", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//iq sdf\nfloat sdCappedCylinder( vec3 p, float r, float h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//own sdf from intuition (fastest to slowest(?))\nfloat sdCappedCylinder2(vec3 p, float h, float r){\n    \n    vec2 v = vec2(length(p.xz)-r,abs(p.y)-h);\n    return v.y<0.?v.x:v.x<0.?v.y:length(v);\n\n    \n    \n    float a = length(p.xz)-r;\n    float b = abs(p.y)-h;\n    return b<0.?a:a<0.?b:sqrt(a*a+b*b);\n    \n    if(b<0.){\n    \treturn a;\n    }\n    else if(a<0.){\n    \treturn b;\n    }\n    else{\n    \treturn sqrt(a*a+b*b);\n    }\n}\n\n\n\nvec2 rotate(vec2 p, float t){\n\tfloat a = cos(t);\n    float b = -sin(t);\n    return mat2(a,-b,b,a)*p;\n}\n\n#define AA 2\n#define r .25\n\n\nfloat map(vec3 p){\n    \n    return sdCappedCylinder2(p, 0.5,0.2);\n}\n\nvec3 calcNormal(vec3 p){\n\tvec2 e = vec2(0.001,0.);\n    return normalize(vec3(map(p+e.xyy)-map(p-e.xyy),\n                          map(p+e.yxy)-map(p-e.yxy),\n                          map(p+e.yyx)-map(p-e.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 ro = normalize(vec3(sin(iTime),sin(iTime)*5.,cos(iTime)));\n    vec3 uu = -ro;\n    vec3 vv = cross(uu,vec3(0.,1.,0.));\n    vec3 ww = cross(vv,uu);\n    float t = 0.;\n    vec3 col = vec3(.1,.1,.1);\n    vec3 p = ro;\n    \n    for(int n = 0; n<AA; n++){\n        for(int m = 0; m<AA; m++){\n            vec2 o = vec2(m,n)/float(AA)-.5;\n            vec2 uv = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n\t\t\tvec3 rd = normalize(uu+vv*uv.x + ww*uv.y);          \n\t\t\tvec3 n = vec3(0.,0.,0.);\n        \tfor(int i = 0;i<1000;i++){\n                \n                p = ro+rd*t;\n                float d = map(p);\n                if(d<0.01){\n                    p = p+d*rd;\n                    n = calcNormal(p);\n                    col += n*.5+.5;\n                    break;\n                }\n                if(d>1000.)\n                \tbreak;\n                t+=d;\n            }\n            for(int j = 1; j<5; j++){\n                float d = 0.01 + 0.12*float(j)/4.0;\n            \tvec3 sp = p+n*d;\n                float d2 = map(sp);\n                float occ =d-d2;\n                col-=abs(occ);\n            }\n        }\n    }\n    col/=vec3(AA*AA);\n    \n    \n    fragColor = vec4(col,0.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsByDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 9, 61, 61, 168], [170, 219, 269, 269, 596], [600, 600, 629, 629, 702], [733, 733, 751, 751, 800], [802, 802, 826, 826, 1015], [1017, 1017, 1074, 1074, 2265]], "test": "valid"}
{"id": "WsByR1", "name": "The Live Coders Conference - 3", "author": "mrange", "description": "The Live Coders Conference - Online on twitch.tv April 9, 2020 - https://captcalli.github.io/LiveCodersConf/\n\nCreated a few shaders inspired by the online event, these shaders are not officially adopted just made for fun and to promote the event.", "tags": ["2d", "fbm", "tlc"], "likes": 5, "viewed": 250, "published": "Public API", "date": "1586036143", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by mrange/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 Unported License.\n\n// The Live Coders Conference - Online on twitch.tv April 9, 2020 - https://captcalli.github.io/LiveCodersConf/\n// Created a few shaders inspired by the online event, these shaders are not officially adopted just made for fun and to promote the event.\n\n// 2D shape created by combining 2D primitives from IQ's blog:\n//  http://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n// pmin from IQ's blog on smooth minimum functions:\n//  http://www.iquilezles.org/www/articles/smin/smin.htm\n// warped fbms from IQ's blog:\n//  https://iquilezles.org/www/articles/warp/warp.htm\n\n#define PI     3.141592654\n#define TAU    (2.0*PI)\n#define SCA(a) vec2(sin(a), cos(a))\n#define TIME   (iTime+120.0)\n#define TTIME  (TIME*TAU)\n#define PERIOD 600.0\n\nconst float a1 = PI/2.0;\nconst float a2 = PI*4.5/6.0;\n\nconst vec2 sca1 = SCA(a1);\nconst vec2 sca2 = SCA(a2);\n\nconst mat2 frot = mat2(0.80, 0.60, -0.60, 0.80);\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nfloat noise(vec2 p) {\n  float a = sin(p.x);\n  float b = sin(p.y);\n  float c = 0.5 + 0.5*cos(p.x + p.y);\n  float d = mix(a, b, c);\n  return d;\n}\n\nfloat fbm(vec2 p) {    \n  float f = 0.0;\n  float a = 1.0;\n  float s = 0.0;\n  float m = 2.0-0.1;\n  for (int x = 0; x < 4; ++x) {\n    f += a*noise(p); p = frot*p*m;\n    m += 0.01;\n    s += a;\n    a *= 0.45;\n  }\n  return f/s;\n}\n\nfloat warp(vec2 p, float offset, out vec2 v, out vec2 w) {\n  vec2 vx = vec2(0.0, 0.0);\n  vec2 vy = vec2(3.2, 1.3);\n\n  vec2 wx = vec2(1.7, 9.2);\n  vec2 wy = vec2(8.3, 2.8);\n\n  vec2 off = (1.75 + 0.5*cos(TTIME/60.0))*vec2(-5, 5);\n\n  p += mix(vec2(0.0), off, 0.5 + 0.5*tanh(offset));\n\n  rot(vx, TTIME/1000.0);\n  rot(vy, TTIME/900.0);\n\n  rot(wx, TTIME/800.0);\n  rot(wy, TTIME/700.0);\n\n  vec2 vv = vec2(fbm(p + vx), fbm(p + vy));  \n  vec2 ww = vec2(fbm(p + 3.0*vv + wx), fbm(p + 3.0*vv + wy));\n\n  float f = fbm(p + 2.25*ww);\n\n\n  v = vv;\n  w = ww;\n\n//  return tanh(f);\n  return f;\n}\n\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = max(k-abs(a-b), 0.0)/k;\n  return min(a, b) - h*h*k*(1.0/4.0);\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat box(vec2 p, vec2 b, vec4 r) {\n  r.xy = (p.x>0.0)?r.xy : r.zw;\n  r.x  = (p.y>0.0)?r.x  : r.y;\n  vec2 q = abs(p)-b+r.x;\n  return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nfloat arc(vec2 p, vec2 sca, vec2 scb, float ra, float rb) {\n  p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n  p.x = abs(p.x);\n  float k = (scb.y*p.x>scb.x*p.y) ? dot(p.xy,scb) : length(p.xy);\n  return sqrt(dot(p,p) + ra*ra - (2.0 - 0.000001)*ra*k) - rb;\n}\n\nfloat spokes(vec2 p, float s) {\n  vec2 pp = toPolar(p);\n  pp.y += TTIME*10.0/PERIOD;\n  mod1(pp.y, TAU/10.0);\n  pp.y += PI/2.0;\n  p = toRect(pp);\n  float ds = box(p, s*vec2(0.075, 0.5), s*vec4(0.04));\n  return ds;\n}\n\nfloat arcs(vec2 p, float s) {\n  \n  float d1 = arc(p, sca1, sca2, s*0.275, s*0.025);\n  float d2 = arc(p, sca1, sca2, s*0.18, s*0.025);\n  \n  return min(d1, d2);\n}\n\nfloat meeple(vec2 p, float s) {\n  float dh = box(p - s*vec2(0.0, -0.035), s*vec2(0.07, 0.1), s*vec4(0.065));\n  float dc = box(p - s*vec2(0.0, -0.22), s*vec2(0.15, 0.04), s*vec4(0.05, 0.02, 0.05, 0.02));\n  \n  return pmin(dh, dc, s*0.115);\n}\n\nfloat theLiveCoders(vec2 p, float s) {\n  float ds = spokes(p, s);\n  float dc = circle(p, 0.375*s);\n  float da = arcs(p, s);\n  float dm = meeple(p, s);\n  \n  float d = ds;\n  d = min(d, dc);\n  d = max(d, -da);\n  d = max(d, -dm);\n  \n  return d;\n}\n\nfloat df(vec2 p) {  \n  return theLiveCoders(p, 3.0);\n}\n\nvec3 normal(vec2 p, float offset) {\n  vec2 v;\n  vec2 w;\n  vec2 e = vec2(0.0001, 0);\n  \n  vec3 n;\n  n.x = warp(p + e.xy, offset, v, w) - warp(p - e.xy, offset, v, w);\n  n.y = 2.0*e.x;\n  n.z = warp(p + e.yx, offset, v, w) - warp(p - e.yx, offset, v, w);\n  \n  return normalize(n);\n}\n\n\nvec3 postProcess(vec3 col) {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75));\n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= iResolution.x/iResolution.y;\n\n  p *= 1.65;\n  vec3 col = vec3(1.0);\n \n  float d = df(p);\n  p += -0.025*TTIME*vec2(-1.0, 1.0);\n \n  vec2 v;\n  vec2 w;\n \n  float f = warp(p, d, v, w);\n  vec3 n = normal(p, d);\n\n  vec3 lig = normalize(vec3(0.6, -0.4, -0.4));\n//  rot(lig.xz, TTIME/100.0);\n  float dif = max(dot(lig, n), 0.5);\n\n  const vec3 col1 = vec3(0.1, 0.3, 0.8);\n  const vec3 col2 = vec3(0.7, 0.3, 0.5);\n  \n  float c1 = dot(normalize(lig.xz), v)/length(v);\n  float c2 = dot(normalize(lig.xz), w)/length(w);\n  \n  col = pow(dif, 0.75)*tanh(pow(abs(f + 0.5), 1.5)) + c1*col1 + c2*col2;\n  col += 0.25*vec3(smoothstep(0.0, -0.0125, d));\n\n  col = postProcess(col);\n\n  col *= smoothstep(0.0, 16.0, iTime*iTime);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsByR1.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1028, 1028, 1061, 1061, 1146], [1148, 1148, 1169, 1169, 1291], [1293, 1293, 1312, 1312, 1517], [1519, 1519, 1577, 1577, 2095], [2097, 2097, 2136, 2136, 2261], [2263, 2263, 2285, 2285, 2329], [2331, 2331, 2352, 2352, 2397], [2399, 2399, 2438, 2438, 2514], [2516, 2516, 2547, 2547, 2573], [2575, 2575, 2610, 2610, 2759], [2761, 2761, 2820, 2820, 3007], [3009, 3009, 3040, 3040, 3223], [3225, 3225, 3254, 3254, 3385], [3387, 3387, 3418, 3418, 3626], [3628, 3628, 3666, 3666, 3870], [3872, 3872, 3890, 3890, 3926], [3928, 3928, 3963, 3963, 4207], [4210, 4210, 4238, 4238, 4414], [4416, 4416, 4468, 4468, 5277]], "test": "error"}
{"id": "WsByRW", "name": "Confetti twister (atz)", "author": "ilyaev", "description": "Particles emulation via raymarch repetition study", "tags": ["raymarch", "particles"], "likes": 6, "viewed": 191, "published": "Public", "date": "1586148629", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 156\n#define MIN_DISTANCE 0.001\n#define MAX_DISTANCE 10.\n#define LAYERS 10.\n#define LAYER_SIZE 6.\n\nstruct TraceResult {\n    vec3 id;\n    float dt;\n    float ds;\n    float alpha;\n};\n\nfloat dPoint(vec3 ro, vec3 rd, vec3 p) {\n    return length(cross(rd, p - ro))/length(rd);\n}\n\nfloat n21(vec2 p) {\n    //return fract(sin(dot(n, vec2(12.9898, 4.1414 + iTime*0.00001))) * 43758.5453);\n     return fract(sin(p.x*123.231 + p.y*1432.342 + iTime*0.01)*15344.22);\n}\n\nvec3 getIdColor(vec3 id) {\n    float n = max(.2, n21(vec2(id.x + id.y, id.z)));\n    vec3 rcol = vec3(n, fract(n*4567.433), fract(n*45689.33));\n    return rcol;\n}\n\nTraceResult trace(vec3 ro, vec3 rd) {\n    float ds,dt;\n    float n;\n    vec3 id, shift;\n    float baseSize = .05;\n    vec3 baseSpacing = vec3(baseSize * 4.);\n    vec3 bounds = vec3(LAYER_SIZE, LAYER_SIZE, LAYERS);\n    vec3 l = bounds;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n\n    TraceResult res;\n    res.alpha = 1.;\n\n    for(int i = 0 ; i < MAX_STEPS ; i++) {\n        vec3 p = ro + rd * ds;\n\n        float a = 3.14/2.;\n        p.yz *= mat2(vec2(sin(a), cos(a)), vec2(-cos(a), sin(a)));\n        float aa = sin(iTime/4.)*6.26;//mouse.x * 3.14 * 2.;\n        p.xy *= mat2(vec2(sin(aa), cos(aa)), vec2(-cos(aa), sin(aa)));\n\n        vec3 rc1 = vec3(baseSpacing);\n        vec3 q1 = p - rc1 * clamp(round(p/rc1), -l, l);\n\n\n        id = round(p/rc1).xyz;\n\n        float pa = sin(id.z + iTime * id.z*.05)*6.28;\n\n        \n        // z-layer interval scale\n        rc1.xy *= (1. + (sin(id.z/5. + iTime*3.) * .5 + .5)*2.);\n        // z-layer rotation\n        p.xy *= mat2(vec2(sin(pa), cos(pa)), vec2(-cos(pa), sin(pa)));\n\n        q1 = p - rc1 * clamp(round(p/rc1), -l, l);\n        id = round(p/rc1).xyz;\n\n        float n = n21(vec2(id.x * id.y, id.z * id.x*id.z));\n\n        dt = length(q1 + vec3(.04 * n, .04 * fract(n*567.43), .01)) - baseSize;//- (.05 * fract(n*123.22));\n\n\n        ds += dt * .5;\n        if (abs(dt) < MIN_DISTANCE || dt > MAX_DISTANCE) {\n            if (length(id.xy) > 1.6 && fract(n*718.54) > .5) {\n                break;\n            } else {\n                 ds += .1;\n            }\n        }\n    }\n\n\n\n    res.id = id;\n    res.dt = dt;\n    res.ds = ds;\n\n    return res;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoords) {\n    vec2 uv = ((fragCoords.xy / iResolution.xy) - .5) * vec2(iResolution.x / iResolution.y, 1.);\n    vec2 mouse = iMouse.xy/iResolution.xy;\n\n    vec3 col = vec3(.0);\n\n    vec3 ro = vec3(0.+sin(iTime), 0. + cos(iTime) , -3. + sin(iTime));\n    vec3 lookat = vec3(0., 0., 0.);\n    float zoom = .6;\n\n    vec3 f = normalize(lookat - ro);\n    vec3 r = normalize(cross(vec3(0., 1., 0.), f));\n    vec3 u = cross(f, r);\n\n    vec3 c = ro + f * zoom;\n    vec3 I = c + uv.x * r + uv.y * u;\n\n    vec3 rd = normalize(I - ro);\n\n    TraceResult tr = trace(ro, rd);\n\n    if (tr.dt < MIN_DISTANCE) {\n        vec3 id = tr.id;\n        vec3 rcol = getIdColor(id);\n        col += rcol;\n    }\n\n\n    // col.rg = uv;\n\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsByRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[199, 199, 239, 239, 290], [292, 292, 311, 396, 472], [474, 474, 500, 500, 635], [637, 637, 674, 674, 2223], [2225, 2225, 2281, 2281, 3007]], "test": "valid"}
{"id": "wsByWc", "name": "StarGåte by JZQ & SRC", "author": "fidlajka", "description": "KRI", "tags": ["stargate", "sg1", "tapiok"], "likes": 1, "viewed": 116, "published": "Public", "date": "1587422396", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M_PI 3.1415926535897932384626433832795\n\nfloat dist (vec2 A, vec2 B)\n{\n\treturn sqrt(pow(A.x - B.x, 2.0) + pow(A.y - B.y, 2.0));\n}\n\nfloat getTheta (float x, float y)\n{\n    return (atan(y,x) * 180.0/M_PI) + 180.0;\n}\n\n\nvec3 getColor (float r, float theta,float x,float y)\n{      \n    vec3 bgLight = vec3(0.7,0.7,0.8);\n    vec3 bgDark = vec3 (0.45,0.45,0.6);\n    vec3 bg = vec3(0.6, 0.6, 0.7);\n    vec3 color;\n    if (r < 150.0)\n    {\n\t    float s = r/60.0 + 0.1*(sin(r/150.0*8.0*2.0*3.14-iTime*10.0)*sin(x*0.1));\t\n        color = bgDark*s + bgLight*(1.0-s);\n    }\n    else\n    {\n        color = bg;\n    }\n    \n    vec3 gate = vec3(0.35, 0.35, 0.42);\n    vec3 symbols = vec3(0.45, 0.45, 0.55);\n    vec3 chevronsGrey = vec3(0.3, 0.3, 0.4);\n    vec3 chevronsRed = vec3 (0.4,  0.25,  0.27353);\n\n    \n    if (r < 150.0 && r > 120.0)\n    {\n        color = gate;\n    }\n    if (r < 140.0 && r > 125.0)\n    {\n        float theta2 = mod(theta+iTime*10.0,9.0);\n        if (theta2<8.0)\n        {\n          color = symbols;\n        }\n        else\n        {\n         color = gate;\n        }\n    }\n    if (r < 152.0 && r > 130.0 )\n    {\n        float theta3 = mod(theta,40.0);\n        \t\n        float hrana1 = 0.0;\n        float hrana2 = 5.0;\n    \t\n        float t = (r-130.0)/(152.0-130.0);\n        float hrana = t*hrana1+(1.0-t)*hrana2;\n    \n        \n        if (theta3 >hrana && theta3 < 15.0-hrana)\n            {\n            \tcolor = chevronsGrey; \n            }\n        if (theta3 > hrana+2.0 && theta3 < 15.0-hrana-2.0)\n        {\n        \tcolor = chevronsRed;\n        }\n   \n    }\n\n    return color;\n   \t \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Scaling\n    vec2 xy = fragCoord.xy/(iResolution.xy/vec2(800.0,450.0));\n       \n    vec2 center = vec2(800.0,450.0) /2.0;\n    float dx = center.x - xy.x;\n    float dy = center.y - xy.y;\n    float r = dist(xy, center);\n    float theta = getTheta(dx, dy);\n    \n    vec3 col = getColor(r, theta,xy.x,xy.y);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsByWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 48, 77, 77, 136], [138, 138, 173, 173, 220], [223, 223, 277, 277, 1601], [1603, 1603, 1660, 1675, 2028]], "test": "valid"}
{"id": "wsByWW", "name": "mandelbulb--derivate---v8-", "author": "jorge2017a1", "description": "mandelbulb--derivate---v8-", "tags": ["mandelbulbderivatev8"], "likes": 5, "viewed": 88, "published": "Public", "date": "1586627787", "time_retrieved": "2021-10-01T00:00:00", "image_code": "///Original por IQ --> https://www.shadertoy.com/view/ltfSWn\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// The source code for these videos from 2009: \n// https://www.youtube.com/watch?v=eKUh4nkmQbc\n// https://www.youtube.com/watch?v=erS6SKqtXLY\n\n// More info here: http://iquilezles.org/www/articles/mandelbulb/mandelbulb.htm\n\n// See https://www.shadertoy.com/view/MdfGRr to see the Julia counterpart\n\n\n///---------------------------------------\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n///-----------------------------\n\n\n\n\nvec2 isphere( in vec4 sph, in vec3 ro, in vec3 rd )\n{\n    vec3 oc = ro - sph.xyz;\n    \n\tfloat b = dot(oc,rd);\n\tfloat c = dot(oc,oc) - sph.w*sph.w;\n    float h = b*b - c;\n    \n    if( h<0.0 ) return vec2(-1.0);\n\n    h = sqrt( h );\n\n    return -b + vec2(-h,h);\n}\n\n#define ZERO (min(iFrame,0))\n\n\nfloat map( in vec3 p, out vec4 resColor )\n{\n    \n    vec3 w = p;\n    float m = dot(w,w);\n\n    vec4 trap = vec4(abs(w),m);\n\tfloat dz = 1.0;\n    \n    \n\tfor( int i=0; i<4; i++ )\n    {\n        dz = 8.0*pow(sqrt(m),7.0)*dz + 1.0;\n\t\t//dz = 8.0*pow(m,3.5)*dz + 1.0;\n        \n        float r = length(w);\n        float b = 8.0*acos( w.y/r);\n        float a = 8.0*atan( w.x, w.z );\n        w = p + pow(r,8.0) * vec3( sin(b)*sin(a), cos(b), sin(b)*cos(a) );\n\n        \n        trap = min( trap, vec4(abs(w),m) );\n\n        m = dot(w,w);\n\t\tif( m > 256.0 )\n            break;\n    }\n\n    resColor = vec4(m,trap.yzw);\n\n    \n\n    float fra =0.25*log(m)*sqrt(m)/dz;\n    \n    \n    float sdb1 =sdBox(p- vec3(0.0,-0.8,0.0), vec3(0.9,0.6,0.8) );\n    \n    float res=999.9 ;\n    \n    float dif1= differenceSDF(sdb1,fra) ;\n    \n    res=min(res,dif1);\n    return res;\n    \n}\n\nfloat intersect( in vec3 ro, in vec3 rd, out vec4 rescol, in float px )\n{\n    float res = -1.0;\n\n    // bounding sphere\n    vec2 dis = isphere( vec4(0.0,0.0,0.0,1.25), ro, rd );\n    if( dis.y<0.0 )\n        return -1.0;\n    dis.x = max( dis.x, 0.0 );\n    dis.y = min( dis.y, 10.0 );\n\n    // raymarch fractal distance field\n\tvec4 trap;\n\n\tfloat t = dis.x;\n\tfor( int i=0; i<128; i++  )\n    { \n        vec3 pos = ro + rd*t;\n        float th = 0.25*px*t;\n\t\tfloat h = map( pos, trap );\n\t\tif( t>dis.y || h<th ) break;\n        t += h;\n    }\n    \n    \n    if( t<dis.y )\n    {\n        rescol = trap;\n        res = t;\n    }\n\n    return res;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float k )\n{\n    float res = 1.0;\n    float t = 0.0;\n    for( int i=0; i<64; i++ )\n    {\n        vec4 kk;\n        float h = map(ro + rd*t, kk);\n        res = min( res, k*h/t );\n        if( res<0.001 ) break;\n        t += clamp( h, 0.01, 0.2 );\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos, in float t, in float px )\n{\n    vec4 tmp;\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.25*px;\n    return normalize( e.xyy*map( pos + e.xyy,tmp ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx,tmp ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy,tmp ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx,tmp ) );\n}\n\nconst vec3 light1 = vec3(  0.577, 0.577, -0.577 );\nconst vec3 light2 = vec3( -0.707, 0.700,  0.707 );\nconst vec3 light3 = vec3( 1.0, 2.00, -1.0 );\n\n\nvec3 render( in vec2 p, in mat4 cam )\n{\n\t// ray setup\n    const float fle = 3.5;\n\n    vec2  sp = (2.0*p-iResolution.xy) / iResolution.y;\n    float px = 2.0/(iResolution.y*fle);\n\n    vec3  ro = vec3( cam[0].w, cam[1].w, cam[2].w );\n\tvec3  rd = normalize( (cam*vec4(sp,fle,0.0)).xyz );\n\n    // intersect fractal\n\tvec4 tra;\n    float t = intersect( ro, rd, tra, px );\n    \n\tvec3 col;\n\n    // color sky\n    if( t<0.0 )\n    {\n     \tcol  = vec3(0.8,.9,1.1)*(0.6+0.4*rd.y);\n\t\tcol += 5.0*vec3(0.8,0.7,0.5)*pow( clamp(dot(rd,light1),0.0,1.0), 32.0 );\n\t}\n    // color fractal\n\telse\n\t{\n        // color\n        col = vec3(0.01);\n\t\t\n        col = mix( col, vec3(0.30,0.20,0.30), clamp(tra.y,0.0,1.0) );\n\t \tcol = mix( col, vec3(0.2,0.10,0.30), clamp(tra.z*tra.z,0.0,1.0) );\n        col = mix( col, vec3(0.30,0.10,0.62), clamp(pow(tra.w*0.5,6.0),0.0,1.0) );\n        \n        \n        col *= 0.5;\n\t\t//col = vec3(0.1);\n        \n        // lighting terms\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, t, px );\n        vec3 hal = normalize( light1-rd);\n        vec3 ref = reflect( rd, nor );\n        float occ = clamp(0.05*log(tra.x),0.0,1.0);\n        float fac = clamp(1.0+dot(rd,nor),0.0,1.0);\n\n        // sun\n        float sha1 = softshadow( pos+0.001*nor, light1, 12.0 );\n        \n        \n        float dif1 = clamp( dot( light1, nor ), 0.0, 1.0 )*sha1;\n        float dif4 = clamp( dot( light3, nor ), 0.0, 1.0 )*sha1;\n        \n        float spe1 = pow( clamp(dot(nor,hal),0.0,1.0), 32.0 )*dif1*(0.04+0.96*pow(clamp(1.0-dot(hal,light1),0.0,1.0),5.0));\n        // bounce\n        float dif2 = clamp( 0.5 + 0.5*dot( light2, nor ), 0.0, 1.0 )*occ;\n        \n        \n        // sky\n        float dif3 = (1.0+0.3*nor.y)*(0.2+0.8*occ);\n        \n        \n        ///------------\n        \n        vec3 n =nor;\n  \t\tvec3 rf = ref;\n  \t\tfloat factor = length(0.25*sin(rf*3.)*0.5+0.5)/sqrt(0.35);\n  \t\tvec3 col2 = mix(vec3(0.3,0.25,0.1), vec3(0.8,0.6,0.2), factor) + pow(factor*0.8, 6.);\n\t\t\n        \n        \n        \n\t\tvec3 lin = vec3(0.0); \n\t\t     lin += 7.0*vec3(1.50,1.10,0.70)*dif1;\n\t\t     lin += 4.0*vec3(0.25,0.20,0.15)*dif2;\n        \t lin += 1.5*vec3(0.10,0.20,0.30)*dif3;\n        \t lin += 2.0*vec3(1.0)*dif4;\n        \n             lin += 2.5*vec3(0.35,0.30,0.25)*(0.05+0.95*occ); // ambient*/\n        \t// lin += 4.0*fac*occ;                          // fake SSS\n        \t\t\n        \t\tlin += 4.0*fac*occ+col2;\n        \t\t\n        \n\t\tcol *= lin;\n\t\t//col = pow( col, vec3(0.7,0.9,1.0) );          // fake SSS\n        col = pow( col, vec3(2.2) );\n        \n        \n        col += spe1*15.0;\n        //col += 8.0*vec3(0.8,0.9,1.0)*(0.2+0.8*occ)*(0.03+0.97*pow(fac,5.0))*smoothstep(0.0,0.1,ref.y )*softshadow( pos+0.01*nor, ref, 2.0 );\n        //col = vec3(occ*occ);\n    }\n\n    // gamma\n\tcol = sqrt( col );\n    \n    // vignette\n    col *= 1.0 - 0.05*length(sp);\n\n    return col;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime*.25;\n\n    // camera\n\tfloat di = 1.4+0.1*cos(.9*time);\n\tvec3  ro = di * vec3( cos(.33*time), 0.4+0.4*sin(.37*time), sin(.31*time) );\n\tvec3  ta = vec3(0.0,0.1,0.0);\n\tfloat cr = 0.25*cos(0.1*time);\n\n    // camera matrix\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cw = normalize(ta-ro);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv =          (cross(cu,cw));\n    mat4 cam = mat4( cu, ro.x, cv, ro.y, cw, ro.z, 0.0, 0.0, 0.0, 1.0 );\n\n\tvec3 col = render(  fragCoord, cam );\n    \n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsByWW.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[530, 530, 565, 565, 589], [592, 607, 638, 638, 788], [791, 791, 839, 839, 872], [911, 911, 964, 964, 1171], [1204, 1204, 1247, 1247, 2052], [2054, 2054, 2127, 2127, 2684], [2686, 2686, 2742, 2742, 3016], [3018, 3018, 3075, 3075, 3306], [3457, 3457, 3496, 3510, 6330], [6336, 6336, 6393, 6393, 6927]], "test": "valid"}
{"id": "wsByzG", "name": "River of Fire", "author": "jarble", "description": "This is an edit of my [url=https://www.shadertoy.com/view/wdsyD8]\"Sea of Lava\"[/url] shader.", "tags": ["fractal", "river", "pseudorandom"], "likes": 2, "viewed": 235, "published": "Public API", "date": "1586831013", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//This parameter changes the magnification.\nconst float mag = 9.0;\nconst float distortion_scale = mag*mag;\n\nconst int GREEN = 0;\nconst int BLUE = 1;\nconst int GRAY = 2;\nconst int YELLOW = 3;\nconst int WHITE = 4;\nconst int FOREST_GREEN = 5;\nconst int LIGHTBLUE = 6;\nconst int SKYBLUE = 7;\nconst int SNOW = 8;\nconst int WHITESMOKE = 9;\nconst int LIGHTGRAY = 10;\nconst int LIME = 11;\nconst int LIGHTYELLOW = 12;\nconst int BEIGE = 13;\nconst int SAND = 14;\nconst int TAN = 15;\nconst int ORANGE = 16;\nconst int RED = 17;\nconst int BLACK = 18;\nconst int DARKGRAY = 19;\nconst int ORANGERED = 20;\n\nconst int SWAMP_BIOME = 1;\nconst int GLACIER_BIOME = 2;\nconst int FORESTS_AND_MOUNTAINS = 3;\nconst int SAVANNA_BIOME = 4;\nconst int FOREST_BIOME = 5;\n\n//this function is from https://www.shadertoy.com/view/4djSRW\nint hash12(vec2 p,float num_colors)\n{\n    //set the number of colors to be randomly generated\n    p = sin(p.xx-p.yy);\n    vec3 p3 = (vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return int(floor(fract((p3.x + p3.y) * p3.z)*num_colors));\n}\n    \nint magnify(vec2 fragCoord,float mag,float num_colors){\n    fragCoord += vec2(sin(fragCoord.y/(distortion_scale*mag)+iTime),sin(fragCoord.x/(distortion_scale*mag)+iTime))*10.0*mag*mag;\n    return hash12(floor(fragCoord/pow(3.0,mag)),num_colors);\n}\n\nivec4 get_neighbors(vec2 fragCoord,float mag,float colors){\n\treturn ivec4(magnify(fragCoord+vec2(0,1),mag,colors),\n        magnify(fragCoord+vec2(1,0),mag,colors),\n        magnify(fragCoord-vec2(0,1),mag,colors),\n        magnify(fragCoord-vec2(1,0),mag,colors));\n}\n\n\nbool is_next_to(int color,ivec4 neighbors){\n\treturn (neighbors.x == color)\n        || (neighbors.y == color)\n        || (neighbors.z == color)\n        || (neighbors.w == color);\n}\n\nvec3 rgb(float r,float g,float b){\n\treturn vec3(r,g,b)/255.0;\n}\n\nvec3 get_color(int color){\n    if(color == BLUE){\n    \treturn vec3(0.149,0.141,0.912);\n   \t}\n    else if(color == GREEN){\n    \treturn vec3(0.000,0.833,0.224);\n   \t}\n    else if(color == FOREST_GREEN){\n    \treturn rgb(34.0,139.0,34.0);\n   \t}\n    else if(color == WHITE){\n    \treturn vec3(1.0,1.0,1.0);\n   \t}\n    else if(color == GRAY){\n    \treturn vec3(192.0,192.0,192.0)/255.0;\n    }\n    else if(color == YELLOW){\n    \treturn vec3(1.0,1.0,0.0);\n   \t}\n    else if(color == LIGHTBLUE){\n    \treturn rgb(173.0,216.0,230.0);\n   \t}\n    else if(color == SKYBLUE){\n    \treturn rgb(135.0,206.0,235.0);\n    }\n    else if(color == SNOW){\n    \treturn rgb(255.0,250.0,250.0);\n    }\n    else if(color == WHITESMOKE){\n    \treturn rgb(245.0,245.0,245.0);\n    }\n    else if(color == LIGHTGRAY){\n    \treturn rgb(211.0,211.0,211.0);\n    }\n    else if(color == LIME){\n    \treturn rgb(0.0,255.0,0.0);\n    }\n    else if(color == LIGHTYELLOW){\n    \treturn rgb(255.0,255.0,153.0);\n    }\n    else if(color == BEIGE){\n    \treturn rgb(245.0,245.0,220.0);\n    }\n    else if(color == TAN){\n    \treturn rgb(210.,180.,140.);\n    }\n    else if(color == ORANGE){\n    \treturn vec3(255,127,80)/255.0;\n    }\n    else if(color == RED){\n    \treturn vec3(1.0,0.0,0.0);\n   \t}\n    else if(color == DARKGRAY){\n    \treturn rgb(128.0,128.0,128.0);\n    }\n    else if(color == ORANGERED){\n    \treturn rgb(255.0,69.0,0.0);\n    }\n}\n\n\nint glacier_biome(inout int color1, ivec4 neighbors){\n\tint GREEN = 0;\n    int BLUE = 1;\n    int GRAY = 2;\n    int WHITE = 3;\n    int YELLOW = 4;\n    \n    return (color1 == GREEN && is_next_to(BLUE,neighbors))\n        ? GRAY\n    : (color1 == GREEN && is_next_to(WHITE,neighbors))\n        ? GRAY\n    : (color1 == BLUE && is_next_to(GREEN,neighbors))\n        ? WHITE\n    : (color1 == YELLOW && is_next_to(GREEN,neighbors))\n        ? GRAY\n    : (color1 == YELLOW && is_next_to(GRAY,neighbors))\n        ? BLUE\n    :(color1 == WHITE && is_next_to(YELLOW,neighbors))\n        ? GRAY\n    :(color1 == YELLOW && is_next_to(WHITE,neighbors))\n        ? WHITE\n    :(color1 == GRAY && is_next_to(BLUE,neighbors))\n        ? BLUE\n    :color1;\n}\n\nvoid biome(inout int color1, ivec4 neighbors,int biome){\n    color1 =\n        glacier_biome(color1,neighbors);\n}\n\nint biome(in vec2 fragCoord,float mag,float zoom,int colors[5],int biome1){\n    fragCoord *= zoom;\n\n    \n    float num_colors = float(colors.length());\n    \n    int color1 = magnify(fragCoord,mag,num_colors);\n    \n    ivec4 neighbors;\n    \n    while(mag > 1.0){\n    neighbors = get_neighbors(fragCoord,mag,num_colors);\n    biome(color1, neighbors,biome1);\n    mag -= 1.0;\n    }\n    return colors[int(color1)];;\n}\n\n\nint glacier_biome(in vec2 fragCoord,float mag,float zoom,int[5] colors){\n    return biome(fragCoord,mag,zoom,colors,GLACIER_BIOME);\n}\n\nint lava_biome(in vec2 fragCoord,float mag,float zoom){\n\treturn glacier_biome(fragCoord,mag,zoom,int[](DARKGRAY,YELLOW,ORANGERED,ORANGE,ORANGERED));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = mag*(((iMouse.x-iMouse.y)*2.0+iResolution.x)/iResolution.x);\n    fragCoord *= zoom;\n    fragCoord = fragCoord + floor(iTime*100.0)*vec2(zoom,0.0);\n\n\tint biome = lava_biome(fragCoord,mag,1.0);\n    \n    fragColor = vec4(get_color(biome),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsByzG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[741, 803, 840, 896, 1057], [1063, 1063, 1118, 1118, 1310], [1312, 1312, 1371, 1371, 1576], [1579, 1579, 1622, 1622, 1758], [1760, 1760, 1794, 1794, 1823], [1825, 1825, 1851, 1851, 3208], [3211, 3211, 3264, 3264, 3938], [3940, 3940, 3996, 3996, 4052], [4054, 4054, 4129, 4129, 4466], [4757, 4757, 4814, 4814, 5074]], "test": "error"}
{"id": "wsByzt", "name": "Color Circle SmoothStep", "author": "nickcody", "description": "Click and drag to four corners: x-axis controls width of circle edge, y-axis controls blend.", "tags": ["circle", "geometry", "smoothstep"], "likes": 1, "viewed": 294, "published": "Public API", "date": "1587145663", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec3 white = vec3(1., 1., 1.);\nconst vec3 black = vec3(0., 0., 0.);\nconst float EDGE_SCALE = .02;\n\n// circleTest\n//\n// coord      - pixel to test\n// center     - center of circle\n// radius     - radius of circle\n// width      - thickness of circle line\n// pixelWidth - blendiness\nvec3 circleTest(vec2 coord, vec2 center, float radius, float width, float pixelWidth) {\n    float dist_to_center = sqrt(pow(coord.x - center.x, 2.) + pow(coord.y - center.y, 2.));\n    float delta = dist_to_center-radius;\n\n    // From shadertoy default shader\n    vec2 uv = gl_FragCoord.xy/iResolution.xy;\n    vec3 inside = .5 + .5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    float blend = smoothstep(0., pixelWidth, abs(delta) - width);\n    \n    if (delta  < 0.) {\n    \t// rgb -> white (inside  edge)\n        return mix(white, inside, blend);\n    } else if (delta  > 0.) {\n    \t// white -> black (outside edge)\n        return mix(white, black, blend);\n    } else {\n        // can't decide\n        return white;\n    }\n        \n}\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord) {\n\tvec2 center = iResolution.xy/2.;\n    float pixelWidth;\n    float width;\n    \n    if (iMouse.xy == vec2(0)) {\n        pixelWidth = width = 1.;\n    } else {\n        pixelWidth = EDGE_SCALE * distance(iMouse.y, 0.);\n        width = EDGE_SCALE * distance(iMouse.x, 0.);\n    }\n    \n    vec3 c = circleTest(gl_FragCoord.xy, center, center.y/2., width, pixelWidth);\n\t\n    out_color = vec4(c, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsByzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 286, 373, 373, 1009], [1011, 1011, 1063, 1063, 1456]], "test": "valid"}
{"id": "wsByzw", "name": "Mandelbulb_rainbow", "author": "elle", "description": "3D fractal -> http://blog.hvidtfeldts.net/index.php/2011/06/distance-estimated-3d-fractals-part-i/\nhsv2rgb -> https://www.shadertoy.com/view/MsS3Wc", "tags": ["fractal", "mandelbulb"], "likes": 5, "viewed": 250, "published": "Public API", "date": "1586657482", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 rotate(vec3 p, float angleX, float angleY)\n{\n    float cosA = cos(angleY);\n\tfloat sinA = sin(angleY);\n\tvec3 r = vec3(p.x, sinA * p.z + cosA * p.y, cosA * p.z - sinA * p.y);\n    cosA = cos(angleX);\n\tsinA = sin(angleX);\n\treturn (-vec3(cosA * r.x - sinA * r.z, r.y, sinA * r.x + cosA * r.z));\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0,4.0,2.0),6.0) - 3.0) - 1.0, 0.0, 1.0);\n\treturn (c.z * mix(vec3(1.0), rgb, c.y));\n}\n\nfloat distSphere(vec3 p, float r)\n{\n\treturn (length(p) - r);\n}\n\nbool backgr = false;\n\nfloat distanceEstimate(vec3 p)\n{\n    float bailout = 2.0;\n\tfloat dSphere = -distSphere(p, 12.0);\t\n\tvec3 v = p;\n\tfloat r = 0.0;\n\tfloat dr = 1.0;\n\tfloat power = abs(cos(iTime * 0.02)) * 10.0 + 2.0;\n\tfor(float n = 0.0; n <= 8.0; n++)\n\t{\n\t\tr = length(v);\n\t\tif(r > bailout)\n            break;\n        // convert to polar coordinate\n\t\tfloat theta = acos(v.z / r);\n\t\tfloat phi = atan(v.y, v.x);\n\t\tdr = pow(r, power - 1.0) * power * dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat vr = pow(r, power);\n\t\ttheta = theta * power;\n\t\tphi = phi * power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tv = vr * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));\n        \n        v += p;\n\t}\n\tfloat dFractal = 0.50 * log(r) * r / dr;\t\n\tbackgr = dSphere < dFractal ? true : false;\n\treturn (min(dFractal, dSphere));\n}\n\nvec3 getNormal(vec3 pos, float dist)\n{\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n\treturn normalize(vec3(\n           distanceEstimate(pos + eps.xyy),\n           distanceEstimate(pos + eps.yxy),\n           distanceEstimate(pos + eps.yyx)) - dist);\n}\n\nfloat softShadow(in vec3 ro, in vec3 rd, in float k)\n{\n    float res = 1.0;\n    float t = 0.0;\n    for(int i = 0; i < 64; i++)\n    {\n        float d = distanceEstimate(ro + rd * t);\n        res = min(res, k * d/t);\n        if(res < 0.001)\n            break;\n        t += clamp(d, 0.01, 0.2);\n    }\n    return (clamp(res, 0.0, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 aspectRatio = vec2(iResolution.x/iResolution.y, 1.0);\n\tvec2 uv = aspectRatio * (fragCoord.xy / iResolution.xy - 0.5);\n    vec2 mouse = 7.0 * (iMouse.xy / iResolution.xy - 0.5);\n    vec3 ro = rotate(vec3(0.0, 0.0, 2.5), mouse.x, mouse.y);\n    vec3 rd = -rotate(vec3(uv, 1.0), mouse.x, mouse.y);  \n    vec3 light = rotate(vec3(0.0, 0.3, 0.77), mouse.x, mouse.y);\n    vec3 lightColor = vec3(0.8, 0.9, 1.0);\n    vec3 material;\n    vec3 color;\n    float eps = 0.002;\n\tfloat dist;\n\tfor(float n = 0.0; n < 200.0; n++)\n    {\n\t\tdist = distanceEstimate(ro);\n\t\tif(dist < eps)\n\t\t\tbreak;\n\t\tro += rd * dist * 0.5;\n\t}\n\tif(backgr == true)\n\t{ \n        color = vec3(0.3, 0.8, 1.0) * (0.5 - 0.4 * uv.x);\n\t\tfragColor = vec4(color, 1.0);\n\t\treturn;\n\t}\n\tvec3 norm = getNormal(ro, dist);\n\tmaterial = hsv2rgb(vec3(dot(ro, ro) - 0.27, 1.2, 1.0));\n\tvec3 lightDir = normalize(light - rd);   \n\tfloat shadow = softShadow(ro + 0.001 * norm, light, 5.0);\n    float ambient = 0.22;\n\tfloat diff = clamp(dot(light, norm), 0.0, 1.0) * shadow * 0.9;\n\tfloat spec = pow(clamp(dot(norm, lightDir), 0.0, 1.0), 32.0) * shadow * 1.8;\n \tcolor = (lightColor * (ambient + diff + spec) * material);  \n\tcolor = pow(color, lightColor); \n\tvec2 fd = (6.0 * fragCoord - iResolution.xy) / iResolution.y;   \n    color *= 1.0 - length(fd) * 0.07;\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsByzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 49, 49, 296], [298, 298, 320, 320, 453], [455, 455, 490, 490, 517], [541, 541, 573, 573, 1357], [1359, 1359, 1397, 1397, 1602], [1604, 1604, 1658, 1658, 1938], [1940, 1940, 1995, 1995, 3329]], "test": "valid"}
{"id": "WsfBDH", "name": "Broken box", "author": "gaz", "description": "https://twitter.com/gaziya5/status/1255243348866142218", "tags": ["3d", "2tweets"], "likes": 12, "viewed": 90, "published": "Public", "date": "1588109183", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(a)a=vec2(a.x+a.y,a.x-a.y)*.7\nvoid mainImage(out vec4 O, vec2 C) {\n\tfor(float g,e,j,i;i++<50.;){\n   \t\tvec3 p=g*vec3((C*2.-iResolution.xy)/iResolution.y,1);\n        p.z+=iTime;\n        p=fract(p)-.5;\n        p.xz=abs(p.xz)-.15-.05*(sin(iTime*2.));\n        R(p.xz);R(p.yz);\n        p.yz=abs(p.yz)-.1;\n        R(p.yz);\n        g+=e=.5*length(p.xy)-.01;\n        e<.01?O.xyz+=.4/i:p;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsfBDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[39, 39, 75, 75, 395]], "test": "valid"}
{"id": "WsfBDN", "name": "Waving Plane", "author": "os0450", "description": "Day 29: Plane/Snake", "tags": ["dailycodingchallenge"], "likes": 3, "viewed": 71, "published": "Public", "date": "1588241229", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(float s) {\n    return fract(sin(s)*3908213.21321);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    vec2 q = p;\n    q.y -= -0.4;\n    \n    float t = fract(iTime/4.0)*10.0 - 5.0;\n    float c = floor(iTime/4.0);\n    \n    for(float i=0.0; i<=3.0; i+=1.0) {\n    \tq.y -= +0.3*smoothstep(0.0, rand(c+i*11.0)*0.5+0.05, abs(q.x-t-rand(c+i*13.0))-rand(c+i));\n    \tq.y -= -0.3*smoothstep(0.0, rand(c+i*17.0)*0.5+0.05, abs(q.x-t-rand(c+i*23.0))-rand(c+i*0.5));\n    }\n    \n    vec3 col = vec3(0.02);\n    float pi = acos(-1.0);\n    float banner = smoothstep(0.64, 0.63, abs(q.y-0.45));\n    col = mix(col, vec3(1.0), banner);\n    col -=\n        0.8*smoothstep(0.3, -0.3, sin( (q.x+iTime*0.2+floor(q.y*9.)*pi*0.5)*30. ))*\n        banner;\n    col = pow(col, vec3(0.45));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsfBDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 63], [65, 65, 122, 122, 902]], "test": "valid"}
{"id": "WsfBRH", "name": "Circular rounding errors", "author": "kamjam21xx", "description": "Pretty sure this is just a rounding error from squaring those coordinates so they they line up just right to be rounded into circles on my GPU. May look different for you. This is my first shaderToy shader, so meh.", "tags": ["circle"], "likes": 3, "viewed": 81, "published": "Public", "date": "1587653942", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float c = 1.45;\n    float t = iTime * c;\n    float s = t * 128.0; //sin(t/1.5) * 150.0 + 50000.0;\n\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = 0.5 + 0.5 * cos(t + uv.xyx + vec3(0,2,4));\n    \n    vec2 center = vec2(iResolution.x / 2.0, iResolution.y/2.0);\n    float x = fragCoord.x - center.x;\n    float y = fragCoord.y - center.y;\n    float xSquared = x * x;\n    float ySquared = y * y;\n\n    fragColor = vec4(col,1.0);\n    fragColor.g *= 0.5;\n    fragColor.g += sin(t * 12.0 * (xSquared + ySquared)/s - 2.001 * s);\n    fragColor.b += sin(t * 12.0 * (xSquared + ySquared)/s - 2.0011 * s)/50.0;\n    fragColor.r += sin(t * 12.0 * (xSquared + ySquared)/s - 2.0012 * s)/100.0;\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsfBRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 747]], "test": "valid"}
{"id": "WsfBW4", "name": "Tutorial point cube", "author": "CraftedCart", "description": "https://www.youtube.com/watch?v=dKA5ZVALOhs\nhttps://www.youtube.com/watch?v=PBxuVlp7nuM", "tags": ["3d", "tutorial"], "likes": 1, "viewed": 241, "published": "Public API", "date": "1588206204", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec3 WORLD_UP = vec3(0.0, 1.0, 0.0);\nconst vec3 VIEW_TARGET = vec3(0.0, 0.0, 0.0);\nconst float ZOOM_FAC = 2.0;\n\n/** Returns how far away `point` is from the ray line */\nfloat distLine(vec3 rayOrigin, vec3 rayDir, vec3 point) {\n    return length(cross(point - rayOrigin, rayDir)) / length(rayDir);\n}\n\nfloat drawPoint(vec3 rayOrigin, vec3 rayDir, vec3 point) {\n    return smoothstep(0.06, 0.05, distLine(rayOrigin, rayDir, point));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float ratio = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord / iResolution.xy;\n\n    uv -= 0.5; // Move the origin to the middle of the screen\n    uv.x *= ratio; // Account for the aspect ratio\n\n    vec3 rayOrigin = vec3(cos(iTime) * 4.0, sin(iTime) * 4.0, sin(iTime) * 4.0); // Camera position\n\n    vec3 camForward = normalize(VIEW_TARGET - rayOrigin);\n    vec3 camRight = normalize(cross(WORLD_UP, camForward));\n    vec3 camUp = cross(camForward, camRight);\n\n    vec3 screenCenter = rayOrigin + camForward * ZOOM_FAC; // Figure out where the center of the screen is in 3D space\n    vec3 intersectPoint = screenCenter + (uv.x * camRight) + (uv.y * camUp);\n\n    vec3 rayDir = intersectPoint - rayOrigin;\n\n    // Make a color shifting gradient\n    vec3 col = 0.5 + 0.5 * cos((iTime * 0.8) + uv.xyx + vec3(0.0, 2.0, 4.0));\n\n    float mask = 0.0;\n\n    // Add points of a cube\n    // mask += drawPoint(rayOrigin, rayDir, vec3(-0.5, -0.5, -0.5));\n    // mask += drawPoint(rayOrigin, rayDir, vec3(-0.5, -0.5,  0.5));\n    // mask += drawPoint(rayOrigin, rayDir, vec3(-0.5,  0.5, -0.5));\n    // mask += drawPoint(rayOrigin, rayDir, vec3(-0.5,  0.5,  0.5));\n    // mask += drawPoint(rayOrigin, rayDir, vec3( 0.5, -0.5, -0.5));\n    // mask += drawPoint(rayOrigin, rayDir, vec3( 0.5, -0.5,  0.5));\n    // mask += drawPoint(rayOrigin, rayDir, vec3( 0.5,  0.5, -0.5));\n    // mask += drawPoint(rayOrigin, rayDir, vec3( 0.5,  0.5,  0.5));\n\n    // Add \"lines\" (composed of many points) of a cube\n    for (float x = -0.5; x < 0.5; x += 0.05) {\n        mask += drawPoint(rayOrigin, rayDir, vec3(x, -0.5, -0.5));\n        mask += drawPoint(rayOrigin, rayDir, vec3(x,  0.5, -0.5));\n        mask += drawPoint(rayOrigin, rayDir, vec3(x, -0.5,  0.5));\n        mask += drawPoint(rayOrigin, rayDir, vec3(x,  0.5,  0.5));\n    }\n\n    for (float y = -0.5; y < 0.5; y += 0.05) {\n        mask += drawPoint(rayOrigin, rayDir, vec3(-0.5, y, -0.5));\n        mask += drawPoint(rayOrigin, rayDir, vec3( 0.5, y, -0.5));\n        mask += drawPoint(rayOrigin, rayDir, vec3(-0.5, y,  0.5));\n        mask += drawPoint(rayOrigin, rayDir, vec3( 0.5, y,  0.5));\n    }\n\n    for (float z = -0.5; z < 0.5; z += 0.05) {\n        mask += drawPoint(rayOrigin, rayDir, vec3(-0.5, -0.5, z));\n        mask += drawPoint(rayOrigin, rayDir, vec3( 0.5, -0.5, z));\n        mask += drawPoint(rayOrigin, rayDir, vec3(-0.5,  0.5, z));\n        mask += drawPoint(rayOrigin, rayDir, vec3( 0.5,  0.5, z));\n    }\n\n    col *= (min(mask, 1.0) * 0.8) + 0.2;\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsfBW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[118, 175, 232, 232, 304], [306, 306, 364, 364, 437], [439, 439, 494, 494, 3052]], "test": "valid"}
{"id": "wsfBWr", "name": "Julia 7 v1", "author": "jonGomez", "description": "Julia set, inspired by https://en.wikipedia.org/wiki/Julia_set#/media/File:JSr07885.gif", "tags": ["julia", "mandelbrot", "fractals"], "likes": 2, "viewed": 251, "published": "Public API", "date": "1588020315", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// inspired by https://en.wikipedia.org/wiki/Julia_set#/media/File:JSr07885.gif\n// https://www.shadertoy.com/view/XljGzV\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (y: -1 to 1 ;; x: -something to something)\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    \n    vec2 z = uv;\n    \n    float my_const = 0.7885;\n    float theta = iTime*0.4;\n    vec2 c = vec2(my_const*cos(theta), my_const*sin(theta));\n    \n    const float max_steps = 65.;\n    float boundary = 20.;\n    float num_steps;\n    \n    for(num_steps = 0.; num_steps<max_steps; num_steps++) {\n    \tz = vec2(z.x*z.x - z.y*z.y, 2.*z.x*z.y) + c;\n        if(length(z) > boundary) break;\n    }\n    \n    float pixel_intensity = num_steps/max_steps;\n    \n    vec3 col = hsl2rgb(vec3(pixel_intensity + .6,1., smoothstep(1.,.8,pixel_intensity)*.5));\n \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsfBWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 121, 148, 148, 291], [293, 293, 350, 429, 1094]], "test": "valid"}
{"id": "WsfBz8", "name": "1 tweet effect challenge", "author": "yasuo", "description": "I won't do this any more.... This shit takes my time forever.....", "tags": ["raymarching", "tweet"], "likes": 2, "viewed": 254, "published": "Public API", "date": "1587651535", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 O, vec2 T) {\n    vec2 R=iResolution.xy,U=(T-.5*R.xy)/R.y;\n    float D,t=iTime;\n    vec3 P,B = normalize( vec3( U.x, U.y,1) );\n    for(int i = 0; i<64;i++) {\n        P = vec3(0, sin(U.x*5.+t), -5)+ B*D;\n        P.z-=t*6.; \n        P=mod(P,3.)-1.5;\n        P.z -= clamp( P.z, 0., 5. );\n        D+=length(P) - .05;\n    }\n    O.r=O.g=((D< 16.) ? 1.:0.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsfBz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 375]], "test": "valid"}
{"id": "WsfBzN", "name": "Shine On You Crazy Ball", "author": "Kali", "description": "Surely not the best way to achieve what I did here, but I'm quite happy with the outcome and it was fun to figure out things. ", "tags": ["raymarching", "volumetric", "reflections"], "likes": 78, "viewed": 3149, "published": "Public", "date": "1587743973", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float det=.005;\nconst float maxdist=50.;\nfloat objcol, flo;\nvec3 ldir=vec3(4.,-1.5,-1.);\nconst vec3 lcol=vec3(.7,.3,.2);\nconst vec3 ilcol=vec3(.6,.5,1.);\n\n\nmat2 rot(float a) {\n\tfloat s=sin(a), c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\nvec3 fractal(vec2 p) {\n    float m=100., l=100.;\n    vec2 c=vec2(100.);\n    p*=.2;\n    for (int i=0; i<5; i++) {\n    \tp=abs(p+.75)-abs(p-.75)-p;\n        p+=vec2(0.,2.);\n        p=p*2.5/clamp(dot(p,p),.2,1.)-1.5;\n        if (i>0) l=min(l,min(abs(p.x),abs(p.y)));\n        m=min(m,length(p));\n        c=min(c,abs(p));\n    }\n    l=exp(-6.*l)*pow(abs(.5-fract(m*.3+iTime))*2.,6.);\n    c=normalize(exp(-1.*c));\n    return l*vec3(c.x,length(p)*.015,c.y)*1.5;\n}\n\nvec3 rotate(vec3 p) {\n    p.xz*=rot(iTime);\n    p.yz*=rot(iTime*.5);\n\treturn p;\n}\n\nfloat de_light(vec3 p) {\n    return length(p)-1.5;\n}\n\n\nfloat de(vec3 p) {\n    float op=smoothstep(.5,.7,sin(iTime*.5));\n    //float op=1.;\n    float r=-op*1.3;\n\tfloat w=cos(length(p.xz*2.)-iTime*5.)*.15*smoothstep(0.,3.,length(p.xz));\n    w*=exp(-.1*length(p.xz));\n    float f=p.y+3.+w-r;\n    p=rotate(p);\n    float c1=abs(p.x)-op;\n    float c2=abs(p.y)-op;\n    float c3=abs(p.z)-op;\n\tfloat c=min(min(c3,min(c1,c2)),length(p)-2.8+r);\n    float s=length(p)-3.+r;\n    float d=max(s,-c);\n    p=fract(p*5.);\n    float grid=min(abs(p.z),min(abs(p.x),abs(p.y)))*.5;\n    d=min(d,f);\n    objcol=max(step(c,d+.1),grid);\n    flo=step(f,d);\n    objcol=max(flo,objcol);\n    return d;\n}\n\nvec3 normal(vec3 p) {\n    vec3 e=vec3(0.,det*4.,0.);\n\treturn normalize(vec3(de(p+e.yxx),de(p+e.xyx),de(p+e.xxy))-de(p));\n}\n\nvec3 triplanar(vec3 p, vec3 n) {\n\tp=rotate(p);\n    return fractal(p.yz) * abs(n.x) + fractal(p.xz) * abs(n.y) + fractal(p.xy) * abs(n.z);\n}\n\nfloat shadow(vec3 p, vec3 dir) {\n\tfloat td=.0, sh=1., d=.2;\n    for (int i=0; i<60; i++) {\n        p-=d*dir;\n        d=de(p);\n        float dl=de_light(p);\n        td+=min(d,dl);\n        sh=min(sh,10.*d/td);\n        if (sh<.01 || dl<1.) break;\n    }\n    return clamp(sh,0.,1.);\n}\n\n\nvec3 shade(vec3 p, vec3 n, vec3 dir) {\n    float f=flo;\n    float ocol=objcol;\n    float sh=shadow(p,ldir);\n    float ish=shadow(p,normalize(p));\n    sh=max(sh,ish);\n    float amb=max(0.,dot(dir,-n))*.1;\n    float dif=max(0.,dot(ldir,-n))*sh;\n    vec3 ref=reflect(ldir,-n);\n    float spe=pow(max(0.,dot(dir,-ref)),50.);\n    vec3 fcol=triplanar(p,n)*(1.-ocol);\n    vec3 col=ocol*vec3(1.5)-f;\n    vec3 ildir=normalize(p);\n    float idif=max(0.,dot(ildir,-n))*exp(-.05*length(p));    \n    vec3 lref=reflect(ildir,-n);\n    float lspe=pow(max(0.,dot(dir,-lref)),30.)*ish;\n    return max((amb+dif*lcol)*col+spe*lcol,idif*ilcol*ish+lspe)+fcol;\n}\n\n\nvec3 march(vec3 from, vec3 dir) {\n\tfloat d, dl, td=0., tdl=0., ref=0.;\n    vec3 p=from, refrom=from, pl=p, col=vec3(0.), savecol=col, odir=dir;\n    vec3 back=lcol*max(0.,1.-dir.y*3.)*.1;\n    for (int i=0; i<80; i++) {\n\t\tp+=dir*d;\n\t\tpl+=dir*dl;\n        d=de(p);\n        td+=d;\n        if (d<det && flo<.5) break;\n        if (td>maxdist) break;\n        if (d<det && flo>.5) {\n\t        p-=det*dir*2.;\n            vec3 n=normal(p);\n            savecol=mix(shade(p,n,dir),back,td/maxdist);\n            dir=reflect(dir,n);\n            ref=.7;\n            refrom=p;\n        }\n    }\n    if (d<det) {\n        p-=det*dir*2.;\n        vec3 n=normal(p);\n    \tcol=shade(p,n,dir);\n    } else {\n      \tback+=pow(max(0.,dot(dir,normalize(-ldir))),100.)*lcol;\n\t    back+=pow(max(0.,dot(dir,normalize(-ldir))),200.)*.5;\n        col=back;\n        td=maxdist;\n    }\n    float li1=pow(max(0.,dot(dir,-normalize(refrom))),120.);\n    float li2=pow(max(0.,dot(odir,-normalize(from))),120.);\n    float li=max(li1,li2);\n    li*=step(length(from),distance(p,from));\n    col=mix(col,savecol,ref)+li*ilcol*2.;\n    \n    int steps=70;\n    float lmax=maxdist*.5;\n    float st=lmax/float(steps);\n    li=0.;\n    for (int i=0; i<steps; i++) {\n    \tp=from+odir*tdl;\n        tdl+=st;\n        if (tdl>td) break;\n        li+=shadow(p, normalize(p))*exp(-.25*length(p));\n    }\n    \n    return col+li*.035*ilcol;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tldir=normalize(ldir);\n    vec2 uv=(fragCoord-iResolution.xy*.5)/iResolution.y;\n\tvec3 dir=normalize(vec3(uv,1.+sin(10.+iTime*.5)*.3));\n    vec3 from=vec3(0.,0.,-12.);\n    from.xz*=rot(iTime*.2);\n    dir.xz*=rot(iTime*.2);\n    dir.x+=sin(iTime*.5)*.3;\n    dir=normalize(dir);\n    vec3 col = march(from, dir);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsfBzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[162, 162, 181, 181, 237], [239, 239, 261, 261, 692], [694, 694, 715, 715, 775], [777, 777, 801, 801, 829], [832, 832, 850, 850, 1450], [1452, 1452, 1473, 1473, 1574], [1576, 1576, 1608, 1608, 1715], [1717, 1717, 1749, 1749, 1996], [1999, 1999, 2037, 2037, 2637], [2640, 2640, 2673, 2673, 4012], [4015, 4015, 4072, 4072, 4413]], "test": "valid"}
{"id": "wsfcDf", "name": "logistic_difference_v0007", "author": "darkczar", "description": "logistic difference equation silliness", "tags": ["psychedelic", "trippy"], "likes": 1, "viewed": 60, "published": "Public", "date": "1585722031", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// based on...\n// https://www.shadertoy.com/view/lssfW2\n\nfloat nsin(float x)\n{\n    return .5+.5*sin(x);\n}\nfloat ncos(float x)\n{\n    return .5+.5*cos(x);\n}\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}  //https://gist.github.com/companje/29408948f1e8be54dd5733a74ca49bb9\n\nhighp float rand(vec2 co)  //from stackoverflow\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nuint hash( uint x ) {  //http://amindforeverprogramming.blogspot.com/2013/07/random-floats-in-glsl-330.html\n\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\nfloat random( float f ) {  //http://amindforeverprogramming.blogspot.com/2013/07/random-floats-in-glsl-330.html\n\n    const uint mantissaMask = 0x007FFFFFu;\n    const uint one          = 0x3F800000u;\n   \n    uint h = hash( floatBitsToUint( f ) );\n    h &= mantissaMask;\n    h |= one;\n    \n    float  r2 = uintBitsToFloat( h );\n    return r2 - 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float r = 0.0;\n    float g = 0.0;\n    float b = 0.0;\n    vec2 xy0 = vec2(0.,0.);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord /iResolution.xy;\n    //vec2 p=uv;//(fragCoord.xy-iResolution.xy)/iResolution.y;\n    \n    vec2 xy = vec2(0.,0.);\n    // r between 3.75 and 4.0 produces chaotic behavior\n    float rr = .5*(ncos(.5*iTime))+3.5; // + .5*nsin(iTime*.5); //2.57 +nsin(iTime); //+cos(iTime);\n    xy = uv;\n    //int max_iter = int(6.0 + floor(8.0*nsin(iTime*.2)));\n    for (int i = 0; i<9; i++)\n    {\n        xy = rr*xy*(vec2(1.0,1.0)-xy + .125*nsin(.1*iTime)*vec2(sin(.5*iTime + 6.28*xy.y),cos(.5*iTime-6.28*xy.x)));\n        if(i==0)\n        {\n          xy0 = xy;  \n        }\n        if (i>1)\n            {\n                if(abs(length(xy) - length(xy0)) < .1) // try and tease out the cycles and color them\n                {\n                    r = 1.*random(float(mod(float(i),15.00)))*nsin(iTime);\n                    g = 1.*random(1.28+float(mod(float(i),15.0)));\n                    b = 1.*random((1.0 - float(mod(float(i),15.0))))*ncos(iTime);\n                } else if (dot(normalize(xy),normalize(xy0)) > .08)\n                {\n                    r = 1.*random((1.0 - float(mod(float(i),15.0))))*ncos(iTime);\n                    g = 1.0 - 1.*random(1.28+float(mod(float(i),15.0)));\n                    b = 1.*random(float(mod(float(i),15.00)))*nsin(iTime);\n                }\n            }\n    }\n    if (length(xy) > 20000.0)\n    {\n        r = mod(length(xy),2000.0)/8000000.0;\n        g = 0.0;\n        b = 20000.0/length(xy);\n    } \n        \n        //m = (rand_point.x-prev_point.x) / ((rand_point.y-prev_point.y);\n        //line_y = m*p.x +  \n\n\n    \n    vec3 col = vec3(r, g, b);\n    float dn = col.x + col.y + col.z;\n    col /= dn;\n    // Output to screen\n    //fragColor = vec4(col,1.0);\n    fragColor = vec4( pow(col,vec3(1./2.2)),1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsfcDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 79, 79, 106], [107, 107, 128, 128, 155], [157, 157, 229, 229, 295], [616, 616, 637, 723, 855], [856, 856, 881, 967, 1204], [1206, 1206, 1263, 1263, 3152]], "test": "valid"}
{"id": "WsfcWs", "name": "logistic_difference_v0008", "author": "darkczar", "description": "more noodling", "tags": ["trippy"], "likes": 2, "viewed": 33, "published": "Public", "date": "1585807279", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// based on...\n// https://www.shadertoy.com/view/lssfW2\n\nfloat nsin(float x)\n{\n    return .5+.5*sin(x);\n}\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}  //https://gist.github.com/companje/29408948f1e8be54dd5733a74ca49bb9\n\nhighp float rand(vec2 co)  //from stackoverflow\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nuint hash( uint x ) {  //http://amindforeverprogramming.blogspot.com/2013/07/random-floats-in-glsl-330.html\n\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\nfloat random( float f ) {  //http://amindforeverprogramming.blogspot.com/2013/07/random-floats-in-glsl-330.html\n\n    const uint mantissaMask = 0x007FFFFFu;\n    const uint one          = 0x3F800000u;\n   \n    uint h = hash( floatBitsToUint( f ) );\n    h &= mantissaMask;\n    h |= one;\n    \n    float  r2 = uintBitsToFloat( h );\n    return r2 - 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float r = 0.0;\n    float g = 0.0;\n    float b = 0.0;\n    vec2 xy0 = vec2(0.,0.);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p=(fragCoord.xy-iResolution.xy)/iResolution.y;\n    \n    vec2 xy = vec2(0.,0.);\n    float rr = .5*(nsin(.15*iTime))+3.5; // + .5*nsin(iTime*.5); //2.57 +nsin(iTime); //+cos(iTime);\n    xy = uv;\n    for (int i = 0; i<9; i++)\n    {\n        xy = rr*xy*(vec2(1.0,1.0)-xy);\n        if(i==0)\n        {\n          xy0 = xy;  \n        }\n        if (i>0)\n            {\n                if(abs(length(xy) - length(xy0)) < .005) // try and tease out the cycles and color them\n                {\n                    r = 1.*random(float(mod(float(i),7.0)));\n                    g = 1.*random(1.28+float(mod(float(i),7.0)));\n                    b = 1.*random((1.0 - float(mod(float(i),7.0))));\n                }\n            }\n    }\n    if (length(xy) > 3.0)\n    {\n        r = .05;\n        g = 0.2;\n        b = 0.9;\n    } else\n    {\n        //r = .05;\n        //g = .99;\n        //b = .3;\n    }\n        \n        //m = (rand_point.x-prev_point.x) / ((rand_point.y-prev_point.y);\n        //line_y = m*p.x +  \n\n\n    \n    vec3 col = vec3(r, g, b);\n    float dn = col.x + col.y + col.z;\n    col /= dn;\n    // Output to screen\n    //fragColor = vec4(col,1.0);\n    fragColor = vec4( pow(col,vec3(1./2.2)),1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsfcWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 79, 79, 106], [108, 108, 180, 180, 246], [567, 567, 588, 674, 806], [807, 807, 832, 918, 1155], [1157, 1157, 1214, 1214, 2585]], "test": "valid"}
{"id": "WsffRM", "name": "MandelBro", "author": "savegor", "description": "Simple visualization of the Mandelbrot set.", "tags": ["test"], "likes": 2, "viewed": 117, "published": "Public", "date": "1587856602", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 nextZ(vec2 z, vec2 z0) {\n    const float c = 0.0;\n    \n    return vec2(z.x * z.x - z.y * z.y + z0.x, 2.0 * z.x * z.y + z0.y); \n}\n\nfloat mandelbrot(vec2 z, vec2 z0) {    \n    const float R2 = 1200.0;\n    vec2 r = vec2(0.0, 0.0);\n    float i = 0.0;\n    for(; i < 1.0; i = i + 0.0056) {\n    \tz = nextZ(z, z0);\n        r = z - z0;\n        float dist2 = r.x * r.x + r.y * r.y;\n        if(dist2 > R2) {\n            break;\n        }\n    }\n    return i;\n}\n\nfloat red(float i) {\n    i *= 0.2;\n\treturn sin(i * 3.14 * 10.0);   \n}\n\nfloat green(float i) {\n    i *= 0.5;\n\treturn sin(i * 3.14 * 3.0);   \n}\n\nfloat blue(float i) {\n    i *= 1.3;\n\treturn sin(i * 3.14 * 4.0);   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 size = vec2(iResolution.x, iResolution.y);\n    \n    //z coordinate x : -1.0 .. 1.0, y : -1.0 .. 1.0\n    vec2 z = 0.2 * (2.0 * (fragCoord - 0.5 * size) / size);\n    float aspect = size.y / size.x;\n    // y coordinate from -aspect .. aspect\n    z.y *= aspect;\n\n    // scale calculation by time\n    float zeroone = 0.5 * sin(iTime * 0.1);\n    float arg = zeroone * 550.0;\n    float scale = pow(1.029, -arg);\n    \n    // dirty hack for scale increasing slow down\n    if(scale > 1.0) {\n        scale = pow(scale, 0.63);\n    }\n\n    // apply scale\n    z = z * scale;\n    \n    // rotation\n    float alpha = iTime * 0.13;\n    float cosa = cos(alpha);\n    float sina = sin(alpha);\n    \n    z = vec2(z.x * cosa + z.y * sina, z.y * cosa - z.x * sina);\n    \n    //center :: from wiki\n    vec2 center = vec2(-1.88488933694469, 0.00000000081387);\n    z += center;\n    \n    // distance to mandelbrot set\n\tfloat d = mandelbrot(z, z);\n    // Output to screen\n    fragColor = vec4(red(d), green(d), blue(d), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsffRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 133], [135, 135, 170, 170, 452], [454, 454, 474, 474, 523], [525, 525, 547, 547, 595], [597, 597, 618, 618, 666], [668, 668, 725, 725, 1731]], "test": "valid"}
{"id": "wsffRN", "name": "Web container", "author": "gaz", "description": "https://twitter.com/gaziya5/status/1253832111544393729", "tags": ["3d", "2tweets"], "likes": 6, "viewed": 122, "published": "Public", "date": "1587771969", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define F(s)p.s=abs(p.s)-.3+sin(iTime*9.)*.05\nvoid mainImage(out vec4 O, vec2 C) {\n\tfor(float g,e,i;i++<80.;){\n    \tvec3 p=g*vec3(C/iResolution.y-.7,1)+vec3(0,4,iTime*5.);\n    \tp=mod(p,8.)-4.;\n    \tfor(int j;j++<3;)F(xy),F(yz),F(xz);\n    \tg+=e=length(cross(p,.2+p-p))-.02;\n    \te<.01?O.xyz+=(cos(p+exp(-p*8.)))/i:p;\n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsffRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 82, 82, 320]], "test": "valid"}
{"id": "wsffW8", "name": "jumpings", "author": "katila4", "description": "learn how to jump", "tags": ["learning"], "likes": 0, "viewed": 39, "published": "Public", "date": "1588115589", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord/iResolution.xy;\n\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    \n    color = mix(color, vec3(0.0, 1.0, 1.0), step(0.0, st.x));\n    color = mix(color, vec3(1.0, 1.0, 0.0), step(0.340, st.x));\n    color = mix(color, vec3(1.0, 0.0, 1.0), step(0.674, st.x));\n    \n    float pi = 3.14;\n    float c = 1.5;\n    float v1 = abs(sin(iTime * (pi + 0.1) * c));\n    float v2 = abs(sin(iTime * (pi + -0.756) * c));\n    float v3 = abs(sin(iTime * (pi + 0.816) * c));\n    \n    color = color + vec3(1.0, 0.0, 0.0) * step(0.560 * v1, st.y);\n    color = color + vec3(0.0, 1.0, 0.0) * step(0.880 * v2, st.y);\n    color = color + vec3(0.0, 0.0, 1.0) * step(0.592 * v3, st.y);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsffW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 768]], "test": "valid"}
{"id": "wsfyDs", "name": "Amiga Balls", "author": "dr2", "description": "The Amiga and its ever-present ball", "tags": ["amiga", "bounce", "recursion", "computer"], "likes": 13, "viewed": 288, "published": "Public API", "date": "1585835552", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Amiga Balls\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// The Amiga and its ever-present ball\n\n// The Amiga was the best graphics PC when it first appeared.\n\n#define AA   1   // optional antialiasing\n\n#define GURU 0   // optional guru meditation message\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nvoid PxInit ();\nvoid PxBgn (vec2 p);\nfloat PxText (vec2 p, int txt);\nfloat PxChar (vec2 p, vec4 c);\n\nmat3 vuMat;\nvec3 ltDir, bPos;\nvec2 sSize, cSpace;\nfloat dstFar, tCur, sMidHt;\nint idObj, nRec;\nconst int nRecMax = 6;\nconst float pi = 3.14159;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, h;\n  dMin = dstFar;\n  q = p;\n  q.y -= 0.35;\n  d = PrRoundBoxDf (q, vec3 (1., 0.16, 0.7), 0.01);\n  q = p - vec3 (0.7, 0.4, -0.72);\n  d = max (d, - PrBoxDf (q, vec3 (0.17, 0.01, 0.2)));\n  q.y -= -0.02;\n  d = max (d, - PrBoxDf (q, vec3 (0.08, 0.08, 0.03)));\n  q.y -= 0.01;\n  d = max (d, - PrBoxDf (q, vec3 (0.045, 0.05, 0.05)));\n  q = p;\n  q.yz -= vec2 (0.3, -0.72);\n  d = max (d, - PrBoxDf (q, vec3 (1.1, 0.01, 0.03)));\n  q = p;\n  q.x = abs (q.x) - 0.4;\n  q.yz -= vec2 (0.35, -0.72);\n  d = max (d, - PrBoxDf (q, vec3 (0.01, 0.17, 0.03)));\n  q = p;\n  q.x = abs (q.x) - 1.;\n  q.yz -= vec2 (0.35, 0.05);\n  d = max (d, - PrBoxDf (q, vec3 (0.02, 0.007, 0.7)));\n  DMIN (1);\n  q = p;\n  q.x = abs (q.x) - 0.95;\n  q.y -= 0.09;\n  q.x -= 0.02 * q.y;\n  d = PrRoundBoxDf (q, vec3 (0.025 + 0.02 * q.y, 0.09, 0.6), 0.005);\n  q = p;\n  q -= vec3 (-0.05, 0.09, 0.3);\n  d = min (d, PrRoundBoxDf (q, vec3 (0.9, 0.09, 0.02), 0.005));\n  DMIN (2);\n  q = p;\n  q.yz -= vec2 (0.55, 0.05);\n  q.xz = abs (q.xz) - vec2 (0.55, 0.4);\n  d = PrCylDf (q.xzy, 0.05, 0.05);\n  DMIN (3);\n  q = p;\n  q.yz -= vec2 (0.71 + sSize.y, -0.45);\n  d = 0.9 * max (PrRoundBoxDf (q, vec3 (sSize.x + 0.16, sSize.y + 0.12, 0.13), 0.03),\n     - PrRoundBox2Df (q.xy, sSize + 0.01, 0.03));\n  DMIN (4);\n  q = p - vec3 (0.7, 0.4, -0.55);\n  d = PrBoxDf (q, vec3 (0.16, 0.008, 0.16));\n  DMIN (5);\n  q = p;\n  h = sSize.y + 0.05 - 0.1 * (q.z - 0.05);\n  q.yz -= vec2 (0.6 + h, 0.05);\n  d = 0.9 * PrRoundBoxDf (q, vec3 (sSize.x + 0.12, h, 0.6), 0.03);\n  DMIN (6);\n  q = p;\n  q.x = mod (q.x + 1., 2.) - 1.;\n  q -= bPos;\n  d = PrSphDf (q, 0.2);\n  DMIN (11);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 100; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjAO (vec3 ro, vec3 rd)\n{\n  float ao, d;\n  ao = 0.;\n  for (int j = VAR_ZERO; j < 8; j ++) {\n    d = float (j + 1) / 16.;\n    ao += max (0., d - 3. * ObjDf (ro + d * rd));\n  }\n  return 0.4 + 0.6 * clamp (1. - 0.2 * ao, 0., 1.);\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  vec2 q;\n  float d;\n  if (rd.y >= 0.) col = vec3 (0.1, 0.2, 0.3) + 0.2 * pow (1. - rd.y, 5.);\n  else {\n    d = - ro.y / rd.y;\n    q = ro.xz + d * rd.xz;\n    col = mix (mix (vec3 (0.3, 0.1, 0.), vec3 (0.4, 0.2, 0.), smoothstep (0.4, 0.6, Fbm2 (q * vec2 (1., 4.)))),\n       vec3 (0.3, 0.4, 0.5), 1. - min (1., exp2 (2. - 8. * d / dstFar)));\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro)\n{\n  vec4 col4;\n  vec3 col, rd, roh, vn, q;\n  vec2 sb, a;\n  float dstObj, ao;\n  bool isBg, isScrn;\n  isBg = false;\n  isScrn = true;\n  for (int k = VAR_ZERO; k <= nRecMax; k ++) {\n    rd = normalize (vec3 (ro.xy, 7.));\n    if (k == 0) ro.xy = vec2 (0.);\n    ro.z -= 20. * sSize.y;\n    rd = vuMat * rd;\n    ro = vuMat * ro;\n    ro.y += sMidHt;\n    dstObj = ObjRay (ro, rd);\n    if (dstObj >= dstFar) isBg = true;\n    else {\n      ro += dstObj * rd;\n      roh = ro;\n      if (idObj != 6) isScrn = false;\n      else {\n        ro.y -= sMidHt;\n        sb = abs (ro.xy) - sSize;\n#if GURU\n        isScrn = (max (sb.x, sb.y) < 0. && ro.z < -0.5 && k < nRec);\n#else\n        isScrn = (max (sb.x, sb.y) < 0. && ro.z < -0.5);\n#endif\n      } \n    }\n#if GURU\n    if (! isScrn || isBg || k == nRec) break;\n#else\n    if (! isScrn || isBg) break;\n#endif\n  }\n  if (isBg) {\n    col = BgCol (ro, rd);\n    if (rd.y < 0.) {\n      roh = ro - (ro.y / rd.y) * rd;\n      if (length (roh.xz) < 2.) col *= ObjAO (roh, vec3 (0., 1., 0.));\n    }\n  } else {\n    col4 = vec4 (0.8, 0.81, 0.79, 0.);\n    PxInit ();\n    if (idObj < 11) {\n      if (idObj == 1) {\n        if (ro.z < -0.65) {\n          col4.rgb *= 1.2;\n          sb = ro.xy - vec2 (-0.82, 0.42);\n          sb.x -= 0.2 * sb.y;\n          if (PxText (sb * 260., 1) > 0.) col4 = vec4 (0.1);\n          else if (PxText ((ro.xy - vec2 (-0.75, 0.21)) * 240., 2) > 0.)\n             col4 = vec4 (0.1, 0.1, 0.8, 0.3);\n          else if (abs (abs (ro.x) - 0.9) < 0.02 && abs (ro.y - 0.3) < 0.008)\n             col4 = (ro.x < 0.) ? vec4 (0., 1., 0., -1.) : ((mod (0.33 * tCur, 1.) < 0.3) ?\n             vec4 (1., 0., 0., -1.) : vec4 (0.4, 0.4, 0.4, 0.1));\n        }\n      } else if (idObj == 2) {\n        col4 *= 0.9;\n      } else if (idObj == 3) {\n        col4.rgb = vec3 (0.4, 0.3, 0.1);\n      } else if (idObj == 4) {\n        if (ro.z < -0.45) col4 *= 1.2;\n        if (ro.z < -0.6 && abs (ro.x) < sSize.x + 0.15 &&\n           abs (ro.y - sMidHt) < sSize.y + 0.11) col4 *= 0.8;\n      } else if (idObj == 5) {\n        col4.rgb = vec3 (0.1);\n      } else if (idObj == 6) {\n        if (length (ro.yz - vec2 (-0.4, -0.05)) < 0.15 &&\n           mod (ro.y + 0.4 - 0.01, 0.04) < 0.02) col4 *= 0.4;\n        else if (ro.z < -0.5) {\n          col4 = vec4 (0.1);\n#if GURU\n          sb = (ro.xy - vec2 (0., 0.6 * sSize.y)) * 340.;\n          if (PxText (sb, 0) > 0.) col4 = vec4 (1., 0., 0., -1.);\n          else if (mod (tCur, 1.) < 0.5) {\n            ro.xy = (abs (sb - vec2 (0., -1.5) * cSpace) - vec2 (29., 7.) * cSpace);\n            if (max (ro.x, ro.y) < 1.25 &&\n               (min (abs (ro.x), abs (ro.y)) < 1.25)) col4 = vec4 (1., 0., 0., -1.);\n          }\n#endif\n        }\n      }\n    }\n    if (! isScrn) {\n      if (col4.a >= 0.) {\n        vn = ObjNf (roh);\n        if (idObj < 11) vn = VaryNf (128. * roh, vn, 0.2);\n        else {\n          sb = Rot2D (vn.xy, -0.1 * pi);\n          a = sign (mod (floor (8. * vec2 (atan (sb.x, vn.z) + 0.6 * pi * tCur, asin (sb.y)) / pi), 2.) - 0.5);\n          col4 = mix (vec4 (1., 0., 0., 0.2), vec4 (0.95, 0.95, 1., 0.2), step (0., a.x * a.y));\n        }\n        ao = ObjAO (roh, vn);\n        col = ao * (col4.rgb * (0.2 + 0.1 * max (0., - dot (vn, normalize (vec3 (ltDir.xz, 0.).xzy))) +\n           0.8 * (max (0., dot (vn, ltDir)))) + col4.a * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.));\n      } else col = col4.rgb;\n    }\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ut;\n  float el, az, zmFac, sr, ds, s, t;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  ut = abs (uv) - vec2 (1.33, 1.);\n  if (max (ut.x, ut.y) > 0.003) col = vec3 (0.82);\n  else {\n    dstFar = 60.;\n    ltDir = normalize (vec3 (1., 3., -1.));\n    ds = SmoothBump (0.2, 0.8, 0.1, mod (0.043 * tCur, 1.));\n    az = -0.07 * pi * (2. * floor (mod (0.043 * tCur + 0.5, 2.)) - 1.) * (1. - ds);\n    el = -0.01 * pi * (1. - ds);\n    if (mPtr.z > 0.) {\n      az += pi * mPtr.x;\n      el += 0.3 * pi * mPtr.y;\n    }\n    az = clamp (az, -0.4 * pi, 0.4 * pi);\n    vuMat = StdVuMat (clamp (el, -0.4 * pi, 0.01 * pi), az);\n    sSize = 0.55 * vec2 (1.33, 1.);\n    sMidHt = 1.26;\n    nRec = int ((1. - abs (2. * mod (0.1 * tCur, 1.) - 1.)) * float (nRecMax + 1));\n    zmFac = 12. * sSize.y * ds;\n    t = mod (0.3 * tCur, 2.);\n    s = sign (2. * floor (t) - 1.);\n    t = mod (t, 1.);\n    bPos = vec3 (1.5 * s * (0.5 - t), 0.2 + 8. * t * (1. - t), -5.);\n#if ! AA\n    const float naa = 1.;\n#else\n    const float naa = 3.;\n#endif  \n    col = vec3 (0.);\n    sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n    for (float a = float (VAR_ZERO); a < naa; a ++) {\n      col += (1. / naa) * ShowScene (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n         sr * (0.667 * a + 0.5) * pi), zmFac));\n    }\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\n/*\n Text derived from 8x12 Font shader by Flyguy (Mt2GWD)\n Glyph bitmaps generated from 8x12 font sheet\n   http://www.massmind.org/techref/datafile/charset/extractor/charset_extractor.htm\n*/\n\n#define g_spc  0\n#define g_exc  1\n#define g_quo  2\n#define g_hsh  3\n#define g_dol  4\n#define g_pct  5\n#define g_amp  6\n#define g_apo  7\n#define g_lbr  8\n#define g_rbr  9\n#define g_ast 10\n#define g_crs 11\n#define g_com 12\n#define g_dsh 13\n#define g_per 14\n#define g_lsl 15\n#define g_0   16\n#define g_1   17\n#define g_2   18\n#define g_3   19\n#define g_4   20\n#define g_5   21\n#define g_6   22\n#define g_7   23\n#define g_8   24\n#define g_9   25\n#define g_col 26\n#define g_scl 27\n#define g_les 28\n#define g_equ 29\n#define g_grt 30\n#define g_que 31\n#define g_ats 32\n#define g_A   33\n#define g_B   34\n#define g_C   35\n#define g_D   36\n#define g_E   37\n#define g_F   38\n#define g_G   39\n#define g_H   40\n#define g_I   41\n#define g_J   42\n#define g_K   43\n#define g_L   44\n#define g_M   45\n#define g_N   46\n#define g_O   47\n#define g_P   48\n#define g_Q   49\n#define g_R   50\n#define g_S   51\n#define g_T   52\n#define g_U   53\n#define g_V   54\n#define g_W   55\n#define g_X   56\n#define g_Y   57\n#define g_Z   58\n#define g_lsb 59\n#define g_rsl 60\n#define g_rsb 61\n#define g_pow 62\n#define g_usc 63\n#define g_a   64\n#define g_b   65\n#define g_c   66\n#define g_d   67\n#define g_e   68\n#define g_f   69\n#define g_g   70\n#define g_h   71\n#define g_i   72\n#define g_j   73\n#define g_k   74\n#define g_l   75\n#define g_m   76\n#define g_n   77\n#define g_o   78\n#define g_p   79\n#define g_q   80\n#define g_r   81\n#define g_s   82\n#define g_t   83\n#define g_u   84\n#define g_v   85\n#define g_w   86\n#define g_x   87\n#define g_y   88\n#define g_z   89\n#define g_lpa 90\n#define g_bar 91\n#define g_rpa 92\n#define g_tid 93\n#define g_lar 94\n\n#define C(g) s += PxChar (p, glph[g]);\n\n#define _spc C(g_spc)  \n#define _exc C(g_exc)\n#define _quo C(g_quo)\n#define _hsh C(g_hsh) \n#define _dol C(g_dol) \n#define _pct C(g_pct) \n#define _amp C(g_amp) \n#define _apo C(g_apo) \n#define _lbr C(g_lbr) \n#define _rbr C(g_rbr) \n#define _ast C(g_ast) \n#define _crs C(g_crs) \n#define _com C(g_com) \n#define _dsh C(g_dsh) \n#define _per C(g_per) \n#define _lsl C(g_lsl) \n#define _0   C(g_0) \n#define _1   C(g_1) \n#define _2   C(g_2) \n#define _3   C(g_3) \n#define _4   C(g_4) \n#define _5   C(g_5) \n#define _6   C(g_6) \n#define _7   C(g_7) \n#define _8   C(g_8) \n#define _9   C(g_9) \n#define _col C(g_col) \n#define _scl C(g_scl) \n#define _les C(g_les) \n#define _equ C(g_equ) \n#define _grt C(g_grt) \n#define _que C(g_que) \n#define _ats C(g_ats) \n#define _A   C(g_A) \n#define _B   C(g_B) \n#define _C   C(g_C) \n#define _D   C(g_D) \n#define _E   C(g_E) \n#define _F   C(g_F) \n#define _G   C(g_G) \n#define _H   C(g_H) \n#define _I   C(g_I) \n#define _J   C(g_J) \n#define _K   C(g_K) \n#define _L   C(g_L) \n#define _M   C(g_M) \n#define _N   C(g_N) \n#define _O   C(g_O) \n#define _P   C(g_P) \n#define _Q   C(g_Q) \n#define _R   C(g_R) \n#define _S   C(g_S) \n#define _T   C(g_T) \n#define _U   C(g_U) \n#define _V   C(g_V) \n#define _W   C(g_W) \n#define _X   C(g_X) \n#define _Y   C(g_Y) \n#define _Z   C(g_Z) \n#define _lsb C(g_lsb) \n#define _rsl C(g_rsl) \n#define _rsb C(g_rsb) \n#define _pow C(g_pow) \n#define _usc C(g_usc) \n#define _a   C(g_a) \n#define _b   C(g_b) \n#define _c   C(g_c) \n#define _d   C(g_d) \n#define _e   C(g_e) \n#define _f   C(g_f) \n#define _g   C(g_g) \n#define _h   C(g_h) \n#define _i   C(g_i) \n#define _j   C(g_j) \n#define _k   C(g_k) \n#define _l   C(g_l) \n#define _m   C(g_m) \n#define _n   C(g_n) \n#define _o   C(g_o) \n#define _p   C(g_p) \n#define _q   C(g_q) \n#define _r   C(g_r) \n#define _s   C(g_s) \n#define _t   C(g_t) \n#define _u   C(g_u) \n#define _v   C(g_v) \n#define _w   C(g_w) \n#define _x   C(g_x) \n#define _y   C(g_y) \n#define _z   C(g_z) \n#define _lpa C(g_lpa) \n#define _bar C(g_bar) \n#define _rpa C(g_rpa) \n#define _tid C(g_tid) \n#define _lar C(g_lar) \n\nvec4 glph[95];\nvec2 cPos;\n\nfloat PxChar (vec2 p, vec4 c)\n{\n  vec2 cb;\n  float pOn, b;\n  p = floor (p - cPos);\n  if (min (p.x, p.y) >= 0. && max (p.x - 8., p.y - 12.) < 0.) {\n    b = 8. * (p.y + 1.) - (p.x + 1.);\n    if (b < 48.) cb = (b < 24.) ? vec2 (c.w, b) : vec2 (c.z, b - 24.);\n    else cb = (b < 72.) ? vec2 (c.y, b - 48.) : vec2 (c.x, b - 72.);\n    pOn = mod (floor (cb.x / exp2 (cb.y)), 2.);\n  } else pOn = 0.;\n  cPos.x += cSpace.x;\n  return pOn;\n}\n\nvoid PxBgn (vec2 p)\n{\n  cPos = floor (p * cSpace);\n}\n\nfloat PxText (vec2 p, int txt)\n{\n  float s;\n  s = 0.;\n  if (txt == 0) {\n#if GURU\n    PxBgn (- vec2 (27., -1.));\n    _S _o _f _t _w _a _r _e _spc _F _a _i _l _u _r _e _per _spc _P _r _e _s _s _spc \n    _l _e _f _t _spc _m _o _u _s _e _spc _b _u _t _t _o _n _spc _t _o _spc \n    _c _o _n _t _i _n _u _e _per\n    PxBgn (- vec2 (17., 1.));\n    _G _u _r _u _spc _M _e _d _i _t _a _t _i _o _n _spc _hsh\n    _8 _2 _0 _1 _0 _0 _0 _3 _per _D _E _A _D _B _E _E _F\n    PxBgn (- vec2 (7., 5.));\n    _B _e _w _a _r _e _exc _spc _C _O _R _O _N _A _exc _exc \n#endif\n  } else if (txt == 1) {\n    PxBgn (- vec2 (2., 0.));\n    _A _M _I _G _A\n  } else if (txt == 2) {\n    PxBgn (- vec2 (4., 0.));\n    _C _o _m _m _o _d _o _r _e\n   }\n  return s;\n}\n\nvoid PxInit ()\n{\n  glph[g_spc] = vec4 (0x000000, 0x000000, 0x000000, 0x000000);\n  glph[g_exc] = vec4 (0x003078, 0x787830, 0x300030, 0x300000);\n  glph[g_quo] = vec4 (0x006666, 0x662400, 0x000000, 0x000000);\n  glph[g_hsh] = vec4 (0x006C6C, 0xFE6C6C, 0x6CFE6C, 0x6C0000);\n  glph[g_dol] = vec4 (0x30307C, 0xC0C078, 0x0C0CF8, 0x303000);\n  glph[g_pct] = vec4 (0x000000, 0xC4CC18, 0x3060CC, 0x8C0000);\n  glph[g_amp] = vec4 (0x0070D8, 0xD870FA, 0xDECCDC, 0x760000);\n  glph[g_apo] = vec4 (0x003030, 0x306000, 0x000000, 0x000000);\n  glph[g_lbr] = vec4 (0x000C18, 0x306060, 0x603018, 0x0C0000);\n  glph[g_rbr] = vec4 (0x006030, 0x180C0C, 0x0C1830, 0x600000);\n  glph[g_ast] = vec4 (0x000000, 0x663CFF, 0x3C6600, 0x000000);\n  glph[g_crs] = vec4 (0x000000, 0x18187E, 0x181800, 0x000000);\n  glph[g_com] = vec4 (0x000000, 0x000000, 0x000038, 0x386000);\n  glph[g_dsh] = vec4 (0x000000, 0x0000FE, 0x000000, 0x000000);\n  glph[g_per] = vec4 (0x000000, 0x000000, 0x000038, 0x380000);\n  glph[g_lsl] = vec4 (0x000002, 0x060C18, 0x3060C0, 0x800000);\n  glph[g_0]   = vec4 (0x007CC6, 0xD6D6D6, 0xD6D6C6, 0x7C0000);\n  glph[g_1]   = vec4 (0x001030, 0xF03030, 0x303030, 0xFC0000);\n  glph[g_2]   = vec4 (0x0078CC, 0xCC0C18, 0x3060CC, 0xFC0000);\n  glph[g_3]   = vec4 (0x0078CC, 0x0C0C38, 0x0C0CCC, 0x780000);\n  glph[g_4]   = vec4 (0x000C1C, 0x3C6CCC, 0xFE0C0C, 0x1E0000);\n  glph[g_5]   = vec4 (0x00FCC0, 0xC0C0F8, 0x0C0CCC, 0x780000);\n  glph[g_6]   = vec4 (0x003860, 0xC0C0F8, 0xCCCCCC, 0x780000);\n  glph[g_7]   = vec4 (0x00FEC6, 0xC6060C, 0x183030, 0x300000);\n  glph[g_8]   = vec4 (0x0078CC, 0xCCEC78, 0xDCCCCC, 0x780000);\n  glph[g_9]   = vec4 (0x0078CC, 0xCCCC7C, 0x181830, 0x700000);\n  glph[g_col] = vec4 (0x000000, 0x383800, 0x003838, 0x000000);\n  glph[g_scl] = vec4 (0x000000, 0x383800, 0x003838, 0x183000);\n  glph[g_les] = vec4 (0x000C18, 0x3060C0, 0x603018, 0x0C0000);\n  glph[g_equ] = vec4 (0x000000, 0x007E00, 0x7E0000, 0x000000);\n  glph[g_grt] = vec4 (0x006030, 0x180C06, 0x0C1830, 0x600000);\n  glph[g_que] = vec4 (0x0078CC, 0x0C1830, 0x300030, 0x300000);\n  glph[g_ats] = vec4 (0x007CC6, 0xC6DEDE, 0xDEC0C0, 0x7C0000);\n  glph[g_A]   = vec4 (0x003078, 0xCCCCCC, 0xFCCCCC, 0xCC0000);\n  glph[g_B]   = vec4 (0x00FC66, 0x66667C, 0x666666, 0xFC0000);\n  glph[g_C]   = vec4 (0x003C66, 0xC6C0C0, 0xC0C666, 0x3C0000);\n  glph[g_D]   = vec4 (0x00F86C, 0x666666, 0x66666C, 0xF80000);\n  glph[g_E]   = vec4 (0x00FE62, 0x60647C, 0x646062, 0xFE0000);\n  glph[g_F]   = vec4 (0x00FE66, 0x62647C, 0x646060, 0xF00000);\n  glph[g_G]   = vec4 (0x003C66, 0xC6C0C0, 0xCEC666, 0x3E0000);\n  glph[g_H]   = vec4 (0x00CCCC, 0xCCCCFC, 0xCCCCCC, 0xCC0000);\n  glph[g_I]   = vec4 (0x007830, 0x303030, 0x303030, 0x780000);\n  glph[g_J]   = vec4 (0x001E0C, 0x0C0C0C, 0xCCCCCC, 0x780000);\n  glph[g_K]   = vec4 (0x00E666, 0x6C6C78, 0x6C6C66, 0xE60000);\n  glph[g_L]   = vec4 (0x00F060, 0x606060, 0x626666, 0xFE0000);\n  glph[g_M]   = vec4 (0x00C6EE, 0xFEFED6, 0xC6C6C6, 0xC60000);\n  glph[g_N]   = vec4 (0x00C6C6, 0xE6F6FE, 0xDECEC6, 0xC60000);\n  glph[g_O]   = vec4 (0x00386C, 0xC6C6C6, 0xC6C66C, 0x380000);\n  glph[g_P]   = vec4 (0x00FC66, 0x66667C, 0x606060, 0xF00000);\n  glph[g_Q]   = vec4 (0x00386C, 0xC6C6C6, 0xCEDE7C, 0x0C1E00);\n  glph[g_R]   = vec4 (0x00FC66, 0x66667C, 0x6C6666, 0xE60000);\n  glph[g_S]   = vec4 (0x0078CC, 0xCCC070, 0x18CCCC, 0x780000);\n  glph[g_T]   = vec4 (0x00FCB4, 0x303030, 0x303030, 0x780000);\n  glph[g_U]   = vec4 (0x00CCCC, 0xCCCCCC, 0xCCCCCC, 0x780000);\n  glph[g_V]   = vec4 (0x00CCCC, 0xCCCCCC, 0xCCCC78, 0x300000);\n  glph[g_W]   = vec4 (0x00C6C6, 0xC6C6D6, 0xD66C6C, 0x6C0000);\n  glph[g_X]   = vec4 (0x00CCCC, 0xCC7830, 0x78CCCC, 0xCC0000);\n  glph[g_Y]   = vec4 (0x00CCCC, 0xCCCC78, 0x303030, 0x780000);\n  glph[g_Z]   = vec4 (0x00FECE, 0x981830, 0x6062C6, 0xFE0000);\n  glph[g_lsb] = vec4 (0x003C30, 0x303030, 0x303030, 0x3C0000);\n  glph[g_rsl] = vec4 (0x000080, 0xC06030, 0x180C06, 0x020000);\n  glph[g_rsb] = vec4 (0x003C0C, 0x0C0C0C, 0x0C0C0C, 0x3C0000);\n  glph[g_pow] = vec4 (0x10386C, 0xC60000, 0x000000, 0x000000);\n  glph[g_usc] = vec4 (0x000000, 0x000000, 0x000000, 0x00FF00);\n  glph[g_a]   = vec4 (0x000000, 0x00780C, 0x7CCCCC, 0x760000);\n  glph[g_b]   = vec4 (0x00E060, 0x607C66, 0x666666, 0xDC0000);\n  glph[g_c]   = vec4 (0x000000, 0x0078CC, 0xC0C0CC, 0x780000);\n  glph[g_d]   = vec4 (0x001C0C, 0x0C7CCC, 0xCCCCCC, 0x760000);\n  glph[g_e]   = vec4 (0x000000, 0x0078CC, 0xFCC0CC, 0x780000);\n  glph[g_f]   = vec4 (0x00386C, 0x6060F8, 0x606060, 0xF00000);\n  glph[g_g]   = vec4 (0x000000, 0x0076CC, 0xCCCC7C, 0x0CCC78);\n  glph[g_h]   = vec4 (0x00E060, 0x606C76, 0x666666, 0xE60000);\n  glph[g_i]   = vec4 (0x001818, 0x007818, 0x181818, 0x7E0000);\n  glph[g_j]   = vec4 (0x000C0C, 0x003C0C, 0x0C0C0C, 0xCCCC78);\n  glph[g_k]   = vec4 (0x00E060, 0x60666C, 0x786C66, 0xE60000);\n  glph[g_l]   = vec4 (0x007818, 0x181818, 0x181818, 0x7E0000);\n  glph[g_m]   = vec4 (0x000000, 0x00FCD6, 0xD6D6D6, 0xC60000);\n  glph[g_n]   = vec4 (0x000000, 0x00F8CC, 0xCCCCCC, 0xCC0000);\n  glph[g_o]   = vec4 (0x000000, 0x0078CC, 0xCCCCCC, 0x780000);\n  glph[g_p]   = vec4 (0x000000, 0x00DC66, 0x666666, 0x7C60F0);\n  glph[g_q]   = vec4 (0x000000, 0x0076CC, 0xCCCCCC, 0x7C0C1E);\n  glph[g_r]   = vec4 (0x000000, 0x00EC6E, 0x766060, 0xF00000);\n  glph[g_s]   = vec4 (0x000000, 0x0078CC, 0x6018CC, 0x780000);\n  glph[g_t]   = vec4 (0x000020, 0x60FC60, 0x60606C, 0x380000);\n  glph[g_u]   = vec4 (0x000000, 0x00CCCC, 0xCCCCCC, 0x760000);\n  glph[g_v]   = vec4 (0x000000, 0x00CCCC, 0xCCCC78, 0x300000);\n  glph[g_w]   = vec4 (0x000000, 0x00C6C6, 0xD6D66C, 0x6C0000);\n  glph[g_x]   = vec4 (0x000000, 0x00C66C, 0x38386C, 0xC60000);\n  glph[g_y]   = vec4 (0x000000, 0x006666, 0x66663C, 0x0C18F0);\n  glph[g_z]   = vec4 (0x000000, 0x00FC8C, 0x1860C4, 0xFC0000);\n  glph[g_lpa] = vec4 (0x001C30, 0x3060C0, 0x603030, 0x1C0000);\n  glph[g_bar] = vec4 (0x001818, 0x181800, 0x181818, 0x180000);\n  glph[g_rpa] = vec4 (0x00E030, 0x30180C, 0x183030, 0xE00000);\n  glph[g_tid] = vec4 (0x0073DA, 0xCE0000, 0x000000, 0x000000);\n  glph[g_lar] = vec4 (0x000000, 0x10386C, 0xC6C6FE, 0x000000);\n  cSpace = vec2 (8., 13.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsfyDs.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1041, 1041, 1063, 1063, 2698], [2700, 2700, 2733, 2733, 2916], [2918, 2918, 2939, 2939, 3194], [3196, 3196, 3228, 3228, 3431], [3433, 3433, 3464, 3464, 3836], [3838, 3838, 3864, 3864, 7283], [7285, 7285, 7341, 7341, 8882], [8884, 8884, 8916, 8916, 9016], [9018, 9018, 9064, 9064, 9111], [9113, 9113, 9160, 9160, 9207], [9209, 9209, 9242, 9242, 9269], [9271, 9271, 9313, 9313, 9364], [9366, 9366, 9402, 9402, 9608], [9610, 9610, 9640, 9640, 9753], [9755, 9755, 9812, 9812, 9895], [9929, 9929, 9953, 9953, 10065], [10067, 10067, 10092, 10092, 10278], [10280, 10280, 10301, 10301, 10456], [10458, 10458, 10487, 10487, 10699], [10701, 10701, 10740, 10740, 10920], [14858, 14858, 14889, 14889, 15287], [15289, 15289, 15310, 15310, 15341], [16072, 16072, 16088, 16088, 22102]], "test": "error"}
{"id": "WsjcDw", "name": "additiveBlob", "author": "nodewendig", "description": "colorful deformations", "tags": ["additive"], "likes": 1, "viewed": 59, "published": "Public", "date": "1586772965", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-iResolution.xy*0.5)/iResolution.y;\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    col = vec3(0.,0.,0.);\n\t\n\tfloat rad = length(uv);\n\tfloat a = atan(uv.y, uv.x);\n\tfloat bound = 0.7;\n\tfloat circle = smoothstep(bound, bound-0.01, rad);\n    float strength = 1.-((sin(iTime) + 1.) * 0.005);\n    \n\tfloat blobmaskr = mix(cos(a*2.)+sin(a+iTime), 1.-rad, strength);\n\tfloat blobr = smoothstep(bound, bound+0.001, blobmaskr);\n\t\n\tfloat blobmaskg = mix(sin(a*2.)+cos(a+iTime-0.3), 1.-rad, strength);\n\tfloat blobg = smoothstep(bound, bound+0.001, blobmaskg);\n\t\n\tfloat blobmaskb = mix(cos(a*2.)-sin(a+iTime-0.7), 1.-rad, strength);\n\tfloat blobb = smoothstep(bound, bound+0.001, blobmaskb);\n\t\n\tcol = vec3(blobr,blobg,blobb);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsjcDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 845]], "test": "valid"}
{"id": "WsjcWw", "name": "3d Mandelbrot", "author": "themasmo", "description": "A fractal carved in 3d.\nUnfortunately I am not able to remove imperfections on the edges. Sorry", "tags": ["fractal", "mandelbrot", "light", "frattali"], "likes": 1, "viewed": 133, "published": "Public", "date": "1586770180", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"ShaderToy Tutorial - Ray Marching for Dummies!\" \n// by Martijn Steinrucken aka BigWings/CountFrolic - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// This shader is part of a tutorial on YouTube\n// https://youtu.be/PGtv-dBi2wE\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n#define MAXITE 32.0\n\nmat3 rotx(float a) { mat3 rot; rot[0] = vec3(1.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 1.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\n\nfloat rnd(vec2 n){\n  return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat mandel(vec2 p)\n{    \n    float zre=0.; //sin(iTime)/4.0;\n    float zim=0.; //cos(iTime)/3.0;\n    float cre=p.x;\n    float cim=p.y;\n    float col=0.;\n\n    for(float i=0.;i<MAXITE;i++)\n    {\n        float dam=zre*zre-zim*zim+cre;\n        zim=2.0*zre*zim+cim;\n        zre=dam;\n        col++;\n        if( (zre*zre+zim*zim)>4.0 )\n            break;\n    }\n    \n    return (col/MAXITE);\n}\n\n\nfloat GetDist(vec3 p) {\n    float v=mandel(p.xz/6.0);\n\tvec4 s1 = vec4(p.x,-v,p.z,0.5);\n  \n    float sphereDist1 =  length(p-s1.xyz)-s1.w;\n    float planeDist = p.y;\n    \n    float d = min(sphereDist1, planeDist);\n    return d;    \n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        \n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 6, 2);\n    //lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n   // float d = RayMarch(p+n*SURF_DIST*2., l);\n    //if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(-2., 6, -7.5);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n\n    ro = ro*(rotx(-0.4));\n    ro.x=-2.0+4.0*cos(iTime/2.0);\n    ro.z=-7.0+5.0*sin(iTime/1.5);\n    float d = RayMarch(ro, rd);\n\n    vec3 p = ro + rd * d;\n\n    float dif = GetLight(p);\n    col = vec3(dif);\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsjcWw.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[369, 369, 389, 389, 516], [517, 517, 537, 537, 664], [666, 666, 684, 684, 751], [753, 753, 775, 775, 1140], [1143, 1143, 1166, 1166, 1375], [1377, 1377, 1411, 1411, 1626], [1628, 1628, 1652, 1652, 1841], [1843, 1843, 1867, 1867, 2178], [2180, 2180, 2237, 2237, 2648]], "test": "valid"}
{"id": "wsjcWy", "name": "Purple Wallpaper Study", "author": "D4v1D", "description": "a little study on sines, tan and tanh, cos and cosh\n", "tags": ["study", "purple", "wallpaper"], "likes": 0, "viewed": 43, "published": "Public", "date": "1587307846", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// inspired by https://www.shadertoy.com/view/MdlXz8\n\n#define TAU 30.3\n#define MAX_ITER 4\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tfloat time = iTime*1.0;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 p = uv*TAU;\n    \n   \tvec2 i = vec2(p);\n\tfloat c = 1.;\n\tfloat intensity = 0.01;\n\n\tfor (int n = 1; n < MAX_ITER; n++) \n\t{\n\t\tfloat t = time * (1./(float(n+1)));\n       i = p + vec2(sin(time - i.y)* tan(t - i.x),sin(t - i.x)-tanh(t * i.xy))-(TAU*tanh(sin(time)*intensity),time);\n\t\tc -= 1./length(vec2(abs(tan(i.x+t)/intensity),p.y / (cosh(i.y-t)/intensity)));\n\t}\n\tc /= float(MAX_ITER);\n\tc = 1.0-(pow(c, 2.4));\n\tvec3 colour = vec3(pow((c),50.0));\n    colour = clamp(colour + vec3(0.3, 0.0, .3), 0.0, 1.0);\n\t\n    fragColor = vec4(colour, 1.0);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsjcWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "valid"}
{"id": "WsjczW", "name": "Layers of Shapes", "author": "Passion", "description": "Layers of shapes. Click to see grid", "tags": ["2d", "spiral", "layers"], "likes": 5, "viewed": 137, "published": "Public", "date": "1586211911", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Layers of Shapes\n// Timothy Michael Walsh\n// 2020\n\n#define NUM_LAYERS 7.0\n#define PI acos(-1.0)\n#define PI_2 PI*2.0\n\nmat2 rot(float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(s,-c,c,s);\n}\n\nfloat rnd(vec2 uv){\n    return fract(sin(uv.x+uv.y*7876.78)*97687.78);   //-iTime/800.\n}\n\nfloat pattern(vec2 uv, inout vec4 rColor, inout float grd){\n    \n    uv*=0.75;\n    \n    vec2 id = floor(uv);\n    float rr = fract(sin(id.y*768.67)*7868.89)*1.3;\n    uv.x += rr;\n    //uv.x += (rr > .49) ? sin(3.0*iTime*fract(rr*rr)) : sin(3.0*-iTime*rr);\n    \n    id = floor(uv);\n    vec2 gv = fract(uv)-.5;\n    grd = step(.468,gv.x) + step(.468,gv.y);\n    \n    \n    float rand =  fract(sin(id.x+id.y * 768.65) *7868.78);\n    float rand2 = fract(sin(id.x * 768.65) *7868.78);\n    \n    float spin = rand<.49 ? -1.0 : 1.0;\n    \n    gv *= rot(spin*fract(rand+rand+14.8)*iTime*5.0);\n    \n    //rColor += vec4(rand2, fract(id.x*76.56), fract(rand2+rand2), rand2);\n    rColor = vec4(rnd(id), rnd(id+234.56), rnd(id*67.67), rnd(id));\n    \n    rand *= 4.0;\n    rand += 3.0;\n    \n    int num = int(rand); // 3;\n    float angle = atan(gv.x,gv.y)+PI;\n    float radius = PI_2/float(num);\n    float shape = cos(floor(.5+angle/radius) * radius - angle) * length(gv);\n        \n    shape = smoothstep(.13,.1, shape);\n    return shape;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * (fragCoord/iResolution.xy-.5));\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 id = floor(uv);\n\tvec4 rColor = vec4(0.0);\n    vec4 col = vec4(0.0);\n    float grd = 0.0;\n    float uvy = uv.y;\n        \n    for(float i = 0.0; i<1.; i+=1.0/NUM_LAYERS){\n        float depth = fract(i+(iTime*.35));\n        float scale = mix(25., .15, depth);\n        uv *= rot(fract(sin(i))+sin(iTime*.5)*2.);\n        float d = pattern(uv*scale+i*564., rColor, grd);\n        float fade = (depth*smoothstep(.3,.99,depth));\n        //col += mix(col, rColor, d)*fade;  //pattern(uv)  vec4(r, r1, r2, 1.0)\n        col += rColor*d*fade;\n        col.rgb += iMouse.z>0.1 ? grd*fade : 0.0;\n    }\n\t\n    fragColor = col;   //vec4(col,1.0)*pattern(uv);\n    fragColor = (abs(uvy)<.95) ? fragColor : vec4(1.0);\n    \n}\n", "image_inputs": [{"id": "4lBGD1", "previewfilepath": "https://soundcloud.com/k-maaz-ali/deadmau5-october", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/k-maaz-ali/deadmau5-october", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsjczW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[120, 120, 138, 138, 211], [213, 213, 232, 232, 301], [303, 303, 362, 362, 1322], [1325, 1325, 1382, 1382, 2190]], "test": "valid"}
{"id": "wsjyDd", "name": "Chessstyle", "author": "PoetLuchnik", "description": "Black or white cells", "tags": ["chess"], "likes": 0, "viewed": 189, "published": "Public API", "date": "1587557386", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    float t = (1.1 + sin(iTime * 0.5)) * 2.0;\n    vec2 cellSize = vec2(t / 16.0, t / 9.0);\n    //Cell coords:\n    vec2 cell = vec2( int(uv.x / cellSize.x), int(uv.y / cellSize.y) );\n    \n    bool isWhite = false;\n    \n    if(int(cell.x) % 2 == 0)\n        isWhite = true;\n    \n    if(int(cell.y) % 2 == 0)\n        isWhite = !isWhite;\n    \n    if(isWhite)\n        fragColor = vec4(0.9, 0.9, 1, 1);\n    else\n        fragColor = vec4(0.1, 0.1, 0, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsjyDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 548]], "test": "valid"}
{"id": "WsjyDh", "name": "mandelbulb--derivate---v7", "author": "jorge2017a1", "description": "///Original por IQ --> https://www.shadertoy.com/view/ltfSWn", "tags": ["mandelbulbderivatev7"], "likes": 4, "viewed": 111, "published": "Public", "date": "1586550597", "time_retrieved": "2021-10-01T00:00:00", "image_code": "///Original por IQ --> https://www.shadertoy.com/view/ltfSWn\n// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// The source code for these videos from 2009: \n// https://www.youtube.com/watch?v=eKUh4nkmQbc\n// https://www.youtube.com/watch?v=erS6SKqtXLY\n\n// More info here: http://iquilezles.org/www/articles/mandelbulb/mandelbulb.htm\n\n// See https://www.shadertoy.com/view/MdfGRr to see the Julia counterpart\n\n\n///---------------------------------------\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\n//Box function\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n///-----------------------------\n\n\n\n\nvec2 isphere( in vec4 sph, in vec3 ro, in vec3 rd )\n{\n    vec3 oc = ro - sph.xyz;\n    \n\tfloat b = dot(oc,rd);\n\tfloat c = dot(oc,oc) - sph.w*sph.w;\n    float h = b*b - c;\n    \n    if( h<0.0 ) return vec2(-1.0);\n\n    h = sqrt( h );\n\n    return -b + vec2(-h,h);\n}\n\n#define ZERO (min(iFrame,0))\n\n\nfloat map( in vec3 p, out vec4 resColor )\n{\n    vec3 w = p;\n    float m = dot(w,w);\n\n    vec4 trap = vec4(abs(w),m);\n\tfloat dz = 1.0;\n    \n    \n\tfor( int i=0; i<4; i++ )\n    {\n        dz = 8.0*pow(sqrt(m),7.0)*dz + 1.0;\n\t\t//dz = 8.0*pow(m,3.5)*dz + 1.0;\n        \n        float r = length(w);\n        float b = 8.0*acos( w.y/r);\n        float a = 8.0*atan( w.x, w.z );\n        w = p + pow(r,8.0) * vec3( sin(b)*sin(a), cos(b), sin(b)*cos(a) );\n\n        \n        trap = min( trap, vec4(abs(w),m) );\n\n        m = dot(w,w);\n\t\tif( m > 256.0 )\n            break;\n    }\n\n    resColor = vec4(m,trap.yzw);\n\n    \n\n    float fra =0.25*log(m)*sqrt(m)/dz;\n    \n    \n    float sdb1 =sdBox(p- vec3(0.0), vec3(0.75) );\n    \n    float res=999.9 ;\n    \n    float dif1= differenceSDF(sdb1,fra) ;\n    \n    res=min(res,dif1);\n    return res;\n    \n}\n\nfloat intersect( in vec3 ro, in vec3 rd, out vec4 rescol, in float px )\n{\n    float res = -1.0;\n\n    // bounding sphere\n    vec2 dis = isphere( vec4(0.0,0.0,0.0,1.25), ro, rd );\n    if( dis.y<0.0 )\n        return -1.0;\n    dis.x = max( dis.x, 0.0 );\n    dis.y = min( dis.y, 10.0 );\n\n    // raymarch fractal distance field\n\tvec4 trap;\n\n\tfloat t = dis.x;\n\tfor( int i=0; i<128; i++  )\n    { \n        vec3 pos = ro + rd*t;\n        float th = 0.25*px*t;\n\t\tfloat h = map( pos, trap );\n\t\tif( t>dis.y || h<th ) break;\n        t += h;\n    }\n    \n    \n    if( t<dis.y )\n    {\n        rescol = trap;\n        res = t;\n    }\n\n    return res;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float k )\n{\n    float res = 1.0;\n    float t = 0.0;\n    for( int i=0; i<64; i++ )\n    {\n        vec4 kk;\n        float h = map(ro + rd*t, kk);\n        res = min( res, k*h/t );\n        if( res<0.001 ) break;\n        t += clamp( h, 0.01, 0.2 );\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos, in float t, in float px )\n{\n    vec4 tmp;\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.25*px;\n    return normalize( e.xyy*map( pos + e.xyy,tmp ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx,tmp ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy,tmp ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx,tmp ) );\n}\n\nconst vec3 light1 = vec3(  0.577, 0.577, -0.577 );\nconst vec3 light2 = vec3( -0.707, 0.000,  0.707 );\n\n\nvec3 render( in vec2 p, in mat4 cam )\n{\n\t// ray setup\n    const float fle = 1.5;\n\n    vec2  sp = (2.0*p-iResolution.xy) / iResolution.y;\n    float px = 2.0/(iResolution.y*fle);\n\n    vec3  ro = vec3( cam[0].w, cam[1].w, cam[2].w );\n\tvec3  rd = normalize( (cam*vec4(sp,fle,0.0)).xyz );\n\n    // intersect fractal\n\tvec4 tra;\n    float t = intersect( ro, rd, tra, px );\n    \n\tvec3 col;\n\n    // color sky\n    if( t<0.0 )\n    {\n     \tcol  = vec3(0.8,.9,1.1)*(0.6+0.4*rd.y);\n\t\tcol += 5.0*vec3(0.8,0.7,0.5)*pow( clamp(dot(rd,light1),0.0,1.0), 32.0 );\n\t}\n    // color fractal\n\telse\n\t{\n        // color\n        col = vec3(0.01);\n\t\tcol = mix( col, vec3(0.30,0.20,0.30), clamp(tra.y,0.0,1.0) );\n\t \tcol = mix( col, vec3(0.2,0.10,0.30), clamp(tra.z*tra.z,0.0,1.0) );\n        col = mix( col, vec3(0.30,0.10,0.62), clamp(pow(tra.w*0.5,6.0),0.0,1.0) );\n        \n        \n        col *= 0.5;\n\t\t//col = vec3(0.1);\n        \n        // lighting terms\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, t, px );\n        vec3 hal = normalize( light1-rd);\n        vec3 ref = reflect( rd, nor );\n        float occ = clamp(0.05*log(tra.x),0.0,1.0);\n        float fac = clamp(1.0+dot(rd,nor),0.0,1.0);\n\n        // sun\n        float sha1 = softshadow( pos+0.001*nor, light1, 32.0 );\n        float dif1 = clamp( dot( light1, nor ), 0.0, 1.0 )*sha1;\n        float spe1 = pow( clamp(dot(nor,hal),0.0,1.0), 32.0 )*dif1*(0.04+0.96*pow(clamp(1.0-dot(hal,light1),0.0,1.0),5.0));\n        // bounce\n        float dif2 = clamp( 0.5 + 0.5*dot( light2, nor ), 0.0, 1.0 )*occ;\n        // sky\n        float dif3 = (1.0+0.3*nor.y)*(0.2+0.8*occ);\n        \n\t\tvec3 lin = vec3(0.0); \n\t\t     lin += 7.0*vec3(1.50,1.10,0.70)*dif1;\n\t\t     lin += 4.0*vec3(0.25,0.20,0.15)*dif2;\n        \t lin += 1.5*vec3(0.10,0.20,0.30)*dif3;\n             lin += 2.5*vec3(0.35,0.30,0.25)*(0.05+0.95*occ); // ambient\n        \t lin += 4.0*fac*occ;                          // fake SSS\n\t\tcol *= lin;\n\t\tcol = pow( col, vec3(0.7,0.9,1.0) );                  // fake SSS\n        col += spe1*15.0;\n        //col += 8.0*vec3(0.8,0.9,1.0)*(0.2+0.8*occ)*(0.03+0.97*pow(fac,5.0))*smoothstep(0.0,0.1,ref.y )*softshadow( pos+0.01*nor, ref, 2.0 );\n        //col = vec3(occ*occ);\n    }\n\n    // gamma\n\tcol = sqrt( col );\n    \n    // vignette\n    col *= 1.0 - 0.05*length(sp);\n\n    return col;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime*.5;\n\n    // camera\n\tfloat di = 1.4+0.1*cos(.29*time);\n\tvec3  ro = di * vec3( cos(.33*time), 0.8*sin(.37*time), sin(.31*time) );\n\tvec3  ta = vec3(0.0,0.1,0.0);\n\tfloat cr = 0.5*cos(0.1*time);\n\n    // camera matrix\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cw = normalize(ta-ro);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv =          (cross(cu,cw));\n    mat4 cam = mat4( cu, ro.x, cv, ro.y, cw, ro.z, 0.0, 0.0, 0.0, 1.0 );\n\n\tvec3 col = render(  fragCoord, cam );\n    \n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsjyDh.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[530, 530, 565, 565, 589], [592, 607, 638, 638, 788], [791, 791, 839, 839, 872], [911, 911, 964, 964, 1171], [1204, 1204, 1247, 1247, 2031], [2033, 2033, 2106, 2106, 2663], [2665, 2665, 2721, 2721, 2995], [2997, 2997, 3054, 3054, 3285], [3391, 3391, 3430, 3444, 5715], [5721, 5721, 5778, 5778, 6307]], "test": "valid"}
{"id": "wsjyDK", "name": "simple 2d distance functions", "author": "benhardy", "description": "just an experiment with distance functions in 2d, will be using in a tutorial on raymarching as a preface to showing it in 3d", "tags": ["2d", "sdf"], "likes": 2, "viewed": 175, "published": "Public", "date": "1587372364", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926536\n\nfloat d_circle(vec2 point, vec2 center, float radius) {\n    return length(point - center) - radius;\n}\n\nfloat d_box(vec2 point, vec2 size, float rounding) {\n    return length(max(vec2(0.0),abs(point) - size)) - rounding;\n}\n\nvec2 radial_symmetry(vec2 point, float ways) {\n    vec2 prad = vec2(length(point), atan(point.x, point.y) + PI);\n    prad.y = mod(prad.y, PI*2.0/ways) - PI/ways;\n    return prad.x*vec2(cos(prad.y), sin(prad.y));\n}\n\nvec2 rotate(vec2 point, float angle) {\n    return vec2(point.x * cos(angle) + point.y * sin(angle),\n                point.x * sin(angle) - point.y * cos(angle));\n}\n\nvec3 color_rings(float d) {\n    float level = floor(d) / 5.0;\n    if (fract(d) < 0.1 && d<=5.2) {\n        return vec3(level) * 0.75;\n    } else {\n        return vec3(level) * 0.5 + 0.5;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float range = 30.0;\n    \n    vec2 point  = (fragCoord/iResolution.xy - vec2(0.5,0.5))\n        * vec2(1.0, iResolution.y / iResolution.x) * range\n        ;\n    vec2 cpoint = radial_symmetry(point, 5.0);\n    \n    vec2 center = vec2(5,0);\n    float circ = d_circle(cpoint, center, 2.0);\n    vec2 boxp = rotate(point, iTime*0.2) + \n        vec2(8.0*sin(iTime*0.19), 7.0*cos(iTime*0.17));\n    float box = d_box(boxp, vec2(6, 1.2), 0.10);\n//    float bevel = (box + circ) -0.5;\n    float cornerbit = max(box,circ) - 0.5;\n    float d = min(min(box,circ), cornerbit);\n    // Time varying pixel color\n    vec3 col = vec3(1);\n    if (d < 0.0) {\n        col = vec3(0.7,0.2,0.2);\n    } else {\n        col = color_rings(d);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsjyDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 80, 80, 126], [128, 128, 180, 180, 246], [248, 248, 294, 294, 461], [463, 463, 501, 501, 626], [628, 628, 655, 655, 821], [823, 823, 880, 880, 1659]], "test": "valid"}
{"id": "WsjyDw", "name": "simple outlined hexes", "author": "manthrax", "description": "draw an outlined hex with size, line thickness, blending,", "tags": ["hex"], "likes": 1, "viewed": 64, "published": "Public", "date": "1586770606", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SQRT3 1.7320508\n\nconst vec2 s = vec2(1.0, SQRT3);\nconst vec2 ax0=vec2( .0  ,1.);\nconst vec2 ax1=vec2(-.866, .5);\nconst vec2 ax2=vec2( .866, .5);\n\nvec4 getHex(vec2 p){\n    //return xy = square 0-1 coords\n    vec4 hC = floor(vec4(p, p - vec2(.5, 1))/s.xyxy) + .5;\n    vec4 h = vec4(p - hC.xy*s, p - (hC.zw + .5)*s);\n    return dot(h.xy, h.xy)<dot(h.zw, h.zw) ? vec4(h.xy, hC.xy) : vec4(h.zw, hC.zw + 9.73);\n}\n\nfloat distToNearestHexEdge(vec2 hv){\n    vec3 adist = abs(vec3(dot(hv,ax0),dot(hv,ax1),dot(hv,ax2)));\n    return 1.-(max(max(adist.x,adist.y),adist.z)*2.);\n}\n\nvec4 hexOutline(vec2 uv,float hexSize,float lineSize,float lineBlend){\n\tvec4 hex = getHex(uv/hexSize);\n    //fragColor = vec4(abs(h.xy-.5), 0.,1.);\n    float dist = distToNearestHexEdge(hex.yx);\n    float linePower = smoothstep(lineSize,lineSize+lineBlend,dist);\n    //fragColor=vec4(mix(1.,0.,linePower));\n    hex.z = linePower;\n\treturn hex;\n}\n\nfloat hexsz(){\n    return (fract(iTime*.01)*0.5)+.1;\n}\n\nvec4 hexfn(in vec2 fragCoord){\n\tfloat hexSize = hexsz();\n    float lineSize = .02;\n    float lineBlend = .02;\n    vec2 uv = (fragCoord /iResolution.xx).yx;\n    vec4 hex = hexOutline(uv,hexSize,lineSize,lineBlend);\n    float linePower = hex.z;\n    return mix(texture(iChannel0,hex.xy),vec4(1.),1.-linePower);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nfloat hexSize = hexsz();\n    float ksz = hexSize*.1;\n    fragColor = hexfn(fragCoord);\n    \n    /*fragColor = (   // \"antialising\"\n        (hexfn(fragCoord)\t\t\t\t *4.)+\n        (hexfn(fragCoord+vec2(-ksz,   0))*2.)+\n        (hexfn(fragCoord+vec2( ksz,   0))*2.)+\n        (hexfn(fragCoord+vec2(   0,-ksz))*2.)+\n        (hexfn(fragCoord+vec2(   0, ksz))*2.)+\n\n        hexfn(fragCoord+vec2(-ksz, -ksz))+\n        hexfn(fragCoord+vec2( ksz, -ksz))+\n        hexfn(fragCoord+vec2( ksz,  ksz))+\n        hexfn(fragCoord+vec2(-ksz,  ksz))\n\t) * (1./16.);*/\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsjyDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[154, 154, 174, 210, 414], [416, 416, 452, 452, 573], [575, 575, 645, 645, 919], [921, 921, 935, 935, 975], [977, 977, 1007, 1007, 1286], [1288, 1288, 1345, 1345, 1891]], "test": "error"}
{"id": "wsjyRw", "name": "Sine Question", "author": "xXpro_campr_pro_scopeXx", "description": "I'm looking for ideas to shade 32 to of them (8 per row) with different frequencies. My plan is to copy this code 32 times and then change the smoothstep coordinats and frequencies of each copy. But I know this would be not elegant.", "tags": ["question"], "likes": 2, "viewed": 78, "published": "Public", "date": "1586352100", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//modified shader of https://www.shadertoy.com/view/ltX3zs\n\n#define f1 1.\n#define f2 50.\n#define f3 3.\n#define f4 7.\n#define f5 1000.\n#define f6 11.\n#define f7 100.\n#define f8 80.\n#define f9 19.\n#define f10 11.\n#define f11 12.\n#define f12 150.\n#define f13 99.\n#define f14 40.\n#define f15 1.\n#define f16 10.\n#define f17 2.\n#define f18 10.\n#define f19 12.\n#define f20 100.\n#define f21 1000.\n#define f22 400.\n#define f23 210.\n#define f24 112.\n#define f25 113.\n#define f26 131.\n#define f27 1300.\n#define f28 110.\n#define f29 1139.\n#define f30 1108.\n#define f31 1313.\n#define f32 1431.\n\n\nfloat sine_freq(vec2 uv)\n{   \n    float row = floor(uv.y*32.);\n    float y = fract(uv.y*32.);\n\n    float time = uv.x + iTime;\n    float sine = sin(3.1415926* time);\n    float r = sine;\n    return r;\n}\n\nfloat plot(vec2 uv, float pct)\n{\n    float k1 = 0.; \n    float k2 = 0.;\n    uv.y *= 4.;\n\n    float center_pos = 0.0;\n\n    if (uv.x >= -0.9 && uv.x <= .9)\n    {\n        k1 = smoothstep(12./iResolution.y,0., abs(uv.y-pct));\n    }\n\n    return k1;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = ( 2.*fragCoord.xy - iResolution.xy ) / iResolution.y;\n    float s = sine_freq(uv.xy);\n\tfragColor =  vec4(43.*plot(uv,s));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsjyRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[583, 583, 609, 609, 783], [785, 785, 817, 817, 1030], [1033, 1033, 1088, 1088, 1226]], "test": "valid"}
{"id": "WsjyRz", "name": "Lights in the Sky", "author": "Roninkoi", "description": "Raymarching experiments", "tags": ["raymarching", "glow"], "likes": 4, "viewed": 252, "published": "Public API", "date": "1585977963", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265\n#define MAXIT 128\n#define EPSILON 0.001\n \n#define minx4(a, b) ((a.w) < (b.w) ? (a) : (b))\n#define minx2(a, b) ((a.x) < (b.x) ? (a) : (b))\n \n#define MAT0 0.0\n#define MAT1 1.0\n \nmat3 rotX(float a)\n{\n    return mat3(\n        1., 0., 0.,\n        0., cos(a), -sin(a),\n        0., sin(a), cos(a)\n    );\n}\n \nmat3 rotY(float a)\n{\n    return mat3(\n        cos(a), 0.0, -sin(a),\n        0., 1., 0.,\n        sin(a), 0.0, cos(a)\n    );\n}\n \nmat3 rotZ(float a)\n{\n    return mat3(\n        cos(a), -sin(a), 0.,\n        sin(a), cos(a), 0.,\n        0., 0., 1.\n    );\n}\n \nfloat t;\n \nfloat sphere(vec3 r, float a)\n{\n    return length(r) - a;\n}\n \nfloat torus(vec3 r, vec2 a)\n{\n    a.y += sin(length(r.xy + t) * 7.) * 0.09;\n    vec2 p = vec2(length(r.xz) - a.x, r.y);\n    return length(p) - a.y;\n}\n \nfloat plane(vec3 r, vec3 o, vec3 n) {\n    return dot(r - o, n);\n}\n \nfloat box(vec3 r, vec3 a)\n{\n    vec3 p = abs(r) - a;\n    return length(max(p - p.x * 0.4 - p.y * 0.4, 0.)) + min(max(p.x - p.y * 0.5, max(p.y, p.z) - p.x * 0.3), 0.);\n}\n \nfloat shade(vec3 n, vec3 rd)\n{\n    return clamp(max(dot(n, -rd), 0.) + 1., 0., 1.);\n}\n \nvec3 fog(float z, vec3 col, vec3 fogCol)\n{\n    return mix(fogCol, col, exp(-z));\n}\n \nmat3 obj;\n \nvec2 map(vec3 r)\n{\n    obj = rotZ((-t + r.z * 0.2) * 0.3) * rotY(1. * t);\n   \n    vec2 b1 = vec2(\n        box(obj * obj * (r) + vec3(0., sin(2. * t) * 1., 0.), vec3(.75, .5, .5)),\n        MAT0\n    );\n   \n    vec2 t1 = vec2(\n        torus(- obj *r, vec2(2.0, 0.1)),\n        MAT1\n    );\n   \n    return minx2(b1, t1);\n}\n \nfloat hash(vec2 r) {\n    return fract(sin(dot(r, vec2(15.5921, 96.654654))) * 23626.3663);\n}\n \nvec3 matCol(vec2 o)\n{\n    if (o.y == MAT0)\n        return normalize(vec3(1., 0.5, .0));\n   \n    if (o.y == MAT1)\n        return normalize(vec3(0., 1.7, 0.0));\n   \n    return vec3(0.);\n}\n \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    t = iTime;\n   \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n   \n    mat3 cam = rotY(t * 0. - PI);\n       \n    vec3 ro = vec3(0., 0., -3.0);\n    vec3 rd = cam * normalize(vec3(uv * 2., -1.));\n    vec3 r = ro;\n   \n    vec3 bcol = normalize((vec3(1., 0., 1.0) + 0.5) * (uv.y + 0.3) * (sin(t) + 1.) * 1.5 + vec3(0., 0.5, 1.0)) * 1.5 + 0.4;\n    vec4 col = vec4(0.);\n    col.rgb = bcol;\n   \n    vec2 c = vec2(10000., MAT0);\n   \n    float sh = 1.;\n   \n    float glow = 0.;\n   \n    vec3 gcol = bcol;\n   \n    for (int i = 0; i < MAXIT; ++i) {\n        vec2 d = map(r);\n        float z = length(r - ro);\n       \n        glow += exp(-d.x * 5.);\n        gcol += matCol(d) * exp(-d.x * 1.);\n       \n        if (d.x < EPSILON) {\n            col.rgb = mix(col.rgb, matCol(d), shade(normalize(r), rd));\n            col.rgb = fog(z * 0.1, col.rgb, bcol);\n            break;\n        }\n       \n        d.x *= 0.7 - 0.1 * hash(uv);\n        r += rd * clamp(d.x, -0.5, 0.5) * 0.7;\n       \n        sh = (float(i) / float(MAXIT));\n    }\n   \n    col.rgb *= exp(-sh * .9);\n    col.rgb = mix(col.rgb, gcol, glow * 0.005);\n   \n    fragColor = vec4(col.rgb, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsjyRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[198, 198, 218, 218, 320], [323, 323, 343, 343, 447], [450, 450, 470, 470, 572], [586, 586, 617, 617, 645], [648, 648, 677, 677, 797], [800, 800, 837, 837, 865], [868, 868, 895, 895, 1036], [1039, 1039, 1069, 1069, 1124], [1127, 1127, 1169, 1169, 1209], [1224, 1224, 1242, 1242, 1540], [1543, 1543, 1563, 1563, 1635], [1638, 1638, 1659, 1659, 1823]], "test": "valid"}
{"id": "WsjyWh", "name": "Grass 1.0", "author": "DenZ33", "description": "Drag to change view", "tags": ["grass"], "likes": 0, "viewed": 77, "published": "Public", "date": "1586563037", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nconst int MAX_STEPS = 63;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1024.0;\nconst float EPSILON = 0.01;\n\n\n\n\nmat4 rotationX( in float angle ) {\n\treturn mat4(\t1.0,\t\t0,\t\t\t0,\t\t\t0,\n\t\t\t \t\t0, \tcos(angle),\t-sin(angle),\t\t0,\n\t\t\t\t\t0, \tsin(angle),\t cos(angle),\t\t0,\n\t\t\t\t\t0, \t\t\t0,\t\t\t  0, \t\t1);\n}\n\nmat4 rotationY( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t0,\t\tsin(angle),\t0,\n\t\t\t \t\t\t\t0,\t\t1.0,\t\t\t 0,\t0,\n\t\t\t\t\t-sin(angle),\t0,\t\tcos(angle),\t0,\n\t\t\t\t\t\t\t0, \t\t0,\t\t\t\t0,\t1);\n}\n\nmat4 rotationZ( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t-sin(angle),\t0,\t0,\n\t\t\t \t\tsin(angle),\t\tcos(angle),\t\t0,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t1,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t0,\t1);\n}\n\n\nfloat sphereSDF(vec3 samplePoint) {\n    return length(samplePoint) - 1.0;\n}\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat halfEllipseSDF(vec3 smp,vec3 size){ //approx\n    float k0 = length(smp/size);\n    float k1 = length(smp/(size*size));\n\tif(smp.y > -EPSILON) return k0*(k0-1.0)/k1;\n    else return -smp.y;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdPlane( vec3 p){\n \treturn p.y;   \n}\n\nvec2 getWindVec(vec2 sp,float t){\n\tvec2 pos = vec2(0.0,500.0);\n    vec2 pos2 = vec2(400.0,100.0);\n    float power1 = (sin(-length(pos - sp)*0.1 + t*5.0)*0.5+0.5);\n    float power2 = (sin(-length(pos2 - sp)*0.1 + t*3.0)*0.5+0.5);\n    vec2 dir = (normalize(pos - sp)*power1 + normalize(pos2 - sp)*power2);\n    return dir;   \n    \n}\n\nfloat grass1SDF(vec3 sp){\n const float md = 0.5;\n vec2 fact1 = sp.y*sp.y*getWindVec(sp.xz,iTime + sin(iTime)*0.5)*0.04; //deform global\n highp vec3 sp2 = sp + vec3(fact1.x,0.0,fact1.y) ; // wind\n sp2 = sp2 + vec3(sin(sp2.z)*md,0.0,sin(sp2.x)*md);\n    \n vec3 sp3 = vec3(mod(sp2.x,md*2.0)-md,sp2.y,mod(sp2.z,md*2.0)-md); // repeat\n   \n float p1 = halfEllipseSDF(sp3,vec3(0.3,4.0 + sin(sp2.x*2.0)*sin(sp2.z*2.0)*sin(sp2.x*0.9),0.4));\n    //float p2 = halfEllipseSDF(samplePoint2 + vec3(0.3,0.0,0.0),vec3(0.2+sin(samplePoint.x*0.1)*0.1,5.0,0.3 + sin(samplePoint.z*0.1)*0.1));\n return p1;\n}\n\n\nfloat sceneSDF(vec3 samplePoint) {\n\n   float p1 = grass1SDF(samplePoint);\n   return p1;\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n\nfloat rayMarchScene(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    } \n    return end;\n}\n\nfloat rayMarchGround(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        float dist = sdBox(eye + depth * marchingDirection + vec3(0.0,5.0,0.0),vec3(1000.0,5.0,1000.0));\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    } \n    return end;\n}\n\nfloat rayMarchBound(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        float dist = sdBox(eye + depth * marchingDirection,vec3(1000.0,5.0,1000.0));\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nfloat rayMarchShadow(vec3 eye, vec3 marchingDirection, float start, float end){\n    float depth = start ;\n    float intens = 1.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n       \tintens = min(intens,clamp(dist/depth*10.0,0.0,1.0));\n        if (dist < EPSILON) {\n\t\t\treturn 0.0;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return intens;\n        }\n    } \n    return intens;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 grassColor = vec3(0.2,0.55,0.2);\n    vec3 groundColor = vec3(0.5,0.3,0.2);\n    vec3 albedo = vec3(0.0);\n  \n    vec3 ldir = vec3(0.0,1.0,1.0);\n    vec2 mousev = (iMouse.xy-iResolution.xy*0.5)*0.1;\n   if(iMouse.xy == vec2(0.0,0.0))\n        mousev = vec2(sin(iTime*0.1)*50.0,cos(iTime*0.5)*5.0+6.0);\n    \n\tvec3 dir = rayDirection(90.0, iResolution.xy, fragCoord);\n    dir = ( vec4(dir,1.0) * rotationX(-mousev.y*0.05) * rotationY(mousev.x*0.05) ).xyz;\n    vec3 eye = vec3(mousev*5.0 + vec2(0.0,5.0) , 55.0);\n    \n    float distBound = rayMarchBound(eye, dir, MIN_DIST, MAX_DIST);\n    float distScene = rayMarchScene(eye , dir, distBound, MAX_DIST);\n    float distGround = rayMarchGround(eye, dir, MIN_DIST, MAX_DIST);\n   \n    float isGround = step(distScene,distGround);\n    float distMain = mix(distGround,distScene,isGround);\n    \n    vec3 pos = eye + dir*distMain;\n    \n    albedo = mix(groundColor,grassColor + texture(iChannel1,pos.xz*0.002).rgb*0.1-0.1,isGround);\n    \n    vec3 normal = mix(vec3(0.0,1.0,0.0),estimateNormal(eye+distMain*dir),isGround);\n\n    \n    if ((distMain > MAX_DIST - EPSILON) ) {\n        fragColor = mix(vec4(0.4, 0.8, 1.0, 0.0),vec4(1.0,1.0,0.9,0.0),(clamp(dot(dir,ldir)*30.0-41.0,0.0,1.0)));\n\t\treturn;\n\t}\n    \n\n\n    float ldist = rayMarchShadow(eye + dir*distMain,ldir,0.5,MAX_DIST);\n    float ldist2 = ldist;\n    \n    vec3 ambientColor = vec3(0.4,0.7,0.4)*(pos.y*0.2+0.3);\n    vec3 sunColor = vec3(1.0,1.0,0.8);\n   // fragColor = vec4(dist/MAX_DIST, nor.x*0.5+0.5, 0.0, 1.0);\n     //vec3 col = nor.xyz*0.5+0.5;\n     vec3 col = albedo * (sunColor * clamp(dot(ldir,normal),0.0,1.0)* ldist2 + ambientColor);\n     fragColor = vec4(col.xyz, 1.0);\n}", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}, {"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsjyWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[119, 119, 153, 153, 292], [294, 294, 328, 328, 464], [466, 466, 500, 500, 633], [636, 636, 671, 671, 711], [712, 712, 748, 748, 851], [853, 853, 894, 903, 1047], [1049, 1049, 1080, 1080, 1171], [1173, 1173, 1196, 1196, 1215], [1217, 1217, 1250, 1250, 1546], [1548, 1548, 1573, 1573, 2133], [2136, 2136, 2170, 2170, 2225], [2227, 2227, 2256, 2256, 2566], [2569, 2569, 2648, 2648, 2946], [2948, 2948, 3028, 3028, 3367], [3369, 3369, 3448, 3448, 3766], [3768, 3768, 3847, 3847, 4235], [4237, 4237, 4302, 4302, 4434], [4437, 4437, 4494, 4494, 6176]], "test": "error"}
{"id": "wsjyWt", "name": "basic shadertoy template", "author": "dreness", "description": "The simplest possible shadertoy shader to test integrations.\n\n... and a fancy string to let you limit search results. It is:\n\nD56F4F257DFB43EAA43481246A226D71", "tags": ["test", "simple", "basic"], "likes": 0, "viewed": 228, "published": "Public API", "date": "1587532485", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsjyWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 294]], "test": "valid"}
{"id": "WsjyWV", "name": "Paper Washer", "author": "iY0Yi", "description": "View original: https://bit.ly/2KjkQb6", "tags": ["golf", "1tc", "twigl"], "likes": 15, "viewed": 167, "published": "Public", "date": "1587351521", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 O, vec2 C ) {\n    for (float T, D, i = 0.; i < 99.; i += .1) {\n        vec3 B, P = vec3((C.xy - iResolution.xy * .5) / iResolution.y, 2) * T;\n        P.y += sin(P.x + iTime) * .3 - 9.;\n        P.xy *= mat2(cos(T + vec4(0, 5, 8, 0)));\n        B = abs(mod(P + iTime, 10.) - 5.) - vec3(2, .01, .3);\n        T += D = (length(max(B, 0.)) + min(max(B.x, max(B.y, B.z)), 0.)) * .02;\n        O += (D < .001) ? .05 / i : 0.;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsjyWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 447]], "test": "error"}
{"id": "wsjyz3", "name": "hindsight_reader", "author": "Nedelstein", "description": "hindsight reader shader", "tags": ["noise", "gradient", "parsons", "hindsight"], "likes": 1, "viewed": 90, "published": "Public", "date": "1587088849", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random1f(vec2 st){\n    return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\n\nfloat map(float v,float a,float b,float c,float d){\n    float nv=(v-a)/(b-a);\n    nv=pow(nv,3.);\n    float o=nv*(d-c)+c;\n    \n    return o;\n}\n\n   \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     vec2 uv=fragCoord/iResolution.xy;\n    uv=uv*2.-1.;\n    uv.y/=iResolution.x/iResolution.y;\n    \n    vec2 A=vec2(.151,-.2);\n    vec2 B=vec2(-.7,-.28);\n    vec2 C=vec2(.83,-.9);\n    vec2 D=vec2(1.,-.96);\n    vec2 E=vec2(.9,.79);\n    \n    vec2 F=vec2(.79,-.79);\n    \n    float k1=.7;// size\n    float k2=3.;// shape\n    \n    // warp domains\n    vec2 uvA=uv*vec2(.2,.1);\n    uvA.x+=sin(uv.y*4.+iTime)*.05;\n    vec2 uvB=uv*vec2(.4,.3);\n    uvB.y+=sin(uv.y*3.+iTime)*.15;\n    vec2 uvC=uv*vec2(.6,.8);\n    uvC.y+=sin(uv.x*4.+iTime)*.1;\n    vec2 uvD=uv*vec2(-1.2,-.9);\n    uvD.y+=sin(uv.x*11.+iTime)*.05;\n    vec2 uvE=uv*vec2(-1.1,.9);\n    uvE.x+=sin(uv.y*4.+iTime)*.1;\n    \n    vec2 uvF=uv*vec2(1.1,-.45);\n    uvF.x+=sin(uv.y*4.+iTime)*.1;\n    \n    // create shaped gradient\n    float dA=max(0.,1.-pow(distance(uvA,A)/k1,k2));\n    float dB=max(0.,1.-pow(distance(uvB,B)/k1,k2));\n    float dC=max(0.,1.-pow(distance(uvC,C)/k1,k2));\n    float dD=max(0.,1.-pow(distance(uvD,D)/k1,k2));\n    float dE=max(0.,1.-pow(distance(uvE,E)/k1,k2));\n    \n    float dF=max(0.,1.-pow(distance(uvF,F)/k1,k2));\n    \n    // smooth in, out\n    dA=smoothstep(0.,1.3,dA);\n    dB=smoothstep(0.,1.,dB);\n    dC=smoothstep(0.,1.,dC);\n    dD=smoothstep(0.,1.,dD);\n    dE=smoothstep(0.,1.,dE);\n    \n    dF=smoothstep(0.,1.,dF);\n    \n    // define colors\n    \n    vec3 blue=vec3(35.,122.,144.)/255.;\n    vec3 pink=vec3(255.,122.,114.)/255.;\n    vec3 green=vec3(44.,162.,148.)/255.;\n    vec3 black=vec3(20.,10.,0.)/255.;\n    vec3 orange=vec3(255.,78.,0.)/255.;\n    \n    vec3 vanta=vec3(-25,-25,-25)/255.;\n    \n    // lay in color blobs\n    vec3 color=vec3(0.);\n    color=mix(color,blue,dA);\n    color=mix(color,black,dC);\n    color=mix(color,pink,dB);\n    color=mix(color,green,dD);\n    // color=mix(color,orange,dE);\n    \n    color=mix(color,pink,dF);\n    \n    // add noise\n    color+=vec3(\n        random1f(uv),\n        random1f(uv+1.),\n        random1f(uv+2.)\n    )*.2;\n    // Output to screen\n    fragColor = vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsjyz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 96], [98, 98, 149, 149, 239], [245, 245, 302, 302, 2299]], "test": "valid"}
{"id": "wsjyzz", "name": "Watermelon Steven", "author": "Flopine", "description": "I've been obsessed with Steven Universe those past few months, I wanted to make a tribute to this AWESOME show. Coded mostly during a Twitch strem, you can rewatch all of them here: https://www.twitch.tv/flopine\nComment line 16 to use the mouse", "tags": ["raymarching", "modeling", "watermelon", "npr", "stevenuniverse"], "likes": 14, "viewed": 178, "published": "Public", "date": "1586019262", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n#define ITER 64.\n#define PI 3.141592\n#define TAU (2.*PI)\n#define time iTime\n#define mousepos (-1.+2.*(iMouse.xy / iResolution.xy))\n\n// Comment this line to toggle mouse rotation\n// you'll be able to see steven from every angle! \n#define ANIMATED\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nvoid mo (inout vec2 p ,vec2 d)\n{\n    p = abs(p)-d;\n    if (p.y>p.x) p = p.yx;\n}\n\nfloat cyl (vec3 p, float r, float h)\n{return max(length(p.xy)-r,abs(p.z)-h);}\n\n/////////////////////////////////////////////////\n// iq's website : https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat capsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat ellipse( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n////////////////////////////////////////////////////\n\nfloat head (vec3 p)\n{\n    p.y -= 0.85;\n    float sphe = ellipse(p+vec3(0.,0.2,.2),vec3(0.4,0.25,0.4));\n    float rx = (p.y > 0.)? 0.45 : 0.45 -sin(p.y)*0.4;  \n    return smin(ellipse(p , vec3(rx,0.5,0.5)),sphe, 0.2);\n}\n\nfloat hair (vec3 p)\n{\n    p.y -= 0.9;\n    vec3 pp = p;\n    p.yz *= rot(TAU/6.);\n    mo(p.xz, vec2(0.18));\n    p.x -= 0.22;\n    float s1 = length(p)-0.2;\n\n    p = pp;\n    p.z -= 0.2;\n    p.yz *= rot(TAU/5.);\n    mo(p.xz, vec2(0.17,0.25));\n    float s2 = length(p)-0.28;\n\n    p = pp;\n    p.z -= 0.35;\n    p.x = abs(p.x)-0.1;\n    float s3 = length(p)-0.25;\n    return min(min(s2,s3),s1);\n}\n\nfloat eyes (vec3 p)\n{\n    p.y -= 0.9;\n    p.z += 0.48;\n    p.x = abs(p.x)-0.12;\n    return ellipse(p,vec3(0.05,0.08,0.05));\n}\n\nfloat belly (vec3 p)\n{\n    return ellipse(p-vec3(0.,0.,0.03), vec3(0.6,0.67,0.55));\n}\n\nfloat legs (vec3 p)\n{\n    float feet_position = 0.9;\n    float r = (p.y>-feet_position) ? 0.2 : 0.2-sin(p.y+feet_position)*0.3;\n    p.y += 0.6;\n    p.x = abs(p.x)-.28;\n\n    return cyl(p.xzy, r, 0.4);\n}\n\nfloat arms (vec3 p)\n{\n    p.x = abs(p.x) - 0.24;\n    float thumb = capsule(p,vec3(0.37,-.0,-0.25),vec3(0.37,-0.13,-0.38), 0.05);\n    p.x += sin(p.y*3.+5.)*0.2;\n    return smin(thumb,capsule(p, vec3(0.18,.3,0.05), vec3(.25,-0.12,-0.2), 0.17),0.05);\n}\n\nfloat ey, bo;\nvec3 new_p;\nfloat SDF (vec3 p)\n{\n    p.y += 0.15;\n    #ifdef ANIMATED\n    \tp.xz *= rot(time);\n    #else\n    \tp.xz *= rot(PI*mousepos.x);\n    \tp.yz *= rot(PI*mousepos.y);\n    #endif\n    new_p = p;\n    ey = eyes(p);\n    bo = min(smin(belly(p),legs(p),0.05),smin(smin(head(p),hair(p),0.08),arms(p),0.15));\n    return min(ey,bo);\n}\n\nvec3 steven_color (vec2 uv)\n{\n    uv.x = abs(uv.x)-PI/5.;\n    vec2 guv = fract(uv)-0.5;\n    vec2 id = floor(uv)-0.5;\n    float mask = step(abs(guv.x),0.25+sin((uv.y+id.x)*15.)*0.05);\n    return mix (vec3(0.8,0.9,0.8),vec3(0.2,0.8,0.5), mask);\n}\n\n///////////////////////////////////////////////////\n// PIXEL SPIRIT DECK CODE \n// https://patriciogonzalezvivo.github.io/PixelSpiritDeck/\nfloat starSDF2(vec2 uv, int V, float s) \n{\n    vec2 st = uv;\n    float a = atan(st.y, st.x) / TAU;\n    float seg = a * float(V);\n    a = ((floor(seg) + 0.5)/float(V) + mix(s, -s, step(.5, fract(seg)))) * TAU;\n    return abs(dot(vec2(cos(a), sin(a)), st));\n}\nfloat fill(float x, float size) \n{\n    return 1. - smoothstep(size,size*1.05, x);\n}\n///////////////////////////////////////////////////\n\nvec3 background (vec2 uv)\n{\n    uv.y -= 0.07;\n    uv *= rot(-PI/10.);\n\n    float a = atan(uv.y,uv.x);\n    a = mod(a,TAU/5.)-(TAU/5.)*0.5;\n    uv = vec2(cos(a),sin(a)) * length(uv);\n    uv.x += 0.05;\n    float mask = fill(starSDF2(uv, 5, 0.1),0.13);\n    return mix(vec3(0.9,0.25,0.45),vec3(0.9,0.8,0.),mask);\n}\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2(0.001,0.);\n    return normalize(SDF(p)-vec3(SDF(p-eps.xyy),SDF(p-eps.yxy),SDF(p-eps.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    vec3 ro = vec3(0.,0.2,-3.3),\n        rd = normalize(vec3(uv,1.)),\n        p = ro,\n        col = background(uv);\n\n    float d,shad = 0.;\n    bool hit = false;\n\n    for (float i=0.; i<ITER; i++)\n    {\n        d = SDF(p);\n        if (d<0.001)\n        {\n            hit = true;\n            shad = i/ITER;\n            break;\n        }\n        p += d*rd*0.85;\n    }\n\n    if (hit)\n    {\n        if (d == ey)\n        {\n            col = vec3(0.);\n        }\n        else if (d == bo)\n        {\n\n            col = steven_color (vec2(atan(new_p.z,new_p.x), new_p.y));     \n        }\n\n        vec3 norm = abs(getnorm(p));\n        col  *= vec3(smoothstep(0.4,0.45,norm.z));\n    }\n\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsjyzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[559, 559, 579, 579, 622], [624, 624, 656, 656, 703], [705, 705, 743, 743, 782], [784, 924, 965, 965, 1058], [1060, 1060, 1110, 1110, 1237], [1239, 1239, 1272, 1272, 1361], [1416, 1416, 1437, 1437, 1634], [1636, 1636, 1657, 1657, 2022], [2024, 2024, 2045, 2045, 2149], [2151, 2151, 2173, 2173, 2236], [2238, 2238, 2259, 2259, 2439], [2441, 2441, 2462, 2462, 2690], [2718, 2718, 2738, 2738, 3033], [3035, 3035, 3064, 3064, 3279], [3281, 3419, 3461, 3461, 3676], [3677, 3677, 3711, 3711, 3760], [3814, 3814, 3841, 3841, 4123], [4125, 4125, 4148, 4148, 4262], [4264, 4264, 4321, 4321, 5169]], "test": "valid"}
{"id": "wslBDr", "name": "fork-- Triangle - distance 3D", "author": "jorge2017a1", "description": "version modificada por jorge\nhttps://www.shadertoy.com/view/4sXXRN  por IQ", "tags": ["forktriangledistance"], "likes": 2, "viewed": 47, "published": "Public", "date": "1588086196", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//version modificada por jorge --28-abril-2020\n//https://www.shadertoy.com/view/4sXXRN  por IQ\n\n// The MIT License\n// Copyright © 2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// It computes the distance to a triangle.\n//\n// See here: http://iquilezles.org/www/articles/triangledistance/triangledistance.htm\n//\n// In case a mesh was rendered, only one square root would be needed for the\n// whole mesh. In this example the triangle is given a thckness of 0.01 units\n// for display purposes. Like the square root, this thickness should be added\n// only once for the whole mesh too.\n\n\n//\n// List of primitive SDFs at http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n\nmat4 mdv;\n\n///-------------------------------------------------------\n// a perspective correct triangle rasterizer, in a shader :D\n\nmat4 setRotation( float x, float y, float z )\n{\n    float a = sin(x); float b = cos(x); \n    float c = sin(y); float d = cos(y); \n    float e = sin(z); float f = cos(z); \n\n    float ac = a*c;\n    float bc = b*c;\n\n    return mat4( d*f,      d*e,       -c, 0.0,\n                 ac*f-b*e, ac*e+b*f, a*d, 0.0,\n                 bc*f+a*e, bc*e-a*f, b*d, 0.0,\n                 0.0,      0.0,      0.0, 1.0 );\n}\n\nmat4 setTranslation( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,     y,   z, 1.0 );\n}\n///-------------------------------------------------------\n\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat udTriangle( in vec3 v1, in vec3 v2, in vec3 v3, in vec3 p )\n{\n    vec3 v21 = v2 - v1; vec3 p1 = p - v1;\n    vec3 v32 = v3 - v2; vec3 p2 = p - v2;\n    vec3 v13 = v1 - v3; vec3 p3 = p - v3;\n    vec3 nor = cross( v21, v13 );\n\n    return sqrt( (sign(dot(cross(v21,nor),p1)) + \n                  sign(dot(cross(v32,nor),p2)) + \n                  sign(dot(cross(v13,nor),p3))<2.0) \n                  ?\n                  min( min( \n                  dot2(v21*clamp(dot(v21,p1)/dot2(v21),0.0,1.0)-p1), \n                  dot2(v32*clamp(dot(v32,p2)/dot2(v32),0.0,1.0)-p2) ), \n                  dot2(v13*clamp(dot(v13,p3)/dot2(v13),0.0,1.0)-p3) )\n                  :\n                  dot(nor,p1)*dot(nor,p1)/dot2(nor) );\n}\n\n//=====================================================\n\nfloat map( in vec3 p )\n{\n    // triangle\t\n    \n      \t\t\n    vec3 v0 = vec3(-1.0,0.0, 1.0);\n    vec3 v1 = vec3(1.0, 0.0, 1.0);    \n    vec3 v2 = vec3(1.0, 0.0, -1.0);    \n    vec3 v3 = vec3(-1.0,0.0, -1.0);\n    vec3 v4 = vec3(0.0, 1.0, 0.0)*vec3(1.0,3.0,1.0);\t\n\t\n\n    v0= (mdv * vec4(v0,1.0)).xyz;\n    v1= (mdv * vec4(v1,1.0)).xyz;\n    v2= (mdv * vec4(v2,1.0)).xyz;\n    v3= (mdv * vec4(v3,1.0)).xyz;\n    v4= (mdv * vec4(v4,1.0)).xyz;\n    \n\t//triangulos\n\tfloat d11 = udTriangle( v0, v1, v4, p ) - 0.01;\n    float d12 = udTriangle( v1, v2, v4, p ) - 0.01;\n    float d13 = udTriangle( v3, v0, v4, p ) - 0.01;\n    float d14 = udTriangle( v3, v2, v4, p ) - 0.01;\n\n     ///cuadro inferior\n    float d15 = udTriangle( v0, v2, v1, p ) - 0.01;\n    float d16 = udTriangle( v0, v3, v2, p ) - 0.01;\n    \n\n    // ground plane\n\tfloat d2 = p.y + 2.0;\n    \n\tfloat find =10000.0;\n    find =min(find, d2);\n    find =min(find, d11);\n    find =min(find, d12);\n    find =min(find, d13);\n    find =min(find, d14);\n    \n    find =min(find, d15);\n   // find =min(find, d16);\n    \n    \n   \t\n    return find;\n}\n\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 10.0;\n\tfloat h = 1.0;\n    float t = 0.0;\n    for( int i=0; i<50; i++ )\n    {\n        if( h<0.001 || t>maxd ) break;\n\t    h = map( ro+rd*t );\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n\t\n    return t;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.002,0.0,0.0);\n\n\treturn normalize( vec3(\n           map(pos+eps.xyy) - map(pos-eps.xyy),\n           map(pos+eps.yxy) - map(pos-eps.yxy),\n           map(pos+eps.yyx) - map(pos-eps.yyx) ) );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 1.0;\n    float t = 0.0;\n\tfloat h = 1.0;\n    for( int i=0; i<20; i++ )\n    {\n        h = map(ro + rd*t);\n        res = min( res, k*h/t );\n\t\tt += clamp( h, 0.01, 1.0 );\n\t\tif( h<0.0001 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.02 + 0.025*float(i*i);\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return 1.0 - clamp( occ, 0.0, 1.0 );\n}\n\nvec3 lig = normalize(vec3(1.0,0.9,0.7));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 mo = iMouse.xy/iResolution.xy;\n\tmdv = setTranslation( 0.0, 0.0, -3.0 ) * \n\t\t       setRotation( 0.6-6.0*mo.y+iTime, 0.0,  0.6 ) * \n\t\t       setRotation( 0.0, 20.0+1.0*iTime - 6.3*mo.x, 0.0 );\n    \n    \n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n\tvec3 ro = vec3(0.0, 0.25, 2.0 );\n\tvec3 rd = normalize( vec3(p,-1.0) );\n\t\n\tvec3 col = vec3(0.0);\n\n    float t = intersect(ro,rd);\n    if( t>0.0 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\t\tfloat sha = calcSoftshadow( pos + nor*0.01, lig, 32.0 );\n\t\tfloat occ = calcOcclusion( pos, nor );\n\t\tcol =  vec3(0.9,0.6,0.3)*clamp( dot( nor, lig ), 0.0, 1.0 ) * sha;\n\t\tcol += vec3(0.5,0.1,0.7)*clamp( nor.y, 0.0, 1.0 )*occ;\n        col += 0.03;\n\t\tcol *= exp( -0.2*t );\n        col *= 1.0 - smoothstep( 5.0, 10.0, t );\n\t}\n\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.45) );\n\t   \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wslBDr.jpg", "access": "shaders20k", "license": "mit", "functions": [[1814, 1814, 1861, 1861, 2218], [2220, 2220, 2270, 2270, 2386], [2448, 2448, 2473, 2473, 2492], [2494, 2494, 2561, 2561, 3213], [3272, 3272, 3296, 3313, 4355], [4357, 4357, 4400, 4400, 4627], [4629, 4629, 4661, 4661, 4873], [4875, 4875, 4932, 4932, 5178], [5180, 5180, 5229, 5229, 5520], [5564, 5564, 5621, 5621, 6534]], "test": "valid"}
{"id": "wslcDf", "name": "Rorschach Ink Test", "author": "xjorma", "description": "I know it's not the first implementation, but that was the mood of the day.", "tags": ["ink", "psy", "rorschach", "cineshader"], "likes": 11, "viewed": 2370, "published": "Public API", "date": "1585791486", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n//\tSimplex 3D Noise \n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C \n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 ); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\n\nfloat sat(float v)\n{\n    return min(max(v, 0.), 1.);\n}\n\n\nfloat fbm(vec3 p, int octaveNum)\n{\n\tfloat acc = 0.0;\t\n\tfloat freq = 1.0;\n\tfloat amp = 0.5;\n    vec3 shift = vec3(100);\n\tfor (int i = 0; i < octaveNum; i++)\n\t{\n\t\tacc += snoise(p) * amp;\n        p = p * 2.0 + shift;\n        amp *= 0.5;\n\t}\n\treturn acc;\n}\n\nfloat hash21(vec2 uv)\n{\n\treturn fract(sin(dot(uv.xy ,vec2(532.1231,1378.3453))) * 53211.1223);\n}\n\nconst vec3\tinkColor1  = vec3( 28,  28,  40) / 255.;\nconst vec3\tinkColor2  = vec3(255,  68,  23) / 255.;\nconst vec3\tpaperColor = vec3( 28,  28,  40) / 255.;\n\nvec3 vignette(vec3 color, vec2 q, float v)\n{\n    color *= 0.3 + 0.8 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), v);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2\tp = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    vec2\tsp = p;\n    sp.x = abs(sp.x);\n    \n    vec3 col = vec3(252,232,225) / 255.;\n    \n\tcol += hash21(p) / 20.;\n    \n    \n    \n    float i1 = smoothstep(.03, 0., fbm(vec3(sp, iTime * 0.05 + 30.), 7) - 0.2 + length(p) * 0.5);\n    float i2 = smoothstep(.03, 0., fbm(vec3(sp, iTime * 0.04 + 16.), 7) + length(p) * 0.5);\n    \n    col = mix(col, inkColor2, i2 * (0.4 + 0.6 * (fbm(vec3(p * 0.75, iTime * 0.04 + 256.), 5))));\n    col = mix(col, inkColor1, i1 * (0.4 + 0.6 * (fbm(vec3(p * 0.75, iTime * 0.04 + 2445.), 5))));\n    \n    col = vignette(col, fragCoord / iResolution.xy, 0.3);\n\n    // Output to screen\n    fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wslcDf.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[113, 167, 188, 188, 225], [226, 226, 253, 253, 301], [303, 303, 324, 324, 2160], [2163, 2163, 2183, 2183, 2217], [2220, 2220, 2254, 2254, 2471], [2473, 2473, 2496, 2496, 2569], [2728, 2728, 2772, 2772, 2871], [2873, 2873, 2930, 2930, 3631]], "test": "valid"}
{"id": "wslcDX", "name": "Simple logo", "author": "CDucree", "description": "Simple logo which is a registered trademark and happens to resemble my initials quite well... ", "tags": ["logo"], "likes": 3, "viewed": 85, "published": "Public", "date": "1585767151", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Based on the \"RayMarching starting point\" by BigWings/CountFrolic\n// and re-animated by watching IQ's Shader Deconstruction session on U-Tube.\n\n// Antialiasing: number of samples in x and y dimensions\n#define AA 1   // make this 1 if your machine is too slow\n\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define ST(a, b, t) smoothstep(a, b, t)\n\nvec3 mx(vec3 p, float x){\n\tp.x += x;\n    return p;\n}\nvec3 my(vec3 p, float y){\n\tp.y += y;\n    return p;\n}\nvec3 mz(vec3 p, float z){\n\tp.z += z;\n    return p;\n}\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n// -------------------------------------------------------------------------------------------------\nvec2 opU(vec2 d1, vec2 d2){\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 opS(vec2 d1, vec2 d2){\n    \n    if(d1.x < -d2.x) return vec2(-d2.x, d2.y);\n    \n    return d1;\n}\n\nfloat opE(vec3 p, float d, float h){\n    vec2 w = vec2( d, abs(p.y) - h );\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0)); \n}\n\n// -------------------------------------------------------------------------------------------------\n// From IQ's SDF library\n// -------------------------------------------------------------------------------------------------\nfloat sdStar(in vec2 p, in float r, in int n, in float m) // m=[2,n]\n{\n    // these 4 lines can be precomputed for a given shape\n    float an = 3.141593/float(n);\n    float en = 3.141593/m;\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) and simplify, for regular polygon,\n\n    // reduce to first sector\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n\n    // line sdf\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\nfloat sdHorseshoe( in vec2 p, in vec2 c, in float r, in vec2 w )\n{\n    p.x = abs(p.x);\n    float l = length(p);\n    p = mat2(-c.x, c.y, \n              c.y, c.x)*p;\n    p = vec2((p.y>0.0)?p.x:l*sign(-c.x),\n             (p.x>0.0)?p.y:l );\n    p = vec2(p.x,abs(p.y-r))-w;\n    return length(max(p,0.0)) + min(0.0,max(p.x,p.y));\n}\n// -------------------------------------------------------------------------------------------------\nvec2 sdCD2(vec3 p) {\n\tvec2 res = vec2(0.);\n    float r = .1;\n    float c1 = 1.;\n    float c2 = 2.;\n    float h = .1;\n    float ngs = -.0027;\n    float ngr = .03;\n    p *= .9;\n    \n    float t = 3.14/2.;\n\n    p.z += .5;\n    float li = sdHorseshoe(p.xz, vec2(cos(t),sin(t)),.081 + ngs,vec2(0.48,0.4));\n    li = opE(p, li, h);\n    vec2 lif = vec2(li - ngr, c1);\n    \n\n    p.z = -p.z;\n    p.z += 1.;\n    float ri = sdHorseshoe(p.xz, vec2(cos(t),sin(t)),.081 + ngs,vec2(0.48,0.4));    \n    ri = opE(p, ri, h);\n    vec2 rif = vec2(ri - ngr, c2);\n    \n    \n    p.z = -p.z;\n    p.z += 1.;    \n    float mi = sdHorseshoe(p.xz, vec2(cos(t),sin(t)),.755 + ngs,vec2(0.48,0.23));\n    mi = opE(p, mi, h);\n    vec2 mif = vec2(mi - ngr, c2);   \n    \n    p.z = -p.z;\n    p.z += 1.;\n    float o1 = sdHorseshoe(p.xz, vec2(cos(t),sin(t)),.78 + ngs,vec2(0.48,0.26));\n    o1 = opE(p, o1, h);\n    vec2 o1f = vec2(o1- ngr, c1);\n    \n    p.z = -p.z;\n    p.z += 1.;\n    float o2 = sdHorseshoe(p.xz, vec2(cos(t),sin(t)),1.035 + ngs,vec2(0.52,0.005));\n    o2 = opE(p, o2, h);\n    vec2 o2f = vec2(o2- ngr, c1);\n        \n    res = opU(lif, rif);\n    res = opU(res, mif);\n    res = opU(res, o1f);\n    res = opU(res, o2f);        \n    \n    return res;\n}\n\n\n// -------------------------------------------------------------------------------------------------\nvec2 GetDist(vec3 p) {\n\tvec2 res = vec2(0.);\n    \n    p *= .7;\n\tres = sdCD2(p);\n    p /= .7;\n    \n\n    return res;\n}\n\n// -------------------------------------------------------------------------------------------------\nvec2 RayMarch(vec3 ro, vec3 rd) {\n\tvec2 dO= vec2(0);\n    vec2 dS=vec2(0);\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO.x;\n        dS = GetDist(p);\n        dO.x += dS.x;\n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n\n    dO.y = dS.y;\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tvec2 d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d.x - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n// -------------------------------------------------------------------------------------------------\nvec3 ambientColor = vec3(0.05, 0.15, 0.2);\nvec3 diffuseColor = vec3(0.2, 0.6, 0.8);\nvec3 specularColor = vec3(1.0, 1.0, 1.0);\nvec3 lightDir = normalize(vec3(0.0, 4.0, 5.0));\nvec3 spherePos = vec3(0.0, 0.5, 0.0);\n// -------------------------------------------------------------------------------------------------\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    vec3 col = vec3(1);\n    \n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int ma=0; ma<AA; ma++ )\n    for( int na=0; na<AA; na++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(ma),float(na)) / float(AA) - 0.5;\n        uv = (fragCoord+o-.5*iResolution.xy)/iResolution.y;\n#endif\n    vec3 ro = vec3(0,6, -1);\n    //ro.yz *= Rot(-m.y*3.14+1.);        \n    //ro.xz *= Rot(-m.x*6.2831);\n    ro.xz *= 5.*Rot(iTime/4.);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n\n    vec2 d = RayMarch(ro, rd);\n    \n    if(d.x<MAX_DIST) {\n\n        if(d.y==1.) {\n            ambientColor = vec3(0.);\n            diffuseColor = vec3(0.);\n        }\n        if(d.y==2.){\n            ambientColor = vec3(.7);\n            diffuseColor = vec3(1.);\n        }\n        if(d.y==3.){\n            ambientColor = vec3(.3, .0, .0);\n            diffuseColor = vec3(1., .0, .0);\n        }   \n        if(d.y==4.){\n            ambientColor = vec3(.0, .3, .0);\n            diffuseColor = vec3(.0, 1.0, .0);\n        }         \n        vec3 p = ro + rd * d.x;\n    \tvec3 n = GetNormal(p);\n                \n        float occ = 0.5 + 0.5 * n.y;\n\n        float amb = clamp(0.5 + 0.5 * n.y, 0.0, 1.0);\n        float dif = clamp(dot(lightDir, n), 0.0, 1.0);\n\n        vec3 h = normalize(-rd + lightDir);\n        float spe = pow(clamp(dot(h, n), 0.0, 1.0), 64.0);\n\n        col = amb * ambientColor * occ;        \n        col += dif * diffuseColor * occ;\n        col += dif * spe * specularColor * occ;\n               \n        \n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n\n    tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    fragColor=vec4(tot,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wslcDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[373, 373, 398, 398, 425], [426, 426, 451, 451, 478], [479, 479, 504, 504, 531], [533, 533, 552, 552, 628], [629, 730, 757, 757, 790], [792, 792, 819, 819, 893], [895, 895, 931, 931, 1027], [1029, 1256, 1326, 1384, 1820], [1822, 1822, 1888, 1888, 2147], [2148, 2249, 2269, 2269, 3470], [3473, 3574, 3596, 3596, 3690], [3692, 3793, 3826, 3826, 4085], [4087, 4087, 4111, 4111, 4308], [4310, 4310, 4360, 4360, 4555]], "test": "valid"}
{"id": "wslcWs", "name": "Attack of the Bats", "author": "Roninkoi", "description": "Bats are evil", "tags": ["raymarching", "pillars", "bats"], "likes": 4, "viewed": 213, "published": "Public API", "date": "1585888969", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265\n#define MAXIT 128\n#define EPSILON 0.001\n\n#define minx(a, b) ((a.w) < (b.w) ? (a) : (b))\n#define maxx(a, b) ((a.w) > (b.w) ? (a) : (b))\n\nfloat t;\n\nfloat sphere(vec3 r, float a)\n{\n\treturn length(r) - a;\n}\n\nfloat bat(vec3 r, float a)\n{\n\tr *= mat3(\n\t\tcos((r.x * sin(t * 20.) * 0.5) * 1.), -sin((r.x * sin(t * 20.) * 0.5) * 1.), 0., \n\t\tsin((r.x * sin(t * 20.) * 0.5) * 1.), cos((r.x * sin(t * 20.) * 0.5) * 1.), 0.,\n\t\t0., 0., 1.\n\t);\n\tfloat d = (abs(r.x*r.y)*3. + 1./a) * (abs(sqrt(r.y+0.1) * r.y) + sin(r.y) + 1./a) * (abs(r.z) + 1./a);\n\treturn length(r) - 1./ d;\n}\n\nfloat plane(vec3 r, vec3 o, vec3 n) {\n\treturn dot(r - o, n);\n}\n\nfloat box(vec3 r, vec3 a)\n{\n\tr.x += sin(r.y * PI) * 0.1;\n\tvec3 p = abs(r) - a * (sin(length(abs(abs(r)*4. - 2.) * 8.)) + 2.);\n\treturn length(max(p, 0.)) + min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat shade(vec3 n, vec3 rd)\n{\n\treturn clamp(max(dot(n, -rd), 0.) + 1., 0., 1.);\n}\n\nvec3 fog(float z, vec3 col, vec3 fogCol)\n{\n\treturn mix(fogCol, col, exp(-z));\n}\n\nmat3 obj;\n\nvec4 map(vec3 r)\n{\n\tobj = mat3(\n\t\tcos(sin(-t + r.z * 0.2) * 0.31), -sin(sin(-t+r.z * 0.2) * 0.51), 0., \n\t\tsin(sin(-t + r.z * 0.2) * 0.41), cos(sin(-t+r.z * 0.2) * 0.51), 0.,\n\t\t0., 0., 1.\n\t);\n\t\n\tfloat z = r.z;\n\t\n\tvec4 s0 = vec4(\n\t\tvec3(0.0, 0.8, 0.) * 0.8,\n\t\tbat(mat3(3.) * (obj * mod(r + 1. - vec3(cos(t*2. * 0.785 + z) * 0.5+ 0.5, sin(t*2. * 0.785 + z) * 0.25, t) + 0.45, 4.) - 1.), 1.3)\n\t);\n\tvec4 b1 = vec4(\n\t\tvec3(0.3, 0.1, 2.3) * 0.12,\n\t\tbox((mod(r + 3.0, 4.) - 1.0), vec3(0.1, 4., 0.1))\n\t);\n\t\n\treturn minx(s0, b1);\n}\n\nfloat hash(vec2 r) {\n\treturn fract(sin(dot(r, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tt = iTime;\n\t\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv -= 0.5;\n\tuv.x *= iResolution.x / iResolution.y;\n\t\n\tmat3 cam = mat3(\n\t\tcos(sin(t) * 0.1), -sin(sin(t) * 0.1), 0., \n\t\tsin(sin(t) * 0.1), cos(sin(t) * 0.1), 0.,\n\t\t0., 0., 1.\n\t) * mat3(\n\t\t1., 0., 0.,\n\t\t0., cos(0.15), -sin(0.15), \n\t\t0., sin(0.15), cos(0.15)\n\t);\n\t\t\n\tvec3 ro = vec3(0., - 0.5, - 1.0 + t);\n\tvec3 rd = cam * normalize(vec3(uv, -1.));\n\tvec3 r = ro;\n\t\n\tvec4 col = vec4(1.);\n\tvec3 bcol = vec3(1., 0.0, 0.2) + 0.0;\n\t\n\tvec4 c = vec4(bcol, 1.);\n\t\n\tfloat sh = 1.;\n\t\n\tfloat rs = 0.;\n\t\n\tfor (int i = 0; i < MAXIT; ++i) {\n\t\tvec4 d = map(r);\n\t\tfloat z = length(r - ro);\n\t\t\n\t\tvec4 nc = minx(c, d);\n\t\tc.rgb = mix(nc.rgb, c.rgb, nc.w / c.w);\n\t\tc.w = nc.w;\n\t\t\n\t\tif (d.w < EPSILON) {\n\t\t\tcol.rgb = d.rgb * shade(normalize(r), rd);\n\t\t\tcol.rgb = d.rgb;\n\t\t\tcol.rgb = fog(z * 0.1, col.rgb, bcol);\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\td.w *= 0.7 - 0.1 * hash(uv);\n\t\tr += rd * clamp(d.w, -0.5, 0.5) * 0.7;\n\t\t\n\t\tsh += (float(i) / float(MAXIT));\n\t}\n\t\n\tcol.rgb *= exp(-sh * sh * 0.02);\n\t\n\tif (c.w > EPSILON) {\n\t\tcol.rgb = fog(c.w, c.rgb, bcol * 0.1) * 0.2;\n\t}\n\t\n\tfragColor = vec4(col.rgb, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wslcWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[168, 168, 199, 199, 224], [226, 226, 254, 254, 582], [584, 584, 621, 621, 646], [648, 648, 675, 675, 838], [840, 840, 870, 870, 922], [924, 924, 966, 966, 1003], [1016, 1016, 1034, 1034, 1537], [1539, 1539, 1559, 1559, 1625]], "test": "valid"}
{"id": "WslfRM", "name": "Color blend", "author": "disambiguator", "description": "Quick experiment learning how to blend overlapping shapes", "tags": ["blend"], "likes": 2, "viewed": 167, "published": "Public", "date": "1587918990", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circ(vec2 p, float radius) {\n    return step(length(p - 0.5), radius);   \n}\nfloat distanceBetween = 0.8;\n// http://www.iquilezles.org/www/articles/palettes/palettes.htm\n// As t runs from 0 to 1 (our normalized palette index or domain), \n//the cosine oscilates c times with a phase of d. \n//The result is scaled and biased by a and b to meet the desired constrast and brightness.\nvec3 cosPalette( float t, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nfloat blendOverlay(float base, float blend) {\n\treturn base<0.5?(2.0*base*blend):(1.0-2.0*(1.0-base)*(1.0-blend));\n}\nvec3 blendOverlay(vec3 base, vec3 blend) {\n\treturn vec3(blendOverlay(base.r,blend.r),blendOverlay(base.g,blend.g),blendOverlay(base.b,blend.b));\n}\nvec3 blendOverlay(vec3 base, vec3 blend, float opacity) {\n\treturn (blendOverlay(base, blend) * opacity + base * (1.0 - opacity));\n}\nvec3 blendColors(vec3 c1, vec3 c2) {\n    if(length(c1) == 0.) { return c2; }\n    if(length(c2) == 0.) { return c1; }\n    return blendOverlay(c1, c2);\n}\nvec3 shapes(vec2 position, vec3 color) {\n    float radius = 0.3;\n    position = mod(position, distanceBetween);\n    float inCircle = circ(position, radius);\n    return color * inCircle;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 position = ( 2.* fragCoord - iResolution.xy ) /iResolution.y;\n    \n    float time = iTime;\n     float drift =  mod(time/5., distanceBetween);\n    vec3 col = cosPalette(0.5,vec3(0.1),vec3(0.3),vec3(1),vec3(time*0.01,time*0.1,time*.2));\n    vec3 col2 = cosPalette(0.3,vec3(0.4),vec3(0.5),vec3(1),vec3(time*0.1,time*0.1,time*.3));\n    vec3 col3 = cosPalette(0.1,vec3(0.2),vec3(0.1),vec3(1),vec3(time*0.2,time*0.4,time*.3));\n    vec3 col4 = cosPalette(0.2,vec3(0.6),vec3(0.3),vec3(1),vec3(time*0.4,time*0.2,time*.5));\n    vec3 shape = shapes(vec2(position.x + drift,                          position.y + distanceBetween/4.), vec3(.2, .62, 1.0));\n    vec3 shape2 = shapes(vec2(position.x + distanceBetween/3. - 2.*drift, position.y), col);\n    vec3 shape3 = shapes(vec2(position.x - drift,                         position.y + distanceBetween/2.), col3);\n    vec3 shape4 = shapes(vec2(position.x + 2.*drift,                      position.y + 3.*distanceBetween/4.), col2);\n     fragColor = vec4(blendColors(blendColors(blendColors(shape, shape2), shape3), shape4), 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WslfRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 81], [111, 385, 445, 445, 488], [489, 489, 534, 534, 604], [605, 605, 647, 647, 751], [752, 752, 809, 809, 883], [884, 884, 920, 920, 1035], [1036, 1036, 1076, 1076, 1223], [1225, 1225, 1282, 1282, 2361]], "test": "valid"}
{"id": "WslfW4", "name": "[TWITCH] Orb harvest", "author": "evvvvil", "description": "Orb harvest - Result of improvised live code session on Twitch\nLIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 21:00 Uk time:\nhttps://www.twitch.tv/evvvvil_", "tags": ["terrain", "demoscene", "abstract", "tree", "beam", "glow", "alien", "robot", "kifs", "spaceship", "structure", "industrial", "twitch", "improv"], "likes": 13, "viewed": 689, "published": "Public API", "date": "1588270625", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Orb harvest - Result of an improvised live code session on Twitch\n// Thankx to md10t, Balkhan and haptix for suggestions & help\n// LIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 21:00 Uk time:\n// https://www.twitch.tv/evvvvil_\n\n// \"Everyday the postman votes for me\" - Raymond Prunier\n\nvec2 z,v,e=vec2(.0035,-.0035); float f,t,tt,g,g2,b,bb,cc;vec3 np,bp,pp,cp,po,no,al,ld;//global vars. About as exciting as vegans talking about sausages.\nfloat bo(vec3 p,vec3 r){p=abs(p)-r;return max(max(p.x,p.y),p.z);} //box primitive function. Box is the only primitve I hang out with, I find the others have too many angles and seem to have a multi-faced agenda.\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));} //rotate function. Short and sweet, just like a midget wrestler covered in Mapple syrup.\nvec2 fb( vec3 p, float s ) // fb \"fucking bit\" function make a base geometry which we use to make spaceship and central structures using more complex positions defined in mp\n{\n  vec2 h,t=vec2(bo(p,vec3(.5,.5,17)),5);  \n  h=vec2(bo(p,vec3(.7,.3,17)),6);  \n  t=t.x<h.x?t:h;\n  h=vec2(bo(p,vec3(.3,.7,17)),3);  \n  t=t.x<h.x?t:h;  \n  h=vec2(bo(abs(p)-vec3(1,0,0),vec3(0,0,17)),6);  \n  h.x=max(h.x,abs(cp.z)-8.);\n  g+=0.1/(0.1*h.x*h.x*(1000.-980.*sin(cp.z*.2+tt*2.)));\n  t=t.x<h.x?t:h;\n  if(s>0.) t.x=max(t.x,abs(cp.z)-8.),t.x=max(t.x,-cp.y);\n  return t;\n}\nvec2 mp( vec3 p )\n{ \n  p.xy*=r2(sin(p.z*.2+tt*.5)*.4);  \n  p.z=mod(p.z+tt*5.,40.)-20.;  \n  np=bp=pp=cp=p;\n  vec2 h,t=vec2(length(abs(p)-vec3(2.+cc,0,0))-3.,7.);\n  t.x=max(abs(t.x)-.2,-(abs(p.x)-2.-cc));  \n  h=vec2(length(abs(p)-vec3(2.+cc,0,0))-3.,6.);\n  h.x=max(abs(h.x)-.1,-(abs(p.x)-1.8-cc));\n  t=t.x<h.x?t:h;\n  t.x=max(t.x,-(length(p.yz)-1.8));  \n  h=vec2(bo(p,vec3(1.5)),3);  //MIDDLE BOX + CYLINDER\n  h.x=max(abs(h.x)-.1,-(length(p)-1.8));\n  t=t.x<h.x?t:h;\n  h=vec2(length(p.xy)-.2,6);  \n  t=t.x<h.x?t:h;     \n  bp.yz*=r2(0.785*2.);pp.yz*=r2(0.785*2.);//TENTACLES + STRUCTURE KIFS \n  np.x=abs(np.x)-8.;\n  bb=.5+.5*sin(np.x*.5-1.7)+np.x*.1;\n  np.z-=2.*sin(p.x*.3+tt*1.)*bb;\n  np.zy*=r2(tt);\n  for(int i=0;i<3;i++){\n    np=abs(np)-vec3(0,1.*bb,1.*bb);\n    bp=abs(bp)-vec3(0,5,.75);\n    bp.yz*=r2(.785);\n    bp.xz*=r2(sin(pp.z*.2)*.3);\n  } bp.y-=1.4;\n  b=abs(np.x*.8)*.1;\n  h=vec2(bo(np,vec3(5,.4-b,.4-b)),3);\n  h.x*=.5; t=t.x<h.x?t:h;\n  h=vec2(bo(np,vec3(5,.5-b,.25-b)),6);\n  h.x*=.5; t=t.x<h.x?t:h; \n  h=fb(bp,1.);h.x*=0.7;t=t.x<h.x?t:h;    //STRUCTURE\n  h=fb(abs(p*.5-vec3(0,1,0))-vec3(4,5,4),0.);h.x*=0.7;   //ROADS\n  t=t.x<h.x?t:h;    \n  h=vec2(length(abs(p)-vec3(3,0,0))-1.3,6.); //GLOWY SPHEREs \n  g2+=0.1/(0.1*h.x*h.x*(40.-39.*sin(cp.x*.2+tt*2.)));\n  t=t.x<h.x?t:h;  \n  h=vec2(p.y+10.+sin(cp.z*25.-tt*60.)*.03,8);//TERRAIN\n  h.x*=0.4;  t=t.x<h.x?t:h;  \n  float at=min(length(cp)-7.,7.)/7.;//TREES\n  b=ceil(cp.x*.1);\n  p.z=mod(p.z-tt*2.5,40.)-20.;\n  p.xz=abs(abs(p.xz)-10.)-8.+b*2.;  \n  p+=vec3(0,10.-b,0);\n  bb=.5+.5*sin(cp.y*.5+2.7-b);\n  h=vec2(bo(abs(p)-vec3(1.*bb,0,1.*bb),vec3(.2,5.-at*3.,.1)),6);\n  h.x*=.5; t=t.x<h.x?t:h;\n  h=vec2(.5*length(abs(p-vec3(0,5.-at*6.,0))-vec3(.5,0,.5))+.05,6);\n  g2+=.3/(0.1*h.x*h.x*150.);\n  t=t.x<h.x?t:h; t.x*=0.9;\n  return t;\n}\nvec2 tr( vec3 ro, vec3 rd ) // main trace / raycast / raymarching loop function \n{\n  vec2 h,t= vec2(.1); //Near plane because when it all started the hipsters still lived in Norwich and they only wore tweed.\n  for(int i=0;i<128;i++){ //Main loop de loop \n    h=mp(ro+rd*t.x); //Marching forward like any good fascist army: without any care for culture theft. (get distance to geom)\n    if(h.x<.0001||t.x>60.) break; //Conditional break we hit something or gone too far. Don't let the bastards break you down!\n    t.x+=h.x;t.y=h.y; //Huge step forward and remember material id. Let me hold the bottle of gin while you count the colours.\n  }\n  if(t.x>60.) t.y=0.;//If we've gone too far then we stop, you know, like Alexander The Great did when he realised his wife was sexting some Turkish bloke. (10 points whoever gets the reference)\n  return t;\n}\n// Rough shadertoy approximation of the bonzomatic noise texture by yx - https://www.shadertoy.com/view/tdlXW4\nvec4 texNoise(vec2 uv){ float f = 0.; f+=texture(iChannel0, uv*.125).r*.5;\n    f+=texture(iChannel0,uv*.25).r*.25;f+=texture(iChannel0,uv*.5).r*.125;\n    f+=texture(iChannel0,uv*1.).r*.125;f=pow(f,1.2);return vec4(f*.45+.05);\n}\n#define a(d) clamp(mp(po+no*d).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d).x/d)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )//2 lines above are a = ambient occlusion and s = sub surface scattering\n{\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1); //get UVs, nothing fancy, \n  tt=mod(iTime+3.,62.82);  //Time variable, modulo'ed to avoid ugly artifact. Imagine moduloing your timeline, you would become a cry baby straight after dying a bitter old man. Christ, that's some fucking life you've lived, Steve.\n  cc=3.*(clamp(sin(tt*.75-1.8),-.5,.5)+.5);\n    vec3 ro=mix(vec3(1),vec3(-1,-1,1),ceil(sin(tt*.4+2.)))*vec3(sin(tt*.4-2.)*15.,2.,-20.),//Ro=ray origin=camera position We build camera right here broski. Gotta be able to see, to peep through the keyhole.\n  cw=normalize(vec3(0)-ro),cu=normalize(cross(cw,vec3(0,1,0))),cv=normalize(cross(cu,cw)),\n  rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),co,fo;//rd=ray direction (where the camera is pointing), co=final color, fo=fog color\n  ld=normalize(vec3(-.1,.5,-.2)); //ld=light direction\n  v=vec2(abs(atan(rd.x,rd.z)),rd.y);//make some polar uvs to make a fake spherical environment map\n  co=fo=vec3(.1,.3,.6)-length(uv)*.1+.5*texNoise(v*.5).r;//background is dark blueish with vignette and subtle vertical gradient based on ray direction y axis. \n  z=tr(ro,rd);t=z.x; //Trace the trace in the loop de loop. Sow those fucking ray seeds and reap them fucking pixels.\n  if(z.y>0.){ //Yeah we hit something, unlike you at your best man speech.\n    po=ro+rd*t; //Get ray pos, know where you at, be where you is.\n    no=normalize(e.xyy*mp(po+e.xyy).x+e.yyx*mp(po+e.yyx).x+e.yxy*mp(po+e.yxy).x+e.xxx*mp(po+e.xxx).x); //Make some fucking normals. You do the maths while I count how many instances of Holly Willoughby there really is.\n    al=vec3(1,.5,0);b=1.;  \n    if(z.y<5.) al=vec3(0); //material ID < 5 makes it black\n    if(z.y>5.) al=vec3(1); //material ID > 5 makes it white\n    if(z.y>6.) al=vec3(0,.2,.7);  \n    if(z.y>7.) al=vec3(1),b=0.;  \n    float dif=max(0.,dot(no,ld)), //Dumb as fuck diffuse lighting\n    fr=pow(1.+dot(no,rd),4.), //Fr=fresnel which adds background reflections on edges to composite geometry better\n    sp=pow(max(dot(reflect(-ld,no),-rd),0.),50.);//Sp=specular, stolen from Shane \n    co=mix(sp*b+mix(vec3(.8),vec3(1),abs(rd))*al*(a(.1)*a(.3)+.2)*(dif+s(7.)*.5),fo,min(fr,.3));//Building the final lighting result, compressing the fuck outta everything above into an RGB shit sandwich\n    co=mix(fo,co,exp(-.00002*t*t*t)); //Fog soften things, but it won't stop your mother from being unimpressed by your current girlfriend\n  } ro=.5+.5*sin(cp);\n  fragColor = vec4(pow(co+g*.2*mix(vec3(.7,.3,0),vec3(1,.1,0),ro)+g2*.2*mix(vec3(0,.1,.5),vec3(.1,.2,1),ro),vec3(.55)),1);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WslfW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[386, 453, 477, 477, 518], [519, 665, 682, 682, 725], [726, 815, 990, 990, 1365], [1366, 1366, 1385, 1385, 3142], [3143, 3143, 3225, 3225, 3991], [3992, 4103, 4126, 4126, 4330], [4420, 4420, 4549, 4549, 7127]], "test": "error"}
{"id": "WslfzH", "name": "Crypts of Sand", "author": "Roninkoi", "description": "Voxelized caverns", "tags": ["raymarching", "voxel", "pillars"], "likes": 4, "viewed": 267, "published": "Public API", "date": "1587693501", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265\n#define MAXIT 80\n#define EPSILON 0.08\n \n#define minx4(a, b) ((a.w) < (b.w) ? (a) : (b))\n#define minx2(a, b) ((a.x) < (b.x) ? (a) : (b))\n \n#define MAT0 0.0\n#define MAT1 1.0\n\nmat3 rotX(float a)\n{\n    return mat3(\n        1., 0., 0.,\n        0., cos(a), -sin(a),\n        0., sin(a), cos(a)\n    );\n}\n \nmat3 rotY(float a)\n{\n    return mat3(\n        cos(a), 0.0, -sin(a),\n        0., 1., 0.,\n        sin(a), 0.0, cos(a)\n    );\n}\n \nmat3 rotZ(float a)\n{\n    return mat3(\n        cos(a), -sin(a), 0.,\n        sin(a), cos(a), 0.,\n        0., 0., 1.\n    );\n}\n \nfloat t;\n \nfloat sphere(vec3 r, float a)\n{\n    return length(r) - a;\n}\n \nfloat torus(vec3 r, vec2 a)\n{\n    vec2 p = vec2(length(r.xz) - a.x, r.y);\n    return length(p) - a.y;\n}\n \nfloat plane(vec3 r, vec3 o, vec3 n) {\n    return dot(r - o, n);\n}\n\nfloat cylinder(vec3 r, vec2 a)\n{\n\tvec2 p = abs(vec2(length(r.xz), r.y)) - a;\n\t\n\treturn min(max(p.x, p.y), 0.0) + length(max(p, 0.));\n}\n\nfloat hash(vec2 r) {\n    return fract(sin(dot(r, vec2(15.5921, 96.654654))) * 23626.3663);\n}\n\nfloat box(vec3 r, vec3 a, vec2 s)\n{\n\tr.y *= 0.45;\n\tr.y *= 1. + cos(max(-r.y, 0.)) * 0.05;\n\tr.y -= max(r.y, 0.5) * 0.33;\n\tr.y *= 1. + cos(r.x * 0.3) * cos(r.z * 0.2) * 0.01 * max(r.y, 0.);\n\tr.y *= 1. + round(mod(r.x * 0.105, 1.)) * round(mod(r.z * 0.105, 1.)) * 0.009 * max(r.y, 0.) * hash(r.xz) * hash(r.xz) * 1.5;\n\t\n    vec3 p = (abs(r) - a) - max(abs(r.y) + r.y * r.y * 0.1, 2.) + fract(abs(sin(r.x + 0.05)) + hash(r.xx)) * 4. + fract(abs(sin(r.z))) * 4. - 10.;\n\t\n    return length(max(p, 0.));\n}\n\nfloat shade(vec3 n, vec3 rd)\n{\n    return clamp(max(dot(n, -rd), 0.) + 1., 0., 1.);\n}\n \nvec3 fog(float z, vec3 col, vec3 fogCol)\n{\n    return mix(fogCol, col, exp(-z));\n}\n \nvec2 map(vec3 r)\n{    \n\tr *= rotY(t);\n\tr.z += t * 50.;\n\tr.x += 10. * sin(r.z * 0.015) + 50.;\n\t\n    float b = 0.7;\n    vec3 rr = vec3(0.);\n    rr.x = round(r.x / b) * b;\n    rr.y = round(r.y / b) * b;\n    rr.z = round(r.z / b) * b;\n\t\n    vec2 b1 = vec2(\n        box(mod(rr + 50., 100.) - 50., vec3(2.1, 2.1, 2.1), r.xy),\n        (int(sin(rr.x * 0.1) * 2. + sin(rr.y * 0.1) * 2. + sin(rr.z * 0.1) * 2.) % 2)\n    );\n    \n    return b1;\n}\n \nvec3 matCol(vec2 o)\n{\n    if (o.y == MAT0)\n        return normalize(vec3(0.8, 0.5, .2));\n   \n    if (o.y == MAT1)\n        return normalize(vec3(0.7, 0.55, .2));\n   \n    return vec3(0.);\n}\n \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    t = -iTime * 0.4;\n   \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n   \n    mat3 cam = rotY(-PI) * rotX(0.3);\n       \n    vec3 ro = vec3(0., 10.0, -20.0);\n    vec3 rd = cam * normalize(vec3(uv * 2., -1.));\n    vec3 r = ro;\n   \n    vec3 bcol = vec3(0.5, 0.5, 0.) * 0.2;\n    vec4 col = vec4(0.);\n    col.rgb = bcol;\n   \n    float sh = 1.;\n   \n    for (int i = 0; i < MAXIT; ++i) {\n        vec2 d = map(r);\n        float z = length(r - ro);\n       \n        if (d.x < EPSILON) {\n            col.rgb = mix(col.rgb, \n\t\t\t\tmatCol(d), \n\t\t\t\tshade(normalize(r), rd));\n            col.rgb = fog(z * 0.02, col.rgb, bcol);\n            break;\n        }\n       \n        d.x *= 0.7 - 0.1 * hash(uv);\n\t\tr += rd * d.x * 0.5;\n       \n        sh = (float(i) / float(MAXIT));\n    }\n   \n    if (sh < 0.5)\n\t\tcol.rgb *= exp(-sh * 2. + 1.);\n   \n    fragColor = vec4(col.rgb, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WslfzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[195, 195, 215, 215, 317], [320, 320, 340, 340, 444], [447, 447, 467, 467, 569], [583, 583, 614, 614, 642], [645, 645, 674, 674, 748], [751, 751, 788, 788, 816], [818, 818, 850, 850, 952], [954, 954, 974, 974, 1046], [1048, 1048, 1083, 1083, 1546], [1548, 1548, 1578, 1578, 1633], [1636, 1636, 1678, 1678, 1718], [2158, 2158, 2179, 2179, 2345]], "test": "valid"}
{"id": "wslyDl", "name": "36 Days Of Type - O", "author": "nicolasdnl", "description": "36 Days Of Type - O", "tags": ["letter"], "likes": 0, "viewed": 23, "published": "Public", "date": "1586307505", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535897932384626433832795\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat msign( in float x ) { return (x>0.0)?1.0:-1.0; }\n\n// http://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nvec2 sdSqLine( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( dot2(pa-ba*h), ba.x*pa.y-ba.y*pa.x );\n}\n\nfloat sdCrescent(vec2 p, float r0, float r1, float d, float sign0, float sign1)\n{\n    float a = (r0*r0 - r1*r1 + d*d) / (2.0 * d);\n    \n    if( a < r0)\n    {\n        p.y = abs(p.y);\n        float b = sqrt(r0*r0-a*a);\n        float k = p.y*a - p.x*b;\n        float h = min(d*sign0*(d*(p.y-b)-k ),\n                      d*sign1*k);\n        if (h>0.0)\n        {\n            return length(p-vec2(a,b));\n        }\n    }\n    \n    return max(sign0*(length(p          )-r0),\n               sign1*(length(p-vec2(d,0))-r1));\n}\n\n// http://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nvec2 sdSqArc( in vec2 p, in vec2 a, in vec2 b, in float h, float d2min )\n{\n    vec2  ba  = b-a;\n    float l   = length(ba);\n    float ra2 = h*h + l*l*0.25;\n\n    // recenter\n    p -= (a+b)/2.0 + vec2(-ba.y,ba.x)*h/l;\n    \n    float m = ba.y*p.x-ba.x*p.y;\n    float n = dot(p,p);\n    \n    if( abs(h)*abs(ba.x*p.x+ba.y*p.y) < msign(h)*l*0.5*m )\n    {\n        d2min = min( d2min, n + ra2 - 2.0*sqrt(n*ra2) );\n    }\n\n    return vec2(d2min, -max(m,ra2-n) );\n}\n\n\n//------------------------------------------------------------\n\n\n\n// SDF of a shape made of a set line and arc segments\n//float sdShape( in vec2 p, int kType[3], float kPath[10] )\nfloat sdShape( in vec2 p, int kType[4], float kPath[10] )\n{\n    vec2 vb = vec2(kPath[0],kPath[1]);\n    \n    float d = dot2(p-vb);\n    int off = 0;\n    float s = 1.0;\n    for( int i=0; i<kType.length(); i++ )\n    {\n        vec2 va = vb;\n        vec2 ds;\n        \n        if( kType[i]==0) // line (x,y)\n        {\n            vb = vec2(kPath[off+2],kPath[off+3]);\n            ds = sdSqLine( p, va, vb );\n            off += 2;\n        }\n        else if( kType[i]==1 || kType[i]==2 ) // arc (x,y,r)\n        {\n            vb = vec2(kPath[off+3],kPath[off+4]);\n            ds = sdSqArc(p, va, vb, kPath[off+2], d );\n        \toff += 3;\n\n        }\n        \n        // in/out test\n        if ( kType[i]==2 )\n        {\n            bvec3 cond = bvec3( p.y<va.y, p.y<vb.y, ds.y>0.0 );\n            if( all(cond) || all(not(cond)) ) s*=-1.0;\n        }\n        else\n        {\n            bvec3 cond = bvec3( p.y>=va.y, p.y<vb.y, ds.y>0.0 );\n            if( all(cond) || all(not(cond)) ) s*=-1.0;\n        }\n\n        d = min( d, ds.x );\n    }\n    \n\treturn s*sqrt(d);\n}\n\nfloat sdA( in vec2 p )\n{\n    float width = 1.;\n    float height = 1.;\n    \n   \t/*int kType[] = int[](1,0,1);\n\tfloat kPath[] = float[](  0.0,  height*0.5, 0.0,\n                              0.0, -height*0.5,\n                              0.0, -height*0.5, 0.0,\n                              0.0,  height*0.5 );*/\n   \tint kType[] = int[](0,0,0,0);\n\tfloat kPath[] = float[]( -width*0.5,  height*0.5,\n                             -width*0.5, -height*0.5,\n                              width*0.5, -height*0.5,\n                              width*0.5,  height*0.5,\n                             -width*0.5,  height*0.5 );\n    /*int kType[] = int[](1,0);\n\tfloat kPath[] = float[](  width*0.5, 0.0, 0.0,\n                             -width*0.5, 0.0,\n                              width*0.5, 0.0 );*/\n    return sdShape(p,kType,kPath );\n}\n\nvec3 generateBorder(in vec3 col, in float border)\n{\n    col = mix( col, vec3(0.0), 1.0-smoothstep(0.0,0.015,border) );\n    return col;\n}\n\nfloat getLetter(float d)\n{\n    float letter = 1.-sign(d);\n\tletter = mix( letter, 1., 1.0-smoothstep(0.0,0.015,abs(d)) );\n    \n    return letter;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pBase = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0.);\n    \n    vec3 cols[6] = vec3[6](\n    \tvec3(1.,0.,0.),\n        vec3(0.,0.,1.),\n        vec3(0.,1.,0.),\n        vec3(1.,1.,0.),\n        vec3(0.,1.,1.),\n        vec3(1.,0.,1.)\n    );\n    \n    float t = mod(iTime * 0.1, 0.1) / 0.1 * PI * 2.;\n    float count = 50.;\n    \n    for (int i=50; i>=0; i--)\n    {\n    \tvec2 p = pBase * (1. + float(i)*0.05);\n        p.x += sin(t) * (float(i)-count*0.) * 0.008;\n\t\t//p.y += cos(t) * (float(i)-count*0.) * 0.008;\n        p.y += float(i) * 0.01;\n        \n        float d = sdA(p);\n        \n        float letter = getLetter(d);\n        \n        float dMask = sdBox(p, vec2(0.15));\n        letter -= getLetter(dMask);\n        //col = mix(col, vec3(0.96), min(1., max(0., letter)));\n        \n        //col = mix(col, 0.94-vec3((float(i)+1.)/(count+10.)), min(1., max(0., letter)));\n        col = mix(0.96-vec3((float(i)+1.)/(count+10.)), col, min(1., max(0., letter)));\n        //col = mix(col, cols[i], min(1., max(0., letter)));\n    }\n    \n    float d = sdA(pBase);\n    float letter = getLetter(d);\n    col = mix(vec3(0.96), col, min(1., max(0., letter)));\n\n    float dMask = sdBox(pBase, vec2(0.1));\n    letter = getLetter(dMask);\n    //col = mix(col, vec3(0.96), min(1., max(0., letter)));\n    \n    // output\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wslyDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 71, 71, 90], [91, 91, 118, 118, 145], [147, 221, 271, 271, 404], [406, 406, 487, 487, 922], [924, 998, 1072, 1072, 1451], [1520, 1634, 1693, 1693, 2684], [3516, 3516, 3567, 3567, 3652], [3654, 3654, 3680, 3680, 3800], [3802, 3802, 3839, 3839, 3919]], "test": "error"}
{"id": "wssBDr", "name": "interaction with user (mouse)", "author": "elmtili", "description": "stroboscop\ninspiration from professor Ballet pascal \n\nenjoy magic", "tags": ["noise", "elmtili", "noiseeffect"], "likes": 0, "viewed": 68, "published": "Public", "date": "1588122969", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//noise effect cur\nfloat noiseld(float value) {\n    \n return cos(value + cos(value * 100.0)  );   \n\n}\n\n//noise effect cur\nfloat noiseldx2(float value) {\n    \n return cos(value + cos(value * 100.0) *10.0);   \n\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 coord = fragCoord / iResolution.xy;\n     vec2 uv = 20.0 * (fragCoord - iResolution.xy / 2.0) / min(iResolution.y, iResolution.x);\n    \n    vec3 color = vec3(uv.x, noiseldx2(iTime), 1.0);\n     \n   \n\n   //pointeur birth\n    float d = distance(coord, iMouse.xy/iResolution.xy) ;\n    if (d < 0.12 ) {\n        color += vec3(noiseld(d*iTime), noiseld(d*iTime), noiseld(d*iTime));\n        \n    }\n    \n    \n    \n    //color effect with moving mouse\n    color.r= iMouse.x/ iResolution.x;\n    color.b= iMouse.y/ iResolution.y;\n\n\n    \n    fragColor = vec4(color ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wssBDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 19, 47, 47, 101], [103, 122, 152, 152, 210], [214, 214, 271, 321, 890]], "test": "valid"}
{"id": "wssBz8", "name": "Foam Noise", "author": "TEttinger", "description": "Foam Noise! Really this is just value noise, rotated to match a corner of the appropriate simplex, and domain-warping the next rotation, averaging all results at the end. It's pretty simple but gives nice results with just one octave.", "tags": ["noise", "hash", "foam", "continuous"], "likes": 8, "viewed": 345, "published": "Public API", "date": "1587709458", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This Shadertoy ( https://www.shadertoy.com/view/wssBz8 ) shows \"Foam Noise\" by Tommy Ettinger.\n// It's just value noise that's rotated and domain warps the next result.\n\n// Based on a Shadertoy: https://www.shadertoy.com/view/4dS3Wd\n// By Morgan McGuire @morgan3d, http://graphicscodex.com\n// Reuse permitted under the BSD license.\n// The improved value noise is also from a Shadertoy: https://www.shadertoy.com/view/MllBRr\n// By afl_ext, public domain.\n\n// For a single octave\n#define NOISE foam\n\n// For multiple octaves\n//#define NOISE fbm\n#define NUM_NOISE_OCTAVES 1\n\nconst highp float pi          = 3.1415926535;\nconst highp float pi2         = 2.0 * pi;\nconst highp float inf         = 1.0 / 0.0;\nfloat square(float x) { return x * x; }\nfloat infIfNegative(float x) { return (x >= 0.0) ? x : inf; }\n\nconst highp float PHI = 1.61803398874989484820459; // (phi = Golden Ratio)\nconst highp vec2 H2 = vec2(1.324717957244746, 1.754877666246693); // harmonious number for 2D, then its square\nconst highp vec3 H3 = vec3(1.8191725134, 1.6710436067, 1.5497004779); // harmonious 3D\n\nfloat bounce(float x) {\n    float y = fract(x);\n    return mix(y, 1.0 - y, step(fract(x * 0.5), 0.5));\n}\n\nvec2 bounce(vec2 x) {\n    vec2 y = fract(x);\n    return mix(y, 1.0 - y, step(fract(x * 0.5), vec2(0.5)));\n}\n\nfloat hash(float seed, float p) {\n    return bounce(fract((p - seed) * PHI + seed) * (PHI - p));\n//    return fract(fract((p - seed) * PHI + seed) * (PHI - p));\n//    return fract((cos(p * seed + PHI) - sin(p * PHI - seed)) * (31.0 + seed));\n//    float f = floor(p);\n//    float start = sin((cos(f * seed) + sin(f * 1024.)) * 345. + seed);\n//    float end   = sin((cos((f+1.) * seed) + sin((f+1.) * 1024.)) * 345. + seed);\n//    return mix(start, end, smoothstep(0., 1., p - f)) * 0.5 + 0.5;\n}\n\n    //////////WIP comments, feel free to ignore\n    //// old, slow\n//    return fract(dot(sin(seed + hm + p), cos(seed + hm * p)));\n//    const float scale = -1.0 / log(2.125);\n    //// thanks mgsx! https://www.mgsx.net/2015/07/21/006-011-fm-3D-WIP.html\n//    return fract(sin(p * 12.9898 + seed) * 43758.5453 - p - seed);\n\n    //    return acos(fract(sin(p * 12.9898 + seed) * 43758.5453 - p - seed) * 2.0 - 1.0) * (1.0 / pi);\n//    return scale * log(fract(sin(p * 12.9898 + seed) * 43758.5453 - seed) + 1.0) + 1.0;\n    //return pow(0.61803, 3.14159 * fract(sin((p+seed) * 12.9898) * 43758.5453 + (p+seed) * 2.6180339887498949));\n//    return pow(0.61803, 3.14159 * fract(sin(p * 12.9898 + seed) * 43758.5453 - p - seed));\n\n\nfloat hash(float seed, vec2 p) {\n/*\n    p = (fract((p - seed) * PHI + seed) * (PHI - p.yx));\n    p = (fract((p.yx - seed) * PHI + seed) * (PHI - p));\n    return bounce(p.x - p.y);\n*/\n    return fract(4768.1232345456 * sin((p.x+p.y*43.0+seed*137.0)));\n\t//return fract(4768.1232345456 * sin((p.x+p.y*43.0+p.z*137.0+p.w*2666.0)));\n}\n//    return fract((dot((p + seed), HAR) + seed) * (0.5 + fract(length(HAR.yx * p - seed))));\n\n    //////////WIP comments, feel free to ignore\n    //return fract(dot((seed * hm + p.xyx), (seed + hm * p.yxy)) * (0.5 - fract(length(p - seed))));\n    //// faster way, seems better-distributed than the 1D noise, thanks again mgsx\n//    return fract(sin(seed + dot(p, vec2(12.9898,78.233))) * 43758.5453 - length(p + seed));\n//    return acos(fract(sin(seed + dot(p, vec2(12.9898,78.233))) * 43758.5453 - length(p + seed)) * 2.0 - 1.0) * (1.0 / pi);\n    //return pow(0.61803, 3.14159 * fract(sin(seed + dot(p, vec2(12.9898,78.233))) * 43758.5453 - seed));\n    //return pow(0.61803, 3.14159 * fract(sin(seed + dot(p, vec2(12.9898,78.233))) * 43758.5453 + length(p - seed)));\n\nhighp float noise(float seed, float x) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(hash(seed, i), hash(seed, i + 1.0), u);\n}\n\nhighp float noise(float x) {\n    return noise(42.0, x);\n}\n/*\nfloat noise(float seed, vec2 p)\n{    \n    vec2 i = floor(p);\n\tvec2 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    return mix(mix(sin(pi*dot(p,g(seed,i+vec2(0.000000,0.000000)))),\n               \t   sin(pi*dot(p,g(seed,i+vec2(1.000000,0.000000)))),f.x),\n               mix(sin(pi*dot(p,g(seed,i+vec2(0.000000,1.000000)))),\n               \t   sin(pi*dot(p,g(seed,i+vec2(1.000000,1.000000)))),f.x),f.y) * 0.5 + 0.5;\n}\n*/\nhighp float noise(float seed, vec2 x) {\n/*    x.x -= seed;\n    x.y += seed;\n    x *= 0.125;\n    vec2 y = bounce(x.yx + H2);\n    y += (bounce(x * H2 + seed) * (PHI - y));\n    //y -= (bounce(x * H2 - seed) * (PHI - y));\n    return bounce(y.x - y.y + 0.5);\n//    return sin(pi * (y.x - y.y)) * 0.5 + 0.5;\n*/\n/*\n    vec2 y = sin(x * H2) * pi2;\n    y += cos(y * H2 - x.yx);\n    return sin(pi2 * ((y.x - y.y + 0.5) + (PHI + sin((x.y - x.x - 0.5) * pi2)))) * 0.5 + 0.5;\n*/    \n//    const highp vec2 step = vec2(43.0, 59.0);\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n\n\t// Four corners in 2D of a tile\n\tfloat a = hash(seed, i);\n    float b = hash(seed, i + vec2(1.0, 0.0));\n    float c = hash(seed, i + vec2(0.0, 1.0));\n    float d = hash(seed, i + vec2(1.0, 1.0));\n/*\n    float n = dot(i, step);\n\n    float a = hash(seed, n);\n    float b = hash(seed, n + dot(step, vec2(1.0, 0.0)));\n    float c = hash(seed, n + dot(step, vec2(0.0, 1.0)));\n    float d = hash(seed, n + dot(step, vec2(1.0, 1.0)));\n*/\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nhighp float noise(vec2 x) {\n    return noise(42.0, x);\n}\n\n\nhighp float noise(float seed, vec3 x) {\n    const highp vec3 step = vec3(59.0, 43.0, 37.0);\n\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n \n    // For performance, compute the base input to a 1D hash from the integer part of the argument and the \n    // incremental change to the 1D based on the 3D -> 1D wrapping\n    float n = dot(i, step);\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(seed, n                              ), hash(seed, n + dot(step, vec3(1., 0., 0.))), u.x),\n                   mix( hash(seed, n + dot(step, vec3(0., 1., 0.))), hash(seed, n + dot(step, vec3(1., 1., 0.))), u.x), u.y),\n               mix(mix( hash(seed, n + dot(step, vec3(0., 0., 1.))), hash(seed, n + dot(step, vec3(1., 0., 1.))), u.x),\n                   mix( hash(seed, n + dot(step, vec3(0., 1., 1.))), hash(seed, n + dot(step, vec3(1., 1., 1.))), u.x), u.y), u.z);\n}\n\nhighp float noise(vec3 x) {\n    return noise(42.0, x);\n}\n\nhighp float foam(float seed, float x) {\n    return noise(seed, x);\n}\n\nhighp float foam(float x) { return foam(61.0, x); }\n\nhighp float foam(float seed, vec2 x) {\n    highp vec3 p = vec3(x.x, dot(x, vec2(-0.5, 0.8660254037844386)), dot(x, vec2(-0.5, -0.8660254037844386)));\n    float a = noise(seed, p.yz);\n    float b = noise(seed + 1.0, p.xz + a * 0.5);\n    float c = noise(seed + 2.0, p.xy + b * 0.5);\n    return smoothstep(0.0, 1.0, (a + b + c) * (1.0 / 3.0));\n}\n\nhighp float foam(vec2 x) { return foam(61.0, x); }\n\nhighp float foam(float seed, vec3 x) {\n    highp vec4 p = vec4(x.x, \n                  dot(x.xy, vec2(-0.3333333333333333, 0.9428090415820634)),\n                  dot(x, vec3(-0.3333333333333333, -0.4714045207910317, 0.816496580927726)),\n                  dot(x, vec3(-0.3333333333333333, -0.4714045207910317, -0.816496580927726)));\n    float a = noise(seed, p.yzw);\n    float b = noise(seed + 42.0, p.xzw + a * 0.5);\n    float c = noise(seed + 84.0, p.xyw + b * 0.5);\n    float d = noise(seed + 126.0, p.xyz + c * 0.5);\n    return smoothstep(0.0, 1.0, \n           smoothstep(0.0, 1.0, (a + b + c + d) * 0.25)\n           );\n}\n\nhighp float foam(vec3 x) { return foam(61.0, x); }\n\nfloat fbm(float x) {\n\tfloat v = 0.0;\n\tfloat a = 0.6666;\n\tfloat seed = 61.0;\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; ++i) {\n\t\tv += a * foam(seed, x);\n        seed += 42.0;\n\t\tx = x * 2.0 + seed;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n\nfloat fbm(vec2 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.6666;\n\tfloat seed = 61.0;\n\t// Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; ++i) {\n\t\tv += a * foam(seed, x);\n        seed += 42.0;\n\t\tx = rot * x * 2.0 + seed;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n\nfloat fbm(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.6666;\n\tfloat seed = 61.0;\n\tfor (int i = 0; i < NUM_NOISE_OCTAVES; ++i) {\n\t\tv += a * foam(seed, x);\n        seed += 42.0;\n\t\tx = x * 2.0 + seed;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////\n// Visualization:\n\n// C = sphere center, r = sphere radius, P = ray origin, w = ray direction\nfloat  intersectSphere(vec3 C, float r, vec3 P, vec3 w) {\t\n\tvec3 v = P - C;\n\tfloat b = -dot(w, v);\n\tfloat c = dot(v, v) - square(r);\n\tfloat d = (square(b) - c);\n\tif (d < 0.0) { return inf; }\t\n\tfloat dsqrt = sqrt(d);\n\t\n\t// Choose the first positive intersection\n\treturn min(infIfNegative((b - dsqrt)), infIfNegative((b + dsqrt)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\thighp float v = 0.0;\n\t\n\t// Visualize 1D, 2D, and 3D\n\tif (fragCoord.y > iResolution.y / 2.0) {\n\t\tif (fragCoord.x < iResolution.x / 2.0) {\n\t\t\t// 1D\n\t\t    float coord = fragCoord.x * 0.05 + iTime * 5.0 - 10.0;\n\t\t\tfloat height = NOISE(coord) * iResolution.y / 2.0;\n\t\t\tv = clamp((height - fragCoord.y + iResolution.y / 2.0) / (iResolution.y * 0.02), 0.0, 1.0);\n\t\t} else if (fragCoord.x < iResolution.x / 2.0 + 1.0) {\n\t\t\tfragColor.rgb = vec3(1.0);\n\t\t\treturn;\n\t\t} else {\n\t\t\t// 2D\n\t\t\tvec2 coord = fragCoord.xy * 0.125 - vec2(iTime * 5.0, iResolution.y * 0.5);\n\t\t\tv = NOISE(coord);\n\t\t}\n\t} else if (fragCoord.y > iResolution.y / 2.0 - 1.0) {\n\t\tfragColor.rgb = vec3(1.0);\n\t\treturn;\n\t} else {\n\t\t// Ray-sphere\n\t\tconst float verticalFieldOfView = 25.0 * pi / 180.0;\n\t\t\t\n\t    vec3 P = vec3(sin(iTime) * 2.0, 0, 5.0);\n\t\tvec3 w = normalize(vec3(fragCoord.xy - iResolution.xy / vec2(2.0, 4.0), \n\t\t\t\t\t\t\t\t(iResolution.y / 2.0) / (-2.0 * tan(verticalFieldOfView / 2.0))));\n\n\t\tfloat t = min(intersectSphere(vec3(0, 0, 0), 1.0, P, w),\n\t\t\t\t\t  intersectSphere(vec3(0, -2000, 0), 2000.0 - 1.0, P, w));\n\t\tif (t < inf) {\n\t\t\tvec3 X = P + w * t;\n\t\t\t// Fake lighting to make surfaces appear nicely\n\t\t\tv = NOISE(X * 10.0) * clamp(X.y * 0.75 + 1.0 - min(X.z * 0.05, 0.0), 0.0, 1.0) + \n\t\t\t\tclamp((length(X.xz) - 0.75) * 0.15, 0.0, 0.1);\n\t\t} else {\n\t\t\t// Background\n\t\t\tv = 0.5;\n\t\t}\n\t}\n\n    fragColor.rgb = vec3(v);\n//    fragColor.rgb = vec3(pow(v, 0.375));\n//    fragColor.rg += foam(1999.0, fragCoord.xy * 0.25) * 0.0625;\n//    fragColor.g += foam(97.0, fragCoord.xy * 0.375) * 0.0625;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wssBz8.jpg", "access": "shaders20k", "license": "bsd-new", "functions": [[705, 705, 728, 728, 744], [745, 745, 775, 775, 806], [1082, 1082, 1105, 1105, 1186], [1188, 1188, 1209, 1209, 1295], [1297, 1297, 1330, 1330, 1791], [2520, 2520, 2552, 2702, 2849], [7594, 7594, 7614, 7614, 7814], [7817, 7817, 7836, 7836, 8137], [8140, 8140, 8159, 8159, 8359], [8468, 8543, 8600, 8600, 8874], [8876, 8876, 8933, 8933, 10489]], "test": "error"}
{"id": "WsScDd", "name": "just sine", "author": "StrangerintheQ", "description": "just sine", "tags": ["sine"], "likes": 1, "viewed": 74, "published": "Public", "date": "1587493846", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    float a = uv.x * 22. + iTime;\n    float c = uv.y + sin(a)*0.1;\n    float b = 0.002 + 0.0015 * abs(cos(a));\n    c = smoothstep(abs(c), 0.0, b);\n    fragColor = vec4(vec3(1.0 - c), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsScDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 293]], "test": "valid"}
{"id": "wsscDf", "name": "Sphere Tunnel", "author": "Emiel", "description": "Just a little ray marcher I made (is supposed to react to music but can't be bothered to do a multi stage shader for integrated fft).\nHookup sa (sample amplitude fft) and si (sample integrated fft) for sound reactivity.", "tags": ["tunnel", "sdf", "spheres", "glow"], "likes": 4, "viewed": 107, "published": "Public", "date": "1585783527", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define nrm normalize\n#define len length\n#define inv inverse\n#define tim iTime\n\nfloat vol = 80.;\n\nfloat sa(float x) { return 0.; }\nfloat si(float x) { return 0.; }\nmat2 r2(float x) { return mat2(cos(x), -sin(x), sin(x), cos(x)); }\nmat3 r3x(float x) { return mat3(1,0,0,0,cos(x),-sin(x),0,sin(x),cos(x)); }\nmat3 r3y(float x) { return mat3(cos(x),0,sin(x),0,1,0,-sin(x),0,cos(x)); }\nmat3 r3z(float x) { return mat3(cos(x),-sin(x),0,sin(x),cos(x),0,0,0,1); }\n\nfloat sdt(vec3 p, vec2 t) { vec2 q = vec2(length(p.xz)-t.x,p.y); return len(q) - t.y; }\nvec4 ope(vec3 p, vec3 h) { vec3 q = abs(p)-h; return vec4(max(q,0.),min(max(q.x,max(q.y,q.z)),0.)); }\nvec3 rpz(vec3 p, float c) { return vec3(p.xy, mod(p.z+.5*c,c)-.5*c); }\nfloat sds(vec3 p, float s){ return len(p)-s; }\n\nfloat map(vec3 p) {\n  \n  p*=r3z(tim+si(.2)*.5);\n  p.y += cos(p.z*.1)*.1;\n  p.x += sin(p.z*.1+2.5)*.1;\n  \n  vec3 pp=p;\n  \n  \n  p = rpz(p, 12.);\n  vec4 w = ope(p, vec3(.2, 0, 4.2));\n  float d = w.w+sdt(w.xzy, vec2(.8, .05));\n  \n  \n  for (float i=0.; i<12.;i++) {\n    float ic = .4;\n    float as = sa(.1+i*.02);\n    float is = si(.1+i*.02);\n    as = pow(as,.8);\n    as*= .2;\n    d = min(d, sds(p+vec3(\n      vec2(cos(i*ic),sin(i*ic))*.95 * (.9+(cos(i+tim)*.5+.5)*.2),\n      \n      sin(i*10.+tim*2.+is*.1)*3.)\n    \n    *.8, // scale\n    \n    .2+as));\n  }\n  \n  return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = fragCoord/iResolution.xy;\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1.);\n  \n\n  vec3 ro = vec3(0,sin(tim*2.)*.1,tim*5.+si(.1));\n  vec3 rd = normalize(vec3(uv, 1));\n  \n  float sc = 64.;\n  vec3 p = ro;\n  float i, d;\n  float e = 1e-3;\n  bool hit=false;\n  for (;i<sc;i++) { d=map(p); if(d<e){hit=true;break;} p+=d*rd;}\n  \n  vec2 h = vec2(e,0);\n  vec3 n = nrm(vec3(\n    map(p+h.xyy)-map(p-h.xyy),\n    map(p+h.yxy)-map(p-h.yxy),\n    map(p+h.yyx)-map(p-h.yyx)\n  ));\n  \n  vec3 c = vec3(i/sc*1.2) * vec3(.44,.1,.14)*3.;\n  if (hit) {\n    c += .2*max(vec3(0), dot(n,nrm(vec3(1,2,-2))));\n  } else {\n    c.r = mix(c.r, c.b, len(uv));\n    c.g = mix(c.g, c.b, len(uv));\n  }\n  c = pow(c, vec3(1.2));\n\n    // Output to screen\n    fragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsscDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[99, 99, 118, 118, 131], [132, 132, 151, 151, 164], [165, 165, 183, 183, 231], [232, 232, 251, 251, 306], [307, 307, 326, 326, 381], [382, 382, 401, 401, 456], [458, 458, 485, 485, 545], [546, 546, 572, 572, 647], [648, 648, 675, 675, 718], [719, 719, 746, 746, 765], [767, 767, 786, 786, 1334], [1336, 1336, 1393, 1441, 2207]], "test": "valid"}
{"id": "wsScDK", "name": "Yet another simple metaballs", "author": "codecontemplator", "description": "Just simple metaballs to get started", "tags": ["metaballs"], "likes": 0, "viewed": 42, "published": "Public", "date": "1587320327", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float metaball(vec2 p, float r)\n{\n    return r / dot(p, p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 p )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = p/iResolution.xy * 2.0 - 1.0;\n\n\n    vec2 p1 = uv + vec2(0.2*sin(iTime), -0.25*cos(iTime));\n    vec2 p2 = uv + vec2(0.25*sin(iTime+2.0), 0.1*cos(iTime));\n    vec2 p3 = uv + vec2(0.1*sin(iTime), 0.3*cos(iTime));\n        \n    float d1 = metaball(p1, .2);\n    float d2 = metaball(p2, .2);\n    float d3 = metaball(p3, .3);\n    float d = d1*d2*d3;\n    \n    if (d > 6.6) {\n        fragColor = mix(vec4(0.5, 0.8, 0.3, 1), vec4(0.5, 0.2, 0.7, 1), uv.x);\n    } else if (d > 5.0) {\n        fragColor = vec4(1.0);\n    }\n    else {\n        fragColor = mix(vec4(0.5), vec4(0.3), sin(iTime));\n    }    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsScDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 33, 33, 61], [63, 63, 112, 163, 767]], "test": "valid"}
{"id": "WsscDl", "name": "hollow", "author": "JabberSnatch", "description": "yet another experiment", "tags": ["noise", "volume", "clouds", "fire", "glitch"], "likes": 9, "viewed": 229, "published": "Public", "date": "1585853122", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//https://gizma.com/easing/\nfloat ease(float a, float b, float t)\n{\n\tt *= 2.0;\n\tif (t < 1.0) return (b-a)/2.0*t*t*t + a;\n\tt -= 2.0;\n\treturn (b-a)/2.0*(t*t*t + 2.0) + a;\n}\n\nfloat pulse(float time, float bpm, float signature, float offset)\n{\n\treturn fract((time * bpm) / (60.0 * signature) - offset);\n}\n\nfloat cycle(float time, float bpm, float signature, float release, float offset)\n{\n\tfloat pulse = pulse(time, bpm, signature, offset);\n\treturn step(pulse, release) * (pulse / release);\n}\n\nfloat envelope(float t, float attack, float decay, float sustain)\n{\n\tfloat attack_segment = (t / attack) * step(t, attack);\n\tfloat decay_segment = mix(1.0, sustain, (t-attack)/decay) * step(t-attack, decay) * step(attack, t);\n\tfloat sustain_segment = sustain * step(decay, t-attack);\n\treturn attack_segment + decay_segment + sustain_segment;\n}\n\n\nvec3 hash3(vec3 p)\n{\n    mat3 seed = mat3(742.342, 823.457, 242.086,\n                     247.999, 530.343, 634.112,\n                     437.652, 139.485, 484.348);\n\n    return fract(seed * sin(p)) * 2.0 - vec3(1.0);\n}\n\n\nfloat noise3(vec3 p)\n{\n    float f = (sqrt(4.0) - 1.0) / 3.0;\n    mat3 skew = mat3(1.0 + f, f, f,\n                     f, 1.0 + f, f,\n\t\t\t\t\t f, f, 1.0 + f);\n    float g = (1.0 - 1.0/sqrt(4.0)) / 3.0;\n    mat3 invskew = mat3(1.0-g, -g, -g,\n                        -g, 1.0-g, -g,\n\t\t\t\t\t\t-g, -g, 1.0-g);\n\n    vec3 sp = skew * p;\n    vec3 cell = floor(sp);\n    vec3 d0 = fract(sp);\n\n    float x0 = step(d0.x, d0.y);\n\tfloat x1 = step(d0.y, d0.z);\n\tfloat x2 = step(d0.z, d0.x);\n    vec3 s0 = vec3(x2*(1.-x0), x0*(1.-x1), x1*(1.-x2));\n    vec3 s1 = min(vec3(1.0), vec3(1.0) + vec3(x2-x0, x0-x1, x1-x2));\n\n    vec3 sv[4] = vec3[4](cell,\n                         cell + s0,\n                         cell + s1,\n                         cell + vec3(1.0));\n    vec3 wv[4] = vec3[4](invskew * sv[0],\n                         invskew * sv[1],\n                         invskew * sv[2],\n                         invskew * sv[3]);\n    vec3 d[4] = vec3[4](p - wv[0],\n                        p - wv[1],\n                        p - wv[2],\n                        p - wv[3]);\n\n    vec4 weights = max(vec4(0.0), vec4(0.6) - vec4(dot(d[0], d[0]),\n                                                   dot(d[1], d[1]),\n                                                   dot(d[2], d[2]),\n                                                   dot(d[3], d[3])));\n    weights = weights * weights * weights * weights;\n\n    return (dot(hash3(sv[0]), d[0]) * weights[0] +\n            dot(hash3(sv[1]), d[1]) * weights[1] +\n            dot(hash3(sv[2]), d[2]) * weights[2] +\n            dot(hash3(sv[3]), d[3]) * weights[3]) * 16.0;\n}\n\nvec3 target_half_diagonal_hfov(float n, float alpha, float aspect)\n{\n\tfloat half_width = tan(alpha * 0.5) * n;\n\tfloat half_height = half_width * aspect;\n\treturn vec3(half_width, half_height, n);\n}\n\nvec3 target_half_diagonal_vfov(float n, float alpha, float aspect)\n{\n\tfloat half_height = tan(alpha * 0.5) * n;\n\tfloat half_width = half_height * aspect;\n\treturn vec3(half_width, half_height, n);\n}\n\n\nvec3 compute_ray_plane(vec3 half_diagonal, vec2 clip_coord)\n{\n\tvec3 target = half_diagonal * vec3(clip_coord, 1.0);\n\treturn normalize(target);\n}\n\nfloat sample_noise(vec3 p, float octave)\n{\n    float cv = (cycle(iTime, 60.0, 1.0, 0.5, 0.5) + cycle(iTime, 13.44, 1.0, 1.0, 0.25))/2.0;\n    float ev = ease(19.0, 20.0, envelope(cv, 0.25, 0.4, 0.4));\n\n    float density = 0.0;\n    float max_i = exp2(octave);\n    float bd = ev;\n    float expo = 0.3;\n    float scale = 4.5;\n    float offset = +0.115;\n    float of = 1.2;\n\n    vec3 d2 = hash3(vec3(-1.0, -13.0, 0.0)) * iTime * 2.25;\n\n    for (float i = 1.0; i < max_i; i *= 2.0)\n        density += (bd * pow((noise3(((p*scale + d2/(i*of))*i)) + offset), expo)) / i;\n\n    return max(0.0, density);\n}\n\nvoid mainImage(out vec4 frag_color, vec2 frag_coord)\n{\n\tfloat aspect_ratio = iResolution.y / iResolution.x;\n\tfloat fov = 85.0 * 3.1415926536 / 180.0;\n\tfloat near = 0.1;\n\tvec3 half_diagonal = target_half_diagonal_vfov(near, fov, 1.0/aspect_ratio);\n\tvec2 clip_coord = ((frag_coord / iResolution.xy) - 0.5) * 2.0;\n\n    mat3 view = mat3(cos(iTime), -sin(iTime), 0.0,\n                     sin(iTime), cos(iTime), 0.0,\n                     0.0, 0.0, 1.0);\n    vec3 ro = vec3(0.0, 0.0, -2.0);\n\tvec3 rd = compute_ray_plane(half_diagonal, clip_coord);\n\n    vec3 pc = ro + dot(rd, -ro) * rd;\n    float x0 = length(pc);\n    float x1 = 1.0 - x0*x0;\n    float x2 = length(pc - ro) - x1;\n\n    vec3 i0 = ro + rd*x2;\n    vec3 i1 = i0 + 2.0*(pc - i0);\n\n    float t0 = x2;\n    float t1 = length(ro - i1);\n\n    float stepcount = 8.0;\n    float dt0 = (t1-t0)/stepcount;\n    float t = 0.0;\n    float density = 0.0;\n    float i;\n\n    //vec3 Ld = normalize(vec3(0.2 * cos(iTime), 0.2 * sin(iTime), 0.1));\n    //vec3 Ld = normalize(vec3(0.0, 0.1, 0.1));\n    vec3 Ld = normalize(vec3(0.2 * cos(1.0), 1.0, 0.2 * sin(1.0)));\n\n    vec3 Lo = vec3(0.0);\n\n    vec3 Li_sky = vec3(0.7, 0.35, 0.12) * 1.2;\n    vec3 Li_light = vec3(0.97, 0.95, 0.92) * 1.5;\n\n    float st0_count = stepcount + 1.0;\n    float Tr0 = 1.0;\n    float St0 = 0.0;\n\n    for (i = 0.0; i < st0_count; i += 1.0)\n    {\n        float tx = iTime;\n        float bpm = 20.0;\n        float cv =(\n            cycle(tx, bpm, 1.0, 0.05, 0.6) +\n            //cycle(tx, bpm, 1.0, 0.2, 0.0) +\n            cycle(tx, bpm, 1.33, 0.05, 0.1)) / 3.0;\n        float ev0 = ease(0.05, 3.0, envelope(cv, 0.1, 0.8, 0.003));\n\n        t = t0 + dt0*i*\n            (1.0 -\n             hash3(vec3(fract(frag_coord*iTime*1.5), iTime*20.0)).y\n             *ev0);\n        vec3 p = ro + t*rd;\n\n        float st0 = sample_noise(p, 3.0);\n        St0 += st0 * dt0;\n\n        float t_max = 2.0;\n        {\n            vec3 pc = p + dot(Ld, -p) * Ld;\n            float x0 = length(pc);\n            float x1 = 1.0 - x0*x0;\n            float x2 = length(pc - p) - x1;\n            vec3 i0 = ro + rd*x2;\n            vec3 i1 = i0 + 2.0*(pc - i0);\n            float t0 = x2;\n            float t1 = length(ro - i1);\n            t_max = t1/2.0;\n        }\n\n        float st1_count = 64.0;\n        float dt1 = (t_max / st1_count);\n        float Tr1 = 1.0;\n        float St1 = 0.0;\n        for (float j = 0.0; j < st1_count; ++j)\n        {\n            float st1_t = (j + 1.0 + 0.152*(hash3(vec3(frag_coord*0.001, 0.0)).x * 0.5 + 0.5))*dt1;\n\n            vec3 p1 = p + Ld*st1_t;\n            float st1 = 0.0;\n            if (length(p1) <= 1.0)\n                st1 = sample_noise(p1, 1.0);\n            else\n            {\n                float Tr2 = exp(-(St1+St0));\n                Lo += (Tr2 * Li_sky * st0 * dt0);\n                break;\n            }\n\n            St1 += st1 * dt1;\n        }\n\n        Tr1 = exp(-(St1+St0));\n        Lo += (Tr1 * Li_light * st0 * dt0);\n    }\n\n    Tr0 = exp(-St0);\n    Lo += (Tr0 * Li_sky);\n\n    frag_color.xyz = Lo;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsscDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 29, 68, 68, 171], [173, 173, 240, 240, 301], [303, 303, 385, 385, 489], [491, 491, 558, 558, 834], [837, 837, 857, 857, 1056], [1059, 1059, 1081, 1081, 2653], [2655, 2655, 2723, 2723, 2851], [2853, 2853, 2921, 2921, 3050], [3053, 3053, 3114, 3114, 3197], [3199, 3199, 3241, 3241, 3794], [3796, 3796, 3850, 3850, 6829]], "test": "valid"}
{"id": "wsScRt", "name": "glsl [-X-]", "author": "makkotech", "description": "https://twitter.com/darandy\n\nつぶやきGLSL＆Gaming Cube解説？（下書き）\nhttps://www.pixiv.net/fanbox/creator/34219572/post/968500?utm_campaign=manage_post_page&utm_medium=share&utm_source=twitter", "tags": ["intro"], "likes": 3, "viewed": 90, "published": "Public", "date": "1587140421", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R(_)\\\n\tmat2(\\\n    \t2.0,\\\n      \t(sin(t)/cos(t))\\\n        -sin(2.5),\\\n         sin(t)/cos(t)\\\n        -sin(2.5)\\\n    ,2.0)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    vec2 r = iResolution.xy;\n\tvec2 p=(gl_FragCoord.xy*2.-r)/min(r.y,r.x);\n    for(int i=0;i<4;++i){\n        p=abs(p)-0.34;p*=R(t);\n    }\n    float v = 1.0/(p.y)*(5.0/-log(p.y/.3));\n    fragColor = vec4(v*vec3(1.0,1.0,1.0),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsScRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[131, 131, 188, 188, 437]], "test": "valid"}
{"id": "WsScWK", "name": "Trippy Circles 2", "author": "LoganOracio", "description": "I COPY PASTED THE NOISE FUNC, I don't know if it's allowed and I don't know where it came from, sorry", "tags": ["noisesin"], "likes": 2, "viewed": 47, "published": "Public", "date": "1587305315", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MOD3 vec3(.1031,.11369,.13787)\n\nfloat dist(vec2 c1, vec2 c2) {\nreturn pow((c1.x-c2.x)*(c1.x-c2.x)+(c1.y - c2.y)*(c1.y - c2.y),0.5);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nfloat noise(vec3 p)\n{\n    vec3 pi = floor(p);\n    vec3 pf = p - pi;\n    \n    vec3 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    return \tmix(\n        \t\tmix(\n                \tmix(dot(pf - vec3(0, 0, 0), hash33(pi + vec3(0, 0, 0))), \n                        dot(pf - vec3(1, 0, 0), hash33(pi + vec3(1, 0, 0))),\n                       \tw.x),\n                \tmix(dot(pf - vec3(0, 0, 1), hash33(pi + vec3(0, 0, 1))), \n                        dot(pf - vec3(1, 0, 1), hash33(pi + vec3(1, 0, 1))),\n                       \tw.x),\n                \tw.z),\n        \t\tmix(\n                    mix(dot(pf - vec3(0, 1, 0), hash33(pi + vec3(0, 1, 0))), \n                        dot(pf - vec3(1, 1, 0), hash33(pi + vec3(1, 1, 0))),\n                       \tw.x),\n                   \tmix(dot(pf - vec3(0, 1, 1), hash33(pi + vec3(0, 1, 1))), \n                        dot(pf - vec3(1, 1, 1), hash33(pi + vec3(1, 1, 1))),\n                       \tw.x),\n                \tw.z),\n    \t\t\tw.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 mouse = iMouse.xy/iResolution.xy;\n    vec2 coords = vec2(fragCoord.x+18.0*noise(vec3(fragCoord.x/10.0,fragCoord.y/10.0,100.0+30.0*sin(iTime/10.0))),fragCoord.y+18.0*noise(vec3(fragCoord.x/10.0,fragCoord.y/10.0,-100.0+30.0*sin(iTime/10.0))));\n    \n    float dis = dist(coords,iMouse.xy)/5.0;\n\n    float r = sin(iTime* 10.0 + dis);\n    float g = sin(3.14 + iTime * 5.0 + dis);\n    float b = sin(1.57 + iTime * 20.0 + dis);\n    \n    fragColor = vec4(r,g,b,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsScWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[40, 40, 70, 70, 141], [143, 143, 165, 165, 317], [319, 319, 340, 340, 1279], [1281, 1281, 1338, 1338, 1813]], "test": "valid"}
{"id": "WsSczd", "name": "Cursive", "author": "BackwardsCap", "description": "Writing in cursive", "tags": ["1tweet"], "likes": 1, "viewed": 189, "published": "Public API", "date": "1587148660", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 o, in vec2 f )\n{\n    vec2 p = (2.0*f-iResolution.xy)/iResolution.y+.5;\n    for(float t=iTime,s,c,i=1.;i<3.;i++){\n        s=sin(t/i),c=cos(t/i);\n\t\tp.yx=p/(dot(-p+cos(.001*i*(p.x-p.y)),p));\n\t\tp*=.25*(1.5+c)/2.*mat2(c,-s,s,c);\n    }\n    o.gb = p;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsSczd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 270]], "test": "valid"}
{"id": "wsSczm", "name": "RayMarch-Test", "author": "hshshshshs", "description": "RayMarch", "tags": ["raymarch"], "likes": 2, "viewed": 42, "published": "Public", "date": "1586321199", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n\nfloat GetDist(vec3 p) {\n\tvec4 s = vec4(0, 0, 0, 1);\n    float sphereDist =  length(p-s.xyz)-s.w;\n    return sphereDist;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<.01) break;\n    }\n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.0001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0.6, 0.6, 0.6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*3.;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(1);\n    \n    vec3 ro = vec3(0, 0, -3.0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n\n    float d = RayMarch(ro, rd);\n\n    if (d < MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n        float dif = GetLight(p);\n        col = vec3(dif + 0.1, dif*0.8 + 0.1, dif*0.6 + 0.1);\n    }   \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsSczm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 47, 70, 70, 168], [170, 170, 204, 204, 399], [401, 401, 425, 425, 616], [618, 618, 642, 642, 867], [869, 869, 926, 926, 1319]], "test": "valid"}
{"id": "wsSczW", "name": "Rotating Voronoise", "author": "nickcody", "description": "Compliments the great Voronoise/noise combo algorithm by Inigo Quilez.\n\nClick on four qudrants to adjust u/v as in http://iquilezles.org/www/articles/voronoise/voronoise.htm", "tags": ["noise", "voronoise"], "likes": 5, "viewed": 217, "published": "Public API", "date": "1586183305", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float u_rotated_scale        = 0.05;\nfloat u_primary_scale        = 0.01;\nfloat u_rot_left_timescale   = 0.1;\nfloat u_rot_right_timescale  = 0.2;\nfloat u_timescale            = 0.1;\nint   u_showComponents       = 0;\n\n// Voronoise\n// http://iquilezles.org/www/articles/voronoise/voronoise.htm\n// by inigo quilez\n//\nvec3 hash3( vec2 p ){\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)),\n    dot(p,vec2(269.5,183.3)),\n    dot(p,vec2(419.2,371.9)) );\n    return fract(sin(q)*43758.5453);\n}\n\nfloat iqnoise( in vec2 x, float u, float v ){\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    float k = 1.0+63.0*pow(1.0-v,4.0);\n\n    float va = 0.0;\n    float wt = 0.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = vec2( float(i),float(j) );\n        vec3 o = hash3( p + g )*vec3(u,u,1.0);\n        vec2 r = g - f + o.xy;\n        float d = dot(r,r);\n        float ww = pow( 1.0-smoothstep(0.0,1.414,sqrt(d)), k );\n        va += o.z*ww;\n        wt += ww;\n    }\n\n    return va/wt;\n}\n\nvec2 rotate(vec2 v, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat2 m = mat2(c, -s, s, c);\n    return m * v;\n}\n\nvec2 rotateOrigin(vec2 v, vec2 center, float a) {\n    vec2 t = v - center;\n    vec2 r = rotate(t, a);\n    return r + center;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 white = vec3(1.0, 1.0, 1.0);\n    vec3 black = vec3(0.0, 0.0, 0.0);\n\n    vec2 rotated_resolution = iResolution.xy * u_rotated_scale;\n    vec2 primary_resolution = iResolution.xy * u_primary_scale;\n\n    vec2 rotated_fragCoord = fragCoord.xy * u_rotated_scale;\n    vec2 primary_fragCoord = fragCoord.xy * u_primary_scale;\n\n    vec2 left_rotated_center = rotated_resolution.xy/4.0;\n    vec2 right_rotated_center = 3.0 * rotated_resolution.xy/4.0;\n    vec2 primary_center = primary_resolution.xy/2.0;\n\n    float time3d     = iTime * u_timescale;\n    float timeLeft   = iTime * u_rot_left_timescale;\n    float timeRight  = iTime * u_rot_right_timescale;\n\n    vec2 coord0 = vec2( rotateOrigin(primary_fragCoord, primary_center,time3d));\n    vec2 coord1 = vec2( rotateOrigin(rotated_fragCoord, left_rotated_center, timeLeft));\n    vec2 coord2 = vec2( rotateOrigin(rotated_fragCoord, right_rotated_center, timeRight));\n\n    vec2 uv = iMouse.xy/iResolution.xy;\n    float n0 = iqnoise(coord0, uv.x, uv.y);\n    float n1 = iqnoise(coord1, uv.x, uv.y);\n    float n2 = iqnoise(coord2, uv.x, uv.y);\n\n    vec3 color;\n\n    if (u_showComponents == 0) {\n        float brighten = 1.5;\n        float c = (n1+n2)/2.0;\n        float n = iqnoise(coord0 * c, 0.0, 1.0);\n\n        vec3 col = 0.5 + 0.5*cos(iTime+coord0.xyx+vec3(0,2,4));\n\n        color = mix(vec3(n, n, n), col, c);\n    } else {\n        color = vec3(n0, n1, n2);\n    }\n\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsSczW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[217, 314, 335, 335, 481], [483, 483, 528, 528, 1004], [1006, 1006, 1036, 1036, 1132], [1134, 1134, 1183, 1183, 1260], [1262, 1262, 1319, 1319, 2772]], "test": "valid"}
{"id": "wssfR7", "name": "Wave tube", "author": "gaz", "description": "https://twitter.com/gaziya5/status/1254555922665361408", "tags": ["3d", "2tweets"], "likes": 4, "viewed": 73, "published": "Public", "date": "1587956414", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 O, vec2 C) {\n\tO=vec4(.1,.4,.7,1);\n    for(float g,e,i;i++<70.;){\n        vec3 p=g*vec3(C/iResolution.y-.5,1.)+vec3(-.5,1,iTime);\n        p.xy=abs(p.xy)-1.4;\n        p.xy=vec2(atan(p.x,p.y)+iTime,cos(length(p.xy)));\n        g+=e=.3*length(vec2(p.y-sin(p.x*30.)*.02,fract(p.z*2.)-.5))-.01;\n        e<.01?O+=.8/i:O;\n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wssfR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 341]], "test": "valid"}
{"id": "WssfRN", "name": "Worst Amiga ball ever", "author": "Bjorn", "description": "All is in the title.\nPart of the trigonomety formula was stolen from https://www.shadertoy.com/view/XstXzs ", "tags": ["amigaball"], "likes": 2, "viewed": 87, "published": "Public", "date": "1587911917", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 bg = uv;\n\tfloat t = iTime;\n    \n    float carre = 40.;\n    \n    bg.x *= iResolution.x/iResolution.y;\n    \n    uv.x -= cos(t*2.)*.3+.5;\n    uv.y -= abs(cos(t*3.))*.4+.25;\n    \n    uv.x *= iResolution.x/iResolution.y;\n\n    vec3 rgb;\n    \n    float c = length(uv);\n    if(c<.25){\n\n        float nimp = 4.;\n        // following line is stolen from https://www.shadertoy.com/view/XstXzs\n        float nah = asin(uv.x*nimp / cos(asin(uv.y*nimp)))*.25;\n        \n        vec2 plop;\n        plop.x= cos(carre*nah+t*carre*.5)+.5;\n        plop.y= cos(uv.y*carre)+.5;\n        \n        \n        if(plop.x < 0.5 ^^ plop.y < 0.5 ){\n            rgb=vec3(1,0,0);\n        }\n        else rgb=vec3(1,1,1);\n    }\n    else{\n        vec2 plop = cos(bg*carre*1.5);\n        if (plop.x > 0.99 || plop.y > 0.99) rgb=vec3(.5,0.,.5);\n        else rgb=vec3(.7,.7,.7);\n    }\n    \n\n    // Output to screen\n    fragColor = vec4(rgb,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WssfRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "valid"}
{"id": "wssfWH", "name": "Moulins à vent", "author": "moamine", "description": "3 moulins à vent qui tourne en plein air, on peut changer la vitesse de rotation ainsi que la direction de la  rotation.", "tags": ["moulinavent"], "likes": 0, "viewed": 27, "published": "Public", "date": "1588224358", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//Pour changer la vitesse de rotation \n#define SPEED1 iTime\n#define SPEED2 iTime*1.0\n#define SPEED3 iTime*2.0\n#define SPEED4 iTime*3.0\n#define SPEED5 iTime*4.0\n#define SPEED8 iTime*8.0\n\n\nvec3 getSun(vec2 uv){\n\tfloat sun = 1.0 - distance(uv-0.9,iMouse.xy / iResolution.y);\n    sun = clamp(sun,0.0,1.0);\n    \n    float glow = sun;\n    glow = clamp(glow,0.0,1.0);\n    \n    sun = pow(sun,100.0);\n    sun *= 100.0;\n    sun = clamp(sun,0.0,1.0);\n    \n    glow = pow(glow,6.0) * 1.0;\n    glow = pow(glow,(uv.y));\n    glow = clamp(glow,0.0,1.0);\n    \n    sun *= pow(dot(uv.y, uv.y), 1.0 / 1.65);\n    \n    glow *= pow(dot(uv.y, uv.y), 1.0 / 2.0);\n    \n    sun += glow;\n    \n    vec3 sunColor = vec3(1.0,0.6,0.5) * sun;\n    \n    return vec3(sunColor);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy;\n   \n\tvec2 q1 = p - vec2(0.2,0.5);\n    vec2 q2 = p - vec2(0.5,0.5);\n    vec2 q3 = p - vec2(0.8,0.5);\n\t\n    vec3 sun = getSun(p);\n    // Pour la couleur du ciel\n    vec3 col = mix( vec3(1.0,1.0,1.0), vec3(0.0,0.0,1.0), sqrt(p.y) );\n    \n    \n    \n\t\n\tfloat b = 0.015;\n\t\n    //construction et ajout de deux batons \n    col *= 1.0 - (1.0-smoothstep(b,b+0.002, abs(q1.x-0.25*sin(q1.y))))*(1.0-smoothstep(0.0,0.0,q1.y));\n    col *= 1.0 - (1.0-smoothstep(b,b+0.002, abs(q2.x-0.25*sin(q2.y))))*(1.0-smoothstep(0.0,0.0,q2.y));\n    col *= 1.0 - (1.0-smoothstep(b,b+0.002, abs(q3.x-0.25*sin(q3.y))))*(1.0-smoothstep(0.0,0.0,q3.y));\n    \n\t//construction de la tete des moulin à vent\n    float r1 = 0.05 + 0.2*cos( atan(q1.y,q1.x)*4.0 + SPEED8);\n\tcol *= smoothstep( r1, r1+0.01, length( q1 ) );\n    float r2 = 0.05 + 0.2*cos( atan(q2.y,q2.x)*4.0 - SPEED5);\n    col *= smoothstep( r2, r2+0.01, length( q2 ) );\n    float r3 = 0.05 + 0.2*cos( atan(q3.y,q3.x)*4.0 + SPEED8);\n    col *= smoothstep( r3, r3+0.01, length( q3 ) );\n    \n\t\n\tfragColor = vec4(col + sun,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wssfWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[188, 188, 209, 209, 744], [747, 747, 804, 804, 1898]], "test": "error"}
{"id": "wssfWr", "name": "RENTAGHOST", "author": "jj99", "description": "RENT-A-GHOST", "tags": ["silly", "ghost", "purple"], "likes": 3, "viewed": 201, "published": "Public API", "date": "1588084390", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// RENT-A-GHOST (C) ME\n\nvec2 rot(vec2 p, float a)\n{\nfloat sa = sin(a), ca = cos(a);\nreturn p * mat2(ca, -sa, sa, ca);\n}   \nfloat seg( in vec2 p, in vec2 a, in vec2 b )\n{\nvec2 ba = b-a;\nvec2 pa = p-a;\nfloat h =clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\nreturn length(pa-h*ba);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\nvec2 p = (fragCoord.xy - iResolution.xy/2.) / iResolution.y;\np*=1.7+sin(p.x+time*0.9)*0.3;\np = rot(p,0.5+sin(time+p.y*1.2+p.x*0.2)*0.5);\np += sin(time*.87)*.7;\nvec2 pp = rot(p,degrees(-45.0*0.5));\nfloat d = length(pp-vec2(0.25,0.2))-0.04;\nd = min(d,length(pp-vec2(0.0,0.3))-0.04);\npp = rot(pp,degrees(((pp.x-0.1)*-0.05))*0.75);\nfloat d2 = seg(pp, vec2(-0.1,0.0), vec2(0.2,-0.1));\nd2 += 0.02;\nfloat d3 = length(pp-vec2(0.05,0.0))-0.02;\nfloat v = 0.5+sin(time*1.1)*0.5;\nd2 = mix(d3,d2,v);\nfloat angle = atan(p.y, p.x);\nfloat radius = length(p*p) * (1. + sin(p.x*6.0+angle+p.y*9.0 + time)*.1);\nfloat ed = 0.055 + 0.02*sin(p.y*10.0+time*1. + angle);    \ned = -(ed /  (radius - 0.3+sin(20.0*p.x*p.y)*0.1));\ned -= abs(sin(p.y*0.1+time*1.3)*0.3);\nvec3 col = vec3(0.5,0.7,0.1) * ed;\nd = abs(d)+0.01;\nd = 1.0-smoothstep(0.02,0.025,d);\ncol += d*vec3(1.5,1.5,1.5);\nd2 = 1.0-smoothstep(0.03,0.04,d2);\ncol.rgb+=d2*vec3(0.9,0.9,0.9);\nfragColor = vec4(1.-col,1.0);\n}\n \n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wssfWr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 51, 51, 119], [123, 123, 169, 169, 276], [277, 277, 334, 334, 1310]], "test": "valid"}
{"id": "wssfzr", "name": "Heart_Fireworks_remake", "author": "bhuwan0000", "description": "heart fireworks", "tags": ["light", "physics", "fireworks", "particle", "kinematics", "burst"], "likes": 13, "viewed": 374, "published": "Public", "date": "1587641330", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//fireworks in heart shape\n//np = no. of particles\n//snp = no. of spawned particles\n\n#define rad(x) radians(x)\n#define np 50.\n#define snp 40.\n#define spawn 1\n#define trail 1\n\n//random value\nvec2 N22(vec2 p){\n    vec3 a = fract(p.xyx*vec3(123.34, 234.34, 345.65));\n    a += dot(a, a+34.45);\n\treturn fract(vec2(a.x*a.y, a.y*a.z));\n}\nfloat hash(vec2 uv){\n \treturn fract(sin(dot(uv,vec2(154.45,64.548))) * 124.54)  ; \n}\n\n//particle\nvec3 particle(vec2 st, vec2 p, float r, vec3 col){\n \tfloat d = length(st-p);\n    d = smoothstep(r, r-2.0/iResolution.y, d);//d<r?1.0:0.0;\n    return d*col;\n}\n//particle with light\nvec3 burst(vec2 st, vec2 pos, float r, vec3 col, int heart) {\n\tst -= pos;\n    if (heart==1) st.y -= sqrt(abs(st.x))*0.1;\n    r *=0.6*r;\n    return (r/dot(st, st))*col*0.6;\n}\n\n//displacement with s = p0 + ut + 0.5at^2\nvec2 get_pos(vec2 u, vec2 a, vec2 p0, float t, float ang){\n    ang = rad(ang);\n    vec2 d = p0 + vec2(u.x*cos(ang), u.y*sin(ang))*t + 0.5*a*t*t;\n    return d;\n}\n//velocity at time t\nvec2 get_velocity(vec2 u, vec2 a, float t, float ang){\n    ang = rad(ang);\n    return vec2(u.x*cos(ang), u.y*sin(ang)) + a*t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    float aspect = iResolution.x/iResolution.y;\n    vec3 col = vec3(0.0);\n    float t = mod(iTime, 10.);\n    \n    //particle\n    float r = 0.04;\n    vec2 u = vec2(5.); //init velocity\n    vec2 a = vec2(0.0, -9.8); //acc due to gravity\n    float ang = 75.0; //angle of projection\n\n    vec3 p1 = vec3(0.0); //particle\n    \n    for (float i=0.; i<np; i++)\n    {\n        vec2 rand = N22(vec2(i));\n        vec2 ip = vec2(sin(15.*rand.x)*aspect, -1.+r); //initial pos\n        u = vec2(sin(5.*rand.x), 5.+sin(4.*rand.y)); //initial velocity\n        float t1 = t-i/5.;\n    \tvec2 s = get_pos(u, a, ip, t1, ang); // displacement\n    \tvec2 v = get_velocity(u, a, t1, ang);\n        float Tf = 2.0*u.y*sin(rad(ang))/abs(a.y); //time of flight\n\t\tvec2 H = get_pos(u, a, ip, Tf/2.0, ang); //max height\n        \n        vec3 pcol = vec3(sin(22.*rand.x), sin(5.*rand.y), sin(1.*rand.x)); //color per particle\n\n        if (v.y<-0.5){\n            //p1+= burst(uv, H, max(0.0, 0.1-(t1*t1-Tf*0.5)), pcol*0.5, 1 );\n        \tr=0.0; //die\n        }\n        p1 += burst(uv, s, r, pcol, 0); //main particle\n        \n        //trail particle\n        if (trail==1){\n        \tfor (float k=4.0; k>0.0; k--){\n                vec2 strail = get_pos(u, a, ip, t1-(k*0.02), ang); //delay for trail particles\n        \t\tp1 += burst(uv, strail, v.y<-0.5?0.0:r-(k*0.006), pcol, 0);\n        \t}\n        }\n        \n        //spawn\n        if (v.y<=0.0 && t1>=Tf/2.0 && spawn==1)\n        {\n            for (float j=0.0; j<snp; j++)\n            {\n                vec2 rand2 = N22(vec2(j));\n                float ang2 = (j*(360./snp));\n                r = 0.035; // radius of spawned particles\n                r -= (t1-Tf*0.5)*0.04;\n                //r/=(t-(Tf/2.)+0.2);\n                \n                float x = cos(rad(ang2)); //coords of unit circle \n                float y = sin(rad(ang2));\n                \n                y = y + abs(x) * sqrt( (8.- abs(x))/50.0 ); // heart shape as a function of j\n\t\t\t\t\n                vec2 heart = vec2(x*x + y*y)*(0.4/(t1*sqrt(t1))); //velocity vector\n                vec2 S = get_pos(heart, a*0.03, H, t1-(Tf/2.), ang2);\n                pcol = vec3(sin(8.*rand2.x), sin(6.*rand2.y), sin(2.*rand2.x)); // color per spawn particle\n                p1 += burst(uv, S, max(0.0,r), pcol, 0);\n                \n            }\n        } \n\n    }\n    \n    //bg\n    float stars = pow(hash(uv),200.) * 0.5;\n    col = p1;\n    vec3 night = vec3(0.06, 0.02, 0.18)*vec3(uv.y*0.5+0.5)+vec3(stars)*vec3(uv.y*0.5+0.5);;\n    col += night*(1.0-p1);\n    //col = vec3(light(uv, vec2(0.0), 0.1));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wssfzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[175, 190, 207, 207, 330], [331, 331, 351, 351, 415], [417, 428, 478, 478, 585], [586, 608, 669, 669, 781], [783, 825, 883, 883, 985], [986, 1007, 1061, 1061, 1134], [1136, 1136, 1193, 1244, 3907]], "test": "valid"}
{"id": "wssyDs", "name": "Kaleidoscopic Fractal", "author": "kruzifix", "description": "Based on http://roy.red/folding-the-koch-snowflake-.html", "tags": ["raymarching", "fractals"], "likes": 3, "viewed": 63, "published": "Public", "date": "1585910845", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Source Material:\n// Great source for all kinds of computer graphics stuff: http://iquilezles.org/\n// Fractals: http://blog.hvidtfeldts.net/index.php/2011/06/distance-estimated-3d-fractals-part-i/\n\n// Videos:\n// Ray marching setup and HDR colors: https://www.youtube.com/watch?v=Cfe5UQ-1L9Q\n// SDF maths: https://www.youtube.com/watch?v=sl9x19EnKng\n\nconst float PI = 3.141592;\n\nvec2 fold(in vec2 p, in float angle)\n{\n    vec2 n = vec2(cos(angle), sin(angle));\n    p -= 2.0 * min(0.0, dot(p, n)) * n;\n    return p;\n}\n\nvec3 fold(vec3 p)\n{\n    float t = iTime;\n    p.xy = fold(p.xy, -PI / 3.0 - cos(t * 0.5) * 0.1);\n    p.xy = fold(p.xy, PI / 3.0);\n    p.yz = fold(p.yz, -PI / 6.0 + sin(t * 0.4) * 0.022);\n    p.yz = fold(p.yz, +PI / 6.0);\n    \n    return p;\n}\n\nvec3 curve(vec3 p)\n{\n    for (int i = 0; i < 11; ++i)\n    {\n        p *= 2.0;\n        p.x -= 2.6;\n        p = fold(p);\n    }\n    \n    return p;\n}\n\n// Signed distance function that describes the scene\nfloat sceneSDF(vec3 pos)\n{\n    pos.x += 1.7;\n    pos = curve(pos);\n    \n    return length(pos * 0.0004) - 0.0006;\n}\n\n// Approximates the normal of the surface at the given position\n// by calculating the gradient of the scene SDF\nvec3 calcNormal(in vec3 pos)\n{\n    vec2 e = vec2(0.0001, 0.0);\n    \n    return normalize(vec3(\n        sceneSDF(pos + e.xyy) - sceneSDF(pos - e.xyy),\n        sceneSDF(pos + e.yxy) - sceneSDF(pos - e.yxy),\n        sceneSDF(pos + e.yyx) - sceneSDF(pos - e.yyx)));\n}\n\n// Returns the distance to scene surface.\n// If the ray hit nothing this returns -1.0\nfloat rayMarchScene(in vec3 rayOrigin, in vec3 rayDir)\n{\n    float t = 0.0;\n    for (int i = 0; i < 100; ++i)\n    {\n        vec3 pos = rayOrigin + rayDir * t;\n        \n        float dist = sceneSDF(pos);\n        t += dist;\n        if (dist < 0.001)\n            break;\n        if (t > 100.0)\n            return -1.0;\n    }\n    \n    return t;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    //vec2 mouse = vec2(0.5, 1.0);\n    float time = mouse.x * 6.28;//iTime * 0.2;\n    float cameraDist = mix(1.0, -0.1, mouse.y);\n    \n    vec3 rayOrigin = vec3(cos(time), 0.1, sin(time)) * cameraDist;\n    vec3 lookAtPos = vec3(0.2, -0.3, 0.0);\n    \n    vec3 forward = normalize(lookAtPos - rayOrigin);\n    vec3 right = cross(forward, vec3(0.0, 1.0, 0.0));\n    vec3 up = cross(right, forward);\n    \n    vec3 rayDir = normalize(forward + right * uv.x + up * uv.y);\n    \n    float t = rayMarchScene(rayOrigin, rayDir);\n    \n    // Skybox color\n    vec3 skyCol = vec3(0.3, 0.5, 0.4) - rayDir.y * 0.3;\n    vec3 col = skyCol;\n    if (t > 0.0)\n    {\n        vec3 surfacePos = rayOrigin + rayDir * t;\n        vec3 normal = calcNormal(surfacePos);\n        \n        float fogStart = 0.3;\n        float fogEnd = 1.0;\n        float fog = smoothstep(fogStart, fogEnd, t);\n        \n        vec3 sunDir = normalize(vec3(-0.8, 0.4, 0.3));\n        float sunDiffuse = clamp(dot(normal, sunDir), 0.0, 1.0);\n        float sunShadow = step(rayMarchScene(surfacePos + normal * 0.0001, sunDir), 0.0);\n        float skyDiffuse = clamp(0.5+0.5*dot(normal, vec3(0.0, 1.0, 0.0)), 0.0, 1.0);\n        \n        col = vec3(1.8, 1.0, 0.7) * sunDiffuse;\n        col *= mix(0.5, 1.0, sunShadow);\n        \n        col = mix(col, skyCol, fog);\n    }\n    \n    // Gamma correction\n    col = pow(col, vec3(0.4545));    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wssyDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[380, 380, 418, 418, 517], [519, 519, 538, 538, 759], [761, 761, 781, 781, 906], [908, 961, 987, 987, 1076], [1078, 1190, 1220, 1220, 1453], [1455, 1541, 1597, 1597, 1883], [1885, 1885, 1940, 1940, 3468]], "test": "valid"}
{"id": "WsSyDt", "name": "unconnected pipes", "author": "yuntaRobo", "description": "I referenced Truchet Tiling from The Art of Code.\nhttps://www.youtube.com/watch?v=2R7h76GoIJM", "tags": ["raymarching", "truchet", "pipes"], "likes": 20, "viewed": 426, "published": "Public API", "date": "1587482652", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.1415926;\nconst float E = 0.005;\n\nstruct Ray\n{\n    vec3 pos;\n    vec3 dir;\n};\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3 = fract(p3 * 0.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(0.1031, 0.1030, 0.0973));\n    p3 += dot(p3, p3.yxz + 33.33);\n    return fract((p3.xxy + p3.yxx) * p3.zyx);\n}\n\nmat2 rotate2D(float rad)\n{\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat2(c, s, -s, c);\n}\n\nvec3 rotate(vec3 p)\n{\n    p.xz *= rotate2D(iTime * 0.2);\n    p.yz *= rotate2D(0.5);\n    return p;\n}\n\nfloat deBlock(vec3 p)\n{\n    vec3 pb = p;\n\n    p.xz += 0.5;\n\tvec2 q = vec2(length(p.xz) - 0.5, p.y);\n\tfloat d = length(q) - 0.12;\n\t\n\tp = pb;\n\tp.yz -= 0.5;\n\tq = vec2(length(p.yz) - 0.5, p.x);\n\td = min(d, length(q) - 0.12);\n\t\n\tp = pb;\n\tp.xy -= vec2(0.5, -0.5);\n\tq = vec2(length(p.xy) - 0.5, p.z);\n\td = min(d, length(q) - 0.12);\n\t\n\td = abs(d) - 0.0125;\n\t\n\treturn d;\n}\n\nvec2 de(vec3 p)\n{\n    p = rotate(p);\n    \n    vec3 pb = p;\n    \n    vec3 id = floor(p);\n    p = fract(p) - 0.5;\n    \n    vec3 r = hash33(id);\n    if (r.x < 0.5)  p.x *= -1.0;\n\tif (r.y < 0.5)\tp.y *= -1.0;\n\tif (r.z < 0.5)\tp.z *= -1.0;\n\n    float d = deBlock(p);\n\tfloat offset = smoothstep(0.45, 0.5, length(p));\n\td -= offset * 0.03;\n    \n    p = pb;\n    d = max(max(d, abs(p.x) - 5.0), abs(p.z) - 5.0);\n    \n    return vec2(d * 0.75, offset);\n}\n\n// iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 normal(vec3 p)\n{\n    float h = E;\n    vec2 k = vec2(1.0, -1.0);\n    return normalize(\n            k.xyy * de(p + k.xyy * h).x + \n            k.yyx * de(p + k.yyx * h).x + \n            k.yxy * de(p + k.yxy * h).x + \n            k.xxx * de(p + k.xxx * h).x\n        );\n}\n\nfloat ao(Ray ray)\n{\n    float d = 0.0;\n    d += de(ray.pos + ray.dir * 1.0).x;\n    d += de(ray.pos + ray.dir * 2.0).x;\n    d += de(ray.pos + ray.dir * 3.0).x;\n    d += de(ray.pos + ray.dir * 4.0).x;\n    d += de(ray.pos + ray.dir * 5.0).x;\n    return pow(d / 15.0, 2.0);\n}\n\nfloat noiseValue3D(vec3 p, float div)\n{\n    p *= div;\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    float r1 = hash13((i + vec3(0.0, 0.0, 0.0)));\n    float r2 = hash13((i + vec3(1.0, 0.0, 0.0)));\n    float r3 = hash13((i + vec3(0.0, 1.0, 0.0)));\n    float r4 = hash13((i + vec3(1.0, 1.0, 0.0)));\n    float r5 = hash13((i + vec3(0.0, 0.0, 1.0)));\n    float r6 = hash13((i + vec3(1.0, 0.0, 1.0)));\n    float r7 = hash13((i + vec3(0.0, 1.0, 1.0)));\n    float r8 = hash13((i + vec3(1.0, 1.0, 1.0)));\n    return mix(\n            mix(mix(r1, r2, smoothstep(0.0, 1.0, f.x)), mix(r3, r4, smoothstep(0.0, 1.0, f.x)), smoothstep(0.0, 1.0, f.y)),\n            mix(mix(r5, r6, smoothstep(0.0, 1.0, f.x)), mix(r7, r8, smoothstep(0.0, 1.0, f.x)), smoothstep(0.0, 1.0, f.y)),\n            smoothstep(0.0, 1.0, f.z)\n        );\n}\nfloat noiseValueFbm3D(vec3 p, float div, int octaves, float amplitude)\n{\n    float o = 0.0;\n    float fbm_max = 0.0;\n    for(int i = 0; i >= 0; i++)\n    {\n        if(i >= octaves)    break;\n        float a = pow(amplitude, float(i));\n        o += a * noiseValue3D(p, div * pow(2.0, float(i)));\n        fbm_max += a;\n    }\n    return o / fbm_max;\n}\n\nvoid trace(Ray ray, inout vec3 color, float md)\n{\n    vec3 or = ray.pos;\n    \n    float ad = 0.0;\n    for (float i = 1.0; i > 0.0; i -= 1.0 / 120.0)\n    {\n        vec2 o = de(ray.pos);\n        if (o.x < E)\n        {\n            vec3 n = normal(ray.pos);\n\n            // diffuse\n            vec3 ld = normalize(vec3(1.0, 0.75, 0.5));\n            float l = pow(dot(n, ld) * 0.5 + 0.5, 3.0) * 3.0;\n            \n            // specular\n            vec3 h = normalize(ld + normalize(or - ray.pos));\n            float hn = max(dot(h, n), 0.0);\n            float s1 = pow(hn, 15.0) * 0.75;\n            float s2 = pow(hn, 50.0) * 15.0;\n            \n            // ao\n            Ray rayAo;\n            rayAo.pos = ray.pos;\n            rayAo.dir = n;\n            float a = ao(rayAo);\n            \n            // noise\n            vec3 p = rotate(ray.pos);\n            float ns = noiseValueFbm3D(p, 10.0, 4, 0.5);\n            ns = noiseValueFbm3D(p + vec3(ns), 10.0, 4, 0.5);\n\n            // color\n            color += mix(\n                    vec3(0.01, 0.1, 1.0) + s2 * ns * ns * ns, \n                    (mix(vec3(0.2, 0.2, 0.2), vec3(0.15, 0.15, 0.3), ns) + s1) * max(ns, 0.35), \n                    smoothstep(0.8, 1.0, 1.0 - o.y)\n                ) * l * a;\n            \n//            color = n * 0.5 + 0.5;\n//            color = vec3(a);\n\n            return;\n        }\n\n        ray.pos += ray.dir * o.x;\n        ad = ad + o.x;\n        if (ad > md)\n        {\n            break;\n        }\n    }\n\n    // background\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    // view\n    vec3 view = vec3(0.0, 0.0, 10.0);\n    vec3 at = normalize(vec3(0.0, 0.0, 0.0) - view);\n    vec3 right = normalize(cross(at, vec3(0.0, 1.0, 0.0)));\n    vec3 up = cross(right, at);\n    float focallength = 1.75;\n    \n    // ray\n    Ray ray;\n    ray.pos = view;\n    ray.dir = normalize(right * p.x + up * p.y + at * focallength);\n\n    // ray marching\n    trace(ray, color, 20.0);\n\n    // cheap tonemapping\n    // https://www.desmos.com/calculator/adupt0spl8\n    float k = 0.75;\n    color = mix(color, 1.0 - exp(-(color - k) / (1.0 - k)) * (1.0 - k), step(k, color));\n\n    // gamma correction\n    color = pow(color, vec3(0.454545));\n\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsSyDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 138, 161, 161, 264], [265, 265, 287, 287, 418], [420, 420, 446, 446, 526], [528, 528, 549, 549, 627], [629, 629, 652, 652, 992], [994, 994, 1011, 1011, 1436], [1438, 1495, 1516, 1516, 1767], [1769, 1769, 1788, 1788, 2040], [2042, 2042, 2081, 2081, 2856], [2857, 2857, 2929, 2929, 3204], [3206, 3206, 3255, 3255, 4715], [4717, 4717, 4774, 4774, 5549]], "test": "valid"}
{"id": "WssyDX", "name": "Cheap Integer Hash", "author": "tomoe", "description": "3-times XorShift and 2-times multiplication.", "tags": ["hash"], "likes": 8, "viewed": 572, "published": "Public API", "date": "1585733302", "time_retrieved": "2021-10-01T00:00:00", "image_code": "uvec3 k = uvec3(0x456789abu, 0x6789ab45u, 0x89ab4567u); //large odd digits, 0 and 1 are fully mixed\n\nfloat hash11(uint n){\n    n ^= (n << 9);\n    n ^= (n >> 1);\n    n ^= (n << 1);\n    n *= k.x;\n    return float(n) / float(0xffffffffu);\n}\nvec2 hash22(uvec2 n){\n    n ^= (n.yx << 9);\n    n ^= (n.yx >> 1);\n    n *= k.xy;\n    n ^= (n.yx << 1);\n    n *= k.xy;\n    return vec2(n) / float(0xffffffffu);\n}\nvec3 hash33(uvec3 n) {\n    n ^= (n.yzx << 9);\n    n ^= (n.yzx >> 1);\n    n *= k;\n    n ^= (n.yzx << 1);\n    n *= k;\n    return vec3(n) / float(0xffffffffu);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy + vec2(iFrame);\n    vec3 col;\n    if (fragCoord.x < 0.33 * iResolution.x){ \n        col = vec3(hash11(floatBitsToUint(p.x)));\n    } else if (fragCoord.x < 0.66 * iResolution.x){\n        col = vec3(hash22(floatBitsToUint(p)), 1.0);\n    } else {\n        col = vec3(hash33(floatBitsToUint(vec3(p, iFrame))));\n    }\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WssyDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[101, 101, 122, 122, 237], [238, 238, 259, 259, 398], [399, 399, 421, 421, 557], [559, 559, 616, 616, 988]], "test": "valid"}
{"id": "wsSyRG", "name": "Bulles", "author": "domgenest", "description": "Des bulles.", "tags": ["bubbles"], "likes": 1, "viewed": 55, "published": "Public", "date": "1586823870", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const int n = 20;\n    vec2 x[n];\n    for(int i=0;i<n;++i)\n    \tx[i] = vec2(0.5+sin(iTime*(float(i)+1.0)*0.1)*0.7,0.5 +cos(iTime*(float(i)+3.0)*0.3)*0.3);\n    vec2 uv = fragCoord/iResolution.y;\n    int closest=-1; float dist;\n    for(int i=0;i<n;++i)\n    {\n        float candidatedist = distance(uv,x[i]);\n        if(closest==-1 || candidatedist<dist)\n        {\n            closest = i;\n            dist = candidatedist;\n        }\n    }\n    float prox0 = sin(dist*20.0)*0.1+0.3;\n    float prox1 = cos(dist*45.0)*0.1+0.3;\n    fragColor=vec4(prox0*0.7,prox1*0.8,prox0*1.4,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsSyRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "error"}
{"id": "wsSyRt", "name": "Plasma chessboard", "author": "Bjorn", "description": "My first Shader. <3", "tags": ["plasma", "chessboard"], "likes": 1, "viewed": 244, "published": "Public", "date": "1587138835", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col;\n    float minSize = 50.;\n    float mergez =0.;\n\n    float popx = cos(uv.x*minSize*(0.5+0.5*cos(iTime))-0.5*cos(iTime)*minSize*0.5);\n    float popy = cos(uv.y*minSize*(0.5+0.5*cos(iTime))-0.5*cos(iTime)*minSize*0.5);\n\n    if(popx<mergez ^^ popy<mergez){\n        //col = vec3(0,0,0);\n        col = vec3(0.5,0.5 + 0.5*cos(uv.xy+iTime));\n    }\n    else{\n        //col = vec3(1,1,1);\n        col = vec3(0.5 + 0.5*cos(uv.xy+iTime),0.5);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsSyRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "valid"}
{"id": "WsSyRy", "name": "eyespy", "author": "Del", "description": "raymarch blinking eye test - classic eye texture by IQ :)\nleft click + move mouse to look around... the usual\n - from in game  [url]https://www.youtube.com/watch?v=u3JePjNBRjM&feature=emb_logo[/url]", "tags": ["eye", "blink"], "likes": 2, "viewed": 94, "published": "Public", "date": "1586812152", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// simple raymarch blinking eye test using IQ's classic eye texture :)\n// optimized eye calc / texture lookup etc.\n\n#define MARCHSTEPS 80\n#define AA\t2\n#define PI\t3.1415926\n#define\tTAU\t6.28318\n\n// ---------------\n// IQ's classic eye texture \nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0;\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n}\n\nfloat fbm( vec2 p )\n{\n    float f = 0.50000*noise( p ); p = m*p*2.02;\n    f += 0.25000*noise( p ); p = m*p*2.03;\n    f += 0.12500*noise( p ); p = m*p*2.01;\n    f += 0.06250*noise( p ); p = m*p*2.04;\n    f += 0.03125*noise( p );\n    return f/0.984375;\n}\n\nfloat length2( vec2 p )\n{\n    vec2 q = p*p*p*p;\n    return pow( q.x + q.y, 1.0/4.0 );\n}\n\nvec3 eyetex(vec2 p)\n{\n\tfloat r = length( p );\n    float a = atan( p.y, p.x );\n    float dd = 0.2*sin(1.4*iTime);\n    float ss = 1.0 + clamp(1.0-r,0.0,1.0)*dd;\n    r *= ss;\n    vec3 col = vec3( 0.0, 0.3, 0.4 );\n    float f = fbm( 5.0*p );\n    col = mix( col, vec3(0.2,0.5,0.4), f );\n    col = mix( col, vec3(0.9,0.6,0.2), 1.0-smoothstep(0.2,0.6,r) );\n    a += 0.05*fbm( 20.0*p );\n    f = smoothstep( 0.3, 1.0, fbm( vec2(20.0*a,6.0*r) ) );\n    col = mix( col, vec3(1.0,1.0,1.0), f );\n    f = smoothstep( 0.4, 0.9, fbm( vec2(15.0*a,10.0*r) ) );\n    col *= 1.0-0.5*f;\n    col *= 1.0-0.25*smoothstep( 0.6,0.8,r );\n    f = 1.0-smoothstep( 0.0, 0.6, length2( mat2(0.6,0.8,-0.8,0.6)*(p-vec2(0.3,0.5) )*vec2(1.0,2.0)) );\n    //col += vec3(1.0,0.9,0.9)*f*0.985;\n    col *= vec3(0.8+0.2*cos(r*a));\n    f = 1.0-smoothstep( 0.2, 0.25, r );\n    col = mix( col, vec3(0.0), f );\n    f = smoothstep( 0.79, 0.82, r );\n    col = mix( col, vec3(1.0), f );    \n    return col;\n}\n// end of IQ's classic eye texture\n// ---------------\n\n// ----------\n// background stripes\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 SSTLines(vec2 duv, float nl, float grad,float thickness, float wibblesize, float wibblespeed, float glowintensity, float glowclamp, float extraglow)\n{\n   \tvec3 col2 =  hsv2rgb(vec3(iTime*0.025,0.5,0.5));\n    duv.y -= (floor(duv.x)*grad) + (duv.x*grad);\n    duv = fract(duv);\n    float l1 = abs(fract((duv.x*grad-duv.y)*nl) -0.5);\n    float dd = sin(iTime*wibblespeed+duv.x*6.28)*wibblesize;\n    l1 = min(glowclamp, (thickness+dd)/l1);\n    vec3 col = col2*l1*glowintensity+(dd*extraglow);\n    return mix(col2,col,l1);\n}\n\nvec3 background(vec2 uv)\n{\n    uv *= 0.5+sin(iTime)*0.25;\t// zoom\n    uv.y += iTime*0.1;\t\t\t// vscroll\n\treturn SSTLines(uv, 5.0, sin(iTime*0.35)*0.2, 0.15,  0.015, 6.5, 3.25, 1.0, 9.0);\n}\n//end of background stripes\n// ----------\n\nfloat pMod1(inout float p, float size)\n{\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nfloat ssub( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\n// simplified :)\nfloat _cindex = 0.0;\t\t\t// colour index\nfloat map( in vec3 p )\n{\n    float c = 3.3+pMod1(p.y,2.5);\n    p.x += sin(iTime+c*0.5)*4.0;\n    c *= 7.7+pMod1(p.x,2.5);\n    float d1 = length(p)-0.9;\n    float d2 = length(vec2(p.z-1.6,p.y))-(1.0-pow((sin( mod(iTime+c*0.35, 200.))*0.5+0.5), 40.));\n    d2 = ssub(d2, d1-0.1, 0.05);\n    _cindex = 2.0+step(d1,d2);\n    return  min(d2, d1);    \n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n// ----------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 bg = background(uv)*0.65;\n     // camera movement\t\n    float an = sin(iTime*0.7)*0.35;\n    float dist = 8.0+sin(iTime*0.8)*4.0;\n    an+=PI*0.5;\n    float y = 0.0;\n    \n    if (iMouse.z>0.5)\n    {\n        an=iMouse.x/iResolution.x*4.0;\n        y = (iMouse.y/iResolution.y)*8.0;\n        y-=4.0;\n    }\n    \n\tvec3 ro = vec3( dist*cos(an), -y, dist*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 40.0;\n        float t = 0.0;\n        for( int i=0; i<MARCHSTEPS; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n    \n        // shading/lighting\t\n        vec3 col = bg;\t//vec3(0.1);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n\n            // nasty :)\n            vec3 ambcol =  vec3(0.65, 0.4, 0.35);\n            if(_cindex > 2.5)\n\t\t\t\tambcol = eyetex(vec2((0.25-( atan(nor.z, nor.x) / TAU)) * 12.0, -( asin(nor.y) / PI)*6.0))*0.9;\n            col = (ambcol*ambcol)*(dif+0.25);\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    \n\tfragColor = vec4( tot, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsSyRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[292, 292, 315, 315, 354], [356, 356, 382, 382, 600], [602, 602, 623, 623, 854], [856, 856, 881, 881, 943], [945, 945, 966, 966, 1902], [1958, 1994, 2021, 2021, 2147], [2149, 2149, 2304, 2304, 2672], [2674, 2674, 2700, 2700, 2860], [2904, 2904, 2944, 2944, 3065], [3067, 3067, 3110, 3110, 3210], [3212, 3268, 3292, 3292, 3611], [3613, 3613, 3645, 3645, 3884]], "test": "error"}
{"id": "wsSyW3", "name": "HW_09_4 XuechengSun_Shadow", "author": "hehehaha12138", "description": "HW09 for CIS461 Shadow Scene", "tags": ["3d"], "likes": 0, "viewed": 36, "published": "Public", "date": "1587681649", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SQUARE_PLANE 0\n#define CUBE 1\n#define POINT_LIGHT 0\n#define FOCAL_LENGTH 8.0\n#define FOCAL_RANGE 20.0\nconst float AO_DIST = 0.15;\nconst float FIVETAP_K = 2.0;\n\nconst float FOVY = 3.141569 * 0.25;\nconst int RAY_STEPS = 256;\n\n// BSSRDF \n// The larger the DISTORTION, the smaller the glow\nconst float DISTORTION = 0.1;\n// The higher GLOW is, the smaller the glow of the subsurface scattering\nconst float GLOW = 1.0;\n// The higher the BSSRDF_SCALE, the brighter the scattered light\nconst float BSSRDF_SCALE = 3.0;\n// Boost the shadowed areas in the subsurface glow with this\nconst float AMBIENT = 0.0;\n// Toggle this to affect how easily the subsurface glow propagates through an object\n#define ATTENUATION 0\n\n// Shadow\nconst float SHADOW_HARDNESS = 40.0;\n\n\nstruct Intersection {\n    float t;\n    vec3 color;\n    vec3 p;\n    int object; // Assign every object in our scene a unique ID int\n};\n    \nstruct Transform\n{\n\tvec3 trans;\n    vec3 scale;\n    vec3 rotate;\n};\n\nstruct Primitive\n{\n\tint id;\n    Transform transform;\n    vec3 matColor;\n    int primitiveId;\n};\n    \nstruct Light\n{\n\tint id;\n    int typeId;\n    float intensity;\n    Transform transform;\n    vec3 lightColor;\n};\n   \n    \nPrimitive floorSquare;\nPrimitive redWall;\nPrimitive greenWall;\nPrimitive backWall;\nPrimitive ceilingWall;\nPrimitive shortCube;\nPrimitive longCube;\nLight pointLight;\nPrimitive primitives[3];\nLight lights[1];\n\nvoid initializeCornelBox()\n{\n    \n    \n    // Primitive initialization\n\tfloorSquare.transform.trans = vec3(0, -2.5, 0);\n\tfloorSquare.transform.rotate = vec3(-90, 0, 0);\n\tfloorSquare.transform.scale = vec3(10, 10, 1);\n    floorSquare.primitiveId = SQUARE_PLANE;\n    floorSquare.matColor = vec3(0.85, 0.81, 0.78);\n    primitives[0] = floorSquare;\n    \n    shortCube.transform.trans = vec3(-2, -1, 0.75);\n    shortCube.transform.rotate = vec3(0, -17.5, 0);\n\tshortCube.transform.scale = vec3(3, 3, 3);\n    shortCube.primitiveId = CUBE;\n    shortCube.matColor = vec3(0.85, 0.81, 0.78);\n    primitives[1] = shortCube;\n    \n    longCube.transform.trans = vec3(2, 0, 3);\n    longCube.transform.rotate = vec3(0, 27.5, 0);\n\tlongCube.transform.scale = vec3(3, 6, 3);\n    longCube.primitiveId = CUBE;\n    longCube.matColor = vec3(0.85, 0.81, 0.78);\n    primitives[2] = longCube;\n    \n \n    \n    // Light initlaization\n    pointLight.id = 0;\n    pointLight.typeId = POINT_LIGHT;\n    pointLight.intensity = 2.0;\n    pointLight.lightColor = vec3(17, 12, 4);\n    pointLight.transform.trans = vec3(0, 5.0, -5.0);\n    pointLight.transform.rotate = vec3(90, 0, 0);\n    pointLight.transform.scale = vec3(3, 3, 1);\n    \n    return;\n}\n\n// SDF of a sphere\nfloat sphere(vec3 p, float r, vec3 c) {\n    return distance(p, c) - r;\n}\n\nfloat random1( vec3 p ) {\n    return fract(sin((dot(p, vec3(127.1,\n                                  311.7,\n                                  191.999)))) *         \n                 43758.5453);\n}\n\nvec3 random3( vec3 p ) {\n    return fract(sin(vec3(dot(p,vec3(127.1, 311.7, 191.999)),\n                          dot(p,vec3(269.5, 183.3, 765.54)),\n                          dot(p, vec3(420.69, 631.2,109.21))))\n                 *43758.5453);\n}\n\n\nfloat WorleyNoise3D(vec3 p) {\n    // Tile the space\n    vec3 pointInt = floor(p);\n    vec3 pointFract = fract(p);\n\n    float minDist = 1.0; // Minimum distance initialized to max.\n\n    // Search all neighboring cells and this cell for their point\n    for(int z = -1; z <= 1; z++)\n    {\n        for(int y = -1; y <= 1; y++)\n        {\n            for(int x = -1; x <= 1; x++)\n            {\n                vec3 neighbor = vec3(float(x), float(y), float(z));\n\n                // Random point inside current neighboring cell\n                vec3 point = random3(pointInt + neighbor);\n\n                // Animate the point\n                point = 0.5 + 0.5 * sin(iTime * 0.01 + 6.2831 * point); // 0 to 1 range\n\n                // Compute the distance b/t the point and the fragment\n                // Store the min dist thus far\n                vec3 diff = neighbor + point - pointFract;\n                float dist = length(diff);\n                minDist = min(minDist, dist);\n            }\n        }\n    }\n    return minDist;\n}\n\nvoid CoordinateSystem(in vec3 v1, out vec3 v2, out vec3 v3) {\n    if (abs(v1.x) > abs(v1.y))\n            v2 = vec3(-v1.z, 0.0, v1.x) / sqrt(v1.x * v1.x + v1.z * v1.z);\n        else\n            v2 = vec3(0.0, v1.z, -v1.y) / sqrt(v1.y * v1.y + v1.z * v1.z);\n        v3 = cross(v1, v2);\n}\n\nvec3 WorleyTangentSpaceNormal(vec3 pos) {\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( WorleyNoise3D(pos + epsilon.yxx) - WorleyNoise3D(pos - epsilon.yxx),\n                            WorleyNoise3D(pos + epsilon.xyx) - WorleyNoise3D(pos - epsilon.xyx),\n                            WorleyNoise3D(pos + epsilon.xxy) - WorleyNoise3D(pos - epsilon.xxy)));\n\n}\n\n    \n    \nmat4 transformMatrix(Transform t)\n{\n\tmat4 translate = mat4(      1.0,       0.0,       0.0, 0.0,\n                                0.0,       1.0,       0.0, 0.0,\n                                0.0,       0.0,       1.0, 0.0,\n                                t.trans.x,       t.trans.y,       t.trans.z, 1.0);\n    \n    float xRot = radians(t.rotate.x);\n    float yRot = radians(t.rotate.y);\n    float zRot = radians(t.rotate.z);\n    \n    mat4 rotateX = mat4(1.0,        0.0,       0.0, 0.0,\n                        0.0,  cos(xRot), sin(xRot), 0.0,\n                        0.0, -sin(xRot), cos(xRot), 0.0,\n                        0.0,        0.0,       0.0, 1.0);\n    \n    mat4 rotateY = mat4(cos(yRot), 0.0, -sin(yRot), 0.0,\n                              0.0, 1.0,        0.0, 0.0,\n                        sin(yRot), 0.0,  cos(yRot), 0.0,\n                              0.0, 0.0,        0.0, 1.0);\n    \n    mat4 rotateZ = mat4( cos(zRot), sin(zRot), 0.0, 0.0,\n                        -sin(zRot), cos(zRot), 0.0, 0.0,\n                               0.0,       0.0, 1.0, 0.0,\n                               0.0,       0.0, 0.0, 1.0);\n    \n    mat4 scale = mat4(      t.scale.x,       0.0,       0.0, 0.0,\n                            0.0,       t.scale.y,       0.0, 0.0,\n                            0.0,       0.0,       t.scale.z, 0.0,\n                            0.0,       0.0,       0.0, 1.0);\n    \n    return translate * rotateX * rotateY * rotateZ * scale;\n}\n\nmat4 rotMat(Transform t)\n{\n\tfloat xRot = radians(t.rotate.x);\n    float yRot = radians(t.rotate.y);\n    float zRot = radians(t.rotate.z);\n    \n    mat4 rotateX = mat4(1.0,        0.0,       0.0, 0.0,\n                        0.0,  cos(xRot), sin(xRot), 0.0,\n                        0.0, -sin(xRot), cos(xRot), 0.0,\n                        0.0,        0.0,       0.0, 1.0);\n    \n    mat4 rotateY = mat4(cos(yRot), 0.0, -sin(yRot), 0.0,\n                              0.0, 1.0,        0.0, 0.0,\n                        sin(yRot), 0.0,  cos(yRot), 0.0,\n                              0.0, 0.0,        0.0, 1.0);\n    \n    mat4 rotateZ = mat4( cos(zRot), sin(zRot), 0.0, 0.0,\n                        -sin(zRot), cos(zRot), 0.0, 0.0,\n                               0.0,       0.0, 1.0, 0.0,\n                               0.0,       0.0, 0.0, 1.0);\n    \n    return rotateX * rotateY * rotateZ;\n}\n\nmat3 TangentToWorld(vec3 nor) {\n\tvec3 tangent, bitangent;\n    CoordinateSystem(nor, tangent, bitangent);\n    return mat3(tangent, bitangent, nor);\n}\n\n// Cube SDF\nfloat cube(vec3 p, Transform cubeTrans)\n{\n\tvec3 q = vec3(abs(inverse(transformMatrix(cubeTrans)) * vec4(p, 1.0))) - vec3(0.5);\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// SquarePlane SDF\nfloat squarePlane(vec3 p, Transform squareTrans)\n{\n    mat4 squareMat = transformMatrix(squareTrans);\n    vec3 planeNormal = vec3(0, 0, 1);\n    vec3 actualPoint = vec3(inverse(squareMat) * vec4(p, 1.0f));    \n\treturn abs(dot(actualPoint, planeNormal));\n}\n\nfloat squarePlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p, n.xyz) + n.w;\n}\n\n\nbool isOnPlane(vec3 p, Transform squareTrans)\n{\n    mat4 squareMat = transformMatrix(squareTrans);\n\tvec3 ap = vec3(inverse(squareMat) * vec4(p, 1.0));\n    if(ap.x < 0.5f && ap.x > -0.5f && ap.y < 0.5f && ap.y > -0.5f)\n    {\n    \treturn true;\n    }\n    else\n    {\n    \treturn false;\n    }\n}\n\n\nvoid sceneMap3D(vec3 pos, out float t, out int obj)\n{\n    float minT = 10000.0;\n    obj = -1;\n    for(int i = 0; i < primitives.length(); i = i + 1)\n    {\n        if(primitives[i].primitiveId == SQUARE_PLANE)\n        {\n            vec4 curNor = normalize(rotMat(primitives[i].transform) * vec4(0.0, 0.0, 1.0, 0.0));\n            float maxOffset = max(max(abs(primitives[i].transform.trans.x), \n                                      abs(primitives[i].transform.trans.y)), \n                                      abs(primitives[i].transform.trans.z));\n            curNor.w = maxOffset;\n        \tt = squarePlane(pos, curNor);\n        }\n        else if(primitives[i].primitiveId == CUBE)\n        {\n        \tt = cube(pos, primitives[i].transform);\n        }\n        \n       \n        \n        if(t < minT)\n        {\n        \tminT = t;\n            obj = i;\n        }\n    }\n   \n    t = minT;\n}\n\n/*void sceneMap3D(vec3 pos, out float t, out int obj) {\n    t = cube(pos, longCube.transform);\n    obj = CUBE_1_ID;\n    \n    float t2;\n    if((t2 = SPHERE_2_SDF) < t) {\n        t = t2;\n        obj = SPHERE_2_ID;\n    }\n}*/\n\nfloat sceneMap3D(vec3 pos)\n{\n    float minT = 10000.0;\n    float t = minT;\n    for(int i = 0; i < primitives.length(); i++)\n    {\n        if(primitives[i].primitiveId == SQUARE_PLANE)\n        {\n        \tvec4 curNor = normalize(rotMat(primitives[i].transform) * vec4(0.0, 0.0, 1.0, 0.0));\n            float maxOffset = max(max(abs(primitives[i].transform.trans.x), \n                                      abs(primitives[i].transform.trans.y)), \n                                      abs(primitives[i].transform.trans.z));\n            curNor.w = maxOffset;\n        \tt = squarePlane(pos, curNor);\n        }\n        else if(primitives[i].primitiveId == CUBE)\n        {\n        \tt = cube(pos, primitives[i].transform);\n        }\n        \n       \n        if(t < minT)\n        {\n        \tminT = t;\n        }\n    }\n    t = minT;\n    return t;\n}\n\nfloat softShadow(vec3 dir, vec3 origin, float min_t, float k) {\n    float res = 1.0;\n    float t = min_t;\n    for(int i = 0; i < RAY_STEPS; ++i) {\n        float m = -1.0;\n        int obj = -1;\n        sceneMap3D(origin + t * dir, m, obj);\n        if(m < 0.0001) \n           return 0.0;\n        res = min(res, k * m / t);\n        t += m;\n    }\n    return res;\n}\n\nfloat fiveTapAO(vec3 p, vec3 n, float k) {\n    float aoSum = 0.0;\n    for(float i = 0.0; i < 5.0; ++i) {\n        float coeff = 1.0 / pow(2.0, i);\n        aoSum += coeff * (i * AO_DIST - sceneMap3D(p + n * i * AO_DIST));\n    }\n    return 1.0 - k * aoSum;\n}\n\nvec3 computeNormal(vec3 pos) {\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( sceneMap3D(pos + epsilon.yxx) - sceneMap3D(pos - epsilon.yxx),\n                            sceneMap3D(pos + epsilon.xyx) - sceneMap3D(pos - epsilon.xyx),\n                            sceneMap3D(pos + epsilon.xxy) - sceneMap3D(pos - epsilon.xxy)));\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj) {\n    t = 0.001;\n    for(int i = 0; i < RAY_STEPS; ++i) {\n        vec3 pos = origin + t * dir;\n    \tfloat m;\n        sceneMap3D(pos, m, hitObj);\n        if(primitives[hitObj].primitiveId == CUBE)\n        {\n        \tif(abs(m) < 0.01) \n                return;\n        }\n        else if(primitives[hitObj].primitiveId == SQUARE_PLANE)\n        {\n            if(abs(m) < 0.01) \n            {\n            \treturn;\n            }\n        \t\n        }\n        t += m;\n    }\n    t = -1.0;\n    hitObj = -1;\n}\n\nconst vec3 a = vec3(0.5, 0.5, 0.5);\nconst vec3 b = vec3(0.5, 0.5, 0.5);\nconst vec3 c = vec3(2.0, 1.0, 1.0);\nconst vec3 d = vec3(0.5, 0.2, 0.25);\n\nvec3 colorPalette(float t) {\n    return a + b * cos(6.28 * (t * c + d));\n}\n\nfloat subsurface(vec3 lightDir, vec3 normal, vec3 viewVec, float thickness) {\n    vec3 scatteredLightDir = lightDir + normal * DISTORTION;\n    float lightReachingEye = pow(clamp(dot(viewVec, scatteredLightDir), 0.0, 1.0), GLOW) * BSSRDF_SCALE;\n    float attenuation = 1.0;\n    #if ATTENUATION\n    attenuation = max(0.0, dot(normal, lightDir) + dot(viewVec, -lightDir));\n    #endif\n\tfloat totalLight = attenuation * (lightReachingEye + AMBIENT) * thickness;\n    return totalLight;\n}\n\nvec3 computeMaterial(int hitObj, vec3 p, vec3 n, vec3 light, vec3 view, float thick) {\n    vec3 lightVec = normalize(light - p);\n    float lambert = max(0.0, dot(lightVec, n));\n    if(hitObj == -1)\n        return vec3(0.0, 0.0, 0.0);\n    if(hitObj == 1)\n    {\n    \tvec3 color = primitives[hitObj].matColor * lambert * vec3(1.0, 1.0, 1.0);\n        float sub = subsurface(lightVec, n, view, thick);\n        color = color + vec3(1.0, 0.0, 0.0) * sub * vec3(1.0, 1.0, 1.0);\n        //color = vec3(sub);\n        color *= softShadow(lightVec, p, 0.1, SHADOW_HARDNESS);\n    \treturn color;\n    }\n    vec3 color = primitives[hitObj].matColor * lambert * vec3(1.0, 1.0, 1.0);\n\tcolor *= softShadow(lightVec, p, 0.1, SHADOW_HARDNESS);\n    return color;\n    \n}\n\nvec3 rotateY(vec3 p, float a) {\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\nIntersection sdf3D(vec3 dir, vec3 eye) {\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj);\n\n    vec3 isect = eye + t * dir;\n    vec3 nor = computeNormal(isect);\n    isect = isect + 0.01 * nor;\n    //vec3 lightDir = normalize(lightPos - isect);\n    \n    vec3 light = rotateY(pointLight.transform.trans, iTime);\n    float thickness = fiveTapAO(isect, -nor, FIVETAP_K);\n    \n    vec3 surfaceColor = computeMaterial(hitObj, isect, nor, light, normalize(eye - isect), thickness);\n   \t\n    \n    vec3 normalAsColor = 0.5 * (nor + vec3(1.0, 1.0, 1.0));\n    \n    return Intersection(t, surfaceColor, isect, hitObj);\n}\n\n\n\n\n// Returns direction of ray\nvec3 rayCast(vec3 eye, vec3 ref, vec2 ndc) {\n    vec3 F = ref - eye;\n    vec3 R = normalize(cross(F, vec3(0,1,0)));\n    vec3 U = normalize(cross(R, F)); \n    \n    vec3 V = U * length(F) * tan(FOVY * 0.5);\n    vec3 H = R * length(F) * tan(FOVY * 0.5) * float(iResolution.x) / iResolution.y;\n    \n    vec3 p = ref + ndc.x * H + ndc.y * V;\n    \n    return normalize(p - eye);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initializeCornelBox();\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    // Convert to range [-1, 1]\n    uv = uv * 2.0 - vec2(1.0, 1.0);\n    \n    vec3 eye = vec3(0, 4, -15);\n    vec3 ref = vec3(0, 2, 0);\n    \n    vec3 rayDir = rayCast(eye, ref, uv);\n    \n    Intersection isect = sdf3D(rayDir, eye);\n    \n    float focalLength = (sin(iTime) *  FOCAL_RANGE +  FOCAL_RANGE) / 2.0;\n\t\n    vec3 focalLine = isect.p - eye;\n    float distance = length(focalLine);\n    float disAlongCamZ = dot(focalLine, normalize(ref - eye));\n    float t = abs(disAlongCamZ - focalLength) / FOCAL_RANGE;\n    \n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    //fragColor = vec4(0.5 * (rayDir + vec3(1., 1., 1.)), 1.0);\n    fragColor = vec4(isect.color, t);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsSyW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1398, 1398, 1426, 1468, 2610], [2612, 2631, 2670, 2670, 2703], [2705, 2705, 2730, 2730, 2901], [2903, 2903, 2927, 2927, 3146], [3149, 3149, 3178, 3200, 4173], [4175, 4175, 4236, 4236, 4460], [4462, 4462, 4503, 4503, 4841], [4853, 4853, 4888, 4888, 6312], [6314, 6314, 6340, 6340, 7200], [7202, 7202, 7233, 7233, 7350], [7352, 7364, 7405, 7405, 7560], [7562, 7581, 7631, 7631, 7835], [7837, 7837, 7874, 7900, 7932], [7935, 7935, 7982, 7982, 8224], [8227, 8227, 8280, 8280, 9110], [9335, 9335, 9363, 9363, 10170], [10172, 10172, 10235, 10235, 10532], [10534, 10534, 10576, 10576, 10789], [10791, 10791, 10821, 10821, 11140], [11142, 11142, 11206, 11206, 11701], [11849, 11849, 11877, 11877, 11923], [11925, 11925, 12002, 12002, 12406], [12408, 12408, 12494, 12494, 13155], [13157, 13157, 13188, 13188, 13271], [13273, 13273, 13313, 13313, 13892], [13897, 13925, 13969, 13969, 14299], [14301, 14301, 14358, 14358, 15213]], "test": "error"}
{"id": "wssyWj", "name": "noise_test_ooo", "author": "ooo198632", "description": "cell?", "tags": ["2dnoise"], "likes": 2, "viewed": 39, "published": "Public", "date": "1585712410", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float freq = 5.;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    //uv.x *= iResolution.x/iResolution.y;\n    vec2 uv1;\n      uv1.y = uv.y * freq;\n    uv1.x = uv.x * freq*iResolution.x/iResolution.y;\n   // uv1.x = clamp(uv1.x,0.,5.);\n    //uv *= 5.;\n    //uv.x = clamp(uv.x,0.,5.);\n    \n    vec2 i_st = floor(uv1);\n    vec2 f_st = fract(uv1);\n    \n    vec2 point[5];\n    point[0] = vec2(0.83,0.75);\n    point[1] = vec2(0.60,0.07);\n    point[2] = vec2(0.28,0.64);\n    point[3] =  vec2(0.31,0.26);\n    \n    point[4] = vec2(0.53,0.75);\n    \n    vec2 point_m;\n    \n    point_m = iMouse.xy/iResolution.xy;\n    \n        \n    point_m.x *= iResolution.x/iResolution.y;\n    \n    float m_dist = 1.;  // minimun distance\n\n    // Iterate through the points positions\n    for (int i = 0; i < 5; i++) {\n        point[i] = 0.5 + 0.5*sin(iTime + 6.2831*point[i]);\n        float dist = distance(uv, point[i]);\n        float dist1 = clamp(distance(uv1, point_m),0.0,1.0);\t\n\n        // Keep the closer distance\n        m_dist = min(m_dist, dist);\n        m_dist = min(m_dist,dist1);\n    }\n    \n    float m_dist1 = 1.; \n     \n    for(int x = -1;x <= 1;x++){\n        for(int y = -1;y <= 1 ;y++){\n             vec2 neighbor = vec2(float(x),float(y));\n            if(iMouse.xy==vec2(0))\n        point_m = random2(i_st + neighbor);\n             vec2 point = random2(i_st + neighbor);\n             point = 0.5 + 0.5*sin(iTime + 6.2831*point);\n            // vec2 diff = point+neighbor-f_st;\n             float dist = distance(f_st, point+neighbor);\n            \n             //float dist = length(diff);\n             m_dist1 = min(m_dist1, dist);\n            \n        }\n    }\n    float distM = distance(uv1, point_m*freq);\t\n     \n    //float dist2 = clamp(distance(uv, point_m),0.0,1.0);\n\t\n    // Time varying pixel color\n   vec3 col = mix(vec3(1.,0.,0.),vec3(0.,1.,0.),smoothstep(0.,1.,(distM - m_dist1)));\n\t//\tcol = vec3(m_dist);\n    m_dist1 = min(m_dist1, distM);\n    col = mix(col,vec3(0.,0,0.),m_dist1);\n    col += 1.-step(.02, m_dist1);\n     col += (1.- smoothstep(0.,0.08,m_dist1))*0.5;\n    \n    //col.r += step(.98, f_st.x) + step(.98, f_st.y);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wssyWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 117], [119, 119, 176, 176, 2412]], "test": "valid"}
{"id": "wsSyWV", "name": "Ink-Marbling Fractal", "author": "jarble", "description": "This is based on my [url=https://www.shadertoy.com/view/tlGSDG]\"Swamps and Tundras\"[/url] fractal. It looks very much like suminagashi.\nClick and drag the mouse to zoom in and out!", "tags": ["fractal", "marbling", "suminagashi"], "likes": 1, "viewed": 197, "published": "Public API", "date": "1587322404", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//This parameter changes the number of iterations.\nconst float mag = 9.0;\nconst float GREEN = 0.;\nconst float BLUE = 1.;\nconst float GRAY = 2.;\nconst float YELLOW = 3.;\nconst float WHITE = 4.;\nconst float RED = 5.;\n\n\n//this function is from https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n    float num_colors = 5.0;\n    //set the number of colors to be randomly generated\n    \n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return floor(fract((p3.x + p3.y) * p3.z)*num_colors);\n}\n    \n\n\nfloat magnify(vec2 fragCoord,float mag){\n    return hash12(floor(fragCoord/pow(3.0,mag)));\n}\n\nvec4 get_neighbors(vec2 fragCoord,float mag){\n    return vec4(magnify(fragCoord+vec2(0,1),mag),\n        magnify(fragCoord+vec2(1,0),mag),\n        magnify(fragCoord-vec2(0,1),mag),\n        magnify(fragCoord-vec2(1,0),mag));\n}\n\n\nbool is_next_to(float color,vec4 neighbors){\n\treturn (neighbors.x == color)\n        || (neighbors.y == color)\n        || (neighbors.z == color)\n        || (neighbors.w == color);\n}\n\n\n\nvec3 get_color(float color){\n    if(color == BLUE){\n    \treturn vec3(0.149,0.141,0.912);\n   \t}\n    else if(color == GREEN){\n    \treturn vec3(0.000,0.833,0.224);\n   \t}\n    else if(color == RED){\n    \treturn vec3(1.0,0.0,0.0);\n   \t}\n    else if(color == WHITE){\n    \treturn vec3(1.0,1.0,1.0);\n   \t}\n    else if(color == GRAY){\n    \treturn vec3(192.0,192.0,192.0)/255.0;\n    }\n    else if(color == YELLOW){\n    \treturn vec3(1.0,1.0,0.0);\n   \t}\n}\n\nvec3 iterations(float color1,in vec2 fragCoord,float mag){\n    float colors[] = float[](GREEN,BLUE,GRAY,YELLOW,WHITE,RED);\n    float mag1 = mag;\n    vec4 neighbors;\n    vec3 color;\n    float steps = 0.0;\n    while(mag > 1.0){\n        float avg =(100.0*(mag/color1));\n        fragCoord += vec2(sin(fragCoord.y/avg)*10.0,sin(fragCoord.x/(avg))*10.0)*mag*mag;\n\n        neighbors = get_neighbors(fragCoord,mag);\n    color1 = color1 == GREEN && is_next_to(BLUE,neighbors)\n    \t? YELLOW\n    :color1 == BLUE && is_next_to(GREEN,neighbors)\n        ? GREEN\n    :color1 == YELLOW && is_next_to(GRAY,neighbors)\n        ? BLUE\n    :color1 == GRAY && is_next_to(YELLOW,neighbors)\n        ? YELLOW\n    :color1 == WHITE && is_next_to(YELLOW,neighbors)\n        ? GRAY\n    :color1 == GRAY && is_next_to(BLUE,neighbors)\n        ? BLUE\n    :color1;\n\n    color += get_color(color1);\n    //mag -= 1.0+(sin(fragCoord.x+iTime)+cos(fragCoord.y+iTime))*0.0002;\n    mag -= 1.0;\n    steps += 1.0;\n\n    }\n    return color/steps;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord *= mag*(((iMouse.x-iMouse.y)+iResolution.x)/iResolution.x);\n    fragCoord = fragCoord + floor(iTime*100.0)*vec2(mag,0.0);\n    fragCoord += vec2(sin(fragCoord.y/(100.0*(mag)))*10.0,sin(fragCoord.x/(100.0*(mag)))*10.0)*mag*mag;\n\n    float color1 = magnify(fragCoord,mag);\n    //color1 = replace_pattern(mat2(1.0,1.0,1.0,1.0),mat2(0.0,2.0,2.0,0.0),fragCoord,mag);\n\n    vec3 color2 = iterations(color1,fragCoord,mag-1.0);\n\n    fragColor = vec4(color2,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsSyWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[218, 280, 302, 302, 529], [537, 537, 577, 577, 629], [631, 631, 676, 676, 855], [858, 858, 902, 902, 1038], [1042, 1042, 1070, 1070, 1484], [2491, 2491, 2547, 2547, 3016]], "test": "error"}
{"id": "WsSyzd", "name": "Chip Mandelbrot", "author": "chipbell4", "description": "Rendering the mandelbrot set", "tags": ["fractal"], "likes": 2, "viewed": 56, "published": "Public", "date": "1587654518", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int N = 300;\nconst float EPSILON = 0.001;\n\n\n#define p(x) (max(0.0, 4.0 * (x) * (1.0 - (x))))\n\nvec3 color(float t) {\n    float r = p(t * 2.0);\n    float g = p(t * 2.0 - 0.5);\n    float b = p(t * 2.0 - 1.0);\n    \n    return vec3(r, g, b);\n}\n\nvec2 complex_exponent(vec2 c1, float f) {\n    float r = length(c1);\n    float phi = atan(c1.y, c1.x);\n    \n    float r_exponent = pow(r, f);\n\n    return vec2(r_exponent * cos(f * phi), r_exponent * sin(f * phi));\n}\n\nvec2 mult_complex(vec2 c1, vec2 c2) {\n    return vec2(c1.x * c2.x - c1.y * c2.y, c1.x * c2.y + c1.y * c2.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ( fragCoord -.5* iResolution.xy) / iResolution.y;\n    \n    // our uv coordinates, transformed to make the shape fit the window more nicely\n    vec2 c = 3. * uv;\n    \n    // our exponent for composed function. 2.0 is a mandelbrot set, but many exponents look good!\n    float min_exponent = 2.0;\n    float max_exponent = 10.0;\n    float exponent = (min_exponent + max_exponent) * 0.5 + (max_exponent - min_exponent) * 0.5 * sin(iTime * 1.0);\n    \n    vec2 z = vec2(0., 0.);\n    vec2 f = z;\n    for (int i = 0; i < N; i++) {\n        f = complex_exponent(f, exponent) + c;\n    }\n    \n    float d = distance(f, z);\n    \n  \tfloat intensity = (1.0 - d) * (1.0 - d);\n    \n    fragColor = vec4(color(intensity), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsSyzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 100, 121, 121, 244], [246, 246, 287, 287, 460], [462, 462, 499, 499, 572], [574, 574, 631, 681, 1406]], "test": "valid"}
{"id": "WsXBD4", "name": "A first raymarcher", "author": "CraftedCart", "description": "I started off with https://www.youtube.com/watch?v=PGtv-dBi2wE and tried adding some more shapes, a spinning camera, multiple lights, and soft shadows :)", "tags": ["3d", "raymarching"], "likes": 0, "viewed": 259, "published": "Public API", "date": "1588214279", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Tutorial videos\n// ===============\n// https://www.youtube.com/watch?v=PGtv-dBi2wE\n\n#define M_PI 3.1415926535897932384626433832795\n\nconst int MAX_MARCHING_STEPS = 100; // How many marching iterations should we do before giving up\nconst float MAX_MARCHING_DIST = 100.0; // How far should we march for before giving up and calling it \"sky\"\nconst float MARCHING_SURFACE_DIST = 0.01; // How close should we march towards some geometry before we consider it a hit\nconst float MAX_LIGHT_BOUNCES = 6.0; // How many times we should attempt to bounce light in shadowed areas before giving up\n\nconst vec3 WORLD_UP = vec3(0.0, 1.0, 0.0);\nconst vec3 VIEW_TARGET = vec3(0.0, 2.5, 0.0);\nconst float ZOOM_FAC = 1.0;\n\nconst vec3 COL_PINK = vec3(0.969, 0.659, 0.722);\nconst vec3 COL_BLUE = vec3(0.333, 0.804, 0.988);\n\n/** Given a point in 3D space, figure out how far away we are from the nearest piece of geometry */\nfloat getDistToGeom(vec3 point) {\n    float minDist = MAX_MARCHING_DIST;\n\n    // Sphere object\n    vec3 sphere1Pos = vec3(-2.0, 1.0, 0.0);\n    float sphere1Radius = 1.0;\n    float sphere1Dist = length(point - sphere1Pos) - sphere1Radius;\n    minDist = min(minDist, sphere1Dist);\n\n    // Sphere object\n    vec3 sphere2Pos = vec3(2.0, 0.5, 0.0);\n    float sphere2Radius = 0.5;\n    float sphere2Dist = length(point - sphere2Pos) - sphere2Radius;\n    minDist = min(minDist, sphere2Dist);\n\n    // Many sphere objects\n    float rot = sin(iTime * 2.0) * 0.5 + 0.5;\n    for (float i = 0.0; i < 2.0 * M_PI; i += M_PI / 6.0) {\n        // vec3 spherePos = vec3(cos(i * 4) + sin(iTime * 2 + i), 4 + sin(i * 4) + cos(iTime * 2 + i), sin(i));\n        vec3 spherePos = vec3(sin(iTime * 4.0 + i) * (1.0 - rot) + cos(iTime * 4.0 + i) * rot, 3.0 + cos(iTime + i), sin(iTime * 4.0 + i) * rot + cos(iTime * 4.0 + i) * (1.0 - rot));\n        float sphereRadius = 0.15;\n        float sphereDist = length(point - spherePos) - sphereRadius;\n        minDist = min(minDist, sphereDist);\n    }\n\n    // Ground plane distance can be calculated as just the point offset from the ground\n    float planeDist = point.y;\n    minDist = min(minDist, planeDist);\n\n    // Return whatever distance is closest to the point\n    return minDist;\n}\n\n/** Given a ray origin and ray direction, figure out how far the ray goes before hitting some geometry */\nfloat rayMarch(vec3 rayOrigin, vec3 rayDir) {\n    float distFromOrigin = 0.0;\n\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec3 currentPos = rayOrigin + rayDir * distFromOrigin;\n\n        float distToGeom = getDistToGeom(currentPos);\n        distFromOrigin += distToGeom; // March forward\n\n        // Check if we should exit the loop\n        if (distFromOrigin > MAX_MARCHING_DIST || distToGeom < MARCHING_SURFACE_DIST) break;\n    }\n\n    return distFromOrigin;\n}\n\n/** Given a point on a surface in 3D space, figure out its normal direction */\nvec3 getNormal(vec3 point) {\n    float dist = getDistToGeom(point);\n\n    return normalize(dist - vec3(\n                getDistToGeom(point - vec3(0.01, 0.0, 0.0)),\n                getDistToGeom(point - vec3(0.0, 0.01, 0.0)),\n                getDistToGeom(point - vec3(0.0, 0.0, 0.01))\n                ));\n}\n\n/** Gets the pixel color of a point in 3D space */\nfloat getLight(vec3 point, vec3 lightPos) {\n    vec3 lightDir = normalize(lightPos - point);\n    vec3 surfaceNorm = getNormal(point);\n\n    float diffuse = max(0.0, dot(lightDir, surfaceNorm));\n\n    // Now, let's raymarch towards our light source\n    // if it turns out we can't raymarch all the way to the light, that means we hit an object along the way\n    // meaning we should be in shadow\n\n    // Adjust the point so we don't start inside some geometry\n    bool rayEscaped = false;\n    for (float i = 0.0; i < MAX_LIGHT_BOUNCES; i++) {\n        vec3 pointAdj = point + surfaceNorm * MARCHING_SURFACE_DIST * 3.0;\n\n        float distTowardsLight = rayMarch(pointAdj, lightDir);\n        if (distTowardsLight < length(lightPos - point)) {\n            // We hit something - let's do a light bounce\n            vec3 hitPoint = pointAdj + lightDir * distTowardsLight;\n            vec3 hitNormal = getNormal(hitPoint);\n\n            float bounceMarchDist = rayMarch(hitPoint, hitNormal);\n            vec3 bouncePoint = hitPoint + hitNormal * bounceMarchDist;\n            vec3 bounceNorm = getNormal(bouncePoint);\n\n            diffuse *= pow(1.0 - (1.0 / MAX_LIGHT_BOUNCES), i);\n\n            point = bouncePoint;\n            surfaceNorm = bounceNorm;\n        } else {\n            rayEscaped = true;\n        }\n    }\n\n    // If a ray never made it to the light source, make it pitch black\n    if (!rayEscaped) {\n        diffuse = 0.0;\n    }\n\n    return diffuse;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float ratio = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord / iResolution.xy;\n\n    uv -= 0.5; // Move the origin to the middle of the screen\n    uv.x *= ratio; // Account for the aspect ratio\n\n    vec3 col = vec3(0.0, 0.0, 0.0);\n\n    vec3 rayOrigin = vec3(cos(iTime * 0.2) * 12.0, 1.5 + sin(iTime * 0.5), sin(iTime * 0.2) * 12.0); // Camera position\n\n    vec3 camForward = normalize(VIEW_TARGET - rayOrigin);\n    vec3 camRight = normalize(cross(WORLD_UP, camForward));\n    vec3 camUp = cross(camForward, camRight);\n\n    vec3 screenCenter = rayOrigin + camForward * ZOOM_FAC; // Figure out where the center of the screen is in 3D space\n    vec3 intersectPoint = screenCenter + (uv.x * camRight) + (uv.y * camUp);\n\n    vec3 rayDir = intersectPoint - rayOrigin;\n\n    float rayDist = rayMarch(rayOrigin, rayDir);\n    vec3 point = rayOrigin + rayDir * rayDist; // Get the point in 3D space\n\n    vec3 lightPos;\n    lightPos = vec3(0.0 + sin(iTime * 1.5) * 8.0, 5.0, 6.0 + cos(iTime * 1.5) * 8.0);\n    col += getLight(point, lightPos) * COL_BLUE * (sin(iTime * 0.3) + 1.0) * 0.5;\n\n    lightPos = vec3(0.0 + sin(iTime) * 2.0, 2.0, 6.0 + cos(iTime) * 2.0);\n    col += getLight(point, lightPos) * COL_PINK * (cos(iTime * 0.3) + 1.0) * 0.5;\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsXBD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[803, 903, 936, 936, 2206], [2208, 2314, 2359, 2359, 2790], [2792, 2871, 2899, 2899, 3177], [3179, 3230, 3273, 3273, 4684], [4686, 4686, 4741, 4741, 6043]], "test": "valid"}
{"id": "WsXBR4", "name": "Amiga Man Made of Mirrors", "author": "dagelf", "description": "Cheap remix of https://www.shadertoy.com/view/llXSWr\n\nClick and drag!", "tags": ["raymarching", "spheres", "reflections", "mirror", "humanoid"], "likes": 4, "viewed": 231, "published": "Public", "date": "1587729768", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// My AMIGA's 30th anniversary contribution.\n\n// started from iq primitives.\n// switched to a pure raytracing approach\n// added the text title borrowing code from https://www.shadertoy.com/view/Mt2GWD\n//\n// This is my first shadertoy.com production :D\n// so veeery far to be considered a well written and optimized code :D.\n// Heavly inspired from http://meatfighter.com/juggler/ and totally rebuilt on GLSL.\n\n// This is the Amiga Juggler , a raytracing animation by Eric Graham 86/87 ... yes,\n// 28 years ago!. I think this is one of the most inspiring piece\n// of digital art made on Amiga after all :D.\n// I desired to see it in real time since I've seen it\n// on my Amiga, tons of years ago, It was provided as a playback of a precalculated movie.\n\n// I'll try to post a little more about this shader on my new blog next days\n//  www.ereticus.com\n// a site where I , @pellicus, will rant some heresies ;) and ideas about graphic stuff, shaders,\n// raytracing and alternative rendering techs, engine3ds, unity plugins, and stuff like\n// that looking at videogames\n// and multimedia productions perspective.\n\n// Thanks you all for watching. :D\n// Genoa (Italy), 1 july 2015\n// Dario Pelella (@pellicus or dario.pelella on FB)\n\n// Edit by dagelf:\n// I never owned an Amiga, but I think this was close to the first computer graphics I saw in primary school in the 80's. \n// ... been hooked ever since. \n\n// ===============================================================\n// VECTOR TEXT TITLE  ============================================\n// ===============================================================\nvec2 g_pen;\nvec4 g_out_color;\n\nvoid tris(vec2 a, vec2 c,vec2 b)\n{\n    vec2 pa = g_pen-a;\n    bool si = (b.x-a.x)*pa.y-(b.y-a.y)*pa.x > 0.0;\n    vec2 ca= c-a;\n    if ((ca.x)*pa.y-(ca.y)*pa.x > 0.0 == si) return;\n    vec2 cb=c-b;\n    if (cb.x*(g_pen.y-b.y)-cb.y*(g_pen.x-b.x) > 0.0 != si) return;\n    g_out_color = vec4(1,1,1,1);\n}\n\nvoid vector_text()\n{\n    vec2 uv=g_pen;\n    \n    \n    vec2 off= abs(uv-vec2(0.125000,0.125000)) - vec2(0.125000); if( off.x <= 0.0 || off.y <=  0.0)\n    { tris(vec2(0.207,0.005),vec2(0.210,0.010),vec2(0.133,0.006));tris(vec2(0.090,0.005),vec2(0.095,0.012),vec2(0.005,0.005));tris(vec2(0.095,0.012),vec2(0.000,0.011),vec2(0.005,0.005));tris(vec2(0.210,0.010),vec2(0.129,0.012),vec2(0.133,0.006));tris(vec2(0.095,0.012),vec2(0.002,0.016),vec2(0.000,0.011));tris(vec2(0.210,0.010),vec2(0.205,0.017),vec2(0.129,0.012));tris(vec2(0.095,0.012),vec2(0.090,0.017),vec2(0.002,0.016));tris(vec2(0.205,0.017),vec2(0.136,0.018),vec2(0.129,0.012));tris(vec2(0.205,0.017),vec2(0.196,0.019),vec2(0.136,0.018));\n        tris(vec2(0.090,0.017),vec2(0.078,0.020),vec2(0.002,0.016));tris(vec2(0.196,0.019),vec2(0.148,0.021),vec2(0.136,0.018));tris(vec2(0.196,0.019),vec2(0.181,0.026),vec2(0.148,0.021));tris(vec2(0.078,0.020),vec2(0.021,0.026),vec2(0.002,0.016));tris(vec2(0.181,0.026),vec2(0.155,0.029),vec2(0.148,0.021));tris(vec2(0.078,0.020),vec2(0.071,0.035),vec2(0.021,0.026));tris(vec2(0.071,0.035),vec2(0.072,0.072),vec2(0.021,0.026));tris(vec2(0.072,0.072),vec2(0.072,0.086),vec2(0.021,0.026));tris(vec2(0.131,0.072),vec2(0.072,0.086),vec2(0.072,0.072));\n        tris(vec2(0.122,0.086),vec2(0.131,0.072),vec2(0.075,0.154));tris(vec2(0.131,0.072),vec2(0.122,0.086),vec2(0.072,0.086));tris(vec2(0.072,0.086),vec2(0.075,0.154),vec2(0.021,0.026));tris(vec2(0.181,0.026),vec2(0.131,0.072),vec2(0.155,0.029));tris(vec2(0.054,0.205),vec2(0.131,0.072),vec2(0.181,0.026));tris(vec2(0.075,0.154),vec2(0.032,0.203),vec2(0.021,0.026));tris(vec2(0.131,0.072),vec2(0.054,0.205),vec2(0.075,0.154));tris(vec2(0.075,0.154),vec2(0.054,0.205),vec2(0.032,0.203));tris(vec2(0.054,0.205),vec2(0.042,0.209),vec2(0.032,0.203));\n        tris(vec2(0.287,0.000),vec2(0.230,0.008),vec2(0.258,0.002));tris(vec2(0.287,0.000),vec2(0.333,0.008),vec2(0.230,0.008));tris(vec2(0.275,0.089),vec2(0.272,0.094),vec2(0.173,0.094));tris(vec2(0.275,0.089),vec2(0.173,0.094),vec2(0.171,0.090));tris(vec2(0.275,0.089),vec2(0.171,0.090),vec2(0.177,0.083));tris(vec2(0.269,0.083),vec2(0.275,0.089),vec2(0.177,0.083));tris(vec2(0.258,0.081),vec2(0.269,0.083),vec2(0.177,0.083));tris(vec2(0.258,0.081),vec2(0.177,0.083),vec2(0.190,0.080));tris(vec2(0.252,0.071),vec2(0.258,0.081),vec2(0.190,0.080));\n        tris(vec2(0.252,0.071),vec2(0.190,0.080),vec2(0.202,0.061));tris(vec2(0.268,0.018),vec2(0.252,0.071),vec2(0.202,0.061));tris(vec2(0.268,0.018),vec2(0.202,0.061),vec2(0.215,0.016));tris(vec2(0.268,0.018),vec2(0.215,0.016),vec2(0.230,0.008));tris(vec2(0.295,0.017),vec2(0.268,0.018),vec2(0.230,0.008));tris(vec2(0.295,0.017),vec2(0.230,0.008),vec2(0.333,0.008));tris(vec2(0.196,0.156),vec2(0.181,0.158),vec2(0.189,0.153));tris(vec2(0.196,0.156),vec2(0.197,0.170),vec2(0.181,0.158));tris(vec2(0.197,0.170),vec2(0.175,0.175),vec2(0.181,0.158));\n        tris(vec2(0.197,0.170),vec2(0.198,0.189),vec2(0.175,0.175));tris(vec2(0.198,0.189),vec2(0.168,0.196),vec2(0.175,0.175));tris(vec2(0.287,0.191),vec2(0.212,0.193),vec2(0.258,0.181));tris(vec2(0.212,0.193),vec2(0.168,0.196),vec2(0.198,0.189));tris(vec2(0.287,0.191),vec2(0.168,0.196),vec2(0.212,0.193));tris(vec2(0.287,0.191),vec2(0.178,0.203),vec2(0.168,0.196));tris(vec2(0.287,0.191),vec2(0.208,0.207),vec2(0.178,0.203));\n    }\n    if(g_out_color.a>0.0)return;\n    off= abs(uv-vec2(0.375000,0.125000)) - vec2(0.125000); if( off.x <= 0.0 || off.y <=  0.0)\n    { tris(vec2(0.287,0.000),vec2(0.230,0.008),vec2(0.258,0.002));tris(vec2(0.287,0.000),vec2(0.333,0.008),vec2(0.230,0.008));\n        tris(vec2(0.275,0.089),vec2(0.272,0.094),vec2(0.173,0.094));tris(vec2(0.275,0.089),vec2(0.173,0.094),vec2(0.171,0.090));tris(vec2(0.275,0.089),vec2(0.171,0.090),vec2(0.177,0.083));tris(vec2(0.269,0.083),vec2(0.275,0.089),vec2(0.177,0.083));tris(vec2(0.258,0.081),vec2(0.269,0.083),vec2(0.177,0.083));tris(vec2(0.258,0.081),vec2(0.177,0.083),vec2(0.190,0.080));tris(vec2(0.252,0.071),vec2(0.258,0.081),vec2(0.190,0.080));tris(vec2(0.252,0.071),vec2(0.190,0.080),vec2(0.202,0.061));tris(vec2(0.268,0.018),vec2(0.252,0.071),vec2(0.202,0.061));\n        tris(vec2(0.268,0.018),vec2(0.202,0.061),vec2(0.215,0.016));tris(vec2(0.268,0.018),vec2(0.215,0.016),vec2(0.230,0.008));tris(vec2(0.295,0.017),vec2(0.268,0.018),vec2(0.230,0.008));tris(vec2(0.295,0.017),vec2(0.230,0.008),vec2(0.333,0.008));tris(vec2(0.333,0.008),vec2(0.319,0.030),vec2(0.295,0.017));tris(vec2(0.333,0.008),vec2(0.370,0.034),vec2(0.319,0.030));tris(vec2(0.370,0.034),vec2(0.332,0.071),vec2(0.319,0.030));tris(vec2(0.370,0.034),vec2(0.386,0.077),vec2(0.332,0.071));tris(vec2(0.386,0.077),vec2(0.322,0.116),vec2(0.332,0.071));\n        tris(vec2(0.386,0.077),vec2(0.356,0.148),vec2(0.322,0.116));tris(vec2(0.356,0.148),vec2(0.297,0.154),vec2(0.322,0.116));tris(vec2(0.356,0.148),vec2(0.258,0.181),vec2(0.297,0.154));tris(vec2(0.356,0.148),vec2(0.287,0.191),vec2(0.258,0.181));tris(vec2(0.287,0.191),vec2(0.212,0.193),vec2(0.258,0.181));tris(vec2(0.287,0.191),vec2(0.168,0.196),vec2(0.212,0.193));tris(vec2(0.287,0.191),vec2(0.178,0.203),vec2(0.168,0.196));tris(vec2(0.287,0.191),vec2(0.208,0.207),vec2(0.178,0.203));tris(vec2(0.510,0.005),vec2(0.512,0.010),vec2(0.415,0.006));\n        tris(vec2(0.512,0.010),vec2(0.409,0.012),vec2(0.415,0.006));tris(vec2(0.512,0.010),vec2(0.506,0.016),vec2(0.409,0.012));tris(vec2(0.506,0.016),vec2(0.414,0.018),vec2(0.409,0.012));tris(vec2(0.506,0.016),vec2(0.496,0.019),vec2(0.414,0.018));tris(vec2(0.496,0.019),vec2(0.425,0.019),vec2(0.414,0.018));tris(vec2(0.496,0.019),vec2(0.484,0.027),vec2(0.425,0.019));tris(vec2(0.484,0.027),vec2(0.431,0.029),vec2(0.425,0.019));tris(vec2(0.484,0.027),vec2(0.439,0.183),vec2(0.431,0.029));tris(vec2(0.439,0.183),vec2(0.387,0.182),vec2(0.431,0.029));\n        tris(vec2(0.439,0.183),vec2(0.451,0.188),vec2(0.387,0.182));tris(vec2(0.451,0.188),vec2(0.370,0.190),vec2(0.387,0.182));tris(vec2(0.451,0.188),vec2(0.460,0.194),vec2(0.370,0.190));tris(vec2(0.460,0.194),vec2(0.362,0.195),vec2(0.370,0.190));tris(vec2(0.460,0.194),vec2(0.452,0.202),vec2(0.362,0.195));tris(vec2(0.452,0.202),vec2(0.368,0.202),vec2(0.362,0.195));tris(vec2(0.556,0.200),vec2(0.487,0.200),vec2(0.489,0.193));tris(vec2(0.510,0.183),vec2(0.556,0.200),vec2(0.489,0.193));\n    }\n    if(g_out_color.a>0.0)return;\n    off= abs(uv-vec2(0.625000,0.125000)) - vec2(0.125000); if( off.x <= 0.0 || off.y <=  0.0)\n    { tris(vec2(0.510,0.005),vec2(0.512,0.010),vec2(0.415,0.006));\n        tris(vec2(0.512,0.010),vec2(0.409,0.012),vec2(0.415,0.006));tris(vec2(0.512,0.010),vec2(0.506,0.016),vec2(0.409,0.012));tris(vec2(0.506,0.016),vec2(0.414,0.018),vec2(0.409,0.012));tris(vec2(0.506,0.016),vec2(0.496,0.019),vec2(0.414,0.018));tris(vec2(0.686,0.011),vec2(0.666,0.012),vec2(0.678,0.007));tris(vec2(0.626,0.006),vec2(0.628,0.011),vec2(0.531,0.006));tris(vec2(0.782,0.007),vec2(0.784,0.011),vec2(0.711,0.006));tris(vec2(0.628,0.011),vec2(0.527,0.011),vec2(0.531,0.006));tris(vec2(0.784,0.011),vec2(0.708,0.012),vec2(0.711,0.006));\n        tris(vec2(0.784,0.011),vec2(0.781,0.017),vec2(0.708,0.012));tris(vec2(0.628,0.011),vec2(0.533,0.018),vec2(0.527,0.011));tris(vec2(0.628,0.011),vec2(0.622,0.018),vec2(0.533,0.018));tris(vec2(0.781,0.017),vec2(0.714,0.018),vec2(0.708,0.012));tris(vec2(0.622,0.018),vec2(0.611,0.019),vec2(0.533,0.018));tris(vec2(0.611,0.019),vec2(0.543,0.020),vec2(0.533,0.018));tris(vec2(0.781,0.017),vec2(0.727,0.020),vec2(0.714,0.018));tris(vec2(0.686,0.011),vec2(0.688,0.021),vec2(0.666,0.012));tris(vec2(0.781,0.017),vec2(0.758,0.026),vec2(0.727,0.020));\n        tris(vec2(0.611,0.019),vec2(0.600,0.029),vec2(0.543,0.020));tris(vec2(0.600,0.029),vec2(0.548,0.030),vec2(0.543,0.020));tris(vec2(0.758,0.026),vec2(0.734,0.032),vec2(0.727,0.020));tris(vec2(0.758,0.026),vec2(0.691,0.160),vec2(0.734,0.032));tris(vec2(0.600,0.029),vec2(0.565,0.161),vec2(0.548,0.030));tris(vec2(0.565,0.161),vec2(0.510,0.183),vec2(0.548,0.030));tris(vec2(0.556,0.200),vec2(0.487,0.200),vec2(0.489,0.193));tris(vec2(0.510,0.183),vec2(0.556,0.200),vec2(0.489,0.193));tris(vec2(0.565,0.161),vec2(0.556,0.200),vec2(0.510,0.183));\n        tris(vec2(0.640,0.073),vec2(0.556,0.200),vec2(0.565,0.161));tris(vec2(0.640,0.073),vec2(0.565,0.161),vec2(0.666,0.012));tris(vec2(0.688,0.021),vec2(0.640,0.073),vec2(0.666,0.012));tris(vec2(0.688,0.021),vec2(0.691,0.160),vec2(0.640,0.073));tris(vec2(0.758,0.026),vec2(0.700,0.182),vec2(0.691,0.160));tris(vec2(0.691,0.160),vec2(0.644,0.199),vec2(0.640,0.073));tris(vec2(0.700,0.182),vec2(0.644,0.199),vec2(0.691,0.160));tris(vec2(0.700,0.182),vec2(0.723,0.196),vec2(0.644,0.199));tris(vec2(0.723,0.196),vec2(0.719,0.202),vec2(0.644,0.199));\n        \n    }\n    if(g_out_color.a>0.0)return;\n    off= abs(uv-vec2(0.875000,0.125000)) - vec2(0.125000); if( off.x <= 0.0 || off.y <=  0.0)\n    { tris(vec2(0.782,0.007),vec2(0.784,0.011),vec2(0.711,0.006));tris(vec2(0.784,0.011),vec2(0.708,0.012),vec2(0.711,0.006));tris(vec2(0.784,0.011),vec2(0.781,0.017),vec2(0.708,0.012));tris(vec2(0.781,0.017),vec2(0.714,0.018),vec2(0.708,0.012));tris(vec2(0.781,0.017),vec2(0.727,0.020),vec2(0.714,0.018));tris(vec2(0.781,0.017),vec2(0.758,0.026),vec2(0.727,0.020));tris(vec2(0.758,0.026),vec2(0.734,0.032),vec2(0.727,0.020));tris(vec2(0.758,0.026),vec2(0.691,0.160),vec2(0.734,0.032));tris(vec2(0.758,0.026),vec2(0.700,0.182),vec2(0.691,0.160));\n        tris(vec2(0.998,0.006),vec2(1.000,0.010),vec2(0.923,0.007));tris(vec2(0.881,0.005),vec2(0.886,0.012),vec2(0.796,0.005));tris(vec2(0.886,0.012),vec2(0.790,0.012),vec2(0.796,0.005));tris(vec2(1.000,0.010),vec2(0.920,0.012),vec2(0.923,0.007));tris(vec2(0.886,0.012),vec2(0.793,0.016),vec2(0.790,0.012));tris(vec2(1.000,0.010),vec2(0.995,0.017),vec2(0.920,0.012));tris(vec2(0.886,0.012),vec2(0.881,0.018),vec2(0.793,0.016));tris(vec2(0.995,0.017),vec2(0.926,0.018),vec2(0.920,0.012));tris(vec2(0.995,0.017),vec2(0.986,0.019),vec2(0.926,0.018));\n        tris(vec2(0.881,0.018),vec2(0.868,0.020),vec2(0.793,0.016));tris(vec2(0.986,0.019),vec2(0.939,0.021),vec2(0.926,0.018));tris(vec2(0.986,0.019),vec2(0.972,0.026),vec2(0.939,0.021));tris(vec2(0.868,0.020),vec2(0.811,0.027),vec2(0.793,0.016));tris(vec2(0.972,0.026),vec2(0.945,0.030),vec2(0.939,0.021));tris(vec2(0.868,0.020),vec2(0.861,0.035),vec2(0.811,0.027));tris(vec2(0.861,0.035),vec2(0.863,0.073),vec2(0.811,0.027));tris(vec2(0.972,0.026),vec2(0.922,0.073),vec2(0.945,0.030));tris(vec2(0.863,0.073),vec2(0.863,0.086),vec2(0.811,0.027));\n        tris(vec2(0.922,0.073),vec2(0.863,0.086),vec2(0.863,0.073));tris(vec2(0.922,0.073),vec2(0.912,0.086),vec2(0.863,0.086));tris(vec2(0.972,0.026),vec2(0.912,0.086),vec2(0.922,0.073));tris(vec2(0.863,0.086),vec2(0.865,0.154),vec2(0.811,0.027));tris(vec2(0.972,0.026),vec2(0.865,0.154),vec2(0.912,0.086));tris(vec2(0.865,0.154),vec2(0.822,0.204),vec2(0.811,0.027));tris(vec2(0.972,0.026),vec2(0.844,0.205),vec2(0.865,0.154));tris(vec2(0.865,0.154),vec2(0.844,0.205),vec2(0.822,0.204));tris(vec2(0.844,0.205),vec2(0.833,0.209),vec2(0.822,0.204));\n        \n    }\n    \n}\n#define PI 3.1415926536\n\nconst vec2 res = vec2(640.0,400.0);\nconst mat3 mRot = mat3(0.9553, -0.2955, 0.0, 0.2955, 0.9553, 0.0, 0.0, 0.0, 1.0);\nconst vec3 ro = vec3(0.0,0.0,-4.0);\n\nconst vec3 cRed = vec3(1.0,0.0,0.0);\nconst vec3 cWhite = vec3(1.0);\nconst vec3 cGrey = vec3(0.66);\nconst vec3 cPurple = vec3(0.51,0.29,0.51);\n\nconst float maxx = 0.378;\n\nvoid mainVectorText( inout vec4 fragColor, in vec2 fragCoord )\n{   g_pen = fragCoord.xy/iResolution.xy;\n    float asp = iResolution.y/iResolution.x;\n    vec2 uvR = floor(g_pen*res);\n    g_pen*=vec2(1.2,1.2*asp);\n    g_pen.x = 0.195+(1.0-g_pen.x);\n    g_out_color = vec4(1,1,1.0,0.0);\n    \n    //  if(distance(g_pen,vec2(1,1))<0.01)g_out_color =vec4(1,0,0,1.0);\n    \n    vector_text();\n    fragColor.rgb =mix(fragColor.rgb,g_out_color.rgb,g_out_color.a);\n    \n    \n    \n    \n    vec2 uv = uvR/res + vec2(-0.046,-0.13);\n    \n    vec3 rd = normalize(vec3((uv)*vec2(2.0,2.0*asp),1.0));\n    \n    float b = dot(rd,ro);\n    float t1 = b*b-15.0;\n    float t = -b-sqrt(t1);\n    vec3 nor = normalize(ro+rd*t)*mRot;\n    vec2 tuv = floor(vec2(atan(nor.x,nor.z)/PI+((floor((iTime)*60.0)/60.0)*0.5),acos(nor.y)/PI)*8.0);\n    fragColor = vec4(mix(fragColor.rgb,mix(cRed,cWhite,clamp(mod(tuv.x+tuv.y,2.0),0.0,1.0)),1.0-step(t1,0.0)),1.0);\n    \n    \n    \n    \n}\n\n\n\n//#######################################################################\n//#######################################################################\n//#######################################################################\n\n#define PRECISION_STEP 0.01\n//----------------------------------------------------------------------\n\n// Inspired by http://meatfighter.com/juggler/\n// I used some values and snippets here and there\n\n#define Math_PI 3.1415926\n\n\n// Materials\n#define MAT_FLOOR  vec3(-1.0,1.0,0.0)\n#define MAT_MIRROR vec3(-1.0,2.0,0.0)\n\n#define MAT_LIMBS  vec3(0.929,0.508,0.508)\n\n#define MAT_TORSO  vec3(0.890,0.000,0.000)\n#define MAT_EYES   vec3(0.087,0.019,0.508)\n#define MAT_HAIR   vec3(0.111,0.054,0.071)\n\n//#define MAT_SKY     10.0\n#define MAT_SKY_COLOR_A   vec3(0.74,0.74,1.0)\n#define MAT_SKY_COLOR_B   vec3(0.13,0.137,0.96)\n\n// Scene constants\n\n#define CAMERA_NEAR 0.03\n#define CAMERA_FAR 50.0\n\n// The global scale of the scene is the same found in meatfighter.com,\n// should be better to change it in meters instead of centimeters but\n// I preferred to respect the original author choice.\n\n#define gSCALE  0.01\n\n// Animations and Modeling parameters\n\n#define JUGGLE_X0  -182.0\n#define JUGGLE_X1  -108.0\n#define JUGGLE_Y0  88.0\n#define JUGGLE_H_Y  184.0\n\n#define JUGGLE_H_VX ( (JUGGLE_X0 - JUGGLE_X1) / 60.0)\n#define JUGGLE_L_VX ((JUGGLE_X1 - JUGGLE_X0) / 30.0)\n\n#define  JUGGLE_H_H (JUGGLE_H_Y - JUGGLE_Y0)\n#define  JUGGLE_H_VY (4.0 * JUGGLE_H_H / 60.0)\n#define  JUGGLE_G (JUGGLE_H_VY * JUGGLE_H_VY/ (2.0 * JUGGLE_H_H))\n\n\n#define  JUGGLE_B_VY (2.0 * JUGGLE_H_H / 30.0)\n#define  JUGGLE_B ((JUGGLE_B_VY * JUGGLE_B_VY )/ (JUGGLE_H_H))\n\n#define JUGGLE_L_VY  (0.5 * JUGGLE_G * 60.0)\n\n#define HIPS_MAX_Y 85.0\n#define HIPS_MIN_Y  81.0\n\n#define HIPS_ANGLE_MULTIPLIER  (2.0 * Math_PI / 30.0)\n\n// by reason of culling and skip unnecessary calculations\nfloat sdCapsule( vec3 pa, vec3 ba, float r )\n{\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat rAABB( in vec3 roo, in vec3 rdd, in vec3 rad )\n{\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n    \n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    \n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN > tF || tF < 0.0) return CAMERA_FAR;\n    \n    return tN;\n}\n// by reason of modeling\n\nfloat rPlane(vec3 o,vec3 d,vec4 pn)\n{\n    float num = pn.w - dot(pn.xyz,o);\n    float denom = dot(pn.xyz,d);\n    float t = num/denom;\n    if(t>PRECISION_STEP)\n        return t;\n    return CAMERA_FAR;\n}\n\n\nfloat rSphere(vec3 o, vec3 d, vec3 c, float r)\n{\n    vec3 e= c - o;\n    float a= dot(e, d);\n    float b= r*r - dot(e,e) + a*a;\n    if(b>0.0)\n    {\n        float t = a- sqrt(b);\n        if(t>PRECISION_STEP)\n            return t;\n    }\n    return CAMERA_FAR;\n}\n\n#define tSPH(v,r,col) { vec3 sp = ((v)+vec3(-150.0,0.0,150.0))*gSCALE;mind = rSphere( ro,rd, sp ,float(r)*gSCALE);if(mind<res.x){res=vec4(mind,col); n_out =normalize((ro+rd*mind)-sp); } }\n\n\n\n// the modeling and animation updates.\n\n// we have 8 spheres per limb\n#define countA 8\n// todo calculate dist based on count\n\nvoid tUpdateAppendage(inout vec4 res,vec3 ro,vec3 rd,vec3 p, vec3 q, vec3 w, float A, float B,inout vec3 n_out)\n{\n    vec3 V=q-p;\n    float D=length(V);\n    float inverseD = 1.00 / D;\n    V*= inverseD;\n    \n    vec3 W = normalize(w);\n    vec3 U = cross(V, W);\n    \n    float A2 = A * A;\n    \n    float y = 0.5 * inverseD * (A2 - B * B + D * D);\n    float square = A2 - y * y;\n    if (square < 0.0) {\n        return;\n    }\n    float x = sqrt(square);\n    \n    vec3 j = p+U*x+V*y;\n    float ooA=  1.0 / 8.0;\n    vec3 d= (j- p)*ooA;\n    \n    vec3 k = p;\n    float mind=res.x;\n    \n    \n    \n    for(int i = 0; i <= countA; i++)\n    {\n        float fi=float(i);\n        tSPH((k+d*fi),(2.5+2.5*fi*ooA),MAT_LIMBS);\n    }\n    \n    d= (j- q )*ooA;\n    k = q;\n    for(int i = 0; i < countA; i++)\n    {\n        tSPH((k+d*float(i)),5.0,MAT_LIMBS);\n    }\n    \n    \n}\n\n\n// the juggler sphere animation paths, taken from http://meatfighter.com/juggler/\nvoid juggling(inout vec3 c,float t)\n{\n    if(t<60.0)\n    {\n        c.z = JUGGLE_X1 + JUGGLE_H_VX * t;\n        c.y = JUGGLE_Y0 + ((JUGGLE_H_VY - 0.5 * JUGGLE_G * t) * t);\n    }\n    else\n    {   float h= t-60.0;\n        c.z = JUGGLE_X0 + ((JUGGLE_X1 - JUGGLE_X0)/30.0) * h;\n        c.y = JUGGLE_Y0 + (((2.0 * JUGGLE_H_H / 30.0) - 0.5 * JUGGLE_B * h) * h)*.5;\n    }\n}\n// the raytracing scene function.\nvec4 trace(in vec3 ro, in vec3 rd,out vec3 n_out)\n{   vec4 res=vec4(CAMERA_FAR,-2.0,-2.0,0.0);\n    n_out=vec3(0);\n    float mind = rPlane(ro,rd,vec4(0,1.0,0,0));\n    if(mind<res.x) { res=vec4(mind,MAT_FLOOR); n_out =vec3(0.0,1.0,0.0);}\n    \n    \n    float chkd=rAABB(ro-vec3(0,1,0),rd,vec3(0.6,1.0,0.6));\n    if(chkd<res.x)\n    {\n        float t =  mod(iTime*30.0,90.0);\n        vec3 pos = ro;\n        vec3 c=vec3(110.0);\n        juggling(c,t);\n        tSPH(c,14.0,MAT_MIRROR);\n        \n        juggling(c,mod(t+25.0,90.0));\n        tSPH(c,14.0,MAT_MIRROR);\n        \n        juggling(c,mod(t+55.0,90.0));\n        tSPH(c,14.0,MAT_MIRROR);\n        \n        float T =  mod(iTime*30.0,30.0);\n        \n        float angle = HIPS_ANGLE_MULTIPLIER * T;\n        float oscillation = 0.5 * (1.0 + cos(angle));\n        vec3 o = vec3(151.0, HIPS_MIN_Y + (HIPS_MAX_Y - HIPS_MIN_Y) * oscillation,-151.0);\n        vec3 v=normalize(vec3(0.0,70.0,(HIPS_MIN_Y - HIPS_MAX_Y) * sin(angle)) );\n        vec3 u=vec3(0.0,v.z,-v.y);\n        vec3 w=vec3(1.0,0.0,0.0);\n        vec3 k = o;\n        \n        for(int i = 0; i <= 7; i++)\n        {\n            float percent = float(i) / 7.0;\n            tSPH(( k+v*(32.0*percent)) , (16.0+4.0*percent),MAT_TORSO);\n        }\n        tSPH(o+v*70.0, 14., MAT_LIMBS);\n        tSPH(o+v*55.0, 5., MAT_LIMBS);\n        \n        vec3 p=vec3(159.0,1.5,-133.0);\n        \n#define mapYZ(o,v,w,y,z) (v*y+w*z+o)\n        vec3 q = mapYZ(o,v,u,-9.0,-16.0);\n        tUpdateAppendage(res,ro,rd, p, q, u, 42.58, 34.07,n_out);\n        \n        p=vec3( 139.0,2.5,-164.0);\n        q=mapYZ( o, v, u, -9.0, 16.0);\n        tUpdateAppendage(res,ro,rd, p, q, u, 42.58, 34.07,n_out);\n        \n        vec3 n ;\n        float armAngle = -0.35 * oscillation;\n        p.x = 69.0 + 41.0 * cos(armAngle);\n        p.y = 60.0 - 41.0 * sin(armAngle);\n        p.z = -108.0;\n        \n        q=mapYZ( o, v, u, 45.0, -19.0);\n        n=mapYZ( o, v, u, 45.41217, -19.91111);\n        n-= q;\n        tUpdateAppendage(res,ro,rd, p, q, n, 44.294, 46.098,n_out);\n        \n        p.z = -182.0;\n        q=mapYZ( o, v, u, 45.0, 19.0);\n        n=mapYZ( o, v, u, 45.41217, 19.91111);\n        n= q- n;\n        tUpdateAppendage(res,ro,rd,p, q, n, 44.294, 46.098,n_out);\n        \n        c = mapYZ( o, v, u, 69.0, -7.0);\n        c.x=142.0;\n        tSPH(c, 4.0, MAT_EYES);\n        \n        c = mapYZ( o, v, u, 69.0, 7.0);\n        c.x=142.0;\n        tSPH(c, 4.0, MAT_EYES);\n        \n        c =  o + v*71.0;\n        c.x=152.0;\n        tSPH(c, 14.0, MAT_HAIR);\n        \n    }\n    \n    return res;\n}\n\n\nvec4 castRay( in vec3 ro, in vec3 rd ,out vec3 n_out)\n{\n    float tmin = CAMERA_NEAR;\n    \n    float precis = PRECISION_STEP;\n    \n    vec3 m =  vec3(-2.0);\n    n_out =vec3(0.0);\n    vec4 traced = trace(ro,rd,n_out);\n    float tmax =min(CAMERA_FAR,traced.x);\n    float t = tmin;\n    vec4 res=vec4(CAMERA_FAR,-2.0,-2.0,0.0);\n    \n    if(traced.x < CAMERA_FAR)\n        return traced;\n    \n    \n    n_out=vec3(0);\n    m=vec3(-2.0);\n    return vec4( CAMERA_FAR, m.x,m.y,m.z );\n}\n\n\n\nvec3  LightDirection = vec3(-0.646997, 0.754829, -0.107833);\n\nvec4 render( in vec3 ro, in vec3 rd ,out vec3 pos,out vec3 nor,out vec3 ref)\n{\n    // the sky... ugly dot(viewdir,up) ..\n    float l = pow(rd.y+.21 , .3 );\n    vec3 col =mix(vec3(MAT_SKY_COLOR_A),vec3(MAT_SKY_COLOR_B), l);\n    \n    vec4 res = castRay(ro,rd,nor);\n    float t = res.x;\n    vec3 m = res.yzw;\n    float tm =1.0;\n    if( m.x>=-1.0 )\n    {\n        pos = ro + t*rd;\n        ref = reflect( rd, nor );\n        \n        if( m.x<0.0 )\n        {\n            if(m.y<=1.0)\n            {   // the floor\n                float f = mod( floor(pos.z+.5) + floor(pos.x+0.5), 2.0);\n                col = mix(vec3(1,1,0),vec3(0,1,0),f);\n                col *=mix(vec3(1,1,1),vec3(0.1,.1,.1),t/CAMERA_FAR);\n            }\n            else\n            {   // mirror ball\n                tm=-1.0;\n                col=vec3(1.0);\n            }\n        } else { // or.... mirror ball\n            tm=-1.0;\n            col=vec3(1.0);\n        };\n        \n            \n       // else col = m; // solid stuff\n            \n            \n        // lighitng calculation\n        \n        float amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, LightDirection ), 0.0, 1.0 );\n        float spe = pow(clamp( dot( ref, LightDirection ), 0.0, 1.0 ),16.0);\n        vec3 nnn;\n        // a shadow\n        dif *= (castRay(pos,LightDirection,nnn).x<CAMERA_FAR?0.0:1.0);\n        \n        vec3 lit = vec3(dif);\n        lit += 0.20*amb*vec3(0.50,0.50,0.60);\n        col *= lit;\n        // specular on solid stuff, no floor or mirrors\n        if(m.x>0.0)\n            col+= spe*dif;\n    }\n    \n    return vec4( col,tm );\n}\n\n// from iq code :D\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n    float time =  iTime;\n    \n    // camera animation , mouse x to spin around the scene.\n    vec3 ro = vec3( -0.5+3.2*cos(0.1*time + 6.0*mo.x), .50 + 1.0, 0.5 + 3.2*sin(0.1*time + 6.0*mo.x) );\n    vec3 ta = vec3( -0.0, 1.0, 0.0 );\n    \n    // mouse y to zoom in and out a little\n    ro = ro+normalize(ta-ro)*mo.y*2.0;\n    \n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n    vec3 rd = ca * normalize( vec3(p.xy,2.5) );\n    \n    // render\n    vec3 pos,nor,ref;\n    vec4 col = render( ro, rd ,pos,nor,ref);\n    // mirrors reflections, the first bounce\n    if(col.w<0.0)\n        col = pow(max(0.0, dot( ref, LightDirection ) ),26.0) + render( pos, ref ,pos,nor,ref);\n    // and a second one\n    if(col.w<0.0)\n        col = render( pos, ref ,pos,nor,ref);\n    // and some more\n    if(col.w<0.0)\n        col = render( pos, ref ,pos,nor,ref);\n//    if(col.w<0.0)\n//        col = render( pos, ref ,pos,nor,ref);\n//    if(col.w<0.0)\n//        col = render( pos, ref ,pos,nor,ref);\n    \n    // gamma\n    col = pow( col, vec4(0.4545) );\n    \n    fragColor=vec4( col.xyz, 1.0 );\n    \n    // the title\n    //    mainText(fragColor,fragCoord);\n    //mainVectorText(fragColor,fragCoord);\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsXBR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1637, 1637, 1671, 1671, 1935], [1937, 1937, 1957, 1957, 12956], [13307, 13307, 13371, 13371, 14251], [16052, 16110, 16156, 16156, 16250], [16252, 16252, 16306, 16306, 16591], [16618, 16618, 16655, 16655, 16819], [16822, 16822, 16870, 16870, 17080], [17399, 17399, 17512, 17512, 18253], [18256, 18338, 18375, 18375, 18702], [18703, 18737, 18788, 18788, 21295], [21298, 21298, 21353, 21353, 21772], [21838, 21838, 21916, 21958, 23451], [23453, 23472, 23524, 23524, 23713], [23715, 23715, 23772, 23772, 25157]], "test": "valid"}
{"id": "wsXBRN", "name": "The striped box", "author": "Krafpy", "description": "Along a dark tunnel where light moves step by step.", "tags": ["raymarching", "reflection"], "likes": 5, "viewed": 163, "published": "Public", "date": "1587847767", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define N_ITER 80.\n#define N_REF 3.\n#define PI 3.1415926535\n\n#define BOX vec3(5, 5, 1000)\n\n\n// some chaotic function\nfloat hash(){\n    float time = iTime;\n\treturn clamp(floor(fract(sin(time)*cos(time))*2.*sin(time*1.45)+0.5), 0., 1.);\n    //float time = mod(iTime*0.01, 50.);\n    //return abs(floor(cos(3.*fract(exp(.2*(time*time+30.))))));\n}\n\n// 2D rotation matrix\nmat2 rot(float a){ // rotation matrix\n\treturn mat2(cos(a), -sin(a),\n               sin(a), cos(a));\n}\n\n// box sdf\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// sin pulse function based on time : control the cube shape\nfloat pulse(){\n    float x = mod(iTime*10., 15.);\n    if(x > PI*2.) return 0.;\n    return 0.5 + 0.5*sin(x-PI/2.);\n}\n\nfloat map(in vec3 p, out int id){\t\n    float d;\n    \n    // cube\n    vec3 c = vec3(0., -3.5, 7); // center of the cube\n    // animate the cube\n    vec3 q = p - c;\n    float t = iTime*0.4;\n    q.xz *= rot(iTime*0.5);\n    q.yz *= rot(iTime*0.6);\n    q.xy *= rot(iTime*0.8);\n    // sdf with displacement\n    float d1 = box(q, vec3(0.7)) + 0.1/distance(c, p) * pulse();\n    \n    // outer box (walls)\n   \tfloat d2 = -box(p, BOX);\n    \n    if(d1 < d2){\n    \tid = 0; d = d1;\n    } else {\n    \tid = 1; d = d2;\n    }\n    return d;\n}\n\nfloat map(in vec3 p){ // overloaded simplified method\n   int _; return map(p, _);\n}\n\nvec3 getNormal(vec3 p) {\n    const float eps = 0.0001;\n    return normalize(vec3(\n        map(vec3(p.x + eps, p.yz)) - map(vec3(p.x - eps, p.yz)),\n        map(vec3(p.x, p.y + eps, p.z)) - map(vec3(p.x, p.y - eps, p.z)),\n        map(vec3(p.xy, p.z + eps)) - map(vec3(p.xy, p.z - eps))\n    ));\n}\n\n\nfloat raymarch(vec3 ro, vec3 rd, out float shad, out int id){\n    bool hit = false;\n    float h, t = 0.;\n    \n    for(float i = 0.; i < N_ITER; ++i){\n    \th = map(ro + rd * t, id);\n       \t\n        if(h < 0.001){\n            shad = i/N_ITER;\n            hit = true;\n            break;\n        }\n        \n        t += h;\n    }\n\t\n\treturn hit ? t : 0.;\n}\n\n// get texture intensity : create the stripe pattern\nfloat wall(float z, vec3 n){\n   \n    float t = iTime*4.;\n    float w = 1.5; // width of a stripe\n    float r = 1.15; // ratio light surface / drak reflective surface per stripe \n\n\n    float u = abs(z - BOX.z) - t; // position along depth axis\n    float a = mod(u, w*r);\n    float k = step(w, a); // black or bright surface\n\n    float h = hash();\n    if(h == 0.)\n        if(n.x != 0.){k = 1. - k;} // change animation when hash changes\n\n    float c = h == 0. ? 7. : 12.; // number of stripes per wave of light\n    float s = h == 0. ? 2. : 15.; // waves speed\n    float d = h == 0. ? 1. : -1.; // direction of light waves\n    float st = floor(iTime*s);\n    // create the stripe pattern, with uniform color\n    // and make light stripes move forward at st speed with steps\n    float b = floor(mod(d*u + st*w*r , c*w*r)/w/r);\n\n    k /= clamp(exp(b*0.4)*1.7, 1., 100.); // decay color intensity\n\n    return k;\n}\n\n\nvec3 matcol(){ // color of the cube\n    return vec3(1., 1., 5.); \n}\n\nvec3 matcol(float k){ // color of the walls, depends on k\n    return k <= 0. ?\n        vec3(0.4) :\n    \tvec3(1., 0.5, 0.7) * k * 4.;\n}\n\n\nvec3 noise(vec3 p){\n    vec3 tex =\ttexture(iChannel0, p.xz).rgb;\n    tex += \t\ttexture(iChannel0, p.yx).rgb;\n    tex += \t\ttexture(iChannel0, p.yz).rgb;\n    return tex;\n}\n\nvec3 disp1(vec3 p){ // normal displacement for the cube's surface\n\treturn noise(p)/3.*0.015;\n}\n\nvec3 disp2(vec3 p){ // normal displacement for the reflective surfaces of the walls\n\treturn 0.1/noise(p*0.25)/3.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // ray\n    vec3 ro = vec3(0., -3., 0.);\n    vec3 rd = normalize(vec3(uv, 1.));\n    \n    // animate the camera\n    rd.xy *= rot(sin(iTime*0.5)*0.5);\n    rd.yz *= rot(sin(iTime)*0.1);\n    \n    // pixel color\n    vec3 col = vec3(0.);\n        \n    // RAYMARCHING\n\n    int id = -1; // id of the object we hit\n    float shad; // ration number of steps / number of iterations\n    \n    float t, k;\n    \n    float i;\n    for(i = 0.; i <= N_REF; ++i){\n    \tt = raymarch(ro, rd, shad, id);\n        \n        if(t == 0.){ // cancel if error detection\n            col = vec3(0.);\n            break;\n        }\n        \n        vec3 p = ro + rd * t;\n        vec3 n = getNormal(p);\n        \n        vec3 scol;\n        \n        float decay = clamp((1.-shad-exp(p.z*0.05)*0.01), 0., 1.); // fade along depth axis\n        \n        if(id == 0){ // if we hit the cube\n            scol = matcol() * decay; // get the material color, with fading along depth axis\n            n += disp1(p); // normal displacement\n        } else { // if we hit the walls\n            k = wall(p.z, n);\n            scol = matcol(k) * decay;\n            n += disp2(p);\n        }\n        \n        if(i == 0.) col = scol; // initial color\n        else col *= scol * (1.-t*0.05); // reflection with fading proportional to length of the reflected ray\n        \n        if(k > 0.) break; // no reflection if we hit a light stripe\n        \n        // reflect ray\n        ro = p + n * 0.01;\n        rd = reflect(rd, n);\n    }\n    \n    // some post processing\n    col *= 1.1;\n    col += vec3(0., 0.1, 0.);\n\n    // Output to screen\n    fragColor = vec4(col,1.);\n}", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsXBRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[92, 117, 130, 130, 342], [344, 366, 384, 403, 467], [469, 480, 509, 509, 596], [598, 659, 673, 673, 774], [776, 776, 809, 809, 1299], [1301, 1301, 1322, 1354, 1384], [1386, 1386, 1410, 1410, 1679], [1682, 1682, 1743, 1743, 2033], [2035, 2088, 2116, 2116, 2994], [2997, 2997, 3011, 3032, 3064], [3066, 3066, 3087, 3123, 3200], [3203, 3203, 3222, 3222, 3371], [3373, 3373, 3392, 3438, 3467], [3469, 3469, 3488, 3552, 3584], [3587, 3587, 3644, 3644, 5360]], "test": "error"}
{"id": "WsXBz4", "name": "B-day cake", "author": "42yeah", "description": "This is a fairly ugly cake. I just made it for fun! It's probably your birthday, and if so, happy birthday!", "tags": ["raymarching"], "likes": 2, "viewed": 63, "published": "Public", "date": "1587732952", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Comment this if topping is way too laggy for you.\n#define NICE_TOPPINGS\n\nfloat smin(float a, float b, float r) {\n    float h = clamp(0.5 + 0.5 * (b - a) / r, 0.0, 1.0);\n    return mix(b, a, h) - r * h * (1.0 - h);\n}\n\nvec2 rand2d(vec2 u) {\n    return fract(sin(\n        vec2(dot(u, vec2(12.345, 67.89)),\n            dot(u, vec2(512.215, 91.51)))\n    ) * 42123.45678) * 2.0 - 1.0;\n}\n\nvec3 rand3d(vec3 u) {\n    return fract(sin(\n        vec3(dot(u, vec3(12.345, 67.89, 1.56)),\n            dot(u, vec3(512.215, 91.51, 918.12)),\n            dot(u, vec3(12.567, 84.23, 92.5)))\n    ) * 42123.45678) * 2.0 - 1.0;\n}\n\nfloat ball(vec3 p, vec3 off, float r) {\n    return length(p - off) - r;\n}\n\nfloat sol(vec3 p) {\n    return p.y;\n}\n\nfloat cylinder(vec3 p, vec3 off, float ra, float rb, float h) {\n    p = p - off;\n    vec2 d = vec2(length(p.xz) - 2.0 * ra + rb, abs(p.y) - h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - rb;\n}\n\nfloat topping(vec3 p, vec3 off) {\n    float v = cylinder(p, off, 0.161, 0.1, -0.05);\n    vec3 currentOff = vec3(0.0, 0.0, 0.0);\n\n#ifdef NICE_TOPPINGS\n    for (int i = 0; i < 10; i++) {\n        vec2 deltaOff = vec2(sin(float(i)) * 0.29, cos(float(i)) * 0.3);\n        currentOff = vec3(deltaOff.x, -0.05, deltaOff.y);\n        v = smin(v, ball(p, off + currentOff, 0.015 + cos(float(i * 3)) * 0.01), \n            0.1 + (sin(float(i * 2)) * 0.005 + 0.001));\n    }\n#endif\n    return v;\n}\n\nfloat grapes(vec3 p, vec3 off) {\n    float v = ball(p, off + vec3(0.1, 0.0, 0.0), 0.03);\n    v = min(v, ball(p, off + vec3(0.03, 0.0, 0.0), 0.03));\n    v = min(v, ball(p, off + vec3(0.05, 0.0, -0.06), 0.03));\n    v = min(v, ball(p, off + vec3(0.06, 0.04, -0.025), 0.03));\n    \n    for (int i = 0; i < 5; i++) {\n        vec2 rnd = rand2d(vec2(float(i + 2), float(i))) * 0.2;\n        v = min(v, ball(p, off + vec3(rnd.x, 0.0, rnd.y), 0.03));\n    }\n    return v;\n}\n\nfloat line(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat candle(vec3 p, vec3 off) {\n    p = p - off;\n    return line(p, vec3(0.0, -0.02, 0.1), vec3(0.0, 0.08, 0.11), 0.02);\n}\n\n\n\n//float age(vec3 p, vec3 off) {\n//    p = p - (off + vec3(0.0, 0.1, 0.1));\n//    vec2 t = vec2(0.05, 0.01);\n//    vec2 q = vec2(length(p.xy) - t.x, p.z);\n//    float v = length(q) - t.y;\n//    v -= min(p.y, 0.0);\n//    v = smin(v, line(p, vec3(0.05, 0.0, 0.0), vec3(-0.04, -0.1, 0.0), 0.01), 0.01);\n//    v = smin(v, line(p, vec3(0.05, -0.1, 0.0), vec3(-0.04, -0.1, 0.0), 0.01), 0.01);\n//    v = smin(v, line(p, vec3(0.1, -0.1, 0.0), vec3(0.12, 0.05, 0.0), 0.01), 0.01);\n//    return v;\n//}\n\nvec2 map(vec3 p) {\n    float closest = 1000.0;\n    float id = -1.0;\n    \n    float dist = sol(p);\n    if (dist < closest) { closest = dist; id = 0.5; }\n\n    dist = cylinder(p, vec3(0.0, 0.1, 0.0), 0.2, 0.1, 0.1);\n    if (dist < closest) { closest = dist; id = 1.5; }\n    \n    dist = cylinder(p, vec3(0.0, 0.36, 0.0), 0.16, 0.1, 0.09);\n    if (dist < closest) { closest = dist; id = 2.5; }\n    \n    dist = topping(p, vec3(0.0, 0.51, 0.0));\n    if (dist < closest) { closest = dist; id = 3.5; }\n    \n    dist = grapes(p, vec3(0.0, 0.585, 0.0));\n    if (dist < closest) { closest = dist; id = 4.5; }\n    \n    dist = candle(p, vec3(0.0, 0.585, 0.0));\n    if (dist < closest) { closest = dist; id = 5.5; }\n    \n//    dist = age(p, vec3(0.0, 0.6, 0.0));\n//    if (dist < closest) { closest = dist; id = 5.5; }\n    \n    return vec2(closest, id);\n}\n\nvec2 intersect(vec3 ro, vec3 rd) {\n    float depth = 0.0;\n    float id = -1.0;\n    \n    for (int i = 0; i < 200; i++) {\n        vec2 result = map(ro + depth * rd);\n        if (result.x <= 0.001) {\n            id = result.y;\n            break;\n        }\n        depth += result.x;\n    }\n    return vec2(depth, id);\n}\n\n#define PI acos(-1.0)\nvec3 bottomCakeColor(vec3 p) {\n    vec3 baseColor = vec3(1.2, 1.2, 0.7);\n    vec3 toppingColor = vec3(1.0, 0.5, 0.01);\n    float dist = pow(max(p.y - 0.25, 0.0), 0.2);\n    vec3 color = mix(baseColor, toppingColor, clamp(dist, 0.0, 1.0));\n    \n    p = normalize(p);\n    float rad = atan(p.x / p.z) / (2.0 * PI);\n    float v = sin(rad) * 10.0;\n    float yDist = 1.0 - pow(max(abs(v - p.y), 0.0), 2.0);\n    yDist = 1.0 - clamp(pow(yDist, 0.2), 0.0, 1.0);\n    vec3 chocolat = vec3(0.82, 0.411, 0.117);\n    color = mix(color, chocolat, yDist);\n    return vec3(color);\n}\n\nvec3 topCakeColor(vec3 p) {\n    vec3 baseColor = vec3(1.2, 1.2, 1.0);\n    vec3 toppingColor = vec3(1.0, 0.5, 0.0);\n    \n    return vec3(p.y);\n}\n\nvec3 candleColor(vec3 p) {\n    p *= 5.0;\n    vec3 f = fract(p);\n    vec3 u = floor(p);\n    vec3 baseColor = vec3(1.0, 1.0, 1.0) * 1.2;\n    return vec3(rand3d(u.yyy) * baseColor);\n}\n\nvec3 getColor(float id, vec3 p) {\n    if (id < -0.5) { return vec3(0.0); }\n    if (id < 1.0) { return vec3(1.05, 1.0, 1.0); }\n    if (id < 2.0) { return bottomCakeColor(p); }\n    if (id < 3.0) { return topCakeColor(p); }\n    if (id < 4.0) { return vec3(0.82, 0.411, 0.117) * 0.4; }\n    if (id < 5.0) { return vec3(0.435, 0.176, 0.658); }\n    if (id < 6.0) { return candleColor(p); }\n    return vec3(1.0, 0.0, 0.0);\n}\n\nvec3 getNormal(vec3 p, vec2 info) {\n    const float epsilon = 0.001;\n    vec3 n = normalize(vec3(\n        map(p).x - map(vec3(p.x - epsilon, p.yz)).x,\n        map(p).x - map(vec3(p.x, p.y - epsilon, p.z)).x,\n        map(p).x - map(vec3(p.xy, p.z - epsilon)).x\n    ));\n    return n;\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float k) {\n    float depth = 0.01;\n    float res = 1.0;\n    vec2 dv = vec2(1.0, -1.0);\n    for (int i = 0; i < 30; i++) {\n        dv = map(ro + rd * depth);\n        res = min(res, smoothstep(0.0, 1.0, k * dv.x / depth));\n        if (res <= 0.0001) {\n            break;\n        }\n        depth += clamp(dv.x, 0.02, 2.0);\n    }\n    return res;\n}\n\nfloat directLighting(vec3 pos, vec3 n, vec3 lightPos, vec3 lightDir) {\n    float shadowIntensity = softShadow(pos + n * 0.001, lightDir, 5.0);\n    return shadowIntensity;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    float aspect = iResolution.x / iResolution.y;\n    uv.x *= aspect;\n    \n    float r = 1.0;\n    vec3 ro = vec3(sin(iTime * 0.1) * r, 1.0 + (sin(iTime * 0.05) * 0.5 + 0.5), cos(iTime * 0.1) * r);\n    vec3 center = vec3(sin(iTime * 0.5) * 0.1, 0.5 + (cos(iTime * 0.1) * 0.05), cos(iTime * 0.5) * 0.1);\n    \n    vec3 front = normalize(center - ro);\n    vec3 right = normalize(cross(front, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(right, front));\n    mat4 lookAt = mat4(\n        vec4(right, 0.0),\n        vec4(up, 0.0),\n        vec4(front, 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n    vec3 rd = normalize(vec3(lookAt * vec4(uv, 2.0, 1.0)));\n\n    vec2 info = intersect(ro, rd);\n    vec3 pos = ro + info.x * rd;\n    vec3 n = getNormal(pos, info);\n    \n    vec3 lightPos = vec3(1.5, 2.0, 0.0);\n    vec3 lightDir = normalize(lightPos);\n    \n    float attenuation = 1.0 * smoothstep(0.9, 1.0, dot(normalize(lightPos - pos), lightDir));\n    float ambient = 1.0;\n    float diffuse = max(dot(n, pos), 0.0);\n    float back = max(dot(n, vec3(-lightDir.x, 0.0, -lightDir.z)), 0.0);\n    float top = clamp(n.y * 0.8 + 0.2, 0.0, 1.0);\n    float fr = pow(clamp(1.0 + dot(n, rd), 0.0, 1.0), 3.0);\n    float sol = clamp(-n.y * 0.8 + 0.2, 0.0, 1.0) * pow(clamp(1.0 - pos.y, 0.0, 1.0), 2.0);\n    float shadow = directLighting(pos, n, lightPos, lightDir);\n    float specular = 0.0;\n    if (info.y > 3.1 && info.y < 5.0) {\n        vec3 refl = reflect(-lightDir, n);\n        specular = pow(max(dot(-rd, refl), 0.0), 16.0);\n    }\n    \n    vec3 light = vec3(0.0);\n    light += ambient * vec3(0.2, 0.2, 0.2) * attenuation * shadow;\n    light += diffuse * vec3(0.73, 0.7, 0.7) * attenuation;\n    light += back * vec3(0.2, 0.1, 0.1) * attenuation;\n    light += top * vec3(0.3, 0.3, 0.3) * attenuation;\n    light += fr * vec3(0.98, 1.0, 0.86) * attenuation;\n    light += sol * vec3(0.1, 0.1, 0.1) * attenuation;\n    light += specular * vec3(5.0, 5.0, 5.0) * attenuation * shadow;\n    \n    vec3 color = light * getColor(info.y, pos);\n\n    color = pow(color, vec3(0.4545));\n    \n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsXBz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 76, 115, 115, 218], [220, 220, 241, 241, 383], [385, 385, 406, 406, 609], [611, 611, 650, 650, 684], [686, 686, 705, 705, 723], [725, 725, 788, 788, 933], [935, 935, 968, 968, 1417], [1419, 1419, 1451, 1451, 1880], [1882, 1882, 1927, 1927, 2054], [2056, 2056, 2088, 2088, 2179], [2675, 2675, 2693, 2693, 3515], [3517, 3517, 3551, 3551, 3832], [3856, 3856, 3886, 3886, 4420], [4422, 4422, 4449, 4449, 4565], [4567, 4567, 4593, 4593, 4747], [4749, 4749, 4782, 4782, 5165], [5167, 5167, 5202, 5202, 5450], [5452, 5452, 5497, 5497, 5830], [5832, 5832, 5902, 5902, 6004], [6006, 6006, 6061, 6061, 8218]], "test": "valid"}
{"id": "WsXBz7", "name": "sphere and sineggcarton", "author": "NRGsama", "description": "Tried to recreate the shader from https://richardmattka.com/", "tags": ["raymarching", "sphere"], "likes": 2, "viewed": 129, "published": "Public", "date": "1587906307", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 80\n#define MAX_DIST 80.\n#define SURF_DIST .0001\n\nfloat sinPatt(vec3 p){\n\treturn 0.1 + abs(sin(p.x) - cos(p.y) + sin(p.z))*1.2 ;\n}\nfloat getDist(vec3 p) {\n\tvec4 s = vec4(0, 0, 0, 2);\n    //s.xz += vec2(2.*cos(iTime),2.*sin(iTime));\n    float angle = iTime*0.5;\n    float si = sin(angle);\n    float co = cos(angle);\n    \n    float scale = 5.+4.*sin(angle);\n    mat2 rotationMatrix = mat2( co, si,\n                               \t-si,  co);\n    //s.w = s.w*(1.2+0.2*sin(angle));\n    vec2 p1 = rotationMatrix*p.xz ;\n    p = vec3(p1.x,p.y,p1.y);\n    float sphereDist =  length(p-s.xyz)-s.w;\n    float d = max(sphereDist,(0.85-sinPatt(p*(scale)))/scale);\n    return  d;\n}\nfloat rayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = getDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\nvec3 getNormal(vec3 p) {\n\tfloat d = getDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        getDist(p-e.xyy),\n        getDist(p-e.yxy),\n        getDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 getColor(vec3 p) {\n    float amount = clamp((2.7 - length(p)) / 3.0, 0.0, 1.0);\n    vec3 col = vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5) * cos(6.28319 * (vec3(0.2, 0.0, 0.0) + amount * vec3(1.0, .9, 0.8)));\n    return col*amount ;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec3 ro = vec3(0,0,-5.+sin(iTime));\n    vec3 rd = normalize(vec3(uv.x,uv.y,1));\n    float d=0.;\n    vec3 col = vec3(0.);\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*d;\n        float dS = getDist(p);\n        d += dS;\n        if(d>MAX_DIST || dS<SURF_DIST) break;\n        col += 0.07*getColor(p);\n    }\n    \n    //return dO;\n    //vec3 p = ro + rd * d ;\n    //vec3 col = GetColor((p));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsXBz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 89, 89, 147], [148, 148, 171, 171, 683], [684, 684, 718, 718, 924], [925, 925, 949, 949, 1138], [1140, 1140, 1163, 1163, 1377], [1378, 1378, 1435, 1435, 1927]], "test": "valid"}
{"id": "wsXBz8", "name": "Undertale hearts", "author": "Necr0o0", "description": "Learning shaders, here's some reference to Undertale :D", "tags": ["learning"], "likes": 2, "viewed": 99, "published": "Public", "date": "1587672099", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define RED vec4(1.0,0.3,0.3,0.0)\n#define CYAN vec4(0.380, 0.937, 0.941,0.0)\n#define GREEN vec4(0.180, 0.694, 0.329,0.0)\n#define YELLOW vec4(0.964, 0.917, 0.047,0.0)\n#define GOLD vec4(0.909, 0.639, 0.129,0.0)\n#define PURPLE vec4(0.631, 0.309, 0.631,0.0)\n#define BLUE vec4(0.176, 0.431, 0.925,0.0)\n#define M_PI 3.14159265\n#define PIXEL_SIZE 10.0\n\nvec2 pixelSnap(vec2 coord)\n{\n    float pixelation = iResolution.y / PIXEL_SIZE;\n    return floor(coord * pixelation) / pixelation;\n}\n\nfloat getHeart(vec2 uv,vec2 offset)\n{\n    vec2 circleMovement = vec2(sin(iTime+offset.x),cos(iTime+offset.y))* 0.7;\n    circleMovement = pixelSnap(circleMovement);\n    uv += circleMovement;\n    uv.y *=1.2;\n    uv.y -= sqrt(clamp(abs(uv.x)+0.01,0.01,0.1) )*0.4;\n    float pixelSize = fwidth(uv.x);\n    float radius = 0.2 + pow(sin(2.0+uv.y *1.0) *0.2+0.2,2.0)*-0.1;\n    float circle = 1.0 - step(radius,length(uv)); \n    return circle;\n}\n\nfloat getHeart(vec2 uv)\n{\n    uv.y *=1.2;\n    uv.y -= sqrt(clamp(abs(uv.x)+0.01,0.0,0.1) )*0.4;\n    float pixelSize = fwidth(uv.x);\n    float radius = 0.2 + pow(sin(2.0+uv.y *1.0) *0.2+0.2,2.0)*-0.1;\n    float circle = 1.0 - step(radius,length(uv)); \n    return circle;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy)/iResolution.y;\n\tuv = pixelSnap(uv);\n\tfloat circut = 2.0 * 3.14;\n\n    vec4 heart1 = getHeart(uv)* RED;\n    vec4 heart2 = getHeart(uv,vec2(circut/6.0))* CYAN;\n    vec4 heart3 = getHeart(uv,vec2(2.*circut/6.))* GREEN;\n    vec4 heart4 = getHeart(uv,vec2(3.*circut/6.))* YELLOW;\n    vec4 heart5 = getHeart(uv,vec2(4.*circut/6.))* GOLD;\n    vec4 heart6 = getHeart(uv,vec2(5.*circut/6.))* PURPLE;\n    vec4 heart7 = getHeart(uv,vec2(6.*circut/6.))* BLUE;\n\n\n    \n    // Time varying pixel color\n    // Output to screen\n    fragColor = (heart1 + heart2 + heart3 + heart4 + heart5 + heart6+heart7);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsXBz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[346, 346, 374, 374, 478], [480, 480, 517, 517, 916], [918, 918, 943, 943, 1189], [1191, 1191, 1248, 1298, 1937]], "test": "valid"}
{"id": "wsXcDf", "name": "logistic_difference_v0005", "author": "darkczar", "description": "throw a dot product in there", "tags": ["psychedelic", "trippy", "chaos"], "likes": 1, "viewed": 27, "published": "Public", "date": "1585718874", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// based on...\n// https://www.shadertoy.com/view/lssfW2\n\nfloat nsin(float x)\n{\n    return .5+.5*sin(x);\n}\nfloat ncos(float x)\n{\n    return .5+.5*cos(x);\n}\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}  //https://gist.github.com/companje/29408948f1e8be54dd5733a74ca49bb9\n\nhighp float rand(vec2 co)  //from stackoverflow\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nuint hash( uint x ) {  //http://amindforeverprogramming.blogspot.com/2013/07/random-floats-in-glsl-330.html\n\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\nfloat random( float f ) {  //http://amindforeverprogramming.blogspot.com/2013/07/random-floats-in-glsl-330.html\n\n    const uint mantissaMask = 0x007FFFFFu;\n    const uint one          = 0x3F800000u;\n   \n    uint h = hash( floatBitsToUint( f ) );\n    h &= mantissaMask;\n    h |= one;\n    \n    float  r2 = uintBitsToFloat( h );\n    return r2 - 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float r = 0.0;\n    float g = 0.0;\n    float b = 0.0;\n    vec2 xy0 = vec2(0.,0.);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p=(fragCoord.xy-iResolution.xy)/iResolution.y;\n    \n    vec2 xy = vec2(0.,0.);\n    // r between 3.75 and 4.0 produces chaotic behavior\n    float rr = .5*(ncos(.05*iTime))+3.5; // + .5*nsin(iTime*.5); //2.57 +nsin(iTime); //+cos(iTime);\n    xy = uv;\n    //int max_iter = int(6.0 + floor(8.0*nsin(iTime*.2)));\n    for (int i = 0; i<6; i++)\n    {\n        xy = rr*xy*(vec2(1.0,1.0)-xy);\n        if(i==0)\n        {\n          xy0 = xy;  \n        }\n        if (i>1)\n            {\n                if(abs(length(xy) - length(xy0)) < .01) // try and tease out the cycles and color them\n                {\n                    r = 1.*random(float(mod(float(i),15.00)))*nsin(iTime);\n                    g = 1.*random(1.28+float(mod(float(i),15.0)));\n                    b = 1.*random((1.0 - float(mod(float(i),15.0))))*ncos(iTime);\n                } else if (dot(normalize(xy),normalize(xy0)) > .98)\n                {\n                    r = 1.*random((1.0 - float(mod(float(i),15.0))))*ncos(iTime);\n                    g = 1.0 - 1.*random(1.28+float(mod(float(i),15.0)));\n                    b = 1.*random(float(mod(float(i),15.00)))*nsin(iTime);\n                }\n            }\n    }\n    if (length(xy) > 1.0)\n    {\n        r = .0;\n        g = 0.0;\n        b = 0.0;\n    } else\n    {\n        //r = .05;\n        //g = .99;\n        //b = .3;\n    }\n        \n        //m = (rand_point.x-prev_point.x) / ((rand_point.y-prev_point.y);\n        //line_y = m*p.x +  \n\n\n    \n    vec3 col = vec3(r, g, b);\n    float dn = col.x + col.y + col.z;\n    col /= dn;\n    // Output to screen\n    //fragColor = vec4(col,1.0);\n    fragColor = vec4( pow(col,vec3(1./2.2)),1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsXcDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 79, 79, 106], [107, 107, 128, 128, 155], [157, 157, 229, 229, 295], [616, 616, 637, 723, 855], [856, 856, 881, 967, 1204], [1206, 1206, 1263, 1263, 3091]], "test": "valid"}
{"id": "WsXcWs", "name": "mandelbrot with fractional power", "author": "sniffle", "description": "another mandelbrot shader", "tags": ["fractal", "madelbrot"], "likes": 2, "viewed": 64, "published": "Public", "date": "1585807550", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float zoom = 0.1;\nvec2 center = vec2(-0.58, 0.5);\nfloat PI = 3.14159265359;\nint max_i = 200;\nfloat POWER = 2.0;\n\nvec2 toPolar(vec2 c)\n{\n    float r = length(c);\n    float arg = 0.0;\n\n    arg = atan(c.y/c.x);\n    return vec2(r, arg);\n}\nvec2 toCartesian(vec2 pol)\n{\n    vec2 c;\n    c.x = pol.x*cos(pol.y);\n    c.y = pol.x*sin(pol.y);\n    return c;\n}\n\nint iterate(vec2 c)\n{\n    vec2 pol;\n    vec2 c_temp = c;\n    for(int i = 0; i < max_i; i++)\n    {\n        if(length(c_temp) > 2.0)\n            return i;\n        pol = toPolar(c_temp);\n        pol.x = pow(pol.x, POWER);\n        pol.y *= POWER;\n        c_temp = toCartesian(pol);\n        c_temp += c;\n    }\n    return max_i;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    POWER = 10.0*iTime/iResolution.x + 1.96;\n   // center = iMouse.xy/iResolution.xy - 0.5;\n    // Normalized pixel coordinates (from 0 to 1);\n    vec2 worldCoord = zoom*(fragCoord-0.5*iResolution.xy)/iResolution.y + center;\n    \n    float col = 1.0 - float(iterate(worldCoord))/float(max_i);\n\n    // Output to screen\n    fragColor = vec4(col,col,col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsXcWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[113, 113, 135, 135, 234], [235, 235, 263, 263, 347], [349, 349, 370, 370, 673], [675, 675, 732, 732, 1091]], "test": "valid"}
{"id": "WsXfDn", "name": "Coloured Collatz fractal", "author": "hamalan", "description": "Collatz fractal", "tags": ["fractal", "collatz"], "likes": 0, "viewed": 239, "published": "Public API", "date": "1587989157", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Original code created by Trashe725\n\n#define AA 4\n#define pi 3.14159265358979323846\n#define maxIter 100\n#define maxThres 100.\n\n// from julesb\n// github: https://github.com/julesb/glsl-util/blob/master/complexvisual.glsl\n\nfloat sinnh(float a) { return float(0.5*( exp(a) - exp(-a))); }\nfloat cossh(float a) { return float(0.5*( exp(a) + exp(-a))); }\nfloat tannh(float a) { return float(sinnh(a)/cossh(a)); }\nvec2 cx_add(vec2 a, float b) { return vec2(a.x+b, a.y); }\nvec2 cx_mul(vec2 a, vec2 b) { return vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x); }\nvec2 cx_div(vec2 a, vec2 b) { return vec2((a.x*b.x+a.y*b.y)/(b.x*b.x+b.y*b.y), (a.y*b.x-a.x*b.y)/(b.x*b.x+b.y*b.y)); }\nvec2 cx_cos(vec2 a) { return vec2(cos(a.x) * cossh(a.y), -sin(a.x) * sinnh(a.y)); }\nvec2 cx_sin(vec2 a) { return vec2(sin(a.x) * cossh(a.y), cos(a.x) * sinnh(a.y)); }\nvec2 cx_tanh(vec2 a) { return vec2(cx_div(cx_sin(a),cx_cos(a))); }\n\nvec3 render(vec2 fragCoord, float time)\n{\n    //zoom\n    float sc = 0.12;\n    // Center of the image\n    vec2 ce = vec2(1.99, 0.0);\n    float zoom = time;\n    sc = sc * pow(0.9, zoom);\n    \n    vec2 fc = (-iResolution.xy + 2.0 *fragCoord) / iResolution.x;\n    vec2 z = ce + sc * fc;\n    vec2 dz = vec2(1.0, 0.0);\n    \n    vec2 lz = z;\n    vec2 ldz = dz;\n    \n    //iter\n    int iter = 0;\n    while(iter < maxIter && length(z) < maxThres){\n        lz = z;\n        ldz = dz;\n        vec2 piz = pi*z;\n        dz = cx_add( pi*cx_mul(cx_sin(piz), cx_add(z*4., 2.))-5.*cx_cos(piz), 7.)/4.;\n        z = ( cx_add(z*7., 2.) - cx_mul(cx_add(z*5., 2.), cx_cos(piz)) )/4.;\n        ++iter;\n    }\n    \n    //color\n    float de = length(lz)*log(length(lz))/length(ldz);\n    if (iter < maxIter && length(ldz) < maxThres){\n        \n        return vec3(1.0, 1.0, 1.0);\n    } else {\n    \treturn vec3(0.0, sin(clamp( length(dz), 0.0, 1.0)), tannh(clamp(length(ldz), 0.0, 1.0)));\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.0);\n    float time = -sin(iTime/10.)*9.1 + pi/2.;\n#ifdef AA\n    for(int m=0;m<AA;++m){\n        for(int n=0;n<AA;++n){\n        \tvec2 px = fragCoord + vec2(float(m), float(n))/float(AA);\n            col += render(px, time);\n        }\n    }\n    \n    col /= float(AA*AA);\n#else\n    col = render(fragCoord, time);\n#endif\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsXfDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[223, 223, 245, 245, 286], [287, 287, 309, 309, 350], [351, 351, 373, 373, 408], [409, 409, 439, 439, 466], [467, 467, 496, 496, 545], [546, 546, 575, 575, 664], [665, 665, 686, 686, 748], [749, 749, 770, 770, 831], [832, 832, 854, 854, 898], [900, 900, 941, 952, 1866], [1868, 1868, 1925, 1925, 2297]], "test": "valid"}
{"id": "WsXfRn", "name": "izvor", "author": "merrecurent_", "description": "vefneqv", "tags": ["noob"], "likes": 4, "viewed": 129, "published": "Public", "date": "1587714284", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n   \n    \n    \n    //resize space\n    uv *= 13.;\n    \n    vec2 st = vec2(atan(cos(uv.x*(1.-.2*cos(.6*iTime))), cos(uv.y*(1.-.2*cos(.6*iTime)))), length(uv));\n    \n    uv = vec2(st.x/6.2831*10. + 3.*sin(iTime), st.y*sin(.2*iTime - st.y*.1));\n    \n    //tile the space\n    vec2 i_uv = floor(uv);\n    vec2 f_uv = fract(uv);\n    \n    \n    \n    float minDist = 1.;\n    \n    for (int y = -1; y <= 1; y++)\n    \tfor (int x = -1; x <= 1; x++)  \n    \t{\n    \t\tvec2 neighbor = vec2(float(x), float(y));\n            \n            \n            //random position from current + neighbor place in the grid\n            vec2 point = random2(i_uv + neighbor);\n            \n            point = .5 + .5*sin(iTime + 6.2831*point);\n            \n            //vector between the pixel and the point\n            vec2 diff = neighbor + point - f_uv;\n            \n            float dist = length(diff);\n            \n        \tminDist = min(minDist, dist);\n        \n         \n    \t}\n\t\n    vec3 color = 1.2*minDist*vec3(.85 + .2*uv.x, .7, .65 + .1*uv.y);\n    \n    //draw cell center\n    color += .9 * smoothstep(.09, .01, minDist);\n    //color += step(.98, f_uv.x) + step(.98, f_uv.y);\n    \n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsXfRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 117], [120, 120, 177, 177, 1476]], "test": "valid"}
{"id": "WsXfW8", "name": "DoF DNA Helix", "author": "jaszunio15", "description": "DNA Helix - live coded during TK Games Shader Course.\n\nShader License: CC BY 3.0\nAuthor: Jan Mróz (jaszunio15)", "tags": ["dof", "helix", "dna"], "likes": 4, "viewed": 114, "published": "Public", "date": "1588096704", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Shader License: CC BY 3.0\n//Author: Jan Mróz (jaszunio15)\n\n//source: https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdBox( in vec2 uv, in vec2 boxSize )\n{\n    vec2 d = abs(uv) - boxSize;\n    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}\n\nfloat square(vec2 uv, vec2 center, float size, float blur)\n{\n    float pixelSize = fwidth(uv.y);\n\tfloat sdf = sdBox(uv - center, vec2(size - pixelSize * blur * 0.5));\n    return smoothstep(pixelSize * blur, -pixelSize, sdf);\n}\n\nfloat depthToColor(float depth)\n{\n \treturn mix(0.2, 1.0, depth);   \n}\n\nfloat depthToBlur(float depth)\n{\n \treturn mix(10.0, 1.0, depth);   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 baseUV = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    baseUV *= 5.0;\n    float pixelSize = fwidth(baseUV.x);\n    \n    float angle = 0.3;\n    baseUV *= mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n    \n    float uvPos = floor(baseUV.x) * 0.3;\n    vec2 uv = vec2(fract(baseUV.x) - 0.5, baseUV.y);\n    \n    float sinDNA = sin(uvPos + iTime);\n    float cosDNA = cos(uvPos + iTime);\n    \n    float dnaPos1 = sinDNA * 2.0;\n    float dnaPos2 = -sinDNA * 2.0;\n    \n    float dnaDepth1 = cosDNA * 0.5 + 0.5;\n    float dnaDepth2 = -cosDNA * 0.5 + 0.5;\n    \n    float depthLine = mix(dnaDepth1, dnaDepth2, smoothstep(dnaPos1, dnaPos2, uv.y));\n    \n    float lineBlur = depthToBlur(depthLine);\n    float lineAlpha = smoothstep(2.0 * pixelSize * lineBlur * 0.5, -pixelSize * lineBlur , abs(uv.x));\n    lineAlpha *= 1.0 - step(abs(dnaPos1), abs(uv.y));\n\n    float square1Alpha = square(uv, \n                                vec2(0.0, dnaPos1), \n                                dnaDepth1 * 0.2 + 0.2, \n                                depthToBlur(dnaDepth1));\n    float square2Alpha = square(uv, \n                                vec2(0.0, dnaPos2), \n                                dnaDepth2 * 0.2 + 0.2, \n                                depthToBlur(dnaDepth2));\n    \n    float image = 0.0;\n    \n    if (dnaDepth1 > dnaDepth2)\n    {\n        image = mix(image, depthToColor(dnaDepth2), square2Alpha);\n        image = mix(image, depthToColor(depthLine), lineAlpha);\n        image = mix(image, depthToColor(dnaDepth1), square1Alpha);\n    }\n    else\n    {\n        image = mix(image, depthToColor(dnaDepth1), square1Alpha);\n        image = mix(image, depthToColor(depthLine), lineAlpha);\n        image = mix(image, depthToColor(dnaDepth2), square2Alpha);\n    }\n    \n    fragColor = vec4(image);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsXfW8.jpg", "access": "shaders20k", "license": "cc-by-3.0", "functions": [[62, 148, 192, 192, 284], [286, 286, 346, 346, 512], [514, 514, 547, 547, 583], [585, 585, 617, 617, 654], [656, 656, 713, 713, 2518]], "test": "valid"}
{"id": "wsXfWN", "name": "Spiral vortex", "author": "themasmo", "description": "A Lot of circles rotate around the y axe", "tags": ["circles", "vortex"], "likes": 2, "viewed": 78, "published": "Public", "date": "1588256108", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define N 400.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = 2.0*( fragCoord.xy / iResolution.xy ) - 1.0;\n    p.x *= iResolution.x/iResolution.y;\n\n\tfloat color = 0.0;\n\tfloat mk=floor(45.*iMouse.x);\t// Click to change number of spirals\n\tfloat ft=(3.141/180.)*mk;\n\tfor(float t=0.;t<N;t++)\n\t{\n\t\tfloat an=t*ft+5.*iTime;\n\t\tfloat rg=(t/N+abs(cos(t*2.)))/2.;\n\t\tfloat kx=t/N;\n\t\tfloat x=(kx*rg)*cos(an);\n\t\tfloat y=-0.5+t/N+(rg*.3)*sin(an);\n\t\tvec2 r=vec2(x,y);\n\t\tfloat d=abs(0.02+0.01*sin(an+3.141));\n\t\tif(distance(p,r)<d)\n\t\t\t\tcolor=d*30.;\n\t}\n\t\n\n\tfragColor = vec4( vec3( color ), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsXfWN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[16, 16, 73, 73, 601]], "test": "valid"}
{"id": "WsXfz7", "name": "Psychedelic burning Wheel (2D)", "author": "mrange", "description": "Psychedelic burning wheel. A simple variation of an earlier shader: https://www.shadertoy.com/view/tdScD1", "tags": ["2d"], "likes": 8, "viewed": 344, "published": "Public API", "date": "1587887897", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License: CC0\n//  Psychedelic burning wheel. A simple variation of an earlier shader: https://www.shadertoy.com/view/tdScD1\n\n\n// Experiment with these parameters for variants\nconst float size  = 0.75 ;\nconst float offc  = 1.05;\nconst float width = 0.0125;\nconst int   rep   = 15 ;\n\n#define PHI   (.5*(1.+sqrt(5.)))\n#define PI    3.141592654\n#define TAU   (2.0*PI)\n#define TIME  iTime\n#define TTIME (TAU*TIME)\n\nconst vec3 plnormal = normalize(vec3(1, 1, -1));\nconst vec3 n1 = normalize(vec3(-PHI,PHI-1.0,1.0));\nconst vec3 n2 = normalize(vec3(1.0,-PHI,PHI+1.0));\nconst vec3 n3 = normalize(vec3(0.0,0.0,-1.0));\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat box(vec2 p, vec2 b, float r) {\n  vec2 d = abs(p) - (b - r);\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r;\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nvec2 toPolar(vec2 p) {\n  return vec2(length(p), atan(p.y, p.x));\n}\n\nvec2 toRect(vec2 p) {\n  return vec2(p.x*cos(p.y), p.x*sin(p.y));\n}\n\nfloat dodec(in vec3 z) {\n  vec3 p = z;\n  float t;\n  z = abs(z);\n  t=dot(z,n1); if (t>0.0) { z-=2.0*t*n1; }\n  t=dot(z,n2); if (t>0.0) { z-=2.0*t*n2; }\n  z = abs(z);\n  t=dot(z,n1); if (t>0.0) { z-=2.0*t*n1; }\n  t=dot(z,n2); if (t>0.0) { z-=2.0*t*n2; }\n  z = abs(z);\n\n  float dmin=dot(z-vec3(size,0.,0.),plnormal);\n        \n  dmin = abs(dmin) - width*7.5*(0.55 + 0.45*sin(10.0*length(p) - 0.5*p.y + TTIME/9.0));\n        \n  return dmin;\n}\n\nfloat weird(vec2 p) {\n  float d = 100000.0;\n  float off = 0.30  + 0.25*(0.5 + 0.5*sin(TTIME/11.0));\n  float a = atan(p.y, p.x);\n  float r = length(p);\n  for (int i = 0; i < rep; ++i) {\n    vec2 ip = p;\n    //rot(ip, i*TAU/rep + 0.5*(r+0.5*p.x) - a*1.0);\n    rot(ip, float(i)*TAU/float(rep));\n    ip -= vec2(offc*size, 0.0);\n    vec2 cp = ip;\n    rot(ip, TTIME/73.0);\n    float dd = dodec(vec3(ip, off*size));\n    float cd = length(cp - vec2(0.25*sin(TTIME/13.0), 0.0)) - 0.125*size;\n    cd = abs(cd) - width*0.5;\n    d = pmin(d, dd, 0.05);\n    d = pmin(d, cd, 0.025);\n  }\n  return d;\n}\n\nfloat wheel(vec2 p, float s) {\n  vec2 pp = toPolar(p);\n  pp.y += TTIME/60.0;\n  mod1(pp.y, TAU/10.0);\n  pp.y += PI/2.0;\n  p = toRect(pp);\n  float ds = box(p, s*vec2(0.075, 0.5), s*0.04);\n  \n  float dc = circle(p, s*0.375);\n  \n  return pmin(ds, dc, s*0.0125);\n}\n\nfloat df(vec2 p) {\n  float dc = wheel(p, 3.0);\n  dc = abs(dc) - 0.2;\n  dc = abs(dc) - 0.1;\n  dc = abs(dc) - 0.05;\n  float dw = weird(p);\n  return pmin(dw, dc, mix(0.05, 0.5, (0.5 - 0.5*cos(TTIME/120.0))));\n}\n\nvec3 postProcess(vec3 col, vec2 q, vec2 p) {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  const float r = 1.5;\n  float d = max(r - length(p), 0.0)/r;\n  col *= vec3(1.0 - 0.25*exp(-200.0*d*d));\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord.xy / iResolution.xy;\n  vec2 p = 2.0*(q - 0.5);\n  p.x *= iResolution.x/iResolution.y;\n  float d = df(p);\n\n  float fuzzy = 5.0/iResolution.x;\n    \n  vec3 col = vec3(0.0);\n\n  const vec3 baseCol = vec3(240.0, 175.0, 20.0)/255.0;\n  \n  col += 0.9*baseCol*vec3(smoothstep(fuzzy, -fuzzy, d));\n\n  vec3 rgb = 0.5 + 0.5*vec3(sin(TAU*vec3(50.0, 49.0, 48.0)*(d - 0.050) + TTIME/3.0));\n\n  col += baseCol.xyz*pow(rgb, vec3(8.0, 9.0, 7.0)); \n  col *= 1.0 - tanh(0.05+length(8.0*d));\n\n  float phase = TAU/4.0*(-length(p) - 0.5*p.y) + TTIME/11.0;\n \n  float wave = sin(phase);\n  float fwave = sign(wave)*pow(abs(wave), 0.75);\n \n  col = abs(0.79*(0.5 + 0.5*fwave) - col);\n  col = pow(col, vec3(0.25, 0.5, 0.75));\n  col = postProcess(col, q, p);\n\n  col = clamp(col, 0.0, 1.0);\n\n  col += 1.0 - smoothstep(0.0, 3.0, TIME);\n\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsXfz7.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[611, 611, 642, 642, 668], [670, 670, 706, 706, 794], [796, 796, 829, 829, 914], [916, 916, 955, 955, 1044], [1046, 1046, 1085, 1085, 1210], [1212, 1212, 1234, 1234, 1278], [1280, 1280, 1301, 1301, 1346], [1348, 1348, 1372, 1372, 1782], [1784, 1784, 1805, 1805, 2369], [2371, 2371, 2401, 2401, 2630], [2632, 2632, 2650, 2650, 2839], [2841, 2841, 2885, 2885, 3167], [3169, 3169, 3224, 3224, 4078]], "test": "error"}
{"id": "WsXyDs", "name": "logistic_difference_v0010", "author": "darkczar", "description": "psychedelic", "tags": ["trippy"], "likes": 1, "viewed": 27, "published": "Public", "date": "1585808796", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// based on...\n// https://www.shadertoy.com/view/lssfW2\n\nfloat nsin(float x)\n{\n    return .5+.5*sin(x);\n}\nfloat ncos(float x)\n{\n    return .5+.5*cos(x);\n}\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}  //https://gist.github.com/companje/29408948f1e8be54dd5733a74ca49bb9\n\nhighp float rand(vec2 co)  //from stackoverflow\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nuint hash( uint x ) {  //http://amindforeverprogramming.blogspot.com/2013/07/random-floats-in-glsl-330.html\n\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\nfloat random( float f ) {  //http://amindforeverprogramming.blogspot.com/2013/07/random-floats-in-glsl-330.html\n\n    const uint mantissaMask = 0x007FFFFFu;\n    const uint one          = 0x3F800000u;\n   \n    uint h = hash( floatBitsToUint( f ) );\n    h &= mantissaMask;\n    h |= one;\n    \n    float  r2 = uintBitsToFloat( h );\n    return r2 - 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float r = 0.0;\n    float g = 0.0;\n    float b = 0.0;\n    vec2 xy0 = vec2(0.,0.);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p=(fragCoord.xy-iResolution.xy)/iResolution.y;\n    \n    vec2 xy = vec2(0.,0.);\n    float rr = .5*(nsin(.5*iTime))+3.45; // + .5*nsin(iTime*.5); //2.57 +nsin(iTime); //+cos(iTime);\n    xy = uv;\n    for (int i = 0; i<4; i++)\n    {\n        xy = rr*xy*(vec2(1.0,1.0)-xy);\n        if(i==0)\n        {\n          xy0 = xy;  \n        }\n        if (i>0)\n            {\n                if(abs(length(xy) - length(xy0)) < .005 +.02*ncos(iTime*.15)) // try and tease out the cycles and color them\n                {\n                    r = 1.*random(float(mod(float(i),7.0)));\n                    g = 1.*random(1.28+float(mod(float(i),7.0)));\n                    b = 1.*random((1.0 - float(mod(float(i),7.0))));\n                }\n            }\n    }\n    if (length(xy) > .25+1.0*sin(iTime*.3))\n    {\n        r = 1.0 - mod(length(xy),2.);\n        g = 0.2;\n        b = mod(3.,length(xy));\n    } else\n    {\n        //r = .05;\n        //g = .99;\n        //b = .3;\n    }\n        \n        //m = (rand_point.x-prev_point.x) / ((rand_point.y-prev_point.y);\n        //line_y = m*p.x +  \n\n\n    \n    vec3 col = vec3(r, g, b);\n    float dn = col.x + col.y + col.z;\n    col /= dn;\n    // Output to screen\n    //fragColor = vec4(col,1.0);\n    fragColor = vec4( pow(col,vec3(1./2.2)),1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsXyDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 79, 79, 106], [107, 107, 128, 128, 155], [156, 156, 228, 228, 294], [615, 615, 636, 722, 854], [855, 855, 880, 966, 1203], [1205, 1205, 1262, 1262, 2708]], "test": "valid"}
{"id": "wt3SW8", "name": "Voxel Traversal 2D", "author": "spalmer", "description": "lattice cell marching algorithm to compute which cells possibly intersect ray, in order.  Trying to get Bresenham style DDA to work w fractions.", "tags": ["grid", "line", "bresenham", "lattice"], "likes": 6, "viewed": 241, "published": "Public", "date": "1588252266", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// this toy is so cluttered now, with variant implementations,\n// it really needs some work cleaning up.\n\n// btw this got forked into 3D in\n// toys https://shadertoy.com/view/WslBWH\n// and https://shadertoy.com/view/wdsfWn\n\n// iq's line segment distance, trimmed & renamed\n// just so I can see the mouse ray\nfloat seg(vec2 p, vec2 a, vec2 b)\n{\n    p -= a; b -= a; return length(p - b *\n        clamp(dot(p, b) / dot(b, b), 0., 1.));\n}\n\n// This is a testbed.  \n// A terrible testbed; I have better ones!\n// For this testbed, \n// the conditions and results of \n// the test are quite simple\n// and are communicated by \n// these global variables:\n\nbool celltouchesline = false;\n//vec2 qf;  // query pixel in grid space\nivec2 qi; // query pixel grid cell coordinate\n\n// simply checks if qi is among the cells visited\nbool Condition(ivec2 i) { return qi == i; }\n// return false to stop, true to keep going\nbool Traverse(ivec2 i) { celltouchesline = true; return true; }\n\n#if 0 \n// low-tech inefficient method I just made\n// just scans the segment's bounding box\n// for cells that are \"close enough\" to the line\n// which incorrectly flags some cells that it shouldn't FIXME\n// anyway yeah, it's way overly conservative and has issues\n// will flag too many cells that shouldn't be, but \n// will sort of get the job done for the time being\n// and is still better than the naive bounding\n// box iter without seg distance check.\n// really, if using a bounding box for each cell anyway,\n// could get away with just iterating the seg's bounding box.\n// anyway it basically *works* and \n// handles floating point coordinates properly.\n// it just isn't a very good algorithm.\nvoid Scan2B(vec2 pa, vec2 pb)\n{\n    ivec2 a = ivec2(floor(pa)), b = ivec2(floor(pb))\n        , d = b-a, s = sign(d);\n    if (s.x == 0) s.x = 1; // at least 1\n    if (s.y == 0) s.y = 1;\n    d += s;\n    for (int y = 0; y != d.y; y += s.y)\n    for (int x = 0; x != d.x; x += s.x) {\n        ivec2 p = ivec2(x,y) + a;\n        if (seg(vec2(p) + .5, pa, pb) <= .7072)\n\t        if (Condition(p)) // your condition\n                if (!Traverse(p)) // your traversal function\n       \t             break; \n   \t\t}\n}\n// this loop is a bit wacky due to bidirectionality.\n// if qi not in the [a,b] box, there's no\n// way it will flag a cell, could early out,\n// but this example should be kept simple\n#endif\n\n#if 0\n// try out some bresenham; \n// I have the original Gem book... doesn't help.\n// I'm sure I've done this before, I can't find my code though.\n\n// Integer voxel traversal\n\n// adapted from https://www.shadertoy.com/view/XdBGDG\n// by https://www.shadertoy.com/user/Dave_Hoskins\n\n// Originally from Graphics Gems IV\n// http://read.pudn.com/downloads56/sourcecode/graph/texture_mapping/194552/gemsiv/vox_traverse.c__.htm\n\n// only int adds...  old skool indeed!\n// when starting at p heading +d\n// you could obviously do something fancier\nvoid Scan2I(ivec2 p, ivec2 d)\n{\n\tivec2 s = sign(d), a = abs(d), b = a + a;\n\tint e = a.y - a.x, n = a.x + a.y;\n    for (int i = 0; i <= n; ++i) {\n\t\tif (Condition(p)) // your condition\n            if (!Traverse(p)) // your traversal function\n                 break; \n\t\tif (e < 0) {\n\t\t\tp.x += s.x;\n\t\t\te += b.y;\n\t\t} else {\n\t\t\tp.y += s.y;\n\t\t\te -= b.x;\n\t\t}\n    }\n}\n// actually a rather poor truncating wrapper over Scan2DI - do not use except to see Scan2D operate\nvoid Scan2IF(vec2 a, vec2 b)\n{\n    ivec2 o = ivec2(floor(a));\n\tScan2I(o, ivec2(floor(b))-o);\n}\n#endif\n\n#if 0\n// will need to modify this anyway since it must handle fractional starting position\n// and float vector direction\nvoid Scan2F(vec2 pa, vec2 pb)\n{ // not quite!  must initialize the error better\n\tvec2 d = pb - pa;\n    ivec2 s = ivec2(sign(d)), p = ivec2(floor(pa));\n    vec2 a = abs(d), b = a + a;\n\tfloat e = a.y - a.x;\n    int n = int(round(a.x) + round(a.y)); // idk if this is precise\n    // must bias away from .5 cell center depending on initial fraction of pa\n    // but I'll be damned if I can understand how to fudge this integer to account for that.\n    // e is really complicated.  Hoskins tore this out of the Gem already.\n    // but he didn't explain it to me when he did!  So I'm looking at it now\n    // trying to unravel the gradient ratios involved.  fun!\n    // Dammit I wish I hadn't lost my old implementation of this! \n    // I had this all worked out once upon a time.\n    // Alas I think I'll give up on it again for the day.  Hurts my brain.\n    vec2 f = pa - vec2(p);\n    vec2 bias = f - .5;\n\n    for (int i = 0; i <= n; ++i) {\n\t\tif (Condition(p)) // your condition\n            if (!Traverse(p)) // your traversal function\n                break;\n\t\tif (e < 0.) {\n\t\t\tp.x += s.x;\n\t\t\te += b.y;\n\t\t} else {\n\t\t\tp.y += s.y;\n\t\t\te -= b.x;\n\t\t}\n    }\n}\n// I actually need float precision in my coordinates\n// for perfect ray-cell traversal, so...\n// must redo part of the initialization anyway to handle that.\n// it's not that super tricky iirc.\n\n#endif \n// actual DDA - WIP\n\n// from https://shadertoy.com/view/ttyXRR\n#if 1\n// originally from unnick's https://shadertoy.com/view/wtXSW8\n// stripped down to just the DDA portion\n// the dda raycaster; returns fine distance traced which this toy doesn't use\nfloat Scan2DDA2(vec2 pa, vec2 pb)\n{ \n    vec2 ro = pa, pd = pb - pa\n    , rd = normalize(pd), nrd = normalize(rd)\n    , ad = abs(pd)\n    , dd = 1. / abs(nrd)\n    , pos = ro\n    , sd = fract(pos);\n    ivec2 mp = ivec2(floor(pa)) // tile iterator\n    , aid = abs(ivec2(floor(pb))-mp)\n    , st = ivec2(sign(rd)); // step direction\n    int side = 0;\n    if (st.x > 0) sd.x = 1. - sd.x;\n    if (st.y > 0) sd.y = 1. - sd.y;\n    sd *= dd;\n    int nsteps = 1+aid.x+aid.y;\n    for (int i = nsteps; --i >= 0; ) {\n        if (Condition(mp))\n            if (!Traverse(mp))\n            \tbreak;\n        side = int(sd.x >= sd.y);\n        switch (side) {\n            case 0: sd.x += dd.x; mp.x += st.x; break;\n        \tcase 1: sd.y += dd.y; mp.y += st.y; break;\n        }\n    }\n    float dist = float(mp[side]) - pos[side];\n    dist += float((1 - st[side]) / 2);\n    dist /= 1.*rd[side]; // unproject distance from axial to along ray\n    return dist;\n}\n#endif\n\n#if 0\n// from https://shadertoy.com/view/3lySWm\n// which is originally from https://shadertoy.com/view/ltXBz7\nfloat Scan2DDA3(vec2 m0, vec2 m1) //, vec2 result) \n{\n    vec2 ro = m0, rd = m1 - m0\n    , n = vec2(0), c = floor(ro) + .5;\n    ro -= c; // ro now just a (signed?) fraction\n    const int maxiter = 36; //40; //42; //\n    int niter = 0+int(ceil(abs(rd.x)))+int(ceil(abs(rd.y))); // borked\n    rd = normalize(rd);\n    float totald = 0.;\n    for (int s = min(niter,maxiter); s-- > 0; ) {\n        ivec2 q = ivec2(c + ro);\n        if (Condition(q))\n            if (!Traverse(q))\n            \tbreak;\n        vec2 d = (sign(rd)*.5 - ro) / rd;\n        float adv = min(d.x, d.y);\n        totald += adv; // all these small adds may not work though\n        ro += adv * rd;\n        n = -sign(rd) * step(d.xy, d.yx);\n        c -= n;\n       \tro += n;\n    }\n    return totald;\n}\n#endif\n// FIXME not quite working yet, need I bust out my sledgehammer?\n\n#if 1\n// my modification of ocb's idea\n// from ocb's https://shadertoy.com/view/4lscDn\n// was called getNextBox(); quite good DDA step function-\n// tiny, simple, completely dynamic, fast.  Clever!\n// but I had to change it up quite a bit to get it shoe-horned\n// into my existing framework, to provide the step distance required etc.\n// what I wound up with is pretty simple also; slightly refactored I suppose.\n\n// btw sign() for me on OpenGL ES is bugged and returns zero for zero inputs\n// instead of the expected positive 1, and also\n// can give slightly below 1.0 which truncates to zero incorrectly.\n// so I use these replacements:\nvec2 sgn(vec2 v)\n{\n    return vec2((v.x < 0. ? -1. : 1.)\n              , (v.y < 0. ? -1. : 1.));\n}\n\nvec3 sgn(vec3 v)\n{\n    return vec3((v.x < 0. ? -1. : 1.)\n              , (v.y < 0. ? -1. : 1.)\n              , (v.z < 0. ? -1. : 1.));\n}\n\nfloat nextCell(vec2 p, vec2 v)\n{\n    vec2 dt = (floor(p) + .5 + .5 * sgn(v) - p) / v;\n    return min(dt.x, dt.y);\n}\n\nfloat nextCell(vec3 p, vec3 v)\n{\n    vec3 dt = (floor(p) + .5 + .5 * sgn(v) - p) / v;\n    return min(min(dt.x, dt.y), dt.z);\n}\n\n// what makes a DDA special is the logic for multiple dimensions\n// to decide which is the *next* cell, whose boundary will be \n// crossed first.  Here that's a divide, some min, a step, and a few other ops.\n\nfloat Scan2DDAnext(vec2 pa, vec2 pb)\n{\n    float t = 0.;\n    vec2 ro = pa, pd = pb - pa\n    , rd = normalize(pd);\n    vec2 mp = pa; // tile iterator\n    ivec2 aid = abs(ivec2(floor(pb)-floor(pa)));\n    int nsteps = 1+aid.x+aid.y;\n    for (int i = nsteps; --i >= 0; ) {\n        ivec2 ip = ivec2(floor(mp));\n        if (Condition(ip))\n            if (!Traverse(ip))\n            \tbreak;\n        float tnc = nextCell(mp, rd);\n        tnc += 1e-5; // ensure we get all the way into the cell, since it's probably exactly on the edge\n\t\tt += tnc;\n        mp = ro + rd * t;\n    }\n    return t;\n}\n\n#endif\n\n#if 0\n// closer to ocb's originals\n// from ocb's https://shadertoy.com/view/4lscDn\n// was called getNextBox(); nicest DDA step function I've seen!\n// tiny, simple, completely dynamic, fast.  Clever!\n// TODO merge in somehow, try it out; I already rearranged\n// it somewhat, eliminated some temp variables used once.\n// changed dim (was boxDim) to an argument, etc.  Went back to 2D too.\n// Easy enough and good to have both variants in one place. --Sean\n// if you want to understand it, I made a 1D version that\n// simply uses sign to decide which way to step, plus or minus.\nfloat nextCell(float p, float v, float c) //, float dim)\n{ // since step(dt, dt) is equivalent to 1.0, just get rid of now-unused dt.\n    float d = sign(v); //, dt = ((c + d * .5) * dim - p) / v;\n    return c + d; // * step(dt, dt);\n}\n// it wound up not needing the dim, so what if none of them used dim?\n// I may have *caller* to do such coordinate system conversion/mapping,\n// so that the p coordinate here is always already in cell coordinates\n// which simplifies a few things\n// dim is size of cell hypercubes in p space, they don't have to\n// actually be the same size here, for these variants\n// which are closer to ocb's originals which were called getNextBox or getNextCell.  \n        // see, his may be just little too clever, as it integrates\n        // the tracking of the ray position in a way that is incompatible\n        // with keeping the same ray and just incrementing the offset along it.\n        // I prefer to avoid the accumulation of small errors from individual steps\n        // anyway I require new t, or delta to t, distance to the next cell\n    // knowing the cell id isn't helping much, for me; I need the distance to hit\n    // and, see, his thing is simply not set up to help calculate the needed step distance\n\n// key function to find the next Voxel along the ray\nvec2 nextCell(vec2 p, vec2 v, vec2 c, float dim)\n{\n    vec2 d = sign(v), dt = ((c + d * .5) * dim - p) / v;\n    return c + d * step(dt, vec2(min(dt.x, dt.y)));\n}\nvec3 nextCell(vec3 p, vec3 v, vec3 c, float dim)\n{\n    vec3 d = sign(v), dt = ((c + d * .5) * dim - p) / v;\n    return c + d * step(dt, vec3(min(min(dt.x, dt.y), dt.z)));\n}\n// p is a current position, c is corresponding id of cell\n// which p is currently inside, v is trace direction\n\n//vec2    return c + d * step(dt, vec2(min(dt.x, dt.y)));\n//vec3    return c + d * step(dt, vec3(min(min(dt.x, dt.y), dt.z)));\n// ocb's scanner was called browseBox and had totally different interface\n        //vec3 n = newBox - box; // but his allowed to find the hit normal with little cost!\n#endif\n\n#if 1 \n// extracting stb's voxel dda code\n// from https://shadertoy.com/view/Wt2cW3 or http://glslsandbox.com/e#58331.0\n// removed unneeded alpha / lighting stuff\n// kind of working, but needs tuned on the exit; records distance too early\n// also seems a little wonky on the traversal; unsure what's going on.\nfloat Scan2stb(vec2 m0, vec2 m1)\n{\n\tvec2 d = m1 - m0, s = sign(d), V = m0;\n\tint niter = int(floor(max(abs(d.x), abs(d.y)))) + 1;\n\tfor (int i = niter; i-- > 0; ) {\n        vec2 adj = mix(floor(V+s), ceil(V+s), .5-.5*s) - V\n        , xV = adj.x * vec2(1., d.y/d.x)\n        , yV = adj.y * vec2(d.x/d.y, 1.)\n        , dV = dot(xV,xV) < dot(yV,yV) ? xV : yV;\n        V += dV;\n        ivec2 q = ivec2(floor(V));\n        if (Condition(q))\n            if (!Traverse(q))\n            \tbreak;\n    }\n\tfloat dist;\n\t\tdist = length(V-m0); // seems wasteful to compute when not needed\n    return dist;\n}\n#endif\n\n#if 0\n// extracted the dda from kastorp's variant\n// of https://shadertoy.com/user/fb39ca4 's Voxel Game\n// https://shadertoy.com/view/MtcGDH\nfloat Scan2evolved(vec2 m0, vec2 m1)\n{\n    vec2 d = m1 - m0\n    , s = sign(d);\n    , rayInv = 1./d; // FIXME divides by zero\n\t, p = m0;\n    , mapPos = floor(p)\n    , sideDist = (mapPos - p + .5 + s*.5) * rayInv\n    , mask = vec2(0); \n    for (int i = 0; i < 32; ++i) {\n        if (i > 0)\n       \t\tmask = step(sideDist.xyz, sideDist.yzx) * step(sideDist.xyz, sideDist.zxy);\n\t\tsideDist += mask * s * rayInv;\n        mapPos += mask * s;\n        //getVoxel(mapPos, vox, 3);\n        //etc.\n    }\n    return dist;\n}\n#endif\n// almost same as fb39ca4's original, must integrate all this back together somehow :)\n// or just pick one that works well\n#if 0\n// fb39ca4 makes some bad-ass DDA toys!  https://shadertoy.com/view/4dX3zl\n// based on the article http://lodev.org/cgtutor/raycasting.html btw\nfloat Scan2branchless(vec2 m0, vec2 m1)\n{\n\tivec2 q = ivec2(floor(m0));\n    vec2 d = m1 - m0\n    , deltaDist = abs(vec2(length(d)) / d) // FIXME divides by zero\n    , s = sign(d)\n\t, sideDist = (s * (vec2(q) - m0) + (s * .5) + .5) * deltaDist;\n\tivec2 rayStep = ivec2(s);\n\tivec2 aid = abs(ivec2(floor(m1)-floor(m0)));\n    int niter = 1+aid.x+aid.y;\n    for (int i = niter; i-- > 0; ) {\n        if (Condition(q))\n            if (!Traverse(q))\n            \tbreak;\n\t\t//Thanks kzy for the suggestion!\n        //bvec3 mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));\n        bvec2 mask = lessThanEqual(sideDist, sideDist.yx);\n\t\t// All components of mask are false except for the corresponding largest component\n\t\t// of sideDist, which is the axis along which the ray should be incremented.\n\t\tsideDist += vec2(mask) * deltaDist;\n\t\tq += ivec2(mask) * rayStep;\n\t}\n    return distance(vec2(q), m0); // FIXME not accurate yet\n}\n#endif\n\n#if 0\n// fork of Branchless Voxel Raycasting Tex by jt at https://shadertoy.com/view/7dK3D3\n// which is itself a fork of https://shadertoy.com/view/4dX3zl Branchless Voxel Raycasting by fb39ca4 (with loop optimization by kzy),\n// based on the article http://lodev.org/cgtutor/raycasting.html.\n// ripe for cleanup!  hey... didn't I already clean up this same... crap yes, see above fb39ca4 toy ;)\n// well idk if I wanna do it again.  So far this doesn't work yet.\n// but it's great to have the original paper that fb39ca4's toy was based on, for reference!\nfloat Scan2jt(vec2 m0, vec2 m1)\n{\n    vec2 rayPos = m0;\n    vec2 rayDir = m1;\n    vec2 s = sign(rayDir);\n    ivec2 rayStep = ivec2(s);\n    rayDir = normalize(rayDir);\n    ivec2 mapPos = ivec2(floor(rayPos));\n    vec2 sideDist;\n    vec2 mask;\n    // core of https://shadertoy.com/view/4dX3zl Branchless Voxel Raycasting by fb39ca4 (somewhat reduced)\n    int MAX_RAY_STEPS = 32;\n    vec2 deltaDist = 1.0 / abs(rayDir);\n    sideDist = (s * (vec2(mapPos) - rayPos + .5) + .5) * deltaDist; \n\n    for (int i = 0; i < MAX_RAY_STEPS; ++i) {\n        //if (getVoxel(mapPos)) continue;\n        if (Condition(mapPos))\n            if (!Traverse(mapPos))\n            \tbreak;\n\n        // Thanks kzy for the suggestion! for 3d\n        //mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));\n        mask = vec2(lessThanEqual(sideDist.xy, sideDist.yx)); // for 2d\n        sideDist += mask * deltaDist;\n        mapPos += ivec2(mask) * rayStep;\n    }\n    // jt's texcoord addon recovering distance & subvoxel intersection-position of ray \n    // as described in https://lodev.org/cgtutor/raycasting.html (see \"perpWallDist\" there)\n    //float d = (mask.x ? sideDist.x - deltaDist.x : mask.y ? sideDist.y - deltaDist.y : mask.z ? sideDist.z - deltaDist.z : 0.0) / length(rayDir);\n    vec2 l = mask * (sideDist - deltaDist);\n    return l.x + l.y; // one will be zero\n}\n#endif\n\n#if 0\n// fb39ca4 makes some bad-ass DDA toys!  https://shadertoy.com/view/ldl3DS\n// pretty much same thing, but has some details I may need\nfloat Scan2branchless(vec2 m0, vec2 m1)\n{\n\tivec2 q = ivec2(floor(m0));\n    vec2 d = m1 - m0\n\t, deltaDist = abs(vec3(length(d)) / d) // FIXME divides by zero\n\t, s = sign(d)\n\t, sideDist = (s * (vec2(q) - m0) + s * .5 + .5) * deltaDist\n\t, mask;\n\tivec2 aid = abs(ivec2(floor(m1)-floor(m0)));\n    int niter = 1+aid.x+aid.y;\n    for (int i = niter; i-- > 0; ) {\n        if (Condition(q))\n            if (!Traverse(q))\n            \tbreak;\n\t\t//mask = step(sideDist.xyz, sideDist.yzx) * step(sideDist.xyz, sideDist.zxy);\n        mask = step(sideDist, sideDist.yx); // TODO 2d\n\t\tsideDist += mask * deltaDist;\n\t\tq += mask * s;\n\t}\t\n\tvec2 /*intersectPlane = mapPos + vec3(lessThan(rayDir, vec3(0)))\n\t,*/ endRayPos = d / sum(mask * d)\n        * sum(mask * (vec2(q) + vec3(lessThan(d, vec3(0))) - m0))\n        + m0;\n    return totaldist; // TODO\n}\n#endif\n\n#if 0\n// from my unlisted deconstruction https://shadertoy.com/view/3lySWm\n// refactoring https://shadertoy.com/view/ltXBz7\n// by https://shadertoy.com/user/glk7\n// Created by genis sole - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International.\nfloat Scan2glk7(vec2 m0, vec2 m1) \n{\n    vec2 ro = m0\n    , rd = normalize(m1 - m0)\n    , n = vec2(0)\n    , c = floor(ro) + .5\n//    , q = floor(uv) + .5\n    , s = sign(rd)\n    //, v = vec2(point(uv, e, ro), step(.5, distance(q, c)))\n    ;\n    ro -= c;\n    float totald = 0.;\n    const int maxiter = 36; //40; //42; //\n    for (int it = maxiter; it-- > 0; ) {\n        vec2 d = (s*.5 - ro) / rd;\n        ro += min(d.x, d.y) * rd;\n        n = -s * step(d, d.yx);\n        c -= n;\n       \tro += n;\n//        totald += n;\n    }\n    return totald;\n}\n#endif\n\nconst int grid = 5;\nconst float scale = 1.1 * float(grid-1);\n\nvec2 StoQ(vec2 s, vec2 r)\n{\n    return (s+s-r) * scale / r.y + .5;\n}\n\nvoid mainImage(out vec4 c, vec2 p)\n{\n    float a = .2 * iTime;\n    vec2 R = iResolution.xy\n\t\t, q = StoQ(p, R);\n\tvec2 m0 = StoQ(iMouse.zw, R)\n       , m1 = StoQ(iMouse.xy, R);\n    if (iMouse.z <= 0.) {\n        m0 = vec2(.5); m1 = m0 + float(grid-1)*vec2(vec2(sin(a), cos(a)));\n    }\n\tqi = ivec2(floor(q)); // gridcell\n\tcelltouchesline = false;\n    float l =\n    Scan2DDAnext //Scan2jt //Scan2DDA2 //Scan2branchless //Scan2stb //Scan2DDA3 //Scan2F //Scan2B //Scan2IF //\n        (m0, m1);\n    vec2 hp = m0 + normalize(m1 - m0) * l;\n    bool h = celltouchesline;\n    float g = h ? .1 : .85;\n    if (((qi.x^qi.y)&1)!=0) g += .05; // checks\n    g += max(0., 1.-.25*R.y/scale*seg(q, m0, m1));\n    g += max(0., .5 - 12.*(distance(hp, q) - .1));\n\tc = vec4(vec3(sqrt(g)), 1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt3SW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[224, 308, 343, 343, 434], [762, 812, 837, 837, 855], [856, 900, 924, 924, 963], [18197, 18197, 18224, 18224, 18265], [18267, 18267, 18303, 18303, 19035]], "test": "valid"}
{"id": "XlKBDG", "name": "circles around circles", "author": "Vermifuge", "description": "circles", "tags": ["circles"], "likes": 1, "viewed": 38, "published": "Public", "date": "1587492445", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 col = vec3(.3, .3, 1.);\n    \n    vec2 center = vec2(0., 0.);\n    float r = .1;\n    float exc = .2;\n    for (float i = 1.; i < 10.; ++i) {\n        float theta = i * iTime+i;\n        vec2 p = vec2( sin(theta) * exc, cos(theta) * exc) + center;\n    \tcol = mix(col, i*vec3(.05, .08, .1), smoothstep(.051, .03, length(uv - p) - r));\n        r -= r * 0.5;\n        exc -= r;\n        center = p;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlKBDG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 670]], "test": "valid"}
