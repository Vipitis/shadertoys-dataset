{"id": "4d2GRD", "name": "many spheres", "author": "kig", "description": "bounding sphere hierarchy of doom, oculus things, fogs", "tags": ["raytracing", "spheres", "bvh"], "likes": 11, "viewed": 324, "date": "1498319832", "time_retrieved": "2024-06-20T18:55:35.724114", "image_code": "#define TRANSPARENCY\n#define SHADOWS\n#define SECOND_BOUNCE\n#define ANTIALIAS\n#define ANTIALIAS_4X\n//#define SHOW_BV\n//#define SHOW_AA\n//#define OCULUS\n#define SAILS\n\n#define FOG_D 120.0\n\n#define L_COUNT 1.0\n#define M_COUNT 1.0\n#define N_COUNT 3.0\n#define I_COUNT 3.0\n#define J_COUNT 3.0\n\nstruct tSphere {\n\tvec3 center;\n\tfloat radius;\n\tvec3 color;\n\tfloat spec;\n};\n\n// return ray p,d distance to triangle v0,v1,v2\n// returns -1.0 if no intersection\n// writes UV value to the uv vector\nfloat rayIntersectsTriangle(vec3 p, vec3 d, vec3 v0, vec3 v1, vec3 v2, inout vec2 uv)\n{\n\tvec3 e1,e2,h,s,q;\n\tfloat a,f,u,v,t;\n\te1 = v1-v0;\n\te2 = v2-v0;\n\n\th = cross(d,e2);\n\ta = dot(e1,h);\n\n\tf = 1.0 / a;\n\ts = p-v0;\n\tu = f * dot(s,h);\n\n\tq = cross(s,e1);\n\tv = f * dot(d,q);\n\t\n\tuv = vec2(u,v);\n\t\n\tif (u < 0.0 || u > 1.0 || v < 0.0 || u+v > 1.0) {\n\t\treturn -1.0;\n\t}\n\n\t// at this stage we can compute t to find out where\n\t// the intersection point is on the line\n\tt = f * dot(e2,q);\n\n\tfloat m = float(t <= 0.00001 || (a > -0.00001 && a < 0.00001));\n\t\n\tt = mix(t, -1.0, m);\n\t\n\treturn t;\n\n}\n\n\nfloat raySphereDet(vec3 ray, vec3 dir, vec3 center, float radius, float closestHit, inout float b)\n{\n\tvec3 rc = ray-center;  // 1\n\tfloat c = dot(rc, rc); // 1\n\tc -= radius*radius;    // 2?\n\tb = dot(dir, rc);      // 1\n\treturn b*b - c;        // 2?\n}\n\nbool rayBV(vec3 ray, vec3 dir, vec3 center, float radius, float closestHit)\n{\n\tfloat b;\n\tfloat d = raySphereDet(ray, dir, center, radius, closestHit, b);\n\tif (d < 0.0) {\n\t\treturn true;\n\t};\n\tfloat t = -b - sqrt(d);\n\treturn (t < -(2.0*radius) || t > closestHit+(2.0*radius));\n}\n\nfloat rayIntersectsSphere(vec3 ray, vec3 dir, vec3 center, float radius, float closestHit)\n{\n\tfloat b;\n\tfloat d = raySphereDet(ray, dir, center, radius, closestHit, b); // 7\n\tif (d < 0.0) { // 1\n\t\treturn -1.0;\n\t}\n\tfloat t = -b - sqrt(d); // 3\n\tif (t < 0.0 || t > closestHit) { // 2\n\t\treturn -1.0;\n\t} else {\n\t\treturn t;\n\t}\n}\n\n// rotate position around axis\nvec2 rotate(vec2 p, float a)\n{\n\treturn vec2(p.x * cos(a) - p.y * sin(a), p.x * sin(a) + p.y * cos(a));\n}\n\nfloat intersect(inout vec3 ray, vec3 dir, inout vec3 nml, inout tSphere sphere, inout float doAA, inout float pick)\n{\n\tfloat dist = 5000.0;\n\n\tsphere.radius = doAA = -2.0;\n\tsphere.center = ray+dist*dir;\n\tnml = -dir;\n\tpick = -1.0;\n\n\tfloat time = iTime*0.1 + 450.0;\n\t\n\tfloat b,k,d;\n\tfloat aaBorder = 1.15;\n\n\tfloat l=0.0,m=0.0,n=0.0;\n\tfloat tl = l+time;\n\tvec3 mContrib = vec3(0.0, 0.0, 8.0) + (vec3(sin(tl), -sin(tl), -cos(tl)) * 80.0*ceil(l/8.0));\n\n\tfor (float n=0.0; n<N_COUNT; n++) {\n\t\tfloat r = min(n, 1.0)*10.0;\n\t\tfloat tn = time + (n*6.28/9.0);\n\t\tvec3 nContrib = mContrib + (vec3(sin(tn), -cos(tn), -cos(tn))*r);\n\t\tif (rayBV(ray, dir, nContrib, 14.0, dist)) {\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tdoAA = max(doAA, -0.5);\n\n\t\tfor (float i=0.0; i<I_COUNT; i++) {\n\t\t\tfloat ikOff = sin(time+i)*5.0;\n\t\t\tfloat sikOff = cos(time+i)*5.0;\n\t\t\tvec3 iContrib = nContrib + vec3(ikOff, sikOff, ikOff);\n\t\t\tif (rayBV(ray, dir, iContrib, 7.0, dist)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\n\t\t\tdoAA = max(doAA, -0.3);\n\t\t\tfor (float j=0.0; j<J_COUNT; j++) {\n\t\t\t\tfloat kOff = + cos(time*5.0+j)*2.5;\n\t\t\t\tfloat skOff = - sin(time*5.0+j)*2.5;\n\t\t\t\tk = l*(M_COUNT*N_COUNT*I_COUNT*J_COUNT) + m*(N_COUNT*I_COUNT*J_COUNT) + n*(I_COUNT*J_COUNT) + i*J_COUNT + j;\n\t\t\t\tr = 1.35+cos(k);\n\t\t\t\tvec3 cen = iContrib + vec3(kOff, skOff, kOff);\n\t\n\t#ifdef SAILS\n\t\t\t\t// Do sails first since they're occluded by the sphere.\n\t\t\t\t\n\t\t\t\tvec3 px = vec3(1.0, 0.0, 0.0);\n\t\t\t\tvec3 py = vec3(0.0, 1.0, 0.0);\n\t\t\t\tvec3 pz = vec3(0.0, 0.0, 1.0);\n\t\t\t\t\n\t\t\t\t// BV intersect, let's switch on 4x sampling and check for sail intersect\n\t\t\t\tif (!rayBV(ray, dir, cen, r*2.5, dist)) {\n\t\t\t\t\t\n\t\t\t\t\tvec3 p1 = cen - py*2.25*r - px*0.2*r;\n\t\t\t\t\tvec3 p2 = cen + py*2.25*r - px*0.2*r;\n\t\t\t\t\tvec3 p3 = cen + py*0.0*r + px*0.2*r;\n\t\t\t\t\tvec2 uv, one = vec2(1.0, 1.0);\n\t\t\t\t\tfloat t = rayIntersectsTriangle(ray, dir, p2, p3, p1, uv);\n\t\t\t\t\tfloat uvD = uv.x+uv.y;\n\t\t\t\t\tif (uv.x > -0.1 && uv.x < 1.1 && uv.y > -0.1 && uv.y < 1.1 && uvD < 1.1) {\n\t\t\t\t\t\tdoAA = max(0.0, doAA);\n\t\t\t\t\t}\n\t\t\t\t\tif (t > 0.0 && t < dist) {\n\t\t\t\t\t\tdist = t;\n\t\t\t\t\t\tsphere.radius = 100.0;\n\t\t\t\t\t\tnml = pz;\n\t\t\t\t\t\tif(dot(nml, dir) < 0.0) {\n\t\t\t\t\t\t\tnml = -nml;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsphere.center = p1;\n\t\t\t\t\t\tsphere.color = vec3(0.5, 0.1, 0.05); //texture(iChannel0, uv).rgb;\n\t\t\t\t\t\t// Switch off AA for points inside the triangle.\n\t\t\t\t\t\tif (uv.x > 0.1 && uv.x < 0.9 && uv.y > 0.1 && uv.y < 0.9) {\n\t\t\t\t\t\t\tdoAA = -0.1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsphere.spec = 8.0;\n\t\t\t\t\t\tpick = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t#endif\n\t\n\t\t\t\td = raySphereDet(ray, dir, cen, r*aaBorder, dist, b);\n\t\t\t\t// BV intersect, let's switch on 4x sampling and check for sphere intersect\n\t\t\t\tif (d > 0.0 && -b - sqrt(d) > -r*aaBorder) {\n\t\t\t\t\tdoAA = max(doAA, 0.0);\n\t\t\t\t\t// d = b*b - dot(rc,rc) + (r*r)*(aaBorder*aaBorder)\n\t\t\t\t\t// eliminate aaBorder^2 by\n\t\t\t\t\t// d_r = b^2 - rc^2 + r^2 * aaBorder^2 - r^2 * aaBorder^2 + r^2\n\t\t\t\t\t//     = b^2 - rc^2 + r^2\n\t\t\t\t\t// rewrite -r^2 * aaBorder^2 + r^2 = -r^2 * (aaBorder^2 - 1)\n\t\t\t\t\td = d - (r*r)*(aaBorder*aaBorder - 1.0);\n\t\t\t\t\tif (d > 0.0) {\n\t\t\t\t\t\tfloat t = -b - sqrt(d);\n\t\t\t\t\t\tif (t > 0.0 && t < dist) {\n\t\t\t\t\t\t\tdist = t;\n\t\t\t\t\t\t\tsphere.radius = r;\n\t\t\t\t\t\t\tsphere.center = cen;\n\t\t\t\t\t\t\tnml = normalize(sphere.center - ray - dist*dir);\n\t\t\t\t\t\t\tfloat odd = mod(n+j, 2.0);\n\t\t\t\t\t\t\tfloat ay = abs(nml.y);\n\t\t\t\t\t\t\tfloat fy = float(ay < 0.05 || (ay > 0.75 && ay < 0.78));\n\t\t\t\t\t\t\tsphere.color = mix(vec3(0.95, 0.8, 0.7), vec3(0.2), fy);\n\t\t\t\t\t\t\tsphere.color = mix(vec3(0.1), sphere.color, odd);\n\t\t\t\t\t\t\t// Switch off AA for points inside the sphere\n\t\t\t\t\t\t\tif (dot(nml, dir) > 0.4) {\n\t\t\t\t\t\t\t\tdoAA = -0.1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsphere.spec = mix(64.0, 8.0, odd);\n\t\t\t\t\t\t\tpick = k;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tray += dist*dir;\n\treturn dist;\n}\n\nfloat pickIntersect(vec3 ray, vec3 dir)\n{\n\ttSphere sphere;\n\tvec3 nml;\n\tfloat doAA, pick;\n\tfloat t = intersect(ray, dir, nml, sphere, doAA, pick);\n\treturn pick;\n}\n\n\n\n\nvec3 shadeBg(vec3 dir, vec3 nml)\n{\nvec3 lightPos_ = vec3(\n\t-cos(iTime*0.1)*-8.5, \n\t3.5+sin(iTime*0.05)*3.0, \n\t-(sin(iTime*0.1)*4.0-5.4)\n);\nvec3 bgLight = normalize(lightPos_);\nvec3 lightPos = bgLight * 9999.0;\n\n\tvec3 sun = vec3(2.0, 1.5, 1.0);\n\tvec3 bgCol = vec3(0.35, 0.45, 0.55);\n\tfloat bgDiff = dot(nml, vec3(0.0, 1.0, 0.0));\n\tfloat sunPow = max(dot(nml, bgLight), 0.0);\n\tbgCol *= max(0.0, 1.0-0.15*sunPow+bgDiff);\n\tbgCol += pow( max(0.0, 0.15*sunPow-bgDiff), 1.5 ) * vec3(0.9, 0.6, 0.5);\n\tbgCol += sun*pow( sunPow, abs(bgLight.y)*64.0);\n\treturn bgCol;\n}\n\nvec3 shade(vec3 ray, vec3 dir, vec3 nml, float dist, tSphere sphere, inout float doAA)\n{\n\tvec3 col = vec3(0.0, 0.0, 0.0);\n\tvec3 bgCol = shadeBg(dir, dir);\n\tif (sphere.radius > 0.0) {\n\t\t\t\t\n\t\ttSphere s;\n#ifdef SHADOWS\n\t\tvec3 shadow = ray-nml*0.0001, snml = vec3(0.0);\n\t\tfloat pick;\nvec3 lightPos_ = vec3(\n\t-cos(iTime*0.1)*-8.5, \n\t3.5+sin(iTime*0.05)*3.0, \n\t-(sin(iTime*0.1)*4.0-5.4)\n);\nvec3 bgLight = normalize(lightPos_);\nvec3 lightPos = bgLight * 9999.0;\n\n\t\tfloat lightDist = length(lightPos - ray);\n\t\tfloat sdist = intersect(shadow, normalize(lightPos - shadow), snml, s, doAA, pick);\n\t\tif (sdist > lightDist) {\n\t\t\ts.radius = -1.0;\n\t\t}\n#else\n\t\ts.radius = -1.0;\n#endif\n\t\tvec3 light = normalize(lightPos - ray);\n\t\tvec3 specCol = sphere.color + vec3(0.3-min(0.29, length(sphere.color)));\n\t\t// lighting\n\t\tcol = sphere.color;\n\t\tfloat diff = max(0.0, dot(nml, -light));\n\t\tvec3 ref = reflect(dir, nml);\n\t\tfloat spec = max(dot(ref, light), 0.0);\n\t\tspec = pow(spec, abs(sphere.spec));\n\t\t\n\t\tcol *= diff;\n\t\tfloat inShadow = float(s.radius > 0.0);\n\t\tcol = mix(col+specCol*(spec*2.0), col*0.1, inShadow);\n\t\t\n\t\t\n\t\tfloat a = 1.0 - abs(dot(dir, nml));\n\t\tif (sphere.spec < 0.0) {\n\t\t\tcol += a * vec3(2.5, 1.6, 1.3);\n\t\t}\n\t\t\n\t\tfloat fog = clamp(dist / FOG_D, 0.0, 1.0);\n\t\tfog *= fog;\n\t\tcol = (1.0-fog)*col + fog*bgCol;\n\t} else {\n\t\tcol = bgCol;\n\t}\n\n\treturn col;\n}\n\n#ifdef OCULUS\nvec2 hmdWarp(vec2 texIn) {\n\tvec2 u_lensCenter = vec2(0.0, 0.0);\n\tvec2 u_scaleIn = vec2(0.45, 0.7);\n\tvec2 u_scale = vec2(0.7);\n\tvec4 u_hmdWarpParam = vec4(0.7);\n\tvec2 u_screenCenter = vec2(0.0);\n\tvec2 u_lensCenter;\n\tif (texIn.x > 0.0) {\n\t\tu_lensCenter = vec2(-0.05, 0.0);\n\t\ttexIn.x = (0.85 - texIn.x);\n\t} else {\n\t\tu_lensCenter = vec2(0.05, 0.0);\n\t\ttexIn.x = (-0.85 - texIn.x);\n\t}\n\tvec2 theta = (texIn - u_lensCenter) * u_scaleIn;\n\tfloat rSq = theta.x * theta.x + theta.y * theta.y;\n\tvec2 theta1 = theta * (u_hmdWarpParam.x + u_hmdWarpParam.y * rSq + \n\t\tu_hmdWarpParam.z * rSq * rSq + u_hmdWarpParam.w * rSq * rSq * rSq);\n\treturn u_lensCenter + u_scale * theta1;\n}\n#endif\n\nvec3 getDir(vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = 2.0 * uv - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n\n#ifdef OCULUS\t\n\tvec2 tc = hmdWarp(uv);\n\tuv = tc;\n\tuv.x *= iResolution.x / iResolution.y;\n#endif\n\t\n\tvec3 dir = normalize(vec3(uv, 1.0));\n\tdir.xy = rotate(dir.xy, cos(iTime*0.1));\n\tdir.xz = rotate(dir.xz, sin(iTime*0.15));\n\treturn dir;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat xOff = 0.0;\n#ifdef OCULUS\n\txOff = 1.0;\n\tif (fragCoord.x < iResolution.x*0.5) xOff = -1.0;\n#endif\n\n\tvec3 eye = vec3(-xOff*0.5, -0.0, -30.0);\n\t//eye.xy = rotate(eye.xy, 0.5*sin(iTime));\n\n\tvec3 mdir, dir;\n\tmdir = getDir(iMouse.zw);\n\t\n\tvec3 ray = eye;\n\tvec3 nml = vec3(0.0);\n\t\t\n\tvec3 col = vec3(0.0, 0.0, 0.0);\n\t\n\ttSphere sphere;\n\tfloat doAA;\n\tfloat doAA_;\n\t\n\tfloat picked = -2.0;\n\tfloat k = 0.0;\n\n\tfor (float x = 0.0; x < 2.0; x++) {\n\t\tfor (float y = 0.0; y < 2.0; y++) {\n\n#ifndef ANTIALIAS_4X\n\t\t\tif (x + y == 1.0) {\n\t\t\t\tcontinue;\n\t\t\t}\n#endif\n\t\t\tk++;\n\n\t\t\tvec2 d = (vec2(x, y) * 0.33) - vec2(0.5);\n\n\t\t\tray = eye;\n\n\t\t\tdir = getDir(fragCoord.xy+d);\n\n\t\t\tfloat target = -1.0;\n\t\t\tfloat dist = intersect(ray, dir, nml, sphere, doAA, target);\n\t\t\tfloat fog = clamp(dist / FOG_D, 0.0, 1.0);\n\t\t\tfog *= fog;\n\n\t\t\tif (picked == -2.0 && target >= 0.0 && iMouse.z > 1.0) { \n\t\t\t\tpicked = pickIntersect(eye, mdir);\n\t\t\t}\n\t\t\t\n\t\t\tvec3 ref = dir;\n\t\t\tvec3 ncol = vec3(0.1);\n\t\t\tsphere.spec *= min(1.0, mix(-1.0, 1.0, abs(picked-target)));\n\t\t\tncol = shade(ray, ref, nml, dist, sphere, doAA_);\n\n\t\t\tif ( sphere.radius > 0.0 )\n\t\t\t{\n\t\t\t\tvec3 diff = sphere.color; //normalize(sphere.color+vec3(0.01));\n\t\t\t\tref = reflect(ref, nml);\n\t\t\t\t// transparency\n#ifdef TRANSPARENCY\n\t\t\t\tif (sphere.radius < 100.0 && sphere.color.r < 0.2) {\n\t\t\t\t\tvec3 ray2 = ray;\n\t\t\t\t\tvec3 ref2 = refract(dir, nml*0.5, 0.04);\n\t\t\t\t\tray2 += ref2*sphere.radius*1.01;\n\t\t\t\t\tfloat tdist = intersect(ray2, dir, nml, sphere, doAA_, target);\n\t\t\t\t\tsphere.spec *= min(1.0, mix(-1.0, 1.0, abs(picked-target)));\n\t\t\t\t\tvec3 tcol = shade(ray2, dir, nml, dist+tdist, sphere, doAA_);\n\t\t\t\t\tncol = mix(tcol, ncol, 0.5);\n\t\t\t\t\tdiff *= vec3(0.5);\n\t\t\t\t}\n#endif\n\t\t\t\t// reflection\n                ray += ref * 0.0001;\n\t\t\t\tdist = intersect(ray, ref, nml, sphere, doAA_, target);\n\t\t\t\tsphere.spec *= min(1.0, mix(-1.0, 1.0, abs(picked-target)));\n\t\t\t\tncol += (1.0-fog) * 0.6 * diff * shade(ray, ref, nml, dist, sphere, doAA_);\n\t\t\t\tfog = clamp(dist / FOG_D, 0.0, 1.0);\n\t\t\t\tfog *= fog;\n\t\t\t\t// second reflection\n#ifdef SECOND_BOUNCE\n\t\t\t\tif (sphere.radius > 0.0) {\n\t\t\t\t\tdiff = sphere.color;\n\t\t\t\t\tref = reflect(ref, nml);\n\t                ray += ref * 0.0001;\n\t\t\t\t\tdist = intersect(ray, ref, nml, sphere, doAA_, target);\n\t\t\t\t\tsphere.spec *= min(1.0, mix(-1.0, 1.0, abs(picked-target)));\n\t\t\t\t\tncol += (1.0-fog) * 0.6 * diff * shade(ray, ref, nml, dist, sphere, doAA_);\n\t\t\t\t}\n#endif\n\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\n\t\t\tcol += max(vec3(0.0), ncol);\n\t\t\t\n\t\t\tif (doAA < 0.0) {\n#ifdef SHOW_BV\n\t\t\t\tcol += vec3(0.05)*doAA;\n#endif\n\t\t\t\tbreak;\n\t\t\t}\n#ifndef ANTIALIAS\n\t\t\tbreak;\n#endif\n#ifdef SHOW_AA\n\t\t\tcol += vec3(0.5, 0.0, 0.5);\n#endif\n\t\t}\n\t}\n\t// gamma correction\n\tcol = 1.0 - exp((-col/k) * 3.5);\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4d2GRD.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dfBDl", "name": "raym split screen", "author": "anclin", "description": "raym split screen", "tags": ["raymsplitscreen"], "likes": 4, "viewed": 125, "date": "1498681517", "time_retrieved": "2024-06-20T18:55:35.724114", "image_code": "const float EPSILON = 0.0001;\nconst float MAX_DIST = 100.0;\n\nfloat remap(float low1, float high1, float low2, float high2, float value){\n    return low2 + (value - low1) * (high2 - low2) / (high1 - low1);\n}\n\n/**\n * Rotation matrix around the Y axis.\n */\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n/**\n * Constructive solid geometry intersection operation on SDF-calculated distances.\n */\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\n/**\n * Constructive solid geometry union operation on SDF-calculated distances.\n */\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\n/**\n * Constructive solid geometry difference operation on SDF-calculated distances.\n */\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nfloat SphereSDF(vec3 p, float size){\n\treturn length(p) - size;\n}\n\nfloat CubeSDF(vec3 p, vec3 size){\n    vec3 d = abs(p) - size;\n    \n    float insideDistance = min( max(max(d.x, d.y),d.z), 0.0);\n    \n    float outsideDistance = length( max(d, 0.0) );\n    \n    return insideDistance + outsideDistance;\n}\n\nfloat TorusSDF( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n\n/// SCENE ///////////////////////////\nfloat SceneSDF(vec3 p){\n    \n    p = rotateY(iTime * 0.2) * p;\n    \n    float gap = 1.75;\n    \n    p.x = mod(p.x + gap, 2.0 * gap) - gap;\n    p.z = mod(p.z + gap, 2.0 * gap) - gap;\n    \n    //return CubeSDF(p, vec3(1));\n    \n\tfloat torus = TorusSDF(p, vec2(1,0.5));\n    return torus;\n}\n\n\n\n\nvec3 EstimateNormal(vec3 p){\n\treturn normalize(vec3(\n        SceneSDF(vec3(p.x+EPSILON, p.y, p.z)) - SceneSDF(vec3(p.x-EPSILON, p.y, p.z)),\n        SceneSDF(vec3(p.x, p.y+EPSILON, p.z)) - SceneSDF(vec3(p.x, p.y-EPSILON, p.z)),\n        SceneSDF(vec3(p.x, p.y, p.z+EPSILON)) - SceneSDF(vec3(p.x, p.y, p.z-EPSILON))\n        ));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        SceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - SceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        SceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - SceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        SceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - SceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 RayDirection(float fieldOfView, vec2 fragCoord, vec2 size){\n\tvec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec4 ShortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end){\n\tfloat depth = start;\n\tvec3 pos = eye;\n    for(int i = 0; i < 255; i++){\n        vec3 pos = eye + depth * marchingDirection;\n    \tfloat dist = SceneSDF(pos);\n        if( dist <= EPSILON){\n            return vec4(pos,depth);\n        }\n        depth += dist;\n        if(depth >= end){\n            pos = eye + depth * marchingDirection;\n        \treturn vec4(pos,end);\n        }\n    }\n    return vec4(pos,end);\n}\n\nmat4 viewMatrixRIGHT() {\n    return mat4(\n        vec4(0, 0, 1, 0),\n        vec4(0, 1, 0, 0),\n        vec4(-1,0, 0, 0),\n        vec4(0, 0, 0, 1)\n    );\n}\n\nmat4 viewMatrixDOWN() {\n    return mat4(\n        vec4(1, 0, 0, 0),\n        vec4(0, 0, 1, 0),\n        vec4(0, 1, 0, 0),\n        vec4(0, 0, 0, 1)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // shadertoy vars\n    float t = iTime * 0.3;\n    vec2 res = iResolution.xy;\n    vec2 frag = fragCoord.xy;\n    vec2 uv = frag / res;\n    \n    // decalreations\n    vec3 rayDir;\n    vec3 worldDir;    \n    vec3 eye;\n    vec4 shortDist = vec4(0);\n    \n    float m = iMouse.x / res.x;\n    if(m <= 0.001)\n        m = 0.5;\n    float treshold = m;\n    \n    // left side\n    if( uv.x < treshold){\n        frag = fragCoord.xy;\n        res = vec2(res.x * 0.5, res.y);\n        rayDir = RayDirection(60.0, frag, res );\n\t\tworldDir = ( viewMatrixRIGHT() * vec4(rayDir,0) ).xyz;\n        eye = vec3(-10.0 + 0.0 * cos(t),\n                    2.0 + 0.0 * cos(t),\n                    0.0 + 0.0 * sin(t));\n        shortDist = ShortestDistanceToSurface(eye, worldDir, 0.0, 100.0);\n    }\n    \n    // right side\n    else{\n        frag = vec2(frag.x - res.x * 0.5, frag.y);\n        res = vec2(res.x * 0.5, res.y);\n        rayDir = RayDirection(60.0, frag, res);\n\t\tworldDir = ( viewMatrixDOWN() * vec4(rayDir,0) ).xyz;\n        eye = vec3(0.0 + 0.0 * cos(t),\n                   20.0 + 0.0 * cos(t),\n                   0.0 + 0.0 * sin(t));\n        shortDist = ShortestDistanceToSurface(eye, worldDir, 0.0, 100.0);\n    }\n\n    vec3 pos = shortDist.xyz;\n    float dist = shortDist.w;\n    \n    vec3 ambientColor = vec3(0.5, 0.3, 0.3);\n    vec3 color = vec3(130.0, 84.0, 72.0) / 255.0;\n    \n    //vec3 lightPos = vec3(0.5, 0.5, 0.5);\n    vec3 lightPos = vec3(4.0 * sin(iTime),\n                         6.0,\n                         4.0 * cos(iTime));\n    \n    \n    vec3 lightDirection = normalize(-lightPos);\n    \n    vec3 p = eye + dist * worldDir;\n    vec3 normal = estimateNormal(p);\n    float diffuse = dot(normal, -lightDirection);\n    diffuse = max(diffuse, 0.0);\n    \n    vec3 finalColor = vec3(0);\n    \n    // render donuts\n    if( dist < MAX_DIST){\n        finalColor = color;\n        \n        // apply diffuse\n        finalColor = finalColor * (diffuse + ambientColor);\n        \n\t\t// apply fog\n        float distToEye = length(eye - pos);\n        finalColor = finalColor * remap(70.0, 20.0, 0.0, 1.0, distToEye);\n    }\n    \n\tfragColor = vec4(finalColor,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dfBDl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dfBRf", "name": "[TUT] Camera System", "author": "BigWIngs", "description": "This shader is part of my ShaderToy tutorial series on YouTube. \nThe tutorial can be found here:\n\nhttps://www.youtube.com/watch?v=PBxuVlp7nuM\n\n", "tags": ["3d", "tutorial", "camera"], "likes": 30, "viewed": 1540, "date": "1497150126", "time_retrieved": "2024-06-20T18:55:36.118140", "image_code": "// \"ShaderToy Tutorial - CameraSystem\" \n// by Martijn Steinrucken aka BigWings/CountFrolic - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// This shader is part of my ongoing tutorial series on how to ShaderToy\n// For an explanation go here: \n// https://www.youtube.com/watch?v=PBxuVlp7nuM\n\nfloat DistLine(vec3 ro, vec3 rd, vec3 p) {\n\treturn length(cross(p-ro, rd))/length(rd);\n}\n\nfloat DrawPoint(vec3 ro, vec3 rd, vec3 p) {\n\tfloat d = DistLine(ro, rd, p);\n    d = smoothstep(.06, .05, d);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t = iTime;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy; // 0 <> 1\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(3.*sin(t), 2., -3.*cos(t));\n    \n    vec3 lookat = vec3(.5);\n    \n    float zoom = 1.;\n    \n    vec3 f = normalize(lookat-ro);\n    vec3 r = cross(vec3(0., 1., 0.), f);\n    vec3 u = cross(f, r);\n    \n    vec3 c = ro + f*zoom;\n    vec3 i = c + uv.x*r + uv.y*u;\n    vec3 rd = i-ro;\n    \n   \n    \n    float d = 0.;\n    \n    d += DrawPoint(ro, rd, vec3(0., 0., 0.));\n    d += DrawPoint(ro, rd, vec3(0., 0., 1.));\n    d += DrawPoint(ro, rd, vec3(0., 1., 0.));\n    d += DrawPoint(ro, rd, vec3(0., 1., 1.));\n    d += DrawPoint(ro, rd, vec3(1., 0., 0.));\n    d += DrawPoint(ro, rd, vec3(1., 0., 1.));\n    d += DrawPoint(ro, rd, vec3(1., 1., 0.));\n    d += DrawPoint(ro, rd, vec3(1., 1., 1.));\n    \n    \n\tfragColor = vec4(d);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dfBRf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dffDB", "name": "everyday 035/100", "author": "kalin", "description": "everyday 035/100", "tags": ["everyday"], "likes": 1, "viewed": 131, "date": "1497768628", "time_retrieved": "2024-06-20T18:55:36.118140", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 nuv = uv * 2.0 - 1.0;\n    \n    float bpm = 1.0 / 60.0 * 110.0;\n    float t = iTime;\n    float bt = t * bpm;\n    float pi = 3.14159265359;\n    float btp = bt * pi;\n    \n    float ts = 1.0 / 32.0;\n    float t0 = texture(iChannel0, vec2(ts * 0.0, 0.25)).x;\n    float t1 = texture(iChannel0, vec2(ts * 1.0, 0.25)).x;\n    float t2 = texture(iChannel0, vec2(ts * 3.5, 0.25)).x;\n    \n    vec3 c = vec3(0.0);\n    \n    vec3 colb = vec3(0.0, 0.13, 0.23);\n    vec3 colf = vec3(0.58, 0.06, 0.02);\n    vec3 col0 = vec3(0.10, 0.43, 0.16);\n    vec3 col1 = vec3(0.24, 0.82, 0.66);\n    vec3 col2 = vec3(0.18, 0.16, 0.22);\n    \n    float rtuv = 1000.0 + btp * 0.1 + nuv.x * pow(uv.y - uv.y * 0.05, 1.2) * 14.0;\n\n    mat2 ruv0 = mat2(cos(rtuv), -sin(rtuv), sin(rtuv), cos(rtuv * nuv.y));\n    mat2 ruv1 = mat2(cos(rtuv), -sin(rtuv), sin(rtuv), cos(rtuv));\n    vec2 tuv = ((nuv * ruv0) + (nuv * ruv1)) * 0.5;\n\n    float n0 = texture(iChannel2, tuv).x;\n    float n1 = texture(iChannel2, nuv).x;\n    \n    float txp = abs(cos(btp * 0.1) * sin(btp * 0.2) * tuv.x * tuv.y) + n0 * 0.1;\n    \n    float txn = texture(iChannel1, tuv).x * mix(1.0, 1.2 + pow(t2, 3.0) * 3.0 * nuv.y, n1);\n    float tx0 = texture(iChannel1, nuv + vec2(0.0, bt)).x + n0;\n    \n    c.xyz = colb + colb * pow(abs(nuv.y), 2.0) * 1.5;\n    c.xyz -= pow(abs(nuv.y + 0.05), 2.0) * 0.63 - sin(uv.x * 12.0 + btp) * 0.01 + (ruv1 * vec2(tx0 + sin(btp))).x * 0.00001;\n    c.xyz -= pow(abs(nuv.y + 0.05), 2.0) * -0.13 - sin(uv.y * 2.0 + btp) * 0.19 * (c.y) * tx0 * n0;\n    c.xyz += pow(abs(nuv.y + 0.3 + sin(btp * 0.1)), 2.0) * 0.2 * sin(uv.x * 7.0 + sin(btp) * 0.1) * colf;\n    c.xyz += col1 * t2 * 0.5 * length(c.xyz) + 0.1;\n\n    c.xyz = mix(c, col0, txp * pow(t0 + 0.2, 4.5) * 3.0);\n    c.xyz = mix(c, col1, txn * pow(t1, 0.5) * (txp + 0.05) * 2.0);\n    \n    c.xyz += colf * t2 * 0.31 + pow(t0, 4.0) * abs(nuv.y);\n    \n    fragColor.xyz = c;\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}, {"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}, {"id": "ldXXR2", "previewfilepath": "https://soundcloud.com/vindsvept/vindsvept-hearthfire", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/vindsvept/vindsvept-hearthfire", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dffDB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dffDj", "name": "FireWorks on a moonlit night", "author": "Torumu106", "description": "My best work ever.", "tags": ["shader", "moon", "night", "firework"], "likes": 2, "viewed": 198, "date": "1498033363", "time_retrieved": "2024-06-20T18:55:36.118140", "image_code": "vec3 firework(vec2 r, vec3 col, float GlobalTime){\n    vec3 ret = vec3(0.0);\n\tvec2 r1 = r + vec2(0.0, pow(GlobalTime - 1.0, 2.0) * 0.2 - 0.8);\n    if(mod(length(r1), 0.02 * GlobalTime) <= 0.02 && mod(atan(r1.y / r1.x), 3.141592 / 16.0) <= 3.141592 / 64.0 && GlobalTime * 0.2 >= length(r1)){\n    \tret = col * ((2.0 - GlobalTime) / 2.0 + 0.5) \n                * max(0.,(.5+.5*sin(atan(r1.y , r1.x)*2.*16.))*4.-3.) * 1.5;\n    }\n    return ret;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //def\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 r = 2.0 * vec2(uv.x - 0.5, uv.y - 0.5);\n    r.x *= iResolution.x / iResolution.y;\n    vec3 ret = vec3(0.0);\n    vec3 col = vec3(0.8, 0.2, 0.2);\n    vec3 col1 = vec3(0.2, 0.8, 0.2);\n    vec3 col2 = vec3(0.2, 0.2, 0.8);\n    \n    //fireworks\n    ret += firework(r - vec2(-0.8, -0.7), col1, mod(iTime - 2.0, 9.0));\n    ret += firework(r - vec2(1.2, -0.3), col2, mod(iTime - 2.0, 9.0) - 2.0);\n    ret += firework(r - vec2(-0.5, 0.2), col, mod(iTime - 2.0, 9.0) - 4.0);\n    ret += firework(r - vec2(0.6, -1.0), col2, mod(iTime - 2.0, 9.0) - 6.0);\n    \n    //moon\n    if(length(r - vec2(-1.65, 0.9)) <= 0.2){\n    \tret = vec3(0.7);\n    }\n    if(length(r - vec2(-1.51, 0.9)) <= 0.05){\n    \tret = vec3(0.5);\n    }\n    if(length(r - vec2(-1.52, 0.87)) <= 0.05){\n    \tret = vec3(0.5);\n    }\n    if(length(r - vec2(-1.54, 0.85)) <= 0.05){\n    \tret = vec3(0.5);\n    }\n    if(length(r - vec2(-1.65, 0.77)) <= 0.05){\n    \tret = vec3(0.5);\n    }\n    \n\tfragColor = vec4(ret,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dffDj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dffRS", "name": "Day 3 - Interesting shapes", "author": "Mercesa", "description": "Day 3 of me doing shadertoy", "tags": ["3d"], "likes": 0, "viewed": 266, "date": "1496596161", "time_retrieved": "2024-06-20T18:55:36.124263", "image_code": "\n#define MAXMARCHSTEPS 64\n#define EPSILON 0.0001\n\nfloat udSphere(vec3 p, float radius)\n{\n    return length(p) - radius;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat opBlend( vec3 p, float a, float b)\n{\n   \n    return smin( a, b, 0.1f );\n}\n\nfloat opS(float d1, float d2)\n{\n    return max(-d1, d2);\n}\n\n    \nfloat Map(vec3 p)\n{\n    float d1 = udSphere(p, 1.0f);\n    // Rotate around the x axis\n    float d2 = udSphere(p + vec3(cos(iTime) * 1.2f , sin(iTime) * 1.2f, 0.0f), 0.6f);\n    float d3 = udSphere(p + vec3(sin(iTime+ 1.0f) * 1.2f, cos(iTime) * 1.2f, 0.0f), 0.5f);\n   //float d4 = udBox(p + vec3(, vec3(0.5f, 0.5f, 0.05f);\n    float blend = opBlend(p, d1, d2);\n    float blend2 = opBlend(p, blend, d3);\n    float blend3 = opS(udBox(p + vec3(0.0f, 0.0f, sin(iTime) * 4.0f), vec3(0.5f, 0.5f, 0.5f)), blend2);\n\n    //float subSphere = opS(udSphere(p + vec3(0.0f, 0.0f, sin(iTime)), 0.f), blend2);\n    return blend2;\n    \n    \n}\n\nfloat Trace(vec3 origin, vec3 direction, float min, float end)\n{\n    float t = min;\n    \n    for(int i = 0; i < MAXMARCHSTEPS; ++i)\n    {\n        vec3 p = origin + direction * t;\n        \n        float d = Map(p);\n        \n        if(d < EPSILON)\n        {\n            return t;\n        }\n        \n        t += d;\n        \n    \tif(t >= end)\n    \t{\n        \treturn end;\n    \t}    \n    }\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nmat3 ViewMatrix(vec3 eye, vec3 center, vec3 up)\n{\n    vec3 f = normalize(center-eye);\n    vec3 r = normalize(cross(f, up));\n    vec3 u = cross(r,f);\n    \n    return mat3(r,u,-f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \t// Calculate a nice screenspace color\n\tvec2 xy = fragCoord.xy / iResolution.xy;\n    xy = xy * 2.0f - 1.0f;\n\tfragColor = vec4(xy,0.5+0.5*sin(iTime),1.0);\n    \n    \n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 lookAt = vec3(0.0f, 0.0f, 0.0f);\n    vec3 eye = vec3(0.0, 0.0f, 7.0f);\n    \n    mat3 viewToWorld = ViewMatrix(eye, vec3(0.0f, 0.0f, 0.0f), vec3(0.0f, 1.0f, 0.0f));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float t = Trace(eye, worldDir, 0.0, 1000.0f);\n    \n     \n    float fog = 1.0f / (1.0f + t*t*0.4);\n    fragColor.rg = xy.rg;\n    \n    if(t > 1000.0f - EPSILON)\n    {\n    \tfragColor = vec4(0.0f, 0.0f, 0.0f, 1.0f);   \n        return;\n    }\n    \n    fragColor += fog;\n   \t//fragColor = vec4(1.0f, 1.0f, 1.0f, 1.0f);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dffRS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dffWj", "name": "fale caustics", "author": "frankbatista", "description": "here is a test caustic", "tags": ["causticstest"], "likes": 6, "viewed": 171, "date": "1498018106", "time_retrieved": "2024-06-20T18:55:36.124263", "image_code": "// Fake Caustics - written 2015 by Jakob Thomsen\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//#define pi 3.1415926\nfloat pi = 3.1415926;\nfloat pi2 = 2.0 * 3.1415926;\n\nvec4 rnd(vec2 pos)\n{\n    return texture(iChannel0, pos);\n}\n\nfloat wave(vec2 uv)\n{\n    float m = 0.0;\n    float sum = 0.0;\n    const float n = 4.0;\n    for(float y = 1.0; y <= n; y++)\n    {\n        for(float x = 1.0; x <= n; x++)\n        {\n            //vec4 r = rnd(0.001 * iTime + vec2(x, y) / n);\n            vec4 r = rnd(vec2(x, y) / n);\n            r.z = 2.0 * r.z - 1.0;\n            float a = sin(pi2 * (x * uv.x + r.x + 0.1 * iTime * r.z));\n            float b = sin(pi2 * (y * uv.y + r.y + 0.1 * iTime * r.z));\n            sum += a * b / (x * y);\n            m += 1.0 / (x * y);\n        }\n    }\n    return sum / m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 d = 1.0 / iResolution.xy;\n    vec3 nrm;\n    nrm.x = -wave(uv + vec2(-d.x, 0.0)) - wave(uv + vec2(+d.x, 0.0));\n    nrm.y = -wave(uv + vec2( 0.0,-d.y)) - wave(uv + vec2( 0.0,+d.y));\n    nrm.z = 1.0;\n    nrm = normalize(nrm);\n    \n    vec3 r = refract(vec3(0.0, 0.0, 1.0), nrm, 1.0);\n    fragColor = texture(iChannel1, uv.xy + 0.01 * r.xy);\n    //fragColor = texture(iChannel1, uv.xy);\n    fragColor.rgb += pow(abs(r.z), 100.0);\n}\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dffWj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dlBRf", "name": "Threstle-raymarching-1", "author": "Threstle", "description": "Threstle-raymarching-1", "tags": ["threstleraymarching1"], "likes": 2, "viewed": 108, "date": "1497285043", "time_retrieved": "2024-06-20T18:55:36.675778", "image_code": "// formules courtesy of http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n\nfloat unite( float a, float b){return min(a, b);}\nfloat subtract( float a, float b ){ return max(-a, b); }\nfloat intersect( float a, float b ){ return max(a, b); }\nfloat sphere( vec3 p, float s ){return length(p)-s;}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\nfloat torus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat displacement(vec3 p){\n    \n    return sin(60.0*p.x)*sin(60.0*p.y)*cos(60.0*p.z);\n}\n\nfloat sdf(vec3 p){\n\n    //float t = torus(vec3(p),vec2(1.0));\n    float t = sdTriPrism(vec3(p),vec2(1.0));\n   // float s = sphere(vec3(p),1.0);\n    \n    //float s = sphere(vec3(p),2.0);\n    float d = displacement(vec3(t));\n    \n   // float d = subtract(t,s);\n    \n    return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //1 : retrieve the fragment's coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy *2.0 - 1.0; // center the scene\n    \n    uv.x *= iResolution.x / iResolution.y;\n    \n    //2 : camera position and ray direction\n\tvec3 pos = vec3( 0.,0.,-3.);\n    \n    //pos.x = (pos.x*cos(iTime*0.1) - pos.y*sin(iTime*0.1));\n    //pos.y = (pos.x*sin(iTime*0.1) + pos.y*cos(iTime*0.1));\n    \n    float angle = iTime*1.0;\n    mat3 rot;\n    rot[0] = vec3(cos(angle),0.0,-sin(angle));\n    rot[1] = vec3(0.0,1.0,0.0);\n    rot[2] = vec3(-sin(angle),0.0,cos(angle));\n    \n    \n    pos = pos * rot;\n    \n\tvec3 dir = normalize( vec3( uv, 1. ) );\n    \n    //3 : ray march loop\n    //ip will store where the ray hits the surface\n    \n    vec3 ip;\n    \n    //variable step size\n    float t = 1.1;\n    \n    for(int i = 0; i < 32; i++){\n     \t\n        // update position along path\n        ip = pos + dir * t;\n        \n        // gets the shortest distance to the scene\n        float temp = sdf(ip);\n            \n        //break the loop if the distance was too small\n        // this means that we are close enough to the surface\n        if(temp < 0.01) break;\n            \n        // increment the step along the ray path\n         t+= temp;\n        \n    }\n    \n    // 4 : apply color to this fragment\n    \n\tfragColor = vec4(ip,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dlBRf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dlBRs", "name": "boxPass", "author": "kekwizard", "description": "...", "tags": ["box"], "likes": 0, "viewed": 104, "date": "1497701598", "time_retrieved": "2024-06-20T18:55:37.463637", "image_code": "#define MAX_STEPS 100\n#define MIN_DIST 0.001\n#define NORMAL_SMOOTHNESS 0.02\n#define PI 3.14159265359\n\nfloat time = 0.;\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nmat2 Rotate(float angle)\n{\n\treturn mat2(cos(angle), sin(angle), -sin(angle), cos(angle));   \n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nvec3 opCheapBend( vec3 p )\n{\n    float c = cos(1.0*p.y);\n    float s = sin(1.0*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return q;\n}\n\nfloat Scene(vec3 position)\n{\n    vec3 orig = position;\n    vec3 c = vec3(15., 15., 15.0);\n    \n    position.x = mod(position.x, c.x) - 0.5 * c.x; // p.z -0.05 - 0.05\n    position.y = mod(position.y, c.y) - 0.5 * c.y; // p.z -0.05 - 0.05\n    position.z = mod(position.z, c.z) - 0.5 * c.z; // p.z -0.05 - 0.05\n\n    vec3 rpos = position;\n    mat2 ma = Rotate(time + pow((orig.z / c.z), 1.01) * sin(time) * 0.005);\n    rpos.xy *= ma;\n    //rpos.xz *= mb;\n    //rpos.yz *= mb;\n    \n    float bsize = 2.;\n    float bhole = bsize - 0.5;\n    float bextrude = bsize + 0.5;\n    \n    //position = opCheapBend(position);\n   \n    float boxB = sdBox(rpos, vec3(bsize));\n    float boxA = sdBox(rpos, vec3(bhole, bhole, bextrude));\n    float boxC = sdBox(rpos, vec3(bhole, bextrude, bhole));\n    float boxD = sdBox(rpos, vec3(bextrude, bhole, bhole));\n\n    \n    float cellX = mod(orig.x / c.x, 2.);\n    \n    \n\tfloat res = opS(boxA, boxB);//min(res, svalue);\n    res = opS(boxC, res);\n    res = opS(boxD, res);\n    \n    position.z = mod(orig.z + sign(cellX - 1.0) * time * 10.0, c.z * .75) - 0.5 * c.z;\n    \n    \n    res = min(sdSphere(position, 1.0), res);\n    \n    //position.x += (position.x / 17.0);\n    \n   // position.z += position.z * sin(time);\n    \n    float map = 1.0;//-Sphere(17.99, position);\n    \n    //float timeD = c.z * 0.5 + c.z * 0.5 * sin(iTime * .5);\n   // float threshold = 0.1;\n    //if( abs(timeD - position.y - c.z * 0.5) < threshold ) return .0;\n    \n    \n\n    \n    map = min(map, res);\n    return map;\n}\n\nvec3 cameraMovement(vec3 position) {\n\tposition.z = time * 4.0;\n    return position;\n}\n\nvec3 Normal(vec3 position)\n{\n\tvec3 offset = vec3(NORMAL_SMOOTHNESS, 0, 0);\n    \n    vec3 normal = vec3\n    (\n        Scene(position - offset.xyz) - Scene(position + offset.xyz),\n        Scene(position - offset.zxy) - Scene(position + offset.zxy),\n        Scene(position - offset.yzx) - Scene(position + offset.yzx)\n    );\n    \n    return normalize(normal);\n}\n\nvec4 RayMarch(vec3 origin,vec3 direction)\n{\n    \n\n    float hitDist = 0.0;\n    int iters = 1;\n    for(int i = 0;i < MAX_STEPS;i++)\n    {\n        iters++;\n        float sceneDist = Scene(origin + direction * hitDist);\n        \n        hitDist += sceneDist;\n        \n        if(sceneDist < MIN_DIST)\n        {\n            break;\n        }\n    }\n    \n    return vec4(origin + direction * hitDist, float(iters)/float(MAX_STEPS));\n}\n\nvoid steadyRotate(inout vec3 orig, inout vec3 dir) {\n\tmat2 ma = Rotate(time * 0.0015);\n    mat2 mb = Rotate(time * 0.005);\n    orig.xy *= ma;\n    dir.xy *= ma;\n    \n    orig.xz *= mb;\n    dir.xz *= mb;\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime * 0.8;\n        \n    vec2 aspect = iResolution.xy / iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    vec3 rayOrigin = cameraMovement(vec3(0. , 0., 0.0));\n    vec3 rayDirection = normalize(vec3(uv - aspect / 2.0, 1.0));   \n    \n    //steadyRotate(rayDirection, rayOrigin);\n    vec4 scenePosition = RayMarch(rayOrigin, rayDirection);\n        \n    \n\tfragColor = vec4(vec3(1. - scenePosition.w), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dlBRs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dlBWS", "name": "3D Glasses Test", "author": "slerpy", "description": "Simple 3D Demo", "tags": ["3d"], "likes": 7, "viewed": 323, "date": "1497883713", "time_retrieved": "2024-06-20T18:55:37.463637", "image_code": "#define TAU 6.28318530718\n\n#define FAR 250.\n#define FOG 4.\n#define ITER 128\n#define QUA .0\n#define NORK 5e-3\n\n// EOFF (Eye-OFFset) is half the distance between both cameras in meters.\n// Invert this number to invert the colors or set it to .0 for a non-3D shader.\n\n#define EOFF .03\n\nmat3 rx(float a){ float sa = sin(a), ca = cos(a); return mat3(1.,0.,0.,0.,ca,sa,0.,-sa,ca); }\nmat3 ry(float a){ float sa = sin(a), ca = cos(a); return mat3(ca,0.,sa,0.,1.,0.,-sa,0.,ca); }\nmat3 rz(float a){ float sa = sin(a), ca = cos(a); return mat3(ca,sa,0.,-sa,ca,0.,0.,0.,1.); }\n\nfloat map(vec3 p)\n{\n    vec3 v = abs(round(p)-p);\n\treturn max(max(v.x,v.y),v.z)-.1;\n}\n\nvec3 normal(vec3 p, float k)\n{\n\tvec2 e = vec2(.0,k);\n\treturn normalize(vec3(\n\t\tmap(p) - map(p - e.yxx),\n\t\tmap(p) - map(p - e.xyx),\n\t\tmap(p) - map(p - e.xxy)\n\t));\n}\n\nfloat tracer(vec3 ro, vec3 rd)\n{    \n    float t = .0, d;\n    for(int i=0; i < ITER; i++){        \n        d = map(ro + rd*t);\n        if (d < QUA*t || t > FAR) break;\n        t += d;\n    } \n    return t + QUA;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n    \n    uvec2 tmp = uvec2(fragCoord) & 1u;\n    bool alt = tmp.x == tmp.y;\n\n\tvec3 ro = vec3(vec2(.5),iTime);\n    vec3 rd = normalize(vec3(uv,2));\n    vec3 dp = vec3(EOFF/2.,vec2(0));\n    \n    mat3 rt = rx(iTime/32.)*ry(iTime/32.);\n    rd *= rt; dp *= rt;\n    \n    if(alt) ro += dp;\n    else ro -= dp;\n    \n    float t = tracer(ro,rd);\n\tvec3 sp = ro + rd*t;\n    \n\tvec3 sn = normal(sp,NORK);\n    vec3 ld = normalize(ro-sp);\n\tfloat diff = max(dot(sn,ld),0.);\n    \n    vec3 col = vec3(1.);\n    col *= (1.+diff)/2.;\n    col *= exp(-t/FOG);\n    \n    if(alt) col.x *= .0;\n    else col.yz *= .0;\n    \n\tfragColor = vec4(col,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dlBWS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dlfDf", "name": "Just a Mandelbrot", "author": "DJDoomz", "description": "Now with broken periodicity checking", "tags": ["2d", "fractal", "mandelbrot"], "likes": 4, "viewed": 152, "date": "1498579056", "time_retrieved": "2024-06-20T18:55:37.730323", "image_code": "#define maxIter 1000.\n#define pi 3.14159\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    fragColor -= fragColor;\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = (uv-.5)*4.;\n    uv.y/=iResolution.x/iResolution.y;\n    \n    float s = sin(t/5.), c = cos(t/5.);\n    uv *=mat2(c,s,s,-c);\n    \n    float zoom = pow(2.,8.*sin(t/8.-.5*pi)+8.);\n    \n    uv /= zoom;\n    \n    uv.x -= .7;\n    uv.y -= 0.3501;\n    \n    float Iter = 0.;\n    \n    float p=sqrt( (uv.x-.25) * (uv.x-.25) + uv.y*uv.y);\n    if(uv.x < p-2.*(p*p)+.25 || (uv.x+1.)*(uv.x+1.)+uv.y*uv.y < 1./16.)Iter = maxIter; //copied from wikipedia, skips over main bulb\n    \n    vec2 comp = uv;\n    vec2 tempcomp = vec2(0.);\n    \n    for(float i = 0.0; i < maxIter; i++)\n    {\n        tempcomp = vec2(comp.x*comp.x-comp.y*comp.y, 2.*(comp.x*comp.y))+uv;\n        Iter += (tempcomp.x > comp.x-0.005 && tempcomp.x < comp.x+0.005) ? maxIter : 1.;\n        comp = tempcomp;\n        if(length(comp) > 4. || Iter > maxIter) break;\n    }\n    \n    if(Iter<maxIter) Iter=5.*Iter-500.;\n   \n    fragColor.xyz += abs(sin(Iter/maxIter*pi));\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dlfDf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dlfWf", "name": "Daily 2017-06-28", "author": "Koltes", "description": "Daily", "tags": ["daily"], "likes": 1, "viewed": 372, "date": "1498650768", "time_retrieved": "2024-06-20T18:55:37.730323", "image_code": "// Inspired by aurelia's logo.\n\n#define BORDER .2\n\nstruct B{bool i,o;float m;};\nstruct M{float d,m;};\nstruct N{M m;float d1,d2;};\nfloat C,S;\n#define rot(a) mat2(C=cos(a),S=sin(a),-S,C)\n    \nvoid bup(inout B b,float d){\n    if(!b.o){\n        if (b.i&&d>=b.m)b.o=true;\n        else if (!b.i&&d<b.m){\n            b.i=true;\n            b.m=d;\n        }\n    }\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b + BORDER;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0))-BORDER;\n}\n\nM mmin(M a,M b){\n    if(a.d<b.d)return a;else return b;\n}\n\nfloat smax(float a,float b,float k){\n    float h=clamp((b-a)/k*.5+.5,0.,1.);\n    return mix(a,b,h)+k*h*(1.-h);\n}\n\nN map(vec3 p){\n    p.xy*=rot(iTime*.3);\n    p.yz*=rot(iTime*.5);\n    p.xy*=rot(iTime*.7);\n    float d1=sdBox(p+vec3(0.,0.,1.),vec3(3.,1.5,3.));\n    float d2=sdBox(p+vec3(0.,0.,-1.),vec3(1.5,3.,3.));\n    M m;\n    m.d=min(d1,d2);\n    m.m=1.;\n    M m2;\n    m2.d=smax(d1-BORDER,d2-BORDER,BORDER);\n    m2.m=0.;\n    N n;\n    n.m=mmin(m,m2);\n    n.d1=d1;\n    n.d2=d2;\n    return n;\n}\n\nvec3 norm(vec3 p){\n    vec2 e=vec2(.001,0.);\n    return normalize(vec3(\n        map(p+e.xyy).m.d-map(p-e.xyy).m.d,\n        map(p+e.yxy).m.d-map(p-e.yxy).m.d,\n        map(p+e.yyx).m.d-map(p-e.yyx).m.d\n        ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv-=.5;\n    uv.x*=iResolution.x/iResolution.y;\n    vec3 ro=vec3(uv,-10.),rd=normalize(vec3(uv,1.)),mp=ro;\n    N mn;\n    B b1=B(false,false,BORDER);\n    B b2=B(false,false,BORDER);\n    int i;for(i=0;i<50;++i){\n        mn=map(mp);\n        bup(b1,mn.d1);\n        bup(b2,mn.d2);\n        if(abs(mn.m.d)<.001)break;\n        mp+=rd*mn.m.d;\n    }\n    vec3 c=vec3(exp(-pow(length(uv),2.)*10.));\n    if (i<50&&(!b1.o&&!b2.o)){\n        vec3 n=norm(mp);\n        c=mix(c,mix(vec3(.1,.0,.1),vec3(.8,.1,.6),pow(dot(normalize(vec3(1.,1.,-1.)),n),4.)),mn.m.m);\n    }\n    c=sqrt(c);\n\tfragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dlfWf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dlfWn", "name": "HyperSphere 5x5x5", "author": "JCDjcd", "description": "4D sphere with 5 wires along each angle alpha,beta,gamma (parameterizing the hypersphere).\nAlpha (resp. beta and gamma) wires are displayed in red (resp. green and blue).\nIntersections of 2 wires (different color) are yellow, cyan or purple... 3 is white.", "tags": ["sphere", "4d"], "likes": 14, "viewed": 265, "date": "1496353504", "time_retrieved": "2024-06-20T18:55:38.378907", "image_code": "//--------------------------------------------------------------------------\n#define TWOPI \t\t\t(2.0*3.1415926535)\n#define ROTATION(alpha) mat2(cos(alpha),-sin(alpha),sin(alpha),cos(alpha))\n#define COLORIZATION(h)\tclamp(abs(fract(h+vec4(3.0,2.0,1.0,0.0)/3.0)*6.0-3.0)-1.0,0.0,1.0)\n\n//--------------------------------------------------------------------------\n// Ray is defined by M(t1,t2) = P + t1.d1 + t2.d2\nvec4 compute(vec4 P,vec4 d1,vec4 d2,int method /* 0-left or 1-right */)\n{    \n\t// compute the intersections with the hypersphere\n    // it turns out that it is specifically a circle\n    float t1_center = -dot(P,d1);\n    float t2_center = -dot(P,d2);\n    float r2 \t\t= 1.0 + t1_center*t1_center + t2_center*t2_center - dot(P,P);\n    \n    if(r2 < 0.0)\n    {\n        return vec4(0.0,0.0,0.0,1.0);\n    }\n    else\n    {\n        float r \t= sqrt(r2);\n        int N \t\t= 200+int(400.0*r);\n        vec4 color \t= vec4(0.0,0.0,0.0,1.0);\n        for(int i=0;i<=N;i++)\n        {\n            // angle along the circle within the (z,w) plan\n            float q  = TWOPI*float(i)/float(N);\n            float t1 = t1_center+r*cos(q); // z\n            float t2 = t2_center+r*sin(q); // w\n            \n            vec4 M    = P + t1*d1 + t2*d2;\n            M \t\t  = M/sqrt(dot(M,M)); // solve roudning issue => slight renormalization to 1\n            \n            float gamma = acos(M.w);\n            float beta \t= atan(sqrt(M.x*M.x+M.y*M.y),M.z);\n            float alpha\t= atan(M.y,M.x);\n            \n            float repeat    = 7.0;\n            float threshold = 0.98;\n            int bool_alpha \t= cos(alpha*repeat) > threshold ? 1 : 0;\n            int bool_beta\t= cos( beta*repeat) > threshold ? 1 : 0;\n            int bool_gamma\t= cos(gamma*repeat) > threshold ? 1 : 0;\n            \n            //bool_alpha = 0;\n            //bool_beta = 0;\n            //bool_gamma = 0;\n            vec4 c = vec4(0.0,0.0,0.0,1.0);\n            if(0 == method)\n            {\n                int sum = bool_alpha+bool_beta+bool_gamma;\n                if(sum >= 1)\n                {\n                    c = vec4(float(bool_alpha),float(bool_beta),float(bool_gamma),1.0);\n                    \n                    // highlight higher-order intersections\n                    if(sum == 2)\n                        c *= 2.0;\n                    else if(sum == 3)\n                        c *= 100.0;\n                    \n                    c *= 1.0/float(N)*7.0*r;\n                }\n            }\n            else\n            {\n                int sum = bool_alpha+bool_beta+bool_gamma;\n                if(sum >= 1)\n                {\n                    c = vec4(float(bool_alpha),float(bool_beta),float(bool_gamma),1.0);\n\n                    if(sum == 1)\n                        c *= 0.0; // don't display simple intersection (order 1)\n                    else if(sum == 3)\n                        c *= 100.0;\n                    \n                    c *= 1.0/float(N)*30.0*r;\n                }\n            }\n            \n            color += c;\n            //color += c*(0.75+0.25*cos(q));\n\n        } // for()\n        return vec4(color.rgb,1.0);\n    }\n} // compute()\n\nvec4 transform(vec4 X)\n{\n    float alpha1\t= iTime*TWOPI/51.0;\n    float alpha2\t= iTime*TWOPI/45.0;\n    float beta1\t\t= iTime*TWOPI/31.0;\n    float beta2\t\t= iTime*TWOPI/37.0;\n    float beta3\t\t= iTime*TWOPI/43.0;\n    \n    vec4 Y = X;\n    Y.xw *= ROTATION(beta1);\n    Y.yw *= ROTATION(beta2);\n    Y.zw *= ROTATION(beta3);\n    Y.xy *= ROTATION(alpha1);\n    Y.zx *= ROTATION(alpha2);\n\treturn Y;\n} // transform()\n\n//--------------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor,vec2 fragCoord)\n{\n    float m \t\t= iResolution.x/4.0;\n\tvec2 uvLeft\t\t= (fragCoord.xy/m - vec2(1.0,1.0))*1.2;\n\tvec2 uvRight\t= (fragCoord.xy/m - vec2(3.0,1.0))*1.2;\n    vec4 d1      \t= transform(vec4(0.0,0.0,1.0,0.0)); // direction along z\n    vec4 d2      \t= transform(vec4(0.0,0.0,0.0,1.0)); // direction along w\n    if(dot(uvLeft,uvLeft)<=1.0)\n    {\n        vec4 P \t\t\t= transform(vec4(uvLeft,0.0,0.0));\n        fragColor = compute(P,d1,d2,0);\n    }\n    else if(dot(uvRight,uvRight)<=1.0)\n    {\n        vec4 P \t\t\t= transform(vec4(uvRight,0.0,0.0));\n        fragColor = compute(P,d1,d2,1);\n    }\n\n} // mainImage()\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dlfWn.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dsBDl", "name": "Complex Function Plot", "author": "yumcyawiz", "description": "Plot complex functions", "tags": ["complex"], "likes": 4, "viewed": 144, "date": "1498833676", "time_retrieved": "2024-06-20T18:55:38.378907", "image_code": "//convert hsv to rgb\nvec3 hsv2rgb(float h, float s, float v) {\n    return ((clamp(abs(fract(h+vec3(0,2,1)/3.)*6.-3.)-1.,0.,1.)-1.)*s+1.)*v;\n}\n\n\n//complex number utils\nvec2 cmult(vec2 z1, vec2 z2) {\n    return vec2(z1.x*z2.x - z1.y*z2.y, z1.x*z2.y + z1.y*z2.x);\n}\nvec2 cdiv(vec2 z1, vec2 z2) {\n    return 1.0/(z2.x*z2.x + z2.y*z2.y) * vec2(z1.x*z2.x + z1.y*z2.y, -z1.x*z2.y + z1.y*z2.x);\n}\nfloat carg(vec2 z) {\n    float arg = atan(z.y, z.x);\n    if(arg < 0.0) {\n        arg = 6.28 + arg;\n    }\n    return arg;\n}\nvec2 cpow(vec2 z, float n) {\n    float arg = carg(z);\n    return pow(length(z), n) * vec2(cos(n*arg), sin(n*arg));\n}\n\n\n//complex function\nvec2 f(vec2 z) {\n    return cdiv(cpow(z, iTime/2.0) + vec2(-1, 0), cpow(z, 2.0) + vec2(1, 1));\n}\n\n\n//coloring\nfloat contourInterval = 1.0;\nvec3 coloring(vec2 z) {\n    float zabs = length(z);\n    float arg = carg(z);\n    return hsv2rgb(arg/6.28, 1.0 - 0.5*pow(abs(sin(zabs*3.14/2.0/contourInterval)), 10.0), clamp(zabs, 0.0, 1.0));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.0*(2.0*fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    vec2 z = f(uv);\n    \n\tfragColor = vec4(coloring(z), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dsBDl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dsBRB", "name": "Interconnected Portal", "author": "rohtie", "description": "Inspired by the album cover of Altered State by TesseracT", "tags": ["interconnectedportalweb"], "likes": 6, "viewed": 201, "date": "1496748174", "time_retrieved": "2024-06-20T18:55:38.378907", "image_code": "mat2 rotate(float a) {\n    return mat2(-sin(a), cos(a),\n                 cos(a), sin(a));\n}\n\nvoid mainImage( out vec4 o, in vec2 p ) {\n    p /= iResolution.xy;\n    p -= 0.5;\n    p.x *= iResolution.x / iResolution.y;\n    \n    vec2 p2 = p;\n    \n    vec2 q = p;\n    vec2 u = p;\n    \n    float size = 0.35;\n    float deg30 = 0.523599;\n \n\n    float a = 0.15 + iTime * 0.1;\n    \n    mat2 rotation =  mat2(-sin(a), cos(a),\n                           cos(a), sin(a));\n       \n    p *= rotation;\n    p2 *= rotation;\n    \n    \n    u.x += sin(iTime) * 0.1;\n    u.y += cos(iTime) * 0.1;\n    \n    \n    float deform = (0.5 + 2.5 * dot(u, u));\n    p *= deform;\n    p2 *= deform;\n\n    p.x = mod(p.x, 0.05 * size * 2.0);\n    p.y = mod(p.y, 0.05 * size);\n    p -= 0.025 * size;\n\n\n    \n    p2.y -= 0.025 * size;\n    p2.x = mod(p2.x + 0.05 * size, 0.05 * size * 2.0);\n    p2.y = mod(p2.y, 0.05 * size);\n    p2 -= 0.025 * size;\n\n   \n    float r = length(p) - 0.0075 * size;\n    \n\n    r = min(r, abs(p.x) - 0.00001 * size);  \n    \n    \n    float cut = p.x;\n    \n    p *= rotate(deg30);\n    r = min(r, max(-cut, abs(p.x) - 0.00001 * size));\n\n    p *= rotate(-deg30);\n    r = min(r, max(-cut, abs(p.x) - 0.00001 * size));\n    \n    \n    \n    r = min(r, length(p2) - 0.0075 * size);\n    \n    r = min(r, abs(p2.x) - 0.00001 * size);  \n    \n    cut = p2.x;\n    \n    p2 *= rotate(deg30);\n    r = min(r, max(-cut, abs(p2.x) - 0.00001 * size));\n    p2 *= rotate(-deg30);\n    r = min(r, max(-cut, abs(p2.x) - 0.00001 * size));\n    \n    \n    float sphereMask = length(q) - 0.35;\n    r = max(r, sphereMask);\n\n    float foreground = smoothstep(0.0025 * size, 0.0, r);\n    float background = 1.0 - foreground;\n\n    o.rgb = (\n        foreground * vec3(1.0, 1.0, 1.0) + \n        background * vec3(0.0, 0.0, 0.0) \n        + smoothstep(0.0, 0.001, sphereMask) - sphereMask * 0.15\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dsBRB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dsBRf", "name": "Threstle-raymarching-2", "author": "Threstle", "description": "Threstle-raymarching-2", "tags": ["threstleraymarching2"], "likes": 1, "viewed": 82, "date": "1497285590", "time_retrieved": "2024-06-20T18:55:39.160828", "image_code": "// formules courtesy of http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n\nfloat unite( float a, float b){return min(a, b);}\nfloat subtract( float a, float b ){ return max(-a, b); }\nfloat intersect( float a, float b ){ return max(a, b); }\nfloat sphere( vec3 p, float s ){return length(p)-s;}\n\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdHexPrism( vec3 p, vec2 h)\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\nfloat torus( vec3 p, vec2 t, float hole  )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  \n  return length(q)-(t.y/hole);\n}\n\nfloat displacement(vec3 p){\n    \n    return sin(10.0*p.x)*cos(10.0*p.y)*cos(10.0*p.z);\n}\n\nvec3 rotate(vec3 p,float angle, int axis){\n    mat3 rot;\n    \n    if(axis == 0)\n    {\n        rot[0] = vec3(1.0,0,0.0);\n        rot[1] = vec3(0.0,cos(angle),sin(angle));\n        rot[2] = vec3(0.0,-sin(angle),cos(angle));\n    }\n    else if(axis == 1)\n    {\n        rot[0] = vec3(cos(angle),0,-sin(angle));\n        rot[1] = vec3(0.0,1.0,0.0);\n        rot[2] = vec3(sin(angle),0.0,cos(angle));\n    }\n    else\n    {\n        rot[0] = vec3(cos(angle),sin(angle),0.0);\n        rot[1] = vec3(-sin(angle),cos(angle),0.0);\n        rot[2] = vec3(0.0,0.0,1.0);\n    }\n    \n    return p * rot;\n\n}\n\nfloat sdf(vec3 p){\n\n    \n    float angle = iTime*1.0;\n        \n    \n    \n    \n    \n    //pos = pos * rot;\n    \n    //float t = torus(vec3(p),vec2(1.0));\n    float t = torus(rotate(p,-iTime/10.0,0),vec2(1.5),8.0);\n    float t2 = torus(rotate(p,iTime*2.0,2),vec2(1.0),8.0);\n    float t3 = torus(rotate(p,-iTime*4.0,1),vec2(1.0),8.0);\n    float t4 = torus(rotate(p,iTime/4.0,2),vec2(2.0),20.0);\n    float t5 = torus(rotate(p,-iTime/1.0,2),vec2(2.5),20.0);\n    //float s = sphere(vec3(0.2),0.3);\n    \n    //float s = sphere(vec3(p),1.0);\n    //float d = displacement(vec3(t));\n    \n    //float d = subtract(t,s);\n    \n \n    return sin(t*t2*t3*t4*t5);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //1 : retrieve the fragment's coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy *2.0 - 1.0; // center the scene\n    \n    uv.x *= iResolution.x / iResolution.y;\n    \n    //2 : camera position and ray direction\n\tvec3 pos = vec3( 0.,0.,-3.5);\n    \n    //pos.x = (pos.x*cos(iTime*0.1) - pos.y*sin(iTime*0.1));\n    //pos.y = (pos.x*sin(iTime*0.1) + pos.y*cos(iTime*0.1));\n    \n    float angle = iTime*1.0;\n        \n    \n    \n    // rotation sur soi mme\n    mat3 rot;\n    rot[0] = vec3(cos(angle),0.0,-sin(angle));\n    rot[1] = vec3(0.0,1.0,0.0);\n    rot[2] = vec3(-sin(angle),0.0,cos(angle));\n    \n   \n    \n    \n   // pos = pos * rot;\n    \n\tvec3 dir = normalize( vec3( uv, 1. ) );\n    \n    //3 : ray march loop\n    //ip will store where the ray hits the surface\n    \n    vec3 ip;\n    \n    //variable step size\n    float t = 1.1;\n    \n    for(int i = 0; i < 32; i++){\n     \t\n        // update position along path\n        ip = pos + dir * t;\n        \n        // gets the shortest distance to the scene\n        float temp = sdf(ip);\n        \n\n        //break the loop if the distance was too small\n        // this means that we are close enough to the surface\n        if(temp < 0.01) break;\n            \n        // increment the step along the ray path\n         t+= temp;\n        \n    }\n    \n    // 4 : apply color to this fragment\n    //fragColor = vec4(ip,1.0);\n\tfragColor = vec4(vec3(ip.x*clamp(sin(iTime),0.5,1.0),ip.y*clamp(sin(iTime),0.5,1.0),ip.z*clamp(sin(iTime),0.5,1.0)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dsBRf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dsBWf", "name": "Truchet Flythrough 2", "author": "dr2", "description": "The original updated to use cubic cell Truchet", "tags": ["truchet", "tiling", "flight", "drone"], "likes": 7, "viewed": 566, "date": "1498556051", "time_retrieved": "2024-06-20T18:55:39.173060", "image_code": "// \"Truchet Flythrough 2\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// The original updated to use cubic cell Truchet (see Truchet Tentacles by WAHa_06x36 for mapping)\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrRCylDf (vec3 p, float r, float rt, float h);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashfv3 (vec3 p);\nfloat Noisefv3 (vec3 p);\n\nvec3 dronePos[2], ltPos;\nvec2 aTilt[2];\nfloat dstFar, tCur;\nint idObj;\nconst int idDrBod = 11, idDrLamp = 12, idDrCam = 13;\nconst float pi = 3.14159;\n\nfloat DroneDf (vec3 p, float dMin)\n{\n  vec3 q;\n  float d;\n  q = p;\n  q.y -= 0.05;\n  d = PrRCylDf (q.xzy, 0.2, 0.03, 0.07);\n  if (d < dMin) { dMin = d;  idObj = idDrBod; }\n  q.y -= 0.07;\n  d = PrRoundBoxDf (q, vec3 (0.06, 0.02, 0.12), 0.04);\n  if (d < dMin) { dMin = d;  idObj = idDrLamp; }\n  q = p;\n  q.y -= -0.05;\n  d = PrSphDf (q, 0.17);\n  if (d < dMin) { dMin = d;  idObj = idDrCam; }\n  q = p;\n  q.xz = abs (q.xz) - 0.7;\n  d = min (PrCylAnDf (q.xzy, 0.5, 0.05, 0.05), PrCylDf (q.xzy, 0.1, 0.03));\n  q -= vec3 (-0.4, -0.15, -0.4);\n  d = min (d, PrRCylDf (q.xzy, 0.05, 0.03, 0.2));\n  q -= vec3 (-0.3, 0.2, -0.3);\n  q.xz = Rot2D (q.xz, 0.25 * pi);\n  d = min (d, min (PrRCylDf (q, 0.05, 0.02, 1.), PrRCylDf (q.zyx, 0.05, 0.02, 1.)));\n  if (d < dMin) { dMin = d;  idObj = idDrBod; }\n  return dMin;\n}\n\nvec3 TrackPath (float t)\n{\n  return vec3 (2. * sin (0.2 * t) + 0.9 * sin (0.23 * t),\n     1.3 * sin (0.17 * t) + 0.66 * sin (0.24 * t), t);\n}\n\nvec2 TubeNutDf (vec3 p)\n{\n  vec3 q;\n  float a, dNut, dTor;\n  float radI = 0.05;\n  p.z -= 0.5;\n  q = p;\n  a = atan (- q.y, q.x);\n  q.xy = Rot2D (q.xy, 2. * pi * (floor (8. * a / (2. * pi)) + 0.5) / 8.);\n  q.x -= 0.5;\n  q = abs (q);\n  dNut = max (max (max (q.x * 0.866 + q.z * 0.5, q.z) - radI - 0.015,\n     q.y - 0.03), 0.007 - q.y);\n  dNut = min (dNut, PrRCylDf (q.xzy, radI + 0.005, 0.001, 0.045));\n  dTor = length (vec2 (length (p.xy) - 0.5, p.z)) - radI +\n     0.004 * SmoothBump (0.2, 0.8, 0.07, mod (24. * a + 1./24., 1.));\n  return vec2 (dTor, dNut);\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  vec2 vMin;\n  float dMin, r;\n  const float dSzFac = 15.;\n  q = p;\n  q.xy -= TrackPath (q.z).xy;\n  r = floor (8. * Hashfv3 (floor (q)));\n  q = fract (q);\n  if (r >= 4.) q = q.yxz;\n  r = mod (r, 4.);\n  if (r == 0.) q.x = 1. - q.x;\n  else if (r == 1.) q.y = 1. - q.y;\n  else if (r == 2.) q.xy = 1. - q.xy;\n  vMin = min (TubeNutDf (q), min (TubeNutDf (vec3 (q.z, 1. - q.x, q.y)),\n     TubeNutDf (vec3 (1. - q.yz, q.x))));\n  if (vMin.x < vMin.y) { dMin = vMin.x;  idObj = 1; }\n  else { dMin = vMin.y;  idObj = 2; }\n  dMin *= 0.9;\n  dMin *= dSzFac;\n  for (int k = 0; k < 2; k ++) {\n    q = dSzFac * (p - dronePos[k]);\n    q.yz = Rot2D (q.yz, - aTilt[k].y);\n    q.yx = Rot2D (q.yx, - aTilt[k].x);\n    dMin = DroneDf (q, dMin);\n  }\n  dMin /= dSzFac;\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = ObjDf (ro + rd * dHit);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = 0; j < 16; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += 0.07;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn, ltVec;\n  float dHit, ltDist, sh, spec;\n  dHit = ObjRay (ro, rd);\n  if (dHit < dstFar) {\n    ro += dHit * rd;\n    if (idObj >= idDrBod) {\n      if (idObj == idDrBod) {\n        col = vec3 (0.2, 0.2, 0.9);\n        spec = 1.;\n      } else if (idObj == idDrLamp) {\n        col = mix (vec3 (0., 1., 0.), vec3 (1., 0., 0.),\n           step (0., sin (10. * tCur)));\n        spec = -1.;\n      } else if (idObj == idDrCam) {\n        col = vec3 (0.1);\n        spec = 1.;\n      }\n    } else {\n      if (idObj == 1) col = vec3 (1., 0.5, 0.);\n      else col = vec3 (1., 1., 0.2);\n      col *= 0.5 + 0.5 * smoothstep (0., 1., 0.5 + 0.5 * Noisefv3 (500. * ro));\n      spec = 0.3;\n    }\n    vn = ObjNf (ro);\n    ltVec = ltPos - ro;\n    ltDist = length (ltVec);\n    ltVec /= ltDist;\n    if (spec >= 0.) {\n      sh = ObjSShadow (ro, ltVec);\n      col = col * (0.1 + 0.9 * sh * max (dot (vn, ltVec), 0.)) +\n         spec * sh * pow (max (dot (normalize (vn - rd), vn), 0.), 64.);\n      col *= 1. / (1. + 0.1 * ltDist * ltDist);\n    }\n  } else col = vec3 (0.);\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, pF, pB, u, vd;\n  vec2 canvas, uv, ori, ca, sa;\n  float az, el, asp, zmFac, vFly, f;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  vFly = 1.5;\n  for (int k = 0; k < 2; k ++) {\n    dronePos[k] = TrackPath (vFly * tCur + 0.5 + 0.8 * float (k));\n    dronePos[k].y += 0.06 * (1. - 2. * float (k)) * sin (0.2 * tCur);\n    aTilt[k] = vec2 (20. * (TrackPath (dronePos[k].z + 0.05).x -\n       dronePos[k].x), 0.2);\n  }\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az = 2. * pi * mPtr.x;\n    el = -0.1 * pi + pi * mPtr.y;\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  zmFac = 2.;\n  rd = normalize (vec3 ((2. * tan (0.5 * atan (uv.x / (asp * zmFac)))) * asp,\n    uv.y / zmFac, 1.));\n  pF = TrackPath (vFly * tCur + 0.1);\n  pB = TrackPath (vFly * tCur - 0.1);\n  ro = 0.5 * (pF + pB);\n  vd = normalize (pF - pB);\n  u = - vd.y * vd;\n  f = 1. / sqrt (1. - vd.y * vd.y);\n  vuMat = mat3 (f * vec3 (vd.z, 0., - vd.x), f * vec3 (u.x, 1. + u.y, u.z), vd) *\n     vuMat;\n  rd = vuMat * rd;\n  rd.xy = Rot2D (rd.xy, 2. * (pF.x - pB.x));\n  ltPos = ro + vuMat * vec3 (0.3, 0.5, 0.1);\n  dstFar = 30.;\n  fragColor = vec4 (pow (clamp (ShowScene (ro, rd), 0., 1.), vec3 (0.8)), 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrRCylDf (vec3 p, float r, float rt, float h)\n{\n  vec2 dc;\n  float dxy, dz;\n  dxy = length (p.xy) - r;\n  dz = abs (p.z) - h;\n  dc = vec2 (dxy, dz) + rt;\n  return min (min (max (dc.x, dz), max (dc.y, dxy)), length (dc) - rt);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, cHashA3)) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t1, t2;\n  vec3 ip, fp;\n  float q;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  q = dot (ip, cHashA3);\n  t1 = Hashv4f (q);\n  t2 = Hashv4f (q + cHashA3.z);\n  return mix (mix (mix (t1.x, t1.y, fp.x), mix (t1.z, t1.w, fp.x), fp.y),\n              mix (mix (t2.x, t2.y, fp.x), mix (t2.z, t2.w, fp.x), fp.y), fp.z);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dsBWf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dsfzf", "name": "Simple Procedural Sun", "author": "Ebanflo", "description": "More FBM stuff, mouse rotates camera", "tags": ["procedural", "3d", "raytracing", "fractal", "noise", "fbm"], "likes": 8, "viewed": 662, "date": "1497568810", "time_retrieved": "2024-06-20T18:55:39.173060", "image_code": "#define urx 1920U\n#define ury 1080U\n#define pi 3.141592654\n//sun\n#define sunCenter vec3(0.0)\n#define sunRad .25\n#define fractalIterations 4\n#define fractalScale 10.0\n#define fractalFreq 2.0\n#define sunBrightness .87\n#define redMean .55\n#define greenMean .35\n#define blueMean .0\n//corona\n#define coronaCol vec3(.8, .5, .1)\n#define coronaDropOff 15.0\n\nfloat iSphere(vec3 ray, vec3 dir, vec3 center, float radius)\n{\n\tvec3 rc = ray-center;\n\tfloat c = dot(rc, rc) - (radius*radius);\n\tfloat b = dot(dir, rc);\n\tfloat d = b*b - c;\n\tfloat t = -b - sqrt(abs(d));\n\tfloat st = step(0.0, min(t,d));\n\treturn mix(-1.0, t, st);\n}\n\n\nvec4 iPlane(vec3 ro, vec3 rd, vec3 po, vec3 pd){\n    float d = dot(po - ro, pd) / dot(rd, pd);\n    return vec4(d * rd + ro, d);\n}\n\nvec3 r(vec3 v, vec2 r){//rodolphito's rotation\n    vec4 t = sin(vec4(r, r + 1.5707963268));\n    float g = dot(v.yz, t.yw);\n    return vec3(v.x * t.z - g * t.x,\n                v.y * t.w - v.z * t.y,\n                v.x * t.x + g * t.z);\n}\n\nfloat hash(uint n){//Hugo Elias's hash\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return 1.0 - float(n & 0x7fffffffU)/float(0x7fffffff);\n}\n\nfloat hashNoise3(vec3 x){\n    vec3 fr = fract(x);\n    fr = smoothstep(0.0, 1.0, fr);\n    uvec3 p = uvec3(x);\n    return mix(mix(mix(hash(p.x + ury * p.y + urx * p.z), \n                        hash(p.x + 1U + ury * p.y + urx * p.z),fr.x),\n                   mix(hash(p.x + ury * (p.y + 1U) + urx * p.z), \n                        hash(p.x + 1U + ury * (p.y + 1U) + urx * p.z),fr.x),fr.y),\n               mix(mix(hash(p.x + ury * p.y + urx * (p.z + 1U)), \n                        hash(p.x + 1U + ury * p.y + urx * (p.z + 1U)),fr.x),\n                   mix(hash(p.x + ury * (p.y + 1U) + urx * (p.z + 1U)), \n                        hash(p.x + 1U + ury * (p.y + 1U) + urx * (p.z + 1U)),fr.x),fr.y),fr.z);\n}\n\nfloat fractalNoise3(vec3 pos){\n    float acc = 0.0;\n    float scale = 1.0;\n    for(int n = 0; n < fractalIterations; n++){\n        acc += hashNoise3(scale * pos) / scale;\n        scale *= 2.0;\n    }\n    return acc / 2.0;\n}\n\nvec3 colorSun(float x){\n    vec3 result = vec3(0.0);\n    result.x += exp(-(x - redMean) * (x - redMean) * 16.0);\n    result.y += exp(-(x - greenMean) * (x - greenMean) * 16.0);\n    //result.z += exp(-(x - blueMean) * (x - blueMean) * 16.0);\n    if(result.y > .5) result.x += result.y;\n    return result;\n}\n\nvec3 render(vec3 rd, vec3 ro){\n    float d = iSphere(ro, rd, sunCenter, sunRad);\n    if(d > 0.0){\n        vec3 n = normalize(d * rd + ro - sunCenter);\n        float f = fractalNoise3(fractalScale * n + (.3 + .2 * sin(fractalFreq * iTime)\n                                      + fractalFreq * vec3(iTime + 13.0)));\n        vec3 col = colorSun(f);\n        return col + dot(rd, n) * (1.0 - sunBrightness);\n    }\n    else{\n        vec4 intersect = iPlane(ro, rd, sunCenter, normalize(sunCenter - ro));\n        return pow(coronaCol, vec3(coronaDropOff * (length(intersect.xyz - sunCenter) - sunRad)));\n    }\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n\tfragColor = vec4(0.0);\n    vec2 xy = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 cam = vec3(0.0, 0.0, -1.0);\n    vec3 dir = normalize(vec3(xy, 2.5));\n    vec2 m = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n    m *= 2.0;\n    dir = r(dir, m);\n    cam = r(cam, m);\n    fragColor.xyz = render(dir, cam);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dsfzf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dSyR3", "name": "Sum ray marching", "author": "public_int_i", "description": "ray marching with additive sampling, modified version of my old 'Blurry ray/cone marching' shader.", "tags": ["ray", "marching", "sum"], "likes": 4, "viewed": 568, "date": "1496832947", "time_retrieved": "2024-06-20T18:55:39.179777", "image_code": "//Ethan Alexander Shulman 2017\n\n\n\nfloat ground(vec3 p) {\n    return abs(p.y+10.);\n}\n\nfloat walls(vec3 p) {\n    return length(max(abs(p+vec3(10.,0.,0.))-vec3(10.,10.,1.), 0.));\n}\n\nfloat spheres(vec3 p){\n    return length(abs(p)-8.)-2.;\n}\n\n\n\n#define join(d,c) s.xyz = mix(s.xyz,c,clamp((s.w-d)/s.w,0.,1.)); if (d < s.w) s.w = d;\n\n/*\nvec4 input:\nxyz = position\nw = mipmap level\n\nvec4 output:\nxyz = color\nw = min distance\n*/\nvec4 scene(vec4 p) {\n    //ground\n    vec4 s = vec4(textureLod(iChannel1, p.xz*.05, p.w).xyz, ground(p.xyz));\n    \n    //wall\n    float d = walls(p.xyz);\n    join(d, textureLod(iChannel0, p.xy*.1, p.w).xyz);\n    \n    //spheres\n   \td = spheres(p.xyz);\n    join(d, vec3(0.,0.,1.));\n    \n    \n    return s;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 rp = vec4(0.,2.,20.,1.),\n        rd = vec4(normalize(vec3((fragCoord*2.-iResolution.xy)/iResolution.x,-.5)),0.);\n    \n    float blur = sin(iTime)*.5+.5;\n    if (iMouse.w > 0.) blur = (iMouse.y/iResolution.y)*10.;\n\n    //blur must be non-zero\n    rd.w = blur = max(blur, 1e-2);\n    \n    vec4 c = vec4(0.);\n    float d = 0.;\n    for (int i = 1; i < 64; i++) {\n        if (c.w >= 1.) break;\n        \n        vec4 s = scene(rp+rd*d);\n        s.w = max(s.w, blur);\n        c += vec4(s.xyz,1.)*max(0., 1.-s.w/(d*blur)) / max(1., d*blur);\n        d += mix(s.w, float(i)*.1, min(1.,blur));\n    }\n\t\n    \n    fragColor = vec4(mix(vec3(0.),c.xyz/c.w,min(c.w,1.)),1.);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dSyR3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dXBzj", "name": " Power Packed Alliance 1", "author": "patu", "description": "Used as visuals in cooperation of polish demoscene musicians. \nReleased in wild compo at Decrunch copy party, 3 June 2017\n \nhttp://www.pouet.net/prod.php?which=70247", "tags": ["demoscene", "demo", "wild"], "likes": 13, "viewed": 767, "date": "1496879123", "time_retrieved": "2024-06-20T18:55:40.924701", "image_code": "/*\n\n\tTunnel1\n    for cooperation of polish demoscene musicians, called:\n    \n    \n    \"Power Packed Alliance\".\n    -----------------------------------\n\n\thttps://www.youtube.com/watch?v=_lSReW7eRI4\n    http://www.pouet.net/prod.php?which=70247\n\n\t\n    \n    also check my chrome extension for Shadertoy:\n    https://chrome.google.com/webstore/detail/shadertoy-unofficial-plug/ohicbclhdmkhoabobgppffepcopomhgl?hl=pl\n\n*/\n\n#define getNormal getNormalCube\n\n#define FAR 30.\n#define INFINITY 1e32\n#define t iTime\n#define mt iChannelTime[1]\n#define FOV 60.0\n#define FOG .4\n\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (1.618033988749895)\n\nfloat vol = 0.;\n\n    \nvec3 light = vec3(0.0);\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec4 getFreq(float f){\n\tfloat fft  = texture( iChannel0, vec2(f, 0.25) ).x; \n\tfloat wave = texture( iChannel0, vec2(f, 0.75) ).x;\n\tvec3 col = vec3( fft, 4.0 * fft * (1.0 - fft), 1.0 - fft ) * fft;\n    return vec4(col, 1.0);\n}\n\n// mercury\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nvec3 opU2( vec3 d1, vec3 d2 ) {\n    if (d1.x < d2.x) return d1;\n    return d2;\n}\n\nvec3 opS2( vec3 d1, vec3 d2 )\n{\t\n    if (-d2.x > d1.x) return -d2;\n    return d1;\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n// mercury\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nvec3 map(vec3 p) {\n    \n    vec3 \n        obj = vec3(FAR, -1.0, 0.0),\n        obj2 = obj;\n    \n    vec3 orgP = p;\n    \n    float mat = 0.;\n    \n    pModPolar(p.yx, 7.);\n    \n    obj = vec3(\n        fBox(p, vec3(1.25, 1.25, INFINITY)),\n        3.,\n        0.\n    );\n\n    obj2 = vec3(\n        fBox(p, vec3(1.8, .9, INFINITY)),\n        3.0,\n        0.\n    );\n    \n    obj = opS2(obj, obj2);\n\n    p = orgP;\n    \n    p.z += 8. + t * 4.;\n    \n    obj2 = vec3(\n        fSphere(p, 0.1),\n        6.0,\n        0.0\n    );\n    \n    obj = opU2(obj, obj2);\n\n    p = orgP;\n    \n    pModPolar(p.yx, 3.);\n    \n    pR(p.xz, 0.2);\n    \n    float rx = pModInterval1(p.x, 1.0, -INFINITY, INFINITY);\n    float rz = pModInterval1(p.z, 1.0, -INFINITY, INFINITY);\n    \n    p.y += -.5;\n    p.x += 0.;\n    \n    pR(p.xz, -PI / 4.);\n    \n    obj2 = vec3(\n        fSphere(p, 0.1 + sin(rz + t * 5.) / 20.),\n        ceil(mod(sin(rz) * 10., 2.)),\n        0.\n    );    \n    \n    obj = opU2(obj, obj2);\n    \n    return obj;\n}\n\nfloat t_min = 0.0001;\nfloat t_max = 50.;\nconst int MAX_ITERATIONS = 100;\n\n// enhanced sphere tracing\nvec3 trace(vec3 o, vec3 d) {\n    float omega = 1.2;\n    float t = t_min;\n    float candidate_error = INFINITY;\n    float candidate_t = t_min;\n    float previousRadius = 0.;\n    float stepLength = 0.;\n    float pixelRadius = 0.001;\n    float functionSign = map(o).x < 0. ? -1. : +1.;\n    vec3 mp;\n    \n    for (int i = 0; i < MAX_ITERATIONS; ++i) {\n        mp = map(d * t + o);\n        float signedRadius = functionSign * mp.x;\n        float radius = abs(signedRadius);\n        bool sorFail = omega > 1. &&\n        (radius + previousRadius) < stepLength;\n        if (sorFail) {\n            stepLength -= omega * stepLength;\n            omega = 1.;\n        } else {\n        stepLength = signedRadius * omega;\n        }\n        previousRadius = radius;\n        float error = radius / t;\n        if (!sorFail && error < candidate_error) {\n            candidate_t = t;\n            candidate_error = error;\n        }\n        if (!sorFail && error < pixelRadius || t > t_max) break;\n        t += stepLength;\n   \t}\n    if (\n        (t > t_max || candidate_error > pixelRadius)\n    \t) return vec3(INFINITY, 0., 0.);\n    \n    return vec3(candidate_t, mp.yz);\n}\n\nfloat softShadow(vec3 ro, vec3 lp, float k) {\n    const int maxIterationsShad = 42;\n    vec3 rd = (lp - ro); // Unnormalized direction ray.\n\n    float shade = 1.0;\n    float dist = .1;\n    float end = max(length(rd), 0.001);\n    float stepDist = end / float(maxIterationsShad);\n\n    rd /= end;\n    for (int i = 0; i < maxIterationsShad; i++) {\n        float h = map(ro + rd * dist).x;\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k * h / dist)); \n        dist += min(h, stepDist * 1.); \n        if (h < 0.001 || dist > end) break;\n    }\n    return min(max(shade, 0.2), 1.0);\n}\n\n#define EPSILON .001\nvec3 getNormalHex(vec3 pos)\n{\n\tfloat d=map(pos).x;\n\treturn normalize(\n        vec3(\n            map(\n                pos+vec3(EPSILON,0,0)).x-d,\n                map(pos+vec3(0,EPSILON,0)).x-d,\n                map(pos+vec3(0,0,EPSILON)).x-d \n        \t)\n    \t);\n}\n\n#define delta vec3(.001, 0., 0.)\nvec3 getNormalCube(vec3 pos)   \n{    \n   vec3 n;  \n   n.x = map( pos + delta.xyy ).x - map( pos - delta.xyy ).x;\n   n.y = map( pos + delta.yxy ).x - map( pos - delta.yxy ).x;\n   n.z = map( pos + delta.yyx ).x - map( pos - delta.yyx ).x;\n   \n   return normalize(n);\n}\n\n\nfloat getAO(in vec3 hitp, in vec3 normal)\n{\n    float dist = 0.1;\n    vec3 spos = hitp + normal * dist;\n    float sdist = map(spos).x;\n    return clamp(sdist / dist, 0.7, 1.0);\n}\n\nvec3 getObjectColor(vec3 p, vec3 n, vec2 mat) {\n    vec3 col = vec3(.0);\n    \n    if (mat.x == 0.0) col = vec3(1., 0., 0.);\n    if (mat.x == 1.0) col = vec3(1., 0., 1.);\n    if (mat.x == 2.0) col = vec3(1., 1., 0.);\n    if (mat.x == 3.0) col = vec3(0., 1., 1.);    \n    if (mat.x == 6.0) col = vec3(1., 1., 1.) * 10.;\n    return col ;\n}\n\nvec3 doColor( in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, vec2 mat) {\n\tvec3 ld = lp-sp; // Light direction vector.\n    float lDist = max(length(ld), 0.001); // Light to surface distance.\n    ld /= lDist; // Normalizing the light vector.\n    \n    // Attenuating the light, based on distance.\n    float atten = 1.0 / (1.0 + lDist*0.25 + lDist*lDist*0.05);\n    \n    // Standard diffuse term.\n    float diff = max(dot(sn, ld), 0.);\n    // Standard specualr term.\n    float spec = .1;//pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 8.0);\n    \n    // Coloring the object. You could set it to a single color, to\n    // make things simpler, if you wanted.\n    vec3 objCol = getObjectColor(sp, sn, mat);\n    \n    // Combining the above terms to produce the final scene color.\n    vec3 sceneCol = (objCol*(diff + 0.15) + vec3(1.)*spec*2.) * atten;\n\n    // Return the color. \n    return sceneCol;\n\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec2 uv = fragCoord.xy / iResolution.xy - .5;\n\n    uv *= tan(radians (FOV) / 2.0);\n    \n    vol = texture(iChannel0, vec2(.75, .25)).r  * 4.; \n    \n    float \n        sk = sin(t * 2.3) * 2.0,\n        ck = cos(t * .3) * 1.0,\n        \n        mat = 0.;\n    \n    light = vec3(0., 0., -7.);        \n    \n    vec3 sceneColor = vec3(0.);\n    float vol = getFreq(0.2).r / 4.;\n    vec3 \n        vuv = vec3(sin(t), 1., 0.), // up\n    \tro = vec3(0., 0. + vol, -t * 4.),\n    \tvrp =  vec3(ck, 0., -4. + sk ) + ro,\n    \tvpn = normalize(vrp - ro),\n    \tu = normalize(cross(vuv, vpn)),\n    \tv = cross(vpn, u),\n    \tvcv = (ro + vpn),\n    \tscrCoord = (vcv + uv.x * u * iResolution.x/iResolution.y + uv.y * v),\n    \trd = normalize(scrCoord - ro);\n\n    vec3 lp = light + ro;\n    vec3 tr = trace(ro, rd);    \n    \n    float fog = smoothstep(FAR * FOG, 0., tr.x);\n    ro += rd * tr.x;\n    \n    vec3 sn = getNormal(ro);\t\n    \n    float sh = softShadow(ro, lp, 3.);\n    float ao = getAO(ro, sn);\n    \n    sceneColor += doColor(ro, rd, sn, lp, tr.yz) * 4. + vol * 4.;\n    \n    sceneColor *= fog;\n    sceneColor *= ao;\n    sceneColor *= sh;\n    \n    fragColor = vec4(clamp(sceneColor, 0.0, 1.0), 1.0);\n}\n", "image_inputs": [{"id": "MdsSDH", "previewfilepath": "https://soundcloud.com/decrunch/power-packed-alliance", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/decrunch/power-packed-alliance", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dXBzj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dXfDj", "name": "Added one more cycloid", "author": "Torumu106", "description": "Added one more cycloid.", "tags": ["shader", "cycloid"], "likes": 1, "viewed": 63, "date": "1498029415", "time_retrieved": "2024-06-20T18:55:40.924701", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 r = 2.0 * vec2(uv.x - 0.5, uv.y - 0.5);\n    r.x *= iResolution.x / iResolution.y;\n    vec3 ret = vec3(0.1);\n    vec3 col = vec3(0.8, 0.4, 0.4);\n    for(float i = 0.0; i >= -2.0; i -= 0.1){\n    \tif(length(r - vec2(cos(iTime - i) * 0.8, sin(iTime - i) * 0.8) + vec2(-cos((iTime - i) * 8.0) * 0.1, sin((iTime - i) * 8.0) * 0.1) + vec2(cos((iTime - i) * 32.0) * 0.025, sin((iTime - i) * 32.0) * 0.025)) <= 0.03){\n    \t\tret = col;\n    \t}\n        if(length(r + vec2(cos(iTime - i) * 0.8, sin(iTime - i) * 0.8) + vec2(-cos((iTime - i) * 8.0) * 0.1, sin((iTime - i) * 8.0) * 0.1) + vec2(cos((iTime - i) * 32.0) * 0.025, sin((iTime - i) * 32.0) * 0.025)) <= 0.03){\n    \t\tret = col;\n    \t}\n    }\n    \n\tfragColor = vec4(ret,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dXfDj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4dXfWj", "name": "PiuPiu Raymarching", "author": "villedieumorgan", "description": "Based on those pictures : http://www.movi.pizza/experiments/shaders/sdf/piupiu/pictures/", "tags": ["raymarching", "sdf", "signeddistancefield", "model", "bird"], "likes": 0, "viewed": 119, "date": "1498023026", "time_retrieved": "2024-06-20T18:55:42.046028", "image_code": "#define TOGGLE_NORMAL false\n#define BACKGROUND_COLOR vec4(0.95, 0.59, 0.61, 0.)\n#define MAIN_COLOR vec3(1., 0.88, 0.25)\n#define SECONDARY_COLOR vec3(0.84, 0.43, 0.26)\n#define EYE_BACKGROUND_COLOR vec3(0., 0., 0.)\n#define EYE_PUPIL_COLOR vec3(1., 1., 1.)\n#define PI 3.14159265\n#define SHININESS 0.3\n#define LIGHT_COLOR vec3(0., 0., 0.)\n\n/* \n    Shader made for fun on June 20, 2017 in approximatively 4 hours\n    By Morgan Villedieu Twitter @VilledieuMorgan\n    Using Raymarching and IQ's signed distance field functions to model\n    (http://iquilezles.org/www/articles/distfunctions/distfunctions.htm)\n*/\n\nmat4 RotateX(float phi) {\n  return mat4(\n    vec4(1., 0., 0., 0),\n    vec4(0., cos(phi), -sin(phi), 0.),\n    vec4(0., sin(phi), cos(phi), 0.),\n    vec4(0., 0., 0., 1.));\n}\n\nmat4 RotateY(float theta) {\n  return mat4(\n    vec4(cos(theta), 0., -sin(theta), 0),\n    vec4(0., 1., 0., 0.),\n    vec4(sin(theta), 0., cos(theta), 0.),\n    vec4(0., 0., 0., 1.));\n}\n\nmat4 RotateZ(float psi) {\n  return mat4(\n    vec4(cos(psi), -sin(psi), 0., 0),\n    vec4(sin(psi), cos(psi), 0., 0.),\n    vec4(0., 0., 1., 0.),\n    vec4(0., 0., 0., 1.));\n}\n\nvec2 opU( in vec2 d1, in vec2 d2) {\n\treturn mix(d2,d1,step(d1.x,d2.x));\n}\n\nvec2 sdEllipsoid( in vec3 p, in vec3 r, in int color) {\n  return vec2((length(p / r) - 1.0) * min(min(r.x, r.y), r.z), color);\n}\n\nvec2 sdSphere( in vec3 p, in vec3 def, in int color) {\n  float d = length(p * def) - 1.9;\n  return vec2(d, color);\n}\n\nvec2 sdCylinder(vec3 p, vec2 h, in int color) {\n  vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n  return vec2(min(max(d.x, d.y), 0.0) + length(max(d, 0.0)), color);\n}\n\nvec2 distance_to_obj( in vec3 p) {\n  vec3 feet_offset = vec3(0.45, 0., 0.);\n  float wings_anim = cos(iTime) * 0.07;\n  return opU(\n    opU(\n      opU(\n        opU(\n          opU(\n            sdSphere(p, vec3(0.9, 1., 1.), 1), //HEAD\n            opU(\n              opU(\n                sdSphere(p + vec3(-0.9, -0.25, 0.40), vec3(2.2, 1.9, 1.5), 3), //right black eye\n                sdEllipsoid(p + vec3(-1.19, -.48, 1.37), vec3(0.2, 0.25, 0.2), 4) //right white eye\n              ),\n              opU(\n                sdSphere(p + vec3(0.9, -0.25, 0.40), vec3(2.2, 1.9, 1.5), 3), // left black eye\n                sdEllipsoid(p + vec3(1.19, -.48, 1.37), vec3(0.2, 0.25, 0.2), 4) //leff white eye\n              )\n            )\n          ),\n          sdSphere(p + vec3(0., 2.7, 0.), vec3(1.1, abs(clamp(p.y, 1.8, 1.9)) * 0.8, clamp(exp(-p.z * 0.1), 0.5, 1.)), 1) //BODY\n        ),\n        sdSphere(p + vec3(0., 0.5, 0.3), vec3(1.9, 2.9, 1.), 2) //NOSE LEFT RIGHT\n      ),\n      sdSphere(p + vec3(0., 0.45, 0.32), vec3(2.9, 2.3, 1.), 2) //NOSE TOP BOTTOM\n    ),\n    opU(\n      opU(\n        opU(\n          sdEllipsoid((RotateX(0.2) * vec4(p, 1.)).xyz + vec3(0., -1.65, -0.22), vec3(0.5, 1.8, 0.31), 2), //center antenna yellow\n          sdEllipsoid((RotateX(0.2) * vec4(p, 1.)).xyz + vec3(0., -1.35, -0.22), vec3(0.4, 1.4, 0.71), 1) //center antenna orange\n        ),\n        opU(\n          sdEllipsoid((RotateX(0.1) * RotateY(sin(iTime) * 0.2) * RotateZ(0.4) * vec4(p, 1.)).xyz + vec3(-0.3, -1.45, -0.32), vec3(0.25, 1., 0.51), 1), //left antenna orange\n          sdEllipsoid((RotateX(0.1) * RotateY(sin(iTime) * -0.2) * RotateZ(-0.4) * vec4(p, 1.)).xyz + vec3(0.3, -1.45, -0.32), vec3(0.25, 1., 0.51), 1) //right antenna orange\n        )\n      ),\n      opU(\n        opU(\n          sdEllipsoid((RotateX(0.1) * RotateY(sin(iTime) * 0.2) * RotateZ(0.4) * vec4(p, 1.)).xyz + vec3(-0.2, -1.45, -0.32), vec3(0.4, 1.3, 0.31), 2), //left antenna yellow\n          opU(\n            sdEllipsoid((vec4(p + feet_offset, 1.)).xyz + vec3(0., 4.39, 0.32), vec3(0.2, 0.2, 0.7), 2), //feet finger middle left leg\n            opU(\n              sdEllipsoid((RotateY(-0.3) * vec4(p + feet_offset, 1.)).xyz + vec3(0.1, 4.45, 0.27), vec3(0.2, 0.2, 0.6), 2), //feet finger left\n              sdEllipsoid((RotateY(0.3) * vec4(p + feet_offset, 1.)).xyz + vec3(-0.1, 4.45, 0.27), vec3(0.2, 0.2, 0.6), 2) //feet finger right\n            )\n          )\n        ),\n        opU(\n          opU(\n            sdEllipsoid((RotateX(0.1) * RotateY(sin(iTime) * -0.2) * RotateZ(-0.4) * vec4(p, 1.)).xyz + vec3(0.2, -1.45, -0.32), vec3(0.4, 1.3, 0.31), 2), //right antenna yellow\n            sdCylinder(p + feet_offset + vec3(0., 3.85, -0.12), vec2(0.2, 0.6), 2) //left leg\n          ),\n          opU(\n            opU(\n              sdEllipsoid((vec4(p - feet_offset, 1.)).xyz + vec3(0., 4.39, 0.32), vec3(0.2, 0.2, 0.7), 2), //feet finger middle right leg\n              sdCylinder(p - feet_offset + vec3(0., 3.85, -0.12), vec2(0.2, 0.6), 2) //right leg\n            ),\n            opU(\n              opU(\n                sdEllipsoid((RotateY(-0.3) * vec4(p - feet_offset, 1.)).xyz + vec3(0.1, 4.45, 0.27), vec3(0.2, 0.2, 0.6), 2), //feet finger left\n                opU(\n                  opU(\n                    opU( /* WINGS */\n                      sdEllipsoid((RotateZ(wings_anim) * RotateY(90. + 0.6) * vec4(p, 1.)).xyz + vec3(1.6, 2., 0.), vec3(1.0, 0.4, 0.6), 2),\n                      opU(\n                        sdEllipsoid((RotateZ(-wings_anim) * RotateY(90.5 + 0.6) * vec4(p, 1.)).xyz + vec3(-1.8, 2., 0.5), vec3(1.0, 0.4, 0.6), 2),\n                        sdEllipsoid((RotateZ(-wings_anim) * RotateY(90.3 + 1.) * vec4(p, 1.)).xyz + vec3(-1.6, 2., 0.5), vec3(1.0, 0.4, 0.6), 2)\n                      )\n                    ),\n                    sdEllipsoid((RotateZ(wings_anim) * RotateY(90. + 1.) * vec4(p, 1.)).xyz + vec3(1.6, 2., 1.), vec3(1.0, 0.4, 0.6), 2)\n                  ),\n                  opU(\n                    opU(\n                      opU(\n                        sdEllipsoid((RotateZ(wings_anim) * RotateY(90. + 0.9) * vec4(p, 1.)).xyz + vec3(1.6, 2., 0.5), vec3(1.0, 0.4, 0.6), 2),\n                        opU(\n                          sdEllipsoid((RotateZ(-wings_anim) * RotateY(90.7 + 0.9) * vec4(p, 1.)).xyz + vec3(-1.6, 2., 0.5), vec3(1.0, 0.4, 0.6), 2),\n                          sdEllipsoid((RotateZ(-wings_anim) * RotateY(90.8 + 0.9) * vec4(p, 1.)).xyz + vec3(-1.6, 2., 0.1), vec3(1.0, 0.4, 0.6), 2)\n                        )\n                      ),\n                      sdEllipsoid((RotateZ(wings_anim) * RotateY(0. + 0.9) * vec4(p, 1.)).xyz + vec3(1.6, 2., 0.1), vec3(1.0, 0.4, 0.6), 2)\n                    ),\n                    opU(\n                      sdEllipsoid((RotateZ(wings_anim) * RotateY(90. + 0.5) * vec4(p, 1.)).xyz + vec3(1.6, 2., -0.5), vec3(1.0, 0.4, 0.6), 2),\n                      sdEllipsoid((RotateZ(-wings_anim) * RotateY(-0.9 + 0.5) * vec4(p, 1.)).xyz + vec3(-1.6, 2., -0.5), vec3(1.0, 0.4, 0.6), 2)\n                    )\n                  )\n                )\n              ),\n              sdEllipsoid((RotateY(0.3) * vec4(p - feet_offset, 1.)).xyz + vec3(-0.1, 4.45, 0.27), vec3(0.2, 0.2, 0.6), 2) //feet finger right\n            )\n          )\n        )\n      )\n    )\n  );\n}\n\nvec3 rgba_normalized( in vec3 c) {\n  return c / 255.;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 vPos = fragCoord.xy / iResolution.xy - 0.5;\n\n  // Camera up vector.\n  vec3 vuv = vec3(0, 1, 0);\n\n  // Camera lookat.\n  vec3 vrp = vec3(0, 0, 0);\n\n  float mx = iMouse.x / iResolution.x * PI * 2.0;\n  float my = iMouse.y / iResolution.y * PI / 2.01;\n  vec3 prp = vec3(cos(my) * cos(mx+iTime*0.5), sin(my), cos(my) * sin(mx+iTime*0.5)) * 11.0;\n  //vec3 prp = vec3(0.0);\n\n  // Camera setup.\n  vec3 vpn = normalize(vrp - prp);\n  vec3 u = normalize(cross(vuv, vpn));\n  vec3 v = cross(vpn, u);\n  vec3 vcv = (prp + vpn);\n  vec3 scrCoord = vcv + vPos.x * u * iResolution.x / iResolution.y + vPos.y * v;\n  vec3 scp = normalize(scrCoord - prp);\n\n  // Raymarching.\n  const vec3 e = vec3(0.02, 0, 0);\n  const float maxd = 15.; //Max depth\n  vec2 d = vec2(0.01, 0.0);\n  vec3 c, p, N;\n\n  float f = 1.0;\n  for (int i = 0; i < 45; i++) {\n    if ((abs(d.x) < .01) || (f > maxd))\n      break;\n\n    f += d.x;\n    p = prp + scp * f;\n    d = distance_to_obj(p);\n  }\n\n  //Colors of different parts of the body\n  if (f < maxd) {\n    if (d.y == 2.0)\n      c = MAIN_COLOR; // hair, feet, mouth\n    else if (d.y == 3.) //black\n      c = EYE_BACKGROUND_COLOR;\n    else if (d.y == 4.) //white\n      c = EYE_PUPIL_COLOR;\n    else\n      c = SECONDARY_COLOR; //body color\n\n    //Compute normals\n    vec3 normals = vec3(d.x - distance_to_obj(p - e.xyy).x,\n      d.x - distance_to_obj(p - e.yxy).x,\n      d.x - distance_to_obj(p - e.yyx).x);\n\n    N = normalize(normals);\n\n    //Light & Shading\n    vec3 L = vec3(sin(iTime) * 20., 20., -35.);\n    float b = dot(N, normalize(prp - p + L));\n\n    //Simple phong lighting\n    if (!TOGGLE_NORMAL) {\n      fragColor = vec4(LIGHT_COLOR, 1.);\n      fragColor.rgb += (b * c + pow(b, 16.0) * SHININESS) * (1.0 - f * .01); //simple phong\n      //fragColor=vec4((b*c)*(1.0-f*.01),0.0); lambert shading no specular\n    } else {\n      fragColor = vec4(N, 1.);\n    }\n  } else\n    fragColor = BACKGROUND_COLOR;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4dXfWj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4sfBWf", "name": "Animated Box Rasterizer", "author": "zproxy", "description": "https://www.shadertoy.com/view/MsjSzz", "tags": ["rasterizer"], "likes": 3, "viewed": 71, "date": "1498417238", "time_retrieved": "2024-06-20T18:55:42.912696", "image_code": "#define LINEAR_ROTATION\n\n#define WEIGHT (3.0 / iResolution.x)\nconst vec3 RED = vec3(1.0,0.0,0.0);\nconst vec3 GREEN = vec3(0.0,1.0,0.0);\nconst vec3 BLUE = vec3(0.0,0.8,1.0);\nconst vec3 WHITE = vec3(1.0,1.0,0.97);\nconst vec3 YELLOW = vec3(1.0,1.0,0.0);\n\n// rasterize functions\nfloat line(vec2 p, vec2 p0, vec2 p1, float w) {\n    vec2 d = p1 - p0;\n    float t = clamp(dot(d,p-p0) / dot(d,d), 0.0,1.0);\n    vec2 proj = p0 + d * t;\n    float dist = length(p - proj);\n    dist = 1.0/dist*WEIGHT*w;\n    return min(dist*dist,1.0);\n}\nfloat circle(vec2 p, vec2 c, float r, float w) {\n    float dist = abs(length(p - c)) + r;\n    dist = 1.0/dist*WEIGHT*w;\n    return min(dist*dist,1.0);\n}\n\n// matrices\nmat4 getRotMatrix(vec3 a) {\n    vec3 s = sin(a);\n    vec3 c = cos(a);    \n    mat4 ret;\n    ret[0] = vec4(c.y*c.z,c.y*s.z,-s.y,0.0);\n    ret[1] = vec4(s.x*s.y*c.z-c.x*s.z,s.x*s.y*s.z+c.x*c.z,s.x*c.y,0.0);\n    ret[2] = vec4(c.x*s.y*c.z+s.x*s.z, c.x*s.y*s.z-s.x*c.z,   c.x*c.y,0.0);    \n    ret[3] = vec4(0.0,0.0,0.0,1.0);\n    return ret;\n}\nmat4 getPosMatrix(vec3 p) {   \n    mat4 ret;\n    ret[0] = vec4(1.0,0.0,0.0,p.x);\n    ret[1] = vec4(0.0,1.0,0.0,p.y);\n    ret[2] = vec4(0.0,0.0,1.0,p.z);   \n    ret[3] = vec4(0.0,0.0,0.0,1.0);\n    return ret;\n}\n\n// utils\nvec3 mix3(vec3 a, vec3 b, vec3 c, float t) {\n    if(t>0.5) return mix(b,c,t*2.0-1.0);\n    else return mix(a,b,t*2.0);\n}\nvec3 fragment(vec3 p) {\n    float t = sin(p.x*0.8+iTime*0.5)*0.5+0.5;\n    float fog = min(pow(p.z,3.0)*400.0,1.0);\n    return mix3(RED,GREEN,BLUE,t) * fog;\n}    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    //uv = uv * (1.0 + pow(length(uv)*0.4,0.5)) * 0.6;\n    \n    float line_width = 1.9;\n    float time = iTime * 0.31415;\n    vec3 c = vec3(mix(vec3(0.19,0.13,0.1),vec3(1.0), 0.5*pow(length(uv)*0.5,2.0)));\n    mat4 cam = getPosMatrix(vec3(0.0,0.0,8.0));\n    \n#ifdef LINEAR_ROTATION\n    mat4 rot = getRotMatrix(vec3(time,time*0.86,time*0.473));\n#else\n    float p = 0.08;\n    mat4 rot = getRotMatrix(vec3(time\t\t+sin(time*30.0)*p,\n                                 time*0.860\t+sin(time*20.0)*p*1.24,\n                                 time*0.473\t+sin(time*10.0)*p));\n#endif\n    \n    vec3 instances[18];\n    instances[0] = vec3( 0.0, 0.0,0.0);\n   \n    // box pipeline\n    for(int dip = 0; dip < 1; dip++) {\n        \n        // input assembly\n        // vec3 vert[8];\n        vec3[8 + 4] vert;\n        \n        vert[0] = vec3(-1.0,-1.0, 1.0);\n        vert[1] = vec3(-1.0, 1.0, 1.0);    \n        vert[2] = vec3( 1.0, 1.0, 1.0);    \n        vert[3] = vec3( 1.0,-1.0, 1.0);\n\n        // center\n        vert[8+0] = vec3(-1.0,-1.0,0.0);\n        vert[8+1] = vec3(-1.0, 1.0,0.0);    \n        vert[8+2] = vec3( 1.0, 1.0,0.0);    \n        vert[8+3] = vec3( 1.0,-1.0,0.0);\n\n        \n        vert[4] = vec3(-1.0,-1.0,-1.0);\n        vert[5] = vec3(-1.0, 1.0,-1.0);    \n        vert[6] = vec3( 1.0, 1.0,-1.0);    \n        vert[7] = vec3( 1.0,-1.0,-1.0);\n\n\n        \n        // vertex processing        \n        mat4 pos = getPosMatrix(instances[dip] * 4.0);\n        mat4 mat = pos * rot * cam;\n\n        for(int i = 0; i < 8 + 4; i++) {\n\n            // transform\n            vert[i] = (vec4(vert[i],1.0) * mat).xyz;\n\n            // perspective\n            vert[i].z = 1.0 / vert[i].z;\n            \n            // what does this do? isometric without.\n            vert[i].xy *= vert[i].z;\n        }    \n\n        // primitive assembly and rasterize\n        float i;\n        \n     \n     \n        // upper make. it blink some\n        if (int((iFrame / 30) % 3) == 0)\n        {\n        i += line(uv,vert[4].xy,vert[5].xy,line_width);\n        i += line(uv,vert[5].xy,vert[6].xy,line_width);\n        i += line(uv,vert[6].xy,vert[7].xy,line_width);\n        i += line(uv,vert[7].xy,vert[4].xy,line_width);\n        }\n        \n        \n        else  if (int((iFrame / 30) % 3) == 1)\n        {\n            // https://www.shadertoy.com/view/MsjSzz\n            \n            // verticals\n            // https://www.shadertoy.com/view/XdfBWf\n\n      \n            \n               i += line(uv,vert[8+0].xy,vert[8+1].xy,line_width);\n        i += line(uv,vert[8+1].xy,vert[8+2].xy,line_width);\n        i += line(uv,vert[8+2].xy,vert[8+3].xy,line_width);\n        i += line(uv,vert[8+3].xy,vert[8+0].xy,line_width);\n        \n        }\n        else\n        {\n        i += line(uv,vert[0].xy,vert[1].xy,line_width);\n        i += line(uv,vert[1].xy,vert[2].xy,line_width);\n        i += line(uv,vert[2].xy,vert[3].xy,line_width);\n        i += line(uv,vert[3].xy,vert[0].xy,line_width);\n        \n        }\n        \n          i += line(uv,vert[0].xy,vert[4].xy,line_width);\n        i += line(uv,vert[1].xy,vert[5].xy,line_width);\n        i += line(uv,vert[2].xy,vert[6].xy,line_width);\n        i += line(uv,vert[3].xy,vert[7].xy,line_width);\n    \n        \n        c += fragment(vert[0]) * min(i,1.0);\n    }\n     \n    \n    // fragment\n\tfragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sfBWf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4sfBz8", "name": "Tunnel_Spiral", "author": "balkhan", "description": "Experimenting some more with space partitioning. ", "tags": ["raymarching"], "likes": 12, "viewed": 312, "date": "1497563294", "time_retrieved": "2024-06-20T18:55:42.918652", "image_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\n#define I_MAX\t150\n#define E\t\t0.001\n\n#define L1\tvec3(0., 4.75, 1.-t*4.)\n#define L2\tvec3(0.,-4.75, 1.-t*4.)\n\n#define SPIKES\n#define TRIPPY\n#define ANIM -0.5 // Speed of the animation\n//#define CENTERED\n\nvoid\trotate(inout vec2 v, float angle);\nvec3\tcalcNormal( in vec3 pos, float e, vec3 dir);\nfloat\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvec3\tblackbody(float Temp);\nfloat\tscene(vec3 p);\n\n// --globals-- //\nvec3\ttech;\nvec3\th;\nfloat\tt;\nfloat\tmind;\nfloat\ttess;\nfloat\tst;\nfloat\tct;\nfloat\thit;\nfloat\texp_a;\nfloat\tbass;\nfloat\tmedium;\nfloat\thigh;\n// --globals-- //\n\nconst vec3\tlightCol1 = vec3(.1,.3,.7);\nconst vec3\tlightCol2 = vec3(.5,.3,.2);\n\n// blackbody by aiekick : https://www.shadertoy.com/view/lttXDn\n\n// -------------blackbody----------------- //\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\n\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// -------------blackbody----------------- //\n\n// sebH's volumetric light : https://www.shadertoy.com/view/XlBSRz\n\n// ------------volumetric light----------- //\n\nvec3 evaluateLight(in vec3 pos)\n{\n    float distanceToL = length(L1-pos);\n    float distanceToL2 = length(L2-pos);\n    return (\n        \tlightCol2 * 1.0/(distanceToL*distanceToL)\n           +lightCol1 * 1.0/(distanceToL2*distanceToL2)\n        \t)*.5;\n}\n\n// ------------volumetric light----------- //\n\t\nvoid mainImage(out vec4 o, in vec2 f )\n{\n\tbass = texture(iChannel0, vec2(.1, .015)).x*20.;\n\tmedium = texture(iChannel0, vec2(.5, .015)).x*20.;\n\thigh = texture(iChannel0, vec2(.8, .015)).x*20.;\n\tt = iTime;\n\texp_a = exp(-t*1.+3.);\n\thit = 0.;\n\ttech = vec3(0.);\n\tvec2 R = iResolution.xy,\n          uv  = vec2(f-R/2.) / R.y;\n    h = vec3(0.);\n    \n    vec3\tdir = camera(uv);\n\t#ifndef CENTERED\n    rotate(dir.zy, -.35);\n    vec3\tpos = vec3(.0, 8.+sin(t)*2., 15.0-t*4. );\n    #else\n    vec3\tpos = vec3(.0, .0250, 15.0-t*4. );\n\t#endif\n    float\tinter = (march(pos, dir));\n\n    if (hit == 1.0)\n    {\n    #ifdef TRIPPY\n    vec3\tp = inter*dir + pos;\n\ttech = vec3(cos(3.*length(p-vec3(high, medium, bass)*.5)+1.04), \n              \tcos(3.*length(p-vec3(high, medium, bass)*.5)+2.08), \n              \tcos(3.*length(p-vec3(high, medium, bass)*.5)+3.14) )*.5\n\t        -\n\t        vec3(cos(20.*length(p+vec3(high, medium, bass)*.5)+1.04),\n    \t         cos(20.*length(p+vec3(high, medium, bass)*.5)+2.08),\n        \t     cos(20.*length(p+vec3(high, medium, bass)*.5)+3.14) )*.5\n        ;\n        if (mind == tess)\n            o.xyz+=vec3(cos(20.*length(p)+1.04), cos(20.*length(p)+2.08), cos(20.*length(p)+3.14) )*.75;\n        else\n\t  \t\to.xyz += tech;\n    #endif\n\t    o.xyz += blackbody(length(h)*20000.+(inter*.51)*(100.-min(100.,100.*exp(-t*1.+3.)) ));\n\t    o.xyz *= (1.-length(uv)*1.); // vignette\n    }\n    o.xyz *= .5;\n    o.xyz += h*1.;\n}\n\nfloat\tscene(vec3 p)\n{\n    float\tmine;\n    mind = mine = tess = 1e5;\n    \n    mine = min(mine, length(p-L1)-.1);\n\tmine = min(mine, length(p-L2)-.1);\n\n    p.xy = abs(p.xy)-2.0+2.*sin(p.z*.125+t*.052*ANIM+bass*.025);\n    p *= .5;\n\tp+= vec3(cos(p.z+t*1.*ANIM)*1.,sin(p.z+t*1.*ANIM)*1.,0.);\n    p.xy=abs(p.xy)-.5;\n    p.x += cos(p.z*3.+t*2.*ANIM)*.5;\n    p.y += sin(p.z*3.+t*2.*ANIM)*.5;\n    \n    mine = min(mine, ( -.02+.02*exp_a+1.01002-length( ( cos(p.x)*cos(p.y ) ) ) ) );\n    \n    #ifdef\tSPIKES\n    if(t > 4.)\n    {\n   \t\tfloat\tba;\n    \tba = length(sin(p.xy))*(.251+0.749*exp_a);\n    \tp.z-=t*.5;\n    \ttess = min(tess,\n    \t          ((ba-.075)+length(sin(vec2(p.y, mod(p.z, .125) )) ))\n    \t          );\n        p*=.5;\n    \trotate(p.xy, -p.z*(7.)*3.-t);\n    \ttess = min(tess, length(vec2(abs(p.y)-.1+0.*.0125*cos(p.z*80.+high*20.-t*20.*ANIM),abs(p.x) ))\n    \t           -.006125-0.*.006125*high-.025*clamp( (40.*sin(p.z*80.+t*30.*ANIM)), .25,.75) );\n\t}\n    #endif\n    mind = min(mine, mind);\n    mind = min(mind, tess);\n    return mind;\n}\n\nfloat\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0);\n    vec3\tp = vec3(0.0);\n\n    for (int i = 1; i < I_MAX; ++i)\n    {\n        hit = 0.;\n    \tp = pos + dir * dist.y;\n        dist.x = scene(p);\n        dist.y += dist.x;\n        h += evaluateLight(p)*.25;\n        if (dist.x < E)\n        {\n           hit = 1.;\n           break;\n        }\n    }\n    return (dist.y);\n}\n\n// Utilities\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float   fov = 1.;\n\tvec3    forw  = vec3(0.0, 0.0, -1.0);\n\tvec3    right = vec3(1.0, 0.0, 0.0);\n\tvec3    up    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n", "image_inputs": [{"id": "ldfXzB", "previewfilepath": "https://soundcloud.com/krabe/bad-company-the-pulse", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/krabe/bad-company-the-pulse", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sfBz8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4sfBzj", "name": "Lipschitz Owned in 4 iterations!", "author": "ollj", "description": "fuck yeah i KNEW it would be possible, but i failed to substitute correctly to get to this WAY too long.\nwell, this ray marcher does only 4 iterations to reach the surface!\n\nartifacts are DivBy0 cases, should be easy to catch", "tags": ["lipschitzismybitchshitz"], "likes": 4, "viewed": 478, "date": "1496886860", "time_retrieved": "2024-06-20T18:55:45.343160", "image_code": "//dad: https://www.shadertoy.com/view/4dVGzw\n//but with swiveled parameters:\n//parent has .xyz as Dfdx() Dfdx() Dfdz(), via automatic differentiation\n//this   has .yzw as Dfdx() Dfdx() Dfdz(), via automatic differentiation\n\n//brother: https://www.shadertoy.com/view/XlV3Dy\n//This has a simpler set (no goursat surface)\n//...and instead has derivative arithmetic fields of hg_sdf\n//where hg_sdf dunction return the distance to point [p]\n//THIS returns distance as .x \n//... and 3 first derivatives for 3 domains as .yzw\n//...for the input point [p]\n\n//brother: https://www.shadertoy.com/view/MsXBRB  \n//as this is a process.\n\n// Arithmetic set for automatic differentiation, \n// derivative arithmetic [DA] for\n// https://en.wikipedia.org/wiki/Smoothness\n// of shapes that lack C0-continuity but have C1-continuity.\n// based on    : https://www.shadertoy.com/view/4dVGzw\n// inspired by : https://www.shadertoy.com/view/Mdl3Ws \n//\n//explained at http://blog.demofox.org/2014/12/30/dual-numbers-automatic-differentiation/\n//wiki         https://en.m.wikipedia.org/wiki/Automatic_differentiation\n//summary:     https://www.reddit.com/r/math/comments/68st6p/the_wikipedia_article_on_automatic/\n\n//namespace: All common arithmetic namespaces get a \"*d\" suffix added\n//...that means \"also calculate dirst derivatives for all the domains\",\n//and that increases type float to vec4, and vec3 to mat4 for inOut.\n\n//derivative arithmetic is very useful for fluid dynamics.\n\n//todo, clean up namespaces, find aliases.\n\n//todo, merge with;\n//    https://www.shadertoy.com/view/XdffzB\n//which allows for less domains than 3 domains, \n//...using the same namespaces.\n\n//todo, merge with hg_sdf, full set\n//to have hg_sdf with first derivatives, in 2 or 3 domains.\n//done:\n//fSphere\n//fBox\n//fBoxCheap\n\n\n\n//optionally show superprim\n#define SuperPrim\n\n//if(surfce is convex) rush lets you hit the surface VERY quickly ?\n#define rush\n//rush mode is a bit buggy though.\n\n#ifdef rush\n #define IterRm 4\n//max raymarch iterations|steps\n#else \n #define IterRm 64\n#endif\n\n\n#define IterSh 24\n//softshadow iterations\n\n//the below constant gets overwritten, \n//and htis is wha THIS is all about, it gets overwritten by the right thing!\n//that is == 1./length(dot(raydirection,gradientAtP));\n//==1./length(dot(s.d.yzw,i))\n#define ReciprocalAbsLipschitz .99\n//if(lipschitzConstant>1., distance is overestimated.\n//mzltiplying by ReciprocalAbsLipschitz is a \n//... lazy fix for that is scaling stepDistance*=ReciprocalAbsLipschitz\n//higher precision with a smaller ReciprocalAbsLipschitz AND epsilon=0.\n//meaning, a surface will NEVER really be reached.\n//maybe todo: eps=log(eps*b)*a\n\n//Using f'(x)= f(d)/dx notation for derivates:\n//https://en.wikipedia.org/wiki/Derivative#Notation\n\n//this defines common operations but on a (pseudo) dual number (i,j), defined as:\n//[j] stays \"underived\"\n//[i] calculates the gradient as byproduct\n//[i] becomes Operation(i,FirstDerivateOf(Operation(i,j))\n//[i] is always precise and this way usually calculates faster than using central differences,\n//mostly because a lot of operations have a lot of values cancel each other out, allowing \"shortcuts\".\n//especially canceling out a lot of domainVectors at once, which is nice for vectorHardware.\n//\n//\"pseudo\" dual because [i] has 3 dimensions, and [j] has 1 dimension that modifies on all dimensions of [i], \n//because graphic cards are good with domain operators on vectors.\n//we define dual number (where one part calculates with derivative of the other part and itself)\n//as type vec4(vec3,float)\n//and the 3 dimensions|domains are resolved with [struct DAVec3{}] and [da_domain()]:\nstruct DAVec3{vec4 x;vec4 y;vec4 z;};\nstruct DAVec2{vec3 x;vec3 y;};\nDAVec3 da_domain(vec3 p){return DAVec3(\n vec4(p.x,1.,0.,0.),\n vec4(p.y,0.,1.,0.),\n vec4(p.z,0.,0.,1.));}\nDAVec2 da_domain(vec2 p){return DAVec2(\n vec3(p.x,1.,0.),\n vec3(p.y,0.,1.));}\n//this lets you derive over 3 dimensions at once OR seperately, using very self-similar dual-function variants:\n#define dacon(a) vec4(a,0.,0.,0.)\n#define i1 in float\n#define i4 in vec4\n#define i3 in vec3\nvec4 constd(i1 a){return dacon(a);}\n//as proof of concept, remember the derivates of sin|cos:\n//sin => cos => -sin => -cos => sin =>...\nvec4 sind(i4 a){return vec4(sin(a.x), a.yzw*cos(a.x));}\nvec4 cosd(i4 a){return vec4(cos(a.x),-a.yzw*sin(a.x));}\n//eulers number, exponential functions and natural log:\nvec4 expd(i4 a){float w=exp(a.w);return vec4(a.xyz*w,w);}//exp(a)==pow(e,a)\nvec4 logd(i4 a){return vec4(a.xyz/a.w,log(a.w));}\n\n//#define siq safeinv(q),q);}\nfloat safeinv(i1 a){return (a==0.)?a:1./a;}//reciprocal,1/x but 1./0.=1.; sometimes makes more sense than divBy0!\nvec4 absd (i4 a){return vec4(abs(a.x),a.yzw*sign(a.x));}\nvec4 pow2d(i4 a){return vec4(a.x*a.x,2.*a.x*a.yzw);}\nvec4 sqrtd(i4 a){float q=sqrt(a.x);\n return vec4(q,.5*a.yzw*safeinv(q));}\n\n//derivatives of functions with 2 variables are trickier:\n//because only .w determines breanching of min()|max() (in the nature of dual numbers, only one matters here)\n//optionally, a float parameter can be given as vec4(0,0,0,f):\nvec4 mind(i4 a,i4 b){return(a.x<=b.x)?a:b;}\nvec4 mind(i4 a,i1 b){return(a.x<=b  )?a:constd(b);}\nvec4 mind(i1 a,i4 b){return(a  < b.x)?constd(a):b;}\nvec4 maxd(i4 a,i4 b){return(a.x>=b.x)?a:b;}\nvec4 maxd(i4 a,i1 b){return(a.x>=b  )?a:constd(b);}\nvec4 maxd(i1 a,i4 b){return(a  > b.x)?constd(a):b;}\nmat4 maxd(mat4 a,vec3 p){return mat4(maxd(a[0],p.x),\n                                      maxd(a[1],p.y),\n                                      maxd(a[2],p.z),0,0,0,0);}\nmat4 mind(mat4 a,vec3 p){return mat4(mind(a[0],p.x),\n                                      mind(a[1],p.y),\n                                      mind(a[2],p.z),0,0,0,0);}\nmat4 maxd(mat4 a,float p){return maxd(a,vec3(p));}\nmat4 mind(mat4 a,float p){return mind(a,vec3(p));}\nvec4 maxd(i4 a,i4 b,i4 c){return maxd(maxd(a,b),c);}\nvec4 maxd(mat4 a){return maxd(a[0],a[1],a[2]);}\n//I assume the more general logic here is that all these functions with 2 parameters do:\n/*vec4 r;\n  r.w  = operationOn(a.w,b.w);\n  r.xyz= operationOn(a.xyz , vec3(firstDerivateOf(r.w))); //firstDerivateOf(r.w)==[tricky part]==(3d graphs tangents)\n  return r;*/\n//f(a,b)=mod(a,b) => f'(a,b)=1. , (still disontinuous, not defined for whole multiples of b).\nvec4 modd(i4 a,i4 b){return vec4(mod(a.x,b.x),mod(a.yzw,1.));}\nvec4 modd(i4 a,i1 b){return vec4(mod(a.x,b  ),mod(a.yzw,1.));}\nvec4 modd(i1 a,i4 b){return vec4(mod(a  ,b.x),0,0,0        );}//here \"a.xyz\"==vec3(0)\n//and usually a lot cancels out in substraction/division...\nvec4 subd(i4 a,i4 b){return a-b;}\nvec4 subd(i4 a,i1 b){return vec4(a.x-b  , a.yzw);}\nvec4 subd(i1 a,i4 b){return vec4(a  -b.x,-b.yzw);}\nvec4 addd(i4 a,i4 b){return a+b;}\nvec4 addd(i4 a,i1 b){return subd(a,-b);}//addition as invrse substraction\nvec4 addd(i1 a,i4 b){return subd(a,-b);}\n             \nvec4 muld(i4 a,i4 b){return vec4(a.x*b.x,a.yzw*b.w+a.x*b.yzw);}\nvec4 muld(i4 a,i1 b){return a*b;}\nvec4 muld(i1 a,i4 b){return a*b;}\nvec4 divd(i4 a,i4 b){return vec4(a.x/b.x,(a.yzw*b.x-a.x*b.yzw)/(b.x*b.x));}\nvec4 divd(i4 a,i1 b){return a/b;}\nvec4 divd(i1 a,i4 b){return vec4(a/b.x,(-a*b.yzw)/(b.x*b.x));} \n             \n//some operations cancel out a bit more, to (nearly) tautological|identical identities:\n//<- wooha, a recursive meta-tautology!\n//vec4 da_fract(i4 a){return a;}//derivative of fract(a)=a => tautological.\nvec4 floord(i4 a){return dacon(a.x);}\nvec4 floord(i1 a){return dacon(a);}\n//#define mod(a,b) (a-b*floor(a/b))\n//da_mod.xyz==a.xyz-b.xyz*0==a.xyz\n\n//f(a,b)=dot(g(a),h(b)) => f'(x)              =dot(g'(a)',h(b))+dot(g(a),h(b))\n//                      => d/dx(dot(g(a),h(b))=dot(ga/gx ,h   )+dot(g   ,ha/hx); //similar to \"product rule for scalars\"\n//g(a)=c\n//h(b)=d\n//f(a,b)=dot(c,d) => f'(x)=dot(c',d)+dot(c,d');\n// c and d are type type vec3;\n//f'(x)=dot(0,d)+dot(c,0) == 0+0; ???\n\n\n//todo: derivative of dot() appears tricky: this #define should do:\n//#define dotDer(a,b) min(f(abs(a)),abs(b))*sign(a)*sign(b)\n//vec4 da_dot(i4 a,i4 b){return vec4(a.xyz*dotDer(a,b),dot(a.w,b.w));}           \n//vec4 da_dot(i4 a,i1 b){return vec4(a.xyz*dotDer(a,b),dot(a.w,b  ));}  \n//vec4 da_dot(i1 a,i4 b){return da_dot(b,a);}//is commutative\n             \n//and it gets trickier with functions that take 3 parameters:\nvec4 da_length(i4 x,i4 y){float q=length(vec2(x.x,y.x));\n return vec4(q,(x.yzw*x.x+y.yzw*y.x)*safeinv(q));}\nvec4 da_length(i4 x,i4 y,i4 z){float q=length(vec3(x.x,y.x,z.x));\n return vec4(q,(x.yzw*x.x+y.yzw*y.x+z.yzw*z.x)*safeinv(q));}\nvec4 da_length(mat4 u){return da_length(u[0],u[1],u[2]);}//3*3domain\nvec4 da_length2(mat4 u){return da_length(u[0],u[1]);}//2*3domain\n//the utility of a length() function is clear.\n\n//the utility of da_*().xyz is trickier, just search below to see  what it is ued for:\n\n\n//using the above, we define distance functions that automatically calculate their derivatives\n//this makes surfaces that are C1-discontinuous, like staircases, \n//at least have their (continuous) first rerivate calculated, which is useful for raymarching (?)\n//distance to unit sphere.\nvec4 sdSphere(DAVec3 p){vec4 q=da_length(p.x,p.y,p.z);return subd(q,1.);;}\n//return distance to infinite line segment\nvec4 sdRay(DAVec3 p){\n float ass=p.x.w;\n p.x.w=mix(0.,p.x.w,step(p.x.w,0.));\n vec4 q=da_length(p.x,p.y,p.z);\n q=subd(q,1.);\n return q;}\n\nvec4 subdabsd(vec4 p,float s){return subd(absd(p),s);}\nmat4 subdabsd(DAVec3 p,vec3 s){\n return mat4(subdabsd(p.x,s.x),\n             subdabsd(p.y,s.y),\n             subdabsd(p.z,s.z),0,0,0,0);}\n\n/*\nfloat fBoxCheap(vec3 p,vec3 b){\n vec3 q=abs(p);q=q-p;//mirror clamp\n return max(max(q.x,q.y),q.z);}\n*///hg_sdf\n//return distance to box size (s)\nvec4 sdBoxCheap(DAVec3 p,vec3 s){\n //vec3 s=vec3(1.5,.5,1.5);\n vec4 x,y,z,d,e,f,q,a,b,c;\n x=vec4(0);y=vec4(0);z=vec4(0);d=vec4(0);\n e=vec4(0);f=vec4(0);q=vec4(0);\n a=vec4(0);b=vec4(0);c=vec4(0);\n mat4 u=subdabsd(p,s);//mirror clamp\n return maxd(u);}\n/*\nfloat fBox(vec3 p,vec3 s){\nvec3 d=abs(p)-s;//mirror clamp\nfloat a=length(max(d,0.));//rounded corners\nvec3 q=min(d,0.);//clamp\nfloat b=max(max(q.x,q.y),q.z);//keep largest of 3\nreturn a+b;}//add\n*///hg_sdf\nvec4 sdBox(DAVec3 p){\n vec3 s=vec3(1.5,.5,1.5);\n mat4 d=subdabsd(p,s);//mirror clamp\n vec4 a=da_length(maxd(d,0.));//rounded corners\n mat4 q=mind(d,0.);//clamp\n vec4 b=maxd(q);//keep largest of 3\n return addd(a,b);}//add\n             \n//a more readable version of the above, like, seriously WTF MAN!\n//how about one operation per line man, keep it BASIC!\nvec4 sdSuperprim(DAVec3 p, i4 s,vec2 r) {\n //vec2 r=vec2(.2,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n vec4 dx,dy,dz,d,e,f,q,a,b,c;\n dx=vec4(0);dy=vec4(0);dz=vec4(0);d=vec4(0);\n e=vec4(0);f=vec4(0);q=vec4(0);\n a=vec4(0);b=vec4(0);c=vec4(0);\n dx=absd(p.x);\n dx=subd(dx,s.x);\n dy=absd(p.y);\n dy=subd(dy,s.y);\n dz=absd(p.z);\n dz=subd(dz,s.z);\n \n d=addd(dx,r.x);\n d=maxd(d,0.);\n e=addd(dy,r.x);\n e=maxd(e,0.);\n q=da_length(d,e);\n f=maxd(dx,dy);\n f=mind(-r.x,f);\n \n q=addd(q,f);\n q=addd(q,s.w);\n q=absd(q);\n q=subd(q,s.w);\n ///return...\n a=addd(q ,r.y);\n a=maxd(a,0.);    \n b=addd(dz,r.y);\n b=maxd(b,0.);\n a=da_length(a,b);\n c=mind(-r.y,maxd(q,dz));\n c=addd(a,c);\n return c;\n}\n\n// example parameters\n#define SHAPE_COUNT 10.0\nvoid getfactor (int i, out vec4 s,out vec2 r) {\n    //i = 8;\n    if (i == 0) { // cube\n        s = vec4(1.0);\n        r = vec2(0.0);\n    } else if (i == 1) { // corridor\n        s = vec4(vec3(1.0),0.25);\n        r = vec2(0.0);\n    } else if (i == 2) { // pipe\n        s = vec4(vec3(1.0),0.25);\n        r = vec2(1.0,0.0);\n    } else if (i == 3) { // cylinder\n        s = vec4(1.0);\n        r = vec2(1.0,0.0);\n\t} else if (i == 4) { // pill\n        s = vec4(1.0,1.0,2.0,1.0);\n        r = vec2(1.0);\n    } else if (i == 5) { // sphere\n        s = vec4(1.0);\n        r = vec2(1.0);\n    } else if (i == 6) { // pellet\n        s = vec4(1.0,1.0,0.25,1.0);\n        r = vec2(1.0,0.25);\n    } else if (i == 7) { // torus\n        s = vec4(1.0,1.0,0.25,0.25);\n        r = vec2(1.0,0.25);\n    } else if (i == 8) { // sausage mouth\n        s = vec4(2.0,0.5,0.25,0.25);\n        r = vec2(0.5,0.25);\n    } else if (i == 9) { // beveled O\n        s = vec4(0.7,1.0,1.0,0.25);\n        r = vec2(0.125);\n\t}\n}\n\n//set camera position & target\nvoid setCam(out vec3 o,out vec3 i,i1 t,i1 m){\n o=vec3(4.*sin(t),m*9.-2.,4.*cos(t));i=vec3(0);}\n\nstruct DAMValue{vec4 d;float m;};\nDAMValue min2(DAMValue a, DAMValue b){if(a.d.x>b.d.x)return b;return a;}\nDAMValue plane(DAVec3 p){return DAMValue(addd(p.y,1.),1.);}\n//DAMValue add_plane(DAVec3 p,DAMValue m){return min2(plane(p),m);}\n\n#define ss01(a) smoothstep(0.,1.,a) \n#define imsc(a) int(mod(a,SHAPE_COUNT))\n//return distance to surface of DistanceField\nDAMValue df(DAVec3 p){vec4 r;\n#ifndef SuperPrim\n //r=sdGoursat(p);\n r=sdBox(p);\n //r=da_max(-sdTangle(p),sdSphere(p));\n //r=sdGoursat(p)*.7+sdSphere(p)*.3;\n //r=mix(sdGoursat(p),sdSphere(p),sin(iTime*.61)*.5+.5);\n#else\n float t=iTime,u=ss01(ss01(fract(t)));\n vec4 a,b;vec2 c,d;\n getfactor(imsc(t   ),a,c);\n getfactor(imsc(t+1.),b,d);\n DAVec3 q=DAVec3(p.y,p.z,p.x);\n if(iMouse.z>.5){\n  vec2 m=iMouse.xy/iResolution.xy;\n  r=sdSuperprim(q,vec4(vec3(1.0),mix(a.x,b.x,u)),m);\n }else\n  r=sdSuperprim(q,mix(a,b,u),mix(c,d,u));\n#endif\n //return DAMValue(r,0.);\n return min2(plane(p),DAMValue(r,0.));}\n\n//return distance & materialID\nvec2 dm(i3 p){DAMValue d=df(da_domain(p));\n return vec2(d.d.x,d.m);}\n//return material at p with normal n\nvec4 material(i3 p,i3 n ){vec4 d=df(da_domain(vec3(p.x,0.,p.z))).d;\n return mix(vec4(n*.5+.5,.1)\n           ,vec4(d.yzw*.5 +.5,.0)*abs(mod(d.x,.1)/.1-.5)\n           ,clamp(dm(p).y,0.,1.));}\n\n//return soft shadow\nfloat shadow(i3 o,i3 i){\n const float a=32.;//shadow hardnes\n float r=1.,h =1.,t=.0005;//t=(self)intersection avoidance distance\n for(int j=0;j<IterSh;j++){\n  h=dm(o+i*t).x;\n  r=min(r,h*a/t);\n  t+=clamp(h,.02,2.);}//limit max and min stepping distances\n return clamp(r,0.,1.);}\n\n//return p, modified by light , shadow, envMap...\nvec3 light(i3 p,i3 n,i3 i,i1 d,i4 m){\n vec3 l=normalize(vec3(1.,.7,.9));//light direction\n float o=max(0.,dot(n,l)),\n c=max(0.,dot(n,normalize(l-i))),\n s;if(c>.01)s=shadow(p+.01*n,l); \n const vec3 LigCol=vec3(1.);//light color\n vec3 r=m.rgb*(LigCol+o*vec3(.8,.7,.6)*s*3.+vec3(.2,.3,.3));  \n r+=s*c*pow(o,40.);//specular\n //r+=m.w*texture(iChannel0, reflect(i,n)).rgb;//envmap\n r*=exp(-.01*d*d);//fog  \n return r;}\n\n//return distance along ray (raymarch till surface)\nfloat rm(i3 o,i3 i){\n const float m=20.;//distance.Max\n float e=.0,h=e,t=0.;//intersection.precission\n for(int j=0;j<IterRm;j++){\n  if(h<e)break;if(t>m)return -1.;\n          //wait a moment, do i not have the lipschitz for the point\n     //or at least 3 for 3 domains of the point\n     //by using [DA]?\n     //i mean, i could really insert this here, right?\n     //and substitute ReciprocalAbsLipschitz with \"1/da_length(dm(o+i*t).yzw)\"\n  //i am pretty sure that i am missing a dotproduct here\n  //the gradient must be dorproducted onto the ray direction?\n  DAMValue s=df(da_domain(o+i*t));\n  float r=ReciprocalAbsLipschitz;\n  #ifndef rush\n  r=1./max(1.,length(dot(s.d.yzw,i)));//overwriting with a VERY LOCAL lipschitz constant\n     //its not a good estimate, but it is a LOT better?\n  #else\n  r=1./   (   length(dot(s.d.yzw,i)));//overwriting with a VERY LOCAL lipschitz constant\n  \n  #endif\n  h=s.d.x*r;t+=h;}return t;}\n\n//return surface normal\nvec3 getN(in vec3 p){DAMValue d=df(da_domain(p));\n return d.d.yzw;}\n//.xyz store the first derivatives on the 3 domains, \n//this is equivalent to the gradient at p\n//if (p is near a surface) the gradient is a surface normal\n//d.d.* addresses a vec4. where *.xyz==gradient\n//d.m.* addresses a material\n             \n//return camera matrix\nmat3 calcLookAtMatrix(in vec3 o,in vec3 i,in float r ){\n vec3 w=normalize(i-o);vec3 u=normalize(cross(w,vec3(sin(r),cos(r),0.)) );\n return mat3(u,normalize(cross(u,w)),w);}\n\n//return color corrected r\nvec3 ff_filmic_gamma3(vec3 r){vec3 x=max(vec3(0),r-.004);\n return (x*(x*6.2+.5))/(x*(x*6.2+1.7)+.06);}\n\nvoid mainImage( out vec4 r,in vec2 fragCoord ){\n vec2 p=(-iResolution.xy+2.*fragCoord.xy)/iResolution.y,\n m=iMouse.xy/iResolution.xy;  //mouse\n vec3 o,i;\n setCam(o,i,iTime,m.y+.2);//camMovement\n const float roll=0.,lens=2.;//camRoll,CamLensLength\n vec3 d=normalize(calcLookAtMatrix(o,i,roll)*vec3(p.xy,lens));//ray.direction\n vec3 c=vec3(0);\n float t=rm(o,d);//Distance.raymarched\n if(t>-.5){\n  vec3 p=o+t*d,n=getN(p); //position & normal\n  vec4 m=material(p,n);   //material\n  c=light(p,n,d,t,m);}    //light\n c=ff_filmic_gamma3(c*.6);//gamma\n //c=pow( clamp(col,0.0,1.0), vec3(0.4545) );\n r=vec4(c,1.);}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sfBzj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4sffRl", "name": "bump mapping", "author": "adambene", "description": "Bump mapping with directional and omnidirectional lighting.\nDirectional light comes in blue from the top left.\nClick anywhere to move the yellow omni light.", "tags": ["bump", "bumpmapping"], "likes": 14, "viewed": 387, "date": "1497391350", "time_retrieved": "2024-06-20T18:55:45.343160", "image_code": "#define PI 3.141592654\n#define t iTime\n#define light_height_dir 2.\n#define light_height_omni 1.5\n#define ambient .4\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    float p = 1. / iResolution.x,\n          c = length(texture(iChannel0, uv).rgb),\n         cu = length(texture(iChannel0, uv + vec2(0, p)).rgb),\n         cr = length(texture(iChannel0, uv + vec2(p, 0)).rgb);\n    \n    vec3 n = normalize(cross(vec3(0, p, cu - c), vec3(p, 0, cr - c))),\n         l_dir = - normalize(vec3(\n             sin(-PI/4.),\n             cos(-PI/4.),\n             light_height_dir\n         )),\n    \t l_omni = vec3(\n             .5 + .5 * sin(t + PI),\n             .5 + .5 * cos(t + PI),\n             light_height_omni\n         );\n\n    if (iMouse.w > .5) {\n        // l_dir  = - normalize(vec3(vec2(.5, .5) - iMouse.xy / iResolution.xy, light_height_dir));\n        l_omni = vec3(iMouse.xy / iResolution.xy, light_height_omni);\n    }\n    \n    vec3 d = vec3(uv, 0) - l_omni;\n\n    // diffuse + ambient lights\n    vec4 color = 1. * vec4(.3, .3, 1., 0.) * dot(n, l_dir) + ambient\n               + 2. * vec4(1., 1., .3, 0.) * dot(n, normalize(d)) / (dot(d, d));\n    \n    if (length(uv-l_omni.xy) < .02) {\n    \tfragColor = vec4(1., 1., .3, 0.);\n        return;\n    }\n\t\n    fragColor = color * texture(iChannel1, uv);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sffRl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4slBRl", "name": "Simple shadows", "author": "phuidn", "description": "a basic implementation of shadows in diffuse lighting, plenty of room for improvement", "tags": ["raymarch", "shadow"], "likes": 3, "viewed": 109, "date": "1497546479", "time_retrieved": "2024-06-20T18:55:46.312857", "image_code": "#define EPS (0.0005)\n#define TAU (6.2832)\n\n// SDF for a sphere\nfloat sphereSDF(vec3 point, vec3 centre, float radius)\n{\n \treturn (length(centre - point) - radius);   \n}\n\n// SDF for a cube\nfloat cubeSDF(vec3 point, vec3 centre, float side_length)\n{\n    point -= centre;\n    float half_side = side_length * 0.5;\n    \n \treturn max(max(abs(point.x) - half_side, abs(point.y) - half_side),\n               abs(point.z) - half_side);\n}\n\n// a sphere with cubes rotating around it\nfloat sceneSDF(vec3 point)\n{\n    float dist,\n          phi = atan(point.y, point.x),\n          r = sqrt(point.x * point.x + point.y * point.y),\n          omega = TAU / 8.0;\n    \n    phi = mod(phi + omega * iTime,radians(15.0)) - 0.5 * radians(15.0);\n    float r_x = r * cos(phi),\n    \t  r_y = r * sin(phi);\n\n    dist = sphereSDF(point, vec3(0,0,0), 1.0);\n    dist = min(dist, cubeSDF(vec3(r_x, r_y, point.z), \n                             1.3 * vec3(1.0, 0.0, 0.0), \n                             0.2));\n         \n    \n    return dist;\n}\n\n//checks whether there is an uninterrupted line between a point on the surface and\n//another point (the light source in this instance)\nbool clearLine(vec3 surface_point, vec3 point2)\n{\n \tvec3 dir = normalize(surface_point - point2);\n    \n    float dist_to_point = length(surface_point - point2),\n          dist;\n    \n    const int max_its = 200;\n    \n    for (int i = 0; i < max_its; i++)\n    {\n    \tdist = sceneSDF(point2);\n        \n        if (dist_to_point - dist < EPS)\n        {\n            return true;\n        }\n        \n        if (dist < 0.0)\n        {\n         \treturn false;   \n        }\n        \n        point2 += dir * dist;\n        dist_to_point -= dist;\n    }\n    \n    return false;\n}\n\n//basic diffuse reflection from the phong reflection model\nvec3 diffuseReflection(vec3 k_d, vec3 surface_point, vec3 surface_normal,\n                        vec3 light_pos, vec3 light_col)\n{\n    float intensity = max( dot(surface_normal, normalize(light_pos - surface_point)), 0.0);\n    \n    return k_d * light_col * intensity;   \n}\n\n//adds an ambient term everywhere, and diffuse reflection everywhere where there is a\n//clear path to the light source\nvec3 calculateLighting(vec3 surface_point, vec3 surface_normal, vec3 light_pos)\n{\n \tvec3 col;\n    \n    if (clearLine(surface_point, light_pos))\n    {\n    \tcol = diffuseReflection(vec3(1.0,1.0,0.85), surface_point, surface_normal, light_pos, vec3(1.0,1.0,1.0));\n    }\n\n    return col + vec3(0.0,0.0,0.075);\n}\n\n//estimate the normal of a point (on the surface of the scene geometry)\nvec3 normalEstimate(vec3 point)\n{\n    vec3 dx = vec3(EPS, 0, 0),\n         dy = vec3(0, EPS, 0),\n         dz = vec3(0, 0, EPS);\n    \n \treturn normalize(vec3(sceneSDF(point + dx) - sceneSDF(point - dx),\n                          sceneSDF(point + dy) - sceneSDF(point - dy),\n                          sceneSDF(point + dz) - sceneSDF(point - dz)));\n}\n\n\n//a matrix which transforms from camera space to world space\nmat4 transformMat(vec3 position, vec3 lookAt, vec3 up)\n{\n    vec3 z_c = -normalize(lookAt - position),\n         x_c = normalize(cross(up, z_c)),\n         y_c = normalize(cross(z_c, x_c));\n    \n    return mat4( vec4(x_c, 0),\n                 vec4(y_c, 0),\n                 vec4(z_c, 0),\n                 vec4(position, 1) );\n}\n\n//calculate the raytracing path for this pixel in camera space\nvec3 pathVector(float fov_angle, vec2 px_coord, vec3 resolution)\n{\n \tvec2 xy = (px_coord - 0.5 * resolution.xy);\n    float z = -resolution.x / (2.0 * tan(radians(fov_angle) * 0.5));\n\t\n    return normalize(vec3(xy, z));\n}\n\n//calculate the closest distance from the camera to the geometry, for the current pixel\nfloat closestDistance(vec3 camera, vec3 rayVec, float minDist, float maxDist)\n{\n \tfloat dist,\n          totDist = minDist;\n    \n    const int max_its = 300;\n    \n    for (int i = 0; i < max_its; i++)\n    {\n    \tdist = sceneSDF(camera + totDist * rayVec);\n        totDist += dist;\n        \n        if (totDist > maxDist)\n        {\n         \treturn maxDist;   \n        }\n        if (dist < EPS)\n        {\n         \treturn totDist;   \n        }\n    }\n    \n    return maxDist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float camera_rad = 5.0,\t\n          x = camera_rad * cos (TAU * iTime * 0.05),\n          z = camera_rad * sin (TAU * iTime * 0.05),\n          y = 3.0;\n    \n\tvec3 camera_pos =  vec3(x,y,z);\n    vec3 initial_path = pathVector(60.0, fragCoord, iResolution);\n    mat4 camera_to_world = transformMat(camera_pos, vec3(0), vec3(0,1,0));\n    \n    float minDist = 0.1,\n  \t\t  maxDist = 10.0;\n    \n    initial_path = (camera_to_world * vec4(initial_path,0)).xyz;\n    \n    float dist = closestDistance(camera_pos, initial_path, minDist, maxDist);\n    \n    if (dist > maxDist - EPS)\n    {\n     \tfragColor = vec4(0,0,0,0);   \n        return;\n    }\n    \n    vec3 scene_point = camera_pos + dist * initial_path;\n    \n    vec3 surface_normal = normalEstimate(scene_point);\n    vec3 colour = calculateLighting(scene_point, surface_normal, \n                                    vec3(camera_pos.x*0.1, 3.0, camera_pos.z*0.1));\n    \n    fragColor = vec4(colour,0);\n    //fragColor = vec4(0.5 * (normalEstimate(scene_point) + 1.0), 1.0);\n    \n\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4slBRl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4slBWl", "name": "Vinyl Suface", "author": "c0de4", "description": "", "tags": ["2d", "vinyl", "suface"], "likes": 14, "viewed": 213, "date": "1498820778", "time_retrieved": "2024-06-20T18:55:46.646325", "image_code": "// thanks to: https://wgld.org/\n\n#define time iTime\n#define mouse iMouse\n#define resolution iResolution\n\nfloat random (in vec2 st) { \n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233))) \n                * 43758.5453123);\n}\n\n// The MIT License\n// Copyright  2013 Inigo Quilez\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n    \n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( random( i + vec2(0.0,0.0) ), \n                     random( i + vec2(1.0,0.0) ), u.x),\n                mix( random( i + vec2(0.0,1.0) ), \n                     random( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n  vec2 p = ( fragCoord.xy * 2.0 - resolution.xy ) / min(resolution.x, resolution.y);\n\n  float color = 0.0;\n  \n  for(float i = 0.; i < 4.; i++) {\n    float j = i + 1.0;\n    p += vec2(noise(p+j)-cos(time*.5)+noise(vec2(time))*.1, noise(p*j)-sin(time*j) * .01 );\n    vec2 q = vec2(noise(vec2(p+j)) );\n    float a = length(p-q);\n    color += .02/length(p-a);\n  }\n\n  fragColor = vec4( vec3( color ), 1.0 );\n\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4slBWl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4slfWl", "name": "Smoothed Voronoi Tunnel", "author": "dr2", "description": "No more Voronoi corners (use the mouse)", "tags": ["voronoi", "tunnel", "raymarch", "hexagon", "smoothing"], "likes": 14, "viewed": 628, "date": "1498816761", "time_retrieved": "2024-06-20T18:55:48.088914", "image_code": "// \"Smoothed Voronoi Tunnel\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Smoothed hexagonal-lattice-based Voronoi partitioning.\n\nfloat PrCylDf (vec3 p, float r, float h);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\nfloat SmoothMin (float a, float b, float r);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\n\nvec3 ltDir;\nvec2 gVec[7], hVec[7];\nfloat dstFar, tCur, wdTun, htTun, lmpSep;\nint idObj;\nconst int idWal = 1, idCeil = 2, idFlr = 3, idLmp = 4;\nconst float pi = 3.14159;\n\nfloat TrackPath (float t)\n{\n  return wdTun * (0.7 * sin (0.005 * 2. * pi * t) + 0.4 * cos (0.009 * 2. * pi * t));\n}\n\n#define SQRT3 1.73205\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./SQRT3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (SQRT3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvoid HexVorInit ()\n{\n  vec3 e = vec3 (1., 0., -1.);\n  gVec[0] = e.yy;\n  gVec[1] = e.xy;\n  gVec[2] = e.yx;\n  gVec[3] = e.xz;\n  gVec[4] = e.zy;\n  gVec[5] = e.yz;\n  gVec[6] = e.zx;\n  for (int k = 0; k < 7; k ++) hVec[k] = HexToPix (gVec[k]);\n}\n\nvec4 HexVor (vec2 p)\n{\n  vec4 sd, udm;\n  vec2 ip, fp, d, u;\n  float amp, a;\n  amp = 0.7;\n  ip = PixToHex (p);\n  fp = p - HexToPix (ip);\n  sd = vec4 (4.);\n  udm = vec4 (4.);\n  for (int k = 0; k < 7; k ++) {\n    u = Hashv2v2 (ip + gVec[k]);\n    a = 2. * pi * (u.y - 0.5);\n    d = hVec[k] + amp * (0.4 + 0.6 * u.x) * vec2 (cos (a), sin (a)) - fp;\n    sd.w = dot (d, d);\n    if (sd.w < sd.x) {\n      sd = sd.wxyw;\n      udm = vec4 (d, u);\n    } else sd = (sd.w < sd.y) ? sd.xwyw : ((sd.w < sd.z) ? sd.xyww : sd);\n  }\n  sd.xyz = sqrt (sd.xyz);\n  return vec4 (SmoothMin (sd.y, sd.z, 0.3) - sd.x, udm.xy, Hashfv2 (udm.zw));\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec4 vc;\n  vec3 q;\n  float dMin, d, db;\n  dMin = dstFar;\n  p.x -= TrackPath (p.z);\n  q = p;\n  q.y -= htTun;\n  d = wdTun - abs (q.x);\n  if (d < dMin) { dMin = d;  idObj = idWal; }\n  vc = HexVor (q.zx);\n  d = q.y + htTun - 0.05 * smoothstep (0.05 + 0.03 * vc.w, 0.14 + 0.03 * vc.w, vc.x);\n  if (d < dMin) { dMin = d;  idObj = idFlr; }\n  q.y -= htTun;\n  d = max (wdTun - length (q.xy), - q.y);\n  if (d < dMin) { dMin = d;  idObj = idCeil; }\n  q.z = mod (q.z + lmpSep, 2. * lmpSep) - lmpSep;\n  q.y -= 0.5 * wdTun;\n  d = PrCylDf (q.xzy, 0.1 * wdTun, 0.01 * wdTun);\n  q.y -= 0.25 * wdTun;\n  d = min (d, PrCylDf (q.xzy, 0.005 * wdTun, 0.25 * wdTun));\n  q.y -= 0.25 * wdTun;\n  d = min (d, PrCylDf (q.xzy, 0.05 * wdTun, 0.02 * wdTun));\n  q.y -= - wdTun - htTun;\n  if (d < dMin) { dMin = d;  idObj = idLmp; }\n  return 0.8 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 250; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 vc;\n  vec3 vn, col, q;\n  float dstObj, bh, s, spec, att;\n  HexVorInit ();\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += rd * dstObj;\n    q = ro;\n    q.x -= TrackPath (q.z);\n    vn = ObjNf (ro);\n    spec = 0.1;\n    if (idObj == idWal) {\n      vc = HexVor (5. * q.zy);\n      col = HsvToRgb (vec3 (0.6 + 0.1 * vc.w, 1., 1.)) * (0.3 + 0.7 *\n         smoothstep (0.05, 0.06 + 0.03 * vc.w, vc.x));\n    } else if (idObj == idCeil) {\n      q.x = wdTun * atan (q.x, q.y - 2. * htTun);\n      vc = HexVor (2. * q.zx);\n      col = HsvToRgb (vec3 (0.4 + 0.1 * vc.w, 1., 1.)) * (0.3 + 0.7 *\n         smoothstep (0.05, 0.06 + 0.03 * vc.w, vc.x));\n      spec = 0.05;\n    } else if (idObj == idFlr) {\n      vc = HexVor (q.zx);\n      col = mix (vec3 (0.2), HsvToRgb (vec3 (vc.w, 1., 1.)),\n         step (0.06 + 0.03 * vc.w, vc.x)) * (1. - 0.1 * Noisefv2 (150. * q.xz));\n      q.z = mod (q.z + lmpSep, 2. * lmpSep) - lmpSep;\n      col *= 1. - 0.3 * smoothstep (0.4, 0.85, length (q.xz) / wdTun);\n      spec = 0.3;\n      vn = VaryNf (100. * q, vn, 1.);\n    } else if (idObj == idLmp) {\n      if (q.y < htTun + wdTun) {\n        col = vec3 (1., 1., 0.7) * 0.5 * (1. - vn.y);\n        spec = -1.;\n      } else col = vec3 (0.6, 0.4, 0.1);\n    }\n    if (spec >= 0.) col = col * (0.2 + 0.8 * max (dot (vn, ltDir), 0.) +\n       spec * pow (max (dot (normalize (ltDir - rd), vn), 0.), 64.));\n    att = min (600. / pow (dstObj, 1.5), 1.);\n    col *= att;\n  } else col = vec3 (0.01, 0.01, 0.05);\n  return pow (clamp (col, 0., 1.), vec3 (0.7));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  wdTun = 8.;\n  htTun = 4.;\n  lmpSep = 10.;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    el = clamp (el + pi * mPtr.y, -0.4 * pi, 0.4 * pi);\n    az = az + 2.5 * pi * mPtr.x;\n  }\n  dstFar = 300.;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  rd = vuMat * normalize (vec3 (uv, 3.));\n  ro.z = 10. * tCur;\n  ro.x = TrackPath (ro.z);\n  rd.zx = Rot2D (rd.zx, 0.1 * atan (ro.x));\n  ro.y = 1.5 * htTun;\n  ltDir = vuMat * normalize (vec3 (0., 0.2, -1.));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, cHashA3.xy)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  const vec2 cHashVA2 = vec2 (37.1, 61.7);\n  const vec2 e = vec2 (1., 0.);\n  return fract (sin (vec2 (dot (p + e.yy, cHashVA2),\n     dot (p + e.xy, cHashVA2))) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n)) * (1. / 1.9375);\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  float s;\n  const vec3 e = vec3 (0.1, 0., 0.);\n  s = Fbmn (p, n);\n  g = vec3 (Fbmn (p + e.xyy, n) - s, Fbmn (p + e.yxy, n) - s,\n     Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4slfWl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4slfzf", "name": "spiral over time", "author": "hufo", "description": "for HardlyDifficult", "tags": ["spiralanimation"], "likes": 2, "viewed": 69, "date": "1497306038", "time_retrieved": "2024-06-20T18:55:48.313159", "image_code": "#define M_PI 3.1415926535897932384626433832795\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // input coordinates within [-1 1]\n\tvec2 uv = 2.0*fragCoord.xy / iResolution.xy - vec2(1.0,1.0);\n    \n    // input time from 0 to 1\n    float progress = fract(iTime*0.1);\n    \n    // intermediate variables\n    float angleFrac = (atan(uv.y, uv.x)/(2.0*M_PI)+0.5);\n    float norm = sqrt(dot(uv,uv));\n    \n    // simple progression\n    //float activationTime = norm;\n    \n    // step progression\n    //float activationTime = 0.1*floor(10.0*norm);\n    \n    // bad spiral\n    //float activationTime = 0.1*(angleFrac+floor(10.0*norm));\n    \n    // good spiral\n    //float activationTime = 0.1*(angleFrac+floor(10.0*norm-angleFrac));\n    \n    // removing sharp corner\n    float x = 10.0*norm-angleFrac;\n    float activationTime = 0.1*(angleFrac+floor(x)+fract(x)*0.2);\n    \n    if (activationTime <= progress)\n\t  fragColor = vec4(1.0,1.0,1.0,1.0);\n    else\n\t  fragColor = vec4(angleFrac,0.0,0.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4slfzf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4ssBR2", "name": "MadWall", "author": "c0de4", "description": "ABAREKABE.", "tags": ["raymarching"], "likes": 3, "viewed": 101, "date": "1497022145", "time_retrieved": "2024-06-20T18:55:48.319239", "image_code": "\n\n// thanks to: @h_doxas https://wgld.org/\n//\n// rotate, twist, smoothMin, distance func, ray marching\n\n\n// thanks to: Inigo Quilez http://www.iquilezles.org/\n// \n// noise\n\n// wrote: @c0de4 \n\nvec3 hsv(float h, float s, float v){\n  vec4 t = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(vec3(h) + t.xyz) * 6.0 - vec3(t.w));\n  return v * mix(vec3(t.x), clamp(p - vec3(t.x), 0.0, 1.0), s);\n}\n\nconst vec3 lightDir = vec3(0.577, 0.577, 0.577);\n\nvec3 rotate(vec3 p, float angle, vec3 axis){\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x + a.x * r + c,\n        a.y * a.x * r - a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r + a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nvec3 twistX(vec3 p, float power){\n    float s = sin(power * p.y);\n    float c = cos(power * p.y);\n    mat3 m = mat3(\n        1.0, 0.0, 0.0,\n        0.0, c, s,\n        0.0, -s,   c\n    );\n    return m * p;\n}\n\nvec3 twistY(vec3 p, float power){\n    float s = sin(power * p.y);\n    float c = cos(power * p.y);\n    mat3 m = mat3(\n          c, 0.0,  -s,\n        0.0, 1.0, 0.0,\n          s, 0.0,   c\n    );\n    return m * p;\n}\n\n\nfloat random (in vec2 st) { \n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233))) \n                * 43758.5453123);\n}\n\n// The MIT License\n// Copyright  2013 Inigo Quilez\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n    \n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( random( i + vec2(0.0,0.0) ), \n                     random( i + vec2(1.0,0.0) ), u.x),\n                mix( random( i + vec2(0.0,1.0) ), \n                     random( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// smoothing min\nfloat smoothMin(float d1, float d2, float k){\n    float h = exp(-k * d1) + exp(-k * d2 * d1);\n    return -log(h) / k;\n}\n\n// torus\nfloat torus(vec3 p, vec2 r){\n    float a = -.3 * cos(iTime + p.z * p.y * p.x) * noise(vec2(p.xz+iTime));\n    vec2 d = vec2(length(p.xy) + a + noise(vec2(a, iTime)) - r.x, p.z);\n    return length(d * p.z) - r.x + noise(vec2(r.x+iTime*.1));\n}\n\n// sphere\nfloat sphere( vec3 p, float r )\n{\n  return length(mod(p, .1))-r;\n}\n\nfloat box( vec3 p )\n{\n  return length(max(abs(p)-vec3(1.),0.0));\n}\n\n// distance function\nfloat distFunc(vec3 p){\n  float a = cos(iTime + noise(vec2(p.z, iTime))) + sin(iTime + p.z);\n  float b = sin(iTime - p.x) + noise(vec2(iTime));\n  \n    vec3 q = rotate(twistX(twistX(p+b, 1.2 + cos(iTime)), 1.1 + sin(iTime)), radians(iTime * 100.), vec3(1.0, 0., 0.));\n\n    float d1 = torus(p+q*.2, vec2(.6, .1));\n    float d2 = sphere(p + q*-.1*cos(iTime), 1.);\n    float c = smoothMin(d1, d2+noise(vec2(d1)), 16.);\n    return c + sqrt(mod(c - mod(c - d2 * noise(vec2(iTime*.1)*.1), 4.) * .1, 2.) * .1);\n\n}\n\nvec3 genNormal(vec3 p){\n    float d = 0.1;\n    return normalize(vec3(\n        distFunc(p + vec3(  d, 0.0, 0.0)) - distFunc(p + vec3( -d, 0.0, 0.0)),\n        distFunc(p + vec3(0.0,   d, 0.0)) - distFunc(p + vec3(0.0,  -d, 0.0)),\n        distFunc(p + vec3(0.0, 0.0,   d)) - distFunc(p + vec3(0.0, 0.0,  -d))\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // fragment position\n    vec2 p = (gl_FragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    // camera and ray\n    vec3 cPos = vec3(0., 0., -1.8);\n    vec3 cDir = vec3(cos(iTime*.5)*.5 - .5, sin(iTime*.5)*.5, -1. + cos(iTime*.5)*.5);\n    vec3 cUp  = vec3(0.0, 1.0, 0.0);\n    vec3 cSide = cross(cDir, cUp);\n    float targetDepth = 1.1;\n    vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir * targetDepth);\n    \n    // marching loop\n    float tmp, dist;\n    tmp = 0.0;\n    vec3 dPos = cPos;\n    for(int i = 0; i < 16; i++){\n        dist = distFunc(dPos);\n        tmp += dist;\n        dPos = cPos - cos(iTime*.1)*.4 + tmp * ray * .75;\n    }\n    \n    // hit check\n    vec3 color;\n    if(abs(dist) < .1){\n        vec3 normal = genNormal(dPos);\n        float diff = clamp(dot(lightDir, normal), 0.1, 1.0);\n        color = vec3(cos(iTime)*.5, .5+sin(iTime*.2)*.2, .8) * hsv(diff*.5, .2, 1.);\n    }else{\n        color = vec3(0.0);\n    }\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ssBR2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4ssBz2", "name": "music beat flowers", "author": "adambene", "description": "Flowers dancing to the beat.\nWait for the music to start.", "tags": ["music", "beat", "flower", "flowers"], "likes": 0, "viewed": 86, "date": "1497393285", "time_retrieved": "2024-06-20T18:55:48.319239", "image_code": "#define PI 3.141592654\n#define t iTime\n\nfloat core(float r, float dist) {\n\treturn pow(max(0., r - dist), .2);\n}\n\nfloat petal(float r, float phi, float dist) {\n\treturn pow(max(0., r*cos(phi*8.) - dist), .3);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy - vec2(.5, .5);\n\tuv.x *= iResolution.x/iResolution.y;\n    \n    float r11 = (.5 + .05 * sin(t + PI)),\n          r22 = (.4 + .05 * sin(t*2.)),\n            f = .6 * texture(iChannel0, .4 * uv + vec2(.5, .0)).r + .2,\n            m = f,\n            r = f / 2.,\n           r1 = f,\n           r2 = f,\n         dist = length(uv),\n          phi = -atan(uv.x, uv.y) + t / 5. + f;\n    \n\tfragColor = vec4(1,1,0,0)*core(r, dist)\n              + vec4(1,0,0,0)*petal(r1, phi, dist)\n              - vec4(0,1,0,0)*petal(r1, phi, dist)\n              + vec4(1,2,0,0)*petal(r2, phi + PI/8., dist)\n              - vec4(0,1,0,0)*petal(r2, phi + PI/8., dist)\n              + m * vec4(f, .3, .5, 0.);\n}", "image_inputs": [{"id": "XsXGRr", "previewfilepath": "/media/ap/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ssBz2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4sXBWf", "name": "Tyre Rasterizer", "author": "zproxy", "description": "https://www.shadertoy.com/view/MsjSzz\ncannot move camera inside object tho", "tags": ["rasterizer"], "likes": 0, "viewed": 106, "date": "1498422510", "time_retrieved": "2024-06-20T18:55:49.543588", "image_code": "#define LINEAR_ROTATION\n\n#define WEIGHT (3.0 / iResolution.x)\nconst vec3 RED = vec3(1.0,0.0,0.0);\nconst vec3 GREEN = vec3(0.0,1.0,0.0);\nconst vec3 BLUE = vec3(0.0,0.8,1.0);\nconst vec3 WHITE = vec3(1.0,1.0,0.97);\nconst vec3 YELLOW = vec3(1.0,1.0,0.0);\n\n// rasterize functions\nfloat line(vec2 p, vec2 p0, vec2 p1, float w) {\n    vec2 d = p1 - p0;\n    float t = clamp(dot(d,p-p0) / dot(d,d), 0.0,1.0);\n    vec2 proj = p0 + d * t;\n    float dist = length(p - proj);\n    dist = 1.0/dist*WEIGHT*w;\n    return min(dist*dist,1.0);\n}\nfloat circle(vec2 p, vec2 c, float r, float w) {\n    float dist = abs(length(p - c)) + r;\n    dist = 1.0/dist*WEIGHT*w;\n    return min(dist*dist,1.0);\n}\n\n// matrices\nmat4 getRotMatrix(vec3 a) {\n    vec3 s = sin(a);\n    vec3 c = cos(a);    \n    mat4 ret;\n    ret[0] = vec4(c.y*c.z,c.y*s.z,-s.y,0.0);\n    ret[1] = vec4(s.x*s.y*c.z-c.x*s.z,s.x*s.y*s.z+c.x*c.z,s.x*c.y,0.0);\n    ret[2] = vec4(c.x*s.y*c.z+s.x*s.z, c.x*s.y*s.z-s.x*c.z,   c.x*c.y,0.0);    \n    ret[3] = vec4(0.0,0.0,0.0,1.0);\n    return ret;\n}\nmat4 getPosMatrix(vec3 p) {   \n    mat4 ret;\n    ret[0] = vec4(1.0,0.0,0.0,p.x);\n    ret[1] = vec4(0.0,1.0,0.0,p.y);\n    ret[2] = vec4(0.0,0.0,1.0,p.z);   \n    ret[3] = vec4(0.0,0.0,0.0,1.0);\n    return ret;\n}\n\n// utils\nvec3 mix3(vec3 a, vec3 b, vec3 c, float t) {\n    if(t>0.5) return mix(b,c,t*2.0-1.0);\n    else return mix(a,b,t*2.0);\n}\nvec3 fragment(vec3 p) {\n    float t = sin(p.x*0.8+iTime*0.5)*0.5+0.5;\n    float fog = min(pow(p.z,2.0)*400.0,1.0);\n //   return mix3(RED,GREEN,BLUE,t) * fog;\n    \n    // return white. always\n    return vec3(1.) * fog;\n}    \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    //uv = uv * (1.0 + pow(length(uv)*0.4,0.5)) * 0.6;\n    \n    float line_width = 1.9;\n    float time = iTime * 0.1;\n    vec3 c = vec3(mix(vec3(0.19,0.13,0.1),vec3(1.0), 0.5*pow(length(uv)*0.5,2.0)));\n    \n    \n    // if we go too close it will break\n    mat4 cam = getPosMatrix(vec3(0.0,0.0,8.0));\n    \n\n    //mat4 rot = getRotMatrix(vec3(0.,0.,3.14 +time));\n\n    \n    \n    mat4 rot = getRotMatrix(vec3(\n        \n        // xlat animation\n        -3.14 +iTime  *0.1,0.,\n                                 \n                                 // moonrise to moonset\n                                 -iTime));\n\n    \n     \n    vec3 instances[1];\n    instances[0] = vec3( 0.0, 0.0,0.0);\n   \n    \n    {\n        \n        // input assembly\n        // vec3 vert[8];\n        \n        #define zcount 3\n        //#define zpoints 4\n        \n        // 23fps\n//        #define zpoints 8 \n\n        #define zpoints 36 \n\n        #define radius 5.\n        \n        // https://www.opengl.org/discussion_boards/showthread.php/170193-Constant-vec3-array-no-go\n        // const vec3 MyArray[4]=vec3[4](\n        \n        // 360 Gx2 from 1999 vb6 hehe\n        vec3[zpoints * zcount] vert;\n        \n        // -1 0 +1\n        for(int i = 0; i < zcount; i++) \n        {\n            float z = float(i) - 1.;\n        \n            // can we get 4 corners from a circle?\n            \n             for(int zpoint = 0; zpoint < zpoints ; zpoint++) \n             {\n                 vert[(i * zpoints)+zpoint] = vec3(\n                     radius*cos(float(zpoint)*2.*3.14/float(zpoints)),\n                     radius*sin(float(zpoint)*2.*3.14/float(zpoints)),\n                     z);\n             }\n          // vert[(i * zpoints)+0] = vec3(-1.0,-1.0,z);\n          // vert[(i * zpoints)+1] = vec3(-1.0, 1.0,z);    \n          // vert[(i * zpoints)+2] = vec3( 1.0, 1.0,z);    \n          // vert[(i * zpoints)+3] = vec3( 1.0,-1.0,z);\n        }\n        \n        \n \n\n\n        \n        // vertex processing        \n        mat4 pos = getPosMatrix(instances[0] );\n        mat4 mat = pos * rot * cam;\n\n        for(int i = 0; i < zpoints * zcount; i++) {\n\t\t\t\n            // rescale?\n            //vert[i] *= 4.;\n            \n            // transform\n            vert[i] = (vec4(vert[i],1.0) * mat).xyz;\n\n            // perspective\n            vert[i].z = 1.0 / vert[i].z;\n            \n            // what does this do? isometric without.\n            vert[i].xy *= vert[i].z;\n            \n            \n        }    \n\n        // primitive assembly and rasterize\n        vec3 i;\n        \n     \n        \n        \n     // which scanline?\n       int zindex0 = (int(iFrame) / 30) % 3;\n                         \n        //\n        \n        //         for(int zindex = 0; zindex <  zcount; zindex++) \n\n        {\n            int zindex = 0;\n           \n            for(int zpoint = 0; zpoint < zpoints ; zpoint++) \n            {\n                // https://www.shadertoy.com/view/MsjSzz\n\n                // verticals\n                // https://www.shadertoy.com/view/XdfBWf\n\n\n\n                //zpoint = 0;\n            i += vec3(0.0,0,1.0) * line(uv,vert[(zindex * zpoints)+zpoint].xy,vert[(zindex * zpoints)+(zpoint+1)%zpoints].xy,line_width * 0.5);\n            //i += line(uv,vert[(zindex * zpoints)+1].xy,vert[(zindex * zpoints)+2].xy,line_width);\n            //i += line(uv,vert[(zindex * zpoints)+2].xy,vert[(zindex * zpoints)+3].xy,line_width);\n            //i += line(uv,vert[(zindex * zpoints)+3].xy,vert[(zindex * zpoints)+0].xy,line_width);\n\n            }\n        }\n    \n           {\n            int zindex = 1;\n           \n            for(int zpoint = 0; zpoint < zpoints ; zpoint++) \n            {\n                // https://www.shadertoy.com/view/MsjSzz\n\n                // verticals\n                // https://www.shadertoy.com/view/XdfBWf\n\n\n\n                //zpoint = 0;\n            i += vec3(1.0,1.0,0) * line(uv,vert[(zindex * zpoints)+zpoint].xy,vert[(zindex * zpoints)+(zpoint+1)%zpoints].xy,line_width * 0.5);\n            //i += line(uv,vert[(zindex * zpoints)+1].xy,vert[(zindex * zpoints)+2].xy,line_width);\n            //i += line(uv,vert[(zindex * zpoints)+2].xy,vert[(zindex * zpoints)+3].xy,line_width);\n            //i += line(uv,vert[(zindex * zpoints)+3].xy,vert[(zindex * zpoints)+0].xy,line_width);\n\n            }\n        }\n        \n           {\n            int zindex = 2;\n           \n            for(int zpoint = 0; zpoint < zpoints ; zpoint++) \n            {\n                // https://www.shadertoy.com/view/MsjSzz\n\n                // verticals\n                // https://www.shadertoy.com/view/XdfBWf\n\n\n\n                //zpoint = 0;\n            i += vec3(1.0,0,0) * line(uv,vert[(zindex * zpoints)+zpoint].xy,vert[(zindex * zpoints)+(zpoint+1)%zpoints].xy,line_width * 0.5);\n            //i += line(uv,vert[(zindex * zpoints)+1].xy,vert[(zindex * zpoints)+2].xy,line_width);\n            //i += line(uv,vert[(zindex * zpoints)+2].xy,vert[(zindex * zpoints)+3].xy,line_width);\n            //i += line(uv,vert[(zindex * zpoints)+3].xy,vert[(zindex * zpoints)+0].xy,line_width);\n\n            }\n        }\n        \n        \n        \n        //int vindex = (int(iFrame) / 2) % (zpoints);\n        \n        // animate the whole thing instead?\n        int vindex = 0;\n\n        i += line(uv,vert[vindex].xy,vert[vindex + 2 * zpoints].xy,line_width *2.);\n        \n        //i += line(uv,vert[1].xy,vert[5].xy,line_width);\n        //i += line(uv,vert[2].xy,vert[6].xy,line_width);\n        //i += line(uv,vert[3].xy,vert[7].xy,line_width);\n    \n        \n        c += fragment(vert[0]) * min(i,1.0);\n    }\n     \n    \n    // fragment\n\tfragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sXBWf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4sXBWs", "name": "Tusi-Couple", "author": "unbird", "description": "Special case of a so-called hypotrochoid (inner circle has half the radius of the outer one) called a Tusi-couple:\nhttps://en.wikipedia.org/wiki/Tusi_couple.\n\nUpdate 3: Configurable 2nd point, ellipse path now derived. Todo: Select point with mouse", "tags": ["2d", "animation", "gear", "trochoid", "tusi", "hypotrochoid"], "likes": 12, "viewed": 499, "date": "1498692621", "time_retrieved": "2024-06-20T18:55:52.574072", "image_code": "/*\n    Tusi-couple\n\n\tUsing basic sdf shapes to render gear animation\n*/\n\n// Parameters\n\n// 2nd Tusi position (relative to the inner wheel). Set 0 to disable\n\nconst vec2 relativePos = vec2(0.5, -1.7);\n\n#define SHOWAXIS false\n\n// constants\n#define M_PI 3.1415926535897932384626433832795\n\nconst vec4 Red = vec4(1,0,0,1);\nconst vec4 LightRed = vec4(1,0.8,0.8,1);\nconst vec4 Yellow = vec4(1,1,0,1);\nconst vec4 Green = vec4(0,1,0,1);\nconst vec4 LightGreen = vec4(0.8,1.0,0.8,1);\nconst vec4 Blue = vec4(0,0,1,1);\nconst vec4 LightBlue = vec4(0.8,0.8,1,1);\nconst vec4 White = vec4(1,1,1,1);\nconst vec4 Gray = vec4(0.5,0.5,0.5,1);\nconst vec4 Black = vec4(0,0,0,1);\nconst vec4 TransparentWhite = vec4(1,1,1,0);\nconst vec4 Brown = vec4(0.8, 0.4, 0.2,1);\n\nvec4 Dark(vec4 color)\n{\n\treturn vec4(color.rgb * 0.7, color.a);\n}\n\n\n//////////////////////////////////////\n// Combine distance field functions //\n//////////////////////////////////////\n\n\nfloat smoothMerge(float d1, float d2, float k)\n{\n    float h = clamp(0.5 + 0.5*(d2 - d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0-h);\n}\n\nfloat merge(float d1, float d2)\n{\n\treturn min(d1, d2);\n}\n\n\nfloat mergeExclude(float d1, float d2)\n{\n    float a = min(d1 * sign(d2), d2 * sign(d1));\n    float b = max(d1 * sign(d2), d2 * sign(d1));\n    \n    if (sign(d1) == sign(d2))\n    \treturn a;\n    else\n    \treturn b;\n}\n\n\nfloat substract(float d1, float d2)\n{\n\treturn max(-d1, d2);\n}\n\n\nfloat intersect(float d1, float d2)\n{\n\treturn max(d1, d2);\n}\n\n\n//////////////////////////////\n// Rotation and translation //\n//////////////////////////////\n\nvec2 translate(vec2 p, vec2 t)\n{\n\treturn p - t;\n}\n\nvec2 rotateCCW(vec2 p, float a)\n{\n\tmat2 m = mat2(cos(a), sin(a), -sin(a), cos(a));\n\treturn p * m;\t\n}\n\n\nvec2 rotateCW(vec2 p, float a)\n{\n\tmat2 m = mat2(cos(a), -sin(a), sin(a), cos(a));\n\treturn p * m;\n}\n\n\n//////////////////////////////\n// Distance field functions //\n//////////////////////////////\n\n\nfloat pie(vec2 p, float angle)\n{\n\tangle = radians(angle) / 2.0;\n\tvec2 n = vec2(cos(angle), sin(angle));\n\treturn abs(p).x * n.x + p.y*n.y;\n}\n\n\nfloat circleDist(vec2 p, float radius)\n{\n\treturn length(p) - radius;\n}\n\n\nfloat signxx(float x)\n{\n    return x > 0.0 ? 1.0 : -1.0;\n}\n\n// --- ellipse\n// Created by Inigo Quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// unbird parameters to change shape\nfloat ellipse(vec2 P, vec2 ab)\n{\n/*\n    // Alternate version (approximation)\n    float a = 1.0;\n    float b = 3.0;\n    float r = 0.9;\n    float f = length( p*vec2(a,b) );\n    f = length( p*vec2(a,b) );\n    f = f*(f-r)/length( p*vec2(a*a,b*b) );\n    return f;\n*/\n\n    //vec2 ab = vec2(size/3.0, size/2.0);\n    vec2 p = abs( P );\n    if( p.x > p.y ){\n        p = p.yx;\n        ab = ab.yx;\n    }\n    // unbird: slight modification to make inverted shape and ellipse line not produce artifacts at main axis\n    if(p.x < 0.0001)\n    {\n        return p.y - ab.y;\n    }\n    // unbird: another edge case. Perfect circles fail (one should use an actual circle). \n    if(abs(ab.x - ab.y) < 0.005)\n        ab.x += 0.005;\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;\n    float n = ab.y*p.y/l;\n    float m2 = m*m;\n    float n2 = n*n;\n\n    float c = (m2 + n2 - 1.0)/3.0;\n    float c3 = c*c*c;\n\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n\n    float co;\n\n    if(d < 0.0)\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n\n    float si = sqrt(1.0 - co*co);\n    vec2 closestPoint = vec2(ab.x*co, ab.y*si);\n    return length(closestPoint - p ) * sign(p.y-closestPoint.y);\n}\n\nfloat ellipseLine(vec2 pos, vec2 ab, float width)\n{\n    return abs(ellipse(pos, ab)) - width;\n}\n\n\nfloat triangleDist(vec2 p, float radius)\n{\n\treturn max(\tabs(p).x * 0.866025 + \n\t\t\t   \tp.y * 0.5, -p.y) \n\t\t\t\t-radius * 0.5;\n}\n\n\nfloat triangleDist(vec2 p, float width, float height)\n{\n\tvec2 n = normalize(vec2(height, width / 2.0));\n\treturn max(\tabs(p).x*n.x + p.y*n.y - (height*n.y), -p.y);\n}\n\n\nfloat semiCircleDist(vec2 p, float radius, float angle, float width)\n{\n\twidth /= 2.0;\n\tradius -= width;\n\treturn substract(pie(p, angle), \n\t\t\t\t\t abs(circleDist(p, radius)) - width);\n}\n\n\nfloat boxDist(vec2 p, vec2 size, float radius)\n{\n\tsize -= vec2(radius);\n\tvec2 d = abs(p) - size;\n  \treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n}\n\n\nfloat lineDist(vec2 p, vec2 start, vec2 end, float width)\n{\n\tvec2 dir = start - end;\n\tfloat lngth = length(dir) + 0.0001;\n\tdir /= lngth;\n\tvec2 proj = max(0.0, min(lngth, dot((start - p), dir))) * dir;\n\treturn length( (start - p) - proj ) - (width / 2.0);\n}\n\n\nfloat ellipseLineSafe(vec2 pos, vec2 ab, float width)    \n{\n    vec2 aab = abs(ab);\n    if(aab.x < 0.1 || aab.y < 0.1)\n    {\n        return lineDist(pos, -ab, ab, width);\n    }\n    return abs(ellipse(pos, ab)) - width;\n}\n\n\nfloat polygon(vec2 p, float radius, int n)\n{\n    // mod angle \n    float angle = atan(p.y, p.x);\n    float part = 2.0*M_PI / float(n);\n    angle = mod(angle, part);   \n    p = length(p) * vec2(cos(angle), sin(angle));    \n    \n    // plane equation for border (note half angle otherwise the ends don't match)\n    part *= 0.5;\n    vec2 plane = vec2(cos(part), sin(part));\n    \n\treturn dot(p, plane) - radius;\n}\n\n// get normalized slice of circle\nfloat circleMod(vec2 p, int n)\n{\n    // mod angle \n    float angle = atan(p.y, p.x);\n    float part = 2.0*M_PI / float(n);\n    angle = mod(angle, part);   \n\treturn angle / part;\n}\n\n// arbitrary \"polygon\". Has to be used with circleMod and some function which has f'(0) = f'(1), e.g. sin(x*2*pi)\nfloat polyShape(vec2 p, float radius, int n, float offset)\n{\n    // mod angle \n    float angle = atan(p.y, p.x);\n    float part = 2.0*M_PI / float(n);\n    angle = mod(angle, part);   \n    p = length(p) * vec2(cos(angle), sin(angle));    \n    \n    // plane equation for border (note half angle otherwise the ends don't match)\n    part *= 0.5;\n    vec2 plane = vec2(cos(part), sin(part));\n    \n\treturn length(p) - radius - offset;\n}\n\nfloat star(vec2 p, float radius, float innerradius, int n)\n{\n    // similar to polygon\n    float angle = atan(p.y, p.x);\n    float part = 2.0*M_PI / float(n);\n    angle = mod(angle, part);   \n    p = length(p) * vec2(cos(angle), sin(angle));            \n    float halfpart = 0.5 * part;\n    \n    // define 3 point of first \"tooth\" of the star\n    vec2 A = vec2(innerradius, 0);\n    vec2 B = vec2(cos(part), sin(part)) * innerradius;\n    vec2 C = vec2(cos(halfpart), sin(halfpart)) * radius;\n    \n    // derive plane equations thereof (normals and offsets)\n    vec2 plane1 = A - C;\n    plane1 = normalize(vec2(-plane1.y, plane1.x));\n    float p1c = dot(C, plane1);\n    \n    vec2 plane2 = C - B;\n    plane2 = normalize(vec2(-plane2.y, plane2.x));\n    float p2c = dot(C, plane2);\n    \n    // combine the planes\n\treturn max(dot(p, plane2) - p2c, dot(p, plane1) - p1c);\n}\n\n\nfloat spikesDist(vec2 p, float radius, int n, float width)\n{\n    // similar to polygon\n    float angle = atan(p.y, p.x);\n    float part = 2.0*M_PI / float(n);\n    angle = mod(angle, part);   \n    p = length(p) * vec2(-cos(angle), sin(angle));            \n    \n    width *= 0.5;\n    \n    float leftspike = abs(p.y) - width;    \n    \n    //part *= 0.5;\n    vec2 normal = vec2(sin(part), cos(part));\n    \n    float rightspike = -dot(p, normal) - width;\n    //return rightspike;      \n    //return leftspike;      \n    \n    return max(min(leftspike, rightspike), circleDist(p, radius));\n}\n\n\n///////////////////////\n// Masks for drawing //\n///////////////////////\n\n\nfloat fillMask(float dist)\n{\n\treturn clamp(-dist, 0.0, 1.0);\n}\n\n\nfloat innerBorderMask(float dist, float width)\n{\n\tdist -= width * 0.5;\n\tfloat alpha1 = clamp(dist + width, 0.0, 1.0);\n\tfloat alpha2 = clamp(dist, 0.0, 1.0);\n\treturn alpha1 - alpha2;\n}\n\n\nfloat outerBorderMask(float dist, float width)\n{\n\tdist -= 5.0;\n\tfloat alpha1 = clamp(dist, 0.0, 1.0);\n\tfloat alpha2 = clamp(dist - width, 0.0, 1.0);\n\treturn alpha1 - alpha2;\n}\n\n\n///////////////\n// The scene //\n///////////////\n\nvec2 lissajous(float x, float alpha, float phase)\n{\n    return vec2(sin(alpha*x + phase), cos(x));\n}\n\nfloat saturate(float x)\n{\n    return clamp(x, 0.0, 1.0);\n}\n\nvoid blend(inout vec4 back, float alpha, vec4 color)\n{\n    float a = saturate(alpha);\n    // basic alpha blending\n    color = mix(color, vec4(0.1, 0.1, 0.1, 1.0), innerBorderMask(alpha, 1.5));\n    back = mix(back, color, (1.0-a) * color.a);\n}\n\nvec2 cis(float alpha)\n{\n    return vec2(cos(alpha), sin(alpha));\n}\n\nfloat radial(vec2 p, int n)\n{\n    // mod angle \n    float angle = atan(p.y, p.x);\n    float part = 2.0*M_PI / float(n);\n    angle = mod(angle, part);   \n    return abs(angle - part * 0.5) / part / 0.5;\n}\n\n\n\nvec4 drawLight(vec2 p, vec2 pos, vec4 color, float range, float radius)\n{\n\t// distance to light\n\tfloat ld = length(p - pos);\n\t\n\t// out of range\n\tif (ld > range) return vec4(0.0);\n\t\n\t// shadow and falloff\n\t\n\tfloat fall = saturate((range - ld)/range);\n\tfall *= fall;\n\tfloat source = fillMask(circleDist(p - pos, radius));\n\treturn (fall + source) * color;\n}\n\n\nfloat bar(vec2 p, vec2 start, vec2 end, float width)\n{\n    return\n        merge(\n        merge(lineDist(p, start, end, width), \n              circleDist(p - start, 1.5 * width)),\n              circleDist(p - end, 1.5 * width));\n}\n\nfloat sceneDist(vec2 p, inout vec4 color)\n{    \n    float time = iTime;\n    \n\tvec2 center = iResolution.xy / 2.0;\n    vec2 amplitudes = center *0.7;\n\n    float maxdim = min(iResolution.x, iResolution.y);\n    float outerradius = maxdim * 0.45;\n    \n    float pointsize = maxdim * 0.007;\n    \n\tint cogn = 64;\n\tvec2 cogp = translate(p, center);\n\tfloat cogx = circleMod(cogp, cogn);    \n\tfloat c1 = -polyShape(cogp, outerradius, cogn, outerradius*0.03*cos(2.0*M_PI*cogx));\n    \n    c1 = intersect(c1, circleDist(cogp, maxdim * 0.5));\n    \n\t//float c1 = -circleDist(\t\ttranslate(p, center), outerradius);\n    float spikes = radial(translate(p, center), 10);\n    blend(color, c1, mix(Gray, Dark(Gray), spikes < 0.5 ? 0.0 : 1.0));        \n    \n    \n    float innerradius = outerradius * 0.5;\n    vec2 wheelpos = cis(time) * (outerradius - innerradius) + center;\n    float wheelratio = outerradius / innerradius;\n    float wheelrotation = time;\n\n\tint cogn2 = cogn / 2;\n\tvec2 cogp2 = rotateCW(translate(p, wheelpos), time);\n\tfloat cogx2 = circleMod(cogp2, cogn2);    \n\tfloat c2 = polyShape(cogp2, innerradius, cogn2, outerradius*0.03*cos(2.0*M_PI*cogx2));    \n    \n    float spikeradius = innerradius * 0.9;\n    float c2Spikes = spikesDist(cogp2, spikeradius, 10, innerradius * 0.1);\n    \n    c2 = merge(mergeExclude(c2, circleDist(cogp2, spikeradius*0.9)), c2Spikes);\n    \n\t//float c2 = circleDist(cogp2, innerradius);\n    float spikes2 = radial(rotateCW(translate(p, wheelpos), time), 5);\n    blend(color, c2, mix(Red, Dark(Red), spikes2 < 0.5 ? 0.0 : 1.0));            \n    \n    float phase = 0.0;\n    vec2 tusipos = wheelpos + cis(-time + phase) * innerradius * 0.6;    \n    \n    float tt = bar(p, wheelpos, tusipos, pointsize*2.0);\n    blend(color, tt, Gray);    \n    \n\tfloat t3 = star(\trotateCW(translate(p, tusipos), time), pointsize*4.0, pointsize*2.0, 12);\n    blend(color, t3, LightRed);    \n    \n    \n    //vec2 ellipseSize = vec2(0.8, 0.1);\n    vec2 ellipseSize = vec2(0.8, 0.2);\n    float ell = ellipseLine( translate(p, center), ellipseSize*outerradius, 3.0);\n    //float ell = -ellipse( translate(p, center), ellipseSize*outerradius);\n    blend(color, ell, vec4(Yellow.rgb, 0.5));    \n          \t\n    color += drawLight(p, tusipos, Yellow, pointsize*10.0, pointsize*0.1);\n    \n    float tusi2limit = pointsize * 5.0;\n    \n    blend(color, boxDist(p, vec2(tusi2limit), 1.0), Dark(Red));\n    \n    \n    //vec2 tusipos2 = iMouse.xy;\n    //if(iMouse.x > tusi2limit && iMouse.y > tusi2limit)\n    //if(iMouse.x > tusi2limit && iMouse.y > tusi2limit)    \n    if(length(relativePos) > 0.001)\n    {   \n        vec2 tusipos2 = wheelpos + rotateCCW(relativePos, time) * innerradius;    \n\n\t\tblend(color, bar(p, wheelpos, tusipos2, pointsize*2.0), Gray);                   \n\t\tblend(color, star(\trotateCW(translate(p, tusipos2), time), pointsize*4.0, pointsize*2.0, 12), LightRed);    \n        \n\n        float offsetAngle = atan(relativePos.y, relativePos.x) * 0.5;\n        float  offsetAngle2 = offsetAngle + M_PI * 0.5;\n\n        vec2 major = cis(offsetAngle) * innerradius + rotateCCW(relativePos, offsetAngle) * innerradius;\n        vec2 minor = cis(offsetAngle2) * innerradius + rotateCCW(relativePos, offsetAngle2) * innerradius;\n\n        if(SHOWAXIS)\n        {\n        \tblend(color, lineDist(p, center, center + major, 2.0), vec4(Green.rgb, 0.25));\n        \tblend(color, lineDist(p, center, center + minor, 2.0), vec4(LightGreen.rgb, 0.25));\n        }\n        \n\n        ellipseSize = vec2(length(major), length(minor));\n        ell = ellipseLineSafe( rotateCCW(translate(p, center), offsetAngle), ellipseSize, 2.5);        \n        blend(color, ell, vec4(Green.rgb, 0.5));    \n        \n\n        color += drawLight(p, tusipos2, Green, pointsize*10.0, pointsize*0.1);\n    }\n    \n    \n        \n\treturn 0.0;\n}\n\nfloat sceneDist(vec2 p)\n{\n    vec4 dummy;\n    return sceneDist(p, dummy);\n}                    \n\n\nfloat sceneSmooth(vec2 p, float r)\n{\n\tfloat accum = sceneDist(p);\n\taccum += sceneDist(p + vec2(0.0, r));\n\taccum += sceneDist(p + vec2(0.0, -r));\n\taccum += sceneDist(p + vec2(r, 0.0));\n\taccum += sceneDist(p + vec2(-r, 0.0));\n\treturn accum / 5.0;\n}\n\n\n//////////////////////\n// Shadow and light //\n//////////////////////\n\n\n\n\n\nfloat luminance(vec4 col)\n{\n\treturn 0.2126 * col.r + 0.7152 * col.g + 0.0722 * col.b;\n}\n\n\nvoid setLuminance(inout vec4 col, float lum)\n{\n\tlum /= luminance(col);\n\tcol *= lum;\n}\n\n\nfloat AO(vec2 p, float dist, float radius, float intensity)\n{\n\tfloat a = clamp(dist / radius, 0.0, 1.0) - 1.0;\n\treturn 1.0 - (pow(abs(a), 5.0) + 1.0) * intensity + (1.0 - intensity);\n\treturn smoothstep(0.0, 1.0, dist / radius);\n}\n\n\n/////////////////\n// The program //\n/////////////////\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy + vec2(0.5);\n\tvec2 c = iResolution.xy / 2.0;\n\t\n\t// background\t\n\tvec4 col = vec4(0.15, 0.15, 0.4, 1.0);\n    // vignette\n    //col *= (1.0 - length(c - p)/iResolution.x);\n    \n\t// grid\n\t//col *= clamp(min(mod(p.y, 10.0), mod(p.x, 10.0)), 0.9, 1.0);\n    \n\t//float dist = sceneSmooth(p, 5.0);\n\tfloat dist = sceneDist(p, col);\n        \n    \n\t// ambient occlusion\n\t//col *= AO(p, sceneSmooth(p, 10.0), 40.0, 0.4);\n\t//col *= 1.0-AO(p, sceneDist(p), 40.0, 1.0);\n\t// light\n\t// shape fill\n    \n\t//col = mix(col, vec4(1.0, 0.4, 0.0, 1.0), fillMask(dist));\n\t// shape outline\n\t//col = mix(col, vec4(0.1, 0.1, 0.1, 1.0), innerBorderMask(dist, 0.8));\n\n\tfragColor = clamp(col, 0.0, 1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sXBWs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4sXBzj", "name": "First test raymarching", "author": "MatHack", "description": "raymarching", "tags": ["raymarching"], "likes": 1, "viewed": 52, "date": "1496878162", "time_retrieved": "2024-06-20T18:55:52.580166", "image_code": "const float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\nfloat plane(vec3 pos){\n    return pos.y;\n}\n\nfloat sphere(vec3 pos, float radius){\n    return length(pos) - radius;\n}\n\nfloat repeat(float coord, float spacing) {\n    return mod(coord, spacing) - spacing*0.5;\n}\n\nvec2 scene(vec3 camPos){\n    float dist = 0.;\n    float materialID = 0.;\n    \n    vec3 q = vec3(camPos+vec3(0., -0.6, 0.));\n    q.x = repeat(q.x, sin(iTime)*0.5 + 1.5);\n    q.z = repeat(q.z, sin(iTime)*0.5 + 1.5);\n    \n    \n    float obj1 = sphere(q, 0.3);\n    float obj2 = plane(camPos);\n    \n    dist = obj1;\n    materialID = 1.0;\n    \n    if(obj2 < obj1){\n        dist = obj2;\n        materialID = 2.0;\n    }\n        \n    return vec2(dist, materialID);\n}\n\n\nmat3 setCamera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\n\n\nvec2 trace(vec3 camPos, vec3 camTarget){\n    float td = 0.1;\n    float mat = -1.0;\n    \n    for(int i=0;i<1024;i++){\n        float pres = EPSILON * td;\n        vec2 result = scene(camPos + camTarget * td);\n        if(result.x < pres || td > MAX_DIST){\n           break;\n        }\n        td += result.x;  \n        mat = result.y;\n    }\n    \n    if(td>MAX_DIST){\n        mat = -1.0;\n    }\n    return vec2(td, mat);\n}\n\nvec3 calcNorm(vec3 pos){\n    vec2 eps = vec2(0.001, 0.0);\n    vec3 norm = vec3(\n        scene(pos+eps.xyy).x - scene(pos-eps.xyy).x,\n        scene(pos+eps.yxy).x - scene(pos-eps.yxy).x,\n        scene(pos+eps.yyx).x - scene(pos-eps.yyx).x);\n    return normalize(norm);\n        \n}\n\nfloat getReflect(vec3 ro, vec3 rd )\n{\n\tfloat res = 1.0;\n    float t = 0.02;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = scene( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>2.5 ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    vec2 uv = (-iResolution.xy + 2.0*(fragCoord))/iResolution.y;\n    vec2 mo = iMouse.xy / iResolution.xy;\n    \n    vec3 outColor = vec3(0.);\n    \n    float time = iTime;\n    \n    vec3 camOrigin = vec3( -0.5+3.5*cos(0.1*time + 3.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.0*sin(0.1*time + 4.0*mo.x) );\n    vec3 camTarget = vec3( 0.0, 0.4, 0.0 );\n    mat3 ca = setCamera( camOrigin, camTarget, 0.0 );\n    vec3 camDir = ca * normalize( vec3(uv.xy,1.8) );\n    \n    vec3 lightDir = normalize(vec3(0.0, 1.0, 0.0));\n    \n    vec2 result = trace(camOrigin, camDir);\n    \n    vec3 pos = camOrigin + result.x * camDir;\n    \n    vec3 norm = calcNorm(pos);\n    float dif = clamp( dot( norm, lightDir ), 0.0, 1.0 );\n    float amb = clamp( 0.5+0.5*norm.y, 0.0, 1.0 );\n    vec3 ref = reflect(camDir, norm);    \n    float dom = smoothstep(-0.1, 0.1, ref.y);\n    dom *= getReflect(pos, ref);\n    \n    vec3 matColor = vec3(0.);\n    if(result.y == 1.0){\n        vec3 col = vec3(0.9, 0.2, 0.2);\n        \n        vec3 lin = vec3(0.);\n        lin += 1.3 * dif;\n        lin += 0.8 * amb;\n        lin += 0.5 * dom;\n        \n        col = col * lin;\n        matColor = col;\n        \n       \n    }\n    \n    if(result.y == 2.0){\n        vec3 f = vec3(mod(floor(pos.x*5.)+floor(pos.z*5.), 2.));\n        vec3 color = 0.4 + 0.3*f*vec3(0.5);\n     \n        vec3 fl = texture(iChannel0, pos.xz).rgb;\n\n        \n        vec3 lin = vec3(0.);\n        lin += 1.2 * dif;\n        lin += 0.5 * dom;\n        \n        color = color * lin;\n        \n        matColor = vec3(color);\n    }\n   \t\n    float fogAmount = exp( -(clamp(pos.y-300.0, 0.0, 300000000.0))* 0.01 );\n \n\toutColor = mix(vec3(1.), matColor, fogAmount);\n    \n\tfragColor = vec4(outColor ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sXBzj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4sXfR2", "name": "Chromium kiss", "author": "grinist", "description": "First foray into raymarching. Tried to do something simple and soothing for the eyes. See comments for more info.\nMouse for camera FOV /distance.\n", "tags": ["raymarch", "sdf", "material"], "likes": 22, "viewed": 893, "date": "1496913232", "time_retrieved": "2024-06-20T18:55:55.640676", "image_code": "// Tried to do something sensible with predefined materials per primitive.\n// Probably the interesting thing is material blending based on distances to primitives.\n// Materials are only solved once we know the final ray position, so the logic doesn't need to be\n// dragged around for all the marchers.\n// This and per-frame initialization of trivial trigonometry for the distance scene\n// helped performance quite a bit.\n// Tried to get a faux metal thing going to illustrate lerping better.\n// The surface shading is definitely not academic reference material worth studying. :D\n\n// Update: Restructured lighting / shading. Added reflections and some swithces / extra parameters.\n// Not certain about the fog term propagation with reflections, but it looks close.\n// Added mouse controls for camera fov and distance.\n\n#define PI 3.1415926536\n#define TAU (2.0 * PI)\n#define DEG2RAD (PI / 180.0)\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define time (iTime * 0.8)\n#define RING_SPHERES 8\n#define RING_RADIUS 4.2\n#define SMIN_K 0.65\n#define MARCH_MAX_STEPS 100\n#define MAX_RAY_TRAVEL 25.0\n#define DIST_EPSILON 0.001\n#define MAX_RAY_BOUNCES 3\n\n// lighting contributions\n#define AMBIENT_CONTRIBUTION\n#define DIFFUSE_CONTRIBUTION\n#define SPECULAR_CONTRIBUTION\n#define FRESNEL_CONTRIBUTION\n#define FOG_CONTRIBUTION\n#define REFLECTION_CONTRIBUTION\n\nstruct Material\n{\n    vec3 diffColor;\n    vec3 specColor;\n    vec3 smr; // smoothness, metallic, reflectivity\n};\n\n// needs GLSL ES 3.0\nconst Material materials[6] = Material[6](\n  Material(vec3(0.7, 0.45, 0.25), vec3(1.0, 0.7, 0.5), vec3(0.1, 0.1, 0.0)), \t// ground\n  Material(vec3(0.91, 0.13, 0.23), vec3(1.0, 0.82, 0.79), vec3(0.1, 0.3, 0.0)),\t// ring spheres\n  Material(vec3(0.96, 0.57, 0.18), vec3(1.0, 0.85, 0.68), vec3(0.4, 0.1, 0.05)),\n  Material(vec3(0.13, 0.72, 0.29), vec3(0.36, 1.0, 0.40), vec3(0.6, 0.2, 0.08)),\n  Material(vec3(0.12, 0.51, 0.59), vec3(0.72, 0.94, 1.0), vec3(0.6, 0.9, 0.1)),\n  Material(vec3(0.3, 0.5, 0.7), vec3(1.0, 1.0, 1.0), vec3(0.8, 0.8, 0.5)) \t\t// orbiting sphere\n);\n\n\n// ----- Incremental trigonometry\nfloat tsin = 0.0;\nfloat tcos = 0.0;\nfloat tcosd = 0.0;\nfloat tsind = 0.0;\n\nvoid trigInit(float startAngle, float increment)\n{\n\ttsin = sin(startAngle);\n\ttcos = cos(startAngle);\n\ttsind = sin(increment);\n\ttcosd = cos(increment);\n}\n\nvoid trigInc()\n{\n\tfloat sinn = tsin * tcosd + tcos * tsind;\n\tfloat cosn = tcos * tcosd - tsin * tsind;\n\ttsin = sinn;\n\ttcos = cosn;\n}\n// -----\n\n// cosine gradient, a - constant, b - multiplier, c - phase, d - frequency\nvec3 cosGradient(vec3 a, vec3 b, vec3 c, vec3 d, float t)\n{\n    return a + b * cos(TAU * (c + d * t));\n}\n\n// returns the vector with smallest x component\nvec2 xmin(vec2 a, vec2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\n// returns the vector with smallest x component\nvec3 xmin(vec3 a, vec3 b)\n{\n    return a.x < b.x ? a : b;\n}\n\n// returns the vector with smallest x component\nvec4 xmin(vec4 a, vec4 b)\n{\n    return a.x < b.x ? a : b;\n}\n\n// returns 1.0 if (a == b == 1.0) or (a == b == 0.0), 0.0 otherwise.\n// \"complement of xor for floats\"\nfloat nxorf(float a, float b)\n{\n    return abs(a + b - 1.0);\n}\n\n// iq's polynomial smooth min\nfloat smin(float a, float b, float k)\n{\n    float h = saturate(0.5 + 0.5 * (b - a) / k);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n// -----\n// Hash without Sine\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n#define HASHSCALE1 443.8975\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n// -----\n\n// Returns the interpolant in [0.0, 1.0], inverse lerp\nfloat lerpstep(float a, float b, float x)\n{\n    return (a == b) ? step(x, a) : clamp((x - a) / (b - a), 0.0, 1.0);\n}\n\n\n// Interpolating with 1/x: https://www.shadertoy.com/view/Xd2yRd\n// ----------\n\n// Interpolates from 0 to 1 with slope of k at x=0 and 1/k at x=1.\n// k must be greater than zero.\n// k<1: ease in, k=1: lerp, k>1: ease out\nfloat rxEase(float x, float k)\n{\n    k = clamp(k, 0.0001, 10000.0) - 1.0; // clamp optional, if you know your k\n    x = clamp(x, 0.0, 1.0);\n    float kx = k * x;\n    return (x + kx) / (kx + 1.0);    \n}\n\n// Interpolates from 0 to 1 with slope of k at x=0 and x=1.\n// k must be greater than zero.\n// k<1: sigmoid, k=1: lerp, k>1: seat\nfloat rxEase2(float x, float k)\n{\n    k = clamp(k, 0.0001, 10000.0); // clamp optional, if you know your k\n    x = 0.5 - x; // re-center at 0\n    float s = sign(x);\n    x = clamp(abs(x) * 2.0, 0.0, 1.0);\n    return 0.5 + 0.5 * s * x / (x * (k - 1.0) - k);\n}\n\n// Interpolates from 0 to 1 between [a, b], with slope of k at x=a and 1/k at x=b.\n// k must be greater than zero.\n// k<1: ease in, k=1: lerp, k>1: ease out\nfloat rxStep(float a, float b, float x, float k)\n{\n    return (a == b) ? step(x, a) : rxEase(clamp((x - a) / (b - a), 0.0, 1.0), k);\n}\n\n// Interpolates from 0 to 1 between [a, b], with slope of k at x=a and x=b.\n// k must be greater than zero.\n// k<1: sigmoid, k=1: lerp, k>1: seat\nfloat rxStep2(float a, float b, float x, float k)\n{\n    return (a == b) ? step(x, a) : rxEase2(clamp((x - a) / (b - a), 0.0, 1.0), k);\n}\n\n// ----------\n\nvec3 desaturateColor(vec3 color)\n{\n    return vec3(dot(vec3(0.2126, 0.7152, 0.0722), color));\n}\n\nfloat sWavyPlane(vec3 p)\n{\n    // this is still complex\n\treturn p.y + 0.05 * sin((p.z + 0.5 * p.x) * 3.0 - time * 3.0) + 0.06 * sin((0.4 * p.z + p.x) * 2.0 - time);\n}\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat sPlane(vec3 p, vec3 n, float d)\n{\n\treturn dot(p, n) + d;\n}\n\nfloat sdSphere(vec3 p, float s)\n{\n  return length(p) - s;\n}\n\n// Init frame global stuff for scene\nfloat sphereRadius;\nfloat tsinInit;\nfloat tcosInit;\nfloat tsindInit;\nfloat tcosdInit;\nvec3 orbiterPos;\nvec3 lightPos;\nvoid sceneInit()\n{\n    sphereRadius = 0.65 + sin(time * 2.0) * 0.1;\n    trigInit(PI * 0.125 + time * 0.2, TAU / float(RING_SPHERES));\n    tsinInit = tsin;\n    tcosInit = tcos;\n    tsindInit = tsind;\n    tcosdInit = tcosd;\n    \n    vec2 orbiterXZ = vec2(cos(time * 0.8), -sin(time * 0.9));\n\torbiterPos = vec3(orbiterXZ.x * RING_RADIUS, 0.6, orbiterXZ.y * RING_RADIUS);\n    lightPos = vec3(0.0 + cos(time * 0.4) * 9.0, 3.5, 0.0 + sin(time * 0.4) * 9.0);\n}\n\nvoid trigReset()\n{\n    tsin = tsinInit;\n    tcos = tcosInit;\n    tsind = tsindInit;\n    tcosd = tcosdInit;\n}\n\n// Distance equation scene, used by all marches (mainray, shadow, AO) and normal\nfloat distScene(vec3 pos)\n{\n    const float y = 0.6;\n    const float crad = RING_RADIUS;\n    float res = sWavyPlane(pos);\n\n    float os = sdSphere(pos - orbiterPos, 0.65);\n\n\ttrigReset();\n    // could use polar domain repetition for rs or symmetry\n    for (int i = 0; i < RING_SPHERES; i++)\n    {\n\t    float rs = sdSphere(pos - vec3(tcos * crad, y, tsin * crad), sphereRadius + tcos * 0.15);\n        trigInc();\n\t    float ros = smin(rs, os, SMIN_K);\n\t    res = min(res, ros);\n    }\n\n    return res;\n}\n\nvoid lerpMaterial(inout Material matr1, Material matr2, float lerp)\n{\n    matr1.diffColor = mix(matr1.diffColor, matr2.diffColor, lerp);\n    matr1.specColor = mix(matr1.specColor, matr2.specColor, lerp);\n    matr1.smr = mix(matr1.smr, matr2.smr, lerp);\n}\n\n// Material scene, run once when we know the final position\n// Returns vec3(sourceMaterial, targetMaterial, interpolant)\nMaterial matScene(vec3 pos, float depth, int steps)\n{\n    // material freakshow\n    //int matrIndex = int(mod(float(steps) * 10.0 / float(MARCH_MAX_STEPS), 7.0));\n    //int matrIndex = int(mod((depth + 1.0) * 2.0, 7.0));\n    //Material mat = materials[matrIndex];\n    //return mat;\n    \n    // replicate the distScene with material indices\n    const float y = 0.6;\n    const float crad = RING_RADIUS;\n    float r = sWavyPlane(pos);\n    vec4 res = vec4(r, 0.0, 0.0, 0.0);\n    \n    float os = sdSphere(pos - orbiterPos, 0.65);\n\n\ttrigReset();\n    for (int i = 0; i < RING_SPHERES; i++)\n    {\n\t    float rs = sdSphere(pos - vec3(tcos * crad, y, tsin * crad), sphereRadius + tcos * 0.15);\n        trigInc();\n        float mat = 1.0 + mod(float(i), 4.0);\n        // lerp material based on distances to original primitives\n\t    vec4 ros = vec4(smin(rs, os, SMIN_K), mat, 5.0, rxStep2(0.0, max(rs, os), rs, 0.75));\n\t    res = xmin(res, ros);\n    }\n\n    // create material\n    vec3 matrs = res.yzw;\n    int matr1Index = int(matrs.x);\n    int matr2Index = int(matrs.y);\n    float lerp = matrs.z;\n    Material matr = materials[matr1Index];\n    Material matr2 = materials[matr2Index];\n    if (lerp > 0.0)\n        lerpMaterial(matr, matr2, lerp);\n\n    if (matr1Index == 0)\n    {\n        float mul = 0.85 + 0.15 * hash12(pos.xz * 0.01);\n        vec2 check = floor(mod(pos.xz, 2.0));\n        mul *= 1.0 - saturate(1.0 - length(pos.xz) * 0.22) * 0.2 * nxorf(check.x, check.y);\n        matr.diffColor *= mul;\n    }\n    \n    matr.smr.x = clamp(matr.smr.x, 0.001, 1.0);\n    return matr;\n}\n\n// Calculates normal\nvec3 normal(vec3 pos)\n{\n\tvec3 eps = vec3(0.001, 0.0, 0.0);\n\tvec3 nor = vec3(\n\t    distScene(pos + eps.xyy) - distScene(pos - eps.xyy),\n\t    distScene(pos + eps.yxy) - distScene(pos - eps.yxy),\n\t    distScene(pos + eps.yyx) - distScene(pos - eps.yyx));\n\treturn normalize(nor);\n}\n\n// Main raymarch for primary and secondary reflected rays\nfloat march(vec3 ro, vec3 rd, float maxt, inout int steps)\n{\n    float h = DIST_EPSILON;\n    float t = 0.0;\n    const int maxSteps = MARCH_MAX_STEPS;\n    //int maxSteps = int(50.0 + sin(time * 6.0) * 40.0);\n    for(steps = 0; steps < maxSteps; steps++)\n    {\n        if (abs(h) < DIST_EPSILON * t)\n            return t;\n        if (t >= maxt)\n            return maxt;\n\t    h = distScene(ro + rd * t);\n        t += h;\n    }\n\n    return t;\n}\n\n// Shadow raymarch\nfloat shadow(vec3 ro, vec3 rd, float maxt, float k)\n{\n    float s = 1.0;\n    float h = 0.01;\n    float t = h;\n    for(int i = 0; i < 100; i++)\n    {\n        if (t >= maxt)\n            break;\n\t    h = distScene(ro + rd * t);\n        if (abs(h) < DIST_EPSILON * t)\n            return 0.0;\n        s = min(s, k * h / t);\n        t += h;\n    }\n\n    return s;\n}\n\n// AO raymarch / step\nfloat AO(vec3 ro, vec3 rd)\n{\n\tfloat total = 0.0;\n    float scatter = 1.0;\n    for(float i = 0.0; i < 10.0; i += 1.0)\n    {\n        float hr = 0.01 + 0.05 * i;\n        vec3 pos = ro + rd * hr;\n        float dd = distScene(pos);\n        total += -(dd - hr) * scatter;\n        scatter *= 0.65;\n    }\n    return saturate(1.0 - 2.5 * total);\n}\n\nvec3 skyCol(vec3 rd)\n{\n    //return texture(iChannel0, rd).rgb;\n    return cosGradient(vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5),\n                  vec3(0.525, 0.408, 0.409), vec3(0.9, 0.97, 0.8), clamp(rd.y * 0.6 + 0.5, 0.3, 1.0));\n}\n\nvec3 ambientCol(vec3 rd)\n{\n    return cosGradient(vec3(0.5, 0.5, 0.5), vec3(0.3, 0.3, 0.3),\n                  vec3(0.578, 0.507, 0.481), vec3(0.5, 0.5, 0.4), clamp(rd.y * 0.4 + 0.6, 0.3, 1.0));\n}\n\nvec3 skyCol(vec3 rd, float frequency)\n{\n    return mix(ambientCol(rd), skyCol(rd), frequency);\n}\n\n// returns vec2(diffuseTerm, specularTerm)\nvec2 dirLight(vec3 pos, vec3 nor, vec3 ref, inout Material matr, float dotNV, vec3 lightPos)\n{\n    vec3 lightVec = normalize(lightPos);\n    float dotNL = dot(nor, lightVec);\n    float diff = saturate(dotNL);\n\n    float shdw = 1.0;\n    if(diff > 0.001)\n    {\n        shdw = clamp(shadow(pos, lightVec, MAX_RAY_TRAVEL, 12.0), 0.0, 1.0);\n        diff *= shdw;\n    }\n\n    float pp = saturate(dot(ref, lightVec));\n    float spec = matr.smr.x * shdw * pow(pp, 128.0 * matr.smr.x);\n\n    return vec2(diff, spec);\n}\n\n\n// returns vec2(diffuseTerm, specularTerm)\nvec2 pointLight(vec3 pos, vec3 nor, vec3 ref, inout Material matr, float dotNV, vec3 lightPos, float attenuationTerm)\n{\n    vec3 lightDir = normalize(lightPos);\n    vec3 lightVec = lightPos - pos;\n    float lDistSq = dot(lightVec, lightVec);\n    float intensity = 1.0 / (1.0 + attenuationTerm * lDistSq);\n    float lDist = sqrt(lDistSq);\n    lightVec /= lDist;\n    float dotNL = dot(nor, lightVec);\n    float diff = saturate(dotNL) * intensity;\n\n    float shdw = 1.0;\n    if(diff > 0.001)\n    {\n        shdw = clamp(shadow(pos, lightVec, lDist, 6.0), 0.0, 1.0);\n        diff *= shdw;\n    }\n\n    float pp = saturate(dot(ref, lightVec));\n    float spec = matr.smr.x * shdw * intensity * pow(pp, 128.0 * matr.smr.x);\n\n    return vec2(diff, spec);\n}\n\n// returns vec2(diffuseTerm, specularTerm)\nvec2 spotLight(vec3 pos, vec3 nor, vec3 ref, inout Material matr, float dotNV, vec3 lightPos, float attenuationTerm, vec3 lightTarget, vec2 spotCutoff)\n{\n    vec3 lightDir = normalize(lightPos - lightTarget);\n    vec3 lightVec = lightPos - pos;\n    float lDistSq = dot(lightVec, lightVec);\n    float intensity = 1.0 / (1.0 + attenuationTerm * lDistSq);\n    float lDist = sqrt(lDistSq);\n    lightVec /= lDist;\n    float cutoff = smoothstep(spotCutoff.x, spotCutoff.y, saturate(dot(lightVec, lightDir)));\n    intensity *= cutoff;\n    float dotNL = dot(nor, lightVec);\n    float diff = saturate(dotNL) * intensity;\n\n    float shdw = 1.0;\n    if(diff > 0.001)\n    {\n        shdw = clamp(shadow(pos, lightVec, lDist, 6.0), 0.0, 1.0);\n        diff *= shdw;\n    }\n\n    float pp = saturate(dot(ref, lightVec));\n    float spec = matr.smr.x * shdw * intensity * pow(pp, 128.0 * matr.smr.x);\n\n    return vec2(diff, spec);\n}\n\nvec4 render(vec3 ro, vec3 rd, vec2 uv)\n{\n    vec3 finalCol = vec3(0.0);\n    float rayContribution = 1.0; // current ray contribution to final color\n    vec3 raySpecular = vec3(1.0);// current ray specular contribution\n    float depth = MAX_RAY_TRAVEL;\n    float tt = 0.0;\n    float ff = 1.0;\n    for (int i = 0; i <= MAX_RAY_BOUNCES; i++)\n    {\n        vec3 col = skyCol(rd);\n        vec3 fogColor = col;\n        // sky only\n        if (uv.y > 0.1)\n            return vec4(col, depth);\n\n        // main raymarch\n        int steps = 0;\n        float t = march(ro, rd, MAX_RAY_TRAVEL, steps);\n        // store depth\n        if (i == 0)\n            depth = t;\n\n        // marched to sky\n        if (t >= MAX_RAY_TRAVEL)\n        {\n            // mix ray contribution\n\t       \tfinalCol = mix(finalCol, col * raySpecular, rayContribution);\n            break;\n        }\n\n        vec3 pos = ro + t * rd;\n        vec3 nor = normal(pos);\n\n        // material\n        Material matr = matScene(pos, depth, steps);\n\n        // shade\n        float ao = AO(pos, nor);\n        float dotNV = dot(nor, rd);\n        \n        vec3 ref = reflect(rd, nor);\n        vec3 refCol = skyCol(ref, matr.smr.x); // mimic low frequency reflection\n\n        vec3 surf = vec3(0.0);\n#ifdef AMBIENT_CONTRIBUTION\n        vec3 ambient = ambientCol(nor);\n        surf += (0.6 + 0.4 * nor.y) * ambient * ao * matr.diffColor;\n        // since the ao is visible only below the spheres, lift the ao a bit toward ground\n        surf += 0.15 * materials[0].diffColor * (1.0 - ao);\n#endif\n        \n        vec3 specCol = mix(matr.specColor, refCol, matr.smr.y);\n\n        // first light\n        vec2 lighting = spotLight(pos, nor, ref, matr, dotNV, lightPos, 0.004, orbiterPos, vec2(0.775, 0.875));\n        float diff = lighting.x;\n        float spec = lighting.y;\n        vec3 lightColor = vec3(1.4);\n\n#ifdef DIFFUSE_CONTRIBUTION\n        surf += lightColor * matr.diffColor * saturate(diff - matr.smr.y) * ao;\n#endif\n#ifdef SPECULAR_CONTRIBUTION\n        surf += lightColor * specCol * spec;\n#endif\n        // second light\n        /*\n        lighting = dirLight(pos, nor, ref, matr, dotNV, vec3(1.0, 1.0, 0.0));\n        diff = lighting.x;\n        spec = lighting.y;\n        lightColor = vec3(0.25);\n\n#ifdef DIFFUSE_CONTRIBUTION\n        surf += lightColor * matr.diffColor * saturate(diff - matr.metallic) * ao;\n#endif\n#ifdef SPECULAR_CONTRIBUTION\n        surf += lightColor * specCol * spec;\n#endif\n\t\t*/\n        \n#ifdef FRESNEL_CONTRIBUTION\n        float fresnel = matr.smr.s * pow(saturate(1.0 + dotNV), 2.0);\n        surf += fresnel * mix(specCol, refCol, matr.smr.s) * ao * ao;\n#endif\n        \n#ifdef FOG_CONTRIBUTION\n        // reflected fog might not be correct, but I don't want to store intermediate ray results\n        tt += t;\n        float fog = exp(-0.008 * t * t);\n        ff *= fog;\n        col = mix(fogColor, surf, ff);\n#else\n        float fog = 1.0;\n        col = surf;\n#endif\n\n        // mix ray contribution, tint reflected color\n       \tfinalCol = mix(finalCol, col * raySpecular, rayContribution);\n#ifdef REFLECTION_CONTRIBUTION\n        raySpecular = matr.specColor;\n        rayContribution *= matr.smr.z * fog;\n#else\n        rayContribution = 0.0;\n#endif\n        \n        if (rayContribution <= 0.0)\n            break;\n        \n        // secondary reflected ray\n        rd = ref;\n        ro = pos + rd * 0.01;\n    }\n    \n\treturn vec4(saturate(finalCol), depth);\n}\n\nvec3 perspRay(vec2 uv, vec3 camPos, vec3 camTarget, float fov)\n{\n    fov *= DEG2RAD;\n    float focal = 1.0 / tan(fov * 0.5); // vertical fov\n    \n\tvec3 camForward = normalize(camTarget - camPos);\n\tvec3 camUp = vec3(0.0, 1.0, 0.0);\n\tvec3 camRight = normalize(cross(camForward, camUp));\n\tcamUp = normalize(cross(camRight, camForward));\n\treturn normalize(uv.x * camRight + uv.y * camUp + focal * camForward);\n}\n\nvec3 orthoRay(vec2 uv, inout vec3 camPos, vec3 camTarget, float size)\n{\n\tvec3 camForward = normalize(camTarget - camPos);\n\tvec3 camUp = vec3(0.0, 1.0, 0.0);\n\tvec3 camRight = normalize(cross(camForward, camUp));\n\tcamUp = normalize(cross(camRight, camForward));\n    camPos += (uv.x * camRight * size + uv.y * camUp * size);\n    return camForward;\n}\n\n// maps mouse xy to range, if not pressed returns def\nvec2 mouse(vec2 def, vec4 range)\n{\n    if (iMouse.z <= 0.0)\n        return def;\n    vec2 m = iMouse.xy / iResolution.xy;\n    m.x = mix(range.x, range.y, m.x);\n    m.y = mix(range.z, range.w, m.y);\n    return m;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = (-iResolution.xy + 2.0 * fragCoord) / iResolution.y;\n    vec2 m = mouse(vec2(70.0, 0.0), vec4(100.0, 20.0, 10.0, 0.0));\n\n    sceneInit();\n\n    // camera setup\n\tvec3 camPos = vec3(0.0, 3.0 + sin(time * 0.5) * 1.3, 7.0 + sin(time * 0.5) * 0.5) + vec3(0.0, 0.0, m.y);\n\tvec3 camTarget = vec3(0.0, 2.0 + sin(time * 0.5) * 0.5, 0.0);\n    vec3 ray = perspRay(uv, camPos, camTarget, m.x);\n    //vec3 ray = orthoRay(uv, camPos, camTarget, 4.0);\n\n    // render, depth is stored in col.a\n    vec4 col = render(camPos, ray, uv);\n\n    // vignette\n    vec3 v = vec3(smoothstep(0.4, 4.0, length(uv)));\n    col.rgb *= vec3(1.0) - v * vec3(1.0, 0.8, 0.6);\n    \n    // slight gamma crush\n    fragColor = vec4(pow(col.rgb, vec3(1.1)), col.a);\n    \n    //fragColor = vec4(1.0 - col.aaa / MAX_RAY_TRAVEL, col.a); // visualize depth\n}\n", "image_inputs": [{"id": "MdsXW4", "previewfilepath": "https://soundcloud.com/magic-sword/13-journeys-end-1", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/magic-sword/13-journeys-end-1", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sXfR2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "4sXfzB", "name": "Museum of Planets (lite?)", "author": "Noobenstein", "description": "Combination of \"Fast pseudo-3d Perlin noise\" and \"Museum of random planets\" (both by Luke Rissacher). Originals here: https://www.shadertoy.com/view/MtcGRl https://www.shadertoy.com/view/XttGzj", "tags": ["procedural", "2d", "raymarching", "perlin", "random", "optimization", "planets", "flownoise"], "likes": 16, "viewed": 293, "date": "1496662120", "time_retrieved": "2024-06-20T18:55:55.640948", "image_code": "const float MAX_DEPTH = 3.0;\nconst float START_PLANET = 18.0;\n\nvec2 Rotate(vec2 pos, float angle) {\n\treturn vec2(\n        pos.x * cos(angle) - pos.y * sin(angle),\n        pos.x * sin(angle) + pos.y * cos(angle)\n    );\n}\n\nfloat Cubic(float a, float b, float t) {\n    float blendFactor = t * t * (3.0 - 2.0 * t);\n    return mix(a, b, blendFactor);\n}\n\nvec3 HueToRgb(float h) {\n    vec3 rgb = 2.0 - abs(6.0 * h - vec3(3, 2, 4));\n    rgb.r = 1.0 - rgb.r;\n    return clamp(rgb, 0.0, 1.0);\n}\n\nvec3 HsvToRgb(vec3 hsv) {\n    vec3 rgb = HueToRgb(hsv.x);\n    return ((rgb - 1.0) * hsv.y + 1.0) * hsv.z;\n}\n\n// Gradient noise functions courtesy Inigo Q\nvec2 GetGradient(vec2 intPos, float t) {\n    \n    // Uncomment for calculated rand\n    //float rand = fract(sin(dot(intPos, vec2(12.9898, 78.233))) * 43758.5453);;\n    \n    // Texture-based rand (a bit faster on my GPU)\n    float rand = texture(iChannel0, intPos / 64.0).r;\n    \n    // Rotate gradient: random starting rotation, random rotation rate\n    float angle = 6.283185 * rand + 4.0 * t * rand;\n    return vec2(cos(angle), sin(angle));\n}\n\n\nfloat noise(vec3 pos) {\n    vec2 i = floor(pos.xy);\n    vec2 f = pos.xy - i;\n    vec2 blend = f * f * (3.0 - 2.0 * f);\n    float noiseVal = \n        mix(\n            mix(\n                dot(GetGradient(i + vec2(0, 0), pos.z), f - vec2(0, 0)),\n                dot(GetGradient(i + vec2(1, 0), pos.z), f - vec2(1, 0)),\n                blend.x),\n            mix(\n                dot(GetGradient(i + vec2(0, 1), pos.z), f - vec2(0, 1)),\n                dot(GetGradient(i + vec2(1, 1), pos.z), f - vec2(1, 1)),\n                blend.x),\n        blend.y\n    );\n    return noiseVal / 0.7; // normalize to about [-1..1]\n}\n\n\n\nfloat Rand(vec2 pos) {\n    return fract(sin(dot(pos.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat Rand(float pos) {\n    return Rand(vec2(pos));\n}\n\nfloat SphereDistance(vec3 localPos, float radius) {\n\treturn length(localPos) - radius;\n}\n\nfloat SceneDistance(vec3 pos, out float layer) {\n    if (pos.x < 0.0) {\n        return 1.0;\n    }\n    \n    float planetNumber = floor((pos.x) / 2.0) + START_PLANET;\n    \n    vec3 planetPos = pos;\n    planetPos.x = mod(planetPos.x, 2.0) - 1.0;\n    float rotationSpeed = mix(-1.0, 1.0, fract(planetNumber / 2.3));\n    planetPos.xz = Rotate(planetPos.xz, rotationSpeed * iTime);\n    \n    float terrainDetail = mix(0.1, 5.5, Rand(planetNumber + 0.16));\n    float layerHeight = mix(0.005, 0.05, Rand(planetNumber + 0.55));\n    float layerCount = floor(mix(3.5, 20.5, Rand(planetNumber + 0.36)));\n    float noiseValue = 0.5 * noise((normalize(planetPos) + planetNumber) * terrainDetail) + 0.5;\n    layer = floor(noiseValue * layerCount);\n\t\n\tfloat baseSize = mix(0.2, 0.4, Rand(planetNumber + 0.28));\n    float d1 = SphereDistance(planetPos, baseSize + (layer - 1.0) * layerHeight);\n    float d2 = SphereDistance(planetPos, baseSize + layer * layerHeight);\n    \n    float layerTransition = smoothstep(0.0, 0.3, fract(noiseValue * layerCount) + 0.06);\n    return mix(d1, d2, layerTransition);\n}\n\nfloat SceneDistance(vec3 pos) {\n    float dummy;\n    return SceneDistance(pos, dummy);\n}\n\nfloat RayMarch(vec3 startPos, vec3 dir) {\n\tfloat depth = 0.0;\n    for (int i = 0; i < 64; i++) {\n        vec3 pos = startPos + dir * depth;\n        float dist = SceneDistance(pos);\n        if (dist < 0.0001) {\n        \treturn depth;\n        }\n        depth += 0.6 * dist;\n        if (depth >= MAX_DEPTH) {\n            return MAX_DEPTH;\n        }\n    }\n    return MAX_DEPTH;\n}\n\nvec3 SceneNormal(vec3 pos) {\n\tconst float DX = 0.004;\n\tconst vec3 dx = vec3(DX, 0.0, 0.0);\n    const vec3 dy = vec3(0.0, DX, 0.0);\n    const vec3 dz = vec3(0.0, 0.0, DX);\n    return normalize(vec3(\n        SceneDistance(pos + dx) - SceneDistance(pos - dx),\n        SceneDistance(pos + dy) - SceneDistance(pos - dy),\n        SceneDistance(pos + dz) - SceneDistance(pos - dz)\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tconst float FOV = radians(45.0);\n    vec3 eyePos = vec3(0.5 * iTime - 1.0, 0.0, -2.0);\n    vec2 xy = (2.0 * fragCoord - iResolution.xy) * 0.5;\n    vec3 rayDir = normalize(vec3(xy, 1.0 / tan(0.5 * FOV) * 0.5 * iResolution.y));\n    vec3 lightDir = normalize(vec3(0.5, 0.8, -1.0));\n   \n    float depth = RayMarch(eyePos, rayDir);\n    if (depth < MAX_DEPTH) {\n        \n        vec3 pos = eyePos + rayDir * depth;\n        float layer;\n        vec3 normal = SceneNormal(pos);\n        SceneDistance(pos, layer);\n        \n        float planetNumber = floor((pos.x) / 2.0) + START_PLANET;\n        \n        float baseHue = Rand(planetNumber + 1.72);\n        float hueStep = mix(0.02, 0.15, pow(Rand(planetNumber + 0.492), 2.0));\n        \n        float baseSat = pow(Rand(planetNumber + 0.195), 0.2);\n        float satStep = mix(-0.2, 0.2, Rand(planetNumber + 0.777));\n        \n        float baseVal = mix(0.5, 1.0, pow(Rand(planetNumber + 0.888), 0.3));\n        float valStep = mix(0.0, 0.2, Rand(planetNumber + 0.992));\n        \n        vec3 color = HsvToRgb(\n            vec3(fract(baseHue + layer * hueStep), \n\t             clamp(baseSat + layer * satStep, 0.0, 1.0), \n                 0.3 + 0.7 * fract(baseVal + layer * valStep)));\n        float diffuse = 2.0 * clamp(dot(lightDir, normal), 0.0, 1.0);\n    \tfragColor = vec4(diffuse * color, 1.0);\n    }\n    else {\n        float gradient = abs(2.0 * (fragCoord.y / iResolution.y) - 1.0);\n        vec3 skyColor = HsvToRgb(vec3(fract(0.015 * iTime) + 0.5, 1.0, 0.1 * gradient));\n        fragColor = vec4(skyColor, 1.0);\n    }\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4sXfzB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldcGzS", "name": "Escheristic horses", "author": "Ultraviolet", "description": "Inspired from https://s-media-cache-ak0.pinimg.com/originals/05/c5/e7/05c5e79ebe8df908e8078d6558e5b91f.jpg\nYou can use the mouse to control the zoom.", "tags": ["escher", "tiling", "horse", "copies", "reproductions"], "likes": 22, "viewed": 311, "date": "1498469507", "time_retrieved": "2024-06-20T18:55:57.816898", "image_code": "\n\n// (half) contour\nconst vec2 vert[43] = vec2[](vec2(0,-0),\n                             vec2(-0.066934,0.073242), \n                             vec2(-0.096244,0.12762), \n                             vec2(-0.066934,0.22177), \n                             vec2(-0.056485,0.33263), \n                             vec2(0.094141,0.38494), \n                             vec2(0.19246,0.44143), \n                             vec2(0.11297,0.52929), \n                             vec2(-0.033483,0.56905), \n                             vec2(-0.056485,0.53974), \n                             vec2(0.043933,0.47909), \n                             vec2(-0.060658,0.40167), \n                             vec2(-0.16735,0.53557), \n                             vec2(-0.094141,0.65271), \n                             vec2(0.077416,0.67992), \n                             vec2(0.14435,0.83265), \n                             vec2(0.24477,0.95607), \n                             vec2(0.30963,1.0439), \n                             vec2(0.1548,1.0544), \n                             vec2(0.0,1), \n                             vec2(0.079487,1.09), \n                             vec2(0.014655,1.1422), \n                             vec2(0.03138,1.2531), \n                             vec2(0.16318,1.2803), \n                             vec2(0.24894,1.3096), \n                             vec2(0.3117,1.3159), \n                             vec2(0.32846,1.364), \n                             vec2(0.36819,1.318), \n                             vec2(0.4456,1.3054), \n                             vec2(0.61923,1.2824), \n                             vec2(0.61506,1.2197), \n                             vec2(0.66527,1.136), \n                             vec2(0.7092,1.092), \n                             vec2(0.70502,1.0649), \n                             vec2(0.63806,0.9749), \n                             vec2(0.48953,0.8452), \n                             vec2(0.4456,0.71758), \n                             vec2(0.54185,0.68409), \n                             vec2(0.64854,0.66319), \n                             vec2(0.62133,0.77196), \n                             vec2(0.74896,0.85775), \n                             vec2(0.88493,0.93096), \n                             vec2(1.0,1.0));\n\n\n// details (represented as 1 single contour for simplicity)\nconst vec2 det[197] = vec2[](\n                            vec2(0.90106,-0.082627),\n                            vec2(1.0248,0.0075632),\n                            vec2(0.90311,-0.079755),\n                            vec2(0.77286,-0.17864),\n                            vec2(0.68331,-0.25935),\n                            vec2(0.6938,-0.34666),\n                            vec2(0.65268,-0.33832),\n                            vec2(0.54527,-0.31598),\n                            vec2(0.44902,-0.28249),\n                            vec2(0.49295,-0.15487),\n                            vec2(0.55592,-0.10055),\n                            vec2(0.50339,-0.09118),\n                            vec2(0.55527,-0.10103),\n                            vec2(0.64418,-0.024416),\n                            vec2(0.51365,-0.01939),\n                            vec2(0.64148,-0.025166),\n                            vec2(0.70729,0.063619),\n                            vec2(0.52041,0.056996),\n                            vec2(0.70844,0.064794),\n                            vec2(0.71262,0.091974),\n                            vec2(0.66869,0.1359),\n                            vec2(0.52323,0.11563),\n                            vec2(0.66969,0.13964),\n                            vec2(0.61848,0.21959),\n                            vec2(0.51691,0.20233),\n                            vec2(0.61918,0.21823),\n                            vec2(0.62265,0.28235),\n                            vec2(0.44889,0.30528),\n                            vec2(0.51704,0.23839),\n                            vec2(0.5199,0.15744),\n                            vec2(0.52367,0.064497),\n                            vec2(0.51128,-0.050781),\n                            vec2(0.49314,-0.15332),\n                            vec2(0.51149,-0.05024),\n                            vec2(0.52346,0.064667),\n                            vec2(0.52052,0.15831),\n                            vec2(0.51594,0.23975),\n                            vec2(0.44902,0.30536),\n                            vec2(0.37142,0.31567),\n                            vec2(0.37547,0.28106),\n                            vec2(0.36137,0.26746),\n                            vec2(0.37519,0.28121),\n                            vec2(0.37161,0.31791),\n                            vec2(0.33188,0.36394),\n                            vec2(0.32632,0.34797),\n                            vec2(0.34413,0.31933),\n                            vec2(0.34757,0.2892),\n                            vec2(0.33379,0.26771),\n                            vec2(0.34748,0.29045),\n                            vec2(0.3442,0.32047),\n                            vec2(0.32571,0.34736),\n                            vec2(0.31512,0.31584),\n                            vec2(0.30578,0.28931),\n                            vec2(0.30406,0.26799),\n                            vec2(0.32059,0.22776),\n                            vec2(0.32034,0.21043),\n                            vec2(0.32035,0.22748),\n                            vec2(0.26329,0.23816),\n                            vec2(0.24109,0.26012),\n                            vec2(0.22483,0.24894),\n                            vec2(0.23993,0.25952),\n                            vec2(0.25707,0.27098),\n                            vec2(0.30386,0.26814),\n                            vec2(0.30433,0.28921),\n                            vec2(0.31554,0.31352),\n                            vec2(0.25236,0.30956),\n                            vec2(0.1666,0.28025),\n                            vec2(0.034805,0.25308),\n                            vec2(0.030179,0.22242),\n                            vec2(0.077108,0.22381),\n                            vec2(0.074181,0.2043),\n                            vec2(0.030134,0.22326),\n                            vec2(0.018075,0.14218),\n                            vec2(0.084837,0.089569),\n                            vec2(0.11915,0.097959),\n                            vec2(0.082915,0.089903),\n                            vec2(-0.0025677,-6.5609e-05),\n                            vec2(0.15822,0.054315),\n                            vec2(0.31362,0.043885),\n                            vec2(0.3884,0.07841),\n                            vec2(0.43726,0.15746),\n                            vec2(0.38916,0.079136),\n                            vec2(0.31305,0.043865),\n                            vec2(0.24819,-0.043995),\n                            vec2(0.14777,-0.16742),\n                            vec2(0.080888,-0.32135),\n                            vec2(0.074893,-0.36311),\n                            vec2(0.080845,-0.32015),\n                            vec2(-0.090715,-0.34736),\n                            vec2(-0.16393,-0.4645),\n                            vec2(-0.057235,-0.5984),\n                            vec2(0.047355,-0.52098),\n                            vec2(-0.0099704,-0.48725),\n                            vec2(-0.098806,-0.54886),\n                            vec2(-0.0094202,-0.48841),\n                            vec2(-0.055624,-0.46084),\n                            vec2(-0.099665,-0.4635),\n                            vec2(-0.055028,-0.46012),\n                            vec2(-0.035162,-0.43163),\n                            vec2(-0.042237,-0.39288),\n                            vec2(-0.033727,-0.43134),\n                            vec2(0.11639,-0.47077),\n                            vec2(0.19626,-0.55953),\n                            vec2(0.21725,-0.49512),\n                            vec2(0.19588,-0.55863),\n                            vec2(0.097565,-0.61512),\n                            vec2(-0.053055,-0.66743),\n                            vec2(-0.063505,-0.77829),\n                            vec2(-0.092815,-0.87244),\n                            vec2(-0.063505,-0.92682),\n                            vec2(0.0034248,-1.0038),\n                            vec2(0.082915,-0.91383),\n                            vec2(0.039776,-0.88191),\n                            vec2(-0.037953,-0.95721),\n                            vec2(0.040105,-0.8818),\n                            vec2(0.015333,-0.86276),\n                            vec2(-0.013385,-0.87653),\n                            vec2(0.015834,-0.8629),\n                            vec2(0.031838,-0.7511),\n                            vec2(0.0063407,-0.71769),\n                            vec2(0.031542,-0.75074),\n                            vec2(0.1666,-0.72348),\n                            vec2(0.25236,-0.69417),\n                            vec2(0.31512,-0.68789),\n                            vec2(0.34387,-0.57387),\n                            vec2(0.32896,-0.64211),\n                            vec2(0.37161,-0.68582),\n                            vec2(0.44902,-0.69837),\n                            vec2(0.623,-0.72085),\n                            vec2(0.66386,-0.65508),\n                            vec2(0.6213,-0.72581),\n                            vec2(0.61848,-0.78414),\n                            vec2(0.66869,-0.86783),\n                            vec2(0.71262,-0.91176),\n                            vec2(0.70844,-0.93894),\n                            vec2(0.64148,-1.0289),\n                            vec2(0.49295,-1.1586),\n                            vec2(0.44902,-1.2862),\n                            vec2(0.4925,-1.3022),\n                            vec2(0.51582,-1.2356),\n                            vec2(0.47125,-1.2109),\n                            vec2(0.51602,-1.2353),\n                            vec2(0.55933,-1.1526),\n                            vec2(0.70232,-1.0529),\n                            vec2(0.77397,-0.95581),\n                            vec2(0.71159,-0.91187),\n                            vec2(0.77337,-0.95437),\n                            vec2(0.7009,-1.0515),\n                            vec2(0.55852,-1.1528),\n                            vec2(0.51422,-1.2402),\n                            vec2(0.62801,-1.2606),\n                            vec2(0.51456,-1.2401),\n                            vec2(0.49324,-1.3029),\n                            vec2(0.54276,-1.3205),\n                            vec2(0.65196,-1.3406),\n                            vec2(0.62475,-1.2318),\n                            vec2(0.75238,-1.146),\n                            vec2(0.88835,-1.0728),\n                            vec2(1.0034,-1.0038),\n                            vec2(0.93723,-0.92682),\n                            vec2(0.90792,-0.87244),\n                            vec2(0.93723,-0.77829),\n                            vec2(0.94768,-0.66743),\n                            vec2(1.0983,-0.61512),\n                            vec2(1.1966,-0.55863),\n                            vec2(1.1171,-0.47077),\n                            vec2(1.0153,-0.44313),\n                            vec2(1.1081,-0.51535),\n                            vec2(1.0797,-0.56628),\n                            vec2(0.97079,-0.62794),\n                            vec2(1.0796,-0.5657),\n                            vec2(1.1076,-0.51499),\n                            vec2(1.0156,-0.44376),\n                            vec2(0.97068,-0.43101),\n                            vec2(0.94768,-0.46032),\n                            vec2(1.0481,-0.52097),\n                            vec2(0.9435,-0.59839),\n                            vec2(0.83681,-0.46449),\n                            vec2(0.75549,-0.50029),\n                            vec2(0.66622,-0.48935),\n                            vec2(0.75619,-0.4978),\n                            vec2(0.83779,-0.46475),\n                            vec2(0.90486,-0.34559),\n                            vec2(0.80353,-0.33633),\n                            vec2(0.91002,-0.34735),\n                            vec2(1.08,-0.31943),\n                            vec2(1.101,-0.27377),\n                            vec2(0.87067,-0.27214),\n                            vec2(1.0966,-0.2737),\n                            vec2(1.1446,-0.16405),\n                            vec2(0.97482,-0.16882),\n                            vec2(1.1485,-0.16741),\n                            vec2(1.2466,-0.042572),\n                            vec2(1.0354,-0.060845),\n                            vec2(1.2489,-0.043995),\n                            vec2(1.3138,0.043865),\n                            vec2(1.1545,0.054315));\n\n\nconst vec2 textureTiles[3] = vec2[](vec2(0.0), vec2(0.0, 1.0), vec2(-1.0, 0.0));\nconst vec2 detailTiles[5] = vec2[](vec2(0.0), vec2(0.0,-1.0), vec2(0.0,-2.0), vec2(1.0,-1.0), vec2(-1.0,-1.0));\n\nfloat PointSegDistance2(vec2 p, vec2 p0, vec2 p1)\n{\n    vec2 d = p1 - p0;\n    \n    float t = clamp(dot(p - p0, d) / dot(d, d), 0.0, 1.0);\n\n    vec2 proj = (1.0-t)*p0 + t*p1;\n    \n    return dot(proj-p, proj-p);\n}\n\nfloat horizontalDistance(vec2 p, vec2 p0, vec2 p1)\n{\n    if(p.y < min(p0.y, p1.y) || p.y > max(p0.y, p1.y))\n        return 100000000.0*sign(p1.y-p0.y);\n    \n    float h = p.y-p0.y;\n    float slope = (p1.x-p0.x)/(p1.y-p0.y);\n    float l = p.x-h*slope - p0.x;\n    \n    return l*sign(p1.y-p0.y);\n}\n\n\n\nfloat verticalDistance(vec2 p, vec2 p0, vec2 p1)\n{\n    if(p.x < min(p0.x, p1.x) || p.x > max(p0.x, p1.x))\n        return 100000000.0*sign(p1.x-p0.x);\n    \n    float h = p.x-p0.x;\n    float slope = (p1.y-p0.y)/(p1.x-p0.x);\n    float l = p.y-h*slope - p0.y;\n    \n    return l*sign(p1.x-p0.x);\n}\n\n\nfloat escherTextureX(vec2 p)\n{\n    vec2 pp = vec2(mod(p.x+0.5, 1.0)-0.5, mod(p.y,2.0));\n    \n    float d = 1000.0;\n    \n    for(int i=0; i<19; ++i)\n    \tif(abs(horizontalDistance(pp, vert[i], vert[i+1])) < abs(d))\n        {\n            d = horizontalDistance(pp, vert[i], vert[i+1]);\n        }\n    \n    pp = vec2(mod(p.x+0.5, 1.0)-0.5, mod(p.y-1.0,2.0));\n    \n    for(int i=0; i<19; ++i)\n    \tif(abs(horizontalDistance(pp, vert[i], vert[i+1])) < abs(d))\n        {\n            d = horizontalDistance(pp, vert[i], vert[i+1]);\n        }\n    \n    float val = smoothstep(0.0, 1.0, d/0.05);\n    val = d;\n    \n    \n    if(mod(p.x-0.5, 2.0)-1.0 > 0.)\n        val = -val;\n    \n    return val;\n}\n\n\nfloat escherTextureY(vec2 p)\n{\n    vec2 pp = vec2(mod(p.x, 2.0), mod(p.y-.5, 1.0)+0.5);\n    \n    float d = 1000.0;\n    for(int i=19; i<vert.length()-1; ++i)\n    \tif(abs(verticalDistance(pp, vert[i], vert[i+1])) < abs(d))\n            d=verticalDistance(pp, vert[i], vert[i+1]);\n    \n\n    pp = vec2(mod(p.x-1.0, 2.0), mod(p.y-.5, 1.0)+0.5);\n    for(int i=19; i<vert.length()-1; ++i)\n    \tif(abs(verticalDistance(pp, vert[i], vert[i+1])) < abs(d)) \n            d=verticalDistance(pp, vert[i], vert[i+1]);\n    \n    float val = smoothstep(0.0, 1.0, d/0.05);\n    val = d;\n    \n    if(mod(p.y-0.5, 2.0)-1.0 > 0.)\n        val = -val;\n    \n    return val;\n}\n\n\nfloat escherTexture(vec2 p, float pixel_size)\n{\n    float x = escherTextureX(p);\n    float y = escherTextureY(p);\n    \n    x = smoothstep(-1.0, 1.0, x/pixel_size);\n    y = smoothstep(-1.0, 1.0, y/pixel_size);\n    \n    float d = x+y - 2.0 * x*y;\n    \n    return d;\n}\n\nfloat escherTextureContour(vec2 p, float linewidth, float pixel_size)\n{\n    vec2 pp = mod(p,1.0);\n    \n    float d = 10000000.0;\n    for(int i=0; i<vert.length()-1; ++i)\n    {\n        //*\n        for(int j=0; j<textureTiles.length(); ++j)\n        {\n            d = min(d, PointSegDistance2(pp+textureTiles[j], vert[i], vert[i+1]));\n        }\n        /*/\n    \td = min(d, PointSegDistance2(pp, vert[i], vert[i+1]));\n    \td = min(d, PointSegDistance2(pp-vec2(1.0, 0.0), vert[i], vert[i+1]));\n    \td = min(d, PointSegDistance2(pp+vec2(0.0, 1.0), vert[i], vert[i+1]));\n        //*/\n    }\n    \n    d = smoothstep(0.0, 1.0, (sqrt(d)-linewidth)/pixel_size);\n    \n    return d;\n}\n\n\nfloat ToroidalDistance (vec2 p0, vec2 p1)\n{\n    float dx = abs(p1.x - p0.x);\n    float dy = abs(p1.y - p0.y);\n \n    dx = min(dx, 1.0 - dx);\n    dy = min(dy, 1.0 - dy);\n \n    return dx*dx+dy*dy;\n}\n\nfloat PointSegToroidalDistance(vec2 p, vec2 p0, vec2 p1)\n{\n    vec2 d = p1 - p0;\n    \n    float t = clamp(dot(p - p0, d) / dot(d, d), 0.0, 1.0);\n\n    vec2 proj = (1.0-t)*p0 + t*p1;\n    \n    return dot(proj-p, proj-p);\n}\n\nfloat escherTextureContour_(vec2 p, float linewidth, float pixel_size)\n{\n    vec2 pp = mod(p,1.0);\n    \n    float d = 10000000.0;\n    for(int i=0; i<vert.length()-1; ++i)\n    {\n        // d = min(d, ToroidalDistance(pp, vert[i]));\n        d = min(d, PointSegToroidalDistance(pp, vert[i], vert[i+1]));\n    }\n    \n    d = smoothstep(0.0, 1.0, (sqrt(d)-linewidth)/pixel_size);\n    \n    return d;\n}\n\n\nfloat escherDetails(vec2 p, float linewidth, float pixel_size)\n{\n    vec2 pp = mod(p,1.0);\n    \n    float d = 10000000.0;\n    for(int i=0; i<det.length(); ++i)\n    {\n        //*\n        for(int j=0; j<detailTiles.length(); ++j)\n        {\n            d = min(d, PointSegDistance2(pp+detailTiles[j], det[i], det[i+1]));\n        }\n\t\t/*/\n        d = min(d, PointSegDistance2(pp+vec2( 0.0, 0.0), det[i], det[i+1]));\n    \td = min(d, PointSegDistance2(pp-vec2( 0.0, 1.0), det[i], det[i+1]));\n    \td = min(d, PointSegDistance2(pp-vec2( 0.0, 2.0), det[i], det[i+1]));\n    \td = min(d, PointSegDistance2(pp+vec2( 1.0,-1.0), det[i], det[i+1]));\n    \td = min(d, PointSegDistance2(pp+vec2(-1.0,-1.0), det[i], det[i+1]));\n\t\t//*/\n    }\n    \n    d = smoothstep(0.0, 1.0, (sqrt(d)-linewidth)/pixel_size);\n    \n    return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    \n    uv -= vec2(0.5* iResolution.x / iResolution.y, 0.5);\n    float zoom = iMouse.y / iResolution.y * 10.0;\n    \n    if(iMouse.y < 5.0)\n        zoom = 4.0 + sin(iTime);\n    \n    uv *= zoom;\n    \n    float pixel_size = 1.5*zoom/iResolution.y;\n    float t = escherTexture(uv, pixel_size);\n    \n    float line = escherTextureContour(uv, 0.01, pixel_size);\n\tfragColor = vec4(vec3(0.8, vec2(0.8-0.5*t))*line,1.0);\n    \n    float details = escherDetails(uv, 0.001, pixel_size);\n\tfragColor = vec4(vec3(0.8, vec2(0.8-0.5*t))*line*details,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldcGzS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldfBDS", "name": "infinite candyland (melting)", "author": "nexor", "description": "raymarched twisted cylinders.", "tags": ["raymarching"], "likes": 5, "viewed": 167, "date": "1497793112", "time_retrieved": "2024-06-20T18:55:57.816898", "image_code": "#define pi 3.141569\n#define pi2 (pi*2.)\n#define up vec3(.0,1.,.0)\n#define sin1(x) (sin(x)*.5+.5)\n#define cos1(x) (cos(x)*.5+.5)\n#define saw(x) (abs(fract((x))*4.-2.)-1.)\n#define rpt(x,c) (mod(x,c)-.5*c)\n\n\nmat2 rot2(float a)\n{\n\tfloat c=cos(a),s=sin(a);\n\treturn mat2(c,-s,s,c);\n}\n\nmat3 rot(float a,float x,float y,float z)\n{\n\tfloat s=sin(a),c=cos(a);\n\treturn mat3(\n\t\tx+c*y+c*z,s*z,s*y,\n\t\t-s*z,y+c*x+c*z,s*x,\n\t\t-s*y,-s*x,z+c*x+c*y);\n}\n\nfloat plane(vec3 p,vec3 n,float d)\n{\n\treturn dot(p,n)+d;\n}\n\nfloat sphere(vec3 p,float r)\n{\n\treturn length(p)-r;\n}\n\nfloat box(vec3 p,vec3 b)\n{\n\treturn length(max(abs(p)-b,vec3(.0)));\n}\n\nfloat box(vec3 p,float b)\n{\n\treturn box(p,vec3(b));\n}\n\nfloat cylinder(vec3 p,vec3 c)\n{\n\treturn length(p.yz-c.xy)-c.z;\n}\n\nvec2 opU(vec2 a,vec2 b)\n{\n\treturn mix(b,a,step(a.x,b.x));\n}\n\nvec2 map(vec3 p)\n{\n\tfloat m=-1.;\n\tvec3 q=p;\n\tvec2 res=vec2(-1.);\n\tp.y-=-abs(sin(p.z*3.+iTime*.25))*.5\n\t+sin(iTime*2.+p.x*1.5+p.z*.2)*.1\n\t;\n\tres=vec2(100.,m++);\n\tres=opU(res,vec2(plane(p,up,1.),m++));\n\tq-=vec3(.0,3.,-20.);\n    \n\tq.xz*=rot2(pi/4.);\n\tq.z=rpt(q.z,5.);\n    q.y-=sin(q.x)*.5;\n    q.x-=iTime*.2;\n\tp=q;\n\tq.z-=cos(q.x*3.)*.3;\n\tq.y-=sin(q.x*3.)*.3;\n\tres=opU(res,vec2(\n\t\tcylinder(q,vec3(.2)),m++));\n\tq=p;\n\tq.x-=1.5;\n\tq.z-=cos(q.x*3.)*.3;\n\tq.y-=sin(q.x*3.)*.3;\n\tres=opU(res,vec2(\n\t\tcylinder(q,vec3(.2)),m++));\n\tq=p;\n\tq.x-=1.;\n\tq.z-=cos(q.x*3.)*.3;\n\tq.y-=sin(q.x*3.)*.3;\n\tres=opU(res,vec2(\n\t\tcylinder(q,vec3(.2)),m++));\n\tq=p;\n\tq.x-=.5;\n\tq.z-=cos(q.x*3.)*.3;\n\tq.y-=sin(q.x*3.)*.3;\n\tres=opU(res,vec2(\n\t\tcylinder(q,vec3(.2)),m++));\n\treturn res;\n}\n\nvec3 norm(vec3 p)\n{\n\tvec2 e=vec2(1.,-1.)*.5773*.00125;\n\treturn normalize(\n\t\te.xyy*map(p+e.xyy).x+\n\t\te.yxy*map(p+e.yxy).x+\n\t\te.yyx*map(p+e.yyx).x+\n\t\te.xxx*map(p+e.xxx).x);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n\trd=normalize(rd);\n\tfloat res = 1.0;\n\tfor( float t=mint; t < maxt; )\n\t{\n\t\tfloat h = map(ro + rd*t).x;\n\t\tif( h<0.00025 ) return 0.0;\n\t\tres = min( res, k*h/t );\n\t\tt += h*.5;\n\t}\n\treturn res;\n}\n\nmat3 material(float m)\n{\n\tmat3 colm=mat3(.0);\n\tcolm[0]=vec3(1.,cos1(m*pi/6.),.0);\n\tcolm[1]=vec3(.5*cos1(m*pi/4.),sin1(m*pi/2.),sin1(m*pi/2.+pi/4.));\n\tcolm[2]=vec3(1.);\n\treturn colm;\n}\n\nvec3 shade(vec3 lig,vec3 p,vec3 rd,vec3 nor,float tmin,float tmax,float spec,float k)\n{\n\tfloat a=1.;\n\tfloat d=max(dot(nor,-lig),.0);\n\tfloat s=pow(max(dot(rd,reflect(-lig,nor)),.0),spec);\n\treturn vec3(a,d,s)*softshadow(p,-lig,tmin,tmax,k);\n}\n\nvec3 color(float m,vec3 ro,vec3 rd,float t,float tmin,float tmax)\n{\n\tvec3 col=vec3(.0);\n\tvec3 p=ro+t*rd;\n\tvec3 nor=norm(p);\n\tmat3 mtr=material(m);\n\tvec3 lig1=normalize(vec3(6.,-5.,-6.));\n\tvec3 lig2=normalize(vec3(-8.,-7.,3.5));\n\tcol+=mtr*\n\t\t(shade(lig1,p,rd,nor,tmin,tmax,60.,5.)\n\t\t+shade(lig2,p,rd,nor,tmin,tmax,90.,2.)\n\t\t)*vec3(.3,.3,1.);\n\treturn col;\n}\n\nvec3 render(vec3 ro, vec3 rd)\n{\n\tvec3 col=vec3(.5);\n\n\tfloat tmin=.0;\n\tfloat tmax=90.;\n\n\tfloat t=tmin;\n\tfloat m=-1.;\n\tfor(float i=0.;i<25.;i++)\n\t{\n\t\tfloat precis=.00125*t;\n\t\tvec2 res=map(ro+t*rd);\n\t\tif(res.x<precis||t>tmax)break;\n\t\tt+=res.x*.5;\n\t\tm=res.y;\n\t}\n\tm=mix(-1.,m,step(t,tmax));\n\tcol=color(m,ro,rd,t,tmin,tmax);\n\tcol=mix(vec3(.8,.9,1.),col,exp(-t*t*.0007));\n\treturn col;\n}\n\nmat3 camera(vec3 ro, vec3 ta, float cr)\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr),cos(cr),.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = normalize(cross(cu,cw));\n\treturn mat3(cu,cv,cw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n\tvec3 col = vec3(.0);\n\tvec2 p=(-iResolution.xy+2.*fragCoord.xy)/iResolution.y;\n\tvec2 q=iMouse.xy/iResolution.xy;\n\tq=-1.+2.*q;\n\tq*=2.;\n    q.x+=5.;\n\tvec3 ro =vec3(.0,9.,-3.);\n\tvec3 to = vec3(-6.*sin(q.x),7.,-6.*cos(q.x));\n\tmat3 ca = camera(ro,to,.0);\n\tvec3 rd = ca*normalize(vec3(p,3.));\n\n\tcol=render(ro,rd);\n    col=pow(col,vec3(1./2.2));\n\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldfBDS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldfBzM", "name": "Playing with Raymarching", "author": "shanesimmsart", "description": "raymarching", "tags": ["alittletestsceneforplayingwithdifferentraymarchingtechniques"], "likes": 7, "viewed": 559, "date": "1498353179", "time_retrieved": "2024-06-20T18:55:58.550220", "image_code": "float sdSphere(vec3 p, float s)\n{\n  return length(p)-s;\n}\n\nfloat sdTorus(vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat opU(float d1, float d2)\n{\n    return min(d1,d2);\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nfloat displacement(vec3 p)\n{\n    float freq = 40.0;\n    float gain = 0.05;\n    float trans = iTime/5.0;\n    return sin(freq*p.x)*sin(freq*(p.y+trans))*sin(freq*p.z)*gain;\n}\n\nvec3 opTwist(vec3 p)\n{\n    float c = cos(5.0*p.y);\n    float s = sin(5.0*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);;\n}\n\nfloat map(vec3 p)\n{\n    vec3 c = vec3(2.0);\n    vec3 q1 = opRep(p, c);\n    //q = opTwist(q);\n    \n    float radius = 0.3;\n    \n    float sphere1 = sdSphere(q1, radius);\n    \n    float d1 = displacement(p);\n    \n    float dispSphere = sphere1 + d1;\n    \n    vec3 q2 = p;\n    \n    q2 = opTwist(q2);\n    \n    q2.xy *= mat2(cos(iTime), -sin(iTime), sin(iTime), cos(iTime));\n    q2.yz *= mat2(cos(iTime), -sin(iTime), sin(iTime), cos(iTime));\n    \n    float torus1 = sdTorus(q2, vec2(0.5, 0.2));\n    \n    float res = opU(dispSphere, torus1);\n    \n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*(map( pos + e.xyy )) + \n\t\t\t\t\t  e.yyx*(map( pos + e.yyx )) + \n\t\t\t\t\t  e.yxy*(map( pos + e.yxy )) + \n\t\t\t\t\t  e.xxx*(map( pos + e.xxx )) );\n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr)\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nfloat trace(vec3 o, vec3 r)\n{\n    float t = 0.0;\n    for (int i = 0; i < 128; i++)\n    {\n        vec3 p = o + r * t;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    \n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv = uv* 2.0 - 1.0;\n    \n    uv.x *= iResolution.x / iResolution.y;\n    \n    \n    \n    // CAMERA SET-UP\n    vec4 m = (iMouse / iResolution.xxxx) * 2.0 - vec4(1.0);\n    \n    // camera\t\n    vec3 o = vec3( -0.5+3.5*cos(0.1*iTime + 6.0*m.x), 1.0 + 2.0*m.y, 0.5 + 4.0*sin(0.1*iTime + 6.0*m.x) );\n    vec3 ta = vec3( 0.0 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( o, ta, 0.0 );\n    \n    vec3 r = ca * normalize( vec3(uv.xy,3.0) );\n    \n    \n    \n    float t = trace(o, r);\n    \n    vec3 pos = o + r*t;\n    vec3 nor = calcNormal(pos);\n    \n    float fog = 5.0 / (5.0 + t * t *0.1);\n    \n    vec3 lig = normalize(vec3(-1.0, -1.0, 0.0));\n    \n    float ambient = 0.1;\n    float dif = clamp( dot( nor, lig ), ambient, 1.0 );\n    float inten = 2.0;\n    \n    vec3 n = nor;\n    \n    n.xy = nor.xy * 0.5 + vec2(0.5);\n    n.z = nor.z * 0.5 + 1.0;\n    \n    vec3 kd = n * dif * .18;\n    \n    vec3 ref = reflect(r, nor);\n    float exponent = 32.0;\n    float fre = pow( clamp(1.0+dot(nor,r),0.0,1.0), 2.0 );\n    float ks = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),exponent) * fre;\n    \n    float exposure = 10.0;\n    \n    vec3 col = (kd+ks)*exposure*fog;\n    \n\tfragColor = vec4((col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldfBzM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldfBzs", "name": "limits of analytic isolines", "author": "ollj", "description": "contour isolines from Analytical derivatives.\n\ntanh() has its limits in precision, limiting the utility of isolines.\nmost noticable when you hold left mouse button near the top left corner.\ntanh(x) has an upper bound for x,if mouse is close to top border.", "tags": ["noise", "contour", "isoline"], "likes": 6, "viewed": 546, "date": "1497529772", "time_retrieved": "2024-06-20T18:55:58.956321", "image_code": "//grandparent: https://www.shadertoy.com/view/MdfcRS (not analytical derivatives)\n//parent:      https://www.shadertoy.com/view/XdlyzS (    analytical derivatives)\n\n//this just makes things more variable, for mouse input:\n//- iscount, number of isolines\n//- isoblur, thickness of isolines\n\n#define tau acos(-1.)\n\n// --- noise from procedural pseudo-Perlin ( adapted from IQ )\n\nfloat noise3( vec3 x , out vec2 g) {\n    vec3 p = floor(x),f = fract(x),\n        F = f*f*(3.-2.*f);  // or smoothstep     // to make derivative continuous at borders\n\n#define hash3(p)  fract(sin(1e3*dot(p,vec3(1,57,-13.7)))*4375.5453)        // rand\n    float v000 = hash3(p+vec3(0,0,0)), v100 = hash3(p+vec3(1,0,0)),\n          v010 = hash3(p+vec3(0,1,0)), v110 = hash3(p+vec3(1,1,0)),\n          v001 = hash3(p+vec3(0,0,1)), v101 = hash3(p+vec3(1,0,1)),\n          v011 = hash3(p+vec3(0,1,1)), v111 = hash3(p+vec3(1,1,1));\n    g.x = 6.*f.x*(1.-f.x)                        // gradients\n          * mix( mix( v100 - v000, v110 - v010, F.y),\n                 mix( v101 - v001, v111 - v011, F.y), F.z);\n    g.y = 6.*f.y*(1.-f.y)\n          * mix( mix( v010 - v000, v110 - v100, F.x),\n                 mix( v011 - v001, v111 - v101, F.x), F.z);\n    \n    return mix( mix(mix( v000, v100, F.x),       // triilinear interp\n                    mix( v010, v110, F.x),F.y),\n                mix(mix( v001, v101, F.x),       \n                    mix( v011, v111, F.x),F.y), F.z);}\n\n\nfloat noise(vec3 x, out vec2 g) {     // pseudoperlin improvement from foxes idea \n    vec2 g0,g1;\n    float n = (noise3(x,g0)+noise3(x+11.5,g1)) / 2.;\n    g = (g0+g1)/2.;\n    return n;}\n\n//#define camLens 1.\n//#define frame(u) camLens*(u-.5*iResolution.xy)/iResolution.y\n\n\nvoid mainImage( out vec4 O, vec2 U ) // ------------ draw isovalues\n{\n    vec2 m=iMouse.xy/iResolution.xy;\n    float t=iTime*.5;\n    if(iMouse.z<=0.)m=(vec2(sin(t),cos(t*.61))*.5+.5)*.7;//if mouse is not down\n    float isoblur  =(m.y+1./iResolution.y)*9.;\n    float isocount = m.x*90.;\n\n    float tauc=tau*isocount;\n    vec2 R = iResolution.xy;\n    vec2 V=U;\n    U *= 8./R.y;\n    vec2 g;\n    float n = noise(vec3(U,.1*iTime), g);\n    float taun=tauc*n;\n    float v = sin(taun);\n    //if top half\n    if(V.y/iResolution.y>0.5) g*=tauc*cos(taun) * 8./R.y; //analytic derivatives\n    //if bottom half\n      else g*= (fwidth(n)               )*R.y;  //fast derivatives (look much worse here)\n    //else g*= (abs(dFdx(n))+abs(dFdy(n))*R.y); //fast derivatives (look much worse here)\n    //\n    //O = vec4( sin(10.*atan(g.y,g.x)), v, 0,0); return; //optional  debug\n    //\n    //v = tanh(isoblur*abs(v) / (abs(g.x)+abs(g.y))); // better antialiasing than smoothstep\n    v=tanh(min(isoblur*abs(v)/(abs(g.x)+abs(g.y)),isocount)); // some systems dislike tanh(big)\n    n=floor(n*isocount)/isocount;\n\tO=v*(.6+cos(10.*n+vec4(0,2.1,-2.1,0)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldfBzs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldffDf", "name": "Truchet Flythrough", "author": "dr2", "description": "Metallic spaghetti layout from Shane's \"Simplex Truchet Tubing\" (use mouse to look around). Hopefully the drone doesn't crash.\n", "tags": ["truchet", "tube", "flight", "drone"], "likes": 9, "viewed": 687, "date": "1498494768", "time_retrieved": "2024-06-20T18:55:58.968471", "image_code": "// \"Truchet Flythrough\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrRCylDf (vec3 p, float r, float rt, float h);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashfv3 (vec3 p);\nfloat Noisefv3 (vec3 p);\n\nvec3 dronePos, ltPos;\nvec2 aTilt;\nfloat dstFar, tCur;\nint idObj;\nconst int idDrBod = 11, idDrLamp = 12, idDrCam = 13;\nconst float pi = 3.14159;\n\nfloat DroneDf (vec3 p, float dMin)\n{\n  vec3 q, qq;\n  float d;\n  const float dSzFac = 50.;\n  dMin *= dSzFac;\n  qq = dSzFac * (p - dronePos);\n  qq.yz = Rot2D (qq.yz, - aTilt.y);\n  qq.yx = Rot2D (qq.yx, - aTilt.x);\n  q = qq;\n  q.y -= 0.05;\n  d = PrRCylDf (q.xzy, 0.2, 0.03, 0.07);\n  if (d < dMin) { dMin = d;  idObj = idDrBod; }\n  q.y -= 0.07;\n  d = PrRoundBoxDf (q, vec3 (0.06, 0.02, 0.12), 0.04);\n  if (d < dMin) { dMin = d;  idObj = idDrLamp; }\n  q = qq;\n  q.y -= -0.05;\n  d = PrSphDf (q, 0.17);\n  if (d < dMin) { dMin = d;  idObj = idDrCam; }\n  q = qq;\n  q.xz = abs (q.xz) - 0.7;\n  d = min (PrCylAnDf (q.xzy, 0.5, 0.05, 0.05), PrCylDf (q.xzy, 0.1, 0.03));\n  q -= vec3 (-0.4, -0.15, -0.4);\n  d = min (d, PrRCylDf (q.xzy, 0.05, 0.03, 0.2));\n  q -= vec3 (-0.3, 0.2, -0.3);\n  q.xz = Rot2D (q.xz, 0.25 * pi);\n  d = min (d, min (PrRCylDf (q, 0.05, 0.02, 1.), PrRCylDf (q.zyx, 0.05, 0.02, 1.)));\n  if (d < dMin) { dMin = d;  idObj = idDrBod; }\n  return dMin / dSzFac;\n}\n\nmat3 MatAxR (vec3 vd)\n{\n  float f1, f2;\n  vd = normalize (vd);\n  f1 = 1. / (1. + vd.z);\n  f2 = - f1 * vd.x * vd.y;\n  return mat3 (1. - f1 * vd.x * vd.x, f2, - vd.x,\n     f2, 1. - f1 * vd.y * vd.y, - vd.y, vd);\n}\n\nvec2 TubeNutDf (vec3 p)\n{\n  vec3 q;\n  float a, dNut, dTor;\n  float radO = sqrt(6.)/8.;\n  float radI = 0.025;\n  q = p;\n  q.xy = Rot2D (q.xy, pi / 12.);\n  a = atan (- q.y, q.x);\n  q.xy = Rot2D (q.xy, 2. * pi * (floor (6. * a / (2. * pi)) + 0.5) / 6.);\n  q.x -= radO;\n  q = abs (q);\n  dNut = max (max (max (q.x * 0.866 + q.z * 0.5, q.z) - radI - 0.013,\n     q.y - 0.03), 0.005 - q.y);\n  dNut = min (dNut, PrRCylDf (q.xzy, radI + 0.005, 0.001, 0.04));\n  dTor = length (vec2 (length (p.xy) - radO, p.z)) - radI +\n     0.004 * SmoothBump (0.2, 0.8, 0.07, mod (20. * a, 1.));\n  return vec2 (dTor, dNut);\n}\n\nvec3 TrackPath (float t)\n{\n  vec2 w;\n  w = vec2 (sin (0.22 * t), cos (0.28 * t));\n  return vec3 (dot (w, vec2 (2., -0.75)), dot (w, vec2 (0.75, 0.85)), t);\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 ip0, ip1, ip2, p0, p1, p2, p3, t0, t1, t2, t3, q;\n  vec2 vMin;\n  float dMin, r;\n  q = p;\n  q.xy -= TrackPath (q.z).xy;\n  ip0 = floor (q + dot (q, vec3 (1./3.)));\n  q -= ip0 - dot (ip0, vec3 (1. / 6.));\n  ip1 = step (q.yzx, q);\n  ip2 = max (ip1, 1. - ip1.zxy);\n  ip1 = min (ip1, 1. - ip1.zxy);\n  p0 = vec3 (0.);\n  p1 = ip1 - 1./6.;\n  p2 = ip2 - 1./3.;\n  p3 = vec3 (0.5);\n  r = Hashfv3 (101. * ip0 + 102. * ip1 + 103. * ip2);\n  if (r > 0.66) { t0 = p2;  t1 = p3;  t2 = p0;  t3 = p1; }\n  else if (r > 0.33) { t0 = p3;  t1 = p0;  t2 = p1;  t3 = p2; }\n  else { t0 = p1;  t1 = p2;  t2 = p3;  t3 = p0; }\n  vMin = min (TubeNutDf ((q - 0.5 * (t0 + t1)) * MatAxR (t0 - t1)),\n              TubeNutDf ((q - 0.5 * (t2 + t3)) * MatAxR (t2 - t3)));\n  if (vMin.x < vMin.y) { dMin = vMin.x;  idObj = 1; }\n  else { dMin = vMin.y;  idObj = 2; }\n  dMin *= 0.8;\n  dMin = DroneDf (p, dMin);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = ObjDf (ro + rd * dHit);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = 0; j < 16; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += 0.07;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn, ltVec;\n  float dHit, ltDist, sh, spec;\n  dHit = ObjRay (ro, rd);\n  if (dHit < dstFar) {\n    ro += dHit * rd;\n    if (idObj >= idDrBod) {\n      if (idObj == idDrBod) {\n        col = vec3 (0.2, 0.9, 0.2);\n        spec = 1.;\n      } else if (idObj == idDrLamp) {\n        col = mix (vec3 (0.3, 0.3, 1.), vec3 (1., 0., 0.),\n           step (0., sin (10. * tCur)));\n        spec = -1.;\n      } else if (idObj == idDrCam) {\n        col = vec3 (0.1);\n        spec = 1.;\n      }\n    } else {\n      if (idObj == 1) col = vec3 (0.5, 0.5, 0.55);\n      else col = vec3 (1., 0.7, 0.1);\n      col *= 0.5 + 0.5 * smoothstep (0., 1., 0.5 + 0.5 * Noisefv3 (500. * ro));\n      spec = 0.3;\n    }\n    vn = ObjNf (ro);\n    ltVec = ltPos - ro;\n    ltDist = length (ltVec);\n    ltVec /= ltDist;\n    if (spec >= 0.) {\n      sh = ObjSShadow (ro, ltVec);\n      col = col * (0.1 + 0.9 * sh * max (dot (vn, ltVec), 0.)) +\n         spec * sh * pow (max (dot (normalize (vn - rd), vn), 0.), 64.);\n      col *= 1. / (1. + 0.2 * ltDist * ltDist);\n    }\n  } else col = vec3 (0.);\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, pF, pB, u, vd;\n  vec2 canvas, uv, ori, ca, sa;\n  float az, el, vFly, f;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  vFly = 1.;\n  dronePos = TrackPath (vFly * tCur + 0.5);\n  aTilt = vec2 (20. * (TrackPath (vFly * tCur + 0.55).x - dronePos.x), 0.2);\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az = 2. * pi * mPtr.x;\n    el = -0.1 * pi + pi * mPtr.y;\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  rd = normalize (vec3 (uv, 2.5));\n  pF = TrackPath (vFly * tCur + 0.1);\n  pB = TrackPath (vFly * tCur - 0.1);\n  ro = 0.5 * (pF + pB);\n  vd = normalize (pF - pB);\n  vd.xy = Rot2D (vd.xy, 2. * (pF.x - pB.x));\n  u = - vd.y * vd;\n  f = 1. / sqrt (1. - vd.y * vd.y);\n  vuMat = mat3 (f * vec3 (vd.z, 0., - vd.x), f * vec3 (u.x, 1. + u.y, u.z), vd) *\n     vuMat;\n  rd = vuMat * rd;\n  ltPos = ro + vuMat * vec3 (0.3, 0.5, 0.1);\n  dstFar = 20.;\n  fragColor = vec4 (pow (clamp (ShowScene (ro, rd), 0., 1.), vec3 (0.8)), 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrRCylDf (vec3 p, float r, float rt, float h)\n{\n  vec2 dc;\n  float dxy, dz;\n  dxy = length (p.xy) - r;\n  dz = abs (p.z) - h;\n  dc = vec2 (dxy, dz) + rt;\n  return min (min (max (dc.x, dz), max (dc.y, dxy)), length (dc) - rt);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, cHashA3)) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t1, t2;\n  vec3 ip, fp;\n  float q;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  q = dot (ip, cHashA3);\n  t1 = Hashv4f (q);\n  t2 = Hashv4f (q + cHashA3.z);\n  return mix (mix (mix (t1.x, t1.y, fp.x), mix (t1.z, t1.w, fp.x), fp.y),\n              mix (mix (t2.x, t2.y, fp.x), mix (t2.z, t2.w, fp.x), fp.y), fp.z);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldffDf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldffWB", "name": "everyday 036/100", "author": "kalin", "description": "everyday 036/100\n", "tags": ["everyday"], "likes": 4, "viewed": 500, "date": "1497848811", "time_retrieved": "2024-06-20T18:55:58.968471", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 nuv = uv * 2.0 - 1.0;\n    \n    float t = iTime;\n    float bpm = 1.0 / 60.0 * 120.0;\n    float pi = 3.14159265359;\n    float bt = t * bpm;\n    float btp = bt * pi;\n    float btp4 = btp / 4.0;\n    \n    vec3 c = vec3(0.0);\n\n    float mt = btp4;\n    mat2 rm = mat2(cos(mt), -sin(mt), sin(mt), cos(mt));\n    \n    nuv = rm * vec2(nuv.x * sin(abs(nuv.x) + btp4), abs(nuv.y)*1.0);\n    \n    float ts = 1.0 / 32.0;\n    float freqE = 146.83;\n    float g0 =\n        texture(iChannel0, vec2(1.0 / 512.0 * ((freqE * 1.0) / 23.0), 0.25)).x +\n        texture(iChannel0, vec2(1.0 / 512.0 * ((freqE * 2.0) / 23.0), 0.25)).x +\n        texture(iChannel0, vec2(1.0 / 512.0 * ((freqE * 3.0) / 23.0), 0.25)).x +\n        texture(iChannel0, vec2(1.0 / 512.0 * ((freqE * 4.0) / 23.0), 0.25)).x;\n    float freqB = 110.0;\n    float g1 =\n        texture(iChannel0, vec2(1.0 / 512.0 * ((freqB * 1.0) / 23.0), 0.25)).x +\n        texture(iChannel0, vec2(1.0 / 512.0 * ((freqB * 2.0) / 23.0), 0.25)).x +\n        texture(iChannel0, vec2(1.0 / 512.0 * ((freqB * 3.0) / 23.0), 0.25)).x +\n        texture(iChannel0, vec2(1.0 / 512.0 * ((freqB * 4.0) / 23.0), 0.25)).x;\n    \n    g0 /= 4.0;\n    g1 /= 4.0;\n    \n    g0 = max(0.0, g0 - 0.45);\n    g1 = max(0.0, g1 - 0.45);\n    \n    g0 = pow(g0, 0.7);\n    g1 = pow(g1, 0.7);\n        \n    float w0 = texture(iChannel0, vec2(uv.x, 0.75)).x;\n    float m0 = texture(iChannel0, vec2(uv.x, 0.25)).x;\n    float m0n = texture(iChannel0, vec2(abs(nuv.x), 0.25)).x;\n    \n    m0n = pow(m0n, 3.0) * 20.0;\n    \n    float f0 = pow(m0n, 4.0);\n    float f1 = w0 * (1.0 - pow(abs(nuv.y), 0.1));\n    float f2 = 1.0 - pow(abs(w0 - uv.y), 1.0 - g0) * 0.3;\n    \n    float fwave = g0 * g1 * 2.5 * pow(abs(sin(nuv.x + btp4 + 1.3*f2)), 12.0);\n    \n    c.xyz = vec3(abs(f2 * fwave * pow(abs(nuv.y), 1.4) * 4.0 + m0n * -fwave));\n    c.xyz += vec3(0.2 * pow(1.0 - f0, 0.0));\n\n    c.z += abs(g0 * g1);\n    c.z += max(0.0, f2 * 2.0) * 0.5;\n    c.y += max(0.0, f2 * 2.0) * 2.0 * pow(g0, 3.0);\n    \n    c.xyz *= 1.0 - length(abs(nuv.y));\n    \n    fragColor.xyz = c;\n}", "image_inputs": [{"id": "lsXXR2", "previewfilepath": "https://soundcloud.com/bonetender/slow-hand-improvisation", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/bonetender/slow-hand-improvisation", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldffWB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldlBWX", "name": "Volume_0", "author": "kenhu", "description": "Volumetric test", "tags": ["volumetric"], "likes": 10, "viewed": 303, "date": "1498587115", "time_retrieved": "2024-06-20T18:55:58.968471", "image_code": "// SDFs\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n    float sdSphere( vec3 p, float s )\n    {\n        return length(p) - s;\n    }\n\n\tfloat sdBox( vec3 p, vec3 b )\n    {\n      vec3 d = abs(p) - b;\n      return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n    }\n\n    float sdPlane( vec3 p, vec4 n )\n    {\n      // n must be normalized\n      return dot(p,n.xyz) + n.w;\n    }\n\n    float sdTorus( vec3 p, vec2 t )\n    {\n        vec2 q = vec2(length(p.xz)-t.x,p.y);\n        return length(q)-t.y;\n    }\n\n    float sdCone( vec3 p, vec3 c )\n    {\n        vec2 q = vec2( length(p.xz), p.y );\n        float d1 = -q.y-c.z;\n        float d2 = max( dot(q,c.xy), q.y);\n        return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n    }\n\n// Noise\n    float hash (float n)\n    {\n        return fract(sin(n)*43758.5453);\n    }\n\n    float noise (in vec3 x)\n    {\n        vec3 p = floor(x);\n        vec3 f = fract(x);\n\n        f = f*f*(3.0-2.0*f);\n\n        float n = p.x + p.y*57.0 + 113.0*p.z;\n\n        float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                            mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                        mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                            mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n        return res;\n    }\n\n// Environment\n    vec3 LightPosition()\n    {\n        return vec3(0.0,20.0,0);\n    }\n\n    vec3 LightDirection()\n    {\n        return normalize(vec3(-0.05,-1,0));\n    }\n\n\t// https://www.shadertoy.com/view/MsS3Wc\n    // Smooth HSV to RGB conversion \n    vec3 hsv2rgb_smooth( in vec3 c )\n    {\n        vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n        rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n        return c.z * mix( vec3(1.0), rgb, c.y);\n    }\n\n\tvec3 LightColor()\n    {\n     \treturn hsv2rgb_smooth(vec3(fract(iTime * 0.05), 0.5, 0.5)) * 0.03;\n    }\n\n// Scene\n    float Scene(vec3 pos)\n    {\n        float outerSize = 20.0;\n        \n        float outer = sdBox(pos - vec3(0,0,0), vec3(outerSize*10.0,0.5,outerSize*10.0));\n        float lower = sdBox(pos - vec3(0,-40.0,0), vec3(outerSize*10.0,0.1,outerSize*10.0));\n        \n        float theta = iTime * 1.0;\n        mat3 fast_rot = mat3(\n            cos(theta),0,sin(theta),\n            0,1,0,\n            -sin(theta),0,cos(theta));\n        vec3 fast_rot_pos = fast_rot * pos;\n        \n        theta = iTime * 0.1;\n        mat3 slow_rot = mat3(\n            cos(theta),0,sin(theta),\n            0,1,0,\n            -sin(theta),0,cos(theta));\n        vec3 slow_rot_pos = slow_rot * pos;\n        \n        float offset = 8.0;\n        float size = 4.0;\n        \n        float box0 = sdBox(slow_rot_pos - vec3(0.0, 0.0, -offset), vec3(size, 1.0, size));\n        float box1 = sdBox(slow_rot_pos - vec3(0.0, 0.0, offset),  vec3(size, 1.0, size));\n        float box2 = sdBox(slow_rot_pos - vec3(offset, 0.0, 0.0),  vec3(size, 1.0, size));\n        float box3 = sdBox(slow_rot_pos - vec3(-offset, 0.0, 0.0), vec3(size, 1.0, size));\n        \n        float boxes = min(min(box0,box1), min(box2, box3));\n        \n        float depth = min(lower, max(-boxes, outer));\n        \n        size = 2.0;\n        offset = 16.0;\n        \n        box0 = sdBox(fast_rot_pos - vec3(0.0, -20.0, -offset), vec3(size, 1.0, size));\n        box1 = sdBox(fast_rot_pos - vec3(0.0, -20.0, offset),  vec3(size, 1.0, size));\n        box2 = sdBox(fast_rot_pos - vec3(offset, -20.0, 0.0),  vec3(size, 1.0, size));\n        box3 = sdBox(fast_rot_pos - vec3(-offset, -20.0, 0.0), vec3(size, 1.0, size));\n        \n        boxes = min(min(box0,box1), min(box2, box3));\n        \n        depth = min(depth, boxes);\n\n        return depth;\n    }\n\n\tfloat Density( in vec3 pos )\n    {\n        float y = (0.0 - pos.y + 15.0) / 40.0;\n        return y;\n    }\n\n    // from https://www.shadertoy.com/view/Xds3zN\n    vec3 CalcNormal( in vec3 pos )\n    {\n        vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n        return normalize( e.xyy * Scene( pos + e.xyy ) +\n                          e.yyx * Scene( pos + e.yyx ) +\n                          e.yxy * Scene( pos + e.yxy ) +\n                          e.xxx * Scene( pos + e.xxx ) );\n    }\n\n    vec3 RayDirection()\n    {\n        float fieldOfView = 90.0;\n        vec2 xy = gl_FragCoord.xy - iResolution.xy / 2.0;\n        float z =  iResolution.y / tan(radians(fieldOfView) / 2.0);\n        vec3 dir = normalize(vec3(xy, z)); // let z goes forward\n        \n        float pitch = 0.0;\n        \n        dir += vec3(0.0,pitch,0);\n        \n        return normalize(dir);\n    }\n\n\tvec3 Origin()\n    {\n    \tfloat backwards = -70.0;\n        \n        return vec3(0, -25, backwards);\n    }\n\n    float CastRay(vec3 origin, vec3 dir, float near, float far)\n    {\n        float EPSILON = 0.01;\n        const int STEP_COUNT = 64;\n\n        float depth = near;\n        for (int i = 0; i < STEP_COUNT; i++)\n        {\n            float dist = Scene(origin + depth * dir);\n            if (dist <= EPSILON)\n            {\n                // hit\n                return depth;\n            }\n            depth += dist; // go to next possible hit\n            if (depth >= far)\n            {\n                // hit far bound\n                return far;\n            }\n        }\n    }\n\n// Volume\n    vec3 marchThroughVolume(vec3 origin, vec3 dir, float near, float far)\n    {\n        vec2 xy = gl_FragCoord.xy - iResolution.xy / 2.0;\n                \n        origin -= 1.0 * dir * (noise(vec3(2.0 * xy, 0.0)));\n        \n        const float STEP_COUNT = 64.0;\n        float stepSize = (far - near) / STEP_COUNT;\n\n        vec3 accumulation = vec3(0.0);    \n\n        float depth = near;\n        for (float i = 0.0; i < STEP_COUNT; i++)\n        {\n            vec3 pos = origin + depth * dir;\n            vec3 diff = LightPosition() - pos;\n            vec3 dir = normalize(diff);\n            vec3 lightDir = LightDirection();\n            float near = 0.0;\n            float far = length(diff);\n            float distance = CastRay(pos, dir, near, far);\n            if (distance == far)\n            {\n                accumulation += Density(pos);\n            }\n\n            depth += stepSize;\n        }\n\n        return accumulation * stepSize * LightColor();\n    }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float near = 40.0;\n    float far = 100.0;\n    vec3 origin = Origin();\n    vec3 dir = RayDirection();\n    float depth = CastRay(origin, dir, near, far);\n    \n    fragColor = vec4(marchThroughVolume(origin, dir, near, depth), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldlBWX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldlBzX", "name": "yarf", "author": "Sheado", "description": "Practicing tiling.", "tags": ["gradient", "tiling", "rotation"], "likes": 0, "viewed": 82, "date": "1497338155", "time_retrieved": "2024-06-20T18:55:58.968471", "image_code": "vec2 rotate2d(in vec2 st, float _angle){\n    st -= .5;\n    mat2 m = mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n    st = m * st;\n    st += .5;\n    return st;\n}\n\nvoid practice( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    uv = rotate2d(uv,sin(iTime));\n    uv *= 5.;\t\t\t\t// tile count\n\n    float delta = step(1.,mod(uv.y,2.)) * cos(iTime);\n    uv.x += delta;\n    if( delta == 0. )\n        uv.x += cos(iTime);\n    delta = step(1.,mod(uv.x,2.)) * sin(iTime);\n    uv.y += delta;\n    if( delta == 0. )\n        uv.y += -sin(iTime);\n\n    uv = fract(uv);\t\t\t// fract - to tile\n    \n    vec2 center = vec2(uv.x,uv.y)-.5;\n\tfloat dist = distance(center,vec2(0.));\n    float feather = .6+sin(iTime)*.2;\n    dist = smoothstep(feather, 1.0, 1.0 - dist);\t\t\t\t\t\t\t\t\t// for a smooth gradient\n    \n    fragColor += vec4(0.,dist,feather,1.);    \n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    practice(fragColor, fragCoord);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldlBzX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldlfD2", "name": "33/100", "author": "yahe", "description": "some trivial things bothered me for a while..", "tags": ["neon"], "likes": 9, "viewed": 738, "date": "1498325859", "time_retrieved": "2024-06-20T18:55:58.968471", "image_code": "#define t iTime\n\nfloat pulse(float cn, float wi, float x)\n{\n\treturn 1.-smoothstep(0., wi, abs(x-cn));\n}\n\nfloat hash11(float n)\n{\n    return fract(sin(n)*43758.5453);\n}\n\nvec2 hash22(vec2 p)\n{\n    p = vec2( dot(p,vec2(127.1, 311.7)), dot(p,vec2(269.5, 183.3)));\n\treturn fract(sin(p)*43758.5453);\n}\n\nvec2 field(in vec2 p)\n{\n\tvec2 n = floor(p);\n\tvec2 f = fract(p);\n\tvec2 m = vec2(1.);\n\tvec2 o = hash22(n)*0.17;\n\tvec2 r = f+o-0.5;\n\tfloat d = abs(r.x) + abs(r.y);\n\tif(d<m.x)\n    {\n\t\tm.x = d;\n\t\tm.y = hash11(dot(n,vec2(1., 2.)));\n\t}\n\treturn vec2(m.x,m.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy-0.5;\n\tuv.x *= iResolution.x/iResolution.y*0.9;\n\tuv *= 4.;\n\t\n\tvec2 p = uv*.01;\n\tp *= 1./(p-1.);\n\t\n\tuv.y += sin(t*.5)*2.2+t;\n\tuv.x += cos(t*.5)*0.8;\n\tvec2 buv = uv;\n\t\n\tfloat rz = 0.;\n\tvec3 col = vec3(0.);\n\tfor(float i=1.; i<= 50.; i++)\n\t{\n\t\tvec2 rn = field(uv);\n\t\tuv -= p*(i*.5-20.)*0.2;\n\t\trn.x = pulse(0.7,.02, rn.x+rn.y*.15);\n\t\tcol += rn.x*vec3(.4+sin(rn.y*sin(t*10.)), cos(rn.y)*0.2*cos(t*10.)+.2,sin(rn.y)*0.3+.2);\n\t}\n\t\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldlfD2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldlfD4", "name": "Circle progressbar", "author": "tort32", "description": "Circle progress bar with antialiased edges", "tags": ["antialiasing", "proceduralgeometry", "gui"], "likes": 6, "viewed": 486, "date": "1496270502", "time_retrieved": "2024-06-20T18:55:58.968471", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float duration = 50.0;\n    float progress = fract(iTime / duration);\n    \n    float innerRadius = 100.0;\n    float outerRadius = 200.0;\n    \n    float middleRadius = 0.5 * (innerRadius + outerRadius);\n    float halfWidth = 0.5 * (outerRadius - innerRadius);\n    \n    vec2 pos = fragCoord.xy - 0.5 * iResolution.xy;\n    float radius = length(pos.xy);\n\t\n\tfloat fr = halfWidth - abs(radius - middleRadius) + 1.0; // radius double edge function\n\t//if(fr < 0.0) discard;\n    fr = clamp(fr, 0.0, 1.0);\n\t\n\tfloat angle = degrees(atan(-pos.x, -pos.y)) + 180.0; // angle clockwise from the top\n\tfloat fa = radians(angle - progress * 360.0) * radius + 1.0; // angle edge function\n    fa = clamp(fa, 0.0, 1.0);\n\t\n\t// Compute mixed bar color with antialiasing\n    vec4 color = vec4(0.8,0.9,1,1);\n    vec4 color2 = vec4(0.7,0.6,0.5,1);\n    vec4 col = mix(color, color2, fa);\n\tcol.a *= fr;\n    \n    // Blend with background\n    vec4 bgColor = vec4(0.1,0.3,0.2,1);\n    col = mix(bgColor, col, col.a);\n\t\n\tfragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldlfD4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldlfRl", "name": "Chinese Puzzle Balls 2", "author": "dr2", "description": "Updated with lots more holes", "tags": ["symmetry"], "likes": 7, "viewed": 418, "date": "1497620109", "time_retrieved": "2024-06-20T18:56:00.108109", "image_code": "// \"Chinese Puzzle Balls 2\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Updated with lots more holes; symmetry transformations adapted from \"sdf modpolyhedra\"\n  by tdhooper\n*/\n\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nvec2 Rot2D (vec2 q, float a);\nfloat SmoothMin (float a, float b, float r);\nvec3 HsvToRgb (vec3 c);\n\n#define N_BALL 5\nfloat aSpin, sHole, redFac, tCur, dstFar;\nint idObj;\nconst float pi = 3.14159;\n\nvec3 IcosSym (vec3 p)\n{\n  const float dihedIcos = 0.5 * acos (sqrt (5.) / 3.);\n  float a, w;\n  w = 2. * pi / 3.;\n  p.z = abs (p.z);\n  p.yz = Rot2D (p.yz, - dihedIcos);\n  p.x = - abs (p.x);\n  for (int k = 0; k < 4; k ++) {\n    p.zy = Rot2D (p.zy, - dihedIcos);\n    p.y = - abs (p.y);\n    p.zy = Rot2D (p.zy, dihedIcos);\n    if (k < 3) p.xy = Rot2D (p.xy, - w);\n  }\n  p.z = - p.z;\n  a = mod (atan (p.x, p.y) + 0.5 * w, w) - 0.5 * w;\n  p.yx = vec2 (cos (a), sin (a)) * length (p.xy);\n  p.x -= 2. * p.x * step (0., p.x);\n  return p;\n}\n\nvec3 DodecSym (vec3 p)\n{\n  const float dihedDodec = 0.5 * atan (2.);\n  float a, w;\n  w = 2. * pi / 5.;\n  p.z = abs (p.z);\n  p.xz = Rot2D (p.xz, dihedDodec);\n  p.xy = Rot2D (p.xy, - 0.25 * w);\n  p.x = - abs (p.x);\n  for (int k = 0; k < 4; k ++) {\n    p.zy = Rot2D (p.zy, - dihedDodec);\n    p.y = - abs (p.y);\n    p.zy = Rot2D (p.zy, dihedDodec);\n    if (k < 3) p.xy = Rot2D (p.xy, - w);\n  }\n  p.z = - p.z;\n  a = mod (atan (p.x, p.y) + 0.5 * w, w) - 0.5 * w;\n  p.yx = vec2 (cos (a), sin (a)) * length (p.xy);\n  p.x -= 2. * p.x * step (0., p.x);\n  return p;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float cLen, rad, smVal, dMin, d, aRot, r;\n  dMin = dstFar;\n  rad = 1.;\n  smVal = 0.01;\n  q = p;\n  d = PrTorusDf (q.xzy, 0.03 * rad, 1.03 * rad);\n  if (d < dMin) { dMin = d;  idObj = 20; }\n  q.xz = abs (q.xz) - 0.707 * 1.03 * rad;\n  cLen = 0.7;\n  q.y -= - cLen;\n  d = PrCylDf (q.xzy, 0.03 * rad, cLen);\n  if (d < dMin) { dMin = d;  idObj = 20; }\n  aRot = 1.5 * aSpin;\n  q = p;\n  for (int j = 0; j < N_BALL; j ++) {\n    r = length (q);\n    d = - SmoothMin (- (max (r - rad, - (r - 1.03 * redFac * rad))),\n       min (length (IcosSym (q) + vec3 (0., 0., rad)) - rad * sHole,\n       length (DodecSym (q) + vec3 (0., 0., rad)) - rad * sHole), redFac * smVal);\n     \n    if (d < dMin) { dMin = d;  idObj = j; }\n    q = q.yzx;\n    q.xz = Rot2D (q.xz, aRot);\n    rad *= redFac;\n    smVal *= redFac;\n    aRot *= 1.23;\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float d, h;\n  d = 0.;\n  for (int j = 0; j < 100; j ++) {\n    h = ObjDf (ro + d * rd);\n    d += h;\n    if (h < 0.0005 || d > dstFar) break;\n  }\n  return d;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec3 e = vec3 (0.0001, -0.0001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjAO (vec3 ro, vec3 rd)\n{\n  float ao, d;\n  ao = 0.;\n  for (int j = 0; j < 8; j ++) {\n    d = 0.1 + float (j) / 16.;\n    ao += max (0., d - 3. * ObjDf (ro + rd * d));\n  }\n  return 0.5 + 0.5 * clamp (1. - 0.2 * ao, 0., 1.);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 1.;\n  for (int j = 0; j < 30; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += 0.08 * (1. + 0.1 * d);\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 ltDir, col, bgCol, vn;\n  float dstHit, ts, amb, c, sh, bk;\n  ts = fract (tCur * 0.333 + 0.125) - 0.25;\n  aSpin = 0.1 * (tCur + max (0., ts) - 3. * min (0., ts));\n  sHole = 0.3 * (0.7 + 0.3 * cos (tCur * 0.4));\n  redFac = 0.87;\n  dstHit = ObjRay (ro, rd);\n  ltDir = normalize (vec3 (0.2, 1., -0.1));\n  col = vec3 (0.);\n  amb = 1.;\n  if (dstHit < dstFar) {\n    ro += rd * dstHit;\n    if (idObj < 20) col = HsvToRgb (vec3 (mod (1.7 * float (idObj) + 0.5, 1.), 1., 1.));\n    else col = vec3 (0.5, 0.5, 0.);\n    vn = ObjNf (ro);\n    bk = max (dot (vn, - normalize (vec3 (ltDir.x, 0., ltDir.z))), 0.);\n    sh = ObjSShadow (ro, ltDir);\n    col = col * (0.2 + 0.2 * bk + sh * 0.8 * max (dot (vn, ltDir), 0.)) +\n       sh * 0.2 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 128.);\n    amb = 0.2 * ObjAO (ro, vn);\n    rd = reflect (rd, vn);\n  }\n  c = (rd.y > max (abs (rd.x), abs (rd.z * 0.25))) ? min (2. * rd.y, 1.) :\n     0.05 * (1. + dot (rd, ltDir));\n  if (rd.y > 0.) c += 0.5 * pow (clamp (1.05 - 0.5 *\n     length (max (abs (rd.xz / rd.y) - vec2 (1., 4.), 0.)), 0., 1.), 6.);\n  bgCol = vec3 (0.5, 0.5, 1.) * c + 2. * vec3 (1., 0.8, 0.9) *\n     (clamp (0.0002 / (1. - abs (rd.x)), 0., 1.) +\n      clamp (0.0002 / (1. - abs (rd.z)), 0., 1.));\n  col += amb * bgCol;\n  return pow (clamp (col, 0., 1.), vec3 (0.8));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  az = 0.25 * pi - 0.1 * tCur;\n  el = -0.4 + 0.1 * sin (0.3 * tCur);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  rd = vuMat * normalize (vec3 (uv, 4.));\n  ro = vuMat * vec3 (0., 0., -5.);\n  dstFar = 10.;\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldlfRl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldlfWN", "name": "22/100", "author": "yahe", "description": "Inspired by https://www.shadertoy.com/view/4d2yW1", "tags": ["line"], "likes": 3, "viewed": 371, "date": "1496282516", "time_retrieved": "2024-06-20T18:56:00.108109", "image_code": "#define PI 3.1415926535\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy - iResolution.xy / 2.0;\n    float phi = atan(p.y + 1e-6, p.x);\n\n    float t = sin(iTime/5.)*4.;\n\tfloat fin = floor(phi * t / PI + 0.5);\n    float phi_fin = fin * PI / t;\n    \n    vec2 dir = vec2(cos(phi_fin), sin(phi_fin));\n    float l = dot(dir, p);\n\n    float ivr = 30.0;\n    float seg = l / ivr;\n\n    float w = sin(floor(seg)*.1 - iTime) * 0.45 + 0.5;\n    float c = (w / 2.0 - abs(fract(seg) - 0.5)) * ivr;\n\n    fragColor = vec4(c, c, c, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldlfWN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldsBz2", "name": "Lost World", "author": "nlight", "description": "Raymarched planet + atmospheric scattering.\n\nYou can move the light source using the mouse.", "tags": ["raymarching"], "likes": 13, "viewed": 405, "date": "1497094299", "time_retrieved": "2024-06-20T18:56:02.035423", "image_code": "// atmospheric scattering - https://www.shadertoy.com/view/lslXDr (thanks to GLtracy)\n// raymarching algorithm - http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n// noise functions - https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n\n//#define ULTRA_QUALITY\n\n#define DRAW_BACKGROUND\n#define DRAW_STAR\n#define DRAW_ATMOSPHERE\n#define DRAW_CLOUDS\n#define DRAW_WATER\n\nconst float MIN_DIST = 0.1;\nconst float MAX_DIST = 6.0;\nconst float EPSILON = 0.0001;\nconst float PI = 3.14159265359;\nconst float WATER_LEVEL = 0.02;\nconst float PLAINS_LEVEL = 0.028;\nconst float SNOW_LEVEL = 0.055;\nconst vec3 WATER_COLOR = vec3(0.1921, 0.2352, 0.545);\nconst vec3 PLAINS_COLOR = vec3(0.709, 0.592, 0.4431);\nconst vec3 MOUNTAINS_COLOR = vec3(0.1960, 0.2366, 0.1176);\nconst vec3 SNOW_COLOR = vec3(0.95, 0.87, 0.83);\nconst vec3 BACKGROUND_COLOR = vec3(0.0025, 0.00125, 0.01) * 0.25;\nconst vec3 STAR_COLOR = vec3(1.0, 0.8, 0.4);\nconst float DEG_TO_RAD = PI / 180.0;\nconst float MAX = 10000.0;\nconst float K_R = 0.166;\nconst float K_M = 0.0025;\nconst float E = 12.0; \t\t\t\t\t\t// light intensity\nconst vec3  C_R = vec3(0.3, 0.7, 1.0); \t// 1 / wavelength ^ 4\nconst float G_M = -0.95;\t\t\t\t\t// Mie g\nconst float R = 1.1;\nconst float R_INNER = 1.015;\nconst float SCALE_H = 5.0 / (R - R_INNER);\nconst float SCALE_L = 1.0 / (R - R_INNER);\nconst int NUM_OCTAVES = 7;\n\n#ifdef ULTRA_QUALITY\nconst int MAX_MARCHING_STEPS = 128;\nconst int NUM_OUT_SCATTER = 8;\nconst float FNUM_OUT_SCATTER = 8.0;\nconst int NUM_IN_SCATTER = 8;\nconst float FNUM_IN_SCATTER = 8.0;\n#else\nconst int MAX_MARCHING_STEPS = 48;\nconst int NUM_OUT_SCATTER = 4;\nconst float FNUM_OUT_SCATTER = 4.0;\nconst int NUM_IN_SCATTER = 4;\nconst float FNUM_IN_SCATTER = 4.0;\n#endif\n\nvec2 intersectRaySphere(vec3 p, vec3 dir, float r)\n{\n    const float MAX = 100.0;\n\n\tfloat b = dot(p, dir);\n\tfloat c = dot(p, p) - r * r;\n\t\n\tfloat d = b * b - c;\n\tif (d < 0.0)\n    {\n\t\treturn vec2(MAX, -MAX);\n\t}\n    \n\td = sqrt(d);\n\t\n\treturn vec2(-b - d, -b + d);\n}\n\nvec3 permute(vec3 x)\n{\n    return mod(((x*34.0)+1.0)*x, 289.0);\n}\n\nfloat snoise(vec2 v)\n{\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n           -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n  + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nfloat hash(float n)\n{\n    return fract(sin(n) * 1e4);\n}\n\nfloat hash(vec2 p)\n{\n    return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x))));\n}\n\nfloat noise(vec2 x)\n{\n\tvec2 i = floor(x);\n\tvec2 f = fract(x);\n\tfloat a = hash(i);\n\tfloat b = hash(i + vec2(1.0, 0.0));\n\tfloat c = hash(i + vec2(0.0, 1.0));\n\tfloat d = hash(i + vec2(1.0, 1.0));\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 x)\n{\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec2 shift = vec2(100);\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n\tfor (int i = 0; i < NUM_OCTAVES; ++i)\n    {\n\t\tv += a * noise(x);\n\t\tx = rot * x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n\nvec2 planetUV(vec3 p)\n{\n\tvec3 normal = normalize(p);\n    vec2 uv = vec2(asin(normal.x), asin(normal.y)) / PI + 0.5;\n  \tuv.x += iTime * 0.005;\n    return uv;\n}\n\nfloat planetSDF(vec3 samplePoint)\n{\n    vec2 uv = planetUV(samplePoint);\n    float low = fbm(uv * 16.0);\n    float med = fbm(uv * 64.0);\n    float d = length(samplePoint) - 1.0;\n    \n    float height = pow(low, 2.0) * 0.1 + med * 0.015;\n    \n    float holes = fbm(uv * 12.0) * 0.035;\n    height -= holes * smoothstep(0.75, 0.8, noise(uv * 32.0));\n    \n    return d - height;\n}\n\nvec3 sceneNormal(vec3 p)\n{\n    return normalize(\n    \tvec3\n        (\n            planetSDF(vec3(p.x + EPSILON, p.y, p.z)) - planetSDF(vec3(p.x - EPSILON, p.y, p.z)),\n            planetSDF(vec3(p.x, p.y + EPSILON, p.z)) - planetSDF(vec3(p.x, p.y - EPSILON, p.z)),\n            planetSDF(vec3(p.x, p.y, p.z  + EPSILON)) - planetSDF(vec3(p.x, p.y, p.z - EPSILON))\n    \t)\n    );\n}\n\nvec3 shadeTerrain(vec3 p, vec3 lightPos, vec3 eye)\n{\n    vec3 lightDir = normalize(lightPos - p);\n    \n    float h = length(p) - 1.0;\n    vec3 normal = sceneNormal(p);\n    float ldotn = max(0.0, dot(lightDir, normal));\n   \n    vec2 uv = planetUV(p);\n    \n    vec3 terrainColor = MOUNTAINS_COLOR * (0.75 + smoothstep(0.5, 1.0, noise(uv * 32.0)));\n    terrainColor = mix(PLAINS_COLOR, terrainColor, smoothstep(PLAINS_LEVEL, PLAINS_LEVEL + 0.005, h));\n    terrainColor = mix(terrainColor, SNOW_COLOR, smoothstep(SNOW_LEVEL, SNOW_LEVEL + 0.01, h));\n\n    return terrainColor * ldotn;\n}\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 dir, float start, float end)\n{\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++)\n    {\n        float dist = planetSDF(eye + depth * dir);\n        if (dist < EPSILON)\n        {\n\t\t\treturn depth;\n        }\n        \n        depth += dist * 0.95;\n        if (depth >= end)\n        {\n            return end;\n        }\n    }\n    \n    return end;\n}\n\nfloat phase_mie(float g, float c, float cc)\n{\n\tfloat gg = g * g;\n\tfloat a = (1.0 - gg) * (1.0 + cc);\n\tfloat b = 1.0 + gg - 2.0 * g * c;\n\tb *= sqrt(b);\n\tb *= 2.0 + gg;\t\n\treturn 1.5 * a / b;\n}\n\nfloat density(vec3 p)\n{\n\treturn exp(-(length(p) - R_INNER) * SCALE_H);\n}\n\nfloat optic(vec3 p, vec3 q)\n{\n\tvec3 step = (q - p) / FNUM_OUT_SCATTER;\n\tvec3 v = p + step * 0.5;\n\t\n\tfloat sum = 0.0;\n\tfor (int i = 0; i < NUM_OUT_SCATTER; i++)\n    {\n\t\tsum += density(v);\n\t\tv += step;\n\t}\n    \n\tsum *= length(step) * SCALE_L;\n\treturn sum;\n}\n\nvec3 shadeAtmosphere(vec3 o, vec3 dir, vec2 e, vec3 l)\n{\n\tfloat len = (e.y - e.x) / FNUM_IN_SCATTER;\n\tvec3 step = dir * len;\n\tvec3 p = o + dir * e.x;\n\tvec3 v = p + dir * (len * 0.5);\n\n\tvec3 sum = vec3(0.0);\n\tfor (int i = 0; i < NUM_IN_SCATTER; i++)\n    {\n\t\tvec2 f = intersectRaySphere(v, l, R);\n\t\tvec3 u = v + l * f.y;\n\t\t\n\t\tfloat n = (optic(p, v) + optic(v, u)) * (PI * 4.0);\n\t\tsum += density(v) * exp(-n * (K_R * C_R + K_M));\n\t\tv += step;\n\t}\n    \n\tsum *= len * SCALE_L;\n\t\n\tfloat c  = dot(dir, -l);\n\tfloat cc = c * c;\n\t\n\treturn sum * (K_R * C_R * 0.75 * (1.0 + cc) + K_M * phase_mie(G_M, c, cc)) * E;\n}\n\nvec3 shadeBackground(vec3 eye, vec3 dir, vec2 fragCoord)\n{\n    vec3 color = BACKGROUND_COLOR;\n   \n   \tfloat noise = snoise(fragCoord * 0.32);\n    color += vec3(0.3) * step(0.93, noise);\n    \n    noise = snoise(vec2(16.0, 3.0) + fragCoord * 0.56);\n    color += vec3(0.45) * step(0.93, noise);\n    \n    noise = snoise(vec2(15.0, 86.0) + fragCoord * 1.65);\n    color += vec3(0.76) * step(0.95, noise);\n    \n    return color;\n}\n\nvec3 shadeClouds(vec2 uv)\n{\n\tfloat noise = fbm(uv * 8.0 + vec2(iTime * 0.15, 0.0));\n    noise = max(fbm(uv * 12.0 + vec2(iTime * 0.25, 0.0)), noise);\n    noise = noise * smoothstep(0.55, 1.0, fbm(uv * 32.0));\n    return vec3(noise);\n}\n\nvec3 shadePlanet(vec3 eye, vec3 dir, vec3 lightPos, vec2 fragCoord)\n{\n#ifdef DRAW_BACKGROUND\n    vec3 color = shadeBackground(eye, dir, fragCoord);\n#else\n    vec3 color = vec3(0.0);\n#endif\n    \n    vec2 e = intersectRaySphere(eye, dir, R);\n\tif (e.x > e.y)\n    {\n        return color;\n\t}\n        \n    float dist = shortestDistanceToSurface(eye, dir, MIN_DIST, MAX_DIST);\n    vec3 p = eye + dist * dir;\n    \n    vec3 lightDir = normalize(lightPos - p);\n    vec3 normal = normalize(p);\n    float ldotn = max(0.0, dot(lightDir, normal));\n    \n    if (dist <= MAX_DIST - EPSILON)\n    {\n        vec2 uv = planetUV(p);\n        vec3 terrainColor = shadeTerrain(p, lightPos, eye);\n        \n#ifdef DRAW_WATER\n        vec3 reflectDir = reflect(-lightDir, normal);\n        vec3 viewDir = normalize(eye - p);\n    \tfloat specular = pow(max(dot(reflectDir, viewDir), 0.0), 4.0);\n        vec3 waterColor = WATER_COLOR * ldotn + vec3(0.25) * specular;\n        \n        float h = length(p) - 1.0;\n        \n        color = mix(terrainColor, waterColor, smoothstep(1.0 - WATER_LEVEL - 0.01, 1.0 - WATER_LEVEL, 1.0 - h));\n#else\n      \tcolor = terrainColor;  \n#endif\n        \n#ifdef DRAW_CLOUDS\n        vec3 clouds = shadeClouds(uv) * ldotn * 2.0;\n        color = mix(color * 0.85, clouds, 0.55);\n#else\n     \tcolor = mix(color * 0.85, vec3(0.0), 0.55);\n#endif\n    }\n\t\n\tvec2 f = intersectRaySphere(eye, dir, R_INNER);\n\te.y = min(e.y, f.x);\n    vec3 p2 = eye + e.x * dir;\n\n#ifdef DRAW_ATMOSPHERE\n\tvec3 scatter = shadeAtmosphere(eye, dir, e, lightDir);\n    color = color + scatter * 0.35;\n#endif\n    \n    return color;\n}\n\nvec3 shadeStar(vec3 eye, vec3 dir, vec3 lightPos)   \n{\n  \tvec2 e2 = intersectRaySphere(eye, dir, 1.0);    \n    vec2 e = intersectRaySphere(eye - lightPos, dir, 3.0);\n    \n    if (e2.x <= e.x || e.x < 0.0)\n    {\n\t\treturn vec3(0.0);\n    }\n    \n    if(e.x <= e.y)\n    {\n        vec3 p = eye + e.x * dir;\n        p.z = 0.0;\n        lightPos.z = 0.0;\n        float t = length(p - lightPos) * 64.0;\n        t = 1.0 / (t * t);\n\t\treturn mix(vec3(0), STAR_COLOR * 32.0, t);\n    }\n    \n\treturn vec3(0);\n}\n\nvec3 rayDirection(float fov, vec2 size, vec2 fragCoord)\n{\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 rot3xy(vec2 angle)\n{\n\tvec2 c = cos(angle);\n\tvec2 s = sin(angle);\n\t\n\treturn mat3\n    (\n\t\tc.y, 0.0, -s.y,\n\t\ts.y * s.x, c.x, c.y * s.x,\n\t\ts.y * c.x, -s.x, c.y * c.x\n\t);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 eye = vec3(0.0, 0.0, 6.0);\n    vec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n    \n    mat3 lightRot = rot3xy(vec2(0.0, -iTime * 0.05 + 1.32 + PI * (iMouse.x / iResolution.x) * 2.0));\n    vec3 lightPos = lightRot * vec3(8, 0, 0) * 1.0;\n\n    vec3 color = shadePlanet(eye, dir, lightPos, fragCoord);\n    \n#ifdef DRAW_STAR\n    color += shadeStar(eye, dir, lightPos);\n#endif\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldsBz2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldsfD7", "name": "palm tree minus palm tree ", "author": "ollj", "description": "branch of \nhttps://www.shadertoy.com/view/MdsBD7", "tags": ["cars", "nopalmtree", "nobuildings", "noboats", "towater", "nobridgesupports"], "likes": 4, "viewed": 904, "date": "1496567922", "time_retrieved": "2024-06-20T18:56:02.296129", "image_code": "/*\nthis is a branch of \nhttps://www.shadertoy.com/view/MdsBD7\nwhich is called \"2d palm tree\"\nand i think the \"palm tree shape\" is the least interesting of it\nand the cars on the bridge are the most interesting of it.\n\nfor shame, the cars are not first derivative cars. \ngood illusion of that though.\n\nbottom line, who needs to calculate a first derivative \nif you can just shade over such lack of precision.\n\nwell, i do care!\n*/\n\n#define PI 3.14159265359\n#define PI2 6.28318530718\n\nvec4 bridge(vec2 p){\n vec4 col = vec4(0.0);\n float f=.01*cos(10.*p.x)+.01;//baseline sinusoid\n f += 0.006 * cos(p.x * 10.4);\n f += 0.13 * cos(p.x * 2.0);//3 octaves\n if(distance(f, p.y) < 0.03){\n  if(distance(f, p.y) < 0.003){\n   col.rgb = vec3(0.4);//floor of sinusoid road.\n   col.a = 1.0;}\n  //Vehicles:\n  if(p.y > f + 0.003 && p.y < f + 0.014){\n   float vehicle = cos(p.x * 100.0 + iTime * PI2);\n   vehicle = vehicle < 0.0? 0.0: 1.0;\n   if(vehicle > 0.0){\n    col.rgb = vec3(0.3);\n    col.a=1.;\n }}}return col;}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n vec2 u=fragCoord.xy/iResolution.xy;\n u.y*=iResolution.y/iResolution.x;\n u.y-=.2;\n fragColor=bridge(u);}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldsfD7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldsfRX", "name": "everyday 031/100", "author": "kalin", "description": "everyday 031/100", "tags": ["everyday"], "likes": 7, "viewed": 539, "date": "1497333773", "time_retrieved": "2024-06-20T18:56:02.296129", "image_code": "vec3 pass( out vec4 fragColor, in vec2 fragCoord, float time )\n{\n    float t = time;\n    float bpm = 1.0 / 60.0 * 140.0;\n    float bt = t * bpm;\n    float pi = 3.14152925359;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 nuv = uv * 2.0 - 1.0;\n    nuv.y /= iResolution.x / iResolution.y;\n    vec2 nuv0 = nuv;\n    \n    float must = 1.0 / 32.0;\n    float mus0 = texture(iChannel0, vec2(must * 0.0)).x;\n    float mus1 = texture(iChannel0, vec2(must * 26.0)).x;\n    \n    mus0 = smoothstep(0.0, 1.0, pow(mus0, 0.6));\n    mus1 = pow(mus1 - 0.3, 3.0) * 2.0;\n        \n    float r = sqrt(nuv0.x * nuv0.x + nuv0.y * nuv0.y);\n    float theta = atan(nuv0.y / nuv0.x);\n    \n    vec4 t0 = texture(iChannel1, uv * 0.05 + bt * 0.000001 * abs(theta) * mus1 * 0.1);\n    vec4 t1 = texture(iChannel1, uv * 0.5 + bt * 0.000001 * abs(theta));\n        \n    float il = max(0.0, 1.0 - length(nuv) * 1.0);\n    il = smoothstep(0.1, 0.8, il);\n    float f0 = sin(abs(theta) * 35.0 + bt + t1.x * 12.0 + 2.5 * mus0) * pow(il, 4.5);\n    float f1 = sin(length(nuv) * 32.0 * (1.0 - mus0 * 0.2) - bt * 2.0 + t0.x * 12.5) * pow(il, 3.5);\n    float f2 = cos(theta * 8.0 - bt * 2.0) * pow(il, 3.0);\n    float f3 = cos(abs(theta) + bt * 2.0 + uv.y * 4.0) * pow(il, 2.5);\n\n    vec3 c = vec3(0.0);\n    \n    c.x = f0 * t0.x;\n    c.y = f1 * (1.0 + mus0 * 0.2);\n    c.z = f2 * t0.x;\n    \n    c.xy -= vec2(f3) * (0.3 + mus0 * 0.6) * t0.x;\n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat t = iTime;\n    float bpm = 1.0 / 60.0 * 140.0;\n    float bt = t * bpm;\n    \n    float must = 1.0 / 32.0;\n    float mus0 = texture(iChannel0, vec2(must * 0.0)).x;\n    float mus1 = texture(iChannel0, vec2(must * 26.0)).x;\n    \n    mus0 = pow(mus0, 0.6);\n    mus1 = pow(mus1 - 0.3, 3.0) * 2.0;\n    \n    vec3 c = vec3(0.2, 0.2, 0.2);\n     \n    vec2 fragCoord0 = fragCoord + vec2(sin(bt * 0.01) * 0.01, cos(bt * 0.01) * 0.21);\n    vec2 fragCoord1 = fragCoord + vec2(sin(bt * 0.02 + mus0) * 0.01, cos(bt * 0.2) * 0.2);\n    vec2 fragCoord2 = fragCoord + vec2(sin(bt * 0.03 + mus1) * 0.01);\n\n    vec3 pass0 = pass(fragColor, fragCoord0, t);\n    vec3 pass1 = pass(fragColor, fragCoord1, t + 0.04 + mus0 * 0.02);\n    vec3 pass2 = pass(fragColor, fragCoord2, t + 0.065);\n\n    c.x += abs(pass0.x + pass0.y + pass0.z) * (1.0 + mus0 * 0.3);\n    c.y += abs(pass1.x + pass1.y + pass1.z);\n    c.z += abs(pass2.x + pass2.y + pass2.z);\n    \n  \tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 nuv = uv * 2.0 - 1.0;\n    nuv.y /= iResolution.x / iResolution.y;\n    \n    fragColor.xyz = c;\n}", "image_inputs": [{"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}, {"id": "ldsSW7", "previewfilepath": "https://soundcloud.com/helloworldhello/yellow-leaves-komradejack", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/helloworldhello/yellow-leaves-komradejack", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldsfRX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldsfWB", "name": "Line of Sight 2", "author": "dr2", "description": "Hexagonal grid line of sight (updated); ray-grid intercepts added. Mouse moves line end.", "tags": ["hexagon", "los", "intercept"], "likes": 17, "viewed": 885, "date": "1497980402", "time_retrieved": "2024-06-20T18:56:03.035466", "image_code": "// \"Line of Sight 2\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Hexagonal grid line of sight (updated); ray-grid intercepts added (uses different\n  grid orientation from mattz). Mouse moves line end.\n*/\n\n#define SQRT3 1.7320508\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./SQRT3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (SQRT3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nbool HexNeb (vec2 a, vec2 b)\n{\n  vec2 d = a - b;\n  return (d.x == 0. && abs (d.y) == 1. || abs (d.x) == 1. && d.y == 0. ||\n    d.x * d.y == -1.);\n}\n\nfloat HexEdgeDist (vec2 p)\n{\n  p = abs (p);\n  return (SQRT3/2.) - p.x + 0.5 * min (p.x - SQRT3 * p.y, 0.);\n}\n\nbool HexOnLine (vec2 v, vec2 b)\n{\n  vec3 w;\n  w = abs (vec3 (v.x, 0.5 * (v.x + SQRT3 * v.y), 0.5 * (v.x - SQRT3 * v.y)));\n  return (abs (b.x * v.y - b.y * v.x) < max (w.x, max (w.y, w.z)));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nvec3 ShowScene (vec2 pA, vec2 pB, vec2 pC)\n{\n  vec3 col, vri, ev, hv, hvv, vf;\n  vec2 edN[3], cIdA, cIdB, cIdC, pCM, pM, rd, vt;\n  float lenLn, dEdge, hitW, s, t;\n  rd = pB - pA;\n  lenLn = length (rd);\n  rd /= lenLn;\n  cIdC = PixToHex (pC);\n  cIdA = PixToHex (pA);\n  cIdB = PixToHex (pB);\n  pCM = HexToPix (cIdC);\n  dEdge = HexEdgeDist (pC - pCM);\n  col = vec3 (0.3);\n  vt = pCM - pA;\n  t = dot (vt, rd);\n  if (cIdC == cIdA || cIdC == cIdB || t > 0. && t < lenLn && HexOnLine (rd, vt)) {\n    col = HsvToRgb (vec3 (1., 1. - 1.2 * dEdge,\n       min (1. + 0.2 * sin (50. * dEdge), 1.)));\n    col = mix (vec3 (0., 0., 1.), col, smoothstep (0.1, 0.13, length (pC - pCM)));\n  } else {\n    if (HexNeb (cIdC, cIdA) || HexNeb (cIdC, cIdB)) col += 0.2;\n  }\n  col = mix (vec3 (0., 0., 1.), col, smoothstep (0.04, 0.05, dEdge));\n  vt = pC - pA;\n  t = dot (vt, rd);\n  if (t > -0.03 && t < lenLn + 0.03) {\n    col = mix (vec3 (0.), col, smoothstep (0.03, 0.1,\n       sqrt (max (0., dot (vt, vt) - t * t))));\n    if (t > 0. && t < lenLn) col = mix (vec3 (1., 1., 0.), col,\n       smoothstep (0.03, 0.04, sqrt (max (0., dot (vt, vt) - t * t))));\n  }\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., SQRT3);\n  edN[2] = 0.5 * vec2 (1., - SQRT3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd));\n  vri = 1. / vec3 (dot (rd, edN[0]), dot (rd, edN[1]), dot (rd, edN[2]));\n  vf = (SQRT3/2.) - vec3 (dot (pA, edN[0]), dot (pA, edN[1]), dot (pA, edN[2]));\n  pM = HexToPix (cIdA);\n  hitW = 1e6;\n  for (int j = 0; j < 40; j ++) {\n    hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n    s = min (hv.x, min (hv.y, hv.z));\n    if (s > lenLn) break;\n    pM += SQRT3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n    hitW = min (hitW, length (pA + s * rd - pC));\n  }\n  col = mix (vec3 (0., 1., 0.), mix (vec3 (0.), col, smoothstep (0.13, 0.2, hitW)),\n     smoothstep (0.13, 0.15, hitW));\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  vec4 mPtr;\n  vec3 col;\n  vec2 canvas, uv, va, pC, pA, pM, r;\n  float tCur, pSize, a, h;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  pSize = 20.;\n  va = pSize * vec2 (canvas.x / canvas.y, 1.);\n  a = 0.1 * tCur;\n  r = vec2 (cos (a), sin (a)) * va;\n  pC = pSize * uv;\n  pM = 2. * mPtr.xy * va;\n  pA = (mPtr.z > 0.) ? pM : - 0.65 * r + 0.1 * vec2 (- r.y, r.x);\n  col = ShowScene (pA, pA + 1.3 * r, pC);\n  if (mPtr.z > 0.) {\n    h = length (pC - pM);\n    col = mix (vec3 (1., 1., 0.), mix (vec3 (0.), col,\n       smoothstep (0.15, 0.2, h)), smoothstep (0.15, 0.17, h));\n  }\n  fragColor = vec4 (clamp (col, 0., 1.), 1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldsfWB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldsfWS", "name": "JosKleinyanCat", "author": "soma_arc", "description": "Finally, I understood Jos Leys's great algorithm for rendering the limit set of the Kleinian Groups!\nIt is tiresome to trap all of the orbits.\nReference: A fast algorithm for limit sets of Kleinian groups...\nhttp://www.josleys.com/article_show.php?id=221", "tags": ["2d", "fractal", "klein"], "likes": 6, "viewed": 264, "date": "1498046424", "time_retrieved": "2024-06-20T18:56:03.962793", "image_code": "// 2017 created by soma_arc\n// This shader is based on Kleinian limit set-Maskit slice by Jos Leys\n// https://www.shadertoy.com/view/MtKXRh\n\n// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n    vec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n    // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nconst float GAMMA_COEFF = 2.2;\nconst float DISPLAY_GAMMA_COEFF = 1. / GAMMA_COEFF;\nvec3 gammaCorrect(vec3 rgb) {\n  return vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),\n              (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));\n}\n\nvec3 degamma(vec3 rgb) {\n  return vec3((min(pow(rgb.r, GAMMA_COEFF), 1.)),\n              (min(pow(rgb.g, GAMMA_COEFF), 1.)),\n              (min(pow(rgb.b, GAMMA_COEFF), 1.)));\n}\n\nfloat lineY(vec2 pos, vec2 uv){\n\treturn uv.x * .5 + sign(uv.y * .5) * (2.*uv.x-1.95)/4. * sign(pos.x + uv.y * 0.5)* (1. - exp(-(7.2-(1.95-uv.x)*15.)* abs(pos.x + uv.y * 0.5)));\n}\n\nvec2 TransA(vec2 z, vec2 uv){\n\tfloat iR = 1. / dot(z, z);\n\tz *= -iR;\n\tz.x = -uv.y - z.x; z.y = uv.x + z.y;\n    return z;\n}\n\nvec2 TransAInv(vec2 z, vec2 uv){\n\tfloat iR = 1. / dot(z + vec2(uv.y,-uv.x), z + vec2(uv.y, -uv.x));\n\tz.x += uv.y; z.y = uv.x - z.y; \n\tz *= iR;\n    return z;\n}\n\nvec4 getNyanCatColor(vec2 p) {\n\tp = clamp(p,0.0,1.0);\n\tp.x = p.x*40.0/256.0;\n    float fr = floor( mod( 20.0*iTime, 6.0 ) );\n\tp.x += fr*40.0/256.0;\n\treturn textureLod( iChannel0, p, 0.0);\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 computeColor(float n){\n\treturn hsv2rgb(vec3(.3 +0.06 * n, 1., .7));\n}\n\nconst int LOOP_NUM = 150;\nvec3 josKleinian(vec2 pos, vec2 uv, float translation){\n    // draw line3\n    //if(abs(pos.y - lineY(pos, uv.xy)) < .01) return vec3(1);\n    \n    float loopNum = 0.;\n    if(pos.y <= 0. || uv.x < pos.y) {\n    \treturn computeColor(loopNum);\n    }\n    vec2 lz = pos + vec2(1.);\n    vec2 llz = pos + vec2(-1.);\n\n    \n    vec2 catPos1 = vec2(1.5, 1.);\n    vec2 catPos2 = catPos1 - vec2(4., 0.);\n\n    for(int i = 0 ; i < LOOP_NUM ; i++){\n        \n        // orbit trap\n        vec4 c = getNyanCatColor(pos  * 2. - catPos1);\n        if(c.a == 1.) return degamma(c.rgb);\n        c = getNyanCatColor(pos  * 2. - catPos2);\n        if(c.a == 1.) return degamma(c.rgb);\n        c = getNyanCatColor((vec2(-uv.y+2.0, uv.x) + -pos)  * 2. - catPos1);\n        if(c.a == 1.) return degamma(c.rgb);\n        c = getNyanCatColor((vec2(-uv.y-2.0, uv.x) + -pos)  * 2. - catPos2);\n        if(c.a == 1.) return degamma(c.rgb);\n        \n        c = getNyanCatColor(TransAInv(pos, uv) * 2. - catPos1);\n        if(c.a == 1.) return degamma(c.rgb);\n        c = getNyanCatColor(TransAInv(pos, uv) * 2. - catPos2);\n        if(c.a == 1.) return degamma(c.rgb);\n        c = getNyanCatColor((vec2(-uv.y+2.0, uv.x) + -TransAInv(pos, uv)) * 2. - catPos1);\n        if(c.a == 1.) return degamma(c.rgb);\n        c = getNyanCatColor((vec2(-uv.y-2.0, uv.x) + -TransAInv(pos, uv))  * 2. - catPos2);\n        if(c.a == 1.) return degamma(c.rgb);\n        /*\n        c = getNyanCatColor(TransA(pos, uv) * 2. - catPos1);\n        if(c.a == 1.) return degamma(c.rgb);\n        c = getNyanCatColor(TransA(pos, uv) * 2. - catPos2);\n        if(c.a == 1.) return degamma(c.rgb);\n        c = getNyanCatColor((vec2(-uv.y+2.0, uv.x) + -TransA(pos, uv)) * 2. - catPos1);\n        if(c.a == 1.) return degamma(c.rgb);\n        c = getNyanCatColor((vec2(-uv.y-2.0, uv.x) + -TransA(pos, uv))  * 2. - catPos2);\n        if(c.a == 1.) return degamma(c.rgb);\n        */\n        \n        // translate\n    \tpos.x += translation/2. + (uv.y * pos.y) / uv.x;\n        pos.x = mod(pos.x, translation);\n        pos.x -= translation/2. + (uv.y * pos.y) / uv.x;\n        \n        // rotate\n        if (pos.y >= lineY(pos, uv.xy)){\n            //pos -= vec2(-uv.y, uv.x) * .5;\n            //pos = - pos;\n            //pos += vec2(-uv.y, uv.x) * .5;\n            // |\n            pos = vec2(-uv.y, uv.x) - pos;\n            //loopNum++;\n        }\n        \n        // orbit trap\n        c = getNyanCatColor(pos  * 2. - catPos1);\n        if(c.a == 1.) return degamma(c.rgb);\n        c = getNyanCatColor(pos  * 2. - catPos2);\n        if(c.a == 1.) return degamma(c.rgb);\n        c = getNyanCatColor((vec2(-uv.y+2.0, uv.x) + -pos)  * 2. - catPos1);\n        if(c.a == 1.) return degamma(c.rgb);\n        c = getNyanCatColor((vec2(-uv.y-2.0, uv.x) + -pos)  * 2. - catPos2);\n        if(c.a == 1.) return degamma(c.rgb);\n        \n        c = getNyanCatColor(TransAInv(pos, uv)  * 2. - catPos1);\n        if(c.a == 1.) return degamma(c.rgb);\n        c = getNyanCatColor(TransAInv(pos, uv)  * 2. - catPos2);\n        if(c.a == 1.) return degamma(c.rgb);\n        c = getNyanCatColor((vec2(-uv.y+2.0, uv.x) + -TransAInv(pos, uv))  * 2. - catPos1);\n        if(c.a == 1.) return degamma(c.rgb);\n        c = getNyanCatColor((vec2(-uv.y-2.0, uv.x) + -TransAInv(pos, uv))  * 2. - catPos2);\n        if(c.a == 1.) return degamma(c.rgb);\n        /*\n        c = getNyanCatColor(TransA(pos, uv) * 2. - catPos1);\n        if(c.a == 1.) return degamma(c.rgb);\n        c = getNyanCatColor(TransA(pos, uv) * 2. - catPos2);\n        if(c.a == 1.) return degamma(c.rgb);\n        c = getNyanCatColor((vec2(-uv.y+2.0, uv.x) + -TransA(pos, uv)) * 2. - catPos1);\n        if(c.a == 1.) return degamma(c.rgb);\n        c = getNyanCatColor((vec2(-uv.y-2.0, uv.x) + -TransA(pos, uv))  * 2. - catPos2);\n        if(c.a == 1.) return degamma(c.rgb);\n        */\n        pos = TransA(pos, uv);\n        \n        loopNum++;\n        \n        // 2-cycle\n        if(dot(pos-llz,pos-llz) < 1e-6) return vec3(0);\n\n        if(pos.y <= 0. || uv.x < pos.y) {\n        \treturn computeColor(loopNum);\n        }\n        llz=lz; lz=pos;\n    }\n    return vec3(0.);\n}\n\nconst float PI = 3.141592;\nconst float SAMPLE_NUM = 10.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec3 sum = vec3(0);\n\tfloat ratio = iResolution.x / iResolution.y / 2.0;\n    \n    float n = 1.;\n    float k = 2. * cos(PI / n); // default value is k = 2\n    for(float i = 0. ; i < SAMPLE_NUM ; i++){\n        vec2 position = ( (fragCoord.xy + (rand2n(fragCoord.xy, i))) / iResolution.yy ) - vec2(ratio, 0.5);\n        position = position * 2.1;\n        position.y += 1.;\n        position.x += 1.86 - mod(iTime, 2.);\n        \n        sum += josKleinian(position, \n                           vec2(2. - .1*abs(sin(iTime)), 1.*(sin(iTime))), \n                           k);\n\n    }\n    fragColor = vec4(gammaCorrect(sum/SAMPLE_NUM), 1.);\n}", "image_inputs": [{"id": "Xsf3Rn", "previewfilepath": "/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldsfWS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldsfzj", "name": "Sketch_TriLattice8", "author": "cexlearning", "description": "TriLattice8copy from https://github.com/keijiro/ShaderSketches", "tags": ["sketch"], "likes": 7, "viewed": 147, "date": "1497060518", "time_retrieved": "2024-06-20T18:56:03.962793", "image_code": "float rand(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 uv2tri(vec2 uv)\n{\n    float sx = uv.x - uv.y / 2.0; // skewed x\n    float offs = step(fract(1.0 - uv.y), fract(sx));\n    return vec2(floor(sx) * 2.0 + offs, floor(uv.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    float res = iResolution.y / (5.0 + sin(iTime * 0.5));\n\n    vec2 uv = (fragCoord.xy - iResolution.xy / 2.0) / res;\n\n    vec3 p = vec3(dot(uv, vec2(1.0, 0.5)), dot(uv, vec2(-1.0, 0.5)), uv.y);\n    vec3 p1 = fract(+p);\n    vec3 p2 = fract(-p);\n\n    // distance from borders\n    float d1 = min(min(p1.x, p1.y), p1.z);\n    float d2 = min(min(p2.x, p2.y), p2.z);\n    float d = min(d1, d2);\n\n    // border line\n    float c = clamp((d - 0.04) * res, 0.0, 1.0);\n\n    // gradient inside triangles\n    float r = rand(uv2tri(uv));\n    c *= abs(0.5 - fract(d + r + iTime * 0.8)) * 2.0;\n\n    // color variation\n    float cb = sin(iTime * 4.8 + r * 32.984) * 0.5 + 0.5;\n    vec3 rgb = mix(vec3(0.75, 0, 0), vec3(1, 0.5, 0.5), cb);\n\n    fragColor = vec4(rgb * c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldsfzj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldXBDM", "name": "23/100", "author": "yahe", "description": "Lack of ideas.. T_T", "tags": ["wave"], "likes": 5, "viewed": 505, "date": "1496358615", "time_retrieved": "2024-06-20T18:56:03.962793", "image_code": "#define SCALE 25.\n#define SPEED 5.\n#define FREQUENCY .7\n\nfloat d;\n#define D(p,o)  ( d=length(p-o)<=.1 ? d:.95 )\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y; \n   \tuv *= SCALE;\n    \n    vec2 f = fract(uv);\n    uv = floor(uv);\n    \n    float t= sqrt( uv.x*uv.x + uv.y*uv.y) * FREQUENCY + iTime*SPEED;\n    \n    vec2 o = vec2(cos(t),sin(t))*.4+.5;\n    \n    fragColor.xyz = vec3(D(f,o));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldXBDM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldXBDX", "name": "Playing around with Raymarching1", "author": "VoidChicken", "description": "A shader I made while messing around in Visual Studio Code.", "tags": ["3d", "raymarch"], "likes": 6, "viewed": 115, "date": "1498455739", "time_retrieved": "2024-06-20T18:56:03.962793", "image_code": "vec2 rotate(vec2 a, float b){\n    float c=length(a),r=atan(a.x,a.y)+b;\n    return vec2(cos(r),sin(r))*c;\n}\nfloat box(vec3 p,vec3 b) {\n    return length(max(abs(p)-b,0.));\n}\nfloat smin( float a, float b)\n{\n    float k = 0.1;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat map(vec3 o) {\n    o.xz=rotate(o.xz,iTime);\n    o.y=1.-o.y;\n    float f = 0.0;\n    f=length(o)-1.;//box(o,vec3(1.));\n    f=max(-f,box(o-vec3(0,.5,0),vec3(1.1,.51,1.1)));\n    f=smin(f,length(o+vec3(.7,.1,0))-.5);\n    f=smin(f,box(o,vec3(.5)));\n    return f;\n}\nvec3 normal( in vec3 x)\n{\n    vec2 e = vec2( .01, 0.0 );\n    return normalize( vec3( map(x+e.xyy) - map(x-e.xyy),\n                            map(x+e.yxy) - map(x-e.yxy),\n                            map(x+e.yyx) - map(x-e.yyx) ) );\n}\n\nfloat trace(vec3 o, vec3 d){float t=0.;for(int i=0;i<128;i++){t+=map(o+d*t)*.7;}return t;}\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec2 u = fragCoord.xy/iResolution.xy;\n    vec3 mc = vec3(1,1,.2),c=mc;\n    vec3 o = vec3(0,3,-5), d=vec3(u*2.-1.,2.);\n    d.y-=.7;\n    d.x*=iResolution.x/iResolution.y;\n    d=normalize(d);\n\n    float t = trace(o, d);\n    vec3 h = o+d*t;\n    float b = map(h);\n    if(b<.01){\n        float m = abs(dot(normal(h),normalize(h)));\n        c=vec3(max(m,.1));\n        c=mix(mc,c,dot(normal(h),-d));\n        float s = (length(normal(h))/10.-map(h+normal(h)/10.))*1.;\n        c-=s;\n    }\n    c=mix(c,vec3(0),length(u-.5));\n    fragColor = vec4(c,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldXBDX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldXBRf", "name": "Raymarching 02", "author": "darkace65", "description": "Writing a raymarcher from scratch", "tags": ["raymarching"], "likes": 3, "viewed": 83, "date": "1497200627", "time_retrieved": "2024-06-20T18:56:03.962793", "image_code": "#define EPSILON 0.0001\n\nconst int MAX_MARCHING_STEPS = 100;\nconst float MAX_DEPTH = 100.0;\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvec3 viewDir(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nfloat udRoundBox(vec3 p, vec3 b, float r) {\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sceneSDF(vec3 p) {\n    return udRoundBox(p, vec3(0.4, 0.2, 0.7), 0.3);\n}\n\nvec3 normal(vec3 p) {\n    vec3 x = vec3(EPSILON, 0.0, 0.0);\n    vec3 y = vec3(0.0, EPSILON, 0.0);\n    vec3 z = vec3(0.0, 0.0, EPSILON);\n    return normalize(vec3(\n        (sceneSDF(p + x) - sceneSDF(p - x)),\n        (sceneSDF(p + y) - sceneSDF(p - y)),\n        (sceneSDF(p + z) - sceneSDF(p - z))\n    ));\n}\n\nfloat raymarch(vec3 camera, vec3 ray) {\n    float depth = 0.0;\n    for(int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(camera + depth * ray);\n        if(dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if(depth >= MAX_DEPTH) {\n            return MAX_DEPTH;\n        }\n    }\n    return MAX_DEPTH;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 camera = vec3(-9.0 * cos(iTime / 4.0), 4.0, 9.0 * sin(iTime / 4.0));\n    vec3 focus = vec3(0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    mat4 viewToWorld = viewMatrix(camera, focus, up);\n    \n    vec3 viewRay = viewDir(45.0, iResolution.xy, fragCoord);\n    vec3 cameraRay = (viewToWorld * vec4(viewRay, 0.0)).xyz;\n    \n    float dist = raymarch(camera, cameraRay);\n    \n    vec3 color = vec3(0.0);\n    if(dist <= MAX_DEPTH - EPSILON) {\n        vec3 p = camera + dist * cameraRay;\n        color = normal(p).xzy;\n    }\n\tfragColor = vec4(color * 0.5 + 0.5, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldXBRf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldXBWj", "name": "First SDF shader", "author": "revillo", "description": "First attempt at writing ray marching and basic sdf boolean geometry + rendering. ", "tags": ["procedural", "raymarching", "sdf"], "likes": 0, "viewed": 105, "date": "1498071102", "time_retrieved": "2024-06-20T18:56:04.799302", "image_code": "float sphere_sdf(vec3 center, float radius, vec3 pos) {\n\n \treturn (length(center - pos) - radius);\n}\n\n\nfloat box_sdf(vec3 center, vec3 dimensions, vec3 pos) {\n\n\tvec3 dist = abs(pos - center) - dimensions;\n    return max(max(dist.x, dist.y), dist.z);\n    \n    \n}\n\nfloat union_sdf(float sdf1, float sdf2) {\n\n    return min(sdf1, sdf2);\n\n}\n\nfloat intersect_sdf(float sdf1, float sdf2) {\n\n\treturn max(sdf1, sdf2);\n    \n}\n\nfloat exclude_sdf(float sdf1, float sdf2) {\n\n    return max(sdf1, -sdf2);\n\n}\n\nfloat cone(in vec3 p, in vec3 c) {\n    vec2 q = vec2(length(p.xz), p.y);\n    float d1 = -p.y-c.z;\n    float d2 = max(dot(q, c.xy), p.y);\n    return length(max(vec2(d1, d2),0.0)) + min(max(d1, d2), 0.0);\n}\n\n\nfloat gem_sdf(in vec3 ray)\n{\n    float heightFactor = 1.5;\n    vec3 coneBase = vec3(0.35, 0.4, 1.64 * heightFactor);\n    vec3 coneBase2 = vec3(0.4, 0.3, 2.5 * heightFactor);\n\n\n    // your magical distance function\n    float cone1 = cone(vec3(ray.x, ray.y - coneBase.z , ray.z), coneBase);\n    float cone2 = cone(vec3(ray.x, -ray.y - coneBase2.z, ray.z), coneBase2);\n    return max(ray.y - coneBase.z * 0.3, min(cone1, cone2));\n\n}\n\n\n\nvec3 repeat_y(vec3 pos) {\n  float y = mod(pos.y, 30.0);\n  return vec3(pos.x, y, pos.z);\t\n}\n\nvec3 repeat_x(vec3 pos) {\n  float x = mod(pos.x + iTime * 35.0, 30.0);\n  return vec3(x, pos.yz);\n}\n\nvec3 repeat_z(vec3 pos) {\n  float z = mod(pos.z - 40.0, 50.0);\n  return vec3(pos.xy, z);\n}\n\n\n\n\n\nfloat sdf(vec3 pos) {\n\n    \n   // pos = repeat_x(pos);\n   // pos = repeat_y(pos);\n   // pos = repeat_z(pos);\n    \n    //return intersect_sdf(sphere_sdf(vec3(15.0,15.0,50.0), 15.0, pos),\n\t//box_sdf(vec3(15.0, 15.0, 50.0), vec3(12.0, 12.0, 2.0), pos));\n    \n    //return exclude_sdf(box_sdf(vec3(15.0, 15.0, 35.0), vec3(12.0, 12.0, 2.0), pos),\n    //                   sphere_sdf(vec3(15.0,15.0,35.0), 10.0, pos));\n\t\n    \n    \n    pos.z -= 5.0;\n    return gem_sdf(pos);\n    //return box_sdf(vec3(0.0, 0.0, 50.0), vec3(2.0, 2.0, 2.0), pos);\n}\nvec3 roundNormal(vec3 n, float tf, float pf) {\n      \n    /*\n    float phi = asin(n.z) / 3.14159 + 0.5;\n\n    float theta = atan(n.y, n.x) / 3.14159 + 0.5;\n\n    theta = ((floor(theta * tf + 0.5) / tf) - 0.5) * 3.14159;\n    phi = ((floor(phi * pf + 0.5) / pf) - 0.5) * 3.14159;\n\n    return vec3(cos(theta) * cos(phi), sin(theta) * cos(phi), sin(phi));*/\n    \n    return floor(n * 5.0) / 5.0;\n}\n\nvec3 normal_sdf(vec3 pos) {\n\n  const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n  const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n  const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n  const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n    \n  const float eps = 0.02;\n\n  return normalize( v1 * sdf( pos + v1*eps ) +\n                    v2 * sdf( pos + v2*eps ) +\n                    v3 * sdf( pos + v3*eps ) +\n                    v4 * sdf( pos + v4*eps ) );\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n\t\n    uv *= 2.0;\n    uv -= vec2(iResolution.x / iResolution.y, 1.0);\n    \n    vec3 ray = normalize(vec3(uv, 1.0) - vec3(0.0,0.0,0.6 + sin(iTime * 2.0) * 0.05));\n    \n    vec3 eye = -ray;\n    \n    float minMarch = 0.05 + max(sin(iTime * 10.0) * 0.0, 0.0);\n    float dist = 1.0;\n    const float maxDist = 150.0;\n    \n \n    const int maxSteps = 40;\n    int currentStep = 0;\n    \n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    vec3 pos;\n    \n    \n    float currentDistance;\n    \n    int hit = 0;\n    vec3 hitposition = vec3(0.0, 0.0, 0.0);\n    \n    while(currentStep < maxSteps)\n    {\n        pos = ray * dist;\n        currentDistance = sdf(pos);\n        \n    \tdist += max(0.0, currentDistance);\n        \n        \n        hit += int(currentDistance < 0.01);\n        ++currentStep;\n    }\n    \n  \n    vec3 normal = roundNormal(normal_sdf(pos), 8.0 ,64.0);\n    float diffuse = (dot(normal, normalize(vec3(1.0, 0.2, -1.0))) * 0.5 + 0.5) * (1.0 - dist / maxDist);\n            \n    vec2 specShift = vec2(sin(iTime * 5.0), cos(iTime * 5.0));\n            \n    float specular = pow(max(0.0, dot(reflect(eye, normal), normalize(vec3(specShift, 1.0)))), 2.0) * 0.3;\n    \n    diffuse = diffuse * float(hit > 0);\n    specular = specular * float(hit > 0);\n    \n    fragColor = vec4(vec3(1.0,0.5,0.5) * diffuse + vec3(0.9, 0.9, 0.7) * specular, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldXBWj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldXfRl", "name": "Mandel Hex Vox", "author": "dr2", "description": "Voxel tracing with hexagonal prisms", "tags": ["mandelbrot", "voxel", "hexagon"], "likes": 17, "viewed": 602, "date": "1497468971", "time_retrieved": "2024-06-20T18:56:04.805925", "image_code": "// \"Mandel Hex Vox\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Hexagonal prism voxel traversal derived from shader by mattz; architecture\n// from \"Mandel City\".\n\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\n\n#define MULTI 0   // set =1 for extra reflections\n#define SQRT3 1.73205\n\nvec3 sunDir, cHit, qnHit;\nfloat tCur, dstFar;\nconst float hcScale = 1.2;\nconst vec3 hcSize = vec3 (0.5 * SQRT3, 1., 2.);\nconst float pi = 3.14159;\n\nbool HexCellFull (vec3 p)\n{\n  vec2 v, w;\n  float h;\n  p = (p * hcSize).yzx / hcScale;\n  p.xz *= 0.03;\n  p.x -= 0.85;\n  h = 0.;\n  if (length (p.xz + vec2 (0.25, 0.)) > 0.45 &&\n     length (p.xz + vec2 (1., 0.)) > 0.2 &&\n     (p.x < 0. || abs (p.z) > 0.04)) {\n    v = p.xz;\n    h = 80.;\n    for (int j = 0; j < 80; j ++) {\n      w = v * v;\n      if (w.x + w.y > 4.) {\n        h = float (j + 1);\n        break;\n      } else v = p.xz + vec2 (w.x - w.y, 2. * v.x * v.y);\n    }\n  }\n  return (0.3 * h > p.y);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec2 c, r, dr;\n  c = vec2 ((2. / SQRT3) * p.x, p.y);\n  r = floor (c);\n  r += mod (vec2 (r.x, r.y + step (2., mod (r.x + 1., 4.))), 2.);\n  dr = c - r;\n  r += step (1., 0.5 * dot (abs (dr), vec2 (SQRT3, 1.))) * sign (dr) * vec2 (2., 1.);\n  return r;\n}\n\nfloat HexVolRay (vec3 ro, vec3 rd)\n{\n  vec3 ht, htt, w;\n  vec2 hv[3], ve;\n  float dHit, ty, dy;\n  ro *= hcScale;\n  cHit = vec3 (PixToHex (ro.zx), floor (ro.y / hcSize.z + 0.5));\n  hv[0] = vec2 (0., 1.);\n  hv[1] = vec2 (1., 0.5);\n  hv[2] = vec2 (1., -0.5);\n  for (int k = 0; k < 3; k ++)\n     hv[k] *= sign (dot (hv[k], vec2 (0.5 * SQRT3 * rd.z, rd.x)));\n  dy = sign (rd.y);\n  qnHit = vec3 (0.);\n  dHit = dstFar * hcScale + 0.01;\n  for (int j = 0; j < 160; j ++) {\n    w = ro - (cHit * hcSize).yzx;\n    ht.z = 1e6;\n    for (int k = 0; k < 3; k ++) {\n      ve = vec2 (0.5 * SQRT3 * hv[k].x, hv[k].y);\n      htt = vec3 (hv[k], (1. - dot (ve, w.zx)) / dot (ve, rd.zx));\n      if (htt.z < ht.z) ht = htt;\n    }\n    ty = (0.5 * dy * hcSize.z - w.y) / rd.y;\n    if (ht.z < ty) cHit.xy += 2. * ht.xy;\n    else cHit.z += dy;\n    if (HexCellFull (cHit)) {\n      if (ht.z < ty) {\n        qnHit = - vec3 (0.5 * SQRT3 * ht.x, ht.y, 0.);\n        dHit = ht.z;\n      } else {\n        qnHit = - vec3 (0., 0., dy);\n        dHit = ty;\n      }\n      break;\n    }\n  }\n  return dHit / hcScale;\n}\n\nfloat EdgeDist (vec3 p)\n{\n  vec2 dh;\n  float d;\n  p *= hcScale;\n  dh = p.zx - cHit.xy * vec2 (0.5 * SQRT3, 1.);\n  if (qnHit.z == 0.) {\n    d = abs (fract (p.y / hcSize.z) - 0.5) * hcSize.z;\n    dh -= qnHit.xy * dot (dh, qnHit.xy);\n    d = min (d, abs (length (dh) - 1. / SQRT3));\n  } else {\n    dh = abs (dh);\n    d = max (0.5 * dot (dh, vec2 (SQRT3, 1.)), dh.y) - 1.;\n  }\n  return d;\n}\n\nvec3 BgCol (vec3 ro, vec3 rd)\n{\n  vec3 vn, col;\n  vec2 w, e;\n  float f;\n  if (rd.y >= 0.) {\n    col = vec3 (0.1, 0.2, 0.4) + 0.2 * pow (1. - rd.y, 8.) +\n       0.35 * pow (max (dot (rd, sunDir), 0.), 6.);\n    col = mix (col, vec3 (0.9), clamp (0.1 + 0.8 * rd.y *\n       Fbm2 (5. * rd.xz / max (rd.y, 0.001)), 0., 1.));\n  } else {\n    ro -= rd * ro.y / rd.y;\n    w = 0.5 * ro.xz;\n    f = Fbm2 (w);\n    e = vec2 (0.01, 0.);\n    vn = normalize (vec3 (f - Fbm2 (w + e.xy), 0.1, f - Fbm2 (w + e.yx)));\n    col = mix (vec3 (0.4, 0.5, 0.2), vec3 (0.35, 0.3, 0.1), f) *\n       (1. - 0.1 * Noisefv2 (31. * w));\n    col *= 0.1 + 0.9 * max (dot (vn, sunDir), 0.);\n    col = mix (col, vec3 (0.1, 0.2, 0.4) + 0.25, pow (1. + rd.y, 32.));\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  float dHit;\n  ro += 50. * rd;\n  ro.x += 8.;\n  dHit = HexVolRay (ro, rd);\n  ro += rd * dHit;\n  if (length (ro.xz - vec2 (8., 0.)) > 50.) dHit = dstFar;\n  if (dHit < dstFar) {\n    if (abs (EdgeDist (ro)) > 0.15) {\n      rd = reflect (rd, qnHit.yzx);\n      ro += 0.01 * rd;\n      dHit = HexVolRay (ro, rd);\n      ro += rd * dHit;\n      if (length (ro.xz - vec2 (8., 0.)) > 50.) dHit = dstFar;\n#if MULTI\n      if (dHit < dstFar) {\n        if (abs (EdgeDist (ro)) > 0.15) {\n          rd = reflect (rd, qnHit.yzx);\n          ro += 0.01 * rd;\n          dHit = HexVolRay (ro, rd);\n          ro += rd * dHit;\n          if (length (ro.xz - vec2 (8., 0.)) > 50.) dHit = dstFar;\n        }\n      }\n#endif\n    }\n  }\n  if (dHit < dstFar) col = BgCol (ro, reflect (rd, qnHit.yzx)) *\n     (0.4 + 0.6 * step (0.15, abs (EdgeDist (ro))));\n  else col = BgCol (ro, rd);\n  col = pow (clamp (col, 0., 1.), vec3 (0.8));\n  return col;\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  if (mPtr.z > 0.) {\n    az = 2.5 * pi * mPtr.x;\n    el = -0.3 * pi + 0.7 * pi * mPtr.y;\n  } else {\n    az = 1.2 * pi * sin (0.017 * pi * tCur);\n    el = -0.15 * pi + 0.1 * pi * sin (0.05 * pi * tCur);\n  }\n  el = clamp (el, -0.45 * pi, -0.02 * pi);\n  dstFar = 200.;\n  zmFac = 3.;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  ro = vuMat * vec3 (0., 0., -120.);\n  sunDir = normalize (vec3 (1., 1., -1.));\n  ro.y += 1.;\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldXfRl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldXfzj", "name": " Power Packed Alliance 4", "author": "patu", "description": "Used as visuals in cooperation of polish demoscene musicians. \nReleased in wild compo at Decrunch copy party, 3 June 2017\n \nhttp://www.pouet.net/prod.php?which=70247", "tags": ["demoscene", "demo", "wild"], "likes": 9, "viewed": 697, "date": "1497026031", "time_retrieved": "2024-06-20T18:56:06.314653", "image_code": "/*\n\n\tTunnel4 a.k.a \"Ice cave\"\n    for cooperation of polish demoscene musicians, called:\n    \n    \n    \"Power Packed Alliance\".\n    -----------------------------------\n\n\thttps://www.youtube.com/watch?v=_lSReW7eRI4\n    http://www.pouet.net/prod.php?which=70247\n\n\t\n    \n    also check my chrome extension for Shadertoy:\n    https://chrome.google.com/webstore/detail/shadertoy-unofficial-plug/ohicbclhdmkhoabobgppffepcopomhgl?hl=pl\n\n*/\n\n\n\n#define getNormal getNormalHex\n\n#define INFINITY 1e32\n#define FAR 30.\n#define t iTime / patternTime\n#define mt iTime\n#define FOV 110.0\n#define FOG .7\n\nfloat yC(float x) {\n \treturn cos(x * -.34) * 1. * sin(x * .3) * 5.;\n}\n\n// \t3D noise function (IQ)\nfloat noise(vec3 p)\n{\n\tvec3 ip=floor(p);\n    p-=ip; \n    vec3 s=vec3(7,157,113);\n    vec4 h=vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\n    p=p*p*(3.-2.*p); \n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z); \n}\n\nfloat vol;\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Repeat in three dimensions\nvec3 pMod3(inout vec3 p, vec3 size) {\n\tvec3 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\treturn c;\n}\n\nfloat opU2( float d1, float d2 ) {\n    if (d1 < d2) return d1;\n    return d2;\n}\n\nvec3 opU2( vec3 d1, vec3 d2) {\n    if (d1.x < d2.x) return d1;\n    return d2;\n}\n\nvec3 opS2( vec3 d1, vec3 d2) {\t\n    if (-d2.x > d1.x) return -d2;\n    return d1;\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat fCross(vec3 p, vec3 size) {\n    float obj = fBox(p, size);\n    obj = opU2(obj, fBox(p, size.zxy));\n    obj = opU2(obj, fBox(p, size.yzx));               \n               return obj;\n}\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nvec3 DE(vec3 p) {\n \tconst float scale = 1.;\n\tconst float offset = 1.2;\n    const int FRACTALITERATIONS = 8;\n    vec3 modifier = vec3(1.4 , 1.1, 1.9);\n\t\n\tfor(int n=0; n< FRACTALITERATIONS; n++)\n\t{\n        p.xy = (p.x + p.y < 0.0) ? -p.yx : p.xy;\n\t\tp.xz = (p.x + p.z < 0.0) ? -p.zx : p.xz;\n\t\tp.zy = (p.z + p.y < 0.0) ? -p.yz : p.zy;\n\n        pR(p.yz, 0.282915);\n        \n\t\tp = scale*p-offset*(scale-.1) * modifier;\n\t}\n    \n \tvec3 obj;\n    \n    obj.x = fBox(p, vec3(.2, 2.1, 3.)) * (pow(scale, -float(FRACTALITERATIONS))) - 0.1; \n\t\n    return obj;\n}\nvec3 map(vec3 p) {\n    p.y -= yC(p.x);\n    \n    vec3 mp = p; \n    vec3 \n        obj = vec3(FAR, 0.0, 0.0),\n        obj2 = obj,\n        obj3 = obj;\n    \n    vec3 fra =  DE(mod(mp + 10., vec3(20.)) - 10.);\n    fra.y = 3.;\n    \n    vec3 orgP = p;\n    vec3 orgP3 = p;\n\n    float matDetail = 1.0;\n    float mat = 2.0;\n\t\n    orgP3 = p;\n    \n    vec3 pp = pMod3(orgP3, vec3(2.4));\n    \n    p = orgP3;\n    \n    mat = 1.;\n    obj = vec3(\n        fBox(p, vec3(1.05)), \n        mat, \n        matDetail\n    );\n    \n    vec3 orgP2 = orgP;\n    \n    pR(orgP.zy, orgP.x / 12.);\n\t\n    vec3 size = vec3(0.725 , 1.5, 1.275);\n    \n    p = opRep(orgP, vec3(0.35, 0.1, .4) + size.x + size.y + size.z);\n    \n    obj = opS2(\n        obj, \n        vec3(                \n            fCross(p, size), \n            0.0, \n            matDetail\n        )\n    );\n\t\n    size *= 1.2;\n    p = opRep(orgP, vec3(0.35, 0.5, 0.1) + size.x + size.x + size.z);\n \n    obj = opS2(\n        obj, \n        vec3(                \n            fCross(p, size), \n            0.0, \n            matDetail\n        )\n    );\n    \n    p = orgP2;\n    \n    float n = noise(p);\n  \t\n    pR(p.yz, p.x * .8 + n * 7.);\n    p.y += .6;\n    \n    obj3.x = fCross(p, vec3(1e32, 2.1, .1));\n    obj3.y = 2.;\n    \n    p = orgP2;\n    \n\tobj = opS2(obj, vec3(fCross(p, vec3(1e32, .6, .6) ), 1., 1.)); \n\tobj3.x = mix(-length(p.zy) + .5, obj3.x, 0.55 * n);\n    \n  \tobj3 = opS2(obj3, fra);\n    \n    return obj3;\n}\n\nvec3 trace(vec3 prp, vec3 scp) {\n    vec3 \n        tr = vec3(0., -1., 0.),\n        d;\n    \n    for (int i = 0; i < 74; i++) {\t\n        d = map(prp + scp * tr.x);\n        tr.x += d.x * .7;\n        if ((abs(d.x) < .01) || (tr.x > FAR)) break;\n    }\n    \n    tr.yz = d.yz;\n\treturn tr;\n    \n}\nvec3 traceRef(vec3 ro, vec3 rd) {\n    vec3 \n        tr = vec3(0., -1., 0.),\n        d;\n    \n    for (int i = 0; i < 20; i++) {\n        d = map(ro + rd * tr.x);\n        tr.x += d.x;\n        \n        if (abs(d.x) < 0.0055 || tr.x> FAR) break;\n    }\n    \n    tr.yz = d.yz;\n    return tr;\n}\n\n#define EPSILON .1\nvec3 getNormalHex(vec3 pos)\n{\n\tfloat d=map(pos).x;\n\treturn normalize(\n        vec3(\n            map(\n                pos+vec3(EPSILON,0,0)).x-d,\n                map(pos+vec3(0,EPSILON,0)).x-d,\n                map(pos+vec3(0,0,EPSILON)).x-d \n        \t)\n    \t);\n}\n\nvec3 getObjectColor(vec3 p, vec3 n, inout vec2 mat) {\n    vec3 col = vec3(.1);    \n    \n    return col;\n}\n\nvec3 doColor( in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, inout vec2 mat) {\n\tvec3 sceneCol = vec3(0.0);\n    vec3 ld = lp - sp; \n    float lDist = max(length(ld), 0.001); \n    \n    ld /= lDist;\n\n    float atten = 2.0 / (1.0 + lDist * 0.525 + lDist * lDist * 0.05);\n\tfloat diff = max(dot(sn, ld), .1);\n    float spec = pow(max(dot(reflect(-ld, sn), -rd), .5), 2.0);\n\tvec3 objCol = getObjectColor(sp, sn, mat);\n    \n    sceneCol += (objCol * (diff + 0.15) + vec3(.6, .9, 1.6) * spec * 1.) * atten;\n    return sceneCol;\n\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec2 uv = fragCoord.xy / iResolution.xy - .5;\n\t//uv.x /= iResolution.x/iResolution.y;\n\t\n    uv *= tan(radians (FOV) / 2.0);\n    \n    vol = texture(iChannel0, vec2(.0, .25)).r  * 1.; \n    \n    float \n        sk = sin(mt * .2) * 2.0,\n        ck = cos(mt * .3) * 2.0,\n        mat = 0.;\n\n    float camx = mt * 1.5;\n    \n    vec3 \n        vuv = vec3(0., 1., sin(mt / 3.)),\n    \tro = vec3(camx, yC(camx), 0.),\n    \tvrp =  vec3(camx + 1., yC(camx + 1.), 0.),\n    \tvpn = normalize(vrp - ro),\n    \tu = normalize(cross(vuv, vpn)),\n    \tv = cross(vpn, u),\n    \tvcv = (ro + vpn),\n    \tscrCoord = (vcv + uv.x * u * iResolution.x/iResolution.y + uv.y * v),\n    \trd = normalize(scrCoord - ro),\n        lp = ro,\n\t\torgRO = ro,\n        orgRD = rd,\n        sceneColor = vec3(0.);\n\t\n    vec3 tr = trace(ro, rd);\n    \n    float fog = smoothstep(FAR * FOG, 0., tr.x);\n    \n    ro += rd * tr.x;\n    \n    vec3 sn = getNormal(ro);\t\n   \t\n    sceneColor += doColor(ro, rd, sn, lp, tr.yz);\n\n    float dist = tr.x;\n    \n    if (tr.y != 3.) {\n        rd = reflect(rd, sn);\n        tr = traceRef(ro + rd * .03, rd);\n        ro += rd * tr.x;\n        sn = getNormal(ro);\n        sceneColor += doColor(ro, rd, sn, lp, tr.yz) * .2;\n    } else {\n        sceneColor *= 0.;\n    }\n\n    fragColor = vec4(clamp(sceneColor * 2., 0.0, 1.0), tr.x / FAR);\n}\n", "image_inputs": [{"id": "ldsSD4", "previewfilepath": "https://soundcloud.com/decrunch/power-packed-alliance", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/decrunch/power-packed-alliance", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldXfzj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "ldySzy", "name": "HOWTO: Circle", "author": "yoyobbi", "description": "Makes a coloured circle.", "tags": ["procedural"], "likes": 0, "viewed": 83, "date": "1497990326", "time_retrieved": "2024-06-20T18:56:06.454150", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Compute viewport coords relative to center of screen.\n    vec2 center = iResolution.xy * 0.5;\n    float size = min(center.x, center.y);\n    vec2 view = ((fragCoord.xy - center) / size);\n    \n    // Make a pretty colour.\n\tfragColor = vec4(view, 0.5 + 0.5 * sin(iTime), 1.0);\n    \n    // Invert the colour if outside a (soft-edged) circle.\n    float r = length(view);\n    float inCircle = smoothstep(0.95, 1.05, r);\n    fragColor = fragColor * inCircle + (1.0 - fragColor) * (1.0 - inCircle);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ldySzy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsfBDB", "name": "Forest Sunset", "author": "AlexM", "description": "Trying out some of this terrain raymarching stuff. Fake forest looks a bit noisy.", "tags": ["terrain"], "likes": 5, "viewed": 468, "date": "1497861849", "time_retrieved": "2024-06-20T18:56:07.702483", "image_code": "#define PI 3.141592653589793 \n\nconst float WORLEYMAXDIST = 8.0; // worley noise max distance\nconst float MAXLENGTH = 190.0; // maximum ray length\nconst vec3  SUNDIRECTION = normalize(vec3(1.0, -0.3, -0.4)); //direction of the sunlight\nconst vec3  SUNCOLOR = normalize(vec3(0.960, 0.619, 0.180)); // sun color? \nconst float FOGHEIGHT = 0.01; // background fog height. \nconst float FOGFADEHEIGHT = 0.2; // background fog fade height - fades background fog into actual sky.\nconst vec3  FOGCOLOR = vec3(0.996, 0.878, 0.603);\n\nfloat random(in vec2 st) { \n    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nmat3 rotateY(float n) {\n    float a = cos(n);\n    float b = sin(n);\n    return mat3( a, 0.0, b, 0.0, 1.0, 0.0, -b, 0.0, a );\n}\n\nmat3 rotateX(float n) {\n    float a = cos(n);\n    float b = sin(n);\n    return mat3( 1.0, 0.0, 0.0, 0.0, a, -b, 0.0, b, a );\n}\n\nfloat noise2D(vec2 uv) {\n    vec2 st = 0.1 * uv; \n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    \n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n    \n    \n    vec2 u = f*f*(3.0-2.0*f);\n    float a1 = mix(a, b, u.x);\n    float a2 = mix(c, d, u.x);\n    float a3 = mix(a1, a2, u.y);\n    return clamp(a3, 0.0, 1.0); \n}\n\nfloat worley(vec2 uv) {\n\tvec2 tileCoord = floor(uv);    \n    \n    float dist = 9999999.0;\n    for (int y = -1; y <= 1; y++)\n    for (int x = -1; x <= 1; x++) {\n        vec2 currentTile = tileCoord + vec2(x, y);\n        vec2 point = currentTile + random(currentTile);\n        // not entirely correct but makes fakes trees look better... imho\n        dist = min(dist, sqrt(length(point-uv))); \n    }\n    dist = clamp(dist, 0.0, WORLEYMAXDIST) / WORLEYMAXDIST;\n    return dist;\n}\n\nfloat fbm(vec2 st) {\n    float value = 0.0;\n    float amplitud = 0.5;\n    float frequency = 0.2;\n\n    const int octaves = 3;\n    for (int i = 0; i < octaves; i++) {\n        value += amplitud * noise2D(st * frequency);\n        st *= 2.;\n        amplitud *= .5;\n        frequency *= 1.20;;\n    }\n    return value;\n}\n\nfloat trees(vec2 st) {\n    float a = fbm(st.xy * 1.9) + 1.0;\n    float x = 2.0 * worley(st * 7.5) - 1.0;\n    return a+(min(-x, 0.91)  * 2.5 * fbm(st * 20.0)); \n}\n\nfloat terrain(vec2 st) {\n    float a = fbm(st.xy * 1.9) + 1.0;\n    a = abs(1.0-a)  * 19.0 - 4.0;\n    float b = fbm(st.yx * 41.3);\n    return a - b*(a*0.20); \n}\n\nfloat map(vec2 st, out int mattype) {\n    float terrainh = terrain(st) + 2.0; \n    float treesh = trees(st * 1.1) * 1.4 + 0.35; \n    float h = max(treesh, terrainh);\n    if (h == terrainh)  mattype = 1; \n    if (h == treesh)    mattype = 2; \n    return h;\n}\n\nvec2 trace(vec3 ro, vec3 rd, out int mattype) {\n\n    float height = -1.0;\n    float t = 0.02;\n    float tmax = MAXLENGTH;\n   \n\n    for (;t < tmax;) {\n        int m = 0;\n        vec3 rp = ro + rd * t;\n        float h = map(rp.xz, m);\n        float d = rp.y - h;\n\n        if (d < 0.01) {\n            height = h;\n            mattype = m;\n            break;\n        }\n        t += 0.5 * d;\n    }\n\n    return vec2(height, t);\n}\n\nvec3 getNormal(vec3 rp) {\n    int unused = 0;\n    vec2 eps = vec2(0.01, 0.0);\n    vec3 normal = normalize(vec3( \n        map(rp.xz - eps.xy, unused) - map(rp.xz + eps.xy, unused),\n        2.0 * eps.x, \n        map(rp.xz - eps.yx, unused) - map(rp.xz + eps.yx, unused) \n    ));\n    return normal;\n}\n\n\nvec3 getShading(vec3 p, vec3 ld, vec3 n) {\n    int unused;\n    // lambert\n    float kd = max(0.0, dot(-ld, n));\n    // cast shadow ray...\n\n    vec3 a = p + vec3(0.0, 0.1, 0.0);\n    vec2 s = trace(a, -SUNDIRECTION, unused);\n    float sh = (s.x == -1.0) ? 1.0 : 0.0;\n\n    return (kd * SUNCOLOR * sh) ;\n}\n\n// that is really shitty AO but at least unlit fragments do not look so plain... :)\nfloat bad_ao(vec3 n) {\n    return abs(dot(n, vec3(0.0, 1.0, 0.0))); \n}\n\nfloat fog(float dist) {\n    const float density = 0.008;\n    return  1.0 - 1.0/exp(pow(dist * density, 2.0));\n}\n\n// shamelessly stol... borrowed this from a certain thread on pouet\nvec3 postprocess(vec3 color) {\n    const float contrast   = 0.15;\n    const float brightness = 2.4;\n    const float gamma = 1.5;  // higher => darker; lower => brighter\n    const float saturation = 1.4;\n\n    color = color * brightness;\n    color = pow(color, vec3(gamma));\n    color = color * 0.5 + contrast * 0.5;\n\n    float luminance = dot(vec3(0.2126, 0.7152, 0.0722), color);\n    color = luminance + (color - luminance) * saturation;\n\n    return clamp(color, 0.0, 1.0);\n}\n\nvec3 sky(vec3 ro, vec3 rd, vec2 st) {\n    vec3 color = vec3(0.8, 0.5, 0.4);\n    color += smoothstep(0.3, 0.6, fbm(rd.xz * 90.0 / rd.y));\n\n    float d = dot(-SUNDIRECTION, rd); // sun??\n    if (d > 0.0)          \n        color = mix(color, vec3(1.0, 1.0, 0.8), pow(d, 20.0));\n    if (rd.y < FOGFADEHEIGHT)     \n        color = mix(FOGCOLOR, color, (rd.y-FOGHEIGHT)/(FOGFADEHEIGHT-FOGHEIGHT));\n    if (rd.y < FOGHEIGHT) \n        color = FOGCOLOR;\n    return clamp(color, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 st = fragCoord.xy / iResolution.xy;\n    float finv = tan(90.0 * 0.5 * PI / 180.0);\n    float aspect = iResolution.x / iResolution.y;\n    st.x = st.x * aspect;\n    st = (st - vec2(aspect * 0.5, 0.5)) * finv;\n\n    vec3 rd = normalize(vec3(st, 1.0));\n    rd = rotateY(-iMouse.x*0.002+0.785398) * rotateX(iMouse.y*0.002-0.19) * rd;\n    rd = normalize(rd);\n \n    vec3 ro = vec3(0.0, 14.5, 0.0); \n  \n    ro += iTime  * normalize(vec3(-1.0, 0.0, 1.0));\n\n    int mattype = 0;\n    vec2 height = trace(ro, rd, mattype);\n\n    vec3 rp = ro + height.y * rd;\n    vec3 n = getNormal(rp);\n    vec3 kd = getShading(rp, SUNDIRECTION, n);\n\n    // texture slope fade constants\n    // anything below smin slope uses grass texture, anything above uses rock texture,\n    // values between are lerped.\n    float smin = 0.05;  \n    float smax = 0.15;\n\n    // terrain detail texture\n    float vmin = 0.4;\n    float vmax = 1.0;\n\n    vec3 color1 = vec3(1.0, 0.0, 0.0);\n    vec3 color2 = vec3(1.0, 0.0, 0.0);\n    if (mattype == 1) {\n        color1 = vec3(0.925, 0.964, 0.572); //  grass color;\n        color2 = vec3(0.474, 0.368, 0.207); // rock \n    }\n    if (mattype == 2) {\n        color1 = vec3(0.611, 0.686, 0.113); //  tree base;\n        color2 = vec3(0.760, 0.913, 0.427); //   tree top;\n        color1 = color1 + vec3(noise2D(rp.xz * 9.0),  noise2D(rp.zx * 2.0), noise2D(rp.zx)) * 0.20;\n        color2 = color2 + vec3(noise2D(rp.xz * 5.0),  noise2D(rp.zx * 9.0), noise2D(rp.zx)) * 0.20;\n        smin = 0.09;\n        smax = 0.24;\n        vmin = 0.5;\n        vmax = 1.0;\n    }\n\n    float slopefactor =  1.0 - abs(dot(n, vec3(0.0, 1.0, 0.0)));\n    float slopefactor2 = clamp(slopefactor, smin, smax);\n    slopefactor2 = (slopefactor2-smin) / (smax - smin);\n    \n    vec3 color = mix(color1, color2, slopefactor2);\n    float variation = (noise2D(rp.xz *225.0) + noise2D(rp.zx * 225.0)) * 0.5 ;\n    variation = clamp(variation, vmin, vmax);\n    color *= variation;\n    float ao = bad_ao(n);\n    color = color * 0.3 * ao + color * kd;\n\n    const vec3 fogcolor = vec3(0.996, 0.878, 0.603);\n    color = mix(color, fogcolor, fog(height.y));\n\n    if (height.x == -1.0) { color = sky(ro, rd, st); }\n    color = postprocess(color);\n    fragColor = vec4(color, 1.0); \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsfBDB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsfBRs", "name": "Twindragon construction", "author": "al13n", "description": "Inspired by https://projecteuler.net/problem=508", "tags": ["procedural", "2d", "twindragon"], "likes": 12, "viewed": 454, "date": "1497513670", "time_retrieved": "2024-06-20T18:56:08.102633", "image_code": "#define PI 3.141592653589793\n\nfloat bits(vec2 p){\n    p = floor(p + .5);\n    float res = 0.;\n    for (int i = 0; i < 100; ++i) {\n        if(dot(p,p)<.5)\n            return res;\n        res += 1.;\n        p.x -= step(1., mod(p.x+p.y+.5, 2.));\n        p = mat2(-.5,-.5,.5,-.5)*p;\n    }\n    return -1.; // this shouldn't happen\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const vec4 bg_col = vec4(.3,.3,.7,1.);\n    const vec4 fg_col = vec4(.7,.7,.7,1.);\n    const vec4 mv_col = vec4(.2,.8,.2,1.);\n    const float step_t = 1.;\n    const float col_t = .2;\n    const float wait_t = .1;\n    const float num_steps = 20.;\n\n    float period = num_steps*step_t*4.;\n    float t = mod(iTime, period);\n    float mode = float(t>period/2.);\n    t = mod(t,period/2.);\n    t=min(t,period/2.-t);\n    float b = floor(t/step_t);\n    float bt = fract(t/step_t);\n    float logscale = b+(b>num_steps-1.5 ? (1.-pow(1.-bt,2.))*.5 : b<.5 ? bt*bt*.5+.5 : bt);\n    float scale = pow(2.,logscale/2.)*3.;\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5 + vec2(.12,.17)) / iResolution.y * scale;\n\n    float fg, mv;\n    \n    if (mode < .5) {\n    \tvec2 offset = vec2(cos(PI*.75*b),sin(PI*.75*b))*pow(2.,b*.5);\n    \tfg = float(bits(uv)<b+.5);\n    \tmv = float(bits(mix(uv,uv-offset,smoothstep(col_t+wait_t,1.-col_t-wait_t,bt)))<b+.5);\n    } else {\n        // This block of code is bad, but I should go to sleep now.\n        float tt=smoothstep(.1,.4,bt);\n        mat2 ip = mat2(cos(PI*.75*tt),-sin(PI*.75*tt),sin(PI*.75*tt),cos(PI*.75*tt))*pow(2.,-tt*.5);\n        vec2 uvc = mat2(.5,.5,.5,-.5)*uv;\n        uvc = floor(uvc+.5);\n        uvc = mat2(1.,1.,1.,-1.)*uvc;\n        vec2 wi = ip*uvc;\n        float tt2=1.-smoothstep(.4,.7,bt);\n        if(b>10.)\n            tt2=1.; // terrible aliasing otherwise\n        mat2 ip2 = mat2(cos(PI*.25*tt2),-sin(PI*.25*tt2),sin(PI*.25*tt2),cos(PI*.25*tt2))*pow(2.,-tt2*.5);\n        vec2 wr=(tt2==1.?ip:ip2*ip)*(uv-uvc);\n        fg = float((tt2==1. || all(lessThanEqual(abs(mat2(1.,1.,1.,-1.)*wr),vec2(.5)))) && bits(wi+wr)<b+.5);\n        float mvt = smoothstep(.7,.9,bt);\n        float xr=uv.x+mod(floor(uv.y+.5)+.5,2.)-.5;\n        xr=mod(xr,2.);\n        mv = float(xr>.5 && xr<=.5+mvt && bits(uv)<b+1.5);\n    }\n\n    fragColor =\n        mix(mix(mix(bg_col,fg_col,fg),\n                mv_col,\n                mv*.7*smoothstep(wait_t,col_t+wait_t,bt)),\n            fg_col,\n            smoothstep(1.-col_t-wait_t,1.-wait_t,bt*mv));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsfBRs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsffDf", "name": "Simple Screensaver", "author": "alexpolt", "description": "A very simple shader.", "tags": ["screensaver"], "likes": 2, "viewed": 501, "date": "1498496987", "time_retrieved": "2024-06-20T18:56:08.102633", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  uv.y = uv.y * ( iResolution.x / iResolution.y );\n  float tt = 1024.*fract( iTime / 16384. );\n  vec4 c = vec4(  cos( ( uv.x*uv.y + uv.y + 5.*tt ) * 3.), \n                  cos( ( 3.*uv.y*uv.x + 7.*tt ) * 2.0 ), \n                  cos( sin(tt)*(1.-uv.x-uv.y)*3. ), 1 );\n  fragColor = c*vec4( .5, .5, .5, 1 ) + vec4( .5, .5, .5, 0 );\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsffDf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsffDS", "name": "Playing with IQs code", "author": "pthextract", "description": "Testing iq's code.\n\nOriginal code:\n[url]https://www.shadertoy.com/view/Xds3zN[/url]\n\nI did create a simple ripple in the plane when touching down, but there is a problem with normals I think because distfield is not correct when plane is distorted. :) \n\n\n", "tags": ["raymarching", "sphere", "iq", "checker", "code", "pattern", "capsule"], "likes": 2, "viewed": 207, "date": "1497813371", "time_retrieved": "2024-06-20T18:56:09.793592", "image_code": "// The MIT License\n// Copyright  2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n    \n\n// A list of useful distance function to simple primitives, and an example on how to \n// do some interesting boolean operations, repetition and displacement.\n//\n// More info here: http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n// Modified by pthextract in 2017-Jun-18\n\n\n#define AA 1   // make this 1 is your machine is too slow\n\n//------------------------------------------------------------------\n\n\n\n\nfloat sdCapP( vec3 p, vec3 a, vec3 b, float la,float lb)\n{\n    float l=length(a-b);\n    float l1=clamp(dot(a-p,a-b)/l/l,0.,1.);\n    float ll=length((p-=a)-(b-=a)*clamp(dot(p,b)/dot(b,b), 0.0, 1.0 ));\n    //float l2=dot(b-p,b-a)/length(b-a)/length(b-a);\n    return (-lb*l1--+la*l1)+ll;\n}\n\n\n\nfloat sdPlane( vec3 p )//with some topografi\n{\n    \n\treturn p.y-.1*sin(length(p))-.1/length(p)+.1*sin(p.x)-.3;\n}\n\nfloat sdPlaneVec(vec3 p, vec3 a,vec3 b,float len)\n{\n    return dot(p,b-a)/length(b-a)-len;\n  \n}\n\n\nfloat sdTruePlane( vec3 p )\n{\n\treturn p.y-.5/length(1./p);\n}\n\n\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    p=p.xzy;\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max((q.x*0.866025+q.y*0.5),q.y)-h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\n\n\n\n\n//------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn ((d1.x<d2.x) ? d1 : d2);\n    \n}\n\n\n\n\n\n//------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    \n   //for (float x=0.;x<2;x??)\n    vec3 upndown=vec3(-.5*mod(iDate.w*3.,22.),2.*pow(sin(iDate.w*3.)+1.,.33)-1.,0); \n        vec3 groin=vec3( -.0,1.5, 0)+upndown;\n    vec3 lknee=groin+vec3( .4,-.3,-.2);\n    vec3 rknee=groin+vec3( 0,-.4,.2);\n    vec3 leg=vec3(-0.1,-.4,0);\n     vec3 chest=groin+vec3(0,.4,0);\n    vec3 shjoint=vec3(0,.2,0);\n    vec3 arm=vec3(0,0,.3);\n    vec3 rarm=vec3(0.2,-0.2,.6);\n    vec3 larm=vec3(0,-0.2,-.6);\n      vec3 head=vec3(0,-.45,0);\n     vec3 forearm=vec3(.4,-.2,0);\n    vec3 toe=vec3(.4,0,0)/2.;\n    float color=44. ;\n    vec3 hand=vec3(0.1,0,0);\n    vec3 thumb=vec3(0.04,.14,0);\n    vec3 hip=vec3(0,0,.6)/4.;\n    vec3 under=vec3(0.,sdTruePlane(rknee+leg),0.);\n    float underover=clamp(under.y,-.05,.05);\n    under.y=clamp(under.y,-100.,.05);\n    float cdist=6.*distance(pos,rknee+leg);\n    vec3 under2=vec3(0.,sdTruePlane(lknee+leg),0.);\n    under2.y=clamp(under.y,-100.,.05);\n    float cdist2=9.*distance(pos,lknee+leg);\n    \nvec2 \n    \n    //res = opU( , vec2( sdCapP(    pos, groin+vec3( 0,-.4,.4),groin,.1,.3 ), (1.+sin(iTime))*20. ) );\n    //res = opU( vec2( sdPlane(     pos+vec3(0,.5,0)), .0 ), sdPlane(     pos+vec3(0,.5,0)), .0 ) );\n    \n     // res = opU( vec2( sdPlane(     pos+vec3(0,.5,0)), .0 ), sdPlane(     pos+vec3(0,.5,0)), color) );\n     \n     res = opU( vec2(sdTruePlane(     pos+vec3(0,0,0)-.9*under/cdist-.9*under2/cdist2), .0 ), vec2( sdCapP(    pos,lknee,groin-hip,.1,.2 ), color) );\n  \n     //res = opU( vec2(sdPlane(     pos+vec3(0,0,0)), .0 ), vec2( sdCapP(    pos,lknee,groin,.1,.3 ), color) );\n  \n    res = opU( res, vec2( sdCapP(    pos, rknee,groin+hip,.1,.2 ), color ));\n     res = opU( res, vec2( sdCapP(    pos,lknee,lknee+leg,.1,.1 ), color ));\n    res = opU( res, vec2( sdCapP(    pos, rknee,rknee+leg,.1,.1 ), color ));\n      res = opU( res, vec2( sdCapP(    pos,lknee+leg+toe,lknee+leg,.1,.1 ), color ));\n    res = opU( res, vec2( sdCapP(    pos, rknee+leg+toe,rknee+leg,.1,.1 ), color ));\n    \n    res = opU( res, vec2( sdCapP(    pos,chest,groin,.35,.25 ), color+10.));\n       res = opU( res, vec2( sdCapP(    pos,chest+shjoint+arm,chest+rarm,.2,.1 ), color ));\n        res = opU( res, vec2( sdCapP(    pos,chest+shjoint-arm,chest+larm,.2,.1 ), color ));\n    res = opU( res, vec2( sdCapP(    pos,chest,chest-head,.1,.25 ), color+25. ));\n    under.y=underover/8.;\n    under.y=under.y/abs(under.y)*pow(abs(under.y),.5);\n        res = opU( res, vec2( sdCapP(    pos,chest+rarm+forearm+under,chest+rarm,.09,.1 ), color ));\n        res = opU( res, vec2( sdCapP(    pos,chest+larm+forearm+under,chest+larm,.09,.1 ), color ));\n     res = opU( res, vec2( sdCapP(    pos,chest+rarm+forearm+under,chest+rarm+forearm+hand+under,.09,.08 ), color ));\n        res = opU( res, vec2( sdCapP(    pos,chest+larm+forearm+under,chest+larm+forearm+hand+under,.09,.08 ), color ));\n  res = opU( res, vec2( sdCapP(    pos,chest+rarm+forearm+under,chest+rarm+forearm+thumb+under,.06,.05 ), color ));\n        res = opU( res, vec2( sdCapP(    pos,chest+larm+forearm+under,chest+larm+forearm+thumb+under,.06,.05 ), color ));\n    float hexc=acos(0.)/3.;\n    for (float x=0.;x++<12.;)\n    {res = opU( res,-.1+ vec2( sdHexPrism(  pos-2.5*vec3(sin(iDate.w+hexc*x),sin(iDate.w*x+x)/19., cos(iDate.w+hexc*x)), vec2(.5,.5) ),10.0*x ) );\n    }\n  vec3 nupos=clamp(pos,1.+.1*sin(3.*(pos.x+pos.z)),9.);\nres = opU( res,vec2(7.-length(nupos)-.5*sin(pos.y),iDate.w*10.+10.*pos.x+10.*pos.z+2.*pos.y));\n\n    \n   \n    \n    return res;\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 30.0;\n   \n#if 0\n    // bounding volume\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<64; i++ )\n    {\n\t    float precis = 0.0005*t;\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n    /*\n\tvec3 eps = vec3( 0.0005, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n\t*/\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        if( m<1.5 )\n        {\n            \n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n            col = 0.3 + 0.1*f*vec3(1.0);\n        }\n\n        // lighitng        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.4, 0.7, -0.6) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( pos, lig, 0.02, 5.5 );\n        dom *= softshadow( pos, ref, 0.02, 5.5 );\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.30*dif*vec3(1.00,0.80,0.55);\n\t\tlin += 2.00*spe*vec3(1.00,0.90,0.70)*dif;\n        lin += 0.40*amb*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime;\n\n    \n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n\t\t// camera\t\n        vec3 ro = vec3( -0.5+4.*cos(0.3*time + 6.0*mo.x), 20. + 5.0*mo.y, 0.5 + 3.0*sin(0.3*time + 6.0*mo.x) );\n \t\tro.y-=0.9*    sdPlane(ro);//drop 90% towards ground\n        \n          vec3 ta = vec3( -0., 1.0, 0. );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta, 0.0 );\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        // render\t\n        vec3 col = render( ro, rd );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n    fragColor=fragColor*.7+.3*fragColor*fragColor;\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "ldfXR2", "previewfilepath": "https://soundcloud.com/espenvh/heightened-senses", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/espenvh/heightened-senses", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/lsffDS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsffRl", "name": "Galaxy Cluster (140 chars)", "author": "DJDoomz", "description": "Was making a tiny starfield, stumbled across this neat effect...\n\nTo see the regular starfield effect, change the c+= to c.xyz+=", "tags": ["tiny", "awfulcode"], "likes": 2, "viewed": 189, "date": "1497470476", "time_retrieved": "2024-06-20T18:56:09.793592", "image_code": "// 139 now... replaced distance(u,vec2()) with length(u-vec2())\n// thanks to GregRostami for his help\n#define s sin(c.w*35.)*\nvoid mainImage(out vec4 c,vec2 u)\n{\n\tfor(c-=c;c.w++<20.;c+=2./length(u-vec2(mod(s 8e2+s iTime*9.,1e3),s 4e2)));\n}\n\n// Glass?\n//void/**/mainImage(out/**/vec4/**/c,vec2/**/u)\n//{for(;c.w++<80.;c+=2./distance(u,vec2(mod(sin(c.w*31.)*800.+sin(c.w)*iTime*15.,999.),sin(c.w*34.)*400.)));}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsffRl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsffRs", "name": "Ocean & Rocks", "author": "lz", "description": "Day and Night at the Ocean with sunset, rocks and a lonely seagull\nMouse clicks:\nY - axis: earth rotation speed (light rotation). \nX - axis: sky color. 0 - blue/ yellow sunset. 1 - aqua/ red sunset. \n", "tags": ["procedural", "reflection", "terrain", "refraction", "scattering", "rayleigh", "mie"], "likes": 14, "viewed": 544, "date": "1497522582", "time_retrieved": "2024-06-20T18:56:12.836187", "image_code": "/*\n\tNOTES and ACKNOWLEDGMENTS:\n\tProcedural terrain with waterlike surface, rocks and a low quality seagull.\n\n\tThe rocks were influenced by:\n    'Nightfall' by vgs https://www.shadertoy.com/view/MlfXWH\n\tThe color of the rocks was taken (with slight modification) from \n\t'Tiny Planet' by valentingalea https://www.shadertoy.com/view/ldyXRw\n\n\tImplementations that I took directly from Inigo's articles:\n\t\n\tAltitude based fog (took the funciton as is).\n\thttp://iquilezles.org/www/articles/fog/fog.htm\n\t\n\tImplemented penumbras as explained here:\n\thttp://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\n\n\tUsed signed distance modeling with functions:\n\thttp://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n\tI guess that the hash functions are also originated from Inigo's work.\n\n\tAlso thanks to VGS for explanation on smooth min and one line rotations:\n\thttp://homepages.dcc.ufmg.br/~vgs/blog/simple-code-rotation/\n\t\n\tReflection and refraction were taken from scratchpixel.\n\tThe refracted objects look dimmer with deps dependent on distance measured. Used\n\texponential attenuation.\n\n\tThe scattering was taken from scratchpixel as well, however with some changes:\n\tChanged some of the defaults: (BetaR, atmosphere height to be 100km - same as earth, \n\tBy default the step is exponential and not uniform. This creates smoother transitions and a\n\tbetter sunset effect, however it introduces more error at the higher altitudes due to lack\n\tof samples there. So for the upper half, there is only one sample which is taken at the point\n\t.75 of the atmosphere. It is possible to improve it by picking the point with an average density\n\tfor each range (and for .5 - 1. of the atmosphere specifically). Clearly this point should \n\tbe closer to the lower bound of the range.\n\t\n\tcommenting EXPSTEP will use uniform step.\n\tprecomputed values for BetaR:\n\tuse RED_SUNSET for aqua like sky color and red sunset.\n \tuse YELLOW_SUNSET for blue sky and yellow sunset.\n\n\tTODO:\n\tUse analytic raytracing for the sea surface.\n\tBetter camera movements.\n\tMaybe clouds.\n*/\n#define PI 3.14159265359\n\n#define HGN 9999.9\n#define FAR 400.\n#define EPS (2.0/iResolution.x)\n#define WATER_VIS_COEFF .7\n#define PEAK 14.\n#define EXP1 2.718282\n\n#define IGT iTime\n#define EARTH_ROT_TIME IGT/13.\n\n#define CAMERA_MOVE -5.*IGT\n\n#define EARTH_RADIUS 6370e3\n#define ORBIT_RADIUS 6470e3\n\n#define VIEW_RAY_SAMPLES 12\n#define SUN_RAY_SAMPLES 6\n\n#define EXPSTEP\n#define EXP16 -0.692885385572419\n#define EXP8 -0.69102321753708\n\n#define HR 7994. // Rayleigh Height\n#define HM 1200. // Mie Height\n\n#define YELLOW_SUNSET vec3(5.8e-6, 10.5e-6, 9.1e-5)\n#define RED_SUNSET vec3(5.8e-6, 80.5e-6, 9.1e-5)\n\nvec3 BetaR = vec3(5.8e-6, 10.5e-6, 9.1e-5);\nconst vec3 BetaM = vec3(21e-6);\n\nvec2 solveQuadratic(in float a, in float b, in float c) { // the second value is 0 if no solution exists and 1 if found solution.\n    float discr = b*b - 4.*a*c;\n    vec2 res = vec2(0.0, 0.0);\n    float eps = 0.001;\n\n    if (discr > 0.0) {\n        float sq_discr = sqrt(discr);\n        float q = -.5*(b+sign(b)*sq_discr);\n        float t1 = q/a;\n        float t2 = c/q;\n\n        // the solution is the minimal positive t.\n\n        res.x = t1 * t2 > 0. ? min(t1, t2) : max(t1, t2);\n        res.y = step(eps, max(t1, t2));\n    }\n\n    return res;\n}\n\nstruct Ray {\n    vec3 o;\n    vec3 d;\n};\n\nstruct ODist {\n    float t;\n    int idx;\n    float eps;\n    float pmb;\n};\n\nfloat raySphereIntersect(in Ray ray, in vec4 sphere) { // vec4(ox, oy, oz, radius);\n    vec3 o = ray.o - sphere.xyz;\n    vec3 d = ray.d;\n    float t = -1.0;\n\n    float a = dot(d, d);\n    float b = 2.*dot(o, d);\n    float c = dot(o, o) - sphere.w*sphere.w;\n\n    vec2 res = solveQuadratic(a, b, c);\n\n    if (res.y > 0.5) {\n        t = res.x;\n    }\n\n    return t;\n}\n\nfloat earthOrbitDist(in Ray ray) {\n    return raySphereIntersect(ray, vec4(0., 0., 0., ORBIT_RADIUS));\n}\n\n#define MAX_RAY_MARCH 300\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat random(vec3 t) {\n    return fract(sin(dot(t.xyz,\n                         vec3(12.9898,78.233, 2.23435)))*\n        43758.5453123);\n}\n\nvec2 rot2d(in vec2 u, in float a) {\n    return u.xy*cos(a) + vec2(-u.y, u.x)*sin(a);\n}\n\nfloat value_noise(in vec3 p) {\n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n\n    float q = random(ip);\n    float w = random(ip + vec3(1.,0.,0.));\n    float e = random(ip + vec3(0.,1.,0.));\n    float r = random(ip + vec3(1.,1.,0.));\n    \n    float a = random(ip + vec3(0.,0.,1.));\n    float s = random(ip + vec3(1.,0.,1.));\n    float d = random(ip + vec3(0.,1.,1.));\n    float f = random(ip + vec3(1.,1.,1.));\n\n    vec3 u = 3.*fp*fp - 2.*fp*fp*fp;\n    \n    float v1 = mix(mix(q,w,u.x),\n                    mix(e,r,u.x), u.y);\n    float v2 = mix(mix(a,s,u.x), \n                    mix(d,f,u.x), u.y);\n    float v = mix(v1, v2, u.z);\n    return v;\n}\n\nvec3 value_noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f*f*f*(f*(f*6.0 - 15.0) + 10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0); //iq\n\n    float k0 = a;\n    float k1 = b - a;\n    float k2 = c - a;\n    float k3 = a - b - c + d;\n\n    vec3 nres;\n    \n    nres.x = mix(mix(a, b, u.x), mix(c, d, u.x), u.y);\n    nres.yz = vec2(k1+k3*u.y, k2+k3*u.x)*du;\n\n    return nres;\n}\n\n#define OCTAVES 10\n\nfloat waterFbm(in vec3 p, in int octaves)  {\n    float f = 0., af = 0.;\n    /*float f = .5*value_noise(p);\n    f += .25*value_noise(2.*p);\n    f += .125*value_noise(4.*p);\n    f += .0625*value_noise(8.*p);\n    return f;*/\n\n    for (int i = 0; i < 4; i++) {\n        if (i >= octaves) break;\n        af = pow(2., float(i));\n        f += (.5/af)*value_noise(af*p);\n    }\n\n    return f;\n}\n\nvec3 fbm(in vec2 grid, in int octaves) {\n    // Initial values\n    float v = 0.0, a = PEAK, f = 2.101;\n    mat2 m = mat2(0.6, -.8, .8, .6);\n    mat2 cm = mat2(1., 0., 0., 1.);\n    vec2 d = vec2(0., 0.);\n    // Loop of octaves\n    a *= sqrt(abs(value_noise(grid*.3).x));\n\n    for (int i = 0; i < OCTAVES; i++) {\n        if (i >= octaves) break;\n        vec3 ns = value_noise(grid);\n        v += (a * ns.x)/(.78+dot(ns.yz, ns.yz));\n        d += (a * cm * ns.yz);\n        grid = m*grid*f;\n        cm = m*cm;\n        a *= .49;\n    }\n    return vec3(v, d);\n}\n\n#define NUM_GEOMS 3\n\n#define c_beach vec3(.153, .172, .121)\n#define c_rock  vec3(.080, .050, .030)\n#define c_snow  vec3(0.805671, 0.805671, 0.805671)\n\nvec3 origin;\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat getMGeomL(in vec3 p) {\n    return p.y - fbm(p.xz*.05, 2).x;\n}\n\nfloat getMGeom(in vec3 p) {\n    return p.y - fbm(p.xz*.05, 4).x;\n}\n\nfloat getMGeomH(in vec3 p) {\n    float d = length(p - origin);\n    //int octaves = 7+int(log2(1.-d/FAR));\n    int octaves = int(14.*(1. - .5*d/FAR)+1.);\n    return p.y - fbm(p.xz*.05, octaves).x;\n}\n\nvec4 getMMtl(in vec3 p, in vec3 N) {\n    vec3 col;\n    float s = smoothstep(15., 19., p.y);\n    col = mix(c_rock, c_snow, s*sqrt(abs(N.y)));\n    s = smoothstep(12., 13., p.y);\n    col += mix(c_beach, c_rock, s);\n    \n    return vec4(col, 10.);\n}\n\nstruct Wave {\n    float a;\n    float L;\n    float v;\n    vec2  dir;\n    float k;\n};\n\nfloat wave(in vec2 st, in Wave w) {\n    float res;\n\n    float ampl = w.a;\n    float L = w.L;\n    float freq = 2./L;\n    vec2  dir = normalize(w.dir);\n    float speed = w.v;\n    float phi = speed * 2./L;\n\n    res = 2.*ampl * pow(.5*(1.+sin(dot(dir,st)*freq + phi)), w.k);\n    return res;\n}\n\nvec3 gwave(in vec2 st, in Wave w) {\n    vec3 res;\n\n    float ampl = w.a;\n    float L = w.L;\n    float freq = 2./L;\n    vec2  dir = normalize(w.dir);\n    float speed = w.v;\n    float phi = speed * 2./L;\n    float q = 1./(freq*ampl);\n\n    res.x = q*ampl + dir.x*cos(dot(dir, st)*freq + phi);\n    res.y = q*ampl + dir.y*cos(dot(dir, st)*freq + phi);\n    res.z = ampl * sin(dot(dir,st)*freq + phi);\n    return res;\n}\n    \nfloat getWGeom(in vec3 p) {\n    Wave waves[3];\n    waves[0] = Wave(1.2, 15., 3.5 + IGT*4., vec2(1., 1.), .7);\n    waves[1] = Wave(1.1, 12.6, 2.5 + IGT, vec2(-1., -2.), .9);\n    waves[2] = Wave(.4, 4., 2. + IGT*2., vec2(1., -.6), .9);\n    waves[2] = Wave(.4, 4.2, 1. + IGT*2., vec2(-1., -.6), .9);\n    \n    /*for (int i = 0; i < 3; i++) {\n        p.y += wave(p.xz, waves[i]);\n    }*/\n    for (int i = 0; i < 3; i++) {\n        vec3 q = gwave(p.xz, waves[i]);\n        p.xzy = p.xzy + q.xyz;\n    }\n    \n    return p.y -12. -waterFbm(vec3(p.xz*.1, IGT/4.), 4);\n}\n\nfloat getWGeomH(in vec3 p) {\n    return getWGeom(p);\n    \n    float d = length(p - origin);\n    //int octaves = 4+int(log2(1.-d/FAR));\n    int octaves = int(4.*(1. - .8*d/FAR)+1.);\n    return p.y -12. -waterFbm(vec3(p.xz*.1, IGT/4.), octaves);\n}\n\nvec3 wingTrf(in vec3 p) {\n    vec3 q = vec3(p.xy, p.z-2.6 + 2.*pow(abs(cos(p.y/4.)), 4.));\n    q.z += cos(IGT*8. + PI/2.)*.04*q.y*q.y;\n    return q;\n}\n\nfloat birdWings(in vec3 p) {\n    vec3 q = wingTrf(p);\n\n    q.y *= .3;\n    q.x += .6*cos(2.5*q.y);\n    \n    float f1 = max(length(q.xy) - 3.5, abs(q.z) - .01);\n\n    vec3 q2 = wingTrf(p);\n    q2.y *= .75;\n    float cq2y = cos(q2.y);\n    q2.x += cq2y*cq2y*cq2y*.343;\n    float f2 = max(length(q2.xy - vec2(-12., 0.)) - 12.5, abs(q2.z) - .01);\n\n    float f = max(f1, f2);\n\n    return f;\n}\n\nfloat birdBody(in vec3 p) {\n    vec3 q = p;\n\n    float l = length(q.yz);\n    float f = max(l - (1.-.08*q.x*q.x - .3*q.x) -.3, abs(q.x) - 7.);\n    return f;\n}\n\n#define BR -180.\n\nfloat getSBird(in vec3 p) {\n    p -= vec3(-BR*sin(.5*IGT) + origin.x, 21., BR*cos(.5*IGT) + origin.z);\n    p.yz = rot2d(p.yz, PI/3.);\n    return smin(birdBody(p), birdWings(p), .2);\n}\n\nvec4 seagullCol(in vec3 p) {\n\n    p -= vec3(-BR*sin(.5*IGT) + origin.x, 21., BR*cos(.5*IGT) + origin.z);\n    p.yz = rot2d(p.yz, PI/3.);\n    vec3 col;\n    float wgs = birdWings(p);\n    float bdy = birdBody(p);\n\n    col = smoothstep(0., .3, .3-abs(wgs))*mix(vec3(1.,1.,1.), vec3(0.1, 0.1, 0.1), step(7.5, abs(p.y)));\n    col += smoothstep(0., .3, .3-abs(bdy))*vec3(1., 1., 1.);\n\n    return vec4(col, 6.2);\n}\n\nODist intersect(in vec3 p, in int excl_idx) {\n    ODist gi[NUM_GEOMS];\n    gi[0] = ODist(-1., 1, getMGeom(p), 1.);\n    gi[1] = ODist(-1., 2, getWGeom(p), 1.);\n    gi[2] = ODist(-1., 3, getSBird(p), 1.);\n\n    ODist g = ODist(HGN, 0, HGN, 1.);\n\n    for (int i = 0; i < NUM_GEOMS; i++) {\n        if (gi[i].eps < g.eps && excl_idx != gi[i].idx) {\n            g = gi[i];\n        }\n    }\n\n    return g;\n}\n\nvec3 calcNormal(in vec3 p, int geomId, in float t) {\n    vec3 e = vec3(0.001, 0.0, 0.0)*t;\n    vec3 n;\n\t\n    if (geomId == 1) {\n        //vec2 n1 = fbm(p.xz*.05, 4).yz;\n        //n = normalize(vec3(n1.x, 0.001*2., n1.y));\n\t\t\n        n.x = getMGeomH(p+e.xyy) - getMGeomH(p-e.xyy);\n        n.y = 2.*e.x;\n        n.z = getMGeomH(p+e.yyx) - getMGeomH(p-e.yyx);\n    } else if (geomId == 2) {\n        //n = vec3(0., 1., 0.);\n\n        n.x = getWGeomH(p+e.xyy) - getWGeomH(p-e.xyy);\n        n.y = 2.*e.x;\n        n.z = getWGeomH(p+e.yyx) - getWGeomH(p-e.yyx);\n\n    } else if (geomId == 3) {\n        n.x = getSBird(p+e.xyy) - getSBird(p-e.xyy);\n        n.y = getSBird(p+e.yxy) - getSBird(p-e.yxy);\n        n.z = getSBird(p+e.yyx) - getSBird(p-e.yyx);\n    }\n\n    return normalize(n);\n}\n\nODist trace(in Ray ray, in int excl_idx) {\n    ODist res = ODist(-1.0, 0, HGN, 1.);\n    res.t = -1.;\n    res.idx = 0;\n    float pmb = 10.;\n    float t = 0.0;\n    float up = step(0.01, ray.d.y);\n\n    for (int it = 0; it < MAX_RAY_MARCH; it++) {\n        vec3 p = ray.o + t*ray.d;\n        if (up*step(2.*PEAK, p.y) > .5) {\n            break;\n        }\n        res = intersect(ray.o + t*ray.d, excl_idx);\n        if (res.eps < 0.001*t) {\n            res.t = t;\n            res.pmb = 0.;\n            return res;\n        } \n\n        pmb = min(pmb, 10.*res.eps/(t + 0.001));\n        //t += (.25+exp(5.*t/FAR-5.))*res.eps;\n        t += .25*res.eps;\n\n        if (t > FAR) {\n            break;\n        }\n    }\n\n    return ODist(t, 0, res.eps, pmb);\n}\n\n#define NUM_LIGHTS 1\n#define DIR_LIGHT 1\n#define SPH_LIGHT 2\n\nstruct Light {\n    int type;\n    vec4 col;\n    vec3 pos;\n    vec3 dir;\n};\n\nfloat fresnell(in vec3 I, in vec3 N, in float ior) {\n    float sint1 = length(cross(I, N));\n    float sint2 = sint1*ior;\n\n    if (sint2 > 1.) {\n        return 1.;\n    }\n\n    float cost1 = cos(asin(sint1));\n    float cost2 = cos(asin(sint2));\n\n    float fpar = (ior*cost1 - cost2)/(ior*cost1 + cost2);\n    float fperp = (cost2 - ior*cost1)/(cost2 + ior*cost1);\n\n    float fresnell = (fpar*fpar + fperp*fperp)*.5;\n    return fresnell;\n}\n\nvec3 scattering(in Ray ray, in vec3 sun_dir) {\n    float to = earthOrbitDist(ray);\n    vec3 col = vec3(.5);\n    float ds = to/float(VIEW_RAY_SAMPLES);\n    float mu = dot(ray.d, sun_dir);\n    float phaseR = 3./(16.*PI)*(1.+mu*mu);\n    float g = 0.80;\n    float denom = 1. + g * g - 2. * g * mu;\n    float phaseM = 3. / (8. * PI) * ((1. - g * g) * (1. + mu * mu)) / ((2. + g * g) * denom*denom/sqrt(denom)); \n    float opR = 0.0;\n    float opM = 0.0;\n    vec3 sumR = vec3(0.0);\n    vec3 sumM = vec3(0.0);\n\n    for (int i = 0; i < VIEW_RAY_SAMPLES; i++) {\n        #ifdef EXPSTEP\n        ds = exp(EXP16*float(VIEW_RAY_SAMPLES - i))*to;\n        #endif\n        vec3 x = ray.o + (ds*float(i) + ds*.5)*ray.d;\n        float height = length(x)-EARTH_RADIUS;\n        float hr = exp(-height/HR)*ds;\n        float hm = exp(-height/HM)*ds;\n        float opSunR = 0.0;\n        float opSunM = 0.0;\n        vec3 attenuation = vec3(0.0);\n        opR += hr;\n        opM += hm;\n\n        Ray sun_ray = Ray(x, sun_dir);\n        float tsun = earthOrbitDist(sun_ray);\n        float dst = tsun/float(SUN_RAY_SAMPLES);\n\n        for (int j = 0; j < SUN_RAY_SAMPLES; j++) {\n            #ifdef EXPSTEP\n            dst = exp(EXP8*float(SUN_RAY_SAMPLES - i))*tsun;\n            #endif\n            vec3 xt = sun_ray.o + (dst*float(j)+dst*.5)*sun_ray.d;\n            float htt = length(xt) - EARTH_RADIUS;\n            opSunR += exp(-htt/HR)*dst;\n            opSunM += exp(-htt/HM)*dst;\n        }\n\n        attenuation = exp(-BetaR*(opR + opSunR) -BetaM*(opM + opSunM)*1.1);\n        sumR += attenuation*hr;\n        sumM += attenuation*hm;\n    }\n\n    col = (sumR*phaseR*BetaR*(1.+max(sun_dir.y, 0.)) + sumM*phaseM*BetaM)*15.;\n    return col;\n}\n\nvec3 render(in Ray ray, in ODist tgeom, in Light l, bool shadow) {\n    vec3 col = vec3(0., 0., 0.);\n    vec3 p = ray.o + tgeom.t*ray.d;\n    vec3 n = calcNormal(p, tgeom.idx, tgeom.t);\n\n    vec3 ldir = l.dir;\n    //vec3 ldir = normalize(l.pos - p); // spherical light\n    vec3 vreflect; // = ldir - 2.*dot(n, ldir)*n;\n    vreflect = reflect(ldir, n);\n\n    if (tgeom.idx == 1) {\n        vec4 mtl = getMMtl(p, n);\n        vec3 diff = mtl.xyz*l.col.xyz/(PI)*max(0.0, dot(n, ldir.xyz))*l.col.w;\n        vec3 spec = l.col.xyz*pow(max(0.0, dot(vreflect, ray.d)), mtl.w)*l.col.w/mtl.w;\n        col = diff + .1*spec;\n    }  else if (tgeom.idx == 3) {\n        vec4 mtl = seagullCol(p);\n        vec3 diff = mtl.xyz*l.col.xyz/(PI)*max(0.0, dot(n, ldir.xyz))*l.col.w;\n        col = diff*(.2 + step(0., ldir.y));\n    }  else {\n       Ray sray = Ray(ray.o + vec3(0., EARTH_RADIUS, 0.), ray.d);\n       col = scattering(sray, ldir);\n    } \n\n    if (tgeom.idx != 0 && shadow) {\n        vec3 vpos = p+normalize(ldir)*.1;\n        Ray shRay = Ray(p, ldir);\n        float pmb = float(trace(shRay, -1).pmb); \n        col *= min(1., .5+pmb);\n    }\n\n    return col;\n}\n\nvec3 reflection(in vec3 I, in vec3 N, in vec3 p, in Light l, in int gindex) {\n    vec3 vreflect = reflect(I, N);\n    Ray reflRay = Ray(p, vreflect);\n    ODist tgeom2 = trace(reflRay, gindex);\n    return render(reflRay, tgeom2, l, false);\n}\n\nvec4 refraction(in vec3 I, in vec3 N, in vec3 p, in Light l, in float ior, in int gindex) {\n    vec3 vrefract = refract(I, N, ior);\n    Ray refrRay = Ray(p, vrefract);\n    ODist tgeom = trace(refrRay, gindex);\n    return vec4(render(refrRay, tgeom, l, false), tgeom.t);\n}\n\nvec3 applyFog(in vec3 rgb, in float distance, in Ray ray) {\n    float b = .3 + .03*sin(IGT/4.234);\n    float c = 1.;\n    float fogAmount = c * exp(-ray.o.y*b) * (1.0-exp( -distance*ray.d.y*b ))/ray.d.y;\n    vec3  fogColor  = vec3(0.5,0.6,0.9);\n    return mix( rgb, fogColor, fogAmount );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st = fragCoord.xy / iResolution.xy;\n    st.x = 1. - st.x;\n    //st.x *= iResolution.x/iResolution.y;\n    vec3 col = vec3(0.0);\n    Ray ray;\n    ray.o = vec3(0, 30. + 2.*sin(IGT/4.), 2. CAMERA_MOVE);\n    origin = ray.o;\n\n    ray.d = normalize(vec3(-1. + 2.*st.xy, -1.));\n\n   // First iteration\n    ODist tgeom = trace(ray, 0);\n    vec3 ldir = normalize(vec3(-2., 3., -5.));\n    float rot_cf = 1.;\n    if (iMouse.y > 0.) {\n        rot_cf = pow(abs(2.*iMouse.y/iResolution.y), 4.);\n    } if (iMouse.x >0.) {\n        BetaR = mix(YELLOW_SUNSET, RED_SUNSET, iMouse.x/iResolution.x); \n    }\n    ldir.yz = rot2d(ldir.yz, -EARTH_ROT_TIME*rot_cf);\n    Light l = Light(2, vec4(1., 1., 1., 4.4), vec3(0., 10., -10.), ldir);\n    if (tgeom.idx != 2) {\n        col = render(ray, tgeom, l, true);\n    } else if (tgeom.idx == 2) {\n        float ior = 1./1.3;\n        vec3 p = ray.o + ray.d*tgeom.t;\n        vec3 n = calcNormal(p, tgeom.idx, tgeom.t);\n        vec3 vreflect = reflect(ray.d, n);\n        float frs = fresnell(ray.d, n, ior);\n        vec3 col1 = reflection(ray.d, n, p, l, tgeom.idx);\n        vec4 refr = refraction(ray.d, n, p, l, ior, tgeom.idx);\n        // darken refraction based on ray length.\n        col = .85*(frs*col1 + .3*(1.-frs)*refr.xyz*exp(-refr.w*WATER_VIS_COEFF));\n    }\n\n    col = applyFog(col, tgeom.t, ray);\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsffRs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsffW7", "name": "Kryptonite Tunnel", "author": "aiekick", "description": "Kryptonite Tunnel", "tags": ["tunnel", "kryptonite"], "likes": 15, "viewed": 554, "date": "1496402324", "time_retrieved": "2024-06-20T18:56:13.854618", "image_code": "// Created by Stephane Cuillerdier - @Aiekick/2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Tuned via XShade (http://www.funparadigm.com/xshade/)\n\nmat3 getRotXMat(float a){return mat3(1.,0.,0.,0.,cos(a),-sin(a),0.,sin(a),cos(a));}\nmat3 getRotYMat(float a){return mat3(cos(a),0.,sin(a),0.,1.,0.,-sin(a),0.,cos(a));}\nmat3 getRotZMat(float a){return mat3(cos(a),-sin(a),0.,sin(a),cos(a),0.,0.,0.,1.);}\n\nmat3 m1;\nmat3 m2;\n\nvec2 path(float t)\n{\n\treturn vec2(cos(t*0.08), sin(t*0.08)) * 4.;\n}\n\nfloat pattern(vec3 p)\n{\n\tp = abs(fract(p*.3) - 0.5);\n\treturn length( max(abs(p.x), abs(p.y)) - p.z);\n}\n\nvec4 map(vec3 p)\n{\n\tp.xy -= path(p.z);\n    float d0 = min(pattern(p*m1), pattern(p*m2));\n    float d1 = min(pattern(p*3.*m1), pattern(p*2.*m2));\n    \n   \tfloat dist0 = dot(vec3(1)-clamp(d0,0.,1.),vec3(1));\n\tfloat dist1 = dot(vec3(1)-clamp(d1,0.,1.),vec3(d0));\n    \n\treturn vec4(4.5 - length(p.xy) - dist0*.5 + dist1*0.5, vec3(0));\n}\n\nvec3 nor( vec3 pos, float k )\n{\n\tvec3 eps = vec3( k, 0., 0. );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n// return color from temperature \n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// get density of the df at surfPoint\n// ratio between constant step and df value\nfloat SubDensity(vec3 surfPoint, float prec, float ms) \n{\n\tvec3 n;\n\tfloat s = 0.;\n    const int iter = 8;\n\tfor (int i=0;i<iter;i++)\n\t{\n\t\tn = nor(surfPoint,prec); \n\t\tsurfPoint = surfPoint - n * ms; \n\t\ts += map(surfPoint).x;\n\t}\n\t\n\treturn 1.-s/(ms*float(iter)); // s < 0. => inside df\n}\n\nfloat SubDensity(vec3 p, float s) \n{\n\tvec3 n = nor(p,s); \t\t\t\t\t\t\t// precise normale at surf point\n\treturn map(p - n * s).x;\t\t\t\t\t\t// ratio between df step and constant step\n}\n\n// from shane sahders\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n   \n    n = max((abs(n) - .2)*7., .001);\n    n /= (n.x + n.y + n.z );  \n    \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    \n    return p*p;\n}\n\n// from shane sahders\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n    \n}\n\nvec4 shade(vec3 ro, vec3 rd, float d, vec3 lp)\n{\n\tvec3 p = ro + rd * d;\t\t\t\t\t\t\t\t\t\t\t// surface point\n\tfloat sb = SubDensity(p, 0.001, 0.1);\t\t\t\t\t\t\t// deep subdensity (10 iterations)\n\tvec3 bb = blackbody(100.*sb+100.);\t\t\t\t\t\t\t\t// bb\n\tvec3 ld = normalize(lp-p); \t\t\t\t\t\t\t\t\t\t// light dir\n\tvec3 n = nor(p, .0001);\t\t\t\t\t\t\t\t\t\t\t// normal at surface point\n\tn = doBumpMap(iChannel0, -p*0.5, n, 0.015);\n\tvec3 refl = reflect(rd,n);\t\t\t\t\t\t\t\t\t\t// reflected ray dir at surf point \n\tfloat amb = 0.08; \t\t\t\t\t\t\t\t\t\t\t\t// ambiance factor\n\tfloat diff = clamp( dot( n, ld ), 0.0, 1.0 ); \t\t\t\t\t// diffuse\n\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 16. ); \t\t\t// fresnel\n\tfloat spe = pow(clamp( dot( refl, ld ), 0.0, 1.0 ),25.);\t\t// specular\n\tfloat sss = 1. - SubDensity(p*0.1, 0.1) * 0.5; \t\t\t\t\t\t\t// one step sub density of df\n\treturn vec4(\n        (diff + fre + bb.x * sss) * amb + diff * 0.5, \n        (diff + fre + bb * sb + sss * 0.3) * amb + spe * 0.6 - diff * sss * 0.05\t\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 f = vec4(0);\n    \n    vec2 g = fragCoord.xy;\n    vec2 si = iResolution.xy;\n    \n    mat3 mx = getRotXMat(-7.);\n\tmat3 my = getRotYMat(-5.);\n\tmat3 mz = getRotZMat(-3.);\n\t\n    m1 = mx * my * mz;\n    m2 = m1*m1;\n\t\n    // for avoid artifacts due to float precision over 400 secs\n    float time = mod(iTime * 4., 400.); \n    \n    vec3 camUp=vec3(0,1,0);//Change camere up vector here\n  \tvec3 camView=vec3(0,0,time + .1); //Change camere view here\n\tcamView.xy += path(camView.z);\n    \n  \tvec2 uv = (g+g-si)/si.y;\n    \n    vec3 ro = vec3(0,0,time);\n\tro.xy += path(ro.z);\n    \n    vec3 lp = vec3(path(ro.z + 7.),ro.z + 7.);\n    \n  \tvec3 rov = normalize(camView-ro);\n    vec3 u = normalize(cross(camUp,rov));\n  \tvec3 v = cross(rov,u);\n  \tvec3 rd = normalize(rov + uv.x*u + uv.y*v);\n    \n    float s = 1.;\n    float d = 0.;\n    for(int i=0;i<60;i++)\n    {      \n        if (log(d*d/s/1e4)>0.) break;\n        d += s = map(ro+rd*d).x * .6;\n    }\n\t\n    vec3 p = ro+rd*d;\n    vec3 n = nor(p, 0.1);\n        \n    f = shade(ro, rd, d, lp);\n\t\n\tf = f.zyww + f.x*0.2;\n\n    f = mix( f, vec4(0.8), 1.0-exp( -0.001*d*d ) );\n        \n   \tfragColor = sqrt(f*f*f*2.);\n}\n", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsffW7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsffWs", "name": "Smoothed Voronoi Landscape", "author": "dr2", "description": "Smoothed hexagonal lattice-based Voronoi landscape with fireball; mouse enabled. Details in the source.", "tags": ["voronoi", "raymarch", "landscape"], "likes": 11, "viewed": 631, "date": "1498773637", "time_retrieved": "2024-06-20T18:56:16.224500", "image_code": "// \"Smoothed Voronoi Landscape\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n Smoothed honeycomb-based Voronoi landscape with fireball; mouse enabled.\n\n Voronoi patterns are discussed in several articles at  www.iquilezles.org. Cell\n edges are generated by computing d_2 - d_1, where d_k is the distance to the\n k-th nearest cell center, or some extension of this to reduce artifacts. These\n methods all produce sharp corners, which lead to sharp edges when used for\n landscape generation.\n\n The method employed here is based on smoothmin (d_3, d_2, epsilon) - d_1, which\n reduces the severity of the problem (contrast with \"Flaming Sphere 2\").\n\n Explore the effect by changing DLEVEL:\n   DLEVEL = 5 full image\n   DLEVEL = 4 no fireball\n   DLEVEL = 3 no surface texturing or shadows\n   DLEVEL = 2 no noise in polygon positioning\n   DLEVEL = 1 no polygon corner smoothing\n*/\n\n#define DLEVEL 5\n\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nfloat Noiseff (float p);\nfloat Noisefv2 (vec2 p);\nvec3 Noisev3v2 (vec2 p);\nfloat Fbm2 (vec2 p);\nfloat Fbm3 (vec3 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nmat3 flMat;\nvec3 flPos, qHit, qnHit, fBallPos, sunDir;\nvec2 gVec[7], hVec[7];\nfloat tCur, dstFar, fBallRad;\nconst float pi = 3.14159;\n\n#define SQRT3 1.73205\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./SQRT3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (SQRT3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvoid HexVorInit ()\n{\n  vec3 e = vec3 (1., 0., -1.);\n  gVec[0] = e.yy;\n  gVec[1] = e.xy;\n  gVec[2] = e.yx;\n  gVec[3] = e.xz;\n  gVec[4] = e.zy;\n  gVec[5] = e.yz;\n  gVec[6] = e.zx;\n  for (int k = 0; k < 7; k ++) hVec[k] = HexToPix (gVec[k]);\n}\n\n#define EPS 0.1  // controls smoothing\n\nvec4 HexVor (vec2 p)\n{\n  vec4 sd, udm;\n  vec2 ip, fp, d, u;\n  float amp, a;\n  amp = 0.7;\n  ip = PixToHex (p);\n  fp = p - HexToPix (ip);\n  sd = vec4 (4.);\n  udm = vec4 (4.);\n  for (int k = 0; k < 7; k ++) {\n    u = Hashv2v2 (ip + gVec[k]);\n    a = 2. * pi * (u.y - 0.5);\n    d = hVec[k] + amp * (0.4 + 0.6 * u.x) * vec2 (cos (a), sin (a)) - fp;\n    sd.w = dot (d, d);\n    if (sd.w < sd.x) {\n      sd = sd.wxyw;\n      udm = vec4 (d, u);\n    } else sd = (sd.w < sd.y) ? sd.xwyw : ((sd.w < sd.z) ? sd.xyww : sd);\n  }\n  sd.xyz = sqrt (sd.xyz);\n#if DLEVEL >= 2\n  return vec4 (SmoothMin (sd.y, sd.z, EPS) - sd.x, udm.xy, Hashfv2 (udm.zw));\n#else\n  return vec4 (min (sd.y, sd.z) - sd.x, udm.xy, Hashfv2 (udm.zw));\n#endif\n}\n\nfloat GrndHt (vec2 p)\n{\n  vec4 sv;\n  float h1, h2, r, s;\n#if DLEVEL >= 3\n  r = 0.2 * length (Noisev3v2 (0.3 * p));\n#else\n  r = 0.;\n#endif\n  sv = HexVor (0.05 * p + r);\n  s = (0.8 + 0.5 * sv.w);\n  h1 = s * smoothstep (0.1, 0.4 + 0.1 * sv.w, sv.x);\n  h2 = 2. * s * smoothstep (0.2, 0.4 + 0.1 * sv.w, max (0.,\n     (0.45 - dot (sv.yz, sv.yz))));\n  return 3. * SmoothMax (h1, h2, 0.4) - 0.5;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = 0; j < 200; j ++) {\n    p = ro + s * rd;\n    h = p.y - GrndHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.2, 0.4 * h);\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = 0; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (p.y > GrndHt (p.xz)) sLo = s;\n      else sHi = s;\n    }\n    dHit = 0.5 * (sLo + sHi);\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec2 e = vec2 (0.01, 0.);\n  float h;\n  h = GrndHt (p.xz);\n  return normalize (vec3 (h - GrndHt (p.xz + e.xy), e.x, h - GrndHt (p.xz + e.yx)));\n}\n\nfloat FBallHit (vec3 ro, vec3 rd, vec3 p, float s)\n{\n  vec3 v;\n  float h, b, d;\n  v = ro - p;\n  b = dot (rd, v);\n  d = b * b + s * s - dot (v, v);\n  h = dstFar;\n  if (d >= 0.) {\n    h = - b - sqrt (d);\n    qHit = ro + h * rd;\n    qnHit = (qHit - p) / s;\n  }\n  return h;\n}\n\nfloat FBallLum (vec3 ro, vec3 rd, float dHit)\n{\n  vec3 p, q, dp;\n  float g, s, fr, f;\n  p = ro + dHit * rd - fBallPos;\n  dp = (fBallRad / 30.) * rd;\n  g = 0.;\n  for (int i = 0; i < 30; i ++) {\n    p += dp;\n    q = 4. * p;   q.y -= 5. * tCur;\n    f = Fbm3 (q);\n    q = 7. * p;   q.y -= 9. * tCur;\n    f += Fbm3 (q);\n    s = length (p);\n    fr = max (1. - 0.9 * s / fBallRad, 0.);\n    g += max (0.15 * fr * (f - 0.55), 0.);\n    if (s > fBallRad || g > 1.) break;\n  }\n  return g;\n}\n\nvec3 SkyBg (vec3 rd)\n{\n  return vec3 (0.2, 0.3, 0.55) + 0.1 * pow (1. - max (rd.y, 0.), 4.);\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  float sd, f;\n  sd = max (dot (rd, sunDir), 0.);\n  ro.x += 0.5 * tCur;\n  f = 0.5 * Fbm2 (0.1 * (rd.xz * (50. - ro.y) / rd.y + ro.xz));\n  col = SkyBg (rd) + 0.35 * pow (sd, 6.) + 0.65 * min (pow (sd, 256.), 0.3);\n  return mix (col, vec3 (0.85), clamp (f * rd.y + 0.1, 0., 1.));\n}\n\nfloat GrndSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float sh, d, h;\n  sh = 1.;\n  d = 1.;\n  for (int j = 0; j < 16; j ++) {\n    p = ro + rd * d;\n    h = p.y - GrndHt (p.xz);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += 0.3;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 flmCol, col, vn;\n  float dstGrnd, dstFbHit, fIntens, f, sh;\n  HexVorInit ();\n#if DLEVEL == 5\n  dstFbHit = FBallHit (ro, rd, fBallPos, fBallRad);\n  fIntens = (dstFbHit < dstFar) ? FBallLum (ro, rd, dstFbHit) : 0.;\n#endif\n  dstGrnd = GrndRay (ro, rd);\n  if (dstGrnd < dstFar) {\n    ro += dstGrnd * rd;\n    vn = GrndNf (ro);\n    sh = 1.;\n#if DLEVEL >= 4\n    vn = VaryNf (1.3 * ro, vn, 3.);\n    sh = GrndSShadow (ro, sunDir);\n#endif\n    col = mix (vec3 (0.9), vec3 (1.), clamp (0.7 * Noisefv2 (ro.xz) - 0.3, 0., 1.));\n    col = col * (0.1 + 0.1 * max (vn.y, 0.) +\n       0.2 * max (dot (vn, - sunDir), 0.) +\n       0.8 * sh * max (0., max (dot (vn, sunDir), 0.))) +\n       0.2 * sh * pow (max (dot (normalize (sunDir - rd), vn), 0.), 64.);\n    f = dstGrnd / dstFar;\n    f *= f;\n    col = mix (col, SkyBg (rd), max (f * f - 0.1, 0.));\n  } else col = SkyCol (ro, rd);\n#if DLEVEL == 5\n  if (dstFbHit < dstFar) {\n    ro += rd * dstFbHit;\n    rd = reflect (rd, qnHit);\n    col = 0.9 * col + 0.08 + 0.25 * max (dot (qnHit, sunDir), 0.) * (1. +\n       4. * pow (max (0., dot (sunDir, rd)), 128.));\n  }\n  f = clamp (0.7 * fIntens, 0., 1.);\n  f *= f;\n  flmCol = (1. + 0.4 * Noiseff (10. * tCur)) *\n     mix (vec3 (1., 0.4, 0.1), vec3 (1., 1., 0.5), f * f);\n  col = mix (col, flmCol, min (1.2 * fIntens * fIntens, 1.));\n  if (dstFbHit < dstFar) {\n    dstGrnd = GrndRay (ro, rd);\n    col = mix (col, ((dstGrnd < dstFar) ? vec3 (0.4, 0.4, 0.5) :\n       SkyCol (ro, rd)), pow (1. - abs (dot (rd, qnHit)), 3.));\n  }\n#endif\n  return pow (clamp (col, 0., 1.), vec3 (0.7));\n}\n\nvec3 TrackPath (float t)\n{\n  return vec3 (30. * sin (0.035 * t) * sin (0.012 * t) * cos (0.01 * t) +\n     26. * sin (0.0032 * t), 1. + 3. * sin (0.021 * t) * sin (1. + 0.023 * t), t);\n}\n\nvoid VuPM (float t)\n{\n  vec3 fpF, fpB, vel, acc, va, ort, cr, sr;\n  float dt;\n  dt = 2.;\n  flPos = TrackPath (t);\n  fpF = TrackPath (t + dt);\n  fpB = TrackPath (t - dt);\n  vel = (fpF - fpB) / (2. * dt);\n  vel.y = 0.;\n  acc = (fpF - 2. * flPos + fpB) / (dt * dt);\n  acc.y = 0.;\n  va = cross (acc, vel) / length (vel);\n  ort = vec3 (0.2, atan (vel.z, vel.x) - 0.5 * pi, 5. * length (va) * sign (va.y));\n  cr = cos (ort);\n  sr = sin (ort);\n  flMat = mat3 (cr.z, - sr.z, 0., sr.z, cr.z, 0., 0., 0., 1.) *\n     mat3 (1., 0., 0., 0., cr.x, - sr.x, 0., sr.x, cr.x) *\n     mat3 (cr.y, 0., - sr.y, 0., 1., 0., sr.y, 0., cr.y);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float az, el;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = 0.;\n  VuPM (10. * tCur);\n  ro = flPos;\n  rd = normalize (vec3 (uv, 2.5));\n  if (mPtr.z > 0.) {\n    az = -2. * pi * mPtr.x;\n    el = -0.1 * pi + pi * mPtr.y;\n    ori = vec2 (el, az);\n    ca = cos (ori);\n    sa = sin (ori);\n    vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n       mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n    rd = vuMat * rd;\n  } else {\n    rd = rd * flMat;\n  }\n  fBallRad = 3.;\n  fBallPos = TrackPath (10. * (tCur + 5. + 4. * sin (0.5 * tCur)));\n  fBallPos.y += 10.;\n  ro.y += 12.;\n  sunDir = normalize (vec3 (cos (0.01 * tCur), 0.7, - sin (0.01 * tCur)));\n  dstFar = 200.;\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, cHashA3.xy)) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + cHashA4.xy) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  const vec2 cHashVA2 = vec2 (37.1, 61.7);\n  const vec2 e = vec2 (1., 0.);\n  return fract (sin (vec2 (dot (p + e.yy, cHashVA2),\n     dot (p + e.xy, cHashVA2))) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  const vec3 cHashVA3 = vec3 (37.1, 61.7, 12.4);\n  const vec3 e = vec3 (1., 0., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  float i, f;\n  i = floor (p);  f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec2 t = Hashv2f (i);\n  return mix (t.x, t.y, f);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Noisefv3a (vec3 p)\n{\n  vec3 i, f;\n  i = floor (p);  f = fract (p);\n  f *= f * (3. - 2. * f);\n  vec4 t1 = Hashv4v3 (i);\n  vec4 t2 = Hashv4v3 (i + vec3 (0., 0., 1.));\n  return mix (mix (mix (t1.x, t1.y, f.x), mix (t1.z, t1.w, f.x), f.y),\n              mix (mix (t2.x, t2.y, f.x), mix (t2.z, t2.w, f.x), f.y), f.z);\n}\n\nvec3 Noisev3v2 (vec2 p)\n{\n  vec4 h;\n  vec3 g;\n  vec2 ip, fp, ffp;\n  ip = floor (p);\n  fp = fract (p);\n  ffp = fp * fp * (3. - 2. * fp);\n  h = Hashv4f (dot (ip, cHashA3.xy));\n  g = vec3 (h.y - h.x, h.z - h.x, h.x - h.y - h.z + h.w);\n  return vec3 (h.x + dot (g.xy, ffp) + g.z * ffp.x * ffp.y,\n     30. * fp * fp * (fp * fp - 2. * fp + 1.) * (g.xy + g.z * ffp.yx));\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f;\n}\n\nfloat Fbm3 (vec3 p)\n{\n  const mat3 mr = mat3 (0., 0.8, 0.6, -0.8, 0.36, -0.48, -0.6, -0.48, 0.64);\n  float f, a, am, ap;\n  f = 0.;  a = 0.5;\n  am = 0.5;  ap = 4.;\n  p *= 0.5;\n  for (int i = 0; i < 6; i ++) {\n    f += a * Noisefv3a (p);\n    p *= mr * ap;  a *= am;\n  }\n  return f;\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s = vec3 (0.);\n  float a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  float s;\n  const vec3 e = vec3 (0.1, 0., 0.);\n  s = Fbmn (p, n);\n  g = vec3 (Fbmn (p + e.xyy, n) - s, Fbmn (p + e.yxy, n) - s,\n     Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsffWs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsffzS", "name": "Day 4 - Coloured shapes", "author": "Mercesa", "description": "Day 4 of me doing shadertoy, coloured shapes with noise", "tags": ["3d"], "likes": 2, "viewed": 320, "date": "1496687638", "time_retrieved": "2024-06-20T18:56:16.224500", "image_code": "\n#define MAXMARCHSTEPS 64\n#define EPSILON 0.0001\n\nfloat udSphere(vec3 p, float radius)\n{\n    return length(p) - radius;\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat opBlend( vec3 p, float a, float b)\n{\n   \n    return smin( a, b, 0.1f );\n}\n\nfloat opS(float d1, float d2)\n{\n    return max(-d1, d2);\n}\n\n    \nfloat Map(vec3 p)\n{\n    float d1 = udSphere(p, 1.0f);\n    // Rotate around the x axis\n    float d2 = udSphere(p + vec3(cos(iTime + 2.0f) * 1.2f , sin(iTime) * 1.2f, 0.0f), 0.6f);\n    float d3 = udSphere(p + vec3(sin(iTime+ 1.0f) * 1.2f, 0.0f, 0.0f), 0.5f);\n   //float d4 = udBox(p + vec3(, vec3(0.5f, 0.5f, 0.05f);\n    float blend = opBlend(p, d1, d2);\n    float blend2 = opBlend(p, blend, d3);\n    float blend3 = opS(udBox(p + vec3(0.0f, 0.0f, sin(iTime) * 4.0f), vec3(0.5f, 0.5f, 0.5f)), blend2);\n\t\n    //float subSphere = opS(udSphere(p + vec3(0.0f, 0.0f, sin(iTime)), 0.f), blend2);\n    return blend2;\n    \n    \n}\n\nfloat Trace(vec3 origin, vec3 direction, float min, float end, vec2 xy)\n{\n    float t = min;\n    \n    for(int i = 0; i < MAXMARCHSTEPS; ++i)\n    {\n        // We do some trippy things with our sampling point\n        vec3 p = origin + (direction + vec3(texture(iChannel0, xy + vec2(0.0f, 1.0f - iTime)).r) /20.0f * sin(iTime)) * t;\n        \n        float d = Map(p);\n        \n        if(d < EPSILON)\n        {\n            return t;\n        }\n        \n        t += d;\n        \n    \tif(t >= end)\n    \t{\n        \treturn end;\n    \t}    \n    }\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nmat3 ViewMatrix(vec3 eye, vec3 center, vec3 up)\n{\n    vec3 f = normalize(center-eye);\n    vec3 r = normalize(cross(f, up));\n    vec3 u = cross(r,f);\n    \n    return mat3(r,u,-f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \t// Calculate a nice screenspace color\n\tvec2 xy = fragCoord.xy / iResolution.xy;\n    vec2 uv = xy;\n    xy = xy * 2.0f - 1.0f;\n\t//fragColor = vec4(xy,0.5+0.5*sin(iTime),1.0);\n    \n  \n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 lookAt = vec3(0.0f, 0.0f, 0.0f);\n    vec3 eye = vec3(0.0, 0.0f, 7.0f);\n    \n    mat3 viewToWorld = ViewMatrix(eye, vec3(0.0f, 0.0f, 0.0f), vec3(0.0f, 1.0f, 0.0f));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float t = Trace(eye, worldDir, 0.0, 1000.0f, xy);\n\n     \n    float fog = 1.0f / (1.0f + t*t*0.4);\n    //fragColor.rg = xy.rg;\n    \n    \n    if(t > 1000.0f - EPSILON)\n    {\n    \tfragColor = vec4(0.0f, 0.0f, 0.0f, 1.0f);   \n        return;\n    }\n\tvec3 position = normalize(eye + worldDir * t);\n\n   \n    fragColor.rgb = position.rgb;\n    \n    fragColor += fog;\n    //fragColor = vec4(1.0f, 1.0f, 1.0f, 1.0f);\n    \n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsffzS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsffzX", "name": "slimy triangular truchet", "author": "mattz", "description": "This one was fun to make. I tried to pack a lot more effects into this shader than my usual efforts -- lots of bumpmapping and fake refraction. Plus since there's no \"real\" 3D geometry, it wasn't too hard to antialias.", "tags": ["triangle", "truchet", "slime", "slimy"], "likes": 20, "viewed": 897, "date": "1497392393", "time_retrieved": "2024-06-20T18:56:17.660995", "image_code": "/* slimy triangular truchet, by mattz\n   License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n   Use mouse to change lighting.\n\n   flockaroo's \"silver tilings\" (https://www.shadertoy.com/view/XsXfz2) got me thinking\n   about triangular truchet tilings, and I ended up with this odd creation.\n\n */\n\nconst float s3 = 1.7320508075688772;\nconst float i3 = 0.5773502691896258;\n\nconst mat2 tri2cart = mat2(1.0, 0.0, -0.5, 0.5*s3);\nconst mat2 cart2tri = mat2(1.0, 0.0, i3, 2.0*i3);\n\n/////////////////////////////////////////////////////////////////////////////\n\n// from https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE1 .1031\n\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n\n// from https://www.shadertoy.com/view/XsXfRH\n// return value noise (in x) and its derivatives (in yzw)\nvec4 noised( in vec3 x ) {\n    \n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n#if 1\n    // quintic interpolation\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n#else\n    // cubic interpolation\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n#endif    \n    \n    \n    float a = hash13(p+vec3(0.0,0.0,0.0));\n    float b = hash13(p+vec3(1.0,0.0,0.0));\n    float c = hash13(p+vec3(0.0,1.0,0.0));\n    float d = hash13(p+vec3(1.0,1.0,0.0));\n    float e = hash13(p+vec3(0.0,0.0,1.0));\n\tfloat f = hash13(p+vec3(1.0,0.0,1.0));\n    float g = hash13(p+vec3(0.0,1.0,1.0));\n    float h = hash13(p+vec3(1.0,1.0,1.0));\n\t\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \n                 du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\n                            k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\n                            k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// fractal brownian motion w/ derivative thanks to iq's code above\n\nvec4 fbmd(vec3 p) {\n    \n    vec4 rval = vec4(0);\n    float a = 1.0;\n    \n    vec3 freq = vec3(1.0);\n    vec3 scl = vec3(vec2(2.0), 1.0);\n    \n    for (int i=0; i<4; ++i) {\n        rval += a*noised(p*freq) * vec4(1.0, freq);\n        freq *= scl;\n        p += vec3(1.32, -2.392, 1.392) * freq;\n        a *= 0.2;\n    }\n    \n    return rval;\n    \n}\n\n/////////////////////////////////////////////////////////////////////////////\n// sample texture and fake normal\n\nvec3 sample_bump(in vec2 uv, in vec3 L) {\n    \n    vec3 color = texture(iChannel0, uv).xyz;\n    \n    const vec2 eps = vec2(1.0/1024.0, 0.0);\n    \n    vec3 N = normalize(vec3(texture(iChannel0, uv - eps.xy).x - \n                       texture(iChannel0, uv + eps.xy).x,\n                       texture(iChannel0, uv - eps.yx).x - \n                       texture(iChannel0, uv + eps.yx).x, \n                       0.1));\n    \n    color *= 0.3 + 0.7 * clamp(dot(N, L), 0.0, 1.0);    \n    \n    return color;\n       \n}\n\n/////////////////////////////////////////////////////////////////////////////\n// our main function\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n    // fit 4 full rows of triangles on screen\n    float scl = 2.0*s3 / iResolution.y;\n    \n    // get 2D scene coords\n \tvec2 p = (fragCoord - 0.5*iResolution.xy) * scl;\n    \n    // fake 3D coordinates for lighting: place hit point on a plane at z=-4\n    vec3 hit = vec3(p, -4.0);\n    \n    // place light at z=10\n    vec3 lpos = vec3(-cos(-iTime*0.047), 0.5*cos(iTime*0.053), 1.0) * 10.0;\n    \n    // handle mouse light position\n    if (iMouse.z > 0.0) {\n        lpos.xy = 20.0*(iMouse.xy - 0.5*iResolution.xy)/iResolution.xy;\n    }\n\n    // light direction and view direction for ray hitting scene\n    vec3 L = normalize(lpos - hit);\n    vec3 V = normalize(hit);\n\n    // get triangular coords\n    vec2 tri_coords = cart2tri * p;\n    vec2 tri_idx = floor(tri_coords);\n    vec2 tri_frac = tri_coords - tri_idx;\n    float top_bottom = step(tri_frac.y, tri_frac.x);\n    \n    // position relative to triangle vertex 0\n    vec2 pdiff = p - tri2cart*tri_idx;\n\n    // vertex 1 and 2, relative to vertex 0\n    const vec2 c1 = vec2(0.5, 0.5*s3);\n    vec2 c2 = tri2cart * vec2(top_bottom, 1.0-top_bottom);\n    \n    // handle growing/shrinking\n    float t = iTime * 0.125;\n    float ft = max(0.0, abs(fract(t) - 0.5) - 0.1666666);\n    ft = smoothstep(0.3333333, 0.0, ft);\n    \n    // minimum radius of \"island\" circles \n    const float rmin = 0.34;\n\n    // how far from the edge does the slopey bit go\n    // should exactly dome off when at minimum radius\n    const float chamfer = rmin - 0.25;\n\n    // maximum radius should be just past closing up chamfers\n    const float rmax = i3 + 1.1*chamfer;\n\n    // actual radius of \"islands\"\n    float rad = mix(rmax, rmin, ft);\n    \n    // generate a random number for this cell at this time\n    float tri_random = hash13(vec3(tri_idx, top_bottom + 2.0*floor(t)));\n    \n    vec2 pts[3];\n    float ds;\n    \n    // bias ever so slightly to type 2 cells \n    if (tri_random < 0.45) { \n        // type 1 cell has arcs of given radius at each corner\n        pts[0] = vec2(0);\n        pts[1] = c1;\n        pts[2] = c2;\n        rad = -rad;\n        ds = 1.0;\n    } else {\n        // type 2 cell has arcs of complement of given radius at current edge\n        pts[0] = 0.5*c1;\n        pts[1] = 0.5*c2;\n        pts[2] = pts[0] + pts[1];\n        rad = 0.5 - rad;\n        ds = -1.0;\n    }\n    \n    // get distance to nearest feature and normal direction\n    vec3 nd = vec3(0, 0, 1e5);\n\n    for (int i=0; i<3; ++i) {\n        vec2 n = ds*(pdiff - pts[i]);\n        float ln = length(n);\n        if (ln < nd.z) {\n            nd = vec3(n/ln, ln);\n        }\n    }\n\n    // signed distance to slime: d < 0 inside slime\n    float d = nd.z*ds + rad; \n    \n    // point coordinates for fbm function\n    // oscillate in x, scroll in y, undulate in time.\n    vec3 pn = vec3(2.0*p + vec2(0.04*sin(0.2*iTime), 0.1*iTime), 0.2*iTime);\n    vec2 f_grad = fbmd(pn).yz;\n       \n    // e is 1 at edge, 0 in center (linearly)\n    // z is 0 at edge, 1 at center (in a circular arc)    \n    float e = clamp((chamfer + d) / chamfer, 0.00001, 0.99999); \n    float z = sqrt(1.0 - e*e);\n    vec2 z_grad = nd.xy * e / z;\n    \n    // make surface normal for fluid and smoothstep at fluid boundary\n    vec2 nxy = z_grad + 0.15*f_grad;\n    vec3 N = normalize(vec3(nxy, 1.0));\n    \n    // smooth blending coefficient between background (k=0) and surface (k=1)\n    float coverage = smoothstep(0.0, scl, -d);    \n\n    // get reflection vector for phong lighting    \n    vec3 R = reflect(L, N);\n\n    // get UV coordinates for background texture\n    vec2 uv = 0.5 + (fragCoord.xy - 0.5*iResolution.xy) * 0.25 / iResolution.y;\n    \n    // sample the background texture \n    vec3 bg = sample_bump(uv, L);\n    \n    // fake refraction perturbs background texture lookup by fluid surface normal\n    vec3 bgR = sample_bump(uv - 0.08*N.xy * N.z, L);\n    \n    // light and shade slime:\n    const vec3 hue = vec3(0.3, 1.0, 0.0);\n    const vec3 surface_color = 0.5*hue;\n    const vec3 transmissive_color = 0.5*hue + 0.5;\n    const vec3 specular_color = 0.2*hue + 0.8;\n    \n    // diffuse + ambient\n    float diffamb = 0.3 + 0.7 * clamp(dot(N, L), 0.0, 1.0);\n    vec3 fg = surface_color * diffamb;\n    \n    // transparent background\n    fg = mix(fg, bgR * transmissive_color, 0.3);\n    \n    // specular\n    fg += 0.5*pow(clamp(dot(V, R), 0.0, 1.0), 10.0)*specular_color;\n       \n    // smoothstep based upon coverage\n    fragColor = vec4(mix(bg, fg, coverage), 1.0);\n    \n}", "image_inputs": [{"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsffzX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lslBDX", "name": "2D Rocket", "author": "antoineMoPa", "description": "A simple 2D rocket with smoke made out of sin waves. (Sorry I have no windows computers currently available to test for windows bugs)", "tags": ["2d", "glsl", "rocket"], "likes": 8, "viewed": 698, "date": "1498617544", "time_retrieved": "2024-06-20T18:56:18.515540", "image_code": "                \n#define PI 3.14159265359\n#define PI2 6.28318530718\n\n#define shadertoy 1\n\n#ifdef shadertoy\n// time is iTime in shadertoy\n#define time iTime\n#endif\n#ifndef shadertoy\n// Define some uniforms\n// (which shadertoy already defines for us, but not shadergif)\nprecision highp float;\nuniform float time;\nuniform float iTime;\nvarying vec2 UV;\nuniform vec3 iResolution;\n#endif\n\n\nvec4 rocket(vec2 pos){\n    vec4 col = vec4(0.0);\n    \n    // Clip (because otherwise a sine is repeated)\n    if(pos.x < -0.5 || pos.x > 0.5){\n        return col;\n    }\n    \n    if(\n      // Base parabolic shape\n      pos.y + 0.02 * cos(12.0 * pos.y + 0.1) * pos.y < 0.5 - pow(3.88 * pos.x, 2.0) && pos.y > -0.1 \n      ||\n        // Lower rectangle\n       ( pos.y < 0.0 && pos.y > -0.2 \n            && \n                // Lower left arc\n                (pos.x > -0.1 || distance(pos, vec2(-0.1,-0.1)) < 0.10) \n                // Lower right arc\n            &&     (pos.x < 0.1  || distance(pos, vec2(0.1,-0.1)) < 0.10)\n       )\n      )\n    {\n        // Window\n        if (\n            distance(pos, vec2(0.0,0.2)) < 0.05\n        )\n        {\n            col.rgb += vec3(0.1,0.1,0.1);\n            col.a = 1.0;\n        }\n        // Rest\n        else\n        {\n            col.rgb += vec3(1.0,1.0,1.0);\n            col.a = 1.0;\n        }\n    }\n    \n    else if (\n        pos.y < -0.4 + 0.5 * cos(4.5 * pos.x)\n        &&\n        pos.y > -0.5 + 0.3 * cos(3.0 * pos.x)\n    )\n    {\n        col.rgb += vec3(1.0,0.1,0.2);\n        col.a = 1.0;\n    }\n    \n    // Propeller\n    else if (pos.x < 0.1 && pos.y < 0.0 && pos.x > -0.1 && pos.y > -0.3)\n    {\n        col.rgb += vec3(0.3,0.3,0.3) + 0.3 * cos(pos.x * 10.0 + 1.0);\n        col.a = 1.0;\n    }\n       \n    \n    return col;\n}\n\nmat2 rotation(float angle){\n    mat2 r = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    return r;\n}\n\nvec4 smoke(vec2 pos){\n    vec4 col = vec4(0.0);\n    \n    // Density\n    float d = 0.0;\n    \n    pos.y += 0.08;\n    \n    if(pos.y > 0.0){\n    \treturn col;\n    }\n    \n    pos.x += 0.003 * cos(20.0 * pos.y + 4.0 * time * PI2);\n    float dd = distance(pos,vec2(0.0,0.0));\n    if(dd > 1.0){\n    \tpos *= 2.2 * pow(1.0 - dd, 2.0);\n    }\n    \n    pos *= 1.9;\n    \n    d += cos(pos.x * 10.0);\n\td += cos(pos.x * 20.0);\n\td += cos(pos.x * 40.0);\n\t\n    d += 0.3 * cos(pos.y * 6.0 + 8.0 * time * PI2) - 1.4;\n\td += 0.3 * cos(pos.y * 50.0 + 4.0 * time * PI2) ;\n\td += 0.3 * cos(pos.y * 10.0 + 2.0 * time * PI2);\n    \n    if(distance(pos.x, 0.0) < 0.05){\n    \td *= 0.2 - distance(pos.x, 0.0);\t\n    } else {\n    \td *= 0.0;\n    }\n    if( d < 0.0){\n    \td = 0.0;\n    }\n    \n    float dy = distance(pos.y, 0.0);\n    \n    if(dy < 0.3){\n        float fac = 1.0 / 0.3 * dy;\n    \tcol.r += 50.0 * pow(1.0 - fac,2.0) * d;\n        col.g += 10.0 * pow(1.0 - fac,4.0) * d;\n        col.a += 20.0 * (1.0 - fac) * d;\n    }\n    \n    col.rgb += d * 10.0;\n    col.a += d;\n    \n    return col;\n}\n\n\nvec4 alpha_over(vec4 a, vec4 b){\n\treturn a * a.a + (1.0 - a.a) * b; \n}\n\nvoid mainImage(out vec4 col, in vec2 UV){\n    vec2 pos = UV / iResolution.xy;\n    pos -= vec2(0.5);\n    pos.x *= iResolution.x / iResolution.y;\n    \n    col = 0.4 * vec4(0.3, 0.5, 0.7, 0.0) - 0.2 * cos(time * 0.3 + pos.y + 0.35 * pos.x);\n    \n   \t\n    vec2 rocket_pos = pos * rotation(0.5 + 0.02 * cos(time * PI2) + 0.02 * cos(2.0 * time * PI2));\n    rocket_pos *= 3.9;\n    col = alpha_over(rocket(rocket_pos),col);\n    \n    vec2 smoke_pos = pos * rotation(0.5);\n    col = alpha_over(smoke(smoke_pos),col);\n\n    col.a = 1.0;\n}\n\n\n#ifndef shadertoy\nvoid main(){\n    vec2 uv = UV.xy * iResolution.xy;\n    vec4 col = vec4(0.0);\n\n    mainImage(col, uv);\n\n    gl_FragColor = col;\n}\n#endif", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lslBDX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lslBRj", "name": "Colory sphery fractal", "author": "Kikkers", "description": "Colors, spheres", "tags": ["colors", "spheres"], "likes": 6, "viewed": 147, "date": "1497035970", "time_retrieved": "2024-06-20T18:56:19.958038", "image_code": "\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (sqrt(5)*0.5 + 0.5)\n\n// Clamp to [0,1] - this operation is free under certain circumstances.\n// For further information see\n// http://www.humus.name/Articles/Persson_LowLevelThinking.pdf and\n// http://www.humus.name/Articles/Persson_LowlevelShaderOptimization.pdf\n#define saturate(x) clamp(x, 0, 1)\n\nfloat fOpIntersectionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r + a,r + b), vec2(0));\n\treturn min(-r, max (a, b)) + length(u);\n}\n\nfloat fOpDifferenceRound (float a, float b, float r) {\n\treturn fOpIntersectionRound(a, -b, r);\n}\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n// Cheap Box: distance to corners is overestimated\nfloat fBoxCheap(vec3 p, vec3 b) { //cheap box\n\treturn vmax(abs(p) - b);\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Box: correct distance to corners\nfloat fBoxChamfer(vec3 p, vec3 b, float c) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0))) - c;\n}\n\n// Repeat in three dimensions\nvec3 pMod3(inout vec3 p, vec3 size) {\n\tvec3 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\treturn c;\n}\n\n\n\n#define EPSILON 0.0001\n#define MAX_MARCHING_STEPS 255\n#define MIN_DIST 0.1\n#define MAX_DIST 15.0\n\n//float global\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 p, out int depth) {\n    float boxSize = 0.85;\n    float chamfer = 0.01;\n    vec3 boxBounds = vec3(boxSize, boxSize, boxSize);\n    \n    pMod3(p, boxBounds * 2.0);\n    //pMod3(p, boxBounds * 20.0);\n    \n    //float box = fBoxChamfer(p, boxBounds, chamfer);\n    float box = fBoxCheap(p, boxBounds);\n    \n    \n    float spheres = 1000.0;\n    vec3 sphereOffset = vec3(0);\n    float sphereSize = 1.0;\n    depth = 0;\n    for(int i = 0; i < 9; ++i) {\n        float newSphere = fSphere(p, sphereSize);\n        if (newSphere < spheres)\n        {\n            depth = i;\n            spheres = newSphere;\n        }\n    \tboxBounds *= 0.5;\n        p += boxBounds + vec3(sin(iTime * 0.2) * 0.1);\n        sphereSize *= 0.4 + sin(iTime * 0.17) * 0.05;\n    \tpMod3(p, boxBounds * 2.0);\n    }\n    \n    return fOpDifferenceRound(box, spheres, chamfer);\n}\n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec3 normal( vec3 p )\n{\n    vec2 e = vec2(0.005, -0.005);\n    int depth;\n    return normalize(\n        e.xyy * sceneSDF(p + e.xyy, depth) + \n        e.yyx * sceneSDF(p + e.yyx, depth) + \n        e.yxy * sceneSDF(p + e.yxy, depth) + \n        e.xxx * sceneSDF(p + e.xxx, depth));\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end, out int hit) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection, hit);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n   \nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n   \n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = normal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n     \n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = (fragCoord.xy - iResolution.xy/2.0) / min(iResolution.xy.x, iResolution.xy.y);\n    \n    float t = iTime * 0.1;\n    float camDist = 3.0;\n    vec3 campos = vec3(camDist * sin(t*0.37),2.5*sin(t*0.59),-camDist*cos(t*0.73));\n    vec3 camtar = vec3(0.0,0.0,0.0);\n    \n    mat3 camMat = calcLookAtMatrix( campos, camtar, 0.0 );\n\tvec3 camdir = normalize( camMat * vec3(xy,1.0) );\n    \n    int hit;\n    float dist = shortestDistanceToSurface(campos, camdir, MIN_DIST, MAX_DIST, hit);\n    float fog = (MAX_DIST - dist) / MAX_DIST;\n    fog *= fog;\n    \n    vec3 fogColor = vec3(0.3, 0.5, 0.7);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(fogColor, 1.0);\n\t\treturn;\n    }\n    \n    vec3[6] colors;\n    colors[0] = vec3(0.6, 1.0, 0.3);\n    colors[1] = vec3(1.0, 0.0, 0.6);\n    colors[2] = vec3(0.0, 0.5, 1.0);\n    colors[3] = vec3(0.4, 0.3, 0.4);\n    colors[4] = vec3(0.0, 0.9, 0.3);\n    colors[5] = vec3(0.9, 0.9, 0.2);\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = campos + dist * camdir;\n    \n    vec3 K_a = vec3(0.2, 0.2, 0.2);\n    vec3 K_d = colors[hit % 6];//vec3(0.7, 0.5, 0.6);\n    vec3 K_s = fogColor;\n    float shininess = 10.0;\n    \n    //vec3 color = normal(p);\n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, campos);\n    fragColor = vec4(color * fog + fogColor * (1.0 - fog), 1.0);    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lslBRj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lslBWj", "name": "triplanar  texturing test", "author": "AngryBaguette", "description": "WIP", "tags": ["triplanar"], "likes": 2, "viewed": 106, "date": "1498233009", "time_retrieved": "2024-06-20T18:56:21.006763", "image_code": "// Triplanar texture fetch\n//\n// References:\n// https://gamedevelopment.tutsplus.com/articles/use-tri-planar-texture-mapping-for-better-terrain--gamedev-13821\n// http://www.martinpalko.com/triplanar-mapping/\n//\n// Distance function\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.001;\nconst float GRAD_STEP = 0.1;\nconst float PI_4 = 0.78539816339744;\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n    \n\n// Union\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\n// Substraction\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n// Intersection\nfloat opI( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\n// Twist operator\nvec3 opTwist( vec3 p, float sa )\n{\n    float c = cos(sa*p.y);\n    float s = sin(sa*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return q;\n}\n\n// Box\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// Sphere\nfloat sdSphere( vec3 p, float r )\n{\n     return length(p)-r;\n}\n\nfloat sdCircle(vec2 uv, vec2 center, float r)\n{\n    vec2 c = (uv - center);\n    return 1.0-clamp(dot(c,c)/r,0.0,1.0);\n}\n    \n// Rotation matrix from euler angle (radian)\nmat3 fromEuler(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat3 m;\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n\treturn m;\n}\n\n// The scene\nfloat sdScene(vec3 p)\n{     \n    // twist\n\tp = fromEuler( vec3(0.0,0.0,p.y) ) * p;\n    p = opTwist(p, 0.0);\n    \n    //return sdSphere(p,1.0);\n    //return sdBox(p,vec3(0.75,0.75,0.5));\n    //return opS( sdSphere(p,1.0), sdBox(p,vec3(0.75,0.75,0.5)) );\n    //return opS( sdBox(p,vec3(0.8,0.8,0.5)), sdSphere(p,1.0) );\n    return opU( sdBox(p,vec3(2.0,2.0,2.0)), sdSphere(p,2.7) );\n    //return sdSphere(p,2.7);\n}\n\n// Compute through gradient\nvec3 sdSceneNormal(vec3 p) \n{\n    return normalize(vec3(\n        sdScene(vec3(p.x + GRAD_STEP, p.y, p.z)) - sdScene(vec3(p.x - GRAD_STEP, p.y, p.z)),\n        sdScene(vec3(p.x, p.y + GRAD_STEP, p.z)) - sdScene(vec3(p.x, p.y - GRAD_STEP, p.z)),\n        sdScene(vec3(p.x, p.y, p.z  + GRAD_STEP)) - sdScene(vec3(p.x, p.y, p.z - GRAD_STEP))\n    ));\n}\n\n// Ray marching algorithm\nfloat sdRayMarching(Ray ray, float start, float end)\n{\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sdScene(ray.origin + depth * ray.direction);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\n// Compute ray\nRay sdRay(vec3 origin, vec2 frag, vec2 res, float fov)\n{\n    Ray ray;\n    ray.origin = origin;\n    vec2 xy = frag - res / 2.0;\n    float z = res.y / tan(fov / 2.0);\n    ray.direction = normalize(vec3(xy, -z));\n    \n    return ray;\n}\n\n// https://gamedevelopment.tutsplus.com/articles/use-tri-planar-texture-mapping-for-better-terrain--gamedev-13821\n// http://www.martinpalko.com/triplanar-mapping/\nvec4 textureTriPlanar(vec3 P, vec3 N)\n{\n    float texScale = 2.0;\n    // Absolute world normal\n    vec3 sharpness = vec3(1.0);\n    vec3 Nb = pow(abs(N), sharpness);     \n    // Force weights to sum to 1.0\n    float b = (Nb.x + Nb.y + Nb.z);\n    Nb /= vec3(b);\t\n    \n    vec4 c0 = texture(iChannel0, P.xy * texScale) * Nb.z;\n    vec4 c1 = texture(iChannel0, P.yz * texScale) * Nb.x;\n    vec4 c2 = texture(iChannel0, P.xz * texScale) * Nb.y;\n    \n    //vec4 c0 = vec4(1.0,0.0,0.0,1.0) * Nb.z;\n    //vec4 c1 = vec4(0.0,1.0,0.0,1.0) * Nb.x;\n    //vec4 c2 = vec4(0.0,0.0,1.0,1.0) * Nb.y;\n    \n    return c0 + c1 + c2;\n}\n\n//Phong shading\nvec3 BlinnPhong(vec3 E, vec3 P, vec3 N)\n{   \n    // Light position\n    vec3 LP = vec3(0.0, 0.0, 6.0);    \n    mat3 rot = fromEuler( vec3(0.0, iTime*0.5, iTime*0.5) );\n    LP = rot * LP;\n \n    // Material\n    //vec3 D = vec3(1.0,0.0,0.0);\n    vec3 D = textureTriPlanar(P,N).rgb;\n    \n    vec3 S = vec3(0.8,0.8,0.8);\n    vec3 A = D * 0.8;\n    float Shininess = 128.0;\n    \n    // Phong\n    vec3 L = normalize(LP-P);\n    vec3 V = normalize(E-P);\n    vec3 H = normalize(L+V);\n    float NDotL = clamp(dot(N,L),0.0,1.0);      \n    float NDotH = clamp(dot(N,H),0.0,1.0);   \n    return D * NDotL + pow( NDotH, Shininess ) + A;    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{       \n    vec3 E = vec3(0.0, 0.0, 15.0);\n    Ray ray = sdRay(E, fragCoord.xy, iResolution.xy, PI_4);\n    \n    //mat3 rot = fromEuler( vec3(0.0, iTime, iTime) );\n    //ray.origin = rot * ray.origin;\n    //ray.direction = rot * ray.direction;\n    \n        \n    vec3 color = vec3(0.0);\n    float d = sdRayMarching( ray, MIN_DIST, MAX_DIST);\n    if(d < MAX_DIST)\n    {\n        vec3 P = ray.origin + ray.direction * d;\n        vec3 N = sdSceneNormal(P);\n        \n        // Apply Light\n        color += BlinnPhong(E,P,N);\n        \n        //color += textureTriPlanar(P,N).rgb;\n    }\n    else\n    {\n        // No intersection\n        color = vec3(0.3,0.3,0.3);\n    }\n    \n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lslBWj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lslBzX", "name": "Electric and digital wave", "author": "Torumu106", "description": "I drew check and hid most of them.", "tags": ["shader", "digital"], "likes": 4, "viewed": 170, "date": "1497340239", "time_retrieved": "2024-06-20T18:56:21.006763", "image_code": "bool wave(vec2 r, float box, float width, float wavewidth, float Time){\n\tif(mod(r.x + width / 2.0, box) <= width || mod(r.y + width / 2.0, box) <= width){\n        float dis = abs(r.x) + abs(r.y);\n        if(dis <= Time  / 1.0 + wavewidth && dis >= Time / 1.0){\n    \t\treturn true;\n        }\n    }\n    return false;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float GlobalTime = mod(iTime, 13.5);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 r = 2.0 * vec2(uv.x - 0.5, uv.y - 0.5);\n    r.x *= iResolution.x / iResolution.y;\n    vec3 ret = vec3(0.1);\n    vec3 col = vec3(0.5, 0.7, 1.0);\n    float box = 0.5;\n    float width = 0.05;\n    float wavewidth = 0.05;\n    if(mod(r.x + width / 2.0, box) <= width || mod(r.y + width / 2.0, box) <= width){\n        float dis = abs(r.x) + abs(r.y);\n        if(dis <= GlobalTime * 1.0  / 1.0 + wavewidth && dis >= GlobalTime * 1.0 / 1.0){\n    \t\tret = col;\n        }\n    }\n    vec2 r1 = r - vec2(0.8);\n    if(wave(r1, box, width, wavewidth, (GlobalTime - 2.0) * 1.5))\n        ret = col;\n    \n    vec2 r2 = r - vec2(-0.5);\n    if(wave(r2, box, width, wavewidth, (GlobalTime - 3.0) * 1.0))\n        ret = col;\n    \n    vec2 r3 = r - vec2(1.0, -0.3);\n    if(wave(r3, box, width, wavewidth, (GlobalTime - 4.0) * 1.4))\n        ret = col;\n    \n    vec2 r4 = r - vec2(-1.2, 0.8);\n    if(wave(r4, box, width, wavewidth, (GlobalTime - 4.0) * 0.8))\n        ret = col;\n    \n    vec2 r5 = r - vec2(0.2, -0.8);\n    if(wave(r5, box, width, wavewidth, (GlobalTime - 6.0) * 1.2))\n        ret = col;\n    \n    vec2 r6 = r - vec2(-1.0, 0.6);\n    if(wave(r6, box, width, wavewidth, (GlobalTime - 7.0) * 1.1))\n        ret = col;\n    \n    vec2 r7 = r;\n    if(wave(r7, box / 1.2, width * 1.2, wavewidth * 1.5, (GlobalTime - 9.0) * 0.7))\n        ret = col;\n    \n\tfragColor = vec4(ret,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lslBzX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lslfDj", "name": "interferingPendulum", "author": "Emil", "description": "Just trial and error", "tags": ["2d", "wave", "sin", "chaos"], "likes": 10, "viewed": 152, "date": "1498256540", "time_retrieved": "2024-06-20T18:56:21.006763", "image_code": "#define pendulum(freq) (length(((u-iResolution.xy*0.5)*0.12)-vec2(0.,6.*sin(freq*iTime))))\n#define loop(offset, color) for (int i = -3; i<3; i++){ o += sin(pendulum(20.2*float(i)+offset))*color; u.x += 90.;}\nvoid mainImage( out vec4 o, in vec2 u ) {u = trunc(u*0.15)*1./0.15; u-=vec2(2.5*90.,0.); loop(.6, vec4(.6*u.y/iResolution.y,.25,.6*u.x/iResolution.x,1.)) o = abs(o);}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lslfDj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lslfDS", "name": "voronoi weave", "author": "public_int_i", "description": "voronoi weave", "tags": ["voronoi", "weave"], "likes": 12, "viewed": 513, "date": "1498130940", "time_retrieved": "2024-06-20T18:56:21.012602", "image_code": "void mainImage( out vec4 o, vec2 u )\n{\n    #define l(i) length(fract(u*.01+fract(i*vec2(1,8))+cos(u.yx*fract(iTime*.01)*.2+i*8.))-.5)\n\to += min(l(.6),l(.1))*1.66-o;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lslfDS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lslfR2", "name": "31/100", "author": "yahe", "description": "Cellular Noise", "tags": ["noise"], "likes": 2, "viewed": 420, "date": "1497080289", "time_retrieved": "2024-06-20T18:56:21.012858", "image_code": "vec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n    vec3 color = vec3(.3+sin(iTime/5.), .1 + cos(iTime/7.), .3 + cos(iTime/2.));\n    \n    // Scale \n    st *= 10.;\n    \n    // Tile the space\n    vec2 i_st = floor(st);\n    vec2 f_st = fract(st);\n\n    float m_dist = 1.;  // minimun distance\n    \n    for (int y= -1; y <= 1; y++) {\n        for (int x= -1; x <= 1; x++) {\n            // Neighbor place in the grid\n            vec2 neighbor = vec2(float(x),float(y));\n            \n            // Random position from current + neighbor place in the grid\n            vec2 point = random2(i_st + neighbor);\n\n\t\t\t// Animate the point\n            point = 0.5 + 0.5*sin(iTime + 6.2831*point);\n            \n\t\t\t// Vector between the pixel and the point\n            vec2 diff = neighbor + point;\n            \n            // Distance to the point\n            float dist = length(diff);\n\n            // Keep the closer distance\n            m_dist = min(m_dist, dist);\n        }\n    }\n\n    // Draw the min distance (distance field)\n    color += m_dist;\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lslfR2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lslfRl", "name": "mix partial circle inversion", "author": "ollj", "description": "circle inversion playground\ncontains a a simpler sub-set of what is being done in\nhttps://www.shadertoy.com/view/4dXfzs\n\nillustrates potential for similar shapes.", "tags": ["circle", "inversion"], "likes": 3, "viewed": 415, "date": "1497623414", "time_retrieved": "2024-06-20T18:56:21.255231", "image_code": "#define camLens 6.\n#define frame(u) camLens*(u-.5*iResolution.xy)/iResolution.y \n\n//case a; only inside  of unit circle gets inverted on unit circle.\n//case a; only outside of unit circle gets inverted on unit circle.\n//2 cases get mixed by mix(a,b,mixRatio);\n#define mixRatio sin(iTime)*.5+.5\n//#define mixRatio 0.\n//#define mixRatio 1.\n//#define mixRatio -1.\n//#define mixRatio 2.\n\n//return polar of carthesian [.x]distance [.y]angle\nvec2 c2p(vec2 u){return vec2(length(u),atan(u.y,u.x));}\n//return carthesian of polar [.x]distance [.y]angle\nvec2 p2c(vec2 u){return vec2(u.x*cos(u.y),u.x*sin(u.y));}\n\nvoid mainImage( out vec4 O, in vec2 U ){\n\tvec2 u = frame(U);\n    u.x+=sin(iTime);\n    u.y+=cos(iTime);\n    u=c2p(u);\n    float f,g;\n    vec2 a=u;if(a.x<1.)a.x=1./a.x;//if(inside unit circle)  do circle inversion\n    vec2 b=u;if(b.x>1.)b.x=1./b.x;//if(outside unit circle) do circle inversion\n    u=mix(a,b,mixRatio);\n    u=p2c(u);\n    \n    u.x-=sin(iTime);\n    u.y-=cos(iTime);\n    u=fract(u*camLens);\n    u.x*=.5;\n    vec3 c=u.x*vec3(2,2,0)+u.y*vec3(1,0,1);\n    //BlackredBluePurple->BlackYellowCyanWhite == more contrast on lcd or oled.\n    O = vec4(c,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lslfRl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lslfWf", "name": "SimpleMengerSponge ", "author": "YUII", "description": "", "tags": ["raymarch", "raytrace", "mengersponge"], "likes": 2, "viewed": 100, "date": "1498632838", "time_retrieved": "2024-06-20T18:56:23.934066", "image_code": "\n/*\n \n\n */\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n//const float EPSILON = 0.1;\n/**\n * Rotation matrix around the X axis.\n */\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n                vec3(1, 0, 0),\n                vec3(0, c, -s),\n                vec3(0, s, c)\n                );\n}\n\n/**\n * Rotation matrix around the Y axis.\n */\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n                vec3(c, 0, s),\n                vec3(0, 1, 0),\n                vec3(-s, 0, c)\n                );\n}\n\n/**\n * Rotation matrix around the Z axis.\n */\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n                vec3(c, -s, 0),\n                vec3(s, c, 0),\n                vec3(0, 0, 1)\n                );\n}\n\n\n/**\n * Constructive solid geometry intersection operation on SDF-calculated distances.\n */\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n/**\n * Constructive solid geometry union operation on SDF-calculated distances.\n */\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\n/**\n * Constructive solid geometry difference operation on SDF-calculated distances.\n */\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n/**\n * Signed distance function for a cube centered at the origin\n * with width = height = length = 2.0\n */\nfloat cubeSDF(vec3 p) {\n    // If d.x < 0, then -1 < p.x < 1, and same logic applies to p.y, p.z\n    // So if all components of d are negative, then p is inside the unit cube\n    vec3 d = abs(p) - vec3(1.0, 1.0, 1.0);\n    \n    // Assuming p is inside the cube, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    \n    // Assuming p is outside the cube, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\nfloat cubeSDF(vec3 p,float w) {\n    // If d.x < 0, then -1 < p.x < 1, and same logic applies to p.y, p.z\n    // So if all components of d are negative, then p is inside the unit cube\n    vec3 d = abs(p) - vec3(w, w, w);\n    \n    // Assuming p is inside the cube, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    \n    // Assuming p is outside the cube, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\n/**\n * Signed distance function for a sphere centered at the origin with radius 1.0;\n */\nfloat sphereSDF(vec3 p) {\n    return length(p) - 1.0;\n}\n\nfloat sphereSDF(vec3 p,float r) {\n    return length(p) - r;\n}\n\n\nfloat distTorus( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\n\nfloat cylinderSDF(vec3 p, float h, float r) {\n    // How far inside or outside the cylinder the point is, radially\n    float inOutRadius = length(p.xy) - r;\n    \n    // How far inside or outside the cylinder is, axially aligned with the cylinder\n    float inOutHeight = abs(p.z) - h/2.0;\n    \n    // Assuming p is inside the cylinder, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(inOutRadius, inOutHeight), 0.0);\n    \n    // Assuming p is outside the cylinder, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(vec2(inOutRadius, inOutHeight), 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n\nfloat toSphere(in vec3 p){\n//    p = rotate_y(p,-time*0.5);\n    p.y += 0.2;\n    return length(pow(abs(p),vec3(.7,0.68,0.4)))-1.5;\n    //you can try this another DE vertion\n    //return length(pow(abs(p),vec3(.7,0.68,0.4))-vec3(.6,0.35,0.4))-1.;\n}\n\n\nfloat smin( float a, float b, float k){\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n    \n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) +\n    length(max(d,0.0));\n}\n\n//for fractals\nfloat sdCross( in vec3 p)\n{\n    float v = 1.0;\n    float da = sdBox(p.xyz,vec3(1000.0, v, v));\n    float db = sdBox(p.yzx,vec3(v, 1000.0, v));\n    float dc = sdBox(p.zxy,vec3(v, v, 1000.0));\n    return min(da,min(db,dc));\n}\n\n\n//Menger Sponge Fractal\nfloat disEstimator(vec3 pt)\n{\n    float dis = sdBox(pt, vec3(1.0));\n   \tfloat s = 1.0;\n    float fact = 3.0;\n    \n    for( int m=0; m<3; m++ )\n   \t{\n//       s *= fact;\n        //        vec3 a = mod( pt*s, 2.0 )-1.0;\n//        vec3 a = mod( pt*s, 3.0 )-1.5;\n        \n//        vec3 r =  fact - fact*abs(a);\n//        float c = sdCross(a*fact)/fact;\n//        dis = max(dis,-c);\n//        dis +c;\n        \n        \n        \n//        vec3 q = pt*s;//  mod( pt*s, 3.0 )-1.5;\n        vec3 a =  mod( pt*s, 2.0 )-1.0;\n\n        s *= fact;\n        vec3 r = 3.0-3.0*abs(a);\n        float c = sdCross(r)/s;\n        dis = max(dis,-c);\n   \t}\n    \n    return dis;\n}\n\n\nfloat sdPlane( vec3 p, vec4 n ) {\n    return dot( p, n.xyz ) + n.w;\n}\n\n/**\n * Signed distance function describing the scene.\n *\n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint) {\n\n    \n   float dist = disEstimator(samplePoint);\n\n    return dist;\n}\n\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n *\n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        \n//         dist = floor(dist*10.+0.5)/10.;\n        \n        if (dist < EPSILON) {\n            return depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n *\n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n                          sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n                          sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n                          sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n                          ));\n}\n\n\n\nconst bool USE_BRANCHLESS_DDA = true;\n\n\n\nbool raymarch( vec3 eye, vec3 marchingDirection, out vec3 hitPos, out vec3 hitNrm )\n{\n    //    const int maxSteps = 128;\n    //    const float hitThreshold = 0.0001;\n    \n    bool hit = false;\n    hitPos = eye;\n    float depth = MIN_DIST;\n    vec3 pos = eye;//MIN_DIST, MAX_DIST\n    \n    for ( int i = 0; i < MAX_MARCHING_STEPS; i++ )\n    {\n        float d = sceneSDF( pos );\n       \n        if ( d < EPSILON )\n        {\n            hit = true;\n            hitPos = pos;\n            pos += d * marchingDirection;\n            \n            hitNrm = estimateNormal(  pos);\n            break;\n        }\n        \n        depth += d;\n        if (depth >= MAX_DIST) {\n            return hit;\n        }\n        \n        pos += d * marchingDirection;\n    }\n    return hit;\n}\n\n\nfloat shadowSoft( vec3 ro, vec3 rd, float mint, float maxt, float k )\n{\n    float t = mint;\n    float res = 1.0;\n    for ( int i = 0; i < 128; ++i )\n    {\n        float h = sceneSDF( ro + rd * t );\n        if ( h < EPSILON )\n            return 0.0;\n        \n        res = min( res, k * h / t );\n        t += h;\n        \n        if ( t > maxt )\n            break;\n    }\n    return res;\n}\n\nvec3 shade( vec3 pos, vec3 nrm, vec4 light )\n{\n    vec3 toLight = light.xyz - pos;\n    \n    float toLightLen = length( toLight );\n    toLight = normalize( toLight );\n    \n    float comb = 0.1;\n    //float vis = shadow( pos, toLight, 0.01, toLightLen );\n    float vis = shadowSoft( pos, toLight, 0.0625, toLightLen, 8.0 );\n    \n    if ( vis > 0.0 )\n    {\n        float diff = 2.0 * max( 0.0, dot( nrm, toLight ) );\n        float attn = 1.0 - pow( min( 1.0, toLightLen / light.w ), 2.0 );\n        comb += diff * attn * vis;\n    }\n    \n    return vec3( comb, comb, comb );\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n *\n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    }\n    \n    vec3 KD = k_d;//vec3(abs(sin(p)));\n//     vec3 KD = vec3(abs(sin(p)));\n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (KD * dotLN);\n    }\n    return lightIntensity * (KD * dotLN + k_s * pow(dotRV, alpha));\n}\n\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity,vec3 N) {\n//    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    }\n    \n    vec3 KD = k_d;//vec3(abs(sin(p)));\n//    vec3 KD = vec3(abs(sin(p)));\n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (KD * dotLN);\n    }\n    return lightIntensity * (KD * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n *\n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phong(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,vec4 light) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(light.xyz);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);\n    return color;\n}\n\n\nvec3 phong(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,vec4 light,vec3 N) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(light.xyz);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity,N);\n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n                vec4(s, 0.0),\n                vec4(u, 0.0),\n                vec4(-f, 0.0),\n                vec4(0.0, 0.0, 0.0, 1)\n                );\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n   // float si = sign(sin(iTime));\n   // if(si>0.){\n   //      VoxelMainImage(fragColor,fragCoord);\n        \n    //    return ;\n    //}\n    \n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    //    vec3 eye = vec3(sin(iTime)*4., cos(iTime)*4., 7.0);\n    vec3 eye = vec3(sin(iTime)*4., 4., cos(iTime)*7.0);\n    //    vec3 eye = vec3(4., 4., 10.0);\n    \n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n            // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        return;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = vec3(0.2, 0.2, 0.2);\n    vec3 K_d = vec3(0.7, 0.2, 0.2);\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    vec4 light1 = vec4(4.0 * sin(iTime),\n                       2.0,\n                       4.0 * cos(iTime),10.);\n    \n    vec3 color = phong(K_a, K_d, K_s, shininess, p, eye,light1);\n    \n    fragColor = vec4(color, 1.0);\n\n    vec3 sceneWsPos;\n    vec3 sceneWsNrm;\n    if ( raymarch( eye, worldDir, sceneWsPos, sceneWsNrm ) )\n    {\n        vec3 shade1 = shade( sceneWsPos, sceneWsNrm, light1 );\n        fragColor *= vec4( shade1, 1.0 );\n    }\n    else\n    {\n        fragColor *= vec4( 0.0, 0.0, 0.0, 1.0 );\n    }\n    \n}\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lslfWf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lssBD4", "name": "RGB Tunnel 2", "author": "kekwizard", "description": "...", "tags": ["tunnel", "rgb", "rotation", "morph"], "likes": 1, "viewed": 206, "date": "1496269342", "time_retrieved": "2024-06-20T18:56:23.934066", "image_code": "float time = 0.1;\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n\n\n mat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nfloat mixV(float a, float b, float d) {\n\treturn (d * a)+(1.0 - d)*b;\n}\n\nfloat map(vec3 p)\n{\n\n    vec3 q = p;\n\n    vec3 c = vec3(0.175);\n    p.z = mod(p.z,c.z)-0.5*c.z; // p.z -0.05 - 0.05\n\n    \n    vec3 p_s;\n    \n    p = p * rotationMatrix(vec3(0.0, 0.0, 1.0), (time * 0.4) + sin(time * 0.7));\n    \n    float bars = 1000.0;\n    \n    \n    const int sides = 16;//int(sin(iTime /6.0) * 5.0) + 5;\n    float angle = 3.1415 * 2.0 / float(sides);\n    \n    for ( int i = 0; i < sides; i ++)\n    {\n        \n        p_s = p * rotationMatrix(vec3(0.0, 0.0, 1.0), angle * float(i));\n        \n       \tp_s += vec3(sin(q.z) * cos(q.z * 1.2) * 2.0, sin(q.z) + 1.0, 0.0);\n        p_s += vec3(0.4 + .25 * sin(time * 0.2), 0.4 + .2 * sin(time * 0.3), 0.0);\n\n     \tvec3 boxdim = vec3(\n            0.075 + 0.02 *  sin(iTime / 5.7) , //* sin(length(p.xy * 20.0))* 0.2, \n            0.1, \n            0.05  + 0.05 * sin(iTime / 3.2));\n        \n        float boxValue = sdBox(p_s, boxdim);\n        //float torusValue = sdTorus(p_s, vec2(.1)) * 0.01;\n        \n        bars = min(bars, boxValue);  \n    }\n\n        \n    \n    float result = bars;   \n    return result;\n}\n\n\n\nvoid getCamPos(inout vec3 ro, inout vec3 rd)\n{\n    ro.z = time;\n    // ro.y -= sin(iTime) * .5;\n}\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n   \n    time = iTime * 1.5;\n    vec2 _p = (iResolution.xy - 2.0 * fragCoord.xy) / iResolution.y;\n    vec3 ray = normalize(vec3(_p, 1.0));\n    vec3 cam = vec3(0.0, 0.0, 0.0);\n    bool hit = false;\n    getCamPos(cam, ray);  \n    \n        \n    float depth = 0.0, d = 0.0, iter = 0.0;\n    vec3 p;\n    \n    for( int i = 0; i < 80; i ++)\n    {\n    \tp = depth * ray + cam;\n        d = map(p);\n                  \n        if (d < 0.0001) {\n\t\t\thit = true;\n            break;\n        }\n                   \n\t\tdepth += d * 0.25;\n\t\titer++;\n                   \n    }\n    \n    vec3 col = vec3(1.0 - iter / 80.0);\n    \n    const vec3 a = vec3(0.5, 0.5, 0.5);\n    const vec3 b = vec3(0.5, 0.5, 0.5);\n    const vec3 c = vec3(2., 1., 0.);\n    const vec3 da = vec3(0.5, 0.2, 0.25);\n\n    /*\n    const vec3 a = vec3(0.5, 0.5, 0.5);\n    const vec3 b = vec3(0.5, 0.5, 0.5);\n    const vec3 c = vec3(1., 1., 0.5);\n    const vec3 da = vec3(0.8, 0.9, 0.3);\n\t*/\n    \n    \n    vec3 sq = sqrt(col);\n    \n    vec3 gg = palette(sq.x * sq.y * sq.z, a, b, c, da);\n\n    fragColor = vec4(gg, 0.0);\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lssBD4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lssBDM", "name": "Bezier - Simpler Signed Distance", "author": "tomkh", "description": "Simpler/faster signed distance to quadratic bezier curve.\nBased on [url]https://www.shadertoy.com/view/ltXSDB[/url] by Adam Simmons.\n[url=http://polycu.be/edit/?h=cpcFVB]Polycu.be version[/url] with multiple segments and endpoint extension.", "tags": ["2d", "bezier", "distance", "parametrization"], "likes": 24, "viewed": 915, "date": "1496509042", "time_retrieved": "2024-06-20T18:56:24.855606", "image_code": "// Signed distance to quadratic bezier.\n// Tomasz Dobrowolski'2017 \n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// My own derivation:\n//   http://ricedit.com/roots_of_quadratic.png\n// with hand-wavy explanation why 3rd root is unnecessary.\n\n// Based on:\n// Signed Distance to a Quadratic Bezier Curve\n// - Adam Simmons (@adamjsimmons) 2015\n// https://www.shadertoy.com/view/ltXSDB\n\n// Enable endpoint extension? 0 = no\n#define ENDPOINTS 1\n\n// Solve cubic equation for roots\nvec3 solveCubic(float a, float b, float c)\n{\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) { \n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n#if ENDPOINTS == 0\n\n// Find the signed distance from a point to a bezier curve (simple version)\nvec3 sdBezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{   \n    // This is to prevent 3 colinear points, but there should be better solution to it.\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    \n    // Calculate roots.\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);      \n    vec2 t = clamp(solveCubic(k.x, k.y, k.z).xy, 0.0, 1.0);\n    // note: 3rd root is actually unnecessary, it's never closest!\n    \n    // [Tom'2017] simplified calculations\n    vec2 dp1 = d + (c + b*t.x)*t.x;\n    float d1 = dot(dp1, dp1);\n    vec2 dp2 = d + (c + b*t.y)*t.y;\n    float d2 = dot(dp2, dp2);\n   \n    // Find closest distance and t\n    vec4 r = (d1 < d2) ? vec4(d1, t.x, dp1) : vec4(d2, t.y, dp2);\n  \n    // Sign is just cross product with gradient\n    vec2 g = 2.*b*r.y + c;\n    float s =  sign(g.x*r.w - g.y*r.z);\n\n    float dist = sqrt(r.x);\n    return vec3(dist, s*dist, r.y);\n}\n\n#else\n\n// Find the signed distance from a point to a bezier curve with endpoint extension\nvec3 sdBezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{   \n    // This is to prevent 3 colinear points, but there should be better solution to it.\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    \n    // Calculate roots.\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);      \n    vec2 t = clamp(solveCubic(k.x, k.y, k.z).xy, 0.0, 1.0);\n    // note: 3rd root is actually unnecessary, it's never closest!\n    \n    // [Tom'2017] simplified calculations\n    vec2 dp1 = d + (c + b*t.x)*t.x;\n    float d1 = dot(dp1, dp1);\n    vec2 dp2 = d + (c + b*t.y)*t.y;\n    float d2 = dot(dp2, dp2);\n   \n    // Find closest distance and t\n    vec2 r = (d1 < d2) ? vec2(d1, t.x) : vec2(d2, t.y);\n   \n    // Find on which side (t=0 or t=1) is extension\n    vec2 e = vec2(step(0.,-r.y),step(1.,r.y));\n\n    // Calc. gradient\n    vec2 g = 2.*b*r.y + c;\n   \n    // Calc. extension to t\n    float et = (e.x*dot(-d,g) + e.y*dot(p-C,g))/dot(g,g);\n   \n    // Find closest point on curve with extension\n    vec2 dp = d + (c + b*r.y)*r.y + et*g;\n   \n    // Sign is just cross product with gradient\n    float s =  sign(g.x*dp.y - g.y*dp.x);\n   \n    return vec3(sqrt(r.x), s*length(dp), r.y + et);\n}\n\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    vec2 m = mix((2.0*iMouse.xy-iResolution.xy)/iResolution.y,\n        vec2(cos(iTime * 1.2) * 0.8, 0.0), step(iMouse.z, 0.0));\n    \n    // Define the control points of our curve\n    vec2 A = vec2(0.0, -0.6), C = vec2(0.0, +0.6), B = (4.0 * m - A - C) / 2.0;\n\n    // Get the signed distance to bezier curve\n    vec3 r = sdBezier(A, B, C, p);\n    \n    // Anti-alias factor\n    float ss = 1.5/iResolution.y;\n    \n    float d = r.x; // unsigned distance\n    float s = smoothstep(-ss,ss,r.y)*2. - 1.; // smooth sign\n\n    fragColor = vec4(.5) - .5*s*vec4(0.1,0.4,0.8,1.0);\n    fragColor *= fragColor; // to linear-space (for correct blending)\n    \n    fragColor += smoothstep(.8,1.,cos(140.*d))*.3;\n    \n    // Show AA curve.\n    fragColor = mix(fragColor, vec4(1.0), 1.0-smoothstep(0.01,0.01+ss,abs(d)) );\n    \n    // Show \"t\":\n \tfragColor += smoothstep(.9,1.,cos(140.*(r.z-.5)))*.3;\n    \n    // Render the control points\n    float pd = min(distance(p, A),(min(distance(p, m),distance(p, C))));\n    fragColor = mix(vec4(1.0 - smoothstep(0.03-ss, 0.03, pd)), \n                    fragColor, smoothstep(0.03, 0.04, pd));\n    \n    // Back to gamma-space\n    fragColor = sqrt(fragColor);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lssBDM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lssBRf", "name": "Threstle-raymarching-3", "author": "Threstle", "description": "Threstle-raymarching-3", "tags": ["threstleraymarching3"], "likes": 0, "viewed": 68, "date": "1497362705", "time_retrieved": "2024-06-20T18:56:25.625316", "image_code": "// formules courtesy of http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n\nfloat unite( float a, float b){return min(a, b);}\nfloat subtract( float a, float b ){ return max(-a, b); }\nfloat intersect( float a, float b ){ return max(a, b); }\nfloat sphere( vec3 p, float s ){return length(p)-s;}\n\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdHexPrism( vec3 p, vec2 h)\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\nfloat torus( vec3 p, vec2 t, float hole  )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  \n  return length(q)-(t.y/hole);\n}\n\nfloat displacement(vec3 p){\n    \n    return sin(10.0*p.x)*cos(10.0*p.y)*cos(10.0*p.z);\n}\n\nvec3 rotate(vec3 p,float angle, int axis){\n    mat3 rot;\n    \n    if(axis == 0)\n    {\n        rot[0] = vec3(1.0,0,0.0);\n        rot[1] = vec3(0.0,cos(angle),sin(angle));\n        rot[2] = vec3(0.0,-sin(angle),cos(angle));\n    }\n    else if(axis == 1)\n    {\n        rot[0] = vec3(cos(angle),0,-sin(angle));\n        rot[1] = vec3(0.0,1.0,0.0);\n        rot[2] = vec3(sin(angle),0.0,cos(angle));\n    }\n    else\n    {\n        rot[0] = vec3(cos(angle),sin(angle),0.0);\n        rot[1] = vec3(-sin(angle),cos(angle),0.0);\n        rot[2] = vec3(0.0,0.0,1.0);\n    }\n    \n    return p * rot;\n\n}\n\nfloat sdf(vec3 p){\n\n    \n    //float t = torus(vec3(p),vec2(1.0));\n    float t = torus(rotate(p,iTime/10.0,0),vec2(1.5),8.0);\n    float t2 = torus(rotate(p,iTime*2.0,2),vec2(1.0),8.0);\n    float t3 = torus(rotate(p,iTime*4.0,1),vec2(1.0),8.0);\n    float t4 = torus(rotate(p,iTime/4.0,2),vec2(2.0),20.0);\n    float t5 = torus(rotate(p,iTime/1.0,2),vec2(2.5),20.0);\n    //float s = sphere(vec3(0.2),0.3);\n    \n    //float s = sphere(vec3(p),1.0);\n    //float d = displacement(vec3(t));\n    \n    //float d = subtract(t,s);\n    \n \n    return sin(t*t2*t3*t4*t5);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //1 : retrieve the fragment's coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy *2.0 - 1.0; // center the scene\n    \n    uv.x *= iResolution.x / iResolution.y;\n    \n    //2 : camera position and ray direction\n\tvec3 pos = vec3( 0.,0.,-3.5);\n    \n    //pos.x = (pos.x*cos(iTime*0.1) - pos.y*sin(iTime*0.1));\n    //pos.y = (pos.x*sin(iTime*0.1) + pos.y*cos(iTime*0.1));\n    \n    float angle = iTime*1.0;\n        \n    \n    \n    // rotation sur soi mme\n    mat3 rot;\n    rot[0] = vec3(cos(angle),0.0,-sin(angle));\n    rot[1] = vec3(0.0,1.0,0.0);\n    rot[2] = vec3(-sin(angle),0.0,cos(angle));\n    \n   \n    \n    \n   // pos = pos * rot;\n    \n\tvec3 dir = normalize( vec3( uv, 1. ) );\n    \n    //3 : ray march loop\n    //ip will store where the ray hits the surface\n    \n    vec3 ip;\n    \n    //variable step size\n    float t = 1.1;\n    \n    for(int i = 0; i < 32; i++){\n     \t\n        // update position along path\n        ip = pos + dir * t;\n        \n        // gets the shortest distance to the scene\n        float temp = sdf(ip);\n        \n        if(temp < 0.4)temp = 0.4;\n        else temp = 0.0;\n        //break the loop if the distance was too small\n        // this means that we are close enough to the surface\n        if(temp < 0.01) break;\n            \n        // increment the step along the ray path\n         t+= temp;\n        \n    }\n    \n    // 4 : apply color to this fragment\n    fragColor = vec4(0.5,ip.z/4.0,0.0,.5);\n\t//fragColor = vec4(vec3(ip.x*clamp(sin(iTime),0.5,1.0),ip.y*clamp(sin(iTime),0.5,1.0),ip.z*clamp(sin(iTime),0.5,1.0)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lssBRf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lssBWN", "name": "SingleFlower", "author": "misspurple", "description": "Messing around creating a flower shape.", "tags": ["flower"], "likes": 0, "viewed": 70, "date": "1496274620", "time_retrieved": "2024-06-20T18:56:25.625316", "image_code": "const float epsilon = 0.01;\nconst float pi = radians(180.);\nconst float two_pi = pi * 2.;\nconst float leaves = 5.;\n\nbool singleTest(vec2 point, vec2 center, float size, out float brightness)\n{\n    vec2 offset = point - center;\n    float dist = length(offset);\n    if (dist < epsilon)\n    {\n     \tbrightness = 1.5;\n    \treturn true;\n    }\n   \tfloat prop_y = dist/size;\n    if (prop_y > 1.)\n    {\n        brightness = 0.;\n        return false;\n    }\n    \n    \n    float angle = atan(offset.x, offset.y) + iTime;\n    \n    float prop_x = mod(((angle / two_pi) * leaves) + 0.5, 1.);\n    float from_mid = abs(prop_x - 0.5) * 2.;\n    float from_apex = from_mid - 0.2;\n    float threshold = max(\n    \t\t\t\t\t\t1. - 4. * from_mid,\n    \t\t\t\t\t\t1. - 0.6*(from_apex * from_apex) \n    \t\t\t\t\t);\n    \n    \n    brightness = max(1.,\n                     max( 2.0 - 8. * prop_y,\n                         max(\n                         0.3 + 0.5 * prop_y,\n                         1.5 - 8.*from_mid)));\n    return prop_y < threshold;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 center = iResolution.xy / 2.;\n    float radius = min(iResolution.x, iResolution.y) / 2.;\n    \n    float brightness = 0.;\n    bool in_area = singleTest(fragCoord, center, radius, brightness);\n    if (in_area)\n    {\n\t\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0) * brightness;\n    }\n        \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lssBWN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lssfDj", "name": "Code training 02", "author": "antonOTI", "description": "Training  my shader fu.\nafter some duel with Ponk and Koltes, I wanted to keep toying with Bonzomatic, this is the result ", "tags": ["raymarching", "training", "shaderdojo"], "likes": 4, "viewed": 492, "date": "1498261548", "time_retrieved": "2024-06-20T18:56:25.625316", "image_code": "vec2 rot(vec2 v, float a)\n{\n\tfloat sa = sin(a);float ca = cos(a);\n\treturn mat2(ca,-sa,sa,ca) * v;\n}\n\nfloat map(vec3 pos)\n{\n  vec3 p = pos;\n  \n  p.xy = rot(p.xy,p.z * .03);\n\n  p = mod(p ,vec3(10.)) - 5.;\n  \n  \n  float time = iTime - pow(pos.z * .05,2.) ;// iTime + pow(pos.z,.5);\n\n  float f1 = distance(p.xy, vec2(0.+ cos(time),2. + sin(time))) - 1.2;\n  \n\n  return f1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1.);\n\n  vec3 ro = vec3(0.,0.,-5.); \n  vec3 rd = normalize(vec3(uv,1)); \n  vec3 cp = ro;\n  int STEP = 256;\n  int cs = 0;\n  float hit = 0.;\n  for(; cs < STEP; ++cs)\n  {\n    float d = map(cp);\n    if(d < .001)\n      {\n        hit = 1.;\n        break;\n      }\n    cp += rd * d * .25;\n  }\n\n  float f =  1. - distance(cp,ro) / 500.;\n    \n  f = f * sin((sin(cp.z * .03 + 10.)*.5+.5));\n\n  fragColor = vec4(f);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lssfDj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lssfRs", "name": "mandelbub", "author": "bpatmiller", "description": "the bub", "tags": ["fractal"], "likes": 1, "viewed": 125, "date": "1497652181", "time_retrieved": "2024-06-20T18:56:25.625316", "image_code": "float bailout = 8.0;\nfloat power = 8.0;\nint maxRaySteps =  60;\nfloat minimumStepDistance = 0.001;\nint iterations = 8;\nint maxIters = 8;\nfloat eps = 0.00001;\nfloat zoom = 2.0;\n\nvec3 camera = vec3(.0,2.0,-2.0);\nvec3 focus = vec3(0.0,0.0,0.0);\nvec3 light = vec3(0.0,0.0,5.0);\n\nfloat atan3(in float y, in float x) {\n    return x == 0.0 ? sign(y)*(1.5708) : atan(y, x);\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvec3 toRectangular(in vec3 sph) {\n    return vec3(sph.x*sin(sph.z)*cos(sph.y),\n             \tsph.x*sin(sph.z)*sin(sph.y),\n\t\t\t \tsph.x*cos(sph.z));\n}\n\nvec3 toSpherical(in vec3 rec) {\n\treturn vec3(length(rec),\n             \tatan3(rec.y,rec.x),\n            \tatan3(sqrt(rec.x*rec.x+rec.y*rec.y),rec.z));\n}\n\nfloat escape(in vec3 position) {\n\tvec3 z = position;\n    float r = 0.0;\n    float theta,phi,zr;\n    int i=0;\n    for(i=0;i<iterations;i++) {\n    \tr = length(z);\n        if(r>bailout) break;\n        \n        theta = power*atan3(sqrt(z.x*z.x+z.y*z.y),z.z);\n        phi = power*atan3(z.y,z.x);\n        zr = pow(r,power);\n\t\tz = vec3( zr*sin(theta)*cos(phi) + position.x,\n                  zr*sin(phi)*sin(theta) + position.y,\n                  zr*cos(theta) + position.z\t\t );\n    }\n    //return float(i) + log(log(r*r))/log(2.0) - log(log(dot(z,z)))/log(2.0);\n    return float(i);\n\n}\n\nfloat DE(in vec3 position) {\n\tvec3 z = position;\n    float dr = 1.0;\n    float r = 0.0;\n    float theta,phi,zr;\n    for(int i=0;i<iterations;i++) {\n    \tr = length(z);\n        if(r>bailout) break;\n        \n        theta = power*atan3(sqrt(z.x*z.x+z.y*z.y),z.z);\n        phi = power*atan3(z.y,z.x);\n        zr = pow(r,power);\n\t\tz = vec3( zr*sin(theta)*cos(phi) + position.x,\n                  zr*sin(phi)*sin(theta) + position.y,\n                  zr*cos(theta) + position.z\t\t );\n    \tdr = ( pow(r, power-1.0)*power*dr ) + 1.0;        \n    }\n    return 0.5*log(r)*r/dr;\n}\n\nvec3 normalOf(in vec3 pos) {\n\treturn normalize(vec3(DE(pos + vec3(eps,0,0))-DE(pos-vec3(eps,0,0)),\n\t\t                DE(pos+vec3(0,eps,0))-DE(pos-vec3(0,eps,0)),\n\t\t                DE(pos+vec3(0,0,eps))-DE(pos-vec3(0,0,eps))));    \n}\n\nfloat phong(in vec3 position) {\n\tvec3 k = (position - light) + (camera - light);\n    vec3 h = k/length(k);\n    return dot(h,normalOf(position));\n    \n}\n\nvec3 march(in vec3 from, in vec3 direction) {\n\tfloat totalDistance = 0.0;\n    float dist;\n    vec3 position;\n    int steps;\n    for (steps=0;steps<maxRaySteps;steps++) {\n        position = vec3(from.x + (direction.x*totalDistance),\n                        from.y + (direction.y*totalDistance),\n                        from.z + (direction.z*totalDistance));\n        dist=DE(position);\n        totalDistance+=dist;\n        if(totalDistance>25.0) return vec3(0,0,0);\n        if(dist<minimumStepDistance) break;\n\t}\n    return vec3(0.5+sin(escape(position)),\n        \t\t0.6,\n        \t\t0.7*(1.0-float(steps)/float(maxRaySteps)) + 0.3*phong(position) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    power = 6.0-4.0*cos(iTime*0.20) ;\n    /*camera = vec3(2.0*cos(iTime*0.05),\n                  2.0*sin(iTime*0.05),\n                  -2.0);*/\n    vec3 viewVector = vec3(focus.x-camera.x,focus.y-camera.y,focus.z-camera.z);\n    vec3 topVector = toSpherical(viewVector);\n    topVector.z += 1.5708;\n    topVector = toRectangular(topVector);\n    vec3 sideVector = cross(viewVector,topVector);\n    sideVector = normalize(sideVector)*length(topVector);\n    \n    //zoom=1.0-(iTime/50.0);\n    //maxRaySteps = 10+2*int(iTime);\n    //minimumStepDistance = ;\n    float dx = zoom*(fragCoord.x/iResolution.x - 0.5);\n    float dy = zoom*(fragCoord.y/iResolution.y - 0.5)*(iResolution.y/iResolution.x);\n\n    vec3 direction = (sideVector*dx) + (topVector*dy) + viewVector;\n    \n    direction = normalize(direction);\n    vec3 hsv = march(camera,direction)\t;\n\tfragColor = vec4(hsv2rgb(hsv),1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lssfRs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lssfW2", "name": "Playing with parametric curve", "author": "AngryBaguette", "description": "Playing with parametric curve", "tags": ["curve", "parametric"], "likes": 2, "viewed": 117, "date": "1498302166", "time_retrieved": "2024-06-20T18:56:25.625316", "image_code": "// Playing with parametric curve\nvec2 m,n;\n\nvec2 map(float t){//from iq's shader https://www.shadertoy.com/view/Xlf3zl\n\treturn 0.85*cos( (t+n) + vec2(0.0,1.0) )*(0.6+0.4*cos(t*(7.0)+m+vec2(0.0,1.0)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 p=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    \n    // Curve animation\n    m = cos( 0.42*iTime + vec2(2.0,0.0) );\n    n = cos( 0.61*iTime + vec2(3.0,1.0) );\n    \n    // Evaluate distance to the parametric function\n\tfloat t=0.0,d=length(p-map(t)),dt=0.001,d1=d;\n    for(int i=0;i<150;i++){\n        t+=0.2*d1;\n        d1=length(p-map(t));\n        d=min(d,d1);\n    }\n    \n    \n\t//d=smoothstep(0.0,0.01,d);   \n\tvec3 col=vec3(sqrt(d),d*d,d);    \n    float dn = col.x + col.y + col.z;\n    col /= dn;\n        \n\tfragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lssfW2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lssfW4", "name": "Dance of Dodecahedron", "author": "flewww", "description": "Docahedron dancing on rob hubbard's Warhawk", "tags": ["3d", "raymarching", "dodecahedron", "soundcloud", "505"], "likes": 6, "viewed": 724, "date": "1496270915", "time_retrieved": "2024-06-20T18:56:26.207064", "image_code": "// Source https://www.shadertoy.com/view/Xs3GRB\n#define PHI (1.618033988749895)\n\n// PHI (sqrt(5)*0.5 + 0.5)\n\n// \"Generalized Distance Functions\" by Akleman and Chen.\n// see the Paper at https://www.viz.tamu.edu/faculty/ergun/research/implicitmodeling/papers/sm99.pdf\n//\n// This set of constants is used to construct a large variety of geometric primitives.\n// Indices are shifted by 1 compared to the paper because we start counting at Zero.\n// Some of those are slow whenever a driver decides to not unroll the loop,\n// which seems to happen for fIcosahedron und fTruncatedIcosahedron on nvidia 350.12 at least.\n// Specialized implementations can well be faster in all cases.\n//\n\n// Macro based version for GLSL 1.2 / ES 2.0 by Tom\n#define GDFVector13 normalize(vec3(0, PHI, 1))\n#define GDFVector14 normalize(vec3(0, -PHI, 1))\n#define GDFVector15 normalize(vec3(1, 0, PHI))\n#define GDFVector16 normalize(vec3(-1, 0, PHI))\n#define GDFVector17 normalize(vec3(PHI, 1, 0))\n#define GDFVector18 normalize(vec3(-PHI, 1, 0))\n\n#define fGDFBegin float d = 0.;\n\n// Version with variable exponent.\n// This is slow and does not produce correct distances, but allows for bulging of objects.\n#define fGDFExp(v) d += pow(abs(dot(p, v)), e);\n\n// Version with without exponent, creates objects with sharp edges and flat faces\n#define fGDF(v) d = max(d, abs(dot(p, v)));\n\n#define fGDFExpEnd return pow(d, 1./e) - r;\n#define fGDFEnd return d - r;\n\n// Primitives follow:\n\nfloat fDodecahedron(vec3 p, float r, float e) {\n\tfGDFBegin\n    fGDFExp(GDFVector13) fGDFExp(GDFVector14) fGDFExp(GDFVector15) fGDFExp(GDFVector16)\n    fGDFExp(GDFVector17) fGDFExp(GDFVector18)\n    fGDFExpEnd\n}\n\nfloat fDodecahedron(vec3 p, float r) {\n    fGDFBegin\n    fGDF(GDFVector13) fGDF(GDFVector14) fGDF(GDFVector15) fGDF(GDFVector16)\n    fGDF(GDFVector17) fGDF(GDFVector18)\n    fGDFEnd\n}\n\n\n\n// Scene\n\nvec2 rotate(vec2 v, float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a))*v;\n}\n\nfloat mdist(vec3 pos) {\n    const float radius = 1.;\n    pos.xz = rotate(pos.xz, iTime);\n    pos.xy = rotate(pos.xy, 3.*texture(iChannel0,vec2(0.9,0.)).x);\n    return fDodecahedron(pos, radius, 48.);\n}\n\nvec3 march(vec3 pos, vec3 dir) {\n    for(int i=0; i<50; i++) {\n        float dst = mdist(pos);\n        if (dst < 0.0001) break;\n        pos += dir*dst;\n    }\n    return pos;\n}\n\n// Source: https://en.wikipedia.org/wiki/Phong_reflection_model\nfloat phong(vec3 light, vec3 surf, vec3 norm, vec3 cam) {\n    const float ks = 0.7;\n    const float kd = 0.2;\n    const float ka = 0.1;\n    const float al = 5.;\n    \n    vec3 lm = normalize(light - surf);\n    vec3 rm = reflect(-lm, norm);\n    vec3 v = normalize(cam - surf);\n    \n    float diff = kd*dot(lm,norm);\n    float spec = ks*pow(dot(rm,v), al);\n\treturn clamp(ka + max(diff, 0.) + max(spec, 0.), 0., 1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 buv = fragCoord.xy / iResolution.xy;\n    vec2 uv = 2.*buv - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // Camera setting (distance and FOV)\n    vec3 dr = normalize(vec3(uv, -3.));\n    vec3 og = vec3(0.,0.,5.);\n    vec3 lt = vec3(-1.,-1.,2.);\n    \n    vec3 pt = march(og, dr);\n    float ds = length(pt - og);\n\n    fragColor = vec4(0.,1.,0.,0.)*0.2*texture(iChannel0,vec2(buv.x,0.)).x;\n    if (ds < 100.) {\n        vec3 ptx = march(vec3(og.x+0.001,og.y,og.z), dr);\n    \tvec3 pty = march(vec3(og.x,og.y+0.001,og.z), dr);\n        if (length(ptx-og)<100. && length(pty-og)<100.) {\n    \t\tvec3 nrm = normalize(cross(ptx-pt, pty-pt));\n        \tfloat scl = phong(lt, pt, nrm, og);\n\t\tfragColor = vec4(scl,0.,scl,0.);   \n        }\n    }\n}\n", "image_inputs": [{"id": "MlsGRS", "previewfilepath": "https://soundcloud.com/c64com/warhawk?in=c64com/sets/robhubbard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/c64com/warhawk?in=c64com/sets/robhubbard", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lssfW4.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lssfWB", "name": "Strangler Fig", "author": "leon", "description": "Raymarching sketch about a plant named [b]Strangler Fig[/b] that grows around a tree host.  \nRecently saw in real life while traveling with friends in Thailand.  \nLook for pictures on internet, it does really amazing shapes.  \n", "tags": ["raymarching", "tree", "wood", "roots"], "likes": 60, "viewed": 1634, "date": "1498006511", "time_retrieved": "2024-06-20T18:56:26.909912", "image_code": "// Raymarching sketch about a plant named Strangler Fig that grows around a tree host.\n// Recently saw in real life while traveling with friends in Thailand.\n// Look for pictures on internet, it does really amazing shapes.\n// Leon 21 / 06 / 2017\n\n// using codes from iq, mercury, lj, koltes\n\n#define PI 3.14159\n#define TAU 2.*PI\n#define t iTime*.3\n#define wood1 vec3(0.658, 0.592, 0.529)\n#define wood2 vec3(0.415, 0.352, 0.290)\nstruct Infos { vec3 color; vec3 pos; float blend; };\nInfos infos;\nmat2 rot (float a) { float c=cos(a),s=sin(a);return mat2(c,-s,s,c); }\nfloat sphere (vec3 p, float r) { return length(p)-r; }\nfloat cyl (vec2 p, float r) { return length(p)-r; }\nfloat iso (vec3 p, float r) { return dot(p,normalize(sign(p)))-r; }\nfloat smin (float a, float b, float r) {\n    float h = clamp(.5+.5*(b-a)/r,0.,1.);\n    return mix(b,a,h)-r*h*(1.-h);\n}\nfloat scolor (float a, float b, float r) {\n    return clamp(.5+.5*(b-a)/r,0.,1.);\n}\nvec3 moda (vec2 p, float count) {\n    float an = TAU/count;\n    float a = atan(p.y,p.x)+an*.5;\n    float c = floor(a/an);\n    a = mod(a,an)-an*.5;\n    c = mix(c,abs(c),step(count*.5,abs(c)));\n    return vec3(vec2(cos(a),sin(a))*length(p),c);\n}\n\n// Martin Palko http://www.martinpalko.com/triplanar-mapping/\nvec3 triplanar(vec3 pos, vec3 normal, sampler2D channel, float uvscale) {\n    vec2 uvx = pos.yz*uvscale;\n    vec2 uvy = pos.xz*uvscale;\n    vec2 uvz = pos.xy*uvscale;\n    vec3 texx = texture(channel,uvx).rgb;\n    vec3 texy = texture(channel,uvy).rgb;\n    vec3 texz = texture(channel,uvz).rgb;\n    vec3 blends = abs(normal);\n    return texx*blends.x+texy*blends.y+texz*blends.z;\n}\n\nfloat map (vec3 p);\nvec3 normal (vec3 p) {\n    float e = .01;\n    return normalize(vec3(map(p+vec3(e,0,0))-map(p+vec3(-e,0,0)),\n                          map(p+vec3(0,e,0))-map(p+vec3(0,-e,0)),\n                          map(p+vec3(0,0,e))-map(p+vec3(0,0,-e))));\n}\nfloat luminance (vec3 c) { return (c.r+c.g+c.b)/3.; }\nvec3 camera (vec3 p) {\n    //p.xz *= rot(t);\n    //p.yz *= rot(t*1.5);\n    p.yz *= rot((PI*(iMouse.y/iResolution.y-.5)*step(0.5,iMouse.z)));\n    p.xz *= rot((PI*(iMouse.x/iResolution.x-.5)*step(0.5,iMouse.z)));\n    p.xz *= rot(0.5);\n    p.z += t;\n    return p;\n}\n\nfloat root (vec3 p, float count, float torsade, float width, float scale) {\n    p.xz *= rot(torsade);\n    vec3 p1 = moda(p.xz, count);\n    p1.x -= width+.2*sin(p1.z);\n    p.xz = p1.xy;\n    return cyl(p.xz, scale);\n}\n\nfloat map (vec3 p) {\n    \n    p = camera(p);\n    float treespace = 8.;\n    float treeindex = abs(floor(p.x/treespace)+floor(p.z/treespace));\n    p.xz = mod(p.xz,treespace)-treespace*.5;\n    \n    float blendRoots = .2;\n    float blendTrunk = .02;\n    float trunkWidth = 1.+.25*(.5+.5*sin(-p.y*.5+t*2.+treeindex*3.));\n    float hostTrunk = cyl(p.xz, trunkWidth);\n    \n    // fat\n    float seed1 = treeindex*4.+t+p.y*.25+sin(p.y*.2+t);\n    float seed2 = treeindex*3.+t+p.y*-.1+sin(p.y*.2+t);\n    float roots = root(p, 2.+mod(treeindex,6.), seed1, trunkWidth, .2);\n    roots = smin(roots, root(p, 2.+mod(treeindex,6.), seed2, trunkWidth+.1+sin(p.y*.3+t*3.+treeindex)*.3, .3), blendRoots);\n    // middle\n    float seed3 = treeindex*2.+3.*p.y*-.1+sin(-p.y*.2+t*2.);\n    float seed3b = treeindex*2.+.1*p.y+sin(-p.y*.2+t*2.);\n    roots = smin(roots, root(p, 3., seed3, trunkWidth+.1, .2), blendRoots);\n    roots = smin(roots, root(p, 6.+mod(treeindex,6.), seed3b, trunkWidth+.1, .2), blendRoots);\n    // thin\n    float seed4 = treeindex*8.+p.y*.5+sin(p.y*2.5+t*3.)*.2;\n    float seed5 = treeindex*4.+p.y*-.5+sin(p.y*1.5+t*5.)*.2;\n    roots = smin(roots, root(p, 8., seed4, trunkWidth+.1, .09), blendRoots);\n    roots = smin(roots, root(p, 6., seed5, trunkWidth+.2, .08), blendRoots);\n    \n    float scene = smin(roots, hostTrunk, blendTrunk);\n    infos.pos = p;\n    infos.blend = scolor(hostTrunk, roots, blendTrunk);\n    return scene;\n}\n\nvoid mainImage( out vec4 color, in vec2 coord )\n{\n\tvec2 uv = (coord.xy-.5*iResolution.xy)/iResolution.y;\n    vec3 eye = vec3(uv,0.), ray = normalize(vec3(uv,.5)), pos = eye;\n    int ri = 0;\n    for (int i = 0; i < 50; ++i) {\n        float dist = map(pos);\n        if (dist < 0.001) {\n            break;\n        }\n        pos += ray*dist;\n        ri = i;\n    }\n    float ratio = float(ri)/50.;\n    color.rgb = mix(wood1, wood2, infos.blend);\n    \n    vec3 n = normal(pos);\n    \n    vec3 tex = triplanar(pos, n, iChannel1,.09);\n    tex = mix(tex, triplanar(pos, n, iChannel0,0.5), infos.blend);\n    float lum = luminance(tex);\n    color.rgb *= smoothstep(-.5,1.,lum)*2.;\n    //color.rgb *= dot(-ray,n)*.5+.5;\n    //color.rgb = n*.5+.5;\n    color.rgb *= 1.-ratio;\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lssfWB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lssfzB", "name": "moving_camera", "author": "phuidn", "description": "testing a moving camera", "tags": ["raymarch", "camera", "matrix"], "likes": 4, "viewed": 91, "date": "1496926658", "time_retrieved": "2024-06-20T18:56:27.510333", "image_code": "#define EPS (0.0005)\n\nfloat sphereSDF(vec3 point, vec3 centre, float radius)\n{\n \treturn (length(centre - point) - radius);   \n}\n\nfloat cubeSDF(vec3 point, vec3 centre, float side_length)\n{\n    point -= centre;\n    float half_side = side_length * 0.5;\n    \n \treturn max(max(abs(point.x) - half_side, abs(point.y) - half_side),\n               abs(point.z) - half_side);\n}\n\nfloat sceneSDF(vec3 point)\n{\n    float dist;\n    float big_sphere_rad = 0.9,\n          small_sphere_rad = 0.3,\n          sphere_pos = 1.0 + 0.7 * sin(iTime);\n    \n    dist = cubeSDF(point, vec3(0,0,0), 2.0);\n    \n    dist = max(dist, -sphereSDF(point, vec3(sphere_pos,0,0), big_sphere_rad));\n    dist = max(dist, -sphereSDF(point, vec3(-sphere_pos,0,0), big_sphere_rad));\n    dist = max(dist, -sphereSDF(point, vec3(0, sphere_pos,0), big_sphere_rad));\n    dist = max(dist, -sphereSDF(point, vec3(0, -sphere_pos,0), big_sphere_rad));\n    dist = max(dist, -sphereSDF(point, vec3(0, 0, sphere_pos), big_sphere_rad));\n    dist = max(dist, -sphereSDF(point, vec3(0, 0, -sphere_pos), big_sphere_rad));\n\n    dist = min(dist, sphereSDF(point, vec3(sphere_pos,0,0), small_sphere_rad));\n    dist = min(dist, sphereSDF(point, vec3(-sphere_pos,0,0), small_sphere_rad));\n    dist = min(dist, sphereSDF(point, vec3(0, sphere_pos,0), small_sphere_rad));\n    dist = min(dist, sphereSDF(point, vec3(0, -sphere_pos,0), small_sphere_rad));\n    dist = min(dist, sphereSDF(point, vec3(0, 0, sphere_pos), small_sphere_rad));\n    dist = min(dist, sphereSDF(point, vec3(0, 0, -sphere_pos), small_sphere_rad));           \n    \n    return dist;\n}\n\nvec3 normalEstimate(vec3 point)\n{\n    vec3 dx = vec3(EPS, 0, 0),\n         dy = vec3(0, EPS, 0),\n         dz = vec3(0, 0, EPS);\n    \n \treturn normalize(vec3(sceneSDF(point + dx) - sceneSDF(point - dx),\n                          sceneSDF(point + dy) - sceneSDF(point - dy),\n                          sceneSDF(point + dz) - sceneSDF(point - dz)));\n}\n\n\nmat4 transformMat(vec3 position, vec3 lookAt, vec3 up)\n{\n    vec3 z_c = -normalize(lookAt - position),\n         x_c = normalize(cross(up, z_c)),\n         y_c = normalize(cross(z_c, x_c));\n    \n    return mat4( vec4(x_c, 0),\n                 vec4(y_c, 0),\n                 vec4(z_c, 0),\n                 vec4(position, 1) );\n}\n\nvec3 pathVector(float fov_angle, vec2 px_coord, vec3 resolution)\n{\n \tvec2 xy = (px_coord - 0.5 * resolution.xy);\n    float z = -resolution.x / (2.0 * tan(radians(fov_angle) * 0.5));\n\t\n    return normalize(vec3(xy, z));\n}\n\nfloat closestDistance(vec3 camera, vec3 rayVec, float minDist, float maxDist)\n{\n \tfloat dist,\n          totDist = minDist;\n    \n    int max_its = 300;\n    \n    for (int i = 0; i < max_its; i++)\n    {\n    \tdist = sceneSDF(camera + totDist * rayVec);\n        totDist += dist;\n        \n        if (totDist > maxDist)\n        {\n         \treturn maxDist;   \n        }\n        if (dist < EPS)\n        {\n         \treturn totDist;   \n        }\n    }\n    \n    return maxDist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float camera_rad = 6.0,\t\n          x = camera_rad * cos (0.5 * iTime),\n          z = camera_rad * sin (0.5 * iTime),\n          y = 0.0;\n    \n\tvec3 camera_pos =  vec3(x,y,z);\n    vec3 initial_path = pathVector(60.0, fragCoord, iResolution);\n    mat4 camera_to_world = transformMat(camera_pos, vec3(0), vec3(0,1,0));\n    \n    float minDist = 0.1,\n  \t\t  maxDist = 10.0;\n    \n    initial_path = (camera_to_world * vec4(initial_path,0)).xyz;\n    \n    float dist = closestDistance(camera_pos, initial_path, minDist, maxDist);\n    \n    if (dist > maxDist - EPS)\n    {\n     \tfragColor = vec4(0,0,0,0);   \n        return;\n    }\n    \n    vec3 scene_point = camera_pos + dist * initial_path;\n    \n    fragColor = vec4(0.5 * (normalEstimate(scene_point) + 1.0), 1.0);\n    \n\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lssfzB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lssfzs", "name": "underwater explosion", "author": "adambene", "description": "Underwater explosion with smoke.\nNewton's 2nd law with the drag equation.", "tags": ["explosion", "water", "underwater"], "likes": 3, "viewed": 313, "date": "1498051499", "time_retrieved": "2024-06-20T18:56:27.510333", "image_code": "#define cycle_interval 5.\n#define t mod(iTime, cycle_interval)\n#define SEED (float(int(iTime) / int(cycle_interval)) / 1000. + .012)\n#define PI 3.141592654\n\nconst float particles = 100.;\nconst float c = 50.; // drag coeff.\nconst float m = 2.; // particle mass\nconst float sqrt_c = sqrt(c);\nconst float sqrt_m = sqrt(m);\n\n// [0, 1)\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// x: [0, PI] -> [0, 1)\nfloat rand(float x){\n    return fract(sin(x) * 43758.5453);\n}\n\n// i: (-1, 1)\nvec2 randVec(float i) {\n    float phi = rand(SEED + i + .01) * PI * 2.,\n            r = rand(SEED - i + .02);\n\treturn vec2(cos(phi), sin(phi)) * r;\n}\n\nvec2 randVecRing(float i) {\n    return normalize(vec2(rand(SEED + i + .001) - .5, rand(SEED + i + .002) - .5));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y - vec2(iResolution.x / iResolution.y / 2., .5);\n    vec4 cl = vec4(0,0,.3,1);\n\n    for (float i = 0.; i < particles; i++) {\n        float seed = i / particles;\n        vec2 p0 = (randVec(seed)) / 10.;\n        vec2 v0 = (randVec(seed + .1)) * .8;\n        \n        vec2 p = p0 - v0 * 2. * sqrt_m * atan(sqrt_c * t / sqrt_m) / sqrt_c;\n\n        float d = smoothstep(.0, 1., 1. - clamp(7. * distance(uv, p), 0., 1.));\n\n        cl += .2 * vec4(1., .9, .5, 1) * mix(d, 0., t / cycle_interval);\n    }\n\n    for (float i = 0.; i < particles; i++) {\n        float seed = i / particles;\n        vec2 p0 = (randVec(seed)) / 50.;\n        vec2 v0 = (randVecRing(seed + .01)) * (.2*rand(seed + .02) + .7);\n        \n        vec2 p = p0 - v0 * 2. * sqrt_m * atan(sqrt_c * t / sqrt_m) / sqrt_c;\n\n        float d = smoothstep(.15, .0, distance(uv, p));\n\n        cl += mix(vec4(.7, .4, .0, 1) * d, -1. * vec4(.1, .1, .1, 1) * d, t / cycle_interval);\n        cl = mix(cl,vec4(.3, .3, .3, 1.), mix(d, 0., 1. - t / cycle_interval));\n    }\n\n    fragColor = cl;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lssfzs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsXBDl", "name": "Homework - Blinnphong Ligthning", "author": "MillhausVKodi", "description": "Blinnphong ", "tags": ["blinnphong"], "likes": 0, "viewed": 121, "date": "1498749295", "time_retrieved": "2024-06-20T18:56:29.213860", "image_code": "// TODO If you want to change from central to intermediate differences, do it here by commenting/uncommenting\n// the corresponding define\n#define USE_CENTRAL\n//#define USE_INTERMEDIATE\n\n// first three coordinates: position\n// w-component: radius\nconst vec4 sphere1 = vec4(0, 0, 0, 1);\nconst vec4 sphere2 = vec4(1, 1, 1, 1.5);\nconst vec4 sphere3 = vec4(1, 0, 3, 0.5);\n\n// density of objects\nconst float s1Dens = 0.015;\nconst float s2Dens = 0.02;\nconst float s3Dens = 0.03;\n\n// bounding box\nconst vec3 bbMin = vec3(-1.5, -1.5, -1.5);\nconst vec3 bbMax = vec3(2.5, 2.5, 3.5);\n\n// additional camera parameters\nconst float fovy = 45.0;\nconst float zNear = 0.1;\n\n// light direction\nconst vec3 lightDir = vec3(1.0, -1.0, -1.0);\n\nconst vec4 lightColor = vec4(1);\nconst vec4 specularColor = vec4(1);\nconst float ka = 0.5;  // ambient contribution\nconst float kd = 0.5;  // diffuse contribution\nconst float ks = 0.7;  // specular contribution\nconst float exponent = 50.0;  // specular exponent (shininess)\n\n// number of maximum raycasting samples per ray\nconst int sampleNum = 256;\n\n// width of one voxel\nconst float voxelWidth = 1.0 / 64.0;\n\n// epsilon for comparisons\nconst float EPS = 0.000001;\n\n/**\n *\tReturns whether a given point is inside a given sphere.\n *  \n * \t@param point The point that is tested against the sphere.\n * \t@param sphere The sphere parameters. xyz = position, w = radius\n *\t@return True, when the point is inside the sphere, false otherwise\n */\nbool isInSphere(vec3 point, vec4 sphere)\n{\n    vec3 spherePos = sphere.xyz;\n    \n    if(length(point - spherePos) <= sphere.w)\n        return true;\n    else\n        return false;\n}\n\n/**\n *\tReturns whether a given point is inside a given cube.\n *  \n * \t@param point The point that is tested against the cube.\n * \t@param cube The cube parameters. xyz = position, w = half of the cube width\n *\t@return True, when the point is inside the cube, false otherwise\n */\nbool isInCube(vec3 point, vec4 cube)\n{\n\tvec3 dist = abs(point.xyz - cube.xyz);\n    \n    if(all(lessThan(dist, vec3(cube.w))))\n        return true;\n    else return false;\n}\n\n/**\n *\tSamples the volume texture at a given position.\n *\n *\t@param volumeCoord The position one wants to retrieve the sample of (in world coordinates).\n *\t@return The sample value at the given position.\n */\nfloat sampleVolume(vec3 volumeCoord)\n{\n    bool in1 = isInCube(volumeCoord, sphere1);\n    bool in2 = isInCube(volumeCoord, sphere2);\n    bool in3 = isInSphere(volumeCoord, sphere3);\n    \n    float result = 0.0;\n    \n    if(in1)\n    \tresult += s1Dens;\n    \n    if(in2)\n        result += s2Dens;\n    \n    if(in3)\n        result += s3Dens;\n    \n    return result;\n}\n\n/**\n *\tEvaluates the transfer function for a given sample value\n * \t\n *\t@param value The sample value\n *\t@return The color for the given sample value\n */\nvec4 transferFunction(float value)\n{\n    if(value > EPS)\n    {\n    \tif(value > s1Dens + EPS)\n        {\n        \tif(value > s2Dens + EPS)\n            {   \n            \tif(value > s1Dens + s2Dens + EPS)\n                {\n                \treturn vec4(0, 0, 0, 1.0);\n                }\n                return vec4(1, 0, 0, 1.0);\n            }\n            return vec4(0, 1, 0,1.0);\n        }\n        return vec4(0, 0, 1, 1.0);\n    }\n    return vec4(0);\n}\n\n/**\n *\tIntersects a ray with the bounding box and returs the intersection points\n * \t\n * \t@param rayOrig The origin of the ray\n * \t@param rayDir The direction of the ray\n *  @param tNear OUT: The distance from the ray origin to the first intersection point\n *\t@param tFar OUT: The distance from the ray origin to the second intersection point\n *\t@return True if the ray intersects the bounding box, false otherwise.\n */\nbool intersectBoundingBox(vec3 rayOrig, vec3 rayDir, out float tNear, out float tFar)\n{\n\tvec3 invR = vec3(1.0) / rayDir;\n    vec3 tbot = invR * (bbMin - rayOrig);\n    vec3 ttop = invR * (bbMax - rayOrig);\n    \n    vec3 tmin = min(ttop, tbot);\n    vec3 tmax = max(ttop, tbot);\n    \n    float largestTMin = max(max(tmin.x, tmin.y), max(tmin.x, tmin.z));\n    float smallestTMax = min(min(tmax.x, tmax.y), min(tmax.x, tmax.z));\n    \n    tNear = largestTMin;\n    tFar = smallestTMax;\n    \n    return (smallestTMax > largestTMin);\n}\n\n/**\n *\tReturns the gradient at a given position using central differences\n *\t@param pos The postion from which the gradient should be determined\n *\t@return The gradient at pos.\n */\nvec3 gradientCentral(vec3 pos)\n{\n\tvec3 result;\n\tfloat offsetVal = voxelWidth;\n    \n    float valuexm1 = sampleVolume(pos+vec3(-offsetVal,0,0));\n    float valueym1 = sampleVolume(pos+vec3(0,-offsetVal,0));\n    float valuezm1 = sampleVolume(pos+vec3(0,0,-offsetVal));\n    \n    float valuex1 = sampleVolume(pos+vec3(offsetVal,0,0));\n    float valuey1 = sampleVolume(pos+vec3(0,offsetVal,0));\n    float valuez1 = sampleVolume(pos+vec3(0,0,offsetVal));\n    \n    result.x = (valuex1 - valuexm1)/2.0;\n    result.y = (valuey1 - valueym1)/2.0;\n    result.z = (valuez1 - valuezm1)/2.0;\n    return result;\n}\n\n/**\n *\tReturns the gradient at a given position using intermediate differences\n *\n *\t@param pos The postion from which the gradient should be determined\n *\t@return The gradient at pos.\n */\nvec3 gradientIntermediate(vec3 pos)\n{\n\t\n\tvec3 result;\n\t\n    float offsetVal = voxelWidth;\n    \n    float value0 = sampleVolume(pos);\n    float valuex1 = sampleVolume(pos+vec3(offsetVal,0,0));\n    float valuey1 = sampleVolume(pos+vec3(0,offsetVal,0));\n    float valuez1 = sampleVolume(pos+vec3(0,0,offsetVal));\n    \n    result.x = valuex1 - value0;\n    result.y = valuey1 - value0;\n    result.z = valuez1 - value0;\n    \n    return result;\n}\n\n/**\n *\tComputes the color of the lit surface of an object, using a global\n *\tdirectional light source.\n *\n *\t@param objColor The emission color of the object.\n *\t@param normal The surface normal at the position that should be lit.\n *\t@param eyeDir The direction from the surface to the camera position.\n *\t@return The color of the lit surface\n */\nvec4 lighting(vec4 objColor, vec3 normal, vec3 eyeDir)\n{\n    //normal = normalize(normal);\n    \n    vec3 l = lightDir*vec3(-1.0);\n    \n   \tfloat lambertian = max(dot(normalize(l),normal), 0.0);\n\n    \n    vec3 h  = normalize(eyeDir + l);\n    \n    \n    vec4 ambient = ka * lightColor;\n    vec4 diffuse = kd * lightColor * max(lambertian, 0.0);\n    vec4 specular= ks * lightColor * specularColor * pow(max( dot(normal, h) , 0.0 ), exponent);\n    \n\n    \n\tvec4 iOut = ambient + diffuse + specular;\n    \n    vec4 color = objColor*iOut ;\n    \n    color.w = objColor.w;\n    \n\n    return color;\n    \n\t\n    \n}\n\n/**\n *\tMain Function: \n *  Computes the color for the given fragment.\n *\n *\t@param fragColor OUT: The color of the pixel / fragment.\n *\t@param fragCoord The coordinate of the fragment in screen space\n */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n    \n    /******************** compute camera parameters ********************/\n    \n    // camera movement  \n    float camSpeed = 0.5;\n    vec3 camPos = 7.0 * vec3(cos(iTime*camSpeed), 0.5, sin(iTime*camSpeed));\n    vec3 camDir = -normalize(camPos);\n    vec3 camUp = vec3(0.0, 1.0, 0.0);\n    vec3 camRight = normalize(cross(camDir, camUp));\n    camUp = normalize(cross(camRight, camDir));\n    \n    /************ compute ray direction (OpenGL style) *****************/\n    vec2 myUV = 2.0 * uv - 1.0;\n    float fovx = 2.0 * atan(tan(fovy / 2.0) * aspect);\n    \n    vec3 uL = (tan(fovx*0.5)*zNear) * (-camRight) + (tan(fovy*0.5) * zNear) * camUp + camDir * zNear + camPos;\n    vec3 lL = (tan(fovx*0.5)*zNear) * (-camRight) + (tan(fovy*0.5) * zNear) * (-camUp) + camDir * zNear + camPos;\n    vec3 uR = (tan(fovx*0.5)*zNear) * camRight + (tan(fovy*0.5) * zNear) * camUp + camDir * zNear + camPos;\n    vec3 lR = (tan(fovx*0.5)*zNear) * camRight + (tan(fovy*0.5) * zNear) * (-camUp) + camDir * zNear + camPos;\n    \n    vec3 targetL = mix(lL, uL, uv.y);\n    vec3 targetR = mix(lR, uR, uv.y);\n    vec3 target = mix(targetL, targetR, uv.x);\n    \n    vec3 rayDir = normalize(target - camPos);\n    \n    /******************* test against bounding box ********************/\n    float tNear, tFar;\n    bool hit = intersectBoundingBox(camPos, rayDir, tNear, tFar);\n       vec4 background = vec4(1.0);\n    if(tNear < 0.0)\n        tNear = 0.0;\n    \n    if(!hit)\n    {\n        fragColor = background;\n        return;\n    }\n    \n    vec3 pos = camPos + rayDir * tNear;\n    float tstep = (bbMax.x - bbMin.x) / float(sampleNum);\n    vec4 finalColor = vec4(0);\n    vec3 finalGradient = vec3(0);\n    \n    /******************** main raycasting loop *******************/\n    for(int i = 0; i < sampleNum; i++)\n    {\n        if(finalColor.a > 0.99)\n            break; // early ray termination!\n    \tpos += tstep * rayDir;\n        float sampleValue = sampleVolume(pos);\n        vec4 color = transferFunction(sampleValue);\n\n        \n        #ifdef USE_INTERMEDIATE\n        vec3 grad = gradientIntermediate(pos);\n        #else\n        #ifdef USE_CENTRAL\n        vec3 grad = gradientCentral(pos);\n        #else\n        vec3 grad = vec3(0);\n        #endif // USE_CENTRAL\n        #endif // USE_INTERMEDIATE\n        \n    \n   \t /****************** lighting ********************************/  \n        {\n           finalGradient = grad;\n        }\n        color = lighting(color, -normalize(finalGradient), -rayDir);\n        // blending with pre-multiplied color!\n        color.rgb *= color.a;\n        finalColor += color * (1.0 - finalColor.w);\n    }\n    fragColor = finalColor * finalColor.a + (1.0 - finalColor.a) * background;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsXBDl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsXfDf", "name": "Shaded Horses", "author": "Ultraviolet", "description": "[WIP]\nAttempt to bring 3D into https://www.shadertoy.com/view/ldcGzS\nIf anyone knows how to blend normals from closest neighbors (like n1 and n2 at line 481) in order to achieve a smooth shading, I'd be glad ! (EDIT: see herehttps://www.shadertoy.com/vie)", "tags": ["3d", "escher", "tiling", "horse"], "likes": 28, "viewed": 344, "date": "1498551430", "time_retrieved": "2024-06-20T18:56:31.753066", "image_code": "const float M_PI = 3.1415972;\n\n// (half) contour\nconst vec2 vert[43] = vec2[](vec2(0,-0),\n                             vec2(-0.066934,0.073242), \n                             vec2(-0.096244,0.12762), \n                             vec2(-0.066934,0.22177), \n                             vec2(-0.056485,0.33263), \n                             vec2(0.094141,0.38494), \n                             vec2(0.19246,0.44143), \n                             vec2(0.11297,0.52929), \n                             vec2(-0.033483,0.56905), \n                             vec2(-0.056485,0.53974), \n                             vec2(0.043933,0.47909), \n                             vec2(-0.060658,0.40167), \n                             vec2(-0.16735,0.53557), \n                             vec2(-0.094141,0.65271), \n                             vec2(0.077416,0.67992), \n                             vec2(0.14435,0.83265), \n                             vec2(0.24477,0.95607), \n                             vec2(0.30963,1.0439), \n                             vec2(0.1548,1.0544), \n                             vec2(0.0,1), \n                             vec2(0.079487,1.09), \n                             vec2(0.014655,1.1422), \n                             vec2(0.03138,1.2531), \n                             vec2(0.16318,1.2803), \n                             vec2(0.24894,1.3096), \n                             vec2(0.3117,1.3159), \n                             vec2(0.32846,1.364), \n                             vec2(0.36819,1.318), \n                             vec2(0.4456,1.3054), \n                             vec2(0.61923,1.2824), \n                             vec2(0.61506,1.2197), \n                             vec2(0.66527,1.136), \n                             vec2(0.7092,1.092), \n                             vec2(0.70502,1.0649), \n                             vec2(0.63806,0.9749), \n                             vec2(0.48953,0.8452), \n                             vec2(0.4456,0.71758), \n                             vec2(0.54185,0.68409), \n                             vec2(0.64854,0.66319), \n                             vec2(0.62133,0.77196), \n                             vec2(0.74896,0.85775), \n                             vec2(0.88493,0.93096), \n                             vec2(1.0,1.0));\n\n\n// details (represented as 1 single contour for simplicity)\nconst vec2 det[197] = vec2[](\n                            vec2(0.90106,-0.082627),\n                            vec2(1.0248,0.0075632),\n                            vec2(0.90311,-0.079755),\n                            vec2(0.77286,-0.17864),\n                            vec2(0.68331,-0.25935),\n                            vec2(0.6938,-0.34666),\n                            vec2(0.65268,-0.33832),\n                            vec2(0.54527,-0.31598),\n                            vec2(0.44902,-0.28249),\n                            vec2(0.49295,-0.15487),\n                            vec2(0.55592,-0.10055),\n                            vec2(0.50339,-0.09118),\n                            vec2(0.55527,-0.10103),\n                            vec2(0.64418,-0.024416),\n                            vec2(0.51365,-0.01939),\n                            vec2(0.64148,-0.025166),\n                            vec2(0.70729,0.063619),\n                            vec2(0.52041,0.056996),\n                            vec2(0.70844,0.064794),\n                            vec2(0.71262,0.091974),\n                            vec2(0.66869,0.1359),\n                            vec2(0.52323,0.11563),\n                            vec2(0.66969,0.13964),\n                            vec2(0.61848,0.21959),\n                            vec2(0.51691,0.20233),\n                            vec2(0.61918,0.21823),\n                            vec2(0.62265,0.28235),\n                            vec2(0.44889,0.30528),\n                            vec2(0.51704,0.23839),\n                            vec2(0.5199,0.15744),\n                            vec2(0.52367,0.064497),\n                            vec2(0.51128,-0.050781),\n                            vec2(0.49314,-0.15332),\n                            vec2(0.51149,-0.05024),\n                            vec2(0.52346,0.064667),\n                            vec2(0.52052,0.15831),\n                            vec2(0.51594,0.23975),\n                            vec2(0.44902,0.30536),\n                            vec2(0.37142,0.31567),\n                            vec2(0.37547,0.28106),\n                            vec2(0.36137,0.26746),\n                            vec2(0.37519,0.28121),\n                            vec2(0.37161,0.31791),\n                            vec2(0.33188,0.36394),\n                            vec2(0.32632,0.34797),\n                            vec2(0.34413,0.31933),\n                            vec2(0.34757,0.2892),\n                            vec2(0.33379,0.26771),\n                            vec2(0.34748,0.29045),\n                            vec2(0.3442,0.32047),\n                            vec2(0.32571,0.34736),\n                            vec2(0.31512,0.31584),\n                            vec2(0.30578,0.28931),\n                            vec2(0.30406,0.26799),\n                            vec2(0.32059,0.22776),\n                            vec2(0.32034,0.21043),\n                            vec2(0.32035,0.22748),\n                            vec2(0.26329,0.23816),\n                            vec2(0.24109,0.26012),\n                            vec2(0.22483,0.24894),\n                            vec2(0.23993,0.25952),\n                            vec2(0.25707,0.27098),\n                            vec2(0.30386,0.26814),\n                            vec2(0.30433,0.28921),\n                            vec2(0.31554,0.31352),\n                            vec2(0.25236,0.30956),\n                            vec2(0.1666,0.28025),\n                            vec2(0.034805,0.25308),\n                            vec2(0.030179,0.22242),\n                            vec2(0.077108,0.22381),\n                            vec2(0.074181,0.2043),\n                            vec2(0.030134,0.22326),\n                            vec2(0.018075,0.14218),\n                            vec2(0.084837,0.089569),\n                            vec2(0.11915,0.097959),\n                            vec2(0.082915,0.089903),\n                            vec2(-0.0025677,-6.5609e-05),\n                            vec2(0.15822,0.054315),\n                            vec2(0.31362,0.043885),\n                            vec2(0.3884,0.07841),\n                            vec2(0.43726,0.15746),\n                            vec2(0.38916,0.079136),\n                            vec2(0.31305,0.043865),\n                            vec2(0.24819,-0.043995),\n                            vec2(0.14777,-0.16742),\n                            vec2(0.080888,-0.32135),\n                            vec2(0.074893,-0.36311),\n                            vec2(0.080845,-0.32015),\n                            vec2(-0.090715,-0.34736),\n                            vec2(-0.16393,-0.4645),\n                            vec2(-0.057235,-0.5984),\n                            vec2(0.047355,-0.52098),\n                            vec2(-0.0099704,-0.48725),\n                            vec2(-0.098806,-0.54886),\n                            vec2(-0.0094202,-0.48841),\n                            vec2(-0.055624,-0.46084),\n                            vec2(-0.099665,-0.4635),\n                            vec2(-0.055028,-0.46012),\n                            vec2(-0.035162,-0.43163),\n                            vec2(-0.042237,-0.39288),\n                            vec2(-0.033727,-0.43134),\n                            vec2(0.11639,-0.47077),\n                            vec2(0.19626,-0.55953),\n                            vec2(0.21725,-0.49512),\n                            vec2(0.19588,-0.55863),\n                            vec2(0.097565,-0.61512),\n                            vec2(-0.053055,-0.66743),\n                            vec2(-0.063505,-0.77829),\n                            vec2(-0.092815,-0.87244),\n                            vec2(-0.063505,-0.92682),\n                            vec2(0.0034248,-1.0038),\n                            vec2(0.082915,-0.91383),\n                            vec2(0.039776,-0.88191),\n                            vec2(-0.037953,-0.95721),\n                            vec2(0.040105,-0.8818),\n                            vec2(0.015333,-0.86276),\n                            vec2(-0.013385,-0.87653),\n                            vec2(0.015834,-0.8629),\n                            vec2(0.031838,-0.7511),\n                            vec2(0.0063407,-0.71769),\n                            vec2(0.031542,-0.75074),\n                            vec2(0.1666,-0.72348),\n                            vec2(0.25236,-0.69417),\n                            vec2(0.31512,-0.68789),\n                            vec2(0.34387,-0.57387),\n                            vec2(0.32896,-0.64211),\n                            vec2(0.37161,-0.68582),\n                            vec2(0.44902,-0.69837),\n                            vec2(0.623,-0.72085),\n                            vec2(0.66386,-0.65508),\n                            vec2(0.6213,-0.72581),\n                            vec2(0.61848,-0.78414),\n                            vec2(0.66869,-0.86783),\n                            vec2(0.71262,-0.91176),\n                            vec2(0.70844,-0.93894),\n                            vec2(0.64148,-1.0289),\n                            vec2(0.49295,-1.1586),\n                            vec2(0.44902,-1.2862),\n                            vec2(0.4925,-1.3022),\n                            vec2(0.51582,-1.2356),\n                            vec2(0.47125,-1.2109),\n                            vec2(0.51602,-1.2353),\n                            vec2(0.55933,-1.1526),\n                            vec2(0.70232,-1.0529),\n                            vec2(0.77397,-0.95581),\n                            vec2(0.71159,-0.91187),\n                            vec2(0.77337,-0.95437),\n                            vec2(0.7009,-1.0515),\n                            vec2(0.55852,-1.1528),\n                            vec2(0.51422,-1.2402),\n                            vec2(0.62801,-1.2606),\n                            vec2(0.51456,-1.2401),\n                            vec2(0.49324,-1.3029),\n                            vec2(0.54276,-1.3205),\n                            vec2(0.65196,-1.3406),\n                            vec2(0.62475,-1.2318),\n                            vec2(0.75238,-1.146),\n                            vec2(0.88835,-1.0728),\n                            vec2(1.0034,-1.0038),\n                            vec2(0.93723,-0.92682),\n                            vec2(0.90792,-0.87244),\n                            vec2(0.93723,-0.77829),\n                            vec2(0.94768,-0.66743),\n                            vec2(1.0983,-0.61512),\n                            vec2(1.1966,-0.55863),\n                            vec2(1.1171,-0.47077),\n                            vec2(1.0153,-0.44313),\n                            vec2(1.1081,-0.51535),\n                            vec2(1.0797,-0.56628),\n                            vec2(0.97079,-0.62794),\n                            vec2(1.0796,-0.5657),\n                            vec2(1.1076,-0.51499),\n                            vec2(1.0156,-0.44376),\n                            vec2(0.97068,-0.43101),\n                            vec2(0.94768,-0.46032),\n                            vec2(1.0481,-0.52097),\n                            vec2(0.9435,-0.59839),\n                            vec2(0.83681,-0.46449),\n                            vec2(0.75549,-0.50029),\n                            vec2(0.66622,-0.48935),\n                            vec2(0.75619,-0.4978),\n                            vec2(0.83779,-0.46475),\n                            vec2(0.90486,-0.34559),\n                            vec2(0.80353,-0.33633),\n                            vec2(0.91002,-0.34735),\n                            vec2(1.08,-0.31943),\n                            vec2(1.101,-0.27377),\n                            vec2(0.87067,-0.27214),\n                            vec2(1.0966,-0.2737),\n                            vec2(1.1446,-0.16405),\n                            vec2(0.97482,-0.16882),\n                            vec2(1.1485,-0.16741),\n                            vec2(1.2466,-0.042572),\n                            vec2(1.0354,-0.060845),\n                            vec2(1.2489,-0.043995),\n                            vec2(1.3138,0.043865),\n                            vec2(1.1545,0.054315));\n\n\n\n// tiles to explore for creating the base shape\nconst vec2 textureTiles[] = vec2[](vec2(0.0), \n                                   vec2(0.0, 1.0), \n                                   vec2(-1.0, 0.0), \n                                   vec2(-1.0, 1.0));\n\n// tiles to explore for creating the details\nconst vec2 detailTiles[5] = vec2[](vec2(0.0), \n                                   vec2(0.0,-1.0), \n                                   vec2(0.0,-2.0), \n                                   vec2(1.0,-1.0), \n                                   vec2(-1.0,-1.0));\n\nvec2 PointSegProj(vec2 p, vec2 p0, vec2 p1)\n{\n    vec2 d = p1 - p0;\n        \n    float t = clamp(dot(p - p0, d) / dot(d, d), 0.0, 1.0);\n\n    vec2 proj = (1.0-t)*p0 + t*p1;\n    \n    return proj;\n}\n\nfloat PointSegDistance2(vec2 p, vec2 p0, vec2 p1)\n{\n    vec2 d = p1 - p0;\n    \n    float t = clamp(dot(p - p0, d) / dot(d, d), 0.0, 1.0);\n\n    vec2 proj = (1.0-t)*p0 + t*p1;\n    \n    return dot(proj-p, proj-p);\n}\n\nvec2 PointSegDirection(vec2 p, vec2 p0, vec2 p1)\n{\n    vec2 proj = PointSegProj(p, p0, p1);\n    \n    return proj-p;\n}\n\nfloat horizontalDistance(vec2 p, vec2 p0, vec2 p1)\n{\n    if(p.y < min(p0.y, p1.y) || p.y > max(p0.y, p1.y))\n        return 100000000.0*sign(p1.y-p0.y);\n    \n    float h = p.y-p0.y;\n    float slope = (p1.x-p0.x)/(p1.y-p0.y);\n    float l = p.x-h*slope - p0.x;\n    \n    return l*sign(p1.y-p0.y);\n}\n\nfloat verticalDistance(vec2 p, vec2 p0, vec2 p1)\n{\n    if(p.x < min(p0.x, p1.x) || p.x > max(p0.x, p1.x))\n        return 100000000.0*sign(p1.x-p0.x);\n    \n    float h = p.x-p0.x;\n    float slope = (p1.y-p0.y)/(p1.x-p0.x);\n    float l = p.y-h*slope - p0.y;\n    \n    return l*sign(p1.x-p0.x);\n}\n\n\nfloat escherTextureX(vec2 p)\n{\n    vec2 pp = vec2(mod(p.x+0.5, 1.0)-0.5, mod(p.y,2.0));\n    \n    float d = 1000.0;\n    \n    for(int i=0; i<19; ++i)\n    \tif(abs(horizontalDistance(pp, vert[i], vert[i+1])) < abs(d))\n        {\n            d = horizontalDistance(pp, vert[i], vert[i+1]);\n        }\n    \n    pp = vec2(mod(p.x+0.5, 1.0)-0.5, mod(p.y-1.0,2.0));\n    \n    for(int i=0; i<19; ++i)\n    \tif(abs(horizontalDistance(pp, vert[i], vert[i+1])) < abs(d))\n        {\n            d = horizontalDistance(pp, vert[i], vert[i+1]);\n        }\n    \n    float val = smoothstep(0.0, 1.0, d/0.05);\n    val = d;\n    \n    \n    if(mod(p.x-0.5, 2.0)-1.0 > 0.)\n        val = -val;\n    \n    return val;\n}\n\n\nfloat escherTextureY(vec2 p)\n{\n    vec2 pp = vec2(mod(p.x, 2.0), mod(p.y-.5, 1.0)+0.5);\n    \n    float d = 1000.0;\n    for(int i=19; i<vert.length()-1; ++i)\n    \tif(abs(verticalDistance(pp, vert[i], vert[i+1])) < abs(d))\n            d=verticalDistance(pp, vert[i], vert[i+1]);\n    \n\n    pp = vec2(mod(p.x-1.0, 2.0), mod(p.y-.5, 1.0)+0.5);\n    for(int i=19; i<vert.length()-1; ++i)\n    \tif(abs(verticalDistance(pp, vert[i], vert[i+1])) < abs(d)) \n            d=verticalDistance(pp, vert[i], vert[i+1]);\n    \n    float val = smoothstep(0.0, 1.0, d/0.05);\n    val = d;\n    \n    if(mod(p.y-0.5, 2.0)-1.0 > 0.)\n        val = -val;\n    \n    return val;\n}\n\n\nfloat escherTexture(vec2 p, float pixel_size)\n{\n    float x = escherTextureX(p);\n    float y = escherTextureY(p);\n    \n    x = smoothstep(-1.0, 1.0, x/pixel_size);\n    y = smoothstep(-1.0, 1.0, y/pixel_size);\n    \n    float d = x+y - 2.0 * x*y;\n    \n    return d;\n}\n\n\nfloat escherTextureContour(vec2 p, float linewidth, float pixel_size)\n{\n    vec2 pp = mod(p,1.0);\n    \n    float d = 10000000.0;\n    for(int i=0; i<vert.length(); ++i)\n    {       \n        for(int j=0; j<textureTiles.length(); ++j)\n        {\n            d = min(d, PointSegDistance2(pp+textureTiles[j], vert[i], vert[i+1%vert.length()]));\n        }\n    }\n    \n    d = smoothstep(0.0, 1.0, (sqrt(d)-linewidth)/pixel_size);\n    \n    return d;\n}\n\n\nfloat escherDetails(vec2 p, float linewidth, float pixel_size)\n{\n    vec2 pp = mod(p,1.0);\n    \n    float d = 10000000.0;\n    for(int i=0; i<det.length()-1; ++i)\n    {\n        for(int j=0; j<detailTiles.length(); ++j)\n        {\n            d = min(d, PointSegDistance2(pp+detailTiles[j], det[i], det[i+1]));\n        }\n    }\n    \n    d = smoothstep(0.0, 1.0, (sqrt(d)-linewidth)/pixel_size);\n    \n    return d;\n}\n\nvec3 escherNormal(vec2 p)\n{\n    vec2 pp = mod(p,1.0);\n    \n    float d = 10000000.0;\n    int i_min, j_min;\n    \n    float d_temp;\n    \n    for(int i=0; i<vert.length()-1; ++i)\n    {\n        \n        for(int j=0; j<textureTiles.length(); ++j)\n        {\n            d_temp = PointSegDistance2(pp+textureTiles[j], vert[i], vert[i+1]);\n            if(d_temp < d)\n            {\n                d = d_temp;\n                i_min = i;\n                j_min = j;\n            }\n        }\n    }\n    \n    d = sqrt(d);\n    \n    vec2 proj = PointSegProj(pp+textureTiles[j_min], vert[i_min], vert[i_min+1]);\n    \n    vec2 dir = proj-(pp+textureTiles[j_min]);\n    \n    //float alpha = M_PI/4.0;\n    //vec3 n = vec3(dir/d*cos(alpha), sin(alpha));\n    vec3 n = normalize(vec3(dir/d, 1.0));\n    \n    return n;\n}\n\n\n\n\nvec3 escherDetailNormal(vec2 p)\n{\n    vec2 pp = mod(p,1.0);\n    \n    float d = 10000000.0;\n    vec2 dir;\n    \n    vec2 dir_temp;\n    float d_temp;\n    \n    for(int i=0; i<det.length()-1; ++i)\n    {\n        \n        for(int j=0; j<detailTiles.length(); ++j)\n        {\n            dir_temp = PointSegDirection(pp+detailTiles[j], det[i], det[i+1]);\n            d_temp = length(dir_temp);\n            if(d_temp < d)\n            {\n                d = d_temp;\n                dir = dir_temp;\n            }\n        }\n    }\n    \n    float alpha = M_PI/4.0;\n    vec3 n = vec3(dir/d*cos(alpha), sin(alpha));\n    \n    return n;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    \n    uv -= vec2(0.5* iResolution.x / iResolution.y, 0.5);\n    float zoom = 3.5;\n    zoom = 5.0*iMouse.x / iResolution.x;\n    if(iMouse.x < 5.0)\n        zoom = 4.0 + sin(iTime);\n    \n    uv *= zoom;\n    \n    float pixel_size = 1.5*zoom/iResolution.y;\n    float t = escherTexture(uv, pixel_size);\n    \n\tfragColor = vec4(vec3(t),1.0);\n    \n    \n    float beta = iMouse.y/ iResolution.y * 2.0*M_PI;\n    if(iMouse.y < 5.0)\n        beta = iTime;\n    vec3 lightDir = normalize(vec3(cos(beta), sin(beta), 2.0));\n    \n    vec3 n = escherNormal(uv);\n    vec3 n_det = escherDetailNormal(uv);\n    float blend = 0.3;\n    n = (1.0-blend)*n + blend*n_det;\n    n = n/length(n);\n    n = n*vec3(vec2(2.0*t-1.0), 1.0);\n    float s = 0.15 + 0.85 * (dot(n, lightDir));\n    \n    float spec = 0.5;\n    float shin = 64.0;\n\tfragColor = vec4(vec3(0.8, vec2(0.8-0.5*t)) * (0.15 + 0.85*s) + spec * vec3(pow(s, shin)),1.0);\n\n    float line = escherTextureContour(uv, 0.002, pixel_size);\n\tfragColor = fragColor*line;\n    \n    float details = escherDetails(uv, 0.0002, pixel_size);\n\tfragColor = fragColor*details;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsXfDf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsXfDS", "name": "Is this 4D?", "author": "VoidChicken", "description": "An attempt to do 4D projection. Probably messed up.", "tags": ["projection", "4d"], "likes": 2, "viewed": 134, "date": "1498189269", "time_retrieved": "2024-06-20T18:56:31.753066", "image_code": "vec3 proj4(vec4 V) {\n    vec4 L = vec4(0,0,0,sqrt(2.));\n    vec4 nv = normalize(V-L);\n    return (L+nv*(2./nv.w)).xyz;\n}\nfloat FOV = 100.; //60 degrees FOV\nconst float pi = acos(-1.);\nvec2 project( vec3 p ) {\n    float RAD = FOV/360.*pi;\n    float DVN = p.z;\n    return p.xy/((tan(RAD/2.))*DVN)+.5;\n}\nfloat line ( vec2 p, vec2 a, vec2 b, float r ) {\n\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2 ac = abs( pa - ba*h );\n    return ac.x+ac.y - r;\n    \n}\nfloat lp(vec2 p, vec2 a, vec2 b) {\n\tfloat xP = (p.x-min(a.x,b.x));\n    float xFP = xP/abs(a.x-b.x);\n    float yP = (p.y-min(a.y,b.y));\n    float yFP = yP/abs(a.y-b.y);\n    return xFP>yFP?xP:yP;\n}\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nmat3 rmx(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  \n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c\n              );\n}\nmat4 rm(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, 0.,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, 0.,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,         0.,\n              0.,                                 0.                               ,           0.,                      1.    );\n}\nvec4 shpe[16];\nvec3 poly[16];\nvec2 proj[16];\nvoid polyShape() {\n\tshpe[0]=vec4(-1, -1, -1,0);\n    shpe[1]=vec4(1, -1, -1,0);\n    shpe[2]=vec4(1, 1, -1,0);\n    shpe[3]=vec4(-1,1,-1,0);  \n\tshpe[4]=vec4(-1, -1, 1,0);\n    shpe[5]=vec4(1, -1, 1,0);\n    shpe[6]=vec4(1, 1, 1,0);\n    shpe[7]=vec4(-1,1,1,0);   \n\tshpe[8]=vec4(-1, -1, -1,1);\n    shpe[9]=vec4(1, -1, -1,1);\n    shpe[10]=vec4(1, 1, -1,1);\n    shpe[11]=vec4(-1,1,-1,1);  \n\tshpe[12]=vec4(-1, -1, 1,1);\n    shpe[13]=vec4(1, -1, 1,1);\n    shpe[14]=vec4(1, 1, 1,1);\n    shpe[15]=vec4(-1,1,1,1);    \n    for (int x = 0; x < 16; x++) {\n        vec4 point = shpe[x]*rm(vec3(0,1,0),iTime);\n        poly[x]=proj4(point);\n    }\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    polyShape();\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float df = 5000000.;\n    for (int i = 0; i < 16; i++) {\n    \tproj[i]=project(poly[i]+vec3(0,0,55));    \n    }\n    float lv = 0.;\n    int pt = 0;\n    for (int i = 0; i < 16; i++) {\n        /*for (int n = 0; n < 8; n++) {\n        vec2 nv =  proj[n];\n     \t  \n    \t\tdf=min(df,line(uv, proj[i],nv, .002)); \n        \tlv=lp(uv,proj[i],nv);\n    \t}*/\n        float ndf = length(proj[i]-uv)-1./10000.;\n        if (ndf<df)pt=i;\n        df=min(ndf,df);\n    }\n\n    vec3 c = vec3(0);\n    if (df<.02) {\n     \tvec3 ct = hsv2rgb(vec3(lv,1,1));\n        c=(pt<8?vec3(1,0,0):vec3(0,1,1));//pow(1.-df/.02,15.)*ct;\n        c-=1.-pow(1.-df/.02,5.);\n    }\n    \n\tfragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsXfDS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsXfRs", "name": "Deep", "author": "834144373", "description": "raymarch", "tags": ["raymarch", "morphing"], "likes": 11, "viewed": 196, "date": "1497510649", "time_retrieved": "2024-06-20T18:56:31.753066", "image_code": "//created by 834144373()\n#define R iResolution.xy\n#define DEPTH_STEP 64\n#define time iTime\nfloat map(vec3 p){\n\tfloat a = p.z*0.1001;\n\tp.xy *= mat2(cos(a), sin(a), -sin(a), cos(a));\n\tfloat t = length(mod(p.xy, 2.0) - 1.0) - 0.07 - sin(p.z)*sin(time)/4.;\n\tt = min(t,length(mod(p.yz, 2.0) - 1.0) - 0.07 - sin(p.x)*cos(time)/4.);\n\tt = min(t,length(mod(p.zx, 2.0) - 1.0) - 0.07 - sin(p.y)*sin(time)/4.);\n\treturn t;\n}\n\nvoid mainImage( out vec4 Color, in vec2 U ){\n\tfloat j = 0.;\n\tfloat depth = 1.;\n\tfloat d = 0.;\n\tfor(int i=0;i<64;i++){\n\t\tdepth += (d = map(vec3(0.,0.,time) + normalize(vec3((U+U-R)/R.y,2.)) * depth));\n\t\tj = float(i);\n\t\tif(d<0.01)\n\t\t\tbreak;\n\t}\n\tdepth = 1.-j/float(DEPTH_STEP);\n    /*\n\tfloat coeff = pow(depth,2.2)*3.;\n\tfloat c1 = clamp(coeff,0.,1.);\n\tfloat c2 = clamp(coeff,1.,2.)-1.;   \n\tfloat c3 = clamp(coeff,2.,3.)-2.;\n\tvec3 col = vec3(c1,c2,c3);\n\t*/\n    //Super thanks for Shane's suggestion,:-\n    //vec3 col = pow(vec3(1.5, 1, 1)*val, vec3(1, 3, 16));\n    vec3 col = pow(vec3(1.)*depth, vec3(1, 3, 10));\t\n\tColor = vec4(col,0.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsXfRs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "lsXfRX", "name": "Cosmos", "author": "Ebanflo", "description": "Mouse rotates camera. FBM based nebula and starfield with a trick that looks like gravitational lensing. ", "tags": ["procedural", "3d", "fractal", "noise", "interactive", "volumetric"], "likes": 8, "viewed": 828, "date": "1497157058", "time_retrieved": "2024-06-20T18:56:32.831759", "image_code": "// Cosmos by Eben Kadile aka Ebanflo - 2017\n// eben.cowley42@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n#define pi 3.141592654\n#define urx 1920U\n#define ury 1080U\n#define time iDate.x + iDate.y + iDate.z + iDate.w\n//blackhole\n#define renderBlackhole\n#define blackholeInFront //adds cool halo effect when clouds pass in front of the lensing\n#define blackholeCenter vec3(0.0)\n#define blackholeRadius .12\n#define blackholeIntensity .02\n//nebula\n#define cloudSpeed .05\n#define fractalIterations3d 5\n#define renderIterations 6\n#define stepsize .3\n#define cloudBrightness 1.1\n#define cloudThickness .47\n#define colDisp vec3(2.5, 5.0, 7.5)\n#define colDist 6.0\n//starfield\n#define renderStars\n#define fractalIterations2d 4\n#define starDensity .15\n#define starColor vec3(1.0)\n#define starBrightness 1.0\n#define starTwinkle \n#define twinkleFreq .01\nconst bool coolEffect = false; //try it out\n\nvec4 iPlane(vec3 ro, vec3 rd, vec3 po, vec3 pd){\n    float d = dot(po - ro, pd) / dot(rd, pd);\n    return vec4(d * rd + ro, d);\n}\n\n//modified Lambert-Azimuthal projection\nvec2 proj(vec3 v){return inversesqrt(.5 * (1.0 + abs(v.z)) * abs(v.xy));}\n\nvec3 r(vec3 v, vec2 r){//rodolphito's rotation\n    vec4 t = sin(vec4(r, r + 1.5707963268));\n    float g = dot(v.yz, t.yw);\n    return vec3(v.x * t.z - g * t.x,\n                v.y * t.w - v.z * t.y,\n                v.x * t.x + g * t.z);\n}\n\nfloat hash(uint n){//Hugo Elias's hash\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return 1.0 - float(n & 0x7fffffffU)/float(0x7fffffff);\n}\n\nfloat hashNoise2(vec2 x){\n    x = mod(x, .1);\n    x *= vec2(urx, ury);\n    vec2 fr = fract(x);\n    uvec2 p = uvec2(x);\n\tfloat f1 = hash(p.x + ury * p.y);\n    float f2 = hash(p.x + 1U + ury * p.y);\n    f1 = mix(f1, f2, fr.x);\n    float f3 = hash(p.x + ury * (p.y + 1U));\n    float f4 = hash(p.x + 1U + ury * (p.y + 1U));\n    f3 = mix(f3, f4, fr.x);\n\treturn mix(f1, f3, fr.y);\n}\n\nfloat hashNoise3(vec3 x){\n    vec3 fr = fract(x);\n    fr = smoothstep(0.0, 1.0, fr);\n    uvec3 p = uvec3(x);\n    return mix(mix(mix(hash(p.x + ury * p.y + urx * p.z), \n                        hash(p.x + 1U + ury * p.y + urx * p.z),fr.x),\n                   mix(hash(p.x + ury * (p.y + 1U) + urx * p.z), \n                        hash(p.x + 1U + ury * (p.y + 1U) + urx * p.z),fr.x),fr.y),\n               mix(mix(hash(p.x + ury * p.y + urx * (p.z + 1U)), \n                        hash(p.x + 1U + ury * p.y + urx * (p.z + 1U)),fr.x),\n                   mix(hash(p.x + ury * (p.y + 1U) + urx * (p.z + 1U)), \n                        hash(p.x + 1U + ury * (p.y + 1U) + urx * (p.z + 1U)),fr.x),fr.y),fr.z);\n}\n\nfloat fractalNoise3d(vec3 pos){\n    float acc = 0.0;\n    float scale = 1.0;\n    for(int n = 0; n < fractalIterations3d; n++){\n        acc += hashNoise3(scale * pos) / scale;\n        scale *= 2.0;\n    }\n    return .5 * acc; \n}\n\nfloat fractalNoise2d(vec2 x){\n    float acc = 0.0;\n    float scale = 1.0;\n    for(int n = 0; n < fractalIterations2d; n++){\n        acc += hashNoise2(scale * x) / scale;\n        scale *= 2.0;\n    }\n    return .65 * acc;\n}\n\nvec3 density(vec3 pos, float d){\n    pos += cloudSpeed * (time + 13.0);\n    float fn = fractalNoise3d(pos * 10.0);\n    fn *= cloudBrightness;\n    fn = 3.0 * smoothstep(1.0 - cloudThickness, 1.0, fn);\n    vec3 col = fn * sin(fn + colDisp + colDist * d);\n    return mix(col, vec3(fn), fn);\n}\n\nvec3 starField(vec2 pos){\n    float stars = fractalNoise2d(pos);\n    stars = smoothstep(1.0 - starDensity, 1.0, stars);\n    stars *= starBrightness;\n    #ifdef starTwinkle\n    if(stars > 1.0 - starDensity || coolEffect){\n    \tstars -= hash(uint(5.0 * abs((pos.x + float(urx) * pos.y)) \n                           + float(ury) * iTime * twinkleFreq));\n    }\n\t#endif\n    return starColor * stars;\n}\n\n#ifdef blackholeInFront\nvec3 render(vec3 ro, vec3 rd){\n    #ifdef renderBlackhole\n    \tvec3 nml = normalize(blackholeCenter - ro);\n    \tvec3 pos = iPlane(ro, rd, blackholeCenter, nml).xyz;\n    \tpos = blackholeCenter - pos;\n    \tfloat intensity = dot(pos, pos);\n    \tif(intensity < blackholeRadius * blackholeRadius) return vec3(0.0);\n    \telse {\n            intensity = 1.0 / intensity;\n        \trd = mix(rd, pos * sqrt(intensity), blackholeIntensity * intensity);\n        }\n    #endif\n    vec3 result = vec3(0.0);\n    float d = stepsize;\n\tfor(int n = 0; n < renderIterations; n++){\n        vec3 pos = d * rd + ro;\n        result += density(pos, d) / d;\n        d += stepsize;\n    }\n    #ifdef renderStars\n    \tvec2 dir = proj(rd);\n    \tvec3 stars = starField(dir);\n    \tresult += stars;\n    #endif\n    return result;\n}\n#else\nvec3 render(vec3 ro, vec3 rd){\n    vec3 nml = normalize(blackholeCenter - ro);\n    vec4 pos = iPlane(ro, rd, blackholeCenter, nml);\n    float dist = pos.w;\n    vec3 p = blackholeCenter - pos.xyz;\n    float intensity = dot(p, p);\n    vec3 result = vec3(0.0);\n    float ss = 2.0 * dist / float(renderIterations);\n    float d = ss;\n\tfor(int n = 0; n < renderIterations / 2; n++){\n        vec3 pos = d * rd + ro;\n        result += density(pos, d) / d;\n        d += ss;\n    }\n    bool cont = true;\n    #ifdef renderBlackhole\n    \tif(intensity < blackholeRadius * blackholeRadius){\n        \tresult -= .5;\n            cont = false;\n        }\n    \telse {\n            intensity = 1.0 / intensity;\n        \trd = mix(rd, p * sqrt(intensity), blackholeIntensity * intensity);\n        }\n    #endif\n    if(cont){\n    \tfor(int n = 0; n < renderIterations / 2; n++){\n    \t    vec3 pos = d * rd + ro;\n    \t    result += density(pos, d) / d;\n    \t    d += ss;\n    \t}\n    }\n    #ifdef renderStars\n    if(cont){\n    \tvec2 dir = proj(rd);\n    \tvec3 stars = starField(dir);\n    \tresult += stars;\n    }\n    #endif\n    return result;\n}\n#endif\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n\tfragColor = vec4(1.0);\n    vec2 xy = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, -1.0);\n    vec3 rd = normalize(vec3(xy, 3.0));\n    vec2 m = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n    if(iMouse.xy == vec2(0.0)) m = vec2(0.0);\n    rd = r(rd, m);\n    ro = r(ro, m);\n    ro += blackholeCenter;\n    fragColor.xyz = render(ro, rd);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lsXfRX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdfBDf", "name": "Ice cream", "author": "Koltes", "description": "Quick enhancement of my shader at the Shader Showdown Paris #1.", "tags": ["shadershowdown"], "likes": 25, "viewed": 673, "date": "1498475813", "time_retrieved": "2024-06-20T18:56:32.831992", "image_code": "struct M{float d;vec3 c;};\nfloat C,S;\n#define rot(a) mat2(C=cos(a),S=sin(a),-S,C)\n#define t iTime\n\nM mmin(M a,M b,float k){\n    float h=clamp((b.d-a.d)/k*.5+.5,0.,1.);\n    M m;\n    m.d=mix(b.d,a.d,h)-k*h*(1.-h);\n    m.c=mix(b.c,a.c,h);\n    return m;\n}\n\nM map(vec3 p){   \n    p.y-=.1*sin(t*5.)-.2;\n    p.xz*=rot(t);\n    float a=atan(p.z,p.x);\n    float d=dot(normalize(vec2(.9,-.2)),vec2(length(p.xz),p.y+2.));\n    d=max(d,p.y-1.);\n    M m;\n    m.d=d;\n    vec2 st=fract(vec2(a/6.2831*10.+p.y*1., a/6.2831*2.-p.y*4.));\n    st*=(1.-st);\n    m.c=mix(vec3(.8,.4,.0),vec3(.9,.8,.0),pow(st.x*st.y*15.,.5));\n    d=length(p.xz)-(.8+.1*sin(a*8.+p.y*15.-.5))*(smoothstep(.5,1.,p.y)-smoothstep(1.5,3.,p.y));\n    M m2;\n    m2.d=d;\n    m2.c=mix(vec3(.9),vec3(.9,.1,.1),step(.5,fract(a/6.2831*4.+p.y/6.2831*7.5)));\n    m=mmin(m,m2,.1);\n    return m;\n}\n\nvec3 hsv(float h,float s,float v){\n    vec3 k=vec3(3.,2.,1.)/3.,\n        p=abs(fract(h+k.xyz)*6.-3.);\n    return v*mix(k.xxx,clamp(p-1.,0.,1.),s);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy,v=uv*(1.-uv);\n    uv-=.5;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    vec3 ro=vec3(uv,-5.),rd=normalize(vec3(uv,1.)),mp=ro;\n    M m;\n    float f;for(f=0.;f<30.;++f){\n        m=map(mp);\n        if(abs(m.d)<.001)break;\n        mp+=rd*m.d;\n    }\n    float mbg=min(1.,length(mp-ro)*.01);\n    float a=atan(uv.y+.8,uv.x)/6.2831*40.+iTime;\n    vec3 bg=mix(vec3(.0,.4,.8),vec3(.1,.5,.9),step(.5,fract(a)))*2.;\n    vec3 c=mix(m.c*vec3(1.-f/30.)*1.2,bg,mbg);\n    for(f=0.;f<40.;++f){\n        vec4 h=fract(sin(f+vec4(0.,3.,5.,8.))*1e4);\n        h.y=fract(h.y-t*.1);\n        vec3 p=(h.xyz-.5)*8.;\n        p.xz*=rot(t*.7);\n        float l=length(cross(p-ro,rd));\n        c+=.01/l/l*hsv(h.w,1.,1.);\n    }\n    c=sqrt(c)*pow(v.x*v.y*20.,.6);\n\tfragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdfBDf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdfBR2", "name": "ChromeBug", "author": "hubbe", "description": "demonstrates a bug in chrome", "tags": ["bug"], "likes": 1, "viewed": 377, "date": "1496961369", "time_retrieved": "2024-06-20T18:56:32.831992", "image_code": "#define BUG   // works if you comment this out\n\n#define NOHIT 20000.0\n\n#define CYLINDER\n#ifdef BUG\n#define CAPPEDCYLINDER\n#endif\n    \nstruct Plane {\n    vec3 pos;\n    vec3 normal;\n};\n\n#ifdef CYLINDER\nstruct Cylinder {\n    vec3 a, b;\n    float r;\n};\n#endif\n#ifdef CAPPEDCYLINDER\nstruct CappedCylinder {\n    vec3 a, b;\n    float r;\n};\n#endif\n\n        \nstruct Ray {\n    vec3 start, dir;\n};\n\nstruct Hit {\n    float dist;\n    vec3 normal;\n};\n\nstruct Range {\n    Hit begin;\n    Hit end;\n};\n    \n\nHit FAR() {\n    return Hit(NOHIT, vec3(0));\n}\nHit NEAR() {\n    return Hit(0.0, vec3(0));\n}\n \nRange Everything() {\n    return Range(NEAR(), FAR());\n}\n\nRange Nothing() {\n    return Range(FAR(), NEAR());\n}\n\nHit Max(Hit a, Hit b) {\n    if (a.dist > b.dist)\n        return a;\n    else\n        return b;\n}\n\nHit Min(Hit a, Hit b) {\n    if (a.dist < b.dist)\n        return a;\n    else\n        return b;\n}\n\nRange Intersect(Range a, Range b) {\n    return Range(Max(a.begin, b.begin),\n                 Min(a.end, b.end));\n}\n\nbool Empty(Range a) {\n    return a.begin.dist >= a.end.dist;\n}\n\n\nvec3 Project( vec3 a, vec3 b )\n{\n\treturn a - b * dot(a, b);\n}\n\nfloat SQ(vec3 x) { return dot(x,x); }\n\n\nRange Trace(Ray ray, Plane o) {\n    vec3 pos = o.pos;\n    vec3 normal = o.normal;\n    float tmp = dot(pos - ray.start, normal);\n   \tfloat div = dot(ray.dir, normal);\n    if (div == 0.0) {\n        if (tmp > 0.0) {\n            return Everything();\n        } else {\n            return Nothing();\n        }\n    }\n    float dist = tmp / div;\n    if (div > 0.0) {\n        return Range(NEAR(), Hit(dist, normal));\n    } else {\n        return Range(Hit(dist, normal), FAR());\n    }\n}\n\n\n\nRange cut(Range hit, Ray ray, vec3 p, vec3 n) {\n    return Intersect(hit, Trace(ray, Plane(p, n)));\n}\n\n#ifdef CYLINDER\nRange Trace(Ray ray, Cylinder o) {\n    vec3 A = o.a;\n    vec3 B = o.b;\n    float r = o.r;\n    vec3 O = ray.start;\n    vec3 V = ray.dir;\n    vec3 AB = B - A;\n    vec3 AO = O - A;\n    vec3 AOxAB = cross(AO, AB);\n    vec3 VxAB = cross(V, AB);\n    float ab2 = dot(AB, AB);\n    float a = dot(VxAB, VxAB);\n    float b = 2.0 * dot(VxAB, AOxAB);\n    float c = dot(AOxAB, AOxAB) - (r * r * ab2);\n    float toroot = b * b - 4.0 * a * c;\n    if (toroot < 0.0) return Nothing();\n    float root = sqrt(toroot);\n\n    Range ret;\n    ret.begin.dist = (-b - root) / (2.0 * a);\n    ret.begin.normal = Project(ray.start + ret.begin.dist * ray.dir - A, AB);\n    ret.end.dist = (-b + root) / (2.0 * a);\n    ret.end.normal = Project(ray.start + ret.begin.dist * ray.dir - A, AB);    \n    return ret;   \n}\n#endif\n\n\n#ifdef CAPPEDCYLINDER\nRange Trace(Ray ray, CappedCylinder o) {\n    Range ret = Trace(ray, Cylinder(o.a, o.b, o.r));\n    ret = cut(ret, ray, o.a, normalize(o.a - o.b));\n    ret = cut(ret, ray, o.b, -normalize(o.a - o.b));\n    return ret;\n}\n#endif\n\n\nHit Range2Hit(Range r) {\n    if (r.begin.dist >= r.end.dist) return FAR();\n    if (r.end.dist <= 0.0) return FAR();\n    if (r.begin.dist <= 0.0) return NEAR();\n    return r.begin;\n}\n\nHit Trace(Ray ray) {\n\t#ifdef CAPPEDCYLINDER\n    Range ret = Trace(ray, CappedCylinder(vec3(0.0, -0.4, 1.0), vec3(0.0, 0.4, 1.0), 0.2));\n\t#else\n    Range ret = Trace(ray, Cylinder(vec3(0.0, -0.4, 1.0), vec3(0.0, 0.4, 1.0), 0.2));\n\n    #endif\n  \n    return Range2Hit(ret);\n}\n\nvec3 GetColor(vec2 xy) {\n    vec3 ret;\n \tvec2 uv = (xy.xy - iResolution.xy / 2.0) / iResolution.xx;\n    Ray ray = Ray(vec3(0, 0, -6), normalize(vec3(uv, 1)));\n    \n    float s = sin(iTime/3.0);\n    float c = cos(iTime/3.0);\n    mat3 rot = mat3(c, 0, s,\n         0, 1, 0,\n         -s,0, c);\n    ray.start = rot * ray.start;\n    ray.dir = rot * ray.dir;\n     \n    // Cast a ray, see if we hit anything.\n    Hit t = Trace(ray);\n    \n    // Just set the output color to the distance.\n    vec3 hp = ray.start + ray.dir * t.dist;\n    int grid1 = int( (hp.x + hp.y + hp.z + 100.0) * 5.0 ) % 2;\n    int grid2 = int( (hp.x + hp.y - hp.z + 100.0) * 5.0 ) % 2;\n    int grid3 = int( (hp.x - hp.y - hp.z + 100.0) * 5.0 ) % 2;\n        \n\tret = vec3(grid1, grid2, grid3);\n    if (t.dist == NOHIT) ret=vec3(0);\n\treturn ret;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  fragColor = vec4(GetColor(fragCoord), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdfBR2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdfBWB", "name": "Rectangle rotation", "author": "stas0", "description": "Rectangle rotation", "tags": ["rectangle", "rotation"], "likes": 3, "viewed": 560, "date": "1497820798", "time_retrieved": "2024-06-20T18:56:32.831992", "image_code": "vec4 translate(vec4 size, vec2 offset) {\n    size.xz += offset.x;\n    size.yw += offset.y;\n    \n\treturn size;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = (fragCoord - .5 * iResolution.xy ) / iResolution.y;\n    \n   \tvec3 color = vec3(.0, .0, .0);\n    \n    vec4 rect = vec4(.0, .0, .15, .15);\n    \n    //\tTranslate\n    //rect = translate(rect, vec2(.2, .2));\n    float slowerRate = 4.;\n    float rotate = 6.28319;\n    float rotateTime = mod(iTime, slowerRate);\n    rotate = rotate / slowerRate * rotateTime;\n    float c = cos(rotate);\n    float s = sin(rotate);\n    mat2 rot = mat2(c, -s, s, c);\n    \n    pos *= rot;\n    \n    vec2 rc = step( abs(pos), rect.zw);\n    \n    color = vec3(rc.x * rc.y);\n    \n    \n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdfBWB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdfBzB", "name": "Yolk", "author": "Sheado", "description": "Stumbled across this while learning and tinkering. ", "tags": ["2d", "simple", "basic", "gradient"], "likes": 2, "viewed": 94, "date": "1496708668", "time_retrieved": "2024-06-20T18:56:32.831992", "image_code": "#define PI 3.14159265359\n\nvoid gradient( out vec4 fragColor, in vec2 fragCoord );\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    gradient( fragColor, fragCoord );\n}\n\nvoid gradient( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 center = vec2(.5,.5);\n    float x = (uv.x-center.x)*5.2*cos(iTime);\n    float y = (uv.y-center.y)*5.2*sin(iTime);\n\n    float l = (cos(x) + sin(y));\n    \n    float r = smoothstep(0.,1.1,l);\n    float g = smoothstep(0.5,1.2,l);\n    float b = smoothstep(0.7,1.3,l);\n    \n    vec4 color = vec4(r,g,b,1.0);\n    fragColor = color;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdfBzB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdfBzl", "name": "ice and fire", "author": "mattz", "description": "I've been seeing lots of trendy triangle-based backgrounds and wallpapers over the past 2 years, and I never saw a Shadertoy version, so here's my take. Next step: terrain marching a similar pattern...", "tags": ["2d", "triangles", "soothing", "triangulation", "fakedelaunay"], "likes": 113, "viewed": 4832, "date": "1497550069", "time_retrieved": "2024-06-20T18:56:34.213866", "image_code": "/* ice and fire, by mattz\n   License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n   Demonstrate triangulation of jittered triangular lattice.\n\n*/\nconst float s3 = 1.7320508075688772;\nconst float i3 = 0.5773502691896258;\n\nconst mat2 tri2cart = mat2(1.0, 0.0, -0.5, 0.5*s3);\nconst mat2 cart2tri = mat2(1.0, 0.0, i3, 2.0*i3);\n\n//////////////////////////////////////////////////////////////////////\n// cosine based palette \n// adapted from https://www.shadertoy.com/view/ll2GD3\n\nvec3 pal( in float t ) {\n    \n    const vec3 a = vec3(0.5);\n    const vec3 b = vec3(0.5);\n    const vec3 c = vec3(0.8, 0.8, 0.5);\n    const vec3 d = vec3(0, 0.2, 0.5);\n    \n    return clamp(a + b*cos( 6.28318*(c*t+d) ), 0.0, 1.0);\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// from https://www.shadertoy.com/view/4djSRW\n\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n\nfloat hash12(vec2 p) {\n    vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);   \n}\n\nvec2 hash23(vec3 p3) {\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//////////////////////////////////////////////////////////////////////\n// compute barycentric coordinates from point differences\n// adapted from https://www.shadertoy.com/view/lslXDf\n\nvec3 bary(vec2 v0, vec2 v1, vec2 v2) {\n    float inv_denom = 1.0 / (v0.x * v1.y - v1.x * v0.y);\n    float v = (v2.x * v1.y - v1.x * v2.y) * inv_denom;\n    float w = (v0.x * v2.y - v2.x * v0.y) * inv_denom;\n    float u = 1.0 - v - w;\n    return vec3(u,v,w);\n}\n\n//////////////////////////////////////////////////////////////////////\n// distance to line segment from point differences\n\nfloat dseg(vec2 xa, vec2 ba) {\n    return length(xa - ba*clamp(dot(xa, ba)/dot(ba, ba), 0.0, 1.0));\n}\n\n//////////////////////////////////////////////////////////////////////\n// generate a random point on a circle from 3 integer coords (x, y, t)\n\nvec2 randCircle(vec3 p) {\n    \n    vec2 rt = hash23(p);\n    \n    float r = sqrt(rt.x);\n    float theta = 6.283185307179586 * rt.y;\n    \n    return r*vec2(cos(theta), sin(theta));\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// make a time-varying cubic spline at integer coords p that stays\n// inside a unit circle\n\nvec2 randCircleSpline(vec2 p, float t) {\n\n    // standard catmull-rom spline implementation\n    float t1 = floor(t);\n    t -= t1;\n    \n    vec2 pa = randCircle(vec3(p, t1-1.0));\n    vec2 p0 = randCircle(vec3(p, t1));\n    vec2 p1 = randCircle(vec3(p, t1+1.0));\n    vec2 pb = randCircle(vec3(p, t1+2.0));\n    \n    vec2 m0 = 0.5*(p1 - pa);\n    vec2 m1 = 0.5*(pb - p0);\n    \n    vec2 c3 = 2.0*p0 - 2.0*p1 + m0 + m1;\n    vec2 c2 = -3.0*p0 + 3.0*p1 - 2.0*m0 - m1;\n    vec2 c1 = m0;\n    vec2 c0 = p0;\n    \n    return (((c3*t + c2)*t + c1)*t + c0) * 0.8;\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n// perturbed point from index\n\nvec2 triPoint(vec2 p) {\n    float t0 = hash12(p);\n    return tri2cart*p + 0.45*randCircleSpline(p, 0.15*iTime + t0);\n}\n\n//////////////////////////////////////////////////////////////////////\n// main shading function. inputs:\n// \n//   p - current pixel location in scene\n//\n//   tfloor - integer grid coordinates of bottom-left triangle vertex\n//\n//   t0, t1, t2 - displaced cartesian coordinates (xy) and integer\n//                grid offsets (zw) of triangle vertices, relative\n//                to tfloor\n//\n//   scl - pixel size in scene units\n//\n//   cw - pixel accumulator. xyz are rgb color pre-multiplied by\n//        weights, and w is total weight.\n//\n\nvoid tri_color(in vec2 p, \n               in vec4 t0, in vec4 t1, in vec4 t2, \n               in float scl, \n               inout vec4 cw) {\n               \n    // get differences relative to vertex 0\n    vec2 p0 = p - t0.xy;\n    vec2 p10 = t1.xy - t0.xy;\n    vec2 p20 = t2.xy - t0.xy;\n    \n    // get barycentric coords\n    vec3 b = bary(p10, p20, p0);\n    \n    // distances to line segments\n    float d10 = dseg(p0, p10);\n    float d20 = dseg(p0, p20);\n    float d21 = dseg(p - t1.xy, t2.xy - t1.xy);\n    \n    // unsigned distance to triangle boundary\n    float d = min(min(d10, d20), d21);\n\n    // now signed distance (negative inside, positive outside)\n    d *= -sign(min(b.x, min(b.y, b.z))); \n\n    // only wory about coloring if close enough\n    if (d < 0.5*scl) {\n\n        //////////////////////////////////////////////////\n        // generate per-vertex palette entries\n    \n        // sum of all integer grid indices\n        vec2 tsum = t0.zw + t1.zw + t2.zw;\n\n        // generate unique random number in [0, 1] for each vertex of\n        // this triangle\n        vec3 h_tri = vec3(hash12(tsum + t0.zw),\n                          hash12(tsum + t1.zw),\n                          hash12(tsum + t2.zw));\n\n        //////////////////////////////////////////////////\n        // now set up the \"main\" triangle color:\n        \n        // get the cartesian centroid of this triangle\n        vec2 pctr = (t0.xy + t1.xy + t2.xy) / 3.0;\n\n        // angle of scene-wide color gradient\n        float theta = 1.0 + 0.01*iTime;\n        vec2 dir = vec2(cos(theta), sin(theta));\n\n        // how far are we along gradient?\n        float grad_input = dot(pctr, dir) - sin(0.05*iTime);\n\n        // h0 varies smoothly from 0 to 1\n        float h0 = sin(0.7*grad_input)*0.5 + 0.5;\n\n        // now the per-vertex random numbers are all biased towards h\n        // (still in [0, 1] range tho)\n        h_tri = mix(vec3(h0), h_tri, 0.4);\n\n        //////////////////////////////////////////////////\n        // final color accumulation\n        \n        // barycentric interpolation of per-vertex palette indices\n        float h = dot(h_tri, b);\n\n        // color lookup\n        vec3 c = pal(h);\n        \n        // weight for anti-aliasing is 0.5 at border, 0 just outside,\n        // 1 just inside\n        float w = smoothstep(0.5*scl, -0.5*scl, d);\n\n        // add to accumulator\n        cw += vec4(w*c, w);\n        \n    }\n    \n}\n\n//////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n    float scl = 4.1 / iResolution.y;\n    \n    // get 2D scene coords\n    vec2 p = (fragCoord - 0.5 - 0.5*iResolution.xy) * scl;\n    \n    // get triangular base coords\n    vec2 tfloor = floor(cart2tri * p + 0.5);\n\n    // precompute 9 neighboring points\n    vec2 pts[9];\n\n    for (int i=0; i<3; ++i) {\n        for (int j=0; j<3; ++j) {\n            pts[3*i+j] = triPoint(tfloor + vec2(i-1, j-1));\n        }\n    }\n    \n    // color accumulator\n    vec4 cw = vec4(0);\n\n    // for each of the 4 quads:\n    for (int i=0; i<2; ++i) {\n        for (int j=0; j<2; ++j) {\n    \n            // look at lower and upper triangle in this quad\n            vec4 t00 = vec4(pts[3*i+j  ], tfloor + vec2(i-1, j-1));\n            vec4 t10 = vec4(pts[3*i+j+3], tfloor + vec2(i,   j-1));\n            vec4 t01 = vec4(pts[3*i+j+1], tfloor + vec2(i-1, j));\n            vec4 t11 = vec4(pts[3*i+j+4], tfloor + vec2(i,   j));\n          \n            // lower\n            tri_color(p, t00, t10, t11, scl, cw);\n\n            // upper\n            tri_color(p, t00, t11, t01, scl, cw);\n           \n        }\n    }    \n        \n    \n    // final pixel color\n    fragColor = cw / cw.w;\n    \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdfBzl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdffDf", "name": "z = f(x, y) surface plot", "author": "yumcyawiz", "description": ".", "tags": ["raymarching"], "likes": 4, "viewed": 116, "date": "1498503077", "time_retrieved": "2024-06-20T18:56:34.213866", "image_code": "float f(vec3 p) {\n    float t = iTime;\n    float x = p.x;\n    float y = p.y;\n    return sin(t*x) + cos(t*y);\n}\n\n\nvec3 calcNormal(vec3 p) {\n    float eps = 0.001;\n    float dfdx = (f(p + vec3(eps, 0, 0)) - f(p - vec3(eps, 0, 0)))/(2.0*eps);\n    float dfdy = (f(p + vec3(0, eps, 0)) - f(p - vec3(0, eps, 0)))/(2.0*eps);\n    return normalize(vec3(dfdx, dfdy, -1));\n}\n\n\n\nstruct Ray {\n    vec3 position;\n    int steps;\n    float t;\n    vec3 normal;\n};\nconst int maxSteps = 300;\nRay trace(vec3 from, vec3 rayDir) {\n    vec3 p = vec3(0);\n    int steps = 0;\n    float t = 0.0;\n    vec3 normal = vec3(0);\n    for(int i = 0; i < maxSteps; i++) {\n        p = from + t*rayDir;\n        float d = abs(p.z - f(p)/2.0);\n        if(d < 0.1) {\n            p -= 0.05*d*rayDir;\n            steps = i;\n            normal = calcNormal(p);\n            break;\n        }\n        t += d*0.05;\n    }\n    return Ray(p, steps, t, normal);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //(-1, -1) ~ (1, 1)\n\tvec2 uv = (2.0*fragCoord.xy - iResolution.xy)/iResolution.y;\n    \n    //camera settings\n    float t = iTime;\n    vec3 camPos = vec3(0, 0, -3);\n    vec3 camFront = vec3(0, 0, 1);\n    vec3 camUp = vec3(0, 1, 0);\n    vec3 camRight = cross(camUp, camFront);\n    float focus = 1.0;\n    \n    //ray direction\n    vec3 rayDir = uv.x*camRight + uv.y*camUp + focus*camFront;\n    \n    //trace\n    Ray tr = trace(camPos, rayDir);\n    \n    //coloring\n    vec3 ao = pow((1.0 - float(tr.steps)/float(maxSteps)), 1.0) * vec3(1);\n    vec3 sunDir = normalize(vec3(0.5, 0.5, -1));\n    vec3 diffuse = max(dot(tr.normal, sunDir), 0.) * vec3(1);\n    vec3 color = 0.5*ao + 0.5*diffuse;\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdffDf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdffDM", "name": "everyday 023/100", "author": "kalin", "description": "everyday 023/100", "tags": ["everyday"], "likes": 2, "viewed": 157, "date": "1496384605", "time_retrieved": "2024-06-20T18:56:34.213866", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 nuv = uv * 2.0 - 1.0;\n    vec2 nnuv = nuv * vec2(1.0, iResolution.y / iResolution.x);\n    \n    float t = iTime;\n    float bpm = 1.0 / 60.0 * 142.0 * 2.0;\n    float bpmw = pow(abs(sin(t * bpm * 0.5)), 2.5);\n    \n    float m0 = texture(iChannel0, vec2(0.0, 0.25)).x;\n    \n    m0 += texture(iChannel0, vec2(0.05, 0.25)).x;\n    m0 += texture(iChannel0, vec2(0.12, 0.25)).x;\n    m0 += texture(iChannel0, vec2(0.2, 0.25)).x;\n    \n    m0 /= 4.0;\n    \n    m0 = pow(max(0.0, m0 - 0.25) * 2.0, 3.5);\n    \n    vec2 cylv = nnuv + vec2(0.0, 0.2 - m0 * 0.1);\n    float cyl = (cylv.x * cylv.x) / 0.25 - 0.2 * m0 + (cylv.y * cylv.y) / 0.020;\n    float c0 = max(0.0, 1.0 - cyl);\n    \n    c0 *= pow(uv.y, 1.0 + 2.0 * -cylv.y) * 8.0;\n\n    float c1 = step(-0.0125, cylv.y);\n    \n    c1 *= step(-0.4, -cylv.y);\n    \n    float c2 = step(-0.40, cylv.x);\n        \n    c2 *= step(-0.40, -cylv.x);\n    \n    vec2 c3va = nnuv + vec2(0.0, 0.2);\n    vec2 c3vb = nnuv + vec2(0.0, -0.05);\n    float c3a = (c3va.x * c3va.x) / 0.25 + (c3va.y * c3va.y) / 0.020;\n    float c3b = (c3vb.x * c3vb.x) / 0.25 + (c3vb.y * c3vb.y) / 0.020;\n    \n    float c3 = max(0.0, max(0.0, (1.25 + 0.05 * bpmw - c3a * 1.0)) - max(0.0, (1.0 - c3a) * 4.0));\n    \n    //fragColor.x = 1.0 * c0;\n    //fragColor.y = 1.0 * c1;\n    //fragColor.z = 1.0 * c2;\n    \n    fragColor.xyz += vec3(0.15);\n    fragColor.xyz += vec3(0.0, 0.2, 0.1 + m0 * 0.1) * c0 * (1.0 + m0 * 0.4);\n    fragColor.xyz += vec3(0.0, 0.3 + 0.1 * bpmw, 0.2) * c3;\n    \n    fragColor.xyz += vec3(texture(iChannel0, vec2(cyl)).x) * c0 * (0.05 + bpmw * m0 * 0.5);\n    \n    fragColor.xyz += vec3(c3) * 0.35;\n    \n    fragColor.xyz += vec3(texture(iChannel0, vec2(abs(nuv.x), abs(nuv.y)))).x * 0.7 * (1.0 - abs(nuv.y)) * max(0.0, (1.0 - abs(nuv.x * 1.0)) * m0);\n    \n    /// start white and fade out to color\n    // or blink white on beat\n    fragColor.xyz += vec3(c3 * c3b) * pow(abs(sin(t * bpm * 0.5 - uv.y * 4.0)), 2.5) * 0.15;\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "4dfSWH", "previewfilepath": "https://soundcloud.com/kompakt/siren-33-orphee-mirror?in=kompakt/sets/the-orb-cow-chill-out-world-1", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/kompakt/siren-33-orphee-mirror?in=kompakt/sets/the-orb-cow-chill-out-world-1", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdffDM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdffDS", "name": "Rainbow filter", "author": "cacheflowe", "description": "A simple color shift", "tags": ["rainbow", "roygbiv", "pride"], "likes": 16, "viewed": 821, "date": "1497807801", "time_retrieved": "2024-06-20T18:56:34.438014", "image_code": "#define posterSteps 4.0\n#define lumaMult 0.5\n#define timeMult 0.15\n#define BW 0\n\nfloat rgbToGray(vec4 rgba) {\n\tconst vec3 W = vec3(0.2125, 0.7154, 0.0721);\n    return dot(rgba.xyz, W);\n}\n\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 color = texture(iChannel0, uv);\n    float luma = rgbToGray(color) * lumaMult;\n    float lumaIndex = floor(luma * posterSteps);\n   \tfloat lumaFloor = lumaIndex / posterSteps;\n    float lumaRemainder = (luma - lumaFloor) * posterSteps;\n    if(mod(lumaIndex, 2.) == 0.) lumaRemainder = 1.0 - lumaRemainder; // flip luma remainder for smooth color transitions\n    float timeInc = iTime * timeMult;\n    float lumaCycle = mod(luma + timeInc, 1.);\n    vec3 roygbiv = hsv2rgb(vec3(lumaCycle, 1., lumaRemainder));\n    if(BW == 1) {\n        float bw = rgbToGray(vec4(roygbiv, 1.));\n        fragColor = vec4(vec3(bw), 1.0);\n    } else {\n        fragColor = vec4(roygbiv, 1.0);\n    }\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdffDS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdffRS", "name": "Mandel Oct Vox", "author": "dr2", "description": "Voxel tracing with truncated octahedra", "tags": ["mandelbrot", "voxel", "octahedron", "trunacted"], "likes": 15, "viewed": 700, "date": "1496677079", "time_retrieved": "2024-06-20T18:56:34.444144", "image_code": "// \"Mandel Oct Vox\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Truncated octahedral voxel tracer distilled from culdevu's shader.\n// Architecture from \"Mandel City\" which used a cubic voxel tracer.\n\nvec3 ltDir, cMid;\nfloat dstFar, fcId;\nconst float pi = 3.14159;\n\nbool HitMand (vec3 p)\n{\n  vec3 q;\n  vec2 v, w;\n  float h;\n  h = 0.;\n  p.xz *= 0.03;\n  p.x -= 0.85;\n  q = 0.01 * floor (100. * p);\n  if (length (q.xz + vec2 (0.25, 0.)) > 0.45 &&\n     length (q.xz + vec2 (1., 0.)) > 0.2 &&\n     (q.x < 0. || abs (q.z) > 0.04)) {\n    v = q.xz;\n    h = 80.;\n    for (int j = 0; j < 80; j ++) {\n      w = v * v;\n      if (w.x + w.y > 4.) {\n        h = float (j + 1);\n        break;\n      } else v = q.xz + vec2 (w.x - w.y, 2. * v.x * v.y);\n    }\n  }\n  return (0.3 * h > q.y);\n}\n\nvec3 FcVec (float k)\n{\n  vec3 u;\n  const vec3 e = vec3 (1., 0., -1.);\n  if (k <= 3.) u = (k == 1.) ? e.xyy : ((k == 2.) ? e.yxy : e.yyx);\n  else if (k <= 5.) u = 0.5 * ((k == 4.) ? e.xxx : e.zxx);\n  else u = 0.5 * ((k == 6.) ? e.xzx : e.xxz);\n  return u;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p, cm, fv;\n  float dHit, d, dd, s;\n  cMid = sign (ro) * floor (abs (ro) + 0.5);\n  cm = mod (cMid, 2.);\n  s = cm.x + cm.y + cm.z;\n  if (s == 1. || s == 2.)\n     cMid += step (abs (cm.yzx - cm.zxy), vec3 (0.5)) * sign (ro - cMid);\n  dHit = 0.;\n  for (int j = 0; j < 220; j ++) {\n    p = cMid - (ro + dHit * rd);\n    fcId = 0.;\n    d = dstFar;\n    for (float k = 1.; k <= 7.; k ++) {\n      fv = FcVec (k);\n      s = dot (fv, rd);\n      if (s != 0.) {\n        dd = dot (p + sign (s) * fv, fv)  / s;\n        if (dd < d) {\n          d = dd;\n          fcId = sign (s) * k;\n        }\n      }\n    }\n    cMid = floor (cMid + 2. * sign (fcId) * FcVec (abs (fcId)) + 0.5);\n    dHit += d;\n    if (HitMand (cMid) || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 vn, col;\n  float dstObj;\n  dstObj = ObjRay (ro, rd);\n  ro += rd * dstObj;\n  if (length (ro.xz - vec2 (8., 0.)) > 50.) dstObj = dstFar;\n  if (dstObj < dstFar) {\n    vn = - normalize (sign (fcId) * FcVec (abs (fcId)));\n    col = HsvToRgb (vec3 (mod (0.039 * cMid.y, 1.), 1., 1.));\n    col = col * (0.1 + 0.1 * max (vn.y, 0.) + 0.8 * max (dot (vn, ltDir), 0.)) +\n       0.2 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 128.);\n    col = pow (clamp (col, 0., 1.), vec3 (0.5));\n  } else {\n    col = vec3 (0.9, 0.9, 1.) * (0.6 + 0.4 * rd.y);\n  }\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float az, el, tCur;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  if (mPtr.z > 0.) {\n    az = 1.5 * pi * mPtr.x;\n    el = -0.3 * pi + 0.7 * pi * mPtr.y;\n  } else {\n    az = 0.6 * pi * sin (0.03 * pi * tCur);\n    el = -0.3 * pi + 0.1 * pi * sin (0.05 * pi * tCur);\n  }\n  el = clamp (el, -0.45 * pi, -0.05 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  rd = vuMat * normalize (vec3 (uv, 2.2));\n  ro = vuMat * vec3 (0., -5., -120.);\n  ltDir = vuMat * normalize (vec3 (1., 2.5, -1.));\n  dstFar = 200.;\n  if (0.5 * abs (uv.x) < canvas.y / canvas.x) {\n    ro.xy += vec2 (8., 5.);\n    col = ShowScene (ro, rd);\n  } else col = vec3 (0.9, 0.9, 1.) * (0.6 + 0.4 * rd.y);\n  fragColor = vec4 (col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdffRS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdffWM", "name": "Leblon", "author": "duvengar", "description": "Reproducing the famous Rio de Janeiro's street pattern.", "tags": ["2d", "blackandwhite", "stripes"], "likes": 2, "viewed": 124, "date": "1496376827", "time_retrieved": "2024-06-20T18:56:34.444144", "image_code": "void mainImage( out vec4 C, in vec2 U )\n{  \n    //U.y *= 0.88;\n    U *=  vec2(2,3) / iResolution.x; \n    //U =  U.xy / iResolution.xy * 2.0;\n    U.y -=  iTime / 5.;\n    float wy = cos(U.y * 12.);\n    float wx = sin(U.x * 15.); \n    float w  = cos(U.x * 30.);\n    C = vec4(smoothstep(-0.25, 0.25,mix(wy + wx, wx*1.4, w * 3.)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdffWM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Mdffzf", "name": "Burger", "author": "FMS_Cat", "description": "I'm at Burger King \nPerformance is sooo bad", "tags": ["raymarcher"], "likes": 17, "viewed": 338, "date": "1497245024", "time_retrieved": "2024-06-20T18:56:36.087072", "image_code": "// https://twitter.com/FMS_Cat\n\n// ------\n\n#define MARCH_ITER 50\n#define INIT_LEN 0.01\n#define MARCH_MULT 0.8\n\n#define material float\n#define MTL_NONE 0.0\n#define MTL_BASE 1.0\n#define MTL_MEAT 2.0\n#define MTL_HAPPA 3.0\n#define MTL_CHEESE 4.0\n#define MTL_TOMATO 5.0\n\n#define V vec2(0.,1.)\n#define PI 3.14159265\n#define HUGE 1E9\n#define saturate(i) clamp(i,0.,1.)\n#define lofi(i,d) floor(i/d)*d\n\n// ------\n\n// \nprecision mediump float;\n\n// JS\nuniform float time;\nuniform vec2 resolution;\nuniform vec2 mouse;\n\n// ------\n\n// \nmat2 rotate2D( float _t ) {\n  return mat2(\n    cos( _t ), sin( _t ),\n    -sin( _t ), cos( _t )\n  );\n}\n\n// smooth minimum : http://iquilezles.org/www/articles/smin/smin.htm\nfloat smin( float _a, float _b, float _k, out float h ) {\n  h = clamp( 0.5 + 0.5 * ( _b - _a ) / _k, 0.0, 1.0 );\n  return mix( _b, _a, h ) - _k * h * ( 1.0 - h );\n}\n\nfloat smin( float _a, float _b, float _k ) {\n  float h;\n  return smin( _a, _b, _k, h );\n}\n\nfloat random( vec2 _uv ) {\n  return fract( sin( dot( vec2( 12.563, 21.864 ), _uv ) ) * 19934.54 );\n}\n\nfloat iRandom( vec2 _uv ) {\n  float v00 = random( floor( _uv + V.xx ) );\n  float v10 = random( floor( _uv + V.yx ) );\n  float v01 = random( floor( _uv + V.xy ) );\n  float v11 = random( floor( _uv + V.yy ) );\n  return mix(\n    mix( v00, v10, smoothstep( 0.0, 1.0, fract( _uv.x ) ) ),\n    mix( v01, v11, smoothstep( 0.0, 1.0, fract( _uv.x ) ) ),\n    smoothstep( 0.0, 1.0, fract( _uv.y ) )\n  );\n}\n\nfloat noise( vec2 _uv ) {\n  float sum = 0.0;\n  for ( int i = 0; i < 4; i ++ ) {\n    float p = pow( 2.0, float( i ) + 1.0 );\n    sum += iRandom( _uv * p * 4.0 ) / p;\n  }\n  return sum;\n}\n\nvec3 rainbow( vec3 _i, float _p ) {\n  float p = fract( _p );\n  return mix(\n    mix(\n      mix(\n        _i.xyz,\n        _i.yzx,\n        saturate( p * 3.0 )\n      ),\n      _i.zxy,\n      saturate( p * 3.0 - 1.0 )\n    ),\n    _i.xyz,\n    saturate( p * 3.0 - 2.0 )\n  );\n}\n\n// ------\n\n// \nstruct Camera {\n  vec3 pos;\n  vec3 dir;\n  vec3 sid;\n  vec3 top;\n  float fov;\n};\n\n// \nstruct Ray {\n  vec3 dir;\n  vec3 ori;\n};\n\n// ------\n\n// \nCamera camInit( in vec3 _pos, in vec3 _tar, in float _fov ) {\n  Camera cam;\n  cam.pos = _pos;\n  cam.dir = normalize( _tar - _pos );\n  cam.sid = normalize( cross( cam.dir, V.xyx ) );\n  cam.top = normalize( cross( cam.sid, cam.dir ) );\n  cam.fov = _fov;\n\n  return cam;\n}\n\n// \nRay rayInit( in vec3 _ori, in vec3 _dir ) {\n  Ray ray;\n  ray.dir = _dir;\n  ray.ori = _ori;\n  return ray;\n}\n\n// \nRay rayFromCam( in vec2 _p, in Camera _cam ) {\n  vec3 dir = normalize(\n    _p.x * _cam.sid\n    + _p.y * _cam.top\n    + _cam.dir / tan( _cam.fov * PI / 360.0 ) // Is this correct?\n  );\n  return rayInit( _cam.pos, dir );\n}\n\n// ------\n\n// \nfloat distFuncSphere( vec3 _p, float _r ) {\n  return length( _p ) - _r;\n}\n\n// \nfloat distFuncBox( vec3 _p, vec3 _s ) {\n  vec3 d = abs( _p ) - _s;\n  return min( max( d.x, max( d.y, d.z ) ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\n// \nfloat distFuncTorus( vec3 _p, float _r, float _R ) {\n  vec2 q = vec2( length( _p.xz ) - _R, _p.y );\n  return length( q ) - _r;\n}\n\n// \nfloat distFuncPillar( vec3 _p, float _r, float _t ) {\n  return max( abs( _p.y ) - _t, length( _p.xz ) - _r );\n}\n\n// xzRepetition\nvec3 circleRep( vec3 _p, float _r, float _c ) {\n  vec3 p = _p;\n  float intrv = PI * 2.0 / _c;\n  p.zx = rotate2D( floor( atan( p.z, p.x ) / intrv ) * intrv ) * p.zx;\n  p.zx = rotate2D( intrv / 2.0 ) * p.zx;\n  p.x -= _r;\n  return p;\n}\n\n// \nfloat distFunc( vec3 _p, out material mtl ) {\n  vec3 p = _p;\n  float dist = HUGE;\n  \n  { // base\n    vec3 p = p;\n    p.y -= -0.3;\n    vec3 ps = p;\n    ps.y += ( noise( p.xz * 0.2 - 0.7 ) - 0.5 ) * 0.1;\n    float distt = distFuncPillar( p, 0.85, 0.02 );\n    distt = smin( distt, distFuncTorus( ps, 0.1, 0.9 ), 0.1 );\n    mtl = distt < dist ? MTL_BASE : mtl;\n    dist = distt < dist ? distt : dist;\n  }\n  \n  { // top\n    vec3 p = p;\n    p.y *= 2.5;\n    p.y -= 0.3;\n    vec3 ps = p;\n    ps.y += ( noise( p.xz * 0.2 - 0.7 ) - 0.5 ) * 0.2;\n    float distt = max(\n      distFuncSphere( ps, 1.0 ),\n      -p.y\n    );\n    mtl = distt < dist ? MTL_BASE : mtl;\n    dist = distt < dist ? distt : dist;\n  }\n  \n  { // niku\n    vec3 p = p;\n    p.y += ( noise( p.zx * 0.4 - 0.4 ) - 0.5 ) * 0.1;\n    p.x += ( noise( p.yz * 0.4 - 0.4 ) - 0.5 ) * 0.1;\n    p.z += ( noise( p.xy * 0.4 - 0.4 ) - 0.5 ) * 0.1;\n    p.y -= -0.15;\n    float distt = distFuncPillar( p, 1.0, 0.03 );\n    distt = smin( distt, distFuncTorus( p, 0.05, 1.0 ), 0.1 );\n    mtl = distt < dist ? MTL_MEAT : mtl;\n    dist = distt < dist ? distt : dist;\n  }\n  \n  { // happa\n    vec3 p = p;\n    p += vec3(\n      noise( p.yz * 0.4 - 0.7 ) - 0.5,\n      noise( p.zx * 0.4 - 0.7 ) - 0.5,\n      noise( p.xy * 0.4 - 0.7 ) - 0.5\n    ) * 0.4 * smoothstep( 1.0, 1.1, length( p.xz ) );\n    p.y -= 0.1;\n    p.xz = rotate2D( 1.0 ) * p.xz;\n    float distt = distFuncPillar( p, 1.15, 0.02 );\n    mtl = distt < dist ? MTL_HAPPA : mtl;\n    dist = distt < dist ? distt : dist;\n  }\n  \n  { // cheese\n    vec3 p = p;\n    p.y -= -0.05;\n    p.y -= -0.2 * smoothstep( 1.0, 1.5, length( p.xz ) );\n    p.xz = rotate2D( 1.0 ) * p.xz;\n    float distt = distFuncBox( p, vec3( 0.95, 0.02, 0.95 ) );\n    mtl = distt < dist ? MTL_CHEESE : mtl;\n    dist = distt < dist ? distt : dist;\n  }\n  \n  { // tomato\n    vec3 p = p;\n    p.y -= 0.02;\n    p = circleRep( p, 0.6, 3.0 );\n    p.xz = rotate2D( 1.0 ) * p.xz;\n    float distt = distFuncPillar( p, 0.5, 0.05 );\n    float fresh = 0.99 * smoothstep( 0.15, 0.4, length( p ) ) * smoothstep( 0.45, 0.4, length( p ) );\n    fresh *= 0.5 + 0.5 * sin( atan( p.z, p.x ) * 16.0 );\n    mtl = distt < dist ? ( MTL_TOMATO + fresh ) : mtl;\n    dist = distt < dist ? distt : dist;\n  }\n  \n  return dist;\n}\n\nfloat distFunc( vec3 _p ) {\n  material dummy = MTL_NONE;\n  return distFunc( _p, dummy );\n}\n\n// \nvec3 normalFunc( in vec3 _p ) {\n  vec2 d = V * 1E-3;\n  return normalize( vec3(\n    distFunc( _p + d.yxx ) - distFunc( _p - d.yxx ),\n    distFunc( _p + d.xyx ) - distFunc( _p - d.xyx ),\n    distFunc( _p + d.xxy ) - distFunc( _p - d.xxy )\n  ) );\n}\n\n// ------\n\nvec4 draw( vec2 p, float time ) { \n  // \n  Camera cam = camInit(\n    vec3( cos( time ) * 4.0, 1.0, sin( time ) * 4.0 ),\n    vec3( 0.0, -0.2, 0.0 ),\n    50.0\n  );\n  Ray ray = rayFromCam( p, cam );\n\n  // ------\n\n  float rayLen = INIT_LEN; // \n  vec3 rayPos = ray.ori + rayLen * ray.dir; // \n  float rayDist = 0.0; // \n  material mtl = MTL_NONE;\n\n  // raymarch\n  for ( int i = 0; i < MARCH_ITER; i ++ ) {\n    rayDist = distFunc( rayPos, mtl );\n    rayLen += rayDist * MARCH_MULT;\n    rayPos = ray.ori + rayLen * ray.dir;\n    if ( 10.0 < rayLen ) { return vec4( 0.0 ); }\n    if ( abs( rayDist ) < 1E-4 ) { break; }\n  }\n\n  vec4 col = V.xxxx; // \n  if ( abs( rayDist ) < 1E-2 ) { // \n    // \n    vec3 normal = normalFunc( rayPos );\n    vec3 camDir = normalize( rayPos - cam.pos );\n    vec3 ligPos = cam.pos + cam.sid + cam.top * 1.0 - cam.dir;\n    vec3 ligDir = normalize( rayPos - ligPos );\n\n    // \n    float dif = 0.5 + 0.5 * dot( -normal, ligDir );\n    float spe = pow( dot( normalize( camDir - normal ), ligDir ), 40.0 );\n    \n    // \n    vec3 mtlCol = vec3( 0.0 );\n    float mtlSpe = 0.0;\n\t  \n    if ( floor( mtl ) == MTL_BASE ) {\n      mtlCol = vec3( 1.0, 0.4, 0.1 );\n      mtlSpe = 0.5;\n\t  \n    } else if ( floor( mtl ) == MTL_MEAT ) {\n      float yaki = smoothstep( 0.4, 0.8, noise( rayPos.xz * 4.0 ) );\n      mtlCol = mix( vec3( 0.6, 0.4, 0.2 ), vec3( 0.1 ), yaki * 0.4 );\n      mtlSpe = 0.2;\n\t    \n    } else if ( floor( mtl ) == MTL_HAPPA ) {\n      mtlCol = vec3( 0.6, 0.8, 0.2 );\n      mtlSpe = 0.5;\n\t    \n    } else if ( floor( mtl ) == MTL_CHEESE ) {\n      mtlCol = vec3( 0.9, 0.7, 0.1 );\n      mtlSpe = 0.4;\n\t    \n    } else if ( floor( mtl ) == MTL_TOMATO ) {\n      float fresh = fract( mtl );\n      mtlCol = mix( vec3( 0.9, 0.2, 0.2 ), vec3( 1.0, 0.9, 0.7 ), fresh );\n      mtlSpe = mix( 0.5, 0.8, fresh );\n    }\n\n    // \n    col.xyz += mtlCol * dif;\n    col.xyz += mtlSpe * spe;\n    col.w = 1.0;\n\t  \n    return col;\n  } else { // \n    return vec4( 0.0 );\n  }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 p = ( fragCoord.xy * 2.0 - iResolution.xy ) / iResolution.x;\n  fragColor = draw( p, iTime );\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mdffzf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdlBW7", "name": "Volatile Sphere of Cubes", "author": "knarkowicz", "description": "100% pure code without artificial textures", "tags": ["raymarching", "sdf", "cube", "sphere"], "likes": 36, "viewed": 1314, "date": "1496615864", "time_retrieved": "2024-06-20T18:56:36.087072", "image_code": "const float MATH_PI = float( 3.14159265359 );\n\nfloat saturate( float x )\n{\n    return clamp( x, 0.0, 1.0 );\n}\n\nfloat Sphere( vec3 p, float s )\n{\n\treturn length( p ) - s;\n}\n\nfloat RoundBox( vec3 p, vec3 b, float r )\n{\n\treturn length( max( abs( p ) - b, 0.0 ) ) - r;\n}\n\nfloat Union( float a, float b )\n{\n    return min( a, b );\n}\n\nfloat RepeatAngle( inout vec2 p, float n ) \n{\n\tfloat angle = 2.0 * MATH_PI / n;\n\tfloat a = atan( p.y, p.x ) + angle / 2.0;\n\tfloat r = length( p );\n\tfloat c = floor( a / angle );\n\ta = mod( a, angle ) - angle / 2.;\n\tp = vec2( cos( a ), sin( a ) ) * r;\n\treturn c;\n}\n\nvoid Rotate( inout vec2 p, float a ) \n{\n    p = cos( a ) * p + sin( a ) * vec2( p.y, -p.x );\n}\n\nfloat Scene( vec3 p )\n{\n    float a = p.x;\n    p.x = -p.y;\n    p.y = a;\n    \n    Rotate( p.yz, iTime );    \n    \n    // sphere\n    float ret = Sphere( p, 0.6 );\n    for ( float i = -5.0; i < 6.0; ++i )\n    {\n        float theta   = ( i / 6.0 ) * MATH_PI * 0.5;\n        float boxNum  = 12.0;\n        float radius  = cos( theta ) * 0.7;\n        float boxSize = abs( radius ) * 0.12;\n        float boxOffset = -sin( theta ) * 0.7;\n                \n        Rotate( p.yz, MATH_PI / ( 2.0 * boxNum ) );\n        \n        vec3 t = p;\t\t\n\t\tfloat boxLen = 0.15 + sin( iTime * 2.0 ) * 0.1;        \n    \tt = p + vec3( boxOffset, 0.0, 0.0 );\n    \tRepeatAngle( t.yz, boxNum );\n    \tt.y -= radius;\n        Rotate( t.xy, -theta );\n    \tret = Union( ret, RoundBox( t, vec3( boxSize, boxLen, boxSize ), 0.02 ) );\n        \n\t\tt = p;\n\t\tboxLen = 0.15 + sin( iTime * 3.0 ) * 0.1;        \n\t\tRotate( p.yz, MATH_PI / boxNum );\n    \tt = p + vec3( boxOffset, 0.0, 0.0 );\n    \tRepeatAngle( t.yz, boxNum );\n    \tt.y -= radius;\n        Rotate( t.xy, -theta );\n    \tret = Union( ret, RoundBox( t, vec3( boxSize, boxLen, boxSize ), 0.02 ) );\n    }\n    \n    // debris\n    vec3 t = p;\n    t.y = abs( t.y + 0.3 * sin( 1.7 * iTime ) );\n    t.z = abs( t.z );\n    t -= vec3( 0.8, 1.0, 1.0 );\n    Rotate( t.xz, iTime );    \n\tRotate( t.xy, -0.25 );\n    ret = Union( ret, RoundBox( t, vec3( 0.01 ), 0.005 ) );\n    \n    Rotate( p.xy, 0.1 * iTime );\n    Rotate( p.yz, MATH_PI * 0.25 );\n    t = p;\n    t.y = abs( t.y + 0.3 * sin( 1.7 * iTime ) );\n    t.z = abs( t.z );\n    t -= vec3( 0.8, 1.0, 1.0 );\n    Rotate( t.xz, iTime );    \n\tRotate( t.xy, -0.25 );    \n    ret = Union( ret, RoundBox( t, vec3( 0.01 ), 0.005 ) );    \n\n\treturn ret;\n}\n\nfloat CastRay( in vec3 ro, in vec3 rd )\n{\n    const float maxd = 5.0;\n    \n\tfloat h = 1.0;\n    float t = 0.0;\n   \n    for ( int i = 0; i < 50; ++i )\n    {\n        if ( h < 0.001 || t > maxd ) \n        {\n            break;\n        }\n        \n\t    h = Scene( ro + rd * t );\n        t += h;\n    }\n\n    if ( t > maxd )\n    {\n        t = -1.0;\n    }\n\t\n    return t;\n}\n\nvec3 SceneNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 normal = vec3(\n\t    Scene( pos + eps.xyy ) - Scene( pos - eps.xyy ),\n\t    Scene( pos + eps.yxy ) - Scene( pos - eps.yxy ),\n\t    Scene( pos + eps.yyx ) - Scene( pos - eps.yyx ) );\n\treturn normalize( normal );\n}\n\nvec3 KeyColor = vec3( 1.0, 0.98, 0.94 );\nvec3 FillColor = vec3( 0.09, 0.19, 0.25 ); \n\nvec3 Sky( vec3 rayDir )\n{\n    vec3 skyPos     = rayDir;\n    vec2 skyAngle   = vec2( atan( skyPos.z, skyPos.x ), acos( skyPos.y ) );\n\n    vec3 color = KeyColor * mix( 1.0, 0.4, smoothstep( 0.0, 1.0, saturate( 1.5 * skyPos.y + 0.1 ) ) );\n    color = mix( color, FillColor, smoothstep( 0.0, 1.0, saturate( -1.5 * skyPos.y - 0.1 ) ) );\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n\tp.x *= iResolution.x / iResolution.y;\n\n    vec3 rayOrigin\t= vec3( 0.0, -0.2, -3.0 );\n\tvec3 rayDir \t= normalize( vec3( p.xy, 2.0 ) ); \n\n\tvec3 color = Sky( rayDir );\n\tfloat t = CastRay( rayOrigin, rayDir );\n    if ( t > 0.0 )\n    {\n        vec3 pos = rayOrigin + t * rayDir;\n        vec3 normal = SceneNormal( pos );\n        vec3 lightDir = normalize( vec3( 0.5, 0.5, -1.0 ) );\n            \n        // ambient, diffuse and specular\n        color = 0.8 * mix( FillColor, KeyColor, 0.5 * normal.y + 0.5 );\n        float specOcc = 0.3 + 0.7 * smoothstep( 0.0, 1.0, saturate( 2.0 * length( pos.xy ) ) );\n        float fresnel = saturate( pow( 1.4 + dot( rayDir, normal ), 5.0 ) ) * specOcc;\n        color += 0.5 * Sky( normal ) * mix( 0.1, 1.0, fresnel );\n        color += 0.3 * KeyColor * saturate( dot( normal, lightDir ) );\n        color *= 0.85;\n    }\n    else\n    {\n        // sphere shadow\n        float planeT = -( rayOrigin.y + 1.2 ) / rayDir.y;\n        if ( planeT > 0.0 )\n        {\n            vec3 p = rayOrigin + planeT * rayDir;\n            \n            float radius = max( 0.15 + sin( iTime * 2.0 ) * 0.1, 0.15 + sin( iTime * 3.0 ) * 0.1 );\n            color *= 0.7 + 0.3 * smoothstep( 0.0, 1.0, saturate( length( p + vec3( 0.0, 1.0, 0.0 ) ) - radius ) );\n        }\t\t\n    }\n    \n    float vignette = q.x * q.y * ( 1.0 - q.x ) * ( 1.0 - q.y );\n    vignette = saturate( pow( 32.0 * vignette, 0.05 ) );\n    color *= vignette;\n        \n    fragColor = vec4( color, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdlBW7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdlfD7", "name": "2D Rotation Visualisation", "author": "gilesruscoe", "description": "The relationship between 2D rotation and sin/cos", "tags": ["2d", "math", "visualization", "lines", "sin", "cos", "curve", "dots", "rotation", "visualisation", "points", "vectors"], "likes": 11, "viewed": 308, "date": "1496552780", "time_retrieved": "2024-06-20T18:56:36.087072", "image_code": "#define AA 6.0 / iResolution.y\n#define SIZE 0.75\n\nfloat disk(vec2 uv, vec2 center, float radius)\n{\n    float d = length(uv - center);\n    return smoothstep(d, d + 0.01, radius);\n}\n\nfloat line(vec2 uv, vec2 a, vec2 b, float width)\n{\n    vec2 pa = uv - a;\n    vec2 ba = b - a;\n\tfloat h = clamp(dot(pa,ba) / dot(ba,ba), 0.0, 1.0);\t\n\treturn 1.0 - smoothstep(-AA, AA, length(pa - ba * h) - width);\n}\n\nfloat cosLine(vec2 uv, float width)\n{\n    return smoothstep(AA, -AA, length(cos(iTime - uv.x) - uv.y) - width);\n}\n\nfloat sinLine(vec2 uv, float width)\n{\n    return smoothstep(AA, -AA, length(sin(iTime - uv.y) - uv.x) - width);\n}\n\nfloat circle(vec2 uv, vec2 center, float radius)\n{\n    return smoothstep(AA, -AA, abs(length(uv - center)-radius));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    //Uvs\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y / SIZE;\n    \n    //Cos and Sin waves power the rotation angle\n    float sinx = sin(iTime);\n    float cosx = cos(iTime);\n    \n    //Lines showing indivisual axis movements\n    float lineSX = line(uv, vec2(sinx, -1.0), vec2(sinx, 1.0), 0.005);\n    float lineCX = line(uv, vec2(-1.0, cosx), vec2(1.0, cosx), 0.005);\n    \n    //Points of interest\n    vec2 pRot = vec2(sinx, cosx);\n    vec2 pOrigin = vec2(0);\n    float p0 = disk(uv, pOrigin, 0.04);\n    float p1 = disk(uv, vec2(sinx, 0.0), 0.03);\n    float p2 = disk(uv, vec2(0.0, cosx), 0.03);\n    float p3 = disk(uv, pRot, 0.04);\n    \n    //Lazy single channel colours...\n    fragColor = vec4(0.1);\n\tfragColor.x += max(lineSX, p1);\n    fragColor.y += max(lineCX, p2);\n    float rotLine =  max(p3 + p0, line(uv, pOrigin, pRot, 0.01));\n    fragColor.xyz += max(rotLine, circle(uv, pOrigin, 1.0));\n    fragColor.xyz += cosLine(uv, 0.005) * 0.25;\n    fragColor.xyz += sinLine(uv, 0.005) * 0.25;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdlfD7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdlfDj", "name": "Bezier Colors", "author": "joshforisha", "description": "A demo of color-shifting using bezier curves.", "tags": ["bezier"], "likes": 2, "viewed": 105, "date": "1498247775", "time_retrieved": "2024-06-20T18:56:36.565527", "image_code": "vec3 green = vec3(0.0, 1.0, 0.0);\nvec3 pinkSalmon = vec3(1.000, 0.589, 0.718);\nvec3 white = vec3(1.0, 1.0, 1.0);\nvec3 wisteria = vec3(0.620, 0.402, 0.694);\n\nfloat cerp (float a, float b, float c, float d, float u) {\n    return (a * pow(1.0 - u, 3.0)) +\n        (3.0 * b * pow(1.0 - u, 2.0) * u) +\n        (3.0 * c * (1.0 - u) * pow(u, 2.0)) +\n        (d * pow(u, 3.0));\n}\n\nfloat cirp (vec4 v, float t) {\n    return v[0]*pow(t, 3.0) + v[1]*pow(t, 2.0) + v[2]*t + v[3];\n}\n\nvec4 infl (float a, float b, float c, float d) {\n    return vec4(\n        d - 3.0*c + 3.0*b - a,\n        3.0*c - 6.0*b + 3.0*a,\n        3.0*b - 3.0*a,\n        a\n    );\n}\n\nfloat slope (float a, float b, float c, float t) {\n    return 1.0 / (3.0*a*pow(t, 2.0) + 2.0*b*t + c);\n}\n\nfloat cubicBezier (vec4 curve, float u) {\n    vec4 ix = infl(0.0, curve[0], curve[2], 1.0);\n    vec4 iy = infl(0.0, curve[1], curve[3], 1.0);\n    \n    float v = u;\n    int nRefinements = 10;\n    for (int i = 0; i < nRefinements; i++) {\n        float x = cirp(ix, v);\n        float slp = slope(ix[0], ix[1], ix[2], v);\n        v = clamp(v - ((x - u) * slp), 0.0, 1.0);\n    }\n    \n    return cirp(iy, v);\n}\n\nfloat plot (float val, float pct) {\n    return smoothstep(pct - 0.02, pct, val) -\n           smoothstep(pct, pct + 0.02, val);\n}\n\n// CURVES!\nvec4 easeInOutCirc = vec4(0.785, 0.135, 0.15, 0.86);\nvec4 easeInOutCubic = vec4(0.645, 0.045, 0.355, 1.000);\nvec4 easeInOutExpo = vec4(1.0, 0.0, 0.0, 1.0);\nvec4 easeInOutQuad = vec4(0.455, 0.03, 0.515, 0.955);\nvec4 easeInOutQuart = vec4(0.77, 0.0, 0.175, 1.0);\nvec4 easeInOutQuint = vec4(0.86, 0.0, 0.07, 1.0);\nvec4 easeInOutSine = vec4(0.445, 0.05, 0.55, 0.95);\n\nvec4 easeInCirc = vec4(0.6, 0.04, 0.98, 0.335);\nvec4 easeInCubic = vec4(0.55, 0.055, 0.675, 0.19);\nvec4 easeInExpo = vec4(0.95, 0.05, 0.795, 0.035);\nvec4 easeInQuad = vec4(0.55, 0.085, 0.68, 0.53);\nvec4 easeInQuart = vec4(0.895, 0.03, 0.685, 0.22);\nvec4 easeInQuint = vec4(0.755, 0.05, 0.855, 0.06);\nvec4 easeInSine = vec4(0.47, 0.0, 0.745, 0.715);\n\nvec4 easeOutCirc = vec4(0.075, 0.82, 0.165, 1.0);\nvec4 easeOutCubic = vec4(0.215, 0.61, 0.355, 1.0);\nvec4 easeOutExpo = vec4(0.19, 1.0, 0.22, 1.0);\nvec4 easeOutQuad = vec4(0.25, 0.46, 0.45, 0.94);\nvec4 easeOutQuart = vec4(0.165, 0.84, 0.44, 1.0);\nvec4 easeOutQuint = vec4(0.23, 1.0, 0.32, 1.0);\nvec4 easeOutSine = vec4(0.39, 0.575, 0.565, 1.0);\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n\t// Change this to any of the above curves:\n\tvec4 curve = easeInOutQuad;\n\n\t// Set speed, in seconds:\n\tfloat speed = 2.0;\n    \n    vec2 st = fragCoord.xy / float(iResolution);\n    float t = 1.0 - abs((mod(iTime, 2.0 * speed) - speed) / speed);\n    float timed = cubicBezier(curve, t);\n    float plotted = plot(st.y * 1.778, cubicBezier(curve, st.x));\n    float indicated = plot(st.x, t);\n    \n    vec3 baseColor = mix(wisteria, pinkSalmon, timed);\n    vec3 bgColor = mix(baseColor, white, indicated);\n    vec3 color = mix(bgColor, green, plotted);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdlfDj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdlfRl", "name": "Closely Watched Dolphins", "author": "dr2", "description": " Dolphins in a hexagonal crystal reef. The default view tracks the nearest dolphin;\n override using the mouse.\n", "tags": ["raymarch", "voxel", "hexagon", "bubble", "underwater", "dolphin"], "likes": 17, "viewed": 1124, "date": "1497620302", "time_retrieved": "2024-06-20T18:56:39.414340", "image_code": "// \"Closely Watched Dolphins\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrSphAnDf (vec3 p, float r, float w);\nfloat PrEllipsDf (vec3 p, vec3 r);\nvec2 Rot2D (vec2 q, float a);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec3 HsvToRgb (vec3 c);\nfloat Hashfv2 (vec2 p);\nvec3 Hashv3f (float p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define N_FISH 2\n#define SQRT3 1.73205\n\nvec3 fishPos[N_FISH], vuPos, sunDir, cHit, cHitP, qnHit, qHit;\nfloat fishAngH[N_FISH], fishAngV[N_FISH], fishAngI, tCur, dstFar;\nint idObj;\nconst float hcScale = 20.;\nconst vec3 hcSize = vec3 (0.5 * SQRT3, 1., 1.3);\nconst vec3 bcSize = vec3 (0.5, 1., 0.5);\nconst float pi = 3.14159;\n\nvec3 TrackPath (float t)\n{\n  return vec3 (4. * sin (0.08 * t) + 1.5 * sin (0.11 * t),\n     2. * sin (0.09 * t) + 0.4 * sin (0.13 * t), t);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec2 c, r, dr;\n  c = vec2 ((2. / SQRT3) * p.x, p.y);\n  r = floor (c);\n  r += mod (vec2 (r.x, r.y + step (2., mod (r.x + 1., 4.))), 2.);\n  dr = c - r;\n  r += step (1., 0.5 * dot (abs (dr), vec2 (SQRT3, 1.))) * sign (dr) * vec2 (2., 1.);\n  return r;\n}\n\nbool HexCellFull (vec3 p)\n{\n  float hs, hb;\n  p = (p * hcSize).yzx / hcScale;\n  p.xy -= TrackPath (p.z).xy;\n  p += 0.1 * (1. - cos (2. * pi * (p + 0.2 * (1. - cos (2. * pi * p.zxy)))));\n  hs = length (cos (0.6 * p - 0.5 * sin (1.4 * p.zxy +\n     0.4 * cos (2.7 * p.yzx)))) - 1.1;\n  hb = 4. - p.y;\n  idObj = (hs > hb) ? 0 : 1;\n  return (min (hs, hb) < 0.);\n}\n\nfloat HexVolRay (vec3 ro, vec3 rd)\n{\n  vec3 ht, htt, w;\n  vec2 hv[3], ve;\n  float dHit, ty, dy;\n  ro *= hcScale;\n  cHit = vec3 (PixToHex (ro.zx), floor (ro.y / hcSize.z + 0.5));\n  hv[0] = vec2 (0., 1.);\n  hv[1] = vec2 (1., 0.5);\n  hv[2] = vec2 (1., -0.5);\n  for (int k = 0; k < 3; k ++)\n     hv[k] *= sign (dot (hv[k], vec2 (0.5 * SQRT3 * rd.z, rd.x)));\n  dy = sign (rd.y);\n  qnHit = vec3 (0.);\n  dHit = dstFar * hcScale + 0.01;\n  for (int j = 0; j < 200; j ++) {\n    w = ro - (cHit * hcSize).yzx;\n    ht.z = 1e6;\n    for (int k = 0; k < 3; k ++) {\n      ve = vec2 (0.5 * SQRT3 * hv[k].x, hv[k].y);\n      htt = vec3 (hv[k], (1. - dot (ve, w.zx)) / dot (ve, rd.zx));\n      if (htt.z < ht.z) ht = htt;\n    }\n    ty = (0.5 * dy * hcSize.z - w.y) / rd.y;\n    cHitP = cHit;\n    if (ht.z < ty) cHit.xy += 2. * ht.xy;\n    else cHit.z += dy;\n    if (HexCellFull (cHit)) {\n      if (ht.z < ty) {\n        qnHit = - vec3 (0.5 * SQRT3 * ht.x, ht.y, 0.);\n        dHit = ht.z;\n      } else {\n        qnHit = - vec3 (0., 0., dy);\n        dHit = ty;\n      }\n      break;\n    }\n  }\n  return dHit / hcScale;\n}\n\nfloat HexFaceDist (vec3 p)\n{\n  vec4 h[4];\n  vec3 cNeb, vh;\n  float d;\n  p = p.zxy * hcScale - cHitP * hcSize;\n  p.z *= 2. / hcSize.z;\n  h[0] = vec4 (0., 1., 0., 1.);\n  h[1] = vec4 (1., 0.5, 0., 1.);\n  h[2] = vec4 (1., -0.5, 0., 1.);\n  h[3] = vec4 (0., 0., 0.5, 0.5 * hcSize.z);\n  d = 1e5;\n  for (int k = 0; k < 4; k ++) {\n    vh = h[k].xyz;\n    cNeb = cHitP + 2. * vh;\n    if (cNeb != cHit && HexCellFull (cNeb))\n\td = min (d, h[k].w - dot (vh * hcSize, p));\n    cNeb = cHitP - 2. * vh;\n    if (cNeb != cHit && HexCellFull (cNeb))\n\td = min (d, h[k].w + dot (vh * hcSize, p));\n  }\n  return d;\n}\n\nvec3 HexVolCol (vec3 p, float edgDist, float dHit)\n{\n  vec3 col;\n  col = HsvToRgb (vec3 (Hashfv2 (cHit.xy), 0.5, 1.));\n  col.r *= 0.1 + 0.9 * smoothstep (-0.5, 0.5, p.y) *\n     (1. - smoothstep (0., 5., dHit));\n  if (qnHit.z != 0.) col *= 0.7 + 0.3 * smoothstep (0., 0.7, abs (edgDist));\n  return col;\n}\n\nfloat WatShd (vec3 rd)\n{\n  vec2 p;\n  float t, h;\n  p = 10. * rd.xz / rd.y;\n  t = tCur * 2.;\n  h = sin (p.x * 2. + t * 0.77 + sin (p.y * 0.73 - t)) +\n     sin (p.y * 0.81 - t * 0.89 + sin (p.x * 0.33 + t * 0.34)) +\n     (sin (p.x * 1.43 - t) + sin (p.y * 0.63 + t)) * 0.5;\n  h *= smoothstep (0.5, 1., rd.y) * 0.04;\n  return h;\n}\n\nfloat EdgeDist (vec3 p)\n{\n  vec2 dh;\n  float d;\n  p *= hcScale;\n  dh = p.zx - cHit.xy * vec2 (0.5 * SQRT3, 1.);\n  if (qnHit.z == 0.) {\n    d = abs (fract (p.y / hcSize.z) - 0.5) * hcSize.z;\n    dh -= qnHit.xy * dot (dh, qnHit.xy);\n    d = min (d, abs (length (dh) - 1. / SQRT3));\n  } else {\n    dh = abs (dh);\n    d = max (0.5 * dot (dh, vec2 (SQRT3, 1.)), dh.y) - 1.;\n  }\n  return d;\n}\n\nfloat FishDf (vec3 p)\n{\n  vec3 q;\n  float dMin, dBodyF, dBodyB, dMouth, dFinT, dFinP, dFinD, dEye, d;\n  p.x = abs (p.x);\n  p.z -= 2.;\n  p.yz = Rot2D (p.yz, 0.2 * fishAngI);\n  q = p;\n  q.z -= -0.6;\n  dBodyF = PrEllipsDf (q, vec3 (0.7, 0.8, 2.4));\n  q = p;\n  q.z -= -1.2;\n  q.yz = Rot2D (q.yz, fishAngI);\n  q.z -= -1.6;\n  dBodyB = PrEllipsDf (q, vec3 (0.35, 0.5, 2.5));\n  q.z -= -2.2;\n  q.yz = Rot2D (q.yz, 2. * fishAngI);\n  q.xz -= vec2 (0.5, -0.5);\n  q.xz = Rot2D (q.xz, 0.4);\n  dFinT = PrEllipsDf (q, vec3 (0.8, 0.07, 0.4));\n  q = p;\n  q.yz -= vec2 (-0.3, 1.7);\n  q.yz = Rot2D (q.yz, 0.1);\n  q.y = abs (q.y) - 0.04;\n  dMouth = PrEllipsDf (q, vec3 (0.25, 0.12, 0.6));\n  q = p;\n  q.yz -= vec2 (0.7, -1.);\n  q.yz = Rot2D (q.yz, 0.6);\n  dFinD = PrEllipsDf (q, vec3 (0.05, 1., 0.35));\n  q = p;\n  q.xy = Rot2D (q.xy, 0.8);\n  q.xz -= vec2 (0.7, -0.1);\n  q.xz = Rot2D (q.xz, 0.6);\n  dFinP = PrEllipsDf (q, vec3 (0.9, 0.04, 0.3));\n  q = p;\n  q -= vec3 (0.4, -0.1, 1.1);\n  dEye = PrEllipsDf (q, vec3 (0.11, 0.15, 0.15));\n  idObj = 11;\n  dMin = SmoothMin (dBodyF, dBodyB, 0.3);\n  dMin = SmoothMin (dMin, dFinT, 0.1);\n  dMin = SmoothMin (dMin, dMouth, 0.15);\n  dMin = SmoothMin (dMin, dFinD, 0.02);\n  dMin = SmoothMin (dMin, dFinP, 0.02);\n  if (dEye < dMin) idObj = 12;\n  dMin = SmoothMin (dMin, dEye, 0.01);\n  qHit = q;\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qHitA;\n  float dMin, d, szFac;\n  int idObjA;\n  szFac = 8.;\n  dMin = dstFar * szFac;\n  for (int k = 0; k < N_FISH; k ++) {\n    q = (p - fishPos[k]) * szFac;\n    q.xz = Rot2D (q.xz, fishAngH[k]);\n    q.yz = Rot2D (q.yz, fishAngV[k]);\n    d = FishDf (q);\n    if (d < dMin) {\n      idObjA = idObj;\n      qHitA = qHit;\n      dMin = d;\n    }\n  }\n  idObj = idObjA;\n  qHit = qHitA;\n  return dMin / szFac;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + rd * dHit);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 1.;\n  for (int j = 0; j < 30; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += 0.08 * (1. + 0.1 * d);\n    if (sh < 0.05) break;\n  }\n  return 0.3 + 0.7 * sh;\n}\n\nfloat BubDf (vec3 p, vec3 vr)\n{\n  float s, d, a;\n  vr -= 0.5;\n  s = fract (64. * dot (vr, vec3 (1.)));\n  d = 0.1 * s * abs (vr.x * sin (3. * pi * s * (tCur + vr.y)));\n  a = 0.03 * pi * vr.z * tCur;\n  p.xz -= d * vec2 (cos (a), sin (a));\n  p.y -= bcSize.y * vr.x;\n  return PrSphDf (p, 0.01 * (1. - 0.7 * s));\n}\n\nconst vec3 bHash = vec3 (1., 57., 113.);\n\nfloat BObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p, cId, vr, s;\n  float dHit, d;\n  dHit = 0.1;\n  for (int j = 0; j < 120; j ++) {\n    p = ro + rd * dHit;\n    p.y -= 0.5 * tCur;\n    cId = floor (p / bcSize);\n    vr = Hashv3f (dot (cId, bHash));\n    d = (vr.x > 0.5) ? BubDf (p - bcSize * (cId + 0.5), vr) : dstFar;\n    s = (bcSize * (cId + step (0., rd)) - p) / rd;\n    d = min (d, abs (min (min (s.x, s.y), s.z)) + 0.01);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nfloat BObjDf (vec3 p)\n{\n  vec3 cId, vr;\n  cId = floor (p / bcSize);\n  vr = Hashv3f (dot (cId, bHash));\n  return BubDf (p - bcSize * (cId + 0.5), vr);\n}\n\nvec3 BObjNf (vec3 p)\n{\n  vec4 v;\n  vec3 e = vec3 (0.001, -0.001, 0.);\n  p.y -= 0.5 * tCur;\n  v = vec4 (BObjDf (p + e.xxx), BObjDf (p + e.xyy),\n     BObjDf (p + e.yxy), BObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat CageDf (vec3 p)\n{\n  p.xz = Rot2D (Rot2D (p.xz, 2. * pi * 0.5/12.), 2. * pi * (floor (12. *\n     ((length (p.xz) > 0.) ? atan (p.z, - p.x) / (2. * pi) : 0.)) + 0.5) / 12.);\n  p.z = abs (p.z);\n  return max (PrSphAnDf (p, 0.05, 0.0001),\n     min (abs (mod (p.y, 0.019) - 0.0095) - 0.0001,\n     dot (p.xz, vec2 (sin (0.04 * 2. * pi / 24.), cos (0.04 * 2. * pi / 24.)))));\n}\n\nfloat CObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = CageDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 BgCol (vec3 rd)\n{\n  float t, gd, b;\n  t = 4. * tCur;\n  b = dot (vec2 (atan (rd.x, rd.z), 0.5 * pi - acos (rd.y)), vec2 (2., sin (rd.x)));\n  gd = (clamp (sin (5. * b + t), 0., 1.) * clamp (sin (3.5 * b - t), 0., 1.) +\n     clamp (sin (21. * b - t), 0., 1.) * clamp (sin (17. * b + t), 0., 1.)) *\n     (1. - smoothstep (0.4, 0.6, rd.y));\n  return vec3 (0.3, 1., 1.) * (0.1 + 0.225 * (rd.y + 1.) * (rd.y + 1.)) *\n     (1. + 0.06 * gd);\n}\n\nfloat TurbLt (vec3 p, vec3 n, float t)\n{\n  vec2 q, qq, a1, a2;\n  float c, tt;\n  q = vec2 (dot (p.yzx, n), dot (p.zxy, n));\n  q = 2. * pi * mod (q, 1.) - 256.;\n  t += 11.;\n  c = 0.;\n  qq = q;\n  for (float k = 1.; k <= 7.; k ++) {\n    tt = t * (1. + 1. / k);\n    a1 = tt - qq;\n    a2 = tt + qq;\n    qq = q + tt + vec2 (cos (a1.x) + sin (a2.y), sin (a1.y) + cos (a2.x));\n    c += 1. / length (q / vec2 (sin (qq.x), cos (qq.y)));\n  }\n  return clamp (pow (abs (1.25 - abs (0.167 + 40. * c)), 8.), 0., 1.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, bgCol, vn;\n  float dstObj, dstBub, dstCage, dHit, dEdge, sh, diff, h, dFade, dm;\n  dHit = HexVolRay (ro, rd);\n  if (idObj == 0) dHit = dstFar;\n  dstObj = ObjRay (ro, rd);\n  dstBub = BObjRay (ro, rd);\n  if ((ro + dstBub * rd).y > 4.) dstBub = dstFar;\n  dstCage = CObjRay (ro - vuPos, rd);\n  bgCol = BgCol (rd);\n  col = bgCol;\n  dm = min (dstCage, dstObj);\n  if (min (min (dstBub, dm), dHit) < dstFar) {\n    if (min (dstBub, dm) < dHit) {\n      if (dm < dstBub) {\n        if (dstObj < dstCage) {\n          ro += dstObj * rd;\n          vn = ObjNf (ro);\n          if (idObj == 11) col = vec3 (0.6, 0.6, 1.) *\n             (1. - 0.4 * smoothstep (-0.5, -0.4, vn.y));\n          else if (idObj == 12) col = vec3 (1., 0.8, 0.2) *\n             step (0.05, length (qHit.yz - vec2 (-0.02, 0.05)));\n          col = col * (0.2 + 0.8 * max (dot (vn, sunDir), 0.)) +\n             0.1 * pow (max (dot (normalize (sunDir - rd), vn), 0.), 64.);\n          dHit = dstObj;\n          dFade = 0.2;\n        } else {\n          ro += dstCage * rd;\n          vn = - normalize (ro - vuPos);\n          col = vec3 (0.35, 0.3, 0.3) * (0.6 + 0.4 * max (dot (vn, sunDir), 0.));\n          dHit = dstCage;\n          dFade = 0.2;\n        }\n      } else {\n        ro += dstBub * rd;\n        vn = BObjNf (ro);\n        col = mix ((0.5 - 0.5 * dot (rd, vn)) * vec3 (0.4, 0.6, 0.8),\n           BgCol (reflect (rd, vn)), 0.5) +\n           0.2 * pow (max (dot (normalize (sunDir - rd), vn), 0.), 128.);\n        dHit = dstBub;\n        dFade = 0.05;\n      }\n    } else {\n      ro += rd * dHit;\n      vn = qnHit.yzx;\n      dEdge = EdgeDist (ro);\n      h = smoothstep (0., 0.1, HexFaceDist (ro));\n      col = HexVolCol (ro, dEdge, dHit) * (0.7 + 0.3 * h);\n      diff = clamp (dot (sunDir, vn), 0., 1.);\n      sh = (diff > 0. && HexVolRay (ro + 0.001 * vn, sunDir) < dstFar) ? 0.6 : 1.;\n      sh = min (sh, ObjSShadow (ro, sunDir));\n      col = col * (0.2 + 0.8 * sh * diff) + 0.2 * sh * step (0.1, diff) *\n         pow (max (dot (normalize (sunDir - rd), vn), 0.), 128.);        \n      dFade = 0.05;\n      col += 0.3 * TurbLt (0.8 * ro, abs (vn), 0.3 * tCur) *\n         smoothstep (-0.3, -0.1, vn.y);\n    }\n    col = mix (col, bgCol, smoothstep (dFade, 0.85, dHit / dstFar));\n  } else col = bgCol + WatShd (rd);\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, fpF, fpB, vd, u, fpNear;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, zmFac, vMov, vFish, tGap, t, a, d, f, aHlx, fHlx, fDist;\n  bool fishLook;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.1 * pi;\n  fishLook = true;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.95 * pi * mPtr.y;\n    fishLook = false;\n  }\n  dstFar = 15.;\n  zmFac = 1.8;\n  vMov = 0.5;\n  aHlx = 0.45;\n  fHlx = 0.2 * vMov;\n  fpF = TrackPath (vMov * tCur + 0.5);\n  fpB = TrackPath (vMov * tCur - 0.5);\n  vuPos = 0.5 * (fpF + fpB);\n  vuPos.xy += 0.6 * aHlx * vec2 (cos (fHlx * tCur), sin (fHlx * tCur));\n  ro = vuPos;\n  if (! fishLook) {\n    vd = fpF - fpB;\n    t = length (vd);\n    if (t > 0.) vd = normalize (vd);\n    ori = vec2 (el + sin (vd.y), az + ((t > 0.) ? atan (vd.x, vd.z) : 0.5 * pi));\n    ca = cos (ori);\n    sa = sin (ori);\n    vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n            mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  }\n  vFish = 1.;\n  tGap = 2. * dstFar / (float (N_FISH) * vFish);\n  fDist = dstFar;\n  for (int k = 0; k < N_FISH; k ++) {\n    t = tGap * ((float (k) + floor (ro.z / (tGap * vFish) + 0.5)) -\n       mod (tCur / tGap, 1.));\n    fpF = TrackPath (t * vFish + 0.2);\n    fpB = TrackPath (t * vFish - 0.2);\n    fishPos[k] = 0.5 * (fpF + fpB);\n    fishPos[k].xy -= aHlx * vec2 (cos (fHlx * t), sin (fHlx * t));\n    vd = fpF - fpB;\n    t = length (vd);\n    if (t > 0.) vd = normalize (vd);\n    fishAngH[k] = pi + ((t > 0.) ? atan (vd.x, vd.z) : 0.5 * pi);\n    fishAngV[k] = - sin (vd.y);\n    if (fishLook) {\n      d = length (fishPos[k] - ro);\n      if (d < fDist) {\n        fDist = d;\n        fpNear = fishPos[k];\n      }\n    }\n  }\n  if (fishLook) {\n    vd = normalize (fpNear - ro);\n    u = - vd.y * vd;\n    f = 1. / sqrt (1. - vd.y * vd.y);\n    vuMat = mat3 (f * vec3 (vd.z, 0., - vd.x), f * vec3 (u.x, 1. + u.y, u.z), vd);\n  }\n  fishAngI = 0.15 * sin (pi * tCur);\n  uv += sin (2. * pi * (5. * uv + 0.5 * sin (0.4 * pi * tCur))) / canvas.y;\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  sunDir = normalize (vec3 (cos (0.002 * pi * tCur), 2., sin (0.002 * pi * tCur)));\n  fragColor = vec4 (pow (clamp (ShowScene (ro, rd), 0., 1.), vec3 (0.8)), 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrSphAnDf (vec3 p, float r, float w)\n{\n  return abs (length (p) - r) - w;\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, cHashA3.xy)) * cHashM);\n}\n\nvec3 Hashv3f (float p)\n{\n  return fract (sin (vec3 (p, p + 1., p + 2.)) *\n     vec3 (cHashM, cHashM * 0.43, cHashM * 0.37));\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  const vec3 e = vec3 (0.1, 0., 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) -\n     Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdlfRl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdlfRS", "name": "Filter Faux-Bode", "author": "notlion", "description": "Trying out some functions for a fake bode plot", "tags": ["fake", "filter", "plot", "bode"], "likes": 2, "viewed": 62, "date": "1496805966", "time_retrieved": "2024-06-20T18:56:39.414340", "image_code": "float br(float cut, float res, float t) {\n  return max(0.0, 0.5 - (1.0 - res) / (20.0 * abs(t - cut)));\n}\n\nfloat bp(float cut, float res, float t) {\n  float d = t - cut;\n  float r1 = pow(0.33 / res, 1.75);\n  d = 1.0 / (res * 30.0 * max(0.0, (abs(d) + r1 * 0.11) / res));\n  d = d * (1.6 + 0.2 * res);\n  return 0.2 + 0.8 * sin(r1 * d * 3.14159) * res;\n}\n\nfloat lp(float cut, float res, float t) {\n  float d = cut - t + 0.13;\n  float g = 0.5 - 1.0 / (30.0 * max(0.0, d));\n  d = 0.5 - 1.0 / (res * 30.0 * max(0.0, d / res));\n  d = clamp(d * (1.6 + 0.2 * res), 0.0, 1.0);\n  g += sin(d * 3.14159) * (1.0 - d) * res * 1.36;\n  return g;\n}\n\nfloat hp(float cut, float res, float t) {\n  float d = t - cut + 0.13;\n  float g = 0.5 - 1.0 / (30.0 * max(0.0, d));\n  d = 0.5 - 1.0 / (res * 30.0 * max(0.0, d / res));\n  d = clamp(d * (1.6 + 0.2 * res), 0.0, 1.0);\n  g += sin(d * 3.14159) * (1.0 - d) * res * 1.36;\n  return max(0.0, g);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord.xy / iResolution.xy;\n\n  float t = iTime;\n  float cut = 0.5 * (1.0 + sin(t));\n  float res = 0.5 * (1.0 + cos(t * 2.3563));\n\n  vec2 p = (iMouse.xy / iResolution.xy) * 2.0 - 1.0;\n  p.y *= -1.0;\n  float lpa = max(0.0, 0.5 * (p.x + p.y));\n  float hpa = max(0.0, -0.5 * (p.x + p.y));\n  float bpa = max(0.0, 0.5 * p.x - 0.5 * p.y);\n  float bra = max(0.0, 0.5 * p.y - 0.5 * p.x);\n\n  vec3 c = vec3(0.0);\n  c.r += float(uv.x < br(cut, res, uv.y)) * bra;\n  c.g += float(uv.x < bp(cut, res, uv.y)) * bpa;\n  c.b += float(uv.x < hp(cut, res, uv.y)) * hpa;\n  c += float(uv.x < lp(cut, res, uv.y)) * lpa * 0.33;\n\n  c += float(uv.x < max((br(cut, res, uv.y)) * bra,\n                        max((bp(cut, res, uv.y)) * bpa,\n                            max(hp(cut, res, uv.y) * hpa,\n                                (lp(cut, res, uv.y)) * lpa)))) *\n       0.33;\n\n  fragColor = vec4(c * 0.5, 1.0);\n\n  float handle = smoothstep(20.0, 18.0, distance(fragCoord.xy, iMouse.xy));\n  fragColor = mix(fragColor, vec4(1.0, 0.5, 0.0, 1.0), handle);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdlfRS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdlfWM", "name": "Fractal Furball Monster", "author": "soma_arc", "description": "WATCHING YOU.\nYou can move the camera with your mouse.\nFur shader is based on  \"furball\" by simesgreen.\nhttps://www.shadertoy.com/view/XsfGWN", "tags": ["3d", "fractal", "fur"], "likes": 6, "viewed": 220, "date": "1497412034", "time_retrieved": "2024-06-20T18:56:41.390174", "image_code": "// 2017 @soma_arc\n\nconst int OBJ_FUR = 0;\nconst float MARCH_THRESHOLD = 0.1;\nconst int MAX_KLEIN_ITARATION = 50;\nconst int TRACE_DEPTH = 6;\nconst float SAMPLE_NUM = 2.;\nfloat iTime2;\n// from Syntopia http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/\nvec2 rand2n(vec2 co, float sampleIndex) {\n\tvec2 seed = co * (sampleIndex + 1.0);\n\tseed+=vec2(-1,1);\n\t// implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n\treturn vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nconst float DISPLAY_GAMMA_COEFF = 1. / 2.2;\nvec3 gammaCorrect(vec3 rgb) {\n    return vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),\n                (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),\n                (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));\n}\n\nconst float GAMMA = 2.2;\nvec3 degamma(vec3 rgb) {\n    return vec3((min(pow(rgb.r, GAMMA), 1.)),\n                (min(pow(rgb.g, GAMMA), 1.)),\n                (min(pow(rgb.b, GAMMA), 1.)));\n}\n\n// Fur Rendering code is based on \"furball\" by simesgreen.\n// https://www.shadertoy.com/view/XsfGWN\nconst float uvScale = 1.0;\nconst float colorUvScale = 0.1;\nconst float furDepth = 0.4;\nconst int furLayers = 64;\nconst float rayStep = furDepth*2.0 / float(furLayers);\nconst float furThreshold = 0.4;\nconst float shininess = 90.0;\n\nvec3 rotateX(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\n}\n\nvec2 cartesianToSpherical(vec3 p, vec4 ball)\n{\t\n    vec3 ballPos = p - ball.xyz;\n    float r = length(ballPos);\n\n    float depth = furDepth * ball.w;\n\tfloat t = (r - (ball.w - depth)) / depth;\t\n\tballPos = rotateX(ballPos.zyx, -cos(iTime*1.5)*t*t*0.2).zyx;\t// curl\n\n\tballPos /= r;\t\n\tvec2 uv = vec2(atan(ballPos.y, ballPos.x), acos(ballPos.z));\n\n\tuv.y -= t*t*0.1;\t// curl down\n\treturn uv;\n}\n\nfloat furDensity(vec3 pos, vec4 ball, out vec2 uv)\n{\n\tuv = cartesianToSpherical(pos.xzy, ball.xzyw);\t\n\tvec4 tex = textureLod(iChannel0, uv*uvScale, 0.0);\n\n    float threshold = ball.w * furThreshold;\n\t// thin out hair\n\tfloat density = smoothstep(furThreshold, 1., tex.x);\n\t\n    float depth = ball.w * furDepth;\n\tfloat r = length(pos - ball.xyz);\n\tfloat t = (r - (ball.w - depth)) / depth;\n\t\n\t// fade out along length\n\tfloat len = tex.y;\n\tdensity *= smoothstep(len, len-0.2 , t);\n\n\treturn density;\t\n}\n\nvec3 furNormal(vec3 pos, vec4 ball, float density)\n{\n    float eps = 1.;\n    vec3 n;\n\tvec2 uv;\n    n.x = furDensity( vec3(pos.x+eps, pos.y, pos.z), ball, uv ) - density;\n    n.y = furDensity( vec3(pos.x, pos.y+eps, pos.z), ball, uv ) - density;\n    n.z = furDensity( vec3(pos.x, pos.y, pos.z+eps), ball, uv ) - density;\n    return normalize(n);\n}\n\nvec3 furShade(vec3 pos, vec4 ball, vec2 uv, vec3 ro, float density, vec3 mColor){\n\tconst vec3 L = vec3(0, 1, 0);\n\tvec3 V = normalize(ro - pos);\n\tvec3 H = normalize(V + L);\n\n\tvec3 N = -furNormal(pos, ball, density);\n\n\tfloat diff = max(0.0, sqrt(1. - dot(N, L)* dot(N, L)));\n\tfloat spec = pow(max(0.0, sqrt(1. - dot(N, H) * dot(N, H)) ), shininess);\n\n\tvec3 color = degamma(textureLod(iChannel1, uv*colorUvScale, 0.0).xyz);\n\n    float depth = furDepth * ball.w;\n\tfloat r = length(pos - ball.xyz);\n\tfloat t = (r - (ball.w - depth)) / depth;\n\tt = clamp(t, 0.0, 1.0);\n\tfloat i = t*0.5+0.5;\n\t\t\n\treturn color*diff*i +vec3(0) * vec3(spec*i);\n}\n\n\n\nconst float schottkyRadius = 300.;\nvec4 schottky1 = vec4(300, 300, 0, schottkyRadius);\nvec4 schottky2 = vec4(300, -300, 0, schottkyRadius);\nvec4 schottky3 = vec4(-300, 300, 0, schottkyRadius);\nvec4 schottky4 = vec4(-300, -300, 0, schottkyRadius);\nvec4 schottky5 = vec4(0, 0, 424.26, schottkyRadius);\nvec4 schottky6 = vec4(0, 0, -424.26, schottkyRadius);\n\nvec3 sphereInvert(vec3 pos, vec4 sphere){\n\tvec3 diff = pos - sphere.xyz;\n    float d = length(diff);\n\treturn (diff * sphere.w * sphere.w)/(d * d) + sphere.xyz;\n}\n\nvec3 g_pos;\nfloat loopNum = 0.;\nvec4 baseSphere = vec4(0, 0, 0, 115);\nfloat g_baseRadius;\nfloat distKlein(vec3 pos){\n    float scalingFactor= 0.1;\n    loopNum = 0.;\n    float dr = 1.;\n    bool loopEnd = true;\n    for(int i = 0 ; i < MAX_KLEIN_ITARATION ; i++){\n        loopEnd = true;\n        if(distance(pos, schottky1.xyz) < schottky1.w){\n            vec3 diff = (pos - schottky1.xyz);\n            dr *= (schottky1.w * schottky1.w) / dot(diff, diff);\n            pos = sphereInvert(pos, schottky1);\n            loopEnd = false;\n            loopNum++;\n        }else if(distance(pos, schottky2.xyz) < schottky2.w){\n            vec3 diff = (pos- schottky2.xyz);\n            dr *= (schottky2.w * schottky2.w) / dot(diff, diff);\n            pos = sphereInvert(pos, schottky2);\n            loopEnd = false;\n            loopNum++;\n        }else if(distance(pos, schottky3.xyz) < schottky3.w){\n            vec3 diff = (pos- schottky3.xyz);\n            dr *= (schottky3.w * schottky3.w) / dot(diff, diff);\n            pos = sphereInvert(pos, schottky3);\n            loopEnd = false;\n            loopNum++;\n        }else if(distance(pos, schottky4.xyz) < schottky4.w){\n            vec3 diff = (pos- schottky4.xyz);\n            dr *= (schottky4.w * schottky4.w) / dot(diff, diff);\n            pos = sphereInvert(pos, schottky4);\n            loopEnd = false;\n            loopNum++;\n        }else if(distance(pos, schottky5.xyz) < schottky5.w){\n            vec3 diff = (pos- schottky5.xyz);\n            dr *= (schottky5.w * schottky5.w) / dot(diff, diff);\n            pos = sphereInvert(pos, schottky5);\n            loopEnd = false;\n            loopNum++;\n        }else if(distance(pos, schottky6.xyz) < schottky6.w){\n            vec3 diff = (pos- schottky6.xyz);\n            dr *= (schottky6.w * schottky6.w) / dot(diff, diff);\n            pos = sphereInvert(pos, schottky6);\n            loopEnd = false;\n            loopNum++;\n        }\n        if(loopEnd == true) break;\n    }\n    g_pos = pos;\n  \tg_baseRadius = baseSphere.w / abs(dr);\n    return (length(pos) - baseSphere.w) / abs(dr) * scalingFactor;\n}\n\nvec3 calcRay (const vec3 eye, const vec3 target, const vec3 up, const float fov,\n              const float width, const float height, const vec2 coord){\n    float imagePlane = (height * .5) / tan(fov * .5);\n    vec3 v = normalize(target - eye);\n    vec3 xaxis = normalize(cross(v, up));\n    vec3 yaxis =  normalize(cross(v, xaxis));\n    vec3 center = v * imagePlane;\n    vec3 origin = center - (xaxis * (width  *.5)) - (yaxis * (height * .5));\n    return normalize(origin + (xaxis * coord.x) + (yaxis * (height - coord.y)));\n}\n\nconst vec4 K = vec4(1.0, .666666, .333333, 3.0);\nvec3 hsv2rgb(const vec3 c){\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat distFunc(vec3 p){\n    return distKlein(p);\n}\n\nconst vec2 d = vec2(0.01, 0.);\nvec3 getNormal(const vec3 p){\n    return normalize(vec3(distFunc(p + d.xyy) - distFunc(p - d.xyy),\n                          distFunc(p + d.yxy) - distFunc(p - d.yxy),\n                          distFunc(p + d.yyx) - distFunc(p - d.yyx)));\n}\n\nconst int MAX_MARCHING_LOOP = 1000;\nint march(const vec3 origin, const  vec3 ray, const float threshold,\n           float t0, float t1,\n           out vec3 intersection){\n    vec3 rayPos = origin + t0 * ray;\n    float dist;\n    float rayLength = t0;\n    for(int i = 0 ; i < MAX_MARCHING_LOOP ; i++){\n        if(rayLength > t1) break;\n        dist = distFunc(rayPos);\n        rayLength += dist;\n        rayPos = origin + ray * rayLength ;\n        if(dist < threshold) {\n        \tintersection = rayPos;\n            return OBJ_FUR;\n        }\n    }\n    return -1;\n}\n\nbool intersectSphere(vec4 sphere, \n                     vec3 rayOrigin, vec3 rayDir,\n                     out float t0, out float t1){\n  \tvec3 v = rayOrigin - sphere.rgb;\n  \tfloat b = dot(rayDir, v);\n  \tfloat c = dot(v, v) - sphere.w * sphere.w;\n  \tfloat d = b * b - c;\n  \tif(d >= 0.){\n    \tfloat s = sqrt(d);\n    \tfloat tmin = -b - s;\n        float tmax = -b + s;\n            if(tmin < tmax) {\n            \tt0 = tmin;\n                t1 = tmax;\n            } else {\n            \tt0 = tmax;\n                t1 = tmin;\n            }\n      \t\treturn true;\n    \t\n  \t}\n  \treturn false;\n}\n\nconst float PI = 3.14159265359;\nconst float TWO_PI = 2. * PI;\nvec2 equirectangularCoord(const vec3 coordOnSphere){\n    vec3 dir = (coordOnSphere);\n    float l = atan(dir.z, dir.x);\n    if (l < 0.) l += TWO_PI;\n    return vec2(l, abs(acos(dir.y) -PI));\n}\n\nbool inEqui(vec2 a, vec2 b, float threshold){\n\treturn (distance(a, b) < threshold ||\n            distance(a , b + vec2(TWO_PI, 0)) < threshold||\n            distance(a , b - vec2(TWO_PI, 0)) < threshold);\n}\n\nvec3 calcColor(vec3 eye, vec3 ray){\n    vec3 originalEye = eye;\n    vec4 l = vec4(0);\n    float coeff = 1.;\n    float t0, t1;\n    bool intersect =  intersectSphere(vec4(0,0,0, 310.), eye, ray, t0, t1);\n    if(intersect == false) return l.rgb; \n\tif(t0 < 0.) t0 = 0.;\n    for(int rayDepth = 0 ; rayDepth < TRACE_DEPTH ; rayDepth++){\n\t\tvec3 intersection, normal;\n    \tint objId = march(eye, ray, MARCH_THRESHOLD, t0, t1, intersection);\n    \tif(objId != -1){\n\t\t\tnormal = getNormal(intersection);\n\n\t\t\tvec4 c = vec4(0.0);        \n        \tvec3 pos = intersection;\n        \n        \tfloat ballRadius = g_baseRadius;\n        \tvec4 ball = vec4(intersection - normal * ballRadius, ballRadius);\n        \tfloat depth = ballRadius * furDepth;\n        \tfloat rstep = depth*2.0 / float(furLayers);\n\n\t\t\t// render eye        \n            vec2 eqc = equirectangularCoord(normalize(intersection - ball.xyz));\n        \tvec2 v = equirectangularCoord(normalize(normalize(originalEye - ball.xyz)));\n        \tvec2 left = v - vec2(.23 , -0.1);\n        \tvec2 right = v + vec2(.23, 0.1);\n            if(inEqui(eqc, left, .1)){\n        \t    c = vec4(0, 0, 0, 1);\n                c.rgb *= c.a;\n\t\t\t\tl = l + c * (1.0 - l.a);\n            \tbreak;\n            }else if(inEqui(eqc, left, .2)){\n            \tc = vec4(1);\n                c.rgb *= c.a;\n\t\t\t\tl = l + c * (1.0 - l.a);\n                break;\n            }\n            if(inEqui(eqc, right, .1)){\n           \t\tc = vec4(0, 0, 0, 1);\n                c.rgb *= c.a;\n\t\t\t\tl = l + c * (1.0 - l.a);\n            \tbreak;\n            }else if(inEqui(eqc, right, .2)){\n            \tc = vec4(1);\n                c.rgb *= c.a;\n\t\t\tl = l + c * (1.0 - l.a);\n                break;\n            }\n            //dummy\n            vec3 matColor = vec3(0);\n            // render fur\n\t\t\tfor(int i=0; i<furLayers; i++) {\n\t\t\t\tvec4 sampleCol;\n\t\t\t\tvec2 uv;\n\t\t\t\tsampleCol.a = furDensity(pos, ball, uv);\n\t\t\t\tif (sampleCol.a > 0.0) {\n\t\t\t\t\tsampleCol.rgb = furShade(pos, ball, uv, eye, sampleCol.a, matColor);\n\n\t\t\t\t\tsampleCol.rgb *= sampleCol.a;\n\t\t\t\t\tc = c + sampleCol*(1.0 - c.a);\n\t\t\t\t\tif (c.a > 0.99) break;\n\t\t\t\t}\n\t\t\t\n\t\t\t\tpos += ray*rstep;\n\t\t\t}\n        \tc = clamp(c, 0., 1.);            \n            \n        \tc.rgb *= c.a;\n\t\t\tl = l + c * (1.0 - l.a);\n        \tfloat tmin, tmax;\n        \tintersectSphere(ball, eye, ray, tmin, tmax);\n        \teye = eye + ray * (tmax + ball.w * 0.2);\n        \tt0 = 0.;\n    \t} else {\n        \tvec4 c = vec4(0, 0, 0, 1);\n        \tc.rgb *= c.a;\n\t\t\tl = l + c * (1.0 - l.a);\n    \t\tbreak;\n    \t}\n    \tif (l.a > 0.99) break;\n    }\n    return l.rgb;\n}\n\nvec3 eye = vec3(300 , 0., 550 );\nconst vec3 target = vec3(0, 0, 0);\nconst vec3 up = vec3(0, 1, 0);\nfloat fov = radians(60.);\n\nfloat scene(in float t, in float w, in float s){\n    return clamp(t - w, 0.0, s) / s;  \n}\n\nfloat expEasingIn(float t){\n    return pow( 2., 13. * (t - 1.) );\n}\nfloat expEasingOut(float t) {\n\treturn -pow( 2., -10. * t) + 1.;\n}\n\nfloat circEasingInOut(float t){\n\tt /= .5;\n\tif (t < 1.) return -.5 * (sqrt(1. - t*t) - 1.);\n\tt -= 2.;\n\treturn .5 * (sqrt(1. - t*t) + 1.);\n}\n\nfloat circEasingIn(float t){\n\treturn -  (sqrt(1. - t*t) - 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec3 sum = vec3(0);\n    float t = iTime * .5;\n    iTime2 = iTime;\n    float dist = 500. + -iMouse.x;\n    float height = 100. + iMouse.y;\n\n    eye = vec3(dist * cos(t) , height, \n               dist * sin(t) );\n\n    \n    float start = 0.;\n    float dur = 1.; \n\tschottky1.w = mix(0., schottkyRadius, expEasingIn(scene(t, start, dur)));\n   \tschottky5.w = mix(0., schottkyRadius, expEasingIn(scene(t, start + .5, dur)));\n\tschottky2.w = mix(0., schottkyRadius, expEasingIn(scene(t, start + 2. * .5, dur)));\n\tschottky4.w = mix(0., schottkyRadius, expEasingIn(scene(t, start + 3. * .5, dur)));\n    schottky3.w = mix(0., schottkyRadius, expEasingIn(scene(t, start + 4. * .5, dur)));\n\tschottky6.w = mix(0., schottkyRadius, expEasingIn(scene(t, start + 5. * .5, dur)));\n\tdur = dur * 6.;\n    \n  \tfor(float i = 0. ; i < SAMPLE_NUM ; i++){\n    \tvec2 coordOffset = rand2n(gl_FragCoord.xy, i);\n    \tvec3 ray = calcRay(eye, target, up, fov,\n        \t               iResolution.x, iResolution.y,\n            \t           gl_FragCoord.xy + coordOffset);\n          \n    \tsum += calcColor(eye, ray);\n\t}\n\tvec3 col = (sum/SAMPLE_NUM);\n\n\tfragColor = vec4(gammaCorrect(col), 1.);\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdlfWM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Mdlfzf", "name": "Color conversion test", "author": "thykka", "description": "Mixing color in Lab space", "tags": ["color", "gradient"], "likes": 1, "viewed": 107, "date": "1497423193", "time_retrieved": "2024-06-20T18:56:41.390174", "image_code": "vec3 rgb2xyz (in vec3 rgb) {\n    float r = rgb.r;\n\tfloat g = rgb.g;\n\tfloat b = rgb.b;\n\n\tr = r > 0.04045 ? pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);\n\tg = g > 0.04045 ? pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);\n\tb = b > 0.04045 ? pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);\n\n\tfloat x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);\n\tfloat y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);\n\tfloat z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);\n    \n    vec3 xyz = vec3(\n        (r * 0.4124) + (g * 0.3576) + (b * 0.1805) * 100.0,\n        (r * 0.2126) + (g * 0.7152) + (b * 0.0722) * 100.0,\n        (r * 0.0193) + (g * 0.1192) + (b * 0.9505) * 100.0\n    );\n    return(xyz);\n}\n\nvec3 xyz2lab (in vec3 xyz) {\n\tfloat x = xyz.x / 95.047;\n\tfloat y = xyz.y / 100.0;\n\tfloat z = xyz.z / 108.883;\n\n\tx = x > 0.008856 ? pow(x, 1.0 / 3.0) : (7.787 * x) + (16.0 / 116.0);\n\ty = y > 0.008856 ? pow(y, 1.0 / 3.0) : (7.787 * y) + (16.0 / 116.0);\n\tz = z > 0.008856 ? pow(z, 1.0 / 3.0) : (7.787 * z) + (16.0 / 116.0);\n\n    vec3 lab = vec3((116.0 * y) - 16.0, 500.0 * (x - y), 200.0 * (y - z));\n    return(lab);\n}\n\nvec3 rgb2lab(in vec3 rgb) {\n    vec3 xyz = rgb2xyz(rgb);\n    vec3 lab = xyz2lab(xyz);\n    return(lab);\n}\n\nvec3 xyz2rgb (in vec3 xyz) {\n\tfloat x = xyz.x / 100.0;\n\tfloat y = xyz.y / 100.0;\n\tfloat z = xyz.z / 100.0;\n\t\n    \n\tfloat r = (x *  3.2406) + (y * -1.5372) + (z * -0.4986);\n\tfloat g = (x * -0.9689) + (y *  1.8758) + (z *  0.0415);\n\tfloat b = (x *  0.0557) + (y * -0.2040) + (z *  1.0570);\n\n\tr = r > 0.0031308 ? ((1.055 * pow(r, 1.0 / 2.4)) - 0.055) : r * 12.92;\n\tg = g > 0.0031308 ? ((1.055 * pow(g, 1.0 / 2.4)) - 0.055) : g * 12.92;\n\tb = b > 0.0031308 ? ((1.055 * pow(b, 1.0 / 2.4)) - 0.055) : b * 12.92;\n\n\tr = min(max(0.0, r), 1.0);\n\tg = min(max(0.0, g), 1.0);\n\tb = min(max(0.0, b), 1.0);\n\n\treturn(vec3(r, g, b));\n}\n\nvec3 lab2xyz (in vec3 lab) {\n    float l = lab.x;\n\tfloat a = lab.y;\n\tfloat b = lab.z;\n\n  \tfloat y = (l + 16.0) / 116.0;\n\tfloat x = a / 500.0 + y;\n\tfloat z = y - b / 200.0;\n\n\tfloat y2 = pow(y, 3.0);\n\tfloat x2 = pow(x, 3.0);\n\tfloat z2 = pow(z, 3.0);\n\n  \ty = y2 > 0.008856 ? y2 : (y - 16.0 / 116.0) / 7.787;\n\tx = x2 > 0.008856 ? x2 : (x - 16.0 / 116.0) / 7.787;\n\tz = z2 > 0.008856 ? z2 : (z - 16.0 / 116.0) / 7.787;\n\n\tx *= 95.047;\n\ty *= 100.0;\n\tz *= 108.883;\n\n\treturn(vec3(x, y, z));\n}\nvec3 lab2rgb (in vec3 lab) {\n    vec3 xyz = lab2xyz(lab);\n    vec3 rgb = xyz2rgb(xyz);\n    return(rgb);\n}\n\nconst vec3 lab0 = vec3(  20.0, 100.0,  -50.0);\nconst vec3 lab1 = vec3( 100.0,  50.0,  -50.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 A; // First gradient point.\n    if(iMouse.z > 0.0) {\n        A = vec2(iMouse);\n    } else {\n        A = vec2(\n            (sin(iTime * 0.1) * 0.5 + .5) * iResolution.x,\n            (cos(iTime * 0.3) * 0.5 + .5) * iResolution.y\n        );\n    }\n    vec2 B = vec2(\n        (sin(-iTime * -0.2) * 0.5 + .50) * iResolution.x,\n        (-cos(iTime * -0.1) * 0.5 + .50) * iResolution.y\n    ); // Second gradient point.\n\n    vec2 V = B - A;\n    \n    float s = dot(fragCoord.xy-A, V) / dot(V, V); // Vector projection.\n    //s = clamp(s, 0.0, 1.0); // Saturate scaler.\n    \n    // color = pow(color, vec3(1.0/1.0)); // sRGB gamma encode.\n    fragColor = vec4(lab2rgb(vec3(\n        (sin(iTime / (s + 10.0) * 4.2) + 1.0) * 25.0 + 25.0,\n        sin(asin(fragCoord.x / iResolution.x * 1.0) * cos(iTime * 2.2)) * 100.0,\n        sin(acos(fragCoord.y / iResolution.y * 1.1) * 0.0-s * 6.283) * 100.0\n    )), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mdlfzf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Mdlfzj", "name": "Sketch_TriLattice5", "author": "cexlearning", "description": "TriLattice5copy from https://github.com/keijiro/ShaderSketches", "tags": ["sketch"], "likes": 4, "viewed": 86, "date": "1497060392", "time_retrieved": "2024-06-20T18:56:41.390174", "image_code": "float rand(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 uv2tri(vec2 uv)\n{\n    float sx = uv.x - uv.y / 2.0; // skewed x\n    float sxf = fract(sx);\n    float offs = step(fract(1.0 - uv.y), sxf);\n    return vec2(floor(sx) * 2.0 + sxf + offs, uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = (fragCoord.xy - iResolution.xy / 2.0) / iResolution.y * 8.0;\n    uv.y += iTime;\n\n    float t = iTime * 0.8;\n    float tc = floor(t);\n    float tp = smoothstep(0.0, 0.8, fract(t));\n\n    vec2 r1 = vec2(floor(uv.y), tc);\n    vec2 r2 = vec2(floor(uv.y), tc + 1.0);\n    float offs = mix(rand(r1), rand(r2), tp);\n\n    uv.x += offs * 8.0;\n\n    vec2 p = uv2tri(uv);\n    float ph = rand(floor(p)) * 6.3 + p.y * 0.2;\n    float c = abs(sin(ph + iTime));\n\n    fragColor = vec4(c, c, c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mdlfzj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdlfzS", "name": "28/100", "author": "yahe", "description": "Play with Bezier curve", "tags": ["bezier"], "likes": 17, "viewed": 611, "date": "1496809328", "time_retrieved": "2024-06-20T18:56:42.159866", "image_code": "const float Pi = 3.1415926535;\n\nfloat Point(vec2 uv, vec2 P)\n{\n    return smoothstep(0.035, 0.005, distance(uv, P));   \n}\n\nfloat cbrt(float x)\n{\n    return sign(x) * pow(abs(x), 1.0/3.0);\n}\n\n// http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c\n// Solve cubic ax^3 + bx^2 + cx + d = 0 \n// Returns amount of roots\nint SolveCubic(vec4 coeffs, out vec3 roots)\n{\n    int nS = 0;  \n    // normal form: x^3 + Ax^2 + Bx + C = 0 \n    vec4 N = coeffs / coeffs[0];\n\n    // substitute x = y - A/3 \n    // depressed cubic: x^3 + px + q = 0 \n    float sqA = N[1]*N[1];\n    float p = (N[2] - sqA/3.0) / 3.0;\n    float q = ( (N[1] * sqA)/13.5 - (N[1] * N[2])/3.0 + N[3]) * 0.5;\n\n    // Use Cardano's formula \n    float cbP = p * p * p;\n    float D = q * q + cbP;\n\n    if (abs(D) < 1e-20)\n    {\n\t\tif (q == 0.0)  \n            nS = 1;\n\t\t   \n\t\telse // one single and one double solution\n\t\t{\n\t\t    float u = cbrt(-q);\n\t\t    roots[0] = 2.0 * u;\n\t\t    roots[1] = -u;\n\t\t    nS = 2;\n\t\t}\n    }\n    \n    else if (D < 0.0) // Casus irreducibilis: three real solutions\n    {\n\t\tfloat phi = acos(-q / sqrt(-cbP)) / 3.0;\n\t\tfloat t = 2.0 * sqrt(-p);\t\n\t\troots[0] = t * cos(phi);\n\t\troots[1] = -t * cos(phi + Pi/3.0);\n\t\troots[2] = -t * cos(phi - Pi/3.0);\n\t\tnS = 3;\n    }\n    \n    else // one real solution \n    {\n\t\tfloat sqrtD = sqrt(D);\n\t\troots[0] = cbrt(sqrtD - q) - cbrt(sqrtD + q);\n\t\tnS = 1;\n    }\n\n    roots -= N[1] / 3.0;\n    \n    return nS;\n}\n\nvec2 QuadraticBezier(float t, vec2 p0, vec2 p1, vec2 p2)\n{\n\treturn mix((mix(p0, p1, t)),(mix(p1, p2, t)), t);\n}\n\n// x is a point\n// {a, b, c} are the control points\nfloat DistanceQuadraticBezier(vec2 x, vec2 a, vec2 b, vec2 c)\n{\n    float aa = dot(a,a);\tfloat bc = dot(b,c);\tfloat cc = dot(c,c);\n    float ab = dot(a,b);\tfloat bb = dot(b,b);   \tfloat cx = dot(c,x);\n    float ac = dot(a,c);\tfloat bx = dot(b,x);\n    float ax = dot(a,x);\n           \n    // Cubic coefficients\n    float cu = 4.0*(aa + cc) + 16.0*(bb - ab - bc) + 8.0*ac;\n    // Quadratic coefficients\n\tfloat qu = 12.0*(bc - ac - aa) - 24.0*bb + 36.0*ab;\n    // Linear coefficients\n    float li = 4.0*(ac - ax - cx) + 8.0*(bx + bb) + 12.0*aa - 24.0*ab;\n    // Constant terms\n    float C = 4.0*(ab + ax - aa - bx);\n    vec3 roots;\n    vec4 coeffs = vec4(cu, qu, li, C);\n    \n    int nS = SolveCubic(coeffs, roots);  \n    float t;\n\n   \tfloat Dist1 = distance(x, QuadraticBezier(clamp(roots.x, 0.0, 1.0), a, b, c));\n    float Dist2 = distance(x, QuadraticBezier(clamp(roots.y, 0.0, 1.0), a, b, c));\n    float Dist3 = distance(x, QuadraticBezier(clamp(roots.z, 0.0, 1.0), a, b, c));\n    \n    return min(Dist3, min(Dist1, Dist2));\n}                 \n\nvec2 Mouse()\n{\n    vec2 a = 2.0 *(iMouse.xy / iResolution.xy) - 1.0;\n    a.x *= iResolution.x / iResolution.y;\n    return a;\n    \n}\n\nvec3 Curves(vec2 uv)\n{\n    float t = iTime * 7.0;\n    \n    float P = 0.0;\n    vec3 L = vec3(0.0);\n    \n    vec2 p0 = vec2(uv.x, -1.);\n    \n    for (float i = 0.0; i < 50.; i++) {\n    \n    vec2 p2 = vec2(1.5*sin(t*.5+i), 1.5*cos(t*.1+i)); \n    vec2 p4 = -p2;\n    vec2 p5 = vec2(-p2.y, p2.x);\n        \n        vec2 p = vec2(1.5*sin((t*0.04+i)), sin((t*.1+i) - 1.));\n    \tfloat d1 = smoothstep(0.02, 0.00, DistanceQuadraticBezier(uv, p0, p2, p));\n    \tfloat d2 = smoothstep(0.03, 0.00, DistanceQuadraticBezier(uv, p0, p4, p));\n    \tfloat d3 = smoothstep(0.05, 0.00, DistanceQuadraticBezier(uv, p0, p5, p));\n        \n    vec3 L1 = d1 * vec3(0.2 , 0.4, 0.4+ .5*sin(i));\n    vec3 L2 = d2 * vec3(0.3, 0.2, 0.4+ .2*cos(i));\n        \n        L += L1 + L2;\n    }\n    \n    return P + L;\n}   \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy;\n    vec2 q = 2.0*p - 1.0;\n    q.x *= iResolution.x / iResolution.y;   \n    \n    vec3 col = vec3(0.15, 0.15, 0.19);\n    col = max(col, Curves(q));\n       \n    col = sqrt(col) * .7;\n    col = col * (1.0 - 0.2*dot(q,q));\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdlfzS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdsBRX", "name": "explicit branchless atan2", "author": "ollj", "description": "explicit (and branchless) atan2 for automatic differentiation\nfor\nhttps://www.shadertoy.com/view/lsffRX\nthe core is line 32:\n return mix(1.57+atan(-y/xx),mix(3.14+b,b,step(0.,y)),step(x,0.));}", "tags": ["atan", "branchless"], "likes": 4, "viewed": 532, "date": "1497312033", "time_retrieved": "2024-06-20T18:56:42.578160", "image_code": "//explicit (and branchless) atan2 for automatic differentiation\n//for\n//https://www.shadertoy.com/view/lsffRX\n\n//optionally ignore (linux) incompatibility, for better precision and performance\n//#define ignorelinux\n\n#define v0 float\n#define pi acos(-1.)\n#define pih acos(0.)\n\n//wrapping for namespace sake:\n//atan2() is a bit tricky, thankfully commonly only defined for vec2.\nv0 atand(v0 a){return atan(a);}//atan(x/y) has limited range and is non branching.\n\nv0 signd(v0 a){return sign(a);}\nv0 absd(v0 a){return abs(a);}\nv0 negd(v0 a){return -a;}\nv0 mind(v0 a,v0 b){return min(a,b);}\nv0 divd(v0 a,v0 b){return a/b;}\nv0 addd(v0 a,v0 b){return a+b;}\nv0 stepd(v0 a,v0 b){return step(a,b);}\nv0 mixd(v0 a,v0 b,v0 c){return mix(a,b,c);}\n\n#ifndef ignorelinux\n //should be smallest positive float, or close to it, and still >0.\n const float smallestP=exp2(1e-125);\n //all for linux compatibility, \n //linux distegards that IEEfloats are DEFIED AS BEING JUST FINE when dividing by +-0 !!!\n #define not0(a) signd(a)*mind(smallestP,absd(a))\n#endif \n\n//expliicit atan2() //https://en.wikipedia.org/wiki/Atan2\n//is equivalent to atan(x,y) as far as I can tell.\nv0 atand(v0 x,v0 y){\n #ifdef ignorelinux\n  float yy=y,xx=x,\n #else\n  float yy=not0(y),xx=not0(x),// (needs extreme resolution to show a difference)\n #endif\n b=atand(divd(x,yy));\n return mixd(pih+atand(divd(negd(y),xx)),mixd(addd(pi,b),b,stepd(0.,y)),stepd(x,0.));}\n\n//below just tests above for consistency\n//carthesian to polar\nvec2 c2p(vec2 c){\n  //float y=mix(atand(c.y,c.x),atan(c.y,c.x),sin(iTime*99.));//see flicker?  \n  float y=atand(c.y,c.x);\n  return vec2(length(c),y);}\n//polar to carthesian\nvec2 p2c(vec2 c){return vec2(c.x*cos(c.y),c.x*sin(c.y));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n vec2 u = fragCoord.xy / iResolution.xy;\n u-=.5;\n u.x*=iResolution.x/iResolution.y;\n //u*=6.;//zoom out\n u=c2p(u);\n //u.y+=2.61;\n u.y+=iTime;//inefficient rotation transform (polar transform is overkill)\n u=p2c(u);    \n u=fract(u);    \n fragColor = vec4(u,0.5,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdsBRX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdsBz2", "name": "Octopus", "author": "knarkowicz", "description": "A cephalopod mollusc with eight sucker-bearing arms, a soft sac-like body, strong beak-like jaws, and no internal shell.", "tags": ["sdf", "water", "bokeh", "octopus", "tentacle", "predator"], "likes": 65, "viewed": 1995, "date": "1497218968", "time_retrieved": "2024-06-20T18:56:42.584252", "image_code": "const float MATH_PI = float( 3.14159265359 );\n\nfloat saturate( float x )\n{\n    return clamp( x, 0.0, 1.0 );\n}\n\nfloat Smooth( float x )\n{\n\treturn smoothstep( 0.0, 1.0, saturate( x ) );   \n}\n\nfloat Sphere( vec3 p, float s )\n{\n\treturn length( p ) - s;\n}\n\nfloat Capsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat Union( float a, float b )\n{\n    return min( a, b );\n}\n\nfloat UnionRound( float a, float b, float k )\n{\n    float h = clamp( 0.5 + 0.5 * ( b - a ) / k, 0.0, 1.0 );\n    return mix( b, a, h ) - k * h * ( 1.0 - h );\n}\n\nfloat SubstractRound( float a, float b, float r ) \n{\n\tvec2 u = max( vec2( r + a, r - b ), vec2( 0.0, 0.0 ) );\n\treturn min( -r, max( a, -b ) ) + length( u );\n}\n\nfloat Displace( float scale, float ampl, vec3 p )\n{\n    p *= ampl;\n\treturn scale * sin( p.x ) * sin( p.y ) * sin( p.z );\n}\n\nfloat RepeatAngle( inout vec2 p, float n ) \n{\n\tfloat angle = 2.0 * MATH_PI / n;\n\tfloat a = atan( p.y, p.x ) + angle / 2.0;\n\tfloat r = length( p );\n\tfloat c = floor( a / angle );\n\ta = mod( a, angle ) - angle / 2.;\n\tp = vec2( cos( a ), sin( a ) ) * r;\n\treturn c;\n}\n\nvoid Rotate( inout vec2 p, float a ) \n{\n    p = cos( a ) * p + sin( a ) * vec2( p.y, -p.x );\n}\n\nfloat Tentacle( vec3 p )\n{    \n    p.y += 0.3;\n    \n    float scale = 1.0 - 2.5 * saturate( abs( p.y ) * 0.25 );    \n    \n    p.x = abs( p.x );\n    \n    p -= vec3( 1.0, -0.5, 0.0 );\n    Rotate( p.xy, 0.4 * MATH_PI );\n    p.x -= sin( p.y * 5.0 + iTime * 1.6 ) * 0.05;\n    \n    vec3 t = p;    \n    \n    float ret = Capsule( p, vec3( 0.0, -1000.0, 0.0 ), vec3( 0.0, 1000.0, 0.0 ), 0.25 * scale );\n\n    p.z = abs( p.z );\n    p.y = mod( p.y + 0.08, 0.16 ) - 0.08;\n    p.z -= 0.12 * scale;\n    float tent = Capsule( p, vec3( 0.0, 0.0, 0.0 ), vec3( -0.4 * scale, 0.0, 0.0 ), 0.1 * scale );\n    \n    float pores = Sphere( p - vec3( -0.4 * scale, 0.0, 0.0 ), mix( 0.04, 0.1, scale ) );\n    tent = SubstractRound( tent, pores, 0.01 );\n  \n    ret = UnionRound( ret, tent, 0.05 * scale );\n    ret += textureLod( iChannel0, vec2( t.xy * 0.5 ), 0. ).x * 0.01;\n    \n    return ret;\n}\n\nfloat Scene( vec3 p )\n{   \n    p.z += cos( p.y * 0.2 + iTime ) * 0.11;\n    p.x += sin( p.y * 5.0 + iTime ) * 0.05;    \n    p.y += sin( iTime * 0.51 ) * 0.1;\n    \n    Rotate( p.yz, 0.45 + sin( iTime * 0.53 ) * 0.11 );\n    Rotate( p.xz, 0.12 + sin( iTime * 0.79 ) * 0.09 );\n    \n    vec3 t = p;\n    RepeatAngle( t.xz, 8.0 );\n    float ret = Tentacle( t );\n\n    p.z += 0.2;\n    p.x += 0.2;\n        \n    float body = Sphere( p - vec3( -0.0, -0.3, 0.0 ), 0.6 );\n    \n    t = p;    \n    t.x *= 1.0 - t.y * 0.4;\n    body = UnionRound( body, Sphere( t - vec3( -0.2, 0.5, 0.4 ), 0.8 ), 0.3 ); \n    \n    body += Displace( 0.02, 10.0, p );\n    body += textureLod( iChannel0, vec2( p.xy * 0.5 ), 0. ).x * 0.01;\n   \n    ret = UnionRound( ret, body, 0.05 );   \n    \n    ret = SubstractRound( ret, Sphere( p - vec3( 0.1, -1.0, 0.2 ), 0.4 ), 0.1 );        \n    \n\treturn ret;\n}\n\nfloat CastRay( in vec3 ro, in vec3 rd )\n{\n    const float maxd = 10.0;\n    \n\tfloat h = 1.0;\n    float t = 0.0;\n   \n    for ( int i = 0; i < 50; ++i )\n    {\n        if ( h < 0.001 || t > maxd ) \n        {\n            break;\n        }\n        \n\t    h = Scene( ro + rd * t );\n        t += h;\n    }\n\n    if ( t > maxd )\n    {\n        t = -1.0;\n    }\n\t\n    return t;\n}\n\nvec3 SceneNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 normal = vec3(\n\t    Scene( pos + eps.xyy ) - Scene( pos - eps.xyy ),\n\t    Scene( pos + eps.yxy ) - Scene( pos - eps.yxy ),\n\t    Scene( pos + eps.yyx ) - Scene( pos - eps.yyx ) );\n\treturn normalize( normal );\n}\n\nvec3 WaterKeyColor  = vec3( 0.09, 0.92, 0.98 );\nvec3 WaterFillColor = vec3( 0.1, 0.06, 0.28 );\n\nvec3 Water( vec3 rayDir )\n{\n    Rotate( rayDir.xy, -0.2 ); \n    vec3 color = mix( WaterKeyColor, WaterFillColor, Smooth( -1.2 * rayDir.y + 0.6 ) );\n    return color;\n}\n\nfloat Circle( vec2 p, float r )\n{\n    return ( length( p / r ) - 1.0 ) * r;\n}\n\nvoid BokehLayer( inout vec3 color, vec2 p, vec3 c, float radius )   \n{    \n    float wrap = 350.0;    \n    if ( mod( floor( p.y / wrap + 0.5 ), 2.0 ) == 0.0 )\n    {\n        p.x += wrap * 0.5;\n    }    \n    \n    vec2 p2 = mod( p + 0.5 * wrap, wrap ) - 0.5 * wrap;\n    float sdf = Circle( p2, radius );\n    color += c * ( 1.0 - Smooth( sdf * 0.01 ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n\tp.x *= iResolution.x / iResolution.y;\n\n    vec3 rayOrigin\t= vec3( -0.5, -0.5, -4.0 );\n\tvec3 rayDir \t= normalize( vec3( p.xy, 2.0 ) ); \n\n    vec3 background = Water( rayDir );\n      \n    p *= 400.0;\n    Rotate( p, -0.2 );  \n    BokehLayer( background, p + vec2( 125.0, -120.0 * iTime ), vec3( 0.1 ), 0.5 );\n    BokehLayer( background, p * 1.5 + vec2( 546.0, -80.0 * iTime ), vec3( 0.07 ), 0.25 ); \n    BokehLayer( background, p * 2.3 + vec2( 45.0, -50.0 * iTime ), vec3( 0.03 ), 0.1 ); \n\n    vec3 color = background;\n\tfloat t = CastRay( rayOrigin, rayDir );\n    if ( t > 0.0 )\n    {        \n        vec3 pos = rayOrigin + t * rayDir;\n        vec3 normal = SceneNormal( pos );\n        \n        float specOcc = Smooth( 0.5 * length( pos - vec3( -0.1, -1.2, -0.2 ) ) );\n\n  \n        vec3 c0\t= vec3( 0.95, 0.99, 0.43 );\n        vec3 c1\t= vec3( 0.67, 0.1, 0.05 );\n        vec3 c2\t= WaterFillColor;\n        vec3 baseColor = normal.y > 0.0 ? mix( c1, c0, saturate( normal.y ) ) : mix( c1, c2, saturate( -normal.y ) );\n                \n        vec3 reflVec = reflect( rayDir, normal );        \n        float fresnel = saturate( pow( 1.2 + dot( rayDir, normal ), 5.0 ) );\n        color = 0.8 * baseColor + 0.6 * Water( reflVec ) * mix( 0.04, 1.0, fresnel * specOcc );\n\n        float transparency = Smooth( 0.9 + dot( rayDir, normal ) );\n        color = mix( color, background, transparency * specOcc );\n    }\n    \n    float vignette = q.x * q.y * ( 1.0 - q.x ) * ( 1.0 - q.y );\n    vignette = saturate( pow( 32.0 * vignette, 0.05 ) );\n    color *= vignette;\n        \n    fragColor = vec4( color, 1.0 );\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdsBz2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdsBzS", "name": "Spheres (99 chars)", "author": "rammoskar", "description": "Tried making something with less than 100 chars.", "tags": ["short"], "likes": 5, "viewed": 99, "date": "1496799594", "time_retrieved": "2024-06-20T18:56:42.584252", "image_code": "// Original by me\n//void mainImage(out vec4 o,vec2 u){for(u/=iTime;length(mod(o.xy+=.1*u,1.)-.5)>o.y*.1;);o*=.1;}\n\n// Fix by coyote\nvoid mainImage(out vec4 o,vec2 u){\n    for(o-=o;length(fract(o.xy+=.1*u/iTime)-.5)>o.y*.1;);\n    o*=.1;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdsBzS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdsfzS", "name": "Rotating Lines", "author": "Torumu106", "description": "I iminated my friend's video.", "tags": ["shader"], "likes": 1, "viewed": 149, "date": "1496821275", "time_retrieved": "2024-06-20T18:56:42.584252", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 r = 2.0 * vec2(uv.x - 0.5, uv.y - 0.5);\n    r.x *= iResolution.x / iResolution.y;\n    vec3 ret = vec3(1.0, 0.3, 0.3);\n    \n    float the = 0.0 + iTime * 0.3;\n    vec2 s = r;\n    s.xy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    \n    if(length(r) <= 0.1){\n    \tret = vec3(1.0);\n    }\n    else if(length(s) >= 0.3 && length(s) <= 0.32 && s.x <= 0.1){\n    \tret = vec3(1.0);\n    }\n    \n    the = 1.0 + iTime * 0.2;\n    s.xy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    if(length(s) >= 0.45 && length(s) <= 0.47 && s.x >= 0.1){\n    \tret = vec3(1.0);\n    }\n    \n    the = 1.0 + iTime * 0.2;\n    s.xy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    if(length(s) >= 0.6 && length(s) <= 0.62 && s.x <= -0.2){\n    \tret = vec3(1.0);\n    }\n    \n    the = 1.0 - iTime * 0.1;\n    s.xy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    if(length(s) >= 0.75 && length(s) <= 0.77 && s.x >= -0.4){\n    \tret = vec3(1.0);\n    }\n    \n    vec2 t = r;\n    \n    the = iTime * 0.1 - 0.7;\n    t.y *= 2.0;\n    t.xy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    if(length(t) >= 1.0 && length(t) <= 1.02 && (t.y >= 0.7 || t.y <= -0.7)){\n    \tret = vec3(1.0);\n    }\n    \n\tfragColor = vec4(ret,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdsfzS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdXBDf", "name": "SurMetaball", "author": "surma", "description": "A metaball", "tags": ["metaball"], "likes": 0, "viewed": 81, "date": "1498469741", "time_retrieved": "2024-06-20T18:56:43.263076", "image_code": "\n#define MAX_IT 256\n#define EPSILON 0.0001\n#define PI 3.1415926535\n\nvec4 sdSphere(vec3 p, float s, vec3 color) {\n  return vec4(color, length(p)-s);\n}\n\nvec4 udBox(vec3 p, vec3 b, vec3 color) {\n  return vec4(color, length(max(abs(p)-b,0.0)));\n}\n\nvec4 sdPlane(vec3 p, vec3 n, vec3 color) {\n  return vec4(color, dot(normalize(n), p));\n}\n\nmat4 genCameraMatrix(vec3 camera, vec3 up, vec3 lookAt, float fovy, float aspect) {\n  // Coordinate system\n  vec3 lookDir = normalize(lookAt - camera);\n  vec3 xDir = normalize(cross(lookDir, up));\n  vec3 yDir = normalize(cross(xDir, lookDir));\n  // Stretch vectors to size of canvas\n  xDir *= tan(fovy/360.0*PI);\n  yDir *= tan(fovy/360.0*PI)/aspect;\n\n  vec3 origin = camera + lookDir - xDir/2.0 - yDir/2.0;\n  return\n    mat4( // Translation to first pixel of canvas\n      1.0, 0.0, 0.0, 0.0,\n      0.0, 1.0, 0.0, 0.0,\n      0.0, 0.0, 1.0, 0.0,\n      origin, 1.0\n    ) * mat4( // Change of basis\n      vec4(xDir, 0.0),\n      vec4(yDir, 0.0),\n      vec4(-lookDir, 0.0),\n      0.0, 0.0, 0.0, 1.0\n    );\n}\n\nvec4 sdUnion(vec4 a, vec4 b) {\n  return a.w < b.w ? a : b;\n}\n\nvec3 sdRepeat(vec3 p, vec3 c) {\n  return mod(p,c)-0.5*c;\n}\n\nvec3 translate(vec3 p, vec3 t) {\n  return p - t;\n}\n\nfloat smin(float a, float b, float k) {\n    float res = exp(-k*a) + exp(-k*b);\n    return -log(res)/k;\n}\n\nvec4 smoothUnion(vec4 a, vec4 b) {\n  return vec4(a.rgb, smin(a.w, b.w, 0.8));\n}\n\nvec4 worldSDF(vec3 p) {\n  return\n    smoothUnion(\n      sdSphere(\n        translate(p, vec3(0.0, sin(iTime)*3.0+1.0, 0.0)),\n        1.0,\n        vec3(1.0, 0.0, 0.0)\n      ),\n      sdPlane(\n        translate(p, vec3(0.0, -1.0, 0.0)),\n        vec3(0.0, 1.0, 0.0),\n        vec3(1.0, 1.0, 1.0)\n      )\n    );\n}\n\nvec3 worldNormal(vec3 p) {\n  return normalize(\n    vec3(\n      worldSDF(p + vec3(EPSILON, 0.0, 0.0)).w - worldSDF(p - vec3(EPSILON, 0.0, 0.0)).w,\n      worldSDF(p + vec3(0.0, EPSILON, 0.0)).w - worldSDF(p - vec3(0.0, EPSILON, 0.0)).w,\n      worldSDF(p + vec3(0.0, 0.0, EPSILON)).w - worldSDF(p - vec3(0.0, 0.0, EPSILON)).w\n    )\n  );\n}\n\nfloat closestIntersection(vec3 ro, vec3 rd, float tstart) {\n  float t = tstart;\n  float d = 1.0;\n  int count = 0;\n  while(d > EPSILON && count < MAX_IT) {\n    d = worldSDF(ro + rd * t).w;\n    t += d;\n    count++;\n  }\n  return t + d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec3 camera = vec3(30.0 * sin(iTime), 15.0, 30.0 * cos(iTime));\n  //vec3 camera = vec3(0.0, 10.0, 30.0);\n  vec3 up = vec3(0.0, 1.0, 0.0);\n  vec3 lookAt = vec3(0.0, 0.0, 0.0);\n  vec3 light = vec3(12.0, 12.0, 12.0);\n  float fov = 45.0;\n  vec4 fogColor = vec4(0.5, 0.6, 0.7, 1.0);\n  float fogFactor = 0.04;\n\n\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  float aspectRatio = iResolution.x/iResolution.y;\n  mat4 cameraMatrix = genCameraMatrix(camera, up, lookAt, fov, aspectRatio);\n\n  vec3 rayDirection = normalize((cameraMatrix * vec4(uv, 0.0, 1.0)).xyz - camera);\n  float intersectionDistance = closestIntersection(camera, rayDirection, 0.0);\n  vec3 intersectionPoint = camera + rayDirection * intersectionDistance;\n  vec3 color = worldSDF(intersectionPoint).rgb;\n\n  vec3 toLight = light - intersectionPoint;\n  float shadowCasterDistance = closestIntersection(intersectionPoint, normalize(toLight), EPSILON*10.0);\n  float lightFactor = shadowCasterDistance < length(toLight) ? 0.0 : 1.0;\n  float distanceFromLight = clamp(1.0-length(toLight)/50.0, 0.0, 1.0);\n  float distanceFactor = pow(distanceFromLight, 2.0);\n  lightFactor *= distanceFactor;\n\n  float lambert = dot(worldNormal(intersectionPoint), normalize(toLight));\n\n  fragColor = vec4(color * vec3(lambert*lightFactor), 1.0);\n\n  float fogAmount = 1.0 - exp(-intersectionDistance * fogFactor);\n  fogAmount = pow(fogAmount, 10.0);\n  fragColor = mix(fragColor, fogColor, fogAmount);\n\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdXBDf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdXBzB", "name": "Bezier distance with 2 roots", "author": "tomkh", "description": "To find distance to quadratic bezier, we need only 2 roots i.e. we can ignore 3rd one (blue), because it is local maximum.\nIt's not much faster, but at least few cycles :)\n[url=http://polycu.be/edit/?h=L1VihH]Polycu.be[/url] version (with more control).", "tags": ["bezier", "distance", "optimization"], "likes": 23, "viewed": 1316, "date": "1496706647", "time_retrieved": "2024-06-20T18:56:44.560234", "image_code": "// Distance to quadratic bezier with 2 roots by Tom'2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// 3rd root is in all cases unnecessary (there is no blue area),\n// because it is local maximum (note: circle always contains two other roots).\n// This was actually suggested to me by Ken Silverman in 2010, while playing with distance\n// functions to Bezier curves, but we didn't come up with any actual proof.\n// It seems to be also true for 3d, which is pretty much the same code/formula,\n// you can just replace input \"vec2\" with \"vec3\".\n\n// As iq suggested here https://www.shadertoy.com/view/4dsfRS,\n// we can just draw diagram showing which root is the closest\n// (this doesn't really prove anything, but gives us a little bit of intuition)\n#define ROOT_DIAGRAM 1\n // 0 to just show color based on sign\n\n// Area/dots color coding:\n// 1st root (t_1) = orange\n// 2nd root (t_2) = green\n// 3rd root (t_3) = blue\n// if there is only one root: purple\n\n// Sketch of the proof:\n// Let's denote f(t) = d + (c + b*t)*t, as a quadratic bezier curve relative to the query point \"p\",\n// where b = A-2*B-C, c = 2*(B-A), d = A-p.\n// We want to find the global minimum of |f(t)|^2.\n// |f(t)|^2 has local extrema when d |f(t)|^2 / dt = 2*f(t).f'(t) = 0 <=> f(t).f'(t) = 0\n// (see http://ricedit.com/roots_of_quadratic.png).\n// We can derive that f(t).f'(t) = g(t) = 2b^2*t^3 + 3bc*t^2 + (2bd+c^2)*t + cd\n// Therefore g(t) = 0 is a cubic polynomial with 3 possible real roots at t in {t_1, t_2, t_3}.\n// Just by looking at http://mathworld.wolfram.com/CubicFormula.html,\n// we can see that roots can be found as follows:\n//  v = acos( x )/3 for some \"x\"\n//  assuming \"x\" can be anywhere within -1..1 range, v is between 0..pi/3 range\n//  t_1 = s*cos(v) - o, for some positive \"s\"\n//  t_2 = s*cos(v + 2pi/3) - o\n//  t_3 = s*cos(v + 4pi/3) - o\n// Now it is trivial (left as an excercise;)) to show that for all v in 0..pi/3:\n//  cos(v + 2pi/3) <= cos(v + 4pi/3) <= cos(v)\n// Therefore t_2 <= t_3 <= t_1.\n// We know that |f(t)|^2 has all local extrema at t_2, t_3 and t_1.\n// Therefore we have only two cases:\n//   1. We have local minima at t_1 and t_2 and local maximum at t_3\n//   2. We have local maxima at t_1 and t_2 and local minimum at t_3\n// By Fermat theorem, we know that extremum is a local maximum if second derivative is negative\n// (https://en.wikipedia.org/wiki/Derivative_test#Second_derivative_test_.28single_variable.29).\n// We can derive that g'(t) =  6b^2*t^2 + 6bc*t + 2bd+c^2\n// Assuming b!=0 (otherwise f(t) is a straight line, which is not interesting),\n// we know that 6b^2 > 0 and the parabola is opening up (going to +infinity at the boundaries),\n// therefore t_2 <= t_3 <= t_1 implies that g'(t_3) < max(g'(t_1), g'(t_2)).\n// This excludes case 2, where local maxima are at t_1 and t_2, \n// because g'(t_1) < 0 and g'(t_2) < 0 implies g'(t_3) < 0 and t_3 would have \n// to be local maximum as well, which is contradictory to this case.\n// The only case left is case 1, and local maximum obviously cannot be global minimum.\n// Q.E.D. ;)\n\n// Convenient implementation of cubic polynomial solver\n// https://www.shadertoy.com/view/ltXSDB by Adam Simmons, T21 and others\n// Additionally: returns number of roots\nvec4 solveCubic(float a, float b, float c)\n{\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec4(vec3(offset + uv.x + uv.y), 1.0);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec4(vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset, 3.0);\n}\n\n// Find the signed distance from a point to a bezier curve without clamping\nvec2 sdBezier(vec2 A, vec2 B, vec2 C, vec2 p, out vec4 rf)\n{   \n    // This is to prevent 3 colinear points, but there should be better solution to it.\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    \n    // Calculate roots.\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);      \n    vec4 t = solveCubic(k.x, k.y, k.z);\n\n    vec2 dp1 = d + (c + b*t.x)*t.x;\n    float d1 = dot(dp1, dp1);\n    vec2 dp2 = d + (c + b*t.y)*t.y;\n    float d2 = dot(dp2, dp2);\n    // note: 3rd root is unnecessary\n    \n  #if ROOT_DIAGRAM == 1\n    // return which root is closest, it's just for testing, otherwise can be removed\n    vec2 dp3 = d + (c + b*t.z)*t.z;\n    float d3 = dot(dp3, dp3);\n    vec3 rd = sqrt(vec3(d1,d2,d3)); rd -= min(min(rd.x,rd.y),rd.z);\n    rf = vec4(rd, t.w);\n  #endif\n\n    // Find closest distance and t\n    vec4 r = (d1 < d2) ? vec4(d1, t.x, dp1) : vec4(d2, t.y, dp2);\n\n    // Sign is just cross product with gradient\n    vec2 g = 2.*b*r.y + c;\n    float s =  sign(g.x*r.w - g.y*r.z);\n\n    return vec2(s*sqrt(r.x), r.y);\n}\n\nfloat sdSegment(vec2 a,vec2 b,vec2 p)\n{\n\tb -= a; p -= a;\n    return length(b*clamp(dot(p,b)/dot(b,b),0.,1.) - p);\n}\n\nfloat getRoots(vec2 A, vec2 B, vec2 C, vec2 p, out vec3 r[3])\n{   \n    // This is to prevent 3 colinear points, but there should be better solution to it.\n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    \n    // Calculate roots.\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);      \n    vec4 t = solveCubic(k.x, k.y, k.z);\n    \n    r[0] = vec3(A + (c + b*t.x)*t.x, t.x);\n    r[1] = vec3(A + (c + b*t.y)*t.y, t.y);\n    r[2] = vec3(A + (c + b*t.z)*t.z, t.z);\n    return t.w;\n}\n\n// Define root colors:\nconst vec3 rcol0 = vec3(1.,.6,.1);\nconst vec3 rcol1 = vec3(.1,.8,.1);\nconst vec3 rcol2 = vec3(.1,.6,1.);\nconst vec3 rcol3 = vec3(.8,.2,.8); // special color if there is only 1 root\n\nvoid plotRoot(vec3 rt, vec2 m, vec2 p, float ss, vec3 rcol, inout vec4 col)\n{\n    vec2 rd = rt.xy - m;\n\tfloat w  = length((p - vec2(rt.z,dot(rd,rd)))/vec2(8.,32.));\n    float alpha = smoothstep(.009,.006,w)*(1.-col.w);\n    col += vec4(mix(rcol,vec3(0),smoothstep(.006-ss*.2,.006,w)),1)*alpha;\n}\n\n// Plot |f(t)|^2\nvec4 plotDistance(vec2 A, vec2 B, vec2 C, vec2 m, float rn, vec3 rt[3], vec2 fragCoord, float ss)\n{\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - m;\n    vec2 p = fragCoord/iResolution.x;\n    p = vec2(p.x*8. - .6, p.y*32. - 2.);\n    if (p.x > 2. || p.y > 6.) return vec4(0);\n    vec2 r = d + (c + b*p.x)*p.x;\n    vec4 col = vec4(0);\n    float w, alpha;\n    if (rn < 1.5) {\n        plotRoot(rt[0],m,p,ss,rcol3,col);\n    } else {\n        plotRoot(rt[0],m,p,ss,rcol0,col);\n        plotRoot(rt[1],m,p,ss,rcol1,col);\n        plotRoot(rt[2],m,p,ss,rcol2,col);\n    }\n    w = p.y-dot(r,r);\n    w = smoothstep(fwidth(w)*1.5,0.,abs(w))*(1.-col.w);\n    col += vec4(1)*w*.9;\n    return col;\n}\n\nfloat cross2(vec2 a,vec2 b) { return a.x*b.y - a.y*b.x; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    vec2 m = mix((2.0*iMouse.xy-iResolution.xy)/iResolution.y,\n        vec2(cos(iTime * 1.2) * 0.8, 0.0), step(iMouse.z, 0.0));\n    \n    // Define the control points of our curve\n    vec2 A = vec2(0.0, -0.6), C = vec2(0.0, +0.6), B = vec2(-0.8, +0.6);\n\n    // Get the signed distance to bezier curve\n    vec4 rf;\n    vec2 r = sdBezier(A, B, C, p, rf);\n    \n    // Anti-alias factor\n    float ss = 1.5/iResolution.y;\n\n    float s = smoothstep(-ss,ss,r.x)*2. - 1.; // smooth sign\n    s *= sign(cross2(B-C,A-C)); // flip sign to always be positive on \"inside\"\n\n  #if ROOT_DIAGRAM == 0\n    // show sign\n    fragColor = vec4(.5) - .5*s*vec4(0.1,0.4,0.8,1.0);\n    fragColor *= fragColor; // to linear-space (for correct blending)\n  #else\n    // Show root field\n    rf.xyz = clamp((1.-rf.xyz*.5/ss),0.,1.);\n    vec3 rcol = mix((rcol0*rf.x + rcol1*rf.y + rcol2*rf.z)/(rf.x + rf.y + rf.z + 1e-6),\n                    rcol3, 1.-(rf.w-1.)*.5);\n    fragColor = vec4(rcol*rcol*.6,1);\n  #endif\n\n    // Display distance isolines\n    fragColor *= 1. + smoothstep(.02+ss*28.,.02,abs(fract(22.*r.x+.5)-.5))*.5;\n\n    // Make negative sign slightly lighter\n    fragColor = mix(fragColor, vec4(1), (-s+1.)*.05);\n    \n    vec3 rt[3];\n    float rn = getRoots(A, B, C, m, rt);\n    \n    // Plot polynomial:\n    vec4 rp = plotDistance(A,B,C,m,rn,rt,fragCoord,ss);\n    fragColor = mix(fragColor, vec4(rp.xyz,1), rp.w);\n    \n    // Show AA curve.\n    fragColor = mix(vec4(1), fragColor, smoothstep(0.01,0.01+ss,abs(r.x)) );\n    \n    // Render root points to mouse cursor:\n    float pd = min(min(sdSegment(m,rt[0].xy,p), sdSegment(m,rt[1].xy,p)), sdSegment(m,rt[2].xy,p));\n    fragColor = mix(fragColor, vec4(1), (1.-smoothstep(.002,0.002+ss,abs(pd)))*.6 );\n    \n    float dm = distance(p, m);\n    float d0 = distance(p, rt[0].xy);\n    vec4 crt = (d0 < dm) ? vec4(rcol3,d0) : vec4(1.,.1,.1,dm);\n    if (rn > 2.5)\n    {\n        float d1 = distance(p, rt[1].xy);\n        float d2 = distance(p, rt[2].xy);\n        if (d0 < dm) crt = vec4(rcol0,d0);\n        if (d1 < crt.w) crt = vec4(rcol1,d1);\n        if (d2 < crt.w) crt = vec4(rcol2,d2);\n        \n        // Show that 3rd root is local maximum by drawing circle crossing it:\n        fragColor = mix(fragColor, vec4(1),\n                        smoothstep(ss*1.5,0.,abs(distance(p,m)-distance(m,rt[2].xy)))*.8);\n    }\n    fragColor = mix(vec4(1.0 - smoothstep(0.03-ss, 0.03, crt.w))*vec4(crt.xyz,1),\n                    fragColor, smoothstep(0.03, 0.04, crt.w));\n    \n    // Render the control points\n    pd = min(distance(p, A),(min(distance(p, B),distance(p, C))));\n    fragColor = mix(vec4(1.0 - smoothstep(0.03-ss, 0.03, pd)), \n                    fragColor, smoothstep(0.03, 0.04, pd));\n    \n    // Back to gamma-space\n    fragColor = sqrt(fragColor);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdXBzB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdXBzS", "name": "Interactive Quasicrystal Zoom", "author": "Ebanflo", "description": "I don't really know anything about quasicrystals so I'm figuring out how [url=shadertoy.com/view/4tcXDl]sheepmaster's shader[/url] works.", "tags": ["2d", "fractal", "interactive", "quasicrystal", "zoom"], "likes": 8, "viewed": 664, "date": "1496705186", "time_retrieved": "2024-06-20T18:56:44.796602", "image_code": "const int numWaves = 5;\nconst float numStripes = 1.0;\nconst float numFreqs = 8.0;\nconst float meanFreq = 4.0;\nconst float stdDev = 2.0;\nconst float period = 3.0;\nconst float pi = 4.0 * atan(1.0);\nconst float pi2 = 2.0 * pi;\nconst float ln2 = log(2.0);\nconst float mean = meanFreq * .69314718;\n\nfloat wavething(int n, float x){\n    float l = ln2 * float(n) + log(x);\n    l -= mean;\n    return exp(-l * l / stdDev) / 2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = exp2(-fract(iTime / period));\n    float sum1 = 0.0;\n    for(int n = 0; n < int(numFreqs); n++){\n        sum1 += wavething(n, scale);\n    }\n    vec2 m = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n    if(iMouse.xy == vec2(0.0)) m = vec2(0.0);\n    vec2 xy = pi2 * numStripes\n        * ((2.0 * fragCoord - iResolution.xy) / iResolution.y - m);\n    \n    float sum2 = 0.0;\n    for(int n = 0; n < numWaves; n++){\n        float theta = pi * float(n) / float(numWaves);\n        vec2 waveVec = vec2(cos(theta), sin(theta));\n        float phase = dot(xy, waveVec);\n        for(int k = 0; k < int(numFreqs); k++){\n            sum2 += cos(phase * scale * exp2(float(k))) * wavething(k, scale);\n        }\n    }\n    fragColor = vec4(sum2 / sum1);\n    float r = length(xy);\n    fragColor.x *= .5 + .5 * sin(-iTime * .25 + r);\n    fragColor.y *= .5 + .5 * cos(iTime * .25 + r);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdXBzS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdXfDj", "name": "Extending ring", "author": "stas0", "description": "Extending ring", "tags": ["ring"], "likes": 6, "viewed": 424, "date": "1498080694", "time_retrieved": "2024-06-20T18:56:44.796602", "image_code": "#define PI 3.14159;\n\nfloat circle(vec2 uv, float width) {\n\tfloat add = fract(iTime);\n    float cOuter = step(length(uv), width + add);\n    float cInner = step(.0 + add, length(uv));\n    \n    float c = cOuter * cInner;\n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    vec3 color = vec3(.0, .0, .0);\n    \n    float e = exp(fract(iTime));\n    float c = circle(uv * e, .02);\n  \t\n    color = vec3(c);\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdXfDj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MdXfWS", "name": "Icosahedral Variations", "author": "dr2", "description": "Four simple objects based on the icosahedron (quatre objets simples bass sur l'icosadre, pour Fabrice); mousing allowed.", "tags": ["icosahedron", "symmetry"], "likes": 16, "viewed": 490, "date": "1497778988", "time_retrieved": "2024-06-20T18:56:44.802552", "image_code": "// \"Icosahedral Variations\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat SmoothMin (float a, float b, float r);\nvec2 Rot2D (vec2 q, float a);\n\nvec3 ltDir;\nfloat dstFar, tCur;\nconst float pi = 3.14159;\n\nvec3 IcosSym (vec3 p)\n{\n  const float dihedIcos = 0.5 * acos (sqrt (5.) / 3.);\n  float a, w;\n  w = 2. * pi / 3.;\n  p.z = abs (p.z);\n  p.yz = Rot2D (p.yz, - dihedIcos);\n  p.x = - abs (p.x);\n  for (int k = 0; k < 4; k ++) {\n    p.zy = Rot2D (p.zy, - dihedIcos);\n    p.y = - abs (p.y);\n    p.zy = Rot2D (p.zy, dihedIcos);\n    if (k < 3) p.xy = Rot2D (p.xy, - w);\n  }\n  p.z = - p.z;\n  a = mod (atan (p.x, p.y) + 0.5 * w, w) - 0.5 * w;\n  p.yx = vec2 (cos (a), sin (a)) * length (p.xy);\n  p.x -= 2. * p.x * step (0., p.x);\n  return p;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 pIco;\n  float d1, d2, t;\n  pIco = IcosSym (p);\n  t = floor (mod (0.2 * tCur, 4.));\n  d1 = 0.05 - ((t < 2.) ? abs (length (p) - 2.5) : abs (pIco.z + 2.3));\n  d2 = (mod (t, 2.) == 1.) ? 0.02 - abs (mod (pIco.y, 0.1) - 0.05) : 0.7 - pIco.y;\n  return - SmoothMin (d1, d2, 0.02);\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = ObjDf (ro + rd * dHit);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec3 e = vec3 (0.0001, -0.0001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 vn, col;\n  float dstObj, vDotL;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += rd * dstObj;\n    vn = ObjNf (ro);\n    vDotL = dot (ltDir, vn);\n    col = (dot (ro, vn) < 0.) ? vec3 (0.7, 0.2, 0.2) : vec3 (0.9, 0.9, 1.);\n    col = col * (0.1 + 0.2 * max (- vDotL, 0.) + 0.8 * max (vDotL, 0.)) +\n       0.3 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 256.);\n  } else col = vec3 (0., 0., 0.1);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float az, el;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  if (mPtr.z > 0.) {\n    az = 3. * pi * mPtr.x;\n    el = -0.1 * pi + 1. * pi * mPtr.y;\n  } else {\n    az = -0.02 * pi * tCur;\n    el = 0.1 * pi * sin (0.022 * pi * tCur);\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  rd = vuMat * normalize (vec3 (uv, 3.));\n  ro = vuMat * vec3 (0., 0., -10.);\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n  dstFar = 20.;\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MdXfWS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Mls3z8", "name": "Form constant test (fibonacci)", "author": "StingrayZ", "description": "Experimenting with form constants (successful right now)", "tags": ["formconstant", "form", "constant"], "likes": 2, "viewed": 97, "date": "1497274284", "time_retrieved": "2024-06-20T18:56:44.802552", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 position = (fragCoord.xy/iResolution.xy);\n\n    float cX = position.x - 0.5;\n    float cY = position.y - 0.5;\n\n    float newX =log2((sqrt(cX*cX + cY*cY))); //mainit \"acis\"\n    float newY = atan(cX, cY);\n     \n \n    \n\tfloat PI = 3.14159;\n    float PHI = 1.6180339887498948482;\n\t  \n    for(float i = 0.0; i < 6.0; i++) {\n    vec2(atan(((i/1.2*10.0*PI), sin(i/6.0*2.0*PI))));\n    }    \n    float numHorBands = 160.0;\n\tfloat numVertBands = 160.0;\n\tfloat numDiagBands = 160.0;\n    float numArms = 15.0;\n\tfloat numLines = 15.0;\n\tfloat numRings = 15.0;\n\tfloat spiralAngle = PI*2.0;\n\t\n    float color = 0.1;\n\t //Form constant equation: color += log((sqrt(cX*cX + cY*cY), atan(cX, cY)));\n\t//Vertical Bands\n\t//color += cos(numVertBands*cY + iTime);\t\n\t//Horizontal bands\n\t//color += cos(numHorBands*cX - iTime);\t\n\t//Diognal bands\n\t//color += cos(2.0*numDiagBands*(cX*sin(spiralAngle) + cY*cos(spiralAngle)) + iTime);\t\n\t//\"Arms\"\n\t//color += cos(numLines*newY / iTime);\n\t//Rings\n\tcolor += cos(numRings*newX + iTime*-16.18);//zooom speed\n    //Spiral counts\n\tcolor +=cos(numArms*(newX*sin(spiralAngle) + newY*cos(spiralAngle)) + iTime*-16.0);//Rotation speed\n\t//kopeja krasa un spilgtums\n\tcolor += sin(iTime*1.618); // Last tweaks\n    fragColor = vec4( vec3(cos( color ) * 1.5, color*PI, cos( color * iTime / 0.2*color ) * 0.0 ), 232 );  // Colors     \n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mls3z8.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsfBDs", "name": "Heart beat", "author": "gaz", "description": "fake particle", "tags": ["raymarching"], "likes": 11, "viewed": 377, "date": "1498832468", "time_retrieved": "2024-06-20T18:56:44.802552", "image_code": "#define PI radians(180.0)\n#define PI2 PI*2.0\n#define R 3.5\n#define A fract(iTime / R)\n#define T sin(PI2 * A)*0.5+0.5\n\nmat2 rotate(in float a)\n{\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nmat3 lookat(in vec3 eye, in vec3 target)\n{\n\tvec3 w = normalize(eye-target);\n\tvec3 u = normalize(cross(w,vec3(0.0,1.0,0.0)));\n\tvec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\n// https://www.shadertoy.com/view/MtsGWH\nvec4 boxmap(in sampler2D sam, in vec3 p, in vec3 n)\n{\n    vec3 m = pow(abs(n), vec3(8));\n\tvec4 x = textureLod(sam, p.yz, 0.0);\n\tvec4 y = textureLod(sam, p.zx, 0.0);\n\tvec4 z = textureLod(sam, p.xy, 0.0);\n\treturn (x*m.x + y*m.y + z*m.z)/(m.x+m.y+m.z);\n}\n\n// http://qiita.com/muripo_life/items/f24408ca1d06eb0658e3\nfloat sdHeart(in vec3 p, in float h)\n{\n    p.y += .5; // position ajust\n    \n    p.z *= 1.5;\n    return ( sqrt( dot(p,p) - pow(p.x*p.x+p.z*p.z/20., .33) *p.y ) - h ) / 2.;\n    \n    /*\n    p.y *= -1.0;\n    p.y -=0.5;\n    vec3 q = vec3(p.x, p.y, 1.5*p.z);\n    float de = sqrt(length(q)*length(q) + pow(p.x*p.x+0.1125*p.z*p.z, 0.33)*p.y)- h;\n    return 0.5*de;\n\t*/\n}\n\nfloat udRoundBox(in vec3 p, in vec3 b, in float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat map(in vec3 p)\n{  \n    float de = abs(mix(sdHeart(p,1.7), udRoundBox(p,vec3(1),0.3), T)) - 0.01;\n    //return max(de, -de - boxmap(iChannel0, p * 0.4, p).x + 0.6);\n    \n    p=normalize(p);\n    vec2 uv = vec2(atan(p.x, p.y), acos(p.z));\n    uv = floor(uv  * 100.0) / 100.0;\n    return max(de, -de - fract(sin(uv.x + uv.y * 100.0) * 1e4) + 0.6);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0, 2, 3.5);\n    vec3 rd = normalize(vec3(p, -2));    \n    vec3 ta = vec3(0,0,0);\n    ro.xz *= rotate(PI * A + 0.8);\n    rd = lookat(ro,ta) * rd;\n    vec3 col = vec3(0.1);\n\tconst float maxd = 10.0, precis = 0.001;\n\tfloat t = 0.0, d;\n \tfor(int i = 0; i < 32; i++)\n  \t{\n    \tt += d = map(ro + rd * t);\n    \tif(d < precis || t > maxd) break;\n  \t}\n  \tif(d < precis) col = mix(vec3(1,0.2,0.2), vec3(0.8), T);\n    fragColor = vec4(col, 1.0);\n}\n\n/*\n#define PI radians(180.0)\n#define PI2 radians(360.0)\n#define R 3.7\n\nmat3 rotate(in vec3 axis, in float theta)\n{\n  axis = normalize(axis);\n  float x = axis.x, y = axis.y, z = axis.z, s = sin(theta), c = cos(theta), o = 1.0-c;\n  return mat3(\n    o*x*x+c,o*x*y+z*s,o*z*x-y*s,\n    o*x*y-z*s,o*y*y+c,o*y*z+x*s,\n    o*z*x+y*s,o*y*z-x*s,o*z*z+c\n    );\n}\n\nmat3 lookat(in vec3 eye, in vec3 target)\n{\n\tvec3 w = normalize(eye-target);\n\tvec3 u = normalize(cross(w,vec3(0.0,1.0,0.0)));\n\tvec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\n// https://www.shadertoy.com/view/MtsGWH\nvec4 boxmap(sampler2D sam, in vec3 p, in vec3 n)\n{\n    vec3 m = pow(abs(n), vec3(8));\n\tvec4 x = textureLod(sam, p.yz, 0.0);\n\tvec4 y = textureLod(sam, p.zx, 0.0);\n\tvec4 z = textureLod(sam, p.xy, 0.0);\n\treturn (x*m.x + y*m.y + z*m.z)/(m.x+m.y+m.z);\n}\n\n// http://qiita.com/muripo_life/items/f24408ca1d06eb0658e3\nfloat sdHeart(vec3 p, float h)\n{\n    p.y *= -1.0;\n    p.y -=0.5;\n    vec3 q = vec3(p.x, p.y, 1.5*p.z);\n    float de = sqrt(length(q)*length(q) + pow(p.x*p.x+0.1125*p.z*p.z, 0.33)*p.y)- h;\n    return 0.5*de;\n}\n\nfloat udRoundBox(in vec3 p, in vec3 b, in float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat map(in vec3 p)\n{  \n    float de = abs(mix(\n        sdHeart(p,1.7),\n        udRoundBox(p,vec3(1),0.3),\n        sin(PI2 * fract(iTime / R))*0.5+0.5)\n        ) - 0.01;\n    return max(de, -de - boxmap(iChannel0, p * 0.4, p).x + 0.6);\n}\n\nvec3 doColor(vec3 p){\n    return mix(\n        \tvec3(1,0.2,0.2),\n        \tvec3(0.8),\n       \t\tsin(PI2 * fract(iTime / R))*0.5+0.5\n        );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0, 2, 3.5);\n    vec3 rd = normalize(vec3(p, -2));\n    \n    vec3 ta = vec3(0,0,0);\n    ro = rotate(vec3(0,1,0), PI * fract(iTime / R) + 0.8) * ro;\n    rd = lookat(ro,ta) * rd;\n\n    vec3 col = vec3(0.);\n\tconst float maxd = 10.0, precis = 0.001;\n\tfloat t = 0.0, d;\n \tfor(int i = 0; i < 32; i++)\n  \t{\n    \tt += d = map(ro + rd * t);\n    \tif(d < precis || t > maxd) break;\n  \t}\n  \tif(d < precis)\n  \t{\n\t  \tvec3 p = ro + rd * t;\n        col = doColor(p);\n    }\n    fragColor = vec4(col, 1.0);\n}\n*/", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsfBDs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsfBRS", "name": "y=x mod16 rotate", "author": "nosources", "description": "y=x mod16 rotate", "tags": ["fomular"], "likes": 2, "viewed": 100, "date": "1496670380", "time_retrieved": "2024-06-20T18:56:44.802552", "image_code": "const vec4 col0 = vec4(0.5, 0.5, 0.5, 1.0);\nconst vec4 col1 = vec4(0.7, 0.7, 0.7, 1.0);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float angle = iTime / 5.0;\n    mat2 rotate = mat2(sin(angle), -cos(angle),\n                       cos(angle), sin(angle));\n    fragCoord = rotate * fragCoord;\n    float d = fragCoord.x - fragCoord.y;\n    if( mod(d,32.0) > 16.0){\n        fragColor  = col0;\n    }else{\n        fragColor = col1;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsfBRS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsfBWj", "name": "TLLOM lean shader", "author": "cupofnestor", "description": "cos", "tags": ["cos"], "likes": 0, "viewed": 76, "date": "1498074930", "time_retrieved": "2024-06-20T18:56:44.802552", "image_code": "\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvec2 rotated(vec2 _uv, float _angle){\n    _uv -= vec2(0.5f,0.5f);\n    _uv = rotate2d( _angle ) * _uv;\n    _uv += vec2(0.5f,0.5f);\n    return _uv;\n}\n\nfloat cosColor(float f){\n    return 0.5*cos(f)+0.5;\n}\nfloat tanColor(float f){\n    float s = 0.5*sin(f)+0.5;\n    float c = 0.5*cos(f)+0.5;\n    return s*c;\n}\nfloat circ(vec2 xy){\n    float s = 0.5*sin(xy.x)+0.5;\n    float c = 0.5*cos(xy.y)+0.5;\n    return s*c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n       uv.x+= -1.0;\n    \n    vec2 uv2 = fragCoord.xy / iResolution.xy;\n    uv.x += 1.0;\n    vec2 somePt = vec2(0.5, 0);\n    \n    //uv -= vec2(0.5f,0.5f);\n    //uv = rotate2d( sin(iTime)*3.1416 ) * uv;\n    //uv += vec2(0.5f,0.5f);\n    \n    uv = rotated(uv, sin(iTime/3.18932)*1.07);\n \n    uv2 = rotated(uv2, cos(iTime/12.0)*1.07);\n    \n   \n    float d = pow( length( vec2( vec2(0.5, uv.y) - somePt) ),sin(uv.x)+0.5*2.0 );\n    //float d = length(vec2(vec2(0.5, uv.y) - somePt));\n    //float d = circ(uv);\n    float d2 = length(vec2(vec2(0.5, uv2.y) - somePt));\n    \n    \n    float c = cosColor(d*255.0);\n    float c2 = cosColor(d2*255.0);\n    \n    //float c2 = cos(d2*128.0)+0.5*0.5 ;\n    \n    //float c = max(cos(d*255.0), 0.0);\n    //float c2 = max(cos(d2*127.0), 0.0) ;\n    \n    float cc = (c+c2)/2.0;\n    //cc = step(0.5, cc);\n    fragColor = vec4(cc, cc, cc, 1.0);\n\t\n    //fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsfBWj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsfBWs", "name": "Fake menger", "author": "SudoNhim", "description": "Attempt to make something that looks like a menger with only one loop and very low iterations.", "tags": ["voxels", "menger"], "likes": 2, "viewed": 125, "date": "1498773538", "time_retrieved": "2024-06-20T18:56:45.354098", "image_code": "// Some code swiped and mangled from fb39ca4 :)\n\nconst int MAX_RAY_STEPS = 10;\n\nvec2 rotate2d(vec2 v, float a) {\n\tfloat sinA = sin(a);\n\tfloat cosA = cos(a);\n\treturn vec2(v.x * cosA - v.y * sinA, v.y * cosA + v.x * sinA);\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int actualRaySteps = 4 + int(iTime) % 10;\n    \n\tvec2 screenPos = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    screenPos.y += 0.01;\n\tvec3 cameraDir = vec3(0.0, 0.0, 0.8);\n\tvec3 cameraPlaneU = vec3(1.0, 0.0, 0.0);\n\tvec3 cameraPlaneV = vec3(0.0, 1.0, 0.0) * iResolution.y / iResolution.x;\n\tvec3 rayDir = cameraDir + screenPos.x * cameraPlaneU + screenPos.y * cameraPlaneV;\n    rayDir = normalize(rayDir);\n\tvec3 rayPos = vec3(0.5*sin(iTime * 0.17), 0.5 * sin(iTime * 0.23), 0.5 * sin(iTime * 0.3));\n\trayDir.xz = rotate2d(rayDir.xz, 1.5+3.3*sin(iTime*0.03));\n    rayPos += vec3(1.5);\n    \t\n    // This is just the basic voxel marching setup used throughout shadertoy, developed by fb39ca4 and others\n\tvec3 mapPos = vec3(floor(rayPos));\n\tvec3 deltaDist = abs(vec3(length(rayDir)) / rayDir);\n\tvec3 rayStep = sign(rayDir);\n\tvec3 sideDist = (sign(rayDir) * (mapPos - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist; \n\tvec3 mask;\n    \n    // Additionally, keep track of...\n    int spacefilling=0; // How many empty voxels were marched through\n    bool filled=false;  // Was the final voxel filled\n    \n    // This is the only loop, and it marches 4-10 steps depending on how deep the menger should be drawn\n    // The actual steps taken will be some mix of:\n    //    a] Step forwards into an empty voxel\n    // and\n    //    b] Move down the hierarchy of the menger\n\tfor (int i = 0; i < MAX_RAY_STEPS; i++) {\n        if (i > actualRaySteps) break;\n        mask = step(sideDist.xyz, sideDist.yzx) * step(sideDist.xyz, sideDist.zxy);\n        \n        // This checks the current map position to see if it intersects the menger\n        ivec3 relPos = ((ivec3(mapPos)+3333) % 3)-1;\n        bvec3 bb= bvec3(relPos);\n        bool isHit = (bb.x && bb.y) || (bb.y && bb.z) || (bb.x && bb.z);\n        \n        if (!isHit) { // No intersect - march forward one voxel\n            sideDist += mask * deltaDist;\n            mapPos += mask * rayStep;\n            \n            spacefilling++;\n            filled=true;\n            \n            ivec3 esc = ivec3(mask)*relPos;\n            if (esc.x + esc.y + esc.z != 0) {\n\n                // Set the new ray origin just slightly back of where the voxel would have been hit\n                rayPos = dot(mask, sideDist-sign(rayPos)*0.001)*rayDir + rayPos;\n\n                    // Scale ray origin up by 3x. This is equivalent to moving down-hierarchy\n                rayPos /= 3.;\n\n\n                // Reset the voxel marching\n                mapPos = vec3(floor(rayPos));\n                sideDist = (sign(rayDir) * (mapPos - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist;\n            }\n            \n    \t} else {// Intersect - move down-hierarchy instead of marching forward\n\t\t\t\n            // Set the new ray origin just slightly back of where the voxel would have been hit\n            rayPos = dot(mask, sideDist-sign(rayPos)*0.001)*rayDir + rayPos;\n            \n            // Scale ray origin up by 3x. This is equivalent to moving down-hierarchy\n            rayPos *= 3.;\n            \n            // Reset the voxel marching\n            mapPos = vec3(floor(rayPos));\n            sideDist = (sign(rayDir) * (mapPos - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist;\n            \n            filled = false;\n        } \n\t}\n\t\n    if (!filled) spacefilling++;\n    float f = float(spacefilling); \n\tfloat brightness = max(0.0, 1.0-float(f)/20.0);\n    vec3 color = vec3(sin(float(f)/3.0), 1.0, cos(float(f)/2.0));\n\n\tfragColor.rgb = color*brightness;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsfBWs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsfBzB", "name": "Blobby-ball thingies", "author": "piyushslayer", "description": "My first attempt at writing an sdf ray marching shader. 3 spheres smooth min-ed with pseudo random-ish movements. Stratified jittered AA. PBR w/ Burley diffuse & Karis prefiltered environment BRDF for IBL. Soft Shadows. Gamma correction and Tone Mapping.", "tags": ["raymarching", "blobs", "sdf", "metaballs", "ibl", "pbr"], "likes": 11, "viewed": 612, "date": "1496709650", "time_retrieved": "2024-06-20T18:56:47.639174", "image_code": "#define PI 3.14159265359\n\n// Comment/uncomment this to disable/enable anti-aliasing.\n// #define AA\n\n// The scene renderer averages pow(AA_SAMPLES, 2) random ray-marched samples for anti-aliasing.\n#define AA_SAMPLES 4\n\n// Enable or disable the rotating of the camera\n#define ROTATE_CAMERA 1\n\n// Material properties. Play around with these to change the way how the spheres are shaded.\nconst vec3 LIGHT_INTENSITY = vec3 (6.0);\nconst float INDIRECT_INTENSITY = 0.55;\nconst vec3 INDIRECT_SPECULAR_OFFSET = vec3(0.45, 0.65, 0.85);\n\nconst vec3 SPHERE0_RGB = vec3(0.4, 0.5, 0.0);\nconst vec3 SPHERE1_RGB = vec3(0.5, 0.0, 0.4);\nconst vec3 SPHERE2_RGB = vec3(0.0, 0.4, 0.5);\n\nconst float SPHERE_METALLIC = 0.99;\nconst float SPHERE_ROUGHNESS = 0.11;\n\n// If you decrease metalness factor above, make sure to also change this to something\n// non-metallic. Sample values can be found at: https://learnopengl.com/PBR/Theory\nconst vec3 SILVER_F0 = vec3(0.988, 0.98, 0.96);\n\n\n// Modified version of igo Qulez's integer hash3 function (https://www.shadertoy.com/view/llGSzw).\nvec2 Hash2(uint n) \n{\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    uvec2 k = n * uvec2(n,n*16807U);\n    return vec2( k & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nfloat UniformHash(vec2 xy)\n{\n\treturn fract(sin(dot(xy.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat SdPlane(vec3 p)\n{\n    return p.y;\n}\n\nfloat SdSphere(vec3 p, float s)\n{\n\treturn length(p) - s;  \n}\n\nvec2 SdUnion(vec2 d1, vec2 d2)\n{\n\treturn d1.x < d2.x ? d1 : d2;   \n}\n\nfloat SdSmoothMin(float a, float b)\n{\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat SdSmoothMin(float a, float b, vec3 mtl1, vec3 mtl0, inout vec3 mtl)\n{\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    float s = mix(b, a, h) - k * h * (1.0 - h);\n    float sA = s - a;\n    float sB = s - b;\n    float r = sA / (sA + sB);\n    mtl = mix(mtl1, mtl0, r);\n    return s;\n}\n\nconst float g_sRepeat = 800.0;\n\nvec2 PosIndex(vec3 pos)\n{\n\tvec2 posIndex;\n\tposIndex.x = floor((pos.x + 0.5 * g_sRepeat) / g_sRepeat);\n\tposIndex.y = floor((pos.y + 0.5 * g_sRepeat) / g_sRepeat);\n\treturn posIndex;\n}\n\nfloat UniformHashFromPos(vec3 pos)\n{\n\tpos.xy = PosIndex(pos);\n\treturn UniformHash(pos.xy);\n}\n\nvec3 VecOsc(vec3 vecFreq, vec3 vecAmp, float dT)\n{\n\treturn vecAmp * sin(vec3((iTime + dT) * 2.0 * PI) * vecFreq);\n}\n\nvec2 SdScene(vec3 p)\n{\n    float uniformRandom = UniformHashFromPos(p);\n    vec3 uSphereOsc1 = VecOsc(vec3(1.02389382 / 2.0, 1.0320809 / 3.0, 1.07381 / 4.0),\n\t\t\t\t\t\t\tvec3(0.25, 0.25, 0.1), uniformRandom);\n    vec3 uSphereOsc2 = VecOsc(vec3(1.032038 / 4.0, 1.13328 / 2.0, 1.09183 / 3.0),\n\t\t\t\t\t\t\tvec3(0.25, 0.25, 0.1), uniformRandom);\n    vec3 uSphereOsc3 = VecOsc(vec3(1.123283 / 3.0, 1.13323 / 4.0, 1.2238 / 2.0),\n\t\t\t\t\t\t\tvec3(0.25, 0.25, 0.1), uniformRandom);\n    return SdUnion(vec2(SdPlane(p), 1.0), \n                   vec2(\n                       SdSmoothMin(\n                           SdSmoothMin(\n                               SdSphere(p - vec3(0.0, 0.5, 0.0) + uSphereOsc1, 0.18),\n                               SdSphere(p - vec3(0.0, 0.5, 0.0) + uSphereOsc2, 0.2)\n\t\t     \t    \t   ),\n                       \t   SdSphere(p - vec3(0.0, 0.5, 0.0) + uSphereOsc3, 0.19)\n                       ),\n                       2.0\n                   )\n           );\n}\n\nvec2 SdScene(in vec3 p, inout vec3 mtl)\n{\n    float uniformRandom = UniformHashFromPos(p);\n    vec3 uSphereOsc1 = VecOsc(vec3(1.02389382 / 2.0, 1.0320809 / 3.0, 1.07381 / 4.0),\n\t\t\t\t\t\t\tvec3(0.25, 0.25, 0.1), uniformRandom);\n    vec3 uSphereOsc2 = VecOsc(vec3(1.032038 / 4.0, 1.13328 / 2.0, 1.09183 / 3.0),\n\t\t\t\t\t\t\tvec3(0.25, 0.25, 0.1), uniformRandom);\n    vec3 uSphereOsc3 = VecOsc(vec3(1.123283 / 3.0, 1.13323 / 4.0, 1.2238 / 2.0),\n\t\t\t\t\t\t\tvec3(0.25, 0.25, 0.1), uniformRandom);\n    \n    float smin1 = SdSmoothMin(\n                             SdSphere(p - vec3(0.0, 0.5, 0.0) + uSphereOsc1, 0.18),\n                             SdSphere(p - vec3(0.0, 0.5, 0.0) + uSphereOsc2, 0.2),\n        \t\t\t\t\t SPHERE0_RGB, SPHERE1_RGB, mtl\n\t\t\t\t  );\n    float smin2 = SdSmoothMin(smin1, SdSphere(p - vec3(0.0, 0.5, 0.0) + uSphereOsc3, 0.19),\n                              mtl, SPHERE2_RGB, mtl);\n    return SdUnion(vec2(SdPlane(p), 1.0), vec2(smin2, 2.0));\n}\n\nvec3 CalcNormal(vec3 p)\n{\n\tvec2 e = vec2(1.0,-1.0) * 0.5773 * 0.0005;\n    return normalize( e.xyy * SdScene( p + e.xyy ).x + \n\t\t\t\t\t  e.yyx * SdScene( p + e.yyx ).x + \n\t\t\t\t\t  e.yxy * SdScene( p + e.yxy ).x + \n\t\t\t\t\t  e.xxx * SdScene( p + e.xxx ).x );\n}\n\nfloat ShadowMarch(in vec3 origin, in vec3 rayDirection)\n{\n\tfloat result = 1.0;\n    float t = 0.01;\n    for (int i = 0; i < 64; ++i)\n    {\n        float hit = SdScene(origin + rayDirection * t).x;\n        if (hit < 0.001)\n            return 0.0;\n        result = min(result, 5.0 * hit / t);\n        t += hit;\n        if (t >= 1.5)\n            break;\n    }\n    \n    return clamp(result, 0.0, 1.0);\n}\n    \nvec2 RayMarch(in vec3 origin, in vec3 rayDirection, inout vec3 mtl)\n{\n    float material = -1.0;\n    float t = 0.01;\n\tfor(int i = 0; i < 64; ++i)\n    {\n        vec3 p = origin + rayDirection * t;\n        vec2 hit = SdScene(p, mtl);\n        if (hit.x < 0.001 * t || t > 50.0)\n\t\t\tbreak;\n        t += hit.x;\n        material = hit.y;\n    }\n    \n    if (t > 50.0)\n    {\n     \tmaterial = -1.0;   \n    }\n    return vec2(t, material);\n}\n\n//-----------------------------------------PBR Functions-----------------------------------------------//\n\n// Trowbridge-Reitz GGX based Normal distribution function\nfloat NormalDistributionGGX(float NdotH, float roughness)\n{    \n    float a = roughness * roughness;\n    float a2 = a * a;\n    float NdotH2 = NdotH * NdotH;\n    \n    float numerator = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom *= denom * PI;\n    \n    return numerator / denom;\n}\n\n// Schlick-Beckmann GGX approximation used for smith's method\nfloat GeometrySchlickGGX(float NdotX, float k)\n{\n    float numerator   = NdotX;\n    float denom = NdotX * (1.0 - k) + k;\n\n    return numerator / denom;\n}\n\n// Smith's method for calculating geometry shadowing\nfloat GeometrySmith(float NdotV, float NdotL, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n    //float k = (r*r) * sqrt(2.0 / PI);\n    \n    float ggx2 = GeometrySchlickGGX(NdotV, k);\n    float ggx1 = GeometrySchlickGGX(NdotL, k);\n\n    return ggx1 * ggx2;\n}\n\n// Schlick's approximation for Fresnel equation\nvec3 FresnelSchlick(float dotProd, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - dotProd, 5.0);\n}\n\nfloat FresnelSchlick(float dotProd, float F0, float F90)\n{\n    return F0 + (F90 - F0) * pow(1.0 - dotProd, 5.0);\n}\n\n// Burley 2012, \"Physically-Based Shading at Disney\"\nfloat DiffuseBurley(float linearRoughness, float NdotV, float NdotL, float LdotH)\n{\n    float f90 = 0.5 + 2.0 * linearRoughness * LdotH * LdotH;\n    float lightScatter = FresnelSchlick(NdotL, 1.0, f90);\n    float viewScatter  = FresnelSchlick(NdotV, 1.0, f90);\n    return lightScatter * viewScatter * (1.0 / PI);\n}\n\n// Irradiance from \"Ditch River\" IBL (http://www.hdrlabs.com/sibl/archive.html)\nvec3 DiffuseIrradiance(const vec3 n) \n{\n    return max(\n          vec3( 0.754554516862612,  0.748542953903366,  0.790921515418539)\n        + vec3(-0.083856548007422,  0.092533500963210,  0.322764661032516) * (n.y)\n        + vec3( 0.308152705331738,  0.366796330467391,  0.466698181299906) * (n.z)\n        + vec3(-0.188884931542396, -0.277402551592231, -0.377844212327557) * (n.x)\n        , 0.0);\n}\n\n// Karis 2014, \"Physically Based Material on Mobile\"\nvec2 PrefilteredEnvApprox(float roughness, float NoV) \n{\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\n//-----------------------------------------------------------------------------------------------------//\n\n// Handle the shading of the scene.\nvec3 RenderScene(in vec3 origin, in vec3 rayDirection, out float hitDistance)\n{\n    vec3 finalColor = vec3(0.0);\n    vec3 albedo = vec3(0.0);\n    vec3 sphereMaterial = vec3(0.0);\n\n    // returns distance and material\n    vec2 hit = RayMarch(origin, rayDirection, sphereMaterial);\n    hitDistance = hit.x;\n    float material = hit.y;\n    \n    vec3 sphereColor = vec3(0.13, 0.0, 0.5);\n    \n    if (material > 0.0)\n    {\n        // Essential vectors and scalars for lighting calculation\n        vec3 position = origin + hitDistance * rayDirection;\n        vec3 normal\t= CalcNormal(position);\n        vec3 viewDir = normalize(-rayDirection);\n        vec3 lightDir = normalize(vec3(20.6, 20.7, -20.7) - position);\n        vec3 halfVec = normalize(viewDir + lightDir);\n        vec3 reflectDir = normalize(reflect(rayDirection, normal));\n        \n        float NdotL = max(dot(normal, lightDir), 0.0);\n        float NdotV = max(dot(normal, viewDir), 0.0);\n        float NdotH = max(dot(normal, halfVec), 0.0);\n        float LdotH = max(dot(lightDir, halfVec), 0.0);\n        float VdotH = max(dot(halfVec, viewDir), 0.0);\n        \n        float roughness = 0.0, metallic = 0.0;\n        vec3 F0 = vec3(0.0);\n        \n        if (material < 2.0)\n        {\n            // Checkerboard floor\n        \tfloat f = mod(floor(7.5 * position.z) + floor(7.5 * position.x), 2.0);\n\t\t\talbedo = 0.4 + f * vec3(0.6);\n            roughness = (f > 0.5 ? 1.0 : 0.18);\n            metallic = 0.4;\n            // Plastic/Glass F0 value\n            F0 = mix(vec3(0.04), albedo, metallic);\n        } \n        else if (material < 3.0)\n        {\n            // Spheres\n         \talbedo =  sphereMaterial;\n            roughness = clamp(SPHERE_ROUGHNESS, 0.0, 1.0);\n            metallic = clamp(SPHERE_METALLIC, 0.0, 1.0);\n            // Silver F0 value\n            F0 = mix(SILVER_F0, albedo, metallic);\n        }\n         \n        \n        // Calculate radiance\n        //float lightDistance = length(lightDir);\n        //float attenuation = 1.0 / (lightDistance * lightDistance);\n        float attenuation = ShadowMarch(position, lightDir);\n        vec3 radiance = LIGHT_INTENSITY * attenuation;\n        \n        // Cook-Torrence specular BRDF\n        float ndf = NormalDistributionGGX(NdotH, roughness);\n        float geometry = GeometrySmith(NdotV, NdotL, roughness);\n        vec3 fresnel = FresnelSchlick(VdotH, F0);\n        \n        vec3 numerator = ndf * geometry * fresnel;\n        float denominator = 4.0 * NdotV * NdotL;\n        \n        vec3 specular = numerator / max(denominator, 0.0001);\n        \n        // Burley Diffuse BRDF\n        float diffuse = DiffuseBurley(roughness * roughness, NdotV, NdotL, LdotH);\n        \n        // Energy conservation\n        vec3 kS = fresnel;\n        vec3 kD = vec3(1.0) - kS;\n        // Diffuse light decreases as \"metal-ness\" increases (and vice versa).\n        kD *= 1.0 - metallic;\n        \n        vec3 ambient = 0.05 * albedo;\n            \n        // Note to self: Hmm, not sure whether to divide diffuse by PI or not. Some implementations\n        // do while others don't seem to.\n        // Also, note to self: We don't multiply by kS here because it's already done in the calculation\n        // of the numerator part of the specular component.\n        finalColor += (kD * albedo * diffuse / PI + specular + ambient) * radiance * NdotL;\n        \n        \n        // Indirect Lighting\n        sphereMaterial = vec3(0.0);\n        vec2 indirectHit = RayMarch(position, reflectDir, sphereMaterial);\n        vec3 indirectDiffuse = DiffuseIrradiance(normal) / PI;\n        vec3 indirectSpecular = INDIRECT_SPECULAR_OFFSET + reflectDir.y * 0.72;\n        \n        if (indirectHit.y > 0.0)\n        {\n            if (indirectHit.y < 2.0)\n            {\n                vec3 indirectPosition = position + indirectHit.x * reflectDir;\n                // Checkerboard floor\n                float f = mod(floor(7.5 * indirectPosition.z) + floor(7.5 * indirectPosition.x), 2.0);\n\t\t\t\tindirectSpecular = 0.4 + f * vec3(0.6);\n            }\n            else if (indirectHit.y < 3.0)\n            {\n                // Spheres\n                indirectSpecular = sphereMaterial;\n            }\n        }\n        \n        vec2 prefilteredSpecularBRDF = PrefilteredEnvApprox(roughness, NdotV);\n        vec3 indirectSpecularColor = F0 * prefilteredSpecularBRDF.x + prefilteredSpecularBRDF.y;\n        vec3 ibl = (1. - metallic) * albedo * indirectDiffuse + indirectSpecular * indirectSpecularColor;\n        \n        finalColor += ibl * INDIRECT_INTENSITY;\n    }\n    \n    return finalColor;\n}\n\n// Gamma correction\nvec3 LinearTosRGB(const vec3 linear)\n{\n    return pow(linear, vec3(1.0 / 2.2));\n}\n\n// Tone mapping\nvec3 AcesFilmicToneMap(const vec3 x)\n{\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\n// Generate the camera view matrix\nmat3 SetCamera(in vec3 origin, in vec3 target, float rotation)\n{\n    vec3 forward = normalize(target - origin);\n    vec3 orientation = vec3(sin(rotation), cos(rotation), 0.0);\n    vec3 left = normalize(cross(forward, orientation));\n    vec3 up = normalize(cross(left, forward));\n    return mat3(left, up, forward);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Set up the camera view matrix\n    vec3 lookAt = vec3(0.0, 0.25, 0.0);\n    float phi = iTime * 0.25 + PI; // horizontal plane angle\n    float theta = 0.3; // left-right (around y-axis) angle\n#if ROTATE_CAMERA\n    vec3 eyePosition = vec3(cos(theta)*cos(phi), sin(theta), cos(theta)*sin(phi)) * 4.0;\n#else\n    vec3 eyePosition = vec3(0.0, 1.0, -4.0);\n#endif\n    \n    // Calculate the camera matrix.\n    mat3 cameraToWorld = SetCamera(eyePosition, lookAt, 0.0);\n    \n    vec3 color = vec3(0.0);\n    float t;\n    \n#ifdef AA\n    \n    int totalAASamples = AA_SAMPLES*AA_SAMPLES;\n    for (int i = 0; i < totalAASamples; ++i)\n    {\n        \n        // Shamelessly plugged and modified from demofox's reflection/refraction shader.\n        // Calculates stratified subpixel jitter for anti-aliasing.\n        float x = mod(float(i), float(AA_SAMPLES));\n        float y = mod(float(i / AA_SAMPLES), float(AA_SAMPLES));\n        \n        vec2 jitter = (Hash2(uint(i)) + vec2(x, y)) / float(AA_SAMPLES);\n\n        vec2 uv = 2.0 * (fragCoord.xy + jitter) / iResolution.xy - 1.0;\n        uv.x *= iResolution.x / iResolution.y;\n\n#else\n        vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n        uv.x *= iResolution.x / iResolution.y;\n\n#endif    \n        // Ray direction starts from camera's current position\n        vec3 rayDirection = cameraToWorld * normalize(vec3(uv, 5.0));\n\n        // Ray march the scene using sdfs\n        color += RenderScene(eyePosition, rayDirection, t);    \n#ifdef AA\n    }\n    \n    color /= float(totalAASamples);\n#endif\n    \n    // Add a simple distance fog to the scene\n    float fog = 1.0 - exp2(-0.012 * t * t);\n    color = mix(color, 0.8 * vec3(0.6, 0.8, 1.0), fog);\n    \n    // Tone mapping\n    color = AcesFilmicToneMap(color);\n\n    // Gamma correction\n    color = LinearTosRGB(color);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsfBzB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsffDj", "name": "Worley Please Work", "author": "themdubs", "description": "Is bad", "tags": ["procedural"], "likes": 1, "viewed": 73, "date": "1498086459", "time_retrieved": "2024-06-20T18:56:47.639174", "image_code": "vec3 VoronoiHash(vec3 v, float s){\n \tv = mod(v,s);\n    v = vec3(dot(v, vec3(127.1,311.7,74.7)),\n             dot(v, vec3(269.5,183.3,246.1)),\n             dot(v, vec3(113.5,271.9,124.6)));\n    return fract(sin(v)*43758.5453123);\n}\n\nvec3 Voronoi(vec3 v, float s, bool inverted){\n \tv = v*s;\n    v = v+0.5;\n    vec3 p = floor(v);\n    vec3 f = fract(v);\n    \n    float id = 0.0;\n    vec2 res = vec2(1.0,1.0);\n    for(int k=-1;k<=1;k++){\n        for(int j=-1;j<=1;j++){\n            for(int i=-1;i<=1;i++){\n                vec3 b = vec3(i,j,k);\n                vec3 r = vec3(b)-f+VoronoiHash(p+b, s);\n                float d = dot(r,r);\n                if(d<res.x){\n                    id= dot(p+b, vec3(1.0,57.0,113.0));\n                    res = vec2(d,res.x);\n                }\n                else if(d<res.y){\n                    res.y = d;\n                }\n            }\n        }\n    }\n    vec2 result = res;\n    id = abs(id);\n    if(inverted)\n        return vec3(1.0-result, id);\n    else\n        return vec3(result, id);\n}\n\nfloat Worley3Octaves(vec3 p, float s){\n\tvec3 xyz = p;\n    \n    float worleyV1 = Voronoi(xyz, 1.0*s, true).r;\n    float worleyV2 = Voronoi(xyz, 2.0*s, false).r;\n    float worleyV3 = Voronoi(xyz, 4.0*s, false).r;\n    \n    worleyV1 = clamp(worleyV1, 0.0, 1.0);\n    worleyV2 = clamp(worleyV2, 0.0, 1.0);\n    worleyV3 = clamp(worleyV3, 0.0, 1.0);\n    \n    float worleyV = worleyV1;\n    worleyV = worleyV - worleyV2*0.3;\n    worleyV = worleyV - worleyV3*0.3;\n    return worleyV;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 pos = vec3(uv,sin(iTime/60.0));\n\tfragColor.r = Worley3Octaves(pos, 6.0);\n    fragColor.g = Worley3Octaves(pos, 6.0);\n    fragColor.b = Worley3Octaves(pos, 12.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsffDj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsffDS", "name": "Donut factory", "author": "anclin", "description": "raymarching, donuts, texture", "tags": ["raymarching", "texture", "donuts"], "likes": 11, "viewed": 389, "date": "1497811931", "time_retrieved": "2024-06-20T18:56:48.736092", "image_code": "const float EPSILON = 0.0001;\nconst float MAX_DIST = 100.0;\n\nfloat remap(float low1, float high1, float low2, float high2, float value){\n    return low2 + (value - low1) * (high2 - low2) / (high1 - low1);\n}\n\nfloat rSin(float time){\n    return remap(-1.0, 1.0, 0.0, 1.0, sin(time));\n}\n\nfloat r2Sin(float min, float max, float time){\n    return remap(-1.0, 1.0, min, max, sin(time));\n}\n\n/**\n * Rotation matrix around the Y axis.\n */\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n/**\n * Constructive solid geometry intersection operation on SDF-calculated distances.\n */\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\n/**\n * Constructive solid geometry union operation on SDF-calculated distances.\n */\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\n/**\n * Constructive solid geometry difference operation on SDF-calculated distances.\n */\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nfloat SphereSDF(vec3 p, float size){\n\treturn length(p) - size;\n}\n\nfloat CubeSDF(vec3 p, vec3 size){\n    vec3 d = abs(p) - size;\n    \n    float insideDistance = min( max(max(d.x, d.y),d.z), 0.0);\n    \n    float outsideDistance = length( max(d, 0.0) );\n    \n    return insideDistance + outsideDistance;\n}\n\nfloat TorusSDF( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n\n\nfloat SceneSDF(vec3 p){\n    \n    //p = rotateY(iTime * 0.2) * p;\n    \n    float pi = 3.14;\n    float angle = 0.25 * pi;//45\n    p = rotateY(angle) * p;\n    \n    float gap = 1.75;\n    \n    p.x = mod(p.x + gap, 2.0 * gap) - gap;\n    p.z = mod(p.z + gap, 2.0 * gap) - gap;\n    \n\tfloat torus = TorusSDF(p, vec2(1,0.5));\n    return torus;\n}\n\n\n\n\nvec3 EstimateNormal(vec3 p){\n\treturn normalize(vec3(\n        SceneSDF(vec3(p.x+EPSILON, p.y, p.z)) - SceneSDF(vec3(p.x-EPSILON, p.y, p.z)),\n        SceneSDF(vec3(p.x, p.y+EPSILON, p.z)) - SceneSDF(vec3(p.x, p.y-EPSILON, p.z)),\n        SceneSDF(vec3(p.x, p.y, p.z+EPSILON)) - SceneSDF(vec3(p.x, p.y, p.z-EPSILON))\n        ));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        SceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - SceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        SceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - SceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        SceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - SceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 RayDirection(float fieldOfView, vec2 fragCoord, vec2 size){\n\tvec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec4 ShortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end){\n\tfloat depth = start;\n\tvec3 pos = eye;\n    for(int i = 0; i < 255; i++){\n        vec3 pos = eye + depth * marchingDirection;\n    \tfloat dist = SceneSDF(pos);\n        if( dist <= EPSILON){\n            return vec4(pos,depth);\n        }\n        depth += dist;\n        if(depth >= end){\n            pos = eye + depth * marchingDirection;\n        \treturn vec4(pos,end);\n        }\n    }\n    return vec4(pos,end);\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 rayDir = RayDirection(45.0, fragCoord.xy, iResolution.xy);\n    \n    float t = iTime * 0.3;\n    vec3 eye = vec3(30.0 + 10.0 * cos(t * 1.1),\n                    r2Sin(3.0, 20.0, t * 1.2),\n                    0.0 + 10.0 * sin(t * 1.4));\n    \n    vec3 lookAtPos = vec3(1.0 + 0.0 * cos(t * 1.3),\n                          -3.0 + 0.0 * sin(t * 1.12),\n                          1.0 + 0.0 * sin(t * 1.3));\n    \n    mat4 viewToWorld = viewMatrix(eye, lookAtPos, vec3(0,1,0) );\n    vec3 worldDir = ( viewToWorld * vec4(rayDir,0) ).xyz;\n    \n    vec4 shortDist = ShortestDistanceToSurface(eye, worldDir, 0.0, 100.0);\n    vec3 pos = shortDist.xyz;\n    float dist = shortDist.w;\n    \n    vec3 ambientColor = vec3(0.5, 0.3, 0.3);\n    vec3 color = vec3(1,0,0);\n    \n    vec3 lightPos = vec3(0.5, 0.5, 0.5);\n    /*vec3 lightPos = vec3(4.0 * sin(iTime),\n                         6.0,\n                         4.0 * cos(iTime));*/\n    \n    \n    vec3 lightDirection = normalize(-lightPos);\n    \n    vec3 p = eye + dist * worldDir;\n    vec3 normal = estimateNormal(p);\n    float diffuse = dot(normal, -lightDirection);\n    diffuse = max(diffuse, 0.0);\n    \n    vec3 finalColor = vec3(0);\n    \n    // render donuts\n    if( dist < MAX_DIST){\n        \n        const vec3 donutColor = vec3(130.0, 84.0, 72.0) / 255.0;\n        const vec3 glazureColor = vec3(255.0, 176.0, 193.0) / 255.0;\n        const vec3 sprinklesColor = vec3(1);\n        \n        float t = iTime + pos.x * 0.2;\n        float wavesTresh = rSin(t * 3.0) * 0.06 + 0.06;\n        float tresh = rSin(cos(t) * 4.0) * 0.25;\n        \n        if(shortDist.y < cos(pos.x*10.0) * sin(pos.z*10.0) * wavesTresh + tresh){\n            finalColor = donutColor;\n        }\n        \n        else{\n            finalColor = glazureColor;\n            \n            // render sprinkles\n            if( shortDist.y > 0.3){\n            \tfloat noise = texture(iChannel0, pos.xz / 5.0 ).x;\n            \tfloat noise2 = step(0.85,noise);\n            \tfinalColor = mix( glazureColor, sprinklesColor, noise2);\n            }\n        }\n        \n        // apply diffuse\n        finalColor = finalColor * (diffuse + ambientColor);\n        \n\t\t// apply fog\n        float distToEye = length(eye - pos);\n        finalColor = finalColor * remap(70.0, 20.0, 0.0, 1.0, distToEye);\n    }\n    \n\tfragColor = vec4(finalColor,1);\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsffDS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsffWj", "name": "twisted sine columns", "author": "anclin", "description": "twisted sine columns", "tags": ["raymarchingtwistedsinecolumns"], "likes": 1, "viewed": 102, "date": "1498077131", "time_retrieved": "2024-06-20T18:56:49.736248", "image_code": "const float EPSILON = 0.001;\nconst float MAX_DIST = 100.0;\n\nfloat remap(float low1, float high1, float low2, float high2, float value){\n    return low2 + (value - low1) * (high2 - low2) / (high1 - low1);\n}\n\nfloat rSin(float time){\n    return remap(-1.0, 1.0, 0.0, 1.0, sin(time));\n}\n\nfloat r2Sin(float min, float max, float time){\n    return remap(-1.0, 1.0, min, max, sin(time));\n}\n\n/**\n * Rotation matrix around the Y axis.\n */\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n/**\n * Constructive solid geometry intersection operation on SDF-calculated distances.\n */\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\n/**\n * Constructive solid geometry union operation on SDF-calculated distances.\n */\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\n/**\n * Constructive solid geometry difference operation on SDF-calculated distances.\n */\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nfloat SphereSDF(vec3 p, float size){\n\treturn length(p) - size;\n}\n\nfloat CubeSDF(vec3 p, vec3 size){\n    vec3 d = abs(p) - size;\n    \n    float insideDistance = min( max(max(d.x, d.y),d.z), 0.0);\n    \n    float outsideDistance = length( max(d, 0.0) );\n    \n    return insideDistance + outsideDistance;\n}\n\nfloat TorusSDF( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\n\n\nfloat SceneSDF(vec3 p){\n    \n    float sy = 1.0 + r2Sin(0.0, 1.5, p.x / 2.0 + iTime);\n    float sz = 1.0;//0.0 + r2Sin(0.0, 1.5, p.x / 2.0 + iTime + 1.0);\n    \n    float gap = 1.75;\n    p.x = mod(p.x + gap, 2.0 * gap) - gap;\n    //p.z = mod(p.z + gap, 2.0 * gap) - gap;\n    \n    //p = rotateY(iTime * 0.2 + p.y) * p;\n    p = rotateY(p.y * r2Sin(0.0, 0.25, iTime * 0.5) * 3.14 * 0.5) * p;\n    //p = rotateY(p.y * p.z * 3.14 * 0.5) * p;\n    \n\n    \n    //p.x = mod(p.x + gap, 2.0 * gap) - gap;\n    //p.z = mod(p.z + gap, 2.0 * gap) - gap;\n    \n\tfloat torus = CubeSDF(p, vec3(1,sy,sz));\n    return torus;\n}\n\n\n\n\nvec3 EstimateNormal(vec3 p){\n\treturn normalize(vec3(\n        SceneSDF(vec3(p.x+EPSILON, p.y, p.z)) - SceneSDF(vec3(p.x-EPSILON, p.y, p.z)),\n        SceneSDF(vec3(p.x, p.y+EPSILON, p.z)) - SceneSDF(vec3(p.x, p.y-EPSILON, p.z)),\n        SceneSDF(vec3(p.x, p.y, p.z+EPSILON)) - SceneSDF(vec3(p.x, p.y, p.z-EPSILON))\n        ));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        SceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - SceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        SceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - SceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        SceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - SceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 RayDirection(float fieldOfView, vec2 fragCoord, vec2 size){\n\tvec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvec4 ShortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end){\n\tfloat depth = start;\n\tvec3 pos = eye;\n    for(int i = 0; i < 255; i++){\n        vec3 pos = eye + depth * marchingDirection;\n    \tfloat dist = SceneSDF(pos);\n        if( dist <= EPSILON){\n            return vec4(pos,depth);\n        }\n        depth += dist;\n        if(depth >= end){\n            pos = eye + depth * marchingDirection;\n        \treturn vec4(pos,end);\n        }\n    }\n    return vec4(pos,end);\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 rayDir = RayDirection(45.0, fragCoord.xy, iResolution.xy);\n    \n    float t = iTime * 0.3;\n    vec3 eye = vec3(0.0 + 0.0 * cos(t),\n                    10.0 + 0.0 * sin(t),\n                    20.0 + 0.0 * sin(t));\n    \n    vec3 lookAtPos = vec3(0.0 + 30.0 * cos(t * 1.1),\n                          0.0 + 0.0 * sin(t * 1.12),\n                          0.0 + 0.0 * sin(t * 1.3));\n    \n    mat4 viewToWorld = viewMatrix(eye, lookAtPos, vec3(0,1,0) );\n    vec3 worldDir = ( viewToWorld * vec4(rayDir,0) ).xyz;\n    \n    vec4 shortDist = ShortestDistanceToSurface(eye, worldDir, 0.0, 100.0);\n    vec3 pos = shortDist.xyz;\n    float dist = shortDist.w;\n    \n    vec3 ambientColor = vec3(0.5, 0.3, 0.3) * 0.3;\n    vec3 color = vec3(1,0,0);\n    \n    vec3 lightPos = vec3(0.0 + 0.0 * sin(iTime),\n                         6.0,\n                         3.0 + 0.0 * cos(iTime));\n    \n    \n    vec3 lightDirection = normalize(-lightPos);\n    \n    vec3 p = eye + dist * worldDir;\n    vec3 normal = estimateNormal(p);\n    float diffuse = dot(normal, -lightDirection);\n    diffuse = max(diffuse, 0.0);\n    \n    vec3 finalColor = vec3(0);\n    \n    // render donuts\n    if( dist < MAX_DIST){\n        \n        finalColor = vec3(1);\n        \n        // apply diffuse\n        finalColor = finalColor * (diffuse + ambientColor);\n        \n\t\t// apply fog\n        float distToEye = length(eye - pos);\n        //finalColor = finalColor * remap(70.0, 20.0, 0.0, 1.0, distToEye);\n    }\n    \n\tfragColor = vec4(finalColor,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsffWj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Msffz2", "name": "Neon ripples with split effect", "author": "adambene", "description": "Neon ripples with RGB split effect.\nClick anywhere to set center.\n", "tags": ["rings", "ripple", "rgbsplit", "shift", "split"], "likes": 4, "viewed": 182, "date": "1496984619", "time_retrieved": "2024-06-20T18:56:49.736248", "image_code": "#define PI 3.141592654\n#define t iTime\n#define speed 4.\n#define size 50.\n#define start_split .2\n#define split 1.2\n#define fade 5.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = fragCoord.xy / iResolution.xy;\n\n    // distance from mouse pointer\n    float dist = length(iMouse.xy - fragCoord.xy) / iResolution.y,\n             s = start_split + split*dist,\n         phase = dist*size - t*speed;\n\n\tfragColor = vec4(.55, .5, .55, 0)\n              + vec4(.3, 1, .3, 0) * sin(phase\n              + s * vec4(0, 1, 2, 0)) / (dist * fade);\n}\n", "image_inputs": [{"id": "MdsSWN", "previewfilepath": "https://soundcloud.com/mark-aria/sleep-music-delta-waves", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/mark-aria/sleep-music-delta-waves", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Msffz2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Msffzf", "name": "Bankohan", "author": "amagitakayosi", "description": "Trying to simulate paopei \"Bankohan\" http://www.angelfire.com/anime3/karrafear/Paopei/Bankohan.html", "tags": ["raymarching"], "likes": 7, "viewed": 530, "date": "1497245948", "time_retrieved": "2024-06-20T18:56:50.645430", "image_code": "precision mediump float;\n#define GLSLIFY 1\nuniform float time;\nuniform vec2  mouse;\nuniform vec2  resolution;\nconst float PI = 3.1415926535897932384626433;\n\nvec2 squareFrame(vec2 screenSize) {\n  vec2 position = 2.0 * (gl_FragCoord.xy / screenSize.xy) - 1.0;\n  position.x *= screenSize.x / screenSize.y;\n  return position;\n}\n\nmat3 calcLookAtMatrix(vec3 origin, vec3 target, float roll) {\n  vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n  vec3 ww = normalize(target - origin);\n  vec3 uu = normalize(cross(ww, rr));\n  vec3 vv = normalize(cross(uu, ww));\n\n  return mat3(uu, vv, ww);\n}\n\nvec3 getRay(mat3 camMat, vec2 screenPos, float lensLength) {\n  return normalize(camMat * vec3(screenPos, lensLength));\n}\n\nvec3 getRay(vec3 origin, vec3 target, vec2 screenPos, float lensLength) {\n  mat3 camMat = calcLookAtMatrix(origin, target, 0.0);\n  return getRay(camMat, screenPos, lensLength);\n}\n\nvec2 map(vec3 p);\n// Originally sourced from https://www.shadertoy.com/view/ldfSWs\n// Thank you Iigo :)\n\nvec2 calcRayIntersection(vec3 rayOrigin, vec3 rayDir, float maxd, float precis, float reduction) {\n  float latest = precis * 2.0;\n  float dist   = +0.0;\n  float type   = -1.0;\n  vec2  res    = vec2(-1.0, -1.0);\n\n  for (int i = 0; i < 30; i++) {\n    if (latest < precis || dist > maxd) break;\n\n    vec2 result = map(rayOrigin + rayDir * dist);\n\n    latest = result.x;\n    type   = result.y;\n    dist  += latest * reduction;\n  }\n\n  if (dist < maxd) {\n    res = vec2(dist, type);\n  }\n\n  return res;\n}\n\nvec2 calcRayIntersection(vec3 rayOrigin, vec3 rayDir) {\n  return calcRayIntersection(rayOrigin, rayDir, 20.0, 0.001, 1.0);\n}\n\n// Originally sourced from https://www.shadertoy.com/view/ldfSWs\n// Thank you Iigo :)\n\nvec3 calcNormal(vec3 pos, float eps) {\n  const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n  const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n  const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n  const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n  return normalize( v1 * map( pos + v1*eps ).x +\n                    v2 * map( pos + v2*eps ).x +\n                    v3 * map( pos + v3*eps ).x +\n                    v4 * map( pos + v4*eps ).x );\n}\n\nvec3 calcNormal(vec3 pos) {\n  return calcNormal(pos, 0.002);\n}\n\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec2 rotate(in vec2 v, in float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat2 m = mat2(c, -s, s, c);\n    return m * v;\n}\n\n#define NUM 1.\n\nfloat t() {\n    return iTime * .3;\n}\n\nfloat smoothMin(float d1, float d2, float k){\n    float h = exp(-k * d1) + exp(-k * d2);\n    return -log(h) / k;\n}\n\nvec2 sdSpheres(in vec3 p) {\n    vec3 c1 = vec3(0);\n    float d1 = length(p - c1) - 2.4;\n\n    float d = 9999.;\n\n    for (int i = 0; i < 3; i++) {\n        float fi = float(i);\n        float ti = (1. - pow(1. - fract((t() + fi * .2)), 1.5)) * 8.;\n\n        vec3 u = vec3(rotate(vec2(1, 0), (fi + 1.) * .7 * PI), 0);\n        u.xy = rotate(u.xy, (fi + 1.) * .3);\n        u.xz = rotate(u.xz, (fi * 2. + 1.) * 1.9);\n        vec3 c2 = u * ti;\n        float d2 = length(p - c2) - .7;\n\n        float a1 = max(dot(normalize(p - c1), normalize(c2 - c1)), 0.);\n        float a2 = max(dot(normalize(p - c2), normalize(c1 - c2)), 0.);\n\n        d = smoothMin(\n            d,\n            smoothMin(\n                d1 * (1.1 - pow(a1, 20.)),\n                d2 * (1.1 - pow(a2, 20.)),\n                2.2\n            ),\n            2.5\n        );\n\n        for (int j = 0; j < 5; j++) {\n            float fj = float(j);\n            float tj = (1. - pow(1. - max(ti - 5. + fj * .8, 0.) / 3., 3.)) * 4.;\n\n            vec3 uj = vec3(rotate(vec2(1, 0), (fj + 1.) * .4 * PI + 1.5 * PI), 0);\n            uj.xy = rotate(uj.xy, (fi + 1.) * 1.3);\n            uj.xz = rotate(uj.xz, (fi * 3. + 1.) * .9);\n\n            vec3 cj = c2 + uj * tj;\n            float dj = length(p - cj) - .3;\n\n            float aj1 = max(dot(normalize(p - c2), normalize(cj - c2)), 0.);\n            float aj2 = max(dot(normalize(p - cj), normalize(c2 - cj)), 0.);\n\n            d = smoothMin(\n                d,\n                smoothMin(\n                    d2 * (1.1 - pow(aj1, 10.)),\n                    dj * (1.1 - pow(aj2, 10.)),\n                    4.3\n                ),\n                3.6\n            );\n        }\n    }\n\n    return vec2(d, 0);\n}\n\nvec2 map(vec3 p) {\n    return sdSpheres(p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 rayOrigin = vec3(0, 5, 10);\n    rayOrigin.xy = rotate(rayOrigin.xy, t() * 2.7);\n    rayOrigin.z = sin(t() * 1.) * 3. + 10.;\n\n    vec3 rayTarget = vec3(0, 0, 0);\n    vec3 rayDirection = getRay(rayOrigin, rayTarget, squareFrame(iResolution.xy), 1.);\n\n    vec3 lightDir = normalize(vec3(0, 2, 1.));\n    vec3 light = vec3(.4, .2, .4) * 1.6;\n    vec3 ambient = vec3(-.3, 0, -.1);\n\n    vec2 collision = calcRayIntersection(rayOrigin, rayDirection, 20., 0.001, .8);\n    if (collision.x > .5) {\n        vec3 pos = rayOrigin + rayDirection * collision.x;\n        vec3 normal = calcNormal(pos);\n        float diff = clamp(dot(lightDir, normal), 0., 1.0);\n        vec3 c = diff * light + ambient;\n        fragColor = vec4(c, 1.0);\n    }\n    else {\n        float c = 1. - length(fragCoord.xy / iResolution.xy - 0.5);\n        fragColor = vec4(c * vec3(0.7, 0.8, 1.), 1);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Msffzf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Msffzj", "name": " Power Packed Alliance 6", "author": "patu", "description": "Used as visuals in cooperation of polish demoscene musicians. \nReleased in wild compo at Decrunch copy party, 3 June 2017\n \nhttp://www.pouet.net/prod.php?which=70247", "tags": ["tunnel", "demoscene"], "likes": 18, "viewed": 676, "date": "1497050585", "time_retrieved": "2024-06-20T18:56:52.166757", "image_code": "/*\n\n\tTunnel6 a.k.a \"Polish up\"\n    for cooperation of polish demoscene musicians, called:\n    \n    \n    \"Power Packed Alliance\".\n    -----------------------------------\n\n\thttps://www.youtube.com/watch?v=_lSReW7eRI4\n    http://www.pouet.net/prod.php?which=70247\n\n\t\n    \n    also check my chrome extension for Shadertoy:\n    https://chrome.google.com/webstore/detail/shadertoy-unofficial-plug/ohicbclhdmkhoabobgppffepcopomhgl?hl=pl\n\n*/\n\n#define getNormal getNormalHex\n\n#define INFINITY 1e32\n#define FAR 30.\n#define t iTime\n#define mt iTime * 1.2 \n#define FOV 90.0\n#define FOG .7\n\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (1.618033988749895)\n\nvec3 os;\n\nvec3 pal( in float ta, in vec3 a, in vec3 b, in vec3 c, in vec3 d ){return a + b*cos( 6.28318*(c*ta+d) );}\n\n// \t3D noise function (IQ)\nfloat noise(vec3 p)\n{\n\tvec3 ip=floor(p);\n    p-=ip; \n    vec3 s=vec3(7,157,113);\n    vec4 h=vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\n    p=p*p*(3.-2.*p); \n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z); \n}\n\nfloat yC(float x) {\n \treturn cos(x * -.134) * 1. * sin(x * .13) * 15.+ noise(vec3(x * .01, 0., 0.) * 55.4);\n}\n\nfloat vol = 0.;\n\nvec3 light = vec3(0.0);\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Repeat in three dimensions\nvec3 pMod3(inout vec3 p, vec3 size) {\n\tvec3 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\treturn c;\n}\n\nfloat opU2( float d1, float d2 ) {\n    if (d1 < d2) return d1;\n    return d2;\n}\n\nvec3 opU2( vec3 d1, vec3 d2 ) {\n    if (d1.x < d2.x) return d1;\n    return d2;\n}\n\nvec3 opS2( vec3 d1, vec3 d2 )\n{\t\n    if (-d2.x > d1.x) return -d2;\n    return d1;\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat fCross(vec3 p, vec3 size) {\n    float obj = fBox(p, size);\n    obj = opU2(obj, fBox(p, size.zxy));\n    obj = opU2(obj, fBox(p, size.yzx));               \n    return obj;\n}\n\nvec3 map(vec3 p) {\n    p.y -= yC(p.x);\n    vec3 \n        obj = vec3(FAR, 0.0, 0.0),\n        obj2 = obj,\n        obj3 = obj;\n    \n    vec3 orgP = p;\n    vec3 orgP3 = orgP;\n\n\torgP3 = p;\n    \n    vec3 pp = pMod3(orgP3, vec3(2.4));\n    p = orgP3;\n    \n    obj = vec3(\n        fBox(p, vec3(1.05)), \n        1.0, \n        1.0\n    );\n    \n    vec3 orgP2 = orgP;\n    \n    pR(orgP.zy, orgP.x / 12.);\n\t\n    vec3 size = vec3(0.725 , 1.5, 1.275);\n    \n    p = opRep(orgP, vec3(0.35, 0.1, .4) + size.x + size.y + size.z);\n    \n    obj = opS2(\n        obj, \n        vec3(                \n            fCross(p, size), \n            0.0, \n            1.0\n        )\n    );\n\t\n    size *= 1.2;\n    p = opRep(orgP, vec3(0.35, 0.5, 0.1) + size.x + size.x + size.z);\n    \n    obj = opS2(\n        obj, \n        vec3(                \n            fCross(p, size), \n            0.0, \n            1.0\n        )\n    );\n    p = orgP2;\n    float n = noise(p);\n  \tpR(p.yz, p.x * .8 + n * 7.);\n    p.y += .6;\n   \n    p = orgP2;\n\n    obj = opS2(obj, vec3(fCross(p, vec3(1e32, .6, .6) ), 1., 1.)); \n\n\tobj3.x = mix(-length(p.zy) + 1., obj3.x,  .6  *  n)- .1;\n    obj3 = opU2(obj, vec3(fBox(p, vec3(1.1))));\n\tos = p;\n    \n    return obj3;\n}\n\nvec3 trace(vec3 prp, vec3 scp) {\n    vec3 \n        tr = vec3(0., -1., 0.),\n        d;\n    \n    for (int i = 0; i < 164; i++) {\t\n        d = map(prp + scp * tr.x);\n        tr.x += d.x * .4;\n\n        if ((abs(d.x) < .0001) || (tr.x > FAR)) break;\n    }\n    \n    tr.yz = d.yz;\n\treturn tr;\n    \n}\nvec3 traceRef(vec3 ro, vec3 rd) {\n    vec3 \n        tr = vec3(0., -1., 0.),\n        d;\n    \n    for (int i = 0; i < 50; i++) {\n        d = map(ro + rd * tr.x);\n        tr.x += d.x;\n        \n        if (abs(d.x) < 0.0055 || tr.x> FAR) break;\n    }\n    \n    tr.yz = d.yz;\n    return tr;\n}\n\nfloat softShadow(vec3 ro, vec3 lp, float k) {\n    const int maxIterationsShad = 12;\n    vec3 rd = (lp - ro); \n\n    float shade = .1;\n    float dist = 2.2;\n    float end = max(length(rd), 0.001);\n    float stepDist = end / float(maxIterationsShad);\n\n    rd /= end;\n    for (int i = 0; i < maxIterationsShad; i++) {\n        float h = map(ro + rd * dist).x;\n        shade = min(shade, smoothstep(0.0, 1.0, k * h / dist)); \n        dist += min(h, stepDist * 2.); \n        if (h < 0.001 || dist > end) break;\n    }\n    return min(max(shade, 0.), 1.0);\n}\n\n\n#define EPSILON .1\nvec3 getNormalHex(vec3 pos)\n{\n\tfloat d=map(pos).x;\n\treturn normalize(\n        vec3(\n            map(\n                pos+vec3(EPSILON,0,0)).x-d,\n                map(pos+vec3(0,EPSILON,0)).x-d,\n                map(pos+vec3(0,0,EPSILON)).x-d \n        \t)\n    \t);\n}\n\nfloat getAO(in vec3 hitp, in vec3 normal)\n{\n    float dist = 0.2;\n    vec3 spos = hitp + normal * dist;\n    float sdist = map(spos).x;\n    return clamp(sdist / dist, 0.0, 1.0);\n}\n\nvec3 getObjectColor(vec3 p, vec3 n, inout vec2 mat) {\n    vec3 col = vec3(.4, 0.6, 1.);    \n\t\n    col = pal( p.x * 0.01, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );\n   \tcol *= 1.+ pow(noise( os * 5.) * noise(p * 3.2), 1.);\n    \n    return col;\n}\n\nvec3 doColor( in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, inout vec2 mat) {\n\tvec3 sceneCol = vec3(0.0);\n    \n    vec3 ld = lp - sp; \n    float lDist = max(length(ld), 0.001); \n    ld /= lDist;\n\n    float atten = max(0.1, 2.0 / (1.0 + lDist * .525 + lDist * lDist * 1.05));\n    float diff = max(dot(sn, ld), .1);\n    float spec = pow(max(dot(reflect(-ld, sn), -rd), .5), 2.0);\n   \n    vec3 objCol = getObjectColor(sp, sn, mat);\n    sceneCol += (objCol * (diff + 0.15) + vec3(.3, .4, .6) * spec * 1.) * atten;\n\n    return sceneCol;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec2 uv = fragCoord.xy / iResolution.xy - .5;\n\tuv.x /= iResolution.y / iResolution.x;\n    \n    uv *= tan(radians (FOV) / 2.0);\n    \n    vol = texture(iChannel0, vec2(.0, .25)).r  * 1.; \n    \n    float \n        sk = sin(mt * .2) * 2.0,\n        ck = cos(mt * .3) * 2.0,\n        \n        mat = 0.;\n    \n    light = vec3(0., 0., 11.);        \n    \n    vec3 sceneColor = vec3(0.);\n    float camx = mt;\n    \n    vec3 \n        vuv = vec3(0., 1., 0.),\n    \tro = vec3(camx, yC(camx), 0.),\n    \tvrp =  vec3(camx + 1., yC(camx + 1.5), 0.),\n    \tvpn = normalize(vrp - ro),\n    \tu = normalize(cross(vuv, vpn)),\n    \tv = cross(vpn, u),\n    \tvcv = (ro + vpn),\n    \tscrCoord = (vcv + uv.x * u * iResolution.x/iResolution.y + uv.y * v),\n    \trd = normalize(scrCoord - ro);        \n\t\n    light = ro;\n    \n    vec3 lp = vrp;\n    \n\tvec3 orgRO = ro,\n         orgRD = rd;\n\t\n    vec3 tr = trace(ro, rd), otr;\n    \n    float fog = smoothstep(FAR * FOG, 0., tr.x * 1.);\n    \n    ro += rd * tr.x;\n    otr = ro;\n    \n    vec3 sn = getNormal(ro);\t\n    float ao = getAO(ro, sn);\n   \t\n    sceneColor += doColor(ro, rd, sn, lp, tr.yz);\n    \n    float dist = tr.x;\n    \n    rd = reflect(rd, sn);\n    tr = traceRef(ro + rd * .03, rd);\n    ro += rd * tr.x;\n    sn = getNormal(ro);\n    sceneColor += doColor(ro, rd, sn, lp, tr.yz) * .3;\n\n    fragColor = vec4(clamp(sceneColor * 1.3, 0.0, 1.0), tr.x / FAR);\n}\n", "image_inputs": [{"id": "lssSD4", "previewfilepath": "https://soundcloud.com/decrunch/power-packed-alliance", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/decrunch/power-packed-alliance", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Msffzj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MslBDB", "name": "Duckohedron", "author": "dr2", "description": "Just one duck", "tags": ["icosahedron", "symmetry"], "likes": 23, "viewed": 493, "date": "1497990223", "time_retrieved": "2024-06-20T18:56:52.178916", "image_code": "// \"Duckohedron\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrEllipsDf (vec3 p, vec3 r);\nfloat PrEllCylDf (vec3 p, vec2 r, float h);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat SmoothMin (float a, float b, float r);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\n\nvec3 ltDir, qHit;\nfloat dstFar, tCur, dRot;\nint idObj;\nconst int idBdy = 1, idWng = 2, idHead = 3, idBk = 4, idPol = 5;\nconst float pi = 3.14159;\n\nvec3 IcosSym (vec3 p)\n{\n  const float dihedIcos = 0.5 * acos (sqrt (5.) / 3.);\n  float a, w;\n  w = 2. * pi / 3.;\n  p.z = abs (p.z);\n  p.yz = Rot2D (p.yz, - dihedIcos);\n  p.x = - abs (p.x);\n  for (int k = 0; k < 4; k ++) {\n    p.zy = Rot2D (p.zy, - dihedIcos);\n    p.y = - abs (p.y);\n    p.zy = Rot2D (p.zy, dihedIcos);\n    if (k < 3) p.xy = Rot2D (p.xy, - w);\n  }\n  p.z = - p.z;\n  a = mod (atan (p.x, p.y) + 0.5 * w, w) - 0.5 * w;\n  p.yx = vec2 (cos (a), sin (a)) * length (p.xy);\n  p.x -= 2. * p.x * step (0., p.x);\n  return p;\n}\n\nfloat DukDf (vec3 p)\n{\n  vec3 q;\n  vec2 r, cs;\n  float dMin, d, szFac, h, s;\n  szFac = 1.1;\n  dMin = dstFar / szFac;\n  p /= szFac;\n  q = p;\n  r = vec2 (0.04, 0.06 + 0.01 * clamp (q.z, -0.4, 0.4));\n  h = 0.1;\n  s = (length (q.xz / r) - 1.) * min (r.x, r.y);\n  d = min (max (s, abs (q.y) - h), length (vec2 (s, q.y)) - h);\n  if (d < dMin) { dMin = d;  idObj = idBdy;  qHit = q; }\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.1, 0.06, 0.12);\n  cs = vec2 (cos (0.3), sin (0.3));\n  q.yz = Rot2Cs (q.yz, cs);\n  cs.y = - cs.y;\n  q.xy = Rot2Cs (q.xy, cs);\n  q.xz = Rot2Cs (q.xz, cs);\n  q = q.yxz;\n  r = vec2 (0.06, 0.1 + 0.016 * clamp (q.z, -0.4, 0.4));\n  h = 0.014;\n  s = (length (q.xz / r) - 1.) * min (r.x, r.y);\n  d = min (max (s, abs (q.y) - h), length (vec2 (s, q.y)) - h);\n  d = SmoothMin (d, dMin, 0.01);\n  if (d < dMin) { dMin = d;  idObj = idWng;  qHit = q; }\n  q = p;\n  q.yz -= vec2 (0.15, -0.08);\n  d = PrEllipsDf (q, vec3 (0.08, 0.07, 0.1));\n  d = SmoothMin (d, dMin, 0.02);\n  if (d < dMin) { dMin = d;  idObj = idHead;  qHit = q; }\n  q = p;\n  q.yz -= vec2 (0.14, -0.19);\n  r = vec2 (0.03, 0.008);\n  h = 0.02;\n  d = max (PrEllCylDf (q, r, h), - PrEllCylDf (q - vec3 (0., 0., h),\n     r - 0.004, 2. * h));\n  if (d < dMin) { dMin = d;  idObj = idBk;  qHit = q; }\n  return 0.9 * dMin * szFac;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 pIco, q;\n  float dMin, d;\n  pIco = IcosSym (p);\n  q = pIco + vec3 (0.3, -0.55, 2.45);\n  q.xy = Rot2D (q.xy, dRot);\n  dMin = DukDf (- q.xzy);\n  d = - SmoothMin (0.05 - abs (pIco.z + 2.3), 0.85 - pIco.y, 0.02);\n  if (d < dMin) { dMin = d;  idObj = idPol;  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = ObjDf (ro + rd * dHit);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec3 e = vec3 (0.0001, -0.0001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = 0; j < 30; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += 0.03;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 ObjCol ()\n{\n  vec3 col, cBdy;\n  float s;\n  cBdy = vec3 (0.5, 1., 1.);\n  if (idObj == idBdy) {\n    col = cBdy * (1. - smoothstep (0.02, 0.06, qHit.y) *\n       smoothstep (0., 0.14, qHit.z) * 0.1 * SmoothBump (0.3, 0.5, 0.05,\n       mod (50. * qHit.x, 1.)));\n  } else if (idObj == idWng) {\n    col = cBdy * (1. - step (0.004, qHit.y) *\n       smoothstep (0., 0.04, qHit.z) * 0.2 * SmoothBump (0.3, 0.5, 0.05,\n       mod (100. * qHit.x, 1.)));\n  } else if (idObj == idHead) {\n    s = length (qHit.yz - vec2 (0.02, -0.05));\n    if (s > 0.02) col = cBdy;\n    else col = (abs (s - 0.01) < 0.003) ? vec3 (1., 1., 1.) : vec3 (0.3, 0.3, 1.);\n  } else if (idObj == idBk) col = vec3 (1., 0.5, 0.);\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 vn, col;\n  float dstObj, vDotL, sh;\n  dRot = 0.5 * tCur;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += rd * dstObj;\n    vn = ObjNf (ro);\n    if (idObj != idPol) col = ObjCol ();\n    else col = (dot (ro, vn) < 0.) ? vec3 (0.7, 0.2, 0.2) : vec3 (0.9, 0.9, 1.);\n    vDotL = dot (ltDir, vn);\n    sh = ObjSShadow (ro, ltDir);\n    col = col * (0.1 + 0.1 * max (- vDotL, 0.) + 0.8 * sh * max (vDotL, 0.)) +\n       0.3 * sh * pow (max (dot (normalize (ltDir - rd), vn), 0.), 256.);\n  } else col = vec3 (0., 0., 0.2);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float az, el;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  if (mPtr.z > 0.) {\n    az = 3. * pi * mPtr.x;\n    el = -0.1 * pi + pi * mPtr.y;\n  } else {\n    az = -0.03 * pi * tCur;\n    el = 0.1 * pi * sin (0.05 * pi * tCur);\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  rd = vuMat * normalize (vec3 (uv, 3.));\n  ro = vuMat * vec3 (0., 0., -10.);\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n  dstFar = 20.;\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nfloat PrEllCylDf (vec3 p, vec2 r, float h)\n{\n  return max ((length (p.xy / r) - 1.) * min (r.x, r.y), abs (p.z) - h);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MslBDB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MslfD7", "name": "25/100", "author": "yahe", "description": ".", "tags": ["color"], "likes": 0, "viewed": 333, "date": "1496561470", "time_retrieved": "2024-06-20T18:56:52.178916", "image_code": "vec2 rotate( vec2 inVec, float angle )\n{\n \tmat4 rotMatrix = mat4\n    (\n    \tcos( angle ),\t-sin( angle ),\t0,\t0,\n        sin( angle ), \tcos( angle ),\t0,\t0,\n        0,\t\t\t\t0,\t\t\t\t1,\t0,\n        0,\t\t\t\t0,\t\t\t\t0,\t1    );\n    \n    return ( vec4( inVec, 0.0, 1.0 ) * rotMatrix ).xy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= .5;\n    uv.x += sin(iTime/4.)/2.;\n    uv.y += sin(iTime*2.)/4.;\n    \n    float offsetVal = iTime;\n    \n    vec2 uvR = uv;\n    uvR.y /= abs(uvR.x);\n    uvR = rotate( uvR, offsetVal );\n    \n    vec2 uvG = uv;\n    uvG.x /= abs(uvG.y);\n    uvG = rotate( uvG, offsetVal );\n    \n    vec2 uvB = uv;\n    uvB.xy -= sin( offsetVal );\n    \n    fragColor = vec4( uvR.y * 0.5 + 0.5, uvG.y * 0.5 + 0.5, uvB.y * 0.5 + 0.5, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MslfD7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "Mslfzj", "name": "Sketch_TriLattice7", "author": "cexlearning", "description": "TriLattice7copy from https://github.com/keijiro/ShaderSketches", "tags": ["sketch"], "likes": 7, "viewed": 120, "date": "1497060487", "time_retrieved": "2024-06-20T18:56:52.178916", "image_code": "float rand(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 uv2tri(vec2 uv)\n{\n    float sx = uv.x - uv.y / 2.0; // skewed x\n    float offs = step(fract(1.0 - uv.y), fract(sx));\n    return vec2(floor(sx) * 2.0 + offs, floor(uv.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    float res = iResolution.y / (5.0 + sin(iTime * 0.5));\n\n    vec2 uv = (fragCoord.xy - iResolution.xy / 2.0) / res;\n    uv += vec2(1.0, 0.5) * iTime;\n\n    vec3 p = vec3(dot(uv, vec2(1.0, 0.5)), dot(uv, vec2(-1.0, 0.5)), uv.y);\n    vec3 p1 = fract(+p);\n    vec3 p2 = fract(-p);\n\n    float d1 = min(min(p1.x, p1.y), p1.z);\n    float d2 = min(min(p2.x, p2.y), p2.z);\n    float d = min(d1, d2);\n    float c1 = (d - 0.04) * res;\n\n    float r = rand(uv2tri(uv)) * 6.3;\n    d = dot(uv, vec2(cos(r), sin(r))) + iTime * 0.25;\n    float c2 = (abs(0.5 - fract(d * 4.0)) - 0.18) * res / 4.0;\n\n    float c = min(c1, c2);\n    fragColor = vec4(c, c, c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mslfzj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MssBRl", "name": "CUBE", "author": "bqq", "description": "THE FUN CANNOT BE HALTED", "tags": ["cube"], "likes": 1, "viewed": 96, "date": "1497621699", "time_retrieved": "2024-06-20T18:56:52.178916", "image_code": "\nbool rtCube(mat4 trans, vec3 o, vec3 d, out float t, out vec3 n)\n{\n    mat4 inv = inverse(trans);\n    vec3 op = (inv * vec4(o, 1.0)).xyz;\n    vec3 od = (inv * vec4(d, 0.0)).xyz;\n    vec3 t0 = (vec3(1.0) - op) / od;\n    vec3 t1 = (vec3(-1.0) - op) / od;\n    \n    vec3 tmin = min(t0, t1);\n    vec3 tmax = max(t0, t1);\n    \n    float fmin = max(tmin.x, max(tmin.y, tmin.z));\n    float fmax = min(tmax.x, min(tmax.y, tmax.z));\n    \n    if (fmin == t0.x)      n = vec3(+1.0, 0.0, 0.0);\n    else if (fmin == t1.x) n = vec3(-1.0, 0.0, 0.0);\n    else if (fmin == t0.y) n = vec3(0.0, +1.0, 0.0);\n    else if (fmin == t1.y) n = vec3(0.0, -1.0, 0.0);\n    else if (fmin == t0.z) n = vec3(0.0, 0.0, +1.0);\n    else if (fmin == t1.z) n = vec3(0.0, 0.0, -1.0);\n    \n    n = (trans * vec4(n, 0.0)).xyz;\n        \n    t = fmin;\n    return fmax >= fmin;\n}\n\nbool rtFloor(vec3 o, vec3 d, out float t, out vec3 n)\n{\n    if (d.y < 0.0)\n    {\n    \tn = vec3(0.0, 1.0, 0.0);\n        t = -o.y / d.y;\n        return true;\n    }\n    else\n\t\treturn false;\n}\n\nmat4 mRotateY(float angle, float sc, vec3 t)\n{\n    float c = cos(angle) * sc;\n    float s = sin(angle) * sc;\n    \n    return mat4(\n        c,  0,  s,   0,\n        0,  sc, 0,   0,\n        -s, 0,  c,   0,\n        t.x,t.y,t.z, 1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x / iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.yy;\n    vec3 ro = vec3(0.0, 4.0, -12.0);\n\tvec3 rd = normalize(vec3(uv - vec2(0.5 * aspect, 0.5), 1.0));\n    \n    vec3 light = normalize(vec3(1.0, 1.5, 1.0));\n    \n    mat4 m = mRotateY(iTime, 1.5, vec3(0.0, 1.5, 0.0));\n    float rt;\n    vec3 rn;\n    if (rtCube(m, ro, rd, rt, rn)) {\n        float col = max(dot(rn, light) * 0.5 + 0.5, 0.0);\n        fragColor = vec4(col, col, col, 1.0);\n    } else if (rtFloor(ro, rd, rt, rn)) {\n        vec3 p = ro + rd * rt;\n        float shadow = 1.0;\n        float st;\n        vec3 sn;\n        if (rtCube(m, p, light, st, sn)) {\n            shadow = 0.0;\n        }\n        \n        float col = mix(0.3, 0.8, shadow);\n        \n\t\tfragColor = vec4(col, 0.0, 0.0, 1.0);\n    } else {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MssBRl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MssfRf", "name": "Voxel 01", "author": "darkace65", "description": "Experimenting with voxel rendering", "tags": ["voxel"], "likes": 3, "viewed": 152, "date": "1497368890", "time_retrieved": "2024-06-20T18:56:52.178916", "image_code": "#define EPSILON 0.0001\n\nconst vec3 VOXEL_SIZE = vec3(0.2);\nconst int MAX_MARCHING_STEPS = 200;\nconst float MAX_DEPTH = 20.0;\n\nmat4 viewMatrix(vec3 eye, vec3 focus, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(focus - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvec3 viewDir(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sceneSDF(vec3 p) {\n    return sdSphere(p, 0.5 * sin(iTime / 2.0) + 0.6);\n}\n\nbool voxeltrace(vec3 camera, vec3 ray, out vec3 hit, out vec3 normal) {\n    vec3 currentVoxel = floor(camera / VOXEL_SIZE);\n    vec3 closestVoxel = currentVoxel + max(sign(ray), 0.0);\n    \n    vec3 next = (closestVoxel * VOXEL_SIZE - camera) / ray;\n    vec3 step = sign(ray);\n    vec3 delta = VOXEL_SIZE / abs(ray);\n    \n    hit = currentVoxel;\n    float depth = 0.0;\n    \n    for(int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(currentVoxel * VOXEL_SIZE);\n        if(dist < EPSILON) {\n            hit = (camera + ray * depth) * (1.0 - abs(normal));\n\t\t\treturn true;\n        }\n        if(depth >= MAX_DEPTH) {\n\t\t\treturn false;\n        }\n        \n        if(next.x < next.y && next.x < next.z) {\n            currentVoxel.x += step.x;\n            depth = next.x;\n            next.x += delta.x;\n            normal = vec3(-step.x, 0.0, 0.0);\n        }\n        else if(next.y < next.x && next.y < next.z) {\n            currentVoxel.y += step.y;\n            depth = next.y;\n            next.y += delta.y;\n            normal = vec3(0.0, -step.y, 0.0);\n        }\n        else if(next.z < next.x && next.z < next.y) {\n            currentVoxel.z += step.z;\n            depth = next.z;\n            next.z += delta.z;\n            normal = vec3(0.0, 0.0, -step.z);\n        }\n    }\n    return false;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float y = 4.0;\n    float c = iTime / 8.0;\n    if(iMouse.z > 0.0) {\n        c = -iMouse.x / iResolution.x * radians(360.0);\n        y = -iMouse.y / iResolution.y * 20.0 + 10.0;\n    }\n    vec3 camera = vec3(-9.0 * cos(c), y, 9.0 * sin(c));\n    vec3 focus = vec3(0.0) + VOXEL_SIZE / 2.0;\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    mat4 viewToWorld = viewMatrix(camera, focus, up);\n    \n    vec3 viewRay = viewDir(45.0, iResolution.xy, fragCoord);\n    vec3 cameraRay = normalize((viewToWorld * vec4(viewRay, 0.0)).xyz);\n    \n    vec3 hitPoint;\n    vec3 normal;\n    bool hit = voxeltrace(camera, cameraRay, hitPoint, normal);\n    \n    vec3 color = vec3(0.0);\n    if(hit) {\n        vec3 block = mod(hitPoint, VOXEL_SIZE) / VOXEL_SIZE;\n        vec3 l = max(abs(normal), smoothstep(0.0, 0.1, block));\n        vec3 u = max(abs(normal), smoothstep(0.0, 0.1, 1.0 - block));\n        float edge = l.x * l.y * l.z *\n                     u.x * u.y * u.z;\n\n        color = mix(vec3(0.4), vec3(0.95), edge);\n    }\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MssfRf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MssfRX", "name": "Infinite Rose", "author": "Sheado", "description": "A random distance field infinite rose. \nClick to seed randomizer.", "tags": ["noise", "distancefield", "random", "rose"], "likes": 3, "viewed": 108, "date": "1497337761", "time_retrieved": "2024-06-20T18:56:52.178916", "image_code": "float random(vec2 uv);\nfloat noise (in vec2 st);\nvoid noise( out vec4 fragColor, in vec2 fragCoord );\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    noise(fragColor, fragCoord);\n}\n\nvoid noise( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= .5;\n    uv *= 10.;\n    float n = noise(uv);\n    n = length(uv)-n+(fract(iTime));\n    n = fract(n);\n    \n    fragColor = vec4(vec3(n,0.,0.),1.);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u;// = f*f*(3.0-2.0*f);\n     u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners porcentages\n    return mix(a, b, u.x) + \n            (c - a)* u.y * (1.0 - u.x) + \n            (d - b) * u.x * u.y;\n}\n\nfloat random(vec2 uv)\n{\n    float x = iMouse.x;\n    float y = iMouse.y;\n    if( x == 0. )\n        x = 12.32453454;\n    if( y == 0. )\n        y = 4.98743657943;\n    return fract(sin(dot(uv,vec2(x,y))) * iResolution.x*iResolution.y);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MssfRX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MssfW2", "name": "cone-traced lighting", "author": "public_int_i", "description": "cone-traced lighting and opaque materials", "tags": ["ray", "lighting", "marching", "cone", "distance", "function", "traced", "material", "scene", "opaque"], "likes": 2, "viewed": 501, "date": "1498388481", "time_retrieved": "2024-06-20T18:56:52.185661", "image_code": "//Ethan Alexander Shulman 2017\n\n\nstruct mat {\n    vec3 diffuse, specular;\n    float metallic, roughness;\n};\n    \nfloat hash(vec2 p) {\n    return fract(dot(p+vec2(.36834,.723), normalize(fract(p.yx*73.91374)+1e-4))*7.38734);\n}\nfloat voronoi_dither(vec2 u) {\n    #define l(i) length(fract(u*.7+fract(i*vec2(1,8))+cos(u.yx*.2333+i*8.))-.5)\n\treturn min(l(.1),l(.6))*2.66-1.;\n}\n\n//scene distance function\nfloat df(vec3 p) {\n    return min(p.y, \n               min(length(p-vec3(0.,2.,0.))-1.,\n                  length(p.xyz-vec3(sin(iTime*.43),.5,cos(iTime*.4))*3.)-1.));\n}\n//scene distance function used for normal calculation(put normal mapping/displacements here)\nfloat dfNormal(vec3 p) {\n    return min(p.y+texture(iChannel0, p.xz).x*.04,//floor bump displacement\n               min(length(p-vec3(0.,2.,0.))-1.,\n                  length(p.xyz-vec3(sin(iTime*.43),.5,cos(iTime*.4))*3.)-1.));\n}\n//returns normalized gradient at position p\nvec3 normal(vec3 p) {\n     const vec2 NE = vec2(1e-3, 0.);\n     return normalize(dfNormal(p)-vec3(dfNormal(p-NE.xyy), \n                      \t\t\tdfNormal(p-NE.yxy), \n                      \t\t\tdfNormal(p-NE.yyx)));\n}\n\n\n#define join(d,c) s.xyz = mix(s.xyz,c,clamp((s.w-d)/s.w,0.,1.)); if (d < s.w) s.w = d;\n\n//distance must be >= 0\n//scene emissive(xyz) & distance(w) function, w parameter in 'p' is the mipmap to use level\nvec4 scene(vec4 p) {\n    //floor\n    vec4 s = vec4(0., 0., 0., max(p.y,0.));\n    \n    //sphere\n    float d = max(0., length(p.xyz-vec3(0,2,0))-1.);\n    vec3 sl = vec3(max(0., sin(iTime)));//flashing sphere emissive\n    join(d,sl);\n    \n    d = max(0., length(p.xyz-vec3(sin(iTime*.43),.5,cos(iTime*.4))*3.)-1.);\n    sl = vec3(max(0., sin(iTime*1.23+3.1)));\n    join(d,sl);\n    \n    return s;\n}\n                  \n//scene material at position p\nmat material(vec3 p) {\n    if (p.y < 1e-1) {\n        //floor\n        return mat(vec3(.4), vec3(.9), 0., .1);\n    }\n\n    //sphere\n    return mat(vec3(.9), vec3(.9), 0., .5);\n}\n\n//background function, returns color from direction d.xyz and mipmap/blur level d.w\nvec3 background(vec4 d) {\n    return textureLod(iChannel1, vec2(atan(d.x,d.z)/6.28+0.5, d.y*.5+.5), d.w).xyz*(sin(iTime*.29)*.5+.5);\n}\n\n\n//ray-trace(march) scene, returns distance to hit or -1 if nothing hit\nfloat trace(vec3 rp, vec3 rd, float epsilon) {\n    float s = 0.;\n    for (int i = 0; i < 64; i++) {        \n        float dst = df(rp+rd*s);\n        if (dst < epsilon) return s;\n        s += dst;\n    }\n    return -1.;\n}\n\n\n//blurry trace scene, returns color\nvec3 blurTrace(vec3 pos, vec3 dir, float blur) {\n    vec4 rp = vec4(pos,1.),\n         rd = vec4(dir,blur);\n    float istep = .1+hash(dir.xy*512.+dir.zz*2048.)*.1,\n        bm = abs(dot(dir,normal(pos)));\n    \n    vec4 c = vec4(0.);\n    float d = 1e-4;\n    for (int i = 1; i < 16; i++) {\n        if (c.w >= 1.) break;\n        \n        vec4 s = scene(rp+rd*d);\n        s.w = max(s.w, blur);\n        float ba = bm*d*blur;\n        c += vec4(s.xyz,1.)*(max(0., 1.-s.w/ba)/ba);\n        d += mix(s.w, float(i)*istep, min(1.,blur));\n    }\n\t\n    \n    return mix(background(vec4(dir,blur*10.)),c.xyz/max(1e-4,c.w),min(c.w,1.));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //ray-march screen ray\n    float epsilon = 2e-2+voronoi_dither(fragCoord+128.)*1e-2;//dither epsilon\n    vec3 rp = vec3(cos(iTime*.12),sin(iTime*.143)+2.,-5.),\n         rd = vec3(normalize(vec3((fragCoord*2.-iResolution.xy)/iResolution.x,.5)));\n    \n    float s = trace(rp,rd,epsilon);\n    \n    vec3 c;\n    if (s < 0.) {\n        //nothing hit, background\n        c = background(vec4(rd,0.));\n    } else {\n        //shade object\n        vec3 hp = rp+rd*s,\n            hn = normal(hp),\n            ref = reflect(rd, hn);\n        mat m = material(hp);\n\n        c = scene(vec4(hp,0.)).xyz+ //emissive\n                         m.diffuse*blurTrace(hp,hn,1.)*(.5-m.metallic*.5)+ //diffuse\n                         m.specular*blurTrace(hp,ref,m.roughness)*(1.-max(0.,dot(-rd,ref))*(1.-m.metallic))*(.5+m.metallic*.5); //specular\n    }\n\n\tfragColor = vec4(floor(c*32.99+voronoi_dither(fragCoord))/32.,1.);//dither\n}", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MssfW2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsXBRB", "name": "022 simple Derivative Arithmetic", "author": "ollj", "description": "mouse does stuff.\nis just like \nhttps://www.shadertoy.com/view/4dVGzw (paniq)\nhttps://www.shadertoy.com/view/XlV3Dy (ollj)\nwith a simpler BASIC set at line 185...", "tags": ["numbers", "derivative", "dual", "paniq", "arithmetic", "continuous", "automatic", "differential", "derivate", "goursat", "continuity", "superprim"], "likes": 12, "viewed": 519, "date": "1496698256", "time_retrieved": "2024-06-20T18:56:54.360897", "image_code": "//simpler set than its parent: https://www.shadertoy.com/view/XlV3Dy\n\n// arithmetic set for automatic differentiation, \n// derivative arithmetic [DA] for\n// https://en.wikipedia.org/wiki/Smoothness\n// of shapes that (otherwise) lack C1-continuity.\n// based on    : https://www.shadertoy.com/view/4dVGzw\n// inspired by : https://www.shadertoy.com/view/Mdl3Ws \n//\n//explained at http://blog.demofox.org/2014/12/30/dual-numbers-automatic-differentiation/\n//wiki         https://en.m.wikipedia.org/wiki/Automatic_differentiation\n//summary:     https://www.reddit.com/r/math/comments/68st6p/the_wikipedia_article_on_automatic/\n\n#define Goursat\n//disabled in this one\n\n/*\nmouse does stuff.\ncleaned and starting to undertand how to use:\nsubstraction of distances is in line 235 ish\n, mixing 2 shapes by sin(time)*.5+.5\n*/\n\n#define IterRm 64\n//max raymarch iterations|steps\n//using [DA], it still looks decent with much less iterations. try <6\n//this is where [DA]-raymarching can have higher performance \n//than non-DA-raymarching\n\n#define IterSh 24\n//softshadow iterations\n\n#define ReciprocalLipschitz .99\n//if(lipschitzConstant>1., distance is overestimated.\n//... lazy fix for that is scaling stepDistance*=ReciprocalLipschitz\n//I noticed better quality with a smaller stepfactor AND epsilon=0.\n//meaning, a surface will NEVER really be reached.\n//maybe todo: eps=log(eps*b)*a\n\n//Using f'(x)= f(d)/dx notation for derivates:\n//https://en.wikipedia.org/wiki/Derivative#Notation\n\n//this defines common operations but on a (pseudo) dual number (i,j), defined as:\n//[j] stays \"underived\"\n//[i] calculates the gradient as byproduct\n//[i] becomes Operation(i,FirstDerivateOf(Operation(i,j))\n//[i] is always precise and this way usually calculates faster than using central differences,\n//mostly because a lot of operations have a lot of values cancel each other out, allowing \"shortcuts\".\n//especially canceling out a lot of domainVectors at once, which is nice for vectorHardware.\n//\n//\"pseudo\" dual because [i] has 3 dimensions, and [j] has 1 dimension that modifies on all dimensions of [i], \n//because graphic cards are good with domain operators on vectors.\n//we define your dual number (where one part calculates with derivative of the other part and itself)\n//as type vec4(vec3,float)\n//and the 3 dimensions|domains are resolved with [struct DAVec3{}] and [da_domain()]:\nstruct DAVec3{vec4 x;vec4 y;vec4 z;};\nDAVec3 da_domain(vec3 p){return DAVec3(\n vec4(1.,0.,0.,p.x),\n vec4(0.,1.,0.,p.y),\n vec4(0.,0.,1.,p.z));}\n//this lets you derive over 3 dimensions at once OR seperately, using very self-similar dual-function variants:\n#define dacon(a) vec4(0.,0.,0.,a)\n#define i1 in float\n#define i4 in vec4\n#define i3 in vec3\nvec4 da_const(i1 a){return dacon(a);}\n//as proof of concept, remember the derivates of sin|cos:\n//sin => cos => -sin => -cos => sin =>...\nvec4 da_sin(i4 a){return vec4( a.xyz*cos(a.w),sin(a.w));}\nvec4 da_cos(i4 a){return vec4(-a.xyz*sin(a.w),cos(a.w));}\n//eulers number, exponential functions and natural log:\nvec4 da_exp(i4 a){float w=exp(a.w);return vec4(a.xyz*w,w);}//exp(a)==pow(e,a)\nvec4 da_log(i4 a){return vec4(a.xyz/a.w,log(a.w));}\n\n#define siq safeinv(q),q);}\nfloat safeinv(i1 a){return (a==0.)?a:1./a;}//reciprocal,1/x but 1./0.=1.; sometimes makes more sense than divBy0!\nvec4 da_abs (i4 a){return vec4(a.xyz*sign(a.w),abs(a.w));}\nvec4 da_pow2(i4 a){return vec4(2.*a.w*a.xyz, a.w*a.w);}\nvec4 da_sqrt(i4 a){float q=sqrt(a.w);\n return vec4(.5*a.xyz*siq\n\n//derivatives of functions with 2 variables are trickier:\n//because only .w determines breanching of min()|max() (in the nature of dual numbers, only one matters here)\n//optionally, a float parameter can be given as vec4(0,0,0,f):\nvec4 da_min(i4 a,i4 b){return(a.w<=b.w)?a:b;}\nvec4 da_min(i4 a,i1 b){return(a.w<=b  )?a:da_const(b);}\nvec4 da_min(i1 a,i4 b){return(a  < b.w)?da_const(a):b;}\nvec4 da_max(i4 a,i4 b){return(a.w>=b.w)?a:b;}\nvec4 da_max(i4 a,i1 b){return(a.w>=b  )?a:da_const(b);}\nvec4 da_max(i1 a,i4 b){return(a  > b.w)?da_const(a):b;}\n#define da_max3(a,b,c) da_max(da_max(a,b),c)\n//I assume the more general logic here is that all these functions with 2 parameters do:\n/*vec4 r;\n  r.w  = operationOn(a.w,b.w);\n  r.xyz= operationOn(a.xyz , vec3(firstDerivateOf(r.w))); //firstDerivateOf(r.w)==[tricky part]==(3d graphs tangents)\n  return r;*/\n//f(a,b)=mod(a,b) => f'(a,b)=1. , (still disontinuous, not defined for whole multiples of b).\nvec4 da_mod(i4 a,i4 b){return vec4(mod(a.xyz,1.),mod(a.w,b.w));}\nvec4 da_mod(i4 a,i1 b){return vec4(mod(a.xyz,1.),mod(a.w,b  ));}\nvec4 da_mod(i1 a,i4 b){return vec4(0,0,0        ,mod(a  ,b.w));}//here \"a.xyz\"==vec3(0)\n//and usually a lot cancels out in substraction/division...\nvec4 da_sub(i4 a,i4 b){return a-b;}\nvec4 da_sub(i4 a,i1 b){return vec4( a.xyz,a.w-b  );}\nvec4 da_sub(i1 a,i4 b){return vec4(-b.xyz,a  -b.w);}\nvec4 da_add(i4 a,i4 b){return a+b;}\nvec4 da_add(i4 a,i1 b){return da_sub(a,-b);}//addition as invrse substraction\nvec4 da_add(i1 a,i4 b){return da_sub(a,-b);}\n             \nvec4 da_mul(i4 a,i4 b){return vec4(a.xyz*b.w+a.w*b.xyz, a.w*b.w);}\nvec4 da_mul(i4 a,i1 b){return a*b;}\nvec4 da_mul(i1 a,i4 b){return a*b;}\nvec4 da_div(i4 a,i4 b){return vec4((a.xyz*b.w-a.w*b.xyz)/(b.w*b.w), a.w/b.w);}\nvec4 da_div(i4 a,i1 b){return a/b;}\nvec4 da_div(i1 a,i4 b){return vec4((-a*b.xyz)/(b.w*b.w), a/b.w);} \n             \n//some operations cancel out a bit more, to (nearly) tautological|identical identities:\n//<- wooha, a recursive meta-tautology!\n//vec4 da_fract(i4 a){return a;}//derivative of fract(a)=a => tautological.\nvec4 da_floor(i4 a){return dacon(a);}\nvec4 da_floor(i1 a){return dacon(a);}\n//#define mod(a,b) (a-b*floor(a/b))\n//da_mod.xyz==a.xyz-b.xyz*0==a.xyz\n\n//f(a,b)=dot(g(a),h(b)) => f'(x)              =dot(g'(a)',h(b))+dot(g(a),h(b))\n//                      => d/dx(dot(g(a),h(b))=dot(ga/gx ,h   )+dot(g   ,ha/hx); //similar to \"product rule for scalars\"\n//g(a)=c\n//h(b)=d\n//f(a,b)=dot(c,d) => f'(x)=dot(c',d)+dot(c,d');\n// c and d are type type vec3;\n//f'(x)=dot(0,d)+dot(c,0) == 0+0; ???\n            \n\n//todo: derivative of dot() appears tricky: this #define should do:\n//#define dotDer(a,b) min(f(abs(a)),abs(b))*sign(a)*sign(b)\n//vec4 da_dot(i4 a,i4 b){return vec4(a.xyz*dotDer(a,b),dot(a.w,b.w));}           \n//vec4 da_dot(i4 a,i1 b){return vec4(a.xyz*dotDer(a,b),dot(a.w,b  ));}  \n//vec4 da_dot(i1 a,i4 b){return da_dot(b,a);}//is commutative\n             \n//and it gets trickier with functions that take 3 parameters:\nvec4 da_length(i4 x,i4 y){float q=length(vec2(x.w,y.w));\n return vec4((x.xyz*x.w+y.xyz*y.w)*siq\nvec4 da_length(i4 x,i4 y,i4 z){float q=length(vec3(x.w,y.w,z.w));\n return vec4((x.xyz*x.w+y.xyz*y.w+z.xyz*z.w)*siq\n//the utility of a length() function is clear.\n\n//the utility of da_*().xyz is trickier, just search below to see  what it is ued for:\n\n\n//using the above, we define distance functions that automatically calculate their derivatives\n//this makes surfaces that are C1-discontinuous, like staircases, \n//at least have their (continuous) first rerivate calculated, which is useful for raymarching (?)\nvec4 sdSphere(DAVec3 p){\n p.x*=.8;p.x-=.5*sin(1.61*iTime);\n p.y*=.8;\n p.z*=.8;p.z-=.5*cos(1.61*iTime);\n vec4 q=da_length(p.x,p.y,p.z);\n q=da_sub(q,1.);\n return q;}\n\nvec4 sdRay(DAVec3 p){//infinite line segment\n float ass=p.x.w;\n p.x.w=mix(0.,p.x.w,step(p.x.w,0.));\n vec4 q=da_length(p.x,p.y,p.z);\n q=da_sub(q,1.);\n return q;}\n\n/*\nfloat fBox(vec3 p,vec3 b){\n\n vec3 q;\n vec3 q=min(d,0.);\n\n vec3 a=length(max(d,0.));\n vec3 c=max(max(q.x,q.y),q.z);\n return a+c;\n}\n*/\n  \n/*\nfloat fBoxCheap(vec3 p,vec3 b){\n vec3 q=abs(p);q=q-p;\n return max(max(q.x,q.y),q.z);}//hg_saf\n*/\nvec4 sdBoxCheap(DAVec3 p){\n //vec2 r=vec2(.0,.0);\n vec3 s=vec3(1.5,.5,1.5);\n vec4 x,y,z,d,e,f,q,a,b,c;\n x=vec4(0);y=vec4(0);z=vec4(0);d=vec4(0);\n e=vec4(0);f=vec4(0);q=vec4(0);\n a=vec4(0);b=vec4(0);c=vec4(0);\n x=da_abs(p.x);x=da_sub(x,s.x);\n y=da_abs(p.y);y=da_sub(y,s.y);\n z=da_abs(p.z);z=da_sub(z,s.z); //thichnessess\n c=da_max3(x,y,z);\n return c;}\n/*\nfloat fBox(vec3 p,vec3 s){\nvec3 d=abs(p)-s;\nfloat a=length(max(d,0.));\nvec3 q=min(d,0.);\nfloat b=max(max(q.x,q.y),q.z);\nreturn a+b;}//hg_sdf\n*/\nvec4 sdBox(DAVec3 p){\n //vec2 r=vec2(.0,.0);\n vec3 s=vec3(1.5,.5,1.5);\n vec4 x,y,z,d,e,f,q,a,b,c;\n x=vec4(0);y=vec4(0);z=vec4(0);d=vec4(0);\n e=vec4(0);f=vec4(0);q=vec4(0);\n a=vec4(0);b=vec4(0);c=vec4(0);\n x=da_abs(p.x);x=da_sub(x,s.x);\n y=da_abs(p.y);y=da_sub(y,s.y);\n z=da_abs(p.z);z=da_sub(z,s.z);\n //thichnessess\n vec4 qx=da_min(x,0.);\n vec4 qy=da_min(y,0.);\n vec4 qz=da_min(z,0.);\n b=da_max3(qx,qy,qz);\n x=da_max(x,0.);\n y=da_max(y,0.);\n z=da_max(z,0.);\n a=da_length(x,y,z);\n c=da_add(a,b);\n return c;}\n             \n             \n//a more readable version of the above, like, seriously WTF MAN!\n//how about one operation per line man, keep it BASIC!\nvec4 sdSuperprim(DAVec3 p, i4 s,vec2 r) {\n //vec2 r=vec2(.2,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n vec4 dx,dy,dz,d,e,f,q,a,b,c;\n dx=vec4(0);dy=vec4(0);dz=vec4(0);d=vec4(0);\n e=vec4(0);f=vec4(0);q=vec4(0);\n a=vec4(0);b=vec4(0);c=vec4(0);\n dx=da_abs(p.x);\n dx=da_sub(dx,s.x);\n dy=da_abs(p.y);\n dy=da_sub(dy,s.y);\n dz=da_abs(p.z);\n dz=da_sub(dz,s.z);\n \n d=da_add(dx,r.x);\n d=da_max(d,0.);\n e=da_add(dy,r.x);\n e=da_max(e,0.);\n q=da_length(d,e);\n f=da_max(dx,dy);\n f=da_min(-r.x,f);\n \n q=da_add(q,f);\n q=da_add(q,s.w);\n q=da_abs(q);\n q=da_sub(q,s.w);\n ///return...\n a=da_add(q ,r.y);\n a=da_max(a,0.);    \n b=da_add(dz,r.y);\n b=da_max(b,0.);\n a=da_length(a,b);\n c=da_min(-r.y,da_max(q,dz));\n c=da_add(a,c);\n return c;\n}\n\n// example parameters\n#define SHAPE_COUNT 10.0\nvoid getfactor (int i, out vec4 s,out vec2 r) {\n    //i = 8;\n    if (i == 0) { // cube\n        s = vec4(1.0);\n        r = vec2(0.0);\n    } else if (i == 1) { // corridor\n        s = vec4(vec3(1.0),0.25);\n        r = vec2(0.0);\n    } else if (i == 2) { // pipe\n        s = vec4(vec3(1.0),0.25);\n        r = vec2(1.0,0.0);\n    } else if (i == 3) { // cylinder\n        s = vec4(1.0);\n        r = vec2(1.0,0.0);\n\t} else if (i == 4) { // pill\n        s = vec4(1.0,1.0,2.0,1.0);\n        r = vec2(1.0);\n    } else if (i == 5) { // sphere\n        s = vec4(1.0);\n        r = vec2(1.0);\n    } else if (i == 6) { // pellet\n        s = vec4(1.0,1.0,0.25,1.0);\n        r = vec2(1.0,0.25);\n    } else if (i == 7) { // torus\n        s = vec4(1.0,1.0,0.25,0.25);\n        r = vec2(1.0,0.25);\n    } else if (i == 8) { // sausage mouth\n        s = vec4(2.0,0.5,0.25,0.25);\n        r = vec2(0.5,0.25);\n    } else if (i == 9) { // beveled O\n        s = vec4(0.7,1.0,1.0,0.25);\n        r = vec2(0.125);\n\t}\n}\n\n//set camera position & target\nvoid setCam(out vec3 o,out vec3 i,i1 t,i1 m){\n o=vec3(4.*sin(t),m*9.-2.,4.*cos(t));i=vec3(0);}\n\nstruct DAMValue{vec4 d;float m;};\nDAMValue min2(DAMValue a, DAMValue b){if(a.d.w>b.d.w)return b;return a;}\nDAMValue plane(DAVec3 p){return DAMValue(da_add(p.y,1.),1.);}\n//DAMValue add_plane(DAVec3 p,DAMValue m){return min2(plane(p),m);}\n\n#define ss01(a) smoothstep(0.,1.,a) \n#define imsc(a) int(mod(a,SHAPE_COUNT))\n//return distance to surface of DistanceField\nDAMValue df(DAVec3 p){vec4 r;\n#ifdef Goursat\n //r=sdGoursat(p);\n r=sdBox(p);\n //r=da_max(-sdTangle(p),sdSphere(p));\n //r=sdGoursat(p)*.7+sdSphere(p)*.3;\n //r=mix(sdGoursat(p),sdSphere(p),sin(iTime*.61)*.5+.5);\n#else\n float t=iTime,u=ss01(ss01(fract(t)));\n vec4 a,b;vec2 c,d;\n getfactor(imsc(t   ),a,c);\n getfactor(imsc(t+1.),b,d);\n DAVec3 q=DAVec3(p.z,p.y,p.x);\n if(iMouse.z>.5){\n  vec2 m=iMouse.xy/iResolution.xy;\n  r=sdSuperprim(q,vec4(vec3(1.0),mix(a.w,b.w,u)),m);\n }else\n  r=sdSuperprim(q,mix(a,b,u),mix(c,d,u));\n#endif\n return min2(plane(p),DAMValue(r,0.));}\n\n//return distance & materialID\nvec2 dm(i3 p){DAMValue d=df(da_domain(p));\n return vec2(d.d.w,d.m);}\n//return material at p with normal n\nvec4 material(i3 p,i3 n ){vec4 d=df(da_domain(vec3(p.x,0.,p.z))).d;\n return mix(vec4(n*.5+.5,.1)\n           ,vec4(d.xyz*.5 +.5,.0)*abs(mod(d.w,.1)/.1-.5)\n           ,clamp(dm(p).y,0.,1.));}\n\n//return soft shadow\nfloat shadow(i3 o,i3 i){\n const float a=32.;//shadow hardnes\n float r=1.,h =1.,t=.0005;//t=(self)intersection avoidance distance\n for(int j=0;j<IterSh;j++){\n  h=dm(o+i*t).x;\n  r=min(r,h*a/t);\n  t+=clamp(h,.02,2.);}//limit max and min stepping distances\n return clamp(r,0.,1.);}\n\n//return p, modified by light , shadow, envMap...\nvec3 light(i3 p,i3 n,i3 i,i1 d,i4 m){\n vec3 l=normalize(vec3(1.,.7,.9));//light direction\n float o=max(0.,dot(n,l)),\n c=max(0.,dot(n,normalize(l-i))),\n s;if(c>.01)s=shadow(p+.01*n,l); \n const vec3 LigCol=vec3(1.);//light color\n vec3 r=m.rgb*(LigCol+o*vec3(.8,.7,.6)*s*3.+vec3(.2,.3,.3));  \n r+=s*c*pow(o,40.);//specular\n //r+=m.w*texture(iChannel0, reflect(i,n)).rgb;//envmap\n r*=exp(-.01*d*d);//fog  \n return r;}\n\n//return distance along ray (raymarch till surface)\nfloat rm(i3 o,i3 i){\n const float m=20.;//distance.Max\n float e=.0,h=e,t=0.;//intersection.precission\n for(int j=0;j<IterRm;j++){\n  if(h<e)break;if(t>m)return -1.;\n     //wait a moment, do i not have the lipschitz for the point\n     //or at least 3 for 3 domains of the point\n     //by using [DA]?\n     //i mean, i could really insert this here, right?\n     //and substitute ReciprocalLipschitz with 1/da_length()\n  h=dm(o+i*t).x*ReciprocalLipschitz;t+=h;}return t;}\n\n//return surface normal\nvec3 getN(in vec3 p){DAMValue d=df(da_domain(p));\n return d.d.xyz;}\n//.xyz store the first derivatives on the 3 domains, \n//this is equivalent to the gradient at p\n//if (p is near a surface) the gradient is a surface normal\n//d.d.* addresses a vec4. where *.xyz==gradient\n//d.m.* addresses a material\n             \n//return camera matrix\nmat3 calcLookAtMatrix(in vec3 o,in vec3 i,in float r ){\n vec3 w=normalize(i-o);vec3 u=normalize(cross(w,vec3(sin(r),cos(r),0.)) );\n return mat3(u,normalize(cross(u,w)),w);}\n\n//return color corrected r\nvec3 ff_filmic_gamma3(vec3 r){vec3 x=max(vec3(0),r-.004);\n return (x*(x*6.2+.5))/(x*(x*6.2+1.7)+.06);}\n\nvoid mainImage( out vec4 r,in vec2 fragCoord ){\n vec2 p=(-iResolution.xy+2.*fragCoord.xy)/iResolution.y,\n m=iMouse.xy/iResolution.xy;  //mouse\n vec3 o,i;\n setCam(o,i,iTime,m.y+.2);//camMovement\n const float roll=0.,lens=2.;//camRoll,CamLensLength\n vec3 d=normalize(calcLookAtMatrix(o,i,roll)*vec3(p.xy,lens));//ray.direction\n vec3 c=vec3(0);\n float t=rm(o,d);//Distance.raymarched\n if(t>-.5){\n  vec3 p=o+t*d,n=getN(p); //position & normal\n  vec4 m=material(p,n);   //material\n  c=light(p,n,d,t,m);}    //light\n c=ff_filmic_gamma3(c*.6);//gamma\n //c=pow( clamp(col,0.0,1.0), vec3(0.4545) );\n r=vec4(c,1.);}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsXBRB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsXBWB", "name": "Daily 2017-06-18", "author": "Koltes", "description": "Daily", "tags": ["daily"], "likes": 13, "viewed": 410, "date": "1497820958", "time_retrieved": "2024-06-20T18:56:54.360897", "image_code": "float C,S;\n#define rot(a) mat2(C=cos(a),S=sin(a),-S,C)\n#define hash(x) fract(sin(x)*1e4)\n\nfloat rd(vec2 p){\n    return hash(dot(p,vec2(13.,78.)));\n                }\n\nfloat noise(vec2 p){\n    vec2 f=smoothstep(0.,1.,fract(p)),i=floor(p),oi=vec2(0.,1.);\n    return mix(\n        mix(rd(i+oi.xx),rd(i+oi.yx),f.x),\n                mix(rd(i+oi),rd(i+oi.yy),f.x),\nf.y);\n}\n\nstruct M{float d,l;};\n\n    \nvec3 ht(vec2 st, vec3 a, vec3 b, float t) {\n    vec2 ist=floor(st),fst=fract(st),wp=ist+step(.5,fst),bp=ist+vec2(.5);\n    float wl=length(st-wp),bl=length(st-bp);\n    return mix(b,a,smoothstep(t-.1,t+.1,bl/(wl+bl)));\n}\n\nM map(vec3 p) {\n    M m;\n    vec2 n=floor((p.xy+2.)/4.);\n    float rdn=rd(n)*10.;\n \tp.xy=mod(p.xy+2.,4.)-2.;\n    m.d= length(p)-1.;\n    vec3 q=p;\n    q.xy*=rot(iTime*.3+rdn);\n    q.yz*=rot(iTime*.5+rdn);\n    q.xy*=rot(iTime*.7+rdn);\n    q.yz*=rot(iTime*.2+rdn);\n    m.l=fract(q.z*1.5+iTime*rdn*.02);\n    return m;\n}\n\nvec3 norm(vec3 p) {\n    vec2 e=vec2(.001,0.);\n    return normalize(vec3(\n        map(p+e.xyy).d-map(p-e.xyy).d,\n        map(p+e.yxy).d-map(p-e.yxy).d,\n        map(p+e.yyx).d-map(p-e.yxx).d));\n                     }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy,v=uv*(1.-uv);\n    uv-=.5;\n    uv.x*=iResolution.x/iResolution.y;\n    vec3 ro=vec3(vec2(iTime+cos(iTime*2.+sin(iTime)),sin(iTime*.6)),-4.+sin(iTime)),rd=normalize(vec3(uv,1.)),mp=ro;\n    rd.xy*=rot(iTime*.4);\n    M m;\n    float f;for(f=0.;f<30.;++f){\n        m=map(mp);\n        if(abs(m.d)<.001)break;\n        mp+=rd*m.d;\n    }\n    float fr=f/30.;\n    vec3 n=norm(mp);\n    float htr=step(length(mp-ro),30.);\n    float hr=-dot(rd,n);\n    hr=mix(hr,1.,step(.6,m.l));\n    hr=mix(hr,0.,step(.8,m.l));\n    vec3 h=ht(uv*40.*rot(iTime),vec3(.9,.5,.3)*1.,vec3(.3,.5,.7)*.4,hr);\n    uv*=rot(sin(iTime*.6+sin(iTime*2.)*.2)*.2);\n    uv.x+=sin(iTime*.02)*20.;\n    uv.y+=sin(iTime*.03)*30.;\n    float ns=fract(noise(uv*.8)*5.);\n    vec3 bg=mix(vec3(.3,.5,.7)*.4,vec3(.9,.5,.3)*1.,smoothstep(0.,.01,ns)-smoothstep(.2,.21,ns));\n    vec3 c=mix(bg,h,htr);\n    c=sqrt(c)*pow(v.x*v.y*25.,.25);\n\tfragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsXBWB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsXfD7", "name": "2D Vector Graphics Library fork", "author": "cxw", "description": "Fork of https://www.shadertoy.com/view/lslXW8 by paniq, tweaked to compile on the updated shadertoy.", "tags": ["fork", "vector", "mattdamon"], "likes": 7, "viewed": 648, "date": "1496413766", "time_retrieved": "2024-06-20T18:56:57.652208", "image_code": "// BY paniq, not cxw --- cxw just tweaked it to compile on the new shadertoy.\n///////////////////////////////////////////////////\n// 2d vector graphics library\n// after Cairo API, with anti-aliasing\n// by Leonard Ritter (@paniq)\n// v0.3\n\n// I release this into the public domain.\n\n// undefine if you are running on glslsandbox.com\n// #define GLSLSANDBOX\n\n#ifdef GLSLSANDBOX\n#ifdef GL_ES\n#endif\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n#define iTime time\n#define iResolution resolution\n#define iMouse mouse\n#endif\n\n// interface\n//////////////////////////////////////////////////////////\n\n// set color source for stroke / fill / clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source(sampler2D image);\n// if enabled, blends using premultiplied alpha instead of\n// regular alpha blending.\nvoid premultiply_alpha(bool enable);\n\n// set line width in normalized units for stroke\nvoid set_line_width(float w);\n// set line width in pixels for stroke\nvoid set_line_width_px(float w);\n// set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n// add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n// add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n\n// set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n// draw straight line from starting point to P,\n// and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n// draw quadratic bezier curve from starting point\n// over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n// connect current starting point with first\n// drawing point.\nvoid close_path();\n\n// clear screen in the current source color\nvoid clear();\n// fill paths and clear the path buffer\nvoid fill();\n// fill paths and preserve them for additional ops\nvoid fill_preserve();\n// stroke paths and clear the path buffer\nvoid stroke_preserve();\n// stroke paths and preserve them for additional ops\nvoid stroke();\n// clears the path buffer\nvoid new_path();\n\n// return rgb color for given hue (0..1)\nvec3 hue(float hue);\n// return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n// rotate the context by A in radians\nvoid rotate(float a);\n// uniformly scale the context by S\nvoid scale(float s);\n// translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n// clear all transformations for the active context\nvoid identity_matrix();\n// transform the active context by the given matrix\nvoid transform(mat3 mtx);\n// set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n// return the active query position for in_fill/in_stroke\n// by default, this is the mouse position\nvec2 get_query();\n// set the query position for subsequent calls to\n// in_fill/in_stroke; clears the query path\nvoid set_query(vec2 p);\n// true if the query position is inside the current path\nbool in_fill();\n// true if the query position is inside the current stroke\nbool in_stroke();\n\n// return the transformed coordinate of the current pixel\nvec2 get_origin();\n// draw a 1D graph from coordinate p, result f(p.x),\n// and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n// draw a 2D graph from coordinate p, result f(p),\n// and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n// adds a custom distance field as path\n// this field will not be testable by queries\nvoid add_field(float c);\n\n// returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) / (2.0*get_gradient_eps())\n// returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) / (2.0*get_gradient_eps())\n// draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n// draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n// represents the current drawing context\n// you usually don't need to change anything here\nstruct Context {\n    // screen position, query position\n    vec4 position;\n    vec2 shape;\n    float scale;\n    float line_width;\n    bool premultiply;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n};\n    \n// save current source color, stroke width and starting\n// point from active context.\nContext save();\n// restore source color, stroke width and starting point\n// to a context previously returned by save()\nvoid restore(Context ctx);\n\n// draws a half-transparent debug gradient for the\n// active path\nvoid debug_gradient();\n// returns the gradient epsilon width\nfloat get_gradient_eps();\n\n// your draw calls here\n//////////////////////////////////////////////////////////\n\nfloat myf(float x) {\n    return sin(x) * cos((x + iTime * 0.2) * 20.0);\n}\n\nfloat myf2(vec2 x) {\n    float r = length(x);\n    float a = atan(x.y,x.x);\n    return r - 1.0 + 0.5 * sin(3.0*a + 2.0*r*r);\n}\n\nvoid paint() {\n    float t = iTime;\n    \n    // clear screen\n    \n    set_source_rgb(vec3(0.0,0.0,0.5));\n    clear();\n\n    // draw 1D graph\n    graph1D(myf);\n    // graphs only look good at pixel size\n    set_line_width_px(1.0);\n    set_source_rgba(vec4(vec3(1.0),0.3));\n    stroke();\n\n    // draw 2D graph\n    graph2D(myf2);\n    // graphs only look good at pixel size\n    set_line_width(0.01);\n    set_source_rgba(vec4(vec3(1.0),0.3));\n    stroke();\n\n    // fill circle\n    circle(0.0, 0.0, 0.3);\n    bool in_circle = in_fill();\n    set_source_rgb(hsl(0.0, 1.0, in_circle?0.7:0.5));\n    fill_preserve(); // don't reset shape\n    \n    // add another circle\n    circle(0.3 + 0.3*(sin(t)*0.5+0.5), 0.0, 0.2);\n    set_line_width(0.04);\n    bool in_circle_rim = in_circle || in_stroke();\n    // stroke both circles, twice\n    set_source_rgb(hsl(0.0, 1.0, 0.3));\n    set_line_width(0.04);\n    stroke_preserve();\n    set_source_rgb(hsl(0.1, 1.0, in_circle_rim?0.8:0.5));\n    set_line_width(0.02);\n    stroke();\n    \n    // shadowed stop sign stroke\n    \n    move_to(-0.2,0.0);\n    line_to(0.2,0.0);\n    \n    set_source_rgba(0.0,0.0,0.0,0.5);\n    set_line_width(0.02);\n    set_blur(0.05);\n    stroke_preserve();\n    set_blur(0.0);\n    \n    set_source_rgb(vec3(1.0));\n    set_line_width(0.02);\n    stroke();\n    \n    // transformed glowing triangle\n    \n    // to preserve stroke width, first save context...\n    Context ctx = save();\n    translate(-1.0, 0.4);\n    scale(0.5 * (sin(t)*0.5+0.5));\n    rotate(radians(t*30.0));\n    move_to(-0.7,-0.7*0.86);\n    line_to(0.7,-0.7*0.86);\n    line_to(0.0,0.7*0.86);\n    close_path();\n    // ...then restore to previous transformation\n    restore(ctx);   \n\n    set_line_width(0.1);\n    bool tri_active = in_stroke();\n    // add glow \n    set_source_rgba(vec4(hsl(tri_active?0.1:0.52, 1.0, 0.5)*0.5,0.0));\n    set_line_width(0.02);\n    set_blur(0.1);\n    premultiply_alpha(true);\n    stroke_preserve();\n    premultiply_alpha(false);\n    set_blur(0.0);\n    // and stroke   \n    set_line_width(0.02);    \n    set_source_rgb(hsl(tri_active?0.1:0.5, 1.0, 0.5));\n   \tstroke();\n    \n    // pink alphablended rectangle\n\n    rectangle(0.6,-0.3,0.6,0.8);\n    if (in_fill())\n        set_source(iChannel0);\n    else\n    \tset_source_rgba(hsl(0.9, 1.0, 0.5, 0.5));\n   \tset_blur(mix(0.0,0.1,sin(iTime)*0.5+0.5));\n    fill_preserve();\n    set_blur(0.0);\n\t\n    set_line_width(0.02);\n    set_source_rgb(hsl(0.9, 1.0, 0.5));\n    stroke();\n    \n    // quadratic bezier spline\n    \n    translate(-0.8, -0.8);\n    move_to(-0.5, mix(0.0,0.5,sin(t)*0.5+0.5));\n    curve_to(0.0, mix(0.0,0.5,sin(t*1.2+0.5)*0.5+0.5), 0.5, mix(0.0,0.5,sin(t*0.91+1.0)*0.5+0.5));\n\tcurve_to(1.0, mix(0.0,0.5,sin(t*1.4+0.5)*0.5+0.5), 0.8, mix(0.0,0.5,sin(t*0.71+1.0)*0.5+0.5));\n    set_line_width(0.04);\n    bool bezier_active = in_stroke();\n    set_source_rgb(hsl(0.9, 1.0, bezier_active?1.0:0.5));\n    stroke_preserve();\n    set_line_width(0.02);\n    set_source_rgb(hsl(0.9, 1.0, 0.1));\n    stroke();\n}\n\n// implementation\n//////////////////////////////////////////////////////////\n\nvec2 aspect;\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH;\nfloat AA;\nfloat AAINV;\n\n//////////////////////////////////////////////////////////\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n//////////////////////////////////////////////////////////\n\nvec3 hue(float hue) {\n    return clamp( \n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, \n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n//////////////////////////////////////////////////////////\n\n#define DEFAULT_SHAPE_V 1e+20\n\nContext _stack;\n\nvoid init (vec2 fragCoord) {\n    uv = fragCoord.xy / iResolution.xy;\n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n    \n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        1.0,\n        1.0,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0)\n    );\n}\n\nvec3 _color = vec3(1.0);\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n}\n\nContext save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    // preserve shape\n    vec2 shape = _stack.shape;    \n    _stack = ctx;\n    _stack.shape = shape;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 / d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = 1.0;\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;    \n    _stack.scale = length(vec2(mtx[0].x,mtx[1].y));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    vec2 u = vec2(mtx[0].x, mtx[1].x);\n    _stack.scale *= length(u);\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(float s) {\n    transform(mat3(s,0.0,0.0,0.0,s,0.0,0.0,0.0,1.0));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color = mix(_color, _stack.source.rgb, _stack.source.a);\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(_color, 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = _color;\n}\n\nvoid add_field(vec2 d) {\n    d = d / _stack.scale;\n    _stack.shape = min(_stack.shape, d);    \n}\n\nvoid add_field(float c) {\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n}\n\nvoid debug_gradient() {\n    _color = mix(_color, \n        hsl(_stack.shape.x * 6.0, \n            1.0, (_stack.shape.x>=0.0)?0.5:0.3), \n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color = _color * (1.0 - src_a) + rgba.rgb * dst_a;    \n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA, 0.0, 1.0);\n    float wb = clamp(-w / blur.x + blur.y, 0.0, 1.0);    \n\treturn wa * wb; //min(wa,wb);    \n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*_stack.scale/AA;\n}\n\nfloat get_gradient_eps() {\n    return _stack.scale/AA;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    _stack.source = c;\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) { \n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture(image, _stack.position.xy));\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    s*=0.5;\n    o += s;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    add_field(max(dmin.xz, dmin.yw) + length2(dmax));\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rectangle(vec2(ox,oy), vec2(sx,sy));\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n// stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)/dot(ba,ba), 0.0, 1.0);\n    add_field(length2(pa - ba.xyxy*h.xxyy));\n    \n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n// from https://www.shadertoy.com/view/ltXSDB\n\n// Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.0) { \n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset;\n}\n\n// Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{    \n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);      \n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis; // * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    add_field(vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw)));\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) / sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(abs(f_x) / length(df_x));\n}\n\n//////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t aspect = vec2(iResolution.x / iResolution.y, 1.0);\n\t ScreenH = min(iResolution.x,iResolution.y);\n\t AA = ScreenH*0.4;\n\t AAINV = 1.0 / AA;\n    \n    init(fragCoord);\n    \n    paint();\n    \n    blit(fragColor);\n}\n\n#ifdef GLSLSANDBOX\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n#endif\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsXfD7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsXfWM", "name": "HyperSphere 12x12x12", "author": "JCDjcd", "description": "Same as 5x5x5 but with 12 wires for each alpha,beta,gamma angle.\n", "tags": ["sphere", "4d", "hypersphere"], "likes": 15, "viewed": 299, "date": "1496354704", "time_retrieved": "2024-06-20T18:56:58.330905", "image_code": "//--------------------------------------------------------------------------\n#define TWOPI \t\t\t(2.0*3.1415926535)\n#define ROTATION(alpha) mat2(cos(alpha),-sin(alpha),sin(alpha),cos(alpha))\n#define COLORIZATION(h)\tclamp(abs(fract(h+vec4(3.0,2.0,1.0,0.0)/3.0)*6.0-3.0)-1.0,0.0,1.0)\n\n//--------------------------------------------------------------------------\n// Ray is defined by M(t1,t2) = P + t1.d1 + t2.d2\nvec4 compute(vec4 P,vec4 d1,vec4 d2,int method /* 0-left or 1-right */)\n{    \n\t// compute the intersections with the hypersphere\n    // it turns out that it is specifically a circle\n    float t1_center = -dot(P,d1);\n    float t2_center = -dot(P,d2);\n    float r2 \t\t= 1.0 + t1_center*t1_center + t2_center*t2_center - dot(P,P);\n    \n    if(r2 < 0.0)\n    {\n        return vec4(0.0,0.0,0.0,1.0);\n    }\n    else\n    {\n        float r \t= sqrt(r2);\n        int N \t\t= 200+int(400.0*r);\n        vec4 color \t= vec4(0.0,0.0,0.0,1.0);\n        for(int i=0;i<=N;i++)\n        {\n            // angle along the circle within the (z,w) plan\n            float q  = TWOPI*float(i)/float(N);\n            float t1 = t1_center+r*cos(q); // z\n            float t2 = t2_center+r*sin(q); // w\n            \n            vec4 M    = P + t1*d1 + t2*d2;\n            M \t\t  = M/sqrt(dot(M,M)); // solve roudning issue => slight renormalization to 1\n            \n            float gamma = acos(M.w);\n            float beta \t= atan(sqrt(M.x*M.x+M.y*M.y),M.z);\n            float alpha\t= atan(M.y,M.x);\n            \n            float repeat    = 12.0;\n            float threshold = 0.98;\n            int bool_alpha \t= cos(alpha*repeat) > threshold ? 1 : 0;\n            int bool_beta\t= cos( beta*repeat) > threshold ? 1 : 0;\n            int bool_gamma\t= cos(gamma*repeat) > threshold ? 1 : 0;\n            \n            //bool_alpha = 0;\n            //bool_beta = 0;\n            //bool_gamma = 0;\n            vec4 c = vec4(0.0,0.0,0.0,1.0);\n            if(0 == method)\n            {\n                int sum = bool_alpha+bool_beta+bool_gamma;\n                if(sum >= 1)\n                {\n                    c = vec4(float(bool_alpha),float(bool_beta),float(bool_gamma),1.0);\n                    \n                    // highlight higher-order intersections\n                    if(sum == 2)\n                        c *= 3.0;\n                    else if(sum == 3)\n                        c *= 100.0;\n                    \n                    c *= 1.0/float(N)*17.0*r;\n                }\n            }\n            else\n            {\n                int sum = bool_alpha+bool_beta+bool_gamma;\n                if(sum >= 1)\n                {\n                    c = vec4(float(bool_alpha),float(bool_beta),float(bool_gamma),1.0);\n\n                    if(sum == 1)\n                        c *= 0.0; // don't display simple intersection (order 1)\n                    else if(sum == 3)\n                        c *= 0.0;\n                    \n                    c *= 1.0/float(N)*80.0*r;\n                }\n            }\n            \n            //color += c;\n            float attenuation = 0.5 + 0.5*cos(q+iTime*TWOPI/10.0);\n            attenuation = pow(attenuation,10.0);\n            color += c*(0.1+0.9*attenuation);\n\n        } // for()\n        return vec4(color.rgb,1.0);\n    }\n} // compute()\n\nvec4 transform(vec4 X)\n{\n    float alpha1\t= iTime*TWOPI/151.0;\n    float alpha2\t= iTime*TWOPI/145.0;\n    float beta1\t\t= iTime*TWOPI/131.0;\n    float beta2\t\t= iTime*TWOPI/137.0;\n    float beta3\t\t= iTime*TWOPI/143.0;\n    \n    vec4 Y = X;\n    Y.xw *= ROTATION(beta1);\n    Y.yw *= ROTATION(beta2);\n    Y.zw *= ROTATION(beta3);\n    Y.xy *= ROTATION(alpha1);\n    Y.zx *= ROTATION(alpha2);\n\treturn Y;\n} // transform()\n\n//--------------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor,vec2 fragCoord)\n{\n    float m \t\t= iResolution.x/4.0;\n\tvec2 uvLeft\t\t= (fragCoord.xy/m - vec2(1.0,1.0))*1.2;\n\tvec2 uvRight\t= (fragCoord.xy/m - vec2(3.0,1.0))*1.2;\n    vec4 d1      \t= transform(vec4(0.0,0.0,1.0,0.0)); // direction along z\n    vec4 d2      \t= transform(vec4(0.0,0.0,0.0,1.0)); // direction along w\n    if(dot(uvLeft,uvLeft)<=1.0)\n    {\n        vec4 P \t\t\t= transform(vec4(uvLeft,0.0,0.0));\n        fragColor = compute(P,d1,d2,0);\n    }\n    else if(dot(uvRight,uvRight)<=1.0)\n    {\n        vec4 P \t\t\t= transform(vec4(uvRight,0.0,0.0));\n        fragColor = compute(P,d1,d2,1);\n    }\n\n} // mainImage()\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsXfWM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsXfzB", "name": "Growing Buildings", "author": "amagitakayosi", "description": "My first post on Shadertoy.", "tags": ["raymarching"], "likes": 8, "viewed": 154, "date": "1496715134", "time_retrieved": "2024-06-20T18:56:58.961317", "image_code": "precision mediump float;\n#define GLSLIFY 1\nuniform float time;\nuniform vec2  mouse;\nuniform vec2  resolution;\nconst float PI = 3.14159265;\n\nvec2 squareFrame(vec2 screenSize, vec2 coord) {\n  vec2 position = 2.0 * (coord.xy / screenSize.xy) - 1.0;\n  position.x *= screenSize.x / screenSize.y;\n  return position;\n}\n\nmat3 calcLookAtMatrix(vec3 origin, vec3 target, float roll) {\n  vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n  vec3 ww = normalize(target - origin);\n  vec3 uu = normalize(cross(ww, rr));\n  vec3 vv = normalize(cross(uu, ww));\n\n  return mat3(uu, vv, ww);\n}\n\nvec3 getRay(mat3 camMat, vec2 screenPos, float lensLength) {\n  return normalize(camMat * vec3(screenPos, lensLength));\n}\n\nvec3 getRay(vec3 origin, vec3 target, vec2 screenPos, float lensLength) {\n  mat3 camMat = calcLookAtMatrix(origin, target, 0.0);\n  return getRay(camMat, screenPos, lensLength);\n}\n\nvec2 map(vec3 p);\n// Originally sourced from https://www.shadertoy.com/view/ldfSWs\n// Thank you Iigo :)\n\nvec2 calcRayIntersection(vec3 rayOrigin, vec3 rayDir, float maxd, float precis) {\n  float latest = precis * 2.0;\n  float dist   = +0.0;\n  float type   = -1.0;\n  vec2  res    = vec2(-1.0, -1.0);\n\n  for (int i = 0; i < 256; i++) {\n    if (latest < precis || dist > maxd) break;\n\n    vec2 result = map(rayOrigin + rayDir * dist);\n\n    latest = result.x;\n    type   = result.y;\n    dist  += latest;\n  }\n\n  if (dist < maxd) {\n    res = vec2(dist, type);\n  }\n\n  return res;\n}\n\nvec2 calcRayIntersection(vec3 rayOrigin, vec3 rayDir) {\n  return calcRayIntersection(rayOrigin, rayDir, 20.0, 0.001);\n}\n\n// Originally sourced from https://www.shadertoy.com/view/ldfSWs\n// Thank you Iigo :)\n\nvec3 calcNormal(vec3 pos, float eps) {\n  const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n  const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n  const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n  const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n  return normalize( v1 * map( pos + v1*eps ).x +\n                    v2 * map( pos + v2*eps ).x +\n                    v3 * map( pos + v3*eps ).x +\n                    v4 * map( pos + v4*eps ).x );\n}\n\nvec3 calcNormal(vec3 pos) {\n  return calcNormal(pos, 0.002);\n}\n\n#define NUM 1.\nfloat t() {\n    return iTime * 3.;\n}\n\nfloat random(in vec2 p) {\n    return fract(sin(dot(p.xy, vec2(12.34, 56.78))) * 90.0);\n}\n\nfloat sdGround(in vec3 p) {\n    return p.y;\n}\n\nfloat sdBuildings(in vec3 p) {\n    vec3 pp = mod(p, 1.) - .5;\n    float height = random(p.xz - mod(p.xz, 1.)) *3.;\n    float nearness = max(floor(p.z) - t() - 2., 0.3);\n    nearness = pow(nearness, .3);\n    pp.y = p.y * 0.4 * nearness - height * 0.1;\n    return length(max(abs(pp) - .25, .0));\n}\n\nvec2 map(vec3 p) {\n    return vec2(min(sdGround(p), sdBuildings(p)), 0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 rayOrigin = vec3(0, 1.5, 0);\n    rayOrigin.x += (sin(t() * .7) + cos(t() * .67)) * 0.07;\n    rayOrigin.y += (sin(t() * .81) + cos(t() * .8)) * 0.2;\n    vec3 rayTarget = vec3(0, 2, 9999999.);\n    rayOrigin.z = t();\n    vec3 rayDirection = getRay(rayOrigin, rayTarget, squareFrame(iResolution.xy, fragCoord), 2.);\n\n    vec3 lightDir = normalize(vec3(0.3, 3., 2.));\n    vec3 light = vec3(.4);\n    vec3 ambient = vec3(.4, .3, .5);\n\n    vec2 collision = calcRayIntersection(rayOrigin, rayDirection);\n    if (collision.x > 0.) {\n        vec3 pos = rayOrigin + rayDirection * collision.x;\n        vec3 normal = calcNormal(pos);\n        float diff = clamp(dot(lightDir, normal), 0.1, 1.0);\n        fragColor = vec4(diff * light + ambient * 1./pos.y, 1.0);\n    }\n    else {\n        float c = fragCoord.y / iResolution.y;\n        fragColor = vec4(c * 0.2, 0, c * 0.3, 1);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsXfzB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsXfzj", "name": " Power Packed Alliance 5", "author": "patu", "description": "Used as visuals in cooperation of polish demoscene musicians. \nReleased in wild compo at Decrunch copy party, 3 June 2017\n \nhttp://www.pouet.net/prod.php?which=70247", "tags": ["tunnel", "demoscene"], "likes": 26, "viewed": 1164, "date": "1497025372", "time_retrieved": "2024-06-20T18:57:01.203906", "image_code": "/*\n\n\tTunnel5 a.k.a \"IFSerno\"\n    for cooperation of polish demoscene musicians, called:\n    \n    \n    \"Power Packed Alliance\".\n    -----------------------------------\n\n\thttps://www.youtube.com/watch?v=_lSReW7eRI4\n    http://www.pouet.net/prod.php?which=70247\n\n\t\n    \n    also check my chrome extension for Shadertoy:\n    https://chrome.google.com/webstore/detail/shadertoy-unofficial-plug/ohicbclhdmkhoabobgppffepcopomhgl?hl=pl\n\n*/\n\n#define getNormal getNormalHex\n\n#define FAR 150.\n#define INFINITY 1e32\n\n#define mt iChannelTime[1]\n#define FOV 130.0\n#define FOG .06\n\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (1.618033988749895)\n\nfloat vol = 0.;\n\nvec3 fromRGB(int r, int g, int b) {\n \treturn vec3(float(r), float(g), float(b)) / 255.;   \n}\n    \nconst vec3 \n    light = vec3(0., 0., 2.)\n\t;\n\nvec3 lightColour = normalize(vec3(0.1, .0, .4)); \nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat opU2( float d1, float d2 ) {\n    if (d1 < d2) return d1;\n    return d2;\n}\n\nvec3 opU2( vec3 d1, vec3 d2 ) {\n    if (d1.x < d2.x) return d1;\n    return d2;\n}\n\nstruct geometry {\n    float dist;\n    vec3 space;\n    vec3 hit;\n    vec3 sn;\n    vec2 material;\n    int iterations;\n    float glow;\n};\n\ngeometry geoU(geometry g1, geometry g2) {\n    if (g1.dist < g2.dist) return g1;\n    return g2;\n}\n\ngeometry geoI(geometry g1, geometry g2) {\n    if (g1.dist > g2.dist) return g1;\n    return g2;\n}\n\nvec3 opS2( vec3 d1, vec3 d2 )\n{\t\n    if (-d2.x > d1.x) return -d2;\n    return d1;\n}\n\nvec3 opI2( vec3 d1, vec3 d2 ) {\n \tif (d1.x > d2.x) return d1;\n    return d2;\n}\n\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n\treturn (x<0.)?-1.:1.;\n}\n\nvec2 sgn(vec2 v) {\n\treturn vec2((v.x<0.)?-1.:1., (v.y<0.)?-1.:1.);\n}\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n// Mirror at an axis-aligned plane which is at a specified distance <dist> from the origin.\nfloat pMirror (inout float p, float dist) {\n\tfloat s = sgn(p);\n\tp = abs(p)-dist;\n\treturn s;\n}\n\nvec2 pMirrorOctant (inout vec2 p, vec2 dist) {\n\tvec2 s = sgn(p);\n\tpMirror(p.x, dist.x);\n\tpMirror(p.y, dist.y);\n\tif (p.y > p.x)\n\t\tp.xy = p.yx;\n\treturn s;\n}\n\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat fBox2Cheap(vec2 p, vec2 b) {\n\treturn vmax(abs(p)-b);\n}\n\nfloat fCross(vec3 p, vec3 size) {\n    float obj = fBox(p, size);\n    obj = opU2(obj, fBox(p, size.zxy));\n    obj = opU2(obj, fBox(p, size.yzx));\n    return obj;\n}\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\ngeometry DE(vec3 p)\n{\n    float scale = 2.1;\n\tconst float offset = 6.0;\n    const int FRACTALITERATIONS = 5;\n    vec3 modifier = vec3(1.43 , 2.01, 1.);\n\tvec3 orgp = p;\n    \n    for(int n = 0; n< FRACTALITERATIONS; n++)\n\t{\n\n        p = abs(p);\n        \n\t\tp.xy = (p.x - p.y < 0.0) ? p.yx : p.xy;\n\t\tp.xz = (p.x - p.z < 0.0) ? p.zx : p.xz;\n\t\tp.zy = (p.y - p.z < 0.0) ? p.yz : p.zy;\n\n\t\tp.x -= 12.9;\n        p.z += -2.3;\n\n        pR(p.xz, -.20645);\n        \n        if (orgp.y < 5.) p.y += orgp.x;\n        if (p.z > 0.5 * scale - 1.) p.z -= scale - 3.;\n        \n        p.xyz = scale* p.xyz - offset*(scale-1.0) * modifier.xyz;\n\t}\n    \n \tgeometry obj;\n    obj.dist = length(p.xz) * (pow(scale, -float(FRACTALITERATIONS))) - 0.03; \n\tobj.space = p;\n    return obj;\n}\n\n\ngeometry map(vec3 p) {\n    \n    vec3 bp = p;\n    \n    p.z = mod(p.z, 30.) - 65.;\n\n    pMirrorOctant(p.zy, vec2(110., 15.));        \n\tpMirrorOctant(p.xy, vec2(20.,  12.));        \n    \n    vec3 floor_p = p;\n\n    pR(p.xz, -1.5);\n        \n    p.x += 1.5;\n   \n    float pM = pModPolar(p.zx, 4.);\n\n    pMirrorOctant(p.xy, vec2(12.1, 8.)) ;\n    pMirrorOctant(p.xz, vec2(12.5, 64.));\n    \n    p.x += 10.;\n    p.yx += 3.;\n\n    geometry obj;\n    \n    obj = DE(p);\n    obj.material = vec2(1., 0.);\n\n    return obj;\n}\n\nfloat t_min = 0.01;\nfloat t_max = FAR;\nconst int MAX_ITERATIONS = 60;\n\ngeometry trace(vec3 o, vec3 d) {\n    float omega = 1.2;\n    float t = t_min;\n    float candidate_error = INFINITY;\n    float candidate_t = t_min;\n    float previousRadius = 0.;\n    float stepLength = 0.;\n    float pixelRadius = 1./ 90.;\n    \n    geometry mp = map(o);\n    mp.glow = 0.;\n    \n    float functionSign = mp.dist < 0. ? -1. : +1.;\n    float minDist = 140.;\n    \n    for (int i = 0; i < MAX_ITERATIONS; ++i) {\n\n        mp = map(d * t + o);\n\t\tmp.iterations = i;\n        \n        minDist = min(minDist, mp.dist);\n        if (i < 110) mp.glow = pow( 1. / minDist, 1.12);\n        \n        float signedRadius = functionSign * mp.dist;\n        float radius = abs(signedRadius);\n        bool sorFail = omega > 1. &&\n        (radius + previousRadius) < stepLength;\n        if (sorFail) {\n            stepLength -= omega * stepLength;\n            omega = 1.;\n        } else {\n        stepLength = signedRadius * omega;\n        }\n        previousRadius = radius;\n        float error = radius / t;\n        if (!sorFail && error < candidate_error) {\n            candidate_t = t;\n            candidate_error = error;\n        }\n        if (!sorFail && error < pixelRadius || t > t_max) break;\n        t += stepLength;\n   \t}\n    \n    mp.dist = candidate_t;\n    \n    if (\n        (t > t_max || candidate_error > pixelRadius)\n    \t) mp.dist = INFINITY;\n    \n    return mp;\n}\n\n\nfloat softShadow(vec3 ro, vec3 lp, float k) {\n    const int maxIterationsShad = 8;\n    vec3 rd = (lp - ro); // Unnormalized direction ray.\n\n    float shade = 4.;\n    float dist = 4.5;\n    float end = max(length(rd), 0.01);\n    float stepDist = end / float(maxIterationsShad);\n\n    rd /= end;\n    for (int i = 0; i < maxIterationsShad; i++) {\n        float h = map(ro + rd * dist).dist;\n        shade = min(shade, k*h/dist);\n        dist += min(h, stepDist * 2.); \n        if (h < 0.001 || dist > end) break;\n    }\n    return min(max(shade, 0.0), 1.0);\n}\n\n#define EPSILON .001\nvec3 getNormalHex(vec3 pos)\n{\n\tfloat d=map(pos).dist;\n\treturn normalize(\n        vec3(\n            map(\n                pos+vec3(EPSILON,0,0)).dist-d,\n                map(pos+vec3(0,EPSILON,0)).dist-d,\n                map(pos+vec3(0,0,EPSILON)).dist-d \n        \t)\n    \t);\n}\n\nfloat getAO(vec3 hitp, vec3 normal, float dist)\n{\n    vec3 spos = hitp + normal * dist;\n    float sdist = map(spos).dist;\n    return clamp(sdist / dist, 0.0, 1.0);\n}\n\nvec3 getObjectColor(vec3 p, vec3 n, geometry obj) {\n    vec3 col = vec3(0.0);\n        \n    if (obj.material.x == 1.0) { \n        col += 1.;\n    }\n    \n    return col ;\n}\n\nvec3 doColor( in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, geometry obj) {\n\tvec3 sceneCol = vec3(0.0);\n    lp = sp + lp;\n    vec3 ld = lp - sp; \n    float lDist = max(length(ld / 2.), 0.001); \n    ld /= lDist; \n    float diff = max(dot(sn, ld), 1.);\n    float spec = pow(max(dot(reflect(-ld, sn), -rd), .0), 1.);\n    vec3 objCol = getObjectColor(sp, sn, obj);\n    sceneCol += (objCol * (diff + .15) * spec * .4);\n\n    return sceneCol;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    vec2 ouv = fragCoord.xy / iResolution.xy;\n    vec2 uv = ouv - .5;\n    \n    vol = length(texture(iChannel0, vec2(.42, .25)).rgb);\n    \n    uv *= tan(radians (FOV) / 2.0);\n    \n    if (abs(uv.y) > .75) {\n    \tfragColor *= 0.;\n        return;\n    }\n\n    float t2 = iTime - 35.;\n    float \n        sk = sin(-t2 * .04) * 16.0, \n        ck = cos(-t2 * .107) * 12.0 - sk,\n        \n        mat = 0.;    \n\n    \n    //light = vec3(0., 0., 2.);        \n    \n    float speed = min(7., iTime / 20.); \n\n    \n    vec3 \n        vuv = vec3(cos(iTime / 17. * speed), sin(iTime / 4.), 0.), // up\n    \tro = vec3(-1., 0.5, iTime * speed);\n    \n    vec3\n        vrp =  vec3(0., 0., 10. + iTime * speed); \n\t\n\n    vrp.x += sin(ro.z / 12.) * 1.;\n    vrp.y += sin(ro.z / 10.) * 10.;\n     \n    vec3 \n    \tvpn = normalize(vrp - ro),\n    \tu = normalize(cross(vuv, vpn)),\n    \tv = cross(vpn, u),\n    \tvcv = (ro + vpn),\n    \tscrCoord = (vcv + uv.x * u * iResolution.x/iResolution.y + uv.y * v),\n    \trd = normalize(scrCoord - ro);\n                \n\t\n    vec3 sceneColor = vec3(0.);\n  \n    vec3 lp = light + ro;\n\t//lightDir = lp;\n\t\n    geometry tr = trace(ro, rd);    \n    \n    float fog = smoothstep(FAR * FOG, 0., tr.dist / 6.);\n    tr.hit = ro + rd * tr.dist;\n    \n    tr.sn = getNormal(tr.hit);\t\n    \n    float sh = softShadow(tr.hit, light, 15.);\n    \n    float \n        ao = getAO(tr.hit, tr.sn, 9.);\n  \n    if (tr.dist < FAR) { \n        \n        vec3 col = (doColor(tr.hit, rd, tr.sn, light, tr) * 1.) * 1.;\n        \n        sceneColor = col;\n        sceneColor *= ao; \n        sceneColor *= sh;\n     \n        sceneColor += texture(iChannel0, vec2(120. - length(tr.hit.xy) / 8., 0.25)).rrr / tr.dist / 4.; \n    }    \n    \n    sceneColor = mix(sceneColor, lightColour, 0.15); \n    sceneColor += pow(sin(float(tr.iterations) / 70.), 2.9) * 5.55 * vec3(1., 0.5, 0.);\n    sceneColor += (pow((sin(PI * fract(iTime * 0.1 +  (sin(tr.hit.y + iTime * 0.1) - sin(tr.hit.x)) / 10. + iTime / 3.)) + 1.), 5.) / 10.) / 20.;\n    \n    fragColor = vec4(clamp(sceneColor * (1. - length(uv) / 2.5), 0.0, 1.0), 1.0);\n    fragColor *= 1. + pow(vol * 1.,  13.2) / 10.;\n    fragColor = pow(fragColor, vec4(1.4));\n    \n\n    \n}\n", "image_inputs": [{"id": "MdsSD4", "previewfilepath": "https://soundcloud.com/decrunch/power-packed-alliance", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/decrunch/power-packed-alliance", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsXfzj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MsXfzS", "name": "Pillar test", "author": "macke", "description": "pillar", "tags": ["pillar"], "likes": 2, "viewed": 62, "date": "1496685667", "time_retrieved": "2024-06-20T18:57:01.203906", "image_code": "#define pi 3.1415\n#define tm iTime\n\n\nstruct Object {\n    float d; // Distance\n    vec3 color;\n};\n    \n    \nObject omin(Object o1, Object o2) {\n    if(o1.d <= o2.d) {\n        return o1;\n    }\n    return o2;\n}\n\nObject omax(Object o1, Object o2) {\n    if(o1.d >= o2.d) {\n        return o1;\n    }\n    return o2;\n}\n    \nmat3 rotz(float t){\n     return mat3( cos(t),  -sin(t), 0,\n       \t          sin(t),   cos(t), 0,\n\t\t  \t\t  0,        0 ,     1);\n}\n\nmat3 roty(float t){\n    return  mat3( cos(t),  0,  sin(t),\n     \t    \t  0,       1,  0,\n           \t      -sin(t), 0,  cos(t)); \n\n}\n\nmat3 rotx(float t){\n     return mat3( 1, 0 ,      0,\n            \t  0, cos(t), -sin(t),\n\t   \t  \t      0, sin(t),  cos(t));\n}\n\nfloat modcenter(float t, float m) {\n    t += m/2.;\n    return mod(t, m) - m/2.;\n}\n\nfloat modax(float t, float m) {\n    return mod(t, m) - m/2.;\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p)-r;\n}\n\nfloat udBox(vec3 p, vec3 s) {\n   \treturn length(max(abs(p)-s,0.));\n    \n}\n\nfloat random(float hash) {\n \treturn fract(sin(hash*361.)*45345.34645645) * 2. - 1.;   \n}\n\nObject map(vec3 p) {\n    \n    vec3 q = p;\n    q.x = abs(q.x) - 8.;\n    q.z = modcenter(q.z, 20.);\n    q.y = modcenter(q.y, 2.);\n    \n    // Random block\n    q.x += random(floor(p.y/2.))* 0.5;\n    q.z += random(floor(p.y/2.) + 1.)* 0.5;\n    \n    // Random color\n    vec3 col = vec3(((random(floor(p.y/2.)) + 1.) * 0.5 + .8)/8.);\n    \n    Object boxes = Object(udBox(q,vec3(2.,1.,2.)), col);  \n    Object plane = Object(p.y + 5.4, vec3(.3));\n    \n    vec3 pp = p + vec3(0.,5.6,-40.-tm*5.);\n    pp.z = modcenter(pp.z, 2.);\n    pp.x = abs(pp.x) - 2.;\n    pp.x = abs(pp.x) - 2.;\n    pp.x = abs(pp.x) - 2.;\n    pp.x = abs(pp.x) - 2.;\n    pp.y -= random(floor(p.x/2.))* 0.2;\n    pp.y -= random(floor(p.z/2.))* 0.2;\n    \n    Object path = Object(udBox(pp , vec3(2.,2.,2.)), vec3(0.4));\n    \n    return omin(path, omin(boxes,plane));\n}\n\nvec3 normalapprox(vec3 p, float e) {\n    vec2 h = vec2(e, 0.);\n    return normalize(vec3(map(p + h.xyy).d - map(p - h.xyy).d,\n                          map(p + h.yxy).d - map(p - h.yxy).d,\n                          map(p + h.yyx).d - map(p - h.yyx).d));\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv*2. - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float fasttime = tm * 5.;\n    vec3 o = vec3(0.,5.+sin(fasttime)/5., fasttime);\n    vec3 r = normalize(vec3(uv,2.));\n    \n    //Mouse\n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n  \t//r *= rotx(pi/6.);\n   \t//r *= roty(pi/6.);\n    \n    //Distance, p = position of object\n   \tObject obj = Object(0., vec3(0.,0.,0.));\n    vec3 p;\n    for (int i = 0; i < 64; i++) {\n        p = o + r * obj.d;\n     \tObject m = map(p);\n        //if (m.d < 0.01) break;\n        obj.d += m.d * 0.9;\n      \tobj.color = m.color;\n    }\n    \n   \t//Light\n    //vec3 normal = normalapprox(p,0.0001);\n    vec3 normal = normalize(-p);\n    vec3 light = normalize(vec3(0.,1., -1.));\n    float a = acos(dot(normal, light));\n    \n    float fog = 1.0 / (0.0005 * obj.d * obj.d + .5 + a);\n    \n\tfragColor = vec4(vec3(fog) * obj.color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MsXfzS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "MtS3Wy", "name": "data center old", "author": "public_int_i", "description": "had this sitting as private for a while, has some bugs", "tags": ["3d", "old", "center", "data"], "likes": 0, "viewed": 375, "date": "1497706432", "time_retrieved": "2024-06-20T18:57:02.003927", "image_code": "//Ethan Alexander Shulman 2017\n#define FOV_SCALE 1.\n#define VIEW_DIST 5000.\n#define REFLECTION_BOUNCES 2\n#define AA 2\n\nconst vec2 wallSize = vec2(2.,2.);\n\n//distance multiplier\n#define pm db *= 1.+(min(0.,db)*10000000.)\n//plane clip\n#define cp(p,s) db *= 1.+length(max(abs(p)-s,0.))*10000000.\n//plane clip position\n#define cc(p,d,c) ba = (p+d*db)-c\n//distance compare\n#define dc lt = float(db<d); lt1 = 1.-lt; d = d*lt1+db*lt\n//normal compare\n#define ns(n) nrm = lt1*nrm+lt*n\nfloat trace(in vec3 rp, in vec3 rd, inout vec3 nrm) {\n    vec2 ba;\n    float lt,lt1;\n    float d;\n    float nb = 2.-rp.y;//floor\n    float db = nb/rd.y;\n    pm;\n    d = db;\n    nrm = vec3(0.,sign(nb),0.);\n    \n    nb = 2.-rp.x;//right wall\n    db = nb/rd.x;\n    cc(rp.yz,rd.yz,vec2(0.,0.));\n    cp(ba,wallSize);\n    pm;\n    dc;\n    ns(vec3(sign(nb),0.,0.));\n   \n    nb = -2.-rp.x;//left wall\n    db = nb/rd.x;\n    cc(rp.yz,rd.yz,vec2(0,0.));\n    cp(ba,wallSize);\n    pm;\n    dc;\n    ns(vec3(sign(nb),0.,0.));\n    \n    nb = 2.-rp.z;//front wall\n    db = nb/rd.z;\n    cc(rp.xy,rd.xy,vec2(0.,0.));\n    cp(ba,wallSize);\n    pm;\n    dc;\n    ns(vec3(0.,0.,sign(nb)));\n    \n    nb = -2.-rp.z;//back wall\n    db = nb/rd.z;\n    cc(rp.xy,rd.xy,vec2(0.,0.));\n    cp(ba,wallSize);\n    pm;\n    dc;\n    ns(vec3(0.,0.,sign(nb)));\n    \n    nb = -2.-rp.y;//roof\n    db = nb/rd.y;\n    cc(rp.xz,rd.xz,vec2(0.,0.));\n    cp(ba,wallSize);\n    pm;\n    dc;\n    ns(vec3(0.,sign(nb),0.));\n    \n    return d;\n}\n\nconst vec3 ne = vec3(0.001,0.,0.);\nfloat engraving(in vec3 rp, in vec3 r) {\n    return length(rp)-max(0., 1.-min(abs(r.x),abs(r.z))*12.)*.04;\n    //return (-2.-r.y)\n}\n#define sky(r)  (texture(iChannel1,r.xz/r.y-iTime*.01).z*texture(iChannel0,r.xz/r.y/44.2314+iTime*.02).z)+.4\n\nvec4 scene(inout vec3 rp, inout vec3 rd) {\n    vec4 c;\n    vec3 nrm;\n    \n \tfloat d = trace(rp,rd,nrm);\n    if (d < VIEW_DIST) {\n        rp += (d-.08)*rd;\n        vec3 srp = rp;\n        rp += .04*rd;\n        for (int i = 0; i < 4; i++) {\n            d = engraving((rp-srp)*nrm,rp);\n            if (d < .04) break;\n        \trp += d*rd;\n        }\n        \n        vec3 s2rp = rp;\n        rp = rp-srp;\n\t\trp *= nrm;\n        srp = s2rp;\n        nrm = normalize(vec3(engraving(rp+ne,srp+ne)-engraving(rp-ne,srp-ne),\n                             engraving(rp+ne.yxz,srp+ne.yxz)-engraving(rp-ne.yxz,srp-ne.yxz),\n                             engraving(rp+ne.yzx,srp+ne.yzx)-engraving(rp-ne.yzx,srp-ne.yzx)));\n      \trp = s2rp;\n        \n        rd = reflect(rd,nrm);\n        \n        c.xyz = vec3(.04)+\n            \tvec3(.8,.9,.4)*max(0., 1.-min(abs(rp.x),abs(rp.z))*32.)*max(0.,cos(iTime*10.+abs(rp.x)+abs(rp.z)));\n        c.w = .3;//reflection amount\n    } else {\n        c = vec4(sky(rd));\n        c.w = 0.;\n    }\n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 fout = vec4(0.);\n    float cscale = 1.;\n    #ifdef AA\n    cscale = 1./float(AA*AA*2);\n    for (int ai = -AA*AA; ai < AA*AA; ai++) { \n    #endif\n\tvec2 uv = fragCoord.xy / iResolution.xy - vec2(.5);\n        #ifdef AA\n        float fi = float(ai);\n        uv += vec2(mod(fi,float(AA)),floor(fi/float(AA)))*(.5/iResolution.xy);\n        #endif\n    uv.y *= iResolution.y/iResolution.x;\n    \n    float mX = iMouse.x/iResolution.x*6.3;\n    vec3 rp = vec3(sin(mX)*15.,(iMouse.y/iResolution.y-1.)*30.,cos(mX)*15.);\n    vec3 rd = normalize(-rp);\n    vec3 rr = cross(vec3(0.,1.,0.),rd);\n    rr = rd = normalize(rd*FOV_SCALE + uv.x*rr + uv.y*cross(rr,rd));\n    \n    vec4 c = scene(rp,rd);\n    if (c.w < .01) {\n        #ifdef AA\n        fout += cscale*c;\n        continue;\n        #else\n        fragColor = c;\n        return;\n        #endif\n    }\n    \n    float s = 1.,wb;\n    vec4 cs;\n    for (int i = 0; i < REFLECTION_BOUNCES; i++) {\n        cs = scene(rp,rd);\n        wb = cs.w;\n        c = mix(c,cs,c.w*s);\n        if (wb < .02) break;\n        \n        c.w = wb;\n        s *= .5;\n    }\n    \n    fout += cscale*c;\n    #ifdef AA\n    }\n    #endif\n    fragColor = fout;\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MtS3Wy.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdfBDl", "name": "Railord", "author": "pi", "description": "An infinite roller coaster with a superconductor on it. More of a vomit dispenser than a roller coaster.", "tags": ["3d", "raymarch", "raytrace", "rollercoaster"], "likes": 10, "viewed": 247, "date": "1498688663", "time_retrieved": "2024-06-20T18:57:02.003927", "image_code": "\n    float speed = 12.;\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\nmat3 rotate(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, \n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c\n             );\n}\nmat3 lookat(vec3 o, vec3 t) {\n\tvec3 dir = normalize(t-o);\n    float yAxis = atan(dir.x,dir.z);\n    float xAxis = -asin(dir.y);\n    return rotate(vec3(1,0,0),xAxis)*rotate(vec3(0,1,0),yAxis);\n}\nvec3 path (float m) {\n    float t = m/10.;\n    vec2 core = vec2(noise(vec2(t/5.,t/3.))*2.,noise(vec2(t,t/3.)));\n\treturn vec3(core*4.,m);    \n}float smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nfloat rail(vec3 o) {\n\tfloat nL = length(o.xy-vec2(1,-1.2)-path(o.z).xy)-.2;\n    float nR = length(o.xy+vec2(1,1.2)-path(o.z).xy)-.2;\n    float mD =length(o.xy+vec2(asin(sin(o.z))/3.14*1.8,1.2)-path(o.z).xy)-.1;\n    return smin(mD,min(nL,nR),.1);\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat cart(vec3 o) {\n    \n    o.y/=2.6;\n    o/=1.3;\n    float f = sdBox(o,vec3(o.y+1.5,.3,o.y+1.5)/3.);\n    return f;\n}\nvec2 map(vec3 pos) {\n\tfloat n = 0.;\n    \n    n=rail(pos);//length(pos)-1.;\n    \n    \tvec3 c = path(iTime*speed+3.);\n        vec3 v = pos-c;\n        v*=inverse(lookat(c,path(iTime*speed+3.+.1)));\n        float q = cart(v);    \n    \tn=min(q,n);\n    return vec2(n,n==q?1.:0.);\n}\nvec3 normal( in vec3 x)\n{\n    vec2 e = vec2( .01, 0.0 );\n    return normalize( vec3( map(x+e.xyy).x - map(x-e.xyy).x,\n                            map(x+e.yxy).x - map(x-e.yxy).x,\n                            map(x+e.yyx).x - map(x-e.yyx).x ) );\n}\nfloat FAR = 85.;\nfloat trace(vec3 o, vec3 d){\n\tfloat t=0.,q;\n    for (int i = 0;i < 160; i++) {\n    \tif((q=map(o+d*t).x)<.01||t>FAR) break;\n        t+=q*.9;    \n    }\n    return t;\n}\nfloat raycast_terrain(vec3 o, vec3 d) {\n    return (1.2+o.y)/-d.y;\n}\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max((abs(n) - 0.2)*7., 0.001); // max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z );  \n    \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\nvec3 ground(vec2 u) {\n    float k = 0.;\n    k=(sign(sin(u.x*3.14))+sign(sin(u.y*3.14)));\n    float jt =  ((sin(u.x*3.14))+(sin(u.y*3.14)));\n    vec3 i = vec3(.2,.1,0)*pow(abs(1.-clamp(jt, 0., 1.)), 10.);\n    i+=abs(jt)/2.;\n    return i;\n}\nvec3 bGround(vec2 u) {\n    return ground(u);\n}\nvec3 pMarch(vec3 ro, vec3 rd)  {\n    float tr = raycast_terrain(ro,rd);\n    vec3 hit = ro+rd*tr;\n    if(tr<0.)\n        return vec3(0);\n    vec3 tex = bGround(hit.xz);\n    return tex;\n}\nconst float e= 2.71828;\nfloat fogDens = .05;\nvec3 sky(vec3 rd) {\n\treturn abs(rd).yxy;\n}\nvoid render(vec3 od, vec3 rd, out vec3 color) {\n    vec3 ro = path(iTime*speed)+vec3(0,1.25,0)+od;\n    color=vec3(0);\n    rd*=lookat(ro,path(iTime*speed+.1)+vec3(0,1.25,0));\n    float dist = trace(ro, rd);\n    float terr = raycast_terrain(ro,rd);\n    float dv = dist;\n    if(terr>0.&&terr<dist&&terr<FAR) {\n        dv=terr;\n        vec3 hit = ro+rd*terr;\n        color = ground(hit.xz);\n        float shd = (trace(hit,vec3(0,1,0)));\n        if(map(hit+vec3(0,1,0)*shd).x<.02)\n            color-=1./vec3(shd);\n    } else {\n        vec3 hit = ro+rd*dist;\n        float mit = map(hit).x;\n\n        if (mit<.01) {\n            vec3 n = normal(hit);\n            vec3 qit = hit;\n            if(map(hit).y>0.) {\n            \t\n            color = tex3D(iChannel2, (lookat(path(iTime*speed+3.),path(iTime*speed+3.+.1)))*(qit-path(iTime*speed+3.)), n);\n            color *= max(n.y,0.4);\n            }\n            else{\n            color = tex3D(iChannel0, qit/10., n).ggg;\n            color *= max(n.y,0.0);\n            vec3 pbr = pMarch(hit, n);\n            color+=pbr/5.;\n            }\n        }\n    }\n    color=mix(color,sky(rd),clamp(1./e*dv*fogDens,0.,1.));\n}\nvoid mainImage( out vec4 f, vec2 p )\n{\n    vec2 R = iResolution.xy, uv = (2.*p-R)/R.y;\n    vec3 od = vec3(0);\n    render(od,normalize(vec3(uv,1.6)), od);\n    f=vec4(od*min(1.,iTime),1)*(1.-length(uv)/2.3);\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}, {"id": "lsXSRf", "previewfilepath": "https://soundcloud.com/dj-meizong/radiation-original-mix", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/dj-meizong/radiation-original-mix", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdfBDl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdfBDM", "name": "cccccsaderfvg", "author": "yuchenwuhen", "description": "qqq", "tags": ["qqq"], "likes": 0, "viewed": 66, "date": "1496324478", "time_retrieved": "2024-06-20T18:57:02.010158", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdfBDM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdfBRs", "name": "Cyclone ~another version", "author": "Torumu106", "description": "Another version for friend.", "tags": ["shader"], "likes": 1, "viewed": 73, "date": "1497428356", "time_retrieved": "2024-06-20T18:57:02.010158", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 r = 2.0 * vec2(uv.x - 0.5, uv.y - 0.5);\n    r.x *= iResolution.x / iResolution.y;\n    vec3 ret = vec3(0.1);\n    vec3 col = vec3(0.7 + sin(iTime) * 0.2, 0.4  - sin(iTime) * 0.1, 0.0);\n    vec3 col1 = vec3(0.5 - sin(iTime) * 0.2, 0.2, 0.5  + sin(iTime) * 0.1);\n    \n    float GlobalTime = mod(iTime, 9.0);\n    \n    vec2 r1 = r;\n    \n    float the = (3.0 - length(r) / 2.0) * 20.0;\n    r.xy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    \n    the = -iTime * 2.0;\n    r1.xy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    \n    if(r1.x >= -2.6 && r1.x <= 2.6 && r1.y <= 0.015 && r1.y >= -0.015){\n    \tret = col1;\n    }\n    if(r1.x >= -0.015 && r1.x <= 0.015 && r1.y <= 2.6 && r1.y >= -2.6){\n    \tret = col1;\n    }\n    \n    the =  3.1415926535 / 4.0;\n    r1.xy *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    \n    if(r1.x >= -2.6 && r1.x <= 2.6 && r1.y <= 0.015 && r1.y >= -0.015){\n    \tret = col1;\n    }\n    if(r1.x >= -0.015 && r1.x <= 0.015 && r1.y <= 2.6 && r1.y >= -2.6){\n    \tret = col1;\n    }\n    \n    if(length(r - vec2(GlobalTime / 5.0)) <= GlobalTime / 30.0 ){\n    \tret = col;\n    }\n    r.x *= -1.0;\n    if(length(r - vec2(GlobalTime / 5.0)) <= GlobalTime / 30.0 ){\n    \tret = col;\n    }\n    r.y *= -1.0;\n    if(length(r - vec2(GlobalTime / 5.0)) <= GlobalTime / 30.0 ){\n    \tret = col;\n    }\n    r.x *= -1.0;\n    if(length(r - vec2(GlobalTime / 5.0)) <= GlobalTime / 30.0 ){\n    \tret = col;\n    }\n    \n    GlobalTime = mod(iTime - 6.0, 9.0);\n    if(length(r - vec2(GlobalTime / 5.0)) <= GlobalTime / 30.0 ){\n    \tret = col;\n    }\n    r.x *= -1.0;\n    if(length(r - vec2(GlobalTime / 5.0)) <= GlobalTime / 30.0 ){\n    \tret = col;\n    }\n    r.y *= -1.0;\n    if(length(r - vec2(GlobalTime / 5.0)) <= GlobalTime / 30.0 ){\n    \tret = col;\n    }\n    r.x *= -1.0;\n    if(length(r - vec2(GlobalTime / 5.0)) <= GlobalTime / 30.0 ){\n    \tret = col;\n    }\n    \n    GlobalTime = mod(iTime - 3.0, 9.0);\n    if(length(r - vec2(GlobalTime / 5.0)) <= GlobalTime / 30.0 ){\n    \tret = col;\n    }\n    r.x *= -1.0;\n    if(length(r - vec2(GlobalTime / 5.0)) <= GlobalTime / 30.0 ){\n    \tret = col;\n    }\n    r.y *= -1.0;\n    if(length(r - vec2(GlobalTime / 5.0)) <= GlobalTime / 30.0 ){\n    \tret = col;\n    }\n    r.x *= -1.0;\n    if(length(r - vec2(GlobalTime / 5.0)) <= GlobalTime / 30.0 ){\n    \tret = col;\n    }\n    \n    if(length(r) <=0.1){\n    \tret = col1;\n    }\n    \n\tfragColor = vec4(ret,1.0);\n}\n//sin(iTime)", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdfBRs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdfBWf", "name": "Blinking Cube Rasterizer", "author": "zproxy", "description": "https://www.shadertoy.com/view/MsjSzz", "tags": ["rasterizer"], "likes": 3, "viewed": 93, "date": "1498416210", "time_retrieved": "2024-06-20T18:57:02.743459", "image_code": "#define LINEAR_ROTATION\n\n#define WEIGHT (3.0 / iResolution.x)\nconst vec3 RED = vec3(1.0,0.0,0.0);\nconst vec3 GREEN = vec3(0.0,1.0,0.0);\nconst vec3 BLUE = vec3(0.0,0.8,1.0);\nconst vec3 WHITE = vec3(1.0,1.0,0.97);\nconst vec3 YELLOW = vec3(1.0,1.0,0.0);\n\n// rasterize functions\nfloat line(vec2 p, vec2 p0, vec2 p1, float w) {\n    vec2 d = p1 - p0;\n    float t = clamp(dot(d,p-p0) / dot(d,d), 0.0,1.0);\n    vec2 proj = p0 + d * t;\n    float dist = length(p - proj);\n    dist = 1.0/dist*WEIGHT*w;\n    return min(dist*dist,1.0);\n}\nfloat circle(vec2 p, vec2 c, float r, float w) {\n    float dist = abs(length(p - c)) + r;\n    dist = 1.0/dist*WEIGHT*w;\n    return min(dist*dist,1.0);\n}\n\n// matrices\nmat4 getRotMatrix(vec3 a) {\n    vec3 s = sin(a);\n    vec3 c = cos(a);    \n    mat4 ret;\n    ret[0] = vec4(c.y*c.z,c.y*s.z,-s.y,0.0);\n    ret[1] = vec4(s.x*s.y*c.z-c.x*s.z,s.x*s.y*s.z+c.x*c.z,s.x*c.y,0.0);\n    ret[2] = vec4(c.x*s.y*c.z+s.x*s.z, c.x*s.y*s.z-s.x*c.z,   c.x*c.y,0.0);    \n    ret[3] = vec4(0.0,0.0,0.0,1.0);\n    return ret;\n}\nmat4 getPosMatrix(vec3 p) {   \n    mat4 ret;\n    ret[0] = vec4(1.0,0.0,0.0,p.x);\n    ret[1] = vec4(0.0,1.0,0.0,p.y);\n    ret[2] = vec4(0.0,0.0,1.0,p.z);   \n    ret[3] = vec4(0.0,0.0,0.0,1.0);\n    return ret;\n}\n\n// utils\nvec3 mix3(vec3 a, vec3 b, vec3 c, float t) {\n    if(t>0.5) return mix(b,c,t*2.0-1.0);\n    else return mix(a,b,t*2.0);\n}\nvec3 fragment(vec3 p) {\n    float t = sin(p.x*0.8+iTime*0.5)*0.5+0.5;\n    float fog = min(pow(p.z,3.0)*400.0,1.0);\n    return mix3(RED,GREEN,BLUE,t) * fog;\n}    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    //uv = uv * (1.0 + pow(length(uv)*0.4,0.5)) * 0.6;\n    \n    float line_width = 1.9;\n    float time = iTime * 0.31415;\n    vec3 c = vec3(mix(vec3(0.19,0.13,0.1),vec3(1.0), 0.5*pow(length(uv)*0.5,2.0)));\n    mat4 cam = getPosMatrix(vec3(0.0,0.0,8.0));\n    \n#ifdef LINEAR_ROTATION\n    mat4 rot = getRotMatrix(vec3(time,time*0.86,time*0.473));\n#else\n    float p = 0.08;\n    mat4 rot = getRotMatrix(vec3(time\t\t+sin(time*30.0)*p,\n                                 time*0.860\t+sin(time*20.0)*p*1.24,\n                                 time*0.473\t+sin(time*10.0)*p));\n#endif\n    \n    vec3 instances[18];\n    instances[0] = vec3( 0.0, 0.0,0.0);\n   \n    // box pipeline\n    for(int dip = 0; dip < 1; dip++) {\n        \n        // input assembly\n        // vec3 vert[8];\n        vec3[8] vert;\n        \n        vert[0] = vec3(-1.0,-1.0, 1.0);\n        vert[1] = vec3(-1.0, 1.0, 1.0);    \n        vert[2] = vec3( 1.0, 1.0, 1.0);    \n        vert[3] = vec3( 1.0,-1.0, 1.0);\n        vert[4] = vec3(-1.0,-1.0,-1.0);\n        vert[5] = vec3(-1.0, 1.0,-1.0);    \n        vert[6] = vec3( 1.0, 1.0,-1.0);    \n        vert[7] = vec3( 1.0,-1.0,-1.0);\n\n        // vertex processing        \n        mat4 pos = getPosMatrix(instances[dip] * 4.0);\n        mat4 mat = pos * rot * cam;\n\n        for(int i = 0; i < 8; i++) {\n\n            // transform\n            vert[i] = (vec4(vert[i],1.0) * mat).xyz;\n\n            // perspective\n            vert[i].z = 1.0 / vert[i].z;\n            \n            // what does this do? isometric without.\n            vert[i].xy *= vert[i].z;\n        }    \n\n        // primitive assembly and rasterize\n        float i;\n        i  = line(uv,vert[0].xy,vert[1].xy,line_width);\n        i += line(uv,vert[1].xy,vert[2].xy,line_width);\n        i += line(uv,vert[2].xy,vert[3].xy,line_width);\n        i += line(uv,vert[3].xy,vert[0].xy,line_width);\n        \n        // upper make. it blink some\n        if (int((iFrame / 30) % 2) == 0)\n        {\n        i += line(uv,vert[4].xy,vert[5].xy,line_width);\n        i += line(uv,vert[5].xy,vert[6].xy,line_width);\n        i += line(uv,vert[6].xy,vert[7].xy,line_width);\n        i += line(uv,vert[7].xy,vert[4].xy,line_width);\n        }\n        \n        // verticals\n        \n        else\n        {\n        i += line(uv,vert[0].xy,vert[4].xy,line_width);\n        i += line(uv,vert[1].xy,vert[5].xy,line_width);\n        i += line(uv,vert[2].xy,vert[6].xy,line_width);\n        i += line(uv,vert[3].xy,vert[7].xy,line_width);\n        }\n        \n    \n        \n        c += fragment(vert[0]) * min(i,1.0);\n    }\n     \n    \n    // fragment\n\tfragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdfBWf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdfBzl", "name": "308 char starfield (w/ texture)", "author": "Ebanflo", "description": "Not very exciting, but its my first shot at this sort of thing.", "tags": ["golf"], "likes": 1, "viewed": 511, "date": "1497405849", "time_retrieved": "2024-06-20T18:57:02.743459", "image_code": "float h(vec3 p)//Dave_Hoskins https://www.shadertoy.com/view/4djSRW\n{\n\tp=fract(p*.103);\n    p+=dot(p,p.yzx+19.2);\n    return fract((p.x+p.y)*p.z);\n}\nvec4 f(vec2 x){\n    vec4 a=vec4(0);\n    float s=1.;\n    for(int n=0;n<5;n++){\n        a+=texture(iChannel0,s*x)/s;\n        s*=2.;\n    }\n    return a*.65;\n}\nvoid mainImage(out vec4 o,vec2 i){\n    i/=iResolution.xy;\n    o=smoothstep(.9,1.,f(i));\n    //(length(o)>.7)?o+=h(vec3(i,iTime)):o=vec4(0.); //twinkle\n    //(length(o)>.7)?o+=texture(iChannel0, i+iTime):o=vec4(0.0); //not working\n    o+=(dot(o,o)>.5)?h(vec3(i,iTime)):0.; //Fabrice's twinkle\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdfBzl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdffR2", "name": "29/100", "author": "yahe", "description": "29/100", "tags": ["bezier"], "likes": 6, "viewed": 470, "date": "1496912907", "time_retrieved": "2024-06-20T18:57:03.531399", "image_code": "const float Pi = 3.1415926535;\n\nfloat Point(vec2 uv, vec2 P)\n{\n    return smoothstep(0.035, 0.005, distance(uv, P));   \n}\n\nfloat cbrt(float x)\n{\n    return sign(x) * pow(abs(x), 1.0/3.0);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n// http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c\n// Solve cubic ax^3 + bx^2 + cx + d = 0 \n// Returns amount of roots\nint SolveCubic(vec4 coeffs, out vec3 roots)\n{\n    int nS = 0;  \n    // normal form: x^3 + Ax^2 + Bx + C = 0 \n    vec4 N = coeffs / coeffs[0];\n\n    // substitute x = y - A/3 \n    // depressed cubic: x^3 + px + q = 0 \n    float sqA = N[1]*N[1];\n    float p = (N[2] - sqA/3.0) / 3.0;\n    float q = ( (N[1] * sqA)/13.5 - (N[1] * N[2])/3.0 + N[3]) * 0.5;\n\n    // Use Cardano's formula \n    float cbP = p * p * p;\n    float D = q * q + cbP;\n\n    if (abs(D) < 1e-20)\n    {\n\t\tif (q == 0.0)  \n            nS = 1;\n\t\t   \n\t\telse // one single and one double solution\n\t\t{\n\t\t    float u = cbrt(-q);\n\t\t    roots[0] = 2.0 * u;\n\t\t    roots[1] = -u;\n\t\t    nS = 2;\n\t\t}\n    }\n    \n    else if (D < 0.0) // Casus irreducibilis: three real solutions\n    {\n\t\tfloat phi = acos(-q / sqrt(-cbP)) / 3.0;\n\t\tfloat t = 2.0 * sqrt(-p);\t\n\t\troots[0] = t * cos(phi);\n\t\troots[1] = -t * cos(phi + Pi/3.0);\n\t\troots[2] = -t * cos(phi - Pi/3.0);\n\t\tnS = 3;\n    }\n    \n    else // one real solution \n    {\n\t\tfloat sqrtD = sqrt(D);\n\t\troots[0] = cbrt(sqrtD - q) - cbrt(sqrtD + q);\n\t\tnS = 1;\n    }\n\n    roots -= N[1] / 3.0;\n    \n    return nS;\n}\n\nvec2 QuadraticBezier(float t, vec2 p0, vec2 p1, vec2 p2)\n{\n\treturn mix((mix(p0, p1, t)),(mix(p1, p2, t)), t);\n}\n\n// x is a point\n// {a, b, c} are the control points\nfloat DistanceQuadraticBezier(vec2 x, vec2 a, vec2 b, vec2 c)\n{\n    float aa = dot(a,a);\tfloat bc = dot(b,c);\tfloat cc = dot(c,c);\n    float ab = dot(a,b);\tfloat bb = dot(b,b);   \tfloat cx = dot(c,x);\n    float ac = dot(a,c);\tfloat bx = dot(b,x);\n    float ax = dot(a,x);\n           \n    // Cubic coefficients\n    float cu = 4.0*(aa + cc) + 16.0*(bb - ab - bc) + 8.0*ac;\n    // Quadratic coefficients\n\tfloat qu = 12.0*(bc - ac - aa) - 24.0*bb + 36.0*ab;\n    // Linear coefficients\n    float li = 4.0*(ac - ax - cx) + 8.0*(bx + bb) + 12.0*aa - 24.0*ab;\n    // Constant terms\n    float C = 4.0*(ab + ax - aa - bx);\n    vec3 roots;\n    vec4 coeffs = vec4(cu, qu, li, C);\n    \n    int nS = SolveCubic(coeffs, roots);  \n    float t;\n\n   \tfloat Dist1 = distance(x, QuadraticBezier(clamp(roots.x, 0.0, 1.0), a, b, c));\n    float Dist2 = distance(x, QuadraticBezier(clamp(roots.y, 0.0, 1.0), a, b, c));\n    float Dist3 = distance(x, QuadraticBezier(clamp(roots.z, 0.0, 1.0), a, b, c));\n    \n    return min(Dist3, min(Dist1, Dist2));\n}                 \n\nvec2 Mouse()\n{\n    vec2 a = 2.0 *(iMouse.xy / iResolution.xy) - 1.0;\n    a.x *= iResolution.x / iResolution.y;\n    return a;\n    \n}\n\nvec3 Curves(vec2 uv)\n{\n    float t = iTime;\n    \n    float P = 0.0;\n    vec3 L = vec3(0.0);\n    \n    for (float i = 0.0; i < 15.; i++) {\n        vec2 p0 = vec2(sin(t*.6+i), cos(t*.6+i));\n        vec2 p2 = vec2(sin(t*.5+i-iTime), cos(t*.5+i+iTime));\n        \n        vec2 p = vec2(cos((t*.6+i)), sin((t*.6+i)));\n    \tfloat d1 = smoothstep(0.01, 0.00, DistanceQuadraticBezier(uv, p0, p2, p));\n        \n    \tL += d1 * vec3(1. , 1., 1.);\n    }\n    \n    return P + L;\n}   \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy;\n    vec2 q = 2.0*p - 1.0;\n    q = 0.5*q;\n    q.x *= iResolution.x / iResolution.y;   \n    \n    \n    p.x += 0.01*iTime;\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    //vec3 col = p.y*p.y*pal( p.x, vec3(0.408, 0.298 , 0.500), vec3(0.248, 0.358 , 0.248), vec3(0.800, 0.748, 0.500), vec3(3.14*sin(iTime*.1), 0.578, 0.500) );\n    \n    col = max(col, 0.7*Curves(q)*vec3(sin(iTime/4.0)+.2, cos(iTime/3.0)+.3, 0.3+cos(iTime/2.0)));\n       \n    col = sqrt(col) * .9;\n    //col = col * (1.0 - 0.2*dot(q,q));\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdffR2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdffWj", "name": "water shader", "author": "frankbatista", "description": "here is a water wavy noise", "tags": ["waterwavesnoise"], "likes": 10, "viewed": 353, "date": "1498017715", "time_retrieved": "2024-06-20T18:57:03.531399", "image_code": "float random(float x) {\n \n    return fract(sin(x) * 10000.);\n          \n}\n\nfloat noise(vec2 p) {\n\n    return random(p.x + p.y * 50000.);\n            \n}\n\nvec2 sw(vec2 p) { return vec2(floor(p.x), floor(p.y)); }\nvec2 se(vec2 p) { return vec2(ceil(p.x), floor(p.y)); }\nvec2 nw(vec2 p) { return vec2(floor(p.x), ceil(p.y)); }\nvec2 ne(vec2 p) { return vec2(ceil(p.x), ceil(p.y)); }\n\nfloat smoothNoise(vec2 p) {\n\n    vec2 interp = smoothstep(0., 1., fract(p));\n    float s = mix(noise(sw(p)), noise(se(p)), interp.x);\n    float n = mix(noise(nw(p)), noise(ne(p)), interp.x);\n    return mix(s, n, interp.y);\n        \n}\n\nfloat fractalNoise(vec2 p) {\n\n    float x = 0.;\n    x += smoothNoise(p      );\n    x += smoothNoise(p * 2. ) / 2.;\n    x += smoothNoise(p * 4. ) / 4.;\n    x += smoothNoise(p * 8. ) / 8.;\n    x += smoothNoise(p * 16.) / 16.;\n    x /= 1. + 1./2. + 1./4. + 1./8. + 1./16.;\n    return x;\n            \n}\n\nfloat movingNoise(vec2 p) {\n \n    float x = fractalNoise(p + iTime);\n    float y = fractalNoise(p - iTime);\n    return fractalNoise(p + vec2(x, y));   \n    \n}\n\n// call this for water noise function\nfloat nestedNoise(vec2 p) {\n    \n    float x = movingNoise(p);\n    float y = movingNoise(p + 100.);\n    return movingNoise(p + vec2(x, y));\n    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float n = nestedNoise(uv * 6.);\n    \n\tfragColor = vec4(mix(vec3(.4, .6, 1.), vec3(.1, .2, 1.), n), 0.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdffWj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdlBD7", "name": "everyday 024/100", "author": "kalin", "description": "everyday 024/100", "tags": ["everyday"], "likes": 0, "viewed": 71, "date": "1496553650", "time_retrieved": "2024-06-20T18:57:03.531399", "image_code": "float lined(vec2 p, vec2 pa, vec2 pb)\n{\n    return (p.x - pa.x) * (pb.y - pa.y) - (p.y - pa.y) * (pb.x - pa.x);\n}\n\nfloat trid(vec2 p, vec2 a, vec2 b, vec2 c)\n{\n    return \n        step(0.0, lined(p, a, b)) *\n        step(0.0, lined(p, b, c)) *\n        step(0.0, lined(p, c, a));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 nuv = uv * 2.0 - 1.0;\n    vec2 nnv = vec2(nuv.x * (iResolution.x / iResolution.y), nuv.y);\n    \n    float t = iTime;\n    float bpm = 1.0 / 60.0 * 97.2;\n    float pi = 3.1415926535;\n    \n    vec2 p = uv;\n    float rres = iResolution.x / iResolution.y;\n    \n    float rt0 = t * bpm * pi * (2.5 - 0.05 * pow(texture(iChannel0, vec2(0.0, 0.25)).x, 8.0));\n    float rt1 = t * bpm * pi * (0.5 - 0.05 * pow(texture(iChannel0, vec2(0.3, 0.25)).x, 4.0));\n    mat2 r0 = mat2(cos(rt0), -sin(rt0), sin(rt0), cos(rt0));\n    mat2 r1 = mat2(cos(rt1), -sin(rt1), sin(rt1), cos(rt1));\n    \n    vec2 tp0 = vec2(0.15, 0.5);\n    vec2 tp1 = vec2(0.35, 0.5);\n    \n    vec2 pa = vec2(-0.125 * rres, -0.20);\n    vec2 pb = vec2(-0.0 * rres, +0.20);\n    vec2 pc = vec2(+0.125 * rres, -0.20);\n    \n    vec2 rpa0 = (r0 * pa);\n    vec2 rpb0 = (r0 * pb);\n    vec2 rpc0 = (r0 * pc);\n    \n    rpa0.x /= rres;\n    rpb0.x /= rres;\n    rpc0.x /= rres;\n    \n    rpa0 += tp0 * vec2(rres, 1.0);\n    rpb0 += tp0 * vec2(rres, 1.0);\n    rpc0 += tp0 * vec2(rres, 1.0);\n        \n    vec2 rpa1 = (r1 * pa);\n    vec2 rpb1 = (r1 * pb);\n    vec2 rpc1 = (r1 * pc);\n    \n    rpa1.x /= rres;\n    rpb1.x /= rres;\n    rpc1.x /= rres;\n    \n    rpa1 += tp1 * vec2(rres, 1.0);\n    rpb1 += tp1 * vec2(rres, 1.0);\n    rpc1 += tp1 * vec2(rres, 1.0);\n    \n    float m0 = texture(iChannel0, vec2(0.0, 0.25)).x;\n    m0 = pow(m0, 8.0) * 2.0;\n    float m1 = texture(iChannel0, vec2(0.3, 0.25)).x;\n    m1 = pow(m1, 8.0) * 12.0;\n    \n    rpb1 += texture(iChannel1, vec2(uv.x * m0, uv.y)).x * 12.0;\n    rpb1 -= texture(iChannel1, vec2(uv.x * 12.0 * m0, uv.y)).x * 12.0;\n\n    float ct0 = step(0.001, trid(p, rpa0 + m0, rpb0 + m0, rpc0 + m0 * vec2(0.0, 1.0)));\n    float ct1 = step(0.001, trid(p, rpa1*1.1, rpb1*1.1, rpc1*1.1));\n    \n    fragColor.xyz = vec3(0.2);\n    \n    fragColor.y += ct0 * 0.3;\n    fragColor.z += ct1 * 0.4 + ct1 * m0 * 2.5;\n    fragColor.x *= texture(iChannel1, vec2(uv.x * ct0 * sin(t * 20.0), uv.y)).x * 12.0;\n    \n    fragColor.yz += vec2(m0 * fragColor.x, m1 * fragColor.x * uv.x * 20.0 * fragColor.x * sin(t * 120.0));\n}", "image_inputs": [{"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}, {"id": "4dfXDH", "previewfilepath": "https://soundcloud.com/sendaiofficial/sod-012", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/sendaiofficial/sod-012", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdlBD7.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdlBRX", "name": "32/100", "author": "yahe", "description": "ball", "tags": ["noise"], "likes": 1, "viewed": 385, "date": "1497250256", "time_retrieved": "2024-06-20T18:57:04.192138", "image_code": "// Learn about Duke's spikeball https://www.shadertoy.com/view/MljXDw\n// Basically it's his code, i just modified and learn\n\n#define SCATTERING\n\n#define pi 3.14159265\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n#define hsv(h,s,v) mix(vec3(1.), clamp((abs(fract(h+vec3(3., 2., 1.)/3.)*6.-3.)-1.), 0., 1.), s)*v\n\n// iq's noise\nfloat pn( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn -1.0*sin(iTime)+2.4*mix( rg.x, rg.y, f.z );\n}\n\n\nfloat fpn(vec3 p) {\n   return pn(p*.06125)*.5 + pn(p*.125)*.25 + pn(p*.25)*.125;\n}\n\n//vec3 n1 = vec3(1.000,0.000,0.000);\n//vec3 n2 = vec3(0.000,1.000,0.000);\n//vec3 n3 = vec3(0.000,0.000,1.000);\nvec3 n4 = vec3(0.577,0.577,0.577);\nvec3 n5 = vec3(-0.577,0.577,0.577);\nvec3 n6 = vec3(0.577,-0.577,0.577);\nvec3 n7 = vec3(0.577,0.577,-0.577);\nvec3 n8 = vec3(0.000,0.357,0.934);\nvec3 n9 = vec3(0.000,-0.357,0.934);\nvec3 n10 = vec3(0.934,0.000,0.357);\nvec3 n11 = vec3(-0.934,0.000,0.357);\nvec3 n12 = vec3(0.357,0.934,0.000);\nvec3 n13 = vec3(-0.357,0.934,0.000);\nvec3 n14 = vec3(0.000,0.851,0.526);\nvec3 n15 = vec3(0.000,-0.851,0.526);\nvec3 n16 = vec3(0.526,0.000,0.851);\nvec3 n17 = vec3(-0.526,0.000,0.851);\nvec3 n18 = vec3(0.851,0.526,0.000);\nvec3 n19 = vec3(-0.851,0.526,0.000);\n\nfloat spikeball(vec3 p) {\n    p.x += sin(iTime);\n    p.y += cos(iTime);\n   vec3 q=p;\n   p = normalize(p);\n   vec4 b = max(max(max(\n      abs(vec4(dot(p,n16), dot(p,n17),dot(p, n18), dot(p,n19))),\n      abs(vec4(dot(p,n12), dot(p,n13), dot(p, n14), dot(p,n15)))),\n      abs(vec4(dot(p,n8), dot(p,n9), dot(p, n10), dot(p,n11)))),\n      abs(vec4(dot(p,n4), dot(p,n5), dot(p, n6), dot(p,n7))));\n   b.xy = max(b.xy, b.zw);\n   b.x = pow(max(b.x, b.y), 140.);\n   return length(q)-2.5*pow(1.5,b.x*(1.-mix(.3, 1., 2.)*b.x));\n}\n\nfloat f(vec3 p) {\n   p.z += 6.;\n   R(p.xy, iTime);\n   R(p.xz, iTime);\n   return spikeball(p) + fpn(p*50.+iTime*15.) * 0.45;\n}\n\n/*\nvec3 g(vec3 p) {\n   vec2 e = vec2(.0001, .0);\n   return normalize(vec3(f(p+e.xyy) - f(p-e.xyy),f(p+e.yxy) - f(p-e.yxy),f(p+e.yyx) - f(p-e.yyx)));\n}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n   // p: position on the ray\n   // d: direction of the ray\n   vec3 p = vec3(0.,0.,2.);\n   vec3 d = vec3((gl_FragCoord.xy/(0.5*iResolution.xy)-1.)*vec2(iResolution.x/iResolution.y,1.0), 0.) - p;\n   d = normalize(d); \n   \n   // ld, td: local, total density \n   // w: weighting factor\n   float ld=0., td=0.;\n   float w=0.;\n   \n   // total color\n   vec3 tc = vec3(0.);\n   \n   // i: 0 <= i <= 1.\n   // r: length of the ray\n   // l: distance function\n   float r=0., l=0., b=0.;\n\n   // rm loop\n   for (float i=0.; (i<1.); i+=1./64.) {\n\t   if(!((i<1.) && (l>=0.001*r) && (r < 50.)&& (td < .95)))\n\t\t   break;\n      // evaluate distance function\n      l = f(p) * 0.5;\n      \n      // check whether we are close enough (step)\n      // compute local density and weighting factor \n      const float h = .05;\n      ld = (h - l) * step(l, h);\n      w = (1. - td) * ld;   \n     \n      // accumulate color and density\n      tc += w; // * hsv(w, 1., 1.); // * hsv(w*3.-0.5, 1.-w*20., 1.); \n      td += w;\n       \n      td += 1./200.;\n      \n      // enforce minimum stepsize\n      l = max(l, 0.03);\n      \n      // step forward\n      p += l*d;\n      r += l;\n   }  \n    \n   #ifdef SCATTERING\n   // simple scattering approximation\n   tc *= 1. / exp( ld * 0.4 ) * 1.25;\n   #endif\n      \n   fragColor = vec4(tc.x*.2, ld*2.5, .2, tc.x);\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdlBRX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdlBW2", "name": "Flash out", "author": "stas0", "description": "Flash out", "tags": ["flash"], "likes": 2, "viewed": 540, "date": "1498164841", "time_retrieved": "2024-06-20T18:57:04.192682", "image_code": "#define PI 3.14159;\n\nfloat circ(vec2 p) {\n\tfloat r = length(p);\n    r = sqrt(r);\n    \n    return abs(4. * r * fract(1. - iTime));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n   \tvec3 color = vec3(.0);\n    \n    float rz = abs(circ(uv));\n    \n    color = vec3(.2) / rz;\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdlBW2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdlBzX", "name": "Atlantis 2", "author": "dr2", "description": "Count the dolphins and use the mouse to look around.", "tags": ["voxel", "hexagon", "underwater", "dolphin"], "likes": 15, "viewed": 809, "date": "1497267055", "time_retrieved": "2024-06-20T18:57:04.211337", "image_code": "// \"Atlantis 2\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n Hexagonal prism voxel traversal and ruins derived from shaders by mattz and Shane.\n Count the dolphins and use the mouse to look around.\n*/\n\nfloat PrEllipsDf (vec3 p, vec3 r);\nvec2 Rot2D (vec2 q, float a);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define N_FISH 3\n#define SQRT3 1.73205\n\nvec3 fishPos[N_FISH], sunDir, cHit, cHitP, qnHit, qHit;\nfloat fishAngH[N_FISH], fishAngV[N_FISH], fishAngI, tCur, dstFar;\nint idObj;\nconst float htCell = 1.6;\nconst float gScale = 2.;\nconst vec3 cSize = vec3 (0.5 * SQRT3, 1., htCell);\nconst float pi = 3.14159;\n\nvec3 TrackPath (float t)\n{\n  return vec3 (5. * sin (0.08 * t) + 2. * sin (0.11 * t),\n     4. * sin (0.09 * t) + 0.8 * sin (0.13 * t), t);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec2 c, r, dr;\n  c = vec2 ((2. / SQRT3) * p.x, p.y);\n  r = floor (c);\n  r += mod (vec2 (r.x, r.y + step (2., mod (r.x + 1., 4.))), 2.);\n  dr = c - r;\n  r += step (1., 0.5 * dot (abs (dr), vec2 (SQRT3, 1.))) * sign (dr) * vec2 (2., 1.);\n  return r;\n}\n\nbool HexCellFull (vec3 p)\n{\n  float hs, hb;\n  p = (p * cSize).yzx / gScale;\n  p.xy -= TrackPath (p.z).xy;\n  hs = SmoothMin (length (p.xy * vec2 (1, 0.8)) - 4., 4. - p.y -\n    (0.5 - 8. * dot (sin (p * pi / 16. - cos (p.yzx * pi / 12.)), vec3 (1.))), 2.);\n  hs = min (- hs, max (abs (abs (p.x) - 4.) - 0.5, p.y + 3.));\n  hb = max (abs (p.x) - 3.5, p.y + 4.);\n  idObj = (hs > hb) ? 1 : 2; \n  return (min (hs, hb) < 0.);\n}\n\nfloat HexVolRay (vec3 ro, vec3 rd)\n{\n  vec3 ht, htt, w;\n  vec2 hv[3], ve;\n  float dHit, ty, dy;\n  ro *= gScale;\n  cHit = vec3 (PixToHex (ro.zx), floor (ro.y / htCell + 0.5));\n  hv[0] = vec2 (0., 1.);\n  hv[1] = vec2 (1., 0.5);\n  hv[2] = vec2 (1., -0.5);\n  for (int k = 0; k < 3; k ++)\n     hv[k] *= sign (dot (hv[k], vec2 (0.5 * SQRT3 * rd.z, rd.x)));\n  dy = sign (rd.y);\n  qnHit = vec3 (0.);\n  dHit = dstFar * gScale + 0.01;\n  for (int j = 0; j < 220; j ++) {\n    w = ro - (cHit * cSize).yzx;\n    ht.z = 1e6;\n    for (int k = 0; k < 3; k ++) {\n      ve = vec2 (0.5 * SQRT3 * hv[k].x, hv[k].y);\n      htt = vec3 (hv[k], (1. - dot (ve, w.zx)) / dot (ve, rd.zx));\n      if (htt.z < ht.z) ht = htt;\n    }\n    ty = (0.5 * dy * htCell - w.y) / rd.y;\n    cHitP = cHit;\n    if (ht.z < ty) cHit.xy += 2. * ht.xy;\n    else cHit.z += dy;\n    if (HexCellFull (cHit)) {\n      if (ht.z < ty) {\n        qnHit = - vec3 (0.5 * SQRT3 * ht.x, ht.y, 0.);\n        dHit = ht.z;\n      } else {\n        qnHit = - vec3 (0., 0., dy);\n        dHit = ty;\n      }\n      break;\n    }\n  }\n  return dHit / gScale;\n}\n\nfloat HexFaceDist (vec3 p)\n{\n  vec4 h[4];\n  vec3 cNeb, vh;\n  float d;\n  p = p.zxy * gScale - cHitP * cSize;\n  p.z *= 2. / htCell;\n  h[0] = vec4 (0., 1., 0., 1.);\n  h[1] = vec4 (1., 0.5, 0., 1.);\n  h[2] = vec4 (1., -0.5, 0., 1.);\n  h[3] = vec4 (0., 0., 0.5, 0.5 * htCell);\n  d = 1e6;\n  for (int k = 0; k < 4; k ++) {\n    vh = h[k].xyz;\n    cNeb = cHitP + 2. * vh;\n    if (cNeb != cHit && HexCellFull (cNeb))\n\td = min (d, h[k].w - dot (vh * cSize, p));\n    cNeb = cHitP - 2. * vh;\n    if (cNeb != cHit && HexCellFull (cNeb))\n\td = min (d, h[k].w + dot (vh * cSize, p));\n  }\n  return d;\n}\n\nfloat EdgeDist (vec3 p)\n{\n  vec2 dh;\n  float d;\n  p *= gScale;\n  dh = p.zx - cHit.xy * vec2 (0.5 * SQRT3, 1.);\n  if (qnHit.z == 0.) {\n    d = abs (fract (p.y / htCell) - 0.5) * htCell;\n    dh -= qnHit.xy * dot (dh, qnHit.xy);\n    d = min (d, abs (length (dh) - 1. / SQRT3));\n  } else {\n    dh = abs (dh);\n    d = max (0.5 * dot (dh, vec2 (SQRT3, 1.)), dh.y) - 1.;\n  }\n  return d;\n}\n\nvec3 HexVolCol (vec3 p, float edgDist, float dHit)\n{\n  vec3 col;\n  col = (idObj == 1) ? vec3 (0.5, 0.75, 0.8) : vec3 (0.6, 0.8, 0.9);\n  col = mix (col, vec3 (0.25, 0.4, 1.), 0.7 * smoothstep (0., 1., 5. * dHit / dstFar));\n  col *= 0.5 + 0.5 * smoothstep (0., 0.05, abs (edgDist));\n  if (qnHit.z != 0.) col *= 0.7 + 0.3 * smoothstep (0., 0.7, abs (edgDist));\n  col *= (1.5 - 0.5 * smoothstep (0., 0.06 * sqrt (dHit), abs (edgDist) - 0.03)) *\n     (0.3 + 0.7 * smoothstep (0., 0.03 * sqrt (dHit), abs (edgDist) - 0.01));\n  return col;\n}\n\nfloat WatShd (vec3 rd)\n{\n  vec2 p;\n  float t, h;\n  p = 10. * rd.xz / rd.y;\n  t = tCur * 2.;\n  h = sin (p.x * 2. + t * 0.77 + sin (p.y * 0.73 - t)) +\n     sin (p.y * 0.81 - t * 0.89 + sin (p.x * 0.33 + t * 0.34)) +\n     (sin (p.x * 1.43 - t) + sin (p.y * 0.63 + t)) * 0.5;\n  h *= smoothstep (0.5, 1., rd.y) * 0.04;\n  return h;\n}\n\nfloat FishDf (vec3 p)\n{\n  vec3 q;\n  float dMin, dBodyF, dBodyB, dMouth, dFinT, dFinP, dFinD, dEye, d;\n  p.x = abs (p.x);\n  p.z -= 2.;\n  p.yz = Rot2D (p.yz, 0.2 * fishAngI);\n  q = p;\n  q.z -= -0.6;\n  dBodyF = PrEllipsDf (q, vec3 (0.7, 0.8, 2.4));\n  q = p;\n  q.z -= -1.2;\n  q.yz = Rot2D (q.yz, fishAngI);\n  q.z -= -1.6;\n  dBodyB = PrEllipsDf (q, vec3 (0.35, 0.5, 2.5));\n  q.z -= -2.2;\n  q.yz = Rot2D (q.yz, 2. * fishAngI);\n  q.xz -= vec2 (0.5, -0.5);\n  q.xz = Rot2D (q.xz, 0.4);\n  dFinT = PrEllipsDf (q, vec3 (0.8, 0.07, 0.4));\n  q = p;\n  q.yz -= vec2 (-0.3, 1.7);\n  q.yz = Rot2D (q.yz, 0.1);\n  q.y = abs (q.y) - 0.04;\n  dMouth = PrEllipsDf (q, vec3 (0.25, 0.12, 0.6));\n  q = p;\n  q.yz -= vec2 (0.7, -1.);\n  q.yz = Rot2D (q.yz, 0.6);\n  dFinD = PrEllipsDf (q, vec3 (0.05, 1., 0.35));\n  q = p;\n  q.xy = Rot2D (q.xy, 0.8);\n  q.xz -= vec2 (0.7, -0.1);\n  q.xz = Rot2D (q.xz, 0.6);\n  dFinP = PrEllipsDf (q, vec3 (0.9, 0.04, 0.3));\n  q = p;\n  q -= vec3 (0.4, -0.1, 1.1);\n  dEye = PrEllipsDf (q, vec3 (0.11, 0.15, 0.15));\n  idObj = 11;\n  dMin = SmoothMin (dBodyF, dBodyB, 0.3);\n  dMin = SmoothMin (dMin, dFinT, 0.1);\n  dMin = SmoothMin (dMin, dMouth, 0.15);\n  dMin = SmoothMin (dMin, dFinD, 0.02);\n  dMin = SmoothMin (dMin, dFinP, 0.02);\n  if (dEye < dMin) idObj = 12;\n  dMin = SmoothMin (dMin, dEye, 0.01);\n  qHit = q;\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, qHitA;\n  float dMin, d, szFac;\n  int idObjA;\n  szFac = 2.;\n  dMin = dstFar * szFac;\n  for (int k = 0; k < N_FISH; k ++) {\n    q = (p - fishPos[k]) * szFac;\n    q.xz = Rot2D (q.xz, fishAngH[k]);\n    q.yz = Rot2D (q.yz, fishAngV[k]);\n    d = FishDf (q);\n    if (d < dMin) {\n      idObjA = idObj;\n      qHitA = qHit;\n      dMin = d;\n    }\n  }\n  idObj = idObjA;\n  qHit = qHitA;\n  return dMin / szFac;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + rd * dHit);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 1.;\n  for (int j = 0; j < 30; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += 0.08 * (1. + 0.1 * d);\n    if (sh < 0.05) break;\n  }\n  return 0.4 + 0.6 * sh;\n}\n\nvec3 BgCol (vec3 rd)\n{\n  float t, gd, b;\n  t = 4. * tCur;\n  b = dot (vec2 (atan (rd.x, rd.z), 0.5 * pi - acos (rd.y)), vec2 (2., sin (rd.x)));\n  gd = (clamp (sin (5. * b + t), 0., 1.) * clamp (sin (3.5 * b - t), 0., 1.) +\n     clamp (sin (21. * b - t), 0., 1.) * clamp (sin (17. * b + t), 0., 1.)) *\n     (1. - smoothstep (0.4, 0.6, rd.y));\n  return 0.8 * vec3 (0.2, 0.7, 1.) * (0.24 + 0.44 * (rd.y + 1.) * (rd.y + 1.)) *\n     (1. + 0.06 * gd);\n}\n\nfloat TurbLt (vec3 p, vec3 n, float t)\n{\n  vec2 q, qq, a1, a2;\n  float c, tt;\n  q = vec2 (dot (p.yzx, n), dot (p.zxy, n));\n  q = 2. * pi * mod (q, 1.) - 256.;\n  t += 11.;\n  c = 0.;\n  qq = q;\n  for (float k = 1.; k <= 7.; k ++) {\n    tt = t * (1. + 1. / k);\n    a1 = tt - qq;\n    a2 = tt + qq;\n    qq = q + tt + vec2 (cos (a1.x) + sin (a2.y), sin (a1.y) + cos (a2.x));\n    c += 1. / length (q / vec2 (sin (qq.x), cos (qq.y)));\n  }\n  return clamp (pow (abs (1.25 - abs (0.167 + 40. * c)), 8.), 0., 1.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, bgCol, vn;\n  float dstObj, dHit, dEdge, sh, diff, h;\n  int idObjH;\n  dHit = HexVolRay (ro, rd);\n  idObjH = idObj;\n  dstObj = ObjRay (ro, rd);\n  bgCol = BgCol (rd);\n  col = bgCol;\n  if (min (dstObj, dHit) < dstFar) {\n    if (dstObj < dHit) {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      if (idObj == 11) col = vec3 (0.7, 0.7, 0.75) *\n         (1. - 0.4 * smoothstep (-0.5, -0.4, vn.y));\n      else if (idObj == 12) col = vec3 (0.5, 1., 0.5) *\n         step (0.05, length (qHit.yz - vec2 (-0.02, 0.05)));\n      col = col * (0.2 + 0.8 * max (dot (vn, sunDir), 0.)) +\n         0.2 * pow (max (dot (normalize (sunDir - rd), vn), 0.), 64.);\n      dHit = dstObj;\n    } else {\n      ro += rd * dHit;\n      vn = qnHit.yzx;\n      dEdge = EdgeDist (ro);\n      h = smoothstep (0., 0.3, HexFaceDist (ro));\n      vn = VaryNf (20. * ro, vn, 2. * h * step (0., abs (dEdge) - 0.02) *\n        (1. - smoothstep (10., 15., dHit)));\n      col = HexVolCol (ro, dEdge, dHit) * (0.5 + 0.5 * h);\n      diff = clamp (dot (sunDir, vn), 0., 1.);\n      sh = (diff > 0. && HexVolRay (ro + 0.001 * vn, sunDir) < dstFar) ? 0.6 : 1.;\n      if (idObjH == 1) sh = min (sh, ObjSShadow (ro, sunDir));\n      col = col * (0.2 + 0.8 * sh * diff) + 0.2 * sh * step (0., diff) *\n         pow (max (dot (normalize (sunDir - rd), vn), 0.), 128.);        \n      col += 0.3 * TurbLt (0.3 * ro, abs (vn), 0.3 * tCur) *\n         smoothstep (-0.3, -0.1, vn.y);\n    }\n    col = mix (col, bgCol, smoothstep (0.2, 0.85, dHit / dstFar));\n  } else col = bgCol + WatShd (rd);\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, fpF, fpB, vd;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, zmFac, vMov, vFish, tGap, t, a;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  if (mPtr.z > 0.) {\n    az = 2. * pi * mPtr.x;\n    el = 0.95 * pi * mPtr.y;\n  } else {\n    t = mod (floor (0.05 * tCur), 4.);\n    a = pi * SmoothBump (0.75, 0.95, 0.05, mod (0.05 * tCur, 1.));\n    if (t < 2.) el = (2. * t - 1.) * 0.45 * a;\n    else az = (2. * t - 5.) * a;\n  }\n  dstFar = 50.;\n  zmFac = 1.5;\n  vMov = 2.;\n  fpF = TrackPath (vMov * tCur + 0.5);\n  fpB = TrackPath (vMov * tCur - 0.5);\n  ro = 0.5 * (fpF + fpB);\n  ro.y += 0.5;\n  vd = fpF - fpB;\n  t = length (vd);\n  if (t > 0.) vd = normalize (vd);\n  ori = vec2 (el + sin (vd.y), az + ((t > 0.) ? atan (vd.x, vd.z) : 0.5 * pi));\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  vFish = 2.;\n  tGap = 2. * dstFar / (float (N_FISH) * vFish);\n  for (int k = 0; k < N_FISH; k ++) {\n    t = tGap * ((float (k) + floor (ro.z / (tGap * vFish) + 0.5)) -\n       mod (tCur / tGap, 1.));\n    fpF = TrackPath (t * vFish + 0.5);\n    fpB = TrackPath (t * vFish - 0.5);\n    fishPos[k] = 0.5 * (fpF + fpB);\n    fishPos[k].y -= 1.;\n    vd = fpF - fpB;\n    t = length (vd);\n    if (t > 0.) vd = normalize (vd);\n    fishAngH[k] = pi + ((t > 0.) ? atan (vd.x, vd.z) : 0.5 * pi);\n    fishAngH[k] += 0.1 * pi * sin (0.1 * pi * tCur) * sign (fishAngH[k]);\n    fishAngV[k] = - sin (vd.y);\n  }\n  fishAngI = 0.1 * sin (pi * tCur);\n  uv += 2. * sin (2. * pi * (5. * uv + 0.5 * sin (0.4 * pi * tCur))) / canvas.y;\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  sunDir = normalize (vec3 (cos (0.002 * pi * tCur), 2., sin (0.002 * pi * tCur)));\n  fragColor = vec4 (pow (clamp (ShowScene (ro, rd), 0., 1.), vec3 (0.8)), 1.);\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, cHashA3.xy)) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  const vec3 e = vec3 (0.1, 0., 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) -\n     Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdlBzX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdlfDX", "name": "HSV bend", "author": "MadcoreTom", "description": "darker colours are less saturated, and more blue.\nI'm not happy with how it pops when looping past red;", "tags": ["color", "hsv", "colour"], "likes": 3, "viewed": 90, "date": "1498534399", "time_retrieved": "2024-06-20T18:57:04.211337", "image_code": "// from https://gist.github.com/eieio/4109795\nvec4 hsv_to_rgb(float h, float s, float v, float a)\n{\n\tfloat c = v * s;\n\th = mod((h * 6.0), 6.0);\n\tfloat x = c * (1.0 - abs(mod(h, 2.0) - 1.0));\n\tvec4 color;\n\n\tif (0.0 <= h && h < 1.0) {\n\t\tcolor = vec4(c, x, 0.0, a);\n\t} else if (1.0 <= h && h < 2.0) {\n\t\tcolor = vec4(x, c, 0.0, a);\n\t} else if (2.0 <= h && h < 3.0) {\n\t\tcolor = vec4(0.0, c, x, a);\n\t} else if (3.0 <= h && h < 4.0) {\n\t\tcolor = vec4(0.0, x, c, a);\n\t} else if (4.0 <= h && h < 5.0) {\n\t\tcolor = vec4(x, 0.0, c, a);\n\t} else if (5.0 <= h && h < 6.0) {\n\t\tcolor = vec4(c, 0.0, x, a);\n\t} else {\n\t\tcolor = vec4(0.0, 0.0, 0.0, a);\n\t}\n\n\tcolor.rgb += v - c;\n\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float h = 0.0 + iTime/10.0;\n    float s = 0.5;\n    float v = 0.5;\n    s = max((1.0 - uv.x * 0.7) - 1.0 + uv.y,0.0);\n    v = 1.0 - uv.x;\n    h = (0.6 * uv.x*0.2) + (mod(h,1.0) * (1.0-uv.x*0.2));\n\tfragColor = vec4(hsv_to_rgb(h, s, v, 1.0f));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdlfDX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdlfWf", "name": "all seeing structure", "author": "public_int_i", "description": "all seeing structure, use mouse to look", "tags": ["3d", "raymarch", "all", "structure", "seeing"], "likes": 1, "viewed": 410, "date": "1498563213", "time_retrieved": "2024-06-20T18:57:04.212335", "image_code": "//Ethan Alexander Shulman 2017\n\n\nstruct mat {\n    vec3 diffuse, specular;\n    float metallic, roughness;\n};\n    \nmat2 rot2d(float a){\n    return mat2(sin(a),cos(a),-cos(a),sin(a));   \n}\nfloat hash(vec2 p) {\n    return fract(dot(p+vec2(.36834,.723), normalize(fract(p.yx*73.91374)+1e-4))*7.38734);\n}\nfloat voronoi_dither(vec2 u) {\n    #define l(i) length(fract(u*.7+fract(i*vec2(1,8))+cos(u.yx*.2333+i*8.))-.5)\n\treturn min(l(.1),l(.6))*2.66-1.;\n}\n\n//scene distance function\nfloat df(vec3 p) {\n    float d = length(abs(p)-2.)-2.;\n    return max(abs(length(p)-4.)-1., d);\n}\n//scene distance function used for normal calculation(put normal mapping/displacements here)\nfloat dfNormal(vec3 p) {\n    return df(p);\n}\n//returns normalized gradient at position p\nvec3 normal(vec3 p) {\n     const vec2 NE = vec2(1e-3, 0.);\n     return normalize(dfNormal(p)-vec3(dfNormal(p-NE.xyy), \n                      \t\t\tdfNormal(p-NE.yxy), \n                      \t\t\tdfNormal(p-NE.yyx)));\n}\n\n\n#define join(d,c) s.xyz = mix(s.xyz,c,clamp((s.w-d)/s.w,0.,1.)); if (d < s.w) s.w = d;\n\n//distance must be >= 0\n//scene emissive(xyz) & distance(w) function, w parameter in 'p' is the mipmap to use level\nvec4 scene(vec4 p) {\n    //structure\n    float d = max(0.,df(p.xyz));\n    vec4 s = vec4(0.014, 0.014, 0.014+mix(length(tan(p.yzx*16.))*.01,1.,min(1.,p.w))*max(0.,4.-length(p)), d);\n    \n    return s;\n}\n                  \n//scene material at position p\nmat material(vec3 p) {\n    //sphere\n    return mat(vec3(.5), vec3(1.), 0., .45);\n}\n\n//background function, returns color from direction d.xyz and mipmap/blur level d.w\nvec3 background(vec4 d) {\n    return textureLod(iChannel0, vec2(atan(d.x,d.z)/3.14+0.5, d.y*.5+.5), d.w).xxx;\n}\n\n\n//ray-trace(march) scene, returns distance to hit or -1 if nothing hit\nfloat trace(vec3 rp, vec3 rd, float epsilon) {\n    float s = 0.;\n    for (int i = 0; i < 48; i++) {        \n        float dst = df(rp+rd*s);\n        if (dst < epsilon) return s;\n        s += dst;\n        if (s > 1e4) return -1.;\n    }\n    return -1.;\n}\n\n\n//blurry trace scene, returns color\nvec3 blurTrace(vec3 pos, vec3 dir, float blur) {\n    vec4 rp = vec4(pos,1.),\n         rd = vec4(dir,blur);\n    float istep = .15+hash(dir.xy*512.+dir.zz*2048.)*.15,\n        bm = abs(dot(dir,normal(pos)));\n    \n    vec4 c = vec4(0.);\n    float d = 1e-4;\n    for (int i = 1; i < 16; i++) {\n        if (c.w >= 1.) break;\n        \n        vec4 s = scene(rp+rd*d);\n        s.w = max(s.w, blur);\n        float ba = bm*d*blur;\n        c += vec4(s.xyz,1.)*(max(0., 1.-s.w/ba)/ba);\n        d += mix(s.w, float(i)*istep, min(1.,blur));\n    }\n\t\n    \n    return mix(background(vec4(dir,blur*10.)),c.xyz/max(1e-4,c.w),min(c.w,1.));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //ray-march screen ray\n    vec3 rp = vec3(0.,cos(iTime*.08-2.)*6.,-4.+sin(iTime*.08-2.)*4.),\n         rd = vec3(normalize(vec3((fragCoord*2.-iResolution.xy)/iResolution.x,.5)));\n    \n    if (iMouse.w < 1.) {\n    \trd = vec3(normalize(vec3((fragCoord*2.-iResolution.xy)/iResolution.x,.5)));\n    } else {\n        vec2 lookEuAng = (iMouse.xy/iResolution.xy)*6.28;\n        rd.zy *= rot2d(lookEuAng.y);\n        rd.xz *= rot2d(-lookEuAng.x);\n    }\n  \n   \t\n    float epsilon = 2e-2+voronoi_dither(fragCoord+128.)*1e-2;//dither epsilon\n    float s = trace(rp,rd,epsilon);\n    \n    vec3 c;\n    if (s < 0.) {\n        //nothing hit, background\n        c = background(vec4(rd,0.));\n    } else {\n        //shade object\n        vec3 hp = rp+rd*s,\n            hn = normal(hp),\n            ref = reflect(rd, hn);\n        mat m = material(hp);\n\n        c = scene(vec4(hp,0.)).xyz+ //emissive\n                         m.diffuse*blurTrace(hp,hn,1.)*(.5-m.metallic*.5)+ //diffuse\n                         m.specular*blurTrace(hp,ref,m.roughness)*(1.-max(0.,dot(-rd,ref))*(1.-m.metallic))*(.5+m.metallic*.5); //specular\n    }\n\n\tfragColor = vec4(floor(c*32.99+voronoi_dither(fragCoord))/32.,1.);//dither\n}", "image_inputs": [{"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdlfWf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdsfD2", "name": "Dodecahedral Duckohedron", "author": "dr2", "description": "Again, just one duck (same maximal symmetry as before),  with inflationary issue", "tags": ["dodecahedron", "duck", "ducksymmetry"], "likes": 7, "viewed": 444, "date": "1498225837", "time_retrieved": "2024-06-20T18:57:04.223074", "image_code": "// \"Dodecahedral Duckohedron\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrEllipsDf (vec3 p, vec3 r);\nfloat PrEllCylDf (vec3 p, vec2 r, float h);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat SmoothMin (float a, float b, float r);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\n\nvec3 ltDir, qHit;\nfloat dstFar, tCur, szFac, dRot;\nint idObj;\nconst int idBdy = 1, idWng = 2, idHead = 3, idBk = 4, idPol = 5;\nconst float pi = 3.14159;\n\nvec3 DodecSym (vec3 p)\n{\n  const float dihedDodec = 0.5 * atan (2.);\n  float a, w;\n  w = 2. * pi / 5.;\n  p.z = abs (p.z);\n  p.xz = Rot2D (p.xz, dihedDodec);\n  p.xy = Rot2D (p.xy, - 0.25 * w);\n  p.x = - abs (p.x);\n  for (int k = 0; k < 4; k ++) {\n    p.zy = Rot2D (p.zy, - dihedDodec);\n    p.y = - abs (p.y);\n    p.zy = Rot2D (p.zy, dihedDodec);\n    if (k < 3) p.xy = Rot2D (p.xy, - w);\n  }\n  p.z = - p.z;\n  a = mod (atan (p.x, p.y) + 0.5 * w, w) - 0.5 * w;\n  p.yx = vec2 (cos (a), sin (a)) * length (p.xy);\n  p.x -= 2. * p.x * step (0., p.x);\n  return p;\n}\n\nfloat DukDf (vec3 p)\n{\n  vec3 q;\n  vec2 r, cs;\n  float dMin, d, h, s;\n  dMin = dstFar / szFac;\n  p /= szFac;\n  q = p;\n  r = vec2 (0.04, 0.06 + 0.01 * clamp (q.z, -0.4, 0.4));\n  h = 0.1;\n  s = (length (q.xz / r) - 1.) * min (r.x, r.y);\n  d = min (max (s, abs (q.y) - h), length (vec2 (s, q.y)) - h);\n  if (d < dMin) { dMin = d;  idObj = idBdy;  qHit = q; }\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.1, 0.06, 0.12);\n  cs = vec2 (cos (0.3), sin (0.3));\n  q.yz = Rot2Cs (q.yz, cs);\n  cs.y = - cs.y;\n  q.xy = Rot2Cs (q.xy, cs);\n  q.xz = Rot2Cs (q.xz, cs);\n  q = q.yxz;\n  r = vec2 (0.06, 0.1 + 0.016 * clamp (q.z, -0.4, 0.4));\n  h = 0.014;\n  s = (length (q.xz / r) - 1.) * min (r.x, r.y);\n  d = min (max (s, abs (q.y) - h), length (vec2 (s, q.y)) - h);\n  d = SmoothMin (d, dMin, 0.01);\n  if (d < dMin) { dMin = d;  idObj = idWng;  qHit = q; }\n  q = p;\n  q.yz -= vec2 (0.15, -0.08);\n  d = PrEllipsDf (q, vec3 (0.08, 0.07, 0.1));\n  d = SmoothMin (d, dMin, 0.02);\n  if (d < dMin) { dMin = d;  idObj = idHead;  qHit = q; }\n  q = p;\n  q.yz -= vec2 (0.14, -0.19);\n  r = vec2 (0.03, 0.008);\n  h = 0.02;\n  d = max (PrEllCylDf (q, r, h), - PrEllCylDf (q - vec3 (0., 0., h),\n     r - 0.004, 2. * h));\n  if (d < dMin) { dMin = d;  idObj = idBk;  qHit = q; }\n  return 0.9 * dMin * szFac;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 pDod, q;\n  float dMin, d;\n  pDod = DodecSym (p);\n  q = pDod + vec3 (0.3, -1., 2.25);\n  q.xy = Rot2D (q.xy, dRot);\n  dMin = DukDf (- q.xzy);\n  d = - SmoothMin (0.05 - abs (pDod.z + 2.1), min (1.24 - pDod.y,\n     -0.05 + pDod.x + 0.72 * pDod.y), 0.02);\n  if (d < dMin) { dMin = d;  idObj = idPol;  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = ObjDf (ro + rd * dHit);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec3 e = vec3 (0.0001, -0.0001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = 0; j < 30; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += 0.03;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 ObjCol ()\n{\n  vec3 col, cBdy;\n  float s;\n  cBdy = vec3 (1., 0.2, 0.2);\n  if (idObj == idBdy) {\n    col = cBdy * (1. - smoothstep (0.02, 0.06, qHit.y) *\n       smoothstep (0., 0.14, qHit.z) * 0.1 * SmoothBump (0.3, 0.5, 0.05,\n       mod (50. * qHit.x, 1.)));\n  } else if (idObj == idWng) {\n    col = cBdy * (1. - step (0.004, qHit.y) *\n       smoothstep (0., 0.04, qHit.z) * 0.2 * SmoothBump (0.3, 0.5, 0.05,\n       mod (100. * qHit.x, 1.)));\n  } else if (idObj == idHead) {\n    s = length (qHit.yz - vec2 (0.02, -0.05));\n    if (s > 0.02) col = cBdy;\n    else col = (abs (s - 0.01) < 0.003) ? vec3 (1., 1., 1.) : vec3 (0.3, 0.3, 1.);\n  } else if (idObj == idBk) col = vec3 (0.5, 0.5, 1.);\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 vn, col;\n  float dstObj, vDotL, sh;\n  dRot = -0.5 * tCur;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += rd * dstObj;\n    vn = ObjNf (ro);\n    if (idObj != idPol) col = ObjCol ();\n    else col = (dot (ro, vn) < 0.) ? vec3 (1., 1., 0.3) : vec3 (0.5, 1., 0.);\n    vDotL = dot (ltDir, vn);\n    sh = ObjSShadow (ro, ltDir);\n    col = col * (0.1 + 0.1 * max (- vDotL, 0.) + 0.8 * sh * max (vDotL, 0.)) +\n       0.3 * sh * pow (max (dot (normalize (ltDir - rd), vn), 0.), 256.);\n  } else col = vec3 (0., 0., 0.1);\n  return pow (clamp (col, 0., 1.), vec3 (0.8));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float az, el;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  if (mPtr.z > 0.) {\n    az = 3. * pi * mPtr.x;\n    el = -0.1 * pi + pi * mPtr.y;\n  } else {\n    az = 0.03 * pi * tCur;\n    el = 0.1 * pi * sin (0.05 * pi * tCur);\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  szFac = 1. + 7. * SmoothBump (0.2, 0.7, 0.15, mod (0.05 * tCur, 1.));\n  rd = vuMat * normalize (vec3 (uv, 3.));\n  ro = vuMat * vec3 (0., 0., -8. - szFac);\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n  dstFar = 20.;\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nfloat PrEllCylDf (vec3 p, vec2 r, float h)\n{\n  return max ((length (p.xy / r) - 1.) * min (r.x, r.y), abs (p.z) - h);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdsfD2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdsfDS", "name": "ray v plane/billboard testing", "author": "public_int_i", "description": "ray v plane/billboard testing", "tags": ["ray", "testing", "plane", "billboard", "v"], "likes": 1, "viewed": 549, "date": "1498046840", "time_retrieved": "2024-06-20T18:57:04.707321", "image_code": "\n#define MAX_DISTANCE 1e5\n#define PI 3.14\n\n//returns distance to triangle or MAX_DISTANCE if triangle wasn't hit and outputs uv\nfloat rayTriangle(vec3 rayPos, vec3 rayDir, vec3 p1, vec3 p2, vec3 p3, out vec2 uv) {\n    const float EPSILON = 1e-5;\n    vec3 edge1 = p2-p1,\n        edge2 = p3-p1,\n        pdir = cross(rayDir,edge2);\n    float a = dot(edge1,pdir);\n    if (a > -EPSILON && a < EPSILON) return MAX_DISTANCE;\n    \n    float f = 1./a;\n    vec3 s = rayPos-p1;\n    float u = f*dot(s,pdir);\n    if (u < 0. || u > 1.) return MAX_DISTANCE;\n    \n    s = cross(s,edge1);\n    float v = f*dot(rayDir,s);\n    if (v < 0. || u+v > 1.) return MAX_DISTANCE;\n    \n    float dst = f*dot(edge2,s);\n    if (dst < EPSILON) dst = MAX_DISTANCE;\n    \n    uv = vec2(u,v);\n    return dst;\n}\n\n//returns distance to plane or MAX_DISTANCE if plane wasn't hit and outputs uv\nfloat rayPlane(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeDir, vec3 planeRight, vec3 planeUp, vec2 planeSize, out vec2 uv) {\n    float dst = dot(planePos-rayPos, planeDir)/dot(rayDir,planeDir);\n    \n    if (dst < 0.) {\n        dst = MAX_DISTANCE;\n    } else {\n        vec3 hp = (rayPos+rayDir*dst)-planePos;\n        uv = vec2(dot(hp,planeRight),dot(hp,planeUp))/planeSize*0.5+0.5;\n        if (uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1.) dst = MAX_DISTANCE;\n    }\n\n\treturn dst;\n}\n\n//return distance to billboard or MAX_DISTANCE if billboard wasn't hit and outputs uv\nfloat rayBillboard(vec3 rayPos, vec3 rayDir, vec3 billboardPos, vec2 billboardSize, out vec2 uv) {\n    vec3 dvec = billboardPos-rayPos;\n    float dst = dot(dvec, rayDir);\n    \n    if (dst < 0.) {\n        dst = MAX_DISTANCE;\n    } else {\n    \t//uv through reprojection\n\t\tvec2 screenUv = (rayPos+rayDir*dst).xy,\n             screenPos = billboardPos.xy;\n\n        uv = screenUv;\n        uv = (screenUv-screenPos)/(billboardSize/length(dvec))*.5+.5;\n        if (uv.x < 0. || uv.x > 1. || uv.y < 0. || uv.y > 1.) dst = MAX_DISTANCE;\n    }\n        \n    return dst;\n}\n\n\nvoid mainImage( out vec4 o, in vec2 u)\n{\n   \tvec3 rp = vec3(0.,0.,-30.),\n         rd = normalize(vec3((u*2.-iResolution.xy)/iResolution.x, 1.));\n    \n    vec2 planeUv, billboardUv;\n    vec3 planeDir = vec3(sin(iTime), 0., cos(iTime));\n    float dst = rayPlane(rp, rd, vec3(0.), \n                              planeDir, \n                              vec3(sin(iTime+PI*.5),0.,cos(iTime+PI*.5)), \n                              vec3(0.,1.,0.),\n                              vec2(1.,8.), planeUv);  \n\n\tfloat bdst = rayBillboard(rp, rd, planeDir*15., vec2(20.,10.), billboardUv);\n    if (bdst < dst) {\n        planeUv = billboardUv;\n        dst = bdst;\n    }\n    \n    \n    if (dst < MAX_DISTANCE) {\n    \to = vec4(planeUv, 0., 1.);\n    } else {\n        o = vec4(0.);   \n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdsfDS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdsfW2", "name": "Generative Bismuth Crystal", "author": "amagitakayosi", "description": "It was so difficult to me... I'll write a blog post here: https://fand.github.io/webgl-study/?id=46", "tags": ["raymarching"], "likes": 19, "viewed": 1996, "date": "1498179399", "time_retrieved": "2024-06-20T18:57:05.828624", "image_code": "// Author : @amagitakayosi\n\nprecision mediump float;\nuniform float time;\nuniform vec2  mouse;\nuniform vec2  resolution;\n\nconst float PI = 3.1415926535897932384626433;\nconst int LOOP = 90;\nconst int INNER_LOOP = 5;\n\nvec2 squareFrame(vec2 screenSize) {\n  vec2 position = 2.0 * (gl_FragCoord.xy / screenSize.xy) - 1.0;\n  position.x *= screenSize.x / screenSize.y;\n  return position;\n}\n\nmat3 calcLookAtMatrix(vec3 origin, vec3 target, float roll) {\n  vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n  vec3 ww = normalize(target - origin);\n  vec3 uu = normalize(cross(ww, rr));\n  vec3 vv = normalize(cross(uu, ww));\n\n  return mat3(uu, vv, ww);\n}\n\nvec3 getRay(vec3 origin, vec3 target, vec2 screenPos, float lensLength) {\n  mat3 camMat = calcLookAtMatrix(origin, target, 0.0);\n  return normalize(camMat * vec3(screenPos, lensLength));\t\n}\n\nvec2 map(vec3 p);\n\nvec2 calcRayIntersection(vec3 rayOrigin, vec3 rayDir, float maxd, float precis, float reduction) {\n  float latest = precis * 2.0;\n  float dist   = +0.0;\n  float type   = -1.0;\n  vec2  res    = vec2(-1.0, -1.0);\n\n  for (int i = 0; i < LOOP; i++) {\n    if (latest < precis || dist > maxd) break;\n\n    vec2 result = map(rayOrigin + rayDir * dist);\n\n    latest = result.x;\n    type   = result.y;\n    dist  += latest * reduction;\n  }\n\n  if (dist < maxd) {\n    res = vec2(dist, type);\n  }\n\n  return res;\n}\n\nvec3 calcNormal(vec3 pos) {\n  float eps = 0.1;\n  const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n  const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n  const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n  const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n  return normalize( v1 * map( pos + v1*eps ).x +\n                    v2 * map( pos + v2*eps ).x +\n                    v3 * map( pos + v3*eps ).x +\n                    v4 * map( pos + v4*eps ).x );\n}\n\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec2 rotate(in vec2 v, in float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat2 m = mat2(c, -s, s, c);\n    return m * v;\n}\n\nfloat t() {\n    return (iTime + 3.) * 1.;\n}\n\nfloat random (in float x) {\n    return fract(sin(x *  13456.234));\n}\n\nfloat random (in vec2 p) {\n    return fract(sin(dot(p, vec2(34556.,67892.))));\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = smoothstep(0., 1., f);\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat fbm (in vec2 p) {\n    return (\n        noise(p * 2.) +\n        noise(p * 4.) +\n        noise(p * 8.)\n    );\n}\n\nvec2 opU(in vec2 p, in vec2 q) {\n    return p.x < q.x ? p : q;\n}\n\nvec2 sdBox(in vec3 p) {\n    return vec2(\n        length(max(abs(p) - 2., 0.0)),\n        noise(vec2(noise(p.xy * p.z * .25 + sin(time * 2.)))) * .4\n    );\n}\n\nvec2 sdSwirl(in vec3 p) {\n    p.xy = rotate(p.xy, t());\n    p.z = p.z * 1.2 -2.;\n\n    float c = noise(vec2(noise(p.xy * .3), p.z * .3));\n\n    // Random distortion\n    p.x += noise(p.xy * 10.) * .03;\n    p.y += noise(p.xy * 10. + .3) * .03;\n\n    float d = 99999.;\n\n    for (int i = 0; i < INNER_LOOP; i++) {\n        float fi = float(i);\n        vec3 pi = p;\n        p.xy = rotate(p.xy, fi * PI * .5);\n\n        pi.x *= clamp(1. - fi * random(fi * 4.) * .4, .3,.7);\n        pi.y *= clamp(1. - fi * random(fi * 5.) * .4, .3,.7);\n\n        pi.x += clamp((1. - fi * random(fi + 1.)) * .4 + fi * .3, .7, 1.7);\n        pi.y += clamp((1. - fi * random(fi + 2.)) * .4 + fi * .3, .7, 1.7);\n        pi.z -= (3. - fi) + fi * 2.0;\n\n        pi *= 3.5;\n        float di = min(\n            pi.z + 2. - floor(abs(pi.y)),\n            pi.z + 2. - floor(abs(pi.x))\n        );\n\n        di = max(di, -min(\n            pi.z + 2. - floor(abs(pi.y * .7)),\n            pi.z + 2. - floor(abs(pi.x * .7))\n        ));\n\n        // Create binding box\n        float ti = clamp(mod(t(), 2.) - fi * .2, 0., 2.);\n        float tt = floor(ti * 20.) * .1;\n        di = max(di, length(max(abs(pi / 3.) - tt, 0.0)));\n\n        d = min(d, di);\n    }\n\n    d -= .1;\n\n    return vec2(d, c);\n}\n\nvec2 map(vec3 p) {\n    p.yz = rotate(p.zy, .2 * PI + t());\n    p.xy = rotate(p.xy, .2 * PI + t());\n    vec2 v = sdBox(p);\n\n    v = opU(v, sdSwirl(p));\n    p.yz = rotate(p.yz, PI);\n    v = opU(v, sdSwirl(p));\n\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){    \n    vec2 p = (fragCoord.xy * 2. - resolution) / min(iResolution.x, iResolution.y);\n    vec3 color;\n\n    vec3 rayOrigin = vec3(0., 0., 40.);\n    rayOrigin.xz = rotate(rayOrigin.xz, t() * 1.0);\n\n    vec3 rayTarget = vec3(0, 0, 0);\n    vec3 rayDirection = getRay(rayOrigin, rayTarget, squareFrame(iResolution.xy), 2.);\n\n    vec3 ambient = vec3(.4, .7, .5);\n    vec3 lightDir1 = normalize(vec3(-1., 2.3, 10.));\n    vec3 light1 = vec3(-.4, .7, 1.) * 1.2;\n    vec3 lightDir2 = normalize(vec3(3.,  -3., 3.));\n    vec3 light2 = vec3(.8, .8, 6.) * 1.2;\n\n    vec3 lightDir3 = vec3(0, 0., 40.);\n    vec3 light3 = vec3(.9, .3, .5) * .7;\n\n    vec2 collision = calcRayIntersection(rayOrigin, rayDirection, 70., 0.0001, .3);\n    if (collision.x > -.5) {\n        vec3 pos = rayOrigin + rayDirection * collision.x;\n        vec3 normal = normalize(calcNormal(pos));\n\n        vec3 c = ambient;\n\n        float diff1 = clamp(dot(lightDir1, normal), 0., 1.0);\n        float phong1 = pow(max(dot(reflect(lightDir1, normal), rayOrigin), 0.0), .8);\n        c += light1 * diff1 + phong1 * 1.3;\n\n        float diff2 = clamp(dot(lightDir2, normal), 0., 1.0);\n        float phong2 = pow(max(dot(reflect(lightDir2, normal), rayOrigin), 0.0), .8);\n        c += light2 * diff2 + phong2 * 1.3;\n\n        float diff3 = clamp(dot(lightDir3, normal), 0., 1.0) * 9.9;\n        float phong3 = pow(max(dot(reflect(lightDir3, normal), rayOrigin), 0.0), .3);\n        c += light3 * diff3 + phong3;\n\n        float d = length(rayOrigin - pos) + 1.;\n        c *= 30. / (d * d);\n\n        c += hsv2rgb(vec3(collision.y, 1, 1)) * .3;\n\n        color = c;\n    }\n    else {\n        float c = 1.5 - length(p *.5);\n        color = vec3(c);\n    }\n    color += vec3(p.x * .1, p.y * .1, 1.);\n    fragColor = vec4(color, 1);\n}\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdsfW2.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdXBDf", "name": "Simplex Sun", "author": "Palliaci", "description": "I got this strange sun while messing with this simplex noise and fbm.\nI'm sorry I can't remember who I took it from.\nLights uses the blackbody algorithm with distance as parameter.", "tags": ["raymarching", "sun", "3dnoise", "simplex"], "likes": 1, "viewed": 557, "date": "1498469736", "time_retrieved": "2024-06-20T18:57:06.895243", "image_code": "\n#define I_MAX\t130\n#define E\t\t0.002\nvec2\tuv;\nfloat\tphase;\n\nvec3\tcamera(vec2 uv);\nvec3\tblackbody(float Temp);\nfloat\tsimplex3d(vec3 p);\nfloat\tsimplex3d_fractal(vec3 m);\nvec3\trandom3(vec3 c);\nvec2\thash( vec2 p );\nfloat\tnoise( in vec2 p );\nmat3\tRot3X( float a );\nmat3\tRot3Y( float a );\n\n\nfloat sdTriPrism( vec3 p, vec2 h ) {\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat\tscene( vec3 p ) {\n    float\tmind = 1e5;\n    float plen = length(p);\n    if (plen-.125 < .0)\n        return 1e5;\n    mind = plen - .25 * (phase-.125);\n//\tmind = sdTriPrism( p, vec2(.2, .8) );\n    //mind = min(length(simplex3d_fractal(vec3(mind, .2 * iTime, p.y)) - .1), mind);\n    mind = min(length(simplex3d_fractal(vec3(mind, p.z, p.y)) - .1), mind);\n    /*\n\tmind = min(length(noise(vec2(iTime*.25, 1.*p.y*mind)) -.5), mind);\n    mind = min(length(noise(vec2(iTime*.25, 2.*p.x*mind)) -.5), mind);\n    mind = min(length(noise(vec2(iTime*.25, 2.*p.z*mind)) -.5), mind);\n    */\n/*\n   // mind = min(length(noise(vec2(mind, p.y))) -.1, mind);\n    mind = min(length(noise(vec2(mind, .2 * iTime))) -.1, mind);\n    mind = min(length(noise(vec2(p.y*2., mind))) -.1, mind);\n*/\n //   mind = min(length(texture(iChannel0, uv)) -uv, mind);\n    //mind = length(noise(vec2(iTime*.25, 2.*p.y)) -.5*mind);\n//    mind = mod(mind, 2.);\n    return( max(mind, plen - 1.2) );\n}\n\nvec4\tmarch( vec3 pos, vec3 dir ) {\n    vec2\tdist = vec2( 0.0 );\n    vec3\tp = vec3( 0.0 );\n    vec4\tstep = vec4( 0.0 );\n    for ( int i = -1; i < I_MAX; ++i )\n    {\n    \tp = pos + dir * dist.y;\n        dist.x = scene( p );\n        dist.y += dist.x;\n        if ( dist.x < E || dist.y > 4. )\n           break;\n        step.x++;\n    }\n    step.y = dist.x;\n    step.w = dist.y;\n    return ( step );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    uv  = fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    float\tt = iTime*.5;\n    phase = 1. + sin(iTime);\n    float \tst = sin(t);\n    float\tct = cos(t);\n\tvec3\tdir = camera( uv );\n    vec4\tcol;\n    vec3\tpos = vec3( 0., 0., -.5);\n\n    //pos.z += 1.8*(.5*-st);\n    pos.x -= 2.5*st;\n    pos.y -= 2.5*-ct;\n    dir *= Rot3X( ct*1. ) * Rot3Y( st*1. );\n    vec4 inter = ( march( pos, dir ) );\n\n\tcol.xyz = blackbody(inter.x*200./inter.w);\n   \tfragColor = col;\n}\n\n\n\n\n\n\nvec3\tcamera(vec2 uv) {\n    float   fov = \t\t 1.;\n\tvec3    forw  = vec3( 0.0, 0.0, 1.0 );\n\tvec3    right = vec3( 1.0, 0.0, 0.0) ;\n\tvec3    up    = vec3( 0.0, 1.0, 0.0) ;\n\n    return ( normalize( ( uv.x - 1. ) * right\n                        + ( uv.y - 0.5 ) * up\n                        + fov * forw ) );\n}\n\nvec3 blackbody(float Temp)\n{\n\tvec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\nconst mat3 rot1 = mat3(-0.37, 0.36, 0.85,-0.14,-0.93, 0.34,0.92, 0.01,0.4);\nconst mat3 rot2 = mat3(-0.55,-0.39, 0.74, 0.33,-0.91,-0.24,0.77, 0.12,0.63);\nconst mat3 rot3 = mat3(-0.71, 0.52,-0.47,-0.08,-0.72,-0.68,-0.7,-0.45,0.56);\n\nfloat simplex3d_fractal(vec3 m) {\n    return   0.5333333*simplex3d(m*rot1)\n\t\t\t+0.2666667*simplex3d(2.0*m*rot2)\n\t\t\t+0.1333333*simplex3d(4.0*m*rot3)\n\t\t\t+0.0666667*simplex3d(8.0*m);\n}\nvec2 hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = step(a.yx,a.xy);    \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\n\t\n}\nmat3\tRot3X( float a ) {\n    float c = cos( a );\n    float s = sin( a );\n    return mat3( 1, 0, 0,\n                 0, c,-s,\n                 0, s, c );\n}\nmat3\tRot3Y( float a ) {\n    float c = cos( a );\n    float s = sin( a );\n    return mat3( c, 0, s,\n                 0, 1, 0,\n                 -s, 0, c );\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdXBDf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdXBDM", "name": "Wormy's Space Adventure", "author": "DJDoomz", "description": "Just messing about\n", "tags": ["2d", "starfield"], "likes": 10, "viewed": 624, "date": "1496323290", "time_retrieved": "2024-06-20T18:57:06.895243", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime/10.;\n    float color = 0.;\n    fragCoord-= iResolution.xy/2.;\n    float w = iResolution.x/2.;\n    float h = iResolution.y/2.;\n    \n    //wormy\n    for(float i = 0.; i < 12.; i+=.25){\n    \tfloat x = (w/2.)*sin(i/30.+t*4.);\n    \tfloat y = (h/10.)*cos(i/10.+t*8.) + 2.*sin((x*3.+t*200.)/25.);\n        color += .2/distance(fragCoord, vec2(x, y));\n    }\n\n    //stars\n    for(float i = 0.; i < 25.; i++){\n        float x = mod(i+(sin(i))*(t+500.)*500., w*2.+200.)-w-100.;\n        float y = h*sin(cos(i*524.)*i*5.+i*2.);\n        color += (.2*sin(i)+.2)/distance(fragCoord, vec2(x,y));\n    }\n   \n    fragColor = vec4(color);\n    \n    //for more fun:\n    //fragColor = vec4(abs(sin(color*34.)),abs(sin(color*45.+3.)),abs(cos(color*23.+23.)), 255);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdXBDM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdXBRs", "name": "Combine", "author": "yahe", "description": "combined phase 1", "tags": ["showreel"], "likes": 3, "viewed": 466, "date": "1497418515", "time_retrieved": "2024-06-20T18:57:09.974186", "image_code": "\n//////////////////////////////////////////////////////////////////////////////////////\n// use voronoi function from iq \n\n// http://www.iquilezles.org/www/articles/voronoilines/voronoilines.htm\n\n#define ANIMATE\n\nvec2 hash2( vec2 p )\n{\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec3 voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.5*sin( iTime + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.5*sin( iTime + 6.2831*o )/2.;\n        #endif\t\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return vec3( md, mr );\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n\nconst float Pi = 3.1415926535;\n\nfloat Point(vec2 uv, vec2 P)\n{\n    return smoothstep(0.035, 0.005, distance(uv, P));   \n}\n\nfloat cbrt(float x)\n{\n    return sign(x) * pow(abs(x), 1.0/3.0);\n}\n\n// http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c\n// Solve cubic ax^3 + bx^2 + cx + d = 0 \n// Returns amount of roots\nint SolveCubic(vec4 coeffs, out vec3 roots)\n{\n    int nS = 0;  \n    // normal form: x^3 + Ax^2 + Bx + C = 0 \n    vec4 N = coeffs / coeffs[0];\n\n    // substitute x = y - A/3 \n    // depressed cubic: x^3 + px + q = 0 \n    float sqA = N[1]*N[1];\n    float p = (N[2] - sqA/3.0) / 3.0;\n    float q = ( (N[1] * sqA)/13.5 - (N[1] * N[2])/3.0 + N[3]) * 0.5;\n\n    // Use Cardano's formula \n    float cbP = p * p * p;\n    float D = q * q + cbP;\n\n    if (abs(D) < 1e-20)\n    {\n\t\tif (q == 0.0)  \n            nS = 1;\n\t\t   \n\t\telse // one single and one double solution\n\t\t{\n\t\t    float u = cbrt(-q);\n\t\t    roots[0] = 2.0 * u;\n\t\t    roots[1] = -u;\n\t\t    nS = 2;\n\t\t}\n    }\n    \n    else if (D < 0.0) // Casus irreducibilis: three real solutions\n    {\n\t\tfloat phi = acos(-q / sqrt(-cbP)) / 3.0;\n\t\tfloat t = 2.0 * sqrt(-p);\t\n\t\troots[0] = t * cos(phi);\n\t\troots[1] = -t * cos(phi + Pi/3.0);\n\t\troots[2] = -t * cos(phi - Pi/3.0);\n\t\tnS = 3;\n    }\n    \n    else // one real solution \n    {\n\t\tfloat sqrtD = sqrt(D);\n\t\troots[0] = cbrt(sqrtD - q) - cbrt(sqrtD + q);\n\t\tnS = 1;\n    }\n\n    roots -= N[1] / 3.0;\n    \n    return nS;\n}\n\nvec2 QuadraticBezier(float t, vec2 p0, vec2 p1, vec2 p2)\n{\n\treturn mix((mix(p0, p1, t)),(mix(p1, p2, t)), t);\n}\n\n// x is a point\n// {a, b, c} are the control points\nfloat DistanceQuadraticBezier(vec2 x, vec2 a, vec2 b, vec2 c)\n{\n    float aa = dot(a,a);\tfloat bc = dot(b,c);\tfloat cc = dot(c,c);\n    float ab = dot(a,b);\tfloat bb = dot(b,b);   \tfloat cx = dot(c,x);\n    float ac = dot(a,c);\tfloat bx = dot(b,x);\n    float ax = dot(a,x);\n           \n    // Cubic coefficients\n    float cu = 4.0*(aa + cc) + 16.0*(bb - ab - bc) + 8.0*ac;\n    // Quadratic coefficients\n\tfloat qu = 12.0*(bc - ac - aa) - 24.0*bb + 36.0*ab;\n    // Linear coefficients\n    float li = 4.0*(ac - ax - cx) + 8.0*(bx + bb) + 12.0*aa - 24.0*ab;\n    // Constant terms\n    float C = 4.0*(ab + ax - aa - bx);\n    vec3 roots;\n    vec4 coeffs = vec4(cu, qu, li, C);\n    \n    int nS = SolveCubic(coeffs, roots);  \n    float t;\n\n   \tfloat Dist1 = distance(x, QuadraticBezier(clamp(roots.x, 0.0, 1.0), a, b, c));\n    float Dist2 = distance(x, QuadraticBezier(clamp(roots.y, 0.0, 1.0), a, b, c));\n    float Dist3 = distance(x, QuadraticBezier(clamp(roots.z, 0.0, 1.0), a, b, c));\n    \n    return min(Dist3, min(Dist1, Dist2));\n}                 \n\nvec2 Mouse()\n{\n    vec2 a = 2.0 *(iMouse.xy / iResolution.xy) - 1.0;\n    a.x *= iResolution.x / iResolution.y;\n    return a;\n    \n}\n\nvec3 Curves(vec2 uv)\n{\n    float t = iTime * 7.0;\n    \n    float P = 0.0;\n    vec3 L = vec3(0.0);\n    \n    vec2 p0 = vec2(uv.x, -1.);\n    \n    for (float i = 0.0; i < 50.; i++) {\n    \n    vec2 p2 = vec2(1.5*sin(t*.5+i), 1.5*cos(t*.1+i)); \n    vec2 p4 = -p2;\n    vec2 p5 = vec2(-p2.y, p2.x);\n        \n        vec2 p = vec2(1.5*sin((t*0.04+i)), sin((t*.1+i) - 1.));\n    \tfloat d1 = smoothstep(0.02, 0.00, DistanceQuadraticBezier(uv, p0, p2, p));\n    \tfloat d2 = smoothstep(0.03, 0.00, DistanceQuadraticBezier(uv, p0, p4, p));\n    \tfloat d3 = smoothstep(0.05, 0.00, DistanceQuadraticBezier(uv, p0, p5, p));\n        \n    vec3 L1 = d1 * vec3(0.2 , 0.4, 0.4+ .5*sin(i));\n    vec3 L2 = d2 * vec3(0.3, 0.2, 0.4+ .2*cos(i));\n        \n        L += L1 + L2;\n    }\n    \n    return P + L;\n}   \n\n//////////////////////////////////////////////////////////////////////////////////\n\n#define NUM_PARTICLES 200.0\n#define GLOW 0.5\n\nvec3 Orb(vec2 uv, vec3 color, float radius, float offset)\n{        \n    vec2 position = vec2(sin(offset * (iTime+30.)),\n                         cos(offset * (iTime+30.)));\n    \n    position *= sin((iTime ) - offset) * cos(offset);\n     \n    //offset = pModPolar(position,2.);\n    \n    radius = radius * offset;\n    float dist = radius / distance(uv, position);\n    return color * pow(dist, 1.0 / GLOW);\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////\n\n#define PI 3.14159265358979323846\n\n#define W(x,k,c) A*sin(k*(X=x*2.-c*t))*exp(-X*X)\n\n#define C( r, R, t) smoothstep(t, 0., abs(R-(r)) )\n\n//////////////////////////////////////////////////////////////////////////////////\n\nfloat noise(in vec2 position) {\n    return fract(sin(dot(position.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Value Noise courtesy of Book of Shaders\n// https://thebookofshaders.com/11/\nfloat noise2d(vec2 uv) {\n    \n    vec2 pos = floor(uv);\n    vec2 fractional = fract(uv);\n    \n    // four corners\n    float a = noise(pos);\t\t\t\t\t// bottom left\n    float b = noise(pos + vec2(1., 0.));\t// bottom right\n    float c = noise(pos + vec2(1., 1.));\t// top right\n    float d = noise(pos + vec2(0., 1.));\t// top left\n    \n    vec2 intermix = smoothstep(0., 1., fractional);\n    \n    float value = mix(a, b, intermix.x);\n    value += (d - a) * intermix.y * (1.0 - intermix.x);\n    value += (c - b) * intermix.x * intermix.y;\n    \n    return value;\n}\n\n// Fractal noise courtesy of iq\n// https://www.shadertoy.com/view/XdXGW8\nfloat fractalNoise2d(vec2 uv) {\n    uv *= 3.0;\n    uv.x -= iTime / 5.0;\n    uv.y += sin(iTime / 5.0) * 2.0;\n    \n    mat2 rotate = mat2(1.6 - sin(iTime / 100.0) / 10.0, 1.2, -1.2, 1.6);\n    \n    float value = 0.5 * noise2d(uv);\n    uv *= rotate;\n    value += 0.25 * noise2d(uv);\n    uv *= rotate;\n    value += 0.125 * noise2d(uv);\n    uv *= rotate;\n    value += 0.0625 * noise2d(uv);\n    \n    return value;\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n\nvec2 rotate2D(vec2 _st, float _angle){\n    _st -= 0.5;\n    _st =  mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle)) * _st;\n    _st += 0.5;\n    return _st;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////\n\n\nvec2 rotate( vec2 inVec, float angle )\n{\n \tmat4 rotMatrix = mat4\n    (\n    \tcos( angle ),\t-sin( angle ),\t0,\t0,\n        sin( angle ), \tcos( angle ),\t0,\t0,\n        0,\t\t\t\t0,\t\t\t\t1,\t0,\n        0,\t\t\t\t0,\t\t\t\t0,\t1    );\n    \n    return ( vec4( inVec, 0.0, 1.0 ) * rotMatrix ).xy;\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n\n// Lissajous curve\n// http://en.wikipedia.org/wiki/Lissajous_curve\n\n#define NUM 200.0\n#define TOW_PI 6.28318\n#define STEPS 300.\n\nvec2 lissajous(float t, float a, float b, float d)\n{\n\treturn vec2(sin(a*t+d), sin(b*t));\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////\n\nvec2 c11;\n\nfloat avgDistance(vec2 uv)\n{\n \tfloat d = 0.0;\n    float k = 50.;\n    \n    for(int i=0; i<5; i++)    \n     \td+= cos(k*  sqrt((uv.x - c11.x) * (uv.x - c11.x) + (uv.y - c11.y) * (uv.y - c11.y)) ); \n    \n    return d/float(5);  \n}\n\nvec3 distToColor(float d)\n{\n    return vec3(sin(d),sin(d),sin(d));\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n\nfloat F(vec2 p, float s)\n{\n\tfloat x = abs(p.x);\n    float y = abs(p.y);\n    \n    x *= s;\n    y *= s;\n    \n    float ScaleX = (1.0 - sqrt(abs(1.0 - x)))/(x);\n    float ScaleY = (1.0 - sqrt(abs(1.0 - y)))/(y);\n    \n    float brightness = 1.1;\n    \n    return ScaleX * ScaleY * brightness;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////\n\nvec3 Orb13(vec2 uv, vec3 color, float radius, float offset)\n{        \n    float t = (iTime+200.)/5.;\n    vec2 position = vec2(sin(offset * t)*sin(offset * t)+ sin(iTime),\n                         cos(offset * t)*cos(offset * t)+ cos(iTime));\n    \n    if (sin(offset * t) < 0.&& cos(offset * t) > 0.) {\n     \n        position = vec2(-sin(offset * t)*sin(offset * t)+sin(iTime),\n                         cos(offset * t)*cos(offset * t)+cos(iTime));\n    } else if (cos(offset * t) < 0. && sin(offset * t) > 0.) {\n        \n        position = vec2(sin(offset * t)*sin(offset * t)+sin(iTime),\n                         -cos(offset * t)*cos(offset * t)+cos(iTime));\n        \n    } else if (cos(offset * t) < 0. && sin(offset * t) < 0.) {\n        \n        position = vec2(-sin(offset * t)*sin(offset * t)+sin(iTime),\n                         -cos(offset * t)*cos(offset * t)+cos(iTime));\n    }\n    \n    position *= sin((t + offset )*2. )* offset;\n    \n    radius = radius * sqrt(abs(position.x * position.y)) ;\n    \n    float dist = radius / distance(uv, position);\n    \n    return color * pow(dist, 1.0 / .4);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime*3.0;\n\t\n\n\t//col = pow( col, vec3(0.7, 1., .9) );\n\n    vec2 uv = fragCoord.xy/iResolution.xx;\n\n    vec3 c = voronoi( 3.0*uv + ( sin(iTime)/2. +.5) );\n\n    c = c*c*1.5;\n    vec3 color2 = vec3(c.x*3., c.y*c.x, c.y);\n    color2 = mix( vec3(sin(iTime)+.3,sin(iTime)+.6,.9), color2, 0.5 );\n    \n    ////////////////////////////////////////////////////////\n    vec2 uv2 = fragCoord.xy / iResolution.xy;\n    vec2 q2 = 2.0*uv2 - 1.0;\n    q2.x *= iResolution.x / iResolution.y;   \n    \n    vec3 color3 = vec3(0.15, 0.15, 0.19);\n    color3 = max(color3, Curves(q2));\n       \n    color3 = sqrt(color3) * .7;\n    color3 = color3 * (1.0 - 0.2*dot(q2,q2));\n    \n    ////////////////////////////////////////////////////////\n\n    vec2 uv3 =  vec2(fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec3 pixel = vec3(0.0, 0.0, 0.0);\n   \tvec3 color4 = vec3(0.0, 0.0, 0.0);\n    \n \tcolor4.r = ((sin(((iTime)) * 0.55) + 1.5) * 0.4);\n    color4.g = ((sin(((iTime)) * 0.34) + 2.0) * 0.4);\n    color4.b = ((sin(((iTime)) * 0.31) + 4.5) * 0.3);\n    \n    float radius = 0.005;\n    \n    for\t(float i = 0.0; i < NUM_PARTICLES; i++)\n        pixel += Orb(uv3, color4, radius, i / NUM_PARTICLES);\n\n    color4 = mix(vec3(uv3,0.8+0.5*sin(iTime)), vec3(pixel), 0.8);\n    \n    ////////////////////////////////////////////////////////  \n\n    float A=3., X, y, Y=0.,  T = iTime,  t=mod(T,5.);\n    \n\tvec2 uv4 = fragCoord.xy / iResolution.xy;\n     \n    vec2 p4 = uv4 - vec2(0.5);\n    p4.x *= iResolution.x / iResolution.y;\n\n    float pr = length(p4);\n    float pa = atan(p4.y, p4.x);\n    \n    float radius5;\n    \n    float o = 0.0;\n    \n\tfloat wave_width = 0.01;\n    \n    for( float i = 1.0 ; i < 10.0 ; i += 1.0 )\n    {\n        radius5 = .1 + i*i/700. + 0.01 * ( W( (cos(pa * i / 5.) + PI/2.), i, sqrt(i) ) );\n        \n    \to += C(radius5 + (sin(T)+1.)/10., pr, 2./iResolution.y);\n    }\n    \n    vec4 color5 = mix( vec4(0.7, 0.85, 1. - 0.2*p.y, 0) * (1.0 - 0.2 * pr), o + p.xyyy * sin(T), o );\n    \n    //////////////////////////////////////////////////////// \n    \n    vec2 uv7 = fragCoord.xy/iResolution.x;\n    \n    float noise = fractalNoise2d(uv7);\n    uv7 = rotate2D(uv7, noise*300.);\n    \n    uv7 = .5*uv7;\n    float plasma = noise*(sin(uv7.x)+cos(uv7.y))*5.;\n    \n    vec3 color7 = vec3(sin((-plasma)+iTime),\n                    sin((-plasma+.4)+iTime),\n                    sin((-plasma+.5)+iTime));\n    \n    //////////////////////////////////////////////////////// \n    \n\tvec2 uv8 = fragCoord.xy / iResolution.xy;\n    uv8 -= .5;\n    uv8.x += sin(iTime/4.)/2.;\n    uv8.y += sin(iTime*2.)/4.;\n    \n    float offsetVal = iTime;\n    \n    vec2 uvR = uv8;\n    uvR.y /= abs(uvR.x);\n    uvR = rotate( uvR, offsetVal );\n    \n    vec2 uvG = uv8;\n    uvG.x /= abs(uvG.y);\n    uvG = rotate( uvG, offsetVal );\n    \n    vec2 uvB = uv;\n    uvB.xy -= sin( offsetVal );\n    \n    vec3 color8 = vec3( uvR.y * 0.5 + 0.5, uvG.y * 0.5 + 0.5, uvB.y * 0.5 + 0.5 );\n\n    //////////////////////////////////////////////////////// \n    \n\t\n\tvec2 uv9 = (fragCoord.xy-.5*iResolution.xy)/min(iResolution.x,iResolution.y);\n    //vec3 c=vec3(0.9,0.55,0.6); //background color\n    \n    vec2 polar;\n    polar.y = sqrt(uv9.x * uv9.x + uv9.y * uv9.y);\n    polar.y /= iResolution.x / 2.0;\n    polar.y = 1.0 - polar.y;\n\n    polar.x = atan(uv9.y, uv9.x);\n    polar.x -= 1.57079632679;\n    if(polar.x < 0.0){\n\t\tpolar.x += 6.28318530718;\n    }\n    polar.x /= 6.28318530718;\n    polar.x = 1.0 - polar.x;\n    \n    vec3 color9 = vec3(sin( (uv9.x*uv9.x+uv9.y*uv9.y)*6.1-iTime*2.345)*.1+.15,sin((uv9.x*uv9.x+uv9.y*uv9.y)*3.1-iTime*1.2)*0.1+0.1,sin((uv9.x*uv9.x+uv9.y*uv9.y)*1.5-iTime*3.123)*0.01+.1);\n    \n    //vec3 c = smoothstep(-0.6+w,1.4+w+f,sqrt(p.x*p.x+p.y*p.y));\n\t\n    float radius9 = .4;\n    float brightness = 0.0005;\n    \n    for(float i=0.0; i<500.0; i++){\n        radius9 += sin(i*45.+iTime)*0.1;\n        \n\t\t//get location of dot\n        float x = sin(2.*3.14*i/(500.0))*radius9;\n        float y = cos(2.*3.14*i/(500.0))*radius9;\n        vec2 o = vec2(x,y);\n\t    \n        //get brightness of this pixel based on distance to dot\n\t\tcolor9 += brightness/(length(p-o))*radius9;\n    }\n    \n    radius9 = .15;\n    brightness = 0.0009;\n     for(float i=0.0; i<300.0; i++){\n        radius9 += sin(i*45.+iTime)*0.1;\n        \n\t\t//get location of dot\n        float x = sin(2.*3.14*i/(300.0))*radius9;\n        float y = cos(2.*3.14*i/(300.0))*radius9;\n        vec2 o = vec2(x,y);\n\t    \n        //get brightness of this pixel based on distance to dot\n\t\tcolor9 += brightness/(length(p-o))*radius9;\n    }\n\t \n\n    //////////////////////////////////////////////////////// \n\n    vec2 uv10 = (fragCoord.xy / iResolution.xy)*2.0-1.0;\n\tuv10.x *= iResolution.x / iResolution.y;\n    \n\tfloat a = 2. + mod(iTime, 10.);\n\tfloat b = 4.0;\n\tfloat d = 1.;\t// phase\n\t\n\tfloat m = .006;\n    vec2 lp = lissajous(log(iTime), a, b, d)*0.8;\n    \n    vec3 pixel10 = vec3(0.0, 0.0, 0.0);\n   \tvec3 color10 = vec3(0.0, 0.0, 0.0);\n    \n    for\t(float i = 0.0; i < NUM; i++) {\n        float t = float(i)*TOW_PI / STEPS;\n\t\tt += log(iTime);\n        vec2 p = lissajous(t, a, b, d)*0.8;\n\t\t\n\t\t// distance to line\n        vec2 pa = uv10 - p;\n        vec2 ba = lp - p;\n        float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n        vec2 q = pa - ba*h;\n        \n        m = min( m, dot( q, q )*50.);\n\t\t\n            \n        pixel10 += vec3(1., 1., 1.) * m;\n     }\n    \n    color10 = mix(vec3(uv10,0.8+0.5*sin(iTime)), pixel10, 0.8);\n    \n    //////////////////////////////////////////////////////// \n\n    vec2 uv11 = (fragCoord.xy - iResolution.xy * .5) / iResolution.y;\n    \n    for(int i=0; i<5; i++)\n    {\n     float fi = 2.0*3.14*float(i)/5.0;\n     c11= vec2(sin(fi+iTime/10.), cos(fi+iTime/10.))*cos(iTime/10.);\n    }\n    \n\tvec3 color11 = distToColor(avgDistance(uv11))*1.;\n    \n    \n    //////////////////////////////////////////////////////// \n\tvec2 uv12 = fragCoord.xy / iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n    uv12.x = uv12.x * aspect;\n    vec2 p12 = uv12 - vec2(0.5 * aspect, 0.5);\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    \n    float scale = 0.;\n    \n    for (float i=0.; i<20.; i++) {\n    \tscale += F(rotate(p12,(i+1.)*iTime/10.), (i*(sin(iTime/2.)/5.+.5)+1.));\n    }\n    \n    vec3 color12 = vec3(0.5);\n    color12 = color12 * scale / 4.;\n    \n    \n    \n    //////////////////////////////////////////////////////// \n\n    vec2 uv13 =  vec2(fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec3 pixel13 = vec3(0.0, 0.0, 0.0);\n   \tvec3 color = vec3(1.);\n    \n    float radius13 = 0.02;\n    \n    for\t(float i = 0.0; i < 500.; i++) {\n        pixel13 += Orb13(uv13, color, radius13,  i / 500.);\n    //pixel += Orb(uv, color, radius, i / NUM_PARTICLES);\n    }\n\n    \n    vec3 color13 = pixel13;\n\n    \n    if (iTime <= 10.) {\n\t    fragColor = vec4( color3, 1.0 );\n    } else if (iTime <= 12.) {\n        fragColor = vec4(mix( color3, color2, 1.-(12.-iTime)/2. ), 1.0 );\n    } else if (iTime < 22.) {\n        fragColor = vec4( color2, 1.0 );\n    } else if (iTime < 24.) {\n        fragColor = vec4(mix( color2, color4, 1.-(24.-iTime)/2. ), 1.0 );\n    } else if (iTime < 34.) {\n        fragColor = vec4( color4, 1.0 );\n    } else if (iTime < 36.) {\n        fragColor = mix( vec4(color4, 1.0), color5, 1.-(36.-iTime)/2. );\n    } else if (iTime < 46.) {\n        fragColor = color5;\n    } else if (iTime < 48.) {\n        fragColor = mix( color5, vec4(color7, 1.0), 1.-(48.-iTime)/3. );\n    } else if (iTime < 58.) {\n        fragColor = vec4( color7, 1.0 );\n    } else if (iTime < 60.) {\n        fragColor = vec4(mix( color7, color8, 1.-(60.-iTime)/2. ), 1.0 );\n    } else if (iTime < 70.) {\n        fragColor = vec4( color8, 1.0 );\n    } else if (iTime < 72.) {\n        fragColor = vec4(mix( color8, color9, 1.-(72.-iTime)/2. ), 1.0 );\n    } else if (iTime < 82.) {\n        fragColor = vec4( color9, 1.0 );\n    } else if (iTime < 84.) {\n        fragColor = vec4(mix( color9, color10, 1.-(84.-iTime)/2. ), 1.0 );\n    } else if (iTime < 94.) {\n        fragColor = vec4( color10, 1.0 );\n    } else if (iTime < 96.) {\n        fragColor = vec4(mix( color10, color13, 1.-(96.-iTime)/2. ), 1.0 );\n    } else if (iTime < 106.) {\n        fragColor = vec4( color13, 1.0 );\n    } else if (iTime < 108.) {\n        fragColor = vec4(mix( color13, color12, 1.-(108.-iTime)/2. ), 1.0 );\n    } else {\n        fragColor = vec4( color12, 1.0 );\n    }\n}", "image_inputs": [{"id": "MsXSzf", "previewfilepath": "https://soundcloud.com/yanling-he/phase2", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/yanling-he/phase2", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdXBRs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdXBWM", "name": "Metaballs-threstle", "author": "Threstle", "description": "metaballs", "tags": ["metaballs"], "likes": 0, "viewed": 77, "date": "1496305376", "time_retrieved": "2024-06-20T18:57:09.974346", "image_code": "float isInCircle(vec2 pos, vec2 mouse, vec4 circle, vec4 circle2, vec4 circle3, vec4 circle4){\n    \n    \n    \n    float dist1 = circle.z / sqrt(((pos.x - circle.x)*(pos.x - circle.x)) + ((pos.y - circle.y)*(pos.y - circle.y)));\n    float dist2 = circle2.z / sqrt(((pos.x - circle2.x)*(pos.x - circle2.x)) + ((pos.y - circle2.y)*(pos.y - circle2.y)));\n    float dist3 = circle3.z / sqrt(((pos.x - circle3.x)*(pos.x - circle3.x)) + ((pos.y - circle3.y)*(pos.y - circle3.y)));\n    float dist4 = circle4.z / sqrt(((pos.x - circle4.x)*(pos.x - circle4.x)) + ((pos.y - circle4.y)*(pos.y - circle4.y)));\n\n    float dist5 = circle4.z / sqrt(((pos.x - mouse.x)*(pos.x - mouse.x)) + ((pos.y - mouse.y)*(pos.y - mouse.y)));\n    \n    float col = ((dist1*circle.w) + (dist2*circle2.w) + (dist3*circle3.w) + (dist4*circle4.w));  \n    float newDist;\n    newDist = dist2 + dist1 + dist3 + dist4;\n    \n    \n    float color = 0.0;\n    \n    if(newDist > circle.z*18.0  && newDist < circle.z*20.0)color = col;\n    \n    //newDist = cos(newDist);\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r = vec2(fragCoord.x / iResolution.x,\n\t\t\t\t  fragCoord.y / iResolution.y);\n    \n    vec2 m = vec2(iMouse.x / iResolution.x,\n\t\t\t\t  iMouse.y / iResolution.y);\n\t\n    vec4 ball1 = vec4(0.4 + cos(iTime)*0.1, 0.5 + sin(iTime)*0.1,0.05,0.3);\n    vec4 ball2 = vec4(0.6 - cos(iTime)*0.1, 0.5 - sin(iTime)*0.4,0.05,0.5);\n\tvec4 ball3 = vec4(0.5 - cos(iTime)*0.1, 0.4 + sin(iTime)*0.12,0.05,0.6);\n\tvec4 ball4 = vec4(0.5 - cos(iTime)*0.1, 0.6 - sin(iTime*0.3)*0.40,0.05,0.9);\n\n    \n    vec3 pixel = vec3(0.0);\n\n    \n    float dist = isInCircle(r,m,ball1,ball2,ball3,ball4);\n    \n    \n    pixel = vec3(dist,dist/4.0,dist/2.0);\n\t\n\tfragColor = vec4(pixel, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdXBWM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdXBWX", "name": "Triangles wave", "author": "balkhan", "description": " ", "tags": ["2d", "triangles"], "likes": 2, "viewed": 110, "date": "1498538311", "time_retrieved": "2024-06-20T18:57:09.974346", "image_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\nvec2 skew (vec2 st) {\n    vec2 r = vec2(0.0);\n    r.x = 1.5*st.x;\n    r.y = st.y+0.5*r.x;\n    return r;\n}\n\nvoid mainImage( out vec4 o, in vec2 f )\n{\n    float\tt = iTime;\n\tvec2 R = iResolution.xy,\n          uv  = vec2(f-R/2.) / R.xy;\n\n    mat2\trot = mat2(\n    cos(t),\n        sin(t),\n        -sin(t),\n        cos(t)\n    \n    );\n    \n\tvec4\tteal = vec4(0.3,.7,.9,1.0);\n    vec4\torange = vec4(0.95,.5,.1,1.0);\n    vec2\told;\n    old = uv*3.;\n    uv*=10.;\n    old *= rot;\n    \n    uv = skew(uv);\n\tuv = fract(uv);\n\n    float\tr1 = 1.*.125*sin(t+0.+(old.x+old.y) );\n    float\tr2 = 1.*.125*sin(t+1.57+(old.x+old.y) );\n    o =  teal*(step(uv.y, uv.x) * step(r2, uv.y) );\n    o +=  orange*(step(uv.x, uv.y) * step(r1, uv.x) );\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdXBWX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdXfDj", "name": "Cycloid ~Now Loading~", "author": "Torumu106", "description": "I added one more cycloid.\nIts name is \"Added one more cycloid\"", "tags": ["shader", "cycloid"], "likes": 0, "viewed": 102, "date": "1498027752", "time_retrieved": "2024-06-20T18:57:09.974346", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 r = 2.0 * vec2(uv.x - 0.5, uv.y - 0.5);\n    r.x *= iResolution.x / iResolution.y;\n    vec3 ret = vec3(0.1);\n    vec3 col = vec3(0.8, 0.4, 0.4);\n    for(float i = 0.0; i >= -2.0; i -= 0.1){\n    \tif(length(r - vec2(cos(iTime - i) * 0.8, sin(iTime - i) * 0.8) + vec2(-cos((iTime - i) * 8.0) * 0.1, sin((iTime - i) * 8.0) * 0.1)) <= 0.03){\n    \t\tret = col;\n    \t}\n        if(length(r + vec2(cos(iTime - i) * 0.8, sin(iTime - i) * 0.8) + vec2(-cos((iTime - i) * 8.0) * 0.1, sin((iTime - i) * 8.0) * 0.1)) <= 0.03){\n    \t\tret = col;\n    \t}\n    }\n    \n\tfragColor = vec4(ret,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdXfDj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdXfRl", "name": "025 Derivative Arithmetic 5", "author": "ollj", "description": "unifies an alpha composition\nhttps://www.shadertoy.com/view/4sXfRl\nof 2d gradient differentiation\nhttps://www.shadertoy.com/view/XdffzB\nand 3d automatic differentiation\nhttps://www.shadertoy.com/view/lsffRX", "tags": ["derivative", "alpha", "arithmetic", "mercury", "composition", "hgsdf", "differential", "automaticdifferentiation", "calculus", "lisp"], "likes": 1, "viewed": 619, "date": "1497388944", "time_retrieved": "2024-06-20T18:57:14.762618", "image_code": "//\"024 Derivative Arithmetic 4 & 5\" are a variant of\n// https://www.shadertoy.com/view/XdfBzj\n//\"023 Derivative Arithmetic 3\" with one core change:\n//\n//\"023 Derivative Arithmetic 3\" uses vectors and matrices (and a struct for a mat43)\n//\"024 Derivative Arithmetic 4 & 5\" use different structure, to differentiate 2 arithmetics.\n//Explicit structure adds  symmetry, making things simpler.\n//Explicit structure confuses, mostly due to its atomic defines, and counting from 0.\n//Explicit structure creates \"permutation hell\", as usual.\n//Explicit structure does not slow down performance.\n//\n//This defines implicit 3d Surfaces, or 2d curves, \n//... with ChainRule automatic differentiation Arithmetic, \n//This inevitably makes you write in prefixNotation, like Lisp source code.\n//surely this would look much better in Lisp than in Webgl\n//Still waiting for the Lisp gpu API, and openCL or CUDA are not my thing!\n//... there is \"harlan\" for inspiration, but it is a 2007 non-api thing...\n//\n//\"024 Derivative Arithmetic 5\" has 4 modes (patchwork):\n//to be used in 3d, 2d and 1d.\n//[#define domains 4] overlays its 3d and 2d calculations to a composite.\n//\n//\"024 Derivative Arithmetic 4\" possibly fixed the modulo function's errors?\n//\n//general automatic differentiation is:\n// based on    : https://www.shadertoy.com/view/4dVGzw\n// inspired by : https://www.shadertoy.com/view/Mdl3Ws \n//explained at : http://blog.demofox.org/2014/12/30/dual-numbers-automatic-differentiation/\n//wiki         : https://en.m.wikipedia.org/wiki/Automatic_differentiation\n//summary:     : https://www.reddit.com/r/math/comments/68st6p/the_wikipedia_article_on_automatic/\n//\n//dad: https://www.shadertoy.com/view/4dVGzw\n//but with swiveled parameters:\n//dad: has .xyz as Dfdx() Dfdx() Dfdz(), via automatic differentiation\n//THIS has .d   as Dfdx() Dfdx() Dfdz(), via automatic differentiation +structure\n//\n//brother: https://www.shadertoy.com/view/XlV3Dy\n//brother: Has the goursat_surface, C0-discontinuous isosurface example\n//THIS has derivative arithmetic fields of hg_sdf:\n//  mercury.sexy/hg_sdf/\n//But where a hg_sdf_function returns the distance to point [p].\n//THIS returns distance to point [p] as .x \n//...and N_first_derivatives along N_domains as .d\n//...for point [p]\n//\n//sister: https://www.shadertoy.com/view/MsXBRB\n//focuses on simpler implicit surfaces, is a nicer more constrained introduction.\n\n//Here ends the bad habbit of; starting to count at 1! Start counting at 0!:\n\n//domains 0 <-> 1d //black screen\n//domains 1 <-> 2d\n//domains 2 <-> 3d\n//domains 3 <-> overlay(3d,2d)\n#define domains 3\n\n//#if (domains>1)\n //#define SuperPrim\n //optionally show superprim \n //== https://www.shadertoy.com/results?query=superprim\n #define IterRm 64\n //max raymarch iterations|steps\n \n #define IterSh 16\n //softshadow iterations\n \n #define ReciprocalAbsLipschitz .99\n //if(lipschitzConstant>1., distance is overestimated.\n //multiplying by ReciprocalAbsLipschitz is a \n //... lazy fix for that is scaling stepDistance*=ReciprocalAbsLipschitz\n //higher precision with a smaller ReciprocalAbsLipschitz AND epsilon=0.\n //meaning, a surface will NEVER really be reached.\n //maybe todo: eps=log(eps*b)*a\n\n #define camLens 2.\n #define camRoll 0.\n //camera lens and roll for camera projection matrix (is not a quaternion camera)\n\n//#else\n \n #define camLens 2.\n //view scaling\n\n #define thick .1\n //line thickness (it does nice tangential lines for the first derivative visualisazion, \n //... by using the analytic second derivative)\n//#endif\n\n//--------------------------\n//--------------------------\n\n#define pi acos(-1.)\n\n#define m3 mat4\n#define m2 mat3\n#define m1 mat2\n//the below is basically an [m0]==[m]\n#define v3 vec4\n#define v2 vec3\n#define v1 vec2\n#define v0 float\n//dual number arithmetic structure:\nstruct d {v0 x;v0 d;};//+gradient on 1 domain , is a vec2\nstruct d1{v0 x;v1 d;};//+gradient on 2 domains, is a vec3\nstruct d2{v0 x;v2 d;};//+gradient on 3 domains, is a vec4\n//substiduting \"d0\" to \"d\" is worth it here.\n//above namespaces must be short, try not to confuse a [type] with a [label|pointer].\n//short defines tend to kill compatibility. make no single character defines!\n   \n/*todo, ipmplemnt tripple number arithmetic structure, \n//...for second derivaive automatic differentiation:\n//for all the fun that comes with precise double integrals?\nstruct d22{v0 x;v2 d;v2 d1};//d==1stDerivatives==gradient; d1=2ndDerivatives==Curvature\nstruct d11{v0 x;v1 d;v1 d1};\nstruct d00{v0 x;v  d;v  d1};//substituting d00 to something shorter? bad idea!\n*/\n\n//Explicit structure [.x] utilizes simple (non complex number) arithmetic as you know it.\n//Explicit structure [.d] calculates the first derivative as a byproduct, for each domain.\n//...using the chain rule  https://en.wikipedia.org/wiki/Chain_rule\n//ALL functions get a \"*d\" added to it, wrapping them in this new namespace.\n//By differetiating by type, automatic differentiation includes non-automadic arithmetic.\n//v1 addd(v1 a,v1 b){return a+b;}\n//\n//This inlcusion should enable you do #define a distance field\n//...and that will define it for derivative arithmethic AND non derivative arithmetic.\n//...and you neet to say goodbye to the infix_notation with \"+-*/%^\" operands.\n//and replace it with a proper prefix_notation, like writing in Lisp.:\n//  https://en.wikipedia.org/wiki/Polish_notation\n//a+b*pow(c,d) \n//becomes\n//addd(a,muld(b,powd(c,d)))\n//\n//The \"art\" here is to define an implicit isosurface\n//  https://en.wikipedia.org/wiki/Implicit_surface\n//  https://en.wikipedia.org/wiki/Isosurface\n//...as a(n extended) distance_field equivalent with Arithmetic that\n//...automatically calculate its first derivatives for any point (without multisampling)\n//An overview of that is best explained in\n//  https://www.youtube.com/watch?v=qb40J4N1fa4\n//That way you get all the Contour lines, gradients, normals...\n//  https://en.wikipedia.org/wiki/Contour_line\n//  https://en.wikipedia.org/wiki/Gradient\n//  https://en.wikipedia.org/wiki/Surface_normal\n//...along all the domains (dimensions) of a surface\n//  https://en.wikipedia.org/wiki/Surface_%28topology%29\n//...very cheaply, because the contour is orthoogonal to the gradient.\n//\n// The above \"art\" requires a[Derivative Arithmetic] set \n// for [Automatic Differentiation].\n// Derivative arithmetic [DA] is great for\n//-more precise surface normals and curvature. (better normals on corners)\n//-more precise anti-alasing\n//-faster better gradient|contour calculation. (2d ovals. metaballs)\n//- https://en.wikipedia.org/wiki/Contour_integration\n//-Fluid dynamics, pressure waves (With a buffer over time)\n//-EM-fields: https://en.wikipedia.org/wiki/Surface_integral\n//-all that is in the todo list, at the bottom of this file\n//- https://en.wikipedia.org/wiki/Smoothness\n//- shapes with functions that that lack C0-continuity but have C1-continuity.\n//\n//My [DA] uses a simple namespace:\n//All common arithmetic namespaces get a \"*d\" suffix added.\n//That \"*d\" means \"also calculate first derivatives \n//... for all the domains\".\n//That also increases type float to vec4, and vec3 to \"mat4\" for inOut.\n\n//filling lists with zeroes (seems to make more sese than filling them with (a);\nv1 v0tv1(v0 a){return v1(a,0);}\nv2 v0tv2(v0 a){return v2(a,0,0);}\nv3 v0tv3(v0 a){return v3(a,0,0,0);}\nv2 v1tv2(v1 a){return v2(a,0);}//what to put in .z here? .x or .y or.0?\nd  v0td0(v0 a){return d (a,0.);}\nd1 v0td1(v0 a){return d1(a,v1(0));}\nd2 v0td2(v0 a){return d2(a,v2(0));}\n//filling gradient with zeroes to include more domains.\nd1 d0td1(d  a){return d1(a.x,v0tv1(a.d));}\nd2 d0td2(d  a){return d2(a.x,v0tv2(a.d));}\nd2 d1td2(d1 a){return d2(a.x,v1tv2(a.d));}\n//there is an intuitive problem for the above, for 2 different easily mistaken cases:\n//- A 2d gradient has NULL differential along +1 additional domain.\n//- A vector gets all components scaled when multiplying a vector by a float.\n\n//The 3 (or 2) dimensions|domains \n//...are resolved with [struct DAmN{}] and [da_domain(vN  p)]:\n//where N=number of domains, range [0..3]\nstruct DAm2{d2 x;d2 y;d2 z;};//for 3 domains (density/distance field)\nDAm2 da_domain(v2 p){return DAm2(d2(p.x,v2(1,0,0)),\n                                 d2(p.y,v2(0,1,0)),\n                                 d2(p.z,v2(0,0,1)));}\nstruct DAm1{d1 x;d1 y;};//for 2 domains (heightmap, isoline, contour)\n//https://en.wikipedia.org/wiki/Contour_line\nDAm1 da_domain(v1 p){return DAm1(d1(p.x,v1(1,0)),\n                                 d1(p.y,v1(0,1)));}\nstruct DAm0{d x;};//for 1 domain (linear equation)\nDAm0 da_domain(v0 p){return DAm0(d (p  ,   1.));}\n//I will likely replace these with mat4, mat3 mat2.\n//Not sure yet, but it would make things simpler.\n\n#define sat(a) clamp(a,0.,1.)\n//This lets you derive over up to 3 dimensions at once OR seperately, \n//...using very self-similar dual-function variants:\n//#define pow2d(a) d2(muld(a.x,a.x),muld(a,2.))\n#define pow2d(a) muld(a,a)\n//above pow2() is very special and simple derivative arithmetic \n//... that should tell you what is going on with all the other \n//... dual number arithmetic functions below.\n//operations with only 1 input parameter are the simplest.\n\n//special case of component wise multiplication, special because a.x==1:\nd  cmd(d a,v0 b){return d (a.x,a.d*b);}\nd1 cmd(d a,v1 b){return d1(a.x,a.d*b);}\nd2 cmd(d a,v2 b){return d2(a.x,a.d*b);}\n//#define rmd {return cmd\nd  absd(v0 a){return   d(abs (a  ),sign(a  ));}\nd  absd(d  a){return cmd(absd(a.x),a.d);}//d (abs(a.x),sign(a.x)*a.d);}\nd1 absd(d1 a){return cmd(absd(a.x),a.d);}//d1(abs(a.x),sign(a.x)*a.d);}\nd2 absd(d2 a){return cmd(absd(a.x),a.d);}//d2(abs(a.x),sign(a.x)*a.d);}\n\nd  sind(v0 a){return d (sin(a  ),cos(a  ));}\nd  sind(d  a){return d (sin(a.x),cos(a.x)*a.d);}\nd1 sind(d1 a){return d1(sin(a.x),cos(a.x)*a.d);}\nd2 sind(d2 a){return d2(sin(a.x),cos(a.x)*a.d);}\nd  cosd(v0 a){return d (cos(a  ),-sin(a  ));}\nd  cosd(d  a){return d (cos(a.x),-sin(a.x)*a.d);}\nd1 cosd(d1 a){return d1(cos(a.x),-sin(a.x)*a.d);}\nd2 cosd(d2 a){return d2(cos(a.x),-sin(a.x)*a.d);}\nd  logd(d  a){return d (log(a.x),a.d/a.x);}\nd1 logd(d1 a){return d1(log(a.x),a.d/a.x);}\nd2 logd(d2 a){return d2(log(a.x),a.d/a.x);}\nd  expd(d  a){v0 x=exp(a.x);return d (x,x*a.d);}\nd1 expd(d1 a){v0 x=exp(a.x);return d1(x,x*a.d);}\nd2 expd(d2 a){v0 x=exp(a.x);return d2(x,x*a.d);}\n//sqrt() and divisions require a worksave reciprocal operator:\nv0 rec(float a){return (a==0.)?a:1./a;}//return [1/a] , work safe\n//single parameter operations are MUCH simpler here:\nd  sqrtd(d  a){v0 q=sqrt(a.x);return d (q,.5*rec(q)*a.d);}\nd1 sqrtd(d1 a){v0 q=sqrt(a.x);return d1(q,.5*rec(q)*a.d);}\nd2 sqrtd(d2 a){v0 q=sqrt(a.x);return d2(q,.5*rec(q)*a.d);}\n//        pow (x,y) exp (     log (x)*y )//wait till we define muld()\n//#define powd(x,y) expd(muld(logd(x),x))//wait till we define muld()\n\n//i am not too sure about my implementation on fractd();\n//the hell, just use modd() instead, modd() has VERY nice first derivatives!\n//reminder that the fract function's first derivative has a \"kick\" on (mod(a,1)==0.0)\nv0 djum(v0 a){return mix(a,-1.,step(fract(a),0.)*step(0.,fract(a)));}\nv1 djum(v1 a){return v1(djum(a.x),djum(a.y));}\nv2 djum(v2 a){return v2(djum(a.x),djum(a.y),djum(a.z));}\n//i should definitely define this by fract, and not by floor.\n//because fm-modulation taught me that i need fract() a lot more than floor()\nd2 fractd(d2 a){return d2(floor(a.x),djum(a.d));}\nd1 fractd(d1 a){return d1(floor(a.x),djum(a.d));}\nd  fractd(d  a){return d (floor(a.x),djum(a.d));}\n//very slightly lower precision? rarely relevant. fract() has great precision on float!\n#define floord(a) subd(a,fractd(a))\n\n//derivatives of functions with 2 input parameters are trickier:\n//  https://en.wikipedia.org/wiki/Multivariable_calculus\n//There are exponential many permutations of modd() mixd() mind()\n\n//modd ideally should be replaced by fractd(), but that adds 1dvd() and 1muld()\n//... but chain rule division (reciprocal product rule) on a custom type is so bad.\n//... that for derivative arithmetic, modd(a,b) outperforms muld(fractd(divd(a,b)),b)\n//v4 modd(v4 a,v4 b){return v4(mod(a.x,b.x),mod(a.yzw,1.));}\n//v4 modd(v4 a,v1 b){return v4(mod(a.x,b  ),mod(a.yzw,1.));}\n//v4 modd(v1 a,v4 b){return v4(mod(a  ,b.x),0,0,0        );}\n//#define modo(a,b) fract(a/b)*b /*what mod(a,b) actually does*/\n#define may fract(a.d));}\n#define maz mod(a.x,b),may\n#define mab mod(a.x,b.x)\nd2 modd(d2 a,v0 b){return d2(maz\nd1 modd(d1 a,v0 b){return d1(maz\nd  modd(d  a,v0 b){return d (maz\nd  modd(d  a,d  b){return d (mab,may\nd2 modd(d2 a,d  b){return d2(mab,may\nd2 modd(d2 a,d2 b){return d2(mab,may\nd2 modd(d2 a,d1 b){return d2(mab,may\nd2 modd(d  a,d2 b){return d2(mab,v2(0));}\nd2 modd(d1 a,d2 b){return d2(mab,v2(0));}\nd2 modd(v0 a,d2 b){return d2(mod(a,b.x),v2(0));}\nd1 modd(v0 a,d1 b){return d1(mod(a,b.x),v1(0));}\nd  modd(v0 a,d  b){return d (mod(a,b.x),   0.);}\n//mmixd is subroutine for mind(), which is used as branch. mix(n1,n2,step(m,0.))\nv0 mixd(v0 a,v0 b,v0 c){return mix(a,b,c);}\nv1 mixd(v1 a,v1 b,v0 c){return mix(a,b,c);}\nv2 mixd(v2 a,v2 b,v0 c){return mix(a,b,c);}\nv3 mixd(v3 a,v3 b,v0 c){return mix(a,b,c);}\n//v1 mixd(v0 a,v1 b,v0 c){return mix(v0tv1(a),b,c);} oh my permutations...\nd  mixd(d  a,d  b,v0 c){return d (mix(a.x,b.x,c),mix(a.d,b.d,c));}\nd1 mixd(d1 a,d1 b,v0 c){return d1(mix(a.x,b.x,c),mix(a.d,b.d,c));}\nd2 mixd(d2 a,d2 b,v0 c){return d2(mix(a.x,b.x,c),mix(a.d,b.d,c));}\nd1 mixd(d  a,d1 b,v0 c){return mixd(d0td1(a),b,c);}\nd2 mixd(d  a,d2 b,v0 c){return mixd(d0td2(a),b,c);}\nd2 mixd(d1 a,d2 b,v0 c){return mixd(d1td2(a),b,c);}\nd1 mixd(d1 a,d  b,v0 c){return mixd(a,d0td1(b),c);}\nd2 mixd(d2 a,d1 b,v0 c){return mixd(a,d1td2(b),c);}\nd2 mixd(d2 a,d  b,v0 c){return mixd(a,d0td2(b),c);}\n//the return of Fortran's \"XIF(m,n1,n2)===(m==0)?n1:n2===mix(n1,n2,step(m,0.)*step(0.,m))\n//ecept it compares if (a.x>b.x)\n#define min1 {return mixd(b,a,step(a.x,b.x));}\n#define min3 {return mind(b,a);}\n//I define mind() and -maxd(-,-) instead of maxd() and -mind(-,-)\n//because min() is far more common than max(), for z-buffering.\nd2 mind(d2 a,d2 b)min1\nd2 mind(d1 a,d2 b)min1\nd2 mind(d  a,d2 b)min1\nd2 mind(d2 a,d1 b)min1\nd2 mind(d2 a,d  b)min1\nd1 mind(d1 a,d1 b)min1\nd1 mind(d  a,d1 b)min1\nd  mind(d  a,d  b)min1\nd2 mind(v0 a,d2 b){return mixd(v0td2(a),b,step(b.x,a));}\nd2 mind(d2 a,v0 b){return mixd(v0td2(b),a,step(a.x,b));}\nd1 mind(v0 a,d1 b){return mind(v0td1(a),b);}\nd  mind(v0 a,d  b){return mind(v0td0(a),b);}\nd  mind(v0 a,v0 b){return v0td0(min(a,b));}\nd1 mind(d1 a,d  b)min3\nd1 mind(d1 a,v0 b)min3\nd  mind(d  a,v0 b)min3\n//negation identity: max(a,b)=-min(-a,-b), requires struct negation\nd2 negd(d2 a){return d2(-a.x,-a.d);}\nd1 negd(d1 a){return d1(-a.x,-a.d);}\nd  negd(d  a){return d (-a.x,-a.d);}\nv0 negd(v0 a){return -a;}\n#define maxd(a,b) negd(mind(negd(a),negd(b)))\n//3-domain matrix tripples:\nDAm2 maxdm(DAm2 a,v2 p){\n return DAm2(maxd(a.x,p.x),maxd(a.y,p.y),maxd(a.z,p.z));}\nDAm2 mindm(DAm2 a,v2 p){\n return DAm2(mind(a.x,p.x),mind(a.y,p.y),mind(a.z,p.z));}\nDAm2 maxdm(DAm2 a,v0 p){return maxdm(a,v2(p));}\nDAm2 mindm(DAm2 a,v0 p){return mindm(a,v2(p));}//needed for fast clamping\nd2 maxdm(d2 a,d2 b,d2 c){return maxd(maxd(a,b),c);}\nd2 maxdm(DAm2 a){return maxdm(a.x,a.y,a.z);}\n\n/*\nv4 subd(v4 a,v4 b){return a-b;}\nv4 subd(v4 a,v1 b){return v4(a.x-b  , a.yzw);}\nv4 subd(v1 a,v4 b){return v4(a  -b.x,-b.yzw);}\nv4 addd(v4 a,v4 b){return a+b;}\nv4 addd(v4 a,v1 b){return subd(a,-b);}//addition as invrse substraction\nv4 addd(v1 a,v4 b){return subd(a,-b);}\n*/\n//substraction is simple, because \"differentiation equals integration\"\n//  https://en.wikipedia.org/wiki/Cauchy_integral_formula\n//...making the implementation of the chain rule much simpler for:\n//  https://en.wikipedia.org/wiki/Translation_(geometry)\nd2 subd(d2 a,d2 b){return d2(a.x-b.x,a.d-b.d);}//3d translation\nd1 subd(d1 a,d1 b){return d1(a.x-b.x,a.d-b.d);}//2d translation\nd  subd(d  a,d  b){return d (a.x-b.x,a.d-b.d);}//1d translation\nd2 subd(d2 a,v0 b){return d2(a.x-b  ,a.d);}\nd2 subd(d2 a,d  b){return d2(a.x-b.x,a.d);}\nd2 subd(d2 a,d1 b){return d2(a.x-b.x,a.d);}\nd1 subd(d1 a,v0 b){return d1(a.x-b  ,a.d);}\nd1 subd(d1 a,d  b){return d1(a.x-b.x,a.d);}\nd  subd(d  a,v0 b){return d (a.x-b  ,a.d);}                           \nd2 subd(v0 a,d2 b){return d2(a  -b.x,-b.d);}\nd2 subd(d  a,d2 b){return d2(a.x-b.x,-b.d);}\nd2 subd(v3 a,d2 b){return d2(a.x-b.x,-b.d);}\nd1 subd(v0 a,d1 b){return d1(a  -b.x,-b.d);}\nd1 subd(d  a,d1 b){return d1(a.x-b.x,-b.d);}\nd  subd(v0 a,d  b){return d (a  -b.x,-b.d);}\n//glide-translations along multiple domains:\nDAm2 subd(DAm2 p,v2 s){return DAm2(subd(p.x,s.x),\n                                   subd(p.y,s.y),\n                                   subd(p.z,s.z));}\nDAm1 subd(DAm1 p,v1 s){return DAm1(subd(p.x,s.x),\n                                   subd(p.y,s.y));}\nDAm0 subd(DAm0 p,v0 s){return DAm0(subd(p.x,s));}\n//subd(absd(p),s) equals a translation away from the origin by [s]\n//... AND mirroring at origin, via abs() \n//... so it it clamps a an implicit surface to a limited \"thickness\"\n//(in 3 domains),also translating its first derivatives.\nd2 subdabsd(d2 p,float s){return subd(absd(p),s);}\nd1 subdabsd(d1 p,float s){return subd(absd(p),s);}\nd  subdabsd(d  p,float s){return subd(absd(p),s);}\nDAm2 subdabsd(DAm2 p,v2 s){return DAm2(subdabsd(p.x,s.x),\n                                       subdabsd(p.y,s.y),\n                                       subdabsd(p.z,s.z));}\nDAm1 subdabsd(DAm1 p,v1 s){return DAm1(subdabsd(p.x,s.x),\n                                       subdabsd(p.y,s.y));}\nDAm0 subdabsd(DAm0 p,v0 s){return DAm0(subdabsd(p.x,s));}\n//addition is negated substraction.\n#define addd(a,b) subd(a,negd(b))\n#define adddabsd(a,b) subdabsd(a,negd(b))\n\n//automatic_differentiation_multiplication applies the product rule within the chain rule\n//  https://en.wikipedia.org/wiki/Product_rule\n/*\nv4 muld(v4 a,v4 b){return v4(a.x*b.x,a.yzw*b.w+a.x*b.yzw);}\nv4 muld(v4 a,v1 b){return a*b;}\nv4 muld(v1 a,v4 b){return a*b;}\nv4 divd(v4 a,v4 b){return v4(a.x/b.x,(a.yzw*b.x-a.x*b.yzw)/(b.x*b.x));}\nv4 divd(v4 a,v1 b){return a/b;}\nv4 divd(v1 a,v4 b){return v4(a/b.x,(-a*b.yzw)/(b.x*b.x));} \n*/\n#define atb a.x*b,a.d*b);}\n#define mdb b){return muld(b,a);}\nd2 muld(d2 a,v0 b){return d2(atb\nd1 muld(d1 a,v0 b){return d1(atb\nd  muld(d  a,v0 b){return d (atb\nd2 muld(v0 a,d2 mdb //mdb is the commutative inverse of the 3 above ones\nd1 muld(v0 a,d1 mdb\nd  muld(v0 a,d  mdb//scalar multiplication is tautological product_rule.\nd2 muld(d2 a,d2 b){return d2(a.x*b.x,a.d*b.x+a.x*b.d);}\nd1 muld(d1 a,d1 b){return d1(a.x*b.x,a.d*b.x+a.x*b.d);}\nd  muld(d  a,d  b){return d (a.x*b.x,a.d*b.x+a.x*b.d);}\nd1 muld(d  a,d1 b){return d1(a.x*b.x,a.d*b.x+a.x*b.d);}\nd1 muld(d1 a,d  b){return d1(a.x*b.x,a.d*b.x+a.x*b.d);}\n//d2 muld(d2 a,d1 b){return d2(a.x*b.x,a.d*b.x+a.x*b.d);}//nonsense?\nd2 muld(d2 a,d  b){return d2(a.x*b.x,a.d*b.x+a.x*b.d);}\n//d2 muld(d1 a,d2 b){return d2(a.x*b.x,a.d*b.x+a.x*b.d);}//nonsense?\nd2 muld(d  a,d2 b){return d2(a.x*b.x,a.d*b.x+a.x*b.d);}\nDAm2 muld(DAm2 p,v2 s){return DAm2(muld(p.x,s.x),\n                                         muld(p.y,s.y),\n                                         muld(p.z,s.z));}\nDAm1 muld(DAm1 p,v1  s){return DAm1(muld(p.x,s.x),\n                                         muld(p.y,s.y));}\nDAm0 muld(DAm0 p,v0 s){return DAm0(muld(p.x,s));}\n//reciprocal derivatives are most confusing.\n#define atc a.x/b,a.d/b);}\nd2 divd(d2 a,v0 b){return d2(atc\nd1 divd(d1 a,v0 b){return d1(atc\nd  divd(d  a,v0 b){return d (atc//inverse scalar multiplication is a tautolotgy.\n#define bxx /(b.x*b.x));}\nd2 divd(v0 a,d2 b){return d2(a  /b.x,(-a  *b.d)bxx\nd2 divd(d  a,d2 b){return d2(a.x/b.x,(-a.x*b.d)bxx\nd2 divd(d1 a,d2 b){return d2(a.x/b.x,(-a.x*b.d)bxx\nd2 divd(d2 a,d2 b){return d2(a.x/b.x,(a.d*b.x-a.x*b.d)bxx\n//d2 divd(d2 a,d1 b){return d2(a.x/b.x,(a.d*b.x-a.x*b.d)bxx//nonsense?\n//d2 divd(d2 a,d  b){return d2(a.x/b.x,(a.d*b.x-a.x*b.d)bxx//nonsense?\n//All exponential functions utilize their Base_E_identity:\n//...which is still not efficient, but comes doen to O(exp(n*log(n)))\n//      pow (x,y)==exp(     log (x)*y )//baseE exponential and logarythmic functions.\n#define powd(x,y) expd(muld(logd(x),x))\n\n//It gets trickier with functions that take 3 parameters:, applying the\n//  https://en.wikipedia.org/wiki/Triple_product_rule\n//Euclidean distance (pythagorean theorem) with first derivatives.\n#define v0q v0 q=length(v1(x.x,y.x))\n#define ll2 q,(x.d*x.x+y.d*y.x)*rec(q));}\nd  lengthd(d  x,d  y){v0q;return d (ll2\nd1 lengthd(d1 x,d1 y){v0q;return d1(ll2\nd2 lengthd(d2 x,d2 y){v0q;return d2(ll2\nd2 lengthd2(DAm2 u){return lengthd(u.x,u.y);}//2*3domain\n//above is planar length 2 input parameters. below is 3d length.\nd2 lengthd(d2 x,d2 y,d2 z){float q=length(v2(x.x,y.x,z.x));\n return d2(q,(x.d*x.x+y.d*y.x+z.d*z.x)*rec(q));}\nd2 lengthd(DAm2 u){return lengthd(u.x,u.y,u.z);}//3*3domain\n//the utility of a length() function is clear.\n\n//these branchless comparators compare [c] with [0.0] to return [a]==true or [b]==false;\n#define step2 step(c,0.)+step(0.,c)-1.)\n//above is based on   https://www.reddit.com/r/askmath/comments/6aag2g/simplifying_stepa00step00a/\n//(a> 0)?b:c\n#define greater(a,b,c)   mix(a,b,step(c,0.))\n//(a< 0)?b:c\n#define less(a,b,c)      mix(a,b,step(0.,c))\n//(a==0)?b:c\n#define equals(a,b,c)    mix(b,a,step2\n//(a!=0)?b:c\n#define unequal(a,b,c)   mix(a,b,step2\n//(a>=0)?b:c  \"unless   \"=not less   ==greater OR equal\n#define unless(a,b,c)    mix(b,a,step(0.,c))\n//(a<=0)?b:c  \"ungreater\"=not greater==less    OR equal\n#define ungreater(a,b,c) mix(b,a,step(c,0.))\n// https://www.shadertoy.com/view/XssfRf\n                                    \n//atan2() is a bit tricky, thankfully commonly only defined for vec2.\nv0 atand(v0 a){return atan(a);}//atan(x/y) has limited range and is non branching.\n//wrapping for namespace sake, for automatic differentiation:\n//first defivative of f(x)=atan(x) is f(x)=1/x*x+1\nd2 atand(d2 a){\n    float b=atan(a.x);\n    d2 e=pow2d(a);\n    e=addd(e,1.);\n    e=divd(1.,e);\n    //e=divd(1.,addd(pow2d(a),1.));\n    return d2(b,e.d);}\n\n//todo, copy\n//https://www.shadertoy.com/view/MdsBRX\n                                    \n//expliicit atan2() //https://en.wikipedia.org/wiki/Atan2\nv0 atand(v0 x,v0 y){//return atan(y,x);//2 branches, goes full circle.\n if(x >0.)return atan(y/x);\n if(y >0.)return  pi*.5-atan(x/y);\n if(0.>y )return -pi*.5-atan(x/y);\n if(0.>x )return  pi   +atan(y/x);\n return 0.;\n}\nv0 atand(v1 a){return atand(a.y,a.x);}\n//but that means it only cares for 2 domains?\nd1 atand(d1 a,d1 b){return a;\n}\n\n//and then it gets more and more tricky: \n// Chain rule Derivative of dot() appears tricky: this should work, untested:\nd2 dotd(DAm2 a, DAm2 b){d2 t0=muld(a.x,b.x),t1=muld(a.y,b.y),t2=muld(a.z,b.z); \n return addd(addd(t0,t1),t2);}\n\n\n//using the above, we define distance functions \n//...that automatically also return the gradient at [p].\n//the gradient is multiple first derivatives along multiple domains\n//... like Dfdx() and Dfdy(), and we also have Dfdz()...\n//... except much cheaper, due to many things canceling out each other.\n//This makes surfaces that are C0-discontinuous, like y=fract(x), \n//...at least have their first derivate calculated continuously,\n//... as long as they are C1-continuous,\n//which can be useful for raymarching:\n\n//Below are translations of the hg_sdf library\n//...to use the above Derivative Arithmetic\n//...serving as examples. on how to translate between 2 arithmetics.\n\n//return distance to unit sphere\nd2 fSphere(DAm2 p){d2 q=lengthd(p.x,p.y,p.z);return subd(q,1.);;}\n//return distance to infinite line segment\nd2 fRay(DAm2 p){p.x.x=mix(0.,p.x.x,step(p.x.x,0.));\n d2 q=lengthd(p.x,p.y,p.z);return subd(q,1.);}//this might be \"broken\" now.\n//fRay() was an error that I chose to keep.\n\n//return distance to box size (s),\n//... corners extrude, keeping all agngles, underestimating distances.\nfloat fBoxCheap(v2 p,v2 b){\n v2 q=abs(p);q=q-p;//mirror clamp\n return max(max(q.x,q.y),q.z);}\nd2 fBoxCheap(DAm2 p,v2 s){\n DAm2 u=subdabsd(p,s);//mirror clamp\n return maxdm(u);}  \n//return distance to box size (s), corners extrude to rounded spheres.\nfloat fBox(vec3 p,vec3 s){\n v2 d=abs(p)-s;//mirror clamp\n v0 a=length(max(d,0.));//rounded corners\n v2 q=min(d,0.);//clamp\n v0 b=max(max(q.x,q.y),q.z);//keep largest of 3\n return a+b;}//add //hg_sdf\nd2 fBox(DAm2 p,v2 s){//v3 s=v3(1.5,.5,1.5);\n DAm2 d=subdabsd(p,s);//mirror clamp\n d2 a=lengthd(maxdm(d,0.));//rounded corners\n DAm2 q=mindm(d,0.);//clamp\n d2 b=maxdm(q);//keep largest of 3\n return addd(a,b);}//add\n             \n//A more readable version of a very parametric implicit surface.\n//...that does not look as much like LISP code, but at its core is just like that.\n//One operation per line keeps it BASIC and modifiable.\nd2 sdSuperprim(DAm2 p, v3 s,vec2 r) {\n //vec2 r=vec2(.2,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 dx,dy,dz,d,e,f,q,a,b,c;\n //dy=vec4(0);dz=vec4(0);d=vec4(0);\n //e=vec4(0);f=vec4(0);q=vec4(0);\n //a=vec4(0);b=vec4(0);c=vec4(0);\n d2 dx=subdabsd(p.x,s.x);\n d2 dy=subdabsd(p.y,s.y);\n d2 dz=subdabsd(p.z,s.z);\n \n d2 d=addd(dx,r.x);d=maxd(d,0.);\n d2 e=addd(dy,r.x);e=maxd(e,0.);\n d2 q=lengthd(d,e);\n d2 f=maxd(dx,dy);f=mind(-r.x,f);\n \n q=addd(q,f);\n q=addd(q,s.w);\n q=absd(q);\n q=subd(q,s.w);\n ///return...\n d2 a=addd(q ,r.y);a=maxd(a,0.);    \n d2 b=addd(dz,r.y);b=maxd(b,0.);a=lengthd(a,b);\n d2 c=mind(-r.y,maxd(q,dz));c=addd(a,c);\n return c;}\n\n\n\n//getfactor() cycles trough example input parameters for sdSuperprim() \n#define SHAPE_COUNT 10.0\nvoid getfactor (int i,out vec4 s,out vec2 r){\n       if(i==0){s=vec4(1)           ;r=vec2(0)     ;//cube\n }else if(i==1){s=vec4(vec3(1),.25) ;r=vec2(0)     ;//corridor\n }else if(i==2){s=vec4(vec3(1),.25) ;r=vec2(1)     ;//pipe\n }else if(i==3){s=vec4(1)           ;r=vec2(1,0)   ;//cylinder\n }else if(i==4){s=vec4(1,1,2,1)     ;r=vec2(1)     ;//pill\n }else if(i==5){s=vec4(1)           ;r=vec2(1)     ;//sphere\n }else if(i==6){s=vec4(1,1,.25,1)   ;r=vec2(1,.25) ;//pellet\n }else if(i==7){s=vec4(1,1,.25,.25) ;r=vec2(1,.25) ;//torus\n }else if(i==8){s=vec4(2,.5,.25,.25);r=vec2(.5,.25);//sausage mouth\n }else if(i==9){s=vec4(.7,1,1,.25)  ;r=vec2(.125)  ;//beveled O\n}}//  https://www.shadertoy.com/results?query=superprim\n                             \n                             \nfloat fOpUnionRound(float a,float b,float r){\n vec2 u=max(vec2(r-a,r-b),0.);return max(r,min(a,b))-length(u);}     \nd2 fOpUnionRound(d2 a,d2 b,v0 r){\n d2 x=subd(r,a);x=maxd(x,0.);\n d2 y=subd(r,b);y=maxd(y,0.);x=lengthd(x,y);\n d2 m=mind(a,b);m=maxd(r,m);return subd(m,x);}\n//does not seem to have good lipschitz.\nfloat fOpIntersectionRound(float a,float b,float r){\n  vec2 u=max(vec2(r+a,r+b),0.);return min(-r,max(a,b))+length(u);}\nd2 fOpIntersectionRound(d2 a, d2 b,float r){\n d2 x=addd(r,a);x=maxd(x,0.);\n d2 y=addd(r,b);y=maxd(y,0.);x=lengthd(x,y);\n d2 m=maxd(a,b);m=mind(-r,m);return addd(m,x);}\n#define fOpDifferenceRound(a,b,r) fOpIntersectionRound(a,negd(b),r)\n\n\nfloat pMod1(inout float p,float s){p/=s;\n float c=floor((p)+.5);p=(fract(p+.5)-.5)*s;return c;}\nd2 pMod1(d2 p,v0 s){p=divd(p,s);\n //vec4 c=floord4(p);//c=subd(c,.5);//float c=floor((p)+.5);\n p=addd(p,.5);p=fractd(p);p=subd(p,.5);p=muld(p,s);//p=(fract(p+.5)-.5)*s;\n return p;}\n\n//#if (domains>1)\n /*\n vec2 pR45(vec2 p){return (p+vec2(p.y,-p.x))*sqrt(.5);}\n mat4 pR45(mat4 p){float s=sqrt(.5);\n  p[0]=addd(p[1],p[0]);p[0]=muld(p[0],s);\n  p[1]=subd(p[1],p[0]);p[1]=muld(p[0],s);return p;}\n                              \n //commented out, because it apperrs broken:\n //my fract() <- mod() is likely nonsense!\n //float fOpDifferenceColumns _M(-1.)\n //                             p.y+=c;p.x-=0.70710678118*(r+c);if(mod(n,2.)==1.)p.y+=c;pMod1(p.y,c*2.);return-min(min(max(-length(p)+c,p.x),a),b);}\n //#define fOpIntersectionColumns(a,b,r,n) fOpDifferenceColumns(a-b,r,n)\n /*\n //unknown error\n float fOpUnionColumns(float a, float b, float r, float n) { \n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n\t\tpR45(p);\n\t\tp.x -= sqrt(2.)/2.*r;\n\t\tp.x += columnradius*sqrt(2.);\n\t\tif (mod(n,2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\t// At this point, we have turned 45 degrees and moved at a point on the\n\t\t// diagonal that we want to place the columns on.\n\t\t// Now, repeat the domain along this direction and place a circle.\n\t\tpMod1(p.y, columnradius*2.);\n\t\tfloat result = length(p) - columnradius;\n\t\tresult = min(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn min(result, b);\n\t} else {\n\t\treturn min(a, b);\n\t}\n }\n v4 fOpUnionColumns(v4 a, v4 b, float r, float n) {\n  if(a.x<r&&b.x<r){\n   mat4 p=mat4(a,b,0,0,0,0,0,0,0,0);\n   float columnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n   p=pR45(p);\n   p[0]=subd(p[0],sqrt(2.)/2.*r);\n   p[0]=addd(p[0],columnradius*sqrt(2.));\n   if (mod(n,2.) == 1.) {\n    p[1]=addd(p[1],columnradius);\n   }\n   p[1]=pMod1(p[1],columnradius*2.);\n   vec4 r=lengthd(p[0],p[1]);\n   r=subd(r,columnradius);\n   r=mind(r,p[0]);\n   r=mind(r,a);\n   r=mind(r,b);\n   return r;\n  }\n  return mind(a,b);\n }\n */\n                             \n                             /*\n //also fails\n // The \"Stairs\" flavour produces n-1 steps of a staircase:\n // much less stupid version by paniq\n float fOpUnionStairs(float a, float b, float r, float n) {\n     float s=r/n; \n     b=b-r; \n     float d=b-a+s;\n     d=mod(d,2.*s);\n     d=d-s;\n     d=abs(d);\n     d=b+a+d;\n     d=d*.5;      \n     return min(min(a,b),d);\n }\n v4 fOpUnionStairs(v4 a, v4 b, float r, float n) {\n     float s=r/n;\n     b=subd(b,r);\n     a=subd(b,a);\n     a=addd(a,s);//float d=b-a+s;\n     vec4 d=modd(a,2.*s);//d=mod(d,2.*s);\n     d=subd(d,s);\n     d=absd(d);\n     d=addd(a,d);\n     d=addd(b,d);\n     d=muld(d,.5);  \n     d=mind(d,a);\n     d=mind(d,b);\n     return d;\n\t return min(min(a,b),d);\n }\n\n // We can just call Union since stairs are symmetric.\n float fOpIntersectionStairs(float a, float b, float r, float n) {\n     return -fOpUnionStairs(-a, -b, r, n);\n }\n\n float fOpDifferenceStairs(float a, float b, float r, float n) {\n     return -fOpUnionStairs(-a, b, r, n);\n }\n */\n\n\n //demo playground for boolean unions of implicit surfaces.\n d2 aBool(DAm2 p){\n  d2 box=fBoxCheap(p,vec3(1));\n  p=subd(p,vec3(-1,1,1));//p.x=addd(p.x,1.);p.y=subd(p.y,1.);p.z=subd(p.z,1.);\n  d2 box2=fBox(p,vec3(1));\n  //return mind(box,box2);//(box or     box2)\n  //return maxd(box,box2);//(box and     box2)\n  //return maxd(box,-box2);//(box and not box2)\n  return fOpUnionRound(box,box2,1.);\n  //return fOpIntersectionRound(box,box2,.3);\n  //return fOpDifferenceRound(box,box2,.5);\n  //return box;\n }\n \n //set camera position & target\n void setCam(out vec3 o,out vec3 i,v0 t,v0 m){\n  o=vec3(4.*sin(t),m*9.-2.,4.*cos(t));i=vec3(0);}\n\n struct DAMValue{d2 d;float m;};//to paint the gradient on a plane.\n DAMValue min2(DAMValue a, DAMValue b){if(a.d.x>b.d.x)return b;return a;}\n DAMValue plane(DAm2 p){return DAMValue(addd(p.y,1.),1.);}\n //DAMValue add_plane(DAVec3 p,DAMValue m){return min2(plane(p),m);}\n \n  #define ss01(a) smoothstep(0.,1.,a) \n  #define imsc(a) int(mod(a,SHAPE_COUNT))\n  //return distance to surface of DistanceField\n  DAMValue df(DAm2 p){d2 r;\n  #ifndef SuperPrim\n   //simpler more static parametric surfaces:\n   r=aBool(p);\n   //r=fSphere(p);\n   //r=fBox(p,vec3(1));\n   //r=fBoxCheap(p,vec3(1));\n   float holesize=mix(.6,5.,sin(iTime*3.)*.5+.5);\n   d2 s=fSphere(muld(p,vec3(holesize)));r=maxd(r,negd(s));\n   //scaling by holesize is bad for lipschitz constant.\n  #else\n   //superprim() is a very parametric implicit surface.\n   float t=iTime,u=ss01(ss01(fract(t)));\n   vec4 a,b;vec2 c,d;\n   getfactor(imsc(t   ),a,c);\n   getfactor(imsc(t+1.),b,d);\n   DAm2 q=DAm2(p.y,p.z,p.x);\n   if(iMouse.z>.5){\n    vec2 m=iMouse.xy/iResolution.xy;\n    r=sdSuperprim(q,vec4(vec3(1.0),mix(a.x,b.x,u)),m);\n   }else\n    r=sdSuperprim(q,mix(a,b,u),mix(c,d,u));\n  #endif\n   //return DAMValue(r,0.);\n   return min2(plane(p),DAMValue(r,0.));}\n \n //return distance & materialID\n vec2 dm(v2 p){DAMValue d=df(da_domain(p));return vec2(d.d.x,d.m);}\n //return material at p with normal n\n vec4 material(v2 p,v2 n ){d2 d=df(da_domain(vec3(p.x,0.,p.z))).d;\n  return mix(vec4(n*.5+.5,.1)\n            ,vec4(d.d*.5 +.5,.0)*abs(mod(d.x,.1)/.1-.5)\n            ,sat(dm(p).y));} \n\n //return soft shadow of light source at [o], \n //... with light direction [i] pointing from [o] to surface point [p]\n float shadow(v2 o,v2 i){\n  const float a=32.;//shadow hardnes\n  float r=1.,h =1.,t=.0005;//t=(self)intersection avoidance distance\n  for(int j=0;j<IterSh;j++){\n   h=dm(o+i*t).x;\n   r=min(r,h*a/t);\n   t+=clamp(h,.02,2.);}//limit max and min stepping distances\n  return clamp(r,0.,1.);}\n //  www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\n\n //return p, modified by light , shadow, envMap...\n v2 light(vec3 p,vec3 n,vec3 i,float d,vec4 m){\n  v2 l=normalize(v2(1.,.7,.9));//light direction\n  v0 o=max(0.,dot(n,l)),\n  c=max(0.,dot(n,normalize(l-i))),\n  s;if(c>.01)s=shadow(p+.01*n,l); \n  const v2 LigCol=vec3(1.);//light color\n  v2 r=m.rgb*(LigCol+o*vec3(.8,.7,.6)*s*3.+vec3(.2,.3,.3));  \n  r+=s*c*pow(o,40.);//specular\n  //r+=m.x*texture(iChannel0, reflect(i,n)).rgb;//environment map\n  r*=exp(-.01*d*d);//fog  \n  return r;}\n\n //return distance along ray (raymarch till surface)\n float rm(v2 o,v2 i){\n  const float m=20.;//distance.Max\n  float e=.0,h=e,t=0.;//intersection.precission\n  for(int j=0;j<IterRm;j++){\n   if(h<e)break;if(t>m)return -1.;\n           //wait a moment, do i not have the lipschitz for the point\n      //or at least 3 for 3 domains of the point\n      //by using [DA]?\n      //i mean, i could really insert this here, right?\n      //and substitute ReciprocalAbsLipschitz with \"1/da_length(dm(o+i*t).yzw)\"\n   //i am pretty sure that i am missing a dotproduct here\n   //the gradient must be dorproducted onto the ray direction?\n   DAMValue s=df(da_domain(o+i*t));\n   float r=ReciprocalAbsLipschitz;\n   //r=1./length(dot(s.d.yzw,i));//overwriting with a VERY LOCAL lipschitz constant\n      //its not a good estimate, but it is a LOT better?\n      //nah it totally fails for concave isosurfaces.\n   h=s.d.x*r;t+=h;}return t;}\n \n  //return camera matrix\n  mat3 calcLookAtMatrix(in vec3 o,in vec3 i,in float r ){\n   vec3 w=normalize(i-o);vec3 u=normalize(cross(w,vec3(sin(r),cos(r),0.)) );\n   return mat3(u,normalize(cross(u,w)),w);} \n\n //return surface normal\n vec3 getN(in vec3 p){DAMValue d=df(da_domain(p));return d.d.d;}\n //d.d.d stores the first derivatives on the 3 domains, (is also an awesopme pointer label)\n //this is equivalent to the gradient at p.\n //If (p is near a surface) the gradient is a surface normal\n //d.d.* addresses a vec4. where *.yzw==gradient\n //d.m.* addresses a material\n//#elif (domains==1||domains==3)\n //is a lot like \n //  https://www.shadertoy.com/view/XdffzB\n d getd(v0 u){\n  //function must be defined in prefix-notation;\n  //  https://en.wikipedia.org/wiki/Polish_notation  \n  //return absd(u);//f(x)=abs(x)  //first derivative of abs(x) is always a good start\n  //return sind(u);//f(x)=sin(x) //cos(x) as first derivative of sin(x)\n  return addd(absd(u),sind(u));//f(x) = abs(x)+sin(x) = add(abs(x),sin(x))\n }\n//#elif (domains==0)\n //this mode may insist on using a second domain as deltaTime or deltaMultipleFunctions?\n //so, it basically comes down to Fourier Transform.\n //otherwise one domain of screenspace gets wasted.\n//#endif \n\n//domain independent algebra:\n//return color corrected r\nvec3 ff_filmic_gamma3(vec3 r){vec3 x=max(vec3(0),r-.004);\n return (x*(x*6.2+.5))/(x*(x*6.2+1.7)+.06);}     \n\n //https://en.wikipedia.org/wiki/Alpha_compositing\n vec4 aOverB(vec4 a,vec4 b){a.xyz*=a.w;b.xyz*=b.w;return vec4(a+b*(1.-a));}\n //vec2 aOverB(vec2 a,vec2 b){a.x*=a.y;b.x  *=b.y;return vec2(a+b*(1.-a));}\n //not sure if correct, but looks useful.\n vec4 aXorB(vec4 a,vec4 b){a.xyz*=a.w;b.xyz*=b.w;return vec4(a*(1.-b)+b*(1.-a));}\n //vec2 aXorB(vec2 a,vec2 b){a.x*=a.y;b.x  *=b.y;return vec2(a*(1.-b)+b*(1.-a));}\n #define ssb(a) smoothstep(blur,-blur,a)\n\n//#if (domains>1)         \n vec4 in3d(vec2 u){\n u=(-iResolution.xy+2.*u.xy)/iResolution.y;\n vec2 m=iMouse.xy/iResolution.xy;  //mouse\n vec3 o,i,c=vec3(0);\n setCam(o,i,iTime,m.y+.2);//camMovement\n vec3 d=normalize(calcLookAtMatrix(o,i,camRoll)*vec3(u.xy,camLens));//ray.direction\n float t=rm(o,d);//Distance.raymarched\n if(t>-.5){\n  vec3 p=o+t*d,n=getN(p); //position & normal\n  vec4 m=material(p,n);   //material\n  c=light(p,n,d,t,m);}    //light\n c=ff_filmic_gamma3(c*.6);//gamma\n //c=pow( clamp(col,0.0,1.0), vec3(0.4545) );\n return vec4(c,1.);}\n//#elif (domains==3)\n #define frame(u) camLens*(u-.5*iResolution.xy)/iResolution.y\n //2d domain space parent: https://www.shadertoy.com/view/XdffzB\n vec4 in2d(vec2 u){\n  u=frame(u)*9.;\n  u.y+=2.;\n  vec2 f=abs(fract(u));//green carthesian grid\n  float h=abs(fract(length(u)+thick)-thick);//green polar circles\n  float g=min(min(f.x,f.y),h);\n  d d=getd(u.x);\n  //float div=sqrt(1.+p.y*p.y);\n  float r=abs(d.x-u.y)/(sqrt(1.+d.d*d.d))-thick;    \n  d=getd(u.x);\n  //no analytical 2nd derivative, so this one sucks a bit\n  float b=abs(d.d-u.y)/(sqrt(1.+d.d*d.d))-thick;\n  //this does not work for scaled p, is far from being uder friendly\n  float blur=20./max(iResolution.y,1.);\n  vec4 yellow =vec4(vec3(1,1,0),ssb(r));\n  vec4 cyan   =vec4(vec3(0,1,1),ssb(g));\n  vec4 magenta=vec4(vec3(1,0,1),ssb(b));\n  return aOverB(aOverB(yellow,magenta),cyan);}\n//#elif (domains==0)\n vec4 in1d(vec2 u){\n  return vec4(0);}\n//#endif \n\n\nvoid mainImage( out vec4 O,in vec2 U ){\n #if (domains==3)\n  //this is not 4d, it is 2d overlayed on top of 3d.\n  O=aOverB(in2d(U),in3d(U));}\n  //O=vec4(mix(ass.xyz,poo.xyz,ass.w),1.);}\n #elif (domains==2)\n  O=in3d(U);}\n #elif (domains==1)\n  O=in2d(U);}\n #elif (domains==0)\n  O=in1d(U);}\n #endif \n                             \n//my todo_list;\n//todo, find aliases for common operations, and debug them.\n//I suspect that modulo and 2d rotation seem buggy.\n//\n//todo, merge with hg_sdf, full set\n//to have hg_sdf with first derivatives, in 2 or 3 domains.\n//it already poited at my lack of competence to substitute correctly\n//-> lots of small errors.\n//\n//done, looking good enough:\n//\n//fSphere()\n//fRay() (infinite line segment with radius 1)\n//fBox()\n//fBoxCheap()\n//\n//mind() maxd() unions of 2 distance fields (Boolean AND, boolean OR)\n//fOpUnionRound()\n//fOpIntersectionRound()\n//fOpDifferenceRound()\n//\n//I failed at:\n//fOp*Columns\n//fOP*Staircase\n//\n//\n//todo pModd() , will likely hint me at how to fix stuff.\n//\n//todo: include complex plane transformation math of\n//  https://www.shadertoy.com/view/ls2cDt\n//for anything \"Cauchy\"\n//  https://en.wikipedia.org/wiki/Complex_analysis\n//  https://en.wikipedia.org/wiki/Augustin-Louis_Cauchy\n//\n//todo, antialiasing, merger with: https://www.shadertoy.com/view/MdXczr\n//\n//todo, curvature stuff, because I want a minimal surface !", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdXfRl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdXfWj", "name": "Magic Marble", "author": "duvengar", "description": "More fun with fbm and colors.", "tags": ["noise", "fbm", "marble"], "likes": 20, "viewed": 516, "date": "1498013259", "time_retrieved": "2024-06-20T18:57:14.762618", "image_code": "//// COLORS ////\n\nconst vec3 ORANGE = vec3(1.0, 0.6, 0.2);\nconst vec3 PINK   = vec3(0.7, 0.1, 0.2); \nconst vec3 BLUE   = vec3(0.4, 0.2, 0.9);\nconst vec3 GREEN  = vec3(0.1, 0.9, 0.4); \nconst vec3 BLACK  = vec3(0.0, 0.0, 0.3);\n\n///// NOISE /////\n\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453123);   \n}\n\n\nfloat noise( in vec2 x ){\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f * f * (3.0 - 2.0 * f);\n    float n = p.x + p.y * 57.0;\n    return mix(mix( hash(n + 0.0), hash(n + 1.0), f.x), mix(hash(n + 57.0), hash(n + 58.0), f.x), f.y);\n}\n\n////// FBM ////// \n\nmat2 m = mat2( 0.6, 0.6, -0.6, 0.8);\nfloat fbm(vec2 p){\n \n    float f = 0.0;\n    f += 0.5000 * noise(p); p *= m * 2.02;\n    f += 0.2500 * noise(p); p *= m * 2.03;\n    f += 0.1250 * noise(p); p *= m * 2.01;\n    f += 0.0625 * noise(p);\n    f /= 0.9375;\n    return f;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n    // pixel ratio\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;   \n    vec2 p = - 1. + 2. * uv;  \n    p.x *= iResolution.x / iResolution.y ;\n    \n    // ZOOM\n    \n    p *= abs(cos(iTime  * 0.17));\n    \n    // domains\n    \n    float r = sqrt(dot(p,p)); \n    float tetha = atan(p.x, p.y)  ;   \n     \n    float alpha = r * 0.2 + atan(dot(0.5, pow(abs(p.x), p.y)), dot(0.5, pow(abs(p.x),p.y))) - (iTime * 0.1); \n    tetha += - (iTime * 0.2);\n                  \n    // distortion\n     \n    alpha +=  1.4 + fbm( 1.7 * p) ;\n   \n  \t\n    // colorize\n    \n    vec3 col = BLACK;\n    \n    float ff = 1.0 - smoothstep( 0.2, 0.5, fbm(vec2( alpha * 20.0 , r * 3.)));        \n    col =  mix( col, ORANGE, ff );\n    \n    ff = smoothstep(0.5, 0.9, fbm(vec2(alpha * 20.0 , r * 3.0)));  \n    col =  mix( col, BLUE, ff); \n    \n    ff = smoothstep(0.4, 0.9, fbm(vec2(alpha * 8.0 , r )));  \n    col =  mix( col, PINK, ff ); \n    \n    ff = smoothstep(0.6, 0.7, fbm(vec2(alpha * 18.0 , r / 2. )));  \n    col =  mix( col, GREEN, ff * 0.6 ); \n    \n    ff = smoothstep(0.3, 0.6, fbm(vec2(alpha * 100.0 , r * 7. )));  \n    col *=  1.8 - ff ; \n    \n    \n    \n    ff = smoothstep(0.9, 0.0, length(p - vec2(0.4,0.4)));  \n    col =  mix( col, vec3(1.), ff * 0.6);\n    \n    ff = smoothstep(0.5, 0.0, length(p - vec2(0.4,0.4)));  \n    col =  mix( col, vec3(1.), ff * 0.6 );\n    \n    ff = smoothstep(0.2, 0.0, length(p - vec2(0.4,0.4)));  \n    col =  mix( col, vec3(1.), ff * 0.3);   \n    \n    ff = smoothstep(0.3, 1.6, fbm(vec2(tetha * 6., 3.)));  \n    col +=  mix( BLACK, col, ff * 0.3);\n    \n    ff = smoothstep(0.3, 1.6, fbm(vec2(tetha * 56., r *10.)));  \n    col +=   ff * 0.2;\n   \n    ff = smoothstep(0.7, 0.99, length(p));  \n    col *=  mix(col, vec3(0.), ff);\n    \n    ff = smoothstep(0.7, 0.9, length(p - vec2(0.4,0.4)));  \n    col *=  mix(col, vec3(0.), ff*0.6  );\n\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdXfWj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XdXfWM", "name": "Daily 2017-06-01", "author": "Koltes", "description": "Daily", "tags": ["daily"], "likes": 1, "viewed": 475, "date": "1496319201", "time_retrieved": "2024-06-20T18:57:14.762618", "image_code": "#define LENGTH 1.3\n\n#define rot(a) mat2(C=cos(a),S=sin(a),-S,C)\n#define TAU 6.28318531\nconst float sq3=sqrt(3.);\nfloat C,S;\nvec3 clr;\n\nfloat spiral(vec2 uv, float angle) {\n    float a=atan(uv.y,uv.x)/TAU+angle,\n        l=length(uv)-a,\n        s=floor(l)+a,\n        c=fract(l)-.5,\n        ac=abs(c),\n        b=smoothstep(.27,.23,ac)*step(s,2.-1./6.);\n    return b;\n}\n\nfloat rand(vec2 uv) { \n    return fract(sin(dot(uv,vec2(12.9898,78.233)))*43758.5453123);\n}\n\nfloat noise(vec2 uv) {\n    vec2 i=floor(uv),f=smoothstep(0.,1.,fract(uv)),oi=vec2(0.,1.);\n    return mix(\n        mix(rand(i),rand(i+oi.yx),f.x),\n        mix(rand(i+oi.xy),rand(i+oi.yy),f.x),\n        f.y);\n}\n\nvoid blend(vec3 s, float a) {\n    clr=s*a+clr*(1.-a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy,v=uv*(1.-uv);\n    uv-=.5;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    vec2 st=uv*.5;\n    st+=vec2(noise(st+iTime*vec2(.2,.3)), noise(st+iTime*vec2(.4,.2)+3.))*.2;\n    \n    clr=mix(vec3(.05,.3,.2),vec3(.05,.6,.8),texture(iChannel0,st).r);\n    \n    uv*=14.;\n    uv*=rot(iTime*.2);\n    \n    float c=abs(length(uv)-5.3),\n        w=smoothstep(.27,.23,abs(c));\n    w=max(w,spiral(uv-vec2(0.,2.)*LENGTH, 0.));\n    w=max(w,spiral(uv-vec2(-sq3,-1.)*LENGTH, 2./3.));\n    w=max(w,spiral(uv-vec2(sq3,-1.)*LENGTH, 1./3.));\n    blend(vec3(1.,.7,.4),w);\n    \n    clr=sqrt(clr)*pow(v.x*v.y*25.,.25);\n\tfragColor = vec4(clr,1.);\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XdXfWM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsBcD3", "name": "Champernowne", "author": "robclouth", "description": "A failed visualization of Champernowne's constant.", "tags": ["2d"], "likes": 0, "viewed": 350, "date": "1496505638", "time_retrieved": "2024-06-20T18:57:14.762618", "image_code": "float noise(float n,float s,float res)\n{\n\tfloat a = fract(sin(((floor((n)/s-0.5)*s)/res)*43632.6326)*53356.6426);\n\tfloat b = fract(sin(((floor((n)/s+0.5)*s)/res)*43632.6326)*53356.6426);\n\treturn mix(a,b,smoothstep(0.0,1.0,+mod(n/s+0.5,1.0)));\n}\n\nint ndigstartIndexBN(int b, int n){ // b=10 Decimal: 1 is at index 1, 10 is at index 10, 100 is at index 190, ...\n  int i0 = 0;\n    \n  for(int i=1; i<n; i++)\n      i0 += 9*i * int(pow(10.0, float(i-1))); //i0+=9*i*Math.pow(10,i-1);\n  return i0 + 1;\n}\n\nint nthDigit(int number, int position){\n\treturn (number % int(pow(10.0, float(position)))) / int(pow(10.0, float(position - 1)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int base = 2;\n    \n    float rot = radians(45.0);\n    \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 fcoord = fragCoord.xy - iResolution.xy / 2.0;\n    //uv-=.5;\n    \n    mat2 m = mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n   \tfcoord  = m * fcoord;\n\n    int index = int(fcoord.x * fcoord.y * (noise(iTime*0.1, 1.0, 1.0))*1.0 + sin(iTime*0.09)*100.0 + iTime*10.0 );\n    \n    int n = int(mod(iTime*0.002, 1.0)*30.0);\n    while(ndigstartIndexBN(base, n) < index) \n        n++; \n    n--;\n    \n    int offset = index - ndigstartIndexBN(base, n);\n    \n    int number = int(pow(float(base), float(n-1))) + int(offset / n); \n    int position = offset % n;\n    int value = nthDigit(number, position);\n    float fvalue = float(value) / 10.0;\n    \n\tfragColor = vec4(vec3(fvalue),1.0);\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsBcD3.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsfBDj", "name": "Hex Ducks", "author": "dr2", "description": "Raymarching across a hexagonal grid (mouse enabled)", "tags": ["grid", "raymarch", "hexagon", "dda"], "likes": 16, "viewed": 785, "date": "1498023412", "time_retrieved": "2024-06-20T18:57:14.779467", "image_code": "// \"Hex Ducks\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrEllipsDf (vec3 p, vec3 r);\nfloat PrEllCylDf (vec3 p, vec2 r, float h);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat SmoothMin (float a, float b, float r);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nvec3 HsvToRgb (vec3 c);\nfloat Hashfv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 qHit, sunDir, dukConf;\nvec2 gId;\nfloat dstFar, tCur, szFac;\nconst float pi = 3.14159;\nint idObj;\nconst int idBdy = 1, idWng = 2, idHead = 3, idBk = 4;\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  float f;\n  ro.xz += 0.5 * tCur;\n  f = Fbm2 (0.1 * (ro + rd * (50. - ro.y) / rd.y).xz);\n  return mix (vec3 (0.2, 0.3, 0.55) + 0.25 * pow (1. - max (rd.y, 0.), 8.) +\n     0.35 * pow (max (dot (rd, sunDir), 0.), 16.),\n     vec3 (0.85), clamp (0.8 * f * rd.y + 0.1, 0., 1.));\n}\n\nfloat WaveHt (vec2 p)\n{\n  vec2 u;\n  u = mod (0.1 * vec2 (p.x + p.y, p.x - p.y) * (1. + 0.3 * sin (0.2 * 2. * pi * p)) +\n   vec2 (-0.1, 0.053) * tCur, 1.) - 0.5;\n  u = exp (-100. * u * u);\n  return 0.5 + (u.x + u.y) / (3. + 0.05 * dot (p, p));\n}\n\nfloat WaveRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = 0; j < 50; j ++) {\n    p = ro + s * rd;\n    h = p.y - WaveHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.5, h);\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = 0; j < 8; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      h = step (0., p.y - WaveHt (p.xz));\n      sLo += h * (s - sLo);\n      sHi += (1. - h) * (s - sHi);\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nvec3 WaveNf (vec3 p)\n{\n  vec2 e = vec2 (0.01, 0.);\n  float h;\n  h = WaveHt (p.xz);\n  return normalize (vec3 (h - WaveHt (p.xz + e.xy), e.x, h - WaveHt (p.xz + e.yx)));\n}\n\nfloat DukDf (vec3 p)\n{\n  vec3 q;\n  vec2 r, cs;\n  float dMin, d, h, s;\n  dMin = dstFar / szFac;\n  p /= szFac;\n  q = p;\n  r = vec2 (0.04, 0.06 + 0.01 * clamp (q.z, -0.4, 0.4));\n  h = 0.1;\n  s = (length (q.xz / r) - 1.) * min (r.x, r.y);\n  d = min (max (s, abs (q.y) - h), length (vec2 (s, q.y)) - h);\n  if (d < dMin) { dMin = d;  idObj = idBdy;  qHit = q; }\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.1, 0.06, 0.12);\n  cs = vec2 (cos (0.3), sin (0.3));\n  q.yz = Rot2Cs (q.yz, cs);\n  cs.y = - cs.y;\n  q.xy = Rot2Cs (q.xy, cs);\n  q.xz = Rot2Cs (q.xz, cs);\n  q = q.yxz;\n  r = vec2 (0.06, 0.1 + 0.016 * clamp (q.z, -0.4, 0.4));\n  h = 0.014;\n  s = (length (q.xz / r) - 1.) * min (r.x, r.y);\n  d = min (max (s, abs (q.y) - h), length (vec2 (s, q.y)) - h);\n  d = SmoothMin (d, dMin, 0.01);\n  if (d < dMin) { dMin = d;  idObj = idWng;  qHit = q; }\n  q = p;\n  q.yz -= vec2 (0.15, -0.08);\n  d = PrEllipsDf (q, vec3 (0.08, 0.07, 0.1));\n  d = SmoothMin (d, dMin, 0.02);\n  if (d < dMin) { dMin = d;  idObj = idHead;  qHit = q; }\n  q = p;\n  q.yz -= vec2 (0.14, -0.19);\n  r = vec2 (0.03, 0.008);\n  h = 0.02;\n  d = max (PrEllCylDf (q, r, h), - PrEllCylDf (q - vec3 (0., 0., h),\n     r - 0.004, 2. * h));\n  if (d < dMin) { dMin = d;  idObj = idBk;  qHit = q; }\n  return 0.9 * dMin * szFac;\n}\n\n#define SQRT3 1.7320508\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./SQRT3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (SQRT3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat ObjDf (vec3 p)\n{\n  p.xz -= HexToPix (gId);\n  p.y -= 0.02 * szFac + dukConf.x;\n  p.yz = Rot2D (p.yz, -3. * dukConf.z);\n  p.xy = Rot2D (p.xy, 4. * dukConf.y);\n  return DukDf (p);\n}\n\nvoid EvalDukConf ()\n{\n  vec4 ht;\n  vec2 e, g;\n  szFac = 3. - 0.3 * floor (5. * Hashfv2 (17. * gId));\n  e = vec2 (0.03 * szFac, 0.);\n  g = HexToPix (gId);\n  ht = vec4 (WaveHt (g - e), WaveHt (g + e), WaveHt (g - e.yx), WaveHt (g + e.yx));\n  dukConf = vec3 (0.25 * dot (ht, vec4 (1.)) + 0.1 * (Hashfv2 (22. * gId) - 0.5),\n     vec2 (ht.xz - ht.yw));\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP;\n  float dHit, d, s;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., SQRT3);\n  edN[2] = 0.5 * vec2 (1., - SQRT3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = 1. / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = (SQRT3/2.) - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),\n     dot (ro.xz, edN[2]));\n  pM = HexToPix (PixToHex (ro.xz));\n  gIdP = vec2 (-10.);\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n    s = min (hv.x, min (hv.y, hv.z));\n    p = ro + dHit * rd;\n    gId = PixToHex (p.xz);\n    if (max (max (abs (gId.x), abs (gId.y)), abs (gId.x + gId.y)) <= 4.) {\n      if (gId.x != gIdP.x || gId.y != gIdP.y) {\n        EvalDukConf ();\n        gIdP = gId;\n      }\n      d = ObjDf (p);\n    } else d = dstFar;\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + 0.01;\n      pM += SQRT3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n    }\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = 0; j < 20; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += 0.015;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 ObjCol ()\n{\n  vec3 col, cBdy;\n  float s;\n  cBdy = HsvToRgb (vec3 (mod (Hashfv2 (gId * vec2 (17., 27.) + 0.5), 1.), 1., 1.));\n  if (idObj == idBdy) {\n    col = cBdy * (1. - smoothstep (0.02, 0.06, qHit.y) *\n       smoothstep (0., 0.14, qHit.z) * 0.1 * SmoothBump (0.3, 0.5, 0.05,\n       mod (50. * qHit.x, 1.)));\n  } else if (idObj == idWng) {\n    col = cBdy * (1. - step (0.004, qHit.y) *\n       smoothstep (0., 0.04, qHit.z) * 0.2 * SmoothBump (0.3, 0.5, 0.05,\n       mod (100. * qHit.x, 1.)));\n  } else if (idObj == idHead) {\n    s = length (qHit.yz - vec2 (0.02, -0.05));\n    if (s > 0.02) col = cBdy;\n    else col = (abs (s - 0.01) < 0.003) ? vec3 (1., 1., 1.) : vec3 (0.3, 0.3, 1.);\n  } else if (idObj == idBk) col = vec3 (1., 0.5, 0.);\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, colW, vn;\n  float dstObj, dstWat, sh;\n  bool waterRefl;\n  dstWat = WaveRay (ro, rd);\n  dstObj = ObjRay (ro, rd);\n  waterRefl = (dstWat < min (dstFar, dstObj));\n  if (waterRefl) {\n    ro += rd * dstWat;\n    vn = WaveNf (ro);\n    vn = VaryNf (10. * ro, vn, 0.3);\n    colW = 0.7 * vec3 (0., 0.2, 0.3) * (0.4 + 0.6 * max (dot (vn, sunDir), 0.));\n    rd = reflect (rd, vn);\n    dstObj = ObjRay (ro, rd);\n  }\n  if (dstObj < dstFar) {\n    ro += rd * dstObj;\n    gId = PixToHex (ro.xz);\n    col = ObjCol ();\n    EvalDukConf ();\n    vn = ObjNf (ro);\n    sh = ObjSShadow (ro, sunDir);\n    col = col * (0.2 + 0.8 * sh * max (dot (vn, sunDir), 0.)) +\n       0.2 * sh * pow (max (dot (normalize (sunDir - rd), vn), 0.), 128.);\n  } else col = SkyCol (ro, rd);\n  if (waterRefl) col = mix (colW, col, 0.3);\n  col = pow (clamp (col, 0., 1.), vec3 (0.7));\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float az, el;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  if (mPtr.z > 0.) {\n    az = 2. * pi * mPtr.x;\n    el = 1. * pi * mPtr.y;\n  } else {\n    az = -0.03 * pi * tCur;\n    el = -0.2 * pi + 0.05 * pi * sin (0.1 * pi * tCur);\n  }\n  el = clamp (el, -0.45 * pi, -0.12 * pi);\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n     mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 0., -12.);\n  rd = vuMat * normalize (vec3 (uv, 4.));\n  dstFar = 40.;\n  sunDir = vuMat * normalize (vec3 (1., 2., -1.));\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nfloat PrEllCylDf (vec3 p, vec2 r, float h)\n{\n  return max ((length (p.xy / r) - 1.) * min (r.x, r.y), abs (p.z) - h);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, cHashA3.xy)) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f;\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 3; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  float s;\n  const vec3 e = vec3 (0.1, 0., 0.);\n  s = Fbmn (p, n);\n  g = vec3 (Fbmn (p + e.xyy, n) - s, Fbmn (p + e.yxy, n) - s,\n     Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsfBDj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsfBDs", "name": "small sun & sky", "author": "public_int_i", "description": "small sun and sky", "tags": ["sun", "sky", "small"], "likes": 0, "viewed": 446, "date": "1498823930", "time_retrieved": "2024-06-20T18:57:14.779467", "image_code": "void mainImage( out vec4 o,  vec2 u )\n{\n    u /= iResolution.xy;\n    float y = sin(iTime*.3),\n          s = length(u-vec2(.5,y));\n    o = max(mix(vec4(.2,.4,.6,1)*(.6+y*.4),//sky\n            vec4(.95,.5,.4,1), (1.-abs(y))*(1.-u.y)-pow(s,2.)), //horizon scattering\n            vec4(0,0,.1,1))+ //night\n        max(0.,10.-s*200.);//sun\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsfBDs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsfBWB", "name": "Magic Orb", "author": "dr2", "description": "Something ancient", "tags": ["symmetry"], "likes": 8, "viewed": 494, "date": "1497734423", "time_retrieved": "2024-06-20T18:57:14.790728", "image_code": "// \"Magic Orb\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat SmoothMin (float a, float b, float r);\nvec3 HsvToRgb (vec3 c);\nvec2 Rot2D (vec2 q, float a);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltDir, qHit;\nfloat dstFar, tCur;\nint idObj;\nconst float pi = 3.14159;\n\nvec3 IcosSym (vec3 p)\n{\n  const float dihedIcos = 0.5 * acos (sqrt (5.) / 3.);\n  float a, w;\n  w = 2. * pi / 3.;\n  p.z = abs (p.z);\n  p.yz = Rot2D (p.yz, - dihedIcos);\n  p.x = - abs (p.x);\n  for (int k = 0; k < 4; k ++) {\n    p.zy = Rot2D (p.zy, - dihedIcos);\n    p.y = - abs (p.y);\n    p.zy = Rot2D (p.zy, dihedIcos);\n    if (k < 3) p.xy = Rot2D (p.xy, - w);\n  }\n  p.z = - p.z;\n  a = mod (atan (p.x, p.y) + 0.5 * w, w) - 0.5 * w;\n  p.yx = vec2 (cos (a), sin (a)) * length (p.xy);\n  p.x -= 2. * p.x * step (0., p.x);\n  return p;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 pIco;\n  const vec3 vIco = normalize (vec3 (sqrt(3.), -1., 0.5 * (3. + sqrt(5.))));\n  float dMin, r, d, f;\n  dMin = dstFar;\n  idObj = 1;\n  f = 1.;\n  for (int k = 0; k < 3; k ++) {\n    pIco = IcosSym (p);\n    r = 2.8 * f;\n    d = - (0.021 * r + SmoothMin (- abs (length (p) - r),\n       - length (length ((pIco + 0.411 * r * vIco).xy - 0.093 * r) -\n       0.114 * r), 0.021 * r));\n    if (d < dMin) { dMin = d;  qHit = p; }\n    if (k == 0) p.xy = Rot2D (p.xy, 0.051 * pi * tCur);\n    else if (k == 1) p.yz = Rot2D (p.yz, 0.052 * pi * tCur);\n    f *= 0.93;\n  }\n  d = length (p) - 2.8 * f;\n  if (d < dMin) { dMin = d;  idObj = 2; }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + rd * dHit);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec3 e = vec3 (0.0001, -0.0001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjAO (vec3 ro, vec3 rd)\n{\n  float ao, d;\n  ao = 0.;\n  for (int j = 0; j < 8; j ++) {\n    d = 0.1 + float (j) / 16.;\n    ao += max (0., d - 3. * ObjDf (ro + rd * d));\n  }\n  return 0.5 + 0.5 * clamp (1. - 0.2 * ao, 0., 1.);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = 0; j < 30; j ++) {\n    h = ObjDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += 0.05;\n    if (sh < 0.05) break;\n  }\n  return sh;\n}\n\nfloat MarbVol (vec3 p)\n{\n  vec3 q;\n  float f;\n  f = 0.;\n  p *= 0.7;\n  q = p;\n  for (int j = 0; j < 5; j ++) {\n    q = abs (q) / dot (q, q) - 0.89;\n    f += 1. / (1. + abs (dot (p, q)));\n  }\n  return f;\n}\n\nvec3 VtRot (vec3 p, vec3 a)\n{\n  a *= pi * tCur;\n  p.yz = Rot2D (p.yz, a.x);\n  p.zx = Rot2D (p.zx, a.y);\n  p.xy = Rot2D (p.xy, a.z);\n  return p;\n}\n\nvec3 SphMarb (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  float t;\n  col = vec3 (0.);\n  ro = VtRot (ro, - vec3 (0.03, 0.022, 0.026));\n  rd = VtRot (rd, - vec3 (0.03, 0.022, 0.026));\n  t = 0.;\n  for (int j = 0; j < 20; j ++) {\n    t += 0.02;\n    col = mix (HsvToRgb (vec3 (mod (0.4 * MarbVol (ro + t * rd) +\n       0.03 * pi * tCur, 1.), 1., 1. / (1. + t))), col, 0.95);  \n  }\n  return clamp (col, 0., 1.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 vn, col, bgCol, qHitT;\n  float dstObj, c, sh, bk, env, eFac;\n  int idObjT;\n  dstObj = ObjRay (ro, rd);\n  env = 1.;\n  if (dstObj < dstFar) {\n    ro += rd * dstObj;\n    idObjT = idObj;\n    qHitT = qHit;\n    vn = ObjNf (ro);\n    bk = max (dot (vn, - normalize (vec3 (ltDir.x, 0., ltDir.z))), 0.);\n    sh = ObjSShadow (ro, ltDir);\n    if (idObjT == 1) {\n      col = vec3 (1., 0.95, 0.4);\n      vn = VaryNf (50. * qHitT, vn, 3.);\n      sh = 0.5 + 0.5 * sh;\n      col = col * (0.1 + 0.1 * bk + sh * 0.7 * max (dot (vn, ltDir), 0.));\n      eFac = 0.25;\n    } else {\n      col = 2. * (0.8 + 0.2 * sh) * SphMarb (0.5 * ro, refract (rd, vn, 1./1.5));\n      eFac = 0.05;\n     }\n    env = eFac * ObjAO (ro, vn);\n    col += sh * 0.1 * pow (max (dot (normalize (ltDir - rd), vn), 0.), 256.);\n    rd = reflect (rd, vn);\n  } else col = vec3 (0., 0., 0.05);\n  c = (rd.y > max (abs (rd.x), abs (rd.z * 0.25))) ? min (2. * rd.y, 1.) :\n     0.05 * (1. + dot (rd, ltDir));\n  if (rd.y > 0.) c += 0.5 * pow (clamp (1.05 - 0.5 *\n     length (max (abs (rd.xz / rd.y) - vec2 (1., 4.), 0.)), 0., 1.), 6.);\n  bgCol = vec3 (0.4, 0.4, 1.) * c + 2. * vec3 (1., 0.9, 0.8) *\n     (clamp (0.0002 / (1. - abs (rd.x)), 0., 1.) +\n      clamp (0.0002 / (1. - abs (rd.z)), 0., 1.));\n  col += env * bgCol;\n  return pow (clamp (col, 0., 1.), vec3 (0.9));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float az, el;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur += 10.;\n  if (mPtr.z > 0.) {\n    az = 3. * pi * mPtr.x;\n    el = -0.1 * pi + 1. * pi * mPtr.y;\n  } else {\n    az = 0.02 * pi * tCur;\n    el = -0.25 * pi + 0.1 * pi * sin (0.022 * pi * tCur);\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  rd = vuMat * normalize (vec3 (uv, 3.6));\n  ro = vuMat * vec3 (0., 0., -12.);\n  ltDir = vuMat * normalize (vec3 (1., 1., -1.));\n  dstFar = 30.;\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 3; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  float s;\n  const vec3 e = vec3 (0.1, 0., 0.);\n  s = Fbmn (p, n);\n  g = vec3 (Fbmn (p + e.xyy, n) - s, Fbmn (p + e.yxy, n) - s,\n     Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsfBWB.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsfBWM", "name": "Rainbow Cavern", "author": "dr2", "description": "Underground boat ride (mouseable)", "tags": ["voronoi", "raymarch", "lighting", "water", "cave", "boat"], "likes": 20, "viewed": 887, "date": "1496312994", "time_retrieved": "2024-06-20T18:57:16.556978", "image_code": "// \"Rainbow Cavern\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define USE_BMAP true\n//#define USE_BMAP false  // for weaker GPUs\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashfv3 (vec3 p);\nvec3 Hashv3f (float p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec4 vcId;\nvec3 ltPos[2], boatPos[2];\nfloat boatAng[2], dstFar, tCur, htWat, dstBMap;\nint idObj;\nbool uWat, hitWat;\nconst int idBoat = 1, idBLamp = 2, idFLamp = 3;\nconst float pi = 3.14159;\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  for (int k = 0; k < 2; k ++) {\n    q = p - boatPos[k];\n    q.xz = Rot2D (q.xz, boatAng[k]);\n    d = max (PrCapsDf (q, 0.11, 0.25),\n       - PrCapsDf (q + vec3 (0., -0.02, 0.), 0.1, 0.24));\n    if (d < dMin) { dMin = d;  idObj = idBoat; }\n    q.y -= 0.1;\n    q.z -= 0.3;\n    d = PrSphDf (q, 0.01);\n    if (d < dMin) { dMin = d;  idObj = idFLamp; }\n    q.z -= -0.6;\n    d = PrSphDf (q, 0.01);\n    if (d < dMin) { dMin = d;  idObj = idBLamp; }\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 100; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy),\n     ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat VPoly (vec3 p)\n{\n  vec3 ip, fp, g, w, a;\n  ip = floor (p);\n  fp = fract (p);\n  a = vec3 (2.);\n  for (float gz = -1.; gz <= 1.; gz ++) {\n    for (float gy = -1.; gy <= 1.; gy ++) {\n      for (float gx = -1.; gx <= 1.; gx ++) {\n        g = vec3 (gx, gy, gz);\n        w = g + 0.7 * Hashfv3 (ip + g) - fp;\n        a.x = dot (w, w);\n        if (a.x < a.y) {\n          vcId = vec4 (ip + g, a.y - a.x);\n          a = a.zxy;\n        } else a.z = min (a.z, a.x);\n      }\n    }\n  }\n  return a.y;\n}\n\nvec3 TrackPath (float t)\n{\n  return vec3 (4.7 * sin (t * 0.15) + 2.7 * cos (t * 0.19), 0., t);\n}\n\nfloat CaveDf (vec3 p)\n{\n  vec3 hv;\n  float s, d;\n  s = p.y - htWat;\n  p.xy -= TrackPath (p.z).xy;\n  p += 0.1 * (1. - cos (2. * pi * (p + 0.2 * (1. - cos (2. * pi * p.zxy)))));\n  hv = cos (0.6 * p - 0.5 * sin (1.4 * p.zxy + 0.4 * cos (2.7 * p.yzx)));\n  if (USE_BMAP && dstBMap < 10.) hv *= 1. + 0.01 *\n     (1. - smoothstep (0., 10., dstBMap)) *\n     smoothstep (0.05, 0.4, VPoly (10. * p)) / length (hv);\n  d = 0.9 * (length (hv) - 1.1);\n  if (! uWat) d = min (d, s);\n  return d;\n}\n\nfloat CaveRay (vec3 ro, vec3 rd)\n{\n  float d, dHit;\n  dHit = 0.;\n  for (int j = 0; j < 200; j ++) {\n    dstBMap = dHit;\n    d = CaveDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 CaveNf (vec3 p)\n{\n  vec4 v;\n  const vec3 e = vec3 (0.001, -0.001, 0.);\n  v = vec4 (CaveDf (p + e.xxx), CaveDf (p + e.xyy),\n     CaveDf (p + e.yxy), CaveDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat CaveSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.1;\n  for (int j = 0; j < 16; j ++) {\n    h = CaveDf (ro + rd * d);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (0.2, 0.1 * d);\n    if (sh < 0.05) break;\n  }\n  return 0.4 + 0.6 * sh;\n}\n\nvec3 CaveCol (vec3 ro, vec3 rd, vec3 ltDir, float atten)\n{\n  vec3 col, vn, q, vno;\n  float glit;\n  VPoly (10. * ro);\n  q = ro;\n  if (! USE_BMAP) q = 0.004 * floor (250. * q);\n  vn = VaryNf (10. * q, CaveNf (q), 1.);\n  col = (vec3 (0.3, 0.1, 0.) + vec3 (0.3, 0.2, 0.1) * Hashv3f (Hashfv3 (vcId.xyz))) *\n     (1.2 - 0.4 * Hashfv3 (100. * ro)) *\n     (0.4 + 0.6 * smoothstep (0.05, 1., sqrt (vcId.w))) *\n     (0.2 + 0.8 * max (dot (vn, ltDir), 0.) +\n     2. * pow (max (dot (normalize (ltDir - rd), vn), 0.), 256.));\n  if (! hitWat) {\n    vno = CaveNf (ro);\n    glit = 20. * pow (max (0., dot (ltDir, reflect (rd, vno))), 4.) *\n       pow (1. - 0.6 * abs (dot (normalize (ltDir - rd),\n       VaryNf (100. * ro, vno, 5.))), 8.);\n    col += vec3 (1., 1., 0.5) * glit;\n  }\n  col *= atten * CaveSShadow (ro, ltDir);\n  return col;\n}\n\nvec3 ObjCol (vec3 ro, vec3 rd, vec3 vn, vec3 ltDir, float atten)\n{\n  vec4 col4;\n  if (idObj == idBoat) col4 = vec4 (0.3, 0.3, 0.6, 0.2);\n  else if (idObj == idFLamp) col4 = vec4 (0., 1., 0., -1.);\n  else if (idObj == idBLamp) col4 = vec4 (1., 0., 0., -1.);\n  if (col4.a >= 0.)\n    col4.rgb = col4.rgb * (0.2 + 0.8 * CaveSShadow (ro, ltDir)) *\n       (0.1 + 0.9 * atten * max (dot (ltDir, vn), 0.)) +\n       col4.a * atten * pow (max (dot (normalize (ltDir - rd), vn), 0.), 64.);\n  return col4.rgb;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, colR, bgCol, ltVec, vn, roo, rdo, row, vnw;\n  float dstCave, dstObj, atten, frFac;\n  roo = ro;\n  rdo = rd;\n  bgCol = (abs (rd.y) < 0.5) ? vec3 (0., 0.05, 0.08) : vec3 (0.01);\n  uWat = false;\n  hitWat = false;\n  dstCave = CaveRay (ro, rd);\n  dstObj = ObjRay (ro, rd);\n  if (dstCave < min (dstObj, dstFar) && ro.y + rd.y * dstCave < htWat + 0.001) {\n    hitWat = true;\n    ro += rd * dstCave;\n    row = ro;\n    vnw = VaryNf (1.5 * ro, vec3 (0., 1., 0.), 0.1);\n    rd = reflect (rd, vnw);\n    ro += 0.01 * rd;\n    dstCave = CaveRay (ro, rd);\n    dstObj = ObjRay (ro, rd);\n  }\n  if (min (dstCave, dstObj) < dstFar) {\n    ltVec = roo + ltPos[0] - ro;\n    atten = 1. / (0.1 + dot (ltVec, ltVec));\n    if (hitWat) atten *= 3.;\n    ltVec = normalize (ltVec);\n    ro += min (dstCave, dstObj) * rd;\n    if (dstCave < dstObj) col = mix (CaveCol (ro, rd, ltVec, atten), bgCol,\n       smoothstep (0.45, 0.99, dstCave / dstFar));\n    else col = ObjCol (ro, rd, ObjNf (ro), ltVec, atten);\n  } else col = bgCol;\n  if (hitWat) {\n    frFac = rdo.y * rdo.y;\n    frFac *= frFac;\n    if (frFac > 0.005) {\n      rd = refract (rdo, vnw, 1./1.333);\n      ro = row + 0.01 * rd;\n      uWat = true;\n      dstCave = CaveRay (ro, rd);\n      if (min (dstCave, dstObj) < dstFar) {\n        ltVec = roo + ltPos[1] - ro;\n        atten = 1. / (0.1 + dot (ltVec, ltVec));\n        ltVec = normalize (ltVec);\n        ro += rd * dstCave;\n        hitWat = false;\n        colR = mix (CaveCol (ro, rd, ltVec, atten), bgCol,\n           smoothstep (0.45, 0.99, dstCave / dstFar));\n      } else colR = bgCol;\n      col = mix (col, colR * vec3 (0.4, 1., 0.6) * exp (0.02 * ro.y), frFac);\n    }\n  }\n  return pow (clamp (col, 0., 1.), vec3 (0.8));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, fpF, fpB, vd;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, t, tt, a;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  t = 1. * tCur;\n  az = 0.;\n  el = 0.;\n  if (mPtr.z > 0.) {\n    az = az + 2. * pi * mPtr.x;\n    el = el + 0.95 * pi * mPtr.y;\n  } else {\n    tt = mod (floor (0.05 * tCur), 4.);\n    a = 0.45 * pi * SmoothBump (0.75, 0.95, 0.05, mod (0.05 * tCur, 1.));\n    if (tt < 2.) el = (2. * tt - 1.) * a;\n    else az = (2. * tt - 5.) * a;\n  }\n  htWat = -0.5;\n  for (int k = 0; k < 2; k ++) {\n    fpF = TrackPath (t + 3. + 3. * float (k) + 0.1);\n    fpB = TrackPath (t + 3. + 3. * float (k) - 0.1);\n    boatPos[k] = 0.5 * (fpF + fpB);\n    boatPos[k].y = htWat + 0.01;\n    vd = fpF - fpB;\n    boatAng[k] = (length (vd.xz) > 0.) ? atan (vd.x, vd.z) : 0.5 * pi;\n  }\n  fpF = TrackPath (t + 0.1);\n  fpB = TrackPath (t - 0.1);\n  ro = 0.5 * (fpF + fpB);\n  vd = fpF - fpB;\n  ori = vec2 (el, az + ((length (vd.xz) > 0.) ? atan (vd.x, vd.z) : 0.5 * pi));\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  rd = vuMat * normalize (vec3 (uv, 2.));\n  ltPos[0] = 0.5 * vuMat * vec3 (0., 1., -1.);\n  ltPos[1] = 0.5 * vuMat * vec3 (0., -1., -1.);\n  dstFar = 50.;\n  fragColor = vec4 (ShowScene (ro, rd) , 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, cHashA3.xy)) * cHashM);\n}\n\nfloat Hashfv3 (vec3 p)\n{\n  return fract (sin (dot (p, cHashA3)) * cHashM);\n}\n\nvec3 Hashv3f (float p)\n{\n  return fract (sin (vec3 (p, p + 1., p + 2.)) *\n     vec3 (cHashM, cHashM * 0.43, cHashM * 0.37));\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec4 t;\n  vec2 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv4f (dot (ip, cHashA3.xy));\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  const vec3 e = vec3 (0.1, 0., 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) -\n     Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsfBWM.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsfBzj", "name": "20170608_Spincode", "author": "FMS_Cat", "description": "2d something...", "tags": ["2d"], "likes": 15, "viewed": 267, "date": "1496883742", "time_retrieved": "2024-06-20T18:57:16.908329", "image_code": "// == defines ==================================================================\n#define BITS 16.0\n#define THR 0.5\n#define LOOPFREQ 2.0\n#define SCALE (iResolution.y * 0.1)\n#define VIG 0.0\n\n#define PI 3.14159265\n#define saturate(x) clamp(x,0.,1.)\n#define linearstep(a,b,x) saturate((x-a)/(b-a))\n\n// == vec2 to float hash =======================================================\nfloat random2( vec2 co ) {\n  return fract( sin( dot( co.xy, vec2( 2.9898, 7.233 ) ) ) * 4838.5453 );\n}\n\n// == main procedure ===========================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 p = ( fragCoord.xy * 2.0 - iResolution.xy ) / iResolution.y;\n\n  float radius = length( p ) * SCALE;\n  float layerI = floor( radius );\n  \n  if ( layerI < 2.0 ) {\n    fragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n    return; // fast return\n  }\n\n  float ssThr = 2.0 / iResolution.y; // threshold of smoothstep\n  float theta = ( atan( p.y, p.x ) + PI ) / 2.0 / PI;\n\n  // make \"ring\"s\n  float layerF = fract( radius );\n  float ring = linearstep( 0.0, ssThr * SCALE, layerF );\n  ring *= 1.0 - linearstep( 0.0, ssThr * SCALE, layerF - 0.3 );\n\n  // define spinning velocity\n  float vel = 0.05 * ( random2( vec2( layerI, 3.155 ) ) - 0.5 );\n\n  // define number of segments\n  float seg = 1.0 + floor( layerI * 4.0 * pow( random2( vec2( layerI, 2.456 ) ), 2.0 ) );\n\n  // define seeds\n  float phase = fract( ( theta + iTime * vel ) * LOOPFREQ ) * seg;\n  float seed = floor( phase ); // seed of current segment\n  float seedN = mod( seed + 1.0, seg ); // seed of next segment\n\n  // calcurate state by seed and random\n  float stateI = random2( vec2( layerI, seed ) ) < THR ? 0.0 : 1.0;\n  float stateIN = random2( vec2( layerI, seedN ) ) < THR ? 0.0 : 1.0;\n\n  // make gradient for next segment\n  float state = mix(\n    stateI,\n    stateIN,\n    linearstep( 0.0, ssThr / length( p ) * seg / PI, fract( phase ) )\n  );\n\n  // final destination\n  fragColor = vec4( vec3( state * ring ), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsfBzj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsffRs", "name": "Daily 2017-06-14", "author": "Koltes", "description": "Daily", "tags": ["daily"], "likes": 5, "viewed": 508, "date": "1497442150", "time_retrieved": "2024-06-20T18:57:16.908329", "image_code": "#define TAU 6.28318531\nfloat C,S;\n#define rot(a) mat2(C=cos(a),S=sin(a),-S,C)\n\nfloat map(vec3 p) {\n    p.yz*=rot(p.z*(.03*sin(iTime*3.)));\n    p.xz*=rot(p.z*(.03*cos(iTime*3.)));\n    float m=TAU/6.,\n        l=length(p.xy),\n        a=mod(atan(p.y,p.x)-p.z*.5+iTime*5.,m)-.5*m;\n    return length(vec2(a*l,l-2.))-.8;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv-=.5;\n    uv.x*=iResolution.x/iResolution.y;\n    vec3 ro=vec3(uv,-3.),rd=normalize(vec3(uv,1.)),mp=ro;\n    float i;for (i=0.;i<30.;++i) {\n        float md=map(mp);\n        if (abs(md)<.001)break;\n        mp+=rd*md;\n    }\n    float r=i/30.;\n    float d=length(mp-ro)*.1;\n    vec3 c=mix(vec3(.2,.5,.7)*d*d,vec3(.2,.4,.8)*r/d,r*r);\n    c=sqrt(c);\n\tfragColor = vec4(c,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsffRs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsffWj", "name": "Simplex Truchet Tubing", "author": "Shane", "description": "A 3D simplex Truchet pattern - inspired by Mattz's octahedral and tetrahedral \"Rainbow Spaghetti\" example.", "tags": ["torus", "random", "simplex", "truchet", "pattern", "tube"], "likes": 51, "viewed": 1275, "date": "1498310337", "time_retrieved": "2024-06-20T18:57:20.084366", "image_code": "/*\n\tSimplex Truchet Tubing\n\t----------------------\n\n\tThis was inspired by Mattz's \"Rainbow Sphaghetti\" example, which I've always admired\n\tfor both its aesthetics and mathematical content. However, this version was constructed\n\tvia a more direct simplex grid approach. In fact, I made it a point not to look at \n\tMattz's code too deeply in the hope that I might bring something new to the table... \n\tNot sure if I did, but here it is anyway. :)\n\n\tThe idea is very simple: Break space into a simplex grid, which is just a bunch of \n\tpacked regular tetrahedrons. Each tetrahedron has four faces, so run a tube from one\n\tface center to another face center, then do the same with the remaining two faces - \n\tIf you require a visual reference, look up cubic Truchet tiles, then picture one with\n\ttetrahedrons instead of cubes. The result is a grid space full of double-tubed \n\ttetrahedral Truchet blocks which can each be randomly oriented to produce a Truchet \n\tpattern.\n\n\tRunning a straight tube, or even a Bezier curve, from one tetrahedral face center to \n\tthe next is almost trivial, but threading tori through them was slighly more tricky. \n\tEach had to be centered on the correct central edge, then aligned accordingly. The code \n\tto do that turned out to be reasonably simple, but I had to make a lot of really stupid \n\tmistakes to get there. :)\n\n\tAnyway, for anyone interested, the relevant code is contained in the distance function;\n\tThe rest is window dressing. I also have a much, much more simplistic version using \n\tstraight tubes that I'll put up pretty soon which should be much easier to absorb. With\n\ta bit of trial and error, I've also managed to produce an animated version, so I'll\n\tput that up too.\n\t\n\n\tBy the way, I really rushed in the comments, but I'll tidy them up later.\n    \n\n    // Relevant examples:\n\n    // Truchet pattern using an octahedral and tetrahedral setup.\n    rainbow sphagetti - Mattz\n    https://www.shadertoy.com/view/lsjGRV\n\n\t// Classic cubic Truchet pattern. Easier to understand.\n\tTwisted Tubes - Shane\n\thttps://www.shadertoy.com/view/lsc3DH\n \n\n*/\n\n\n#define FAR 20. // Maximum ray distance. Analogous to the far plane.\n\n//#define NO_BOLTS // Bland, but faster, plus it allows you to see the pattern better.\n\n\n// Scene object ID. Either the bolts (0) or the tube itself (1).\nfloat objID;\nfloat svObjID; // Global ID to keep a copy of the above from pass to pass.\n\nfloat hash(float n){ return fract(sin(n)*43758.5453); }\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float t){ \n\n    //return vec2(0); // Straight path override.\n   \n    // Curvy path.\n    float a = sin(t * 0.22);\n    float b = cos(t * 0.28);\n    return vec2(a*2. -b*.75, b*.85 + a*.75);\n\n}\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D t, in vec3 p, in vec3 n ){ \n    \n    //p -= vec3(path(p.z), 0.);\n     \n    n = max(abs(n), 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\n\nfloat hash31(vec3 p) { \n\n    // Faster, but doesn't disperse things quite as nicely as the block below it. However, when framerate\n    // is an issue, and it often is, this is the one to use. Basically, it's a tweaked amalgamation I put\n    // together, based on a couple of other random algorithms I've seen around... so use it with caution,\n    // because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec3(7.31, 157.47, 113.93)));    \n    return fract(n); // return fract(vec3(64, 8, 1)*32768.0*n)*2.-1.; \n\n    // I'll assume the following came from IQ.\n    //p = vec3( dot(p, vec3(127.1, 311.7, 74.7)), dot(p, vec3(269.5, 183.3, 246.1)), dot(p, vec3(113.5, 271.9, 124.6)));\n    //return (fract(sin(p)*43758.5453)*2. - 1.);\n\n}\n\n// A cheap orthonormal basis vector function - Taken from Nimitz's \"Cheap Orthonormal Basis\" example, then \n// modified slightly.\n//\n//Cheap orthonormal basis by nimitz\n//http://orbit.dtu.dk/fedora/objects/orbit:113874/datastreams/file_75b66578-222e-4c7d-abdf-f7e255100209/content\n//via: http://psgraphics.blogspot.pt/2014/11/making-orthonormal-basis-from-unit.html\nmat3 basis(in vec3 n){\n    \n    float a = 1./(1. + n.z);\n    float b = -n.x*n.y*a;\n    return mat3(1. - n.x*n.x*a, b, n.x, b, 1. - n.y*n.y*a, n.y, -n.x, -n.y, n.z);\n    //return transpose(mat3(vec3(1. - n.x*n.x*a, b, -n.x), vec3(b, 1. - n.y*n.y*a , -n.y), n));\n                 \n}\n\n// Torus function, with the standard large radius and smaller cross-sectional radius. With just a \n// standard torus shape, this would be a very simple algorithm, but just to make it a little more\n// interesting, I spaced some bolts around the tori segments, so that added a few more lines.\nvec2 tor(vec3 p, float rad, float rad2){\n    \n    // \"p\" has been passed in as \"p - p0,\" where \"p0\" is the central torus axial point. \n  \n    #ifndef NO_BOLTS\n    // Bolts. Standard object repetition around a torus.\n    vec3 q = p;\n    q.xy = rot2(-3.14159/12.)*q.xy; // Rotating the bolts to avoid seam lines.\n    // Animation: I'd love to include this but there are some boundary issues that I'll have\n    // to compensate for first. It's on the list though.\n    //q.xy = rot2(iTime/2.)*q.xy;\n\n    float a = atan(q.y, q.x); // Polar angle of \"q.xy\" coordinate.\n    \n    // Partitioning the the torus into centered cells - \"oNum\" in all.\n    const float oNum = 6.; // Six objects in all.\n    float ia = floor(a/6.2831853*oNum);\n    ia = (ia + .5)/oNum*6.2831853; \n    \n    // Converting the cell coordinates to polar positions. \"X\" now represents the radial\n    // distance, and \"Y\" repesents the radial distance.\n    q.xy = rot2(ia)*q.xy; \n    \n    q.x -= rad; // Edging the object out to the distance of the outer radius.\n    \n    // Drawing some hexagon bolts at the postion.\n    q = abs(q);\n    float sh = max(max(q.x*.866025 + q.z*.5, q.z) - rad2 - .0125, q.y - .045);\n    sh = max(sh, -q.y + .01); // Taking out the center to make it look like two bolts.\n    #endif               \n    \n    #ifndef NO_BOLTS\n    // The torus itself. Without the bolts, the following would be all you need:\n    \n    // Sweeping a circle \"rad\" units about the center point. \n    p.xy = vec2(length(p.xy) - rad, p.z);\n   \n    // Producing the inner circle and adding some tiny ribbing (\"cos\" term) to emulate a thread.\n    float tor = length(p.xy) - rad2 + cos(a*180.)*.0002;\n    \n    // Hexagonal cross section. Cool, but I have to deal with segment alignment first.\n    ////p.xy = rot2(a)*p.xy;\n    //p = abs(p);\n    //float tor = max(p.x, p.y) - rad2;// + cos(a*180.)*.0002;\n\n    \n    // Returning the torus value and the shape (bolt) value seperately (for ID purposes), but\n    // they'll be combined afterward.\n    \n    return vec2(tor, sh);\n    #else\n    float a = atan(p.y, p.x);\n    p.xy = vec2(length(p.xy) - rad, p.z);\n    float tor = length(p.xy) - rad2 + cos(a*180.)*.0002;\n    return vec2(tor, 1e8);\n    #endif\n    \n}\n\n\n// Breaking space into a 3D simplex grid (packed tetrahedra), constructing tetrahedral Truchet tiles,\n// then randomly rotating them to form a 3D simplex Truchet pattern.\nfloat simplexTruchet(in vec3 p)\n{\n    \n    // Breaking space into tetrahedra and obtaining the four verticies. The folowing three code lines\n    // are pretty standard, and are used for all kinds of things, including 3D simplex noise. In this\n    // case though, we're constructing tetrahedral Truchet tiles.\n    \n    // Skewing the cubic grid, then determining relative fractional position.\n    vec3 i = floor(p + dot(p, vec3(1./3.)));  p -= i - dot(i, vec3(1./6.)) ;\n    \n    // Breaking the skewed cube into tetrahedra with partitioning planes, then determining which side of \n    // the intersecting planes the skewed point is on. Ie: Determining which tetrahedron the point is in.\n    vec3 i1 = step(p.yzx, p), i2 = max(i1, 1. - i1.zxy); i1 = min(i1, 1. - i1.zxy);    \n    \n    \n    // Using the above to produce the four vertices for the tetrahedron.\n    vec3 p0 = vec3(0), p1 = i1 - 1./6., p2 = i2 - 1./3., p3 = vec3(.5);\n\n    \n    \n    // Using the verticies to produce a unit random value for the tetrahedron, which in turn is used \n    // to determine its rotation.\n    float rnd = hash31(i*57.31 + i1*41.57 + i2*27.93);\n    \n    // This is a cheap way (there might be cheaper, though) to rotate the tetrahedron. Basically, we're\n    // rotating the vertices themselves, depending on the random number generated.\n    vec3 t0 = p1, t1 = p2, t2 = p3, t3 = p0;\n    if (rnd > .66){ t0 = p2, t1 = p3; t2 = p0; t3 = p1; }\n    else if (rnd > .33){ t0 = p3, t1 = p0; t2 = p1; t3 = p2; } \n    \n\n    \n    // Threading two torus segments through each pair of faces on the tetrahedron.\n    \n    // Used to hold the distance field values for the tori segments and the bolts.\n    // v.xy holds the first torus and bolt values, and v.zw hold the same for the second torus.\n    vec4 v;\n    \n    // Axial point of the torus segment, and the normal from which the orthonormal bais is derived.\n    vec3 q, bn; \n \n    \n    // I remember reasoning that the outer torus radius had to be this factor (sqrt(6)/8), but I \n    // can't for the life of me remember why. A lot of tetrahedral lengths involve root six. I \n    // think it's equal to the tetrahedral circumradius... I'm not happy with that explanation either, \n    // so I'll provide a proper explanation later. :D Either way, it's the only value that fits.\n    float rad = .306186218; // Equal to sqrt(6)/8.\n    float rad2 = .025; // The smaller cross-sectional torus radius.\n\n\n    // Positioning the center of each torus at the corresponding edge mid-point, then aligning with\n    // the direction of the edge running through the midpoint. One of the ways to align an object is to\n    // determine a face normal, construct an orthonormal basis from it, then multiply the object by it\n    // relative to its position. On a side note, orientation could probably be achieved with a few \n    // matrix rotations instead, which may or may not be cheaper, so I'll look into it later.\n    \n    // First torus. Centered on the line between verticies t0 and t1, and aligned to the face that\n    // the edge runs through.\n    bn = (t0 - t1)*1.1547005; // Equivalent to normalize(t0 - t1);\n    q = basis(bn)*(p - mix(t0, t1, .5)); // Applying Nimitz's basis formula to the point to realign it.\n    v.xy = tor(q, rad, rad2); // Obtain the first torus distance.\n\n    // Second torus. Centered on the line between verticies t2 and t3, and aligned to the face that\n    // the edge runs through.\n    bn = (t2 - t3)*1.1547005; // Equivalent to normalize(t2 - t3);\n    q = basis(bn)*(p - mix(t2, t3, .5)); // Applying Nimitz's basis formula to the point to realign it.\n    v.zw = tor(q, rad, rad2); // Obtain the second torus distance.\n\n    // Determine the minium torus value, v.x, and the minimum bolt value, v.y.\n    v.xy = min(v.xy, v.zw);\n    \n \n    // Object ID. It's either the ribbed torus itself or a bolt.\n    objID = step(v.x, v.y);\n\n    // Return the minimum surface point.\n    return min(v.x, v.y);\n    \n    \n}\n\n// The main distance field function. In this case, it's just calling the \n// simplex Truchet object.\nfloat map(vec3 p){\n    \n \n    p.xy -= path(p.z).xy; // Perturb the object around the camera path.\n    \n\n    float ns = simplexTruchet(p); // The Truchet object.\n    \n    // If a field function adheres to Lipschitz conditions, then no ray shortening is\n    // necessary, but this one seems to require just a touch. I've tried to use the highest \n    // shortening factor possible.\n    return ns*.9;\n    \n}\n\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 bumpMap(sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n    \n}\n\n\n// Standard raymarching routine.\nfloat trace(vec3 ro, vec3 rd){\n   \n    float t = 0., d;\n    \n    for (int i=0; i<96; i++){\n\n        d = map(ro + rd*t);\n        \n        if(abs(d)<.001*(t*.125 + 1.) || t>FAR) break;//.001*(t*.125 + 1.)\n        \n        t += d; // Using slightly more accuracy in the first pass.\n    }\n    \n    return min(t, FAR);\n}\n\n\n\n// Cheap shadows are the bain of my raymarching existence, since trying to alleviate artifacts is an excercise in\n// futility. In fact, I'd almost say, shadowing - in a setting like this - with limited  iterations is impossible... \n// However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k, float t){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 24; \n    \n    vec3 rd = lp-ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = .001*(t*.125 + 1.);  // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        dist += clamp(h, .01, .25); \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0.0 || dist > end) break; \n    }\n\n    // I've added a constant to the final shade value, which lightens the shadow a bit. It's a preference thing. \n    // Really dark shadows look too brutal to me. Sometimes, I'll add AO also, just for kicks. :)\n    return min(max(shade, 0.) + .1, 1.); \n}\n\n/*\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical. Due to \n// the intricacies of this particular scene, it's kind of needed to reduce jagged effects.\nvec3 getNormal(in vec3 p) {\n\tconst vec2 e = vec2(0.002, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n\n*/\n\n// Normal calculation, with some edging and curvature bundled in.\nvec3 getNormal(vec3 p, inout float edge, inout float crv) { \n\t\n    // Roughly two pixel edge spread, regardless of resolution.\n    vec2 e = vec2(2./iResolution.y, 0);\n\n\tfloat d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\tfloat d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\tfloat d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\tfloat d = map(p)*2.;\n\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    //edge = abs(d1 + d2 + d3 + d4 + d5 + d6 - d*3.);\n    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n/*    \n    // Wider sample spread for the curvature.\n    e = vec2(12./450., 0);\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx);\n    crv = clamp((d1 + d2 + d3 + d4 + d5 + d6 - d*3.)*32. + .5, 0., 1.);\n*/\n    \n    e = vec2(.002, 0); //iResolution.y - Depending how you want different resolutions to look.\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\t\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calculateAO(in vec3 pos, in vec3 nor)\n{\n\tfloat sca = 2.0, occ = 0.0;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = 0.01 + float(i)*0.5/4.0;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\n// Coloring\\texturing the scene objects, according to the object IDs.\nvec3 getObjectColor(vec3 p, vec3 n){\n    \n    // Object texture color.\n\n    vec3 tx = tex3D(iChannel0, p, n);\n    tx = smoothstep(.05, .5, tx);\n\n    // Shading the steel tubes sepia grey and giving the bolts a splash\n    // of color, just to break up the monotony a bit.\n    if(svObjID>.5) tx *= vec3(1.25, 1., .8); // Steel tubes.\n    else tx *= vec3(.9, .6, .3); // Bolts.\n    \n    return tx; // Return the texture.\n    \n}\n\n\n// Simple environment mapping. Pass the reflected vector in and create some\n// colored noise with it. It's fake, obviously, but gives a bit of a shiny\n// reflected-pass vibe.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 eMap(vec3 rd, vec3 sn){\n    \n    // Pass the reflected vector into the object color function.\n    vec3 tx = getObjectColor(rd, sn);\n    return smoothstep(.15, .75, tx);\n \n}\n\n// Using the hit point, unit direction ray, etc, to color the scene. Diffuse, specular, falloff, etc. \n// It's all pretty standard stuff.\nvec3 doColor(in vec3 ro, in vec3 rd, in vec3 lp, float t){\n    \n    // Initiate the scene (for this pass) to zero.\n    vec3 sceneCol = vec3(0);\n    \n    if(t<FAR){ // If we've hit a scene object, light it up.\n        \n         // Surface position.\n   \t\t vec3 sp = ro + rd*t;\n        \n        // Edge and curvature variables. Passed to the normal functions.\n        float edge = 0., crv = 1.;\n\n        // Retrieving the normal at the hit point, plus the edge and curvature values.\n        vec3 sn = getNormal(sp, edge, crv);\n        //vec3 sn = getNormal(sp);\n        vec3 svSn = sn; // Save the unbumped normal.\n\n        // Texture-based bump mapping.\n        // Contorting the texture coordinates to match the contorted scene.\n        sn = bumpMap(iChannel0, sp*2., sn, .01);\n        \n        // Less bumped normal for the fake environment mapping. Sometimes, I prefer it.\n        svSn = mix(sn, svSn, .75); \n\n\n        // Shading. Shadows, ambient occlusion, etc.\n        float sh = softShadow(sp + sn*.00125, lp, 16., t); // Set to \"1.,\" if you can do without them.\n        float ao = calculateAO(sp, sn);\n        sh = (sh + ao*.3)*ao;\n\n    \n        vec3 ld = lp - sp; // Light direction vector.\n        float lDist = max(length(ld), 0.001); // Light to surface distance.\n        ld /= lDist; // Normalizing the light vector.\n\n        // Attenuating the light, based on distance.\n        float atten = 2./(1. + lDist*0.125 + lDist*lDist*0.25);\n\n        // Diffuse term.\n        float diff = max(dot(sn, ld), 0.);\n        diff = (pow(diff, 2.)*.66 + pow(diff, 4.)*.34)*2.; // Ramping up the diffuse.\n        // Specular term.\n        float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 32.0);\n        // Fresnel term.\n        float fres = clamp(1. + dot(rd, sn), 0., 1.);\n        //float Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.0);\n        //float fre2 = mix(.5, 1., Schlick);  //F0 = .5.\n\n        // Coloring the object. You could set it to a single color, to\n        // make things simpler, if you wanted.        \n        vec3 objCol = getObjectColor(sp*2., sn);\n\n        // Combining the above terms to produce the final scene color.\n        sceneCol = objCol*(diff + .5*ao + fres*fres*.25) + vec3(1, .97, .92)*spec*2.;\n        //sceneCol += fres*fres*vec3(.2, .6, 1)*.5;\n        \n        sceneCol += eMap(reflect(rd, svSn)/2., svSn)*.75;\n        \n        // Edges and curvature.\n        //sceneCol *= clamp(crv, 0., 1.);\n        //sceneCol += (sceneCol*.75 + .25)*edge;\n        sceneCol *= 1. - edge*.9;\n        \n\n        // APPLYING SHADOWS\n    \tsceneCol *= sh;  \n        \n        // Attenuation only. To save cycles, the shadows and ambient occlusion\n        // from the first pass only are used.\n        sceneCol *= atten;\n    \n    }\n    \n    \n    // APPLYING FOG\n    // Blend in a bit of light fog for atmospheric effect.\n    vec3 fogCol = vec3(0);//vec3(.7, .8, 1.)*(rd.y*.5 + .5)*2.5;\n    sceneCol = mix(sceneCol, fogCol, smoothstep(0., .75, t/FAR)); // exp(-.002*t*t), etc.\n\n    \n  \n    // Return the color. Done once for each pass.\n    return sceneCol;\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5) / iResolution.y;\n    \n\t// Camera Setup.\n\tvec3 ro = vec3(0, 0, iTime*.5); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(0, 0, .25);  // \"Look At\" position.\n\n   \n    // Light position. Set in the vicinity the ray origin.\n    vec3 lp = ro + vec3(0, 1, .375);\n    \n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and light vector down the tunnel. The \"path\" function is \n\t// synchronized with the distance function.\n    ro.xy += path(ro.z);\n\tlk.xy += path(lk.z);\n\tlp.xy += path(lp.z);\n \n    \n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159/2.; // FOV - Field of view.\n    vec3 forward = normalize(lk - ro);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(forward + (uv.x*right + uv.y*up)*FOV);\n    rd = normalize(vec3(rd.xy, rd.z - length(rd.xy)*.25 ));\n\n    \n    // Raymarching.\n    // Obtain the scene distance.    \n    float t = trace(ro, rd);\n\n    svObjID = objID; // Save the ID.\n    \n    // Coloring.\n    // Retrieving the color at the hit point.\n    vec3 sceneColor = doColor(ro, rd, lp, t);\n    \n    \n    // Postprocessing.\n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    sceneColor *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125)*.5 + .5;\n    // Colored varation.\n    //sceneColor = mix(pow(min(vec3(1.5, 1, 1)*sceneColor, 1.), vec3(1, 2.5, 12.)).zyx, sceneColor, \n                    // pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y) , .125)*.5 + .5);\n    \n\n    // Clamping the scene color, roughly gamma correcting, then presenting to the screen.\n\tfragColor = vec4(sqrt(clamp(sceneColor, 0., 1.)), 1);\n}\n\n", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsffWj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsffWS", "name": "Red light", "author": "h13579", "description": "First shader, followed this tutorial: https://www.youtube.com/watch?v=u5HAYVHsasc", "tags": ["2d"], "likes": 0, "viewed": 85, "date": "1497680819", "time_retrieved": "2024-06-20T18:57:20.084366", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -=.5; \n    uv.x *= iResolution.x/iResolution.y;\n    \n    float d = length(uv);\n    float r = 0.3 * abs(cos(iTime));\n    float c = smoothstep(r, r+0.1, d);\n\tfragColor = vec4(1.0, vec2(c), 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsffWS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsffzS", "name": "Cube Tracing with Animated Voxel", "author": "culdevu", "description": "This is another proof-of-concept (read: I couldn't be bothered to make it look good) where I modified my previous voxel shader to animate the voxels.", "tags": ["raytracing", "voxel", "animated"], "likes": 11, "viewed": 619, "date": "1496765571", "time_retrieved": "2024-06-20T18:57:21.599262", "image_code": "/* \n    Author: Daniel Taylor\n\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\tI got the cool idea the other day. Instead of voxel tracing animated models, why don't\n\tI try animated the actual voxels instead!\n\n\tThis is slow, unfortunately. It can be made a lot faster by ensuring that the camera\n\tis always at the origin. This code doesn't assume that, though.\n\n\tAlso, the AO is made by the same broken system as my last one: \n\t\thttps://www.shadertoy.com/view/XssfDN\n\tIt looks terrible, though. Don't use it. The same effect could easily be accomplished\n\tby the old SDF method, and it would look a lot nicer.\n\n\tAlso note this is almost a direct copy-and-paste of my truncated-octohedron tracer. The\n\timportant changes are highlighted with exclamation marks (!!!!). Honestly, not much has\n\tchanged. Mostly just stability-related things.\n*/\n\n#define PI 3.14159\n \n// Plane-Ray intersection\nfloat fp(vec3 p, vec3 r, vec3 n)\n{\n    if (abs(dot(n, r)) < 0.001)\n        return 10000.;\n    return dot(n, p) / dot(n, r);\n}\n\n// Ulities\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\nfloat sgn(int a)\n{\n    return (a > 0) ? 1. : -1.;\n}\nfloat sgn(float a)\n{\n    return (a > 0.) ? 1. : -1.;\n}\nint isgn(int a)\n{\n    return int(sgn(a));\n}\nvoid round1(inout vec3 r)\n{\n    r.xyz = floor(r.xyz + 0.5);\n}\n\n// Determines which cells are solid based on their centers\nbool isSolid(vec3 center)\n{\n    if (center.y <= 0.)\n        return true;\n    if (length(center) < 8.)\n        return true;\n    if (abs(center.z) < 2. && abs(length(center.xy) - 20.) < 5.)\n        return true;\n    \n    return false;\n}\n\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  \n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  \n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c          );\n}\n#define rotMat rotationMatrix(normalize(vec3(1,1,1)), iTime/1.5)\n\n//---------------------------------------------------\n// Intersection and tracing code\n//---------------------------------------------------\n\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n// Inspired by dr2's take on the truncated octohedron code:\n// (https://www.shadertoy.com/view/MdffRS)\nvec3 Fv(int i)\n{\n    vec3 r = vec3(1,0,0);\n    if (i == 1)\n        r = vec3(0,1,0);\n    if (i == 2)\n        r = vec3(0,0,1);\n    return rotMat * r;\n}\n\n// This just tests against a bunch of planes\nfloat truncOctInner(vec3 p, vec3 ray, out int best_norm)\n{\n    float best_d = 1000.0;\n    best_norm = -1;\n    \n    vec3 offset, n;\n    float d;\n    \n    for (int i = 0; i < 3; ++i)\n    {\n        offset = Fv(i);\n        n = normalize(offset);\n        d = fp(p + offset, ray, n);\n        if (d < best_d && dot(n, ray) > 0.)\n        {\n            best_d = d;\n            best_norm = i + 1;\n        }\n        \n        offset = -offset;\n        n = normalize(offset);\n        d = fp(p + offset, ray, n);\n        if (d < best_d && dot(n, ray) > 0.)\n        {\n            best_d = d;\n            best_norm = -i - 1;\n        }\n    }\n    \n    return best_d;\n}\n\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n// This is the worst possible way to do this, but I can't\n// think of any other (remotely easy) way.\n// This is also a large part of why the shader is slow. If you\n// can fix this, you can speed the entire thing up.\nvec3 findCenter(vec3 o)\n{\n    vec3 center = vec3(0);\n    float L = length(o);\n    vec3 ray = normalize(o);\n    o = vec3(0);\n\n    float d = 0.;\n    int normId;\n    \n    // keeps track of the total distance traveled\n    float totalD = 0.;\n    \n    for (int i = 0; i < 30; ++i)\n    {\n        d = truncOctInner(center - o, ray, normId);\n        o = o + ray * d;\n        \n        totalD += d;\n        \n        if (totalD > L)\n        {\n            return center;\n        }\n        \n        center += float(sign(normId)) * 2. * Fv( abs(normId - sign(normId)) );\n    }\n    \n    return vec3(0,0,0);\n}\n\n// This is just cube marching\nfloat traceTruncOct(vec3 o, vec3 ray, out vec3 norm, out vec3 center, int depth)\n{\n    center = findCenter(o);\n    \n    norm = vec3(0);\n    float d = 0.;\n    vec3 p = center - o;\n    \n    int normId;\n    \n    // keeps track of the total distance traveled\n    float totalD = 0.;\n    \n    for (int i = 0; i < depth; ++i)\n    {\n        d = truncOctInner(p, ray, normId);\n        o = o + ray * d;\n        center += float(sign(normId)) * 2. * Fv( abs(normId - sign(normId)) );\n        p = center - o;\n        \n        totalD += d;\n        \n        if (isSolid(center))\n        {\n            norm = -float(sign(normId)) * normalize(Fv( abs(normId - sign(normId)) ));\n            return totalD;\n        }\n    }\n    \n    return -1.;\n}\n\nfloat aoDist(vec3 o, vec3 center, vec3 norm)\n{\n    vec3 trash;\n    o += norm / 5.;\n    \n    float best = 0.;\n    vec3 r;\n    \n    for (int i = 0; i < 3; ++i)\n    {\n        // these two lines are equivalent to:\n        //   vec3 p = Fv(i)\n        //   vec3 q = p;\n        // for cubes. This form is for truncated octohedrons.\n        // I'm not sure if this generalizes to any other space-filling\n        // polyhedra or not.\n        //\n        // Either way, it looks horrible. Don't do this.\n        vec3 p = normalize(Fv(i));\n        vec3 q = p - norm * dot(norm, p);\n        \n        if (dot(o - center, q) > best && dot(norm, p) < 0.95)\n        {\n            r = q;\n            best = dot(o - center, q);\n        }\n        \n        q = -q;\n        if (dot(o - center, q) > best && dot(norm, p) < 0.95)\n        {\n            r = q;\n            best = dot(o - center, q);\n        }\n    }\n    \n    return traceTruncOct(o, normalize(r), trash, trash, 1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y - vec2(iResolution.x/iResolution.y/2., 0.5);\n    float mouseU = 2. * (iMouse.x / iResolution.x - 0.5);\n    vec3 trash;\n    \n    vec3 cam = vec3(0,8,30.);\n    vec3 screenPos = vec3(uv, -0.5);\n    \n    pR(cam.xz, mouseU * 2. * PI);\n    pR(screenPos.xz, mouseU * 2. * PI);\n    \n    vec3 ray = normalize(screenPos);\n    \n    vec3 norm, center;\n    float d = traceTruncOct(cam, ray, norm, center, 80);\n    vec3 pt = cam + ray*d;\n    \n    if (d < 0.)\n    {\n        fragColor = vec4(uv.y);\n        return;\n    }\n    \n    //--------------------------------------------------\n    // Lighting Time!\n    //--------------------------------------------------\n    float ambient = 0.1;\n    float ao = aoDist(pt, center, norm);\n    if (ao < 0.)\n        ao = 5.0;\n    if (ao/5. < 0.1)\n        ambient = ao/5.;\n    \n    // Lighting\n    vec3 light = 10. * vec3(1,1,1);\n    vec3 lightDir = d*ray + cam - light;\n    float lightIntensity = 10.0;\n    \n    // These shadows look really ugly.\n    // I'm not all that knowledged about how cube marching people do shadows,\n    // but it's probably *not* something like this... oh well.\n    // If you have any suggestions, please tell me!\n    float lightDist = traceTruncOct(light, normalize(lightDir), trash, trash, 40);\n    float shadow = 0.;\n    if (abs(lightDist - length(lightDir)) < 0.2)\n        shadow = 1.;\n    \n    // Yeah, that's right, I used linear falloff. Sue me.\n    fragColor = shadow * lightIntensity * vec4(max(0., dot(norm, -normalize(lightDir)) )) / length(lightDir);\n    fragColor += vec4(ambient);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsffzS.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XslBDl", "name": "Desert Town", "author": "dr2", "description": "More fun with rounded Voronoi shapes (mousing encouraged)", "tags": ["voronoi", "raymarch", "hexagon", "smooth"], "likes": 7, "viewed": 562, "date": "1498825473", "time_retrieved": "2024-06-20T18:57:21.605575", "image_code": "// \"Desert Town\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nmat3 flMat;\nvec3 flPos, sunDir;\nvec2 gVec[7], hVec[7];\nfloat tCur, dstFar;\nconst float pi = 3.14159;\n\n#define SQRT3 1.73205\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./SQRT3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (SQRT3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvoid HexVorInit ()\n{\n  vec3 e = vec3 (1., 0., -1.);\n  gVec[0] = e.yy;\n  gVec[1] = e.xy;\n  gVec[2] = e.yx;\n  gVec[3] = e.xz;\n  gVec[4] = e.zy;\n  gVec[5] = e.yz;\n  gVec[6] = e.zx;\n  for (int k = 0; k < 7; k ++) hVec[k] = HexToPix (gVec[k]);\n}\n\nvec4 HexVor (vec2 p)\n{\n  vec4 sd, udm;\n  vec2 ip, fp, d, u;\n  float amp, a;\n  amp = 0.5;\n  ip = PixToHex (p);\n  fp = p - HexToPix (ip);\n  sd = vec4 (4.);\n  udm = vec4 (4.);\n  for (int k = 0; k < 7; k ++) {\n    u = Hashv2v2 (ip + gVec[k]);\n    a = 2. * pi * (u.y - 0.5);\n    d = hVec[k] + amp * (0.4 + 0.6 * u.x) * vec2 (cos (a), sin (a)) - fp;\n    sd.w = dot (d, d);\n    if (sd.w < sd.x) {\n      sd = sd.wxyw;\n      udm = vec4 (d, u);\n    } else sd = (sd.w < sd.y) ? sd.xwyw : ((sd.w < sd.z) ? sd.xyww : sd);\n  }\n  sd.xyz = sqrt (sd.xyz);\n  return vec4 (SmoothMin (sd.y, sd.z, 0.1) - sd.x, udm.xy, Hashfv2 (udm.zw));\n}\n\nfloat GrndHt (vec2 p)\n{\n  vec4 sv;\n  float h1, h2, s;\n  sv = HexVor (0.15 * p);\n  s = (0.8 + 0.5 * sv.w);\n  h1 = s * smoothstep (0.2, 0.4 + 0.2 * sv.w, sv.x);\n  h2 = 1.3 * s * smoothstep (0.2, 0.4 + 0.2 * sv.w, max (0.,\n     (0.3 - dot (sv.yz, sv.yz))));\n  return 3. * SmoothMax (h1, h1 + h2, 0.2) - 0.5;\n}\n\nfloat GrndCol (vec2 p)\n{\n  vec4 sv;\n  float h, s;\n  sv = HexVor (0.15 * p);\n  s = (0.8 + 0.5 * sv.w);\n  h = 1.3 * s * smoothstep (0.2, 0.4 + 0.2 * sv.w, max (0.,\n     (0.3 - dot (sv.yz, sv.yz))));\n  return (h > 0.1) ? 1. + sv.w : 0.;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  dHit = dstFar;\n//  s = max (0., - (ro.y - 4.) / rd.y); // old\n  if (rd.y < 0.) { // new\n    s = - (ro.y - 4.) / rd.y;\n    sLo = s;\n    for (int j = 0; j < 200; j ++) {\n      p = ro + s * rd;\n      h = p.y - GrndHt (p.xz);\n      if (h < 0.) break;\n      sLo = s;\n      s += max (0.2, 0.4 * h);\n      if (s > dstFar) break;\n    }\n    if (h < 0.) {\n      sHi = s;\n      for (int j = 0; j < 5; j ++) {\n        s = 0.5 * (sLo + sHi);\n        p = ro + s * rd;\n        if (p.y > GrndHt (p.xz)) sLo = s;\n        else sHi = s;\n      }\n      dHit = 0.5 * (sLo + sHi);\n    }\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec2 e = vec2 (0.01, 0.);\n  float h;\n  h = GrndHt (p.xz);\n  return normalize (vec3 (h - GrndHt (p.xz + e.xy), e.x, h - GrndHt (p.xz + e.yx)));\n}\n\nvec3 SkyBg (vec3 rd)\n{\n  return vec3 (0.2, 0.3, 0.55) + 0.1 * pow (1. - max (rd.y, 0.), 4.);\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  float sd, f;\n  sd = max (dot (rd, sunDir), 0.);\n  ro.x += 0.5 * tCur;\n  f = 0.5 * Fbm2 (0.1 * (rd.xz * (50. - ro.y) / rd.y + ro.xz));\n  col = SkyBg (rd) + 0.35 * pow (sd, 6.) + 0.65 * min (pow (sd, 256.), 0.3);\n  return mix (col, vec3 (0.85), clamp (f * rd.y + 0.1, 0., 1.));\n}\n\nfloat GrndSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float sh, d, h;\n  sh = 1.;\n  d = 1.;\n  for (int j = 0; j < 16; j ++) {\n    p = ro + rd * d;\n    h = p.y - GrndHt (p.xz);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += 0.3;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 flmCol, col, vn;\n  float dstGrnd, sh, f;\n  HexVorInit ();\n  dstGrnd = GrndRay (ro, rd);\n  if (dstGrnd < dstFar) {\n    ro += dstGrnd * rd;\n    vn = VaryNf (2. * ro, GrndNf (ro), 0.5);\n    sh = GrndSShadow (ro, sunDir);\n    if (ro.y > -0.3) {\n      f = GrndCol (ro.xz);\n      col = (f == 0.) ?\n         vec3 (1., 0.9, 0.7) : vec3 (0.2, 0.6, 1.) * (1.2 - 0.4 * (f - 1.));\n    } else col = vec3 (0.4, 0.1, 0.);\n    col *= 1. - 0.2 * Noisefv2 (100. * ro.xz);\n    col = col * (0.1 + 0.1 * max (vn.y, 0.) +\n       0.2 * max (dot (vn, - sunDir), 0.) +\n       0.8 * sh * max (0., max (dot (vn, sunDir), 0.))) +\n       0.1 * sh * pow (max (dot (normalize (sunDir - rd), vn), 0.), 64.);\n    f = dstGrnd / dstFar;\n    f *= f;\n    col = mix (col, SkyBg (rd), max (f * f - 0.1, 0.));\n  } else col = SkyCol (ro, rd);\n  return pow (clamp (col, 0., 1.), vec3 (0.8));\n}\n\nvec3 TrackPath (float t)\n{\n  return vec3 (30. * sin (0.035 * t) * sin (0.012 * t) * cos (0.01 * t) +\n     26. * sin (0.0032 * t), 1. + 3. * sin (0.021 * t) * sin (1. + 0.023 * t), t);\n}\n\nvoid VuPM (float t)\n{\n  vec3 fpF, fpB, vel, acc, va, ort, cr, sr;\n  float dt;\n  dt = 2.;\n  flPos = TrackPath (t);\n  fpF = TrackPath (t + dt);\n  fpB = TrackPath (t - dt);\n  vel = (fpF - fpB) / (2. * dt);\n  vel.y = 0.;\n  acc = (fpF - 2. * flPos + fpB) / (dt * dt);\n  acc.y = 0.;\n  va = cross (acc, vel) / length (vel);\n  ort = vec3 (0.2, atan (vel.z, vel.x) - 0.5 * pi, 5. * length (va) * sign (va.y));\n  cr = cos (ort);\n  sr = sin (ort);\n  flMat = mat3 (cr.z, - sr.z, 0., sr.z, cr.z, 0., 0., 0., 1.) *\n     mat3 (1., 0., 0., 0., cr.x, - sr.x, 0., sr.x, cr.x) *\n     mat3 (cr.y, 0., - sr.y, 0., 1., 0., sr.y, 0., cr.y);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd;\n  vec2 canvas, uv, ori, ca, sa;\n  float az, el;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = 0.;\n  VuPM (10. * tCur);\n  ro = flPos;\n  rd = normalize (vec3 (uv, 2.5));\n  if (mPtr.z > 0.) {\n    az = -2. * pi * mPtr.x;\n    el = -0.1 * pi + pi * mPtr.y;\n    ori = vec2 (el, az);\n    ca = cos (ori);\n    sa = sin (ori);\n    vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n       mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n    rd = vuMat * rd;\n  } else {\n    rd = rd * flMat;\n  }\n  ro.y += 12.;\n  sunDir = normalize (vec3 (cos (0.01 * tCur), 0.5, - sin (0.01 * tCur)));\n  dstFar = 200.;\n  fragColor = vec4 (ShowScene (ro, rd), 1.);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nconst vec4 cHashA4 = vec4 (0., 1., 57., 58.);\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, cHashA3.xy)) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + cHashA4.xy) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + cHashA4) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  const vec2 cHashVA2 = vec2 (37.1, 61.7);\n  const vec2 e = vec2 (1., 0.);\n  return fract (sin (vec2 (dot (p + e.yy, cHashVA2),\n     dot (p + e.xy, cHashVA2))) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  const vec3 cHashVA3 = vec3 (37.1, 61.7, 12.4);\n  const vec3 e = vec3 (1., 0., 0.);\n  return fract (sin (vec4 (dot (p + e.yyy, cHashVA3), dot (p + e.xyy, cHashVA3),\n     dot (p + e.yxy, cHashVA3), dot (p + e.xxy, cHashVA3))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 i = floor (p);\n  vec2 f = fract (p);\n  f = f * f * (3. - 2. * f);\n  vec4 t = Hashv4f (dot (i, cHashA3.xy));\n  return mix (mix (t.x, t.y, f.x), mix (t.z, t.w, f.x), f.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f;\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s = vec3 (0.);\n  float a = 1.;\n  for (int i = 0; i < 5; i ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  float s;\n  const vec3 e = vec3 (0.1, 0., 0.);\n  s = Fbmn (p, n);\n  g = vec3 (Fbmn (p + e.xyy, n) - s, Fbmn (p + e.yxy, n) - s,\n     Fbmn (p + e.yyx, n) - s);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XslBDl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XslBWl", "name": "Blured Image", "author": "c0de4", "description": "", "tags": ["2d"], "likes": 1, "viewed": 117, "date": "1498820773", "time_retrieved": "2024-06-20T18:57:22.235980", "image_code": "// thanks to: https://wgld.org/\n\n#define time iTime\n#define mouse iMouse\n#define resolution iResolution\n\nvec3 rotate(vec3 p, float angle, vec3 axis){\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nfloat random (in vec2 st) { \n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233))) \n                * 43758.5453123);\n}\n\n// The MIT License\n// Copyright  2013 Inigo Quilez\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n    \n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( random( i + vec2(0.0,0.0) ), \n                     random( i + vec2(1.0,0.0) ), u.x),\n                mix( random( i + vec2(0.0,1.0) ), \n                     random( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nconst vec3 lightDir = vec3(-0.577, 0.577, 0.577);\n\nfloat sphere(vec3 p, float size) {\n  p += vec3(cos(time*.1*size+noise(vec2(time))), sin(time*size), cos(time*size));\n\n  vec3 q = vec3(noise(vec2(time)), noise(vec2(time)), noise(vec2(time)));\n  return length(mod(p, .4) - .2) - size;\n}\n\n\nfloat distanceFunc(vec3 p){\n  \n  p += vec3(cos(time*.1), sin(time*.1), cos(time*.1));\n  p = rotate(p, radians(time)*1., vec3(1., 0., 0.));\n\n  float obj1 = sphere(p, .1);\n  float obj2 = max(-obj1, sphere(p*p, .2));\n  float obj3 = min(obj2, sphere(p-obj1-obj2, .4));\n\n  \n  float dist = obj3;\n\n  return dist *max(-obj1, min(obj2, obj3) );\n}\n\nvec3 getNormal(vec3 p){\n    float d = 0.1;\n    return normalize(vec3(\n        distanceFunc(p + vec3(  d, 0.0, 0.0)) - distanceFunc(p + vec3( -d, 0.0, 0.0)),\n        distanceFunc(p + vec3(0.0,   d, 0.0)) - distanceFunc(p + vec3(0.0,  -d, 0.0)),\n        distanceFunc(p + vec3(0.0, 0.0,   d)) - distanceFunc(p + vec3(0.0, 0.0,  -d))\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // fragment position\n    vec2 p = (fragCoord.xy * 2.0 - resolution.xy) / min(resolution.x, resolution.y);\n    \n    // camera\n    vec3 cPos = vec3(0.0,  0.0,  2.);\n    vec3 cDir = vec3(0.0,  0.0, -1.);\n    vec3 cUp  = vec3(0.0,  1.0,  0.0);\n    vec3 cSide = cross(cDir, cUp);\n    float targetDepth = 1.;\n    \n    // ray\n    vec3 ray = normalize(cSide * p.y - cUp * p.x + cDir * targetDepth);\n    \n    // marching loop\n    float distance = 0.0;\n    float rLen = 0.0;\n    vec3  rPos = cPos;\n    for(int i = 0; i < 16; i++){\n        distance = distanceFunc(rPos);\n        rLen += distance;\n        rPos = rPos * .2 + max(-(cPos - ray * rLen * .75), (cPos + ray * rLen * .75));\n    }\n    \n    // hit check\n  vec3 normal = getNormal(length(rPos) - length(p)*.5 - rPos*2.);\n        float diff = clamp(dot(lightDir*lightDir+noise(vec2(lightDir)), normal), 0.1, 1.0);\n    if(abs(distance) < .1){\n\n        fragColor = vec4(vec3(diff*.1, diff, diff*3.), 1.);\n    }else{\n        fragColor = vec4(vec3(0.), 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XslBWl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XslBWX", "name": "metaballs phong", "author": "abje", "description": "many metaballs moving in a pattern, experimenting with shading.", "tags": ["raymarching", "metaball"], "likes": 8, "viewed": 650, "date": "1498498933", "time_retrieved": "2024-06-20T18:57:22.241986", "image_code": "#define time iTime\n\nfloat dot2(vec3 p) {\n    return dot(p,p);\n}\n\nfloat map(vec3 p) {\n    float len = 0.0;\n    \n    for(float i = 1.0; i < 20.0; i++) {\n        vec3 sphere = vec3(sin(time*i*0.1),cos(time*i*0.12),0.0)*10.0;\n        len += 1.0/dot2(p-sphere);\n    }\n    \n    return (inversesqrt(len)-1.0)*3.0;\n}\n\nvec3 findcolor(vec3 p) {\n    float len = 10000.0;\n    vec3 color = vec3(0.0);\n    for(float i = 1.0; i < 20.0; i++) {\n        float len2 = (dot2(p-vec3(sin(time*i*0.1),cos(time*i*0.12),0.0)*10.0));\n        \n        //random colors\n        color = mix(vec3(sin(i*9.11)*0.5+0.5,fract(1.0/fract(i*3.14)),fract(i*3.14)),\n                    color, clamp((len2-len)*0.1+0.5,0.0,1.0));\n        \n        len = mix(len2,len,clamp((len2-len)*0.1+0.5,0.0,1.0));\n    }\n    return color;\n}\n\nvec3 findnormal(vec3 p) {\n    vec2 eps = vec2(0.01,0.0);\n    \n    return normalize(vec3(\n        map(p+eps.xyy)-map(p-eps.xyy),\n        map(p+eps.yxy)-map(p-eps.yxy),\n        map(p+eps.yyx)-map(p-eps.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy*2.0-iResolution.xy) / iResolution.y;\n    \n    vec3 ro = vec3(0.0,0.0,-15.0);\n    vec3 rd = normalize(vec3(uv,1));\n    float len = 0.0;\n    float dist = 0.0;\n    \n    for (int i = 0; i < 50; i++) {\n        len = map(ro);\n        dist += len;\n        ro += rd * len;\n        if (dist > 30.0 || len < 0.01) {\n            break;\n        }\n    }\n    \n    if (dist < 30.0 && len < 0.01) {\n        vec3 sun = normalize(vec3(-1.0));\n        vec3 objnorm = findnormal(ro);\n        vec3 reflectnorm = reflect(rd,objnorm);\n        vec3 color = findcolor(ro);\n        fragColor = vec4(color*max(0.2,0.8*dot(objnorm,sun)),1.0);\n        fragColor = max(fragColor,(dot(reflectnorm,sun)-0.9)*12.0);\n    }\n    fragColor = sqrt(fragColor);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XslBWX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XslfRl", "name": "Jump into the Mandelbrot set", "author": "adambene", "description": "Mandelbrot set animated.", "tags": ["fractal", "mandelbrot", "mandelbrotset"], "likes": 1, "viewed": 92, "date": "1497559649", "time_retrieved": "2024-06-20T18:57:22.241986", "image_code": "#define PI 3.141592654\n\nconst vec2 center = vec2(.9266, 0.2623);\nconst int iter = 200;\n\nfloat triangle(float t) {\n    return .5 + .5 * cos(t + PI);\n\treturn smoothstep(0., 1., 1. - abs(mod(t, 2.) - 1.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat scale = 4. / (1. + 1000.*triangle(.5 * iTime));\n    \n    vec2 uv = fragCoord.xy / iResolution.y;\n    uv.x -= iResolution.y / iResolution.x;\n\n    vec2 z, c;\n    \n    c.x = (uv.x - 0.5) * scale - center.x;\n    c.y = (uv.y - 0.5) * scale - center.y;\n\n    int i;\n    z = c;\n    for(i=0; i<iter; i++) {\n        float x = (z.x * z.x - z.y * z.y) + c.x;\n        float y = (z.y * z.x + z.x * z.y) + c.y;\n\n        if((x * x + y * y) > 4.0) break;\n        z.x = x;\n        z.y = y;\n    }\n\n    float r = float(i) / float(iter);\n    fragColor = vec4(\n        r,\n        clamp(r, .0, .6) / .6,\n        clamp(r, .0, .4) / .4,\n        1.0\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XslfRl.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XssfDj", "name": "Cool rings", "author": "stas0", "description": "Cool rings", "tags": ["rings"], "likes": 3, "viewed": 409, "date": "1498163208", "time_retrieved": "2024-06-20T18:57:22.241986", "image_code": "#define PI 3.14159;\n\nfloat circ(vec2 p) {\n\tfloat r = length(p);\n    r = log(sqrt(r));\n    \n    return abs(mod(4. * r, 6.) - 3.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n   \tvec3 color = vec3(.0);\n    \n    float rz = 1.;\n    uv /= exp(mod(iTime * .15, 3.));\n    \n    rz *= abs(circ(uv));\n    \n    color = vec3(.2, .1, .6) / rz;\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XssfDj.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XssfDN", "name": "Truncated Octohedron Voxel Scene", "author": "culdevu", "description": "Truncated Octohedron voxel tracer proof-of-concept shader", "tags": ["3d", "raytracing", "polyhedra"], "likes": 19, "viewed": 856, "date": "1496337448", "time_retrieved": "2024-06-20T18:57:23.957392", "image_code": "/* \n    Author: Daniel Taylor\n\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\tOn the recent post made by Shane (https://www.shadertoy.com/view/4dsBz4) he mentioned how\n\the was wanting to see different types of voxel tracers, and that inspired me to build this.\n\n\tThere are exactly 5 convex polyhedra (with regular polygonal faces) that fill 3D space:\n\t\t\n\t\t-Triangular Prism      (possibly being worked on?)\n\t\t-Hexagonal Prism       (https://www.shadertoy.com/view/ldBcDd)\n\t\t-Cube                  (done many times before)\n\t\t-Truncated Octohedron  (this shader)\n\t\t-Gyrobifastigium       (https://www.shadertoy.com/view/4lcBWX)\n\n\tThis is just a proof-of-concept. It runs kinda slow, the shadows are messy. There's no\n\ttexturing or AO or any fancy stuff. Just... tracing.\n\n\tThe code itself is pretty simple. It's just cube marching, but with truncated octohedrons.\n\tThe only part that's interesting is the code for finding the cell centers, which is needed\n\tto start the tracing algo.\n\n\tThis thing needs a lot of work, so suggestions are welcome!\n\n\tUPDATE (6 June 2017): AO is kinda working now. Also, for a a reduced version of this shader,\n\t\tsee dr2's Mandelbrot tracer (https://www.shadertoy.com/view/MdffRS)\n\t\n\tUPDATE (6 Sept 2017): That annoying flickering is gone now. Please refer to the updated\n\t\tfindCenter function. It may be the case the dr2 already figured that out a while \n\t\tback, but trying to read his code gave me eye cancer.\n    \n\t(Also, for whatever reason, Shadertoy keeps eating this comment block. No idea why...)\n*/\n\n#define PI 3.14159 \n\n// Plane-Ray intersection\nfloat fp(vec3 p, vec3 r, vec3 n)\n{\n    if (dot(n, r) < 0.001)\n        return -1.;\n    return dot(n, p) / dot(n, r);\n}\n\n// Ulities\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\nfloat sgn(int a)\n{\n    return (a > 0) ? 1. : -1.;;\n}\nfloat sgn(float a)\n{\n    return (a > 0.) ? 1. : -1.;\n}\nint isgn(int a)\n{\n    return int(sgn(a));\n}\nvoid round1(inout vec3 r)\n{\n    r.xyz = floor(r.xyz + 0.5);\n}\n\n// Determines which cells are solid based on their centers\nbool isSolid(vec3 center)\n{\n    if (center.y <= 0.)\n        return true;\n    if (length(center) < 8.)\n        return true;\n    if (abs(center.z) < 2. && abs(length(center.xy) - 20.) < 5.)\n        return true;\n    \n    return false;\n}\n\n//---------------------------------------------------\n// Intersection and tracing code\n//---------------------------------------------------\nconst vec3 Fv[7] = vec3[](\n    vec3(1, 0, 0),\n    vec3(0, 1, 0),\n    vec3(0, 0, 1),\n\n    vec3(1, 1, 1 ) / 2.,\n    vec3(-1, 1, 1) / 2.,\n    vec3(1, -1, 1) / 2.,\n    vec3(1, 1, -1) / 2.\n);\n\n// This just tests against a bunch of planes\n// Side note: the planes defined by the Mercury SDF library\n// are incorrect\nfloat truncOctInner(vec3 p, vec3 ray, out int best_norm)\n{\n    float best_d = 1000.0;\n    best_norm = -1;\n    \n    vec3 offset, n;\n    float d;\n    \n    for (int i = 0; i < 7; ++i)\n    {\n        offset = Fv[i];\n        n = normalize(offset);\n        d = fp(p + offset, ray, n);\n        if (d < best_d && d > 0.)\n        {\n            best_d = d;\n            best_norm = i + 1;\n        }\n        \n        offset = -Fv[i];\n        n = normalize(offset);\n        d = fp(p + offset, ray, n);\n        if (d < best_d && d > 0.)\n        {\n            best_d = d;\n            best_norm = -i - 1;\n        }\n    }\n    \n    return best_d;\n}\n\n/* this is an improved findCenter function (much better than the more\n   brute-force previous version)\n   here's how it works:\n     the square faces oriented along the axes are of unit length, and the\n     hexagonal faces are oriented at (+-1, +-1, +-1)/2. Since the centers \n     of neighboring cells are reflections of the current one across the\n     cooresponding plane, the separations are just permutations of (+-2, 0, 0)\n     and (+-1, +-1, +-1).\n  \n     So, the end result of all of this is that every cell center (x,y,z) must \n     obey parity(x) = parity(y) = parity(z). Also, every integer triplet that\n     obeys this is also a center of a cell in this tesselation. So, all that's\n     left to do is to find the closest point to the point given which obeys this\n     property.\n*/\nvec3 findCenter(vec3 o)\n{\n    vec3 p = o;\n    vec3 tempSign = sign(p.xyz);\n    p = abs(p.xyz);\n    p = tempSign.xyz * floor(p.xyz + 0.5);\n    \n    vec3 parity = abs(mod(p.xyz, 2.0));\n    \n    if (abs(dot(parity, parity) - 1.5) > 1.0) // they all have the same parity\n    {\n        return p;\n    }\n    \n    // if not, then it must be the case that 2 of them have the same parity (pidgeonhole principle)\n    // so just add or subtract one to the last one to achieve that parity, whichever one is closer\n    \n    if (abs(parity.x - parity.y) < 0.5)\n    {\n        p.z += sgn(o.z - p.z);\n    }\n    if (abs(parity.x - parity.z) < 0.5)\n    {\n        p.y += sgn(o.y - p.y);\n    }\n    if (abs(parity.y - parity.z) < 0.5)\n    {\n        p.x += sgn(o.x - p.x);\n    }\n    \n    // for any point, there are 2 neighboring candidate centers that all have the same parity.\n    // so we need to pick the one that's closer\n    vec3 shift = vec3(sgn(o.x - p.x), sgn(o.y - p.y), sgn(o.z - p.z));\n    vec3 p2 = p + shift;\n\n    if (length(o - p) > length(o - p2))\n        return p2;\n    return p;\n}\n\n// This is just a modification of cube marching\nfloat traceTruncOct(vec3 o, vec3 ray, out vec3 norm, out vec3 center, int depth)\n{\n    center = findCenter(o);\n    \n    norm = vec3(0);\n    float d = 0.;\n    vec3 p = center - o;\n    \n    int normId;\n    \n    // keeps track of the total distance traveled\n    float totalD = 0.;\n    \n    for (int i = 0; i < depth; ++i)\n    {\n        d = truncOctInner(p, ray, normId);\n        o = o + ray * d;\n        center += float(sign(normId)) * 2. * Fv[abs(normId - sign(normId))];\n        p = center - o;\n        \n        totalD += d;\n        \n        if (isSolid(center))\n        {\n            norm = -float(sign(normId)) * normalize(Fv[abs(normId - sign(normId))]);\n            return totalD;\n        }\n    }\n    \n    return -1.;\n}\n\n// Okay, so this AO isn't at all as clever as the solution\n// I had originally planned. In fact, this is kinda gross.\n// It looks ugly and broken and someone should really fix it.\n// Don't use this unless there's no other option.\nfloat aoDist(vec3 o, vec3 center, vec3 norm)\n{\n    vec3 trash;\n    \n    float best = 0.;\n    vec3 r;\n    \n    for (int i = 0; i < 7; ++i)\n    {\n        vec3 p = normalize(Fv[i]);\n        vec3 q = p - norm * dot(norm, p);\n        \n        if (dot(o - center, q) > best && dot(norm, p) < 0.95 && dot(norm, p) > 0.05)\n        {\n            r = q;\n            best = dot(o - center, q);\n        }\n        \n        q = -q;\n        if (dot(o - center, q) > best && dot(norm, p) < 0.95 && dot(norm, p) > 0.05)\n        {\n            r = q;\n            best = dot(o - center, q);\n        }\n    }\n    \n    return traceTruncOct(o, normalize(r), trash, trash, 1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y - vec2(iResolution.x/iResolution.y/2., 0.5);\n    float mouseU = 2. * (iMouse.x / iResolution.x - 0.5);\n    vec3 trash;\n    \n    vec3 cam = vec3(0,8,20);\n    vec3 screenPos = vec3(uv, -0.5);\n    \n    pR(cam.xz, mouseU * 2. * PI);\n    pR(screenPos.xz, mouseU * 2. * PI);\n    \n    vec3 ray = normalize(screenPos);\n    \n    vec3 norm, center;\n    float d = traceTruncOct(cam, ray, norm, center, 80);\n    vec3 pt = cam + ray * d;\n    center = findCenter(cam + d * ray);\n    \n    if (d < 0.)\n    {\n        fragColor = vec4(0);\n        return;\n    }\n    \n    //--------------------------------------------------\n    // Lighting Time!\n    //--------------------------------------------------\n    float ambient = 0.15;\n    float ao = aoDist(pt, center, norm);\n    if (ao < 0.0)\n        ao = 5.0;\n    if (ao/3. < 0.1)\n        ambient = ao/3. + 0.05;\n    \n    // Lighting\n    vec3 light = 10. * vec3(sin(iTime), 1, cos(iTime));\n    vec3 lightDir = pt - light;\n    float lightIntensity = 10.0;\n    \n    // These shadows look really ugly.\n    // I'm not all that knowledged about how cube marching people do shadows,\n    // but it's probably *not* something like this... oh well.\n    // If you have any suggestions, please tell me!\n    float lightDist = traceTruncOct(light, normalize(lightDir), trash, trash, 40);\n    float shadow = 0.;\n    if (abs(lightDist - length(lightDir)) < 0.2)\n        shadow = 1.;\n    \n    // Yeah, that's right, I used linear falloff. Sue me.\n    fragColor = 0.6 * shadow * lightIntensity * vec4(dot(norm, -normalize(lightDir) )) / length(lightDir);\n    fragColor += vec4(ambient) + 0.6 * vec4(abs(dot(norm, -normalize(lightDir)) )) / length(lightDir);\n    //fragColor = vec4(ao/(ao + 1.));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XssfDN.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsXBDX", "name": "Trip in Tron 3", "author": "ocb", "description": "Just for fun, a TRON cover for \"Boreal Spring\" shader: [/url]https://www.shadertoy.com/view/ldXBRH[/url]\n\nUse mouse to look around.", "tags": ["raytracing", "grid", "tron", "aurora", "raymarcing"], "likes": 62, "viewed": 4250, "date": "1498393747", "time_retrieved": "2024-06-20T18:57:28.570267", "image_code": "// Author: ocb\n// Title: Trip in Tron 3\n\n// tron cover for Boreal Spring shader\n// https://www.shadertoy.com/view/ldXBRH\n\n\n// thanks to Dave Hoskins for his function (here named electric())\n// https://www.shadertoy.com/view/MdlXz8\n// function used to render fairyligths surface and path lag \n\n\n#define PI 3.141592653589793\n#define PIdiv2 1.57079632679489\n#define TwoPI 6.283185307179586\n#define INFINI 1000000000.\n\n#define maxTreeH 130.\n#define maxHill 300.\n#define cellH 430. \t/*treeH + maxHill*/\n#define cellD 100.\n#define maxCell 150\n#define TREE_DENSITY (abs(fract(cell.x/10.)-.5)*abs(fract(cell.y/10.)-.5))*10.\n\n// object name\n#define GND -1\n#define SKY -1000\n\n#define REDL 1\n#define MAGL 2\n#define BLUL 3\n#define YELL 4\n\n#define COTTA 10\n#define WALL 11\n#define ROOF 12\n\n#define TREE 20\n\n#define SNOWMAN 40\n#define BELLY 41\n#define HEAD 42\n#define HAT 43\n#define NOZ 44\n\n// ground parameters\n#define SHIFT 0.\n#define AMP 1.\n#define P1 .003\n#define P2 .0039999  /* P1*1.3333 */\n#define P3 .0059661  /* P1*1.9887 */\n\n#define DP2 .0039999 /*.00199995  /* AMP * P2 */\n#define DP3 .0059661 /*.00298305  /* AMP * P3 */\n\n#define NRM 4.   /* (1. + AMP + SHIFT) * 2. */\n\n//*******************************************************************************\n//Global var\n\nint hitObj = SKY;\nfloat T = INFINI;\n\n// object global\n// Ambiance light direction\nvec3 lightRay;\n// lights\nvec3 redO, magO, bluO, yelO;\nfloat redR, magR, bluR, yelR;\n// cotta\nvec3 wallO, roofO;\nfloat wallR, roofR, roofH;\nvec2 cottaCell;\n\n// snowpeople\nvec3 belO, hedO, hatO, nozO;\nfloat belR, hedR, hatH, hatR, nozH, nozR;\nvec2 snowmanCell;\n\n//tree\nvec3 treeO;\nfloat treeR, treeH;\n\n//*******************************************************************************\nfloat rand1 (in float v) { \t\t\t\t\t\t\n    return fract(sin(v) * 437585.);\n}\nfloat rand2 (in vec2 st,in float time) { \t\t\t\t\t\t\n    return fract(sin(dot(st.xy,vec2(12.9898,8.233))) * 43758.5453123+time);\n}\n\nfloat pattern(in vec2 st, in float index){\n    if (index > 0.5) return st.x;\n    else return st.y;\n}\n//*******************************************************************************\n// Ground fonction for ray marching *********************************************\nfloat ground(in vec2 p){\n    float len = max(1.,0.0001*length(p));\n    float hx = max(0., (sin(P1*(p.x+p.y)) + AMP*sin(P2*p.x+PIdiv2) + SHIFT) );\n    float hy = max(0., (sin(P1*(p.y+.5*p.x)) + AMP*sin(P3*p.y+PIdiv2) + SHIFT));\n    return maxHill*(hx+hy)/NRM/len;\n}\n\n// derivation of the above function\nvec3 getGndNormal(in vec2 p, in float h) {\n    if(h<.001) return vec3(0.,1.,0.);\n    else{\n        float len = max(1.,0.0005*length(p));\n        float dx = maxHill*( P1*cos(P1*(p.x+p.y)) + DP2*cos(P2*p.x+PIdiv2) )/NRM;\n        float dy = maxHill*( P1*cos(P1*(p.y+.5*p.x)) + DP3*cos(P3*p.y+PIdiv2) )/NRM;\n        return normalize(cross( vec3(1.,dx/len,0.), vec3(0.,dy/len,1.) ));\t\t// divided by len: We may call that \"normal fog\"\n    }\n}\n\n// Ray marching (only for ground)\nfloat gndRayTrace(in vec3 p, in vec3 ray){\n    float t = 0.;\n    float contact = .1;\n    float dh = p.y - ground(p.xz);\n    if(dh<contact) return .0001;\n    for(int i=0; i<100;i++){\n        t += dh;\t\t\t// t = dh/length(ray) but ray normalized\n        p += dh*ray;\n        if(p.y >= cellH && ray.y>=0.){\n            t = INFINI;\n            break;\n        }\n        dh = p.y - ground(p.xz);\n        if(abs(dh)<contact)break;\n    }\n    return t;\n}\n\n//*************************************************************************************\n// Primitives solution for raytracing *************************************************\nfloat sfcImpact(in vec3 p, in vec3 ray, in float h){\n    float t = (h-p.y)/ray.y;\n    if (t <= 0.001) t = INFINI;\n    return t;\n}\n\nfloat sphereImpact(in vec3 pos, in vec3 sphO, in float sphR, in vec3 ray){\n    float t = INFINI;\n    vec3 d = sphO - pos;\n    float b = dot(d, ray);\n    \n    if (b >= 0.){\t// check if object in frontside first (not behind screen)\n        float c = dot(d,d) - sphR*sphR;\n    \tfloat disc = b*b - c;\n    \tif (disc >= 0.){\n        \tfloat sqdisc = sqrt(disc);\n            float t1= b + sqdisc;\n            float t2= b - sqdisc;\n        \tt = min(t1,t2) ;\n        \tif (t <= 0.001){\n                t = max(t1,t2);\n                if (t <= 0.001) t = INFINI;\n            } \n        }\n    }\n    return t;\n}\n\nfloat coneImpact(in vec3 pos, in vec3 coneO, in float coneH, in float coneR, in vec3 ray){\n    float t = INFINI, dmin=0.;\n    vec3 d = coneO - pos;\n    float Dy = coneH + d.y;\n    float r2 = coneR*coneR/(coneH*coneH);\n    float b = dot(d.xz, ray.xz);\n    \n    float a = dot(ray.xz,ray.xz);\n    float c = dot(d.xz,d.xz) - r2*Dy*Dy;\n    float c1 = -b + r2*Dy*ray.y;\n    float disc = c1*c1 - (a - r2*ray.y*ray.y) * c;\n    if (disc >= 0.){\n        float sqdis = sqrt(disc);\n        float t1 = (-c1 + sqdis)/(a - r2*ray.y*ray.y);\n        float t2 = (-c1 - sqdis)/(a - r2*ray.y*ray.y);\n\n        float ofc = -ray.y*t1 + Dy;\n        t1 *= step(0.,ofc)*(1.-step(coneH,ofc));\n        if (t1 <= 0.001) t1 = INFINI;\n\n        ofc = -ray.y*t2 + Dy;\n        t2 *= step(0.,ofc)*(1.-step(coneH,ofc));\n        if (t2 <= 0.001) t2 = INFINI;\n\n        t = min(t1,t2);\n    }\n\n\treturn t;\n}\n\nvec2 cylinderImpact(in vec2 pos, in vec2 cylO, in float cylR, in vec2 ray){\n    float t1 = INFINI, t2 = INFINI;\n    vec2 delta = pos - cylO;\n\n    float a = dot(ray,ray);\n    float b = dot(delta, ray);\n    float c = dot(delta,delta) - cylR*cylR;\n    float d = b*b - a*c;\n    \n    if (d >= 0.){\n        float Vd = sqrt(d);\n        t1 = (-b - Vd)/a;\n        t2 = (-b + Vd)/a;\n        if(t1<0.001) t1 = INFINI;\n        if(t2<0.001) t2 = INFINI;\n    }\n    \n\treturn vec2(t1,t2);\n}\n\n//*******************************************************************************************\n// Color and render functions ***************************************************************\nvec3 skyGlow(in vec3 ray){\n    if(ray.y>=0.)return vec3(.5*max(ray.x+.7,0.)*(.8-max(0.,ray.y)), .35,.4)*(1.-ray.y)*(ray.x+1.5)*.4;\n    else return vec3(0.);\n}\n\nvec3 snowColor(in vec3 pos){\n    vec3 col = vec3(.7,.7,.75)+vec3(.05,.05,.05)*rand2(floor(pos.xz*10.), 0.);\n    col += vec3(1.,.7,.8)*step(.997,rand2 (floor(pos.xz*20.), 0.));\n    return col;\n}\n\nvec3 lightColor(in vec3 pos){\n    vec3 color = vec3(0.);\n    color.r += min(1.,3./length(pos-redO));\n    color.rb += min(1.,3./length(pos-magO));\n    color.b += min(1.,6./length(pos-bluO));\n    color.rg += min(1.,2./length(pos-yelO));\n    return color;\n}\n\nvec3 window(in float angl, in vec3 pos){\n    float dh = pos.y-wallO.y-.25*wallR;\n    float an = fract(3.*angl/PI)-.5;\n    return vec3(0.522,0.581,1.000)*(smoothstep(-.9,-.8,-abs(abs(dh)-1.))*( smoothstep(-.04,-.03,-abs(abs(an)-.04)))+.2*(1.-smoothstep(.0,.4,abs(an))));\n    \n}\n\nvec3 winLitcolor(vec3 pos){\n    float r = length(pos.xz-wallO.xz)*.01;\n    if (r<2.5){\n    \tfloat a= fract(3.*atan(pos.z- wallO.z,pos.x - wallO.x)/PI)-.5;\n    \treturn vec3(0.087,0.626,1.000)*.3*smoothstep(-2.,-.0,-r)*smoothstep(.1,.8,r)*smoothstep(-.5,-.0,-abs(a))*smoothstep(-60.,.0,-pos.y+wallO.y);\n    }\n    else return vec3(0.);\n}\n\nvec3 stars(in float a,in vec3 ray){\n    vec2 star = vec2(a,ray.y*.7)*30.;\n    vec2 p = floor(star);\n    if(rand2(p,0.)>.97){\n        vec2 f = fract(star)-.5;\n    \treturn  vec3(.7*smoothstep(0.,.3,abs(fract(iTime*.3+3.*a)-.5))*ray.y * (smoothstep(-.01,-.0,-abs(f.x*f.y))+max(0.,.1/length(f)-.2)));\n    }\n\telse return vec3(0.);\n}\n\nvec3 boreal(in float a,in vec3 ray){\n    vec3 col = vec3(0.);\n    float b = .03*(asin(clamp(6.*a+12.,-1.,1.))+PIdiv2);\n    float c = .2*(asin(clamp(-.2*a*abs(a)-1.67222,-1.,1.))+2.042);\n    float d = .05*(a+1.)*(asin(clamp(a-1.,-1.,1.))+PIdiv2);\n    float rebord = smoothstep(1.83333,1.9,-a);\n    float rebord2 = smoothstep(-2.,-1.9,-a);\n    float var1 = (sin(1./(a+2.2)+a*30. + iTime)+1.)/2.+.5;\n    float var2 = (sin(a*10. - iTime)+1.)/2.+.5;\n    float var3 = (sin(1./(a+.04)+a*10. + iTime)+1.)/2.+.5;\n    col += 2.5*vec3(0.292,ray.y,0.1)*var1*smoothstep(b,b+.5*ray.y,ray.y)*smoothstep(-b-.9*ray.y,-b,-ray.y)*rebord;\n    col += 1.*vec3(.6-ray.y,.5*ray.y,0.15)*var2*smoothstep(c,c+.07,ray.y)*smoothstep(-c-.5,-c,-ray.y)*rebord;\n    col += 2.5*vec3(0.292,ray.y,0.1)*var3*smoothstep(d,d+.5*ray.y,ray.y)*smoothstep(-d-.9*ray.y,-d,-ray.y)*rebord2;\n    col *= .5+.5*smoothstep(-1.,0.,-fract(ray.y+iTime*.1*rand1(floor(a*300.))))*smoothstep(-.7,0.,-abs(fract(a*300.)-.5));\n\treturn col;\n}\n\nvec3 skyColor(in vec3 ray){\n    float a = atan(ray.z,ray.x);\n    vec3 color = skyGlow(ray);\n    color += stars(a,ray);\n    color += boreal(a, ray);\n    return color;\n}\n\nvec3 groundColor(in vec3 pos, in vec3 ray, in vec3 norm){\n    float len = length(pos.xz);\n    float dir = max(0.,dot(-lightRay,norm));\n    vec3 color = snowColor(pos)*(.8*dir+.2);\n    color *= .5+.5*pos.y/maxHill;\n    ray = reflect(ray, norm);\n    ray.y = max(0.,ray.y);\n    color = mix(.9*skyGlow(ray),color,.7);\n    color *= 1.-atan(len/10000.)/PIdiv2;\n    color += vec3(.4*max(ray.x+.7,0.), .35,.4)*(ray.x+1.5)*.4*atan(len/20000.)/PIdiv2;\n    color += .8*lightColor(pos);\n    color += winLitcolor(pos);\n\treturn color;\n}\n\n//**********************************************************************************\n// cotta functions *****************************************************************\nvec3 roofColor(in vec3 p, in vec3 ray, in vec3 norm){\n    float an = atan((p.z - roofO.z),(p.x - roofO.x));\n    float lim = 6.*(.2*sin(6.*an)+1.1);\n    vec3 tile = (smoothstep(.0,.9, abs(fract(p.y)-.5))+smoothstep(0.,.7,abs(fract(20.*an+step(1., mod(p.y,2.0)) * 0.5)-.5)))*vec3(0.085,0.548,0.975);\n    vec3 color = step(-p.y+roofO.y,-lim)*tile + step(p.y-roofO.y,lim)*snowColor(p*5.);\n    color *= ((dot(lightRay,norm)+1.)*.2 + .2);\n    color += 1.5*vec3(0.029,0.560,0.975)*smoothstep(.5,1.,1.-dot(ray.xz,(roofO.xz-p.xz)/roofR));\n    color += vec3(0.029,0.560,0.975)*.7*smoothstep(-lim-4.,-lim,roofO.y-p.y)*step(-p.y+roofO.y,-lim);\n    color += vec3(0.102,0.147,0.975)*smoothstep(-3.,0.,-abs(roofO.y-p.y));\n    color += vec3(0.049,0.956,0.975)*.5*smoothstep(-1.,0.,-abs(roofO.y-p.y));\n    color += .8*lightColor(p);\n    return color;\n}\n\nvec3 wallColor(in vec3 p, in vec3 ray, in vec3 norm){\n    float angl = atan((p.z - wallO.z),(p.x - wallO.x));\n    float lim = 1.3*(sin(2.*angl)+1.5);\n    vec3 tile = 2.*(smoothstep(0.,.6,abs(fract(p.y*2.)-.5))+(1.-smoothstep(0.,.1,abs(fract(2.*angl+iTime*rand1(floor(p.y*2.)))-.5))))*vec3(0.037,0.518,0.975);\n    vec3 color = step(p.y,lim)*snowColor(p*5.)*vec3(0.048,0.691,0.990) + step(-p.y,-lim)*tile;\n    ray = reflect(ray, norm);\n    if(ray.y >0.) color = mix(color,skyGlow(ray),.3);\n    else color = mix(color,skyGlow(ray*vec3(1.,-1.,1.)),.3);\n    color *= ((dot(lightRay,norm)+1.)*.2 + .2);\n    color += window(angl, p);\n    color.b += .5*smoothstep(-lim,0.,-p.y);\n    color += .8*lightColor(p);\n    return color;\n}\n\nbool cottaImpact(in vec3 p, in vec3 ray, inout vec3 color){\n    bool impact = false;\n    float tr = coneImpact(p, roofO, roofH, roofR, ray);\n    float tw = sphereImpact(p, wallO, wallR, ray);\n    float t = min(tr,tw);\n    if(t<T){\n        T=t;\n        p += t*ray;\n        impact = true;\n        if(t == tr){\n            hitObj = ROOF; \n            vec3 norm = normalize(vec3(p.x - roofO.x,roofR*roofR/(roofH*roofH)*(roofH + roofO.y - p.y),p.z-roofO.z));\n            color += .7*roofColor(p, ray, norm);\n        }\n        else{\n            hitObj = WALL;\n            vec3 norm = normalize(p-wallO);\n            color += wallColor(p, ray, norm);\n        }\n    }\n    return impact;\n}\n\n//******************************************************************************************\n// Snowman functions ***********************************************************************\nfloat drawPattern(in vec3 p, in vec3 obj){\n    float a = 4.*atan(p.z-obj.z,p.x-obj.x);\n    vec2 i = floor(vec2(a,p.y));  \n    vec2 f = fract(vec2(a,p.y));  \n\tfloat tile = pattern(f, rand2(i, iTime*.04));\n    return 1.5*(smoothstep(-.1,.0,-abs(tile-.05)));\n}\n\nvec3 bellyColor(in vec3 p, in vec3 ray, in vec3 norm, in vec3 belly){\n    vec3 color = snowColor(norm*30.);\n    ray = reflect(ray, norm);\n    if(ray.y >0.) color = mix(color,skyGlow(ray),.3);\n    else color = mix(color,skyGlow(ray*vec3(1.,-1.,1.)),.3);\n    color *= ((dot(lightRay,norm)+1.)*.2 + .2);\n    color *= (1.-step(-.5,-abs(p.z-belly.z))*step(0.,p.x-belly.x)* step(.9, fract((p.y-belly.y)*.4)));\n    color += vec3(0.995,0.234,0.177)*drawPattern(p, belO);\n    color += lightColor(p);\n    color += vec3(0.990,0.395,0.006)*1.5*smoothstep(-3.,0.,-abs(belO.y-1.-p.y));\n    return color;\n}\n\nvec3 headColor(in vec3 p, in vec3 ray, in vec3 norm, in vec3 head){\n    vec3 color = snowColor(norm*30.);\n    color -= (1.-step(.3,length(head.yz+vec2(1.5,1.5)-p.yz)))*step(hedO.x,p.x);\n    color -= (1.-step(.3,length(head.yz+vec2(1.5,-1.5)-p.yz)))*step(hedO.x,p.x);\n    ray = reflect(ray, norm);\n    if(ray.y >0.) color = mix(color,skyGlow(ray),.3);\n    else color = mix(color,skyGlow(ray*vec3(1.,-1.,1.)),.3);\n    color *= ((dot(lightRay,norm)+1.)*.2 + .2);\n    color += vec3(0.995,0.234,0.177)*drawPattern(p, hedO)*step(-hedO.y+.4*exp(p.x-hedO.x-2.),-p.y);\n    color += lightColor(p);\n    return color;\n}\n\nvec3 hatColor(in vec3 p, in vec3 ray, in vec3 norm){\n    vec3 color = snowColor(p*5.);\n    color *= ((dot(lightRay,norm)+1.)*.2 + .2);\n    color += smoothstep(-.3,.0,-abs(fract(p.y*.4)-.5))*vec3(0.995,0.336,0.308);\n    color += lightColor(p);\n    return color;\n}\n\nvec3 nozColor(in vec3 p, in vec3 ray, in vec3 norm){\n    vec3 color = vec3(0.475,0.250,0.002);\n    color *= ((dot(vec3(0.,1.,0.),norm)+1.)*.4 + .2);\n    color += lightColor(p);\n    return color;\n}\n\nvec3 flowpatern(in float a, in float y){\n    vec3 color = vec3(0.);\n    float i = floor(a/PI*10.);\n    float f = fract(a/PI*10.);\n    float s = rand1(i*1.22543)+.2;\n    float proba = rand1(i*1.3377+floor(3.*iTime*s+y/30.));\n    float pattern = smoothstep(-.2,-.1,-abs(f-.5))*rand1(floor((iTime+y)));\n    if(bool(step(.95,proba))) color += vec3(0.990,0.729,0.430)*.9*pattern;\n    else if(bool(step(.8,proba))) color += vec3(0.139,0.990,0.990)*0.3*pattern;\n    return color;\n}\n\nbool caracterImpact(in vec3 pos, in vec3 ray,inout vec3 color){\n    bool impact = false;\n    vec3 p = pos;\n    float tbel = sphereImpact(p, belO, belR, ray);\n    float thed = sphereImpact(p, hedO, hedR, ray);\n    float that = coneImpact(p, hatO, hatH, hatR, ray);\n    float tnoz = coneImpact(vec3(-p.y,p.x,p.z), vec3(-nozO.y,nozO.x,nozO.z), nozH, nozR, vec3(-ray.y,ray.x,ray.z));\n    float t = min(min(min(tbel,thed),that),tnoz);\n    if(t<T){\n        T=t;\n        p += t*ray;\n        impact = true;\n        hitObj = SNOWMAN;\n        if(t == tbel){\n            vec3 norm = normalize(p - belO);\n            color += bellyColor(p, ray, norm, belO);\n        }\n        else if(t == thed){\n            vec3 norm = normalize(p - hedO);\n            color += headColor(p, ray, norm, hedO);\n        }\n        else if(t == that){\n            vec3 norm;\n            norm.xz = p.xz - hatO.xz;\n            norm.y = 0.;\n            norm = normalize(norm);\n            color += hatColor(p, ray, norm);\n        }\n        else{\n            vec3 norm;\n            norm.yz = p.yz - nozO.yz;\n            norm.x = 0.;\n            norm = normalize(norm);\n            color += nozColor(p, ray, norm);\n        }\n    }\n\n    return impact;\n}\n\n//**************************************************************************************\n// Tree functions **********************************************************************\n\nvec3 treeColor(in vec3 p, in vec3 ray, in vec3 norm){\n    float lim = 40.*(.05*sin(.6*p.x)+.5);\n    vec3 color = step(-p.y+treeO.y,-lim)*snowColor(fract(p*5.)) + step(p.y-treeO.y,lim)*vec3(0.019,0.966,0.975);\n    color *= ((dot(lightRay,norm)+1.)*.2 + .1);\n    color += .8*lightColor(p);\n    \n    float border = 1.-dot(ray.xz,(treeO.xz-p.xz)/treeR);\n\tcolor.b += smoothstep(.5,1.,border);\n    color += .3*smoothstep(.7,1.,border);\n    color += .3*smoothstep(-lim-4.,-lim,treeO.y-p.y)*step(-p.y+treeO.y,-lim);\n    color += vec3(0.019,0.966,0.975)*.7*smoothstep(-20.,0.,-abs(treeO.y-p.y));\n\tcolor *= 1.-atan(length(p)/10000.)/PI*2.;\n    return color;\n}\n\nbool getTree(in vec2 cell,inout vec3 treeO, inout float treeH, inout float treeR){\n    bool treeOk = bool(step(TREE_DENSITY,rand2(cell*1.331,1.))) && cell != cottaCell;\t\t\t// check if object depending cell coords\n        if (treeOk){ \n            treeH = (.7*rand2(cell*3.86,0.)+.3)*maxTreeH;\n            treeR = .15*treeH;\n            float lim = (1.-2.*treeR/cellD);\n            treeO = vec3(lim*(rand2(cell*2.23,0.) - 0.5) + cell.x, 0., lim*(rand2(cell*1.41,0.) -0.5)  + cell.y) *cellD;\n            treeO.y += ground(treeO.xz)-11.;\n        }\n    return treeOk;\n}\n\nbool treeImpact(in vec2 cell, in vec3 p, in vec3 ray, inout vec3 color){\n    bool impact = false;\n    bool tree = getTree(cell,treeO, treeH, treeR);\n    if(tree){\n        float t = coneImpact(p, treeO, treeH, treeR, ray);\n        if(t<T){\n            T=t;\n            hitObj = TREE;\n            impact = true;\n            p += t*ray;\n            vec3 norm = normalize(vec3(p.x - treeO.x,treeR*treeR/(treeH*treeH)*(treeH + treeO.y - p.y),p.z-treeO.z));\n            color += .5*treeColor(p, ray, norm);\n        }\n    }\n    return impact;\n}\n\n//***************************************************************************************************\n// fairy light functions ****************************************************************************\nvec3 fairyReflect(in vec3 ray,in vec3 norm){\n    vec3 r = reflect(ray,norm);\n    r.y = abs(r.y);\n    return skyGlow(r);\n}\n\n// thanks to Dave Hoskins...\n// https://www.shadertoy.com/view/MdlXz8\n// function used to render fairyligths surface and path\nfloat electric(in vec2 p){\n\tp = mod(p*TwoPI, TwoPI)-250.0;\n\tvec2 i = p;\n\tfloat c = 1.0;\n\tfloat inten = .005;\n\n\tfor (int n = 0; n < 5; n++) \n\t{\n\t\tfloat t = 2.*iTime * (1.0 - (3.5 / float(n+1)));\n\t\ti = p + vec2(cos(t - i.x) + sin(t + i.y), sin(t - i.y) + cos(t + i.x));\n\t\tc += 1./length(vec2(p.x / (sin(i.x+t)/inten),p.y / (cos(i.y+t)/inten)));\n\t}\n\tc /= 5.;\n\tc = 1.12-pow(c, 1.2);\n\treturn pow(abs(c), 8.0);\n}\n//...\n\n\n// set color and render of lights\nvec3 fairyLight(in vec3 ray,in vec3 pos,in int hitObj){\n    float cs;\n    vec3 norm;\n    vec3 refl;\n    vec3 col=vec3(0.);\n    if (hitObj == REDL){\n        vec3 v = pos - redO;\n    \tfloat a = atan(v.x,v.z);\n        col.r += electric(vec2(a/PI+.5, v.y/redR+.5));\n        norm = normalize(redO-pos);\n        col += .5*fairyReflect(ray,norm);\n\t\tcs = dot(ray,norm);\n        col.r += .2*smoothstep(-1.,0.,-cs);\n    }\n    else if (hitObj == MAGL){\n        vec3 v = pos - magO;\n    \tfloat a = atan(v.x,v.z);\n        col.rb += electric(vec2(a/PI+.5, v.y/magR+.5));\n        norm = normalize(magO-pos);\n        col += .5*fairyReflect(ray,norm);\n        cs = dot(ray,norm);\n        col.rb += .2*smoothstep(-1.,0.,-cs);\n    }\n    else if (hitObj == BLUL){\n        vec3 v = pos - bluO;\n    \tfloat a = atan(v.x,v.z);\n        col += vec3(0.,.3,1.)*electric(vec2(a/PI+.5, v.y/bluR+.5));\n        norm = normalize(bluO-pos);\n        col += .5*fairyReflect(ray,norm);\n        cs = dot(ray,norm);\n        col += vec3(0.,.3,1.)*.3*smoothstep(-1.,0.,-cs);\n    }\n\telse if (hitObj == YELL){\n        col.rg += .15;\n        norm = normalize(yelO-pos);\n        cs = dot(ray,norm);\n        col.rg += .3*smoothstep(-1.,0.,-cs);\n    }\n    return col;\n}\n\n// specific raytracing for the lights with transparency parameter\n// if trans = obj then this obj is ignored (transparent)\nfloat lightTrace(in vec3 pos, in vec3 ray,inout int hitLit, in int trans){\n    float t = INFINI, tp; \t\n    \n    if(trans != REDL){\n    \t\ttp = sphereImpact(pos, redO, redR, ray);\n    \t\tif(tp<t){\n            \tt = tp;\n            \thitLit = REDL;\n    \t\t}\n        }\n    if(trans != MAGL){\n    \t\ttp = sphereImpact(pos, magO, magR, ray);\n    \t\tif(tp<t){\n            \tt = tp;\n            \thitLit = MAGL;\n    \t\t}\n        }\n    if(trans != BLUL){\n    \t\ttp = sphereImpact(pos, bluO, bluR, ray);\n    \t\tif(tp<t){\n            \tt = tp;\n            \thitLit = BLUL;\n    \t\t}\n        }\n    if(trans != YELL){\n    \t\ttp = sphereImpact(pos, yelO, yelR, ray);\n    \t\tif(tp<t){\n            \tt = tp;\n            \thitLit = YELL;\n    \t\t}\n        }\n\n    return t;\n}\n\n//**************************************************************************************\n// Space is divided by a grid. Each element (or cell) of the grid may content one object\n// (for ex: tree) or nothing. Raytracing occur only in local cell if an object is present.\n// Allow lots of objects with only few raytraced object.\n// see demo: https://www.shadertoy.com/view/XdffRN\n\n// Key function to find the next cell of the grid\nvec2 getNextCell(in vec2 p, in vec2 v, in vec2 cell){\n    vec2 d = sign(v);\n\tvec2 dt = ((cell+d*.5)*cellD-p)/v;\n    d *= vec2( step(dt.x-0.02,dt.y) , step(dt.y-0.02,dt.x) );\t\t// -0.020 to avoid cell change for epsilon inside\n    return cell+d;\n}\n\n// call the involved ratrace funtion, depending of kind of object present in cell of the grid\nbool checkCell(in vec2 cell, in vec3 p, in vec3 ray, inout vec3 color){\n    bool impact = false;\n    if(cell == cottaCell) impact = cottaImpact(p, ray, color);   \n    else if(cell == snowmanCell) impact = caracterImpact(p, ray, color);\n    else impact = treeImpact(cell, p, ray, color);\n    return impact;\n}\n\n//**************************************************************************************\n// Fairy lights and camera trajectory management\n\n// to circle around an object\nvec3 circle(in float ti, in vec3 obj){\n    return vec3(80.*cos(ti*TwoPI) + obj.x, 0., 80.*sin(ti*TwoPI) + obj.z);\n}\n\n// kind of free flight\nvec3 freetrack(in float time){\n    return vec3(3000.*cos(time*.02), 0., 3200.*sin(time*.07));\n}\n\n// to smoothly change the trajectory to circle fligth to free flight (or reverse)\nvec3 transfer(in vec3 tr1, in vec3 tr2, in float dti, in float period){\n    float ang = dti*period*PI;\n    return tr1*(1.+cos(ang))/2. + tr2*(1.+cos(ang+PI))/2.;\n}\n\n// track of the lights\n// sometime circle around object, sometime free flight\nvec3 getTrac(in float time){\n    float ti = 27.*fract(time*.01);\n    vec3 track;\n    \n    if(ti<1.) track = circle(ti,wallO);\n    else if(ti<9.) track = transfer(circle(ti,wallO), freetrack(time), ti-1., .125); \t// .125 = 1/(9-1)\n    else if(ti<14.) track = freetrack(time);\n    else if(ti<22.) track = transfer(freetrack(time), circle(ti,hedO), ti-14.,.125);\t// .125 = 1/(22-14)\n    else if(ti<23.) track = circle(ti,hedO);\n    else track = transfer(circle(ti,hedO), circle(ti,wallO), ti-23.,.25);\n       \n    return track;\n}\n\n// track of the camera\n// not the same as fairylight to avoid to get sick when ligth are turning around objects\n// when lights circling, cam is fixed on the object\nvec3 getCam(in float time, in vec3 track){\n    float ti = 27.*fract(time*.01);\n    vec3 cam;\n    \n    if(ti<1.) cam = wallO;\n    else if(ti<5.) cam = transfer(wallO, track, ti-1., .25);\t// .25 = 1/(5-1)\n    else if(ti<18.) cam = track;\n    else if(ti<22.) cam = transfer(track, hedO, ti-18., .25);\n    else if(ti<23.) cam = hedO;\n    else cam = transfer(hedO, wallO, ti-23., .25);\t// .25 = 1/(27-23)\n    \n    return cam;\n}\n\n// local flight of fairylight aroud the main track\nvec3 flyR(in float time){return vec3(20.*sin(time*2.),5.*sin(time*3.),10.*cos(time*2.));}\nvec3 flyM(in float time){return vec3(10.*sin(1.+time*2.),4.*sin(1.6+time*3.),15.*cos(1.+time*2.));}\nvec3 flyB(in float time){return vec3(10.*sin(5.+time*3.),2.*sin(3.+time*2.),10.*cos(5.+time*3.));}\nvec3 flyY(in float time){return vec3(30.*sin(time*3.),abs(15.*sin(time*4.)+4.),20.*cos(time*3.));}\n\n// BACK IN TIME...\n// to generate the glowing path behind the fairiylights\n// without using buffer\nfloat glowTrack(in vec2 obj, in vec2 pos, in int lit){\n    float d = length(obj.xy-pos.xy);\t//current distance from obj at time now\n    \t\t\t\t\t\t\t\t\t// at the speed of the obj, this distance represent a certain amount of time\n    \t\t\t\t\t\t\t\t\t// objective: come back in time to check if position was on the obj path.\n    \n    // first : finding obj speed by derivation dp/dt\n    float past = iTime-.2; //dt\n    // what was the obj position a little time ago (dp)\n    vec2 delta = (getTrac(past)).xz;\n    if(lit == REDL) delta += flyR(past).xz;\n    else if(lit == MAGL) delta += flyM(past).xz;\n    else if(lit == BLUL) delta += flyB(past).xz;\n    \n    // obj speed : dp/dt (here dt = .2)\n    float v = length(obj.xy-delta.xy)/.2;\n    \n    // finding \"time\" to the object at obj speed\n    float backInTime = d/v;\n    float oldTime = iTime-backInTime;\n    \n    // finding obj. pos at this old time\n    vec2 oldTrac = (getTrac(oldTime)).xz;\n    if(lit == REDL) oldTrac += flyR(oldTime).xz;\n    else if(lit == MAGL) oldTrac += flyM(oldTime).xz;\n    else if(lit == BLUL) oldTrac += flyB(oldTime).xz;\n    \n    // finding distance from obj when at this old time\n    float l = length(oldTrac.xy-pos.xy);\n    // if pos was close to obj, then pos is on the track\n    // intensity of the color depends how long before it was... \n    float glow = 1.-step(10.,l);\n    if(bool(glow)) return (1.-smoothstep(2.,10.,l))*(1.-smoothstep(0.,2.,backInTime))*electric(pos.xy*.02);\n    else return 0.;\n}\n\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 st = fragCoord.xy/iResolution.xy-.5;\n    st.x *= iResolution.x/iResolution.y;\n        \n    // object def\n    \n    //cotta\n    wallO = vec3(400.,4.,-600.);\n    wallO.y += ground(wallO.xz);\n    wallR = 20.;\n    roofO = wallO+vec3(0.,8.,0.);\n    roofH = 42.;\n    roofR = 22.;\n    cottaCell = vec2(4.,-6.);   //floor(wallO.xz/cellD + .5);\n    \n    //SnowMan\n    belO = vec3(200.,4.,100.);\n    belR = 10.;\n    belO.y = ground(belO.xz);\n    hedO = belO+vec3(0.,13.,0.);\n    hedR = 5.;\n    hatO = belO+vec3(0.,16.,0.);\n    hatH = 15.;\n    hatR = 3.8;\n    nozO = belO+vec3(4.,13.,0.);\n    nozH = 4.;\n    nozR = .8;\n    snowmanCell = vec2(2.,1.);\t\t//floor(belO.xz/cellD + .5);\n    \n    //light\n    vec3 trac = getTrac(iTime);\n    trac.y += ground(trac.xz)+15.;\n    vec3 tracb = getTrac(iTime-.5);\n    tracb.y += ground(tracb.xz)+1.;\n    redO = trac + flyR(iTime);\n    redR = 3.;\n    magO = trac + flyM(iTime);\n    magR = 3.;\n    bluO = trac + flyB(iTime);\n    bluR = 3.;\n    yelO = tracb + flyY(iTime);\n    yelR = 1.;\n    \n    //vec3 camTarget = trac;\n    //vec3 camTarget = tracb;\n    //vec3 camTarget = wallO*(1.+sin(iTime*.2))/2. + trac*(1.+sin(iTime*.2+PI))/2.;\n    //vec3 camTarget = redO;\n    //vec3 camTarget = bluO;\n    //vec3 camTarget = yelO;\n    //vec3 camTarget = (trac+wallO)/2.;\n    //vec3 camTarget = wallO;\n    //vec3 camTarget = roofO;\n    //vec3 camTarget = hedO;\n    //vec3 camTarget = CtreeO+vec3(0.,50.,0.);\n    vec3 camTarget = getCam(iTime, trac);\n    \n    // camera def\n    float \tfocal = 1.;\n    float \trau = 300.*(sin(iTime/7.)+1.) + 50.,\n    \t\t//rau = 80.,\n    \t\talpha,\n    \t\ttheta;\t\n    // to start shader\n    if (iMouse.xy == vec2(0.)){\n        alpha = PIdiv2;\n        theta = .3;\n    }\n    else{\n        alpha = iMouse.x/iResolution.x*4.*PI/*-iTime/5.*/,\n    \ttheta = -iMouse.y/iResolution.y*PIdiv2+PIdiv2-.2;//(sin(iTime/7.)/2.+0.5)*(PI/2.-1.)+0.05;\n    }\n    \n    vec3 pos = rau*vec3(-cos(theta)*sin(alpha),sin(theta),cos(theta)*cos(alpha)) + camTarget;\n\tpos.y = max(ground(pos.xz)+15.,pos.y);\t\t//anti-collision\n    \n    vec3 ww = normalize( camTarget - pos );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0)) ) ;\n    vec3 vv = cross(uu,ww);\n\t// create view ray\n\tvec3 N_ray = normalize( st.x*uu + st.y*vv + focal*ww );\n    \n\tlightRay = vec3(1.,0.,0.);\t// global var\n\tvec3 GNDnorm = vec3(0.);\n    \n    vec3 color = vec3(.0);\n        \n    vec2 cell, outCell;\n    vec3 p = pos;\n    \n    // first step getting boundarry of interesting areas\n    // find exit cell\n\n    T = gndRayTrace(pos, N_ray);\n    if(T<INFINI){\n        hitObj = GND;\n        vec3 tp = pos+T*N_ray;\n        cell = floor(tp.xz/cellD + .5);\n        outCell = getNextCell(pos.xz,N_ray.xz,cell);\n    }\n    else if(pos.y<cellH){\n        T = sfcImpact(pos, N_ray, cellH);\n        if(T<INFINI){\t\t\t\t\t\t\t\t\t// hitObj = SKY already default value\n            vec3 tp = pos+T*N_ray;\n            cell = floor(tp.xz/cellD + .5);\n            outCell = getNextCell(pos.xz,N_ray.xz,cell);\n            T = INFINI;\t\t\t\t\t\t\t\t\t// T consistant with SKY\n        }\n    }\n    else outCell = floor(pos.xz/cellD + .5);\n\t\n    //if cam above ceiling, find entry cell\n    // ceiling is the upper most top of object\n    // no need the grid above ceiling - no objects possible\n    if(pos.y>=cellH){\n        float t = sfcImpact(pos, N_ray, cellH);\n        if(t<INFINI){\n            p = pos+t*N_ray;\n        }\n    }\n    \n    // MAIN PROCESS\n    // going thru the grid checking for existing object in each cell\n    // if obj: raytrace\n    // if impact: stop the ray\n    // else going again thru the grid\n    bool objImpact = false;\n    cell = floor(p.xz/cellD + .5);\n    for(int i=0; i<maxCell;i++){\n        if(cell == outCell) break;\n        objImpact = checkCell(cell, pos, N_ray, color);\n        if(objImpact) break;\n        cell = getNextCell(pos.xz,N_ray.xz,cell);\n    } \n    \n    // Final position reach by the ray\n    // if object in grid has been hit, color and rendering already (localy) done\n    // if no object, just check for ground hit or sky\n    vec3 finalPos = pos + T*N_ray;\n    \n    if(hitObj == SKY) color += skyColor(N_ray);\n    else if(hitObj == GND){\n        GNDnorm = getGndNormal(finalPos.xz,finalPos.y);\n        color += groundColor(finalPos, N_ray, GNDnorm);\n        float shad = 1.-atan(length(finalPos.xz - pos.xz)/20000.)/PI*1.5;\n        float cut = step(.8,shad);\n\t\t\n        // level lines\n        color.b += .5*smoothstep(-.2,0.,-abs(fract(finalPos.y/cellD*10.)-.5))*shad;\n        \n        // blue pulse line\n        float line = -abs((sin(finalPos.x*.004)+2.)*fract(finalPos.z*.002)-.5);\n        float pulse = fract(.0002*finalPos.x-iTime*.1+3.*sin(floor(finalPos.z*.002)));\n        color.gb += .3*smoothstep(-.01,0.,line)*shad;\n        color.gb += smoothstep(-.02,0.,line) *smoothstep(.98,1.,pulse)*shad;\n        \n    \tvec2 finalCell = floor(finalPos.xz/cellD + .5);\n        // cotta halo\n        if(finalCell == cottaCell)\n            color.b += .8*max(0.,3./(length(wallO.xz-finalPos.xz)-wallR+3.)-.1);\n        // trees halo\n        if(getTree(finalCell,treeO, treeH, treeR)){\n            float glow = max(0.,(1./(length(treeO.xz-finalPos.xz)-treeR+2.)-.1));\n            color += vec3(0.019,0.966,0.975)*glow*shad*cut;\n    \t\tcolor.r += 2.*glow*smoothstep(-.4,0.,line)*step(.8,pulse)*shad*cut;\n        }\n    \t// Snowman halo\n        if(finalCell == snowmanCell)\n            color += .8*vec3(0.990,0.395,0.006)*max(0.,3./(length(belO.xz-finalPos.xz)-belR+1.)-.1);\n    \n        \n        // glowing multi-track\n        // lag behind fairyligths\n        color.r += glowTrack(redO.xz, finalPos.xz, REDL);\n        color.rb += glowTrack(magO.xz, finalPos.xz, MAGL);\n        color.b += 2.*glowTrack(bluO.xz, finalPos.xz, BLUL);\n        \n    }\n    \n    // cylinder of data aroud snowman\n    // done in global matter instead of grid, because grid height is limited to celling (maxHeight)\n    vec2 tc = cylinderImpact(pos.xz, belO.xz, belR, N_ray.xz);\n\tif(tc.x < T){\n        vec3 cpos = pos + tc.x*N_ray;\n        color += vec3(0.990,0.395,0.006)*2./(cpos.y-belO.y+1.);\n        float a  = atan(cpos.z-belO.z, cpos.x-belO.x);\n        color += flowpatern(a, cpos.y);\n    }\n    if(tc.y < T){\n        vec3 cpos = pos + tc.y*N_ray;\n        float a  = atan(cpos.z-belO.z, cpos.x-belO.x);\n        color += .5*flowpatern(a, cpos.y);\n    }\n    \n        \n    // getting lights position (lights independant of cells)\n    int lightNbr;\n    float tlit;\n    tlit = lightTrace(pos,N_ray,lightNbr,0);\t\t// 0 means no transparency requested\n    \n    if(tlit<T){\n        hitObj = lightNbr;\n        vec3 trpos = pos + tlit*N_ray; \n        // adding fairy lights\n    \tcolor += 1.5*fairyLight(N_ray, trpos, hitObj);\n        tlit = lightTrace(pos,N_ray,lightNbr,hitObj);\t\t// hitObj means transparency requested for this obj\n        if(tlit<INFINI){\t\t\t\t\t\t\t\t\t// to make visible the fairy light behind\n            trpos = pos + tlit*N_ray;\n        \tcolor += fairyLight(N_ray, trpos, lightNbr);\n        }\n    }\n    \n    fragColor = vec4(color,1.0);\n}\n\n", "image_inputs": [{"id": "MsBXzK", "previewfilepath": "https://soundcloud.com/andrewgavrilets/01-carbon-based-lifeforms", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/andrewgavrilets/01-carbon-based-lifeforms", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsXBDX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsXBWf", "name": "Deformed fractal", "author": "lherm", "description": "Busting my shader chops", "tags": ["raymarch"], "likes": 5, "viewed": 893, "date": "1498414796", "time_retrieved": "2024-06-20T18:57:29.066897", "image_code": "#define eps .002\n#define far 40.\n#define time iTime\n#define PI 3.1415926\n\n#define fft texture(iChannel0, vec2(.25, 0.)).r\n\nmat2 r2(float a) {float c = cos(a), s = sin(a); return mat2(c, -s, s, c);}\n\nvoid distort(inout vec3 p)\n{\n    p += dot(p, p.yzx)*.01;\n    p += dot(p, p.zxy)*.01;\n    p += dot(p, p.xyx)*.01;\n    p += dot(p, p.yxy)*.01;\n    if (p.x<p.y){ p.xy = p.yx;}\n\tif (p.x<p.z){ p.xz = p.zx;}\n\tif (p.y<p.z){ p.yz = p.zy;}\n}\n\nfloat trap;\n\nfloat map(vec3 p)\n{\n    float d = 0.;\n    float s = 6. + fft;\n    for (int i = 0; i < 3; i++)\n    {\n        p = -abs(p) + .5;\n        p.xz *= r2(PI / 4. + time + fft);\n        p.yz *= r2(PI / 8. + time + fft);\n        distort(p);\n        d = max(-d, length(max(abs(p) -s, 0.)));\n        s *= .2;\n        trap = sin(dot(p, p/p));\n    }\n    return d;\n}\n\nfloat trace(vec3 ro, vec3 rd)\n{\n    float t = 0., m;\n    \n    for (int i = 0; i < 128; i++)\n    {\n        vec3 p = ro + rd * t;\n        m = map(p);\n        t += m;\n        if (m < eps || t > far) break;\n    }\n    return t;\n}\n\nvec3 calcNormal(vec3 p)\n{\n    vec2 e = vec2(eps, 0);\n    return normalize(vec3(\n        map(p+e.xyy)-map(p-e.xyy),\n        map(p+e.yxy)-map(p-e.yxy),\n        map(p+e.yyx)-map(p-e.yyx)\n        ));\n}\n\nvec3 doColor(vec3 ro, vec3 rd, vec3 p, vec3 n, vec3 lp, float t)\n{\n    vec3 col = vec3(0.),\n         objCol = vec3(trap, trap/dot(p,p), trap*trap)*5.,\n         ld = lp - p;\n    if (t < far)\n    {\n        float len = length(ld);\n        ld /= len;\n        float diff = max(dot(ld, n), 0.),\n              atten = (1./len*len),\n              amb = .25,\n              spec = pow(max(dot(reflect(-ld, n), -rd), 0.), 8.);\n        col = objCol * (((diff + amb*.2)+spec*.1)+atten*.1);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 f, in vec2 g )\n{\n\tvec2 R = iResolution.xy, u = (g+g-R)/R.y;\n    vec3 ro = vec3(0, 0, 1),\n         rd = normalize(vec3(u, -1)),\n         p = ro-ro,\n         col = p,\n         n = p,\n         lp = vec3(1, 3, 5);\n    float t = trace(ro, rd);\n    p = ro + rd * t;\n    n = calcNormal(p);\n    col = doColor(ro, rd, p, n, lp, t);\n    f = vec4(col, 1.);\n}", "image_inputs": [{"id": "XdXGRr", "previewfilepath": "/presets/mic.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/mic.png", "ctype": "mic"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsXBWf.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsXfDX", "name": "Honeycomb Voronoi", "author": "dr2", "description": "Voronoi (or Dirichlet) partitioning based on random points in the cells of a hexagonal (honeycomb) lattice", "tags": ["voronoi", "hexagon", "partition", "dirichlet"], "likes": 8, "viewed": 610, "date": "1498406195", "time_retrieved": "2024-06-20T18:57:29.891183", "image_code": "// \"Honeycomb Voronoi\" by dr2 - 2017\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\nVoronoi (or Dirichlet) partitioning based on random points in the cells of a hexagonal\n(honeycomb) lattice.\n\nOnly need to examine 7 neighbor points, rather than 9 on the square lattice. Errors due\nto omitting second-nearest neighbors are reduced (more on this in iq's Voronoi shaders\nand website tutorials). The underlying lattice is less noticeable, which is useful for\ngraphics applications.\n\nMultiple visualization modes.\n*/\n\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec3 HsvToRgb (vec3 c);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\n\nvec2 gVec[7], hVec[7];\nfloat tCur;\nconst float pi = 3.14159;\n\n#define SQRT3 1.7320508\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./SQRT3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (SQRT3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat HexEdgeDist (vec2 p)\n{\n  p = abs (p);\n  return (SQRT3/2.) - p.x + 0.5 * min (p.x - SQRT3 * p.y, 0.);\n}\n\nvoid HexVorInit ()\n{\n  vec3 e = vec3 (1., 0., -1.);\n  gVec[0] = e.yy;\n  gVec[1] = e.xy;\n  gVec[2] = e.yx;\n  gVec[3] = e.xz;\n  gVec[4] = e.zy;\n  gVec[5] = e.yz;\n  gVec[6] = e.zx;\n  for (int k = 0; k < 7; k ++) hVec[k] = HexToPix (gVec[k]);\n}\n\nvec4 HexVor (vec2 p)\n{\n  vec4 udm;\n  vec3 sd;\n  vec2 ip, fp, d, u;\n  float amp, a;\n  bool nNew;\n  amp = 0.7;\n  ip = PixToHex (p);\n  fp = p - HexToPix (ip);\n  sd = vec3 (4.);\n  udm = vec4 (0.);\n  for (int k = 0; k < 7; k ++) {\n    u = Hashv2v2 (ip + gVec[k]);\n    a = 2. * pi * (u.y - 0.5) * tCur;\n    d = hVec[k] + amp * (0.4 + 0.6 * u.x) * vec2 (cos (a), sin (a)) - fp;\n    sd.z = dot (d, d);\n    nNew = (sd.z < sd.x);\n    udm = nNew ? vec4 (d, u) : udm;\n    sd = nNew ? sd.zxz : ((sd.z < sd.y) ? sd.xzz : sd);\n  }\n  sd.xy = sqrt (sd.xy);\n  return vec4 (sd.y - sd.x, udm.xy, Hashfv2 (udm.zw));\n}\n\nvec3 ShowScene (vec2 p)\n{\n  vec4 vc;\n  vec3 col;\n  vec2 dp;\n  float dm, s, tCyc;\n  HexVorInit ();\n  col = vec3 (0.);\n  tCyc = mod (0.02 * tCur, 1.);\n  vc = HexVor (p);\n  col = mix (vec3 (0.5, 1., 0.5), HsvToRgb (vec3 (mod (vc.w, 1.), 0.7, 1.)),\n     SmoothBump (0.2, 0.7, 0.02, mod (tCyc, 1.)));\n  dm = length (vc.yz);\n  col *= (1. - min (0.8 * dm, 1.)) * mix (1., 0.7 + 0.3 * sin (40. * vc.x),\n     SmoothBump (0.2, 0.7, 0.02, mod (2. * tCyc, 1.)));\n  s = SmoothBump (0.2, 0.7, 0.02, mod (4. * tCyc, 1.));\n  col = mix (vec3 (1., 0.5, 0.), col,\n     min (min (s + smoothstep (0.03, 0.04, vc.x), 1.),\n     min (s + smoothstep (0.05, 0.1, dm), 1.)));\n  s = SmoothBump (0.1, 0.9, 0.01, mod (8. * tCyc, 1.));\n  dp = p - HexToPix (PixToHex (p));\n  col = mix (vec3 (0.3, 0.3, 0.7), col,\n     min (min (s + smoothstep (0.02, 0.03, HexEdgeDist (dp)), 1.),\n     min (s + smoothstep (0.04, 0.06, length (dp)), 1.)));\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  vec3 col;\n  vec2 canvas, uv, p;\n  float pSize;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  tCur += 20.;\n  pSize = canvas.x / 100.;\n  p = pSize * uv;\n  fragColor = vec4 (ShowScene (p), 1.);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nconst vec3 cHashA3 = vec3 (1., 57., 113.);\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, cHashA3.xy)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  const vec2 cHashVA2 = vec2 (37.1, 61.7);\n  const vec2 e = vec2 (1., 0.);\n  return fract (sin (vec2 (dot (p + e.yy, cHashVA2),\n     dot (p + e.xy, cHashVA2))) * cHashM);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsXfDX.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
{"id": "XsXfWs", "name": "My first shader_Cardioid", "author": "linhow", "description": "The line of heart is a fixed point on a circle that is formed around a circle that is tangent to it and has the same radius as its circumference, because its shape is named after the heart.", "tags": ["2d", "cardioid"], "likes": 2, "viewed": 118, "date": "1498704502", "time_retrieved": "2024-06-20T18:57:29.897072", "image_code": "//2017/6/29 10:38 I Graduated\n#define PI 3.1415926f\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 xy = fragCoord.xy - iResolution.xy*0.5;\n    //static circle\n    if(abs(length(xy)-iResolution.y*0.1666)<2.)\n        fragColor = vec4(0.5*sin(iTime+PI*0.5),0.,0.5,1.);\n    vec2 move= iResolution.y*0.3333*vec2(sin(mod(iTime,36.0)/18.*PI),cos(mod(iTime,36.0)/18.*PI));\n    if(abs(length(xy-move)-iResolution.y*0.1666)<2.)\n        fragColor = vec4(0.5*sin(iTime+PI*0.5),0.,0.5,1.);\n    //move circle\n    float i,time=iTime;\n    vec2 move2,move3;\n    //Cardioid\n    for(i=0.;i<mod(time,36.);i+=0.1)\n    {\n    move = iResolution.y*0.3333*vec2(sin(mod(i,36.0)/18.*PI),cos(mod(i,36.0)/18.*PI));\n    move2= iResolution.y*0.1666*vec2(sin(PI+2.*mod(1.*i,36.0)/18.*PI),cos(PI+2.*mod(1.*i,36.0)/18.*PI));\n    move3= move2+move;\n    if(length(xy-move3)<3.)  fragColor =vec4(1.,0.,0.,0.);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "CC-BY-NC-SA-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XsXfWs.jpg", "access": "shaders20k", "wgpu-test": "not-tested"}
