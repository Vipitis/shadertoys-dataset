{"id": "4ddSD7", "name": "Voxel Marcher", "author": "rodolphito", "description": "based on https://www.shadertoy.com/view/4dX3zl", "tags": ["voxel"], "likes": 3, "viewed": 142, "published": "Public", "date": "1533185566", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAX_RAY_STEPS = 64;\n\nfloat sdSphere(vec3 p, float d)\n{\n    return length(p) - d;\n} \n\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nbool getVoxel(vec3 c)\n{\n    vec3 p = vec3(c) + vec3(0.5);\n    float d = min(max(-sdSphere(p, 7.5), sdBox(p, vec3(6.0))), -sdSphere(p, 25.0));\n    return d < 0.0;\n}\n\nvec2 rotate2d(vec2 v, float a)\n{\n    float sinA = sin(a);\n    float cosA = cos(a);\n    return vec2(v.x * cosA - v.y * sinA, v.y * cosA + v.x * sinA);\t\n}\n\nvoid mainImage(out vec4 fragColor,vec2 fragCoord)\n{\n    fragCoord += 0.5;\n    vec2 screenPos = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    vec3 cameraDir = vec3(0.0, 0.0, 0.8);\n    vec3 cameraPlaneU = vec3(1.0, 0.0, 0.0);\n    vec3 cameraPlaneV = vec3(0.0, 1.0, 0.0) * iResolution.y / iResolution.x;\n    vec3 rayDir = cameraDir + screenPos.x * cameraPlaneU + screenPos.y * cameraPlaneV;\n    vec3 rayPos = vec3(0.0, 2.0 * sin(iTime * 2.7), -12.0);\n\n    rayPos.xz = rotate2d(rayPos.xz, iTime);\n    rayDir.xz = rotate2d(rayDir.xz, iTime);\n    rayDir = normalize(rayDir);\n\n    vec3 rayStep = sign(rayDir);\n    vec3 invDir = 1.0 / rayDir;\n    vec3 voxel = floor(rayPos);\n    vec3 sideDist = (max(rayStep,0.0) - fract(rayPos)) * invDir;\n    vec3 normal = vec3(0.0);\n    float thing = 0.0;\n    for (int i = 0; i < MAX_RAY_STEPS; i++)\n    {\n        normal = step(sideDist,min(sideDist.yzx,sideDist.zxy)) * rayStep;\n        sideDist += normal * invDir;\n        voxel += normal;\n        thing += dot(sideDist*rayStep-invDir,normal);\n        if (getVoxel(voxel)) break;\n    }\n    //fragColor.rgb = vec3(thing*0.001);//vec3(0.5+dot(normal, 0.5*normalize(vec3(0.4,0.2,0.7))));\n    fragColor.rgb = vec3(mod(voxel,vec3(2.0)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ddSD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 31, 64, 64, 92], [95, 95, 124, 124, 215], [217, 217, 240, 240, 380], [382, 382, 414, 414, 534], [536, 536, 587, 587, 1753]], "test": "ok"}
{"id": "4l3cWS", "name": "[twitch] Trench Run", "author": "yx", "description": "Coded live on twitch stream in Bonzomatic, and ported to shadertoy.\nUnedited Bonzomatic shader here: [url]https://gist.github.com/willkirkby/6f3ef0770acf4d2a4962cc16fd508aff[/url]", "tags": ["starwars"], "likes": 10, "viewed": 858, "published": "Public API", "date": "1533762082", "time_retrieved": "2021-10-01T00:00:00", "image_code": "uniform float fGlobalTime; // in seconds\nuniform vec2 v2Resolution; // viewport resolution (in pixels)\n\n#define pi acos(-1.)\n\nfloat noise(vec2 p)\n{\n  return fract(sin(dot(p, vec2(12.43243, 4.58479)))*1234.4556);\n}\n\nfloat scene(vec3 p)\n{\n  p.x = abs(p.x);\n  return min(\n    1.+p.y,\n    1.-p.x\n  ) + texture(iChannel0, p.xz*.25+p.yz*.25).r*.4;\n}\n\nvec2 rotate(vec2 a, float b)\n{\n  float c = cos(b);\n  float s = sin(b);\n  return vec2(\n    a.x * c - a.y * s,\n    a.x * s + a.y * c\n  );\n}\n\nvec4 laser(vec4 color, vec2 uv)\n{\n  uv -= .5;\n  float w = clamp(pow(.1/length(uv),3.),0.,30.);\n  return color* w*.2;\n}\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord)\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n    vec3 cam = vec3(0,0,iTime*8.);\n    vec3 dir = normalize(vec3(uv, 1));\n\n  cam.x = sin(iTime)*.3;\n  dir.xy = rotate(dir.xy, sin(iTime)*.1);\n\n  float t = 0.;\n  for(int i = 0; i < 64;++i)\n  {\n    t += scene(cam + dir * t)*.5;\n  }\n  vec3 h = cam + dir*t;\n\n  vec2 o = vec2(.001, 0);\n  vec3 n = normalize(vec3(\n    scene(h+o.xyy)-scene(h-o.xyy),\n    scene(h+o.yxy)-scene(h-o.yxy),\n    scene(h+o.yyx)-scene(h-o.yyx)\n  ));\n\n  //n = normalize(cross(dFdy(h), dFdx(h)));\n\n  out_color.rgb = fract(h*1.);\n  out_color.rgb = n*.5+.5;\n\n  out_color = vec4(max(0.,dot(n, vec3(.2,1,.1)))*.4+.05);\n\n  out_color /= t*.3;\n\n  {\n    vec4 red = vec4(1,.1,.1,1);\n    vec4 green = vec4(.1,1,.1,1);\n    vec2 luv = vec2(\n      .3/length(dir.xy),\n      atan(dir.x, dir.y)/pi*.5\n    );\n    out_color += laser(red, fract(luv*vec2(.01,1)+vec2(-iTime*3.,-.1)));\n    out_color += laser(green, fract(luv*vec2(.01,1)+vec2(iTime*3.+.5,.1)));\n  }\n\n  if (h.y > abs(h.x))\n  {\n    out_color = vec4(step(.995,noise(fragCoord.xy)));\n  }\n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l3cWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[126, 126, 147, 147, 213], [215, 215, 236, 236, 343], [345, 345, 375, 375, 482], [484, 484, 517, 517, 602], [604, 604, 656, 656, 1792]], "test": "error"}
{"id": "4l3yDX", "name": "Twisting up", "author": "Peetu", "description": "My first raymarching shader.", "tags": ["raymarching"], "likes": 3, "viewed": 66, "published": "Public", "date": "1534337281", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float EPSILON = 0.0001;\nconst float end = 100.0;\nconst float start = 0.01;\nconst float PI = 3.141592;\n\nvec3 bg(vec2 p) {\n\tvec3 col = vec3(p.y * 0.2, p.y * 0.2,p.y * 0.2);\n   \t\n    if(int(floor(p.y * 5.0 + iTime * .2)) % 2 == 0) {\n    \tcol += vec3(0.0, 0.05, 0.05);   \n    }\n    \n    return col;\n}\n\nmat3 rotationMatrix(float rad) {\n    return mat3(\n        vec3(cos(rad), 0.0, sin(rad)),\n        vec3(0.0, 1.0, 0.0),\n        vec3(-sin(rad), 0.0, cos(rad))\n    );\n}\n\nfloat helixSDF(vec3 p, float i) {\n    \n    mat3 rot = rotationMatrix(mod(iTime, 2.*PI) + i);\n    vec3 dir = rot * vec3(1.0, 0.0, 0.0);\n    \n    float r = 0.1;\n    float h = 1.2 + 0.2 * iTime;\n    float lh  = abs(p.y) - h;\n    \n    p.x += cos(p.y * 15.) * 0.1 * dir.x;\n    p.z += cos(p.y * 15.) * 0.1 * dir.z;\n    float lr = length(p.xz) - r;    \n    return lr;\n}\n\nfloat sceneSDF(vec3 p) {\n    return min(helixSDF(p,sin(iTime) * .5), min(helixSDF(p - vec3(0.5, 0., 5.), 3.), helixSDF(p - vec3(0.6, 0., 0.5), cos(iTime) *.6)));\n}\n\nfloat rayMarch(vec3 eye, vec3 rayDir) {\n    float depth = start;\n    for(int i = 0; i < 64; i++) {\n   \t\tfloat dist = sceneSDF(eye + rayDir * depth);\n        \n        if(dist < EPSILON){\n \t      \treturn depth;   \n        }else if(depth >= end) {\n        \treturn end;   \n        }\n        \n        depth += dist * 0.9;\n    }\n    return end;\n}\n\nvec3 estimateNormal(vec3 p) {\n    float E = 0.1;\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + E, p.y, p.z)) - sceneSDF(vec3(p.x - E, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + E, p.z)) - sceneSDF(vec3(p.x, p.y - E, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z + E)) - sceneSDF(vec3(p.x, p.y, p.z - E))\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    \n    vec3 eye = vec3(0.0, (iTime + 5.) * 0.2, -8.0);\n    vec3 rayDir = vec3(-.05+uv.x*.1, -.05+uv.y*.1, 1.0);\n    \n    float depth = rayMarch(eye, rayDir);\n    \n    vec3 col;\n   \n   \tif(depth >= end - EPSILON) {\n    \tcol = bg(uv);\n    }else{\n        vec3 normal = estimateNormal(eye + depth * rayDir);\n        vec3 light = vec3(-1.0, -.4, .5);\n        float diffuse = clamp(dot(normal, -light), 0.0, 1.0) * .4;\n        float i = 0.3 + diffuse;\n        col = vec3(i*0.8,0.0,i*0.8);\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l3yDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[109, 109, 126, 126, 302], [304, 304, 336, 336, 469], [471, 471, 504, 504, 833], [835, 835, 859, 859, 998], [1000, 1000, 1039, 1039, 1340], [1342, 1342, 1371, 1371, 1663], [1665, 1665, 1722, 1772, 2340]], "test": "timeout"}
{"id": "4l3yR2", "name": "WyrdWave", "author": "mildanach", "description": "cosine wave wrapped in polar coords, with gradually growing number of peaks", "tags": ["waves", "hypnotic", "polar"], "likes": 2, "viewed": 90, "published": "Public", "date": "1533130184", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float PEAKS = 3.0;\n    float BAND = 2.0 + sin(0.5 * iTime);\n    \n\tfloat mx = max(iResolution.x, iResolution.y);\n    vec2 uv = fragCoord / mx;\n    vec2 center = iResolution.xy / mx * 0.5;\n    vec2 p = uv - center;\n    \n    float ang = atan(p.y, p.x);\n    float d = distance(uv, center);\n    float band0 = floor(d * BAND);\n    float band1 = 1.0 + band0;\n    float band2 = 1.0 + band1;\n    \n    float wav1 = cos(ang * PEAKS * band1 * band1);\n    float wav2 = cos(ang * PEAKS * band2 * band2);\n    float wavT = (d - band0 / BAND) * BAND;\n    float wav = 0.1 * mix(wav1, wav2, clamp(wavT, 0.0, 1.0));\n    \n    float r = sin(-iTime + 100.0 * d * (1.0 + wav));\n    float g = -r;\n    float b = cos(iTime * 3.0 + 100.0 * d);\n\n    fragColor = vec4(r, g, b, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l3yR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 814]], "test": "ok"}
{"id": "4lcyD7", "name": "Small Solar System", "author": "TylerWalters", "description": "Continued learning at home!", "tags": ["solarsystemorbitearthsunplanetplanets"], "likes": 4, "viewed": 202, "published": "Public", "date": "1533229593", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Tyler Walters - Technical Artist - 2018\n\n\n\nconst vec3 bg_color = vec3(0.1);\nconst vec3 sun_color = vec3(1.0,0.825,0.6);\nconst vec3 earth_color = vec3(0.1,0.3,0.4);\nconst vec3 moon_color = vec3(0.3,0.3,0.3);\n    \n\n\n\t\n//Circle function with smooth stepped aa\nfloat circle (in vec2 pos, in vec2 rad, in float smth_min, in float smth_max)\n    {\n        float dis = distance(pos, rad);\n        float circ = smoothstep(smth_min,smth_max,dis);\n        \n        return circ;    \n    }\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    \n    // UV coordinate offsets for earth and moon\n    vec2 uv_rota = (uv * 3.0) + vec2(1.3 * sin(iTime / 3.0), cos(iTime / 3.0));\n    vec2 uv_rotb = (uv_rota * 4.0) + vec2(sin(iTime * 2.0), cos(iTime * 2.0));\n    \n    // Sun\n    float sun = circle(uv * 2.0 , vec2(0.0), float(0.25), float(0.255));\n    float sun_ripple = abs(sin(circle(uv * 2.0 , vec2(0.0), float(0.0), float(1.0)) * 25.0 - (iTime * 0.5)));\n    float sun_glow = circle(uv * 2.0 , vec2(0.0), float(0.2), float(0.4)); \n    sun = (((max(sun_glow, sun_ripple) / 2.0 + 0.5) * sun_glow) * sun);\n\n    // Earth    \n    float earth = circle(uv_rota, vec2(0.0), float(0.1), float(0.11));\n    float earth_grad = mix(dot(uv_rota, vec2(sin(iTime / 3.0), cos(iTime / 3.0))) + 0.2, 0.0, earth);\n\n    // Moon\n    float moon = circle(uv_rotb, vec2(0.0), float(0.1), float(0.12));\n\tfloat moon_grad = mix(dot(uv_rota, vec2(sin(iTime / 3.0), cos(iTime / 3.0))) + 0.15, 0.0, moon) / 2.0;\n    \n    // Black and white mask of all elements\n    float bg_mask = sun * earth * moon;\n    \n   \n    // Color & shading of each individual element\n    vec3 sun_lit = mix(sun_color, vec3(0.0), sun);\n    vec3 earth_lit = mix(earth_color + ((earth_grad * sun_color) * 2.0), vec3(0.0), earth);\n    vec3 moon_lit = mix(moon_color + ((moon_grad * sun_color) * 2.0), vec3(0.0), moon);\n    \n   \n    // Cheap combination of all shaded elements\n\tvec3 col = sun_lit + earth_lit + moon_lit;\n\n\n    // Output to screen\n    fragColor = vec4(vec3(mix(col, bg_color, bg_mask)) * 1.15,0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lcyD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[219, 260, 343, 343, 479], [484, 484, 541, 591, 2175]], "test": "ok"}
{"id": "4ldcRf", "name": "flipflop", "author": "lennyjpg", "description": "gsdfgsdfgfsd", "tags": ["sdfgsdf"], "likes": 4, "viewed": 393, "published": "Public API", "date": "1533492678", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x;\n\tvec2 u=fract(uv*12.0);\n    float t = iTime*0.81;\n    u-=0.5;\n    vec2 m = uv-0.5-mod(u.x*0.1,20.5)*.01 ;\n    float a = atan(m.y,m.x);\n    a = sin(uv.x*7.0)+cos(uv.y*7.0);\n    u = rotate2d( a+t*PI ) * u;\n    u+=0.5;\n    float k = smoothstep(0.,-18./iResolution.x, u.x-.5);\n    fragColor = vec4(k);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ldcRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 54, 54, 140], [142, 142, 199, 199, 538]], "test": "ok"}
{"id": "4ldcWj", "name": "madness falls", "author": "valyagolev", "description": "nothing", "tags": ["nothing"], "likes": 1, "viewed": 44, "published": "Public", "date": "1534113639", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec4 wave(vec4 def, vec2 xy) {\n    float start = def.x;\n    float height = def.y + start / 25.0 * sin(iTime) + xy.y / 20.0 - 20.0;\n    float width = def.z;\n \tfloat offset = 10.0 * sin(float(iTime) / start); \n    \n    float t = (\n        start + height/2.0\n        + sin(width * (xy.x * (1.0 - xy.y/3.0/iResolution.y) + xy.y/2.0) / 100.0  + offset)\n        \t* height / 2.0\n        - xy.y);\n    \n    if (t > -20.0) {\n        return vec4(0.3, 0.3, 0.6 + 0.29 * (t / -15.0), 1.0);\n    } else {\n        return vec4(0.0, 0.0, 0.0, 0.0);\n    }\n}\n\nvec4 mixWithWave(vec4 cur, vec4 def, vec2 xy) {\n\tvec4 r = wave(def, xy);\n    if (r.a == 1.0) return r;\n    else return cur;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    \n    // Normalized pixel coordinates (from 0 to 1)\n//    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n  //  vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    vec4 col = vec4(0.0);\n    vec2 xy = fragCoord;\n    col = mixWithWave(col, vec4(220.0, 25.0, 2.1, 0.0), xy);\n    col = mixWithWave(col, vec4(145.0, 35.0, 2.4, 0.0), xy);\n    col = mixWithWave(col, vec4(70.0, 40.0, 2.7, 0.0), xy);\n    col = mixWithWave(col, vec4(10.0, 45.0, 3.0, 0.0), xy);\n    //col = mixWithWave(col, vec4(1.2, vec3(0.8)), xy);\n    \n    \n    // Output to screen\n    fragColor = vec4(col);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ldcWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 31, 31, 539], [541, 541, 588, 588, 666], [668, 668, 725, 918, 1331]], "test": "ok"}
{"id": "4ldyD2", "name": "Noise In Progress", "author": "IAmSparticle", "description": "The first steps in a Perlin-like gradient noise function.", "tags": ["noise", "perlin", "gradient", "wip"], "likes": 2, "viewed": 419, "published": "Public API", "date": "1534200148", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nThis shader is a work in progress.\n\nAt the risk of oversimplificatin, Perlin noise is generated by selecting pseudo-random\ngraditent vectors at the integer units of an n-dimensional grid, projecting points onto \nthose gradients, then interpolating the resulting heights acording to the distance from\neach of units bounding the points. This shader is obviouly not Perlin-noise. This \nshader implements pseudo-random gradient generation in a 4d space and scales those 4d \ngradients to the 4d color space for debuging.\n\nPerlin's hashing of inputs generated axial artifacts. He create simplex noise to address\nthis.  In \"Better Gradient Noise\" (https://www.cs.utah.edu/~aek/research/noise.pdf), \nKensler et al. propose sevral improvements to Perlin noise.  Relivent to this shader,\nthey sugest using unique permutation tables for each axis and xor-ing the results of\neach to index the gradient-vector table. \n\nThis shader implements multiple perterbation tables directly, however, a simple xor of \nthe resulting coordinates generated repitition artifacts modulo the perturbaton tables \nsizes.  To resovle this, the result of the the x perturbation was xored with the y \ncoordinate to index the y perturbation. This was repeated for the remaining two \ndimensions. While this significantly reduced the artifacts, some artifacts remained \nalong the x axis. Xoring the value back with the noise-space x coordinated to index a\nsecond lookup of the x perturbation tables elimanted these visual artifacts.\n\nThis shader is for my reference while I create a new shader which fully implements a \nPerlin-like gradient noise function. \n*/ \n\n/* These arrays are used to perturb indexing of the gradient vector array. These number\nare not magic. They where generated with four sucessive invocations of the python \none-liner `random.sample([x for x in range(257)], 257);` Though I have not tested it,\nany set of sequences generated in this way should perturb the gradient vector array\njust fine (albeit in a different order). */\nconst int[257] x_perts = int[](122, 157, 41, 75, 247, 215, 201, 106, 179, 67, 109, 2, 44, 144, 43, 99, 51, 5, 66, 223, 30, 112, 206, 183, 213, 37, 3, 0, 103, 12, 93, 143, 13, 127, 162, 136, 164, 166, 124, 107, 239, 72, 108, 211, 246, 161, 52, 90, 11, 220, 14, 203, 168, 95, 236, 214, 155, 196, 151, 251, 202, 219, 61, 59, 248, 76, 22, 45, 199, 154, 121, 46, 125, 28, 83, 186, 149, 181, 111, 232, 15, 158, 24, 191, 194, 229, 18, 172, 254, 178, 185, 192, 69, 80, 4, 7, 235, 131, 101, 226, 234, 189, 63, 105, 88, 49, 160, 163, 134, 175, 176, 47, 139, 198, 225, 74, 256, 152, 16, 231, 118, 23, 133, 253, 42, 249, 187, 27, 255, 55, 71, 34, 218, 78, 212, 98, 100, 86, 228, 242, 224, 33, 77, 10, 171, 200, 148, 227, 216, 184, 8, 240, 21, 1, 54, 145, 92, 25, 233, 89, 53, 205, 209, 82, 244, 195, 204, 20, 237, 147, 128, 197, 156, 62, 116, 142, 190, 126, 68, 170, 110, 29, 48, 26, 150, 73, 245, 174, 114, 252, 250, 217, 40, 79, 207, 39, 60, 56, 102, 135, 19, 222, 38, 241, 6, 238, 81, 58, 31, 57, 36, 87, 120, 119, 141, 104, 84, 132, 91, 230, 94, 146, 208, 113, 138, 9, 173, 177, 65, 243, 137, 167, 193, 123, 140, 210, 188, 70, 32, 85, 96, 97, 50, 117, 35, 182, 17, 169, 221, 129, 180, 64, 153, 159, 165, 130, 115);\nconst int[257] y_perts = int[](189, 201, 143, 210, 90, 55, 20, 27, 221, 47, 249, 17, 29, 45, 255, 56, 121, 142, 175, 26, 248, 76, 40, 188, 180, 44, 0, 112, 137, 48, 132, 70, 151, 200, 209, 53, 231, 184, 149, 176, 28, 163, 199, 130, 219, 164, 15, 65, 233, 106, 58, 25, 168, 171, 98, 187, 136, 32, 134, 198, 115, 227, 256, 124, 206, 146, 127, 216, 197, 238, 111, 242, 105, 12, 95, 86, 57, 14, 237, 85, 99, 46, 247, 33, 154, 36, 232, 69, 156, 225, 214, 13, 170, 211, 172, 125, 60, 23, 24, 109, 212, 250, 117, 244, 126, 9, 166, 77, 139, 190, 162, 224, 243, 167, 169, 152, 10, 246, 203, 92, 21, 183, 71, 122, 220, 67, 93, 174, 64, 150, 196, 110, 75, 38, 208, 192, 107, 217, 49, 252, 41, 80, 230, 193, 68, 155, 87, 114, 178, 118, 31, 207, 228, 141, 148, 52, 218, 179, 4, 215, 2, 135, 82, 78, 97, 194, 103, 138, 72, 202, 182, 66, 160, 88, 96, 205, 61, 63, 222, 94, 11, 226, 147, 241, 50, 59, 83, 173, 119, 100, 120, 245, 34, 89, 144, 42, 251, 108, 254, 185, 123, 181, 54, 6, 102, 73, 223, 145, 19, 8, 39, 81, 239, 234, 5, 186, 91, 240, 128, 43, 161, 253, 157, 84, 235, 229, 213, 204, 113, 18, 140, 177, 236, 16, 129, 195, 3, 153, 35, 116, 165, 158, 101, 104, 131, 191, 22, 79, 62, 37, 7, 1, 133, 51, 74, 30, 159);\nconst int[257] z_perts = int[](75, 58, 198, 164, 90, 182, 121, 179, 103, 217, 31, 162, 17, 24, 147, 120, 256, 244, 72, 5, 216, 209, 22, 66, 205, 155, 215, 232, 186, 20, 239, 84, 153, 144, 150, 32, 14, 255, 109, 27, 3, 28, 180, 35, 195, 19, 193, 2, 137, 38, 126, 160, 9, 41, 174, 88, 86, 134, 188, 60, 106, 81, 132, 203, 49, 79, 208, 65, 251, 56, 13, 44, 40, 191, 25, 12, 93, 149, 243, 141, 11, 226, 69, 6, 168, 99, 236, 183, 228, 37, 71, 52, 192, 223, 10, 204, 129, 48, 151, 29, 197, 202, 116, 53, 187, 246, 4, 219, 213, 172, 30, 117, 220, 231, 89, 77, 196, 227, 125, 158, 206, 234, 128, 165, 201, 229, 124, 51, 235, 67, 114, 250, 222, 42, 159, 189, 127, 225, 136, 26, 85, 154, 110, 64, 200, 249, 143, 212, 50, 248, 108, 33, 210, 54, 194, 161, 157, 237, 68, 76, 1, 107, 0, 238, 252, 100, 105, 135, 96, 73, 156, 63, 62, 146, 170, 178, 171, 8, 152, 133, 199, 119, 34, 113, 94, 233, 82, 112, 115, 104, 173, 177, 166, 241, 47, 70, 122, 102, 23, 118, 181, 184, 167, 92, 207, 224, 87, 140, 245, 39, 185, 218, 130, 240, 57, 43, 131, 16, 74, 142, 163, 15, 80, 46, 18, 230, 169, 247, 97, 175, 95, 55, 123, 7, 111, 91, 45, 83, 61, 59, 190, 21, 148, 176, 221, 214, 78, 36, 145, 138, 242, 211, 139, 253, 98, 254, 101);\nconst int[257] w_perts = int[](28, 94, 76, 143, 203, 93, 249, 138, 125, 36, 107, 252, 236, 137, 91, 101, 159, 49, 55, 214, 201, 4, 209, 97, 59, 247, 195, 242, 170, 18, 175, 181, 67, 156, 213, 152, 35, 109, 251, 12, 120, 190, 133, 113, 194, 86, 204, 20, 162, 61, 117, 42, 25, 46, 155, 164, 79, 41, 126, 115, 240, 180, 53, 103, 208, 70, 151, 114, 38, 173, 69, 161, 131, 121, 64, 234, 122, 154, 163, 1, 43, 57, 212, 197, 84, 241, 202, 146, 111, 6, 179, 253, 65, 87, 63, 17, 96, 100, 78, 140, 183, 26, 45, 52, 166, 178, 150, 153, 71, 230, 92, 254, 145, 48, 11, 58, 157, 123, 246, 238, 19, 210, 233, 189, 147, 3, 211, 192, 54, 81, 130, 124, 188, 80, 223, 98, 205, 8, 243, 248, 250, 68, 207, 39, 142, 30, 105, 21, 221, 89, 206, 88, 231, 108, 85, 51, 77, 149, 148, 168, 198, 24, 184, 83, 95, 33, 99, 62, 73, 239, 118, 169, 215, 200, 144, 72, 139, 135, 199, 60, 244, 10, 104, 44, 216, 116, 112, 237, 29, 219, 182, 191, 228, 75, 37, 196, 9, 82, 235, 158, 134, 172, 174, 186, 0, 27, 185, 50, 187, 129, 34, 229, 22, 16, 256, 226, 218, 193, 106, 160, 102, 167, 31, 74, 232, 110, 245, 5, 132, 222, 177, 171, 90, 217, 255, 13, 7, 14, 136, 165, 66, 2, 32, 128, 220, 47, 23, 119, 141, 56, 225, 176, 227, 127, 15, 224, 40);\n\n/* This table represents directions from the center of a 4d unit cube to the midpoint \nof each segment of the tesseract. */\nconst vec4[32] grads   = vec4[](\n    vec4( 1, 1, 1, 0), vec4( 1, 1, 0, 1), vec4( 1, 1, 0,-1), vec4( 1, 1,-1, 0),\n\tvec4( 1, 0, 1, 1), vec4( 1, 0, 1,-1), vec4( 1, 0,-1, 1), vec4( 1, 0,-1,-1),\n\tvec4( 1,-1, 1, 0), vec4( 1,-1, 0, 1), vec4( 1,-1, 0,-1), vec4( 1,-1,-1, 0), \n    vec4( 0, 1, 1, 1), vec4( 0, 1, 1,-1), vec4( 0, 1,-1, 1), vec4( 0, 1,-1,-1),\n    vec4( 0,-1, 1, 1), vec4( 0,-1, 1,-1), vec4( 0,-1,-1, 1), vec4( 0,-1,-1,-1),\n    vec4(-1, 1, 1, 0), vec4(-1, 1, 0, 1), vec4(-1, 1, 0,-1), vec4(-1, 1,-1, 0),\n    vec4(-1, 0, 1, 1), vec4(-1, 0, 1,-1), vec4(-1, 0,-1, 1), vec4(-1, 0,-1,-1),\n    vec4(-1,-1, 1, 0), vec4(-1,-1, 0, 1), vec4(-1,-1, 0,-1), vec4(-1,-1,-1, 0)\n);\n\n/* Select a gradient vector from  4d noise space */\nvec4 grad(ivec4 pert) \n{\n    int i = x_perts[(pert.x) % 257];\n    i = y_perts[(pert.y ^ i) % 257];\n    i = z_perts[(pert.z ^ i) % 257];\n    i = w_perts[(pert.w ^ i) % 257];\n    i = x_perts[(pert.x ^ i) % 257];\n    return grads[i % 32];\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float framesPerSec = iTime * 60.0;  // 60 Frames per Second\n    float scalingFactor = 1.0;\t\t\t// 1 pixel in screen space = 1 unit in noise space\n    vec4 noiseSpaceCoord = vec4(\n        fragCoord,     // xy \n        0,             // z\n        framesPerSec   // w\n     );\n\n    // purturbation vector in a scaled version of the noise space coordinate\n    ivec4 pertVec = ivec4(noiseSpaceCoord / scalingFactor);\n    \n    // get the gradient vector for this chosen noise space coordinate.\n    vec4 gradVec = grad(pertVec); \n    \n    fragColor = (gradVec + 1.0) * 0.5; // Move gradient vector components into the range\n                                       // from 0 to 1 for visualization only.                            \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ldyD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[7637, 7689, 7713, 7713, 7926], [7928, 7928, 7983, 7983, 8709]], "test": "ok"}
{"id": "4ldyRj", "name": "Arbitrary Regular Stars", "author": "nr4", "description": "Signed distance to regular stars.", "tags": ["2d", "sdf", "stars", "regular"], "likes": 11, "viewed": 304, "published": "Public", "date": "1533298558", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n * Arbitrary Regular Stars\n * \n * Copyright (C) 2018  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n//Update 1: Distance is now not relying on min(.) anymore to decide which edge should be used.\n//Update 2: Added sign to distance function by avoiding length(p).\n//Update 3: Used mix(vec2,vec2,float) for the alternating radii instead of 2 times mix(float,float,float).\n//Update 4: Added slight grid lines\n//Update 5: Fixed rotation and hash evaluation\n//Update 6: Added counter-clockwise rotations\n\nconst float pi = acos(-1.);\nconst vec3 c = vec3(1.,0.,-1.);\n\n// hash function\nfloat r(vec2 a0)\n{\n    return fract(sin(dot(a0.xy ,vec2(12.9898,78.233)))*43758.5453);\n}\n\n// compute distance to regular star\nfloat dstar(vec2 x, float N, vec2 R)\n{\n    float d = pi/N,\n        p0 = acos(x.x/length(x)),\n        p = mod(p0, d),\n        i = mod(round((p-p0)/d),2.);\n    x = length(x)*vec2(cos(p),sin(p));\n    vec2 a = mix(R,R.yx,i),\n    \tp1 = a.x*c.xy,\n        ff = a.y*vec2(cos(d),sin(d))-p1;\n   \tff = ff.yx*c.zx;\n    return dot(x-p1,ff)/length(ff);\n}\n\n#define A iResolution.y\n#define B 3./Y\n#define S(v) smoothstep(-1.5/A,1.5/A,v)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float a = .1, aa = .5*a; // tile size\n    vec2 uv = fragCoord/A+.5,\n        x = mod(uv, a)-aa, y = uv-x; // we want many polygons\n    \n    //random number of edges and random rotation\n    float p = 5.*(-1.+.1+2.*r(y))*iTime,\n        k = cos(p), s = sin(p),\n        d = dstar(mat2(k,s,-s,k)*x, 3.+floor(8.*r(2.e2*y)), vec2(.15,.45)*a); \n    \n    //set random colors\n    vec3 col = .5 + .5*cos(p+uv.xyx+vec3(0.,2.,4.));\n    fragColor = vec4(col*mix(S(d),1.,.5)+S(-abs(d)),1.);\n    \n    //add borders\n    vec2 v = smoothstep(-aa,-aa+1.5/A,x)*smoothstep(aa,aa-1.5/A,x);\n    fragColor *= v.x*v.y;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ldyRj.jpg", "access": "shaders20k", "license": "gpl-3.0-plus", "functions": [[1205, 1222, 1240, 1240, 1310], [1312, 1348, 1386, 1386, 1688], [1769, 1769, 1826, 1826, 2424]], "test": "error"}
{"id": "4lGcz1", "name": "Optical Stream", "author": "notargs", "description": "#TokyoDemoFest #CEDEC2018", "tags": ["opticalstream", "tokyodemofest", "cedec2018"], "likes": 54, "viewed": 2799, "published": "Public API", "date": "1535009715", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst float PI = 3.1415926;\n\nvec3 rgb2hsv(vec3 hsv)\n{\n\tvec4 t = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(vec3(hsv.x) + t.xyz) * 6.0 - vec3(t.w));\n\treturn hsv.z * mix(vec3(t.x), clamp(p - vec3(t.x), 0.0, 1.0), hsv.y);\n}\n\nmat2 rotate(float a)\n{\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\treturn mat2(\n\t\tc, -s,\n\t\ts, c\n\t);\n}\n\nfloat rand(vec4 co)\n{\n    return fract(sin(dot(co, vec4(12.9898, 78.233, 15.2358, 29.23851))) * 43758.5453);\n}\n\nfloat groundDist(vec3 pos)\n{\n\tpos.y += sin(pos.z * 0.2 + pos.x + iTime * 10.0) * 0.5;\n\tpos.x = mod(pos.x, 4.0) - 2.0;\n\treturn length(pos.yx);\n}\n\nfloat particleDist(vec3 pos)\n{\n    pos += cross(sin(pos * 0.05 + iTime), cos(pos * 0.05 + iTime)) * 3.0;\n    pos.z += iTime * 200.0;\n    vec3 id = floor(pos / 16.0);\n    pos = mod(pos, 16.0) - 8.0;\n    pos += vec3(rand(vec4(id, 0.0)), rand(vec4(id, 1.0)), rand(vec4(id, 2.0))) * 10.0 - 5.0;\n\treturn max(length(pos.yx), abs(pos.z) - 2.0);\n}\n\nfloat skyDist(vec3 pos)\n{\n\tpos.z += iTime * 50.0;\n    vec3 id = floor(pos / 50.0);\n    \n    vec3 t = iTime * vec3(0.0125, 0.25, 0.5);\n    vec3 a = vec3(rand(vec4(id, floor(t.x))), rand(vec4(id + 10.0, floor(t.y))), rand(vec4(id + 20.0, floor(t.z))));\n    vec3 b = vec3(rand(vec4(id, floor(t.x + 1.0))), rand(vec4(id + 10.0, floor(t.y + 1.0))), rand(vec4(id + 20.0, floor(t.z + 1.0))));\n    vec3 c = mix(a, b, pow(fract(t), vec3(1.0 / 4.0)));\n    \n    float s = sign(mod(id.x + id.y + id.z + 0.5, 2.0) - 1.0);\n    vec3 u = iTime / 3.0 + vec3(1.0, 2.0, 3.0) / 3.0;\n    vec3 d = floor(u);\n    vec3 e = floor(u + 1.0);\n    vec3 f = mix(d, e, pow(fract(u), vec3(1.0 / 8.0)));\n    \n\tpos = mod(pos, 50.0) - 25.0;\n\tfor (int i = 0; i < 3; ++i)\n\t{\n\t    pos.yz = rotate(f.x * PI / 2.0 * s) * pos.yz;\n\t    pos.xz = rotate(f.y * PI / 2.0 * s) * pos.xz;\n\t    pos.xy = rotate(f.z * PI / 2.0 * s) * pos.xy;\n\t\tpos = abs(pos);\n\t\tpos -= (c * 12.0);\n\t\tpos *= 2.0;\n\t\tif (pos.x > pos.z) pos.xz = pos.zx;\n\t\tif (pos.y > pos.z) pos.yz = pos.zy;\n\t\tif (pos.x < pos.y) pos.xy = pos.yx;\n\t}\n\treturn length(pos.xz) / 8.0;\n}\n\nfloat dist(vec3 pos)\n{\n\tfloat d = 3.402823466E+38;\n\td = min(d, groundDist(pos));\n\td = min(d, skyDist(pos));\n\treturn d;\n}\n\nvec3 calcNormal(vec3 pos)\n{\n\tvec2 ep = vec2(0.001, 0.0);\n\treturn normalize(vec3(\n\t\tdist(pos + ep.xyy) - dist(pos - ep.xyy),\n\t\tdist(pos + ep.yxy) - dist(pos - ep.yxy),\n\t\tdist(pos + ep.yyx) - dist(pos - ep.yyx)\n\t));\n}\n\nvec3 calcColor(vec3 pos)\n{\n\treturn rgb2hsv(vec3(pos.x * 0.04 + iTime, 1, 1));\n}\n\nvec3 march(vec3 pos, vec3 dir)\n{\n    vec3 color = vec3(0.0, 0.0, 0.0);\n\tfor (int i = 0; i < 32; ++i)\n\t{\n\t\tfloat d = dist(pos);\n\t\tpos += dir * d * 0.9;\n\t\tcolor += max(vec3(0.0), 0.02 / d * calcColor(pos));\n\t}\n\t\n\treturn color;\n}\n\nvec3 marchParticle(vec3 pos, vec3 dir)\n{\n    vec3 color = vec3(0.0, 0.0, 0.0);\n\tfor (int i = 0; i < 32; ++i)\n\t{\n\t\tfloat d = particleDist(pos);\n\t\tpos += dir * d * 0.9;\n\t\tcolor += max(vec3(0.0), 0.005 / d * vec3(1.0, 1.0, 1.0));\n\t}\n\t\n\treturn color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n\t\n\tvec3 pos = vec3(0, 0.0, -10);\n\tvec3 dir = normalize(vec3(p, 1.0));\n\tdir.yz = rotate(-0.5) * dir.yz;\n\tpos.yz = rotate(-0.5) * pos.yz;\n\tdir.xz = rotate(sin(iTime) * 0.3) * dir.xz;\n\tpos.xz = rotate(sin(iTime) * 0.3) * pos.xz;\n\tdir.xy = rotate(0.1 + sin(iTime * 0.7) * 0.1) * dir.xy;\n\tpos.xy = rotate(0.1 + sin(iTime * 0.7) * 0.1) * pos.xy;\n\t\n\tvec3 color = vec3(0, 0, 0) * length(p.xy) * sin(iTime * 10.0);\n\t\n\tcolor += march(pos, dir);\n\tcolor += marchParticle(pos, dir);\n\t\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lGcz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 54, 54, 236], [238, 238, 260, 260, 334], [336, 336, 357, 357, 446], [448, 448, 476, 476, 591], [593, 593, 623, 623, 932], [934, 934, 959, 959, 2026], [2028, 2028, 2050, 2050, 2148], [2150, 2150, 2177, 2177, 2365], [2367, 2367, 2393, 2393, 2446], [2448, 2448, 2480, 2480, 2674], [2676, 2676, 2716, 2716, 2924], [2927, 2927, 2984, 2984, 3554]], "test": "timeout"}
{"id": "4lGyWR", "name": "Bitwise Crunch", "author": "yx", "description": "Tiny little pattern", "tags": ["tweet", "bitwise"], "likes": 4, "viewed": 414, "published": "Public API", "date": "1535625531", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*void mainImage( out vec4 c, vec2 f )\n{\n    //ivec2 u = ivec2(f);\n    //c=vec4((u.x&u.y&255)>(iFrame&255));\n    \n    //c=vec4((int(f.x)&int(f.y)&255)>(iFrame&255));\n    \n    //c+=(int(f.x)&int(f.y)&255)>(iFrame&255)?1.:0.;\n    \n    //if((int(f.x)&int(f.y)&255)>(iFrame&255))c++;\n}*/\n\nvoid mainImage(out vec4 c,vec2 f){if((int(f.x)&int(f.y)&255)>(iFrame&255))c++;}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lGyWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "ok"}
{"id": "4lKcRw", "name": "Fibonacci's Cones", "author": "dr2", "description": "A cheap complex form... (mouseable)", "tags": ["raymarch", "fibonacci"], "likes": 23, "viewed": 632, "published": "Public API", "date": "1535544407", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Fibonacci's Cones\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  1   // optional antialiasing\n\nfloat PrSphDf (vec3 p, float r);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\n\nvec3 ltDir;\nvec2 sRot;\nfloat tCur, dstFar;\nconst float pi = 3.14159, phi = 1.618034;\n\nfloat SphFib (vec3 v, float n)\n{   // based on iq's version of Keinert et al's Spherical Fibonnacci Mapping code\n  vec4 b;\n  vec3 q;\n  vec2 ff, c;\n  float fk, ddMin, a, z, ni;\n  ni = 1. / n;\n  fk = pow (phi, max (2., floor (log (n * pi * sqrt (5.) * (1. - v.z * v.z)) / log (phi + 1.)))) / sqrt (5.);\n  ff = vec2 (floor (fk + 0.5), floor (fk * phi + 0.5));\n  b = 2. * vec4 (ff * ni, pi * (fract ((ff + 1.) * phi) - (phi - 1.)));\n  c = floor ((mat2 (b.y, - b.x, b.w, - b.z) / (b.y * b.z - b.x * b.w)) *\n     vec2 (atan (v.y, v.x), v.z - (1. - ni)));\n  ddMin = 4.1;\n  for (int s = 0; s < 4; s ++) {\n    a = dot (ff, vec2 (s - 2 * (s / 2), s / 2) + c);\n    z = 1. - (2. * a + 1.) * ni;\n    q = vec3 (sin (2. * pi * fract (phi * a) + vec2 (0.5 * pi, 0.)) * sqrt (1. - z * z), z) - v;\n    ddMin = min (ddMin, dot (q, q));\n  }\n  return sqrt (ddMin);\n}\n\nfloat ObjDf (vec3 p)\n{\n  float d;\n  d = PrSphDf (p, 1.11);\n  if (d < 0.05) {\n    p.xz = Rot2Cs (p.xz, sRot);\n    d = 0.4 * PrSphDf (p, 1.1 - 0.1 * smoothstep (0.015, 0.07, SphFib (normalize (p), 512.)));\n  }\n  return d;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = 0; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (0.05, h);\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float dstObj, sh;\n  sRot = sin (0.03 * tCur + vec2 (0.5 * pi, 0.));\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    sh = ObjSShadow (ro, ltDir);\n    col = vec3 (0.2, 1., 0.3) * (0.4 + 0.6 * smoothstep (1., 1.02, length (ro)));\n    col = col * (0.1 + 0.1 * max (dot (vn, - normalize (vec3 (ltDir.xz, 0.).xzy)), 0.) +\n       0.8 * sh * max (dot (vn, ltDir), 0.)) +\n       0.2 * smoothstep (0.8, 0.9, sh) * sh * pow (max (dot (normalize (ltDir - rd), vn), 0.), 64.);\n  } else {\n    col = mix (vec3 (1., 1., 0.5), vec3 (0., 0., 0.3 * (0.7 + 0.3 * rd.y)),\n       smoothstep (0.0035, 0.004, SphFib (rd, 8192.)));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 0., -8.);\n  dstFar = 20.;\n  ltDir = normalize (vec3 (0.5, 3., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 4.;\n#endif  \n  col = vec3 (0.);\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.71 / canvas.y, 0.),\n       0.5 * pi * (a + 0.5)), 6.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (pow (col, vec3 (0.8)), 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lKcRw.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[348, 348, 380, 460, 1193], [1195, 1195, 1217, 1217, 1416], [1418, 1418, 1451, 1451, 1628], [1630, 1630, 1651, 1651, 1851], [1853, 1853, 1890, 1890, 2124], [2126, 2126, 2161, 2161, 2875], [2877, 2877, 2933, 2933, 3935], [3937, 3937, 3970, 3970, 3997], [3999, 3999, 4029, 4029, 4142], [4144, 4144, 4175, 4175, 4239]], "test": "ok"}
{"id": "4ltcDj", "name": "skulls", "author": "nabr", "description": "And the blood drains down like devil's rain\nWe'll bathe tonight", "tags": ["texture", "musicvisualisation", "soundcloud"], "likes": 5, "viewed": 276, "published": "Public", "date": "1534121916", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// nabr\n// https://www.shadertoy.com/view/4ltcDj\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://creativecommons.org/licenses/by-nc-sa/3.0/\n\n\n\n#define time iTime\n#define _ vec2((fragCoord.xy*2.001-iResolution.xy )/iResolution.y)\n\n#define pi 3.14159265359\n#define pi2 6.28318530718\n\nfloat music(vec2 r){\n    \n    // ----- music texture https://www.shadertoy.com/view/Xds3Rr\n    \n \t// the sound texture is 512x2\n    int tx = int( r.x * 512.0);\n    \n\t// first row is frequency data (48Khz/4 in 512 texels, meaning 23 Hz per texel)\n\tfloat fft  = texelFetch( iChannel0, ivec2(tx,0), 0 ).x ; \n\n    // second row is the sound wave, one texel is one mono sample\n    return texelFetch( iChannel0, ivec2(tx,1), 0 ).x;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // music texture\n    float m = (music( abs(_) / 22.001 ))* .5 +.5 ;\n    \n    // make a tunnel\n    float a = (.5+atan( length ( _ ), 1. ) * pi2);\n    float r = clamp(  a - acos(  _.y * 1.18 ) / pi2, 0., 1.);\n    \n    // animate\n    // https://en.wikipedia.org/wiki/Shadertoy#Usage\n    vec2 uv =  vec2( 1./r + 0.2* time, m+a );\n    float f = sin(uv.x) * cos ( time  - uv.y);\n    \n    // grid overlay\n    float grid = abs(0.01/ sin(  f + _.x * 12.) - f * cos( _.y)) \n        \t\t - uv.y * abs(0.0015 / sin( f - _.y * 12.) - .081/cos(f*_.x));\n    \n    // shade\n    vec3 col = (grid * 0.5) + (0.25 * cos(time- 0.25 + (pi2 * grid) + vec3( -pi/2., pi/2.6, pi )));\n    \n    fragColor.rgb =  grid + pow(col + 0.2 , 2.2 / vec3( uv.x, uv.y , 1.-(uv.x+uv.y) ) );\n    fragColor.a = 1.;\n}", "image_inputs": [{"id": "4d2SWV", "previewfilepath": "https://soundcloud.com/midocamusic/misfits-skulls-dark-waves-midoca-cover-1", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/midocamusic/misfits-skulls-dark-waves-midoca-cover-1", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ltcDj.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[332, 332, 352, 459, 759], [762, 762, 819, 840, 1596]], "test": "error"}
{"id": "4ltyDl", "name": "t^-n thingy", "author": "khlorghaal", "description": " ", "tags": ["fractal", "sierpenski"], "likes": 2, "viewed": 94, "published": "Public", "date": "1534660684", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SS 4\nvec3 subsample(vec2 fc){\n    vec2 res= floor(iResolution.xy);\n    vec2 uv = fc/res;\n    vec2 s= uv*2.-1.;\n    s.x*= res.x/res.y;\n    uv= s;\n    uv*= 1.0001;\n    int a= 0;\n    for(int i=1; i<= 32; i++){\n        float c= pow(2.+cos(iTime*.5),float(i));\n        vec2 v= mod(abs(uv)*c, vec2(1))*2.-1.;\n        a+= max(v.x,v.y)>.0? 1:0;\n        //if(a<.0)\n            //b= true;\n    }\n    \n    vec3 c;\n    a=a/2-6;\n    \n    switch(a){\n    case 0:\n        c= vec3(0.,0.,0.);\n        break;\n    case 1:\n        c= vec3(1.,0.,0.);\n        break;\n    case 2:\n        c= vec3(0.,1.,0.);\n        break;\n    case 3:\n        c= vec3(0.,0.,1.);\n        break;\n    case 4:\n        c= vec3(0.,0.,1.);\n        break;\n    case 5:\n        c= vec3(0.,1.,1.);\n        break;\n    case 6:\n        c= vec3(.5,0.,1.);\n        break;\n    case 7:\n        c= vec3(1.,.5,0.);\n        break;\n    };\n\t\n    //float l= float(a)/32.;\n    //c= vec3(l);\n    return c;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 fc = floor(fragCoord);\n    \n    vec3 c= vec3(0);\n    for(int y=0; y!=SS; y++){\n    \tfor(int x=0; x!=SS; x++){\n            c+= subsample(fc + vec2(x,y)/float(SS));\n        }\n    }\n    c/=float(SS*SS);\n    //c= pow(c,vec3(1./2.4));//srgb\n    //c+= rand(length(fc)+iTime)/250.;//dither\n        \n    fragColor= vec4(c,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ltyDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[13, 13, 37, 37, 946], [947, 947, 1004, 1004, 1333]], "test": "ok"}
{"id": "4ltyWf", "name": "pedal - parabola", "author": "elenzil", "description": "the pedal curve of a parabola and the mouse point", "tags": ["math", "curves", "parabola", "pedal"], "likes": 3, "viewed": 439, "published": "Public API", "date": "1534454132", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// the Pedal of a curve C and a point Q\n// is the locus of all points P such that there is a tangent to C\n// which passes through P and which is perpendicular to PQ.\n//\n// line-plotting credits:\n// http://www.iquilezles.org/www/articles/functions/functions.htm\n// Reimplemented by starea @ shadertoy using Flyguy's Implicit Plotter https://www.shadertoy.com/view/4tB3WV\n//\n// todo: apply the GRAD/PLOT approach to the pedal curve itself.\n\n\n#define SHOW_MOUSE_TANGENTS 0\n#define SHOW_MOUSE          1\n\n#define LINE_SIZE           2.0\n#define DISP_SCALE          1.0\n\nconst vec2 GRAD_OFFS = vec2(0.001, 0);\n\n#define GRAD(f, p) (vec2(f(p) - f(p + GRAD_OFFS.xy), f(p) - f(p + GRAD_OFFS.yx)) / GRAD_OFFS.xx)\n\n//PLOT(Function, Color, Destination, Screen Position)\n#define PLOT(f, c, d, p) d = mix(c, d, smoothstep(0.0, (LINE_SIZE / iResolution.y * DISP_SCALE), abs(f(p) / length(GRAD(f,p)))))\n\n\n#define FWIDTH2(f) (length(vec2(dFdx(f), dFdy(f))))\n\nfloat parabola_k = 1.0;\nvec2  parabola_c = vec2(0.0, 0.0);\n\nfloat parabola(vec2 p) {\n    float x = p.y * p.y * parabola_k + parabola_c.x;\n    return p.x - x;\n}\n\nbool parabolaTangents(vec2 c, float k, vec2 p, out vec2 t1, out vec2 t2) {\n    p -= c;\n    \n    // check that p is outside the parabola\n    float ppx = p.y * p.y * k;\n    if (p.x * sign(k) > ppx * sign(k)) {\n        return false;\n    }\n    \n    float A = k;\n    float B = -2.0 * k * p.y;\n    float C = p.x;\n    float D = (B * B) - (4.0 * A * C);\n    // we don't check D >= 0 because we know p is beneath the parabola\n    \n    float d = sqrt(D);\n    t1.y = (-B + d) / (2.0 * A);\n    t1.x = t1.y * t1.y * k;\n    t2.y = (-B - d) / (2.0 * A);\n    t2.x = t2.y * t2.y * k;\n    \n    t1 += c;\n    t2 += c;\n    \n    return true;\n}\n\n\nfloat oxeVec2f_distanceRight_PointLine(vec2 linePt, vec2 unitDir, vec2 pt)\n{\n   float vx = pt.x - linePt.x;\n   float vy = pt.y - linePt.y;\n   return unitDir.y * vx - unitDir.x * vy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = length(iMouse.xy) < 0.01 ? vec2(cos(iTime) * 40.0 + iResolution.x / 4.0, sin(iTime) * 20.0 + iResolution.y / 2.0) : iMouse.xy;\n    vec2 uv = ((fragCoord - iResolution.xy * 0.5)/iResolution.y);\n\tvec2 ms = ((mouse - iResolution.xy * 0.5)/iResolution.y);\n    vec2 pm = ms - uv;\n    float lpm = length(pm);\n\n    vec3 col = vec3(0.0);\n    \n    parabola_k = sin(iTime * 0.1 - 1.6) * 8.0 + 8.001;\n    parabola_c = vec2(-0.1, 0.0);\n    \n    vec2 t1;\n    vec2 t2;\n    bool hasTangents;\n    \n    PLOT(parabola, vec3(0.0, 0.7, 0.8), col, uv);\n    \n    \n\thasTangents = parabolaTangents(parabola_c, parabola_k, uv, t1, t2);\n    if (hasTangents) {\n        col += vec3(0.2);\n        \n\t    vec2 pmn = pm / lpm;\n   \t    vec2 t1n = normalize(t1 - uv);\n   \t    vec2 t2n = normalize(t2 - uv);\n        \n        float t1d = dot(pmn, t1n);\n        float t2d = dot(pmn, t2n);\n        \n        const float thresh = 0.04;\n        \n        float c1 = smoothstep(thresh, 0.0, abs(t1d) / (FWIDTH2(t1d) * 70.0));\n        float c2 = smoothstep(thresh, 0.0, abs(t2d) / (FWIDTH2(t2d) * 70.0));\n        col += vec3(c1 * 0.6);\n        col += vec3(c2 * 0.6);\n        col += vec3(0., 0., 0.3 * smoothstep(thresh, 0.0, t1d));\n        col += vec3(0.3 * smoothstep(thresh, 0.0, t2d), 0., 0.);\n    }\n    \n    #if SHOW_MOUSE\n    \tcol.g += 0.4 * smoothstep(0.02, 0.01, lpm);\n    #endif\n    \n    #if SHOW_MOUSE_TANGENTS\n    hasTangents = parabolaTangents(cen, parabola_k, ms, t1, t2);\n    if (hasTangents) {\n        float distToTangentLine;\n        distToTangentLine = oxeVec2f_distanceRight_PointLine(t1, normalize(t1 - ms), uv);\n        col *= smoothstep(0.005, 0.0, abs(distToTangentLine)) * 0.5 + 1.0;\n        distToTangentLine = oxeVec2f_distanceRight_PointLine(t2, normalize(t2 - ms), uv);\n        col *= smoothstep(0.005, 0.0, abs(distToTangentLine)) * 0.5 + 1.0;\n    }\n    #endif\n    \n    \n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ltyWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1002, 1002, 1026, 1026, 1101], [1103, 1103, 1177, 1177, 1724], [1727, 1727, 1803, 1803, 1910], [1912, 1912, 1969, 1969, 3873]], "test": "ok"}
{"id": "4lVcRR", "name": "Pinky", "author": "rs_creative", "description": "Raymarching play with lighting.", "tags": ["raymarch", "fun", "specular", "pink"], "likes": 2, "viewed": 101, "published": "Public", "date": "1534861223", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nvec3 mapP( vec3 p )\n{\n    //p.xyz += 1.000*sin(  2.0*p.yzx )*grow.x;\n    //p.xyz += 0.500*sin(  4.0*p.yzx )*grow.y;\n    //p.xyz += 0.250*sin(  8.0*p.yzx )*grow.z;\n    //p.xyz += 0.050*sin( 16.0*p.yzx )*grow.w;\n    return p;\n}\n\n\nvec2 rotate(vec2 pos, float angle) \n{\n    float c = cos(angle);\n    float s = sin(angle);\n\n    return mat2(c, s, -s, c) * pos;\n}\n\nfloat sphere( vec3 pos, float r )\n{\n  return length(pos) - r;\n}\n\nfloat plane (vec3 pos)\n{\n    return pos.y;\n}\n\nfloat box(vec3 pos, vec3 size, float radius)\n{\n    return length(max(abs(pos) - size, 0.0)) - radius;\n}\n\nfloat map(vec3 pos) \n{\n    vec3 planePos = pos + vec3(1.2, 3.0, + 0.5);\n    \n    float planeDist = plane(planePos);\n    \n    vec3 spherePos = pos + vec3((sin(iTime)) * 3.0,  -2.0, + 0.5);\n    spherePos.y += sin(iTime) * 0.4;\n    \n    \n    vec3 boxPos = mapP(pos) + vec3(-1.8, -3.5, + 0.5);\n    \n    spherePos.xz = rotate(spherePos.xz, iTime);\n    spherePos.xy = rotate(spherePos.xy, iTime * 2. );\n\n    \n    float sphere = sphere(spherePos, 1.9);\n    \n    // Rotate the shapes\n    boxPos.xz = rotate(boxPos.xz, iTime);\n    boxPos.xy = rotate(boxPos.xy, iTime * 2. );\n    boxPos.x += sin(iTime) * 0.6;\n    \n    float box1 = box(boxPos, vec3(1.2), 1.0);\n    \n    float d = min(box1, planeDist);\n    d = min(d, sphere);\n    return d;\n}\n\nvec3 albedo(vec3 pos)\n{\n    return vec3(1.0);\n}\n\nvec3 computeNormal(vec3 pos)\n{\n    vec2 eps = vec2(0.01, 0.0);\n    return normalize(vec3(\n        map(pos + eps.xyy) - map(pos - eps.xyy),\n        map(pos + eps.yxy) - map(pos - eps.yxy),\n        map(pos + eps.yyx) - map(pos - eps.yyx)\n        ));\n}\n\nvec3 lightDirection = normalize(vec3(1.0, 0.6, 1.0));\n\nfloat diffuse(vec3 normal) {\n    return max(dot(normal, lightDirection), 0.0);\n}\n\nfloat specular(vec3 normal, vec3 dir) \n{\n    vec3 h = normalize(normal - dir);\n    return pow(max(dot(h, normal), 0.0), 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = -1.0 + uv * 2.0;    \n    uv.x *= (iResolution.x / iResolution.y);\n   \t\n    \n    vec3 pos = vec3(0.0, 2.7, -8.0);\n    \n    \n    vec3 dir = normalize(vec3(uv, 1.0));    \n    vec3 color = vec3(1.0);\n        \n    for (int i = 0; i < 64; i ++ ) \n    {\n        float d = map(pos);\n        if (d < 0.1)\n        {\n            // Intersection\n            float lightDistance1 = sphere(pos + vec3(0.0, -2.0, 1.0), 0.0);\n            vec3 normal = computeNormal(pos);\n            float diff = diffuse(normal);\n            float spec = specular(normal, dir);\n            color =  (diff + spec) * 5.0 / (lightDistance1) * vec3(0.7, 0.1, 0.3) * albedo(pos);\n            break;\n        }\n        pos += d * dir;\n        color = vec3(1.0);\n    }\n    \n    float fogFactor = exp(-pos.z * 0.09);\n    \n    color = mix(vec3(0.0), color, fogFactor);\n    \n    fragColor = vec4(color, 1.0);\n\n}", "image_inputs": [{"id": "4sfGzn", "previewfilepath": "/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lVcRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 23, 211, 227], [230, 230, 267, 267, 358], [360, 360, 395, 395, 423], [425, 425, 449, 449, 469], [471, 471, 517, 517, 574], [576, 576, 598, 598, 1307], [1309, 1309, 1332, 1332, 1356], [1358, 1358, 1388, 1388, 1607], [1664, 1664, 1692, 1692, 1744], [1746, 1746, 1786, 1786, 1873], [1875, 1875, 1930, 1930, 2853]], "test": "ok"}
{"id": "4lVyzW", "name": "Hash Random Testing", "author": "mgear", "description": "modifying the original shader from https://www.shadertoy.com/view/XlXcW4", "tags": ["hash"], "likes": 2, "viewed": 90, "published": "Public", "date": "1535357448", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// attempt to make 'lite' version of this noise (by random-brute-force-try-method : )\n// Based on https://www.shadertoy.com/view/XlXcW4\n\nconst uint k = 1103515245U;  // GLIB C\n\nfloat hash( uvec2 x )\n{\n//    return float(((x.x+k)^x.y)*k)*0.00000000025;\n    return float(((x.x>>8U)^x.y)*k)*0.00000000025;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uvec2 p = uvec2(fragCoord.xy*float(iFrame));\n    float c = hash(p);\n    fragColor = vec4(c,c,c,1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lVyzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[177, 177, 200, 251, 304], [306, 306, 363, 363, 471]], "test": "ok"}
{"id": "4lyyRw", "name": "Square Tunnels", "author": "momoro", "description": "Random WIP", "tags": ["color"], "likes": 4, "viewed": 504, "published": "Public API", "date": "1535425717", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n#define PI 3.141592654\n\nfloat map(float value, float inMin, float inMax, float outMin, float outMax) {\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n}\n\n\nmat2 rotate(float angle) {\n    return mat2(cos(angle), -sin(angle),\n                sin(angle), cos(angle)\n    );\n}\n\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n\nfloat atan201(float x, float y) {\n    return (atan(x, y) + PI) / (PI * 2.);\n}\n\nfloat sin01(float n) {\n    return sin(n)/2.+.5;\n}\n\nvec2 sin01(vec2 n) {\n    return sin(n)/2.+.5;\n}\n\nvec4 blend(vec4 bg, vec4 fg) {\n    vec4 c = vec4(0.);\n    c.a = 1.0 - (1.0 - fg.a) * (1.0 - bg.a);\n    if(c.a < .00000) return c;\n    \n    c.r = fg.r * fg.a / c.a + bg.r * bg.a * (1.0 - fg.a) / c.a;\n    c.g = fg.g * fg.a / c.a + bg.g * bg.a * (1.0 - fg.a) / c.a;\n    c.b = fg.b * fg.a / c.a + bg.b * bg.a * (1.0 - fg.a) / c.a;\n    \n    return c;\n}\n\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return dot(m, g);\n}\n\n\nfloat fbm1d(float x, float amplitude, float frequency, float offset) {\n    x += offset;\n    float y = 0.;\n    // Properties\n    const int octaves = 8;\n    float lacunarity = 1.144;\n    float gain = 1.092;\n    \n    // Initial values\n    //sin(u_time) * 5. + 10.;\n    //sin(u_time/10. + 10.);\n    \n    // Loop of octaves\n    for (int i = 0; i < octaves; i++) {\n        y += amplitude * snoise(vec2(frequency*x));\n        frequency *= lacunarity;\n        amplitude *= gain;\n    }\n    \n    return y;\n}\n\n\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\nfloat smax(float a,float b, float k)\n{\n    return -smin(-a,-b,k);\n}\n\nfloat smootheststep(float t) {\n    return -20.*pow(t, 7.)+70.*pow(t,6.)-84.*pow(t,5.)+35.*pow(t,4.); // when smootherstep's second derivative isn't enough\n}\n\n\nfloat pcsmooth(float x) {\n    return -\n        pow(cos((PI*(x)/2.)), 3.) + 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    \n    vec4 color;\n    vec2 st = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    \n    st /=20.036;\n    //st += vec2(0.000,-0.055);\n    \n    st *= rotate(iTime/.9);\n    \n    /////////////////////////////////////////////////////////////\n    // Blobby circle\n    #define arcs 7.\n    \n    float f = atan201(st.x, st.y); // angle\n    float m = smoothstep(0., 1., fract(f * arcs)); // mix amount\n\t\n     m = pcsmooth(fract(f*arcs));\n    \n    f = ceil(f * arcs) / arcs; // split up\n    \n    float fNext = f + 1./arcs;\n    // fNext = f;\n    \n    \n    // Smooth the blob at the end\n    bool e = false;\n    if(f > (arcs-1.)/arcs + .01) {\n\t\tfNext = 1./arcs;\n    }\n    \n    // Add noise\n    float amp = 10000.;\n    float freq = 30.;\n    \n    float offset = 1.144 + iTime/300.;\n    f = fbm1d(f, amp, freq, offset);\n    fNext = fbm1d(fNext, amp, freq, offset);\n    \n    f =  map(f, -20., 1., 0.648, 0.712);\n    fNext = map(fNext, -20., 1., 0.648, 0.712);\n\n    float len = length(st);\n\n    float mx = mix(f, fNext, m);\n    len += mx * 0.080;\n    \n  //  float c = smoothstep(len, 0.712, 0.900);\n    \n   // color.rgb = vec3(c);\n\n  //  color.a = 1.;\n    //color.rgb = vec3(mx);\n    \n    #define steps 90.\n    for(float i=0.; i<steps; i++) {\n   \t\tfloat df = max(abs(st.x), abs(st.y));\n   //     df = len -1.984;\n        // df = length(st);\n        \n        float incr = 0.4 - (0.4 * i/steps);\n        \n        float f = 1.0 - smoothstep(incr-.001, incr, df);\n\n        // SHADOW\n       f -=  (1.0 - (fract(df*steps) + 0.0)) * 1. * f;\n        \n        vec3 rgb = vec3(f);\n        \n        vec3 hsv = vec3(1.);\n        hsv.x = pow(2. * fract((i*6.)/steps + iTime/2.3) - 1., 2.);\n        hsv.x = map(hsv.x, 0., 1., 0.0, 0.108);\n        hsv.y = .9;\n\n        vec3 rgb2 = hsv2rgb(hsv);\n\n        rgb = rgb2 * rgb * 3.112;\n        float a = (i/steps + 0.640) * f;\n       // a  = 0.208;\n\n        color = blend(color, vec4(rgb, a * f));\n    }\n    \n   // st = st * rotate(-300.148 + -iTime/.3);\n    st += vec2(0,0);\n    st *= 1.128 + sin(iTime);\n\n    \n    for(float i=0.; i<steps; i++) {\n   \t\tfloat df = max(abs(st.x), abs(st.y));\n      //  df = len  *.3;\n        // df = length(st);\n        \n        float incr = 0.4 - (0.4 * i/steps);\n        \n        float f = 1.0 - smoothstep(incr-.001, incr, df);\n\n        // SHADOW\n       f -=  (1.0 - (fract(df*steps) + 0.)) * 1.* f;\n        \n        vec3 rgb = vec3(f);\n        \n        vec3 hsv = vec3(1.);\n        hsv.x = pow(2. * fract((i*6.)/steps + iTime/9.3) - 1., 2.);\n        hsv.x = map(hsv.x, 0., 1., 0.0, 0.964);\n        hsv.y = .9;\n        hsv.z = .3;\n\n        vec3 rgb2 = hsv2rgb(hsv);\n\n        rgb = rgb2 * rgb * 3.112;\n        float a = (i/steps + 0.01) - 0.472;\n       // a  = 0.208;\n\n        color = blend(color, vec4(rgb, a * f));\n    }\n        \n    color = color;\n    \n    fragColor = color;\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lyyRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 104, 104, 179], [182, 182, 208, 208, 297], [300, 300, 322, 322, 653], [655, 655, 677, 677, 846], [848, 848, 869, 869, 916], [917, 917, 938, 938, 985], [986, 986, 1008, 1008, 1043], [1046, 1046, 1079, 1079, 1123], [1125, 1125, 1147, 1147, 1174], [1176, 1176, 1196, 1196, 1223], [1225, 1225, 1255, 1255, 1572], [1574, 1574, 1596, 1649, 3338], [3341, 3341, 3411, 3411, 3838], [3841, 3841, 3879, 3879, 3956], [3958, 3958, 3996, 3996, 4025], [4027, 4027, 4057, 4057, 4183], [4186, 4186, 4211, 4211, 4266], [4268, 4268, 4325, 4325, 7173]], "test": "ok"}
{"id": "4lyyzh", "name": "[twitch] Elysian", "author": "yx", "description": "Coded live on twitch stream in Bonzomatic, and ported to shadertoy.\nUnedited Bonzomatic shader here: [url]https://gist.github.com/willkirkby/dcad2f53b0ce381c30513f707786dbb4[/url]\nInspired by [url=http://www.pouet.net/prod.php?which=68375]Elysian[/url]", "tags": ["elysian"], "likes": 30, "viewed": 1263, "published": "Public API", "date": "1534974606", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi acos(-1.)\n\nvec2 modang(vec2 p, float rep)\n{\n  float r = length(p);\n\n  float ang = atan(p.x,p.y) / (2. * pi);\n  ang = (fract(ang*rep)+1.)/rep;\n  ang *= 2.*pi;\n\n  return vec2(sin(ang),cos(ang))*r;\n}\n\nfloat sdBox( vec2 p, vec2 b )\n{\n  vec2 d = abs(p) - b;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec3 color(vec2 uv)\n{\n  uv = fract(uv);\n  uv = uv * 1.04 - .02;\n  if(any(greaterThan(abs(uv-.5),vec2(.5))))\n    return vec3(0);\n\n  vec2 originalUv = uv;\n\n  uv = fract(uv * 8.);\n  uv = uv * 1.1 - .05;\n  if(any(greaterThan(abs(uv-.5),vec2(.5))))\n    return vec3(0);\n  \n  float d = sdBox(fract(uv*4.)-.5, vec2(.2));\n  float threshold = .04;\n  //threshold = max(length(dFdx(uv)),length(dFdy(uv)));\n  float mask = smoothstep(threshold,-threshold,d);\n  //mix(vec3(66, 244, 226), vec3(65, 68, 244), sin(uv.x+iTime*4.)*.5+.5) / 255;\n  uv = fract(originalUv);\n  uv *= 32.;\n  uv = floor(uv);\n  uv /= 32.;\n  vec3 col = vec3(.03);\n  col += smoothstep(.6,1.,sin(uv.x*20.-iTime*1.5));\n  col += smoothstep(.9,1.,sin(3.*atan(uv.x-.5,uv.y-.5)-iTime*1.5+.5)) * vec3(.2,.6,1);\n  col += smoothstep(.9,1.,sin(3.*atan(uv.x-.5,uv.y-.5)+iTime*1.5+.5)) * vec3(1,.5,.2);\n//mask=1;\n  return vec3(mask) * col;\n}\n\nvec3 pal(vec3 a, vec3 b, vec3 c, vec3 d, float t)\n{\n  return a+b*cos(2.*pi*(c*t+d));\n}\n\nvec3 logichroma(float t)\n{\n  return pal(\n    vec3(.5),\n    vec3(.5),\n    vec3(1.),\n    vec3(0,1,2)/3.,\n    t\n  );\n}\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord)\n{\n  vec2 uv = fragCoord / iResolution.xy - .5;\n  uv.x *= iResolution.x / iResolution.y;\n  uv.y += .07;\n\n  out_color.rgb = color(fragCoord / iResolution.xy);\n  \n  float chromaStrength = sin(iTime*.5);\n\n  out_color.rgb = vec3(0);\n  for(int i=0;i<100;++i)\n  {\n    uv *= mix(1.,.996,chromaStrength);\n    vec2 u = modang(uv, 3.);\n    u = vec2(\n      u.x/u.y,\n      1./u.y\n    ) / sqrt(3.)*.5 + .5;\n    \n    vec3 col = color(u+vec2(0,-iTime*.1));\n    float depthfog = pow(smoothstep(3.,-1.,-u.y),2.);\n    out_color.rgb += col * depthfog * logichroma(float(i)/100.0);\n  }\n  out_color.rgb /= 4.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lyyzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 54, 54, 207], [209, 209, 240, 240, 318], [320, 320, 341, 341, 1203], [1205, 1205, 1256, 1256, 1291], [1293, 1293, 1319, 1319, 1408], [1410, 1410, 1462, 1462, 2050]], "test": "ok"}
{"id": "4st3z7", "name": "Checkboard Illusion", "author": "benito_luna", "description": "Classic checkboard illusion", "tags": ["illusion"], "likes": 2, "viewed": 73, "published": "Public", "date": "1534872796", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec4 grey1 = vec4(0.7,0.7,0.7,1.0);\nconst vec4 grey2 = vec4(0.6,0.6,0.6,1.0);\nconst vec4 white = vec4(0.9,0.9,0.9,1.0);\nconst float squareSize = 0.07;\n\nconst float crossThickness = 0.05;\nconst float crossWidth = 0.2;\nconst float speed = 2.;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\tvec2 uv =  (fragCoord.xy  / ( squareSize * iResolution.xx ) );          \n    vec2 checkboardCoords =  floor(uv);\n    \n    // Checkboard\n    if ((checkboardCoords.x+checkboardCoords.y != floor((checkboardCoords.x+checkboardCoords.y)*0.5)*2.))\n    {\n        fragColor = grey1;\n    }\n    else\n    {\n        fragColor = grey2;\n    }        \n    \n    //floating part\n     vec2 floatingPart = uv - checkboardCoords.xy;\n    float xDiff = ( floatingPart.x > 0.5 ) ?  checkboardCoords.x + 1. - uv.x : uv.x - checkboardCoords.x;\n    float yDiff = ( floatingPart.y > 0.5 ) ?  checkboardCoords.y + 1. - uv.y : uv.y - checkboardCoords.y;\n\t\n    if ( xDiff < crossThickness && yDiff < crossWidth || yDiff < crossThickness && xDiff < crossWidth )\n    {\n               fragColor = mix(white,fragColor, 0.5 * ( sin(iTime* speed) + 1. ) );\n    }\n    \n    \n    \n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4st3z7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[249, 249, 306, 306, 1165]], "test": "ok"}
{"id": "4syBWV", "name": "A Stormy Night", "author": "dreamur", "description": "Just something else I've been working on.\n\nCredits/ thanks to akufishi here on Shadertoy, Golan Levin & Collaborators from flong, and Patricio Gonzalez Vivo & Jen Lowe from The Book of Shaders for creating lots of helpful resource materials.", "tags": ["cloud", "sky"], "likes": 2, "viewed": 110, "published": "Public", "date": "1535489169", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265358\n\nfloat circle(in vec2 _st, in float _radius){\n    vec2 dist = _st-vec2(0.5);\n\treturn 1.-smoothstep(_radius-(_radius*0.08),\n                         _radius+(_radius*0.1),\n                         dot(dist,dist)*4.0);\n}\n\nfloat ellipse(vec2 _st, float _radius){\n    vec2 dist = _st-vec2(0.5);\n\treturn 1.-smoothstep(_radius,\n                         _radius,\n                         dot(dist,dist / vec2(1.61, 0.67) )*4.0);\n}\n\nfloat rect(vec2 coordSpace, vec2 dim)\n{          \n    vec2 tmp = smoothstep( dim, dim, coordSpace );\n    float pct = tmp.x * tmp.y;\n    \n    tmp = smoothstep( dim, dim, 1. - coordSpace );\n    pct *= tmp.x * tmp.y;\n\n    return pct;\n}\n\n\nfloat plot(float x, float pct) {\n    \n    return step( x, pct ) - step( x, pct - .15 ); \n}\n\n// by Golan Levin and Collaborators\n// http://www.flong.com/texts/code/shapers_exp/\nfloat logisticSigmoid (float x, float a){\n\n  float epsilon = 0.0001;\n  float min_param_a = 0.0 + epsilon;\n  float max_param_a = 1.0 - epsilon;\n  a = max(min_param_a, min(max_param_a, a));\n  a = (1./(1.-a) - 1.);\n\n  float A = 1.0 / (1.0 + exp(0. -((x-0.5)*a*2.0)));\n  float B = 1.0 / (1.0 + exp(a));\n  float C = 1.0 / (1.0 + exp(0.-a)); \n  float y = (A-B)/(C-B);\n  return y;\n}\n\n// concept from \"Rainbow Showoff\"\n// by akufishi\n// https://www.shadertoy.com/view/lscBRf\nfloat rainDrop( vec2 coordSpace, float scalar, float timeOffset, float modVal)\n{      \n    float tempTime = iTime * 10.;\n    float initPos = fract( sin(coordSpace.x) * scalar ) / iTime + timeOffset;\n    return rect( vec2(mod(coordSpace.y + tempTime * initPos, modVal)) , vec2(0.485, .44) );\n}\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                * 43758.5453123);\n}\n\n\n// by Patricio Gonzalez Vivo from The Book of Shaders\n// https://thebookofshaders.com/11/\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);    \n    vec2 u;\n    u = f*f*f*(f*(f*6.-15.)+10.);\n    return mix( mix( random( i + vec2(0.0,0.0) ),\n                     random( i + vec2(1.0,0.0) ), u.x),\n                mix( random( i + vec2(0.0,1.0) ),\n                     random( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// by Patricio Gonzalez Vivo from The Book of Shaders\n// live version below\n//     https://thebookofshaders.com/edit.php#11/wood.frag\nfloat lines(in vec2 pos, float b){\n    float scale = 10.0;\n    pos *= scale;\n    return smoothstep(0.0,\n                    .5+b*.5,\n                    abs((sin(pos.x*3.1415)+b*2.0))*.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord/iResolution.xy;\n    \n    st -= 0.5;\n    st.x *= iResolution.x/iResolution.y;\n    st += 0.5;\n\n    vec3 col;\n    col = vec3(0.);\n    col = vec3(0, .518, 0.694);\t\n    \n    float pct;   \n    \n    \n    //\n    //\n    // rain - far layer\n    //\n    //   \n    pct = rainDrop(st - vec2(0.0, 0.5), 54873., 0.2, 1.0 );\n    col = mix(col, vec3(0.851, 0.851, 1.0), pct );\n      \n    \n    //\n    //\n    // create far hill of grass\n    //\n    //\n    \n    \n    pct = ellipse(st + vec2(-.35, 0.05), .55);\n    col = mix(col, vec3(.133, .553, .133), pct); \n       \n    \n    //\n    //\n    // create far river\n    //\n    //\n    \n    float xOffset = 0.68;\n    vec2 tmpSpace;\n    \n    for (int i = 0; i < 7; i++)\n    {\n        tmpSpace = st - vec2(xOffset, 0.5025);\n        tmpSpace *= vec2(3., 3.);    \n        float range = step(-0.05, tmpSpace.x) * tmpSpace.y;\n        range -= step(0.7, tmpSpace.x) * tmpSpace.y;\n        range += step(0.75, tmpSpace.y) * tmpSpace.y;\n        range += step(0.8, tmpSpace.y) * tmpSpace.y;            \n        \n        pct = logisticSigmoid(tmpSpace.x , 0.887);\n        pct = plot(range , pct);\n        \n        col = mix(col, vec3(0, .576, 0.769), pct );\n        \n        xOffset -= 0.01;\n    }    \n    \n    \n    //\n    //\n    // darken things up to this point\n    //\n    //\n    col = mix(col, vec3(0.0), 0.15);\n    \n    \n    //\n    //\n    // draw the near field of grass\n    //\n    //\n    \n    col = mix(col, vec3(.133, .553, .133), rect(st - vec2(0.0, -.45), vec2(-.5, .02)) );        \n        \n    //\n    //\n    // fill the sky of clouds\n    //\n    //\n    \n    float cloudColor = 0.3;\n    float yPos = 0.31;\n    float width = 0.79;\n    float xMod = 0.0;\n    float xModOffset = 0.00;\n    \n    for (int i = 0; i < 6; i++)\n    {\n        for (int j = 0; j < 29; j++)\n        {                   \n            float mov = 0.0;\t\n            \n            vec2 offset = vec2( -0.95 + xMod + mov + xModOffset, yPos );\n            vec2 coords = st * vec2(width, 1.0);\n            \n            col = mix(col, vec3(cloudColor), circle(coords - offset, .005) );\n            col = mix(col, vec3(cloudColor), circle(coords - offset - vec2(0.06, 0.), .005) );\n            col = mix(col, vec3(cloudColor), circle(coords - offset - vec2(-0.06,0.), .005) );   \n\n            xMod += .17;\n        } \n        \n        if (i % 2 == 0)\n        {\n        \txModOffset = 0.023;      \n        }\n        else\n        {\n         \txModOffset = -0.013;   \n        }\n        \n        \n        cloudColor += 0.04;\n        yPos += 0.025;\n        width -= 0.07;\n        \n        xMod = 0.0;  \n    }\n    \n    //\n    //\n    // foliage\n    //\n    // \n    for (int i = 0; i < 5; i++)\t\n    {\n        vec2 unitOffset = \ti == 0 ? vec2(0.52, -0.1) : \n                            i == 1 ? vec2(0.0, -0.25) :\n                            i == 2 ? vec2(-0.5, -0.4) : \n                            i == 3 ? vec2(0.43, -.3) :\n        \t\t\t\t\t\t\t vec2(-0.45, 0.015);\n        \n        float scale = i == 0 ? 0.02 : i == 1 ? 0.025 : i == 2 ? 0.04 : i == 3 ? 0.03 : 0.008;\n\n        vec2 leafOffset = \ti == 0 ? vec2(0.08, 0.0) :\n                            i == 1 ? vec2(0.11, 0.0) :\n                            i == 2 ? vec2(0.12, 0.0) :\n                            i == 3 ? vec2(0.11, 0.0) :\n                            \t\t vec2(0.05, 0.0);\n       \n        \n        col = mix(col, vec3(.10, .485, .105), circle( st - vec2(0.0, 0.01) - unitOffset, scale  ) );\n        col = mix(col, vec3(.10, .485, .105), circle( st - leafOffset - unitOffset, scale  ) );\n        col = mix(col, vec3(.10, .485, .105), circle( st + leafOffset - unitOffset, scale  ) );\n\n\n        col = mix(col, vec3(.66, .0, .0), circle( st - vec2(0.0, 0.01) - unitOffset - vec2(scale / 0.35, 0.0), scale / 18.5 ) );\n        col = mix(col, vec3(.66, .0, .0), circle( st - vec2(0.0, 0.01) - unitOffset - vec2(scale / -0.251, scale / 1.37), scale / 13.5 ) );\n        col = mix(col, vec3(.66, .0, .0), circle( st - vec2(0.0, 0.01) - unitOffset - vec2(scale / 0.275, scale / -.53), scale / 15.5 ) );                \n    }\n    \n    //\n    //\n    // darken everything\n    //\n    //  \n    col = mix(col, vec3(0.0, 0., 0.), 0.475);\n    \n    //\n    //\n    // rain - window layer\n    //\n    //   \n    pct = rainDrop(st - vec2(0.0, 0.5), 68451., 0.2, 5.5 );\n    col = mix(col, vec3(0.851, 0.851, 1.0), pct );    \n      \n    //\n    //\n    // periodic lightning strikes\n    //\n    //   \n     \n    pct = sin( (iTime * PI) / 1.025) * sin( sqrt( iTime * iTime * PI ) * 0.4 );\n    pct = clamp(pct, 0.0, 1.0);\n    \n    col = mix(col, vec3(1.0), pct);\n    \n    \n    //\n    //\n    // the window frame\n    //\n    //\n    \n    vec2 pos = st.yx * vec2(2.8, 8.8);\n    pos = noise(pos - vec2(0., 20.) ) * pos * 1.5;\n    pct = rect(st - vec2(0.0, 0.0), vec2(.48, 0.085) );   \n    col = mix(col, vec3(.545, .271, .075), pct );\n    pct *= lines(pos,0.35);\n    col = mix(col, vec3(.412, .204, .059), pct );\n    \n    \n    pos = st.yx * vec2(7.5, 3.8);\n    pos = noise(pos - vec2(0., 20.) ) * pos * 1.5;\n    pct = rect(st - vec2(0.0, 0.0), vec2(-.30, 0.48) );   \n    col = mix(col, vec3(.545, .271, .075), pct );\n    pct *= lines(pos,0.354);\n    col = mix(col, vec3(.412, .204, .059), pct );\n    \n  \n    pos = st.yx * vec2(4.45, 3.3);\n    pos = noise(pos) * pos;   \n    pct = rect(st - vec2(0.0, 0.46), vec2(-.40, .45) );   \n    col = mix(col, vec3(.545, .271, .075), pct );   \n    pct *= lines(pos,0.8);\n    col = mix(col, vec3(.412, .204, .059), pct );\n       \n    \n    pos = st.yx * vec2(10.2, 5.3);\n    pos = noise(pos - vec2(0., 20.) ) * pos * 1.5;\n    pct = rect(st - vec2(0.0, -0.46), vec2(-.40, .45) );   \n    col = mix(col, vec3(.545, .271, .075), pct );\n    pct *= lines(pos,0.4);\n    col = mix(col, vec3(.412, .204, .059), pct );\n    \n    \n    pos = st.yx * vec2(5.2, 3.5);\n    pos = noise(pos - vec2(0., 20.) ) * pos * 1.5;\n    pct = rect(st - vec2(0.85, 0.0), vec2(.45, 0.) );   \n    col = mix(col, vec3(.545, .271, .075), pct );\n    pct *= lines(pos,0.4);\n    col = mix(col, vec3(.412, .204, .059), pct );\n    \n    \n    pct = rect(st - vec2(-0.85, 0.0), vec2(.45, 0.) );   \n    col = mix(col, vec3(.545, .271, .075), pct );\n    pct *= lines(pos,0.4);\n    col = mix(col, vec3(.412, .204, .059), pct );\n   \n    \n    \n        \n    fragColor = vec4( col ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4syBWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 70, 70, 243], [245, 245, 284, 284, 448], [450, 450, 489, 489, 682], [685, 685, 717, 717, 775], [777, 861, 902, 902, 1236], [1238, 1328, 1408, 1408, 1620], [1622, 1622, 1649, 1649, 1765], [1768, 1858, 1880, 1880, 2198], [2200, 2334, 2368, 2368, 2524], [2526, 2526, 2583, 2583, 8868]], "test": "ok"}
{"id": "4t3XRf", "name": "Volumetric Smoke", "author": "blankensmith", "description": "Explode", "tags": ["volumetric"], "likes": 4, "viewed": 207, "published": "Public", "date": "1533256169", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#define Use_Perlin\n//#define Use_Value\n#define Use_Simplex\n#define MOD3 vec3(.1031,.11369,.13787)\nfloat hash31(vec3 p3)\n{\n\tp3  = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return -1.0 + 2.0 * fract((p3.x + p3.y) * p3.z);\n}\n\nfloat value_noise(vec3 p)\n{\n    vec3 pi = floor(p);\n    vec3 pf = p - pi;\n    \n    vec3 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    return \tmix(\n        \t\tmix(\n        \t\t\tmix(hash31(pi + vec3(0, 0, 0)), hash31(pi + vec3(1, 0, 0)), w.x),\n        \t\t\tmix(hash31(pi + vec3(0, 0, 1)), hash31(pi + vec3(1, 0, 1)), w.x), \n                    w.z),\n        \t\tmix(\n                    mix(hash31(pi + vec3(0, 1, 0)), hash31(pi + vec3(1, 1, 0)), w.x),\n        \t\t\tmix(hash31(pi + vec3(0, 1, 1)), hash31(pi + vec3(1, 1, 1)), w.x), \n                    w.z),\n        \t\tw.y);\n}\n\n\n\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nfloat simplex_noise(vec3 p)\n{\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n    \n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n    \n    // thx nikita: https://www.shadertoy.com/view/XsX3zB\n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n\tvec3 i1 = e * (1.0 - e.zxy);\n\tvec3 i2 = 1.0 - e.zxy * (1.0 - e);\n    \n    vec3 d1 = d0 - (i1 - 1.0 * K2);\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\n    \n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\n    \n    return dot(vec4(31.316), n);\n}\n\n\n\nfloat noise(vec3 p) {\n#ifdef Use_Value\n    return value_noise(p * 2.0);\n#elif defined Use_Simplex\n    return simplex_noise(p);\n#endif\n    return 0.0;\n}\n\nfloat noise_sum_abs(vec3 p)\n{\n    float f = 0.0;\n    p = p * 3.0;\n    f += 1.0000 * abs(noise(p)); p = 2.0 * p;\n    f += 0.5000 * abs(noise(p)); p = 2.0 * p;\n\tf += 0.2500 * abs(noise(p)); p = 2.0 * p;\n\tf += 0.1250 * abs(noise(p)); p = 2.0 * p;\n\tf += 0.0625 * abs(noise(p)); p = 2.0 * p;\n    \n    return f;\n}\n\nfloat noise_sum_abs_sin(vec3 p)\n{\n    float f = noise_sum_abs(p);\n    f = sin(f * 2.5 + p.x * 5.0 - 1.5);\n    \n    return f * f;\n}\n\n\nfloat volDensity ( vec3 p ) {\n\treturn noise_sum_abs_sin( vec3(p.x + -0.5*sin(iTime), p.y + 0.5*sin(iTime), p.z + iTime )) / max(4.0, pow(distance( p, vec3(0.0)), 5.0+ 8.0 * sin(iTime)));   \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n    \n    vec3 rayPos = vec3( 0.0, 0.0, -2.4 * sin(iTime) );\n    vec3 rayDir = normalize(vec3( uv, 1.0 ));\n    \n    vec3 color;\n    \n    float totalDensity = 0.0;\n    for (int i = 0; i < 30; i++ ) {\n\t\trayPos += rayDir * 0.03;\n        totalDensity += abs(volDensity( rayPos ));\n    }\n    if (totalDensity == 0.0) {\n        color = vec3( 1.0, 1.0, 1.0);\n    } else {\n        color = 1.8*vec3(uv, 1.5 + sin(iTime))/ totalDensity;\n    }\n    \n    fragColor = vec4(color, 1.0);\n    //fragColor = vec4(uv,0.5+0.05*sin(iTime),1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t3XRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[100, 100, 123, 123, 238], [240, 240, 267, 267, 800], [805, 805, 827, 827, 979], [981, 981, 1010, 1010, 1727], [1731, 1731, 1752, 1752, 1882], [1884, 1884, 1913, 1913, 2191], [2193, 2193, 2226, 2226, 2323], [2326, 2326, 2355, 2355, 2517], [2520, 2520, 2577, 2577, 3171]], "test": "ok"}
{"id": "4t3yDs", "name": "Another Petri Dish", "author": "momoro", "description": "WIP", "tags": ["voronoi"], "likes": 2, "viewed": 431, "published": "Public API", "date": "1534567338", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rotate(float angle) {\n    return mat2(cos(angle), -sin(angle),\n                sin(angle), cos(angle)\n    );\n}\n\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                    vec2(12.9898, 78.233)))*\n        \t\t\t\t 43758.5453123);\n}\n\nfloat random1 (float f) {\n    return random(vec2(f, -0.128));\n}\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// Commutative smooth minimum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk:\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\nfloat noise(float s) {\t\n    float i = floor(s);\n    float f = fract(s);\n    float n = mix(random(vec2(i, 0.)), \n                  random(vec2(i+1., 0.)), \n                  smoothstep(0.0, 1., f)); \n   \n    return n;\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat map(float value, float inMin, float inMax, float outMin, float outMax) {\n\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n\n} \n\n\n\nvec2 map(vec2 value, vec2 inMin, vec2 inMax, vec2 outMin, vec2 outMax) {\n\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n\n}\n\n\n\nvec3 map(vec3 value, vec3 inMin, vec3 inMax, vec3 outMin, vec3 outMax) {\n\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n\n}\n\n\n\nvec4 map(vec4 value, vec4 inMin, vec4 inMax, vec4 outMin, vec4 outMax) {\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 color;\n\n    for(float i=0.; i<2.; i++) {\n        vec2 st = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n        st = rotate(i * 1.128) * st;\n        \n\n        st *=6.440 * i/0.376;\n        st += vec2(-0.170,-0.240);\n\n        // Tile\n        vec2 i_st = floor(st);\n        vec2 f_st = fract(st);\n\n        float m_dist = 1.; // min distance\n\n        for(int j=-2; j<=2; j++) {\n            for(int i=-2; i<=2; i++) {\n\n                // Neighbor place in the grid\n                vec2 neighbor = vec2(float(i), float(j));\n\n                // Random position from current + neighbor place in the grid\n                vec2 offset = random2(i_st + neighbor);\n\n                // Animate the offset\n                offset = 0.5 + 0.5 * sin(iTime + 6.2831 * offset );\n\n                // Position of the cell\n                vec2 pos = neighbor + offset - f_st;\n\n                // Cell distance\n                float dist = length(pos);\n\n                // Metaball\n                m_dist = smin(m_dist, dist, 1.344);            \n            }\n        }\n\n\n        float f = m_dist;\n        f *= 5.;\n        float steps = 5.0;\n        f = ceil(f *steps) / steps;\n\n        float h = map(f, 0., 0.7, 0.628, 0.764);\n        h += (st.x + 0.376)/10. * (st.y/10. - 1.280) * 1.264;\n\n        float s = map(f, 0., 1., 0.852, 0.752);\n        float v = map(f, 0., 0.696, 0.280, 0.824);\n\n        color += hsv2rgb(vec3(h, s, v));\n        //color *= \tfwidth(f) * 3.640;\n\n        //color *= 2.896;\n\n        vec2 uv= st;\n        f = 0.;\n        uv.x *= noise(iTime - 20.);\n        uv.y *= noise(iTime);\n        f = 1.0 - length(uv);\n\n        vec2 uv2 = st;\n        uv2 += 0.308;\n        float q = map(1.0 - length(uv2), -0.496, 1., -0.552, 1.072);\n        q += 3.744;\n\n\n      //  color *= abs(vec3(f)) * 0.356 ;\n        color *= q * .2;\n    }\n    \n    fragColor = vec4(color, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t3yDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 115], [118, 118, 146, 146, 255], [257, 257, 282, 282, 320], [322, 322, 346, 346, 439], [441, 551, 589, 589, 666], [668, 668, 690, 690, 886], [888, 888, 910, 910, 1241], [1243, 1243, 1265, 1265, 1434], [1436, 1436, 1514, 1514, 1591], [1596, 1596, 1668, 1668, 1745], [1749, 1749, 1821, 1821, 1898], [1902, 1902, 1974, 1974, 2049], [2053, 2053, 2110, 2110, 3990]], "test": "ok"}
{"id": "4tccRj", "name": "iching", "author": "zwwgggbest", "description": "iching", "tags": ["iching"], "likes": 1, "viewed": 69, "published": "Public", "date": "1533107741", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI \t\t3.14159265359\n#define TWO_PI  6.28318530718\n#define NUM     8\n\n// Reference to\n// http://thndl.com/square-shaped-shaders.html\nfloat shape(vec2 _uv, float N)\n{\n    _uv = _uv * 2. - 1.;\n    float a = atan(_uv.x/_uv.y);\n    float r = TWO_PI/N;\n    \n\treturn abs(cos(floor(.5+a/r)*r-a)*length(_uv));\n}\n\nfloat box(vec2 _uv, vec2 _size)\n{\n\treturn shape(_uv*_size, 4.);\n}\n\nfloat iching(vec2 _uv, float _val)\n{\n    //hex\n    float s[NUM];\n    _val = floor(mod(_val, pow(2., float(NUM))));\t//need 6 bits\n    \n    for(int i = 0; i < NUM; i++)\n    {\n    \ts[i] = step(1., mod(_val, 2.));\n        _val = ceil(_val/2.);\n    }\n    \n    //iching\n\t_uv *= vec2(2., float(NUM));\n    \n    vec2 fpos = fract(_uv);\n    vec2 ipos = floor(_uv);\n    \n    if(ipos.x == 1.) fpos.x = 1.-fpos.x;\n    return mix(box(fpos, vec2(0.84,1.)),\n               box(fpos-vec2(0.03,0.),vec2(1.)), s[int(ipos.y)]);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    \n    uv *= 2.;\n    vec2 ipos = floor(uv);\n    uv = fract(uv);\n    float t = ipos.x + ipos.y * 2. + iTime * 2.;\n\n    float col = mix(iching(uv, t), iching(uv, t + 1.), fract(t));\n    col = smoothstep(.7, .701, col) + smoothstep(.7, .701, box(uv, vec2(1., 1.)));\n    \n    // Output to screen\n    fragColor = vec4(vec3(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tccRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 139, 171, 171, 309], [311, 311, 344, 344, 376], [378, 378, 414, 424, 887], [889, 889, 946, 996, 1368]], "test": "ok"}
{"id": "4tcyDX", "name": "Drops", "author": "momoro", "description": "Moving metaballs", "tags": ["bookofshaders"], "likes": 11, "viewed": 611, "published": "Public API", "date": "1534256237", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// based on Metaballs by @patriciogv\n// Thanks @shane for suggesting smin\n\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv.x *= iResolution.x / iResolution.y;\n    \n    vec2 st = uv;\n    vec3 color = vec3(.0);\n\n    // Scale\n    st *= 15.;\n\n    // Tile the space\n    vec2 i_st = floor(st);\n    vec2 f_st = fract(st);\n\n    float m_dist = 1.;  // minimun distance\n    for (int j= -2; j <= 2; j++ ) {\n        for (int i= -2; i <= 2; i++ ) {\n            // Neighbor place in the grid\n            vec2 neighbor = vec2(float(i),float(j));\n\n            // Random position from current + neighbor place in the grid\n            vec2 offset = random2(i_st + neighbor);\n\n            // Animate the offset\n            offset = 0.5 + 0.5*sin(iTime + 6.2831*offset);\n\n            // Position of the cell\n            vec2 pos = neighbor + offset - f_st;\n\n            // Cell distance\n            float dist = length(pos);\n\n            //m_dist = min(m_dist, dist);\n\n            // Metaball it!\n           // m_dist = min(m_dist, m_dist*dist);\n            m_dist = smin(m_dist, dist, .9);\n\n        }\n    }\n\n    // Draw cells (thanks @shane)\n    color = 1.0 - vec3(smoothstep(0.0, fwidth(m_dist) * 1.5, m_dist));\n    //color = vec3(m_dist);\n\n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tcyDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 75, 113, 113, 190], [192, 192, 216, 216, 309], [311, 311, 368, 368, 1547]], "test": "ok"}
{"id": "4tcyWl", "name": "Shiny Boi but shinier", "author": "JuliaPoo", "description": "Second version. Phong shading is now done incorrectly intentionally because it looks nicer", "tags": ["phong", "inaccurate"], "likes": 2, "viewed": 417, "published": "Public API", "date": "1534518070", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//sphere signed\nfloat SDsphere(vec3 pos, vec3 p, float r){\n    return distance(pos,p) - r;\n}\n\n//Mere signed\nfloat SDMere(vec3 pos, vec3 p, float r, vec2 T, float t){\n\treturn distance(pos,p) - r + 0.01*sin(t+(T.x*.5+T.y*.3)*.01)*(sin(100.*p.x +2.*t)+cos(70.*p.y+t)+sin(90.*p.z+t));\n}\n\n\nfloat SDscene(vec3 p, vec2 T, float t){\n    float d = SDMere(vec3(0,0,0),p,.2,T,t);\n    //d = min(d,SDsphere(L1,p,.1));\n    return d;\n}\n\n//SD normal\nvec3 SDn(vec3 p, vec2 T, float t){\n    float ep = 0.01;\n    return normalize(vec3(\n    SDscene(vec3(p.x+ep,p.y,p.z),T,t)-SDscene(vec3(p.x-ep,p.y,p.z),T,t),\n    SDscene(vec3(p.x,p.y+ep,p.z),T,t)-SDscene(vec3(p.x,p.y-ep,p.z),T,t),\n    SDscene(vec3(p.x,p.y,p.z+ep),T,t)-SDscene(vec3(p.x,p.y,p.z-ep),T,t)\n    ));\n}\n\n//lights\nvec3 i1s = vec3(1.);\nvec3 i1d = vec3(1.);\n\n//ambient lighting\nvec3 ia = .6*vec3(1.);\n\n//test material\nvec3 Tks = vec3(.5);\nvec3 Tkd = .5*vec3(.5);\nvec3 Tka = 2.*vec3(.5);\nfloat alp = 900.;\n\n//phong shading\nvec3 phong(vec3 p, vec3 L1, vec2 T, float t){\n    vec3 L1v = normalize(L1-p);\n    vec3 N = SDn(p,T,t);\n    vec3 R1 = normalize(reflect(L1v,N));\n    vec3 J,Q;\n    float temp = dot(L1v,N);\n    float temp2 = dot(R1,L1v);\n    J = Tkd*i1d*temp;\n    Q = Tks*i1d*pow(abs(dot(R1,L1v)),alp);\n    vec3 I = Tka*ia + J + Q;\n    return I;\n}\n\n//raytracing\nfloat end = 10.;\nfloat depth(vec3 ro, vec3 rd, vec2 T, float t){\n    float dist=0., d;\n    int max=1000;\n    float ep = 0.001;\n    for (int i=0; i<max; i++){\n        d = SDscene(ro + dist*rd, T,t);\n    if (d<ep){\n        return dist;\n    }\n    dist += d;\n    if (dist > end){\n        return end;\n    }\n  }\n}\n\nvec2 T = vec2(12.5);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    T = 25.*(iMouse.xy)/iResolution.xy;\n    float t = .5*iTime;\n\n\n    //lights (t dependent position) \n\tvec3 L1 = vec3(3.*sin(2.5*t),3.*cos(t),3.*sin(t));\n\n    //initialise screen\n    vec2 uv = (fragCoord/iResolution.xy-.5)*.6 + (T-12.5)*0.002;\n    uv.x *= iResolution.x/iResolution.y;\n   \t\n    //Camera setup\n    float zoom = 0.3;\n    float k = .2;\n    vec3 ro = .35*vec3(cos(k*T.x)*sin(k*T.y),sin(k*T.x)*sin(k*T.y),cos(k*T.y));\n    vec3 lookat = vec3(0,0,0);\n    vec3 fw = normalize(lookat - ro);\n    vec3 r = normalize(cross(vec3(0,1.,0), fw));\n    vec3 up = normalize(cross(fw,r));\n    vec3 scrC = ro + zoom*fw;\n    vec3 scrP = scrC + uv.x*r + uv.y*up;\n    vec3 rd = scrP - ro;\n    vec4 Color;\n    float d = depth(ro,rd,T,t);\n    if (d<end){\n    \tvec3 p = d*rd + ro;\n    \tColor = vec4((5.*vec3(-p.z,p.y,-p.x)+1.*vec3(1.5,1,1.5))*phong(p,L1,T,t),1.);\n    }\n    else{Color = 2.*vec4(.9,.8,.8,1.);}\n\n    //vigillant\n    Color *= sqrt(.65-0.7*length(uv));\n    fragColor = Color;\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tcyWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 16, 58, 58, 92], [94, 108, 165, 165, 282], [285, 285, 324, 324, 420], [422, 434, 468, 468, 744], [945, 961, 1006, 1006, 1288], [1320, 1320, 1367, 1367, 1610], [1634, 1634, 1690, 1690, 2673]], "test": "error"}
{"id": "4tdcWn", "name": "[SH18]ForgottenLand", "author": "EvilRyu", "description": "Only strange creatures left on this land, but all with human parts :)", "tags": ["eye", "spider", "hand", "hand", "human", "sh18", "breast"], "likes": 48, "viewed": 2108, "published": "Public API", "date": "1533476403", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by EvilRyu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// 2018 shadertoy competition entry.\n//\n// 75 seconds for the whole animation\n// \n\n#define PI 3.1415926535\n\n\nfloat hash11(float a)\n{\n    return fract(sin(a)*10403.9);\n}\n\n\nfloat hash21(vec2 uv)\n{\n    float f=uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\n\n\nvec2 hash22(vec2 uv)\n{\n    float f=uv.x + uv.y * 37.0;\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\n\n\nvec2 hash12(float f)\n{\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\n\n\nfloat hash31(vec3 p)\n{ \n    return fract(sin(dot(p, vec3(127.1, 311.7, 74.7)))*43758.5453); \n}\n\n\nfloat noise(vec2 x)\n{\n    vec2 p=floor(x);\n    vec2 f=fract(x);\n    f=f*f*(3.0-2.0*f);\n    float n=p.x + p.y*57.0;\n    return mix(mix(hash11(n+0.0), hash11(n+1.0),f.x),\n               mix(hash11(n+57.0), hash11(n+58.0),f.x),f.y);\n}\nconst mat2 m=mat2(0.8,0.6,-0.6,0.8);\n\n\nfloat fbm(vec2 p)\n{\n    float f=0.0;\n    f+=0.50000*noise(p); p=m*p*2.02;\n    f+=0.25000*noise(p); p=m*p*2.03;\n    f+=0.12500*noise(p); p=m*p*2.01;\n    f+=0.06250*noise(p); p=m*p*2.04;\n    f+=0.03125*noise(p);\n    return f/0.984375;\n}\n\n\nfloat smin(float a, float b, float k)\n{\n    float h=clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\n\nfloat smax(float a, float b, float k)\n{\n    return smin(a, b, -k);\n}\n\n\nvec3 rot_x(vec3 p, float t)\n{\n    float co=cos(t);\n    float si=sin(t);\n    p.yz=mat2(co,-si,si,co)*p.yz;\n    return p;\n}\n\nvec3 rot_y(vec3 p, float t)\n{\n    float co = cos(t);\n    float si = sin(t);\n    p.xz = mat2(co,-si,si,co)*p.xz;\n    return p;\n}\n\nvec3 rot_z(vec3 p, float t)\n{\n    float co=cos(t);\n    float si=sin(t);\n    p.xy=mat2(co,-si,si,co)*p.xy;\n    return p;\n}\n\n\nfloat mixp(float f0, float f1, float a)\n{\n    return mix(f0, f1, a*a*(3.0-2.0*a));\n}\n\n\nfloat sphere(vec3 p,float r)\n{\n    return length(p)-r;\n}\n\n\nfloat ellipsoid(vec3 p, vec3 c, vec3 r)\n{\n    p-=c;\n    float d=length(p/r)-.5;\n    return d*min(r.x,min(r.y,r.z));\n}\n\n\nfloat box(vec3 p, vec3 r)\n{\n  vec3 d=abs(p) - r;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n\nfloat rbox(vec3 p, vec3 b, float r)\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\n\nvec2 line2(vec3 a, vec3 b, vec3 p, float ll)\n{\n    vec3 pa=p-a;\n    vec3 ba=b-a;\n    float h=clamp(dot(pa,ba)*ll, 0.0, 1.0);\n    \n    return vec2(length(pa-ba*h), h);\n}\n\n\nvec2 line(vec3 pos, in vec3 a, in vec3 b)\n{\n    vec3 pa=pos-a;\n    vec3 ba=b-a;\n   \n    float h=clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n    \n    return vec2(length(pa-h*ba), h);\n}\n\n\nvec3 solve(vec3 p, float l1, float l2, vec3 dir)\n{\n    vec3 q=p*(0.5 + 0.5*(l1*l1-l2*l2)/dot(p,p));\n    \n    float s=l1*l1 - dot(q,q);\n    s=max(s, 0.0);\n    q += sqrt(s)*normalize(cross(p,dir));\n    \n    return q;\n\n}\n\n\nvec3 solve(vec3 a, vec3 b, float l1, float l2, vec3 dir)\n{\n    return a + solve(b-a, l1, l2, dir);\n}\n\n\nvec4 texcube(sampler2D sam, vec3 p, vec3 n)\n{\n    vec4 p1=texture(sam, p.xy);\n    vec4 p2=texture(sam, p.xz);\n    vec4 p3=texture(sam, p.yz);\n    return p1*abs(n.z)+p2*abs(n.y)+p3*abs(n.x);\n}\n\n\nfloat bump(vec3 p, vec3 n)\n{\n    return dot(texcube(iChannel0, 0.25*p, n).xyz, vec3(0.299, 0.587, 0.114)); \n}\n\n\nvec3 bump_mapping(vec3 p, vec3 n, float weight)\n{\n    vec2 e=vec2(2./iResolution.y, 0); \n    vec3 g=vec3(bump(p-e.xyy, n)-bump(p+e.xyy, n),\n                bump(p-e.yxy, n)-bump(p+e.yxy, n),\n                bump(p-e.yyx, n)-bump(p+e.yyx, n))/(e.x*2.);  \n    g=(g-n*dot(g,n));\n    return normalize(n+g*weight);\n}\n\nstruct Spider\n{\n    vec3 pos;\n    vec3 forward;\n    vec3 knees[6];\n    vec3 feet[6];\n};\n\n    \nSpider spider;\n\n#define MAT_AB 0.0\n#define MAT_LEGS 1.0\n#define MAT_BODY 2.0\n#define MAT_EYES 3.0\n#define MAT_SPIDER_EYEHOLE 4.\n#define MAT_OTHERS 5.0\n\n#define BREATH (0.08*sin(4.*iTime))\n#define BREATH_FREQ 4.0\n#define SPIDER_EYEPOS vec3(0.,2.75,0.45)\n\nvec3 get_spider_coord(vec3 p)\n{\n    vec3 u=vec3(1.0,0.0,0.0);\n    vec3 v=normalize(cross(spider.forward,u));\n\n    return vec3(p.x, dot(v,p), dot(spider.forward,p));\n}\n\n// from spider coord\nvec3 get_world_coord(vec3 p)\n{\n    vec3 u=vec3(1.,0.,0.);\n    vec3 v=normalize(cross(spider.forward,u));\n    vec3 f=spider.forward;\n    return vec3(u*p.x+v*p.y+f*p.z);\n}\n\nvec2 body(vec3 q)\n{    \n    float matid=MAT_BODY;\n    // body\n    float d0=rbox(q+vec3(0.,-1.3,-0.4),vec3(0.02+0.3*sin(q.y-.2),0.8,0.02+0.1*sin(q.y*1.5-1.2)),0.1);\n    \n    // breast\n    vec3 q1=rot_x(q,0.6);\n    q1.x=abs(q1.x)-.3;\n    q1.y+=0.06*sin(BREATH_FREQ*iTime-2.);\n    float d1=ellipsoid(q1,vec3(0.,1.8,-0.4),vec3(.4,.3,.5));\n    if(d1<d0)matid=MAT_BODY;\n    d0=smin(d0,d1,0.3);\n    \n    // neck\n    d1=line(q,vec3(0.,2.1,0.4),vec3(0.,2.4,0.4)).x-.1;\n    if(d1<d0)matid=MAT_BODY;\n    d0=smin(d0,d1,0.2);\n    \n    // head\n    d1=ellipsoid(q,vec3(0.,2.7,.4),vec3(0.4,0.55,0.4));\n    if(d1<d0)matid=MAT_BODY;\n    d0=smin(d0,d1,0.05);\n    \n    // abs\n    q1=q+vec3(0.,-.75,-.55);\n    q1.xy=vec2(abs(q1.x)-0.1,abs(q1.y)-0.19);\n    d1=ellipsoid(q1, vec3(0.), vec3(0.05,0.08,0.07));\n    if(d1<d0)matid=MAT_LEGS;\n    d0=smin(d0,d1,0.2);\n  \n\n    // arms\n    q1=vec3(abs(q.x)-.4,q.y+0.02*sin(BREATH_FREQ*iTime-1.),q.z);\n    vec2 hh=line(q1,vec3(0.,2.1,0.4), vec3(.7,1.5,0.));\n    d1=hh.x-mix(0.14,0.02,hh.y) + 0.05*sin(6.2831*hh.y);\n    if(d1<d0)matid=MAT_BODY;\n    d0=smin(d0, d1, 0.15);\n    \n    hh=line(q1,vec3(.7,1.5,0.), vec3(1.5,1.,0.9));\n    d1=hh.x-mix(0.06,0.02,hh.y) + 0.01*cos(2.0*6.2831*hh.y);\n    if(d1<d0)matid=MAT_LEGS;\n    d0=smin(d0, d1,0.1);\n    \n    q1=vec3(abs(q.x)-.02,abs(q.y-2.7)-.1,q.z);\n    hh=line(q1,vec3(0.,0.,0.3), vec3(0.5,.3,-.5));\n    d1=hh.x-mix(0.06,0.02,hh.y) + 0.01*cos(2.0*6.2831*hh.y);\n    if(d1<d0)matid=MAT_BODY;\n    d0=smin(d0, d1,0.3);\n    \n    // nipples\n    /*q1=q;q1.x=abs(q1.x)-0.42;q1.yz+=0.04*sin(2.*iTime-2.);\n    float d11=sphere(q1-vec3(0.,1.65,0.84),0.04);\n    if(d11<d0){d0=d11;matid=MAT_LEGS;}*/\n    return vec2(d0,matid);\n}\n\nfloat legs(in vec3 p, in vec3 mvv, in vec3 muu)\n{\n    float d0=100.;\n    for(int i=0; i<min(0,iFrame)+6; i++)\n    {\n        float s=-sign(float(i)-2.5);\n        float h=mod(float(i), 3.0)/3.0;\n        \n        vec3 bas=spider.pos - 0.8*mvv*(1.0-h) + muu*s*0.8*(1.-h) + spider.forward*.8*(h-0.33) ;\n\n        vec3 n1=spider.knees[i];\n        vec2 hh=line2(bas, n1, p, 1./(2.5*2.5));\n        d0=smin(d0, hh.x-mix(0.15,0.1,hh.y) + 0.05*sin(6.2831*hh.y), 0.1);\n        hh=line2(n1, spider.feet[i], p, 1./((2.+(1.-h))*(2.+(1.-h))));\n        d0=smin(d0, hh.x-mix(0.08,0.02,hh.y) + 0.01*cos(2.0*6.2831*hh.y),0.1);\n    }\n    return d0;\n}\n\nvec2 dspider(in vec3 p)\n{\n    p*=0.14;\n    vec3 q=p - spider.pos;\n    \n    if(dot(q,q)>72.0) return vec2(32.0);\n    \n    vec3 muu=vec3(1.0,0.0,0.0);\n    vec3 mvv=normalize(cross(spider.forward,muu));\n    q=vec3(q.x, dot(mvv,q), dot(spider.forward,q));    \n    q.y+=BREATH;    \n    float matid=MAT_LEGS;\n       \n    float d0=100.;\n    \n    d0=legs(p,mvv,muu);\n    \n    // ab\n    vec3 q1=rot_x(q,-0.7);\n    float d1=ellipsoid(q1, vec3(0.), vec3(1.5,1.5,2.));\n    if(d1<d0)matid=MAT_AB;\n    d0=smin(d0,d1,0.2);\n    //ab\n    float ab=(0.5 + 0.5*cos(4.0*pow(0.5-0.5*q.z,2.0)))*(0.5+0.5*q.z);\n    d1=ellipsoid(q, vec3(0.,-0.6,-1.6),vec3(2.3,2.3,4.))- 0.1*ab;\n    d1+=0.03*sin(10.*q.z);    \n    if(d1<d0)matid=MAT_AB;\n    d0=smin(d0,d1,0.2);\n    \n    vec2 res=body(q);\n    if(res.x<d0)matid=res.y;\n    d0=smin(d0,res.x,0.2);\n    \n    // eyes\n    d1=ellipsoid(q,vec3(0.,2.84,0.65),vec3(0.19,0.55,0.3));\n    if(-d1>d0){d0=-d1;matid=MAT_SPIDER_EYEHOLE;}\n    \n    d1=sphere(q-SPIDER_EYEPOS, 0.15);\n    if(d1<d0){d0=d1;matid=MAT_EYES;}\n\n    return vec2(d0/.14, matid);\n}\n\n\n#define MAT_HAND 0.\n#define MAT_LAND 1.\n#define MAT_EYE 2.\n#define MAT_EYEHOLE 3.\n\n\n#define EYEPOS vec3(0.3,3.4,0.2)\nfloat eyeball(vec3 p)\n{\n    float d0=sphere(p-EYEPOS, 1.);\n    return d0;\n}\n\n\nvec2 hand(vec3 p)\n{\n    float matid=MAT_HAND;\n    // palm\n    float d0=rbox(p-vec3(0.,0.,0.1), vec3(0.6,1.5,0.05), 1.); //line(p, vec3(0.0,0.,0.0), vec3(0.0,1.0,0.0)).x-1.;\n    vec3 q=rot_z(p,-0.1);\n    float d1=rbox(q-vec3(0.,3.,0.), vec3(1.+.5*sin(12.+.55*p.y),1.7,0.01), .8+.15*sin(p.y));\n    d0=smin(d0,d1,2.);\n    \n    // thumb\n    vec2 hh=line(p,vec3(-1.5,1.,0.0), .85*vec3(-4.,3.,1.));\n    d1=hh.x-.9+0.35*sin(hh.y);\n    d0=smin(d0,d1,.7);\n    hh=line(p,vec3(-3.5,2.6,0.9),vec3(-3.,3.4,1.8));\n    d1=hh.x-.6+.2*sin(hh.y);\n    d0=smin(d0,d1,.1);\n    \n    // center\n    d1=sphere(p-vec3(0.4,3.3,2.5),1.7);\n    d0=smax(d0,-d1,.7);\n    \n    // fingers\n    hh=line(p,vec3(-1.3,4.8,-0.2),.74*vec3(-2.8,8.,-1.));\n    d1=hh.x-.7+.3*sin(hh.y);\n    d0=smin(d0,d1,.3);\n    hh=line(p-vec3(0.4,-0.6,0.6),vec3(-2.4,6.2,-1.4),.96*vec3(-2.7,7.6,-.8));\n    d1=hh.x-.5+.1*sin(hh.y);\n    d0=smin(d0,d1,.1);\n    hh=line(p,vec3(-2.2,6.8,0.),.95*vec3(-2.2,7.4,0.6));\n    d1=hh.x-.4+.05*sin(hh.y);\n    d0=smin(d0,d1,.1);\n    \n    hh=line(p,vec3(-0.1,4.8,-0.2),.85*vec3(-0.3,8.,-1.));\n    d1=hh.x-.66+.2*sin(hh.y);\n    d0=smin(d0,d1,.3);\n    hh=line(p,vec3(-0.3,6.9,-1.),.98*vec3(-0.3,7.9,0.25));\n    d1=hh.x-.5+.1*sin(hh.y);\n    d0=smin(d0,d1,.1);\n    hh=line(p,vec3(-0.3,7.6,0.4),.97*vec3(-0.3,7.7,1.));\n    d1=hh.x-.4+.05*sin(hh.y);\n    d0=smin(d0,d1,.1);\n    \n    hh=line(p,vec3(1.,4.8,-0.2),.84*vec3(1.5,8.,-1.));\n    d1=hh.x-.6+.2*sin(hh.y);\n    d0=smin(d0,d1,.3);\n    hh=line(p,vec3(1.25,6.5,-0.9),.93*vec3(1.5,7.9,0.25));\n    d1=hh.x-.48+.1*sin(hh.y);\n    d0=smin(d0,d1,.1);\n    hh=line(p,vec3(1.4,7.3,0.1),vec3(1.3,7.,.9));\n    d1=hh.x-.4+.05*sin(hh.y);\n    d0=smin(d0,d1,.1);\n    \n    hh=line(p,vec3(2.2,4.8,-0.2),.7*vec3(3.8,8.,-1.));\n    d1=hh.x-.5+.1*sin(hh.y);\n    d0=smin(d0,d1,.25);\n    hh=line(p,vec3(2.73,5.6,-.8),.98*vec3(3.,6.4,0.));\n    d1=hh.x-.45+.1*sin(hh.y);\n    d0=smin(d0,d1,.1);\n    hh=line(p,vec3(2.88,6.3,0.1),.97*vec3(2.8,6.4,.6));\n    d1=hh.x-.4+.05*sin(hh.y);\n    d0=smin(d0,d1,.1);\n    \n    \n    // eye\n    d1=ellipsoid(p,vec3(0.3,3.6,1.2),vec3(3.6,1.2+cos(p.x-.3),2.2));//sphere(q1, 0.055);\n    if(-d1>d0){matid=MAT_EYEHOLE;} \n    d0=smax(d0,-d1,0.2);\n    d1=eyeball(p);\n    if(d1<d0){d0=d1;matid=MAT_EYE;}\n    \n   /* q=p-vec3(-0.26,7.9,1.);\n    d1=box(q,vec3(.25,.05-0.03*sin(q.x*10.-8.2),.3-0.05*sin(q.x*10.-8.2)));\n    d0=min(d0,d1);*/\n    return vec2(d0,matid);\n    \n}\n\n\nvec2 dead_land(vec3 p)\n{    \n    vec2 res=hand(p);\n    float d0=res.x+.05*texture(iChannel0,p.xy*.05).x;\n    float matid=res.y;\n    \n    float bump=textureLod(iChannel1,p.xz/16.+p.xy/80.,0.0).x;\n    float d1=p.y+4.-bump+1.9*cos(p.x*0.15+1.8+cos(p.z*0.15));\n    if(d1<d0){d0=d1;matid=MAT_LAND;}\n    d0=smin(d0,p.y+4.-0.15*bump, 0.5);\n    \n    \n    return vec2(d0,matid);\n}\n\nfloat map(vec3 p)\n{\n    float d=hand(p).x;\n    d=min(d,dspider(p).x);\n    return d;  \n}\n\nvec3 get_spider_normal(vec3 p)\n{\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*dspider(p+0.001*e).x;\n    }\n    return normalize(n);\n}\n\nvec3 get_dead_land_normal(vec3 p)\n{\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*dead_land(p+0.001*e).x;\n    }\n    return normalize(n);\n}\n\n\n\n// marciot's \"The Mandel Grim\"  \n// https://www.shadertoy.com/view/4tGXWd\nvec3 get_eye_material(vec2 uv, bool bloody, float iris)\n{   \n    float r=uv.y/iris;\n    float a=uv.x*PI*2.0;\n    vec2 p=vec2(r*cos(a), r*sin(a));\n    vec3 col=vec3(1.);\n\n    if(r<.7) \n    {\n        col=vec3(0.9, 0.4, 0.2)*.5;\n\n        float f=fbm(5.0*p);\n        col=mix(col, vec3(0.9,0.8,0.3)*0.2, f);\n        col=mix(col, vec3(0.9,0.5,0.2), 1.0-smoothstep(0.2,0.6,r));\n\n        a += 0.05*fbm(20.0*p);\n        f=smoothstep(0.3, 1.0, fbm(vec2(6.2*r, 20.0*a)));\n        col=mix(col, vec3(0.), f);\n\n        f=smoothstep(0.4, 0.9, fbm(vec2(10.0*r, 15.0*a)));\n        col *= 1.0 - 0.5*f;\n\n        f=smoothstep(0.6, 0.8, r);\n        col *= 1.0 - 0.5*f;\n\n        f=smoothstep(0.2, 0.25, r);\n        col *= f;\n\n        f=smoothstep(0.75, 0.8, r);\n        col=mix(col, vec3(1.0), f);\n    }\n    \n    if(r>.67 && bloody)\n    {\n        a+=0.15*fbm(10.0*p);\n        float f=smoothstep(0.25, .8, fbm(vec2(0.9*r, 20.0*a)));\n        col-=vec3(.0,1.0,1.0)*f;\n    }\n\n    return col;\n}\n\nvec4 get_spider_material(vec3 p, vec3 n)\n{\n    vec2 res=dspider(p);\n    vec3 material=vec3(1.0);\n    p*=0.14;\n    vec3 q=get_spider_coord(p-spider.pos);\n\n    if(res.y<MAT_LEGS)\n    {\n        float t=mod(q.z, 0.7); \n        material= vec3(0.01)+vec3(.3, 0.01, 0.01)*\n                    pow(smoothstep(0.0, 0.1, t) * smoothstep(0.285, .28, t), 40.0);\n       \n        clamp(material, 0.0, 1.0);\n    }\n    else if(res.y<MAT_BODY)\n    {\n        material=vec3(0.01);\n    }\n    else if(res.y<MAT_EYES)\n    {\n        q.y+=BREATH;        \n        material=mix(vec3(0.01), vec3(1.55,.7333,.6)*.75,\n                     smoothstep(1.,1.75,q.y));\n    }\n    else if(res.y<MAT_SPIDER_EYEHOLE)\n    {\n        float t=mod(q.z, 0.508);\n\n        vec3 p0=q-SPIDER_EYEPOS;\n        p0.y+=BREATH;\n        vec2 uv=vec2(atan(p0.y,p0.x)/(2.*PI), \n                    acos(p0.z/length(p0))/PI);\n        material=get_eye_material(uv, false, 0.4);\n        \n    }\n    else\n    {\n        material=texture(iChannel0, q.xy).xyz;    \n        \n    }\n    return vec4(material,res.y);\n}\n\n\nvec4 get_dead_land_material(vec3 p, vec3 n)\n{\n    vec2 res=dead_land(p);\n    vec3 material=vec3(0.);\n    if(res.y<MAT_LAND)\n    {\n        material=vec3(1.55,.7333,.6)*.75;\n    }\n    else if(res.y<MAT_EYE)\n    {\n        material=texture(iChannel0, p.xz*0.1).xyz;\n    }\n    else if(res.y<MAT_EYEHOLE)\n    {\n    \tp=rot_y(p,0.2*(floor(sin(iTime*2.+sin(iTime)+17.))*2.+1.));\n        \n        vec3 p0=p-EYEPOS;\n        vec2 uv=vec2(atan(p0.y,p0.x)/(2.*PI), \n                    acos(p0.z/length(p0))/PI);\n        material=get_eye_material(uv, true, .2);\n    }\n    else\n    {\n        material=texture(iChannel0, p.xy).xyz;\n        material-=vec3(0.,.24,.2);\n        material=clamp(material,0.,1.);\n    }\n    return vec4(material, res.y);\n}\n\nfloat shadow(vec3 ro, vec3 rd)\n{\n    float res=1.0;\n    float t=0.02;\n    float h;\n    \n    for (int i=0; i < min(0,iFrame)+8; i++)\n    {\n        h=map(ro + rd*t);\n        res=min(6.0*h / t, res);\n        t += h;\n    }\n    return max(res, 0.0);\n}\n\nfloat get_ao(vec3 p, vec3 n)\n{\n    float r=0.0, w=1.0, d;\n    for(float i=1.; i<float(min(0,iFrame))+5.0+1.1; i++)\n    {\n        d=i/5.0;\n        r += w*(d - dead_land(p + n*d).x);\n        w *= 0.5;\n    }\n    return 1.0-clamp(r,0.0,1.0);\n}\n\nconst vec3 moon_dir=normalize(vec3(-0.1,0.05,0.4));\n\n\nvec3 lighting_spider(vec3 ro, vec3 rd, vec3 pos, vec3 nor)\n{\n    vec3 l0dir=moon_dir;\n    vec3 l0col=vec3(1.);\n    vec4 ma=get_spider_material(pos, nor);\n    \n    if(ma.w<MAT_BODY)\n    \tnor=bump_mapping(pos, nor, 0.03);\n    \n    float diff=4.0*max(0.,dot(l0dir,nor));\n    float back=0.5*max(0.,dot(-l0dir,nor));\n    float sky=max(0.,dot(vec3(0,1,0),nor));\n    float boun=0.5*max(0.,dot(vec3(0,-1,0),nor));\n    float spec=max(0.0, pow(clamp(dot(l0dir, reflect(rd, nor)), 0.0, 1.0), 64.0));\n    \n    vec3 col=((l0col*diff+l0col*back)+\n              3.*vec3(0.0,0.05,0.1)*sky+\n              3.*vec3(0.0,0.05,0.1)*boun)+vec3(1.)*spec;\n\n    col*=ma.xyz*0.2;\n    \n    col+=(ma.w<MAT_BODY?1.0:0.)*spec;\n    return col;\n}\n\n\nfloat density_hand(vec3 p, float ms, vec3 n) \n{\n    return hand(p+n*ms).x/ms;\n}\n\n\nvec3 lighting_dead_land(vec3 ro, vec3 rd, vec3 pos, vec3 nor)\n{\n    vec3 l0dir=moon_dir;\n    vec3 l0col=vec3(1.);\n    \n    vec4 ma=get_dead_land_material(pos, nor);\n    //nor=bump_mapping(pos, nor, 0.03);\n    \n    float shad=shadow(pos+0.1*nor,l0dir);\n    float ao=get_ao(pos,nor);\n    float diff=4.0*max(0.,dot(l0dir,nor));\n    float back=0.2*max(0.,dot(-l0dir,nor));\n    float sky=max(0.,dot(vec3(0,1,0),nor));\n    float boun=0.5*max(0.,dot(vec3(0,-1,0),nor));\n    float spec=max(0.0, pow(clamp(dot(l0dir, reflect(rd, nor)), 0.0, 1.0), 16.0));\n    float sca=1.-density_hand(pos,1.,nor);\n\n    \n    vec3 col=((l0col*diff+l0col*back)*shad*ao*ao+\n              3.*vec3(0.0,0.05,0.1)*sky+\n              3.*vec3(0.0,0.05,0.1)*boun);\n    if(ma.w<MAT_EYEHOLE)\n        col+=spec;\n    if(ma.w<MAT_LAND)\n        col+=.7*vec3(0.3,0.1,0.1)*sca;\n    col*=ma.xyz;\n    col*=0.2;\n\n    return col;\n}\n\n\nvec4 scene_spider(vec3 ro, vec3 rd)\n{    \n    float t=0.1;\n    for(int i=0;i<min(0,iFrame)+128;++i)    \n    {\n        float d=dspider(ro+rd*t).x;\n        if(d<0.005||t>100.0)\n            break;\n        \n        t+=d;\n    }\n        \n    \n    vec3 col=vec3(1.);\n    if(t<100.)\n    {\n        vec3 pos=ro+t*rd;\n        vec3 nor=get_spider_normal(pos);\n        col=lighting_spider(ro,rd,pos,nor);\n    }\n    return vec4(col,t);\n}\n\n\nvec4 scene_dead_land(vec3 ro, vec3 rd)\n{\n    float t=0.1;\n    for(int i=0;i<min(0,iFrame)+128;++i)    \n    {\n        float d=dead_land(ro+rd*t).x;\n        if(d<0.005||t>100.0)\n            break;\n        \n        t+=d;\n    }\n            \n    vec3 col=vec3(0.);\n\n    \n    if(t<100.)\n    {\n        vec3 pos=ro+t*rd;\n        vec3 nor=get_dead_land_normal(pos);\n        col=lighting_dead_land(ro,rd,pos,nor);\n    }\n    col=mix(col,vec3(0.0,0.05,0.1)*.7, 1.0-exp(-0.00025*t*t));\n    \n    return vec4(col,t);\n}\n\n\nfloat terrain(vec2 p) \n{\n    float w=0.;\n    float s=1.;\n    p.x*=20.;\n    w+=sin(p.x*.3521)*4.;\n    for (int i=0; i<min(0,iFrame)+5; i++) \n    {\n        p.x*=1.53562;\n        p.x+=7.56248;\n        w+=sin(p.x)*s;      \n        s*=.5;\n    }\n    w=w*.5+.5;\n    return step(0.,p.y-w*.02+.07);\n}\n\nvec3 render_terrian(vec3 ro, vec3 rd, vec3 col)\n{\n    col=mix(col,vec3(0.0,0.05,0.1)*0.7, 1.-terrain(rd.xy));\n    return col;\n}\n\n// Shane's \"3D cellular tiling\"\n// https://www.shadertoy.com/view/ld3Szs\nfloat tri3(in vec3 p)\n{\n    p=cos(p*2.+(cos(p.yzx)+1.+iTime*4.)*1.57);\n    return dot(p, vec3(0.1666))+0.5;\n}\n\nfloat triangle_noise(vec3 p)\n{\n    const mat3 m=mat3(0.25, -0.866, 0.433, \n                        0.9665, 0.25, -0.2455127, \n                        -0.058, 0.433, 0.899519)*1.5;\n  \n    float res=0.;\n\n    float t=tri3(p*PI);\n    p+=(t-iTime*0.25);\n    p=m*p;\n    res+=t;\n    \n    t=tri3(p*PI); \n    p+=(t-iTime*0.25)*0.7071;\n    p=m*p;\n    res+=t*0.7071;\n\n    t=tri3(p*PI);\n    res+=t*0.5;\n     \n    return res/2.2071;\n}\n\n\nfloat get_mist(in vec3 ro, in vec3 rd, in vec3 lp, in float t){\n\n    float mist=0.;\n    ro+=rd*t/8.;\n    \n    for (int i=0; i<min(0,iFrame)+4; i++)\n    {\n        mist+=triangle_noise(ro/4.)*(1.-float(i)*.2);\n        ro+=rd*t/4.;\n    }\n    return clamp(mist/2.+hash31(ro)*0.1-0.05, 0., 1.);\n}\n\nvec3 render_sky(vec3 ro, vec3 rd)\n{\n    vec3 sky=vec3(0.0,0.05,0.1);\n   \n    vec3 clouds=vec3(0.0);\n    float s=.3;\n    for (int i=0; i < min(0,iFrame)+3; ++i) \n    {\n        clouds+=smoothstep(0.5,0.2,fbm(s*rd.xz/(rd.y+2./iResolution.x)+s*iTime*0.5));\n        s *= 1.5;\n    }\n    \n    vec3 col=sky + .35*clouds*max(0.0, rd.y);\n    vec3 moon_col=pow(vec3(0.659,0.765,0.878),vec3(1.2));\n    col+=moon_col*smoothstep(0.3,0.36,pow(max(dot(moon_dir, rd), 0.0), 32.0));\n    vec2 moon_pos=rd.xy/rd.z - moon_dir.xy/moon_dir.z;\n    col=mix(col, moon_col*fbm(10.*moon_pos-2.), max(0.,rd.z)*smoothstep(0.37, 0.1, length(moon_pos)));\n    \n    return col;\n}\n\nvec3 tonemap(vec3 x) \n{\n    const float a=2.51;\n    const float b=0.03;\n    const float c=2.43;\n    const float d=0.59;\n    const float e=0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\n// time slot of each scene\n#define SCENE_1 5.  // moon\n#define SCENE_2 10. // mist\n#define SCENE_3 33. // spider passes\n#define SCENE_4 45. // eye of the hand\n#define SCENE_5 65. // spider alone\n\nvoid get_camera(out vec3 ro, out vec3 ta)\n{\n    // center: x_rot=-1.5, y_rot=0.01;\n    float x_rot=-1.3, y_rot=0.01;\n    \n    if(iTime<SCENE_3 || iTime>SCENE_5)\n    {\n        x_rot=-1.3, y_rot=0.05;\n        ro=vec3(0.,4.,0.)+vec3(cos(y_rot)*cos(x_rot),sin(y_rot),cos(y_rot)*sin(x_rot))*20.35;\n        ta=vec3(0.0,1.,0.);\n    }\n    else if(iTime<SCENE_4)\n    {\n        x_rot=-1.3+2.8*smoothstep(SCENE_3, SCENE_3+5., iTime), y_rot=0.05;\n        ro=vec3(0.,4.0,-1.5*smoothstep(SCENE_3, SCENE_4, iTime))+vec3(cos(y_rot)*cos(x_rot),sin(y_rot),cos(y_rot)*sin(x_rot))*20.35;\n        ta=vec3(0.0,1.,0.);\n    }\n    else if(iTime<SCENE_5)\n    {\n        x_rot=1.4;y_rot=0.3;\n        ro=spider.pos+vec3(10.,25.,40.);//+vec3(cos(y_rot)*cos(x_rot),sin(y_rot),cos(y_rot)*sin(x_rot))*45.;\n        ta=spider.pos+vec3(-10.,15.,0.);\n    }\n    \n    // shake\n    ro+=0.04*sin(2.0*iTime*vec3(1.1,1.2,1.3)+vec3(3.0,0.0,1.0));\n    ta+=0.04*sin(2.0*iTime*vec3(1.7,1.5,1.6)+vec3(1.0,2.0,1.0));\n    \n}\n\nvec3 spider_path(vec3 offset, float time)\n{\n    return offset+vec3(0., 0., .4*time);\n}\n\n\n// iq's \"Insect\" : https://www.shadertoy.com/view/Mss3zM\nvoid move_legs(vec3 offset, float time)\n{\n    for(int i=0; i<min(0,iFrame)+6; i++)\n    {\n        // side\n        float s=-sign(float(i)-2.5);\n        // pair\n        float h=mod(float(i), 3.0)/3.0;\n\n        float z=.5*time + 4.*h + 0.25*s;\n        float iz=floor(z);\n        float fz=fract(z);\n        float az=clamp((fz-0.66)/0.34,0.0,1.0);\n\n        vec3 fo=offset+vec3(s*2.5, 0.7*az*(1.0-az)-2.,\n                              (iz+az+(h-0.4)*6.0)*.8);\n        spider.feet[i]=fo;\n\n        vec3 ba=spider.pos-0.8*vec3(0.,1.,0.)*(1.0-h)+vec3(1.0,0.0,0.0)*s*0.8*(1.0-h)+spider.forward*.8*(h-0.33) ;\n\n        spider.knees[i]=solve(ba, fo, 2.5, 2.+(1.-h), s*vec3(0.0,0.0,-1.));\n    }\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 q=fragCoord/iResolution.xy;\n    vec2 p=q*2.-1.;\n    p.x*=iResolution.x/iResolution.y;\n   \n    if (abs(p.y)>.88) {\n        fragColor=vec4(0.0, 0.0, 0.0, 1.0);\n        return;\n    }\n   \n    vec3 offset=vec3(-1.8,1.5,-20.);\n    \n    if(iTime<SCENE_2 || iTime>SCENE_5)\n    {\n        spider.pos=offset;\n        spider.forward=vec3(0.,0.,1.);\n    }\n    else if(iTime<SCENE_3)\n    {\n        float atime=30.+2.*(iTime-SCENE_2);\n        spider.pos=spider_path(offset,atime);\n        spider.forward=normalize(spider_path(offset,atime+2.)-spider.pos);\n        move_legs(offset, atime);\n    }\n    else if(iTime<SCENE_4)\n    {\n        spider.pos=offset;\n        spider.forward=vec3(0.,0.,1.);\n    }\n    else\n    {\n        float atime=30.+2.*(iTime-SCENE_4);\n        spider.pos=spider_path(offset,atime);\n        spider.forward=normalize(spider_path(offset,atime+2.)-spider.pos);\n        move_legs(offset, atime);\n    }\n    \n\n    vec3 ro=vec3(0.,1.,3.);\n    vec3 ta=vec3(0.);\n    \n    // debugging camera\n    //float x_rot=-iMouse.x/iResolution.x*PI*2.0;\n    //float y_rot=iMouse.y/iResolution.y*3.14*0.5 + PI/2.0;\n    //ro=spider.pos+vec3(0.,20.,0.)+vec3(cos(y_rot)*cos(x_rot),sin(y_rot),cos(y_rot)*sin(x_rot))*10.35;\n    //ta=spider.pos+vec3(0.,20.,0.);\n    //ro=vec3(0.,3.0,0.)+vec3(cos(y_rot)*cos(x_rot),sin(y_rot),cos(y_rot)*sin(x_rot))*20.35;\n    //ta=vec3(0.0,1.,0.);\n    \n    \n    get_camera(ro,ta);\n    \n    vec3 f=normalize(ta-ro);\n    vec3 r=normalize(cross(f,vec3(0.,1.,0.)));\n    vec3 u=normalize(cross(r,f));\n    vec3 rd=normalize(r*p.x+u*p.y+f*2.3);\n    \n    vec3 sky=vec3(0.0,0.05,0.1)*1.4;\n    vec3 col=render_sky(ro,rd);\n    col=render_terrian(ro,rd,col);\n    \n    vec4 res0=scene_dead_land(ro,rd);\n    \n    vec4 res1=vec4(0,0,0,100);\n   \n    if((iTime>SCENE_2 && iTime<SCENE_4) ||\n      (iTime>SCENE_4 && iTime<SCENE_5))\n    {\n        res1=scene_spider(ro,rd);\n    }\n    \n    vec4 res=res0;\n    if(res1.w<res0.w)\n        res=res1;\n    \n    float t=res.w;\n\n    if(t<100.)\n    {\n        col=res.xyz;\n    }\n\n    \n    float mist=get_mist(ro, rd, moon_dir, t);\n    if(iTime<SCENE_5)\n    {\n        col=mix(col, vec3(0.8,0.8,1.)*mix(1., .75, mist)*(rd.y*.25+.5),\n                min(pow(t, 1.5*smoothstep(0.,10.,iTime))*.15/100., 1.));\n    }\n    else\n    {\n        col=mix(col, vec3(0.8,0.8,1.)*mix(1., .75, mist)*(rd.y*.25+.5),\n                min(pow(t, 1.5-smoothstep(0.,20.,iTime-SCENE_5))*.15/100., 1.));\n    }\n    \n    col=tonemap(col);\n    col=pow(clamp(col,0.0,1.0),vec3(0.45));\n    col*=0.5+0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n   \n    fragColor=vec4(col,1.0);\n    \n    fragColor.xyz=mix(fragColor.xyz, vec3(0.), smoothstep(3.,0., iTime));\n    \n    if(iTime>SCENE_3)\n    {\n        fragColor.xyz=mix(fragColor.xyz, vec3(0.), smoothstep(3.,0., iTime-SCENE_3));\n    }\n    if(iTime>SCENE_4)\n    {\n        fragColor.xyz=mix(fragColor.xyz, vec3(0.), smoothstep(3.,0., iTime-SCENE_4));\n    }\n    if(iTime>SCENE_5)\n    {\n        fragColor.xyz=mix(fragColor.xyz, vec3(0.), smoothstep(4.,0., iTime-SCENE_5));\n    }\n}", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tdcWn.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[219, 219, 242, 242, 278], [281, 281, 304, 304, 373], [376, 376, 398, 398, 483], [486, 486, 508, 508, 561], [564, 564, 586, 586, 658], [661, 661, 682, 682, 892], [932, 932, 951, 951, 1166], [1169, 1169, 1208, 1208, 1297], [1300, 1300, 1339, 1339, 1368], [1371, 1371, 1400, 1400, 1492], [1494, 1494, 1523, 1523, 1621], [1623, 1623, 1652, 1652, 1744], [1747, 1747, 1788, 1788, 1831], [1834, 1834, 1864, 1864, 1890], [1893, 1893, 1934, 1934, 2010], [2013, 2013, 2040, 2040, 2129], [2132, 2132, 2169, 2169, 2209], [2212, 2212, 2258, 2258, 2380], [2383, 2383, 2426, 2426, 2562], [2565, 2565, 2615, 2615, 2782], [2785, 2785, 2843, 2843, 2885], [2888, 2888, 2933, 2933, 3079], [3082, 3082, 3110, 3110, 3191], [3194, 3194, 3243, 3243, 3505], [3855, 3855, 3886, 3886, 4021], [4023, 4044, 4074, 4074, 4213], [4215, 4215, 4234, 4234, 5892], [5894, 5894, 5943, 5943, 6522], [6524, 6524, 6549, 6549, 7582], [7702, 7702, 7725, 7725, 7777], [7780, 7780, 7799, 7799, 10170], [10173, 10173, 10197, 10197, 10544], [10546, 10546, 10565, 10565, 10633], [10635, 10635, 10667, 10765, 10967], [10969, 10969, 11004, 11102, 11306], [11310, 11384, 11441, 11441, 12351], [12353, 12353, 12395, 12395, 13403], [13406, 13406, 13451, 13451, 14138], [14140, 14140, 14172, 14172, 14386], [14388, 14388, 14418, 14418, 14627], [14683, 14683, 14743, 14743, 15396], [15399, 15399, 15446, 15446, 15478], [15481, 15481, 15544, 15544, 16364], [16367, 16367, 16404, 16404, 16790], [16793, 16793, 16833, 16833, 17296], [17299, 17299, 17323, 17323, 17590], [17592, 17592, 17641, 17641, 17719], [17721, 17794, 17817, 17817, 17903], [17905, 17905, 17935, 17935, 18326], [18329, 18329, 18392, 18392, 18620], [18622, 18622, 18657, 18657, 19267], [19269, 19269, 19292, 19292, 19468], [19666, 19666, 19709, 19748, 20640], [20642, 20642, 20685, 20685, 20728], [20731, 20788, 20829, 20829, 21468], [21471, 21471, 21526, 21526, 24573]], "test": "error"}
{"id": "4tdczl", "name": "Shiny spiral", "author": "Plento", "description": "an experiment ", "tags": ["2d", "spiral", "shiny"], "likes": 40, "viewed": 799, "published": "Public API", "date": "1533676601", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec2 sp(vec2 uv){ // spiral\n    float r = length(uv);\n    float angle = atan(uv.x, uv.y);\n    uv *= cos(15.0 * r - 1.0 * angle - iTime * 0.8 );\n    return uv;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n    vec2 sv = sp(uv); // warping uv space to spiral\n    vec3 bg = texture(iChannel0, sv - 0.5).xyz; // get background texture\n    // mix between the warped uv and the warped background. then the dot of the two interpolates it\n    vec3 col = mix(vec3(sv, 0.0), bg, dot(vec3(sv, 1.05), bg)) * 1.88; \n    fragColor = vec4(col, 1.0) ;\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tdczl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 18, 28, 161], [162, 162, 218, 218, 620]], "test": "error"}
{"id": "4tdyDs", "name": "stegoBG", "author": "nyu", "description": "background code for https://git.psychoscientists.com/stegOS/stegocute", "tags": ["waves"], "likes": 2, "viewed": 75, "published": "Public", "date": "1534688255", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SPEED 0.03\n#define ENABLEAA\n\nvec3 hsv2rgb(in vec3 c)\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nfloat wave(vec2 uv, vec2 offset){\n    uv.y += (sin(((uv.x + (iTime * SPEED) + offset.x) / 1.0) * 4.0) / 12.0) - offset.y;\n\treturn uv.y;\n}\n\nfloat cylinder(vec2 uv, vec3 offset) {\n    float w = 1.0 - smoothstep(wave(uv, offset.xy), 0.0, 0.02);\n    offset.y += offset.z;\n    w += 1.0 - smoothstep(wave(uv, offset.xy), 0.02, 0.0);\n    return w;\n}\n\nfloat tubes(vec2 uv) {\n    float w = cylinder(uv, vec3(0.0, 0.3, 0.4));\n    w += cylinder(uv, vec3(0.2 + iTime / 30.0, 0.5, 0.4));\n    w += cylinder(uv, vec3(0.4 + iTime / 40.0, 0.1, 0.4));\n    return w;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    float w = tubes(uv);\n    #ifdef ENABLEAA\n    float v = tubes(uv + vec2(0.0, 0.002));\n    w = mix(v, w, 0.5);\n    #endif\n    \n    vec3 bg = mix(vec3(0.05,0.05,0.3), vec3(0.1,0.65,0.85), (uv.x + (1.0 - uv.y))*0.55);\n    //vec3 col = mix(bg, vec3(1.0,1.0,1.0), w);\n    vec3 hsvbg = rgb2hsv(bg);\n    hsvbg.x += iTime / 45.0;\n\n    vec3 col = hsv2rgb(hsvbg) + vec3(0.2) * w;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tdyDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[37, 37, 62, 62, 240], [242, 242, 264, 264, 595], [597, 597, 630, 630, 734], [736, 736, 774, 774, 939], [941, 941, 963, 963, 1146], [1148, 1148, 1204, 1204, 1679]], "test": "ok"}
{"id": "4tdyRj", "name": "Happy Plant 3", "author": "lnae", "description": "Last one :)\n\nmore plants :\nhttps://www.shadertoy.com/view/4t3cDM\nhttps://www.shadertoy.com/view/4ltyD4\n\n", "tags": ["raymarching", "watercolor", "npr", "plant", "cactus"], "likes": 71, "viewed": 1195, "published": "Public", "date": "1533207486", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159\n#define STEPS 100.\n#define EPS 0.00001\n#define EPSN 0.001\n#define EPSOUT 0.004\n\nfloat hash(vec3 p){\n\treturn fract(123456.789 * sin(dot(p, vec3(12.34, 56.78, 91.01))));\n}\n\nmat2 rot(float a){\n    float c = cos(a);\n    float s = sin(a);\n\treturn mat2(c, -s, s, c);\n}\n\nfloat smoothmin(float a, float b, float k){\n\tfloat f = clamp(0.5 + 0.5 * (a - b) / k, 0., 1.);\n    return mix(a, b, f) - k * f * (1. - f);\n}\n\nfloat smoothmax(float a, float b, float k){\n\treturn -smoothmin(-a, -b, k);\n}\n\nfloat smoothabs(float p, float k){\n\treturn sqrt(p * p + k * k) - k;\n}\n\nfloat noise(vec3 p){\n\tvec3 f = fract(p);\n    f = f * f * (3. - 2. * f);\n    vec3 c = floor(p);\n  \n    return mix(mix(mix(hash(c), hash(c + vec3(1., 0., 0.)), f.x),\n               \t   mix(hash(c + vec3(0., 1., 0.)), hash(c + vec3(1., 1., 0.)), f.x),\n               \t   f.y),\n               mix(mix(hash(c + vec3(0., 0., 1.)), hash(c + vec3(1., 0., 1.)), f.x),\n               \t   mix(hash(c + vec3(0., 1., 1.)), hash(c + vec3(1., 1., 1.)), f.x),\n               \t   f.y),\n               f.z);  \n}\n\nfloat fbm(vec3 p){\n\tvec3 pos = 10. * p;\n    float c = 0.5;\n    float res = 0.;\n    for(int i = 0; i < 4; i++){\n        pos.xy = rot(2.) * pos.xy;\n        pos = pos * 2. + 2.;\n    \tres += c * noise(pos);\n        c /= 2.;\n    }\n    return res;\n}\n\n\nvec2 repeat(vec2 pos, float t){\n\tt = 2. * PI / t;\n    float angle = mod(atan(pos.y, pos.x) , t) - 0.5 * t;\n    float r = length(pos);\n    return r * vec2(cos(angle), sin(angle));\n}\n\n\nfloat distScene(in vec3 pos, out int object, out float colorVariation){\n    \n    pos.yz = rot(0.5 + 0.25 * (0.5 + 0.5 * sin(0.25 * iTime - 0.5 * PI))) * pos.yz;\n    pos.xz = rot(0.25 * iTime) * pos.xz;\n    pos.y += 0.22;\n    \n    float f = noise(100. * pos);\n    float sf = smoothstep(0.4, 0.5, f);\n    \n    //floor\n    float dist = pos.y;\n    object = 0;\n    colorVariation = 0.;\n    \n    //pot\n    vec3 p = pos;\n    p.y -= 0.155;\n    float distPot = length(p) - 0.2;\n    distPot = smoothmax(distPot, p.y - 0.097, 0.01);\n    distPot = smoothmax(distPot, -(length(p) - 0.18), 0.01);\n    distPot = max(distPot, -(p.y + 0.15));\n    dist = min(dist, distPot);\n    \n    if(dist == distPot){\n        object = 1;\n        float anglev = acos(p.y / 0.2);\n        colorVariation = 0.9 * smoothstep(0.1, 0.2, 0.5 * sin(5. * sin(10. * anglev)) + 0.3 * (f - 0.5)) + 0.1 * sf;   \n    }\n    \n    //ground\n    float distGround = max(p.y - 0.06 + 0.01 * (noise(150. * p) - 0.5), length(p) - 0.18);\n    dist = min(dist, distGround);\n    \n    if(dist == distGround){\n        object = 2;\n        colorVariation = 0.;\n    }\n    \n    //anim\n    pos.y *= 1. + 0.0075 * sin(5. * iTime);\n    f = noise(100. * pos);\n    sf = smoothstep(0.4, 0.5, f);\n    \n\t//cactus\n    p = pos;\n    p.y -= 0.31;\n    float radout = 0.1;\n    float radin = 0.03;\n    float distPlant = length(vec2(length(p.xz) - radin, p.y)) - radout;\n    \n    float angleh = atan(p.z, p.x); \n    float rh = length(p.xz);\n    float t = 14.;\n    float div = 2. * PI / t;\n    float qh = floor(angleh / div);\n    angleh += 0.15 * p.y / radout;\n    angleh = mod(angleh, div) - 0.5 * div;\n    \n    p.x = rh * cos(angleh);\n    p.z = rh * sin(angleh);\n    \n    distPlant -= 0.01 * (0.5 + 0.5 * cos(t * angleh));\n    \n   \tvec3 pr = p - vec3(radin, 0., 0.);\n    float anglev = atan(pr.y, pr.x);\n    float att = abs(anglev);\n    float rv = length(pr.xy);\n    float qv = floor(anglev / (0.5 * div));\n    anglev = mod(anglev, 0.5 * div) - 0.25 * div;\n    p.x = rv * cos(anglev);\n    p.y = rv * sin(anglev);\n    \n    p -= vec3(radout + 0.01, 0., 0.);\n    float bumpRad = max(0.001, 0.005 - 0.0025 * att * att);\n    distPlant = smoothmin(distPlant, length(p) - bumpRad, 0.008);\n    \n    vec3 pSpike = p - vec3(bumpRad, 0., 0.);\n    pSpike.yz = rot(1.5 * hash(10. * vec3(qv, qh, t))) * pSpike.yz;\n    pSpike = abs(pSpike);\n    float spikeRad = 0.;//0.0015 - 0.001 * att * att;\n    float distSpike = length(pSpike.yz) - spikeRad;\n    pSpike.xz = rot(0.4 + 0.075 * sin(5. * iTime)) * pSpike.xz;\n    pSpike.xy = rot(0.4 + 0.075 * sin(5. * iTime)) * pSpike.xy;\n    distSpike = min(distSpike, length(pSpike.yz) - spikeRad);\n    distSpike = 1.75 * smoothmax(distSpike, length(pSpike) - 0.0375 + 0.01 * att * att, 0.025);\n    distPlant = min(distPlant, distSpike);\n    \n    dist = min(dist, distPlant);\n    \n    if(dist == distPlant){\n        object = 3;\n        colorVariation = cos(t * angleh) * cos(t * anglev) + 0.9 * (f - 0.5);\n        colorVariation = 0.5 + 0.5 * (smoothstep(0.5, 0.9, colorVariation) - smoothstep(0.55, 0.95, -colorVariation));\n        colorVariation = 0.8 * colorVariation + 0.2 * sf;\n    }\n    \n    //flower\n    p = pos;\n    p.y -= 0.31 + radout + 0.005;\n    \n    vec3 pLayer = p;\n    float radius = 0.075;\n    float np = 7.;\n    pLayer.xz = repeat(pLayer.xz, np);\n    pLayer.xy = rot(0.99 - 0.01 * sin(5. * iTime)) * pLayer.xy;\n    pLayer.y = abs(pLayer.y);\n    pLayer.z = smoothabs(pLayer.z, 0.01);\n    float distFlower = length(pLayer - vec3(0.4 * radius, -0.68 * radius, -0.67 * radius)) - radius;\n    \n    pLayer = p;\n    pLayer.xz = rot(PI / np) * pLayer.xz;\n    pLayer.xz = repeat(pLayer.xz, np);\n    pLayer.xy = rot(0.7 - 0.01 * sin(5. * iTime)) * pLayer.xy;\n    pLayer.y = abs(pLayer.y);\n    pLayer.z = smoothabs(pLayer.z, 0.01);\n    radius = 0.09;\n    distFlower = 1.3 * min(distFlower, length(pLayer - vec3(0.4 * radius, -0.68 * radius, -0.67 * radius)) - radius);\n    \n    dist = min(dist, distFlower);\n    if(dist == distFlower){\n    \tobject = 4;\n        colorVariation = smoothstep(0., 0.75, length(pLayer / radius));\n    }\n               \n    return 0.5 * dist;\n}\n\nvec3 getNormal(vec3 p){\n    float c;\n    int o;\n\treturn normalize(vec3(distScene(p + vec3(EPSN, 0., 0.), o, c) - distScene(p - vec3(EPSN, 0., 0.), o, c),\n    \t\t\t\t\t  distScene(p + vec3(0., EPSN, 0.), o, c) - distScene(p - vec3(0., EPSN, 0.), o, c),\n                          distScene(p + vec3(0., 0., EPSN), o, c) - distScene(p - vec3(0., 0., EPSN), o, c)));\n}\n\nvec3 render(vec2 uv){\n    \n    vec3 inkColor = vec3(0.15, 0.25, 0.4);\n    vec3 col = inkColor;\n    \n    //raymarch\n    vec3 eye = vec3(0., 0., 5);\n    vec3 ray = normalize(vec3(uv, 1.) - eye);\n    int o;\n    float dist, step, c, prevDist;\n    bool hit = false;\n    vec3 pos = eye;\n    dist = distScene(pos, o, c);\n    float outline = 1.;\n    \n    for(step = 0.; step < STEPS; step++){\n        prevDist = dist;\n    \tdist = distScene(pos, o, c);\n        if(dist > prevDist + EPS && dist < EPSOUT ){\n        \toutline = min(outline, dist);\n        }\n        if(abs(dist) < EPS){\n        \thit = true;\n            break;\n        }\n    \tpos += dist * ray;\n    }\n    outline /= EPSOUT;\n    \n    vec3 normal = getNormal(pos);\n    float f = fbm(pos);\n    \n    //shading\n    if(hit){\n    \tvec3 light = vec3(10., 5., 5.);\n        light.yz = rot(0.5) * light.yz;\n        float shine = 30.;\n        \n        //paper\n        if(o == 0) col = 1. - 0.025 * vec3(smoothstep(0.6, 0.2, fbm(vec3(uv * 6.,1.))));\n        //pot\n        if(o == 1) col = mix(vec3(0.63, 0.63, 0.85), vec3(1.), 0.8 * c);\n        if(o == 2) col = vec3(0.6, 0.6, 0.6);\n        //plant\n        if(o == 3){\n            col = mix(vec3(0.3, 0.7, 0.6),vec3(0.85, 0.95, 0.7), c);\n\t\t\tshine = 5.;\n        }\n        //flower\n        if(o == 4){\n        \tcol = mix(vec3(0.85, 0.95, 0.7), vec3(0.96, 0.6, 0.85), c);\n            shine = 5.;\n        }\n        \n        //diffuse\n        vec3 l = normalize(light - pos);\n        float diff = dot(normalize(normal + 0.2 * vec3(f - 0.5)), l);\n        diff = smoothstep(0.4, 0.5, diff + 0.3 * f);\n        if(o != 0) col = mix(col, vec3(0.1, 0.3, 0.75), 0.3 * (1. - diff));\n        \n        //specular\n        vec3 refl = reflect(-l, normal);\n        float spec = pow(dot(normalize(eye - pos), refl), shine);\n        spec = smoothstep(0.5, 0.6, spec + 0.5 * f);\n        col += 0.01 * shine * spec;\n        \n        //outline\n        outline = smoothstep(0.75, 0.95, outline + 0.9 * f);\n        col = mix(inkColor, col, outline);\n    }  \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.x;\n    uv *= 0.8;\n    vec3 col = render(uv);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tdyRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[99, 99, 118, 118, 188], [190, 190, 208, 208, 281], [283, 283, 326, 326, 423], [425, 425, 468, 468, 501], [503, 503, 537, 537, 572], [574, 574, 594, 594, 1067], [1069, 1069, 1087, 1087, 1312], [1315, 1315, 1346, 1346, 1495], [1498, 1498, 1569, 1569, 5618], [5620, 5620, 5643, 5643, 5980], [5982, 5982, 6003, 6003, 8023], [8025, 8025, 8082, 8082, 8223]], "test": "timeout"}
{"id": "4tGczm", "name": "Electric [rough]", "author": "Hadyn", "description": "Just wanted to try out a couple of ideas! Code is the result of experimentation without any cleanup whatsoever, so it's super rough / contains redundant vestigial stuff (sorry!).", "tags": ["experiment", "voronoise"], "likes": 19, "viewed": 459, "published": "Public", "date": "1535560232", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Based on original code by by inigo quilez - iq/2013\n// https://www.shadertoy.com/view/ldl3W8\n// http://www.iquilezles.org/www/articles/voronoilines/voronoilines.htm\n\n// Modified by hadyn lander\n\n#define PHASE_POWER 2.0\n\nvec2 hash2( vec2 p )\n{\n\t// texture based white noise\n\treturn texture( iChannel0, (p+0.5)/256.0, -100.0 ).xy;\n\t\n    // procedural white noise\t\n\t//return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec4 voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\tvec2 o;\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr;\n\tfloat oldDist;\n    \n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\to = hash2( n + g );\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\t\n    oldDist = md;\n    \n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\to = hash2( n + g );\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return vec4( md, mr, oldDist );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.yy;\n    float pauseFreq = 20.0;\n    float pauseScale = 1.0; // range 0-1\n    float scaledTime = iTime * 0.50;\n    scaledTime += 0.05*uv.x;\n    float sinTime = sin(pauseFreq*scaledTime);\n    float sinTimeOffset = sin(pauseFreq*scaledTime - 0.5*3.141);\n    float timeStep = scaledTime + pauseScale*(sinTime/pauseFreq);\n    \n    vec2 p = uv;\n    vec4 c;\n    \n    \n    p *= 4.0;\n    // p.x += - timeStep*6.0;\n    // p.y += - timeStep*3.0;    \n    p.x = 0.5 - timeStep*3.0;\n    p.y = 0.5 - timeStep*3.0; \n    c = voronoi( p );\n    \n    float cellPos = (p.y+c.z)+ timeStep*3.0;\n    // uv.x += 0.5*(2.0 * cellPos-1.0) * (uv.y-0.5);\n    uv.x += 1.5*(2.0 * c.x-0.33) * (uv.y-0.5);\n\t// fragColor = vec4(2.5*(2.0 * cellPos-1.0) * (uv.y-0.5)); return;\n    \n    \n    uv.x *= 0.25; \n    p = uv;\n    p.y = max(p.y, 0.5); \n    p *= 12.0; // higher values zoom out further - don't go too high or the sine waves will become quite obvious...\n    p.x += timeStep*16.0;\n    p.y += timeStep*32.0;\n    c = voronoi( p );\n    // c.x = 1.0-pow(1.0-c.x, 2.0);\n    \n    \n\tfragColor = 0.5*vec4(c.x);\n    \n    float d = 0.0;\n    float edgeScale = 1.0-2.0*abs(fragCoord.x/iResolution.x - 0.5);\n    //edgeScale = fragCoord.x/iResolution.x ;\n    float scaleMulti = pow(0.5*sinTime + 0.5, 2.0);\n\tfloat dScale = 2.0 * edgeScale * (0.25+0.75*pow(0.5*sinTimeOffset + 0.5, 2.0));\n    \n    p.y = 0.5*12.0 + timeStep*3.0;\n    c = dScale*voronoi( p );\n    // float d = 1.0-abs(uv.y-c.x-0.25);\n    d = (uv.y+c.x-0.75);\n    \n    p.x = uv.x*12.0 - timeStep*6.0;\n    p.y = 4.5*12.0 - timeStep*3.0;\n    c = dScale*voronoi( p );\n    d = mix(d, (uv.y-c.x-0.25), 0.5);\n    \n    \n    d = 1.0-abs(d);\n    \n    fragColor = vec4(d);\n    //float lineWidth *= 1.0- pow(1.0-(0.5*sinTimeOffset + 0.5), 2.0);\n    float lineWidth = d+0.025*scaleMulti *edgeScale;\n\n\tfragColor = mix(vec4(0,1,1.5,1 ), vec4(1,2,2.0,1 ), scaleMulti) * smoothstep(1.0, 1.005, lineWidth);\n\t//fragColor += edgeScale*vec4(1,1,1.0,1 ) * smoothstep(1.0, 1.005, lineWidth);\n    \n    fragColor += edgeScale*pow(scaleMulti*smoothstep(0.75, 1.005, lineWidth), 16.0) * 0.5*vec4(.8,1,2.0,1 ) ;\n    \n    fragColor += 0.5*vec4(.1,0.05,0.2,1 );\n    \n}\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tGczm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[223, 223, 245, 275, 456], [458, 458, 485, 485, 1475], [1477, 1477, 1534, 1534, 3730]], "test": "error"}
{"id": "4tGyRw", "name": "Paint Topology", "author": "momoro", "description": "WIP Mistake", "tags": ["color"], "likes": 3, "viewed": 496, "published": "Public API", "date": "1535424972", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592654\n\nfloat map(float value, float inMin, float inMax, float outMin, float outMax) {\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n}\n\n\nmat2 rotate(float angle) {\n    return mat2(cos(angle), -sin(angle),\n                sin(angle), cos(angle)\n    );\n}\n\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n\nfloat atan201(float x, float y) {\n    return (atan(x, y) + PI) / (PI * 2.);\n}\n\nfloat sin01(float n) {\n    return sin(n)/2.+.5;\n}\n\nvec2 sin01(vec2 n) {\n    return sin(n)/2.+.5;\n}\n\nvec4 blend(vec4 bg, vec4 fg) {\n    vec4 c = vec4(0.);\n    c.a = 1.0 - (1.0 - fg.a) * (1.0 - bg.a);\n    if(c.a < .00000) return c;\n    \n    c.r = fg.r * fg.a / c.a + bg.r * bg.a * (1.0 - fg.a) / c.a;\n    c.g = fg.g * fg.a / c.a + bg.g * bg.a * (1.0 - fg.a) / c.a;\n    c.b = fg.b * fg.a / c.a + bg.b * bg.a * (1.0 - fg.a) / c.a;\n    \n    return c;\n}\n\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return dot(m, g);\n}\n\n\nfloat fbm1d(float x, float amplitude, float frequency, float offset) {\n    x += offset;\n    float y = 0.;\n    // Properties\n    const int octaves = 8;\n    float lacunarity = 1.144;\n    float gain = 1.092;\n    \n    // Initial values\n    //sin(u_time) * 5. + 10.;\n    //sin(u_time/10. + 10.);\n    \n    // Loop of octaves\n    for (int i = 0; i < octaves; i++) {\n        y += amplitude * snoise(vec2(frequency*x));\n        frequency *= lacunarity;\n        amplitude *= gain;\n    }\n    \n    return y;\n}\n\n\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\nfloat smax(float a,float b, float k)\n{\n    return -smin(-a,-b,k);\n}\n\nfloat smootheststep(float t) {\n    return -20.*pow(t, 7.)+70.*pow(t,6.)-84.*pow(t,5.)+35.*pow(t,4.); // when smootherstep's second derivative isn't enough\n}\n\n\nfloat pcsmooth(float x) {\n    return -\n        pow(cos((PI*(x)/2.)), 3.) + 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n       \n    vec4 color;\n    vec2 st = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    \n    st /=15.036;\n    st += vec2(0.000,-0.055);\n    \n    st *= rotate(iTime/.9);\n    \n    /////////////////////////////////////////////////////////////\n    // Blobby circle\n    #define arcs 7.\n    \n    float f = atan201(st.x, st.y); // angle\n    float m = smoothstep(0., 1., fract(f * arcs)); // mix amount\n\t\n     m = pcsmooth(fract(f*arcs));\n    \n    f = ceil(f * arcs) / arcs; // split up\n    \n    float fNext = f + 1./arcs;\n    // fNext = f;\n    \n    \n    // Smooth the blob at the end\n    bool e = false;\n    if(f > (arcs-1.)/arcs + .01) {\n\t\tfNext = 1./arcs;\n    }\n    \n    // Add noise\n    float amp = 10000.;\n    float freq = 30.;\n    \n    float offset = 1.144 + iTime/300.;\n    f = fbm1d(f, amp, freq, offset);\n    fNext = fbm1d(fNext, amp, freq, offset);\n    \n    f =  map(f, -20., 1., 0.648, 0.712);\n    fNext = map(fNext, -20., 1., 0.648, 0.712);\n\n    float len = length(st);\n\n    float mx = mix(f, fNext, m);\n    len += mx * 0.080;\n    \n  //  float c = smoothstep(len, 0.712, 0.900);\n    \n   // color.rgb = vec3(c);\n\n  //  color.a = 1.;\n    //color.rgb = vec3(mx);\n    \n    #define steps 90.\n    for(float i=0.; i<steps; i++) {\n   \t\tfloat df = max(abs(st.x), abs(st.y));\n        df = len;\n        // df = length(st);\n        \n        float incr = 0.4 - (0.4 * i/steps);\n        \n        float f = 1.0 - smoothstep(incr-.001, incr, df);\n\n        // SHADOW\n       f -=  (1.0 - (fract(df*steps) + 0.116)) * 1.016 * f;\n        \n        vec3 rgb = vec3(f);\n        \n        vec3 hsv = vec3(1.);\n        hsv.x = pow(2. * fract((i*6.)/steps + iTime/2.3) - 1., 2.);\n        hsv.x = map(hsv.x, 0., 1., 0.0, 0.108);\n        hsv.y = .9;\n\n        vec3 rgb2 = hsv2rgb(hsv);\n\n        rgb = rgb2 * rgb * 3.112;\n        float a = (i/steps + 0.640) * f;\n       // a  = 0.208;\n\n        color = blend(color, vec4(rgb, a * f));\n    }\n    \n    st = st * rotate(-3.148);\n    st += vec2(-0.030,0.070);\n    st *= 1.288;\n\n    \n    for(float i=0.; i<steps; i++) {\n   \t\tfloat df = max(abs(st.x), abs(st.y));\n        df = len  *.3;\n        // df = length(st);\n        \n        float incr = 0.4 - (0.4 * i/steps);\n        \n        float f = 1.0 - smoothstep(incr-.001, incr, df);\n\n        // SHADOW\n       f -=  (1.0 - (fract(df*steps) + 0.036)) * 1.064 * f;\n        \n        vec3 rgb = vec3(f);\n        \n        vec3 hsv = vec3(1.);\n        hsv.x = pow(2. * fract((i*6.)/steps + iTime/9.3) - 1., 2.);\n        hsv.x = map(hsv.x, 0., 1., 0.0, 0.964);\n        hsv.y = .9;\n        hsv.z = .3;\n\n        vec3 rgb2 = hsv2rgb(hsv);\n\n        rgb = rgb2 * rgb * 3.112;\n        float a = (i/steps + 0.01) - 0.472;\n       // a  = 0.208;\n\n        color = blend(color, vec4(rgb, a * f));\n    }\n        \n    color = color;\n    \n    fragColor = color;\n\n    // todo: rotate it and try to think about the light effect more\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tGyRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 102, 102, 177], [180, 180, 206, 206, 295], [298, 298, 320, 320, 651], [653, 653, 675, 675, 844], [846, 846, 867, 867, 914], [915, 915, 936, 936, 983], [984, 984, 1006, 1006, 1041], [1044, 1044, 1077, 1077, 1121], [1123, 1123, 1145, 1145, 1172], [1174, 1174, 1194, 1194, 1221], [1223, 1223, 1253, 1253, 1570], [1572, 1572, 1594, 1647, 3336], [3339, 3339, 3409, 3409, 3836], [3839, 3839, 3877, 3877, 3954], [3956, 3956, 3994, 3994, 4023], [4025, 4025, 4055, 4055, 4181], [4184, 4184, 4209, 4209, 4264], [4266, 4266, 4323, 4323, 7218]], "test": "ok"}
{"id": "4tKyWR", "name": "Tulip", "author": "Redline", "description": "Tulip animation (was originally supposed to be Pacman but whatever)", "tags": ["flower", "animation", "tulip"], "likes": 1, "viewed": 448, "published": "Public API", "date": "1535748156", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define tau 6.28318530718\n\nconst int res = 128;\nconst float speed = .1;\nconst float detune = .5;\nconst float zoom = 1.3;\nconst float blur = .1;\n\nfloat rectSin(float phase){\n\treturn sin(phase) / 2. + 1.;\n}\nfloat circle(float radius, vec2 pos){\n\treturn radius - length(pos);\n}\nfloat ring(float radius, vec2 pos){\n\treturn abs(radius - length(pos));\n}\nvec3 leaf(vec2 uv,float angle){\n\tvec3 col = vec3(0);\n    for(int i = 0; i < res;i++){\n\t    float prog = float(i) / float(res);\n\t    float phase = (iTime * speed + prog * detune) * tau;\n    \tfloat radius = 1. - abs(atan(uv.x,uv.y) + angle) * 1. * rectSin(phase);\n        float ringBright = smoothstep(1.,0.,ring(radius,uv) / blur);\n        float fillBright = smoothstep(0.,1.,circle(radius,uv) / blur) / 20.;\n        float bright = ringBright + fillBright;\n    \tcol += vec3(\n                prog,\n                rectSin(phase) + .5,\n                rectSin(prog*tau) + prog\n            ) * bright;\n    }\n\n    return col / (float(res) * blur * 10.);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy ;\n    uv.x = uv.x *  2. -1.;\n    uv.x /= iResolution.y / iResolution.x;\n    uv.y = uv.y * zoom + (1. - zoom) + .1;\n\n    vec3 col = vec3(0);\n    col = max(col,leaf(uv,0.));\n    \n    float angle = rectSin(iTime / tau) / 2.;\n    col = max(col,leaf(uv,angle));\n    col = max(col,leaf(uv,-angle));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tKyWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[145, 145, 172, 172, 204], [205, 205, 242, 242, 274], [275, 275, 310, 310, 347], [999, 999, 1056, 1056, 1445]], "test": "ok"}
{"id": "4ttczl", "name": "beachclub", "author": "lennyjpg", "description": "asdfasdf", "tags": ["asdfasdf"], "likes": 1, "viewed": 411, "published": "Public API", "date": "1533686284", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 O, in vec2 f )\n{\n    vec2 uv = f/iResolution.xy;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    uv.y+=sin(uv.x*7.0-iTime)*0.03;\n    uv.x+=cos(uv.x*3.3+iTime)*0.1;\n    uv.y*=sin(iTime*0.1+0.5)*2.3;\n    float s = .2,\n        t = iTime*.3,\n        y = mod(exp(uv.y+0.7)+t,0.4),\n        x = uv.x+t*.2;\n        y += sin(t*1.0)*0.5;\n    float k = smoothstep(.0,uv.y+y, sin(x * 7.)*s+.45);\n    float d = smoothstep(0.42,.44,length(uv-0.5));\n    vec3 hey = vec3(1.,.1,.2),        \n        hoo = vec3(.0,.0,.2),\n    thisisit = mix(hey,hoo,k);   \n    O = vec4(thisisit,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ttczl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 592]], "test": "ok"}
{"id": "4ttyRj", "name": "gam0022!", "author": "kaneta", "description": "I am fan of gam0022\nhttps://www.shadertoy.com/user/gam0022", "tags": ["2d", "text", "font", "curve", "ttf", "gam0022"], "likes": 15, "viewed": 647, "published": "Public API", "date": "1533204435", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// I got idea of this code from here\n// https://www.shadertoy.com/view/lslGDn\n\n// Reference\n// https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch25.html\n\n//#define AA\n\nfloat cross2(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\nfloat InTri( vec2 A, vec2 B, vec2 C, const in vec2 P )\n{\n    vec2 a = C - A, b = B - A, c = P - A;\n    vec2 area = vec2(cross2(c,b),cross2(a,c)) / (cross2(a,b));\n    return -min(min(area.x, area.y), 1.0 - area.x - area.y);\n}\n\nfloat InBezier(vec2 A, vec2 B, vec2 C, vec2 P, float cond)\n{\n    vec2 a = C - A, b = B - A, c = P - A;\n    vec2 area = vec2(cross2(c,b),cross2(a,c)) / (cross2(a,b));\n    float area2 = 1.0 - area.x - area.y;\n    vec2 d = vec2(area.y * 0.5, 0.0) + area2;\n    return max(cond * (d.x * d.x - d.y), -min(min(area.x, area.y), area2));\n}\n\n#define IT(a,b,c) d = min( d, InTri(v[a],v[b],v[c], uv));\n#define IB(a,b,c) d = min( d, InBezier(v[a],v[b],v[c], uv, -1.0));\n#define IB2(a,b,c) d = min( d, InBezier(v[a],v[b],v[c], uv, 1.0));\n\nfloat udRect( vec2 p, vec2 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat GA(vec2 uv) {    // \n    float d = 10000.0;\n    if (udRect(uv - vec2(0.1165,0.8740), vec2(0.1755,0.3340)) == 0.0) {\n    vec2 v[202] = vec2[202](\n        vec2(0.0290,0.6070),vec2(0.0160,0.6460),vec2(0.0180,0.6480),vec2(0.0320,0.6280),vec2(0.0470,0.6000),vec2(0.0490,0.6030),\n        vec2(0.0160,0.7480),vec2(-0.0210,0.6860),vec2(-0.0240,0.6780),vec2(-0.0130,0.7870),vec2(0.0250,0.8450),vec2(0.0350,0.8740),\n        vec2(-0.0500,0.8630),vec2(-0.0570,0.8670),vec2(-0.0030,0.9200),vec2(0.0460,1.0510),vec2(0.0180,1.0320),vec2(0.0040,1.0290),\n        vec2(0.0420,1.0970),vec2(0.0620,1.1300),vec2(0.0650,1.1400),vec2(0.0740,1.1650),vec2(0.0960,1.1610),vec2(0.1040,1.1540),\n        vec2(0.1130,1.1480),vec2(0.1120,1.1360),vec2(0.1100,1.1190),vec2(0.0840,1.0870),vec2(0.0810,0.9940),vec2(0.0970,1.0060),\n        vec2(0.1040,0.9910),vec2(0.1100,0.9760),vec2(0.1010,0.9470),vec2(0.1330,1.0650),vec2(0.1240,1.1520),vec2(0.1200,1.1650),\n        vec2(0.1160,1.1830),vec2(0.1040,1.2060),vec2(0.1360,1.2020),vec2(0.1540,1.1940),vec2(0.1620,1.1790),vec2(0.1700,1.1640),\n        vec2(0.1700,1.1410),vec2(0.1760,1.0110),vec2(0.1960,1.0310),vec2(0.2080,1.0320),vec2(0.2400,1.0170),vec2(0.2520,0.9920),\n        vec2(0.2120,0.9730),vec2(0.2150,0.9470),vec2(0.2920,0.9300),vec2(0.2520,0.8650),vec2(0.2390,0.8430),vec2(0.2060,0.8110),\n        vec2(0.2470,0.7530),vec2(0.2540,0.6940),vec2(0.2580,0.6360),vec2(0.2630,0.5700),vec2(0.2410,0.5700),vec2(0.2250,0.5800),\n        vec2(0.2130,0.5930),vec2(0.2020,0.6230),vec2(0.1920,0.6490),vec2(0.1750,0.7210),vec2(0.1460,0.7540),vec2(0.0920,0.7050),\n        vec2(0.0870,0.7090),vec2(0.0930,0.7190),vec2(0.1210,0.7420),vec2(0.1460,0.7790),vec2(0.1390,0.9210),vec2(0.1200,0.9040),\n        vec2(0.1030,0.8800),vec2(0.2050,1.1210),vec2(0.1950,1.1230),vec2(0.2070,1.1350),vec2(0.2180,1.1460),vec2(0.2340,1.1470),\n        vec2(0.2500,1.1490),vec2(0.2610,1.1400),vec2(0.2550,1.0840),vec2(0.2370,1.0700),vec2(0.2240,1.0510),vec2(0.0600,1.0600),\n        vec2(0.0750,1.0760),vec2(0.0090,1.0470),vec2(0.0740,1.0330),vec2(0.0600,1.0200),vec2(0.0640,1.1650),vec2(0.0640,1.1590),\n        vec2(0.0000,1.0310),vec2(0.0130,0.9350),vec2(0.0370,0.9090),vec2(0.0420,0.9130),vec2(0.0100,0.8730),vec2(0.0330,0.9540),\n        vec2(0.0740,0.9900),vec2(0.0600,0.9790),vec2(0.0490,0.9690),vec2(0.0980,0.9360),vec2(0.0420,0.9080),vec2(0.1150,1.2080),\n        vec2(0.1650,1.1090),vec2(0.1610,1.0920),vec2(0.1610,1.0220),vec2(0.1420,0.9780),vec2(0.0990,0.9390),vec2(0.1000,0.8750),\n        vec2(0.1470,0.9280),vec2(0.1200,0.9570),vec2(0.1650,0.9400),vec2(0.1480,0.9240),vec2(0.1690,0.8890),vec2(0.1530,0.8590),\n        vec2(0.0950,0.8680),vec2(-0.0360,0.8590),vec2(-0.0540,0.7200),vec2(-0.0410,0.7420),vec2(-0.0560,0.6930),vec2(-0.0590,0.7130),\n        vec2(-0.0180,0.8580),vec2(-0.0020,0.8600),vec2(-0.0290,0.7620),vec2(0.0540,0.8090),vec2(-0.0480,0.6650),vec2(-0.0380,0.6620),\n        vec2(-0.0310,0.6660),vec2(0.0280,0.6360),vec2(0.0250,0.6420),vec2(0.0900,0.8590),vec2(0.0850,0.8510),vec2(0.0720,0.8310),\n        vec2(0.0540,0.8030),vec2(0.1630,0.7690),vec2(0.1490,0.7840),vec2(0.1510,0.7580),vec2(0.1560,0.7630),vec2(0.0510,0.6970),\n        vec2(0.0660,0.6890),vec2(0.0610,0.5800),vec2(0.0500,0.5520),vec2(0.0580,0.5450),vec2(0.0880,0.7150),vec2(0.1610,1.0450),\n        vec2(0.2190,1.1110),vec2(0.2150,1.0460),vec2(0.2160,1.0490),vec2(0.2140,1.0430),vec2(0.1840,0.9580),vec2(0.1730,0.9500),\n        vec2(0.1620,0.9980),vec2(0.1620,1.0050),vec2(0.1970,0.9660),vec2(0.2180,1.0320),vec2(0.2170,1.0530),vec2(0.2600,1.1250),\n        vec2(0.2570,1.1210),vec2(0.2540,1.1160),vec2(0.2280,1.0960),vec2(0.2660,1.1340),vec2(0.2640,1.1300),vec2(0.2690,1.1000),\n        vec2(0.2680,1.0970),vec2(0.2620,1.1070),vec2(0.2660,1.0940),vec2(0.2260,1.0810),vec2(0.2190,1.0580),vec2(0.2340,1.0240),\n        vec2(0.2270,1.0290),vec2(0.2590,1.0880),vec2(0.2630,1.0910),vec2(0.1770,0.8330),vec2(0.1550,0.8420),vec2(0.1780,0.8280),\n        vec2(0.1560,0.8000),vec2(0.1820,0.7870),vec2(0.1850,0.8410),vec2(0.1980,0.8680),vec2(0.1840,0.7790),vec2(0.1620,0.7680),\n        vec2(0.1600,0.7660),vec2(0.1640,0.7670),vec2(0.1640,0.7640),vec2(0.1660,0.7580),vec2(0.1680,0.7510),vec2(0.1950,0.7490),\n        vec2(0.1700,0.7420),vec2(0.1720,0.7320),vec2(0.2180,0.6980),vec2(0.2080,0.7180),vec2(0.2040,0.9450),vec2(0.2090,0.9480),\n        vec2(0.2060,0.9400),vec2(0.2070,0.9260),vec2(0.2060,0.8930),vec2(0.2070,0.9080),vec2(0.2300,0.7150),vec2(0.2370,0.7690),\n        vec2(0.2240,0.6930),vec2(0.2440,0.7840),vec2(0.2390,0.7850),vec2(0.2420,0.7900)\n    );\n    IT(83,18,84)IT(27,18,19)IT(18,83,15)IT(15,85,18)IT(15,17,85)IT(83,86,87)IT(88,21,89)IT(89,21,20)IT(19,25,27)IT(83,84,86)\n    IT(84,18,27)IT(19,20,25)IT(90,85,17)IT(14,91,92)IT(93,92,91)IT(94,14,92)IT(91,95,93)IT(86,96,87)IT(32,97,96)IT(87,96,97)\n    IT(97,32,98)IT(93,98,99)IT(93,95,98)IT(100,93,99)IT(96,28,30)IT(20,23,25)IT(101,38,36)IT(38,40,36)IT(102,103,34)IT(34,35,40)\n    IT(33,104,105)IT(36,37,101)IT(106,98,32)IT(72,99,71)IT(99,98,106)IT(107,100,72)IT(72,100,99)IT(30,32,96)IT(108,109,110)IT(99,109,70)\n    IT(71,99,70)IT(110,111,108)IT(70,109,108)IT(105,110,109)IT(111,112,113)IT(21,23,20)IT(107,114,100)IT(14,115,12)IT(7,116,117)IT(118,119,116)\n    IT(120,94,121)IT(120,115,14)IT(122,9,6)IT(123,6,9)IT(122,6,117)IT(94,120,14)IT(6,7,117)IT(118,7,8)IT(7,118,116)IT(118,8,124)\n    IT(125,124,126)IT(124,8,126)IT(2,127,0)IT(3,0,127)IT(127,2,128)IT(10,123,9)IT(11,129,130)IT(129,11,114)IT(11,130,131)IT(123,131,132)\n    IT(123,10,131)IT(133,69,134)IT(68,69,64)IT(135,64,69)IT(135,69,136)IT(11,100,114)IT(137,138,5)IT(139,5,138)IT(4,0,3)IT(140,0,4)\n    IT(140,4,139)IT(139,141,140)IT(4,5,139)IT(68,66,67)IT(132,138,137)IT(142,67,66)IT(64,66,68)IT(131,138,132)IT(131,10,11)IT(40,42,34)\n    IT(33,34,103)IT(34,42,102)IT(103,143,33)IT(73,75,144)IT(82,145,146)IT(82,147,145)IT(104,33,143)IT(105,148,149)IT(149,110,105)IT(150,105,151)\n    IT(150,43,152)IT(150,148,105)IT(48,45,153)IT(150,152,148)IT(152,43,48)IT(45,48,43)IT(146,154,82)IT(104,151,105)IT(77,155,156)IT(77,156,157)\n    IT(77,157,144)IT(158,144,157)IT(144,75,77)IT(79,159,160)IT(79,160,155)IT(161,162,163)IT(158,157,163)IT(155,77,79)IT(164,163,162)IT(165,81,166)\n    IT(82,166,81)IT(167,48,168)IT(167,46,48)IT(165,158,80)IT(154,166,82)IT(163,169,158)IT(80,158,169)IT(165,80,81)IT(170,169,163)IT(163,164,170)\n    IT(153,168,48)IT(111,110,112)IT(113,112,171)IT(113,171,172)IT(172,173,174)IT(173,172,171)IT(174,173,175)IT(175,134,174)IT(175,133,134)IT(176,53,173)\n    IT(53,175,173)IT(53,177,51)IT(133,175,178)IT(69,179,180)IT(133,178,181)IT(69,180,136)IT(182,181,178)IT(183,182,178)IT(69,133,179)IT(184,185,186)\n    IT(185,184,183)IT(186,185,187)IT(187,185,63)IT(61,63,188)IT(185,189,63)IT(185,183,178)IT(190,191,192)IT(193,192,49)IT(53,176,177)IT(51,194,195)\n    IT(194,51,177)IT(51,193,49)IT(51,195,193)IT(191,49,192)IT(54,196,197)IT(196,54,56)IT(56,61,198)IT(188,198,61)IT(59,61,56)IT(188,63,189)\n    IT(199,54,197)IT(199,200,201)IT(59,56,58)IT(56,198,196)IT(200,199,197)IT(40,35,36)IB2(0,1,2)IB(3,4,5)IB(6,7,8)IB(9,10,11)\n    IB2(12,13,14)IB2(15,16,17)IB(18,19,20)IB2(21,22,23)IB2(23,24,25)IB2(25,26,27)IB2(28,29,30)IB2(30,31,32)IB(33,34,35)IB(35,36,37)\n    IB2(38,39,40)IB2(40,41,42)IB2(43,44,45)IB2(46,47,48)IB2(49,50,51)IB2(51,52,53)IB2(54,55,56)IB2(56,57,58)IB2(59,60,61)IB2(61,62,63)\n    IB2(64,65,66)IB(67,68,69)IB(70,71,72)IB2(73,74,75)IB2(75,76,77)IB2(77,78,79)IB(80,81,82)\n    return d;\n    }\n    return d;\n}\nfloat MU(vec2 uv) {    // \n    float d = 10000.0;\n    if (udRect(uv - vec2(0.1050,0.8770), vec2(0.1770,0.3410)) == 0.0) {\n    vec2 v[279] = vec2[279](\n        vec2(0.1160,0.5660),vec2(0.1280,0.5960),vec2(0.1300,0.6270),vec2(-0.0320,0.6640),vec2(0.0110,0.6820),vec2(0.0260,0.6930),\n        vec2(-0.0120,0.7180),vec2(-0.0360,0.7060),vec2(-0.0640,0.7410),vec2(-0.0410,0.8430),vec2(-0.0560,0.8470),vec2(-0.0660,0.8570),\n        vec2(0.0390,1.0690),vec2(0.0390,1.0760),vec2(0.0100,1.0580),vec2(-0.0230,1.0280),vec2(-0.0480,1.0010),vec2(-0.0520,1.0040),\n        vec2(-0.0540,1.0080),vec2(-0.0630,1.0260),vec2(-0.0510,1.0680),vec2(-0.0340,1.1340),vec2(-0.0330,1.1630),vec2(-0.0330,1.1890),\n        vec2(-0.0420,1.2050),vec2(-0.0460,1.2140),vec2(-0.0470,1.2180),vec2(-0.0170,1.2020),vec2(0.0230,1.1220),vec2(0.0170,1.1100),\n        vec2(-0.0130,1.0690),vec2(-0.0310,1.0420),vec2(-0.0310,1.0380),vec2(0.0220,1.0850),vec2(0.0540,1.1140),vec2(0.0680,1.1180),\n        vec2(0.0880,1.1250),vec2(0.1010,1.1190),vec2(0.1220,1.0890),vec2(0.0980,1.0720),vec2(0.0710,1.0450),vec2(0.0890,1.0010),\n        vec2(0.1050,1.0440),vec2(0.1130,1.0500),vec2(0.1300,1.0490),vec2(0.1430,1.0400),vec2(0.1430,1.0100),vec2(0.1430,0.9870),\n        vec2(0.1370,0.9680),vec2(0.1010,0.8570),vec2(0.1010,0.8470),vec2(0.1140,0.8320),vec2(0.1490,0.8170),vec2(0.2000,0.8190),\n        vec2(0.2100,0.8230),vec2(0.2280,0.8290),vec2(0.2540,0.8120),vec2(0.2810,0.7930),vec2(0.2820,0.7690),vec2(0.2820,0.7570),\n        vec2(0.2720,0.7540),vec2(0.2640,0.7510),vec2(0.2190,0.7630),vec2(0.1120,0.7680),vec2(0.0970,0.7350),vec2(0.0460,0.6940),\n        vec2(0.0920,0.6770),vec2(0.1070,0.7070),vec2(0.1140,0.7100),vec2(0.1440,0.6950),vec2(0.1650,0.7250),vec2(0.1860,0.7260),\n        vec2(0.2060,0.6670),vec2(0.1870,0.6090),vec2(0.1260,0.5550),vec2(0.0410,0.8060),vec2(0.0060,0.8290),vec2(0.0120,0.8600),\n        vec2(0.0080,0.8650),vec2(-0.0030,0.8580),vec2(0.0010,0.8500),vec2(0.0660,0.8160),vec2(0.0500,0.8360),vec2(0.0480,0.8730),\n        vec2(0.0360,0.8770),vec2(0.0260,0.8460),vec2(0.0320,0.8310),vec2(0.0670,0.8710),vec2(0.0640,0.8470),vec2(0.0690,0.8330),\n        vec2(-0.0010,1.1930),vec2(-0.0220,1.0550),vec2(0.0000,1.0520),vec2(-0.0280,1.0450),vec2(0.0280,1.1580),vec2(-0.0410,0.9730),\n        vec2(-0.0400,0.9840),vec2(-0.0360,0.9770),vec2(-0.0400,0.9380),vec2(-0.0270,0.9500),vec2(-0.0220,0.9250),vec2(-0.0390,0.9000),\n        vec2(-0.0210,0.9190),vec2(-0.0130,0.9340),vec2(0.0060,0.9530),vec2(-0.0110,0.9150),vec2(-0.0090,0.9430),vec2(-0.0050,0.9530),\n        vec2(-0.0200,0.9210),vec2(-0.0170,0.9260),vec2(-0.0140,0.9070),vec2(-0.0010,0.9630),vec2(-0.0150,0.9030),vec2(0.0110,1.1820),\n        vec2(0.0210,1.1700),vec2(0.0300,1.1440),vec2(0.0100,0.9860),vec2(0.0290,1.0400),vec2(0.0330,1.0010),vec2(0.0170,0.9740),\n        vec2(0.0060,0.9820),vec2(0.0360,1.0600),vec2(0.0230,0.9880),vec2(0.0440,1.0150),vec2(0.0560,1.0300),vec2(0.0020,0.9720),\n        vec2(0.0050,0.9780),vec2(0.0200,0.9670),vec2(0.0230,0.9560),vec2(0.0060,0.9460),vec2(0.0290,0.9360),vec2(0.0070,0.9160),\n        vec2(0.0070,0.9340),vec2(0.0260,0.9460),vec2(0.0020,0.9130),vec2(0.0370,0.8800),vec2(0.0710,0.9550),vec2(0.0300,0.9390),\n        vec2(0.0330,0.9470),vec2(0.0720,0.8980),vec2(0.0470,0.8870),vec2(0.0350,0.9530),vec2(0.0420,0.8850),vec2(-0.0090,0.9070),\n        vec2(0.0120,0.8680),vec2(-0.0710,0.8710),vec2(-0.0660,0.8760),vec2(-0.0580,0.8810),vec2(-0.0490,0.8860),vec2(-0.0720,0.8670),\n        vec2(-0.0380,0.8920),vec2(-0.0310,0.8380),vec2(-0.0180,0.8230),vec2(-0.0060,0.7790),vec2(0.0040,0.7320),vec2(-0.0110,0.7770),\n        vec2(-0.0180,0.7750),vec2(-0.0040,0.8050),vec2(-0.0720,0.7560),vec2(-0.0720,0.7610),vec2(-0.0630,0.7620),vec2(-0.0500,0.6190),\n        vec2(-0.0550,0.6440),vec2(-0.0120,0.6160),vec2(-0.0430,0.5990),vec2(-0.0550,0.6550),vec2(-0.0340,0.7700),vec2(-0.0260,0.7720),\n        vec2(-0.0200,0.5900),vec2(-0.0340,0.5890),vec2(-0.0250,0.5840),vec2(0.0000,0.6470),vec2(0.0060,0.8370),vec2(0.0360,0.8240),\n        vec2(0.0140,0.7950),vec2(0.0110,0.8170),vec2(0.0390,0.8830),vec2(0.0440,0.8160),vec2(0.0410,0.8000),vec2(0.0530,0.7640),\n        vec2(0.0300,0.7950),vec2(0.0530,0.8060),vec2(0.0040,0.7840),vec2(0.0150,0.7880),vec2(0.0240,0.7490),vec2(0.0210,0.6550),\n        vec2(0.0120,0.6570),vec2(0.0340,0.6850),vec2(0.0370,0.7020),vec2(0.0530,0.7170),vec2(0.0300,0.6470),vec2(0.0490,0.6750),\n        vec2(0.0410,0.6800),vec2(0.0440,0.6080),vec2(0.0340,0.6340),vec2(0.0810,0.6250),vec2(0.0570,0.6700),vec2(0.0460,0.9820),\n        vec2(0.0690,0.9700),vec2(0.0620,0.9920),vec2(0.0660,0.9840),vec2(0.0560,0.9950),vec2(0.0900,0.9810),vec2(0.0760,0.9650),\n        vec2(0.1030,1.0100),vec2(0.0790,0.9530),vec2(0.0900,0.9560),vec2(0.0990,0.9590),vec2(0.0930,0.9050),vec2(0.1280,0.9090),\n        vec2(0.0730,0.8220),vec2(0.0760,0.8150),vec2(0.0700,0.8100),vec2(0.0810,0.9020),vec2(0.1230,0.9040),vec2(0.0920,0.8980),\n        vec2(0.0930,0.9030),vec2(0.0860,0.8490),vec2(0.0880,0.8730),vec2(0.1070,0.8770),vec2(0.0910,0.8880),vec2(0.1110,1.1120),\n        vec2(0.1240,1.1010),vec2(0.1300,1.0950),vec2(0.1030,0.9990),vec2(0.1380,0.9100),vec2(0.1380,0.9660),vec2(0.1420,0.9650),\n        vec2(0.1590,0.9580),vec2(0.1720,0.9450),vec2(0.1780,0.9300),vec2(0.1690,0.9160),vec2(0.1010,0.8290),vec2(0.1100,0.8180),\n        vec2(0.1180,0.8270),vec2(0.1220,0.8220),vec2(0.1060,0.8160),vec2(0.1260,0.8170),vec2(0.1240,0.8200),vec2(0.1760,0.7730),\n        vec2(0.1150,0.7750),vec2(0.1400,0.7750),vec2(0.0680,0.7670),vec2(0.0650,0.8080),vec2(0.0900,0.7720),vec2(0.0570,0.8060),\n        vec2(0.0470,0.8020),vec2(0.0770,0.8110),vec2(0.0790,0.8110),vec2(0.0950,0.8140),vec2(0.1020,0.7730),vec2(0.1000,0.7680),\n        vec2(0.0930,0.7570),vec2(0.0830,0.7460),vec2(0.0700,0.7330),vec2(0.0790,0.6550),vec2(0.0740,0.5920),vec2(0.0670,0.5940),\n        vec2(0.0760,0.6020),vec2(0.0930,0.6570),vec2(0.0820,0.6590),vec2(0.1010,0.6750),vec2(0.1060,0.6790),vec2(0.1080,0.5400),\n        vec2(0.1020,0.5420),vec2(0.1010,0.5380),vec2(0.1260,0.7040),vec2(0.1290,0.6980),vec2(0.1970,0.7240),vec2(0.2060,0.7130),\n        vec2(0.2100,0.6920),vec2(0.1330,0.6890),vec2(0.1230,0.7080),vec2(0.1260,0.6290),vec2(0.1110,0.6440),vec2(0.1310,0.6380),\n        vec2(0.1140,0.6220),vec2(0.1360,0.6850),vec2(0.1410,0.6900)\n    );\n    IT(24,25,27)IT(27,23,24)IT(20,31,32)IT(30,20,21)IT(23,90,22)IT(90,23,27)IT(30,21,28)IT(30,91,20)IT(20,32,18)IT(32,92,15)\n    IT(93,31,20)IT(91,93,20)IT(32,15,18)IT(22,94,21)IT(17,18,15)IT(95,96,97)IT(98,95,99)IT(98,100,101)IT(100,98,99)IT(95,97,99)\n    IT(102,101,100)IT(103,104,105)IT(104,103,106)IT(104,106,107)IT(108,109,105)IT(110,102,105)IT(109,103,105)IT(105,102,108)IT(107,111,104)IT(112,102,110)\n    IT(90,113,22)IT(114,94,22)IT(21,115,28)IT(32,33,92)IT(14,33,13)IT(116,117,118)IT(92,33,14)IT(119,120,116)IT(113,114,22)IT(40,121,12)\n    IT(116,118,122)IT(117,123,118)IT(124,123,117)IT(121,124,117)IT(12,13,40)IT(94,115,21)IT(119,116,122)IT(125,126,119)IT(119,127,125)IT(120,119,126)\n    IT(127,104,111)IT(128,129,104)IT(130,131,132)IT(129,133,132)IT(134,131,135)IT(127,128,104)IT(127,111,125)IT(136,137,138)IT(137,136,130)IT(130,132,133)\n    IT(139,140,130)IT(141,136,138)IT(133,129,128)IT(131,130,142)IT(143,134,144)IT(11,145,146)IT(11,146,147)IT(9,147,148)IT(149,145,11)IT(11,147,9)\n    IT(148,150,9)IT(150,101,112)IT(112,79,150)IT(79,112,78)IT(101,102,112)IT(79,151,9)IT(80,152,151)IT(153,154,155)IT(154,156,155)IT(157,152,76)\n    IT(80,151,79)IT(79,9,150)IT(158,159,160)IT(160,8,158)IT(161,162,163)IT(164,161,163)IT(162,165,3)IT(8,160,166)IT(166,167,6)IT(167,154,6)\n    IT(156,154,167)IT(163,168,164)IT(162,3,163)IT(169,168,170)IT(169,164,168)IT(163,3,171)IT(8,166,6)IT(85,77,84)IT(78,112,144)IT(85,86,77)\n    IT(76,152,172)IT(77,86,75)IT(86,173,75)IT(174,157,175)IT(77,144,84)IT(175,157,76)IT(144,112,143)IT(176,131,142)IT(135,144,134)IT(177,75,173)\n    IT(178,179,180)IT(172,175,76)IT(181,75,177)IT(135,84,144)IT(176,135,131)IT(182,174,183)IT(182,157,174)IT(183,184,182)IT(183,179,184)IT(184,154,153)\n    IT(3,4,171)IT(4,185,186)IT(4,186,171)IT(4,187,185)IT(182,184,153)IT(179,183,180)IT(5,188,187)IT(65,188,189)IT(187,188,65)IT(190,185,191)\n    IT(185,187,192)IT(193,194,195)IT(190,196,194)IT(191,185,192)IT(187,4,5)IT(172,152,80)IT(130,140,142)IT(141,197,198)IT(121,40,124)IT(39,40,13)\n    IT(35,39,13)IT(199,200,197)IT(198,197,200)IT(198,136,141)IT(201,199,197)IT(41,202,203)IT(39,35,37)IT(202,41,204)IT(205,136,203)IT(206,207,208)\n    IT(203,202,205)IT(208,207,209)IT(139,130,136)IT(88,81,83)IT(88,83,87)IT(87,83,140)IT(87,140,139)IT(210,211,81)IT(89,210,81)IT(88,89,81)\n    IT(81,211,212)IT(213,139,136)IT(213,205,208)IT(214,215,216)IT(205,206,208)IT(217,218,49)IT(219,218,220)IT(215,219,220)IT(218,219,49)IT(214,216,208)\n    IT(205,213,136)IT(50,217,49)IT(221,39,37)IT(13,33,35)IT(38,221,222)IT(222,223,38)IT(224,48,207)IT(46,224,204)IT(44,204,43)IT(204,41,43)\n    IT(46,204,44)IT(38,39,221)IT(48,224,46)IT(225,226,227)IT(225,228,229)IT(227,228,225)IT(229,230,231)IT(207,48,226)IT(207,226,209)IT(215,214,219)\n    IT(50,51,232)IT(233,234,235)IT(233,232,51)IT(236,233,237)IT(51,234,233)IT(238,233,235)IT(50,232,217)IT(209,226,225)IT(229,231,225)IT(238,237,233)\n    IT(62,53,54)IT(52,53,239)IT(236,237,240)IT(208,209,214)IT(52,241,237)IT(242,243,244)IT(245,243,242)IT(179,246,242)IT(246,245,242)IT(244,243,212)\n    IT(246,75,181)IT(244,247,248)IT(248,249,244)IT(249,236,250)IT(212,211,247)IT(250,244,249)IT(251,63,252)IT(63,253,252)IT(65,253,63)IT(244,212,247)\n    IT(65,189,254)IT(194,196,255)IT(256,257,258)IT(193,258,257)IT(195,258,193)IT(259,195,255)IT(255,195,194)IT(255,260,259)IT(196,190,191)IT(66,261,259)\n    IT(261,66,262)IT(263,264,0)IT(263,265,264)IT(262,66,68)IT(66,259,260)IT(65,254,253)IT(63,251,250)IT(178,246,179)IT(240,63,250)IT(237,241,240)\n    IT(240,250,236)IT(68,266,267)IT(62,56,60)IT(62,239,53)IT(56,58,60)IT(268,269,71)IT(241,52,239)IT(269,270,71)IT(271,262,267)IT(68,272,266)\n    IT(262,68,267)IT(273,274,275)IT(1,74,0)IT(1,72,74)IT(276,274,273)IT(0,74,263)IT(271,277,262)IT(278,69,72)IT(270,72,69)IT(275,72,2)\n    IT(72,277,278)IT(72,275,277)IT(274,277,275)IT(72,1,2)IT(262,277,274)IT(71,270,69)IT(56,62,54)IB(0,1,2)IB(3,4,5)IB2(6,7,8)\n    IB2(9,10,11)IB(12,13,14)IB2(15,16,17)IB2(18,19,20)IB(20,21,22)IB(22,23,24)IB2(25,26,27)IB2(28,29,30)IB(31,32,33)IB2(33,34,35)\n    IB2(35,36,37)IB(38,39,40)IB2(41,42,43)IB2(44,45,46)IB2(46,47,48)IB(49,50,51)IB(52,53,54)IB2(54,55,56)IB2(56,57,58)IB2(58,59,60)\n    IB2(60,61,62)IB2(63,64,65)IB2(66,67,68)IB2(69,70,71)IB2(72,73,74)IB2(75,76,77)IB(78,79,80)IB2(81,82,83)IB(84,85,86)IB(87,88,89)\n    return d;\n    }\n    return d;\n}\n\nfloat GAM(vec2 uv)\n{\n    uv *= 0.4;\n    uv += vec2(0.275, 0.85);\n    float d = GA(uv);\n    uv.x -= 0.35;\n    d = min(d, MU(uv));\n    return d;\n}\n\nvec2 hash( vec2 x )\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat fbm(vec2 uv, float s)\n{\n    uv *= s;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tfloat f  = 0.5000*noise( uv ); uv = m*uv;\n\tf += 0.2500*noise( uv ); uv = m*uv;\n\tf += 0.1250*noise( uv ); uv = m*uv;\n\tf += 0.0625*noise( uv ); uv = m*uv;\n    return f * 0.5 + 0.5;\n}\n\nfloat pingpong(float t, float len, float smo)\n{\n  t = mod(t + smo, len * 2.);\n  return 1.0 - (smoothstep(0., smo, t) - smoothstep(len, len + smo, t));\n}\n\nfloat getColor(vec2 uv) {\n\tuv += (vec2(fbm(vec2(iTime * 0.1), 1.0), fbm(vec2(iTime * 0.1 + 114.514), 1.0)) * 2.0 - 1.0) * 0.5;\n\tuv.x += tan(uv.y * iTime * 100.0 * rand(vec2(iTime))) * 0.04 * smoothstep(0.54, 0.7, fbm(vec2(iTime * 1.0), 1.0));\n\n    float fill = step(0.00000001, GAM(uv));\n    fill = clamp(fill + smoothstep(0.58, 0.63, fbm(uv, 8.)), 0.0, 0.8);\n    fill = clamp(fill - smoothstep(0.6, 0.65, fbm(uv, 12.)) * (1.0 - smoothstep(0.8, 0.95, length(uv * vec2(1.0, 1.1)))), 0.0, 0.8);\n    return mix(fill, 1.0 - fill, pingpong(iTime, 6.0, 1.0));\n}\n\nfloat aaGetColor(vec2 p) {\n    float col = 0.0;\n    const int num = 4;\n    \n    for (int i = 0; i < num; i++) {\n        float fi = float(i + 1);\n    \tcol += getColor(p + vec2(step(fi, 2.001), mod(fi, 2.001)) * vec2(0.002, 0.0028));\n    }\n    return col / float(num);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 mouse = (iMouse.zw / iResolution.xy) * 2.0 - 1.0;\n    mouse.x *= iResolution.x / iResolution.y;\n    \n    if (distance(mouse, uv) < 0.75) {\n        float zoom = 5.0;\n        uv += mouse * (zoom - 1.0);\n        uv /= zoom;\n    }\n    \n    #ifdef AA\n    \tfloat fill = aaGetColor(uv);\n    #else\n    \tfloat fill = getColor(uv);\n    #endif\n    \n    // Simple vignette effect by Ippokratis\n    // https://www.shadertoy.com/view/lsKSWR\n    uv = fragCoord.xy / iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 200.0;\n    vig = pow(vig, 0.1);\n    fragColor = vec4(vec3(vig * fill), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ttyRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[175, 175, 205, 205, 231], [459, 459, 519, 519, 789], [984, 984, 1016, 1016, 1054], [19014, 19014, 19034, 19034, 19158], [19160, 19160, 19181, 19181, 19319], [19321, 19321, 19341, 19341, 19413], [19415, 19415, 19441, 19441, 19839], [19841, 19841, 19870, 19870, 20109], [20111, 20111, 20158, 20158, 20263], [20265, 20265, 20290, 20290, 20820], [20822, 20822, 20848, 20848, 21090], [21092, 21092, 21149, 21149, 21864]], "test": "error"}
{"id": "4tVyRz", "name": "Sine Grid Warping", "author": "coler706", "description": "Discovered While Playing around in Desmos", "tags": ["2d", "grid", "sine", "hexagons"], "likes": 17, "viewed": 405, "published": "Public", "date": "1534872555", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float q(vec2 pos,float angle){\n    return pos.x*cos(angle)+pos.y*sin(angle);\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pi=atan(1.0,0.0)*2.0;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 pos=(uv-vec2(0.5))*iResolution.xy/iResolution.y*100.0;\n    float s=iTime/5.0;\n    float angle=atan(pos.y,pos.x)+s/2.0;\n    pos=length(pos)*vec2(cos(angle),sin(angle));\n    float c=cos(q(pos,pi/3.0))+cos(q(pos,0.0))+cos(q(pos,s+pi/3.0))+cos(q(pos,s+0.0))+cos(q(pos,pi/3.0*2.0))+cos(q(pos,s+pi/3.0*2.0));\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+c+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col*(-c),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tVyRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 78], [84, 84, 141, 141, 725]], "test": "ok"}
{"id": "ll2XDy", "name": "blue dots", "author": "TinyTexel", "description": "a shader", "tags": ["bloom", "glow", "blue", "dots"], "likes": 20, "viewed": 397, "published": "Public", "date": "1534620148", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst float Pi = 3.14159265359;\n\n#define Time iTime\n#define Frame iGlobalFrame\n#define PixelCount iResolution.xy\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define mad(x, a, b) ((x) * (a) + (b))\n#define rsqrt(x) inversesqrt(x)\n\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\n\n    \nfloat SDFtoMask(float sdf)\n{\n   return sdf / length(vec2(dFdx(sdf), dFdy(sdf))) * 1.2; \n}\n\nfloat Hash(float v)\n{\n    return fract(sin(v) * 43758.5453);\n}\n\nfloat Hash(vec2 v)\n{\n\treturn Hash(v.y + v.x * 12.9898);\n}\n\nfloat Hash(vec3 v)\n{\n\treturn Hash(v.y + v.x * 12.9898 + v.z * 33.7311);\n}\n\n\nfloat Pow2(float v){return v * v;}\nfloat Pow3(float v){return v * v * v;}\nfloat Pow4(float v){return Pow2(Pow2(v));}\nfloat Pow8(float v){return Pow2(Pow4(v));}\nfloat Pow16(float v){return Pow4(Pow4(v));}\nfloat Pow32(float v){return Pow16(Pow2(v));}\n\nfloat SqrLen(vec2 v){return dot(v, v);}\nfloat SqrLen(vec3 v){return dot(v, v);}\nfloat SqrLen(vec4 v){return dot(v, v);}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//=============================================================================================================================================//\n// \"Hash without Sine\"        | https://www.shadertoy.com/view/4djSRW \n//  Created by David Hoskins  | \n//  used under CC BY-SA 4.0   | https://creativecommons.org/licenses/by-sa/4.0/             \n//  reformatted from original |              \n//---------------------------------------------------------------------------------------------------------------------------------------------//\n\n// Use this for integer stepped ranges, ie Value-Noise/Perlin noise functions.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\nfloat Hash11I(float p ){vec3 p3 = fract(vec3(p     ) * HASHSCALE1); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.x    + p3.y   ) * p3.z   );}\nfloat Hash12I(vec2  p ){vec3 p3 = fract(vec3(p.xyx ) * HASHSCALE1); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.x    + p3.y   ) * p3.z   );}\nfloat Hash13I(vec3  p3){     p3 = fract(    (p3    ) * HASHSCALE1); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.x    + p3.y   ) * p3.z   );}\nvec2  Hash21I(float p ){vec3 p3 = fract(vec3(p     ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xx   + p3.yz  ) * p3.zy  );}\nvec2  Hash22I(vec2  p ){vec3 p3 = fract(vec3(p.xyx ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xx   + p3.yz  ) * p3.zy  );}\nvec2  Hash23I(vec3  p3){     p3 = fract(    (p3    ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xx   + p3.yz  ) * p3.zy  );}\nvec3  Hash31I(float p ){vec3 p3 = fract(vec3(p     ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xxy  + p3.yzz ) * p3.zyx );}\nvec3  Hash32I(vec2  p ){vec3 p3 = fract(vec3(p.xyx ) * HASHSCALE3); p3 += dot(p3, p3.yxz  + 19.19); return fract((p3.xxy  + p3.yzz ) * p3.zyx );}\nvec3  Hash33I(vec3  p3){     p3 = fract(    (p3    ) * HASHSCALE3); p3 += dot(p3, p3.yxz  + 19.19); return fract((p3.xxy  + p3.yxx ) * p3.zyx );}\nvec4  Hash41I(float p ){vec4 p4 = fract(vec4(p     ) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\nvec4  Hash42I(vec2  p ){vec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\nvec4  Hash43I(vec3  p ){vec4 p4 = fract(vec4(p.xyzx) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\nvec4  Hash44I(vec4  p4){     p4 = fract(    (p4    ) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\n \n#undef HASHSCALE1\n#undef HASHSCALE3\n#undef HASHSCALE4\n\n//---------------------------------------------------------------------------------------------------------------------------------------------//\n\n// For smaller input rangers like audio tick or 0-1 UVs use these...\n#define HASHSCALE1 443.8975\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n#define HASHSCALE4 vec4(443.897, 441.423, 437.195, 444.129)\n\nfloat Hash11F(float p ){vec3 p3 = fract(vec3(p     ) * HASHSCALE1); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.x    + p3.y   ) * p3.z   );}\nfloat Hash12F(vec2  p ){vec3 p3 = fract(vec3(p.xyx ) * HASHSCALE1); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.x    + p3.y   ) * p3.z   );}\nfloat Hash13F(vec3  p3){     p3 = fract(    (p3    ) * HASHSCALE1); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.x    + p3.y   ) * p3.z   );}\nvec2  Hash21F(float p ){vec3 p3 = fract(vec3(p     ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xx   + p3.yz  ) * p3.zy  );}\nvec2  Hash22F(vec2  p ){vec3 p3 = fract(vec3(p.xyx ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xx   + p3.yz  ) * p3.zy  );}\nvec2  Hash23F(vec3  p3){     p3 = fract(    (p3    ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xx   + p3.yz  ) * p3.zy  );}\nvec3  Hash31F(float p ){vec3 p3 = fract(vec3(p     ) * HASHSCALE3); p3 += dot(p3, p3.yzx  + 19.19); return fract((p3.xxy  + p3.yzz ) * p3.zyx );}\nvec3  Hash32F(vec2  p ){vec3 p3 = fract(vec3(p.xyx ) * HASHSCALE3); p3 += dot(p3, p3.yxz  + 19.19); return fract((p3.xxy  + p3.yzz ) * p3.zyx );}\nvec3  Hash33F(vec3  p3){     p3 = fract(    (p3    ) * HASHSCALE3); p3 += dot(p3, p3.yxz  + 19.19); return fract((p3.xxy  + p3.yxx ) * p3.zyx );}\nvec4  Hash41F(float p ){vec4 p4 = fract(vec4(p     ) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\nvec4  Hash42F(vec2  p ){vec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\nvec4  Hash43F(vec3  p ){vec4 p4 = fract(vec4(p.xyzx) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\nvec4  Hash44F(vec4  p4){     p4 = fract(    (p4    ) * HASHSCALE4); p4 += dot(p4, p4.wzxy + 19.19); return fract((p4.xxyz + p4.yzzw) * p4.zywx);}\n\n#undef HASHSCALE1\n#undef HASHSCALE3\n#undef HASHSCALE4\n\n//=============================================================================================================================================//\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n/*\nfloat PowL_Exp(float x, const float f)\n{\n    const float d = 1.0 / (exp2(f) - 1.0);\n    \n    return mad(exp2(x * f), d, -d);\n}\n*/\n\nfloat EvalIntensityCurve(vec2 id, float time)\n{\n    time += Hash(id.yx * 1.733);\n    //time += Hash12I(id.yx);\n    \n    float iTime = floor(time);\n    float fTime = fract(time);\n    \n    float h = Hash(vec3(id, iTime));\n    //float h = Hash13I(vec3(id, iTime));\n    \n    //if(h < 0.9) h = 0.0;\n    //h = fract(id.x*0.23+id.y*0.1+iTime*0.09);\n    h *= h;\n    h *= h;\n    \n    float falloff = 1.0 - Pow2(fTime * 2.0 - 1.0);\n    \n    /*\n    falloff = Pow32(falloff);\n    /*/\n    {\n        const float f = 100.0;\n        const float d = 1.0 / (exp2(f) - 1.0);\n\n        falloff = mad(exp2(falloff * f), d, -d);\n    }\n    //*/\n    \n    //falloff = exp2(falloff * 100.1) - 1.0;\n    //falloff /= exp2(1.0 * 100.1) - 1.0;\n    \n    return h * falloff*1.0;\n}\n\nfloat GlowKern1(float x, float s)\n{\n    float rx = sqrt(x);\n    \n    return (exp(-s * rx) * s) / (2.0 * rx);\n}\n\nfloat GlowKern2(float x, float s)\n{\n    float rx = sqrt(x);\n    \n    return s / (2.0 * Pow2(1.0 + s * rx) * rx);\n}\n\nfloat GlowKern3(float x, float s)\n{    \n    return s / Pow3(1.0 + s * x);\n}\n\nfloat GlowKern4(float x, float c)\n{\n    return c * rsqrt(x * Pow3(x + c)) * 0.5;\n}\n\nfloat CurveU(float x, float u)\n{\n    return (u - u * x) / (u + x);\n}\n\nfloat EvalGlow3(vec2 uv, vec2 off, float time)\n{\n    vec2 iUV = floor(uv) + off;\n    vec2 fUV = fract(uv) - off;\n\n    vec2 fUV2 = fUV * 2.0 - 1.0;\n    \n    float dist2 = SqrLen(fUV2);\n    \n    float l = length(fUV2);\n    l = max(0.0, l - 0.7);\n    float glow = 0.0;\n    //glow = GlowKern1(l, 2.5);\n    //glow = GlowKern2(l, 4.0);\n    glow = GlowKern3(l, 1.2);\n  //glow = GlowKern4(l, 0.4);\n    //glow = CurveU(l * 0.25, 0.04);\n    \n    glow = clamp01(glow);\n    \n    glow *= clamp01(1.0 - Pow2(l*0.25));// window\n    \n    return EvalIntensityCurve(iUV.xy, time) * glow;\n}\n\n\nfloat PlotDot(vec2 sp, vec2 dp, float dr)\n{\n    float v = length(sp - dp);\n    \n    float d = v - dr;\n    //return d < 0.0 ? 1.0 : 0.0;\n    d /= length(vec2(dFdx(v), dFdy(v)));   \n    //d += 0.5;\n    d = clamp01(1.0 - d * 1.2);\n    \n    return d;\n}\n\nfloat EvalGlyph(vec2 uv, vec2 off, float time)\n{\n    vec2 iUV = floor(uv) + off;\n    vec2 fUV = fract(uv) - off;\n\n    vec2 fUV2 = fUV * 2.0 - 1.0;\n    \n    float distToCenter = length(fUV2);\n    \n    float gMask = distToCenter - 0.75;\n    \t  gMask = SDFtoMask(gMask);\n          gMask = clamp01(1.0 - gMask);\n    \n    gMask = PlotDot(fUV2, vec2(0.0), 0.75);\n    \n    return EvalIntensityCurve(iUV.xy, time) * gMask;\n}\n\n\nvec3 EvalTile(vec2 uv, vec2 off, float time)\n{\n    vec2 iUV = floor(uv) + off;\n    vec2 fUV = fract(uv) - off;\n\n    vec3 blue1 = vec3(0.02, 0.1, 1.0);\n    \n    float nTime = time*50.0;\n    float iTime = floor(nTime);\n    float fTime = fract(nTime);\n    \n    float n0 = Hash(vec3(uv, iTime));\n    float n1 = Hash(vec3(uv, iTime + 1.0));\n\n    //n0 = n1 = 1.0;\n    \n    float glyph = EvalGlyph(uv, off, time);\n    \n    float glow = 0.0;\n    \n    for(float i = -2.0; i <= 2.0; ++i)\n    for(float j = -2.0; j <= 2.0; ++j)\n    {\n        glow += EvalGlow3(uv, off + vec2(i, j), time); \n    }\n    \n\n\treturn vec3(mix(glow, glyph, 0.94)).xxx * blue1 * 32.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 uv0 )\n{\n\tvec2 uv = uv0.xy / iResolution.xy;\n    \n    vec2 coord = (uv0.xy - 0.5) * 0.1;\n    float time = iTime * 0.1;\n     \n    \n    \n    \n    vec3 outCol = vec3(1.0, 1.0, 1.0);\n    \n    outCol = vec3(0.0);\n    \n\toutCol = EvalTile(coord, vec2(0.0), time);\n    \n    //outCol = EvalTile(coord, vec2(0.0, 0.0), time);\n    \n    //fragColor = vec4(vec3(saturate(gMask)).xxx * vec3(Hash(iCoord)).xxx, 1.0); return;\n    //fragColor = vec4(outCol.xyz, 1.0); return;\n    fragColor = vec4(GammaEncode(clamp01(outCol.xyz)), 1.0); return;\n\n\t//fragColor = vec4(uv,0.5+0.5*sin(iTime*0.0),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll2XDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[224, 224, 250, 250, 282], [289, 289, 317, 317, 378], [380, 380, 401, 401, 442], [444, 444, 464, 464, 501], [503, 503, 523, 523, 576], [579, 579, 599, 599, 613], [614, 614, 634, 634, 652], [653, 653, 673, 673, 695], [696, 696, 716, 716, 738], [739, 739, 760, 760, 782], [783, 783, 804, 804, 827], [829, 829, 850, 850, 868], [869, 869, 890, 890, 908], [909, 909, 930, 930, 948], [1833, 1833, 1857, 1857, 1978], [1979, 1979, 2003, 2003, 2124], [2125, 2125, 2149, 2149, 2270], [2271, 2271, 2295, 2295, 2416], [2417, 2417, 2441, 2441, 2562], [2563, 2563, 2587, 2587, 2708], [2709, 2709, 2733, 2733, 2854], [2855, 2855, 2879, 2879, 3000], [3001, 3001, 3025, 3025, 3146], [3147, 3147, 3171, 3171, 3292], [3293, 3293, 3317, 3317, 3438], [3439, 3439, 3463, 3463, 3584], [3585, 3585, 3609, 3609, 3730], [4144, 4144, 4168, 4168, 4289], [4290, 4290, 4314, 4314, 4435], [4436, 4436, 4460, 4460, 4581], [4582, 4582, 4606, 4606, 4727], [4728, 4728, 4752, 4752, 4873], [4874, 4874, 4898, 4898, 5019], [5020, 5020, 5044, 5044, 5165], [5166, 5166, 5190, 5190, 5311], [5312, 5312, 5336, 5336, 5457], [5458, 5458, 5482, 5482, 5603], [5604, 5604, 5628, 5628, 5749], [5750, 5750, 5774, 5774, 5895], [5896, 5896, 5920, 5920, 6041], [6526, 6526, 6573, 6573, 7273], [7275, 7275, 7310, 7310, 7385], [7387, 7387, 7422, 7422, 7501], [7503, 7503, 7538, 7538, 7578], [7580, 7580, 7615, 7615, 7662], [7664, 7664, 7696, 7696, 7732], [7734, 7734, 7782, 7782, 8305], [8308, 8308, 8351, 8351, 8556], [8558, 8558, 8606, 8606, 8974], [8977, 8977, 9023, 9023, 9626], [9628, 9628, 9679, 9679, 10253]], "test": "ok"}
{"id": "ll3cWs", "name": "Simple fractal", "author": "drcd1", "description": "First shader. Testing the render of a mandelbulb fractal in shadertoy. Rotate the fractal with the left mouse button.\nThe power in the sequence formula (z_{n+1} = z_{n}^p + c ) varies between 2 and 8.", "tags": ["fractal"], "likes": 0, "viewed": 45, "published": "Public", "date": "1534623160", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_ITER_SM 50\n#define MAX_ITER_FRACTAL 10\n#define M_PI 3.14159265358979323846 \nstruct ray {\n\tvec3 o;\n    vec3 d;\n};\nstruct sphere{\n\tvec3 o;\n    float size;\n};\nstruct intersection{\n    vec3 n;\n};\n\nfloat de(vec3 x){\t \n    float power = 8.0f;\n    vec3 z = x;\n    float dr = 1.0f;\n    float r = 0.0f;\n    for (int i = 0; i <5 ; i++) {\n        r = length(z);\n        if (r>2.0f) break;\n\n        float phi = asin(z.z/r);\n        float theta = atan(z.y,z.x);\n        dr =  pow( abs(r), power-1.0f)*power*dr + 1.0f;\n\n        float zr = pow( abs(r),power);\n\n        phi = phi*power;\n        theta = theta*power;\n\n        z = vec3(cos(theta)*cos(phi), sin(phi)*cos(theta), -sin(theta))*zr;\n        z = z+x;\n    }\n    return 0.5*log(r)*r/dr;\n}\n\n\nfloat de(vec3 x, float power){\t \n    vec3 z = x;\n    float dr = 1.0f;\n    float r = 0.0f;\n    for (int i = 0; i < MAX_ITER_FRACTAL ; i++) {\n        r = length(z);\n        if (r>2.0f) break;\n        float phi = asin(z.z/r);\n        float theta = atan(z.y,z.x);\n        dr =  dr*pow( abs(r), power-1.0f)*power + 1.0f;\n        float zr = pow( abs(r),power);\n        phi = phi*power;\n        theta = theta*power;\n        z = vec3(cos(theta)*cos(phi), sin(theta)*cos(phi), -sin(phi))*zr;\n        z = z+x;\n    }\n    return 0.5*log(r)*r/dr;\n}\nvec3 grad(vec3 x){\n    vec3 dx = vec3(1e-3f,0,0);\n    vec3 dy = vec3(0,1e-3f,0);\n    vec3 dz = vec3(0,0,1e-3f);\n\treturn vec3((de(x+dx)-de(x))*1e3f,(de(x+dy)-de(x))*1e3f,(de(x+dz)-de(x))*1e3f);\n}\nstruct sm_ret{\n\tfloat t;\n    int it;\n};\nsm_ret spheremarch(ray r, float minT, float maxT, float power){\n    int i;\n    sm_ret ret;\n\tfloat t = minT;\n    while(i<MAX_ITER_SM && t<maxT){\n        vec3 x = r.o + r.d*t;\n        float dist = de(x, power);\n        t+=dist;\n        if(dist<1e-4){\n        \tbreak;\n        }\n       \ti++;\n    \t\n    }\n\tif(i==MAX_ITER_SM || t>=maxT)\n        t = maxT+1.0f;\n\n    ret.t = t;\n    ret.it = i;\n\treturn ret;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect = iResolution.x/iResolution.y;\n\n\tfloat theta = (iMouse.x/iResolution.x-0.5f)*2.0f*M_PI;\n\tfloat phi = iMouse.y/iResolution.y*M_PI;\n    mat3 rot;\n    \n    float a = cos(-theta);\n    float b = sin(-theta);\n    float c = cos(phi);\n    float d = sin(phi);\n    \n    rot[0][0]=a;\n    rot[1][0]=-b*c;\n    rot[2][0]= b*d;\n    rot[0][1]= b;\n    rot[1][1]= a*c;\n    rot[2][1]= -a*d;\n    rot[0][2]= 0.0f;\n    rot[1][2]= d;\n    rot[2][2]= c;\n    \n  \tray r;\n    r.o.x=0.0f;\n    r.o.y=0.0f;\n    r.o.z=2.0f;\n    \n\tr.d.x = (uv.x-0.5f)*aspect;\n    r.d.y = uv.y-0.5f;\n    r.d.z = -1.0f;\n    \n    r.o = rot*r.o;\n    r.d = rot*r.d;\n    \n    r.d = normalize(r.d);\n    float power = (cos(iTime*0.2f)+1.0f)*0.5f*6.0f+2.0f;\n\tvec3 col;\n    sm_ret ret= spheremarch(r,0.01f, 8.0f, power);\n    if(ret.t<8.0f){\n       \t// vec3 normal = grad(r.o + ret.t*r.d);\n       \t//col.x=col.y=col.z=max(dot(normal,normalize(vec3(1.0f,1.0f,1.0f))),0.0f);\n\t\tcol.x = col.y = col.z = 1.0f-float(ret.it)/float(MAX_ITER_SM);\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll3cWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[205, 205, 222, 222, 741], [744, 744, 774, 774, 1279], [1280, 1280, 1298, 1298, 1474], [1515, 1515, 1578, 1578, 1915], [1921, 1921, 1978, 2033, 3130]], "test": "ok"}
{"id": "ll3yDf", "name": "sphere noise", "author": "nabr", "description": " nothing special or crazy. so many stuff on the web, this is my attempt to create noise. yeah.", "tags": ["noise", "raymarch", "sphere", "complex"], "likes": 6, "viewed": 194, "published": "Public", "date": "1534365415", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// nabr\n// https://www.shadertoy.com/view/ll3yDf\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://creativecommons.org/licenses/by-nc-sa/3.0/\n\n\n// NOTE: this is for minimum distance check\n\n\n#define R(p, a) p = cos(a) * p + sin(a) * vec2(p.y, -p.x)\n#define eps 1e-3\n\n#define STEPS 128\n\nfloat map(vec3 p) \n{\n\t// note: i make this for my personal use, \n    // you have to play with thouse values in order to archive the desired effect\n    \n    float noise = \n        ( 0.1 / (cos(p.x * 0.01 - sin(p.z * cos(iTime - p.y)))))\n        / (/* 1.51 + */ 1.997 - cos((p.y * 2.001 - sin(p.x * cos(iTime - p.y)))));\n    \n    \n   /* // littel booster just in case\n   noise = min(noise * 1.5, \n                ( .1 / abs(cos(p.y * 1.001 - sin(p.z + cos(iTime + p.y * 3.14 )))))\n                / (1.001 + cos((p.x * .1 +  cos(iTime * 3.14- p.z)))));\n\t*/\n   \n    return min(noise,1.0 );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // setup scene\n    vec2 uv = 2.0 * (fragCoord.xy / iResolution.xy) - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(0.0, 0.0, -1.0 );\n    float cameraZ = 1.;\n    vec3 rd = normalize(vec3(uv,cameraZ));\n    \n    R(rd.yz, iTime * 0.43 );\n    R(rd.xz, iTime * 0.31 );\n\n    \n    // raymarch\n    \n    float t = 0.0;\n    \n    for(int i = 0; i < STEPS; i++) \n    {\n        t += map( ro + rd * t);\n\t\tif(t <  eps) break;\n    }\n    \n    \n    // ------- shade\n    vec3 ip = ro + rd * t;\n    fragColor.rgb = (t * vec3( 0.12, 0.2, 0.24)) * map(ip - 0.2) + t * 0.02;\n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll3yDf.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[333, 333, 353, 479, 921], [924, 924, 981, 1000, 1585]], "test": "ok"}
{"id": "ll3yDs", "name": "Juicy", "author": "leon", "description": "Shadertoy version of our 4kb demo at Evoke 2018", "tags": ["intro", "evoke", "froot"], "likes": 15, "viewed": 626, "published": "Public API", "date": "1534634108", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Juicy by ponk (code) + glafouk (music)\n// 4kb PC intro released at Evoke 2018\n// most lines below are from the community\n// licensed under hippie love conspiracy\n\n// pouet: https://www.pouet.net/prod.php?which=77683\n// github: https://github.com/leon196/Smoothie\n// youtube: https://www.youtube.com/watch?v=rn01yIpgonA\n\n#define repeat(p,r) (mod(p,r)-r/2.)\n#define time mod(iTime, 122.)\n\nconst float PI = 3.14159;\nconst float TAU = 6.283;\nconst float PIHALF = 1.7079;\nconst float PIQUART = 0.785397;\nconst float epsilon = .001;\nconst float steps = 100.;\nconst float far = 40.;\nconst float timeStart = 0.;\nconst float timeBouncy = 20.5;\nconst float timeGnacing = 41.5;\nconst float timeDropping = 51.;\nconst float timeSplashing = 61.5;\nconst float timeSwimming = 82.;\nconst float timeEnd = 122.;\nconst float speed = 1.5;\nconst float count = 8.;\nconst float size = 1.;\nconst float thin = .04;\n\nvoid add (inout vec4 a, vec4 b) { a = mix(b,a,step(a.z,b.z)); }\nfloat random (vec2 p) { vec3 p3  = fract(vec3(p.xyx) * 100.1031); p3 += dot(p3, p3.yzx + 19.19); return fract((p3.x + p3.y) * p3.z); }\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\nvoid toroidal (inout vec2 p, float r) { p = vec2(length(p)-r, atan(p.y,p.x)*r); }\nvoid polar (inout vec2 p, float c) {\n\tfloat an = TAU/c;\n\tfloat a = mod(atan(p.y,p.x)+an/2., an)-an/2.;\n\tp = vec2(cos(a), sin(a))*length(p);\n}\n\nvec4 geometry (vec3 pos)\n{\n\tvec4 scene;\n\tvec3 p, pp;\n\tfloat r, salt, z, angle, offset, ratio, number, anim, fall, splash, bouncy, gnac, cell, shape;\n\tscene.z = 10.;\n\tscene.xy = pos.xz;\n\tscene.w = 0.;\n\n\tratio = mod(time*speed, 1.);\n\tnumber = 1.+mod(floor(time*speed), 4.);\n\toffset = floor(time*speed);\n\n\t// bouncing\n\tif ((time < timeGnacing && time > timeBouncy) || time > timeSwimming) {\n\t\tp = pos;\n\t\tz = time*speed;\n\t\tif (time < timeSwimming) {\n\t\t\tp.z += 3.;\n\t\t\tp.yx *= rot(sin(floor(z)*1.5156));\n\t\t\tp.yz *= rot(sin(floor(z)*2.5156));\n\t\t}\n\t\tangle = z*25.;\n\t\tratio = mod(z, 1.);\n\t\tnumber = 1.+mod(floor(z), 4.);\n\t\tanim = smoothstep(.8,1.,ratio)+smoothstep(.2,.0,ratio);\n\t\tp.xy *= 1.+.4*anim*vec2(sin(angle), cos(angle));\n\n\t\t// gnacinc\n\t\tif (time > timeBouncy+10.7 && time < timeGnacing) {\n\t\t\tpp = p;\n\t\t\tcell = floor((atan(p.y,p.x)/PI*.5+.5)*5.);\n\t\t\tpolar(pp.xy, 5.);\n\t\t\tpp.x -= 1.+step(floor(ratio*8.), cell);\n\t\t\tshape = length(pp.xy)-.4;\n\t\t\tpolar(pp.xy, 16.);\n\t\t\tpp.x -= .4;\n\t\t\tshape = min(shape, length(pp.xy)-.1);\n\t\t\tadd(scene, vec4(p.xy/size, max(max(length(p)-size, abs(p.z)-thin), -shape), number));\n\n\t\t} else add(scene, vec4(p.xy/size, max(length(p)-size, abs(p.z)-thin), number));\n\t}\n\n\t// orbiting\n\tif (time < timeBouncy) {\n\t\tp = pos;\n\t\tp.y -= mix(10., 0., smoothstep(timeStart, timeBouncy/2., time));\n\t\tp.z -= mix(8., -2., smoothstep(timeBouncy/3., timeBouncy/1.5, time));\n\t\tp.xz *= rot(ratio*PI+PI/2.);\n\t\tadd(scene, vec4(p.xy/size, max(length(p)- size, abs(p.z)-thin), number));\n\n\t// swimming\n\t} else if (time < timeSwimming && time > timeSplashing) {\n\t\tpos.z += mix(4., -5., smoothstep(timeSplashing, timeSplashing + 10., time));\n\t\tpos.xz *= rot(-PI/2.);\n\t\tcell = 3.;\n\t\tz = pos.z + time;\n\t\tnumber = 1.+mod(floor(abs(z)/cell), 4.);\n\t\tr = number / 4.;\n\t\tpos.y += sin(pos.z * .2+time);\n\t\tp = pos;\n\t\tp.xy *= rot(pos.z*.1);\n\t\tp.x -= 4.;\n\t\tp.z = repeat(z, cell);\n\t\tp.y += sin(length(p.xz)*4.-time*5.+number)*.1;\n\t\tp.zx *= rot(sin(time+r*TAU+p.y)*.5);\n\t\tp.yz *= rot(sin(time*2.+r+p.x*2.)*.2);\n\t\tp.y = abs(p.y)-2.*mix(0., .5+.5*sin(number+time), smoothstep(65., 70., time));\n\t\tp.y = abs(p.y)-1.*mix(0., .5+.5*sin(number+time), smoothstep(70., 75., time));\n\t\tadd(scene, vec4(p.xz/size, max(length(p.xzy)-size, abs(p.y)-thin), number));\n\n\t// dropping\n\t} else if (time < timeDropping && time > timeGnacing) {\n\t\tpos.z -= 4.;\n\t\tpos.yz *= rot(PI/8.);\n\t\tfor (float index = count; index > 0.; --index) {\n\t\t\tr = index / count;\n\t\t\tp = pos;\n\t\t\tsalt = random(vec2(r+offset*.14598));\n\t\t\tfall = smoothstep(.0,.2,ratio);\n\t\t\tsplash = smoothstep(.2,.4,ratio);\n\t\t\tbouncy = smoothstep(.3,.2,ratio) * fall;\n\t\t\tp.y += ((fall*8.-8.+r)-(bouncy * abs(sin(time+r))*2.));\n\t\t\tangle = r*TAU+offset;\n\t\t\tp.xz += vec2(cos(angle), sin(angle)) * splash * (1.+4.*salt);\n\t\t\tp.xz *= rot(salt*TAU);\n\t\t\tp.zy *= rot(PI/2.-r*.1);\n\t\t\tadd(scene, vec4(p.xy/size, max(length(p)- size, abs(p.z)-thin), number));\n\t\t}\n\n\t// dancing\n\t} else if (time < timeEnd && time > timeSwimming) {\n\t\tp = pos;\n\t\tp.yz *= rot(PI/2.);\n\t\tp.xz *= rot(5.*smoothstep(timeSwimming+20., timeEnd, time));\n\t\ttoroidal(p.xz, 6.);\n\t\tp.z += p.y * .5;\n\t\tnumber = 1.+mod(abs(floor(p.z / PI)+floor((p.y-time*5.)/4.)), 4.);\n\t\tp.y = repeat(p.y-time*5., 4.);\n\t\tp.z = repeat(p.z, PI);\n\t\tp.xz *= rot(time+number);\n\t\tp.yz *= rot(time+number);\n\t\tadd(scene, vec4(p.xy/size, max(length(p)- size, abs(p.z)-thin), number));\n\t}\n\n\t// splashing\n\tif ((time < timeSplashing && time > timeDropping)){\n\t\tfor (float index = count; index > 0.; --index) {\n\t\t\tr = index / count;\n\t\t\tcell = time*speed/2.+r;\n\t\t\tratio = mod(cell, 1.);\n\t\t\tp = pos-vec3(0,0,5);\n\t\t\tp += vec3(sin(r*TAU*5.654+floor(cell))*7.*ratio, 5.-12.*smoothstep(.0,.7,ratio)+12.*smoothstep(.3,1.,ratio), index*.5);\n\t\t\tp.xz *= rot(ratio*8.);\n\t\t\tp.yz *= rot(r*5.456);\n\t\t\tadd(scene, vec4(p.xy/size, max(length(p)- size, abs(p.z)-thin), 1.+mod(floor(cell)+index, 4.)));\n\t\t}\n\t}\n\n\treturn scene;\n}\n\nvec4 raymarching (vec3 pos, vec3 ray, inout vec4 hit)\n{\n\tvec4 scene;\n\tfloat total = 0.;\n\tfloat dither = random(gl_FragCoord.xy/iResolution.xy);\n\tfor (float i = steps; i >= 0.; --i) {\n\t\tscene = geometry(pos);\n\t\tfloat dist = scene.z;\n\t\tif (scene.z < epsilon * total || total > far) {\n\t\t\thit.xyz = pos;\n\t\t\thit.w = i/steps;\n\t\t\tbreak;\n\t\t}\n\t\tdist *= .5 + .1 * dither;\n\t\ttotal += dist;\n\t\tpos += ray * dist;\n\t}\n\treturn scene;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 coordinate )\n{\n\tvec4 hit, scene;\n\tvec3 eye, ray, pos, color;\n\tvec2 uv = (gl_FragCoord.xy-.5*iResolution.xy)/iResolution.y;\n\tfloat cell, beat;\n\teye = vec3(0,0,-5);\n\tif (time > timeSwimming) eye.z = -.5-5. * smoothstep(timeSwimming, timeSwimming + 10., time);\n\tbeat = ((sin(time*25.))*(smoothstep(2., 1., abs(time-40.))+smoothstep(1.,.5,abs(time-51.))+smoothstep(1.,.5,abs(time-61.))))*.3;\n\tray = normalize(vec3(uv,1.+beat));\n\tscene = raymarching(eye, ray, hit);\n\tpos = hit.xyz;\n\n\tif (scene.w == 1.) color = vec3(1.0, 0.66, 0.0);\n\telse if (scene.w == 2.) color = vec3(0.376, 0.819, 0.278);\n\telse if (scene.w == 3.) color = vec3(1, 0.913, 0.341);\n\telse if (scene.w == 4.) color = vec3(1.0, 0.11, 0.05);\n\n\t// background\n\tif (length(color) == 0. || pos.z > far/1.5) {\n\t\tvec2 p = (coordinate.xy-.5*iResolution.xy)/iResolution.y;\n\t\tvec2 id = floor(p/.05);\n\t\tp = repeat(p, .05);\n\t\tp *= rot(time+random(id/20.)*TAU);\n\t\tp.x -= .05/4.;\n\t\tcolor = mix(vec3(.9,.5,.5), vec3(1,1,.7), uv.y);\n\t\tfloat n = .01+.99*random(id/10.);\n\t\tcolor += smoothstep(.005*n,.004*n,length(p));\n\n\t}\n\t// slice texture\n\telse {\n\t\tuv = scene.xy*.5;\n\t\tfloat dist = length(uv);\n\t\tfloat shade = smoothstep(.45, .5, dist)*.5+smoothstep(.475,.5, dist)*.5;\n\t\tfloat angle = atan(uv.y,uv.x);\n\t\tdist -= smoothstep(.0,1.,abs(sin(angle*5.))+.4)*.1 * dist;\n\t\tfloat pulp = abs(sin(angle*60.)*sin(dist*60.+sin(angle*60.)))*.25+.5;\n\t\tcolor = mix(vec3(1), color, clamp(shade+smoothstep(1.,.0,.1/abs(sin(angle*5.))) * smoothstep(.41,.4, dist) * smoothstep(.01,.02, dist) * pulp + (random(scene.xy * .5)*2.-1.)*.1, 0., 1.));\n\t}\n\n\t// droplets\n\tif (time > timeSplashing) {\n\t\tuv = (gl_FragCoord.xy-.5*iResolution.xy)/iResolution.y;\n\t\tif (time < timeSwimming) {\n\t\t\tuv.y = abs(uv.y)-.1;\n\t\t\tcell = floor((uv.x+.25)/.25)/1.5;\n\t\t\tuv.x = repeat(uv.x+.25, .25);\n\t\t} else {\n\t\t\tcell = 0.;\n\t\t\tpolar(uv.yx, 8.);\n\t\t\tuv.y -= .3;\n\t\t}\n\t\tfor (float i = 16.; i > 0.; --i) {\n\t\t\tfloat r = i / 16.;\n\t\t\tfloat salt = random(vec2(r*10.16));\n\t\t\tvec2 p = uv;\n\t\t\tfloat ratio = mod(time*speed+r*.1+cell, 1.);\n\t\t\tfloat number = 1.+mod(floor(r*.1+time*speed+cell), 4.);\n\t\t\tvec3 c;\n\t\t\tif (number == 1.) c = vec3(1.0, 0.66, 0.0);\n\t\t\telse if (number == 2.) c = vec3(0.376, 0.819, 0.278);\n\t\t\telse if (number == 3.) c = vec3(1, 0.913, 0.341);\n\t\t\telse if (number == 4.) c = vec3(1.0, 0.11, 0.05);\n\t\t\tfloat a = r*TAU*2.15498+floor(time*speed+r*.1+cell);\n\t\t\tp += vec2(cos(a),sin(a)) * ratio * (.5+.5*salt) * .25;\n\t\t\tp.y -= sin(ratio*PI) * .2;\n\t\t\tfloat size = .01;\n\t\t\tif (time < timeSwimming) size -= .005*salt*smoothstep(1.,.8,ratio);\n\t\t\telse size += .02*salt*smoothstep(1.,.8,ratio);\n\t\t\tcolor = mix(color, c, smoothstep(size,size-.002,length(p)));\n\t\t}\n\t}\n\n\tfragColor = vec4(color * clamp(abs(time), 0., 1.) * clamp(-(time-timeEnd), 0., 1.), 1);\n\n\t// heart\n\tvec2 p = (gl_FragCoord.xy-.5*iResolution.xy)/iResolution.y;\n\tp *= 1.5*smoothstep(timeEnd-15., timeEnd-5., time);\n\tp.y -= sin(sqrt(abs(p.x))) * .4;\n\tp.y *= 1.25;\n\tp.y += .1;\n\tfragColor *= smoothstep(.01, 0., length(p)-.5);\n}", "image_inputs": [{"id": "ls2SDV", "previewfilepath": "https://soundcloud.com/leon-denise/juicy-by-glafouk", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/leon-denise/juicy-by-glafouk", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll3yDs.jpg", "access": "shaders20k", "license": "unknown-license-reference", "functions": [[894, 894, 927, 927, 957], [958, 958, 981, 981, 1092], [1093, 1093, 1113, 1113, 1163], [1164, 1164, 1203, 1203, 1245], [1246, 1246, 1282, 1282, 1387], [1389, 1389, 1415, 1415, 5244], [5246, 5246, 5301, 5301, 5665], [5667, 5667, 5725, 5725, 8695]], "test": "ok"}
{"id": "ll3yzj", "name": "Moire Eyebleed", "author": "cacheflowe", "description": "Basic rows, calculated by texture noise", "tags": ["blackandwhite", "moire", "bw", "stripes"], "likes": 7, "viewed": 660, "published": "Public API", "date": "1533159463", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI     3.14159265358\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    uv.y += 0.4 * sin(uv.x * sin(iTime) + iTime);\n    float scroll = iTime / 20.;\n    vec2 noisePos = vec2(scroll + uv.x * 0.015, 0.5 + 0.5 * sin(scroll * PI));\n    float numLines = 40. + 160. * sin(PI * texture(iChannel0, noisePos).r);\n    float col = 0.5 + 0.5 * sin(uv.y * numLines);\n    float aA = 1./(iResolution.y / numLines) ;\n\tfragColor = vec4(smoothstep(0.5 - aA, 0.5 + aA, col));\n}\n    \n", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll3yzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 87, 87, 541]], "test": "error"}
{"id": "llccRf", "name": "Trippy Grid", "author": "TanayStyle", "description": "Waving grid", "tags": ["grid"], "likes": 1, "viewed": 81, "published": "Public", "date": "1533414503", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sin01(float x) {\n\treturn (sin(x)+1.)/2.;\n}\nfloat cos01(float x) {\n\treturn (cos(x)+1.)/2.;\n}\n\nfloat manDist(vec2 from, vec2 to) {\n    return abs(from.x - to.x) + abs(from.y - to.y);\n}\n\nfloat euclDist(vec2 from, vec2 to) {\n\treturn length(from - to);\n}\n\nvec2 randVec01(vec2 p) {\n    vec3 a = fract(vec3(sin(p.x), cos(p.y), cos(p.x)));\n    a += dot(a, a+ (sin01(iTime) - 1.5));\n    return smoothstep(0., 1., fract(vec2(a.x * a.y, a.y * a.z)));\n}\n\nfloat circ(float t, vec2 uv, vec2 pos, float radius) {\n    //float f01 = cos01(t + uv.x);\n    float f01 =  uv.x * 1.5;// * .5;\n    \n    float dist = f01 * euclDist(uv, pos) + (1. - f01) * manDist(uv, pos);\n    return smoothstep(radius, 0., dist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Adjust coordinates so 0,0 is in center\n    vec2 uv = (fragCoord - iResolution.xy/2.)/iResolution.xy; \n    float aspectRatio = iResolution.x / iResolution.y;\n\tuv.x *= aspectRatio;\n    \n    // Adjust speed of time\n    float t = iTime * 1.5;\n    \n    // Distort UV coordinates\n    float diff = cos01(t)*1.5 + 1.;\n    uv.xy += vec2(diff * 1., diff * .5);\n    \n    // Create grid\n    float gridSize = 2. * ( ((1.-abs(uv.x*uv.y))/1.5 + 1.) + sin01(t));\n    vec2 gridCoord = floor(uv * gridSize) / gridSize;\n    \n    // Get how far inside a cell we are\n    float cellRadius = .5 / gridSize;\n    vec2 cellCenter = gridCoord + cellRadius;\n    float inGrid = circ(t, uv, cellCenter, cellRadius);\n    float bright = inGrid * (sin01(uv.x + t*2.) + .4);\n    \n    // Color where bright (foreground color)\n    vec3 col = cos(t + uv.x + vec3(1.,0.,2.)) * bright;\n    \n    // Color where not bright (background color)\n    col += .3*(1. - cos(t + uv.x + vec3(.1,1.,2.)))* (1. - bright);\n    \n    // Add subtle flair\n    vec2 pos = randVec01(vec2(inGrid));\n    col.rb -= pos * (1. - uv.x) * sin01(t) * .1;\n    \n    // Output color to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llccRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 48], [49, 49, 71, 71, 97], [99, 99, 134, 134, 188], [190, 190, 226, 226, 255], [257, 257, 281, 281, 447], [449, 449, 503, 538, 697], [699, 699, 756, 802, 1918]], "test": "ok"}
{"id": "lldcDf", "name": "lightsdf", "author": "xiaosong0911", "description": "global illumination based on sdf -- following https://github.com/miloyip/light2d", "tags": ["sdf"], "likes": 53, "viewed": 2238, "published": "Public API", "date": "1535186629", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sphereSDF(vec2 p, float size) {\n\treturn length(p) - size;\n}\n\nfloat boxSDF(vec2 p, vec2 size) {\n\tvec2 r = abs(p) - size;\n    return min(max(r.x, r.y),0.) + length(max(r,vec2(0,0)));\n}\n\nvoid AddObj(inout float dist, inout vec3 color, float d, vec3 c) {\n    if (dist > d) {\n        dist = d;\n        color = c;\n    }\n}\n\nvoid scene(in vec2 pos, out vec3 color, out float dist) {\n    dist = 1e9; color = vec3(0,0,0);\n    AddObj(dist, color, boxSDF(pos - vec2(-3,1), vec2(1,1)), vec3(.6,.8,1.));\n    AddObj(dist, color, sphereSDF(pos - vec2(3,1), 1.), vec3(1,.9,.8));\n    AddObj(dist, color, sphereSDF(pos - vec2(.3*sin(iTime),-2), 0.5), vec3(0,.1,0));\n    AddObj(dist, color, boxSDF(pos - vec2(0,1), vec2(1.5,0.1)), vec3(.3,.1,.1));\n}\n\nvoid trace(vec2 p, vec2 dir, out vec3 c) {\n    for (;;) {\n        float d;\n        scene(p, c, d);\n        if (d < 1e-3) return;\n        if (d > 1e1) break;\n        p += dir * d;\n    }\n    c = vec3(0,0,0);\n}\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n        vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n#define SAMPLES 128\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-(iResolution.xy/2.f))/iResolution.y*10.f;\n    vec3 col = vec3(0,0,0);\n    for (int i = 0; i < SAMPLES; i++) {\n        float t = (float(i) + random(uv+float(i)+iTime)) / float(SAMPLES) * 2. * 3.1415;\n        vec3 c;\n        trace(uv, vec2(cos(t), sin(t)), c);\n        col += c;\n    }\n    col /= float(SAMPLES);\n    // Output to screen\n    fragColor = vec4(col*2.,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lldcDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 65], [67, 67, 100, 100, 188], [190, 190, 256, 256, 321], [323, 323, 380, 380, 735], [737, 737, 779, 779, 944], [946, 946, 974, 974, 1065]], "test": "ok"}
{"id": "lldcDl", "name": "Morning Mandelbrot Set", "author": "uynet", "description": "because I made this in the morning.", "tags": ["math"], "likes": 1, "viewed": 80, "published": "Public", "date": "1534727201", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 z = vec2(0);\n    vec2 z_next;\n    \n    vec2 a = vec2(0.76 , 0.5);\n    uv -= a;\n    uv /=((iTime*iTime)/10.0 + 0.3);\n    uv+=a;\n    vec2 com = (uv - vec2(0.5 , 0.5));\n    \n    int isInner = 1;\n    float po;\n    for(int i=0;i<60;i++){\n        z_next.x = z.x*z.x -z.y*z.y + com.x;\n        z_next.y = 2.0 * z.x *z.y + com.y;\n        z = z_next;\n        if(length(z)>2.0){\n   \t\t\tpo = float(i)/60.0;\n            isInner = 0;\n            break;\n        }\n    }\n    \n     vec3 col;\n    if(isInner == 0){\n        \n        col = vec3(5.0*po+0.2,po,2.5*po+0.3);\n    }else{\n        col = vec3(1,0.9,1);\n        }\n    //col = vec3(length(z));\n   \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lldcDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 775]], "test": "ok"}
{"id": "lldcDS", "name": "Sun and Moon over Ocean", "author": "draco_nite", "description": "I want to do the waves smoother but dunno how", "tags": ["sun", "moon"], "likes": 1, "viewed": 76, "published": "Public", "date": "1533937452", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\n#define sunRadius 0.09\n#define moonRadius 0.075\n#define posMult 0.808\n#define timeMult 0.5\n#define pi 3.14159265\n\nstruct gp {\n    float point;\n    vec3 col;\n};\n\nvec3 getFromGradient(float pos, gp grad[6]) {\n    // find what we're between\n    float lt0 = step(pos, grad[0].point);\n    float b01 = step(grad[0].point, pos) * step(pos, grad[1].point);\n    float b12 = step(grad[1].point, pos) * step(pos, grad[2].point);\n    float b23 = step(grad[2].point, pos) * step(pos, grad[3].point);\n    float b34 = step(grad[3].point, pos) * step(pos, grad[4].point);\n    float b45 = step(grad[4].point, pos) * step(pos, grad[5].point);\n    float gt5 = step(grad[5].point, pos);\n    \n\t// get the between values\n    float b01v = grad[1].point - grad[0].point;\n    float b12v = grad[2].point - grad[1].point;\n    float b23v = grad[3].point - grad[2].point;\n    float b34v = grad[4].point - grad[3].point;\n    float b45v = grad[5].point - grad[4].point;\n    \n    // get the between values points\n    float b01p = pos - grad[0].point;\n    float b12p = pos - grad[1].point;\n    float b23p = pos - grad[2].point;\n    float b34p = pos - grad[3].point;\n    float b45p = pos - grad[4].point;\n    \n    // scale what we're between as a %\n    float b01s = b01p / b01v;\n\tfloat b12s = b12p / b12v;\n\tfloat b23s = b23p / b23v;\n    float b34s = b34p / b34v;\n    float b45s = b45p / b45v;\n\n    // mix our colors\n    vec3 lt0c = grad[0].col * lt0;\n    vec3 b01c = mix(grad[0].col, grad[1].col, b01s) * b01;\n    vec3 b12c = mix(grad[1].col, grad[2].col, b12s) * b12;\n    vec3 b23c = mix(grad[2].col, grad[3].col, b23s) * b23;\n\tvec3 b34c = mix(grad[3].col, grad[4].col, b34s) * b34;\n    vec3 b45c = mix(grad[4].col, grad[5].col, b45s) * b45;\n    vec3 gt5c = grad[4].col * gt5;\n    \n    return lt0c + b01c + b12c + b23c + b34c + b45c + gt5c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // make our gradient\n    gp gradient[6];\n    gradient[0] = gp(0.000, vec3(0.349,0.806,1.000)); // day\n    gradient[1] = gp(0.168, vec3(1.000,0.374,0.092)); // sunset\n    gradient[2] = gp(0.211, vec3(0.147,0.110,0.310)); // night\n    gradient[3] = gp(0.786, vec3(0.147,0.110,0.310)); // night\n    gradient[4] = gp(0.925, vec3(1.000,0.635,0.325)); // sunrise\n    gradient[5] = gp(1.000, vec3(0.349,0.806,1.000)); // day\n    \n    \n    vec2 st = fragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n\n    vec2 sun = vec2(0.);\n    sun.x = (sin(iTime * timeMult) * posMult + 0.9);\n    sun.y = (cos(iTime * timeMult) * posMult);\n    \n    vec2 moon = vec2(0.);\n    moon.x = -(sin(iTime * timeMult) * posMult + -0.9);\n    moon.y = -(cos(iTime * timeMult) * posMult);\n    \n    // colors\n    vec3 skyColor = getFromGradient(mod(iTime / (2. * pi) * timeMult, 1.), gradient);\n    vec3 oceanColor = vec3(0.000,0.000,0.705);\n    vec3 sunColor = vec3(1.000,0.822,0.674);\n    vec3 moonColor = vec3(0.720,0.720,0.720);\n        \n    // get distance from sun and moon\n    float distFromSun = distance(sun, st);\n    float distFromMoon = distance(moon, st);\n    \n    // set shapes\n    float isOcean = step(sin((st.x + iTime / 2.) * 40.) / 200. * sin((iTime) * 4.) + 0.3, st.y);\n    float isSun = step(sunRadius, distFromSun);\n    float isMoon = step(moonRadius, distFromMoon);\n    float isSphere = step(1.064, isSun + isMoon);\n    \n    // and paint them\n    vec3 spheres = moonColor * (1. - isMoon) + sunColor * (1. - isSun);\n    vec3 sky = skyColor * (isSphere) + spheres;\n    vec3 color = sky * isOcean + oceanColor * (1. - isOcean);\n\n    fragColor = vec4(color,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lldcDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[279, 279, 324, 355, 1927], [1929, 1929, 1986, 2016, 3661]], "test": "error"}
{"id": "lldcRX", "name": "Whacked out shonet", "author": "dana", "description": "some whacky stuff!", "tags": ["whacky"], "likes": 0, "viewed": 339, "published": "Public API", "date": "1533509132", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time=(sqrt(iTime))*sin(iTime)*0.5;\n\tvec2 uv = (fragCoord.xy / iResolution.xx-.5)*6.0;\n    vec2 uv0=uv;\n\tfloat i0=1.1;\n\tfloat i1=1.0;\n\tfloat i2=1.0;\n\tfloat i4=0.0;\n\tfor(int s=0;s<6;s++)\n\t{\n\t\tvec2 r;\n\t\tr=vec2(sin(uv.y*i0-i4+time/i1*0.1),tan(uv.x*i0-i4+time/i1))/i2;\n        r+=vec2(-r.y,r.x)*0.1;\n\t\tuv.xy+=r;\n\n\t\ti0*=2.93;\n\t\ti1*=5.15;\n\t\ti2*=3.7;\n\t\ti4-=0.02+1.1*time*i1;\n\t}\n    float r=sqrt(uv.x-time)*0.6+1.5;\n    float b=log(uv.y+time)*0.5+01.5;\n    float g=tan((uv.x+uv.y+sin(time*0.5))*0.5)*0.5+1.5;\n\tfragColor = vec4(r,g,b,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lldcRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 597]], "test": "ok"}
{"id": "llGcDz", "name": "Dancing H ", "author": "luruke", "description": "An H that dance ", "tags": ["raymarching", "sdf", "ao", "h", "letter", "breakdance"], "likes": 10, "viewed": 400, "published": "Public", "date": "1535737183", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision highp float;\n\nstruct Camera {\n  vec3 position;\n  vec3 target;\n  float fov;\n};\n\nstruct Ray {\n  vec3 origin;\n  vec3 direction;\n};\n\nstruct Light {\n  vec3 position;\n};\n\nvec3 calculateRayDirection(Camera c, vec2 uv) {\n  vec3 forward = normalize(c.target - c.position);\n  vec3 right = normalize(vec3(forward.z, 0.0, -forward.x));\n  vec3 up = normalize(cross(forward, right));\n\n  return normalize(forward + c.fov * uv.x * right + c.fov * uv.y * up);\n}\n\n////\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n    vec3(1, 0, 0), vec3(0, c, -s), vec3(0, s, c)\n    );\n}\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n    vec3(c, 0, s), vec3(0, 1, 0), vec3(-s, 0, c)\n    );\n}\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n    vec3(c, -s, 0), vec3(s, c, 0), vec3(0, 0, 1)\n    );\n}\n\nfloat voxel(vec3 p, mat4 m) {\n  vec3 tp = vec3(m * vec4(p, 1.0)).xyz;\n  vec3 size = vec3(1.0);\n\n  vec3 d = abs(tp) - size;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat scene(vec3 op){\n  vec3 p = op;\n\n  p.x = -p.x;\n\n  p = rotateY(p.y * 0.1 + iTime + sin(iTime)) * p;\n  p = rotateY(p.y * 0.1 + iTime) * p;\n  p = rotateZ(p.y * 0.03 + sin(iTime) * 0.3 * .05 + iTime) * p;\n  p = rotateZ(p.y * 0.01 + sin(iTime)) * p;\n\n  // H\n  float h = voxel(p, mat4(0.0,-0.0,-0.2996,-0.0,-1.0,0.0,-0.0,0.0,0.0,1.0,0.0,-0.0,-0.0,0.0,-0.0,1.0));\n  h = min(h, voxel(p, mat4(-1.0,-0.0,0.0,-0.0,-0.0,0.0,0.1597,0.0,0.0,1.0,0.0,-0.0,-2.5,0.0,-0.0,1.0)));\n  h = min(h, voxel(p, mat4(-1.0,-0.0,0.0,-0.0,-0.0,0.0,0.1597,0.0,0.0,1.0,0.0,-0.0,2.5,-0.0,-0.0,1.0)));\n\n  float plane = dot(op, normalize(vec3(0.0, 0.0, -1.0))) + 12.1;\n\n  return min(h, plane);\n}\n\n#define FAR 200.\n#define INFINITY 1e32\nfloat t_min = 2.01;\nfloat t_max = FAR;\nconst int MAX_ITERATIONS = 125;\n// http://erleuchtet.org/~cupe/permanent/enhanced_sphere_tracing.pdf\n// https://www.shadertoy.com/view/4tVXRV\nfloat march(Ray r) {\n    vec3 o = r.origin;\n    vec3 d = r.direction;\n\n    float omega = 1.3;\n    float t = t_min;\n    float candidate_error = INFINITY;\n    float candidate_t = t_min;\n    float previousRadius = 0.2;\n    float stepLength = 0.;\n    float pixelRadius = 0.0001;\n    float functionSign = scene(o) < 0. ? -1. : 1.;\n    float mp;\n    \n    for (int i = 0; i < MAX_ITERATIONS; ++i) {\n        mp = scene(d * t + o);\n        float signedRadius = functionSign * mp;\n        float radius = abs(signedRadius);\n        bool sorFail = omega > 1. &&\n        (radius + previousRadius) < stepLength;\n        if (sorFail) {\n            stepLength -= omega * stepLength;\n            omega = 1.;\n        } else {\n        stepLength = signedRadius * omega;\n        }\n        previousRadius = radius;\n        float error = radius / t;\n        if (!sorFail && error < candidate_error) {\n            candidate_t = t;\n            candidate_error = error;\n        }\n        if (!sorFail && error < pixelRadius || t > t_max) break;\n        t += stepLength;\n   \t}\n    if (\n        (t > t_max || candidate_error > pixelRadius)\n    \t) return 0.0;\n    \n    return candidate_t;\n}\n\n// 4 taps\n// http://www.iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calculateNormal( in vec3 p ) // for function f(p)\n{\n    const float h = 0.1; // or some other value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*scene( p + k.xyy*h ) + \n                      k.yyx*scene( p + k.yyx*h ) + \n                      k.yxy*scene( p + k.yxy*h ) + \n                      k.xxx*scene( p + k.xxx*h ) );\n}\n\nfloat hash( float n ){\n\treturn fract(sin(n)*3538.5453);\n}\n\nfloat calcAO( in vec3 p, in vec3 n, float maxDist, float falloff ){\n\tfloat ao = 0.0;\n\tconst int nbIte = 6;\n\tfor( int i=0; i<nbIte; i++ )\n\t{\n\t\tfloat l = hash(float(i))*maxDist;\n\t\tvec3 rd = n*l;\n\t\tao += (l - scene( p + rd )) / pow(1.+l, falloff);\n\t}\n\treturn clamp( 1.-ao/float(nbIte), 0., 1.);\n}\n\n// https://www.shadertoy.com/view/4scSW4\nfloat fresnel(float bias, float scale, float power, vec3 I, vec3 N) {\n    return bias + scale * pow(1.0 + dot(I, N), power);\n}\n\nfloat calcShadow( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 1.0;\n    float t = 0.01;\n    for( int i=0; i<125; i++ )\n    {\n        vec3 pos = ro + t*rd;\n        float h = scene( pos );\n        res = min( res, k*max(h,0.0)/t );\n        if( res<0.0001 ) break;\n        t += clamp(h,0.01,0.5);\n    }\n\n    return res;\n}\n\nfloat blinnPhongSpecular(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float shininess) {\n\n  //Calculate Blinn-Phong power\n  vec3 H = normalize(viewDirection + lightDirection);\n  return pow(max(0.0, dot(surfaceNormal, H)), shininess);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float aspect = iResolution.x / iResolution.y;\n  vec2 uv = (2.0 * fragCoord.xy / iResolution.xy - 1.0) * vec2(aspect, 1.0);\n\n  Camera c = Camera(\n    // vec3(sin(iTime) * 10.0, cos(iTime) * 10.0, -30.0),\n    vec3(0.0, 0.0, -30.0),\n    vec3(0.0, 0.0, 0.0),\n    0.4\n  );\n\n  Ray r = Ray(\n    c.position,\n    calculateRayDirection(c, uv)\n  );\n\n  Light l = Light(\n    vec3(0.0, 20.0, 20.0)\n  );\n\n  float traveled = march(r);\n  vec3 color = vec3(0.0);\n\n  if (traveled <= 0.0) {\n    // Hit nothing\n    fragColor = vec4(color, 1.0);\n    return;\n  }\n\n  vec3 positionHit = c.position + r.direction * traveled;\n  vec3 normal = calculateNormal(positionHit);\n\n  if (positionHit.z > 5.0) {\n    fragColor = vec4(color, 1.0);\n    return;\n  }\n\n  // Phong\n  vec3 eyeDirection = normalize(c.position - positionHit);\n  vec3 lightDirection = normalize(l.position - positionHit);\n  float power = blinnPhongSpecular(lightDirection, eyeDirection, normal, 1.0);\n\n  color += vec3(0.3) + power;\n\n  // AO\n  float ao = calcAO(positionHit, normal,10.,1.6);\n  color *= ao;\n\n  // Fresnel\n  vec3 I = normalize(positionHit - c.position);\n  float R = fresnel(.0, 2.4, 5.2, I, normal);\n  color *= 1.0 - R;\n\n  // Fog\n  float dd = distance(c.position, positionHit);\n  float start = 20.0;\n  float end = 50.0;\n  float fog = 1.0 - clamp((end - dd) / (end - start), 0.0, 1.0);\n  color = mix(color, vec3(0.0), fog);\n  \n  fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llGcDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[175, 175, 222, 222, 454], [456, 461, 488, 488, 615], [616, 616, 643, 643, 770], [771, 771, 798, 798, 925], [927, 927, 956, 956, 1113], [1115, 1115, 1136, 1136, 1779], [1891, 2001, 2021, 2021, 3163], [3165, 3243, 3299, 3299, 3588], [3590, 3590, 3612, 3612, 3647], [3649, 3649, 3716, 3716, 3942], [3944, 3985, 4054, 4054, 4111], [4113, 4113, 4166, 4166, 4437], [4439, 4439, 4552, 4585, 4699], [4701, 4701, 4756, 4756, 6167]], "test": "ok"}
{"id": "llGyzh", "name": "GPU hacks #01 - CUDA & OpenGL", "author": "PrzemyslawZaworski", "description": "Welcome. ShaderToy is a great place to learn WebGL shaders. Now it's time to extend our skills with GPU programming. Every episode will provide full source code with tiny framework in different language. ", "tags": ["tutorial", "opengl", "nvidia", "cuda"], "likes": 1, "viewed": 358, "published": "Public", "date": "1535022594", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nWritten by Przemyslaw Zaworski, MIT licence\nRequirements and tools:\n - A CUDA-capable GPU\n - A supported version of Microsoft Windows\n - A supported version of Microsoft Visual Studio (2015)\n - the NVIDIA CUDA Toolkit (available at http://developer.nvidia.com/cuda-downloads)\nSave code as uv.cu and compile from command line (toolkit installed in E:\\CUDA):\n\tnvcc -o uv.exe uv.cu -IE:\\CUDA\\Samples\\common\\inc -lopengl32 -arch=sm_30  user32.lib gdi32.lib\nYou can make your own functions, and add __device__ qualifier, for example:\n    __device__  float plane(float3 p, float3 c, float3 n)\n    {\n        return dot(p - c, n);\n    }\n*/\n\n/*\n#include <windows.h>\n#include <GL/gl.h>\n#include <helper_math.h> \n#include <cuda_runtime.h>\n#include <cuda_gl_interop.h>\n\n#define width 1920\n#define height 1080\nstatic float timer = 0.0f;\nfloat3* device;\nunsigned int buffer;\ntypedef void (APIENTRY* PFNGLGENBUFFERSPROC) (GLsizei n, GLuint *b);\ntypedef void (APIENTRY* PFNGLBINDBUFFERPROC) (GLenum t, GLuint b);\ntypedef void (APIENTRY* PFNGLBUFFERDATAPROC) (GLenum t, ptrdiff_t s, const GLvoid *d, GLenum u);\ntypedef int (APIENTRY* PFNWGLSWAPINTERVALEXTPROC) (int i);\n\n__global__ void mainImage(float3 *output, float iTime)\n{\n\tunsigned int x = blockIdx.x*blockDim.x + threadIdx.x;\n\tunsigned int y = blockIdx.y*blockDim.y + threadIdx.y;\n\tunsigned int i = (height - y - 1)*width + x;\n\tfloat2 iResolution = make_float2((float)width, (float)height);\n\tfloat2 fragCoord = make_float2((float)x, (float)y);\n\tfloat2 uv = fragCoord / iResolution;\n\tfloat r = cos(iTime+uv.x+0), g = cos(iTime+uv.y+2), b = cos(iTime+uv.x+4);\n\tfloat3 fragColor = clamp(0.5 + 0.5 * make_float3(r,g,b),0.0,1.0);\n\tfloat colour;\n\tGLubyte bytes[] = {(GLubyte)(fragColor.x*255+0.5),(GLubyte)(fragColor.y*255+0.5),(GLubyte)(fragColor.z*255+0.5)};\n\tmemcpy(&colour, &bytes, sizeof(colour));\n\toutput[i] = make_float3(x, y, colour);\n}\n\nint main()\n{\n\tShowCursor(0);\n\tunsigned int size = width * height * sizeof(float3);\n\tcudaMalloc(&device, size);\n\tdim3 block(8, 8, 1);\n\tdim3 grid(width / block.x, height / block.y, 1);\n\tPIXELFORMATDESCRIPTOR pfd = { 0, 0, PFD_DOUBLEBUFFER };\n\tHDC hdc = GetDC(CreateWindow(\"static\", 0, WS_POPUP | WS_VISIBLE | WS_MAXIMIZE, 0, 0, 0, 0, 0, 0, 0, 0));\n\tSetPixelFormat(hdc, ChoosePixelFormat(hdc, &pfd), &pfd);\n\twglMakeCurrent(hdc, wglCreateContext(hdc));\n\tglOrtho(0.0, width, 0.0, height, -1.0, 1.0);\n\t((PFNWGLSWAPINTERVALEXTPROC)wglGetProcAddress(\"wglSwapIntervalEXT\")) (0);\n\t((PFNGLGENBUFFERSPROC)wglGetProcAddress(\"glGenBuffers\"))(1, &buffer);\n\t((PFNGLBINDBUFFERPROC)wglGetProcAddress(\"glBindBuffer\"))(0x8892, buffer);\n\t((PFNGLBUFFERDATAPROC)wglGetProcAddress(\"glBufferData\"))(0x8892, size, 0, 0x88EA);\n\tcudaGLRegisterBufferObject(buffer);\n\tglVertexPointer(2, GL_FLOAT, 12, 0);\n\tglColorPointer(3, GL_UNSIGNED_BYTE, 12, (GLvoid*)8);\n\tglEnableClientState(GL_VERTEX_ARRAY);\n\tglEnableClientState(GL_COLOR_ARRAY);\n\tfloat s = GetTickCount();\n\tdo\n\t{\n\t\ttimer = (GetTickCount()-s)*0.001f;\n\t\tcudaGLMapBufferObject((void**)&device, buffer);\n\t\tmainImage <<< grid, block >>>(device, timer); \n\t\tcudaGLUnmapBufferObject(buffer);\n\t\tglDrawArrays(GL_POINTS, 0, width * height);\n\t\twglSwapLayerBuffers(hdc, WGL_SWAP_MAIN_PLANE);\n\t} while (!GetAsyncKeyState(VK_ESCAPE));\n\tcudaFree(device);\n\treturn 0;\n}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llGyzh.jpg", "access": "shaders20k", "license": "mit", "functions": [[3266, 3266, 3323, 3373, 3560]], "test": "ok"}
{"id": "llKyRw", "name": "[twitch] Gilded Cage", "author": "yx", "description": "Coded live on twitch stream in Bonzomatic, and tidied/ported to shadertoy.\nUnedited Bonzomatic shader here: [url]https://gist.github.com/willkirkby/d13449b7857e40c81642a6c64386a058[/url]", "tags": ["gold", "cage"], "likes": 26, "viewed": 799, "published": "Public API", "date": "1535576796", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rotate(vec2 a, float b)\n{\n    float c = cos(b);\n    float s = sin(b);\n    return vec2(\n        a.x * c - a.y * s,\n        a.x * s + a.y * c\n    );\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat scene(vec3 p)\n{\n    vec3 sp = p + vec3(1,3,2);\n\n    return min(\n        max(\n            max(\n                sdBox(p, vec3(1.)),\n                -sdBox(p,vec3(.9))\n            ),\n            abs(mod(length(sp)-iTime*.2,.2)-.1)-.01\n        ),\n        length(p)-.8\n    );\n}\n\nfloat sceneWithFloor(vec3 p)\n{\n    return min(\n        scene(p),\n        1.+p.y\n    );\n}\n\nvec3 trace(vec3 cam, vec3 dir)\n{\n    vec3 accum = vec3(1);\n   \t// 20 maybe overkill?\n    for (int bounce = 0; bounce < 20; bounce++)\n    {\n        float tfloor = (cam.y + 1.)/-dir.y;\n        float t = 0.;\n        float k = 0.;\n        for(int i = 0; i < 100; i++)\n        {\n            k = scene(cam + t * dir);\n            t += k;\n            if (k < 0.001 || (tfloor > 0. && t > tfloor))\n                break;\n        }\n        if (tfloor > 0.)\n            t = min(t, tfloor);\n\n        vec3 h = cam + t * dir;\n\n        vec2 o = vec2(.005, 0);\n        vec3 n = normalize(vec3(\n            sceneWithFloor(h+o.xyy)-sceneWithFloor(h-o.xyy),\n            sceneWithFloor(h+o.yxy)-sceneWithFloor(h-o.yxy),\n            sceneWithFloor(h+o.yyx)-sceneWithFloor(h-o.yyx)\n        ));\n\n        if (h.y < -.999)\n        {\n            // floor\n            float A = .5;\n            float B = max(0.,sceneWithFloor(h+n*A));\n            float w = clamp(1.-length(h.xz) * .01, 0., 1.);\n            w = w * .2 + .8;\n            return accum * vec3(pow(B/A,.7)*.6+.4) * w;\n        }\n        else if (length(h) < .85)\n        {\n            // ball\n            float fresnel = mix(.001,1.,pow(1.-dot(-dir, n),5.));\n            accum *= fresnel;\n            cam = h + n * .01;\n            dir = reflect(dir, n);\n        }\n        else if (length(h) < 2.) // ew yucky hack\n        {\n            // cube\n            accum *= vec3(.72,.576,.288);\n            cam = h + n * .01;\n            dir = reflect(dir, n);\n        }\n        else\n        {\n            // sky\n            return accum * vec3(.8);\n        }\n    }\n    return vec3(0);\n}\n\nvoid mainImage(out vec4 out_color, vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy - .5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 cam = vec3(0,0,-4);\n    vec3 dir = normalize(vec3(uv, 1));\n\n    cam.yz = rotate(cam.yz, sin(iTime*.1)*.25+.25);\n    dir.yz = rotate(dir.yz, sin(iTime*.1)*.25+.25);\n\n    cam.xz = rotate(cam.xz, iTime*.3);\n    dir.xz = rotate(dir.xz, iTime*.3);\n\n    out_color = vec4(pow(trace(cam,dir),vec3(.45)),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llKyRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 153], [155, 155, 186, 186, 277], [279, 279, 300, 300, 557], [559, 559, 589, 589, 647], [649, 649, 681, 681, 2263], [2265, 2265, 2317, 2317, 2718]], "test": "timeout"}
{"id": "llKyRz", "name": "Ice cavern", "author": "Flopine", "description": "Having fun with the inside raymarching function of simesgreen : https://www.shadertoy.com/view/Msf3Dj\nCoding in 25 minutes during the semi-finals of Evoke 2018 Shader Showdown.", "tags": ["raymarching", "volumetric", "ice", "watercolor"], "likes": 42, "viewed": 1279, "published": "Public", "date": "1534942805", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n\n// Simplified version (with no reflection) \n// of simesgreen shader : https://www.shadertoy.com/view/Msf3Dj\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui and Coyhot for teaching me\n// Cookie Collective rulz\n\nconst int maxSteps = 64;\nconst float hitThreshold = 0.01;\nconst float minStep = 0.02;\nconst float PI = 3.14159;\n\n#define time iTime\n\nvec2 moda (vec2 p, float per)\n{\n    float a = atan(p.y,p.x);\n    float l = length(p);\n    a = mod(a-per/2., per)-per/2.;\n    return vec2(cos(a), sin(a))*l;\n}\n\nmat2 rot (float a)\n{\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nfloat beat (float value, float intensity, float frequency) \n{\n    float v = atan(sin(value * 3.14 * frequency) * intensity);\n    return (v + 3.14 / 2.) / 3.14;\n}\n\nfloat sphere(vec3 p, float r)\n{return length(p) - r;}\n\nfloat box( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat odile(vec3 p, float d)\n{return dot(p, normalize(sign(p)))-d;}\n\nfloat cyl(vec3 p, float r, float h)\n{return max(length(p.xz)-r, abs(p.y)-h);}\n\nfloat prim1 (vec3 p)\n{\n    vec3 pp = p;\n    p.xz *= rot(time*0.7);\n  \tp.xz = moda(p.xz, 2.*PI/5.);\n    p.xz *= rot(p.y*0.5);\n    p.x -= .5;\n    float c = cyl(p,0.35,0.8);\n    \n    p = pp;\n    p.xz *= rot(time);\n    p.xy *= rot(time);\n    float od = odile(p,1.- beat(time, 0.3, .5));\n    return min(c,od);\n}\n\n\nfloat scene(vec3 p)\n{  \n  float d;\n  d = sphere(p,.9);\n\td = max(box(p, vec3(1.1)), -d);\n  d  = min(d, prim1(p));\n\n\tvec3 np = p + vec3(0.0, time*0.2, time*0.1);\n  d += texture(iChannel0, -np.xz).r*0.2;\n  d += texture(iChannel0, np.yz).r*0.2;\n\treturn d;\n}\n\n//simesgreen raymarched inside function\nvec3 traceInside(vec3 ro, vec3 rd, out bool hit, out float insideDist)\n{\n    \n    hit = false;\n    insideDist = 0.0;\t\n    vec3 pos = ro;\n    vec3 hitPos = pos;\n    for(int i=0; i<maxSteps; i++)\n    {\n\t\tfloat d = scene(pos);\n\t\td = max(abs(d), minStep) * sign(d);// enforce minimum step size\n\t\t\n\t\tif (d < hitThreshold && !hit) {\n\t\t\t// save first hit\n\t\t\thitPos = pos;\n\t\t\thit = true;\n\t\t}\n\t\t\n\t\tif (d < 0.01) {\n\t\t\t// sum up distance inside\n\t\t\tinsideDist += d;\n\t\t}\n\t\tpos += abs(d)*rd*0.35;\n    }\n    return hitPos;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  vec3 translucentColor = vec3(length(uv), 0.2, 0.1);\n     vec3 rd = normalize(vec3(uv, 1));\n    vec3 ro = vec3(0.0, 0.0, -2.8);\n    // trace ray\n    bool hit;\n    float dist;\n    vec3 hitPos = traceInside(ro, rd, hit, dist);\n\n    vec3 rgb = vec3(0.0);\n    if(hit) \n    {\n\t\t// exponential fall-off:\n\t\trgb = exp(-dist*dist*translucentColor);\n     } \n      else \n      {\n        rgb = vec3(1.);\n     }\n\n    fragColor = vec4(pow(rgb,vec3(2.2)),1.);\n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llKyRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[366, 366, 397, 397, 523], [525, 525, 545, 545, 594], [596, 596, 657, 657, 757], [759, 759, 790, 790, 812], [814, 814, 843, 843, 930], [932, 932, 962, 962, 999], [1001, 1001, 1038, 1038, 1078], [1080, 1080, 1102, 1102, 1386], [1389, 1389, 1410, 1410, 1642], [1644, 1684, 1756, 1756, 2193], [2195, 2195, 2252, 2252, 2837]], "test": "error"}
{"id": "llKyzw", "name": "Lightshow", "author": "Citiral", "description": "Some fun with really simple metaballs. This has probably bene done a thousand times over already.", "tags": ["simple", "colors", "color"], "likes": 8, "viewed": 1088, "published": "Public API", "date": "1535586082", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int BALLS = 25;\n\n// noise and rand functions stolen from stack overflow :)\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nvec2 hash(vec2 co) {\n    float m = dot(co, vec2(12.9898, 78.233));\n    return fract(vec2(sin(m),cos(m))* 43758.5453) * 2. - 1.;\n}\n\nfloat fade(float t) { return t * t * t * (t * (t * 6. - 15.) + 10.); }\n\nvec2 ssmooth(vec2 x) { return vec2(fade(x.x), fade(x.y)); }\n\nfloat perlinNoise(vec2 uv) {\n    vec2 PT  = floor(uv);\n    vec2 pt  = fract(uv);\n    vec2 mmpt= ssmooth(pt);\n\n    vec4 grads = vec4(\n        dot(hash(PT + vec2(.0, 1.)), pt-vec2(.0, 1.)),   dot(hash(PT + vec2(1., 1.)), pt-vec2(1., 1.)),\n        dot(hash(PT + vec2(.0, .0)), pt-vec2(.0, .0)),   dot(hash(PT + vec2(1., .0)), pt-vec2(1., 0.))\n    );\n\n    return 5.*mix (mix (grads.z, grads.w, mmpt.x), mix (grads.x, grads.y, mmpt.x), mmpt.y);\n}\n\n// https://github.com/hughsk/glsl-hsv2rgb/blob/master/index.glsl\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 position = fragCoord/iResolution.xy;\n\tposition.x *= iResolution.x / iResolution.y;\n\n    \n    vec3 dist = vec3(0.0);\n\tfor (int i = 0 ; i < BALLS ; i++) {\n\t\tvec2 bpos = vec2(perlinNoise(vec2(float(i*3218) + cos(iTime*0.1), iTime*0.1)), perlinNoise(vec2(float(i*1357) + sin(iTime*0.1), -iTime*0.1))) / 5.0;\n\t\tbpos += vec2(0.5 * iResolution.x/iResolution.y,0.5);\n\t\tdist += hsv2rgb(vec3(float(i) / float(BALLS), 1.0, 1.0)) * 1.0 / (pow(position.x - bpos.x, 2.0) + pow(position.y - bpos.y, 2.0));\n\t}\n\t\n\tfragColor = vec4(dist/1000., 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llKyzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 81, 101, 101, 139], [141, 141, 161, 161, 270], [272, 272, 293, 293, 342], [344, 344, 366, 366, 403], [405, 405, 433, 433, 846], [848, 913, 935, 935, 1098], [1100, 1100, 1157, 1207, 1750]], "test": "ok"}
{"id": "lls3zr", "name": "superquadric", "author": "386dx25", "description": "Simple raycaster for a superquadric tensor glyph. In the code you can switch between classical raymarching and a Newton-style iteration. The latter is faster but leads to artefacts for some alpha/beta combinations (in the current implementation).", "tags": ["visualization", "superquadric"], "likes": 1, "viewed": 134, "published": "Public", "date": "1535450603", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Raycast a supequadric glyph (comparison of two implementation variants)\n// Max Hermann and Vitalis Wiens, Dec 2014 ({wiens,hermann}@cs.uni-bonn.de)\n\n//precision highp float;\n//precision highp int;\n\n//---[ Shading ] --------------------------------------------------------------\n\n// Phong material\nstruct Material\n{\n\tfloat ka;\tvec3 camb;  // ambient\n\tfloat kd;\tvec3 cdiff; // diffuse\n\tfloat ks;   vec3 cspec; // specular\n\tfloat phongExponent;\n};\n\n// Phong shading with some default material and constant light\nvec3 shade( vec3 N, vec3 E )\n{    \n    Material mat = Material(\n\t\t0.20, vec3(1.0,1.0,1.0),\n\t\t0.65, vec3(0.6,0.8,1.0),\n\t\t0.90, vec3(1.0,1.0,0.0), 50.0 \n\t);\n    E = normalize(E);\n    vec3 L = normalize(vec3(-1, 1, -1));\n\tvec3 H = normalize( E + L );\n\treturn  \n\t\tmat.ka * mat.camb\n\t  +\tmat.kd * mat.cdiff * max(0.0, 1.0 * dot(L,N))\n      + mat.ks * mat.cspec * pow( max(0.0,dot(H,N)), mat.phongExponent );\n}\n\n//---[ Ray & sphere intersection ]---------------------------------------------\n\n// Ray has an origin and a (normalized) direction\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n    \n// Raytracing intersection\nstruct Intersection {\n    bool valid;\n    vec3 normal;\n    vec3 pos;\n};\n\n// Raytracing intersection calculation for the bounding sphere\nIntersection intersect_unit_sphere( Ray r )\n{\n    const float radius = 1.7;\n    \n    Intersection s;\n    s.valid = true;\n    \n    // Apply pq formula\n    float denom = dot(r.dir,r.dir);\n    float p = 2.0 * dot(r.dir,r.origin) / denom;\n    float q = (dot(r.origin,r.origin) - radius*radius) / denom;\n    \n    float D = (0.5*p)*(0.5*p) - q;\n    if( D < 0.0 )\n    {\n    \ts.valid = false;\n        return s;\n    }\n    \n    // Return closer intersection\n    s.pos = r.origin + (-.5*p - sqrt(D)) * r.dir;\n    s.normal = normalize(s.pos);\n    return s;\n}\n\n// Explicit intersection calculation\nvec4 scene1( Ray r, vec3 eye )\n{\n    Intersection s = intersect_unit_sphere( r );\n    if( s.valid )\n    {\n        //float li = abs(dot(s.normal,normalize(eye)));\n        //return li * vec4(1.0,1.0,1.0,1.0);\n        //return vec4(s.normal,1.0);\n        return vec4(shade(s.normal,normalize(eye)),1.0);\n    }\n    else\n    {\n        return vec4(0.0,0.0,0.0,1.0);\n    }    \n}\n\n//---[ Superquadric implicit equation & gradient ]-----------------------------\n\n// Workaround for some WebGL implementation deficiencies\n// (Only required for specific browser/driver combinations?!)\nvoid sq_sanitize_input( inout vec3 p, inout float alpha, inout float beta )\n{  \n  #if 0\n    // On some hardware/drivers below workaround is not required?!\n    p.x = abs(p.x);\n    p.y = abs(p.y);\n    p.z = abs(p.z);\n  #else\n    // WORKAROUND: There seems to be an optimization bug when alpha/beta are integers.\n    //             Avoid this by adding some epsilon.\n    const float eps = 0.000001;\n    alpha += eps;\n    beta  += eps;\n    // WORKAROUND: pow(x,y) requires x>0 and x and y not equal 0.\n    p.x = abs(p.x) + eps;\n    p.y = abs(p.y) + eps;\n    p.z = abs(p.z) + eps;    \n  #endif    \n}\n\n// Superquadric implicit equation\nfloat sq( vec3 p, float alpha, float beta )\n{\n    sq_sanitize_input( p, alpha, beta );\n    return \n        //x*x + y*y + z*z - 1.0; \n        pow( pow(p.x,2.0/alpha) + pow(p.y,2.0/alpha), alpha/beta ) + pow(p.z,2.0/beta) - 1.0;\n}\n\n// Superquadric implicit gradient\nvec3 dsq( vec3 p, float alpha, float beta )\n{   \n    vec3 p0 = p;\n    vec3 sp = sign(p);\n    sq_sanitize_input( p, alpha, beta );\n    \n    // Chain rule (df is inner derivative for dx,dy terms)\n    vec3 dq;\n    float df = (alpha/beta)*pow( pow(p.x,2.0/alpha)+pow(p.y,2.0/alpha), (alpha/beta)-1.0);\n    dq.x = (2.0/alpha) * pow(p.x,(2.0/alpha)-1.0) * df;\n    dq.y = (2.0/alpha) * pow(p.y,(2.0/alpha)-1.0) * df;\n    dq.z = (2.0/beta)  * pow(p.z,(2.0/beta)-1.0);\n    \n    // WORKAROUND: Orient gradient as in a sphere\n   \tdq *= sp;\n    //dq = dot(dq,normalize(p))*p;\n    //dq = abs(dq)*sp;\n    return dq;\n}\n\n//---[ Distance field adapter w/ global rotation ]-----------------------------\n\n// Workaround: tranpose() not available in Shadertoy OpenglES version\nmat3 transpose2( mat3 m )\n{\n    return mat3( m[0].x, m[1].x, m[2].x,\n                 m[0].y, m[1].y, m[2].y,\n                 m[0].z, m[1].z, m[2].z );\n}\n\n// Distance function\nmat3 g_R = mat3(1.0); // Global rotation\nfloat g_alpha = 1.0;  // Global alpha parameter for superquadric\nfloat g_beta  = 1.0;  // Global beta parameter for superquadric\nfloat df( vec3 p )\n{\n    return sq( g_R * p, g_alpha, g_beta );\n}\nvec3 ddf( vec3 p )\n{\n    return transpose2(g_R) * dsq( g_R * p, g_alpha, g_beta );\n}\n\n//---[ Variant A: Raymarching ]------------------------------------------------\n\n// Stupid raycasting\nvec4 scene2( Ray r, vec3 eye )\n{       \n    // Tuned to raycast tensor glyph shape space\n    const float stepsize = 0.001; // 0.007;\n    const float maxlength = 2.8;\n    \n    // Ray marching\n    vec3 step = stepsize*r.dir;\n    const int refinement_steps = 7;\n    vec3  p; // Current point on ray traversal\n    vec3  n; // Normal at Rp\n    float s; // Scalar value at Rp\n    vec4 color = vec4(1.0,0.0,0.0,1.0);    \n    for( int i=0; i < int(maxlength/stepsize); ++i )\n    {\n        vec3 total = float(i)*stepsize * r.dir;\n        p = r.origin + total;\n        s = df( p );\n        \n        //return 0.1*vec4(s,abs(s),abs(s),1.0); // DEBUG: Show scalar field\n        \n        // Close to zero set?\n        if( abs(s) < 0.1 )\n        {\n          #if 0 // FIXME: Bisection does not really help on superquadrics?\n            //if( abs(s)>0.001 ) // Just refine if not close enough already\n            {\n                // Intersection refinement\n                float searchdir = sign(s);    // Initial step direction\n                vec3 ministep = step*.5;\n                for( int j=0; j < refinement_steps; ++j )\n                {\n                    // Binary search\n                    p += searchdir*ministep;\t\t\t\t\n                    s = df( p );\n\n                    // Move backwards until exact intersection overstepped\n                    // and vice versa\n                    if( s < 0.0 )\n                        searchdir = -1.0;\n                    else\n                        searchdir = 1.0;\n\n                    // Half stepsize\n                    ministep *= .5;\n                }\n            }\n            //if( abs(s) > 0.01 ) continue; // Sanity: Reject if we didn't get closer\n          #endif                   \n            \n          #if 0\n            // DEBUG gradient\n            float sq = df( p );\n            vec3 gradient = ddf( p );\n            float sqd = dot( gradient, r.dir );\n            return 20.0*vec4(0.05*vec3(sqd,abs(sqd),abs(sqd)),1.0); // DEBUG: Show gradient\n          #endif\n            \n            // Shading\n        \tn = normalize( ddf(p) );            \n        \tcolor = \n                //vec4( 20.0 *vec3(s,abs(s),abs(s)), 1.0 ); // DEBUG: Show distance to real isosurface\n                //vec4(n,1.0); // DEBUG: Show normals\n                vec4( shade(n,normalize(eye)), 1.0 );            \t\n            \n            // BUG: On Firefox 34.05 with a GTX 780 / driver 340.64 the \n            //      if branch seems to be optimized away and is never \n            //      executed as long as we use a return (or break) to \n            //      leave the loop!\n            //return vec4(1.0,1.0,1.0,1.0);\n            //break;\n            return color;\n        }\n    }\n    return color;\n}\n\n//---[ Variant B: Newton iteration ]-------------------------------------------\n\n// Newton raycasting (as described by Hlawitschka et al. 2008)\nvec4 scene3( Ray r, vec3 eye )\n{\n    const int maxNumSteps = 50;\n    float t = 0.0;\n    for( int i=0; i < maxNumSteps; ++i )\n    {\n        vec3 p = r.origin + t*r.dir;    \n        float sq = df( p );\n        vec3 gradient = ddf( p );\n        float sqd = dot( gradient, r.dir );\n        \n        //return vec4(sq,abs(sq),abs(sq),1.0); // DEBUG: Show scalar field\n        //return 0.4*vec4(sqd,abs(sqd),abs(sqd),1.0); // DEBUG: Show gradient\n        \n        // WORKAROUND: One should only consider gradients close to the glyph!\n        //sqd = sign(sqd) * clamp(abs(sqd), 0.001, 100.0);\n        \n        // Newton step         \n        float stepsize = 0.5 * (sq / sqd);\n        t = t - stepsize;\n        \n        //return vec4(stepsize,0.0,0.0,1.0);\n            \n        if( (sq < 0.0001) ) //|| (abs(stepsize) < 0.00001) )\n        {\n            // Shading\n        \tvec3 n = normalize( gradient );\n        \treturn\n                vec4( shade(n,normalize(eye)), 1.0 );\n                //vec4(n,1.0); // DEBUG: Show normals\n            \t//vec4(0.05*vec3(sqd,abs(sqd),abs(sqd)),1.0); // DEBUG: Show gradient\n        }   \n    }\n    \n    return vec4(0.0,1.0,0.0,1.0);\n}\n\n//---[ Camera rotation functions ]---------------------------------------------\n\nmat3 rodriguez( vec3 r, float theta )\n{\n    float s = sin(theta);\n    float c = cos(theta);\n    float t = 1.0-c;\n    return mat3(\n        \tt*r.x*r.x + c,     t*r.x*r.y - s*r.z, t*r.x*r.y + s*r.y,\n        \tt*r.x*r.y + s*r.z, t*r.y*r.y + c,     t*r.y*r.z - s*r.x,\n        \tt*r.x*r.z - s*r.y, t*r.x*r.y + s*r.x, t*r.z*r.z + c\n        );\n}\n\nmat3 Rx( float theta )\n{\n    return mat3( \n        \t   1.0,        0.0,        0.0, \n               0.0,  cos(theta), sin(theta),\n               0.0, -sin(theta), cos(theta) );\n}\n\nmat3 Ry( float theta ) \n{\n    return mat3( \n               cos(theta), 0.0, -sin(theta),\n               0.0,        1.0, 0.0,\n               sin(theta), 0.0, cos(theta) );\n}\n\nmat3 Rz( float theta )\n{\n\treturn mat3( \n               cos(theta), sin(theta),  0.0,\n              -sin(theta), cos(theta),  0.0,\n               0.0,        0.0,         1.0 );\n}\n\n//---[ Main ]------------------------------------------------------------------\n\n// Interaction mode:\n//  0 = navigate camera w/ automatic animation\n//  1 = navigate parameter space\n#define MODE 0\n// Scenes:\n//  scene1 = raytrace the bounding sphere\n//  scene2 = raycast superquadric using plain raymarching\n//  scene3 = raycast superquadric using Newton iteration\n#define SCENE scene2(r,eye);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Cast a ray through the screen\n    Ray r;\n    vec2 p0 = 2.0 * fragCoord.xy / iResolution.xy - vec2(1.0,1.0);\n    p0.x *= iResolution.x / iResolution.y;    \n    p0 *= 1.3; // Zoom out a bit\n    vec3 eye = vec3(0.0,0.0,-8.0);    \n    r.origin = vec3(p0,-2.0);\n    r.dir    = normalize(r.origin - eye);\n    \n    // Intersect with bounding sphere\n\tIntersection s = intersect_unit_sphere( r );\n    r.origin = s.pos;\n    \n    // Normalized mouse coordinate [-1,1]\n    vec2 nm = 2.0 * iMouse.xy / iResolution.xy - 1.0;\n    \n    // Mouse interaction\n  #if MODE==0\n    // Control camera, hardcoded alpha,beta\n    g_alpha = 0.1 + 3.5*(0.5+0.5*sin(1.0*iTime));\n    g_beta  = 0.1 + 3.5*(0.5+0.5*cos(2.3*iTime));\n    g_R = Ry(nm.x*1.0*3.1415)*Rx(nm.y*1.0*3.1415);     \n  #else // MODE==1\n    // Control alpha/beta, hardcoded viewing angle    \n    g_alpha = 4.0 * float(iMouse.x) / float(iResolution.x);\n    g_beta = 4.0 * float(iMouse.y) / float(iResolution.y);    \n    g_R = Rz(-0.1*3.1415)*Rx(-0.35*3.1415);\n  #endif    \n    //g_R = mat3(1.0); // DEBUG: Fixed camera\n    \n    // Estimate fragment color\n    vec4 color = vec4(0.0); // Black background\n    if( s.valid )\n        // Quadric\n    \tcolor = SCENE;\n    // Color tensor parameter space\n    vec2 ps = 4.0 * fragCoord.xy / iResolution.xy;\n    if( (ps.x < 1.0) && (ps.y < ps.x) ) \n        color = vec4( 0.5*color.rgb + 0.5*vec3(1.0,1.0,1.0), 1.0 );\n        //color = vec4(0.0,0.0,1.0,1.0);\n   \t\n    vec2 pixelSize = 1.0 / iResolution.xy;\n    if( (abs(ps.x-g_alpha)<15.0*pixelSize.x) && (abs(ps.y-g_beta)<15.0*pixelSize.y) )\n        color = vec4(1.0,1.0,1.0,1.0);\n    \t\n    fragColor = color; // scene2(r,eye);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lls3zr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[449, 512, 542, 542, 916], [1201, 1264, 1309, 1309, 1810], [1812, 1849, 1881, 1881, 2220], [2303, 2422, 2499, 2499, 3016], [3018, 3052, 3097, 3097, 3280], [3282, 3316, 3361, 3361, 3919], [4002, 4072, 4099, 4099, 4226], [4228, 4419, 4439, 4439, 4484], [4485, 4485, 4505, 4505, 4569], [4652, 4673, 4705, 4761, 7406], [7489, 7552, 7584, 7584, 8716], [8799, 8799, 8838, 8838, 9134], [9136, 9136, 9160, 9160, 9314], [9316, 9316, 9341, 9341, 9489], [9491, 9491, 9515, 9515, 9669], [10066, 10066, 10123, 10160, 11785]], "test": "ok"}
{"id": "lltcRX", "name": "Wz Portal Test", "author": "uqone", "description": "just testing a portal effect hack that i found on here for the game i'm working on.", "tags": ["portal"], "likes": 1, "viewed": 359, "published": "Public API", "date": "1533507291", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// SNOISE function from: https://www.shadertoy.com/view/lsf3RH\nfloat snoise(vec3 uv, float res)\n{\n\tconst vec3 s = vec3(1e0, 1e2, 1e3);\n\t\n\tuv *= res;\n\t\n\tvec3 uv0 = floor(mod(uv, res))*s;\n\tvec3 uv1 = floor(mod(uv+vec3(1.), res))*s;\n\t\n\tvec3 f = fract(uv); f = f*f*(3.0-2.0*f);\n\n\tvec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,\n\t\t      \t  uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);\n\n\tvec4 r = fract(sin(v*1e-1)*1e3);\n\tfloat r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\tr = fract(sin((v + uv1.z - uv0.z)*1e-1)*1e3);\n\tfloat r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\treturn mix(r0, r1, f.z)*2.-1.;\n}\n\nfloat noise(vec2 uv, float baseres)\n{\n    float n = 0.0;\n    for (int i = 0; i < 4; i++)\n    {\n        float v = pow(2.0, float(i));\n        n += (1.5 / v) * snoise(vec3(uv + vec2(1.,1.) * (float(i) / 17.), 1), v * baseres);\n    }\n    \n    \n    return clamp((1.0 - n) * .5, 0., 1.) * 2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspectRatio = iResolution.y/iResolution.x;\n    vec2 uv = (fragCoord/iResolution.xy);\n    uv.y *= aspectRatio;\n    \n    // Tweaking vars\n    vec4 color = vec4(0.125, 0.291, 0.923, 1.0);\n    vec4 leaving = vec4(0.925, 0.791, 0.323, 1.0);\n    float noise_sz = 7.0f;\n    float speed = 0.4;\n    vec2 center = vec2(0.5, 0.5 * aspectRatio);\n    \n    float dc = 1. - (distance(uv, center) * 2.75);\n    float pdc = pow(dc, 3.5);\n    \n    vec2 dir = -normalize(uv - center) * speed;\n    \n    float phase0 = fract(iTime * 0.3 + 0.5);\n    float phase1 = fract(iTime * 0.3 + 0.0);\n    \n    vec2 uv0 = uv + phase0 * dir;\n    vec2 uv1 = uv + phase1 * dir;\n    \n    // Rotation\n    float as = pdc * sin(iTime * 0.9) * 1.2;\n\tfloat ca = cos(as);\n\tfloat sa = sin(as);\t\t\t\t\t\n    \n    mat2 rot;\n    rot[0] = vec2(ca, -sa);\n    rot[1] = vec2(sa, ca);\n    \n    uv0 = center + ((uv0 - center) * rot);\n    uv1 = center + ((uv1 - center) * rot);\n\n    // Samplings\n    float tex0 = max(noise(uv0, noise_sz), noise(uv0 * 1.2, noise_sz));\n    float tex1 = max(noise(uv1, noise_sz), noise(uv1 * 1.4, noise_sz));\n    \n    float lerp = abs((0.5 - phase0) / 0.5);\n    float samplings = mix(tex0, tex1, lerp);\n    \n    vec4 c = vec4(samplings, samplings, samplings, 1.0) * mix(color, leaving, pdc) * pdc;\n  \tc += pow(dc, 16.0) * mix(color, leaving, pow(dc, 16.0)) * 2.3;\n    \n    float cl = clamp(max(c.r, max(c.g, c.b)), 0.0, 1.0);\n    \n    c.rgb += texture(iChannel0, (fragCoord/iResolution.xy)).rgb * cl;\n    \n    // Output to screen\n    fragColor = c;\n    fragColor.a = cl;\n}\n", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lltcRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 63, 97, 97, 621], [915, 915, 972, 972, 2527]], "test": "error"}
{"id": "lltcWl", "name": "3d perlin noise with colors", "author": "stoox", "description": "some colors for https://www.shadertoy.com/view/MtcGRl", "tags": ["perlinnoise"], "likes": 4, "viewed": 1058, "published": "Public API", "date": "1534711910", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//original by LukeRissache: https://www.shadertoy.com/view/MtcGRl\n\nvec2 GetGradient(vec2 intPos, float t) {\n    \n    // Uncomment for calculated rand\n    //float rand = fract(sin(dot(intPos, vec2(12.9898, 78.233))) * 43758.5453);;\n    \n    // Texture-based rand (a bit faster on my GPU)\n    float rand = texture(iChannel0, intPos / 64.0).r;\n    \n    // Rotate gradient: random starting rotation, random rotation rate\n    float angle = 6.283185 * rand + 4.0 * t * rand;\n    return vec2(cos(angle), sin(angle));\n}\n\n\nfloat Pseudo3dNoise(vec3 pos) {\n    vec2 i = floor(pos.xy);\n    vec2 f = pos.xy - i;\n    vec2 blend = f * f * (3.0 - 2.0 * f);\n    float noiseVal = \n        mix(\n            mix(\n                dot(GetGradient(i + vec2(0, 0), pos.z), f - vec2(0, 0)),\n                dot(GetGradient(i + vec2(1, 0), pos.z), f - vec2(1, 0)),\n                blend.x),\n            mix(\n                dot(GetGradient(i + vec2(0, 1), pos.z), f - vec2(0, 1)),\n                dot(GetGradient(i + vec2(1, 1), pos.z), f - vec2(1, 1)),\n                blend.x),\n        blend.y\n    );\n    return noiseVal / 0.7; // normalize to about [-1..1]\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n\tvec2 uv = fragCoord.xy / iResolution.y;\n    \n\n\n    const int ITERATIONS = 10;\n    float noiseVal = 0.0;\n    float sum = 0.0;\n    float multiplier = 1.0;\n    for (int i = 0; i < ITERATIONS; i++) {\n        vec3 noisePos = vec3(vec2(2.0*uv.x+50.0*sin(0.01*iTime),2.0*uv.y+50.0*cos(0.01*iTime)), 0.02 * iTime / multiplier);\n        noiseVal += multiplier * abs(Pseudo3dNoise(noisePos));\n        sum += multiplier;\n        multiplier *= 0.6;\n        uv = 2.0 * uv + 4.3;\n    }\n    noiseVal /= sum;\n\n    // Map to a color palette\n    fragColor.rgb = 0.5 + 0.5 * cos(6.283185 * (3.0 * noiseVal + vec3(0.15, cos(0.0001*uv.x+0.1*iTime+0.1), sin(0.001*uv.y+0.2*iTime))));\n\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lltcWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 107, 286, 511], [514, 514, 545, 545, 1135], [1138, 1138, 1193, 1193, 1864]], "test": "error"}
{"id": "lltyWS", "name": "Radar Trace", "author": "jonnyjedjedi", "description": "Learning Shaders so just testing some stuff out. ", "tags": ["radar", "trace", "blip", "sweep"], "likes": 16, "viewed": 788, "published": "Public", "date": "1534111036", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst float PI = 3.14159265359;\nconst float TWO_PI = 6.28318530718;\nconst int N = 3;\t\t\t\t// triangle polygons please\nconst float r0 = 0.01;\t\t\t// size of centre circle\nconst float r_blue = 0.025;\t\t// size of blue radar blips\nconst float r_red = 0.015;\t\t// size of red radar blips\nconst float edge = 0.95;\t\t// overall size\nconst float offset = 0.05;\n\nfloat plot(const vec2 st, const float pct, const float width)\n\t{\n        return smoothstep(pct - width, pct, st.y) -\n               smoothstep(pct, pct + width, st.y);\n    }\n\nfloat drawPolygon(const vec2 polygonCenter, const int N, const float radius, vec2 pos)\n\t{\n\t\tpos = pos - polygonCenter;\n\t\tfloat d = 0.0;\n\t\tfloat a = atan(pos.x, pos.y);\n\t\tfloat r = TWO_PI / float(N);\n\t\td = cos(floor(0.5 + a / r)*r - a)*length(pos);\n\t\treturn (1.0 - smoothstep(radius, radius + radius/10.0, d));\n\t}\n\nfloat gradations(const float a, const float gradNum, const float outRad, const float tickLen, const float tickWidth, const float r, const float move)\n\t{\n\t\tfloat f = step(0.0, cos((a + move)*gradNum) - tickWidth)*tickLen + (outRad - tickLen);\n    \treturn 1.0 - step(f, r) * 1.0 - step(r, outRad - tickLen);\n\t}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy / iResolution.y;\n\tvec2 pos = uv.xy - vec2(0.825, 0.5) ; // center what being drawn\n   \n   \tvec4 grndSpd = vec4(0.0, iTime/5.0, 0.0, 0.0);\n\tvec4 mapcol = texture(iChannel0,uv) * vec4 (0.0, 0.85, 0.0, 1.0);\n  \n\tvec3 color = vec3(0.0, 0.0, 0.0);\n\n\tfloat r = length(pos) * 2.0;\n\tfloat a = atan(pos.y, pos.x); // angle of pixel\n\tfloat an = PI - mod(iTime / 1.0, TWO_PI); // angle of radar sweep\n    float blipSpd = 3.0; // Blip / Trace speed\n\tvec2 translate1 = vec2(cos(iTime/ blipSpd), sin(iTime / blipSpd));\n\tvec2 translate2 = vec2(sin(iTime / blipSpd), cos(iTime / blipSpd));\n\tvec2 left1 = translate1 * 0.35;\n\tvec2 right1 = -translate1 * 0.30;\n\tvec2 left2 = translate2 * 0.15;\n\tvec2 right2 = -translate2 * 0.25;\n    \n// Radar Sweep\n   \tfloat sn = step(PI/2.0, an) * step(-PI/2.0, (a + an)) * step(r, edge) * (1.0 - 0.55 * (a + (TWO_PI) - an));\n\tfloat sw = step(an, a) * step(r, edge);\n\tfloat s_blade = sw * (1.0 - (a - an) * 20.0);\n\tfloat s = sw * (1.0 - 0.55 * (a - an));\n\ts = max(sn,s);\n\tfloat se = step(r, edge - 0.05);\n   \n// Center point\n\tfloat s1 = smoothstep(edge - 0.00, edge + 0.01, r)* smoothstep(edge + 0.02, edge + 0.01, r);   \n   \n// Circular concentric rings\n\tfloat s0 = 1.0 - smoothstep(r0 / 2.0, r0, length(pos));\n    float smb = (1.0 - smoothstep(0.2, 0.2 + 0.01, length(pos))) * (1.0 - smoothstep(0.2 +0.01, 0.2, length(pos)));\n    float smr = (1.0 - smoothstep(0.3, 0.3 + 0.01, length(pos))) * (1.0 - smoothstep(0.3 +0.01, 0.3, length(pos)));\n    \n// Circular concentric gradations\n\tfloat gradNum = 120.0;\n\tfloat tickWidth = 0.9;\n\tconst float tickLen = 0.04;\n\tfloat outRad = edge;\n\tfloat move = 0.0;\n\tfloat sm = 0.75*gradations(a, gradNum, outRad, tickLen, tickWidth, r, move);   \n   \n\tgradNum = 36.0;\n\ttickWidth = 0.95;\n\toutRad = 0.6;\n\tmove = sin(iTime/10.0);\n\tsmr += 0.5*gradations(a, gradNum, outRad, tickLen, tickWidth, r, move);\n\n\toutRad = 0.4;\n\tmove = cos(iTime/10.0);\n\tsmb += 0.5*gradations(a, gradNum, outRad, tickLen, tickWidth, r, move);\n\n// Radial spoke gradations \n\tfloat sr = plot(pos, pos.x, 0.003) * step(r, edge - 0.06);\n\tsr += plot(vec2(0.0, 0.0), pos.x, 0.002) * step(r, edge - 0.06);\n\tsr += plot(vec2(0.0, 0.0), pos.y, 0.003) * step(r, edge - 0.06);\n\tsr += plot(-pos, pos.x, 0.003) * step(r, edge - 0.06);\n    sr *= 0.75;\n\n// Blue circular radar blip traces\n\tvec2 st_trace1 = left2;\n\tfloat s_trace1 = s * (1.0 - smoothstep(r_blue / 10.0, r_blue, length(pos - st_trace1)));\n\ts_trace1 += s * (1.0 - smoothstep(r_blue / 10.0, r_blue, length(pos - st_trace1 + vec2(+offset, +offset))));\n\ts_trace1 += s * (1.0 - smoothstep(r_blue / 10.0, r_blue, length(pos - st_trace1 + vec2(+2.0 *offset, +2.0 *offset))));\n\n\tvec2 st_trace2 = right1;\n\tfloat s_trace2 = s * (1.0 - smoothstep(r_blue / 10.0, r_blue, length(pos - st_trace2)));\n\n// Red Trianglular radar flight blip trace \n\tvec2 st_trace3 = left1;\n\tfloat st1 = s * (drawPolygon(st_trace3, N, r_red , pos));\n\tst1 += s * (drawPolygon(st_trace3 + vec2(-offset, -offset), N, r_red, pos));\n\tst1 += s * (drawPolygon(st_trace3 + vec2(+offset, -offset), N, r_red, pos));\n\n\tvec2 st_trace4 = right2;\n\tfloat st2 = s * (drawPolygon(st_trace4, N, r_red, pos));  \n    \n// Lets add all the bits together and send them to screen\n\tfloat s_grn = max(s * mapcol.y, s_blade);\n\ts_grn = max(s_grn, (s0 +  sr + sm));\n\ts_grn += s1 / 1.5  + smb + smr;\n\n\tfloat s_red = st1*2.0 + st2*2.0 + smr;\n\t\t\n\tfloat s_blue = max(s_trace1 + s_trace2, s_blade) + smb;\n\n\tif (s_trace1 > 0.0 || s_trace2 > 0.0) { s_blue = max(s, s_blue); s_grn = max(s_grn, s_blue); }\n\n\tcolor += vec3(s_red , s_grn, s_blue);   \n    \n    vec4 texColor = mapcol * s;\n    \n    // Output to screen   \n    fragColor = vec4(color, 1.0);//Set the screen pixel to that color\n\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lltyWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[349, 349, 413, 413, 522], [524, 524, 613, 613, 836], [838, 838, 990, 990, 1146], [1148, 1148, 1205, 1255, 4970]], "test": "error"}
{"id": "lltyzj", "name": "ashima cellular worley L1 L2 ", "author": "ollj", "description": "iMouse.y modifies the hashes (based on mod(a,17*17)/7 ring)\niMouse.x sets jitter (how close to the border of a cell a point is allowed to be)\ncode looks like simplex noise by ashima (with permute() and min max sorting) but the result looks like voronoi.", "tags": ["voronoi", "noise", "worley", "simplex", "ashima", "gems", "gustavson"], "likes": 1, "viewed": 487, "published": "Public API", "date": "1533286270", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//i messed up the zoom within the frame, not sure how. its a bit hyperplanar\n//2d zoom\n#define ViewZoom 8.\n\n\n\n//divide by /aa for hairline drawing and sharp smoothstep()\n#define aa (min(iResolution.x,iResolution.y)/ViewZoom)\n#define fra(u)(u-.5*iResolution.xy)*ViewZoom/iResolution.y\n//usually first function of mainImage(), not typecast.\n\n\n#define pi acos(-1.)\n//trig definition for 3.14... can be better for smarter compilers.\n#define sat(x)clamp(x,0.,1.)\n#define dd(a)dot(a,a)\n#define u5(a) ((a)*.5+.5)\n#define u2(a) ((a)*2.-1.)\n#define ss(a,u)smoothstep(a,-a,u)\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\nv0 suv(v3 a){return dot(v3(1),a);}v0 suv(v2 a){return dot(v2(1),a);}\nv0 suv(v1 a){return a.x+a.y;}//sum of vector\nv0 mav(v1 a){return max(a.y,a.x);}v0 mav(v2 a){return max(a.z,mav(a.xy));}v0 mav(v3 a){return max(mav(a.zw),mav(a.xy));}\n#define miv(a)-mav(-a)\n\n#define ab012(a,b) (a+b*vec3(0,1,2))//desaturation.rgb kernel; b scales offset\n//rainbow*() ro from purple to purple for range[0..1], this makes ab012() desaturate into semi-gaussian scattering.\nvec3 rainbow(float a,float b){return u5(cos(2.*pi*ab012(a,b)));}//sine rainbow with offsets, desaturates colors for small b\nvec3 rainbow2(float a,float b){return abs(u2(fract(ab012(a,b))));}//triangle rainbow with offsets, desaturates colors for small b\nvec3 rainbow(float a){return rainbow(a,1./3.);}\nvec3 rainbow2(float a){return rainbow2(a,1./3.);}\n\n\n\n/*\niMouse.y modifies the hashes (base is mod(a,17*17)/7 rings)\niMouse.x sets jitter (how close to the border of a cell a point is allowed to be)\nlower left is 2d noise\n//other quadrants are 3d noise (2d hyperslices, 3rd domain is time, orthogonal to view)\ncode looks like simplex noise by ashima (with permute() and min max sorting) but the result looks like voronoi.\n*/\n\n\n//the hyperplanes are aligned to the lattice, and because of that alignment the animation does not look too \"random\"\n//is addressed below, but complicated\n\n\n//open challenge:\n//there exist ways to do a 2pass of 2 voronoi, first pass is 3x3 square lattice 9tap, with 3 buffered values.\n//, second pass is 5x5 square lattice 25 tap.\n//and the result is a [shortest distance to cell border]\n//and i would like to have this here, with a planar distance and/or a 3d distance to a cell border\n\n\n\n//fast cellular noise, optimized by ollj\n//mouse.xy is basically \"salting hashes\"\n//imouse.x sets jitter range[0..1] 0 is squares, 1 is maximum jitter.  (known bug, iMouse.x-scaling for lower left quadrant is a bit bad here)\n//imouse.z sets hash dividend, is ideally 1/7, but others can be fine too. use like a salt.\n//lower left quadrant is 2d input noise2x2x2\n//the other 3 quadrants are 3d input noises3x3x3 where .z is iTime. \n// the 3 quadrants inputs are swiveled differently to debug 3 orthogonal hyperplanes in one view.\n//return value .x is L1, .y is L2 according to [worley noise]\n//this uses a lot of mat2, or the v33 struct, and permute() functions similar to ahsima-simplex noise, defers the sorting, for performance.\n\n// Cellular noise (\"Worley noise\") in 3D in GLSL.\n// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\n// This code is released under the conditions of the MIT license.\n// See LICENSE file for details.\n// https://github.com/stegu/webgl-noise\n\n#define mous (iResolution.xyxy-iMouse.xyzw)\n//flip mouse everywhere, for shadertoy fun\n\nmat3 fr(mat3 a){return mat3(fract(a[0]),fract(a[1]),fract(a[2]));}\nmat3 fl(mat3 a){return mat3(floor(a[0]),floor(a[1]),floor(a[2]));}\nmat3 add(mat3 a,vec3 b){return mat3(a[0]+b.x,a[1]+b.y,a[2]+b.z);}\n//mat3 addF(mat3 a,vec3 b){return mat3(a[0]+b,a[1]+b,a[2]+b);}//contextual namespace hell.\nmat3 ma3(vec3 a,float b,float c){return mat3(a,vec3(b),vec3(c));}\n\n//th7 is for the 2d noise, should be (iResolution.y/7.) , BUT i managed to make other values look fine, too\n#define th7 (mous.y/iResolution.y)\n//usually ==1./7., because mod(a,7) is famous for old LCGs.\n//th8 is for the 3d noise, should be (iResolution.y/7.) , other values may work, but they tend to barely work at all, try only simple factors of 1/7\n#define th8 (iResolution.y/7./mix(1.,4.,mous.y/iResolution.y))\n//seems to be fine bounds, not too sure.\nvec3 mod2893d(vec3 x){return x-floor(x*(1./289.))*289.;}// Modulo 289 without a division (only multiplications)\nmat3 mod2893d(mat3 x){return x-fl(x*(1./289.))*289.;}// Modulo 289 without a division (only multiplications)\nvec3 mod73d(vec3 x){return x-floor(x*(1.0/th8))*th8;}// Modulo 7 without a division\nmat3 mod73d(mat3 x){return x-fl(x*(1.0/th8))*th8;}\n\n// Permutation polynomial: (34x^2+x) mod 289\nvec3 permute3d(vec3 x){return mod2893d((34.0*x+1.)*x);}\nmat3 permute3d(mat3 x){return mod2893d((34.0*x+1.)*x);}\n\n\n#define K 1./th8 \n// 1/7\n#define K2 1./th8/th8 \n// 1/(7*7)\n#define Ko (1.-K)*.5 \n// 1/2-K/2\n#define Kz 1./(th8-1.) \n// 1/6\n#define Kzo .5-2./(th8-1.)//0.416666666667 \n// 1/2-1/6*2\n#define jitter mous.x/iResolution.x \n// smaller jitter gives more regular pattern\n\nmat3 perm3(vec3 p){\n ;vec3 p1=permute3d(p-1.) \n ;vec3 p2=permute3d(p)\n ;vec3 p3=permute3d(p+1.)\n ;return mat3(p1,p2,p3);}\n \nmat3 perm3(vec3 p,vec3 b){\n ;vec3 p1=permute3d(p+b.x-1.) \n ;vec3 p2=permute3d(p+b.y)\n ;vec3 p3=permute3d(p+b.z+1.)\n ;return mat3(p1,p2,p3);}\n\n#define maa(a,b,c)  ma3(pf[0],pf[1].a,pf[2].b)+jitter*c\n#define mat3dd(a) a[0]*a[0]+a[1]*a[1]+a[2]*a[2]\n#define mat3ddmaa(a,b,c) mat3dd((maa(a,b,mat3(ox3[c],oy3[c],oz3[c]))))\n\n//ollj optimized these by putting vec3 and vec4 into higher doimain structs (like matrices)\n//todo, make it traversable by getting distance2Border.\nvec2 cellular(vec3 P,float m\n//code looks a lot like simplex3d moise (by ashima, with permute()\n//but is 3d voronoi/vorley with L1 and L2.\n){vec3 p=mod2893d(floor(P))\n ;mat3 pf=add(mat3(1,0,-1,1,0,-1,1,0,-1),fract(P)-.5)\n ;mat3 pp=perm3(permute3d(p.x+vec3(-1,0,1))+p.y)\n ;mat3 p1=perm3(pp[0]+p.z)\n ;mat3 p2=perm3(pp[1]+p.z)\n ;mat3 p3=perm3(pp[2]+p.z)\n ;mat3 ox=fr(p1*K)-Ko\n ;mat3 ox2=fr(p2*K)-Ko\n ;mat3 ox3=fr(p3*K)-Ko \n ;mat3 oz=fl(p1*K2)*Kz-Kzo\n ;mat3 oz2=fl(p2*K2)*Kz-Kzo\n ;mat3 oz3=fl(p3*K2)*Kz-Kzo \n ;mat3 oy=mod73d(fl(p1*K))*K-Ko\n ;mat3 oyy=mod73d(fl(p2*K))*K-Ko\n ;mat3 oy3=mod73d(fl(p3*K))*K-Ko\n ;mat3 dy=jitter*oy+pf[1].x\n ;mat3 dy2=jitter*oyy+pf[1].y\n ;mat3 dz=add(jitter*oz,vec3(pf[2].x,pf[2].y,pf[2].z))\n ;mat3 dz2=add(jitter*oz2,vec3(pf[2].x,pf[2].y,pf[2].z))\n ;mat3 dx=mat3(pf[0],pf[0],pf[0])+jitter*ox   \n ;mat3 dx2=mat3(pf[0],pf[0],pf[0])+jitter*ox2\n ;mat3 d1=maa(x,x,mat3(ox[0],oy[0],oz[0]))\n ;vec3 d31=mat3ddmaa(z,x,0)\n ;vec3 d32=mat3ddmaa(z,y,1)\n ;vec3 d33=mat3ddmaa(z,z,2)\n ;vec3 d11=dx[0]*d1[0]+dy[0]*d1[1]+dz[0]*d1[2]\n ;vec3 d12=dx[1]*dx[1]+dy[1]*dy[1]+dz[1]*dz[1]\n ;vec3 d13=dx[2]*dx[2]+dy[2]*dy[2]+dz[2]*dz[2] \n ;vec3 d21=dx2[0]*dx2[0]+dy2[0]*dy2[0]+dz2[0]*dz2[0]\n ;vec3 d22=dx2[1]*dx2[1]+dy2[1]*dy2[1]+dz2[1]*dz2[1]\n ;vec3 d23=dx2[2]*dx2[2]+dy2[2]*dy2[2]+dz2[2]*dz2[2]\n \n ;mat3 a\n \n //for a second pass that also gets distance2Border i need these 3 values\n //mg=g;//ID to shortest distance cell (integer vector)\n //mr=r;//vector to shortest distance    md=d;//shortest distance squared == is dot(r,r)\n\n\n // Sort out the two smallest distances (F1, F2)\n#if 0\n // Cheat and sort out only F1 //shortcut if you do not need L2\n ;vec3 d1=min(min(d11,d12), d13);\n vec3 d2=min(min(d21,d22), d23);\n vec3 d3=min(min(d31,d32), d33);\n vec3 d=min(min(d1,d2), d3);//shortest of 9 distances, except its 9*vec3()\n d.x=min(min(d.x,d.y),d.z);\n return vec2(sqrt(d.x)) ;} // F1 F1\n#else\n // Do it right and sort out both F1 and F2\n ;vec3 d1a=min(d11, d12);\n d12=max(d11, d12);\n d11=min(d1a, d13); // Smallest now not in d12 or d13\n d13=max(d1a, d13);\n d12=min(d12, d13); // 2nd smallest now not in d13\n vec3 d2a=min(d21, d22);\n d22=max(d21, d22);\n d21=min(d2a, d23); // Smallest now not in d22 or d23\n d23=max(d2a, d23);\n d22=min(d22, d23); // 2nd smallest now not in d23\n vec3 d3a=min(d31, d32);\n d32=max(d31, d32);\n d31=min(d3a, d33); // Smallest now not in d32 or d33\n d33=max(d3a, d33);\n d32=min(d32, d33); // 2nd smallest now not in d33\n vec3 da=min(d11, d21);\n d21=max(d11, d21);\n d11=min(da, d31); // Smallest now in d11\n d31=max(da, d31); // 2nd smallest now not in d31\n d11.xy=(d11.x < d11.y) ? d11.xy : d11.yx;\n d11.xz=(d11.x < d11.z) ? d11.xz : d11.zx; // d11.x now smallest\n ;d12=min(min(d21,min(d22,d31)),min(min(d12,d21),min(d22,d32)))\n ;d11.yz=min(d11.yz,d12.xy) // nor in d12.yz\n ;d11.y=min(d11.y,d12.z) // Only two more to go\n ;d11.y=min(d11.y,d11.z) // Done! (Phew!)\n ;return sqrt(d11.xy);} // F1, F2\n//ollj multiple times vectorized/matrixed this, and then had trouble debugging it, too sleepy, so i let it as is.\n//3d cells are tricky to debug is all\n#endif\n\n\n\n//above is 3d , below is 2d\n//above is 3d , below is 2d\n//above is 3d , below is 2d\n\n\n//crunched by ollj\n// Cellular noise (\"Worley noise\") in 2D in GLSL.\n// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\n// This code is released under the conditions of the MIT license of: // https://github.com/stegu/webgl-noise\n\nstruct v33{vec3 a;vec3 b;};//mat3 is likely faster\nstruct v22{vec2 a;vec2 b;};//mat2 i likely faster\nv33 ff(vec3 a){return v33(fract(a),floor(a));}//BUT here mat3 would just waste memory and mat32 mat23 are less comatible.\nv22 ff(vec2 a){return v22(fract(a),floor(a));}\nvec2 ff(float a){return vec2(fract(a),floor(a));}\nv33 sub(vec2 a,v33 b){return v33(a.x-b.a,a.y-b.b);}\nv33 sub(v33 a,v33 b){return v33(a.a-b.a,a.b-b.b);}\nv33 mul(float a,v33 b){return v33(a*b.a,a*b.b);}\n\n//float miv(vec2 a){return min(a.x,a.y);}\n//float miv(vec3 a){return min(miv(a.xy),a.z);}\n\n\n//mod(a,289.) without a division (only multiplications), because [mod(33.,33.)!=0] on too many implementations.\nvec3 mob89(vec3 a){return a-floor(a*(1./289.))*289.;}\nvec2 mob89(vec2 a){return a-floor(a*(1./289.))*289.;}\nv22  mob89(v22  a){return v22(a.a,a.b-floor(a.b*(1./289.))*289.);}//vers ypecial use case\nmat2 mob89(mat2  a){return mat2(a[0],a[1]-floor(a[1]*(1./289.))*289.);}//vers ypecial use case\nvec3 modth7(vec3 a){return a-floor(a*th7)/th7;}// Modulo 7 without a division\nv33  modth7(v33  a){return v33(a.a,(a.b-floor(a.b*th7)/th7)*th7);}//special case for a #define\nvec3 permute(vec3 a){return mob89((34.*a+1.)*a);}// Permutation polynomial: (34x^2+x) mod 289\n\nvec3 square(v33 a){return a.a*a.a+a.b*a.b;}\n\n#define tt3(p,f,j,m,a) square(sub(j,sub(v33(vec3(a),f),mul(m,mul(m,modth7(ff(p*th7)))))))\n//vec3 tt3(vec3 p,vec3 f,vec2 j,float m,float a){return square(sub(j,sub(v33(vec3(a),f),mul(m,mul(m,modth7(ff(p*th7)))))));}\n //;v33 g=modth7(ff(p*th7))g=mul(m,g);v33 t=v33(vec3(a),f);t=sub(t,g);t=sub(j,t);return t.a*t.a+t.b*t.b;}//operand-separated\n\n//the [-Ko] results in offsetting the whole thing, within a raster, which is pretty useless, and therefore removed.\n#define permi(c) p=permute(o+k.b.y+px.c)\n#define ppm(d,e,c) r[d]=tt3(p,f,k.a,m,e);permi(c)\n\n// Cellular noise,returning F1 and F2 in a vec2 //3x3 search window reduced to 2 permute()as special case voronoi\n//m[0..1] sets distortedness for a GOOD LCG (minimal self-similarity) m=1./7., by sqiveling this parameter, you get +0.7 domain very cheaply\n//as in by making m a 3rd parameter, you ALMMOST get cheap cellular3d noise, BUT it is likely a bit flawed, more repetitive, shorter period.\nvec2 cellular(vec2 P,float m//this is voronoi without loop. the permute() function marks +1 iteration/tap //is 4tap voronoi in O(3)\n){mat3 r;\n ;v22 k=mob89(ff(P))\n ;vec3 o=vec3(-1,0,1)\n ;vec3 f=o+.5\n ;vec3 px=permute(o+k.b.x)\n ;vec3 permi(x)\n ;ppm(0,-.5,y)\n ;ppm(1,+.5,z)\n //it seems that the loop got unrolles and al lits min() fucntions fold into the below\n //which is quite a lot of symmetry folding, surely gets better performance.\n ;r[2]=min(r[0],r[1])\n ;r[1]=clamp(r[1],r[0],tt3(p,f,k.a,m,1.5))\n ;r[0]=min(r[1],r[2])\n ;r[1]=max(r[2],r[1])\n ;r[0].xy=mix(r[0].yx,r[0].xy,step(r[0].x,r[0].y))\n ;r[0].xz=mix(r[0].zx,r[0].xz,step(r[0].x,r[0].z))\n ;r[0].yz=min(r[0].yz,r[1].yz)//can not be inserted in below line , because r[0].y is a return value. \n ;r[0].y=min(miv(r[0].yz),r[1].x)\n ;return sqrt(r[0].xy);}\n\n\nmat2 rot(float a){float s=sin(a);float c=cos(a);return mat2(c,-s,s,c);}\n\n\n//above is subroutines\n//above is subroutines\n\nvoid mainImage(out vec4 O,in vec2 U\n){vec2 u=fra(U)\n ;vec2 m=fra(mous.xy)\n //;vec2 n=fra2(mous.zw)/iResolution\n //;float p=(length(m.xy-u)*5.)\n //;float q=(length(n.xy-u)*7.)\n //;m=1.-m //flip m for shadertoy preview\n // ;vec2 d=cellular(u,m.x/ViewZoom)\n ;m.x/=ViewZoom\n ;vec2 d=vec2(0)\n ;if(U.x<iResolution.x*.5\n ){\n  if(U.y<iResolution.y*.5){\n   ;m.x=clamp(m.x*iResolution.y/iResolution.x*.5+.5,0.,.78)\n   //;m.x=max(-ViewZoom*.5,m.x)\n   //;m.x*=iResolution.y/iResolution.x\n   ;d=cellular(u,m.x)\n  ;}else{   \n   ;m.x/=iResolution.x/mous.x\n   ;d=cellular(vec3(u,iTime),m.x)\n   ;}\n  ;\n ;}else{\n  ;if(U.y<iResolution.y*.5){\n   ;d=cellular(vec3(iTime,u),m.x)//3d noise u.xy\n   ;}else{\n   ;vec3 a=vec3(u,iTime);\n   //the hyperplanes are aligned to the lattice, and because of that alignment the animation does not look too \"random\"\n   //the plane should be rotated by pi*(sqrt(5.)*5.+.5) t avoid repetition any synchronization.\n   //a=vec3(u,0);a.zx*=rot(iTime*.2) ;a.zx*=rot(iTime*.61*.1)//yes you can easily see 3d rotation of a simplex4d in its 2d slice.\n   ;d=cellular(a.xzy,m.x)\n ;}}\n //;d.x=d.y//only L2\n //;d.y=d.x//only L2 \n //;d=1.-d\n ;O=vec4(d,0,1)//3d noise u.xy\n ;}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lltyzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[632, 632, 645, 645, 666], [666, 666, 679, 679, 700], [701, 701, 714, 714, 730], [730, 746, 759, 759, 780], [780, 780, 793, 793, 820], [820, 820, 833, 833, 866], [970, 1086, 1116, 1116, 1150], [1150, 1210, 1241, 1241, 1276], [1276, 1340, 1362, 1362, 1387], [1388, 1388, 1411, 1411, 1437], [3381, 3381, 3397, 3397, 3447], [3448, 3448, 3464, 3464, 3514], [3515, 3515, 3539, 3539, 3580], [3581, 3672, 3705, 3705, 3737], [4154, 4195, 4217, 4217, 4251], [4251, 4307, 4329, 4329, 4360], [4360, 4416, 4436, 4436, 4469], [4469, 4500, 4520, 4520, 4550], [4552, 4597, 4620, 4620, 4652], [4653, 4653, 4676, 4676, 4708], [4974, 4974, 4993, 4993, 5095], [5098, 5098, 5124, 5124, 5238], [9008, 9082, 9097, 9097, 9128], [9128, 9204, 9219, 9219, 9250], [9251, 9251, 9268, 9268, 9300], [9301, 9301, 9323, 9323, 9352], [9353, 9353, 9374, 9374, 9403], [9404, 9404, 9427, 9427, 9452], [9546, 9658, 9677, 9677, 9711], [9712, 9712, 9731, 9731, 9765], [9766, 9766, 9785, 9785, 9832], [9832, 9856, 9876, 9876, 9927], [9927, 9951, 9971, 9971, 9998], [9998, 10029, 10049, 10049, 10095], [10095, 10124, 10145, 10145, 10173], [10219, 10219, 10238, 10238, 10262], [10813, 11209, 11343, 11343, 12017], [12020, 12020, 12038, 12038, 12091], [12141, 12141, 12179, 12179, 13315]], "test": "error"}
{"id": "lltyzX", "name": "cubelattice", "author": "Harha", "description": "first raymarching test", "tags": ["raymarch", "cube"], "likes": 3, "viewed": 508, "published": "Public API", "date": "1533515066", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n * Started from: https://www.youtube.com/watch?v=yxNnRSefK94\n * \n * Just a quick GLSL/Raymarching experiment.\n *\n **/\n\n#define GRID_CELL_SIZE 3.0\n#define GRID_SIZE (GRID_CELL_SIZE + 1.0)\n#define GRID_MOD (GRID_SIZE * 2.0)\n\nfloat map(vec3 p)\n{\n\tfloat t1 = iTime * 0.5;\n\tp.x += sin(p.y) * 0.2;\n\tp.y += sin(p.x) * 0.2;\n\tvec3 q = fract(p) * 2.0 - 1.0;\n\tq = clamp(q, -0.33, 0.33);\n\treturn length(q) - 0.33;\n}\n\nfloat trace(vec3 o, vec3 r)\n{\n\tfloat t = 0.0;\n\tfor (int i = 0; i < 32; ++i)\n\t{\n\t\tvec3 p = o + r * t;\n\t\tfloat d = map(p);\n\t\tt += d * 0.5;\n\t}\n\t\n\treturn t;\n}\n\nbool circle(in float r, in vec2 o, in vec2 v)\n{\n    return (length(o - v) <= r) ? true : false;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = gl_FragCoord.xy;\n\n\tbool in_circle = circle(GRID_CELL_SIZE, uv - mod(uv, GRID_MOD) + vec2(GRID_SIZE), uv);\n\n\tvec3 color = vec3(0.0, 0.0, 0.0);\n\tif (in_circle)\n\t{\n\t\tuv /= iResolution.xy;\n\t\tuv = uv * 2.0 - 1.0;\n\t\tuv.x *= iResolution.x / iResolution.y;\n\n\t\tvec3 r = normalize(vec3(uv, 1.0));\n\t\t\n\t\tfloat the1 = sin(iTime * 0.1) * 5.0;\n\t\tfloat the2 = iTime * 0.25;\n\t\tr.xz *= mat2(cos(the1), -sin(the1), sin(the1), cos(the1));\n\t\tr.xy *= mat2(cos(the2), -sin(the2), sin(the2), cos(the2));\n\n\t\tfloat t1 = iTime * 0.5;\n\t\tvec3 o = vec3(cos(t1), sin(t1), 0.0);\n\t\t\n\t\tfloat t = trace(o, r);\n\t\t\n\t\tfloat fog = 1.0 / (1.0 + t * t * 0.25);\n\t\t\n\t\tr = sin(r + iTime * 2.5);\n\t\tr *= 0.5;\n\t\tr += 1.0;\n\t\tcolor = vec3(fog) * vec3(r.x, r.y, r.z);\n\t}\n\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lltyzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[227, 227, 246, 246, 407], [409, 409, 438, 438, 563], [565, 565, 612, 612, 662], [664, 664, 719, 719, 1485]], "test": "ok"}
{"id": "llVczD", "name": "Metallic Effect", "author": "momoro", "description": "Slight metallic effect in fullscreen", "tags": ["wip"], "likes": 0, "viewed": 371, "published": "Public API", "date": "1535424222", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define PI 3.141592654\n\nfloat map(float value, float inMin, float inMax, float outMin, float outMax) {\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n}\n\n\nmat2 rotate(float angle) {\n    return mat2(cos(angle), -sin(angle),\n                sin(angle), cos(angle)\n    );\n}\n\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n\nfloat atan201(float x, float y) {\n    return (atan(x, y) + PI) / (PI * 2.);\n}\n\nfloat sin01(float n) {\n    return sin(n)/2.+.5;\n}\n\nvec2 sin01(vec2 n) {\n    return sin(n)/2.+.5;\n}\n\nvec4 blend(vec4 bg, vec4 fg) {\n    vec4 c = vec4(0.);\n    c.a = 1.0 - (1.0 - fg.a) * (1.0 - bg.a);\n    if(c.a < .00000) return c;\n    \n    c.r = fg.r * fg.a / c.a + bg.r * bg.a * (1.0 - fg.a) / c.a;\n    c.g = fg.g * fg.a / c.a + bg.g * bg.a * (1.0 - fg.a) / c.a;\n    c.b = fg.b * fg.a / c.a + bg.b * bg.a * (1.0 - fg.a) / c.a;\n    \n    return c;\n}\n\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return dot(m, g);\n}\n\n\nfloat fbm1d(float x, float amplitude, float frequency, float offset) {\n    x += offset;\n    float y = 0.;\n    // Properties\n    const int octaves = 8;\n    float lacunarity = 1.144;\n    float gain = 1.092;\n    \n    // Initial values\n    //sin(u_time) * 5. + 10.;\n    //sin(u_time/10. + 10.);\n    \n    // Loop of octaves\n    for (int i = 0; i < octaves; i++) {\n        y += amplitude * snoise(vec2(frequency*x));\n        frequency *= lacunarity;\n        amplitude *= gain;\n    }\n    \n    return y;\n}\n\n\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\nfloat smax(float a,float b, float k)\n{\n    return -smin(-a,-b,k);\n}\n\nfloat smootheststep(float t) {\n    return -20.*pow(t, 7.)+70.*pow(t,6.)-84.*pow(t,5.)+35.*pow(t,4.); // when smootherstep's second derivative isn't enough\n}\n\n\nfloat pcsmooth(float x) {\n    return -pow(cos((PI*(x)/2.)), 3.) + 1.;\n}\n\n\n///////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec4 color;\n    vec2 st = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    st /=1.036;\n    st += vec2(0.020,0.020);\n    \n    st *= rotate(iTime/.9);\n    \n    /////////////////////////////////////////////////////////////\n    // Blobby circle\n    #define arcs 7.\n    \n    float f = atan201(st.x, st.y); // angle\n    float m = smoothstep(0., 1., fract(f * arcs)); // mix amount\n\t\n     m = pcsmooth(fract(f*arcs));\n    \n    f = ceil(f * arcs) / arcs; // split up\n    \n    float fNext = f + 1./arcs;\n    // fNext = f;\n    \n    \n    // Smooth the blob at the end\n    bool e = false;\n    if(f > (arcs-1.)/arcs + .01) {\n\t\tfNext = 1./arcs;\n    }\n    \n    /////////////////////////////////////////////////////////////\n    // Add noise\n    float amp = 10000.;\n    float freq = 30.;\n    \n    float offset = 1.144 + iTime/300.;\n    f = fbm1d(f, amp, freq, offset);\n    fNext = fbm1d(fNext, amp, freq, offset);\n    \n    float noiseMin = -20.;\n    f =  map(f, noiseMin, 1., 0.648, 0.712);\n    fNext = map(fNext, noiseMin, 1., 0.648, 0.712);\n\n    float len = length(st);\n\n    float mx = mix(f, fNext, m);\n  //  mx = clamp(mx, 0., 1.);\n\n    \n  \n\t/////////////////////////////////////////////////////////////\n    // First pass\n    #define steps 20.\n    for(float i=0.; i<steps; i++) {\n   \t\tfloat df = length(st) + (mx / 10.296) * (1.0 - i/steps);\n        \n        float incr = 0.4 - (0.4 * i/steps);\n        \n        float f = 1.0 - smoothstep(incr-.001, incr, df);\n\n        // SHADOW\n        f -=  (1.0 - (fract(df*steps) + 0.696)) * 100.768 * f;\n        vec3 rgb = vec3(f);\n        \n        vec3 hsv = vec3(1.);\n         hsv.x = pow(2. * fract((i*6.)/steps + iTime/2.3) - 1., 2.);\n        hsv.x = map(hsv.x, 0., 1., 0.0, 0.052);\n        hsv.y = .9;\n\n        vec3 rgb2 = hsv2rgb(hsv);\n\n        rgb = rgb2 * rgb * 3.112;\n        float a = (i/steps + 0.640) * f;\n        a  = 0.072;\n\n        color = blend(color, vec4(rgb, a * f));\n    }\n    \n    \n\n\n  \n\t/////////////////////////////////////////////////////////////\n    // Second pass    \n    for(float i=0.; i<steps; i++) {\n   \t\tfloat df = len  *0.036;\n        \n        float incr = 0.4 - (0.4 * i/steps);\n        \n        float f = 1.0 - smoothstep(incr-.001, incr, df);\n\n        // SHADOW\n       f -=  (1.0 - (fract(df*steps) + .532)) * +3.280 * f;\n        \n        vec3 rgb = vec3(f);\n        \n        vec3 hsv = vec3(1.);\n        hsv.x = pow(2. * fract((i*6.)/steps + iTime/9.3) - 1., 2.);\n        hsv.x = map(hsv.x, 0., 1., 0.0, 0.964);\n        hsv.y = .9;\n        hsv.z = .3;\n\n        vec3 rgb2 = hsv2rgb(hsv);\n\n        rgb = rgb2 * rgb * 3.112;\n        float a = (i/steps + 0.01) - 0.472;\n       // a  = 0.208;\n\n       // color = blend(color, vec4(rgb, a * f));\n    }\n        \n    \n    fragColor = color;\n\n    // todo: rotate it and try to think about the light effect more\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llVczD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 103, 103, 178], [181, 181, 207, 207, 296], [299, 299, 321, 321, 652], [654, 654, 676, 676, 845], [847, 847, 868, 868, 915], [916, 916, 937, 937, 984], [985, 985, 1007, 1007, 1042], [1045, 1045, 1078, 1078, 1122], [1124, 1124, 1146, 1146, 1173], [1175, 1175, 1195, 1195, 1222], [1224, 1224, 1254, 1254, 1571], [1573, 1573, 1595, 1648, 3337], [3340, 3340, 3410, 3410, 3837], [3840, 3840, 3878, 3878, 3955], [3957, 3957, 3995, 3995, 4024], [4026, 4026, 4056, 4056, 4182], [4185, 4185, 4210, 4210, 4256], [4405, 4405, 4461, 4461, 7293]], "test": "ok"}
{"id": "llyyDz", "name": "falling net", "author": "vitalbrick", "description": "first shader", "tags": ["first"], "likes": 0, "viewed": 357, "published": "Public", "date": "1535733898", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float simpleMap(float dIn, float oMin, float oMax){\n    return dIn * (oMax - oMin) + oMin;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x;\n    \n    float cf = simpleMap(sin(simpleMap(uv.x, 0., 2.)), 20., 30.);\n    cf = cf * simpleMap(uv.y, 0.7, 1.);\n\n    float c0 = tan(iTime-uv.x*cf + uv.y*cf)/2.+0.5;\n    float c1 = tan(iTime+uv.x*cf + uv.y*cf)/2.+0.5;\n    \n    float v0 = (c0 + c1) * (0.0 + simpleMap(uv.y, .3, 1.));\n    float v1 = (c1 - c0) * 0.9;\n    float v2 = cos(iTime) * 0.3;\n    \n    fragColor = vec4(v0, v1, v2, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llyyDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 51, 51, 92], [94, 94, 151, 151, 582]], "test": "ok"}
{"id": "llyyRh", "name": "flypointtest", "author": "zk", "description": "flypointtest", "tags": ["flypointtest"], "likes": 1, "viewed": 89, "published": "Public", "date": "1535530729", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define _SnowflakeAmount 10\t// Number of snowflakes\n#define _BlizardFactor 0.1\t\t// Fury of the storm !\n\nvec2 uv;\n\nfloat rnd(float x)\n{\n    return fract(sin(dot(vec2(x+47.49,38.2467/(x+2.3)), vec2(12.9898, 78.233)))* (43758.5453));\n}\n\nfloat drawCircle(vec2 center, float radius)\n{\n    return 1.0 - smoothstep(0.0, radius, length(uv - center));\n}\n\n\nfloat drawCC(float p){\n    float j;\n    float color = 0.;\n    for(int i=0; i<_SnowflakeAmount; i++)\n    {\n        j = float(i);\n        float a = 0.0;\n        float b = 0.0;\n        \n        float c = -1.0* 3.14/4.0;\n        if(mod(p,2.0)==0.0){\n            c +=  j*3.14/20.0;\n        }\n        else{\n            c +=  (j + 0.5)*3.14/20.0;\n        }\n        float m = sin(fract(((iTime+p)*0.05))) ;\n        float x = 0.9 *m;  \n        float y = 0.9 *m;\n        float x1=(x-a)*cos(c)-(y-b)*sin(c)+a;\n        float y1=(y-b)*cos(c)+(x-a)*sin(c)+b;\n//      float speed =  0.3+rnd(cos(j))*(0.7+0.5*cos(j/(float(_SnowflakeAmount)*0.25)));\n        vec2 center = vec2(x1,y1);//vec2((0.25-uv.y)*_BlizardFactor+rnd(j)+0.1*cos(iTime+sin(j)), mod(sin(j)-speed*(iTime*1.5*(0.1+_BlizardFactor)), 0.65));\n        color += drawCircle(center,0.01*(sin(3.0*m)))*(1.0 - sin(1.5*m)) ;\n     }\n        return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uv = fragCoord.xy / iResolution.x;\n   // uv -= 0.5;\n    //uv.x *= iResolution.x/iResolution.y;\n    vec3 col =  vec3(0.5,0.35,0.79) ;//0.5 + 0.5*cos(0.01*iTime+uv.xyx+vec3(128,92,203));\n\n    fragColor = vec4(col, 1.0);\n    float j;\n   \n    for(float i=0.; i<20.; i++)\n    {  \n        fragColor += vec4(drawCC(i));\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llyyRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[114, 114, 134, 134, 232], [234, 234, 279, 279, 344], [347, 347, 369, 369, 1242], [1244, 1244, 1301, 1301, 1626]], "test": "ok"}
{"id": "llyyzh", "name": "3D Adventures #1 - 3D Meets 2D", "author": "bombshell93", "description": "After the last shader 2D Adventures #3 I decided to jump back to 3D with some 2D knowledge, nothing particularly complicated, simply a cleaner ray marcher than I'd written previously with some triplanar mapping used to apply 2D effects to the surface.", "tags": ["3d"], "likes": 6, "viewed": 204, "published": "Public", "date": "1535027015", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//// ABSTRACT\n//\n//\tAfter the last shader 2D Adventures #3 (https://www.shadertoy.com/view/ldKyDt) \n//\tI decided to jump back to 3D with some 2D knowledge, nothing particularly\n//\tcomplicated, simply a cleaner ray marcher than I'd written previously with\n//\tsome triplanar mapping used to apply 2D effects (polkadots inside a hex) on the\n//\tsurface.\n//\n//\tI feel like I could have done something more with this shader but I left it on\n//\tthe back burner too long to recall what that was, still though I think the\n//\teffect is pretty cool and it at least demonstrates the concept it was started\n//\tfor, that being using a 2D effect to improve a 3D effect.\n//\n//// AUTHOR\n//\n//\tScott R Howell (Bombshell93)\n\n// config\n\nconst float fov = 1.62;\n\n// some handy numbers\n\nconst vec4 vec = vec4(0., 1., 1.e3, sqrt(3.));\nconst vec4 pi = vec4(3.14159265359, 3.14159265359 * 2., 3.14159265359 * .5, 3.14159265359 * .25);\n\n//// map\n//\n//\tfinds and returns the distance from the nearest surface, in this case a single \n//\tunit sphere\n\nfloat map(vec3 p) {\n    \n    return length(p) - 1.;\n}\n\n//// map_normal\n//\n//\tusing the nearest surface in each direction finds the surface normal for\n//\tthe given position\n\nvec3 map_normal(vec3 p) {\n    \n    return normalize(vec3\n        ( map(p + vec.zxx) - map(p - vec.zxx)\n        , map(p + vec.xzx) - map(p - vec.xzx)\n        , map(p + vec.xxz) - map(p - vec.xxz)));\n}\n\n//// march\n//\n//\tgiven a ray origin, ray direction, step count, min and max check distance\n//\tfinds the distance the ray will travel before hitting a surface\n\nfloat march(vec3 ro, vec3 rd, int max_steps, float min_dist, float max_dist) {\n    \n    float dist = 0.;\n    int i = 0;\n    for (int i = 0; i < max_steps; ++i) {\n        \n        float mdist = map(ro + rd * dist);\n        dist += mdist;\n        if (mdist < min_dist || dist > max_dist) {\n            \n            return dist;\n        }\n    }\n    return max_dist;\n}\n\n//// axial\n//\n//\tripped clean from my 2D Adventures #3 converts 2D coordinates to axial\n//\tcooridnates\n\nvec2 axial(vec2 p) {\n    \n    float y3 = p.y * sqrt(3.);\n    return floor((\n        floor(vec2(p.x * 2., y3 - p.x) + 1.)\n        + (y3 + 1. + p.x)) / 3.);\n}\n\nvoid mainImage( out vec4 oc, in vec2 fc ) {\n    \n    // center the UV and adjust for aspect ratio\n    \n    vec2 uv = (fc - iResolution.xy * .5) / iResolution.y;\n    \n    // cos time, sin time\n    \n    float ct = cos(iTime);\n    float st = sin(iTime);\n    \n    // eye, look, up\n    \n    vec3 e = vec3(st, ct, 0.) * 3.5;\n    vec3 l = vec3(0., 0., 0.);\n    \n    // up, forward, right\n    \n    vec3 u = vec3(0., 0., 1.);\n    vec3 f = normalize(l - e);\n    vec3 r = cross(f, u);\n    \n    // ray direction\n    \n    vec3 rd = normalize((uv.x * r + uv.y * u) + f * fov);\n    \n    // march and find mask\n    \n    float d = march(e, rd, 64, .001, 10.);\n    float m = step(d, 10.);\n    \n    // find position\n    \n    vec3 p = e + rd * d;\n    \n    // find normal\n    \n    vec3 n = map_normal(p);\n    \n    // triplanar coordinates\n    \n    vec2 uuv = p.xy;\n    vec2 ruv = p.yz;\n    vec2 fuv = p.zx;\n    uv = length(uuv) < length(ruv) ? uuv : ruv;\n    uv = length(uv) < length(fuv) ? uv : fuv;\n    \n    vec3 c = vec3(0., 0., 0.);\n    \n    // polkadots\n    \n    c += step(length(mod(uv + iTime * .15, .2) - .1), .05) * vec3(1., .2, .2);\n    c += step(length(mod(uv + iTime * .15 + vec2(.1), .2) - .1), .025) * vec3(1., 1., .2);\n    \n    // hex mask\n    \n    vec2 ax = mod(axial(uv), 5.);\n    c *= step(length(ax), .1);\n    \n    oc = vec4(m * c, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llyyzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1023, 1023, 1042, 1042, 1076], [1196, 1196, 1221, 1221, 1395], [1556, 1556, 1634, 1634, 1920], [2026, 2026, 2046, 2046, 2182], [2184, 2184, 2227, 2281, 3520]], "test": "error"}
{"id": "lt3cWl", "name": "Water Ripples Filter", "author": "nmtrang29", "description": "Fork of https://www.shadertoy.com/view/MsBSz1", "tags": ["shader"], "likes": 0, "viewed": 86, "published": "Public", "date": "1534600333", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float timeFactor = 10.0;\n\nfloat ripple(float dist, float rippleIntensity, float rippleScale) {\n\treturn rippleScale * (sin(dist * rippleIntensity - iTime * timeFactor) / (dist * rippleIntensity));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float intensity = ripple(distance(fragCoord.xy / iResolution.xy, iMouse.xy / iResolution.xy), 100., 5.);\n    for(int x = 0; x < 2; x++) {\n        for(int y = 0; y < 2; y++) {\n            vec2 center = vec2(0.375 + float(x) * 0.25, 0.375 + float(y) * 0.25);\n            float dist = distance(fragCoord.xy / iResolution.xy, center);\n            intensity += ripple(dist, 50.  + 100. * float(x), 2.5 + 5. * float(y));\n        }\n    }\n    vec4 color = vec4(0.,0.,intensity,1.0);\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt3cWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 32, 100, 100, 203], [205, 205, 262, 262, 766]], "test": "ok"}
{"id": "lt3czs", "name": " [SH18] Adonis Bob", "author": "TLC123", "description": "Hambone mit node xyz scaling: variation of conecapsule", "tags": ["3d", "human", "sh18", "conecapsule", "hambone"], "likes": 12, "viewed": 249, "published": "Public", "date": "1533667243", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TAU 6.28318530718\n//Procedural animation. What a horrable mess i made.  \n// 2018 shadertoy competition entry.\n\n\n struct mdt { vec3 pos; vec3 scale; }; \nvec3 walkbob(float t){  return vec3(0.,0.,sin ( smoothstep(0.,1. , mod(t,1.0))*TAU));} \nvec3 swing(float t){  return vec3(0.,sin (smoothstep(0.,1. , mod(t,1.0))*TAU),0.);} \nvec3 sway(float t){  return vec3(    sin ( smoothstep(0.,1. ,mod(t,1.0))*TAU),0.,0.);} \n \nconst mdt[] v1= mdt[] ( \n    mdt(vec3(0, -2, 33),vec3(8,8,12)),mdt(vec3(0,-3, 50),vec3(14,14,15)),\n    mdt(vec3(0,-2, 85),vec3(14,10, 14)),mdt(vec3(0, 0,100),vec3(5,5,5)), \n    mdt(vec3(0,-15,117),vec3(12,10,14)),mdt(vec3(0, 5,140),vec3(17,17,17)));\nconst mdt[] v2= mdt[]  ( \n    mdt(vec3( 5, 0,96),vec3(5,6,4)),mdt(vec3(20,  2,95),vec3(7,7,6)),\n    mdt(vec3(40,  0,60),vec3(4,5,4)),mdt(vec3(35,-21,30),vec3(2,3,2)),\n    mdt(vec3(35,-25,10),vec3(8,4,8)),mdt(vec3(35,-20,-5),vec3(3,4,3)));\nconst mdt[] v3= mdt[]  ( \n    mdt(vec3(  -5, 0,96),vec3(5,6,4)),mdt(vec3(-20,  2,95),vec3(7,7,6)),\n    mdt(vec3(-40,  0,60),vec3(4,5,4)),mdt(vec3(-35,-21,30),vec3(2,3,2)),\n    mdt(vec3(-35,-25,10),vec3(8,4,8)),mdt(vec3(-35,-20,-5),vec3(3,4,3)));\n\n\n\nfloat  synmin(float a,float  b,float  r  ) {\n    // drop-in function for smin  \n\t \n        float  e =   max(r*0.02,(abs(a-b)/r) );\n        return min (a,b)- max(0.01,(r*10.1*e*(exp(1.0-(e*0.6 ))))/max(a,b)*0.5)\n \n            ;}\n// rotm sphere  credit to Inigo Quilez\nfloat sdSphere(in vec3 p, float s) {\n    return length(p) - s;}\nfloat smin( float a, float b, float k )\n{    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);}\n\nfloat conecapsule (vec3 p, vec3 p1 ,vec3 p2 ,vec3 r1,vec3 r2 ) {\n// eats vec4 (x,y,z,r) X 2\n    p1=vec3(p1.x,p1.y,max(-85.,p1.z));\n    p2=vec3(p2.x,p2.y,max(-85.,p2.z));\nvec3 a=mix(p1,p2,0.05);\nvec3 b=mix(p1,p2,0.85);;\nvec3 n1=pow(abs(normalize(p-a)),vec3(1.36));\nvec3 n2=pow(abs(normalize(p-b)),vec3(1.36)); \nfloat\t\td1= length  ( vec3(r1.x*n1.x, r1.y*n1.y,r1.z*n1.z));\nfloat\t\td2= length (vec3(r2.x*n2.x, r2.y*n2.y,r2.z*n2.z)); \nvec3\t\tba = b - a;\nvec3\t\tpa = p - a;\n    float v= dot(pa,ba) / dot(ba,ba);\nfloat\t\th = clamp(  v,   0.0,   1.0);\nfloat\t\t\td=mix(d1,d2,  smoothstep(0.0,1.0,   h));\n     float r= d ;// / 2.0;\n \n            return length (pa - ba*h) - r;\n\n}\n\nvec4 map(vec4 r0)\n{  vec3 p=r0.xyz ;\n \nfloat myTime= iTime*2.1 ;\n \n \n  mdt[] v4= mdt[]  ( \n    mdt(vec3( 1, 0, 30)+walkbob(myTime)*8.,vec3(4,4,6)), \n      mdt(vec3(13,  5, 30)+walkbob(myTime)*3.+walkbob(myTime/2.+0.5)*3.,vec3(10,10,11)),\n    mdt(vec3(20,-15,-20)+walkbob(myTime/2.+0.5)*8.+swing(myTime/2.+0.0)*20.+sway(myTime/4. )*2.,vec3(7,7,7)), \n      mdt(vec3(15,  1,-84)+walkbob(myTime/2.+0.5)*8.+sway(myTime/4.+0.25+0.5)*6.,vec3(5,6,4)),\n    mdt(vec3(22, -10,-81)+walkbob(myTime/2.+0.5)*8.+sway(myTime/4.+0.25+0.5)*6.,vec3(8,7,5)),\n      mdt(vec3(25,-20,-84)+walkbob(myTime/2.+0.5)*8.+sway(myTime/4.+0.25+0.5)*8.,vec3(4,6,4)));\n  mdt[] v5= mdt[]  ( \n    mdt(vec3(  -1, 0, 30)+walkbob(myTime)*8.,vec3(4,4,6)),\n      mdt(vec3(-13,  5, 30)+walkbob(myTime)*3.+walkbob(myTime/2.)*3.,vec3(10,10,11)),\n    mdt(vec3(-20,-15,-20)+walkbob(myTime/2.)*8.+swing(myTime/2.+0.5)*20.+sway(myTime/4. +0.5)*2.,vec3(7,7,7)),\n      mdt(vec3(-15,  1,-84)+walkbob(myTime/2.)*8. +sway(myTime/4.+0.35)*6.,vec3(5,6,4)),\n    mdt(vec3(-22, -10,-81)+walkbob(myTime/2.)*8. +sway(myTime/4.+0.35)*6.,vec3(8,7,5)),\n      mdt(vec3(-25,-20,-84)+walkbob(myTime/2.)*8. +sway(myTime/4.+0.35)*8.,vec3(4,6,4))); \n\n \n \n \n \n // make a few points\nfloat d1=1000000000.;\nfloat d2=d1;\nfloat d3=d1;\nfloat d4=d1;\nfloat d5=d1;\n \n for( int i=0; i<5; i++ ){\n  d1= synmin(d1,conecapsule( p -walkbob(myTime)*6.+swing(myTime/2.+0.5)*2.\n                            +vec3(0,-4,0)+sway(myTime/4.+0.5)*2.\n                            ,  v1[i].pos , v1[i+1].pos ,v1[i].scale,v1[i+1].scale ),2.);\n  d2= synmin(d2,conecapsule( p-walkbob(myTime)*4.+walkbob(myTime+0.25)*2.,  v2[i].pos , v2[i+1].pos ,v2[i].scale,v2[i+1].scale ),1.);\n  d3= synmin(d3,conecapsule( p-walkbob(myTime)*4.+walkbob(myTime-0.25)*2.,  v3[i].pos , v3[i+1].pos ,v3[i].scale,v3[i+1].scale ),1.);\n  d4= synmin(d4,conecapsule( p,  v4[i].pos , v4[i+1].pos ,v4[i].scale,v4[i+1].scale ),1.);\n  d5= synmin(d5,conecapsule( p,  v5[i].pos , v5[i+1].pos ,v5[i].scale,v5[i+1].scale ),1.);\n }\n float d=synmin(d1,min(  min(d3,d2), smin(d4,d5,1.0)),3.0);\n float z=p.z+93.;\n  \n float c1= mod( \n        mod (floor(p.x/30.),2.)+\n        mod (floor(p.y/30.),2.)+\n        mod (floor(p.z/30.),2.) ,2.);\n vec3 c2= vec3(0.9,  0.9, 0.8);\n vec3 c= d<z?c2:vec3(c1);\n return vec4(min(d,z) ,c)\n               ;\n\n }\n\n\nconst vec3 bbox_min = vec3(-7.363703305156273,-7.363703305156273,-7.363703305156273);\nconst vec3 bbox_max = vec3(7.363703305156273,7.363703305156273,7.363703305156273);\n// ray marching. ro is ray origin, rd is ray direction (unit vector).\n// result is (t,r,g,b), where\n//  * t is the distance that we marched,\n//  * r,g,b is the colour of the distance field at the point we ended up at.\n//    (-1,-1,-1) means no object was hit.\nvec4 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 700.0;\n   \n    float t = tmin;\n    vec3 c = vec3(-1.0,-1.0,-1.0);\n    for (int i=0; i<200; i++) {\n        float precis = 0.0005*t;\n        vec4 res = map( vec4(ro+rd*t,iTime) );\n        if (res.x < precis) {\n            c = res.yzw;\n            break;\n        }\n        t += res.x;\n        if (t > tmax) break;\n    }\n    return vec4( t, c );\n}\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( vec4(pos + e.xyy,iTime) ).x + \n                      e.yyx*map( vec4(pos + e.yyx,iTime) ).x + \n                      e.yxy*map( vec4(pos + e.yxy,iTime) ).x + \n                      e.xxx*map( vec4(pos + e.xxx,iTime) ).x );\n}\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( vec4(aopos,iTime) ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n// in ro: ray origin\n// in rd: ray direction\n// out: rgb colour\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    //vec3 col = vec3(0.7, 0.9, 1.0) +rd.z*0.8;\n    //vec3 col = vec3(0.8, 0.9, 1.0);\n    vec3 col = vec3(1.0, 1.0, 1.0);\n    vec4 res = castRay(ro,rd);\n    float t = res.x;\n    vec3 c = res.yzw;\n    if( c.x>=0.0 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n        col = mix(c,normalize(c),0.42);\n\n        // lighting        \n        float occ = calcAO( pos, nor );\n        vec3  lig = normalize( ro +vec3(0,10,10) );\n        float amb = clamp( 0.5+0.5*nor.z, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,lig.y,0.0))), 0.0, 1.0 )*clamp( 1.0-pos.z,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.z );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        vec3 lin = vec3(0.0);\n       lin += 1.30*dif*vec3(1.00,0.80,0.55);\n         lin += 2.00*spe*vec3(1.00,0.90,0.70)*dif;\n        //lin += 0.40*amb*vec3(0.40,0.60,1.00)*occ;\n        // lin += 0.50*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*bac*vec3(0.35,0.35,0.35)*occ;\n        // lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n        vec3 iqcol = col*lin;\n\n        //col = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n        col = mix(col,iqcol, 0.6);\n    }\n\n    return vec3( clamp(col,0.0,1.0) );\n}\n// Create a matrix to transform coordinates to look towards a given point.\n// * `eye` is the position of the camera.\n// * `centre` is the position to look towards.\n// * `up` is the 'up' direction.\nmat3 look_at(vec3 eye, vec3 centre, vec3 up)\n{\n    vec3 ww = normalize(centre - eye);\n    vec3 uu = normalize(cross(ww, up));\n    vec3 vv = normalize(cross(uu, ww));\n    return mat3(uu, vv, ww);\n}\n// Generate a ray direction for ray-casting.\n// * `camera` is the camera look-at matrix.\n// * `pos` is the screen position, normally in the range -1..1\n// * `lens` is the lens length of the camera (encodes field-of-view).\n//   0 is very wide, and 2 is a good default.\nvec3 ray_direction(mat3 camera, vec2 pos, float lens)\n{\n    return normalize(camera * vec3(pos, lens));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        vec2 mo = (iMouse.xy/iResolution.xy);\n\n    const vec3 origin = (bbox_min + bbox_max) / 2.0 +vec3 (0,0,10);\n    const vec3 radius = (bbox_max - bbox_min) / 2.0;\n    float r = max(radius.x, max(radius.y, radius.z)) / 1.0;\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n    \n      vec2 mouse = iMouse.xy / iResolution.xy;\n    //  vec3 eye = vec3 (cos (4. * mouse.x) * 67., sin (4. * mouse.x) *sin (4. * mouse.y) * 67., -cos (4. * mouse.y) * 67.);\n     //   vec3 ro =  vec3( -0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.0*sin(0.1*time + 6.0*mo.x) );\n\n    vec3 eye = vec3(sin(iTime/1.2+6.*mo.x)*290., cos(iTime/1.43+6.*mo.x)*290., cos(iTime/3.+6.*mo.y)*126. +100.);\n    vec3 centre = vec3(0.0, 0.0, cos(iTime/2.1)*50. +50.0);\n    vec3 up = eye+ vec3(0.0, 0.0, 10.0);\n \n    mat3 camera = look_at(eye, centre, up);\n    vec3 dir = ray_direction(camera, p, 2.5);\n\n    vec3 col = render( eye, dir );\n    \n    // convert linear RGB to sRGB\n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt3czs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[160, 160, 182, 182, 246], [248, 248, 268, 268, 331], [333, 333, 352, 352, 419], [1161, 1161, 1205, 1240, 1388], [1389, 1428, 1464, 1464, 1491], [1492, 1492, 1533, 1533, 1624], [1626, 1626, 1690, 1717, 2289], [4765, 5025, 5065, 5065, 5448], [5449, 5449, 5481, 5481, 5782], [5783, 5783, 5825, 5825, 6139], [6140, 6204, 6243, 6330, 7703], [7704, 7901, 7947, 7947, 8097], [8098, 8366, 8421, 8421, 8471], [8472, 8472, 8529, 8529, 9602]], "test": "error"}
{"id": "lt3yDS", "name": "(Temporal) Dithering", "author": "matt77hias", "description": "(Temporal) Dithering\n\nPart of MAGE (https://github.com/matt77hias/MAGE; https://github.com/matt77hias/MAGE/blob/master/MAGE/Shaders/shaders/backbuffer/back_buffer_PS.hlsl\n\nSee also: https://www.shadertoy.com/view/Mt3cRX", "tags": ["dithering", "temporaldithering"], "likes": 1, "viewed": 178, "published": "Public", "date": "1533832119", "time_retrieved": "2021-10-01T00:00:00", "image_code": "uint Hash_Wang(uint key) {\n\tkey = (key ^ 61u) ^ (key >> 16u);\n\tkey = key + (key << 3u);\n\tkey = key ^ (key >> 4u);\n\tkey = key * 0x27D4EB2Du;\n\tkey = key ^ (key >> 15u);\n\treturn key;\n}\n\nfloat UniformUintToFloat(uint u) {\n\t// IEEE-754: 2^-32 = 0x2F800000\n\treturn float(u) * uintBitsToFloat(0x2F800000u);\n}\n\nconst float g_quantum_offset = 40.0f;\nconst float g_quantum_delta  = 50.0f;\nconst float g_quantization   = 1.0f / 255.0f;\nconst float g_split_speed    = 0.8f;\n\n//#define DISABLE_DITHERING\n//#define DISABLE_TEMPORAL_DITHERING\n\nvoid mainImage(out vec4 color, in vec2 fragCoord) {\n    // Compute pixel value\n    float value    = g_quantum_offset + fragCoord.x / g_quantum_delta;\n    \n    // Compute pixel noise\n    uint  index = uint(fragCoord.y * iResolution.x + fragCoord.x);\n    \n    #ifdef DISABLE_DITHERING\n    float noise = 0.0f;\n\t#else  // DISABLE_DITHERING\n    \n    #ifdef DISABLE_TEMPORAL_DITHERING\n    uint  key   = index;\n    #else  // DISABLE_TEMPORAL_DITHERING\n    uint  key   = index ^ floatBitsToUint(iTime);\n\t#endif // DISABLE_TEMPORAL_DITHERING\n    \n    uint  state = Hash_Wang(key);\n    float noise = UniformUintToFloat(state);\n    \n    #endif  // DISABLE_DITHERING\n    \n    uint  y        = uint(fragCoord.y);\n    uint  height   = uint(iResolution.y);\n    uint  split    = uint(g_split_speed * float(iFrame)) % ((height << 1u) - 2u);\n    split = (split >= height) ? ((height << 1u) - 2u) - split : split;\n    \n    if (split < y) {\n        // Region above the white seperator: with temporal dithering.\n        color      = vec4(vec3((value + noise) * g_quantization), 1.0f);\n    } \n    else if (split > y){\n        // Region below the white seperator: without temporal dithering.\n        color      = vec4(vec3(value * g_quantization), 1.0f);\n    } \n    else {\n        color      = vec4(1.0f);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt3yDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 181], [183, 183, 217, 250, 301], [529, 529, 580, 607, 1819]], "test": "ok"}
{"id": "lt3yRf", "name": "Tiled gradient", "author": "voidstar69", "description": "A simple tiled gradient", "tags": ["simple", "tiled", "gradient"], "likes": 0, "viewed": 346, "published": "Public API", "date": "1533405976", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy*iTime;\n    uv.xy = vec2(mod(uv.x,1.0),mod(uv.y,1.0));\n\n    // gradient\n    vec3 col = vec3(1,1,1)-uv.xyx*uv.xyy; // % vec3(2,2,2);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt3yRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 339]], "test": "ok"}
{"id": "lt3yRX", "name": "Flower Patterns", "author": "nr4", "description": "Flower pattern with 2D signed distance functions for stars from https://www.shadertoy.com/view/4ldyRj\nTry changing N ;) \nWorking on proper antialiasing when adding stars with mix(.)", "tags": ["2d", "sdf", "flower", "spline", "growth"], "likes": 16, "viewed": 256, "published": "Public", "date": "1533394432", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n * Flower Pattern\n * \n * Copyright (C) 2018  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nconst float pi = acos(-1.);\nconst vec3 c = vec3(1.,0.,-1.);\n\n// compute distance to regular star\nfloat dstar(vec2 x, float N, vec2 R)\n{\n    float d = pi/N,\n        p0 = acos(x.x/length(x)),\n        p = mod(p0, d),\n        i = mod(round((p-p0)/d),2.);\n    x = length(x)*vec2(cos(p),sin(p));\n    vec2 a = mix(R,R.yx,i),\n    \tp1 = a.x*c.xy,\n        ff = a.y*vec2(cos(d),sin(d))-p1;\n   \tff = ff.yx*c.zx;\n    return dot(x-p1,ff)/length(ff);\n}\n\n#define A iResolution.y\n#define S(v) smoothstep(-1.5/A,1.5/A,v)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float N = 5., d = 2.*pi/N*sin(.1*iTime);\n    vec2 uv = fragCoord/A-vec2(.5*iResolution.x/A,.5), \n        k = vec2(cos(d),sin(d)),\n        t = c.zx, e;\n    mat2 R = mat2(k.x,k.y,-k.y,k.x);\n    \n    for(float i = 2.; i > .05; i = i*(.85+.1*sin(.3*iTime)))\n    {\n        uv = R*uv;\n        e = vec2(dstar(uv, N, i*vec2(1.+.5*cos(3.4221*iTime),1.+.5*sin(2.153*iTime))),i);\n        t = mix(t,e,step(-3./A,e.x));\n    }\n    e = vec2(.025-length(uv),pi); \n    \n    //set random colors\n    vec3 col = .8 + .5*cos(1.+uv.xyx+t.y*1.5e1+iTime+vec3(0.,2.,4.));\n    fragColor = vec4(col*mix(S(t.x),1.,.5)+S(-abs(t.x))+col.zxy*S(e.x)+S(-abs(e.x)),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt3yRX.jpg", "access": "shaders20k", "license": "gpl-3.0-plus", "functions": [[797, 833, 871, 871, 1173], [1239, 1239, 1296, 1296, 1938]], "test": "error"}
{"id": "lt3yz2", "name": "Checker Rows", "author": "momoro", "description": "Rows of randomness", "tags": ["bookfofshaders"], "likes": 1, "viewed": 346, "published": "Public API", "date": "1533185348", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 st = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n\n\n    /*\n\tfloat f = 0.;\n    st.x *= 20.;\n    st.x = step(fract(st.x), 0.5);\n    st.x += step(fract(st.y), 0.5);\n    f = mod(st.x, 2.) == 0. ? 0. : 1.;\n    */\n    \n\tst.y *= 20.;\n    st.x *= 100.;\n    \n    float t = iTime * (ceil(st.y) -.5) * random(ceil(st)) * 10.;\n    st.x += t;\n    \n    vec2 a = floor(st);\n    \n    float f = random(a);\n    \n    f = step(.3, f);\n    \n    \n    vec3 color = vec3(f);\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt3yz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 29, 29, 137], [140, 140, 196, 196, 700]], "test": "ok"}
{"id": "ltBfzd", "name": "Perlin fBm", "author": "wsmind", "description": "Standard Perlin noise 2D implementation", "tags": ["noise", "fbm", "perlin"], "likes": 3, "viewed": 588, "published": "Public API", "date": "1534942221", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rand2(vec2 uv)\n{\n    uv += 0.5;\n    uv /= 256.0; // texel size\n\treturn vec2(texture(iChannel0, uv).r, texture(iChannel0, uv + 17.0 / 256.0).r) * 2.0 - 1.0;\n}\n\nfloat smix(float a, float b, float t)\n{\n    return mix(a, b, smoothstep(0.0, 1.0, t));\n}\n\nfloat computeCorner(vec2 corner, vec2 uv)\n{\n    vec2 gradient = normalize(rand2(corner));\n    return dot(gradient, uv - corner);\n}\n\nfloat perlin(vec2 uv)\n{\n\tfloat c00 = computeCorner(floor(uv) + vec2(0.0, 0.0), uv);\n\tfloat c01 = computeCorner(floor(uv) + vec2(0.0, 1.0), uv);\n\tfloat c11 = computeCorner(floor(uv) + vec2(1.0, 1.0), uv);\n\tfloat c10 = computeCorner(floor(uv) + vec2(1.0, 0.0), uv);\n    \n    vec2 diff = uv - floor(uv);\n    \n    return smix(smix(c00, c10, diff.x), smix(c01, c11, diff.x), diff.y);\n}\n\nfloat fbm(vec2 uv)\n{\n    float value = 0.0;\n    float factor = 1.0;\n    for (int i = 0; i < 8; i++)\n    {\n        uv += iTime * 0.04;\n        value += perlin(uv * factor) / factor;\n        factor *= 2.0;\n    }\n    return value;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy * 5.0 / iResolution.y;\n\tfragColor = vec4(vec3(fbm(uv) * 0.5 + 0.5) ,1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltBfzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 162], [164, 164, 203, 203, 252], [254, 254, 297, 297, 384], [386, 386, 409, 409, 766], [768, 768, 788, 788, 997], [999, 999, 1056, 1056, 1156]], "test": "error"}
{"id": "ltcczj", "name": "Red Ripples", "author": "pixlpa", "description": "Some flowy stuff", "tags": ["noise", "texture", "lighting"], "likes": 8, "viewed": 219, "published": "Public", "date": "1533169355", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// Value Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/lsf3WH\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = smoothstep(0.,1.,f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat bumpFunc(vec2 st){\n    vec2 aspect = vec2(iResolution.x/iResolution.y,1.);    \n    float center = length((st-(iMouse.xy/iResolution.xy*2.-vec2(1.)))*aspect);\n    float noisevalue = noise((st+vec2(0.,iTime*0.5))*5.*aspect);\n    noisevalue += noise((st+vec2(0.,iTime*0.25))*20.*aspect)*0.1;\n    return pow(smoothstep(1.3,0.,center)*0.5+noisevalue*0.8,3.);\n}\n\n//LIGHTING and BUMP section adapted from https://www.shadertoy.com/view/4l2XWK\n\nvec3 bumpMap(vec3 st){\n    vec2 ts = st.xy+(0.,iTime*0.2);\n    vec3 noisedist = vec3(noise(ts.xy*3.6),noise((ts.xy+4.)*3.5),0.)*0.1;\n    noisedist += vec3(noise((ts.xy+0.39)*8.),noise((ts.xy+4.2)*8.),0.)*0.05;\n    vec3 sp = st+noisedist;\n    vec2 eps = vec2(4./iResolution.y, 0.);\n    float f = bumpFunc(sp.xy); // Sample value multiplied by the amplitude.\n    float fx = bumpFunc(sp.xy-eps.xy); // Same for the nearby sample in the X-direction.\n    float fy = bumpFunc(sp.xy-eps.yx); // Same for the nearby sample in the Y-direction.\n\n\tconst float bumpFactor = 0.2;\n    fx = (fx-f)/eps.x; // Change in X\n    fy = (fy-f)/eps.x; // Change in Y.\n    return vec3(fx,fy,0.)*bumpFactor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n  \n\n    // VECTOR SETUP - surface postion, ray origin, unit direction vector, and light postion.\n    vec3 sp = vec3(uv, 0); // Surface position.\n    vec3 rd = normalize(vec3(uv, 1.)); // Direction vector from the origin to the screen plane.\n    vec3 lp = vec3(iMouse.xy/iResolution.xy*2.-vec2(1.), -0.5); // Light position\n\tvec3 sn = vec3(0., 0., -1); // Plane normal. Z pointing toward the viewer.\n    \n    // Using the gradient vector, \"vec3(fx, fy, 0),\" to perturb the XY plane normal \",vec3(0, 0, -1).\" \n    sn = normalize( sn + bumpMap(sp));           \n   \n    \n    // LIGHTING\n\t// Determine the light direction vector, calculate its distance, then normalize it.\n\tvec3 ld = lp - sp;\n\tfloat lDist = max(length(ld), 0.001);\n\tld /= lDist;  \n    float atten = 1./(1.0 + lDist*lDist*0.15);\n\n\t// Diffuse value.\n\tfloat diff = max(dot(sn, ld), 0.);  \n    // Specular highlighting.\n    float spec = pow(max(dot( reflect(-ld, sn), -rd), 0.), 8.);\n    float grain = noise(uv.xy*110.);\n    fragColor = vec4(vec3(diff*0.7+spec*0.75)*(vec3(1.,0.2,0.2)+vec3(grain*0.1)),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltcczj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 161], [163, 245, 267, 267, 675], [677, 677, 701, 701, 1038], [1120, 1120, 1142, 1142, 1803], [1805, 1805, 1862, 1862, 2987]], "test": "timeout"}
{"id": "ltcyDj", "name": "Crumpled Noise", "author": "TEttinger", "description": "Lots of wrinkly blocky blobs of color, adjusted in YCbCr color space. Useful for making your brain try to form visual patterns from random noise, like for inspiration.", "tags": ["noise", "hash", "ycbcr"], "likes": 2, "viewed": 565, "published": "Public API", "date": "1534055663", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// CC0 license, do what thou wilt\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // single float input, we get a varied value for it from screen position and time\n\n\n    float rate = 20.0; //fps\n    float size = 7.3;\n    float jitter = 6.87; // when larger, distorts squares more\n    float gamma = 1.1; // not sRGB gamma; arbitrary\n    \n    float time = floor(iTime * rate) / 60.0;\n    float dx = jitter * fract(exp(fract(time * 53.678921) + 0.234567));\n    float dy = jitter * fract(exp(fract(time * 31.456789) + 0.345672));\t\n    \n    \n    vec2 xy = floor((fragCoord) / size);\n\tvec3 uv = mod((vec3((xy / iResolution.xy), time) * 11035.15245)\n                  // these are based off a number I had good results with as an increment with\n                  // 64-bit integer CPU hashing, 0x369DEA0F31A53F85, and its powers modulo 64 bits\n                  + vec3(393555.9000370003845, -55865.4634555294951, 782941.5577042901757),\n                  96.9875);\n    uv = mod((vec3((floor(vec2(fragCoord.x + fract(dot(uv.zyx + uv.zxx + uv.yzy, fract(uv * uv)))\n                           * jitter - jitter,\n                               fragCoord.y + fract(dot(uv + uv.yyx + uv.zxz, fract(uv.zxy * uv.zxy)))\n                              * jitter - jitter) / size) / iResolution.xy), time) * 11035.15245)\n             + vec3(393555.9000370003845, -55865.4634555294951, 782941.5577042901757),\n             96.9875);\n    float h = fract(dot(uv + uv.yzx + uv.zxy, fract(uv.zyx * uv.zyx)));\n    float Y = h;\n    float Cr = fract(h * 78294.15577042901757) - .5;\n    float Cb = fract(h * 258.654634555294951) - .5;\n    \n    float R = Y + 1.402 * Cr;\n\tfloat G = Y - 0.344136 * Cb - 0.714136 * Cr;\n\tfloat B = Y + 1.772 * Cb;\n    \n    vec3 RGB = pow(vec3(R,G,B), vec3(gamma));\n    \n    fragColor = vec4(RGB, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltcyDj.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[36, 36, 93, 179, 1817]], "test": "ok"}
{"id": "ltcyRj", "name": "Voronoi smooth", "author": "darkeclipz", "description": "Another Voronoi where the color is based on the distance, and a color map.", "tags": ["voronoi"], "likes": 0, "viewed": 134, "published": "Public", "date": "1533152475", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float seed = 52452.0;\nfloat random() {\n\treturn fract( sin( seed++ * 4871452.47 ) * 87175.89 );\n}\n\n#define N 64\n#define t iTime\n\nvec3 cmap(float x) {\n    \n    vec3 c = vec3(0);\n    \n    c = mix( c, vec3(1, 1, 1), smoothstep(0.0, 0.2, x) );\n    c = mix( c, vec3(1, .5, .0), smoothstep(0.2, 0.4, x) );\n    c = mix( c, vec3(1, .7, 0), smoothstep(0.4, 0.6, x) );\n    c = mix( c, vec3(1., 1., 1.), smoothstep(0.6, 0.8, x) );\n    c = mix( c, vec3(0., 0, 0), smoothstep(0.8, 1.0, x) );\n    \n    return c;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //fragColor = vec4( cmap( fragCoord.x/iResolution.x ), 0);\n    //return;\n    \n    // Rescale.\n    vec2 R = iResolution.xy;\n    vec2 uv = (2.*fragCoord-R)/R.y;\n    vec2 M = (2.*iMouse.xy-R)/R.y;\n    \n    // Colors.\n    vec3 col = vec3(0);\n    \n    // Location of each points (x, y)\n    vec2 points[N];\n    \n    // Distance to the closest point from uv.\n    float minDist = 0.0;\n    \n    // Index of the closest point.\n\tint minN = 0;\n    \n    float maxDist = 0.;\n    \n    for(int i=0; i < N; i++) {\n                \n        // Create a random point.\n        points[i] = 2. * vec2(2.*random()-.5, random()) - 1.;\n        \n        // Override this with two circling points.\n        if(i == N-1) points[i] = .8*vec2(cos(t/4.), sin(t/4.));\n        if(i == N-2) points[i] = .4*vec2(cos(-t/2.), sin(-t/2.));\n        \n        // Distance from uv to the created point.\n        float d = distance(points[i], uv);\n        \n        // if min dist = 0, this is the first point, so we use that.\n        if(minDist == 0.0) minDist = d;\n        \n        // Save the closest point.\n        minDist = min(minDist, d);\n        maxDist = max(maxDist, d);\n        \n        // Store the index.\n        if(minDist == d) minN = i;    \n        \n    }\n    \n    float d = 0.0125/minDist;\n     \n    // Get a color for the cell.\n    col = cmap( d );\n\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltcyRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 38, 38, 96], [128, 128, 148, 148, 503], [505, 505, 562, 660, 1925]], "test": "ok"}
{"id": "ltcyWs", "name": "Rainbow Flower by sbenche", "author": "SamyBencherif", "description": "This is my first shader project loosely following a tutorial by \"The Art of Code\" on youtube.", "tags": ["basic", "flower"], "likes": 1, "viewed": 65, "published": "Public", "date": "1534626916", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -.5 to .5)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv -= vec2(.5, .5);\n    \n    // Correct aspect ratio\n    uv.x *= iResolution.x/iResolution.y;\n\n    // Assign colors\n    vec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 white = vec4(1.0, 1.0, 1.0, 1.0);\n\n    // Output background\n    fragColor = black;\n    \n    // Output circle\n    float d = length(uv);\n    float a = atan(uv.y, uv.x) + iTime;\n    float r = .4 + .1*sin(10.*(a - 3.14));\n    float c = smoothstep(r,r-.01,d);\n    \n    // Time varying pixel color\n    vec3 colBack = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    \n    fragColor = vec4(.3*colBack + c*col, 1);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltcyWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 110, 789]], "test": "ok"}
{"id": "ltdcWX", "name": "Voronoi Microbes", "author": "momoro", "description": "Playing around with edge detection. Not sure how to get rid of the crosses.", "tags": ["voronoi"], "likes": 13, "viewed": 650, "published": "Public API", "date": "1534483081", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// Commutative smooth minimum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk:\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n//\tvec2 fragCoord = gl_FragCoord.xy;\n//    vec2 iResolution = u_resolution;\n   // float iTime = u_time;\n  //  vec4 fragColor;\n    \n    vec3 color;\n\n    vec2 st = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    \n\tst *=10.;\n    \n    // Tile\n    vec2 i_st = floor(st);\n    vec2 f_st = fract(st);\n    \n    float m_dist = 1.; // min distance\n    \n    for(int j=-5; j<=5; j++) {\n        for(int i=-5; i<=5; i++) {\n\n            // Neighbor place in the grid\n            vec2 neighbor = vec2(float(i), float(j));\n            \n            // Random position from current + neighbor place in the grid\n            vec2 offset = random2(i_st + neighbor);\n            \n            // Animate the offset\n            offset = 0.5 + 0.5 * sin(iTime + 6.2831 * offset );\n            \n            // Position of the cell\n            vec2 pos = neighbor + offset - f_st;\n            \n            // Cell distance\n            float dist = length(pos);\n            \n            // Metaball\n            m_dist = smin(m_dist, dist, 1.688);            \n        }\n    }\n    \n\tfloat f = m_dist *8.296;\n    //f = ceil(f *3.) / 3.;\n    f = sin(m_dist * 40.)/2. + .5;\n   // f = smoothstep(0., fwidth(f) * 200.708, f - 0.108);\n   // f = smoothstep(0., fwidth(f + 10000.196) * 100.5, f + -01.4036);\n    color = 1.0 - vec3(f);\n    color *= \tfwidth(f) * 3.640;\n    color *= 1.5;\n\n\t//color = sqrt(max(color, 0.00));\n\n    \n    \n    fragColor = vec4(color, 1.0);\n   // gl_FragColor = fragColor;\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltdcWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 117], [119, 229, 267, 267, 344], [347, 347, 404, 530, 1877]], "test": "ok"}
{"id": "ltdyDl", "name": "Puffy", "author": "Kali", "description": "Hi shadertoyers! I haven't done much DF modelling in the past, so I thought it was a good idea to try something. I wanted to make it look cartoonish, but it ended near the uncanny valley between a cartoon and something a bit more real xD", "tags": ["puffy"], "likes": 143, "viewed": 6514, "published": "Public", "date": "1534719485", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// GLOBALS\n\n// position & direction\nvec3 pos_finn, pos_eyes;\nvec3 dir_eye;\nmat3 dir_mouth;\nvec3 dir_light;\n\n// coloring and animation\nfloat heye, weye, beye;\nfloat hmouth, cmouth;\nfloat hfinns, htail;\nfloat puff;\nfloat time;\nfloat tim_tail;\nfloat ani_tail, ani_mouth;\n\n// colors\nvec3 col_water = vec3(.3, .7, 1.);\nvec3 col_fish_1 = vec3(1., 0.4, 0.2);\nvec3 col_fish_2 = vec3(1., 0.8, 0.5);\nvec3 col_eyes = vec3(0.7, 0.75, 1.);\nfloat t = 20.;\n\n// marching\nfloat maxdist = 5.;\nfloat det = .001;\n\n\n\n// USEFUL LITTLE FUNCTIONS\n\n// 2D rotation\nmat2 rot2D(float a) {\n  a = radians(a);\n  float s = sin(a);\n  float c = cos(a);\n  return mat2(c, s, -s, c);\n}\n\n// Align vector\nmat3 lookat(vec3 fw, vec3 up) {\n  fw = normalize(fw);\n  vec3 rt = normalize(cross(fw, normalize(up)));\n  return mat3(rt, cross(rt, fw), fw);\n}\n\n\n// Tile fold \nfloat fmod(float p, float c) { return abs(c - mod(p, c * 2.)) / c; }\n\n// Smooth min\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n  return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n// Smooth max\nfloat smax(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5 * (a - b) / k, 0.0, 1.0);\n  return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n// Torus\nfloat sdTorus(vec3 p, vec2 t, vec3 s) {\n  p = p.yxz * s;\n  vec2 q = vec2(length(p.xz) - t.x, p.y);\n  return length(q) - t.y;\n}\n\n\n// PUFFY'S SURFACE DISPLACEMENT FUNCTIONS\n\nfloat thorns(vec3 p) {\n  p.xz*=rot2D(-25.);\n  float s1 = smoothstep(.0, .7, -p.x + p.z + .6);\n  float s2 = smoothstep(.15, .3, length(p.xy)) * smoothstep(.0, .3, length(p.yz));\n  float s3 = smoothstep(.0, .25, abs(p.y));\n  p.x = fmod(atan(p.x, p.y), .31459 / 2.);\n  p.y = fmod(atan(p.y, p.z), .31459 / 2.);\n  p.xz*=rot2D(25.);\n  return min(1., exp((-3. - puff*3.) * length(p.xy))) * s1 * s2 * s3;\n}\n\nfloat spiral(vec3 p, vec3 c) {\n  p.y = abs(p.y);\n  vec3 pos = p;\n  p = lookat(c, vec3(0., 1., 0.)) * p;\n  float a = length(p.xy) * 35.;\n  p.yx *= mat2(sin(a), cos(a), -cos(a), sin(a));\n  float s=pow(abs(p.x), 2.) * smoothstep(0.7, 1., max(0., 1. - length(p.xy)));\n  return s*smoothstep(0.,.05,pos.z+.1);\n}\n\nfloat skin(vec3 pos) {\n  pos *= 2.;\n  vec3 p = pos;\n  float m = 1000.;\n  for (int i = 0; i < 7; i++) {\n    p = abs(p) / dot(p, p) - .5;\n    m = min(m, length(p));\n  }\n  return max(0., 1. - m) * (.1 + smoothstep(-pos.x + 1., 0., .4)) * .003;\n}\n\n// PUFFY'S DE FUNCTIONS\n\n// Body parts\n\nfloat finn(vec3 p) {\n  p.z += .27;\n  p.x += .1;\n  p.x *= 1.-pow(smoothstep(0., .2, -p.z),1.5)*.3;\n  mat2 ro = rot2D(cos(tim_tail*4.+(p.x+p.z)*5.) *(3.-p.x*20.));   \n  p.xy *= ro;\n  p.zy *= ro;\n  float e = atan(p.x, p.z);\n  float o = sin(e * 20.) * .003;\n  float a = .19 - p.z * .15;\n  float d = max(abs(p.y + o) - .005, length(p.xz) - a + cos(o * 500.) * .02);\n  d = max(p.x - p.z*.6, d);\n  d = max(p.z-p.x*.3, d);\n  return d * .75;\n}\n\n\nfloat tail(vec3 p) {\n  p.z += .18;\n  p.x += puff * .1;\n  p.x += .45 + pow(smoothstep(0., .4, abs(p.z)), 5.) * .1;\n  p.xy *= rot2D(cos(tim_tail + p.x * 5. + p.z * 3.) * 25.);\n  float e = atan(p.x, p.z);\n  float o = sin(e * 20.) * .003;\n  float a = .27 - p.z * .15;\n  float d = max(abs(p.y + o) - .003, length(p.xz) - a + cos(o * 500.) * .02);\n  float d1 = smax(p.x - p.z * .2, d, .02);\n  d1 = smax(-p.x * .4 + p.z, d1, .02);\n  float d2 = smax(p.x + p.z * .3, d, .02);\n  d2 = smax(-p.x * .3 - p.z, d2, .02);\n  d = smin(d1, d2, .03);\n  return d * .7;\n}\n\nfloat finns(vec3 p) {\n  float amp = (1. - puff * .3) * .15;\n  float t = time*5. + sign(p.y) * .2;\n  float l = length(p) * 2.;\n  p.y = abs(p.y);\n  p += normalize(pos_finn) * (.28 + puff * .05);\n  p*=1.3;\n  p = lookat(normalize(vec3(-1., -.0, -5.)), vec3(0., 1., 0.)) * p;\n  amp *= (1. + length(p) * 5.);\n  float a = .2 + cos(t + atan(p.y, p.z) * 2.) * amp * .5;\n  float b = 1.2 + puff *1.5 + sin(t - amp) * amp;\n  p.zx *= mat2(sin(a), cos(a), -cos(a), sin(a));\n  p.yx *= mat2(sin(b), cos(b), -cos(b), sin(b));\n  float e = atan(p.y, p.z);\n  float o = sin(e * 20.) * .003;\n  float r = .45 - smoothstep(1., 3., abs(e)) * .25;\n  float d =\n      max(abs(p.x + o) - .005, length(p.yz) - r + cos(p.z * 100.) * .01) * .9;\n  d = max(-p.y - p.z * .5, d);\n  d = max(p.z + p.y * .2, d);\n  d = smin(d, length(p) - .04, .04);\n  return d * .8;\n}\n\nfloat mouth(vec3 p) {\n  p *= dir_mouth;\n  float mo = length(p.yz * vec2(.35 + ani_mouth * .1-p.z*2., 1.)) - .02 * (1. + ani_mouth * .4);\n  return max(-p.x, mo);\n}\n\nfloat body(vec3 p) {\n  float m = smoothstep(0., 1.5, -p.x + 1.3) * .2;\n  float s = smoothstep(0., 1.7, -p.x);\n  p.z -= puff * .1;\n  p.z -= smoothstep(0., p.z*.3 + p.x - .6 + ani_mouth * .1,-.1)*.05;\n  p.y *= 1. + pow(abs(p.z - .2), 2.) * 1.5;\n  p.z *= 1. - (p.x + .1) * .1;\n  p.zy *= 1.+smoothstep(0.,.5,-p.x)*.3;\n  float d = length(p*vec3(1.+smoothstep(0.,.5,-p.x+p.z)*.5,1.,1.4)) - .47 - s-puff*.12;\n  p += vec3(.14 + puff * .0, .0, .2);\n  p.x -= p.z*.5;\n  p.z += puff * .1;\n  d = smin(d, length(p * vec3(0.6, 1.2, 1.7)) - .55 + m, .2) + .1;\n  d+=smoothstep(0.,.7,-p.x)*.05;\n  return (d+.05) * .7;\n}\n\nfloat eye(vec3 p) {\n\tfloat d = length(p) - .13;\n    return d;\n}\n\n// Main DE function\nfloat de(vec3 p) {\n  beye = 0.;\n  heye = 0.;\n  weye = step(0., p.y);\n  hmouth = 0.;\n  hfinns = 0.;\n  htail = 0.;\n  p.y *= 1.15;\n  vec3 rp = p;\n  p.y = abs(p.y);\n  mat2 rotbod=rot2D(smoothstep(0., 1.3, -p.x + .2) * ani_tail * 25.);\n  rp.xy *= rotbod;\n  rp.zy *= rotbod;\n  float t = time * 10.;\n  p += sin(p * 20. + t) * .002;\n  float fi = finn(rp);\n  float fis = finns(rp);\n  float ta = tail(rp);\n  float mo = mouth(p);\n  float sk = skin(rp);\n  float res = (body(rp) - thorns(rp) * (.01 + puff * .1)) * .8 - sk;\n  res += spiral(rp, -pos_eyes + vec3(0.1, 1., -0.3))*.4;\n  rp.y = abs(rp.y);\n  float eyeh = eye(rp + pos_eyes * .9);\n  float eyes = eye(rp + pos_eyes);\n  res = smax(res, -mo, .013);\n  res = smin(res, eyes, .02);\n  res = smin(res, eyeh, .035);\n  res = smin(res, fis, .02);\n  res = smin(res, fi, .02);\n  res = smin(res, ta, .03);\n  beye = abs(res - eyes);\n  heye = 1.-step(.005, beye);\n  hfinns = 1.-step(.005,abs(res-fi));\n  hfinns = max(hfinns,1.-step(.005,abs(res-fis)));\n  htail = 1.-step(.02, abs(res-ta));\n  hmouth = 1.-step(.01, abs(res-mo));\n  return res;\n}\n\n// PUFFY'S COLORING FUNCTIONS\n\nvec3 color_eyes(vec3 p, vec3 n) {\n  vec3 p1 = p + pos_eyes;\n  vec3 p2 = p + vec3(pos_eyes.x, -pos_eyes.y, pos_eyes.z);\n  vec3 l = p1;\n  vec3 c = vec3(1.);\n  p1 = lookat(dir_eye, vec3(0., 1., .5)) * p1;\n  p2 = lookat(dir_eye, vec3(0., 1., -.5)) * p2;\n  p1.y -= .01;\n  p2.y += .01;\n  c -= smoothstep(.07, .085, length(p1.xy) + 1. - weye) * (.4 + col_eyes * 1.5);\n  c -= smoothstep(.07, .085, length(p2.xy) + weye) * (.4 + col_eyes * 1.5);\n  c *= smoothstep(.03 + sin(atan(p1.x, p1.y) * 25.) * .02, .07, length(p1.xy) + 1. - weye);\n  c *= smoothstep(.03 + sin(atan(p2.x, p2.y) * 25.) * .02, .07, length(p2.xy) + weye);\n  return mix(c, -col_fish_1 - .2, smoothstep(.0, .0055, beye));\n}\n\nvec3 color(vec3 p, vec3 n) {\n  float c=.1+max(0.,p.x*3.);\n  float th=pow(max(0.,.2-abs(thorns(p)))/.2,3.);\n  vec3 col = mix(col_fish_1, col_fish_2, c);\n  col=mix(col_fish_1, col, .3+th*.7);\n  if (heye > 0.)\n    col = color_eyes(p, n);\n  if (hmouth > 0.)\n    col = col_fish_2 - .03;\n  if (hfinns > 0.)\n    col = mix(col_fish_1, col_fish_2 + .15,\n              smoothstep(.37, .5, length(p+vec3(0.,0.,.05)) - puff * .05));\n  if (htail > 0.)\n    col = mix(col_fish_1, col_fish_2 + .2,\n              smoothstep(.6, .75, length(p) - puff * .1));\n  return abs(col);\n}\n\n// BACKGROUND AND FOREGROUND FRACTAL\n\nfloat fractal(vec3 p) {\n  p += cos(p.z * 3. + time * 4.) * .02;\n  float depth = smoothstep(0., 6., -p.z + 5.);\n  p *= .3;\n  p = abs(2. - mod(p + vec3(0.4, 0.7, time * .07), 4.));\n  float ls = 0.;\n  float c = 0.;\n  for (int i = 0; i < 6; i++) {\n    p = abs(p) / min(dot(p, p), 1.) - .9;\n    float l = length(p);\n    c += abs(l - ls);\n    ls = l;\n  }\n  return .15 + smoothstep(0., 50., c) * depth * 4.;\n}\n\n// NORMALS AND LIGHTING\n\nvec3 normal(vec3 p) {\n  vec3 e = vec3(0.0, det * 2., 0.0);\n\n  return normalize(vec3(de(p + e.yxx) - de(p - e.yxx),\n                        de(p + e.xyx) - de(p - e.xyx),\n                        de(p + e.xxy) - de(p - e.xxy)));\n}\n\nfloat shadow(vec3 pos) {\n  float sh = 1.0;\n  float totdist = det * 30.;\n  float d = 10.;\n  for (int i = 0; i < 8; i++) {\n    if (d > det) {\n      vec3 p = pos - totdist * dir_light;\n      d = de(p);\n      sh = min(sh, 20. * d / totdist);\n      totdist += d;\n    }\n  }\n  return clamp(sh, 0.0, 1.0);\n}\n\nfloat light(vec3 p, vec3 dir, vec3 n, float shw) {\n  float dif = pow(max(0., dot(dir_light, -n)), 3.);\n  float amb = pow(max(0., dot(dir, -n)), 3.);\n  return dif * .7 * shw + amb * .2 + .15;\n}\n\n// RAY MARCHING AND SHADING\n\nvec3 march(vec3 from, vec3 dir) {\n  vec3 odir = dir;\n  vec3 p = from + dir * 2.;\n  float fg = fractal(p + dir) * .55;\n  vec3 col = vec3(0.);\n  float totdist = 0.;\n  float d;\n  float v = 0.;\n  cmouth = 1.;\n  for (int i = 0; i < 80; i++) {\n    p = from + totdist * dir;\n    d = de(p);\n    if (d < det || totdist > maxdist)\n      break;\n    totdist += d;\n    v += max(0., .1 - d) / .1;\n  }\n  float fade = smoothstep(maxdist * .2, maxdist * .9, maxdist - totdist);\n  float ref = 1.;\n  float eyes_ref = heye;\n  float shw = 1.;\n  if (d < det * 2.) {\n    p -= (det - d) * dir;\n    vec3 n = normal(p);\n    col = color(p, n) * (.1 + .9 * cmouth);\n    shw = shadow(p);\n    col *= light(p, dir, n, shw);\n    from = p - det * dir * 3.;\n    dir = reflect(dir, n);\n    ref = fade * (.3 * cmouth + eyes_ref * .2);\n    col = mix(col_water * .15, col, fade);\n  }\n  col *= normalize(col_water + 1.5) * 1.7;\n  p = maxdist * dir;\n  vec3 bk = fractal(p) * ref * col_water;\n  float glow = pow(max(0., dot(dir, -dir_light)), 1.5+eyes_ref*1.5);\n  vec3 glow_water = normalize(col_water+1.);\n  bk += glow_water*(glow*(1.-eyes_ref*.7) + pow(glow, 8.) * 1.5) * shw * cmouth * ref;\n  col += v * .06 * glow * ref * glow_water;\n  col += bk + fg * col_water;\n  return col;\n}\n\n// MAIN\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n  // Set globals\n  time = mod(iTime, 600.);\n  ani_mouth = sin(time * 6.);\n  puff = -.03+.5*smoothstep(.945, .95, abs(sin(time * .1)))+ani_mouth*.04;\n  pos_finn = normalize(vec3(0.35, -1, 0.));\n  pos_eyes = vec3(-1., -1.1, 1.) * .12;\n  //pos_eyes*=1.+vec3(-1.,1.,0.)*puff*.05;\n  dir_light = normalize(vec3(-.3, 0.2, 1.));\n  dir_mouth = lookat(normalize(vec3(-.4-puff*.1+ani_mouth*.03, 0., -1.)), vec3(0., 1., 0.));\n  tim_tail = time * 2.;\n  ani_tail = cos(tim_tail);\n\n  // Pixel coordinates\n  vec2 uv = fragCoord / iResolution.xy - .5;\n  vec2 uv2 = uv;\n  float ar = iResolution.x / iResolution.y; \n  uv.x *= ar;\n\n  // Camera\n  vec2 mouse = (iMouse.xy / iResolution.xy - .5) * 4.;\n  float tcam = (time+67.)*.05;\n  float zcam = smoothstep(.7, 1., cos(tcam)) * 1.8 - .3;\n  zcam -= smoothstep(.7, 1., -cos(tcam)) * 1.6;\n  if (iMouse.z < .1) mouse = vec2(sin(time * .15)*ar, zcam);\n  vec3 dir = normalize(vec3(uv, .9));\n  vec3 from = vec3(1., 0., -0.5 + mouse.y) * 1.25;\n  from.xy *= rot2D(-mouse.x * 40.);\n  dir = lookat(normalize(-from+vec3(sin(time*.5)*.3,cos(time*.25)*.1,0.)), vec3(0., 0., -1.)) * dir;\n\n  // Eyes direction\n  dir_eye = normalize(from);\n  //dir_eye.x = max(dir_eye.x, pos_eyes.x - .5);\n  dir_eye.y = min(abs(dir_eye.y), pos_eyes.y*sign(dir_eye.y)+.5*sign(dir_eye.y));\n  dir_eye.z = min(dir_eye.z, pos_eyes.z - .5);\n\n  // March and color\n  vec3 col = march(from, dir);\n  col *= vec3(1.1, .9, .8);\n  col += dot(uv2, uv2) * vec3(0., 0.6, 1.) * .8;\n\n  // Output to screen\n  fragColor = vec4(col, 1.);\n}\n", "image_inputs": [{"id": "4dBXW3", "previewfilepath": "https://soundcloud.com/digitalluc/underwater", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/digitalluc/underwater", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltdyDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[525, 540, 561, 561, 649], [651, 667, 698, 698, 809], [812, 826, 856, 856, 894], [896, 910, 949, 949, 1048], [1050, 1064, 1103, 1103, 1202], [1204, 1213, 1252, 1252, 1339], [1385, 1385, 1407, 1407, 1783], [1785, 1785, 1815, 1815, 2090], [2092, 2092, 2114, 2114, 2334], [2376, 2376, 2396, 2396, 2810], [2813, 2813, 2833, 2833, 3362], [3364, 3364, 3385, 3385, 4193], [4195, 4195, 4216, 4216, 4357], [4359, 4359, 4379, 4379, 4960], [4962, 4962, 4981, 4981, 5025], [5027, 5047, 5065, 5065, 6121], [6154, 6154, 6187, 6187, 6835], [6837, 6837, 6865, 6865, 7398], [7438, 7438, 7461, 7461, 7840], [7867, 7867, 7888, 7888, 8095], [8097, 8097, 8121, 8121, 8396], [8398, 8398, 8448, 8448, 8590], [8621, 8621, 8654, 8654, 9863], [9874, 9874, 9929, 9951, 11448]], "test": "timeout"}
{"id": "ltGcRR", "name": "color circle", "author": "battlebottle", "description": "Drag mouse from left to right to adjust brightness.", "tags": ["color"], "likes": 2, "viewed": 415, "published": "Public API", "date": "1534806258", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst float SRGB_GAMMA = 1.0 / 2.2;\nconst float SRGB_INVERSE_GAMMA = 2.2;\nconst float SRGB_ALPHA = 0.055;\nfloat slope(vec2 a, vec2 b) {\n    return (a.x - b.x) / (a.y - b.y);\n}\n\n\n int FindLineCircleIntersections(float cx, float cy, float radius,\n        vec2 point1, vec2 point2, out vec2 intersection1, out vec2 intersection2)\n{\n    float dx, dy, A, B, C, det, t;\n\n    dx = point2.x - point1.x;\n    dy = point2.y - point1.y;\n\n    A = dx * dx + dy * dy;\n    B = 2.0 * (dx * (point1.x - cx) + dy * (point1.y - cy));\n    C = (point1.y - cx) * (point1.x - cx) + (point1.y - cy) * (point1.y - cy) - radius * radius;\n\n    det = B * B - 4.0 * A * C;\n    if ((A <= 0.0000001) || (det < 0.0))\n    {\n        // No real solutions.\n        return 0;\n    }\n    else if (det == 0.0)\n    {\n        return 1;\n    }\n    else\n    {\n        // Two solutions.\n        t = ((-B + sqrt(det)) / (2.0 * A));\n        intersection1 = vec2(point1.x + t * dx, point1.y + t * dy);\n        t = ((-B - sqrt(det)) / (2.0 * A));\n        intersection2 = vec2(point1.x + t * dx, point1.y + t * dy);\n        return 2;\n    }\n}\n\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat sRGB(float x) {\n    if(x <= 0.0031308)\n        return 12.92 * x;\n    else\n        return (1.0 + SRGB_ALPHA) * pow(x, 1.0/2.4) - SRGB_ALPHA;\n}\nvec3 sRGB_v3(vec3 c) {\n    return vec3(sRGB(c.x),sRGB(c.y),sRGB(c.z));\n}\n\nconst int circlSSLevel = 3;\n\nfloat circleMask(vec2 fragCoord, vec2 centre, float rad) {\n    float circleAA = pow(2.0, float(circlSSLevel));\n    float circleSSMask = 0.0;\n    for(float x = 0.0; x < circleAA; x++) {\n        for(float y = 0.0; y < circleAA; y++) {\n            circleSSMask += distance(fragCoord - vec2(1.0 / circleAA) + vec2((1.0 / circleAA) * x,(1.0 / circleAA) * y), centre) < (rad) ? 1.0 : 0.0;\n        }\n        \n    }\n    return max(0.0, circleSSMask / (circleAA * circleAA));\n}\nvec3 ACESFilm( vec3 x )\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp(vec3(0.0), vec3(1.0), (x*(a*x+b))/(x*(c*x+d)+e));\n}\n\nvec3 colorWheel(vec2 fragCoord) {\n \n    vec2 centre = iResolution.xy / 2.0;\n    float radius = iResolution.y * 0.45;\n    \n    vec2 centreOffset = vec2(0,radius);\n    centreOffset = centreOffset;\n    \n    float cols[3];\n    \n    for(int i = 0; i < 3; i++) {\n    \tmat2 rot = rotate2d(3.14 * 0.666  * float(i));\n        vec2 start = centre + centreOffset;\n        vec2 point1, point2;\n        \n        vec2 fragNew = ((fragCoord - centre) * rot) + centre;\n        \n        FindLineCircleIntersections(centre.x, centre.y, radius,\n            start, fragNew, point1, point2);\n        \n        \n        float distFull = distance(start, point1);\n        float distSmall = distance(start, fragNew);\n        float temp = (distFull - distSmall)/distFull;\n        cols[i] = smoothstep(0.0, 1.0, temp);\n    }   \n    return ACESFilm(vec3(cols[0], cols[1], cols[2]));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 centre = iResolution.xy / 2.0;\n    float radius = iResolution.y * 0.45;\n    \n    float mousex = 1.0;\n    if (iMouse.z > 0.0) {\n        mousex = max(0.0, (iMouse.x / iResolution.x) * 2.4 - 0.1);\n    } else {\n        mousex = (sin((mod(iTime , 3.14 * 2.0))) + 1.0) * 1.2;\n    }\n    \n    //\n    \n    \n    vec3 noise = texture(iChannel0, uv * (iResolution.xy / vec2(256.0))).rgb / 128.0 - (1.0/256.0);\n    \n    \n    float pickRadius = iResolution.y * 0.06;\n    \n    float circleSSMask = circleMask(fragCoord, centre, radius -1.0);\n    float pickColorMask = circleMask(fragCoord, centre - vec2(radius - pickRadius, -radius + pickRadius), pickRadius);\n    vec3 pickColor = vec3(0.0);\n    if ( pickColorMask > 0.0 ) {\n        pickColor += colorWheel(iMouse.xy) * mousex * pickColorMask * (distance(iMouse.xy, centre) < radius ? 1.0 : 0.0);\n    }\n    \n    \n    vec3 rgb2 = colorWheel(fragCoord);\n    rgb2 = (rgb2 * (mousex)) * circleSSMask;\n    rgb2 += pickColor;\n    rgb2 += noise;\n    vec3 outSRGB = sRGB_v3(rgb2);\n    \n    fragColor = vec4(outSRGB,1.0);\n    \n    \n    \n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltGcRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 107, 136, 136, 176], [180, 180, 329, 329, 1090], [1093, 1093, 1121, 1121, 1207], [1209, 1209, 1231, 1231, 1562], [1564, 1564, 1586, 1586, 1755], [1757, 1757, 1778, 1778, 1904], [1905, 1905, 1927, 1927, 1977], [2008, 2008, 2066, 2066, 2476], [2477, 2477, 2502, 2502, 2676], [2678, 2678, 2711, 2711, 3533], [3535, 3535, 3592, 3642, 4762]], "test": "error"}
{"id": "ltGcRz", "name": "Organism", "author": "momoro", "description": "Random", "tags": ["trig"], "likes": 3, "viewed": 383, "published": "Public API", "date": "1534832964", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rotate2d(float _angle) {\n    return mat2(cos(_angle), -sin(_angle),\n                sin(_angle), cos(_angle));\n}\n\nvec4 blend(vec4 bg, vec4 fg) {\n    vec4 c = vec4(0.);\n    c.a = 1.0 - (1.0 - fg.a) * (1.0 - bg.a);\n    if(c.a < .00000) return c;\n    \n    c.r = fg.r * fg.a / c.a + bg.r * bg.a * (1.0 - fg.a) / c.a;\n    c.g = fg.g * fg.a / c.a + bg.g * bg.a * (1.0 - fg.a) / c.a;\n    c.b = fg.b * fg.a / c.a + bg.b * bg.a * (1.0 - fg.a) / c.a;\n    \n    return c;\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n     vec2 st = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\tvec2 ost = st;\n    \n    \n    st += vec2(-0.110,-0.050);\n    st *= 1.028;\n\n    st *= length(st * 1.168);\n  //  st.x *= atan(st.x, st.y) * -0.264 + cos(st.x * 10.);\n    st += sin(iTime/5.) * .3;\n\n\tvec4 color = vec4(1.);\n\n    float f = distance(vec2(0.), st.xy);\n    float d = f;\n    \n    \n    \n    //    st.y -= cos(ost.y + iTime)/2.;\n    \n       st.x *= tan(length(ost)) + -1.552 * cos(ost.x*5.);\n\n        st = rotate2d(3. *sin(iTime/20.) * length(ost)) * ost;\n    \n    ost = ost / 1.3;\n    st.x *= tan(length(st)) + -1.552 * cos(st.x*5.);\n    \n    st.y -= tan(length(ost));\n\n   st.y -= cos(ost.y + iTime)/2.+.5 * clamp(tan((80. * sin(iTime) + 3000.)/(1.*sin(iTime)+170.) * ost.y) / 15., -5., 0.644); // thanks davidar\n//   st.y /= tan(iTime/4. );\n\n    st *= f;\n    \n    for(float i=0.; i<60.; i++) {\n        vec2 uv = st;\n        uv *= i/7.768 + 1.;\n  \n        uv += vec2(0.020,-0.020) * i;\n\t\t\n        float f = length(uv);\n        f = 1.0 - smoothstep(0.0, fwidth(f *1000.5), f - -.003);\n        \n        float m = mod(i, 2.);\n       \n        vec4 c;\n        \n        if(m == 0.) {\n    \t\tvec3 orange = vec3(0.945,0.502,0.281);\n            float a = 1.280;\n\t    \tc = vec4(orange, a * f);\n\n        } else if(m == 1.) {\n            vec3 green = vec3(0.351,0.865,0.205);\n            float a = 1.184;;\n\t    \tc = vec4(green, a * f);\n        } \n        \n        color = blend(color, c);\n    }\n    \n     for(float i=0.; i<5.; i++) {\n        vec2 uv = st;\n        uv *= i/7.768 + 1.;\n        uv *= 1.108;\n  \n         uv += vec2(-0.010,0.060);\n        uv += vec2(0.020,0.030) * i;\n\t\t\n        float f = length(uv);\n        f = 1.0 - smoothstep(0.0, fwidth(f * 5.5), f - 0.124);\n        \n        float m = mod(i, 2.);\n       \n        vec4 c;\n        \n    \tvec3 blue = vec3(0.910,0.310,0.533);\n        float a = i / 6. * 0.924;\n\t    c = vec4(blue, a * f);\n        \n        color = blend(color, c);\n    }\n    \n\n    color.rgb *= vec3(1.790,1.645,0.433);\n\n\tcolor.rgb = rgb2hsv(color.rgb);\n    color.y = .8 * f;\n    color.y = clamp(color.y, 0., 1.);\n    color.y *= 2.4;\n    color.x += 0.708 + ost.y/8.;\n    color.rgb = hsv2rgb(color.rgb);\n\n\n    \n    fragColor = color;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltGcRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 117], [119, 119, 149, 149, 466], [468, 468, 490, 490, 821], [823, 823, 845, 845, 1014], [1016, 1016, 1073, 1073, 3295]], "test": "ok"}
{"id": "ltGyRz", "name": "Rainbow (WIP)", "author": "momoro", "description": "Getting closer to what I want. Runs too slowly. Need to figure out a way to compute the layering with a for loop I guess.", "tags": ["voronoi"], "likes": 22, "viewed": 910, "published": "Public API", "date": "1534818226", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rotate(float angle) {\n    return mat2(cos(angle), -sin(angle),\n                sin(angle), cos(angle)\n    );\n}\n\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                    vec2(12.9898, 78.233)))*\n        \t\t\t\t 43758.5453123);\n}\n\nfloat random1 (float f) {\n    return random(vec2(f, -0.128));\n}\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// Commutative smooth minimum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk:\nfloat smin(float a, float b, float k){\n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\nfloat noise(float s) {\t\n    float i = floor(s);\n    float f = fract(s);\n    float n = mix(random(vec2(i, 0.)), \n                  random(vec2(i+1., 0.)), \n                  smoothstep(0.0, 1., f)); \n   \n    return n;\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat map(float value, float inMin, float inMax, float outMin, float outMax) {\n\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n\n} \n\n\n\nvec2 map(vec2 value, vec2 inMin, vec2 inMax, vec2 outMin, vec2 outMax) {\n\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n\n}\n\n\n\nvec3 map(vec3 value, vec3 inMin, vec3 inMax, vec3 outMin, vec3 outMax) {\n\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n\n}\n\n\n\nvec4 map(vec4 value, vec4 inMin, vec4 inMax, vec4 outMin, vec4 outMax) {\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n}\n\nfloat sin01(float n) {\n    return sin(n)/2.+.5;\n}\n\n\nvec4 blend(vec4 bg, vec4 fg) {\n    vec4 c = vec4(0.);\n    c.a = 1.0 - (1.0 - fg.a) * (1.0 - bg.a);\n    if(c.a < .00000) return c;\n    \n    c.r = fg.r * fg.a / c.a + bg.r * bg.a * (1.0 - fg.a) / c.a;\n    c.g = fg.g * fg.a / c.a + bg.g * bg.a * (1.0 - fg.a) / c.a;\n    c.b = fg.b * fg.a / c.a + bg.b * bg.a * (1.0 - fg.a) / c.a;\n    \n    return c;\n}\n\n// Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return dot(m, g);\n}\n\n\nfloat fbm(vec2 x, float amplitude, float frequency, float offset) {\n    x += offset;\n    float y = 0.;\n    // Properties\n    const int octaves = 8;\n    float lacunarity = 0.;\n    float gain = 0.;\n    \n    // Initial values\n    //sin(u_time) * 5. + 10.;\n    //sin(u_time/10. + 10.);\n    \n    // Loop of octaves\n    for (int i = 0; i < octaves; i++) {\n        y += amplitude * snoise(frequency*x);\n        frequency *= lacunarity;\n        amplitude *= gain;\n    }\n    \n    return y;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 color = vec4(0., 0., 0., 1.);\n\n\n    for(float k=0.; k<2.; k++) {\n        vec2 st = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n        vec2 uv = st;\n        \n        st *=2.788;\n        st *= rotate(k/10.936);\n\n        // Tile\n        vec2 i_st = floor(st);\n        vec2 f_st = fract(st);\n\n        float m_dist = 1.; // min distance\n\n        for(int j=-3; j<=3; j++) {\n            for(int i=-3; i<=3; i++) {\n                vec2 neighbor = vec2(float(i), float(j));\n                vec2 offset = random2(i_st + neighbor);\n\n                offset = 0.5 + 0.5 * sin(iTime/1.5 + 6.2831 * offset );\n              //  offset = (iMouse - .5 * iResolution.xy) / iResolution.y * 2. * offset;\n               // offset += sin(iTime/2. + 6.2831 * offset);\n\n                vec2 pos = neighbor + offset - f_st;\n                float dist = length(pos);\n\n                // Metaball\n                float diff = k/2. + 0.084;\n                diff = k/9.120;\n                m_dist = smin(m_dist, dist, 1.640 + diff);            \n            }\n        }\n\n\n        float f = m_dist;\n        f *= 5.;\n        #define steps 4.\n        f = ceil(f *steps) / steps;\n        f = map(f, -3., 0., 1., 0.000);\n\n                \n        float incr = (1./(steps*3.));\n\n        // Map colors to height\n       for(float q = 0.; q<steps*3.; q++) {\n\n\t\t\t// Get the current height\n            float fc = smoothstep(q * incr, q*incr+-0.062, f);\n          \tfc = step(q * incr, f);\n            \n\t\t\t// Base color\n            float h =  map(q*incr, 0., 1., 0.160, 0.844);\n\t\t\th +=  + fc + k/3.392;\n           float co = sin01(iTime);\n           co = map(co, 0., 1., .5, .2);\n           h += uv.x * uv.y + co;\n           \n            // Blend it\n            vec4 c = vec4(h, 0.864, 1., 0.0);\n       \t\tc = vec4(hsv2rgb(c.xyz), 0.444);\n            color = blend(color, c * fc);\n        }\n        \n\n    }\n    \n    float p = 0.;\n    vec2 st = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\n    p = fbm(st, 100., .7, iTime/10.);\n    p = map(p, 0., 0.432, 0.664, 1.040);\n   // color = vec4(color.xyz * p, 1.);\n\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltGyRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 115], [118, 118, 146, 146, 255], [257, 257, 282, 282, 320], [322, 322, 346, 346, 439], [441, 551, 589, 589, 665], [667, 667, 689, 689, 885], [887, 887, 909, 909, 1240], [1242, 1242, 1264, 1264, 1433], [1435, 1435, 1513, 1513, 1590], [1595, 1595, 1667, 1667, 1744], [1748, 1748, 1820, 1820, 1897], [1901, 1901, 1973, 1973, 2048], [2050, 2050, 2072, 2072, 2099], [2102, 2102, 2132, 2132, 2449], [2451, 2476, 2497, 2497, 2544], [2545, 2545, 2566, 2566, 2613], [2614, 2614, 2636, 2636, 2671], [2673, 2994, 3016, 3069, 4758], [4761, 4761, 4828, 4828, 5243], [5248, 5248, 5305, 5305, 7417]], "test": "ok"}
{"id": "ltjBDR", "name": "3ary balls 2", "author": "VJSpackOMat", "description": "another experiment\n\nmouse click setz the intervals for two balls, the right is always moving with speed 1\n\n lhoriz/verti axis control speeds for other 2", "tags": ["3ary"], "likes": 0, "viewed": 47, "published": "Public", "date": "1534194116", "time_retrieved": "2021-10-01T00:00:00", "image_code": " \n// rings\nfloat circ(vec2 p,float radius){\n\treturn length(p )-radius>0.?0.:1.  ;\n}\n\n\n\n// pattern that repeats after just few rounds\n//  vec3 speeds=vec3(2.,2.,2.);\n\n// longer prime number pattern, repeats after some more frames ....  31*53*67=110081 frames\n// vec3 speeds=vec3(1.31,1.53,1.67);\n\n\n// very long prime number pattern, repeats after some more frames ....  33637*68023*94321=some more frames\nvec3 speeds=vec3(1\t, 1\t,1\t);\nfloat speed=2.;\nfloat moveradius=0.35;\nfloat radius=0.1;\nfloat thickness=.07;  \n\n\nvec3 color1=vec3(1.,0.,0.);\nvec3 color2=vec3(0.,1.,1.);\nvec3 color3=vec3(.5,1.,0.);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv-=0.5; \n    uv.x*=iResolution.x/iResolution.y;\n    vec2 speedsinteractive=(iMouse.xy/iResolution.xy)*2.0+1.;\n    vec2 p1=vec2(sin(iTime*speeds.x*speed),cos(iTime*speeds.x*speed))*(moveradius)-vec2(moveradius+radius/2.,0.);\n    vec2 p2=vec2(sin(iTime*speeds.y*speed*speedsinteractive.x),cos(iTime*speeds.y*speed*speedsinteractive.x))*(moveradius);\n    vec2 p3=vec2(sin(iTime*speeds.z*speed*speedsinteractive.y),cos(iTime*speeds.z*speed*speedsinteractive.y))*(moveradius)+vec2(moveradius+radius/2.,0.);\n    \n\tvec3 col = vec3( circ(uv+p1,radius/2.))*color1;\n\tcol +=circ(uv+p2,radius/2.)*color2;\n\t col += circ(uv+p3,radius/2.)*color3;\n    fragColor=vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltjBDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 11, 43, 43, 83], [600, 600, 657, 657, 1366]], "test": "ok"}
{"id": "ltKyRD", "name": "Correct refraction???", "author": "efairbanks", "description": "Trying to raymarch *just* refraction with raymarching SDFs. It's unclear to me if I've done this correctly. It looks roughly correct, but it seems to me that you'd want to counteract the refraction on exit. Does this happen implicitly?", "tags": ["raymarch", "refract"], "likes": 1, "viewed": 121, "published": "Public", "date": "1535427737", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 c2p(in vec2 p){return vec2(atan(p.y,p.x),length(p));}\nvec2 p2c(in vec2 p){return vec2(cos(p.x),sin(p.x))*p.y;}\nvec2 _min(vec2 a, vec2 b) {return a.x<b.x?a:b;}\nvec3 look(vec2 xy, vec3 origin, vec3 target)\n{\n    vec3 up=normalize(vec3(0.,1.,0.));\n    vec3 fwd=normalize(target-origin);\n    vec3 right=normalize(cross(fwd,up));\n    up=normalize(cross(fwd,right));\n    return normalize(fwd+right*xy.x+up*xy.y);\n}\n#define LUM 1.\n#define MAX_DISTANCE 15.\n#define MAX_STEPS 200\n#define EPSILON .00001\n#define STEP_COEF 1.\n#define M_PI 3.1415926535897932384626433832795\nfloat cube(vec3 p, vec3 s)\n{\n\tp=abs(p)-s;\n    return max(p.x,max(p.z,p.y));\n}\nvec2 map(vec3 p)\n{\n    vec3 q=p;\n    vec2 d=vec2(length(q)-0.6,0.9);\n    \n    q.xz=c2p(q.xz); q.x+=M_PI/2.; q.xz=p2c(q.xz);\n    \n    for(int i=0;i<5;i++)\n    {\n        q=abs(q);\n        q.xz=c2p(q.xz); q.x+=M_PI/6.; q.xz=p2c(q.xz);\n    }\n        \n    if(mod(iTime,4.)>2.) d=vec2(cube(q,vec3(.5)),0.1);\n    \n    d=_min(d,vec2(length(p+vec3(sin(iTime),0.,cos(iTime))*3.)-0.9,2.));\n    float m=floor(mod(length(p.xz*4.),1.)*1.1);\n    d=_min(d,vec2(max(-p.y+1.,length(p.xz)-3.),m));\n    d=_min(d,vec2(MAX_DISTANCE,4.));\n    return d;\n}\nvec3 normal(vec3 p, float epsilon)\n{\n    vec2 e=vec2(epsilon*10.,0.);\n    return normalize(vec3(\n        map(p+e.xyy).x-map(p-e.xyy).x,\n        map(p+e.yxy).x-map(p-e.yxy).x,\n        map(p+e.yyx).x-map(p-e.yyx).x\n    ));\n}\n\nvec2 march(vec3 origin,vec3 ray)\n{\n    float t=0.;\n    vec2 result=vec2(MAX_DISTANCE,0.);\n    for(int i=0;i<MAX_STEPS; i++)\n    {\n        result=map(origin+ray*t);\n        if(abs(result.x)<EPSILON||result.x>=MAX_DISTANCE) break;\n        t+=result.x>0.?abs(result.x*STEP_COEF):max(0.05,abs(result.x*STEP_COEF));\n        //t+=abs(result.x);\n    }\n    return vec2(min(t,MAX_DISTANCE),result.y);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(fragCoord/iResolution.xy-.5)*2.;\n    uv.x=uv.x*iResolution.x/iResolution.y;   \n    vec3 camera=vec3(1.2);\n    camera=vec3(sin(iTime/1.567),sin(iTime/1.789)*.3-.3,cos(iTime/1.567))*2.;\n    vec3 ray=look(uv,camera,vec3(0.));\n    // --- //\n    float refraction=1.;\n    float emission=0.;\n    float totalDistance=0.;\n    vec3 pos=camera;\n    vec3 dir=ray;\n    for(int i=0;i<50;i++)\n    {\n        vec2 result=march(pos,dir);\n        totalDistance+=result.x;\n        if(result.y>=LUM)\n        {\n            emission+=result.y;\n            break;\n        }\n        else if(result.y==0.)\n        {\n            emission=0.;\n            refraction=0.;\n            break;\n        }\n        else\n        {\n            pos=pos+result.x*dir;\n            float ref=1.1;\n            vec3 n = normal(pos,EPSILON);\n            if (dot(n,dir) > 0.) {\n                n = -n;\n                ref = 1./ref;\n            }\n            pos -= EPSILON * n;\n            dir=normalize(refract(dir,n,1./ref));\n        }\n    }\n    // --- //\n    fragColor = vec4(vec3(refraction*emission/pow(totalDistance,.7)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltKyRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 58], [59, 59, 79, 79, 115], [116, 116, 143, 143, 163], [164, 164, 210, 210, 413], [567, 567, 595, 595, 644], [645, 645, 663, 663, 1176], [1177, 1177, 1213, 1213, 1399], [1401, 1401, 1435, 1435, 1794], [1795, 1795, 1852, 1852, 2954]], "test": "timeout"}
{"id": "ltKyRR", "name": "Substance flow", "author": "Witek", "description": "Simple effect achieved after playing around with 3D simplex noise functions.", "tags": ["noise"], "likes": 28, "viewed": 562, "published": "Public", "date": "1534891557", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n * This work is licensed under a \n * Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n * http://creativecommons.org/licenses/by-nc-sa/3.0/\n *  - You must attribute the work in the source code \n *    (link to https://www.shadertoy.com/view/ltKyRR).\n *  - You may not use this work for commercial purposes.\n *  - You may distribute a derivative work only under the same license.\n */\n\nvec3 random3(vec3 c)\n{\n    float j = 4096.0*sin(dot(c, vec3(17.0, 59.4, 15.0)));\n    vec3 r;\n    r.z = fract(512.0 * j);\n    j *= 0.125;\n    r.x = fract(512.0 * j);\n    j *= 0.125;\n    r.y = fract(512.0 * j);\n    return r - 0.5;\n}\n\nconst float F3 = 0.3333333;\nconst float G3 = 0.1666667;\n\n// taken from https://www.shadertoy.com/view/XsX3zB\nfloat simplex3d(vec3 p)\n{\n     vec3 s = floor(p + dot(p, vec3(F3)));\n     vec3 x = p - s + dot(s, vec3(G3));\n     vec3 e = step(vec3(0.0), x - x.yzx);\n     vec3 i1 = e*(1.0 - e.zxy);\n     vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n     vec3 x1 = x - i1 + G3;\n     vec3 x2 = x - i2 + 2.0*G3;\n     vec3 x3 = x - 1.0 + 3.0*G3;\n     vec4 w, d;\n     w.x = dot(x, x);\n     w.y = dot(x1, x1);\n     w.z = dot(x2, x2);\n     w.w = dot(x3, x3);\n     w = max(0.6 - w, 0.0);\n     d.x = dot(random3(s), x);\n     d.y = dot(random3(s + i1), x1);\n     d.z = dot(random3(s + i2), x2);\n     d.w = dot(random3(s + 1.0), x3);\n     w *= w;\n     w *= w;\n     d *= w;\n     return dot(d, vec4(52.0));\n}\n\nfloat simplex3d_fractal(vec3 m)\n{\n    float sum = 0.0;\n    for (int i = 0; i < 12; ++i)\n    {\n        float scale = pow(2.0, float(i));\n        sum += simplex3d(scale * m) / scale;\n    }\n    return sum;\n}\n\nvec3 flow_texture(in vec3 p)\n{\n    // animate initial coordinates\n    vec3 p1 = 0.1 * p + vec3(1.0 + iTime * 0.0023, 2.0 - iTime * 0.0017, 4.0 + iTime * 0.0005);\n    // distort noise sampling coordinates using the same noise function\n    vec3 p2 = p + 8.1 * simplex3d_fractal(p1) + 0.5;\n    vec3 p3 = p2 + 4.13 * simplex3d_fractal(0.5 * p2 + vec3(5.0, 4.0, 8.0 + iTime * 0.07)) + 0.5;\n\n    vec3 ret;\n    ret.x = simplex3d_fractal(p3 + vec3(0.0, 0.0, 0.0 + iTime * 0.3));\n    ret.y = simplex3d_fractal(p3 + vec3(0.0, 0.0, 0.2 + iTime * 0.3));\n    ret.z = simplex3d_fractal(p3 + vec3(0.0, 0.0, 0.3 + iTime * 0.3));\n\n    // scale output & map\n    ret = 0.5 + 0.5 * ret;\n    ret = smoothstep(vec3(0.15), vec3(0.85), ret);\n    return ret;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 result = vec3(0.0);\n\n    const int numSamples = 2; // cheap AA\n    for (int x = 0; x < numSamples; ++x)\n    {\n        for (int y = 0; y < numSamples; ++y)\n        {\n            vec2 offset = vec2(float(x), float(y)) / float(numSamples);\n            vec3 p = vec3((fragCoord.xy + offset) / iResolution.x, iTime*0.001);\n            result += flow_texture(p * 6.0);\n            \n        }\n    }\n\n    result /= float(numSamples * numSamples);\n    fragColor = vec4(sqrt(result), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltKyRR.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-4.0", "functions": [[411, 411, 433, 433, 641], [700, 752, 777, 777, 1419], [1421, 1421, 1454, 1454, 1625], [1627, 1627, 1657, 1692, 2362], [2364, 2364, 2419, 2419, 2910]], "test": "ok"}
{"id": "lttczf", "name": "Bilinear warping", "author": "lycium", "description": "test of bilinear distribution sampling.", "tags": ["warping", "sampling", "distribution"], "likes": 6, "viewed": 306, "published": "Public API", "date": "1533569117", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float warp1d(float x, float a, float b)\n{\n    float s = b - a;\n    if (abs(s) < 2e-5) return x; // check for flat distribution\n\n\tfloat D = a*a + (b*b - a*a) * x;\n\treturn (sqrt(max(0.0, D)) - a) / s; // max with 0 to prevent -ve sqrt\n}\n\n// Data points are arranged as follows:\n//\n// a -- b\n// |    |\n// c -- d\n//\n// p_in is a point in [0,1] to be warped to this bilinear distribution.\nvec2 warp2d(vec2 p_in, float a, float b, float c, float d)\n{\n\tfloat y = warp1d(p_in.y, a + b, c + d);\n\n\tfloat x0 = a + (c - a) * y;\n\tfloat x1 = b + (d - b) * y;\n\tfloat x = warp1d(p_in.x, x0, x1);\n\n\treturn vec2(x, y);\n}\n\nfloat sint(float a, float b) { float v = sin(iTime * 0.1 * a + b); return 1.0 - v * v; }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfloat aspect = iResolution.y / iResolution.x;\n\tvec2 pixel_scale = vec2(1.0 / iResolution.x, -aspect / iResolution.y) * 2.0;\n\tvec2 pixel = (fragCoord - iResolution.xy * 0.5) * pixel_scale;\n\n\tfloat pixel_bright = 0.0;\n    \n    if (pixel.x < -0.5 || pixel.x >= 0.5 ||\n\t\tpixel.y < -0.5 || pixel.y >= 0.5)\n    {\n        pixel_bright += 0.0125;\n    }\n    else\n    {\n        float a = sint(5.4534, 1.421); float b = sint(9.9531, 0.492);\n        float c = sint(7.1511, 1.119); float d = sint(2.3593, 1.122);\n\n        const float samples = float(144);\n        const float norm = 1.0 / samples;\n        for (float z = 0.0; z < samples; z += 1.0)\n        {\n            float x = (z + 0.5) * norm;\n            float y = mod(x * 89.0, 1.0);\n            vec2 u = vec2(x, y);\n\n            vec2 warped = warp2d(u, a, b, c, d);\n\n            vec2 d = (warped - 0.5) - pixel;\n            float thresh = 0.000081;\n            float falloff = 0.00003;\n            pixel_bright += smoothstep(thresh, thresh - falloff, dot(d, d));\n        }\n    }\n\n\tvec3 colour_sRGB = vec3(sqrt(pixel_bright));\n    fragColor = vec4(colour_sRGB, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lttczf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 234], [236, 384, 444, 444, 602], [604, 604, 634, 634, 692], [694, 694, 749, 749, 1863]], "test": "ok"}
{"id": "lttyRj", "name": "Sierpinski Decay", "author": "firegodjr", "description": "Pretty much just bitwise operator magic! I wanted to make something a bit more optimized (and larger in scope) than my Dwitter version at https://www.dwitter.net/d/9060. Enjoy!", "tags": ["red", "blue", "sierpinski", "bitwise", "decay", "sierpinskitriangle"], "likes": 6, "viewed": 477, "published": "Public API", "date": "1533258121", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    highp float X = fragCoord.x;\n    highp float Y = fragCoord.y;\n    highp float sloTime = iTime/3.;\n    highp int color = int(iTime * 99. + float(int(sin(sloTime)*X + cos(sloTime)*Y) & int(- cos(sloTime)*X + sin(sloTime)*Y)))%610;\n\n    // Output to screen\n    fragColor = vec4(1. - float(color)/100., float(color)/610., float(color)/610., 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lttyRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 499]], "test": "ok"}
{"id": "lttyWl", "name": "simple 3d noise function", "author": "stoox", "description": "simple 3d noise function with hash function", "tags": ["noise"], "likes": 2, "viewed": 628, "published": "Public API", "date": "1534702684", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash(float n)\n{\n\treturn fract(sin(n) * 43728.1453);\n}\n\nfloat noise(vec3 x)\n{\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\n\tf = f * f * (3.0 - 2.0 * f);\n\tfloat n = p.x + p.y * 55.0 + p.z * 101.0 ;\n\nreturn mix(\n\tmix(\n\t\tmix(hash(n), hash(n + 1.0), f.x),\n\t\tmix(hash(n+55.0), hash(n + 56.0), f.x),\n\t\tf.y),\n\tmix(\n\t\tmix(hash(n+101.0), hash(n + 102.0), f.x),\n\t\tmix(hash(n+156.0), hash(n + 157.0), f.x),\n\t\tf.y),\n\tf.z);\n}\n\n// for shadertoy:\n// (for a simple test I chose the third dimension to be the time)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Normalized pixel coordinates (from 0 to 1)\n\tvec2 uv = fragCoord/iResolution.xy;\n\n\t// Time varying pixel color\n\tvec3 col = vec3(1.0,0.0,0.5)*noise(vec3(2.5*uv,0.5*iTime));\n\n\t// Output to screen\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lttyWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 59], [61, 61, 82, 82, 413], [415, 499, 556, 603, 783]], "test": "ok"}
{"id": "lttyWs", "name": "Distance Goo", "author": "momoro", "description": "Messy code. WIP", "tags": ["voronoi"], "likes": 7, "viewed": 475, "published": "Public API", "date": "1534728001", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nmat2 rotate(float angle) {\n    return mat2(cos(angle), -sin(angle),\n                sin(angle), cos(angle)\n    );\n}\n\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                    vec2(12.9898, 78.233)))*\n        \t\t\t\t 43758.5453123);\n}\n\nfloat random1 (float f) {\n    return random(vec2(f, -0.128));\n}\n\nvec2 random2( vec2 p ) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// Commutative smooth minimum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk:\nfloat smin(float a, float b, float k){\n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\nfloat noise(float s) {\t\n    float i = floor(s);\n    float f = fract(s);\n    float n = mix(random(vec2(i, 0.)), \n                  random(vec2(i+1., 0.)), \n                  smoothstep(0.0, 1., f)); \n   \n    return n;\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat map(float value, float inMin, float inMax, float outMin, float outMax) {\n\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n\n} \n\n\n\nvec2 map(vec2 value, vec2 inMin, vec2 inMax, vec2 outMin, vec2 outMax) {\n\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n\n}\n\n\n\nvec3 map(vec3 value, vec3 inMin, vec3 inMax, vec3 outMin, vec3 outMax) {\n\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n\n}\n\n\n\nvec4 map(vec4 value, vec4 inMin, vec4 inMax, vec4 outMin, vec4 outMax) {\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n}\n\n\n\n\nvec4 blend(vec4 bg, vec4 fg) {\n    vec4 c = vec4(0.);\n    c.a = 1.0 - (1.0 - fg.a) * (1.0 - bg.a);\n    if(c.a < .00000) return c;\n    \n    c.r = fg.r * fg.a / c.a + bg.r * bg.a * (1.0 - fg.a) / c.a;\n    c.g = fg.g * fg.a / c.a + bg.g * bg.a * (1.0 - fg.a) / c.a;\n    c.b = fg.b * fg.a / c.a + bg.b * bg.a * (1.0 - fg.a) / c.a;\n    \n    return c;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec4 color;\n\n    for(float i=0.; i<3.; i++) {\n        vec2 st = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n       //st = rotate(i * 0.024) * st;\n        \n\n       // st *=6.456 * i/-0.528;\n//        st *= i * 30.;\n      //  st *= 4. + (i/11.);\n        st *= 3.5;\n        st += vec2(-0.170,-0.240);\n\n        // Tile\n        vec2 i_st = floor(st);\n        vec2 f_st = fract(st);\n\n        float m_dist = 1.; // min distance\n\n        for(int j=-2; j<=2; j++) {\n            for(int i=-2; i<=2; i++) {\n\n                // Neighbor place in the grid\n                vec2 neighbor = vec2(float(i), float(j));\n\n                // Random position from current + neighbor place in the grid\n                vec2 offset = random2(i_st + neighbor);\n\n                // Animate the offset\n                offset = 0.5 + 0.5 * sin(iTime + 6.2831 * offset );\n\n                // Position of the cell\n                vec2 pos = neighbor + offset - f_st;\n\n                // Cell distance\n                float dist = length(pos);\n\n                // Metaball\n                m_dist = smin(m_dist, dist, 1.344);            \n            }\n        }\n\n\n        float f = m_dist;\n        f *= 5.;\n        float steps = 3.;\n                f = ceil(f *steps) / steps;\n\n        vec2 cst = st;\n        cst = rotate(iTime/10.) * cst;\n        cst *= sin(iTime/2.);\n        float h = map(m_dist, 0., 1., 0.068, -0.316);\n      //  float h;\n\n     //   h += (cst.x + 0.376)/10. * (cst.y/10. - 1.280) * 1.264;\n\n        //h = -2.224 * i/1.680 * cos(st.x/25. * u_time) * length(st*-0.016);\n      //  h = 1.;\n        float s = map(f, 0., 1., 1., 0.752);\n        float v = map(f, 0., 0.696, 0.280, 0.824);\n\n        color += vec4(hsv2rgb(vec3(h, s, v)), 0.184);\n     //   color *= \tfwidth(f) * 100.;\n\n        //color *= 2.896;\n\n        vec2 uv= st;\n        f = 0.;\n        uv.x *= noise(iTime - 20.);\n        uv.y *= noise(iTime);\n        f = 1.0 - length(uv);\n\n        vec2 uv2 = st;\n        uv2 += 0.476;\n        uv2*=0.378;\n        float q = map(1.0 - length(uv2), -0.496, 1., -0.552, 1.072);\n        q += 3.744;\n        \n\n\n       //color *= abs(vec4(f)) * 1.276 ;\n       // color *= q * 0.760;\n    }\n    \n\tvec2 st = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\tfloat f =  length(st);\n    f = smoothstep(0.352, 0.332, f);\n    //color = vec3(f);\n //  color *= f;\n    color *= 1.704;\n  //  color = fwidth(color) * 100.;\n    fragColor = color;\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lttyWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 72, 72, 161], [164, 164, 192, 192, 301], [303, 303, 328, 328, 366], [368, 368, 392, 392, 485], [487, 597, 635, 635, 711], [713, 713, 735, 735, 931], [933, 933, 955, 955, 1286], [1288, 1288, 1310, 1310, 1479], [1481, 1481, 1559, 1559, 1636], [1641, 1641, 1713, 1713, 1790], [1794, 1794, 1866, 1866, 1943], [1947, 1947, 2019, 2019, 2094], [2099, 2099, 2129, 2129, 2446], [2450, 2450, 2507, 2507, 4943]], "test": "ok"}
{"id": "lttyzs", "name": "Circle Pulsar", "author": "Beefster", "description": "My friend was complaining about how OpenGL couldn't do circles, so I made this to prove him wrong.", "tags": ["circle"], "likes": 1, "viewed": 52, "published": "Public", "date": "1533744542", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.1415926535;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    // vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    vec2 d = (fragCoord - vec2(300.0, 180.0)) / 2.0;\n    float dist = sqrt(d.x * d.x + d.y * d.y);\n    float atten = dist / 120.0;\n    \n    fragColor = vec4(\n        float(dist > 10.0 + cos(iTime * 1.2 + PI) * 5.0 && dist < 40.0 + sin(iTime) * 10.0) - atten,\n        float(dist > 25.0 + sin(iTime * 1.3 + PI) * 5.0 && dist < 55.0 + cos(iTime * 0.9) * 10.0) - atten + 0.25,\n        float(dist > 45.0 - sin(iTime * 1.4) * 15.0 && dist < 75.0 - cos(iTime * 1.1 + PI) * 10.0) - atten + 0.5,\n        1.0\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lttyzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 32, 89, 139, 804]], "test": "ok"}
{"id": "ltVyzh", "name": "Penguins Can't Fly", "author": "dr2", "description": "Or perhaps they can...", "tags": ["voronoi", "hexagon", "flight", "penguin"], "likes": 11, "viewed": 465, "published": "Public API", "date": "1535125710", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Penguins Can't Fly\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA        0   // optional antialiasing\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrEllipsDf (vec3 p, vec3 r);\nvec2 Rot2D (vec2 q, float a);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nvoid HexVorInit ();\nvec4 HexVor (vec2 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nvec3 Noisev3v2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 flPos, sunDir, qHit, pngOff;\nvec2 gId;\nfloat dstFar, tCur, fAng, szFac, hgSize, grLim;\nint idObj;\nconst float pi = 3.14159, sqrt3 = 1.7320508;\n\nfloat GrndHt (vec2 p)\n{\n  vec4 sv;\n  float h1, h2, s;\n  sv = HexVor (0.06 * p + 0.2 * length (Noisev3v2 (0.3 * p)));\n  s = (0.8 + 0.5 * sv.w);\n  h1 = smoothstep (0.1, 0.3 + 0.1 * sv.w, sv.x);\n  h2 = 1.5 * smoothstep (0.2, 0.4 + 0.1 * sv.w, max (0., (0.45 - dot (sv.yz, sv.yz))));\n  return SmoothMax (s * h1, s * h2, 0.2) - 0.5;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  dHit = dstFar;\n  if (rd.y < 0.) {\n    s = - (ro.y - 6.) / rd.y;\n    sLo = s;\n    for (int j = 0; j < 220; j ++) {\n      p = ro + s * rd;\n      h = p.y - GrndHt (p.xz);\n      if (h < 0.) break;\n      sLo = s;\n      s += max (0.2, 0.4 * h);\n      if (s > dstFar) break;\n    }\n    if (h < 0.) {\n      sHi = s;\n      for (int j = 0; j < 5; j ++) {\n        s = 0.5 * (sLo + sHi);\n        p = ro + s * rd;\n        if (p.y > GrndHt (p.xz)) sLo = s;\n        else sHi = s;\n      }\n      dHit = 0.5 * (sLo + sHi);\n    }\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec2 e = vec2 (0.001, 0.);\n  return normalize (vec3 (GrndHt (p.xz) - vec2 (GrndHt (p.xz + e.xy), GrndHt (p.xz + e.yx)), e.x).xzy);\n}\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, dh;\n  dMin = dstFar;\n  if (szFac > 0.) {\n    p.xz -= HexToPix (gId * hgSize) + pngOff.xz;\n    dMin /= szFac;\n    p.y += pngOff.y;\n    p /= szFac;\n    p.yz = Rot2D (p.yz, 0.4 * pi);\n    q = p;\n    d = PrEllipsDf (q.xzy, vec3 (1.3, 1.2, 1.4));\n    q.y -= 1.5;\n    dh = PrEllipsDf (q.xzy, vec3 (0.8, 0.6, 1.3));\n    q = p;\n    q.x = abs (q.x);\n    q -= vec3 (0.3, 2., -0.4);\n    d = SmoothMin (d, max (dh, - PrCylDf (q, 0.15, 0.3)), 0.2);\n    DMINQ (1);\n    q = p;\n    q.yz -= vec2 (1.6, -0.6);\n    d = max (PrEllipsDf (q, vec3 (0.4, 0.2, 0.6)), 0.01 - abs (q.y));\n    DMINQ (2);\n    q = p;\n    q.x = abs (q.x);\n    q -= vec3 (0.3, 2., -0.4);\n    d = PrSphDf (q, 0.15);\n    DMINQ (3);\n    q = p;\n    q.x = abs (q.x);\n    q.xy -= vec2 (0.4, -0.8);\n    d = PrCylDf (q.xzy, 0.12, 0.6);\n    DMINQ (4);\n    q -= vec3 (0.1, -0.9, -0.2);\n    q.yz = Rot2D (q.yz, 0.25 * pi);\n    q.xz = Rot2D (q.xz, -0.07 * pi);\n    d = PrEllipsDf (q.xzy, vec3 (0.15, 0.5, 0.05));\n    q.z -= 0.5;\n    q.xz = Rot2D (q.xz, 0.15 * pi);\n    q.z -= -0.5;\n    d = SmoothMin (d, PrEllipsDf (q.xzy, vec3 (0.15, 0.5, 0.05)), 0.05);\n    q.z -= 0.5;\n    q.xz = Rot2D (q.xz, -0.3 * pi);\n    q.z -= -0.5;\n    d = SmoothMin (d, PrEllipsDf (q.xzy, vec3 (0.15, 0.5, 0.05)), 0.05);\n    DMINQ (5);\n    q = p;\n    q.x = abs (q.x);\n    q -= vec3 (1.1, 0.3, 0.);\n    q.yz = Rot2D (q.yz, -0.45 * pi);\n    q.xy = Rot2D (q.xy, fAng) - vec2 (0., -0.7);\n    d = PrEllipsDf (q.xzy, vec3 (0.05, 0.5, 1.4));\n    DMINQ (6);\n    dMin *= szFac;\n  }\n  return dMin;\n}\n\nvoid SetPngConf ()\n{\n  vec2 w;\n  float t;\n  t = Hashfv2 (17. * gId + 99.);\n  if (t < 0.05) szFac = 0.;\n  else {\n    szFac = 0.6 * (0.5 * sqrt3 - 0.3 * t);\n    fAng = -0.5 * pi + 0.2 * pi * (0.2 + 0.8 * SmoothBump (0.25, 0.75, 0.1,\n       mod (0.2 * tCur + 1.3 * t, 1.))) * sin (5. * pi * tCur + 2. * pi * t);\n    w = Hashv2v2 (73. * gId + 77.);\n    pngOff.xz = hgSize * max (0., 0.5 * sqrt3 - 1.5 * szFac) * w.x * sin (2. * pi * w.y +\n       vec2 (0.5 * pi, 0.)) * vec2 (1., 1.3);\n    pngOff.y = 2. * t * cos (0.1 * (1. + t) * pi * tCur + 2. * pi * t) - 0.5;\n  }\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP, rs;\n  float dHit, d, s, f;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSize / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  rs = ro.xz - flPos.xz;\n  vf = 0.5 * sqrt3 - vec3 (dot (rs, edN[0]), dot (rs, edN[1]), dot (rs, edN[2])) / hgSize;\n  pM = HexToPix (PixToHex (rs / hgSize));\n  gIdP = vec2 (-99.);\n  dHit = 0.;\n  for (int j = 0; j < 220; j ++) {\n    hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n    s = min (hv.x, min (hv.y, hv.z));\n    p = ro - flPos + dHit * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (max (max (abs (gId.x), abs (gId.y)), abs (gId.x + gId.y)) <= grLim) {\n      if (gId.x != gIdP.x || gId.y != gIdP.y) {\n        gIdP = gId;\n        SetPngConf ();\n      }\n      d = ObjDf (p);\n    } else d = dstFar;\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + 0.01;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n    }\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  if (d >= 0.0005) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec3 e = vec3 (0.001, -0.001, 0.);\n  p -= flPos;\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nvec3 SkyBg (vec3 rd)\n{\n  return vec3 (0.1, 0.2, 0.5) + 0.1 * pow (1. - max (rd.y, 0.), 8.);\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  float f;\n  ro.x += 0.5 * tCur;\n  f = Fbm2 (0.05 * (rd.xz * (100. - ro.y) / rd.y + ro.xz));\n  col = SkyBg (rd) + 0.8 * pow (max (dot (rd, sunDir), 0.), 1024.) * vec3 (1., 1., 0.6);\n  return mix (col, vec3 (0.85), clamp (f * rd.y + 0.1, 0., 1.));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 vn, col;\n  float dstObj, dstGrnd;\n  HexVorInit ();\n  dstGrnd = GrndRay (ro, rd);\n  dstObj = ObjRay (ro, rd);\n  if (min (dstGrnd, dstObj) < dstFar) {\n    if (dstGrnd < dstObj) {\n      ro += dstGrnd * rd;\n      if (ro.y > 0.1) {\n        vn = VaryNf (0.5 * ro, GrndNf (ro), 0.5);\n        col4 = vec4 (0.9, 0.9, 1., 0.3);\n        col = col4.rgb * (0.1 + 0.1 * max (dot (vn, - normalize (vec3 (sunDir.xz, 0.).xzy)), 0.) +\n           0.1 * max (vn.y, 0.) + 0.8 * max (dot (vn, sunDir), 0.)) +\n           col4.a * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n        col *= 1. - 0.3 * smoothstep (0.3, 0.7, Fbm2 (0.1 * ro.xz - tCur * vec2 (0.1, 0.)));\n      } else {\n        vn = VaryNf (4. * ro, vec3 (0., 1., 0.), 0.2);\n        rd = reflect (rd, vn);\n        col = mix (vec3 (0.2, 0.3, 0.2), vec3 (0.2, 0.2, 0.3), Fbm2 (ro.xz));\n        col = mix (col, 0.8 * SkyCol (ro, rd), smoothstep (0.8, 0.95,\n            1. - pow (dot (rd, vn), 3.)));\n      }\n    } else {\n      ro += dstObj * rd;\n      gId = PixToHex ((ro - flPos).xz / hgSize);\n      SetPngConf ();\n      vn = ObjNf (ro);\n      if (idObj == 1) col4 = (qHit.z < -0.2 || qHit.z < 0. && length (qHit.xy) < 0.2) ?\n         vec4 (0.95, 0.95, 0.95, 0.05) : vec4 (0.1, 0.1, 0.15, 0.1);\n      else if (idObj == 2) col4 = vec4 (1., 0.8, 0.2, 0.2);\n      else if (idObj == 3) col4 = vec4 (0.05, 0.15, 0.05, 0.2);\n      else if (idObj == 4) col4 = vec4 (0.05, 0.1, 0.05, 0.1);\n      else if (idObj == 5) col4 = vec4 (0.9, 0.9, 0., 0.3);\n      else if (idObj == 6) col4 = vec4 (0.15, 0.15, 0.2, 0.1);\n      col = col4.rgb * (0.1 + 0.1 * max (dot (vn, - normalize (vec3 (sunDir.xz, 0.).xzy)), 0.) +\n         0.1 * max (- vn.y, 0.) + 0.8 * max (dot (sunDir, vn), 0.)) +\n         col4.a * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n    }\n    col = mix (col, SkyBg (rd), smoothstep (0.3, 1., min (dstGrnd, dstObj) / dstFar));\n  } else col = SkyCol (ro, rd);\n  return pow (clamp (col, 0., 1.), vec3 (0.8));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, dateCur;\n  vec3 ro, rd, vd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float az, el, flyVel;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur = mod (tCur, 2400.) + 30. * floor (dateCur.w / 7200.);\n  hgSize = 2.3;\n  grLim = 8.;\n  flyVel = -5.;\n  el = 0.15 * pi - 0.2 * pi * (2. * SmoothBump (0.25, 0.75, 0.2, mod (0.015 * tCur, 1.)) - 1.);\n  az = 0.5 * pi + 2. * pi * (0.5 + abs (mod (0.01 * tCur, 2.) - 1.));\n  if (mPtr.z > 0.) {\n    el += 0.5 * pi * mPtr.y;\n    az += 0.3 * pi * mPtr.x;\n  }\n  el = clamp (el, -0.05 * pi, 0.4 * pi);\n  flPos = vec3 (0., 10., flyVel * tCur);\n  ro = flPos + 2. * grLim * hgSize * vec3 (cos (el) * cos (az), sin (el), cos (el) * sin (az));\n  vd = normalize (flPos + vec3 (0., -40. * sin (el), 0.) - ro);\n  vuMat = mat3 (vec3 (vd.z, 0., - vd.x) / sqrt (1. - vd.y * vd.y),\n     vec3 (- vd.y * vd.x, 1. - vd.y * vd.y, - vd.y * vd.z) / sqrt (1. - vd.y * vd.y), vd);\n  ro.y = max (2., ro.y);\n  sunDir = normalize (vec3 (1., 2., -1.));\n  dstFar = 300.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 4.;\n#endif  \n  col = vec3 (0.);\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.71 / canvas.y, 0.),\n       0.5 * pi * (a + 0.5)), 1.8));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (pow (col, vec3 (0.9)), 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec2 gVec[7], hVec[7];\n\nvoid HexVorInit ()\n{\n  vec3 e = vec3 (1., 0., -1.);\n  gVec[0] = e.yy;\n  gVec[1] = e.xy;\n  gVec[2] = e.yx;\n  gVec[3] = e.xz;\n  gVec[4] = e.zy;\n  gVec[5] = e.yz;\n  gVec[6] = e.zx;\n  for (int k = 0; k < 7; k ++) hVec[k] = HexToPix (gVec[k]);\n}\n\nvec4 HexVor (vec2 p)\n{\n  vec4 sd, udm;\n  vec2 ip, fp, d, u;\n  float amp, a;\n  amp = 0.7;\n  ip = PixToHex (p);\n  fp = p - HexToPix (ip);\n  sd = vec4 (4.);\n  udm = vec4 (4.);\n  for (int k = 0; k < 7; k ++) {\n    u = Hashv2v2 (ip + gVec[k]);\n    a = 2. * pi * (u.y - 0.5);\n    d = hVec[k] + amp * (0.4 + 0.6 * u.x) * vec2 (cos (a), sin (a)) - fp;\n    sd.w = dot (d, d);\n    if (sd.w < sd.x) {\n      sd = sd.wxyw;\n      udm = vec4 (d, u);\n    } else sd = (sd.w < sd.y) ? sd.xwyw : ((sd.w < sd.z) ? sd.xyww : sd);\n  }\n  sd.xyz = sqrt (sd.xyz);\n  return vec4 (SmoothMin (sd.y, sd.z, 0.3) - sd.x, udm.xy, Hashfv2 (udm.zw));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + vec4 (0., 1., 57., 58.)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nvec3 Noisev3v2 (vec2 p)\n{\n  vec4 h;\n  vec3 g;\n  vec2 ip, fp, ffp;\n  ip = floor (p);\n  fp = fract (p);\n  ffp = fp * fp * (3. - 2. * fp);\n  h = Hashv4f (dot (ip, vec2 (1., 57.)));\n  g = vec3 (h.y - h.x, h.z - h.x, h.x - h.y - h.z + h.w);\n  return vec3 (h.x + dot (g.xy, ffp) + g.z * ffp.x * ffp.y,\n     30. * fp * fp * (fp * fp - 2. * fp + 1.) * (g.xy + g.z * ffp.yx));\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltVyzh.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[834, 834, 857, 857, 1163], [1165, 1165, 1199, 1199, 1772], [1774, 1774, 1796, 1796, 1931], [2004, 2004, 2026, 2026, 3559], [3561, 3561, 3581, 3581, 4125], [4127, 4127, 4160, 4160, 5387], [5389, 5389, 5410, 5410, 5626], [5628, 5628, 5650, 5650, 5721], [5723, 5723, 5755, 5755, 6016], [6018, 6018, 6053, 6053, 8043], [8045, 8045, 8101, 8101, 9601], [9603, 9603, 9636, 9636, 9663], [9665, 9665, 9707, 9707, 9758], [9760, 9760, 9795, 9795, 9857], [9859, 9859, 9889, 9889, 9947], [9949, 9949, 9994, 9994, 10097], [10099, 10099, 10144, 10144, 10182], [10184, 10184, 10241, 10241, 10324], [10326, 10326, 10350, 10350, 10580], [10582, 10582, 10606, 10606, 10666], [10692, 10692, 10712, 10712, 10932], [10934, 10934, 10956, 10956, 11552], [11586, 11586, 11610, 11610, 11670], [11672, 11672, 11696, 11696, 11826], [11828, 11828, 11852, 11852, 11915], [11917, 11917, 11942, 11942, 12128], [12130, 12130, 12155, 12155, 12499], [12501, 12501, 12522, 12522, 12677], [12679, 12679, 12708, 12708, 12920], [12922, 12922, 12961, 12961, 13141]], "test": "error"}
{"id": "ltVyzw", "name": "Metaballs rainbow", "author": "Citiral", "description": "I came across this effect when messing around with metaballs. Had to share it :)\n", "tags": ["metaballs", "colors", "color", "metaball", "rainbow"], "likes": 7, "viewed": 539, "published": "Public API", "date": "1535586528", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Came across this when messing around with metaballs. Had to share it :)\n\nconst int BALLS = 25;\n\n// noise and rand functions stolen from stack overflow :)\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nvec2 hash(vec2 co) {\n    float m = dot(co, vec2(12.9898, 78.233));\n    return fract(vec2(sin(m),cos(m))* 43758.5453) * 2. - 1.;\n}\n\nfloat fade(float t) { return t * t * t * (t * (t * 6. - 15.) + 10.); }\n\nvec2 ssmooth(vec2 x) { return vec2(fade(x.x), fade(x.y)); }\n\nfloat perlinNoise(vec2 uv) {\n    vec2 PT  = floor(uv);\n    vec2 pt  = fract(uv);\n    vec2 mmpt= ssmooth(pt);\n\n    vec4 grads = vec4(\n        dot(hash(PT + vec2(.0, 1.)), pt-vec2(.0, 1.)),   dot(hash(PT + vec2(1., 1.)), pt-vec2(1., 1.)),\n        dot(hash(PT + vec2(.0, .0)), pt-vec2(.0, .0)),   dot(hash(PT + vec2(1., .0)), pt-vec2(1., 0.))\n    );\n\n    return 5.*mix (mix (grads.z, grads.w, mmpt.x), mix (grads.x, grads.y, mmpt.x), mmpt.y);\n}\n\n// https://github.com/hughsk/glsl-hsv2rgb/blob/master/index.glsl\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 position = fragCoord/iResolution.xy;\n\tposition.x *= iResolution.x / iResolution.y;\n\n    \n    vec3 dist = vec3(0.0);\n\tfor (int i = 0 ; i < BALLS ; i++) {\n\t\tvec2 bpos = vec2(perlinNoise(vec2(float(i*3218) + cos(iTime*0.1), iTime*0.1)), perlinNoise(vec2(float(i*1357) + sin(iTime*0.1), -iTime*0.1))) / 5.0;\n\t\tbpos += vec2(0.5 * iResolution.x/iResolution.y,0.5);\n\t\tdist += hsv2rgb(vec3(1.0 / (pow(position.x - bpos.x, 2.0) + pow(position.y - bpos.y, 2.0)), 1.0, 1.0));\n\t}\n\t\n\tfragColor = vec4(dist/18., 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltVyzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[99, 157, 177, 177, 215], [217, 217, 237, 237, 346], [348, 348, 369, 369, 418], [420, 420, 442, 442, 479], [481, 481, 509, 509, 922], [924, 989, 1011, 1011, 1174], [1176, 1176, 1233, 1283, 1798]], "test": "ok"}
{"id": "ltycRz", "name": "MultiJulia v:(0.0.0)", "author": "Chris_M_Thomasson", "description": "An initial try at an exploded Julia set wrt my:\n\nhttp://www.fractalforums.com/index.php?action=gallery;sa=view;id=20582\n\nexperiment using a vector field.", "tags": ["fractal", "experiment", "field", "vector"], "likes": 8, "viewed": 711, "published": "Public API", "date": "1534835050", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nExploding Julia Hyperbolic Vector v:(0.0.0)\n\nby: Chris M. Thomasson\n___________________________________*/\n\n\n// The number of points in the spiral\n#define CT_N 16\n\n// Viewport Axes\nstruct ct_axes\n{\n    float xmin;\n    float xmax;\n    float ymin;\n    float ymax;\n};\n    \n    \nct_axes ct_axes_from_radius(\n    in vec3 vpcircle\n){\n    return ct_axes(\n        vpcircle.x - vpcircle.z,\n        vpcircle.x + vpcircle.z,\n        vpcircle.y - vpcircle.z,\n        vpcircle.y + vpcircle.z\n    );\n}\n\n\n// Simple 2d Plane\nstruct ct_plane2d\n{\n    ct_axes axes;\n    float xstep;\n    float ystep;\n};\n    \n    \nct_plane2d ct_plane2d_create(\n    in ct_axes axes\n){\n    float awidth = axes.xmax - axes.xmin;\n    float aheight = axes.ymax - axes.ymin;\n    \n    float daspect = abs(iResolution.y / iResolution.x);\n    float waspect = abs(aheight / awidth);\n    \n    if (daspect > waspect)\n    {\n        float excess = aheight * (daspect / waspect - 1.0);\n        axes.ymax += excess / 2.0;\n        axes.ymin -= excess / 2.0;\n    }\n    \n    else if (daspect < waspect)\n    {\n        float excess = awidth * (waspect / daspect - 1.0);\n        axes.xmax += excess / 2.0;\n        axes.xmin -= excess / 2.0;\n    }\n    \n    return ct_plane2d(\n        axes,\n        (axes.xmax - axes.xmin) / iResolution.x,\n        (axes.ymax - axes.ymin) / iResolution.y\n    );\n}\n\n\nvec2 ct_plane2d_project(\n\tin ct_plane2d self,\n    in vec2 z\n){\n\treturn vec2(\n        self.axes.xmin + z.x * self.xstep,\n        self.axes.ymin + z.y * self.ystep\n    );\n}\n\n\n// A vector field point\nstruct ct_vfpoint\n{\n    vec2 p;\n    float m;\n};\n\n\n// Our global per-pixel points\nct_vfpoint g_vfp[CT_N + 1];\n\n\n// Gain a normalized vector from p, \n// using a power of npow.\nvec2 ct_vfield_normal(\n    in vec2 p,\n    float npow\n){\n    float eps = 0.00001;\n    vec2 g = vec2(eps, eps);\n    \n    const int imax = CT_N + 1;\n    \n    for (int i = 0; i < imax; ++i)\n    {\n        vec2 dif = g_vfp[i].p - p;\n        float sum = dif[0] * dif[0] + dif[1] * dif[1];\n        float mass = pow(sum, npow);\n        if (mass == 0.0) mass = 0.00001;\n        \n      \tg[0] = g[0] + g_vfp[i].m * dif[0] / mass;\n      \tg[1] = g[1] + g_vfp[i].m * dif[1] / mass;\n    }\n    \n    return normalize(g);\n}\n\n\nfloat ct_normal_pi(\n    in vec2 z,\n    in float sa\n){\n    float a = atan(z[1], z[0]) + sa;\n    if (a < 0.0) a += 6.28318;\n    a /= 6.28318;\n    return a;\n}\n\n\nvec2 ct_cmul(in vec2 p0, in vec2 p1)\n{\n    return vec2(p0.x * p1.x - p0.y * p1.y, p0.x * p1.y + p0.y * p1.x);\n}\n\n\n// Vector Pixel Iteration\nvec4 ct_vpixel(\n    in vec2 z,\n    in vec2 c,\n    in int n,\n    in float npow\n){\n    float s = 1.0;\n    float t = iTime * .1;\n    vec2 jc = vec2(-1.6 + abs(cos(iTime * .01)), 0.0);\n    vec3 xxxcolor = vec3(0, 0, 0);\n    \n    vec2 zcopy = z;\n    \n    // Augment z with some Mandelbrot iterations\n    for (int i = 0; i < 9; ++i)\n    {\n        z = ct_cmul(z, z);\n    \tz = z + jc;\n        \n        if (length(z) > 2.0)\n        {\n            xxxcolor += vec3(float(i) * .07, 0, 0);\n            //z = zcopy;\n            //break;\n            \n            float xmin = .14;\n            float xmax = .16;\n            float xdif = xmax - xmin;\n            \n            z = z * .01;\n        }\n        \n        else\n        {\t\n            xxxcolor += vec3(.01, .01, .01);\n        }\n    }\n\n    \n    vec2 vn = ct_vfield_normal(z, npow);\n    \n    float a = 0.0;\n\n    vec2 rc = vec2(\n        vn[0] * cos(a) - vn[1] * sin(a),\n        vn[0] * sin(a) + vn[1] * cos(a)\n    );\n    \n    float npi = ct_normal_pi(vn, a);\n    \n    float scale = float(CT_N);\n    \n    float color = mod(npi * scale, 1.0);\n    \n    if (color < abs(sin(iTime * .2)) * .05 + .95)\n    //if (color < 1.0)\n    {\n        color = 1.0 - color;\n    }\n    \n    else\n    {\n        color = 0.0;\n    }\n    \n    return vec4(\n        color + (abs(vn.x) * abs(sin(iTime)) * .2),\n        color + (abs(vn.y) * abs(cos(iTime)) * .1),\n        color + (abs(vn.x * vn.y) * .1),\n        1.0\n    );\n\n}\n\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\n// High-Level Entry\nvec4 ct_main(\n    in ct_plane2d plane,\n    in vec2 c\n){\n    \n    const int n = CT_N;\n    float scale = 1.0;\n    \n    float my_time = 0.0;\n    \n    float r = 0.0;\n    \n    for (int x = 0; x < n; ++x)\n    {\n        int y = 0;\n        float xr = float(x) / float(n);\n        float angle = xr * 6.28 + abs(cos(my_time * .1)) * 1.0;\n        \n        g_vfp[x] = ct_vfpoint(\n            vec2(cos(angle) * r, sin(angle) * r), \n            -1.0\n        );\n    }\n    \n    if (iMouse.z > 0.0)\n    {\n        vec2 cmx = ct_plane2d_project(plane, vec2(iMouse));\n        vec2 cm = vec2(0.0, sin(iTime * 3.0) * .4);\n        g_vfp[n] = ct_vfpoint(\n            cm, \n            1.5\n        );\n    }\n    \n    \n    vec2 rc = rotate(c, iTime);\n\n    \n    return ct_vpixel(rc, rc, 128, 2.0);\n}\n\n\n// Raw Entry.\nvoid mainImage(\n  \tout vec4 fragColor, \n\tin vec2 fragCoord\n){\n    vec3 vpcircle = vec3(\n        0, \n        0.0, \n        .01 + abs(sin(iTime * .03)) * 100.0\n    );\n    \n    ct_plane2d plane = ct_plane2d_create(\n        ct_axes_from_radius(vpcircle)\n    );\n    \n    vec2 c = ct_plane2d_project(plane, fragCoord);\n    \n    // Exec...\n    vec4 color = ct_main(plane, c);\n    \n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltycRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[277, 277, 329, 329, 489], [596, 596, 648, 648, 1337], [1340, 1340, 1402, 1402, 1510], [1648, 1711, 1766, 1766, 2215], [2218, 2218, 2271, 2271, 2373], [2376, 2376, 2414, 2414, 2487], [2490, 2516, 2596, 2596, 3950], [3953, 3953, 3983, 3983, 4067], [4069, 4089, 4144, 4144, 4859], [4862, 4876, 4937, 4937, 5274]], "test": "ok"}
{"id": "ltyyWR", "name": "Zeta Iteration", "author": "Justaway", "description": "Zeta function iterated on itself like a fractal.", "tags": ["fractalzeta"], "likes": 1, "viewed": 95, "published": "Public", "date": "1535679092", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define N 7\n#define E 2.71828\n#define PI 3.14159\n\n#if (N == 5)\nconst float[N] ek = float[N](31.0, 26.0, 16.0, 6.0, 1.0);\n#endif\n#if (N == 6)\nconst float[N] ek = float[N](63.000000,57.000000,42.000000,22.000000,7.000000,1.000000);\n#endif\n#if (N == 7)\nconst float[N] ek = float[N](127.000000,120.000000,99.000000,64.000000,29.000000,8.000000,1.000000);\n#endif\n\nvec2 cpow(vec2 z1, vec2 z2)\n{\n\tfloat a2b2 = z1.x * z1.x + z1.y * z1.y;\n\tfloat t1 = pow(a2b2, z2.x / 2.0) * exp(-z2.y * atan(z1.y, z1.x));\n\tfloat t2 = z2.x * atan(z1.y, z1.x) + 0.5 * z2.y * log(a2b2);\n\treturn vec2(t1 * cos(t2), t1 * sin(t2));\n}\n\nvec2 cexp(vec2 z)\n{\n    return cpow(vec2(E, 0.0), z);\n}\n\nvec2 cdiv(vec2 z1, vec2 z2)\n{\n\treturn z1 * mat2(z2, -z2.y, z2.x) / dot(z2, z2);\n}\n\nvec2 cprod(vec2 z1, vec2 z2)\n{\n\treturn vec2(\n\t\tz1.x * z2.x - z1.y * z2.y,\n\t\tz1.x * z2.y + z1.y * z2.x);\n}\n\nvec2 alt(int x)\n{\n\tfloat[2] tbl = float[2](1.0,-1.0);\n\treturn vec2(tbl[int(mod(float(x),2.0))],0.0);\n}\n    \nvec2 zeta(vec2 s)\n{\n\tvec2 sum1 = vec2(0.0);\n\tvec2 sum2 = vec2(0.0);\n\tvec2 k;\n\tfor(int i = 1; i <= N; i++)\n\t{\n\t\tk = vec2(float(i), 0.0);\n\t\tsum1 += cdiv(alt(i - 1), cpow(k , s));\n\t}\n\tfor(int i = N + 1; i <= 2 * N; i++)\n\t{\n\t\tk = vec2(float(i), 0.0);\n\t\tsum2 += cdiv(cprod(alt(i - 1), vec2(ek[i - N - 1],0.0)), cpow(k,s));\n\t}\n    sum2 = cdiv(sum2, vec2(pow(2.0, float(N)), 0.0));\n    return cdiv(sum1 + sum2,vec2(1.0, 0.0) - cpow(vec2(2.0 ,0.0), vec2(1.0, 0.0) - s));\n\treturn vec2(0.0);\n}\n\nvec2 iterate(vec2 s)\n{\n    vec2 z = s;\n    for(int i = 0; i < 32; i++)\n    {\n        z = zeta(z);\n    }\n    return z;\n}\n\nvec4 gradient(float theta)\n{\n    vec4 color = vec4(0.0);\n    color += vec4(1.0, 0.0, 0.0, 0.0) * smoothstep(0.0, 1.0, clamp(1.0 - abs((2.0 * PI-theta) * PI / 3.0), 0.0, 1.0));\n    color += vec4(1.0, 0.0, 0.0, 0.0) * smoothstep(0.0, 1.0, clamp(1.0 - abs(-theta * PI / 3.0), 0.0, 1.0));\n    color += vec4(1.0, 1.0, 0.0, 0.0) * smoothstep(0.0, 1.0, clamp(1.0 - abs((PI / 3.0 - theta) * PI / 3.0), 0.0, 1.0));\n    color += vec4(0.0, 1.0, 0.0, 0.0) * smoothstep(0.0, 1.0, clamp(1.0 - abs((PI * 2.0 / 3.0 - theta) * PI / 3.0), 0.0, 1.0));\n    color += vec4(0.0, 1.0, 1.0, 0.0) * smoothstep(0.0, 1.0, clamp(1.0 - abs((PI - theta) * PI / 3.0), 0.0, 1.0));\n    color += vec4(0.0, 0.0, 1.0, 0.0) * smoothstep(0.0, 1.0, clamp(1.0 - abs((PI * 4.0 / 3.0 - theta) * PI / 3.0), 0.0, 1.0));\n    color += vec4(1.0, 0.0, 1.0, 0.0) * smoothstep(0.0, 1.0, clamp(1.0 - abs((PI * 5.0 / 3.0 - theta) * PI / 3.0), 0.0, 1.0));\n    return color*(fract(theta / PI * 10.0) / 2.0 + 0.5);\n}\n\nvec4 plotDomain(vec2 z)\n{\n    float theta = mod(atan(z.y, z.x), 2.0 * PI);\n    return gradient(theta) * (fract(log2(length(z))) / 2.0 + 0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ratio = iResolution.x/iResolution.y;\n    vec2 uv = vec2(\n\t\t(fragCoord.x-iResolution.x/2.0)/iResolution.x*ratio,\n\t\t(fragCoord.y-iResolution.y/2.0)/iResolution.y);\n    fragColor = plotDomain(iterate(uv * 20.0 + vec2(0.0, iTime * 4.0)));\n    //fragColor = plotDomain(iterate(uv));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltyyWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[359, 359, 388, 388, 602], [604, 604, 623, 623, 659], [661, 661, 690, 690, 742], [744, 744, 774, 774, 849], [959, 959, 978, 978, 1442], [1444, 1444, 1466, 1466, 1563], [1565, 1565, 1593, 1593, 2525], [2527, 2527, 2552, 2552, 2670], [2672, 2672, 2729, 2729, 3019]], "test": "ok"}
{"id": "Md3Bzj", "name": "rain test tutorial", "author": "littlemilk", "description": "test rain on default bg", "tags": ["rain"], "likes": 3, "viewed": 102, "published": "Public", "date": "1533174615", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n\n\nvec2 Rain( vec2 uv, float t) {\n\n    t *= 40.;\n    \n    //augment square to rect\n   \tvec2 a = vec2(3., 1.);\n    vec2 st = uv*a;\n    \n    //get id of each column\n    vec2 id = floor(st);\n    \n    st.y += t*.22;\n    \n    //psuedo-random offset grid y\n    float n = fract(sin(id.x*76.12)*768.32);\n    st.y += n;\n    uv.y += n;\n    id = floor(st);\n    st = fract(st)-.5;\n    \n    t += fract(sin(id.x*76.12+id.y*1234.5)*768.32)*6.28;\n    float y = -sin(t + sin(t+sin(t)*.5))*.4;\n    vec2 p1 = vec2(0., y);\n    vec2 o1 = (st-p1)/a;\n    float d = length(o1);\n    \n   \tfloat m1 = smoothstep(.07, .0, d);\n    \n    vec2 o2 = (fract(uv*a.x*vec2(1., 2.)) -.5)/vec2(1., 2.);\n    d = length(o2);\n    \n    float m2 = smoothstep(.3*(.5 - st.y), .0, d)*smoothstep(-.1, .1, st.y-p1.y);\n    //if(st.x > .46 || st.y > .49) m1 = 1.;\n    \n\treturn vec2(m1*o1*33.+m2*o2*10.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float t = iTime*.01;\n\tvec2 rainDistort = Rain(uv*.99, t)*1.;\n    rainDistort -= Rain(uv*.2, t)*.8;\n    \n    uv.x += sin(uv.y*50.)*.02;\n\tuv.y += sin(uv.x*170.)*.005;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+vec3(uv-rainDistort, uv.x)+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Md3Bzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[4, 4, 34, 34, 856], [859, 859, 916, 966, 1402]], "test": "ok"}
{"id": "Md3fRj", "name": "rain tut", "author": "littlemilk", "description": "rain distort shader", "tags": ["tutorial", "rain"], "likes": 4, "viewed": 165, "published": "Public", "date": "1533174628", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n\n\nvec2 Rain( vec2 uv, float t) {\n\n    uv *= 3.;\n    t *= 40.;\n    \n    //augment square to rect\n   \tvec2 a = vec2(3., 1.);\n    vec2 st = uv*a;\n    \n    //get id of each column\n    vec2 id = floor(st);\n    \n    st.y += t*.22;\n    \n    //psuedo-random offset grid y\n    float n = fract(sin(id.x*76.12)*768.32);\n    st.y += n;\n    uv.y += n;\n    id = floor(st);\n    st = fract(st)-.5;\n    \n    t += fract(sin(id.x*76.12+id.y*1234.5)*768.32)*6.28;\n    float y = -sin(t + sin(t+sin(t)*.5))*.4;\n    vec2 p1 = vec2(0., y);\n    vec2 o1 = (st-p1)/a;\n    float d = length(o1);\n    \n   \tfloat m1 = smoothstep(.07, .0, d);\n    \n    vec2 o2 = (fract(uv*a.x*vec2(1., 2.)) -.5)/vec2(1., 2.);\n    d = length(o2);\n    \n    float m2 = smoothstep(.3*(.5 - st.y), .0, d)*smoothstep(-.1, .1, st.y-p1.y);\n    //if(st.x > .46 || st.y > .49) m1 = 1.;\n    \n\treturn vec2(m1*o1*33.+m2*o2*10.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    float t = iTime* .05+m.x;\n\tvec2 rainDistort = Rain(uv, t);    \n\n    \n    vec3 col = vec3(uv-rainDistort, 0.);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Md3fRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[4, 4, 34, 34, 870], [873, 873, 930, 980, 1273]], "test": "ok"}
{"id": "MdVfz1", "name": "First shader toy", "author": "raphaelk", "description": "My first shader", "tags": ["first"], "likes": 1, "viewed": 50, "published": "Public", "date": "1535102078", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = fragCoord.xy;\n    xy.x = xy.x / iResolution.x;\n    xy.y = xy.y / iResolution.y;\n    vec4 finalColor = vec4(0, 0, 0, 1.0);\n    finalColor.r = abs(sin(iTime + xy.y));\n    finalColor.g = abs(sin(iTime + xy.y));\n    finalColor.b = abs(sin(iTime + xy.y));\n    fragColor = finalColor;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdVfz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 352]], "test": "ok"}
{"id": "Ml3cDS", "name": "Tiny data.path", "author": "yx", "description": "I just keep coming back to these Ikeda-style patterns", "tags": ["pattern", "tiny", "ikeda"], "likes": 2, "viewed": 450, "published": "Public API", "date": "1533837075", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 c,vec2 f){\n    vec2 u=abs(f/iResolution.xy-.5);u.x*=3.;\n    c+=mix(\n        .3-.3*pow(u.x/length(u),5.),\n        step(.5,fract(sin(dot(floor(vec2(2./u.x,64./u.x*u.y)),vec2(12.13,4.47)))*12563.5+iTime)),\n        u.x>u.y\n    )*max(u.x,u.y)*2.;}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml3cDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 266]], "test": "ok"}
{"id": "Ml3cRf", "name": "Dancing Grid", "author": "TanayStyle", "description": "Grid stuff", "tags": ["grid"], "likes": 1, "viewed": 96, "published": "Public", "date": "1533415913", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sin01(float x) {\n\treturn (sin(x)+1.)/2.;\n}\nfloat cos01(float x) {\n\treturn (cos(x)+1.)/2.;\n}\n\n/*\nvec2 randVec01(vec2 p) {\n    vec3 a = fract(vec3(sin(p.x), cos(p.y), cos(p.x)));\n    a += dot(a, a+34.45);\n    return smoothstep(0., 1., fract(vec2(a.x * a.y, a.y * a.z)));\n} */\n\nvec2 randVec01(vec2 p) {\n    vec3 a = fract(vec3(sin(p.x), cos(p.y), cos(p.x)));\n    a += dot(a, a+ (sin01(iTime) - 1.5));\n    return smoothstep(0., 1., fract(vec2(a.x * a.y, a.y * a.z)));\n}\n\nfloat manDist(vec2 from, vec2 to) {\n    return abs(from.x - to.x) + abs(from.y - to.y);\n}\n\nfloat euclDist(vec2 from, vec2 to) {\n\treturn length(from - to);\n}\n\nfloat circ(vec2 uv, vec2 pos, float radius) {\n    float t = (iTime + uv.x);\n    float f01 = cos01(t * 5.);\n    \n    float dist = f01 * euclDist(uv, pos);\n    dist += (1. - f01) * manDist(uv, pos);\n    return smoothstep(radius, 0., dist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Adjust coordinates so 0,0 is in center\n    //vec2 uv = fragCoord/iResolution.xy; \n    vec2 uv =(fragCoord - iResolution.xy/2.)/iResolution.xy; \n    float aspectRatio = iResolution.x / iResolution.y;\n\tuv.x *= aspectRatio;\n    \n    vec3 col = vec3(0.);\n    \n    \n    // Create grid\n    float gridSize = 4.;\n    vec2 gridCoord = floor(uv * gridSize) / gridSize;\n    \n    // Get parts within grid cell\n    float cellRadius = .5 / gridSize;\n    vec2 cellCenter = gridCoord + cellRadius;\n    float inGrid = circ(uv, cellCenter, cellRadius);\n    col.rb = vec2(inGrid); //* (sin01(uv.x + iTime * 2.) + .4);\n    \n    // Get random position in grid\n    vec2 pos = randVec01(vec2(inGrid));\n    //col = vec3(pos,1.);//vec3(circ(uv, pos, 0.05));\n    col.rb -= pos;\n        \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml3cRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 48], [49, 49, 71, 71, 97], [281, 281, 305, 305, 471], [473, 473, 508, 508, 562], [564, 564, 600, 600, 629], [631, 631, 676, 676, 870], [872, 872, 929, 1018, 1754]], "test": "ok"}
{"id": "Ml3cWs", "name": "glowing particles", "author": "aferriss", "description": "Trying a particles system in just one frag shader", "tags": ["particles", "aa", "smoothstep", "poof", "softedge"], "likes": 16, "viewed": 1461, "published": "Public API", "date": "1534624451", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int nParticles = 150;\nconst float size = 0.001;\nconst float softness = 150.0;\nconst vec4 bgColor = vec4(0.0,0.0,0.0,1.0);\n\nfloat random (int i){\n return fract(sin(float(i)*43.0)*4790.234);   \n}\n\nfloat softEdge(float edge, float amt){\n    return clamp(1.0 / (clamp(edge, 1.0/amt, 1.0)*amt), 0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 tc = uv;\n    float aspect = iResolution.x / iResolution.y;\n\tuv.x *= aspect;\n    \n    fragColor = bgColor;\n    \n    //vec4 tex = texture(iChannel0, tc);\n    float np = float(nParticles);\n    for(int i = 0; i< nParticles; i++){\n        vec2 tc = uv;\n        \n        float r = random(i);\n        float r2 = random(i+nParticles);\n        float r3 = random(i+nParticles*2);\n \n        tc.x -= sin(iTime*1.125 + r*30.0)*r;\n        tc.y -= cos(iTime*1.125 + r*40.0)*r2*0.5;\n                    \n        float l = length(tc - vec2(aspect*0.5, 0.5));// - r*size;\n        tc -= vec2(aspect*0.5, 0.5)*1.0;\n        tc = tc * 2.0 - 1.0;\n        tc *= 1.0;\n        tc = tc * 0.5 + 0.5;\n        \n        vec4 orb = vec4(r, r2, r3, softEdge(l, softness));\n        orb.rgb *= 1.5; // boost it\n        \n        fragColor = mix(fragColor, orb, orb.a);\n    }\n    //fragColor = mix(tex, fragColor, fragColor.a);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml3cWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[129, 129, 150, 150, 199], [201, 201, 239, 239, 305], [307, 307, 364, 364, 1307]], "test": "ok"}
{"id": "Ml3yRj", "name": "slimy vignette", "author": "pixlpa", "description": "Constantly changing vignette shapes", "tags": ["noise", "animated", "mask"], "likes": 2, "viewed": 226, "published": "Public", "date": "1533157021", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// Value Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/lsf3WH\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat buildSDF(vec2 st){\n    vec2 aspect = vec2(iResolution.x/iResolution.y,1.);    \n    float center = length((st-vec2(0.5))*aspect);\n    float noisevalue = noise((st+vec2(0.,iTime*0.85))*5.*aspect) + noise((st+vec2(0.,iTime*0.253))*9.*aspect)*0.25;\n    return smoothstep(1.3,0.,center)*0.1+noisevalue*-0.4+(st.y-0.5)*0.1;\n}\n\nfloat lighter (vec2 st){\n    vec3 lightpos = vec3(1.,1.,0.8);\n    float hscale = 0.1;\n    float nscale = 2.;\n    vec2 aspect = vec2(iResolution.x/iResolution.y,1.);\n    vec2 offs = st+vec2(2.,-2.)/iResolution.xy;\n\tfloat map0 = buildSDF(st);\n    float map1 = buildSDF(vec2(offs.x,st.y))-map0;\n    float map2 = buildSDF(vec2(st.x,offs.y))-map0;\n\tvec3 shape = normalize(cross(vec3(1.,0.,map1),vec3(0.,1.,map2)));\n\tvec3 light = normalize(lightpos-vec3((st*vec2(2.)-vec2(1.))*vec2(1,aspect),(map0/hscale)*-nscale));\n\tfloat greyval = clamp(dot(light,shape),0.,1.);\n    return greyval;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 suv = uv*2.-vec2(1.);\n    vec2 aspect = vec2(iResolution.x/iResolution.y,1.);\n    \n    float center = length((uv-vec2(0.5))*aspect);\n    float noisevalue = noise((uv+vec2(0.,iTime*0.25))*5.*aspect) + noise((uv+vec2(0.,iTime*0.253))*10.*aspect)*0.25;\n    float sdf = smoothstep(1.3,0.,center)+noisevalue*-0.4+uv.y*0.5;\n    vec2 noisedist = vec2(noise(uv*15.*aspect),noise((uv+vec2(23.))*15.*aspect));\n    // Output to screen\n    float mask = smoothstep(0.5,0.501,fract(iTime*0.25+sdf*0.5));\n    vec4 zoomer1 = texture(iChannel0,uv+noisedist*0.01*center);\n    fragColor = vec4(mix(zoomer1.rgb,vec3(0.2,0.8,0.3)*lighter(uv),mask),1.0);\n}", "image_inputs": [{"id": "4sf3zn", "previewfilepath": "/presets/webcam.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/webcam.png", "ctype": "webcam"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml3yRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 161], [163, 245, 267, 267, 671], [673, 673, 697, 697, 998], [1000, 1000, 1024, 1024, 1580], [1582, 1582, 1639, 1639, 2323]], "test": "error"}
{"id": "MlccDf", "name": " The spice trade", "author": "Plento", "description": "(Desert Planet) A simple sand dune render which got me thinking about my favorite book. Soon I'll learn how to make the dunes look more random. ", "tags": ["raymarch", "desert", "dune"], "likes": 15, "viewed": 738, "published": "Public API", "date": "1534449348", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n// My original dunes. simple \n/*\nfloat map(vec3 rp)\n{\n   float res;\n   \n   // this manipulates the space to make the simple shape of dunes\n   // its also phase shifting the wave by time to give illusion of movement\n   rp.y += sin(rp.z*2.0 + iTime * 1.5 ) * 0.3;\n   rp.y += sin(rp.x*2.0 ) * 0.2;\n    \n   // a simple plane whose position is the within this wavy space.\n   return vec3(rp - vec3(0.0, -1.0, 0.0)).y;\n}\n*/\n\n\nfloat map(vec3 p){\n    \n    p.z += iTime;\n    float h = dot(sin(p - cos(p.yzx*1.3)), vec3(.13));\n    h += dot(sin(p*2. - cos(p.yzx*1.3*2.)), vec3(.1/2.));\n    return p.y + 1. + h;     \n}\n\n\n\nvec3 getNormal(vec3 p)\n{\n    vec2 e = vec2(0.0035, -0.0035); \n    return normalize(\n        e.xyy * map(p + e.xyy) + \n        e.yyx * map(p + e.yyx) + \n        e.yxy * map(p + e.yxy) + \n        e.xxx * map(p + e.xxx));\n}\n\nvec3 col(vec3 ro, vec3 rd, vec3 norm, float md, float t)\n{   \n    // light direction\n    vec3 ld = ro + vec3(-1.0, -1.0, 1.21); \n    \n    // basic diffuse / specular \n    float diff = max(dot(norm, ld), 0.0);\n    float spec = pow(max( dot( reflect(-ld, norm), -rd ), 0.0 ), 7.0);\n    \n    vec3 objCol = vec3(0.3, 0.3,0.3);\n    vec3 glowCol = vec3(1.0, 0.4, 0.0); \n    vec3 sceneCol;\n    \n    //main color\n    sceneCol = (objCol*(diff - 0.015 * 0.5) + vec3(1.0, 0.6, 0.2)*spec*0.15) ;\n    \n    //fog\n    sceneCol =  mix( sceneCol, vec3(0.55,0.9,0.9), 1.0 - exp( -0.00026*t*t*t ) );\n    \n    // Kinda makes it look like theres alot of dust in the air. kinda \n    float sand = smoothstep(0.12, 1.15, 0.008 / md * t) * 0.3;\n    sceneCol += glowCol * sand;\n    \n    return sceneCol;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y; \n  \n    // ray origin and direction\n    vec3 ro = vec3(0.0, 0.0, 0.0); \n    vec3 rd = normalize(vec3(uv,2.0));\n    \n    float t = 0.0; \n   \n    float minDist = 999.0;\n    \n    // raymarch\n    for (int i = 0; i < 100; i++) \n    {\n        float d = map(ro + rd*t);\n        \n        minDist = min(minDist, d);\n        \n        if(abs(d)<0.01)\n        {\n            minDist = 0.1;\n            break;  \n        }\n        if(t>25.0) \n        {\n            minDist = min(minDist, d);\n            t = 80.0;\n            break;\n        }\n        \n        t += d * 0.7;\n    }\n    \n    \n    vec3 norm = getNormal(ro + rd * t);\n    \n    // color the scene\n    vec3 sceneColor = col(ro, rd, norm, minDist, t);\n    \n    // crappy sun \n    sceneColor += smoothstep(0.16, 0.001, length(uv - vec2(-1.0, 0.5)))*0.5;\n    \n    fragColor = vec4(sqrt(clamp(sceneColor, 0.0, 1.0)), 1.0);\n \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlccDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[421, 421, 439, 439, 607], [611, 611, 635, 635, 831], [833, 833, 891, 917, 1617], [1619, 1619, 1676, 1676, 2619]], "test": "ok"}
{"id": "MlccRX", "name": "Checker Eye", "author": "momoro", "description": "Rotating pink noise grid (inspired by Ash Thorp)", "tags": ["bookofshaders"], "likes": 8, "viewed": 522, "published": "Public API", "date": "1533396700", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nmat2 rotate(float angle) {\n    return mat2(cos(angle), -sin(angle),\n                sin(angle), cos(angle));\n    \t\n\n}\n\nfloat sin01(float n) {\n    return sin(n)/2.+.5;\n}\n\n#define PI 3.141592654\n#define RINGS 180./2.\n#define COLS 200./2.\n#define BLACK .02\n#define p 3.\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //vec2 fragCoord = gl_FragCoord.xy;\n    //vec2 iResolution = u_resolution;\n    //float iTime = u_time;\n    \n    vec2 st = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    \n    float ringRotation = random(vec2(ceil(pow(1.0 - length(st), p) * RINGS))) - .5;\n    ringRotation *=  iTime/1.5;\n\tst = (rotate(ringRotation)) * st;\n\n    \n    // Set up circular coordinate system\n    float distance = length(st);\n\tfloat angle = atan(st.x, st.y) + PI;\n    angle = angle / (PI * 2.);\n    \n    \n    // x = distance\n    // y = angle\n    vec2 uv = vec2(distance, angle);\n\n\n    vec2 uvGrid;\n    float ix = 1.-uv.x;\n    uvGrid.x = ceil(pow(ix, p) * RINGS);\n    uvGrid.y = ceil(pow(uv.y, p) * COLS );\n\n    \n\n    float f = random(vec2(uvGrid));\n    \n    // Add padding between rings\n    if(fract(pow(ix, p)* RINGS) < 0.340) {\n        f = BLACK;\n    }\n    \n    // Add padding between columns\n    if(fract(pow(uv.y, p) * COLS) < 0.032) {\n        f = BLACK;\n    }\n    \n    // Black Rings\n    float r1 = 2.684;\n    if(uvGrid.x > RINGS/r1 && uvGrid.x < RINGS/(r1-0.152)) {\n        f = BLACK;\n    }\n    float r2 = r1 * 0.688;\n    if(uvGrid.x > RINGS/r2 && uvGrid.x < RINGS/(r2-0.040)) {\n        f = BLACK;\n    }\n    float r3 = r2 * 0.848;\n    if(uvGrid.x > RINGS/r3 && uvGrid.x < RINGS/(r3-0.016)) {\n        f = BLACK;\n    }\n\n    \n    // Cut it off\n    if(length(st) > 0.445 || length(st) < .05) {\n        f  = BLACK;\n    }\n\t// Drop some to black\n    if(f < .05) {\n        f = BLACK;\n    }\n    \n    \n    // Assign blue\n    vec3 color;\n    \n    if(f > .9) {\n        color = vec3(1.);\n    }\n    else if(f > .75)  {\n        color = vec3(0.920,0.248,0.709);\n    } else if(f >.6) {\n        color = vec3(0.302,0.065,0.475);\n    } else if(f < .4 && f > BLACK) {\n        color = vec3(0.064,0.048,0.435);\n    } else\n    {\n   \t\tcolor = vec3(0.875,0.021,0.561) * f;\n    }\n    \n    float c = sin01(uvGrid.x);\n   // color = vec3(c, .5, .5);\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlccRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 136], [138, 138, 164, 164, 255], [257, 257, 279, 279, 306], [407, 407, 464, 571, 2413]], "test": "ok"}
{"id": "Mlccz2", "name": "A shiny pool", "author": "pixlpa", "description": "Evolving gradient noise bump map", "tags": ["noise", "animated", "specular"], "likes": 15, "viewed": 370, "published": "Public", "date": "1533200841", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\nvec3 random3(vec3 st){\n    st = vec3( dot(st,vec3(17.1,61.7,19.73)),\n              dot(st,vec3(69.43,33.3,93.8)),\n             dot(st,vec3(74.31,36.1,83.9)));\n    return -1.0 + 2.0*fract(sin(st)*437581.5453123);\n}\n\n// Value Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/lsf3WH\nfloat noise(vec2 st,float travel) {\n    st += vec2(0.,0.);\n    vec3 i = floor(vec3(st,travel));\n    vec3 f = fract(vec3(st,travel));\n    \n\n    vec3 u = smoothstep(0.,1.,f);\n\n    float base00 = dot( random3(i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) );\n    float base10 = dot( random3(i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) );\n    float base01 = dot( random3(i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) );\n    float base11 = dot( random3(i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) );\n    float top00 = dot( random3(i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) );\n    float top10 = dot( random3(i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) );\n    float top01 = dot( random3(i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) );\n    float top11 = dot( random3(i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) );\n    float base = mix(mix(base00,base10,u.x),mix(base01,base11,u.x),u.y);\n    float top = mix(mix(top00,top10,u.x),mix(top01,top11,u.x),u.y);\n    return mix(base,top,u.z);\n    \n}\n\nfloat bumpFunc(vec2 st){\n    vec2 aspect = vec2(iResolution.x/iResolution.y,1.);\n    float center = smoothstep(1.,0.,length(st));\n    vec2 noisedist = vec2(noise((st+0.3)*2.,10.),noise((st+vec2(13.1238,11.8837))*2.,iTime*0.1));\n    noisedist += vec2(noise((st)*8.,3.),noise((st+vec2(13.1238,11.8837))*8.,iTime*0.1+28.))*0.1;\n    float noisevalue = noise((st+noisedist*0.07+vec2(0.,iTime*0.05)*5.),iTime*2.);\n    noisevalue += noise((st+noisedist*0.35+vec2(0.,iTime*0.05))*25.,iTime*0.5)*0.25;\n    noisevalue += noise(st*5.5,iTime*0.15)*0.15;\n    return center*0.+smoothstep(-1.25,1.25,noisevalue);\n}\n\n//LIGHTING and BUMP section adapted from https://www.shadertoy.com/view/4l2XWK\n\nvec3 bumpMap(vec3 st){\n    vec3 sp = st;\n    vec2 eps = vec2(4./iResolution.y, 0.);\n    float f = bumpFunc(sp.xy); // Sample value multiplied by the amplitude.\n    float fx = bumpFunc(sp.xy-eps.xy); // Same for the nearby sample in the X-direction.\n    float fy = bumpFunc(sp.xy-eps.yx); // Same for the nearby sample in the Y-direction.\n\n\tconst float bumpFactor = 0.1;\n    fx = (fx-f)/eps.x; // Change in X\n    fy = (fy-f)/eps.x; // Change in Y.\n    return vec3(fx,fy,0.)*bumpFactor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n  \n\n    // VECTOR SETUP - surface postion, ray origin, unit direction vector, and light postion.\n    vec3 sp = vec3(uv, 0); // Surface position.\n    vec3 rd = normalize(vec3(uv, 1.)); // Direction vector from the origin to the screen plane.\n    vec3 lp = vec3(iMouse.xy/iResolution.xy*2.-vec2(1.), -0.85); // Light position\n\tvec3 sn = vec3(0., 0., -1); // Plane normal. Z pointing toward the viewer.\n    \n    // Using the gradient vector, \"vec3(fx, fy, 0),\" to perturb the XY plane normal \",vec3(0, 0, -1).\" \n    sn = normalize( sn + bumpMap(sp));           \n   \n    \n    // LIGHTING\n\t// Determine the light direction vector, calculate its distance, then normalize it.\n\tvec3 ld = lp - sp;\n\tfloat lDist = max(length(ld), 0.001);\n\tld /= lDist;  \n    float atten = 1./(1.0 + lDist*lDist*0.05);\n\n\t// Diffuse value.\n\tfloat diff = max(dot(sn, ld), 0.);  \n    // Specular highlighting.\n    float spec = pow(max(dot( reflect(-ld, sn), -rd), 0.), 31.);\n    \n    //reflections\n    vec3 ref = reflect( vec3(sp.xy,bumpFunc(sp.xy)*0.8), sn );\n  \tfloat m = 2. * sqrt(pow( ref.x, 2. ) +\n    \t\t\tpow( ref.y, 2. ) +\n    \t\t\tpow( ref.z + 1., 2. ));\n  \tvec2 tcx = ref.xy / m + .5;\n    vec3 env_color = texture(iChannel0,tcx).rgb;\n    float grain = noise(uv.xy*10.,0.1);\n    vec3 color = diff*0.35*vec3(0.65,0.8,0.8)+vec3(0.25,0.89,0.9)*spec*1.75+pow(env_color,vec3(2.9))*0.65+vec3(grain*0.1);\n    fragColor = vec4(color,1.);\n    //fragColor = vec4(vec3(bumpFunc(sp.xy)),1.);\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mlccz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 161], [163, 163, 185, 185, 376], [378, 460, 495, 495, 1463], [1465, 1465, 1489, 1489, 2064], [2146, 2146, 2168, 2168, 2632], [2634, 2634, 2691, 2691, 4205]], "test": "error"}
{"id": "MlcyRf", "name": "Wibble-Wobble", "author": "jameswilddev", "description": "my brain", "tags": ["ow"], "likes": 2, "viewed": 69, "published": "Public", "date": "1533409908", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sum = 0.0;\nfloat frequency = 1.0;\nvec2 surfacePosition;\n\nvoid harmonic(float prime) {\n\tsum += sin((surfacePosition.x + surfacePosition.y) * frequency) * sin(iTime * 50.0 / prime);\n\tfrequency++;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    surfacePosition = fragCoord * 15.0 / iResolution.xy;\n    \n\tharmonic(2.0);\n\tharmonic(3.0);\n\tharmonic(5.0);\n\tharmonic(7.0);\n\tharmonic(11.0);\n\tharmonic(13.0);\n\tharmonic(17.0);\n\tharmonic(19.0);\n\tharmonic(23.0);\n\tharmonic(29.0);\n\tharmonic(31.0);\n\tharmonic(37.0);\n\tharmonic(41.0);\n\tharmonic(53.0);\n\tharmonic(59.0);\n\tharmonic(61.0);\n\tharmonic(67.0);\n\tharmonic(71.0);\n\tharmonic(73.0);\n\tharmonic(79.0);\n\tharmonic(83.0);\n\tharmonic(89.0);\n\tharmonic(97.0);\n    \n    sum += surfacePosition.y * 10.0;\n\tsum = sin(sum);\n\n\tfragColor = vec4(sum, sum, sum, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlcyRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[63, 63, 91, 91, 201], [203, 203, 260, 260, 810]], "test": "ok"}
{"id": "Mlcyzs", "name": "Phase shifted noise", "author": "fdevant", "description": "makes optical illusions happen?\nIt does somewhat look like my migraine auras.\nSeeing it in my phone, if I rotate the screen, patterns seem to stay in place :D\nSeeing it from different distances makes different patterns emerge.", "tags": ["noise"], "likes": 6, "viewed": 336, "published": "Public", "date": "1533653065", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Hail Eris!\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nuniform vec2 resolution;\nuniform float time;\n\n\nhighp float rand(vec2 co)\n{\nhighp float a = 12.9898;\nhighp float b = 78.233;\nhighp float c = 43758.5453;\nhighp float dt= dot(co.xy ,vec2(a,b));\nhighp float sn= mod(dt,3.14159);\nreturn fract((sin(sn) * c)+iTime*(3.0));}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\nvec2 uv= fragCoord.xy / iResolution.xy;\nvec2 st= vec2(uv.x, uv.y );\n\nfragColor = vec4(rand(st),rand(st+1.0),rand(st+2.0),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mlcyzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[377, 377, 433, 433, 562]], "test": "error"}
{"id": "MlGczD", "name": "Julia variations", "author": "BenWheatley", "description": "Julia fractal variant, where the iterative function z=z+c has a time-varying value of n, and mouse clicks determine the c-value.", "tags": ["fractal", "julia"], "likes": 1, "viewed": 64, "published": "Public", "date": "1535318805", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n * \"Julia variations\" by Ben Wheatley - 2018\n * License MIT License\n * Contact: github.com/BenWheatley\n */\n\nconst int LOOP_MAX = 64;\nconst float PI = 3.14159265359;\n\nfloat complexAbs2(vec2 z) {\n    return (z.x*z.x)+(z.y*z.y);\n}\n\nfloat arg(vec2 z) {\n\tfloat x = z.x;\n\tfloat y = z.y;\n    if (x>0.0) {\n\t\treturn atan(y/x);\n    } else if (y>0.0) {\n\t\treturn atan(y/x)+PI;\n    }\n\treturn atan(y/x)-PI;\n}\n\nvec2 complexExponent(vec2 z, float power) {\n    float r = sqrt(complexAbs2(z));\n    float arg = arg(z);\n    \n    float log_z_real = log(r);\n    float log_z_imag = arg;\n    \n    float x_log_real = power * log_z_real;\n    float x_log_imag = power * log_z_imag;\n    \n    float result_r = exp(x_log_real);\n    \n    return result_r*vec2(cos(x_log_imag), sin(x_log_imag));\n}\n\nvec3 rgbFromHue(float hue){\n    vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);\n    vec3 p = abs(fract(hue + K.xyz) * 6.0 - K.www);\n    return 0.75 * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), 0.75);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n\t\n    vec2 offset1 = vec2(1.0, 0.5);\n    float scale = 2.0;\n    \n    vec2 c = vec2(iMouse.x/iResolution.x, iMouse.y/iResolution.y);\n    c -= vec2(0.5, 0.5);\n    c *= 2.0;\n    vec2 z = (uv - offset1)*scale;\n    \n    vec3 rgb = vec3(0.0, 0.0, 0.0);\n    float basic = 0.0;\n    \n    for (int i=0; i<LOOP_MAX; i++) {\n        z = complexExponent(z, 3.0+(2.0*sin(iTime/2.0))) + c;\n        if (complexAbs2(z)>4.0) {\n            basic = float(i)/float(LOOP_MAX);\n\t\t\trgb = rgbFromHue(basic);\n            i = LOOP_MAX;\n            \n        } else if (i==(LOOP_MAX-1)) {\n            rgb = vec3(0, 0, 0);\n        }\n    }\n    \n    // Output to screen\n    fragColor = vec4(rgb, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlGczD.jpg", "access": "shaders20k", "license": "mit", "functions": [[169, 169, 196, 196, 230], [232, 232, 251, 251, 397], [399, 399, 442, 442, 767], [769, 769, 796, 796, 961], [963, 963, 1018, 1068, 1778]], "test": "ok"}
{"id": "MlGyDR", "name": "Fibonacci's Holes", "author": "dr2", "description": "Holy balls... (mouseable)", "tags": ["lighting", "spiral", "fibonacci"], "likes": 5, "viewed": 437, "published": "Public API", "date": "1535705144", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Fibonacci's Holes\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0   // optional antialiasing\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrSphAnDf (vec3 p, float r, float w);\nfloat SmoothMax (float a, float b, float r);\nvec2 Rot2D (vec2 q, float a);\n\nvec3 ltDir;\nfloat tCur, dstFar;\nconst float pi = 3.14159, phi = 1.618034;\n\nfloat SphFib (vec3 v, float n)\n{   // based on iq's version of Keinert et al's Spherical Fibonnacci Mapping code\n  vec4 b;\n  vec3 q;\n  vec2 ff, c;\n  float fk, ddMin, a, z, ni;\n  ni = 1. / n;\n  fk = pow (phi, max (2., floor (log (n * pi * sqrt (5.) * (1. - v.z * v.z)) / log (phi + 1.)))) / sqrt (5.);\n  ff = vec2 (floor (fk + 0.5), floor (fk * phi + 0.5));\n  b = 2. * vec4 (ff * ni, pi * (fract ((ff + 1.) * phi) - (phi - 1.)));\n  c = floor ((mat2 (b.y, - b.x, b.w, - b.z) / (b.y * b.z - b.x * b.w)) *\n     vec2 (atan (v.y, v.x), v.z - (1. - ni)));\n  ddMin = 4.1;\n  for (int s = 0; s < 4; s ++) {\n    a = dot (ff, vec2 (s - 2 * (s / 2), s / 2) + c);\n    z = 1. - (2. * a + 1.) * ni;\n    q = vec3 (sin (2. * pi * fract (phi * a) + vec2 (0.5 * pi, 0.)) * sqrt (1. - z * z), z) - v;\n    ddMin = min (ddMin, dot (q, q));\n  }\n  return sqrt (ddMin);\n}\n\nfloat FibHole (vec3 p)\n{\n  return smoothstep (0.09, 0.1, SphFib (p, 256.));\n}\n\nfloat ObjDf (vec3 p)\n{\n  float d;\n  d = PrSphDf (p, 1.1);\n  if (d < 0.03) {\n    p.yz = Rot2D (p.yz, 0.03 * tCur);\n    d = PrSphAnDf (p, 1., -0.01 + 0.02 * FibHole (normalize (p)));\n    p.xy = Rot2D (p.xy, 0.05 * tCur);\n    d = 0.4 * min (d, PrSphAnDf (p, 1.04, -0.01 + 0.02 * FibHole (normalize (p))));\n    d = min (d, PrSphDf (p, 0.2));\n  }\n  return d;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 150; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = 0; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (0.05, h);\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float dstObj, sh, f;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    if (length (ro) > 0.3) {\n      vn = ObjNf (ro);\n      sh = ObjSShadow (ro, ltDir);\n      col = vec3 (0.5, 0.1, 0.);\n      if (dot (vn, ro) > 0.) col = col * (0.1 + 0.1 * max (dot (vn, - normalize (vec3 (ltDir.xz, 0.).xzy)), 0.) +\n         0.8 * sh * max (dot (vn, ltDir), 0.)) +\n         0.2 * smoothstep (0.8, 0.9, sh) * sh * pow (max (dot (normalize (ltDir - rd), vn), 0.), 64.);\n      else col *= 0.3 + 0.7 * max (dot (rd, normalize (ro)), 0.);\n    } else {\n      col = vec3 (1., 1., 0.6) * (0.3 + 0.7 * max (- dot (rd, normalize (ro)), 0.));\n    }\n  } else {\n    col = vec3 (0., 0., 0.3 * (0.7 + 0.3 * rd.y));\n    rd.yz = Rot2D (rd.yz, 0.03 * tCur);\n    f = FibHole (rd);\n    rd.xy = Rot2D (rd.xy, 0.05 * tCur);\n    f = SmoothMax (f, FibHole (rd), 0.1);\n    col = mix (vec3 (1., 1., 0.5), col, f);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, zmFac;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.02 * tCur;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  ro = vuMat * vec3 (0., 0., -8.);\n  dstFar = 20.;\n  zmFac = 6.5 / (3. - 2. * sin (0.2 * tCur));\n  ltDir = vuMat * normalize (vec3 (1., 2., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 4.;\n#endif  \n  col = vec3 (0.);\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.71 / canvas.y, 0.),\n       0.5 * pi * (a + 0.5)), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (pow (col, vec3 (0.8)), 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrSphAnDf (vec3 p, float r, float w)\n{\n  return abs (length (p) - r) - w;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlGyDR.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[395, 395, 427, 507, 1240], [1242, 1242, 1266, 1266, 1319], [1321, 1321, 1343, 1343, 1676], [1678, 1678, 1711, 1711, 1888], [1890, 1890, 1911, 1911, 2111], [2113, 2113, 2150, 2150, 2384], [2386, 2386, 2421, 2421, 3378], [3380, 3380, 3436, 3436, 4510], [4512, 4512, 4545, 4545, 4572], [4574, 4574, 4618, 4618, 4655], [4657, 4657, 4702, 4702, 4805], [4807, 4807, 4852, 4852, 4890], [4892, 4892, 4922, 4922, 5035]], "test": "error"}
{"id": "MlKcRh", "name": "Distance field fun 2D", "author": "bitblast", "description": "just some fun with 2D distance fields", "tags": ["2d", "distancefield"], "likes": 2, "viewed": 130, "published": "Public", "date": "1535191962", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float logicalVerticalResolution = 600.0;\nconst float DEG2RAD = 0.01745329251;\nconst float TPI = 6.28318530718;\nconst float PI = 3.14159265359;\n\nfloat circle(vec2 pos)\n{\n    return length(pos);\n}\n\nfloat box(vec2 pos, float w, float h)\n{\n    pos = abs(pos) - vec2(w, h);\n    if (pos.x < 0.0 || pos.y < 0.0)\n        return max(pos.x, pos.y);\n    else\n        return length(pos);\n}\n\nfloat unite(float dista, float distb)\n{\n    return min(dista, distb);\n}\n\nfloat invert(float dist)\n{\n    return -dist;\n}\n\nfloat intersect(float dista, float distb)\n{\n    return max(dista, distb);\n}\n\nfloat subtract(float dista, float distb)\n{\n    return intersect(dista, invert(distb));\n}\n\nfloat softunite(float dista, float distb, float rad)\n{\n    if (dista < rad && distb < rad)\n        return rad - length(vec2(dista, distb) - rad);\n    else\n        return min(dista, distb);\n}\n\nvec2 move(vec2 pos, float x, float y)\n{\n    return pos - vec2(x, y);\n}\n\nvec2 rotate(vec2 pos, float degs)\n{\n    float rad = degs * DEG2RAD;\n    return vec2(-sin(rad) * pos.y + cos(rad) * pos.x, sin(rad) * pos.x + cos(rad) * pos.y);\n}\n\nfloat outline(float dist, float width)\n{\n    return abs(dist) - width;\n}\n\nfloat checkers(vec2 pos, float size)\n{\n    vec2 scl = fract(0.5 * pos / size);\n    return ((scl.x >= 0.5) == (scl.y >= 0.5)) ? 1.0 : 0.0;\n}\n\nfloat smpl(vec2 pos, float iTime)\n{\n    float prog = sin(iTime);\n    //prog = 0.25;\n    float shape =  \n        subtract(\n            softunite(\n                softunite(\n                    box(move(pos, 10.0, 0.0), 300.0, 40.0) - 10.0,\n                    box(rotate(pos, prog * 90.0), 100.0, 100.0) - 10.0,\n                    30.0),\n                box(rotate(pos, prog * -90.0), 100.0, 100.0) - 10.0,\n                30.0),\n            circle(pos) - 60.0\n            ) - 5.0;\n    \n    float dist =\n        unite(\n        \tshape,\n            outline(shape - 30.0, 10.0)\n            );\n    return dist;\n}\n\nvec2 pixelSizeEffect(vec2 pos, float size)\n{\n    if (size < 2.0)\n        return pos;\n    return round(pos / size) * size;\n}\n\nfloat boopBoop(float iTime)\n{\n    iTime *= 3.0;\n    iTime = mod(iTime, 8.0);\n    if (iTime >= 2.0)\n        return 0.0;\n    else\n        return 0.5 * (1.0 - cos(TPI * iTime));\n}\n\nfloat quantize(float val, float size)\n{\n    return size * round(val / size);\n}\n\nvec2 distort(vec2 pos, vec2 center, float rad)\n{\n    vec2 diff = pos - center;\n    float len = length(pos - center);\n    return center +(0.5 * (1.0 - cos(clamp(len / rad, 0.0, 1.0) * PI))) * diff;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord * logicalVerticalResolution / iResolution.y\n        - 0.5 * logicalVerticalResolution * vec2(iResolution.x / iResolution.y, 1.0);\n    /*pos += vec2(15.0 * (2.0 + sin(iTime * 0.33)) * sin(pos.y / 20.0 + iTime),\n                15.0 * (2.0 + sin(iTime * 0.43)) * sin(pos.y / 20.0 + iTime));*/\n\t\n    float time = iTime;\n        \n    vec2 center = vec2(-150.0 * sin(time * 20.0), 0.0);\n    float radius = boopBoop(time) * 500.0;\n    //radius = 200.0;\n    pos = distort(pos, center, radius);\n    float positional = 0.5 * (1.0 + sin(pos.x / 10.0 + sin(time) * TPI) * cos(pos.y / 10.0 + time * TPI));\n    float radial = 1.0 - clamp(length(pos - center) / radius / 1.3, 0.0, 1.0);\n    float timed = boopBoop(time);\n    float pixelAdd = 0.4 * timed * radial;\n    //pixelAdd = 0.0;\n    float pixelSize = 1.0 + 50.0 * pixelAdd;\n    pos = pixelSizeEffect(pos, pixelSize);\n    \n    float water = (1.0 - clamp(length(pos - vec2(300.0, 0.0)) / 150.0, 0.0, 1.0)) * (positional - 0.5) * 10.0;\n    float dist = smpl(pos, time) - water;\n        \n    float log2phys = iResolution.y / logicalVerticalResolution / pixelSize;\n    float alpha = clamp(0.5 - dist * log2phys, 0.0, 1.0);\n    float pattern = 1.0;\n    //alpha = dist / 100.0;\n    vec3 col = mix(0.0, 1.0, alpha) * vec3(pattern);\n    //col = vec3(water) / 10.0;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": "4dXGR8", "previewfilepath": "/media/previz/buffer00.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/previz/buffer00.png", "ctype": "buffer"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlKcRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[150, 150, 174, 174, 200], [202, 202, 241, 241, 383], [385, 385, 424, 424, 456], [458, 458, 484, 484, 504], [506, 506, 549, 549, 581], [583, 583, 625, 625, 671], [673, 673, 727, 727, 863], [865, 865, 904, 904, 935], [937, 937, 972, 972, 1098], [1100, 1100, 1140, 1140, 1172], [1174, 1174, 1212, 1212, 1313], [1315, 1315, 1350, 1350, 1923], [1925, 1925, 1969, 1969, 2048], [2050, 2050, 2079, 2079, 2226], [2228, 2228, 2267, 2267, 2306], [2308, 2308, 2356, 2356, 2506], [2508, 2508, 2565, 2565, 3951]], "test": "ok"}
{"id": "MltcDB", "name": "[SH18] Ink Drawing", "author": "lnae", "description": "My entry for the 2018 Shadertoy Competition :)", "tags": ["raymarching", "npr", "human", "sh18", "statue"], "likes": 90, "viewed": 1888, "published": "Public API", "date": "1533958729", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define STEPS 64.\n#define STEPS_SHADOW 32.\n#define PI 3.14159\n#define EPS 0.0001\n#define EPSN 0.001\n#define EPSOUT 0.01\n\nmat2 rot(float a){\n\treturn mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat hash2(vec2 p){\n\treturn fract(12345.6789 * sin(dot(p, vec2(12.345, 67.891))));\n}\n\nfloat hash3(vec3 p){\n\treturn fract(12345.6789 * sin(dot(p, vec3(12.34, 56.78, 91.01))));\n}\n\nfloat smoothmin(float a, float b, float k){\n\tfloat f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\n}\n\nfloat smoothmax(float a, float b, float k){\n\treturn -smoothmin(-a, -b, k);\n}\n\nfloat smoothabs(float p, float k){\n\treturn sqrt(p * p + k * k) - k;\n}\n\nfloat noise2(vec2 p){\n\tvec2 c = floor(p);\n    vec2 f = fract(p);\n    f = f * f * (3. - 2. * f);\n    return mix(mix(hash2(c), hash2(c + vec2(1., 0.)), f.x), mix(hash2(c + vec2(0., 1.)), hash2(c + vec2(1., 1.)), f.x), f.y);\n}\n\nfloat noise3(vec3 p){\n\tvec3 c = floor(p);\n    vec3 f = fract(p);\n    f = f * f * (3. - 2. * f);\n    vec3 o = vec3(1., 0., 0.);\n    return mix(mix(mix(hash3(c + o.yyy), hash3(c + o.xyy), f.x), mix(hash3(c + o.yxy), hash3(c + o.xxy), f.x), f.y),\n               mix(mix(hash3(c + o.yyx), hash3(c + o.xyx), f.x), mix(hash3(c + o.yxx), hash3(c + o.xxx), f.x), f.y), \n               f.z);\n}\n\nfloat fbm2(vec2 p){\n\treturn 0.5 * noise2(p) + 0.25 * noise2(2. * rot(2.) * (p + 1.)) + 0.125 * noise2(4. * rot(4.) * (p + 2.)) + 0.0625 * noise2(8. * rot(6.) * (p + 3.)) + 0.0625 * noise2(16. * rot(8.) * (p + 4.));\n}\n\n\nfloat fbm3(vec3 p){\n\treturn 0.5 * noise3(p) + 0.25 * noise3(2. * (p + 1.)) + 0.125 * noise3(4. * (p + 2.)) + 0.0625 * noise3(8. * (p + 3.)) + 0.0625 * noise3(16. * (p + 4.));\n}\n\nfloat distEllipsoid(vec3 p, vec3 r){\n    float lg = length(p /(r * r));\n\treturn (length(p / r) - 1.) * (length(p / r)) / lg;\n\t//return (length(p / r) - 1.) * (r.x + r.y + r.z) / 3.;//max(max(r.x, r.y), r.z);\n\n}\n\nfloat distScene(vec3 pos, out float colorVariation){\n    pos.xz = rot(1.5 * sin(0.25 * iTime)) * pos.xz;\n    pos.y += 0.35;\n    colorVariation = 0.;\n    \n    //main sphere\n    vec3 p = pos;\n    p.y -= 0.5;\n    float dist = length(p) - 0.13;\n    \n    //hair + back of the head\n    p = pos;\n    p.y -= 0.51;\n    p.z += 0.04;\n    dist = smoothmin(dist, length(p) - 0.14, 0.02);\n    \n    p.yz = rot(0.3) * p.yz;\n    float f = acos(p.z / 0.16);\n    float angle = atan(p.y, p.x);\n    float hair = -100. * (length(p) - 0.16) - noise2(50. * vec2(angle + 0.01 * sin(50. * f), 0.25 * f));\n    colorVariation += smoothstep(0.25, 0.75, hair);\n    dist -= 0.002 * smoothstep(0., 1., 0.5 * hair);\n    \n    p.z += 0.15;\n    float div = 2. * PI / 18.;\n    angle += 0.5 * PI + 0.5 * div;\n    float c = floor((angle) / div);\n    angle = mod(angle, div) - 0.5 * div;\n    float r = length(p);\n    p.x = r * cos(angle);\n    p.y = r * sin(angle);\n    \n    p.xz = rot(1.) * p.xz;\n    p.xy = rot(35. * p.z + 3.5 * hash2(vec2(c))) * p.xy;\n    p.xy = abs(p.xy);\n    float att = 0.3 * p.z * p.z;\n    float distHair = length(p.xy - vec2(0.01 - 1. * att, 0.01 - 1. * att)) - 0.01 + att;\n    distHair = smoothmax(distHair, length(p - vec3(0., 0., -0.06)) - 0.055, 0.02) - 0.02 * noise3(50. * p);\n    dist = smoothmin(dist, distHair, 0.01);\n    if(dist == distHair) colorVariation = 1.;\n    \n    //chin\n    dist = smoothmin(dist, length(pos - vec3(0., 0.3, 0.105)) - 0.01, 0.2);\n    \n    //nose\n    p = pos;\n    p.y -= 0.41;\n    p.z -= 0.135;\n    p.yz = rot(-0.65) * p.yz;\n    dist = smoothmin(dist, distEllipsoid(p, vec3(0.01, 0.035, 0.0075)), 0.04);\n    \n    //neck\n    p = pos;\n    p.z += 0.05;\n    float distNeck = length(p.xz) - 0.05;\n    distNeck = max(distNeck, p.y - 0.4);\n    dist = smoothmin(dist, distNeck, 0.05);\n    \n    //torso\n    p = pos;\n    p.y -= 0.05;\n    dist = smoothmin(dist, length(p) - 0.15, 0.05);\n    \n    //shoulders\n    p = pos;\n    p.x = smoothabs(p.x, 0.01);\n    dist = smoothmin(dist, length(p - vec3(0.15, 0.15, -0.04)) - 0.055, 0.15);\n    \n    //eye sockets\n    p = pos;\n    p.x = smoothabs(p.x, 0.01);\n    p -= vec3(0.05, 0.44, 0.15);\n    dist = smoothmax(dist, -(length(p) - 0.045), 0.02);\n    \n    //brow bone\n    p.z += 0.045;\n    p.y -= 0.055;\n    p.xz = rot(-0.25) * p.xz;\n    p.yz = rot(1.2) * p.yz;\n    p.xy = rot(-8. * (p.x + 0.04)) * p.xy;\n    dist = smoothmin(dist, distEllipsoid(p, vec3(0.03, 0.01, 0.01)), 0.035);\n    \n    //eyebrow\n    p = pos;\n    p.x = abs(p.x) - 0.0725;\n    p.z -= 0.13;\n    p.y -= 0.495;\n    p.xy = rot(-10. * p.x - 0.25) * p.xy;\n    p.x += 0.0275;\n    p.xz = rot(-10. * p.x) * p.xz;\n    float distEyebrow = distEllipsoid(p, vec3(0.025, 0.007, 0.01));\n    p.x -= 0.025;\n    distEyebrow = smoothmin(distEyebrow, distEllipsoid(p, vec3(0.04, 0.005, 0.01)), 0.01);\n    p.y /= 3.;\n    float eyebrow = -100. * (distEyebrow - 0.004) + 0.5 * noise2(400. * p.xy);\n    eyebrow = smoothstep(0.3, 0.7, eyebrow);\n    colorVariation += eyebrow;\n    dist -= 0.001 * eyebrow;\n    \n    //eyes\n    p = pos;\n    p.x = abs(p.x);\n    p -= vec3(0.05, 0.45, 0.095);\n    dist = smoothmin(dist, length(p) - 0.02, 0.01);\n    p.z -= 0.02;\n    p.x -= 0.005;\n    float eyeColor = -50. * (length(p) - 0.025);\n    colorVariation += smoothstep(0.4, 0.6, eyeColor);\n    colorVariation -= smoothstep(0.45, 0.55, -25. * (length(p - vec3(sign(pos.x) * 0.01, -0.0075, 0.)) - 0.025));\n    \n    //eyelids\n    p.x += 0.0045;\n    p.y -= 0.016;\n    p.xy = rot(-20. * p.x + 0.3) * p.xy;\n    p.xz = rot(-20. * p.x) * p.xz;\n    float distEyelids = distEllipsoid(p, vec3(0.035, 0.005, 0.01));\n    float distEyelashes = abs(p.y + 0.003);\n    p.x -= 0.005;\n    distEyelashes = smoothmax(distEyelashes, length(p) - 0.036, 0.01);\n\tdist = smoothmin(dist, distEyelids, 0.005);\n    colorVariation += smoothstep(0.4, 0.6, -60. * (distEyelashes - 0.01) + 0.15 * noise2(600. * p.xy));\n    \n    //cheeks\n    p = pos;\n    p.x = abs(p.x);\n    dist = smoothmin(dist, length(p - vec3(0.05, 0.385, 0.08)) - 0.01, 0.1);\n    \n    //jaw\n    p = pos;\n    p.x = abs(p.x);\n    dist = smoothmin(dist, length(p - vec3(0.03, 0.34, 0.045)) - 0.005, 0.1);\n    \n    //nose part 2\n    p = pos;\n    p.y -= 0.385;\n    p.z -= 0.155;\n    dist = smoothmin(dist, length(p) - 0.003, 0.025);\n    p.z += 0.01;\n    p.y += 0.004;\n    dist = smoothmin(dist, length(p) - 0.006, 0.01);\n    p.x = abs(p.x) - 0.015;\n    dist = smoothmin(dist, length(p) - 0.006, 0.0125);\n    \n    //ears    \n    p = pos;\n    p.x = abs(p.x);\n    p -= vec3(0.11, 0.4, -0.03);\n    p.xz = rot(0.3) * p.xz;\n    p.yz = rot(-0.4) * p.yz;\n    p.xy = rot(-0.5) * p.xy;\n    dist = smoothmin(dist, distEllipsoid(p, vec3(0.0075, 0.04, 0.025)), 0.015);\n    p -= vec3(0.0175, -0.01, 0.01);\n    dist = smoothmax(dist, -(length(p) - 0.015), 0.02);\n    \n    //mouth    \n    dist = smoothmin(dist, distEllipsoid(pos - vec3(0., 0.345, 0.115), vec3(0.04, 0.03, 0.02)), 0.015);\n    p = pos;\n    p.y -= 0.345;\n    p.z -= 0.14;\n    p.yz = rot(-0.9) * p.yz;\n    p.xz = rot(-15. * p.x) * p.xz;\n    float distLips = distEllipsoid(p, vec3(0.03, 0.0075, 0.0075));\n    p.y -= 0.009;\n    p.z -= 0.001;\n    distLips = smoothmax(distLips, -(length(p) - 0.008), 0.01);\n    \n    p = pos;\n    p.y -= 0.325;\n    p.z -= 0.126;\n    p.yz = rot(0.25) * p.yz;\n    p.xz = rot(-10. * p.x) * p.xz;\n    distLips = smoothmin(distLips, distEllipsoid(p, vec3(0.035, 0.0125, 0.02)), 0.00003);\n    dist = smoothmin(dist, distLips, 0.0075);\n    \n    p = pos;\n    p.x = abs(p.x);\n    p -= vec3(0.036, 0.33, 0.1275);\n    dist = smoothmax(dist, -(length(p) - 0.001), 0.02);\n    \n    //cut\n    p = pos;\n    p.x = abs(p.x);\n    p.xy = rot(0.3) * p.xy;\n    dist = smoothmax(dist, -p.y + 0.075, 0.01); \n    dist = smoothmin(dist, max(pos.y - 0.055, length(pos.xz) - 0.075) + 0.005 * sin(100. * pos.y), 0.1);\n    \n    return dist;\n}\n\nvec3 getNormal(vec3 p){\n    float c;\n\treturn(normalize(vec3(distScene(p + vec3(EPSN, 0., 0.), c) - distScene(p - vec3(EPSN, 0., 0.), c),\n               \t\t\tdistScene(p + vec3(0., EPSN, 0.), c) - distScene(p - vec3(0., EPSN, 0.), c),\n               \t\t\tdistScene(p + vec3(0., 0., EPSN), c) - distScene(p - vec3(0., 0., EPSN), c))));\n}\n\nfloat getShadow(vec3 pos, vec3 light, vec3 normal){\n\tvec3 shadowRay = normalize(light - pos);\n    pos += 3. * EPS * normal;\n    float totDist = 3. * EPS;\n    float prevDist = totDist;\n    float shadow = 1.;\n    float dist, c;\n\n    for(float s = 0.; s < STEPS_SHADOW; s++){\n        dist = distScene(pos, c);\n        shadow = min(shadow, 4. * dist / totDist);\n        if(abs(dist) < EPS){\n            shadow = 0.;\n            break;\n        }\n        dist = 0.997 * dist + 0.003 * hash3(pos + sin(iTime));\n        pos += shadowRay * dist;\n        totDist += dist;\n        if(totDist > 2.) break;\n    }\n    return clamp(shadow, 0., 1.);\n}\n\nvec3 render(vec2 uv){\n\tvec3 col = 0.95 - 0.025 * vec3(smoothstep(0.6, 0.3, fbm2(75. * uv)));\n    vec3 ink = vec3(0.15, 0.2, 0.3);\n    \n    //camera\n    vec3 eye = vec3(0., 0., 5.);\n    vec3 ray = normalize(vec3(uv, 1.) - eye);\n    ray.yz = rot(0.12) * ray.yz;\n    eye.yz = rot(0.12) * eye.yz;\n    \n   \t//raymarch\n    vec3 pos = eye;\n    float s, colorVariation, prevDist, totDist = 0., outline = 1.;\n    bool hit = false;\n    float dist = distScene(pos, colorVariation);\n    float maxDist = 7.;\n        \n    for(s = 0.; s < STEPS; s++){\n        prevDist = dist;\n    \tdist = distScene(pos, colorVariation);\n        if(dist > prevDist && dist < EPSOUT){\n        \toutline = min(outline, dist);\n        }\n        if(abs(dist) < EPS || totDist > maxDist){\n            break;\n        }\n        pos += ray * dist;\n        totDist += dist;\n    }\n    \n    if(totDist < maxDist) hit = true;\n    float f = fbm3(10. * pos);\n    float sf = smoothstep(0.5, 0.6, f);\n    \n    vec3 normal = getNormal(pos);\n    \n    //col = 0.75 * vec3(s / STEPS)  + 0.25 * (0.5 + normal);\n    if(hit) col = mix(col, ink, colorVariation);\n    \n    //outline\n    outline = clamp(outline / EPSOUT, 0., 1.);\n\toutline = smoothstep(0.5, 0.7, outline + 0.5 * f);\n    col = mix(ink, col, outline);\n    \n    vec3 light = vec3(5., 7., 10.);\n    light.yz = rot(0.3) * light.yz;\n    \n    //white highlight\n    float shine = 10.;\n    vec3 refl = reflect(normalize(pos - light), normal);\n    float spec = pow(clamp(dot(normalize(eye - pos), refl), 0., 1.), shine);\n    spec = smoothstep(0.45, 0.55, spec - 0.5 * f);\n    if(hit) col = mix(col, vec3(1.), (1. - 0.5 * colorVariation) * spec);\n    \n    //shadows\n    float shadow = getShadow(pos, light, normal);\n    shadow = smoothstep(0.5, 0.7, shadow + 0.5 * f);\n    if(length(pos) < 1.)col = mix(ink, col, shadow);\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.x;\n    vec3 col = render(uv);\n\t\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MltcDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[121, 121, 139, 139, 188], [190, 190, 210, 210, 275], [277, 277, 297, 297, 367], [369, 369, 412, 412, 520], [522, 522, 565, 565, 598], [600, 600, 634, 634, 669], [671, 671, 692, 692, 894], [896, 896, 917, 917, 1280], [1282, 1282, 1301, 1301, 1498], [1501, 1501, 1520, 1520, 1677], [1679, 1679, 1715, 1715, 1889], [1891, 1891, 1943, 1943, 7694], [7696, 7696, 7719, 7719, 8027], [8029, 8029, 8080, 8080, 8664], [8666, 8666, 8687, 8687, 10503], [10505, 10505, 10562, 10562, 10690]], "test": "timeout"}
{"id": "MltcWf", "name": "ld42_polyarnik_waves", "author": "GRaAL", "description": "Wave shader for LD42 entry: https://ldjam.com/events/ludum-dare/42/polyarnik", "tags": ["ld42"], "likes": 2, "viewed": 79, "published": "Public", "date": "1534510976", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//uncomment if you want to see shader used in LD42 entry\n//#define AS_IN_LD42\n\n//uncomment to see waves only\n//#define WAVES_ONLY\n\n\n#define WAVES 10.\n#define WSCALEY 6.\n#define TIMESCALEY 2.\n#define TIME_SPEED_X -0.01\n#define TIME_SPEED_INC_PER_ROW 0.1\n#define WOFFSET -0.5\n#define WAVE_COUNT 60.\n#define EDGE 0.2\n\n\n\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec4 getColor() {\n    return vec4(0x62, 0x90, 0xc3, 0xff)/255.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 vTextureCoord = fragCoord.xy/iResolution.xy;\n    float onWave = 0.0;\n    float onGlare = 0.0;\n    for (int i = 0; i < int(WAVES); i++) {\n        float scaleTime = TIMESCALEY*((cos(iTime + vTextureCoord.x*10.) + 1.)/0.5 + 1.);\n        float yInWave = WAVES * (vTextureCoord.y - (float(i)*1.0 / WAVES)) * (WSCALEY + scaleTime);\n        float speedX = mod(iTime * (TIME_SPEED_X), 3.1415) + float(i)*TIME_SPEED_INC_PER_ROW;\n\n        onWave = max(onWave, step(abs(sin((vTextureCoord.x + speedX + WOFFSET*float(i))*WAVE_COUNT) - yInWave), EDGE));\n\n        float inWave = vTextureCoord.y > yInWave && vTextureCoord.y < yInWave + 1.0/WAVES ? 1.0 : 0.0;\n        #ifdef AS_IN_LD42\n        float glare = step(rand(vec2(floor(fragCoord.x/8.+ speedX), vTextureCoord.y+fragCoord.y)), 0.001);\n        #else\n        float glare = step(rand(vec2(floor(fragCoord.x/8.+ speedX), vTextureCoord.y+fragCoord.y/20.)), 0.005);\n        #endif\n        glare = glare * (0.5 + 0.5*step((1. + sin(iTime + vTextureCoord.x + rand(fragCoord.xy)))*0.5, 0.5));\n        onGlare = max(onGlare, glare);\n    }\n    fragColor = getColor();\n    fragColor.rgb *= (0.8 + 0.2*onWave);\n#ifndef WAVES_ONLY   \n    fragColor = clamp(fragColor*(1.0 + onGlare), 0., 1.);\n#endif    \n}\n\n\n", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MltcWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[318, 318, 338, 338, 410], [412, 412, 429, 429, 477]], "test": "ok"}
{"id": "MltcWs", "name": "Glitch pt1", "author": "mmerchante", "description": "Trying to replicate a gpu bug that looked really interesting, based on my soulstone shader: https://www.shadertoy.com/view/XtSfDD", "tags": ["raymarching", "glitch", "crystal", "blizzard", "soulstone"], "likes": 36, "viewed": 883, "published": "Public", "date": "1534996890", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// A glitchy version of my soulstone shader: \n// https://www.shadertoy.com/view/XtSfDD\n\n// Inspired by a bug that a friend had on their browser.\n// The code is a mess, so beware.\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define PI 3.14159265\n\n#define MAX_DISTANCE 30.0\n#define MIN_DISTANCE 5.0\n#define EPSILON .02\n#define EPSILON_NORMAL .05\n\n\n// ---------------------------------------------------------\n// hg\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n// hg\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\n// hg\nfloat fBox(vec3 p) {\n    vec3 d = abs(p) - .5;\n    return length(max(d, 0.0)) + vmax(min(d, 0.0));\n}\n\n// hg\nfloat fCapsule(vec3 p, float r, float c) {\n\treturn mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n}\n\nvec2 csqr( vec2 a )  { return vec2( a.x*a.x - a.y*a.y, 2.*a.x*a.y  ); }\n\nvec3 domainRepeat(vec3 p, vec3 size)\n{\n    return mod(abs(p) + size * .5, size) - size * .5;\n}\n\nfloat domainRepeat1D(float p, float size)\n{\n    return mod(abs(p) + size * .5, size) - size * .5;\n}\n\n// hg\nvec2 pModPolar(vec2 p, float repetitions) {\n\tfloat angle = 2.0 * 3.1415 / repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\treturn vec2(cos(a), sin(a))*r;\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * 443.8975);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash31(vec3 uv) {\n    float f = fract(sin(dot(uv, vec3(.09123898, .0231233, .0532234))) * 1e5);\n    return f;\n}\n\n// ---------------------------------------------------------\n\nstruct Intersection\n{\n    float totalDistance;\n    float mediumDistance;\n    float sdf;\n    float density;\n    int materialID;\n};\n    \nstruct Camera\n{\n\tvec3 origin;\n    vec3 direction;\n    vec3 left;\n    vec3 up;\n};\n    \n// ---------------------------------------------------------\n    \n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\nint ihash(int x) { return int(hash(uint(x))); }\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\nfloat random(inout uint seed)\n{\n\tseed = hash(seed);\n\treturn floatConstruct(seed);\n}\n\n// hg\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat density(vec3 p)\n{\n    p -= vec3(-2.35, 2.5, 0.0);    \n    pR(p.xz, iTime * .3);\n    \n    vec3 p0 = p;\n    vec3 pp = p;\n    p *= .3;\n    float res = 0.0;\n    \n    pR(p.yz, iTime * .5);\n    \n    // credit to guil for this hybrid fractal:\n    // https://www.shadertoy.com/view/MtX3Ws\n    // Anything can work here, the idea is to warp the fracture cuts\n\tfor (int i = 0; i < 4; ++i) \n    {\n        p = .7 * abs(p) / dot(p,p) - .95;\n        p.yz = csqr(p.yz);\n        p = p.zxy;\n\t}    \n   \n    p = pp + p * .5;\n    \n    float d = 0.0;\n\tuint seed = uint(14041956);\n    \n    // The fractal warping now distorts the planar cuts in meaningful ways ;)\n    // I should unroll the planes...\n\tfor(int i = 0; i < 3; ++i)\n\t{\n        // Folding\n\t\tp.yxz = clamp(p, -1.0, 1.0) * 2.0 - p;\n        \n        vec3 axis = normalize(vec3(random(seed), random(seed) * 2.0, random(seed)) * 2.0 - vec3(1.0));\n        vec3 offset = vec3(0.0, random(seed) * 2.0 - 1.0, 0.0);\n\t\t\n        float proj = dot(p - offset, axis);\n\t\td += smoothstep(.1, .0, abs(proj));\n\t}\n    \n    p0 *= mix(.8, 1.0, sin(iTime * .8) * .5 + .5);\n        \n    d = d * smoothstep(1.5, -1.5, length(p0) - 2.5 - sin(iTime) * .35 + cos(iTime * 234.0) * .1 - sin(iTime * 2376.0) * .05);    \n    d *= sin(p0.y *2.0 + p.y * 4.0 + iTime * 1.0) * .25 + 1.0;\n    \n    d += smoothstep(1.5, -1.5, length(p0) - 2.5) * .4;\n\treturn d * d;\n}\n    \nfloat sdf_generated(vec3 p)\n{\n\tvec3 wsPos = vec3(.0,.0,.0);\n\tfloat stack[2];\n\tvec3 pStack[2];\n\tpStack[0] = p;\n\twsPos = (mat4(.16, .0, .0, .0, .0, .16, .0, .0, .0, .0, .16, .0, -.348, .149, .329, 1.0) * vec4(pStack[0], 1.0)).xyz;\n\tstack[0] = length(wsPos) - .5;\n\tpStack[1] = (pStack[0] * vec3(1.022,.646,1.022)) - vec3(2.043,-5.67,-1.398);\n\tpStack[1].xz = pModPolar(pStack[1].xz , 13.0);\n\twsPos = (mat4(.628, -.065, .15, .0, .366, .113, -.138, .0, -.039, .023, 1.116, .0, -2.524, .342, -.263, 1.0) * vec4(pStack[1], 1.0)).xyz;\n\tstack[1] = fBox(wsPos);\n\tstack[0] = min( stack[0],stack[1]);\n\twsPos = (mat4(.111, .0, .0, .0, .0, .111, .0, .0, .0, .0, .111, .0, -.242, 1.23, .228, 1.0) * vec4(pStack[0], 1.0)).xyz;\n\tstack[0] = min( stack[0],length(wsPos) - .05);\n\treturn stack[0];\n}\n\nfloat outerDensity(vec3 p)\n{   \n    float d = 0.0;\n    \n    for(int i = 0; i < 5; ++i)\n        d += smoothstep(-1.5, 1.5, sdf_generated(p + vec3(0.0, -5.0 + float(i) * 3.5, 0.0))) * .05;\n    \n    p.y -= 4.5;\n    d *= smoothstep(10.0, -10.0, length(p) - 17.0);\n    \n    return d;\n}\n\nfloat frPlane(vec3 p)\n{\n    return p.y + (clamp(p.x, 0.0, 2.0) * 0.05 + clamp(p.z + .5, 0.0, 1.0) * .1);\n}\n\n// hg\nfloat fBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, 0.0)) + vmax(min(d, 0.0));\n}\n\nfloat sdf_simple(vec3 p)\n{\n    p.x += 2.;\n\tvec3 wsPos = vec3(.0,.0,.0);\n\tfloat stack[12];\n\tvec4 pStack[12];\n\tpStack[0] = vec4(p, 1.0);\n\tpStack[0] = (pStack[0] * vec4(1.0,.98,1.0,1.0));\n\tpStack[1] = pStack[0];\n\tpStack[2] = (mat4(.999, .0, .055, .0, .0, 1.0, .0, .0, -.055, .0, .999, .0, -1.509, .14, .498, 1.0) * pStack[1]);\n\tpStack[2].xz = pModPolar(pStack[2].xz , 8.0);\n\tpStack[3] = (mat4(.795, .934, 2.28, .0, -.491, 1.642, -1.25, .0, -1.401, -.045, 1.732, .0, -.397, -.911, -7.876, 1.0) * pStack[2]);\n\twsPos = (mat4(1.0, .0, .0, .0, .0, .978, -.208, .0, .0, .208, .978, .0, -1.6, -.459, 1.734, 1.0) * pStack[3]).xyz;\n\tstack[3] = fBox(wsPos,vec3(1.0,3.569,1.0));\n\twsPos = (mat4(1.128, .386, .417, .0, -.926, .053, 1.543, .0, 1.235, -.313, .775, .0, -.769, -1.532, -2.843, 1.0) * pStack[3]).xyz;\n\tstack[3] = max(stack[3],frPlane(wsPos));\n\twsPos = (mat4(-1.008, .237, -1.253, .0, -1.259, .149, 1.228, .0, 1.027, .415, .275, .0, 4.273, -.714, -.96, 1.0) * pStack[3]).xyz;\n\tstack[3] = max(stack[3],frPlane(wsPos));\n\twsPos = (mat4(-1.633, -.219, .498, .0, .244, .173, 1.651, .0, -.964, .415, -.425, .0, 3.007, -.072, -3.193, 1.0) * pStack[3]).xyz;\n\tstack[3] = max(stack[3],frPlane(wsPos));\n\twsPos = (mat4(-.526, -.46, -.495, .0, -1.791, .161, -.242, .0, .411, .112, -1.689, .0, 5.514, .189, 1.112, 1.0) * pStack[3]).xyz;\n\tstack[3] = max(stack[3],frPlane(wsPos));\n\tstack[2] = stack[3];\n\tpStack[4] = (mat4(.788, .097, .425, .0, -.135, .792, .022, .0, -.418, -.073, .795, .0, 1.929, -6.665, -.972, 1.0) * pStack[1]);\n\tpStack[5] = pStack[4];\n\tpStack[6] = pStack[5];\n\twsPos = (mat4(.955, .275, .116, .0, -.267, .961, -.077, .0, -.132, .043, .99, .0, -4.202, .92, 3.449, 1.0) * pStack[6]).xyz;\n\tstack[6] = fBox(wsPos,vec3(2.348,1.637,1.216));\n\twsPos = (mat4(.7, .094, -.708, .0, .329, .837, .436, .0, .634, -.539, .555, .0, -.6, 1.689, 1.496, 1.0) * pStack[6]).xyz;\n\tstack[6] = min(stack[6],fBox(wsPos,vec3(2.35,1.884,1.216)));\n\twsPos = (mat4(.577, -.066, .814, .0, -.054, .991, .119, .0, -.815, -.113, .569, .0, -2.891, 1.707, -.919, 1.0) * pStack[5]).xyz;\n\tstack[5] = max(-stack[6],fBox(wsPos,vec3(1.775,4.848,1.713)));\n\twsPos = (mat4(1.68, -.01, .848, .0, -.871, .133, 1.509, .0, -.276, -.482, .4, .0, -5.624, -1.2, .976, 1.0) * pStack[4]).xyz;\n\tstack[4] = max(stack[5],frPlane(wsPos));\n\twsPos = (mat4(-1.288, -.085, -1.277, .0, -1.377, .184, 1.044, .0, .314, .457, -.658, .0, 2.367, .783, 2.615, 1.0) * pStack[4]).xyz;\n\tstack[4] = max(stack[4],frPlane(wsPos));\n\twsPos = (mat4(-.526, -.46, -.495, .0, -1.791, .161, -.242, .0, .411, .112, -1.689, .0, 1.346, .968, -.74, 1.0) * pStack[4]).xyz;\n\tstack[4] = max(stack[4],frPlane(wsPos));\n\twsPos = (mat4(.649, .468, -.157, .0, -1.578, .171, .798, .0, .862, -.04, 1.579, .0, .804, -1.56, 3.123, 1.0) * pStack[4]).xyz;\n\tstack[4] = max(stack[4],frPlane(wsPos));\n\twsPos = (mat4(-.446, -.32, 1.219, .0, -1.751, .078, -.321, .0, .016, -.369, -1.124, .0, -1.128, -.361, -6.142, 1.0) * pStack[4]).xyz;\n\tstack[4] = max(stack[4],frPlane(wsPos));\n\twsPos = (mat4(1.533, .154, .696, .0, -.87, .377, .718, .0, -.329, -.281, 1.342, .0, -4.104, -1.442, -.118, 1.0) * pStack[4]).xyz;\n\tstack[4] = max(stack[4],frPlane(wsPos));\n\twsPos = (mat4(1.853, -.102, -.211, .0, .221, -.014, 1.757, .0, -.392, -.489, -.008, .0, -1.772, -1.406, 6.376, 1.0) * pStack[4]).xyz;\n\tstack[4] = max(stack[4],frPlane(wsPos));\n\twsPos = (mat4(-.556, -.453, -.525, .0, -.17, -.141, 1.687, .0, -1.815, .152, .003, .0, -1.992, -.067, 6.05, 1.0) * pStack[4]).xyz;\n\tstack[4] = max(stack[4],frPlane(wsPos));\n\tstack[1] = min(stack[2],stack[4]);\n\tpStack[7] = (mat4(-.943, -.128, .043, .0, -.107, 1.049, .137, .0, -.059, .146, -.94, .0, 1.858, .33, -1.42, 1.0) * pStack[1]);\n\tpStack[7].xz = pModPolar(pStack[7].xz , 10.0);\n\twsPos = (mat4(.962, .227, .152, .0, -.16, .92, -.359, .0, -.221, .321, .921, .0, -2.419, -1.936, -.092, 1.0) * pStack[7]).xyz;\n\tstack[7] = fBox(wsPos,vec3(.687,1.751,.687));\n\twsPos = (mat4(1.676, .466, 1.232, .0, -1.862, .058, 1.912, .0, 1.213, -.556, 1.231, .0, -3.822, -1.844, -6.583, 1.0) * pStack[7]).xyz;\n\tstack[7] = max(stack[7],frPlane(wsPos));\n\twsPos = (mat4(-1.467, .491, -1.337, .0, -1.788, .06, 1.971, .0, 1.549, .534, 1.009, .0, 6.023, -1.973, -.383, 1.0) * pStack[7]).xyz;\n\tstack[7] = max(stack[7],frPlane(wsPos));\n\twsPos = (mat4(-2.494, -.141, 1.034, .0, .951, .2, 2.324, .0, -.79, .686, -.467, .0, 6.624, -.322, -6.471, 1.0) * pStack[7]).xyz;\n\tstack[7] = max(stack[7],frPlane(wsPos));\n\twsPos = (mat4(-1.116, -.568, -1.242, .0, -2.513, .31, .163, .0, .432, .334, -2.263, .0, 7.905, .708, 4.921, 1.0) * pStack[7]).xyz;\n\tstack[7] = max(stack[7],frPlane(wsPos));\n\tstack[1] = min(stack[1],stack[7]);\n\tpStack[8] = (mat4(-.025, -.278, 1.937, .0, -.454, 1.573, .319, .0, -1.912, -.37, -.101, .0, .038, -4.893, -1.369, 1.0) * pStack[1]);\n\tpStack[8].xz = pModPolar(pStack[8].xz , 5.0);\n\twsPos = (mat4(.651, .483, .586, .0, -.211, .856, -.471, .0, -.729, .183, .66, .0, -2.283, -.628, -2.008, 1.0) * pStack[8]).xyz;\n\tstack[8] = fBox(wsPos,vec3(1.0,2.171,1.0));\n\twsPos = (mat4(1.01, .023, 1.506, .0, -1.623, .004, .939, .0, .032, -.499, .078, .0, -4.952, -.781, -2.879, 1.0) * pStack[8]).xyz;\n\tstack[8] = max(stack[8],frPlane(wsPos));\n\twsPos = (mat4(-1.354, .304, -.64, .0, -.774, .034, 1.62, .0, 1.106, .396, .35, .0, 2.953, -1.14, 2.649, 1.0) * pStack[8]).xyz;\n\tstack[8] = max(stack[8],frPlane(wsPos));\n\twsPos = (mat4(-1.462, -.104, 1.084, .0, .892, .238, 1.325, .0, -.851, .427, -.474, .0, 6.541, .212, -.951, 1.0) * pStack[8]).xyz;\n\tstack[8] = max(stack[8],frPlane(wsPos));\n\twsPos = (mat4(-1.166, -.349, -.663, .0, -1.442, .328, .007, .0, .463, .142, -1.648, .0, 3.098, 1.04, 2.74, 1.0) * pStack[8]).xyz;\n\tstack[8] = max(stack[8],frPlane(wsPos));\n\twsPos = (mat4(.024, .494, .28, .0, -1.723, -.028, .764, .0, .829, -.074, 1.579, .0, .498, -2.115, -.172, 1.0) * pStack[8]).xyz;\n\tstack[8] = max(stack[8],frPlane(wsPos));\n\tstack[1] = min(stack[1],stack[8]);\n\tpStack[9] = (mat4(.795, .0, -.714, .0, .302, 3.241, .336, .0, .647, -1.512, .721, .0, -.378, -3.143, .939, 1.0) * pStack[1]);\n\tpStack[9].xz = pModPolar(pStack[9].xz , 6.0);\n\tpStack[10] = (mat4(.28, .504, 2.966, .0, -.047, 1.821, -.83, .0, -1.66, .033, .523, .0, 1.505, 4.294, -7.819, 1.0) * pStack[9]);\n\twsPos = (mat4(1.0, .0, .0, .0, .0, .978, -.208, .0, .0, .208, .978, .0, -1.61, -1.766, 1.164, 1.0) * pStack[10]).xyz;\n\tstack[10] = fBox(wsPos,vec3(1.0,3.569,1.0));\n\twsPos = (mat4(1.128, .386, .417, .0, -.926, .053, 1.543, .0, 1.235, -.313, .775, .0, -.769, -1.532, -2.843, 1.0) * pStack[10]).xyz;\n\tstack[10] = max(stack[10],frPlane(wsPos));\n\twsPos = (mat4(-1.008, .237, -1.253, .0, -1.259, .149, 1.228, .0, 1.027, .415, .275, .0, 4.273, -.714, -.96, 1.0) * pStack[10]).xyz;\n\tstack[10] = max(stack[10],frPlane(wsPos));\n\twsPos = (mat4(-1.633, -.219, .498, .0, .244, .173, 1.651, .0, -.964, .415, -.425, .0, 3.007, -.072, -3.193, 1.0) * pStack[10]).xyz;\n\tstack[10] = max(stack[10],frPlane(wsPos));\n\twsPos = (mat4(-.526, -.46, -.495, .0, -1.791, .161, -.242, .0, .411, .112, -1.689, .0, 5.514, .189, 1.112, 1.0) * pStack[10]).xyz;\n\tstack[10] = max(stack[10],frPlane(wsPos));\n\tstack[9] = stack[10];\n\tstack[1] = min(stack[1],stack[9]);\n\tpStack[11] = (mat4(1.43, -.088, -1.481, .0, -.092, 1.769, -.567, .0, .828, .35, 2.494, .0, -1.382, -4.146, -2.058, 1.0) * pStack[1]);\n\twsPos = (mat4(.922, .331, -.201, .0, -.385, .731, -.563, .0, -.039, .596, .802, .0, -.756, -1.514, 2.05, 1.0) * pStack[11]).xyz;\n\tstack[11] = fBox(wsPos,vec3(1.0,3.569,1.546));\n\twsPos = (mat4(1.128, .386, .417, .0, -.926, .053, 1.543, .0, 1.235, -.313, .775, .0, -.769, -1.532, -2.843, 1.0) * pStack[11]).xyz;\n\tstack[11] = max(stack[11],frPlane(wsPos));\n\twsPos = (mat4(-1.008, .237, -1.253, .0, -1.259, .149, 1.228, .0, 1.027, .415, .275, .0, 4.057, -.994, -1.057, 1.0) * pStack[11]).xyz;\n\tstack[11] = max(stack[11],frPlane(wsPos));\n\twsPos = (mat4(-1.633, -.219, .498, .0, .244, .173, 1.651, .0, -.964, .415, -.425, .0, 3.007, -.072, -3.193, 1.0) * pStack[11]).xyz;\n\tstack[11] = max(stack[11],frPlane(wsPos));\n\twsPos = (mat4(-.526, -.46, -.495, .0, -1.791, .161, -.242, .0, .411, .112, -1.689, .0, 5.374, .102, 1.328, 1.0) * pStack[11]).xyz;\n\tstack[11] = max(stack[11],frPlane(wsPos));\n\tstack[1] = min(stack[1],stack[11]);\n\tstack[0] = max(stack[1],dot(pStack[0].xyz - vec3(1.24,.07,2.43), vec3(-.129,-.864,.486)));\n\tstack[0] = max(stack[0],dot(pStack[0].xyz - vec3(-.2,-1.41,1.48), vec3(.107,-.943,-.314)));\n\treturn stack[0];\n}\n\nvec3 sdfNormal(vec3 p, float sdf, float epsilon)\n{\n    vec3 eps = vec3(epsilon, -epsilon, 0.0);\n    \n\tfloat dX = sdf - sdf_simple(p + eps.yzz);\n\tfloat dY = sdf - sdf_simple(p + eps.zyz);\n\tfloat dZ = sdf - sdf_simple(p + eps.zzy); \n\n\treturn normalize(vec3(dX,dY,dZ));\n}\n\nCamera GetCamera(vec2 uv, ivec2 coord, float zoom)\n{\n    float dist = 8.0 / zoom;\n    uint seed = uint(float(iFrame) * .1);\n    float time = iTime;\n    float tOffset = random(seed) * (float(ihash((coord.x * coord.y) / 10024) % 1024) / 1024.0);\n    \n    time += (tOffset * 2.0 - 1.0) * 2.2 * step(random(seed), sin(iTime));\n    \n    vec3 target = vec3(0.0, 4.45 + sin(iTime * 2.0) * .65, 0.0);\n    vec3 p = vec3(0.0, 7.5, 0.0) + vec3(cos(time), .0, sin(time)) * dist;\n        \n    vec3 forward = normalize(target - p);\n    vec3 left = normalize(cross(forward, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(forward, left));\n\n    Camera cam;   \n    cam.origin = p;\n    cam.direction = normalize(forward - left * uv.x * zoom - up * uv.y * zoom);\n    cam.up = up;\n    cam.left = left;\n        \n    return cam;\n}\n\n// iq\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 d )\n{\n    return a + b * cos(6.28318 * (t + d));\n}\n\nvec3 Render(Camera camera, Intersection isect, vec2 uv, ivec2 coord, float density)\n{\n    vec3 p = camera.origin + camera.direction * isect.totalDistance;\n    \n    if(isect.sdf < EPSILON)\n    {\n        int frame = int(hash(uint(float(iFrame) * .1)));\n        coord /= frame % 10 + 1;\n        int index = int(coord.y * int(iResolution.y) + coord.x);\n        index /= ihash(frame) % 32 + 4;\n        \n        int checker = index % (int(hash(uint(index + int(float(iFrame) * .15)))) % 7 + 2);\n        \n        float mask = checker > 0 ? 0.0 : 1.0;\n        \n        vec3 normal = sdfNormal(p, isect.sdf, .02) * .5 + .5;\n        \n        vec3 c = palette(0.0, vec3(.5), normal + p * .1, normal * 2.0);\n                \n        //c = mix(normal*normal,c, mask) * (mask * .25 + .75);\n        c = mix(c, palette(length(mod(p, vec3(1.0))) * .1, vec3(.5) + c * .1, uv.xyx + normal, normal * 2.0), mask);\n             \n        // Thank you, night light...\n        c = vec3(c.r * .9 + .15, c.g * .86 + .15, c.b * .7);\n        \n        return c;\n    }\n    \n    float vignette = 1.0 - pow(length(uv) / 2.8, 1.8) - hash12(uv + iTime) * .2;    \n    density = saturate(log(density * .25));    \n    return vec3(.85, .9, 1.0) * density * vignette;\n}\n\n\nfloat RaymarchMedium(Camera camera, float surfaceDistance)\n{    \n    float d = 0.0;\n        \n\tfor(int j = 0; j < 25; ++j)\n\t{\n        float dist = 14.0 + float(j) * .5;                \n        d += outerDensity(camera.origin + camera.direction * dist);        \n\t}\n    \n    return d;\n}\n\nIntersection Raymarch(Camera camera, ivec2 coord)\n{    \n    Intersection outData;\n    outData.sdf = 0.0;\n    outData.density = 0.0;\n    outData.totalDistance = MIN_DISTANCE;\n    \n    // Coherence? Where we're going we don't need coherence\n    int frame = int(hash(uint(float(iFrame) * .2)));\n    int steps = 15 + clamp(ihash(frame) % 40, 0, 40);// clamp(int(hash(uint((coord.y * 32 + coord.x + iFrame) / 128))) % 20, 0, 20);\n        \n\tfor(int j = 0; j < steps; ++j)\n\t{\n        vec3 p = camera.origin + camera.direction * outData.totalDistance;\n\t\toutData.sdf = sdf_simple(p);\n\t\toutData.totalDistance += outData.sdf;\n        \n\t\tif(outData.sdf < EPSILON || outData.totalDistance > MAX_DISTANCE)\n            break;\n\t}\n\n    if(outData.sdf > EPSILON)\n    {\n        outData.density = 0.;\n    }\n    return outData;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 rawUV = (-iResolution.xy + (fragCoord*2.0)) / iResolution.y;\n\tvec2 uv = (-iResolution.xy + (fragCoord*2.0)) / iResolution.y;\n    \n    uint offset = uint(iFrame / 6) + uint((uv.x + uv.y) * 8.0);\n    float res = mix(6.0, 64.0, random(offset));\n    \n    uv = floor(uv * res) / res;\n    \n    uint seed = uint(fragCoord.x + iTime) / 32u;\n    \n    // Horizontal splitter\n    uv.x += (random(seed) * 2.0 - 1.0) * step(random(seed), pow(sin(iTime * 4.), 7.0)) * random(seed);\n\n    Camera camera = GetCamera(uv, ivec2(fragCoord), .45);\n    Intersection isect = Raymarch(camera, ivec2(fragCoord));\n    \n    float density = RaymarchMedium(camera, isect.totalDistance);\n    \n    vec3 color = Render(camera, isect, rawUV, ivec2(fragCoord), density);\n    //color *= 1.0 + rand(uv) * .1;\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "4dBXD3", "previewfilepath": "https://soundcloud.com/c418/time", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/c418/time", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MltcWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[342, 409, 429, 429, 464], [466, 472, 492, 492, 517], [519, 525, 545, 545, 625], [627, 633, 675, 675, 769], [771, 771, 793, 793, 842], [844, 844, 882, 882, 938], [940, 940, 983, 983, 1039], [1041, 1047, 1090, 1090, 1284], [1286, 1327, 1349, 1349, 1469], [1471, 1471, 1494, 1494, 1588], [1939, 2010, 2031, 2031, 2162], [2164, 2164, 2182, 2182, 2211], [2213, 2371, 2403, 2403, 2823], [2825, 2825, 2856, 2856, 2908], [2910, 2916, 2948, 2948, 2990], [2992, 2992, 3015, 3015, 4366], [4372, 4372, 4401, 4401, 5149], [5151, 5151, 5179, 5179, 5431], [5433, 5433, 5456, 5456, 5539], [5541, 5547, 5575, 5575, 5654], [5656, 5656, 5682, 5682, 14027], [14029, 14029, 14079, 14079, 14297], [15114, 15120, 15181, 15181, 15226], [16460, 16460, 16520, 16520, 16743], [16745, 16745, 16796, 16796, 17553], [17555, 17555, 17610, 17610, 18428]], "test": "timeout"}
{"id": "MltyWs", "name": "bubble-circle-waves", "author": "guowei", "description": "bubble-circle-waves, another method yet", "tags": ["circle", "bubble"], "likes": 2, "viewed": 108, "published": "Public", "date": "1534730823", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n   \n   float circleNumber = 3.0;\n   float circleEdgeSharpness = 8.0;\n   float motionSpeed = -1.0;\n   vec4 colorMask = vec4(1.0, 0.5, 0.1, 1.0);\n    \n   float distanceToCenter = distance(uv, vec2(0.0, 0.0)) * circleNumber;\n    \n   float signedDistance = sin(5.0 * distanceToCenter + iTime * motionSpeed) * circleEdgeSharpness;\n    \n   signedDistance = clamp(signedDistance, 0.0, 1.0);\n    \n   fragColor = vec4(vec3(signedDistance), 1.0);\n   \n   fragColor *= colorMask;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MltyWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 590]], "test": "ok"}
{"id": "MlVczD", "name": "Candy Strings", "author": "momoro", "description": "WIP Mistake", "tags": ["color"], "likes": 0, "viewed": 367, "published": "Public API", "date": "1535424489", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592654\n\nfloat map(float value, float inMin, float inMax, float outMin, float outMax) {\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n}\n\n\nmat2 rotate(float angle) {\n    return mat2(cos(angle), -sin(angle),\n                sin(angle), cos(angle)\n    );\n}\n\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n\nfloat atan201(float x, float y) {\n    return (atan(x, y) + PI) / (PI * 2.);\n}\n\nfloat sin01(float n) {\n    return sin(n)/2.+.5;\n}\n\nvec2 sin01(vec2 n) {\n    return sin(n)/2.+.5;\n}\n\nvec4 blend(vec4 bg, vec4 fg) {\n    vec4 c = vec4(0.);\n    c.a = 1.0 - (1.0 - fg.a) * (1.0 - bg.a);\n    if(c.a < .00000) return c;\n    \n    c.r = fg.r * fg.a / c.a + bg.r * bg.a * (1.0 - fg.a) / c.a;\n    c.g = fg.g * fg.a / c.a + bg.g * bg.a * (1.0 - fg.a) / c.a;\n    c.b = fg.b * fg.a / c.a + bg.b * bg.a * (1.0 - fg.a) / c.a;\n    \n    return c;\n}\n\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return dot(m, g);\n}\n\n\nfloat fbm1d(float x, float amplitude, float frequency, float offset) {\n    x += offset;\n    float y = 0.;\n    // Properties\n    const int octaves = 8;\n    float lacunarity = 1.144;\n    float gain = 1.092;\n    \n    // Initial values\n    //sin(u_time) * 5. + 10.;\n    //sin(u_time/10. + 10.);\n    \n    // Loop of octaves\n    for (int i = 0; i < octaves; i++) {\n        y += amplitude * snoise(vec2(frequency*x));\n        frequency *= lacunarity;\n        amplitude *= gain;\n    }\n    \n    return y;\n}\n\n\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\nfloat smax(float a,float b, float k)\n{\n    return -smin(-a,-b,k);\n}\n\nfloat smootheststep(float t) {\n    return -20.*pow(t, 7.)+70.*pow(t,6.)-84.*pow(t,5.)+35.*pow(t,4.); // when smootherstep's second derivative isn't enough\n}\n\n\nfloat pcsmooth(float x) {\n    return -\n        pow(cos((PI*(x)/2.)), 3.) + 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    \n    vec4 color;\n    vec2 st = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    \n    st /=15.036;\n    st += vec2(0.000,-0.055);\n    \n    st *= rotate(iTime/.9);\n    \n    /////////////////////////////////////////////////////////////\n    // Blobby circle\n    #define arcs 7.\n    \n    float f = atan201(st.x, st.y); // angle\n    float m = smoothstep(0., 1., fract(f * arcs)); // mix amount\n\t\n     m = pcsmooth(fract(f*arcs));\n    \n    f = ceil(f * arcs) / arcs; // split up\n    \n    float fNext = f + 1./arcs;\n    // fNext = f;\n    \n    \n    // Smooth the blob at the end\n    bool e = false;\n    if(f > (arcs-1.)/arcs + .01) {\n\t\tfNext = 1./arcs;\n    }\n    \n    // Add noise\n    float amp = 10000.;\n    float freq = 30.;\n    \n    float offset = 1.144 + iTime/300.;\n    f = fbm1d(f, amp, freq, offset);\n    fNext = fbm1d(fNext, amp, freq, offset);\n    \n    f =  map(f, -300., 1., 0.648, 0.712);\n    fNext = map(fNext, -300., 1., 0.648, 0.712);\n\n    float len = length(st);\n\n    float mx = mix(f, fNext, m);\n    len += mx * 0.080;\n    \n  //  float c = smoothstep(len, 0.712, 0.900);\n    \n   // color.rgb = vec3(c);\n\n  //  color.a = 1.;\n    //color.rgb = vec3(mx);\n    \n    #define steps 90.\n    for(float i=0.; i<steps; i++) {\n   \t\tfloat df = max(abs(st.x), abs(st.y));\n        df = len + -0.040;\n        // df = length(st);\n        \n        float incr = 0.4 - (0.4 * i/steps);\n        \n        float f = 1.0 - smoothstep(incr-.001, incr, df);\n\n        // SHADOW\n       f -=  (1.0 - (fract(df*steps) + 0.028)) * 1.016 * f;\n        \n        vec3 rgb = vec3(f);\n        \n        vec3 hsv = vec3(1.);\n        hsv.x = pow(2. * fract((i*6.)/steps + iTime/2.3) - 1., 2.);\n        hsv.x = map(hsv.x, 0., 1., 0.0, 0.108);\n        hsv.y = .9;\n\n        vec3 rgb2 = hsv2rgb(hsv);\n\n        rgb = rgb2 * rgb * 3.112;\n        float a = (i/steps + 0.640) * f;\n       // a  = 0.208;\n\n        color = blend(color, vec4(rgb, a * f));\n    }\n    \n    st = st * rotate(-3.148);\n    st += vec2(-0.030,0.070);\n    st *= 1.288;\n\n    \n    for(float i=0.; i<steps; i++) {\n   \t\tfloat df = max(abs(st.x), abs(st.y));\n        df = len  *-3.632;\n        // df = length(st);\n        \n        float incr = 0.4 - (0.4 * i/steps);\n        \n        float f = 1.0 - smoothstep(incr-.001, incr, df);\n\n        // SHADOW\n       f -=  (1.0 - (fract(df*steps) + 0.036)) * 4.064 * f;\n        \n        vec3 rgb = vec3(f);\n        \n        vec3 hsv = vec3(1.);\n        hsv.x = pow(2. * fract((i*6.)/steps + iTime/9.3) - 1., 2.);\n        hsv.x = map(hsv.x, 0., 1., 0.0, 0.964);\n        hsv.y = .9;\n        hsv.z = .3;\n\n        vec3 rgb2 = hsv2rgb(hsv);\n\n        rgb = rgb2 * rgb * 3.112;\n        float a = (i/steps + 0.01) - 0.472;\n       // a  = 0.208;\n\n        color = blend(color, vec4(rgb, a * f));\n    }\n        \n    color = color;\n    \n    fragColor = color;\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlVczD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 102, 102, 177], [180, 180, 206, 206, 295], [298, 298, 320, 320, 651], [653, 653, 675, 675, 844], [846, 846, 867, 867, 914], [915, 915, 936, 936, 983], [984, 984, 1006, 1006, 1041], [1044, 1044, 1077, 1077, 1121], [1123, 1123, 1145, 1145, 1172], [1174, 1174, 1194, 1194, 1221], [1223, 1223, 1253, 1253, 1570], [1572, 1572, 1594, 1647, 3336], [3339, 3339, 3409, 3409, 3836], [3839, 3839, 3877, 3877, 3954], [3956, 3956, 3994, 3994, 4023], [4025, 4025, 4055, 4055, 4181], [4184, 4184, 4209, 4209, 4264], [4266, 4266, 4323, 4323, 7157]], "test": "ok"}
{"id": "MlVyRm", "name": "Riemann Zeta", "author": "Justaway", "description": "Riemann zeta function calculated using the convergence of alternating series.  \nhttp://numbers.computation.free.fr/Constants/Miscellaneous/zetaevaluations.pdf\nDon't know why I'm getting the artifacts.", "tags": ["riemannzeta"], "likes": 6, "viewed": 238, "published": "Public", "date": "1535604816", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define N 20\n#define E 2.71828\n#define PI 3.14159\n\nconst float[20] ek = float[20](\n\t1048575.000000,1048555.000000,1048365.000000,\n    1047225.000000,1042380.000000,1026876.000000,\n    988116.000000,910596.000000,784626.000000,\n    616666.000000,431910.000000,263950.000000,\n    137980.000000,60460.000000,21700.001953,\n    6196.000488,1351.000122,211.000000,21.000000,1.000000);\n\nvec2 cpow(vec2 z1, vec2 z2)\n{\n\tfloat a2b2 = z1.x * z1.x + z1.y * z1.y;\n\tfloat t1 = pow(a2b2, z2.x / 2.0) * exp(-z2.y * atan(z1.y, z1.x));\n\tfloat t2 = z2.x * atan(z1.y, z1.x) + 0.5 * z2.y * log(a2b2);\n\treturn vec2(t1 * cos(t2), t1 * sin(t2));\n}\n\nvec2 cdiv(vec2 z1, vec2 z2)\n{\n\treturn z1 * mat2(z2, -z2.y, z2.x) / dot(z2, z2);\n}\n\nvec2 cprod(vec2 z1, vec2 z2)\n{\n\treturn vec2(\n\t\tz1.x * z2.x - z1.y * z2.y,\n\t\tz1.x * z2.y + z1.y * z2.x);\n}\n\nvec2 alt(int x)\n{\n\tfloat[2] tbl = float[2](1.0,-1.0);\n\treturn vec2(tbl[int(mod(float(x),2.0))],0.0);\n}\n    \nvec2 zeta(vec2 s)\n{\n\tvec2 sum1 = vec2(0.0);\n\tvec2 sum2 = vec2(0.0);\n\tvec2 k;\n\tfor(int i = 1; i <= N; i++)\n\t{\n\t\tk = vec2(float(i), 0.0);\n\t\tsum1 += cdiv(alt(i - 1), cpow(k , s));\n\t}\n\tfor(int i = N + 1; i <= 2 * N; i++)\n\t{\n\t\tk = vec2(float(i), 0.0);\n\t\tsum2 += cdiv(cprod(alt(i - 1), vec2(ek[i - N - 1],0.0)), cpow(k,s));\n\t}\n    sum2 = cdiv(sum2, vec2(pow(2.0, float(N)), 0.0));\n    return cdiv(sum1 + sum2,vec2(1.0, 0.0) - cpow(vec2(2.0 ,0.0), vec2(1.0, 0.0) - s));\n\treturn vec2(0.0);\n}\n\nvec4 gradient(float theta)\n{\n    vec4 color = vec4(0.0);\n    color += vec4(1.0, 0.0, 0.0, 0.0) * smoothstep(0.0, 1.0, clamp(1.0 - abs((2.0 * PI-theta) * PI / 3.0), 0.0, 1.0));\n    color += vec4(1.0, 0.0, 0.0, 0.0) * smoothstep(0.0, 1.0, clamp(1.0 - abs(-theta * PI / 3.0), 0.0, 1.0));\n    color += vec4(1.0, 1.0, 0.0, 0.0) * smoothstep(0.0, 1.0, clamp(1.0 - abs((PI / 3.0 - theta) * PI / 3.0), 0.0, 1.0));\n    color += vec4(0.0, 1.0, 0.0, 0.0) * smoothstep(0.0, 1.0, clamp(1.0 - abs((PI * 2.0 / 3.0 - theta) * PI / 3.0), 0.0, 1.0));\n    color += vec4(0.0, 1.0, 1.0, 0.0) * smoothstep(0.0, 1.0, clamp(1.0 - abs((PI - theta) * PI / 3.0), 0.0, 1.0));\n    color += vec4(0.0, 0.0, 1.0, 0.0) * smoothstep(0.0, 1.0, clamp(1.0 - abs((PI * 4.0 / 3.0 - theta) * PI / 3.0), 0.0, 1.0));\n    color += vec4(1.0, 0.0, 1.0, 0.0) * smoothstep(0.0, 1.0, clamp(1.0 - abs((PI * 5.0 / 3.0 - theta) * PI / 3.0), 0.0, 1.0));\n    return color*(fract(theta / PI * 10.0) / 2.0 + 0.5);\n}\n\nvec4 plotDomain(vec2 z)\n{\n    float theta = mod(atan(z.y, z.x), 2.0 * PI);\n    return gradient(theta) * (fract(log2(length(z))) / 2.0 + 0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ratio = iResolution.x/iResolution.y;\n    vec2 uv = vec2(\n\t\t(fragCoord.x-iResolution.x/2.0)/iResolution.x*ratio,\n\t\t(fragCoord.y-iResolution.y/2.0)/iResolution.y);\n    vec2 z = uv * 13.0 + vec2(0.0, iTime * 2.0 - 2.0);\n    fragColor = plotDomain(zeta(z));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlVyRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[380, 380, 409, 409, 623], [625, 625, 654, 654, 706], [708, 708, 738, 738, 813], [923, 923, 942, 942, 1406], [1408, 1408, 1436, 1436, 2368], [2370, 2370, 2395, 2395, 2513], [2515, 2515, 2572, 2572, 2838]], "test": "ok"}
{"id": "MlVyzh", "name": "Nova petals", "author": "Redline", "description": "Simple shader somewhat resembling a strange star.", "tags": ["flower", "supernova"], "likes": 7, "viewed": 513, "published": "Public API", "date": "1535132531", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float brightness = 40.;\nconst float speed = .3;\nconst int rings = 1024;\nconst float blur = .1;\nconst float offset = 6.;\nconst float peaks = 10.;\nconst float peakStrength = .5;\nconst float twisting = 1.;\n\nfloat rectSin(float p){\n\treturn sin(p) / 2. + .5;\n}\n\nfloat circle(float r, vec2 pos){\n\treturn abs(r - length(pos));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 nuv =  uv * vec2(2) - vec2(1);\n    nuv.x /= (iResolution.y / iResolution.x);\n\n    vec3 col = vec3(0);\n    int iter = rings;\n    for(int i = 0; i < iter; i++){\n        float prog = float(i) / float(iter);\n        float angle = atan(nuv.x,nuv.y);\n        float radius = pow(rectSin(iTime * speed + prog * offset),2.);\n        radius += pow(radius,.3) * abs(rectSin(iTime / 1. + (angle + rectSin(iTime - radius) * twisting) * peaks)) * peakStrength;\n        vec3 ringColor = vec3(\n            (1.5 - prog - radius) / (radius + .1),\n            rectSin(radius) / (radius + .1),\n            pow(prog,2.) + pow(1. - prog,1.));\n        ringColor += ringColor * smoothstep(0.1,1.,pow(mod(prog , .25) * 4.,9.)) * radius;\n        \n        col +=  ringColor * smoothstep(1.,0.,circle(radius,nuv) / blur);\n    }\n    col /= sqrt(length(col));\n    col /= (float(rings) / log(1. / blur));\n    col = col * brightness;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlVyzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[210, 210, 233, 233, 261], [263, 263, 295, 295, 327]], "test": "ok"}
{"id": "MlyczD", "name": "nabrsurface", "author": "nabr", "description": "writing history yeah!", "tags": ["3d", "raymarch", "surface"], "likes": 3, "viewed": 116, "published": "Public", "date": "1535323579", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// nabr\n// https://www.shadertoy.com/view/MlyczD\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://creativecommons.org/licenses/by-nc-sa/3.0/\n\n\n// note: i wrote this in less then half an hour while wathing a sci-fi movie on netflix\n// most likely not the 100% optimized version also sadly not 3D as you would expect  \n// its all about shading right ?\n\n\n#define time iTime\n#define R(p, a) p = cos(a) * p + sin(a) * vec2(p.y, -p.x)\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    \n    // ----------------------- INIT SCENE\n\n    vec2 uv = (iResolution.xy - fragCoord.xy * 2.0)/min(iResolution.x, iResolution.y);\n    \n\tvec3 ro = vec3(0);\n\tvec3 rd = normalize( vec3(uv, 1));\n\t\n\tR(rd.xy, time * 0.2);\n\t\n    \n    // ----------------------- SURFACE ATTRIB\n    \n    // mouse\n    float m = 2.5 * acos( (2.0 * (iMouse.x/iResolution.x) -1.0 ) * (iResolution.x/iResolution.y) );\n    // uncheck users first click \n    if( iMouse.z == 0.0 ) m = 0.001;\n    \n    // sufrace scale\n    float scale = 1.6;\n    \n    // animation\n    float tm = time;\n    \n    // uncheck users first click / stop anim when clicked \n    if(iMouse.z == 0.0) m = 0.001;\n    else if (iMouse.z >= 0.0) tm =0.;\n    \n\t// ----------------------- RAYMARCH\n\t\n    vec3 color = vec3(0.0);\t\t\n    float t = 0.0, d = 0.0;\n    \n    for (float i= 0.;(i<1.0);i+=0.013) \n    {\n\t\tif(d > 3.0) break;\n\t\tvec3 p = ro;\n\t\td = abs( cos(p.y * 0.5) * cos(p.x * 0.5));\n\t\td = min(1.001 * d, 0.01 / abs(sin(p.y * 0.4) * cos(m-(tm + p.x * 0.5))));\n\t\td = min(d, t - (sqrt( p.x * p.x + p.y * p.y) * scale) );\n\t\tt += d + 0.001;\n\t\tro+= rd * d;\n\t};\n    \n\t\n    // ----------------------- SHADE\n        \n    (t>3.0)? (color = rd * 0.7 + vec3(t * 0.84) * ( d - 0.0199 ) + t * 0.0012):(color = rd * 0.52 +vec3(1.0));\n    \n    fragColor.rgb = color;\n    fragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlyczD.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[480, 480, 537, 586, 1858]], "test": "ok"}
{"id": "Mt3yWS", "name": "life of tree", "author": "thu_yumeng", "description": "fix webgl2.0's error, reference:\nhttps://www.shadertoy.com/view/ltlSRl\n3d raymarching", "tags": ["3draymarching", "fixwebgl20error"], "likes": 9, "viewed": 129, "published": "Public", "date": "1533820110", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nconst int MAX_STEPS = 100;\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nstruct Distance\n{\n\tfloat value;\n\tvec3 color;\n};\n\nstruct Hit\n{\n\tbool is;\n\tvec3 pos;\n\tvec3 color;\n};\n    \nmat4 rotateX(float angle)\n{\n\tangle = -angle/180.0*3.1415926536;\n    float c = cos(angle);\n    float s = sin(angle);\n\treturn mat4(1.0, 0.0, 0.0, 0.0, 0.0, c, -s, 0.0, 0.0, s, c, 0.0, 0.0, 0.0, 0.0, 1.0);\n}\nmat4 rotateY(float angle)\n{\n\tangle = -angle/180.0*3.1415926536;\n    float c = cos(angle);\n    float s = sin(angle);\n\treturn mat4(c, 0.0, s, 0.0, 0.0, 1.0, 0.0, 0.0, -s, 0.0, c, 0.0, 0.0, 0.0, 0.0, 1.0);\n}\nmat4 rotateZ(float angle)\n{\n\tangle = -angle/180.0*3.1415926536;\n    float c = cos(angle);\n    float s = sin(angle);\n\treturn mat4(c, -s, 0.0, 0.0, s, c, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);\n}\nmat4 translate(vec3 t)\n{\n\treturn mat4(1.0, 0.0, 0.0, -t.x, 0.0, 1.0, 0.0, -t.y, 0.0, 0.0, 1.0, -t.z, 0.0, 0.0, 0.0, 1.0);\n}\n\nvec3 repeat(vec3 p, vec3 s)\n{\n\treturn mod(p, s) - s/2.0;\n}\n    \n    \nfloat sphere(vec3 p, float d)\n{ \n    return length(p) - d/2.0;  \n}\n\nfloat box(vec3 p, vec3 s)\n{ \n    vec3 w = abs(p) - s/2.0;\n    return min(max(w.x,max(w.y,w.z)),0.0) + length(max(w,0.0));   \n}\n\nfloat capsule(vec3 p, float h, float d)\n{\n    float x = clamp(p.y/h, 0.0, 1.0);\n    return length(p - vec3(0.0, h*x, 0.0)) - d*0.5;\n}\n    \nDistance add(Distance d1, Distance d2)\n{\n    if (d2.value > d1.value)\n        return d1;\n    else\n        return d2;\n}\n\nDistance smooth_add(Distance d1, Distance d2, float k)\n{\n    float a = d1.value;\n    float b = d2.value;\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return Distance(mix(b, a, h) - k*h*(1.0-h), mix(d2.color, d1.color, pow(h, 2.0)));\n}\n\nDistance intersection(Distance d1, Distance d2)\n{\n\tif (d1.value > d2.value)\n\t\treturn d1;\n\telse\n\t\treturn d2;\n}\n    \nDistance distance2(vec3 p0)\n{         \n    vec4 p = vec4(p0, 1.0);\n    mat4 m;   \n    \n        \n    vec3 color = vec3(0.7, 0.52, 0.4) * 0.7;// * (sin(p.x*30.0)*sin(p.y*2.0)*sin(p.z*30.0)*0.1+0.7);    \n    \n    Distance d = Distance(sphere(p0 + vec3(0.0, 100.0, 0.0), 200.0) + sin(p.x/2.0)*cos(p.z/2.0)/2.0, vec3(0.2, 0.8, 0.5));\n    \n    \n    d = smooth_add(d, Distance(capsule(p.xyz, 3.0, 0.6), color), 0.8);     \n    \n    p *= rotateY(sin(iTime)*2.0+sin(p.y)*2.0); \n    m = translate(vec3(0.0, 3.0, 0.0)) * rotateY(40.0) * rotateX(35.0);    \n    p.x = abs(p.x) - 0.05;\n    p.z = abs(p.z) - 0.05;    \n    p = p * m;    \n    d = smooth_add(d, Distance(capsule(p.xyz, 2.0, 0.4), color), 0.1); \n    \n    p *= rotateY(10.0+sin(iTime+p.x)*5.0+sin(p.x)*5.0);    \n    m = translate(vec3(0.0, 2.0, 0.0)) * rotateY(45.0) * rotateX(30.0);    \n    p.x = abs(p.x) - 0.03;\n    p.z = abs(p.z) - 0.03;\n    p = p * m;    \n    d = smooth_add(d, Distance(capsule(p.xyz, 1.5, 0.2), color), 0.1); \n    \n    p *= rotateY(15.0+sin(iTime+p.z)*8.0+cos(p.z)*8.0);  \n    m = translate(vec3(0.0, 1.5, 0.0)) * rotateY(55.0+sin(p.x)*10.0) * rotateX(35.0);    \n    p.x = abs(p.x) - 0.01;\n    p.z = abs(p.z) - 0.01;\n    p = p * m;    \n    d = smooth_add(d, Distance(capsule(p.xyz, 2.3, 0.08), color), 0.1); \n    \n    \n    float leafSize = min(sin(iTime / 3.0) * 0.06 + 0.11, 0.15);\n    vec3 leafColor = hsv2rgb(vec3(cos((iTime) / 3.0 + sin((p.x+p.y+p.z)*5.0)/3.0) * 0.14 + 0.18, 0.7, 0.8));\n    \n    vec4 r = p;\n    r.x = abs(r.x);\n    r.z = abs(r.z);\n    Distance leafs = Distance(max(sphere(repeat((r.xyz+vec3(0.0, 0.09, 0.1))/vec3(1.0, 2.0, 1.0)-vec3(0.05), vec3(0.19, 0.2, 0.19)), leafSize), box(p.xyz, vec3(0.03, 4.6, 0.2))), leafColor);\n    d = add(d, leafs);\n    \n    p *= rotateY(10.0+sin(iTime+r.x)*10.0+sin(r.x)*10.0);  \n    m = translate(vec3(0.0, 1.0, 0.0)) * rotateY(55.0) * rotateX(40.0);    \n    p.x = abs(p.x) - 0.01;\n    p.z = abs(p.z) - 0.01;\n    p = p * m;    \n    d = smooth_add(d, Distance(capsule(p.xyz, 1.2, 0.04), color), 0.1); \n    \n    p.x = abs(p.x);\n    p.z = abs(p.z);\n    leafs = Distance(max(sphere(repeat((p.xyz+vec3(0.0, 0.0, 0.1))/vec3(1.0, 2.0, 1.0)-vec3(0.05), vec3(0.19, 0.2, 0.19)), leafSize), box(p.xyz, vec3(0.03, 2.5, 0.2))), leafColor);\n    d = add(d, leafs); \n    \n    \n    return d;\n}\n\nHit castRay(inout vec3 p, vec3 dir)\n{\t\n\tHit hit;\n\tDistance dist = distance2(p);\n\tfloat eps = 0.001;\n\t\n\tfor (int i = 0; i < MAX_STEPS; i++)\n\t{\n\t\tDistance dist = distance2(p);\n\t\tfloat d = dist.value;\n                \n\t\tif (d <= eps)\n\t\t{\n            hit.is = true;\n            hit.pos = p;\n            hit.color = dist.color * (1.0 - float(i) / float(MAX_STEPS));\n            return hit;\n\t\t}\n        \n\t\tp += dir*d*0.9;\n\t}\t\n\thit.is = false;\n\thit.color = vec3(0);\n\treturn hit;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 angle = vec2(-iMouse.x/200.0+2.2, radians(25.0));\n    vec3 center = vec3(0.0, 4.0, 0.0);\n    float zoom = 10.0;\n    \n    vec3 p = vec3(cos(angle.x)*cos(angle.y), sin(angle.y), sin(angle.x)*cos(angle.y));\n\tvec2 uv = (fragCoord.xy) / iResolution.yy - vec2(iResolution.x / iResolution.y / 2.0, 0.5);\n    \n    vec3 tx = vec3(-sin(angle.x), 0.0, cos(angle.x));\n    vec3 ty = vec3(-cos(angle.x)*sin(angle.y), cos(angle.y), -sin(angle.x)*sin(angle.y));\n    \n    vec3 p2 = p * 0.8;\n    p = p * zoom + center;\n    \n    vec3 dir = tx * uv.x + ty * uv.y - p2;\n    \n    vec3 color = vec3(0.0);\n    vec3 light = normalize(vec3(-0.6, 0.8, -0.3));\n    \n    \n\tHit hit = castRay(p, dir);\n    \n\tif (hit.is)\n    {        \n        vec3 normal;\n\t\tfloat eps = 0.001;\n        normal.x = distance2(p + vec3(eps,0,0)).value - distance2(p - vec3(eps,0,0)).value;\n        normal.y = distance2(p + vec3(0,eps,0)).value - distance2(p - vec3(0,eps,0)).value;\n        normal.z = distance2(p + vec3(0,0,eps)).value - distance2(p - vec3(0,0,eps)).value;\n        normal = normalize(normal);\n        vec3 c = mix(hit.color, vec3(0.8), normal.y * pow(1.0 - (cos(iTime / 3.0 - 1.5) / 2.0 + 0.5), 4.0) * (sign(hit.pos.y - 1.0) / 2.0 + 0.5));\n\t\tcolor = c * (max(dot(normal, light), 0.0) * 0.8 + 0.4) * min(5.0/length(p-vec3(0.0, 5.0, 0.0)), 2.0);\n        \n    }\n\telse\n\t\tcolor = vec3(0);\n\t\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt3yWS.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[108, 108, 130, 130, 299], [405, 405, 432, 432, 609], [610, 610, 637, 637, 814], [815, 815, 842, 842, 1019], [1020, 1020, 1044, 1044, 1143], [1145, 1145, 1174, 1174, 1203], [1214, 1214, 1245, 1245, 1280], [1282, 1282, 1309, 1309, 1408], [1410, 1410, 1451, 1451, 1543], [1549, 1549, 1589, 1589, 1667], [1669, 1669, 1725, 1725, 1910], [1912, 1912, 1961, 1961, 2021], [2027, 2027, 2056, 2056, 4325], [4327, 4327, 4364, 4364, 4800], [4802, 4802, 4857, 4857, 6257]], "test": "ok"}
{"id": "Mt3yzf", "name": "Water Wave", "author": "TanayStyle", "description": "Water waves", "tags": ["waves", "water", "blue"], "likes": 2, "viewed": 154, "published": "Public", "date": "1533418584", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define tau 6.28318530718\n\nfloat sin01(float x) {\n\treturn (sin(x*tau)+1.)/2.;\n}\nfloat cos01(float x) {\n\treturn (cos(x*tau)+1.)/2.;\n}\n\n//cos between m and 1\nfloat cosm1(float x, float m) {\n    float c = 1. - m;\n\tfloat y = cos(x*tau/2.)*c+(1.-c);\n    return y/2. + .5;\n}\n\nfloat smoothFract(float x, float blurLevel) {\n\treturn pow(cos01(x), 1./blurLevel);\n}\n\nfloat euclDist(vec2 from, vec2 to) {\n\treturn length(from - to);\n}\n\nfloat circ(vec2 uv, vec2 pos, float radius) {\n    float dist = euclDist(uv, pos);\n    return smoothstep(radius, 0., dist);\n}\n\nvec2 rot(vec2 v, float angle) {\n    mat2 m;\n    m[0] = vec2(cos(angle), sin(angle));\n    m[1] = vec2(-sin(angle), cos(angle));\n    return m * v;\n}\n\nvec3 vignette (vec2 uv, vec3 col, float amt) {\n    float len = clamp(0.,1.,length(uv));\n    return col * smoothstep(1., 0., len * amt);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Pixel coordinates centered at 0,0\n    vec2 uv = (fragCoord-iResolution.xy/2.)/iResolution.xy;\n    float aspectRatio = iResolution.x / iResolution.y;\n\tuv.x *= aspectRatio;\n\n    float t = iTime * .2;\n    \n\t// Distort uv coordinates\n    float amplitude = .2;\n    float turbulence = 1.3;\n    uv.xy += sin01(uv.x*turbulence + t) * amplitude;\n    uv.xy -= sin01(uv.y*turbulence + t) * amplitude;\n    \n    // Rotate grid as time goes by\n    uv.xy = rot(uv.xy, t / 2.);\n    \n    //uv.xy = shear(uv.xy, t);\n    \n    // Create grid\n    float gridSize = 4.;\n    \n    // Define lines\n    float bright = 0.;\n    float blurAmount = 0.2;\n    float linesX = smoothFract(uv.y * gridSize, blurAmount);\n    bright = linesX;\n    \n    float linesY = smoothFract(uv.x * gridSize, blurAmount);\n    bright += linesY;\n    \n    // Convert lines to color\n    vec3 linesColor = vec3(.42,.8,1.);\n    vec3 col = linesColor*bright;\n    \n    // Background color\n    vec3 backgroundColor = vec3(0.2,.6,.9);\n    col += backgroundColor*(1.-bright);\n    \n    // Apply vignette\n    col = vignette(uv, col, .4);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt3yzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 49, 49, 79], [80, 80, 102, 102, 132], [134, 156, 187, 187, 268], [270, 270, 315, 315, 354], [356, 356, 392, 392, 421], [423, 423, 468, 468, 547], [549, 549, 580, 580, 695], [697, 697, 743, 743, 834], [836, 836, 893, 934, 2036]], "test": "ok"}
{"id": "MtccW2", "name": "Siggraph logo I", "author": "benoitM", "description": "While beeing at Siggraph 2018, here is my tribute . ", "tags": ["procedural", "2d", "logo", "siggraph"], "likes": 6, "viewed": 444, "published": "Public API", "date": "1534345171", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Benoit Marini - 15/08/2018\n// SIGGRAPH Logo I\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define E(p,d) step(dot(f=(z+p)/d,f),1.) //ellipse center p, size d\n#define V vec2\n\nvoid mainImage( out vec4 o,in V f )\n{   \n    V z = (f/iResolution.y-.5)*mat2(1,.7,-.7,1),\n    //  SIGGRAPH ellipse\n    a=V(0,.04), b=V(.45,.145), c=V(.08,.015), d=V(.39,.14) ;\n    // SIGGRAPH shape \n    float S = 2.*E(.0,.5)-1.\n        - max ( E(.0,.46)-E(.0, V(.52,.22)) ,0.) \n        - max ( E(-a,b)-E(-c,d) , E(a,b)-E(c,d)) ,\n    t=iTime*.25,\n    u=floor(t),\n    v=t-u,\n    q=5.*u+t/8e1;\n \n    // procedural col    \n    o = vec4 (z*5e2,5,5);    \n    for (int i=0; i++<92;) o.xzyw = abs( o/dot(o,o)- vec4(.7+.2*cos(q),.2+.2*sin(q*1.9),0,0)); \n    \n    o*=pow(v,.3);\n    //output  v       \n    o=(S <.0)? o-o : S*o-o+1.;\n    o=pow(o,vec4(2,4,3,1));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtccW2.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[232, 232, 269, 269, 883]], "test": "ok"}
{"id": "MtcyRX", "name": "Function - Ripple", "author": "matt77hias", "description": "A ripple function.", "tags": ["function"], "likes": 1, "viewed": 92, "published": "Public", "date": "1533390280", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float speed = 1.0f;\n\nvoid mainImage(out vec4 color, in vec2 fragCoord) {\n    vec2  position = fragCoord - 0.5f * iResolution.xy;\n    float radius   = length(position);\n    float value    = 0.5f + 0.5f * cos(radius / 7.0f - iTime / speed) / (radius / 7.0f + 1.0f);        \n    \n    color = vec4(vec3(value), 1.0f);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtcyRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 72, 72, 315]], "test": "ok"}
{"id": "MtdcRX", "name": "soft squigs", "author": "pixlpa", "description": "some generative swirling forms", "tags": ["flat", "animated", "liquid"], "likes": 5, "viewed": 203, "published": "Public", "date": "1533510172", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// Value Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/lsf3WH\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = smoothstep(0.,1.,f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    vec2 aspect = vec2(iResolution.x/iResolution.y,1.);\n\n    // Time varying pixel color\n    vec2 uvblop = (uv-aspect*0.5)*3.;\n    float rotate = iTime*0.2;\n    uvblop *= mat2(cos(rotate), -sin(rotate), sin(rotate), cos(rotate));\n    uvblop += uvblop*smoothstep(2.5,0.,length(uvblop))*-3.;\n    vec3 col = vec3(noise(uv*0.2+vec2(0.,iTime*0.5)))*vec3(0.9,0.2,0.5)*0.85+0.85;\n    col.r += noise(uvblop*0.3+vec2(11.,iTime*0.15))*0.43;\n    col.g += noise(uvblop*0.25+vec2(16.,iTime*0.18))*0.63;\n    col.b += noise(uvblop*0.15+vec2(14.,iTime*0.25))*0.33;\n   \n    float clod = noise((uvblop *0.5+ vec2(noise(uv*3.3),noise(uv*7.4+vec2(-iTime*0.1,0.)))*0.5)*4.+vec2(iTime*0.4,0.));\n    col.r += (clod-0.35)*1.45 * step(0.14,clod);\n    clod = noise((uvblop *0.5+ vec2(noise(uv*3.3+0.05),noise(uv*7.4+vec2(-iTime*0.1,0.)+0.1))*0.5)*4.+vec2(iTime*0.4,0.));\n    col.g += (clod-0.35)*1.75 * step(0.17,clod);\n\tclod = noise((uvblop *0.5+ vec2(noise(uv*3.3+0.07),noise(uv*7.4+vec2(-iTime*0.1,0.)+0.2))*0.5)*4.+vec2(iTime*0.4,0.));\n    col.b += (clod-0.25)*1.85 * step(0.1,clod);\n\n    // Output to screen\n    fragColor = vec4(col*0.5+0.5,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtdcRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 161], [163, 245, 267, 267, 675], [679, 679, 736, 786, 1952]], "test": "timeout"}
{"id": "MtdyRX", "name": "Gradient X", "author": "momoro", "description": "Gradients and xs", "tags": ["bookofshaders"], "likes": 1, "viewed": 353, "published": "Public API", "date": "1533504546", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n#define PI 3.141592654\n\nfloat atan201(float x, float y) {\n    return (atan(x, y) + PI) / (PI * 2.);\n}\n\nfloat sin01(float n) {\n    return sin(n)/2.+.5;\n}\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                    vec2(12.9898,78.233)))*\n        \t\t\t43758.5453123);\n}\n\n\nfloat noise(float s) {\t\n    float i = floor(s);\n    float f = fract(s);\n    float n = mix(random(vec2(i, 0.)), \n                  random(vec2(i+1., -0.568)), \n                  smoothstep(0., 1., f)); \n   \n    return n;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    \n    vec2 st = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\n    st *= 0.376;\n    st += sin(st *-20.216).x * length(st)  * (sin(iTime) + 1.) * 20.192 * pow(length(st), .08) * 0.049;\n    \n    float f = 1.0 - length(st);\n    float seed = abs(sin(atan(st.x, st.y) * 1.040) );\n    f += noise(seed*5.752) * 0.656 ;\n    float a = f;\n    a = smoothstep(0.780, 1.608, f);\n    a += smoothstep(0.780, 0.072, f) * 1.376;\n    a = pow(a, 0.976);\n\n\n    vec3 color = vec3(a);\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtdyRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 59, 59, 103], [105, 105, 127, 127, 154], [156, 156, 184, 184, 290], [293, 293, 315, 315, 514], [517, 517, 574, 574, 1086]], "test": "ok"}
{"id": "MtdyWj", "name": "twisty cuby", "author": "DJDoomz", "description": "what is this, 1999?\n\n(help i can't seem to stop making 3d rotating cubes)", "tags": ["3d", "raytracing", "plasma", "dithering"], "likes": 9, "viewed": 765, "published": "Public API", "date": "1534266181", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//force 20 fps\n//#define iTime (floor(iTime*20.)/20.)\n\nfloat t;\n\nmat2 rot(float a)\n{\n    float s = sin(a), c = cos(a);\n    return mat2(c,s,-s,c);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  //p = fract(p/10.)*10.-5.;\n  //p = sin(p/6.)*6.;\n  p.xz *= rot(t);\n  p.yx *= rot(.6*t);\n  \n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdRay(vec3 p, vec3 s, vec3 e){\n    e = s + e;\n    vec3 l1 = p-s;\n    vec3 l2 = (e-s)*(max( dot(l1,(e-s) ) /(dot(e-s,e-s)), 0.) );\n    \n    return length(l1-l2)-.2;\n}\n\nfloat map(vec3 p){\n    float b = sdBox(p-vec3(0,0,7),vec3(2.7));\n    return b;\n}\n\nvec3 norm(vec3 p){\n    vec2 xz = dFdx(p).xz;\n    vec2 yz = dFdy(p).yz;\n    vec3 xyz = vec3(-xz.x,yz.y,(xz.y+yz.y)/2.);\n    return normalize(xyz);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    //vec2 uv = 2.*fragCoord/iResolution.xy-1.;\n    vec2 tuv = fragCoord/iResolution.xy;\n    \n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;    \n    \n    t = iTime+.2*sin(uv.x*1.76+uv.y*1.+iTime);\n    \n    vec3 p = vec3(0,0,-2);\n    p.y += .6*sin(iTime);\n    vec3 rd = normalize(vec3(uv,1.4));\n    \n    //rd.xz*=rot(iTime);\n        \n    float d =9999.;\n    \n    for(int i = 0; i < 14; i++)\n    {\n        d = map(p);\n        p += rd*d;\n        if(d < .001 || d > 10.) break;\n    }\n    \n    vec3 n;\n    n = norm(p);\n    \n    vec3 ld = normalize(vec3(0.5,.0,-.4));\n    \n    float l = max(0.4,dot(-n,ld));\n    //vec3 c = .5+.5*sin( sin(6.*n)+3.*length(p)+3.*iTime );\n               \n    d = l/(d*d+.6);\n\n    // Output to screen\n    fragColor = d*(.4+.3* abs(sin(length(2.*cos(p))*n+t)).rgbb);\n    float b = texelFetch(iChannel0, ivec2(fragCoord)/2%8,0).r;\n    fragColor = floor(fragColor*4.+2.*b-1.)/4.;\n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtdyWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 65, 84, 84, 147], [149, 149, 180, 231, 360], [362, 362, 398, 398, 533], [535, 535, 553, 553, 615], [617, 617, 635, 635, 764], [766, 766, 823, 922, 1788]], "test": "error"}
{"id": "Mtdyzf", "name": "wikipedia shadertoy shader", "author": "shakthi_gs87", "description": "wikipedia shadertoy sample shader from https://en.wikipedia.org/wiki/Shadertoy\n\nUsed for test on threejs here  https://shakthi.github.io/threejs-shadertoy/dist/", "tags": ["wikipediashadertoy"], "likes": 2, "viewed": 1408, "published": "Public API", "date": "1533548930", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // input: pixel coordinates\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n    // angle of each pixel to the center of the screen\n    float a = atan(p.y,p.x);\n    \n    // modified distance metric\n    float r = pow( pow(p.x*p.x,4.0) + pow(p.y*p.y,4.0), 1.0/8.0 );\n    \n    // index texture by (animated inverse) radious and angle\n    vec2 uv = vec2( 1.0/r + 0.2*iTime, a );\n\n    // pattern: cosines\n    float f = cos(12.0*uv.x)*cos(6.0*uv.y);\n\n    // color fetch: palette\n    vec3 col = 0.5 + 0.5*sin( 3.1416*f + vec3(0.0,0.5,1.0) );\n    \n    // lighting: darken at the center    \n    col = col*r;\n    \n    // output: pixel color\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mtdyzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 89, 742]], "test": "ok"}
{"id": "Mtdyzl", "name": "Sunday Morning", "author": "qjcm", "description": "It's early on a Sunday morning.\nThere isn't any wind yet, there will be later though.\nIt's very calm out here.\nDefinitely worth getting up so early.\nA fog horn goes off in the distance.\n", "tags": ["procedural", "raymarching", "noise", "waves", "water", "fog", "mist"], "likes": 5, "viewed": 199, "published": "Public", "date": "1533739847", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n * \"Sunday Morning\" by Quentin Corker-Marin, 2018\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * Contact: quentinjcm@hotmail.com\n */\n\nconst vec3 SUN_DIR = vec3(0.323768, 0.2 , -0.940721);\nconst vec3 SUN_COL = vec3(1.1, 0.9, 0.6);\nconst vec3 WATER_TINT = vec3(0.026, 0.118, 0.071);\n\n/////////////////////////////////////////\n// STRUCTS\n// question: are structs bad form? should I use in and out instead?\n/////////////////////////////////////////\nstruct ray {\n    vec3 o;\n    vec3 d;\n};\n    \nstruct sdf {\n    float d;\n    float id;\n};\n    \n\n/////////////////////////////////////////\n// TRANSFORMATIONS\n///////////////////////////////////////// \nmat3 ry( float rad  ){\n\tmat3 m;\n    m[0] = vec3(cos( rad ), 0., -sin( rad ));\n    m[1] = vec3(0.0, 1.0, 0.0);\n    m[2] = vec3(sin( rad ), 0.0, cos( rad ));\n    return m;\n}\n\n\n/////////////////////////////////////////\n// SDF OPS\n///////////////////////////////////////// \nsdf opU( sdf x, sdf y ) {\n    sdf res;\n    res.d = min( x.d, y.d );\n    float x_is_min = 1.0 - abs( sign( res.d - x.d ) );\n    res.id = mix( y.id, x.id, x_is_min );\n\treturn res;    \n}\n\nfloat rand( float seed ) {\n\treturn fract( fract( sin( seed ) ) * 1e4 );\n}\n    \n\n/////////////////////////////////////////\n// FAST 2D NOISE: https://www.shadertoy.com/view/Ms2SD1\n///////////////////////////////////////// \nfloat hash( vec2 p ) {\n\tfloat h = dot( p, vec2(127.1,311.7) );\t\n    return fract( sin( h ) * 43758.5453123 );\n}\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f * f * (  3.0 - 2.0 * f );\n    return -1.0 + 2.0 * mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0, 0.0) ), u.x ),\n                mix( hash( i + vec2(0.0, 1.0) ), \n                     hash( i + vec2(1.0, 1.0) ), u.x ), u.y );\n}\n\n\n/////////////////////////////////////////\n// SLOWER 3D SIMPLEX NOISE: www.shadertoy.com/view/XsX3zB\n///////////////////////////////////////// \nvec3 random3( vec3 c ) {\n\tfloat j = 4096.0 * sin( dot( c, vec3(17.0, 59.4, 15.0) ) );\n\tvec3 r;\n\tr.z = fract( 512.0 * j );\n\tj *= 0.125;\n\tr.x = fract( 512.0 * j );\n\tj *= 0.125;\n\tr.y = fract( 512.0 * j );\n\treturn r - 0.5;\n}\n\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\nfloat snoise(vec3 p) {\n\n\tvec3 s = floor(p + dot(p, vec3(F3)));\n\tvec3 x = p - s + dot(s, vec3(G3));\n\t \n\tvec3 e = step(vec3(0.0), x - x.yzx);\n\tvec3 i1 = e*(1.0 - e.zxy);\n\tvec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\tvec3 x1 = x - i1 + G3;\n\tvec3 x2 = x - i2 + 2.0*G3;\n\tvec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\tvec4 w, d;\n\t \n\tw.x = dot(x, x);\n\tw.y = dot(x1, x1);\n\tw.z = dot(x2, x2);\n\tw.w = dot(x3, x3);\n\t \n\tw = max(0.6 - w, 0.0);\n\t \n\td.x = dot(random3(s), x);\n\td.y = dot(random3(s + i1), x1);\n\td.z = dot(random3(s + i2), x2);\n\td.w = dot(random3(s + 1.0), x3);\n\t \n\tw *= w;\n\tw *= w;\n\td *= w;\n\t \n\treturn dot(d, vec4(52.0));\n}\n\n\n/////////////////////////////////////////\n// SCENE DISTANCE ESTIMATORS\n/////////////////////////////////////////\nfloat estimateWaterBase( vec3 p ) {\n    mat3 m = ry( -0.436471 );\n    p *= m;\n    float d = p.y;\n    float n1 = noise( p.xz * 0.25 );\n    d += sin( p.x / 2.0 - iTime * 0.5 ) * 0.1 * n1;\n    d += sin( p.x - iTime*1.0 ) * 0.05;\n    d += sin( p.x * 3.0 - iTime * 1.5 ) * 0.02;\n    d += sin( ( p.x + 1.0 )*3.0 - iTime*1.5 ) * 0.02;\n    d += sin( ( p.x + 2.0 )*5.0 - iTime*3.0 ) * 0.001; \n    return d;\n}\n\nfloat estimateWaterRipples( vec3 p ) {\n    mat3 m = ry( -0.436471 );\n    p *= m;\n    p.y = iTime;\n    float n1 = snoise( p * vec3(1.0, 0.0, 1.0) + vec3(0.0, iTime * 0.5, 0.0) ) * 0.008;\n    float n2o = noise( p.xz * vec2(2.0, 2.0) + vec2(iTime * 0.5, 0.0) ) * 0.5;\n    float n2 = snoise( p * vec3(1.5, 0.0, 1.5) + vec3(n2o, iTime * 0.75, 0.0) ) * 0.004;\n    float n3 = snoise( p * vec3(6.0, 0.0, 6.0) + vec3(0.0, iTime, 0.0) ) * 0.0008;\n    return ( n1 + n2 + n3);\n}\n\nfloat estimateWater( vec3 p ){\n    return estimateWaterBase( p ) + estimateWaterRipples( p ); \n}\n\nvec3 getWaterHeight( vec3 p ) {\n    ray r;\n    r.o = vec3(p.x, 10, p.z);\n    r.d = vec3(0, -1, 0);\n    int hit = 0;\n    float t;\n    for (t = 0.01; t < 5.0;){\n    \tfloat e = estimateWaterBase( r.o + r.d * t );\n        if ( e < 0.01 ){\n        \thit = 1;\n            break;\n        }\n        t += e;\n    }\n    return vec3(r.o + r.d * t);\n}\n\nfloat estimateFarBuoys( vec3 p ) {    \n    float freq = 0.15;\n    float fl_x = floor( p.x * freq );\n    float p_x = ( fl_x + rand( fl_x ) - 0.5 ) / freq;\n    vec3 buoy_p = vec3( p_x, 0.0, -14.0 + rand( fl_x + 500.0 ) * 3.0 );\n    \n    vec3 water_level = getWaterHeight( buoy_p );\n    water_level.y += 0.05;\n\n    return distance( p, water_level ) - 0.2;\n}\n\nfloat estimateMidBuoys( vec3 p ) {\n    float freq = 0.05;\n    float fl_x = floor( p.x * freq );\n    float p_x = ( fl_x + rand( fl_x ) + 0.5 ) / freq;\n    vec3 buoy_p = vec3( p_x, 0.0, -2.0 + rand( fl_x + 100.0 ) * 2.0 );\n    \n    vec3 water_level = getWaterHeight( buoy_p );\n\twater_level.y += 0.05;\n \n    return distance( p, water_level ) - 0.2;;\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r ) {\n    //http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n    return length( max( abs( p ) - b, 0.0 ) ) - r; \n}\n\nfloat estimateBreakwaters( vec3 p ) {\n    vec3 mod_p = p; \n    vec3 reps = vec3( 30.0, 1.0, 1.5 );\n    vec3 floor_p = floor( p * reps - reps / 2.0 );\n    float r1 = rand( floor_p.x * floor_p.z );\n    float r2 = rand( floor_p.x * floor_p.z + 100.0 );\n    float r3 = rand( floor_p.x * floor_p.z + 110.0 );\n    mod_p.x = mod( p.x, reps.x )-reps.x / 2.0;\n    mod_p.z = mod( min( p.z, -13.0 + r3 * 0.1 ), reps.z ) - reps.z / 2.0;\n    \n    float w = mix( 0.03, 0.05, r2 );\n    vec3 b = vec3( w, 0.1 + r1 * 0.5, w );\n    return udRoundBox( mod_p, b, 0.01 );;\n}\n\nfloat estimateWaterElements( vec3 p ) { \n\tfloat far_buoys = estimateFarBuoys( p );\n    float mid_buoys = estimateMidBuoys( p );\n    float breakwaters = estimateBreakwaters( p );\n    return min( min( far_buoys, mid_buoys ), breakwaters );\n}\n\nsdf estimate( vec3 p ) {                     \n    sdf grid;\n    grid.id = 1.0;\n    grid.d = estimateWater( p );\n    \n    sdf water_elements;\n    water_elements.id = 0.0;\n    water_elements.d =  estimateWaterElements( p );\n\n    return opU( grid, water_elements );  \n}\n\nvec3 waterGrad( vec3 p ) {\n    float o = estimateWater( p );\n    float dx = estimateWater( p - vec3(0.001, 0., 0.) );\n    float dy = estimateWater( p - vec3(0., 0.001, 0.) );\n    float dz = estimateWater( p - vec3(0., 0., 0.001) );\n    \n    vec3 grad = vec3( o - dx, o - dy, o - dz );\n\treturn normalize( grad );\n}\n\n\nvec2 toNDC(vec2 frag_cord){\n    vec2 uv = frag_cord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    return uv;\n}\n\nray genRay( vec2 ndc ) {\n    //camera positioning and allignment\n    vec3 cam_pos = vec3(0.0, 1.0, 5.0);\n    vec3 cam_tar = vec3(0.0);\n    vec3 cam_up = vec3(0.0, 1.0, 0.0);\n    \n    //cam animation\n    cam_pos.y += sin( iTime * 2.0 ) * 0.05;\n    cam_tar.y += sin( ( iTime - 0.3 ) * 2.0 ) * 0.05;\n    cam_up.z += sin( iTime * 2.0 ) * 0.001;\n    \n    vec3 cam_dir = normalize(cam_tar - cam_pos);   \n    \n    //camera space s and t vectors\n    vec3 cam_s = normalize(cross(cam_dir, cam_up));\n    vec3 cam_t = cross(cam_s, cam_dir);\n    \n    cam_pos -= cam_s * iTime * 0.2;\n    \n    //intersection with \"film\" plane\n    vec3 cam_c = cam_pos + cam_dir;\n    vec3 cam_i = cam_c + cam_s * ndc.x + cam_t * ndc.y;\n    \n    //build ray\n    ray r;\n    r.o = cam_pos;\n    r.d = normalize( cam_i - cam_pos );\n    return r;\n}\n\nvec3 sphereLookUp( vec3 dir ) {\n    // a \"hdri\" for for water reflection lookup\n    //vertical fade\n    vec3 horizon_col = vec3(0.8, 0.8, 0.9);\n    vec3 up_col = vec3(0.0, 0.12, 0.9);\n    float ver_mix = dot( dir, vec3(0.0, 1.0, 0.0) ) * 2.0;\n    vec3 vert_fade = mix( horizon_col, up_col, ver_mix );\n    \n    //sun spot\n\tfloat sun_ang = dot( dir, SUN_DIR );\n    float sun_int = smoothstep( 0.7, 1.0, sun_ang ); \n    vec3 sun_spot = SUN_COL * sun_int * 2.0;\n    float sun_int_inner = smoothstep( 0.95, 1.0, sun_ang );\n    vec3 sun_spot_inner = SUN_COL * sun_int * 4.0;\n    \n\treturn vert_fade + sun_spot;\n}\n\nfloat traceRefl( ray r ){\n\tfloat t;\n    for( t = 0.01; t < 5.0; ){\n    \tfloat e = estimateWaterElements( r.o + r.d * t );\n        if( e < 0.01 ){\n        \treturn 0.0;\n        }\n        t += e;\n    }\n    return 1.0;\n}\n\nvec3 shadeWater(ray r, float t){\n    vec3 hit_p = r.o + r.d * t;\n    vec3 n = waterGrad(hit_p);\n    \n    float cosi = dot(-r.d, n);\n    vec3 refl_dir = r.d + 2.0 * cosi * n;\n    vec3 refl_col = sphereLookUp( refl_dir );\n    float refr_depth = 0.752 * cosi;\n    vec3 refr_col = mix( WATER_TINT, vec3(-0.8), clamp( refr_depth, 0.01, 0.999 ) );\n    \n    float icosi = 1.0 - cosi;\n    float rschlick = 0.02 + 0.98 * icosi * icosi * icosi * icosi * icosi;\n    \n    ray refl;\n    refl.o = hit_p;\n    refl.d = refl_dir;\n    float refl_hit = traceRefl(refl);\n\n    return mix(refr_col, refl_col * refl_hit, rschlick);\n    \n}\n\nvec3 applyFog(vec3 col, ray r, float t){\n\t//http://www.iquilezles.org/www/articles/fog/fog.htm\n    float fog_amount = 1.0 - exp(-t*0.18);\n    float sun_amount = max(dot(r.d, SUN_DIR) , 0.0);\n    sun_amount = sun_amount * sun_amount * sun_amount * sun_amount * sun_amount * sun_amount * sun_amount * sun_amount * sun_amount * sun_amount * sun_amount * sun_amount * sun_amount * sun_amount;\n    vec3 fog_color = mix(vec3(0.7, 0.8, 0.9), vec3(1.5, 1.4, 1.3), sun_amount);\n    return mix(col, fog_color, fog_amount);\n}\n\nvec3 renderScene( ray r ) {\n\tfloat hit = 0.0;\n    sdf e;\n    float t = 0.0;\n    for ( t = 0.001; t < 30.0; ){\n    \te = estimate( r.o + r.d * t );\n        if( e.d < 0.001 ){\n        \thit = 1.0;\n            break;\n        }\n        t += e.d;\n    } \n    vec3 out_col = mix( vec3(0.0), shadeWater( r, t ), e.id );\n    out_col = applyFog( out_col, r, t );\n    return out_col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 ndc = toNDC( fragCoord );\n    ray r = genRay( ndc );\n    vec3 c = renderScene( r );\n    float vignette = clamp( ( 1.1 - length( ndc * 0.7 ) ), 0.0, 1.0 );\n    c *= vignette;\n    c *= 0.6;\n    c = pow( c, vec3(0.4545) );\n    fragColor = vec4(c, 1.0);\n}", "image_inputs": [{"id": "lsBXDV", "previewfilepath": "https://soundcloud.com/user-876112150/lake", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/user-876112150/lake", "ctype": "musicstream"}, {"id": "MlfGRX", "previewfilepath": "https://soundcloud.com/matwhill/inertia", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/matwhill/inertia", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mtdyzl.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[585, 689, 711, 711, 860], [863, 959, 984, 984, 1142], [1144, 1144, 1170, 1170, 1217], [1224, 1365, 1387, 1387, 1476], [1477, 1477, 1503, 1503, 1825], [1828, 1971, 1995, 1995, 2191], [2252, 2252, 2274, 2274, 2854], [2857, 2970, 3005, 3005, 3369], [3371, 3371, 3409, 3409, 3837], [3839, 3839, 3869, 3869, 3935], [3937, 3937, 3968, 3968, 4274], [4276, 4276, 4310, 4310, 4630], [4632, 4632, 4666, 4666, 4980], [4982, 4982, 5027, 5100, 5154], [5156, 5156, 5193, 5193, 5709], [5711, 5711, 5750, 5750, 5950], [5952, 5952, 5976, 5976, 6218], [6220, 6220, 6246, 6246, 6533], [6536, 6536, 6563, 6563, 6676], [6678, 6678, 6702, 6742, 7489], [7491, 7491, 7522, 7590, 8096], [8098, 8098, 8123, 8123, 8314], [8316, 8316, 8348, 8348, 8931], [8933, 8933, 8973, 9027, 9447], [9449, 9449, 9476, 9476, 9821], [9824, 9824, 9880, 9880, 10141]], "test": "timeout"}
{"id": "MtKcRm", "name": "Centred Grey Scale Basis", "author": "ngubbins", "description": "Basis for use in more complicated visual effects", "tags": ["basic", "shade", "greyscale"], "likes": 1, "viewed": 68, "published": "Public", "date": "1535601728", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float dimmerScale = 1.0;\nfloat speed = 0.25;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // initial color\n    vec3 col = vec3(1, 1, 1);\n    \n    // Effect Scale and Time Scale\n    float dimmer = abs(sin(iTime * speed)) * dimmerScale;\n    \n      //need to offset uv to be actual centre\n    uv -= vec2(0.5,0.5);\n    \n    //Dim frags further from centre\n  \tcol = col*( vec3(1,1,1) - (length(vec2(0,0) - uv) * dimmer));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtKcRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 103, 153, 639]], "test": "ok"}
{"id": "MtKczh", "name": "Elliptic Curve Bounce", "author": "aaecheve", "description": "Animation of continuous version of ellipctic curve y^3=x^2+7, used for generating public/private key pairs in Bitcoin and other Cryptocurrencies.\nhttps://en.bitcoin.it/wiki/Secp256k1\n\nModulo factor N oscillates to create animation.\n ", "tags": ["bounce", "curve", "ellipctic", "bitcoin", "secp256k1"], "likes": 1, "viewed": 123, "published": "Public", "date": "1535388708", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float SCALE_FACTOR = 30.0;\nfloat EPSILON = 1.0;\n\nvec3 CURVE_COLOR = vec3(0,1,0);\n\nfloat moduloN = 5.0;\n\n\nvec2 scale(vec2 p) {\n\treturn vec2(SCALE_FACTOR, SCALE_FACTOR*iResolution.y/iResolution.x)*(p - 0.5);\n}\n\nbool ellipticCurveMod(vec2 p) {\n    float t = mod(p.y*p.y - p.x*p.x*p.x - 7.0, moduloN);\n\treturn t < EPSILON && t > -EPSILON;\n}\n\nvec3 drawCurve(vec2 pix, vec3 col) {\n\tif(ellipticCurveMod(pix))\n        col = CURVE_COLOR;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    \n    vec2 pix = scale(uv);\n    vec2 p = scale(mouse);\n    \n    //float freq = texture( iChannel0, vec2( 0.01, 0.25 ) ).x;\n\t\n    moduloN = SCALE_FACTOR * (sin(iTime) + 1.1);\n    \n    vec3 col = vec3(0,0,0);\n    col = drawCurve(pix, col);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtKczh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 105, 125, 125, 207], [209, 209, 240, 240, 336], [338, 338, 374, 374, 446], [448, 448, 505, 505, 867]], "test": "ok"}
{"id": "MtKyRR", "name": "Escape Time Sierpinski Triangle", "author": "ptrgags", "description": "This is my attempt to compute the Escape Time algorithm on a Sierpinski triangle fractal.\n\nThis is based on the Escape Time Algorithm presented in Fractals Everywhere 2nd Edition by Michael F. Barnsley.", "tags": ["fractals", "ifs", "sierpinski", "escape"], "likes": 3, "viewed": 116, "published": "Public", "date": "1534959145", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n * Escape time algorithm for the Sierpinski triangle.\n * \n * This is based on an algorithm found in Fractals\n * Everywhere 2nd Edition by Michael F. Barnsley\n * in section VII.1. I translated the code\n * to GLSL and \n */\n\n\n#define MAX_ITERS 20.0\n#define RADIUS 1.0\n#define CENTER (iResolution.xy / 2.0)\n\nvec2 inverse_sierpinski(vec2 point) {\n    //Inverse transform 1: NW\n    if (point.y > 0.0)\n        return 2.0 * point + vec2(0.5, -0.5);\n    else if (point.x > 0.0)\n        return 2.0 * point + vec2(-0.5, 0.5);\n    else\n        return 2.0 * point + vec2(0.5, 0.5);\n}\n\nfloat escape_time(vec2 point) {\n    \n    vec2 z = point;\n    for (float i = 0.0; i < MAX_ITERS; i++) {\n        z = inverse_sierpinski(z);\n        \n        \n        if (length(z) > RADIUS)\n            return i;\n    }\n    return 0.0;\n}\n\nfloat normcos(float x) {\n    return 0.5 + 0.5 * cos(x);\n}\n\nfloat normsin(float x) {\n    return 0.5 + 0.5 * sin(x);\n}\n\nvec4 palette(float n) {\n    /*\n    vec4 result;\n    //result.r = normcos(n - 3.0 * iTime);\n    //result.g = normsin(n - 2.0 * iTime);\n    //result.b = normcos(2.0 * n - iTime);\n    return result;\n\t*/\n    return vec4(0.0, 0.75 * normcos(n - iTime), 0.75 * normsin(n - iTime), 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - CENTER)/iResolution.y;\n    uv *= 1.5;\n    \n    float n = escape_time(uv);\n    \n    fragColor = palette(n);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtKyRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[308, 308, 345, 375, 574], [576, 576, 607, 607, 809], [811, 811, 835, 835, 868], [870, 870, 894, 894, 927], [929, 929, 952, 1128, 1211], [1214, 1214, 1271, 1321, 1457]], "test": "ok"}
{"id": "MtKyRW", "name": "rayuela", "author": "nabr", "description": "damn shaders, totaly sucked me in i have to slow down for a while. ", "tags": ["raymarch"], "likes": 3, "viewed": 179, "published": "Public", "date": "1535384799", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// nabr\n// https://www.shadertoy.com/view/MtKyRW\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://creativecommons.org/licenses/by-nc-sa/3.0/\n\n\n#define R(p, a) p = cos(a) * p + sin(a) * vec2(p.y, -p.x)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (iResolution.xy - fragCoord.xy * 2.0)/min(iResolution.x, iResolution.y);\n    if(acos(abs(uv.x))<.2||acos(abs(uv.y))<1.){fragColor.rgb=vec3(0.);return;};\n\tfloat tm =  mod(ceil(iTime*.2),2.)/.7*sin(iTime);\n\tfloat u = (.9*sin(abs(uv.x-tm)));\n\tif(tm>0.)uv.y*=-1.;\n\tfloat v = dot(uv.y*1.25,cos(uv.y)*.3+.4);\n\tif(ceil(sin(iTime*7.)/sin(iTime))>2.5)v=fract(uv.y);\n\tvec3 rd = (vec3(u,v,-2.));\n\tR(rd.xy, tm*.081 );\n\tvec3 p = vec3(0);\n\tvec3 p2 = vec3(0.);\n\tfloat t = 0.0, d = 0.0,d2=0.;\n\tfor (float i= 0.;(i<1.0);i+=0.0078){\n\t\td = min(abs(.001/.9+sin(3.+p.z*.1)*abs(cos(p.y*.9*p.y))*(cos(p.x*.5)) ),.01/abs((cos(p.x*p.x*0.65)*sin(p.y*p.y*0.4))));\n\t\td2 = min(abs(.001/1.+sin(1.105+p2.z*.8)*abs(cos(p.y*.5))*(cos(p2.x*.5)) ),.01/abs((cos(p2.x*p2.x*0.35)*sin(p.y*p.y*0.4))));\n\t\tt += d;\n\t\tp+= rd*d;\n\t\tp2+=rd*d+step(.02,d2);\n\t};\n\tvec3 c = pow((vec3(.04)+(d-.02)*4.+t*.02+t*vec3(.12,.2,.19)*(0.85*-rd.y*.2)), vec3(1./2.));\n\tvec3 c2 = pow((vec3(.04)+(d2-.02)*4.+t*.02+t*vec3(.12,.2,.24)*(-rd.y*.3)), vec3(1./2.));\n\tfragColor.rgb = mix(c, c2,.1);\n\tfragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtKyRW.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[250, 250, 307, 307, 1372]], "test": "error"}
{"id": "MtKyzD", "name": "Glass cubes in infinity mirror", "author": "keim", "description": "Glass cubes in infinity mirror room", "tags": ["reflection", "refraction", "glass", "mirror"], "likes": 16, "viewed": 894, "published": "Public API", "date": "1535420606", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SHADERTOY\n\nprecision highp float;\n#ifdef SHADERTOY\n vec2  resolution, mouse;\n float time;\n#else\n uniform vec2  resolution;     // resolution (width, height)\n uniform vec2  mouse;          // mouse      (0.0 ~ 1.0)\n uniform float time;           // time       (1second == 1.0)\n uniform sampler2D backbuffer; // previous scene texture\n#endif\n\n\n//----- Ray-tracing parameters\nconst int   MAX_TRACE_STEP  = 100;\nconst float MAX_TRACE_DIST  = 300.;\nconst float NO_HIT_DIST     = 100.;\nconst float TRACE_PRECISION = .001;\nconst float FUDGE_FACTOR    = .9;\nconst int   RAY_TRACE_COUNT = 8;\n\n// -- lighting parameters\nconst int   GI_TRACE_STEP = 4;\nconst float GI_LENGTH = 1.6;\nconst float GI_STRENGTH = 1.;\nconst float AO_STRENGTH = .4;\nconst int   SS_MAX_TRACE_STEP = 7;\nconst float SS_MAX_TRACE_DIST = 50.;\nconst float SS_MIN_MARCHING = .3;\nconst float SS_SHARPNESS = 1.;\nconst float CS_STRENGTH = 0.2;\nconst float CS_SHARPNESS = 0.2;\n\n//----- Demo parameters\nconst float BPM = 120.;\nconst vec3 BG = vec3(.5);\n\n//----- Constant\nconst vec3 PI = vec3(1.5707963,3.1415927,6.2831853);\nconst vec3 V  = vec3(0,TRACE_PRECISION,1);\n\n\n\n//----- Structures\nstruct Material {\n  vec3  kd, tc;\n  float rl, rr; // diffusion, transparent-color, reflectance, refractive index\n};\nfloat rr2rl(float rr) { float v=(rr-1.)/(rr+1.); return v*v; }\nMaterial matt(vec3 kd) { return Material(kd, vec3(0), 0., 1.); }\nMaterial mirror(vec3 kd, float rl) { return Material(kd, vec3(0), rl, 0.); }\nMaterial glass(vec3 tc, float rr) { return Material(vec3(0), tc, rr2rl(rr), rr); }\n\nstruct Surface {\n  float d;      // distance\n  Material mat; // material\n};\nSurface near(Surface s,Surface t) { if (s.d<t.d) return s; return t; }\nSurface near(Surface s,Surface t,Surface u) { return near(near(s, t), u); }\nSurface near(Surface s,Surface t,Surface u,Surface v) { return near(near(s,t),near(u,v)); }\nSurface NO_HIT = Surface(NO_HIT_DIST, Material(vec3(0), vec3(0), 0., 1.));\n\nstruct Ray {\n  vec3  org, dir, col;     // origin, direction, color\n  float len, stp, rr, sgn; // length, marching step, refractive index of current media, sign of distance function\n};\nRay ray(vec3 o, vec3 d) { return Ray(o,d,vec3(1),0.,0.,1.,1.); }\nRay ray(vec3 o, vec3 d, vec3 c, float rr, float s) { return Ray(o,d,c,0.,0.,rr,s); }\nvec3 _pos(Ray r) { return r.org+r.dir*r.len; }\n\nstruct Hit {\n  vec3 pos, nml; // position, normal\n  Ray ray;       // ray\n  Surface srf;   // surface\n  bool isTransparent, isReflect;  // = (len2(srf.mat.tc) > 0.001, srf.mat.rl > 0.01)\n};\nHit nohit(Ray r) { return Hit(vec3(0), vec3(0), r, NO_HIT, false, false); }\n\nstruct Camera {\n  vec3  pos, tgt, rol;  // position, target, roll\n  float fcs;            // focal length\n};\nmat3 cameraMatrix(Camera c) { vec3 w=normalize(c.pos-c.tgt),u=normalize(cross(w,c.rol)); return mat3(u,normalize(cross(u,w)),w); }\n\nstruct Light {\n  vec3 dir, col, amb;    // direction, color\n};\nLight amb = Light(vec3(0,1,0), vec3(1.0), vec3(0.02));\n\n//----- ray trace caluclations\nRay rayScreen(in vec2 p, in Camera c) { return ray(c.pos, normalize(cameraMatrix(c) * vec3(p.xy, -c.fcs))); }\nRay rayReflect(in Hit h, in float rl) { return ray(h.pos+h.nml*.01, reflect(h.ray.dir, h.nml), h.ray.col*rl, h.ray.rr, h.ray.sgn); }\nRay rayRefract(in Hit h, in float rr) {\n  vec3 r = refract(h.ray.dir, h.nml, h.ray.rr/rr);\n  if (length(r)<.01) return rayReflect(h, 1.);\n  return ray(h.pos-h.nml*.01, r, h.ray.col*h.srf.mat.tc, rr, -h.ray.sgn);\n}\n\n\n\n\n\nvec2 uv;\nfloat tick, pick;\nvec4  gamma(vec4 c){return vec4(pow(c.rgb,vec3(1./2.2)),c.a);}\nvec3  hsv(float h,float s,float v){return((clamp(abs(fract(h+vec3(0,2,1)/3.)*6.-3.)-1.,0.,1.)-1.)*s+1.)*v;}\nfloat fresnel(float r, float dp) {return r+(1.-r)*pow(1.-abs(dp),5.);}\nvec2  circle(float a){return vec2(cos(a),sin(a));}\nmat3  euler(float h, float p, float r){float a=sin(h),b=sin(p),c=sin(r),d=cos(h),e=cos(p),f=cos(r);return mat3(f*e,c*e,-b,f*b*a-c*d,f*d+c*b*a,e*a,c*a+f*b*d,c*b*d-f*a,e*d);}\nfloat dfPln(vec3 p, vec3 n, float z){return dot(p,n)+z;}\nfloat dfRoom(vec3 p, vec3 s) {vec3 v=s-abs(p); return min(v.x, min(v.y, v.z));}\nfloat dfBox(vec3 p, vec3 b, float r){return length(max(abs(p)-b,0.))-r;}\nvec3  doRep(vec3 p, vec3 r){ return mod(p+r*.5,r)-r*.5; }\nfloat dfp2l(vec3 p, vec3 d, vec3 c) { return length(dot(c-p,d)*d+p-c); }\nfloat checker(vec3 u, vec3 s){return mod(floor(u.x/s.x)+floor(u.y/s.y)+floor(u.z/s.z),2.);}\n\nvec3 lightpos[3];\nvec3 lightcol[3];\n\nSurface map(in vec3 p) {\n    vec3 c = mix(vec3(0.1), vec3(0.5), checker(p, vec3(6)));\n    Surface s = Surface(dfRoom(p, vec3(37.1)), mirror(c,0.5));\n    vec3 q = doRep(p, vec3(30));\n    return  near(s, Surface(dfBox(q*euler(pick/16.,pick/7.,0.), vec3(3.5), .8), glass(hsv(tick/64.,.4,.9),1.6)));\n}\n\nvec3 background(in Ray ray) {\n    return BG;\n}\n\n\n\n//----- Lighting\nvec3 emittance(in Ray ray, in Light lit) {\n    return pow(dfp2l(ray.org, ray.dir, lit.dir)*40., -1.5) * lit.col;\n}\n\nvec3 diffusion(in vec3 nml, in Light lit) {\n    return max(dot(nml, lit.dir) * lit.col, 0.);\n}\n\nvec4 shading(in vec3 pos, in vec3 dir) {\n  vec3 color;\n  float shade = 1.0, len = SS_MIN_MARCHING;\n  for (int i=SS_MAX_TRACE_STEP; i!=0; --i) {\n    Surface s = map(pos + dir*len);\n    color = s.mat.tc;\n    shade = min(shade, SS_SHARPNESS * s.d / len);\n    len += max(s.d, SS_MIN_MARCHING);\n    if (s.d<TRACE_PRECISION || len>SS_MAX_TRACE_DIST) break;\n  }\n  shade = clamp(shade, 0., 1.);\n  return vec4(pow((1.-shade), CS_SHARPNESS) * color * CS_STRENGTH, shade);\n}\n\nvec4 occlusion(in vec3 pos, in vec3 nml) {\n  vec3 color;\n  float occl;\n  for (int i=GI_TRACE_STEP; i!=0; --i) {\n    float hr = .01 + float(i) * GI_LENGTH / 4.;\n    Surface s = map(nml * hr + pos);\n    occl += (hr - s.d);\n    color += s.mat.kd * (hr - s.d);\n  }\n  return vec4(color * GI_STRENGTH / GI_LENGTH, clamp(1.-occl * AO_STRENGTH / GI_LENGTH, 0., 1.));\n}\n\nvec3 lighting(in Hit h, in Light lit) {\n  if (h.ray.len > MAX_TRACE_DIST) return background(h.ray);\n  vec4 occl = occlusion(h.pos, h.nml);\n  vec4 shad = shading(h.pos, lit.dir);\n  vec3 lin = (diffusion(h.nml, lit) * shad.w + shad.rgb) * occl.w + occl.rgb + lit.amb;\n  return  h.srf.mat.kd * lin;\n}\n\n\n//----- Ray trace\nvec3 _normal(in vec3 p){\n  float d = map(p).d;\n  return normalize(vec3(map(p+V.yxx).d - d, map(p+V.xyx).d - d, map(p+V.xxy).d - d));\n}\n\nHit trace(in Ray r) {\n  Surface s;\n  for(int i=0; i<MAX_TRACE_STEP; i++) {\n    s = map(_pos(r));\n    s.d *= r.sgn;\n    r.len += s.d * FUDGE_FACTOR;\n    r.stp = float(i);\n    if (s.d < TRACE_PRECISION) break;\n    if (r.len > MAX_TRACE_DIST) return nohit(r);\n  }\n  vec3 p = _pos(r);\n  float interior = .5-r.sgn*.5;\n  s.mat.rr = mix(s.mat.rr, 1., interior);\n  s.mat.tc = max(s.mat.tc, interior);\n  return Hit(p, _normal(p)*r.sgn, r, s, (length(s.mat.tc)>.01), (s.mat.rl>.01));\n}\n\nvec3 _difColor(inout Hit h, in Light l) {\n  if (length(h.srf.mat.kd) < .01) return vec3(0);\n  vec3 col = lighting(h, l) * h.ray.col;\n  h.ray.col *= 1. - h.srf.mat.kd;\n  return col;\n}\n\nRay _nextRay(Hit h) {\n  if (h.isTransparent) return rayRefract(h, h.srf.mat.rr);\n  return rayReflect(h, fresnel(h.srf.mat.rl, dot(h.ray.dir, h.nml)));\n}\n\nvec4 render(in Ray ray) {\n  vec3 col=vec3(0), c;\n  Hit h0, h1;\n  float l0, rl;\n  h0 = trace(ray);\n  l0 = h0.ray.len;\n\n  col += _difColor(h0, amb);\n  if (!h0.isReflect) return vec4(col, l0);\n  rl = fresnel(h0.srf.mat.rl, dot(h0.ray.dir, h0.nml));\n  h1 = trace(rayReflect(h0, rl));\n  col += _difColor(h1, amb);\n  h0.ray.col *= 1. - rl;\n  if (!h0.isTransparent) h0 = h1;\n  for (int i=RAY_TRACE_COUNT; i!=0; --i) {\n    if (!h0.isReflect) return vec4(col, l0);\n    h0 = trace(_nextRay(h0));\n    col += _difColor(h0, amb);\n  }\n  c = h0.ray.col;\n  if (length(c) >= .5) col += background(h0.ray) * c * c;\n\n  return vec4(col, l0);\n}\n\nvec4 entryPoint(vec2 fragCoord) {\n    uv = (fragCoord * 2.-resolution) / resolution.y;\n    tick = time * BPM / 60.;\n    pick = tick * PI.z;\n\n    lightpos[0] = vec3(cos(pick/11.)*10.+5., cos(pick/16.)*10., sin(pick/8.)*10.);\n    lightpos[1] = vec3(cos(pick/8.)*8.+5., cos(pick/6.)*8., sin(pick/7.)*8.);\n    lightpos[2] = vec3(cos(pick/4.)*12.+5., cos(pick/11.)*12., sin(pick/9.)*12.);\n    lightcol[0] = vec3(5,10,50);\n    lightcol[1] = vec3(5,30,5);\n    lightcol[2] = vec3(40,8,8);\n\n    Camera camera = Camera(vec3(sin(pick/14.)*5.+3., circle(pick/32.)*20.), vec3(0,0,0), vec3(1,0,0), 1.732);\n    Ray ray = rayScreen(uv, camera);\n\n    return gamma(render(ray));\n}\n\n\n\n\n#ifdef SHADERTOY\nvoid mainImage(out vec4 flagColor,in vec2 flagCoord) {\n    resolution = iResolution.xy;\n    time = iTime;\n    mouse = iMouse.xy;\n    flagColor = entryPoint(flagCoord);\n}\n#else\nvoid main() {\n    gl_FragColor = entryPoint(gl_FragCoord.xy);\n}\n#endif", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtKyzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1265, 1265, 1288, 1288, 1327], [1328, 1328, 1352, 1352, 1392], [1393, 1393, 1429, 1429, 1469], [1470, 1470, 1505, 1505, 1552], [1630, 1630, 1665, 1665, 1700], [1701, 1701, 1746, 1746, 1776], [1777, 1777, 1832, 1832, 1868], [2130, 2130, 2155, 2155, 2194], [2195, 2195, 2247, 2247, 2279], [2280, 2280, 2298, 2298, 2326], [2518, 2518, 2536, 2536, 2593], [2704, 2704, 2733, 2733, 2834], [2955, 2986, 3025, 3025, 3095], [3096, 3096, 3135, 3135, 3228], [3229, 3229, 3268, 3268, 3442], [3475, 3475, 3495, 3495, 3537], [3538, 3538, 3573, 3573, 3645], [3646, 3646, 3680, 3680, 3716], [3717, 3717, 3739, 3739, 3767], [3768, 3768, 3807, 3807, 3940], [3941, 3941, 3978, 3978, 3997], [3998, 3998, 4028, 4028, 4077], [4078, 4078, 4115, 4115, 4150], [4151, 4151, 4179, 4179, 4208], [4209, 4209, 4246, 4246, 4281], [4282, 4282, 4312, 4312, 4373], [4412, 4412, 4436, 4436, 4709], [4711, 4711, 4740, 4740, 4757], [4761, 4778, 4820, 4820, 4892], [4894, 4894, 4937, 4937, 4988], [4990, 4990, 5030, 5030, 5453], [5455, 5455, 5497, 5497, 5815], [5817, 5817, 5856, 5856, 6114], [6117, 6135, 6159, 6159, 6269], [6271, 6271, 6292, 6292, 6746], [6748, 6748, 6789, 6789, 6930], [6932, 6932, 6953, 6953, 7084], [7086, 7086, 7111, 7111, 7709], [7711, 7711, 7744, 7744, 8373]], "test": "timeout"}
{"id": "MttczB", "name": "clock with basic shape", "author": "guowei", "description": "basic shape, circle, line", "tags": ["clock", "basicshape"], "likes": 0, "viewed": 79, "published": "Public", "date": "1533092103", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//original from https://zhuanlan.zhihu.com/p/39798563?utm_source=ZHShareTargetIDMore&utm_medium=social&utm_oi=70060592857088\n\nfloat circle(vec2 pixel, vec2 center, float radius, float blurSize);\nfloat line(vec2 pixel, vec2 pa, vec2 pb, float width, float blurSize);\nmat2 rotateMatrix(float angle);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    \n    //shake the clock\n    float tt=mod(iTime,1.5)/1.5;\n  \tfloat ss=1.0+0.5*sin(tt*3.1415*6.0+uv.x*0.5)*exp(-tt*4.0);\n  \tuv*=(vec2(0.7,1.5)+ss*vec2(0.3,-0.5));\n\t\n    //paint the clock\n    float circleBodySign = circle(uv, vec2(0.0, 0.0), 0.3, 0.005);\n    vec4 clockBodyColor = mix(vec4(0.404, 0.824, 0.784, 1.0), vec4(0, 0.0, 0.0, 0.0), circleBodySign);\n    \n    float circleBodyWhiteSign = circle(uv, vec2(0.0, 0.0), 0.28, 0.005);\n    vec4 clockBodyWhiteColor = mix(vec4(1.0, 1.0, 1.0, 1.0), vec4(0.0, 0.0, 0.0, 0.0), circleBodyWhiteSign);\n    \n    fragColor = vec4(clockBodyColor);\n    fragColor += clockBodyWhiteColor;\n    \n    mat2 rotationSecond = rotateMatrix(iTime + 45.0/3.14);   \n    float secondLineSign = line(uv, vec2(0.0, 0.2) * rotationSecond, vec2(0.0, -0.03) * rotationSecond, 0.005, 0.005);\n    fragColor = mix(vec4(1.0, 0.0, 0.0, 1.0), fragColor, secondLineSign);\n    //float hourLineSign = line(uv, vec2(0.0, 0.0), vec2(-0.2, 0.15), 0.005, 0.005);\n    //fragColor = mix(vec4(1.0, 0.0, 0.0, 1.0), fragColor, hourLineSign);\n    \n    mat2 rotationMinute = rotateMatrix(iTime/5.0 + 15.0/6.283);\n    float minuteLineSign = line(uv, vec2(0.0, 0.15) * rotationMinute, vec2(0.0, -0.03) * rotationMinute, 0.007, 0.005);\n    fragColor = mix(vec4(0.0, 0.0, 0.0, 1.0), fragColor, minuteLineSign);\n    \n    mat2 rotationHour = rotateMatrix(iTime/10.0 + 45.0/6.283);\n    float hourLineSign = line(uv, vec2(0.0, 0.1) * rotationHour, vec2(0.0, -0.03) * rotationHour, 0.009, 0.005);\n    fragColor = mix(vec4(0.0, 0.0, 0.0, 1.0), fragColor, hourLineSign);\n}\n\nfloat circle(vec2 pixel, vec2 center, float radius, float blurSize) {\n\tvec2 vectorPixelToCenter = pixel - center;\n    float distanceToCenter = length(vectorPixelToCenter);\n    \n    return smoothstep(radius - blurSize, radius, distanceToCenter);\n}\n\n//float line(vec2 pixel, vec2 pa, vec2 pb, float width, float blurSize) {\n\t//vec2 vpa = pixel - pa;\n   // vec2 vba = pb - pa;\n    //vec2 dirBa = normalize(vba);\n    \n    //float shadowVpaOnVba = clamp(dot(vpa, dirBa), 0.0, length(vba));\n    //float dist = length(vpa - dirBa * shadowVpaOnVba);\n    \n    //return smoothstep(width - blurSize, width, dist);\n//}\n\nfloat line(vec2 p, vec2 a, vec2 b, float width, float blur) {\n  vec2 pa = p - a;\n  vec2 ba = b - a;\n  vec2 dir = normalize(ba);\n  float t = clamp(dot(pa, dir), 0., length(ba));\n  float dist = length(pa - dir * t);\n  return smoothstep(width - blur, width, dist);\n}\n\nmat2 rotateMatrix(float angle) {\n\treturn mat2(cos(angle), sin(angle), -sin(angle), cos(angle));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MttczB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[299, 299, 356, 356, 1980], [1982, 1982, 2051, 2051, 2228], [2590, 2590, 2651, 2651, 2853], [2855, 2855, 2887, 2887, 2952]], "test": "ok"}
{"id": "MtVczD", "name": "Endless Neon", "author": "momoro", "description": "Rough wip of a mistake", "tags": ["color"], "likes": 2, "viewed": 443, "published": "Public API", "date": "1535423971", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592654\n\nfloat map(float value, float inMin, float inMax, float outMin, float outMax) {\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n}\n\n\nmat2 rotate(float angle) {\n    return mat2(cos(angle), -sin(angle),\n                sin(angle), cos(angle)\n    );\n}\n\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n\nfloat atan201(float x, float y) {\n    return (atan(x, y) + PI) / (PI * 2.);\n}\n\nfloat sin01(float n) {\n    return sin(n)/2.+.5;\n}\n\nvec2 sin01(vec2 n) {\n    return sin(n)/2.+.5;\n}\n\nvec4 blend(vec4 bg, vec4 fg) {\n    vec4 c = vec4(0.);\n    c.a = 1.0 - (1.0 - fg.a) * (1.0 - bg.a);\n    if(c.a < .00000) return c;\n    \n    c.r = fg.r * fg.a / c.a + bg.r * bg.a * (1.0 - fg.a) / c.a;\n    c.g = fg.g * fg.a / c.a + bg.g * bg.a * (1.0 - fg.a) / c.a;\n    c.b = fg.b * fg.a / c.a + bg.b * bg.a * (1.0 - fg.a) / c.a;\n    \n    return c;\n}\n\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return dot(m, g);\n}\n\n\nfloat fbm1d(float x, float amplitude, float frequency, float offset) {\n    x += offset;\n    float y = 0.;\n    // Properties\n    const int octaves = 8;\n    float lacunarity = 1.144;\n    float gain = 1.092;\n    \n    // Initial values\n    //sin(u_time) * 5. + 10.;\n    //sin(u_time/10. + 10.);\n    \n    // Loop of octaves\n    for (int i = 0; i < octaves; i++) {\n        y += amplitude * snoise(vec2(frequency*x));\n        frequency *= lacunarity;\n        amplitude *= gain;\n    }\n    \n    return y;\n}\n\n\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\nfloat smax(float a,float b, float k)\n{\n    return -smin(-a,-b,k);\n}\n\nfloat smootheststep(float t) {\n    return -20.*pow(t, 7.)+70.*pow(t,6.)-84.*pow(t,5.)+35.*pow(t,4.); // when smootherstep's second derivative isn't enough\n}\n\n\nfloat pcsmooth(float x) {\n    return -pow(cos((PI*(x)/2.)), 3.) + 1.;\n}\n\n\n///////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n   \n    \n    vec4 color;\n    \n    vec2 st = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    st /=9.036;\n    st += vec2(-0.380,0.200);\n    \n    st *= rotate(iTime/.59);\n    \n    /////////////////////////////////////////////////////////////\n    // Blobby circle\n\tfloat arcs = 7.;\n    \n    float f = atan201(st.x, st.y); // angle\n    float m = smoothstep(0., 1., fract(f * arcs)); // mix amount\n\t\n     m = pcsmooth(fract(f*arcs));\n    \n    f = ceil(f * arcs) / arcs; // split up\n    \n    float fNext = f + 1./arcs;\n    \n    \n    // Smooth the blob at the end\n    bool e = false;\n    if(f > (arcs-1.)/arcs + .01) {\n\t\tfNext = 1./arcs;\n    }\n    \n    /////////////////////////////////////////////////////////////\n    // Add noise\n    float amp = 20000.;\n    float freq = 30.;\n    \n    float offset = 1.144 + iTime/300.;\n    f = fbm1d(f, amp, freq, offset);\n    fNext = fbm1d(fNext, amp, freq, offset);\n    \n    float noiseMin = -20.;\n    f =  map(f, noiseMin, 1., 0.648, 0.712);\n    fNext = map(fNext, noiseMin, 1., 0.648, 0.712);\n\n    float len = length(st);\n\n    float mx = mix(f, fNext, m);\n  //  mx = clamp(mx, 0., 1.);\n\n    \n  \n\t#define steps 20.\n    \n    \n\n\t/////////////////////////////////////////////////////////////\n    for(float i=0.; i<steps; i++) {\n   \t\tfloat df = length(st) + (mx / 10.296) * (1.0 - i/steps);\n        \n        float incr = 0.736 - (0.728 * i/steps);\n        \n        float f = 1.0 - smoothstep(incr-.001, incr, df);\n\n        // SHADOW\n        f -=  (1. - (fract(df*steps) + .9)) * 80.768 * f;\n        vec3 rgb = vec3(f);\n        \n        vec3 hsv = vec3(1.);\n        hsv.x = pow(2. * fract((i*6.)/steps + iTime/2.3) - 1., 2.);\n        hsv.x = map(hsv.x, 0., 1., 0.0, 0.952);\n        hsv.y = 1.;\n\n        vec3 rgb2 = hsv2rgb(hsv);\n\n        rgb = rgb2 * rgb * 3.112;\n        float a = (i/steps + 0.640) * f;\n        a  = 0.14;\n\n        color = blend(color, vec4(rgb, a * f));\n    }\n    \n    \n    \n\n\n\n    fragColor = color;\n    \n\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtVczD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 102, 102, 177], [180, 180, 206, 206, 295], [298, 298, 320, 320, 651], [653, 653, 675, 675, 844], [846, 846, 867, 867, 914], [915, 915, 936, 936, 983], [984, 984, 1006, 1006, 1041], [1044, 1044, 1077, 1077, 1121], [1123, 1123, 1145, 1145, 1172], [1174, 1174, 1194, 1194, 1221], [1223, 1223, 1253, 1253, 1570], [1572, 1572, 1594, 1647, 3336], [3339, 3339, 3409, 3409, 3836], [3839, 3839, 3877, 3877, 3954], [3956, 3956, 3994, 3994, 4023], [4025, 4025, 4055, 4055, 4181], [4184, 4184, 4209, 4209, 4255], [4404, 4404, 4461, 4461, 6429]], "test": "ok"}
{"id": "MtVczz", "name": "version of kaleido tunnel", "author": "skeyn", "description": "fractal flight", "tags": ["fractal"], "likes": 4, "viewed": 107, "published": "Public", "date": "1535384114", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float time() { return iTime; }\nvec2 resolution() { return iResolution.xy; }\n\nfloat hash(float n) {\n    return fract(sin(n)*488.5453);\n}\n\nmat2 rotate(float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\t\n\treturn mat2(c, s, -s, c);\n}\n\nfloat de(vec3 p) {\n\tvec3 op = p;\n\tp = fract(p + 0.5) - 0.5;\n\tp.xz *= rotate(3.14159);\n\tconst int it = 7;\n\tfor(int i = 0; i < it; i++) {\n\t\tp = abs(p);\n\t\tp.xz *= rotate(-0.1 + 0.1*sin(time()));\n\t\tp.xy *= rotate(0.3);\n\t\tp.yz *= rotate(0.0 + 0.2*cos(0.45*time()));\n\t\tp = 2.0*p - 1.0;\n\t}\n    \n    float c = length(op.xz - vec2(0, 0.1*time())) - 0.08;\n\t\n\treturn max(-c, (length(max(abs(p) - 1.3 + texture(iChannel0, vec2(0)).r, 0.0)))*exp2(-float(it)));\n}\n\nfloat trace(vec3 ro, vec3 rd, float mx) {\n\tfloat t = 0.0;\n\tfor(int i = 0; i < 100; i++) {\n\t\tfloat d = de(ro + rd*t);\n\t\tif(d < 0.001*t || t >= mx) break;\n\t\tt += d;\n\t}\n\treturn t;\n}\n\nvec3 normal(vec3 p) {\n\tvec2 h = vec2(0.001, 0.0);\n\tvec3 n = vec3(\n\t\tde(p + h.xyy) - de(p - h.xyy),\n\t\tde(p + h.yxy) - de(p - h.yxy),\n\t\tde(p + h.yyx) - de(p - h.yyx)\n\t);\n\treturn normalize(n);\n}\n\nfloat ao(vec3 p, vec3 n) {\n\tfloat o = 0.0, s = 0.005;\n\tfor(int i= 0; i < 15; i++) {\n\t\tfloat d = de(p + n*s);\n\t\to += (s - d);\n\t\ts += s/(float(i) + 1.0);\n\t}\n\treturn 1.0 - clamp(o, 0.0, 1.0);\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n\tvec3 col = vec3(1);\n\t\n\tfloat t = trace(ro, rd, 10.0);\n    if(t < 10.0) {\n        vec3 pos = ro + rd*t;\n        vec3 nor = normal(pos);\n        vec3 ref = normalize(reflect(rd, nor));\n\n        float occ = ao(pos, nor);\n        float dom = smoothstep(0.0, 0.3, trace(pos + nor*0.001, ref, 0.3));\n\n        col = 0.1*vec3(occ);\n        col += clamp(1.0 + dot(rd, nor), 0.0, 1.0)*mix(vec3(1), vec3(1.0, 0.3, 0.3), 1.0 - dom);\n\t\tcol *= vec3(0.7, 3.0, 5.0);\t\n    }\n    \n    col = mix(col, vec3(9), 1.0 - exp(-0.06*t));\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = (-resolution() + 2.0*fragCoord.xy)/resolution().y;\n\tvec2 mo = iMouse.z > 0.0 ? (-resolution() + 2.0*iMouse.xy)/resolution().y : vec2(0);\n  \n\tfloat atime = 0.1*time();\n\tvec3 ro = vec3(0.0, 0.0, atime);    \n    vec3 la = vec3(2.0*mo, atime + 1.0);\n    \n\tvec3 ww = normalize(la-ro);\n\tvec3 uu = normalize(cross(vec3(0, 3, 0), ww));\n\tvec3 vv = normalize(cross(ww, uu));\n    mat3 ca = mat3(uu, vv, ww);\n\tvec3 rd = normalize(ca*vec3(uv, 1.57));\n\t\n\tvec3 col = render(ro, rd);\n\t\n\tcol = 1.0 - exp(-0.5*col);\n\tcol = pow(abs(col), vec3(6.9/9.5));\n\tfragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtVczz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 14, 14, 30], [31, 31, 50, 50, 75], [77, 77, 98, 98, 135], [137, 137, 159, 159, 228], [230, 230, 248, 248, 679], [681, 681, 722, 722, 859], [861, 861, 882, 882, 1052], [1246, 1246, 1277, 1277, 1805], [1807, 1807, 1864, 1864, 2439]], "test": "error"}
{"id": "Mtyczw", "name": "Manhattan Voronoi Distance Map", "author": "curice", "description": "Hello Shadertoy!!!\nThis is my attempt at generating smooth distances to Manhattan Voronoi Cell Edges. Blatantly inspired by IQ's euclidean version, I hope this doesn't offend anyone. I will be writing an article on this topic in the coming days. <3 <3 ", "tags": ["2d", "voronoi", "worley", "manhattan", "manhattanvoronoi", "voronoiedges", "manhattannorm", "manhattanedges"], "likes": 23, "viewed": 1218, "published": "Public", "date": "1535498966", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright  2018 Jake Rice\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/* \n--AUTHOR NOTES--\nHi new Shadertoy friends!!!!\nInspired by IQ's lovely voronoi edge shader, I attempted to define a distance function for manhattan voronoi cells.\nThis proposed method results in evenly spaced isoline lines, which was my goal. \nThere are easier methods of calculating this distance if isoline smoothness is disregarded (but that's lame).\nI'll probably touch on those in my article on the subject.\n\nNext on my list is extending it into 3 dimensions.\n\nAnyways this is my first GLSL shader ever, I come from the land of Houdini, so this was a bit of a struggle.\nApologies if there are easy things I missed that would speed this up (though I'm getting 60fps!!!).\nI'm not sure how you guys make such incredible things with so few tools to help debug issues...\n<3 <3 <3\n*/\n#define ANIMATE\n\n//hash2 shamelessly stolen from IQ <(^.^<)\nvec2 hash2( vec2 p )\n{\n\t// texture based white noise\n\treturn textureLod( iChannel0, (p+0.5)/256.0, 0.0 ).xy;\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\nmat2 ident(){\n  return mat2(1.,0.,0.,1.);\n}\nfloat vmax(vec2 a){\n    return max(a.x, a.y);\n}\n\nvec2 avg(vec2 a, vec2 b){\n    return (a + b) / 2.;\n}\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\nvec3 map(vec3 value, vec3 min1, vec3 max1, vec3 min2, vec3 max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\n// cosine based palette, 4 vec3 params\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat dot2(vec2 a){return dot(a,a);}\n\nfloat man_dist(in vec2 center_a, in vec2 center_b, in vec2 p, out vec2 gradient){\n    //remember, balls in the L1 norm are octohedrons\n\n    vec2 midp = avg(center_a, center_b);\n    vec2 min_c = min(center_a, center_b);\n    vec2 max_c = max(center_a, center_b);\n    \n    //find the largest bounding box axis between the two centers\n    vec2 cm_dir = (min_c - max_c) * (min_c - max_c);\n    float max_axis = vmax(cm_dir);     \n    int max_comp = max_axis == cm_dir.x ? 0 : 1;\n    \n      \n    //define the diagonal source pos\n    vec2 edge = center_a;\n    edge[max_comp] = center_b[max_comp];\n    edge = normalize(edge - center_a);\n    float cc = dot(midp - center_a, edge);\n    vec2 new_p =  center_a + edge * cc;\n    float l = length(new_p - midp);\n    \n    vec2 diag_p_0 = new_p + edge * l;\n    \n    //define the diagonal destination pos\n    edge = center_b;\n    edge[max_comp] = center_a[max_comp];\n\n    edge = normalize(edge - center_b);\n    cc = dot(midp - center_b, edge);\n    new_p =  center_b + edge * cc;\n    l = length(new_p - midp);\n    \n    vec2 diag_p_1 = new_p + edge * l;\n    \n    \n    //define the direction of the two axis aligned planes\n    int min_comp = 1 - max_comp;\n    \n    vec2 dir_a = min_comp == 0 ? vec2(1., 0.) : vec2(0., 1.);\n    vec2 dir_b = dir_a;\n\n    float a_sign =  diag_p_0[min_comp] == max_c[min_comp] ? 1. : -1.;\n    dir_a *= a_sign;\n    dir_b *= a_sign * -1.;\n    \n    //get the projection distance to the axis aligned planes\n    float a_dist = dot(p - diag_p_0, dir_a);\n    float b_dist = dot(p - diag_p_1, dir_b);\n    \n    //get the distance to the diagonal\n    vec2 diag = (diag_p_1 - diag_p_0);\n    \n    float diag_l =  dot2(diag);\n    float diag_dist = dot(p - diag_p_0, diag) / diag_l;\n    \n    //project our current pos onto the diagonal\n    //make sure you clamp it to just that edge\n    vec2 proj_diag = diag_p_0 + diag * clamp(diag_dist, 0., 1.);\n    vec2 proj_a = diag_p_0 + dir_a *  max(a_dist, 0.);\n    vec2 proj_b = diag_p_1 + dir_b * max(b_dist, 0.);\n    \n    //find the distance to the projected point on the planes\n    float a_p_dist = length(proj_a - p );\n    float b_p_dist = length(proj_b - p );\n    \n    float p_diag_dist = length(proj_diag - p) ;\n    \n    float min_dist = min(p_diag_dist, min(a_p_dist, b_p_dist));\n    \n    //this branching is not needed if you dont want shading normals\n    if(min_dist == p_diag_dist){\n        gradient = proj_diag - p;\n    }else if(min_dist == a_p_dist){\n        gradient = proj_a - p;\n    }else{\n        gradient = proj_b - p;\n    }\n    \n\n    //find the minimum of all the distances\n    return min_dist;\n    \n}\n\n//this portion is all based on IQ's Voronoi Edge Shader\n//any additions have been commented\nvec3 voronoi( in vec2 x, out vec2 gradient, out vec2 cell)\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr, mr_2;\n\n    float md = 10.0;\n    \n    //we need to extend the search domain to two cells for voronoi generation (as opposed to one).\n    //this is due to the fact that the manhattan metric is not a straight distance\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.5*sin( iTime * .1 + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n        \n        //manhattan distance (L1 Norm)\n        float d = abs(r.x) +abs(r.y);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n            cell = o;\n        }\n    }\n\t//cell = mg;\n    //----------------------------------\n    // second pass: distance to borders\n    //---------------------------------\n    \n    md = 10.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2;i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.5*sin( iTime * .1 + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n\t\t\n        //call our custom edge distance function\n        if( dot(mr-r,mr-r)>1e-4 ){\n            vec2 grad = vec2(0.);\n            float man_dist = man_dist(f - mr, f - r, f, grad);\n        \tmd = min(md, man_dist);\n            gradient = md == man_dist ? grad : gradient;\n        } \n            \n    }\n\t\n    return vec3( md, mr );\n}\n\n//Visualization also shamelessly stolen from IQ (>^.^)>\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 p = fragCoord/iResolution.xx;\n    vec2 grad = vec2(0.);\n    vec2 cell = vec2(0.);\n    vec3 c = voronoi(5.0*p, grad, cell);\n    \n    vec3 col = vec3(0.);\n    \n    grad = normalize(grad);\n    vec2 light_dir = vec2(1., 0.);\n    mat2 rotation = rotate2d(iTime * .25);\n    light_dir = normalize(light_dir * rotation);\n    float lighting = clamp(dot(grad, light_dir),0., 1.);\n    lighting = map(lighting, 0., 1., .25, 1.);\n    lighting = pow(lighting, .75);\n    //uncomment \n\n    vec3 cell_color = vec3(sin(cell.x * 30.28 + 50.), cos((cell.x * 50.28) + 20.) * .1, .5);                  \n    cell_color = map(cell_color, vec3(-1.), vec3(1.), vec3(.5), vec3(1.));\n    \n    cell_color = palette(cell.x, vec3(.5), vec3(0.3), vec3(.05,0.1,.6), vec3(.2, .6, .4));\n    \n    col = cell_color;\n    //isolines\n    col *=  pow(0.5 + 0.5*cos(200.0*c.x + iTime * 1.), 2.) *vec3(2.0);\n    col *= lighting;\n    \n    // borders\t\n    //col = mix( vec3(0.), col, pow(smoothstep( 0.002, 0.015, c.x ), .75) );\n    \n    \n    /*\n    //isolines\n    col += c.x * pow(0.5 + 0.5*sin(200.0*c.x + iTime * .1), 1.) *vec3(2.0);\n    // borders\t\n    col = mix( vec3(1.), col, pow(smoothstep( 0.002, 0.015, c.x ), 1.) );\n\t*/\n\n\n\tfragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mtyczw.jpg", "access": "shaders20k", "license": "mit", "functions": [[1878, 1921, 1943, 1973, 2031], [2033, 2033, 2061, 2061, 2147], [2148, 2148, 2161, 2161, 2191], [2192, 2192, 2211, 2211, 2239], [2241, 2241, 2266, 2266, 2293], [2295, 2295, 2367, 2367, 2433], [2434, 2434, 2500, 2500, 2566], [2568, 2607, 2679, 2679, 2722], [2724, 2724, 2743, 2743, 2760], [2762, 2762, 2843, 2896, 5367], [5369, 5461, 5521, 5521, 7122], [7124, 7180, 7237, 7237, 8469]], "test": "error"}
{"id": "MtyyRz", "name": "Trig Flowers", "author": "momoro", "description": "Random wip mistake", "tags": ["blend"], "likes": 4, "viewed": 411, "published": "Public API", "date": "1534832122", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nvec4 blend(vec4 bg, vec4 fg) {\n    vec4 c = vec4(0.);\n    c.a = 1.0 - (1.0 - fg.a) * (1.0 - bg.a);\n    if(c.a < .00000) return c;\n    \n    c.r = fg.r * fg.a / c.a + bg.r * bg.a * (1.0 - fg.a) / c.a;\n    c.g = fg.g * fg.a / c.a + bg.g * bg.a * (1.0 - fg.a) / c.a;\n    c.b = fg.b * fg.a / c.a + bg.b * bg.a * (1.0 - fg.a) / c.a;\n    \n    return c;\n} \n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 st = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\tvec2 ost = st;\n    \n    \n    st += vec2(-0.550,0.720) * 1.152;\n    st *= -0.484;\n\n    st *= length(st * 1.168);\n  //  st.x *= atan(st.x, st.y) * -0.264 + cos(st.x * 10.);\n    st += sin(iTime/5.) / 50.;\n\n\tvec4 color = vec4(1.);\n\n    float f = distance(vec2(0.), st.xy);\n    float d = f;\n    \n    \n    float a = atan(st.x, st.y)*3. + tan((d*.1+iTime/5.)) * .1;\n    f = sin(a) + f;\n    f = sin(a*2.) * cos(a*1.);\n    \n    st *= f;\n    \n    for(float i=0.; i<60.; i++) {\n        vec2 uv = st;\n        uv *= i/7.768 + 1.;\n  \n        uv += vec2(0.020,-0.020) * i;\n\t\t\n        float f = length(uv);\n        f = 1.0 - smoothstep(0.0, fwidth(f *1000.5), f - -.003);\n        \n        float m = mod(i, 2.);\n       \n        vec4 c;\n        \n        if(m == 0.) {\n    \t\tvec3 orange = vec3(0.945,0.502,0.281);\n            float a = 1.280;\n\t    \tc = vec4(orange, a * f);\n\n        } else if(m == 1.) {\n            vec3 green = vec3(0.351,0.865,0.205);\n            float a = 1.184;;\n\t    \tc = vec4(green, a * f);\n        } \n        \n        color = blend(color, c);\n    }\n    \n     for(float i=0.; i<5.; i++) {\n        vec2 uv = st;\n        uv *= i/7.768 + 1.;\n        uv *= 1.108;\n  \n         uv += vec2(-0.010,0.060);\n        uv += vec2(0.020,0.030) * i;\n\t\t\n        float f = length(uv);\n        f = 1.0 - smoothstep(0.0, fwidth(f * 1.5), f - 0.124);\n        \n        float m = mod(i, 2.);\n       \n        vec4 c;\n        \n    \tvec3 blue = vec3(0.910,0.310,0.533);\n        float a = i / 6. * 0.924;\n\t    c = vec4(blue, a * f);\n        \n        color = blend(color, c);\n    }\n    \n\n    color.rgb *= vec3(1.790,1.645,0.433);\n\n\tcolor.rgb = rgb2hsv(color.rgb);\n    color.y = .85 * f;\n    color.y = clamp(color.y, 0., 1.);\n    color.y *= 1.4;\n    color.x += 0.708 + ost.y/8.;\n    color.rgb = hsv2rgb(color.rgb);\n\n\n    \n    fragColor = color;\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtyyRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 47, 77, 77, 394], [397, 397, 419, 419, 750], [752, 752, 774, 774, 943], [945, 945, 1002, 1002, 2892]], "test": "ok"}
{"id": "Mtyyzh", "name": "GPU hacks #02 - D3DX9 Assembler", "author": "PrzemyslawZaworski", "description": "Welcome. ShaderToy is a great place to learn WebGL shaders. Now it's time to extend our skills with GPU programming. Every episode will provide full source code with tiny framework in different language. ", "tags": ["tutorial", "asm", "assembler", "directx"], "likes": 1, "viewed": 221, "published": "Public", "date": "1535026585", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nWritten by Przemyslaw Zaworski, MIT licence\nTools:\n - MinGW for Windows\n - DirectX SDK\nSave code as uv.cpp and compile from command line:\n\tg++ -s -o uv.exe uv.cpp  \"-IC:\\Program Files (x86)\\Microsoft DirectX SDK (June 2010)\\Include\" \"-LC:\\Program Files (x86)\\Microsoft DirectX SDK (June 2010)\\Lib\\x86\" -ld3d9 -ld3dx9\nIt will produce standalone executable, which content will be similar to the default ShaderToy's new shader.\nIn HLSL it seems like:\n\nuniform extern float iTime : register(c0);\nfloat4 main (float2 fragCoord : VPOS) : COLOR\n{\n\tfloat2 uv = fragCoord/float2(1920,1080);\n\tuv.y = 1.0 - uv.y;\n\treturn float4(0.5 + 0.5*cos(iTime + uv.xyx + float3(0,2,4)),1.0);\n}\n*/\n\n/*\n#include <d3dx9.h>\n\nstatic const char PixelShaderCode[] = \\\n\t\"ps_3_0\\n\"\n\t\"def c1, 0.0416666418, 1, 0, 0 \\n\"\n\t\"def c2, 0.00092592591, 0.00052083336, 0.159154937, 0.5 \\n\"\n\t\"def c3, 0, 3, 4, -0.00138883968 \\n\"\n\t\"def c4, 6.28318548, -3.14159274, 0, 0 \\n\"\n\t\"dcl vPos.xy \\n\"\n\t\"mov r0.xy, c2 \\n\"\n\t\"mad r1.y, vPos.y, -r0.x, c0.x \\n\"\n\t\"mad r1.xz, vPos.x, r0.y, c0.x \\n\"\n\t\"add r0.xyz, r1, c3 \\n\"\n\t\"mad r0.xyz, r0, c2.z, c2.w \\n\"\n\t\"frc r0.xyz, r0 \\n\"\n\t\"mad r0.xyz, r0, c4.x, c4.y \\n\"\n\t\"mul r0.xyz, r0, r0 \\n\"\n\t\"mad r1.xyz, r0, c4.z, c4.w \\n\"\n\t\"mad r1.xyz, r0, r1, c3.w \\n\"\n\t\"mad r1.xyz, r0, r1, c1.x \\n\"\n\t\"mad r1.xyz, r0, r1, -c2.w \\n\"\n\t\"mad r0.xyz, r0, r1, c1.y \\n\"\n\t\"mad oC0.xyz, r0, c2.w, c2.w \\n\"\n\t\"mov oC0.w, c1.y \\n\";\n\nint main()\n{\n\tShowCursor(0);\n\tLPDIRECT3DPIXELSHADER9 PixelShader;\n\tLPD3DXBUFFER PSBuffer;\t\n\tLPDIRECT3DDEVICE9 d3dDevice;\t\n\tLPDIRECT3D9 d3d = Direct3DCreate9( D3D_SDK_VERSION );\n\tD3DPRESENT_PARAMETERS W = {1920,1080,D3DFMT_A8R8G8B8,1,D3DMULTISAMPLE_NONE,0,_D3DSWAPEFFECT(1),0,0,1,D3DFMT_D24S8,0,0,0x80000000L};\t\n\tW.hDeviceWindow = CreateWindow(\"static\",0,WS_POPUP|WS_VISIBLE,0,0,1920,1080,0,0,0,0);\n\td3d->CreateDevice(0,D3DDEVTYPE_HAL,W.hDeviceWindow,0x00000040L,&W,&d3dDevice);  \n\tD3DXAssembleShader(PixelShaderCode,sizeof(PixelShaderCode), 0,0, (1 << 16), &PSBuffer, 0);\n\td3dDevice->CreatePixelShader((DWORD*)PSBuffer->GetBufferPointer(), &PixelShader);\n\td3dDevice->SetPixelShader(PixelShader);\n\td3dDevice->SetFVF(D3DFVF_XYZ);\n\tfloat quad[20] = {1,-1,0,1,0,-1,-1,0,0,0,1,1,0,1,1,-1,1,0,0,1}, S = GetTickCount()*0.001f;\n\tdo \n\t{\n\t\td3dDevice->BeginScene();\n\t\tfloat timer[1] = {GetTickCount()*0.001f-S};\n\t\td3dDevice->SetPixelShaderConstantF(0, timer, 1);\t\t\n\t\td3dDevice->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2, quad, 5*sizeof(float));\n\t\td3dDevice->EndScene();\n\t\td3dDevice->Present(NULL, NULL, NULL, NULL);\t\t\n\t}\n\twhile ( !GetAsyncKeyState(VK_ESCAPE) );\n\treturn 0;\n}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mtyyzh.jpg", "access": "shaders20k", "license": "mit", "functions": [[2560, 2560, 2617, 2667, 2854]], "test": "ok"}
{"id": "XdcfRj", "name": "Camera Basics 1 (raycasting)", "author": "littlemilk", "description": "simplest 3d (https://www.youtube.com/watch?v=dKA5ZVALOhs)(https://www.youtube.com/watch?v=PBxuVlp7nuM)", "tags": ["raycasting", "camera", "basics"], "likes": 1, "viewed": 83, "published": "Public", "date": "1533174645", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float DistLine(vec3 rayOrigin, vec3 rayDirection, vec3 point) {\n    \n    //using parallelagram formula to calc height\n\treturn length( cross(point-rayOrigin, rayDirection) )/ length(rayDirection);\n}\n\nfloat DrawPoint(vec3 rayOrigin, vec3 rayDirection, vec3 point) {\n    \n    float d = DistLine(rayOrigin, rayDirection, point);\n    d = smoothstep(.06, .05, d);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float time = iTime;\n    \n    vec3 rayOrigin = vec3(3.*sin(time), -3.*cos(time), -3.);\n    vec3 cameraPlane = vec3(uv.x, uv.y, -2.);\n    \n    vec3 lookAt = vec3(.5);\n    \n    float zoom = .5;\n    \n    vec3 forward = normalize(lookAt-rayOrigin);\n    vec3 right = cross(vec3(0.,1.,0.), forward);\n    vec3 up = cross(forward, right);\n    \n    vec3 center = rayOrigin + forward*zoom;\n    vec3 intersection = center + uv.x*right + uv.y*up;\n    vec3 rayDirection = intersection - rayOrigin;    \n\n    float d = 0.;\n    \n    d += DrawPoint(rayOrigin, rayDirection, vec3(0.,0.,0.));\n    d += DrawPoint(rayOrigin, rayDirection, vec3(0.,0.,1.));\n    d += DrawPoint(rayOrigin, rayDirection, vec3(0.,1.,0.));\n    d += DrawPoint(rayOrigin, rayDirection, vec3(0.,1.,1.));\n    d += DrawPoint(rayOrigin, rayDirection, vec3(1.,0.,0.));\n    d += DrawPoint(rayOrigin, rayDirection, vec3(1.,0.,1.));\n    d += DrawPoint(rayOrigin, rayDirection, vec3(1.,1.,0.));\n    d += DrawPoint(rayOrigin, rayDirection, vec3(1.,1.,1.));\n    \n    // Output to screen\n    fragColor = vec4(d);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdcfRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 63, 117, 197], [199, 199, 263, 263, 373], [375, 375, 432, 487, 1647]], "test": "ok"}
{"id": "Xl3cWs", "name": "boolean cut mandelbulb", "author": "MacSlow", "description": "A slight variation of an older shader I wrote months ago (https://www.shadertoy.com/view/MlffDs). This time trying out boolean ops, which sort of reveal almost classic 2D factal shapes as the planer surface cuts. Trying the same with 3D-julia sets later.", "tags": ["3d", "fractal", "mandelbulb", "spheretracing", "pbr", "booleanops"], "likes": 4, "viewed": 549, "published": "Public API", "date": "1534550044", "time_retrieved": "2021-10-01T00:00:00", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// cut mandelbulb - trying out boolean ops on a mandelbulb object\n//\n// Copyright 2018 Mirco Mller\n//\n// Author(s):\n//   Mirco \"MacSlow\" Mller <macslow@gmail.com>\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU General Public License version 3, as published\n// by the Free Software Foundation.\n//\n// This program is distributed in the hope that it will be useful, but\n// WITHOUT ANY WARRANTY; without even the implied warranties of\n// MERCHANTABILITY, SATISFACTORY QUALITY, or FITNESS FOR A PARTICULAR\n// PURPOSE.  See the GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License along\n// with this program.  If not, see <http://www.gnu.org/licenses/>.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nprecision highp float;\n\nconst int MAX_ITER = 96;\nconst float STEP_SIZE = .75;\nconst float EPSILON = .001;\nconst float PI = 3.1415926;\n\nstruct Ray {\n    vec3 ro;\n    vec3 rd;\n};\n\nstruct Result {\n    vec3 point;\n    vec3 normal;\n    float dist;\n    int iter;\n    int id;\n};\n\nconst Result nullResult = Result (vec3 (.0), vec3 (.0), .0, 0, -1);\n\nmat2 r2d (in float a)\n{\n    float c = cos (radians (a));\n    float s = sin (radians (a));\n    return mat2 (c, s, -s, c);\n}\n\nfloat mandelbulb (vec3 pos, in float n, in float bail, in int iter)\n{\n    vec3 z = pos;\n    float dr = 1.;\n    float r = .0;\n    for (int i = 0; i < iter; i++) {\n        r = length (z);\n        if (r > bail) break;\n\n        // from cartesian to polar\n        float theta = acos (z.z / r);\n        float phi = atan (z.y, z.x);\n        dr = pow(r, n - 1.) * n * dr + 1.;\n\n        // scale and rotate the point\n        float zr = pow (r, n);\n        theta = theta * n;\n        phi = phi * n;\n\n        // back to cartesian\n        z = zr * vec3(sin(theta)*cos(phi), sin(theta)*sin(phi), cos(theta));\n        z += pos;\n    }\n\n    return .5 * log (r) * r / dr; // I just don't get this distance estimator here\n}\n\nfloat sdBox (in vec3 p, in vec3 size)\n{\n    vec3 d = abs (p) - size;\n    return min (max (d.x, max (d.y, d.z)), .0) + length (max (d, .0));\n}\n\nfloat map (in vec3 p)\n{\n    float d = mandelbulb (p, 8. + 8.*(.5 + .5*cos(iTime)), 4., 8);\n    p.xz *= r2d (45.*iTime);\n    p.yz *= r2d (75.*iTime);\n    float box = sdBox (p + vec3 (-.75*(.5 + .5*cos(iTime)), -.5, .0), vec3 (1., .5, .5 + 1.*(.5 + .5*cos (iTime))));\n\n    return max (d, -box);\n}\n\nfloat distriGGX (in vec3 N, in vec3 H, in float roughness)\n{\n    float a2     = roughness * roughness;\n    float NdotH  = max (dot (N, H), .0);\n    float NdotH2 = NdotH * NdotH;\n\n    float nom    = a2;\n    float denom  = (NdotH2 * (a2 - 1.) + 1.);\n    denom        = PI * denom * denom;\n\n    return nom / denom;\n}\n\nfloat geomSchlickGGX (in float NdotV, in float roughness)\n{\n    float nom   = NdotV;\n    float denom = NdotV * (1. - roughness) + roughness;\n\n    return nom / denom;\n}\n\nfloat geomSmith (in vec3 N, in vec3 V, in vec3 L, in float roughness)\n{\n    float NdotV = max (dot (N, V), .0);\n    float NdotL = max (dot (N, L), .0);\n    float ggx1 = geomSchlickGGX (NdotV, roughness);\n    float ggx2 = geomSchlickGGX (NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n\nvec3 fresnelSchlick (in float cosTheta, in vec3 F0, float roughness)\n{\n\treturn F0 + (max (F0, vec3(1. - roughness)) - F0) * pow (1. - cosTheta, 5.);\n}\n\nvec3 normal (in vec3 p, in float epsilon)\n{\n    float d = map (p);\n    vec2 e = vec2 (epsilon, .0);\n    vec3 n = vec3 (map (p + e.xyy) - d,\n                   map (p + e.yxy) - d,\n                   map (p + e.yyx) - d);\n\n    return normalize (n);\n}\n\nvec3 shadePBR (in vec3 ro, in vec3 rd, in float d)\n{\n    vec3 p = ro + d * rd;\n    vec3 nor = normal (p, d*EPSILON);\n\n    // \"material\" hard-coded for the moment\n    vec3 albedo = vec3 (.25);\n    float metallic = .35;\n    float roughness = .25;\n\n    // lights hard-coded as well atm\n    vec3 lightColors[2];\n    lightColors[0] = vec3 (.7, .4, .2)*7.;\n    lightColors[1] = vec3 (.2, .7, .4)*9.;\n\n    vec3 lightPositions[2];\n    float t = iTime;\n    float c = cos (t);\n    float s = sin (t);\n    lightPositions[0] = vec3 (1.14, 1.5, -1.75);\n    lightPositions[1] = vec3 (-.125, 1.5, 1.75);\n\n\tvec3 N = normalize (nor);\n    vec3 V = normalize (ro - p);\n\n    vec3 F0 = vec3 (.04);\n    F0 = mix (F0, albedo, metallic);\n    vec3 kD = vec3 (.0);\n\t           \n    // reflectance equation\n    vec3 Lo = vec3 (.0);\n    for (int i = 0; i < 2; ++i) \n    {\n        // calculate per-light radiance\n        vec3 L = normalize (lightPositions[i] - p);\n        vec3 H = normalize (V + L);\n        float dist = distance (p, lightPositions[i]);\n        float attenuation = 4./(dist*dist);\n        vec3 radiance = lightColors[i]*attenuation;\n        \n        // cook-torrance brdf\n        float aDirect = pow (roughness + 1., 2.);\n        float aIBL =  roughness * roughness;\n        float NDF = distriGGX (N, H, roughness);\n        float G = geomSmith (N, V, L, roughness);\n        vec3 F = fresnelSchlick (max (dot (H, V), .0), F0, roughness);\n\n        vec3 kS = F;\n        kD = vec3 (1.) - kS;\n        kD *= 1. - metallic;\n        \n        vec3 nominator = NDF * G * F;\n        float denominator = 4. * max (dot (N, V), .0) * max (dot (N, L), .0);\n        vec3 specular = nominator / max (denominator, .001);  \n\n        // add to outgoing radiance Lo\n        float NdotL = max (dot (N, L), .0);                \n        Lo += (kD*albedo/PI + specular)*radiance*NdotL;\n    }\n\n    vec3 ambient = kD * albedo;\n\n    return ambient + Lo;\n}\n\nResult raymarch (in Ray ray)\n{\n    Result res = nullResult;\n\n    for (int i = 0; i < MAX_ITER; ++i) {\n        res.iter = i;\n        float tmp = map (ray.ro + res.dist * ray.rd);\n        if (tmp < EPSILON) break;\n        res.dist += tmp * STEP_SIZE;\n    }\n\n    res.point = ray.ro + res.dist * ray.rd;\n    res.normal = normal (res.point, EPSILON*res.dist);\n\n    return res;\n}\n\nfloat shadow (in Ray ray, in vec3 lPos)\n{\n    float distToLight = distance (lPos, ray.ro);\n    float dist = .0;\n\n    for (int i = 0; i < MAX_ITER; ++i) {\n        float tmp = map (ray.ro + dist * ray.rd);\n        if (tmp < EPSILON) {\n            if (dist < distToLight)\n                return .125;\n            else\n                return 1.;\n        }\n        dist += tmp * STEP_SIZE;\n    }\n\n    return 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float r = 1.5 + .5 * (cos (iTime)*.5+.5);\n    float theta = (iMouse.x / iResolution.x) * PI;\n    float phi = -(iMouse.y / iResolution.y * 2. - 1.) * PI;\n    float x = r * sin (theta) * cos (phi);\n    float y = r * sin (theta) * sin (phi);\n    float z = r * cos (theta);\n    vec3 ro = vec3 (x, y, z);\n    float zoom = 2.;\n    vec3 lookAt = vec3 (.0);\n    vec3 forward = normalize (lookAt - ro);\n    vec3 worldUp = vec3 (.0, 1., .0);\n    vec3 right = normalize (cross (worldUp, forward));\n    vec3 up = normalize (cross (forward, right));\n    vec3 camCenter = ro + zoom * forward;\n    vec3 i = camCenter + uv.x * right + uv.y * up;\n    vec3 rd = normalize (i - ro);\n\n    Ray ray = Ray (ro, rd);\n    Result res = raymarch (ray);\n    vec3 col = shadePBR (ro, rd, res.dist);\n\n    float fog = float (res.iter) / float (MAX_ITER);\n    col *= 1. - (fog * fog);\n\n    col = col / (.85 + col);\n    col *= vec3 (.95, .9, .85);\n    col = .3*col + .7*sqrt (col);\n\n    fragColor = vec4 (col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xl3cWs.jpg", "access": "shaders20k", "license": "gpl-3.0", "functions": [[1288, 1288, 1311, 1311, 1410], [1412, 1412, 1481, 1481, 2117], [2119, 2119, 2158, 2158, 2260], [2262, 2262, 2285, 2285, 2556], [2558, 2558, 2618, 2618, 2871], [2873, 2873, 2932, 2932, 3040], [3042, 3042, 3113, 3113, 3324], [3326, 3326, 3396, 3396, 3476], [3478, 3478, 3521, 3521, 3727], [3729, 3729, 3781, 3781, 5644], [5646, 5646, 5676, 5676, 6019], [6021, 6021, 6062, 6062, 6429], [6431, 6431, 6488, 6488, 7586]], "test": "ok"}
{"id": "Xl3yD2", "name": "Electric Biology", "author": "TanayStyle", "description": "More voronoi fun!", "tags": ["voronoi", "electric", "electricity", "biology", "flashes"], "likes": 2, "viewed": 238, "published": "Public", "date": "1534013289", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define tau 6.28318530718\n\nfloat sin01(float x) {\n\treturn (sin(x*tau)+1.)/2.;\n}\nfloat cos01(float x) {\n\treturn (cos(x*tau)+1.)/2.;\n}\n\n// rand func from theartofcode (youtube channel)\nvec2 rand01(vec2 p) {\n    vec3 a = fract(p.xyx * vec3(123.5, 234.34, 345.65));\n    a += dot(a, a+34.45);\n    \n    return fract (vec2(a.x * a.y, a.y * a.z));\n}\n\nfloat distFn(float t, vec2 from, vec2 to) {\n\tfloat x = length (from - to);\n    return pow (x, cos01(t/10.)*4.+1.2);\n}\n\nfloat voronoi(vec2 uv, float t, float seed, float size) {\n    \n    float minDist = 100.;\n    \n    float gridSize = size;\n    \n    vec2 cellUv = fract(uv * gridSize) - 0.5;\n    vec2 cellCoord = floor(uv * gridSize);\n    \n    for (float x = -1.; x <= 1.; ++ x) {\n        for (float y = -1.; y <= 1.; ++ y) {\n            vec2 cellOffset = vec2(x,y);\n            \n            // Random 0-1 for each cell\n            vec2 rand01Cell = rand01(cellOffset + cellCoord + seed);\n\t\t\t\n            // Get position of point in cell\n            vec2 point = cellOffset + sin(rand01Cell * (t+10.)) * .5;\n            \n\t\t\t// Get distance between pixel and point\n            float dist = distFn(t, cellUv, point);\n    \t\tminDist = min(minDist, dist);\n        }\n    }\n    \n    return minDist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Center coordinates at 0\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    \n    float t = iTime * .7;\n    \n\t// Distort uv coordinates\n    float amplitude = .05;\n    float turbulence = 0.8;\n    uv.xy += sin01(uv.x*turbulence + t/3.) * amplitude;\n    uv.xy -= sin01(uv.y*turbulence + t/3.) * amplitude;\n    \n\t// Apply layers of voronoi\n    float v1 = voronoi(uv, t, 0.5, 2.5) * 1.;\n    float v2 = voronoi(uv, t * 4., 0., 4.) * .4;\n    float v3 = voronoi(uv, t * 8., 0.3, 10.) * .15; // red\n    float v4 = voronoi(uv, t * 8., 0.2, 2.) * .18;\n    \n    // Color each of the layers\n    vec3 col1 = v1 * vec3(.45, 0., 1.);\n    vec3 col2 = v2 * vec3(.0, .5, .8);\n    vec3 col3 = v3 * vec3(1., .2, 0.);\n    vec3 col4 = v4 * vec3(1., 1., 0.);\n    \n    // Flashes\n    int timeIndex = int(fract(t) * 10.); // 0 to 9\n    vec3 background = vec3(0.);\n    float bright = 1.;\n    if (timeIndex == 7 || timeIndex == 9) {\n        vec3 backCol = vec3(.1, .0, .2);\n        background = (1.-v1-v2-v3-v4) * backCol;\n        bright = 1.4;\n    }\n    \n    // Sum up the colors\n    vec3 colSum = col1 + col2 + col3 + col4 + background;\n    \n    // Adjust brightness\n    colSum *= bright;\n    \n    // Output to screen\n    fragColor = vec4(colSum,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xl3yD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 49, 49, 79], [80, 80, 102, 102, 132], [134, 183, 204, 204, 341], [343, 343, 386, 386, 460], [462, 462, 519, 519, 1235], [1237, 1237, 1294, 1325, 2541]], "test": "ok"}
{"id": "Xl3yRs", "name": "[SH18]Humanz ", "author": "dcoombes", "description": "My entry for Shadertoy Competition 2018. Heavily based of IQ's samples. ", "tags": ["dave"], "likes": 0, "viewed": 284, "published": "Public", "date": "1533755978", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//dcoombes 2018\n//Based on IQ's code found here. That shader includes a link back to the distance field documentation\n//https://www.shadertoy.com/view/Xds3zN\n\n\n#define SCREENFX\n//#define MOUSE_ON\n\n#define \tM_PI   3.14159265358979323846\n#define \tDEG2RAD(x)   ((x) * 0.01745329251994329575)\n\n\n\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\nfloat rand(float x)  //returns a float between 0 and 1.0\n{\n    return fract(sin(x) * 43758.5453);\n}\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n\n\n\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n\n\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n\n\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n\n\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n\n\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\nfloat sdCylinder2( vec3 p, vec2 h )\n{\n//  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  vec2 d = abs(vec2(length(p.xy),p.z)) - h;\n \n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n\n\n\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\nfloat sdConeSection( in vec3 p, in float h, in float r1, in float r2 )\n{\n    float d1 = -p.y - h;\n    float q = p.y - h;\n    float si = 0.5*(r1-r2)/h;\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n\n\n\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\nmat4 rotZMat(float a)\n{ \nmat4 m;\nm[0] = vec4( cos(a), sin(a), 0.0, 0.0); //Sets the first column    \nm[1] = vec4(-sin(a), cos(a), 0.0, 0.0);    \nm[2] = vec4(    0.0,    0.0, 1.0, 0.0);    \nm[3] = vec4(    0.0,    0.0, 0.0, 1.0);     \n    \nreturn m;\n}\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\nmat4 rotYMat(float a)\n{ \nmat4 m;\nm[0] = vec4( cos(a),    0.0, sin(a), 0.0); //Sets the first column    \nm[1] = vec4(    0.0,    1.0,    0.0, 0.0);    \nm[2] = vec4(-sin(a),    0.0, cos(a), 0.0);    \nm[3] = vec4(    0.0,    0.0,    0.0, 1.0);     \n    \nreturn m;\n}\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n\n\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\nmat4 rotXMat(float a)\n{ \nmat4 m;\nm[0] = vec4(1.0, 0.0, 0.0, 1.0); //Sets the first column    \nm[1] = vec4(0.0, cos(a), sin(a), 0.0);    \nm[2] = vec4(0.0, -sin(a), cos(a), 0.0);    \nm[3] = vec4(0.0, 0.0, 0.0, 1.0);     \n    \nreturn m;\n}\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n\n\n\n\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\nvec3 opTx( vec3 p, mat4 m )\n{\n    vec4 q = m*vec4(p,1.0);\n    return q.xyz;\n}\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n\n\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n\n\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n//Subtract Operation\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\nfloat opS( float d1, float d2 ) \n{\n    return max(-d2,d1);\n}\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n\n\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n//Repeat Operation\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n\n\n\n\n\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n// polynomial smooth min (k = 0.1);\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n\n\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n\n\n#define SCALEF 1.0  //making it bigger did not fix artifacts.\n\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\nvec2 babyMap( in vec3 pos )\n{\n\n    vec2 res;\n    mat4 m;\n\n    m = rotYMat(DEG2RAD(iTime*50.0));\n    #define BUDDYDIST 2.8\n    \n       \n    vec3 rep = opRep(vec3(pos),vec3(BUDDYDIST,BUDDYDIST,BUDDYDIST));\n\trep = opTx(rep,m); \n    \n    //graph paper time!\n    \n    float head   = sdCapsule(rep,vec3(  0.12,  0.18,  0.00), vec3(  0.20,  0.34, 0.00), 0.29  );\n\tfloat utorso = sdCapsule(rep,vec3(  0.05,  0.20,  0.00), vec3( -0.10, -0.03, 0.00), 0.20   );\n    float ltorso = sdCapsule(rep,vec3( -0.10,  0.02,  0.00), vec3(  0.00,  -0.30, 0.00), 0.25   );\n    float should = sdCapsule(rep,vec3( -0.00,  0.10, -0.26), vec3(  0.00,   0.10, 0.26), 0.15   );\n    float hips   = sdCapsule(rep,vec3( -0.03, -0.32, -0.26), vec3( -0.03, -0.32, 0.26), 0.14   );\n\n    float leye    = sdSphere(rep-vec3( 0.33,0.22, 0.15), 0.15 );\n    float reye    = sdSphere(rep-vec3( 0.33,0.22, -0.15), 0.15 );\n    float nose    = sdCapsule(rep,vec3(  0.35,  0.23, -0.0), vec3( 0.47, 0.04, 0.0), 0.1   );\n\n    float luleg  = sdCapsule(rep,vec3( -0.03, -0.32, -0.26), vec3(  0.20, -0.28, -0.26), 0.10  );\n    float llleg  = sdCapsule(rep,vec3(  0.20, -0.28, -0.26), vec3(  0.30, -0.46, -0.26), 0.10   );\n    float lfoot  = sdCapsule(rep,vec3(  0.30, -0.46, -0.26), vec3(  0.40, -0.40, -0.26),  0.10   );\n    \n    float ruleg  = sdCapsule(rep,vec3( -0.03, -0.32,  0.26), vec3(  0.20, -0.28,  0.26), 0.10  );\n    float rlleg  = sdCapsule(rep,vec3(  0.20, -0.28,  0.26), vec3(  0.30, -0.46,  0.26), 0.10   );\n    float rfoot  = sdCapsule(rep,vec3(  0.30, -0.46,  0.26), vec3(  0.40, -0.40,  0.26),  0.10   );\n\n\n    float luarm  = sdCapsule(rep,vec3( -0.00,  0.10, -0.26), vec3(  0.10, -0.08, -0.26), 0.10  );\n    float llarm  = sdCapsule(rep,vec3(  0.10, -0.08, -0.26), vec3(  0.25, -0.08, -0.26),0.08  );\n    float lhand  = sdCapsule(rep,vec3(  0.25, -0.08, -0.26), vec3(  0.30, -0.08, -0.26),  0.10   );\n\n\n    float ruarm  = sdCapsule(rep,vec3( -0.00,  0.10, 0.26), vec3(  0.10, -0.08, 0.26), 0.10  );\n    float rlarm  = sdCapsule(rep,vec3(  0.10, -0.08, 0.26), vec3(  0.25, -0.08, 0.26),0.08  );\n    float rhand  = sdCapsule(rep,vec3(  0.25, -0.08, 0.26), vec3(  0.30, -0.08, 0.26),  0.10   );\n\n   \n    res = vec2(head,1.0);\n    res = vec2(smin(head,utorso,0.01),1.0);\n\n    \n    res = vec2(smin(res.x,ltorso,0.03),1.0);\n    res = vec2(smin(res.x,should,0.03),1.0);\n    res = vec2(smin(res.x,hips,0.03),1.0);\n\n\n    res = vec2(smin(res.x,luleg,0.03),1.0);\n    res = vec2(smin(res.x,llleg,0.03),1.0);\n    res = vec2(smin(res.x,lfoot,0.03),1.0);\n    \n    res = vec2(smin(res.x,ruleg,0.03),1.0);\n    res = vec2(smin(res.x,rlleg,0.03),1.0);\n    res = vec2(smin(res.x,rfoot,0.03),1.0);\n\n    res = vec2(smin(res.x,luarm,0.03),1.0);\n    res = vec2(smin(res.x,llarm,0.03),1.0);\n    res = vec2(smin(res.x,lhand,0.03),1.0);\n\n    res = vec2(smin(res.x,ruarm,0.03),1.0);\n    res = vec2(smin(res.x,rlarm,0.03),1.0);\n    res = vec2(smin(res.x,rhand,0.03),1.0);\n    \n\n    res = vec2(smin(res.x,nose,0.08),1.0);\n\n\n    res = opU( res,vec2(leye,2.0));\n    res = opU( res,vec2(reye,2.0));\n    \n   \n    return res;\n\n}\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n\n\n\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 25.0; \n    \n#if 0\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n\t\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<64; i++ )\n    {\n\t    float precis = 0.0004*t;\n        vec2 res = babyMap( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        //t += res.x; \n        t += res.x/1.2; //Dave changed the stepsize to get rid of a artfacts... \n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\nvec3 calcNormal( in vec3 pos )\n{\n\t    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*babyMap( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*babyMap( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*babyMap( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*babyMap( pos + e.xxx ).x );\n   \n\n}\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n\n\n\n\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n\nvec3 col = vec3(0.0, 0.0, 0.0);\nvec2 res = castRay(ro,rd);    \n    \nvec3 skinCol = vec3(059.0/255.0,055.0/255.0,120.0/255.0);\nvec3 eyeCol  = vec3(0.99,0.01,0.10);\n    \n    \nfloat t = res.x;\nfloat m = res.y;\n\nif( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n       \n        vec3  lig = normalize( vec3(-0.0, 0.3, -0.9) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.2, 1.0 ); //set the dark here.\n        \n              \n      //  amb = amb/4.0;\n        amb = 0.0;\n        \n        \n                \n\t\tif (m==1.0)\n        {\n            col = skinCol;\n        }\n        else\n        {\n           col = eyeCol;\n        }\n        \n        \n        \n       col = clamp((col*dif)+amb,0.0,1.0);\n        \n    }\n    \n    \n    \n    \n    \nreturn vec3( clamp(col,0.0,1.0) );\n}\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n\n\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n#define CHARWIDTH 0.03\nfloat human(vec2 tx,vec2 pos)\n{\n\tfloat r;\n\n    pos+=tx;\n   \n    if(pos.y>0.08 && pos.y <=0.12)\n\t{\n\t\t//H\n        float vstroke;\n        vstroke = 0.0;\n        r=  step(vstroke,pos.x)  * (1.0-step (vstroke+0.1,pos.x));\n\t    if(r!=0.0) return 1.0;\n\n        //A\n        vstroke = 0.45;\n        r=  step(vstroke,pos.x)  * (1.0-step (vstroke+0.1,pos.x));\n\t    if(r!=0.0) return 1.0;\n    }\n\n    if(pos.y>0.18 && pos.y <=0.2)\n\t{\n\t\t//M\n        float vstroke;\n        vstroke = 0.30;\n        r=  step(vstroke,pos.x)  * (1.0-step (vstroke+0.1,pos.x));\n\t    if(r!=0.0) return 1.0;\n\n        //A\n        vstroke = 0.45;\n        r=  step(vstroke,pos.x)  * (1.0-step (vstroke+0.1,pos.x));\n\t    if(r!=0.0) return 1.0;\n\n        //N\n        vstroke = 0.60;\n        r=  step(vstroke,pos.x)  * (1.0-step (vstroke+0.1,pos.x));\n\t    if(r!=0.0) return 1.0;\n    }\n\n    \n    if(pos.y>0.0 && pos.y <=0.02)\n\t{\n\t\t//U\n        float vstroke;\n        vstroke = 0.15;\n        r=  step(vstroke,pos.x)  * (1.0-step (vstroke+0.1,pos.x));\n\t    if(r!=0.0) return 1.0;\n    }\n\n\n    \n    \n    \n    \n    if(pos.y <=0.2 && pos.y>0.0)\n\t{\n\t\t//H\n        float vstroke;\n        vstroke = 0.0;\n        r=  step(vstroke,pos.x)  * (1.0-step (vstroke+CHARWIDTH,pos.x));\n\t    if(r!=0.0) return 1.0;\n\n        vstroke = 0.1;\n        r=  step(vstroke,pos.x)  * (1.0-step (vstroke+CHARWIDTH,pos.x));\n\t    if(r!=0.0) return 1.0;\n\n        //U\n        vstroke = 0.15;\n        r=  step(vstroke,pos.x)  * (1.0-step (vstroke+CHARWIDTH,pos.x));\n\t    if(r!=0.0) return 1.0;\n\n        vstroke = 0.25;\n        r=  step(vstroke,pos.x)  * (1.0-step (vstroke+CHARWIDTH,pos.x));\n\t    if(r!=0.0) return 1.0;\n\n        //M\n        vstroke = 0.3;\n        r=  step(vstroke,pos.x)  * (1.0-step (vstroke+CHARWIDTH,pos.x));\n\t    if(r!=0.0) return 1.0;\n\n        vstroke = 0.35;\n        r=  step(vstroke,pos.x)  * (1.0-step (vstroke+CHARWIDTH,pos.x));\n\t    if(r!=0.0) return 1.0;\n\n        vstroke = 0.40;\n        r=  step(vstroke,pos.x)  * (1.0-step (vstroke+CHARWIDTH,pos.x));\n\t    if(r!=0.0) return 1.0;\n\n        //A\n        vstroke = 0.45;\n        r=  step(vstroke,pos.x)  * (1.0-step (vstroke+CHARWIDTH,pos.x));\n\t    if(r!=0.0) return 1.0;\n\n        vstroke = 0.55;\n        r=  step(vstroke,pos.x)  * (1.0-step (vstroke+CHARWIDTH,pos.x));\n\t    if(r!=0.0) return 1.0;\n\n        //N\n        vstroke = 0.6;\n        r=  step(vstroke,pos.x)  * (1.0-step (vstroke+CHARWIDTH,pos.x));\n\t    if(r!=0.0) return 1.0;\n\n        vstroke = 0.7;\n        r=  step(vstroke,pos.x)  * (1.0-step (vstroke+CHARWIDTH,pos.x));\n\t    if(r!=0.0) return 1.0;\n        \n        \n        \n        \n\n        \n    }\n   return 0.0; \n}\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n\n\n\n\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    \n\tvec2 logoP =p; //keep a copy of the pixel coord without wibble/wobble for the logo\n\tvec2 logoPos;      \n    \n#ifdef SCREENFX\n    float temp;\n    float wibble = sin(modf(iTime*0.1,temp));\n    \n    \n    //float wobble =(p.y*1.1)+(5.2*sin(p.y*200.0)/200.0);\n    float wobble =(0.6*sin((p.y+wibble)*200.0)/200.0);\n\tp.x+= wobble;       \n#endif\n    \n   \n\n    \n    float time = 15.0 + iTime;\n \n#ifdef MOUSE_ON\n    vec2 mo = iMouse.xy/iResolution.xy;\n#else\n    vec2 mo = vec2(0.0,0.0);\n#endif\n    \n\n    vec3 ro = vec3( -0.5+3.5*cos(0.1 + 3.0*mo.x), 0.0 + 2.0*mo.y, 0.5 + 4.0*sin(0.1 + 6.0*mo.x) );\n    vec3 ta = vec3( -0.0, -0.0, 0.0 );\n\n    float tseq; \n    float delta = modf(iTime*0.2,tseq);  //delta is fraction eg anim time 0..1,  \n    float interp = smoothstep(0.1,0.8,delta);  \n    int currAnim = int(tseq)%4; //rolls through 4 animations\n    \n   \n    if(currAnim == 0)\n    {\n\t    vec3 t1 = vec3(0.0, 0.0, 0.0);\n\t    vec3 t2 = vec3(0.0, 0.0, 0.0 );\n\t\tta= mix(t1,t2,interp);\n        logoPos =  vec2(-0.9,0.85);\n    }    \n\n    if(currAnim == 1)\n    {\n\t    vec3 t1 = vec3(0.0, 6.0, 0.0);\n\t    vec3 t2 = vec3( -0.0, -6.0, 0.0 );\n\t\tta = mix(t1,t2,interp);     \n        logoPos =  vec2(1.65,0.85);\n\n    }    \n\n    if(currAnim == 2)\n    {\n    \tvec3 t1 = vec3( -4.0, -3.0, 0.0 );\n    \tvec3 t2 = vec3(  4.0, -3.0, 0.0 );\n\t\tta= mix(t1,t2,interp);     \n\n        logoPos =  vec2(1.65,-0.65);\n\n    }    \n\n    if(currAnim == 3)\n    {\n    \tvec3 t1 = vec3( 3.0, -3.0, 0.0);\n    \tvec3 t2 = vec3(0.0, 2.0, 0.0 );\n\t\tta= mix(t1,t2,interp);     \n        logoPos =  vec2(-0.9,-0.65);\n\n    }    \n   \n   \n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.5) );\n\n    \n    \n    // render\t\n    vec3 col;\n    col = render( ro, rd );\n    \n#ifdef SCREENFX\n    col.x+= 0.1*rand(p.x+p.y+wibble);\n    col.y+= 0.1*rand(p.y+p.y+wibble);\n    col.z+= 0.1*rand(p.y+p.y+wibble);\n#endif\n    \n    \n        \n    //Vignette effect\n \tfloat distFromOrig = (logoP.x*logoP.x)+(logoP.y*logoP.y); // cant be much bigger than 1... :-0\n    float fader = smoothstep(1.0,2.6,distFromOrig);\n    col = col*(1.0-fader);\n      \n\t//Render the \"Human\" logo\n    vec2 tx = vec2(-0.9,0.85);\n    if(human(logoPos,logoP)!=0.0) col = vec3(1.0,0.0,0.0);\n    \n    \n    fragColor=vec4( col, 1.0 );\n    \n\n}\n//---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xl3yRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[292, 522, 580, 580, 621], [740, 970, 995, 995, 1010], [1127, 1357, 1392, 1392, 1418], [1536, 1766, 1797, 1797, 1884], [2001, 2231, 2283, 2283, 2397], [2515, 2745, 2781, 2781, 2880], [2998, 3228, 3273, 3273, 3313], [3431, 3661, 3698, 3744, 3845], [3964, 4194, 4266, 4266, 4481], [4600, 4830, 4853, 4853, 5080], [5197, 5427, 5450, 5450, 5689], [5807, 6037, 6060, 6060, 6272], [6392, 6622, 6651, 6651, 6699], [6817, 7047, 7077, 7077, 7110], [7228, 7479, 7513, 7513, 7539], [7657, 7906, 7936, 7936, 7965], [8086, 8352, 8393, 8393, 8486], [8604, 8834, 8886, 8886, 9063], [9244, 9474, 9503, 9503, 12536], [12655, 12885, 12925, 12925, 13616], [13733, 13963, 13995, 13995, 14225], [14345, 14575, 14614, 14614, 15517], [15888, 15888, 15919, 15919, 18508], [18628, 18858, 18915, 18915, 21356]], "test": "error"}
{"id": "Xl3yzl", "name": "WarpGrid", "author": "mildanach", "description": "another colorful wave animation", "tags": ["grid", "wave", "illusion"], "likes": 9, "viewed": 139, "published": "Public", "date": "1533573371", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float SC = 400., \n    \t\tQ = 0.1,\n\t\t\tA = 5.;\n\nvec3 grid(vec2 uv, vec2 pos)\n{\n\tfloat v = max(sin(pos.x), cos(pos.y));\n\tfloat shade = 0.25*(2.+sin(Q*uv.x))\n\t\t\t\t\t*(2.+sin(Q*uv.y));\n\treturn vec3(v*shade, v*(shade-1.), 0.);\n}\n\nvec2 warp(vec2 pos)\n{\n\tfloat TSC = 0.3 * iTime;\n\tvec2 T = vec2(-50.*TSC, 20.*sin(TSC));\n\tvec2 uwave = vec2(sin(Q*pos.y), sin(Q*pos.x));\n\treturn pos + A*uwave + T;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat mx = max(iResolution.x, iResolution.y);\n    vec2 uv = fragCoord.xy / mx;\n    \n    vec3 rgb = grid(SC*uv, warp(SC*uv));\n    fragColor = vec4(rgb, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xl3yzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 81, 81, 225], [227, 227, 248, 248, 391], [393, 393, 450, 450, 610]], "test": "ok"}
{"id": "Xlccz2", "name": "Voronoi example", "author": "darkeclipz", "description": "A simple Voronoi example.", "tags": ["voronoi"], "likes": 0, "viewed": 96, "published": "Public", "date": "1533147917", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float seed = 0.0;\nfloat random() {\n\treturn fract( sin( seed++ * 4871452.47 ) * 87175.89 );\n}\n\n#define N 64\n#define t iTime\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Rescale.\n    vec2 R = iResolution.xy;\n    vec2 uv = (2.*fragCoord-R)/R.y;\n    vec2 M = (2.*iMouse.xy-R)/R.y;\n    \n    // Colors.\n    vec3 col = vec3(0);\n    vec3 colP = vec3(0);\n    \n    // Location of each points (x, y)\n    vec2 points[N];\n    \n    // Distance from uv to point N.\n    float pDistances[N];\n    \n    // Distance to the closest point from uv.\n    float minDist = 0.0;\n    \n    // Index of the closest point.\n\tint minN = 0;\n    \n    for(int i=0; i < N; i++) {\n                \n        // Create a random point.\n        points[i] = 2. * vec2(random(), random()) - 1.;\n        \n        // Override this with two circling points.\n        if(i == N-1) points[i] = .8*vec2(cos(t/4.), sin(t/4.));\n        if(i == N-2) points[i] = .4*vec2(cos(-t/2.), sin(-t/2.));\n        \n        // Distance from uv to the created point.\n        float d = distance(points[i], uv);\n        \n        // if min dist = 0, this is the first point, so we use that.\n        if(minDist == 0.0) minDist = d;\n        \n        // Save the closest point.\n        minDist = min(minDist, d);\n        \n        // Store the index.\n        if(minDist == d) minN = i;   \n        \n        // Used to display the point on the screen.\n        if( distance(uv, points[i]) < 0.01 ) col = vec3(1);   \n        \n    }\n    \n    // Get a normalized index for each cell.\n    float normN = float(minN)/float(N);\n    \n    // Get a color for the cell.\n    col = 0.5 + 0.5*cos( 3.*normN + vec3(0,2,4) + t );\n    \n    // Render points.\n    for(int i=0; i < N && fract(t/8.) < .5; i++) {\n    \tif( distance(uv, points[i]) < 0.01 ) col = vec3(1); \n\t}\n\n    \n    // Set the color, but if the cell is the mouse, it should\n    // be black.\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xlccz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 18, 34, 34, 92], [124, 124, 181, 197, 1912]], "test": "ok"}
{"id": "XldcRl", "name": "Happy glutton Pac", "author": "Ignitron", "description": "Another pacman shader!", "tags": ["pacman"], "likes": 10, "viewed": 202, "published": "Public", "date": "1533668304", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\tFirst of all I want share a thousand thanks to my namesake Iigo Quilez for letting everyone enjoy such a nice tool, \n\twhere one can develop and visualize its own fantasies :)\n\t\n\tWarn: This code is a mix from many geniouses that copied others who copied others(nested forever).\n\tAlso pretends to be didactic in a fairly easy way.\n\t\n\tWould love mentioning the users Nrx & iquilez as my main influences on this shader(functions, ideas, talent, etc...).\n\t\n\tHope someone enjoys it and why not, copy some aspects if they are deserved! :D\n\t\n\tPD: It is highly possible that there are some remains from my own engine, literally unusable here... sorry for it\n\n\tThank you, again, to my love Sara, for ... the other funny point of view!\n*/\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define MOUSE\n#define SHADOW\n#define ARMS\n#define LEGS\n\n#define CAMERA_FOCAL_LENGTH\t2.0\n\n#define RAY_LENGTH_MAX\t\t1000.0\n#define RAY_STEP_MAX\t\t1000.0\n#define DELTA\t\t\t0.2\n#define DELTA_SEARCH\t0.1527\n\n#define NORMAL_DELTA\t\t0.2\n\n#define SHADOW_LENGTH\t\t600.0\n#define SHADOW_POWER\t\t1.0\n#define SHADOW_DELTA\t\t0.12\n\n#define AMBIENT\t\t\t0.1\n\n#define GAMMA\t\t\t1.0\n\n#define BACKGROUND_COLOR vec3(0.3, 0.4, 0.6)\n\n// Math constants\n#define PI\t\t3.14159265359\n#define PI2\t\t6.28318530718\n\n//Config\nvec3 pacmanColor = vec3(0.9,0.65,0.1);\nvec3 pacmanMat = vec3(1.0,0.1,0.0);\nvec3 gloveColor = vec3(1.0,0.545,0.298);\nvec3 gloveMat = vec3(5.0,0.3,0.0);\nvec3 bootColor = vec3(0.55,0.145,0.1);\nvec3 bootMat = vec3(2.0,0.1,0.0);\nvec3 bigBiscuitColor = vec3(1.0,0.75,0.15);\nvec3 bigBiscuitMat = vec3(30.0,0.5,0.0);\nvec3 biscuitColor = vec3(0.9,0.65,0.1);\nvec3 biscuitMat = vec3(10.0,0.5,0.0);\nvec3 groundColor = vec3(0.1,0.898,0.545);\nvec3 groundMat = vec3(3.0,0.0,0.0);\nvec3 tongueColor = vec3(0.9,0.1,0.1);\nvec3 tongueMat = vec3(10.0,5.0,0.0);\nvec3 eyeBallColor = vec3(0.0,0.0,0.0);\nvec3 eyeBallMat = vec3(30.0,1.0,0.0);\nvec3 eyeBall2Color = vec3(0.5,0.5,1.0);\nvec3 eyeBall2Mat = vec3(50.0,3.0,0.0);\n\n//Lighting\nvec3 lightDir = normalize(vec3(0.9,0.8,0.2));\nvec3 light2Dir = normalize(vec3(-0.9,-0.8,-0.2));\nfloat light2Pow = 0.1;\n\n\nmat3 rotX(float c, float s)\n{ \n    return mat3( 1.0, 0.0, 0.0, \n                0.0, c, s, \n                0.0, -s, c);\n}\n\nmat3 rotY(float c, float s)\n{ \n    return mat3( c, 0.0,-s, \n                0.0,1.0,0.0, \n                s, 0.0, c);\n}\n\nmat3 rotZ(float c, float s)\n{ \n    return mat3( c, s, 0.0,\n                -s, c, 0.0, \n                0.0, 0.0, 1.0);\n}\n\nfloat smin( float a, float b, float k, float l )\n{\n\tfloat h = clamp( l + l*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 smin( vec2 a, vec2 b, float k, float l )\n{\n\tfloat h = clamp( l + l*(b.x-a.x)/k, 0.0, 1.0 );\n\treturn vec2( mix( b.x, a.x, h ) - k*h*(1.0-h), mix( b.y, a.y, h ) );\n}\n\nfloat smax( float a, float b, float k, float l )\n{\n\tfloat h = clamp( l + l*(b-a)/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 c, in vec3 r )\n{\n    return (length( (p-c)/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nvec2 sdSegment( vec3 a, vec3 b, vec3 p )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ), h );\n}\n\nfloat reboundValue( float iTime, float limit )\n{\n    float doubleLimit = limit*2.0;\n\tfloat doubleValue = mod(iTime, doubleLimit);\n    if(doubleValue>limit)\n        return doubleLimit-doubleValue;\n    return doubleValue;\n}\n\n\n// Distance to the scene and color of the closest point\nfloat distScene (in vec3 p, out vec3 color, out vec3 material) {\n\tfloat d = 1000.0;\n    float d2 = 1000.0;\n    float d3 = 1000.0;\n    float d4 = 1000.0;\n    \n    float speed = iTime*0.5;\n    \n    float speedPI2 = speed*PI2;\n    \n    vec3 pacmanPos = vec3(0.0,sin((speedPI2)-2.2)*20.0,0.0);\n    \n    //body\n    vec3 pacmanRelPos = p-pacmanPos;\n    float body = length (pacmanRelPos);\n\tbody = max (body - 32.0, 27.5 - body);\n\tfloat mouthAngle = PI * (0.09 + 0.08 * sin (speedPI2));\n    vec3 mouthPos = pacmanRelPos-vec3(0.0,3.0,5.0);\n\tfloat mouthTop = dot (mouthPos, vec3 (0.0, -cos (mouthAngle), sin (mouthAngle))) - 2.0;\n\tmouthAngle *= 1.8;\n\tfloat mouthBottom = dot (mouthPos, vec3 (0.0, cos (mouthAngle), sin (mouthAngle)));\n\tfloat pacManBody = max (body, min (mouthTop, mouthBottom));\n    \n    d = pacManBody;\n    color = pacmanColor;\n    material = pacmanMat;\n    \n    // EYES\n    float eyesAngle = sin(speedPI2)*2.0;\n    vec3 eyesPos = vec3 (abs (pacmanRelPos.x) - 11.5, pacmanRelPos.y - (18.2)-eyesAngle, pacmanRelPos.z - (19.2 - eyesAngle));\n    vec3 q = 1.2*eyesPos;\n\tfloat eyeBall = max (length (q) - (6.0), -p.z);\n    q = 1.0*eyesPos;\n    float eyeBall2 = min(eyeBall,max (length (q) - (6.0), -p.z));\n    eyeBall2 = max(pacManBody-0.1,eyeBall2);\n\tif (eyeBall2 <= d) {\n        d = eyeBall2;\n        if(eyeBall < eyeBall2)\n        {\n            color = eyeBallColor;\n        \tmaterial = eyeBallMat;\n        }\n        else\n        {\n        \tcolor = eyeBall2Color;\n        \tmaterial = eyeBall2Mat;\n        }\n    }\n    \n    //TONGUE\n    float tongueFactor = abs(sin(mod(speed*2.0,PI2)));\n    vec3 tongueAnim = vec3(1.0,1.4,2.5)*tongueFactor;\n    float tongue = sdEllipsoid( vec3(abs(p.x), p.yz), \n                               vec3(3.0,-18.5,-3.0)+pacmanPos, \n                               vec3(14.0,3.2,17.0)+tongueAnim );\n    d2 = smin(pacManBody,tongue,2.06,0.5);\n    if(d2 < d)\n    {\n        d = d2;\n        if(tongue <= d2+0.09)\n        {\n            color = tongueColor;\n    \t\tmaterial = tongueMat;\n        }\n    }\n    \n    float mirrorX = sign(p.x);\n    \n    #ifdef ARMS\n    float armsPeriod = PI*0.55;\n    float armsPeriodiTime = (speedPI2*0.275)-1.15+((mirrorX+1.0)*0.5*armsPeriod);\n    float armRotSegmentA = reboundValue(armsPeriodiTime,armsPeriod)-1.0;\n    float armsSinRotA = sin(armRotSegmentA);\n    float armsCosRotA = cos(armRotSegmentA);\n    mat3 armsSegmentARot = rotX(armsCosRotA, armsSinRotA);\n    \n    float armRotSegmentB0 = reboundValue(armsPeriodiTime,armsPeriod)-0.7;\n    float armsSinRotB0 = sin(armRotSegmentB0);\n    float armsCosRotB0 = cos(armRotSegmentB0);\n    mat3 armsSegmentB0Rot = rotY(armsCosRotB0, armsSinRotB0);\n    \n    float armRotSegmentB1 = reboundValue(armsPeriodiTime,armsPeriod)-1.1;\n    float armsSinRotB1 = sin(armRotSegmentB1);\n    float armsCosRotB1 = cos(armRotSegmentB1);\n    mat3 armsSegmentB1Rot = rotX(armsCosRotB1, armsSinRotB1);\n    \n    float armRotSegmentB2 = reboundValue(armsPeriodiTime,armsPeriod)-0.1;\n    float armsSinRotB2 = sin(armRotSegmentB2);\n    float armsCosRotB2 = cos(armRotSegmentB2);\n    mat3 armsSegmentB2Rot = rotZ(armsCosRotB2, armsSinRotB2);\n    \n    mat3 armsSegmentBRot = armsSegmentB0Rot*armsSegmentB1Rot*armsSegmentB2Rot;\n    \n    vec3 armsSegmentAPos = vec3(28.0,3.0,-2.0)+pacmanPos;\n    vec3 armsSegmentBPos = armsSegmentARot*(vec3(10.0,-10.0,5.0))+armsSegmentAPos;\n    vec3 armsSegmentCPos = armsSegmentBRot*(vec3(1.0,-2.0,15.0))+armsSegmentBPos;\n    \n    vec2 armSegmentA = sdSegment( armsSegmentAPos, armsSegmentBPos, vec3(abs(p.x),p.yz) );\n\td2 = armSegmentA.x - 4.0 + armSegmentA.y*1.0;\n \td2 = smin(pacManBody,d2,1.06,0.5);\n    if (d2 < d) {\n        d = d2;\n\t\tcolor = pacmanColor;\n    \tmaterial = pacmanMat;\n\t}\n    \n    vec2 armSegmentB = sdSegment( armsSegmentBPos, armsSegmentCPos, vec3(abs(p.x),p.yz) );\n\td4 = armSegmentB.x - 3.0 + armSegmentB.y*1.0;\n \td2 = smin(d2,d4,2.06,0.5);\n    if (d2 < d) {\n        d = d2;\n\t\tcolor = pacmanColor;\n    \tmaterial = pacmanMat;\n\t}\n    \n    //Hand\n    vec3 handPos = armsSegmentBRot*vec3(0.0,0.0,1.2)+armsSegmentCPos;\n    \n    vec2 hand = sdSegment( armsSegmentCPos, handPos, vec3(abs(p.x),p.yz) );\n\td3 = hand.x - 3.0 + hand.y*0.1;\n \td2 = smin(d2,d3,2.06,0.5);\n    \n    d2 = smax(-d4,d3,1.06,0.5);\n    if (d2 < d) {\n        d = d2;\n        if(d3 <= d2+0.28)\n        {\n            color = gloveColor;\n            material = gloveMat;\n        }\n\t}\n    \n    //Fingers\n    vec3 fingerPos00 = armsSegmentBRot*vec3(-2.0,2.6,8.2)+armsSegmentCPos;\n    vec3 fingerPos01 = armsSegmentBRot*vec3(-2.0,0.0,9.5)+armsSegmentCPos;\n    vec3 fingerPos02 = armsSegmentBRot*vec3(-2.0,-2.6,8.2)+armsSegmentCPos;\n    \n    vec2 finger00 = sdSegment( armsSegmentCPos, fingerPos00, vec3(abs(p.x),p.yz) );\n\td3 = finger00.x - 1.5 + finger00.y*0.5;\n    d2 = smin(d2,d3,0.01,0.1);\n    \n    vec2 finger01 = sdSegment( armsSegmentCPos, fingerPos01, vec3(abs(p.x),p.yz) );\n\td3 = finger01.x - 1.5 + finger01.y*0.5;\n    d2 = smin(d2,d3,0.01,0.1);\n    \n    vec2 finger02 = sdSegment( armsSegmentCPos, fingerPos02, vec3(abs(p.x),p.yz) );\n\td3 = finger02.x - 1.5 + finger02.y*0.5;\n \td2 = smin(d2,d3,0.01,0.1);\n    \n    if (d2 < d) {\n        d = d2;\n        if(d3 <= d2+0.28)\n        {\n        color = gloveColor;\n        material = gloveMat;\n        }\n\t}\n    #endif\n    \n    #ifdef LEGS\n    float legsPeriod = PI*0.75;\n    float legsPeriodiTime = ((speedPI2*0.375)-1.55)+((-mirrorX+1.0)*0.5*legsPeriod);\n    float legRotSegmentA = reboundValue(legsPeriodiTime,legsPeriod)-1.4;\n    float legsSinRotA = sin(legRotSegmentA);\n    float legsCosRotA = cos(legRotSegmentA);\n    mat3 legsSegmentARot = rotX(legsCosRotA, legsSinRotA);\n    \n    float legRotSegmentB1 = reboundValue(legsPeriodiTime*0.85-1.1,legsPeriod*0.85);\n    float legsSinRotB1 = sin(legRotSegmentB1);\n    float legsCosRotB1 = cos(legRotSegmentB1);\n    mat3 legsSegmentB1Rot = rotX(legsCosRotB1, legsSinRotB1);\n    \n    mat3 legsSegmentBRot = legsSegmentB1Rot*legsSegmentARot;\n    \n    vec3 legsSegmentAPos = vec3(14.0,-27.0,1.0)+pacmanPos;\n    vec3 legsSegmentBPos = legsSegmentARot*(vec3(0.0,-22.0,0.0))+legsSegmentAPos;\n    vec3 legsSegmentCPos = legsSegmentBRot*(vec3(0.0,-20.0,0.0))+legsSegmentBPos;\n    \n    vec2 legsegmentA = sdSegment( legsSegmentAPos, legsSegmentBPos, vec3(abs(p.x),p.yz) );\n\td2 = legsegmentA.x - 4.5 + legsegmentA.y*1.0;\n \td2 = smin(pacManBody,d2,3.06,0.5);\n    if (d2 < d) {\n        d = d2;\n\t\tcolor = pacmanColor;\n    \tmaterial = pacmanMat;\n\t}\n    \n    vec2 legsegmentB = sdSegment( legsSegmentBPos, legsSegmentCPos, vec3(abs(p.x),p.yz) );\n\td4 = legsegmentB.x - 3.5 + legsegmentB.y*1.0;\n \td2 = smin(d2,d4,2.06,0.5);\n    if (d2 < d) {\n        d = d2;\n\t\tcolor = pacmanColor;\n    \tmaterial = pacmanMat;\n\t}\n    \n    //Boot\n    vec3 bootPos = legsSegmentBRot*vec3(0.0,-4.6,14.2)+legsSegmentCPos;\n    \n    vec2 boot = sdSegment( legsSegmentCPos, bootPos, vec3(abs(p.x),p.yz) );\n\td3 = boot.x - 5.5 + boot.y*1.4;\n    d2 = smin(d,d3,2.06,0.5);\n    d2 = smax(-d4,d3,6.06,0.5);\n    if (d2 < d) {\n        d = d2;\n        if(d3 <= d2+0.28)\n        {\n            color = bootColor;\n            material = bootMat;\n        }\n\t}\n    #endif\n    \n    // Biscuits\n    float biscuitPeriod = 200.0;\n    \n    float displacement = floor (speed * biscuitPeriod);\n    \n    float idsPerPeriod = 8.0;\n    \n    float fullPeriod = biscuitPeriod*idsPerPeriod;\n    \n    float modPerPeriod = mod (p.z + displacement, fullPeriod);\n    \n    float unitDist = fullPeriod/idsPerPeriod;\n\n\tfloat idValue = modPerPeriod/unitDist;\n\tidValue = idValue-fract(idValue ); // modf(idValue, idValue);\n    \n    float difSize = floor(idValue/(idsPerPeriod-1.0))*4.0;\n\tq = vec3 (p.xy, mod (p.z + displacement, biscuitPeriod) - biscuitPeriod * 0.5);\n\tfloat biscuit = max (length (q) - (6.0+difSize), -p.z);\n\tif (biscuit < d) {\n\t\td = biscuit;\n        if(idValue==(idsPerPeriod-1.0))\n        {\n            color = bigBiscuitColor;\n        \tmaterial = bigBiscuitMat;\n        }\n        else\n        {\n            color = biscuitColor;\n        \tmaterial = biscuitMat;\n        }\n\t}\n    \n    // Ground\n\tfloat ground = (p.y + 91.50 );\n\tif (ground < d) {\n\t\td = ground;\n\t\tcolor = groundColor;\n        material = groundMat;\n\t}\n    \n    \n\treturn d;\n}\n\n// Distance to the scene\nvec2 dist (inout vec3 p, in vec3 ray, in float rayLengthMax, in float delta, out vec3 color, out vec3 material) {\n    color = vec3(0.0,0.0,0.0);\n    material = vec3(0.0,0.0,0.0);\n\tfloat d = 0.0;\n\tfloat rayLength = 0.0;\n\tfor (float rayStep = 0.0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\t\td = distScene (p, color, material);\n\t\tif (d < delta) {\n\t\t  break;\n\t\t}\n\t\td = d*DELTA_SEARCH;\n\t\trayLength += d;\n\t\tif (rayLength > rayLengthMax) {\n\t\t\tbreak;\n\t\t}\n\t\tp += d * ray;\n\t}\n\treturn vec2 (d, rayLength);\n}\n\n// Normal at a given point\nvec3 normal (in vec3 p) {\n\tvec2 h = vec2 (NORMAL_DELTA, -NORMAL_DELTA);\n    vec3 dummy0, dummy1;\n\tvec3 n;\n\tn = h.xxx * distScene (p + h.xxx, dummy0, dummy1) +\n\t\t\th.xyy * distScene (p + h.xyy, dummy0, dummy1) +\n\t\t\th.yxy * distScene (p + h.yxy, dummy0, dummy1) +\n\t\t\th.yyx * distScene (p + h.yyx, dummy0, dummy1);\n\treturn normalize (n);\n}\n\n// Main function\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\t// Get the fragment\n\tvec2 frag = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n\t// Define the ray corresponding to this fragment\n\tvec3 ray = normalize (vec3 (frag, CAMERA_FOCAL_LENGTH));\n\n\t// Compute the orientation of the camera\n\tfloat yawAngle = PI * (1.9) + clamp(reboundValue( iTime, PI2*1.15 ), PI, PI2);\n\tfloat pitchAngle = PI*(0.1);\n    \n\t#ifdef MOUSE\n\t\tyawAngle += 8.0 * PI * iMouse.x;\n\t\tpitchAngle += PI * 8.0 * (1.0 - iMouse.y);\n\t#endif\n\n\tfloat cosYaw = cos (yawAngle);\n\tfloat sinYaw = sin (yawAngle);\n\tfloat cosPitch = cos (pitchAngle);\n\tfloat sinPitch = sin (pitchAngle);\n\n\tmat3 cameraOrientation;\n\tcameraOrientation [0] = vec3 (cosYaw, 0.0, -sinYaw);\n\tcameraOrientation [1] = vec3 (sinYaw * sinPitch, cosPitch, cosYaw * sinPitch);\n\tcameraOrientation [2] = vec3 (sinYaw * cosPitch, -sinPitch, cosYaw * cosPitch);\n\n\tray = cameraOrientation * ray;\n\n\t// Compute the origin of the ray\n\tfloat cameraDist = 250.0;\n\tvec3 origin = (clamp(reboundValue( iTime, PI2*1.5 ), 0.0, PI)*10.0+(vec3 (0.0, -30.0, 0.0)) - cameraOrientation [2] * cameraDist);\n\n\t// Compute the distance to the scene\n    vec3 color;\n    vec3 material;\n\tvec2 d = dist (origin, ray, RAY_LENGTH_MAX, DELTA, color, material);\n\n\t// Set the background color\n\tvec3 finalColor = vec3(0.0,0.0,0.0);\n\tif (d.x < DELTA) {\n        vec3 n = normal (origin);\n        vec3 diffuse = color * max(0.0,dot(n,lightDir));\n        float specular = pow (max (0.0, dot (reflect (ray, n), lightDir)), material.x) * material.y;\n        vec3 ambient = (AMBIENT*color*groundColor);\n        finalColor = (diffuse+specular);\n        \n        diffuse = color * max(0.0,dot(n,light2Dir));\n        specular = pow (max (0.0, dot (reflect (ray, n), light2Dir)), material.x) * material.y;\n        \n        #ifdef SHADOW\n            vec3 shadowOrigin = origin + n * SHADOW_DELTA*0.5;\n            vec2 shadowDist = dist (shadowOrigin, lightDir, SHADOW_LENGTH, SHADOW_DELTA, color, material);\n            if (shadowDist.x < SHADOW_DELTA ) {\n                float shadowAmount = pow (min (1.0, shadowDist.y / SHADOW_LENGTH), SHADOW_POWER);\n                finalColor *= shadowAmount;\n            }\n\t\t#endif\n        \n\n        finalColor += (diffuse+specular)*light2Pow*groundColor;\n        \n        finalColor += ambient;\n    }\n\n    float dist = length(origin)/600.0;\n    //finalColor = vec3(dist,dist,dist);\n    \n    finalColor = mix(finalColor, BACKGROUND_COLOR, min(dist,1.0));\n    \n\t// Set the fragment color\n\tfinalColor = pow (finalColor, vec3 (GAMMA));\n\tfragColor = vec4 (finalColor, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XldcRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2089, 2089, 2118, 2118, 2211], [2213, 2213, 2242, 2242, 2332], [2334, 2334, 2363, 2363, 2455], [2457, 2457, 2507, 2507, 2592], [2594, 2594, 2641, 2641, 2762], [2764, 2764, 2814, 2814, 2899], [2901, 2901, 2955, 2955, 3019], [3021, 3021, 3063, 3063, 3184], [3186, 3186, 3234, 3234, 3407], [3410, 3466, 3530, 3530, 11634], [11636, 11661, 11774, 11774, 12153], [12155, 12182, 12207, 12207, 12517], [12519, 12536, 12593, 12615, 15136]], "test": "timeout"}
{"id": "Xldczj", "name": "pedal - circle", "author": "elenzil", "description": "the Pedal curve of a circle and the mouse position.", "tags": ["math", "curves", "pedal"], "likes": 5, "viewed": 649, "published": "Public API", "date": "1534400353", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// the Pedal of a curve C and a point Q\n// is the locus of all points P such that there is a tangent to C\n// which passes through P and which is perpendicular to PQ.\n\n\n\n// return the tangent points of the circle of radius r which pass through p.\n// if any.\n// thanks to Mike Plotz for suggesting the geometric approach here.\nbool circleTangents(vec2 c, float r, vec2 p, out vec2 t1, out vec2 t2) {\n    p -= c;\n    \n\tfloat P = length(p);\n    if (P < r) {\n        return false;\n    }\n    \n    float a   = r * r                       / P;\n    float q   = r * sqrt((P * P) - (r * r)) / P;\n    vec2  pN  = p / P;\n    vec2  pNP = vec2(-pN.y, pN.x);\n    vec2  va  = pN * a;\n    \n    t1 = va + pNP * q;\n    t2 = va - pNP * q;\n    \n    return true;\n}\n\n#define FWIDTH2(f) (length(vec2(dFdx(f), dFdy(f))))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = length(iMouse.xy) < 0.01 ? vec2(cos(iTime) * 40.0 + iResolution.x / 4.0, sin(iTime) * 20.0 + iResolution.y / 2.0) : iMouse.xy;\n    \n    vec2 uv = ((fragCoord - iResolution.xy * 0.5)/iResolution.y);\n\tvec2 ms = ((mouse - iResolution.xy * 0.5)/iResolution.y);\n\n    vec3 col = vec3(0.0);\n    \n    float radius = sin(iTime * 0.3) * 0.15 + 0.15;;\n    float width  = 0.008;\n    float d = abs(radius - length(uv));\n    float g = smoothstep(1., 0., d/width) * 0.3;\n    col += vec3(0.0, g, g * 2.0);\n    \n    vec2 t1;\n    vec2 t2;\n    \n    bool hasTangents = circleTangents(vec2(0.0), radius, uv, t1, t2);\n    if (hasTangents) {\n        col += vec3(0.2);\n        \n\t    vec2 pm = ms - uv;\n\t    vec2 pmn = normalize(pm);\n   \t    vec2 t1n = normalize(t1 - uv);\n   \t    vec2 t2n = normalize(t2 - uv);\n        \n        float t1d = dot(pmn, t1n);\n        float t2d = dot(pmn, t2n);\n        \n        const float thresh = 0.07;\n        \n        float c1 = smoothstep(thresh, 0.0, abs(t1d) / (FWIDTH2(t1d) * 40.0));\n        float c2 = smoothstep(thresh, 0.0, abs(t2d) / (FWIDTH2(t2d) * 40.0));\n        col += vec3(c1 * 0.6);\n        col += vec3(c2 * 0.6);\n        col += vec3(0., 0., 0.3 * smoothstep(thresh, 0.0, t1d));\n        col += vec3(0.3 * smoothstep(thresh, 0.0, t2d), 0., 0.);\n    }\n    \n    fragColor = vec4(col,1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xldczj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[169, 325, 397, 397, 741], [796, 796, 853, 853, 2181]], "test": "ok"}
{"id": "XldyDl", "name": "Infinite Hearts", "author": "JuliaPoo", "description": "This is a result of procrastination", "tags": ["hearts"], "likes": 4, "viewed": 456, "published": "Public API", "date": "1534664576", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R iResolution.xy\n#define t iTime\n#define f(i) 2.*cos(i.y+acos(cos(2.*i.x))/(3.))*sin(i.x)-2.5*sin(t)\nvoid mainImage(out vec4 C,in vec2 U){vec2 k=U/R-.5;vec2 j=U/R.y*20.-vec2(t);vec4 d=vec4(1.,.5,.5,1.);if(abs(f(j))<1.){d+=1.;}d/=sqrt(.65-.9*length(.55*k));C=d;}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XldyDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[109, 109, 146, 146, 269]], "test": "ok"}
{"id": "Xldyzf", "name": "droppin", "author": "lennyjpg", "description": "asdfas", "tags": ["heyheyhey"], "likes": 0, "viewed": 356, "published": "Public API", "date": "1533500964", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x;\n    float d = length(uv-0.5);\n    float f = sin(d*3.0);\n\tvec2 u=fract(uv*f);\n    float t = iTime*0.51;\n    t+=sin(t*2.0);\n    u-=0.5;\n    vec2 m = uv-vec2(0.5,0.2);\n    float a = atan(m.y,m.x);\n    u = rotate2d( a+t*PI ) * u;\n    u+=0.5;\n    float k = smoothstep(0.5,0.51,u.x);\n    fragColor = vec4(k);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xldyzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 54, 54, 140], [142, 142, 199, 199, 543]], "test": "ok"}
{"id": "XljBzt", "name": "Perlin-Worley noise", "author": "wsmind", "description": "Cloud density noise function", "tags": ["noise", "clouds", "perlin", "worley"], "likes": 3, "viewed": 550, "published": "Public API", "date": "1534942218", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rand2(vec2 uv)\n{\n    uv += 0.5;\n    uv /= 256.0; // texel size\n\treturn vec2(texture(iChannel0, uv).r, texture(iChannel0, uv + 17.0 / 256.0).r);\n}\n\n\n#define WORLEY_ORDER 2\n\nfloat worley(vec2 uv)\n{\n    vec2 centerCell = floor(uv);\n    float distances[WORLEY_ORDER];\n    \n    for (int i = 0; i < WORLEY_ORDER; i++)\n        distances[i] = 1000.0;\n    \n    for (float y = -1.0; y <= 1.0; y += 1.0)\n    {\n        for (float x = -1.0; x <= 1.0; x += 1.0)\n        {\n            vec2 cell = centerCell + vec2(x, y);\n            vec2 point = cell + rand2(cell);\n            \n            float dist = distance(point, uv);\n            distances[WORLEY_ORDER - 1] = min(dist, distances[WORLEY_ORDER - 1]);\n            \n            // re-sort distances\n\t\t    for (int i = WORLEY_ORDER - 1; i > 0; i--)\n            {\n                if (distances[i] < distances[i - 1])\n                {\n                    float tmp = distances[i - 1];\n                    distances[i - 1] = distances[i];\n                    distances[i] = tmp;\n                }\n            }\n        }\n    }\n    \n    return clamp(0.7 - distances[WORLEY_ORDER - 2], 0.0, 1.0);\n}\n\nfloat worleyfbm(vec2 uv)\n{\n    float value = 0.0;\n    float factor = 1.0;\n    for (int i = 0; i < 3; i++)\n    {\n        uv += iTime * 0.04;\n        value += worley(uv * factor) / factor;\n        factor *= 2.0;\n    }\n    return value;\n}\n\nfloat smix(float a, float b, float t)\n{\n    return mix(a, b, smoothstep(0.0, 1.0, t));\n}\n\nfloat computeCorner(vec2 corner, vec2 uv)\n{\n    vec2 gradient = normalize(rand2(corner) * 2.0 - 1.0);\n    return dot(gradient, uv - corner);\n}\n\nfloat perlin(vec2 uv)\n{\n\tfloat c00 = computeCorner(floor(uv) + vec2(0.0, 0.0), uv);\n\tfloat c01 = computeCorner(floor(uv) + vec2(0.0, 1.0), uv);\n\tfloat c11 = computeCorner(floor(uv) + vec2(1.0, 1.0), uv);\n\tfloat c10 = computeCorner(floor(uv) + vec2(1.0, 0.0), uv);\n    \n    vec2 diff = uv - floor(uv);\n    \n    return smix(smix(c00, c10, diff.x), smix(c01, c11, diff.x), diff.y);\n}\n\nfloat perlinfbm(vec2 uv)\n{\n    float value = 0.0;\n    float factor = 1.0;\n    for (int i = 0; i < 3; i++)\n    {\n        value += perlin(uv * factor) / factor;\n        factor *= 2.0;\n    }\n    return value;\n}\n\nfloat perlinworley(vec2 uv)\n{\n    return perlinfbm(uv) + clamp(worleyfbm(uv * 4.0) * 0.6, 0.0, 1.0) - 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy * 5.0 / iResolution.y;\n\tfragColor = vec4(vec3(perlinworley(uv) * 0.5 + 0.5), 1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XljBzt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 150], [177, 177, 200, 200, 1138], [1140, 1140, 1166, 1166, 1375], [1377, 1377, 1416, 1416, 1465], [1467, 1467, 1510, 1510, 1609], [1611, 1611, 1634, 1634, 1991], [1993, 1993, 2019, 2019, 2200], [2202, 2202, 2231, 2231, 2310], [2312, 2312, 2369, 2369, 2478]], "test": "error"}
{"id": "XlKcRm", "name": "Volumetric Kaleidoscope", "author": "efairbanks", "description": "Playing around with KIFS and volumetric lighting.", "tags": ["raymarch", "lighting", "volumetric", "kaleidoscope"], "likes": 15, "viewed": 594, "published": "Public", "date": "1535565752", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 c2p(vec2 p){return vec2(atan(p.y,p.x),length(p));}\nvec2 p2c(vec2 p){return vec2(cos(p.x),sin(p.x))*p.y;}\nvec2 _min(vec2 a, vec2 b) {return a.x<b.x?a:b;}\nvec3 look(vec2 xy, vec3 origin, vec3 target)\n{\n\tvec3 up=normalize(vec3(0.,1.,0.));\n    vec3 fwd=normalize(target-origin);\n    vec3 right=normalize(cross(fwd,up));\n    up=normalize(cross(fwd,right));\n    return normalize(fwd+right*xy.x+up*xy.y);\n}\n#define LUM 1.\n#define MAX_DISTANCE 20.\n#define MAX_STEPS 70\n#define EPSILON .001\nfloat box(vec3 p, vec3 d)\n{\n    p=abs(p)-d;\n    return max(p.x,max(p.y,p.z));\n}\nfloat map(vec3 p)\n{\n    p=p*0.8;\n    p=p+2.;\n    for(int i=0;i<5;i++)\n    {\n        p=p-vec3(1.,2.,3.);\n    \tp=p*1.5;\n        p.xz=c2p(p.xz);\n        p.x+=iTime/2.;\n        p.xz=p2c(p.xz);\n        p.xy=c2p(p.xy);\n        p.x-=iTime/3.34;\n        p.xy=p2c(p.xy);\n        p=abs(p);\n    }\n\tfloat d=box(p,vec3(0.5));\n    return d;\n}\nfloat march(vec3 origin,vec3 ray)\n{\n    float t=0.;\n    for(int i=0;i<MAX_STEPS; i++)\n    {\n        float len=float(i)*MAX_DISTANCE/float(MAX_STEPS);\n        t+=pow(2.1/max(map(origin+ray*len),1.),1.);\n    }\n    return t/float(MAX_STEPS);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(fragCoord/iResolution.xy-.5)*2.;\n\tuv.x=uv.x*iResolution.x/iResolution.y;   \n    vec3 camera=vec3(1.2);\n    camera=vec3(sin(iTime/1.567),sin(iTime)*.2-.2,cos(iTime/1.567))*10.;\n    vec3 ray=look(uv,camera,vec3(0.));\n    // --- //\n    vec3 pos=camera;\n    vec3 dir=ray;\n\tfloat result=march(camera,ray);\n    fragColor = vec4(vec3(.7,.8,1.)*atan(vec3(pow(result*2.8,2.))),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlKcRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 17, 17, 55], [56, 56, 73, 73, 109], [110, 110, 137, 137, 157], [158, 158, 204, 204, 404], [487, 487, 514, 514, 566], [567, 567, 586, 586, 895], [896, 896, 931, 931, 1136], [1137, 1137, 1194, 1194, 1583]], "test": "ok"}
{"id": "XltcDf", "name": "RayMarching&SDFs", "author": "ycheng14799", "description": "Short demo-scene created following Jamie Wong's \"Ray Marching and Signed Distance Functions\" tutorial. \n\nSources: \n\"Ray Marching and Signed Distance Functions\" tutorial by Jamie Wong\n\"Modeling with Distance Functions\" page by Inigo Quilez", "tags": ["raymarching", "sdfs", "jamiewongtutorial"], "likes": 5, "viewed": 169, "published": "Public", "date": "1534471100", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Define maximum marching steps \nconst int maxMarchSteps = 255;\n// Define minimum distance \nconst float minDist = 0.0;\n// Define maximum distance \nconst float maxDist = 100.0;\nconst float epsilon = 0.0001; \n\n// Sphere SDF \nfloat sphereSDF(vec3 samplePoint) {\n    return length(samplePoint) - 1.0;\n}\n\n// Cube SDF \nfloat ubox(vec3 samplePoint) {\n    return length(max(abs(samplePoint) - vec3(1.0, 1.0, 1.0), 0.0));\n}\n\n// Constructuve solid geometry functions \n// For intersections \nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n// For unions \nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n// For differences \nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\n// Rotation transformation \n// About y-axis\nmat4 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    \n    return mat4(\n        vec4(c, 0, s, 0),\n        vec4(0, 1, 0, 0),\n        vec4(-s, 0, c, 0),\n        vec4(0, 0, 0, 1)\n\t);\n}\n// About x-axis  \nmat4 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    \n    return mat4(\n        vec4(1, 0, 0, 0),\n        vec4(0, c, -s, 0),\n        vec4(0, s, c, 0),\n        vec4(0, 0, 0, 1)\n\t);\n}\n// About z-axis \nmat4 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    \n    return mat4(\n        vec4(c, -s, 0, 0),\n        vec4(s, c, 0, 0),\n        vec4(0, s, 1, 0),\n        vec4(0, 0, 0, 1)\n\t);\n}\n\nfloat sceneSDF(vec3 samplePoint) {\n    // Rotate entire scene \n    samplePoint = (rotateY(iTime / 2.0) * vec4(samplePoint, 1.0)).xyz;\n    // Box distortions \n    float boxX = 0.2;\n    float boxY = 1.5;\n    float boxZ = 1.5; \n    vec3 wallPoint = (rotateX(iTime) * vec4(samplePoint, 1.0)).xyz;\n    float sphereShapeChange = 0.5 * sin(2.0 * iTime) + 0.5;\n    float sphere = sphereSDF(samplePoint / sphereShapeChange) * sphereShapeChange;\n    float wall = ubox(wallPoint / vec3(boxX, boxY, boxZ)) * min(boxX, min(boxY, boxZ));\n\tfloat hole = differenceSDF(wall, sphere);\n    float ball = sphereSDF((samplePoint + vec3(2.0 * sin(iTime - 3.14 / 4.0), 0.0, 0.0))/ 0.5) * 0.5;\n    return unionSDF(hole, ball);\n\t//return hole;\n}\n\n// Ray marching function to find\n// shortest distance from eyepoint to scene surface \n// follow marching direction \n// eye: Origin of ray, eye point \n// marchDirection: normalized direction to march in \n// start: Starting distance away from eye\n// End: Max distance from eye to march \nfloat rayMarch(vec3 eye, vec3 marchingDirection, \n               float start, float end) {\n\t// Define starting depth \n    float depth = start;\n    // March until maxMarchSteps is reached\n    for (int i = 0; i < maxMarchSteps; i++) {\n        // Obtain distance from closest surface \n        float dist = sceneSDF(eye + depth *\n                              marchingDirection);\n        // Determine if marched inside surface\n        if (dist < epsilon) {\n            // Inside scene surface\n            return depth; \n        }\n        // Update depth \n        depth += dist;\n        // Determine if marched too far \n        if (depth >= end) {\n            // Return farthest allowable\n            return end;\n        }\n    }\n    // Return distance if marched more than max steps\n    return end;\n}\n\n// Return normalized direction to march in from eye\n// fov: vertical field of view in degrees \n// size: resolution of output image\n// fragCoord: x, y coordinates of pixel in output \nvec3 rayDirection(float fov, vec2 size, vec2 fragCoords) {\n    // Center coordinate system \n    // Define x and y coordinates \n    vec2 xy = fragCoords - size / 2.0;\n    // Find z\n    float z = size.y / tan(radians(fov) / 2.0);\n    // Return normalized direction to march \n    return normalize(vec3(xy, -z));\n}\n\n// Esimate normal on surface \nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + epsilon, p.y, p.z)) - sceneSDF(vec3(p.x - epsilon, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + epsilon, p.z)) - sceneSDF(vec3(p.x, p.y - epsilon, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z + epsilon)) - sceneSDF(vec3(p.x, p.y, p.z - epsilon))\n    ));\n}\n\n// Calculate lighting contribution of single point light source\n// Return: RGB color of light's contribution \n// k_a: Ambient color \n// k_d: Diffuse color \n// k_s: Specular color \n// alpha: Shininess coefficient \n// p: Position of point being lit \n// eye: Position of camera \n// lightPos: Position of light \n// lightIntensity: color / intensity of light \nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha,\n                          vec3 p, vec3 eye, vec3 lightPos,\n                          vec3 lightIntensity) {\n    // Get normal vector at position p \n    vec3 N = estimateNormal(p);\n    // Get direction of light to position p\n    vec3 L = normalize(lightPos - p);\n    // Get direction of camera to position p\n    vec3 V = normalize(eye - p);\n    // Get direction of reflection \n    vec3 R = normalize(reflect(-L, N));\n    \n    // Obtain dot product between light and normal \n    float dotLN = dot(L, N);\n    // Obtain dot product between reflection and view ray \n    float dotRV = dot(R, V);\n    \n    // Light not visible from this point on surface\n    if (dotLN < 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    \n    // Determine if light reflection is viewable \n    // from viewer\n    if (dotRV < 0.0) {\n        // If light reflection is opposite direction of viewer\n        // Apply only diffuse lighting \n        return lightIntensity * (k_d * dotLN);\n    }\n    \n    // Return phong lighting contribution \n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n// Phong illumination \n// Return RGB color of point after lighting contribution \n// k_a: Ambient color \n// k_d: Diffuse color \n// k_s: Specular color\n// alpha: Shininess coefficient \n// p: Position of point being lit \n// eye: Position of camera \nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n\t// Define ambient light intensity \n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    // Calculate color from ambient light \n    vec3 color = ambientLight * k_a;\n    \n    // Define light 1 \n    vec3 light1Pos = vec3(4.0 * sin(iTime), \n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    color += phongContribForLight(k_d, k_s, alpha, p, \n                                  eye, light1Pos,\n                                  light1Intensity);\n    \n    // Define light 2 \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime), \n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    float light2IntensityComp = 0.5*sin(iTime)+0.5; \n    vec3 light2Intensity = vec3(light2IntensityComp,\n                                light2IntensityComp,\n                               \tlight2IntensityComp);\n    color += phongContribForLight(k_d, k_s, alpha, p,\n                                  eye, light2Pos,\n                                  light2Intensity);\n    return color;\n}\n\n// Return transformation matrix that will transform a \n// ray from view space to world coordinates \n// given a eye point, a camera target, and a up vector\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Define direction from camera to target \n    vec3 f = normalize(center - eye);\n    // Define right vector \n    vec3 s = normalize(cross(f, up));\n    // Define new up for camera \n    vec3 u = cross(s, f);\n    // Return transformation matrix \n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n    \n\n// Main \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t// Obtain view direction\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    // Define camera position \n    vec3 eye = vec3(8.0, 5.0, 7.0);\n    // Obtain transformation matrix \n    // Point camera at target \n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    // Apply transformation \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    // Obtain SDF with eye \n    float dist = rayMarch(eye, worldDir, minDist, maxDist);\n    \n    // Set background as black\n    // if ray did not intersect a surface \n    if (dist > maxDist - epsilon) {\n        \tfragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        \treturn;\n    }\n    \n    // Apply lighting \n    // Find closest point on surface to eyepoint\n    // along view ray \n    vec3 p = eye + dist * worldDir; \n    // Define ambient light color \n    // Defined based on normal estimates \n    vec3 K_a = (estimateNormal(p) + vec3(1.0)) / 2.0;\n    // Define diffuse light color \n    vec3 K_d = K_a;\n    // Defien specular light color \n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    // Set object shininess \n    float shininess = 10.0;\n    // Obtain color \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    // Set fragment color \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XltcDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[209, 224, 259, 259, 299], [301, 314, 344, 344, 415], [417, 481, 527, 527, 559], [560, 575, 617, 617, 649], [650, 670, 717, 717, 750], [752, 796, 823, 823, 1007], [1008, 1026, 1053, 1053, 1237], [1238, 1255, 1282, 1282, 1466], [1468, 1468, 1502, 1530, 2187], [2189, 2474, 2564, 2591, 3269], [3271, 3453, 3511, 3579, 3763], [3765, 3795, 3824, 3824, 4133], [4135, 4490, 4656, 4696, 5632], [5634, 5880, 5965, 6001, 7044], [7046, 7201, 7250, 7297, 7621], [7628, 7637, 7694, 7720, 8971]], "test": "ok"}
{"id": "Xltczl", "name": "RGB Julia", "author": "maeln", "description": "A julia fractal were each channel are rendered with an offset.", "tags": ["fractal", "julia", "rgb"], "likes": 0, "viewed": 385, "published": "Public API", "date": "1533672947", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAXITER 64\n\n// * op for complex number.\nvec2 cmul(vec2 i1, vec2 i2) \n{\n    return vec2(i1.x*i2.x - i1.y*i2.y, i1.y*i2.x + i1.x*i2.y);\n}\n\nint julia(vec2 z, vec2 c)\n{\n    int i = 0;\n    vec2 zi = z;\n    \n    for(int n=0; n < MAXITER; ++n)\n    {\n        if(dot(zi,zi) > 4.0)\n            break;\n        i++;\n        zi = cmul(zi,zi) + c;\n        \n    }\n    \n    return i;\n}\n\nvec4 gen_color(int iter)\n{\n    vec3 c1 = vec3(1.0,1.0,1.0);\n    vec3 c2 = vec3(0.0,0.6,0.3);\n    vec3 m = vec3(float(iter)/float(MAXITER));\n    vec3 base = mix(c1,c2,m);\n    return vec4(base,1.0);\n}\n\nfloat iter2f(int iter) {\n    return float(iter)/float(MAXITER);\n}\n\n// Remap the OpenGL space to the space where the julia set is defined ( [(-2;-2),(2;2)] ).\nvec2 space(vec2 res, vec2 coord)\n{\n    // Center the coordinate so that (0,0) is in the center of the screen.\n    vec2 base = (2.*coord.xy - res.xy) / res.x;\n    // base*2 so that the range is [-2;2] (the julia set is defined on this range)\n    return base*2.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 z = space(iResolution.xy, fragCoord.xy);\n    // Display the julia fractal for C = (-0.8, [0.0;0.3]).\n    int r = julia(z, vec2(cos(iTime/5.0), mix(-0.1, 0.5, sin(iTime))));\n    int g = julia(z, vec2(cos(iTime/5.0), mix(0.1, 0.7, sin(iTime))));\n    int b = julia(z, vec2(cos(iTime/5.0), mix(0.3, 1.0, sin(iTime))));\n    \n\tfragColor = vec4(1.0-iter2f(r), 1.0-iter2f(g), 1.0-iter2f(b), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xltczl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 48, 78, 78, 143], [145, 145, 172, 172, 377], [379, 379, 405, 405, 577], [579, 579, 603, 603, 644], [646, 737, 771, 846, 999], [1001, 1001, 1058, 1058, 1458]], "test": "ok"}
{"id": "XltyDB", "name": "RMK2018003", "author": "Morendil", "description": "ray", "tags": ["ray"], "likes": 1, "viewed": 65, "published": "Public", "date": "1533914175", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat scene(vec3 p) {\n    float twists = sin(iTime/11.)*2.;\n    float c = cos(twists*p.y);\n    float s = sin(twists*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    \n    float d1 = sdSphere(p, 1.1);\n    float d2 = sdBox(q, vec3(.6+cos(iTime)*.2));\n    return smin(d1,d2, .2);\n}\n\nvec3 normal(vec3 where) {\n    vec3 xe = vec3(0.001,0,0);\n    vec3 ye = vec3(0,0.001,0);\n    vec3 ze = vec3(0,0,0.001);\n    return normalize(\n        vec3(scene(where+xe)-scene(where-xe),\n             scene(where+ye)-scene(where-ye),\n             scene(where+ze)-scene(where-ze)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy) - .5;\n    uv.x *= iResolution.x/iResolution.y;\n\n    float focal = 10.;\n    vec3 camera = vec3(20.+sin(iTime)*10.,20.,20);\n    vec3 lookat = vec3(0);\n    vec3 camdir = normalize(lookat-camera);\n    vec3 xvec = cross(vec3(0,1,0),-camdir);\n    vec3 yvec = cross(-camdir,xvec);\n    vec3 projection = camera+focal*camdir+xvec*uv.x+yvec*uv.y;\n\n    vec3 light1 = vec3(5.+cos(iTime),5,-5);\n    vec3 light2 = vec3(-cos(iTime*4.)*.1,-5.,0);\n    \n    vec3 raydir = normalize(projection-camera);\n\n    vec3 col = vec3(0);\n    \n    int steps = 32;\n    float march = 0.;\n    for (int i=0; i<steps; i++) {\n        vec3 raytip = camera + march * raydir;\n        float dist = scene(raytip);\n        if (dist < 0.001) {\n            vec3 normal = normal(raytip);\n            vec3 incident1 = normalize(raytip-light1);\n            vec3 incident2 = normalize(raytip-light2);\n            float diffuse = dot(incident1,normal)*dot(incident2,normal);\n            vec3 reflected = reflect(-incident2,normal);\n            float spec = dot(reflected,-raydir);\n            col = vec3(0,diffuse+.2,spec);\n            break;\n        }\n        march += dist;\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XltyDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 118], [120, 120, 155, 155, 179], [181, 181, 222, 222, 315], [317, 317, 338, 338, 617], [619, 619, 644, 644, 901], [903, 903, 960, 1010, 2218]], "test": "ok"}
{"id": "XlVyRz", "name": "spinnerjoy", "author": "elenzil", "description": "port of ancient iOS app i wrote", "tags": ["aliasing", "moire", "artifacts", "spinners"], "likes": 11, "viewed": 551, "published": "Public API", "date": "1534878990", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// parameters\n#define BOX_SIZE      17.0\n#define LINE_WIDTH     4.0\n#define RENDER_CROSS   1\n#define MOUSE_AMOUNT   0.0\n#define LINE_LENGTH    1.5\n#define JUST_THE_TIPS  1\n\n// careful with this value. iterations = (2n + 1)^2\n// needs to be large enough to fit LINE_LENGTH.\n#define offsetSize     1.0\n\n// not parameters\n#define LARGE_VALUE 100000000.0\n#define STRAIGHT       1\n\nfloat oxeVec2f_distanceRight_PointLine(vec2 linePt, vec2 unitDir, vec2 pt)\n{\n   float vx = pt.x - linePt.x;\n   float vy = pt.y - linePt.y;\n   return unitDir.y * vx - unitDir.x * vy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float boxDim = BOX_SIZE;\n    vec2 lineCenterC = vec2(boxDim, boxDim) * 0.5;\n    vec2 fc2 = fragCoord - (iResolution.xy * 0.5);\n    vec2 pt  = mod(fc2, boxDim);\n    \n    #if STRAIGHT\n    vec2 boxPosC = (floor(fc2 / boxDim) + vec2(0.5)) * boxDim + iResolution.xy * 0.5;\n    #else\n    vec2 boxPosC = fc2;\n    #endif\n    \n    vec3 col = vec3(0.);\n    \n    float r = LINE_LENGTH;\n        \n    for (float dx = -offsetSize; dx <= offsetSize; dx += 1.0) {\n\t    for (float dy = -offsetSize; dy <= offsetSize; dy += 1.0) {\n            vec2 offset = vec2(dx, dy) * boxDim;\n            vec2 lineCenter = lineCenterC + offset;\n            vec2 boxPos = boxPosC + offset;\n\t\t    float boxDist1 = length(boxPos - iResolution.xy * 0.5) *  1.0;\n\t\t    float boxDist2 = length(boxPos - iMouse.xy)            * -MOUSE_AMOUNT;\n\t\t\tfloat boxDist = boxDist1 + boxDist2;\n    \n\t\t    float t = iTime * 1.4 * (boxDist * 0.003 + 0.2);\n            vec2 lineDir = vec2(cos(t), sin(t));\n    \n\t\t    float distN = length(pt - lineCenter) / (boxDim * 0.5);\n\n            // make it a sort of bone shape instead of a flat line\n            float tmp = smoothstep(0.0, 2.0, distN);\n           // tmp *= tmp;\n            float lw = LINE_WIDTH * (tmp * 0.3 + 0.7);\n    \n            float d = 0.0;\n            d = max(d, clamp(lw * 0.5 - abs(oxeVec2f_distanceRight_PointLine(lineCenter, lineDir, pt)), 0.0, 1.0));\n    \n            #if RENDER_CROSS\n            lineDir = vec2(-lineDir.y, lineDir.x);\n            d = max(d, clamp(lw * 0.5 - abs(oxeVec2f_distanceRight_PointLine(lineCenter, lineDir, pt)), 0.0, 1.0));\n            #endif // RENDER_CROSS\n\n            // restrict to a circle\n            d *= smoothstep(r, r - 0.1, distN);\n            \n            #if JUST_THE_TIPS\n            d *= smoothstep(r, r - 0.1, distN);\n            #endif\n    \n            // grey in the middle\n            // d *= smoothstep(0.0, 0.8, distN) * 0.5 + 0.5;\n    \n            col.xyz += d;\n   \t\t    // col.z   = boxDist / iResolution.y;\n        }\n    }\n\t\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlVyRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[377, 377, 453, 453, 560], [562, 562, 619, 619, 2685]], "test": "ok"}
{"id": "XlycRh", "name": "Kaleidoscope 01", "author": "badjano", "description": "based on this shader: https://www.shadertoy.com/view/XlXczr", "tags": ["fractal", "kaleidoscope"], "likes": 2, "viewed": 129, "published": "Public", "date": "1534969443", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define rot(a) mat2(cos(a + PI*0.25*vec4(0,6,2,0)))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy - iResolution.xy * 0.5;\n    uv /= iResolution.y;\n    uv *= cos(iTime*0.5) + 1.5;\n    \n    fragColor.rgb = vec3(0);\n    \n    float scale = PI/3.0;\n    float m = 0.5;\n    for (int i = 0 ; i < 16 ; i++) {\n        float scaleFactor = float(i)+(cos(iTime*0.01) + 2.0);\n        uv *= rot(iTime * scaleFactor * 0.01);\n        float theta = atan(uv.x, uv.y)+PI;\n        theta = (floor(theta/scale)+0.5)*scale;\n        vec2 dir = vec2(sin(theta), cos(theta));\n        vec2 codir = dir.yx * vec2(-1, 1);\n        uv = vec2(dot(dir, uv), dot(codir, uv));\n        uv.xy += vec2(sin(iTime),cos(iTime*1.1)) * scaleFactor * 0.05;\n        uv = abs(fract(uv+0.5)*2.0-1.0)*0.7;\n        vec3 p = vec3(1,3,7);\n        fragColor.rgb += exp(-min(uv.x, uv.y)*16.) * (cos(p*float(i)+iTime*0.5)*.5+.5) * m;\n        m *= 0.95;\n    }\n    \n    //fragColor.rgb *= 0.25;\n\tfragColor.a = 1.0;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlycRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 78, 135, 135, 1021]], "test": "error"}
{"id": "XlyyRR", "name": "Tux and Pals", "author": "dr2", "description": "Linux development (?)", "tags": ["raymarch", "hexagon", "penguin"], "likes": 7, "viewed": 416, "published": "Public API", "date": "1534764520", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Tux and Pals\" by dr2 - 2018\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrEllipsDf (vec3 p, vec3 r);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 sunDir, qHit;\nvec2 gId, obOff;\nfloat dstFar, tCur, fAng, obRot, szFac, hgSize, grLim;\nint idObj;\nconst float pi = 3.14159, sqrt3 = 1.7320508;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, dh;\n  dMin = dstFar / szFac;\n  p.xz -= HexToPix (gId * hgSize) + obOff;\n  p.xz = Rot2D (p.xz, obRot);\n  p /= szFac;\n  p.y -= 1.55;\n  q = p;\n  d = PrEllipsDf (q.xzy, vec3 (1.3, 1.2, 1.4));\n  q.y -= 1.5;\n  dh = PrEllipsDf (q.xzy, vec3 (0.8, 0.6, 1.3));\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.3, 2., -0.4);\n  d = SmoothMin (d, max (dh, - PrCylDf (q, 0.15, 0.3)), 0.2);\n  DMINQ (1);\n  q = p;\n  q.yz -= vec2 (1.6, -0.6);\n  d = max (PrEllipsDf (q, vec3 (0.4, 0.2, 0.6)), 0.01 - abs (q.y));\n  DMINQ (2);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.3, 2., -0.4);\n  d = PrSphDf (q, 0.15);\n  DMINQ (3);\n  q = p;\n  q.x = abs (q.x);\n  q.xy -= vec2 (0.4, -0.8);\n  d = PrCylDf (q.xzy, 0.12, 0.7);\n  DMINQ (4);\n  q -= vec3 (0.1, -0.67, -0.4);\n  q.xz = Rot2D (q.xz, -0.07 * pi);\n  d = PrEllipsDf (q.xzy, vec3 (0.15, 0.5, 0.05));\n  q.z -= 0.5;\n  q.xz = Rot2D (q.xz, 0.15 * pi);\n  q.z -= -0.5;\n  d = SmoothMin (d, PrEllipsDf (q.xzy, vec3 (0.15, 0.5, 0.05)), 0.05);\n  q.z -= 0.5;\n  q.xz = Rot2D (q.xz, -0.3 * pi);\n  q.z -= -0.5;\n  d = SmoothMin (d, PrEllipsDf (q.xzy, vec3 (0.15, 0.5, 0.05)), 0.05);\n  DMINQ (5);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (1.1, 0.3, -0.2);\n  q.yz = Rot2D (q.yz, -0.25 * pi);\n  q.xy = Rot2D (q.xy, fAng) - vec2 (0.1, -0.4);\n  d = PrEllipsDf (q.xzy, vec3 (0.05, 0.25, 0.9));\n  DMINQ (6);\n  return szFac * dMin;\n}\n\nvoid SetPngConf ()\n{\n  vec2 w;\n  float t;\n  t = Hashfv2 (17. * gId + 99.);\n  szFac = 0.8 * (0.5 * sqrt3 - 0.3 * t);\n  obRot = 2. * pi * Hashfv2 (37. * gId + 99.);\n  w = Hashv2v2 (73. * gId + 77.);\n  obOff = hgSize * max (0., 0.5 * sqrt3 - szFac) * w.x * sin (2. * pi * w.y + vec2 (0.5 * pi, 0.));\n  fAng = -0.2 * pi + 0.1 * pi * SmoothBump (0.25, 0.75, 0.1, mod (0.2 * tCur + 1.3 * t, 1.)) *\n     sin (16. * pi * tCur);\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP;\n  float dHit, d, s;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSize / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),\n     dot (ro.xz, edN[2])) / hgSize;\n  pM = HexToPix (PixToHex (ro.xz / hgSize));\n  gIdP = vec2 (-99.);\n  dHit = 0.;\n  for (int j = 0; j < 220; j ++) {\n    hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n    s = min (hv.x, min (hv.y, hv.z));\n    p = ro + dHit * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (length (vec3 (gId.xy, gId.x + gId.y)) <= grLim) {\n      if (gId.x != gIdP.x || gId.y != gIdP.y) {\n        gIdP = gId;\n        SetPngConf ();\n      }\n      d = ObjDf (p);\n    } else d = dstFar;\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + 0.002;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n    }\n    if (d < 0.0005 || dHit > dstFar || p.y < 0. || rd.y > 0. && p.y > 5.) break;\n  }\n  if (d >= 0.0005) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e = vec2 (0.0001, -0.0001);\n  v = vec4 (ObjDf (p + e.xxx), ObjDf (p + e.xyy), ObjDf (p + e.yxy), ObjDf (p + e.yyx));\n  return normalize (vec3 (v.x - v.y - v.z - v.w) + 2. * v.yzw);\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 gIdP;\n  float sh, d, h;\n  sh = 1.;\n  gIdP = vec2 (-99.);\n  d = 0.01;\n  for (int j = 0; j < 30; j ++) {\n    p = ro + d * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (length (vec3 (gId.xy, gId.x + gId.y)) <= grLim) {\n      if (gId.x != gIdP.x || gId.y != gIdP.y) {\n        gIdP = gId;\n        SetPngConf ();\n      }\n      h = ObjDf (p);\n      sh = min (sh, smoothstep (0., 0.05 * d, h));\n      d += clamp (h, 0.05, 0.3);\n    } else d += 0.2;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  ro.xz += tCur;\n  return mix (mix (vec3 (0.2, 0.3, 0.7), vec3 (0.75), pow (1. - max (rd.y, 0.), 8.)) +\n     vec3 (1., 1., 0.9) * (0.3 * pow (max (dot (rd, sunDir), 0.), 32.)),\n     vec3 (0.9), clamp (1.6 * Fbm2 (0.1 * (ro + rd * (50. - ro.y) / (rd.y + 0.0001)).xz) * rd.y +\n     0.1, 0., 1.));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstObj, sh;\n  bool isSky;\n  isSky = false;\n  sh = 0.;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    gId = PixToHex (ro.xz / hgSize);\n    vn = ObjNf (ro);\n    if (idObj == 1 || idObj == 6) vn = VaryNf (64. * ro, vn, 0.3);\n    if (idObj == 1) col4 = (qHit.z < -0.2 || qHit.z < 0. && length (qHit.xy) < 0.2) ?\n       vec4 (0.95, 0.95, 0.95, 0.05) : vec4 (0.1, 0.1, 0.15, 0.1);\n    else if (idObj == 2) col4 = vec4 (1., 0.8, 0.2, 0.2);\n    else if (idObj == 3) col4 = vec4 (0.05, 0.15, 0.05, 0.2);\n    else if (idObj == 4) col4 = vec4 (0.05, 0.1, 0.05, 0.1);\n    else if (idObj == 5) col4 = vec4 (0.9, 0.9, 0., 0.3);\n    else if (idObj == 6) col4 = vec4 (0.15, 0.15, 0.2, 0.1);\n  } else if (rd.y < 0.) {\n    ro += - (ro.y / rd.y) * rd;\n    vn = VaryNf (2. * ro, vec3 (0., 1., 0.), 0.5);\n    col4 = vec4 (0.95, 0.95, 0.95, 0.1);\n    sh = (length (ro.xz) < 1.4 * grLim * hgSize) ? 0. : 1.;\n  } else isSky = true;\n  if (! isSky) {\n    if (sh == 0.) sh = ObjSShadow (ro, sunDir);\n    col = col4.rgb * (0.3 + 0.2 * max (dot (normalize (vec3 (vn.x, 0., vn.z)), - sunDir), 0.) +\n       0.6 * sh * max (dot (vn, sunDir), 0.)) +\n       col4.a * smoothstep (0.8, 1., sh) * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n  } else col = SkyCol (ro, rd);\n  return clamp (col, 0., 1.);\n}\n\nvec3 TrackPos (float t)\n{\n  vec3 r;\n  float tt = mod (t, 1.);\n  r.xz = 0.45 * grLim * hgSize * ((mod (t, 2.) < 1.) ? vec2 (- cos (2. * pi * tt) + 1.,\n     sin (2. * pi * tt)) : vec2 (cos (2. * pi * tt) - 1., sin (2. * pi * tt)));\n  return vec3 (r.x, 5., r.z);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, vd, col;\n  vec2 canvas, uv, ori, ca, sa;\n  float el, az, sunEl, sunAz, spd;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.02 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.5 * pi * mPtr.y;\n  }\n  hgSize = 2.3;\n  grLim = 20.;\n  spd = 0.03;\n  ro = TrackPos (spd * tCur);\n  vd = normalize (TrackPos (spd * tCur + 0.1) - ro);\n  az += 0.5 * pi + atan (- vd.z, vd.x);\n  el += asin (vd.y) - 0.1 * pi;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  vuMat = mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n          mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n  rd = vuMat * normalize (vec3 (uv, 1.8));\n  dstFar = 150.;\n  sunAz = pi - 0.02 * 2. * pi * tCur;\n  sunEl = pi * (0.3 + 0.05 * sin (0.35 * sunAz));\n  sunDir = vec3 (cos (sunAz) * cos (sunEl), sin (sunEl), sin (sunAz) * cos (sunEl));\n  col = ShowScene (ro, rd);\n  fragColor = vec4 (pow (col, vec3 (0.8)), 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlyyRR.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[738, 738, 760, 760, 2113], [2115, 2115, 2135, 2135, 2536], [2538, 2538, 2571, 2571, 3793], [3795, 3795, 3816, 3816, 4016], [4018, 4018, 4055, 4055, 4572], [4574, 4574, 4606, 4606, 4903], [4905, 4905, 4940, 4940, 6290], [6292, 6292, 6317, 6317, 6553], [6555, 6555, 6611, 6611, 7705], [7707, 7707, 7740, 7740, 7767], [7769, 7769, 7811, 7811, 7862], [7864, 7864, 7899, 7899, 7961], [7963, 7963, 8008, 8008, 8111], [8113, 8113, 8170, 8170, 8253], [8255, 8255, 8279, 8279, 8509], [8511, 8511, 8535, 8535, 8595], [8597, 8597, 8627, 8627, 8740], [8774, 8774, 8798, 8798, 8858], [8860, 8860, 8884, 8884, 9014], [9016, 9016, 9041, 9041, 9227], [9229, 9229, 9250, 9250, 9405], [9407, 9407, 9436, 9436, 9648], [9650, 9650, 9689, 9689, 9869]], "test": "error"}
{"id": "Xs3fzj", "name": "The Drive Home tuutorial", "author": "littlemilk", "description": "https://www.youtube.com/watch?v=eKtsY7hYTPg", "tags": ["screenfold"], "likes": 1, "viewed": 90, "published": "Public", "date": "1533174638", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(a, b, t) smoothstep(a, b, t)\n\nstruct ray {\n\t\n    vec3 o, d;\n};\n    \n    \nray GetRay(vec2 uv, vec3 camPos, vec3 lookAt, float zoom) {\n    \n    ray a;\n    a.o = camPos;\n    \n    vec3 f = normalize(lookAt-camPos);\n    vec3 r = cross(vec3(0.,  1., 0.), f);\n    vec3 u = cross(f, r);\n    vec3 c = a.o + f*zoom;\n    vec3 i = c + uv.x*r + uv.y*u;\n    \n    a.d = normalize(i-a.o);\n \t\n    return a;\n}\n\n\nvec3 ClosestPoint(ray r, vec3 p) {\n\n    return r.o + max(0., dot(p-r.o, r.d))*r.d;\n}\n\n\nfloat DistRay(ray r, vec3 p) {\n\n    return length(p - ClosestPoint(r, p));\n}\n\n\nfloat Bokeh(ray r, vec3 p, float size, float blur){\n\n   float d = DistRay(r, p);\n    \n   size *= length(p);\n   float c = S(size, size*(1.-blur), d); \n   c *= mix(.6, 1., S(size*.8, size, d));\n   return c;\n}\n\n\nvec3 StreetLights(ray r, float t) {\n\t\n    float side = step(r.d.x, 0.);\n    r.d.x = abs(r.d.x);\n    float s = 1./10.;\n    float m = 0.;\n    for(float i=0.; i < 1.; i+=s) {\n        float ti = fract(t+i+side*s*.5);\n    \tvec3 p = vec3(2., 2., 100.-ti*100.);\n    \tm += Bokeh(r, p, .05, .1)*ti*ti*ti;\n    }\n    \n    return vec3(1., .7, .3)*m;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n   \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 camPos = vec3(0., .2, 0.);\n    vec3 lookAt = vec3(0., .2, 1.);\n    \n\n    ray r = GetRay(uv, camPos, lookAt, 2.);\n    \n    float t = iTime*.1;\n    \n    vec3 col = StreetLights(r, t);\n    \n    \n    // Output to screen\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xs3fzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[83, 83, 142, 142, 401], [404, 404, 438, 438, 488], [491, 491, 521, 521, 567], [570, 570, 621, 621, 776], [779, 779, 814, 814, 1118], [1121, 1121, 1178, 1232, 1587]], "test": "ok"}
{"id": "Xt3yDS", "name": "Isoline triangle", "author": "tdhooper", "description": "Inspired by the tattoo work of [url=https://www.instagram.com/p/Bl6G0v_gh4d]Cassady Bell[/url].\n\nI remember reading that it was possible to use fwidth to create isolines, turns out it's true!", "tags": ["noise", "triangle", "lines", "perlin", "simplex", "contour", "fwidth", "isoline"], "likes": 111, "viewed": 2788, "published": "Public API", "date": "1533764352", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// White on black, best fullscreen\n//#define ALTERNATE_VERSION\n\n\n// --------------------------------------------------------\n// Simplex(ish) Noise\n// Shane https://www.shadertoy.com/view/ldscWH\n// --------------------------------------------------------\n\nvec3 hash33(vec3 p) { \n    float n = sin(dot(p, vec3(7, 157, 113)));    \n    return fract(vec3(2097152, 262144, 32768)*n)*2. - 1.;\n}\n\nfloat tetraNoise(in vec3 p)\n{\n    vec3 i = floor(p + dot(p, vec3(0.333333)) );  p -= i - dot(i, vec3(0.166666)) ;\n    vec3 i1 = step(p.yzx, p), i2 = max(i1, 1.0-i1.zxy); i1 = min(i1, 1.0-i1.zxy);    \n    vec3 p1 = p - i1 + 0.166666, p2 = p - i2 + 0.333333, p3 = p - 0.5;\n    vec4 v = max(0.5 - vec4(dot(p,p), dot(p1,p1), dot(p2,p2), dot(p3,p3)), 0.0);\n    vec4 d = vec4(dot(p, hash33(i)), dot(p1, hash33(i + i1)), dot(p2, hash33(i + i2)), dot(p3, hash33(i + 1.)));\n    return clamp(dot(d, v*v*v*8.)*1.732 + .5, 0., 1.); // Not sure if clamping is necessary. Might be overkill.\n}\n\n// --------------------------------------------------------\n// Triangle distance\n// The corners aren't a correct distance, normally they'd\n// be rounded, but here they're pointy to keep them sharp\n// when drawn with the isolines\n// --------------------------------------------------------\n\nfloat sTri(vec2 p, float radius) {\n    radius /= 2.;\n    vec2 a = normalize(vec2(1.6,1.));\n    return max(\n        dot(p, vec2(0,-1)) - radius,\n        max(\n        \tdot(p, a) - radius,\n        \tdot(p, a * vec2(-1,1)) - radius\n        )\n    );\n}\n\n// --------------------------------------------------------\n// Repeat space and blend the edges\n//\n// Imagine we have the following domain:\n// 0 1 2 3 4 5 6 7 8 9 ...\n//\n// If you repeat with a size of 3, you get hard edges\n// between 2 and 0:\n// 0 1 2 0 1 2 0 1 2 ...\n//\n// You could flip each repetition, but you'd see a visible\n// mirror effect:\n// 0 1 2 2 1 0 0 1 2 ...\n// \n// So instead, take two samples out of phase:\n// 0 1 2 0 1 2 0 1 2 ...\n// 2 0 1 2 0 1 2 0 1 ...\n//\n// And then blend the samples at these points in such a way\n// that the visible joins of one sample are masked by the \n// continuous part of the other sample.\n// --------------------------------------------------------\n\n#define PI 3.14159265359\n\nvec2 smoothRepeatStart(float x, float size) {\n  return vec2(\n      mod(x - size / 2., size),\n      mod(x, size)\n  );\n}\n\nfloat smoothRepeatEnd(float a, float b, float x, float size) {\n  return mix(a, b,\n      smoothstep(\n          0., 1.,\n          sin((x / size) * PI * 2. - PI * .5) * .5 + .5\n      )\n  );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Square uv centered and sclead to the screen height\n    vec2 uv = (-iResolution.xy + 2. * fragCoord.xy) / iResolution.y;\n    \n    // Zoom in a bit\n    uv /= 2.;\n\n    #ifdef ALTERNATE_VERSION\n   \t\tuv *= 1.8;\n   \t#endif\n    \n    float repeatSize = 4.;\n    float x = uv.x - mod(iTime, repeatSize / 2.);\n    float y = uv.y;\n\n    vec2 ab; // two sample points on one axis\n\n    float noise;\n    float noiseA, noiseB;\n    \n    // Blend noise at different frequencies, moving in\n    // different directions\n    \n    ab = smoothRepeatStart(x, repeatSize);\n    noiseA = tetraNoise(16.+vec3(vec2(ab.x, uv.y) * 1.2, 0)) * .5;\n    noiseB = tetraNoise(16.+vec3(vec2(ab.y, uv.y) * 1.2, 0)) * .5;\n    noise = smoothRepeatEnd(noiseA, noiseB, x, repeatSize);\n\n    ab = smoothRepeatStart(y, repeatSize / 2.);\n    noiseA = tetraNoise(vec3(vec2(uv.x, ab.x) * .5, 0)) * 2.;\n    noiseB = tetraNoise(vec3(vec2(uv.x, ab.y) * .5, 0)) * 2.;\n    noise *= smoothRepeatEnd(noiseA, noiseB, y, repeatSize / 2.);\n\n    ab = smoothRepeatStart(x, repeatSize);\n    noiseA = tetraNoise(9.+vec3(vec2(ab.x, uv.y) * .05, 0)) * 5.;\n    noiseB = tetraNoise(9.+vec3(vec2(ab.y, uv.y) * .05, 0)) * 5.;\n    noise *= smoothRepeatEnd(noiseA, noiseB, x, repeatSize);\n\n    noise *= .75;\n\n    // Blend with a linear gradient, this gives the isolines a\n    // common orientation (try changing .6 to 1.)\n    noise = mix(noise, dot(uv, vec2(-.66,1.)*.4), .6);\n    \n    // Create anti-aliased even weight isolines from the noise...\n\n    // Break the continuous noise into steps\n    float spacing = 1./50.;\n    float lines = mod(noise, spacing) / spacing;\n\n    // Convert each step into a bump, or, the sawtooth wave\n    // into a triangle wave:\n    //\n    //     /|    /|\n    //   /  |  /  |\n    // /    |/    |\n    //       \n    // to:   \n    //       \n    //   /\\    /\\\n    //  /  \\  /  \\ \n    // /    \\/    \\ \n\n    lines = min(lines * 2., 1.) - max(lines * 2. - 1., 0.);\n    \n    // Scale it by the amount the noise varies over a pixel,\n    // factoring in the spacing scaling that was applied.\n    // noise is used because it's continuous, if we use lines we'd\n    // see stepping artefacts.\n    lines /= fwidth(noise / spacing);\n\t\n    // Double to occupy two pixels and appear smoother\n    lines /= 2.;\n    \n    // Triangle distance\n    float d = sTri(uv + vec2(0,.1), .3);\n    \n    // Create a fuzzy border from 0 - 1 around the triangle, this\n    // controls the pointy shape where lines transition from thick\n    // to thin\n    float weight = smoothstep(.0, .05, d);\n\n    // Adjust to the desired inner and outer weight\n    #ifndef ALTERNATE_VERSION\n    \tweight = mix(4.2, 1.2, weight);\n    #else\n    \tweight = mix(.5, .33, weight);\n    #endif\n    \n    // Scale the weight when fullscreen\n    weight *= iResolution.y / 287.;\n\n    // Offset the line by the weight\n    lines -= weight - 1.;\n    \n    #ifdef ALTERNATE_VERSION\n    \tlines = 1. - lines;\n   \t#endif\n    \n\tfragColor = vec4(vec3(lines),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xt3yDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[255, 255, 276, 276, 387], [389, 389, 418, 418, 967], [1259, 1259, 1293, 1293, 1504], [2229, 2229, 2274, 2274, 2347], [2349, 2349, 2411, 2411, 2537], [2539, 2539, 2596, 2654, 5556]], "test": "ok"}
{"id": "Xt3yRN", "name": "Gaze of the abyss", "author": "Vovosunt", "description": "Mouse to control the light <O>", "tags": ["2d", "eye"], "likes": 12, "viewed": 271, "published": "Public", "date": "1535659639", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define thick   0.04\n#define smooth  (0.000015 * iResolution.x)\n#define PI      3.14159265359\n#define grid    10.0\n#define SM(x, offset) smoothstep(smooth, -smooth, x - offset)\n#define SMX(x, offset) smoothstep(1.0, -1.0, x - offset)\n#define scale vec2(4.0, 6.0) \n#define rots 360.0\n\nfloat rand(vec3 v){\n    return fract(cos(dot(v,vec3(13.46543,67.1132,123.546123)))*43758.5453);\n}\n\nfloat rand(vec2 v){\n    return fract(sin(dot(v,vec2(5.11543,71.3177)))*43758.5453);\n}\n\nfloat rand2(vec2 v){\n    return fract(sin(dot(v,vec2(330.2322,91.1132)))*63232.2312);\n}\n\nfloat rand(float v){\n    return fract(sin(v * 71.3132)*43758.5453);\n}\n\nvec2 rotate(vec2 st, float angle){\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, -s, s, c) * st;\n}\nfloat smrand(float v){\n    float vv = floor(v);\n    return mix(rand(vv),rand(vv+1.0),fract(v));\n}\n\nvec3 eye(vec2 st, float rt, vec2 mouse, float open, float siz, float lrt){\n    vec2 str = st * scale;\n        \n    float cs = cos(str.x);\n    float eyelidx = 1.0 -  max(SMX(cs * 2.0 - str.y + 0.5, 0.51), 1.0 - SMX(-cs * 2.0 - str.y + 0.5, 0.51));\n    cs *= min(open,rt + 0.5);\n    float top = cs - str.y + 0.5;\n    float bot = -cs - str.y + 0.5;\n    float eyelid = 1.0 -  max(SM(top, 0.51), 1.0 - SM(bot, 0.51));\n    float eyelid2 = 1.0 - max(SM(top, 0.44), 1.0 - SM(bot,0.44));\n    \n    \n    vec2 sti = (st + mouse * vec2(1.5,0.6)) * scale.x;\n    float a = (atan(sti.x,sti.y) + PI) /PI /2.;\n    float l = length(sti);\n    float irf = SM(l,0.5 * siz);\n    float irl = SM(l,0.45 * siz);\n    float irm = SM(l,0.15 * siz * (rt + 0.5));\n    float irn = smrand(a * 200.0);\n    float irnn = abs(fract(l * (irn + 1.0) - 0.35 * siz * (rt + 0.5) -0.7) - 0.5)* 3. *(1.0 -l);\n    vec2 stir = (st + mouse * vec2(2.0,1.0)) * scale.x;\n    float irr = SM(length(stir),0.1 + 0.05 * lrt);\n    vec2 stis = (st + mouse * vec2(3.0,2.0)) * scale.x;\n    float irs = SMX(length(stis),1.0) * eyelidx;\n    \n    \n    vec3 col = vec3(1.0 - (irf));\n    col = mix(col, irnn * vec3(2.0,(1.0 - fract(l)) * 0.75,0.0),irl -irm);\n    col = mix(col,(1.0 -fract(l /scale.x)) * vec3(2.0,1.0,1.0), 1.0 - irf) + irr;\n    col = min(vec3(eyelid2), col);\n    col = mix(col,irs * vec3(0.15) * (open * 0.65 + 0.25 + 0.05 *lrt), 1.0 - eyelid2);\n    col = mix(col,vec3(0.5,0.0,0.0),max(eyelid - eyelid2, eyelid2 - eyelid));\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 st = (fragCoord.xy - 0.5 * iResolution.xy)/ iResolution.x;\n    vec2 mouse = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.x;\n    vec2 toMouse = -mouse + st;\n    float r = rand(floor(st*grid));\n    float r2 = rand2(floor(st*grid));\n    float rt = (sin(iTime * 2.0 + r * 100.0)+ 1.0)/2.0;\n    vec2 cor = (fract(st * grid) - 0.5) * (1.0 + r2 * 0.5) + 0.25 * (vec2(r, r2) - 0.5);\n    cor = rotate(cor, rots * r);\n    float tm = 1.0 - length(toMouse);\n    float lrt = smrand(iTime* 15.0);\n    float open = length(mouse - floor(st * grid)/grid);\n    open = clamp(pow(1.1 - open, 25.0),0.0, 1.);\n    vec3 col = eye(cor,rt, rotate(toMouse, rots * r), open, r2 + 1.0, lrt);\n    col = col * tm * tm + pow(tm,75.0 + 15.0 * lrt) * vec3(1.5,1.4,1.2);\n        \n    col = max(col, vec3(0.05,0.05,0.025)*rand(fragCoord.xy/2.0 + iTime));\n        \n    //float line = min(SM(st.y - 0.0001, 0.0),SM(-st.y - 0.0001, 0.0));\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xt3yRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[284, 284, 303, 303, 381], [383, 383, 402, 402, 468], [470, 470, 490, 490, 557], [559, 559, 579, 579, 628], [630, 630, 664, 664, 753], [754, 754, 776, 776, 851], [853, 853, 927, 927, 2348], [2351, 2351, 2407, 2407, 3355]], "test": "ok"}
{"id": "XtccDS", "name": "prime fractial", "author": "archibate", "description": "prime fractial. Inspiration: [url]https://www.shadertoy.com/view/XlcyD8[/url].\ntry move mouse around.", "tags": ["2d", "math", "pattern"], "likes": 3, "viewed": 108, "published": "Public", "date": "1533779348", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// https://www.shadertoy.com/view/4slGRH\nint isPrime( int x )\n{\n    int i = 0;\n#define true (-x)\n#define false x\n\tif( x==1 ) return false;\n\tif( x==2 ) return true;\n\tif( x==3 ) return true;\n\tif( x==5 ) return true;\n\tif( x==7 ) return true;\n\tif( (x&1)==0 ) return false;\n\tif( (x%3)==0 ) return false;\n\tif( (x%5)==0 ) return false;\n\n    int xm = 1 + int(sqrt(float(x)));\n    \n\tint y = 7;\n    int im = int(sqrt(float(x))/3.75);\n\twhile (i < im)\n\t{\n\t\t         if( (x%y)==0 ) return false;\n\t\ty += 4;  if( y>=xm    ) return true;\n\t\t         if( (x%y)==0 ) return false;\n\t\ty += 2;  if( y>=xm )    return true;\n\t\t         if( (x%y)==0 ) return false;\n\t\ty += 4;  if( y>=xm )    return true;\n\t\t         if( (x%y)==0 ) return false;\n\t\ty += 2;  if( y>=xm )    return true;\n\t\t         if( (x%y)==0 ) return false;\n\t\ty += 4;  if( y>=xm )    return true;\n\t\t         if( (x%y)==0 ) return false;\n\t\ty += 6;  if( y>=xm )    return true;\n\t\t         if( (x%y)==0 ) return false;\n\t\ty += 2;  if( y>=xm )    return true;\n\t\t         if( (x%y)==0 ) return false;\n\t\ty += 6;  if( y>=xm )    return true;\n\t}\n\t\n\treturn true;\n#undef true\n#undef false\n}\n\nint f(ivec2 u)\n{\n    //return u.x^u.y;\n    return u.x&u.y;\n    //return u.x|u.y;\n    u.x=2*u.x+1; return (u.x|(u.y-(u.x^u.y)));\n    //u=2*u+1; return u.y&(u.x|(u.y-(u.x^u.y)));\n    //u=2*u+1; return u.x^(u.y-(u.x|u.y));\n    //u.x=2*u.x+1; return (u.x&(u.y-(u.x^u.y)));\n    return u.x*u.x+u.x*u.y+44;\n    u *= int(iTime/.1); return u.x&(u.y-u.x*u.y);\n    return u.x*u.x+u.x*u.y+int(iTime/.1);\n    return u.x*u.y+int(iTime/.1);\n    return u.x*u.x+u.x+u.y+1;\n}\n\nvoid mainImage(out vec4 O, in vec2 U)\n{\n#define L 7\n    ivec2 u = ivec2(U-iMouse.xy); u+=int(iTime*100.);\n    O = vec4(float(isPrime(f(u)) % L)/float(L));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtccDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1122, 1122, 1138, 1160, 1579], [1581, 1581, 1620, 1620, 1737]], "test": "ok"}
{"id": "Xtcczl", "name": "redacted now deleted from", "author": "zproxy", "description": "cycle of 5 text blocks", "tags": ["2d", "text"], "likes": 5, "viewed": 143, "published": "Public", "date": "1533582415", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// https://www.shadertoy.com/view/XdXGRB\n\n// Source edited by David Hoskins - 2013.\n\n// I took and completed this http://glsl.heroku.com/e#9743.20 - just for fun! 8|\n// Locations in 3x7 font grid, inspired by http://www.claudiocc.com/the-1k-notebook-part-i/\n// Had to edit it to remove some duplicate lines.\n// ABC  a:GIOMJL b:AMOIG c:IGMO d:COMGI e:OMGILJ f:CBN g:OMGIUS h:AMGIO i:EEHN j:GHTS k:AMIKO l:BN m:MGHNHIO n:MGIO\n// DEF  o:GIOMG p:SGIOM q:UIGMO r:MGI s:IGJLOM t:BNO u:GMOI v:GJNLI w:GMNHNOI x:GOKMI y:GMOIUS z:GIMO\n// GHI\n// JKL \n// MNO\n// PQR\n// STU\n\nvec2 coord;\n\n#define font_size 20. \n#define font_spacing .05\n#define STROKEWIDTH 0.05\n#define PI 3.14159265359\n\n#define A_ vec2(0.,0.)\n#define B_ vec2(1.,0.)\n#define C_ vec2(2.,0.)\n\n//#define D_ vec2(0.,1.)\n#define E_ vec2(1.,1.)\n//#define F_ vec2(2.,1.)\n\n#define G_ vec2(0.,2.)\n#define H_ vec2(1.,2.)\n#define I_ vec2(2.,2.)\n\n#define J_ vec2(0.,3.)\n#define K_ vec2(1.,3.)\n#define L_ vec2(2.,3.)\n\n#define M_ vec2(0.,4.)\n#define N_ vec2(1.,4.)\n#define O_ vec2(2.,4.)\n\n//#define P_ vec2(0.,5.)\n//#define Q_ vec2(1.,5.)\n//#define R_ vec2(1.,5.)\n\n#define S_ vec2(0.,6.)\n#define T_ vec2(1.,6.)\n#define U_ vec2(2.0,6.)\n\n#define A(p) t(G_,I_,p) + t(I_,O_,p) + t(O_,M_, p) + t(M_,J_,p) + t(J_,L_,p)\n#define B(p) t(A_,M_,p) + t(M_,O_,p) + t(O_,I_, p) + t(I_,G_,p)\n#define C(p) t(I_,G_,p) + t(G_,M_,p) + t(M_,O_,p) \n#define D(p) t(C_,O_,p) + t(O_,M_,p) + t(M_,G_,p) + t(G_,I_,p)\n#define E(p) t(O_,M_,p) + t(M_,G_,p) + t(G_,I_,p) + t(I_,L_,p) + t(L_,J_,p)\n#define F(p) t(C_,B_,p) + t(B_,N_,p) + t(G_,I_,p)\n#define G(p) t(O_,M_,p) + t(M_,G_,p) + t(G_,I_,p) + t(I_,U_,p) + t(U_,S_,p)\n#define H(p) t(A_,M_,p) + t(G_,I_,p) + t(I_,O_,p) \n#define I(p) t(E_,E_,p) + t(H_,N_,p) \n#define J(p) t(E_,E_,p) + t(H_,T_,p) + t(T_,S_,p)\n#define K(p) t(A_,M_,p) + t(M_,I_,p) + t(K_,O_,p)\n#define L(p) t(B_,N_,p)\n#define M(p) t(M_,G_,p) + t(G_,I_,p) + t(H_,N_,p) + t(I_,O_,p)\n#define N(p) t(M_,G_,p) + t(G_,I_,p) + t(I_,O_,p)\n#define O(p) t(G_,I_,p) + t(I_,O_,p) + t(O_,M_, p) + t(M_,G_,p)\n#define P(p) t(S_,G_,p) + t(G_,I_,p) + t(I_,O_,p) + t(O_,M_, p)\n#define Q(p) t(U_,I_,p) + t(I_,G_,p) + t(G_,M_,p) + t(M_,O_, p)\n#define R(p) t(M_,G_,p) + t(G_,I_,p)\n#define S(p) t(I_,G_,p) + t(G_,J_,p) + t(J_,L_,p) + t(L_,O_,p) + t(O_,M_,p)\n#define T(p) t(B_,N_,p) + t(N_,O_,p) + t(G_,I_,p)\n#define U(p) t(G_,M_,p) + t(M_,O_,p) + t(O_,I_,p)\n#define V(p) t(G_,J_,p) + t(J_,N_,p) + t(N_,L_,p) + t(L_,I_,p)\n#define W(p) t(G_,M_,p) + t(M_,O_,p) + t(N_,H_,p) + t(O_,I_,p)\n#define X(p) t(G_,O_,p) + t(I_,M_,p)\n#define Y(p) t(G_,M_,p) + t(M_,O_,p) + t(I_,U_,p) + t(U_,S_,p)\n#define Z(p) t(G_,I_,p) + t(I_,M_,p) + t(M_,O_,p)\n#define STOP(p) t(N_,N_,p)\n\t\nvec2 caret_origin = vec2(3.0, .9);\nvec2 caret;\n\n//-----------------------------------------------------------------------------------\nfloat minimum_distance(vec2 v, vec2 w, vec2 p)\n{\t// Return minimum distance between line segment vw and point p\n  \tfloat l2 = (v.x - w.x)*(v.x - w.x) + (v.y - w.y)*(v.y - w.y); //length_squared(v, w);  // i.e. |w-v|^2 -  avoid a sqrt\n  \tif (l2 == 0.0) {\n\t\treturn distance(p, v);   // v == w case\n\t}\n\t\n\t// Consider the line extending the segment, parameterized as v + t (w - v).\n  \t// We find projection of point p onto the line.  It falls where t = [(p-v) . (w-v)] / |w-v|^2\n  \tfloat t = dot(p - v, w - v) / l2;\n  \tif(t < 0.0) {\n\t\t// Beyond the 'v' end of the segment\n\t\treturn distance(p, v);\n\t} else if (t > 1.0) {\n\t\treturn distance(p, w);  // Beyond the 'w' end of the segment\n\t}\n  \tvec2 projection = v + t * (w - v);  // Projection falls on the segment\n\treturn distance(p, projection);\n}\n\n//-----------------------------------------------------------------------------------\nfloat textColor(vec2 from, vec2 to, vec2 p)\n{\n\tp *= font_size;\n\tfloat inkNess = 0., nearLine, corner;\n\tnearLine = minimum_distance(from,to,p); // basic distance from segment, thanks http://glsl.heroku.com/e#6140.0\n\tinkNess += smoothstep(0., 1., 1.- 14.*(nearLine - STROKEWIDTH)); // ugly still\n\tinkNess += smoothstep(0., 2.5, 1.- (nearLine  + 5. * STROKEWIDTH)); // glow\n\treturn inkNess;\n}\n\n//-----------------------------------------------------------------------------------\nvec2 grid(vec2 letterspace) \n{\n\treturn ( vec2( (letterspace.x / 2.) * .65 , 1.0-((letterspace.y / 2.) * .95) ));\n}\n\n//-----------------------------------------------------------------------------------\nfloat count = 0.0;\nfloat gtime;\nfloat t(vec2 from, vec2 to, vec2 p) \n{\n\tcount++;\n\tif (count > gtime*20.0) return 0.0;\n\treturn textColor(grid(from), grid(to), p);\n}\n\n//-----------------------------------------------------------------------------------\nvec2 r()\n{\n\tvec2 pos = coord.xy/iResolution.xy;\n\tpos.y -= caret.y;\n\tpos.x -= font_spacing*caret.x;\n\treturn pos;\n}\n\n//-----------------------------------------------------------------------------------\nvoid add()\n{\n\tcaret.x += 1.0;\n}\n\n//-----------------------------------------------------------------------------------\nvoid space()\n{\n\tcaret.x += 1.5;\n}\n\n//-----------------------------------------------------------------------------------\nvoid newline()\n{\n\tcaret.x = caret_origin.x;\n\tcaret.y -= .18;\n}\n\n//-----------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float speed = 0.8;\n    float time33 = mod(speed * iTime, 11.0 * 5.0);\n\n    //float time22 = mod(0.5 * iTime, 11.0 * 2.0);\n\n    float time = mod(speed * iTime, 11.0);\n    gtime = time;\n\n\tfloat d = 0.;\n\tvec3 col = 0.5*vec3(0.1, .07+0.07*(.5+sin(fragCoord.y*3.14159*1.1+time*2.0)) + sin(fragCoord.y*.01+time+2.5)*0.05, 0.1);\n    \n    coord = fragCoord;\n\t\n\tcaret = caret_origin;\n\n\t// the quick brown fox jumps over the lazy dog...\n    \n    #define w(Z) d += Z(r()); add(); \n    #define dot STOP\n    #define wCOM w(C)w(O)w(M)\n    #define dotCOM w(STOP)w(C)w(O)w(M)\n    \n     if (time33 <= 11.0)\n    {\n   \t\tw(R)w(E)w(D)w(A)w(C)w(T)w(E)w(D)\n    }\n    else if (time33 <= 44.0)\n    {\n    \n        w(I)w(N)w(F)w(O)w(W)w(A)w(R)w(S)dotCOM\n    }\n    else\n    {\n    \n        w(Y)w(O)w(U) \n            space();\n    \n    }\n    \n        newline();\n    w(dot)w(dot)w(dot) space();  \n    \n     if (time33 <= 44.0)\n     {\n    w(N)w(O)w(W)      \t\t\t\t\t\n        }\n    else\n    {\n            w(W)w(I)w(L)w(L)  \n                        space();\n        w(B)w(E) \n    }\n    \n        newline();\n    w(dot)w(dot)w(dot) space();  w(D)w(E)w(L)w(E)w(T)w(E)w(D)        newline();\n    w(dot)w(dot)w(dot) space();  w(F)w(R)w(O)w(M)  \t\t\t\t\tnewline();\n    \n    if (time33 <= 11.0)\n    {\n   \t\t  \t\tw(R)w(E)w(D)w(A)w(C)w(T)w(E)w(D)\n \n    }\n    else if (time33 <= 22.0)\n    {\n         w(Y)w(O)w(U)w(T)w(U)w(B)w(E) \n             \n\n    }\n    else if (time33 <= 33.0)\n    {\n            w(F)w(A)w(C)w(E)w(B)w(O)w(O)w(K) \n    \n    }\n\telse if (time33 <= 44.0)\n    {\n        w(A)w(P)w(P)w(L)w(E)\n    }\n    else \n    {\n        w(I)w(N)w(T)w(E)w(R)w(N)w(E)w(T)\n    }\n        \n\td = clamp(d* (.75+sin(fragCoord.x*PI*.5-time*4.3)*.5), 0.0, 1.0);\n      \n    col += vec3(d*.5, d, d*.85);\n\tvec2 xy = fragCoord.xy / iResolution.xy;\n\tcol *= vec3(.4, .4, .3) + 0.5*pow(100.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), .4 );\t\n    fragColor = vec4( 2.0*col.r, 0,0, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xtcczl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2717, 2803, 2851, 2914, 3593], [3595, 3681, 3726, 3726, 4070], [4072, 4158, 4188, 4188, 4272], [4392, 4392, 4430, 4430, 4523], [4525, 4611, 4621, 4621, 4724], [4726, 4812, 4824, 4824, 4843], [4845, 4931, 4945, 4945, 4964], [4966, 5052, 5068, 5068, 5114]], "test": "timeout"}
{"id": "XtdcRS", "name": "patterns-002", "author": "zwwgggbest", "description": "patterns-002", "tags": ["polka"], "likes": 1, "viewed": 74, "published": "Public", "date": "1533083568", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592653\n\nvec3 circle(vec2 _uv, float _r, float _smoothEdge)\n{\n\t_uv *= 10.;\n    if(sin(iTime * 3.) > 0.)\n    {\n    \t_uv.x += step(1., mod(_uv.y, 2.)) * cos(iTime * 3.);\n    \t_uv.x -= step(mod(_uv.y, 2.), 1.) * cos(iTime * 3.);\n    }\n    else\n    {\n    \t_uv.y += step(1., mod(_uv.x, 2.)) * cos(iTime * 3.);\n    \t_uv.y -= step(mod(_uv.x, 2.), 1.) * cos(iTime * 3.);\n    }\n    _uv = fract(_uv);\n    \n    float dis = sqrt(dot(_uv - vec2(.5), _uv - vec2(.5)));\n    return vec3(dis < .25);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec3 col1 = circle(uv, .5, 0.01) * col;\n\n    // Output to screen\n    fragColor = vec4(col1,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtdcRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 76, 76, 499], [501, 501, 558, 608, 890]], "test": "error"}
{"id": "XtdcW7", "name": "Perlin-Worley 2.5D", "author": "il_presidente", "description": "Shader used in order to produce volumetric clouds.", "tags": ["3dnoise", "perlin", "worley"], "likes": 0, "viewed": 151, "published": "Public", "date": "1534691924", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Random2D(in vec3 st)\n{\n\treturn fract(sin(dot(st.xyz, vec3(12.9898, 78.233, 57.152))) * 43758.5453123);\n}\n\nfloat Interpolate(float a, float b, float x) {  // cosine interpolation\n\tfloat ft = x * 3.1415927f;\n\tfloat f = (1. - cos(ft)) * 0.5;\n\treturn  a * (1. - f) + b * f;\n}\n\nfloat InterpolatedNoise(float x, float y, float z) {\n\tint integer_X = int(floor(x));\n\tfloat fractional_X = fract(x);\n\tint integer_Y = int(floor(y));\n\tfloat fractional_Y = fract(y);\n    int integer_Z = int(floor(z));\n    float fractional_Z = fract(z);\n    \n\tvec3 randomInput = vec3(integer_X, integer_Y, integer_Z);\n\tfloat v1 = Random2D(randomInput + vec3(0.0, 0.0, 0.0));\n\tfloat v2 = Random2D(randomInput + vec3(1.0, 0.0, 0.0));\n\tfloat v3 = Random2D(randomInput + vec3(0.0, 1.0, 0.0));\n\tfloat v4 = Random2D(randomInput + vec3(1.0, 1.0, 0.0));\n    \n    float v5 = Random2D(randomInput + vec3(0.0, 0.0, 1.0));\n\tfloat v6 = Random2D(randomInput + vec3(1.0, 0.0, 1.0));\n\tfloat v7 = Random2D(randomInput + vec3(0.0, 1.0, 1.0));\n\tfloat v8 = Random2D(randomInput + vec3(1.0, 1.0, 1.0));\n    \n    \n\tfloat i1 = Interpolate(v1, v2, fractional_X);\n\tfloat i2 = Interpolate(v3, v4,  fractional_X);\n    \n    float i3 = Interpolate(v5, v6, fractional_X);\n    float i4 = Interpolate(v7, v8, fractional_X);\n    \n    float y1 = Interpolate(i1, i2, fractional_Y);\n    float y2 = Interpolate(i3, i4, fractional_Y);\n    \n    \n\treturn Interpolate(y1, y2, fractional_Z);\n}\n\n\n\nvec3 random3( vec3 p ) {\n    return fract(sin(vec3(dot(p,vec3(127.1,311.7, 194.1729)),dot(p,vec3(269.5,183.3, 72.0192)), dot(p,vec3(183.3,72.0192,311.7))))*43758.5453);\n}\n\nfloat worley(vec3 st) {\n\tfloat color = 0.0;\n\n    // Scale\n    st *= 15.;\n\n    // Tile the space\n    vec3 i_st = floor(st);\n    vec3 f_st = fract(st);\n\n    float m_dist = 1.;  // minimun distance\n\n    for (int y= -1; y <= 1; y++) {\n        for (int x= -1; x <= 1; x++) {\n\t\tfor (int z = -1; z<=1 ; z++) {\n\n            // Neighbor place in the grid\n            vec3 neighbor = vec3(float(x),float(y), float(z));\n\n            // Random position from current + neighbor place in the grid\n            vec3 point = random3(i_st + neighbor);\n\n\n\t\t\t// Vector between the pixel and the point\n            vec3 diff = neighbor + point - f_st;\n\n            // Distance to the point\n            float dist = pow(length(diff), 1.0);\n\n            // Keep the closer distance\n            m_dist = min(m_dist, dist);\n\t\t\t}\n        }\n    }\n\n    // Draw the min distance (distance field)\n    color += m_dist;\n\n    return 1. - color;\n}\n\nfloat worleyFBM(vec3 st){\n\tfloat color = 0.;\n\tfloat amplitude = 1.;\n\tfloat freq = 1.5/2.0;\n\tint octaves = 10;\n\tfloat persistence = 0.5;\n    float amplitudes[3] = float[](0.625, 0.25, 0.125);\n\tfor(int i = 0; i < octaves; i++){\n\t\tamplitude *= persistence;\n\t\tfreq *= 0.5;\n\n\t\tcolor += worley(st/freq)*amplitude;\n\t}\n\treturn color;\n\n}\n\n\nfloat remap(float originalValue, float originalMin, float originalMax, float newMin, float newMax)\n{\n\treturn newMin + (((originalValue - originalMin) / (originalMax - originalMin)) * (newMax - newMin));\n}\n\nfloat perlinFBM(vec3 st){\n\n    const float initScale = 5.0;\n    st*=initScale;\n    const int octaves = 5;\n    float a = 0.5;\n    float f = 1.0;\n    float tot = 0.0;\n    for(int i = 0; i <= octaves; ++i){\n        tot += a*InterpolatedNoise(f*st.x, f*st.y, f*st.z);\n     \ta *= a;\n        f *= 2.0;\n    }\n    return tot;\n    \n}\n\nfloat perlinFBM(vec2 st){\n \treturn perlinFBM( vec3(st + iTime/20.0*vec2(1.,0),iTime/50.0));   \n}\n\nfloat worleyFBM(vec2 st){\n \treturn worleyFBM( vec3(st + iTime/20.0*vec2(1.,0),iTime/50.0));   \n}\n\nfloat perlinWorley(vec2 st){\n    \n    vec2 pixel_coords = st;\n    \n    float perlin = perlinFBM(pixel_coords/float(iResolution));\n\tfloat worley = worleyFBM(pixel_coords/float(iResolution));\n\tperlin = clamp(perlin, 0.0, 1.0);\n\tworley = clamp(worley, 0.0, 1.0);\n    float worley2 = remap(worley, 0.0, 1.0, 0.0, 0.45);\n\treturn remap( 1. - worley2, 0.0, 1.0, perlin, 1.0);\n    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n \t\n\tfloat perlinWorley = perlinWorley(fragCoord);\n    \n    fragColor = vec4(0., perlinWorley*0.90, perlinWorley, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtdcW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 110], [112, 112, 158, 183, 277], [279, 279, 331, 331, 1427], [1431, 1431, 1455, 1455, 1601], [1603, 1603, 1626, 1626, 2515], [2848, 2848, 2948, 2948, 3052], [3054, 3054, 3079, 3079, 3378], [3380, 3380, 3405, 3405, 3476], [3478, 3478, 3503, 3503, 3574], [3576, 3576, 3604, 3604, 3951], [3953, 3953, 4007, 4007, 4133]], "test": "ok"}
{"id": "Xtdczf", "name": "Swastikas", "author": "shaderv44", "description": "Swastikas", "tags": ["fractal"], "likes": 2, "viewed": 179, "published": "Public", "date": "1533497738", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define sqrt2 1.41421356237\n#define pi 3.14159265359\n\nfloat distanceToLine(vec2 start, vec2 end, vec2 uv) {\n    vec2 n = normalize(end-start);\n    float l = length(end-start);\n    float q = length(dot(n, uv-start));\n\tif (q > l || dot(n, uv-start) < 0.0) return 99999.0;\n    else return length((dot(n, uv-start)*n - (uv - start)));\n}\n\nfloat distanceToSwastika(vec2 pos, float scale, float rot, vec2 uv) {\n\tfloat d = scale;\n    vec2 right = scale*vec2(cos(rot), sin(rot));\n    vec2 up = scale*vec2(sin(rot), -cos(rot));\n    return \n    min(distanceToLine(pos, pos+right, uv),\n   \tmin(distanceToLine(pos+right, pos+right+up, uv),\n    min(distanceToLine(pos, pos+up, uv), \n    min(distanceToLine(pos + up, pos-right+up, uv),\n    min(distanceToLine(pos, pos-right, uv),\n    min(distanceToLine(pos+up, pos-right+up, uv), \n    min(distanceToLine(pos-right,pos-right-up, uv), \n    min(distanceToLine(pos, pos-up, uv),\n        distanceToLine(pos-up, pos+right-up, uv)))))))));\n}\n\nfloat distanceToThing(vec2 uv) {\n    vec2 pos = vec2(0.5,0.5);\n    float rot = iTime*0.5;\n    float scale = 0.2;\n\tfloat distance = distanceToSwastika(vec2(0.5,0.5), scale,rot, uv);\n    for (int i = 0; i < 4; i++) {\n        vec2 p = pos + sqrt2 * scale * vec2(cos(rot+float(i)*pi/2.0+pi/4.0),sin(rot+float(i)*pi/2.0+pi/4.0));\n        distance = min(distance, distanceToSwastika(\n            p,\n            scale/4.0,\n            rot*2.0, \n            uv)\n        );\n        for (int j = 0; j < 4; j++) {\n            vec2 p2 = sqrt2 * (scale/4.0)\n                * vec2(cos(rot*2.0+float(i)*pi/2.0+pi/4.0+float(j)*pi/2.0),\n                       sin(rot*2.0+float(i)*pi/2.0+pi/4.0+float(j)*pi/2.0));\n        \tdistance = min(distance, distanceToSwastika(\n                p + p2,\n                scale/8.0,\n                rot*4.0, \n                uv)\n            );\n            for (int k = 0; k < 4; k++) {\n                vec2 p3 = sqrt2 * (scale/8.0)\n                    * vec2(cos(rot*4.0+float(i)*pi/2.0+pi/4.0+float(j)*pi/2.0+float(k)*pi/2.0),\n                           sin(rot*4.0+float(i)*pi/2.0+pi/4.0+float(j)*pi/2.0+float(k)*pi/2.0));\n                distance = min(distance, distanceToSwastika(\n                    p+p2+p3,\n                    scale/24.0,\n                    rot*8.0, \n                    uv)\n                              );\n            }\n        }\n    }\n    return distance;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(-0.4,0.0)+fragCoord/iResolution.y;\n    float D = distanceToThing(uv);\n    float d = D;\n    if (d < 0.005) fragColor = vec4(1.0);\n    else fragColor = vec4(1.0-length(uv - vec2(0.5,0.5)),0.0,1.0-length(uv - vec2(0.5,0.5)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xtdczf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 54, 107, 107, 332], [334, 334, 403, 403, 969], [971, 971, 1003, 1003, 2377], [2379, 2379, 2436, 2436, 2684]], "test": "timeout"}
{"id": "XtGcRw", "name": "Neon Fog", "author": "momoro", "description": "rough", "tags": ["color"], "likes": 0, "viewed": 454, "published": "Public API", "date": "1535426639", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define PI 3.141592654\n\nfloat map(float value, float inMin, float inMax, float outMin, float outMax) {\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n}\n\n\nmat2 rotate(float angle) {\n    return mat2(cos(angle), -sin(angle),\n                sin(angle), cos(angle)\n    );\n}\n\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n\nfloat atan201(float x, float y) {\n    return (atan(x, y) + PI) / (PI * 2.);\n}\n\nfloat sin01(float n) {\n    return sin(n)/2.+.5;\n}\n\nvec2 sin01(vec2 n) {\n    return sin(n)/2.+.5;\n}\n\nvec4 blend(vec4 bg, vec4 fg) {\n    vec4 c = vec4(0.);\n    c.a = 1.0 - (1.0 - fg.a) * (1.0 - bg.a);\n    if(c.a < .00000) return c;\n    \n    c.r = fg.r * fg.a / c.a + bg.r * bg.a * (1.0 - fg.a) / c.a;\n    c.g = fg.g * fg.a / c.a + bg.g * bg.a * (1.0 - fg.a) / c.a;\n    c.b = fg.b * fg.a / c.a + bg.b * bg.a * (1.0 - fg.a) / c.a;\n    \n    return c;\n}\n\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return dot(m, g);\n}\n\n\nfloat fbm1d(float x, float amplitude, float frequency, float offset) {\n    x += offset;\n    float y = 0.;\n    // Properties\n    const int octaves = 8;\n    float lacunarity = 1.144;\n    float gain = 1.092;\n    \n    // Initial values\n    //sin(u_time) * 5. + 10.;\n    //sin(u_time/10. + 10.);\n    \n    // Loop of octaves\n    for (int i = 0; i < octaves; i++) {\n        y += amplitude * snoise(vec2(frequency*x));\n        frequency *= lacunarity;\n        amplitude *= gain;\n    }\n    \n    return y;\n}\n\n\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\nfloat smax(float a,float b, float k)\n{\n    return -smin(-a,-b,k);\n}\n\nfloat smootheststep(float t) {\n    return -20.*pow(t, 7.)+70.*pow(t,6.)-84.*pow(t,5.)+35.*pow(t,4.); // when smootherstep's second derivative isn't enough\n}\n\n\nfloat pcsmooth(float x) {\n    return -\n        pow(cos((PI*(x)/2.)), 3.) + 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    vec4 color;\n    vec2 st = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    \n    st /=21.036;\n    st += vec2(-0.010,-0.030);\n    \n    st *= rotate(iTime/.9);\n    \n    /////////////////////////////////////////////////////////////\n    // Blobby circle\n    #define arcs 7.\n    \n    float f = atan201(st.x, st.y); // angle\n    float m = smoothstep(0., 1., fract(f * arcs)); // mix amount\n\t\n     m = pcsmooth(fract(f*arcs));\n    \n    f = ceil(f * arcs) / arcs; // split up\n    \n    float fNext = f + 1./arcs;\n    // fNext = f;\n    \n    \n    // Smooth the blob at the end\n    bool e = false;\n    if(f > (arcs-1.)/arcs + .01) {\n\t\tfNext = 1./arcs;\n    }\n    \n    // Add noise\n    float amp = 2000.;\n    float freq = 30.;\n    \n    float offset = 1.144 + iTime/300.;\n    f = fbm1d(f, amp, freq, offset);\n    fNext = fbm1d(fNext, amp, freq, offset);\n    \n    f =  map(f, -20., 1., 0.648, 0.712);\n    fNext = map(fNext, -20., 1., 0.648, 0.712);\n\n    float len = length(st);\n\n    float mx = mix(f, fNext, m);\n    len += mx * 0.080;\n    \n  //  float c = smoothstep(len, 0.712, 0.900);\n    \n   // color.rgb = vec3(c);\n\n  //  color.a = 1.;\n    //color.rgb = vec3(mx);\n    \n    #define steps 90.\n    for(float i=0.; i<steps; i++) {\n   \t\tfloat df = max(abs(st.x), abs(st.y));\n        df = len * -2.772;\n        // df = length(st);\n        \n        float incr = 0.4 - (0.4 * i/steps);\n        \n        float f = 1.0 - smoothstep(incr-.001, incr, df);\n\n        // SHADOW\n       f -=  (1.0 - (fract(df*steps) + 0.176)) * 0.744 * f;\n        \n        vec3 rgb = vec3(f);\n        \n        vec3 hsv = vec3(1.);\n        hsv.x = pow(2. * fract((i*6.)/steps + iTime/30.3) - 1., 2.);\n        hsv.x = map(hsv.x, 0., 1., 0.2, 0.908);\n        hsv.y = 0.876;\n\n        vec3 rgb2 = hsv2rgb(hsv);\n\n        rgb = rgb2 * rgb * 500.112;\n        float a = (i/steps + 0.880) * f;\n       // a  = 0.208;\n\n        color = blend(color, vec4(rgb, a * f));\n    }\n    \n\n\n    \n    for(float i=0.; i<steps; i++) {\n   \t\tfloat df = max(abs(st.x), abs(st.y));\n        df = len  *0.044;\n        // df = length(st);\n        \n        float incr = 0.4 - (0.4 * i/steps);\n        \n        float f = 1.0 - smoothstep(incr-.001, incr, df);\n\n        // SHADOW\n       f -=  (1.0 - (fract(df*steps) + 0.700)) * +3.032 * f;\n        \n        vec3 rgb = vec3(f);\n        \n        vec3 hsv = vec3(1.);\n        hsv.x = pow(2. * fract((i*6.)/steps + iTime/9.3) - 1., 2.);\n        hsv.x = map(hsv.x, 0., 1., 0.0, 0.964);\n        hsv.y = .9;\n        hsv.z = .1;\n\n        vec3 rgb2 = hsv2rgb(hsv);\n\n        rgb = rgb2 * rgb * 1.112;\n        float a = (i/steps + 0.01) - 0.472;\n       // a  = 0.208;\n\n        color = blend(color, vec4(rgb, a * f));\n    }\n        \n    color = color;\n    \n    fragColor = color;\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtGcRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 103, 103, 178], [181, 181, 207, 207, 296], [299, 299, 321, 321, 652], [654, 654, 676, 676, 845], [847, 847, 868, 868, 915], [916, 916, 937, 937, 984], [985, 985, 1007, 1007, 1042], [1045, 1045, 1078, 1078, 1122], [1124, 1124, 1146, 1146, 1173], [1175, 1175, 1195, 1195, 1222], [1224, 1224, 1254, 1254, 1571], [1573, 1573, 1595, 1648, 3337], [3340, 3340, 3410, 3410, 3837], [3840, 3840, 3878, 3878, 3955], [3957, 3957, 3995, 3995, 4024], [4026, 4026, 4056, 4056, 4182], [4185, 4185, 4210, 4210, 4265], [4267, 4267, 4323, 4323, 7085]], "test": "ok"}
{"id": "XtGyDR", "name": "Crystal Caustic", "author": "klk", "description": "Caustic-like pattern of overlapping fuzzy circles", "tags": ["caustic"], "likes": 17, "viewed": 1253, "published": "Public API", "date": "1535639880", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Alex Kluchikov\n\n#define float3 vec3\n#define float2 vec2\n#define float4 vec4\n\nfloat3 MIX(float3 x, float3 y)\n{\n\treturn abs(x-y);\n}    \n\nfloat CV(float3 c, float2 uv)\n{\n    float size=640./iResolution.x*0.003;\n\treturn 1.0-clamp(size*(length(c.xy-uv)-c.z),0.,1.);\n}\n\nvoid mainImage(out float4 O, in float2 I)\n{\n    O=float4(0,0,0,1);\n    for(float i=0.;i<60.;i+=4.5)\n    {\n        float3 c=float3(\n            sin(i*0.57+7.+iTime*.7),sin(i*0.59-15.-iTime*.65),sin(i*0.6+iTime*.9)\n            )*0.75+0.75;\n\t\tO.rgb=MIX(O.rgb,c*CV(float3(\n\t\t\tsin(iTime*0.5+i/4.5)*(iResolution.x/2.-60.)+iResolution.x/2.,\n\t\t\tsin(iTime*0.73+i/3.)*(iResolution.y/2.-60.)+iResolution.y/2.,\n\t\t\t0.0),I));\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtGyDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[91, 91, 123, 123, 143], [149, 149, 180, 180, 276], [278, 278, 321, 321, 697]], "test": "ok"}
{"id": "XtGyRD", "name": "14_polarHSB", "author": "ywqy", "description": "repetition and accumulation", "tags": ["polar"], "likes": 2, "viewed": 404, "published": "Public API", "date": "1535194049", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TWO_PI 6.28318530718\n\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvec2 polar(vec2 uv) {\n\treturn vec2(length(uv), atan(uv.y, uv.x));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x / iResolution.y;\n\tvec2 uv = ((fragCoord / iResolution.y) - vec2(0.5*aspect, 0.5)) * 2.0;\n\n    vec2 puv = polar(uv);\n    \n    vec3 col = hsb2rgb(vec3((puv.y/TWO_PI + .5) * 10000.0 / (iTime*iTime + 1.0),puv.x,1.0));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtGyRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 56, 56, 288], [290, 290, 311, 311, 357], [359, 359, 416, 416, 697]], "test": "ok"}
{"id": "XtGyz1", "name": "Animated Circle Pattern", "author": "RynsArgent", "description": "Playing around trying to get animating wavelengths but got bubbles instead.", "tags": ["random"], "likes": 3, "viewed": 111, "published": "Public", "date": "1535061854", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y += 0.02 * iTime;\n    \n    //float r = 0.1 * sin(iTime) + uv.x;\n    float r = mod(sin(uv.x * 8.0) + cos(uv.y * 9.0) + 0.05 * iTime, 1.0);\n    float b = mod(sin(uv.x * 9.0) * cos(uv.y * 6.0) + 0.05 * iTime, 1.0);\n    float g = mod(sin(uv.x * 7.0) - cos(uv.y * 4.0) + 0.05 * iTime, 1.0);\n    \n    // Output to screen\n    fragColor = vec4(r, g, b, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtGyz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 508]], "test": "ok"}
{"id": "XtGyzD", "name": "color crown", "author": "nabr", "description": "what should i say i the king of colors ....", "tags": ["color", "rgb", "rotation", "simpel", "scetch", "crown"], "likes": 4, "viewed": 100, "published": "Public", "date": "1535212363", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// nabr\n// https://www.shadertoy.com/view/XtGyzD\n// License: public\n\n// see also: http://www.iquilezles.org/www/articles/palettes/palettes.htm\n\n\n#define pi  3.14159265359\n#define tau 6.28318530718\n\n#define R(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n\n\n// smoothfactor\n#define sf 0.7\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// vec2 uv = ( 2.0 * fragCoord.xy - iResolution.xy )/min(iResolution.x,iResolution.y);\n    // uv *= R( pi ); // -uv.y becourse it's fun\n\t\n    // changed after comment from FabriceNeyret2\n    vec2 uv = (iResolution.xy - 2.0 * fragCoord.xy)/min(iResolution.x,iResolution.y);\n    \n    \n    vec4 finalColor = vec4(0, 0, 0, 1);\n    \n    vec3 color = uv.y + 0.5 * cos(iTime - (tau * acos(uv.x)) + vec3(0.0, pi * 0.5, pi));\n\t\n    finalColor.rgb = pow( sf - sqrt(color), vec3(1.0/2.2));\n\n    fragColor = finalColor; \n\t\n\t\n    // -------- FabriceNeyret2\n    \n\tvec2 u = fragCoord;\n    vec2 R = iResolution.xy ,             \n         U = ( R - u-u ) / min(R.x,R.y);  \n    finalColor = sf - sqrt( U.y + .5 * cos(iTime - 6.28 *( acos(U.x) + vec4(0, .25, .5, 0))));\n\n\tif(U.x > 0.001)\n      fragColor = finalColor; \n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtGyzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[284, 284, 341, 529, 1146]], "test": "ok"}
{"id": "XtjfRt", "name": "Worley fBm", "author": "wsmind", "description": "Worley generalization of Voronoi", "tags": ["noise", "worley"], "likes": 2, "viewed": 481, "published": "Public API", "date": "1534942225", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rand2(vec2 uv)\n{\n    uv += 0.5;\n    uv /= 256.0; // texel size\n\treturn vec2(texture(iChannel0, uv).r, texture(iChannel0, uv + 17.0 / 256.0).r);\n}\n\n#define WORLEY_ORDER 2\n\nfloat worley(vec2 uv)\n{\n    vec2 centerCell = floor(uv);\n    float distances[WORLEY_ORDER];\n    \n    for (int i = 0; i < WORLEY_ORDER; i++)\n        distances[i] = 1000.0;\n    \n    for (float y = -1.0; y <= 1.0; y += 1.0)\n    {\n        for (float x = -1.0; x <= 1.0; x += 1.0)\n        {\n            vec2 cell = centerCell + vec2(x, y);\n            vec2 point = cell + rand2(cell);\n            \n            float dist = distance(point, uv);\n            distances[WORLEY_ORDER - 1] = min(dist, distances[WORLEY_ORDER - 1]);\n            \n            // re-sort distances\n\t\t    for (int i = WORLEY_ORDER - 1; i > 0; i--)\n            {\n                if (distances[i] < distances[i - 1])\n                {\n                    float tmp = distances[i - 1];\n                    distances[i - 1] = distances[i];\n                    distances[i] = tmp;\n                }\n            }\n        }\n    }\n    \n    return distances[WORLEY_ORDER - 1] - distances[WORLEY_ORDER - 2];\n}\n\nfloat fbm(vec2 uv)\n{\n    float value = worley(uv);\n    float factor = 2.0;\n    for (int i = 1; i < 2; i++)\n    {\n        uv += iTime * 0.04;\n        value *= (worley(uv * factor) + 0.2);\n        factor *= 2.0;\n    }\n    return value;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy * 5.0 / iResolution.y;\n\tfragColor = vec4(vec3(fbm(uv)) ,1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtjfRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 150], [176, 176, 199, 199, 1144], [1146, 1146, 1166, 1166, 1381], [1383, 1383, 1440, 1440, 1528]], "test": "error"}
{"id": "XttcDB", "name": "Atoms", "author": "dronhacker666", "description": "Atoms", "tags": ["atom"], "likes": 5, "viewed": 128, "published": "Public", "date": "1533910030", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circle(vec2 uv, float r){\n    return smoothstep(r-0.02, r, length(vec2(0.0) - uv));\n}\n\nfloat satelit(vec2 uv, vec2 p, float r, vec2 d, float t){\n  \tfloat c = cos(t + d.x);\n    float s = sin(t + d.y);\n    p *= mat2(c, -s, s, c);\n    return circle(uv + p, r);\n}\n\nfloat atom(vec2 uv){\n    float m = 1.0;\n    m *= circle(uv, 0.22);\n    \n    float t = iTime * 0.5;\n    float c = 0.9;\n    float s = 0.1;\n    \n    float t1 = iTime;\n    \n    float c1 = abs(cos(t1)) * .5 + .5;\n    for(float i=0.0; i<20.0; i++){\n     \tm *= satelit(uv, vec2(.1, .4), 0.003 * i * c1, vec2(c, c - 1.0), t1 + i);\n    }\n   \n   \tt1 += 0.1;\n    float c2 = abs(cos(t1)) * .5 + .5;\n    for(float i=0.0; i<20.0; i++){\n     \tm *= satelit(uv, vec2(.4, .1), 0.003 * i * c2, vec2(s, s - 1.0), t1 + i);\n    } \n \n   \tt1 += 0.5;\n    float c3 = abs(cos(t1)) * .5 + .5;\n    for(float i=0.0; i<20.0; i++){\n     \tm *= satelit(uv, vec2(.3, -.3), 0.003 * i * c3, vec2(c, s), t1 + i);\n    } \n    return m;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord.xy/iResolution.xy - 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n\t\n    uv *= 1.0 + (sin(iTime * 0.1)*.5+.5) * 0.5;\n    \n    float m = 1.0;\n    \n    float t = iTime;\n    float c = cos(t + 1.0);\n    float s = sin(t + 0.5);\n    \n    mat2 rot = mat2(c, -s, s, c);\n    \n\tfloat z1 = 1.0 + (c*.2);\n    float z2 = 1.0 + (-c*.2);\n    m *= atom((uv*3.5*z1) - vec2(-0.7, 0.0) * rot);\n    m *= atom((uv*3.5*z2) - vec2(0.7, 0.0) * rot);\n    // m *= atom((uv*2.5) - vec2(0.0, -0.6) * rot);\n    \n    vec3 col = mix(vec3(0.2, 0.2, 0.2), vec3(0.7, 0.8, 0.9), m);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XttcDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 91], [93, 93, 150, 150, 265], [267, 267, 287, 287, 964], [967, 967, 1021, 1021, 1630]], "test": "ok"}
{"id": "XttyD2", "name": "waveform renderer", "author": "jimmyjimmy", "description": "Basic waveform rendering with crappy anti-aliasing.", "tags": ["audio", "waveform"], "likes": 2, "viewed": 100, "published": "Public", "date": "1534158499", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float one_hx = 1.0 / iResolution.x;\n    float one_vx = 1.0 / iResolution.y;\n\n   \n    float a = texture(iChannel0, vec2(uv.x, 1.0)).x;\n    float b = texture(iChannel0, vec2(uv.x, 1.0) + vec2(one_hx, 0.0)).x;\n   \n    float der = (a-b);\n    \n    if(der < 0.0) {\n        \n        float c = texture(iChannel0, vec2(uv.x, 1.0) - vec2(one_hx, 0.0)).x;\n        \n        der = (a-c);\n    } else if(der == 0.0) {\n        der = one_vx;\n    }\n    \n    \n    der = abs(der);\n    \n   \n#if 0\n    float dist = (uv.y - a);\n#else\n    float sign_val = (uv.y - 0.5);\n    float dist;// = 0.0;\n\n    if(sign_val > 0.0){\n       dist = uv.y - (0.5 + (a*0.5));    \n    } else {    \n       dist =  -(uv.y - ((0.5 - (a*0.5))));\n    }\n    \n#endif\n   \n    \n    // Time varying pixel color\n    vec3 col1 = vec3(0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)));\n\n    float epsilon = one_vx;//0.01;\n   \n    \n    vec3 col2 = vec3(1.0) - col1;//vec3(cos(iTime*2.0)+uv.x);//vec3(0.0);// mix(vec3(255.0/255.0, 143.0/255.0, 64.0/255.0), vec3(255.0/255.0, 104.0/255.0, 64.0/255.0), ((uv.y)/0.4));\n    \n    float t = 0.0;\n\n    \n    \n    if(dist < 0.0) {\n        t = 1.0;       \n        //col2 = vec3(1.0, 0.0, 0.0); \n        \n        if(abs(dist) < abs(der)) {            \n            der = abs(der);\n            t =  (abs(dist) / der);\n        } else if(abs(dist) < abs(epsilon)) {\n            dist /= epsilon;\n\n            float pixel_opacity = 1.0-clamp(0.5 - dist, 0.0, 1.0);\n            t = pixel_opacity; \n        \n        } else { \n\n        }\n    } \n   \n    // Output to screen\n    fragColor = vec4(mix(col2, col1, t), 1.0);//vec4(col,1.0);\n}", "image_inputs": [{"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XttyD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1753]], "test": "error"}
{"id": "XttyRX", "name": "Underwater Caustics", "author": "TanayStyle", "description": "Voronoi pattern for water caustics", "tags": ["voronoi", "wave", "water", "caustics", "underwater"], "likes": 30, "viewed": 1679, "published": "Public", "date": "1533447330", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define tau 6.28318530718\n\nfloat sin01(float x) {\n\treturn (sin(x*tau)+1.)/2.;\n}\nfloat cos01(float x) {\n\treturn (cos(x*tau)+1.)/2.;\n}\n\n// rand func from theartofcode (youtube channel)\nvec2 rand01(vec2 p) {\n    vec3 a = fract(p.xyx * vec3(123.5, 234.34, 345.65));\n    a += dot(a, a+34.45);\n    \n    return fract (vec2(a.x * a.y, a.y * a.z));\n}\n\nfloat circ(vec2 uv, vec2 pos, float r) {\n    return smoothstep(r, 0., length(uv - pos));\n}\n\nfloat smoothFract(float x, float blurLevel) {\n\treturn pow(cos01(x), 1./blurLevel);\n}\n\nfloat manDist(vec2 from, vec2 to) {\n    return abs(from.x - to.x) + abs(from.y - to.y);\n}\n\n\nfloat distFn(vec2 from, vec2 to) {\n\tfloat x = length (from - to);\n    return pow (x, 4.);\n}\n\nfloat voronoi(vec2 uv, float t, float seed, float size) {\n    \n    float minDist = 100.;\n    \n    float gridSize = size;\n    \n    vec2 cellUv = fract(uv * gridSize) - 0.5;\n    vec2 cellCoord = floor(uv * gridSize);\n    \n    for (float x = -1.; x <= 1.; ++ x) {\n        for (float y = -1.; y <= 1.; ++ y) {\n            vec2 cellOffset = vec2(x,y);\n            \n            // Random 0-1 for each cell\n            vec2 rand01Cell = rand01(cellOffset + cellCoord + seed);\n\t\t\t\n            // Get position of point\n            vec2 point = cellOffset + sin(rand01Cell * (t+10.)) * .5;\n            \n\t\t\t// Get distance between pixel and point\n            float dist = distFn(cellUv, point);\n    \t\tminDist = min(minDist, dist);\n        }\n    }\n    \n    return minDist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Center coordinates at 0\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    \n    float t = iTime * .35;\n    \n\t// Distort uv coordinates\n    float amplitude = .12;\n    float turbulence = .5;\n    uv.xy += sin01(uv.x*turbulence + t) * amplitude;\n    uv.xy -= sin01(uv.y*turbulence + t) * amplitude;\n    \n\t// Apply two layers of voronoi, one smaller   \n    float v;\n    float sizeDistortion = abs(uv.x)/3.;\n    v += voronoi(uv, t * 2., 0.5, 2.5 - sizeDistortion);\n    v += voronoi(uv, t * 4., 0., 4. - sizeDistortion) / 2.;\n    \n    // Foreground color\n    vec3 col = v * vec3(.55, .75, 1.);\n    \n    // Background color\n    col += (1.-v) * vec3(.0, .3, .5);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XttyRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 49, 49, 79], [80, 80, 102, 102, 132], [134, 183, 204, 204, 341], [343, 343, 383, 383, 433], [435, 435, 480, 480, 519], [521, 521, 556, 556, 610], [613, 613, 647, 647, 704], [706, 706, 763, 763, 1468], [1470, 1470, 1527, 1558, 2264]], "test": "ok"}
{"id": "XtVyR1", "name": "Lemniscata", "author": "frozenshady", "description": "Simple lemniscate equation produces nearly chaotic bubbles.\n", "tags": ["2d", "algebraiccurves"], "likes": 3, "viewed": 219, "published": "Public", "date": "1535105365", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define PI 3.14159265359\n\nfloat sin01(in float x)\n{\n    return (sin(x) + 1.0) / 2.0;\n}\n\nfloat smoothStep2(in float edge, in float x)\n{\n    const float fadeWidth = 0.4;\n    return smoothstep(edge - fadeWidth, edge + fadeWidth, x);\n}\n\nvec2 complexProd(in vec2 v1, in vec2 v2)\n{\n    return vec2(v1.x * v2.x - v1.y * v2.y, v1.x * v2.y + v2.x * v1.y);\n}\n\nfloat lem(in vec2 uv, in vec2 f1, in vec2 f2, in float r, in float width)\n{\n    vec2 cp12 = complexProd(uv - f1, uv - f2);\n    return smoothStep2(abs(length(cp12) - (r * r)), width);\n}\n\nfloat lem(in vec2 uv, in vec2 f1, in vec2 f2, in vec2 f3, in float r, in float width)\n{\n    vec2 cp12 = complexProd(uv - f1, uv - f2);\n    vec2 cp123 = complexProd(uv - f3, cp12);\n    return smoothStep2(abs(length(cp123) - (r * r * r)), width);\n}\n\nfloat lem(in vec2 uv, in vec2 f1, in vec2 f2, in vec2 f3, in vec2 f4, in float r, in float width)\n{\n    vec2 cp12 = complexProd(uv - f1, uv - f2);\n    vec2 cp123 = complexProd(uv - f3, cp12);\n    vec2 cp1234 = complexProd(uv - f4, cp123);\n    return smoothStep2(abs(length(cp1234) - pow(r, 4.0)), width);\n}\n\nfloat lem(in vec2 uv, in vec2 f1, in vec2 f2, in vec2 f3, in vec2 f4, in vec2 f5, in float r, in float width)\n{\n    vec2 cp12 = complexProd(uv - f1, uv - f2);\n    vec2 cp123 = complexProd(uv - f3, cp12);\n    vec2 cp1234 = complexProd(uv - f4, cp123);\n    vec2 cp12345 = complexProd(uv - f5, cp1234);\n    return smoothStep2(abs(length(cp12345) - pow(r, 5.0)), width);\n}\n\nvec2 circMotion(in vec2 center, in float r, in float freq, in float phase)\n{\n    float s = sin(iTime * freq + phase);\n    float c = cos(iTime * freq + phase);\n    return center + r * vec2(c, s);\n}\n\nvec2 ellipseMotion(in vec2 center, in float a, in float b, in float angle, in float freq, in float phase)\n{\n    float s = b * sin(iTime * freq + phase);\n    float c = a * cos(iTime * freq + phase);\n    float rs = sin(angle);\n    float rc = cos(angle);\n    return center + mat2(rc, -rs, rs, rc) * vec2(c, s);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy) * 2.0 - vec2(1.0);\n    uv.x *= (iResolution.x / iResolution.y);\n\n    float r = sin01(iTime) * 0.6 + 0.6;\n    const vec2 f1 = vec2(-0.5, 0.0);\n    const vec2 f2 = vec2(0.8, -0.3);\n    const vec2 f3 = vec2(0.0, 0.3);\n    const vec2 f4 = vec2(-0.85, 0.6);\n    \n    vec2 f1m = circMotion(f1, 0.4, 5.1, 0.7);\n    vec2 f2m = ellipseMotion(f2, 0.2, 0.4, PI / 4.0, 4.3, 0.3);\n    vec2 f3m = circMotion(f3, 0.3, 7.0, 0.0);\n    vec2 f4m = circMotion(f4, 0.3, 2.0, 1.0);\n    \n    vec3 c1 = vec3(1.0, 0.0, 0.0);\n    vec3 c2 = vec3(0.0, 1.0, 0.0);\n    vec3 c3 = vec3(0.0, 0.0, 1.0);\n    vec3 c4 = vec3(1.0);\n    \n    float d1 = distance(uv, f1m);\n    float d2 = distance(uv, f2m);\n    float d3 = distance(uv, f3m);\n    float d4 = distance(uv, f4m);\n    \n    vec3 col = (d1 * c1 + d2 * c2 + d3 * c3 + d4 * c4) / 1.5;\n    \n    float c = lem(uv, f1m, f2m, f3m, f4m, r, 0.008);\n    \n    \n    // Output to screen\n    fragColor = vec4(col * c,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtVyR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 52, 52, 87], [89, 89, 135, 135, 232], [234, 234, 276, 276, 349], [351, 351, 426, 426, 535], [537, 537, 624, 624, 783], [785, 785, 884, 884, 1091], [1093, 1093, 1204, 1204, 1461], [1463, 1463, 1539, 1539, 1659], [1661, 1661, 1768, 1768, 1970], [1972, 1972, 2029, 2029, 3002]], "test": "ok"}
{"id": "XtVyRz", "name": "First Julia Fractal", "author": "rodousse", "description": "Julia fractal implementation", "tags": ["fractaljulia"], "likes": 2, "viewed": 390, "published": "Public API", "date": "1534872305", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define max_iteration 1000\n\n/**\n* Thanks to wikipedia ! \n* https://en.wikipedia.org/wiki/Julia_set\n**/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv * vec2(3.5,2.0)) - vec2(1.8,1.0);\n    vec2 z;\n    vec2 c;\n    float xtemp;\n    float speed = 0.05f;\n    float time;\n    time = iTime + 30.0;\n    \n    z.x = uv.x;\n    z.y =  uv.y;\n    \n\tc.x = -0.835;\n    c.y = -0.2321; \n    \n    \n    c = 0.7885 * vec2(cos(time*speed),sin(time*speed));\n    int iteration = 0;\n  \n    while ((dot(z, z) < 2.0f)  &&  iteration < max_iteration) \n    {\n        xtemp = z.x*z.x - z.y*z.y;\n        z.y = 2.0*z.x*z.y  + c.y ;\n        z.x = xtemp + c.x;\n    \n        iteration = iteration + 1 ;\n    }\n  \n    if (iteration == max_iteration)\n        fragColor = vec4(0.0);\n    else\n        fragColor = vec4(10.0*float(iteration)/float(max_iteration));\n\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtVyRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[104, 104, 161, 161, 893]], "test": "ok"}
{"id": "XtVyz1", "name": "First circle shader", "author": "raphaelk", "description": "First circle", "tags": ["circle"], "likes": 1, "viewed": 63, "published": "Public", "date": "1535104393", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n\n\n\n\t\tvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n\t\t{\n\t\t    vec2 uv = fragCoord/iResolution.xy;\n\t\t\tuv -= 0.5;\n\t\t    uv.x *= iResolution.x / iResolution.y;\n\t\t\tfloat d = length(uv);\n\t\t    float r = 0.2;\n    \n\t\t    float c = smoothstep(r, r + tan(iTime * 0.5), d);\n\n\t\t    fragColor = vec4(vec3(c), 1.0);\n\t\t}\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtVyz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[7, 7, 66, 66, 317]], "test": "ok"}
{"id": "XtVyzw", "name": "Let the sunshine in", "author": "Flopine", "description": "Leeeeeeet  the sunshiiiiiiiiiiine\nLeeeeeeeet the sunshine iiiiiin (8) \n\nAnd now it is stuck in my head... Oh no! ", "tags": ["raymarching", "flower", "volumetric"], "likes": 14, "viewed": 557, "published": "Public", "date": "1535550985", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n// using simesgreen shader : https://www.shadertoy.com/view/Msf3Dj\n// Thanks to wsmind, leon, lsdlive, XT95, lamogui and Coyhot for teaching me :)\n// Thanks LJ for giving me the love of shadercoding :3\n\n\n#define ITER 64\n#define PI 3.141592\n#define minStep 0.02\n#define hitThreshold 0.01\n\nmat2 rot (float a)\n{return mat2 (cos(a),sin(a),-sin(a),cos(a));}\n\nvec2 mo (vec2 p, vec2 d)\n{\n    p = abs(p)-d;\n    if (p.y > p.x) p.xy = p.yx;\n    return p;\n}\n\nvec2 moda(vec2 p, float per)\n{\n    float a = atan(p.y,p.x);\n    float l = length(p);\n    a = mod(a-per/2., per) - per/2.;\n\treturn vec2 (cos(a),sin(a))*l;\n}\n\nfloat stmin(float a, float b, float k, float n)\n{\n    float st = k/n;\n    float u = b-k;\n    return min(min(a,b), 0.5 * (u+a+abs(mod(u-a+st, 2.*st)-st)));\n}\n\nfloat od (vec3 p, float d)\n{\n    return dot(p, normalize(sign(p)))-d;\n}\n\nfloat box( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sphe (vec3 p, float r)\n{return length(p)-r;}\n\nfloat sc(vec3 p, float s) \n{\n    p.xz *= rot(iTime);\n    p = abs(p);\n    p = max(p, p.yzx);\n    return min(p.x, min(p.y, p.z)) - s;\n}\n\nfloat prim1 (vec3 p)\n{\n    p.xy = moda(p.xy, 2.*PI/7.);\n   \tp.x -= 2.5;\n    return max(-sc(p, 0.6), od(p,1.));\n}\n\nfloat prim2 (vec3 p)\n{ \n    p.xy *= rot(iTime*0.3);\n    p.xy = mo(p.xy, vec2(3.));\n    p.xy = moda(p.xy, 2.*PI/5.);\n    p.x -= 3.8;\n    return stmin(prim1(p),sphe(p,1.5),0.6,3.);\n}\n\nfloat SDF (vec3 p)\n{\n    float b = box(p, vec3(15.,10.,1.));\n    float d = max(b, -prim2(p));\n  \td += texture(iChannel0, p.xy).r*0.04;\n    return d;\n}\n\n//simesgreen raymarched inside function : https://www.shadertoy.com/view/Msf3Dj\nvec3 traceInside(vec3 ro, vec3 rd, out bool hit, out float insideDist)\n{\n    \n    hit = false;\n    insideDist = 0.0;\t\n    vec3 pos = ro;\n    vec3 hitPos = pos;\n    for(int i=0; i<ITER; i++)\n    {\n\t\tfloat d = SDF(pos);\n\t\td = max(abs(d), minStep) * sign(d);// enforce minimum step size\n\t\t\n\t\tif (d < hitThreshold && !hit) {\n\t\t\t// save first hit\n\t\t\thitPos = pos;\n\t\t\thit = true;\n\t\t}\n\t\t\n\t\tif (d < 0.01) {\n\t\t\t// sum up distance inside\n\t\t\tinsideDist += d;\n\t\t}\n\t\tpos += abs(d)*rd*0.45;\n    }\n    return hitPos;\n}\n\nvec3 getcam (vec3 eye, vec3 lookat, vec2 uv, float fov)\n{\n    vec3 forward = normalize(lookat-eye);\n    vec3 right = normalize(cross(vec3(0.,1.,0.),forward));\n    vec3 up = normalize(cross(forward, right));\n    return normalize(forward*fov+right*uv.x+up*uv.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.*(fragCoord/iResolution.xy)-1.;\n\tuv.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(0.,-1.3, -5.); \n    vec3 p = ro;\n    vec3 target = vec3(0.);\n    vec3 rd = getcam(ro, target, uv, 0.8);\n    \n    vec3 translucentColor = vec3(0.1, 0.2, length(uv*0.5));\n    // trace ray\n    bool hit;\n    float dist;\n    vec3 hitPos = traceInside(ro, rd, hit, dist);\n\n    vec3 rgb = vec3(0.0);\n    if(hit) \n    {\n\t\t// exponential fall-off:\n\t\trgb = exp(-dist*dist*translucentColor);\n     } \n      else \n      {\n        rgb = vec3(0.94,1.,1.);\n     }\n\n\n    // Output to screen\n    fragColor = vec4(pow(rgb, vec3(0.45)),1.0);\n}", "image_inputs": [{"id": "4sf3Rr", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtVyzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[307, 307, 327, 327, 371], [373, 373, 399, 399, 465], [467, 467, 497, 497, 622], [624, 624, 673, 673, 780], [782, 782, 810, 810, 853], [855, 855, 884, 884, 971], [973, 973, 1003, 1003, 1023], [1025, 1025, 1053, 1053, 1158], [1160, 1160, 1182, 1182, 1272], [1274, 1274, 1296, 1296, 1454], [1456, 1456, 1476, 1476, 1606], [1608, 1688, 1760, 1760, 2191], [2193, 2193, 2250, 2250, 2455], [2457, 2457, 2514, 2564, 3198]], "test": "error"}
{"id": "XtycR1", "name": "Perturbed Grid", "author": "Shane", "description": "A triangulated grid with slope based diagonal orientation. Coded for fun, so not to be taken too seriously. :)", "tags": ["grid", "terrain", "lines", "barycentric", "polygon", "mesh"], "likes": 30, "viewed": 1284, "published": "Public API", "date": "1535115755", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n    Perturbed Grid\n    --------------\n\n\tI made this a while back when constructing my \"Terrain Lattice\" example. I thought the \n    rendering style was interesting, but overall, found it a little bland. Anyway, I\n\ttweaked it a little and put in some options... and it's still a little boring, but I\n\tfigured I'd put it up anyway. :) As you can see, it's a standard triangulated perturbed \n    grid, or to be more specific, a raymarched heightmap subdivided into grid squares, \n    which are each subdivided into two triangles to produce a flat shaded look.\n\n    Normally, when you see one of these, the square grid cells are subdivided into triangles \n    via a diagonal partitioning with fixed orientation. However, it's possible to partition\n\tthe cells in all kinds of ways, like patterns, randomness and slope -- Playing around \n    with the \"SHOW_DIAGONAL\" define will illustrate that. The default is a partitioning \n\tbased on the slope -- Basically, it favors a partitioning that cuts the higher slopes \n\tin half. I believe it gives the underlying height map just a touch more definition.\n\n    There are two ways to render flat grid squares. One is to linearly interpolate between\n\tthe height values of all four vertices to produce a quad that looks flat on account of\n    its straight edge joins. The other is to split the quad into two triangles and linearly \n\tinterpolate between the three verticies of each of those. I tried both methods, but \n\tliked the look of the genuinely flat-planed triangles more. For the smooth quad look,\n\tuncomment the \"SMOOTH_QUAD\" define. By the way, there are a heap of compiler directives\n\tin there for anyone who wants to play around with different looks before making one\n\tof these.\n\n    A flat shaded triangle render usually requires a barycentric approach, but since the\n\tgrid triangles are essentially half squares, it's possible to use, vector \n\tperpendicularity, symmetry, etc, to cut down on the calculations considerably.\n    \n\n\tOther examples:\n    \n\t// Simple, and really nicely lit.\n    Triangulator - nimitz\n\thttps://www.shadertoy.com/view/lllGRr\n\n\t// Nice example that takes an intuitive vectorized approach.\n\tRay Marched Mesh Terrain - Flyguy\n\thttps://www.shadertoy.com/view/ltjSRD\n    \n\tTerrain Lattice - Shane\n\thttps://www.shadertoy.com/view/XslyRH\n\n*/\n\n\n\n// OPTIONAL COMPILER DIRECTIVES\n\n// The point of the exercise was to polygonize the terrain and give it a flat shaded triangulated\n// appearance, but if you'd prefer to see smooth quads, just uncomment the following:\n//#define SMOOTH_QUAD\n\n// Animate the surface: The default setting, \"DIAGONAL_MODE 4,\" will flip diagonals according to \n// changine slope, so this would look better with a fixed diagonal orientation, like \n// \"DIAGONAL_MODE 3\" for instance.\n//#define ANIMATE_SURFACE\n\n// Turn the blinking squares on or off.\n#define BLINKING_LIGHTS \n\n// Diagonal orientation (0 - 4) -- Not applicable when the SMOOTH_QUAD directive is on.\n//\n// The orientation of the diagonal can effect the look of the surface. The default is a diagonal \n// orientation based on the slope. The idea being that you favor cutting the largest quad slope\n// in half, which means running a diagonal line between diagonal points with the smallest slope. \n// It's a matter of opinion, but I think it enhances the terrain shape a little more. In order to \n// more clearly see the joins, set the SHOW_DIAGONAL directive to something other than zero.\n//\n// Left: 0, Right: 1, Random: 2, Pattern: 3, Slope: 4.\n#define DIAGONAL_MODE 4\n\n// Horizontal, vertical and diagonal lines. I like it with the horizonal lines only, but wanted\n// to show the square grid by default to emulate a lot of the online imagery I see.\n#define SHOW_HORIZONTAL\n#define SHOW_VERTICAL\n// I find the diagonal joins too busy, so have left it off by default. Also, it's not \n// applicable when the SMOOTH_QUAD directive is on.\n// No lines: 0, Metalic: 1, Timber Grooves: 2.\n#define SHOW_DIAGONAL 0\n\n// Ball joins. The grid looks cleaner without the ball bearing joins, but less interesting.\n#define SHOW_BALL_JOINS\n\n\n/////////\n\n\n// Max ray distance.\n#define FAR 40.\n\n// Scene object ID container to separate the ball joint mesh object from the terrain.\nvec3 vObjID; // Terrain: 0, Join: 1, Ball, 2.\n\n// 2x2 matrix rotation. Note the absence of \"cos.\" It's there, but in disguise, and comes courtesy\n// of Fabrice Neyret's \"ouside the box\" thinking. :)\nmat2 r2(float th){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n\n// vec3 to float hash.\nfloat hash21(vec2 p){\n   \n    float n = dot(p, vec2(13.163, 157.247)); \n    return fract(sin(n)*43758.5453); \n}\n\n\n/*\n// A cheap orthonormal basis vector function - Taken from Nimitz's \"Cheap Orthonormal Basis\" example, then \n// modified slightly.\n//\n//Cheap orthonormal basis by nimitz\n//http://orbit.dtu.dk/fedora/objects/orbit:113874/datastreams/file_75b66578-222e-4c7d-abdf-f7e255100209/content\n//via: http://psgraphics.blogspot.pt/2014/11/making-orthonormal-basis-from-unit.html\nmat3 basis(in vec3 n){\n    \n    float a = 1./(1. + n.z);\n    float b = -n.x*n.y*a;\n    return mat3(1. - n.x*n.x*a, b, n.x, b, 1. - n.y*n.y*a, n.y, -n.x, -n.y, n.z);\n                \n}\n \n\n// A line segment formula that orients via an orthanormal basis. It'd be faster to use\n// IQ's 3D line segment formula, but this one allows for more interesting cross sections,\n// like hexagons and so forth.\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r, float lf){ // Length factor on the end.\n\n\n    b -= a;\n    float l = length(b);\n    \n    p = basis(normalize(b))*(p - a - b*.5);\n    \n    p = abs(p);\n    //p.x = abs(p.x - .03);\n    //return max(length(p.xy) - r, p.z - l*lf);\n    //return max((p.x + p.y)*.7071 - r, p.z - l*lf);\n    //return max(max(p.x, p.y) - r, p.z - l*lf);\n    //return max(max(max(p.x, p.y), (p.y + p.x)*.7071) - r, p.z - l*lf);\n    return max(max(p.x*.866025 + p.y*.5, p.y) - r, p.z - l*lf);\n}\n*/\n\n\n// IQ's 3D line segment formula. Simpler and cheaper, but doesn't orient carved cross-sections.\nfloat sdCapsule(vec3 p, vec3 a, vec3 b){\n\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    pa = abs(pa - ba*h);\n    return length( pa );\n}\n\n\n\n// Height map values. Just a couple of animated sinusoidal layers, but you could put anything\n// here... so long as it's cheap. :)\nfloat hm(in vec2 p){\n    \n    #ifdef ANIMATE_SURFACE\n    // Scaling, plus some movement.\n    p = p/4. + iTime/8.;\n    #else\n    // Scaling only.\n    p /= 4.;\n    #endif\n    \n    // Layer one.\n    float n = dot(sin(p.xy*3.14159 - cos(p.yx*3.14159)*3.14159/2.), vec2(0.25) + .5)*.66;\n    p = p*1.5;  // Increase frequency.\n  \n    p.xy = mat2(.866025, .5, -.5, .866025)*p.xy; // Rotate.\n    \n    // Add another layer.\n    n += dot(sin(p.xy*3.14159 - cos(p.yx*3.14159)*3.14159/2.), vec2(0.25) + .5)*.34;\n    \n    return n; // Range [0, 1]... hopefully. :)\n\n}\n\n// Used to scale the grid without having to move the camera.\n#define scale 1.5 \nvec3 hVal; // Global variable to hold the three height values for reuse.\n\nfloat diag;\n\n// The terrain - tesselated in a flat-grid triangle-pair fashion... Needs rewording. :D\nfloat triTerrain(vec2 p){ \n\n    \n    \n    vec2 ip = floor(p); // Integer value. Used for the unique corner height values.\n    p -= ip; // Fractional grid value.\n   \n    // The height values -- One for each grid vertex. If it were not for the slope\n    // comparisons, only three values would be required. It's a cheap distance field,\n    // so it shouldn't really matter anyway.\n    float h00 = hm(ip);\n    float h01 = hm(ip + vec2(0, 1));\n    float h10 = hm(ip + vec2(1, 0));\n    float h11 = hm(ip + 1.);\n    \n    #ifdef SMOOTH_QUAD\n    \t// Smoothing: Mainly here for reference. To use it with joins, you need to smoothen\n        // the line joins themselves, which doesn't look that great.\n    \t//p *= p*(3. - 2.*p); \n    \t//p *= p*p*(p*(p*6. - 15.) + 10.); \n    \tdiag = 0.;\n    #else \n        #if DIAGONAL_MODE == 0 // Left diagonal.\n        diag = 0.;\n        #elif DIAGONAL_MODE == 1 // Right diagonal.\n        diag = 1.;\n        #elif DIAGONAL_MODE == 2 // Random diagonal orientation.\n        diag = hash21(ip)<.5? 0. : 1.;\n        #elif DIAGONAL_MODE == 3 // Pattern diagonal\n        diag = mod(ip.x + ip.y, 2.)>.5? 0. : 1.;\n        #else\n        float l1 = abs(h00 - h11);\n        float l2 = abs(h01 - h10);\n        diag = l1>l2? 0. : 1.;\n    #endif\n    \n    #endif\n     \n    // The barycentric coordinates, so to speak, and the corresponding height value.\n    // For those of you familiar with the process, you may note that there are far \n    // fewer operations than usual.\n    float s;\n    \n    if(diag<.5){\n        s = step(1., p.x + p.y); // Determines which side of the diagonal we're on.\n\n        // Storing the heights at the three triangle vertices. Normally, it wouldn't be\n        // necessary, but we're reusing them to render the mesh.\n        //hVal = vec3(hm(ip + s), hm(ip + vec2(1, 0)), hm(ip + vec2(0, 1)));\n        float hs = s<.5? h00 : h11;\n        hVal = vec3(hs, h10, h01);\n    }\n    else {\n        // Triangulating across the other diagonal. Handy, if you want to make patterns.\n        s = step(p.x, p.y);\n        //hVal = vec3(hm(ip), hm(ip + vec2(1. - s, s)), hm(ip + 1.));\n        float hs = s<.5? h10 : h01;\n        hVal = vec3(h00, hs, h11);\n    }    \n\n    \n    #ifdef SMOOTH_QUAD\n        // A simple, interpolated quad. It's not really flat, but the edge-joins are straight,\n        // so it looks that way. Because the mesh is set up on triangle logic, there two\n        // extra height values. Normally, you'd only need one extra.\n        return mix(mix(hm(ip), hVal.y, p.x), mix(hVal.z, hm(ip+1.), p.x), p.y);\n    #else\n    \n\n    \n    // Barycentric setup: This is a very trimmed down version of the generalized barycentric\n    // calculations that involve cross-products, and so forth. Without going into detail, I'm\n    // sure you could imagine that three points in space can be used to generate a plane \n    // equation via cross products and such, and the fractional grid points could be used in\n    // unison with the vertice coordinates to determine the exact coordinate on the plane, or\n    // the height value at that coordinate.\n    //\n    // Anyway, the grid triangles are shaped in such a way that a lot of the operations cancel \n    // out, and the lines below are the result. You could just use them. However, if you require\n    // more information, look up a few barycentric coordinate examples.\n    //\n    if(diag<.5){\n        vec3 b = abs(vec3(1.0 - p.x - p.y, p.x - (p.x - p.y + 1.)*s, p.y - (p.y - p.x + 1.)*s));\n\n        // The linearly interpolated triangle height.\n        return dot(b, hVal);\n    }\n    else {\n        //return mix(mix(hVal.x, hm(ip+vec2(1, 0)), f.x), mix(hm(ip+vec2(0, 1)), hVal.z, f.x),f.y);\n        vec3 b = abs(vec3(1. - (1. - s)*p.x - p.y*s, (1. - 2.*s)*(p.x - p.y), p.x*s + p.y*(1. - s)));\n        return dot(b, hVal);\n    }\n    \n    #endif\n    \n\n   \n \n}\n\nfloat tObjID;\n\n// The flat shaded terrain and the mesh.\nfloat map(vec3 p){\n    \n    // The terrain. By the way, when you scale coordinates, you have to scale back\n    // the distance value to keep things in check. I often forget this.\n    float ter = triTerrain(p.xz*scale)/scale; // The terrain.\n \n    const float hPert = .4; // Terrain height perturbation.\n    float fl = p.y  + (.5 - ter)*hPert;//*.25; // Adding it to a flat plane.\n\n    \n    hVal = (hVal - .5*scale)*hPert + .04;///scale; // Rescaling the height values to match the terrain perturbation.\n    \n    // The grid cell boundaries. As usual, the code looks more complicated than it is, but it's\n    // just grid vextex to grid vertex tubes.\n    vec3 q = p*scale;\n    q.xz = fract(q.xz); // Break space into squares along the XZ plane.\n        \n    // Grid line thickness.\n    const float lw = .04;\n \n    float ln = 1e5;\n    float ln2 = 1e5;\n    \n      if(diag<.5){\n        \n        #ifdef SHOW_HORIZONTAL\n        ln = min(ln, sdCapsule(q, vec3(0, hVal.x, 0), vec3(1, hVal.y, 0)));\n        ln = min(ln, sdCapsule(q, vec3(0, hVal.z, 1), vec3(1, hVal.x, 1)));\n        #endif\n        #ifdef SHOW_VERTICAL\n        ln =  min(ln, sdCapsule(q, vec3(0, hVal.x, 0), vec3(0, hVal.z, 1)));\n        ln = min(ln, sdCapsule(q, vec3(1, hVal.y, 0), vec3(1, hVal.x, 1)));\n        #endif\n        ln -= lw; // Line thickness.\n        #if SHOW_DIAGONAL > 0\n        // Diagonal.\n        ln2 = min(ln2, sdCapsule(q, vec3(0, hVal.z, 1), vec3(1, hVal.y, 0)) - lw);\n        #endif\n\n    }\n    else {\n        #ifdef SHOW_HORIZONTAL\n        ln = min(ln, sdCapsule(q, vec3(0, hVal.x, 0), vec3(1, hVal.y, 0)));\n        ln = min(ln, sdCapsule(q, vec3(0, hVal.y, 1), vec3(1, hVal.z , 1)));\n        #endif\n        #ifdef SHOW_VERTICAL\n    \tln = min(ln, sdCapsule(q, vec3(0, hVal.x, 0), vec3(0, hVal.y, 1)));\n        ln = min(ln, sdCapsule(q, vec3(1, hVal.y, 0), vec3(1, hVal.z, 1)));\n      \t#endif\n        ln -= lw; // Line thickness.\n        #if SHOW_DIAGONAL > 0\n        // Diagonal.\n        ln2 = min(ln2, sdCapsule(q, vec3(0, hVal.x, 0), vec3(1, hVal.z, 1)) - lw);\n        #endif\n    }\n    \n\n    \n    #ifdef SHOW_BALL_JOINS\n    // Ball joins. We've calculated another height value offset by half the grid in order to \n    // draw just one each - instead of four. It's a little hard to explain why but it has to\n    // do with repetitive cell boundaries.\n    float hgt = (hm(floor(p.xz*scale + .5)) - .5*scale)*hPert + .04;\n    vec2 offXZ = fract(p.xz*scale + .5) - .5;\n    // The metallic balls.\n    float sp = length(vec3(offXZ.x, abs(q.y - hgt), offXZ.y)) - .09; // Ball join size.\n    #else\n    float sp = 1e5;\n    #endif\n    \n    // Scaling the variables back.\n    ln /= scale;\n    ln2 /= scale;\n    sp /= scale;\n    \n     \n    #ifndef SMOOTH_QUAD\n    #if SHOW_DIAGONAL == 1\n    ln = min(ln, ln2); // Thinner.\n    //ln = min(ln, ln2 + .01); // Thinner.\n    #elif SHOW_DIAGONAL == 2\n    fl = max(fl, -ln2 + .004); // Innner grooves.\n    //fl = min(fl, ln2 + .01); // Outer join.\n    #endif\n    #endif\n    \n    \n    // Save the individual object IDs: With larger object numbers, Identifying inside the raymarching\n    // equation can add a lot of extra calls, so it's best to store them, then identify them outside.\n    // It's possible to do the vec2(dist, objID), but that can complicate things also.\n    vObjID = vec3(fl, ln, sp); // terrain, joiner lines, ball joints.\n    \n    \n    // Combining the mesh with the terrain.\n    return min(min(fl, ln), sp)*.75; //smin(fl, ln, .025);\n \n}\n\n \n\n// Standard raymarching routine.\nfloat trace(vec3 ro, vec3 rd){\n   \n    float t = 0.; //fract(sin(dot(rd, vec3(57, 111, 27)))*45758.5453)*.1; // Jitter.\n   \n    for (int i=0; i<96; i++){\n\n        float d = map(ro + rd*t);\n        \n        if(abs(d)<.001*(t*.125 + 1.) || t>FAR) break;\n        \n        t += d;  // Using more accuracy, in the first pass.\n    }\n    \n    return min(t, FAR);\n}\n\n\n/*\n// Tetrahedral normal - courtesy of IQ. I'm in saving mode, so the two \"map\" calls saved make\n// a difference. Also because of the random nature of the scene, the tetrahedral normal has the \n// same aesthetic effect as the regular - but more expensive - one, so it's an easy decision.\nvec3 getNormal(in vec3 p, float t)\n{  \n    vec2 e = vec2(-1., 1.)*0.001*min(1. + t, 5.);   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n*/\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\tconst vec2 e = vec2(.002, 0); //vec2(0.002*min(1. + t*.5, 2.), 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n\n\n// Basic soft shadows.\nfloat getShad(in vec3 ro, in vec3 n, in vec3 lp){\n\n    const float eps = .001;\n    \n\tfloat t = 0., sh = 1., dt;\n    \n    ro += n*eps*1.1;\n    \n    vec3 ld = (lp - ro);\n    float lDist = length(ld);\n    ld /= lDist;\n    \n    //t += hash31(ro + ld)*.005;\n    \n\tfor(int i=0; i<16; i++){\n        \n    \tdt = map(ro + ld*t);\n        \n        sh = min(sh, 12.*dt/t);\n         \n \t\tt += clamp(dt, .01, .5);\n        if(dt<0. || t>lDist){ break; } \n\t}\n\n    return min(max(sh, 0.) + 0.2, 1.0); \n}\n\n\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat cAO(in vec3 pos, in vec3 nor)\n{\n\tfloat sca = 2.0, occ = 0.0;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = 0.01 + float(i)*0.5/4.0;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D channel, vec3 p, vec3 n){\n    \n    n = max(abs(n) - .2, 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(channel, p.zy).xyz;\n    vec3 ty = texture(channel, p.xz).xyz;\n    vec3 tz = texture(channel, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 texBump( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.002, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n\n\n// Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n// example that explains it, if you require it.\nfloat n3D(in vec3 p){\n    \n\tconst vec3 s = vec3(57, 113, 27);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n\n\n// Very basic pseudo environment mapping... and by that, I mean it's fake. :) However, it \n// does give the impression that the surface is reflecting the surrounds in some way.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 envMap(vec3 p){\n    \n    p *= 2.;\n    p.xz += iTime*.5;\n    \n    float n3D2 = n3D(p*2.);\n   \n    // A bit of fBm.\n    float c = n3D(p)*.57 + n3D2*.28 + n3D(p*4.)*.15;\n    c = smoothstep(0.5, 1., c); // Putting in some dark space.\n    \n    p = vec3(c*.8, c*.9, c);//vec3(c*c, c*sqrt(c), c); // Bluish tinge.\n    \n    return mix(p.zxy, p, n3D2*.34 + .665); // Mixing in a bit of purple.\n\n}\n\n// Simple sinusoidal path, based on the z-distance.\nvec2 path(in float z){ float s = sin(z/36.)*cos(z/18.); return vec2(s*16., 0.); }\n \n// Recreating part of the distance function to obtain the segment IDs, which in turn is used\n// to create the blink effect.\nfloat lightBlink(vec2 p){\n    \n    // Unique identifier for the grid cell.\n    float rnd = hash21(floor(p));\n    \n    // Blink at random.\n    return smoothstep(.9, 1., sin(rnd*6.283 + iTime*2.)*.5 + .5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/min(iResolution.y, 800.);\n\t\n\t// Camera Setup.\n\tvec3 lk = vec3(0, 0, iTime*1.5);  // \"Look At\" position.\n\tvec3 ro = lk + vec3(0, 2.5, -2); // Camera position, doubling as the ray origin.\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro + vec3(0, 0, 3);// Put it a bit in front of the camera.\n\t\n\t// Sending the camera, \"look at,\" and two light vectors across the plain. The \"path\" function is \n\t// synchronized with the distance function.\n\tlk.xy += path(lk.z);\n\tro.xy += path(ro.z);\n\tlp.xy += path(lp.z);\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159/3.; // FOV - Field of view.\n    vec3 fwd = normalize(lk - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0, -fwd.x)); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    vec3 rd = normalize(fwd + (uv.x*rgt + uv.y*up)*FOV);\n    \n    // Swiveling the camera about the XY-plane (from left to right) when turning corners.\n    // Naturally, it's synchronized with the path in some kind of way.\n\trd.xy *= r2( path(lk.z).x/128.);\n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    //float svObjID = vObjID.x<vObjID.y && vObjID.x<vObjID.z? 0. : vObjID.y<vObjID.z? 1. : 2.;\n    float svObjID = vObjID.x < vObjID.y ? (vObjID.x < vObjID.z ? 0. : 2.) : (vObjID.y < vObjID.z ? 1. : 2.);\n   \t\n    // Initiate the scene color to black.\n\tvec3 sceneCol = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n         \n        // Texture scale factor.\n        float tSize0 = 1.;\n    \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp, t);\n        \n        \n        // Texture-based bump mapping. I've left it out for this.\n        //if(svObjID>.5) sn = texBump(iChannel0, sp*tSize0, sn, .005);\n\n    \t\n    \t// Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = getShad(sp, sn, lp);\n    \tfloat ao = cAO(sp, sn); // Ambient occlusion.\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1.2/(1. + lDist*lDist*0.05);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.0);\n        diff = pow(diff, 4.)*1.5; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 8.); \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow( clamp(dot(sn, rd) + 1., .0, 1.), 4.);\n        \n        \n        // I got a reminder looking at XT95's \"UI\" shader that there are cheaper ways\n        // to produce a hint of reflectivity than an actual reflective pass. :) \n        vec3 ref = reflect(rd, sn);\n        vec3 env = envMap(ref);\n        vec3 specCol = vec3(1, .95, .8);\n        \n        // Obtaining the texel color. \n\t    vec3 texCol;   \n\n        \n        if(svObjID<.5) { // Terrain texturing.\n            \n            // Tri-planar texturing - A little better than the 2D method below.\n            texCol = tex3D(iChannel0, sp*tSize0, sn);\n            //texCol = mix(texCol, tex3D(iChannel0, sp*tSize0*2. + .5, sn), .25);\n            // Just 2D XZ texturing. It works, but lacks a touch of depth.\n            //texCol = texture(iChannel0, sp.xz*tSize0).xyz; texCol *= texCol;\n            // Ramping up the saturation (hue intensity) a bit.\n            texCol = smoothstep(0., .7, texCol);\n            \n            /*\n            // A quick attempt to emulate the timber texture. Some of the nice\n            // patterns and hues are missing, so it needs more work, but it \n            // could definitely be done.\n            vec3 tsp = sp*vec3(1, 1, 6);\n            float ns = n3D(tsp*6.)*.57 + n3D(tsp*12.)*.28 + n3D(tsp*24.)*.15;\n            float ns2 = n3D(tsp*6.)*.66 + n3D(tsp*12.)*.34;\n            ns2 = mix(ns2, smoothstep(0., 1., ns2), .5);\n            float ns3 = clamp(sin(ns*6.2831) + .5, 0., 1.);\n            texCol = mix(vec3(1.3, .175, .0)/1.3, vec3(0), 1. - ns);\n            texCol = mix(texCol, vec3(.5, .05, .02), mix(ns, ns3, .5));\n            tsp = (sp + .5)*vec3(1, 1, 4);\n            float ns4 = n3D(tsp*6.)*.66 + n3D(tsp*18.)*.34;\n            texCol *= mix(ns4, smoothstep(0., .25, ns4 - .35), .5)*.7 + .65;\n            texCol *= n3D(sp*128.)*.8 + .6;//*.4 + .8;\n            //texCol = max(texCol, 0.);\n            */\n            \n            \n            //texCol *= max(triTerrain(sp.xz*scale)*.25 + .75, 0.); // Fake terrain shadowing.\n            //texCol = mix(texCol.xzy, texCol, max(triTerrain(sp.xz*scale)*.3 + .7, 0.)); // Hue shadowing.\n \n            \n            #ifdef BLINKING_LIGHTS\n            texCol = mix(texCol, mix(texCol, texCol.yyz, .35)*3.5, lightBlink(sp.xz*scale));\n            #endif\n            \n            // Lowering the terrain settings a bit.\n            \n            //specCol *= .5; \n            // Add some very subtle, almost imperceptible noise to the specular color. I wanted the\n            // surface to have a laminated sheen, but not completely smooth. I guess you could very\n            // subtly bump the surface, but this is much easier and more suited to the example.\n            specCol *= (n3D(sp*96.)*.66 + n3D(sp*192.)*.34)*.3 + .35;\n            \n            // Toning down the fake environment lighting on the terrain.\n            env *= texCol/1.5;\n            \n            // Subtle reflective hint of cherry.\n            texCol = mix(texCol, texCol.xzy, dot(ref, vec3(.15)));\n            \n        }\n        else { // The chrome lattice.\n            \n            // Tri-planar texturing\n            texCol = tex3D(iChannel0, sp*tSize0*2., sn);\n            // Taking out a lot of the red and darkening. Shiny chrome looking stuff tends\n            // to require less diffuse but higher reflectivity.\n            texCol = mix(texCol, texCol.xxx, .75)*.35;\n           \n            // Add some golden reflectivity to the ball joins.\n            if(svObjID==2.) env *= vec3(2.2, 1.7, .5);\n            \n            // Alternative gold lattice -- A bit gaudy. :)\n            //texCol *= vec3(8, 6, 4)/4.;\n            //env *= vec3(8, 6, 2)/4.;\n\n \n        } \n        \n\n        // Combining the above terms to procude the final color.\n        sceneCol += (texCol*(diff +  ao*.3 + vec3(1, .9, .7)*fre) + env*1.5 + specCol*spec*2.);\n        \n\n        // Shading. The shadows have minimal effect in this example, but I've cut down on \n        // shadow iterations and left them in.\n        sceneCol *= ao*atten*sh;\n        \n        \n\t\n\t}\n    \n    // Simple dark fog. It's almost black, but I left a speck of color in there to account for \n    // the reflective glow... Although, it still doesn't explain where it's coming from. :)\n    vec3 bg = mix(vec3(1, .5, .6), vec3(.1, .05, .025), clamp(rd.y + .75, 0., 1.));\n    bg = mix(bg, bg.xzy, rd.y*.5 + .5);\n    sceneCol = mix(sceneCol, bg, smoothstep(0., .95, t/FAR));\n\n    \n    // Rought gamma correction.\n\tfragColor = vec4(sqrt(clamp(sceneCol, 0., 1.)), 1.0);\n\t\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtycR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[4264, 4416, 4434, 4434, 4502], [4505, 4528, 4549, 4549, 4639], [5927, 6023, 6063, 6063, 6205], [6209, 6340, 6360, 6360, 6894], [7063, 7151, 7176, 7176, 10994], [11011, 11052, 11070, 11230, 14522], [14527, 14560, 14590, 14590, 14917], [15427, 15527, 15563, 15563, 15757], [15761, 15784, 15833, 15833, 16268], [16273, 16425, 16462, 16462, 16721], [16726, 16880, 16926, 16926, 17450], [17452, 17639, 17699, 17699, 18206], [18210, 18353, 18374, 18374, 18720], [18724, 19023, 19043, 19043, 19415], [19417, 19469, 19491, 19491, 19550], [19553, 19677, 19702, 19751, 19882], [19884, 19884, 19940, 19973, 27568]], "test": "error"}
